Title: LAS16- 111: Easing Access to ARM TrustZone   OP TEE and Raspberry Pi 3
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-111: Raspberry Pi3, OP-TEE and JTAG debugging
Speakers:
Date: September 26, 2016

★ Session Description ★
ARM TrustZone is a critical technology for securing IoT devices and systems. But awareness of TrustZone and its benefits lags within the maker community as well as among enterprises. The first step to solving this problem is lowering the cost of access. Sequitur Labs and Linaro have joined forces to address this problem by making a port of OP-TEE available on the Raspberry Pi 3. The presentation covers the value of TrustZone for securing IoT and how customers can learn more through this joint effort.

Embedded systems security remains a challenge for many developers. Awareness of mature, proven technologies such as ARM TrustZone is very low among the Maker community as well as among enterprises. As a result this foundational technology is largely being ignored as a security solution. Sequitur Labs and Linaro have taken an innovative approach combining an Open Source solution – OP-TEE with Raspberry Pi 3. The Raspberry Pi 3 is one of the world’s most popular platforms among device makers. Its value as an educational tool for learning about embedded systems development is proven.

Sequitur Labs have also enabled bare metal debugging via JTag on the Pi 3 enhancing the value of the Pi 3 as an educational tool for embedded systems development.

The presentation will focus on

ARM v8a architecture and instruction set
ARM Trusted Firmware
TrustZone and OP-TEE basics
JTAG and bare metal debugging the Raspberry Pi 3
★ Resources ★
Etherpad: pad.linaro.org/p/las16-111
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-111/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:07,220 --> 00:00:16,049
thanks everybody please bear with me I

00:00:11,820 --> 00:00:18,539
have a cold I'll try to speak slowly if

00:00:16,049 --> 00:00:20,970
I start losing my voice excuse me if I

00:00:18,539 --> 00:00:23,160
turn the mic off for a second and cough

00:00:20,970 --> 00:00:27,660
so I can regain sanity and pick up where

00:00:23,160 --> 00:00:29,900
I left off so people are probably

00:00:27,660 --> 00:00:31,859
wondering what is this all about we

00:00:29,900 --> 00:00:33,899
contemplate oook a look at the raspberry

00:00:31,859 --> 00:00:36,570
pi 3 when it was released earlier this

00:00:33,899 --> 00:00:39,480
year we've been working for over a year

00:00:36,570 --> 00:00:41,640
with opti and wondered if it was

00:00:39,480 --> 00:00:48,090
possible to actually make this off for a

00:00:41,640 --> 00:00:50,370
run on a raspberry pi 3 so cover a few

00:00:48,090 --> 00:00:51,930
topics so basically what's our

00:00:50,370 --> 00:00:53,430
motivation for doing this in the first

00:00:51,930 --> 00:00:55,860
place

00:00:53,430 --> 00:00:57,780
what was involved in actually doing the

00:00:55,860 --> 00:01:00,719
port so what was it with the undertaking

00:00:57,780 --> 00:01:03,439
like what's the availability of the

00:01:00,719 --> 00:01:05,670
components all of the pieces involved

00:01:03,439 --> 00:01:08,250
and then we'll walk through some of the

00:01:05,670 --> 00:01:10,710
core aspects of what the implementation

00:01:08,250 --> 00:01:13,590
means sort of what's there and what

00:01:10,710 --> 00:01:15,450
isn't there and then an overview of what

00:01:13,590 --> 00:01:17,549
the trust zone is really about because

00:01:15,450 --> 00:01:18,900
although you may see that label it

00:01:17,549 --> 00:01:20,610
doesn't necessarily mean that

00:01:18,900 --> 00:01:22,320
everything's in place so we'll give an

00:01:20,610 --> 00:01:28,650
overview of typically what we expect to

00:01:22,320 --> 00:01:29,939
find on a complete implementation so we

00:01:28,650 --> 00:01:32,159
look at the motivation and

00:01:29,939 --> 00:01:34,259
next-generation devices they need to

00:01:32,159 --> 00:01:36,689
have security designed in the systems

00:01:34,259 --> 00:01:38,579
need to have it designed in I think

00:01:36,689 --> 00:01:40,890
we're past the point in systems on ship

00:01:38,579 --> 00:01:42,720
where it's now our requirement are no

00:01:40,890 --> 00:01:45,689
longer required to bolt on additional

00:01:42,720 --> 00:01:46,860
capable chips or other parts at this

00:01:45,689 --> 00:01:48,899
point we're looking from several

00:01:46,860 --> 00:01:51,810
manufacturers they call it fourth fifth

00:01:48,899 --> 00:01:53,820
or sixth generation implementations were

00:01:51,810 --> 00:01:56,280
any security feature that was previously

00:01:53,820 --> 00:01:58,649
in a TPM or a high security device is

00:01:56,280 --> 00:02:01,229
now starting to appear in sub $10

00:01:58,649 --> 00:02:02,909
system-on-chip parts for example used in

00:02:01,229 --> 00:02:05,189
payment terminals so some very high-end

00:02:02,909 --> 00:02:06,780
capabilities for security features now

00:02:05,189 --> 00:02:10,470
appearing on what I say our commodity

00:02:06,780 --> 00:02:12,030
parts the trusted zone of the trusted

00:02:10,470 --> 00:02:12,540
execution environment are very quickly

00:02:12,030 --> 00:02:15,420
because

00:02:12,540 --> 00:02:17,250
a standard for chip level security so

00:02:15,420 --> 00:02:19,920
when you think of the broad deployment

00:02:17,250 --> 00:02:21,689
in terms of mobile devices set-top boxes

00:02:19,920 --> 00:02:23,989
smart televisions these are very very

00:02:21,689 --> 00:02:27,000
commonly in use going back several years

00:02:23,989 --> 00:02:28,470
and one of the biggest challenges we

00:02:27,000 --> 00:02:30,870
find though in trying to bring this a to

00:02:28,470 --> 00:02:34,170
larger embedded space outside of mobile

00:02:30,870 --> 00:02:35,849
is awareness within the maker community

00:02:34,170 --> 00:02:37,860
themselves and within a lot of the

00:02:35,849 --> 00:02:39,870
manufacturers they have no idea what

00:02:37,860 --> 00:02:41,340
this technology is either from the

00:02:39,870 --> 00:02:45,049
standpoint of the hardware or the

00:02:41,340 --> 00:02:47,010
software our firmware that it entails so

00:02:45,049 --> 00:02:48,180
unfortunately where this leaves you the

00:02:47,010 --> 00:02:50,040
only people that understand the

00:02:48,180 --> 00:02:51,750
technology are hardware and software

00:02:50,040 --> 00:02:53,280
professionals that really know how to

00:02:51,750 --> 00:02:55,349
weight their way through a data sheet or

00:02:53,280 --> 00:02:57,120
understand the details of the stock and

00:02:55,349 --> 00:02:59,069
because a lot of this has been sort of

00:02:57,120 --> 00:03:01,430
kept under non-disclosure and wraps it's

00:02:59,069 --> 00:03:04,349
really not a well understood space and

00:03:01,430 --> 00:03:05,970
even even to build this you have to have

00:03:04,349 --> 00:03:07,650
a very deep understanding of the

00:03:05,970 --> 00:03:10,319
hardware and the software fundamentals

00:03:07,650 --> 00:03:12,180
of the systems as well so the objective

00:03:10,319 --> 00:03:14,010
for this port is really to make this all

00:03:12,180 --> 00:03:19,319
accessible and make it economically

00:03:14,010 --> 00:03:22,319
accessible so what's our motivation the

00:03:19,319 --> 00:03:25,410
Raspberry Pi is really inexpensive in no

00:03:22,319 --> 00:03:27,269
volume it's a whopping $35 there's very

00:03:25,410 --> 00:03:29,280
good support for it so the board support

00:03:27,269 --> 00:03:32,910
package from the Raspberry Pi 4 from the

00:03:29,280 --> 00:03:36,510
foundation it's a quad core a 53 v8 a

00:03:32,910 --> 00:03:39,299
part so it's a recent arm core so a very

00:03:36,510 --> 00:03:41,340
good learning platform the starting

00:03:39,299 --> 00:03:43,319
point for us was back in March when

00:03:41,340 --> 00:03:46,319
initial work had been done to port a

00:03:43,319 --> 00:03:47,760
64-bit stock to the Raspberry Pi 3 so we

00:03:46,319 --> 00:03:51,180
watched closely to see what was being

00:03:47,760 --> 00:03:53,069
done we poked around the startup code at

00:03:51,180 --> 00:03:56,989
this point they'd step sideways from the

00:03:53,069 --> 00:03:59,819
normal the normal boot mode for the PI 3

00:03:56,989 --> 00:04:01,739
we poked around and it looked like there

00:03:59,819 --> 00:04:04,980
might be some trustzone capabilities or

00:04:01,739 --> 00:04:06,720
features available on the device search

00:04:04,980 --> 00:04:09,479
for JTAG capabilities for low-level

00:04:06,720 --> 00:04:11,340
debug and found in previous versions

00:04:09,479 --> 00:04:14,129
that there basically been multiplexer

00:04:11,340 --> 00:04:15,930
pin setups for the the 40 pin header on

00:04:14,129 --> 00:04:17,310
the Raspberry Pi and started digging

00:04:15,930 --> 00:04:19,289
around to see if would be possible to do

00:04:17,310 --> 00:04:20,639
this on the PI 3 as well our intention

00:04:19,289 --> 00:04:22,320
was to make it available so that you

00:04:20,639 --> 00:04:25,530
could bare metal debug on the PI in all

00:04:22,320 --> 00:04:26,040
domains and it appeared if a port of up

00:04:25,530 --> 00:04:32,130
to you might

00:04:26,040 --> 00:04:35,130
infeasible so the work was done largely

00:04:32,130 --> 00:04:37,980
late March early April looking through

00:04:35,130 --> 00:04:40,800
what was happening in several of the

00:04:37,980 --> 00:04:42,780
raspberry pi forest surrounding AR 64 if

00:04:40,800 --> 00:04:44,370
you go online you'll find sort of the

00:04:42,780 --> 00:04:47,010
initial work initially importing new

00:04:44,370 --> 00:04:51,000
boot and the port initial poor devil in

00:04:47,010 --> 00:04:53,400
a 64-bit Linux kernel digging into you

00:04:51,000 --> 00:04:55,320
boot naturally they were stepping you

00:04:53,400 --> 00:04:57,270
boot was bringing the cores up in the

00:04:55,320 --> 00:04:59,580
wrong mode from the standpoint of

00:04:57,270 --> 00:05:01,890
launching into secure world so a first

00:04:59,580 --> 00:05:03,690
step was basically modified that you

00:05:01,890 --> 00:05:05,430
modify that you boot stubs or the pre

00:05:03,690 --> 00:05:07,020
boot stubs to bring you boot up in the

00:05:05,430 --> 00:05:09,990
right mode so that we can then begin the

00:05:07,020 --> 00:05:12,120
porn and do the correct handoff and our

00:05:09,990 --> 00:05:14,250
initial objective was to get a 64-bit

00:05:12,120 --> 00:05:16,230
Ubuntu environment up so we use the

00:05:14,250 --> 00:05:19,260
linear own native Ubuntu environment

00:05:16,230 --> 00:05:20,730
just dropped it in place but details of

00:05:19,260 --> 00:05:22,560
all of this are actually in a separate

00:05:20,730 --> 00:05:24,150
PowerPoint or a separate presentation if

00:05:22,560 --> 00:05:30,140
anybody's interested we can make that

00:05:24,150 --> 00:05:32,990
available some of the challenges so I

00:05:30,140 --> 00:05:36,120
did the port myself in a weekend and

00:05:32,990 --> 00:05:37,440
typically this means for any SOC going

00:05:36,120 --> 00:05:39,180
to a vendor signing non-disclosure

00:05:37,440 --> 00:05:40,740
agreements then signing away the first

00:05:39,180 --> 00:05:41,910
bone to get the other not to get the

00:05:40,740 --> 00:05:43,020
other documents that dinner will give

00:05:41,910 --> 00:05:44,130
you just because you have a

00:05:43,020 --> 00:05:45,960
nondisclosure agreement

00:05:44,130 --> 00:05:48,030
to learn to both the underlying details

00:05:45,960 --> 00:05:50,430
of the SOC for the Raspberry Pi

00:05:48,030 --> 00:05:52,800
effectively there is no data sheet so

00:05:50,430 --> 00:05:54,900
what's inside of that is a bit of a

00:05:52,800 --> 00:05:56,370
mystery it took guesswork to come up

00:05:54,900 --> 00:05:58,230
with a memory map that was actually

00:05:56,370 --> 00:06:00,210
workable and about six iterations of

00:05:58,230 --> 00:06:04,020
guessing to find an address space that

00:06:00,210 --> 00:06:05,520
we could work with in memory and the

00:06:04,020 --> 00:06:07,560
sort of the other source of information

00:06:05,520 --> 00:06:11,300
is dive into the source code or the

00:06:07,560 --> 00:06:15,720
expression we use is use the source Luke

00:06:11,300 --> 00:06:18,300
so the approach game we have details in

00:06:15,720 --> 00:06:20,190
them and the other write-up was to

00:06:18,300 --> 00:06:23,880
modify the boot stuff to leave the cores

00:06:20,190 --> 00:06:26,310
in secure mode modifications to you boot

00:06:23,880 --> 00:06:29,790
to handoff to arm trusted firmware

00:06:26,310 --> 00:06:31,560
instead of to the Linux kernel we also

00:06:29,790 --> 00:06:33,150
looking at people were asking us if we

00:06:31,560 --> 00:06:35,220
would port all of the arm trusted

00:06:33,150 --> 00:06:37,620
firmware and reading through the

00:06:35,220 --> 00:06:38,260
documentation it became evident that ATF

00:06:37,620 --> 00:06:39,580
was

00:06:38,260 --> 00:06:42,160
they are protected so that it be

00:06:39,580 --> 00:06:45,280
possible to have an alternate boot chain

00:06:42,160 --> 00:06:47,620
lead to be l-31 so next to the second

00:06:45,280 --> 00:06:49,750
last phase and we worked out how to

00:06:47,620 --> 00:06:51,940
basically do a handoff from you boot to

00:06:49,750 --> 00:06:54,850
be l-31 to hand off to the opti service

00:06:51,940 --> 00:06:58,030
provider so modifications to be to be

00:06:54,850 --> 00:06:59,890
l-31 modification to the memory maps so

00:06:58,030 --> 00:07:01,690
because there's effectively no secure

00:06:59,890 --> 00:07:04,300
memory we create a hole in the middle of

00:07:01,690 --> 00:07:08,920
physical memory and drop all of the the

00:07:04,300 --> 00:07:11,050
secured stock in there in you boot we do

00:07:08,920 --> 00:07:13,660
the pin multiplexing so that JTAG is

00:07:11,050 --> 00:07:15,520
enabled very early so when the clip

00:07:13,660 --> 00:07:17,380
indicate that we've assembled as soon as

00:07:15,520 --> 00:07:20,470
the you boot prompt appears JTAG is

00:07:17,380 --> 00:07:22,210
already enabled on the board we also

00:07:20,470 --> 00:07:25,660
took work that we did last year which

00:07:22,210 --> 00:07:28,810
was basically open OCD support for arch

00:07:25,660 --> 00:07:30,670
64 for our v8 and worked out the

00:07:28,810 --> 00:07:32,740
configuration file for the Raspberry Pi

00:07:30,670 --> 00:07:34,750
so that you can actually use open OCD

00:07:32,740 --> 00:07:37,510
and an inexpensive JTAG interface to

00:07:34,750 --> 00:07:39,910
debug the board and they reported over

00:07:37,510 --> 00:07:41,620
opti that was actually the easy part the

00:07:39,910 --> 00:07:43,540
hardest part was the memory map and

00:07:41,620 --> 00:07:45,780
sorting out the the serial port

00:07:43,540 --> 00:07:45,780
interface

00:07:53,340 --> 00:07:58,900
off the top of my head I don't recall I

00:07:56,040 --> 00:08:01,630
don't remember its I basically derived

00:07:58,900 --> 00:08:04,200
it from another Fork so it's but it's

00:08:01,630 --> 00:08:06,730
the I looked at a more recent version I

00:08:04,200 --> 00:08:08,350
don't think the hand off has changed the

00:08:06,730 --> 00:08:10,780
effectively the setup for it goes in

00:08:08,350 --> 00:08:12,430
passed into register 0 and it's a matter

00:08:10,780 --> 00:08:13,870
of populating the structures for the

00:08:12,430 --> 00:08:16,480
handoff to the secure and not secure

00:08:13,870 --> 00:08:17,800
domains but we did not there was only

00:08:16,480 --> 00:08:19,600
one place we had to make a change

00:08:17,800 --> 00:08:21,370
basically one of their debug read one of

00:08:19,600 --> 00:08:23,980
the debug settings they have was

00:08:21,370 --> 00:08:25,960
conflicting with the core clustering and

00:08:23,980 --> 00:08:28,210
with debug enabled so we just turned

00:08:25,960 --> 00:08:37,870
that off I'm not gonna say it's perfect

00:08:28,210 --> 00:08:40,060
go ahead because I really didn't want to

00:08:37,870 --> 00:08:41,919
rewrite BL one and all the way forward

00:08:40,060 --> 00:08:44,350
when all the drivers are already done I

00:08:41,919 --> 00:08:47,940
don't think I could rewrite all of the

00:08:44,350 --> 00:08:50,140
first three stages of ATF and a weekend

00:08:47,940 --> 00:08:51,430
there's a lot there's a lot of mystery

00:08:50,140 --> 00:08:53,100
alert to get you boot in the raspberry

00:08:51,430 --> 00:08:55,690
pi and it was like I'm not going there

00:08:53,100 --> 00:08:57,400
there's a lot of work the objective was

00:08:55,690 --> 00:08:59,140
to get to the opti and the ability to

00:08:57,400 --> 00:09:01,420
develop their rather than to rewrite the

00:08:59,140 --> 00:09:03,190
ATF report it if somebody's willing to

00:09:01,420 --> 00:09:05,560
do that go for it happy to help

00:09:03,190 --> 00:09:06,910
happy to help with any way we can and at

00:09:05,560 --> 00:09:08,380
this point I think you probably could

00:09:06,910 --> 00:09:10,120
given that you have you boot handing off

00:09:08,380 --> 00:09:17,680
to ATF on that we could debug it really

00:09:10,120 --> 00:09:19,810
easily just set it up so anyway the

00:09:17,680 --> 00:09:22,330
Raspberry Pi 3 the thing we discovered

00:09:19,810 --> 00:09:25,540
is it implements all of the core

00:09:22,330 --> 00:09:29,200
exception States so in the art so in the

00:09:25,540 --> 00:09:34,240
v8 a nomenclature we have all of L 0 1 2

00:09:29,200 --> 00:09:37,270
& 3 0 & 1 on the secure side 0 1 2 & 3

00:09:34,240 --> 00:09:39,670
down in the middle and 0 1 & 2 in the

00:09:37,270 --> 00:09:41,560
non-secure world unfortunately the

00:09:39,670 --> 00:09:44,560
signal that's propagated off the core so

00:09:41,560 --> 00:09:47,080
the security say signal is left dangling

00:09:44,560 --> 00:09:48,400
in the other it goes nowhere so the

00:09:47,080 --> 00:09:49,960
course can't wrap through all of the

00:09:48,400 --> 00:09:52,150
exceptions you have the ability to

00:09:49,960 --> 00:09:53,980
execute the code but there's absolutely

00:09:52,150 --> 00:09:56,710
nothing secure but the bus fabric of the

00:09:53,980 --> 00:09:58,120
device as far as we know the cores are

00:09:56,710 --> 00:10:00,040
also not the first thing that boots from

00:09:58,120 --> 00:10:01,420
our understanding it's actually the GPU

00:10:00,040 --> 00:10:01,990
that boots first and hands off to the

00:10:01,420 --> 00:10:03,490
arm cars

00:10:01,990 --> 00:10:05,830
people have already asked can you

00:10:03,490 --> 00:10:07,690
implement secure boot we go not as far

00:10:05,830 --> 00:10:12,670
as we know no indication that it's

00:10:07,690 --> 00:10:14,050
possible one thing we did find actually

00:10:12,670 --> 00:10:15,640
in the course of doing the port is none

00:10:14,050 --> 00:10:17,290
of the crypto accelerator instructions

00:10:15,640 --> 00:10:19,330
are implemented in v8 so those are

00:10:17,290 --> 00:10:21,010
optional they'll had to be disabled and

00:10:19,330 --> 00:10:22,510
you learn very quickly in bringing an ex

00:10:21,010 --> 00:10:24,899
test that it will hard it will hard

00:10:22,510 --> 00:10:28,120
fault on instructions that are undefined

00:10:24,899 --> 00:10:32,529
so easy easy to track down and discover

00:10:28,120 --> 00:10:34,630
was those instructions are missing there

00:10:32,529 --> 00:10:36,040
was nothing nothing in the Linux device

00:10:34,630 --> 00:10:37,750
tree source so we did a lot of digging

00:10:36,040 --> 00:10:39,700
trying to understand what the IP looked

00:10:37,750 --> 00:10:41,800
like on the device there was nothing

00:10:39,700 --> 00:10:43,360
show any indication of any security IP

00:10:41,800 --> 00:10:46,300
so no mention of an address space

00:10:43,360 --> 00:10:49,660
controller protection controller the

00:10:46,300 --> 00:10:51,640
interrupt controllers proprietary sort

00:10:49,660 --> 00:10:53,890
of another giveaway was that F IQ was

00:10:51,640 --> 00:10:56,290
being used by I think a USB or audio

00:10:53,890 --> 00:10:57,970
component to reduce latency and as soon

00:10:56,290 --> 00:10:59,589
as we brung as soon as we brought Linux

00:10:57,970 --> 00:11:02,290
up in the normal world with opti in the

00:10:59,589 --> 00:11:04,480
backend f IQ fired and the T went into

00:11:02,290 --> 00:11:06,579
an infinite loop because tha's not

00:11:04,480 --> 00:11:08,649
supposed to go to the normal world it's

00:11:06,579 --> 00:11:10,779
so easy to fix that we found no

00:11:08,649 --> 00:11:12,640
indication of securable memory so it's

00:11:10,779 --> 00:11:15,250
basically one big flat space where the

00:11:12,640 --> 00:11:16,720
region carved in the center but the

00:11:15,250 --> 00:11:18,160
really good part and they and the last

00:11:16,720 --> 00:11:19,390
piece I guess they're really there's

00:11:18,160 --> 00:11:21,310
there's no signal fact there's no

00:11:19,390 --> 00:11:22,779
surrogate signal propagation so

00:11:21,310 --> 00:11:24,520
everything that you would want to do to

00:11:22,779 --> 00:11:27,060
try and carve out and isolated secure

00:11:24,520 --> 00:11:29,950
domain is just not present on the device

00:11:27,060 --> 00:11:32,860
so their conclusion is it's a trust and

00:11:29,950 --> 00:11:35,529
implementation but it's not secure but

00:11:32,860 --> 00:11:38,230
the really good part is it's so unlocked

00:11:35,529 --> 00:11:40,120
and so wide open then it's phenomenal

00:11:38,230 --> 00:11:42,339
for education and phenomenal for debug

00:11:40,120 --> 00:11:43,870
and development you can single step with

00:11:42,339 --> 00:11:45,790
practically free Hardware through the

00:11:43,870 --> 00:11:47,980
exception levels and actually see what

00:11:45,790 --> 00:11:50,440
the code is doing so for us this was a

00:11:47,980 --> 00:11:53,620
this was really a great help because

00:11:50,440 --> 00:11:55,329
often at the hardware level signals can

00:11:53,620 --> 00:11:56,589
take interrupts have interesting Layton

00:11:55,329 --> 00:11:58,120
sees and even trying to step across

00:11:56,589 --> 00:12:00,160
boundaries with the debugger attached

00:11:58,120 --> 00:12:03,360
sometimes doesn't work on this device

00:12:00,160 --> 00:12:03,360
you can walk right through the code

00:12:09,519 --> 00:12:15,260
so availability of the kit I sort of

00:12:12,980 --> 00:12:16,040
cobbled this together and hand it off

00:12:15,260 --> 00:12:17,870
with Alcala

00:12:16,040 --> 00:12:22,130
bit of a wheelbarrow full of stuff to

00:12:17,870 --> 00:12:24,320
yoke in back he took this I think it was

00:12:22,130 --> 00:12:26,510
like 27 s get steps in a script to build

00:12:24,320 --> 00:12:29,600
the whole stack up and pull together a

00:12:26,510 --> 00:12:31,160
repo build with a busybox stack he went

00:12:29,600 --> 00:12:32,899
a lot further than that and I'd say is

00:12:31,160 --> 00:12:35,779
PO be the slickest development

00:12:32,899 --> 00:12:38,750
environment I've seen I didn't know that

00:12:35,779 --> 00:12:40,519
you boots supported TFTP boot so he has

00:12:38,750 --> 00:12:45,050
a configuration of what's coming in

00:12:40,519 --> 00:12:49,190
indle enero build is effectively you you

00:12:45,050 --> 00:12:51,649
boot to TFTP with with the file system

00:12:49,190 --> 00:12:54,320
for the raspberry pi over NFS and this

00:12:51,649 --> 00:12:56,209
basically means you can boot without you

00:12:54,320 --> 00:12:58,100
can basically boot and develop entirely

00:12:56,209 --> 00:13:00,769
off the host development machine with

00:12:58,100 --> 00:13:02,449
minimal cycle time so no fussing with

00:13:00,769 --> 00:13:04,100
wires or power buttons or anything like

00:13:02,449 --> 00:13:06,290
that or having to pull SD card to

00:13:04,100 --> 00:13:08,810
reflash anything you can run it entirely

00:13:06,290 --> 00:13:10,310
off the host file system so for cycle

00:13:08,810 --> 00:13:12,110
time and ta development or core

00:13:10,310 --> 00:13:15,170
development this is this is really a

00:13:12,110 --> 00:13:17,720
brilliant move it's extremely fast that

00:13:15,170 --> 00:13:22,100
stock is all art 64 but that's fairly

00:13:17,720 --> 00:13:24,680
easy fairly easy to change in a little

00:13:22,100 --> 00:13:26,180
over a week we're actually hosting we're

00:13:24,680 --> 00:13:28,130
providing the hardware for a global

00:13:26,180 --> 00:13:32,360
platform key hackathon in the Bay Area

00:13:28,130 --> 00:13:35,540
and was was suggested to us that perhaps

00:13:32,360 --> 00:13:37,940
we could run a 32-bit stock on the board

00:13:35,540 --> 00:13:41,690
so what we've done is basically taken

00:13:37,940 --> 00:13:43,760
the art 64 Linux it's built with the

00:13:41,690 --> 00:13:47,329
config compact flag which allows us to

00:13:43,760 --> 00:13:49,399
run either 32 or 64-bit runtime we took

00:13:47,329 --> 00:13:53,660
the raspbian stock out of the box

00:13:49,399 --> 00:13:56,690
raspbian 32 billed for arm d7 added in

00:13:53,660 --> 00:14:00,110
the components from opti so the driver

00:13:56,690 --> 00:14:03,709
in the kernel the T supplicant and the

00:14:00,110 --> 00:14:06,290
set of TAS and drop this onto the

00:14:03,709 --> 00:14:08,810
Raspberry Pi the kernel complains an

00:14:06,290 --> 00:14:10,730
awful lot about deprecated instructions

00:14:08,810 --> 00:14:13,899
from v7 because we didn't recompile but

00:14:10,730 --> 00:14:17,690
it works fine we built a VirtualBox

00:14:13,899 --> 00:14:19,650
Ubuntu image that includes the full all

00:14:17,690 --> 00:14:23,460
source code for the stock

00:14:19,650 --> 00:14:27,060
and in all source code including the

00:14:23,460 --> 00:14:29,700
open OCD port and the whole kit itself

00:14:27,060 --> 00:14:32,340
consists of the Raspberry Pi 3 a buss

00:14:29,700 --> 00:14:34,140
blaster debug cable a micro SD card and

00:14:32,340 --> 00:14:36,720
I think the total cost is public in the

00:14:34,140 --> 00:14:38,370
$70 range for everything so pretty

00:14:36,720 --> 00:14:44,820
pretty hard to beat including the debug

00:14:38,370 --> 00:14:46,620
interface the focus itself

00:14:44,820 --> 00:14:49,560
so the linux dock itself the PI is

00:14:46,620 --> 00:14:51,180
really in widespread use it's great for

00:14:49,560 --> 00:14:54,270
development and from our perspective

00:14:51,180 --> 00:14:56,550
it's not a mobile device we we have a

00:14:54,270 --> 00:14:58,110
license to deploy trusted applications

00:14:56,550 --> 00:15:01,170
on mobile devices and we're totally

00:14:58,110 --> 00:15:02,340
familiar with that ecosystem we look at

00:15:01,170 --> 00:15:04,350
the we look at something like the

00:15:02,340 --> 00:15:06,630
Raspberry Pi has meant for calling other

00:15:04,350 --> 00:15:08,550
edge other nodes other smart devices a

00:15:06,630 --> 00:15:10,650
great platform to learn and develop for

00:15:08,550 --> 00:15:12,660
those so very it's a very different

00:15:10,650 --> 00:15:13,980
ecosystem very different use case very

00:15:12,660 --> 00:15:17,850
different set of applications than

00:15:13,980 --> 00:15:19,650
mobile and for opti I'd say the focus is

00:15:17,850 --> 00:15:24,060
much bigger than mobile we call it the

00:15:19,650 --> 00:15:29,040
other 90% of the market so fault

00:15:24,060 --> 00:15:30,900
fundamentally the the applications that

00:15:29,040 --> 00:15:33,780
are they need to be built go well beyond

00:15:30,900 --> 00:15:35,280
save DRM and payments so these are sort

00:15:33,780 --> 00:15:37,020
of the obvious use cases if you're

00:15:35,280 --> 00:15:39,330
deploying millions of applications out

00:15:37,020 --> 00:15:41,550
on mobile handsets but when you think of

00:15:39,330 --> 00:15:43,680
edge nodes gateways smart devices and a

00:15:41,550 --> 00:15:46,470
variety of other things there's a good

00:15:43,680 --> 00:15:47,790
chance that you know a power meter is

00:15:46,470 --> 00:15:49,170
not going to be taking payments from

00:15:47,790 --> 00:15:51,570
your credit card or has a touch

00:15:49,170 --> 00:15:53,010
interface I just think of the other use

00:15:51,570 --> 00:15:58,080
cases for this and what can be done with

00:15:53,010 --> 00:16:00,260
this cake with the technology so I'm

00:15:58,080 --> 00:16:02,490
gonna walk through some some background

00:16:00,260 --> 00:16:03,810
people ask us what you know what's the

00:16:02,490 --> 00:16:07,680
point of security what's it all about

00:16:03,810 --> 00:16:09,570
it's really about creating it's really

00:16:07,680 --> 00:16:12,650
about creating a boundary security

00:16:09,570 --> 00:16:12,650
happens in a discontinuity

00:16:13,510 --> 00:16:20,710
oh because for people that already used

00:16:18,760 --> 00:16:22,870
the Raspberry Pi we give them something

00:16:20,710 --> 00:16:24,700
that they already know so there's

00:16:22,870 --> 00:16:27,340
nothing stopping them they have they can

00:16:24,700 --> 00:16:29,770
have their they can have 32 or 64 and

00:16:27,340 --> 00:16:32,650
actually we've taken the raspbian 32

00:16:29,770 --> 00:16:35,830
system and dropped in 64-bit shared

00:16:32,650 --> 00:16:37,300
libraries and a 64-bit loader and run

00:16:35,830 --> 00:16:39,670
them both at the same time in the same

00:16:37,300 --> 00:16:41,140
place the kernel doesn't care just make

00:16:39,670 --> 00:16:44,050
sure if you're building kernel modules

00:16:41,140 --> 00:16:46,260
they're build 64 bits so it's it's

00:16:44,050 --> 00:16:48,850
really it's up to you and I mean that

00:16:46,260 --> 00:16:51,160
we've done them both so Ubuntu how is

00:16:48,850 --> 00:16:54,250
that or certainly narrow has a 64 bit

00:16:51,160 --> 00:16:55,630
stock you can run the 64 bit stock at

00:16:54,250 --> 00:16:57,310
fur Depot for debugging in the normal

00:16:55,630 --> 00:16:59,860
world you can run the native gdb tools

00:16:57,310 --> 00:17:01,510
on the software on the board so he says

00:16:59,860 --> 00:17:04,120
it's more than familiar to people when

00:17:01,510 --> 00:17:05,680
they turn the PI on with an HDMI with

00:17:04,120 --> 00:17:07,720
HDMI plugged in they will get the

00:17:05,680 --> 00:17:12,280
standard raspbian experience you want to

00:17:07,720 --> 00:17:14,800
call it that so we call us the problems

00:17:12,280 --> 00:17:16,540
of it makes a big flat space the

00:17:14,800 --> 00:17:18,670
security has to be designed in and the

00:17:16,540 --> 00:17:21,160
objective is to create isolation and a

00:17:18,670 --> 00:17:23,320
boundary so security happens in a

00:17:21,160 --> 00:17:24,760
discontinuity in the system and the

00:17:23,320 --> 00:17:25,930
trick is is there has to be some

00:17:24,760 --> 00:17:29,080
mechanism that enforces that

00:17:25,930 --> 00:17:30,970
discontinuity so the objective is to

00:17:29,080 --> 00:17:32,740
create a hard boundary so something

00:17:30,970 --> 00:17:34,660
that's Hardware enforced not just you

00:17:32,740 --> 00:17:36,160
know an address not something magic like

00:17:34,660 --> 00:17:39,040
an address there's got to be a signal

00:17:36,160 --> 00:17:40,600
behind it so there have to be at least

00:17:39,040 --> 00:17:42,100
two distinct domains they can be

00:17:40,600 --> 00:17:43,930
partitioned beyond that so call it's

00:17:42,100 --> 00:17:45,340
secure and not secure and when those

00:17:43,930 --> 00:17:49,240
domains you should have the ability to

00:17:45,340 --> 00:17:50,680
assign code resources functions without

00:17:49,240 --> 00:17:52,990
requiring some external security

00:17:50,680 --> 00:17:55,030
component so if you look at the the

00:17:52,990 --> 00:17:57,730
architecture of some of the say an

00:17:55,030 --> 00:18:00,790
advanced SOC today you'll find that

00:17:57,730 --> 00:18:02,290
there's no shortage of on chip IP that's

00:18:00,790 --> 00:18:05,080
evolved over the course of probably the

00:18:02,290 --> 00:18:06,580
past 20 years and there I'd say much

00:18:05,080 --> 00:18:09,250
more highly evolved in an average

00:18:06,580 --> 00:18:10,690
desktop PC so because well beyond the

00:18:09,250 --> 00:18:15,370
capability of what's in that box for

00:18:10,690 --> 00:18:18,010
circle one of the objectives from our

00:18:15,370 --> 00:18:20,320
perspective is to isolate management and

00:18:18,010 --> 00:18:23,530
control planes so when you think of the

00:18:20,320 --> 00:18:25,180
critical functions of a system isolate

00:18:23,530 --> 00:18:25,850
management and controlling the critical

00:18:25,180 --> 00:18:28,700
functions

00:18:25,850 --> 00:18:30,890
and treat by definition so the operating

00:18:28,700 --> 00:18:33,110
system such as Linux it's not secure and

00:18:30,890 --> 00:18:34,760
it's not trustworthy we don't care for

00:18:33,110 --> 00:18:35,780
the network stack gets popped we don't

00:18:34,760 --> 00:18:38,000
care if the normal world gets

00:18:35,780 --> 00:18:39,860
compromised the whole objective is that

00:18:38,000 --> 00:18:42,500
what's going on in the secure domain in

00:18:39,860 --> 00:18:45,590
terms of interaction with say actuators

00:18:42,500 --> 00:18:47,240
or sensors and the control of those is

00:18:45,590 --> 00:18:49,820
isolated from anything that can happen

00:18:47,240 --> 00:18:51,410
in the normal world the point is don't

00:18:49,820 --> 00:18:52,700
don't have to trust the network and

00:18:51,410 --> 00:18:54,380
don't have to trust the application

00:18:52,700 --> 00:18:56,030
stack but you do want the core

00:18:54,380 --> 00:18:58,429
components the critical components to be

00:18:56,030 --> 00:18:59,750
trustworthy so it starts at the bottom

00:18:58,429 --> 00:19:03,370
and build up and it's really hard to

00:18:59,750 --> 00:19:03,370
build this on it has to be designed in

00:19:06,760 --> 00:19:13,490
so we look at it trust owns not a

00:19:09,200 --> 00:19:15,799
marketing term it's a strategy the the

00:19:13,490 --> 00:19:17,480
beauty of it is the security's let's

00:19:15,799 --> 00:19:19,789
call it it's the security state not a

00:19:17,480 --> 00:19:22,970
mode it's orthogonal to the processor

00:19:19,789 --> 00:19:25,460
mode so the processor runs either secure

00:19:22,970 --> 00:19:26,929
or not secure in each of those states it

00:19:25,460 --> 00:19:29,780
has the various modes of support

00:19:26,929 --> 00:19:32,120
operating systems and exceptions there

00:19:29,780 --> 00:19:33,860
are two states secure and non-secure the

00:19:32,120 --> 00:19:36,169
physical domains themselves when you

00:19:33,860 --> 00:19:38,539
split between those two states see if

00:19:36,169 --> 00:19:40,580
memory on an off chip memory the ability

00:19:38,539 --> 00:19:42,559
to partition and manage that your bus

00:19:40,580 --> 00:19:44,870
masters and slaves and there must be a

00:19:42,559 --> 00:19:47,510
mechanism to define whether a bus master

00:19:44,870 --> 00:19:49,940
or a slave is secure or not secure and

00:19:47,510 --> 00:19:52,309
when that has to be propagated through

00:19:49,940 --> 00:19:55,549
the bus so that a non secure man on

00:19:52,309 --> 00:19:56,630
secure master cannot access a secure

00:19:55,549 --> 00:19:58,850
slave and vice versa

00:19:56,630 --> 00:20:01,010
so you basically want to not have the

00:19:58,850 --> 00:20:05,390
conflict of a back-channel through that

00:20:01,010 --> 00:20:06,980
through the fabric this also has to has

00:20:05,390 --> 00:20:09,740
to basically permeate through all

00:20:06,980 --> 00:20:10,970
interrupts and caching mechanisms so the

00:20:09,740 --> 00:20:12,049
caches have to be appropriately

00:20:10,970 --> 00:20:13,669
segregated as well

00:20:12,049 --> 00:20:15,860
so typically l2 at the point of

00:20:13,669 --> 00:20:17,450
unification the captions also appear

00:20:15,860 --> 00:20:20,240
independent even though you turn on an

00:20:17,450 --> 00:20:21,860
l2 cache globally whether it's secure or

00:20:20,240 --> 00:20:23,120
not secure is still appropriately tagged

00:20:21,860 --> 00:20:26,590
so that you're not stepping into the

00:20:23,120 --> 00:20:26,590
wrong place from the non secure domain

00:20:26,799 --> 00:20:31,090
there's a lot more to this than crypto

00:20:29,030 --> 00:20:33,380
so we look at it from the standpoint of

00:20:31,090 --> 00:20:35,150
effectively implementing driver stacks

00:20:33,380 --> 00:20:37,909
as well so somebody says they want

00:20:35,150 --> 00:20:39,590
secure storage put the quad spy

00:20:37,909 --> 00:20:41,899
interface in the security

00:20:39,590 --> 00:20:43,909
put the chip on a separate bus put the

00:20:41,899 --> 00:20:45,440
driver in the secure world and your

00:20:43,909 --> 00:20:47,059
storage and your boot blocks are now

00:20:45,440 --> 00:20:49,429
outside the region of the normal world

00:20:47,059 --> 00:20:51,169
just being able to do an easy easy hack

00:20:49,429 --> 00:20:54,980
and Linux to get it to boot region of

00:20:51,169 --> 00:20:56,779
the flash there's a lot more that starts

00:20:54,980 --> 00:20:58,250
before this and it's typically very much

00:20:56,779 --> 00:20:59,899
I'm not saying this is going to not

00:20:58,250 --> 00:21:01,519
change anytime soon there's been a lot

00:20:59,899 --> 00:21:03,919
of fragmentation for good reason

00:21:01,519 --> 00:21:05,870
a lot of the silic investers silicon

00:21:03,919 --> 00:21:08,149
part of the silicon providers have

00:21:05,870 --> 00:21:10,460
invested heavily and effectively what is

00:21:08,149 --> 00:21:12,919
their proprietary IP so all anything

00:21:10,460 --> 00:21:15,710
involved in in terms of planting root

00:21:12,919 --> 00:21:19,190
keys what's embedded in their roms all

00:21:15,710 --> 00:21:21,980
of their safe proprietary IP in terms of

00:21:19,190 --> 00:21:23,720
segregation mechanisms or the roms and

00:21:21,980 --> 00:21:26,450
how those work they're all very much

00:21:23,720 --> 00:21:28,279
device specific in vendor specific so

00:21:26,450 --> 00:21:30,139
what means secure boot what means to

00:21:28,279 --> 00:21:32,029
cure update there are points where you

00:21:30,139 --> 00:21:33,649
can branch forward but these are all Sox

00:21:32,029 --> 00:21:35,450
specific and I have to be taken into

00:21:33,649 --> 00:21:36,980
consideration when doing the design at

00:21:35,450 --> 00:21:39,169
the SOC level as well as the board

00:21:36,980 --> 00:21:43,880
implementation or what the OEM wants to

00:21:39,169 --> 00:21:46,100
build what's involved in a cryptography

00:21:43,880 --> 00:21:47,659
really depends on the tip itself one of

00:21:46,100 --> 00:21:49,100
the things we like about what the trust

00:21:47,659 --> 00:21:52,669
zone provides with the appropriate

00:21:49,100 --> 00:21:54,649
software is it fails elegantly so unlike

00:21:52,669 --> 00:21:56,779
crypto accelerators how many people have

00:21:54,649 --> 00:21:59,450
watched the recommended minimum youth

00:21:56,779 --> 00:22:03,620
minimum length of an RSA key go from 512

00:21:59,450 --> 00:22:06,980
to 1024 to 4096 bits if you embed that

00:22:03,620 --> 00:22:08,840
in hardware and tomorrow 400 4096 bits

00:22:06,980 --> 00:22:10,820
are broken you're kind of left in the

00:22:08,840 --> 00:22:12,769
situation of either your chips broken if

00:22:10,820 --> 00:22:14,600
you can't update it your TPM or your

00:22:12,769 --> 00:22:15,649
external elements broken or if you've

00:22:14,600 --> 00:22:16,850
done it in software have a good

00:22:15,649 --> 00:22:19,399
implementation well you can update

00:22:16,850 --> 00:22:20,899
over-the-air so the failures are a lot

00:22:19,399 --> 00:22:22,610
softer you just have to take a lot more

00:22:20,899 --> 00:22:27,110
into consideration when implementing it

00:22:22,610 --> 00:22:28,519
in software there's a lot more to this

00:22:27,110 --> 00:22:30,320
than just the crypto because you can

00:22:28,519 --> 00:22:32,659
actually implement critical functions so

00:22:30,320 --> 00:22:33,919
let your imaginations go wild and think

00:22:32,659 --> 00:22:35,690
in terms of we think we think

00:22:33,919 --> 00:22:37,850
specifically in terms of sensors and

00:22:35,690 --> 00:22:39,080
actuators what are critical functions on

00:22:37,850 --> 00:22:42,409
the device that really need to be

00:22:39,080 --> 00:22:48,230
isolated properly and this allows us to

00:22:42,409 --> 00:22:49,429
implement trusted controls so I don't

00:22:48,230 --> 00:22:50,629
know that there's an awful lot that I

00:22:49,429 --> 00:22:51,260
need to say on this side it's sort of a

00:22:50,629 --> 00:22:53,380
summary

00:22:51,260 --> 00:22:55,940
effectively it's almost separation

00:22:53,380 --> 00:22:59,060
secure food secure firmware updates

00:22:55,940 --> 00:23:00,080
authenticated payloads this is a bigger

00:22:59,060 --> 00:23:01,790
deal than it sounds

00:23:00,080 --> 00:23:03,200
no security something's really hard to

00:23:01,790 --> 00:23:05,540
sell and you won't find a lot of sea

00:23:03,200 --> 00:23:07,520
level so like I say yeah I'll pay you 20

00:23:05,540 --> 00:23:09,020
bucks a device for security they won't

00:23:07,520 --> 00:23:11,420
pay you for security they will pay you

00:23:09,020 --> 00:23:13,430
for IP protection and if you say to

00:23:11,420 --> 00:23:14,960
somebody well we can protect your IP by

00:23:13,430 --> 00:23:16,550
giving you an encrypted boot chain tied

00:23:14,960 --> 00:23:19,880
to a root of trust so that nobody can

00:23:16,550 --> 00:23:20,930
steal your design then they care so if

00:23:19,880 --> 00:23:22,700
you turn around and say it's about

00:23:20,930 --> 00:23:24,500
protecting basically protecting the

00:23:22,700 --> 00:23:27,140
integrity of the device or brand or

00:23:24,500 --> 00:23:29,000
reputation or not stealing somebody's IP

00:23:27,140 --> 00:23:30,830
then they get really interested really

00:23:29,000 --> 00:23:32,420
quickly the same thing goes for the

00:23:30,830 --> 00:23:34,760
manufacturing and provisioning so that's

00:23:32,420 --> 00:23:36,020
sort of how security is the objective on

00:23:34,760 --> 00:23:37,370
one side and on the other hand the

00:23:36,020 --> 00:23:38,990
benefit is while they lose less money

00:23:37,370 --> 00:23:41,060
and they have a better design in the end

00:23:38,990 --> 00:23:49,610
as well and your your thermostat can't

00:23:41,060 --> 00:23:50,690
be used as a garage door opener so I'm

00:23:49,610 --> 00:23:53,570
gonna walk through some of the

00:23:50,690 --> 00:23:55,340
underpinnings are many people in the

00:23:53,570 --> 00:23:58,640
room familiar with trust zone or the

00:23:55,340 --> 00:24:03,440
terminology or the mechanisms that

00:23:58,640 --> 00:24:05,660
underpin it just a I can cover this

00:24:03,440 --> 00:24:07,220
fairly quickly or fairly slowly do we

00:24:05,660 --> 00:24:11,780
always get asked questions like how does

00:24:07,220 --> 00:24:14,360
this stuff actually work so then oh is

00:24:11,780 --> 00:24:16,010
it induce anywhere so we step back and

00:24:14,360 --> 00:24:18,140
look at it's been around for I say over

00:24:16,010 --> 00:24:20,510
a decade it's on more than a billion

00:24:18,140 --> 00:24:23,210
devices so think in terms of Samsung

00:24:20,510 --> 00:24:24,710
Blackberry Nokia Microsoft so you turn

00:24:23,210 --> 00:24:26,270
the clock back a long time and this has

00:24:24,710 --> 00:24:28,700
been living under the hood on systems

00:24:26,270 --> 00:24:29,120
that were not even aware of nobody talks

00:24:28,700 --> 00:24:30,650
about it

00:24:29,120 --> 00:24:32,570
it's there it's in it's in pretty much

00:24:30,650 --> 00:24:35,080
every hand Samsung handsets that ship

00:24:32,570 --> 00:24:38,540
for its a the past three or four years

00:24:35,080 --> 00:24:40,070
it's used in payment bank terminals uses

00:24:38,540 --> 00:24:42,980
set-top boxes it's used in smart

00:24:40,070 --> 00:24:45,560
televisions and the list goes on so some

00:24:42,980 --> 00:24:47,510
of the terminology trust zone is

00:24:45,560 --> 00:24:50,420
hardware the trusted execution

00:24:47,510 --> 00:24:51,530
environment or the TE is software it's

00:24:50,420 --> 00:24:53,300
tough if you want to call it the

00:24:51,530 --> 00:24:56,090
operating system that occupies the trust

00:24:53,300 --> 00:24:58,340
zone of it or the secure domain there's

00:24:56,090 --> 00:24:59,990
the normal world the rich OS the rich

00:24:58,340 --> 00:25:02,900
execution environment some think of

00:24:59,990 --> 00:25:04,020
Linux are in our costs there's this pure

00:25:02,900 --> 00:25:06,360
world Sakura

00:25:04,020 --> 00:25:09,180
the trusted execution environment opti

00:25:06,360 --> 00:25:11,220
as an example there's a secure monitor

00:25:09,180 --> 00:25:13,500
which is a very special place sort of

00:25:11,220 --> 00:25:15,510
lives in between worlds there's a trust

00:25:13,500 --> 00:25:17,850
that application which naturally lit

00:25:15,510 --> 00:25:19,860
runs in the trusted domain their trusted

00:25:17,850 --> 00:25:21,390
connector API so there's some piece that

00:25:19,860 --> 00:25:23,790
has to call from the normal world to

00:25:21,390 --> 00:25:25,560
invoke a trusted application and then

00:25:23,790 --> 00:25:27,180
depending on the ecosystem you're in

00:25:25,560 --> 00:25:29,430
there may be a third-party trust model

00:25:27,180 --> 00:25:31,290
for deploying trusted applications that

00:25:29,430 --> 00:25:33,570
comes out of the mobile space it's not

00:25:31,290 --> 00:25:36,180
necessarily applicable and I'd say in

00:25:33,570 --> 00:25:38,310
the world of embedded or smart nodes but

00:25:36,180 --> 00:25:40,050
it's really very very use case specific

00:25:38,310 --> 00:25:41,850
and be careful when going there because

00:25:40,050 --> 00:25:46,980
it can inject cost into the into the

00:25:41,850 --> 00:25:51,780
ecosystem that people don't like so I'll

00:25:46,980 --> 00:25:53,730
give a review people ask I mean we get

00:25:51,780 --> 00:25:56,670
asked a lot of questions on this so the

00:25:53,730 --> 00:25:59,480
trick is the CPU propagates his security

00:25:56,670 --> 00:26:02,460
state on to the bus so the CPUs a master

00:25:59,480 --> 00:26:03,990
and it effectively when it's secure it

00:26:02,460 --> 00:26:07,230
will talk to communicate with secure and

00:26:03,990 --> 00:26:10,130
non-secure slaves non secure masters

00:26:07,230 --> 00:26:12,900
can't see non secure masters won't talk

00:26:10,130 --> 00:26:17,490
the right non secure cat though to

00:26:12,900 --> 00:26:19,110
secure effectively are blocked all of

00:26:17,490 --> 00:26:21,750
everything on the bus fabric must

00:26:19,110 --> 00:26:23,250
enforce this so if there's a DMA master

00:26:21,750 --> 00:26:24,630
that does not and then there's a good

00:26:23,250 --> 00:26:26,730
chance you have a back-channel or a leak

00:26:24,630 --> 00:26:29,670
so if you can get control of the driver

00:26:26,730 --> 00:26:31,950
interface for for a bus master that's

00:26:29,670 --> 00:26:34,020
that's not being set up properly or it's

00:26:31,950 --> 00:26:35,940
not you cannot bind to security after

00:26:34,020 --> 00:26:37,140
thee then you've got a piece of silicon

00:26:35,940 --> 00:26:42,600
that I'd say it's kind of questionable

00:26:37,140 --> 00:26:44,460
and this has happened many times people

00:26:42,600 --> 00:26:46,080
ask us what's the you know what is this

00:26:44,460 --> 00:26:48,050
what is the truss zone exactly is it

00:26:46,080 --> 00:26:50,280
like virtualization and the answer's no

00:26:48,050 --> 00:26:52,410
the software is running on bare metal

00:26:50,280 --> 00:26:54,060
there's no magic extra set of page

00:26:52,410 --> 00:26:57,030
tables doing an additional layer of

00:26:54,060 --> 00:26:59,400
interpretation on an address space it is

00:26:57,030 --> 00:27:01,800
like a virtual second CPU just happens

00:26:59,400 --> 00:27:03,750
to be the same one so what happens is

00:27:01,800 --> 00:27:06,570
that the critical registers that

00:27:03,750 --> 00:27:08,340
represent the CPU state are banked so

00:27:06,570 --> 00:27:11,130
things like the control registers for

00:27:08,340 --> 00:27:13,230
page tables the physical and virtual

00:27:11,130 --> 00:27:16,170
address spaces of the mnu effectively

00:27:13,230 --> 00:27:17,700
looks banked and then the caches as well

00:27:16,170 --> 00:27:20,370
are split as well as the control

00:27:17,700 --> 00:27:22,110
so the CPU in the secure world can have

00:27:20,370 --> 00:27:24,150
everything enabled be running with the

00:27:22,110 --> 00:27:27,030
caches on be running with the MMU and

00:27:24,150 --> 00:27:28,590
step into Linux that's not got anything

00:27:27,030 --> 00:27:33,330
turned on yet other than the clocks are

00:27:28,590 --> 00:27:37,110
running there are two interrupt lines to

00:27:33,330 --> 00:27:40,890
the core so thick fast interrupt and irq

00:27:37,110 --> 00:27:47,580
so by convention f IQ is typically bound

00:27:40,890 --> 00:27:49,290
to the secure domain the magic so the

00:27:47,580 --> 00:27:52,050
core if you're coming out of secure boot

00:27:49,290 --> 00:27:53,460
the core resets into secure state at

00:27:52,050 --> 00:27:54,960
this point typically is where the

00:27:53,460 --> 00:27:56,640
binding is done for the peripheral

00:27:54,960 --> 00:27:58,980
States so you've got to find the

00:27:56,640 --> 00:28:01,800
mechanism whether it's proprietary IP or

00:27:58,980 --> 00:28:03,870
arm IP what binds or what allows you to

00:28:01,800 --> 00:28:05,340
associate the security attribute with

00:28:03,870 --> 00:28:07,140
everything that lives on the bus the

00:28:05,340 --> 00:28:08,940
cores are obviously secure at this point

00:28:07,140 --> 00:28:10,400
but you need to designate if they're

00:28:08,940 --> 00:28:12,690
peripherals you want to be secure only

00:28:10,400 --> 00:28:14,580
mark them at this point and keep them

00:28:12,690 --> 00:28:16,230
there depending on the IP it may be

00:28:14,580 --> 00:28:18,210
possible to flip peripherals back and

00:28:16,230 --> 00:28:19,920
forth between the domains on the fly and

00:28:18,210 --> 00:28:22,590
obviously that's under should be under

00:28:19,920 --> 00:28:25,590
the control of the secure domain there's

00:28:22,590 --> 00:28:27,420
this magic register called the scr the

00:28:25,590 --> 00:28:30,720
secure configuration register and it

00:28:27,420 --> 00:28:32,760
really is that it's not accessible from

00:28:30,720 --> 00:28:34,350
the non secure domain so when Linux is

00:28:32,760 --> 00:28:36,780
running in the normal world that

00:28:34,350 --> 00:28:38,670
register doesn't even exist and any

00:28:36,780 --> 00:28:40,800
attempt to read it or write it doesn't

00:28:38,670 --> 00:28:44,940
cause anything weird to happen it's just

00:28:40,800 --> 00:28:46,740
ignored silently by the CPU so this is

00:28:44,940 --> 00:28:49,170
the little magic register it's the least

00:28:46,740 --> 00:28:52,590
significant bit defines the Core State

00:28:49,170 --> 00:28:53,910
Linux kept I can't even ask if it's

00:28:52,590 --> 00:28:56,310
running if it's running not secure it

00:28:53,910 --> 00:28:58,080
won't get an answer back effectively

00:28:56,310 --> 00:29:00,660
that least significant bit so it's

00:28:58,080 --> 00:29:03,120
inverted logic not secure a zero means

00:29:00,660 --> 00:29:06,240
it's secure not secure as one means it's

00:29:03,120 --> 00:29:09,390
not secure there are a couple of other

00:29:06,240 --> 00:29:11,820
interesting bits in there f IQ irq and

00:29:09,390 --> 00:29:14,550
abort these are basically used for

00:29:11,820 --> 00:29:17,160
routing interrupts so in the secure

00:29:14,550 --> 00:29:20,520
world if you set the F bit to one and

00:29:17,160 --> 00:29:22,980
you step to the non secure world Linux

00:29:20,520 --> 00:29:25,830
can do all it wants to try to mask if IQ

00:29:22,980 --> 00:29:28,530
but it can't block it so if n F if a

00:29:25,830 --> 00:29:30,790
fast interrupt appears the core will

00:29:28,530 --> 00:29:33,010
trap to the monitor mode

00:29:30,790 --> 00:29:35,320
from there it's time to dispatch off to

00:29:33,010 --> 00:29:37,120
the handler for secure interrupts so the

00:29:35,320 --> 00:29:39,250
beauty of this basically means you can

00:29:37,120 --> 00:29:41,620
have a DMA master with an interrupt on

00:29:39,250 --> 00:29:43,300
it bound to fi Q you can have this

00:29:41,620 --> 00:29:45,100
running behind the scenes bound to a

00:29:43,300 --> 00:29:47,140
driver in the secure world Linux will

00:29:45,100 --> 00:29:48,520
happily go to its thing the interrupt

00:29:47,140 --> 00:29:50,290
fires and you're not magically in the

00:29:48,520 --> 00:29:52,720
driver in the secure domain without a

00:29:50,290 --> 00:29:55,630
hiccup it's actually it's very very

00:29:52,720 --> 00:29:58,270
elegant analytics has no ability block

00:29:55,630 --> 00:29:59,440
so you have no no way for the normal

00:29:58,270 --> 00:30:02,320
world to stage a denial-of-service

00:29:59,440 --> 00:30:05,140
attack on a resource or a clock or it's

00:30:02,320 --> 00:30:11,380
calling a you know critical peripheral

00:30:05,140 --> 00:30:12,820
against the system the the one of the

00:30:11,380 --> 00:30:14,290
tricks that's actually done or needs to

00:30:12,820 --> 00:30:16,330
be employed is the rerouting of

00:30:14,290 --> 00:30:18,280
interrupts on the fly so as you pass

00:30:16,330 --> 00:30:19,660
between domains if you get to the secure

00:30:18,280 --> 00:30:20,980
world and you block handling and are

00:30:19,660 --> 00:30:23,260
still Linux are gonna deadlock very

00:30:20,980 --> 00:30:25,570
quickly so as soon as the monitor enters

00:30:23,260 --> 00:30:26,920
it actually switches the order around so

00:30:25,570 --> 00:30:30,010
that the interrupts are all delivered to

00:30:26,920 --> 00:30:31,600
the secure world and effectively the irq

00:30:30,010 --> 00:30:33,550
interrupts is delivered to the secure

00:30:31,600 --> 00:30:35,140
world but it's roaded back to the non

00:30:33,550 --> 00:30:36,910
secure world through the monitor through

00:30:35,140 --> 00:30:39,220
the driver so that the normal world

00:30:36,910 --> 00:30:41,050
interrupts can execute if you don't do

00:30:39,220 --> 00:30:43,540
that a lot of things will break very

00:30:41,050 --> 00:30:45,070
quickly so typically in depending on

00:30:43,540 --> 00:30:47,740
what the interrupt architecture looks

00:30:45,070 --> 00:30:49,480
like for device if you bring the if you

00:30:47,740 --> 00:30:51,220
bring opti up and you find as soon as

00:30:49,480 --> 00:30:53,530
you try to do anything like say for

00:30:51,220 --> 00:30:55,150
example access file and the device locks

00:30:53,530 --> 00:30:56,620
up it's probably because they interrupt

00:30:55,150 --> 00:31:01,930
architecture the interrupts are set up

00:30:56,620 --> 00:31:03,940
properly yeah the last point that the

00:31:01,930 --> 00:31:07,420
the register is just not accessible

00:31:03,940 --> 00:31:12,010
which is a bit of a revelation this

00:31:07,420 --> 00:31:14,230
monitor mode or in v8 terms l3 it's not

00:31:12,010 --> 00:31:15,420
obvious for a lot of people how this

00:31:14,230 --> 00:31:19,510
thing works

00:31:15,420 --> 00:31:23,290
the monitor is entered from i from l1 or

00:31:19,510 --> 00:31:25,290
l2 so either secure or not secure

00:31:23,290 --> 00:31:27,820
through an SMC basically a trap call

00:31:25,290 --> 00:31:29,500
when the monitor has entered the nuts

00:31:27,820 --> 00:31:32,170
that your bit reflects the state that it

00:31:29,500 --> 00:31:36,490
was entered from but the monitor mode

00:31:32,170 --> 00:31:38,620
itself is implicitly secure so whatever

00:31:36,490 --> 00:31:41,110
mode the core was in when you let left

00:31:38,620 --> 00:31:43,260
to the normal world is the state that

00:31:41,110 --> 00:31:45,330
you're in when you're in the monitor so

00:31:43,260 --> 00:31:48,120
and the page tables in the address space

00:31:45,330 --> 00:31:52,140
that are visible at el3 are the ones

00:31:48,120 --> 00:31:53,640
that were set up on the secure side so

00:31:52,140 --> 00:31:55,980
the address space in the code space

00:31:53,640 --> 00:31:57,840
you're running in are always secure what

00:31:55,980 --> 00:31:59,700
changes with the value of that bit is

00:31:57,840 --> 00:32:02,580
which view you have of the bank

00:31:59,700 --> 00:32:04,290
registers so from within the monitor

00:32:02,580 --> 00:32:05,970
itself you can actually set the not

00:32:04,290 --> 00:32:07,260
secure bit and you can look go look at

00:32:05,970 --> 00:32:09,660
the page tables from the non secure

00:32:07,260 --> 00:32:11,880
world so we've had to do this at times

00:32:09,660 --> 00:32:13,560
and debugging we have had to go in where

00:32:11,880 --> 00:32:16,860
we found really strange things happening

00:32:13,560 --> 00:32:18,660
and walk TTB 0tg b1 from the normal

00:32:16,860 --> 00:32:20,040
world in the secure world and map the

00:32:18,660 --> 00:32:22,080
pages and to find out what's going on

00:32:20,040 --> 00:32:23,520
but typically you don't have visibility

00:32:22,080 --> 00:32:24,720
because that's not the address space

00:32:23,520 --> 00:32:26,910
you're running in and for a lot of

00:32:24,720 --> 00:32:28,530
people this isn't obvious for entering

00:32:26,910 --> 00:32:31,380
or re-entering something like Linux you

00:32:28,530 --> 00:32:32,790
have to reset the s ctlr so the control

00:32:31,380 --> 00:32:34,980
register that defines things like

00:32:32,790 --> 00:32:36,720
caching and and then you enable because

00:32:34,980 --> 00:32:38,040
those are banked as well but you can see

00:32:36,720 --> 00:32:41,390
what's going on in the normal world from

00:32:38,040 --> 00:32:44,520
the secure side so bottom line for this

00:32:41,390 --> 00:32:46,140
that codes really sensitive keep it as

00:32:44,520 --> 00:32:48,390
small as possible and it should just be

00:32:46,140 --> 00:32:50,430
a pass-through so effectively context

00:32:48,390 --> 00:32:51,900
switch only getting get out and don't do

00:32:50,430 --> 00:32:57,570
as little as possible in there don't

00:32:51,900 --> 00:32:59,070
stick around it's way too sensitive I'm

00:32:57,570 --> 00:33:03,110
going to walk through an example so this

00:32:59,070 --> 00:33:05,490
is basically on just we have some time a

00:33:03,110 --> 00:33:06,960
little bit of the background of what the

00:33:05,490 --> 00:33:08,730
architecture is between a trusted

00:33:06,960 --> 00:33:10,710
application and the and the connector

00:33:08,730 --> 00:33:12,510
component that would call it and the

00:33:10,710 --> 00:33:14,160
api's that are implemented so there's a

00:33:12,510 --> 00:33:16,950
standards organization called global

00:33:14,160 --> 00:33:20,750
platform they implement a number of

00:33:16,950 --> 00:33:23,130
api's for standardizing that relate so

00:33:20,750 --> 00:33:25,110
effectively the calling protocol between

00:33:23,130 --> 00:33:27,690
a normal world application and trusts

00:33:25,110 --> 00:33:30,930
that application so they have two sets

00:33:27,690 --> 00:33:32,730
of API is combine the T internal API and

00:33:30,930 --> 00:33:34,410
the other ones the T client API so the

00:33:32,730 --> 00:33:38,240
client astruc runs in the normal world

00:33:34,410 --> 00:33:41,790
the core API runs in the secure side

00:33:38,240 --> 00:33:45,060
effectively there's a runtime library in

00:33:41,790 --> 00:33:47,640
the secure domain and the T the internal

00:33:45,060 --> 00:33:50,460
API exposes this to you so we have a set

00:33:47,640 --> 00:33:52,230
of predefined entry points and they

00:33:50,460 --> 00:33:53,640
effectively provide the api's to give

00:33:52,230 --> 00:33:54,630
you access to things like trusted

00:33:53,640 --> 00:33:58,770
stories so for today

00:33:54,630 --> 00:34:01,200
keys cryptographic operations time API

00:33:58,770 --> 00:34:02,970
earth medical there's also I think

00:34:01,200 --> 00:34:05,280
advanced API has been announced for

00:34:02,970 --> 00:34:07,410
trusted user interface so the idea is

00:34:05,280 --> 00:34:10,440
that you'll have a complete say call it

00:34:07,410 --> 00:34:11,940
the GPU and a digitizer where the entire

00:34:10,440 --> 00:34:13,590
driver stack and the ability to interact

00:34:11,940 --> 00:34:15,990
that are within the circuit of secure

00:34:13,590 --> 00:34:17,399
domain the big deal about this is that

00:34:15,990 --> 00:34:19,050
you can now do pin capture without

00:34:17,399 --> 00:34:20,970
phishing I don't care if you steal my

00:34:19,050 --> 00:34:22,470
pin the entire capture operation the

00:34:20,970 --> 00:34:24,510
binding to the transaction the request

00:34:22,470 --> 00:34:26,760
is happening outside it's outside of the

00:34:24,510 --> 00:34:28,409
normal world so compromise Linux all you

00:34:26,760 --> 00:34:30,240
want I just don't care the keys are

00:34:28,409 --> 00:34:31,770
routed somewhere else and the entire

00:34:30,240 --> 00:34:33,600
operation is happening outside of the

00:34:31,770 --> 00:34:38,129
domain of the system where they're at

00:34:33,600 --> 00:34:39,659
risk anyway the point the point of that

00:34:38,129 --> 00:34:41,490
basically their objective is to provide

00:34:39,659 --> 00:34:43,950
a set of standard api's and it's more

00:34:41,490 --> 00:34:46,500
thee also as part of their intent is to

00:34:43,950 --> 00:34:48,389
define the semantics of the relationship

00:34:46,500 --> 00:34:50,280
between the two sides what you do with

00:34:48,389 --> 00:34:52,800
the API is entirely up to you you want

00:34:50,280 --> 00:34:53,790
to write bad code right back code but

00:34:52,800 --> 00:34:55,440
the whole point is that they're

00:34:53,790 --> 00:34:57,300
attempting to define the semantics of

00:34:55,440 --> 00:34:59,840
how the T should operate and how the API

00:34:57,300 --> 00:34:59,840
should operate

00:35:07,290 --> 00:35:15,100
it's multicore yes yes it P basically

00:35:12,610 --> 00:35:18,400
asked if opti supports multi-core and

00:35:15,100 --> 00:35:20,170
the answer is yes I mean it has it has

00:35:18,400 --> 00:35:22,030
secondary entry points for as many

00:35:20,170 --> 00:35:26,200
devices as you as many cards as you want

00:35:22,030 --> 00:35:30,490
to bring through the client API itself

00:35:26,200 --> 00:35:32,440
is very straightforward effectively

00:35:30,490 --> 00:35:35,530
allows you to define four parameters

00:35:32,440 --> 00:35:40,830
it's fairly basic much like an IPC you

00:35:35,530 --> 00:35:43,570
have in in a note so quite basic it's

00:35:40,830 --> 00:35:46,390
very straightforward in the case of opti

00:35:43,570 --> 00:35:49,300
the implementation by by I'd say by

00:35:46,390 --> 00:35:50,980
requirement and definition anything

00:35:49,300 --> 00:35:53,830
coming from the normal world is in

00:35:50,980 --> 00:35:55,150
shared non secure memory because the

00:35:53,830 --> 00:35:58,060
normal rule doesn't have access to

00:35:55,150 --> 00:35:59,950
secure memory and the passing is done at

00:35:58,060 --> 00:36:01,690
the physical level so physical address

00:35:59,950 --> 00:36:03,820
space is common to both secure and

00:36:01,690 --> 00:36:05,800
non-secure domains addresses are pay

00:36:03,820 --> 00:36:07,750
addresses of pages are passed physically

00:36:05,800 --> 00:36:09,760
and the remapped under the secure side

00:36:07,750 --> 00:36:11,380
is required so effectively this if your

00:36:09,760 --> 00:36:14,290
domain can see into the parameters that

00:36:11,380 --> 00:36:15,820
were passed so a zero copy interface how

00:36:14,290 --> 00:36:17,020
it's implemented on other devices you

00:36:15,820 --> 00:36:18,810
could do this a symmetric

00:36:17,020 --> 00:36:22,080
multiprocessing there multiple cores

00:36:18,810 --> 00:36:24,190
effectively the whole point is

00:36:22,080 --> 00:36:27,970
transferring information through a non

00:36:24,190 --> 00:36:29,410
secure and a non secure channel the

00:36:27,970 --> 00:36:31,180
api's themselves they can be they can be

00:36:29,410 --> 00:36:33,430
blocking it is possible to cancel

00:36:31,180 --> 00:36:36,100
operation and so from another thread you

00:36:33,430 --> 00:36:38,230
can request that a command or a secure

00:36:36,100 --> 00:36:39,730
operation be aborted and there they're

00:36:38,230 --> 00:36:41,770
actually pretty straightforward to use

00:36:39,730 --> 00:36:43,030
that just say it's very basic so when

00:36:41,770 --> 00:36:44,560
you're staring is something it's effect

00:36:43,030 --> 00:36:46,210
effectively like you're stuffing values

00:36:44,560 --> 00:36:48,280
and for registers and you have to feed

00:36:46,210 --> 00:36:49,660
pretty much scaler structures across if

00:36:48,280 --> 00:36:50,950
you pass a virtual address and a

00:36:49,660 --> 00:36:53,410
structure from the normal rule to the

00:36:50,950 --> 00:36:54,610
secure world well maybe we'll map I'd

00:36:53,410 --> 00:36:58,060
say a good chance that we'll just abort

00:36:54,610 --> 00:36:59,590
because the mapping won't exist so all

00:36:58,060 --> 00:37:01,030
that work is left up to you in terms of

00:36:59,590 --> 00:37:02,560
scale or I in terms of making your

00:37:01,030 --> 00:37:06,370
structures scalar for passing them

00:37:02,560 --> 00:37:08,620
across the result codes really simple I

00:37:06,370 --> 00:37:12,070
you know it's as a tradition zero is

00:37:08,620 --> 00:37:14,140
good otherwise we get an origin back on

00:37:12,070 --> 00:37:16,260
where the likely call it the the domain

00:37:14,140 --> 00:37:18,750
of execution what went wrong so whether

00:37:16,260 --> 00:37:20,700
it's within the API communications the T

00:37:18,750 --> 00:37:22,170
itself or the trusted application it

00:37:20,700 --> 00:37:23,970
gives you a hint as to what get what

00:37:22,170 --> 00:37:25,410
went wrong the beauty of working with

00:37:23,970 --> 00:37:27,150
opt to you is you can debug it to

00:37:25,410 --> 00:37:29,070
whatever extent you want and you also

00:37:27,150 --> 00:37:30,510
have nice print capabilities I think I

00:37:29,070 --> 00:37:33,119
don't think there's an implementation

00:37:30,510 --> 00:37:34,350
that doesn't define serial port so you

00:37:33,119 --> 00:37:36,030
can actually get a lot more information

00:37:34,350 --> 00:37:42,810
out of the system that you've normally

00:37:36,030 --> 00:37:45,300
have in a lot of environments there's a

00:37:42,810 --> 00:37:49,130
concept of a context in a session so you

00:37:45,300 --> 00:37:49,130
can have multiple clients invoking a TA

00:37:49,310 --> 00:37:55,410
you can have multiple connections and

00:37:51,810 --> 00:37:56,880
TAS can invoke other TAS so how you can

00:37:55,410 --> 00:37:59,240
be you can do quite interesting and

00:37:56,880 --> 00:38:02,010
hairy things with this and I'd say

00:37:59,240 --> 00:38:03,780
whenever we run into a lack of

00:38:02,010 --> 00:38:05,280
understanding of the api's or in other

00:38:03,780 --> 00:38:07,920
words they when we don't know what we're

00:38:05,280 --> 00:38:09,570
doing we typically go to X tests so go

00:38:07,920 --> 00:38:12,590
to the test suite it's really elegantly

00:38:09,570 --> 00:38:14,970
done effectively proxies through the

00:38:12,590 --> 00:38:16,740
trust that application api's to the

00:38:14,970 --> 00:38:18,390
normal world and what gives you really

00:38:16,740 --> 00:38:20,760
good overview but how the API should be

00:38:18,390 --> 00:38:22,680
used so from our perspective when we run

00:38:20,760 --> 00:38:25,230
into situations either debugging the tea

00:38:22,680 --> 00:38:26,970
itself or go to X has to understand you

00:38:25,230 --> 00:38:32,040
know what the original intent was it's

00:38:26,970 --> 00:38:35,100
done quite nicely the the concept of the

00:38:32,040 --> 00:38:37,619
API is so you define effectively an enum

00:38:35,100 --> 00:38:39,450
type so it's like writing an i/o control

00:38:37,619 --> 00:38:41,910
if you can define your commands is 0 1 2

00:38:39,450 --> 00:38:43,290
3 4 5 or pick whatever set you want and

00:38:41,910 --> 00:38:45,090
you have a switch routine on the other

00:38:43,290 --> 00:38:46,350
side the dispatch is out to whatever sub

00:38:45,090 --> 00:38:48,720
functions you want to implement within

00:38:46,350 --> 00:38:52,080
the TA so very straightforward very very

00:38:48,720 --> 00:38:53,400
basic and the shared memory up to you to

00:38:52,080 --> 00:38:57,560
define how you use them it could be

00:38:53,400 --> 00:38:57,560
temporary or they can be they can be

00:38:58,940 --> 00:39:07,680
persistent objects the context is

00:39:05,400 --> 00:39:09,270
represented in its own type and just use

00:39:07,680 --> 00:39:10,740
null as the t name because typically

00:39:09,270 --> 00:39:13,520
typically there's not more than one T

00:39:10,740 --> 00:39:13,520
running on the device

00:39:15,690 --> 00:39:19,959
the sessions are represented by a

00:39:17,890 --> 00:39:22,059
session object naming by convention is

00:39:19,959 --> 00:39:24,309
through UID in the intent of this is

00:39:22,059 --> 00:39:25,779
these are really big numbers think

00:39:24,309 --> 00:39:28,209
everybody in here probably knows what a

00:39:25,779 --> 00:39:30,279
UUID is so no know that know what the TA

00:39:28,209 --> 00:39:33,789
is and that's what you're invoking

00:39:30,279 --> 00:39:36,969
there's one unfortunate part of this is

00:39:33,789 --> 00:39:40,059
from the secure world you really don't

00:39:36,969 --> 00:39:43,869
know who's calling you so a TA receives

00:39:40,059 --> 00:39:46,479
a request to open and load it load it

00:39:43,869 --> 00:39:49,180
really can't know who is calling from

00:39:46,479 --> 00:39:52,150
the normal world and by definition it

00:39:49,180 --> 00:39:53,380
can't trust it so keep this in mind when

00:39:52,150 --> 00:39:55,450
you're building your stock in your

00:39:53,380 --> 00:39:56,859
applications that whatever data or the

00:39:55,450 --> 00:39:59,019
application that's calling the inner

00:39:56,859 --> 00:40:02,289
calling out think in terms of what it

00:39:59,019 --> 00:40:05,410
means to have a rogue application in the

00:40:02,289 --> 00:40:06,759
normal world invoking the TA so you have

00:40:05,410 --> 00:40:09,729
to look at what's passed across that

00:40:06,759 --> 00:40:11,709
boundary as well because it's it's world

00:40:09,729 --> 00:40:13,359
by definition the normal world is not

00:40:11,709 --> 00:40:15,369
secure so you can't trust what it's

00:40:13,359 --> 00:40:22,420
doing you have to think defensively in

00:40:15,369 --> 00:40:25,119
writing your TAS as well no loss over

00:40:22,420 --> 00:40:30,099
this commands themselves 32-bit integer

00:40:25,119 --> 00:40:32,799
very straightforward it's up to you to

00:40:30,099 --> 00:40:37,869
define what they do entirely so call it

00:40:32,799 --> 00:40:41,410
it's very very basic four parameters in

00:40:37,869 --> 00:40:42,759
you know though the prep the parameters

00:40:41,410 --> 00:40:48,640
are optional as well so you can put them

00:40:42,759 --> 00:40:50,019
in whatever order you like debug so I

00:40:48,640 --> 00:40:53,410
think global platform may actually

00:40:50,019 --> 00:40:54,999
define an API for this the beauty of

00:40:53,410 --> 00:40:56,469
running with opti if you have a device

00:40:54,999 --> 00:40:58,359
that's as unlocked as the Raspberry Pi

00:40:56,469 --> 00:40:59,920
you can attach up the JTAG dongle and

00:40:58,359 --> 00:41:03,130
debug your heart's content a source

00:40:59,920 --> 00:41:08,799
level so if JTAG this is another thing

00:41:03,130 --> 00:41:11,859
on SOC s typically JTAG enablement is

00:41:08,799 --> 00:41:13,869
split by domain so you may find if you

00:41:11,859 --> 00:41:15,910
buy a board that it may have the trust

00:41:13,869 --> 00:41:17,799
zone populated or unpopulated but

00:41:15,910 --> 00:41:20,529
whether or not you can actually jtag

00:41:17,799 --> 00:41:22,930
debug in the secure domain depends on

00:41:20,529 --> 00:41:25,059
the SOC in the implementation so you may

00:41:22,930 --> 00:41:26,469
find JTAG just will not work and it's

00:41:25,059 --> 00:41:28,209
not your fault it's probably because

00:41:26,469 --> 00:41:29,650
it's been hard disabled if you're

00:41:28,209 --> 00:41:31,329
shipping a device into the field you

00:41:29,650 --> 00:41:33,430
almost certainly want to disable

00:41:31,329 --> 00:41:34,569
security type you don't want anybody

00:41:33,430 --> 00:41:35,799
poking around in there in fact you

00:41:34,569 --> 00:41:39,489
probably want to disable all external

00:41:35,799 --> 00:41:40,900
debug worst case if JTAG is disabled

00:41:39,489 --> 00:41:43,359
you're stuck you basically can run with

00:41:40,900 --> 00:41:45,009
D message or more or less printf but

00:41:43,359 --> 00:41:49,390
it's it's better than it's better than

00:41:45,009 --> 00:41:52,089
running blind the t client itself so the

00:41:49,390 --> 00:41:54,789
client code this is native Linux code so

00:41:52,089 --> 00:41:56,769
it can be effectively represented as a

00:41:54,789 --> 00:41:59,079
dot o whatever you build is a dot o a

00:41:56,769 --> 00:41:59,940
dot a a dot a so link on the fly do

00:41:59,079 --> 00:42:02,829
whatever you like

00:41:59,940 --> 00:42:04,329
there debuggable with gdb so if you're

00:42:02,829 --> 00:42:05,589
running natively on the device you can

00:42:04,329 --> 00:42:08,199
debug the code right on the device

00:42:05,589 --> 00:42:11,819
itself for the normal world or you don't

00:42:08,199 --> 00:42:11,819
like to using a debugger can use printf

00:42:16,809 --> 00:42:25,999
yes yes you can

00:42:19,400 --> 00:42:28,489
yeah so that depends on how you've built

00:42:25,999 --> 00:42:29,809
the poutine so typically in the

00:42:28,489 --> 00:42:32,089
environments where we actually support

00:42:29,809 --> 00:42:34,339
opti for production the trusted

00:42:32,089 --> 00:42:35,779
applications are encrypted and signed

00:42:34,339 --> 00:42:38,059
and they're locked to the root of trust

00:42:35,779 --> 00:42:39,170
on the device so whether they live in it

00:42:38,059 --> 00:42:40,880
whether they live in the normal world

00:42:39,170 --> 00:42:44,569
file system or they live in external

00:42:40,880 --> 00:42:46,339
storage effectively they're the normal

00:42:44,569 --> 00:42:48,680
world is blind to them no matter what

00:42:46,339 --> 00:42:51,229
and if they're corrupted they will not

00:42:48,680 --> 00:42:52,729
live so the whole point of those is

00:42:51,229 --> 00:42:54,499
they're encrypted and locked to the

00:42:52,729 --> 00:43:01,789
reader trust on the secure side no more

00:42:54,499 --> 00:43:05,089
world has no visibility there's a basic

00:43:01,789 --> 00:43:07,009
capability for that but the other the

00:43:05,089 --> 00:43:08,180
other the other experience that we have

00:43:07,009 --> 00:43:10,700
with other silicon and other

00:43:08,180 --> 00:43:12,739
implementations we've written a pile of

00:43:10,700 --> 00:43:15,140
code that's very much silicon dependent

00:43:12,739 --> 00:43:18,259
to deal with the managing and the

00:43:15,140 --> 00:43:22,130
loading of TAS that's a that's a that's

00:43:18,259 --> 00:43:23,599
a detail I mean if you do a static ta

00:43:22,130 --> 00:43:26,269
then that's baked in as part of the

00:43:23,599 --> 00:43:27,589
firmware but it's something as it basic

00:43:26,269 --> 00:43:28,819
I think they're a set of headers so

00:43:27,589 --> 00:43:31,099
there's a tool that will actually do a

00:43:28,819 --> 00:43:32,739
basic signing the hook points for

00:43:31,099 --> 00:43:35,479
implementing this and opti are all there

00:43:32,739 --> 00:43:37,160
but at this point there's I would say

00:43:35,479 --> 00:43:38,749
there is effectively no standard for

00:43:37,160 --> 00:43:40,369
defining how this should be done but

00:43:38,749 --> 00:43:42,829
they should be locked to the device and

00:43:40,369 --> 00:43:45,799
as well if they want to do dynamic

00:43:42,829 --> 00:43:48,559
provisioning I'd say 90% of the time for

00:43:45,799 --> 00:43:52,130
smart devices the answer's no they'll

00:43:48,559 --> 00:43:54,380
bake everything in sorry just a little

00:43:52,130 --> 00:43:56,420
bit of further you have to done you have

00:43:54,380 --> 00:43:58,249
to do a fair amount of work was a poor

00:43:56,420 --> 00:44:01,579
work mostly on the dynamic linking

00:43:58,249 --> 00:44:04,339
supporting the the the tasks part or on

00:44:01,579 --> 00:44:07,339
the authentication and the decryption

00:44:04,339 --> 00:44:09,890
the task loading and the relocation of

00:44:07,339 --> 00:44:11,059
the elf binary is all in there all of

00:44:09,890 --> 00:44:12,769
the code that does the dynamic

00:44:11,059 --> 00:44:14,239
relocation and the memory mapping is re

00:44:12,769 --> 00:44:15,949
it's been there as long as I can

00:44:14,239 --> 00:44:18,109
remember so it's effectively a

00:44:15,949 --> 00:44:21,049
relocatable elf binary but that's

00:44:18,109 --> 00:44:22,729
encrypted and signed and I mean that's

00:44:21,049 --> 00:44:25,459
that's the place where there's

00:44:22,729 --> 00:44:27,820
effectively stub code right now thanks

00:44:25,459 --> 00:44:29,800
but it's all the mechanisms are there

00:44:27,820 --> 00:44:31,180
good points for you I mean ideally what

00:44:29,800 --> 00:44:32,890
you want to do as well and I'll say the

00:44:31,180 --> 00:44:34,870
reason it's information implementation

00:44:32,890 --> 00:44:36,610
defined if you have a hardware root of

00:44:34,870 --> 00:44:38,200
trust and say on chip crypto

00:44:36,610 --> 00:44:41,440
accelerators you want to make use of

00:44:38,200 --> 00:44:42,880
those so it's very much sock dependent

00:44:41,440 --> 00:44:44,890
in terms of the accelerators or the

00:44:42,880 --> 00:44:46,930
capabilities that are available and if

00:44:44,890 --> 00:44:49,150
you want to use ECC instead of RSA for

00:44:46,930 --> 00:44:50,980
performance reasons or key lengths then

00:44:49,150 --> 00:44:52,240
you know it's really up to them it's

00:44:50,980 --> 00:44:55,510
really up to the tool chain you build

00:44:52,240 --> 00:44:57,700
around that so the whole the whole

00:44:55,510 --> 00:44:59,860
objective and this comes down to IP as

00:44:57,700 --> 00:45:01,240
well part of it will be on the TA if

00:44:59,860 --> 00:45:02,620
they're doing something if they're doing

00:45:01,240 --> 00:45:03,970
something that is critical they don't

00:45:02,620 --> 00:45:06,190
want that code to be tampered with so

00:45:03,970 --> 00:45:07,390
even the TAS can lock them that way if

00:45:06,190 --> 00:45:09,400
they want to implement four type

00:45:07,390 --> 00:45:11,470
proprietary algorithms say for deep even

00:45:09,400 --> 00:45:12,880
doing basic math people have asked this

00:45:11,470 --> 00:45:15,550
question so when I go to the trust zone

00:45:12,880 --> 00:45:17,890
is slower right like no it's not like we

00:45:15,550 --> 00:45:20,290
deliberately slow down the CPU clock or

00:45:17,890 --> 00:45:21,700
do we change contexts if it takes a

00:45:20,290 --> 00:45:23,200
hundred clock cycles in the normal world

00:45:21,700 --> 00:45:25,180
takes a hundred clock cycles in the

00:45:23,200 --> 00:45:26,800
secure one and the transitions are very

00:45:25,180 --> 00:45:28,930
fast I'd say no worse than actually

00:45:26,800 --> 00:45:30,250
slept between jumping between say user

00:45:28,930 --> 00:45:33,190
and supervisor on the car

00:45:30,250 --> 00:45:36,970
it's a context switch I wanted to make

00:45:33,190 --> 00:45:38,890
that clear it's not slow the point the

00:45:36,970 --> 00:45:40,690
point of the you IDs have I intent is to

00:45:38,890 --> 00:45:42,610
make them unique I guess you know in a

00:45:40,690 --> 00:45:44,140
in a larger scope they would be managed

00:45:42,610 --> 00:45:46,870
so that there aren't there's no keeping

00:45:44,140 --> 00:45:49,240
no chance of collision the point on the

00:45:46,870 --> 00:45:51,070
TAS is I mean it's it's a valid point so

00:45:49,240 --> 00:45:53,590
how these are managed in terms of TAS it

00:45:51,070 --> 00:45:55,450
depends on the ecosystem if if you're

00:45:53,590 --> 00:45:58,630
the OEM and you're assuming the risk for

00:45:55,450 --> 00:46:00,130
say something like a gas range the risk

00:45:58,630 --> 00:46:02,140
is that it's going to explode if you put

00:46:00,130 --> 00:46:03,490
it online you're holding all of the risk

00:46:02,140 --> 00:46:04,780
for putting the device online in the

00:46:03,490 --> 00:46:06,790
first place I don't think who holds the

00:46:04,780 --> 00:46:08,170
keys going to matter if the device blows

00:46:06,790 --> 00:46:11,440
up because somebody popped it then

00:46:08,170 --> 00:46:12,880
that's the bigger problem but it depends

00:46:11,440 --> 00:46:14,320
if you're going to allow someone else or

00:46:12,880 --> 00:46:16,360
you want a third-party trust model

00:46:14,320 --> 00:46:19,180
that's when you're gonna have to have or

00:46:16,360 --> 00:46:20,740
be able to delegate signing capability

00:46:19,180 --> 00:46:22,660
for the trust that applications over to

00:46:20,740 --> 00:46:30,190
someone else and this is it's very much

00:46:22,660 --> 00:46:32,410
a business an ecosystem consideration oh

00:46:30,190 --> 00:46:34,360
this is really basic I don't know that

00:46:32,410 --> 00:46:35,430
oh like we're running almost late so I

00:46:34,360 --> 00:46:37,750
want to finish up fairly quickly

00:46:35,430 --> 00:46:40,450
effectively the the type for an

00:46:37,750 --> 00:46:40,960
operation I think the presentation is

00:46:40,450 --> 00:46:42,910
already

00:46:40,960 --> 00:46:44,079
online I can just fly through these

00:46:42,910 --> 00:46:47,290
fairly quickly you don't want to hold

00:46:44,079 --> 00:46:48,760
people up from the end of the day the

00:46:47,290 --> 00:46:50,619
shared memory effectively changes

00:46:48,760 --> 00:46:51,970
ownership for the duration of operation

00:46:50,619 --> 00:46:53,380
and the secure domain so when it's

00:46:51,970 --> 00:46:54,940
normal world it's owned by the normal

00:46:53,380 --> 00:46:56,710
world obviously when it's in the secure

00:46:54,940 --> 00:46:57,640
domain it's owned by secure domain who

00:46:56,710 --> 00:46:58,990
has possession of it

00:46:57,640 --> 00:47:04,059
the core is not in both states at the

00:46:58,990 --> 00:47:06,099
same time we hope the buffers are their

00:47:04,059 --> 00:47:07,660
temporary references so the effectively

00:47:06,099 --> 00:47:10,000
these are mapped and potentially two

00:47:07,660 --> 00:47:12,220
different virtual locations the beauty

00:47:10,000 --> 00:47:13,599
of this is is when you send down a

00:47:12,220 --> 00:47:14,980
virtual address in the normal world

00:47:13,599 --> 00:47:16,359
you'll get it a different virtual

00:47:14,980 --> 00:47:18,220
address in the secure world and it will

00:47:16,359 --> 00:47:20,940
be the right place it just happens by

00:47:18,220 --> 00:47:20,940
magic beautifully

00:47:37,120 --> 00:47:40,610
so if you have to trust so and

00:47:39,200 --> 00:47:42,530
protection controller running on the

00:47:40,610 --> 00:47:44,690
memory if you view it as being one

00:47:42,530 --> 00:47:46,400
massive peripheral the Trust's own

00:47:44,690 --> 00:47:48,320
protection controller will enforce the

00:47:46,400 --> 00:47:53,170
state of them that's bound to the memory

00:47:48,320 --> 00:47:53,170
region against the accessing bus master

00:47:55,720 --> 00:48:00,680
if the hardware if the hardware is done

00:47:58,160 --> 00:48:02,420
properly so if you think of a core being

00:48:00,680 --> 00:48:04,010
not secure it's not going to be able to

00:48:02,420 --> 00:48:05,870
get at to memory that's been designated

00:48:04,010 --> 00:48:17,510
secured by the protection controller in

00:48:05,870 --> 00:48:19,250
a region if it's cacheable if your l2

00:48:17,510 --> 00:48:21,760
the security state is bound to each

00:48:19,250 --> 00:48:21,760
domain as well

00:48:26,220 --> 00:48:33,660
oh you can do that no but you could go

00:48:32,040 --> 00:48:35,460
from you can go from the secure side

00:48:33,660 --> 00:48:51,500
looking a non-secure it's the other way

00:48:35,460 --> 00:48:51,500
around you don't want to go yep yep

00:48:51,530 --> 00:48:56,460
right so if you so you have to mark the

00:48:54,810 --> 00:48:57,750
page table attribute correctly to step

00:48:56,460 --> 00:49:07,680
in the right side and the appropriate

00:48:57,750 --> 00:49:09,180
side of the cache right it will see the

00:49:07,680 --> 00:49:10,680
nonce at your side and what it's seeing

00:49:09,180 --> 00:49:12,750
in the cache Manatee Van Beek oh here

00:49:10,680 --> 00:49:14,670
actually should be coherent because if

00:49:12,750 --> 00:49:17,220
you have the paging set up correctly the

00:49:14,670 --> 00:49:18,570
secure side will be using page tables

00:49:17,220 --> 00:49:29,180
that are marked non secure for the

00:49:18,570 --> 00:49:31,530
cached region yeah could do it

00:49:29,180 --> 00:49:33,180
conceivably I mean that's not I would

00:49:31,530 --> 00:49:36,720
see you have non secure accessing non

00:49:33,180 --> 00:49:38,490
secure yeah no agree yeah yeah no no I

00:49:36,720 --> 00:49:41,280
mean I call that actually probably a

00:49:38,490 --> 00:49:42,540
race condition or bug or somebody's

00:49:41,280 --> 00:49:48,420
deliberately trying to mess with the

00:49:42,540 --> 00:49:49,410
secure domain right right at least at

00:49:48,420 --> 00:49:53,190
least it's not creating a brief

00:49:49,410 --> 00:49:54,870
situation okay yeah baby

00:49:53,190 --> 00:50:02,610
one Corey one core is not in both states

00:49:54,870 --> 00:50:04,200
two cores are different right I don't

00:50:02,610 --> 00:50:07,560
think there's necessarily a mechanism to

00:50:04,200 --> 00:50:09,360
allow locking of it there is a one you

00:50:07,560 --> 00:50:12,650
basically can't get an exclusive lock on

00:50:09,360 --> 00:50:14,490
it at least not what you could rely on

00:50:12,650 --> 00:50:16,110
the only thing you could do is change

00:50:14,490 --> 00:50:19,740
the attribute to secure on the fly if

00:50:16,110 --> 00:50:20,790
it's possible and that could exactly

00:50:19,740 --> 00:50:27,000
this will create this will cause other

00:50:20,790 --> 00:50:31,530
problems yeah you can't by definition

00:50:27,000 --> 00:50:33,330
you can yeah so anyway back to the back

00:50:31,530 --> 00:50:35,790
to the concept so multi-threading can

00:50:33,330 --> 00:50:37,590
get a little bit a little bit confusing

00:50:35,790 --> 00:50:39,320
so it's possible to have multiple

00:50:37,590 --> 00:50:41,570
handles and multiple entries

00:50:39,320 --> 00:50:44,900
to a tee at the same time into a TA so

00:50:41,570 --> 00:50:47,270
it's a be careful so you may have

00:50:44,900 --> 00:50:48,800
unexpected consequences so think

00:50:47,270 --> 00:50:50,480
carefully in terms of writing these the

00:50:48,800 --> 00:50:52,520
reenter C can cause problems we've

00:50:50,480 --> 00:50:54,320
experienced this so it takes a little

00:50:52,520 --> 00:50:55,670
bit of creativity to manage the reds and

00:50:54,320 --> 00:51:01,400
avoid avoid the problem in the first

00:50:55,670 --> 00:51:03,020
place it's possible to counsel a TA so

00:51:01,400 --> 00:51:07,910
typically what you do is start a second

00:51:03,020 --> 00:51:09,470
threader just do a fork a clone and

00:51:07,910 --> 00:51:15,740
effectively from the clone you can cause

00:51:09,470 --> 00:51:17,390
a cancellation to take place I think

00:51:15,740 --> 00:51:19,520
then probably skip this this is actually

00:51:17,390 --> 00:51:22,160
all online within the opti repositories

00:51:19,520 --> 00:51:25,220
is the basic example so effectively a TA

00:51:22,160 --> 00:51:29,540
that prints hello world very

00:51:25,220 --> 00:51:31,280
straightforward and I think that's the

00:51:29,540 --> 00:51:34,100
end of it and my apologies for running

00:51:31,280 --> 00:51:40,070
over then thank you for your patience so

00:51:34,100 --> 00:51:42,140
I guess any other questions when very

00:51:40,070 --> 00:51:44,180
short questions to confirm earlier you

00:51:42,140 --> 00:51:47,410
were saying that the oh please already a

00:51:44,180 --> 00:51:51,440
multi-core ready I assume that means

00:51:47,410 --> 00:51:53,630
it's also having you know like spinning

00:51:51,440 --> 00:51:56,990
log music exclusive synchronization

00:51:53,630 --> 00:51:58,730
putting the calls among themselves right

00:51:56,990 --> 00:52:01,340
there is a new text within the tea

00:51:58,730 --> 00:52:02,930
itself yeah multiprocessor okay so

00:52:01,340 --> 00:52:05,750
that's the show questioning little bit

00:52:02,930 --> 00:52:07,070
longer one is the you look at the opt

00:52:05,750 --> 00:52:10,940
but there's actually a bunch of other

00:52:07,070 --> 00:52:14,900
secure wases like trustees like your for

00:52:10,940 --> 00:52:17,930
base there's at least one more popular

00:52:14,900 --> 00:52:20,360
one is its blank I might have you look

00:52:17,930 --> 00:52:22,220
at others and how do they compare what

00:52:20,360 --> 00:52:24,050
is your opinions we have a license for

00:52:22,220 --> 00:52:25,990
one of the others there I'd say the

00:52:24,050 --> 00:52:28,430
dominant player in the mobile sector

00:52:25,990 --> 00:52:29,780
they have a good implementation the

00:52:28,430 --> 00:52:31,790
thing that I think will happen is

00:52:29,780 --> 00:52:34,670
because opti is open source it will

00:52:31,790 --> 00:52:36,260
probably dominate I've familiar with the

00:52:34,670 --> 00:52:37,940
code going back several years the

00:52:36,260 --> 00:52:40,130
original architecture was very nicely

00:52:37,940 --> 00:52:42,230
done well architected the implementation

00:52:40,130 --> 00:52:43,580
is clean the codes been refactored we've

00:52:42,230 --> 00:52:46,880
been watching it very closely

00:52:43,580 --> 00:52:49,119
what about trusty from google trusty I

00:52:46,880 --> 00:52:52,930
think that's the derivative

00:52:49,119 --> 00:52:55,180
okay that came out of Nvidia I've looked

00:52:52,930 --> 00:52:57,160
inside of it and I would say if you

00:52:55,180 --> 00:52:58,660
can't walk the monitor code in less than

00:52:57,160 --> 00:53:00,759
an hour you're probably looking for

00:52:58,660 --> 00:53:02,109
trouble just my personal opinion but

00:53:00,759 --> 00:53:03,700
some of the things that we're done in

00:53:02,109 --> 00:53:05,529
there a little bit hairier than I'd like

00:53:03,700 --> 00:53:07,660
to see it's the cook the codes more

00:53:05,529 --> 00:53:09,069
complicated than necessary and it we

00:53:07,660 --> 00:53:12,369
don't want to guarantee that there isn't

00:53:09,069 --> 00:53:13,869
means of getting it wrong I'm just

00:53:12,369 --> 00:53:15,670
that's just my personal experience

00:53:13,869 --> 00:53:17,650
looking at it I couldn't take it and

00:53:15,670 --> 00:53:19,990
build it and actually run it to exercise

00:53:17,650 --> 00:53:21,490
because there were missing pieces I mean

00:53:19,990 --> 00:53:23,019
my preference is a starting point is

00:53:21,490 --> 00:53:24,279
either I buy the whole product and work

00:53:23,019 --> 00:53:26,109
with it or I have a license and

00:53:24,279 --> 00:53:27,460
somebody's standing behind it if it's

00:53:26,109 --> 00:53:28,779
open-source I want to build the whole

00:53:27,460 --> 00:53:30,789
thing and tear it apart and walk it

00:53:28,779 --> 00:53:33,819
closely enough many people any sets of

00:53:30,789 --> 00:53:35,559
eyes doing that they're mostly pretty

00:53:33,819 --> 00:53:37,690
much same in terms of their goals

00:53:35,559 --> 00:53:39,880
objectives so there are actually driven

00:53:37,690 --> 00:53:42,640
by a slightly different criteria trying

00:53:39,880 --> 00:53:44,349
to be different beasts the inside of tlk

00:53:42,640 --> 00:53:45,999
is actually different they implemented

00:53:44,349 --> 00:53:47,799
an internal scheduler so it supports

00:53:45,999 --> 00:53:50,470
capabilities that say that go beyond

00:53:47,799 --> 00:53:52,299
beyond what's in opti or beyond what the

00:53:50,470 --> 00:53:53,769
platform would define I mean typically

00:53:52,299 --> 00:53:55,869
trusted execution environment

00:53:53,769 --> 00:53:58,269
historically has been more of a call it

00:53:55,869 --> 00:53:59,799
a tokenized subservient interface what

00:53:58,269 --> 00:54:01,269
they built with tlk went a little bit

00:53:59,799 --> 00:54:02,980
beyond there by putting a native

00:54:01,269 --> 00:54:04,480
scheduler in so if you have a separate

00:54:02,980 --> 00:54:06,940
the ability to designate a separate

00:54:04,480 --> 00:54:08,380
clock you can run native threads you

00:54:06,940 --> 00:54:10,089
then can run it I mean that creates a

00:54:08,380 --> 00:54:11,349
little hairier situation if you need to

00:54:10,089 --> 00:54:12,640
have either competing or dueling

00:54:11,349 --> 00:54:14,410
schedulers running between the two

00:54:12,640 --> 00:54:16,059
domains and that's one place where I

00:54:14,410 --> 00:54:17,499
can't calm it because I really couldn't

00:54:16,059 --> 00:54:20,440
load it build the whole thing and play

00:54:17,499 --> 00:54:22,660
with it I looked inside the code I would

00:54:20,440 --> 00:54:24,069
say it probably works I just can't say

00:54:22,660 --> 00:54:27,460
anything about it I'm not familiar with

00:54:24,069 --> 00:54:28,930
a silicon that it runs on either thanks

00:54:27,460 --> 00:54:30,640
I mean I know I know the environment

00:54:28,930 --> 00:54:33,009
though it's sort of the dominant one on

00:54:30,640 --> 00:54:34,150
mobile that comes out of the UK and I

00:54:33,009 --> 00:54:39,549
mean I think they've done a pretty good

00:54:34,150 --> 00:54:42,009
job of it but I would say you know

00:54:39,549 --> 00:54:43,809
watching the progress of opti I think it

00:54:42,009 --> 00:54:46,420
has a very solid future I think they can

00:54:43,809 --> 00:54:47,829
actually take the lead and run and I'm

00:54:46,420 --> 00:54:49,690
not just being biased on that I've been

00:54:47,829 --> 00:54:50,799
working on the inside of this firm but

00:54:49,690 --> 00:54:52,690
personally I've been working on it for

00:54:50,799 --> 00:54:54,279
more than a year as well and watching

00:54:52,690 --> 00:54:55,809
what's going on and watch very closely

00:54:54,279 --> 00:54:59,739
so I think it's going in the right

00:54:55,809 --> 00:55:01,509
direction I think a lot of promise and I

00:54:59,739 --> 00:55:02,500
mean if any of that I think if any of

00:55:01,509 --> 00:55:03,820
the other

00:55:02,500 --> 00:55:05,020
of the other core people that work on it

00:55:03,820 --> 00:55:07,240
as well you know we'd like to say

00:55:05,020 --> 00:55:09,790
anything by all means please don't

00:55:07,240 --> 00:55:12,070
hesitate that's sort of come in from the

00:55:09,790 --> 00:55:15,000
outside but I have a biased view because

00:55:12,070 --> 00:55:15,000
we've done a lot of work on it

00:55:21,849 --> 00:55:36,640
any other questions thank you

00:55:34,029 --> 00:55:39,759
I was just I came a bit late see my

00:55:36,640 --> 00:55:50,140
cover do like the debug with open a CD

00:55:39,759 --> 00:55:51,309
and the opti linux yes so actually that

00:55:50,140 --> 00:55:52,779
was though at the very beginning we

00:55:51,309 --> 00:55:53,799
walked through them the motivation of

00:55:52,779 --> 00:55:56,769
the pork why we did it

00:55:53,799 --> 00:55:58,690
I mean the pie is combined with all the

00:55:56,769 --> 00:56:00,549
pieces together came to under $70

00:55:58,690 --> 00:56:02,739
including a bus blaster forge a tank

00:56:00,549 --> 00:56:04,569
what we assembled in the kit and we'll

00:56:02,739 --> 00:56:05,799
be going in so Yocum how is the basic

00:56:04,569 --> 00:56:07,630
Colin wheelbarrow full of information

00:56:05,799 --> 00:56:09,849
we've pulled together the information

00:56:07,630 --> 00:56:12,130
for wiring the cable but open OCD

00:56:09,849 --> 00:56:14,079
running in secure running in the secure

00:56:12,130 --> 00:56:17,529
side and our 64 is all running on the

00:56:14,079 --> 00:56:19,839
board so even the profile for the

00:56:17,529 --> 00:56:24,640
raspberry PI's in place the open OCD

00:56:19,839 --> 00:56:28,209
code for our VA arch 64 5 different

00:56:24,640 --> 00:56:30,670
vendors SOC it pretty much works for

00:56:28,209 --> 00:56:32,380
well I'd say it's a lot less expensive

00:56:30,670 --> 00:56:34,930
than some of the alternatives it's

00:56:32,380 --> 00:56:37,329
available in the Pyatt as soon as you

00:56:34,930 --> 00:56:39,160
turn it on it's enabled a new boot so

00:56:37,329 --> 00:56:40,479
you can convene for doing psych basic

00:56:39,160 --> 00:56:45,150
you boot feature development you could

00:56:40,479 --> 00:56:45,150
use a PI for that but it's there

00:56:45,459 --> 00:56:50,709
step one for me is get JTAG working and

00:56:48,249 --> 00:56:52,660
then on that it was I've never worked

00:56:50,709 --> 00:56:55,269
with the l3 one from the our trusted

00:56:52,660 --> 00:56:58,779
firmware and that was sort of the means

00:56:55,269 --> 00:57:02,410
to walk the handoff just interested if

00:56:58,779 --> 00:57:06,999
you have like loading the symbols for up

00:57:02,410 --> 00:57:10,599
to enter gdb everything like the Tsukuba

00:57:06,999 --> 00:57:15,339
everything so the shows there so in open

00:57:10,599 --> 00:57:17,709
OCD we force we force Hardware deep

00:57:15,339 --> 00:57:19,900
hardware breakpoints yep so the

00:57:17,709 --> 00:57:21,400
challenge between art 64 and arts 32 if

00:57:19,900 --> 00:57:23,589
we naval soft breakpoints the sucked

00:57:21,400 --> 00:57:25,690
down the whole construction is encoded

00:57:23,589 --> 00:57:27,489
differently if you drop the wrong

00:57:25,690 --> 00:57:30,009
instruction into the wrong address space

00:57:27,489 --> 00:57:34,240
the core will abort so we impose

00:57:30,009 --> 00:57:37,510
hardware breakpoints next piece was

00:57:34,240 --> 00:57:39,580
the address maps don't collide unless

00:57:37,510 --> 00:57:42,220
you're trying to debug multiple TAS so

00:57:39,580 --> 00:57:46,150
in the startup file we load the symbol

00:57:42,220 --> 00:57:49,570
tables for you boot bill 3-1 opti Linux

00:57:46,150 --> 00:57:51,880
and in the case of the tutorial we've

00:57:49,570 --> 00:57:53,890
put the case of the hackathon we load

00:57:51,880 --> 00:57:56,170
the symbols for a trusted application as

00:57:53,890 --> 00:57:58,810
well those are all art 64 binaries and

00:57:56,170 --> 00:58:00,339
none of the addresses collide so when

00:57:58,810 --> 00:58:03,670
you're running Linux you can control C

00:58:00,339 --> 00:58:06,820
and C that you're sitting waiting around

00:58:03,670 --> 00:58:08,740
and the breakpoints because they're hard

00:58:06,820 --> 00:58:10,240
breakpoints doesn't matter when you set

00:58:08,740 --> 00:58:12,160
them because it's up to the dot to

00:58:10,240 --> 00:58:13,359
enforce so you're not trying to change

00:58:12,160 --> 00:58:20,790
an instruction in the clip in the

00:58:13,359 --> 00:58:20,790
currently mapped address space it's

00:58:22,650 --> 00:58:29,920
maybe weird sounding questions so

00:58:27,310 --> 00:58:34,720
instead of having a trust zone or the

00:58:29,920 --> 00:58:39,990
secure or armed v8 what do you think

00:58:34,720 --> 00:58:42,700
about I just connect to an external TPM

00:58:39,990 --> 00:58:45,220
so TPM well I'd say limit you to

00:58:42,700 --> 00:58:47,109
cryptographic functions and if the TPM

00:58:45,220 --> 00:58:50,470
is external the thing that scares me are

00:58:47,109 --> 00:58:52,089
the bus probing attacks so at this point

00:58:50,470 --> 00:58:53,920
I looked at it from this standpoint if

00:58:52,089 --> 00:58:55,869
you attach a TPM maybe there's some

00:58:53,920 --> 00:58:57,580
benefit for it but from the standpoint

00:58:55,869 --> 00:59:00,400
of actually being able to build an

00:58:57,580 --> 00:59:02,260
application in a secure domain how do

00:59:00,400 --> 00:59:04,180
you isolate memory and the peripherals

00:59:02,260 --> 00:59:05,830
at the same time if you're going to add

00:59:04,180 --> 00:59:07,869
a TPM I'm going to say find it to the

00:59:05,830 --> 00:59:09,760
secured world if you need it for that

00:59:07,869 --> 00:59:12,490
otherwise look for a device that has a

00:59:09,760 --> 00:59:14,470
properly implemented boot chain OTP few

00:59:12,490 --> 00:59:16,270
set and ROM and you can probably at this

00:59:14,470 --> 00:59:17,950
point when I look at the defensive

00:59:16,270 --> 00:59:19,990
features that are available on a lot of

00:59:17,950 --> 00:59:21,880
TPMS they represent potentially a lot of

00:59:19,990 --> 00:59:23,470
additional cost when you may be able to

00:59:21,880 --> 00:59:24,849
spend two dollars and two dollars more

00:59:23,470 --> 00:59:26,619
for your SOC and get similar

00:59:24,849 --> 00:59:28,119
capabilities I mean they're currently

00:59:26,619 --> 00:59:29,500
there are currently parts available to

00:59:28,119 --> 00:59:31,780
have die shields they have on chat

00:59:29,500 --> 00:59:33,880
tamper stamp voltage basically voltage

00:59:31,780 --> 00:59:35,349
temperature and clock sensors so you

00:59:33,880 --> 00:59:38,650
look at the chip sideways and they'll

00:59:35,349 --> 00:59:40,210
bump their keys I mean and this is this

00:59:38,650 --> 00:59:41,830
is state-of-the-art and moving forward

00:59:40,210 --> 00:59:43,570
the higher level the integration is

00:59:41,830 --> 00:59:44,800
coming on a freight train so the

00:59:43,570 --> 00:59:46,309
companies that are leading in the

00:59:44,800 --> 00:59:47,869
development of these SOC sir

00:59:46,309 --> 00:59:50,630
are you familiar with the capabilities a

00:59:47,869 --> 00:59:51,680
lot of them sells TPMS some of them will

00:59:50,630 --> 00:59:53,749
you know they almost compete with

00:59:51,680 --> 00:59:55,339
themselves in ways but when I look at

00:59:53,749 --> 00:59:58,009
you know the majority of companies their

00:59:55,339 --> 00:59:59,089
objective is pom cost reduction so if

00:59:58,009 --> 01:00:01,189
they're looking at I need to have

00:59:59,089 --> 01:00:03,109
another part for this the answer is not

01:00:01,189 --> 01:00:04,579
really not necessarily it really depends

01:00:03,109 --> 01:00:05,779
on what you're trying to achieve at the

01:00:04,579 --> 01:00:06,739
end of the day depends on what you're

01:00:05,779 --> 01:00:08,930
trying to achieve but it's an it

01:00:06,739 --> 01:00:10,819
concerns me is the channel between the

01:00:08,930 --> 01:00:12,559
external element and the CPU itself

01:00:10,819 --> 01:00:14,089
unless they're code unless they're

01:00:12,559 --> 01:00:15,709
mounted in the same package and you've

01:00:14,089 --> 01:00:17,809
raised the bar in terms of external

01:00:15,709 --> 01:00:19,999
physical attacks you know you will get

01:00:17,809 --> 01:00:22,789
the key off a TPM necessarily but the

01:00:19,999 --> 01:00:24,920
data going in between them yeah so I

01:00:22,789 --> 01:00:26,930
understand the security of point and

01:00:24,920 --> 01:00:29,949
also the cost point you just made about

01:00:26,930 --> 01:00:31,579
TPM case what do you think about

01:00:29,949 --> 01:00:34,279
functionality-wise

01:00:31,579 --> 01:00:37,430
if I choose that route compared with

01:00:34,279 --> 01:00:39,380
there is any deficiency advantage the

01:00:37,430 --> 01:00:42,769
pro and cons I don't think so at this

01:00:39,380 --> 01:00:44,509
point when you look at the if you added

01:00:42,769 --> 01:00:46,219
a TPM to a device that already had a

01:00:44,509 --> 01:00:47,660
hardware root of trust capability you've

01:00:46,219 --> 01:00:49,189
got a second device where you have to

01:00:47,660 --> 01:00:50,089
effectively manage and provision so

01:00:49,189 --> 01:00:52,339
you've upped your provision and

01:00:50,089 --> 01:00:53,719
management costs if I look in terms of

01:00:52,339 --> 01:00:55,219
what you can actually implement in terms

01:00:53,719 --> 01:00:56,449
of attestation functions I don't think

01:00:55,219 --> 01:00:57,739
there's anything you can't done with an

01:00:56,449 --> 01:00:59,869
appropriately designed hardware route of

01:00:57,739 --> 01:01:01,099
trust on device so if you're looking at

01:00:59,869 --> 01:01:02,390
things like promote on a station you

01:01:01,099 --> 01:01:04,489
designed the boot chain and the

01:01:02,390 --> 01:01:05,929
functions properly so somebody wants to

01:01:04,489 --> 01:01:07,489
know that what's being booted is done

01:01:05,929 --> 01:01:09,439
properly it's up to how you manage the

01:01:07,489 --> 01:01:12,289
keys and how you manage the boot early

01:01:09,439 --> 01:01:14,119
on when the device is coming out we've

01:01:12,289 --> 01:01:15,679
been asked this you can already get soft

01:01:14,119 --> 01:01:19,849
you can already get implementations of

01:01:15,679 --> 01:01:21,499
TPM api's that are built on basically on

01:01:19,849 --> 01:01:26,469
a cortex and class device and there's no

01:01:21,499 --> 01:01:26,469
TPM there thanks

01:01:34,510 --> 01:01:39,830
looks like no other questions just I'll

01:01:38,360 --> 01:01:41,920
thank everybody for your patience

01:01:39,830 --> 01:01:41,920
especially

01:01:49,480 --> 01:01:51,540

YouTube URL: https://www.youtube.com/watch?v=3MnLrHoQcyI


