Title: EuRuKo 2019: A Plan towards Ruby 3 Types by Yusuke Endoh
Publication date: 2021-01-19
Playlist: EuRuKo 2019
Description: 
	Plan towards Ruby 3 Types

We introduce Ruby Type Profiler which is one of the proposals for Ruby 3â€™s static analysis. As far as we know, it is only one approach to statically analyze a non-type-annotated program for MRI. We aim to realize a static analysis tool that imposes no change of the great Ruby programming experience.

Yusuke Endoh - https://twitter.com/mametter
EuRuKo 2019
Captions: 
	00:00:06,080 --> 00:00:09,840
what we have

00:00:07,200 --> 00:00:13,120
now is a talk by a full-time ruby

00:00:09,840 --> 00:00:13,120
committer that works at cookpet

00:00:13,519 --> 00:00:16,800
in that capacity he really likes it that

00:00:15,360 --> 00:00:19,039
he can work together with

00:00:16,800 --> 00:00:19,840
yukida matsumoto on at least a monthly

00:00:19,039 --> 00:00:24,080
basis

00:00:19,840 --> 00:00:27,119
so that's nice and um i've heard he's a

00:00:24,080 --> 00:00:27,519
well very good programmer and then no no

00:00:27,119 --> 00:00:30,320
it's a

00:00:27,519 --> 00:00:31,920
it's a really brilliant programmer so um

00:00:30,320 --> 00:00:32,880
i think that's nice that we have him on

00:00:31,920 --> 00:00:37,600
stage as well

00:00:32,880 --> 00:00:41,120
and he's the winner of the iocc

00:00:37,600 --> 00:00:45,120
which is the international obfuscated c

00:00:41,120 --> 00:00:46,640
code contest you could say he never gets

00:00:45,120 --> 00:00:48,399
seasick

00:00:46,640 --> 00:00:50,719
[Laughter]

00:00:48,399 --> 00:00:50,719
yes

00:00:56,559 --> 00:01:04,700
a fresh round of applause for yusuke

00:01:01,440 --> 00:01:04,700
[Applause]

00:01:06,400 --> 00:01:08,799
thank you

00:01:09,920 --> 00:01:15,920
my name is yusuke endo i come out to

00:01:13,439 --> 00:01:15,920
japan

00:01:18,960 --> 00:01:25,520
and this is all i know about that

00:01:22,320 --> 00:01:28,880
and so i'll talk about plan

00:01:25,520 --> 00:01:31,040
towards ruby three types unfortunately i

00:01:28,880 --> 00:01:34,000
will not talk about iocc

00:01:31,040 --> 00:01:34,000
but anyway

00:01:34,159 --> 00:01:39,759
i'm yusuke endo and i came from japan

00:01:37,360 --> 00:01:41,360
i'm working at cookbot as a free-time

00:01:39,759 --> 00:01:44,880
ruby committee

00:01:41,360 --> 00:01:47,200
so my job is to develop called mri

00:01:44,880 --> 00:01:49,520
maturity interpreter

00:01:47,200 --> 00:01:50,479
quickbot employs two full-time ruby

00:01:49,520 --> 00:01:55,119
committees me

00:01:50,479 --> 00:01:58,560
and coach and koiz you may know a

00:01:55,119 --> 00:02:02,320
ruby vm guy and he makes ruby faster

00:01:58,560 --> 00:02:04,880
so i'm now here and thanks to cookbots

00:02:02,320 --> 00:02:05,600
for sending me to lockdown so let me

00:02:04,880 --> 00:02:08,720
briefly

00:02:05,600 --> 00:02:10,720
introduce our company we are providing

00:02:08,720 --> 00:02:13,040
some services

00:02:10,720 --> 00:02:16,319
for our mission to make everyday cooking

00:02:13,040 --> 00:02:20,160
fun and the biggest service is quick.com

00:02:16,319 --> 00:02:21,680
which is also sharing platform service

00:02:20,160 --> 00:02:24,160
you can submit your original cooking

00:02:21,680 --> 00:02:27,599
list and you can also find

00:02:24,160 --> 00:02:30,000
reviews of other users

00:02:27,599 --> 00:02:32,400
there are 90 million monthly average

00:02:30,000 --> 00:02:35,920
users in the world

00:02:32,400 --> 00:02:40,239
currently quickbot supports two uh

00:02:35,920 --> 00:02:44,480
sorry 29 languages and services at

00:02:40,239 --> 00:02:46,560
72 countries this service is still

00:02:44,480 --> 00:02:50,720
growing to aim to be number one

00:02:46,560 --> 00:02:54,000
in 100 countries uh and cookbook is

00:02:50,720 --> 00:02:55,760
little in ruby on rails to develop and

00:02:54,000 --> 00:02:58,400
maintain this large-scale

00:02:55,760 --> 00:02:59,120
service we need many great ruby

00:02:58,400 --> 00:03:02,239
engineers

00:02:59,120 --> 00:03:03,280
so we are hiring i'm working at japan

00:03:02,239 --> 00:03:06,800
but cookbook

00:03:03,280 --> 00:03:08,879
headquarters in bristol united kingdom

00:03:06,800 --> 00:03:10,400
so if you are interested feel free to

00:03:08,879 --> 00:03:14,080
contact on me

00:03:10,400 --> 00:03:14,080
okay i did the job and

00:03:15,680 --> 00:03:20,720
in cookbook as i said i am developing

00:03:17,760 --> 00:03:23,200
ruby my main contributions

00:03:20,720 --> 00:03:23,840
include the implementation of keyword

00:03:23,200 --> 00:03:28,640
arguments

00:03:23,840 --> 00:03:28,640
in 2.0 thank you

00:03:31,200 --> 00:03:34,640
and test the coverage measurement

00:03:32,480 --> 00:03:37,360
feature and de facto standard

00:03:34,640 --> 00:03:39,200
benchmark uh program called ruby 3c

00:03:37,360 --> 00:03:41,519
called optical

00:03:39,200 --> 00:03:42,400
recently i proposed implemented and

00:03:41,519 --> 00:03:46,239
committed

00:03:42,400 --> 00:03:48,000
endless lens in 2.6 and the

00:03:46,239 --> 00:03:50,720
beginningless lens is

00:03:48,000 --> 00:03:51,680
front to b shifts in the next release to

00:03:50,720 --> 00:03:56,080
0.7

00:03:51,680 --> 00:03:59,439
in december this year and we are now

00:03:56,080 --> 00:04:03,760
developing ruby 3 which is planned to be

00:03:59,439 --> 00:04:07,519
released in 2020. as much said

00:04:03,760 --> 00:04:10,640
in his keynote ruby 3 had three goals

00:04:07,519 --> 00:04:11,840
first is performance as long as ruby 3

00:04:10,640 --> 00:04:14,640
by 3

00:04:11,840 --> 00:04:16,880
which means ruby 3 will be three times

00:04:14,640 --> 00:04:19,759
faster than louis 2.0

00:04:16,880 --> 00:04:20,239
the second is concurrency ruby 3 will

00:04:19,759 --> 00:04:23,199
provide

00:04:20,239 --> 00:04:24,960
a better concurrency model than the

00:04:23,199 --> 00:04:26,960
traditional threat model

00:04:24,960 --> 00:04:28,240
and that is static analysis and this is

00:04:26,960 --> 00:04:31,440
my main mission

00:04:28,240 --> 00:04:33,680
and ruby 3 will provide a way to analyze

00:04:31,440 --> 00:04:37,120
ruby programs statically

00:04:33,680 --> 00:04:40,240
this goal was the most uncertain

00:04:37,120 --> 00:04:43,919
among these three goals since

00:04:40,240 --> 00:04:46,479
years ago i have monthly discussed

00:04:43,919 --> 00:04:47,440
this goal with maths and other

00:04:46,479 --> 00:04:49,280
contributors

00:04:47,440 --> 00:04:52,080
and recently we could figure out the

00:04:49,280 --> 00:04:54,720
goal as a concrete problem

00:04:52,080 --> 00:04:55,199
so in this talk i'd like to introduce

00:04:54,720 --> 00:04:58,240
the

00:04:55,199 --> 00:05:01,280
current maths plan for ruby static and

00:04:58,240 --> 00:05:04,240
with static analysis or revision types

00:05:01,280 --> 00:05:06,240
and then i will explain one of the

00:05:04,240 --> 00:05:08,840
components in this program

00:05:06,240 --> 00:05:11,440
called type profiler which i am now

00:05:08,840 --> 00:05:15,120
developing okay so first

00:05:11,440 --> 00:05:15,120
i explained maths plan

00:05:15,360 --> 00:05:19,039
the objective of three three type

00:05:17,199 --> 00:05:22,400
advocacy types is to find

00:05:19,039 --> 00:05:24,960
a possible type bug

00:05:22,400 --> 00:05:26,240
it aims to provide helpful information

00:05:24,960 --> 00:05:29,759
for a programmer to

00:05:26,240 --> 00:05:30,240
write and debug lubi code type analysis

00:05:29,759 --> 00:05:32,000
can

00:05:30,240 --> 00:05:33,840
be sometimes used for performance

00:05:32,000 --> 00:05:35,039
improvement but in this case it is not

00:05:33,840 --> 00:05:38,080
our scope

00:05:35,039 --> 00:05:40,479
and we have important requirement

00:05:38,080 --> 00:05:41,520
we must keep the greatest programming

00:05:40,479 --> 00:05:45,759
experience

00:05:41,520 --> 00:05:45,759
of ruby so for example

00:05:47,039 --> 00:05:53,919
we must not impose already user to write

00:05:50,960 --> 00:05:54,639
a type annotation like this to make type

00:05:53,919 --> 00:05:58,479
type check

00:05:54,639 --> 00:06:01,360
easy or feasible of course

00:05:58,479 --> 00:06:02,479
if you want to write annotation we don't

00:06:01,360 --> 00:06:05,520
stop so

00:06:02,479 --> 00:06:08,400
please write yourself but

00:06:05,520 --> 00:06:10,720
we want to keep ruby annotated by

00:06:08,400 --> 00:06:14,720
default

00:06:10,720 --> 00:06:18,319
based on this objective and requirement

00:06:14,720 --> 00:06:21,440
ruby will provide three items for

00:06:18,319 --> 00:06:24,240
static analysis first is a

00:06:21,440 --> 00:06:25,759
standard type signature format and

00:06:24,240 --> 00:06:28,800
second is a type layer

00:06:25,759 --> 00:06:32,479
sorry level one type thicker and a

00:06:28,800 --> 00:06:33,280
kind type inference this requires no

00:06:32,479 --> 00:06:36,400
signatures

00:06:33,280 --> 00:06:37,120
and reports a possible bug and suggests

00:06:36,400 --> 00:06:39,280
a

00:06:37,120 --> 00:06:41,039
prototype of type signatures for no

00:06:39,280 --> 00:06:44,400
entity to ruby code

00:06:41,039 --> 00:06:46,560
and third is a level 2 type checker

00:06:44,400 --> 00:06:48,000
this requires type signatures and

00:06:46,560 --> 00:06:51,039
verifies that the code

00:06:48,000 --> 00:06:55,199
complies with the its signature

00:06:51,039 --> 00:06:58,639
i will explain these three in time

00:06:55,199 --> 00:07:01,199
first is a type signature format

00:06:58,639 --> 00:07:02,720
this is an example for regress written

00:07:01,199 --> 00:07:05,520
request

00:07:02,720 --> 00:07:07,599
this code looks similar to ruby but in

00:07:05,520 --> 00:07:10,639
fact it is not lobby

00:07:07,599 --> 00:07:14,560
this file complaint complements

00:07:10,639 --> 00:07:16,880
lube code and shows what types

00:07:14,560 --> 00:07:18,160
each method accepts and returns for

00:07:16,880 --> 00:07:21,919
example rh

00:07:18,160 --> 00:07:23,120
you know accepts a block and it returns

00:07:21,919 --> 00:07:26,240
itself

00:07:23,120 --> 00:07:27,360
and this block accepts an element type

00:07:26,240 --> 00:07:29,840
of this array

00:07:27,360 --> 00:07:30,560
and the result is in this case boiled

00:07:29,840 --> 00:07:33,919
which means

00:07:30,560 --> 00:07:35,840
it is just ignored

00:07:33,919 --> 00:07:37,280
this signature format supports some

00:07:35,840 --> 00:07:40,479
features for

00:07:37,280 --> 00:07:43,199
representing lubricate in type such as

00:07:40,479 --> 00:07:44,000
generics mixing optional type interface

00:07:43,199 --> 00:07:47,599
in any type

00:07:44,000 --> 00:07:50,080
rubber and you can find the current

00:07:47,599 --> 00:07:53,759
proposal for this format

00:07:50,080 --> 00:07:56,960
namely ruby signature

00:07:53,759 --> 00:07:58,720
and the next is a type checker that does

00:07:56,960 --> 00:08:01,440
not require signatures

00:07:58,720 --> 00:08:03,280
it attempts to find a possible error

00:08:01,440 --> 00:08:04,000
including no message delay type error

00:08:03,280 --> 00:08:08,639
and

00:08:04,000 --> 00:08:12,000
a kind of argumentation it works even if

00:08:08,639 --> 00:08:15,759
application has no signatures so it may

00:08:12,000 --> 00:08:18,960
report for responsive this is a example

00:08:15,759 --> 00:08:21,840
this soup is a typo so the czech

00:08:18,960 --> 00:08:22,080
reports it may cause no mess of error

00:08:21,840 --> 00:08:25,680
and

00:08:22,080 --> 00:08:30,080
in this case a variable s is a string

00:08:25,680 --> 00:08:34,320
so s plus 42 is one as a

00:08:30,080 --> 00:08:37,279
possible type error currently

00:08:34,320 --> 00:08:40,000
there are two purposes for this item one

00:08:37,279 --> 00:08:43,599
is type profile which i am developing

00:08:40,000 --> 00:08:44,880
i'll explain this later and the other is

00:08:43,599 --> 00:08:47,920
emerald's

00:08:44,880 --> 00:08:49,360
experimental zit compiler called mlb

00:08:47,920 --> 00:08:52,640
meta circular

00:08:49,360 --> 00:08:55,920
which performs similarities to reduced

00:08:52,640 --> 00:08:58,320
long-term type checking overhead

00:08:55,920 --> 00:08:59,680
and level one type checker is also

00:08:58,320 --> 00:09:03,200
supposed to have a

00:08:59,680 --> 00:09:05,519
cleaned typing furnace feature

00:09:03,200 --> 00:09:06,640
this feature suggests a prototype of

00:09:05,519 --> 00:09:09,680
type signatures

00:09:06,640 --> 00:09:13,440
for no answer to record for example

00:09:09,680 --> 00:09:16,959
if the cheque reads this code

00:09:13,440 --> 00:09:20,160
it suggests that the function who

00:09:16,959 --> 00:09:20,959
should receive string one integer and

00:09:20,160 --> 00:09:24,000
should return

00:09:20,959 --> 00:09:27,040
a string and

00:09:24,000 --> 00:09:29,120
the type sorry at level one type

00:09:27,040 --> 00:09:30,000
checking and type inference can be both

00:09:29,120 --> 00:09:32,000
done by

00:09:30,000 --> 00:09:33,360
the same approach called abstract

00:09:32,000 --> 00:09:37,040
interpolation technique

00:09:33,360 --> 00:09:41,040
uh much set in his keynote it battery

00:09:37,040 --> 00:09:43,920
battery lands a loopy code in type level

00:09:41,040 --> 00:09:44,640
and prints what types each method

00:09:43,920 --> 00:09:50,320
accepts and

00:09:44,640 --> 00:09:53,519
returns in type signature format

00:09:50,320 --> 00:09:54,959
okay and the second shadow is a level 2

00:09:53,519 --> 00:09:57,440
type checker

00:09:54,959 --> 00:09:58,720
this is somewhat traditional traditional

00:09:57,440 --> 00:10:01,360
type checking

00:09:58,720 --> 00:10:02,320
so it requires a signature for each

00:10:01,360 --> 00:10:05,600
record

00:10:02,320 --> 00:10:08,800
and verifies that the code complies with

00:10:05,600 --> 00:10:11,040
its signature it is based on

00:10:08,800 --> 00:10:12,720
some established techniques including

00:10:11,040 --> 00:10:16,079
gradual type checking

00:10:12,720 --> 00:10:19,120
and currently there are three problems

00:10:16,079 --> 00:10:20,000
there are three proposals for level two

00:10:19,120 --> 00:10:22,800
checking

00:10:20,000 --> 00:10:24,640
uh called steep solubility rdl

00:10:22,800 --> 00:10:26,399
unfortunately they require not only

00:10:24,640 --> 00:10:27,360
signatures but also two defined

00:10:26,399 --> 00:10:30,880
annotations but

00:10:27,360 --> 00:10:34,640
at the cost they can verify record

00:10:30,880 --> 00:10:38,079
more deeply than level one type checking

00:10:34,640 --> 00:10:41,200
okay and i review the three

00:10:38,079 --> 00:10:42,079
items first is a type signature for ruby

00:10:41,200 --> 00:10:45,360
code

00:10:42,079 --> 00:10:48,320
almost all libraries is supposed to

00:10:45,360 --> 00:10:50,560
bundle their signatures and second is

00:10:48,320 --> 00:10:52,560
level 1 checking

00:10:50,560 --> 00:10:53,760
it is libraries signature and

00:10:52,560 --> 00:10:58,240
application code

00:10:53,760 --> 00:11:01,279
and produces possible type errors

00:10:58,240 --> 00:11:04,480
and it also

00:11:01,279 --> 00:11:07,120
uh suggests a prototype of

00:11:04,480 --> 00:11:08,560
type signatures for uh no antique

00:11:07,120 --> 00:11:11,040
application code

00:11:08,560 --> 00:11:13,040
and finally level two type checker

00:11:11,040 --> 00:11:15,839
provides

00:11:13,040 --> 00:11:18,320
the correspondence between application

00:11:15,839 --> 00:11:21,360
code and its signature

00:11:18,320 --> 00:11:22,800
and if they find the inconsistency they

00:11:21,360 --> 00:11:26,560
report

00:11:22,800 --> 00:11:30,079
it as a warning now there are

00:11:26,560 --> 00:11:32,959
some use cases for this to change

00:11:30,079 --> 00:11:34,240
at first if you if you are not

00:11:32,959 --> 00:11:36,399
interested in

00:11:34,240 --> 00:11:37,440
static checking at all you don't have to

00:11:36,399 --> 00:11:41,440
use anything

00:11:37,440 --> 00:11:44,320
of course and if you want to just find

00:11:41,440 --> 00:11:45,519
a possible bug but if you are not so

00:11:44,320 --> 00:11:49,120
interested

00:11:45,519 --> 00:11:51,440
in types you can write a code as before

00:11:49,120 --> 00:11:52,720
and just apply type level 1 type

00:11:51,440 --> 00:11:55,200
checking

00:11:52,720 --> 00:11:56,639
and if you want to verify your code more

00:11:55,200 --> 00:12:00,160
deeply

00:11:56,639 --> 00:12:01,360
you can write a code apply everyone

00:12:00,160 --> 00:12:04,560
check how to prove

00:12:01,360 --> 00:12:07,920
prototype signature and finally

00:12:04,560 --> 00:12:11,120
apply level 2 checker if you might

00:12:07,920 --> 00:12:14,720
want to write a code in typed ribbon

00:12:11,120 --> 00:12:16,399
cell like other statically put languages

00:12:14,720 --> 00:12:19,360
such as haskell

00:12:16,399 --> 00:12:20,720
you can first write a signature and then

00:12:19,360 --> 00:12:24,560
write a code

00:12:20,720 --> 00:12:26,480
finally apply you will check

00:12:24,560 --> 00:12:28,079
each tools is currently under

00:12:26,480 --> 00:12:31,440
development

00:12:28,079 --> 00:12:31,920
now all the projects are now open source

00:12:31,440 --> 00:12:35,360
including

00:12:31,920 --> 00:12:36,240
subway as you know and ruby signature is

00:12:35,360 --> 00:12:38,560
now discussed

00:12:36,240 --> 00:12:40,560
mainly by tourist developers but you can

00:12:38,560 --> 00:12:44,079
comment on

00:12:40,560 --> 00:12:46,160
on this repository and typo era

00:12:44,079 --> 00:12:47,519
my project is very still very

00:12:46,160 --> 00:12:49,519
experimental

00:12:47,519 --> 00:12:51,200
and it has still some problems but i

00:12:49,519 --> 00:12:54,480
believe it is

00:12:51,200 --> 00:12:57,760
the most rich way to analyze record

00:12:54,480 --> 00:13:00,720
and steep is in trail

00:12:57,760 --> 00:13:02,800
status it is experimentally used inside

00:13:00,720 --> 00:13:05,920
the inc

00:13:02,800 --> 00:13:07,680
company whose cto is the author of steep

00:13:05,920 --> 00:13:10,320
sotalo matsumoto

00:13:07,680 --> 00:13:11,040
and it is based on structural subtyping

00:13:10,320 --> 00:13:15,440
so

00:13:11,040 --> 00:13:18,079
it can handle it can deal with

00:13:15,440 --> 00:13:19,120
that typing very well but the author

00:13:18,079 --> 00:13:21,279
says

00:13:19,120 --> 00:13:23,760
it requires relatively a lot of

00:13:21,279 --> 00:13:27,360
annotations inline annotations

00:13:23,760 --> 00:13:30,800
and solve is most mature

00:13:27,360 --> 00:13:31,920
among these truths and it is developed

00:13:30,800 --> 00:13:35,440
by a theme of

00:13:31,920 --> 00:13:39,839
stripe and experimentally used

00:13:35,440 --> 00:13:43,360
in stripe and some companies and

00:13:39,839 --> 00:13:45,279
it is kind of play as you go so

00:13:43,360 --> 00:13:47,440
it works without annotation but the

00:13:45,279 --> 00:13:50,399
verification is not so deep

00:13:47,440 --> 00:13:52,480
if you write a signature and annotation

00:13:50,399 --> 00:13:55,120
so we can verify your code

00:13:52,480 --> 00:13:56,160
more deeply much more deeply the weak

00:13:55,120 --> 00:13:59,519
point of survey

00:13:56,160 --> 00:14:02,480
is it has less support for duck typing

00:13:59,519 --> 00:14:03,600
we need to like include modules

00:14:02,480 --> 00:14:07,360
explicitly to

00:14:03,600 --> 00:14:07,360
represent duck typing

00:14:07,519 --> 00:14:14,639
what ruby 3 will ship in current plan

00:14:11,279 --> 00:14:16,240
much wants to build things related to

00:14:14,639 --> 00:14:18,880
type signature itself

00:14:16,240 --> 00:14:20,560
including a path library info the type

00:14:18,880 --> 00:14:22,160
similar format

00:14:20,560 --> 00:14:25,279
type signature files for standard

00:14:22,160 --> 00:14:26,639
libraries and louis gems that can deal

00:14:25,279 --> 00:14:29,519
with

00:14:26,639 --> 00:14:31,040
type signature files and there are no

00:14:29,519 --> 00:14:33,440
plan to boundary and check because

00:14:31,040 --> 00:14:34,880
they will be released uh as extensions

00:14:33,440 --> 00:14:37,279
for for well but

00:14:34,880 --> 00:14:38,079
recently here must want to bundle type

00:14:37,279 --> 00:14:40,160
profiler

00:14:38,079 --> 00:14:42,079
because typing currency is relatively

00:14:40,160 --> 00:14:45,440
important in the two chain

00:14:42,079 --> 00:14:48,959
so this pronoun is still discussed and

00:14:45,440 --> 00:14:52,800
may change in future okay

00:14:48,959 --> 00:14:55,839
i proceed the next topic my project

00:14:52,800 --> 00:14:57,920
called type profiler

00:14:55,839 --> 00:14:59,920
and this is working example of type

00:14:57,920 --> 00:15:02,639
require

00:14:59,920 --> 00:15:04,399
this is this program has a type time

00:15:02,639 --> 00:15:07,519
it's not times

00:15:04,399 --> 00:15:08,720
by applying type profiler to this

00:15:07,519 --> 00:15:12,160
program

00:15:08,720 --> 00:15:15,680
an error undefined method integer

00:15:12,160 --> 00:15:18,880
times is reported

00:15:15,680 --> 00:15:22,399
and this is an example inference by

00:15:18,880 --> 00:15:25,839
applying type profiler to discourse

00:15:22,399 --> 00:15:28,320
it will say that the function who

00:15:25,839 --> 00:15:29,120
is defined and it receives an integer

00:15:28,320 --> 00:15:32,160
and

00:15:29,120 --> 00:15:36,639
returns link in

00:15:32,160 --> 00:15:40,160
type signature format integer to string

00:15:36,639 --> 00:15:42,560
and this is example overloading

00:15:40,160 --> 00:15:43,600
this function receives integers and

00:15:42,560 --> 00:15:46,560
string and

00:15:43,600 --> 00:15:47,839
symbol and in any case it always returns

00:15:46,560 --> 00:15:51,120
a string

00:15:47,839 --> 00:15:53,839
so these three signatures are produced

00:15:51,120 --> 00:15:54,240
integer two string and string to storing

00:15:53,839 --> 00:15:57,120
and

00:15:54,240 --> 00:15:57,120
symbol to storing

00:15:57,759 --> 00:16:01,839
this is an example of recursive method

00:16:00,480 --> 00:16:03,759
typefire is a

00:16:01,839 --> 00:16:04,959
battery interpreter so navy

00:16:03,759 --> 00:16:07,920
implementation

00:16:04,959 --> 00:16:09,680
calls may cause a stack overflow to

00:16:07,920 --> 00:16:12,720
learn this code but

00:16:09,680 --> 00:16:16,000
it were handled by using so-called in

00:16:12,720 --> 00:16:17,440
context sorry context context in

00:16:16,000 --> 00:16:22,000
sensitive analysis

00:16:17,440 --> 00:16:27,040
and it produces a signature saying uh

00:16:22,000 --> 00:16:30,160
table is an integer to integer method

00:16:27,040 --> 00:16:33,279
okay so this is the demonstration but

00:16:30,160 --> 00:16:36,399
and i explain then

00:16:33,279 --> 00:16:39,040
the basic idea of type provider

00:16:36,399 --> 00:16:41,600
it is an abstract interpreter i set to

00:16:39,040 --> 00:16:44,959
learn a library code in type level

00:16:41,600 --> 00:16:48,320
this slide shows a very simple example

00:16:44,959 --> 00:16:51,360
in a normal interpreter it this

00:16:48,320 --> 00:16:54,959
call who passes an integer object

00:16:51,360 --> 00:16:58,639
42 and the method returns a string

00:16:54,959 --> 00:17:02,480
object 42 as you know and

00:16:58,639 --> 00:17:05,520
in on the contrary in type profiler

00:17:02,480 --> 00:17:09,520
this call passes uh integer type

00:17:05,520 --> 00:17:12,400
itself instead of a concrete value 42

00:17:09,520 --> 00:17:13,039
and the method returns a string type

00:17:12,400 --> 00:17:16,240
instead of

00:17:13,039 --> 00:17:19,679
concrete string content that contains

00:17:16,240 --> 00:17:23,120
42 and so

00:17:19,679 --> 00:17:25,760
type type provider records what types

00:17:23,120 --> 00:17:26,640
passed and returned and shows the

00:17:25,760 --> 00:17:30,240
observation

00:17:26,640 --> 00:17:34,240
in type signature format like this

00:17:30,240 --> 00:17:37,360
okay and the difficult part of

00:17:34,240 --> 00:17:38,080
type profiler is a branch because type

00:17:37,360 --> 00:17:41,280
profiler

00:17:38,080 --> 00:17:44,000
abstracts a concrete value so we cannot

00:17:41,280 --> 00:17:47,440
tell which branch is executed select it

00:17:44,000 --> 00:17:50,880
for example uh consider we are now here

00:17:47,440 --> 00:17:51,280
and the type profiler is attempting at

00:17:50,880 --> 00:17:55,760
an

00:17:51,280 --> 00:17:58,240
attempt to uh abrade this

00:17:55,760 --> 00:17:59,520
but type profile just knows n is an

00:17:58,240 --> 00:18:02,960
integer

00:17:59,520 --> 00:18:06,720
there is no concrete information

00:18:02,960 --> 00:18:07,120
so it cannot determine if any less than

00:18:06,720 --> 00:18:10,240
00:18:07,120 --> 00:18:12,320
is through a horse so type profiler

00:18:10,240 --> 00:18:15,440
hooks the execution

00:18:12,320 --> 00:18:18,880
like this and both learns both zen and

00:18:15,440 --> 00:18:22,080
else clauses in this case uh

00:18:18,880 --> 00:18:25,919
zen clause returns an integer and

00:18:22,080 --> 00:18:28,960
escrows returns a string and

00:18:25,919 --> 00:18:30,480
by gathering the results type profiler

00:18:28,960 --> 00:18:33,679
suggests

00:18:30,480 --> 00:18:36,960
at type signature like

00:18:33,679 --> 00:18:39,440
by using a union type integer to integer

00:18:36,960 --> 00:18:39,440
worsely

00:18:39,679 --> 00:18:46,960
as you might see this approach may cause

00:18:43,760 --> 00:18:50,720
so-called state explosion problem

00:18:46,960 --> 00:18:54,080
this code is a typical example

00:18:50,720 --> 00:18:58,080
it initializes variables a b c d

00:18:54,080 --> 00:19:00,960
and e as nil and conditionally assigns

00:18:58,080 --> 00:19:02,720
an integer to variable a and then

00:19:00,960 --> 00:19:05,919
conditionally

00:19:02,720 --> 00:19:09,039
assigns an integer to b rubra and

00:19:05,919 --> 00:19:12,160
these branches calls

00:19:09,039 --> 00:19:14,559
hooks and then

00:19:12,160 --> 00:19:15,760
the number of states are doubled for

00:19:14,559 --> 00:19:18,880
each branch

00:19:15,760 --> 00:19:20,640
this is a state explosion problem this

00:19:18,880 --> 00:19:24,000
problem actually occurs

00:19:20,640 --> 00:19:26,480
in the experiment and when

00:19:24,000 --> 00:19:29,039
i took type profiler in lubikai a

00:19:26,480 --> 00:19:33,440
japanese ruby conference

00:19:29,039 --> 00:19:36,720
to april and at the time

00:19:33,440 --> 00:19:39,280
the analysis was very long

00:19:36,720 --> 00:19:41,600
for example uh type of a type profiler

00:19:39,280 --> 00:19:42,720
is written in ruby so it is applicable

00:19:41,600 --> 00:19:45,760
to itself

00:19:42,720 --> 00:19:47,919
but it took 10 minutes and analyzing

00:19:45,760 --> 00:19:49,600
my benchmark program called opt carrot

00:19:47,919 --> 00:19:53,200
for rubi3

00:19:49,600 --> 00:19:56,480
took about three minutes so i admitted

00:19:53,200 --> 00:20:00,480
that type of ira was not usually

00:19:56,480 --> 00:20:02,320
practically at the time so i spent the

00:20:00,480 --> 00:20:05,760
time i spent time to

00:20:02,320 --> 00:20:08,799
revamp the analysis algorithm

00:20:05,760 --> 00:20:10,640
i investigated some papers in research

00:20:08,799 --> 00:20:11,919
area of abstract interpretation and

00:20:10,640 --> 00:20:14,320
symbolic execution and

00:20:11,919 --> 00:20:16,159
inspired by a technique called

00:20:14,320 --> 00:20:19,440
statements i improved

00:20:16,159 --> 00:20:21,520
the algorithm significantly and

00:20:19,440 --> 00:20:23,280
i briefly explained the current analysis

00:20:21,520 --> 00:20:26,320
algorithm improved by

00:20:23,280 --> 00:20:27,280
statementing as you may know an

00:20:26,320 --> 00:20:30,799
interpreter

00:20:27,280 --> 00:20:31,600
uses an environment which is a map from

00:20:30,799 --> 00:20:35,520
a variable

00:20:31,600 --> 00:20:37,360
to value but in type profiler

00:20:35,520 --> 00:20:39,919
a type profiler is an abstract

00:20:37,360 --> 00:20:43,760
interpreter that abstracts

00:20:39,919 --> 00:20:48,080
the value to type so environment

00:20:43,760 --> 00:20:49,679
in this case is a map from variable to a

00:20:48,080 --> 00:20:52,559
type

00:20:49,679 --> 00:20:53,760
this table represents an example an

00:20:52,559 --> 00:20:57,440
environment

00:20:53,760 --> 00:20:58,000
x is a union type of integer and string

00:20:57,440 --> 00:21:01,360
so

00:20:58,000 --> 00:21:02,880
it means in x is integer string and y is

00:21:01,360 --> 00:21:04,880
an integer

00:21:02,880 --> 00:21:06,799
in type profiler each bytecode

00:21:04,880 --> 00:21:09,840
instruction has an environment

00:21:06,799 --> 00:21:11,919
and type profiler simulates

00:21:09,840 --> 00:21:14,000
each instruction by mutating and

00:21:11,919 --> 00:21:17,200
propagating the environment

00:21:14,000 --> 00:21:20,720
for example assume x is a nil

00:21:17,200 --> 00:21:22,159
and y is an integer and now we are

00:21:20,720 --> 00:21:25,360
executing this

00:21:22,159 --> 00:21:27,600
assignment x equal one type preference

00:21:25,360 --> 00:21:29,840
simulates this instruction by mutating

00:21:27,600 --> 00:21:32,799
and propagating each

00:21:29,840 --> 00:21:34,000
type from plate environment to post

00:21:32,799 --> 00:21:36,000
environment

00:21:34,000 --> 00:21:37,440
in this case postal environment is

00:21:36,000 --> 00:21:40,799
assumed

00:21:37,440 --> 00:21:44,000
initial is empty and x is now

00:21:40,799 --> 00:21:46,640
an integer by this assignment and

00:21:44,000 --> 00:21:47,360
why it's not affected by this assignment

00:21:46,640 --> 00:21:51,520
so

00:21:47,360 --> 00:21:53,919
it is just kept so still it integer

00:21:51,520 --> 00:21:55,039
and type where repeats this process

00:21:53,919 --> 00:21:59,120
until the

00:21:55,039 --> 00:22:02,559
environment updates combuses

00:21:59,120 --> 00:22:05,600
and this is a larger example

00:22:02,559 --> 00:22:08,799
this code defines a function who and

00:22:05,600 --> 00:22:12,480
because it

00:22:08,799 --> 00:22:15,840
defines a function who and calls it and

00:22:12,480 --> 00:22:17,039
this core instruction propagates an

00:22:15,840 --> 00:22:20,320
integer to

00:22:17,039 --> 00:22:23,440
argument of argument a of a

00:22:20,320 --> 00:22:26,480
function who so this part

00:22:23,440 --> 00:22:29,840
oops helps this part

00:22:26,480 --> 00:22:31,280
okay it's changed it passes an integer

00:22:29,840 --> 00:22:34,400
to

00:22:31,280 --> 00:22:38,240
a in line one and now

00:22:34,400 --> 00:22:42,000
we focus the first line there are no

00:22:38,240 --> 00:22:45,200
meaningful statement in first line so

00:22:42,000 --> 00:22:49,440
it just copies the environment to

00:22:45,200 --> 00:22:53,520
the next line line two like this

00:22:49,440 --> 00:22:56,799
now then we are at line three

00:22:53,520 --> 00:22:58,080
this instruction is the branch so we

00:22:56,799 --> 00:23:01,360
focus the execution

00:22:58,080 --> 00:23:04,559
and propagates the both branches

00:23:01,360 --> 00:23:07,600
like this line three and line five

00:23:04,559 --> 00:23:10,640
okay like this and then

00:23:07,600 --> 00:23:14,159
focus line three this assigns an

00:23:10,640 --> 00:23:18,240
integer to a to

00:23:14,159 --> 00:23:20,720
variable b so

00:23:18,240 --> 00:23:21,360
note that the next instruction is line

00:23:20,720 --> 00:23:24,559
seven

00:23:21,360 --> 00:23:28,320
so it rewrites

00:23:24,559 --> 00:23:32,720
so it adds an integer to b in line 7

00:23:28,320 --> 00:23:33,120
like this like this and then we focus

00:23:32,720 --> 00:23:36,400
line

00:23:33,120 --> 00:23:37,679
5 and this assigns a string to a

00:23:36,400 --> 00:23:41,760
variable

00:23:37,679 --> 00:23:42,799
b and the next instruction is line 7

00:23:41,760 --> 00:23:45,919
again

00:23:42,799 --> 00:23:50,400
so it adds a string to b

00:23:45,919 --> 00:23:53,440
line 7 like this okay

00:23:50,400 --> 00:23:56,720
finally we are now at line seven

00:23:53,440 --> 00:23:56,960
and this instruction copies uh typo typo

00:23:56,720 --> 00:24:00,400
b

00:23:56,960 --> 00:24:04,159
to c and we can just copy

00:24:00,400 --> 00:24:08,000
this set integer and string and to see

00:24:04,159 --> 00:24:10,640
like this and

00:24:08,000 --> 00:24:11,520
my previous name implementation hundreds

00:24:10,640 --> 00:24:16,640
uh

00:24:11,520 --> 00:24:16,640
oops oops what's happened

00:24:16,840 --> 00:24:23,919
okay my previous

00:24:19,120 --> 00:24:26,159
naive implementation under two states in

00:24:23,919 --> 00:24:27,440
this in this case one is for integer and

00:24:26,159 --> 00:24:31,279
mine's

00:24:27,440 --> 00:24:33,360
string but now we can handle it as a set

00:24:31,279 --> 00:24:35,039
so static explosion prism redux this is

00:24:33,360 --> 00:24:38,240
statementing technique

00:24:35,039 --> 00:24:41,440
and by gathering this information uh

00:24:38,240 --> 00:24:42,240
the profiler can produce a type

00:24:41,440 --> 00:24:45,600
signature

00:24:42,240 --> 00:24:48,159
for type of transmitter okay so

00:24:45,600 --> 00:24:49,200
by this improvement the analysis time is

00:24:48,159 --> 00:24:52,240
really relaxed

00:24:49,200 --> 00:24:53,440
uh reduces uh analyzing itself takes

00:24:52,240 --> 00:24:56,559
just

00:24:53,440 --> 00:24:57,360
2.5 seconds and the analyzing optical

00:24:56,559 --> 00:25:00,720
takes

00:24:57,360 --> 00:25:06,080
six seconds this unit is correct

00:25:00,720 --> 00:25:06,080
not wrong and this is a comparison graph

00:25:06,720 --> 00:25:13,840
okay but type of st has

00:25:10,480 --> 00:25:16,080
some problems why is typofara is

00:25:13,840 --> 00:25:19,440
requires a test trigger

00:25:16,080 --> 00:25:22,880
method definition if there is no test

00:25:19,440 --> 00:25:25,520
the type profiler cannot check no method

00:25:22,880 --> 00:25:27,200
but even we have a great type sequence

00:25:25,520 --> 00:25:29,360
we need to

00:25:27,200 --> 00:25:31,039
we still need to write a test so i think

00:25:29,360 --> 00:25:34,320
this is not so a big problem

00:25:31,039 --> 00:25:36,720
and second is massive type profile may

00:25:34,320 --> 00:25:38,480
cause foresight and long suggestions for

00:25:36,720 --> 00:25:41,600
example uh astronomer b

00:25:38,480 --> 00:25:42,559
is a union of integer string and copies

00:25:41,600 --> 00:25:45,360
it to c

00:25:42,559 --> 00:25:46,799
it loses horizontally it loses the

00:25:45,360 --> 00:25:50,320
correspondence between

00:25:46,799 --> 00:25:55,200
variables b and c so b plus c

00:25:50,320 --> 00:25:59,279
will be fully reduced allotted

00:25:55,200 --> 00:26:02,559
as it may cause uh integer plastering

00:25:59,279 --> 00:26:05,039
and uh the last uh

00:26:02,559 --> 00:26:07,200
type i cannot handle some ruby uh

00:26:05,039 --> 00:26:09,600
features because of abstraction

00:26:07,200 --> 00:26:10,480
and for example two flows object send

00:26:09,600 --> 00:26:12,559
method to call

00:26:10,480 --> 00:26:14,400
we need to add if identified the target

00:26:12,559 --> 00:26:17,520
method name concretely but

00:26:14,400 --> 00:26:21,360
it is obstructed out as uh instance of

00:26:17,520 --> 00:26:24,640
uh string this is goes to

00:26:21,360 --> 00:26:27,039
a singleton class and this framework is

00:26:24,640 --> 00:26:28,799
not solvable in general but if this

00:26:27,039 --> 00:26:32,400
program frequent matters

00:26:28,799 --> 00:26:35,440
in actual example i may consult

00:26:32,400 --> 00:26:37,600
any background in future okay

00:26:35,440 --> 00:26:39,200
and finally i explain the development

00:26:37,600 --> 00:26:41,120
status

00:26:39,200 --> 00:26:43,679
i have designed as the basic algorithm

00:26:41,120 --> 00:26:44,559
to analyze ruby code by using abstract

00:26:43,679 --> 00:26:46,640
interpretation

00:26:44,559 --> 00:26:49,440
currently it supports a very limited set

00:26:46,640 --> 00:26:49,440
of ruby features

00:26:49,919 --> 00:26:55,360
and however there are

00:26:53,039 --> 00:26:56,320
remains many tasks that i need to

00:26:55,360 --> 00:26:58,480
implement

00:26:56,320 --> 00:27:00,240
first i need to support ruby's various

00:26:58,480 --> 00:27:01,600
features including built-in classes

00:27:00,240 --> 00:27:03,840
complex arguments

00:27:01,600 --> 00:27:05,600
like optional rest keywords and

00:27:03,840 --> 00:27:08,960
currently it does not yet support

00:27:05,600 --> 00:27:11,360
exceptional mixing modules

00:27:08,960 --> 00:27:13,200
and there are many other tasks to make

00:27:11,360 --> 00:27:16,240
typo particles so i

00:27:13,200 --> 00:27:19,120
like to continue to development

00:27:16,240 --> 00:27:20,399
okay sorry there is no time so skip

00:27:19,120 --> 00:27:23,600
across it

00:27:20,399 --> 00:27:26,399
sorry okay conclusion

00:27:23,600 --> 00:27:28,399
i explained what's from all the v3 types

00:27:26,399 --> 00:27:31,360
and it consists of three

00:27:28,399 --> 00:27:33,279
key items for the two chain and i

00:27:31,360 --> 00:27:35,919
introduced a profiler

00:27:33,279 --> 00:27:37,360
one type checker checking tool that is

00:27:35,919 --> 00:27:40,799
included in

00:27:37,360 --> 00:27:43,360
and the tool chain except uh emeruv's

00:27:40,799 --> 00:27:44,159
zit compiler type profile is only one

00:27:43,360 --> 00:27:48,000
approach

00:27:44,159 --> 00:27:49,919
applicable to a non-entity to be code

00:27:48,000 --> 00:27:51,919
it is based on abstract interpretation

00:27:49,919 --> 00:27:54,240
technique and i hope it will

00:27:51,919 --> 00:27:55,919
make it possible to analyze ruby code

00:27:54,240 --> 00:27:58,559
with little change of

00:27:55,919 --> 00:27:59,760
louise great programming experience type

00:27:58,559 --> 00:28:02,480
require is open source

00:27:59,760 --> 00:28:05,760
so any comment and are really welcome

00:28:02,480 --> 00:28:05,760
okay that's all thank you

00:28:14,000 --> 00:28:17,360
thank you well thank you very much thank

00:28:16,960 --> 00:28:27,600
you

00:28:17,360 --> 00:28:27,600

YouTube URL: https://www.youtube.com/watch?v=3HB3WGn2LAQ


