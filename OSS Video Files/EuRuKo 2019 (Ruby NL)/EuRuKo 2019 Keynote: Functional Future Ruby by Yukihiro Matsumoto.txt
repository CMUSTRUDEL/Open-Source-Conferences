Title: EuRuKo 2019 Keynote: Functional Future Ruby by Yukihiro Matsumoto
Publication date: 2021-01-11
Playlist: EuRuKo 2019
Description: 
	Keynote: Functional (Future) Ruby

Yukihiro Matsumoto - https://twitter.com/yukihiro_matz
EuRuKo 2019
Captions: 
	00:00:05,680 --> 00:00:10,000
matt's here

00:00:06,480 --> 00:00:12,320
is the creator of ruby uh he has spent

00:00:10,000 --> 00:00:14,160
27 years of his life without ruby and

00:00:12,320 --> 00:00:17,520
now spent 27 years

00:00:14,160 --> 00:00:19,600
with ruby so

00:00:17,520 --> 00:00:22,400
and for those last 27 years he has

00:00:19,600 --> 00:00:25,920
helped promote developer happiness

00:00:22,400 --> 00:00:26,880
and he has been a big proponent yes

00:00:25,920 --> 00:00:30,400
proponent for

00:00:26,880 --> 00:00:31,760
uh this ruby 3x3 performance gain and is

00:00:30,400 --> 00:00:33,040
going to talk to us a little bit about

00:00:31,760 --> 00:00:45,760
the functional future

00:00:33,040 --> 00:00:49,039
of ruby take it away mats

00:00:45,760 --> 00:00:52,079
hmm let me

00:00:49,039 --> 00:00:52,079
what's wrong with it

00:00:52,559 --> 00:00:54,879
okay

00:00:55,840 --> 00:01:00,079
before i prepare a slice i have to tell

00:00:58,480 --> 00:01:02,719
you two things

00:01:00,079 --> 00:01:02,719
the first

00:01:03,600 --> 00:01:08,720
first i'm suffering very bad jet lag

00:01:11,280 --> 00:01:15,119
what what the heck

00:01:18,560 --> 00:01:20,720
no

00:01:24,159 --> 00:01:30,000
what's wrong it worked

00:01:27,360 --> 00:01:30,000
last time

00:01:30,479 --> 00:01:41,840
can i help you no i don't think so it's

00:01:32,960 --> 00:01:41,840
in japanese

00:01:50,960 --> 00:01:56,719
okay i prepared

00:01:54,000 --> 00:01:59,920
uh the second thing is the last night i

00:01:56,719 --> 00:02:03,200
realized the keynote is 30 minutes

00:01:59,920 --> 00:02:06,399
uh i thought it was 40 minutes

00:02:03,200 --> 00:02:09,440
okay uh i'm in the kind of hurry

00:02:06,399 --> 00:02:12,080
the functional uh our future will be

00:02:09,440 --> 00:02:12,720
open sources community can stop you know

00:02:12,080 --> 00:02:17,440
because

00:02:12,720 --> 00:02:20,640
we have to keep moving or we'll die

00:02:17,440 --> 00:02:23,680
so that we have to move on to the future

00:02:20,640 --> 00:02:26,160
so that our future is ruby three uh

00:02:23,680 --> 00:02:28,000
we are currently planning to release

00:02:26,160 --> 00:02:32,480
will be 3.0

00:02:28,000 --> 00:02:34,879
in december next year 2020.

00:02:32,480 --> 00:02:35,760
and so that we are working on it so

00:02:34,879 --> 00:02:39,120
there are

00:02:35,760 --> 00:02:41,519
the we we are trying

00:02:39,120 --> 00:02:43,920
working on the ruby 3 to fill the

00:02:41,519 --> 00:02:46,080
missing piece of the ruby language

00:02:43,920 --> 00:02:48,239
so that for example the performance or

00:02:46,080 --> 00:02:51,280
the addressing multi cores

00:02:48,239 --> 00:02:54,400
or bigger team or projects then

00:02:51,280 --> 00:02:57,120
the future our future

00:02:54,400 --> 00:02:58,480
will be will be three and uh we are

00:02:57,120 --> 00:03:00,239
working on the performance and the

00:02:58,480 --> 00:03:01,440
concurrent new concurrency model and the

00:03:00,239 --> 00:03:04,480
static analysis

00:03:01,440 --> 00:03:06,000
so let me talk uh about the static

00:03:04,480 --> 00:03:08,640
analysis first

00:03:06,000 --> 00:03:09,680
okay the these days the programming

00:03:08,640 --> 00:03:13,040
language of uh

00:03:09,680 --> 00:03:14,879
the static typing in you know pretty pop

00:03:13,040 --> 00:03:16,480
probably popular in programming

00:03:14,879 --> 00:03:19,920
languages like us say

00:03:16,480 --> 00:03:22,239
the recent language for example rust

00:03:19,920 --> 00:03:24,799
or gold or swift or they're all

00:03:22,239 --> 00:03:27,120
statically typed

00:03:24,799 --> 00:03:28,480
as the project grows the test becomes

00:03:27,120 --> 00:03:31,280
burden

00:03:28,480 --> 00:03:32,000
the tests increase its size and test

00:03:31,280 --> 00:03:36,000
execution

00:03:32,000 --> 00:03:39,519
takes more time and then but it

00:03:36,000 --> 00:03:42,560
tests not dry

00:03:39,519 --> 00:03:45,360
you know the dry principle so that

00:03:42,560 --> 00:03:46,400
you know we want to create the software

00:03:45,360 --> 00:03:50,080
that works

00:03:46,400 --> 00:03:53,360
and then test is the another way to

00:03:50,080 --> 00:03:56,400
express the behavior and when

00:03:53,360 --> 00:03:58,560
you know we you know ensure

00:03:56,400 --> 00:03:59,519
the correctness of the software by

00:03:58,560 --> 00:04:04,239
matching

00:03:59,519 --> 00:04:08,640
the different expression of the behavior

00:04:04,239 --> 00:04:11,920
but it's kind of the you know redundant

00:04:08,640 --> 00:04:15,360
the but uh we

00:04:11,920 --> 00:04:18,560
the human beings have not yet

00:04:15,360 --> 00:04:20,160
invented the way to create a correct

00:04:18,560 --> 00:04:23,440
software without tests

00:04:20,160 --> 00:04:27,759
so we write tests anyway but we

00:04:23,440 --> 00:04:30,240
want to be more productive or we can

00:04:27,759 --> 00:04:30,800
can live without you know the test

00:04:30,240 --> 00:04:33,440
burden

00:04:30,800 --> 00:04:34,560
so that we want to reduce the burden of

00:04:33,440 --> 00:04:37,680
test writing

00:04:34,560 --> 00:04:38,000
so that the other line is try like a you

00:04:37,680 --> 00:04:41,040
know

00:04:38,000 --> 00:04:43,280
php goes to the type hinting the the

00:04:41,040 --> 00:04:44,800
type python 3 goes to type annotations

00:04:43,280 --> 00:04:47,440
and the javascript

00:04:44,800 --> 00:04:48,960
comes with the typescript so that you

00:04:47,440 --> 00:04:51,600
know

00:04:48,960 --> 00:04:54,000
that more language like a scripting

00:04:51,600 --> 00:04:54,000
language

00:04:55,040 --> 00:05:02,080
uh going to the static typing

00:04:58,320 --> 00:05:05,680
or gradual statical topic and then

00:05:02,080 --> 00:05:07,440
what should we do the ruby community do

00:05:05,680 --> 00:05:09,280
they are adding type annotations like

00:05:07,440 --> 00:05:14,400
the others

00:05:09,280 --> 00:05:17,440
like php or python i don't think so

00:05:14,400 --> 00:05:17,440
i hate typing position

00:05:18,960 --> 00:05:24,400
because it's not dry

00:05:22,000 --> 00:05:25,600
we want other thai painting uh in the

00:05:24,400 --> 00:05:29,120
language

00:05:25,600 --> 00:05:29,840
because it's not needed the the platform

00:05:29,120 --> 00:05:32,720
obviously

00:05:29,840 --> 00:05:33,840
statically analysis of code the static

00:05:32,720 --> 00:05:38,000
type checking

00:05:33,840 --> 00:05:40,479
uh the rules three comes with the

00:05:38,000 --> 00:05:41,199
static type checking components like

00:05:40,479 --> 00:05:43,600
this

00:05:41,199 --> 00:05:44,560
the the first one is the type definition

00:05:43,600 --> 00:05:47,759
syntax

00:05:44,560 --> 00:05:50,080
then you know separate files the type

00:05:47,759 --> 00:05:51,440
the type definition for libraries and

00:05:50,080 --> 00:05:54,880
the type profiler

00:05:51,440 --> 00:05:58,240
then static type checkers ah

00:05:54,880 --> 00:06:01,520
type definition syntax uh the

00:05:58,240 --> 00:06:04,240
a guy named soto matsumoto yeah he's not

00:06:01,520 --> 00:06:06,639
my relative

00:06:04,240 --> 00:06:07,280
but he's a smart guy and uh he wrote his

00:06:06,639 --> 00:06:11,120
php

00:06:07,280 --> 00:06:11,600
uh psd paper on on sonic type checking

00:06:11,120 --> 00:06:14,800
in

00:06:11,600 --> 00:06:18,400
ruby language and he

00:06:14,800 --> 00:06:22,000
abandoned the idea once but

00:06:18,400 --> 00:06:25,120
this uh this is his third try and then

00:06:22,000 --> 00:06:27,840
okay separated files to describe

00:06:25,120 --> 00:06:29,360
types argument types return value types

00:06:27,840 --> 00:06:32,479
class modules

00:06:29,360 --> 00:06:35,520
with their generic type and interface

00:06:32,479 --> 00:06:36,160
like this oh this is kind of like a ruby

00:06:35,520 --> 00:06:38,880
but a

00:06:36,160 --> 00:06:39,360
different syntax because of the types

00:06:38,880 --> 00:06:41,919
and

00:06:39,360 --> 00:06:42,560
we are not going to change the ruby

00:06:41,919 --> 00:06:45,199
language

00:06:42,560 --> 00:06:48,880
but we are going to add this kind of the

00:06:45,199 --> 00:06:51,360
type description file for libraries or

00:06:48,880 --> 00:06:52,000
including studying uh standard libraries

00:06:51,360 --> 00:06:55,440
and uh

00:06:52,000 --> 00:06:58,080
you know and gems

00:06:55,440 --> 00:06:58,639
and then we are going to uh provide a

00:06:58,080 --> 00:07:02,319
tool

00:06:58,639 --> 00:07:05,919
to pro plus this rbi file okay

00:07:02,319 --> 00:07:10,000
we you can see that you can see this

00:07:05,919 --> 00:07:13,199
uh that tool prototype of.2 in

00:07:10,000 --> 00:07:16,319
this url this github repository

00:07:13,199 --> 00:07:18,479
then the we are going to provide the

00:07:16,319 --> 00:07:20,880
type definitions for the libraries

00:07:18,479 --> 00:07:21,599
that are standard libraries and gems and

00:07:20,880 --> 00:07:24,880
then

00:07:21,599 --> 00:07:28,080
we are not decided how to

00:07:24,880 --> 00:07:29,759
bundle this type annotation file to the

00:07:28,080 --> 00:07:33,360
gem file but uh we are

00:07:29,759 --> 00:07:36,240
we are working with the rubygem team

00:07:33,360 --> 00:07:37,759
then the next component is the type

00:07:36,240 --> 00:07:40,880
profiler

00:07:37,759 --> 00:07:43,280
the use that you scandal

00:07:40,880 --> 00:07:44,720
is working on this type profiler he's

00:07:43,280 --> 00:07:47,759
there

00:07:44,720 --> 00:07:49,360
and then the the type profile is the key

00:07:47,759 --> 00:07:50,479
component of the static analysis of the

00:07:49,360 --> 00:07:53,680
ruby language

00:07:50,479 --> 00:07:54,080
version three and then it's comes with

00:07:53,680 --> 00:07:56,840
the

00:07:54,080 --> 00:07:58,080
abstract interpretation it's which is

00:07:56,840 --> 00:08:01,120
virtually

00:07:58,080 --> 00:08:04,400
uh execute the

00:08:01,120 --> 00:08:07,280
your program your application in the

00:08:04,400 --> 00:08:09,919
abstract way with the type information

00:08:07,280 --> 00:08:10,879
like for example that you this is very

00:08:09,919 --> 00:08:15,199
small ruby

00:08:10,879 --> 00:08:18,400
uh program and then okay

00:08:15,199 --> 00:08:20,879
you see the the the method foo is

00:08:18,400 --> 00:08:22,160
called with the argument 15 which is the

00:08:20,879 --> 00:08:25,199
integer

00:08:22,160 --> 00:08:28,400
the that means the foo is called

00:08:25,199 --> 00:08:31,039
with the integer and the integer

00:08:28,400 --> 00:08:33,360
has the plus method with the integer

00:08:31,039 --> 00:08:36,399
argument so that this is okay

00:08:33,360 --> 00:08:39,599
but uh if you uh if you try to add

00:08:36,399 --> 00:08:43,440
strings to a which is

00:08:39,599 --> 00:08:46,320
type uh wrong you can tell by the

00:08:43,440 --> 00:08:47,279
the information from the start uh type

00:08:46,320 --> 00:08:49,760
type annotation

00:08:47,279 --> 00:08:50,800
files from the standard library so that

00:08:49,760 --> 00:08:53,360
you can you can

00:08:50,800 --> 00:08:54,480
have the error this is very simple in

00:08:53,360 --> 00:08:56,320
interesting

00:08:54,480 --> 00:08:57,680
so the type profiler works as a

00:08:56,320 --> 00:09:00,560
collecting type

00:08:57,680 --> 00:09:01,680
information of you of your application

00:09:00,560 --> 00:09:05,040
and then

00:09:01,680 --> 00:09:07,600
detect type conflict of the existing

00:09:05,040 --> 00:09:09,040
type information of the standard library

00:09:07,600 --> 00:09:12,240
and gems

00:09:09,040 --> 00:09:15,600
then the then

00:09:12,240 --> 00:09:19,200
if the type checker works so that

00:09:15,600 --> 00:09:22,399
you can generate the rbi

00:09:19,200 --> 00:09:22,959
file for your application so the next

00:09:22,399 --> 00:09:25,440
time

00:09:22,959 --> 00:09:26,560
so that you can use the rbi file to

00:09:25,440 --> 00:09:30,080
check your

00:09:26,560 --> 00:09:32,160
uh your application so the type profile

00:09:30,080 --> 00:09:35,360
that works as a level one type checker

00:09:32,160 --> 00:09:38,320
and the rbi generator

00:09:35,360 --> 00:09:40,800
and then but uh unfortunately type

00:09:38,320 --> 00:09:41,680
profiler our type profile is not yet

00:09:40,800 --> 00:09:44,320
that smart

00:09:41,680 --> 00:09:44,959
so that you cannot detect the say the

00:09:44,320 --> 00:09:48,320
generic

00:09:44,959 --> 00:09:51,120
types or maybe some kind of

00:09:48,320 --> 00:09:53,279
you know parameterized type or maybe

00:09:51,120 --> 00:09:55,920
it's hard to distinguish the turpo

00:09:53,279 --> 00:09:56,399
which is the uniformed class array and

00:09:55,920 --> 00:09:59,680
then

00:09:56,399 --> 00:10:02,240
and then i mean the

00:09:59,680 --> 00:10:03,040
uniform class re and turbo which is the

00:10:02,240 --> 00:10:06,399
you know the

00:10:03,040 --> 00:10:10,480
the classes of the elements differs

00:10:06,399 --> 00:10:12,480
uh for each elements

00:10:10,480 --> 00:10:14,800
in that case you can refine the

00:10:12,480 --> 00:10:18,000
generated i'll be a file so that you

00:10:14,800 --> 00:10:20,240
uh your knowledge your knowledge

00:10:18,000 --> 00:10:22,000
for application is required to refine

00:10:20,240 --> 00:10:26,399
that so that you can refine

00:10:22,000 --> 00:10:29,680
by hand uh that generated rbi file

00:10:26,399 --> 00:10:33,600
that your audio file is you know

00:10:29,680 --> 00:10:37,120
read before the generated worm so the

00:10:33,600 --> 00:10:38,079
we may also provide the uh yeah to

00:10:37,120 --> 00:10:40,720
obvious

00:10:38,079 --> 00:10:42,399
file generator so that you can use the

00:10:40,720 --> 00:10:45,440
the type information from your

00:10:42,399 --> 00:10:46,959
your document but uh this is only a plan

00:10:45,440 --> 00:10:50,880
so that we are not

00:10:46,959 --> 00:10:53,920
uh we are not working on it yet

00:10:50,880 --> 00:10:55,680
well then the level two static type

00:10:53,920 --> 00:10:58,800
checkers so that we

00:10:55,680 --> 00:11:01,760
currently we have the two actually

00:10:58,800 --> 00:11:02,800
including the the original ldl so that

00:11:01,760 --> 00:11:05,600
we have three

00:11:02,800 --> 00:11:06,320
uh type checkers the the first one is

00:11:05,600 --> 00:11:08,959
solved

00:11:06,320 --> 00:11:09,600
from the stripe which which is the you

00:11:08,959 --> 00:11:12,560
know

00:11:09,600 --> 00:11:14,240
the sponsor of this conference and then

00:11:12,560 --> 00:11:17,279
the survey is

00:11:14,240 --> 00:11:19,600
recently uh open source that yesterday

00:11:17,279 --> 00:11:20,480
i'm not sure yesterday yeah yesterday

00:11:19,600 --> 00:11:23,279
open source

00:11:20,480 --> 00:11:24,480
the currently solved requires some kind

00:11:23,279 --> 00:11:28,000
of the dsl

00:11:24,480 --> 00:11:32,560
to annotate your code but uh

00:11:28,000 --> 00:11:35,839
in the future the soviets.read.lbi file

00:11:32,560 --> 00:11:39,120
which i explained the steep is

00:11:35,839 --> 00:11:42,000
uh from the sothoromas model who is

00:11:39,120 --> 00:11:45,920
working on the rbi5

00:11:42,000 --> 00:11:48,160
and then okay those static type checker

00:11:45,920 --> 00:11:50,320
basically use a phantom uh theoretically

00:11:48,160 --> 00:11:54,000
use the audio type definitions

00:11:50,320 --> 00:11:58,079
then they have different characteristics

00:11:54,000 --> 00:12:01,120
the soviet uh you can see them from the

00:11:58,079 --> 00:12:03,600
github uh it is correct url

00:12:01,120 --> 00:12:04,240
i'm not sure and you you can google

00:12:03,600 --> 00:12:06,959
solve it

00:12:04,240 --> 00:12:08,480
from stripe okay the the soviet type

00:12:06,959 --> 00:12:11,120
checker is pretty fast

00:12:08,480 --> 00:12:12,639
it's totally written in c plus plus and

00:12:11,120 --> 00:12:15,680
even in the ruby process

00:12:12,639 --> 00:12:18,000
is written in c plus plus and then the

00:12:15,680 --> 00:12:19,519
type system is mostly nominal and the

00:12:18,000 --> 00:12:24,240
supposed type annotations

00:12:19,519 --> 00:12:27,360
uh the type of notation dsl and then i

00:12:24,240 --> 00:12:27,839
we are working together the the core

00:12:27,360 --> 00:12:29,519
team

00:12:27,839 --> 00:12:30,880
and then the sorbet team is working

00:12:29,519 --> 00:12:33,920
together so the

00:12:30,880 --> 00:12:37,120
the we are working on the rbi support uh

00:12:33,920 --> 00:12:40,399
force orbit a steep

00:12:37,120 --> 00:12:43,600
is uh from this this url

00:12:40,399 --> 00:12:45,600
and then it's written in ruby in a

00:12:43,600 --> 00:12:47,920
they're based on the structure typing

00:12:45,600 --> 00:12:51,040
and since it's written in ruby

00:12:47,920 --> 00:12:54,079
you uh you can play with some kind of

00:12:51,040 --> 00:12:56,639
the type checking systems and it's more

00:12:54,079 --> 00:12:59,920
flexible

00:12:56,639 --> 00:13:03,120
uh i expect that those two

00:12:59,920 --> 00:13:06,720
uh can have the healthy

00:13:03,120 --> 00:13:10,000
competition so that those teams will uh

00:13:06,720 --> 00:13:12,959
have meetings together

00:13:10,000 --> 00:13:13,600
so that what will happen with those uh

00:13:12,959 --> 00:13:16,560
that

00:13:13,600 --> 00:13:16,880
static type analysis uh components so

00:13:16,560 --> 00:13:18,720
that

00:13:16,880 --> 00:13:20,240
your ordinary programs will be

00:13:18,720 --> 00:13:22,959
statically type checked

00:13:20,240 --> 00:13:25,279
and without any type annotation in your

00:13:22,959 --> 00:13:25,760
ruby program so that your existing ruby

00:13:25,279 --> 00:13:27,920
program

00:13:25,760 --> 00:13:28,880
works as it is you don't have to write

00:13:27,920 --> 00:13:30,639
add

00:13:28,880 --> 00:13:31,920
any type the correlation to your

00:13:30,639 --> 00:13:34,320
application

00:13:31,920 --> 00:13:36,480
and then if you refine type definition

00:13:34,320 --> 00:13:39,760
files you will have the better checking

00:13:36,480 --> 00:13:42,720
so that you more precise checking and uh

00:13:39,760 --> 00:13:42,720
wouldn't that be cool

00:13:43,279 --> 00:13:48,959
no you know the i believe adding type

00:13:46,839 --> 00:13:50,399
annotations type the correlation to the

00:13:48,959 --> 00:13:53,920
language will hinder

00:13:50,399 --> 00:13:57,600
or change the characteristics of ruby

00:13:53,920 --> 00:14:00,839
language and uh actually i love

00:13:57,600 --> 00:14:04,480
and i probably really love the current

00:14:00,839 --> 00:14:06,959
characteristic current current language

00:14:04,480 --> 00:14:09,120
so that we don't want to change the

00:14:06,959 --> 00:14:12,160
nature of the language so that we

00:14:09,120 --> 00:14:14,320
want uh change the language

00:14:12,160 --> 00:14:15,600
instead we are going to add these

00:14:14,320 --> 00:14:19,120
components to

00:14:15,600 --> 00:14:22,240
to you know for better checking

00:14:19,120 --> 00:14:25,360
in compile time so we are working on it

00:14:22,240 --> 00:14:26,959
and uh and i think result is uh

00:14:25,360 --> 00:14:29,519
promising

00:14:26,959 --> 00:14:30,320
so the yeah this is the static analysis

00:14:29,519 --> 00:14:32,959
so the

00:14:30,320 --> 00:14:35,120
performance improvement so the no

00:14:32,959 --> 00:14:37,199
language can be fast enough so the

00:14:35,120 --> 00:14:38,480
me uh people complain about the

00:14:37,199 --> 00:14:41,519
performance of the

00:14:38,480 --> 00:14:43,199
you know in every language like a java

00:14:41,519 --> 00:14:44,480
some people complain about the java

00:14:43,199 --> 00:14:45,920
performance and there will be

00:14:44,480 --> 00:14:49,360
performance of course

00:14:45,920 --> 00:14:52,000
python php go rust whatever

00:14:49,360 --> 00:14:54,000
so that every language yeah can be a

00:14:52,000 --> 00:14:56,079
complaint about the performance

00:14:54,000 --> 00:14:57,360
so the and then we are working on

00:14:56,079 --> 00:15:00,480
improving performance in

00:14:57,360 --> 00:15:02,800
since ruby 2 has released but uh

00:15:00,480 --> 00:15:03,519
you know the performance will be again

00:15:02,800 --> 00:15:06,000
slightly

00:15:03,519 --> 00:15:07,519
improved in the past compared to the

00:15:06,000 --> 00:15:10,880
ruby two three four

00:15:07,519 --> 00:15:14,720
the ruby two eight uh two six zero

00:15:10,880 --> 00:15:16,800
runs i don't know some some percent

00:15:14,720 --> 00:15:18,720
processor

00:15:16,800 --> 00:15:20,800
and then yeah okay that hundred is a

00:15:18,720 --> 00:15:23,600
ruby tool

00:15:20,800 --> 00:15:26,040
okay compared to the you know 100 ruby

00:15:23,600 --> 00:15:29,759
260 runs

00:15:26,040 --> 00:15:30,639
1.8 almost yeah close to 1.8 times

00:15:29,759 --> 00:15:33,440
faster

00:15:30,639 --> 00:15:35,920
yeah that's good but we are trying to

00:15:33,440 --> 00:15:38,639
make it even faster

00:15:35,920 --> 00:15:39,360
so we need more performance more traffic

00:15:38,639 --> 00:15:41,600
we can

00:15:39,360 --> 00:15:43,040
we have to handle more traffic in the

00:15:41,600 --> 00:15:46,079
web applications

00:15:43,040 --> 00:15:48,399
so the memory is the first bottleneck of

00:15:46,079 --> 00:15:50,880
the web application

00:15:48,399 --> 00:15:52,399
in fact so that we have been uh we have

00:15:50,880 --> 00:15:54,880
improved uh

00:15:52,399 --> 00:15:56,160
gc performance and then for example we

00:15:54,880 --> 00:15:58,480
introduced a

00:15:56,160 --> 00:16:00,560
generational garbage collector in 2.21

00:15:58,480 --> 00:16:03,759
then incremental garbage collector in 2

00:16:00,560 --> 00:16:05,199
2 and transient heap into 6 and then we

00:16:03,759 --> 00:16:08,240
are going to add the

00:16:05,199 --> 00:16:09,600
object compaction which is our own

00:16:08,240 --> 00:16:12,880
patterson is working on

00:16:09,600 --> 00:16:16,320
is we are going to release it and uh

00:16:12,880 --> 00:16:19,440
introduce it into seven if

00:16:16,320 --> 00:16:21,600
everything goes well uh yeah and the

00:16:19,440 --> 00:16:22,880
other bottlenecks are the cpu and then i

00:16:21,600 --> 00:16:25,600
io

00:16:22,880 --> 00:16:27,519
so the result to resolve cpu bottleneck

00:16:25,600 --> 00:16:30,720
we are working on jet compiler

00:16:27,519 --> 00:16:33,680
just in time compiler uh the

00:16:30,720 --> 00:16:35,759
called mg mg it has introduced in and

00:16:33,680 --> 00:16:39,279
ruby 26 so that

00:16:35,759 --> 00:16:42,560
if you are using ruby two six uh two six

00:16:39,279 --> 00:16:45,519
don't just add the data jet uh

00:16:42,560 --> 00:16:48,240
i mean the dash dash jet so then you can

00:16:45,519 --> 00:16:51,199
have the jit compiler

00:16:48,240 --> 00:16:52,800
the for cpu intensive task uh for

00:16:51,199 --> 00:16:55,440
example that our

00:16:52,800 --> 00:16:56,240
uh the cpu intensive uh benchmark optic

00:16:55,440 --> 00:16:59,920
camera

00:16:56,240 --> 00:17:03,279
uh runs to uh runs 2.8 times faster

00:16:59,920 --> 00:17:05,760
which is kind yeah which is great

00:17:03,279 --> 00:17:06,959
uh compared to the ruby two oh well yeah

00:17:05,760 --> 00:17:10,480
it's almost close to

00:17:06,959 --> 00:17:13,600
three uh three times faster but uh

00:17:10,480 --> 00:17:13,600
for rails up

00:17:13,760 --> 00:17:16,720
mg runs slower

00:17:17,280 --> 00:17:22,720
because uh the most of the cases uh

00:17:20,880 --> 00:17:24,160
cpu is not a bottleneck for web

00:17:22,720 --> 00:17:27,439
applications and then

00:17:24,160 --> 00:17:30,080
memory models comes first and then

00:17:27,439 --> 00:17:32,240
we the in rails rails is huge

00:17:30,080 --> 00:17:34,720
application framework so that we

00:17:32,240 --> 00:17:35,760
we have too many methods and then the

00:17:34,720 --> 00:17:38,799
applications

00:17:35,760 --> 00:17:39,440
uh most of the cases are the web

00:17:38,799 --> 00:17:42,880
applications

00:17:39,440 --> 00:17:46,080
are intensive so the we're working

00:17:42,880 --> 00:17:51,120
on the lighter compilation uh

00:17:46,080 --> 00:17:54,320
jet the vlad vladimir makalov

00:17:51,120 --> 00:17:56,160
who originally created the mj so they're

00:17:54,320 --> 00:17:58,840
also working on the something named the

00:17:56,160 --> 00:18:01,200
mail so

00:17:58,840 --> 00:18:03,840
uh know that

00:18:01,200 --> 00:18:06,720
i don't remember the acronyms but i mean

00:18:03,840 --> 00:18:06,720
something called meal

00:18:06,960 --> 00:18:14,160
which is a lightweight jit compiler

00:18:10,000 --> 00:18:17,360
so that you know the mg compiles

00:18:14,160 --> 00:18:18,240
mj generates the c programs from the

00:18:17,360 --> 00:18:22,080
ruby code

00:18:18,240 --> 00:18:25,200
then compile those c files by the

00:18:22,080 --> 00:18:27,600
gcc or clone then

00:18:25,200 --> 00:18:28,799
dynamically load into the into the

00:18:27,600 --> 00:18:31,919
applications

00:18:28,799 --> 00:18:35,039
that is a heavy process and then

00:18:31,919 --> 00:18:36,080
but with that meal so that you can

00:18:35,039 --> 00:18:39,120
generate

00:18:36,080 --> 00:18:41,600
the unoptimized native code into the

00:18:39,120 --> 00:18:42,480
into the memory without invoking any

00:18:41,600 --> 00:18:44,799
compiler

00:18:42,480 --> 00:18:46,320
so that that this kind of the internal

00:18:44,799 --> 00:18:50,160
jet compiler runs

00:18:46,320 --> 00:18:53,360
uh runs much much lighter and faster

00:18:50,160 --> 00:18:55,440
the compilation time is faster so the

00:18:53,360 --> 00:18:56,400
we are going to have the lighter

00:18:55,440 --> 00:19:00,400
completion

00:18:56,400 --> 00:19:02,000
of and then we probably we are going to

00:19:00,400 --> 00:19:05,120
have the three tires

00:19:02,000 --> 00:19:09,039
i mean the run some methods running

00:19:05,120 --> 00:19:12,400
in vm right then

00:19:09,039 --> 00:19:14,480
some method some hot messes are compiled

00:19:12,400 --> 00:19:17,679
by the lightweight jet

00:19:14,480 --> 00:19:20,000
and then very uh

00:19:17,679 --> 00:19:21,440
you know heavy cpu intensive methods

00:19:20,000 --> 00:19:24,080
will be compiled by the

00:19:21,440 --> 00:19:24,960
optimized mg so that those kind of the

00:19:24,080 --> 00:19:27,919
three tie

00:19:24,960 --> 00:19:28,400
uh jet will coming to the ruby three i

00:19:27,919 --> 00:19:31,919
don't think

00:19:28,400 --> 00:19:35,520
it will come into v3o but uh the later

00:19:31,919 --> 00:19:39,520
in this ruby three okay v vm

00:19:35,520 --> 00:19:41,200
male mj it may not be useful for web

00:19:39,520 --> 00:19:43,520
applications but uh

00:19:41,200 --> 00:19:44,320
you know the ruby is used in many cases

00:19:43,520 --> 00:19:46,960
like some

00:19:44,320 --> 00:19:48,240
you know the bus project or some kind of

00:19:46,960 --> 00:19:50,559
the

00:19:48,240 --> 00:19:51,600
entertainment system so that some in

00:19:50,559 --> 00:19:56,000
some cases

00:19:51,600 --> 00:19:57,919
it works pretty well uh maybe jit may be

00:19:56,000 --> 00:19:59,280
uh would be useful for research

00:19:57,919 --> 00:20:02,400
computing like a you know

00:19:59,280 --> 00:20:02,880
the faster you know number crunching so

00:20:02,400 --> 00:20:05,520
that

00:20:02,880 --> 00:20:06,240
you know in those areas the python is

00:20:05,520 --> 00:20:09,360
stronger

00:20:06,240 --> 00:20:12,799
and the julia is coming but uh but

00:20:09,360 --> 00:20:12,799
with the jet compiler

00:20:13,039 --> 00:20:18,400
i hope ruby will be competitive okay

00:20:16,559 --> 00:20:19,600
the other way to improve the performance

00:20:18,400 --> 00:20:22,799
is the concurrency

00:20:19,600 --> 00:20:24,080
the concurs is hard i regret that

00:20:22,799 --> 00:20:27,360
instead

00:20:24,080 --> 00:20:30,880
in the past remember back in

00:20:27,360 --> 00:20:34,480
90s when i created ruby

00:20:30,880 --> 00:20:36,240
usually the computer has one cpu

00:20:34,480 --> 00:20:38,559
so we don't have to care about the

00:20:36,240 --> 00:20:41,760
multi-cores in in those days

00:20:38,559 --> 00:20:44,480
so that yeah i like knowledge and

00:20:41,760 --> 00:20:46,480
imagination about the threats you know

00:20:44,480 --> 00:20:50,080
in the real world

00:20:46,480 --> 00:20:53,440
that you know we have so multi-core

00:20:50,080 --> 00:20:56,720
in our laptops or you know

00:20:53,440 --> 00:20:57,600
virtually every computer has many many

00:20:56,720 --> 00:21:01,520
cores

00:20:57,600 --> 00:21:04,559
right now so that uh you know

00:21:01,520 --> 00:21:08,080
it in the under such

00:21:04,559 --> 00:21:08,880
situations so the the the threads are

00:21:08,080 --> 00:21:11,679
hard to

00:21:08,880 --> 00:21:13,679
use correctly and how to use efficiently

00:21:11,679 --> 00:21:15,360
and how to debug

00:21:13,679 --> 00:21:18,559
so that we need better abstraction of

00:21:15,360 --> 00:21:22,559
concurrency so the

00:21:18,559 --> 00:21:24,559
uh so we need better abstraction so we

00:21:22,559 --> 00:21:26,240
uh we are going to add the new

00:21:24,559 --> 00:21:30,720
concurrency model which is

00:21:26,240 --> 00:21:34,000
we call it call them gills or isolates

00:21:30,720 --> 00:21:38,400
or an old fiber or async

00:21:34,000 --> 00:21:41,039
whatever uh the gears for

00:21:38,400 --> 00:21:42,720
users provided for the cpu to resolve

00:21:41,039 --> 00:21:45,520
the cpu bottlenecks

00:21:42,720 --> 00:21:48,080
uh the all five of to resolve the cpu

00:21:45,520 --> 00:21:50,640
about io modeling

00:21:48,080 --> 00:21:53,520
they are easy to use easy to debug and

00:21:50,640 --> 00:21:53,520
easy to perform

00:21:53,679 --> 00:21:58,000
yeah go or alexa use a single entity

00:21:56,320 --> 00:22:00,799
like our you know good routine

00:21:58,000 --> 00:22:02,159
and goal or process in elixir and

00:22:00,799 --> 00:22:05,440
ireland

00:22:02,159 --> 00:22:09,679
but uh we need oh

00:22:05,440 --> 00:22:12,880
i'm sorry but uh you know we have

00:22:09,679 --> 00:22:16,320
you know tons of history and

00:22:12,880 --> 00:22:19,440
unlike elixir we we cannot

00:22:16,320 --> 00:22:22,720
make every object immutable

00:22:19,440 --> 00:22:26,080
you know okay from from now on

00:22:22,720 --> 00:22:29,520
all ruby objects are immutable

00:22:26,080 --> 00:22:32,720
all your web application will crash

00:22:29,520 --> 00:22:35,919
so we don't want that so that or

00:22:32,720 --> 00:22:37,600
you know we re-implement it we cannot

00:22:35,919 --> 00:22:41,360
re-implement everything like

00:22:37,600 --> 00:22:43,760
you know we implement we implement ruby

00:22:41,360 --> 00:22:45,200
virtual machine from top to bottom in

00:22:43,760 --> 00:22:49,440
say ruby

00:22:45,200 --> 00:22:50,960
that's not realistic so that uh so that

00:22:49,440 --> 00:22:53,039
you know some kind of the real world

00:22:50,960 --> 00:22:54,960
compromise we have to add the two

00:22:53,039 --> 00:22:58,320
entities instead of one

00:22:54,960 --> 00:23:00,320
then but uh i'm not satisfied we are not

00:22:58,320 --> 00:23:02,400
satisfied with those those names

00:23:00,320 --> 00:23:04,640
gills and art fibers so that we need

00:23:02,400 --> 00:23:08,640
better names so that

00:23:04,640 --> 00:23:09,200
maybe ice race isolate is the better

00:23:08,640 --> 00:23:11,919
name

00:23:09,200 --> 00:23:12,559
and uh yeah but uh koichi who is working

00:23:11,919 --> 00:23:16,159
on girls

00:23:12,559 --> 00:23:19,520
is not really like the name uh

00:23:16,159 --> 00:23:19,520
the old fibers

00:23:20,320 --> 00:23:27,200
or fibers old fiber is the fiber

00:23:23,679 --> 00:23:28,880
uh or routine which uh context switches

00:23:27,200 --> 00:23:30,320
on the io operation blocking eye

00:23:28,880 --> 00:23:32,799
operation so that

00:23:30,320 --> 00:23:33,440
by using those things instead of uh

00:23:32,799 --> 00:23:36,159
threads

00:23:33,440 --> 00:23:37,280
the the context which will be will be

00:23:36,159 --> 00:23:40,320
more

00:23:37,280 --> 00:23:41,440
far more right lightweight but uh you

00:23:40,320 --> 00:23:44,559
know the five

00:23:41,440 --> 00:23:47,039
the name fiber uh

00:23:44,559 --> 00:23:47,679
strongly indicates the you know cool

00:23:47,039 --> 00:23:50,080
routine

00:23:47,679 --> 00:23:51,200
which is which is the context switch in

00:23:50,080 --> 00:23:54,720
in in

00:23:51,200 --> 00:23:58,720
implicit explicit way so that you know

00:23:54,720 --> 00:24:01,840
probably we might need better name

00:23:58,720 --> 00:24:01,840
okay your opinion somewhere

00:24:02,840 --> 00:24:09,679
well so the

00:24:06,960 --> 00:24:11,360
improvement uh inspired those inspire

00:24:09,679 --> 00:24:13,279
improvements are inspired by functional

00:24:11,360 --> 00:24:16,159
programming languages because

00:24:13,279 --> 00:24:16,880
so the at the time i create designed

00:24:16,159 --> 00:24:20,240
ruby

00:24:16,880 --> 00:24:22,240
in 90s so the i don't know very little

00:24:20,240 --> 00:24:24,240
about functional programming so that

00:24:22,240 --> 00:24:25,679
so since they are different functional

00:24:24,240 --> 00:24:27,200
programming languages different from

00:24:25,679 --> 00:24:30,400
ruby so that

00:24:27,200 --> 00:24:33,520
they are the source of the

00:24:30,400 --> 00:24:34,159
inspiration of the future will be static

00:24:33,520 --> 00:24:37,760
typing

00:24:34,159 --> 00:24:40,320
is the crucial part of the many uh

00:24:37,760 --> 00:24:41,440
uh functional programming language and a

00:24:40,320 --> 00:24:44,840
concurrency mode

00:24:41,440 --> 00:24:47,840
is is part of the you know

00:24:44,840 --> 00:24:51,600
the part of the core

00:24:47,840 --> 00:24:54,320
of the island and elixir and even more

00:24:51,600 --> 00:24:57,120
for example we are working on the

00:24:54,320 --> 00:25:01,840
numbered block parameters

00:24:57,120 --> 00:25:01,840
from scala closure and groovy like a yes

00:25:02,320 --> 00:25:05,520
actually i'm not fully satisfied with

00:25:04,400 --> 00:25:08,240
the disagree

00:25:05,520 --> 00:25:08,240
art science

00:25:11,200 --> 00:25:16,640
uh you know but uh

00:25:14,480 --> 00:25:19,360
2-7 is coming in december so that we

00:25:16,640 --> 00:25:22,400
have a few more months

00:25:19,360 --> 00:25:25,279
so yeah we have to discuss and

00:25:22,400 --> 00:25:25,840
that try out other ideas like uh other

00:25:25,279 --> 00:25:29,039
options

00:25:25,840 --> 00:25:32,840
you can be at

00:25:29,039 --> 00:25:35,840
or it or

00:25:32,840 --> 00:25:37,440
square or something

00:25:35,840 --> 00:25:39,120
yeah it comes from the grooving and

00:25:37,440 --> 00:25:41,440
cockling and then

00:25:39,120 --> 00:25:43,120
yeah this rocket is used by scheme

00:25:41,440 --> 00:25:46,480
language

00:25:43,120 --> 00:25:49,440
maybe the other thing is better

00:25:46,480 --> 00:25:50,559
yeah we're working on it pattern

00:25:49,440 --> 00:25:52,960
matching

00:25:50,559 --> 00:25:54,559
not regular expression but a functional

00:25:52,960 --> 00:25:56,480
programming pattern matching

00:25:54,559 --> 00:25:57,840
so this is some kind of the json

00:25:56,480 --> 00:26:01,600
matching uh example

00:25:57,840 --> 00:26:04,880
the uh read json file and uh

00:26:01,600 --> 00:26:08,159
if the json data

00:26:04,880 --> 00:26:12,400
matches the name which name is alice

00:26:08,159 --> 00:26:16,000
and uh who has the uh children named bob

00:26:12,400 --> 00:26:19,760
and then uh retrieve the age

00:26:16,000 --> 00:26:22,840
the the age of the alice's son

00:26:19,760 --> 00:26:25,840
bob should be printed

00:26:22,840 --> 00:26:29,360
or yeah no

00:26:25,840 --> 00:26:34,159
there's no alice this is this is

00:26:29,360 --> 00:26:35,840
quite straightforward and then

00:26:34,159 --> 00:26:38,960
otherwise you have to write down that

00:26:35,840 --> 00:26:39,760
okay person name should be alice and the

00:26:38,960 --> 00:26:43,279
children

00:26:39,760 --> 00:26:46,640
should be uh children's name is one

00:26:43,279 --> 00:26:48,960
then the first children's name is bob or

00:26:46,640 --> 00:26:51,919
something

00:26:48,960 --> 00:26:53,279
or something like that compared to these

00:26:51,919 --> 00:26:54,799
things

00:26:53,279 --> 00:26:57,039
yeah the pattern matching is pretty

00:26:54,799 --> 00:26:59,039
straightforward so the

00:26:57,039 --> 00:27:00,400
yeah it's already merged into seven in

00:26:59,039 --> 00:27:06,480
the trunk so that

00:27:00,400 --> 00:27:09,840
yeah you can try out oops

00:27:06,480 --> 00:27:12,080
chaining or pipeline operator okay five

00:27:09,840 --> 00:27:14,480
minutes

00:27:12,080 --> 00:27:15,840
ah flow maps have an elixir okay like

00:27:14,480 --> 00:27:20,640
this

00:27:15,840 --> 00:27:23,440
hmm controversial

00:27:20,640 --> 00:27:23,440
instead of this

00:27:24,799 --> 00:27:28,880
uh the piper okay well we have five more

00:27:27,600 --> 00:27:31,919
minutes so we have to

00:27:28,880 --> 00:27:34,880
skip something uh the pipeline operator

00:27:31,919 --> 00:27:35,760
is in f sharp is defined like this let's

00:27:34,880 --> 00:27:38,960
something something

00:27:35,760 --> 00:27:42,159
in the user level operator and then it

00:27:38,960 --> 00:27:42,720
as the primary argument which is that so

00:27:42,159 --> 00:27:46,000
for

00:27:42,720 --> 00:27:48,320
for example in the map function the the

00:27:46,000 --> 00:27:49,840
array which is the primary argument

00:27:48,320 --> 00:27:54,159
comes last

00:27:49,840 --> 00:27:57,039
at the in in f-sharp so the

00:27:54,159 --> 00:27:58,159
the in pipeline pipeline operator in

00:27:57,039 --> 00:28:00,880
f-sharp

00:27:58,159 --> 00:28:02,159
asked arguments as the end of the

00:28:00,880 --> 00:28:04,240
parameters

00:28:02,159 --> 00:28:06,080
arguments i mean the pipeline operator

00:28:04,240 --> 00:28:08,799
in elixir is different

00:28:06,080 --> 00:28:09,919
it's implemented in the macro but it as

00:28:08,799 --> 00:28:12,799
the primary

00:28:09,919 --> 00:28:13,760
argument as the first argument of the

00:28:12,799 --> 00:28:17,600
function call

00:28:13,760 --> 00:28:20,799
because the in elixir library uh the

00:28:17,600 --> 00:28:21,520
most most function takes its primary

00:28:20,799 --> 00:28:24,960
argument

00:28:21,520 --> 00:28:26,080
as the first argument of the function

00:28:24,960 --> 00:28:29,120
call

00:28:26,080 --> 00:28:30,480
so the uh the concept of the pipeline

00:28:29,120 --> 00:28:33,760
operator is add

00:28:30,480 --> 00:28:37,360
primary argument to the call

00:28:33,760 --> 00:28:40,320
so in case of the f sharp it comes

00:28:37,360 --> 00:28:41,840
at the end and in case of the elixir it

00:28:40,320 --> 00:28:44,960
comes at the top

00:28:41,840 --> 00:28:48,799
the first argument

00:28:44,960 --> 00:28:50,880
so if i uh i would add the pipeline

00:28:48,799 --> 00:28:53,520
operator in ruby

00:28:50,880 --> 00:28:54,480
uh the primary argument to the call

00:28:53,520 --> 00:28:57,200
means

00:28:54,480 --> 00:28:58,480
odd primary argument as the receiver of

00:28:57,200 --> 00:29:01,200
the method call

00:28:58,480 --> 00:29:03,840
because of the most ruby libraries takes

00:29:01,200 --> 00:29:07,279
its primary argument

00:29:03,840 --> 00:29:10,320
as the receiver uh

00:29:07,279 --> 00:29:13,360
and you know in ruby

00:29:10,320 --> 00:29:15,520
you can change that with the usual dot

00:29:13,360 --> 00:29:18,720
operator so that it's it's all

00:29:15,520 --> 00:29:20,240
out on the syntax syntax and then yeah

00:29:18,720 --> 00:29:21,919
but it has the different operator

00:29:20,240 --> 00:29:24,640
precedence like uh

00:29:21,919 --> 00:29:25,440
like blocks we have two uh two

00:29:24,640 --> 00:29:28,320
expression

00:29:25,440 --> 00:29:29,200
of blocks in the braces and the do and

00:29:28,320 --> 00:29:32,559
ends

00:29:29,200 --> 00:29:36,000
and what's wrong

00:29:32,559 --> 00:29:37,840
okay and then yeah by using these

00:29:36,000 --> 00:29:41,039
alternating syntax we have

00:29:37,840 --> 00:29:41,360
we have less parentheses and i admit i'm

00:29:41,039 --> 00:29:44,880
not

00:29:41,360 --> 00:29:45,200
100 confident about the index okay note

00:29:44,880 --> 00:29:48,399
that

00:29:45,200 --> 00:29:53,039
it's before 2.7 it's okay to cancel

00:29:48,399 --> 00:29:55,600
change articles but i have to experiment

00:29:53,039 --> 00:29:56,799
okay if yeah future options and then i

00:29:55,600 --> 00:30:00,320
give it other days and

00:29:56,799 --> 00:30:03,919
or give up or rename and design

00:30:00,320 --> 00:30:07,120
okay renaming the design comes from say

00:30:03,919 --> 00:30:09,600
we don't call it pipelines instead we

00:30:07,120 --> 00:30:12,960
call them chaining operator

00:30:09,600 --> 00:30:16,159
then they change the operator like

00:30:12,960 --> 00:30:19,600
for example yeah arrow

00:30:16,159 --> 00:30:22,880
or something like that okay

00:30:19,600 --> 00:30:24,000
as a side effect with the from those

00:30:22,880 --> 00:30:26,240
experiments

00:30:24,000 --> 00:30:29,200
we find out that we need to allow

00:30:26,240 --> 00:30:32,240
comments and new lines in method chains

00:30:29,200 --> 00:30:34,880
for example like this so the currents

00:30:32,240 --> 00:30:35,600
but in current syntax you cannot comment

00:30:34,880 --> 00:30:38,880
out

00:30:35,600 --> 00:30:41,919
the the middle of the the method chain

00:30:38,880 --> 00:30:44,000
or you cannot add the new line in the

00:30:41,919 --> 00:30:46,799
message chain because of the

00:30:44,000 --> 00:30:47,279
there so the the message chain will be

00:30:46,799 --> 00:30:51,200
cut

00:30:47,279 --> 00:30:54,960
and executed but uh we are working on

00:30:51,200 --> 00:30:57,519
to improve these things like now

00:30:54,960 --> 00:30:59,440
near future you can comment out the

00:30:57,519 --> 00:31:02,840
middle of the method chain

00:30:59,440 --> 00:31:04,960
or you can put the new line in the mid

00:31:02,840 --> 00:31:08,399
chains

00:31:04,960 --> 00:31:11,039
uh lights assignments is uh coming

00:31:08,399 --> 00:31:13,039
maybe in the different syntax different

00:31:11,039 --> 00:31:14,240
characters but the right assignment is

00:31:13,039 --> 00:31:16,399
coming so the

00:31:14,240 --> 00:31:17,679
instead of writing the assignment at the

00:31:16,399 --> 00:31:21,200
the top of the

00:31:17,679 --> 00:31:24,640
statement you can add the

00:31:21,200 --> 00:31:27,360
assignment destination at the end

00:31:24,640 --> 00:31:29,760
of the expression right assignment is

00:31:27,360 --> 00:31:29,760
common

00:31:31,279 --> 00:31:37,679
as i said we need to survive you know

00:31:34,720 --> 00:31:38,640
many people claim that ruby has died or

00:31:37,679 --> 00:31:41,919
something like that

00:31:38,640 --> 00:31:42,720
i'm sick of it but at least we need to

00:31:41,919 --> 00:31:45,840
survive

00:31:42,720 --> 00:31:47,120
and to provide benefit to provide

00:31:45,840 --> 00:31:50,480
benefit to our users

00:31:47,120 --> 00:31:53,440
like you and then to sustain our lives

00:31:50,480 --> 00:31:54,000
we i'm working ruby for full time so

00:31:53,440 --> 00:32:00,080
that

00:31:54,000 --> 00:32:02,880
yeah if ruby dies my family will die

00:32:00,080 --> 00:32:02,880
that's the problem

00:32:03,919 --> 00:32:10,159
yeah so so we have to survive

00:32:07,360 --> 00:32:11,120
the ruby has to survive to sustain our

00:32:10,159 --> 00:32:14,000
lives

00:32:11,120 --> 00:32:14,960
we will keep moving forward to survive

00:32:14,000 --> 00:32:17,600
with you

00:32:14,960 --> 00:32:18,320
the community input so that to make you

00:32:17,600 --> 00:32:21,840
and us

00:32:18,320 --> 00:32:29,840
and we to make us happy

00:32:21,840 --> 00:32:29,840
and to make world better place thank you

00:32:37,760 --> 00:32:42,000
thank you so much matt yep that talk was

00:32:40,240 --> 00:32:43,760
fantastic it's such a great thing to see

00:32:42,000 --> 00:32:46,640
the future ruby looking so

00:32:43,760 --> 00:32:48,000
so bright and uh definitely makes me a

00:32:46,640 --> 00:32:51,200
jolly roger

00:32:48,000 --> 00:32:53,120
um here's a speaker gift for you from

00:32:51,200 --> 00:32:57,840
the team at yuruko thank you very much

00:32:53,120 --> 00:32:57,840
thank you

00:32:59,679 --> 00:33:01,760

YouTube URL: https://www.youtube.com/watch?v=DC05C-UT3QQ


