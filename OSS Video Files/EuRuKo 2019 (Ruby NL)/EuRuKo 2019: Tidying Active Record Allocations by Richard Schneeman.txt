Title: EuRuKo 2019: Tidying Active Record Allocations by Richard Schneeman
Publication date: 2021-01-19
Playlist: EuRuKo 2019
Description: 
	The Life-Changing Magic of Tidying Active Record Allocations
Your app is slow. It does not spark joy. In this talk, we will use memory profiling tools to discover performance hotspots. We will use this technique with a real-world application to identify a piece of optimizable code in Active Record that leads to a patch with substantial page speed impact.

Richard Schneeman - https://twitter.com/schneems
EuRuKo 2019
Captions: 
	00:00:06,960 --> 00:00:11,599
our next talk

00:00:08,400 --> 00:00:12,799
is by richard schneemann am i saying

00:00:11,599 --> 00:00:15,280
that right good job

00:00:12,799 --> 00:00:16,720
thank you when um when i told him that

00:00:15,280 --> 00:00:18,080
um well he was talking about something

00:00:16,720 --> 00:00:20,480
he built run dock

00:00:18,080 --> 00:00:21,520
when i told him i used it he expressed

00:00:20,480 --> 00:00:25,199
his joy

00:00:21,520 --> 00:00:28,720
by saying sorry it's a was a

00:00:25,199 --> 00:00:31,439
weird way of well being thankful anyway

00:00:28,720 --> 00:00:32,000
and um but on the other end he was uh he

00:00:31,439 --> 00:00:35,040
was

00:00:32,000 --> 00:00:38,320
teaching a master a master course in

00:00:35,040 --> 00:00:40,640
in programming and he uh he

00:00:38,320 --> 00:00:42,239
well made all the material available for

00:00:40,640 --> 00:00:44,719
free online and i think that's a very

00:00:42,239 --> 00:00:47,120
nice uh nice move for you

00:00:44,719 --> 00:00:47,120
thank you

00:00:48,079 --> 00:00:54,079
well without further ado

00:00:51,199 --> 00:00:58,960
give it away take it away warm welcome

00:00:54,079 --> 00:01:01,760
for richard

00:00:58,960 --> 00:01:03,520
it is it is time to set sail uh so hello

00:01:01,760 --> 00:01:05,360
everyone my name is richard um

00:01:03,520 --> 00:01:07,360
thank you for the great introduction uh

00:01:05,360 --> 00:01:09,360
on the internet i go by

00:01:07,360 --> 00:01:10,880
uh schneemz some people who know me know

00:01:09,360 --> 00:01:13,520
that i love ruby

00:01:10,880 --> 00:01:16,400
um so much in fact that i married her

00:01:13,520 --> 00:01:18,640
this is my wife her name is ruby

00:01:16,400 --> 00:01:19,920
we have two uh two wonderful children

00:01:18,640 --> 00:01:21,759
i'm not gonna talk about them i will

00:01:19,920 --> 00:01:24,840
talk about one of my dogs

00:01:21,759 --> 00:01:26,000
uh his name is hans peter von wolfe the

00:01:24,840 --> 00:01:27,920
fifth

00:01:26,000 --> 00:01:30,320
he is in fact the fifth hans peter von

00:01:27,920 --> 00:01:32,079
wolfe my grandfather owned the first one

00:01:30,320 --> 00:01:33,360
uh it's a bit of a mouthful to yell out

00:01:32,079 --> 00:01:36,799
the door so

00:01:33,360 --> 00:01:40,159
instead we just call him cinco

00:01:36,799 --> 00:01:41,439
uh i maintain a service well i created a

00:01:40,159 --> 00:01:42,960
service called codetriage it's the

00:01:41,439 --> 00:01:46,640
easiest way to get started

00:01:42,960 --> 00:01:49,280
in open source also you

00:01:46,640 --> 00:01:50,159
it sends you issue contribution ideas as

00:01:49,280 --> 00:01:52,799
well as

00:01:50,159 --> 00:01:55,360
documentation ideas so if you want to

00:01:52,799 --> 00:01:58,079
contribute to a ruby project

00:01:55,360 --> 00:01:59,680
i work for a small startup based out of

00:01:58,079 --> 00:02:00,719
san francisco

00:01:59,680 --> 00:02:03,280
you might have heard of it it's called

00:02:00,719 --> 00:02:03,280
heroku

00:02:03,520 --> 00:02:07,280
they were nice enough to pay for my

00:02:05,600 --> 00:02:09,119
flight which is fantastic

00:02:07,280 --> 00:02:10,800
and they also pay me to work on the ruby

00:02:09,119 --> 00:02:12,560
build pack as well as some other open

00:02:10,800 --> 00:02:14,879
source things

00:02:12,560 --> 00:02:17,840
before i get started though i want to um

00:02:14,879 --> 00:02:20,080
talk a little bit about a back story

00:02:17,840 --> 00:02:21,200
when i started working on this this talk

00:02:20,080 --> 00:02:23,120
if you follow me on twitter you might

00:02:21,200 --> 00:02:25,599
have seen that i hurt my hands

00:02:23,120 --> 00:02:26,879
pretty bad uh so bad in fact that i had

00:02:25,599 --> 00:02:28,400
to take a couple weeks off

00:02:26,879 --> 00:02:30,480
and about the time that i started

00:02:28,400 --> 00:02:32,000
writing this presentation um i was

00:02:30,480 --> 00:02:34,080
limited to using an eye tracker and

00:02:32,000 --> 00:02:34,720
voice controls for my input devices on a

00:02:34,080 --> 00:02:38,400
computer

00:02:34,720 --> 00:02:38,400
so here's what that looks like

00:02:41,599 --> 00:02:48,800
sun cap near

00:02:45,519 --> 00:02:52,560
each each

00:02:48,800 --> 00:02:54,000
each each so how did i make such an

00:02:52,560 --> 00:02:56,319
amazing presentation without use of my

00:02:54,000 --> 00:02:56,319
hands

00:02:56,879 --> 00:03:02,840
uh so you can you can give a hand to my

00:02:58,800 --> 00:03:05,840
hands this is uh this is caleb thompson

00:03:02,840 --> 00:03:05,840
um

00:03:08,080 --> 00:03:12,000
uh i also have to thank a voice-over

00:03:10,480 --> 00:03:14,159
artist uh yuri who

00:03:12,000 --> 00:03:16,879
you will be seeing um her work later but

00:03:14,159 --> 00:03:16,879
here's yuri

00:03:17,519 --> 00:03:23,680
voice hello actress today i will be

00:03:20,080 --> 00:03:23,680
praying the voice of the rabbit

00:03:25,440 --> 00:03:29,599
who you will meet very soon i was also

00:03:27,680 --> 00:03:31,280
told that we have to have boat jokes

00:03:29,599 --> 00:03:33,360
since we're on a boat if you haven't

00:03:31,280 --> 00:03:35,760
gotten enough of them yet so

00:03:33,360 --> 00:03:37,440
why do we have a ruby uh conference on a

00:03:35,760 --> 00:03:41,440
boat

00:03:37,440 --> 00:03:47,840
huh because everyone knows that ruby is

00:03:41,440 --> 00:03:47,840
written on top of c

00:03:51,440 --> 00:03:54,640
all right so so so this is true this is

00:03:53,360 --> 00:03:57,439
a true thing um

00:03:54,640 --> 00:04:00,879
the the rss david attenborough uh has a

00:03:57,439 --> 00:04:04,000
submarine named bodie mcboatface

00:04:00,879 --> 00:04:05,680
to repeat the name is bodie mcboatface

00:04:04,000 --> 00:04:08,080
i don't have a joke it's just like this

00:04:05,680 --> 00:04:09,920
is life um that's the actual name

00:04:08,080 --> 00:04:11,280
and even though it's a funny name it has

00:04:09,920 --> 00:04:13,040
actual mate actually made serious

00:04:11,280 --> 00:04:15,280
contributions to climate science

00:04:13,040 --> 00:04:17,440
which is pretty cool i also maintain

00:04:15,280 --> 00:04:18,479
puma and we're about to release puma 4

00:04:17,440 --> 00:04:21,280
soon

00:04:18,479 --> 00:04:22,000
but in order to before i can release it

00:04:21,280 --> 00:04:24,880
i have to

00:04:22,000 --> 00:04:24,880
get back to port

00:04:26,160 --> 00:04:29,280
this talk is mostly about uh performance

00:04:28,400 --> 00:04:31,919
um

00:04:29,280 --> 00:04:34,160
and uh i i did find something that i

00:04:31,919 --> 00:04:35,680
think can really make ruby faster

00:04:34,160 --> 00:04:37,919
uh i was thinking about this on the way

00:04:35,680 --> 00:04:40,160
over here and i think that's the problem

00:04:37,919 --> 00:04:41,680
right there

00:04:40,160 --> 00:04:44,560
you just got you just got to take the

00:04:41,680 --> 00:04:47,600
sleep out so that's that's it

00:04:44,560 --> 00:04:49,840
all right okay so who knows who this is

00:04:47,600 --> 00:04:51,919
all right good so this is uh marie kondo

00:04:49,840 --> 00:04:54,400
she's a world famous organizing expert

00:04:51,919 --> 00:04:56,400
um she has a netflix tv show she has a

00:04:54,400 --> 00:04:58,720
number of books they're all fantastic

00:04:56,400 --> 00:05:08,000
uh and i want to show you quickly a clip

00:04:58,720 --> 00:05:08,000
that she has been working on object

00:05:08,840 --> 00:05:11,840
allocations

00:05:13,330 --> 00:05:16,380
[Music]

00:05:18,400 --> 00:05:27,540
oh my god we got too much

00:05:24,090 --> 00:05:27,540
[Music]

00:05:33,440 --> 00:05:37,360
thank you thank you i think uh i think

00:05:35,039 --> 00:05:39,120
this is going to have a wide appeal on

00:05:37,360 --> 00:05:39,919
netflix you should look for it very

00:05:39,120 --> 00:05:42,240
shortly

00:05:39,919 --> 00:05:43,759
um unfortunately uh com marie couldn't

00:05:42,240 --> 00:05:46,960
be here with us today

00:05:43,759 --> 00:05:53,840
so um instead she set her pen rabbit uh

00:05:46,960 --> 00:05:53,840
con hair

00:05:54,690 --> 00:05:57,810
[Music]

00:06:04,840 --> 00:06:09,520
foreign

00:06:06,400 --> 00:06:13,759
hello and welcome everyone

00:06:09,520 --> 00:06:17,600
my name is in english

00:06:13,759 --> 00:06:21,440
means love it robert stops to go

00:06:17,600 --> 00:06:26,800
really fast i love colors

00:06:21,440 --> 00:06:29,759
so i love movies i also love performance

00:06:26,800 --> 00:06:31,800
today you're here to hear the concrete

00:06:29,759 --> 00:06:33,280
method of hiding your groupie

00:06:31,800 --> 00:06:34,880
applications

00:06:33,280 --> 00:06:36,000
all right that's great can you can you

00:06:34,880 --> 00:06:38,319
tell us a little bit more about that web

00:06:36,000 --> 00:06:38,319
method

00:06:40,560 --> 00:06:44,560
and put them in a pile where you can see

00:06:43,440 --> 00:06:49,840
them

00:06:44,560 --> 00:06:49,840
next consider each one

00:06:58,560 --> 00:07:05,759
how do you know if an object sparks joy

00:07:02,319 --> 00:07:09,120
if an object is very useful

00:07:05,759 --> 00:07:11,039
and keeps your code clean and it's not

00:07:09,120 --> 00:07:14,319
causing performance problems

00:07:11,039 --> 00:07:17,360
then it's part joy

00:07:14,319 --> 00:07:19,919
if an object is absolutely necessary

00:07:17,360 --> 00:07:21,039
and removing it from your code causes it

00:07:19,919 --> 00:07:24,319
to crash

00:07:21,039 --> 00:07:24,319
then it sparks joy

00:07:24,720 --> 00:07:28,479
the last one is kind of a technicality

00:07:27,520 --> 00:07:31,199
when we put

00:07:28,479 --> 00:07:32,639
all the objects in front of us it will

00:07:31,199 --> 00:07:35,520
help to determine

00:07:32,639 --> 00:07:37,039
which ones we can consider getting rid

00:07:35,520 --> 00:07:38,720
of

00:07:37,039 --> 00:07:40,319
okay all right thank you very much i see

00:07:38,720 --> 00:07:41,919
where you're going to put

00:07:40,319 --> 00:07:43,280
all of our objects into a pile we're

00:07:41,919 --> 00:07:45,120
going to be using two tools we're going

00:07:43,280 --> 00:07:47,520
to be using memory profiler

00:07:45,120 --> 00:07:48,319
as well as derailed benchmarks which is

00:07:47,520 --> 00:07:50,400
going to help us

00:07:48,319 --> 00:07:52,080
benchmark our rails applications so

00:07:50,400 --> 00:07:54,720
first we're going to start out with a

00:07:52,080 --> 00:07:56,960
little bit of a quiz

00:07:54,720 --> 00:07:58,240
here's a benchmark of two different ways

00:07:56,960 --> 00:08:00,400
of doing the same thing

00:07:58,240 --> 00:08:01,360
determining the largest value of two

00:08:00,400 --> 00:08:03,360
inputs

00:08:01,360 --> 00:08:05,039
so here you can see uh we are allocating

00:08:03,360 --> 00:08:05,919
an array and doing the comparison with

00:08:05,039 --> 00:08:09,360
the array

00:08:05,919 --> 00:08:11,520
and here we can replace that with

00:08:09,360 --> 00:08:12,720
another method that does not use an

00:08:11,520 --> 00:08:16,080
allocation but instead

00:08:12,720 --> 00:08:20,000
it is a direct comparison uh so

00:08:16,080 --> 00:08:20,000
who thinks the array method is faster

00:08:22,720 --> 00:08:26,800
who thinks the other method is faster

00:08:25,280 --> 00:08:28,080
okay good so i will tell you that that

00:08:26,800 --> 00:08:29,599
is correct but does anybody have any

00:08:28,080 --> 00:08:32,479
idea about how much faster

00:08:29,599 --> 00:08:32,479
just shout out a number

00:08:32,719 --> 00:08:40,080
ten thousand okay did somebody say pie

00:08:37,279 --> 00:08:41,519
okay uh so the ant some it is two times

00:08:40,080 --> 00:08:42,959
faster so thank you somebody

00:08:41,519 --> 00:08:44,640
nailed that i don't have any treats to

00:08:42,959 --> 00:08:46,480
give out unfortunately uh

00:08:44,640 --> 00:08:49,120
and that's a really big to me both of

00:08:46,480 --> 00:08:50,320
those methods do the exact same logic so

00:08:49,120 --> 00:08:51,279
that's a really big performance

00:08:50,320 --> 00:08:53,279
difference

00:08:51,279 --> 00:08:55,200
um and in general touching memory is

00:08:53,279 --> 00:08:57,120
going to be slower than performing uh

00:08:55,200 --> 00:08:59,279
comparisons and calculations and this is

00:08:57,120 --> 00:09:01,279
not just true in ruby but this is true

00:08:59,279 --> 00:09:02,959
in every language for example if you're

00:09:01,279 --> 00:09:05,920
writing c then calling malek is going to

00:09:02,959 --> 00:09:07,760
be slow and you want to avoid it

00:09:05,920 --> 00:09:10,399
since we know that ruby allocation is

00:09:07,760 --> 00:09:11,440
expensive and we know we've seen that we

00:09:10,399 --> 00:09:13,440
can optimize

00:09:11,440 --> 00:09:15,519
some cases by removing those allocations

00:09:13,440 --> 00:09:17,200
and doing comparisons instead

00:09:15,519 --> 00:09:18,800
we can use this to make our programs

00:09:17,200 --> 00:09:21,120
faster just like we did before in the

00:09:18,800 --> 00:09:24,240
quiz

00:09:21,120 --> 00:09:25,920
uh and if we find where lots and lots of

00:09:24,240 --> 00:09:27,440
objects are being allocated

00:09:25,920 --> 00:09:28,800
then this is going to show us where

00:09:27,440 --> 00:09:30,399
we're going to be having hot spots in

00:09:28,800 --> 00:09:32,240
our program so so we can look at that

00:09:30,399 --> 00:09:34,240
first

00:09:32,240 --> 00:09:35,360
the uh when we're optimizing the

00:09:34,240 --> 00:09:37,920
percentage of

00:09:35,360 --> 00:09:39,760
bytes allocated roughly if we can if we

00:09:37,920 --> 00:09:42,800
can reduce that by say

00:09:39,760 --> 00:09:44,399
about a by about one percent then on

00:09:42,800 --> 00:09:45,040
average our program is going to get

00:09:44,399 --> 00:09:47,360
about

00:09:45,040 --> 00:09:48,480
one percent faster and that's usually

00:09:47,360 --> 00:09:50,320
but not always

00:09:48,480 --> 00:09:52,480
uh this simplifying assumption helps us

00:09:50,320 --> 00:09:53,519
to actually benchmark faster as well

00:09:52,480 --> 00:09:56,000
typically when you're writing a

00:09:53,519 --> 00:09:57,040
benchmark you can't just run and time

00:09:56,000 --> 00:09:59,360
two things there's

00:09:57,040 --> 00:10:01,040
a lot of variance and you have to run

00:09:59,360 --> 00:10:02,320
them over and over again sometimes

00:10:01,040 --> 00:10:04,880
thousands of times sometimes

00:10:02,320 --> 00:10:06,480
millions of times and in in order to run

00:10:04,880 --> 00:10:07,920
this type of a benchmark it takes a

00:10:06,480 --> 00:10:09,760
large amount of time

00:10:07,920 --> 00:10:11,040
um if you're using benchmark ips it's

00:10:09,760 --> 00:10:13,760
five seconds each time

00:10:11,040 --> 00:10:15,680
so uh in comparison if you're just

00:10:13,760 --> 00:10:17,360
comparing memory directly 100 bytes is

00:10:15,680 --> 00:10:18,240
always going to be 100 bytes it's

00:10:17,360 --> 00:10:19,680
consistent

00:10:18,240 --> 00:10:22,320
and we only have to take one measurement

00:10:19,680 --> 00:10:24,160
instead of thousands

00:10:22,320 --> 00:10:25,920
this is also going to allow us to

00:10:24,160 --> 00:10:28,160
prototype faster we can use this as a

00:10:25,920 --> 00:10:30,320
simplifying assumption

00:10:28,160 --> 00:10:32,000
you do have to be very careful once you

00:10:30,320 --> 00:10:34,640
have major changes to go back

00:10:32,000 --> 00:10:36,079
and re-run your speed benchmarks because

00:10:34,640 --> 00:10:38,480
typically removing

00:10:36,079 --> 00:10:40,240
object allocations involves trading it

00:10:38,480 --> 00:10:42,959
for comparisons and sometimes you might

00:10:40,240 --> 00:10:45,839
add too many comparisons

00:10:42,959 --> 00:10:47,600
another thing to mention is that we are

00:10:45,839 --> 00:10:49,120
going to be looking at bytes allocated

00:10:47,600 --> 00:10:51,279
as opposed to number of objects

00:10:49,120 --> 00:10:53,440
allocated objects are not inherently

00:10:51,279 --> 00:10:54,880
bad ruby is an object-oriented

00:10:53,440 --> 00:10:55,920
programming language i recommend that

00:10:54,880 --> 00:11:00,000
you use them

00:10:55,920 --> 00:11:03,120
um but this is just my experience

00:11:00,000 --> 00:11:04,800
and uh so the next thing

00:11:03,120 --> 00:11:06,160
why aren't you supposed to be telling

00:11:04,800 --> 00:11:09,440
people how to

00:11:06,160 --> 00:11:12,640
get all the objects into one place

00:11:09,440 --> 00:11:14,560
so we can use a message

00:11:12,640 --> 00:11:16,640
all right okay so i got a little off

00:11:14,560 --> 00:11:19,279
track there uh so let's let's take a

00:11:16,640 --> 00:11:19,279
look at that now

00:11:20,900 --> 00:11:26,880
[Music]

00:11:23,200 --> 00:11:30,560
i'll be back in a hot people come on

00:11:26,880 --> 00:11:31,519
it's a rabbit um okay so uh the memory

00:11:30,560 --> 00:11:33,519
profiler gem

00:11:31,519 --> 00:11:35,360
is going to allow us to take uh all the

00:11:33,519 --> 00:11:35,680
allocations from the program and view

00:11:35,360 --> 00:11:37,839
them

00:11:35,680 --> 00:11:38,959
behind the scenes it's using a nice

00:11:37,839 --> 00:11:42,560
wrapper for the

00:11:38,959 --> 00:11:42,560
object space allocation tracing

00:11:42,640 --> 00:11:46,160
if you're trying to profile a rails

00:11:44,399 --> 00:11:47,519
application uh you can use the derailed

00:11:46,160 --> 00:11:50,079
benchmark and the gem

00:11:47,519 --> 00:11:51,519
will hit an endpoint on your application

00:11:50,079 --> 00:11:53,040
directly from your cli

00:11:51,519 --> 00:11:54,399
the benefit of this is that you don't

00:11:53,040 --> 00:11:56,240
have to restart the server between

00:11:54,399 --> 00:11:58,160
changes you don't have to refresh a

00:11:56,240 --> 00:11:59,360
browser it kind of just works

00:11:58,160 --> 00:12:01,440
we're gonna we're gonna take a look at a

00:11:59,360 --> 00:12:11,839
real world case study but

00:12:01,440 --> 00:12:11,839
um i'm gonna need a little introduction

00:12:18,000 --> 00:12:25,839
i call this section in

00:12:21,600 --> 00:12:25,839
adequate record

00:12:25,920 --> 00:12:29,519
okay first off we're going to run

00:12:27,360 --> 00:12:31,760
derailed against the target application

00:12:29,519 --> 00:12:33,440
which in this case is code triage

00:12:31,760 --> 00:12:34,959
and it's going to give us a pile of

00:12:33,440 --> 00:12:38,639
memory allocations

00:12:34,959 --> 00:12:40,000
so this is our pile

00:12:38,639 --> 00:12:41,519
the output is going to show the most

00:12:40,000 --> 00:12:44,320
memory allocations at top so that's

00:12:41,519 --> 00:12:46,240
where we're going to start looking

00:12:44,320 --> 00:12:47,600
i start looking at each file from the

00:12:46,240 --> 00:12:48,240
top to the bottom in this case i've

00:12:47,600 --> 00:12:49,760
already done

00:12:48,240 --> 00:12:51,680
a few and we're going to jump to this

00:12:49,760 --> 00:12:54,720
one once i've picked a file

00:12:51,680 --> 00:12:55,680
then i need to zoom into it and we can

00:12:54,720 --> 00:12:58,880
do this again

00:12:55,680 --> 00:13:00,880
by filtering our results

00:12:58,880 --> 00:13:02,240
here is the filtered output and you can

00:13:00,880 --> 00:13:03,519
see that it's much cleaner now

00:13:02,240 --> 00:13:05,680
and it looks like the majority of

00:13:03,519 --> 00:13:08,720
allocations are coming from

00:13:05,680 --> 00:13:11,519
line 270. let's figure out what the code

00:13:08,720 --> 00:13:16,320
does by opening up that file

00:13:11,519 --> 00:13:16,320
here is uh line 270.

00:13:16,800 --> 00:13:20,000
it looks like it's allocating strings

00:13:18,399 --> 00:13:22,079
but why to understand we

00:13:20,000 --> 00:13:23,760
have to figure out what the code even

00:13:22,079 --> 00:13:25,760
does

00:13:23,760 --> 00:13:27,440
this code is inside of the respond to

00:13:25,760 --> 00:13:28,079
method and when we call respond to on an

00:13:27,440 --> 00:13:29,680
object

00:13:28,079 --> 00:13:31,360
we need to know if a method by that name

00:13:29,680 --> 00:13:32,959
exists because activerecord

00:13:31,360 --> 00:13:35,839
is backed by a database we need to know

00:13:32,959 --> 00:13:37,680
if a column by that name exists

00:13:35,839 --> 00:13:39,440
typically when you call respond to you

00:13:37,680 --> 00:13:41,680
pass in a symbol but active record

00:13:39,440 --> 00:13:44,240
stores the columns as strings

00:13:41,680 --> 00:13:45,760
on this line we convert the uh we

00:13:44,240 --> 00:13:48,880
convert the symbol to a string so we can

00:13:45,760 --> 00:13:51,519
make that comparison uh then we iterate

00:13:48,880 --> 00:13:54,160
all over all of the the column arrays

00:13:51,519 --> 00:13:56,320
so uh here's an example if we're calling

00:13:54,160 --> 00:13:58,880
respond to on user

00:13:56,320 --> 00:14:00,720
we pass in email as a symbol we're going

00:13:58,880 --> 00:14:02,800
to convert it to a string

00:14:00,720 --> 00:14:04,959
and then we see if it matches that

00:14:02,800 --> 00:14:07,760
column or that one

00:14:04,959 --> 00:14:09,279
or that one until finally we found a

00:14:07,760 --> 00:14:11,199
match

00:14:09,279 --> 00:14:12,480
in that case we have to use the string

00:14:11,199 --> 00:14:16,000
and actually check that

00:14:12,480 --> 00:14:16,639
exact object has that attribute on it so

00:14:16,000 --> 00:14:19,600
now that we

00:14:16,639 --> 00:14:20,800
know what this code does we can ask does

00:14:19,600 --> 00:14:23,440
this object allocation

00:14:20,800 --> 00:14:23,440
spark joy

00:14:24,160 --> 00:14:27,279
it's in use so i'd say it's pretty

00:14:25,680 --> 00:14:28,399
useful uh it's doing a lot of

00:14:27,279 --> 00:14:31,360
allocations so

00:14:28,399 --> 00:14:33,040
i would say not very performant does it

00:14:31,360 --> 00:14:36,720
help our code be cleaner

00:14:33,040 --> 00:14:37,680
well not not really um is it absolutely

00:14:36,720 --> 00:14:38,639
necessary

00:14:37,680 --> 00:14:40,560
all right that's kind of the key

00:14:38,639 --> 00:14:41,279
question here we don't really know yet

00:14:40,560 --> 00:14:42,480
so

00:14:41,279 --> 00:14:44,639
let's find out let's see if we can

00:14:42,480 --> 00:14:47,199
refactor this code to be faster while

00:14:44,639 --> 00:14:50,000
also maintaining correctness

00:14:47,199 --> 00:14:51,600
looking at this the name variable must

00:14:50,000 --> 00:14:53,279
be a string because the database columns

00:14:51,600 --> 00:14:55,519
are stored as strings so we must make a

00:14:53,279 --> 00:14:58,240
conversion somewhere

00:14:55,519 --> 00:15:00,079
my hypothesis is that instead of doing

00:14:58,240 --> 00:15:00,880
it here we can find a way to perform a

00:15:00,079 --> 00:15:04,000
column check

00:15:00,880 --> 00:15:06,160
as a symbol directly

00:15:04,000 --> 00:15:07,360
to me this allocation does not spark joy

00:15:06,160 --> 00:15:10,639
so let's let's just

00:15:07,360 --> 00:15:12,240
you know throw it in the trash right now

00:15:10,639 --> 00:15:13,839
we never want to allocate a string if we

00:15:12,240 --> 00:15:15,279
can if we can help it so we can go ahead

00:15:13,839 --> 00:15:26,160
and get rid of this code

00:15:15,279 --> 00:15:28,079
and um

00:15:26,160 --> 00:15:29,600
very thank you thank you very much i got

00:15:28,079 --> 00:15:30,959
a little carried away with myself

00:15:29,600 --> 00:15:32,639
um the code has been in hundreds of

00:15:30,959 --> 00:15:35,360
thousands of production applications

00:15:32,639 --> 00:15:37,279
it might not spark joy now but it has

00:15:35,360 --> 00:15:39,360
been very useful to us so we need to be

00:15:37,279 --> 00:15:40,320
we need to be grateful and for that i'm

00:15:39,360 --> 00:15:45,839
thankful

00:15:40,320 --> 00:15:45,839
thank you code we can now get rid of it

00:15:46,399 --> 00:15:49,279
unfortunately if that's all we did the

00:15:47,680 --> 00:15:50,560
application would break so we have to

00:15:49,279 --> 00:15:52,880
figure out a way to convert the symbol

00:15:50,560 --> 00:15:55,759
to a string without allocating

00:15:52,880 --> 00:15:56,240
we can store our column information as a

00:15:55,759 --> 00:15:59,199
hash

00:15:56,240 --> 00:15:59,600
with the symbol as a key and a string as

00:15:59,199 --> 00:16:03,440
the

00:15:59,600 --> 00:16:05,600
value and now if we port over our code

00:16:03,440 --> 00:16:06,800
then we can use the hash to both check

00:16:05,600 --> 00:16:09,680
for column existence

00:16:06,800 --> 00:16:10,639
as well as using the string it returns

00:16:09,680 --> 00:16:14,000
on the has

00:16:10,639 --> 00:16:15,680
method has attribute method

00:16:14,000 --> 00:16:18,160
as a bonus performance bump here we're

00:16:15,680 --> 00:16:20,240
using a hash lookup as opposed to having

00:16:18,160 --> 00:16:22,639
to iterate over an array

00:16:20,240 --> 00:16:24,560
so how much did that help the patch

00:16:22,639 --> 00:16:26,079
reduced object allocations by about one

00:16:24,560 --> 00:16:28,000
percent of total memory

00:16:26,079 --> 00:16:29,839
before code triage and that's it isn't

00:16:28,000 --> 00:16:31,759
across an entire request it's not just

00:16:29,839 --> 00:16:35,360
like a micro benchmark

00:16:31,759 --> 00:16:38,880
um on average my my patch also caused

00:16:35,360 --> 00:16:40,639
render time to be about 1.01 x faster

00:16:38,880 --> 00:16:48,959
so um i think we're i think we're

00:16:40,639 --> 00:16:52,240
basically done here

00:16:48,959 --> 00:16:55,040
it is faster but you have not shown

00:16:52,240 --> 00:16:56,560
that these results are statistically

00:16:55,040 --> 00:16:59,040
significant

00:16:56,560 --> 00:17:01,120
it is time to teach them that

00:16:59,040 --> 00:17:04,480
[Music]

00:17:01,120 --> 00:17:06,640
all right okay so um who knows what this

00:17:04,480 --> 00:17:06,640
is

00:17:06,799 --> 00:17:14,480
this is a t congratulations you have

00:17:08,880 --> 00:17:14,480
passed the t-test

00:17:17,120 --> 00:17:22,079
all right okay so here's an example of a

00:17:20,400 --> 00:17:22,720
benchmark and how how numbers can lie

00:17:22,079 --> 00:17:24,400
we've got two

00:17:22,720 --> 00:17:25,760
objects we've got an array we've got a

00:17:24,400 --> 00:17:28,880
string if we

00:17:25,760 --> 00:17:31,520
duplicate them we can see that each

00:17:28,880 --> 00:17:32,640
is the same amount of memory in terms of

00:17:31,520 --> 00:17:35,120
ruby

00:17:32,640 --> 00:17:37,360
now which is going to be faster duping

00:17:35,120 --> 00:17:39,760
the array or duping the string

00:17:37,360 --> 00:17:40,480
well as you can see from our benchmark

00:17:39,760 --> 00:17:43,440
here that

00:17:40,480 --> 00:17:45,360
duping the array is clearly faster

00:17:43,440 --> 00:17:47,120
except for when duping the string is

00:17:45,360 --> 00:17:50,160
actually faster

00:17:47,120 --> 00:17:52,400
or um okay so turns out both of them are

00:17:50,160 --> 00:17:53,840
exactly the same

00:17:52,400 --> 00:17:55,679
and this is a problem that you run into

00:17:53,840 --> 00:17:57,120
with benchmarks i could totally lie to

00:17:55,679 --> 00:17:58,000
you and just have picked one of those

00:17:57,120 --> 00:17:59,360
slides and i

00:17:58,000 --> 00:18:01,039
and then you would have taken it you

00:17:59,360 --> 00:18:02,480
know potentially for granted

00:18:01,039 --> 00:18:04,160
but that would be lying with numbers

00:18:02,480 --> 00:18:05,440
instead we can use students t-test to

00:18:04,160 --> 00:18:07,919
determine if our numbers are

00:18:05,440 --> 00:18:10,160
statistically significant

00:18:07,919 --> 00:18:12,840
um student's t-test was introduced in

00:18:10,160 --> 00:18:15,840
1908 by william seely gossett who worked

00:18:12,840 --> 00:18:15,840
for

00:18:17,600 --> 00:18:20,000
guinness

00:18:21,120 --> 00:18:25,120
why is it called student's t-test well

00:18:23,679 --> 00:18:26,320
guinness wouldn't allow its employees to

00:18:25,120 --> 00:18:28,080
publish their findings

00:18:26,320 --> 00:18:30,320
and they worried that competitors would

00:18:28,080 --> 00:18:32,080
start using the same techniques

00:18:30,320 --> 00:18:33,520
so gossip published under a suit in them

00:18:32,080 --> 00:18:35,440
the problem is that

00:18:33,520 --> 00:18:37,039
breweries the quality of their beer is

00:18:35,440 --> 00:18:38,080
based on the quality of the ingredients

00:18:37,039 --> 00:18:39,520
that they're receiving

00:18:38,080 --> 00:18:40,880
and while they can sample from this

00:18:39,520 --> 00:18:42,960
shipment and sample from that shipment

00:18:40,880 --> 00:18:44,240
they needed a way to reliably compare

00:18:42,960 --> 00:18:46,000
lots of samples from two different

00:18:44,240 --> 00:18:49,120
shipments

00:18:46,000 --> 00:18:52,480
and so this history lesson is

00:18:49,120 --> 00:18:56,240
interesting but

00:18:52,480 --> 00:18:58,720
let's get back to object allocations

00:18:56,240 --> 00:18:59,520
okay uh so i use an advanced statistical

00:18:58,720 --> 00:19:02,720
tool set

00:18:59,520 --> 00:19:04,720
it helps you to excel there's a function

00:19:02,720 --> 00:19:07,600
that generates a t-test for you

00:19:04,720 --> 00:19:10,320
if it is under a certain threshold 0.05

00:19:07,600 --> 00:19:14,559
then it is statistically significant

00:19:10,320 --> 00:19:17,600
well was your change statistically

00:19:14,559 --> 00:19:20,240
significant yes so

00:19:17,600 --> 00:19:20,240
it got merged

00:19:22,960 --> 00:19:30,720
times in isn't much to brag about

00:19:27,280 --> 00:19:34,799
you need to get 10 pull requests

00:19:30,720 --> 00:19:37,120
merge into make the problem 1.1 times

00:19:34,799 --> 00:19:40,080
faster

00:19:37,120 --> 00:19:41,039
okay that's true uh but it is a 1.01 x

00:19:40,080 --> 00:19:43,120
speed increase

00:19:41,039 --> 00:19:45,280
at the request response level so

00:19:43,120 --> 00:19:47,280
theoretically if your application needed

00:19:45,280 --> 00:19:49,840
a hundred servers previously after this

00:19:47,280 --> 00:19:54,640
patch it now needs

00:19:49,840 --> 00:19:57,679
only that's pretty cool right

00:19:54,640 --> 00:20:01,200
that's a good point

00:19:57,679 --> 00:20:04,400
but still it's only one po

00:20:01,200 --> 00:20:05,200
let's show these good people another

00:20:04,400 --> 00:20:08,799
example

00:20:05,200 --> 00:20:13,440
of using my world changing tiding

00:20:08,799 --> 00:20:18,080
method alright so what's the first step

00:20:13,440 --> 00:20:18,080
first collect the object

00:20:19,200 --> 00:20:22,240
all right so here's our pile of memory

00:20:21,039 --> 00:20:25,200
like before

00:20:22,240 --> 00:20:26,000
um i started at the top and worked my

00:20:25,200 --> 00:20:27,679
way down

00:20:26,000 --> 00:20:29,919
we're going to zoom into this file and

00:20:27,679 --> 00:20:31,280
see if we can make anything faster

00:20:29,919 --> 00:20:33,679
this time we'll be taking a look at

00:20:31,280 --> 00:20:36,799
active models um

00:20:33,679 --> 00:20:36,799
time value to rb

00:20:37,039 --> 00:20:40,880
it looks like the memory is coming from

00:20:38,480 --> 00:20:43,039
line 72 so let's open up that file

00:20:40,880 --> 00:20:45,120
on line 72 we are matching an input

00:20:43,039 --> 00:20:47,280
string against a regular expression

00:20:45,120 --> 00:20:49,039
this allocates a bunch of memory because

00:20:47,280 --> 00:20:53,200
each of our grouped matches

00:20:49,039 --> 00:20:53,200
is going to allocate a new string

00:20:55,500 --> 00:20:58,609
[Music]

00:21:00,480 --> 00:21:03,360
before i can answer that i have to

00:21:01,600 --> 00:21:04,640
figure out what does it even do i don't

00:21:03,360 --> 00:21:05,280
know i don't know what does this method

00:21:04,640 --> 00:21:07,039
do

00:21:05,280 --> 00:21:08,400
um i can see here that it accepts a

00:21:07,039 --> 00:21:11,840
string argument

00:21:08,400 --> 00:21:13,520
uh i can go down here and see that it's

00:21:11,840 --> 00:21:15,039
taking all of the different string parts

00:21:13,520 --> 00:21:15,440
and it looks like it's assembling a new

00:21:15,039 --> 00:21:18,720
time

00:21:15,440 --> 00:21:20,640
object so can we make it faster

00:21:18,720 --> 00:21:21,919
on this line we're not really doing

00:21:20,640 --> 00:21:23,600
anything we already have all of those

00:21:21,919 --> 00:21:24,400
matches we're just calling 2i on a bunch

00:21:23,600 --> 00:21:25,760
of them

00:21:24,400 --> 00:21:28,080
there's not a whole lot to optimize

00:21:25,760 --> 00:21:29,600
there

00:21:28,080 --> 00:21:32,320
but what about here what about on this

00:21:29,600 --> 00:21:34,640
line what's even what's even happening

00:21:32,320 --> 00:21:35,840
so it turns out that uh dollar sign

00:21:34,640 --> 00:21:37,919
seven the seventh

00:21:35,840 --> 00:21:39,360
regex match is going to be a string

00:21:37,919 --> 00:21:40,640
that's going to start with a period and

00:21:39,360 --> 00:21:42,720
it looks like this

00:21:40,640 --> 00:21:44,640
once we do perform all of this logic to

00:21:42,720 --> 00:21:46,480
it we end up with a variable

00:21:44,640 --> 00:21:47,840
that looks like this so we're basically

00:21:46,480 --> 00:21:50,960
just converting this

00:21:47,840 --> 00:21:54,240
decimal number into an actual integer

00:21:50,960 --> 00:21:56,320
can we do it better we can guard against

00:21:54,240 --> 00:21:59,280
the most common cases

00:21:56,320 --> 00:22:00,559
that when it's exactly seven digits and

00:21:59,280 --> 00:22:02,080
in order to do that first we have to

00:22:00,559 --> 00:22:03,760
remove the leading period

00:22:02,080 --> 00:22:06,159
and then we just convert it directly to

00:22:03,760 --> 00:22:09,840
an integer just call 2i on it

00:22:06,159 --> 00:22:10,559
now is it faster here's a micro

00:22:09,840 --> 00:22:12,320
benchmark

00:22:10,559 --> 00:22:14,960
and when we run it we see that the code

00:22:12,320 --> 00:22:16,559
did in fact get faster

00:22:14,960 --> 00:22:18,960
so is there anything else that we could

00:22:16,559 --> 00:22:18,960
do here

00:22:19,039 --> 00:22:26,240
um i don't i don't really think so don't

00:22:22,400 --> 00:22:30,559
give up now you practically know

00:22:26,240 --> 00:22:32,799
nothing about how this method is used

00:22:30,559 --> 00:22:34,320
right okay so that's that's true let's

00:22:32,799 --> 00:22:34,799
put in some debugging statements and

00:22:34,320 --> 00:22:37,360
figure

00:22:34,799 --> 00:22:40,559
exactly how the code is even used and

00:22:37,360 --> 00:22:42,640
why it exists in the first place

00:22:40,559 --> 00:22:44,080
here's one back trace and i'll admit it

00:22:42,640 --> 00:22:45,360
took me a little bit of time

00:22:44,080 --> 00:22:48,559
digging in here so we're just going to

00:22:45,360 --> 00:22:51,120
kind of jump to the fun part

00:22:48,559 --> 00:22:52,960
here in the back trace these methods are

00:22:51,120 --> 00:22:54,000
being called because we are generating a

00:22:52,960 --> 00:22:56,000
cache key

00:22:54,000 --> 00:22:57,520
so let's go ahead and we can open up

00:22:56,000 --> 00:22:59,440
this file

00:22:57,520 --> 00:23:00,880
if we follow the stack trace backwards

00:22:59,440 --> 00:23:02,960
you'll see that what is happening

00:23:00,880 --> 00:23:04,960
is activerecord is taking a string from

00:23:02,960 --> 00:23:06,559
the database and converting it into a

00:23:04,960 --> 00:23:08,080
time object that is then used to

00:23:06,559 --> 00:23:11,600
generate a cache

00:23:08,080 --> 00:23:15,440
version this is where it calls

00:23:11,600 --> 00:23:17,200
line 99 on the cache version method

00:23:15,440 --> 00:23:23,840
and here is the cache version method

00:23:17,200 --> 00:23:23,840
which is conveniently in the same file

00:23:24,080 --> 00:23:28,000
and here is our culprit what is

00:23:26,080 --> 00:23:28,880
happening is uh database adapters such

00:23:28,000 --> 00:23:31,440
as postgres

00:23:28,880 --> 00:23:31,919
don't actually return a time object in

00:23:31,440 --> 00:23:35,120
ruby

00:23:31,919 --> 00:23:37,039
instead it returns a string and

00:23:35,120 --> 00:23:38,640
then ruby or active record in this case

00:23:37,039 --> 00:23:41,039
will lazily cast it to the

00:23:38,640 --> 00:23:41,840
values that we need in this case our

00:23:41,039 --> 00:23:44,080
time method

00:23:41,840 --> 00:23:46,080
is being used to convert it into a time

00:23:44,080 --> 00:23:47,279
stamp and then that timestamp is being

00:23:46,080 --> 00:23:51,840
used to convert it back

00:23:47,279 --> 00:23:51,840
into a cache version string

00:23:54,080 --> 00:23:57,440
it means it might be possible to

00:23:55,919 --> 00:23:59,520
directly use the string

00:23:57,440 --> 00:24:00,880
rather than having to convert it into a

00:23:59,520 --> 00:24:02,320
time object first

00:24:00,880 --> 00:24:04,559
so here's what it looks like when it

00:24:02,320 --> 00:24:06,720
comes from our driver

00:24:04,559 --> 00:24:08,159
and here's what it looks like when we

00:24:06,720 --> 00:24:11,600
are generating the

00:24:08,159 --> 00:24:15,200
cash version format that we would like

00:24:11,600 --> 00:24:17,039
notice anything we can effectively just

00:24:15,200 --> 00:24:18,240
strip out the unwanted characters here

00:24:17,039 --> 00:24:21,360
and then we've got

00:24:18,240 --> 00:24:21,360
the exact same format

00:24:21,679 --> 00:24:27,120
does this allocation bring us

00:24:24,720 --> 00:24:27,120
joy

00:24:28,159 --> 00:24:32,640
let's take a look so is it useful yes

00:24:31,120 --> 00:24:35,760
caching is very useful

00:24:32,640 --> 00:24:39,200
uh is it fast enough i would say no

00:24:35,760 --> 00:24:41,919
it creates a lot of allocations uh

00:24:39,200 --> 00:24:43,440
unfortunately it is extremely clean the

00:24:41,919 --> 00:24:45,279
existing implementation is like

00:24:43,440 --> 00:24:48,080
one it's like half of one line it's not

00:24:45,279 --> 00:24:51,520
even a line

00:24:48,080 --> 00:24:53,440
so is it is it absolutely necessary well

00:24:51,520 --> 00:24:54,960
in our case it wasn't we can convert

00:24:53,440 --> 00:24:56,320
directly from the string we're getting

00:24:54,960 --> 00:24:57,440
from the database instead of having to

00:24:56,320 --> 00:24:59,039
do this

00:24:57,440 --> 00:25:01,760
conversion to a time object and then

00:24:59,039 --> 00:25:04,400
back so that's pretty expensive

00:25:01,760 --> 00:25:06,559
here's how we could do it differently

00:25:04,400 --> 00:25:09,679
bam

00:25:06,559 --> 00:25:11,520
my version of the code is complicated

00:25:09,679 --> 00:25:13,039
it's some got some guard statements it

00:25:11,520 --> 00:25:15,520
builds on existing code

00:25:13,039 --> 00:25:16,559
it adds cyclomatic complexity and a

00:25:15,520 --> 00:25:20,960
couple new methods

00:25:16,559 --> 00:25:22,720
so is my code cleaner absolutely not

00:25:20,960 --> 00:25:24,960
but does that mean that the old code

00:25:22,720 --> 00:25:25,760
spark joy just because my code is not

00:25:24,960 --> 00:25:27,440
clean

00:25:25,760 --> 00:25:29,200
well that depends on you and your

00:25:27,440 --> 00:25:30,880
judgment before we can decide

00:25:29,200 --> 00:25:32,559
let's take a look at the performance

00:25:30,880 --> 00:25:35,840
impact

00:25:32,559 --> 00:25:38,559
uh this patch reduced memory by

00:25:35,840 --> 00:25:40,320
five percent of total memory where

00:25:38,559 --> 00:25:43,039
previously the other patch only

00:25:40,320 --> 00:25:44,240
reduced memory by one percent so i'd say

00:25:43,039 --> 00:25:45,520
it is uh

00:25:44,240 --> 00:25:47,919
you know that's a that's a pretty big

00:25:45,520 --> 00:25:52,159
change um

00:25:47,919 --> 00:25:52,159
is did we reduce memory i'd say yes

00:25:52,640 --> 00:25:57,840
what about performance

00:25:59,919 --> 00:26:05,120
well it turns out that the conversion

00:26:03,440 --> 00:26:07,520
from a string to a time object is

00:26:05,120 --> 00:26:10,320
extremely cpu intensive

00:26:07,520 --> 00:26:12,480
and that making this change gives our

00:26:10,320 --> 00:26:16,400
application a performance bump of

00:26:12,480 --> 00:26:17,679
uh 1.12 x so going back to our example

00:26:16,400 --> 00:26:21,440
of 100 servers

00:26:17,679 --> 00:26:25,840
uh now we can get rid of 12 of them

00:26:21,440 --> 00:26:25,840
it's a little bit better

00:26:29,440 --> 00:26:34,080
i i thought so now we have to thank the

00:26:32,240 --> 00:26:35,440
old code that helped us for for so many

00:26:34,080 --> 00:26:38,400
years

00:26:35,440 --> 00:26:39,520
and we can get rid of it so with this

00:26:38,400 --> 00:26:41,760
optimization

00:26:39,520 --> 00:26:43,360
including the with these two

00:26:41,760 --> 00:26:45,440
optimizations i've shown as well as some

00:26:43,360 --> 00:26:48,559
other ones that i didn't quite have time

00:26:45,440 --> 00:26:49,720
uh to get around to i am seeing a total

00:26:48,559 --> 00:26:52,640
of

00:26:49,720 --> 00:26:54,080
1.23 x performance improvement in code

00:26:52,640 --> 00:26:57,440
triage which gives us

00:26:54,080 --> 00:26:59,840
a grand total of about 19

00:26:57,440 --> 00:27:01,760
fewer servers another way to look at

00:26:59,840 --> 00:27:03,440
this it's kind of like buying four

00:27:01,760 --> 00:27:07,840
servers

00:27:03,440 --> 00:27:07,840
and getting one free

00:27:08,559 --> 00:27:16,720
wow that is amazing

00:27:12,240 --> 00:27:16,720
so this technique is useful

00:27:17,200 --> 00:27:21,760
yes let's so first we're going to take

00:27:19,919 --> 00:27:25,360
all of our allocations and put them in

00:27:21,760 --> 00:27:25,360
one spot so that we can see them

00:27:25,600 --> 00:27:33,120
next we consider each does it spark joy

00:27:31,039 --> 00:27:35,840
finally we keep only the objects that

00:27:33,120 --> 00:27:35,840
spark joy

00:27:37,919 --> 00:27:41,679
hopefully i've convinced you that object

00:27:39,360 --> 00:27:42,960
allocation hotspots are a good indicator

00:27:41,679 --> 00:27:44,240
of where we can make performance

00:27:42,960 --> 00:27:46,080
optimizations

00:27:44,240 --> 00:27:47,840
and now you're ready to take some of

00:27:46,080 --> 00:27:51,360
these own techniques

00:27:47,840 --> 00:27:51,360
some of these techniques into your own

00:27:52,410 --> 00:27:58,619
[Music]

00:28:00,840 --> 00:28:04,000
code

00:28:02,320 --> 00:28:05,520
thank you very much uh my name is

00:28:04,000 --> 00:28:08,159
richard i

00:28:05,520 --> 00:28:10,240
go by schneems also special thanks to

00:28:08,159 --> 00:28:12,559
caleb thompson for all of the help with

00:28:10,240 --> 00:28:13,840
the slides or i would not be here uh and

00:28:12,559 --> 00:28:16,240
thank you for coming

00:28:13,840 --> 00:28:31,600
and uh enjoying and making yuruko what

00:28:16,240 --> 00:28:33,679
it is

00:28:31,600 --> 00:28:35,600
thank you so much schneemes we've

00:28:33,679 --> 00:28:39,840
plundered a little something for you

00:28:35,600 --> 00:28:39,840

YouTube URL: https://www.youtube.com/watch?v=Aczy01drwkg


