Title: "Node.js Releases" - View Source Conference talk by Myles Borins
Publication date: 2016-10-03
Playlist: View Source Berlin 2016
Description: 
	Node.js is growing up, and with that comes the responsibility of proper legacy support. As of Node.js Argon (v4.2.0) there is an official Long Term Support release cycle that lasts for 30 months!

How does a project moving at the pace of node maintain multiple release lines? How does a commit get backported? How is a release actually made? You will learn all this and more on this weeks episode of "Node.js Releases, how do they work?" 

View Source Berlin 12-14 September, 2016

 Myles Borins is a developer, musician, artist, and inventor. He works for IBM spending most of his time contributing to the node.js ecosystem
Follow Myles at @thealphanerd.
Captions: 
	00:00:06,660 --> 00:00:11,550
so my name is miles and

00:00:13,400 --> 00:00:19,039
called IBM my full-time job is

00:00:17,449 --> 00:00:20,000
contributing to the node.js platform

00:00:19,039 --> 00:00:22,880
we're going to talk a little bit today

00:00:20,000 --> 00:00:24,619
about what I do there but i do want to

00:00:22,880 --> 00:00:27,009
mention the you know are my opinions and

00:00:24,619 --> 00:00:32,449
not necessarily that of my employer

00:00:27,009 --> 00:00:35,089
subversions how do they work so versions

00:00:32,449 --> 00:00:37,820
are a lot like magnets and you know like

00:00:35,089 --> 00:00:41,030
stick with me on this that that versions

00:00:37,820 --> 00:00:42,230
are a lot like magnets mostly in the

00:00:41,030 --> 00:00:43,519
sense that pretty people are pretty

00:00:42,230 --> 00:00:44,839
confused about how they work we just

00:00:43,519 --> 00:00:47,269
kind of like you know we're like it

00:00:44,839 --> 00:00:51,140
works it sticks to something versions

00:00:47,269 --> 00:00:53,659
come out we don't need to know so like

00:00:51,140 --> 00:00:58,820
you know hashtag real talk this stuff is

00:00:53,659 --> 00:01:00,830
complicated this stuff is not super gras

00:00:58,820 --> 00:01:02,360
cable right away if you all have heard

00:01:00,830 --> 00:01:04,570
that term grok before i love it just

00:01:02,360 --> 00:01:08,630
like the ability to like internalize and

00:01:04,570 --> 00:01:10,220
understand something but so the great

00:01:08,630 --> 00:01:12,439
thing about computers is you actually

00:01:10,220 --> 00:01:13,909
don't need to understand everything and

00:01:12,439 --> 00:01:16,220
when you try to understand things that's

00:01:13,909 --> 00:01:17,630
like when it gets complicated you don't

00:01:16,220 --> 00:01:19,490
need to understand everything to

00:01:17,630 --> 00:01:22,340
contribute in a meaningful way you just

00:01:19,490 --> 00:01:23,780
need to know enough to be dangerous so

00:01:22,340 --> 00:01:25,370
you know like let's break this down and

00:01:23,780 --> 00:01:27,140
start from really small pieces and build

00:01:25,370 --> 00:01:30,350
it up and see how these complicated

00:01:27,140 --> 00:01:33,650
systems start coming together and we'll

00:01:30,350 --> 00:01:35,630
start with semantic versioning so I'm

00:01:33,650 --> 00:01:36,800
going to go out on a limb and assume

00:01:35,630 --> 00:01:39,400
that many of the people in the audience

00:01:36,800 --> 00:01:41,540
here have seen a version number before

00:01:39,400 --> 00:01:43,490
and versions are usually made up of

00:01:41,540 --> 00:01:45,530
three digits we have a first digit which

00:01:43,490 --> 00:01:47,360
is known as the major the second digit

00:01:45,530 --> 00:01:49,000
which is known as the minor and the

00:01:47,360 --> 00:01:51,590
third digit which is known as the patch

00:01:49,000 --> 00:01:53,060
I'm thinking about trying to push for a

00:01:51,590 --> 00:01:57,049
fourth digit which will be known as the

00:01:53,060 --> 00:01:59,330
marketing release digit but no one's

00:01:57,049 --> 00:02:03,760
been into that yet but so what's a patch

00:01:59,330 --> 00:02:07,880
and a patch is any change to a system

00:02:03,760 --> 00:02:10,640
that fixes a bug or updates a test any

00:02:07,880 --> 00:02:12,500
change that does not add new behavior

00:02:10,640 --> 00:02:14,989
and does not change old behavior and

00:02:12,500 --> 00:02:16,879
this is really important the idea with a

00:02:14,989 --> 00:02:18,709
patch is that someone should be able to

00:02:16,879 --> 00:02:20,450
take a patch updated version of software

00:02:18,709 --> 00:02:23,359
if they're consuming your software and

00:02:20,450 --> 00:02:25,279
update it and they're their code base

00:02:23,359 --> 00:02:25,790
should just get better they shouldn't

00:02:25,279 --> 00:02:27,530
have

00:02:25,790 --> 00:02:31,010
to make any changes and they shouldn't

00:02:27,530 --> 00:02:35,659
have to worry about stability what's a

00:02:31,010 --> 00:02:39,290
minor and so a minor is any time there

00:02:35,659 --> 00:02:42,349
is a new feature added to software you

00:02:39,290 --> 00:02:45,470
do a minor bump and node for example if

00:02:42,349 --> 00:02:48,019
we add new crypto a new way to do crypto

00:02:45,470 --> 00:02:50,060
that will come in a minor what a minor

00:02:48,019 --> 00:02:52,639
signifies and is important it's like hey

00:02:50,060 --> 00:02:54,739
the functionality of your code is not

00:02:52,639 --> 00:02:56,870
going to change but there's some new

00:02:54,739 --> 00:02:59,780
stuff and that new stuff may not be as

00:02:56,870 --> 00:03:02,269
stable as you may want for production so

00:02:59,780 --> 00:03:04,849
you generally can update to a minor

00:03:02,269 --> 00:03:07,280
release and still again like not worried

00:03:04,849 --> 00:03:10,310
about your production code having any

00:03:07,280 --> 00:03:12,169
problems but at the same time you may

00:03:10,310 --> 00:03:16,790
not want to jump on the bandwagon right

00:03:12,169 --> 00:03:19,519
away of using these new features so

00:03:16,790 --> 00:03:22,269
what's a major a major is any breaking

00:03:19,519 --> 00:03:25,370
change any change the change is

00:03:22,269 --> 00:03:27,500
fundamentally how the code works and

00:03:25,370 --> 00:03:30,260
we'll dig in a little bit more later in

00:03:27,500 --> 00:03:33,470
the talk to describe what major changes

00:03:30,260 --> 00:03:34,549
are a little bit more so in nodejs we

00:03:33,470 --> 00:03:38,299
have a number of different really

00:03:34,549 --> 00:03:40,250
streams we have current which is as of I

00:03:38,299 --> 00:03:42,470
think last week version six point five

00:03:40,250 --> 00:03:45,169
point zero which was super cool because

00:03:42,470 --> 00:03:46,430
we upgraded v8 in version 6 and again

00:03:45,169 --> 00:03:49,280
talk more about that afterwards and why

00:03:46,430 --> 00:03:51,379
that's so cool the current active LTS is

00:03:49,280 --> 00:03:54,409
version four point five point zero and

00:03:51,379 --> 00:03:57,620
then we have maintenance LTSs of version

00:03:54,409 --> 00:04:01,099
10 which is 10 46 and version 0 12 which

00:03:57,620 --> 00:04:02,720
is 12 15 everyone in the audience look

00:04:01,099 --> 00:04:06,340
at me and promise me that you will stop

00:04:02,720 --> 00:04:10,220
using them 10 and 12 are end of life

00:04:06,340 --> 00:04:12,590
very soon as of next month in October we

00:04:10,220 --> 00:04:14,449
will stop updating version 0 10 I know

00:04:12,590 --> 00:04:17,419
we've loved having it for as long as we

00:04:14,449 --> 00:04:18,949
have but is done in version 12 is going

00:04:17,419 --> 00:04:21,470
to be done in december and the reason

00:04:18,949 --> 00:04:23,120
for this isn't just because we don't

00:04:21,470 --> 00:04:26,300
like working on them which also might be

00:04:23,120 --> 00:04:28,280
the case but the version of openssl that

00:04:26,300 --> 00:04:29,870
they rely on is end of life for security

00:04:28,280 --> 00:04:31,940
updates and if any of you have been

00:04:29,870 --> 00:04:33,409
following security and open SSL you know

00:04:31,940 --> 00:04:35,719
that there are vulnerabilities sound all

00:04:33,409 --> 00:04:39,320
the time and it's an extremely dangerous

00:04:35,719 --> 00:04:41,510
attack vector on your servers so it's

00:04:39,320 --> 00:04:43,010
will no longer be safe to be running

00:04:41,510 --> 00:04:46,280
those versions of note and production

00:04:43,010 --> 00:04:47,990
after October in December so I really

00:04:46,280 --> 00:04:49,940
urge you to start trying to push to

00:04:47,990 --> 00:04:51,410
version four and we have a lot of

00:04:49,940 --> 00:04:55,460
resources available to help you do that

00:04:51,410 --> 00:04:57,590
if you're having problems so let's talk

00:04:55,460 --> 00:04:58,910
about what happened to version 1 through

00:04:57,590 --> 00:05:01,070
3 because you know I mentioned there was

00:04:58,910 --> 00:05:03,890
0 10 I mentioned there was 0 12 and then

00:05:01,070 --> 00:05:05,240
all of a sudden it went 2-4 and also

00:05:03,890 --> 00:05:07,580
like what's the deal was 0 12 because

00:05:05,240 --> 00:05:09,920
that one's kind of weird too so when

00:05:07,580 --> 00:05:14,300
node started it was done with an

00:05:09,920 --> 00:05:15,830
alternating release scheme so every even

00:05:14,300 --> 00:05:18,350
release was a stable release and every

00:05:15,830 --> 00:05:21,250
odd release was unstable so the way that

00:05:18,350 --> 00:05:24,020
worked is I started using node in 0.6

00:05:21,250 --> 00:05:26,530
0.6 was the stable branch if you were on

00:05:24,020 --> 00:05:29,060
0.6 you could trust that it would work

00:05:26,530 --> 00:05:30,590
0.7 was the unstable branch where things

00:05:29,060 --> 00:05:32,960
were constantly being updated and played

00:05:30,590 --> 00:05:35,210
with and changed when it was ready for a

00:05:32,960 --> 00:05:36,620
major bump which by the way in sember if

00:05:35,210 --> 00:05:38,870
you don't have a 1 in the first digit

00:05:36,620 --> 00:05:42,350
everything shifts over and you're minors

00:05:38,870 --> 00:05:44,330
our majors and your patches or minors

00:05:42,350 --> 00:05:45,530
and then you have no patches and this is

00:05:44,330 --> 00:05:47,660
a reason why it's a good idea to always

00:05:45,530 --> 00:05:49,100
start a project at one point 0 because

00:05:47,660 --> 00:05:51,290
you will never get to 1 point 0

00:05:49,100 --> 00:05:56,390
otherwise and you're losing like an

00:05:51,290 --> 00:05:59,300
entire it's just bad but so even with

00:05:56,390 --> 00:06:02,540
stable and odd was unstable and it

00:05:59,300 --> 00:06:05,000
started to take a really long time to

00:06:02,540 --> 00:06:06,560
bump from 0 10 20 12 and and by a long

00:06:05,000 --> 00:06:10,700
time i'm talking like more than two

00:06:06,560 --> 00:06:12,200
years and we didn't not only do we not

00:06:10,700 --> 00:06:14,720
know when we were going to move 20 12

00:06:12,200 --> 00:06:16,490
but we also didn't know when we would

00:06:14,720 --> 00:06:18,890
eventually hit one as I was just saying

00:06:16,490 --> 00:06:20,540
and so the note project was moving with

00:06:18,890 --> 00:06:23,420
this entire missing piece of granularity

00:06:20,540 --> 00:06:27,050
as far as how we could let people know

00:06:23,420 --> 00:06:29,660
where we're going and so in December

00:06:27,050 --> 00:06:32,180
2014 a number of contributors from the

00:06:29,660 --> 00:06:34,640
project forked and they released the

00:06:32,180 --> 00:06:36,410
fort as version one which it turns out

00:06:34,640 --> 00:06:37,940
is actually prepare semantic versioning

00:06:36,410 --> 00:06:39,500
there was a major change in the major

00:06:37,940 --> 00:06:43,040
change was it was a new project with new

00:06:39,500 --> 00:06:46,790
people version 0 12 was released

00:06:43,040 --> 00:06:48,140
februari 2015 right before node summit

00:06:46,790 --> 00:06:52,220
which was a conference that was held in

00:06:48,140 --> 00:06:53,220
San Francisco version 0 12 did not have

00:06:52,220 --> 00:06:55,590
a lot of the things that were

00:06:53,220 --> 00:06:58,200
happening in the i/o branches but it did

00:06:55,590 --> 00:07:00,960
have some new int L features and an

00:06:58,200 --> 00:07:02,430
upgraded v8 v8 is the JavaScript engine

00:07:00,960 --> 00:07:03,840
that's embedded in chrome and it's also

00:07:02,430 --> 00:07:05,610
the JavaScript engine that we use in

00:07:03,840 --> 00:07:07,770
node and that was another reason why the

00:07:05,610 --> 00:07:09,870
for cabin v8 hadn't been updated in a

00:07:07,770 --> 00:07:12,390
really long time when you want those new

00:07:09,870 --> 00:07:15,270
es6 language features those come with VA

00:07:12,390 --> 00:07:16,830
so when v8 doesn't get updated your vm

00:07:15,270 --> 00:07:20,640
isn't updated you're stuck on an old

00:07:16,830 --> 00:07:23,100
JavaScript and that's no fun so v1

00:07:20,640 --> 00:07:24,990
through v3 we're all part of the I ojs

00:07:23,100 --> 00:07:27,710
project and these were all updated

00:07:24,990 --> 00:07:30,330
constantly based on semantic versioning

00:07:27,710 --> 00:07:32,940
the project moved extremely quickly on

00:07:30,330 --> 00:07:35,460
in a short period of time moving from V

00:07:32,940 --> 00:07:37,830
1 to V 3 it was not about specific

00:07:35,460 --> 00:07:39,450
release cadences who is basically

00:07:37,830 --> 00:07:43,290
whatever had landed and master they just

00:07:39,450 --> 00:07:47,850
did a bump based on what made sense so

00:07:43,290 --> 00:07:49,560
in September 2015 known an i/o managed

00:07:47,850 --> 00:07:51,450
to have a merger and it was put into a

00:07:49,560 --> 00:07:54,150
foundation and when the project's merged

00:07:51,450 --> 00:07:58,500
they merged his version 4.0 point 0 and

00:07:54,150 --> 00:08:00,780
this was like a huge feet you know when

00:07:58,500 --> 00:08:02,640
the project was forced a forked a lot of

00:08:00,780 --> 00:08:07,200
people thought that it may not get past

00:08:02,640 --> 00:08:10,710
this the project may be over but you

00:08:07,200 --> 00:08:13,530
can't stop JavaScript so what you see

00:08:10,710 --> 00:08:15,780
above me is the node LTS release

00:08:13,530 --> 00:08:17,640
schedule there's a lot of information

00:08:15,780 --> 00:08:19,260
here so I'm going to try to walk you

00:08:17,640 --> 00:08:21,990
through it all but essentially breaks

00:08:19,260 --> 00:08:24,930
down how we do our release schema and

00:08:21,990 --> 00:08:26,550
how things are released so you'll notice

00:08:24,930 --> 00:08:28,950
there you can see 0 10 and where it

00:08:26,550 --> 00:08:31,200
stops in October you can see 0 12 and

00:08:28,950 --> 00:08:33,300
where it stops in December you can see

00:08:31,200 --> 00:08:35,669
master which is an unstable branch we

00:08:33,300 --> 00:08:38,520
can see version 4 version 4 was cut in

00:08:35,669 --> 00:08:40,710
August of 2015 and it was our current

00:08:38,520 --> 00:08:42,719
release for six months at the end of six

00:08:40,710 --> 00:08:45,089
months in October it rolled over into

00:08:42,719 --> 00:08:47,940
LTS and our LTS which is short for

00:08:45,089 --> 00:08:50,790
long-term support has a 30-month support

00:08:47,940 --> 00:08:52,980
cycle it has 18 months of active LTS

00:08:50,790 --> 00:08:55,170
which means we're actively back porting

00:08:52,980 --> 00:08:58,110
as many commits as possible from our

00:08:55,170 --> 00:09:00,839
active support lines into our LTS

00:08:58,110 --> 00:09:04,380
support lines after 18 months of active

00:09:00,839 --> 00:09:05,610
LTS it goes into maintenance and so

00:09:04,380 --> 00:09:06,540
let's talk a little bit more about that

00:09:05,610 --> 00:09:08,940
so current which

00:09:06,540 --> 00:09:12,260
you saw on there is the most active

00:09:08,940 --> 00:09:14,820
stream right now version 6 is current

00:09:12,260 --> 00:09:16,440
next month we're going to cut version 7

00:09:14,820 --> 00:09:20,220
version 7 will become current and

00:09:16,440 --> 00:09:22,470
version 6 will become LTS the current

00:09:20,220 --> 00:09:23,850
relief streams are done in an

00:09:22,470 --> 00:09:26,100
interesting way now it's somewhat

00:09:23,850 --> 00:09:29,430
similar to the old way of even and odd

00:09:26,100 --> 00:09:32,310
all even release streams will eventually

00:09:29,430 --> 00:09:36,390
move into LTS all odd release streams

00:09:32,310 --> 00:09:37,980
will not version 5 was the first odd

00:09:36,390 --> 00:09:39,240
release stream that we had so we weren't

00:09:37,980 --> 00:09:43,050
really sure how long it would keep

00:09:39,240 --> 00:09:45,120
moving after we bumped to version 6 and

00:09:43,050 --> 00:09:47,700
it turned out that after about two or

00:09:45,120 --> 00:09:49,920
three weeks the usage of version 5

00:09:47,700 --> 00:09:51,870
dropped by like ninety percent so in

00:09:49,920 --> 00:09:54,570
general if you're using things in

00:09:51,870 --> 00:09:57,660
production I would advise you to stay

00:09:54,570 --> 00:09:59,880
away from any uneven number relief

00:09:57,660 --> 00:10:02,730
streams unless it has features that you

00:09:59,880 --> 00:10:04,860
specifically need I would even generally

00:10:02,730 --> 00:10:06,660
advise you against using current early

00:10:04,860 --> 00:10:08,760
in the release stream cycle because

00:10:06,660 --> 00:10:10,050
things can be unstable one of the big

00:10:08,760 --> 00:10:12,630
differences about the current release

00:10:10,050 --> 00:10:14,700
over the LTS release streams is the

00:10:12,630 --> 00:10:17,310
current will take any sember minor and

00:10:14,700 --> 00:10:19,440
cember patch commits that are sitting on

00:10:17,310 --> 00:10:22,140
master and add them to the next release

00:10:19,440 --> 00:10:28,080
there's no baking there's no incubation

00:10:22,140 --> 00:10:30,750
stage for LTS active LTS we take any

00:10:28,080 --> 00:10:32,940
commit that has landed into master and

00:10:30,750 --> 00:10:34,950
then bid in a release and once it's been

00:10:32,940 --> 00:10:38,130
in a release for at least two weeks we

00:10:34,950 --> 00:10:39,450
can then back port it to LTS so that's

00:10:38,130 --> 00:10:41,520
one of the nice things about an active

00:10:39,450 --> 00:10:43,440
LTS line you know that every commit that

00:10:41,520 --> 00:10:45,180
landing in there has not only gone

00:10:43,440 --> 00:10:47,010
through our vetting process for getting

00:10:45,180 --> 00:10:48,720
landed we've gone through our testing

00:10:47,010 --> 00:10:50,370
and CI and smoke testing but it's also

00:10:48,720 --> 00:10:52,410
gone out and a release and lived in

00:10:50,370 --> 00:10:54,180
production for a number of weeks before

00:10:52,410 --> 00:10:56,130
we even baked it in and it doesn't mean

00:10:54,180 --> 00:10:58,740
we never break anything but it does mean

00:10:56,130 --> 00:11:00,330
that we're a lot better at it so I had

00:10:58,740 --> 00:11:02,720
mentioned maintenance LTS which is a

00:11:00,330 --> 00:11:05,040
little bit slower than active LTS

00:11:02,720 --> 00:11:07,260
maintenance LTS is the 12 months after

00:11:05,040 --> 00:11:09,060
active and the primary purpose of it is

00:11:07,260 --> 00:11:11,880
to make sure that your systems that are

00:11:09,060 --> 00:11:13,530
running on LTS are going to have extreme

00:11:11,880 --> 00:11:15,960
security vulnerabilities and extreme

00:11:13,530 --> 00:11:18,060
breakage is covered so after the active

00:11:15,960 --> 00:11:19,860
period you'll have another year where

00:11:18,060 --> 00:11:21,870
the LTS branch will have all made

00:11:19,860 --> 00:11:24,329
security updates and all major bugs

00:11:21,870 --> 00:11:25,680
hatched and updated for you in a way

00:11:24,329 --> 00:11:27,480
that should not change any of the

00:11:25,680 --> 00:11:29,730
functionality now sometimes with

00:11:27,480 --> 00:11:32,550
security fixes we can't avoid that so

00:11:29,730 --> 00:11:34,890
there were some recent security fixes we

00:11:32,550 --> 00:11:36,420
have to do to our HTTP library that

00:11:34,890 --> 00:11:39,630
involved what would be arguably

00:11:36,420 --> 00:11:41,519
assembler major change but unfortunately

00:11:39,630 --> 00:11:43,680
sometimes for the sake of safety we

00:11:41,519 --> 00:11:45,390
can't exactly follow cember but for the

00:11:43,680 --> 00:11:46,440
most part what is good about this if you

00:11:45,390 --> 00:11:48,029
have an app and you're putting it in

00:11:46,440 --> 00:11:49,649
production and it's something that you

00:11:48,029 --> 00:11:51,959
aren't going to need to change or touch

00:11:49,649 --> 00:11:54,810
too much you know that you can rely on

00:11:51,959 --> 00:11:56,850
an LTS branch for three years from the

00:11:54,810 --> 00:12:01,950
time in which it's cut until the time in

00:11:56,850 --> 00:12:04,470
which it's done so what about master

00:12:01,950 --> 00:12:06,180
master is this really amazing beautiful

00:12:04,470 --> 00:12:08,730
thing that everything just lands on

00:12:06,180 --> 00:12:10,769
wheel and absolutely everything into

00:12:08,730 --> 00:12:12,600
master and then we use it as a source of

00:12:10,769 --> 00:12:16,769
truth for grabbing things to other

00:12:12,600 --> 00:12:17,730
branches what happened to stable so I

00:12:16,769 --> 00:12:19,140
don't know how many of you have been

00:12:17,730 --> 00:12:21,660
following our release cycles really

00:12:19,140 --> 00:12:23,430
closely but for a little while we had a

00:12:21,660 --> 00:12:26,070
relief stream called stable it's now

00:12:23,430 --> 00:12:28,410
called current we found that like in the

00:12:26,070 --> 00:12:30,420
verbal contract between us and the

00:12:28,410 --> 00:12:32,160
people that use node that that wasn't

00:12:30,420 --> 00:12:33,959
exactly fair because stable seems to

00:12:32,160 --> 00:12:36,209
imply hey things aren't going to break

00:12:33,959 --> 00:12:39,180
and as I was saying with cember made the

00:12:36,209 --> 00:12:40,829
same cember minor changes we're not

00:12:39,180 --> 00:12:42,449
necessary we're not necessarily

00:12:40,829 --> 00:12:44,519
guaranteed that things that come into a

00:12:42,449 --> 00:12:46,290
current branch are going to be stable so

00:12:44,519 --> 00:12:47,970
we changed the name so if you hadn't

00:12:46,290 --> 00:12:50,399
heard about the term stable before just

00:12:47,970 --> 00:12:52,890
slide just ignore it take it out of your

00:12:50,399 --> 00:12:54,329
head you don't need to remember that but

00:12:52,890 --> 00:12:57,899
yeah so how the heck do we manage all of

00:12:54,329 --> 00:13:01,079
this it's a lot of stuff and magic is is

00:12:57,899 --> 00:13:04,110
mostly but more accurately get magic

00:13:01,079 --> 00:13:08,420
because get is magic and it's magic with

00:13:04,110 --> 00:13:12,149
trees and that basically makes us elves

00:13:08,420 --> 00:13:15,120
but we maintain release branches so for

00:13:12,149 --> 00:13:19,500
every release stream we have a branch X

00:13:15,120 --> 00:13:21,660
so we have 20 10 X Y or 12 X 4 X 5 X 6 X

00:13:19,500 --> 00:13:25,220
each of these branches are at the head

00:13:21,660 --> 00:13:27,899
of the last release in which we've done

00:13:25,220 --> 00:13:30,400
when we're ready to make a new current

00:13:27,899 --> 00:13:34,540
release we branched off

00:13:30,400 --> 00:13:36,700
dot X and we cherry commit we cherry

00:13:34,540 --> 00:13:38,860
pick commits from master onto it we're

00:13:36,700 --> 00:13:41,200
actually in the process of changing this

00:13:38,860 --> 00:13:44,040
release process to more mature LTS

00:13:41,200 --> 00:13:46,540
release process so that things can be

00:13:44,040 --> 00:13:48,790
you know more the same between different

00:13:46,540 --> 00:13:50,080
stuff and also to avoid conflicts and if

00:13:48,790 --> 00:13:51,550
you're interested in hearing more about

00:13:50,080 --> 00:13:55,360
that come and grab me afterwards and

00:13:51,550 --> 00:13:56,710
i'll tell you more for LTS and soon for

00:13:55,360 --> 00:13:59,740
current as well we maintain staging

00:13:56,710 --> 00:14:02,530
branches so as changes are audited and

00:13:59,740 --> 00:14:04,590
are signed off on for LTS they get

00:14:02,530 --> 00:14:07,960
cherry picked on to the staging branch

00:14:04,590 --> 00:14:09,550
then when we're ready for a release and

00:14:07,960 --> 00:14:11,560
as I said before those are changes that

00:14:09,550 --> 00:14:12,550
live for at least a week and when

00:14:11,560 --> 00:14:15,370
they're ready for release we do

00:14:12,550 --> 00:14:18,970
something like this so we've got staging

00:14:15,370 --> 00:14:20,770
here and I can check out before point X

00:14:18,970 --> 00:14:22,770
can everyone read that scream enhance if

00:14:20,770 --> 00:14:27,520
you need a bigger all right we're good

00:14:22,770 --> 00:14:29,440
okay how's that is that enhanced so we

00:14:27,520 --> 00:14:32,650
can check out a new branch here called v

00:14:29,440 --> 00:14:34,480
four point five point one proposal so we

00:14:32,650 --> 00:14:35,890
have a new proposal Brent rich and we

00:14:34,480 --> 00:14:39,730
can use a tool and i'll talk more about

00:14:35,890 --> 00:14:42,360
it after called branch diff and we can

00:14:39,730 --> 00:14:45,220
see hey what's the difference between

00:14:42,360 --> 00:14:46,870
this branch and the staging branch and

00:14:45,220 --> 00:14:49,060
we see all these commits that are

00:14:46,870 --> 00:14:50,860
different and so we can go and we can

00:14:49,060 --> 00:14:53,350
say you know we want the format of shaw

00:14:50,860 --> 00:14:58,270
so we just want the sha-1 reverse and we

00:14:53,350 --> 00:15:00,850
can pipe it to xargs git cherry-pick and

00:14:58,270 --> 00:15:02,110
this is some fun typing stuff and you

00:15:00,850 --> 00:15:04,090
know we see all this stuff go through

00:15:02,110 --> 00:15:06,370
and now we've just made a release branch

00:15:04,090 --> 00:15:07,810
4v four point five point one using all

00:15:06,370 --> 00:15:09,280
the commits that have been staged in our

00:15:07,810 --> 00:15:11,920
staging and so the reason why these

00:15:09,280 --> 00:15:13,090
staging branches are really great is now

00:15:11,920 --> 00:15:14,740
on the day that we're ready to do a

00:15:13,090 --> 00:15:16,390
release or the day before release when

00:15:14,740 --> 00:15:18,340
we want to start testing it we're not

00:15:16,390 --> 00:15:20,470
going to be blocked by silly things like

00:15:18,340 --> 00:15:22,480
merge conflicts the staging branch is

00:15:20,470 --> 00:15:24,040
where we can go and take commit and make

00:15:22,480 --> 00:15:26,440
sure that they're not going to cause a

00:15:24,040 --> 00:15:29,260
problem i talked about like how we

00:15:26,440 --> 00:15:30,250
actually go about landing commits so i'm

00:15:29,260 --> 00:15:35,140
going to show you a little bit about how

00:15:30,250 --> 00:15:36,970
that process works so here's node and

00:15:35,140 --> 00:15:38,590
again if things are too small just

00:15:36,970 --> 00:15:42,360
scream out enhance that's the only time

00:15:38,590 --> 00:15:42,360
when i'm going to the Internet's down

00:15:45,400 --> 00:15:54,920
okay so let's pretend so what i would do

00:15:52,370 --> 00:15:57,350
is i would go to an issue and i would go

00:15:54,920 --> 00:15:59,450
and grab the commit are we still down

00:15:57,350 --> 00:16:01,190
okay so i'll come back to this demo and

00:15:59,450 --> 00:16:03,980
a little bit if the internet comes back

00:16:01,190 --> 00:16:05,690
but i was going to patch a note live for

00:16:03,980 --> 00:16:08,540
you and maybe we can do that in a little

00:16:05,690 --> 00:16:09,950
bit but so when we're ready for an LTS

00:16:08,540 --> 00:16:12,110
releases always saying we branch off of

00:16:09,950 --> 00:16:15,080
four point X and we cherry kit cherry

00:16:12,110 --> 00:16:17,390
pick two commits from staging so how do

00:16:15,080 --> 00:16:19,580
we know which commits to cherry pick and

00:16:17,390 --> 00:16:21,620
so this is what I was talking about with

00:16:19,580 --> 00:16:23,930
that tool we use github labels and

00:16:21,620 --> 00:16:25,970
that's what the tool runs off of all of

00:16:23,930 --> 00:16:27,890
our poll requests have labels some of

00:16:25,970 --> 00:16:30,170
them are cember major some of them are

00:16:27,890 --> 00:16:31,520
some ver minor if they're commits that

00:16:30,170 --> 00:16:33,260
we think need to be back boarded to

00:16:31,520 --> 00:16:35,000
specific streams will add an LTS watch

00:16:33,260 --> 00:16:36,470
label to it and if there are commits

00:16:35,000 --> 00:16:38,630
that definitely shouldn't be uncertain

00:16:36,470 --> 00:16:41,510
streams will add don't land so one would

00:16:38,630 --> 00:16:44,540
be LTS watch v4 point x1 we don't land

00:16:41,510 --> 00:16:46,640
v4 point X and then we have a bunch of

00:16:44,540 --> 00:16:49,310
tools so the tool that you saw me using

00:16:46,640 --> 00:16:50,900
was a tool called branched if branched

00:16:49,310 --> 00:16:54,740
if is a really unique way of handling

00:16:50,900 --> 00:16:56,870
gifts with get when you do a git diff

00:16:54,740 --> 00:17:00,320
between two branches it's comparing the

00:16:56,870 --> 00:17:02,360
trees so one get tree and another get

00:17:00,320 --> 00:17:04,040
tree it will see if they're the same and

00:17:02,360 --> 00:17:06,320
it will tell you what the differences

00:17:04,040 --> 00:17:09,920
are between the trees but we're actually

00:17:06,320 --> 00:17:11,360
interested in more is atomic units of

00:17:09,920 --> 00:17:14,020
change but not what happened in the

00:17:11,360 --> 00:17:16,280
atomic unit of change we want to see

00:17:14,020 --> 00:17:17,780
every single commit and we want to

00:17:16,280 --> 00:17:20,030
compare their messages and their

00:17:17,780 --> 00:17:22,790
metadata to see if they exist on two

00:17:20,030 --> 00:17:24,140
streams because the commit on master can

00:17:22,790 --> 00:17:26,060
actually end up being very different

00:17:24,140 --> 00:17:27,589
than the commit on version 6 which can

00:17:26,060 --> 00:17:29,570
also end up being very different than

00:17:27,589 --> 00:17:30,740
the commit on version 4 so we want to

00:17:29,570 --> 00:17:33,290
make sure that we have all the same

00:17:30,740 --> 00:17:36,440
atomic units of change but not

00:17:33,290 --> 00:17:38,090
necessarily the exact same get trees so

00:17:36,440 --> 00:17:40,940
branched if is able to use a combination

00:17:38,090 --> 00:17:43,820
of metadata comparison as well as labels

00:17:40,940 --> 00:17:46,340
from github to let us know which commits

00:17:43,820 --> 00:17:47,990
are missing so when you saw me do branch

00:17:46,340 --> 00:17:50,570
diff here and maybe doing that actually

00:17:47,990 --> 00:17:52,820
took down the internet it was able to

00:17:50,570 --> 00:17:54,630
give us a list of hey here are all the

00:17:52,820 --> 00:17:57,730
commits

00:17:54,630 --> 00:17:59,320
that aren't on this stream and we can

00:17:57,730 --> 00:18:00,730
use that to figure out what we need to

00:17:59,320 --> 00:18:02,980
land so when I'm ready to do a new

00:18:00,730 --> 00:18:05,289
release of version 4 I can go into a

00:18:02,980 --> 00:18:07,330
branch diff between staging and master

00:18:05,289 --> 00:18:08,740
and just have a big list of all the

00:18:07,330 --> 00:18:10,000
commits that haven't been audited yet

00:18:08,740 --> 00:18:12,100
and I can go through those and make sure

00:18:10,000 --> 00:18:13,710
that we get everything we need we have

00:18:12,100 --> 00:18:15,909
another tool called changelog maker

00:18:13,710 --> 00:18:17,409
that's really great when we want to go

00:18:15,909 --> 00:18:19,630
and make our change logs that can go

00:18:17,409 --> 00:18:21,400
through and take the diffs it puts it a

00:18:19,630 --> 00:18:23,679
markdown it can organize it for you and

00:18:21,400 --> 00:18:26,289
every time we make a change login node

00:18:23,679 --> 00:18:27,970
we use the changelog maker both of these

00:18:26,289 --> 00:18:30,100
are tools you can install with NPM and

00:18:27,970 --> 00:18:31,480
both both of these are tools that you

00:18:30,100 --> 00:18:33,340
can use on your own projects if you're

00:18:31,480 --> 00:18:34,990
interested in having that in your

00:18:33,340 --> 00:18:38,230
workflow we have a number of different

00:18:34,990 --> 00:18:41,490
scripts as well that we use for for

00:18:38,230 --> 00:18:44,909
building all the assets and deploying

00:18:41,490 --> 00:18:44,909
this is a good one

00:18:48,179 --> 00:18:54,809
so what's a breaking change this is the

00:18:52,590 --> 00:18:57,210
biggest thing a breaking changes anytime

00:18:54,809 --> 00:18:58,919
there's a change in behavior and that

00:18:57,210 --> 00:19:01,769
seems really obvious like if you switch

00:18:58,919 --> 00:19:03,809
to variables in a function that's pretty

00:19:01,769 --> 00:19:05,820
obvious breaking change but sometimes

00:19:03,809 --> 00:19:07,320
making changes can be a lot more subtle

00:19:05,820 --> 00:19:09,899
than that and you have to create a lot

00:19:07,320 --> 00:19:12,840
of infrastructure in order to test why

00:19:09,899 --> 00:19:15,600
things are breaking so how do we in the

00:19:12,840 --> 00:19:17,570
node project avoid breaking changes one

00:19:15,600 --> 00:19:21,029
way of CI we have a pretty extensive

00:19:17,570 --> 00:19:22,440
testing suite and we have CI running for

00:19:21,029 --> 00:19:25,619
all of the different architectures that

00:19:22,440 --> 00:19:29,059
we released too so we test on debian we

00:19:25,619 --> 00:19:36,210
test on a bun two we test on fedora bsd

00:19:29,059 --> 00:19:38,220
solaris windows mac arm multiple flavors

00:19:36,210 --> 00:19:41,369
of arm so we have all of these different

00:19:38,220 --> 00:19:43,409
operating systems architectures that

00:19:41,369 --> 00:19:44,940
we're building and testing on every time

00:19:43,409 --> 00:19:47,429
we want to make a change but that

00:19:44,940 --> 00:19:50,159
doesn't catch everything we also do

00:19:47,429 --> 00:19:52,019
something called smoke testing so

00:19:50,159 --> 00:19:54,059
there's this utility that I created

00:19:52,019 --> 00:19:56,429
called canary in the gold mining well it

00:19:54,059 --> 00:19:57,990
was actually created by James no my

00:19:56,429 --> 00:19:59,129
mentor at IBM but I carried through a

00:19:57,990 --> 00:20:01,080
lot of the work on the project and

00:19:59,129 --> 00:20:03,629
carrying the gold mine will go and grab

00:20:01,080 --> 00:20:05,610
an NPM module it will NPM install it and

00:20:03,629 --> 00:20:08,759
then run mtm test and then give you the

00:20:05,610 --> 00:20:10,289
output and so we have a list of 70 of

00:20:08,759 --> 00:20:12,990
the top used modules in the ecosystem

00:20:10,289 --> 00:20:14,549
and we can run sit game on that every

00:20:12,990 --> 00:20:16,679
time we want to make big changes or

00:20:14,549 --> 00:20:18,269
periodically against our branches and

00:20:16,679 --> 00:20:20,129
see if we're breaking things in the

00:20:18,269 --> 00:20:21,539
ecosystem and the nice thing about this

00:20:20,129 --> 00:20:23,700
is everyone's code that's using your

00:20:21,539 --> 00:20:25,200
code that has unit tests are essentially

00:20:23,700 --> 00:20:27,769
writing integration tests for you so you

00:20:25,200 --> 00:20:30,299
may as well just run them automated so

00:20:27,769 --> 00:20:31,769
in February we found these two

00:20:30,299 --> 00:20:34,619
interesting breakages that I want to

00:20:31,769 --> 00:20:36,119
share with you one in Jade which many of

00:20:34,619 --> 00:20:37,710
you may know is a templating language

00:20:36,119 --> 00:20:40,940
that's really awesome and the other

00:20:37,710 --> 00:20:44,009
embody parser and body parser is the

00:20:40,940 --> 00:20:46,350
embedded body parser and Express Express

00:20:44,009 --> 00:20:48,929
is used a lot body parsers used a lot we

00:20:46,350 --> 00:20:50,909
don't want to break that so it turned

00:20:48,929 --> 00:20:52,139
out Jade had to change the name to pug

00:20:50,909 --> 00:20:54,749
and they didn't know update their

00:20:52,139 --> 00:20:56,730
package.json so that broke our algorithm

00:20:54,749 --> 00:20:59,530
for grabbing tar balls so we sent a pull

00:20:56,730 --> 00:21:04,520
request and that was pretty quick

00:20:59,530 --> 00:21:10,060
but how how body parser broke was pretty

00:21:04,520 --> 00:21:14,750
subtle so we had some extra logic added

00:21:10,060 --> 00:21:17,090
into query string parse its using string

00:21:14,750 --> 00:21:19,400
split inside to break apart all the

00:21:17,090 --> 00:21:21,470
query strings and we were doing a

00:21:19,400 --> 00:21:23,120
comparison between the length of the of

00:21:21,470 --> 00:21:25,240
the array and the max length that was

00:21:23,120 --> 00:21:27,230
passed and just shortening the array

00:21:25,240 --> 00:21:29,030
that was the way we did it originally

00:21:27,230 --> 00:21:30,920
and that creates a lot of garbage so

00:21:29,030 --> 00:21:32,390
someone submitted a pull request that

00:21:30,920 --> 00:21:35,240
went through and just passed the

00:21:32,390 --> 00:21:37,040
argument of max length to the call to

00:21:35,240 --> 00:21:38,750
split and you know like that's a pretty

00:21:37,040 --> 00:21:41,510
great idea it speeds up a whole bunch of

00:21:38,750 --> 00:21:43,640
stuff and creates less garbage and

00:21:41,510 --> 00:21:47,510
that's the that's the change you can't

00:21:43,640 --> 00:21:52,010
really see it but so something really

00:21:47,510 --> 00:21:54,050
weird happened with infinity so before

00:21:52,010 --> 00:21:56,180
the change if you required query string

00:21:54,050 --> 00:21:58,700
parse and you parts to string and you

00:21:56,180 --> 00:22:02,330
gave max Keys length of infinity you

00:21:58,700 --> 00:22:05,180
would get the expected length after the

00:22:02,330 --> 00:22:07,400
change it would always give back 0 this

00:22:05,180 --> 00:22:09,650
is completely unexpected it turns out

00:22:07,400 --> 00:22:11,180
that query string parse the second

00:22:09,650 --> 00:22:14,320
argument is expected to be an integer

00:22:11,180 --> 00:22:17,660
when you pass infinity infinity gets

00:22:14,320 --> 00:22:20,000
cast as an integer and it turns out by

00:22:17,660 --> 00:22:22,420
the spec infinity as an integer is 0

00:22:20,000 --> 00:22:27,530
which mathematically is more correct but

00:22:22,420 --> 00:22:29,360
obviously it didn't work out so smoke

00:22:27,530 --> 00:22:31,670
testing saved the day we were able to go

00:22:29,360 --> 00:22:34,820
and take there was a single unit test in

00:22:31,670 --> 00:22:37,040
body parser that tested infinity as as

00:22:34,820 --> 00:22:39,080
an option there it was an edge case we

00:22:37,040 --> 00:22:41,480
didn't test in core so we missed that we

00:22:39,080 --> 00:22:42,920
broke it but none of you have to know

00:22:41,480 --> 00:22:45,110
about that because we found out about

00:22:42,920 --> 00:22:47,090
this before release we patched it and

00:22:45,110 --> 00:22:50,870
fixed it before release and smoke

00:22:47,090 --> 00:22:54,650
testing save the day so as I said the

00:22:50,870 --> 00:22:56,270
change wasn't our master yet so there's

00:22:54,650 --> 00:22:59,000
all sorts of weird things the canary in

00:22:56,270 --> 00:23:00,740
the gold mine is found come and grab me

00:22:59,000 --> 00:23:02,030
if you want to find out more I have a

00:23:00,740 --> 00:23:03,740
diary that I've been keeping and

00:23:02,030 --> 00:23:05,390
actually on thursday i'll be giving a

00:23:03,740 --> 00:23:07,400
talk in amsterdam at node interactive

00:23:05,390 --> 00:23:09,410
all about this and if you're not going

00:23:07,400 --> 00:23:09,960
to be there the video will eventually be

00:23:09,410 --> 00:23:12,090
online

00:23:09,960 --> 00:23:15,270
and just keep bugging me on Twitter and

00:23:12,090 --> 00:23:18,169
I'll let you know when it's available so

00:23:15,270 --> 00:23:21,419
to wrap up which version should you use

00:23:18,169 --> 00:23:24,059
at the moment v4 point X but I mean

00:23:21,419 --> 00:23:27,649
version 6 going into LTS next month so

00:23:24,059 --> 00:23:30,480
that's not a bad choice either but why

00:23:27,649 --> 00:23:33,390
longest support cycle closest to master

00:23:30,480 --> 00:23:34,620
of LTS recent releases currently in the

00:23:33,390 --> 00:23:40,799
least likely to break your app in

00:23:34,620 --> 00:23:42,120
production do you have to know I mean

00:23:40,799 --> 00:23:44,250
like do whatever you want that's totally

00:23:42,120 --> 00:23:46,799
cool we need people running on the

00:23:44,250 --> 00:23:50,789
bleeding edge to just you know if you're

00:23:46,799 --> 00:23:51,840
going to run v6 it comes with v8 5.1 as

00:23:50,789 --> 00:23:53,760
I was mentioning which is like

00:23:51,840 --> 00:23:55,980
ninety-eight percent of es6 features

00:23:53,760 --> 00:23:57,840
it's going to be LTS in about a month

00:23:55,980 --> 00:23:59,940
totally makes sense to run on that

00:23:57,840 --> 00:24:02,700
should you run v7 in production when we

00:23:59,940 --> 00:24:04,620
when we release it next month i would

00:24:02,700 --> 00:24:06,840
say probably not but also like I mean

00:24:04,620 --> 00:24:10,320
cool if you want to and you you're ready

00:24:06,840 --> 00:24:13,860
for firefights so as I was saying next

00:24:10,320 --> 00:24:16,260
next month v6 will be LTS so that's

00:24:13,860 --> 00:24:17,640
pretty awesome we updated the v8 in it

00:24:16,260 --> 00:24:21,149
grab me if you want to hear more about

00:24:17,640 --> 00:24:22,470
that and be prepared for breakages if

00:24:21,149 --> 00:24:25,409
you're an early adopter is kind of the

00:24:22,470 --> 00:24:26,789
only warning that i can give you thank

00:24:25,409 --> 00:24:29,510
you very much i leave you with the best

00:24:26,789 --> 00:24:29,510

YouTube URL: https://www.youtube.com/watch?v=JOR2ne84QQg


