Title: "Things You Can Do In ES6 That Can't Be Done In ES5" - View Source talk by Dan Shappir
Publication date: 2016-10-03
Playlist: View Source Berlin 2016
Description: 
	ES6 and ES7 introduce many new features and capabilities to the JavaScript language. And yet, the majority of these enhancements are essentially syntactic sugar over the previous version. This is why tools like Babel are able to convert ES6 code into ES5. But there are several new features that can't be implemented in ES5.

In this session I'll explain what these new features are, what they do, and why they were added to the language. 

View Source Berlin 12-14 September, 2016

 Dan Shappir is a Performance Specialist at Wix.com, focusing on making +80 million sites hosted on the Wix platform load and execute faster. Dan is a twenty year software development veteran, having worked on systems ranging from missile trajectory simulations to networked multi-user games to designing and building Rich Web Apps, since even before AJAX. Dan holds an M.Sc. in Computer Science, and has spoken at various technical conferences.
Follow Dan at @danshappir.
Captions: 
	00:00:07,279 --> 00:00:10,200
today I'm going to talk about things

00:00:08,840 --> 00:00:12,420
that are in the future I'm going

00:00:10,200 --> 00:00:15,660
about things that you can do with es6

00:00:12,420 --> 00:00:18,840
that can't be done with es5 and before I

00:00:15,660 --> 00:00:21,390
begin I would like to define what I mean

00:00:18,840 --> 00:00:23,430
by year six in this context so when I

00:00:21,390 --> 00:00:26,640
say es6 throughout this presentation

00:00:23,430 --> 00:00:29,250
what I actually mean are any post es5

00:00:26,640 --> 00:00:32,550
features that are either part of a

00:00:29,250 --> 00:00:35,190
standard like es 2015 or very close to

00:00:32,550 --> 00:00:37,110
being standardized so as less as well

00:00:35,190 --> 00:00:39,930
said before my name is Dan Dan Shapiro

00:00:37,110 --> 00:00:42,960
and I'm with Wix you can see my email if

00:00:39,930 --> 00:00:45,930
you feel like email me you may email me

00:00:42,960 --> 00:00:49,380
me about anything you also have my

00:00:45,930 --> 00:00:51,329
Twitter handle and in fact this whole

00:00:49,380 --> 00:00:53,130
presentation really started out as a

00:00:51,329 --> 00:00:55,590
tweet one of the things that I

00:00:53,130 --> 00:00:58,170
occasionally like to do on Twitter is

00:00:55,590 --> 00:01:02,070
tweet a JavaScript riddle that's kind of

00:00:58,170 --> 00:01:04,739
my idea of geeky fun and a riddle that I

00:01:02,070 --> 00:01:07,560
posted several months ago was exactly

00:01:04,739 --> 00:01:09,990
the topic of this presentation it was

00:01:07,560 --> 00:01:13,530
what things that you can do with es6

00:01:09,990 --> 00:01:16,289
that can't be done with es5 and it turns

00:01:13,530 --> 00:01:18,270
out that even though many JavaScript

00:01:16,289 --> 00:01:21,689
developers are already fairly familiar

00:01:18,270 --> 00:01:23,759
with es6 not a lot of people knew the

00:01:21,689 --> 00:01:25,979
answers to that and i think that the

00:01:23,759 --> 00:01:29,969
reason for that is that when we look at

00:01:25,979 --> 00:01:33,270
es6 it's mostly about being set at ik

00:01:29,969 --> 00:01:35,700
sugar on top of es 5 that means that

00:01:33,270 --> 00:01:38,819
it's it basically it's the same feature

00:01:35,700 --> 00:01:40,979
set but much more accessible much more

00:01:38,819 --> 00:01:43,679
friendly to to human beings to people

00:01:40,979 --> 00:01:45,719
rather than to computers now that's not

00:01:43,679 --> 00:01:47,399
necessarily a bad thing in fact from my

00:01:45,719 --> 00:01:50,999
opinion it's very much a good thing

00:01:47,399 --> 00:01:52,799
because with programming languages you

00:01:50,999 --> 00:01:54,689
definitely want the syntax to be

00:01:52,799 --> 00:01:57,359
friendly you really want to be more

00:01:54,689 --> 00:01:59,249
about the what rather than the how and

00:01:57,359 --> 00:02:02,700
you want the syntax to be more

00:01:59,249 --> 00:02:04,439
expressive and more concise because of

00:02:02,700 --> 00:02:06,630
fewer lines that we write the fewer bugs

00:02:04,439 --> 00:02:09,300
that we generally have and here are a

00:02:06,630 --> 00:02:11,910
few interesting obvious examples look at

00:02:09,300 --> 00:02:13,560
this piece of code it's obviously you

00:02:11,910 --> 00:02:15,510
know

00:02:13,560 --> 00:02:18,209
very simplistic at not necessarily a

00:02:15,510 --> 00:02:20,130
real code but it actually includes parts

00:02:18,209 --> 00:02:22,980
of code that you would find in typical

00:02:20,130 --> 00:02:24,720
es JavaScript applications and here is

00:02:22,980 --> 00:02:26,430
the same piece of code written

00:02:24,720 --> 00:02:28,800
essentially the same piece of code

00:02:26,430 --> 00:02:31,280
written with es6 we immediately

00:02:28,800 --> 00:02:33,890
immediately see that it's much shorter

00:02:31,280 --> 00:02:37,319
but beyond that it's more declarative

00:02:33,890 --> 00:02:39,840
for example the default value for the

00:02:37,319 --> 00:02:42,630
parameters bar and the parameter in

00:02:39,840 --> 00:02:45,060
itself is actually part of the function

00:02:42,630 --> 00:02:47,519
signature rather than being expressed

00:02:45,060 --> 00:02:49,260
within the code so somebody looking at

00:02:47,519 --> 00:02:51,090
the function signature immediately knows

00:02:49,260 --> 00:02:52,739
what the defaults are and even the

00:02:51,090 --> 00:02:54,900
development environment can know what

00:02:52,739 --> 00:02:56,940
the defaults are and presented to

00:02:54,900 --> 00:03:01,350
somebody who's using this function and

00:02:56,940 --> 00:03:03,690
also in fact the es6 implementation is

00:03:01,350 --> 00:03:05,310
actually more correct than the es5

00:03:03,690 --> 00:03:07,800
implementation and it's an interesting

00:03:05,310 --> 00:03:10,769
exercise to you to find out where that

00:03:07,800 --> 00:03:13,230
is where there's a small bug hiding in

00:03:10,769 --> 00:03:17,280
the es5 implementation that doesn't

00:03:13,230 --> 00:03:19,140
happen in the es6 implementation there

00:03:17,280 --> 00:03:22,530
are other additional syntactic sugar

00:03:19,140 --> 00:03:25,769
features that aren't that obvious in es6

00:03:22,530 --> 00:03:27,930
for example classes I don't know if you

00:03:25,769 --> 00:03:29,850
know this but classes are implemented

00:03:27,930 --> 00:03:32,760
completely on top of the prototypical

00:03:29,850 --> 00:03:36,420
mechanism that underlies the JavaScript

00:03:32,760 --> 00:03:39,329
inheritance mechanism so if you take

00:03:36,420 --> 00:03:41,850
babel for example and you take here six

00:03:39,329 --> 00:03:44,489
code with classes and you compile it you

00:03:41,850 --> 00:03:47,519
get es5 code that just uses prototypes

00:03:44,489 --> 00:03:49,980
and in fact it's because of the fact

00:03:47,519 --> 00:03:52,260
that es6 is primarily about being

00:03:49,980 --> 00:03:55,320
syntactic sugar that babel can even

00:03:52,260 --> 00:03:57,900
exist so an alternative title for this

00:03:55,320 --> 00:04:01,620
presentation might have been things that

00:03:57,900 --> 00:04:04,019
babel can't do or es6 features that

00:04:01,620 --> 00:04:06,420
babel can't handle the same is true for

00:04:04,019 --> 00:04:08,630
iterators and generators rest and spread

00:04:06,420 --> 00:04:11,310
and other features as well with in es6

00:04:08,630 --> 00:04:14,400
so now let's start looking at things

00:04:11,310 --> 00:04:16,590
that are more problematic to implement

00:04:14,400 --> 00:04:19,590
in es6 before we get to the things that

00:04:16,590 --> 00:04:21,030
you literally can't implement so I don't

00:04:19,590 --> 00:04:22,680
know how many of you're familiar I

00:04:21,030 --> 00:04:25,080
assume that most of you hopefully are

00:04:22,680 --> 00:04:28,379
familiar with es6 map

00:04:25,080 --> 00:04:31,409
up till now up till six when we wanted

00:04:28,379 --> 00:04:34,889
to implement a dictionary from values to

00:04:31,409 --> 00:04:37,349
from keys to values we would use Bob

00:04:34,889 --> 00:04:40,050
simple JavaScript objects here's an

00:04:37,349 --> 00:04:41,819
example we have a dictionary object we

00:04:40,050 --> 00:04:44,699
have two keys in this case there are

00:04:41,819 --> 00:04:48,509
objects and we are using them to put a

00:04:44,699 --> 00:04:50,879
value into the dictionary now the thing

00:04:48,509 --> 00:04:52,949
is about using objects as dictionaries

00:04:50,879 --> 00:04:55,860
is that all the keys are by definition

00:04:52,949 --> 00:04:57,599
strings so if you try to use a key which

00:04:55,860 --> 00:05:00,419
isn't a string like an object in this

00:04:57,599 --> 00:05:03,270
case it gets translated into a string

00:05:00,419 --> 00:05:06,569
and because of that because both key one

00:05:03,270 --> 00:05:08,610
and key two are just simple objects they

00:05:06,569 --> 00:05:11,580
get translated into the same string

00:05:08,610 --> 00:05:15,240
value and as a result if you use key -

00:05:11,580 --> 00:05:17,159
it indexes the same value as key one

00:05:15,240 --> 00:05:19,440
even though those are two distinct

00:05:17,159 --> 00:05:21,479
objects you could even use a string

00:05:19,440 --> 00:05:23,759
representation of the object that's the

00:05:21,479 --> 00:05:27,830
final line and again you get at the same

00:05:23,759 --> 00:05:33,210
value on the other hand with es6 Maps

00:05:27,830 --> 00:05:35,849
the keys can be either strings or they

00:05:33,210 --> 00:05:38,009
can be object references and the

00:05:35,849 --> 00:05:40,139
consequence of that is the because key

00:05:38,009 --> 00:05:44,639
one and key two reference to distinct

00:05:40,139 --> 00:05:47,219
objects then when you index a dictionary

00:05:44,639 --> 00:05:49,560
using key - you don't get the value that

00:05:47,219 --> 00:05:51,599
you put in using key one so that's a

00:05:49,560 --> 00:05:53,699
very significant or key difference

00:05:51,599 --> 00:05:58,680
between the two types of dictionaries

00:05:53,699 --> 00:06:00,240
now can we implement maps with es5 well

00:05:58,680 --> 00:06:02,550
the answer is yes we can

00:06:00,240 --> 00:06:05,339
here's a very simple implementation I'll

00:06:02,550 --> 00:06:07,650
give you a second all speak for a bit to

00:06:05,339 --> 00:06:09,719
let you look quickly at the code but the

00:06:07,650 --> 00:06:12,240
the way that this code worked is fairly

00:06:09,719 --> 00:06:15,240
obvious we have two arrays within the

00:06:12,240 --> 00:06:17,699
object one for the keys once for one for

00:06:15,240 --> 00:06:20,279
the values and then we just push the key

00:06:17,699 --> 00:06:22,680
and the value into each array and since

00:06:20,279 --> 00:06:25,139
we push them using the same index value

00:06:22,680 --> 00:06:28,169
then when we want to get the value out

00:06:25,139 --> 00:06:31,020
we just find the key within the keys

00:06:28,169 --> 00:06:33,569
array and use that index to go to the

00:06:31,020 --> 00:06:34,949
values area now can you spot a problem

00:06:33,569 --> 00:06:36,660
with this implementation or what's the

00:06:34,949 --> 00:06:39,810
the cost of

00:06:36,660 --> 00:06:41,420
this implementation well the cost of

00:06:39,810 --> 00:06:45,960
this implementation is performance

00:06:41,420 --> 00:06:47,580
because instead of you know the the for

00:06:45,960 --> 00:06:49,280
those of you remember what you may be

00:06:47,580 --> 00:06:52,680
studied in the university or the college

00:06:49,280 --> 00:06:55,580
then the cost of performing a look up in

00:06:52,680 --> 00:06:58,470
such a data structure is Big O of n

00:06:55,580 --> 00:07:01,500
whereas with usually with dictionaries

00:06:58,470 --> 00:07:03,930
what you want his Big O of log N or

00:07:01,500 --> 00:07:06,870
maybe Big O of constant even if you're

00:07:03,930 --> 00:07:09,300
using a sufficiently large hash so

00:07:06,870 --> 00:07:12,450
that's a so the answer so you can

00:07:09,300 --> 00:07:15,120
emulate maps with es5 but at a

00:07:12,450 --> 00:07:18,030
significant performance cost now let's

00:07:15,120 --> 00:07:20,640
take this a step further let's let's

00:07:18,030 --> 00:07:24,750
look at this scenario say that we want

00:07:20,640 --> 00:07:28,230
to add data on top of existing objects

00:07:24,750 --> 00:07:31,230
without modifying the original objects a

00:07:28,230 --> 00:07:34,410
case might be where we take dom elements

00:07:31,230 --> 00:07:37,680
from the HTML and we want to add

00:07:34,410 --> 00:07:39,320
additional to associate the dom element

00:07:37,680 --> 00:07:42,540
with a JavaScript or a JSON object

00:07:39,320 --> 00:07:45,300
containing some arbitrary value a way to

00:07:42,540 --> 00:07:48,630
do that without having to modify the

00:07:45,300 --> 00:07:51,480
original dom element is to use that dom

00:07:48,630 --> 00:07:53,580
element has a key in the map and use the

00:07:51,480 --> 00:07:55,860
JSON value as the value that you

00:07:53,580 --> 00:07:58,290
associate with it and here we can see

00:07:55,860 --> 00:08:00,690
how we extract an element from the dom

00:07:58,290 --> 00:08:03,300
using one way associated with the value

00:08:00,690 --> 00:08:04,680
and then we even if we extract in some

00:08:03,300 --> 00:08:08,190
other way because it's the same

00:08:04,680 --> 00:08:09,900
reference we get back the same value by

00:08:08,190 --> 00:08:12,570
the way this is such a user a useful

00:08:09,900 --> 00:08:14,730
paradigm the jQuery actually provides it

00:08:12,570 --> 00:08:19,350
as if for those of you remember jQuery

00:08:14,730 --> 00:08:21,660
with the data method yeah

00:08:19,350 --> 00:08:24,510
so moving on but can you spot a problem

00:08:21,660 --> 00:08:26,580
with this implementation though the

00:08:24,510 --> 00:08:28,980
problem is and I'm not really giving you

00:08:26,580 --> 00:08:32,700
enough time to do that the problem is

00:08:28,980 --> 00:08:36,000
it's a there's a leak and the leak is

00:08:32,700 --> 00:08:38,969
that if we look at the size of the map

00:08:36,000 --> 00:08:41,940
and then we remove the element the Dom

00:08:38,969 --> 00:08:45,060
element from the actual Dom it still

00:08:41,940 --> 00:08:47,339
remains referenced it's still referenced

00:08:45,060 --> 00:08:48,380
by the map and as a result it can't be

00:08:47,339 --> 00:08:52,040
garbage collected

00:08:48,380 --> 00:08:53,780
and the data the value also can't be

00:08:52,040 --> 00:08:55,820
garbage collected for the same reason

00:08:53,780 --> 00:08:57,860
because it's still in the map so looking

00:08:55,820 --> 00:09:00,410
at the size before the remove and after

00:08:57,860 --> 00:09:02,330
the remove the size remains the same if

00:09:00,410 --> 00:09:04,940
we use this type of an implementation

00:09:02,330 --> 00:09:05,390
whenever we remove an element from the

00:09:04,940 --> 00:09:08,150
DOM

00:09:05,390 --> 00:09:10,520
we would have to go within every map

00:09:08,150 --> 00:09:13,040
within that application regardless of

00:09:10,520 --> 00:09:15,560
encapsulation and whatnot and try to

00:09:13,040 --> 00:09:17,930
look up that Dom element and remove it

00:09:15,560 --> 00:09:20,810
from the map obviously that's not very

00:09:17,930 --> 00:09:22,790
nice architecture to have so this is

00:09:20,810 --> 00:09:27,550
really solved by something called weak

00:09:22,790 --> 00:09:30,200
map within es6 now weak map is not

00:09:27,550 --> 00:09:32,270
weaker it just uses something called

00:09:30,200 --> 00:09:35,050
weak references or weakly held

00:09:32,270 --> 00:09:38,000
references weakly head held references

00:09:35,050 --> 00:09:40,100
reference the object so you can compare

00:09:38,000 --> 00:09:42,290
the reference to the object but they

00:09:40,100 --> 00:09:44,480
don't prevent garbage collection that's

00:09:42,290 --> 00:09:46,370
why they're weak they're not strong in

00:09:44,480 --> 00:09:48,770
the sense that they hold onto the object

00:09:46,370 --> 00:09:53,470
they're just kind of touching it or

00:09:48,770 --> 00:09:57,080
brushing it and when when the only

00:09:53,470 --> 00:09:59,360
remaining references to an object are

00:09:57,080 --> 00:10:02,990
weak references then the object gets

00:09:59,360 --> 00:10:06,140
garbage collected and weak map is smart

00:10:02,990 --> 00:10:08,570
enough to realize that the object that

00:10:06,140 --> 00:10:11,780
it's weakly referencing has been garbage

00:10:08,570 --> 00:10:14,150
collected and let go of the data

00:10:11,780 --> 00:10:17,660
associated with it as well so both of

00:10:14,150 --> 00:10:19,880
the so there's basically no resource

00:10:17,660 --> 00:10:21,800
leak in this context by the way there is

00:10:19,880 --> 00:10:24,400
a similar data structure called weak set

00:10:21,800 --> 00:10:28,180
which essentially does the same thing

00:10:24,400 --> 00:10:31,190
now weak map can't be implemented in es5

00:10:28,180 --> 00:10:34,010
so here we found the first feature of

00:10:31,190 --> 00:10:34,520
year 6 that can't be implemented with

00:10:34,010 --> 00:10:36,980
es5

00:10:34,520 --> 00:10:39,380
now the reason that year that week maps

00:10:36,980 --> 00:10:42,530
cannot be implemented with es5 is

00:10:39,380 --> 00:10:44,270
because es5 doesn't give you this level

00:10:42,530 --> 00:10:46,400
of control in fact javascript at all

00:10:44,270 --> 00:10:48,590
doesn't intentionally doesn't give you

00:10:46,400 --> 00:10:51,340
this level of control over the garbage

00:10:48,590 --> 00:10:54,080
collector you cannot control how

00:10:51,340 --> 00:10:57,020
references operate with relations to the

00:10:54,080 --> 00:10:59,360
garbage collector so the bottom line is

00:10:57,020 --> 00:11:00,389
that you just cannot implement week maps

00:10:59,360 --> 00:11:06,179
and week sets

00:11:00,389 --> 00:11:10,999
in es5 moving on proxies here's another

00:11:06,179 --> 00:11:14,129
feature that you cannot implement in es5

00:11:10,999 --> 00:11:16,949
proxies allow you to define custom

00:11:14,129 --> 00:11:18,929
behaviors for fundamental operations

00:11:16,949 --> 00:11:21,329
that you perform on objects so we're

00:11:18,929 --> 00:11:24,569
talking about operations like property

00:11:21,329 --> 00:11:28,139
access either to read a property or to

00:11:24,569 --> 00:11:30,899
write to a property in numerating

00:11:28,139 --> 00:11:33,089
properties if the object is a function

00:11:30,899 --> 00:11:35,009
then invoking the function all of these

00:11:33,089 --> 00:11:37,579
are operations that you can perform in

00:11:35,009 --> 00:11:40,529
objects and using the proxy mechanism

00:11:37,579 --> 00:11:42,600
es6 gives you complete control over how

00:11:40,529 --> 00:11:45,119
they operate you know this is also known

00:11:42,600 --> 00:11:49,049
as metaprogramming now you might say

00:11:45,119 --> 00:11:51,059
wait a minute I can control how property

00:11:49,049 --> 00:11:53,429
access occurs with for example here's

00:11:51,059 --> 00:11:55,589
five getters and setters or I can

00:11:53,429 --> 00:11:58,920
control enumeration maybe to an extent

00:11:55,589 --> 00:12:01,679
with access descriptors but getters and

00:11:58,920 --> 00:12:03,959
setters are defined for it but for a

00:12:01,679 --> 00:12:06,209
specific property so you can have a

00:12:03,959 --> 00:12:09,029
property called X and define a getter

00:12:06,209 --> 00:12:10,379
and a setter for property X you cannot

00:12:09,029 --> 00:12:13,980
define with es5

00:12:10,379 --> 00:12:16,079
a generic getter and setter for every

00:12:13,980 --> 00:12:18,449
property including properties that don't

00:12:16,079 --> 00:12:20,100
even exist yet something that as we will

00:12:18,449 --> 00:12:23,129
see in a minute you can do with proxies

00:12:20,100 --> 00:12:25,860
and this allows you to do with with

00:12:23,129 --> 00:12:29,069
JavaScript a lot of the crazy stuff that

00:12:25,860 --> 00:12:30,749
the dome API does that with is that up

00:12:29,069 --> 00:12:32,249
to now you couldn't really implement

00:12:30,749 --> 00:12:34,319
with JavaScript so you could access the

00:12:32,249 --> 00:12:36,779
Dom using JavaScript but some of the

00:12:34,319 --> 00:12:38,999
things that the Dom did the Dom API did

00:12:36,779 --> 00:12:41,819
you couldn't actually implement yourself

00:12:38,999 --> 00:12:45,089
things like node list or even session

00:12:41,819 --> 00:12:46,499
storage or the CSS objects you couldn't

00:12:45,089 --> 00:12:48,779
really implement this type of

00:12:46,499 --> 00:12:52,169
functionality was straight on JavaScript

00:12:48,779 --> 00:12:54,689
up to now and with proxy you can let's

00:12:52,169 --> 00:12:57,299
look at a very simple example we have a

00:12:54,689 --> 00:13:00,720
simple object called obj herbs

00:12:57,299 --> 00:13:04,049
having simply two fields hello and 7 and

00:13:00,720 --> 00:13:06,119
even though it the 7 appears as a number

00:13:04,049 --> 00:13:08,910
it's actually a string obviously because

00:13:06,119 --> 00:13:12,149
it's a key and then we create a proxy

00:13:08,910 --> 00:13:13,860
which wraps this object and we assign

00:13:12,149 --> 00:13:16,920
this proxy into double

00:13:13,860 --> 00:13:20,430
so double now references a proxy which

00:13:16,920 --> 00:13:22,260
wraps the original object the proxy

00:13:20,430 --> 00:13:24,320
received the original object as the

00:13:22,260 --> 00:13:27,420
first parameter the second parameter

00:13:24,320 --> 00:13:30,570
specifies JavaScript functions that

00:13:27,420 --> 00:13:32,580
handle the those operations that you can

00:13:30,570 --> 00:13:35,520
perform on this object so in this case I

00:13:32,580 --> 00:13:37,860
just before I just defined a get which

00:13:35,520 --> 00:13:42,470
means I have total control over how

00:13:37,860 --> 00:13:44,910
property values are read frame from the

00:13:42,470 --> 00:13:47,400
through the proxy from the original

00:13:44,910 --> 00:13:49,950
object so if I look if you look at this

00:13:47,400 --> 00:13:53,010
implementation I look at the key value

00:13:49,950 --> 00:13:57,420
that I receive and if this key value is

00:13:53,010 --> 00:14:00,390
not numeric I go to the original object

00:13:57,420 --> 00:14:03,840
but if it is a numeric I just return

00:14:00,390 --> 00:14:05,700
double that key value and if we you can

00:14:03,840 --> 00:14:08,640
actually copy this code and put it into

00:14:05,700 --> 00:14:11,400
Firefox or Chrome and you can see the

00:14:08,640 --> 00:14:14,520
results that I put on the screen so if

00:14:11,400 --> 00:14:16,590
we put in double three that three is a

00:14:14,520 --> 00:14:18,720
number it gets passed through two times

00:14:16,590 --> 00:14:21,450
key and you get back a six

00:14:18,720 --> 00:14:24,000
likewise with four so effectively I've

00:14:21,450 --> 00:14:26,730
created something which looks like an

00:14:24,000 --> 00:14:29,220
infinite array of all the numbers and

00:14:26,730 --> 00:14:31,740
whichever number you pass in it's as if

00:14:29,220 --> 00:14:33,830
that area contains double that number on

00:14:31,740 --> 00:14:37,860
the other hand if I pass in let's say

00:14:33,830 --> 00:14:40,290
bar bar is not a number it gets passed

00:14:37,860 --> 00:14:42,030
on to the original object and we get

00:14:40,290 --> 00:14:43,680
back the value which in this case is

00:14:42,030 --> 00:14:46,110
hello and I'll leave it as an exercise

00:14:43,680 --> 00:14:48,540
to you guys you could try it on your

00:14:46,110 --> 00:14:51,330
computer to see what happens if you pass

00:14:48,540 --> 00:14:54,660
in seven whether it goes to the original

00:14:51,330 --> 00:14:57,230
object or goes to whether it returns the

00:14:54,660 --> 00:15:02,750
word seven or the number fourteen

00:14:57,230 --> 00:15:06,030
so proxies can't be implemented with es5

00:15:02,750 --> 00:15:10,380
because you simply don't have this level

00:15:06,030 --> 00:15:12,120
of control over object you can't over

00:15:10,380 --> 00:15:14,370
one of the things that JavaScript did

00:15:12,120 --> 00:15:16,140
not have and now in a sense does have is

00:15:14,370 --> 00:15:18,270
operator overloading

00:15:16,140 --> 00:15:21,710
so in effect proxy gives you an ability

00:15:18,270 --> 00:15:24,380
to overload as it were the

00:15:21,710 --> 00:15:28,430
a property access operator be it done

00:15:24,380 --> 00:15:32,810
via square brackets or the dot either

00:15:28,430 --> 00:15:35,990
way so now we have two features that we

00:15:32,810 --> 00:15:37,070
could implement in es5 in year six sorry

00:15:35,990 --> 00:15:42,130
and that we couldn't implement

00:15:37,070 --> 00:15:42,130
previously with es5 let's move on

00:15:42,310 --> 00:15:48,140
javascript type conversions both

00:15:44,690 --> 00:15:49,160
implicit and explicit very very simple

00:15:48,140 --> 00:15:51,320
and easy right

00:15:49,160 --> 00:15:53,450
you know never confusing let's look at

00:15:51,320 --> 00:15:56,780
an example say you want to convert

00:15:53,450 --> 00:15:59,180
something an object whatever into a

00:15:56,780 --> 00:16:02,390
string there are two common ways of

00:15:59,180 --> 00:16:05,900
doing it you can either just add an

00:16:02,390 --> 00:16:08,600
empty string to it another way is to use

00:16:05,900 --> 00:16:11,480
the string object constructor as a

00:16:08,600 --> 00:16:14,300
function effectively doing a cast into

00:16:11,480 --> 00:16:16,580
string and if you you know many people

00:16:14,300 --> 00:16:19,160
basically look at these two methods as

00:16:16,580 --> 00:16:21,260
interchangeable you can use one or the

00:16:19,160 --> 00:16:23,720
other it doesn't really matter you're

00:16:21,260 --> 00:16:26,060
supposed to get the same result well if

00:16:23,720 --> 00:16:27,770
you look at this example if you try it

00:16:26,060 --> 00:16:31,250
you'll see that you get two different

00:16:27,770 --> 00:16:33,380
results and again I give it as an

00:16:31,250 --> 00:16:35,750
exercise to you guys to first try to

00:16:33,380 --> 00:16:37,490
guess which values you get and then

00:16:35,750 --> 00:16:40,520
check that you're getting the correct

00:16:37,490 --> 00:16:42,970
value that you expected but the point

00:16:40,520 --> 00:16:46,070
that I'm trying to make here is that

00:16:42,970 --> 00:16:48,650
rather than the object itself

00:16:46,070 --> 00:16:51,110
controlling how it gets converted into a

00:16:48,650 --> 00:16:53,030
primitive value it's the way in which

00:16:51,110 --> 00:16:56,500
the conversion is performed on the

00:16:53,030 --> 00:16:59,180
object that determines what happens and

00:16:56,500 --> 00:17:01,340
that's not the way that you want to work

00:16:59,180 --> 00:17:03,980
what we really want is for the object

00:17:01,340 --> 00:17:06,500
itself to have as much internal control

00:17:03,980 --> 00:17:10,670
about such conversions as possible and

00:17:06,500 --> 00:17:13,970
to in order to accomplish this year six

00:17:10,670 --> 00:17:15,860
effectively exposes a function that was

00:17:13,970 --> 00:17:18,050
previously internal within the

00:17:15,860 --> 00:17:21,050
JavaScript engine and that's the to

00:17:18,050 --> 00:17:23,780
primitive mechanism so the name of this

00:17:21,050 --> 00:17:26,180
method is actually the symbol to

00:17:23,780 --> 00:17:27,980
primitive I know that this is kind of a

00:17:26,180 --> 00:17:30,260
confusing notation for those of you have

00:17:27,980 --> 00:17:32,840
not encountered it what happens what

00:17:30,260 --> 00:17:34,060
happened here is that within object I

00:17:32,840 --> 00:17:37,480
define I

00:17:34,060 --> 00:17:40,960
find a method and the method name is the

00:17:37,480 --> 00:17:43,360
symbol to primitive this method gets a

00:17:40,960 --> 00:17:46,120
single parameter which is called usually

00:17:43,360 --> 00:17:49,300
hint which basically receives a string

00:17:46,120 --> 00:17:52,840
that tells me or tells the object what

00:17:49,300 --> 00:17:57,040
the calling code wants to convert it to

00:17:52,840 --> 00:17:58,990
and then it can perform whatever

00:17:57,040 --> 00:18:01,810
computation at once and return whatever

00:17:58,990 --> 00:18:03,760
valued wants based on that hint value

00:18:01,810 --> 00:18:05,680
can even throw an exception for example

00:18:03,760 --> 00:18:08,980
if it doesn't want that conversion to

00:18:05,680 --> 00:18:12,460
occur and this gives us a much greater

00:18:08,980 --> 00:18:14,980
level of control as we just saw than

00:18:12,460 --> 00:18:17,620
what we previously had with two string

00:18:14,980 --> 00:18:19,390
and value of now this is not a dramatic

00:18:17,620 --> 00:18:23,770
difference but again it basically just

00:18:19,390 --> 00:18:25,960
shows how es6 took the conversion

00:18:23,770 --> 00:18:35,920
mechanism a step forward beyond again

00:18:25,960 --> 00:18:37,900
what we could do with es5 okay still

00:18:35,920 --> 00:18:41,020
have time for this so we can cover this

00:18:37,900 --> 00:18:43,120
as well tail call optimization hopefully

00:18:41,020 --> 00:18:47,380
I really hope that you can actually see

00:18:43,120 --> 00:18:51,010
the code so what we see here is a

00:18:47,380 --> 00:18:53,920
screenshot that I took from the Firefox

00:18:51,010 --> 00:18:58,600
nightly dev tools where I've defined

00:18:53,920 --> 00:19:02,740
three well two functions and invoke them

00:18:58,600 --> 00:19:04,810
from the global coherence code so we

00:19:02,740 --> 00:19:07,690
have a bar function which gets called

00:19:04,810 --> 00:19:09,460
from the global scope does a bit of

00:19:07,690 --> 00:19:12,730
computation with a parameter that it

00:19:09,460 --> 00:19:15,370
receives passes onto a foo function

00:19:12,730 --> 00:19:19,510
which again does a bit more computation

00:19:15,370 --> 00:19:21,640
when foo returns the value bar doesn't

00:19:19,510 --> 00:19:23,710
do any additional operation it

00:19:21,640 --> 00:19:27,240
immediately returns the value that it

00:19:23,710 --> 00:19:32,770
got from foo back to the global scope

00:19:27,240 --> 00:19:35,470
now if we look at the stack at the stack

00:19:32,770 --> 00:19:38,170
as it's represented here in the dev

00:19:35,470 --> 00:19:40,150
tools we will see that we have well you

00:19:38,170 --> 00:19:43,060
know what we would generally expect we

00:19:40,150 --> 00:19:44,030
see the global scope and on top of that

00:19:43,060 --> 00:19:46,130
the

00:19:44,030 --> 00:19:48,470
the scope for the bar function

00:19:46,130 --> 00:19:52,700
invocation and on top of that the scope

00:19:48,470 --> 00:19:57,500
for foo but here's the thing why do we

00:19:52,700 --> 00:20:00,200
actually need to keep bars context I

00:19:57,500 --> 00:20:03,020
mean we never actually go back to it as

00:20:00,200 --> 00:20:06,650
soon as we go back to bar we immediately

00:20:03,020 --> 00:20:09,800
return to the global scope so if we

00:20:06,650 --> 00:20:12,980
threw away bar and just returned from

00:20:09,800 --> 00:20:14,870
food directly to the global the code

00:20:12,980 --> 00:20:18,590
would work would work exactly the same

00:20:14,870 --> 00:20:21,650
and what would we gain well we would be

00:20:18,590 --> 00:20:26,240
able to release maybe objects referenced

00:20:21,650 --> 00:20:28,790
by bar sooner or and the return code

00:20:26,240 --> 00:20:31,130
would also be more efficient so we can

00:20:28,790 --> 00:20:35,180
get some performance improvements so

00:20:31,130 --> 00:20:37,940
tail call optimization being part of er6

00:20:35,180 --> 00:20:40,670
can make code run faster but you can say

00:20:37,940 --> 00:20:43,040
hey okay so it's faster it's optimum it

00:20:40,670 --> 00:20:44,720
says we like faster we like more

00:20:43,040 --> 00:20:48,590
efficient but that's not really a

00:20:44,720 --> 00:20:50,390
feature yes but we can take it a step

00:20:48,590 --> 00:20:52,220
further with tail recursion

00:20:50,390 --> 00:20:53,510
now I'm really taking you back to the

00:20:52,220 --> 00:20:57,170
unit you're in university days

00:20:53,510 --> 00:20:59,810
potentially looking at this code it's

00:20:57,170 --> 00:21:04,160
code that calculates a factorial on the

00:20:59,810 --> 00:21:06,380
number that's provided to it so you can

00:21:04,160 --> 00:21:09,500
test it and you will see that if I pass

00:21:06,380 --> 00:21:11,930
in 6 I'll get 720 which is the expected

00:21:09,500 --> 00:21:14,420
value now the way that this code is

00:21:11,930 --> 00:21:16,580
implemented is that it uses an internal

00:21:14,420 --> 00:21:20,270
helper function called underscore fact

00:21:16,580 --> 00:21:23,450
and that function is implemented recurse

00:21:20,270 --> 00:21:25,850
in a recursive sort of a way but it's

00:21:23,450 --> 00:21:31,430
also implemented in such a way that when

00:21:25,850 --> 00:21:34,880
an internal invocation returns when the

00:21:31,430 --> 00:21:37,180
when fact calls itself again it never

00:21:34,880 --> 00:21:39,830
really needs to go back because again

00:21:37,180 --> 00:21:42,560
it's the last thing that it does there's

00:21:39,830 --> 00:21:45,920
no additional computation performed on

00:21:42,560 --> 00:21:47,360
when underscore fat calls itself it

00:21:45,920 --> 00:21:49,670
doesn't perform any additional

00:21:47,360 --> 00:21:52,730
computation on the value that it got

00:21:49,670 --> 00:21:54,470
back it just returns out as well so the

00:21:52,730 --> 00:21:56,790
same thing that we saw about teller

00:21:54,470 --> 00:22:00,150
recursion in the previous example

00:21:56,790 --> 00:22:04,560
can be implemented here now if we run

00:22:00,150 --> 00:22:06,780
this code with es5 and we pass in a

00:22:04,560 --> 00:22:10,800
really large number like say a hundred

00:22:06,780 --> 00:22:12,870
thousand then the stack explodes because

00:22:10,800 --> 00:22:14,640
we get more and more and more frames on

00:22:12,870 --> 00:22:16,500
the stack and eventually the stack runs

00:22:14,640 --> 00:22:20,910
out of room and that's the end of that

00:22:16,500 --> 00:22:24,660
but if we have if we're using an e or

00:22:20,910 --> 00:22:28,670
six with tail call optimization then

00:22:24,660 --> 00:22:31,410
because the new fact stack always

00:22:28,670 --> 00:22:33,480
replaces a previous one the start

00:22:31,410 --> 00:22:37,290
doesn't actually grow and there is no

00:22:33,480 --> 00:22:39,600
crash so with es6 tail recursion you

00:22:37,290 --> 00:22:41,190
will get the correct result do you know

00:22:39,600 --> 00:22:42,570
that can you guess the correct result

00:22:41,190 --> 00:22:44,580
here I'll give you a chance to answer

00:22:42,570 --> 00:22:50,160
who here knows the correct result

00:22:44,580 --> 00:22:52,860
without running it correct the according

00:22:50,160 --> 00:22:56,550
to JavaScript the factorial of a hundred

00:22:52,860 --> 00:22:58,650
thousand is in fact infinity and the

00:22:56,550 --> 00:23:00,120
reason is for because it's such a big

00:22:58,650 --> 00:23:08,580
number that it just can't be represented

00:23:00,120 --> 00:23:13,110
using 64-bit so to summarize javascript

00:23:08,580 --> 00:23:15,330
es6 is primarily about Sinta being

00:23:13,110 --> 00:23:17,610
syntactic sugar we look at most of the

00:23:15,330 --> 00:23:19,770
features that's why they are that what

00:23:17,610 --> 00:23:23,190
that's what they are and that's really a

00:23:19,770 --> 00:23:25,620
good thing I really really love the

00:23:23,190 --> 00:23:28,200
syntactic sugar in es6 whenever I do a

00:23:25,620 --> 00:23:30,420
work on an es6 project and then have to

00:23:28,200 --> 00:23:33,450
go back to an es5 project I literally

00:23:30,420 --> 00:23:36,120
suffer withdrawal symptoms having said

00:23:33,450 --> 00:23:39,600
that though it's important to understand

00:23:36,120 --> 00:23:43,170
that es6 is in fact more than es5 with

00:23:39,600 --> 00:23:45,480
just sugar we saw four examples of

00:23:43,170 --> 00:23:48,240
features of new things that you can do

00:23:45,480 --> 00:23:49,260
with es6 that you couldn't previously do

00:23:48,240 --> 00:23:51,930
with es5

00:23:49,260 --> 00:23:54,450
maybe we'll get more features along the

00:23:51,930 --> 00:23:56,400
way in any event it's definitely the

00:23:54,450 --> 00:23:59,070
JavaScript language is growing it's

00:23:56,400 --> 00:24:00,750
getting more powerful more capable go

00:23:59,070 --> 00:24:03,920
ahead and do something really

00:24:00,750 --> 00:24:05,980
interesting with it thank you very much

00:24:03,920 --> 00:24:05,980

YouTube URL: https://www.youtube.com/watch?v=GbVAMgU3Jj0


