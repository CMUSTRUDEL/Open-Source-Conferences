Title: Making CSS From Good to Great - by HJ Chen - Mozilla Developer Roadshow - Seoul
Publication date: 2019-12-21
Playlist: Mozilla Developer Roadshow 2019 - Asia
Description: 
	Singapore-based developer advocate Hui Jing Chen opens her CSS Subgrid talk in Korean (presentation in English).
Captions: 
	00:00:05,420 --> 00:00:08,860
[in Korean] Hello, I am Hui Jing.

00:00:09,160 --> 00:00:19,020
[in Korean] Today, I am going to talk about CSS grid...

00:00:19,860 --> 00:00:21,500
No, I really can't speak Korean.

00:00:22,500 --> 00:00:24,340
Let's - let's try this again. 

00:00:25,020 --> 00:00:25,860
My name is Hui Jing. 

00:00:25,860 --> 00:00:30,360
And as you can probably guess from this slide, I'm a big fan of emojis. 

00:00:30,360 --> 00:00:34,220
And these pretty much describe who I am as a person. 

00:00:34,220 --> 00:00:38,120
And if they don't make sense, you can come talk to me about them later. 

00:00:38,560 --> 00:00:45,880
I'm currently a developer advocate with nexmo, which is a platform that does APIs for messaging, voice and authentication,

00:00:45,880 --> 00:00:49,960
so developers can integrate communications into their apps. Pretty cool. 

00:00:50,240 --> 00:00:53,880
But today, we're all about web layouts. 

00:00:54,960 --> 00:00:59,240
So when the web started, there was no layout. 

00:00:59,660 --> 00:01:04,800
You could format your text with spaces, line breaks, indents, 

00:01:05,100 --> 00:01:10,820
but having a designed visual layout on your web page, you can't do that. 

00:01:11,340 --> 00:01:16,680
And the first time we could sort of place things in specific positions on a web page, 

00:01:17,140 --> 00:01:23,600
that was about 1994, when the table element first got introduced into browsers. 

00:01:23,900 --> 00:01:26,940
Tables are meant for data.

00:01:27,180 --> 00:01:31,200
But developers, you know, they do their own thing. 

00:01:31,200 --> 00:01:38,480
And so we started to hack the table to create creative and interesting layouts, you know, like Space Jam. 

00:01:39,100 --> 00:01:42,940
And then in '96, we got CSS. 

00:01:43,100 --> 00:01:48,900
And we all had to learn a new way to do layout with floats.

00:01:49,520 --> 00:01:53,520
But floats - floats were very difficult to use.

00:01:53,520 --> 00:02:00,040
You know, when you use floats, your columns were uneven heights, things were displaced. They didn't line up. 

00:02:00,680 --> 00:02:02,420
You had to clear floats.

00:02:02,940 --> 00:02:05,620
What is clear? Like, what is -

00:02:05,620 --> 00:02:06,240
Nevermind.

00:02:06,560 --> 00:02:11,280
So because it was so hard, people decided to build frameworks, 

00:02:11,280 --> 00:02:17,480
you know, like bootstrap, or whatever, and release these frameworks to other people 

00:02:17,480 --> 00:02:22,220
so that everyone else could apply pre-written styles with CSS classes. 

00:02:22,220 --> 00:02:25,280
And this approach was very popular. 

00:02:25,280 --> 00:02:30,740
And soon we hit an age where many websites looked very similar.

00:02:31,720 --> 00:02:35,320
So Mr. Jon Gold tweeted this out.

00:02:35,320 --> 00:02:41,180
And this tweet has been used in conference talks all over the world many, many times. 

00:02:41,800 --> 00:02:46,160
But it's a very salient point that, you know,

00:02:46,160 --> 00:02:49,760
you're either building the left website, or the right layout.

00:02:50,020 --> 00:02:53,340
And 6.8 thousand people agree with me. 

00:02:54,100 --> 00:02:59,060
But the thing is that CSS which is predominantly used for layouts, 

00:02:59,220 --> 00:03:02,380
it has evolved over the past 20 years, 

00:03:02,380 --> 00:03:05,880
and now we have a lot of options for doing layouts. 

00:03:06,860 --> 00:03:14,780
So when CSS2 was released, we had four layout modes that were used for different use cases. 

00:03:14,780 --> 00:03:18,180
So we had block layout, which was meant for laying out boxes. 

00:03:18,580 --> 00:03:21,280
We had inline layout for text.

00:03:21,380 --> 00:03:27,040
And then we had table layouts, which was, again, table layouts are meant for doing tables.

00:03:27,320 --> 00:03:31,400
And then we also have, you know, position layout, which was like an escape hatch, 

00:03:31,400 --> 00:03:37,520
because then your elements ignore other elements on the page like a dinosaur going "rarrr".

00:03:37,640 --> 00:03:40,780
So that's - yeah, so we had four for a while.

00:03:40,980 --> 00:03:45,000
And then in 2009, we had the Flexbox layout.

00:03:45,100 --> 00:03:52,540
And this was the first layout model that was designed specifically for building dynamic layouts on the web. 

00:03:52,860 --> 00:03:58,860
So it introduced a lot of new and powerful methods for distributing space between your items 

00:03:58,860 --> 00:04:05,060
as well as aligning content in a way that really suited how dynamic your browsers were,

00:04:05,060 --> 00:04:08,260
how dynamic a website could be, 

00:04:08,260 --> 00:04:12,440
because it was viewed in many different viewport sizes.

00:04:13,800 --> 00:04:15,440
Following that, we had grid. 

00:04:15,440 --> 00:04:19,120
So grid, it was about 2010, when it was first proposed, 

00:04:19,120 --> 00:04:28,360
and grid, for now, is the only layout model that recognizes the relationship between rows and columns. 

00:04:29,180 --> 00:04:36,460
But why is this significant? What's the big deal about two dimensions?

00:04:36,820 --> 00:04:37,980
Do I continue?

00:04:41,160 --> 00:04:42,560
Okay, right.

00:04:42,560 --> 00:04:44,300
Now we have a white border.

00:04:45,840 --> 00:04:54,120
Anyway, grid actually changes the way we think about layout and how we write the code to do layout. 

00:04:54,500 --> 00:05:03,860
So Rachel Andrew, who's one of the major contributors to CSS Grid, she sums it up - magic.

00:05:05,020 --> 00:05:06,540
She sums it up with this quote.

00:05:06,540 --> 00:05:14,240
She says that grid works from the container in, while other layout methods start with the item. 

00:05:14,600 --> 00:05:17,800
So this is better explained with a example. 

00:05:18,060 --> 00:05:23,300
So say you wanted to lay out your content into three columns.

00:05:23,880 --> 00:05:25,540
How would you do it?

00:05:26,200 --> 00:05:30,920
So one such approach for doing such a layout is you could use inline block. 

00:05:31,520 --> 00:05:38,800
And for a three column grid, we would set the display of the items, the inline block, 

00:05:38,800 --> 00:05:43,180
but then you'd have to give a width to your items. 

00:05:43,180 --> 00:05:48,960
Here I'll give it a width of a third of the container and then you get your three columns, right.

00:05:49,440 --> 00:05:52,460
Or maybe you don't like inline block, we got options. 

00:05:52,460 --> 00:05:57,240
You can do floats. But floats are also very similar to inline block. 

00:05:57,240 --> 00:06:01,700
If you look at the code, you also have to set a width on your item.

00:06:03,220 --> 00:06:06,960
And if you want to be, you know, modern and you want to use flex box, 

00:06:06,960 --> 00:06:08,960
sure, let's do flex box. 

00:06:09,840 --> 00:06:14,760
To do a three column grid, you would sort of lock your sizing 

00:06:14,760 --> 00:06:17,780
by setting flex grow and flex shrink to zero, 

00:06:17,780 --> 00:06:21,780
and then a basis of again, that of the container.

00:06:22,780 --> 00:06:29,720
So the similarity between all three techniques is that I have to set a width on my item. 

00:06:29,880 --> 00:06:33,800
And there is no grid, it just looks like there is a grid, 

00:06:33,800 --> 00:06:38,080
because we forced all the items to line up with each other.

00:06:39,480 --> 00:06:46,280
But when we are using grid, the dimensions for rows and columns are defined on the parent container.

00:06:46,280 --> 00:06:48,280
So there actually is a grid,

00:06:48,280 --> 00:06:51,220
and we can place items inside the grid.

00:06:51,540 --> 00:06:55,060
And this is amazing. 

00:06:56,920 --> 00:07:00,500
So the basic premise of how grid works involves two steps.

00:07:00,500 --> 00:07:05,080
You have to define your grid, and then you place items inside the grid.

00:07:07,180 --> 00:07:10,020
So this placing of items in the grid,

00:07:10,020 --> 00:07:13,440
you can either let the browser do it automatically,

00:07:13,440 --> 00:07:15,440
or you can define it yourself.

00:07:16,660 --> 00:07:19,340
So before we go into it,

00:07:19,340 --> 00:07:23,320
there are some terms that I'll be using that I'd like to clarify here.

00:07:23,760 --> 00:07:26,000
So we start off - grid lines. 

00:07:26,340 --> 00:07:31,560
These are the horizontal and vertical lines that form the basis of your grid structure.

00:07:31,560 --> 00:07:37,360
And you refer to these lines using the numerical index that start with one.

00:07:37,740 --> 00:07:41,300
One, because you know, we're not talking about index arrays, 

00:07:41,300 --> 00:07:44,300
we're talking about a grid - start from one not zero.

00:07:44,820 --> 00:07:49,240
And each space between the grid lines are known as grid tracks.

00:07:49,420 --> 00:07:52,720
So these are the tracks that make up the rows and columns of your grid. 

00:07:52,720 --> 00:07:55,480
And that's where your items will appear in. 

00:07:56,040 --> 00:08:02,740
A grid cell is a single unit of the grid and it's made up of two adjacent row and column lines. 

00:08:02,740 --> 00:08:09,560
So by default, a grid item will always take up the space of one grid cell unless you specify a larger area. 

00:08:09,740 --> 00:08:15,340
And speaking of area, a grid area is made up of multiple grid cells. 

00:08:16,000 --> 00:08:21,340
And the best part about grid is the fact that you can now define grid gaps. 

00:08:21,340 --> 00:08:25,040
So gaps are like gutters between your grid tracks.

00:08:25,180 --> 00:08:30,140
So this particular feature - gaps - has been expanded to flex layout as well. 

00:08:30,140 --> 00:08:37,200
So if you're using Firefox 63, and later, you can use gaps for flex layouts as well. 

00:08:38,520 --> 00:08:41,860
So in 2017, Grid was rolled out.

00:08:42,780 --> 00:08:47,680
It was rolled out very successfully, because if you look at this calendar, by the end of March, 

00:08:47,680 --> 00:08:51,380
all the major browsers had shipped the stable implementation of Grid,

00:08:51,580 --> 00:08:56,920
and then if you waited until October, you would see that even Edge (RIP) 

00:08:57,180 --> 00:09:01,600
and Samsung Internet also supported grid. 

00:09:01,600 --> 00:09:05,660
So 2017, the year of grid, very impressive.

00:09:06,880 --> 00:09:11,240
And right now today, I know the number here is very, very small. 

00:09:11,240 --> 00:09:17,940
But trust me when I say more than 93% of internet users are using a browser that supports Grid. 

00:09:18,440 --> 00:09:22,700
So you can't use the excuse that oh, the browsers support is no good. 

00:09:22,700 --> 00:09:24,060
No, you can't say that anymore.

00:09:24,060 --> 00:09:25,580
Think of a better excuse.

00:09:27,340 --> 00:09:32,260
Now, I personally, I've always used Firefox DevTools since I first started using Grid

00:09:32,260 --> 00:09:38,280
because it provides features that make it very easy to debug grid layouts 

00:09:38,540 --> 00:09:42,300
from day one when Firefox shipped Grid.

00:09:42,500 --> 00:09:46,100
But DevTools can be more than just used for debugging. 

00:09:46,280 --> 00:09:51,560
It can be a means for the browser to help us understand CSS better, 

00:09:51,560 --> 00:09:55,300
like how Daisuke had shown us a bit earlier. 

00:09:55,500 --> 00:10:02,400
And I'm going to go a bit more into grid and subgrid specific features in this demo.

00:10:02,880 --> 00:10:05,300
So let's move to - 

00:10:07,600 --> 00:10:15,660
Right. So this is an example page with a lot of layouts that are built with CSS Grid, 

00:10:15,660 --> 00:10:17,660
and we'll go through each of them.

00:10:18,000 --> 00:10:22,300
So when you first open your Firefox DevTools and you inspect it, 

00:10:22,300 --> 00:10:28,200
you'll see that if you use grid, there's this tag next to your container that is a grid container. 

00:10:28,200 --> 00:10:31,120
So you can click it, and you can toggle the grid overlay. 

00:10:31,520 --> 00:10:36,580
You can either do it here, or if you go down, you can see there's a layout panel. 

00:10:36,680 --> 00:10:41,620
And when you click into it, every grid that you use on your page is listed.

00:10:41,740 --> 00:10:45,980
So in this page, I have multiple grids and all of them are listed here.

00:10:46,620 --> 00:10:50,780
The default color is like purple, orange, blue, green, but - 

00:10:50,780 --> 00:10:53,560
but if you don't like the color, you can always change it.

00:10:54,060 --> 00:10:57,500
Let's just stick with purple for now because I tried the other day, 

00:10:57,880 --> 00:11:00,460
I was not good with choosing colours.

00:11:00,460 --> 00:11:03,620
Anyway, so this is the most basic grid, right? 

00:11:03,620 --> 00:11:07,780
So I have a grid container, and I have six grid children.

00:11:08,020 --> 00:11:10,680
So if we look at the code, we look at the syntax, 

00:11:13,260 --> 00:11:14,360
display grid,

00:11:14,500 --> 00:11:20,940
and how you define your columns and rows is with the property grid template columns, and grid template rows.

00:11:20,940 --> 00:11:27,420
And this syntax I really like, because if you can see, three values means I have three columns. 

00:11:28,180 --> 00:11:30,960
Two values of rows means I have two rows. 

00:11:30,960 --> 00:11:34,600
So it's a fairly visual type of syntax. 

00:11:34,840 --> 00:11:39,580
Now, with a six column grid, if I highlight the grid item, 

00:11:39,580 --> 00:11:44,240
you'll notice that there is no layout code on my box. It's just a border. 

00:11:44,400 --> 00:11:48,060
That's because the browser has something called automatic placement, 

00:11:48,060 --> 00:11:53,580
it will place all your grid items into the grid you defined in order.

00:11:53,580 --> 00:11:59,560
But this is something that you know we are very used to because the browser has always laid things out one after another. 

00:11:59,560 --> 00:12:07,100
This is nothing special. What is special about Grid is if I focus on the second example.

00:12:07,100 --> 00:12:10,300
So this is a Go board, 

00:12:10,640 --> 00:12:15,860
which may be more relevant in Japan, but nevermind - Asian people, we know what Go is. 

00:12:15,860 --> 00:12:17,020
Anyway, highlight.

00:12:17,640 --> 00:12:20,340
So this is a slightly more complicated grid.

00:12:20,340 --> 00:12:25,740
So there's 10 grid lines for a nine by nine grid. 

00:12:26,500 --> 00:12:30,840
So if I open up the markup, you'll notice that

00:12:31,840 --> 00:12:36,600
this grid has four grid items for each of the Go pieces. 

00:12:37,000 --> 00:12:43,340
The background is fake, it's a background gradient. 

00:12:44,320 --> 00:12:51,800
The interesting part about building this particular demo was trying to get the background aligned with the grid. 

00:12:51,960 --> 00:12:57,460
And if I didn't have the grid, the Firefox DevTools, it would have been very hard for me to figure out 

00:12:57,720 --> 00:13:02,600
how to align the grids with the background,

00:13:02,780 --> 00:13:08,320
because how Go pieces work is that they're not in the space, 

00:13:08,320 --> 00:13:10,180
they're in the intersection.

00:13:10,620 --> 00:13:14,840
So for a fairly complicated grid like this,

00:13:15,020 --> 00:13:17,660
the key feature here is the line numbers. 

00:13:17,660 --> 00:13:20,600
So Firefox is the only dev tool that provides this. 

00:13:20,600 --> 00:13:22,600
And if you go to the layout panel, 

00:13:22,680 --> 00:13:25,740
you will see that under the settings, you can display the line numbers 

00:13:25,740 --> 00:13:27,420
and you can also display area names. 

00:13:27,420 --> 00:13:28,580
I'll talk about that later. 

00:13:28,580 --> 00:13:30,580
You can extend the lines. 

00:13:31,640 --> 00:13:35,620
So if you have multiple grids on the page, and you need to check their alignment, 

00:13:35,620 --> 00:13:38,780
extending grid lines infinitely is a good feature. 

00:13:39,040 --> 00:13:40,380
But for now, turn it off. 

00:13:40,580 --> 00:13:48,160
So these numbers make it very easy for me to see where I need to place my grid item, 

00:13:48,160 --> 00:13:49,480
in this case, the Go piece. 

00:13:49,700 --> 00:13:55,500
So if you highlight the Go piece, you'll notice that the code for placing an item

00:13:55,800 --> 00:13:59,500
is grid row and grid column and it works like math. 

00:13:59,740 --> 00:14:07,300
So when you do Cartesian geometry - is that what you call it? 

00:14:07,500 --> 00:14:11,520
x and y coordinates, it operates on a similar principle. 

00:14:11,520 --> 00:14:15,520
So for this first Go piece, my grid row is four. 

00:14:15,520 --> 00:14:19,660
So you can see number four here, grid column five. 

00:14:19,660 --> 00:14:26,280
So with the line numbers, I can just immediately find - locate where I want to put my my item,

00:14:26,520 --> 00:14:28,100
and then just put the number in there.

00:14:28,400 --> 00:14:29,860
So it makes it a lot easier. 

00:14:29,860 --> 00:14:33,920
If I didn't have the line numbers, I had to sit there and count lines. 

00:14:33,920 --> 00:14:37,500
And I honestly would have better things to do with my time.

00:14:37,680 --> 00:14:42,720
So moving on, the next example is about grid areas. 

00:14:43,060 --> 00:14:49,640
So again, what Firefox DevTools has is it has support for grid area names. 

00:14:53,800 --> 00:15:02,100
So once you highlight it, another great property other than template columns and template rows is template areas. 

00:15:02,100 --> 00:15:07,860
So after you define your columns and rows, you can actually name specific areas of the grid, 

00:15:08,120 --> 00:15:12,320
and then assign your grid item to be inside that area. 

00:15:12,540 --> 00:15:16,500
So for this particular grid, I have three items in it.

00:15:19,160 --> 00:15:28,740
So three items, and it's a one of them is a doll emoji, sushi emoji and the last one, I don't know, power?

00:15:29,100 --> 00:15:33,320
But the point is that you can assign names, alphanumeric names. 

00:15:33,320 --> 00:15:41,260
So in this case, I just used dolls, sushi, but you can do like - you can do banana if you wanted.

00:15:41,680 --> 00:15:45,300
And how it works is that -

00:15:48,060 --> 00:15:51,020
if you can see the code - let me pull this up - 

00:15:53,420 --> 00:15:57,520
there are quotes so each of these quotes represents a single row,

00:15:58,020 --> 00:16:01,240
and all the values inside the quotes represent the column.

00:16:01,520 --> 00:16:07,660
So because this is a six by six, you have to have six rows, and then six values inside the rows. 

00:16:07,920 --> 00:16:11,540
So if it doesn't, if you don't match up the 36 values, 

00:16:11,540 --> 00:16:17,040
then the browser will ignore this rule, because then it's an invalid rule. 

00:16:17,340 --> 00:16:25,320
But the good part about template areas is that it's really good for full page layouts that have a lot of elements on the page. 

00:16:25,700 --> 00:16:28,620
And if you need to change the layout, 

00:16:28,620 --> 00:16:34,460
for example, if you're doing responsive design, and you want to shift things in a smaller viewport, 

00:16:34,460 --> 00:16:38,640
instead of going to each of the individual items and changing their position, 

00:16:38,640 --> 00:16:45,740
what you can do is after assigning each item into its respective area, you can just tweak it on the parent. 

00:16:45,880 --> 00:16:50,540
So for example, if I don't want sushi to take up four cells,

00:16:50,960 --> 00:16:52,480
I can change it directly. 

00:16:52,940 --> 00:16:55,200
So let's see.

00:16:55,820 --> 00:16:57,060
So hard to type.

00:16:58,900 --> 00:17:00,140
Right, okay. 

00:17:00,140 --> 00:17:01,340
So let's change.

00:17:11,780 --> 00:17:15,020
So if you just tweak the code on the template areas, 

00:17:15,020 --> 00:17:22,520
you'll see that now I can change the size of my grid item without having to go into the grid item for sushi itself.

00:17:22,660 --> 00:17:28,100
So this is really handy, like I mentioned, when you're doing a lot of full page responsive layouts. 

00:17:28,700 --> 00:17:32,740
The next feature of Grid that I want to highlight -

00:17:32,740 --> 00:17:41,180
- and I think for now, it's probably only supported in Firefox 66 and onwards,

00:17:41,180 --> 00:17:45,120
is the fact that you can animate grid rows and columns. 

00:17:45,600 --> 00:17:50,680
So I saw a similar implementation of this. Someone else built a demo.

00:17:50,680 --> 00:17:53,040
And when I saw this, the first thing I thought was that

00:17:53,160 --> 00:17:55,800
'Oh, if I want to animate something across the grid, 

00:17:56,020 --> 00:18:01,640
that means that the grid item is moving across grid tracks, right?' Wrong! 

00:18:02,040 --> 00:18:08,500
And this is much easier to wrap your head around if you have the DevTools. 

00:18:08,500 --> 00:18:13,500
So if I turn it on, you can see that the grid is a lie, 

00:18:13,500 --> 00:18:15,500
again, the grid is just the background, 

00:18:15,700 --> 00:18:21,480
it's not actually three columns and three rows, it's two columns and two rows. 

00:18:21,780 --> 00:18:26,580
And what the browser is animating is the size of the first grid cell.

00:18:27,040 --> 00:18:30,660
So if you look at the keyframes, all I'm doing is 

00:18:30,660 --> 00:18:37,280
I'm only animating the size of the first row of the first cell to move across the entire grid.

00:18:37,580 --> 00:18:41,580
And what you do is that you align the item,

00:18:41,580 --> 00:18:43,380
 which in this case, is the pond, 

00:18:43,380 --> 00:18:45,380
you align it to the bottom right corner. 

00:18:45,700 --> 00:18:48,900
Because interpolation doesn't work across grid tracks, 

00:18:48,900 --> 00:18:51,740
you can only animate the size of your grid track, 

00:18:51,940 --> 00:18:56,840
and it makes it much easier to understand if you can see it using DevTools. 

00:18:57,300 --> 00:18:59,980
So let's go back to the presentation. 

00:19:00,320 --> 00:19:03,900
I hope that I've convinced you that Grid is awesome. 

00:19:03,900 --> 00:19:09,080
But what will make Grid even more awesome, is Subgrid. 

00:19:09,240 --> 00:19:14,700
So some of us might not be too familiar with the levels in CSS specs. 

00:19:15,040 --> 00:19:22,800
But the long story short is that the CSS specification used to be this really, really long, monolithic document, 

00:19:23,000 --> 00:19:24,840
at least for CSS 1 and 2. 

00:19:25,040 --> 00:19:28,660
So it's like, I think if you print it out, it's maybe like this thick, 

00:19:29,040 --> 00:19:32,200
and you kill a lot of trees, so don't do that.

00:19:32,840 --> 00:19:37,720
But in the year 2000, this big document was split up into modules, 

00:19:38,600 --> 00:19:44,240
The rationale behind it was to make it easier to test, to develop and to maintain the spec itself. 

00:19:44,620 --> 00:19:48,560
So this split up version, we commonly call it CSS3, 

00:19:49,020 --> 00:19:52,920
but there will never be a CSS 4 or 5 and so on, 

00:19:52,920 --> 00:19:56,800
because each CSS feature now is a separate document.

00:19:57,020 --> 00:20:01,960
And when a feature gets too complicated or something in there requires more discussion,

00:20:01,960 --> 00:20:04,800
we'll just kick the feature into the next level. 

00:20:04,800 --> 00:20:10,500
So Subgrid was actually a very important feature from the start 

00:20:10,500 --> 00:20:12,500
when CSS Grid was being developed,

00:20:12,500 --> 00:20:18,220
but because there were a lot of edge cases and things that needed more discussion, 

00:20:18,460 --> 00:20:21,820
it was moved and differed into grid level two. 

00:20:22,200 --> 00:20:25,240
So level two of the grid spec cover subgrid, 

00:20:25,240 --> 00:20:30,120
and also something called aspect ratio control gutters - but we'll not talk about that. 

00:20:30,120 --> 00:20:32,440
We're only going to talk about subgrid.

00:20:33,600 --> 00:20:36,540
So why - why do we need subgrid? 

00:20:36,900 --> 00:20:41,280
Subgrid actually solve several use cases where 

00:20:42,140 --> 00:20:48,220
we want nested grids to be able to line up with the outermost grid. 

00:20:48,220 --> 00:20:55,500
So for example, if you have card style layouts, which is a very popular design pattern these days, 

00:20:56,260 --> 00:21:02,640
usually your designer will give you a very neat, stylized cuts, 

00:21:02,640 --> 00:21:06,700
all have the same content because every designer speaks lorem ipsum. 

00:21:06,980 --> 00:21:09,800
And the header will always have the exact same number of words, 

00:21:09,800 --> 00:21:11,600
the images will always be the same size,

00:21:11,600 --> 00:21:13,380
and everyone has the same amount of content. 

00:21:13,380 --> 00:21:18,300
And then when you build it, and you pull data from your CMS, 

00:21:18,300 --> 00:21:24,960
you'll realize that you know, some editors write one word headings, and some write a sentence of headings, 

00:21:24,960 --> 00:21:28,280
and you get uneven heights of content of headings.

00:21:29,020 --> 00:21:34,480
Maybe someone uploaded a five megabyte image because they felt like it and then your layout breaks.

00:21:35,900 --> 00:21:40,000
Before subgrid, you wouldn't be able to line up everything because 

00:21:40,000 --> 00:21:45,020
the content inside the grid doesn't know about the content in the other part.

00:21:45,400 --> 00:21:48,840
So this is why a subgrid solves this particular use case, 

00:21:49,420 --> 00:21:53,820
you can do it either horizontally or vertically as in the second example. 

00:21:54,460 --> 00:21:59,100
Another use case is forms because, again,

00:21:59,860 --> 00:22:03,900
 your forms are usually just a list of fields, right, 

00:22:03,900 --> 00:22:08,220
but each form field is made up of an input and a label. 

00:22:08,680 --> 00:22:15,960
So what you have is that your input and labels are actually grandchildren of your list element, that's fine.

00:22:15,960 --> 00:22:24,980
That's why it's really hard to align your labels with each other, and keep your semantic markup at the same time, 

00:22:24,980 --> 00:22:34,960
because if you try to use grid without subgrid, your inputs and your labels don't know about each other.

00:22:35,220 --> 00:22:41,660
So what we used to do to fix this is that we wouldn't do in-line labels and inputs. 

00:22:41,660 --> 00:22:44,800
We just put the label on top of the input and call it a day. 

00:22:45,120 --> 00:22:50,140
But now we can. Now with subgrid, this is a very possible layout. 

00:22:50,600 --> 00:22:54,180
And so the syntax for subgrid -

00:22:54,680 --> 00:22:56,860
I'm just going to show some code here -

00:22:56,860 --> 00:23:01,480
but we will move to the examples because this is too much text. 

00:23:01,720 --> 00:23:08,080
But basically, the subgrid syntax is applied onto your columns and rows, 

00:23:08,260 --> 00:23:10,880
because subgrid is for sizing. 

00:23:11,400 --> 00:23:14,340
So at the end of the day, you still have to put display grid, 

00:23:14,800 --> 00:23:18,740
not display subgrid - that is not a valid CSS value. 

00:23:18,920 --> 00:23:22,860
The subgrid value goes onto the columns and the rows.

00:23:22,960 --> 00:23:24,360
This is what I want to highlight.

00:23:24,660 --> 00:23:28,280
So let's move on to the example page. 

00:23:30,620 --> 00:23:32,800
The slides will be shared later, don't worry. 

00:23:33,100 --> 00:23:35,900
So this is again a bunch of examples. 

00:23:36,280 --> 00:23:39,420
So what we can do with subgrid is that 

00:23:39,420 --> 00:23:46,140
you have the option of either having the sizing follow columns, or rows, or both. 

00:23:46,460 --> 00:23:48,780
So what do I mean? If I highlight grid,

00:23:49,400 --> 00:23:58,720
and this is where having different colors on the DevTools really comes in handy because you can see - 

00:23:58,960 --> 00:24:01,740
okay, I think people at the back can't see the numbers,

00:24:01,860 --> 00:24:07,220
but your sub grid will have its own set of line numbers that start from one.

00:24:07,520 --> 00:24:12,360
So even though my subgrid is on line three of the parent grid, 

00:24:12,360 --> 00:24:16,580
the sub grid itself has a line number that starts with one, that's fine.

00:24:17,440 --> 00:24:21,820
But when we look at the code, you'll notice that for the subgrid,

00:24:22,820 --> 00:24:26,660
my grid template columns, I use the subgrid keyword. 

00:24:26,780 --> 00:24:30,300
So that means that the columns follow the parent's sizing, 

00:24:30,520 --> 00:24:34,820
but the rows can be any size at once so the rows don't line up. 

00:24:35,260 --> 00:24:41,120
Because sometimes you don't want your rows to follow the parent and that's okay - it's an option. 

00:24:41,520 --> 00:24:44,740
So similarly, you can do that along the rows as well. 

00:24:45,380 --> 00:24:50,020
So, these two examples are just mirrors of each other in a different dimension.

00:24:50,760 --> 00:24:58,360
So, for this one, you will see that the subgrid follows the rows of the pattern, 

00:24:58,500 --> 00:25:00,360
but the column is a different size. 

00:25:00,900 --> 00:25:04,860
So, this is what we mean when we say subgrid along a single dimension. 

00:25:04,860 --> 00:25:06,400
And of course, you can follow both.

00:25:07,240 --> 00:25:13,380
So we use that with using the subgrid keyword inside the template rows or the template columns property.

00:25:14,380 --> 00:25:19,600
Another thing that is interesting about subgrid is gaps. 

00:25:19,740 --> 00:25:23,140
So I mentioned earlier that gaps is a very useful feature.

00:25:23,560 --> 00:25:30,900
So when you have parent grids and subgrids, by default, the subgrid will inherit 

00:25:31,460 --> 00:25:35,340
the gap size of its parent, but you can also override it. 

00:25:36,140 --> 00:25:38,060
So if we highlight this, 

00:25:40,280 --> 00:25:44,280
so I have gaps set on the parent group of 1em,

00:25:46,160 --> 00:25:48,880
on the subgrid it's set to 2em.

00:25:48,880 --> 00:25:50,880
So if you notice item 2, 

00:25:51,040 --> 00:25:54,900
it does line up with the parent grid like item 4, 

00:25:54,900 --> 00:26:02,500
but it's smaller, because the gap for the subgrid is 1em larger than the parent.

00:26:02,800 --> 00:26:06,820
So item 2 is a bit smaller than item 4. 

00:26:06,820 --> 00:26:11,720
So this is something to keep in mind when you are using nested grids and you're adjusting -

00:26:11,720 --> 00:26:13,720
- you're having a different gap size, 

00:26:13,720 --> 00:26:20,600
it's going to affect the sizing of the nested items as much as you nest your grid.

00:26:21,040 --> 00:26:25,160
And this nest thing can become quite significant 

00:26:25,160 --> 00:26:27,900
if you take into account margins and padding. 

00:26:28,460 --> 00:26:32,460
So if you look at this next example, this is a bit of an inception, 

00:26:32,720 --> 00:26:39,740
because I have a grid and I also have a subgrid and then I have a sub subgrid. 

00:26:41,880 --> 00:26:43,860
It's hard to name things, okay. 

00:26:45,100 --> 00:26:54,160
But if you're on the edge, the edge of the grid will accumulate margins, borders and paddings.

00:26:54,480 --> 00:26:56,200
So if you look at this example, 

00:26:57,760 --> 00:27:00,380
the grid is the outermost. 

00:27:02,020 --> 00:27:05,540
It's five columns, that's the outermost container. 

00:27:05,980 --> 00:27:10,480
So first subgrid has padding of 1em and margin of 1em. 

00:27:10,800 --> 00:27:12,540
So this starts to accumulate. 

00:27:13,980 --> 00:27:20,320
By the time you get to the sub subgrid, which also has a padding of 1em and a margin of 1em, 

00:27:20,580 --> 00:27:25,280
the great grandchild, element number two, has shrunk. 

00:27:26,020 --> 00:27:31,680
So all this, even though it's aligned inside the second column of the parent grid, it's much smaller, 

00:27:31,680 --> 00:27:36,400
because this padding and margins from the outer grids accumulate

00:27:36,800 --> 00:27:38,660
 and kind of shrink item 2. 

00:27:38,660 --> 00:27:41,760
If you look at item three, it doesn't have this problem. 

00:27:41,760 --> 00:27:45,860
It's the same width as the parent column because it's not at the edge. 

00:27:46,060 --> 00:27:50,280
So this problem only manifests at the edge of the grid. 

00:27:50,280 --> 00:27:53,660
And so again, this is something to keep in mind when you nest grids, 

00:27:53,660 --> 00:27:59,160
maybe don't nest them too much or take note of your margins and paddings,

00:27:59,160 --> 00:28:01,800
especially if the sizing is very important to you.

00:28:03,140 --> 00:28:08,520
One more thing to note is that because it's a nested grid, 

00:28:09,400 --> 00:28:14,240
no implicit grid tracks means that you can't oversize the sub grid. 

00:28:14,400 --> 00:28:18,200
And I'll show you what I mean with this next example quickly. 

00:28:22,740 --> 00:28:26,040
So if you look at this parent grid, again, there's five columns. 

00:28:27,020 --> 00:28:28,300
And then I have a subgrid.

00:28:34,140 --> 00:28:35,660
So if you look at the subgrid,

00:28:40,180 --> 00:28:46,660
 its size is supposed to span from 2 to 4. 

00:28:46,660 --> 00:28:49,880
So this means that my subgrid only takes up two columns. 

00:28:50,760 --> 00:28:55,740
If I want to size the grandchild item inside, which is item 2, 

00:28:55,740 --> 00:28:57,940
if I size it to three columns,

00:28:58,120 --> 00:29:02,160
 the browser says no, because it can only max out at two. 

00:29:02,540 --> 00:29:08,360
So if I set this to anything bigger than than 2, so even if you do 456, 

00:29:08,740 --> 00:29:15,420
the browser will clamp it at the size of the allocated columns.

00:29:16,120 --> 00:29:17,020
And also, 

00:29:23,220 --> 00:29:27,600
if you have a fixed number of cells for your parent grid, again, 

00:29:27,820 --> 00:29:33,580
if you have more items than grid cells, what the browser's going to do is that 

00:29:33,580 --> 00:29:39,320
it will just stack everything in the last track. 

00:29:39,440 --> 00:29:40,520
So here, 

00:29:41,420 --> 00:29:44,940
when the grid spans line 2 to line 5, 

00:29:44,940 --> 00:29:47,120
it's three columns, two rows, 

00:29:47,120 --> 00:29:48,600
so it can contain six items. 

00:29:48,860 --> 00:29:52,620
If I change the number to, say, for it to span from 2 to 4, 

00:29:52,860 --> 00:29:54,800
that means I'm reducing the columns to 2. 

00:29:55,240 --> 00:29:59,920
So you'll see that items E and F just get stacked up on top of C 

00:29:59,920 --> 00:30:01,380
because there's no space, 

00:30:01,840 --> 00:30:05,540
so the browser is not going to put it outside, it's just going to stack it on top.

00:30:05,940 --> 00:30:08,540
So that's how the browser deals with subgrids. 

00:30:08,760 --> 00:30:11,340
And so if we look at the, 

00:30:11,580 --> 00:30:16,860
these are the examples, which I will be sharing with all of you later so you can see how the code works.

00:30:17,040 --> 00:30:20,660
These are the use cases that subgrid can solve. 

00:30:21,380 --> 00:30:25,480
And I think it can be very useful. 

00:30:26,120 --> 00:30:32,140
And you can sort of reduce the number of hacks you need to do in order to achieve this sort of layout.

00:30:32,840 --> 00:30:35,160
So I'm going to wrap up here 

00:30:37,240 --> 00:30:41,240
by showing you browser support for subgrid, which is actually very sad.

00:30:41,740 --> 00:30:45,060
And this is why more of us need to try this out, 

00:30:45,160 --> 00:30:48,900
because if we build things with subgrid, and then talk about it, 

00:30:49,020 --> 00:30:51,700
we're going to send a signal to other browser vendors. 

00:30:51,700 --> 00:30:56,880
Now Firefox supports it, but like Chrome, Safari, they don't yet. 

00:30:57,120 --> 00:31:00,860
But if we use this and we sort of create more buzz for this feature, 

00:31:01,060 --> 00:31:06,200
we're sort of encouraging them to put this feature higher on the priority list, right? 

00:31:06,800 --> 00:31:08,860
So these slides are going to be shared with everyone 

00:31:08,860 --> 00:31:11,960
and there are some useful links if you want to learn more about grid and subgrid.

00:31:12,140 --> 00:31:15,220
And definitely download a copy of Firefox, 

00:31:15,220 --> 00:31:20,200
plus points if you use Nightly to see all the great dev tools and CSS features 

00:31:20,200 --> 00:31:22,480
and other features as they are released.

00:31:24,220 --> 00:31:24,940

YouTube URL: https://www.youtube.com/watch?v=Ksc0dIg-DFQ


