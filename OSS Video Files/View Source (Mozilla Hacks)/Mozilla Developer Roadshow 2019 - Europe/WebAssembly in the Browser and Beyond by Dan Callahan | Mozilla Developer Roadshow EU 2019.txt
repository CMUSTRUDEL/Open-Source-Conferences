Title: WebAssembly in the Browser and Beyond by Dan Callahan | Mozilla Developer Roadshow EU 2019
Publication date: 2019-10-14
Playlist: Mozilla Developer Roadshow 2019 - Europe
Description: 
	WebAssembly began as an experiment in bringing other languages to the browser, marking a radical shift in the fundamental programming model of the Web. The project has just begun.  

Today, WebAssembly is poised to reshape everything from Node.js modules to containers, and even edge computing. But how is technology from the client side relevant to those domains?
Packed with live demos and real-world examples, this session draws from WebAssembly's past to predict its future. Come find out where we'll be in 2020, and beyond!

Dan Callahan is a Developer Advocate at Mozilla, where he works to ensure that the future of the Web is driven by the needs of real-world developers.
Captions: 
	00:00:10,080 --> 00:00:15,540
so this is the last talk we've kind of

00:00:12,960 --> 00:00:19,500
gone through virtual reality ethics of

00:00:15,540 --> 00:00:21,600
the web CSS and now web assembly my name

00:00:19,500 --> 00:00:23,640
is Dan Callahan I'm an engineer in the

00:00:21,600 --> 00:00:26,060
developer relations team at Mozilla you

00:00:23,640 --> 00:00:28,079
can find me on twitter as cala had and

00:00:26,060 --> 00:00:29,220
what i want to do is i want to take you

00:00:28,079 --> 00:00:33,210
back to the very beginning of the web

00:00:29,220 --> 00:00:36,950
and for the first several years web

00:00:33,210 --> 00:00:41,910
technology meant HTML all we had were

00:00:36,950 --> 00:00:44,030
hyperlinks documents we had data and as

00:00:41,910 --> 00:00:45,870
we just saw there's an entire universe

00:00:44,030 --> 00:00:48,570
missing here because we don't have

00:00:45,870 --> 00:00:50,550
anything for styling and we just had a

00:00:48,570 --> 00:00:52,440
30 minute talk on styling that big early

00:00:50,550 --> 00:00:54,649
scratch the surface of CSS and so we

00:00:52,440 --> 00:00:58,230
need presentation and we need logic and

00:00:54,649 --> 00:01:01,379
so for more than 20 years web technology

00:00:58,230 --> 00:01:04,470
has been these three technologies HTML

00:01:01,379 --> 00:01:06,090
CSS and javascript and there have been

00:01:04,470 --> 00:01:07,410
other things Java and flash that have

00:01:06,090 --> 00:01:09,530
come in but they haven't been part of

00:01:07,410 --> 00:01:13,280
the web so I don't think they count and

00:01:09,530 --> 00:01:15,660
I still think there's something missing

00:01:13,280 --> 00:01:17,640
when I think about programming languages

00:01:15,660 --> 00:01:20,550
I think about them on a spectrum from

00:01:17,640 --> 00:01:22,740
high level to low level and at the very

00:01:20,550 --> 00:01:25,590
lowest level is machine code the actual

00:01:22,740 --> 00:01:26,700
instructions of the physical CPU inside

00:01:25,590 --> 00:01:29,940
your phone or your tablet or your

00:01:26,700 --> 00:01:32,130
computer can understand just slightly

00:01:29,940 --> 00:01:36,000
higher than that our languages like C

00:01:32,130 --> 00:01:39,060
C++ and rust which compiled directly to

00:01:36,000 --> 00:01:41,280
native code to machine code but they

00:01:39,060 --> 00:01:43,650
give you the programmer controller that

00:01:41,280 --> 00:01:45,390
they give you control over what sort of

00:01:43,650 --> 00:01:48,120
operations you're doing how your data

00:01:45,390 --> 00:01:50,790
exists in memory and I think that

00:01:48,120 --> 00:01:53,070
control especially over memory for me is

00:01:50,790 --> 00:01:54,960
what distinguishes a high-level language

00:01:53,070 --> 00:01:57,000
from a low-level language because in

00:01:54,960 --> 00:02:01,620
high-level languages like Python Ruby

00:01:57,000 --> 00:02:03,300
JavaScript Elm and typescript you don't

00:02:01,620 --> 00:02:05,340
have that same degree of control you

00:02:03,300 --> 00:02:08,729
can't say you don't and you also don't

00:02:05,340 --> 00:02:10,950
have to say go allocate memory for my

00:02:08,729 --> 00:02:12,780
array and ok I'm done with that now free

00:02:10,950 --> 00:02:14,099
that memory the high-level language kind

00:02:12,780 --> 00:02:16,800
of frees you from those constraints that

00:02:14,099 --> 00:02:20,310
has garbage collection it has what you

00:02:16,800 --> 00:02:21,960
have more complex data types and that

00:02:20,310 --> 00:02:23,280
gives you more more convenience and more

00:02:21,960 --> 00:02:25,470
efficiency and more Express

00:02:23,280 --> 00:02:27,870
as a developer at the cost of control

00:02:25,470 --> 00:02:31,470
and there are languages in the middle

00:02:27,870 --> 00:02:33,330
Java c-sharp go and Swift which give you

00:02:31,470 --> 00:02:35,490
a little more control but they still

00:02:33,330 --> 00:02:36,560
have strong opinions about how memory

00:02:35,490 --> 00:02:38,940
works

00:02:36,560 --> 00:02:40,850
Java's garbage collected goes garbage

00:02:38,940 --> 00:02:44,100
collected Swift as reference counting

00:02:40,850 --> 00:02:47,550
you're still just slightly held back

00:02:44,100 --> 00:02:50,580
from being that you know adjacent to

00:02:47,550 --> 00:02:52,170
machine and the nice thing about

00:02:50,580 --> 00:02:53,700
programming language it's like who here

00:02:52,170 --> 00:02:57,989
knows more than one programming language

00:02:53,700 --> 00:02:59,190
which yeah so clearly most people know

00:02:57,989 --> 00:03:01,890
more than one programming language it

00:02:59,190 --> 00:03:03,209
seems clearly there's a reason to learn

00:03:01,890 --> 00:03:05,730
more than one there's no language that

00:03:03,209 --> 00:03:07,709
serves all purposes and if you're

00:03:05,730 --> 00:03:09,450
developing for a native platform you're

00:03:07,709 --> 00:03:10,980
able to select from either into the

00:03:09,450 --> 00:03:12,930
spectrum you're able to choose what

00:03:10,980 --> 00:03:15,000
language fits your problems best and

00:03:12,930 --> 00:03:17,459
that's extremely powerful and it's

00:03:15,000 --> 00:03:20,850
useful because in many cases you'll pick

00:03:17,459 --> 00:03:22,980
both in the scientific computing world

00:03:20,850 --> 00:03:25,769
Python is an extremely common language

00:03:22,980 --> 00:03:27,540
but all of the numeric computations all

00:03:25,769 --> 00:03:30,299
these libraries are Python libraries but

00:03:27,540 --> 00:03:32,400
they're actually implemented in C++ or

00:03:30,299 --> 00:03:33,750
in Fortran or ANSI because those

00:03:32,400 --> 00:03:35,579
lower-level languages can give you

00:03:33,750 --> 00:03:38,760
greater efficiency if you have the

00:03:35,579 --> 00:03:41,100
ability to say exactly how certain data

00:03:38,760 --> 00:03:42,269
exists in memory but as a Python

00:03:41,100 --> 00:03:43,980
developer you don't have to think about

00:03:42,269 --> 00:03:47,430
that you can exist at that higher level

00:03:43,980 --> 00:03:49,160
and kind of maintain that nice API the

00:03:47,430 --> 00:03:52,280
problem is that when you go to the web

00:03:49,160 --> 00:03:54,150
your only choice is JavaScript and

00:03:52,280 --> 00:03:55,500
that's not a problem because Java

00:03:54,150 --> 00:03:58,049
scripts are bad language Java scripts an

00:03:55,500 --> 00:04:02,130
incredible language for what it's good

00:03:58,049 --> 00:04:03,989
at when you're but when you're on the

00:04:02,130 --> 00:04:05,130
web you don't have a choice if you want

00:04:03,989 --> 00:04:07,170
to do something that JavaScript isn't

00:04:05,130 --> 00:04:08,190
good at you can't say all right I'm

00:04:07,170 --> 00:04:09,299
gonna go drop down to a different

00:04:08,190 --> 00:04:10,590
language because Java scripts is the

00:04:09,299 --> 00:04:12,299
only language the web understands

00:04:10,590 --> 00:04:16,799
natively it's the only part that's kind

00:04:12,299 --> 00:04:19,190
of baked into the spec of the web so

00:04:16,799 --> 00:04:24,390
that's the hole I think we need to fill

00:04:19,190 --> 00:04:27,780
let's talk about sass so sass is a CSS

00:04:24,390 --> 00:04:29,130
preprocessor that gives you lots of

00:04:27,780 --> 00:04:30,750
shortcuts and convenience functions when

00:04:29,130 --> 00:04:31,620
you're writing style sheets and it was

00:04:30,750 --> 00:04:33,770
originally written in a high-level

00:04:31,620 --> 00:04:36,479
language was originally written in Ruby

00:04:33,770 --> 00:04:36,750
but one of the difficulties with high

00:04:36,479 --> 00:04:38,700
level

00:04:36,750 --> 00:04:41,040
languages is that they have opinions

00:04:38,700 --> 00:04:42,690
about the world right like JavaScript

00:04:41,040 --> 00:04:45,840
has ideas about what an object is what a

00:04:42,690 --> 00:04:47,250
string is what an array is and that

00:04:45,840 --> 00:04:48,450
makes it harder to combine with other

00:04:47,250 --> 00:04:50,280
languages because you have to kind of

00:04:48,450 --> 00:04:54,410
bring like all of Ruby along with you

00:04:50,280 --> 00:04:57,390
and so sass is re-written as libsass

00:04:54,410 --> 00:04:59,640
which is in c and c++ and those

00:04:57,390 --> 00:05:01,470
lower-level languages make it easier to

00:04:59,640 --> 00:05:03,480
embed sass in other places because the

00:05:01,470 --> 00:05:06,330
lower-level languages don't need as much

00:05:03,480 --> 00:05:10,170
support from you know their language

00:05:06,330 --> 00:05:13,920
runtime and so libsass wrappers exists

00:05:10,170 --> 00:05:16,980
in crystals go java javascript lua net

00:05:13,920 --> 00:05:19,950
this whole list of languages where for

00:05:16,980 --> 00:05:22,110
you as a programmer you can you know if

00:05:19,950 --> 00:05:24,570
you're a node developer you can add node

00:05:22,110 --> 00:05:26,730
sass to your package JSON and what you

00:05:24,570 --> 00:05:28,010
get back is a JavaScript module that

00:05:26,730 --> 00:05:32,490
looks and feels like a JavaScript module

00:05:28,010 --> 00:05:34,140
but at its center is this C++ file

00:05:32,490 --> 00:05:37,830
that's been compiled down and it works

00:05:34,140 --> 00:05:39,990
in and everything is great if I then

00:05:37,830 --> 00:05:43,080
went to Ruby or I went to net or I went

00:05:39,990 --> 00:05:44,730
to go I could use that same libsass core

00:05:43,080 --> 00:05:47,040
and wrap it in a different language and

00:05:44,730 --> 00:05:48,330
that portability is one of the more

00:05:47,040 --> 00:05:52,620
useful characteristics of these

00:05:48,330 --> 00:05:55,470
lower-level languages if you look at

00:05:52,620 --> 00:05:56,910
note SAS it gets downloaded more than

00:05:55,470 --> 00:05:59,730
three and a half million times a week

00:05:56,910 --> 00:06:01,800
and the difficulty was having this

00:05:59,730 --> 00:06:03,660
native core is that when you're

00:06:01,800 --> 00:06:05,940
compiling it you're compiling to machine

00:06:03,660 --> 00:06:07,320
code and that means you have to compile

00:06:05,940 --> 00:06:08,280
it differently depending on what

00:06:07,320 --> 00:06:10,050
operating system you're targeting

00:06:08,280 --> 00:06:12,270
Windows Mac or Linux and not just that

00:06:10,050 --> 00:06:15,120
you have to compile it differently for

00:06:12,270 --> 00:06:18,330
which CPU architecture that operating

00:06:15,120 --> 00:06:20,880
systems running on so is it Intel is it

00:06:18,330 --> 00:06:23,730
arm is that 32-bit 64-bit is that Linux

00:06:20,880 --> 00:06:26,340
or is it Mac and so what you get with

00:06:23,730 --> 00:06:27,960
note SAS what in your experience as a

00:06:26,340 --> 00:06:30,600
developer is just like a single line in

00:06:27,960 --> 00:06:34,290
your like packaged up JSON depend on

00:06:30,600 --> 00:06:37,830
node SAS actually has this big matrix of

00:06:34,290 --> 00:06:39,420
supported environments where you have

00:06:37,830 --> 00:06:42,350
this this combinatoric explosion where

00:06:39,420 --> 00:06:45,090
every time I note SAS release happens

00:06:42,350 --> 00:06:47,580
hundreds of megabytes of pre-compile

00:06:45,090 --> 00:06:49,200
bindings get generated for every

00:06:47,580 --> 00:06:50,340
combination of operating system CPU

00:06:49,200 --> 00:06:54,750
architecture

00:06:50,340 --> 00:06:56,760
version of nodejs and this is really

00:06:54,750 --> 00:06:58,620
difficult because to do this it means

00:06:56,760 --> 00:07:00,000
you have to know like exactly what all

00:06:58,620 --> 00:07:01,110
the machines you need to support are in

00:07:00,000 --> 00:07:02,880
fly somebody comes along with a

00:07:01,110 --> 00:07:04,199
different type of machine like all of

00:07:02,880 --> 00:07:05,240
our phones are unarmed chipsets which

00:07:04,199 --> 00:07:08,850
nobody could have predicted that

00:07:05,240 --> 00:07:12,680
dethroning intel 20 years ago then like

00:07:08,850 --> 00:07:15,360
oops now you have to add another one and

00:07:12,680 --> 00:07:17,520
so what feels like a single little thing

00:07:15,360 --> 00:07:19,620
is actually one of these like massive

00:07:17,520 --> 00:07:22,169
combinations of all these different

00:07:19,620 --> 00:07:24,830
variables right and the problem with

00:07:22,169 --> 00:07:27,600
this is that none of these are the web

00:07:24,830 --> 00:07:28,680
right note SAS works in node notice on

00:07:27,600 --> 00:07:30,720
the server side no it isn't in your

00:07:28,680 --> 00:07:33,660
browser and so if I wanted to use

00:07:30,720 --> 00:07:37,470
libsass on my browser this doesn't help

00:07:33,660 --> 00:07:38,820
me and it's really important to find a

00:07:37,470 --> 00:07:40,200
way to bring that code to the web

00:07:38,820 --> 00:07:42,000
because the web is the universal

00:07:40,200 --> 00:07:44,430
platform the web goes everywhere and

00:07:42,000 --> 00:07:46,350
it's durable at last you can load the

00:07:44,430 --> 00:07:52,440
very first web page in a modern browser

00:07:46,350 --> 00:07:53,970
and it still renders 20 years on and

00:07:52,440 --> 00:07:55,260
it's hard to predict where the web will

00:07:53,970 --> 00:07:57,660
go next it's hard to predict where

00:07:55,260 --> 00:08:01,950
computing will go next a few years ago

00:07:57,660 --> 00:08:04,710
somebody at LG instructed someone to put

00:08:01,950 --> 00:08:06,780
windows on a fridge which makes a lot of

00:08:04,710 --> 00:08:08,220
sense except they took it really

00:08:06,780 --> 00:08:10,950
literally and put windows on a fridge

00:08:08,220 --> 00:08:13,500
and then on this fridge because this

00:08:10,950 --> 00:08:15,960
fridge has windows it also has a browser

00:08:13,500 --> 00:08:17,910
and so now the web goes to this fridge

00:08:15,960 --> 00:08:20,580
and now everything that's ever been

00:08:17,910 --> 00:08:23,760
created on the web is available on this

00:08:20,580 --> 00:08:26,220
fridge and that's that's amazing because

00:08:23,760 --> 00:08:27,840
I mean Samsung also did the same thing

00:08:26,220 --> 00:08:32,010
and so now like there's this whole

00:08:27,840 --> 00:08:33,089
separate universe of fridge web but but

00:08:32,010 --> 00:08:34,709
the nice thing about fridge web is

00:08:33,089 --> 00:08:36,959
fridge web is not different from normal

00:08:34,709 --> 00:08:39,419
web fridge web is just the web on your

00:08:36,959 --> 00:08:41,279
fridge and that's the power of the web

00:08:39,419 --> 00:08:42,870
you can't necessarily predict where it's

00:08:41,279 --> 00:08:45,870
going to go but when it gets there it

00:08:42,870 --> 00:08:47,459
brings the whole web with it and we want

00:08:45,870 --> 00:08:48,990
to be able to access all of these

00:08:47,459 --> 00:08:50,850
libraries and all these tools things

00:08:48,990 --> 00:08:53,670
like Lib sets that have been created in

00:08:50,850 --> 00:08:55,170
the world on the web platform but we

00:08:53,670 --> 00:08:56,670
don't have that option around because

00:08:55,170 --> 00:08:58,110
our only option is JavaScript and

00:08:56,670 --> 00:09:01,700
JavaScript is a high-level language and

00:08:58,110 --> 00:09:01,700
has really strong opinions about things

00:09:02,959 --> 00:09:08,190
so what do we do well we're not gonna

00:09:06,390 --> 00:09:09,990
add machine code to the web like that'd

00:09:08,190 --> 00:09:11,550
be a security nightmare and be hardened

00:09:09,990 --> 00:09:13,920
me too we'd have to predict everywhere

00:09:11,550 --> 00:09:15,480
the web goes instead what we're gonna

00:09:13,920 --> 00:09:17,970
try to do is create something called web

00:09:15,480 --> 00:09:20,279
assembly which is just one step over

00:09:17,970 --> 00:09:22,470
from machine code it looks and feels

00:09:20,279 --> 00:09:25,410
like machine code but it's not for a

00:09:22,470 --> 00:09:29,370
real processor and what webassembly does

00:09:25,410 --> 00:09:30,690
is it's kind of like compiling a machine

00:09:29,370 --> 00:09:32,490
code but because it's a virtual machine

00:09:30,690 --> 00:09:35,339
we can then have a run time in your

00:09:32,490 --> 00:09:36,779
browser or inside node that looks at

00:09:35,339 --> 00:09:39,510
that web assembly and converts it to

00:09:36,779 --> 00:09:43,829
machine code and like and what that

00:09:39,510 --> 00:09:45,209
machine code is is like I mean this is

00:09:43,829 --> 00:09:47,220
complicated you'll never have to look at

00:09:45,209 --> 00:09:48,750
it and deals it yourself but it's pretty

00:09:47,220 --> 00:09:52,200
simple well of assembly just knows about

00:09:48,750 --> 00:09:54,029
numbers and memory like it's a CPU it

00:09:52,200 --> 00:09:56,640
can't interact with the outside world it

00:09:54,029 --> 00:09:58,140
can do math but it turns out a lot of

00:09:56,640 --> 00:09:59,100
things kind of can be reduced down to

00:09:58,140 --> 00:10:00,510
math and so when you look at the

00:09:59,100 --> 00:10:03,600
operations that web assembly supports

00:10:00,510 --> 00:10:07,620
you have things like for integers you

00:10:03,600 --> 00:10:09,570
can add and subtract and multiply you

00:10:07,620 --> 00:10:11,310
can shift left and right and shifting is

00:10:09,570 --> 00:10:15,329
just like you move all the bits over and

00:10:11,310 --> 00:10:17,579
that has some useful properties for

00:10:15,329 --> 00:10:19,709
floats you can divide you can minimum

00:10:17,579 --> 00:10:21,540
you can maximum I mean like it's math

00:10:19,709 --> 00:10:27,300
this is what web assembly operations are

00:10:21,540 --> 00:10:29,970
it's just a whole bunch of math but if

00:10:27,300 --> 00:10:31,560
your browser can turn that math into in

00:10:29,970 --> 00:10:34,620
those operations and operations that

00:10:31,560 --> 00:10:36,120
your real CPU understands then instead

00:10:34,620 --> 00:10:38,370
of creating those hundreds of

00:10:36,120 --> 00:10:39,510
combinations of notes ass bindings you

00:10:38,370 --> 00:10:40,949
could just compile it once to web

00:10:39,510 --> 00:10:42,600
assembly and distribute that and it will

00:10:40,949 --> 00:10:46,399
work no matter where you are as long as

00:10:42,600 --> 00:10:46,399
you're somewhere that has a web platform

00:10:46,430 --> 00:10:53,699
and one of the nice things about this is

00:10:49,680 --> 00:10:55,290
that web assembly modules web assembly

00:10:53,699 --> 00:10:56,850
is modular and the modules act a lot

00:10:55,290 --> 00:10:58,920
like JavaScript modules where they say

00:10:56,850 --> 00:11:00,000
here's here the functions I need from

00:10:58,920 --> 00:11:01,350
the outside world and here are the

00:11:00,000 --> 00:11:03,750
functions that I'm going to let you call

00:11:01,350 --> 00:11:05,610
from me here's what I'm providing and

00:11:03,750 --> 00:11:08,339
that means that web assembly can kind of

00:11:05,610 --> 00:11:10,260
coexist with JavaScript so you can have

00:11:08,339 --> 00:11:11,699
a JavaScript library that parts of it

00:11:10,260 --> 00:11:12,930
might be re-implemented web assembly and

00:11:11,699 --> 00:11:14,130
parts of it might be implemented in

00:11:12,930 --> 00:11:15,030
JavaScript and they can kind of all

00:11:14,130 --> 00:11:17,100
depend on each

00:11:15,030 --> 00:11:18,600
but the nice thing about it is that for

00:11:17,100 --> 00:11:21,000
you as a developer you don't have to

00:11:18,600 --> 00:11:23,400
care about that because just like notes

00:11:21,000 --> 00:11:24,570
tasks can wrap up a C++ library and it

00:11:23,400 --> 00:11:26,850
looks and feels like a JavaScript

00:11:24,570 --> 00:11:28,110
library well what was simply can also

00:11:26,850 --> 00:11:30,240
look and feel like a JavaScript library

00:11:28,110 --> 00:11:32,910
and you can kind of end up benefiting

00:11:30,240 --> 00:11:34,830
from these lower level options which you

00:11:32,910 --> 00:11:36,960
might want to reach for if you have like

00:11:34,830 --> 00:11:39,720
a math problem something that needs a

00:11:36,960 --> 00:11:40,650
lot of computational efficiency but you

00:11:39,720 --> 00:11:41,880
don't have to worry about whether

00:11:40,650 --> 00:11:43,440
something you don't have to learn

00:11:41,880 --> 00:11:46,050
something new it can kind of work just

00:11:43,440 --> 00:11:47,340
the same as your existing libraries that

00:11:46,050 --> 00:11:49,320
you're relying on it just happens to be

00:11:47,340 --> 00:11:52,950
that like if you opened it up it would

00:11:49,320 --> 00:11:54,300
look different inside and that's okay to

00:11:52,950 --> 00:11:58,260
give you a sense of like what that looks

00:11:54,300 --> 00:12:01,140
like on the on the far left is a C

00:11:58,260 --> 00:12:03,960
program a C function that just takes it

00:12:01,140 --> 00:12:06,660
a variable X and returns X divided by 4

00:12:03,960 --> 00:12:08,580
and when you compile that to web

00:12:06,660 --> 00:12:12,150
assembly what you get out is this

00:12:08,580 --> 00:12:14,370
function that says ok the way I'm going

00:12:12,150 --> 00:12:17,060
to implement this is I'm going to get

00:12:14,370 --> 00:12:19,050
the variable I pass in get var 0 and

00:12:17,060 --> 00:12:20,490
then it's a stack machine so it like

00:12:19,050 --> 00:12:22,890
puts that on the stack and then it gets

00:12:20,490 --> 00:12:25,110
the constant value of 4 and it calls

00:12:22,890 --> 00:12:30,540
divide s like sign division so it pops

00:12:25,110 --> 00:12:32,100
those often divides them that's that's

00:12:30,540 --> 00:12:35,430
what that see compiled into you this is

00:12:32,100 --> 00:12:36,630
webassembly again you don't have to ever

00:12:35,430 --> 00:12:37,980
know of assembly you know another

00:12:36,630 --> 00:12:40,290
language and that language compiles to

00:12:37,980 --> 00:12:41,400
web assembly but I want you to see kind

00:12:40,290 --> 00:12:44,610
of what's inside to give you a better

00:12:41,400 --> 00:12:46,140
understanding the thing about division

00:12:44,610 --> 00:12:49,770
is that division is a pretty expensive

00:12:46,140 --> 00:12:51,780
operation for a CPU and if you're in a

00:12:49,770 --> 00:12:53,670
language like C what you can do is you

00:12:51,780 --> 00:12:56,430
can actually provide more type

00:12:53,670 --> 00:12:58,230
information like JavaScript typescript

00:12:56,430 --> 00:13:02,280
exists because JavaScript doesn't have

00:12:58,230 --> 00:13:04,110
type information right and so with C I

00:13:02,280 --> 00:13:05,640
could say instead of saying the X is an

00:13:04,110 --> 00:13:07,410
integer X as a number I can say it's an

00:13:05,640 --> 00:13:10,170
unsigned integer which means it will

00:13:07,410 --> 00:13:14,240
always be positive and if I do that and

00:13:10,170 --> 00:13:14,240
recompile instead of dividing by 4

00:13:17,680 --> 00:13:21,130
who changes to shift right by two

00:13:19,480 --> 00:13:23,500
because every time you move the bits

00:13:21,130 --> 00:13:28,060
over to the right for a positive integer

00:13:23,500 --> 00:13:29,860
you have the value and so by having more

00:13:28,060 --> 00:13:31,480
type information up front we can compile

00:13:29,860 --> 00:13:33,070
to much more efficient code and

00:13:31,480 --> 00:13:35,050
webassembly kind gives you those little

00:13:33,070 --> 00:13:37,089
knobs to tweak if you really want to get

00:13:35,050 --> 00:13:39,130
really close to the Machine and say

00:13:37,089 --> 00:13:41,290
exactly how an algorithm should be

00:13:39,130 --> 00:13:44,709
implemented which is not a problem that

00:13:41,290 --> 00:13:46,480
you face every day and like most people

00:13:44,709 --> 00:13:49,839
don't write assembly code in their

00:13:46,480 --> 00:13:52,180
professional careers but most of us rely

00:13:49,839 --> 00:13:53,890
on code that was written in assembly or

00:13:52,180 --> 00:13:55,660
that has some of these optimizations

00:13:53,890 --> 00:13:58,000
like somewhere in that stack of things

00:13:55,660 --> 00:14:00,250
like if you're running nodejs somewhere

00:13:58,000 --> 00:14:01,720
in there somebody took the time to look

00:14:00,250 --> 00:14:03,700
at an algorithm and say actually I think

00:14:01,720 --> 00:14:05,140
I can implement this very very

00:14:03,700 --> 00:14:07,300
efficiently if I do these very specific

00:14:05,140 --> 00:14:08,560
things and what would simply finally

00:14:07,300 --> 00:14:10,089
gives you that option on the web you

00:14:08,560 --> 00:14:12,790
didn't have that option with JavaScript

00:14:10,089 --> 00:14:15,130
and then when you give this web assembly

00:14:12,790 --> 00:14:17,529
to the browser the browser then converts

00:14:15,130 --> 00:14:19,240
it down to native processor instructions

00:14:17,529 --> 00:14:26,020
so for example that's what this would be

00:14:19,240 --> 00:14:29,290
on Intel CPU so just like to not scare

00:14:26,020 --> 00:14:30,459
you you don't have to know C even but

00:14:29,290 --> 00:14:32,950
like you don't have to know the other

00:14:30,459 --> 00:14:34,450
parts either the to use webOS symbol you

00:14:32,950 --> 00:14:36,459
learn a language that compiles to web

00:14:34,450 --> 00:14:42,010
assembly and then there's other things

00:14:36,459 --> 00:14:44,350
happen behind the scenes and this is

00:14:42,010 --> 00:14:48,250
real so this is a screenshot of can I

00:14:44,350 --> 00:14:50,860
use from October 2017 two years ago and

00:14:48,250 --> 00:14:54,670
two years ago web assembly got turned on

00:14:50,860 --> 00:14:56,740
by default in every major browser and so

00:14:54,670 --> 00:14:59,260
the ability to do this work the ability

00:14:56,740 --> 00:15:01,900
to have this low-level complement to

00:14:59,260 --> 00:15:06,730
high-level JavaScript has been here for

00:15:01,900 --> 00:15:10,000
two years have any of you knowingly used

00:15:06,730 --> 00:15:11,440
web assembly oh okay couple people I

00:15:10,000 --> 00:15:15,520
would like to know what you've done with

00:15:11,440 --> 00:15:18,940
it afterwards because for most of time

00:15:15,520 --> 00:15:21,880
like sorry I wanted to go back to this

00:15:18,940 --> 00:15:23,470
real quick so we have this compliment we

00:15:21,880 --> 00:15:25,510
had this missing piece the web didn't

00:15:23,470 --> 00:15:27,060
have a low-level language now it does so

00:15:25,510 --> 00:15:31,199
web technology is now these four things

00:15:27,060 --> 00:15:33,730
HTML CSS JavaScript and wasm

00:15:31,199 --> 00:15:35,079
but because wisdom is like a machine

00:15:33,730 --> 00:15:36,310
code and you don't use machine code

00:15:35,079 --> 00:15:38,889
directly really you write other

00:15:36,310 --> 00:15:40,660
languages to it we're still gonna think

00:15:38,889 --> 00:15:43,389
of the web in terms of HTML Javascript

00:15:40,660 --> 00:15:44,769
and CSS it just happens to be that other

00:15:43,389 --> 00:15:47,800
languages can now come to the web

00:15:44,769 --> 00:15:54,279
because there's this kind of side door

00:15:47,800 --> 00:15:55,600
that we've created if you want to get

00:15:54,279 --> 00:15:56,889
started with web assembly if you

00:15:55,600 --> 00:15:57,430
actually want to try creating some of

00:15:56,889 --> 00:16:01,060
this code

00:15:57,430 --> 00:16:02,440
I really recommend looking at rust rust

00:16:01,060 --> 00:16:04,870
of the language that started at Mozilla

00:16:02,440 --> 00:16:06,730
but is now driven by the community of

00:16:04,870 --> 00:16:08,949
open-source contributors that have have

00:16:06,730 --> 00:16:10,060
found it useful it's a mature language

00:16:08,949 --> 00:16:11,380
it's a great language and it's one of

00:16:10,060 --> 00:16:15,100
the first languages to stand up and say

00:16:11,380 --> 00:16:17,560
we explicitly want rust to be the best

00:16:15,100 --> 00:16:19,149
have the best web experience the best

00:16:17,560 --> 00:16:21,519
tooling the best error messages the best

00:16:19,149 --> 00:16:23,949
support the best community and they've

00:16:21,519 --> 00:16:26,680
done a great job of that but the first

00:16:23,949 --> 00:16:28,899
two years were really dominated by C and

00:16:26,680 --> 00:16:30,639
C++ because they're older languages

00:16:28,899 --> 00:16:33,399
they're well understood for some values

00:16:30,639 --> 00:16:35,079
of understood and those languages

00:16:33,399 --> 00:16:37,440
already have existing mature compilers

00:16:35,079 --> 00:16:41,050
and we could just say like take LLVM the

00:16:37,440 --> 00:16:43,990
playing C compiler and make it output to

00:16:41,050 --> 00:16:47,170
Azzam instead of native machine code and

00:16:43,990 --> 00:16:48,730
when you have that you get demos like

00:16:47,170 --> 00:16:52,870
this from Google i/o last year where the

00:16:48,730 --> 00:16:54,459
AutoCAD desktop design suite got

00:16:52,870 --> 00:16:58,180
compiled to web assembly and then you

00:16:54,459 --> 00:16:59,620
could run it in the browser if you can

00:16:58,180 --> 00:17:00,760
compile things like compile you can also

00:16:59,620 --> 00:17:02,380
compile DOSBox

00:17:00,760 --> 00:17:03,519
through web assembly if you have DOSBox

00:17:02,380 --> 00:17:05,709
and you can run Windows if you have

00:17:03,519 --> 00:17:08,110
Windows in you can run Netscape 3 and so

00:17:05,709 --> 00:17:10,740
this is Netscape running in Windows

00:17:08,110 --> 00:17:14,980
running inside Firefox running on a Mac

00:17:10,740 --> 00:17:17,290
and and this is all just being drawn out

00:17:14,980 --> 00:17:18,579
to an html5 canvas because all webOS

00:17:17,290 --> 00:17:21,459
only knows about his memory in numbers

00:17:18,579 --> 00:17:23,350
so all it's able to do is like paint the

00:17:21,459 --> 00:17:25,299
pixels into memory and then JavaScript

00:17:23,350 --> 00:17:29,110
has to go and look there and pull those

00:17:25,299 --> 00:17:31,150
pixels out and put them on a canvas but

00:17:29,110 --> 00:17:33,070
it works and that's cool it's not useful

00:17:31,150 --> 00:17:34,840
per se I mean it's useful for the

00:17:33,070 --> 00:17:37,150
Internet Archive the Internet Archive is

00:17:34,840 --> 00:17:38,980
using this to preserve old software you

00:17:37,150 --> 00:17:41,730
can boot up an old Mac and run hypercard

00:17:38,980 --> 00:17:44,169
in your browser thanks to web assembly

00:17:41,730 --> 00:17:47,200
or you can boot up Netscape and

00:17:44,169 --> 00:17:48,399
firefox but again because this is going

00:17:47,200 --> 00:17:50,139
to a canvas and because that's part of

00:17:48,399 --> 00:17:51,429
the web and web technology is amazing

00:17:50,139 --> 00:17:53,049
and web technology is open and

00:17:51,429 --> 00:17:55,690
interoperable you can then use that

00:17:53,049 --> 00:17:56,919
canvas as a texture in web VR and then

00:17:55,690 --> 00:18:00,309
you can pretend to be coding in a

00:17:56,919 --> 00:18:02,830
basement in the 90s and this is a demo

00:18:00,309 --> 00:18:03,820
from from April 2017 so stem owes more

00:18:02,830 --> 00:18:07,809
than two years old and I still think

00:18:03,820 --> 00:18:09,279
it's one of the coolest things taking

00:18:07,809 --> 00:18:11,049
that web assembly virtual machine and

00:18:09,279 --> 00:18:15,639
just like me like alright here's a

00:18:11,049 --> 00:18:17,080
texture here's a basement done and this

00:18:15,639 --> 00:18:18,789
is what I like to think of as the will

00:18:17,080 --> 00:18:21,369
it blend era of web assembly where all

00:18:18,789 --> 00:18:24,999
of a sudden we have this really powerful

00:18:21,369 --> 00:18:27,340
tool but we don't really know what to do

00:18:24,999 --> 00:18:29,350
with it and so so will it blend is this

00:18:27,340 --> 00:18:30,009
guy that sells blenders by putting

00:18:29,350 --> 00:18:32,230
phones in them

00:18:30,009 --> 00:18:34,359
and other objects all sorts of objects

00:18:32,230 --> 00:18:35,950
go in the blender and so in this case it

00:18:34,359 --> 00:18:39,299
was a question of like will an iPhone

00:18:35,950 --> 00:18:45,669
blend or will a galaxy phone blend and

00:18:39,299 --> 00:18:50,109
it turns out that they both blend for a

00:18:45,669 --> 00:18:52,299
I mean that does it like if I'm hungry

00:18:50,109 --> 00:18:54,429
that doesn't make me a smoothie I mean I

00:18:52,299 --> 00:18:57,460
guess it could but like knowing that

00:18:54,429 --> 00:19:00,009
knife own blends doesn't help me solve a

00:18:57,460 --> 00:19:01,629
real problem in my life and that's what

00:19:00,009 --> 00:19:02,799
these first kind of rounds of demos have

00:19:01,629 --> 00:19:04,149
been like we had this tool and we're

00:19:02,799 --> 00:19:05,649
like alright cool we have a compiler we

00:19:04,149 --> 00:19:08,919
can take existing code we can compile it

00:19:05,649 --> 00:19:10,419
and put it on the web but it's on the

00:19:08,919 --> 00:19:11,980
web it's not like part of the web and

00:19:10,419 --> 00:19:13,179
it's not necessarily practical and

00:19:11,980 --> 00:19:16,119
that's that's where I think we're headed

00:19:13,179 --> 00:19:20,049
is figuring out what more practical uses

00:19:16,119 --> 00:19:22,109
of web assembly are one example of that

00:19:20,049 --> 00:19:28,779
is this app called squash

00:19:22,109 --> 00:19:32,019
spelled squash app and this is by the

00:19:28,779 --> 00:19:34,899
the chrome dev rel team and what it is

00:19:32,019 --> 00:19:37,629
it's an online image optimizer so you

00:19:34,899 --> 00:19:39,460
can upload an image and then you can say

00:19:37,629 --> 00:19:43,359
like what happens if I recompress this

00:19:39,460 --> 00:19:45,039
as a JPEG or as a web P or as a PNG and

00:19:43,359 --> 00:19:49,269
you can change the quality so this is

00:19:45,039 --> 00:19:50,830
like a quality to JPEG versus the

00:19:49,269 --> 00:19:53,470
original image and that's kind of neat

00:19:50,830 --> 00:19:56,649
and one of the things that webassembly

00:19:53,470 --> 00:19:57,610
has allowed to happen is that these

00:19:56,649 --> 00:20:00,520
image code

00:19:57,610 --> 00:20:01,900
which are native code code bases that

00:20:00,520 --> 00:20:05,650
you know in the case of lib de peg go

00:20:01,900 --> 00:20:08,260
back decades they can now be compiled to

00:20:05,650 --> 00:20:09,730
a dot wiesen file and unloaded in your

00:20:08,260 --> 00:20:11,710
browser and you can run these image

00:20:09,730 --> 00:20:14,320
codecs you can like encode an image from

00:20:11,710 --> 00:20:15,460
Lib JPEG or Lib blood P right in your

00:20:14,320 --> 00:20:17,230
browser without having to go back to a

00:20:15,460 --> 00:20:18,929
server so you can do the compression and

00:20:17,230 --> 00:20:21,100
the optimization on the client side

00:20:18,929 --> 00:20:23,110
without having to rewrite these in

00:20:21,100 --> 00:20:24,370
JavaScript like you're reusing existing

00:20:23,110 --> 00:20:27,100
code and that's really cool that's

00:20:24,370 --> 00:20:30,220
really powerful and I think that's a

00:20:27,100 --> 00:20:31,540
practical use of web assembly one of the

00:20:30,220 --> 00:20:34,780
other things that that this team did is

00:20:31,540 --> 00:20:37,660
they wanted to add base really basic

00:20:34,780 --> 00:20:38,950
editing functions to squash and

00:20:37,660 --> 00:20:43,030
particularly wanted to be able to rotate

00:20:38,950 --> 00:20:45,190
images and you can think about rotating

00:20:43,030 --> 00:20:46,480
is like a case where a low-level image

00:20:45,190 --> 00:20:47,710
could be useful because like all you're

00:20:46,480 --> 00:20:48,790
doing is you're taking this pixel here

00:20:47,710 --> 00:20:50,350
and you're moving it there and then this

00:20:48,790 --> 00:20:53,890
pixel and that pixel and this pixel in

00:20:50,350 --> 00:20:55,120
that pixel and having to to go through a

00:20:53,890 --> 00:20:56,380
garbage collector would be really

00:20:55,120 --> 00:20:58,750
inefficient like if you could just

00:20:56,380 --> 00:21:00,730
manually say move this memory copy this

00:20:58,750 --> 00:21:02,940
memory to this location and vice versa

00:21:00,730 --> 00:21:06,760
you could make that more efficient a

00:21:02,940 --> 00:21:08,320
release that was the hypothesis and so

00:21:06,760 --> 00:21:10,809
what the scheme does they implemented

00:21:08,320 --> 00:21:12,640
the rotation in JavaScript and this is a

00:21:10,809 --> 00:21:14,140
logarithmic scale of how long it took

00:21:12,640 --> 00:21:17,799
different browsers to rotate a really

00:21:14,140 --> 00:21:20,770
big image and two of the browsers could

00:21:17,799 --> 00:21:23,320
do it in under half a second but another

00:21:20,770 --> 00:21:24,880
browser took two and a half seconds and

00:21:23,320 --> 00:21:27,640
if their browser took more than eight

00:21:24,880 --> 00:21:29,320
seconds to do the same operation and so

00:21:27,640 --> 00:21:30,429
one of the challenges with JavaScript

00:21:29,320 --> 00:21:32,770
because it's a high-level language

00:21:30,429 --> 00:21:35,740
because it's a very complex language in

00:21:32,770 --> 00:21:39,520
a very dynamic language you have to be

00:21:35,740 --> 00:21:41,230
really really clever to optimize it and

00:21:39,520 --> 00:21:44,049
to get a really efficient JavaScript

00:21:41,230 --> 00:21:45,640
engine and so two of the browsers were

00:21:44,049 --> 00:21:49,000
able to figure out like what was going

00:21:45,640 --> 00:21:50,679
on and kind of guess and make native

00:21:49,000 --> 00:21:52,900
code that would go really fast for that

00:21:50,679 --> 00:21:54,309
that rotation operation and who the

00:21:52,900 --> 00:21:56,679
browser's weren't able to make the same

00:21:54,309 --> 00:21:58,510
optimization and that's just because

00:21:56,679 --> 00:22:00,220
JavaScript is hard to optimize it's a

00:21:58,510 --> 00:22:03,250
complex language it's a capable language

00:22:00,220 --> 00:22:04,630
but it's a complex language and so what

00:22:03,250 --> 00:22:06,130
they did then was they reimplemented

00:22:04,630 --> 00:22:08,620
that same exact algorithm that same

00:22:06,130 --> 00:22:09,600
exact function in three languages that

00:22:08,620 --> 00:22:11,470
compiled a webassembly

00:22:09,600 --> 00:22:14,649
c assembly script

00:22:11,470 --> 00:22:17,440
and JA and rust and compared to the

00:22:14,649 --> 00:22:20,649
JavaScript all of them were more or less

00:22:17,440 --> 00:22:23,169
on par with the fastest browsers in

00:22:20,649 --> 00:22:25,389
JavaScript but the variance was much

00:22:23,169 --> 00:22:26,740
smaller and the idea is that because web

00:22:25,389 --> 00:22:29,049
assembly is very very simple and web

00:22:26,740 --> 00:22:32,620
assembly is very very kind of dumb it's

00:22:29,049 --> 00:22:34,090
just math on numbers and memory you

00:22:32,620 --> 00:22:36,940
don't have to be as clever to get an

00:22:34,090 --> 00:22:38,860
efficient runtime you still need a good

00:22:36,940 --> 00:22:41,169
compiler to generate good web assembly

00:22:38,860 --> 00:22:42,850
but but then that web assembly will run

00:22:41,169 --> 00:22:45,929
with very similar performance

00:22:42,850 --> 00:22:48,009
characteristics everywhere

00:22:45,929 --> 00:22:49,600
and so I thought this was kind of cool

00:22:48,009 --> 00:22:51,700
because it says if you if you have a

00:22:49,600 --> 00:22:53,440
program for working a web app and you

00:22:51,700 --> 00:22:55,600
find out that like one function is

00:22:53,440 --> 00:22:58,000
really really pegging the CPU and really

00:22:55,600 --> 00:22:59,830
really making your app go slow depending

00:22:58,000 --> 00:23:02,230
on why that is you may be able to

00:22:59,830 --> 00:23:03,519
rewrite just that one function with

00:23:02,230 --> 00:23:05,350
something in rust or something else that

00:23:03,519 --> 00:23:08,740
compiles to web assembly and then

00:23:05,350 --> 00:23:09,970
address that hotspot and so that that's

00:23:08,740 --> 00:23:11,799
kind of the idea of web assembly in the

00:23:09,970 --> 00:23:14,110
browser we want you to be able to bring

00:23:11,799 --> 00:23:15,820
in native code bases to the web and we

00:23:14,110 --> 00:23:18,370
want you to be able to optimize and

00:23:15,820 --> 00:23:21,250
write more efficient code where you need

00:23:18,370 --> 00:23:23,409
that efficiency does it replace

00:23:21,250 --> 00:23:26,139
JavaScript coexist with it it's a it's a

00:23:23,409 --> 00:23:30,820
compliment high-level language low-level

00:23:26,139 --> 00:23:31,840
language but what about Java or what

00:23:30,820 --> 00:23:36,399
about web assembly outside of the

00:23:31,840 --> 00:23:38,080
browser so web technology HTML CSS and

00:23:36,399 --> 00:23:40,110
JavaScript a couple years ago a guy

00:23:38,080 --> 00:23:43,690
named Ryan Dahl was like wait a second

00:23:40,110 --> 00:23:46,090
maybe javascript is useful on its own

00:23:43,690 --> 00:23:49,899
maybe it doesn't need to only be in the

00:23:46,090 --> 00:23:51,730
browser and he created nodejs and it was

00:23:49,899 --> 00:23:55,299
a complete failure and no one uses note

00:23:51,730 --> 00:23:59,470
today and and we've all learned from our

00:23:55,299 --> 00:24:01,120
mistakes no so notice is hugely popular

00:23:59,470 --> 00:24:02,649
javascript is a good language it's great

00:24:01,120 --> 00:24:05,710
on the web it's also great outside of

00:24:02,649 --> 00:24:07,690
the web and then because note is based

00:24:05,710 --> 00:24:10,059
on v8 the JavaScript engine that's also

00:24:07,690 --> 00:24:11,500
used by chromium when v8 added support

00:24:10,059 --> 00:24:12,759
for web assembly node got support for

00:24:11,500 --> 00:24:14,980
web assembly and so now you can use

00:24:12,759 --> 00:24:18,159
these modules in your web assembly very

00:24:14,980 --> 00:24:19,840
use web semaj in your node and because

00:24:18,159 --> 00:24:22,750
other languages compiled a web assembly

00:24:19,840 --> 00:24:24,429
all of a sudden nodejs the runtime for

00:24:22,750 --> 00:24:25,740
the most popular programming language in

00:24:24,429 --> 00:24:29,950
the world

00:24:25,740 --> 00:24:31,990
now also supports other languages and it

00:24:29,950 --> 00:24:33,550
can do that efficiently and it can do

00:24:31,990 --> 00:24:34,960
that safely because it's not native

00:24:33,550 --> 00:24:36,340
machine code it's like it's trusting on

00:24:34,960 --> 00:24:39,420
the runtime to do that translation and

00:24:36,340 --> 00:24:42,190
keep things safe and that seems useful

00:24:39,420 --> 00:24:43,150
CloudFlare is a company that does a lot

00:24:42,190 --> 00:24:45,190
of things one of things they offer

00:24:43,150 --> 00:24:46,660
CloudFlare workers is edge computing and

00:24:45,190 --> 00:24:47,830
edge computing just means they have a

00:24:46,660 --> 00:24:49,420
bunch of servers all around the world

00:24:47,830 --> 00:24:50,740
and you upload your code to those

00:24:49,420 --> 00:24:52,570
servers and when somebody needs

00:24:50,740 --> 00:24:56,260
something like your code runs on the

00:24:52,570 --> 00:24:57,670
server closest to them but that means

00:24:56,260 --> 00:24:59,500
that like a whole bunch of people's code

00:24:57,670 --> 00:25:01,840
are all running on the same server and

00:24:59,500 --> 00:25:04,960
you don't want those to be able to to

00:25:01,840 --> 00:25:06,190
interfere with each other and so one of

00:25:04,960 --> 00:25:08,470
things that clubs Larry talked about was

00:25:06,190 --> 00:25:09,940
like a traditional way to isolate other

00:25:08,470 --> 00:25:12,100
people's code is to put them in virtual

00:25:09,940 --> 00:25:13,180
machines but virtual machines are really

00:25:12,100 --> 00:25:14,290
really heavyweight and they take a while

00:25:13,180 --> 00:25:17,650
to start up and they take a while to

00:25:14,290 --> 00:25:19,560
Reyn what if instead you could just

00:25:17,650 --> 00:25:22,240
start up a single instance of v8

00:25:19,560 --> 00:25:24,850
JavaScript engine that also supports web

00:25:22,240 --> 00:25:26,500
assembly and use the isolation features

00:25:24,850 --> 00:25:27,700
that are already built into v8 to

00:25:26,500 --> 00:25:29,980
achieve that same degree of isolation

00:25:27,700 --> 00:25:31,750
but without that massive start up

00:25:29,980 --> 00:25:33,610
overhead every time now there is still

00:25:31,750 --> 00:25:35,680
over at it does still take take work to

00:25:33,610 --> 00:25:37,750
start a v8 but you know if your clouds

00:25:35,680 --> 00:25:39,940
are you start at once and you can run

00:25:37,750 --> 00:25:42,400
thousands of people's code without any

00:25:39,940 --> 00:25:43,810
additional overhead and because web

00:25:42,400 --> 00:25:45,310
assembly if that code could be in rust

00:25:43,810 --> 00:25:48,780
or it could be in go or it could be in

00:25:45,310 --> 00:25:53,440
Swift all running on a common runtime

00:25:48,780 --> 00:25:54,460
and I think that's kind of cool but

00:25:53,440 --> 00:25:56,350
there's still a question of like there

00:25:54,460 --> 00:25:59,200
is still overhead right like there's

00:25:56,350 --> 00:26:01,650
still that corner where you have to

00:25:59,200 --> 00:26:03,970
start up the JavaScript version machine

00:26:01,650 --> 00:26:07,150
so is wubba soon but maybe what was some

00:26:03,970 --> 00:26:09,580
blaze useful outside of JavaScript right

00:26:07,150 --> 00:26:11,290
like if javascript is useful outside of

00:26:09,580 --> 00:26:13,480
the browser maybe web assembly is also

00:26:11,290 --> 00:26:18,040
useful outside of node and outside of

00:26:13,480 --> 00:26:19,870
the browser and so Mozilla and fastly

00:26:18,040 --> 00:26:21,100
have been working on two different web

00:26:19,870 --> 00:26:23,410
assembly runtimes that are completely

00:26:21,100 --> 00:26:25,830
standalone projects where he can take

00:26:23,410 --> 00:26:28,420
web assembly code and you can run it and

00:26:25,830 --> 00:26:29,710
you know it's it's very small and very

00:26:28,420 --> 00:26:32,920
efficient these runtimes are embeddable

00:26:29,710 --> 00:26:34,960
and the idea is that in the case of

00:26:32,920 --> 00:26:37,090
loose it which is fastly as open-source

00:26:34,960 --> 00:26:38,830
runtime for web assembly they can

00:26:37,090 --> 00:26:40,570
instantiate a web assembly module in

00:26:38,830 --> 00:26:43,210
skee microseconds with just a few

00:26:40,570 --> 00:26:46,059
kilobytes of memory overhead by

00:26:43,210 --> 00:26:48,460
comparison starting up v8 takes about

00:26:46,059 --> 00:26:51,039
five milliseconds so a hundred times

00:26:48,460 --> 00:26:53,440
more time and tens of megabytes of

00:26:51,039 --> 00:26:55,600
memory overhead and so depending on your

00:26:53,440 --> 00:26:56,919
use case like cloud fleurs approach is

00:26:55,600 --> 00:27:01,210
great if you have longer running things

00:26:56,919 --> 00:27:02,320
but if you just need web assembly you

00:27:01,210 --> 00:27:04,450
can make these things pop into existence

00:27:02,320 --> 00:27:05,769
run and then stop really really really

00:27:04,450 --> 00:27:10,419
quickly because web assembly is very

00:27:05,769 --> 00:27:11,710
small and very well defined and so the

00:27:10,419 --> 00:27:13,120
idea here is like I could have a program

00:27:11,710 --> 00:27:15,399
this is a you don't need to worry about

00:27:13,120 --> 00:27:16,809
the code it's fizzbuzz and rust and I

00:27:15,399 --> 00:27:18,779
can compile it to webassembly just by

00:27:16,809 --> 00:27:20,950
saying cargo build target web assembly

00:27:18,779 --> 00:27:24,309
it was weighing me about rusting having

00:27:20,950 --> 00:27:26,649
good tooling and I get back a dot woz on

00:27:24,309 --> 00:27:29,279
file and I can say why some time run

00:27:26,649 --> 00:27:31,779
this dot wasum file and I get fizzbuzz I

00:27:29,279 --> 00:27:33,399
could then take that same exact wise and

00:27:31,779 --> 00:27:36,850
file and put it in my browser and get

00:27:33,399 --> 00:27:38,440
fizzbuzz but one of the challenges is

00:27:36,850 --> 00:27:40,480
like when Ryan doll created new it he

00:27:38,440 --> 00:27:42,370
had to say wait a second how do I make

00:27:40,480 --> 00:27:43,570
this thing talk to the outside world if

00:27:42,370 --> 00:27:44,980
it doesn't have a browser attached so we

00:27:43,570 --> 00:27:47,409
had to build a standard library for node

00:27:44,980 --> 00:27:51,220
that did files and did network access

00:27:47,409 --> 00:27:52,480
and things like that with web assembly

00:27:51,220 --> 00:27:53,919
we also need that because what was

00:27:52,480 --> 00:27:55,750
somebody on its own is just like a CPU

00:27:53,919 --> 00:27:57,549
and a cpu without an operating system or

00:27:55,750 --> 00:27:58,720
anything else isn't able to do much

00:27:57,549 --> 00:28:02,649
isn't able to interact with the outside

00:27:58,720 --> 00:28:04,750
world and so we started proposing at

00:28:02,649 --> 00:28:06,460
Mozilla something called huazi the web

00:28:04,750 --> 00:28:08,169
assembly system interface and it's just

00:28:06,460 --> 00:28:09,789
a library for webassembly but it's a

00:28:08,169 --> 00:28:12,340
library that defines conventions around

00:28:09,789 --> 00:28:13,840
like prints front line like what should

00:28:12,340 --> 00:28:17,710
print line do what's a file

00:28:13,840 --> 00:28:19,779
what's a network path and and by doing

00:28:17,710 --> 00:28:22,389
that when my russ code called print line

00:28:19,779 --> 00:28:23,889
to print fizz or buzz or fizzbuzz in was

00:28:22,389 --> 00:28:26,620
some time while some time says alright

00:28:23,889 --> 00:28:29,139
the print instruction should print to

00:28:26,620 --> 00:28:31,690
the terminal but if I ran that in the

00:28:29,139 --> 00:28:34,240
browser that same function the same

00:28:31,690 --> 00:28:37,450
print function would get translated to a

00:28:34,240 --> 00:28:38,830
console log or the runtime may decide

00:28:37,450 --> 00:28:40,929
instead like maybe you're writing to a

00:28:38,830 --> 00:28:41,889
text area or whatever it's again just

00:28:40,929 --> 00:28:44,799
kind of like web assemblies like an

00:28:41,889 --> 00:28:47,200
abstraction over a CPU instruction huazi

00:28:44,799 --> 00:28:48,880
is an abstraction over an operating

00:28:47,200 --> 00:28:50,320
system standard library so it kind of

00:28:48,880 --> 00:28:51,760
gives you files and and that sort of

00:28:50,320 --> 00:28:52,190
stuff and that's what makes printing an

00:28:51,760 --> 00:28:56,899
input

00:28:52,190 --> 00:28:58,879
hood work does that make sense

00:28:56,899 --> 00:28:59,870
that's kind of so what was somebody's

00:28:58,879 --> 00:29:00,980
really great it's useful in the browser

00:28:59,870 --> 00:29:02,210
but we also think it might be useful

00:29:00,980 --> 00:29:04,490
outside the browser and we think it

00:29:02,210 --> 00:29:06,289
might be useful on its own and one of

00:29:04,490 --> 00:29:08,659
the really wild ideas about how it might

00:29:06,289 --> 00:29:11,029
be a salon zone is what bacilli it's

00:29:08,659 --> 00:29:12,980
kind of a universal library format and

00:29:11,029 --> 00:29:15,110
so it's really easy if level somebody

00:29:12,980 --> 00:29:16,129
knows about numbers it's easy to convert

00:29:15,110 --> 00:29:20,840
between JavaScript numbers and

00:29:16,129 --> 00:29:22,129
webassembly numbers but what if you want

00:29:20,840 --> 00:29:23,389
to deal with more than just numbers what

00:29:22,129 --> 00:29:27,649
if you want to deal with strings or

00:29:23,389 --> 00:29:29,269
arrays or objects well we wanted some

00:29:27,649 --> 00:29:30,950
sort of common interface type because

00:29:29,269 --> 00:29:32,149
like the idea if I'm writing rust to

00:29:30,950 --> 00:29:33,620
compile to webassembly and I'm also

00:29:32,149 --> 00:29:35,779
writing go to compile the web assembly

00:29:33,620 --> 00:29:37,970
the way those languages represent

00:29:35,779 --> 00:29:39,500
strings and memory is different and we

00:29:37,970 --> 00:29:42,889
need some sort of common translation

00:29:39,500 --> 00:29:47,529
layer that lets a string be a string and

00:29:42,889 --> 00:29:47,529
kind of automatically convert each way

00:29:48,340 --> 00:29:52,940
eight days ago

00:29:50,649 --> 00:29:55,580
lynn clark published an article on

00:29:52,940 --> 00:29:57,679
mozilla hacks hacks top mozilla.org kind

00:29:55,580 --> 00:30:00,409
of outlining this challenge with web

00:29:57,679 --> 00:30:02,990
assembly I really recommend reading the

00:30:00,409 --> 00:30:07,580
article I especially recommend watching

00:30:02,990 --> 00:30:10,429
the video but it's an excellent Lin is

00:30:07,580 --> 00:30:11,840
an amazing pedagogue like she will teach

00:30:10,429 --> 00:30:16,370
you things that you thought you knew

00:30:11,840 --> 00:30:17,769
it's awesome but well I think she talks

00:30:16,370 --> 00:30:19,700
about is the difficulty in moving

00:30:17,769 --> 00:30:20,899
complex data into and out of web

00:30:19,700 --> 00:30:22,759
assembly because it kind of it knows

00:30:20,899 --> 00:30:24,259
math and memory so how do you move a

00:30:22,759 --> 00:30:26,149
string well you have a lot of glue code

00:30:24,259 --> 00:30:27,470
a lot of boilerplate so if I want to

00:30:26,149 --> 00:30:27,980
take the string hello and move it to web

00:30:27,470 --> 00:30:30,559
assembly

00:30:27,980 --> 00:30:32,779
I need to convert it to a bunch of

00:30:30,559 --> 00:30:34,820
numbers and put those in memory and then

00:30:32,779 --> 00:30:36,350
tell the web assembly where in memory

00:30:34,820 --> 00:30:38,779
because I like until is a number like

00:30:36,350 --> 00:30:41,509
start reading at point to offset to and

00:30:38,779 --> 00:30:42,769
you'll find a string and so well

00:30:41,509 --> 00:30:44,659
suddenly does that and modifies the

00:30:42,769 --> 00:30:46,039
string does whatever it wants and then

00:30:44,659 --> 00:30:47,450
it has to pass in because it can only

00:30:46,039 --> 00:30:49,580
pass a number back say like all right

00:30:47,450 --> 00:30:52,129
take the number to look at this offset

00:30:49,580 --> 00:30:54,950
in memory JavaScript try to decode that

00:30:52,129 --> 00:30:57,559
memory back into a string and then

00:30:54,950 --> 00:30:59,419
you're done and it works like you can

00:30:57,559 --> 00:31:00,950
pass arbitrarily complex data this way

00:30:59,419 --> 00:31:02,210
but it's a lot of work and you have to

00:31:00,950 --> 00:31:03,590
do it separately you have to kind of

00:31:02,210 --> 00:31:05,290
like bundle your webassembly module at

00:31:03,590 --> 00:31:07,580
this weird glue code

00:31:05,290 --> 00:31:09,590
the idea behind the web assembly

00:31:07,580 --> 00:31:11,660
interface types is that it should be

00:31:09,590 --> 00:31:13,580
possible for the web assembly module

00:31:11,660 --> 00:31:16,220
this compiled binary file to have

00:31:13,580 --> 00:31:19,520
instructions bundled with it for how to

00:31:16,220 --> 00:31:21,650
do those conversions and if we get this

00:31:19,520 --> 00:31:22,640
right and if we succeed in getting kind

00:31:21,650 --> 00:31:25,160
of the this through the standards

00:31:22,640 --> 00:31:27,020
process and people agree and we like did

00:31:25,160 --> 00:31:29,030
the right thing then you get something

00:31:27,020 --> 00:31:31,040
like you see in the video this amazing

00:31:29,030 --> 00:31:32,540
demo where Lin takes a markdown parser

00:31:31,040 --> 00:31:36,500
written in rust called pull down see

00:31:32,540 --> 00:31:37,760
mark and she compiles it to web assembly

00:31:36,500 --> 00:31:39,559
and takes that file and runs it in the

00:31:37,760 --> 00:31:42,160
browser and so you say hash hello web

00:31:39,559 --> 00:31:44,600
you get a heading that says hello web

00:31:42,160 --> 00:31:47,300
but then you could take that same exact

00:31:44,600 --> 00:31:48,380
lazon file and run it inside node and

00:31:47,300 --> 00:31:50,150
say all right import render from

00:31:48,380 --> 00:31:52,940
markdown dot wasum console.log render

00:31:50,150 --> 00:31:55,850
hello node and you get HTML out that

00:31:52,940 --> 00:31:57,440
says hello node and this is the same

00:31:55,850 --> 00:31:59,720
exact library running in the browser and

00:31:57,440 --> 00:32:01,429
running in no tanned and the video kind

00:31:59,720 --> 00:32:03,920
of goes into how this works so please

00:32:01,429 --> 00:32:05,179
watch our video but then we say well

00:32:03,920 --> 00:32:06,590
wait a second if web assembly is so

00:32:05,179 --> 00:32:08,900
small and so efficient and if the

00:32:06,590 --> 00:32:10,010
runtimes are so small maybe we could

00:32:08,900 --> 00:32:12,410
just package up the wise and time

00:32:10,010 --> 00:32:14,000
runtime as a Python library and so in

00:32:12,410 --> 00:32:16,370
your Python program you could import R

00:32:14,000 --> 00:32:18,050
Azzam wise in time rather and then

00:32:16,370 --> 00:32:19,550
import any wowza module and treat it

00:32:18,050 --> 00:32:21,590
just like a Python library even though

00:32:19,550 --> 00:32:23,420
it's not even though there's no

00:32:21,590 --> 00:32:25,340
boilerplate or glue code or wrapper code

00:32:23,420 --> 00:32:28,130
and you can say alright well mark down

00:32:25,340 --> 00:32:30,230
dot render hash Hello Python and then

00:32:28,130 --> 00:32:32,240
Python also spits out HTML and so you

00:32:30,230 --> 00:32:34,730
have this single library being used in

00:32:32,240 --> 00:32:38,929
the browser on node and inside other

00:32:34,730 --> 00:32:42,440
languages which just blew my mind so you

00:32:38,929 --> 00:32:44,270
can like web assembly all the things and

00:32:42,440 --> 00:32:45,650
this is this is something I find really

00:32:44,270 --> 00:32:48,890
interesting because this is an example

00:32:45,650 --> 00:32:50,240
of the web community which is

00:32:48,890 --> 00:32:51,350
fundamentally based on the idea of

00:32:50,240 --> 00:32:54,590
standards and openness and

00:32:51,350 --> 00:32:57,050
interoperability realizing there was

00:32:54,590 --> 00:32:58,640
something missing from the browser we

00:32:57,050 --> 00:33:01,250
had a high level language we needed a

00:32:58,640 --> 00:33:04,910
low level language and after 22 years we

00:33:01,250 --> 00:33:05,870
have one but we built that carefully and

00:33:04,910 --> 00:33:07,790
deliberately because the web is

00:33:05,870 --> 00:33:10,820
everywhere in the web is forever and we

00:33:07,790 --> 00:33:12,500
did it well enough that that's gonna

00:33:10,820 --> 00:33:13,460
solve some real problems outside of the

00:33:12,500 --> 00:33:15,260
browser whether somebody has the

00:33:13,460 --> 00:33:17,090
potential to solve nodes module problem

00:33:15,260 --> 00:33:18,590
with native modules not that's a problem

00:33:17,090 --> 00:33:19,250
but like it can have problems as you saw

00:33:18,590 --> 00:33:22,309
this

00:33:19,250 --> 00:33:24,409
with notes ass and we've also created

00:33:22,309 --> 00:33:26,360
something that is efficient enough to be

00:33:24,409 --> 00:33:30,049
useful perhaps even embedded in other

00:33:26,360 --> 00:33:30,980
languages and I'm really proud of of how

00:33:30,049 --> 00:33:32,270
we've done this I'm really proud of

00:33:30,980 --> 00:33:33,890
Mozilla's role in doing this because

00:33:32,270 --> 00:33:35,690
this this has allowed us to create

00:33:33,890 --> 00:33:39,020
something that I think will be truly

00:33:35,690 --> 00:33:41,679
transformative to to how we build run

00:33:39,020 --> 00:33:44,330
and distribute software in the future I

00:33:41,679 --> 00:33:45,679
hope this has been useful I hope this is

00:33:44,330 --> 00:33:48,590
kind of giving you the mental framework

00:33:45,679 --> 00:33:51,350
to approach webassembly so that we can

00:33:48,590 --> 00:33:53,270
start moving from will it blend to this

00:33:51,350 --> 00:33:58,370
is a useful tool that I know about and I

00:33:53,270 --> 00:34:00,200
can can put in my toolbox and with that

00:33:58,370 --> 00:34:01,640
if you have any questions I'm gonna

00:34:00,200 --> 00:34:03,049
stick around for a while as will the

00:34:01,640 --> 00:34:05,750
other speakers you can find me on

00:34:03,049 --> 00:34:07,460
twitter as cala had this is the end of

00:34:05,750 --> 00:34:10,040
our road show this is the our last stop

00:34:07,460 --> 00:34:12,560
this is the last talk

00:34:10,040 --> 00:34:13,520
please stay talk to us let us know how

00:34:12,560 --> 00:34:15,379
we did let us know what you're

00:34:13,520 --> 00:34:17,300
interested and let us know what we need

00:34:15,379 --> 00:34:20,000
to build at Mozilla to make the web

00:34:17,300 --> 00:34:21,139
better for you thank you so much for

00:34:20,000 --> 00:34:23,030
coming out thank you so much for your

00:34:21,139 --> 00:34:25,450
time I hope you've enjoyed it I hope you

00:34:23,030 --> 00:34:25,450
have a good night

00:34:33,659 --> 00:34:38,829
you

00:34:35,659 --> 00:34:38,829

YouTube URL: https://www.youtube.com/watch?v=RUAXPOSVV1A


