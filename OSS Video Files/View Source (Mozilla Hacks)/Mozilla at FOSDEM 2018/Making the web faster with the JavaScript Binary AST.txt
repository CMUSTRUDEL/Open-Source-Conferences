Title: Making the web faster with the JavaScript Binary AST
Publication date: 2018-02-23
Playlist: Mozilla at FOSDEM 2018
Description: 
	Presented by David Teller. 

First presented at FOSDEM, Feb 3, 2018. 
(https://fosdem.org/2018/schedule/event/mozilla_web_faster_js_binary_ast/)

These talks have been recorded at FOSDEM (https://fosdem.org/) This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence. To view a copy of this licence, visit:
https://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:02:51,659 --> 00:03:05,769
hello so it's great because earlier we

00:03:02,049 --> 00:03:08,109
had presentations on performance then we

00:03:05,769 --> 00:03:09,730
had a presentation of the future and I'm

00:03:08,109 --> 00:03:12,730
going to talk to you a little bit about

00:03:09,730 --> 00:03:17,409
the future of performance admire the

00:03:12,730 --> 00:03:20,019
transition so this presentation is about

00:03:17,409 --> 00:03:22,060
the JavaScript binary AST I'm going to

00:03:20,019 --> 00:03:24,849
give details about what that means but

00:03:22,060 --> 00:03:26,799
what is it it's a proposal for the

00:03:24,849 --> 00:03:28,000
future of JavaScript it's a new

00:03:26,799 --> 00:03:30,430
technology that we are currently

00:03:28,000 --> 00:03:33,430
developing at Mozilla and Bloomberg and

00:03:30,430 --> 00:03:39,840
Facebook to speed up the loading of web

00:03:33,430 --> 00:03:43,569
pages in the not so distant future so

00:03:39,840 --> 00:03:45,459
it's great the web is fast we keep

00:03:43,569 --> 00:03:47,739
improving the web we keep making it

00:03:45,459 --> 00:03:51,549
faster but of course there is no such

00:03:47,739 --> 00:03:54,340
thing as fast enough we have pretty fast

00:03:51,549 --> 00:03:56,680
JavaScript engines these days javascript

00:03:54,340 --> 00:04:00,010
is fast enough to run video games which

00:03:56,680 --> 00:04:03,150
is a few years ago who would have said

00:04:00,010 --> 00:04:06,280
that it would be possible however

00:04:03,150 --> 00:04:10,269
sometimes the performance of JavaScript

00:04:06,280 --> 00:04:13,720
is not sufficient for several reasons

00:04:10,269 --> 00:04:16,630
but one of them is look at how much data

00:04:13,720 --> 00:04:19,150
you're loading when you are opening

00:04:16,630 --> 00:04:22,360
Google sheets or Google Docs or Yahoo or

00:04:19,150 --> 00:04:26,289
LinkedIn or Facebook all of them just

00:04:22,360 --> 00:04:29,020
before they can do anything useful load

00:04:26,289 --> 00:04:32,289
at least 3 megabytes of compressed

00:04:29,020 --> 00:04:33,120
JavaScript code so much more if you

00:04:32,289 --> 00:04:35,979
decompress it

00:04:33,120 --> 00:04:39,699
we have noticed several of them that

00:04:35,979 --> 00:04:42,520
load something like seven megabytes and

00:04:39,699 --> 00:04:45,190
the decompressed size can go to up to 40

00:04:42,520 --> 00:04:47,289
megabytes imagine loading 40 megabytes

00:04:45,190 --> 00:04:49,690
of code in your browser whenever you

00:04:47,289 --> 00:04:51,600
start your application you don't do this

00:04:49,690 --> 00:04:53,660
with your desktop applications

00:04:51,600 --> 00:04:57,930
applications and to make things worse

00:04:53,660 --> 00:05:00,240
these websites are dated very often it's

00:04:57,930 --> 00:05:03,360
usually not the scale of every five

00:05:00,240 --> 00:05:05,250
minutes but sometimes it happens so

00:05:03,360 --> 00:05:06,900
imagine that is going to wreak havoc on

00:05:05,250 --> 00:05:10,140
the old whole infrastructure of your

00:05:06,900 --> 00:05:12,780
browser your caching all of that you

00:05:10,140 --> 00:05:16,770
just need to find a way to cope with

00:05:12,780 --> 00:05:19,170
this level of JavaScript because one of

00:05:16,770 --> 00:05:23,910
the consequences is it's very slow to

00:05:19,170 --> 00:05:27,150
start if you recall what from Western

00:05:23,910 --> 00:05:29,220
saying earlier was it 100 milliseconds

00:05:27,150 --> 00:05:32,430
200 milliseconds that people start

00:05:29,220 --> 00:05:35,250
thinking it's broken 500

00:05:32,430 --> 00:05:37,710
okay so just parsing the JavaScript for

00:05:35,250 --> 00:05:40,260
Facebook is already at least 500

00:05:37,710 --> 00:05:43,110
milliseconds on both Chrome and Firefox

00:05:40,260 --> 00:05:45,540
that's parsing that's once you have

00:05:43,110 --> 00:05:47,490
received the JavaScript once you have

00:05:45,540 --> 00:05:51,210
received the HTML once you have received

00:05:47,490 --> 00:05:54,210
the images the CSS you start parsing the

00:05:51,210 --> 00:05:55,830
JavaScript at some point and after you

00:05:54,210 --> 00:05:57,540
finish parsing the JavaScript you have a

00:05:55,830 --> 00:06:01,110
few more steps which I'm going to detail

00:05:57,540 --> 00:06:03,810
soon and only then can you start having

00:06:01,110 --> 00:06:06,660
an interactive page so that's where the

00:06:03,810 --> 00:06:08,340
chat of Facebook so this means that for

00:06:06,660 --> 00:06:12,030
the first few seconds actually of

00:06:08,340 --> 00:06:13,410
facebook chat you cannot do anything so

00:06:12,030 --> 00:06:15,870
what's Facebook doing against this

00:06:13,410 --> 00:06:17,490
they're doing what we are doing they are

00:06:15,870 --> 00:06:19,290
trying to optimize stuff and they're

00:06:17,490 --> 00:06:22,590
trying to use tricks to make it look

00:06:19,290 --> 00:06:25,770
faster which means unfortunately these

00:06:22,590 --> 00:06:28,440
tricks once you have too many of them

00:06:25,770 --> 00:06:31,260
it actually makes things go slower just

00:06:28,440 --> 00:06:33,330
to make them look faster and the problem

00:06:31,260 --> 00:06:36,390
is that things are only getting worse

00:06:33,330 --> 00:06:38,580
from here a few years ago when you were

00:06:36,390 --> 00:06:40,530
writing javascript code for web

00:06:38,580 --> 00:06:42,600
application you were hand rolling ingly

00:06:40,530 --> 00:06:46,110
and you had a few hundred worst case of

00:06:42,600 --> 00:06:50,130
2009 s of code nowadays you're using

00:06:46,110 --> 00:06:51,300
webpack to pack how many frameworks how

00:06:50,130 --> 00:06:54,690
many modules

00:06:51,300 --> 00:06:56,710
40 modules 70 modules i mean insane

00:06:54,690 --> 00:06:58,330
amounts of data

00:06:56,710 --> 00:07:00,100
and there is no reason to stop that

00:06:58,330 --> 00:07:01,390
because modules are good frameworks or

00:07:00,100 --> 00:07:05,770
good or it is when they were providing

00:07:01,390 --> 00:07:07,240
something useful yes use them but the

00:07:05,770 --> 00:07:09,360
browser needs to be able to cope with

00:07:07,240 --> 00:07:09,360
that

00:07:10,380 --> 00:07:15,790
unfortunately bring this a little bit

00:07:13,240 --> 00:07:17,080
more and we have exactly the problem

00:07:15,790 --> 00:07:24,070
that was described earlier

00:07:17,080 --> 00:07:27,130
it looks broken so I'm saying that

00:07:24,070 --> 00:07:28,950
loading JavaScript is becoming too slow

00:07:27,130 --> 00:07:32,980
because of the amount of JavaScript

00:07:28,950 --> 00:07:36,790
let's take a look at why loading

00:07:32,980 --> 00:07:39,100
javascript is too slow loading

00:07:36,790 --> 00:07:41,080
javascript is basically the same thing

00:07:39,100 --> 00:07:42,670
as loading other programming languages

00:07:41,080 --> 00:07:45,910
it's a bit different because your

00:07:42,670 --> 00:07:48,430
loading is from your browser but still

00:07:45,910 --> 00:07:50,620
generally the same outline you grab the

00:07:48,430 --> 00:07:53,350
source code you decompress it because

00:07:50,620 --> 00:07:54,700
you typically receive compressed you

00:07:53,350 --> 00:07:57,190
typically need to then manipulate

00:07:54,700 --> 00:07:58,780
encodings then you tokenize I'll come

00:07:57,190 --> 00:08:00,460
back to that in the new parse it and you

00:07:58,780 --> 00:08:03,640
generate bytecode then you finally start

00:08:00,460 --> 00:08:07,330
executing all these steps are typically

00:08:03,640 --> 00:08:11,950
relatively simple in well in a

00:08:07,330 --> 00:08:15,130
programming language would that that it

00:08:11,950 --> 00:08:18,880
were so simple for JavaScript because

00:08:15,130 --> 00:08:20,980
javascript is actually pretty

00:08:18,880 --> 00:08:24,520
complicated language

00:08:20,980 --> 00:08:27,220
so let's start with the beginning you

00:08:24,520 --> 00:08:29,170
are opening a web page let's assume

00:08:27,220 --> 00:08:30,460
you're over already loaded the HTML and

00:08:29,170 --> 00:08:32,530
I think that's going to load your

00:08:30,460 --> 00:08:34,840
JavaScript okay

00:08:32,530 --> 00:08:37,300
know you can download the source code

00:08:34,840 --> 00:08:41,260
your JavaScript source code you can

00:08:37,300 --> 00:08:44,410
decompress it this is the web so any

00:08:41,260 --> 00:08:46,450
encoding is accepted except you're not

00:08:44,410 --> 00:08:48,160
going to write an interpreter for every

00:08:46,450 --> 00:08:50,410
single encoding so you typically need to

00:08:48,160 --> 00:08:52,420
come third your encoding to something

00:08:50,410 --> 00:08:55,360
that your JavaScript virtual machine can

00:08:52,420 --> 00:08:57,190
understand that's really going to take

00:08:55,360 --> 00:08:59,310
some time and allocate some memory for

00:08:57,190 --> 00:09:02,800
people who are performance sensitive

00:08:59,310 --> 00:09:04,300
then you tokenize I don't know how many

00:09:02,800 --> 00:09:07,060
of you are familiar with tokenization

00:09:04,300 --> 00:09:08,740
but tokenization is one of the first

00:09:07,060 --> 00:09:10,510
steps you do when you're trying to

00:09:08,740 --> 00:09:13,330
interpret or compile a programming

00:09:10,510 --> 00:09:15,970
language you take your source code above

00:09:13,330 --> 00:09:19,600
above and you convert it to a series of

00:09:15,970 --> 00:09:23,140
tokens so this source code is function

00:09:19,600 --> 00:09:25,990
through something so the function here

00:09:23,140 --> 00:09:27,820
is translated to this token foo is

00:09:25,990 --> 00:09:29,650
translated to token that says it's an

00:09:27,820 --> 00:09:31,810
identifier then we have a left

00:09:29,650 --> 00:09:36,490
parenthesis we have another identifier

00:09:31,810 --> 00:09:38,950
right parenthesis etc that's how every

00:09:36,490 --> 00:09:44,650
single interpreter or compiler on earth

00:09:38,950 --> 00:09:46,870
works problem is that not all of these

00:09:44,650 --> 00:09:49,510
interpreters or compilers are doing

00:09:46,870 --> 00:09:52,360
JavaScript because javascript is not

00:09:49,510 --> 00:09:55,900
such a simple programming language for

00:09:52,360 --> 00:10:00,730
instance if I see four

00:09:55,900 --> 00:10:06,700
what is for in JavaScript it's typically

00:10:00,730 --> 00:10:08,440
a keyword except sometimes it's not you

00:10:06,700 --> 00:10:13,630
cannot have a variable called for but

00:10:08,440 --> 00:10:17,500
you can have a field for so it doesn't

00:10:13,630 --> 00:10:20,260
know what two can be used here if it

00:10:17,500 --> 00:10:21,040
meets encounters are / the / is a

00:10:20,260 --> 00:10:24,790
nightmare

00:10:21,040 --> 00:10:27,279
what's the / is it a division is it the

00:10:24,790 --> 00:10:29,920
start of a single line comment it is is

00:10:27,279 --> 00:10:31,800
it a start of a multi-line comment or is

00:10:29,920 --> 00:10:34,660
it a ragged

00:10:31,800 --> 00:10:36,070
good luck knowing that the tokenizer has

00:10:34,660 --> 00:10:43,900
no way of knowing that

00:10:36,070 --> 00:10:45,970
oh nice one to use treat if it works any

00:10:43,900 --> 00:10:49,930
other string it would be a stranger

00:10:45,970 --> 00:10:52,540
except it's you street so it's actually

00:10:49,930 --> 00:10:54,910
not exactly a string it's a directive

00:10:52,540 --> 00:11:00,250
and a directive is going to change how

00:10:54,910 --> 00:11:03,010
the parser works and there are more

00:11:00,250 --> 00:11:05,890
complicated things such as strings

00:11:03,010 --> 00:11:09,700
themselves are pretty hard to parse or

00:11:05,890 --> 00:11:12,100
to tokenize because because we want to

00:11:09,700 --> 00:11:14,980
be able to deal intelligently with every

00:11:12,100 --> 00:11:17,050
single language on earth and not all

00:11:14,980 --> 00:11:19,990
languages use the same bytes to

00:11:17,050 --> 00:11:22,300
represent the strings and if we want to

00:11:19,990 --> 00:11:24,580
save memory we want to be smart about

00:11:22,300 --> 00:11:26,790
this but being smart about it means that

00:11:24,580 --> 00:11:29,890
we need to analyze every single string

00:11:26,790 --> 00:11:31,450
every time we encounter a string this

00:11:29,890 --> 00:11:34,420
includes every time we encounter an

00:11:31,450 --> 00:11:39,550
identifier which means

00:11:34,420 --> 00:11:41,440
so so the answer to all of these

00:11:39,550 --> 00:11:44,470
questions is it depends

00:11:41,440 --> 00:11:47,970
in other words yeah the organization is

00:11:44,470 --> 00:11:47,970
hard you're going to see that guy again

00:11:49,590 --> 00:11:57,370
the next step once you have tokenized is

00:11:53,380 --> 00:12:00,340
to parse so that was what we have

00:11:57,370 --> 00:12:01,990
produced in the previous step we have

00:12:00,340 --> 00:12:04,090
something that say it's a function and

00:12:01,990 --> 00:12:08,860
then there is an identifier so a name

00:12:04,090 --> 00:12:10,480
foo and more stuff and then you want to

00:12:08,860 --> 00:12:13,990
produce something that basically looks

00:12:10,480 --> 00:12:15,700
like that this is what the interpreter

00:12:13,990 --> 00:12:18,970
or the compiler is going to have in

00:12:15,700 --> 00:12:22,300
memory to do anything to do security

00:12:18,970 --> 00:12:24,700
what safety checks security checks to

00:12:22,300 --> 00:12:28,030
generate bytecode to optimize your code

00:12:24,700 --> 00:12:33,190
to reject the code because features are

00:12:28,030 --> 00:12:34,900
not available etc so from this it's

00:12:33,190 --> 00:12:36,460
going to deduce that this is working

00:12:34,900 --> 00:12:40,120
clearing a function it's not

00:12:36,460 --> 00:12:42,940
asynchronous it's not a generator well

00:12:40,120 --> 00:12:46,060
let's not talk about scope it has a name

00:12:42,940 --> 00:12:49,690
called foo it has arguments so while a

00:12:46,060 --> 00:12:51,490
single argument called X and okay the

00:12:49,690 --> 00:12:54,850
body I don't have enough space to put

00:12:51,490 --> 00:12:57,760
the body on that side nor on other sites

00:12:54,850 --> 00:13:01,950
be reassured you will not have to read

00:12:57,760 --> 00:13:01,950
this data structure to offer

00:13:03,760 --> 00:13:12,520
is it easy I can assure you I'm pretty

00:13:09,220 --> 00:13:14,770
sure you already guessed the answer you

00:13:12,520 --> 00:13:18,160
know it's not going to be easy so let's

00:13:14,770 --> 00:13:21,340
look at this simple example can anyone

00:13:18,160 --> 00:13:23,380
tell me what's the return of this

00:13:21,340 --> 00:13:26,220
function is going to be if I put true

00:13:23,380 --> 00:13:26,220
for this argument

00:13:29,160 --> 00:13:37,320
so I put x equals 20 and i return i

00:13:32,040 --> 00:13:45,420
return x plus 10 and the answer is of

00:13:37,320 --> 00:13:47,010
course it depends k is 1 the one that

00:13:45,420 --> 00:13:48,540
you probably assumed you have when you

00:13:47,010 --> 00:13:51,420
looked at the source code because i had

00:13:48,540 --> 00:13:55,710
hidden the annoying part yeah

00:13:51,420 --> 00:13:57,410
that's 20 yeah 10 plus 10 equals 20 so

00:13:55,710 --> 00:13:59,820
far so good

00:13:57,410 --> 00:14:02,880
second case I've added something

00:13:59,820 --> 00:14:05,010
instantly in my comments here I really

00:14:02,880 --> 00:14:08,220
cleared verbal x after having returned

00:14:05,010 --> 00:14:12,140
it but who cares and suddenly this

00:14:08,220 --> 00:14:12,140
function returns oh that's not a number

00:14:16,600 --> 00:14:23,800
yes exactly because of the hoisting so

00:14:20,910 --> 00:14:26,430
we can detail all the reasons through

00:14:23,800 --> 00:14:29,310
which this happens but the summary is

00:14:26,430 --> 00:14:32,140
parsing is not that easy

00:14:29,310 --> 00:14:34,840
so handing variables is one of the many

00:14:32,140 --> 00:14:38,200
reasons for which parsing is not easy

00:14:34,840 --> 00:14:42,040
and parsing is slowed down a lot by this

00:14:38,200 --> 00:14:45,130
kind of things if you are having fun

00:14:42,040 --> 00:14:46,960
with this and in this in JavaScript

00:14:45,130 --> 00:14:49,180
don't worry if the compiler or the

00:14:46,960 --> 00:14:50,590
interpreter is also having lots of fun

00:14:49,180 --> 00:14:57,010
trying to understand what the heck is

00:14:50,590 --> 00:14:58,230
that this ever AVO is even more evil if

00:14:57,010 --> 00:15:02,200
you know how it works

00:14:58,230 --> 00:15:04,210
so fun fact there are actually four

00:15:02,200 --> 00:15:06,190
different different definitions of evil

00:15:04,210 --> 00:15:09,880
in the specifications of the JavaScript

00:15:06,190 --> 00:15:12,310
language depending on the context and

00:15:09,880 --> 00:15:14,820
some of them change the meaning of

00:15:12,310 --> 00:15:14,820
variables

00:15:16,530 --> 00:15:24,430
okay same thing with will if you have

00:15:21,010 --> 00:15:29,680
you strict the syntax rules are not the

00:15:24,430 --> 00:15:33,280
same ones and just to make things a

00:15:29,680 --> 00:15:36,250
little bit slower by specification it's

00:15:33,280 --> 00:15:39,430
not permitted for the parser to skip

00:15:36,250 --> 00:15:39,880
anything because if there is a syntax

00:15:39,430 --> 00:15:43,260
error

00:15:39,880 --> 00:15:46,210
you need to know about it immediately

00:15:43,260 --> 00:15:49,230
we're talking about performance skipping

00:15:46,210 --> 00:15:52,020
things would have been pretty cool I

00:15:49,230 --> 00:15:54,820
would have

00:15:52,020 --> 00:15:56,529
okay once you have your nice data

00:15:54,820 --> 00:15:59,230
structure which is called a neg est

00:15:56,529 --> 00:16:00,670
we'll come back to that well you still

00:15:59,230 --> 00:16:02,560
have a few steps before you can execute

00:16:00,670 --> 00:16:04,930
you need to clear from some say safety

00:16:02,560 --> 00:16:07,120
checks then you generate your byte code

00:16:04,930 --> 00:16:10,240
every single browser has a byte code

00:16:07,120 --> 00:16:13,779
format and then the byte code is

00:16:10,240 --> 00:16:15,910
something that you can execute yes okay

00:16:13,779 --> 00:16:19,270
we have spent those 500 or 900

00:16:15,910 --> 00:16:20,830
milliseconds so those were that was all

00:16:19,270 --> 00:16:24,839
that was happening the reason during

00:16:20,830 --> 00:16:24,839
those 500 or 900 milliseconds

00:16:26,160 --> 00:16:31,899
we like to make this faster so we have

00:16:29,560 --> 00:16:34,540
all these steps it would be nice if we

00:16:31,899 --> 00:16:37,930
could really move or paralyze or make

00:16:34,540 --> 00:16:42,459
faster some of them let's see how we can

00:16:37,930 --> 00:16:44,589
do that people have tried things now I

00:16:42,459 --> 00:16:47,620
didn't put the obvious thing people have

00:16:44,589 --> 00:16:51,040
tried to optimize the browser yes we've

00:16:47,620 --> 00:16:52,930
been doing this for the past 20 years we

00:16:51,040 --> 00:16:54,430
have done a pretty good job I mean we as

00:16:52,930 --> 00:16:57,910
a hopper community have done a pretty

00:16:54,430 --> 00:17:02,200
good job but again sometimes it's not

00:16:57,910 --> 00:17:06,069
sufficient so what can we do to make

00:17:02,200 --> 00:17:08,410
things faster we can make lazy parsers

00:17:06,069 --> 00:17:10,530
so parsers that are going to try and be

00:17:08,410 --> 00:17:13,439
smart enough to sometimes skip things

00:17:10,530 --> 00:17:18,520
every single browser actually does that

00:17:13,439 --> 00:17:21,699
in practice in practice it actually is

00:17:18,520 --> 00:17:23,890
not that useful plus it actually

00:17:21,699 --> 00:17:26,470
decreases the total performance so it

00:17:23,890 --> 00:17:29,230
makes starting a little bit faster and

00:17:26,470 --> 00:17:33,910
then it makes the total execution a bit

00:17:29,230 --> 00:17:36,040
slower we have recently learned appended

00:17:33,910 --> 00:17:37,840
in Firefox and I think Rob has then did

00:17:36,040 --> 00:17:39,400
something similar recently something

00:17:37,840 --> 00:17:41,860
called byte code caching which is

00:17:39,400 --> 00:17:44,410
extremely great the second time you load

00:17:41,860 --> 00:17:47,410
the same JavaScript you skip most of the

00:17:44,410 --> 00:17:50,290
steps I mentioned above that's insanely

00:17:47,410 --> 00:17:52,809
cool there are two cases in which it

00:17:50,290 --> 00:17:54,520
doesn't work the first case is the first

00:17:52,809 --> 00:17:56,620
time you connect to a website because

00:17:54,520 --> 00:17:58,900
you haven't loaded that Jay is yet the

00:17:56,620 --> 00:18:00,610
second thing is five minutes later when

00:17:58,900 --> 00:18:01,720
Facebook has updated their JavaScript

00:18:00,610 --> 00:18:02,740
code

00:18:01,720 --> 00:18:07,870
and you need to restart the whole

00:18:02,740 --> 00:18:11,830
process so great technology we're trying

00:18:07,870 --> 00:18:15,340
to optimize the other cases people on

00:18:11,830 --> 00:18:16,780
the development on the Jas dev team the

00:18:15,340 --> 00:18:19,120
jf sorry

00:18:16,780 --> 00:18:23,350
side have tried to optimize things of

00:18:19,120 --> 00:18:26,590
course typically with the use of

00:18:23,350 --> 00:18:30,700
minimizer's that try to make the source

00:18:26,590 --> 00:18:34,840
code shorter or with lady lazy module

00:18:30,700 --> 00:18:38,020
loaders so the first one minimizer's are

00:18:34,840 --> 00:18:40,710
pretty good at reducing the total size

00:18:38,020 --> 00:18:43,240
of the file that is being sent and

00:18:40,710 --> 00:18:52,270
typically they may actually make parsing

00:18:43,240 --> 00:18:54,820
slower in our experience so so useful in

00:18:52,270 --> 00:18:57,720
some cases not a solution unfortunately

00:18:54,820 --> 00:19:01,060
plus they also make the code unreadable

00:18:57,720 --> 00:19:04,060
lazy loaders require refactoring your

00:19:01,060 --> 00:19:05,530
code sometimes they work and generally

00:19:04,060 --> 00:19:10,030
they actually make your performance

00:19:05,530 --> 00:19:12,760
force also plus once you reach an large

00:19:10,030 --> 00:19:14,440
enough amount of JavaScript code lazy

00:19:12,760 --> 00:19:16,450
loaders are going to be insanely

00:19:14,440 --> 00:19:18,760
complicated to introduce if you have not

00:19:16,450 --> 00:19:20,880
built your code from this from start for

00:19:18,760 --> 00:19:20,880
that

00:19:21,500 --> 00:19:26,870
people have also tried to improve

00:19:23,510 --> 00:19:29,000
browsers by providing new technologies

00:19:26,870 --> 00:19:30,740
in the browser that you that developers

00:19:29,000 --> 00:19:34,990
can use to make faster stuff

00:19:30,740 --> 00:19:38,300
so recently wasn't which is great and

00:19:34,990 --> 00:19:40,460
works for several use case many use

00:19:38,300 --> 00:19:42,440
cases but not all of them because you

00:19:40,460 --> 00:19:48,040
need to be to basically write your code

00:19:42,440 --> 00:19:50,990
in C++ all rest if you're lucky and

00:19:48,040 --> 00:19:54,290
there are ideas to use the service

00:19:50,990 --> 00:19:56,240
workers to improve the loading time of

00:19:54,290 --> 00:19:58,550
your applications throw the enemy of

00:19:56,240 --> 00:20:00,380
your JavaScript of course you're going

00:19:58,550 --> 00:20:02,240
to spend your time if you're trying to

00:20:00,380 --> 00:20:03,680
use this for a website that's uploaded

00:20:02,240 --> 00:20:05,990
if they did every five minutes you're

00:20:03,680 --> 00:20:08,090
going to spend your time downloading

00:20:05,990 --> 00:20:09,530
updates and compiling your updates and

00:20:08,090 --> 00:20:11,930
preparing your updates for execution

00:20:09,530 --> 00:20:15,860
which is going to be pretty much as good

00:20:11,930 --> 00:20:19,880
for the planet as Bitcoin not the best

00:20:15,860 --> 00:20:22,100
solution oh and people are of course

00:20:19,880 --> 00:20:23,630
doing native apps because sometimes if

00:20:22,100 --> 00:20:27,190
you want to make things start faster

00:20:23,630 --> 00:20:30,290
sometimes the native app is the solution

00:20:27,190 --> 00:20:32,960
our objective here is to provide

00:20:30,290 --> 00:20:35,360
something that doesn't need you to

00:20:32,960 --> 00:20:39,620
refactor doesn't need you to use a

00:20:35,360 --> 00:20:42,140
native app and just so it's called the

00:20:39,620 --> 00:20:44,120
JavaScript binary

00:20:42,140 --> 00:20:47,450
it's a proposal for the JavaScript

00:20:44,120 --> 00:20:49,970
language basically what it's a new file

00:20:47,450 --> 00:20:51,679
format oh yes we've been working on this

00:20:49,970 --> 00:20:56,660
Soviets Mozilla Bloomberg and Facebook

00:20:51,679 --> 00:20:59,090
so it's a new file format instead of dot

00:20:56,660 --> 00:21:02,450
J's files you're going to send B dot B

00:20:59,090 --> 00:21:06,410
J's files which are much faster to ports

00:21:02,450 --> 00:21:08,929
which are pretty much equivalent they're

00:21:06,410 --> 00:21:11,270
not a defied it's not a bytecode it's

00:21:08,929 --> 00:21:14,030
not a new version of web assembly it's

00:21:11,270 --> 00:21:15,980
not a competition of women assembly it's

00:21:14,030 --> 00:21:21,559
your usual JavaScript just in a

00:21:15,980 --> 00:21:23,299
different format so if you recall told

00:21:21,559 --> 00:21:26,090
you you would not have to read it many

00:21:23,299 --> 00:21:29,059
times but that's I didn't never said

00:21:26,090 --> 00:21:32,090
that you would never read it again so

00:21:29,059 --> 00:21:35,049
this is our function declaration so this

00:21:32,090 --> 00:21:39,020
data structure is what we call an AST an

00:21:35,049 --> 00:21:41,179
abstract syntax tree so it's a tree it

00:21:39,020 --> 00:21:43,220
represents the syntax and it's kind of

00:21:41,179 --> 00:21:47,000
abstract

00:21:43,220 --> 00:21:50,810
we can store it efficiently we can store

00:21:47,000 --> 00:21:53,980
it just as this sequence of members plus

00:21:50,810 --> 00:21:56,180
the definition of the string above I

00:21:53,980 --> 00:21:59,200
skipped a few things plus we can

00:21:56,180 --> 00:21:59,200
compress it afterwards

00:21:59,370 --> 00:22:04,980
the whole point of that were there are

00:22:01,140 --> 00:22:07,080
several points remember the long lists

00:22:04,980 --> 00:22:11,040
we had earlier when we can make it

00:22:07,080 --> 00:22:13,110
shorter still need to download the led

00:22:11,040 --> 00:22:17,280
we can tokenize parse and check things

00:22:13,110 --> 00:22:19,920
in a much more efficient way if we have

00:22:17,280 --> 00:22:23,730
a good binary format we can actually

00:22:19,920 --> 00:22:26,070
skip things and with a few changes to

00:22:23,730 --> 00:22:27,810
the specification but if you have the

00:22:26,070 --> 00:22:30,600
right specification we can skip things

00:22:27,810 --> 00:22:32,250
and only read what we need only tokenize

00:22:30,600 --> 00:22:34,920
what we need only parse what we need

00:22:32,250 --> 00:22:39,300
only check what we need then we generate

00:22:34,920 --> 00:22:41,250
the PI's code and we execute many things

00:22:39,300 --> 00:22:45,090
are faster hopefully the file is smaller

00:22:41,250 --> 00:22:47,400
we haven't reached that stage yet we can

00:22:45,090 --> 00:22:49,620
start all the operations much faster we

00:22:47,400 --> 00:22:53,280
don't need to perform as many operations

00:22:49,620 --> 00:22:55,380
before we start tokenization which you

00:22:53,280 --> 00:22:58,470
know had to guess whether 4 was a

00:22:55,380 --> 00:23:00,590
keyword or an identifier or name it

00:22:58,470 --> 00:23:02,580
becomes absolutely trivial and the

00:23:00,590 --> 00:23:04,830
format is what we call the proof

00:23:02,580 --> 00:23:07,770
carrying format which basically means

00:23:04,830 --> 00:23:11,220
that checking that things are basically

00:23:07,770 --> 00:23:15,240
safe or is much much much faster than it

00:23:11,220 --> 00:23:18,120
used to be again we only parse and check

00:23:15,240 --> 00:23:19,860
and organize the code we execute which

00:23:18,120 --> 00:23:22,470
makes it much faster for startups and we

00:23:19,860 --> 00:23:25,320
do this without loss of performance by

00:23:22,470 --> 00:23:28,020
opposition to what happened before we

00:23:25,320 --> 00:23:31,160
also need to parse all names or strings

00:23:28,020 --> 00:23:33,480
or live variables etc only once and

00:23:31,160 --> 00:23:36,180
we're pretty sure that we can open

00:23:33,480 --> 00:23:39,990
paralyze this much better for modern

00:23:36,180 --> 00:23:43,450
architectures so I believe we have a

00:23:39,990 --> 00:23:48,630
little bit of time for a demo

00:23:43,450 --> 00:23:48,630
thank you so let's

00:23:49,860 --> 00:24:02,850
I've taken the source code of jQuery so

00:23:59,299 --> 00:24:06,240
this is jQuery you don't care you don't

00:24:02,850 --> 00:24:09,179
need to read it it's just click where we

00:24:06,240 --> 00:24:12,210
compress it above I don't know if you

00:24:09,179 --> 00:24:16,799
can read the size but we divided the

00:24:12,210 --> 00:24:19,500
size by adult about six models we can do

00:24:16,799 --> 00:24:24,440
better but that's what we have for the

00:24:19,500 --> 00:24:26,700
moment then we can decompress it back

00:24:24,440 --> 00:24:29,639
which is actually a bit slower than it

00:24:26,700 --> 00:24:33,059
should be but there will not optimize

00:24:29,639 --> 00:24:35,100
that part yet and this is the result

00:24:33,059 --> 00:24:39,960
which should be more readable in my

00:24:35,100 --> 00:24:43,230
editor so things to remember is okay we

00:24:39,960 --> 00:24:47,760
have lost comments and that's basically

00:24:43,230 --> 00:24:50,159
the only thing we have lost and so

00:24:47,760 --> 00:24:53,840
variable names are here layout is a bit

00:24:50,159 --> 00:24:53,840
different but it's still understandable

00:24:54,950 --> 00:25:00,720
so we have a process that we can reverse

00:24:57,899 --> 00:25:03,149
so it's a compression format and that

00:25:00,720 --> 00:25:08,659
process the that version when the binary

00:25:03,149 --> 00:25:08,659
version is much much faster to load

00:25:09,820 --> 00:25:15,400
last year we wrote a full proof of

00:25:12,730 --> 00:25:17,770
concept what full - security we had not

00:25:15,400 --> 00:25:19,420
implemented security for that test it

00:25:17,770 --> 00:25:21,190
was just a proof of concept just running

00:25:19,420 --> 00:25:22,890
on my computer I didn't hear about

00:25:21,190 --> 00:25:26,530
security because I was the only one

00:25:22,890 --> 00:25:28,750
using that format anyway I'm not going

00:25:26,530 --> 00:25:31,450
to give hard numbers on the speed-up but

00:25:28,750 --> 00:25:35,920
it ok we had insane speed ups with that

00:25:31,450 --> 00:25:40,560
version and the file format was really

00:25:35,920 --> 00:25:44,250
much smaller than minimized plus GZ plus

00:25:40,560 --> 00:25:47,710
so we put that into the standard

00:25:44,250 --> 00:25:50,560
standardization track and right now we

00:25:47,710 --> 00:25:53,620
are currently are writing a third

00:25:50,560 --> 00:25:55,630
prototype which has the security the

00:25:53,620 --> 00:25:58,180
security again it easier and faster to

00:25:55,630 --> 00:26:00,670
check with JavaScript the source code of

00:25:58,180 --> 00:26:04,060
this parser is easier to check than the

00:26:00,670 --> 00:26:06,850
source than the existing parser that is

00:26:04,060 --> 00:26:09,250
part of Firefox or any competitor so

00:26:06,850 --> 00:26:11,230
it's actually harder to make security

00:26:09,250 --> 00:26:15,310
errors in the parser it's never

00:26:11,230 --> 00:26:19,000
impossible but it's order okay we're not

00:26:15,310 --> 00:26:22,440
finished yet but anyway it's on the

00:26:19,000 --> 00:26:27,790
process to be finished and standardized

00:26:22,440 --> 00:26:30,700
our hope is that we'll be able to ship a

00:26:27,790 --> 00:26:33,070
version for obscene gestures during this

00:26:30,700 --> 00:26:36,210
summer and try it with the number of

00:26:33,070 --> 00:26:36,210
large vendors

00:26:36,250 --> 00:26:41,909
if you want to help and thank you for

00:26:39,820 --> 00:26:41,909
listening

00:26:48,970 --> 00:26:59,790
[Applause]

00:26:50,880 --> 00:26:59,790
yes yes yes

00:27:04,970 --> 00:27:11,880
so the question is I mentioned that

00:27:09,090 --> 00:27:13,980
during parsing we can skip the parts

00:27:11,880 --> 00:27:15,510
that were not using yet and the question

00:27:13,980 --> 00:27:17,700
is do we need to parse them later yeah

00:27:15,510 --> 00:27:19,860
of course the answer is yes reports them

00:27:17,700 --> 00:27:22,560
later but we only need to report the

00:27:19,860 --> 00:27:25,170
part that we're using we can parse one

00:27:22,560 --> 00:27:27,270
function at a time we can say hey let's

00:27:25,170 --> 00:27:29,670
start at this offset until that offset

00:27:27,270 --> 00:27:31,560
and just parse that part which is

00:27:29,670 --> 00:27:34,040
something that's not possible with text

00:27:31,560 --> 00:27:34,040
JavaScript

00:27:46,730 --> 00:27:54,650
you can try to scream if you want in

00:27:49,850 --> 00:27:57,730
case somebody hears okay does anyone

00:27:54,650 --> 00:27:57,730
have a question who's closer

00:27:58,490 --> 00:28:01,490
yes

00:28:01,520 --> 00:28:05,910
apparently I went a bit over time' so if

00:28:04,350 --> 00:28:10,020
you have questions do not hesitate to

00:28:05,910 --> 00:28:12,110
have them afterwards thank you for

00:28:10,020 --> 00:28:12,110
listening

00:30:04,230 --> 00:30:06,290

YouTube URL: https://www.youtube.com/watch?v=P1Sk6Z3er3s


