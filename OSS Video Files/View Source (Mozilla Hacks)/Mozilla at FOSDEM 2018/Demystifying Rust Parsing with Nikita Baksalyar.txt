Title: Demystifying Rust Parsing with Nikita Baksalyar
Publication date: 2018-02-20
Playlist: Mozilla at FOSDEM 2018
Description: 
	Language parsing and automatic binding generation. 

First presented at FOSDEM, Feb 3, 2018. (https://fosdem.org/2018/schedule/speaker/nikita_baksalyar/)

These talks have been recorded at FOSDEM (https://fosdem.org/) This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence. To view a copy of this licence, visit:
https://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:07,559 --> 00:00:11,580
so our next speaker is

00:00:15,969 --> 00:00:22,349
hey thanks a lot and first let me

00:00:20,020 --> 00:00:25,960
introduce myself and before that let me

00:00:22,349 --> 00:00:29,110
say that it's always great to see so

00:00:25,960 --> 00:00:31,539
many people in this room people who are

00:00:29,110 --> 00:00:34,829
interested in rust and the language

00:00:31,539 --> 00:00:38,140
itself has started about two years ago

00:00:34,829 --> 00:00:41,200
less than a little bit more than two

00:00:38,140 --> 00:00:42,820
years ago and there will were maybe a

00:00:41,200 --> 00:00:44,920
couple of hundreds of people who were

00:00:42,820 --> 00:00:46,870
interested in that language and now it's

00:00:44,920 --> 00:00:48,999
really great to see that is getting

00:00:46,870 --> 00:00:53,039
traction and see a lot of people in this

00:00:48,999 --> 00:00:56,109
room who are interested in this topic so

00:00:53,039 --> 00:00:58,929
introducing myself my name is nikita I

00:00:56,109 --> 00:01:01,690
work at made safe and might safe is a

00:00:58,929 --> 00:01:05,050
company that develops peer-to-peer

00:01:01,690 --> 00:01:08,020
network technology and I think we have

00:01:05,050 --> 00:01:11,200
one of the largest code bases that are

00:01:08,020 --> 00:01:15,340
written in rust so today I want to share

00:01:11,200 --> 00:01:17,650
or share my experience developing one of

00:01:15,340 --> 00:01:22,150
the comprise one of the libraries that

00:01:17,650 --> 00:01:27,550
comprise our stead and they want to talk

00:01:22,150 --> 00:01:31,600
to you about parsing so Percy is one of

00:01:27,550 --> 00:01:34,660
the crucial steps in the company in the

00:01:31,600 --> 00:01:39,400
topic of compilers and the compilers is

00:01:34,660 --> 00:01:41,830
a a complex topic by itself so it's it

00:01:39,400 --> 00:01:46,090
will be almost impossible to cover all

00:01:41,830 --> 00:01:48,700
the things that go into compilers in 20

00:01:46,090 --> 00:01:52,600
minutes so this will be more like more

00:01:48,700 --> 00:01:55,930
of an observant talk so I will cover the

00:01:52,600 --> 00:01:59,140
basics and my you know goal here my goal

00:01:55,930 --> 00:02:01,450
today is not to give you the entirety of

00:01:59,140 --> 00:02:04,930
information about compilers but to

00:02:01,450 --> 00:02:09,190
inspire you and basically to pique your

00:02:04,930 --> 00:02:11,739
interest and actually compilers is a

00:02:09,190 --> 00:02:15,040
complex topic and a lot of people are

00:02:11,739 --> 00:02:17,739
scared but it they opened the Dragon

00:02:15,040 --> 00:02:19,930
book they see that it consists of more

00:02:17,739 --> 00:02:21,970
than thousand pages and they close the

00:02:19,930 --> 00:02:24,550
book and never read it again but

00:02:21,970 --> 00:02:27,880
actually compilers are very interesting

00:02:24,550 --> 00:02:29,710
topic and if you take one part of it

00:02:27,880 --> 00:02:36,400
they can be immensely

00:02:29,710 --> 00:02:40,390
useful and they're not that complex so

00:02:36,400 --> 00:02:42,790
let's start from the basics so how her

00:02:40,390 --> 00:02:45,130
how parsing can be useful for you so

00:02:42,790 --> 00:02:47,650
what is actually parsing so if you don't

00:02:45,130 --> 00:02:51,940
know it is one of the steps in a

00:02:47,650 --> 00:02:54,130
compiler you know which allows you to

00:02:51,940 --> 00:02:57,340
extract meta information about your code

00:02:54,130 --> 00:02:59,950
so you can actually imagine the compiler

00:02:57,340 --> 00:03:03,460
as a kind of a pipeline that consists of

00:02:59,950 --> 00:03:08,370
several steps and the first step in the

00:03:03,460 --> 00:03:12,160
compiler is the lexical parsing the

00:03:08,370 --> 00:03:15,490
excuse me the lexical analysis the

00:03:12,160 --> 00:03:18,790
lexical analysis is a simplest step that

00:03:15,490 --> 00:03:22,180
gets your code in its text

00:03:18,790 --> 00:03:26,740
representation and transforms it to a

00:03:22,180 --> 00:03:30,730
set of tokens a token is a very simple

00:03:26,740 --> 00:03:33,490
thing and can be thought of as a word it

00:03:30,730 --> 00:03:35,680
can be a keyword it can be a string out

00:03:33,490 --> 00:03:38,260
of your code it can be a number it can

00:03:35,680 --> 00:03:44,310
be basically anything a return return is

00:03:38,260 --> 00:03:48,010
a curl is a token a fan is a token but

00:03:44,310 --> 00:03:51,160
heavy just joking we can't do many

00:03:48,010 --> 00:03:54,340
useful things with them right we can do

00:03:51,160 --> 00:03:57,520
many useful things with just codes as

00:03:54,340 --> 00:04:02,320
text so what we do here is we puts

00:03:57,520 --> 00:04:07,930
tokens in a token in token trees and out

00:04:02,320 --> 00:04:10,180
of those token trees we create out of

00:04:07,930 --> 00:04:14,380
those token trees we create a data

00:04:10,180 --> 00:04:19,150
structure that's that is called abstract

00:04:14,380 --> 00:04:22,390
syntax tree or EHD for shirt HT allows

00:04:19,150 --> 00:04:25,660
us to extract meta information out of

00:04:22,390 --> 00:04:28,440
our codes and use this information to do

00:04:25,660 --> 00:04:28,440
basically anything

00:04:32,190 --> 00:04:37,750
so how do we apply is these for our

00:04:36,130 --> 00:04:41,440
practical code you might think that

00:04:37,750 --> 00:04:44,650
pasties are usable only for the Roth

00:04:41,440 --> 00:04:48,460
compiler itself or for now building some

00:04:44,650 --> 00:04:50,650
I don't know some utilities or things

00:04:48,460 --> 00:04:53,500
that belong to the Roth compiler but

00:04:50,650 --> 00:04:57,340
actually histories have many everyday

00:04:53,500 --> 00:04:59,260
applications so you can extract matter

00:04:57,340 --> 00:05:02,500
information from your code and based on

00:04:59,260 --> 00:05:05,770
that information you can generate code

00:05:02,500 --> 00:05:08,440
in other languages this is very useful

00:05:05,770 --> 00:05:10,900
if you want to for example if you deal

00:05:08,440 --> 00:05:14,380
with FFI or foreign function interface

00:05:10,900 --> 00:05:17,440
and you want to create a library in rust

00:05:14,380 --> 00:05:20,260
that you want to be make usable from

00:05:17,440 --> 00:05:22,840
other languages and it will be very

00:05:20,260 --> 00:05:25,600
tedious and complicated to write this

00:05:22,840 --> 00:05:30,370
code in other languages to work with

00:05:25,600 --> 00:05:33,280
your rough library that's why we have a

00:05:30,370 --> 00:05:35,290
steez you can basically scan all of your

00:05:33,280 --> 00:05:37,030
libraries code and extract that

00:05:35,290 --> 00:05:39,130
information about the functions that you

00:05:37,030 --> 00:05:41,410
export from your library and generates

00:05:39,130 --> 00:05:44,890
code in other languages based on that

00:05:41,410 --> 00:05:46,090
extracted information and you can also

00:05:44,890 --> 00:05:49,150
transform your code

00:05:46,090 --> 00:05:52,180
it's practically you know when you want

00:05:49,150 --> 00:05:54,250
to apply some kind of refactoring to

00:05:52,180 --> 00:05:57,790
your code and I believe the next talk we

00:05:54,250 --> 00:06:01,060
will be on this topic so for example you

00:05:57,790 --> 00:06:05,680
have Clippy that shows you many compile

00:06:01,060 --> 00:06:08,890
errors in your rusts code and it's not

00:06:05,680 --> 00:06:11,440
so it is very useful but it will be very

00:06:08,890 --> 00:06:13,450
nice if it could do automatic

00:06:11,440 --> 00:06:16,390
transformation an automatic refactoring

00:06:13,450 --> 00:06:19,180
of your code right so that what you can

00:06:16,390 --> 00:06:20,980
do with ASD with HT you have full

00:06:19,180 --> 00:06:24,700
information about your code and you can

00:06:20,980 --> 00:06:26,470
also generate new code out of a steez so

00:06:24,700 --> 00:06:28,450
basically what you do here is you you're

00:06:26,470 --> 00:06:30,330
taking the code of your library and

00:06:28,450 --> 00:06:34,000
you're generating new code based on

00:06:30,330 --> 00:06:37,930
based on that code and as an output you

00:06:34,000 --> 00:06:40,210
have a refactoring code and there is

00:06:37,930 --> 00:06:42,550
also the meta programming aspect as

00:06:40,210 --> 00:06:45,280
basically you're related to macros and

00:06:42,550 --> 00:06:45,759
macros are very similar to how a Steve's

00:06:45,280 --> 00:06:48,699
work

00:06:45,759 --> 00:06:50,610
so mockers basically employed the HD

00:06:48,699 --> 00:06:54,999
framework that you have in your compiler

00:06:50,610 --> 00:06:57,279
but the macros are accessible to only

00:06:54,999 --> 00:07:00,279
within the scope of the compiler and

00:06:57,279 --> 00:07:05,589
with ASD you have the full information

00:07:00,279 --> 00:07:07,389
about your code so basically that means

00:07:05,589 --> 00:07:11,289
that with meta programming you can

00:07:07,389 --> 00:07:12,849
generate any rust code based on the full

00:07:11,289 --> 00:07:18,580
information that you have extracted from

00:07:12,849 --> 00:07:22,680
the east and of course you can use SDS

00:07:18,580 --> 00:07:25,180
to compile your code to a binary but

00:07:22,680 --> 00:07:29,110
thankfully you rusts the Rath compiler

00:07:25,180 --> 00:07:32,110
does that part for us and of course you

00:07:29,110 --> 00:07:33,969
need to know that the use cases are not

00:07:32,110 --> 00:07:37,180
limited to those that were listed on the

00:07:33,969 --> 00:07:39,460
previous slide there is a lot of there

00:07:37,180 --> 00:07:41,289
is a lot more use cases and they are

00:07:39,460 --> 00:07:49,689
basically limited only by your

00:07:41,289 --> 00:07:51,909
imagination how about a purse is these

00:07:49,689 --> 00:07:55,089
by themselves are pretty abstract

00:07:51,909 --> 00:07:57,819
concept how do we actually apply them to

00:07:55,089 --> 00:08:01,499
rust because this is talked about the

00:07:57,819 --> 00:08:04,270
rust language right and in fact rust

00:08:01,499 --> 00:08:07,479
libraries multiple rust libraries

00:08:04,270 --> 00:08:11,349
already apply that concept and we use

00:08:07,479 --> 00:08:13,870
these tools every day and ra7 key is

00:08:11,349 --> 00:08:15,639
also another great example of code

00:08:13,870 --> 00:08:19,659
transformation because what it does is

00:08:15,639 --> 00:08:22,020
basically takes the HD that it has

00:08:19,659 --> 00:08:26,589
extracted from the source code and

00:08:22,020 --> 00:08:31,120
outputs this is T with with a formatting

00:08:26,589 --> 00:08:33,909
that follows the presets preset rules

00:08:31,120 --> 00:08:36,519
about the how indentation should work

00:08:33,909 --> 00:08:40,539
how to put its call to put the brackets

00:08:36,519 --> 00:08:44,410
where to put the brackets and so on and

00:08:40,539 --> 00:08:46,860
clip is a similar beast so it extracts

00:08:44,410 --> 00:08:50,019
the meta information from a ste and

00:08:46,860 --> 00:08:53,769
based on that instructed extracted

00:08:50,019 --> 00:08:57,730
information it checks whether your code

00:08:53,769 --> 00:08:59,410
has any bad patterns in it and suggests

00:08:57,730 --> 00:09:02,859
how to fix

00:08:59,410 --> 00:09:05,079
those bad patterns and there is no magic

00:09:02,859 --> 00:09:07,839
in it you can basically write your own

00:09:05,079 --> 00:09:11,259
clip a based on the compiler

00:09:07,839 --> 00:09:16,539
technologies and finally if you use IDs

00:09:11,259 --> 00:09:19,449
or text editors with with the eraser

00:09:16,539 --> 00:09:21,970
plugin installed you are also using a

00:09:19,449 --> 00:09:25,029
steez Easy's extract information from

00:09:21,970 --> 00:09:27,819
your code and you have killed completion

00:09:25,029 --> 00:09:28,449
syntax highlighting all the nice things

00:09:27,819 --> 00:09:31,359
that

00:09:28,449 --> 00:09:35,739
IDs provide you so IDE is basically a

00:09:31,359 --> 00:09:38,079
compiler that compiler that extracts

00:09:35,739 --> 00:09:40,709
information from your code and makes it

00:09:38,079 --> 00:09:45,449
more usable and convenient for you to

00:09:40,709 --> 00:09:45,449
write your code in the users interface

00:09:47,129 --> 00:09:55,359
so how do we actually use these ASDs and

00:09:53,559 --> 00:09:57,609
of course you don't have to write your

00:09:55,359 --> 00:09:59,799
own library or you don't have to write

00:09:57,609 --> 00:10:03,069
your own code to extract this

00:09:59,799 --> 00:10:06,489
information or parser code into HTS you

00:10:03,069 --> 00:10:10,179
have you have it already in the Rath

00:10:06,489 --> 00:10:12,579
compiler and you can use the lip syntax

00:10:10,179 --> 00:10:17,549
that is an integral part of the compiler

00:10:12,579 --> 00:10:22,419
to basically extract this information

00:10:17,549 --> 00:10:25,239
and use it in your code there is a

00:10:22,419 --> 00:10:30,369
caveat though that's lip syntax library

00:10:25,239 --> 00:10:36,249
is available only in night in the nidal

00:10:30,369 --> 00:10:40,079
version of compiler and brass use it to

00:10:36,249 --> 00:10:45,249
parser code and it provides a teaser

00:10:40,079 --> 00:10:50,019
basically in as an API but if you can't

00:10:45,249 --> 00:10:52,470
use the nightly version of the compiler

00:10:50,019 --> 00:10:56,289
the an alternative version will be

00:10:52,470 --> 00:10:58,929
syntax that is a grade that has been

00:10:56,289 --> 00:11:02,109
ported from the lips index to a separate

00:10:58,929 --> 00:11:04,599
grade is basically a code that has been

00:11:02,109 --> 00:11:07,389
taken from the Russ compiler and put

00:11:04,599 --> 00:11:11,979
into a crate that can work on a stable

00:11:07,389 --> 00:11:13,000
branch of the Russ compiler and it's it

00:11:11,979 --> 00:11:16,390
has the

00:11:13,000 --> 00:11:18,850
exact same API so you can basically use

00:11:16,390 --> 00:11:21,580
it interchangeably in your library if

00:11:18,850 --> 00:11:24,220
you want you if you are not allowed to

00:11:21,580 --> 00:11:27,670
use an idle version of compiler you can

00:11:24,220 --> 00:11:31,620
basically just link this this little

00:11:27,670 --> 00:11:35,800
library and it's a drop-in replacement

00:11:31,620 --> 00:11:40,030
but there's another kavia in that this

00:11:35,800 --> 00:11:43,980
library has been deprecated and its

00:11:40,030 --> 00:11:46,330
usage mostly confined to legacy projects

00:11:43,980 --> 00:11:48,340
well you can still use it it's still

00:11:46,330 --> 00:11:52,840
available on the grades dot io

00:11:48,340 --> 00:11:54,340
repository but there is also an

00:11:52,840 --> 00:11:57,280
alternative and if you're starting a new

00:11:54,340 --> 00:11:58,960
version of your basically if you're

00:11:57,280 --> 00:12:01,270
starting from scratch and not from some

00:11:58,960 --> 00:12:03,870
kind of legacy code you can use an

00:12:01,270 --> 00:12:09,730
alternative library that's called as sin

00:12:03,870 --> 00:12:11,800
sy n and it is used by multiple projects

00:12:09,730 --> 00:12:16,090
too and this syntax crate is used by

00:12:11,800 --> 00:12:17,380
rust affinity stable so it's basically a

00:12:16,090 --> 00:12:19,810
matter of preference

00:12:17,380 --> 00:12:25,210
although the authors of this library

00:12:19,810 --> 00:12:27,760
that I would prefer you to not use it so

00:12:25,210 --> 00:12:29,740
how do you actually to put it in

00:12:27,760 --> 00:12:34,780
practical terms how do you actually use

00:12:29,740 --> 00:12:37,870
that you basically import the syntax

00:12:34,780 --> 00:12:41,830
which isn't part of the wrath compiler

00:12:37,870 --> 00:12:45,040
as a crate you add this separate mmm

00:12:41,830 --> 00:12:48,310
kicker flag that says that it's allowed

00:12:45,040 --> 00:12:51,340
to import private parts of the res

00:12:48,310 --> 00:12:57,820
compiler and you basically import it and

00:12:51,340 --> 00:13:00,970
use it as a as a usual library so then

00:12:57,820 --> 00:13:05,320
you provide a file name of a Russ file

00:13:00,970 --> 00:13:11,290
that you want to parse another and as a

00:13:05,320 --> 00:13:14,910
result you get a vector of items so

00:13:11,290 --> 00:13:17,920
items are actually in arms that

00:13:14,910 --> 00:13:20,140
represent all that you can use in your

00:13:17,920 --> 00:13:22,930
code so it represents functions with

00:13:20,140 --> 00:13:24,790
their arguments it represents statements

00:13:22,930 --> 00:13:26,600
it represents all the expressions that

00:13:24,790 --> 00:13:29,690
you have in her code

00:13:26,600 --> 00:13:34,550
it's a nice thing about it is that it's

00:13:29,690 --> 00:13:36,500
an enum and as you know we have a very

00:13:34,550 --> 00:13:39,050
nice language construct in rust that

00:13:36,500 --> 00:13:43,210
works with enums there's called match

00:13:39,050 --> 00:13:47,780
and by using pattern matching it's very

00:13:43,210 --> 00:13:52,180
simple it's very easy to actually

00:13:47,780 --> 00:13:55,580
extract the information from those items

00:13:52,180 --> 00:13:59,870
you basically match on the type of your

00:13:55,580 --> 00:14:02,390
AC item which could also call carry the

00:13:59,870 --> 00:14:06,200
all the relevant information with it in

00:14:02,390 --> 00:14:12,770
its anon variant and you use it however

00:14:06,200 --> 00:14:15,310
you like so that's how it could look

00:14:12,770 --> 00:14:19,930
yeah it could be a function declaration

00:14:15,310 --> 00:14:23,870
which has its inputs its arguments with

00:14:19,930 --> 00:14:28,640
together with its types and it has also

00:14:23,870 --> 00:14:32,090
on how to type so it goes on like that

00:14:28,640 --> 00:14:35,900
with other kinds of items with other

00:14:32,090 --> 00:14:39,440
kinds of easties so it's not a rocket

00:14:35,900 --> 00:14:44,300
science so you basically can continue in

00:14:39,440 --> 00:14:47,920
the same manner and finally you know

00:14:44,300 --> 00:14:50,500
there is a code generation aspect so

00:14:47,920 --> 00:14:53,900
code generation has a lots and lots of

00:14:50,500 --> 00:14:56,900
useful and practical applications so it

00:14:53,900 --> 00:14:59,870
enough for for an example when Mozilla

00:14:56,900 --> 00:15:02,630
started to develop servo they stumbled

00:14:59,870 --> 00:15:05,240
upon an issue that there is many

00:15:02,630 --> 00:15:09,890
libraries that are not written in rust

00:15:05,240 --> 00:15:13,760
yet so to use these libraries that are

00:15:09,890 --> 00:15:18,230
written in C and C++ they got together

00:15:13,760 --> 00:15:21,250
with a library read sculptress bankin so

00:15:18,230 --> 00:15:24,350
what it does basically it uses si Lang

00:15:21,250 --> 00:15:27,410
to extract the meta information from C++

00:15:24,350 --> 00:15:32,240
code so basically can think about it as

00:15:27,410 --> 00:15:34,630
as an analogy of that lip syntax from

00:15:32,240 --> 00:15:37,790
the Russ compiler but it works for C++

00:15:34,630 --> 00:15:39,460
so it extracts the meta information from

00:15:37,790 --> 00:15:43,510
the C++ code

00:15:39,460 --> 00:15:47,350
and generates code in rust so that that

00:15:43,510 --> 00:15:49,089
way you get a library that can talk to a

00:15:47,350 --> 00:15:51,640
single class library but you don't need

00:15:49,089 --> 00:15:59,770
to write it by hand which will be of

00:15:51,640 --> 00:16:03,430
course very tedious and error-prone so

00:15:59,770 --> 00:16:06,370
then there is a civilization aspect so

00:16:03,430 --> 00:16:09,040
if you work with protobufs or ro or

00:16:06,370 --> 00:16:11,410
other frameworks that work with other

00:16:09,040 --> 00:16:14,230
languages they basically follow the same

00:16:11,410 --> 00:16:17,080
pattern they have a description of data

00:16:14,230 --> 00:16:22,870
structures that you might need to use in

00:16:17,080 --> 00:16:25,870
different languages and they basically

00:16:22,870 --> 00:16:29,740
use code generation to provide this

00:16:25,870 --> 00:16:32,170
feature and in rust you can do the same

00:16:29,740 --> 00:16:34,330
and I believe there is already a bunch

00:16:32,170 --> 00:16:37,630
of libraries that provide this thing for

00:16:34,330 --> 00:16:39,640
you but if you want to make a similar

00:16:37,630 --> 00:16:46,720
thing you can use code generation as

00:16:39,640 --> 00:16:50,110
well and finally why why do we use HTS

00:16:46,720 --> 00:16:54,520
why do we use parsing instead of instead

00:16:50,110 --> 00:16:56,920
of just going by macros well first of

00:16:54,520 --> 00:17:00,250
all macros don't have an access to you

00:16:56,920 --> 00:17:03,520
the environment that you know run your

00:17:00,250 --> 00:17:06,520
program in so macros are kind of

00:17:03,520 --> 00:17:08,530
isolated by the compiler context they

00:17:06,520 --> 00:17:12,220
can't access the input out they can't

00:17:08,530 --> 00:17:14,640
read a file from your file system they

00:17:12,220 --> 00:17:18,939
can't go to the network and so on and

00:17:14,640 --> 00:17:21,490
with and with parsing by parsing your

00:17:18,939 --> 00:17:25,000
code you can basically have and have a

00:17:21,490 --> 00:17:26,709
the all the power that rust the rust

00:17:25,000 --> 00:17:30,910
compiler and the rust language provide

00:17:26,709 --> 00:17:33,190
you and not only the rust language and

00:17:30,910 --> 00:17:39,640
the the full power of your environment

00:17:33,190 --> 00:17:42,910
and a second aspect of it is that macros

00:17:39,640 --> 00:17:45,460
2.0 that should be available in the

00:17:42,910 --> 00:17:48,309
wrath compiler soon should cover at

00:17:45,460 --> 00:17:51,800
least a part of these use cases so you

00:17:48,309 --> 00:17:55,040
might want to follow this closely

00:17:51,800 --> 00:17:58,790
and finally how do you actually generate

00:17:55,040 --> 00:18:01,940
your code huh you can use a tool that

00:17:58,790 --> 00:18:06,170
utilizes the Builder pattern they

00:18:01,940 --> 00:18:08,480
basically call functions so to construct

00:18:06,170 --> 00:18:10,100
a function you will call item of fun and

00:18:08,480 --> 00:18:11,900
provide the context of that function you

00:18:10,100 --> 00:18:13,850
provide the function name you provide

00:18:11,900 --> 00:18:16,490
the function arguments and you provide

00:18:13,850 --> 00:18:21,770
the function body and as a result you

00:18:16,490 --> 00:18:24,560
will get the ast item that will contain

00:18:21,770 --> 00:18:27,290
on all the relevant information for your

00:18:24,560 --> 00:18:30,230
function and from that HT item you can

00:18:27,290 --> 00:18:34,280
convert it into into a string and get

00:18:30,230 --> 00:18:38,060
the rescued as a result but it's not

00:18:34,280 --> 00:18:40,160
very convenient so what we can use

00:18:38,060 --> 00:18:43,640
instead we can employ the concept that

00:18:40,160 --> 00:18:47,660
is called quasi quasi quotation and it

00:18:43,640 --> 00:18:50,030
is widely known and widely used in the

00:18:47,660 --> 00:18:51,650
lisp language and it's widely used by

00:18:50,030 --> 00:18:55,100
some functional languages like Haskell

00:18:51,650 --> 00:18:59,360
for example and the concept is quite

00:18:55,100 --> 00:19:02,930
simple its server resembling of macros

00:18:59,360 --> 00:19:06,230
but actually instead of you know instead

00:19:02,930 --> 00:19:09,200
of outputting just a string it provides

00:19:06,230 --> 00:19:13,730
you with tokens and the HD items that

00:19:09,200 --> 00:19:16,910
you can use further so there is also a

00:19:13,730 --> 00:19:19,730
Russ library that that's called code

00:19:16,910 --> 00:19:22,570
that provides a bunch of handy markers

00:19:19,730 --> 00:19:27,020
that you can use to generate your code

00:19:22,570 --> 00:19:30,200
it looks like this as you can see it's

00:19:27,020 --> 00:19:32,660
almost the same as you would have

00:19:30,200 --> 00:19:35,420
written it if you have dealt with macros

00:19:32,660 --> 00:19:39,500
so you can just create a new identifier

00:19:35,420 --> 00:19:43,460
and place it in your code instead of

00:19:39,500 --> 00:19:45,310
placeholder and as a result and as a

00:19:43,460 --> 00:19:48,530
result if you convert it into a string

00:19:45,310 --> 00:19:52,430
you will get a resulting function a

00:19:48,530 --> 00:19:55,760
resulting source code and you can now

00:19:52,430 --> 00:19:59,960
put it into a file or do whatever you'd

00:19:55,760 --> 00:20:03,400
like with it and finally a small case a

00:19:59,960 --> 00:20:05,720
small case study about how can you use

00:20:03,400 --> 00:20:10,759
parsing in your project

00:20:05,720 --> 00:20:14,629
so it made safe we dealt with our task

00:20:10,759 --> 00:20:19,460
will was to provide a library to be used

00:20:14,629 --> 00:20:21,500
in basically in multiple languages we

00:20:19,460 --> 00:20:24,110
have a library that talks to a p2p

00:20:21,500 --> 00:20:27,169
network a peer-to-peer network and we

00:20:24,110 --> 00:20:29,750
want people to use it from basically any

00:20:27,169 --> 00:20:31,730
language that exists and we provide this

00:20:29,750 --> 00:20:34,009
library as an FF I interface so it

00:20:31,730 --> 00:20:36,200
exports a foreign function interface and

00:20:34,009 --> 00:20:40,879
it's available as a C library as any

00:20:36,200 --> 00:20:43,759
other C library but as we want it to be

00:20:40,879 --> 00:20:46,850
used by as we want it to be used by

00:20:43,759 --> 00:20:53,120
JavaScript or from Python and from Java

00:20:46,850 --> 00:20:55,850
and from other languages we and it's a

00:20:53,120 --> 00:20:59,029
very tedious process to just write that

00:20:55,850 --> 00:21:00,919
code by hand to write the language

00:20:59,029 --> 00:21:04,399
bindings code by hand we came up with

00:21:00,919 --> 00:21:06,740
that solution of parsing basically

00:21:04,399 --> 00:21:09,409
parsing our entire library and export

00:21:06,740 --> 00:21:12,470
them looking at the exported f5

00:21:09,409 --> 00:21:14,509
functions and create generating Java and

00:21:12,470 --> 00:21:18,799
c-sharp and Python code based on that

00:21:14,509 --> 00:21:21,559
and besides that now Java wouldn't work

00:21:18,799 --> 00:21:25,039
simple with that code so we also

00:21:21,559 --> 00:21:28,460
generate Jana bindings in rust so we

00:21:25,039 --> 00:21:31,460
generate rust code that exports jane i

00:21:28,460 --> 00:21:34,340
functions that Java understand and that

00:21:31,460 --> 00:21:37,309
the entire code of that libraries ik is

00:21:34,340 --> 00:21:42,350
generated by basically as a result of

00:21:37,309 --> 00:21:44,450
code generator and the parser so that's

00:21:42,350 --> 00:21:46,690
it and if you have any questions please

00:21:44,450 --> 00:21:46,690
ask

00:21:46,890 --> 00:21:54,549
[Applause]

00:22:04,940 --> 00:22:21,830
my library and I want to replace well

00:22:17,330 --> 00:22:25,679
well the question is can you use

00:22:21,830 --> 00:22:28,110
basically can you transform a STIs in

00:22:25,679 --> 00:22:30,360
the compile time so when you're

00:22:28,110 --> 00:22:32,779
compiling your library can you transform

00:22:30,360 --> 00:22:35,249
the ast s to have some other

00:22:32,779 --> 00:22:37,289
representation and of course it is

00:22:35,249 --> 00:22:39,480
possible and you do its with macros so

00:22:37,289 --> 00:22:42,659
basically that what micros does they

00:22:39,480 --> 00:22:46,200
take the ast three and they produce

00:22:42,659 --> 00:22:48,389
another HD three so mmm that is sold by

00:22:46,200 --> 00:22:51,690
macros and also there is a procedural

00:22:48,389 --> 00:22:55,289
Makris thing and there is also micros

00:22:51,690 --> 00:22:57,600
2.0 so Russ provides multiple ways to

00:22:55,289 --> 00:22:59,519
transform your code to some other

00:22:57,600 --> 00:23:02,720
representation and you can choose

00:22:59,519 --> 00:23:02,720
whatever suits you better

00:23:28,190 --> 00:23:34,429
so the question is can you basically do

00:23:32,009 --> 00:23:38,820
a mock testing and rust by replacing

00:23:34,429 --> 00:23:41,580
structures with some other version with

00:23:38,820 --> 00:23:44,519
versions with instrumentation and test

00:23:41,580 --> 00:23:46,950
functions now and so on and yeah I

00:23:44,519 --> 00:23:49,110
believe it's possible if you use the

00:23:46,950 --> 00:23:51,360
compiler plugins and the procedural

00:23:49,110 --> 00:23:53,909
markers and if you use the derived key

00:23:51,360 --> 00:23:56,940
in keyboard that what it basically does

00:23:53,909 --> 00:24:00,269
and that's also how sir - how the serger

00:23:56,940 --> 00:24:02,190
library works it derives your structs so

00:24:00,269 --> 00:24:04,590
you just write derive

00:24:02,190 --> 00:24:07,500
I realize and the rest the surgery

00:24:04,590 --> 00:24:10,620
library takes that instruction and

00:24:07,500 --> 00:24:12,899
generates the serialization and

00:24:10,620 --> 00:24:16,049
deserialization codes for your structure

00:24:12,899 --> 00:24:18,990
so I believe that so I can work in a

00:24:16,049 --> 00:24:24,029
very similar way for the mock testing

00:24:18,990 --> 00:24:26,669
and the mock features of so for the mock

00:24:24,029 --> 00:24:44,159
version of your stocks any other

00:24:26,669 --> 00:24:47,269
questions yes so the question is is is

00:24:44,159 --> 00:24:49,799
there a project in Roth yet that is a

00:24:47,269 --> 00:24:51,210
basically compiler generator that takes

00:24:49,799 --> 00:24:55,500
a description of a compiler and

00:24:51,210 --> 00:24:58,289
generates a compiler from from the BNF

00:24:55,500 --> 00:25:01,470
grammar or whatever it's called yeah

00:24:58,289 --> 00:25:04,409
there is there is a bunch of such

00:25:01,470 --> 00:25:06,870
projects I believe one is called Lal

00:25:04,409 --> 00:25:11,639
earth and it is based obviously on a

00:25:06,870 --> 00:25:12,960
lower parsing so yeah there are there is

00:25:11,639 --> 00:25:15,450
a multiple projects and you can

00:25:12,960 --> 00:25:18,299
basically find them by googling Russ

00:25:15,450 --> 00:25:21,720
compiler generator and there is a

00:25:18,299 --> 00:25:23,940
prominence once and the activity that

00:25:21,720 --> 00:25:28,200
are being actively developed so you can

00:25:23,940 --> 00:25:28,760
find many of them okay thanks all for

00:25:28,200 --> 00:25:33,349
your attention

00:25:28,760 --> 00:25:33,349

YouTube URL: https://www.youtube.com/watch?v=wUuifvq5Krs


