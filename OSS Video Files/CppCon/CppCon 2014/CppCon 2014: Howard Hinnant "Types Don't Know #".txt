Title: CppCon 2014: Howard Hinnant "Types Don't Know #"
Publication date: 2014-10-23
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
This presentation will be based on the following paper which will be a proposal to the C++ standards committee:

http://htmlpreview.github.io/?https://github.com/HowardHinnant/papers/blob/master/hashing.html

This paper proposes a new hashing infrastructure that completely decouples hashing algorithms from individual types that need to be hashed. This decoupling divides the hashing computation among 3 different programmers who need not coordinate with each other:

1. Authors of hashable types (keys of type K) write their hashing support just once, using no specific hashing algorithm. This code resembles (and is approximately the same amount of work as) operator== and swap for a type.

2. Authors of hashing algorithms write a functor (e.g. H) that operates on a contiguous chunk of generic memory, represented by a void const* and a number of bytes. This code has no concept of a specific key type, only of bytes to be hashed.

3. Clients who want to hash keys of type K using hashing algorithm H will form a functor of type std::uhash to give to an unordered container.

unordered_set my_set;

Source code will be available at this link: https://github.com/HowardHinnant/hash_append
--
Howard Hinnant: Lead author of several C++11 features including: move semantics, unique_ptr, , and . Coming in C++14: .Homepage is http://home.roadrunner.com/~hinnant/ (never seem to have time to make it look pretty).Lead author on two open source projects: A std::lib implementation: http://libcxx.llvm.org An Itanium ABI implementation: http://libcxxabi.llvm.orgWebsite: http://home.roadrunner.com/~hinnant/
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,159 --> 00:00:06,810
all right I guess we better get started

00:00:03,929 --> 00:00:10,200
here title this talks is types don't

00:00:06,810 --> 00:00:13,469
know pound actually its types don't know

00:00:10,200 --> 00:00:15,509
hash my name is Howard Hinnant I worked

00:00:13,469 --> 00:00:20,520
for ripple labs and I'm thrilled to be

00:00:15,509 --> 00:00:23,609
here at CPP Con 2014 so today I'm going

00:00:20,520 --> 00:00:25,890
to be talking about a new way to hash

00:00:23,609 --> 00:00:28,050
types now I'm not going to be talking

00:00:25,890 --> 00:00:32,009
about a new algorithm but rather a new

00:00:28,050 --> 00:00:34,320
infrastructure for hashing types the

00:00:32,009 --> 00:00:37,320
technique I'm talking about is being

00:00:34,320 --> 00:00:39,800
considered for Standardization it has

00:00:37,320 --> 00:00:42,059
not been accepted and there's no

00:00:39,800 --> 00:00:45,170
guarantee that it will be accepted in

00:00:42,059 --> 00:00:48,149
fact the odds are probably against it

00:00:45,170 --> 00:00:51,539
however whether or not the committee

00:00:48,149 --> 00:00:54,030
standardizes this infrastructure and if

00:00:51,539 --> 00:00:57,480
they do the soonest would be C++ 17 so

00:00:54,030 --> 00:01:00,180
that's three years away if you like this

00:00:57,480 --> 00:01:01,890
technique you can start using it today

00:01:00,180 --> 00:01:04,500
there's source code that I can point you

00:01:01,890 --> 00:01:07,049
to at the end of the talk it's a github

00:01:04,500 --> 00:01:08,700
account you can download the code and

00:01:07,049 --> 00:01:10,770
use everything that you're seeing here

00:01:08,700 --> 00:01:13,200
today if you like it and I encourage you

00:01:10,770 --> 00:01:15,600
to do so I I think it's a great new

00:01:13,200 --> 00:01:17,400
technique if you're interested in

00:01:15,600 --> 00:01:19,409
hashing types and putting them into

00:01:17,400 --> 00:01:23,159
unordered containers and that sort of

00:01:19,409 --> 00:01:24,990
thing also if there's any questions

00:01:23,159 --> 00:01:27,509
during the talk I'm the type type of

00:01:24,990 --> 00:01:30,060
speaker that you know is fine with

00:01:27,509 --> 00:01:32,430
interruptions just chat out might be

00:01:30,060 --> 00:01:33,509
best if you use the microphone there in

00:01:32,430 --> 00:01:35,520
the center of the room if you have a

00:01:33,509 --> 00:01:40,320
question just get up from your seat

00:01:35,520 --> 00:01:42,570
there you go in evidence thank you so

00:01:40,320 --> 00:01:44,490
because I only have an hour this this

00:01:42,570 --> 00:01:46,590
technique is fairly simple but there's

00:01:44,490 --> 00:01:49,740
some some details to it that that can

00:01:46,590 --> 00:01:53,009
get kind of complicated I will mention

00:01:49,740 --> 00:01:54,030
those details as I come to them but I

00:01:53,009 --> 00:01:56,610
won't dwell on them

00:01:54,030 --> 00:01:59,250
this talk will concentrate on the just

00:01:56,610 --> 00:02:00,899
the high points of this technique just

00:01:59,250 --> 00:02:03,689
because I want to give you the idea of

00:02:00,899 --> 00:02:05,729
what's going on and when I come to

00:02:03,689 --> 00:02:08,069
something that I'm really proud of or

00:02:05,729 --> 00:02:10,140
think is really important you'll see one

00:02:08,069 --> 00:02:12,300
of these these stars beside it so if

00:02:10,140 --> 00:02:13,820
you're multitasking maybe checking your

00:02:12,300 --> 00:02:15,440
email or something

00:02:13,820 --> 00:02:17,090
if you see one of these stars that's

00:02:15,440 --> 00:02:19,250
when you really should look up and pay

00:02:17,090 --> 00:02:22,820
attention because that's the part that I

00:02:19,250 --> 00:02:24,470
really want you to hear as I mentioned

00:02:22,820 --> 00:02:26,570
details will be mentioned in passing

00:02:24,470 --> 00:02:28,220
mainly just to let you know that the

00:02:26,570 --> 00:02:30,620
details exist that we thought about

00:02:28,220 --> 00:02:34,190
these details but I won't be dwelling on

00:02:30,620 --> 00:02:36,350
a lot of the nitty-gritty but my main

00:02:34,190 --> 00:02:39,590
point when I mentioned details is to

00:02:36,350 --> 00:02:40,640
just let you know that they exist let

00:02:39,590 --> 00:02:43,880
you know that we have are forgotten

00:02:40,640 --> 00:02:46,010
about such details and if you want to

00:02:43,880 --> 00:02:48,230
learn more about them you can read about

00:02:46,010 --> 00:02:50,860
them in the in the standard proposal and

00:02:48,230 --> 00:02:53,660
I'll give you a link to that as well and

00:02:50,860 --> 00:02:55,700
know that there the details are fully

00:02:53,660 --> 00:02:59,060
fresh fleshed out in the reference

00:02:55,700 --> 00:03:01,550
implementation so it's not that we were

00:02:59,060 --> 00:03:06,620
skimping on the details and in the

00:03:01,550 --> 00:03:07,790
actual code just in the presentation so

00:03:06,620 --> 00:03:11,120
some of the issues that I want to talk

00:03:07,790 --> 00:03:13,970
about as the first one is how should one

00:03:11,120 --> 00:03:16,640
combine hash codes from your bases and

00:03:13,970 --> 00:03:18,380
data members that is when I'm when I'm

00:03:16,640 --> 00:03:19,940
talking about types I don't really care

00:03:18,380 --> 00:03:22,160
about hashing the intz and hashing

00:03:19,940 --> 00:03:23,810
strings I'm talking about the classes

00:03:22,160 --> 00:03:25,850
that you guys write which are usually

00:03:23,810 --> 00:03:30,140
made up of several strings or a vector

00:03:25,850 --> 00:03:32,600
answer or what have you once you hatch

00:03:30,140 --> 00:03:34,940
each of those pieces how do you combine

00:03:32,600 --> 00:03:38,090
them together in a good way and once you

00:03:34,940 --> 00:03:41,060
do create that how do you know if you

00:03:38,090 --> 00:03:42,440
have a good hash function or not a lot

00:03:41,060 --> 00:03:44,570
of times if you're just using standard

00:03:42,440 --> 00:03:46,850
hash the specific algorithm for standard

00:03:44,570 --> 00:03:49,100
hash isn't specified so you really don't

00:03:46,850 --> 00:03:50,540
know what algorithm you happen to be

00:03:49,100 --> 00:03:53,920
using except that it was supplied by

00:03:50,540 --> 00:03:57,350
your your standard live implementer and

00:03:53,920 --> 00:03:59,180
if somehow you knew that you weren't

00:03:57,350 --> 00:04:01,040
happy with your hash function by some

00:03:59,180 --> 00:04:02,780
kind of measurement how would you go

00:04:01,040 --> 00:04:04,760
about changing it how much work do you

00:04:02,780 --> 00:04:06,950
have to do that's really what this

00:04:04,760 --> 00:04:09,310
entire infrastructure is about it's

00:04:06,950 --> 00:04:12,019
finding ways to figure this out and

00:04:09,310 --> 00:04:14,360
finding ways to easily easily switch

00:04:12,019 --> 00:04:17,209
from one hashing algorithm to another

00:04:14,360 --> 00:04:19,070
I'm not going to be suggesting any

00:04:17,209 --> 00:04:21,919
specific hashing algorithm although I

00:04:19,070 --> 00:04:23,900
will dwell on one for certain reasons

00:04:21,919 --> 00:04:27,360
and when I get to those out I'll tell

00:04:23,900 --> 00:04:29,370
you about that so to start off

00:04:27,360 --> 00:04:32,219
the whole thing I'm going to keep using

00:04:29,370 --> 00:04:34,439
this class customer as just as an

00:04:32,219 --> 00:04:37,289
example it's got a couple of strings in

00:04:34,439 --> 00:04:38,939
it it's got it in in it and I just want

00:04:37,289 --> 00:04:41,460
to explore different ways of hashing

00:04:38,939 --> 00:04:46,949
this relatively simple type as an

00:04:41,460 --> 00:04:48,330
example so the way people usually start

00:04:46,949 --> 00:04:50,669
doing this you know you might have a

00:04:48,330 --> 00:04:53,909
hash code function or however you want

00:04:50,669 --> 00:04:56,039
to name it and people often use standard

00:04:53,909 --> 00:04:58,409
hash and you know you hash your first

00:04:56,039 --> 00:05:00,419
name you hash your last name you hash

00:04:58,409 --> 00:05:02,669
your aunt you're left with three hash

00:05:00,419 --> 00:05:04,650
codes but you only hit get to return one

00:05:02,669 --> 00:05:06,180
of them so somehow you've got to combine

00:05:04,650 --> 00:05:09,270
all these hash codes together and

00:05:06,180 --> 00:05:11,819
there's a boost function called hash

00:05:09,270 --> 00:05:13,590
combined that'll do this for you and

00:05:11,819 --> 00:05:17,250
that's even been proposed for for

00:05:13,590 --> 00:05:19,800
Standardization and that will smash all

00:05:17,250 --> 00:05:24,210
these all these separate hash codes into

00:05:19,800 --> 00:05:27,240
one by some unknown algorithm so is this

00:05:24,210 --> 00:05:29,039
a good hash algorithm well we don't

00:05:27,240 --> 00:05:33,029
really know what this is doing we don't

00:05:29,039 --> 00:05:35,190
know what hash combined is doing and so

00:05:33,029 --> 00:05:37,620
we we really don't know besides testing

00:05:35,190 --> 00:05:40,409
if this is a good hash algorithm so you

00:05:37,620 --> 00:05:43,139
might test it and discover oh this is my

00:05:40,409 --> 00:05:45,860
sample data set and it's colliding this

00:05:43,139 --> 00:05:48,659
amount of time is that good or bad

00:05:45,860 --> 00:05:50,400
well the only way to really tell is to

00:05:48,659 --> 00:05:52,770
try a different hash algorithm and see

00:05:50,400 --> 00:05:54,569
if your number of collisions goes up or

00:05:52,770 --> 00:05:57,330
down and you might also be curious about

00:05:54,569 --> 00:06:00,810
whether hash function executes slower or

00:05:57,330 --> 00:06:04,909
faster with this alternate alternate

00:06:00,810 --> 00:06:07,439
hash algorithm so to do this you know

00:06:04,909 --> 00:06:09,990
alternate hash algorithm how do we do

00:06:07,439 --> 00:06:14,580
that what do we what do we need to do to

00:06:09,990 --> 00:06:17,639
use some other hash algorithm so as just

00:06:14,580 --> 00:06:19,969
an example my other hash algorithm is is

00:06:17,639 --> 00:06:23,339
going to be this thing called FN v1a

00:06:19,969 --> 00:06:25,560
it's a fairly old hash algorithm it's

00:06:23,339 --> 00:06:28,110
actually surprisingly good but it's not

00:06:25,560 --> 00:06:29,879
the best in the world the technical

00:06:28,110 --> 00:06:30,900
reason that I've chosen to concentrate

00:06:29,879 --> 00:06:32,909
on this one

00:06:30,900 --> 00:06:36,120
is because the whole thing fits on one

00:06:32,909 --> 00:06:39,780
slide it is the it is one of the

00:06:36,120 --> 00:06:41,580
simplest hash algorithms in in the world

00:06:39,780 --> 00:06:44,820
but despite the fact that it's so simple

00:06:41,580 --> 00:06:47,580
it contains all the key functions all

00:06:44,820 --> 00:06:50,430
the key characteristics I should say of

00:06:47,580 --> 00:06:52,050
almost every hash algorithm out there so

00:06:50,430 --> 00:06:53,310
its simplicity is great it's got

00:06:52,050 --> 00:06:55,680
everything I want to show you

00:06:53,310 --> 00:06:58,140
and yet this thing is really very simple

00:06:55,680 --> 00:06:59,820
and don't worry about all these strange

00:06:58,140 --> 00:07:01,650
numbers here because those aren't part

00:06:59,820 --> 00:07:05,430
of the characteristics that I'm that I

00:07:01,650 --> 00:07:07,890
want to show you and I'll explain those

00:07:05,430 --> 00:07:10,740
characters characteristics in a minute

00:07:07,890 --> 00:07:13,710
but at any rate if we're going to use

00:07:10,740 --> 00:07:16,950
this other hash algorithm just taking F

00:07:13,710 --> 00:07:19,470
and V 1 a as an example we might use it

00:07:16,950 --> 00:07:21,810
just like we use standard hitch we

00:07:19,470 --> 00:07:24,990
hashed the first name we hashed the last

00:07:21,810 --> 00:07:27,480
name we hashed the int and now we've got

00:07:24,990 --> 00:07:32,010
three hash codes and we've got a

00:07:27,480 --> 00:07:35,850
fallback to boost hash combined to clump

00:07:32,010 --> 00:07:39,240
these all together so I'm not really

00:07:35,850 --> 00:07:42,210
happy with this solution for one if I

00:07:39,240 --> 00:07:45,180
want to use F in v1 a I want to use F in

00:07:42,210 --> 00:07:47,070
V 1 a or if I want to use sip hash or

00:07:45,180 --> 00:07:49,380
spooky or whatever I want to use that

00:07:47,070 --> 00:07:51,620
algorithm and I don't really want to

00:07:49,380 --> 00:07:54,780
pollute it with this hash combined step

00:07:51,620 --> 00:07:56,790
it's a well-known fact that good hash

00:07:54,780 --> 00:08:00,150
algorithms are really difficult to

00:07:56,790 --> 00:08:01,979
design so we've still got this this hash

00:08:00,150 --> 00:08:04,620
combined thing and and I'm not happy

00:08:01,979 --> 00:08:06,479
with that because this is polluting my F

00:08:04,620 --> 00:08:09,780
in v1 a so the first thing I want to do

00:08:06,479 --> 00:08:12,570
is get rid of this hash combined and to

00:08:09,780 --> 00:08:14,370
do that I first want to talk about the

00:08:12,570 --> 00:08:17,430
characteristics or the anatomy of your

00:08:14,370 --> 00:08:20,250
typical hash function hash functions

00:08:17,430 --> 00:08:22,710
first of all they have a state sometimes

00:08:20,250 --> 00:08:23,850
the state can be very simple in the case

00:08:22,710 --> 00:08:25,979
of FN v1a

00:08:23,850 --> 00:08:28,650
our internal state is just a single size

00:08:25,979 --> 00:08:31,229
T but in general a hash algorithm could

00:08:28,650 --> 00:08:33,360
have like an array of size these 5 of

00:08:31,229 --> 00:08:35,940
them 10 of them whatever or really any

00:08:33,360 --> 00:08:38,039
arbitrary state and the first job of the

00:08:35,940 --> 00:08:41,430
algorithm is to initialize this state to

00:08:38,039 --> 00:08:43,219
some initial state the second in the

00:08:41,430 --> 00:08:46,410
second phase of a hash algorithm

00:08:43,219 --> 00:08:49,020
computation it consumes bytes into its

00:08:46,410 --> 00:08:50,670
internal state and then there's a

00:08:49,020 --> 00:08:53,400
finalization stage where it's no longer

00:08:50,670 --> 00:08:56,340
consuming bytes but it's continuing

00:08:53,400 --> 00:08:59,100
mix or do whatever to this hash State

00:08:56,340 --> 00:09:01,800
you might think of it as the boost hash

00:08:59,100 --> 00:09:05,430
combined phase but it's particular to

00:09:01,800 --> 00:09:07,710
every specific hashing algorithm and

00:09:05,430 --> 00:09:09,510
that's really is all there is to any

00:09:07,710 --> 00:09:11,400
hashing algorithm it's these three

00:09:09,510 --> 00:09:13,230
phases and I'm gonna be a little bit

00:09:11,400 --> 00:09:16,800
repetitive and they keep coming back to

00:09:13,230 --> 00:09:18,990
these three phases because it's it's

00:09:16,800 --> 00:09:22,350
it's key to making this whole system

00:09:18,990 --> 00:09:27,300
work so let's take an let's go back to

00:09:22,350 --> 00:09:30,420
our example FNV 1a the initialization

00:09:27,300 --> 00:09:33,300
state is just this one line here's our

00:09:30,420 --> 00:09:36,150
internal state a single-sized T and to

00:09:33,300 --> 00:09:37,830
initialize it we simply cram this number

00:09:36,150 --> 00:09:39,180
into it and it's not important what this

00:09:37,830 --> 00:09:41,040
number well it's important for the

00:09:39,180 --> 00:09:42,900
algorithm what this number is but it's

00:09:41,040 --> 00:09:45,540
not important to this talk what that

00:09:42,900 --> 00:09:47,310
number is it's important that that is

00:09:45,540 --> 00:09:50,490
the initialization phase right there

00:09:47,310 --> 00:09:51,860
it's very simple other hash algorithms

00:09:50,490 --> 00:09:55,050
will have much more complicated

00:09:51,860 --> 00:09:57,360
initialization stages but this one fits

00:09:55,050 --> 00:10:00,240
on one slide and is easy relatively easy

00:09:57,360 --> 00:10:02,280
to understand so the next four lines are

00:10:00,240 --> 00:10:06,360
the phase where you consume bytes into

00:10:02,280 --> 00:10:08,100
the internal state and then finally this

00:10:06,360 --> 00:10:09,750
is our finalization state here that's

00:10:08,100 --> 00:10:12,900
about as simple as it can get it's the

00:10:09,750 --> 00:10:14,880
identity operation to finalize this

00:10:12,900 --> 00:10:18,570
algorithm you simply return the single

00:10:14,880 --> 00:10:19,890
size T as the hash code other hash

00:10:18,570 --> 00:10:23,100
algorithms will have much more

00:10:19,890 --> 00:10:31,070
complicated finalization States but we

00:10:23,100 --> 00:10:33,930
get to go with identity here so consider

00:10:31,070 --> 00:10:36,360
repackaging this algorithm to make these

00:10:33,930 --> 00:10:38,910
three separate stages separately

00:10:36,360 --> 00:10:43,410
accessible now how would you go about

00:10:38,910 --> 00:10:45,300
that the next the next slide is going to

00:10:43,410 --> 00:10:47,100
do a neat little animation and the

00:10:45,300 --> 00:10:49,770
animation isn't there just to be cute

00:10:47,100 --> 00:10:51,660
it's to emphasize that when I repackage

00:10:49,770 --> 00:10:54,120
this thing I'm not going to change any

00:10:51,660 --> 00:10:55,590
of this source code I'm just going to

00:10:54,120 --> 00:10:57,810
move it around I'm going to turn this

00:10:55,590 --> 00:11:01,340
function into a class and you'll be able

00:10:57,810 --> 00:11:06,330
to access each of these three phases

00:11:01,340 --> 00:11:09,630
separately so looks like this

00:11:06,330 --> 00:11:11,910
now we have a class we have a default

00:11:09,630 --> 00:11:14,640
constructor that's responsible for

00:11:11,910 --> 00:11:17,370
initializing the internal state I'm

00:11:14,640 --> 00:11:19,050
using C++ 11 here to implement my

00:11:17,370 --> 00:11:21,210
default constructor that's just a detail

00:11:19,050 --> 00:11:23,610
to help me fit all this on one slide

00:11:21,210 --> 00:11:25,470
it's not really important in fact it's

00:11:23,610 --> 00:11:26,910
not that important that it be a default

00:11:25,470 --> 00:11:29,160
constructor you could construct this

00:11:26,910 --> 00:11:31,650
thing any way you want but with a simple

00:11:29,160 --> 00:11:33,450
algorithm like this default construction

00:11:31,650 --> 00:11:36,870
seems to be the right the right

00:11:33,450 --> 00:11:38,700
technique then I've got you can call it

00:11:36,870 --> 00:11:40,680
an update operator but an operator paren

00:11:38,700 --> 00:11:42,930
that takes the the same arguments as

00:11:40,680 --> 00:11:45,510
before that consumes bytes into the

00:11:42,930 --> 00:11:47,610
internal state and the key thing here is

00:11:45,510 --> 00:11:49,770
to recognize that I can call this over

00:11:47,610 --> 00:11:52,440
and over and over again I can call it

00:11:49,770 --> 00:11:54,570
more than just one time since it's now

00:11:52,440 --> 00:11:56,490
separately accessible and in my

00:11:54,570 --> 00:12:00,060
finalisation state I've coded just as

00:11:56,490 --> 00:12:05,490
explicit conversion operator to result

00:12:00,060 --> 00:12:07,410
type which is just a size T when they're

00:12:05,490 --> 00:12:09,870
in the repackaging you can imagine that

00:12:07,410 --> 00:12:12,980
for other algorithms this this could be

00:12:09,870 --> 00:12:16,230
arbitrarily complicated but here it's

00:12:12,980 --> 00:12:18,990
just very simple oh and this parts

00:12:16,230 --> 00:12:21,900
really important so separating one

00:12:18,990 --> 00:12:24,990
algorithm into three phases that's key

00:12:21,900 --> 00:12:27,870
to this whole technique let's go back to

00:12:24,990 --> 00:12:30,080
our customer class and again look at how

00:12:27,870 --> 00:12:33,240
we might write our hash code algorithm

00:12:30,080 --> 00:12:35,370
so the first step in using this is

00:12:33,240 --> 00:12:58,260
simply to default construct our RF and

00:12:35,370 --> 00:13:00,300
v1a algorithm question yes sure so the

00:12:58,260 --> 00:13:02,190
quote the question is is can we can we

00:13:00,300 --> 00:13:05,700
stick a Const here

00:13:02,190 --> 00:13:08,070
I would think generally no for that for

00:13:05,700 --> 00:13:11,520
this particular algorithm you really

00:13:08,070 --> 00:13:12,810
could but in in non-trivial out well I

00:13:11,520 --> 00:13:16,620
shouldn't say non-trivial and more

00:13:12,810 --> 00:13:19,170
complicated algorithms this will change

00:13:16,620 --> 00:13:20,220
the state further as it's doing the

00:13:19,170 --> 00:13:22,380
finalization stay

00:13:20,220 --> 00:13:24,120
and so you would have to make your state

00:13:22,380 --> 00:13:26,310
mutable if you wanted to make this

00:13:24,120 --> 00:13:37,140
constant so you might as well keep it

00:13:26,310 --> 00:13:40,470
non constant yes so you're exactly right

00:13:37,140 --> 00:13:42,570
this should be called only once and we

00:13:40,470 --> 00:13:44,490
can we'll be able to wrap that up into

00:13:42,570 --> 00:13:54,810
other code to enforce that that

00:13:44,490 --> 00:13:57,090
invariant yes that's a reasonable

00:13:54,810 --> 00:13:58,590
reasonable tweak to this algorithm you

00:13:57,090 --> 00:14:01,410
know we could one could think about

00:13:58,590 --> 00:14:10,050
doing that any other questions before I

00:14:01,410 --> 00:14:14,400
move on okay so I'm sorry

00:14:10,050 --> 00:14:16,350
oh that the comment was we we could do

00:14:14,400 --> 00:14:21,570
in our value ref on the finalization

00:14:16,350 --> 00:14:25,260
stage and our value refuge you would

00:14:21,570 --> 00:14:27,810
have to say move paren and then convert

00:14:25,260 --> 00:14:30,210
it would get the syntax would get a

00:14:27,810 --> 00:14:34,710
little bit messy but you could do it and

00:14:30,210 --> 00:14:36,360
and it's not a bad suggestion so the

00:14:34,710 --> 00:14:39,930
first thing we need to do to use it is

00:14:36,360 --> 00:14:42,390
default construct our algorithm then we

00:14:39,930 --> 00:14:45,660
call the update stage for each of the

00:14:42,390 --> 00:14:49,350
strings and the age and then we call the

00:14:45,660 --> 00:14:52,920
finalization stage which is just

00:14:49,350 --> 00:14:55,380
explicitly convert it to a size T and we

00:14:52,920 --> 00:14:57,150
have no more hash combined so the

00:14:55,380 --> 00:15:00,870
important thing now is we're hashing our

00:14:57,150 --> 00:15:04,110
entire relatively complicated data

00:15:00,870 --> 00:15:06,480
structure with FN v1a and if you think

00:15:04,110 --> 00:15:08,730
about it if we would get the exact same

00:15:06,480 --> 00:15:10,589
result if we copied the first name and

00:15:08,730 --> 00:15:12,990
the last name in the end all two

00:15:10,589 --> 00:15:16,650
contiguous memory and fed the whole

00:15:12,990 --> 00:15:19,589
thing to FN v1a at the same time that

00:15:16,650 --> 00:15:22,320
the result would be exactly the same so

00:15:19,589 --> 00:15:24,510
this is really just a nice technique for

00:15:22,320 --> 00:15:27,060
making your discontiguous memory look

00:15:24,510 --> 00:15:29,250
contiguous for you to your hashing

00:15:27,060 --> 00:15:32,370
algorithm so that you don't have to do

00:15:29,250 --> 00:15:34,110
this hash combined step so that's a win

00:15:32,370 --> 00:15:35,519
so anybody have any questions

00:15:34,110 --> 00:15:41,610
about that stage before I go on because

00:15:35,519 --> 00:15:44,370
that's kind of important okay

00:15:41,610 --> 00:15:46,620
note that this same technique can be

00:15:44,370 --> 00:15:49,529
used with almost every existing hashing

00:15:46,620 --> 00:15:50,700
algorithm so in in later on in the talk

00:15:49,529 --> 00:15:53,640
I'm going to show that we're going to

00:15:50,700 --> 00:15:55,110
want to switch not only to FNV 1a but

00:15:53,640 --> 00:15:56,760
any other hashing algorithm you can

00:15:55,110 --> 00:15:58,829
think of or that somebody has written up

00:15:56,760 --> 00:16:00,750
it's going to be very important to

00:15:58,829 --> 00:16:06,870
switch from one to the another very

00:16:00,750 --> 00:16:11,430
easily so making this recognizing this

00:16:06,870 --> 00:16:13,560
is is very important now what if we want

00:16:11,430 --> 00:16:19,230
to put customer in oh yes

00:16:13,560 --> 00:16:21,540
please go ahead that excellent question

00:16:19,230 --> 00:16:23,579
there is one hashing algorithm on the

00:16:21,540 --> 00:16:26,040
planet that I found that this technique

00:16:23,579 --> 00:16:29,550
does not work well with and that is siti

00:16:26,040 --> 00:16:32,339
hash now city hashes a is a great

00:16:29,550 --> 00:16:35,040
hashing function but it has a property

00:16:32,339 --> 00:16:38,430
that it wants to see the entire length

00:16:35,040 --> 00:16:41,370
of the hashing of the memory right up

00:16:38,430 --> 00:16:43,890
front and so the only way to really use

00:16:41,370 --> 00:16:46,620
this technique with city hash is instead

00:16:43,890 --> 00:16:48,540
of consuming the bytes as you see them

00:16:46,620 --> 00:16:50,430
to store them in a vector or something

00:16:48,540 --> 00:16:52,010
and then do everything at once and that

00:16:50,430 --> 00:16:55,050
would just be ridiculously expensive

00:16:52,010 --> 00:16:56,550
certainly easily implementable but you

00:16:55,050 --> 00:17:01,399
don't really want to be allocating

00:16:56,550 --> 00:17:01,399
memory under your hash function yes oh

00:17:16,819 --> 00:17:36,480
I'm not sure I'm understanding the

00:17:19,169 --> 00:17:41,160
question some other class ok oh okay yes

00:17:36,480 --> 00:17:42,690
I I think I'll be able to answer your

00:17:41,160 --> 00:17:44,700
question a little bit further in the

00:17:42,690 --> 00:17:47,690
talk and if I don't please ask it again

00:17:44,700 --> 00:17:47,690
yes

00:17:54,940 --> 00:17:59,120
I'm sorry I'm not quite understanding

00:17:57,770 --> 00:18:00,710
here maybe if you spoke into the

00:17:59,120 --> 00:18:20,330
microphone it would be louder and I

00:18:00,710 --> 00:18:31,760
could hear oh sorry I went to went too

00:18:20,330 --> 00:18:37,360
far here are you're asking about this

00:18:31,760 --> 00:18:48,910
static cast here and why is it there

00:18:37,360 --> 00:18:52,130
yeah oh okay

00:18:48,910 --> 00:18:56,090
FairPoint this is just syntax at this

00:18:52,130 --> 00:18:57,980
point so I'd like to move on and yeah

00:18:56,090 --> 00:19:01,400
the syntax of this can be can be varied

00:18:57,980 --> 00:19:04,480
somewhat you know it's just the naming

00:19:01,400 --> 00:19:06,530
but the important point is that as the

00:19:04,480 --> 00:19:08,900
technique we're using to be able to

00:19:06,530 --> 00:19:15,080
switch from one algorithm to another one

00:19:08,900 --> 00:19:17,990
hashing algorithm to another so what

00:19:15,080 --> 00:19:20,600
happens if we put customer into a larger

00:19:17,990 --> 00:19:22,040
class and let's say we you know now

00:19:20,600 --> 00:19:24,710
we've got a class with a customer and a

00:19:22,040 --> 00:19:27,020
product and a date and we prepared each

00:19:24,710 --> 00:19:30,890
one of these with our FNV 1a algorithm

00:19:27,020 --> 00:19:33,020
and how do we hash our larger class now

00:19:30,890 --> 00:19:34,850
so our first try is you know you call

00:19:33,020 --> 00:19:37,940
hash code on on each of these three

00:19:34,850 --> 00:19:39,230
things and lo and behold we we're back

00:19:37,940 --> 00:19:41,720
with hash combined we've got the same

00:19:39,230 --> 00:19:45,500
problem we started with so we need to

00:19:41,720 --> 00:19:48,860
fix that one another way of saying this

00:19:45,500 --> 00:19:50,840
is this solution is not yet composable

00:19:48,860 --> 00:19:53,870
and and and we want to make it

00:19:50,840 --> 00:19:57,679
composable so let's go back to our

00:19:53,870 --> 00:19:59,710
customer class and fix this if you look

00:19:57,679 --> 00:20:02,310
at this

00:19:59,710 --> 00:20:05,010
we what we really need to get rid of is

00:20:02,310 --> 00:20:07,540
constructing the hash function here and

00:20:05,010 --> 00:20:10,450
finalizing the hash function here all

00:20:07,540 --> 00:20:13,180
customers should do is just the update

00:20:10,450 --> 00:20:14,890
stage here in the middle so just for the

00:20:13,180 --> 00:20:17,020
time being imagine that some other piece

00:20:14,890 --> 00:20:19,510
of code don't have to think about where

00:20:17,020 --> 00:20:21,490
yet is going to initialize our hash

00:20:19,510 --> 00:20:24,130
function and some other piece of code is

00:20:21,490 --> 00:20:28,180
going to finalize it and all customer

00:20:24,130 --> 00:20:30,370
needs to do is append to it so with that

00:20:28,180 --> 00:20:33,160
in mind we've got a function here

00:20:30,370 --> 00:20:35,140
instead of instead of computing the hash

00:20:33,160 --> 00:20:37,930
code right here in customer we've got a

00:20:35,140 --> 00:20:41,620
function called hash append that gets an

00:20:37,930 --> 00:20:44,160
FN v1a object from somewhere else a pins

00:20:41,620 --> 00:20:46,900
to it and that's it doesn't bother

00:20:44,160 --> 00:20:55,690
finalizing it and we'll explain later

00:20:46,900 --> 00:20:57,220
how we get the hash code yes it should

00:20:55,690 --> 00:21:01,420
be a friend because we're going to use

00:20:57,220 --> 00:21:05,440
the same syntax for scalars and so think

00:21:01,420 --> 00:21:09,250
of this as a swap function this is very

00:21:05,440 --> 00:21:10,330
much like swap and it doesn't have to be

00:21:09,250 --> 00:21:16,060
a friend but it should be a namespace

00:21:10,330 --> 00:21:19,750
scoped function so with this let's now

00:21:16,060 --> 00:21:22,600
go back to sale class we have our sale

00:21:19,750 --> 00:21:24,880
class it has a hash append now it has to

00:21:22,600 --> 00:21:27,610
do is called hash append on each of eath

00:21:24,880 --> 00:21:29,680
its members so like I was saying before

00:21:27,610 --> 00:21:32,260
this is a bit like a swap function or

00:21:29,680 --> 00:21:34,630
even an operator equal equal if you've

00:21:32,260 --> 00:21:36,610
got some class and you want to implement

00:21:34,630 --> 00:21:38,950
the operator equal equal on it you

00:21:36,610 --> 00:21:41,050
usually call operator equal equal on

00:21:38,950 --> 00:21:43,240
it's all of its bases and all of its

00:21:41,050 --> 00:21:45,430
data members and that may in turn

00:21:43,240 --> 00:21:48,210
recurse down and call operator equal

00:21:45,430 --> 00:21:51,810
equal on its basis and members etc etc

00:21:48,210 --> 00:21:55,270
so we have a composable solution here

00:21:51,810 --> 00:21:58,840
since we just update state to the hash

00:21:55,270 --> 00:22:00,820
append this calls hash append and then

00:21:58,840 --> 00:22:03,160
each one of these individual hash

00:22:00,820 --> 00:22:05,260
depends may call hash append further on

00:22:03,160 --> 00:22:10,000
its data members and so forth and so on

00:22:05,260 --> 00:22:12,080
until you get down to scalars primitive

00:22:10,000 --> 00:22:15,860
types are scalars

00:22:12,080 --> 00:22:19,370
can then just call hash append on their

00:22:15,860 --> 00:22:27,770
on their direct memory oh I'm sorry I

00:22:19,370 --> 00:22:29,810
skipped ahead a little bit yes primitive

00:22:27,770 --> 00:22:32,360
types and and standard defined types can

00:22:29,810 --> 00:22:34,940
be can be given hash append overloads so

00:22:32,360 --> 00:22:36,620
we can simplify this bit this part is

00:22:34,940 --> 00:22:40,910
actually why I'm trying to get this

00:22:36,620 --> 00:22:43,400
standardized if if int and unsigned long

00:22:40,910 --> 00:22:45,410
long and all those have hash appends and

00:22:43,400 --> 00:22:48,290
standard string and standard vector and

00:22:45,410 --> 00:22:51,950
tuple and pair etc etc they all need

00:22:48,290 --> 00:22:53,630
hash append overloads to now in the next

00:22:51,950 --> 00:22:55,070
three years if you want to go ahead and

00:22:53,630 --> 00:22:57,620
implement this before the committee

00:22:55,070 --> 00:22:59,840
provides it for you there is software to

00:22:57,620 --> 00:23:02,180
do this I can point it to you it's just

00:22:59,840 --> 00:23:04,490
a pain in the rear it would be so

00:23:02,180 --> 00:23:07,250
helpful if the committee would say okay

00:23:04,490 --> 00:23:10,220
we'll supply hash append for nth and

00:23:07,250 --> 00:23:10,610
long long and string and so forth and so

00:23:10,220 --> 00:23:12,710
on

00:23:10,610 --> 00:23:15,820
and then you can write your hash a pins

00:23:12,710 --> 00:23:19,190
like this instead of calling the

00:23:15,820 --> 00:23:22,760
extremely ugly update operator and this

00:23:19,190 --> 00:23:25,910
way you know this way you let string

00:23:22,760 --> 00:23:29,720
itself to find how it's going to update

00:23:25,910 --> 00:23:32,090
its state to a algorithm and you let int

00:23:29,720 --> 00:23:33,530
defined how it's going to update its

00:23:32,090 --> 00:23:36,200
state to an algorithm those are details

00:23:33,530 --> 00:23:37,910
for stringing int in other words if you

00:23:36,200 --> 00:23:40,580
look at this in the bigger picture each

00:23:37,910 --> 00:23:42,410
type is individually responsible for

00:23:40,580 --> 00:23:45,320
saying this is how I want to present

00:23:42,410 --> 00:23:47,630
myself to a hashing algorithm and so

00:23:45,320 --> 00:23:55,460
types that compose it simply have to

00:23:47,630 --> 00:23:57,140
forward to its hash append so if all

00:23:55,460 --> 00:24:00,050
hashing algorithms follow the same

00:23:57,140 --> 00:24:02,270
interfaces I've shown for FNV one a hash

00:24:00,050 --> 00:24:04,060
append can really be templated on the

00:24:02,270 --> 00:24:07,640
hash algorithm instead of being

00:24:04,060 --> 00:24:10,280
specialized for just FN v1a and now

00:24:07,640 --> 00:24:12,890
customer can be hashed using any hash

00:24:10,280 --> 00:24:15,830
algorithm it doesn't have to know

00:24:12,890 --> 00:24:18,530
anything at all about FN v1a just by

00:24:15,830 --> 00:24:19,610
templating it so another important point

00:24:18,530 --> 00:24:41,750
there

00:24:19,610 --> 00:24:44,990
yes what so the question is why not make

00:24:41,750 --> 00:25:03,500
hash a pin to function plated on to

00:24:44,990 --> 00:25:08,300
things and then specialize it yeah you

00:25:03,500 --> 00:25:09,830
could write you know you still have to

00:25:08,300 --> 00:25:11,750
specialize it for each class because

00:25:09,830 --> 00:25:13,850
it's gonna be a different number of hash

00:25:11,750 --> 00:25:15,440
of pins for each class depending on its

00:25:13,850 --> 00:25:17,330
data's you know how many data members it

00:25:15,440 --> 00:25:18,020
has in how many bases and what their

00:25:17,330 --> 00:25:25,940
names are

00:25:18,020 --> 00:25:28,400
etc etc okay a minor point it's it's

00:25:25,940 --> 00:25:30,980
very easy to to write a very attic

00:25:28,400 --> 00:25:32,480
version of this hash upend it doesn't

00:25:30,980 --> 00:25:35,330
change anything it just except for the

00:25:32,480 --> 00:25:37,370
syntax yes a very attic version of hash

00:25:35,330 --> 00:25:39,320
append exists so you can write it like

00:25:37,370 --> 00:25:40,760
this if you prefer there's no

00:25:39,320 --> 00:25:42,680
performance difference there's no

00:25:40,760 --> 00:25:46,880
functionality difference but a lot of

00:25:42,680 --> 00:25:50,600
people really prefer this syntax so that

00:25:46,880 --> 00:25:52,010
exists when you get down to two scalars

00:25:50,600 --> 00:25:53,540
or if you have to implement this

00:25:52,010 --> 00:25:56,840
yourself because the standard committee

00:25:53,540 --> 00:25:58,520
hasn't done it for you yet hash a pin

00:25:56,840 --> 00:26:00,830
for an INT you know is just take the

00:25:58,520 --> 00:26:03,560
address of the int and send in you know

00:26:00,830 --> 00:26:07,550
however many bytes is the nth is long

00:26:03,560 --> 00:26:08,960
typically for or for a pointer take the

00:26:07,550 --> 00:26:11,240
address of the pointer you send it in

00:26:08,960 --> 00:26:13,610
and this is calling the update of the

00:26:11,240 --> 00:26:16,070
algorithm and just as a reminder those

00:26:13,610 --> 00:26:19,580
calls are specifically calling into this

00:26:16,070 --> 00:26:21,290
function right here so in general this

00:26:19,580 --> 00:26:24,410
is going to be called for your ents in

00:26:21,290 --> 00:26:28,220
your unsigned Long's and your your

00:26:24,410 --> 00:26:30,560
pointers your scalar types and with any

00:26:28,220 --> 00:26:32,120
luck a few years from now that work will

00:26:30,560 --> 00:26:32,659
be done by the committee instead of hat

00:26:32,120 --> 00:26:35,809
you have

00:26:32,659 --> 00:26:38,419
to put it into your own application so

00:26:35,809 --> 00:26:40,639
if you look at a built-up complicated

00:26:38,419 --> 00:26:42,859
class like sale which is composed of

00:26:40,639 --> 00:26:44,960
customer product and date and then if

00:26:42,859 --> 00:26:46,399
you look into customer product and date

00:26:44,960 --> 00:26:48,710
they're going to be composed of other

00:26:46,399 --> 00:26:51,019
things and eventually you drill down to

00:26:48,710 --> 00:26:53,359
scalars and you can think of this this

00:26:51,019 --> 00:26:55,429
class is being composed of a whole bunch

00:26:53,359 --> 00:26:57,710
of scalars and discontiguous memory and

00:26:55,429 --> 00:26:59,899
what this is what hash append is doing

00:26:57,710 --> 00:27:01,759
is recursively drilling down into this

00:26:59,899 --> 00:27:04,340
data structure until it finds a scalar

00:27:01,759 --> 00:27:05,960
and then sending those bytes to the hash

00:27:04,340 --> 00:27:08,749
algorithm this is actually very

00:27:05,960 --> 00:27:11,389
analogous to serialization works the

00:27:08,749 --> 00:27:14,029
same way you when you serialize

00:27:11,389 --> 00:27:15,769
something you say ok serialize the first

00:27:14,029 --> 00:27:17,299
member and serialize the second member

00:27:15,769 --> 00:27:19,549
and those in turn will have

00:27:17,299 --> 00:27:21,859
serialization that'll drill down until

00:27:19,549 --> 00:27:23,899
you hit something like int you know with

00:27:21,859 --> 00:27:25,729
a value of 5 and you print out of 5 and

00:27:23,899 --> 00:27:27,830
here we're simply sending the 5 to a

00:27:25,729 --> 00:27:30,830
hashing algorithm instead of to a stream

00:27:27,830 --> 00:27:32,629
so this really is it very strange it's

00:27:30,830 --> 00:27:34,729
just that people haven't seen it in the

00:27:32,629 --> 00:27:40,609
context of hashing before that's the

00:27:34,729 --> 00:27:43,729
only thing that makes it strange so in

00:27:40,609 --> 00:27:45,919
general for this technique every single

00:27:43,729 --> 00:27:49,159
type that you might want to hash or even

00:27:45,919 --> 00:27:52,129
somehow participate in a hash

00:27:49,159 --> 00:27:54,499
computation has to have a hash append

00:27:52,129 --> 00:27:57,019
overload and that'll overload will

00:27:54,499 --> 00:27:58,849
either call hash append on all its basis

00:27:57,019 --> 00:28:00,859
and members or at least those bases and

00:27:58,849 --> 00:28:04,039
members that should participate in a

00:28:00,859 --> 00:28:05,450
hashing computation or it will send

00:28:04,039 --> 00:28:08,029
bytes of its memory straight to the hash

00:28:05,450 --> 00:28:11,960
algorithm as would an int or a long-long

00:28:08,029 --> 00:28:14,539
or what have you and no type at all is

00:28:11,960 --> 00:28:16,639
aware of any concrete hashing algorithm

00:28:14,539 --> 00:28:18,769
that's key because you want to be able

00:28:16,639 --> 00:28:22,460
to switch from one hashing algorithm to

00:28:18,769 --> 00:28:24,679
another so I've talked a lot about hash

00:28:22,460 --> 00:28:26,269
append and I haven't said much about how

00:28:24,679 --> 00:28:29,200
to use it in fact we still don't know

00:28:26,269 --> 00:28:32,179
how we get a hash code out of this thing

00:28:29,200 --> 00:28:34,190
well it turns out that that's assuming

00:28:32,179 --> 00:28:36,259
you've got a hash append for every type

00:28:34,190 --> 00:28:38,179
in the universe now and perhaps the

00:28:36,259 --> 00:28:42,559
committee has helped us with with half

00:28:38,179 --> 00:28:45,109
of those types to get a hash out to get

00:28:42,559 --> 00:28:46,790
actual hash code well you default

00:28:45,109 --> 00:28:50,160
construct your hash out

00:28:46,790 --> 00:28:52,230
then for whatever your type is here I'm

00:28:50,160 --> 00:28:55,080
calling it t you have pinned to it and

00:28:52,230 --> 00:28:56,670
that may in turn call hash upend on each

00:28:55,080 --> 00:29:00,330
of its parts and so forth and so on

00:28:56,670 --> 00:29:03,480
until it gets down to scalars and then

00:29:00,330 --> 00:29:05,190
you finalize the algorithm with and here

00:29:03,480 --> 00:29:07,950
I've you know relatively arbitrarily

00:29:05,190 --> 00:29:11,070
chosen the the explicit convergence in

00:29:07,950 --> 00:29:14,610
text to finalize so just three steps to

00:29:11,070 --> 00:29:16,890
do this of course one step is always

00:29:14,610 --> 00:29:19,650
better than three steps so you might

00:29:16,890 --> 00:29:24,200
wrap this up in a class and that class

00:29:19,650 --> 00:29:24,200
is called a standard conforming hash

00:29:25,460 --> 00:29:31,140
function it on the hash algorithm for

00:29:28,500 --> 00:29:36,110
grins up put a default template to our

00:29:31,140 --> 00:29:36,110
favorite FN v1a hashing algorithm and

00:29:36,200 --> 00:29:41,520
it's got a nested type result type which

00:29:39,000 --> 00:29:43,290
is the result type of the hashing

00:29:41,520 --> 00:29:45,720
algorithm if you're putting this into

00:29:43,290 --> 00:29:47,430
unknown or containers this result type

00:29:45,720 --> 00:29:49,230
has to be a size T so you can just think

00:29:47,430 --> 00:29:52,890
everywhere I've written result type here

00:29:49,230 --> 00:29:55,280
just think size t and then our three

00:29:52,890 --> 00:29:59,550
simple steps are just wrapped up in the

00:29:55,280 --> 00:30:05,250
operator paren here so now that we have

00:29:59,550 --> 00:30:06,660
this conforming hash function forming

00:30:05,250 --> 00:30:09,600
hash function you just drop it straight

00:30:06,660 --> 00:30:12,240
into your unordered set and now you can

00:30:09,600 --> 00:30:16,340
hash customer using standard unordered

00:30:12,240 --> 00:30:19,410
set or unordered map or what have you

00:30:16,340 --> 00:30:35,880
now I've talked a lot about switching oh

00:30:19,410 --> 00:30:37,350
before I go on question yes actually

00:30:35,880 --> 00:30:40,440
you're you're getting into one of the

00:30:37,350 --> 00:30:42,030
details that L that I'll get to on a few

00:30:40,440 --> 00:30:49,670
slides or at least is contiguously

00:30:42,030 --> 00:30:49,670
hashable at any rate yes sure

00:30:58,250 --> 00:31:05,040
as in the right here in the construction

00:31:02,520 --> 00:31:12,210
yes it would your a couple of slides

00:31:05,040 --> 00:31:18,900
ahead of me let me just catch up on the

00:31:12,210 --> 00:31:20,430
slides real quick get her that's the

00:31:18,900 --> 00:31:29,640
trouble with putting too many animations

00:31:20,430 --> 00:31:32,040
on one slide alright so if we want to

00:31:29,640 --> 00:31:34,740
change hash functions the great thing is

00:31:32,040 --> 00:31:39,300
that we don't have to to touch anything

00:31:34,740 --> 00:31:41,460
but this guy right here we just slip in

00:31:39,300 --> 00:31:45,630
a new hash function here I'm using sip

00:31:41,460 --> 00:31:48,360
hashes an example and now we're now

00:31:45,630 --> 00:31:50,340
we're hashing sail on this completely

00:31:48,360 --> 00:31:52,710
different algorithm we just change it

00:31:50,340 --> 00:31:56,700
right at the point of use and the key

00:31:52,710 --> 00:31:59,400
thing is here we did not change sail one

00:31:56,700 --> 00:32:02,010
bit and if you remember sail is composed

00:31:59,400 --> 00:32:03,870
of other types customer product date

00:32:02,010 --> 00:32:07,170
what-have-you we didn't have to change

00:32:03,870 --> 00:32:09,480
those either we can keep swapping out

00:32:07,170 --> 00:32:13,110
different hashing algorithms right here

00:32:09,480 --> 00:32:16,650
and it's very easy and because it's very

00:32:13,110 --> 00:32:18,900
easy it becomes trivial to experiment

00:32:16,650 --> 00:32:21,210
with different hashing algorithms and so

00:32:18,900 --> 00:32:23,310
we can we can compare one hashing

00:32:21,210 --> 00:32:25,500
algorithm to another see which gives us

00:32:23,310 --> 00:32:29,580
the fewer collisions which gives us the

00:32:25,500 --> 00:32:31,410
greater performance and and what we can

00:32:29,580 --> 00:32:33,570
do about securing against attacks if

00:32:31,410 --> 00:32:36,200
what we have to put into our unordered

00:32:33,570 --> 00:32:42,480
containers is coming from untrusted code

00:32:36,200 --> 00:32:43,950
so very important point here today when

00:32:42,480 --> 00:32:47,280
you want to switch hash algorithms you

00:32:43,950 --> 00:32:49,710
go and you have to modify each of the

00:32:47,280 --> 00:32:52,940
types that that are that you want to

00:32:49,710 --> 00:32:55,200
hash and so this gets rid of changing

00:32:52,940 --> 00:32:57,690
modifying the classes that your hashing

00:32:55,200 --> 00:32:58,940
entirely so getting back to your

00:32:57,690 --> 00:33:01,610
question

00:32:58,940 --> 00:33:03,560
wouldn't it be useful if we if we could

00:33:01,610 --> 00:33:05,180
seed our hashing algorithms I talked on

00:33:03,560 --> 00:33:08,930
the previous slide I briefly mentioned

00:33:05,180 --> 00:33:11,270
security one way you guard against one

00:33:08,930 --> 00:33:14,120
way you harden your your hash containers

00:33:11,270 --> 00:33:16,610
against attacks is to randomly seed it

00:33:14,120 --> 00:33:19,220
some hash algorithms not FNV one abus

00:33:16,610 --> 00:33:21,770
amount algorithms will allow you to seed

00:33:19,220 --> 00:33:23,150
it so imagine you've got some get seed

00:33:21,770 --> 00:33:25,280
function here and it doesn't really

00:33:23,150 --> 00:33:27,140
matter how you implement that typically

00:33:25,280 --> 00:33:29,180
it might be with a random number

00:33:27,140 --> 00:33:30,800
generator or what have you you can

00:33:29,180 --> 00:33:32,420
imagine it's very easy to write a

00:33:30,800 --> 00:33:35,300
hashing algorithm that simply has a

00:33:32,420 --> 00:33:38,840
constructor that takes a seed so how do

00:33:35,300 --> 00:33:41,720
we use that well it goes much the same

00:33:38,840 --> 00:33:44,870
way we construct it we append to it with

00:33:41,720 --> 00:33:48,200
our type we've finalized the algorithm

00:33:44,870 --> 00:33:55,660
and we wrapped the whole thing up in a

00:33:48,200 --> 00:33:58,100
conforming hash function forming hash

00:33:55,660 --> 00:34:00,080
function up to fit on one slide that

00:33:58,100 --> 00:34:01,640
means they're easy enough that you can

00:34:00,080 --> 00:34:03,560
make as many of these things as you want

00:34:01,640 --> 00:34:05,000
you can make an unseeded hash funkier

00:34:03,560 --> 00:34:07,370
you can make a seated hash function

00:34:05,000 --> 00:34:12,500
functor you could make hash functions

00:34:07,370 --> 00:34:15,050
that salted are padded this this type by

00:34:12,500 --> 00:34:17,750
appending to it either before you call

00:34:15,050 --> 00:34:20,060
hash append here or append to it with

00:34:17,750 --> 00:34:21,310
salt or padding afterward you can do any

00:34:20,060 --> 00:34:23,540
number of things in these

00:34:21,310 --> 00:34:25,610
special-purpose hash functions and I'm

00:34:23,540 --> 00:34:27,320
sure you know if people start using this

00:34:25,610 --> 00:34:29,510
technique like you guys you're a lot

00:34:27,320 --> 00:34:37,639
more clever than me you'll think of wild

00:34:29,510 --> 00:34:39,830
things to do with your hash function to

00:34:37,639 --> 00:34:40,280
at least to create the operator per in

00:34:39,830 --> 00:34:44,030
of it

00:34:40,280 --> 00:34:45,980
so creating hash functions is it's very

00:34:44,030 --> 00:34:49,159
easy and it's very easy to use them you

00:34:45,980 --> 00:34:52,100
just now plug this into your your

00:34:49,159 --> 00:34:55,159
unordered set or an unordered map right

00:34:52,100 --> 00:34:57,530
at the point of use and so you can not

00:34:55,159 --> 00:35:00,500
only change from one hash algorithm to

00:34:57,530 --> 00:35:02,720
another you can change from seated hash

00:35:00,500 --> 00:35:04,820
functions to not seated hash functions

00:35:02,720 --> 00:35:07,820
back and forth to see how that affects

00:35:04,820 --> 00:35:11,609
their performance your collisions etc

00:35:07,820 --> 00:35:15,759
etc very easy to experiment

00:35:11,609 --> 00:35:19,059
it's also easy to set up defaults you

00:35:15,759 --> 00:35:21,940
don't always have to use unordered set

00:35:19,059 --> 00:35:26,920
directly and plug in a custom hash

00:35:21,940 --> 00:35:29,019
function now with using template aliases

00:35:26,920 --> 00:35:32,190
you can just create your own template

00:35:29,019 --> 00:35:35,259
alias make your hash function default

00:35:32,190 --> 00:35:37,480
whatever you like and now whenever you

00:35:35,259 --> 00:35:39,700
use I called mine hash set whenever you

00:35:37,480 --> 00:35:42,220
use hash set it's going to be using your

00:35:39,700 --> 00:35:44,559
favorite hash by default so this doesn't

00:35:42,220 --> 00:35:47,980
have to make your day-to-day earlier use

00:35:44,559 --> 00:35:51,730
a lot uglier you just set one of these

00:35:47,980 --> 00:35:56,980
up wherever everybody can see it and go

00:35:51,730 --> 00:35:59,680
to town with it so I mentioned that

00:35:56,980 --> 00:36:01,809
there were going to be a few details one

00:35:59,680 --> 00:36:04,690
of them is this trait there's a trait

00:36:01,809 --> 00:36:07,299
called is contiguously hashable and what

00:36:04,690 --> 00:36:09,250
it basically says is can you feed this

00:36:07,299 --> 00:36:13,269
types bytes directly into the hash

00:36:09,250 --> 00:36:15,430
function it's update operator so it's

00:36:13,269 --> 00:36:18,730
going to be true for two's complement

00:36:15,430 --> 00:36:21,400
intz and that sort of thing be true for

00:36:18,730 --> 00:36:22,960
pointers on on most platforms it's

00:36:21,400 --> 00:36:27,039
actually not true for floating-point

00:36:22,960 --> 00:36:30,940
types a I Triple E floating point type

00:36:27,039 --> 00:36:31,990
is it contiguously hashable because one

00:36:30,940 --> 00:36:34,240
of the requirements for being

00:36:31,990 --> 00:36:38,609
contiguously hashable is that every bit

00:36:34,240 --> 00:36:41,680
pattern should should every bit pattern

00:36:38,609 --> 00:36:44,319
will hash to a different value and thus

00:36:41,680 --> 00:36:46,599
every bit pattern should not be equal to

00:36:44,319 --> 00:36:49,509
any other bit pattern and if you recall

00:36:46,599 --> 00:36:51,400
in floating points negative zero is

00:36:49,509 --> 00:36:53,200
equal to zero but they're represented

00:36:51,400 --> 00:36:54,789
with different bit patterns but since

00:36:53,200 --> 00:36:57,910
they're equal you want them to hash to

00:36:54,789 --> 00:36:59,619
the same hash code so a hash a pen for

00:36:57,910 --> 00:37:02,589
floating-point might set negative zero

00:36:59,619 --> 00:37:07,869
to positive zero before sending itself

00:37:02,589 --> 00:37:11,640
to the update algorithm so as

00:37:07,869 --> 00:37:13,990
continuously hashable is also

00:37:11,640 --> 00:37:17,559
performance optimization for types like

00:37:13,990 --> 00:37:19,329
tuple string and vector string is

00:37:17,559 --> 00:37:22,480
composed of this contiguous array of

00:37:19,329 --> 00:37:25,050
chars we will know by this trait that

00:37:22,480 --> 00:37:27,300
char will be contiguously hashable i

00:37:25,050 --> 00:37:29,360
hope and so this tells string that it

00:37:27,300 --> 00:37:32,880
can send its entire data buffer at once

00:37:29,360 --> 00:37:35,790
to the hashing algorithm update function

00:37:32,880 --> 00:37:38,040
and the more modern hashing algorithms

00:37:35,790 --> 00:37:38,490
the more memory you send them to them at

00:37:38,040 --> 00:37:40,890
once

00:37:38,490 --> 00:37:42,570
the faster they work so that's that's

00:37:40,890 --> 00:37:44,910
really the main motivation for having

00:37:42,570 --> 00:37:48,180
this trait here is optimization for

00:37:44,910 --> 00:37:49,680
string vector and even tuple if you can

00:37:48,180 --> 00:37:52,500
prove that there's no padding between

00:37:49,680 --> 00:37:57,000
the different elements then it can also

00:37:52,500 --> 00:37:59,100
be contiguously hashable and there's

00:37:57,000 --> 00:38:01,260
there's a way to do that and I don't

00:37:59,100 --> 00:38:03,600
want to go into those details here but

00:38:01,260 --> 00:38:05,670
it's in the it's in the source code it's

00:38:03,600 --> 00:38:07,260
not terribly hard but I really would

00:38:05,670 --> 00:38:09,570
like the committee to supply that code

00:38:07,260 --> 00:38:12,720
instead of asking you guys to do it at

00:38:09,570 --> 00:38:17,270
least three years from now do you have a

00:38:12,720 --> 00:38:17,270
question Nevin or oh okay all right

00:38:17,840 --> 00:38:24,960
so another detail is there does exist a

00:38:22,950 --> 00:38:26,780
way to write hash a pin for pimple types

00:38:24,960 --> 00:38:29,190
pimple types is where you have a

00:38:26,780 --> 00:38:32,160
incomplete type in your in your header

00:38:29,190 --> 00:38:33,480
that's surrounded by a handle object and

00:38:32,160 --> 00:38:36,540
you go to your source and that's where

00:38:33,480 --> 00:38:39,090
you expand your your your incomplete

00:38:36,540 --> 00:38:42,210
type to a complete type and if you

00:38:39,090 --> 00:38:43,860
recall all the hash append functions

00:38:42,210 --> 00:38:46,320
that I've shown you so so far our

00:38:43,860 --> 00:38:48,420
template Adhan the hash algorithm so you

00:38:46,320 --> 00:38:50,510
might have been wondering well gee if

00:38:48,420 --> 00:38:54,110
I'm in a source file how do I get this

00:38:50,510 --> 00:38:57,000
generic hash function into my pimple and

00:38:54,110 --> 00:39:00,600
the way you do it is with what I call ie

00:38:57,000 --> 00:39:03,330
a type erasing hash algorithm adapter

00:39:00,600 --> 00:39:06,090
and you can think of this it's it's very

00:39:03,330 --> 00:39:08,790
analogous to standard function standard

00:39:06,090 --> 00:39:11,580
function is a type erasing func door

00:39:08,790 --> 00:39:13,350
adapter when you use a standard function

00:39:11,580 --> 00:39:15,060
you don't know what type of functor

00:39:13,350 --> 00:39:16,860
you've put into it except unless you

00:39:15,060 --> 00:39:19,170
happen to have access to the way you

00:39:16,860 --> 00:39:21,420
constructed it and you simply call it

00:39:19,170 --> 00:39:24,720
without knowing what type of functor is

00:39:21,420 --> 00:39:27,390
in there X lass a the function pointer a

00:39:24,720 --> 00:39:31,950
lambda you just don't know it at the

00:39:27,390 --> 00:39:34,110
point of call so there's a type of

00:39:31,950 --> 00:39:35,550
racing hash algorithm adapter works

00:39:34,110 --> 00:39:39,150
exactly the same way in fact it's

00:39:35,550 --> 00:39:41,670
implemented by using a standard function

00:39:39,150 --> 00:39:42,990
it's it's in the source code it's more

00:39:41,670 --> 00:39:45,300
than I wanted to present here but I

00:39:42,990 --> 00:39:47,600
wanted to let you know that if you're

00:39:45,300 --> 00:39:50,280
writing if you're using the pimple idiom

00:39:47,600 --> 00:39:53,490
now which is a you know very good at iam

00:39:50,280 --> 00:39:55,500
you're not out you're not left out in

00:39:53,490 --> 00:40:00,510
the cold you can use this technique with

00:39:55,500 --> 00:40:03,420
the pimple idiom finally if you're

00:40:00,510 --> 00:40:06,120
concerned about Indian there's a way to

00:40:03,420 --> 00:40:09,540
handle that this is actually true at my

00:40:06,120 --> 00:40:11,850
company we we have a situation where we

00:40:09,540 --> 00:40:15,180
have a network of computers and we're

00:40:11,850 --> 00:40:18,030
hashing data structures using sha-256

00:40:15,180 --> 00:40:20,430
for security purposes just to preserve

00:40:18,030 --> 00:40:22,230
the integrity of the data structure if

00:40:20,430 --> 00:40:24,480
one machine on this side of the node

00:40:22,230 --> 00:40:26,610
hatches this data structure and another

00:40:24,480 --> 00:40:28,860
machine on the on the other side of the

00:40:26,610 --> 00:40:30,720
network hashes the exact same data

00:40:28,860 --> 00:40:33,030
structure with the same values in it it

00:40:30,720 --> 00:40:34,470
better get the same hashcode otherwise

00:40:33,030 --> 00:40:37,200
these two computers aren't going to be

00:40:34,470 --> 00:40:40,500
able to agree about the contents of what

00:40:37,200 --> 00:40:41,820
they're hashing and the hashing is

00:40:40,500 --> 00:40:43,800
important of course for security

00:40:41,820 --> 00:40:45,900
purposes if these machines happen to be

00:40:43,800 --> 00:40:48,060
of two different Indians but otherwise

00:40:45,900 --> 00:40:51,930
they have identical layout for stuff

00:40:48,060 --> 00:40:54,000
like int sand and pointers these two

00:40:51,930 --> 00:40:56,450
machines ought to be able to agree on on

00:40:54,000 --> 00:40:59,210
how to hash these things so there's

00:40:56,450 --> 00:41:03,000
within within this whole technique

00:40:59,210 --> 00:41:06,600
there's a trigger for saying before you

00:41:03,000 --> 00:41:08,340
hash your 64-bit swap the swap the bytes

00:41:06,600 --> 00:41:11,580
on it because the Indian isn't right on

00:41:08,340 --> 00:41:13,980
your native platform that detail exists

00:41:11,580 --> 00:41:16,290
it's in the reference implementation but

00:41:13,980 --> 00:41:22,350
I didn't want to take time on going into

00:41:16,290 --> 00:41:26,040
it today so moving along here

00:41:22,350 --> 00:41:28,530
in summary every type that may be hashed

00:41:26,040 --> 00:41:30,840
or participate in a hash computation

00:41:28,530 --> 00:41:34,230
must have a hash append overload and

00:41:30,840 --> 00:41:35,580
this is really the hard part and this is

00:41:34,230 --> 00:41:37,680
why I'm trying to get this technique

00:41:35,580 --> 00:41:40,680
standardized because if we get the

00:41:37,680 --> 00:41:42,450
committee to write hash a pin for int

00:41:40,680 --> 00:41:44,880
and unsigned long long and pointers and

00:41:42,450 --> 00:41:47,910
enums and pairs and tuples and vectors

00:41:44,880 --> 00:41:50,550
and strings that will take a huge amount

00:41:47,910 --> 00:41:51,810
of work out of implementing this

00:41:50,550 --> 00:41:52,539
technique for yourself it will take

00:41:51,810 --> 00:41:55,289
practical

00:41:52,539 --> 00:41:57,669
all of the work out of it as it is today

00:41:55,289 --> 00:41:59,529
the way you're going to handle this is

00:41:57,669 --> 00:42:02,049
download my source code from the github

00:41:59,529 --> 00:42:06,489
reference and all of that code is in

00:42:02,049 --> 00:42:08,140
there to do it for you on the other hand

00:42:06,489 --> 00:42:10,419
when you're writing hash a pin for your

00:42:08,140 --> 00:42:12,669
own type it's very easy to do it's about

00:42:10,419 --> 00:42:14,489
the same amount of effort is writing an

00:42:12,669 --> 00:42:17,169
operator equal equal for your type you

00:42:14,489 --> 00:42:19,479
new hash append each of your basis and

00:42:17,169 --> 00:42:21,549
members and it's relatively

00:42:19,479 --> 00:42:23,529
straightforward as I demonstrated for

00:42:21,549 --> 00:42:29,880
the example customer class in the

00:42:23,529 --> 00:42:32,589
example sales class so one mildly

00:42:29,880 --> 00:42:35,099
difficult part is any hash algorithm

00:42:32,589 --> 00:42:38,349
that that you want to use in this tape

00:42:35,099 --> 00:42:41,619
technique it must be adapted to expose

00:42:38,349 --> 00:42:44,259
to three phases initialization updating

00:42:41,619 --> 00:42:46,239
and finalization but note that you only

00:42:44,259 --> 00:42:48,219
have to do this once for a hash

00:42:46,239 --> 00:42:51,369
algorithm and then hash algorithm is

00:42:48,219 --> 00:42:53,259
good to use for all of your types so

00:42:51,369 --> 00:42:57,219
it's it's kind of like the STL where

00:42:53,259 --> 00:43:00,400
before the STL we had if we might have

00:42:57,219 --> 00:43:03,130
in algorithms in m containers and to

00:43:00,400 --> 00:43:04,630
give each container the the correct

00:43:03,130 --> 00:43:07,900
number of algorithms you had to write in

00:43:04,630 --> 00:43:09,669
n times m source code well that's the

00:43:07,900 --> 00:43:12,279
situation today if you're using the

00:43:09,669 --> 00:43:14,829
standard hash T style of hashing your

00:43:12,279 --> 00:43:17,859
functions if you've got in hashing

00:43:14,829 --> 00:43:20,439
algorithms and a type that's made of M

00:43:17,859 --> 00:43:21,939
sub types and you want to change hashing

00:43:20,439 --> 00:43:24,749
algorithms you're talking about writing

00:43:21,939 --> 00:43:27,159
n times M source code to arrange that

00:43:24,749 --> 00:43:32,469
using this technique we've separated it

00:43:27,159 --> 00:43:34,839
out so that you only have to adapt in

00:43:32,469 --> 00:43:37,859
algorithms and then write hash a pin for

00:43:34,839 --> 00:43:42,189
your M types and so that's only n plus M

00:43:37,859 --> 00:43:44,909
source code instead of n times M that's

00:43:42,189 --> 00:43:47,769
that this decoupling is is the whole

00:43:44,909 --> 00:43:51,329
backbone of this this technique it's the

00:43:47,769 --> 00:43:51,329
whole rationale for it to exist

00:43:52,029 --> 00:43:59,469
and finally the probably a very

00:43:55,869 --> 00:44:01,359
important point hash functions are very

00:43:59,469 --> 00:44:04,059
easy to write all they have to do is

00:44:01,359 --> 00:44:05,739
initialize algorithm update it with an

00:44:04,059 --> 00:44:06,280
item to be hashed and finalize the

00:44:05,739 --> 00:44:08,470
algorithm

00:44:06,280 --> 00:44:11,080
and this is very important that it be

00:44:08,470 --> 00:44:13,240
easy because you need to be free to

00:44:11,080 --> 00:44:15,430
write hash function to do different

00:44:13,240 --> 00:44:17,230
things like hash function that doesn't

00:44:15,430 --> 00:44:19,720
see the hash function that does seed

00:44:17,230 --> 00:44:21,130
there's very there's at least two

00:44:19,720 --> 00:44:23,500
different ways I can think of that you

00:44:21,130 --> 00:44:26,110
might want to handle random seeding you

00:44:23,500 --> 00:44:27,820
might want to have hash functions that

00:44:26,110 --> 00:44:29,710
get one random seed every time they're

00:44:27,820 --> 00:44:31,300
constructed or you might want to just

00:44:29,710 --> 00:44:33,520
get one random seed when your

00:44:31,300 --> 00:44:35,070
application starts up and use that for

00:44:33,520 --> 00:44:37,120
every hash function

00:44:35,070 --> 00:44:40,060
both ways have advantages and

00:44:37,120 --> 00:44:43,270
disadvantages and because it's so easy

00:44:40,060 --> 00:44:45,220
to write hash function you can you can

00:44:43,270 --> 00:44:47,050
create whichever technique is right for

00:44:45,220 --> 00:44:49,240
you we don't have to depend on the

00:44:47,050 --> 00:44:53,140
committee to standardize it and get the

00:44:49,240 --> 00:44:55,770
answer wrong for you and if you do all

00:44:53,140 --> 00:44:58,660
this work what are the benefits you get

00:44:55,770 --> 00:45:01,590
again you get to experiment with

00:44:58,660 --> 00:45:04,690
different hashing algorithms very easily

00:45:01,590 --> 00:45:06,940
hashing algorithms are you can either

00:45:04,690 --> 00:45:09,310
use non seeded hashing algorithms or

00:45:06,940 --> 00:45:14,290
seeded hashing algorithms and switch

00:45:09,310 --> 00:45:18,070
between them very easily I talked about

00:45:14,290 --> 00:45:20,230
getting rid of boost come I'm sorry hash

00:45:18,070 --> 00:45:22,570
combined from boost the hashing

00:45:20,230 --> 00:45:24,400
algorithms that you use are exactly as

00:45:22,570 --> 00:45:26,440
the authors of those hashing algorithms

00:45:24,400 --> 00:45:29,920
intended they're no longer polluted with

00:45:26,440 --> 00:45:32,490
these combining steps and finally what I

00:45:29,920 --> 00:45:34,870
think is the the most important point

00:45:32,490 --> 00:45:37,510
when you're writing hash support for

00:45:34,870 --> 00:45:39,430
your type you don't have to get in bed

00:45:37,510 --> 00:45:41,350
you don't have to marry any specific

00:45:39,430 --> 00:45:43,780
hashing algorithm you write your hash

00:45:41,350 --> 00:45:47,140
support once and you know that it's good

00:45:43,780 --> 00:45:49,420
for any hashing algorithm whatsoever so

00:45:47,140 --> 00:45:51,280
clients who use your type maybe three

00:45:49,420 --> 00:45:53,440
years after you've written it they can

00:45:51,280 --> 00:45:54,460
decide at that point maybe I want to use

00:45:53,440 --> 00:45:56,770
FN v1a

00:45:54,460 --> 00:46:00,010
maybe I want to use spookier sip asher

00:45:56,770 --> 00:46:02,110
even sha-256 whatever that decision is

00:46:00,010 --> 00:46:03,630
down the road and can be made by

00:46:02,110 --> 00:46:09,310
different people for their different

00:46:03,630 --> 00:46:11,470
applications so types don't know hash a

00:46:09,310 --> 00:46:13,540
type should only know what parts of

00:46:11,470 --> 00:46:15,970
itself should be presented to a hash

00:46:13,540 --> 00:46:19,180
algorithm it should not be aware of any

00:46:15,970 --> 00:46:21,880
specific hash algorithm so thus the

00:46:19,180 --> 00:46:23,770
title type stone

00:46:21,880 --> 00:46:26,670
I've been promising this link for quite

00:46:23,770 --> 00:46:28,780
a while it's about time I give it to you

00:46:26,670 --> 00:46:30,309
don't worry about memorizing this

00:46:28,780 --> 00:46:33,339
because I'm sure these slides will be

00:46:30,309 --> 00:46:35,170
made publicly available but it's on my

00:46:33,339 --> 00:46:37,630
github it's called hash append and

00:46:35,170 --> 00:46:40,030
within that directory the whole meat of

00:46:37,630 --> 00:46:42,369
this is in one source file called hash

00:46:40,030 --> 00:46:45,910
append a CH but there's also a bunch of

00:46:42,369 --> 00:46:47,980
other hat files in that source for

00:46:45,910 --> 00:46:50,349
example there's the sip hash adapter the

00:46:47,980 --> 00:46:54,450
spookie adapter the sha-256 adapter

00:46:50,349 --> 00:46:58,630
there's the type e racing hash append

00:46:54,450 --> 00:47:00,250
functor adapter whatever you call it all

00:46:58,630 --> 00:47:02,339
kinds of so when you when you download

00:47:00,250 --> 00:47:05,740
it there'll be a bunch of files in there

00:47:02,339 --> 00:47:07,510
but don't be scared off by that you can

00:47:05,740 --> 00:47:10,390
get started just with the hash append

00:47:07,510 --> 00:47:12,220
dot H function and if you want to know

00:47:10,390 --> 00:47:13,930
more about those details there in this

00:47:12,220 --> 00:47:17,470
paper here this is the paper that was

00:47:13,930 --> 00:47:19,920
submitted to the committee in 3980 and

00:47:17,470 --> 00:47:22,660
you can find it right at this link and

00:47:19,920 --> 00:47:25,119
also should mention Bloomberg got

00:47:22,660 --> 00:47:27,460
excited about this and they've they've

00:47:25,119 --> 00:47:30,760
implemented it in their open source what

00:47:27,460 --> 00:47:32,740
they called VSL I believe or B DSL I

00:47:30,760 --> 00:47:34,329
can't remember what they call it but

00:47:32,740 --> 00:47:35,799
they're all excited about it too and

00:47:34,329 --> 00:47:38,799
they they've implemented it

00:47:35,799 --> 00:47:40,750
so it's certainly implementable by other

00:47:38,799 --> 00:47:44,559
people besides myself it's implementable

00:47:40,750 --> 00:47:48,720
by you guys you just go here and go to

00:47:44,559 --> 00:47:48,720
town questions

00:47:57,220 --> 00:48:20,330
I'll try to be quick um okay I'm really

00:48:00,260 --> 00:48:22,490
nervous now writing for all those yes it

00:48:20,330 --> 00:48:24,470
is largely the legwork of just because

00:48:22,490 --> 00:48:26,450
there's so many types but there's some

00:48:24,470 --> 00:48:30,320
types that you could implement only

00:48:26,450 --> 00:48:33,950
suboptimal sub-optimally for example

00:48:30,320 --> 00:48:38,000
deck is a contiguous array of several

00:48:33,950 --> 00:48:39,470
contiguous arrays the way that if you

00:48:38,000 --> 00:48:40,940
don't know the internals of deck you

00:48:39,470 --> 00:48:42,860
just have to send your elements one at a

00:48:40,940 --> 00:48:45,200
time if you do know the internals of

00:48:42,860 --> 00:48:47,780
deck and if the element is contiguously

00:48:45,200 --> 00:48:50,480
hashable you can send an entire chunk of

00:48:47,780 --> 00:48:51,980
elements one at a time so this the

00:48:50,480 --> 00:48:55,520
standard library can really do a better

00:48:51,980 --> 00:48:56,930
job than we can vector bool is another

00:48:55,520 --> 00:49:08,750
problem but vector bulls are always a

00:48:56,930 --> 00:49:11,060
problem so you imagine that will start

00:49:08,750 --> 00:49:13,010
having the idea with the I'm writing my

00:49:11,060 --> 00:49:16,720
class I'll start saying okay well I need

00:49:13,010 --> 00:49:19,070
to have certain things all right such as

00:49:16,720 --> 00:49:20,630
swap is one of those things they may be

00:49:19,070 --> 00:49:22,010
hashed and would be one of those

00:49:20,630 --> 00:49:23,270
standard functions that you write and

00:49:22,010 --> 00:49:25,910
then you have an external function that

00:49:23,270 --> 00:49:28,100
just is maybe norm for your type of

00:49:25,910 --> 00:49:30,760
classes should that be maybe a good

00:49:28,100 --> 00:49:40,460
practice to start adopting so you have

00:49:30,760 --> 00:49:42,620
well if you are excited enough about

00:49:40,460 --> 00:49:44,650
this technique to go here and download

00:49:42,620 --> 00:49:47,810
it and start using it the answer is yes

00:49:44,650 --> 00:49:48,860
if if you're not that excited about it

00:49:47,810 --> 00:49:51,340
you might want to take a wait-and-see

00:49:48,860 --> 00:49:54,110
approach and see what the committee does

00:49:51,340 --> 00:49:56,090
then you know and if the committee

00:49:54,110 --> 00:49:58,250
standardized is that then at that point

00:49:56,090 --> 00:49:59,990
yes hash append will be one of those

00:49:58,250 --> 00:50:01,910
functions that you just need to write

00:49:59,990 --> 00:50:03,969
along with operator equal equal and swap

00:50:01,910 --> 00:50:06,949
and so forth and so on

00:50:03,969 --> 00:50:08,869
yes I have two questions

00:50:06,949 --> 00:50:10,189
um one is because operator equal equal

00:50:08,869 --> 00:50:12,650
and hatch you don't have a mathematical

00:50:10,189 --> 00:50:14,269
relationship give any good strategies

00:50:12,650 --> 00:50:16,609
for keeping those in sync without having

00:50:14,269 --> 00:50:20,170
to do essentially rewrite the same exact

00:50:16,609 --> 00:50:20,170
boilerplate code in every spot

00:50:20,869 --> 00:50:26,509
I thought the what I recommend is always

00:50:23,930 --> 00:50:28,509
use operator equal equal equal for your

00:50:26,509 --> 00:50:30,559
predicate in your unordered containers

00:50:28,509 --> 00:50:33,709
doing anything else

00:50:30,559 --> 00:50:35,719
you're just often a quick sand it gets

00:50:33,709 --> 00:50:38,569
complicated and if you really need to go

00:50:35,719 --> 00:50:43,249
there just go there and don't use hash

00:50:38,569 --> 00:50:45,079
append because it's or you know yeah I

00:50:43,249 --> 00:50:47,799
suppose if you if you really wanted to

00:50:45,079 --> 00:50:50,869
you could sync hash append with some

00:50:47,799 --> 00:50:53,660
weird version of operator equal equal

00:50:50,869 --> 00:50:56,839
but yeah I wouldn't recommend doing that

00:50:53,660 --> 00:50:58,609
I would just write a special has if you

00:50:56,839 --> 00:51:00,829
had to do something besides match with

00:50:58,609 --> 00:51:02,299
sync with operator equal equal I would

00:51:00,829 --> 00:51:06,829
just write a custom hash function and

00:51:02,299 --> 00:51:08,179
use that the other question is so part

00:51:06,829 --> 00:51:11,209
of a good hash function is depending on

00:51:08,179 --> 00:51:13,400
and say how the buckets are allocated in

00:51:11,209 --> 00:51:14,959
an ordered set you know are their prime

00:51:13,400 --> 00:51:17,509
number of buckets or their power of two

00:51:14,959 --> 00:51:19,489
do you envision someday a proposal be

00:51:17,509 --> 00:51:21,469
becoming too you know

00:51:19,489 --> 00:51:23,719
tie those kind of things together you

00:51:21,469 --> 00:51:25,489
pick the standard isn't exposed what

00:51:23,719 --> 00:51:26,239
kind of number of buckets you what kind

00:51:25,489 --> 00:51:29,359
of algorithm

00:51:26,239 --> 00:51:33,349
I don't say yeah do you see some kind of

00:51:29,359 --> 00:51:34,369
hiding advantage of that I I don't see

00:51:33,349 --> 00:51:36,979
that coming

00:51:34,369 --> 00:51:39,949
III don't see a way to take advantage of

00:51:36,979 --> 00:51:41,749
that in the future and I don't see any

00:51:39,949 --> 00:51:43,339
proposal that coming down the pike in

00:51:41,749 --> 00:51:45,769
that department I will say that I am

00:51:43,339 --> 00:51:47,839
biased on one way that the Lib C++

00:51:45,769 --> 00:51:49,999
implementation will switch back and

00:51:47,839 --> 00:51:51,679
forth between whichever you like you

00:51:49,999 --> 00:51:54,109
give it a power of two buckets and it'll

00:51:51,679 --> 00:51:55,459
keep power too as it doubles you give it

00:51:54,109 --> 00:51:57,529
a prime number of buckets and it will

00:51:55,459 --> 00:52:08,179
keep as it doubles it'll find the next

00:51:57,529 --> 00:52:09,890
prime so yes I'm just sorry I'm late I

00:52:08,179 --> 00:52:14,480
tried my best

00:52:09,890 --> 00:52:17,300
what kind of pushback you see the the

00:52:14,480 --> 00:52:19,640
pushback I'm seeing so far is on what I

00:52:17,300 --> 00:52:21,740
call niggling details that that I don't

00:52:19,640 --> 00:52:24,140
Carol out like what is the signature of

00:52:21,740 --> 00:52:26,060
the update operator in a hash function

00:52:24,140 --> 00:52:28,250
that that we need to specialize in

00:52:26,060 --> 00:52:30,860
should it be void pointer or pointer to

00:52:28,250 --> 00:52:33,490
ensign character or whatever I can't get

00:52:30,860 --> 00:52:35,540
really excited about that question but

00:52:33,490 --> 00:52:39,680
but but a lot of people are really

00:52:35,540 --> 00:52:42,740
excited about about that part and other

00:52:39,680 --> 00:52:45,440
push backs are some people don't have as

00:52:42,740 --> 00:52:47,780
good an overview of the entire system as

00:52:45,440 --> 00:52:49,250
you guys hopefully do right now because

00:52:47,780 --> 00:52:51,860
this is the first time I've given this

00:52:49,250 --> 00:53:19,790
presentation and so people keep trying

00:52:51,860 --> 00:53:23,540
to improve it and that's a problem so do

00:53:19,790 --> 00:53:24,950
you think that makes sense perhaps we

00:53:23,540 --> 00:53:27,290
need to do it more than once which means

00:53:24,950 --> 00:53:28,760
you know put things into sorted

00:53:27,290 --> 00:53:32,690
containers when I sort them differently

00:53:28,760 --> 00:53:34,880
sometimes so perhaps you wanted to

00:53:32,690 --> 00:53:42,260
present itself to the hashing algorithm

00:53:34,880 --> 00:53:47,090
differently on different occasions so

00:53:42,260 --> 00:53:48,710
the second question first I guess I I

00:53:47,090 --> 00:53:50,930
have not come up with an application

00:53:48,710 --> 00:53:53,630
where I wanted to change what was

00:53:50,930 --> 00:53:55,700
represented to the to the hash function

00:53:53,630 --> 00:53:58,250
as opposed to changing the hashing

00:53:55,700 --> 00:53:59,540
algorithm I've had plenty of plenty of

00:53:58,250 --> 00:54:02,180
motivation to change my hashing

00:53:59,540 --> 00:54:04,880
algorithms but but not what's presented

00:54:02,180 --> 00:54:07,460
and I I don't know of a good way to

00:54:04,880 --> 00:54:10,880
handle that outside of something gross

00:54:07,460 --> 00:54:12,020
like if death and I'm sorry what could

00:54:10,880 --> 00:54:14,060
you repeat your first question it's

00:54:12,020 --> 00:54:16,660
already blown skipped out of my mind

00:54:14,060 --> 00:54:19,100
automatic house of manpower inflection

00:54:16,660 --> 00:54:21,890
an interesting way to do that might be

00:54:19,100 --> 00:54:23,759
with equal default I don't know whether

00:54:21,890 --> 00:54:25,380
that's technically possible

00:54:23,759 --> 00:54:27,719
it would definitely have to be opt-in

00:54:25,380 --> 00:54:29,880
because not every type wants to present

00:54:27,719 --> 00:54:31,799
everything it has to a hash algorithm

00:54:29,880 --> 00:54:34,319
for example you'd never want to have

00:54:31,799 --> 00:54:37,529
vector present its capacity to a hash

00:54:34,319 --> 00:54:39,029
algorithm so I don't see it as something

00:54:37,529 --> 00:54:41,369
that would be completely automatic it

00:54:39,029 --> 00:54:43,819
would have to be opt in whatever syntax

00:54:41,369 --> 00:54:43,819
is used

00:55:00,919 --> 00:55:11,969
I actually have thought about that and I

00:55:08,329 --> 00:55:13,789
I don't know of a clean way to do it yet

00:55:11,969 --> 00:55:16,589
because you need to do different things

00:55:13,789 --> 00:55:19,709
floating point is my poster child

00:55:16,589 --> 00:55:21,119
example on that for serialization you

00:55:19,709 --> 00:55:23,459
want to keep the difference between

00:55:21,119 --> 00:55:24,779
negative zero and zero and for hashing

00:55:23,459 --> 00:55:26,819
you want to hide the difference between

00:55:24,779 --> 00:55:28,499
negative zero and zero and so I don't

00:55:26,819 --> 00:55:34,409
have a good solution for that very

00:55:28,499 --> 00:55:36,059
problem so in some hashing strategies

00:55:34,409 --> 00:55:37,529
you actually want to like insert the

00:55:36,059 --> 00:55:39,149
Ling's in there as well so that you can

00:55:37,529 --> 00:55:41,999
reduce your alias thing you know like a

00:55:39,149 --> 00:55:43,889
name mangling kind of thing right how

00:55:41,999 --> 00:55:47,039
would that plug in here if you want it

00:55:43,889 --> 00:55:49,169
well in the in the specification I have

00:55:47,039 --> 00:55:50,999
right now if you take vector for example

00:55:49,169 --> 00:55:53,969
the specification is that vector will

00:55:50,999 --> 00:55:56,189
send every element of its in its

00:55:53,969 --> 00:55:57,839
container to hash append and then it

00:55:56,189 --> 00:56:01,279
will also hash append it's linked at the

00:55:57,839 --> 00:56:03,709
end of that and that way you don't

00:56:01,279 --> 00:56:06,719
accidentally get aliasing between

00:56:03,709 --> 00:56:25,649
vectors of vectors which can happen if

00:56:06,719 --> 00:56:28,889
you don't append a length introspection

00:56:25,649 --> 00:56:32,689
solution but there are definite cases be

00:56:28,889 --> 00:56:34,890
different but I think one thing to

00:56:32,689 --> 00:56:36,630
hijack

00:56:34,890 --> 00:56:44,510
realization code that supports all the

00:56:36,630 --> 00:56:44,510
booze containers to add support for okay

00:56:48,260 --> 00:57:08,609
it's a very interesting suggestion thank

00:56:50,579 --> 00:57:12,450
you very much yes there is that's

00:57:08,609 --> 00:57:15,210
actually excellent question the the hash

00:57:12,450 --> 00:57:17,339
function has to be copy assignable and

00:57:15,210 --> 00:57:19,410
copy constructible for very subtle

00:57:17,339 --> 00:57:22,410
reasons and it mainly has to do with

00:57:19,410 --> 00:57:25,680
that that type erasing hash hash append

00:57:22,410 --> 00:57:52,289
adapter that I saw it has to take the

00:57:25,680 --> 00:57:54,089
hash and copy it and send it on and sure

00:57:52,289 --> 00:57:58,890
you could you can you could have the

00:57:54,089 --> 00:58:01,109
seed in the in the hash function struct

00:57:58,890 --> 00:58:03,150
one it could get a new seed a new random

00:58:01,109 --> 00:58:05,490
seed and so you could put one hash

00:58:03,150 --> 00:58:08,069
flunked every R same out same hash

00:58:05,490 --> 00:58:09,509
algorithm another one over here same

00:58:08,069 --> 00:58:15,210
hash algorithm and just have them

00:58:09,509 --> 00:58:19,730
differently seated and Oh in that case

00:58:15,210 --> 00:58:20,930
you could you know just have a global

00:58:19,730 --> 00:58:23,030
that's

00:58:20,930 --> 00:58:29,000
that's what I'm getting at portion of

00:58:23,030 --> 00:58:30,350
the interface yeah yeah the only first

00:58:29,000 --> 00:58:34,360
thing comes to my mind is just making a

00:58:30,350 --> 00:58:34,360
static of your of your hash hash

00:58:43,210 --> 00:59:00,170
function even explicitly sure yes in

00:58:58,370 --> 00:59:01,790
fact that's the the reason that the

00:59:00,170 --> 00:59:05,480
result type was up there so that you can

00:59:01,790 --> 00:59:07,940
customize that for example the sha-256

00:59:05,480 --> 00:59:11,510
doesn't return a size t it returns a

00:59:07,940 --> 00:59:25,060
256-bit animal and so that's the reason

00:59:11,510 --> 00:59:28,070
result type is they're heterogeneous

00:59:25,060 --> 00:59:29,510
look functionality so that I can I can

00:59:28,070 --> 00:59:32,420
do find with the key type that's

00:59:29,510 --> 00:59:35,150
different so long as they're comparable

00:59:32,420 --> 00:59:37,010
but that wasn't added to the unordered

00:59:35,150 --> 00:59:40,370
containers because nobody was sure how

00:59:37,010 --> 00:59:42,500
to how to make sure that the hat that

00:59:40,370 --> 00:59:46,040
the hash function works the same on

00:59:42,500 --> 00:59:48,530
different types this seems like it could

00:59:46,040 --> 00:59:55,910
help with that because it's all about

00:59:48,530 --> 00:59:57,320
sort of delegating to the I that's a

00:59:55,910 --> 00:59:59,150
really interesting question I haven't

00:59:57,320 --> 01:00:02,900
given that a lot of thought but just off

00:59:59,150 --> 01:00:05,000
the cuff here at least it puts the power

01:00:02,900 --> 01:00:07,220
of what gets presented to a hash

01:00:05,000 --> 01:00:09,500
algorithm in your hands and it puts the

01:00:07,220 --> 01:00:12,290
power of what the hash algorithm is into

01:00:09,500 --> 01:00:16,550
your hands and so I can I can easily see

01:00:12,290 --> 01:00:19,210
that if you set your your key up your

01:00:16,550 --> 01:00:22,550
external key up to present the same

01:00:19,210 --> 01:00:25,280
information as your internal key then

01:00:22,550 --> 01:00:27,530
you're golden and then it if it presents

01:00:25,280 --> 01:00:31,940
different information if it presents

01:00:27,530 --> 01:00:34,749
different information then you're not so

01:00:31,940 --> 01:00:36,980
in that sense it certainly sounds doable

01:00:34,749 --> 01:00:39,259
but you know you'd have to be on your

01:00:36,980 --> 01:00:40,940
guard and and make sure that it did

01:00:39,259 --> 01:00:45,650
indeed present the exact same

01:00:40,940 --> 01:00:54,920
information and that yeah and then it

01:00:45,650 --> 01:00:56,329
should just work just as an aside along

01:00:54,920 --> 01:00:58,279
along the same lines I thought I

01:00:56,329 --> 01:01:00,739
actually wrote a hashing algorithm that

01:00:58,279 --> 01:01:02,509
I call debug hash that does nothing but

01:01:00,739 --> 01:01:04,460
collect the bytes and then when you

01:01:02,509 --> 01:01:06,650
convert it to a size T it just prints

01:01:04,460 --> 01:01:09,200
them all out to standard error so that

01:01:06,650 --> 01:01:12,680
in hex format so that you can debug your

01:01:09,200 --> 01:01:15,049
hash append algorithm which would come

01:01:12,680 --> 01:01:20,869
in very handy and doing that that very

01:01:15,049 --> 01:01:23,289
exercise any other questions well thank

01:01:20,869 --> 01:01:23,289

YouTube URL: https://www.youtube.com/watch?v=Njjp_MJsgt8


