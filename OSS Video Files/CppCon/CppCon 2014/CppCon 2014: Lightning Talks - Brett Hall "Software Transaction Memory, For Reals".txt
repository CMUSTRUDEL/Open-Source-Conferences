Title: CppCon 2014: Lightning Talks - Brett Hall "Software Transaction Memory, For Reals"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://cppcon2014.sched.org

Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,490
Brett is next Brett Hall is here to say

00:00:03,540 --> 00:00:07,230
that software transactional memory can

00:00:05,490 --> 00:00:09,780
be more than just a research toy under

00:00:07,230 --> 00:00:11,340
the right conditions red is lead

00:00:09,780 --> 00:00:13,320
developer and dynamics a data collection

00:00:11,340 --> 00:00:15,750
and analysis package were used with

00:00:13,320 --> 00:00:17,340
light scattering instruments so he's

00:00:15,750 --> 00:00:24,060
going to do software transactions every

00:00:17,340 --> 00:00:43,700
four wheels so may get this to work

00:00:24,060 --> 00:00:43,700
again so what's happening

00:00:45,960 --> 00:00:57,690
oh yeah that's pretty yeah I have to

00:00:53,610 --> 00:01:00,090
start slideshow ah there you go okay um

00:00:57,690 --> 00:01:04,769
yeah software transactional memory for

00:01:00,090 --> 00:01:06,690
realz jump right in in some circles

00:01:04,769 --> 00:01:09,630
software transactional memory has been

00:01:06,690 --> 00:01:11,850
accused of just being a research toy if

00:01:09,630 --> 00:01:14,940
you search on Google you'll find this

00:01:11,850 --> 00:01:16,740
paper and you won't find anyone talking

00:01:14,940 --> 00:01:18,960
about using it in actual production

00:01:16,740 --> 00:01:21,869
software except for some folks in the

00:01:18,960 --> 00:01:26,310
Haskell world and they're usually ten

00:01:21,869 --> 00:01:28,710
years ahead of us on everything so but

00:01:26,310 --> 00:01:30,330
at white technology we've been using it

00:01:28,710 --> 00:01:32,789
for the past three years in one of our

00:01:30,330 --> 00:01:35,580
applications as Kate said it's called

00:01:32,789 --> 00:01:41,520
dynamics it's a analysis and data

00:01:35,580 --> 00:01:44,899
collection package and so this may raise

00:01:41,520 --> 00:01:48,390
some questions first off how did it go

00:01:44,899 --> 00:01:50,640
tldr great but why mbv could probably

00:01:48,390 --> 00:01:55,399
leave now but that y MV v has some big

00:01:50,640 --> 00:01:57,450
caveats in it why are or were you insane

00:01:55,399 --> 00:02:03,270
no I'll get into the reasoning behind

00:01:57,450 --> 00:02:05,520
what we did and finally what based on

00:02:03,270 --> 00:02:06,840
the blank stares i get from candidates

00:02:05,520 --> 00:02:08,399
and job interviews when i asked about

00:02:06,840 --> 00:02:12,180
software transexual memory this is

00:02:08,399 --> 00:02:17,130
probably where we should start okay so

00:02:12,180 --> 00:02:20,130
what is it I got okay I got a pointer

00:02:17,130 --> 00:02:21,239
alright so say we've got two variables

00:02:20,130 --> 00:02:23,760
here and be that we want to share

00:02:21,239 --> 00:02:25,140
between threads usually that's a bad

00:02:23,760 --> 00:02:27,420
idea but sometimes we can't get away

00:02:25,140 --> 00:02:28,920
from it so we've got two here's two

00:02:27,420 --> 00:02:31,380
threads here thread one thread to

00:02:28,920 --> 00:02:32,970
somehow on each thread we start a

00:02:31,380 --> 00:02:34,829
transaction this varies from system to

00:02:32,970 --> 00:02:37,079
system you might call a function you

00:02:34,829 --> 00:02:39,980
might create an object or there might be

00:02:37,079 --> 00:02:42,930
some new keyword built into the compiler

00:02:39,980 --> 00:02:44,280
just ignore that detail for now so we

00:02:42,930 --> 00:02:48,030
start some transactions over here in

00:02:44,280 --> 00:02:50,220
thread too we write to a and B at the

00:02:48,030 --> 00:02:54,419
same time we're reading a in transaction

00:02:50,220 --> 00:02:57,540
one on this other thread note that for a

00:02:54,419 --> 00:02:59,550
we get the original value one even

00:02:57,540 --> 00:03:01,920
though we've set the two over here

00:02:59,550 --> 00:03:03,300
none of these rights become available to

00:03:01,920 --> 00:03:04,830
other threads or visible on other

00:03:03,300 --> 00:03:07,530
threads until we reach the end of the

00:03:04,830 --> 00:03:08,970
transaction and commit it for this

00:03:07,530 --> 00:03:11,190
transaction it just commits because we

00:03:08,970 --> 00:03:13,620
haven't done any reads so over here

00:03:11,190 --> 00:03:14,880
we've read a one if we just ignore this

00:03:13,620 --> 00:03:17,340
other stuff for a minute when we get to

00:03:14,880 --> 00:03:18,840
the end of our transaction it's going to

00:03:17,340 --> 00:03:20,700
go back and look at all the reads we did

00:03:18,840 --> 00:03:23,220
and in this case we get scary teeth and

00:03:20,700 --> 00:03:25,350
a conflict because we read a is equal to

00:03:23,220 --> 00:03:26,430
one but now it's equal to two so we have

00:03:25,350 --> 00:03:31,950
to go back to the beginning and start

00:03:26,430 --> 00:03:34,260
over so it's a speculative way of doing

00:03:31,950 --> 00:03:35,670
thread synchronization we're assuming

00:03:34,260 --> 00:03:36,930
there's not going to be any conflicts

00:03:35,670 --> 00:03:37,920
and we can just get through and if we

00:03:36,930 --> 00:03:40,730
don't we have to go back and do

00:03:37,920 --> 00:03:42,960
everything over again so now there's

00:03:40,730 --> 00:03:45,060
some details we need to go into a little

00:03:42,960 --> 00:03:46,950
bit in our system if you read a again

00:03:45,060 --> 00:03:48,210
after this commit you're going to get

00:03:46,950 --> 00:03:49,800
the same value you got the first time

00:03:48,210 --> 00:03:54,090
you always see consistent results within

00:03:49,800 --> 00:03:55,230
a transaction and but when we read B we

00:03:54,090 --> 00:03:56,940
get the value that was written in this

00:03:55,230 --> 00:03:58,350
transaction because we didn't write it

00:03:56,940 --> 00:04:01,020
or we didn't read it before the

00:03:58,350 --> 00:04:03,090
transaction committed and normally

00:04:01,020 --> 00:04:04,770
that's fine we get a conflict we go back

00:04:03,090 --> 00:04:07,500
and then we'll get consistent results

00:04:04,770 --> 00:04:09,690
the next time also if we write to a

00:04:07,500 --> 00:04:11,520
variable in a transaction and then we

00:04:09,690 --> 00:04:14,010
read from it we get the value we read we

00:04:11,520 --> 00:04:16,830
wrote routes you know things would seem

00:04:14,010 --> 00:04:21,959
crazy other systems this reader be might

00:04:16,830 --> 00:04:24,690
have given us to some systems some

00:04:21,959 --> 00:04:28,080
systems enforce consistency through the

00:04:24,690 --> 00:04:30,600
whole thing some systems there is no

00:04:28,080 --> 00:04:33,510
consistency it's up to you to not read

00:04:30,600 --> 00:04:35,490
the variable multiple times and then

00:04:33,510 --> 00:04:36,660
some jargon for those who know what's

00:04:35,490 --> 00:04:38,820
going on I don't really have time to get

00:04:36,660 --> 00:04:41,940
into all this but our system is

00:04:38,820 --> 00:04:43,230
unbounded explicit weekly atomic those

00:04:41,940 --> 00:04:44,550
two because I don't know how without

00:04:43,230 --> 00:04:47,100
modifying the compiler you do anything

00:04:44,550 --> 00:04:49,260
different and it's in directed there's

00:04:47,100 --> 00:04:51,720
some in Direction going on under the

00:04:49,260 --> 00:04:53,280
covers we're not updating things in

00:04:51,720 --> 00:04:56,820
place which can have performance

00:04:53,280 --> 00:05:00,030
implications so why would you use

00:04:56,820 --> 00:05:03,120
software transactional memory for

00:05:00,030 --> 00:05:05,130
composability so here we've got kind of

00:05:03,120 --> 00:05:07,950
a comparison when you're programming

00:05:05,130 --> 00:05:10,020
with locks we've got function a we call

00:05:07,950 --> 00:05:11,789
it we take a lock and we call function B

00:05:10,020 --> 00:05:12,860
this is really dangerous to do unless

00:05:11,789 --> 00:05:14,840
you know what bead

00:05:12,860 --> 00:05:17,180
is and what everything that be calls

00:05:14,840 --> 00:05:18,740
does because if they take a lock you've

00:05:17,180 --> 00:05:19,909
got locks you don't know the ordering

00:05:18,740 --> 00:05:22,099
that you're taking locks in you've got

00:05:19,909 --> 00:05:25,789
potential deadlock makes a program with

00:05:22,099 --> 00:05:27,199
locks in the large really painful for

00:05:25,789 --> 00:05:28,310
small sections of code it works fine but

00:05:27,199 --> 00:05:31,099
when you're talking about the whole

00:05:28,310 --> 00:05:35,030
program it's a real pain on the other

00:05:31,099 --> 00:05:37,009
hand with a pointer go well with softer

00:05:35,030 --> 00:05:38,990
transactional memory we call function a

00:05:37,009 --> 00:05:40,639
we start let's say we're working with a

00:05:38,990 --> 00:05:42,349
system where we just have a keyword

00:05:40,639 --> 00:05:44,210
atomically which starts a transaction

00:05:42,349 --> 00:05:46,279
and then we call Trevor we call function

00:05:44,210 --> 00:05:48,740
B it doesn't matter what B does there's

00:05:46,279 --> 00:05:50,120
no way we can deadlock it could start

00:05:48,740 --> 00:05:52,009
its own transaction as long as your

00:05:50,120 --> 00:05:55,129
system supports nested transactions

00:05:52,009 --> 00:05:57,620
you're okay all the threads can make

00:05:55,129 --> 00:06:00,340
progress there's no way to deadlock with

00:05:57,620 --> 00:06:03,409
this this much structure in our system

00:06:00,340 --> 00:06:05,870
why did we use STM is probably a more

00:06:03,409 --> 00:06:08,120
important question this is a picture of

00:06:05,870 --> 00:06:09,590
what our program looked like a couple of

00:06:08,120 --> 00:06:11,569
years after I started working at Wyatt

00:06:09,590 --> 00:06:12,949
and this was probably about well I

00:06:11,569 --> 00:06:15,740
started about eight years ago so about

00:06:12,949 --> 00:06:17,419
six years ago it was an old program it

00:06:15,740 --> 00:06:19,960
was collapsing under the weight of the

00:06:17,419 --> 00:06:22,069
data we were asking asking it to handle

00:06:19,960 --> 00:06:23,719
originally when the program was written

00:06:22,069 --> 00:06:26,150
the instruments weren't very well

00:06:23,719 --> 00:06:27,379
automated so it you know you had to pay

00:06:26,150 --> 00:06:29,810
someone to gather the data is you

00:06:27,379 --> 00:06:32,770
couldn't gather very much data and their

00:06:29,810 --> 00:06:35,509
thread safety the pattern they used for

00:06:32,770 --> 00:06:38,750
to do thread safety was basically do

00:06:35,509 --> 00:06:40,159
everything in the gooey thread which of

00:06:38,750 --> 00:06:42,379
course means when it's doing

00:06:40,159 --> 00:06:43,610
calculations the calculations touched

00:06:42,379 --> 00:06:45,529
the data they have to be in the gooey

00:06:43,610 --> 00:06:47,900
thread the GUI either locks up or

00:06:45,529 --> 00:06:49,639
stutters like crazy if it was just

00:06:47,900 --> 00:06:51,259
embarrassing to talk to customers that

00:06:49,639 --> 00:06:52,580
had to go through that somehow they

00:06:51,259 --> 00:06:56,569
didn't really care that much they wanted

00:06:52,580 --> 00:06:59,930
other features first of course but and

00:06:56,569 --> 00:07:01,250
when I say it would lock up like some of

00:06:59,930 --> 00:07:02,150
these data files especially when you can

00:07:01,250 --> 00:07:04,430
only use one thread to do the

00:07:02,150 --> 00:07:07,539
calculations we're talking 5 10 15

00:07:04,430 --> 00:07:10,279
minutes to do these calculations so a

00:07:07,539 --> 00:07:13,009
rite of passage for new dynamics users

00:07:10,279 --> 00:07:15,169
was they would start up load a big file

00:07:13,009 --> 00:07:17,360
it would freeze they would report a bug

00:07:15,169 --> 00:07:18,979
that hey the program hang hung and we'd

00:07:17,360 --> 00:07:24,349
say no it's not hung it's just thinking

00:07:18,979 --> 00:07:24,849
just wait it'll come back so I tried for

00:07:24,349 --> 00:07:27,490
a cup

00:07:24,849 --> 00:07:29,319
years to fix this just by putting in

00:07:27,490 --> 00:07:31,809
locks moving things to the background

00:07:29,319 --> 00:07:33,729
threads but some of the stuff I could

00:07:31,809 --> 00:07:35,229
fix some of it I have interests reached

00:07:33,729 --> 00:07:37,629
a point where there was just cascading

00:07:35,229 --> 00:07:38,949
failures and we were effectively going

00:07:37,629 --> 00:07:41,229
to be rewriting the whole thing anyway

00:07:38,949 --> 00:07:42,969
at the same time we needed new features

00:07:41,229 --> 00:07:45,669
to you know have parity with our

00:07:42,969 --> 00:07:47,949
competitors so for about three years we

00:07:45,669 --> 00:07:49,929
had to live with this in those three

00:07:47,949 --> 00:07:52,599
years I was playing with Haskell bad

00:07:49,929 --> 00:07:55,089
idea the bad company to keep um they

00:07:52,599 --> 00:07:56,110
give you bad ideas and I really love

00:07:55,089 --> 00:07:59,199
their software transactional memory

00:07:56,110 --> 00:08:00,909
system and I was also working on you

00:07:59,199 --> 00:08:03,219
know I was working with this system for

00:08:00,909 --> 00:08:06,009
three years that just our system which

00:08:03,219 --> 00:08:07,990
was not very good and dreaming about how

00:08:06,009 --> 00:08:09,519
I was going to fix this and every time I

00:08:07,990 --> 00:08:11,169
was doing design work like okay I can

00:08:09,519 --> 00:08:13,990
fix it like this software transactional

00:08:11,169 --> 00:08:15,729
memory was just a perfect fit I also for

00:08:13,990 --> 00:08:18,819
kicks wrote my own softer zhengzhou

00:08:15,729 --> 00:08:20,949
memory system in C++ it's not a

00:08:18,819 --> 00:08:23,529
particularly great one but we did some

00:08:20,949 --> 00:08:24,969
proof of concept work with it and found

00:08:23,529 --> 00:08:27,849
that it was fast enough for our purposes

00:08:24,969 --> 00:08:31,419
and I'll get into what that means in a

00:08:27,849 --> 00:08:33,069
bit so all everything pointed at STM

00:08:31,419 --> 00:08:36,370
being a good fit so we decided to go for

00:08:33,069 --> 00:08:38,500
it so how did it go great but your

00:08:36,370 --> 00:08:40,899
mileage may vary and by that i mean i

00:08:38,500 --> 00:08:42,669
think our application is sort of in a

00:08:40,899 --> 00:08:46,079
sweet spot for the use of software

00:08:42,669 --> 00:08:48,970
transactional memory and why is that

00:08:46,079 --> 00:08:51,279
first off our data has an embarrassingly

00:08:48,970 --> 00:08:52,660
parallel structure we have when you're

00:08:51,279 --> 00:08:54,279
collecting the data you're collecting

00:08:52,660 --> 00:08:56,110
measurements but you get these

00:08:54,279 --> 00:08:58,089
acquisition things whichever the real

00:08:56,110 --> 00:09:00,790
data is and when we're doing the

00:08:58,089 --> 00:09:02,319
calculations all these acquisitions have

00:09:00,790 --> 00:09:03,370
a bunch of isolated calculations that

00:09:02,319 --> 00:09:04,449
are independent of each other the

00:09:03,370 --> 00:09:06,430
measurements are independent of each

00:09:04,449 --> 00:09:11,589
other it's really easy to fan all this

00:09:06,430 --> 00:09:13,990
out on two different processors which

00:09:11,589 --> 00:09:16,269
means our performance are our thread

00:09:13,990 --> 00:09:18,009
synchronization isn't we aren't doing a

00:09:16,269 --> 00:09:19,389
lot of tight threats or tight

00:09:18,009 --> 00:09:21,870
synchronization between different

00:09:19,389 --> 00:09:26,040
threads doing these calculations

00:09:21,870 --> 00:09:27,880
furthermore our actual calculations are

00:09:26,040 --> 00:09:29,620
basically of a form we read some

00:09:27,880 --> 00:09:31,240
parameters we read the data these are

00:09:29,620 --> 00:09:34,139
done transactionally and then we put

00:09:31,240 --> 00:09:36,309
them through a numerical meat grinder

00:09:34,139 --> 00:09:37,970
spits out some results that we then

00:09:36,309 --> 00:09:39,410
right into

00:09:37,970 --> 00:09:41,899
some transactional variables so all this

00:09:39,410 --> 00:09:43,189
is done in one big transaction but only

00:09:41,899 --> 00:09:46,870
at the very beginning at the very end

00:09:43,189 --> 00:09:51,379
are we doing just a few transactional

00:09:46,870 --> 00:09:52,939
operations and these calculations the

00:09:51,379 --> 00:09:55,699
the amount of time we spend doing these

00:09:52,939 --> 00:09:58,670
completely Dwarfs any overhead from the

00:09:55,699 --> 00:10:00,769
transactional system plus we're not

00:09:58,670 --> 00:10:03,290
trying to hit 60 frames per second beat

00:10:00,769 --> 00:10:06,439
other BOTS to market or you know we

00:10:03,290 --> 00:10:09,680
don't have hard real-time constraints at

00:10:06,439 --> 00:10:10,819
least in this part of the code so you

00:10:09,680 --> 00:10:12,110
know if the researchers have to wait a

00:10:10,819 --> 00:10:13,189
few more seconds for the results they

00:10:12,110 --> 00:10:15,670
aren't going to care they're not going

00:10:13,189 --> 00:10:21,529
to notice mostly it's keeping things

00:10:15,670 --> 00:10:23,240
responsive so the part that went great

00:10:21,529 --> 00:10:25,129
has an easy learning curve we've had a

00:10:23,240 --> 00:10:26,360
few people come on board since we

00:10:25,129 --> 00:10:27,980
started using this they come up to speed

00:10:26,360 --> 00:10:30,230
fast and make some mistakes at first you

00:10:27,980 --> 00:10:32,029
catchment code review after a month or

00:10:30,230 --> 00:10:33,170
two they're working with a great even

00:10:32,029 --> 00:10:35,060
though they've never seen it before and

00:10:33,170 --> 00:10:37,490
it's just much easier to reason about

00:10:35,060 --> 00:10:42,079
the code especially compared to locks

00:10:37,490 --> 00:10:44,569
let alone lock free programming it's not

00:10:42,079 --> 00:10:45,680
all roses though there are problems this

00:10:44,569 --> 00:10:48,110
was something I was really concerned

00:10:45,680 --> 00:10:49,279
about at the beginning ended up not

00:10:48,110 --> 00:10:50,809
being a big issue but you can have

00:10:49,279 --> 00:10:52,939
what's called starvation or live lock

00:10:50,809 --> 00:10:54,920
where you have a long-running

00:10:52,939 --> 00:10:56,540
transaction another thread keeps writing

00:10:54,920 --> 00:10:57,829
to a variable that that one reads that

00:10:56,540 --> 00:10:59,209
long running transaction just gets

00:10:57,829 --> 00:11:01,220
conflict after conflict and can never

00:10:59,209 --> 00:11:05,480
finish in our system you can actually

00:11:01,220 --> 00:11:07,129
set openings you can actually set the

00:11:05,480 --> 00:11:09,379
number of the maximum number of

00:11:07,129 --> 00:11:11,839
conflicts a thread can rub transaction

00:11:09,379 --> 00:11:13,569
can have if you hit that it takes a lock

00:11:11,839 --> 00:11:16,009
that prevents anyone else from

00:11:13,569 --> 00:11:18,860
committing until your transaction does

00:11:16,009 --> 00:11:20,660
its heavy-handed it seems to work okay

00:11:18,860 --> 00:11:22,610
we don't really I don't even think it

00:11:20,660 --> 00:11:24,889
actually fires ever I need to go back

00:11:22,610 --> 00:11:27,529
and check that but it hasn't been an

00:11:24,889 --> 00:11:29,180
issue there's more elegant ways to

00:11:27,529 --> 00:11:32,329
handle it but we haven't needed that yet

00:11:29,180 --> 00:11:33,379
a bigger problem is you have to be

00:11:32,329 --> 00:11:35,720
careful about where you do your side

00:11:33,379 --> 00:11:37,189
effects in this one we're so in this

00:11:35,720 --> 00:11:39,529
example we read a variable and then we

00:11:37,189 --> 00:11:42,199
display a dialog we have a conflict it

00:11:39,529 --> 00:11:44,240
goes back repeats and you can have a bug

00:11:42,199 --> 00:11:45,949
where a dialog will display one time

00:11:44,240 --> 00:11:48,559
like it's supposed to or fifty or

00:11:45,949 --> 00:11:50,569
hundred times the proper way to do that

00:11:48,559 --> 00:11:51,290
we actually have a way to schedule side

00:11:50,569 --> 00:11:52,699
effects

00:11:51,290 --> 00:11:54,230
call a function called after give it a

00:11:52,699 --> 00:11:56,269
function object and when your

00:11:54,230 --> 00:11:59,480
transaction commits the side-effect gets

00:11:56,269 --> 00:12:01,339
run then generally this is pre it's

00:11:59,480 --> 00:12:04,519
pretty obvious when it happens sometimes

00:12:01,339 --> 00:12:07,040
so that's subtle but even when it is

00:12:04,519 --> 00:12:10,149
subtle it's not any it's easier than

00:12:07,040 --> 00:12:13,220
debugging a deadlock or race condition

00:12:10,149 --> 00:12:15,470
so another problem inconsistent reads so

00:12:13,220 --> 00:12:18,019
before when we were talking about back

00:12:15,470 --> 00:12:20,449
at the beginning we have a transaction

00:12:18,019 --> 00:12:23,959
that writes a and B we read a we read B

00:12:20,449 --> 00:12:25,399
we get the read of a happens before we

00:12:23,959 --> 00:12:27,470
commit our transaction so we get the old

00:12:25,399 --> 00:12:29,899
value the reader be happens after the

00:12:27,470 --> 00:12:32,149
transit that transaction commits so we

00:12:29,899 --> 00:12:33,620
get the new value we do stuff with a and

00:12:32,149 --> 00:12:35,920
B normally that's not a problem we get

00:12:33,620 --> 00:12:38,600
the conflict we go back we start over

00:12:35,920 --> 00:12:39,709
everything is consistent everyone smile

00:12:38,600 --> 00:12:41,600
is something weird will happen like

00:12:39,709 --> 00:12:43,339
because an be are inconsistent with each

00:12:41,600 --> 00:12:45,170
other you'll try and allocate I don't

00:12:43,339 --> 00:12:48,410
know 500 gigabytes of memory or

00:12:45,170 --> 00:12:53,209
something and everything crashes that's

00:12:48,410 --> 00:12:55,370
only happened a couple of times it is a

00:12:53,209 --> 00:12:58,339
possibility once you've seen it once you

00:12:55,370 --> 00:13:00,260
learn to recognize it right away in our

00:12:58,339 --> 00:13:01,910
case the way to fix that we have a way

00:13:00,260 --> 00:13:03,500
you can call a function validate which

00:13:01,910 --> 00:13:06,079
validates your transaction at any point

00:13:03,500 --> 00:13:07,430
and if it's invalid you get the conflict

00:13:06,079 --> 00:13:10,100
right away and go back so we after the

00:13:07,430 --> 00:13:13,430
Rita be we would do a validation and

00:13:10,100 --> 00:13:16,760
everything would be good ok so before I

00:13:13,430 --> 00:13:17,810
mention our system is weakly atomic most

00:13:16,760 --> 00:13:19,339
people don't know what that means that

00:13:17,810 --> 00:13:20,600
basically that means when we pull

00:13:19,339 --> 00:13:22,370
something out of one of our

00:13:20,600 --> 00:13:23,600
transactional variables if that has

00:13:22,370 --> 00:13:25,370
mutable state we can just use that

00:13:23,600 --> 00:13:27,860
mutable state wherever if you do that

00:13:25,370 --> 00:13:29,209
it's a race condition a strongly atomic

00:13:27,860 --> 00:13:31,149
system wouldn't allow you to use that

00:13:29,209 --> 00:13:34,310
mutable state outside of a transaction

00:13:31,149 --> 00:13:35,959
to combat that we require either that

00:13:34,310 --> 00:13:38,029
the stuff you store in a transactional

00:13:35,959 --> 00:13:39,560
variable is immutable or it's what I

00:13:38,029 --> 00:13:40,910
call internally transacted which means

00:13:39,560 --> 00:13:44,779
all of its mutable state is also a

00:13:40,910 --> 00:13:46,490
transactional variables and or some

00:13:44,779 --> 00:13:48,439
combination of that this is one example

00:13:46,490 --> 00:13:52,069
if Chandler Carruth was here he'd be

00:13:48,439 --> 00:13:53,750
rolling taking his head and disapproval

00:13:52,069 --> 00:13:56,839
because there's links in here it's a

00:13:53,750 --> 00:13:58,279
tree but we basically use immutable

00:13:56,839 --> 00:13:59,630
links in the tree and then the stuff

00:13:58,279 --> 00:14:02,089
that's stored in the tree is internally

00:13:59,630 --> 00:14:03,500
transacted this allows us you get the

00:14:02,089 --> 00:14:05,000
head head node of the tree and you can

00:14:03,500 --> 00:14:06,680
walk the tree all you want in

00:14:05,000 --> 00:14:08,150
outside of a transaction it's not going

00:14:06,680 --> 00:14:09,590
to change but then when you want to use

00:14:08,150 --> 00:14:11,840
something that's stored in the tree you

00:14:09,590 --> 00:14:16,130
have to start a new transaction and it

00:14:11,840 --> 00:14:17,930
keeps everything thread safe okay so

00:14:16,130 --> 00:14:19,700
icing on the cake is this thing called

00:14:17,930 --> 00:14:23,030
retry which is something I stole from

00:14:19,700 --> 00:14:25,490
high school system say read some

00:14:23,030 --> 00:14:28,640
variables and then you you check some

00:14:25,490 --> 00:14:30,080
condition on those variables and things

00:14:28,640 --> 00:14:31,880
aren't right for you to proceed you call

00:14:30,080 --> 00:14:33,920
this function retry it puts your thread

00:14:31,880 --> 00:14:35,510
to sleep when one of those variables

00:14:33,920 --> 00:14:37,340
changes you get woken back up and your

00:14:35,510 --> 00:14:39,110
transaction starts over it's basically a

00:14:37,340 --> 00:14:42,380
replacement for condition variables and

00:14:39,110 --> 00:14:44,600
it works it's really flexible and it

00:14:42,380 --> 00:14:47,060
works great the one thing I mentioned a

00:14:44,600 --> 00:14:48,740
caveat earlier that there's no deadlocks

00:14:47,060 --> 00:14:50,780
with the structure I'd shown you so far

00:14:48,740 --> 00:14:52,760
once you add retry you do any sort of

00:14:50,780 --> 00:14:55,160
waiting in a transaction you can get I

00:14:52,760 --> 00:14:56,690
just learned this recently you can get a

00:14:55,160 --> 00:14:58,130
form of deadlock not because we ran into

00:14:56,690 --> 00:15:00,290
it because someone pointed at a research

00:14:58,130 --> 00:15:02,360
paper to me you can get a form of

00:15:00,290 --> 00:15:04,490
deadlock that would be akin to say

00:15:02,360 --> 00:15:07,370
having some interlocking condition

00:15:04,490 --> 00:15:09,890
variables it hasn't finished yet I'm

00:15:07,370 --> 00:15:12,620
still exploring all the implications of

00:15:09,890 --> 00:15:14,450
this but like i said it hasn't been as

00:15:12,620 --> 00:15:16,070
yet i don't understand why i think it's

00:15:14,450 --> 00:15:18,920
just that you have to write pathological

00:15:16,070 --> 00:15:20,660
code to get that to happen so the

00:15:18,920 --> 00:15:22,940
stereotypical response to your testers

00:15:20,660 --> 00:15:25,400
is it works fine on my machine in this

00:15:22,940 --> 00:15:27,589
case replace machine with application it

00:15:25,400 --> 00:15:29,930
works great fine for our application but

00:15:27,589 --> 00:15:33,560
as I said we don't have the same strong

00:15:29,930 --> 00:15:35,930
deterministic performance requirements

00:15:33,560 --> 00:15:37,640
that some other systems have and in the

00:15:35,930 --> 00:15:39,140
well there's one place where we do which

00:15:37,640 --> 00:15:40,310
is where we're getting the data from the

00:15:39,140 --> 00:15:41,690
instruments and we don't use the

00:15:40,310 --> 00:15:43,460
software transactional memory system

00:15:41,690 --> 00:15:45,440
there that's at a lower level and then

00:15:43,460 --> 00:15:49,460
it comes into the system at a higher

00:15:45,440 --> 00:15:51,680
level did we really need it probably not

00:15:49,460 --> 00:15:52,970
we could have gotten away with locks but

00:15:51,680 --> 00:15:54,710
it's made our life immeasurably

00:15:52,970 --> 00:15:57,640
immeasurably easier and we're small

00:15:54,710 --> 00:16:00,560
teams so we need all the help we can get

00:15:57,640 --> 00:16:02,660
which brings me i guess the at the

00:16:00,560 --> 00:16:04,580
bottom of that we're hiring if this STM

00:16:02,660 --> 00:16:06,950
system sounds fun like interesting to

00:16:04,580 --> 00:16:09,110
work with but also there's more details

00:16:06,950 --> 00:16:11,330
my blog backwards and compatibilities

00:16:09,110 --> 00:16:13,490
wordpress com i started writing about

00:16:11,330 --> 00:16:15,200
this but the glacial pace i update that

00:16:13,490 --> 00:16:16,820
thing at it'll probably be a year or two

00:16:15,200 --> 00:16:18,060
before i get through everything I have

00:16:16,820 --> 00:16:19,680
to say about it

00:16:18,060 --> 00:16:20,790
there's also give me an open content

00:16:19,680 --> 00:16:24,660
session thursday at eight thirty

00:16:20,790 --> 00:16:26,550
somewhere in the matin Bauer Center so

00:16:24,660 --> 00:16:28,700
if you have questions or you just want

00:16:26,550 --> 00:16:33,830
to tell me why I what I did was insane

00:16:28,700 --> 00:16:33,830

YouTube URL: https://www.youtube.com/watch?v=plQOu_LsKHE


