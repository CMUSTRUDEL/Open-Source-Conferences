Title: CppCon 2014: Nicolas Fleury "C++ in Huge AAA Games"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Video games like Assassin's Creed or Rainbow Six are among the biggest code bases with a single static linking. Iteration-time is critical to develop a great game and keeping a complete compilation-time of a few minutes is a constant challenge. This talk will explain the C++ usage reality at Ubisoft Montreal for huge projects. Ideas will be shared regarding performance, debugging and iteration time.
--
Nicolas Fleury has been in video game industry for over 10 years, working as a Technical Architect on projects like Prince of Persia and currently on Rainbow Six: Siege. Before working in the game industry, he worked in computer assisted surgery, speech recognition and telecoms.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:04,940 --> 00:00:11,389
hi everyone my name is Nicolas Karim a

00:00:09,000 --> 00:00:13,469
Technical Architect at Ubisoft Montreal

00:00:11,389 --> 00:00:17,699
it's an honor to be with you today

00:00:13,469 --> 00:00:20,789
um Ubisoft Montreal is known for its

00:00:17,699 --> 00:00:24,510
huge triple a game open-world games like

00:00:20,789 --> 00:00:26,340
Assassin's Creed watchdogs Far Cry port

00:00:24,510 --> 00:00:29,789
and games like Rainbow six printer cell

00:00:26,340 --> 00:00:35,190
and subversion I've been at Ubisoft

00:00:29,789 --> 00:00:37,920
Montreal for eight years now 11 years on

00:00:35,190 --> 00:00:41,760
the game industry before was working in

00:00:37,920 --> 00:00:43,440
other industries but still in C++ but

00:00:41,760 --> 00:00:46,559
coming in the became insular change the

00:00:43,440 --> 00:00:48,710
way I see C++ and I want to share part

00:00:46,559 --> 00:00:52,649
of that experience with you today

00:00:48,710 --> 00:00:54,809
um this is a talk where I will cover a

00:00:52,649 --> 00:00:57,750
bunch of different things ABI will

00:00:54,809 --> 00:01:03,239
repeat a few points from the Mike Mike

00:00:57,750 --> 00:01:04,860
Acton talked earlier but my way the

00:01:03,239 --> 00:01:08,610
person will discuss the situation at

00:01:04,860 --> 00:01:10,920
Ubisoft Montreal then I will talk about

00:01:08,610 --> 00:01:13,979
what we do to improve completion time in

00:01:10,920 --> 00:01:16,009
iteration time and C++ then I will

00:01:13,979 --> 00:01:18,030
discuss a few performance issues and

00:01:16,009 --> 00:01:20,700
finally we will conclude with some

00:01:18,030 --> 00:01:22,439
debugging tricks and tips and please

00:01:20,700 --> 00:01:23,390
keep your questions for the end of the

00:01:22,439 --> 00:01:26,759
talk

00:01:23,390 --> 00:01:29,070
so first is situation Ubisoft Montreal

00:01:26,759 --> 00:01:31,680
it is as far as I know the biggest video

00:01:29,070 --> 00:01:35,689
game studio in the world slowly reaching

00:01:31,680 --> 00:01:38,729
3,000 employees and working on big games

00:01:35,689 --> 00:01:41,070
up to a thousand employees worldwide at

00:01:38,729 --> 00:01:45,960
the end of a project with up to 400 in

00:01:41,070 --> 00:01:49,590
Montreal and the technology mainly in

00:01:45,960 --> 00:01:52,230
Montreal as 300 developers approximately

00:01:49,590 --> 00:01:54,030
and its

00:01:52,230 --> 00:01:55,410
much windows centric development

00:01:54,030 --> 00:01:57,030
environment then if we're doing

00:01:55,410 --> 00:01:59,460
multi-platform development

00:01:57,030 --> 00:02:01,500
enjoy game console they come with visual

00:01:59,460 --> 00:02:02,700
studio integration maybe a few points in

00:02:01,500 --> 00:02:06,300
the fluid slides might be window

00:02:02,700 --> 00:02:08,820
specific but not much and working on big

00:02:06,300 --> 00:02:11,480
games big codebase biggest one Sassin

00:02:08,820 --> 00:02:14,910
screed unity should be released soon I

00:02:11,480 --> 00:02:16,980
could count over 6 million c-sharp a C++

00:02:14,910 --> 00:02:18,480
lines of code and the code base made by

00:02:16,980 --> 00:02:22,910
different sass and three teams over the

00:02:18,480 --> 00:02:25,920
years that isn't the code base actually

00:02:22,910 --> 00:02:27,930
9 million more C++ size would go that

00:02:25,920 --> 00:02:30,180
are from insider projects they can be

00:02:27,930 --> 00:02:33,150
technology group code that can be code

00:02:30,180 --> 00:02:34,890
from external partners and I could count

00:02:33,150 --> 00:02:38,040
five million c-sharp lines of code as

00:02:34,890 --> 00:02:39,840
well if you look at Rainbow six siege a

00:02:38,040 --> 00:02:41,820
game I am working on if I count only the

00:02:39,840 --> 00:02:44,250
code that we are compiling and linking

00:02:41,820 --> 00:02:47,130
together in the same executable I can

00:02:44,250 --> 00:02:50,930
count in half million C++ lines of code

00:02:47,130 --> 00:02:54,860
made by the rainbow 16 in 4.5 million

00:02:50,930 --> 00:02:57,240
C++ line of code from the technology and

00:02:54,860 --> 00:02:58,440
even the technology group code typically

00:02:57,240 --> 00:03:00,690
we compile it on developer machine

00:02:58,440 --> 00:03:03,930
because we want to be able to tweak that

00:03:00,690 --> 00:03:06,840
code and debug it and I think overall we

00:03:03,930 --> 00:03:09,390
still manage to have a good compilation

00:03:06,840 --> 00:03:11,400
time compiling and linking all that

00:03:09,390 --> 00:03:13,709
together it takes three minutes five

00:03:11,400 --> 00:03:18,600
minutes depending on the target I will

00:03:13,709 --> 00:03:21,660
discuss more about that soon the code

00:03:18,600 --> 00:03:22,890
structure the engine the game itself I

00:03:21,660 --> 00:03:24,840
will describe it as an inverted pyramid

00:03:22,890 --> 00:03:28,230
we have multiple layers and they

00:03:24,840 --> 00:03:30,600
introduce new external libraries at the

00:03:28,230 --> 00:03:32,970
bottom we have the core of the engine so

00:03:30,600 --> 00:03:34,850
mathematics object model it will simple

00:03:32,970 --> 00:03:37,620
stuff that is used across all the errors

00:03:34,850 --> 00:03:40,050
then we have a graphic layer which was

00:03:37,620 --> 00:03:43,200
possible rendering where performance is

00:03:40,050 --> 00:03:45,390
extremely important and then over that

00:03:43,200 --> 00:03:49,160
what why we call the engine engine

00:03:45,390 --> 00:03:51,750
services or physics sound animation

00:03:49,160 --> 00:03:53,760
services are that are used then by the

00:03:51,750 --> 00:03:55,500
last a year the game player which

00:03:53,760 --> 00:03:58,980
contains code that is specific the

00:03:55,500 --> 00:04:00,390
gameplay beginning and we have singer

00:03:58,980 --> 00:04:02,280
programmers working in all of these

00:04:00,390 --> 00:04:03,640
layers but junior programmers they tend

00:04:02,280 --> 00:04:05,680
to often end up

00:04:03,640 --> 00:04:08,290
in the gameplay here it's really

00:04:05,680 --> 00:04:10,840
important for people working on lower

00:04:08,290 --> 00:04:12,850
layers to provide an API that is as less

00:04:10,840 --> 00:04:15,580
error-prone as possible the irony here

00:04:12,850 --> 00:04:17,739
and not only not every problem when it

00:04:15,580 --> 00:04:20,200
comes to stability but also when it

00:04:17,739 --> 00:04:22,210
comes to performance and sometimes you

00:04:20,200 --> 00:04:25,090
have to choose between the two minimum I

00:04:22,210 --> 00:04:26,680
choose performance container might take

00:04:25,090 --> 00:04:28,630
the most performant approach by default

00:04:26,680 --> 00:04:32,200
but if you want something else you need

00:04:28,630 --> 00:04:34,260
to specify it explicitly and we don't

00:04:32,200 --> 00:04:36,370
consider C++ to be the most productive

00:04:34,260 --> 00:04:38,710
language in the world we use it because

00:04:36,370 --> 00:04:39,070
we want performance when we don't care

00:04:38,710 --> 00:04:41,800
about it

00:04:39,070 --> 00:04:44,169
we tend to and said you'd see sharp sole

00:04:41,800 --> 00:04:46,180
editor that is used to make the content

00:04:44,169 --> 00:04:48,010
that the game is made in c-sharp and it

00:04:46,180 --> 00:04:51,010
is embedding windows that are from the

00:04:48,010 --> 00:04:54,370
engine in C++ and it is communicating to

00:04:51,010 --> 00:04:56,740
with the other process I chew with two

00:04:54,370 --> 00:04:58,390
tcp/ip and of course when we need

00:04:56,740 --> 00:05:01,540
performance sometimes we need great code

00:04:58,390 --> 00:05:08,950
I'm a shark to the engine side in C++

00:05:01,540 --> 00:05:10,690
that stuff we don't use from C++ we

00:05:08,950 --> 00:05:13,780
don't use on time type information we

00:05:10,690 --> 00:05:15,790
have an own reflection system on object

00:05:13,780 --> 00:05:17,740
model we even ship the game with our

00:05:15,790 --> 00:05:20,260
reflection system so we have data driven

00:05:17,740 --> 00:05:23,080
systems like epic systems that can edit

00:05:20,260 --> 00:05:25,630
properties of objects too complex for

00:05:23,080 --> 00:05:28,690
bridge paths and you want to control the

00:05:25,630 --> 00:05:31,360
exact memory overhead of this system we

00:05:28,690 --> 00:05:33,190
don't want to ship with the game a game

00:05:31,360 --> 00:05:34,600
with class names or property names that

00:05:33,190 --> 00:05:38,590
would be a waste of memory and that will

00:05:34,600 --> 00:05:41,080
help actors uselessly we don't use

00:05:38,590 --> 00:05:43,570
exception and link in the pass it add a

00:05:41,080 --> 00:05:44,440
runtime class on some platforms as I

00:05:43,570 --> 00:05:47,380
have 10%

00:05:44,440 --> 00:05:50,020
that was clearly a no-go but even today

00:05:47,380 --> 00:05:52,120
it's still as a compile time class and

00:05:50,020 --> 00:05:53,950
anyway there's no return on investment

00:05:52,120 --> 00:05:55,840
for us to make our code exception safe

00:05:53,950 --> 00:05:57,430
we have utilities to reduce the call

00:05:55,840 --> 00:06:00,100
stacks where there's stuff to fix

00:05:57,430 --> 00:06:02,680
and we even use a static analysis tool

00:06:00,100 --> 00:06:04,630
like every beauty that can tell you you

00:06:02,680 --> 00:06:06,340
know this function 8 times of 10 you're

00:06:04,630 --> 00:06:09,390
looking at the return code but even here

00:06:06,340 --> 00:06:12,010
you're not be making a mistake

00:06:09,390 --> 00:06:14,860
we don't use the STL containers in the

00:06:12,010 --> 00:06:17,139
engine but we do use the SL Egger rims

00:06:14,860 --> 00:06:20,229
with other containers

00:06:17,139 --> 00:06:21,939
affecting Estela interface we don't use

00:06:20,229 --> 00:06:24,310
a CD vector because our hourglass has

00:06:21,939 --> 00:06:26,710
more features especially debug features

00:06:24,310 --> 00:06:28,979
and for the other containers there are

00:06:26,710 --> 00:06:31,719
alternatives with better performance

00:06:28,979 --> 00:06:35,409
often these alternatives they will come

00:06:31,719 --> 00:06:37,379
with some restrictions for example a map

00:06:35,409 --> 00:06:39,370
container could say only supporting

00:06:37,379 --> 00:06:42,729
achaeans values that are value types

00:06:39,370 --> 00:06:44,229
that oughta have constructors in our

00:06:42,729 --> 00:06:46,389
case not only we're fine with these

00:06:44,229 --> 00:06:48,879
restrictions but we see em as features I

00:06:46,389 --> 00:06:51,279
don't want my programmers to make a map

00:06:48,879 --> 00:06:54,039
with ease of values without with

00:06:51,279 --> 00:06:57,430
constructors and we never ship a game

00:06:54,039 --> 00:07:01,300
with a map with a string as a key this

00:06:57,430 --> 00:07:02,770
is just not the way we work and the last

00:07:01,300 --> 00:07:05,039
one might sound controversial but we

00:07:02,770 --> 00:07:07,419
have no boost included in the engine

00:07:05,039 --> 00:07:09,159
sometimes they they appear in the past

00:07:07,419 --> 00:07:11,469
word remove camp or compilation time

00:07:09,159 --> 00:07:13,180
reasons we have much better completion

00:07:11,469 --> 00:07:15,659
now than back then so maybe it will come

00:07:13,180 --> 00:07:18,580
back in the future I don't know

00:07:15,659 --> 00:07:20,830
iteration time so as I said I think we

00:07:18,580 --> 00:07:23,319
have a good completion time considering

00:07:20,830 --> 00:07:24,789
the huge code size we have the first

00:07:23,319 --> 00:07:26,430
tool I want to mention is a tool called

00:07:24,789 --> 00:07:29,050
fast bill

00:07:26,430 --> 00:07:31,689
fast bill is not bringing that in

00:07:29,050 --> 00:07:34,629
knitting that much new to the table to

00:07:31,689 --> 00:07:36,550
us but it is containing a bunch of

00:07:34,629 --> 00:07:39,569
utilities and tools that were using

00:07:36,550 --> 00:07:42,279
before as solutions for completion time

00:07:39,569 --> 00:07:44,610
what is fast bill for us is replacing

00:07:42,279 --> 00:07:52,180
game is built for C++ so it's really

00:07:44,610 --> 00:07:54,219
make file to like Boojum or G make it's

00:07:52,180 --> 00:07:58,240
open source and it's made by Fanta with

00:07:54,219 --> 00:07:59,770
working at Ubisoft Montreal today so

00:07:58,240 --> 00:08:02,710
compared to a mess Belfast it means

00:07:59,770 --> 00:08:04,509
smarter a dll dependencies since we can

00:08:02,710 --> 00:08:06,669
compile it provides a dll without

00:08:04,509 --> 00:08:09,759
waiting for the dependencies of the DLL

00:08:06,669 --> 00:08:12,879
itself better CPUs it according to your

00:08:09,759 --> 00:08:22,689
numbers and it has support for

00:08:12,879 --> 00:08:22,910
distribution and caching so what we do

00:08:22,689 --> 00:08:25,250
is

00:08:22,910 --> 00:08:28,100
we is like incredible basically so what

00:08:25,250 --> 00:08:29,600
we do is that we run fast build workers

00:08:28,100 --> 00:08:30,950
on every developer machine and every

00:08:29,600 --> 00:08:34,099
developer is contributing the

00:08:30,950 --> 00:08:35,990
compilation of others with as much as

00:08:34,099 --> 00:08:38,690
half of his course if it's machine is

00:08:35,990 --> 00:08:40,310
idle and whence the teresting is that

00:08:38,690 --> 00:08:43,039
before I said you know three to five

00:08:40,310 --> 00:08:45,040
minutes depending on targets five

00:08:43,039 --> 00:08:48,080
minutes actually without distribution on

00:08:45,040 --> 00:08:50,420
Rainbow six an assassin's creed building

00:08:48,080 --> 00:08:52,460
without distribution is a bit slower but

00:08:50,420 --> 00:08:53,990
the serious thing is that with

00:08:52,460 --> 00:08:55,610
distribution which seems to compile

00:08:53,990 --> 00:08:57,680
pretty much every project at Ubisoft

00:08:55,610 --> 00:09:00,500
Montreal in three minutes there's a kind

00:08:57,680 --> 00:09:03,470
of a critical path that we have that is

00:09:00,500 --> 00:09:07,100
order to make its order to go slower

00:09:03,470 --> 00:09:09,440
look pastor than that and fast bill is

00:09:07,100 --> 00:09:11,390
also support for caching so the way fast

00:09:09,440 --> 00:09:13,310
build is distributing compilation is

00:09:11,390 --> 00:09:15,530
like by pre-processing locally the file

00:09:13,310 --> 00:09:17,690
to remove dependencies of all the

00:09:15,530 --> 00:09:20,510
includes and then send it to our machine

00:09:17,690 --> 00:09:22,490
and so it can make an md5 at that

00:09:20,510 --> 00:09:23,120
pre-process file and look on a cache in

00:09:22,490 --> 00:09:25,370
the network

00:09:23,120 --> 00:09:27,740
the result was done already by somebody

00:09:25,370 --> 00:09:29,510
else so what we do is that build

00:09:27,740 --> 00:09:30,830
machines on the bill farm they will

00:09:29,510 --> 00:09:32,450
update the cache because there's

00:09:30,830 --> 00:09:34,940
overhead so we only do it on dual

00:09:32,450 --> 00:09:37,460
machines and programmers they typically

00:09:34,940 --> 00:09:39,230
don't sink the last the add of the code

00:09:37,460 --> 00:09:42,170
always the instead go through a tool

00:09:39,230 --> 00:09:44,630
that will think the last changes that

00:09:42,170 --> 00:09:46,910
was successfully compiled in machines so

00:09:44,630 --> 00:09:48,710
it means that the cache is up-to-date so

00:09:46,910 --> 00:09:51,140
the first time a programmer will will

00:09:48,710 --> 00:09:52,580
sync the compilation will be extremely

00:09:51,140 --> 00:09:55,100
fast because typically primers their

00:09:52,580 --> 00:09:57,500
work on very high layers so bank bunch

00:09:55,100 --> 00:10:02,230
of a big part of the code is well they

00:09:57,500 --> 00:10:05,720
will get a recompile for most free and

00:10:02,230 --> 00:10:09,080
lastly fast bill supports unity builds

00:10:05,720 --> 00:10:11,800
built in we've been using unity builds

00:10:09,080 --> 00:10:14,360
and QB soft Montreal for over ten years

00:10:11,800 --> 00:10:17,270
we call them the blobs that Ubisoft much

00:10:14,360 --> 00:10:20,780
wrong so if you don't know the concept

00:10:17,270 --> 00:10:22,280
as the concept of having let special CPP

00:10:20,780 --> 00:10:24,950
file it will basically include a big

00:10:22,280 --> 00:10:28,760
number of UCP files and come compile

00:10:24,950 --> 00:10:30,470
that unity CPP file instead and overall

00:10:28,760 --> 00:10:33,080
it will compile faster is what us will

00:10:30,470 --> 00:10:35,800
link faster my 10 line a few more

00:10:33,080 --> 00:10:35,800
functions as well as

00:10:35,940 --> 00:10:40,530
consequences it means your high scope do

00:10:37,770 --> 00:10:42,420
you need to have unique name I need if

00:10:40,530 --> 00:10:44,280
you make defines and simplifies you must

00:10:42,420 --> 00:10:46,380
not forget to under them because I can

00:10:44,280 --> 00:10:50,370
affect another CP pile and the same

00:10:46,380 --> 00:10:52,440
unity but most importantly means that

00:10:50,370 --> 00:10:54,210
you need to maintain still a compilation

00:10:52,440 --> 00:10:56,880
without unity builds because you want

00:10:54,210 --> 00:11:00,750
every CPP file to add all the included

00:10:56,880 --> 00:11:02,910
needs and people also complain when

00:11:00,750 --> 00:11:04,620
using unity builds that when I modify is

00:11:02,910 --> 00:11:08,700
CP file then I need to recompile the

00:11:04,620 --> 00:11:10,560
entire unity in ok sit as when built

00:11:08,700 --> 00:11:12,360
being true but only the first time we

00:11:10,560 --> 00:11:14,910
modify a file so what we had before is a

00:11:12,360 --> 00:11:17,520
special unit here work unity and will

00:11:14,910 --> 00:11:19,440
edit a file it will remove us from that

00:11:17,520 --> 00:11:21,330
unity and put it in the work unity so

00:11:19,440 --> 00:11:25,020
that way you will iterate over your work

00:11:21,330 --> 00:11:27,030
indeed I have never done it but you

00:11:25,020 --> 00:11:28,800
could even do that in parallel as you

00:11:27,030 --> 00:11:31,130
first edit the file in vyasa you

00:11:28,800 --> 00:11:35,670
directly launch the completion of the

00:11:31,130 --> 00:11:38,130
unity - change um but since fast build

00:11:35,670 --> 00:11:40,800
is creating the unity builds on the fly

00:11:38,130 --> 00:11:44,100
as it is compiling it doesn't even need

00:11:40,800 --> 00:11:45,510
that step can just remove from unity

00:11:44,100 --> 00:11:48,210
builds ICP file you are working your

00:11:45,510 --> 00:11:52,200
onion just you just iterate over them

00:11:48,210 --> 00:11:54,030
directly there's other stuff we do as

00:11:52,200 --> 00:11:55,590
well use pre compile errors like a lot

00:11:54,030 --> 00:11:57,930
of people some people they stink they

00:11:55,590 --> 00:11:59,790
are competing with unity builds before

00:11:57,930 --> 00:12:02,220
my numbers are completing each other

00:11:59,790 --> 00:12:05,340
there where we don't use pre compilers

00:12:02,220 --> 00:12:06,930
is in some distribution patterns

00:12:05,340 --> 00:12:09,000
depending on platform sometimes they are

00:12:06,930 --> 00:12:11,550
not worth it on other machines to use

00:12:09,000 --> 00:12:14,100
but luckily it for us it's like a big

00:12:11,550 --> 00:12:16,350
big game oops sorry there's one

00:12:14,100 --> 00:12:19,380
Microsoft compiler option that I think

00:12:16,350 --> 00:12:22,080
is really resting for debug builds the

00:12:19,380 --> 00:12:26,430
option is called ob1 not to confuse with

00:12:22,080 --> 00:12:28,440
the Star Wars character what the obi-wan

00:12:26,430 --> 00:12:32,100
is doing is minimally lining so it will

00:12:28,440 --> 00:12:33,810
inline simple functions from 805 so it

00:12:32,100 --> 00:12:36,140
mine signs we'd at first we have a debug

00:12:33,810 --> 00:12:39,300
target where some functions are in line

00:12:36,140 --> 00:12:40,920
but I've been working with that for over

00:12:39,300 --> 00:12:44,400
five years now and I don't want to go

00:12:40,920 --> 00:12:46,470
back um the reason is that my debug

00:12:44,400 --> 00:12:49,070
target is not much faster and since the

00:12:46,470 --> 00:12:51,680
video game it's it's

00:12:49,070 --> 00:12:53,390
it's appreciable and also it will link

00:12:51,680 --> 00:12:55,280
faster because there's a big bunch of

00:12:53,390 --> 00:12:59,780
symbol that don't need to be object five

00:12:55,280 --> 00:13:02,090
anymore and this one is really important

00:12:59,780 --> 00:13:04,940
when people have bad completion time is

00:13:02,090 --> 00:13:07,460
often because of template's so we try to

00:13:04,940 --> 00:13:11,230
make template classes derived from non

00:13:07,460 --> 00:13:14,570
template based classes the idea is that

00:13:11,230 --> 00:13:16,970
template code should end up in line by

00:13:14,570 --> 00:13:20,150
your compiler otherwise maybe you should

00:13:16,970 --> 00:13:22,070
write your template code differently if

00:13:20,150 --> 00:13:25,100
I take an example an assassin shoot one

00:13:22,070 --> 00:13:28,430
at first was not done so we add an RA

00:13:25,100 --> 00:13:30,680
class the entire code was there then in

00:13:28,430 --> 00:13:34,850
every translation unit we compile aways

00:13:30,680 --> 00:13:37,310
the exact same re types even if we use

00:13:34,850 --> 00:13:41,720
unity bills we still have maybe 300 of

00:13:37,310 --> 00:13:44,000
them in our code base but we did instead

00:13:41,720 --> 00:13:46,490
is that we change the class to move

00:13:44,000 --> 00:13:49,160
inside a non template based class as

00:13:46,490 --> 00:13:52,450
much code as possible and some cases 7

00:13:49,160 --> 00:13:54,860
is CPP 5 to make sure it's not in line

00:13:52,450 --> 00:13:57,200
yeah and then in the template code we

00:13:54,860 --> 00:14:01,990
keep simple function that will end up in

00:13:57,200 --> 00:14:04,340
line we also use a lot of generate code

00:14:01,990 --> 00:14:06,290
we have our own interface description

00:14:04,340 --> 00:14:09,650
language for our object model

00:14:06,290 --> 00:14:11,540
so basically next - most header file and

00:14:09,650 --> 00:14:13,790
CPP file in the engine we have another

00:14:11,540 --> 00:14:16,370
file that is the interface description

00:14:13,790 --> 00:14:19,010
file and there we declare classes

00:14:16,370 --> 00:14:22,430
structures denims and there and some of

00:14:19,010 --> 00:14:24,350
their properties and function and this

00:14:22,430 --> 00:14:26,840
valley is responsible of code regions

00:14:24,350 --> 00:14:29,960
inside the corresponding header file and

00:14:26,840 --> 00:14:31,700
CPP files so for example in our header

00:14:29,960 --> 00:14:33,530
file you will have a class and vary as

00:14:31,700 --> 00:14:35,870
the bracket is opening you have a code

00:14:33,530 --> 00:14:37,370
region and you can still the primary and

00:14:35,870 --> 00:14:38,930
seller right is all members and all

00:14:37,370 --> 00:14:40,970
functions are outside the cold region

00:14:38,930 --> 00:14:42,880
but current record region itself is

00:14:40,970 --> 00:14:45,170
completely and all by a tool that we run

00:14:42,880 --> 00:14:48,650
very quickly at the beginning of every

00:14:45,170 --> 00:14:50,660
compilation and this tool is allowing us

00:14:48,650 --> 00:14:52,730
to the interesting we can avoid a lot of

00:14:50,660 --> 00:14:55,190
meta programming in the CP files example

00:14:52,730 --> 00:14:57,050
the skills a shell function they know

00:14:55,190 --> 00:14:59,360
exactly all the properties were declared

00:14:57,050 --> 00:15:01,700
inside the interface description file a

00:14:59,360 --> 00:15:02,780
narrow file we can sort members to

00:15:01,700 --> 00:15:08,240
minimize padding between

00:15:02,780 --> 00:15:10,730
save memory we can generate IDs as CRC's

00:15:08,240 --> 00:15:13,850
of a name all of that directly inside

00:15:10,730 --> 00:15:15,530
the tool so basically we have created

00:15:13,850 --> 00:15:18,140
another file with another timestamp that

00:15:15,530 --> 00:15:21,290
will affect the generated code so that

00:15:18,140 --> 00:15:25,730
way we can then speed up the c++

00:15:21,290 --> 00:15:28,150
compilation alone and we also have our

00:15:25,730 --> 00:15:31,160
own programming language as it actually

00:15:28,150 --> 00:15:34,760
it looks very much like c++ it's

00:15:31,160 --> 00:15:37,160
actually generating c++ under it and the

00:15:34,760 --> 00:15:38,570
reason we did that language because we

00:15:37,160 --> 00:15:41,240
wanted to have edit and continue working

00:15:38,570 --> 00:15:43,880
on 64-bit platforms or gameplay

00:15:41,240 --> 00:15:45,410
programmers we event went further by

00:15:43,880 --> 00:15:47,140
making sure that editing cut you is

00:15:45,410 --> 00:15:51,260
working event in multiplayer session

00:15:47,140 --> 00:15:55,880
propagating code to all to all players

00:15:51,260 --> 00:15:57,890
and we even wanted to be able to remove

00:15:55,880 --> 00:15:59,570
and add virtual functions so when it

00:15:57,890 --> 00:16:01,970
comes to the virtual functions

00:15:59,570 --> 00:16:04,430
implementation is not using the c++

00:16:01,970 --> 00:16:07,220
virtual function we have our own table

00:16:04,430 --> 00:16:10,040
so that we can patch function pointers

00:16:07,220 --> 00:16:12,740
at runtime more easily and since

00:16:10,040 --> 00:16:15,740
generating c++ we benefit from aligning

00:16:12,740 --> 00:16:17,810
all the performance from c++ and we used

00:16:15,740 --> 00:16:20,030
no preprocessor tricks like dash line

00:16:17,810 --> 00:16:23,990
all of that to specify the original file

00:16:20,030 --> 00:16:25,670
line so we support the C++ debugger

00:16:23,990 --> 00:16:29,170
completely naturally since for the

00:16:25,670 --> 00:16:29,170
debugger it's like it's it was passing

00:16:31,180 --> 00:16:36,800
and we have developed some tools for the

00:16:34,070 --> 00:16:40,220
years to help up speed up improve our

00:16:36,800 --> 00:16:43,340
code one tool to mention is an objection

00:16:40,220 --> 00:16:46,730
eliezer so the idea is to give you the

00:16:43,340 --> 00:16:48,560
size of a symbol but by making the total

00:16:46,730 --> 00:16:51,770
of its size across all the translation

00:16:48,560 --> 00:16:53,240
units so you might see functions that

00:16:51,770 --> 00:16:55,610
are an arrow files but should not be

00:16:53,240 --> 00:16:56,810
there because they are just too big but

00:16:55,610 --> 00:17:00,530
more likely what you will see are

00:16:56,810 --> 00:17:03,440
templates I the area class I've

00:17:00,530 --> 00:17:06,410
mentioned earlier about on Assassin's

00:17:03,440 --> 00:17:09,050
Creed um before doing that change or

00:17:06,410 --> 00:17:10,850
splitting the class into pieces an

00:17:09,050 --> 00:17:13,130
assassin's creed one that place that

00:17:10,850 --> 00:17:16,880
class before that change was taking

00:17:13,130 --> 00:17:20,480
almost 80% of object files of all the

00:17:16,880 --> 00:17:22,880
imagine you have a million multiple

00:17:20,480 --> 00:17:24,620
millions lines of code engine and you

00:17:22,880 --> 00:17:28,280
have a single template class taking

00:17:24,620 --> 00:17:30,770
almost 80% of object file still today

00:17:28,280 --> 00:17:32,360
with the changes who did in debug we

00:17:30,770 --> 00:17:34,420
have some functions that don't end up in

00:17:32,360 --> 00:17:37,760
line because of debug check that we are

00:17:34,420 --> 00:17:41,860
them and still the error class is taking

00:17:37,760 --> 00:17:44,420
15% of objects files and debug target

00:17:41,860 --> 00:17:46,430
we also made our tool to remove useless

00:17:44,420 --> 00:17:48,680
include and Ave and add forward

00:17:46,430 --> 00:17:50,090
declarations I want about talk about it

00:17:48,680 --> 00:17:52,670
much because realized recently that

00:17:50,090 --> 00:17:54,260
Google's include what you use is

00:17:52,670 --> 00:17:56,240
actually a better tool these Ness

00:17:54,260 --> 00:18:01,370
configuration which is the same thing so

00:17:56,240 --> 00:18:02,960
just use that thing instead when it

00:18:01,370 --> 00:18:05,690
comes to performance it's well known

00:18:02,960 --> 00:18:09,260
that we care about performance in the

00:18:05,690 --> 00:18:11,270
game industry some performance very

00:18:09,260 --> 00:18:13,910
important for us the last console

00:18:11,270 --> 00:18:17,180
generation lasted for eight years you

00:18:13,910 --> 00:18:20,180
can imagine that we need to be able to

00:18:17,180 --> 00:18:22,910
always make more with the same there's a

00:18:20,180 --> 00:18:27,310
90/10 principle arguing pretty much 90%

00:18:22,910 --> 00:18:31,340
of the time wasted and 10% of the code

00:18:27,310 --> 00:18:33,020
so people working on that 10% pretty

00:18:31,340 --> 00:18:37,370
much I have a different mindset people

00:18:33,020 --> 00:18:39,200
working on the rest of the code um that

00:18:37,370 --> 00:18:43,450
mindset is pretty much similar to what

00:18:39,200 --> 00:18:47,810
we heard from Mike Acton earlier today

00:18:43,450 --> 00:18:50,060
and the way an engine is made is it has

00:18:47,810 --> 00:18:52,040
a frame rate so it's a big part of the

00:18:50,060 --> 00:18:53,690
code is being stressed confusing so it's

00:18:52,040 --> 00:18:55,610
not like a desktop application that is

00:18:53,690 --> 00:19:00,950
event-driven and it's not running that

00:18:55,610 --> 00:19:02,690
much code um so yeah typically a game

00:19:00,950 --> 00:19:05,510
will run at 30 frames per second so

00:19:02,690 --> 00:19:09,170
30fps gain of games like Rainbow six

00:19:05,510 --> 00:19:11,510
siege a seven 60 FPS what happens is

00:19:09,170 --> 00:19:12,610
that when shipping again may be months

00:19:11,510 --> 00:19:15,500
before shipping a game especially

00:19:12,610 --> 00:19:19,460
single-player games your game might be

00:19:15,500 --> 00:19:21,590
during at 20 FPS or 22 FPS but you want

00:19:19,460 --> 00:19:23,690
to ship a game at 30 FPS and you don't

00:19:21,590 --> 00:19:27,149
want to cut stuff that people have put a

00:19:23,690 --> 00:19:29,519
lot of effort in so what

00:19:27,149 --> 00:19:31,710
that a lot of people a lot of talented

00:19:29,519 --> 00:19:35,119
programmers they are dedicated to just

00:19:31,710 --> 00:19:37,979
optimize the last months of the game

00:19:35,119 --> 00:19:40,830
have been extremely impressed in the

00:19:37,979 --> 00:19:43,919
last eight years seeing people

00:19:40,830 --> 00:19:46,589
optimizing code that was technically

00:19:43,919 --> 00:19:49,969
have been already optimized by multiple

00:19:46,589 --> 00:19:52,489
other talented people and they succeed

00:19:49,969 --> 00:19:56,399
when way of doing that is by

00:19:52,489 --> 00:19:58,289
understanding the art where so I want to

00:19:56,399 --> 00:19:58,950
give a quick example very simple I have

00:19:58,289 --> 00:20:01,859
a structure

00:19:58,950 --> 00:20:04,529
it's basically an area of integers which

00:20:01,859 --> 00:20:08,070
are a bunch of different values they

00:20:04,529 --> 00:20:09,809
make a make a you Jerry and the exact

00:20:08,070 --> 00:20:13,979
size it matter it's not least it's one

00:20:09,809 --> 00:20:16,229
Meg of objects from that type and I have

00:20:13,979 --> 00:20:17,999
two different piece of code doing exact

00:20:16,229 --> 00:20:20,849
same thing are just calculating the

00:20:17,999 --> 00:20:22,889
total of all the value don't reach a

00:20:20,849 --> 00:20:25,950
spec is to join the same speed which one

00:20:22,889 --> 00:20:27,450
you expect one on the same speed I've

00:20:25,950 --> 00:20:30,059
seen a lot of stacks this week that

00:20:27,450 --> 00:20:33,019
assume that you know the answer this um

00:20:30,059 --> 00:20:36,089
so if it's not your case

00:20:33,019 --> 00:20:38,129
let me explain it preferment this on my

00:20:36,089 --> 00:20:42,539
pc the second example is running eight

00:20:38,129 --> 00:20:43,739
times faster so why is that programmers

00:20:42,539 --> 00:20:45,599
they understand there's a huge

00:20:43,739 --> 00:20:47,729
difference between the rhyme the our

00:20:45,599 --> 00:20:50,039
drive not event access to have them

00:20:47,729 --> 00:20:53,070
anyway the same way i drive is bigger

00:20:50,039 --> 00:20:55,979
it's slower but the cpu and it's

00:20:53,070 --> 00:20:58,289
registers is not accessing your eight

00:20:55,979 --> 00:21:00,509
gigs or 3d quick gigs 32 gigs of ram

00:20:58,289 --> 00:21:05,669
directly it is going to on the processor

00:21:00,509 --> 00:21:08,249
to multiple layers of cache the exact

00:21:05,669 --> 00:21:09,979
number of cache is mean it depends on

00:21:08,249 --> 00:21:12,570
the hardware but there are common stuff

00:21:09,979 --> 00:21:14,909
the l1 cache will be specific to the

00:21:12,570 --> 00:21:16,589
core while the last level cache and that

00:21:14,909 --> 00:21:19,289
case the l3 cache will be shared across

00:21:16,589 --> 00:21:21,299
all the court so suppose i imagine

00:21:19,289 --> 00:21:24,960
here's some fictional hardware made of

00:21:21,299 --> 00:21:26,580
six cores i the l1 cache is specific the

00:21:24,960 --> 00:21:28,649
core and then i decide that the l2 cache

00:21:26,580 --> 00:21:30,809
will be shared across pairs of cord and

00:21:28,649 --> 00:21:33,379
finally I'll have the l3 that is shared

00:21:30,809 --> 00:21:36,269
across all the cores and then the memory

00:21:33,379 --> 00:21:39,419
so when a core is accessing memory

00:21:36,269 --> 00:21:40,890
address it first look if under old it

00:21:39,419 --> 00:21:44,010
will look if the if it's in the

00:21:40,890 --> 00:21:47,190
l1 cache the caches are caching cache

00:21:44,010 --> 00:21:50,610
lines so for example the l1 cache could

00:21:47,190 --> 00:21:52,560
be 64 K big and with cache lines of 64

00:21:50,610 --> 00:21:56,220
bytes so it means I had thousands pieces

00:21:52,560 --> 00:21:59,250
from the memory 64 bytes big align at 64

00:21:56,220 --> 00:21:59,910
bytes these pieces can be from all

00:21:59,250 --> 00:22:02,130
underpriced

00:21:59,910 --> 00:22:03,990
in the main memory so it will load with

00:22:02,130 --> 00:22:06,330
the address the memory to accessing if

00:22:03,990 --> 00:22:09,630
it's part of the cache if not you have

00:22:06,330 --> 00:22:13,950
l1 cache miss l2 check it's not there L

00:22:09,630 --> 00:22:15,480
2 cache miss if not then you have l3

00:22:13,950 --> 00:22:17,160
cache miss and the main memory would be

00:22:15,480 --> 00:22:18,990
access for the l3 cache miss in that

00:22:17,160 --> 00:22:21,810
case the worst case because then you

00:22:18,990 --> 00:22:24,810
need create a price the speed of the

00:22:21,810 --> 00:22:26,660
main memory since if you have the layers

00:22:24,810 --> 00:22:29,250
the same rules are playing they are

00:22:26,660 --> 00:22:32,270
further you get from the chord the

00:22:29,250 --> 00:22:34,380
bigger they are but the slower they are

00:22:32,270 --> 00:22:36,840
there's a lot of things here to talk

00:22:34,380 --> 00:22:38,330
about the resting stuff how much all of

00:22:36,840 --> 00:22:40,710
this can be done in parallel other

00:22:38,330 --> 00:22:44,610
processor is making sure all the l1 are

00:22:40,710 --> 00:22:46,050
current but I won't I think that's a C++

00:22:44,610 --> 00:22:47,790
forum what you need to understand is

00:22:46,050 --> 00:22:51,240
that less you access a memory address

00:22:47,790 --> 00:22:53,670
the more likely you are to less like it

00:22:51,240 --> 00:22:57,420
more like you are to pay I cuss if you

00:22:53,670 --> 00:23:00,630
work with huge data you don't work

00:22:57,420 --> 00:23:05,490
properly you are so likely to you have a

00:23:00,630 --> 00:23:08,130
big performance it also typically the

00:23:05,490 --> 00:23:11,250
way the l1 cache would be endl if it

00:23:08,130 --> 00:23:14,550
requires writing to a with l1 cache it

00:23:11,250 --> 00:23:17,160
will be it will have exclusivity to the

00:23:14,550 --> 00:23:19,140
cache line that it is writing to which

00:23:17,160 --> 00:23:21,600
means that if 2 core are writing to the

00:23:19,140 --> 00:23:23,250
exact same cache line if they are not

00:23:21,600 --> 00:23:25,890
writing the same bytes you will have a

00:23:23,250 --> 00:23:29,730
performance it one example earlier this

00:23:25,890 --> 00:23:31,200
week and an episode or stock where you

00:23:29,730 --> 00:23:33,680
have a remote treated container and

00:23:31,200 --> 00:23:35,940
aligning the node on the cache line size

00:23:33,680 --> 00:23:37,620
was improving performance greatly

00:23:35,940 --> 00:23:40,890
because that way you could not have to

00:23:37,620 --> 00:23:42,480
note in the same cache line if you come

00:23:40,890 --> 00:23:45,030
back to the example that was running

00:23:42,480 --> 00:23:47,460
faster it is accessing the arena

00:23:45,030 --> 00:23:49,290
completely sequential way this is the

00:23:47,460 --> 00:23:51,390
best because event modern processors

00:23:49,290 --> 00:23:54,660
today they can detect such patterns and

00:23:51,390 --> 00:23:57,930
even prefetch the cash in advance to me

00:23:54,660 --> 00:24:01,230
- mrs. but if we switch these two for

00:23:57,930 --> 00:24:03,290
loops then we're accessing memory in a

00:24:01,230 --> 00:24:05,460
completely different way or first

00:24:03,290 --> 00:24:09,690
getting the first element of every

00:24:05,460 --> 00:24:12,960
object and then we start back in yet the

00:24:09,690 --> 00:24:14,550
second lemon are very object so if I'm

00:24:12,960 --> 00:24:17,250
on this fictional I'll where I have

00:24:14,550 --> 00:24:19,860
cache line of 64 bytes the size of

00:24:17,250 --> 00:24:22,710
feature is 4 divides 64 by 4 it makes 16

00:24:19,860 --> 00:24:26,130
I could expect this to run 16 times

00:24:22,710 --> 00:24:29,040
lower another example very simple I have

00:24:26,130 --> 00:24:31,440
a structure with an integer member and I

00:24:29,040 --> 00:24:33,240
have a function taking a bunch of values

00:24:31,440 --> 00:24:36,540
it will just update the member with the

00:24:33,240 --> 00:24:38,790
total the value I have two simple

00:24:36,540 --> 00:24:41,940
implementations the first one is very

00:24:38,790 --> 00:24:44,010
intuitive and of situating the value is

00:24:41,940 --> 00:24:47,190
incrementing the member and the second

00:24:44,010 --> 00:24:48,420
one is using a variable on the stack you

00:24:47,190 --> 00:24:52,170
expect these two to run on the same

00:24:48,420 --> 00:24:54,330
speed Pamuk the tests on my pc with the

00:24:52,170 --> 00:24:56,760
Microsoft compiler and ode to

00:24:54,330 --> 00:24:59,520
optimizations and the second one is

00:24:56,760 --> 00:25:00,840
running 12 times faster there are two

00:24:59,520 --> 00:25:03,690
things happening here this is dependent

00:25:00,840 --> 00:25:07,650
on odd where and this is dependent on

00:25:03,690 --> 00:25:09,120
the compiler itself as well so what

00:25:07,650 --> 00:25:11,310
happens is that in the first example the

00:25:09,120 --> 00:25:13,440
or compare is very likely that decided

00:25:11,310 --> 00:25:15,840
what you doing inside the follow is read

00:25:13,440 --> 00:25:18,480
from memory make a calculation and then

00:25:15,840 --> 00:25:20,970
write back to memory you quickly in the

00:25:18,480 --> 00:25:22,830
next iteration you're reading back in

00:25:20,970 --> 00:25:25,340
the same memory so there's a read after

00:25:22,830 --> 00:25:27,390
write opening on the processor

00:25:25,340 --> 00:25:29,850
processors will make sure that we'd have

00:25:27,390 --> 00:25:31,860
the right size as fast as possible but

00:25:29,850 --> 00:25:33,990
the point is that you cannot expect this

00:25:31,860 --> 00:25:35,850
kind of operation to be as fast as just

00:25:33,990 --> 00:25:38,460
working with the registers that are

00:25:35,850 --> 00:25:40,620
exactly that are on the same core and

00:25:38,460 --> 00:25:43,320
this is what the second example is doing

00:25:40,620 --> 00:25:45,240
as far as I know compilers could decide

00:25:43,320 --> 00:25:48,480
to transform the first example into the

00:25:45,240 --> 00:25:52,190
second example but obviously they are

00:25:48,480 --> 00:25:52,190
not and F says it with clang as well

00:25:55,220 --> 00:25:58,830
when it comes to Singleton's i don't

00:25:57,300 --> 00:26:01,530
know if you have Singleton's inside your

00:25:58,830 --> 00:26:04,290
different code bases continue that with

00:26:01,530 --> 00:26:06,840
a huge code base yeah at Ubisoft we have

00:26:04,290 --> 00:26:08,670
a lot of singleton a lot of classes with

00:26:06,840 --> 00:26:12,330
name ending with manager because we lack

00:26:08,670 --> 00:26:15,840
imagination especially when it comes to

00:26:12,330 --> 00:26:18,540
singleton names we don't want to create

00:26:15,840 --> 00:26:20,310
them on the fly I want them to construct

00:26:18,540 --> 00:26:22,740
them and deterministic order want to

00:26:20,310 --> 00:26:25,680
destroy them as well dynastic after like

00:26:22,740 --> 00:26:27,600
release so what we do is that we use a

00:26:25,680 --> 00:26:30,210
property of C++ very simple that

00:26:27,600 --> 00:26:31,980
constructors of members are called in

00:26:30,210 --> 00:26:35,120
the under declaration and destructors in

00:26:31,980 --> 00:26:37,470
the reverse order so every library has a

00:26:35,120 --> 00:26:38,820
special structure that we call singleton

00:26:37,470 --> 00:26:41,930
story where we declare this our

00:26:38,820 --> 00:26:45,960
singleton in their order of dependency

00:26:41,930 --> 00:26:47,250
so Auto implement such a singleton one

00:26:45,960 --> 00:26:50,600
way of doing it is just have a static

00:26:47,250 --> 00:26:53,220
pointer and set it in the constructor

00:26:50,600 --> 00:26:55,710
but what happens if this singleton is

00:26:53,220 --> 00:26:59,220
access thousands of times every frame

00:26:55,710 --> 00:27:00,420
and very different context what happens

00:26:59,220 --> 00:27:02,280
is that you get something that is

00:27:00,420 --> 00:27:05,070
actually less performant than just using

00:27:02,280 --> 00:27:10,020
global object and I couldn't measure the

00:27:05,070 --> 00:27:11,970
difference on xbox 360 the reason is

00:27:10,020 --> 00:27:13,470
that the global object you will access

00:27:11,970 --> 00:27:15,600
directly the memory address of the

00:27:13,470 --> 00:27:17,400
object itself while here the global

00:27:15,600 --> 00:27:19,530
object is actually the static pointer we

00:27:17,400 --> 00:27:21,420
have an indirection the problem is not

00:27:19,530 --> 00:27:22,710
you know CPU instructions to just

00:27:21,420 --> 00:27:27,090
dereference the problem is the cache

00:27:22,710 --> 00:27:30,740
miss that could occur so one solution is

00:27:27,090 --> 00:27:33,180
just to use global objects instead and

00:27:30,740 --> 00:27:34,940
call maybe initialize and shutdown

00:27:33,180 --> 00:27:38,340
functions inside this an open sorry

00:27:34,940 --> 00:27:39,750
another solution would propose we that

00:27:38,340 --> 00:27:41,690
is available in origin is our class

00:27:39,750 --> 00:27:44,640
class called global singleton

00:27:41,690 --> 00:27:46,380
so what is doing is that it has a static

00:27:44,640 --> 00:27:48,150
buffer that as the same size and the

00:27:46,380 --> 00:27:51,840
same alignment as the type you are

00:27:48,150 --> 00:27:54,030
passing and the scope nested class under

00:27:51,840 --> 00:27:56,250
the hood is constructor will mate please

00:27:54,030 --> 00:27:57,540
meet you inside the buffer and the

00:27:56,250 --> 00:27:59,760
destructor will do the opposite

00:27:57,540 --> 00:28:01,530
call the destructor so then getting the

00:27:59,760 --> 00:28:03,900
instance is just casting the address of

00:28:01,530 --> 00:28:05,870
the buffer as a pointer to distinguish

00:28:03,900 --> 00:28:07,550
in pipe so in the end you

00:28:05,870 --> 00:28:09,920
yet Singleton that has the same

00:28:07,550 --> 00:28:13,690
performance as a global object but with

00:28:09,920 --> 00:28:16,190
control construction and destruction I

00:28:13,690 --> 00:28:17,720
have talked about the lack cache miss

00:28:16,190 --> 00:28:19,910
but there's coast cache miss as well

00:28:17,720 --> 00:28:22,550
maybe when you started programming a

00:28:19,910 --> 00:28:24,680
long time ago you were writing you have

00:28:22,550 --> 00:28:26,809
a big bunch of shapes of different types

00:28:24,680 --> 00:28:28,760
you were writing an ugly switch case

00:28:26,809 --> 00:28:30,080
like on the right then you realize oh no

00:28:28,760 --> 00:28:32,660
this is not the way it should work I

00:28:30,080 --> 00:28:35,809
should make a shape abstract base class

00:28:32,660 --> 00:28:37,070
and have an abstract draw function in it

00:28:35,809 --> 00:28:40,010
and then if you shape type will

00:28:37,070 --> 00:28:42,170
implement the draw function then you

00:28:40,010 --> 00:28:43,910
iterate over a new array of shapes and

00:28:42,170 --> 00:28:46,750
then you call the draw function on every

00:28:43,910 --> 00:28:49,480
shape what's happening under the hood

00:28:46,750 --> 00:28:51,980
the object pointer will be different

00:28:49,480 --> 00:28:53,980
probably to get the first eight bytes of

00:28:51,980 --> 00:28:56,900
your object to get the vtable pointer

00:28:53,980 --> 00:28:58,460
you might add a cache miss but maybe

00:28:56,900 --> 00:29:00,080
such a big nut should big deal because

00:28:58,460 --> 00:29:02,750
probably the draw function will access

00:29:00,080 --> 00:29:04,640
members in the same cache line then it

00:29:02,750 --> 00:29:06,830
needs to access the table itself if you

00:29:04,640 --> 00:29:09,050
have a lot of shape types good change

00:29:06,830 --> 00:29:10,730
you have a data cache miss here then

00:29:09,050 --> 00:29:13,610
you're only interested in a single

00:29:10,730 --> 00:29:16,010
function inside that table you get the

00:29:13,610 --> 00:29:19,160
function pointer and then you go to the

00:29:16,010 --> 00:29:22,250
where the code it is again our to

00:29:19,160 --> 00:29:23,540
predict that you were needing that good

00:29:22,250 --> 00:29:26,150
chance you have a code cache miss as

00:29:23,540 --> 00:29:29,179
well because these two are multiplied

00:29:26,150 --> 00:29:31,190
and under F types you have a quick fix

00:29:29,179 --> 00:29:33,290
to at least sort your shapes by type

00:29:31,190 --> 00:29:38,600
that way you will get these cache misses

00:29:33,290 --> 00:29:40,190
only as you meet a new type but what I'm

00:29:38,600 --> 00:29:42,230
saying is not to not use virtual

00:29:40,190 --> 00:29:44,480
functions just as people working in that

00:29:42,230 --> 00:29:48,470
10 percent of code they are will avoid

00:29:44,480 --> 00:29:50,030
the pattern at left it will typically

00:29:48,470 --> 00:29:53,210
instead aim for that are driven

00:29:50,030 --> 00:29:55,580
programming the idea is that is to

00:29:53,210 --> 00:29:57,950
remove abstraction don't iterate over

00:29:55,580 --> 00:30:00,770
pointers of shape their iterate over

00:29:57,950 --> 00:30:04,100
shapes and put the shapes of the same

00:30:00,770 --> 00:30:06,410
type together so iterate over the single

00:30:04,100 --> 00:30:07,790
shape and then you are so avoid code

00:30:06,410 --> 00:30:10,190
cache miss because you're running code

00:30:07,790 --> 00:30:11,929
exactly for that type and since you

00:30:10,190 --> 00:30:13,550
iterate over shape themself you trigger

00:30:11,929 --> 00:30:16,200
they rake over them in the order they

00:30:13,550 --> 00:30:18,059
are in memory which will make the

00:30:16,200 --> 00:30:20,039
best performance possible the processor

00:30:18,059 --> 00:30:22,710
can help you to prefetch more easily and

00:30:20,039 --> 00:30:25,200
to be honest when we on video game

00:30:22,710 --> 00:30:27,480
consoles if we need to prefetch manually

00:30:25,200 --> 00:30:29,429
to help the compiler we do it don't do

00:30:27,480 --> 00:30:31,830
that on PC that can slow down things but

00:30:29,429 --> 00:30:37,590
but on a fixed side wall at consoles we

00:30:31,830 --> 00:30:39,090
event prefetch remember yourself I don't

00:30:37,590 --> 00:30:40,799
want to come back to an example I've

00:30:39,090 --> 00:30:43,919
shown earlier with the RA class when we

00:30:40,799 --> 00:30:46,289
divide the class inside in two classes

00:30:43,919 --> 00:30:49,049
so what we did is take template code

00:30:46,289 --> 00:30:51,929
that was not being end up in line and

00:30:49,049 --> 00:30:53,490
put it instead in a base class and make

00:30:51,929 --> 00:30:55,649
that call a bit more generic so

00:30:53,490 --> 00:30:57,510
basically with that code without

00:30:55,649 --> 00:30:59,580
slightly more instructions you know we

00:30:57,510 --> 00:31:02,940
will pass probably a size of type in the

00:30:59,580 --> 00:31:06,690
another mind of type so does it run

00:31:02,940 --> 00:31:08,610
slower I think it might even run faster

00:31:06,690 --> 00:31:12,149
and I want to at least talk about that

00:31:08,610 --> 00:31:13,710
in the case on the left if there's a

00:31:12,149 --> 00:31:15,840
constructor or something and that type

00:31:13,710 --> 00:31:16,980
and I'm instantiating my re class with

00:31:15,840 --> 00:31:20,720
2,000 types

00:31:16,980 --> 00:31:23,429
means I have 2,000 function in memory if

00:31:20,720 --> 00:31:26,130
there's no constructor or something

00:31:23,429 --> 00:31:29,639
that's so type specific probably yeah

00:31:26,130 --> 00:31:32,429
maybe with the different size of pipes

00:31:29,639 --> 00:31:34,470
or ABI I will have maybe 30 functions

00:31:32,429 --> 00:31:36,179
and memory but you can understand that

00:31:34,470 --> 00:31:39,210
you increase the chances of code cache

00:31:36,179 --> 00:31:41,730
miss with the example on the left my

00:31:39,210 --> 00:31:43,409
point is just that templates especially

00:31:41,730 --> 00:31:45,450
templates that don't end up in line by

00:31:43,409 --> 00:31:46,919
the compiler they might give you the

00:31:45,450 --> 00:31:52,769
illusion that you get something at

00:31:46,919 --> 00:31:54,250
runtime but you might not another thing

00:31:52,769 --> 00:31:56,370
too we do too

00:31:54,250 --> 00:31:59,260
performance is trying to avoid the heap

00:31:56,370 --> 00:32:00,820
the heap is a heavy I always found it

00:31:59,260 --> 00:32:02,080
funny when I see people writing

00:32:00,820 --> 00:32:04,030
containers trying to make sure

00:32:02,080 --> 00:32:05,830
everything is in line while the way to

00:32:04,030 --> 00:32:08,400
use allocations is taking more time than

00:32:05,830 --> 00:32:10,630
the rest of the container combined and

00:32:08,400 --> 00:32:12,040
the reap is global so you can allocate

00:32:10,630 --> 00:32:15,730
in the thread the allocation another

00:32:12,040 --> 00:32:19,810
shred so when you pay a price for that

00:32:15,730 --> 00:32:23,410
and in video games where we allocate so

00:32:19,810 --> 00:32:25,390
much every frame we have can have issues

00:32:23,410 --> 00:32:27,400
of fragmentation permutation is very

00:32:25,390 --> 00:32:29,890
simple you still have space inside your

00:32:27,400 --> 00:32:31,570
locator but will still go out of memory

00:32:29,890 --> 00:32:33,780
because you're asking a buffer that is

00:32:31,570 --> 00:32:36,730
bigger than any of these small spaces

00:32:33,780 --> 00:32:39,430
something that was done on Assassin's

00:32:36,730 --> 00:32:40,840
Creed 1 and we're still doing today then

00:32:39,430 --> 00:32:45,640
when we have an area on the stack like

00:32:40,840 --> 00:32:48,340
this no case is like our SD vector we

00:32:45,640 --> 00:32:51,760
look at what is the typical size what is

00:32:48,340 --> 00:32:54,250
what size is big enough for 95% of the

00:32:51,760 --> 00:32:56,800
time then we believe place that by a

00:32:54,250 --> 00:32:58,690
class with all in place area so it's not

00:32:56,800 --> 00:33:01,480
like your STD are a lot more like Annie

00:32:58,690 --> 00:33:03,370
bread between STD IRA STD vector so it

00:33:01,480 --> 00:33:07,270
will use the static buffer if the size

00:33:03,370 --> 00:33:08,830
is in that case 8 or smaller so it will

00:33:07,270 --> 00:33:11,680
use the stack so you also like save a

00:33:08,830 --> 00:33:14,850
lot of CPU everybody's happy and out and

00:33:11,680 --> 00:33:19,210
if it's bigger than it will use they eat

00:33:14,850 --> 00:33:22,480
so unprincipled to do the same changes

00:33:19,210 --> 00:33:25,030
as on Assassin's Creed and they were

00:33:22,480 --> 00:33:27,310
giving good results but when it came to

00:33:25,030 --> 00:33:29,680
memory fragmentation I was still once in

00:33:27,310 --> 00:33:31,810
a while in that case allocating and was

00:33:29,680 --> 00:33:35,860
removing their way to do that more

00:33:31,810 --> 00:33:37,780
thematic and then we found patterns on

00:33:35,860 --> 00:33:40,750
different platforms to know if your

00:33:37,780 --> 00:33:42,400
pointers on the stack on xbox 360 and

00:33:40,750 --> 00:33:43,000
playstation treat was as simple as a

00:33:42,400 --> 00:33:45,730
mask

00:33:43,000 --> 00:33:48,730
it was undocumented but for us that was

00:33:45,730 --> 00:33:51,070
good enough so what we did is that we

00:33:48,730 --> 00:33:53,130
change the area locator to look if the

00:33:51,070 --> 00:33:55,600
disk pointers on the stack and if it is

00:33:53,130 --> 00:33:58,780
we use what we call a frame a locator

00:33:55,600 --> 00:34:01,360
and so it's just a different alligator

00:33:58,780 --> 00:34:04,750
that is asserted the empty at the end of

00:34:01,360 --> 00:34:06,310
every frame since it's empty at the end

00:34:04,750 --> 00:34:07,690
of every frame there's absolutely no

00:34:06,310 --> 00:34:11,649
fermentation with every

00:34:07,690 --> 00:34:13,690
going to that alligator it's really cool

00:34:11,649 --> 00:34:15,730
because this is even working for arrays

00:34:13,690 --> 00:34:20,079
that are members inside objects on the

00:34:15,730 --> 00:34:21,639
stack in doing that change at that time

00:34:20,079 --> 00:34:23,290
on prints our first year it remove all

00:34:21,639 --> 00:34:25,300
the remaining issues and we had a

00:34:23,290 --> 00:34:30,730
fragmentation that played a game for 40

00:34:25,300 --> 00:34:32,770
hours and no such problem when it comes

00:34:30,730 --> 00:34:37,599
to debugging we have our own challenges

00:34:32,770 --> 00:34:41,440
as well we have a huge mullet codebase

00:34:37,599 --> 00:34:43,839
you can imagine same codebase with over

00:34:41,440 --> 00:34:47,050
sometimes 100 programmers working at the

00:34:43,839 --> 00:34:49,329
same time in it as a consequence we have

00:34:47,050 --> 00:34:51,609
bugs that only reproducible in optimized

00:34:49,329 --> 00:34:53,589
targets since you know different tax our

00:34:51,609 --> 00:34:57,430
tasks are running at so much different

00:34:53,589 --> 00:34:59,260
speeds want to avoid recompiling for

00:34:57,430 --> 00:35:02,410
debug options want to debug issues are

00:34:59,260 --> 00:35:04,380
do as they are occurring and the debug

00:35:02,410 --> 00:35:07,720
targets might be fast to be usable

00:35:04,380 --> 00:35:12,690
because a game running at 2 FPS it's no

00:35:07,720 --> 00:35:15,760
more game this is unplayable I'm a

00:35:12,690 --> 00:35:17,410
consequence for the debug targets

00:35:15,760 --> 00:35:19,920
there's a bunch of stuff we disable this

00:35:17,410 --> 00:35:22,510
is all Microsoft stuff on this slide

00:35:19,920 --> 00:35:24,160
debug iterators from STL I said we're

00:35:22,510 --> 00:35:26,890
not using STL but we're using third

00:35:24,160 --> 00:35:29,349
parties using them and using it is using

00:35:26,890 --> 00:35:32,079
our tools as well the visual studio

00:35:29,349 --> 00:35:33,819
debugger heap we disabled we disable

00:35:32,079 --> 00:35:36,460
default windows fault around heap as

00:35:33,819 --> 00:35:37,690
well to the registry the last one is

00:35:36,460 --> 00:35:39,550
something Windows is the way when the

00:35:37,690 --> 00:35:43,420
application is crashing too often we'll

00:35:39,550 --> 00:35:45,220
just assign a different EEP to it but

00:35:43,420 --> 00:35:50,020
prefer to fix the crashes then have

00:35:45,220 --> 00:35:51,280
something run ten times slower and no

00:35:50,020 --> 00:35:53,380
programmers they need to be able to

00:35:51,280 --> 00:35:55,300
debug release code we have a one day

00:35:53,380 --> 00:35:57,160
course that is very popular in Ubisoft

00:35:55,300 --> 00:35:58,690
Montreal where programmers they

00:35:57,160 --> 00:36:00,099
typically learn to get back the

00:35:58,690 --> 00:36:03,010
disappoint through from the code the

00:36:00,099 --> 00:36:05,710
assembly and the registers here we can

00:36:03,010 --> 00:36:07,480
see a screenshot of a visual to your

00:36:05,710 --> 00:36:09,640
extension we have that is adding

00:36:07,480 --> 00:36:11,310
information so that people understand

00:36:09,640 --> 00:36:13,780
code the assembly better as well

00:36:11,310 --> 00:36:18,810
so one give the course but I can at

00:36:13,780 --> 00:36:18,810
least share one tip with resistors so

00:36:18,910 --> 00:36:23,500
on your PC you end up with a call stack

00:36:20,740 --> 00:36:24,520
like this that completely empty if you

00:36:23,500 --> 00:36:27,039
don't know what you do you're pretty

00:36:24,520 --> 00:36:30,849
much screwed because you have no no idea

00:36:27,039 --> 00:36:33,490
what just happened what happened is that

00:36:30,849 --> 00:36:36,130
your striction pointer register is now

00:36:33,490 --> 00:36:37,780
corrupted and what you can do is just

00:36:36,130 --> 00:36:39,819
look at the different registers and

00:36:37,780 --> 00:36:43,450
typically there's one with a value good

00:36:39,819 --> 00:36:45,480
enough to debug and just try them very

00:36:43,450 --> 00:36:48,819
quickly and as you press ENTER you will

00:36:45,480 --> 00:36:55,030
see your call stack resurrect from the

00:36:48,819 --> 00:36:56,890
dead when it comes to memory allocations

00:36:55,030 --> 00:36:58,710
I said we try to avoid them at your

00:36:56,890 --> 00:37:01,329
relative that we're doing a lot of them

00:36:58,710 --> 00:37:04,000
so much that we don't debug them and

00:37:01,329 --> 00:37:06,910
Julie so what we do instead is that we

00:37:04,000 --> 00:37:08,950
use something we call memory tagging so

00:37:06,910 --> 00:37:11,500
every memory allocation we do we pass a

00:37:08,950 --> 00:37:14,200
string that will be used to tag that

00:37:11,500 --> 00:37:15,819
allocation we even pass a parent pointer

00:37:14,200 --> 00:37:18,359
but the parent pointer is not used for

00:37:15,819 --> 00:37:21,549
ownership Allah this is bathing like any

00:37:18,359 --> 00:37:24,400
C++ knew the parent pointer is used to

00:37:21,549 --> 00:37:26,980
make a path with the tags so like Pat's

00:37:24,400 --> 00:37:28,900
on a file system so the reason we work

00:37:26,980 --> 00:37:31,930
that way is that it has a very low

00:37:28,900 --> 00:37:35,170
memory footprint it's not an issue and

00:37:31,930 --> 00:37:37,930
on all gen consoles because we just need

00:37:35,170 --> 00:37:42,039
to keep an adam account for every path

00:37:37,930 --> 00:37:44,020
and that's it so for example on Prince

00:37:42,039 --> 00:37:47,230
of Persia I added a tester playing the

00:37:44,020 --> 00:37:55,299
game for over 20 hours on multiple days

00:37:47,230 --> 00:37:58,329
and and then you will come back at the

00:37:55,299 --> 00:37:58,930
central hub and you will make regularly

00:37:58,329 --> 00:38:01,420
a dump

00:37:58,930 --> 00:38:02,859
a memory dump but then I was really easy

00:38:01,420 --> 00:38:04,720
for me I will just make a difference

00:38:02,859 --> 00:38:07,210
between these dump and see which memory

00:38:04,720 --> 00:38:09,099
tags were leaking then I will break in

00:38:07,210 --> 00:38:11,799
the debugger on these tags and just fix

00:38:09,099 --> 00:38:13,990
the code accordingly the way will break

00:38:11,799 --> 00:38:16,839
inside the code is by using something we

00:38:13,990 --> 00:38:18,730
call the breaks it's very simple it's

00:38:16,839 --> 00:38:20,500
just that a bunch of our singleton and

00:38:18,730 --> 00:38:23,349
managers they have a global object which

00:38:20,500 --> 00:38:25,630
just is just a structure with a bunch of

00:38:23,349 --> 00:38:28,180
values that we can set to trigger

00:38:25,630 --> 00:38:29,890
breakpoints and debugger so they are

00:38:28,180 --> 00:38:32,530
like conditional breakpoints from the

00:38:29,890 --> 00:38:34,860
debugger but with two differences

00:38:32,530 --> 00:38:37,210
to adventages they are much faster

00:38:34,860 --> 00:38:39,520
conscionable a point from the debugger

00:38:37,210 --> 00:38:41,650
if you're running through the code where

00:38:39,520 --> 00:38:44,170
you have put it that will be extremely

00:38:41,650 --> 00:38:47,950
slow but here they are compiled inside

00:38:44,170 --> 00:38:49,870
the code and you can set them you can

00:38:47,950 --> 00:38:51,610
post a label game the debugger and set

00:38:49,870 --> 00:38:54,130
them at write time where you can set

00:38:51,610 --> 00:38:56,560
them at compile time and also they are

00:38:54,130 --> 00:38:58,630
permanent so if a new developer arrives

00:38:56,560 --> 00:39:01,900
on the project we have a master class

00:38:58,630 --> 00:39:04,300
with a memory for all of these breaks

00:39:01,900 --> 00:39:06,450
classes and so can browse to all the

00:39:04,300 --> 00:39:08,710
breaks available inside the engine on

00:39:06,450 --> 00:39:11,350
this screenshot we can even see that we

00:39:08,710 --> 00:39:12,610
have another master class you can even

00:39:11,350 --> 00:39:14,830
actually browse through all the

00:39:12,610 --> 00:39:20,520
singletons for example all the singleton

00:39:14,830 --> 00:39:23,700
story when it comes to memory corruption

00:39:20,520 --> 00:39:25,690
as I said before you can have as much as

00:39:23,700 --> 00:39:28,270
100 programmers working the same

00:39:25,690 --> 00:39:31,120
codebase a lot of people using the same

00:39:28,270 --> 00:39:33,010
eat so you can understand that

00:39:31,120 --> 00:39:35,980
another programmer can make your code

00:39:33,010 --> 00:39:38,320
look bad um so what happened is that

00:39:35,980 --> 00:39:40,620
when we have a memory address where we

00:39:38,320 --> 00:39:43,180
suspect there's been a memory corruption

00:39:40,620 --> 00:39:45,670
we post the bugger and we have a

00:39:43,180 --> 00:39:48,730
function called debug memory we can pass

00:39:45,670 --> 00:39:51,370
that address but what it will do is tell

00:39:48,730 --> 00:39:53,950
you which allocation was done in the

00:39:51,370 --> 00:39:56,020
past close to that address because often

00:39:53,950 --> 00:39:58,440
what happens that someone is writing to

00:39:56,020 --> 00:40:01,300
an object that is actually now deleted

00:39:58,440 --> 00:40:04,150
so this is finding things after the fact

00:40:01,300 --> 00:40:06,940
but often this is good enough well I

00:40:04,150 --> 00:40:08,740
like to do in the future is not even run

00:40:06,940 --> 00:40:10,600
code inside the process but instead add

00:40:08,740 --> 00:40:14,080
visuals to do add-in that is getting a

00:40:10,600 --> 00:40:18,070
memory and then you cast it in c-sharp

00:40:14,080 --> 00:40:22,000
and make the exact same thing so we have

00:40:18,070 --> 00:40:24,490
another approach as well we have an

00:40:22,000 --> 00:40:27,280
alligator that when you allocate it will

00:40:24,490 --> 00:40:28,720
allocate a complete page or allocation

00:40:27,280 --> 00:40:30,850
and put the allocation at the end of the

00:40:28,720 --> 00:40:35,080
page the next page is allocated as

00:40:30,850 --> 00:40:37,930
read-only so that way if you write pass

00:40:35,080 --> 00:40:39,460
an allocation it will break that within

00:40:37,930 --> 00:40:42,460
the lab error it's a class you are

00:40:39,460 --> 00:40:45,170
trying to write inside the read-only

00:40:42,460 --> 00:40:47,089
page and when we do

00:40:45,170 --> 00:40:48,260
the subject will keep the page as we

00:40:47,089 --> 00:40:51,589
only for some time

00:40:48,260 --> 00:40:53,150
so again someone is writing to an object

00:40:51,589 --> 00:40:56,059
that it's been deleted it would break in

00:40:53,150 --> 00:40:57,530
the debugger directly will be a crash so

00:40:56,059 --> 00:40:59,270
this is cool because now we are finding

00:40:57,530 --> 00:41:13,390
the memory corruption exactly as they

00:40:59,270 --> 00:41:13,390
are with the guilty code file oh sorry

00:41:13,720 --> 00:41:21,170
yeah yeah of course we have asserts

00:41:18,710 --> 00:41:23,450
inside the area class but suppose I'm

00:41:21,170 --> 00:41:25,309
just have a pointer to an object I could

00:41:23,450 --> 00:41:34,609
cast it another wrong type and then

00:41:25,309 --> 00:41:39,140
access pass the address oh yeah okay

00:41:34,609 --> 00:41:41,270
that will work as well yeah yeah so and

00:41:39,140 --> 00:41:43,069
but the problem with this is actually

00:41:41,270 --> 00:41:45,200
that's taking a lot of CPU time to

00:41:43,069 --> 00:41:48,500
allocate all these pages so we need to

00:41:45,200 --> 00:41:50,660
use it with specific specific allocation

00:41:48,500 --> 00:41:53,119
and maybe specific size depending on

00:41:50,660 --> 00:41:54,290
what the problem while I was waiting for

00:41:53,119 --> 00:41:57,579
questions at the end but anyway that's

00:41:54,290 --> 00:41:57,579
on the next slide inertia

00:42:00,490 --> 00:42:08,150
not the entire game not the entire game

00:42:04,190 --> 00:42:11,510
no but I think I've done it on an adjust

00:42:08,150 --> 00:42:13,819
dance project but yeah someone tried to

00:42:11,510 --> 00:42:16,819
do it on Assassin's Creed there's no no

00:42:13,819 --> 00:42:19,430
way but if it all was on here a memory

00:42:16,819 --> 00:42:22,849
problem we would not care we say okay we

00:42:19,430 --> 00:42:27,400
have a machine with whatever Ram is

00:42:22,849 --> 00:42:29,280
necessary but now it's more CPU problem

00:42:27,400 --> 00:42:32,410
yeah

00:42:29,280 --> 00:42:33,900
so that's it before the conditioned I

00:42:32,410 --> 00:42:37,030
talk I want to mention the first

00:42:33,900 --> 00:42:39,130
reference link it's a talk from game

00:42:37,030 --> 00:42:41,500
developer conference in 2003 from mr.

00:42:39,130 --> 00:42:44,380
Rickson from Sony if you interested in

00:42:41,500 --> 00:42:46,900
memorization its really resting so

00:42:44,380 --> 00:42:49,319
that's it yes time for some more

00:42:46,900 --> 00:42:49,319
questions

00:42:54,859 --> 00:42:59,309
hi can you tell us briefly a little bit

00:42:57,990 --> 00:43:01,980
about what kind of concurrency

00:42:59,309 --> 00:43:05,240
primitives you guys use is it kind of a

00:43:01,980 --> 00:43:08,220
set number of threads thread pools

00:43:05,240 --> 00:43:11,520
actually the next talk my friend just

00:43:08,220 --> 00:43:16,530
pressing is about bit of that I want to

00:43:11,520 --> 00:43:18,630
spoil him I don't yeah now he's really

00:43:16,530 --> 00:43:20,790
answering that question in one-hour talk

00:43:18,630 --> 00:43:22,440
yeah so you will have your answer in

00:43:20,790 --> 00:43:28,109
like half an hour

00:43:22,440 --> 00:43:29,490
Thanks do you use any other debugger is

00:43:28,109 --> 00:43:31,950
like windbg

00:43:29,490 --> 00:43:35,160
for some of those problematic crash

00:43:31,950 --> 00:43:38,730
cases or do you just use I will use the

00:43:35,160 --> 00:43:41,390
trace the Sony offer and then it's just

00:43:38,730 --> 00:43:41,390
you and that's it

00:43:42,610 --> 00:43:47,410
I wanted to ask if you guys have used if

00:43:45,850 --> 00:43:49,300
use any other memory debugging tools

00:43:47,410 --> 00:43:50,950
such as like address sanitizer or

00:43:49,300 --> 00:43:52,690
anything like this or if this is

00:43:50,950 --> 00:43:56,110
completely infeasible with video games

00:43:52,690 --> 00:44:00,900
uh by me I have not I don't know people

00:43:56,110 --> 00:44:05,980
have try yeah Jen do you have a lot of

00:44:00,900 --> 00:44:13,200
custom solutions all interesting that's

00:44:05,980 --> 00:44:17,230
familiar stuff so to see our curiosity

00:44:13,200 --> 00:44:19,720
feature selection you know we're talking

00:44:17,230 --> 00:44:22,090
about game beside games this size teens

00:44:19,720 --> 00:44:23,950
this size games different types of games

00:44:22,090 --> 00:44:25,570
do you have anything systems for feature

00:44:23,950 --> 00:44:28,210
selection between them anything that's

00:44:25,570 --> 00:44:30,610
actually managed or is it pretty

00:44:28,210 --> 00:44:33,220
monolithic sorry can you repeat the

00:44:30,610 --> 00:44:34,570
question do you have any do you have any

00:44:33,220 --> 00:44:36,100
systems Ubisoft having system for

00:44:34,570 --> 00:44:38,140
feature selection between the games like

00:44:36,100 --> 00:44:39,880
are you cutting out parts oh yeah okay

00:44:38,140 --> 00:44:41,710
yeah yeah so so let me show you man yeah

00:44:39,880 --> 00:44:43,750
sorry so we have a few have

00:44:41,710 --> 00:44:49,770
possibilities of choosing features for a

00:44:43,750 --> 00:44:53,770
game at Ubisoft Montreal is extremely

00:44:49,770 --> 00:44:58,140
organic every project is branching from

00:44:53,770 --> 00:45:01,420
whatever project so it's pure chaos ah

00:44:58,140 --> 00:45:03,700
but it works and that's actually I think

00:45:01,420 --> 00:45:06,910
we are able to be 2000 because we are

00:45:03,700 --> 00:45:10,270
extruding bottom-up we work the same way

00:45:06,910 --> 00:45:14,890
as you know 300 studio in the Sun some

00:45:10,270 --> 00:45:16,810
way but yeah so the IV project is

00:45:14,890 --> 00:45:18,580
branching and then it will just remove

00:45:16,810 --> 00:45:22,150
stuff like crazy that they don't want

00:45:18,580 --> 00:45:24,880
and the sequel needs again you have an

00:45:22,150 --> 00:45:28,930
OC end of something both need to put it

00:45:24,880 --> 00:45:31,060
back so so yeah this so they were

00:45:28,930 --> 00:45:33,220
definitely not for not working in a

00:45:31,060 --> 00:45:36,700
marginal way to remove stuff and add

00:45:33,220 --> 00:45:39,820
stuff it's maybe we maybe it's possible

00:45:36,700 --> 00:45:42,190
but the real life situation is that

00:45:39,820 --> 00:45:44,710
we're not doing that at all it's pure

00:45:42,190 --> 00:45:47,440
branching and very organic natural

00:45:44,710 --> 00:45:49,720
section good ideas that will finally

00:45:47,440 --> 00:45:53,350
come from project what you've seen over

00:45:49,720 --> 00:45:56,080
the years that having people moving from

00:45:53,350 --> 00:45:56,320
project to other projects as newly gets

00:45:56,080 --> 00:45:57,970
more

00:45:56,320 --> 00:45:59,980
other and bigger on this ship it's

00:45:57,970 --> 00:46:02,650
really helping to propagate good IDs

00:45:59,980 --> 00:46:05,650
people with a was using that on watchdog

00:46:02,650 --> 00:46:10,030
and so yeah that's that will say that

00:46:05,650 --> 00:46:11,260
it's very organic that means how much of

00:46:10,030 --> 00:46:13,300
a performance boost you get out of

00:46:11,260 --> 00:46:16,780
having a unity build versus relying on

00:46:13,300 --> 00:46:18,550
link time code generation so yeah how

00:46:16,780 --> 00:46:23,110
much performance we get at runtime from

00:46:18,550 --> 00:46:25,060
unity build I don't know maybe they

00:46:23,110 --> 00:46:26,560
assess the screen one day will have a

00:46:25,060 --> 00:46:29,200
good idea at that time they were

00:46:26,560 --> 00:46:32,500
maintaining both deals on Rainbow six we

00:46:29,200 --> 00:46:34,060
we only compiled without unity bills

00:46:32,500 --> 00:46:37,950
just to make sure they having food we

00:46:34,060 --> 00:46:41,200
don't even link that that target anymore

00:46:37,950 --> 00:46:42,850
so I really don't know but I know it's

00:46:41,200 --> 00:46:45,220
in lying a few more functions since you

00:46:42,850 --> 00:46:47,140
often you have function that are good

00:46:45,220 --> 00:46:54,810
thing candidates with foreign lining in

00:46:47,140 --> 00:47:00,370
CTD files but yeah edited more questions

00:46:54,810 --> 00:47:02,920
thanks for it up sorry your codebase

00:47:00,370 --> 00:47:04,450
predates se plus ax plus 11 standard can

00:47:02,920 --> 00:47:05,890
you talk about what any sequel has

00:47:04,450 --> 00:47:08,980
eleven features that you've added since

00:47:05,890 --> 00:47:09,430
the standard came out yeah by add some

00:47:08,980 --> 00:47:11,590
slides

00:47:09,430 --> 00:47:14,800
yeah box so the question is about c plus

00:47:11,590 --> 00:47:17,320
positive in usage I had some slides at

00:47:14,800 --> 00:47:18,670
first regarding some features we use

00:47:17,320 --> 00:47:20,680
from two plus plus eleven I removed them

00:47:18,670 --> 00:47:25,060
because they were not fitting in any of

00:47:20,680 --> 00:47:26,620
the three sections really far C++ is

00:47:25,060 --> 00:47:28,390
pretty much what the different compilers

00:47:26,620 --> 00:47:31,330
are offering with the new generation of

00:47:28,390 --> 00:47:34,540
consoles it's much better than in the

00:47:31,330 --> 00:47:37,720
past since we Sony made the great move

00:47:34,540 --> 00:47:40,900
up going with clang and then we have the

00:47:37,720 --> 00:47:42,760
Microsoft compiler so the yeah so what

00:47:40,900 --> 00:47:45,760
both are supporting is something we can

00:47:42,760 --> 00:47:47,140
support so then I will look at it and

00:47:45,760 --> 00:47:49,060
then I will sign an email to my team

00:47:47,140 --> 00:47:53,500
saying okay we can use this on this and

00:47:49,060 --> 00:47:56,440
this in these conditions so for example

00:47:53,500 --> 00:47:58,210
I made we're not using the debugger ders

00:47:56,440 --> 00:48:00,790
from Microsoft by I made my own actually

00:47:58,210 --> 00:48:03,340
in our container and so what I did is I

00:48:00,790 --> 00:48:08,380
made a container integrator that is only

00:48:03,340 --> 00:48:09,930
movable so that way I could use the last

00:48:08,380 --> 00:48:14,099
alive one and use it

00:48:09,930 --> 00:48:16,589
hope to make made the can tailor read

00:48:14,099 --> 00:48:18,869
only while the iterator is existing by

00:48:16,589 --> 00:48:21,690
just incrementing an atomic count inside

00:48:18,869 --> 00:48:26,520
the container um so that's an example I

00:48:21,690 --> 00:48:28,290
have between my mind but yeah otherwise

00:48:26,520 --> 00:48:31,349
yeah I cannot think of other features

00:48:28,290 --> 00:48:37,970
but yeah we're using a few features C++

00:48:31,349 --> 00:48:37,970
11 cool thank you for coming

00:48:38,200 --> 00:48:40,260

YouTube URL: https://www.youtube.com/watch?v=qYN6eduU06s


