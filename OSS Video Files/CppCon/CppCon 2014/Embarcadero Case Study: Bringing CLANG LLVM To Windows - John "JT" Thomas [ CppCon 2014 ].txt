Title: Embarcadero Case Study: Bringing CLANG LLVM To Windows - John "JT" Thomas [ CppCon 2014 ]
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
CLANG/LLVM delivers a highly conforming C++ compiler and architecture for targeting multiple CPUs, and, as such, has seen success in iOS and other operating systems. Embarcadero has successfully delivered the first commercial compiler for Windows based on CLANG/LLVM. This session describes the benefits of CLANG/LLVM as well as the challenges in bringing it to the Windows operating system. Particular emphasis is placed on the managing the changes in CLANG as well as the additional features added to enable Windows development.
--
John "JT" Thomas, Director of Product Management at Embarcadero Technologies, has more than 15 years of product management and product development experience including hands-on experience with the early versions of Delphi and C++Builder at Borland Software. Previously, JT held product management positions at mobile Linux vendor MontaVista Software and at Research in Motion. He earned his Computer Science degree from University of California, Santa Cruz and his MBA and MSE from San Jose State University.Website: http://www.embarcadero.comTwitter handle: @FireMonkeyPM
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
--
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,000 --> 00:00:05,430
alright thanks for joining me today for

00:00:02,399 --> 00:00:08,849
this session hey I know you nice to see

00:00:05,430 --> 00:00:11,040
you again friendly face go way back I'm

00:00:08,849 --> 00:00:14,639
JT I'm going to talk to you today about

00:00:11,040 --> 00:00:17,850
our experience at embarcadero of working

00:00:14,639 --> 00:00:20,310
with clang in LOV m and some of the

00:00:17,850 --> 00:00:22,830
challenges and good things that came out

00:00:20,310 --> 00:00:27,029
of using it to bring a window solution

00:00:22,830 --> 00:00:29,039
to bear earlier I Fickell's Tuesday now

00:00:27,029 --> 00:00:31,219
it seems like so long ago lots of great

00:00:29,039 --> 00:00:34,920
sessions I've been having a great time I

00:00:31,219 --> 00:00:36,510
talked a lot about you I prototyping on

00:00:34,920 --> 00:00:37,680
multiple devices this is what we're

00:00:36,510 --> 00:00:39,690
trying to do in a marketer we're trying

00:00:37,680 --> 00:00:42,960
to solve the application developer

00:00:39,690 --> 00:00:45,690
challenge for developers to build

00:00:42,960 --> 00:00:49,020
applications with good performance using

00:00:45,690 --> 00:00:52,620
C++ across multiple platforms trying to

00:00:49,020 --> 00:00:54,750
use a common API not just for standard

00:00:52,620 --> 00:00:58,770
framework things like network services

00:00:54,750 --> 00:01:01,320
or i/o but also for things like data

00:00:58,770 --> 00:01:04,100
access for things like user interface

00:01:01,320 --> 00:01:06,810
some of the things that C++ standard or

00:01:04,100 --> 00:01:09,330
stl or boost for that matter don't

00:01:06,810 --> 00:01:12,510
necessarily provide common services for

00:01:09,330 --> 00:01:14,790
so that's what we're trying to do and a

00:01:12,510 --> 00:01:17,280
big part of that is when what drives the

00:01:14,790 --> 00:01:22,520
engine behind all this is good compilers

00:01:17,280 --> 00:01:24,240
in good language support so a while back

00:01:22,520 --> 00:01:25,320
I'll give you a little bit of a

00:01:24,240 --> 00:01:26,400
background when we get to it here in

00:01:25,320 --> 00:01:28,290
just a moment but what we're going to

00:01:26,400 --> 00:01:30,119
talk about over the next hour I'm going

00:01:28,290 --> 00:01:31,409
to give you the help you understand what

00:01:30,119 --> 00:01:34,860
we were trying to do what were our goals

00:01:31,409 --> 00:01:37,380
first of all in selecting clang llvm is

00:01:34,860 --> 00:01:39,630
the architecture the tolling that we

00:01:37,380 --> 00:01:40,950
wanted to use to achieve these goals and

00:01:39,630 --> 00:01:44,130
then I'll give you an overview of the

00:01:40,950 --> 00:01:46,590
project itself and we'll talk about what

00:01:44,130 --> 00:01:48,390
worked well what didn't work well I'll

00:01:46,590 --> 00:01:51,659
try to be as brutally honest as I can a

00:01:48,390 --> 00:01:53,220
lot of self-reflection went on as I was

00:01:51,659 --> 00:01:56,070
putting this together a lot of good

00:01:53,220 --> 00:01:57,329
input from the team as well and then

00:01:56,070 --> 00:01:59,850
lessons learned and what we want to do

00:01:57,329 --> 00:02:02,610
going forward so I tell you straight out

00:01:59,850 --> 00:02:03,930
that we're very pleased with what we've

00:02:02,610 --> 00:02:05,850
been able to achieve with clang in l a--

00:02:03,930 --> 00:02:06,970
vm and we think it's a wonderful tool

00:02:05,850 --> 00:02:08,350
chain

00:02:06,970 --> 00:02:10,030
the kudos to the team that's been

00:02:08,350 --> 00:02:12,400
working on that and bringing it to the

00:02:10,030 --> 00:02:14,950
you know making it available to people

00:02:12,400 --> 00:02:20,110
like myself teams like us who are

00:02:14,950 --> 00:02:22,900
building application developer tools so

00:02:20,110 --> 00:02:23,860
some of you remind talk just wanted to

00:02:22,900 --> 00:02:25,570
share a little bit about myself I've

00:02:23,860 --> 00:02:30,040
been programming since I was a younger

00:02:25,570 --> 00:02:31,990
young guy parents part home with vic-20

00:02:30,040 --> 00:02:33,190
had to learn how to use basic to do

00:02:31,990 --> 00:02:34,650
something with it and that's kind of

00:02:33,190 --> 00:02:36,910
when I fell in love programming and

00:02:34,650 --> 00:02:38,140
tried to stay with the graphical systems

00:02:36,910 --> 00:02:40,890
until das came out and that's when I

00:02:38,140 --> 00:02:44,290
learned C++ so that was okay my first

00:02:40,890 --> 00:02:47,920
ide was turbo c++ how many I'll set out

00:02:44,290 --> 00:02:49,390
there used turbo C++ yeah so what was

00:02:47,920 --> 00:02:51,280
great about it was it was more than just

00:02:49,390 --> 00:02:53,560
a compiler right you got everything in

00:02:51,280 --> 00:02:56,380
one you were super productive it was all

00:02:53,560 --> 00:02:58,390
about minimizing that edit compiled

00:02:56,380 --> 00:03:00,670
debug cycle you could just write more

00:02:58,390 --> 00:03:03,160
code and man wasn't it nice to have an

00:03:00,670 --> 00:03:05,140
integrated debugger and it fit out a

00:03:03,160 --> 00:03:07,090
floppy in fact i was going to share with

00:03:05,140 --> 00:03:11,709
you that i borrowed my first copy from a

00:03:07,090 --> 00:03:14,050
friend yeah exactly no license checking

00:03:11,709 --> 00:03:16,540
back then i ended up going to school

00:03:14,050 --> 00:03:21,250
UCSC which is University of California

00:03:16,540 --> 00:03:23,290
Santa Cruz I was a Stephenson and it

00:03:21,250 --> 00:03:26,260
didn't really matter but I wanted the

00:03:23,290 --> 00:03:29,019
nice open field for the graduation which

00:03:26,260 --> 00:03:32,739
overlooked Monterey Bay actually didn't

00:03:29,019 --> 00:03:35,769
live on campus but and I studied there

00:03:32,739 --> 00:03:37,330
at a graphics rendering that was my

00:03:35,769 --> 00:03:39,580
thing I mean I did all the compiler

00:03:37,330 --> 00:03:41,650
theory and all that too but it was all

00:03:39,580 --> 00:03:43,540
C++ and all about graphics I really

00:03:41,650 --> 00:03:47,739
wanted to do game development for a

00:03:43,540 --> 00:03:49,600
living and build 3d engines and I also

00:03:47,739 --> 00:03:51,610
learned as I was going to school there

00:03:49,600 --> 00:03:54,070
that Borland happened to be like right

00:03:51,610 --> 00:03:56,170
down the road and I was like I'm

00:03:54,070 --> 00:03:58,810
gonna go work that so that's what I did

00:03:56,170 --> 00:04:01,540
I started in the support ranks and it

00:03:58,810 --> 00:04:03,640
was a incredible place to learn because

00:04:01,540 --> 00:04:05,110
you didn't learn how to code in support

00:04:03,640 --> 00:04:07,690
what you learned how to do is debug

00:04:05,110 --> 00:04:10,450
other people's code and man what a

00:04:07,690 --> 00:04:12,250
valuable asset that turned out to be so

00:04:10,450 --> 00:04:14,380
as i'm coding these days and writing

00:04:12,250 --> 00:04:15,870
bugs a much better figuring out what i'm

00:04:14,380 --> 00:04:18,519
doing wrong

00:04:15,870 --> 00:04:21,090
but over the years spend a lot of you

00:04:18,519 --> 00:04:24,130
know work mostly on the c++ team and

00:04:21,090 --> 00:04:26,620
around 2000 i spent about 10 years of

00:04:24,130 --> 00:04:28,480
portland and left to go work in the

00:04:26,620 --> 00:04:31,060
valley at a bunch of different startups

00:04:28,480 --> 00:04:32,320
doing things like embedded linux worked

00:04:31,060 --> 00:04:34,900
a research in motion for a little while

00:04:32,320 --> 00:04:37,300
and all of this was C C++ programming

00:04:34,900 --> 00:04:40,420
selves right at home about three years

00:04:37,300 --> 00:04:42,460
ago I ran into an old friend who had

00:04:40,420 --> 00:04:44,860
worked on these products at Borland

00:04:42,460 --> 00:04:46,240
turned out embarcadero which how many

00:04:44,860 --> 00:04:48,790
people have heard of embarcadero before

00:04:46,240 --> 00:04:52,930
this week okay few of you wow really

00:04:48,790 --> 00:04:54,730
that many that's surprising embarcadero

00:04:52,930 --> 00:04:56,800
had bought the board would totally

00:04:54,730 --> 00:05:00,340
bought the important Borland developer

00:04:56,800 --> 00:05:02,950
products and he was telling me that they

00:05:00,340 --> 00:05:04,480
had some grand plans and ideas and was

00:05:02,950 --> 00:05:06,040
wanna know if I was interested in

00:05:04,480 --> 00:05:10,000
helping out so three years ago I

00:05:06,040 --> 00:05:11,620
rejoined embarcadero and I'm not doing

00:05:10,000 --> 00:05:14,200
daily development and I'm running the

00:05:11,620 --> 00:05:16,540
business side of it now so it's a little

00:05:14,200 --> 00:05:18,220
bit different view of the world but I do

00:05:16,540 --> 00:05:20,320
like to stick my nose in the meetings

00:05:18,220 --> 00:05:21,490
and see what's going on and help the

00:05:20,320 --> 00:05:23,320
teams to achieve what they're trying to

00:05:21,490 --> 00:05:24,970
achieve three years ago it was when we

00:05:23,320 --> 00:05:27,610
really made the decision to go with

00:05:24,970 --> 00:05:29,919
clang in llvm and since that time we've

00:05:27,610 --> 00:05:33,760
delivered a 64-bit Windows compiler

00:05:29,919 --> 00:05:35,950
toolchain on clang we've delivered a iOS

00:05:33,760 --> 00:05:38,470
tulle train and we delivered an Android

00:05:35,950 --> 00:05:40,600
toolchain and we're actively working on

00:05:38,470 --> 00:05:46,600
32-bit windows and this is taken a lot

00:05:40,600 --> 00:05:48,070
longer than we'd like so going back to

00:05:46,600 --> 00:05:50,979
the game development thing a little bit

00:05:48,070 --> 00:05:52,300
there was this wonderful publication for

00:05:50,979 --> 00:05:54,870
many years called game developer

00:05:52,300 --> 00:05:57,610
magazine anybody here ever hear of it

00:05:54,870 --> 00:05:59,860
awesome so it was pretty much free never

00:05:57,610 --> 00:06:02,470
had to buy it they just keep sending it

00:05:59,860 --> 00:06:04,780
to but you know in addition to some

00:06:02,470 --> 00:06:07,030
really great programming articles they

00:06:04,780 --> 00:06:09,250
had always had this section called the

00:06:07,030 --> 00:06:11,860
post mortem and it was big development

00:06:09,250 --> 00:06:13,810
teams building Triple A games and they

00:06:11,860 --> 00:06:16,479
did they basically were brutally honest

00:06:13,810 --> 00:06:17,890
about what went wrong in the project and

00:06:16,479 --> 00:06:20,440
I was always loved reading those

00:06:17,890 --> 00:06:22,960
articles because you got appreciate that

00:06:20,440 --> 00:06:24,130
people learn from their mistakes but

00:06:22,960 --> 00:06:25,570
they also talked about when we're at

00:06:24,130 --> 00:06:26,890
right and that was really interesting to

00:06:25,570 --> 00:06:28,420
see too because you can learn things

00:06:26,890 --> 00:06:29,890
about how to make these

00:06:28,420 --> 00:06:32,980
how to make very complex software

00:06:29,890 --> 00:06:35,110
because games are very complex and bring

00:06:32,980 --> 00:06:37,210
it to market I mean ultimately their job

00:06:35,110 --> 00:06:40,510
is to ship something or a sub bunch of

00:06:37,210 --> 00:06:42,010
wasted effort so that's my job to my job

00:06:40,510 --> 00:06:43,810
is to help the developer team ship

00:06:42,010 --> 00:06:46,960
something get it to market in time

00:06:43,810 --> 00:06:48,460
market it sell it and keep that those

00:06:46,960 --> 00:06:53,320
funds going so we can continue and

00:06:48,460 --> 00:06:57,040
continue to invest so just a quick throw

00:06:53,320 --> 00:07:00,010
back to turbo C++ the one thing I wanted

00:06:57,040 --> 00:07:02,050
to point out here was that turbo C++ was

00:07:00,010 --> 00:07:03,700
more than just a C++ compiler can you

00:07:02,050 --> 00:07:06,220
guys still hear me i should probably a

00:07:03,700 --> 00:07:08,980
little closer turbo C++ was more than

00:07:06,220 --> 00:07:10,870
just a compiler it was a development

00:07:08,980 --> 00:07:12,340
environment it was a collection actually

00:07:10,870 --> 00:07:14,650
have a lot of tools that you may or may

00:07:12,340 --> 00:07:16,930
not have been aware of a debugger

00:07:14,650 --> 00:07:20,320
profiler and there's a lot going on

00:07:16,930 --> 00:07:21,730
there and that's what we're doing as

00:07:20,320 --> 00:07:24,880
well in embarcadero we're not just

00:07:21,730 --> 00:07:27,280
shipping a compiler we're building

00:07:24,880 --> 00:07:29,110
actually a pretty complex development

00:07:27,280 --> 00:07:31,300
environment trying to solve some very

00:07:29,110 --> 00:07:33,490
modern problems that application

00:07:31,300 --> 00:07:35,920
developers have so the compiler is

00:07:33,490 --> 00:07:37,330
critical of course without it you're

00:07:35,920 --> 00:07:40,570
never going to get an app to run on a

00:07:37,330 --> 00:07:43,330
device or run on a platform but all

00:07:40,570 --> 00:07:45,550
these other pieces are very important to

00:07:43,330 --> 00:07:48,100
delivering a a good developer experience

00:07:45,550 --> 00:07:50,470
and so borland pretty much had invented

00:07:48,100 --> 00:07:52,300
the IDE and from there a lot of

00:07:50,470 --> 00:07:53,830
innovation went into trying to make

00:07:52,300 --> 00:07:55,960
developers more productive whether it

00:07:53,830 --> 00:07:58,960
was in the framework or in the tooling

00:07:55,960 --> 00:08:01,960
or in the language itself this was this

00:07:58,960 --> 00:08:02,980
is what the heritage of the people that

00:08:01,960 --> 00:08:08,580
are working on these tools today

00:08:02,980 --> 00:08:11,110
continued to take forward so Borland

00:08:08,580 --> 00:08:14,370
throughout the years had been a big C++

00:08:11,110 --> 00:08:17,380
company turbo C++ was incredibly popular

00:08:14,370 --> 00:08:19,270
borland c++ did pretty well too until

00:08:17,380 --> 00:08:22,930
visual c++ really just started to take

00:08:19,270 --> 00:08:25,540
off and it was interesting because we

00:08:22,930 --> 00:08:28,330
had competing frameworks so you know

00:08:25,540 --> 00:08:30,190
people are getting framework religion so

00:08:28,330 --> 00:08:34,110
we had oh w ell on the on the borderland

00:08:30,190 --> 00:08:36,640
side we had NFC on the Microsoft side

00:08:34,110 --> 00:08:38,200
but language compliance was always

00:08:36,640 --> 00:08:39,700
something that was important to C++

00:08:38,200 --> 00:08:41,500
developers so if a new standard came out

00:08:39,700 --> 00:08:42,589
hey we got to be able to use these new

00:08:41,500 --> 00:08:45,170
language features

00:08:42,589 --> 00:08:47,459
throughout the years pardon me

00:08:45,170 --> 00:08:51,299
throughout the years Borland had written

00:08:47,459 --> 00:08:53,279
her own C++ toolchain so one of the

00:08:51,299 --> 00:08:54,449
hallmarks of a boiling compiler for

00:08:53,279 --> 00:08:58,049
those of you that remember was that it

00:08:54,449 --> 00:09:01,170
was incredibly fast at building and it

00:08:58,049 --> 00:09:03,269
took a lot of shortcuts to do that so

00:09:01,170 --> 00:09:04,739
for example there was no intermediate

00:09:03,269 --> 00:09:08,009
representation between the front and on

00:09:04,739 --> 00:09:10,829
the back end they had let's call it

00:09:08,009 --> 00:09:12,899
carnal knowledge of one another which

00:09:10,829 --> 00:09:14,850
you know over the years of trying to

00:09:12,899 --> 00:09:18,119
keep up with the standard also made the

00:09:14,850 --> 00:09:22,049
codebase pretty brittle and so that was

00:09:18,119 --> 00:09:23,999
the cost of having a fast compiler was

00:09:22,049 --> 00:09:25,879
that she lost some flexibility and you

00:09:23,999 --> 00:09:30,299
also ended up especially over years

00:09:25,879 --> 00:09:33,569
losing some some of the architectural

00:09:30,299 --> 00:09:37,079
value of separating these aspects of the

00:09:33,569 --> 00:09:38,549
the tool chain but Borland continued

00:09:37,079 --> 00:09:40,679
trudging on trying to address a lot of

00:09:38,549 --> 00:09:43,920
these new features over the years and

00:09:40,679 --> 00:09:45,749
around the code gear time this is

00:09:43,920 --> 00:09:47,730
probably more history than you may be

00:09:45,749 --> 00:09:49,259
aware of code gear was a spin-out from

00:09:47,730 --> 00:09:52,799
borland Borland decided to wanted to be

00:09:49,259 --> 00:09:55,470
an alm company which was like would he

00:09:52,799 --> 00:09:57,360
call him requirements management testing

00:09:55,470 --> 00:10:00,419
all that kind of stuff and so they set

00:09:57,360 --> 00:10:03,809
the tools out on the side which was the

00:10:00,419 --> 00:10:05,669
money-making business unit and and then

00:10:03,809 --> 00:10:07,980
Borland started you know our customers

00:10:05,669 --> 00:10:09,419
being C++ developers also told us hey we

00:10:07,980 --> 00:10:11,339
really appreciate the productivity that

00:10:09,419 --> 00:10:13,199
we get but we need to have good language

00:10:11,339 --> 00:10:15,569
compliance we need to be able to write

00:10:13,199 --> 00:10:17,669
code that allows us to take advantage of

00:10:15,569 --> 00:10:19,679
these great new features we also need to

00:10:17,669 --> 00:10:22,939
be able to write some portable code and

00:10:19,679 --> 00:10:25,499
our compiler was falling behind frankly

00:10:22,939 --> 00:10:27,029
so started looking at different

00:10:25,499 --> 00:10:29,309
front-end zdg was one that the team

00:10:27,029 --> 00:10:31,470
spent some time with was great for an

00:10:29,309 --> 00:10:36,329
end it just didn't quite fit with the

00:10:31,470 --> 00:10:37,799
model so it was abandoned and like I say

00:10:36,329 --> 00:10:41,369
about three years ago when i came to

00:10:37,799 --> 00:10:44,040
embarcadero clang llvm was pretty pretty

00:10:41,369 --> 00:10:47,699
new at least two beyond the apple

00:10:44,040 --> 00:10:50,249
platform and the team convinced me we

00:10:47,699 --> 00:10:53,429
should we should do this it was a great

00:10:50,249 --> 00:10:54,670
decision it think it's exceeded

00:10:53,429 --> 00:10:57,430
everybody's expectations

00:10:54,670 --> 00:10:58,990
in terms of how easy it was to really

00:10:57,430 --> 00:11:01,300
work with although there was a

00:10:58,990 --> 00:11:03,070
tremendous amount of effort in doing the

00:11:01,300 --> 00:11:04,390
things that we do to the language to

00:11:03,070 --> 00:11:06,640
enable the complete development

00:11:04,390 --> 00:11:08,290
environment it was worth it because the

00:11:06,640 --> 00:11:10,270
one thing that we could deliver and be

00:11:08,290 --> 00:11:12,040
sure that we can deliver also was good

00:11:10,270 --> 00:11:14,170
language compliance and something that

00:11:12,040 --> 00:11:17,740
that clan really really delivers on plus

00:11:14,170 --> 00:11:20,040
l OV m is a great backend one of the

00:11:17,740 --> 00:11:22,930
best optimizers out there very clean

00:11:20,040 --> 00:11:27,660
intermediate representation so this has

00:11:22,930 --> 00:11:27,660
been I think a very valuable experience

00:11:27,780 --> 00:11:31,450
so as I mentioned we deliver more than

00:11:30,130 --> 00:11:34,750
just tool chains we actually deliver a

00:11:31,450 --> 00:11:37,180
C++ an object Pascal tool chains overall

00:11:34,750 --> 00:11:41,740
we probably ship about I would say ten

00:11:37,180 --> 00:11:44,260
distinct tool chains maybe more tool

00:11:41,740 --> 00:11:47,320
chain including the front end and the

00:11:44,260 --> 00:11:49,690
back end linkers debuggers assemblers

00:11:47,320 --> 00:11:53,380
all the ancillary toolchain kind of

00:11:49,690 --> 00:11:56,560
stuff but we also build an application

00:11:53,380 --> 00:11:58,630
platform and are again our goal is to

00:11:56,560 --> 00:12:00,490
build cross-platform libraries that ran

00:11:58,630 --> 00:12:02,860
across the main desktop operating

00:12:00,490 --> 00:12:05,920
systems as well as the main mobile

00:12:02,860 --> 00:12:08,560
operating systems since we do two

00:12:05,920 --> 00:12:12,250
languages we also share a common RTL in

00:12:08,560 --> 00:12:13,780
this RTL is something that is shared

00:12:12,250 --> 00:12:15,430
between the object Pascal and c plus

00:12:13,780 --> 00:12:18,670
plus side you can still continue to use

00:12:15,430 --> 00:12:20,320
pure c and c++ RTL but this is an

00:12:18,670 --> 00:12:21,970
additional our tail layer that's

00:12:20,320 --> 00:12:24,850
provided to developers of using this

00:12:21,970 --> 00:12:27,970
product and on top of that sits an

00:12:24,850 --> 00:12:30,430
application framework so that stuff like

00:12:27,970 --> 00:12:33,390
data access collections and containers

00:12:30,430 --> 00:12:35,260
again doesn't mean you can't use C++

00:12:33,390 --> 00:12:38,710
containers and collections of course you

00:12:35,260 --> 00:12:41,310
can this is just another set things like

00:12:38,710 --> 00:12:44,620
talking to cloud services rest in JSON

00:12:41,310 --> 00:12:46,090
middleware user interface which is one

00:12:44,620 --> 00:12:48,520
of the bigger challenges of building

00:12:46,090 --> 00:12:52,450
cross-platform abs today especially with

00:12:48,520 --> 00:12:54,730
C++ so that so that's another I mean our

00:12:52,450 --> 00:12:58,060
team is probably in total about 200

00:12:54,730 --> 00:13:00,610
people and just to put it into context

00:12:58,060 --> 00:13:03,970
about a fifth of those are working on

00:13:00,610 --> 00:13:06,100
C++ compiler so there's a lot of work I

00:13:03,970 --> 00:13:07,660
mean half of those guys r QA too so

00:13:06,100 --> 00:13:08,140
there's a lot of testing and stuff that

00:13:07,660 --> 00:13:10,540
needs to go on

00:13:08,140 --> 00:13:12,790
product this immense i was sitting

00:13:10,540 --> 00:13:14,320
through the the microsoft office talks

00:13:12,790 --> 00:13:16,450
to the last couple days and again that's

00:13:14,320 --> 00:13:18,610
another humongous product i can fully

00:13:16,450 --> 00:13:19,840
appreciate I mean it was great to see

00:13:18,610 --> 00:13:20,860
the architecture but I know it's going

00:13:19,840 --> 00:13:22,000
on behind the scenes it's just a

00:13:20,860 --> 00:13:24,070
tremendous amount of work to bring

00:13:22,000 --> 00:13:25,600
something like that to market especially

00:13:24,070 --> 00:13:28,930
when it's on multiple operating systems

00:13:25,600 --> 00:13:31,870
and then on top of this is a

00:13:28,930 --> 00:13:34,630
full-featured a de code editors building

00:13:31,870 --> 00:13:36,430
project management UI designers changing

00:13:34,630 --> 00:13:39,130
platforms that you have to support and

00:13:36,430 --> 00:13:41,880
your to run on as a host integrated

00:13:39,130 --> 00:13:44,800
debugging so these are all things that

00:13:41,880 --> 00:13:47,590
come together to deliver a product that

00:13:44,800 --> 00:13:50,680
we bring to market so again the

00:13:47,590 --> 00:13:53,050
compilers critical for critical link in

00:13:50,680 --> 00:13:54,610
the solution but it's also just one link

00:13:53,050 --> 00:13:57,460
there's about ten other links that make

00:13:54,610 --> 00:14:00,940
up this total product so with that

00:13:57,460 --> 00:14:05,950
context in mind we needed to definitely

00:14:00,940 --> 00:14:08,920
find a project that we could leverage to

00:14:05,950 --> 00:14:10,030
deliver this fancy compliance that we

00:14:08,920 --> 00:14:13,900
needed and that our customers were

00:14:10,030 --> 00:14:16,890
asking for so that our compiler team

00:14:13,900 --> 00:14:19,930
could also focus on platform enablement

00:14:16,890 --> 00:14:22,360
that's actually extremely costly trying

00:14:19,930 --> 00:14:23,830
to move all this stuff from one platform

00:14:22,360 --> 00:14:26,440
to another to support iOS and Android

00:14:23,830 --> 00:14:29,530
even though there are C++ compilers on

00:14:26,440 --> 00:14:32,200
both for a C++ in runtime environment

00:14:29,530 --> 00:14:34,510
very challenging to get something to

00:14:32,200 --> 00:14:39,820
support all this runtime on each of

00:14:34,510 --> 00:14:42,430
these so this is our vision today you're

00:14:39,820 --> 00:14:47,290
working on one platform with one ide and

00:14:42,430 --> 00:14:49,990
you build one target platform app if

00:14:47,290 --> 00:14:51,400
reach platform that you go to you have

00:14:49,990 --> 00:14:54,490
to do this with different tools and

00:14:51,400 --> 00:14:55,750
different languages in some cases and

00:14:54,490 --> 00:15:00,820
this is what we really want to try to

00:14:55,750 --> 00:15:03,640
push one team one language multiple

00:15:00,820 --> 00:15:05,920
devices multiple platforms that kind of

00:15:03,640 --> 00:15:09,490
sets the stage I think for helping you

00:15:05,920 --> 00:15:11,380
understand what motivated us to do what

00:15:09,490 --> 00:15:14,650
we're doing we also have actually very

00:15:11,380 --> 00:15:17,710
long a very most alluring looking for a

00:15:14,650 --> 00:15:20,710
large but a developer base that goes

00:15:17,710 --> 00:15:21,360
back 15 20 years some cases that have

00:15:20,710 --> 00:15:23,399
kept

00:15:21,360 --> 00:15:25,709
and are still trying to maintain their

00:15:23,399 --> 00:15:28,339
code base as well and we're trying to

00:15:25,709 --> 00:15:31,290
bring forward so there was a lot of a

00:15:28,339 --> 00:15:32,519
lot of conflicting goals in what we were

00:15:31,290 --> 00:15:35,010
trying to do and try to help people

00:15:32,519 --> 00:15:36,480
build a modern application but at the

00:15:35,010 --> 00:15:37,589
same time also help him do it in a way

00:15:36,480 --> 00:15:39,529
where they could leverage a lot of that

00:15:37,589 --> 00:15:41,910
code that they were were using and

00:15:39,529 --> 00:15:44,310
continue to get the advantages of our

00:15:41,910 --> 00:15:46,589
development environment around the

00:15:44,310 --> 00:15:47,730
productivity with the IDE in the

00:15:46,589 --> 00:15:49,380
development environment and user

00:15:47,730 --> 00:15:55,620
interface design and integrated

00:15:49,380 --> 00:15:58,410
debugging and on and on and on we do

00:15:55,620 --> 00:15:59,519
actually yes and that's something that

00:15:58,410 --> 00:16:02,790
we'll be talking about in a little bit

00:15:59,519 --> 00:16:04,079
so that was they don't really because

00:16:02,790 --> 00:16:06,209
they don't think about that often but

00:16:04,079 --> 00:16:07,890
yeah so the question was did we plug in

00:16:06,209 --> 00:16:09,600
our object Pascal friend into llvm yes

00:16:07,890 --> 00:16:11,279
we did I mean I'm going to talk about

00:16:09,600 --> 00:16:12,540
that because that's a great example of

00:16:11,279 --> 00:16:14,430
why Ella vm is such a great project

00:16:12,540 --> 00:16:16,500
really easy for us to take our front-end

00:16:14,430 --> 00:16:19,740
and do that as I mentioned before our

00:16:16,500 --> 00:16:21,390
tool trains were very intimate in terms

00:16:19,740 --> 00:16:22,890
of the front and a back end and we were

00:16:21,390 --> 00:16:25,459
able to separate those and build to that

00:16:22,890 --> 00:16:29,100
I are and it went actually rather fast

00:16:25,459 --> 00:16:33,839
so this is what we're trying to do sorry

00:16:29,100 --> 00:16:35,790
was our question ok so we're trying to

00:16:33,839 --> 00:16:37,709
build let's call it a language engine

00:16:35,790 --> 00:16:38,640
for lack of a better term look at all

00:16:37,709 --> 00:16:39,839
the things we're trying to support

00:16:38,640 --> 00:16:41,430
trying to support many different

00:16:39,839 --> 00:16:44,130
language standards including

00:16:41,430 --> 00:16:46,620
compatibility with borland c++ c++

00:16:44,130 --> 00:16:51,209
builder these are our existing products

00:16:46,620 --> 00:16:54,180
and the standard standard language as

00:16:51,209 --> 00:16:57,420
well so again these are in many cases

00:16:54,180 --> 00:16:59,040
sometimes conflicting goals as well as

00:16:57,420 --> 00:17:00,540
all the standard libraries that people

00:16:59,040 --> 00:17:02,370
use up there not the standard library

00:17:00,540 --> 00:17:04,579
but boost and low key ace those kinds of

00:17:02,370 --> 00:17:06,990
libraries that people do these out there

00:17:04,579 --> 00:17:08,400
our development environment I talked

00:17:06,990 --> 00:17:13,260
about just a little bit during the UI

00:17:08,400 --> 00:17:16,500
prototyping talk encourages a visual

00:17:13,260 --> 00:17:19,530
design and in order to deliver that

00:17:16,500 --> 00:17:23,309
there's actually extensions we made to

00:17:19,530 --> 00:17:26,100
C++ many eons ago because C++ didn't

00:17:23,309 --> 00:17:29,750
have the facilities at the time things

00:17:26,100 --> 00:17:33,080
like taking public members and

00:17:29,750 --> 00:17:36,680
making them publishable to the design

00:17:33,080 --> 00:17:40,670
surface so we created a new container

00:17:36,680 --> 00:17:43,550
class called published and a property

00:17:40,670 --> 00:17:45,020
was basically a public member that had

00:17:43,550 --> 00:17:46,490
getters and setters for reading and

00:17:45,020 --> 00:17:51,530
writing these values inside this object

00:17:46,490 --> 00:17:53,860
inspector in fact it was a 2002 we

00:17:51,530 --> 00:17:56,390
brought a paper to the committee

00:17:53,860 --> 00:17:58,280
suggesting some of these additions to

00:17:56,390 --> 00:17:59,990
the language and I remember the

00:17:58,280 --> 00:18:01,100
committee wasn't keen on it because they

00:17:59,990 --> 00:18:05,060
said who's going to write user

00:18:01,100 --> 00:18:07,970
interfaces in C++ well that was 14 what

00:18:05,060 --> 00:18:09,920
14 years ago now so of course the world

00:18:07,970 --> 00:18:12,320
has changed we still think it's really a

00:18:09,920 --> 00:18:13,970
great way to write not just any half but

00:18:12,320 --> 00:18:15,500
also client-side applications which are

00:18:13,970 --> 00:18:18,680
heavy on user interface and so we

00:18:15,500 --> 00:18:20,630
continued on with our extensions there's

00:18:18,680 --> 00:18:23,360
actually not that many extensions was

00:18:20,630 --> 00:18:26,570
like four or five but they do a lot and

00:18:23,360 --> 00:18:29,570
this is what the first part of moving to

00:18:26,570 --> 00:18:31,730
clang really was about it was about

00:18:29,570 --> 00:18:35,780
writing these extensions that did things

00:18:31,730 --> 00:18:37,130
like allow classes or class definitions

00:18:35,780 --> 00:18:40,660
to include published members with

00:18:37,130 --> 00:18:45,170
properties also to do things like

00:18:40,660 --> 00:18:46,460
generate rich rtti and when I say

00:18:45,170 --> 00:18:49,010
recharge it's got me more than just

00:18:46,460 --> 00:18:52,490
being able to cast and be told if it's a

00:18:49,010 --> 00:18:54,560
bad cast but just go well I try not to

00:18:52,490 --> 00:18:56,780
use an explicit of a lot of information

00:18:54,560 --> 00:18:59,480
about that object so that it can be

00:18:56,780 --> 00:19:01,070
dynamically invoked dynamically queried

00:18:59,480 --> 00:19:05,720
about what it can do a lot of the

00:19:01,070 --> 00:19:12,710
framework utilizes this rtti so that was

00:19:05,720 --> 00:19:17,000
a lot of effort in fact it took about it

00:19:12,710 --> 00:19:20,210
was a good two years in total effort to

00:19:17,000 --> 00:19:23,060
get all of our extensions and work into

00:19:20,210 --> 00:19:25,070
clang in the first place and again it's

00:19:23,060 --> 00:19:27,530
not a lot of extensions from the

00:19:25,070 --> 00:19:29,240
perspective of the developer who writes

00:19:27,530 --> 00:19:31,400
double under of our property for example

00:19:29,240 --> 00:19:34,550
was all the work that went into trying

00:19:31,400 --> 00:19:36,590
to get it to fit in to clang and Clank

00:19:34,550 --> 00:19:38,660
for for its sake was actually pretty

00:19:36,590 --> 00:19:40,320
easy to get to get it into it's just

00:19:38,660 --> 00:19:41,909
that this was a lot of

00:19:40,320 --> 00:19:44,639
code in the background that did a lot of

00:19:41,909 --> 00:19:46,139
things the real you know one of the real

00:19:44,639 --> 00:19:47,789
goals for us of course was to be able to

00:19:46,139 --> 00:19:49,830
generate arm code as well we knew we

00:19:47,789 --> 00:19:54,750
wanted to get to mobile and arm was the

00:19:49,830 --> 00:19:57,799
platform so this really led us to look

00:19:54,750 --> 00:20:00,149
at many choices but clang llvm was the I

00:19:57,799 --> 00:20:02,309
think it was the obvious choice after

00:20:00,149 --> 00:20:03,990
looking at the pros and cons of various

00:20:02,309 --> 00:20:05,730
approaches we certainly could have tried

00:20:03,990 --> 00:20:07,500
to continue to build our compiler out

00:20:05,730 --> 00:20:09,450
and we could have gotten it's a lot of

00:20:07,500 --> 00:20:10,740
this something would have suffered

00:20:09,450 --> 00:20:11,880
though and probably would have been

00:20:10,740 --> 00:20:14,490
language compliance which would have

00:20:11,880 --> 00:20:16,559
been really sad I did not want that I

00:20:14,490 --> 00:20:18,360
wanted to deliver the highest levels of

00:20:16,559 --> 00:20:22,500
language compliance and the benefits of

00:20:18,360 --> 00:20:28,620
the tooling as well so there's the

00:20:22,500 --> 00:20:31,139
background so our goals in bringing

00:20:28,620 --> 00:20:33,840
clang and ella vm or adopting it was

00:20:31,139 --> 00:20:39,360
first to deliver a 64-bit windows

00:20:33,840 --> 00:20:41,669
toolchain so at the time clang was not

00:20:39,360 --> 00:20:44,639
thinking about windows at all or

00:20:41,669 --> 00:20:46,340
climbing or relevant projects and this

00:20:44,639 --> 00:20:50,009
is something we decided to try to tackle

00:20:46,340 --> 00:20:52,769
was a couple reasons for this one is it

00:20:50,009 --> 00:20:56,429
was highly requested from our developer

00:20:52,769 --> 00:20:58,200
base to build 64-bit apps they were

00:20:56,429 --> 00:21:00,000
missing out on that they were but we

00:20:58,200 --> 00:21:03,269
were behind frankly and delivering that

00:21:00,000 --> 00:21:06,179
kind of support the other reason was

00:21:03,269 --> 00:21:08,779
that there was a lot less complexity and

00:21:06,179 --> 00:21:11,100
going to 64-bit and 32-bit 64-bit

00:21:08,779 --> 00:21:13,679
basically had a pretty straightforward

00:21:11,100 --> 00:21:16,559
standard in the sense of Kali

00:21:13,679 --> 00:21:17,610
conventions in object formats and kinds

00:21:16,559 --> 00:21:19,919
of things that you don't think about

00:21:17,610 --> 00:21:21,690
with the toolchain but will kill a

00:21:19,919 --> 00:21:23,700
project when you're trying to support

00:21:21,690 --> 00:21:27,080
all these things and we're going through

00:21:23,700 --> 00:21:29,610
this right now with 32-bit so this was a

00:21:27,080 --> 00:21:33,809
really good test bed for us to see if we

00:21:29,610 --> 00:21:36,929
can do this and make it work as I

00:21:33,809 --> 00:21:40,740
mentioned one of the key goals was to

00:21:36,929 --> 00:21:42,360
have to deliver C++ 11 and have a high

00:21:40,740 --> 00:21:45,120
level of language and library compliance

00:21:42,360 --> 00:21:47,669
so that was a critical must have feature

00:21:45,120 --> 00:21:51,990
in addition to generating 64 bit

00:21:47,669 --> 00:21:54,269
binaries on top of that we needed to

00:21:51,990 --> 00:21:56,789
support our frameworks and that meant

00:21:54,269 --> 00:21:59,279
these common ap is in existing

00:21:56,789 --> 00:22:03,629
frameworks with existing conventions and

00:21:59,279 --> 00:22:06,480
language usage based on 15 year old C++

00:22:03,629 --> 00:22:09,600
technology and bring those guys forward

00:22:06,480 --> 00:22:12,600
as well and lastly we needed something

00:22:09,600 --> 00:22:15,960
that gave us a flexible architecture to

00:22:12,600 --> 00:22:19,110
at least support various Intel platforms

00:22:15,960 --> 00:22:22,740
which included 32-bit 64-bit but also

00:22:19,110 --> 00:22:24,539
arm platforms so we knew that right

00:22:22,740 --> 00:22:27,480
after finishing 64-bit we were going to

00:22:24,539 --> 00:22:29,100
jump on to two arm platforms and try to

00:22:27,480 --> 00:22:30,450
build an iOS version and try to build an

00:22:29,100 --> 00:22:32,399
android version as quickly as we could

00:22:30,450 --> 00:22:35,570
because we felt like we were behind

00:22:32,399 --> 00:22:37,710
there was already in the mobile space

00:22:35,570 --> 00:22:39,750
kind of an interesting thing going on at

00:22:37,710 --> 00:22:42,200
the time at the time there was a lot of

00:22:39,750 --> 00:22:44,100
apps being built with web technologies

00:22:42,200 --> 00:22:45,510
everybody was saying we got to get

00:22:44,100 --> 00:22:47,100
mobile apps we got to do it as quickly

00:22:45,510 --> 00:22:49,559
as possible we can't build a separate

00:22:47,100 --> 00:22:51,299
app using objective seen a separate app

00:22:49,559 --> 00:22:54,570
using Java so we're going to build using

00:22:51,299 --> 00:22:56,220
HTML in JavaScript and almost everybody

00:22:54,570 --> 00:22:59,250
did this especially from the enterprise

00:22:56,220 --> 00:23:00,510
side and they actually were able to

00:22:59,250 --> 00:23:02,480
deliver applications they're pretty

00:23:00,510 --> 00:23:04,169
simple applications for the most part

00:23:02,480 --> 00:23:06,389
but they were able to deliver

00:23:04,169 --> 00:23:07,679
applications and so that's what we were

00:23:06,389 --> 00:23:09,629
kind of fighting against people didn't

00:23:07,679 --> 00:23:11,820
believe it at the time and the value of

00:23:09,629 --> 00:23:15,090
native now a couple things have happened

00:23:11,820 --> 00:23:17,279
since then one when they started

00:23:15,090 --> 00:23:19,440
delivering apps this way users stopped

00:23:17,279 --> 00:23:20,580
using them because the user expectation

00:23:19,440 --> 00:23:24,690
on a mobile device was a lot different

00:23:20,580 --> 00:23:28,379
than in a browser and the the latency

00:23:24,690 --> 00:23:29,940
exposed by a JavaScript runtime was too

00:23:28,379 --> 00:23:32,460
much for the typical end-user they could

00:23:29,940 --> 00:23:34,619
tell how many people are familiar with

00:23:32,460 --> 00:23:36,240
Facebook's experience and trying to do

00:23:34,619 --> 00:23:38,369
this a few of you it's a pretty famous

00:23:36,240 --> 00:23:39,899
story I mean these guys are the web

00:23:38,369 --> 00:23:42,110
developers in the world they no html5

00:23:39,899 --> 00:23:44,399
they know JavaScript better than anybody

00:23:42,110 --> 00:23:45,990
they I would think we would all agree

00:23:44,399 --> 00:23:49,049
that they write one of the most complex

00:23:45,990 --> 00:23:50,519
web apps there is and they try to take

00:23:49,049 --> 00:23:52,980
that exact same source code and bring it

00:23:50,519 --> 00:23:59,059
to mobile and they got an app running on

00:23:52,980 --> 00:23:59,059
mobile but guess what nobody used it it

00:23:59,530 --> 00:24:07,670
everybody wanted to use it but yeah it

00:24:02,270 --> 00:24:08,990
it suffered well I went to a talk at

00:24:07,670 --> 00:24:10,520
Facebook with the project manager and

00:24:08,990 --> 00:24:12,350
she basically said their stats showed it

00:24:10,520 --> 00:24:14,330
people adopted it and then quickly

00:24:12,350 --> 00:24:16,460
stopped using it and they said this is

00:24:14,330 --> 00:24:19,190
not going to work they rewrote their

00:24:16,460 --> 00:24:21,290
apps using it objective-c and Android

00:24:19,190 --> 00:24:22,940
and it was kind of a new wave of people

00:24:21,290 --> 00:24:26,260
starting to appreciate the value of

00:24:22,940 --> 00:24:28,370
native applications again unfortunately

00:24:26,260 --> 00:24:31,100
also during that time the term native

00:24:28,370 --> 00:24:34,340
got kind of overused in fact people

00:24:31,100 --> 00:24:35,930
writing frameworks for web based

00:24:34,340 --> 00:24:37,340
languages started calling their apps

00:24:35,930 --> 00:24:40,040
native because you could package it and

00:24:37,340 --> 00:24:42,110
sell it through an app store so we're

00:24:40,040 --> 00:24:44,030
kind of dealing with that too ultimately

00:24:42,110 --> 00:24:46,930
that's our biggest competition in terms

00:24:44,030 --> 00:24:51,440
of language adoption and usage in mobile

00:24:46,930 --> 00:24:52,940
there's some people that do a platform I

00:24:51,440 --> 00:24:57,050
would call platform as opposed to native

00:24:52,940 --> 00:25:02,360
using dalvik and java using objective c

00:24:57,050 --> 00:25:04,520
or now swift and and cocoa there are and

00:25:02,360 --> 00:25:06,500
then there's everybody else who's using

00:25:04,520 --> 00:25:08,870
web and again more and more people are

00:25:06,500 --> 00:25:12,890
trying to use platform or native

00:25:08,870 --> 00:25:15,260
solutions to get better performance so

00:25:12,890 --> 00:25:18,050
this is what we went into a a couple

00:25:15,260 --> 00:25:20,120
years ago trying to solve and thinking

00:25:18,050 --> 00:25:22,310
if we could solve this we may be able to

00:25:20,120 --> 00:25:24,380
deliver a platform that could deliver

00:25:22,310 --> 00:25:26,000
the best of both worlds there's this

00:25:24,380 --> 00:25:27,470
business benefit of having a shared

00:25:26,000 --> 00:25:30,350
source code base that something like

00:25:27,470 --> 00:25:34,300
html5 and JavaScript can deliver on but

00:25:30,350 --> 00:25:36,920
the the things you had to give up

00:25:34,300 --> 00:25:40,880
performance in particular device access

00:25:36,920 --> 00:25:43,250
was was really hurting developers versus

00:25:40,880 --> 00:25:45,470
the expensive proposition of having to

00:25:43,250 --> 00:25:47,150
build in a bunch of different code bases

00:25:45,470 --> 00:25:48,860
for each platform so this is really what

00:25:47,150 --> 00:25:55,250
we've been trying to achieve and we're

00:25:48,860 --> 00:25:56,480
finally there so specifically for this

00:25:55,250 --> 00:26:01,180
case study we're going to talk about

00:25:56,480 --> 00:26:01,180
delivering a 64-bit windows toolchain

00:26:04,220 --> 00:26:08,150
again we wanted to make sure we could

00:26:06,650 --> 00:26:10,039
deliver a high level c plus plus 11

00:26:08,150 --> 00:26:11,840
compliance ultimately the number one

00:26:10,039 --> 00:26:15,320
goal is that our developer based could

00:26:11,840 --> 00:26:18,260
build 64 bit binaries but there were

00:26:15,320 --> 00:26:20,450
other must-haves language compliance was

00:26:18,260 --> 00:26:23,809
one of those we wanted to have the best

00:26:20,450 --> 00:26:25,220
optimizer possible we wanted to have

00:26:23,809 --> 00:26:27,620
compatibility with our existing

00:26:25,220 --> 00:26:30,860
frameworks and design methodologies and

00:26:27,620 --> 00:26:34,730
approaches we have a lot of unique

00:26:30,860 --> 00:26:35,900
features in our product something you

00:26:34,730 --> 00:26:37,970
may not have heard of a fee a reason to

00:26:35,900 --> 00:26:40,610
call packages packages are basically

00:26:37,970 --> 00:26:43,309
shared libraries that do a little extra

00:26:40,610 --> 00:26:45,860
work so that you can manage objects in

00:26:43,309 --> 00:26:48,590
shared libraries much easier that's the

00:26:45,860 --> 00:26:50,870
simplest way to describe it but it's

00:26:48,590 --> 00:26:53,539
more than just your typical dll or s oh

00:26:50,870 --> 00:26:56,510
and it turned out to be one of the big

00:26:53,539 --> 00:26:58,970
things that hit us when trying to move

00:26:56,510 --> 00:27:01,340
to llvm because lv just didn't have this

00:26:58,970 --> 00:27:03,830
kind of support at all so these are the

00:27:01,340 --> 00:27:05,390
kinds of things that we're working on as

00:27:03,830 --> 00:27:08,960
we support these things and we also

00:27:05,390 --> 00:27:11,120
needed a a good debugger I think we can

00:27:08,960 --> 00:27:13,190
all agree we write bugs we need to be

00:27:11,120 --> 00:27:18,020
able to debug them so debuggers are

00:27:13,190 --> 00:27:22,100
critical I'm about you but it's a lot

00:27:18,020 --> 00:27:25,700
harder to do see out or CR to an android

00:27:22,100 --> 00:27:27,440
phone than you might imagine okay so

00:27:25,700 --> 00:27:30,200
let's get into the meat of the case

00:27:27,440 --> 00:27:34,610
study we'll talk about what went well

00:27:30,200 --> 00:27:35,720
first and i hope i do justice to the

00:27:34,610 --> 00:27:37,460
development team who couldn't be here

00:27:35,720 --> 00:27:40,520
they're busy trying to get our 32-bit

00:27:37,460 --> 00:27:41,600
compiler out they've certainly we've had

00:27:40,520 --> 00:27:44,690
a lot of meetings on this they've

00:27:41,600 --> 00:27:49,900
expressed a lot of opinions some louder

00:27:44,690 --> 00:27:53,179
than others very passionate group and so

00:27:49,900 --> 00:27:54,860
you know like most developers they

00:27:53,179 --> 00:27:56,419
always I don't want to classify

00:27:54,860 --> 00:27:57,799
everybody but they like to focus on well

00:27:56,419 --> 00:27:59,890
weren't wrong sometimes more than that

00:27:57,799 --> 00:28:02,120
went well so this took a little teasing

00:27:59,890 --> 00:28:03,500
but a lot of things went really well one

00:28:02,120 --> 00:28:05,840
we have a product on the market that

00:28:03,500 --> 00:28:09,549
delivers on all these goals and I think

00:28:05,840 --> 00:28:11,929
that's a big win so we'll start there

00:28:09,549 --> 00:28:15,590
the first thing that the team noticed

00:28:11,929 --> 00:28:17,270
that it was clanging lov em and I'll use

00:28:15,590 --> 00:28:17,590
those terms together even though we know

00:28:17,270 --> 00:28:20,779
there's

00:28:17,590 --> 00:28:24,320
projects are very have a very clean

00:28:20,779 --> 00:28:26,539
architecture you know there was concern

00:28:24,320 --> 00:28:27,919
about using a separate front end and

00:28:26,539 --> 00:28:32,389
back end because we knew there would be

00:28:27,919 --> 00:28:34,399
a compile-time effects but it was a

00:28:32,389 --> 00:28:37,909
godsend really because it made our work

00:28:34,399 --> 00:28:41,809
much much easier much cleaner really

00:28:37,909 --> 00:28:42,859
extensible front end all the component

00:28:41,809 --> 00:28:46,399
parts of a front end were well

00:28:42,859 --> 00:28:49,369
documented and well architected it was

00:28:46,399 --> 00:28:51,109
easy for us to add you know key words

00:28:49,369 --> 00:28:53,419
exactly for example to the scanner and

00:28:51,109 --> 00:28:56,570
that kind of thing and to extend the

00:28:53,419 --> 00:28:58,789
parser with our semantic information it

00:28:56,570 --> 00:29:01,220
was well documented fairly well

00:28:58,789 --> 00:29:03,019
documented is how the team put it it is

00:29:01,220 --> 00:29:05,359
an open source project we all know how

00:29:03,019 --> 00:29:07,220
to use the source Luke but this actually

00:29:05,359 --> 00:29:08,419
had good comments and documentation to

00:29:07,220 --> 00:29:12,950
go along with it as well which is

00:29:08,419 --> 00:29:14,809
helpful the intermediate representation

00:29:12,950 --> 00:29:17,330
yeah that was actually something that we

00:29:14,809 --> 00:29:20,690
felt was very well how many repeat

00:29:17,330 --> 00:29:22,549
question oh thank you that's awesome the

00:29:20,690 --> 00:29:23,989
question was what do I mean by IR that's

00:29:22,549 --> 00:29:25,970
the intermediate representation so

00:29:23,989 --> 00:29:27,679
classical compiler theory front-end

00:29:25,970 --> 00:29:30,619
spits out intermediate representation

00:29:27,679 --> 00:29:35,059
back and reach that and generates CPU

00:29:30,619 --> 00:29:37,099
code and 30 minutes left okay great and

00:29:35,059 --> 00:29:39,109
so you asked a question earlier now

00:29:37,099 --> 00:29:40,999
repeat that question too did we take our

00:29:39,109 --> 00:29:43,070
object Pascal compiler and go to lv m

00:29:40,999 --> 00:29:45,799
and the answer was yes once we

00:29:43,070 --> 00:29:47,720
discovered how well this project was

00:29:45,799 --> 00:29:50,779
architected how well we could understand

00:29:47,720 --> 00:29:52,970
it and work with it we decided to build

00:29:50,779 --> 00:29:55,159
we were already building an arm back end

00:29:52,970 --> 00:29:58,489
by the way I mean pretty far down the

00:29:55,159 --> 00:30:01,129
line with it we decided to try to bolt

00:29:58,489 --> 00:30:05,779
our friend in on tail of em and it was

00:30:01,129 --> 00:30:09,080
surprisingly easy of course this all

00:30:05,779 --> 00:30:10,849
relevant but it took us I'd say a few

00:30:09,080 --> 00:30:13,609
months to get it basically up and

00:30:10,849 --> 00:30:15,799
running and things were working I'd say

00:30:13,609 --> 00:30:17,179
that was pretty impressive because the

00:30:15,799 --> 00:30:19,090
back end we were working on was already

00:30:17,179 --> 00:30:21,259
you're into it wasn't quite there yet

00:30:19,090 --> 00:30:23,210
and the hard part was still coming up

00:30:21,259 --> 00:30:24,950
writing a good you know good optimizers

00:30:23,210 --> 00:30:26,240
per arm ella vm already had a good

00:30:24,950 --> 00:30:30,830
optimizer

00:30:26,240 --> 00:30:32,870
so that was a big win and and it was

00:30:30,830 --> 00:30:35,690
actually a small team that moved that

00:30:32,870 --> 00:30:37,910
object Pascal front end to llvm so

00:30:35,690 --> 00:30:39,380
that's just a testament to how well this

00:30:37,910 --> 00:30:41,120
project has been designed and

00:30:39,380 --> 00:30:47,960
architected and supported by the

00:30:41,120 --> 00:30:51,320
community the second win was we needed

00:30:47,960 --> 00:30:54,110
to support dinkum where I dinkum where

00:30:51,320 --> 00:30:55,429
is our stl we've been actually we've

00:30:54,110 --> 00:30:57,020
gone through lots of STL's over the

00:30:55,429 --> 00:30:58,340
years how many people remember rug way

00:30:57,020 --> 00:31:03,160
if that was one of the first ones we

00:30:58,340 --> 00:31:05,120
supported way back when fist knows and

00:31:03,160 --> 00:31:06,320
several years ago we went to dinkum

00:31:05,120 --> 00:31:08,809
where because they just write a really

00:31:06,320 --> 00:31:10,610
good stl especially for windows problem

00:31:08,809 --> 00:31:12,800
is they never really supported our

00:31:10,610 --> 00:31:14,390
compiler very well because we weren't a

00:31:12,800 --> 00:31:19,190
market leader compared to visual studio

00:31:14,390 --> 00:31:21,860
at the time and also GCC which is pretty

00:31:19,190 --> 00:31:23,360
much the de facto or had been the de

00:31:21,860 --> 00:31:27,140
facto I think clanging lvm has quickly

00:31:23,360 --> 00:31:29,900
overtaken it so we based a port on the

00:31:27,140 --> 00:31:32,800
GCC branch one of the things that really

00:31:29,900 --> 00:31:35,390
went well there was that clang had a

00:31:32,800 --> 00:31:38,660
really great switch compatibility with

00:31:35,390 --> 00:31:41,920
GCC made it pretty easy to start working

00:31:38,660 --> 00:31:41,920
with it and getting up and running and

00:31:44,470 --> 00:31:47,300
the question was why didn't we switched

00:31:46,309 --> 00:31:50,540
to the clang guest hill because it

00:31:47,300 --> 00:31:52,429
didn't exist on windows at the time we

00:31:50,540 --> 00:31:54,380
could have yeah but we had a license

00:31:52,429 --> 00:31:56,240
with the with dinkum wearin plogger and

00:31:54,380 --> 00:32:00,679
he was interested in making this work

00:31:56,240 --> 00:32:02,150
too we also again one of our goals was

00:32:00,679 --> 00:32:03,890
to help people with existing code move

00:32:02,150 --> 00:32:06,020
forward as well and his tales can have

00:32:03,890 --> 00:32:07,790
different support they were already

00:32:06,020 --> 00:32:11,120
working with dinkum our stl we wanted to

00:32:07,790 --> 00:32:13,220
support them on the same stl of course

00:32:11,120 --> 00:32:14,929
it looks like the clang stl it's coming

00:32:13,220 --> 00:32:17,360
along very nicely to this something we

00:32:14,929 --> 00:32:18,410
can consider for a future and I'll talk

00:32:17,360 --> 00:32:21,740
about that actually in a moment that's

00:32:18,410 --> 00:32:24,590
something that is I think was a little

00:32:21,740 --> 00:32:27,020
challenging for us actually back porting

00:32:24,590 --> 00:32:29,809
was something that we did quite a bit of

00:32:27,020 --> 00:32:31,730
actually since we had to do a production

00:32:29,809 --> 00:32:35,990
tool chain that had a lot of other

00:32:31,730 --> 00:32:39,610
dependencies we needed to settle on a

00:32:35,990 --> 00:32:41,779
version and at the time I was 3.1

00:32:39,610 --> 00:32:44,090
and there was a lots of features that we

00:32:41,779 --> 00:32:46,850
needed or desired that weren't available

00:32:44,090 --> 00:32:49,820
in 3.1 sometimes there were features

00:32:46,850 --> 00:32:54,710
that were in klang but not in lov n that

00:32:49,820 --> 00:32:57,009
we needed to support the platform so we

00:32:54,710 --> 00:32:59,840
started doing some back porting in

00:32:57,009 --> 00:33:03,110
picking pieces out of a non release

00:32:59,840 --> 00:33:06,350
builds to bring back a one example is

00:33:03,110 --> 00:33:08,059
when we went to Android the 3.1 version

00:33:06,350 --> 00:33:10,940
of ella vm didn't support exception

00:33:08,059 --> 00:33:13,399
handling at all there were some stubs

00:33:10,940 --> 00:33:15,879
there but it didn't it actually didn't

00:33:13,399 --> 00:33:18,830
unwind or do anything so we needed to

00:33:15,879 --> 00:33:22,450
backport that from a more recent version

00:33:18,830 --> 00:33:24,769
of llvm and that worked out pretty well

00:33:22,450 --> 00:33:26,119
so that was something that's been great

00:33:24,769 --> 00:33:28,879
about this project being open source

00:33:26,119 --> 00:33:31,190
being able to see what's there being

00:33:28,879 --> 00:33:33,639
able to have access to two versions out

00:33:31,190 --> 00:33:37,549
of further out for back porting as

00:33:33,639 --> 00:33:39,859
needed here's one that may seem like a

00:33:37,549 --> 00:33:40,659
really odd one to you guys but it was

00:33:39,859 --> 00:33:44,149
something that ended up being

00:33:40,659 --> 00:33:47,600
interesting for us and actually turned

00:33:44,149 --> 00:33:49,690
out to be a nice surprise in our

00:33:47,600 --> 00:33:51,499
framework we decided to support

00:33:49,690 --> 00:33:53,809
reference automatic reference counting

00:33:51,499 --> 00:33:57,249
in the framework and mobile and this is

00:33:53,809 --> 00:33:59,539
mostly for the object Pascal guys

00:33:57,249 --> 00:34:03,379
because they were asking for this memory

00:33:59,539 --> 00:34:05,539
management help and of course we didn't

00:34:03,379 --> 00:34:07,730
want to do a garbage collector so we

00:34:05,539 --> 00:34:12,530
started looking at arc as the as a good

00:34:07,730 --> 00:34:14,000
approach to do this we went through a

00:34:12,530 --> 00:34:15,530
lot of ideas on how to be this of course

00:34:14,000 --> 00:34:19,639
you can do automatic reference counting

00:34:15,530 --> 00:34:24,139
in C++ with just you know smart pointers

00:34:19,639 --> 00:34:26,059
and good practices but it also would

00:34:24,139 --> 00:34:28,369
mean that code would have to change in

00:34:26,059 --> 00:34:31,069
terms of brick helping developers bring

00:34:28,369 --> 00:34:32,629
an existing code over today in their

00:34:31,069 --> 00:34:34,369
class definition they would point to a

00:34:32,629 --> 00:34:37,159
pointer or they would have a pointer to

00:34:34,369 --> 00:34:40,579
an object in the framework so if we were

00:34:37,159 --> 00:34:41,750
to use a more standard C++ approach we

00:34:40,579 --> 00:34:42,889
would ask them we would have to ask them

00:34:41,750 --> 00:34:46,490
to change all their code either in the

00:34:42,889 --> 00:34:51,319
declaration by wrapping it in a smart

00:34:46,490 --> 00:34:52,580
pointer or in the implementation by how

00:34:51,319 --> 00:34:55,430
they access that point

00:34:52,580 --> 00:34:57,760
after they've implemented it and so we

00:34:55,430 --> 00:35:01,310
started poking around a little bit and

00:34:57,760 --> 00:35:03,710
someone had remembered that objective c

00:35:01,310 --> 00:35:06,500
had implemented some arc and then of

00:35:03,710 --> 00:35:08,150
course he was clang so we did some tests

00:35:06,500 --> 00:35:12,130
and it turned out we were able to access

00:35:08,150 --> 00:35:14,480
those hooks pretty easily if it was

00:35:12,130 --> 00:35:17,420
built with dark we can create a little

00:35:14,480 --> 00:35:19,610
type that rather than the standard new

00:35:17,420 --> 00:35:23,080
and delete operations would call into

00:35:19,610 --> 00:35:24,950
these are cad ref and release hooks and

00:35:23,080 --> 00:35:27,980
surprisingly fast took us about two

00:35:24,950 --> 00:35:30,680
weeks to get that up and running and so

00:35:27,980 --> 00:35:34,600
we were able to arc enable the framework

00:35:30,680 --> 00:35:34,600
from a c++ teller developer perspective

00:35:35,500 --> 00:35:39,410
so there are these kinds of features

00:35:37,340 --> 00:35:42,470
that are in the product largely because

00:35:39,410 --> 00:35:44,690
apples had been using it to support

00:35:42,470 --> 00:35:46,100
objective-c and that we were able to

00:35:44,690 --> 00:35:48,260
take advantage of for a certain feature

00:35:46,100 --> 00:35:51,020
that's not really a C++ feature at all

00:35:48,260 --> 00:35:54,350
but something that was important to our

00:35:51,020 --> 00:35:58,010
goals of enabling this memory management

00:35:54,350 --> 00:36:00,020
support in the framework and allowing

00:35:58,010 --> 00:36:02,930
the developers to continue to keep

00:36:00,020 --> 00:36:04,790
source code the way it is and not have

00:36:02,930 --> 00:36:07,040
to make big changes to their existing

00:36:04,790 --> 00:36:12,550
source code some of which are millions

00:36:07,040 --> 00:36:17,150
of lines of code so this isn't strictly

00:36:12,550 --> 00:36:18,590
related to the 64-bit project but after

00:36:17,150 --> 00:36:20,870
we finished that project and we actually

00:36:18,590 --> 00:36:22,400
started this work before we were

00:36:20,870 --> 00:36:24,230
finished with a 64-bit project we

00:36:22,400 --> 00:36:25,550
started looking at the arm back end and

00:36:24,230 --> 00:36:29,540
started doing a lot of things in

00:36:25,550 --> 00:36:33,050
parallel and connecting to that back end

00:36:29,540 --> 00:36:34,130
was really smooth there were things I

00:36:33,050 --> 00:36:35,510
made it a lot easier we could also

00:36:34,130 --> 00:36:41,630
depend on one object format on the

00:36:35,510 --> 00:36:43,340
mobile platforms to we decided to use

00:36:41,630 --> 00:36:45,110
the STL's that were provided by the

00:36:43,340 --> 00:36:48,260
platforms and not clanging in this case

00:36:45,110 --> 00:36:51,920
or to port dinkum where although we had

00:36:48,260 --> 00:36:53,510
a lot of discussions about that and we

00:36:51,920 --> 00:36:55,250
use things like g DB server and some of

00:36:53,510 --> 00:36:58,460
these other ancillary toolchain items

00:36:55,250 --> 00:36:59,870
that are delivered by the platform and

00:36:58,460 --> 00:37:01,130
so as i mentioned previously so most

00:36:59,870 --> 00:37:04,130
platforms were more ready than others

00:37:01,130 --> 00:37:05,220
Android wasn't quite ready at least at

00:37:04,130 --> 00:37:07,050
the time

00:37:05,220 --> 00:37:08,550
I with exception handling support at

00:37:07,050 --> 00:37:15,119
least and also in the version that we

00:37:08,550 --> 00:37:17,820
were using at the time to question it's

00:37:15,119 --> 00:37:25,650
a 32-bit today yes so the question was

00:37:17,820 --> 00:37:29,060
is the app 32 bit or 64 bits 32 bit so

00:37:25,650 --> 00:37:29,060
what went wrong this is the fun one

00:37:29,900 --> 00:37:35,430
there's a lot of challenges in this

00:37:32,609 --> 00:37:38,070
project one is a lot of this early

00:37:35,430 --> 00:37:39,780
extension work we farmed out to people

00:37:38,070 --> 00:37:41,040
we knew who were no longer working for

00:37:39,780 --> 00:37:46,980
borland that we'd work with in the past

00:37:41,040 --> 00:37:48,359
running her own company and this is you

00:37:46,980 --> 00:37:51,090
know sure to know because all those game

00:37:48,359 --> 00:37:52,770
developer post-mortems are red typically

00:37:51,090 --> 00:37:55,380
contracting at work tended to be

00:37:52,770 --> 00:37:57,150
something that didn't go well so

00:37:55,380 --> 00:37:58,349
nevertheless we thought it was a good

00:37:57,150 --> 00:38:00,140
idea so we could work on some other

00:37:58,349 --> 00:38:02,310
things we're still shipping products

00:38:00,140 --> 00:38:04,650
these guys were excellently compiler

00:38:02,310 --> 00:38:07,109
developers but just like in most

00:38:04,650 --> 00:38:09,359
contracts we sometimes have missed

00:38:07,109 --> 00:38:13,170
expectations different ideas on what

00:38:09,359 --> 00:38:17,490
means a complete project testing because

00:38:13,170 --> 00:38:20,220
they're not a QA team necessarily so you

00:38:17,490 --> 00:38:21,510
know looking back on it we probably

00:38:20,220 --> 00:38:25,320
should have taken the time out to do

00:38:21,510 --> 00:38:26,700
that work ourselves and to because it

00:38:25,320 --> 00:38:29,520
took a lot of time to integrate that

00:38:26,700 --> 00:38:30,660
knowledge back into the team and someone

00:38:29,520 --> 00:38:31,680
was talking about tribal knowledge the

00:38:30,660 --> 00:38:33,450
other day this was definitely one of

00:38:31,680 --> 00:38:35,040
those tribal knowledge kinds of things

00:38:33,450 --> 00:38:36,690
our guys are really up to speed now but

00:38:35,040 --> 00:38:38,609
it took probably more effort than a

00:38:36,690 --> 00:38:40,980
would have otherwise if we had done this

00:38:38,609 --> 00:38:42,480
work in the first place and this was

00:38:40,980 --> 00:38:43,500
with regard to the compiler extensions

00:38:42,480 --> 00:38:45,089
that I've been talking about this

00:38:43,500 --> 00:38:48,810
front-end compiler work and it took a

00:38:45,089 --> 00:38:50,190
really long time you know in total I'd

00:38:48,810 --> 00:38:51,720
say that part of the project is to

00:38:50,190 --> 00:38:54,930
enable our extensions in the front end

00:38:51,720 --> 00:38:57,210
was probably about 24 months to get it

00:38:54,930 --> 00:39:00,300
from parts leak partly through the

00:38:57,210 --> 00:39:01,589
contractors back into the team go

00:39:00,300 --> 00:39:02,910
through the testing process that we

00:39:01,589 --> 00:39:05,280
needed to get a base of basically

00:39:02,910 --> 00:39:11,250
production ready so that was a long haul

00:39:05,280 --> 00:39:13,560
to not have a working compiler yet the

00:39:11,250 --> 00:39:15,869
other thing that is really awesome about

00:39:13,560 --> 00:39:17,369
this project but is really hard for us

00:39:15,869 --> 00:39:18,730
when we're trying to stabilize on a

00:39:17,369 --> 00:39:21,160
version is that it's really

00:39:18,730 --> 00:39:23,230
really active open source project both

00:39:21,160 --> 00:39:24,640
are very active projects actually every

00:39:23,230 --> 00:39:27,640
project that covered under lvm is

00:39:24,640 --> 00:39:31,150
extremely active this is awesome but

00:39:27,640 --> 00:39:33,820
there's a lot of churn and keeping up

00:39:31,150 --> 00:39:35,580
with daily changes is difficult not

00:39:33,820 --> 00:39:40,030
keeping up with changes after a week is

00:39:35,580 --> 00:39:41,530
almost deadly or months and so we're

00:39:40,030 --> 00:39:43,990
actually in a pretty tough situation

00:39:41,530 --> 00:39:46,990
right at the moment because we're not on

00:39:43,990 --> 00:39:50,260
trunk as because we started moving to

00:39:46,990 --> 00:39:52,450
that model but we're behind and we're

00:39:50,260 --> 00:39:54,190
feeling the pain let me tell you is that

00:39:52,450 --> 00:39:55,810
we have basically two full-time

00:39:54,190 --> 00:39:57,820
engineers that are just trying to keep

00:39:55,810 --> 00:40:01,359
merges up and keep this up to speed so

00:39:57,820 --> 00:40:03,880
this was a big did not go well big

00:40:01,359 --> 00:40:07,030
lesson I think for all of us the other

00:40:03,880 --> 00:40:08,619
thing that is can happen and does happen

00:40:07,030 --> 00:40:11,260
is you'll get competitive

00:40:08,619 --> 00:40:13,540
implementations that come in somebody

00:40:11,260 --> 00:40:16,390
got to their got to a sooner maybe

00:40:13,540 --> 00:40:19,240
you've been working on it they're going

00:40:16,390 --> 00:40:21,250
to win and so you're going to end up not

00:40:19,240 --> 00:40:23,650
getting your version in there you may

00:40:21,250 --> 00:40:28,020
end up not you know losing work or

00:40:23,650 --> 00:40:28,020
having to change work or having a fork

00:40:28,290 --> 00:40:33,520
yes though this hose 22 part small parts

00:40:31,720 --> 00:40:35,470
keeping up with it the other part is

00:40:33,520 --> 00:40:40,840
moving changes back in absolutely got a

00:40:35,470 --> 00:40:42,250
question over here we hadn't been

00:40:40,840 --> 00:40:44,560
frankly and that's something that we

00:40:42,250 --> 00:40:46,869
need to change and that's something that

00:40:44,560 --> 00:40:48,130
you'll hear in our the question is how

00:40:46,869 --> 00:40:50,530
we've been contributing a lot of our

00:40:48,130 --> 00:40:53,050
changes and we hadn't been and it was a

00:40:50,530 --> 00:40:55,359
mistake something that is that when in

00:40:53,050 --> 00:40:56,530
the not went well category and something

00:40:55,359 --> 00:40:58,670
that we're going to talk about in the

00:40:56,530 --> 00:41:06,440
end going forward yeah

00:40:58,670 --> 00:41:08,180
a lot frankly and then and to be honest

00:41:06,440 --> 00:41:13,160
reseting competitive implementations get

00:41:08,180 --> 00:41:15,980
in there now so yeah yep there's a lot

00:41:13,160 --> 00:41:17,480
of history there and there were things

00:41:15,980 --> 00:41:20,150
that prevented us from doing it that had

00:41:17,480 --> 00:41:22,700
nothing to do with technology that might

00:41:20,150 --> 00:41:27,560
be happy to share in a non-public forum

00:41:22,700 --> 00:41:30,020
with some people legal stuff frankly and

00:41:27,560 --> 00:41:32,630
that was imposed by ourselves which was

00:41:30,020 --> 00:41:35,780
really unfortunate and frustrating but

00:41:32,630 --> 00:41:38,750
we want to change that so anyways this

00:41:35,780 --> 00:41:39,860
is a good this is just good to recognize

00:41:38,750 --> 00:41:43,040
if you're working with open source in

00:41:39,860 --> 00:41:46,100
general you know try to be as connected

00:41:43,040 --> 00:41:47,920
to that project that you can if you're

00:41:46,100 --> 00:41:50,810
not contributing at least build on that

00:41:47,920 --> 00:41:53,330
daily and do your merges when the

00:41:50,810 --> 00:41:57,770
changes happen otherwise this world have

00:41:53,330 --> 00:41:59,090
heard the other thing I those

00:41:57,770 --> 00:42:00,530
challenging for us does all the other

00:41:59,090 --> 00:42:02,000
toolchain items I mean most people just

00:42:00,530 --> 00:42:05,510
think of compilers of front-end and

00:42:02,000 --> 00:42:07,070
back-end right well that's true but

00:42:05,510 --> 00:42:09,380
there's all sorts of other tools that go

00:42:07,070 --> 00:42:12,710
into making a binary and being able to

00:42:09,380 --> 00:42:16,700
debug that binary on the system a lot of

00:42:12,710 --> 00:42:20,030
tools and some of them are in various

00:42:16,700 --> 00:42:21,410
states of commercial readiness some of

00:42:20,030 --> 00:42:25,630
them were taken more time to get to know

00:42:21,410 --> 00:42:28,250
and learn LD B's looks like a great

00:42:25,630 --> 00:42:29,540
project we want to get there eventually

00:42:28,250 --> 00:42:33,800
we're not there yet we're still using g

00:42:29,540 --> 00:42:35,570
DB servers on the on the platforms lld

00:42:33,800 --> 00:42:38,060
is something we're really interested in

00:42:35,570 --> 00:42:39,350
excited about but it's not ready yet

00:42:38,060 --> 00:42:40,970
we've had to use several different

00:42:39,350 --> 00:42:43,670
linkers I mean we basically have

00:42:40,970 --> 00:42:46,390
Frankenstein tool chains and our guys

00:42:43,670 --> 00:42:48,710
are sitting in hexed editors a lot

00:42:46,390 --> 00:42:50,180
working on object format differences

00:42:48,710 --> 00:42:51,950
calling convention differences and all

00:42:50,180 --> 00:42:53,150
these kinds of other things that most of

00:42:51,950 --> 00:42:55,070
us don't ever want to think about when

00:42:53,150 --> 00:42:58,100
we're writing C++ right how many of you

00:42:55,070 --> 00:42:59,420
out there at work on a compiler okay a

00:42:58,100 --> 00:43:00,980
lot of you well then I'm just gonna say

00:42:59,420 --> 00:43:03,140
you probably don't have to deal with a

00:43:00,980 --> 00:43:06,290
lot of this pain but those guys that do

00:43:03,140 --> 00:43:09,050
yeah this is kind of your daily life and

00:43:06,290 --> 00:43:11,120
so we built a Frankenstein we use and

00:43:09,050 --> 00:43:12,440
one of the reasons we use our own linker

00:43:11,120 --> 00:43:13,970
on Windows is because

00:43:12,440 --> 00:43:15,589
we wanted to improve the build time we

00:43:13,970 --> 00:43:19,010
have a good incremental Winkle linker

00:43:15,589 --> 00:43:20,060
technology and so even though lod wasn't

00:43:19,010 --> 00:43:21,800
ready that was actually kind of a

00:43:20,060 --> 00:43:23,210
blessing in disguise because we ended up

00:43:21,800 --> 00:43:27,050
having to use our incremental linker and

00:43:23,210 --> 00:43:33,260
that helped with with regards to to

00:43:27,050 --> 00:43:34,310
build times Oh question yes and ll DB

00:43:33,260 --> 00:43:36,790
yes those are ones we're going to start

00:43:34,310 --> 00:43:38,780
with because we have more opportunity to

00:43:36,790 --> 00:43:41,119
to participate those we have been

00:43:38,780 --> 00:43:48,980
actually in those projects clang lvm

00:43:41,119 --> 00:43:52,069
we'll get back to that one we are on the

00:43:48,980 --> 00:43:54,560
on the mobile platforms yes but we're

00:43:52,069 --> 00:43:57,260
not using native debug formats so that's

00:43:54,560 --> 00:44:01,630
a whole nother topic which is another

00:43:57,260 --> 00:44:04,910
what didn't go well yes that's coming up

00:44:01,630 --> 00:44:08,060
partly yeah we also have always built

00:44:04,910 --> 00:44:10,339
very verbose debug info and dwarf didn't

00:44:08,060 --> 00:44:13,010
really have the capability to support

00:44:10,339 --> 00:44:14,839
that elf does a little better but yeah

00:44:13,010 --> 00:44:17,420
Dorf on windows which is we ended up

00:44:14,839 --> 00:44:25,490
using didn't support all of our debug

00:44:17,420 --> 00:44:30,829
info question is which Oh actually we

00:44:25,490 --> 00:44:32,839
hadn't this interesting I thought the

00:44:30,829 --> 00:44:35,060
question is rather than debug format

00:44:32,839 --> 00:44:36,619
used AST directly well part of the

00:44:35,060 --> 00:44:39,980
problem is that we do have to write it

00:44:36,619 --> 00:44:44,119
to a file that can be separate from the

00:44:39,980 --> 00:44:45,349
binary for for debugging actually not to

00:44:44,119 --> 00:44:49,160
say that that sounds like a really good

00:44:45,349 --> 00:44:52,760
idea I'm gonna look into that more 15

00:44:49,160 --> 00:44:54,170
minutes anyways so quite a bit of

00:44:52,760 --> 00:44:56,839
Frankenstein we're going on there but

00:44:54,170 --> 00:44:59,240
lots of I think a good progress on these

00:44:56,839 --> 00:45:00,680
other tool chain pieces and stuff that

00:44:59,240 --> 00:45:02,810
we definitely are involved in and want

00:45:00,680 --> 00:45:04,640
to get more involved in here's one that

00:45:02,810 --> 00:45:06,609
was kind of a surprise some language

00:45:04,640 --> 00:45:10,040
figure features don't come for free

00:45:06,609 --> 00:45:15,319
anybody believe that I'll give you a

00:45:10,040 --> 00:45:17,569
simple example we supported iOS pretty

00:45:15,319 --> 00:45:19,310
quickly in terms of getting darme and I

00:45:17,569 --> 00:45:21,500
was writing some C++ 11 code i was just

00:45:19,310 --> 00:45:23,610
using the most basic c++ 11 feature

00:45:21,500 --> 00:45:25,800
default initialization

00:45:23,610 --> 00:45:28,800
turns out that's not in the compiler at

00:45:25,800 --> 00:45:31,710
all oh that's all that all of us in the

00:45:28,800 --> 00:45:34,080
library setting up constructors for all

00:45:31,710 --> 00:45:37,470
the different types so if you're not

00:45:34,080 --> 00:45:39,690
using the correct stl that feature is

00:45:37,470 --> 00:45:42,570
not going to work yeah so we had naively

00:45:39,690 --> 00:45:46,410
used the stl that was on the mac

00:45:42,570 --> 00:45:49,110
platform not the one in xcode and so

00:45:46,410 --> 00:45:50,880
that one was behind and we found out the

00:45:49,110 --> 00:45:53,700
hard way pretty thankfully pretty

00:45:50,880 --> 00:45:56,730
quickly though that you know not all s

00:45:53,700 --> 00:46:01,260
tales are created equal so that's a

00:45:56,730 --> 00:46:02,460
simple example but those are kind of got

00:46:01,260 --> 00:46:06,030
just as you're going to other platforms

00:46:02,460 --> 00:46:11,280
and relying on existing libraries like

00:46:06,030 --> 00:46:14,040
that this was one that we talked about

00:46:11,280 --> 00:46:15,390
already you know once we got it up

00:46:14,040 --> 00:46:16,530
running this is kind of thankfully it

00:46:15,390 --> 00:46:18,720
wasn't a case of premature optimization

00:46:16,530 --> 00:46:20,100
was finding out after the fact oh shoot

00:46:18,720 --> 00:46:21,690
we got a real problem here our

00:46:20,100 --> 00:46:23,880
developers are used to really fast build

00:46:21,690 --> 00:46:28,710
times and they were i would say at least

00:46:23,880 --> 00:46:30,330
i don't know five times slower and that

00:46:28,710 --> 00:46:32,670
was you know this is that the cost of

00:46:30,330 --> 00:46:35,580
flexibility and optimizations to some

00:46:32,670 --> 00:46:38,220
degree yes and that's a reasonable

00:46:35,580 --> 00:46:40,320
argument to make although we're also

00:46:38,220 --> 00:46:43,230
trying to build an environment where

00:46:40,320 --> 00:46:44,970
people can quickly create apps for

00:46:43,230 --> 00:46:46,650
turning around so like for example one

00:46:44,970 --> 00:46:49,590
of the things we try to do since we have

00:46:46,650 --> 00:46:52,080
a common api is you can build a lot of

00:46:49,590 --> 00:46:53,700
your app in windows that will also work

00:46:52,080 --> 00:46:56,070
on iOS and Android so we try to keep it

00:46:53,700 --> 00:46:59,510
local a lot of the stuff we do actually

00:46:56,070 --> 00:47:01,650
runs inside the IDE in memory also so

00:46:59,510 --> 00:47:03,450
these are all things that we try to do

00:47:01,650 --> 00:47:06,300
to minimize having to go through lengthy

00:47:03,450 --> 00:47:08,520
builds and the build time or the cycle

00:47:06,300 --> 00:47:10,770
of not just building but also deploying

00:47:08,520 --> 00:47:12,480
and packaging and all those stuff on

00:47:10,770 --> 00:47:15,210
mobile just add so much more time to

00:47:12,480 --> 00:47:18,510
these these daily cycles or many times a

00:47:15,210 --> 00:47:20,070
day cycles so that's something that that

00:47:18,510 --> 00:47:21,630
we've rediscovered and we had to figure

00:47:20,070 --> 00:47:22,950
out a way dude and we decided at that

00:47:21,630 --> 00:47:24,780
point okay our incremental linkers

00:47:22,950 --> 00:47:27,270
definitely gonna help here and made it

00:47:24,780 --> 00:47:29,310
really work with that but you know

00:47:27,270 --> 00:47:30,660
turned out to be something that wasn't

00:47:29,310 --> 00:47:33,060
as big of a concern as we thought it

00:47:30,660 --> 00:47:35,850
would be most developers who experienced

00:47:33,060 --> 00:47:37,110
it we're willing to exchange the bill

00:47:35,850 --> 00:47:38,460
times for bed

00:47:37,110 --> 00:47:40,890
language compliance and better

00:47:38,460 --> 00:47:42,270
optimizations so that was good you know

00:47:40,890 --> 00:47:44,220
we were worried about that but it turned

00:47:42,270 --> 00:47:48,540
out to be a problem that wasn't as bad

00:47:44,220 --> 00:47:50,760
as we thought it would be okay so some

00:47:48,540 --> 00:47:56,880
of the lessons learned from this I'm

00:47:50,760 --> 00:47:58,590
gonna going on time okay so one of them

00:47:56,880 --> 00:48:00,360
is that clang is very strict with regard

00:47:58,590 --> 00:48:03,800
to the standard that's a good thing

00:48:00,360 --> 00:48:06,920
right problem is if you're bringing up a

00:48:03,800 --> 00:48:09,840
C++ code base this could be 20 years old

00:48:06,920 --> 00:48:11,760
their developers are pretty crafty

00:48:09,840 --> 00:48:14,130
people they're going to work around bugs

00:48:11,760 --> 00:48:16,350
they're going to work around weird

00:48:14,130 --> 00:48:17,910
switches they're going to do things that

00:48:16,350 --> 00:48:19,710
rely on which you present is the

00:48:17,910 --> 00:48:21,930
interface to the tool change that

00:48:19,710 --> 00:48:23,250
probably shouldn't be done I guess it's

00:48:21,930 --> 00:48:25,680
true of anything that you put out there

00:48:23,250 --> 00:48:26,850
that people can build upon and they're

00:48:25,680 --> 00:48:30,630
going to find all sorts of corner cases

00:48:26,850 --> 00:48:32,400
and workarounds and so one of our goals

00:48:30,630 --> 00:48:35,580
was to help our customers move forward

00:48:32,400 --> 00:48:38,640
and I think you know one of the lessons

00:48:35,580 --> 00:48:39,750
there is instead of just putting a new

00:48:38,640 --> 00:48:41,250
standard in front of them or nude

00:48:39,750 --> 00:48:43,620
language implementation in front of them

00:48:41,250 --> 00:48:45,690
you also got to help them move past a

00:48:43,620 --> 00:48:46,860
lot of these issues you don't

00:48:45,690 --> 00:48:48,560
necessarily think about different types

00:48:46,860 --> 00:48:51,870
of switches and the impact it has

00:48:48,560 --> 00:48:53,670
different looseness and the compilers in

00:48:51,870 --> 00:48:56,280
terms of language standard that maybe

00:48:53,670 --> 00:48:58,440
our old compiler was very forgiving

00:48:56,280 --> 00:49:03,510
about and the new compiler is not for

00:48:58,440 --> 00:49:06,210
good reason I was trying to think of one

00:49:03,510 --> 00:49:09,960
just the other day that that hit us had

00:49:06,210 --> 00:49:13,140
to do with template initialization and

00:49:09,960 --> 00:49:15,390
to pass and Clank did it correctly we

00:49:13,140 --> 00:49:31,680
didn't in the past even though it worked

00:49:15,390 --> 00:49:34,170
go right exactly good one so let's learn

00:49:31,680 --> 00:49:35,670
here is better documentation better

00:49:34,170 --> 00:49:38,730
drivers when I say driver I mean things

00:49:35,670 --> 00:49:40,860
that set up things like the path that

00:49:38,730 --> 00:49:43,290
also set up all the environment for

00:49:40,860 --> 00:49:46,560
building so that they call you know they

00:49:43,290 --> 00:49:47,880
call our XE but it does all this set up

00:49:46,560 --> 00:49:50,840
for them so those are the kinds of

00:49:47,880 --> 00:49:50,840
things that we could help improve on

00:49:53,740 --> 00:49:58,010
question is about refactoring tools yeah

00:49:56,360 --> 00:50:01,970
those are some ways to deal with it as

00:49:58,010 --> 00:50:03,740
well yeah I mean in general the customer

00:50:01,970 --> 00:50:05,750
base has been really good about adopting

00:50:03,740 --> 00:50:09,560
the standard in making these changes and

00:50:05,750 --> 00:50:12,020
we were probably overthinking the goal

00:50:09,560 --> 00:50:15,260
to try to help keep them working with

00:50:12,020 --> 00:50:17,750
older conventions so you know there's a

00:50:15,260 --> 00:50:19,910
lot of leverage their that we don't

00:50:17,750 --> 00:50:22,130
people won't move up when your

00:50:19,910 --> 00:50:23,450
businesses around upgrading people you

00:50:22,130 --> 00:50:26,270
want to make it as easy as possible to

00:50:23,450 --> 00:50:27,410
and that's our business model so that's

00:50:26,270 --> 00:50:29,240
something that we had to take into

00:50:27,410 --> 00:50:31,430
careful consideration at the same time a

00:50:29,240 --> 00:50:33,230
lot of these things that we really rung

00:50:31,430 --> 00:50:35,600
our hands about our hands about

00:50:33,230 --> 00:50:36,890
customers were willing to to make those

00:50:35,600 --> 00:50:38,600
changes for better compliance for

00:50:36,890 --> 00:50:40,520
example so this was ended up being a

00:50:38,600 --> 00:50:44,540
good thing we could have done a better

00:50:40,520 --> 00:50:48,260
job by helping them though I've talked

00:50:44,540 --> 00:50:49,700
about that initial contract work well

00:50:48,260 --> 00:50:53,210
this is a second I must have moved it

00:50:49,700 --> 00:50:54,110
yeah this was a lesson learned to we

00:50:53,210 --> 00:50:56,510
should have done this work in-house

00:50:54,110 --> 00:50:58,250
basically was a lesson learned or just

00:50:56,510 --> 00:51:00,220
had better project management better

00:50:58,250 --> 00:51:02,060
more check ins more frequent check-ins

00:51:00,220 --> 00:51:03,260
kind of the same lesson we learned

00:51:02,060 --> 00:51:04,730
around just working with an open source

00:51:03,260 --> 00:51:09,950
project in general to be more connected

00:51:04,730 --> 00:51:12,080
to it and this is kind of up to the next

00:51:09,950 --> 00:51:15,470
one keeping up is painful if you don't

00:51:12,080 --> 00:51:16,970
keep if you don't merge daily this is

00:51:15,470 --> 00:51:19,160
probably the biggest one when I said

00:51:16,970 --> 00:51:21,560
some of the feedback out loud this was

00:51:19,160 --> 00:51:23,060
the biggest one because the business in

00:51:21,560 --> 00:51:25,430
general is keeping our developer team

00:51:23,060 --> 00:51:29,480
from accomplishing this and it was a

00:51:25,430 --> 00:51:31,550
mistake and so yeah we're paying the

00:51:29,480 --> 00:51:33,170
price for it now but that's something

00:51:31,550 --> 00:51:34,640
that looking forward we definitely want

00:51:33,170 --> 00:51:36,440
to change we should have committed

00:51:34,640 --> 00:51:40,970
changes we should have done it earlier

00:51:36,440 --> 00:51:42,590
should've done often and I think from us

00:51:40,970 --> 00:51:44,060
we also want to pay more attention to

00:51:42,590 --> 00:51:48,230
all the other tool chain items again a

00:51:44,060 --> 00:51:50,810
ole DB 0 LD we're very actively working

00:51:48,230 --> 00:51:53,330
on these right now we're not shipping

00:51:50,810 --> 00:51:55,760
them as production components but we

00:51:53,330 --> 00:51:57,290
definitely want to spend time on them

00:51:55,760 --> 00:51:58,430
and support them and be more involved in

00:51:57,290 --> 00:51:59,869
the community and take these lessons

00:51:58,430 --> 00:52:03,140
learned forward

00:51:59,869 --> 00:52:05,059
so looking forward right now we're

00:52:03,140 --> 00:52:08,019
working on 132 supports way more

00:52:05,059 --> 00:52:09,769
complicated than anything we've done

00:52:08,019 --> 00:52:11,390
structured exception handling is

00:52:09,769 --> 00:52:12,230
probably the biggest challenge and

00:52:11,390 --> 00:52:15,200
that's something that I mentioned

00:52:12,230 --> 00:52:17,450
earlier was something we could have

00:52:15,200 --> 00:52:21,529
contributed back but there was legal

00:52:17,450 --> 00:52:26,599
reasons that we created that kept us

00:52:21,529 --> 00:52:28,910
from doing this so up to make long story

00:52:26,599 --> 00:52:30,710
short it was a patent that expired and

00:52:28,910 --> 00:52:33,799
so this is a good thing now we're all

00:52:30,710 --> 00:52:36,619
freed from the handcuffs of this

00:52:33,799 --> 00:52:38,539
implementation there's lots of

00:52:36,619 --> 00:52:40,369
non-standard calling conventions I guess

00:52:38,539 --> 00:52:43,369
you can call them standard if win32 but

00:52:40,369 --> 00:52:46,069
there's lots of calling conventions so

00:52:43,369 --> 00:52:48,140
this has been really challenging and not

00:52:46,069 --> 00:52:51,170
to mention lots of object formats we'd

00:52:48,140 --> 00:52:53,059
never support a cough is because it's

00:52:51,170 --> 00:52:56,900
never been documented and so we've

00:52:53,059 --> 00:53:00,740
always had our own object format but you

00:52:56,900 --> 00:53:02,990
know each tool chain like for example

00:53:00,740 --> 00:53:03,829
we're trying to mix dwarf an omf and

00:53:02,990 --> 00:53:05,329
trying to figure out all the right

00:53:03,829 --> 00:53:07,220
object formats to work to get our debug

00:53:05,329 --> 00:53:10,190
info get everything working correctly

00:53:07,220 --> 00:53:12,799
this has been a pretty complicated task

00:53:10,190 --> 00:53:15,559
it's taken longer to do this even with

00:53:12,799 --> 00:53:18,680
the front end work then it has taken us

00:53:15,559 --> 00:53:19,940
to get the arm for example so this is

00:53:18,680 --> 00:53:21,109
actually something that's about ready to

00:53:19,940 --> 00:53:23,119
go and debate it to our customers so

00:53:21,109 --> 00:53:26,869
this is it's been a long time coming but

00:53:23,119 --> 00:53:28,880
is it was a lot of effort and so for us

00:53:26,869 --> 00:53:30,170
on the Klang an lvm site in general

00:53:28,880 --> 00:53:34,249
we're looking at taking it to more

00:53:30,170 --> 00:53:36,440
platforms as i mentioned our goal is to

00:53:34,249 --> 00:53:38,809
deliver full application development

00:53:36,440 --> 00:53:41,109
environment that people can build C++

00:53:38,809 --> 00:53:47,839
applications for target multiple

00:53:41,109 --> 00:53:51,410
operating systems and devices so when 32

00:53:47,839 --> 00:53:54,859
is next we do also build back in Middle

00:53:51,410 --> 00:54:01,670
where software so Linux 64 is definitely

00:53:54,859 --> 00:54:04,880
a next target today actually yes but we

00:54:01,670 --> 00:54:07,579
stopped to do our work to that yep which

00:54:04,880 --> 00:54:09,770
okay no question isn't isn't clang 64

00:54:07,579 --> 00:54:13,820
already supported on linux and yeah

00:54:09,770 --> 00:54:14,930
so this is it's a good head start but

00:54:13,820 --> 00:54:17,570
other platforms could grow quickly

00:54:14,930 --> 00:54:20,360
android on intel and again i think and

00:54:17,570 --> 00:54:24,920
who knows really when our tea anyone I

00:54:20,360 --> 00:54:26,270
don't know that nevertheless platforms

00:54:24,920 --> 00:54:28,190
are going to come come up that we want

00:54:26,270 --> 00:54:29,810
to get to and lvm is definitely going to

00:54:28,190 --> 00:54:34,310
help us get there but we also have their

00:54:29,810 --> 00:54:37,280
go work on the client side too so we're

00:54:34,310 --> 00:54:40,040
finishing a 3.3 update and you're going

00:54:37,280 --> 00:54:42,260
will 3.5 just came out yes it did and

00:54:40,040 --> 00:54:44,900
this is when i get back to the pain of

00:54:42,260 --> 00:54:48,650
not keeping up with the trunk this is

00:54:44,900 --> 00:54:52,370
what it cost us or behind on it and so

00:54:48,650 --> 00:54:54,260
it's getting better but it was not ideal

00:54:52,370 --> 00:54:57,680
and i was something that again it's been

00:54:54,260 --> 00:54:58,910
a very painful lesson for the team and

00:54:57,680 --> 00:55:01,700
we want to definitely explore strategies

00:54:58,910 --> 00:55:03,950
with the client team from a business

00:55:01,700 --> 00:55:05,060
perspective in particular how can we do

00:55:03,950 --> 00:55:07,070
more to share code back with the

00:55:05,060 --> 00:55:10,910
projects that will use and be more

00:55:07,070 --> 00:55:13,600
involved with the projects ultimately

00:55:10,910 --> 00:55:18,770
what we'd like to do is we want to help

00:55:13,600 --> 00:55:20,450
promote C++ as meeting is potential for

00:55:18,770 --> 00:55:23,030
application development across multiple

00:55:20,450 --> 00:55:25,400
platforms it hasn't really been

00:55:23,030 --> 00:55:28,840
considered a viable language for most

00:55:25,400 --> 00:55:31,190
for mobile development largely because

00:55:28,840 --> 00:55:34,990
the platform vendors have chosen other

00:55:31,190 --> 00:55:37,910
languages iOS with Objective C and

00:55:34,990 --> 00:55:39,620
Google with Java dalvik for example

00:55:37,910 --> 00:55:44,840
although they both have very good C++

00:55:39,620 --> 00:55:47,680
support and so we you know in building

00:55:44,840 --> 00:55:50,870
up the solution we definitely want to be

00:55:47,680 --> 00:55:52,490
C++ advocates in evangelist on the

00:55:50,870 --> 00:55:55,850
client side in particular on the mobile

00:55:52,490 --> 00:55:58,340
did demonstrate more and more let c plus

00:55:55,850 --> 00:55:59,990
plus 11 is accessible to developers

00:55:58,340 --> 00:56:01,220
we're at a seat post post conference so

00:55:59,990 --> 00:56:03,410
you guys are probably thinking what's

00:56:01,220 --> 00:56:04,850
the big deal c plus plus 11 pretty easy

00:56:03,410 --> 00:56:08,030
to use there's a lot of developers out

00:56:04,850 --> 00:56:10,580
there who are scared of C++ for for

00:56:08,030 --> 00:56:13,280
reasons that are not necessarily logical

00:56:10,580 --> 00:56:14,570
so we have to we have to teach them we

00:56:13,280 --> 00:56:16,130
have to inform them we have to write

00:56:14,570 --> 00:56:18,380
articles about it that's loud we're

00:56:16,130 --> 00:56:20,960
spending our marketing effort is in

00:56:18,380 --> 00:56:23,550
educating developers you don't have to

00:56:20,960 --> 00:56:25,400
live with html5 and JavaScript to get a

00:56:23,550 --> 00:56:30,780
common code base you can do it with a

00:56:25,400 --> 00:56:32,190
real language like C++ in the way we're

00:56:30,780 --> 00:56:35,190
going to get them really to buy into it

00:56:32,190 --> 00:56:39,390
is what C++ is best at great runtime

00:56:35,190 --> 00:56:41,610
performance and great facilities that

00:56:39,390 --> 00:56:43,200
are available to developers because the

00:56:41,610 --> 00:56:45,030
biggest competitor to it right now on

00:56:43,200 --> 00:56:48,650
these platforms is html5 and JavaScript

00:56:45,030 --> 00:56:50,850
and who wants to live in that world oh

00:56:48,650 --> 00:56:52,020
yeah yeah Sam oeun actually I think

00:56:50,850 --> 00:56:53,880
doing quite well they're definitely

00:56:52,020 --> 00:56:56,420
question is xamarin competitor

00:56:53,880 --> 00:57:00,170
definitely they definitely put their

00:56:56,420 --> 00:57:03,090
their bucket and c sharp as the language

00:57:00,170 --> 00:57:04,860
which you know hey there's a lot of C

00:57:03,090 --> 00:57:08,100
sharp developers out there so they have

00:57:04,860 --> 00:57:09,630
a definitely a market opportunity but we

00:57:08,100 --> 00:57:14,340
want to definitely do this the same kind

00:57:09,630 --> 00:57:15,690
of the same thing for c++ definitely we

00:57:14,340 --> 00:57:17,640
come up against amarin we come up

00:57:15,690 --> 00:57:19,980
against a bunch of JavaScript solutions

00:57:17,640 --> 00:57:21,060
like Coney and upsell reiter a lot of

00:57:19,980 --> 00:57:25,290
these are pretty easy to overcome

00:57:21,060 --> 00:57:27,570
depending on the how well the developers

00:57:25,290 --> 00:57:30,450
versed in developing with languages

00:57:27,570 --> 00:57:32,730
other than html5 and JavaScript but

00:57:30,450 --> 00:57:34,920
absolutely I we run into xamarin renan

00:57:32,730 --> 00:57:36,600
to this is quite it there's actually put

00:57:34,920 --> 00:57:39,180
this is a pretty exciting time to be a

00:57:36,600 --> 00:57:41,580
developer tools vendor again I mean back

00:57:39,180 --> 00:57:43,590
in the 90s it was crazy there was lots

00:57:41,580 --> 00:57:45,390
of tools throughout the 2000s or is

00:57:43,590 --> 00:57:47,280
almost nothing going on and now it's

00:57:45,390 --> 00:57:48,600
like everybody wants to be a developer

00:57:47,280 --> 00:57:49,890
tools vendor again there's probably a

00:57:48,600 --> 00:57:58,560
hundred different choices for building

00:57:49,890 --> 00:57:59,820
mobile apps these days it's crazy QT

00:57:58,560 --> 00:58:01,500
would be an example although they're

00:57:59,820 --> 00:58:03,120
primarily just focusing on the framework

00:58:01,500 --> 00:58:04,140
which is largely with Zaman's doing two

00:58:03,120 --> 00:58:05,970
of though they're building an ID as well

00:58:04,140 --> 00:58:07,260
who else is sorry the question was who

00:58:05,970 --> 00:58:12,480
else is competing in this base and the

00:58:07,260 --> 00:58:14,370
non HTML there's certainly a lot of

00:58:12,480 --> 00:58:16,890
scripting language solutions out there a

00:58:14,370 --> 00:58:20,210
lot of them tend to be focused on like

00:58:16,890 --> 00:58:24,710
2d casual game development or

00:58:20,210 --> 00:58:25,910
Oh 30 real app development yeah it's

00:58:24,710 --> 00:58:28,690
funny that you say that but those are

00:58:25,910 --> 00:58:30,950
the moneymakers on all these platforms

00:58:28,690 --> 00:58:34,510
but you're right enterprises don't write

00:58:30,950 --> 00:58:34,510
in these languages generally speaking

00:58:34,930 --> 00:58:39,170
that's a good question I think Sam is

00:58:37,400 --> 00:58:42,320
probably going to be the biggest biggest

00:58:39,170 --> 00:58:44,150
competitor but bigger than both of the

00:58:42,320 --> 00:58:46,550
boat than us and salmon is going to be

00:58:44,150 --> 00:58:50,270
html5 and JavaScript because it's still

00:58:46,550 --> 00:58:52,849
especially by enterprises seen as a very

00:58:50,270 --> 00:58:55,670
cost-effective way to solve their mobile

00:58:52,849 --> 00:59:02,540
challenges and a lot of enterprises are

00:58:55,670 --> 00:59:03,770
driven by cost what's that then that may

00:59:02,540 --> 00:59:06,560
be a viable strategy for some

00:59:03,770 --> 00:59:10,150
enterprises but eighty-five percent of

00:59:06,560 --> 00:59:12,830
the world is on Android at this point

00:59:10,150 --> 00:59:15,380
anyways I think we're towards the end I

00:59:12,830 --> 00:59:17,660
just want to let you know that in

00:59:15,380 --> 00:59:20,210
pushing C++ we built a new product

00:59:17,660 --> 00:59:22,820
called that method it's basically our

00:59:20,210 --> 00:59:25,820
c++ builder but we wanted to give it a

00:59:22,820 --> 00:59:27,380
new brand and get people who you know

00:59:25,820 --> 00:59:29,990
are looking at solutions something new

00:59:27,380 --> 00:59:33,200
to think about and really pushing C++ on

00:59:29,990 --> 00:59:34,580
this one there is a free Android

00:59:33,200 --> 00:59:36,020
compiler that you can use for commercial

00:59:34,580 --> 00:59:38,540
development in it that's sort of our

00:59:36,020 --> 00:59:42,050
seating strategy so if you want to play

00:59:38,540 --> 00:59:43,640
with clang lvm on android it's more than

00:59:42,050 --> 00:59:45,050
just a compiler to it's also the

00:59:43,640 --> 00:59:47,630
development environment in the framework

00:59:45,050 --> 00:59:49,220
etc but if you certainly have a compiler

00:59:47,630 --> 00:59:51,470
there at the ready this clang lvm for

00:59:49,220 --> 00:59:54,490
you to play with that you can get from

00:59:51,470 --> 00:59:54,490
the add method home website

00:59:55,269 --> 01:00:00,219
yeah you basically get all the platforms

00:59:57,880 --> 01:00:02,599
in the first 30 days and then you

01:00:00,219 --> 01:00:04,910
continues the android compiler continues

01:00:02,599 --> 01:00:07,999
to work for an annual renewable

01:00:04,910 --> 01:00:09,559
subscription okay session is over I just

01:00:07,999 --> 01:00:12,679
got the note I could take a few

01:00:09,559 --> 01:00:15,109
questions though in the last before the

01:00:12,679 --> 01:00:16,309
next session so if you have anything you

01:00:15,109 --> 01:00:18,079
can feel free to go to the mic there

01:00:16,309 --> 01:00:21,759
otherwise you're welcome to leave to

01:00:18,079 --> 01:00:21,759

YouTube URL: https://www.youtube.com/watch?v=HjfFKNByDvY


