Title: CppCon 2014: Jason Lucas "Polymorphism with Unions"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Using tagged unions to create families of polymorphic types that are more flexible and more easily maintained than those formed with inheritance alone. We demonstrate the design pattern and implementation techniques of sum types with examples from a compiler development project. We also examine the technique's impact on project management and engineering and on algorithm design, including the role of type switches, value type semantics, and multiple dispatch polymorphism.
--
Jason Lucas is an alum of the Microsoft Visual C++ team and has been writing extensively in C++ since the early 90s. He is the architect for Orly, an open source, large-scale, distributed, transactional, and consistent graph database (all in C++) which also includes a compiler for distributed programs.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:03,560 --> 00:00:10,860
this is actually a surprisingly good

00:00:07,890 --> 00:00:13,679
turnout for polymorphic unions at nine

00:00:10,860 --> 00:00:16,070
o'clock in the morning on the

00:00:13,679 --> 00:00:21,570
second-to-last day of the conference so

00:00:16,070 --> 00:00:25,710
that's that's our topic today so I'm not

00:00:21,570 --> 00:00:27,150
my name is Jason Lucas and I'm not a

00:00:25,710 --> 00:00:30,210
real big fan of slides so we're just

00:00:27,150 --> 00:00:34,170
going to be looking at code this is kind

00:00:30,210 --> 00:00:34,800
of a Cody subject so we're just going to

00:00:34,170 --> 00:00:38,719
do it that way

00:00:34,800 --> 00:00:42,059
so what we have here is a fairly simple

00:00:38,719 --> 00:00:44,730
short class hierarchy describing

00:00:42,059 --> 00:00:46,260
two-dimensional shapes I don't think

00:00:44,730 --> 00:00:48,690
there's anything here that requires all

00:00:46,260 --> 00:00:51,920
that much explanation its structure but

00:00:48,690 --> 00:00:56,760
no behavior so you're very much as where

00:00:51,920 --> 00:01:00,449
objects light if we want to add various

00:00:56,760 --> 00:01:05,970
behaviors we can look at doing that the

00:01:00,449 --> 00:01:07,860
C++ wave that is to say we will put some

00:01:05,970 --> 00:01:14,040
pure virtual functions in the base class

00:01:07,860 --> 00:01:16,320
and and start filling things in the

00:01:14,040 --> 00:01:19,110
algorithm spread either anyon throughout

00:01:16,320 --> 00:01:21,900
the entire code base when we add virtual

00:01:19,110 --> 00:01:25,259
functions everybody breaks until we fill

00:01:21,900 --> 00:01:27,299
them all in your dips will sprawl over

00:01:25,259 --> 00:01:29,159
all the files in which these are

00:01:27,299 --> 00:01:32,490
implemented which should be separate one

00:01:29,159 --> 00:01:34,049
would think it's hard to see the

00:01:32,490 --> 00:01:36,060
parallel isms and implementations

00:01:34,049 --> 00:01:39,060
between the various places are your

00:01:36,060 --> 00:01:41,759
filling things in if you have

00:01:39,060 --> 00:01:44,579
intermediate classes in the hierarchy

00:01:41,759 --> 00:01:48,119
between the most derived ones and the

00:01:44,579 --> 00:01:51,240
least derived which this does not those

00:01:48,119 --> 00:01:52,680
are going to group your behaviors in

00:01:51,240 --> 00:01:54,240
ways that are great for some of your

00:01:52,680 --> 00:01:56,250
virtual functions and maybe not so great

00:01:54,240 --> 00:01:59,790
for some of your other virtual functions

00:01:56,250 --> 00:02:01,920
and that's just the way it rolls but on

00:01:59,790 --> 00:02:05,460
the good side the hierarchy remains

00:02:01,920 --> 00:02:09,410
open-ended even across API boundaries

00:02:05,460 --> 00:02:15,840
so if we

00:02:09,410 --> 00:02:18,120
want to add more classes or more you

00:02:15,840 --> 00:02:20,670
know more bits and pieces we're free to

00:02:18,120 --> 00:02:23,130
do that we want to add more virtual

00:02:20,670 --> 00:02:27,240
functions however we can't right then

00:02:23,130 --> 00:02:30,740
we're gonna have to recompile so so far

00:02:27,240 --> 00:02:35,640
what it sounds like I'm telling you is

00:02:30,740 --> 00:02:37,710
this this is the visitor pattern which

00:02:35,640 --> 00:02:39,150
should be familiar by now if only

00:02:37,710 --> 00:02:43,250
because of the number of people who have

00:02:39,150 --> 00:02:43,250
spoken out with great hatred for it

00:02:44,180 --> 00:02:51,390
so visitor groups your concerns together

00:02:48,560 --> 00:02:53,190
so you know we have only one virtual

00:02:51,390 --> 00:02:55,980
function which is the visitor acceptor

00:02:53,190 --> 00:02:58,170
and then all of the algorithms group

00:02:55,980 --> 00:03:01,410
their bits together so they behave more

00:02:58,170 --> 00:03:05,760
like type switches your diffs are

00:03:01,410 --> 00:03:07,320
definitely more focused so this is nice

00:03:05,760 --> 00:03:09,240
we can work on individual algorithms

00:03:07,320 --> 00:03:10,680
we've got a team of people you can have

00:03:09,240 --> 00:03:13,800
people working on structural changes

00:03:10,680 --> 00:03:15,210
which will require updates to all the

00:03:13,800 --> 00:03:17,550
algorithms but at least the compiler can

00:03:15,210 --> 00:03:18,750
tell you and when you're people working

00:03:17,550 --> 00:03:24,930
on the algorithms they pretty much work

00:03:18,750 --> 00:03:26,700
in silos the grouping of the leaf

00:03:24,930 --> 00:03:28,230
classes the most derived classes can

00:03:26,700 --> 00:03:32,190
vary from algorithm to algorithm

00:03:28,230 --> 00:03:34,020
behavior can change so that's nice we're

00:03:32,190 --> 00:03:40,980
not locked into the hierarchy in any

00:03:34,020 --> 00:03:45,540
particular way and the hierarchy is

00:03:40,980 --> 00:03:50,010
sealed we can't extend it across API

00:03:45,540 --> 00:03:53,460
boundaries but we can add algorithms so

00:03:50,010 --> 00:03:56,420
this is the opposite we can extend the

00:03:53,460 --> 00:03:59,550
behaviors but we can't extend the types

00:03:56,420 --> 00:04:04,080
and the other kind of annoying thing

00:03:59,550 --> 00:04:05,730
about visitor is either you have to

00:04:04,080 --> 00:04:11,560
declare everything in an extremely

00:04:05,730 --> 00:04:17,380
specific order if you notice here we go

00:04:11,560 --> 00:04:19,150
the area the visitor is for declared and

00:04:17,380 --> 00:04:21,280
then all the finals are declared and

00:04:19,150 --> 00:04:22,930
then we can define the visitor and then

00:04:21,280 --> 00:04:27,760
we can define the visitor acceptors and

00:04:22,930 --> 00:04:29,290
then we can define the algorithms or if

00:04:27,760 --> 00:04:31,710
you're not the move to do that you can

00:04:29,290 --> 00:04:33,970
just sort of jumble it up in which case

00:04:31,710 --> 00:04:37,810
everybody knows about everybody else and

00:04:33,970 --> 00:04:39,250
you have poor isolation and those are

00:04:37,810 --> 00:04:42,340
kind of your two choices and either way

00:04:39,250 --> 00:04:48,510
there's a lot of boilerplate code here

00:04:42,340 --> 00:04:48,510
it's not particularly easy to read so

00:04:53,919 --> 00:05:05,240
yep variant we go back to our where we

00:05:03,320 --> 00:05:08,150
were with the first version we've got

00:05:05,240 --> 00:05:11,780
nothing behavioral in structures

00:05:08,150 --> 00:05:15,970
themselves and then we after we define

00:05:11,780 --> 00:05:22,460
all of these finals we decide those guys

00:05:15,970 --> 00:05:25,400
collectively are a shape variant

00:05:22,460 --> 00:05:27,080
collects them post hoc into shape and

00:05:25,400 --> 00:05:30,290
then we can define our behaviors like

00:05:27,080 --> 00:05:36,500
this looks a lot like visitor without

00:05:30,290 --> 00:05:38,389
the visitor so it's much more terse the

00:05:36,500 --> 00:05:40,460
algorithms have the advantage of being

00:05:38,389 --> 00:05:41,720
able to group the members of the Union

00:05:40,460 --> 00:05:46,639
any way you like just like visitor

00:05:41,720 --> 00:05:49,160
except we now we can use generosity to

00:05:46,639 --> 00:05:50,810
actually group them together into single

00:05:49,160 --> 00:05:54,979
handlers which would be harder to do the

00:05:50,810 --> 00:05:57,770
other way we're using overloaded lambdas

00:05:54,979 --> 00:06:02,539
here instead of explicit visitors so

00:05:57,770 --> 00:06:05,330
it's nice and terse and it's kind of

00:06:02,539 --> 00:06:07,850
nice that the right function can just be

00:06:05,330 --> 00:06:13,340
easy insertion operator well I think

00:06:07,850 --> 00:06:16,010
that's kind of nice so I wanted to start

00:06:13,340 --> 00:06:18,080
with this example before we backed off

00:06:16,010 --> 00:06:22,370
into more abstract discussion of what

00:06:18,080 --> 00:06:24,349
visitor what variants are so now that

00:06:22,370 --> 00:06:31,419
you've seen it let me get a little more

00:06:24,349 --> 00:06:33,950
abstract about so boost says that a

00:06:31,419 --> 00:06:36,139
variant is a type safe generic stack

00:06:33,950 --> 00:06:37,880
based container offering a simple

00:06:36,139 --> 00:06:40,880
solution for manipulating an object from

00:06:37,880 --> 00:06:42,800
heterogeneous types in a uniform manner

00:06:40,880 --> 00:06:44,270
whereas standard containers such as

00:06:42,800 --> 00:06:46,580
standard vector may be thought of as

00:06:44,270 --> 00:06:51,800
multi value a single type variant is

00:06:46,580 --> 00:06:53,539
multi type single value so I don't know

00:06:51,800 --> 00:06:56,679
why we have the rest of this hour to

00:06:53,539 --> 00:07:01,159
talk that pretty much sums it up

00:06:56,679 --> 00:07:03,379
the we'll put this another way the

00:07:01,159 --> 00:07:06,649
number of states a data structure can be

00:07:03,379 --> 00:07:10,099
in it depends on what it's got inside of

00:07:06,649 --> 00:07:11,629
it and in the case of Union the number

00:07:10,099 --> 00:07:14,479
of states a Union can be n is equal to

00:07:11,629 --> 00:07:18,349
the sum of the states that its members

00:07:14,479 --> 00:07:19,610
can be in as opposed to a struct where

00:07:18,349 --> 00:07:21,679
the number of states is equal to the

00:07:19,610 --> 00:07:25,659
product of the states that its members

00:07:21,679 --> 00:07:28,729
can be in so if you talk to formal

00:07:25,659 --> 00:07:32,889
language people they'll refer to this as

00:07:28,729 --> 00:07:35,089
a sum type as opposed to a product type

00:07:32,889 --> 00:07:39,499
then they will talk to you about Haskell

00:07:35,089 --> 00:07:41,569
and you should sprint away so this will

00:07:39,499 --> 00:07:43,610
go by many names you're gonna hear it

00:07:41,569 --> 00:07:46,099
described as discriminated unions tagged

00:07:43,610 --> 00:07:48,259
unions some types variants it's

00:07:46,099 --> 00:07:51,349
sometimes just lumped in with general

00:07:48,259 --> 00:07:52,959
type eurasia which it is this is not a

00:07:51,349 --> 00:07:55,939
new idea

00:07:52,959 --> 00:07:58,969
Alexandra skew kind of brought this to

00:07:55,939 --> 00:08:02,149
the public for back in 2002 and dr.

00:07:58,969 --> 00:08:04,909
Dobbs with an article series of articles

00:08:02,149 --> 00:08:09,649
about discriminated unions Friedman and

00:08:04,909 --> 00:08:11,389
manaan contributed the boost variant to

00:08:09,649 --> 00:08:15,489
the boost library at about the same time

00:08:11,389 --> 00:08:17,749
shortly thereafter and if you google for

00:08:15,489 --> 00:08:19,879
discriminated unions or variants or any

00:08:17,749 --> 00:08:24,860
of those terms you're gonna find lots

00:08:19,879 --> 00:08:29,589
and lots of implementations still it

00:08:24,860 --> 00:08:29,589
hasn't got a whole lot of traction why

00:08:30,120 --> 00:08:33,229
I'm actually asking

00:08:42,580 --> 00:08:44,580
Oh

00:08:49,150 --> 00:08:56,840
hmm how interesting

00:08:52,220 --> 00:09:00,800
um maybe but we have I mean C++ you know

00:08:56,840 --> 00:09:04,820
revolves around its its class hierarchy

00:09:00,800 --> 00:09:07,190
so saying that C++ doesn't have this

00:09:04,820 --> 00:09:09,740
kind of polymorphism it's true but C was

00:09:07,190 --> 00:09:11,960
suppose that's polymorphism and and what

00:09:09,740 --> 00:09:15,790
I'd like to demonstrate today is that a

00:09:11,960 --> 00:09:18,800
union is actually a class hierarchy

00:09:15,790 --> 00:09:20,590
collapsed into a value type it's exactly

00:09:18,800 --> 00:09:24,550
the same polymorphic behavior it's just

00:09:20,590 --> 00:09:28,580
nicer in some respects to work with

00:09:24,550 --> 00:09:29,930
there's a know what I think has been an

00:09:28,580 --> 00:09:33,560
issue has been that the boost

00:09:29,930 --> 00:09:37,850
implementation was suffering from having

00:09:33,560 --> 00:09:42,800
been written in 2003 when we didn't have

00:09:37,850 --> 00:09:45,110
a bunch of language features that we

00:09:42,800 --> 00:09:47,750
didn't have Lando's we didn't have our

00:09:45,110 --> 00:09:49,820
value semantics we didn't our rate

00:09:47,750 --> 00:09:53,420
references rather we didn't have very

00:09:49,820 --> 00:09:56,000
otic templates basically you know trying

00:09:53,420 --> 00:09:58,010
to do this with the 98 standard was like

00:09:56,000 --> 00:10:02,750
going to the moon with stone knives and

00:09:58,010 --> 00:10:04,430
bearskins so the boost one also made

00:10:02,750 --> 00:10:07,760
another choice which is something called

00:10:04,430 --> 00:10:10,460
the never empty guarantee the if we have

00:10:07,760 --> 00:10:12,530
this union of circle and triangle and

00:10:10,460 --> 00:10:17,600
square what happens if we default

00:10:12,530 --> 00:10:21,070
construct well that depends on who you

00:10:17,600 --> 00:10:23,240
ask what is the correct thing to do

00:10:21,070 --> 00:10:24,920
Alexandra skews implementation would

00:10:23,240 --> 00:10:28,070
default construct an instance of

00:10:24,920 --> 00:10:31,030
whatever the first type was otherwise

00:10:28,070 --> 00:10:31,030
known as surprise

00:10:35,440 --> 00:10:40,120
it's unclear what the correct thing to

00:10:38,050 --> 00:10:42,459
do is it's also therefore unclear what

00:10:40,120 --> 00:10:45,279
to do when you have a moved out variant

00:10:42,459 --> 00:10:46,680
if I move from a variant to another one

00:10:45,279 --> 00:10:49,389
what am I left with

00:10:46,680 --> 00:10:51,250
so the implementation that I'm going to

00:10:49,389 --> 00:10:55,139
show you today which was written by me

00:10:51,250 --> 00:10:57,579
and my colleague here Michael Park wave

00:10:55,139 --> 00:11:00,639
there's Mike

00:10:57,579 --> 00:11:03,220
we decided that they never no guarantee

00:11:00,639 --> 00:11:09,189
never empty guarantee is nice sometimes

00:11:03,220 --> 00:11:12,370
and sometimes it's a pain so what we did

00:11:09,189 --> 00:11:16,300
was say that the variant if it includes

00:11:12,370 --> 00:11:18,939
a null type and it's list then it's

00:11:16,300 --> 00:11:23,980
allowed to be null if it doesn't then

00:11:18,939 --> 00:11:28,209
it's not so and we have some enable if

00:11:23,980 --> 00:11:30,129
you do in the definition so that certain

00:11:28,209 --> 00:11:32,079
things are not there if it's not allowed

00:11:30,129 --> 00:11:40,740
to be no so it won't default construct

00:11:32,079 --> 00:11:40,740
wake up okay well better

00:11:40,769 --> 00:11:48,220
it won't default construct it doesn't

00:11:43,810 --> 00:11:51,279
have a reset method if it can be now

00:11:48,220 --> 00:11:53,620
than it has operator bool cast to find

00:11:51,279 --> 00:11:55,899
so you can test it for an illness in

00:11:53,620 --> 00:11:58,060
other words if it can be no then it

00:11:55,899 --> 00:12:01,240
behaves almost exactly the same as a

00:11:58,060 --> 00:12:02,380
pointer to a base class and you do

00:12:01,240 --> 00:12:05,800
everything you normally do with it

00:12:02,380 --> 00:12:06,880
except that it's a value type so the

00:12:05,800 --> 00:12:12,250
code that we're going to show you today

00:12:06,880 --> 00:12:15,810
is on github feel free to go there and

00:12:12,250 --> 00:12:21,370
play with it I don't think what you have

00:12:15,810 --> 00:12:24,970
today is as it stands a strong candidate

00:12:21,370 --> 00:12:26,500
for the standard library but I kind of

00:12:24,970 --> 00:12:29,740
hope that the standard library will have

00:12:26,500 --> 00:12:31,209
a variant and if you like some of the

00:12:29,740 --> 00:12:32,740
semantics of this one then we can talk

00:12:31,209 --> 00:12:36,550
about maybe moving this this thing

00:12:32,740 --> 00:12:37,839
towards some kind of a standard so I

00:12:36,550 --> 00:12:38,949
want to take a little bit of time and

00:12:37,839 --> 00:12:41,699
walk through how this is actually

00:12:38,949 --> 00:12:44,019
implemented because I think demystifying

00:12:41,699 --> 00:12:46,300
these kinds of type erasure containers

00:12:44,019 --> 00:12:52,410
is a worthwhile thing

00:12:46,300 --> 00:12:54,700
so in this case okay future-proofing

00:12:52,410 --> 00:12:58,360
pulling some stuff that's going to be

00:12:54,700 --> 00:13:01,720
this way shortly anyway and that this

00:12:58,360 --> 00:13:03,370
compiler just doesn't happen to do it's

00:13:01,720 --> 00:13:05,590
not very interesting anybody need to go

00:13:03,370 --> 00:13:06,670
over the stuff yeah if you see something

00:13:05,590 --> 00:13:09,840
on the screen then you're not sure what

00:13:06,670 --> 00:13:09,840
it is just put your hand in there

00:13:11,280 --> 00:13:18,010
alright so here's where we get into the

00:13:14,500 --> 00:13:19,980
thing this is the type that we use to

00:13:18,010 --> 00:13:22,150
say if this is included in the list of

00:13:19,980 --> 00:13:24,940
parameters for the variant then this is

00:13:22,150 --> 00:13:29,770
a nullable variant we actually had null

00:13:24,940 --> 00:13:31,330
pointer T here I'm I still kind of think

00:13:29,770 --> 00:13:34,330
maybe it should be no pointer to Mike

00:13:31,330 --> 00:13:43,030
doesn't so he got the last edit on this

00:13:34,330 --> 00:13:44,200
file so he won yes we are secretly using

00:13:43,030 --> 00:13:45,580
the visitor pattern it's really not a

00:13:44,200 --> 00:13:48,670
secret you should have been able to see

00:13:45,580 --> 00:13:50,920
that but the visitors being defined with

00:13:48,670 --> 00:13:54,730
very attics with a recursive pattern

00:13:50,920 --> 00:14:00,160
here again this isn't totally surprising

00:13:54,730 --> 00:14:03,880
and then this is overload overloaded

00:14:00,160 --> 00:14:08,280
macro or overloaded lambda rather which

00:14:03,880 --> 00:14:10,390
oh did I skip it okay where are you

00:14:08,280 --> 00:14:13,870
this is actually a little harder

00:14:10,390 --> 00:14:16,150
position than I was hoping for so this

00:14:13,870 --> 00:14:19,420
is overloaded lambda did you know you

00:14:16,150 --> 00:14:21,550
could inherit from my enough and even a

00:14:19,420 --> 00:14:23,830
very adequate of lendeth so the result

00:14:21,550 --> 00:14:26,230
is a function object with operator

00:14:23,830 --> 00:14:30,760
operator paren friend defined for all

00:14:26,230 --> 00:14:32,530
these overloads and then if we then have

00:14:30,760 --> 00:14:34,870
a dispatcher that can bridge us from

00:14:32,530 --> 00:14:37,210
variants pure virtual dispatch to one of

00:14:34,870 --> 00:14:40,230
these things we're golden and that's

00:14:37,210 --> 00:14:40,230
basically what we're about to do

00:14:40,670 --> 00:15:01,290
so variant itself okay so a little bit

00:14:51,210 --> 00:15:03,720
of preamble a little bit of I'll show

00:15:01,290 --> 00:15:06,810
you so if we can the question is if we

00:15:03,720 --> 00:15:10,860
can do overloaded lambda why do we need

00:15:06,810 --> 00:15:13,350
the visitor the short answer is we have

00:15:10,860 --> 00:15:15,780
erased the type so we're going to need

00:15:13,350 --> 00:15:20,340
to do a runtime type check to know what

00:15:15,780 --> 00:15:31,940
to do but you'll see it's a little more

00:15:20,340 --> 00:15:31,940
clear in a minute so yep which one oh

00:15:34,490 --> 00:15:41,100
yeah I guess so I'm afraid I'm gonna

00:15:39,690 --> 00:15:45,170
have navigation problems without it let

00:15:41,100 --> 00:15:45,170
me see how it goes I can turn it off

00:15:45,480 --> 00:15:49,590
and the code is actually on github so

00:15:47,520 --> 00:15:53,240
right like right this second so if you

00:15:49,590 --> 00:15:56,100
just go to github calm Jason Nell 9,000

00:15:53,240 --> 00:15:59,510
CPP 14 or CPP con 14 you'll see

00:15:56,100 --> 00:15:59,510
everything you can just follow along

00:15:59,810 --> 00:16:05,880
anyway so there int is a very attic

00:16:03,210 --> 00:16:08,370
template it has a little bit of preamble

00:16:05,880 --> 00:16:10,890
stuff going on here for deciding a few

00:16:08,370 --> 00:16:14,600
things some basic stuff like a union if

00:16:10,890 --> 00:16:16,650
nothing is not fair don't do that to me

00:16:14,600 --> 00:16:19,470
define our visitor and then you'll see

00:16:16,650 --> 00:16:23,040
here the default constructor is

00:16:19,470 --> 00:16:26,300
available if we have known in our list

00:16:23,040 --> 00:16:28,710
otherwise it's not and then you'll see

00:16:26,300 --> 00:16:29,850
the actual trick and I'm not going to

00:16:28,710 --> 00:16:32,130
get too much into this if you're really

00:16:29,850 --> 00:16:35,420
interested go read Alexander rescues

00:16:32,130 --> 00:16:38,310
articles because he spent three issues

00:16:35,420 --> 00:16:42,060
going through this in extremely hairy

00:16:38,310 --> 00:16:48,810
detail but the basic idea is we're going

00:16:42,060 --> 00:16:50,490
to create a poor-man's virtual table so

00:16:48,810 --> 00:16:51,810
that's what this tag data structure is

00:16:50,490 --> 00:16:53,089
and this is the when we talk about a

00:16:51,810 --> 00:16:55,099
tagged Union

00:16:53,089 --> 00:16:56,899
we mean that the union has some kind of

00:16:55,099 --> 00:16:59,479
piece of data following it around that

00:16:56,899 --> 00:17:03,619
says what's currently in it and in our

00:16:59,479 --> 00:17:11,529
case well the way we do that is with an

00:17:03,619 --> 00:17:11,529
instance of come on this data structure

00:17:11,620 --> 00:17:17,149
so it's a data structure full of

00:17:14,269 --> 00:17:22,100
pointers to functions in other words

00:17:17,149 --> 00:17:26,240
it's a V table so the constructor

00:17:22,100 --> 00:17:29,269
functions that we use for it get tag is

00:17:26,240 --> 00:17:31,429
templatized get tagged as a static

00:17:29,269 --> 00:17:33,529
constant a constant instance of it and

00:17:31,429 --> 00:17:36,649
just fills it up with some lambdas that

00:17:33,529 --> 00:17:39,769
do our work for us there's also the null

00:17:36,649 --> 00:17:46,909
version which doesn't actually do very

00:17:39,769 --> 00:17:51,590
much and then here is our tag and here

00:17:46,909 --> 00:17:54,139
is our storage so all we have is a blob

00:17:51,590 --> 00:17:57,259
of bytes that is big enough to hold the

00:17:54,139 --> 00:17:59,149
largest thing and aligned to whatever

00:17:57,259 --> 00:18:01,940
the strictest alignment is in the set of

00:17:59,149 --> 00:18:06,830
types and then if you look inside of

00:18:01,940 --> 00:18:08,990
they these guys they work with that to

00:18:06,830 --> 00:18:10,999
do whatever needs to be done after going

00:18:08,990 --> 00:18:12,860
through the virtual dispatch to get this

00:18:10,999 --> 00:18:15,499
far so this is where the type of ratio

00:18:12,860 --> 00:18:20,710
kicks in or the onion ratio in this case

00:18:15,499 --> 00:18:23,720
the type real and these guys are used to

00:18:20,710 --> 00:18:25,730
force the blob of bytes to behave as

00:18:23,720 --> 00:18:28,669
whatever type the tag discovered they

00:18:25,730 --> 00:18:30,259
really work so you can go through here

00:18:28,669 --> 00:18:33,110
it's probably exactly as you expect at

00:18:30,259 --> 00:18:35,240
this point the destructor for grant

00:18:33,110 --> 00:18:37,070
hands off to the destructor here the

00:18:35,240 --> 00:18:41,659
copy for variant hands-off to the copy

00:18:37,070 --> 00:18:44,990
here all of that stuff so at that point

00:18:41,659 --> 00:18:49,220
we're kind of done with variant the rest

00:18:44,990 --> 00:18:50,659
of this is all of the stuff and this is

00:18:49,220 --> 00:18:52,970
one I'm not going to get too terribly

00:18:50,659 --> 00:18:59,869
into because it is a little bit more

00:18:52,970 --> 00:19:03,049
template magicky how to define this

00:18:59,869 --> 00:19:06,150
visitor for us automatically that will

00:19:03,049 --> 00:19:09,540
dispatch from the virtual entry points

00:19:06,150 --> 00:19:16,020
to whatever the functor object has that

00:19:09,540 --> 00:19:19,680
matches us for an overload magic going

00:19:16,020 --> 00:19:22,200
on I'm happy to sit with anybody later

00:19:19,680 --> 00:19:23,580
after the talk that would like to know

00:19:22,200 --> 00:19:27,000
more about exactly how this part of it

00:19:23,580 --> 00:19:28,890
works but the practical part that you

00:19:27,000 --> 00:19:35,100
need to understand or would be useful to

00:19:28,890 --> 00:19:44,340
understand is that when we accept a

00:19:35,100 --> 00:19:46,560
visitor where is it tempted come on all

00:19:44,340 --> 00:19:51,440
right and get type in to accept your

00:19:46,560 --> 00:19:51,440
people of that and all right

00:19:56,020 --> 00:20:03,460
there it is when we accept a visitor we

00:20:01,030 --> 00:20:06,880
asked the tag to do our accepting for us

00:20:03,460 --> 00:20:09,280
we pass the information through once

00:20:06,880 --> 00:20:12,340
we're inside a tag we have the right

00:20:09,280 --> 00:20:14,710
information to dispatch to the correct

00:20:12,340 --> 00:20:16,150
overload of operator primp ran in the

00:20:14,710 --> 00:20:19,360
visitor object which is a pure virtual

00:20:16,150 --> 00:20:21,910
and then it jumps into that big

00:20:19,360 --> 00:20:23,320
complicated applier thing which hands

00:20:21,910 --> 00:20:27,460
off to the functor object which is the

00:20:23,320 --> 00:20:28,840
overloaded lambda so there's a lot of

00:20:27,460 --> 00:20:32,559
extra dispatch going on we're going to

00:20:28,840 --> 00:20:34,000
talk about performance later as I just

00:20:32,559 --> 00:20:40,000
heard everyone in this room think out

00:20:34,000 --> 00:20:42,100
loud so any questions about the variant

00:20:40,000 --> 00:20:48,280
before we move on the actual

00:20:42,100 --> 00:20:54,450
implementation oh good I knew that was

00:20:48,280 --> 00:20:58,030
gonna be simple so why would you do this

00:20:54,450 --> 00:21:03,010
so I have a few things I would like to

00:20:58,030 --> 00:21:05,500
talk into today variants can be more

00:21:03,010 --> 00:21:07,650
flexible than hierarchies variants can

00:21:05,500 --> 00:21:10,690
be easier to maintain than hierarchies a

00:21:07,650 --> 00:21:16,800
variant with a null state is like a

00:21:10,690 --> 00:21:19,000
superset of optional variants can do

00:21:16,800 --> 00:21:23,200
dispatch tricks that you simply cannot

00:21:19,000 --> 00:21:25,179
do almost any other way in C++ and it

00:21:23,200 --> 00:21:28,600
gets you out of a lot of complicated

00:21:25,179 --> 00:21:31,660
situations a few of which I talked about

00:21:28,600 --> 00:21:33,910
so getting back to the top of those

00:21:31,660 --> 00:21:36,790
variants more flexible than Americas we

00:21:33,910 --> 00:21:39,540
talked about how intermediate classes in

00:21:36,790 --> 00:21:39,540
the high bumps are good

00:21:58,400 --> 00:22:04,710
so the question is when we're defining

00:22:01,010 --> 00:22:06,270
behaviors if someone comes along and

00:22:04,710 --> 00:22:10,260
adds something to the Union which means

00:22:06,270 --> 00:22:13,680
the Union type is changing do all of the

00:22:10,260 --> 00:22:16,340
the behaviors break or do we have to can

00:22:13,680 --> 00:22:19,260
we handle the addition separately and

00:22:16,340 --> 00:22:22,280
the answer is it depends what I'm about

00:22:19,260 --> 00:22:27,360
to show you is that you can go back to

00:22:22,280 --> 00:22:29,340
generics inside your handlers so that

00:22:27,360 --> 00:22:32,520
you can get multiple kinds of dispatch

00:22:29,340 --> 00:22:35,160
going on within a behavior so that you

00:22:32,520 --> 00:22:38,640
might be agnostic about a lot of changes

00:22:35,160 --> 00:22:41,130
to the union's membership if it's not

00:22:38,640 --> 00:22:43,680
then you get an error that says

00:22:41,130 --> 00:22:47,340
something along the lines of this case

00:22:43,680 --> 00:22:49,860
isn't handled here so it's not a

00:22:47,340 --> 00:22:52,470
terrible error and it's essentially the

00:22:49,860 --> 00:22:54,360
same error as I can't instantiate this

00:22:52,470 --> 00:22:58,500
object because because there is a pure

00:22:54,360 --> 00:23:01,140
virtual in it so you're not actually any

00:22:58,500 --> 00:23:04,310
worse off this way I think then you have

00:23:01,140 --> 00:23:04,310
at least a chance to do better

00:23:07,570 --> 00:23:14,359
now they can be convertible to each

00:23:09,529 --> 00:23:20,090
other that's what I'm about to explain

00:23:14,359 --> 00:23:21,619
so I talked earlier about the idea of if

00:23:20,090 --> 00:23:23,899
you have intermediate classes in your

00:23:21,619 --> 00:23:25,129
hierarchy by the way I woke up today

00:23:23,899 --> 00:23:31,340
with a cold this is a little rough

00:23:25,129 --> 00:23:33,109
please excuse my voice the the groupings

00:23:31,340 --> 00:23:35,690
of the intermediate classes might work

00:23:33,109 --> 00:23:41,149
well for certain behaviors and not so

00:23:35,690 --> 00:23:42,350
good for other behaviors one of the ways

00:23:41,149 --> 00:23:45,049
in which class hierarchies are

00:23:42,350 --> 00:23:46,940
classically brittle is that they're

00:23:45,049 --> 00:23:51,679
designed around some set of behaviors

00:23:46,940 --> 00:23:54,470
and then new behaviors come and it's

00:23:51,679 --> 00:23:57,139
just not well laid out for them or and

00:23:54,470 --> 00:24:02,539
this happened to me while I was working

00:23:57,139 --> 00:24:04,340
on MSI L and Microsoft we had two

00:24:02,539 --> 00:24:06,109
perfectly good ways to layout the class

00:24:04,340 --> 00:24:10,039
hierarchy depending on which set of

00:24:06,109 --> 00:24:11,869
functions were your favorite so if you

00:24:10,039 --> 00:24:13,879
have that situation you choose one or

00:24:11,869 --> 00:24:16,100
the other it's almost always the wrong

00:24:13,879 --> 00:24:17,629
thing to do you should really choose

00:24:16,100 --> 00:24:18,980
neither of them or both of them but

00:24:17,629 --> 00:24:20,389
favoring one over the other for no

00:24:18,980 --> 00:24:22,279
particular reason just will eventually

00:24:20,389 --> 00:24:23,840
bite you the problem is when you need to

00:24:22,279 --> 00:24:25,999
do that you need to now talk about

00:24:23,840 --> 00:24:29,179
virtual inheritance and establishing

00:24:25,999 --> 00:24:33,549
diamonds in order to not favor one over

00:24:29,179 --> 00:24:35,509
the other and that just gets horrible so

00:24:33,549 --> 00:24:37,129
dispatch goes down in terms of

00:24:35,509 --> 00:24:39,470
efficiency and it becomes hard to

00:24:37,129 --> 00:24:41,179
maintain you can't do complicated

00:24:39,470 --> 00:24:45,769
constructors very easily it's just a

00:24:41,179 --> 00:24:48,289
mess so in this case what you can do is

00:24:45,769 --> 00:24:50,840
in your overloaded lambda you can choose

00:24:48,289 --> 00:24:55,909
to use generics or possibly even

00:24:50,840 --> 00:24:57,499
concepts to group your handlers such

00:24:55,909 --> 00:25:00,879
that they will handle the members of the

00:24:57,499 --> 00:25:00,879
Union differently for example

00:25:12,140 --> 00:25:18,510
so we have some simple ones and here I'm

00:25:16,860 --> 00:25:20,850
suggesting that these are actually on

00:25:18,510 --> 00:25:22,230
separate header files because this would

00:25:20,850 --> 00:25:23,850
be the way you would roll in a large

00:25:22,230 --> 00:25:27,960
project so that you could work on your

00:25:23,850 --> 00:25:30,480
finals as separate modules their own

00:25:27,960 --> 00:25:31,890
unit tests all of their stuff belongs to

00:25:30,480 --> 00:25:34,410
them and they don't know anything about

00:25:31,890 --> 00:25:36,930
each other so we've got dog

00:25:34,410 --> 00:25:39,870
we've got cat leave that verse and then

00:25:36,930 --> 00:25:42,330
we decide to make animal animal depends

00:25:39,870 --> 00:25:45,720
on them and then creates the Union and

00:25:42,330 --> 00:25:48,900
we could add behaviors now about how we

00:25:45,720 --> 00:25:52,380
like to group virtual behaviors out of

00:25:48,900 --> 00:25:55,320
animals so animals all make sounds

00:25:52,380 --> 00:25:58,920
animals all interact with people how we

00:25:55,320 --> 00:26:01,980
group these classes to do that would

00:25:58,920 --> 00:26:03,360
depend so we might have like we want to

00:26:01,980 --> 00:26:06,990
deal with the dog and the cat together

00:26:03,360 --> 00:26:09,000
as house pets and the horse separately

00:26:06,990 --> 00:26:11,370
for some things because it's big we

00:26:09,000 --> 00:26:13,410
might want to group the dog and the

00:26:11,370 --> 00:26:15,690
horse together for some things because

00:26:13,410 --> 00:26:19,230
we like them and the cat separately

00:26:15,690 --> 00:26:22,200
because we don't like the cat so the

00:26:19,230 --> 00:26:23,940
individual algorithm decides how it

00:26:22,200 --> 00:26:27,110
wants to handle things by creating its

00:26:23,940 --> 00:26:34,770
own generic projections at that point

00:26:27,110 --> 00:26:36,150
okay so this is that was what I meant by

00:26:34,770 --> 00:26:39,210
variance can be more flexible than

00:26:36,150 --> 00:26:41,760
hierarchies variance can be easier to

00:26:39,210 --> 00:26:43,650
maintain than hierarchies as I said you

00:26:41,760 --> 00:26:45,360
build all your final types first just

00:26:43,650 --> 00:26:48,120
like this they don't know about each

00:26:45,360 --> 00:26:50,130
other they don't share concerns your

00:26:48,120 --> 00:26:52,110
designs flow from the specific to the

00:26:50,130 --> 00:26:53,580
general instead of the other way around

00:26:52,110 --> 00:26:55,560
right when you're designing a class

00:26:53,580 --> 00:26:57,630
hierarchy you start with this most

00:26:55,560 --> 00:26:59,430
general thing and you start drilling

00:26:57,630 --> 00:27:01,080
down to the specifics and you might know

00:26:59,430 --> 00:27:03,420
that would know very much about the

00:27:01,080 --> 00:27:04,830
general when you start and you may

00:27:03,420 --> 00:27:07,290
change your mind later about what the

00:27:04,830 --> 00:27:08,730
generalities really are and kind of like

00:27:07,290 --> 00:27:11,240
jacking up the entire class hierarchy

00:27:08,730 --> 00:27:11,240
isn't any fun

00:27:12,480 --> 00:27:29,790
we're talking about sorry well templates

00:27:25,470 --> 00:27:32,460
are great so we can use abstract lambda

00:27:29,790 --> 00:27:36,300
we can use a generic lambda rather so

00:27:32,460 --> 00:27:37,560
for example the the mechanism the

00:27:36,300 --> 00:27:39,390
question is about how to use the

00:27:37,560 --> 00:27:42,390
mechanism of the lambda to do the

00:27:39,390 --> 00:27:46,770
groupings so the simplest case is use

00:27:42,390 --> 00:27:50,220
Auto basically you'd written default if

00:27:46,770 --> 00:27:53,540
you do have hierarchy you know

00:27:50,220 --> 00:27:55,530
membership they can be nothing but tags

00:27:53,540 --> 00:27:57,180
right the type is transparently

00:27:55,530 --> 00:28:00,450
convertible into a group you can add it

00:27:57,180 --> 00:28:02,280
later it does nothing it doesn't hurt

00:28:00,450 --> 00:28:06,630
you and then you can transfer you can

00:28:02,280 --> 00:28:11,990
behave off of those if you wish you can

00:28:06,630 --> 00:28:14,580
also well it's also possible to use SMA

00:28:11,990 --> 00:28:17,700
if we look up something in the dependent

00:28:14,580 --> 00:28:18,620
scope and then we will either specialize

00:28:17,700 --> 00:28:22,070
or not

00:28:18,620 --> 00:28:24,770
so our instantiate or non rather sorry

00:28:22,070 --> 00:28:27,750
but that was that's a little trickier

00:28:24,770 --> 00:28:29,310
I'm not sure you would do that for

00:28:27,750 --> 00:28:34,590
example if you're super interested in

00:28:29,310 --> 00:28:36,330
job security well that's why concepts

00:28:34,590 --> 00:28:40,050
are coming so we can do stuff like this

00:28:36,330 --> 00:28:45,830
and it does we've tried that it does

00:28:40,050 --> 00:28:49,440
work pretty well so easier to maintain

00:28:45,830 --> 00:28:52,980
working from the thank you working from

00:28:49,440 --> 00:28:55,530
the from the specific to the general

00:28:52,980 --> 00:28:58,470
also grounds your initial work in the

00:28:55,530 --> 00:29:01,440
problem space most of the time right dog

00:28:58,470 --> 00:29:03,390
cat and horse are things we can compare

00:29:01,440 --> 00:29:04,710
them to real things in the real problem

00:29:03,390 --> 00:29:06,810
space and decide if this is a good

00:29:04,710 --> 00:29:08,820
representation of a dog or a cat or a

00:29:06,810 --> 00:29:11,970
horse and then when we move toward the

00:29:08,820 --> 00:29:14,780
abstract we move toward the abstract we

00:29:11,970 --> 00:29:18,630
do it by collection it's it's better

00:29:14,780 --> 00:29:22,610
better match for the way human brains

00:29:18,630 --> 00:29:22,610
generally work by cognitive clustering

00:29:23,520 --> 00:29:41,680
it's also possible to do this so here we

00:29:36,040 --> 00:29:44,290
have car and plane and horse and we

00:29:41,680 --> 00:29:48,330
collect them into transport the same

00:29:44,290 --> 00:29:53,620
same idea except that's the same horse

00:29:48,330 --> 00:29:57,100
so this is the equivalent of multiple

00:29:53,620 --> 00:29:58,750
inheritance without the possibility of

00:29:57,100 --> 00:30:01,150
the class hierarchies poisoning each

00:29:58,750 --> 00:30:06,780
other right nothing is leaking back and

00:30:01,150 --> 00:30:06,780
forth the horse is horse of course

00:30:09,000 --> 00:30:15,670
design the whole talk are on that line

00:30:12,330 --> 00:30:18,910
in in either case and it would be

00:30:15,670 --> 00:30:20,440
possible even to do a transfer from one

00:30:18,910 --> 00:30:22,630
and this is something we'll show you

00:30:20,440 --> 00:30:25,720
possibly later if you have time

00:30:22,630 --> 00:30:30,370
it's a run time type check to move from

00:30:25,720 --> 00:30:32,770
one variant family to another if they

00:30:30,370 --> 00:30:34,900
have states it in common if you're

00:30:32,770 --> 00:30:36,190
moving from a subset to a superset it's

00:30:34,900 --> 00:30:38,740
not even a runtime type check that's

00:30:36,190 --> 00:30:41,200
just okay if they don't have states in

00:30:38,740 --> 00:30:42,880
common then it's a static error because

00:30:41,200 --> 00:30:46,480
it's clear that that assignment that

00:30:42,880 --> 00:30:49,660
know would never make sense so it's much

00:30:46,480 --> 00:30:51,580
easier to work with these guys where a

00:30:49,660 --> 00:30:54,370
horse or whatever your final types are

00:30:51,580 --> 00:30:56,260
being reused in various groupings than

00:30:54,370 --> 00:30:58,030
to try to figure out how to make virtual

00:30:56,260 --> 00:31:04,690
based classes work properly in multiple

00:30:58,030 --> 00:31:06,250
inheritance I think so I've said a

00:31:04,690 --> 00:31:09,670
couple of times that if you use the null

00:31:06,250 --> 00:31:12,250
state this behaves the semantics are

00:31:09,670 --> 00:31:15,430
virtually identical to carrying around a

00:31:12,250 --> 00:31:19,840
base pointer into the class hierarchy so

00:31:15,430 --> 00:31:20,500
if I can have car or plane or a horse or

00:31:19,840 --> 00:31:24,010
nothing

00:31:20,500 --> 00:31:26,350
then I'm actually it's like this is

00:31:24,010 --> 00:31:27,700
transport star and you just have to have

00:31:26,350 --> 00:31:30,600
one additional Handler and all your

00:31:27,700 --> 00:31:32,100
algorithms for the null case

00:31:30,600 --> 00:31:34,260
you can also check for the null

00:31:32,100 --> 00:31:35,730
explicitly because we added methods to

00:31:34,260 --> 00:31:40,169
the interface of variant that only show

00:31:35,730 --> 00:31:42,990
up when null is there the difference is

00:31:40,169 --> 00:31:44,850
this is a value type so you're not

00:31:42,990 --> 00:31:47,429
carrying around a base pointer you're

00:31:44,850 --> 00:31:50,250
not doing a heap allocation right you're

00:31:47,429 --> 00:31:52,320
not in general doing anything that's

00:31:50,250 --> 00:31:54,210
involving and directing it's a value

00:31:52,320 --> 00:32:02,429
type it just has the semantics of a base

00:31:54,210 --> 00:32:05,400
pointer so if we have this possibly

00:32:02,429 --> 00:32:09,210
nothing state then the simplest case is

00:32:05,400 --> 00:32:12,030
we have something or nothing so we could

00:32:09,210 --> 00:32:15,570
have a template of a variant where

00:32:12,030 --> 00:32:18,419
variant is T or nothing which would be

00:32:15,570 --> 00:32:21,179
optional it has basically all the same

00:32:18,419 --> 00:32:23,820
semantics is optional it's just a little

00:32:21,179 --> 00:32:30,630
bit more general so we could be a T or

00:32:23,820 --> 00:32:33,990
ru or nothing for example in the case

00:32:30,630 --> 00:32:36,960
where we are bool or nothing then we are

00:32:33,990 --> 00:32:39,150
actually tri-state booth where you can

00:32:36,960 --> 00:32:41,940
interpret the nothing as I don't know

00:32:39,150 --> 00:32:45,360
for example and we could overload and an

00:32:41,940 --> 00:32:47,340
or and not to give you tri-state logic

00:32:45,360 --> 00:32:51,330
that works across this perfectly well

00:32:47,340 --> 00:32:53,520
and because we know null isn't the same

00:32:51,330 --> 00:32:56,850
null across all the different unions

00:32:53,520 --> 00:33:00,059
then we could do comparisons that give

00:32:56,850 --> 00:33:02,850
rise to tri-state pools that just work

00:33:00,059 --> 00:33:05,870
and so for example if we're using

00:33:02,850 --> 00:33:09,539
optional int that's the same as a

00:33:05,870 --> 00:33:11,610
database nullable field so we pull in

00:33:09,539 --> 00:33:15,179
someone's age from the database maybe we

00:33:11,610 --> 00:33:20,850
don't know it we get optional int or int

00:33:15,179 --> 00:33:24,600
or nothing and then we compare it to

00:33:20,850 --> 00:33:26,309
some number we get optional bool and we

00:33:24,600 --> 00:33:27,480
can then do that with an and of some

00:33:26,309 --> 00:33:28,890
other comparison where we get another

00:33:27,480 --> 00:33:33,929
optional bool and it all just sort of

00:33:28,890 --> 00:33:35,070
percolates up and it just works and then

00:33:33,929 --> 00:33:37,950
of course when you actually try to use

00:33:35,070 --> 00:33:41,370
that and if for a while you get their

00:33:37,950 --> 00:33:44,000
own type but at the top you have to

00:33:41,370 --> 00:33:44,000
check what it really is

00:33:44,580 --> 00:33:51,430
the boost version of variant explicitly

00:33:50,080 --> 00:33:55,450
doesn't do this they said if you want to

00:33:51,430 --> 00:33:57,850
be no you should define your annul I I

00:33:55,450 --> 00:34:00,900
didn't really like that very much I

00:33:57,850 --> 00:34:04,420
think having a single definition of null

00:34:00,900 --> 00:34:06,850
enables what I just described with the

00:34:04,420 --> 00:34:09,159
contagiousness of null when you're doing

00:34:06,850 --> 00:34:14,740
operations across multiple nullable

00:34:09,159 --> 00:34:16,899
types another interesting point here by

00:34:14,740 --> 00:34:19,419
the way is if we replace null with an

00:34:16,899 --> 00:34:22,149
exception pointer so it's T or exception

00:34:19,419 --> 00:34:26,470
pointer then this is another Alexander s

00:34:22,149 --> 00:34:28,450
Q special expects so we can implement

00:34:26,470 --> 00:34:30,090
expects as a variant and it just works

00:34:28,450 --> 00:34:33,669
I generally think it would be better to

00:34:30,090 --> 00:34:36,070
implement these guys as variants rather

00:34:33,669 --> 00:34:44,310
than reimplemented type erasure behavior

00:34:36,070 --> 00:34:44,310
over and over so on to the next trick

00:34:46,510 --> 00:34:54,260
so let's go back to our shape example I

00:34:49,070 --> 00:34:57,740
like shape I want to function takes two

00:34:54,260 --> 00:35:00,700
shapes returns bool true or false do

00:34:57,740 --> 00:35:00,700
these two shapes intersect

00:35:02,230 --> 00:35:11,270
can anybody immediately see why this

00:35:04,640 --> 00:35:12,800
problem sucks uh-huh yeah so

00:35:11,270 --> 00:35:15,110
intersecting a circle with the circle is

00:35:12,800 --> 00:35:16,790
easy or a circle with a square or a

00:35:15,110 --> 00:35:18,560
circle with a triangle or a square with

00:35:16,790 --> 00:35:21,500
a triangle or as long as you know what

00:35:18,560 --> 00:35:22,820
both of them are we know what to do but

00:35:21,500 --> 00:35:25,520
we have to know what both of them are

00:35:22,820 --> 00:35:28,700
being polymorphic on one of the shapes

00:35:25,520 --> 00:35:30,910
still leaves us with the damn shape that

00:35:28,700 --> 00:35:33,200
we don't man we don't know what it is so

00:35:30,910 --> 00:35:36,020
this in general is the multi method

00:35:33,200 --> 00:35:38,270
problem and there are a handful of

00:35:36,020 --> 00:35:46,730
languages that solve this tidally for

00:35:38,270 --> 00:35:52,240
you Oh camel cielos end of list

00:35:46,730 --> 00:35:52,240
I think C++ and not so much

00:36:01,650 --> 00:36:11,270
this is one of the prettiest things I've

00:36:03,359 --> 00:36:14,130
ever seen so you can dispatch

00:36:11,270 --> 00:36:15,960
multi-method on variance so we will be

00:36:14,130 --> 00:36:19,470
polymorphic on more than one thing

00:36:15,960 --> 00:36:23,039
instead of having this you have an array

00:36:19,470 --> 00:36:25,140
of these and we will work out what all

00:36:23,039 --> 00:36:26,940
of the types are of all of these before

00:36:25,140 --> 00:36:29,460
we dispatch to the correct Handler and

00:36:26,940 --> 00:36:31,529
this is another case where you can

00:36:29,460 --> 00:36:34,410
collapse you can generally collapse a

00:36:31,529 --> 00:36:36,690
lot of cases because intersecting left

00:36:34,410 --> 00:36:39,660
circle with right square is the same as

00:36:36,690 --> 00:36:44,549
intersecting right circle with left

00:36:39,660 --> 00:36:46,710
square that cast off so you don't

00:36:44,549 --> 00:36:49,859
actually wind up N squared most of the

00:36:46,710 --> 00:36:51,270
time but it's nice that you can and the

00:36:49,859 --> 00:36:54,390
entire algorithm is right in front of

00:36:51,270 --> 00:36:58,170
you all of the dispatch machinery is

00:36:54,390 --> 00:37:02,130
just locked away inside of a variant and

00:36:58,170 --> 00:37:03,450
you never have to see it so I just kind

00:37:02,130 --> 00:37:06,109
of like to soak that one in for a minute

00:37:03,450 --> 00:37:06,109
because I think it's beautiful

00:37:09,559 --> 00:37:18,930
no I'm glad you asked the question is

00:37:14,579 --> 00:37:22,730
are we limited to two era T - no you

00:37:18,930 --> 00:37:25,619
know as far as you want in practice I

00:37:22,730 --> 00:37:29,039
already one common already two common

00:37:25,619 --> 00:37:31,740
and then there is a sharp decline and

00:37:29,039 --> 00:37:36,210
let me explain this whole thing comes up

00:37:31,740 --> 00:37:37,589
because I'm a compiler guy and when I'm

00:37:36,210 --> 00:37:40,470
trying to figure out the type of an

00:37:37,589 --> 00:37:41,910
infix operation and I need to know the

00:37:40,470 --> 00:37:42,359
type it's based on the types of both

00:37:41,910 --> 00:37:50,369
sides

00:37:42,359 --> 00:37:52,910
he's one of these it's so good the

00:37:50,369 --> 00:37:58,109
number of ternary operators in C is

00:37:52,910 --> 00:38:00,960
small and the dependence of the output

00:37:58,109 --> 00:38:04,260
type actually doesn't care about the

00:38:00,960 --> 00:38:06,750
first one so we're hard-pressed to

00:38:04,260 --> 00:38:10,160
actually come up with a true ternary

00:38:06,750 --> 00:38:15,960
operator where all three types matter

00:38:10,160 --> 00:38:17,099
possible there are cases I bet but one

00:38:15,960 --> 00:38:21,119
thing that would be interesting to note

00:38:17,099 --> 00:38:23,180
here is this is shape shape you don't

00:38:21,119 --> 00:38:30,660
actually have to be homogeneously

00:38:23,180 --> 00:38:33,740
multi-method if you need to take your

00:38:30,660 --> 00:38:37,049
animal for a ride we need to know about

00:38:33,740 --> 00:38:41,309
your transport and your animal at the

00:38:37,049 --> 00:38:43,920
same time so this is Mike's example I

00:38:41,309 --> 00:38:46,859
think it's really cute any of these

00:38:43,920 --> 00:38:48,660
cases we have problems of course won't

00:38:46,859 --> 00:38:51,480
fit in the car we can't put the animal

00:38:48,660 --> 00:38:54,210
in the plane putting a horse on a horse

00:38:51,480 --> 00:38:58,920
is dumb and that's possible because

00:38:54,210 --> 00:39:01,170
horses in both right and everything else

00:38:58,920 --> 00:39:16,650
is fine and the auto just eats the other

00:39:01,170 --> 00:39:21,170
cases I think that's really sexy so this

00:39:16,650 --> 00:39:25,859
this code uses c++ 14 require c++ xiv

00:39:21,170 --> 00:39:27,920
for a very small number of things we

00:39:25,859 --> 00:39:30,960
could do without

00:39:27,920 --> 00:39:34,680
in particular when we're doing the apply

00:39:30,960 --> 00:39:37,140
inside of the the applier the thing that

00:39:34,680 --> 00:39:40,710
inherits from the visitor and does the

00:39:37,140 --> 00:39:43,589
dispatch we use tupple apply in order to

00:39:40,710 --> 00:39:46,529
unwind to the thing which uses the trick

00:39:43,589 --> 00:39:50,369
where we're going to expand a parameter

00:39:46,529 --> 00:39:54,440
pack of integer indices so you know the

00:39:50,369 --> 00:39:57,359
the index sequence stuff that's in 14

00:39:54,440 --> 00:39:58,739
but you can write that in 11 it just

00:39:57,359 --> 00:40:01,769
didn't make it into the standard library

00:39:58,739 --> 00:40:03,089
just like we're using some 17 things in

00:40:01,769 --> 00:40:04,470
this head etre in this header you know

00:40:03,089 --> 00:40:10,920
you could we could make this whole thing

00:40:04,470 --> 00:40:16,569
work with 11 very easily I just mmm

00:40:10,920 --> 00:40:18,039
yeah but the way this works there are a

00:40:16,569 --> 00:40:20,019
few cases where you might not want to

00:40:18,039 --> 00:40:22,119
use overloaded lambda anyway where you

00:40:20,019 --> 00:40:26,109
have a functor object that does more

00:40:22,119 --> 00:40:26,529
stuff that entry point is actually still

00:40:26,109 --> 00:40:28,900
here

00:40:26,529 --> 00:40:31,029
so if you just want to define our own

00:40:28,900 --> 00:40:33,430
functor and fly or if you really want to

00:40:31,029 --> 00:40:35,440
use your own visitor you can't but

00:40:33,430 --> 00:40:38,519
dispatches the same times so one one

00:40:35,440 --> 00:40:43,240
cautionary note about multi dispatch

00:40:38,519 --> 00:40:47,289
this is not the fastest horse in the

00:40:43,240 --> 00:40:49,359
plane you are going through multiple

00:40:47,289 --> 00:40:52,569
levels of dispatch in order to unwind

00:40:49,359 --> 00:40:55,660
this operation as we discover what type

00:40:52,569 --> 00:40:57,130
is on the left we cache a reference to

00:40:55,660 --> 00:40:59,259
it discover the next one cache a

00:40:57,130 --> 00:41:00,640
reference to it build up a couple of

00:40:59,259 --> 00:41:04,690
references to everything and then

00:41:00,640 --> 00:41:08,799
eventually push it through it's a lot of

00:41:04,690 --> 00:41:11,710
steps so in general this kind of

00:41:08,799 --> 00:41:15,210
dispatch is no faster than half as fast

00:41:11,710 --> 00:41:19,749
as a virtual function and in general is

00:41:15,210 --> 00:41:21,549
somewhat worse than that however if you

00:41:19,749 --> 00:41:22,900
turn on like full buggy optimization

00:41:21,549 --> 00:41:25,480
whole program optimization D

00:41:22,900 --> 00:41:27,819
virtualizing in a lot of cases we know

00:41:25,480 --> 00:41:30,789
what these types are so the first level

00:41:27,819 --> 00:41:32,289
of divert realization goes away or the

00:41:30,789 --> 00:41:36,160
first level of a virtual function goes

00:41:32,289 --> 00:41:38,980
away so it's not horrible this is not

00:41:36,160 --> 00:41:41,950
what you would do in the tightest of

00:41:38,980 --> 00:41:45,150
loops where you have extremely tight

00:41:41,950 --> 00:41:45,150
performance considerations

00:41:47,170 --> 00:41:59,980
all right so when do we do all this

00:41:51,970 --> 00:42:01,750
stuff why would we use it and so I've

00:41:59,980 --> 00:42:07,809
ever tried to create a pure virtual

00:42:01,750 --> 00:42:10,599
templatized function boy that would be

00:42:07,809 --> 00:42:12,280
nice when of course we can't do that

00:42:10,599 --> 00:42:15,609
because the vtable needs to be a finite

00:42:12,280 --> 00:42:20,190
size so the trick is that we use a

00:42:15,609 --> 00:42:23,619
virtual function but we pass unions

00:42:20,190 --> 00:42:27,809
variants or we we return variants or

00:42:23,619 --> 00:42:30,630
both so we solve the generousity first

00:42:27,809 --> 00:42:32,740
all right by taking whatever the type is

00:42:30,630 --> 00:42:34,990
stuffing it into something that makes it

00:42:32,740 --> 00:42:36,970
homogeneous and then we dispatch

00:42:34,990 --> 00:42:41,500
polymorphically on that and on the other

00:42:36,970 --> 00:42:45,220
side we visited with a functor so you

00:42:41,500 --> 00:42:46,839
can for example create meta access

00:42:45,220 --> 00:42:49,900
functions for your data structures to

00:42:46,839 --> 00:42:53,170
say like I want to access a field by

00:42:49,900 --> 00:42:56,799
name at runtime like the cool kids over

00:42:53,170 --> 00:42:58,270
in Java town you can do that we don't

00:42:56,799 --> 00:42:59,559
know what the type of the field is so

00:42:58,270 --> 00:43:06,400
we'll have to return you some kind of a

00:42:59,559 --> 00:43:10,150
union we can take a regular container

00:43:06,400 --> 00:43:11,940
and turn it into a generic container by

00:43:10,150 --> 00:43:14,109
having a contain unions for example

00:43:11,940 --> 00:43:17,970
what's the difference between a vector

00:43:14,109 --> 00:43:17,970
of unions or a tuple

00:43:25,140 --> 00:43:34,670
ordering so what's the difference

00:43:30,660 --> 00:43:37,670
between a map of string to Union and

00:43:34,670 --> 00:43:37,670
struct

00:43:44,230 --> 00:43:56,900
thank you yeah so speed you the the

00:43:54,230 --> 00:43:58,670
tupple and the struct our results

00:43:56,900 --> 00:44:00,560
statically we're going to resolve some

00:43:58,670 --> 00:44:04,270
things dynamically in the case of the

00:44:00,560 --> 00:44:07,370
containers full of unions but you get

00:44:04,270 --> 00:44:09,830
you know something a little closer what

00:44:07,370 --> 00:44:11,660
a scripting language can do it's not

00:44:09,830 --> 00:44:13,520
always what you want to do you know

00:44:11,660 --> 00:44:16,550
where C++ where systems programming

00:44:13,520 --> 00:44:19,730
language but it's nice to be able to do

00:44:16,550 --> 00:44:20,780
script D things without having to bleed

00:44:19,730 --> 00:44:23,240
out the eyes for it

00:44:20,780 --> 00:44:26,870
like everything else we do in C++ so in

00:44:23,240 --> 00:44:30,260
this case for example if I have a config

00:44:26,870 --> 00:44:32,090
file I can read in my config file very

00:44:30,260 --> 00:44:34,760
straightforwardly make a dictionary and

00:44:32,090 --> 00:44:38,150
mapping of named values to unions of

00:44:34,760 --> 00:44:40,670
their possible actual States and just

00:44:38,150 --> 00:44:44,060
fly with it all right so these are it's

00:44:40,670 --> 00:44:46,970
really handy for processing things from

00:44:44,060 --> 00:44:48,170
the outside world it's also handy when

00:44:46,970 --> 00:44:50,090
you're going over a string based

00:44:48,170 --> 00:44:52,520
interface and string based API like a

00:44:50,090 --> 00:44:55,100
rest interface because we're going to

00:44:52,520 --> 00:44:57,740
parse a bunch of stuff find out what the

00:44:55,100 --> 00:44:59,120
types are and stuff it all away into

00:44:57,740 --> 00:45:00,410
some kind of container that associate

00:44:59,120 --> 00:45:02,780
associate some values with their names

00:45:00,410 --> 00:45:07,220
and dispatch it into a handler that will

00:45:02,780 --> 00:45:10,880
worry about it all later so this is

00:45:07,220 --> 00:45:12,380
handy in general you can do this

00:45:10,880 --> 00:45:19,090
anywhere you want to do type aeration

00:45:12,380 --> 00:45:21,410
anywhere you would use any any is I

00:45:19,090 --> 00:45:23,540
would go say I would say any as more

00:45:21,410 --> 00:45:31,990
than type erasure any is type

00:45:23,540 --> 00:45:39,710
obliteration any is almost a void star

00:45:31,990 --> 00:45:42,770
so I think of Union as please step away

00:45:39,710 --> 00:45:44,990
from the void star think about it decide

00:45:42,770 --> 00:45:49,220
what your finite universe of types

00:45:44,990 --> 00:45:51,050
really is and then use a union instead

00:45:49,220 --> 00:45:52,850
of just leaving the entire universe open

00:45:51,050 --> 00:45:54,710
with any now there are a few cases where

00:45:52,850 --> 00:45:57,790
you really do have an infinite universe

00:45:54,710 --> 00:46:02,570
of types by all means use any

00:45:57,790 --> 00:46:05,600
but most of the time you know so I think

00:46:02,570 --> 00:46:07,070
variant deserves more love I think it's

00:46:05,600 --> 00:46:11,030
a good model for future proofing your

00:46:07,070 --> 00:46:13,670
code because when we make the changes in

00:46:11,030 --> 00:46:15,980
17 or 20 where the build model will

00:46:13,670 --> 00:46:17,690
change and we'll be able to do whole

00:46:15,980 --> 00:46:21,950
program compilation and things like

00:46:17,690 --> 00:46:23,590
partial classes then this jazz becomes

00:46:21,950 --> 00:46:25,910
real vtable

00:46:23,590 --> 00:46:28,400
right because I can take tech switches

00:46:25,910 --> 00:46:31,190
and as I reassemble the whole program I

00:46:28,400 --> 00:46:36,110
can put all the pieces together and make

00:46:31,190 --> 00:46:38,870
one big retail level so right now this

00:46:36,110 --> 00:46:41,090
cost you extra dispatch right now this

00:46:38,870 --> 00:46:43,460
is convenience to the programmer that

00:46:41,090 --> 00:46:45,020
cost you runtime when we change the

00:46:43,460 --> 00:46:52,540
build model that might not be the case

00:46:45,020 --> 00:46:52,540
anymore so it's alright I'm done

00:46:53,770 --> 00:46:59,690
it makes your projects easier to design

00:46:56,750 --> 00:47:01,280
easier to maintain it does sophisticated

00:46:59,690 --> 00:47:05,060
tricks like multi method while remaining

00:47:01,280 --> 00:47:07,820
very terse and very readable our

00:47:05,060 --> 00:47:13,250
implementation is certainly not the only

00:47:07,820 --> 00:47:15,590
possible one but it's short and I think

00:47:13,250 --> 00:47:19,940
it's we wrote it so that it was actually

00:47:15,590 --> 00:47:21,530
be comprehensible it's by which I mean

00:47:19,940 --> 00:47:23,690
it's not written like anything in boost

00:47:21,530 --> 00:47:28,040
okay I'm done I'm not gonna be mean to

00:47:23,690 --> 00:47:29,900
boost down that need to be backward

00:47:28,040 --> 00:47:31,100
compatible to the universe and portable

00:47:29,900 --> 00:47:33,830
and everything it's just like makes code

00:47:31,100 --> 00:47:37,580
really hard to read I think this isn't

00:47:33,830 --> 00:47:39,770
like that so even if this particular

00:47:37,580 --> 00:47:41,150
implementation is purely a teaching

00:47:39,770 --> 00:47:43,400
experience and you guys go implement

00:47:41,150 --> 00:47:46,340
your own and until the standard one

00:47:43,400 --> 00:47:49,600
comes out I still think it's a useful

00:47:46,340 --> 00:47:52,600
idea so anybody that's kind of it

00:47:49,600 --> 00:47:52,600
questions

00:47:53,250 --> 00:48:15,570
github jason el 9000 / CPP con 14 on the

00:48:11,080 --> 00:48:19,750
on the performance issue if I I knew it

00:48:15,570 --> 00:48:23,920
if I implement a a sort of variant based

00:48:19,750 --> 00:48:25,540
design and I discover that you know I'm

00:48:23,920 --> 00:48:28,600
doing I I wind up having you know a

00:48:25,540 --> 00:48:31,270
multi dispatch inside the a hot loop or

00:48:28,600 --> 00:48:35,950
something like that do I have any sort

00:48:31,270 --> 00:48:37,750
of localized options for improving the

00:48:35,950 --> 00:48:41,590
performance of that without tearing

00:48:37,750 --> 00:48:44,260
apart my my whole design uh yeah you can

00:48:41,590 --> 00:48:49,150
fall back to what we do with any which

00:48:44,260 --> 00:48:54,520
is go fish there's a try as interface on

00:48:49,150 --> 00:48:55,990
variant thank you where you can say like

00:48:54,520 --> 00:48:57,670
well if this one actually is a strength

00:48:55,990 --> 00:49:00,070
that I'm just gonna NAB it and go off

00:48:57,670 --> 00:49:03,580
and do stuff so if you can early resolve

00:49:00,070 --> 00:49:07,210
the type there's another thing to the

00:49:03,580 --> 00:49:08,650
lambdas don't have to be short and by

00:49:07,210 --> 00:49:10,390
short I don't mean lexically short I

00:49:08,650 --> 00:49:13,840
mean their stacks don't have to be short

00:49:10,390 --> 00:49:16,750
so once you resolve what the type is you

00:49:13,840 --> 00:49:18,790
can then go jump into a whole separate

00:49:16,750 --> 00:49:20,860
module whole separate library that just

00:49:18,790 --> 00:49:24,970
deals with dog or just deals with horse

00:49:20,860 --> 00:49:26,200
and the virtual dispatch is over right

00:49:24,970 --> 00:49:27,940
the other thing we're not showing here

00:49:26,200 --> 00:49:30,610
is it doesn't have to be a constant

00:49:27,940 --> 00:49:34,990
reference you can have a mutating

00:49:30,610 --> 00:49:37,930
visitor so that's really comes up when

00:49:34,990 --> 00:49:39,610
you do have long lives visitation so and

00:49:37,930 --> 00:49:40,930
at that point you really absolutely no

00:49:39,610 --> 00:49:44,830
worse off than any other technique you

00:49:40,930 --> 00:49:47,010
paid the price exactly once Thanks yes

00:49:44,830 --> 00:49:47,010
sir

00:49:51,420 --> 00:49:56,590
aha

00:49:52,840 --> 00:49:58,990
so boost it uses a separate type for

00:49:56,590 --> 00:50:02,410
recursive Marines sort of the poster

00:49:58,990 --> 00:50:05,050
child for this is expression so infix is

00:50:02,410 --> 00:50:06,130
a kind of expression and expression is a

00:50:05,050 --> 00:50:09,400
union of a bunch of other things

00:50:06,130 --> 00:50:11,550
including in fix and in fix has two

00:50:09,400 --> 00:50:15,609
expressions in it left child right job

00:50:11,550 --> 00:50:17,800
so we solve this by going back just

00:50:15,609 --> 00:50:19,630
recognizing that the union with a

00:50:17,800 --> 00:50:23,590
nullable in it is the same as a base

00:50:19,630 --> 00:50:26,440
pointer so what we aggregate in in fix

00:50:23,590 --> 00:50:28,720
is pointer to expression pointer to

00:50:26,440 --> 00:50:30,220
expression right and we can have a

00:50:28,720 --> 00:50:32,560
forward declaration of expression at

00:50:30,220 --> 00:50:38,410
that point that we finalize eventually

00:50:32,560 --> 00:50:44,770
with the Union so exactly the same thing

00:50:38,410 --> 00:50:56,560
you would do if it weren't Union yeah we

00:50:44,770 --> 00:50:59,109
do in fact so my my backups live if I

00:50:56,560 --> 00:51:03,280
had slides here's an entire language

00:50:59,109 --> 00:51:06,400
interpreter written with yeah simple

00:51:03,280 --> 00:51:09,250
calculator written with a union for

00:51:06,400 --> 00:51:12,130
values and union for expressions and it

00:51:09,250 --> 00:51:19,440
actually works so and it's actually

00:51:12,130 --> 00:51:21,790
pretty short considering yeah well I

00:51:19,440 --> 00:51:23,230
didn't have as much time before this

00:51:21,790 --> 00:51:26,830
conference as I thought I was going to

00:51:23,230 --> 00:51:28,599
huh I try to remember to go in and

00:51:26,830 --> 00:51:38,250
comment things and so I leave nag

00:51:28,599 --> 00:51:38,250
messages for myself so for example

00:51:39,890 --> 00:51:45,720
sir yeah I have a question if is it

00:51:43,470 --> 00:51:47,579
possible to start by type I mean I

00:51:45,720 --> 00:51:51,150
wanted to deal with all the dogs at once

00:51:47,579 --> 00:51:53,789
in order at once in order yes so you can

00:51:51,150 --> 00:51:56,400
define for example a strict week

00:51:53,789 --> 00:51:59,460
ordering operator like less than on

00:51:56,400 --> 00:52:01,079
variant and then decide that all dogs

00:51:59,460 --> 00:52:03,059
come before all cats come before all

00:52:01,079 --> 00:52:06,569
horses and then among dogs you sort by

00:52:03,059 --> 00:52:09,710
breed or whatever so you can you can

00:52:06,569 --> 00:52:24,599
impose all kinds of collective behavior

00:52:09,710 --> 00:52:26,690
thank you are there you need to speak up

00:52:24,599 --> 00:52:26,690
a little

00:52:28,400 --> 00:52:32,819
the question is are there tag index

00:52:30,869 --> 00:52:34,200
unions instead of type index unions I

00:52:32,819 --> 00:52:36,559
don't know what I'm not sure I

00:52:34,200 --> 00:52:36,559
understand

00:52:48,880 --> 00:53:06,220
at construction time if they have a

00:53:03,339 --> 00:53:09,549
default constructor it would be possible

00:53:06,220 --> 00:53:13,059
to do that the problem is I need some

00:53:09,549 --> 00:53:17,410
state to copy or steal to initialize the

00:53:13,059 --> 00:53:20,079
variant so if you create a dog as an

00:53:17,410 --> 00:53:22,359
r-value reference I can move it and then

00:53:20,079 --> 00:53:24,759
it's my variant dog if you just say I

00:53:22,359 --> 00:53:27,299
want a dog by name then I need some kind

00:53:24,759 --> 00:53:29,349
of a factory so we could build a factory

00:53:27,299 --> 00:53:30,759
pattern around this as well it would

00:53:29,349 --> 00:53:33,609
just be something that sits on top it

00:53:30,759 --> 00:53:34,599
wouldn't really change this at all I can

00:53:33,609 --> 00:53:43,950
talk to you about it afterward if you

00:53:34,599 --> 00:53:43,950
like anybody else I think okay

00:53:59,750 --> 00:54:02,690
the question is whether it works like

00:54:01,190 --> 00:54:04,310
pattern matching and is therefore not

00:54:02,690 --> 00:54:07,630
order dependent it is not order

00:54:04,310 --> 00:54:07,630
dependent it works like pattern matching

00:54:30,310 --> 00:54:35,840
wasn't in the wrong position we were

00:54:32,780 --> 00:54:37,880
showing that you can do multi method

00:54:35,840 --> 00:54:44,900
dispatch across heterogeneous sets of

00:54:37,880 --> 00:54:47,240
variants transports right it was kind of

00:54:44,900 --> 00:54:48,770
a you know not very meaningful example

00:54:47,240 --> 00:54:57,170
per se but if the point was they can be

00:54:48,770 --> 00:54:59,780
different only horse the example right

00:54:57,170 --> 00:55:01,970
because horse lived in both unions so it

00:54:59,780 --> 00:55:05,200
you can't violate the type rules it is

00:55:01,970 --> 00:55:05,200
still strictly typeset

00:55:14,880 --> 00:55:24,340
hmm you can actually mix inheritance and

00:55:19,450 --> 00:55:25,869
unions it's it's doable the point is

00:55:24,340 --> 00:55:27,460
sometimes you're going to do inheritance

00:55:25,869 --> 00:55:29,140
for classification for behavior and

00:55:27,460 --> 00:55:31,600
sometimes you're going to do it for

00:55:29,140 --> 00:55:34,359
construction of the type basically it's

00:55:31,600 --> 00:55:38,560
a form of aggregation so you're going to

00:55:34,359 --> 00:55:42,010
stick things in but not be them for the

00:55:38,560 --> 00:55:43,900
purpose of an algorithm that's fine you

00:55:42,010 --> 00:55:47,260
can you can certainly do that and then

00:55:43,900 --> 00:55:48,700
those bases later you could match on if

00:55:47,260 --> 00:55:51,310
you wanted to with the with an

00:55:48,700 --> 00:55:52,570
overloaded lambda but you could overlook

00:55:51,310 --> 00:55:54,010
you could do the overloaded lambda on

00:55:52,570 --> 00:55:57,480
anything that would be statically

00:55:54,010 --> 00:55:57,480
discernibly different about the type

00:56:03,359 --> 00:56:08,800
absolutely so for example though the

00:56:06,940 --> 00:56:11,830
right like I want to stream this variant

00:56:08,800 --> 00:56:14,170
out the simplest case right you just

00:56:11,830 --> 00:56:17,020
have a single auto that whatever it is I

00:56:14,170 --> 00:56:19,090
shove it onto an out stream and it's

00:56:17,020 --> 00:56:20,470
fine right because they all they all

00:56:19,090 --> 00:56:25,270
provide their own overloads for doing

00:56:20,470 --> 00:56:27,460
that but then you could also use binding

00:56:25,270 --> 00:56:29,920
strength rules and say well in general

00:56:27,460 --> 00:56:32,200
I'm going to output them this way but if

00:56:29,920 --> 00:56:35,020
this is dog I'm going to do it some

00:56:32,200 --> 00:56:37,600
other way right so you have the option

00:56:35,020 --> 00:56:39,960
to break out of the default behavior any

00:56:37,600 --> 00:56:39,960
way you want

00:56:43,570 --> 00:57:09,260
like it's no faster than one half as

00:57:06,050 --> 00:57:12,020
fast as a virtual function and some of

00:57:09,260 --> 00:57:15,050
my examples actually we're going it is

00:57:12,020 --> 00:57:17,900
slower than a virtual function is

00:57:15,050 --> 00:57:21,970
between half as and in some of my cases

00:57:17,900 --> 00:57:26,840
one-sixth as fast as a virtual function

00:57:21,970 --> 00:57:28,280
but it's not a hundred times slower than

00:57:26,840 --> 00:57:30,920
a virtual function it's not a different

00:57:28,280 --> 00:57:35,000
world of badness it's okay

00:57:30,920 --> 00:57:37,640
and actually I'm not even sure why that

00:57:35,000 --> 00:57:38,660
six happened I believe we were messing

00:57:37,640 --> 00:57:40,610
around with some of the performance

00:57:38,660 --> 00:57:42,560
testing and it was kind of jittery so

00:57:40,610 --> 00:57:46,970
these are not numbers that I necessarily

00:57:42,560 --> 00:57:50,110
stand by but we are close to not quite

00:57:46,970 --> 00:57:50,110
as bad as half as good

00:58:07,880 --> 00:58:14,029
the intermediate applier data structures

00:58:09,769 --> 00:58:15,979
are tiny you're pushing stack frames in

00:58:14,029 --> 00:58:17,930
order to resolve resolve resolve so

00:58:15,979 --> 00:58:19,430
you've got stack frame size and you've

00:58:17,930 --> 00:58:43,339
got a little intermediate object that's

00:58:19,430 --> 00:58:45,410
done as a local it's not very much I

00:58:43,339 --> 00:58:47,089
think we're officially out of time thank

00:58:45,410 --> 00:58:48,589
you all for coming I hope you play

00:58:47,089 --> 00:58:51,309
around with variant and feel free to

00:58:48,589 --> 00:58:51,309

YouTube URL: https://www.youtube.com/watch?v=uii2AfiMA0o


