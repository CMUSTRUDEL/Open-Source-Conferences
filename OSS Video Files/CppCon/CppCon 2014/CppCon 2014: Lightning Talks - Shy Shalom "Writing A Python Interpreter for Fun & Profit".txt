Title: CppCon 2014: Lightning Talks - Shy Shalom "Writing A Python Interpreter for Fun & Profit"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Shy Shalom. Senior Software Engineer, Intigua. Expert cat herder.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,990
next we have Shai Shalem the one thing

00:00:03,030 --> 00:00:10,650
he loves more than C++ is Python whoa

00:00:06,990 --> 00:00:11,690
okay I got the room where you want them

00:00:10,650 --> 00:00:14,040
now

00:00:11,690 --> 00:00:15,780
Shai is a software engineer from Israel

00:00:14,040 --> 00:00:19,670
in his spare time he teaches high

00:00:15,780 --> 00:00:21,300
schoolers assembly as a first language

00:00:19,670 --> 00:00:25,529
five minutes

00:00:21,300 --> 00:00:31,260
writing your own Python interpreter five

00:00:25,529 --> 00:00:34,980
minutes so five minutes English is not

00:00:31,260 --> 00:00:41,460
my first language so I'll try to make

00:00:34,980 --> 00:00:45,000
this brief so what do we need to know

00:00:41,460 --> 00:00:47,809
about Python it's a interpreted language

00:00:45,000 --> 00:00:49,950
dynamically typed scripting and

00:00:47,809 --> 00:00:53,520
reference implementation is called C

00:00:49,950 --> 00:00:56,239
Python it has a boost Python wrapper

00:00:53,520 --> 00:00:59,840
nice nice wrapper and when you run

00:00:56,239 --> 00:01:02,100
Python scripts it's basically a

00:00:59,840 --> 00:01:04,470
completely compiled into bytecode and

00:01:02,100 --> 00:01:07,049
then the battle is being grounded on

00:01:04,470 --> 00:01:10,680
interpreter so the bicycle is there

00:01:07,049 --> 00:01:13,140
pretty simple it's a very simple stack

00:01:10,680 --> 00:01:15,540
machine so if you take the the first

00:01:13,140 --> 00:01:18,960
statement there C equals a plus B and

00:01:15,540 --> 00:01:22,200
then it it's translated into push and be

00:01:18,960 --> 00:01:24,030
binary add pops and B as them and pushes

00:01:22,200 --> 00:01:26,810
the result back into the stack and then

00:01:24,030 --> 00:01:30,110
pop C pops the result back into

00:01:26,810 --> 00:01:33,060
variability so pretty simple bytecode

00:01:30,110 --> 00:01:34,979
another key concept is that Python has

00:01:33,060 --> 00:01:37,740
an object model everything is an object

00:01:34,979 --> 00:01:39,750
we have a string end and even functions

00:01:37,740 --> 00:01:42,329
classes modules everything is an object

00:01:39,750 --> 00:01:44,250
everything is also reference counted so

00:01:42,329 --> 00:01:46,200
if you have a variable it's actually a

00:01:44,250 --> 00:01:48,329
reference to an object every object

00:01:46,200 --> 00:01:52,799
holds the number of references it has

00:01:48,329 --> 00:01:55,170
similar to shirt PAPR um so that's

00:01:52,799 --> 00:01:59,060
basically it what everything you need to

00:01:55,170 --> 00:01:59,060
know about Python so

00:01:59,840 --> 00:02:05,880
so what I wanted to do is to take some

00:02:02,850 --> 00:02:08,550
Python code and use the Python compiler

00:02:05,880 --> 00:02:14,070
to compile it into bytecode and use my

00:02:08,550 --> 00:02:19,490
interpreter to run this bytecode so what

00:02:14,070 --> 00:02:19,490
happened hmm give it a second

00:02:19,880 --> 00:02:30,950
yeah back table

00:02:22,590 --> 00:02:30,950
this one works okay yeah

00:02:34,820 --> 00:02:39,420
No

00:02:36,290 --> 00:02:42,180
so this tutor not to be quit a pretty

00:02:39,420 --> 00:02:44,430
simple after about five days of work I

00:02:42,180 --> 00:02:46,800
had something working about two

00:02:44,430 --> 00:02:48,990
thousands of lines of code so let's see

00:02:46,800 --> 00:02:51,990
what it looks like we have an

00:02:48,990 --> 00:02:54,390
interpreter instead instance there and I

00:02:51,990 --> 00:02:56,640
can import some Python code into it the

00:02:54,390 --> 00:02:59,730
Python code is being compiled by the c

00:02:56,640 --> 00:03:02,670
python compiler and then executed into

00:02:59,730 --> 00:03:05,730
the interpreter so next thing i can do

00:03:02,670 --> 00:03:08,940
once that's done I can call into Python

00:03:05,730 --> 00:03:11,250
via C++ using disco methods and then

00:03:08,940 --> 00:03:17,790
extract the results from the return

00:03:11,250 --> 00:03:21,870
objects into C++ again so I can also add

00:03:17,790 --> 00:03:25,590
an wrapper for us a C++ function and

00:03:21,870 --> 00:03:28,290
define it into the interpreter and then

00:03:25,590 --> 00:03:30,660
cocoa I can call from C++ into Python

00:03:28,290 --> 00:03:31,880
and then back to C++ again so this is

00:03:30,660 --> 00:03:34,860
pretty nice

00:03:31,880 --> 00:03:38,070
there's also syntax for wrapping a C++

00:03:34,860 --> 00:03:40,400
class with a Python class and defining

00:03:38,070 --> 00:03:44,459
some methods on it on it and then

00:03:40,400 --> 00:03:46,709
wrapping C++ instance with a with a

00:03:44,459 --> 00:03:50,850
Python instance and then calling these

00:03:46,709 --> 00:03:54,150
methods on on the instance so so yeah

00:03:50,850 --> 00:03:58,020
that's nice so you can already imagine

00:03:54,150 --> 00:04:00,540
what this call at the bottom does so

00:03:58,020 --> 00:04:03,600
here it is very straightforward very

00:04:00,540 --> 00:04:06,540
thick stem plates syntax for unwrapping

00:04:03,600 --> 00:04:11,310
the arguments and then calling this very

00:04:06,540 --> 00:04:13,470
distinctively named function run code so

00:04:11,310 --> 00:04:16,049
run code is pretty much the heart of the

00:04:13,470 --> 00:04:18,030
implementation this is the actual

00:04:16,049 --> 00:04:20,970
interpreter it has a while loop that

00:04:18,030 --> 00:04:23,220
goes over the stream of the bytecode the

00:04:20,970 --> 00:04:26,190
opcode by up code and for every opcode

00:04:23,220 --> 00:04:29,430
it executes it with a big switch

00:04:26,190 --> 00:04:31,680
statement so we have there here a few a

00:04:29,430 --> 00:04:33,450
few of the op codes you can see pop and

00:04:31,680 --> 00:04:37,580
push which manage the stack machine I

00:04:33,450 --> 00:04:40,830
mentioned and when Python code code

00:04:37,580 --> 00:04:44,460
calls a function it actually calls this

00:04:40,830 --> 00:04:48,630
run code recursively so it uses the C++

00:04:44,460 --> 00:04:50,790
a call stack as the Python call stack so

00:04:48,630 --> 00:04:55,190
this is as opposed to a stackless python

00:04:50,790 --> 00:04:55,190
implementation which doesn't do that

00:04:55,520 --> 00:05:00,180
next thing we need to do is implement

00:04:57,840 --> 00:05:02,669
the object models we have an object base

00:05:00,180 --> 00:05:05,220
class and we have string int list and

00:05:02,669 --> 00:05:08,310
dictionary objects each is implemented

00:05:05,220 --> 00:05:10,970
by their corresponding c++ types and we

00:05:08,310 --> 00:05:13,590
also have a ref class that's used as a

00:05:10,970 --> 00:05:15,419
as a reference where every reference is

00:05:13,590 --> 00:05:17,820
needed so it's basically a boost

00:05:15,419 --> 00:05:21,360
intrinsic PTR which manages the the ref

00:05:17,820 --> 00:05:24,360
count in in the object class if we want

00:05:21,360 --> 00:05:27,120
to extract a value from such an object

00:05:24,360 --> 00:05:29,370
we do a dynamic cast and then access the

00:05:27,120 --> 00:05:31,979
object so this is where the dynamic

00:05:29,370 --> 00:05:36,210
typing of Python comes into a very

00:05:31,979 --> 00:05:39,210
literal sense yeah so why would you

00:05:36,210 --> 00:05:41,070
actually want to do that why would you

00:05:39,210 --> 00:05:43,590
want to to write such an interpreter

00:05:41,070 --> 00:05:46,169
first if your application needs a

00:05:43,590 --> 00:05:50,090
scripting language it's much easier to

00:05:46,169 --> 00:05:52,650
write interpreter than write a compiler

00:05:50,090 --> 00:05:54,930
second it can be extremely lightweight

00:05:52,650 --> 00:05:58,169
like two thousand lines of code can

00:05:54,930 --> 00:06:00,780
actually do quite a bit and it can have

00:05:58,169 --> 00:06:02,430
multiple instances as opposed to C

00:06:00,780 --> 00:06:05,900
Python which has a single instance with

00:06:02,430 --> 00:06:08,460
gobu state and you can have any kind of

00:06:05,900 --> 00:06:09,750
customizations added to it like you can

00:06:08,460 --> 00:06:12,690
have a multi-threaded

00:06:09,750 --> 00:06:15,030
interpreter while C Python is basically

00:06:12,690 --> 00:06:17,040
single threaded and you can have any

00:06:15,030 --> 00:06:18,969
kind of memory management that you can

00:06:17,040 --> 00:06:21,159
think of

00:06:18,969 --> 00:06:25,299
be as simple or as complex as you want

00:06:21,159 --> 00:06:27,909
and for myself that that object was to

00:06:25,299 --> 00:06:32,319
simply experiment a bit with syphilis 11

00:06:27,909 --> 00:06:37,289
and have fun so here's the gratuitous

00:06:32,319 --> 00:06:37,289

YouTube URL: https://www.youtube.com/watch?v=f534_5H1md8


