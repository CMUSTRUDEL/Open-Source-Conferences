Title: Back To Basics: Lambda Expressions - Barbara Geller & Ansel Sermersheim - CppCon 2020
Publication date: 2020-09-26
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_lambda_expressions/back_to_basics_lambda_expressions__barbara_geller__ansel_sermersheim__cppcon_2020.pdf
---
Lambdas were first introduced into C++ with the release of the groundbreaking C++11 standard. New capabilities like generic lambda expressions and generalized captures were added in C++14. A few years ago, with the release of C++17, additional new features like constexpr lambda expressions were added. With the new release of C++20 even more features will added, some of which may change the way lambda expressions are used.

There are several parts to a lambda expression and in order to use them efficiently and effectively, you really need to master all the pieces. Do you know when to capture by value or capture by reference? Can the lifetime of variables be altered by a lambda expression? What are the ways to pass a lambda expression and is this a good idea? Our goal is to answer these questions and talk about the constraints lifted with each new version of C++. Multiple examples will be shown to illustrate what can be done with lambda expressions.

During this presentation developers will have the opportunity to learn or review the fundamentals about lambda expressions by studying the terminology. Once someone clearly understands the difference between a function object, function pointer, functor, and anonymous function, we have a great foundation for lambda expressions. We will be able to use our knowledge to reason about generalized captures and what it really means to capture "this".

---
Barbara Geller
CopperSpice
Cofounder

I am an independent consultant with over twenty-five years of experience as a programmer and software developer. I have worked with numerous smaller companies developing in-house applications. I have also designed and developed Windows applications for several vertical markets including medical billing, transportation, and construction.

My degree is in Electrical Engineering from Cal Poly Pomona with additional studies in Computer Science.

I am a Co-founder of CopperSpice, a C++ library derived from the existing Qt framework. I designed the Diamond Editor, a cross-platform programmers editor using the CopperSpice libraries. I have programmed in C++, Qt, Visual Objects, Clipper, PHP, and Java.

Ansel Sermersheim
CopperSpice
Cofounder

I have been working as a programmer for nearly twenty years. My degree is in Computer Science from Cal Poly San Luis  Obispo. I have transitioned to independent consulting and I am currently working on a project for RealtyShares in San Francisco.

Co-founder of CopperSpice, a C++ GUI library.
Co-founder of DoxyPress, a C++ application for generating documentation.
Developer of the open source libraries: libGuarded, CsSignal and CsString.

I have programmed in C++, C, Lisp, Java, and Perl, with extensive knowledge in TCP/IP and mutilthreaded design. I am an  avid follower of the C++ standard. Speaker at CppCon 2015, CppNow 2016, CppNow 2017, and several ACCU Bay Area meetings.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,000 --> 00:00:13,920
thanks for joining us

00:00:11,440 --> 00:00:15,679
this is the lambda expressions talk in

00:00:13,920 --> 00:00:19,279
the back to basics track

00:00:15,679 --> 00:00:21,199
i'm barbara and this is ansel

00:00:19,279 --> 00:00:22,480
we have lots of information to cover

00:00:21,199 --> 00:00:24,080
today

00:00:22,480 --> 00:00:25,680
since lambda expressions have been

00:00:24,080 --> 00:00:28,000
updated three times

00:00:25,680 --> 00:00:30,000
since c plus plus 11 there's a lot of

00:00:28,000 --> 00:00:32,160
new information

00:00:30,000 --> 00:00:33,680
if you're watching this live please feel

00:00:32,160 --> 00:00:35,760
free to post questions

00:00:33,680 --> 00:00:37,040
in the q a we're going to try to answer

00:00:35,760 --> 00:00:38,960
them in real time

00:00:37,040 --> 00:00:40,480
if we miss a few questions we'll be

00:00:38,960 --> 00:00:43,440
available after the talk

00:00:40,480 --> 00:00:44,399
and in the hallway track later on so

00:00:43,440 --> 00:00:45,360
we're going to start with an

00:00:44,399 --> 00:00:49,039
introduction

00:00:45,360 --> 00:00:52,000
about who we are ansel and i are the

00:00:49,039 --> 00:00:54,960
co-founders of the copper spice project

00:00:52,000 --> 00:00:56,960
and copper spice is a cross-platform set

00:00:54,960 --> 00:00:58,879
of gui libraries

00:00:56,960 --> 00:01:00,000
all of our work is open source and

00:00:58,879 --> 00:01:03,359
everything is available

00:01:00,000 --> 00:01:05,040
on github but congressvise is more than

00:01:03,359 --> 00:01:07,920
a set of libraries

00:01:05,040 --> 00:01:08,960
it's also a team our developers our

00:01:07,920 --> 00:01:10,840
contributors

00:01:08,960 --> 00:01:12,159
our testers people that help with

00:01:10,840 --> 00:01:14,640
documentation

00:01:12,159 --> 00:01:15,439
we're located all over the world and if

00:01:14,640 --> 00:01:17,520
you're looking for an

00:01:15,439 --> 00:01:19,119
open source project and you don't feel

00:01:17,520 --> 00:01:21,040
like starting one yourself

00:01:19,119 --> 00:01:23,360
because it is a lot of work please

00:01:21,040 --> 00:01:25,280
consider joining our team

00:01:23,360 --> 00:01:26,479
contact us during the conference or send

00:01:25,280 --> 00:01:28,000
us an email

00:01:26,479 --> 00:01:31,360
and please take some time to download

00:01:28,000 --> 00:01:33,200
copper spice and take a look at it

00:01:31,360 --> 00:01:34,799
there's one product that we have that

00:01:33,200 --> 00:01:37,920
we'd like to point out

00:01:34,799 --> 00:01:38,960
and that's doxypress doxypress is an

00:01:37,920 --> 00:01:40,400
application

00:01:38,960 --> 00:01:42,799
which is used for documenting your

00:01:40,400 --> 00:01:44,079
source code and it takes your source

00:01:42,799 --> 00:01:45,840
code in your comments and merges

00:01:44,079 --> 00:01:48,960
everything together

00:01:45,840 --> 00:01:50,960
if you happen to be using c plus 20 and

00:01:48,960 --> 00:01:52,640
you need to document concepts or the new

00:01:50,960 --> 00:01:54,560
requires clauses

00:01:52,640 --> 00:01:57,040
it turns out we've already accommodated

00:01:54,560 --> 00:01:58,640
this and we've added it to doxypress

00:01:57,040 --> 00:02:00,640
we do believe we're one of the few

00:01:58,640 --> 00:02:04,719
documenting programs that actually

00:02:00,640 --> 00:02:04,719
understands c plus 20.

00:02:06,000 --> 00:02:10,319
so whenever we do a presentation we

00:02:08,959 --> 00:02:12,640
always like to start with a bit of

00:02:10,319 --> 00:02:14,640
background about the topic

00:02:12,640 --> 00:02:18,080
and we wanted to look at the question

00:02:14,640 --> 00:02:20,080
where did the term lambda originate from

00:02:18,080 --> 00:02:22,879
well the word lambda comes to us from

00:02:20,080 --> 00:02:25,280
the lambda calculus which is a branch of

00:02:22,879 --> 00:02:28,080
mathematics that focused on trying to

00:02:25,280 --> 00:02:31,280
ask the question which problems could in

00:02:28,080 --> 00:02:33,680
theory be solved by a computer

00:02:31,280 --> 00:02:35,519
it predicted that a lot of problems can

00:02:33,680 --> 00:02:37,599
be solved by a computer

00:02:35,519 --> 00:02:40,160
which is a bit surprising because back

00:02:37,599 --> 00:02:42,879
then computers were very limited

00:02:40,160 --> 00:02:43,680
keep in mind in the 1930s personal

00:02:42,879 --> 00:02:51,840
computers were

00:02:43,680 --> 00:02:51,840
decades away

00:02:56,640 --> 00:03:00,159
so functions in the lambda calculus have

00:02:59,840 --> 00:03:03,680
no

00:03:00,159 --> 00:03:04,080
names and lambda calculus used the greek

00:03:03,680 --> 00:03:07,360
letter

00:03:04,080 --> 00:03:09,519
lambda to define a function

00:03:07,360 --> 00:03:11,040
so the word lambda became associated

00:03:09,519 --> 00:03:14,560
with the idea of

00:03:11,040 --> 00:03:14,560
a function with no name

00:03:16,239 --> 00:03:20,720
now a lot of developers focus on that

00:03:18,560 --> 00:03:22,159
and get the idea that a lambda refers to

00:03:20,720 --> 00:03:25,040
something nameless

00:03:22,159 --> 00:03:25,519
which it does but that's one of the

00:03:25,040 --> 00:03:29,760
least

00:03:25,519 --> 00:03:29,760
important pieces of a lambda expression

00:03:30,080 --> 00:03:34,720
so why do we use the word expression in

00:03:32,400 --> 00:03:37,200
this term lambda expression well what is

00:03:34,720 --> 00:03:40,000
an expression

00:03:37,200 --> 00:03:42,720
well five plus two is an expression and

00:03:40,000 --> 00:03:45,519
it returns a value

00:03:42,720 --> 00:03:46,239
into x is a declaration not an

00:03:45,519 --> 00:03:48,400
expression

00:03:46,239 --> 00:03:49,760
so it doesn't return a value so

00:03:48,400 --> 00:03:52,159
expressions

00:03:49,760 --> 00:03:55,040
one of their parameters is that they

00:03:52,159 --> 00:03:57,200
return values

00:03:55,040 --> 00:03:58,640
the fundamental definition of a lambda

00:03:57,200 --> 00:04:01,599
expression

00:03:58,640 --> 00:04:03,680
is that it is an expression that returns

00:04:01,599 --> 00:04:05,439
a function object

00:04:03,680 --> 00:04:07,120
well now we have a new term so we need

00:04:05,439 --> 00:04:11,360
to define a few more things

00:04:07,120 --> 00:04:11,360
to understand what a function object is

00:04:11,599 --> 00:04:15,840
but our journey really starts with a

00:04:13,920 --> 00:04:18,799
review of function pointers

00:04:15,840 --> 00:04:20,000
because we need this background first a

00:04:18,799 --> 00:04:23,040
function pointer

00:04:20,000 --> 00:04:24,960
is a data type whose value points to a

00:04:23,040 --> 00:04:27,199
particular function

00:04:24,960 --> 00:04:28,000
what's important is that a function

00:04:27,199 --> 00:04:30,479
pointer

00:04:28,000 --> 00:04:33,360
does not point to data which is really

00:04:30,479 --> 00:04:35,919
what a typical pointer is for

00:04:33,360 --> 00:04:36,639
so unlike a normal pointer a function

00:04:35,919 --> 00:04:39,919
pointer

00:04:36,639 --> 00:04:39,919
is not dereferenced

00:04:40,000 --> 00:04:43,600
so here's a quick example using a

00:04:41,919 --> 00:04:45,840
function pointer

00:04:43,600 --> 00:04:47,759
just like a normal pointer you declare a

00:04:45,840 --> 00:04:50,160
function pointer with a star

00:04:47,759 --> 00:04:52,240
but when we call it there is no star

00:04:50,160 --> 00:04:55,600
used for the dereference

00:04:52,240 --> 00:04:57,919
our pointer it's named my process

00:04:55,600 --> 00:04:58,880
our function pointer it can point to any

00:04:57,919 --> 00:05:02,320
function

00:04:58,880 --> 00:05:05,600
which has a single parameter of type in

00:05:02,320 --> 00:05:06,800
and a return type of void so in our

00:05:05,600 --> 00:05:09,600
example

00:05:06,800 --> 00:05:10,160
my process is initialized to point to

00:05:09,600 --> 00:05:13,840
std

00:05:10,160 --> 00:05:16,400
exit so on the last line in this example

00:05:13,840 --> 00:05:19,840
when my process is called the program

00:05:16,400 --> 00:05:22,479
will exit with the error code of 42.

00:05:19,840 --> 00:05:24,880
now notice if you look at this last line

00:05:22,479 --> 00:05:26,080
in isolation without any of the other

00:05:24,880 --> 00:05:29,840
code

00:05:26,080 --> 00:05:31,039
it looks as if my process is a function

00:05:29,840 --> 00:05:35,120
and that turns out to be a very

00:05:31,039 --> 00:05:35,120
important attribute of function pointers

00:05:36,560 --> 00:05:40,240
now we also need to define the terms

00:05:38,639 --> 00:05:43,520
overloaded operators

00:05:40,240 --> 00:05:45,919
and the function call operator well an

00:05:43,520 --> 00:05:48,880
overloaded operator is simply a method

00:05:45,919 --> 00:05:49,840
whose name is the is the word operator

00:05:48,880 --> 00:05:52,080
followed by some

00:05:49,840 --> 00:05:53,520
symbol and a lot of us have written

00:05:52,080 --> 00:05:55,039
these in our code or used them on a

00:05:53,520 --> 00:05:57,440
regular basis we have

00:05:55,039 --> 00:05:58,400
assignment operators comparison

00:05:57,440 --> 00:06:01,680
operators

00:05:58,400 --> 00:06:03,919
increment operators things like that

00:06:01,680 --> 00:06:05,360
the function call operator is a special

00:06:03,919 --> 00:06:07,919
case of an overloaded

00:06:05,360 --> 00:06:09,120
operator where the symbol that you're

00:06:07,919 --> 00:06:11,360
overloading

00:06:09,120 --> 00:06:13,039
is a pair of parentheses the open close

00:06:11,360 --> 00:06:14,720
parens

00:06:13,039 --> 00:06:16,240
and you'll note toward the bottom we're

00:06:14,720 --> 00:06:19,039
showing some examples

00:06:16,240 --> 00:06:20,400
there's two sets of parentheses the

00:06:19,039 --> 00:06:23,199
first pair is always

00:06:20,400 --> 00:06:26,560
empty and it's part of the name and then

00:06:23,199 --> 00:06:26,560
you have the function parameters

00:06:27,360 --> 00:06:31,120
so any class which declares a function

00:06:30,720 --> 00:06:34,240
call

00:06:31,120 --> 00:06:38,880
operator this is called a function

00:06:34,240 --> 00:06:41,919
object data type but it is still a class

00:06:38,880 --> 00:06:45,440
this is very similar to the way we refer

00:06:41,919 --> 00:06:48,560
to an std vector we call it a container

00:06:45,440 --> 00:06:51,520
even though it's a class an

00:06:48,560 --> 00:06:52,160
instance of a function object data type

00:06:51,520 --> 00:06:55,039
is called

00:06:52,160 --> 00:06:56,400
a function object so we're going through

00:06:55,039 --> 00:06:59,360
all these definitions

00:06:56,400 --> 00:07:01,280
so we can understand lambda expressions

00:06:59,360 --> 00:07:03,440
we're going to be tying it all together

00:07:01,280 --> 00:07:04,960
and hopefully that will make sense so

00:07:03,440 --> 00:07:06,479
we've been talking about a function

00:07:04,960 --> 00:07:09,360
object data type

00:07:06,479 --> 00:07:11,039
and a function object what is really

00:07:09,360 --> 00:07:13,840
important to remember

00:07:11,039 --> 00:07:14,639
is when you call a function object you

00:07:13,840 --> 00:07:18,319
are really

00:07:14,639 --> 00:07:20,560
invoking the function call operator

00:07:18,319 --> 00:07:22,560
and remember that function call operator

00:07:20,560 --> 00:07:26,160
is what we showed in the last slide

00:07:22,560 --> 00:07:26,160
the operator open close

00:07:27,120 --> 00:07:30,639
so here's a basic example we're

00:07:29,280 --> 00:07:34,160
declaring a function

00:07:30,639 --> 00:07:37,120
object data type ginger is a class

00:07:34,160 --> 00:07:39,680
it defines a function call operator you

00:07:37,120 --> 00:07:41,759
can note that by the operator open close

00:07:39,680 --> 00:07:44,080
and then the second set of parentheses

00:07:41,759 --> 00:07:47,199
with the data type

00:07:44,080 --> 00:07:51,599
on the following line we construct

00:07:47,199 --> 00:07:55,280
a ginger object and this is named widget

00:07:51,599 --> 00:07:59,280
there are two ways to call our method

00:07:55,280 --> 00:08:01,599
on line a we invoke the method directly

00:07:59,280 --> 00:08:03,680
it might look a little odd because we do

00:08:01,599 --> 00:08:05,759
need the operator open close

00:08:03,680 --> 00:08:07,840
and then the second set of parentheses

00:08:05,759 --> 00:08:10,879
to pass the parameter

00:08:07,840 --> 00:08:12,080
line b is a bit different we're taking

00:08:10,879 --> 00:08:15,520
the function object

00:08:12,080 --> 00:08:17,360
widget and this is called as if it were

00:08:15,520 --> 00:08:20,080
a function

00:08:17,360 --> 00:08:21,280
what this is actually doing is calling

00:08:20,080 --> 00:08:24,080
our function call

00:08:21,280 --> 00:08:24,960
operator even though we did not spell

00:08:24,080 --> 00:08:28,560
out the word

00:08:24,960 --> 00:08:30,400
operator and notice that just like in

00:08:28,560 --> 00:08:32,800
the function pointer case

00:08:30,400 --> 00:08:34,159
if you look at the very last line in

00:08:32,800 --> 00:08:37,440
isolation

00:08:34,159 --> 00:08:39,599
it looks like widget is a function

00:08:37,440 --> 00:08:41,120
this means that the syntax is the same

00:08:39,599 --> 00:08:42,159
regardless of whether you're calling a

00:08:41,120 --> 00:08:46,720
function

00:08:42,159 --> 00:08:46,720
a function pointer or a function object

00:08:47,680 --> 00:08:51,279
we want to throw something in here at

00:08:49,839 --> 00:08:53,279
this point and this is actually

00:08:51,279 --> 00:08:55,839
important to us

00:08:53,279 --> 00:08:57,680
c plus plus programmers they like to use

00:08:55,839 --> 00:08:59,440
the word functor

00:08:57,680 --> 00:09:02,000
the standard actually doesn't mention

00:08:59,440 --> 00:09:05,519
this term so it doesn't have

00:09:02,000 --> 00:09:07,519
a definition based on the standard

00:09:05,519 --> 00:09:09,600
if you look around the internet you can

00:09:07,519 --> 00:09:10,880
find lots of definitions for the word

00:09:09,600 --> 00:09:12,880
functor

00:09:10,880 --> 00:09:15,120
but usually they pertain to math or

00:09:12,880 --> 00:09:17,760
functional programming

00:09:15,120 --> 00:09:18,399
we found that typically when c plus plus

00:09:17,760 --> 00:09:21,040
developers

00:09:18,399 --> 00:09:21,600
use the term functor what they really

00:09:21,040 --> 00:09:24,720
meant

00:09:21,600 --> 00:09:25,200
was function object and why does this

00:09:24,720 --> 00:09:27,279
matter

00:09:25,200 --> 00:09:29,600
well if we want to be able to

00:09:27,279 --> 00:09:30,959
communicate effectively about the code

00:09:29,600 --> 00:09:32,640
we're writing

00:09:30,959 --> 00:09:35,519
we really need to be using the right

00:09:32,640 --> 00:09:37,600
terminology and developing good habits

00:09:35,519 --> 00:09:41,360
we feel like you should use the standard

00:09:37,600 --> 00:09:41,360
terminology whenever possible

00:09:43,360 --> 00:09:47,200
so here's a quick review of what we've

00:09:45,760 --> 00:09:49,839
talked about

00:09:47,200 --> 00:09:50,959
we have a lot of terms here functor

00:09:49,839 --> 00:09:53,519
function pointer

00:09:50,959 --> 00:09:54,560
function object data type and function

00:09:53,519 --> 00:09:57,040
object

00:09:54,560 --> 00:09:58,000
it is really easy to confuse all these

00:09:57,040 --> 00:10:01,680
terms

00:09:58,000 --> 00:10:04,720
they sound very similar the two terms

00:10:01,680 --> 00:10:07,279
that we want to expand on and relate

00:10:04,720 --> 00:10:08,959
to lambda expressions is a function

00:10:07,279 --> 00:10:11,920
object data type

00:10:08,959 --> 00:10:12,640
and a function object these are the main

00:10:11,920 --> 00:10:16,959
terms

00:10:12,640 --> 00:10:19,760
of interest to us now std function

00:10:16,959 --> 00:10:20,640
this is also really important and it was

00:10:19,760 --> 00:10:24,320
added in c

00:10:20,640 --> 00:10:25,360
plus 11. and the main reason why they

00:10:24,320 --> 00:10:27,600
added it

00:10:25,360 --> 00:10:28,880
was they wanted a class which could be

00:10:27,600 --> 00:10:31,519
used to store

00:10:28,880 --> 00:10:32,000
a function object so this actually

00:10:31,519 --> 00:10:34,640
provides

00:10:32,000 --> 00:10:35,440
a mechanism for passing a lambda

00:10:34,640 --> 00:10:38,399
expression

00:10:35,440 --> 00:10:38,399
to another function

00:10:38,880 --> 00:10:42,000
now there's a lot of syntax in a lambda

00:10:41,040 --> 00:10:43,519
expression

00:10:42,000 --> 00:10:45,519
and the order of all the different

00:10:43,519 --> 00:10:48,000
pieces really matters

00:10:45,519 --> 00:10:49,680
there are three main clauses which

00:10:48,000 --> 00:10:52,160
appear in the square brackets

00:10:49,680 --> 00:10:53,839
parentheses and curly braces in that

00:10:52,160 --> 00:10:55,680
order

00:10:53,839 --> 00:10:57,519
the return type which we're showing in

00:10:55,680 --> 00:11:00,000
purple here is optional

00:10:57,519 --> 00:11:01,760
and is usually not specified and we're

00:11:00,000 --> 00:11:04,720
going to talk in detail about all of

00:11:01,760 --> 00:11:06,880
these elements as we go on

00:11:04,720 --> 00:11:09,040
but for the moment we want to call out

00:11:06,880 --> 00:11:11,040
the fact that since a lambda expression

00:11:09,040 --> 00:11:14,480
produces a value

00:11:11,040 --> 00:11:16,880
the result can be stored in a variable

00:11:14,480 --> 00:11:17,760
this variable should almost always be

00:11:16,880 --> 00:11:20,640
declared with

00:11:17,760 --> 00:11:24,320
auto because the data type of a lambda

00:11:20,640 --> 00:11:24,320
expression is compiler dependent

00:11:25,040 --> 00:11:29,839
so these are the key sections that

00:11:27,200 --> 00:11:32,399
pertain to a lambda expression

00:11:29,839 --> 00:11:33,519
we have the capture clause and it

00:11:32,399 --> 00:11:36,720
specifies

00:11:33,519 --> 00:11:39,600
which variables will be available inside

00:11:36,720 --> 00:11:42,079
the body of the lambda expression

00:11:39,600 --> 00:11:44,000
it's not necessary to capture anything

00:11:42,079 --> 00:11:47,440
however the square brackets

00:11:44,000 --> 00:11:50,399
are required so you have to have them

00:11:47,440 --> 00:11:53,440
the parameter list is very similar to

00:11:50,399 --> 00:11:55,600
the parameter list for a normal function

00:11:53,440 --> 00:11:57,360
the parentheses for the parameter list

00:11:55,600 --> 00:11:58,720
you can leave them off

00:11:57,360 --> 00:12:01,519
but then it makes everything look a

00:11:58,720 --> 00:12:03,040
little odd so we strongly suggest

00:12:01,519 --> 00:12:05,440
keep the parentheses there for the

00:12:03,040 --> 00:12:09,120
parameter list even if you're not

00:12:05,440 --> 00:12:11,040
using a parameter list the return type

00:12:09,120 --> 00:12:12,320
it's only required if the compiler

00:12:11,040 --> 00:12:14,800
cannot deduce

00:12:12,320 --> 00:12:16,399
the return type we will talk about that

00:12:14,800 --> 00:12:19,279
a bit more

00:12:16,399 --> 00:12:22,079
the body of the lambda expression this

00:12:19,279 --> 00:12:25,200
is enclosed in the curly braces

00:12:22,079 --> 00:12:28,639
and has the same meaning as any other

00:12:25,200 --> 00:12:30,560
function body what we do want to mention

00:12:28,639 --> 00:12:31,920
is that the body of the lambda

00:12:30,560 --> 00:12:34,240
expression

00:12:31,920 --> 00:12:36,000
this is what becomes the body of the

00:12:34,240 --> 00:12:37,839
function call operator

00:12:36,000 --> 00:12:39,040
so we want to keep bringing that up so

00:12:37,839 --> 00:12:42,560
we're relating

00:12:39,040 --> 00:12:45,040
a lambda expression to a function called

00:12:42,560 --> 00:12:45,040
operator

00:12:45,760 --> 00:12:49,200
so here's an example and it shows a

00:12:48,639 --> 00:12:52,720
simple

00:12:49,200 --> 00:12:56,560
lambda expression we want to capture

00:12:52,720 --> 00:12:59,360
x and print the value the question is

00:12:56,560 --> 00:13:00,560
what value is printed if you're watching

00:12:59,360 --> 00:13:02,160
this talk live

00:13:00,560 --> 00:13:03,600
and you feel like typing the answer in

00:13:02,160 --> 00:13:06,880
the q a

00:13:03,600 --> 00:13:09,760
we'll take a moment to read those

00:13:06,880 --> 00:13:12,079
as we uh continue to go over this

00:13:09,760 --> 00:13:15,200
example

00:13:12,079 --> 00:13:18,880
so looking at the code for main

00:13:15,200 --> 00:13:21,839
we have int x equals 42.

00:13:18,880 --> 00:13:21,839
x is in the capture

00:13:22,079 --> 00:13:27,600
and it must be declared before the

00:13:24,800 --> 00:13:32,480
lambda expression

00:13:27,600 --> 00:13:36,399
but if you notice x is reassigned to 7

00:13:32,480 --> 00:13:38,880
before my lamb is invoked

00:13:36,399 --> 00:13:40,560
and i see some people posting and voting

00:13:38,880 --> 00:13:42,560
up that's a good thing we're seeing some

00:13:40,560 --> 00:13:45,600
answers appear

00:13:42,560 --> 00:13:49,120
notice this x is captured by

00:13:45,600 --> 00:13:51,839
value and this capture

00:13:49,120 --> 00:13:54,079
means that the value is copied when the

00:13:51,839 --> 00:13:58,079
lambda expression is evaluated

00:13:54,079 --> 00:13:58,079
during the initialization of my lamb

00:13:58,160 --> 00:14:02,639
so yes as people are posting uh 42 is

00:14:01,519 --> 00:14:05,120
the answer

00:14:02,639 --> 00:14:06,880
because the capture actually happened

00:14:05,120 --> 00:14:09,040
during that declaration

00:14:06,880 --> 00:14:10,079
so the fact that we're reassigning x to

00:14:09,040 --> 00:14:12,399
seven

00:14:10,079 --> 00:14:13,839
that doesn't have any bearing on what it

00:14:12,399 --> 00:14:16,160
actually prints when the lambda

00:14:13,839 --> 00:14:18,720
expression is evaluated and the result

00:14:16,160 --> 00:14:18,720
is printed

00:14:18,959 --> 00:14:23,600
but let's change things up a bit so what

00:14:22,160 --> 00:14:27,120
happens if we capture

00:14:23,600 --> 00:14:29,199
by reference so

00:14:27,120 --> 00:14:30,720
what value will we be printing in this

00:14:29,199 --> 00:14:33,199
case

00:14:30,720 --> 00:14:34,160
well the capture by reference still

00:14:33,199 --> 00:14:36,639
occurs

00:14:34,160 --> 00:14:38,560
when the lambda expression is evaluated

00:14:36,639 --> 00:14:39,600
so we haven't changed when the capture

00:14:38,560 --> 00:14:43,360
happens

00:14:39,600 --> 00:14:45,199
however changing the value to 7

00:14:43,360 --> 00:14:46,639
will be visible to the body of the

00:14:45,199 --> 00:14:50,160
lambda expression

00:14:46,639 --> 00:14:54,000
because what got captured is a reference

00:14:50,160 --> 00:14:55,440
to x not the value of x

00:14:54,000 --> 00:14:57,760
now there's something to keep in mind

00:14:55,440 --> 00:15:00,959
here since the lambda

00:14:57,760 --> 00:15:03,360
expression now uses a reference if

00:15:00,959 --> 00:15:05,440
x had gone out of scope before we

00:15:03,360 --> 00:15:07,120
invoked my lamb

00:15:05,440 --> 00:15:09,760
then you would have a reference to an

00:15:07,120 --> 00:15:13,839
object whose lifetime has ended

00:15:09,760 --> 00:15:13,839
and you'll have undefined behavior

00:15:15,199 --> 00:15:19,600
we want to be a bit picky right now

00:15:18,079 --> 00:15:21,760
which is sort of what we do as

00:15:19,600 --> 00:15:24,720
programmers

00:15:21,760 --> 00:15:25,680
so everything to the right of the equal

00:15:24,720 --> 00:15:29,440
sign

00:15:25,680 --> 00:15:32,560
is what we call the lambda expression

00:15:29,440 --> 00:15:33,759
the expression is evaluated and then the

00:15:32,560 --> 00:15:37,360
variable mylam

00:15:33,759 --> 00:15:39,279
is initiated and initialized

00:15:37,360 --> 00:15:41,759
but we're using a variable called my

00:15:39,279 --> 00:15:44,800
lamb it's easy to say

00:15:41,759 --> 00:15:46,800
it's easy to hear and to pronounce

00:15:44,800 --> 00:15:48,000
but somebody suggested maybe we should

00:15:46,800 --> 00:15:51,600
be calling this

00:15:48,000 --> 00:15:54,560
my lambda expression as a variable name

00:15:51,600 --> 00:15:55,839
well that is an interesting term but

00:15:54,560 --> 00:15:59,759
keep in mind

00:15:55,839 --> 00:16:02,320
once we evaluate the lambda expression

00:15:59,759 --> 00:16:03,199
it's not actually a lambda expression at

00:16:02,320 --> 00:16:06,240
that point

00:16:03,199 --> 00:16:07,519
it's a closure so maybe we should have

00:16:06,240 --> 00:16:11,600
called the variable

00:16:07,519 --> 00:16:15,040
my closure that is also an option

00:16:11,600 --> 00:16:16,160
but the truth is my closure doesn't

00:16:15,040 --> 00:16:19,519
really say

00:16:16,160 --> 00:16:20,839
anything about the code now we just

00:16:19,519 --> 00:16:24,720
mentioned the term

00:16:20,839 --> 00:16:28,160
closure and the question is what is that

00:16:24,720 --> 00:16:29,199
well in c plus a closure is a term the

00:16:28,160 --> 00:16:32,480
standard uses

00:16:29,199 --> 00:16:33,519
for any function object which is

00:16:32,480 --> 00:16:35,759
returned from

00:16:33,519 --> 00:16:37,040
evaluating a lambda expression that's

00:16:35,759 --> 00:16:40,240
all it is it's just a

00:16:37,040 --> 00:16:43,680
category of function objects that came

00:16:40,240 --> 00:16:44,320
from lambda expressions so the key point

00:16:43,680 --> 00:16:47,440
is

00:16:44,320 --> 00:16:50,240
yes we're using a silly variable name

00:16:47,440 --> 00:16:50,560
we encourage you in your production code

00:16:50,240 --> 00:16:53,120
pick

00:16:50,560 --> 00:16:54,800
variable names that actually make sense

00:16:53,120 --> 00:16:55,759
and that isn't my lambda expression or

00:16:54,800 --> 00:16:57,360
my closure

00:16:55,759 --> 00:16:59,759
but we're just going to use my lamb in

00:16:57,360 --> 00:17:02,839
this talk as a way to pronounce it

00:16:59,759 --> 00:17:05,600
and we've explained now why we're using

00:17:02,839 --> 00:17:07,839
that

00:17:05,600 --> 00:17:09,520
so we want to go a bit deeper in detail

00:17:07,839 --> 00:17:11,679
about the different clauses

00:17:09,520 --> 00:17:14,480
in a lambda expression and first we're

00:17:11,679 --> 00:17:17,520
going to cover the capture clause

00:17:14,480 --> 00:17:20,240
when you capture a variable by value

00:17:17,520 --> 00:17:22,799
it gets copied into the function object

00:17:20,240 --> 00:17:25,199
as a const value

00:17:22,799 --> 00:17:26,959
the only things you can capture are

00:17:25,199 --> 00:17:28,079
variables in your local scope and

00:17:26,959 --> 00:17:31,120
various forms of

00:17:28,079 --> 00:17:34,080
this you can have any number of

00:17:31,120 --> 00:17:36,000
variables in the capture clause

00:17:34,080 --> 00:17:37,120
and since the variable is being captured

00:17:36,000 --> 00:17:38,960
by value

00:17:37,120 --> 00:17:40,799
it doesn't matter if the original

00:17:38,960 --> 00:17:42,960
variable goes out of scope

00:17:40,799 --> 00:17:45,360
before you invoke the lambda expression

00:17:42,960 --> 00:17:47,440
closure

00:17:45,360 --> 00:17:48,559
if you want to be able to modify the

00:17:47,440 --> 00:17:51,280
captured value

00:17:48,559 --> 00:17:53,200
in the body of the lambda expression you

00:17:51,280 --> 00:17:53,840
need to mark the entire lambda

00:17:53,200 --> 00:17:56,640
expression

00:17:53,840 --> 00:17:57,520
mutable this will make the capture by

00:17:56,640 --> 00:18:01,120
value

00:17:57,520 --> 00:18:04,080
rather than by const value the word

00:18:01,120 --> 00:18:04,720
mutable needs to appear just before the

00:18:04,080 --> 00:18:08,000
body

00:18:04,720 --> 00:18:08,000
of the lambda expression

00:18:11,120 --> 00:18:15,360
so here's a capture and you can see the

00:18:14,480 --> 00:18:19,039
ampersand

00:18:15,360 --> 00:18:22,000
x this is an l value reference

00:18:19,039 --> 00:18:23,280
it's not valid valid to capture by r

00:18:22,000 --> 00:18:26,240
value reference

00:18:23,280 --> 00:18:28,640
so all we have is l value we'll talk a

00:18:26,240 --> 00:18:29,600
little bit later on other ways of

00:18:28,640 --> 00:18:33,760
handling

00:18:29,600 --> 00:18:36,320
our value references but keep in mind

00:18:33,760 --> 00:18:37,039
when you have a capture clause you can

00:18:36,320 --> 00:18:40,160
capture by

00:18:37,039 --> 00:18:42,640
value and by l value reference

00:18:40,160 --> 00:18:44,240
and you can mix this up within the

00:18:42,640 --> 00:18:46,880
capture

00:18:44,240 --> 00:18:48,080
so when you capture by l value reference

00:18:46,880 --> 00:18:51,760
make sure the data

00:18:48,080 --> 00:18:54,080
remains alive for the lifetime

00:18:51,760 --> 00:18:55,039
of the closure we have a question that

00:18:54,080 --> 00:18:58,000
just popped up

00:18:55,039 --> 00:18:59,919
what about global variables well that's

00:18:58,000 --> 00:19:02,720
a fascinating question

00:18:59,919 --> 00:19:05,039
and it turns out the answer is you can't

00:19:02,720 --> 00:19:07,440
capture global variables

00:19:05,039 --> 00:19:08,720
but you don't need to because they're

00:19:07,440 --> 00:19:10,720
visible directly

00:19:08,720 --> 00:19:12,160
from the body of the lambda expression

00:19:10,720 --> 00:19:15,120
so there's nothing to capture and

00:19:12,160 --> 00:19:15,120
there's no reason to

00:19:15,840 --> 00:19:20,080
so taking a look at this code again

00:19:18,160 --> 00:19:22,480
there's a bit of a subtleness we want to

00:19:20,080 --> 00:19:25,520
point out

00:19:22,480 --> 00:19:28,160
the variable x in the captcha we're

00:19:25,520 --> 00:19:30,640
saying we're capturing by l value

00:19:28,160 --> 00:19:31,520
reference but that doesn't actually

00:19:30,640 --> 00:19:34,720
indicate

00:19:31,520 --> 00:19:36,240
or have any bearing on how x was

00:19:34,720 --> 00:19:39,360
declared

00:19:36,240 --> 00:19:41,520
in the outer and local scope so you

00:19:39,360 --> 00:19:45,840
can't draw any conclusions

00:19:41,520 --> 00:19:48,000
so x may have been declared as a value

00:19:45,840 --> 00:19:49,760
in the outer scope but we're saying in

00:19:48,000 --> 00:19:52,080
the lambda expression

00:19:49,760 --> 00:19:54,640
it is an l value reference that is how

00:19:52,080 --> 00:19:57,280
we're going to capture the data

00:19:54,640 --> 00:19:59,520
so the capture clause declares what the

00:19:57,280 --> 00:20:01,440
lambda expression sees

00:19:59,520 --> 00:20:02,559
and again you need to ensure the lambda

00:20:01,440 --> 00:20:05,840
expression

00:20:02,559 --> 00:20:06,799
can refer to the data so you do not move

00:20:05,840 --> 00:20:10,320
or destroy

00:20:06,799 --> 00:20:11,280
x if that closure while the closure is

00:20:10,320 --> 00:20:13,360
still alive

00:20:11,280 --> 00:20:15,360
so there's a big difference if you're

00:20:13,360 --> 00:20:17,679
capturing by value

00:20:15,360 --> 00:20:19,760
then it can go out of scope in the outer

00:20:17,679 --> 00:20:22,880
scope but if it's by reference

00:20:19,760 --> 00:20:22,880
it has to stay in scope

00:20:25,039 --> 00:20:29,600
so in c plus 11 all we had was capture

00:20:28,559 --> 00:20:31,520
by value

00:20:29,600 --> 00:20:32,960
or capture by reference as we've just

00:20:31,520 --> 00:20:36,880
discussed

00:20:32,960 --> 00:20:38,640
in c 14 the capture clause was extended

00:20:36,880 --> 00:20:41,440
and they added a feature called

00:20:38,640 --> 00:20:44,240
generalized capture

00:20:41,440 --> 00:20:44,240
so what is this

00:20:44,559 --> 00:20:51,280
so generalized capture has various forms

00:20:48,159 --> 00:20:54,159
and all of these the syntax will look

00:20:51,280 --> 00:20:56,559
like it's doing an assignment

00:20:54,159 --> 00:20:58,159
in our first example you can see that

00:20:56,559 --> 00:21:02,080
we're doing the capture

00:20:58,159 --> 00:21:06,400
and we're saying var a equals 10. so

00:21:02,080 --> 00:21:08,960
we're assigning the value 10 to var a

00:21:06,400 --> 00:21:10,159
in example 2 we are capturing the value

00:21:08,960 --> 00:21:13,360
of x

00:21:10,159 --> 00:21:14,159
and assigning it to var b and as we've

00:21:13,360 --> 00:21:17,280
stated

00:21:14,159 --> 00:21:19,919
since x is in the local scope when we

00:21:17,280 --> 00:21:22,320
capture that and assign it to var b

00:21:19,919 --> 00:21:24,400
x can actually go out of scope because

00:21:22,320 --> 00:21:27,440
we now have captured the value

00:21:24,400 --> 00:21:30,240
and saved it in var b

00:21:27,440 --> 00:21:30,880
the last example we're showing here has

00:21:30,240 --> 00:21:34,400
a move

00:21:30,880 --> 00:21:37,840
capture into var d this allows

00:21:34,400 --> 00:21:40,880
using a generalized capture to move

00:21:37,840 --> 00:21:43,039
a value from the local scope into the

00:21:40,880 --> 00:21:45,760
closure

00:21:43,039 --> 00:21:48,400
now remember that captures happen when

00:21:45,760 --> 00:21:51,039
the lambda expression is evaluated

00:21:48,400 --> 00:21:52,559
even if the closure isn't invoked until

00:21:51,039 --> 00:21:55,760
much later

00:21:52,559 --> 00:21:59,120
so this move operation is going to occur

00:21:55,760 --> 00:22:02,400
where the lambda expression is defined

00:21:59,120 --> 00:22:05,120
you can't use the move captured data

00:22:02,400 --> 00:22:09,600
after the lambda expression is declared

00:22:05,120 --> 00:22:11,039
because the value in z will be gone

00:22:09,600 --> 00:22:13,280
so the fact that we're talking about

00:22:11,039 --> 00:22:16,400
those problems if you

00:22:13,280 --> 00:22:17,840
try to access a variable after it's been

00:22:16,400 --> 00:22:20,159
moved captured

00:22:17,840 --> 00:22:21,600
into the land expression this is

00:22:20,159 --> 00:22:25,440
actually

00:22:21,600 --> 00:22:28,559
nothing specific to a land expression

00:22:25,440 --> 00:22:30,080
this is just the understanding of how a

00:22:28,559 --> 00:22:32,320
move capture works

00:22:30,080 --> 00:22:34,000
the problem is if you're reading a

00:22:32,320 --> 00:22:34,960
particular method and you're looking at

00:22:34,000 --> 00:22:37,520
code

00:22:34,960 --> 00:22:39,360
and you see that there's a move capture

00:22:37,520 --> 00:22:41,440
you tend to glance over the code

00:22:39,360 --> 00:22:45,280
and see oh wait a second we're using

00:22:41,440 --> 00:22:47,440
this later on and we've moved captured

00:22:45,280 --> 00:22:50,000
the problem is sometimes when the move

00:22:47,440 --> 00:22:52,400
capture is part of a land expression

00:22:50,000 --> 00:22:54,159
that has been declared several lines

00:22:52,400 --> 00:22:56,400
above in the method

00:22:54,159 --> 00:22:58,159
that you don't see that the lambda

00:22:56,400 --> 00:23:00,400
expression is called later on

00:22:58,159 --> 00:23:01,919
so that's why we're trying to point out

00:23:00,400 --> 00:23:03,360
you need to be careful if there's a move

00:23:01,919 --> 00:23:06,400
capture

00:23:03,360 --> 00:23:09,600
that everything stays in scope

00:23:06,400 --> 00:23:11,679
for that variable so just remember if

00:23:09,600 --> 00:23:14,880
you're writing code and you're using c

00:23:11,679 --> 00:23:17,039
plus 14 generalized capture

00:23:14,880 --> 00:23:19,440
the capture clause itself can have side

00:23:17,039 --> 00:23:19,440
effects

00:23:20,320 --> 00:23:23,520
so what happens about a lambda

00:23:21,919 --> 00:23:26,559
expression inside

00:23:23,520 --> 00:23:28,000
a class well you don't have access to

00:23:26,559 --> 00:23:31,120
the data members

00:23:28,000 --> 00:23:32,640
and the methods so how do we capture the

00:23:31,120 --> 00:23:36,320
current object

00:23:32,640 --> 00:23:39,200
we need a way to capture this in c

00:23:36,320 --> 00:23:39,919
plus 11 the only supported way to do

00:23:39,200 --> 00:23:43,360
this

00:23:39,919 --> 00:23:46,880
was to capture the this pointer

00:23:43,360 --> 00:23:48,880
this is capturing this by value

00:23:46,880 --> 00:23:51,919
but since this is a pointer you will

00:23:48,880 --> 00:23:54,559
have a pointer to the original object

00:23:51,919 --> 00:23:55,279
that means modifying this arrow some

00:23:54,559 --> 00:23:58,880
data

00:23:55,279 --> 00:24:02,240
will change the original value

00:23:58,880 --> 00:24:05,440
in c plus 14 you can use

00:24:02,240 --> 00:24:06,559
a generalized capture to copy the

00:24:05,440 --> 00:24:09,919
current object

00:24:06,559 --> 00:24:12,799
into some other variable at this point

00:24:09,919 --> 00:24:14,360
inside the body of the lambda expression

00:24:12,799 --> 00:24:17,520
if you modify

00:24:14,360 --> 00:24:19,760
self.sum data you'll be changing the

00:24:17,520 --> 00:24:23,520
copy

00:24:19,760 --> 00:24:24,559
in c plus 17 the capture clause was

00:24:23,520 --> 00:24:27,679
enhanced

00:24:24,559 --> 00:24:29,279
to allow capturing star this

00:24:27,679 --> 00:24:31,600
without changing the name of the

00:24:29,279 --> 00:24:33,679
variable

00:24:31,600 --> 00:24:35,520
the only issue with this is the fact

00:24:33,679 --> 00:24:38,159
that the c plus 17

00:24:35,520 --> 00:24:39,600
syntax which captures a copy of the

00:24:38,159 --> 00:24:42,559
current object

00:24:39,600 --> 00:24:42,799
is only one character different than the

00:24:42,559 --> 00:24:45,679
c

00:24:42,799 --> 00:24:48,080
plus plus 11 syntax which captures a

00:24:45,679 --> 00:24:50,000
pointer to the current object

00:24:48,080 --> 00:24:51,520
so you have to be very careful in

00:24:50,000 --> 00:24:53,520
reading modern code

00:24:51,520 --> 00:24:56,080
to ensure that you know the semantics of

00:24:53,520 --> 00:24:58,960
what's being done

00:24:56,080 --> 00:25:00,640
we have a question when a capture

00:24:58,960 --> 00:25:03,760
initialized by reference

00:25:00,640 --> 00:25:07,360
uh what is visible in the lambda var

00:25:03,760 --> 00:25:09,200
x or var y i think that may be a

00:25:07,360 --> 00:25:12,400
question on the previous slide

00:25:09,200 --> 00:25:16,159
yes um if you mean var c

00:25:12,400 --> 00:25:19,360
or y um the answer would be

00:25:16,159 --> 00:25:21,200
based on this code that var c

00:25:19,360 --> 00:25:24,240
is what's visible inside the lambda

00:25:21,200 --> 00:25:26,880
because that's the name of the captcha

00:25:24,240 --> 00:25:27,679
y would have to be a name in the outer

00:25:26,880 --> 00:25:29,919
scope

00:25:27,679 --> 00:25:32,320
that evaluates to something which can be

00:25:29,919 --> 00:25:33,760
captured

00:25:32,320 --> 00:25:36,080
if there's more to that question feel

00:25:33,760 --> 00:25:43,279
free to post otherwise

00:25:36,080 --> 00:25:46,320
we'll move on

00:25:43,279 --> 00:25:48,320
so here are a few more ways to capture

00:25:46,320 --> 00:25:51,120
and we're going to say that this maybe

00:25:48,320 --> 00:25:54,559
should be used with a little bit of care

00:25:51,120 --> 00:25:57,360
you can specify a default capture

00:25:54,559 --> 00:25:59,360
where any variable which is used in the

00:25:57,360 --> 00:26:01,679
body of the lambda expression

00:25:59,360 --> 00:26:05,039
will automatically be captured from

00:26:01,679 --> 00:26:07,600
again from your local scope

00:26:05,039 --> 00:26:08,960
now the first example here says i would

00:26:07,600 --> 00:26:12,159
like the default

00:26:08,960 --> 00:26:13,760
for any variable i refer to to capture

00:26:12,159 --> 00:26:16,960
by value

00:26:13,760 --> 00:26:18,320
the second example says i would like any

00:26:16,960 --> 00:26:21,679
variable i name

00:26:18,320 --> 00:26:24,880
to be captured by l value reference

00:26:21,679 --> 00:26:27,840
both of these examples refer to x and

00:26:24,880 --> 00:26:29,360
m underscore data and in order to

00:26:27,840 --> 00:26:30,960
compile

00:26:29,360 --> 00:26:34,480
these both need to be either in the

00:26:30,960 --> 00:26:37,600
local scope or class members

00:26:34,480 --> 00:26:41,120
assuming that m data is a class member

00:26:37,600 --> 00:26:41,440
this will be default captured because we

00:26:41,120 --> 00:26:43,360
need

00:26:41,440 --> 00:26:45,279
access to it in order to access that

00:26:43,360 --> 00:26:48,000
variable

00:26:45,279 --> 00:26:50,080
this means changing m data will alter

00:26:48,000 --> 00:26:51,840
the original data member

00:26:50,080 --> 00:26:53,120
because it doesn't matter if you capture

00:26:51,840 --> 00:26:54,880
a pointer by value

00:26:53,120 --> 00:26:58,240
or by reference you're still referring

00:26:54,880 --> 00:27:01,360
to the original object

00:26:58,240 --> 00:27:02,880
starting with c plus plus 20 the default

00:27:01,360 --> 00:27:05,840
capture of this

00:27:02,880 --> 00:27:06,159
by value is deprecated because it's a

00:27:05,840 --> 00:27:08,240
bit

00:27:06,159 --> 00:27:10,240
surprising that you asked for everything

00:27:08,240 --> 00:27:13,440
to be captured by value

00:27:10,240 --> 00:27:16,159
but this was really a pointer so in c

00:27:13,440 --> 00:27:20,240
plus 20 the first example will generate

00:27:16,159 --> 00:27:21,520
a warning when it's compiled we have

00:27:20,240 --> 00:27:23,600
another question

00:27:21,520 --> 00:27:25,600
uh does evaluating the lambda expression

00:27:23,600 --> 00:27:28,960
happen when it's defined

00:27:25,600 --> 00:27:30,240
or when it's first run that's great

00:27:28,960 --> 00:27:31,279
that's a that's a great question that's

00:27:30,240 --> 00:27:32,640
a great question that is a great

00:27:31,279 --> 00:27:34,080
question and it really

00:27:32,640 --> 00:27:36,320
points to the fact that lambda

00:27:34,080 --> 00:27:40,080
expressions sort of get run

00:27:36,320 --> 00:27:41,200
in two parts when we say evaluating a

00:27:40,080 --> 00:27:42,880
lambda expression

00:27:41,200 --> 00:27:46,000
we're talking about the process that

00:27:42,880 --> 00:27:49,120
occurs when it's defined

00:27:46,000 --> 00:27:49,919
then later on when you call the closure

00:27:49,120 --> 00:27:52,240
object

00:27:49,919 --> 00:27:53,039
we call that invoking the lambda

00:27:52,240 --> 00:27:55,520
expression

00:27:53,039 --> 00:27:57,679
and it's important to keep in mind what

00:27:55,520 --> 00:28:00,320
happens at each of those phases

00:27:57,679 --> 00:28:02,000
the evaluation of the lambda expression

00:28:00,320 --> 00:28:04,159
does all the captures

00:28:02,000 --> 00:28:05,520
the invocation of the lambda expression

00:28:04,159 --> 00:28:08,240
runs the body

00:28:05,520 --> 00:28:09,360
great question thank you excellent can

00:28:08,240 --> 00:28:13,279
you call the closure

00:28:09,360 --> 00:28:16,480
my lamb from the lambda expression

00:28:13,279 --> 00:28:18,720
i'm thinking about that i think

00:28:16,480 --> 00:28:20,159
that question is asking inside the

00:28:18,720 --> 00:28:22,000
lambda expression

00:28:20,159 --> 00:28:23,679
do you have access to the closure that

00:28:22,000 --> 00:28:25,760
you're in

00:28:23,679 --> 00:28:27,039
i believe the answer is no yeah we say

00:28:25,760 --> 00:28:28,480
no

00:28:27,039 --> 00:28:31,520
but we'd have to check on that we have

00:28:28,480 --> 00:28:35,200
to check on gold

00:28:31,520 --> 00:28:38,399
okay so we have one more definition

00:28:35,200 --> 00:28:39,120
for the capture clause the c plus

00:28:38,399 --> 00:28:41,120
standard

00:28:39,120 --> 00:28:44,640
says any object created by a lambda

00:28:41,120 --> 00:28:46,080
expression is a closure but if there's

00:28:44,640 --> 00:28:48,559
nothing captured

00:28:46,080 --> 00:28:49,440
the standard actually defines this as

00:28:48,559 --> 00:28:52,080
what's called

00:28:49,440 --> 00:28:53,279
a special kind of closure and this has a

00:28:52,080 --> 00:28:55,039
purpose

00:28:53,279 --> 00:28:57,600
these special closures can be very

00:28:55,039 --> 00:28:58,559
useful when you're calling legacy code

00:28:57,600 --> 00:29:01,679
or some c

00:28:58,559 --> 00:29:04,320
api which expects a function pointer

00:29:01,679 --> 00:29:06,320
because these special closures can be

00:29:04,320 --> 00:29:07,440
implicitly converted to function

00:29:06,320 --> 00:29:09,840
pointers

00:29:07,440 --> 00:29:11,840
that means you can call this api and

00:29:09,840 --> 00:29:13,279
pass a lambda expression as long as

00:29:11,840 --> 00:29:14,799
there is no capture

00:29:13,279 --> 00:29:17,440
and it behaves like you passed a

00:29:14,799 --> 00:29:17,440
function pointer

00:29:17,679 --> 00:29:21,360
so now let's go on and talk about the

00:29:19,120 --> 00:29:24,399
parameter list in a lambda expression

00:29:21,360 --> 00:29:26,640
yes it can be empty it's optional and we

00:29:24,399 --> 00:29:29,520
said you can leave off the parentheses

00:29:26,640 --> 00:29:30,799
but it really does improve readability

00:29:29,520 --> 00:29:32,559
so the parameter list

00:29:30,799 --> 00:29:34,559
you already really know this it's

00:29:32,559 --> 00:29:37,679
similar to a normal function

00:29:34,559 --> 00:29:41,360
parameter list in 11

00:29:37,679 --> 00:29:44,080
default parameters are not allowed

00:29:41,360 --> 00:29:45,360
this was actually an oversight in lambda

00:29:44,080 --> 00:29:47,440
expressions

00:29:45,360 --> 00:29:49,200
they didn't intend this to happen but

00:29:47,440 --> 00:29:51,520
they just kind of forgot

00:29:49,200 --> 00:29:52,320
what's a little interesting is people

00:29:51,520 --> 00:29:55,520
say sometimes

00:29:52,320 --> 00:29:59,120
it was fixed later on this oversight

00:29:55,520 --> 00:30:02,159
was actually fixed retroactively in c

00:29:59,120 --> 00:30:04,880
plus 11. the reason why we mention this

00:30:02,159 --> 00:30:05,520
is if you happen to be using an older c

00:30:04,880 --> 00:30:08,159
plus

00:30:05,520 --> 00:30:09,120
11 compiler this may not have been

00:30:08,159 --> 00:30:10,640
resolved

00:30:09,120 --> 00:30:13,360
so if you're seeing a problem with

00:30:10,640 --> 00:30:14,640
default parameters and you're using 11

00:30:13,360 --> 00:30:16,880
you may just need to update your

00:30:14,640 --> 00:30:20,720
compiler

00:30:16,880 --> 00:30:23,679
c plus 14 added the ability to declare

00:30:20,720 --> 00:30:24,480
a lambda expression parameter using the

00:30:23,679 --> 00:30:27,520
data type

00:30:24,480 --> 00:30:30,080
auto and when you put auto in

00:30:27,520 --> 00:30:31,440
for at least one parameter that lambda

00:30:30,080 --> 00:30:33,840
expression is called

00:30:31,440 --> 00:30:36,000
a generic lambda and we're going to

00:30:33,840 --> 00:30:38,960
cover generic lambdas in more specific

00:30:36,000 --> 00:30:38,960
detail a bit later

00:30:39,520 --> 00:30:43,120
the return type as we've said is

00:30:41,039 --> 00:30:44,480
optional as long as the compiler can

00:30:43,120 --> 00:30:47,679
deduce it

00:30:44,480 --> 00:30:48,960
in 11 you could the compiler could

00:30:47,679 --> 00:30:51,360
deduce it

00:30:48,960 --> 00:30:52,880
if there was and you could only have one

00:30:51,360 --> 00:30:56,159
return type

00:30:52,880 --> 00:30:59,200
so if it could be deduced fine

00:30:56,159 --> 00:31:00,880
in 14 you can have multiple return

00:30:59,200 --> 00:31:03,039
statements now

00:31:00,880 --> 00:31:04,080
but these return statements have to

00:31:03,039 --> 00:31:07,360
return the

00:31:04,080 --> 00:31:08,480
same data type now the example we're

00:31:07,360 --> 00:31:11,440
going to show here

00:31:08,480 --> 00:31:11,760
it is a bit silly and the purpose of

00:31:11,440 --> 00:31:14,960
this

00:31:11,760 --> 00:31:16,080
is to show a use case of when you have

00:31:14,960 --> 00:31:19,200
to specify

00:31:16,080 --> 00:31:20,799
the return type so in this example we

00:31:19,200 --> 00:31:22,880
have two return statements

00:31:20,799 --> 00:31:24,000
and they return different types the

00:31:22,880 --> 00:31:27,120
first one returns an

00:31:24,000 --> 00:31:29,200
int the second returns a double these

00:31:27,120 --> 00:31:31,039
are both convertible to a common type

00:31:29,200 --> 00:31:32,640
you could convert them both to double

00:31:31,039 --> 00:31:34,799
but the compiler won't do that it will

00:31:32,640 --> 00:31:36,240
simply fail with an ambiguous return

00:31:34,799 --> 00:31:38,720
type error

00:31:36,240 --> 00:31:40,799
since we're explicitly specifying that

00:31:38,720 --> 00:31:42,640
we want this lambda expression to have

00:31:40,799 --> 00:31:45,279
the return type double

00:31:42,640 --> 00:31:46,000
our example will compile 5 and the three

00:31:45,279 --> 00:31:50,080
will simply be

00:31:46,000 --> 00:31:50,080
converted to 3.0 in the return

00:31:51,279 --> 00:31:56,159
in c plus 20 lend expressions

00:31:54,320 --> 00:31:58,159
um became a little bit more involved

00:31:56,159 --> 00:31:59,519
there's more sections added

00:31:58,159 --> 00:32:01,200
and we want to spend a little bit of

00:31:59,519 --> 00:32:04,080
time just going over

00:32:01,200 --> 00:32:04,480
what these new sections are but all of

00:32:04,080 --> 00:32:06,960
them

00:32:04,480 --> 00:32:08,080
are optional so if you look at this

00:32:06,960 --> 00:32:09,519
example on the screen

00:32:08,080 --> 00:32:11,600
this is what it's going to start to look

00:32:09,519 --> 00:32:14,080
like with a lambda expression

00:32:11,600 --> 00:32:15,919
notice the first one and the last one

00:32:14,080 --> 00:32:18,640
are highlighted in yellow

00:32:15,919 --> 00:32:20,480
these are the two that are required but

00:32:18,640 --> 00:32:22,640
we're going to start by talking about

00:32:20,480 --> 00:32:24,000
the fact that they've added the ability

00:32:22,640 --> 00:32:27,200
to include

00:32:24,000 --> 00:32:27,760
template parameters this was added for a

00:32:27,200 --> 00:32:30,320
number of

00:32:27,760 --> 00:32:31,840
reasons but one of the most important is

00:32:30,320 --> 00:32:34,960
that in order to support c

00:32:31,840 --> 00:32:37,360
plus plus 20 concepts you needed a way

00:32:34,960 --> 00:32:40,320
to specify a template parameter list on

00:32:37,360 --> 00:32:40,320
a lambda expression

00:32:40,720 --> 00:32:44,000
so we already did talk about the mutable

00:32:42,640 --> 00:32:47,200
specifier

00:32:44,000 --> 00:32:48,480
and in 17 they added the ability to mark

00:32:47,200 --> 00:32:51,279
a lambda expression

00:32:48,480 --> 00:32:52,559
const expert this is actually a bit

00:32:51,279 --> 00:32:56,159
confusing

00:32:52,559 --> 00:32:58,559
because c plus plus 17 is required

00:32:56,159 --> 00:32:59,440
to check and see if it can deduce

00:32:58,559 --> 00:33:03,360
something

00:32:59,440 --> 00:33:04,960
as const expert so if you're using 17

00:33:03,360 --> 00:33:07,600
you really don't need to mark your

00:33:04,960 --> 00:33:09,279
lambda expression as constexpr that's

00:33:07,600 --> 00:33:12,159
going to happen automatically

00:33:09,279 --> 00:33:14,880
so the question is why would you mark a

00:33:12,159 --> 00:33:17,360
lambda expression as const expert

00:33:14,880 --> 00:33:19,039
and the only reason to do this is if you

00:33:17,360 --> 00:33:22,159
have a lambda expression that you

00:33:19,039 --> 00:33:24,720
need to be const expert then marking at

00:33:22,159 --> 00:33:27,360
constexpr will cause a compile error

00:33:24,720 --> 00:33:29,919
if the compiler cannot deduce its const

00:33:27,360 --> 00:33:32,080
experiments

00:33:29,919 --> 00:33:34,480
in c plus plus 20 you also gain the

00:33:32,080 --> 00:33:37,600
ability to mark a lambda expression as

00:33:34,480 --> 00:33:39,600
const eval and this

00:33:37,600 --> 00:33:41,519
acts very similar to the way const

00:33:39,600 --> 00:33:42,640
expert does in terms of the lambda

00:33:41,519 --> 00:33:45,039
expression

00:33:42,640 --> 00:33:47,600
but as far as what consti val means

00:33:45,039 --> 00:33:48,799
we'll leave that one for another talk

00:33:47,600 --> 00:33:50,880
we have another question that just

00:33:48,799 --> 00:33:54,399
popped up um that's on

00:33:50,880 --> 00:33:56,960
slide 25 talking about um

00:33:54,399 --> 00:34:00,000
i think this was the special kind and

00:33:56,960 --> 00:34:02,640
does it have a specific name

00:34:00,000 --> 00:34:04,159
regrettably the specific name that it

00:34:02,640 --> 00:34:07,360
uses in the standard

00:34:04,159 --> 00:34:09,599
is a special type of closure

00:34:07,360 --> 00:34:11,919
so that is the technical term from the

00:34:09,599 --> 00:34:14,720
standard of what it is called

00:34:11,919 --> 00:34:16,639
and somebody's asking if oh if if const

00:34:14,720 --> 00:34:20,560
expert can be used inside

00:34:16,639 --> 00:34:21,119
a lambda expression that's a fascinating

00:34:20,560 --> 00:34:25,040
question

00:34:21,119 --> 00:34:27,679
and the answer is yes if that lambda

00:34:25,040 --> 00:34:29,520
expression is generic

00:34:27,679 --> 00:34:31,760
which follows the exact same rules as

00:34:29,520 --> 00:34:34,560
the rest of the language because

00:34:31,760 --> 00:34:36,720
if constexpr needs to appear inside the

00:34:34,560 --> 00:34:38,960
body of something which is templated

00:34:36,720 --> 00:34:39,919
and yet so you can use if const expert

00:34:38,960 --> 00:34:42,960
within the body

00:34:39,919 --> 00:34:46,399
in the body of the lambda expression

00:34:42,960 --> 00:34:48,159
okay so the next cause we have is the

00:34:46,399 --> 00:34:50,320
exception specifier

00:34:48,159 --> 00:34:51,679
this actually hasn't changed since 11

00:34:50,320 --> 00:34:52,720
but we thought it'd be good to bring it

00:34:51,679 --> 00:34:56,240
up

00:34:52,720 --> 00:34:58,160
marking a lambda expression as no except

00:34:56,240 --> 00:34:59,440
and this is going back to the fact of

00:34:58,160 --> 00:35:02,480
why we talked about

00:34:59,440 --> 00:35:04,480
the function call operator so remember

00:35:02,480 --> 00:35:06,800
what you're actually writing is

00:35:04,480 --> 00:35:09,440
basically a function called operator

00:35:06,800 --> 00:35:11,440
in the body of your lambda expression so

00:35:09,440 --> 00:35:13,839
if you're marking it as no except

00:35:11,440 --> 00:35:14,640
in the specifier when the closure is

00:35:13,839 --> 00:35:17,839
invoked

00:35:14,640 --> 00:35:17,839
it cannot throw

00:35:19,839 --> 00:35:23,359
now we come to the function attributes

00:35:22,400 --> 00:35:26,400
and this one's a bit

00:35:23,359 --> 00:35:27,359
tricky not many people know this but

00:35:26,400 --> 00:35:29,440
there are actually

00:35:27,359 --> 00:35:30,560
two different groups of function

00:35:29,440 --> 00:35:33,119
attributes in c

00:35:30,560 --> 00:35:35,359
plus based on where they can appear in

00:35:33,119 --> 00:35:37,359
the declaration

00:35:35,359 --> 00:35:38,720
for a normal function the attributes

00:35:37,359 --> 00:35:41,920
that we typically use

00:35:38,720 --> 00:35:44,079
like deprecated or no discard they

00:35:41,920 --> 00:35:45,520
appear in an attribute block before the

00:35:44,079 --> 00:35:49,119
return type

00:35:45,520 --> 00:35:51,200
and these are called function attributes

00:35:49,119 --> 00:35:53,200
those are not currently supported on a

00:35:51,200 --> 00:35:55,359
lambda expression

00:35:53,200 --> 00:35:57,040
there is a proposal pending to add this

00:35:55,359 --> 00:35:58,320
but it hasn't made it into the standard

00:35:57,040 --> 00:36:01,520
yet and it's not clear

00:35:58,320 --> 00:36:04,320
if or when it's going to be added

00:36:01,520 --> 00:36:06,400
there's a second set of attributes which

00:36:04,320 --> 00:36:08,560
appear at the end of a declaration

00:36:06,400 --> 00:36:10,839
these are called function type

00:36:08,560 --> 00:36:12,320
attributes and these modify the

00:36:10,839 --> 00:36:14,560
signature

00:36:12,320 --> 00:36:16,240
these are all compiler and platform

00:36:14,560 --> 00:36:18,320
specific attributes

00:36:16,240 --> 00:36:20,480
usually things that change the platform

00:36:18,320 --> 00:36:24,079
abi calling convention

00:36:20,480 --> 00:36:26,480
like gnu colon colon c decal

00:36:24,079 --> 00:36:27,680
these attributes can be placed before

00:36:26,480 --> 00:36:30,400
the return type

00:36:27,680 --> 00:36:32,640
of a lambda expression but don't try

00:36:30,400 --> 00:36:35,760
marking a lambda expression no discard

00:36:32,640 --> 00:36:35,760
it won't work yet

00:36:37,359 --> 00:36:40,640
so the last section we have is the

00:36:39,200 --> 00:36:44,160
requires clause

00:36:40,640 --> 00:36:46,720
which is located just before the body

00:36:44,160 --> 00:36:48,960
and this is used to add a constraint on

00:36:46,720 --> 00:36:50,720
the lambda expression

00:36:48,960 --> 00:36:52,960
and as you can see in our example we

00:36:50,720 --> 00:36:55,520
have a constraint on t

00:36:52,960 --> 00:36:56,800
and this is checked at compile time we

00:36:55,520 --> 00:36:59,359
want to make sure that t

00:36:56,800 --> 00:37:01,280
is copyable and this example that's

00:36:59,359 --> 00:37:04,560
exactly what a requires clause

00:37:01,280 --> 00:37:04,880
will look like in 20 and you can put it

00:37:04,560 --> 00:37:08,320
in

00:37:04,880 --> 00:37:10,800
your lambda expression and to use this

00:37:08,320 --> 00:37:11,440
it does require that the lambda

00:37:10,800 --> 00:37:13,280
expression

00:37:11,440 --> 00:37:14,880
be generic we were just talking about

00:37:13,280 --> 00:37:17,680
that with the question

00:37:14,880 --> 00:37:19,040
and again what makes it generic there

00:37:17,680 --> 00:37:21,680
has to be

00:37:19,040 --> 00:37:22,400
a template a t in the template parameter

00:37:21,680 --> 00:37:25,040
list

00:37:22,400 --> 00:37:26,000
or at least one parameter in the

00:37:25,040 --> 00:37:29,119
parameter list

00:37:26,000 --> 00:37:32,320
has to be marked to auto keep in mind

00:37:29,119 --> 00:37:35,440
in 20 you will be able to mix this so

00:37:32,320 --> 00:37:38,000
in in a parameter list you can have

00:37:35,440 --> 00:37:38,880
one thing auto you can have a template

00:37:38,000 --> 00:37:41,119
parameter

00:37:38,880 --> 00:37:43,359
it's not just one thing you're allowed

00:37:41,119 --> 00:37:45,760
to mix these all up

00:37:43,359 --> 00:37:47,359
will these slides be available yes we

00:37:45,760 --> 00:37:48,079
will be making the slides available

00:37:47,359 --> 00:37:51,839
afterwards

00:37:48,079 --> 00:37:51,839
thank you

00:37:52,160 --> 00:37:56,560
so this brings up a really interesting

00:37:54,640 --> 00:37:58,720
point to us

00:37:56,560 --> 00:38:00,160
why are lambda expressions so darn

00:37:58,720 --> 00:38:02,560
important

00:38:00,160 --> 00:38:03,280
you can write the equivalent code you

00:38:02,560 --> 00:38:05,359
can write

00:38:03,280 --> 00:38:07,599
the function object data type you can

00:38:05,359 --> 00:38:10,960
write the boilerplate

00:38:07,599 --> 00:38:13,200
so why did they go to all of this work

00:38:10,960 --> 00:38:14,400
it's more effective to write the body of

00:38:13,200 --> 00:38:17,520
the function object

00:38:14,400 --> 00:38:19,200
and let the compiler do the rest one of

00:38:17,520 --> 00:38:20,079
the really nice things about lambda

00:38:19,200 --> 00:38:23,119
expressions

00:38:20,079 --> 00:38:24,960
is as we move more toward a functional

00:38:23,119 --> 00:38:28,000
style of programming in c

00:38:24,960 --> 00:38:31,280
plus as many programmers are calling

00:38:28,000 --> 00:38:33,920
functions like std visit just reads

00:38:31,280 --> 00:38:35,599
better when you use a lambda expression

00:38:33,920 --> 00:38:37,200
for the function object

00:38:35,599 --> 00:38:39,599
because all the code that's needed to

00:38:37,200 --> 00:38:41,599
understand the expression is present in

00:38:39,599 --> 00:38:43,359
one place

00:38:41,599 --> 00:38:45,359
one of the things that's really amazing

00:38:43,359 --> 00:38:46,720
about the way lambda expressions were

00:38:45,359 --> 00:38:48,800
implemented

00:38:46,720 --> 00:38:49,920
is that all of the existing standard

00:38:48,800 --> 00:38:52,880
library functions

00:38:49,920 --> 00:38:54,240
like algorithms still work perfectly

00:38:52,880 --> 00:38:57,040
with lambda expressions

00:38:54,240 --> 00:38:57,839
and didn't need to be changed this is a

00:38:57,040 --> 00:39:00,720
testament

00:38:57,839 --> 00:39:03,040
to how carefully the standard designed

00:39:00,720 --> 00:39:05,280
the idea of a lambda expression and

00:39:03,040 --> 00:39:08,960
fit it into the existing framework we

00:39:05,280 --> 00:39:08,960
had for function objects

00:39:09,119 --> 00:39:13,680
so here's how it actually all works and

00:39:12,000 --> 00:39:15,200
this is the slide we say is sort of like

00:39:13,680 --> 00:39:18,000
the take away

00:39:15,200 --> 00:39:19,040
you write your lambda expression the

00:39:18,000 --> 00:39:21,839
compiler

00:39:19,040 --> 00:39:22,640
will generate the function object data

00:39:21,839 --> 00:39:24,560
type

00:39:22,640 --> 00:39:25,760
remember the function object data type

00:39:24,560 --> 00:39:27,520
this is the class with all the

00:39:25,760 --> 00:39:29,359
boilerplate

00:39:27,520 --> 00:39:31,359
and there's a lot of pieces the compiler

00:39:29,359 --> 00:39:32,720
will write and it knows exactly how to

00:39:31,359 --> 00:39:35,760
do it

00:39:32,720 --> 00:39:37,920
at runtime the constructor

00:39:35,760 --> 00:39:38,960
of this function object data type is

00:39:37,920 --> 00:39:42,079
called

00:39:38,960 --> 00:39:43,599
this is what produces a closure

00:39:42,079 --> 00:39:45,920
and the closure you can call it

00:39:43,599 --> 00:39:46,720
immediately store it in a variable like

00:39:45,920 --> 00:39:49,760
we've been doing

00:39:46,720 --> 00:39:53,040
putting it in my lamb or you can pass it

00:39:49,760 --> 00:39:56,400
to another function as programmers

00:39:53,040 --> 00:39:58,079
we normally write classes methods

00:39:56,400 --> 00:40:00,160
to us as we were looking at lambda

00:39:58,079 --> 00:40:01,839
expressions everything feels sort of

00:40:00,160 --> 00:40:04,480
backwards

00:40:01,839 --> 00:40:05,920
and it is because you're writing the

00:40:04,480 --> 00:40:08,880
function

00:40:05,920 --> 00:40:09,520
the function um class you're actually

00:40:08,880 --> 00:40:12,160
writing

00:40:09,520 --> 00:40:12,640
that function call operator you're not

00:40:12,160 --> 00:40:15,760
writing

00:40:12,640 --> 00:40:18,720
the class but the insides

00:40:15,760 --> 00:40:19,359
so our suggestion is think of this as

00:40:18,720 --> 00:40:21,760
yes

00:40:19,359 --> 00:40:23,760
you are just writing that single

00:40:21,760 --> 00:40:25,280
function call operator

00:40:23,760 --> 00:40:27,440
and you're going to let the compiler

00:40:25,280 --> 00:40:31,119
write everything around it

00:40:27,440 --> 00:40:31,119
the class and instantiate it

00:40:32,480 --> 00:40:35,680
so now that we've looked at the

00:40:33,680 --> 00:40:37,359
structure and the layout of a lambda

00:40:35,680 --> 00:40:38,880
expression we want to go over some

00:40:37,359 --> 00:40:40,400
examples

00:40:38,880 --> 00:40:43,200
and the first one we're going to show

00:40:40,400 --> 00:40:44,880
uses a lambda expression as a callback

00:40:43,200 --> 00:40:47,040
so for a quick review we want to look at

00:40:44,880 --> 00:40:49,040
the definition

00:40:47,040 --> 00:40:50,240
from computer science we get the idea

00:40:49,040 --> 00:40:52,800
that a callback

00:40:50,240 --> 00:40:53,440
is a function which is passed as an

00:40:52,800 --> 00:40:57,040
argument

00:40:53,440 --> 00:40:57,520
to another function now callbacks can be

00:40:57,040 --> 00:40:59,680
passed

00:40:57,520 --> 00:41:00,880
as a function pointer or a function

00:40:59,680 --> 00:41:04,720
object in c

00:41:00,880 --> 00:41:06,079
plus so this is nice we can write a

00:41:04,720 --> 00:41:08,960
lambda expression

00:41:06,079 --> 00:41:10,640
and then pass the resulting closure and

00:41:08,960 --> 00:41:12,800
our callback will be invoked

00:41:10,640 --> 00:41:15,520
at the discretion of the receiver based

00:41:12,800 --> 00:41:15,520
on what it's doing

00:41:15,760 --> 00:41:19,599
so here's an example and we're showing a

00:41:17,760 --> 00:41:20,960
callback and it's being passed to an

00:41:19,599 --> 00:41:23,920
algorithm

00:41:20,960 --> 00:41:25,680
on the first line we're just declaring a

00:41:23,920 --> 00:41:28,720
vector of integers

00:41:25,680 --> 00:41:30,560
in example a we define a free function

00:41:28,720 --> 00:41:31,760
because that's the part we're going to

00:41:30,560 --> 00:41:34,160
show first

00:41:31,760 --> 00:41:35,920
and this is my callback and it's

00:41:34,160 --> 00:41:36,560
responsible for testing if the pass

00:41:35,920 --> 00:41:39,200
parameter

00:41:36,560 --> 00:41:40,000
is greater than five the algorithm

00:41:39,200 --> 00:41:42,000
countif

00:41:40,000 --> 00:41:43,040
it expects a callback and it will just

00:41:42,000 --> 00:41:45,040
return a bool

00:41:43,040 --> 00:41:49,040
when it's invoked and this is just going

00:41:45,040 --> 00:41:51,839
to count how many times we got a true

00:41:49,040 --> 00:41:52,560
in example b we're doing exactly the

00:41:51,839 --> 00:41:55,520
same thing

00:41:52,560 --> 00:41:57,040
but using a lambda expression all the

00:41:55,520 --> 00:42:00,640
relevant code is located

00:41:57,040 --> 00:42:01,119
in place on this one line and our belief

00:42:00,640 --> 00:42:02,640
is

00:42:01,119 --> 00:42:04,560
this is much more readable and

00:42:02,640 --> 00:42:05,760
convenient because you don't have to

00:42:04,560 --> 00:42:08,560
look somewhere in

00:42:05,760 --> 00:42:10,000
else in the code to find out what my

00:42:08,560 --> 00:42:12,400
callback is testing for

00:42:10,000 --> 00:42:13,920
you can just read it right here keep in

00:42:12,400 --> 00:42:16,400
mind that both example a

00:42:13,920 --> 00:42:17,200
and example b they will produce the same

00:42:16,400 --> 00:42:18,960
result

00:42:17,200 --> 00:42:20,240
we are just saying that we think example

00:42:18,960 --> 00:42:22,079
b is

00:42:20,240 --> 00:42:23,520
easier to read and again you're not

00:42:22,079 --> 00:42:26,640
having to go search for

00:42:23,520 --> 00:42:30,720
where the callback um was defined

00:42:26,640 --> 00:42:32,800
for example a we do have a question

00:42:30,720 --> 00:42:34,079
it's a little squished uh since the

00:42:32,800 --> 00:42:36,560
constructor of the function

00:42:34,079 --> 00:42:38,800
object is called is there significant

00:42:36,560 --> 00:42:42,240
performance difference

00:42:38,800 --> 00:42:42,240
between a regular function

00:42:43,119 --> 00:42:47,680
we didn't do you know a timing study on

00:42:46,400 --> 00:42:49,280
that

00:42:47,680 --> 00:42:50,800
we haven't benchmarked that yet but we

00:42:49,280 --> 00:42:52,720
haven't benchmarked if

00:42:50,800 --> 00:42:55,920
if you have a function call and you turn

00:42:52,720 --> 00:42:57,599
it into an equivalent lambda expression

00:42:55,920 --> 00:42:59,200
then you won't have a capture clause

00:42:57,599 --> 00:42:59,760
because functions certainly can't

00:42:59,200 --> 00:43:02,400
capture

00:42:59,760 --> 00:43:04,480
yeah so the constructor will be trivial

00:43:02,400 --> 00:43:05,520
i'd be surprised if any good compiler

00:43:04,480 --> 00:43:07,760
will generate

00:43:05,520 --> 00:43:12,880
more expensive code for the lambda

00:43:07,760 --> 00:43:14,720
expression case

00:43:12,880 --> 00:43:16,400
so here's an example taking off from the

00:43:14,720 --> 00:43:19,280
last one and again

00:43:16,400 --> 00:43:20,880
now we're doing a capture clause so our

00:43:19,280 --> 00:43:22,319
lambda expression is going to capture

00:43:20,880 --> 00:43:24,640
the value of ch

00:43:22,319 --> 00:43:26,319
from that local scope and in this

00:43:24,640 --> 00:43:28,480
example we're going to check if

00:43:26,319 --> 00:43:30,160
str starts with the character that we

00:43:28,480 --> 00:43:31,839
want to match on

00:43:30,160 --> 00:43:33,760
the closure returns true or false just

00:43:31,839 --> 00:43:36,160
as it did before and count f would

00:43:33,760 --> 00:43:38,960
return the number of matches

00:43:36,160 --> 00:43:40,480
writing this callback as a free function

00:43:38,960 --> 00:43:43,280
doesn't work

00:43:40,480 --> 00:43:45,119
there's no place to store the value for

00:43:43,280 --> 00:43:46,720
ch

00:43:45,119 --> 00:43:49,040
so here's a place where a lambda

00:43:46,720 --> 00:43:50,960
expression allows us to do something

00:43:49,040 --> 00:43:52,319
which is impossible with a function

00:43:50,960 --> 00:43:53,280
pointer because there's nowhere to put

00:43:52,319 --> 00:43:55,359
the data

00:43:53,280 --> 00:43:56,480
and messy with a function object you

00:43:55,359 --> 00:43:58,400
would need to write a lot more

00:43:56,480 --> 00:44:01,200
boilerplate to do this if you wanted to

00:43:58,400 --> 00:44:01,200
do it manually

00:44:02,640 --> 00:44:04,960
okay

00:44:06,000 --> 00:44:13,040
you want to look at the questions

00:44:09,359 --> 00:44:16,079
uh will example be on slide 36

00:44:13,040 --> 00:44:16,079
prevent jump

00:44:16,560 --> 00:44:19,680
i have not looked at the assembly yeah

00:44:18,800 --> 00:44:21,280
it would very

00:44:19,680 --> 00:44:22,800
that would be very compiler specific

00:44:21,280 --> 00:44:24,400
yeah completely specific

00:44:22,800 --> 00:44:26,319
and the other question was how can a

00:44:24,400 --> 00:44:29,440
lambda recurse

00:44:26,319 --> 00:44:31,760
and i believe the answer is it can't

00:44:29,440 --> 00:44:32,880
because you can't name the lambda within

00:44:31,760 --> 00:44:35,280
its own body

00:44:32,880 --> 00:44:36,000
yes there's no way to refer there's no

00:44:35,280 --> 00:44:40,319
way to refer to

00:44:36,000 --> 00:44:40,880
it so now let's look at how you would

00:44:40,319 --> 00:44:43,200
capture

00:44:40,880 --> 00:44:45,920
something like an std unique pointer

00:44:43,200 --> 00:44:48,079
which is not copyable

00:44:45,920 --> 00:44:50,800
so we start this example by calling make

00:44:48,079 --> 00:44:52,480
unique to construct a new widget

00:44:50,800 --> 00:44:54,960
which returns a unique pointer to the

00:44:52,480 --> 00:44:58,400
new widget object

00:44:54,960 --> 00:45:00,560
we're then going to use a move capture

00:44:58,400 --> 00:45:01,920
to move the unique pointer into the

00:45:00,560 --> 00:45:03,839
closure

00:45:01,920 --> 00:45:06,240
and notice this uses a generalized

00:45:03,839 --> 00:45:09,599
lambda capture so this code requires c

00:45:06,240 --> 00:45:12,319
plus plus 14. we want to mention

00:45:09,599 --> 00:45:13,520
that we could have done this capture and

00:45:12,319 --> 00:45:16,480
named

00:45:13,520 --> 00:45:18,000
the variable mypointer just like it was

00:45:16,480 --> 00:45:20,720
in the outer scope

00:45:18,000 --> 00:45:22,880
instead of calling it captured pointer

00:45:20,720 --> 00:45:25,440
but we suggest you avoid this

00:45:22,880 --> 00:45:26,400
and use a different name it reads a lot

00:45:25,440 --> 00:45:28,960
better in the code

00:45:26,400 --> 00:45:30,960
if you actually change the name in the

00:45:28,960 --> 00:45:33,359
generalized lambda

00:45:30,960 --> 00:45:35,920
and since the the lambda expression

00:45:33,359 --> 00:45:38,400
captures the unique pointer

00:45:35,920 --> 00:45:39,920
the compiler is actually going to

00:45:38,400 --> 00:45:43,119
generate this class

00:45:39,920 --> 00:45:45,839
and it's not going to be copyable

00:45:43,119 --> 00:45:47,359
and this makes sense because the unique

00:45:45,839 --> 00:45:49,920
pointer is actually stored

00:45:47,359 --> 00:45:52,400
in the closure so this closure can't be

00:45:49,920 --> 00:45:52,400
copied

00:45:52,640 --> 00:45:56,000
the side effect of this is you cannot

00:45:55,520 --> 00:45:59,680
store

00:45:56,000 --> 00:46:02,160
this closure in an std function object

00:45:59,680 --> 00:46:02,720
because std function requires that the

00:46:02,160 --> 00:46:05,920
object

00:46:02,720 --> 00:46:07,839
it stores be copyable

00:46:05,920 --> 00:46:11,520
is there performance benefit for using

00:46:07,839 --> 00:46:11,520
lambda versus a function call

00:46:12,960 --> 00:46:16,400
readability that would definitely be one

00:46:14,800 --> 00:46:18,240
of the issues that i would look at

00:46:16,400 --> 00:46:19,920
i am always looking to make my code more

00:46:18,240 --> 00:46:21,440
readable so that feels like a

00:46:19,920 --> 00:46:23,839
performance benefit

00:46:21,440 --> 00:46:25,839
um in terms of a timing study you would

00:46:23,839 --> 00:46:27,920
have to sort of look at the code

00:46:25,839 --> 00:46:29,520
but again remember you're writing the

00:46:27,920 --> 00:46:32,079
function call operator

00:46:29,520 --> 00:46:33,760
the compiler is doing all the outer work

00:46:32,079 --> 00:46:35,680
and we strongly believe

00:46:33,760 --> 00:46:37,119
that this is a part where the compiler

00:46:35,680 --> 00:46:39,359
has really been able to

00:46:37,119 --> 00:46:41,440
optimize and and write it more

00:46:39,359 --> 00:46:44,720
efficiently than i can

00:46:41,440 --> 00:46:46,720
also in general in c plus plus calling

00:46:44,720 --> 00:46:48,160
a function pointer is more expensive

00:46:46,720 --> 00:46:50,880
than calling a function

00:46:48,160 --> 00:46:52,800
object in many cases so lambda

00:46:50,880 --> 00:46:54,839
expressions get that benefit that

00:46:52,800 --> 00:46:57,839
function pointers are actually not

00:46:54,839 --> 00:46:57,839
preferred

00:46:58,319 --> 00:47:01,839
so we've mentioned that when you store a

00:47:01,119 --> 00:47:05,280
closure

00:47:01,839 --> 00:47:07,119
you almost always use the data type auto

00:47:05,280 --> 00:47:08,880
but how do you declare the data type if

00:47:07,119 --> 00:47:09,839
you're passing a closure to another

00:47:08,880 --> 00:47:11,599
function

00:47:09,839 --> 00:47:13,760
because you can't declare a function

00:47:11,599 --> 00:47:16,160
parameter with auto

00:47:13,760 --> 00:47:17,760
so we have three lines of code here and

00:47:16,160 --> 00:47:18,880
we're declaring our lambda expression

00:47:17,760 --> 00:47:21,119
and assigning it

00:47:18,880 --> 00:47:23,359
the closure to my lamb and then you can

00:47:21,119 --> 00:47:26,800
see we're passing my lamb to do thing a

00:47:23,359 --> 00:47:29,520
and do thing b in example a

00:47:26,800 --> 00:47:29,920
we're declaring a templated function

00:47:29,520 --> 00:47:32,640
which

00:47:29,920 --> 00:47:34,720
has the ability to deduce the type the

00:47:32,640 --> 00:47:38,000
data type of our closure

00:47:34,720 --> 00:47:41,040
in example b we're actually storing

00:47:38,000 --> 00:47:43,520
our closure in an std function

00:47:41,040 --> 00:47:45,119
and this is two different ways to do it

00:47:43,520 --> 00:47:47,119
they both work

00:47:45,119 --> 00:47:49,520
and we did want to mention that the

00:47:47,119 --> 00:47:53,440
syntax for the declaration of

00:47:49,520 --> 00:47:55,760
std function it is a little bit odd

00:47:53,440 --> 00:47:56,880
first we have the int that declares the

00:47:55,760 --> 00:48:00,079
return type

00:47:56,880 --> 00:48:02,880
and the double that is the data type for

00:48:00,079 --> 00:48:02,880
the parameter

00:48:05,760 --> 00:48:10,800
so there's something kind of fun with

00:48:07,680 --> 00:48:12,880
std map but not everybody uses it

00:48:10,800 --> 00:48:13,839
you can actually use the third template

00:48:12,880 --> 00:48:16,480
parameter

00:48:13,839 --> 00:48:17,280
to redefine and say how should the

00:48:16,480 --> 00:48:20,319
comparison

00:48:17,280 --> 00:48:21,119
happen and what you need to do is

00:48:20,319 --> 00:48:24,000
specify

00:48:21,119 --> 00:48:24,960
a template parameter so in this example

00:48:24,000 --> 00:48:28,079
we're passing

00:48:24,960 --> 00:48:30,000
a function object data type mycompare

00:48:28,079 --> 00:48:32,079
we wrote the struct we wrote the

00:48:30,000 --> 00:48:34,640
operator open close

00:48:32,079 --> 00:48:36,800
and we're just passing this information

00:48:34,640 --> 00:48:39,359
so the operator open close method

00:48:36,800 --> 00:48:41,040
it's pretty darn simple and it's doing a

00:48:39,359 --> 00:48:43,440
comparison

00:48:41,040 --> 00:48:44,160
this is pretty much how a map works

00:48:43,440 --> 00:48:47,680
anyway

00:48:44,160 --> 00:48:50,240
we're doing the less than comparison

00:48:47,680 --> 00:48:52,160
and as you can see might compare just

00:48:50,240 --> 00:48:53,599
the data type is passed

00:48:52,160 --> 00:48:55,520
but this is sort of the old-fashioned

00:48:53,599 --> 00:48:58,079
way we should be using a lambda

00:48:55,520 --> 00:48:58,079
expression

00:48:59,119 --> 00:49:02,160
so we're going to start by declaring a

00:49:01,040 --> 00:49:04,319
lambda expression

00:49:02,160 --> 00:49:06,480
which implements a comparison and you'll

00:49:04,319 --> 00:49:07,119
notice the body is exactly the same as

00:49:06,480 --> 00:49:10,079
we had

00:49:07,119 --> 00:49:11,680
when we were using a function object the

00:49:10,079 --> 00:49:13,040
code's a bit easier to read

00:49:11,680 --> 00:49:15,440
because we've removed a lot of

00:49:13,040 --> 00:49:17,839
extraneous boilerplate

00:49:15,440 --> 00:49:18,640
but notice we have to use decal type

00:49:17,839 --> 00:49:21,119
mylam

00:49:18,640 --> 00:49:23,359
for the third template parameter because

00:49:21,119 --> 00:49:26,960
we need to specify a data type

00:49:23,359 --> 00:49:29,119
for the third parameter of std map

00:49:26,960 --> 00:49:30,960
now in this example specifying the data

00:49:29,119 --> 00:49:33,760
type is sufficient

00:49:30,960 --> 00:49:36,640
because our map can default construct an

00:49:33,760 --> 00:49:39,440
instance of the closure

00:49:36,640 --> 00:49:41,359
however if you want to take advantage of

00:49:39,440 --> 00:49:44,000
the fact that lambda expressions can

00:49:41,359 --> 00:49:46,319
capture values for example you might

00:49:44,000 --> 00:49:49,680
want to capture a particular locale

00:49:46,319 --> 00:49:52,720
to do a locale aware string comparison

00:49:49,680 --> 00:49:54,319
keep in mind if you add a capture to the

00:49:52,720 --> 00:49:56,240
lambda expression

00:49:54,319 --> 00:49:58,079
then you're going to need to pass an

00:49:56,240 --> 00:50:00,720
instance of the closure

00:49:58,079 --> 00:50:02,960
when you construct the map because the

00:50:00,720 --> 00:50:05,680
closure type will no longer be default

00:50:02,960 --> 00:50:05,680
constructable

00:50:06,960 --> 00:50:12,559
so as a reminder if any parameter uses

00:50:10,160 --> 00:50:15,440
the data type of auto it's called

00:50:12,559 --> 00:50:16,079
a generic lambda when you have a generic

00:50:15,440 --> 00:50:17,599
lambda

00:50:16,079 --> 00:50:19,440
the compiler is actually going to

00:50:17,599 --> 00:50:22,079
generate a templated

00:50:19,440 --> 00:50:23,359
function call operator so in this

00:50:22,079 --> 00:50:25,760
example

00:50:23,359 --> 00:50:28,240
we have the word auto one of them is in

00:50:25,760 --> 00:50:31,119
yellow and one of them is in purple

00:50:28,240 --> 00:50:32,960
but these are not the same auto they do

00:50:31,119 --> 00:50:35,680
different things

00:50:32,960 --> 00:50:36,720
the auto that we're showing in yellow is

00:50:35,680 --> 00:50:39,680
not what makes

00:50:36,720 --> 00:50:42,079
this expression a generic lambda this

00:50:39,680 --> 00:50:43,119
auto is being used for type deduction of

00:50:42,079 --> 00:50:44,880
the closure

00:50:43,119 --> 00:50:46,559
as you normally do with any lambda

00:50:44,880 --> 00:50:49,200
expression

00:50:46,559 --> 00:50:50,640
the auto in purple is the function

00:50:49,200 --> 00:50:52,839
template argument

00:50:50,640 --> 00:50:55,359
and this is what makes it a generic

00:50:52,839 --> 00:50:56,160
lambda and it's important to be aware of

00:50:55,359 --> 00:50:58,240
this

00:50:56,160 --> 00:51:00,000
because the rules for auto type

00:50:58,240 --> 00:51:03,200
deduction of a variable

00:51:00,000 --> 00:51:05,760
are not quite the same as the rules for

00:51:03,200 --> 00:51:08,240
data type deduction as a in a function

00:51:05,760 --> 00:51:11,119
template argument

00:51:08,240 --> 00:51:12,000
now in c plus 20 when we gain the

00:51:11,119 --> 00:51:15,119
ability

00:51:12,000 --> 00:51:15,680
to use t as a template parameter as a

00:51:15,119 --> 00:51:18,720
named

00:51:15,680 --> 00:51:20,079
template parameter if you replace the

00:51:18,720 --> 00:51:22,880
purple auto

00:51:20,079 --> 00:51:24,480
with a t you still call the expression a

00:51:22,880 --> 00:51:26,240
generic lambda

00:51:24,480 --> 00:51:28,240
and we did mention before but it's worth

00:51:26,240 --> 00:51:30,559
bringing up that once you add those

00:51:28,240 --> 00:51:32,960
template parameters and you're using 20

00:51:30,559 --> 00:51:34,559
you can mix and match so you could have

00:51:32,960 --> 00:51:36,720
an auto and a t

00:51:34,559 --> 00:51:38,160
and again as long as there's one auto or

00:51:36,720 --> 00:51:40,800
one t

00:51:38,160 --> 00:51:43,200
then you are in then you have a generic

00:51:40,800 --> 00:51:43,200
lambda

00:51:44,000 --> 00:51:48,960
so we always like to toss in one sort of

00:51:46,480 --> 00:51:51,520
surprising example

00:51:48,960 --> 00:51:54,000
and this is our surprising example

00:51:51,520 --> 00:51:55,920
structured bindings

00:51:54,000 --> 00:51:57,760
they're not actually they're not

00:51:55,920 --> 00:51:59,680
technically variables

00:51:57,760 --> 00:52:01,839
but there was an oversight and they

00:51:59,680 --> 00:52:04,960
don't work in a capture

00:52:01,839 --> 00:52:06,720
our code on line a it declares two

00:52:04,960 --> 00:52:09,920
structured bindings

00:52:06,720 --> 00:52:13,040
one name x and the other y

00:52:09,920 --> 00:52:16,160
line b is a normal lambda expression

00:52:13,040 --> 00:52:16,160
with a capture clause

00:52:16,559 --> 00:52:23,440
and in c plus 17 line b

00:52:19,839 --> 00:52:26,720
is actually ill-formed however

00:52:23,440 --> 00:52:27,920
msvc and gcc said that's fine i don't

00:52:26,720 --> 00:52:29,200
care

00:52:27,920 --> 00:52:31,119
i'm just going to go ahead i'm not

00:52:29,200 --> 00:52:32,160
reporting an error i know you wanted to

00:52:31,119 --> 00:52:35,920
do a capture

00:52:32,160 --> 00:52:37,760
and everything works fine however

00:52:35,920 --> 00:52:39,359
this was incorrect because this

00:52:37,760 --> 00:52:43,359
shouldn't be allowed in c

00:52:39,359 --> 00:52:45,760
plus 17. this bug was resolved

00:52:43,359 --> 00:52:46,559
in the c plus 20 standard and they

00:52:45,760 --> 00:52:49,119
allowed

00:52:46,559 --> 00:52:50,400
capturing a structured binding

00:52:49,119 --> 00:52:53,440
unfortunately

00:52:50,400 --> 00:52:55,280
clang has not caught up with c plus 20.

00:52:53,440 --> 00:52:56,960
so if you test this code on the very

00:52:55,280 --> 00:52:58,720
latest version of clang

00:52:56,960 --> 00:53:01,119
it still reports an error saying you

00:52:58,720 --> 00:53:04,400
cannot capture a structured binding

00:53:01,119 --> 00:53:05,839
that's a known bug the workaround for

00:53:04,400 --> 00:53:09,040
this is quite simple

00:53:05,839 --> 00:53:10,319
but silly you can use a generalized

00:53:09,040 --> 00:53:13,440
lambda capture

00:53:10,319 --> 00:53:14,000
and instead of just capturing x you

00:53:13,440 --> 00:53:18,079
capture

00:53:14,000 --> 00:53:20,640
x equals x because a generalized capture

00:53:18,079 --> 00:53:24,079
of a structured binding works

00:53:20,640 --> 00:53:25,520
so this will work in 17 or 20 no matter

00:53:24,079 --> 00:53:26,839
which compiler you use

00:53:25,520 --> 00:53:29,280
and how they're interpreting the

00:53:26,839 --> 00:53:29,920
standard so there's your silly work

00:53:29,280 --> 00:53:32,400
around

00:53:29,920 --> 00:53:33,440
just use a generalized capture of x

00:53:32,400 --> 00:53:34,640
equals x

00:53:33,440 --> 00:53:37,680
and you don't have to worry which

00:53:34,640 --> 00:53:37,680
compiler you're using

00:53:39,599 --> 00:53:43,359
so we decided to close our talk with a

00:53:41,839 --> 00:53:46,400
nice summary

00:53:43,359 --> 00:53:49,520
especially since well we kept confusing

00:53:46,400 --> 00:53:51,200
generalized capture and a generic lambda

00:53:49,520 --> 00:53:54,880
so we thought this slide really

00:53:51,200 --> 00:53:57,680
represents everything we've talked about

00:53:54,880 --> 00:53:58,160
this talk had a ton of detail in it and

00:53:57,680 --> 00:54:00,960
we hope

00:53:58,160 --> 00:54:02,800
everyone learned some definitions the

00:54:00,960 --> 00:54:04,319
difference between a lambda expression

00:54:02,800 --> 00:54:06,319
and a closure

00:54:04,319 --> 00:54:07,440
may be a bit about how to do a move

00:54:06,319 --> 00:54:10,480
capture

00:54:07,440 --> 00:54:13,760
or some information about how c 20 added

00:54:10,480 --> 00:54:13,760
a lot of new clauses

00:54:14,160 --> 00:54:17,520
we thank you for attending our talk if

00:54:16,319 --> 00:54:20,880
you have questions

00:54:17,520 --> 00:54:23,280
please post them we will be around um

00:54:20,880 --> 00:54:24,400
in the hallway track later you can also

00:54:23,280 --> 00:54:27,200
reach us on twitter

00:54:24,400 --> 00:54:27,200
or by email

00:54:27,839 --> 00:54:31,920
and keep in mind we do have a youtube

00:54:29,760 --> 00:54:34,079
channel we thought we would mention that

00:54:31,920 --> 00:54:35,760
so as you can see this is just a list of

00:54:34,079 --> 00:54:38,400
some of our other talks

00:54:35,760 --> 00:54:40,079
we hope you subscribe to our channel and

00:54:38,400 --> 00:54:41,359
watch some of our videos

00:54:40,079 --> 00:54:43,520
and again if you're interested in the

00:54:41,359 --> 00:54:44,480
copper spice project please come talk

00:54:43,520 --> 00:54:46,160
with us

00:54:44,480 --> 00:54:50,480
and we're going to put up some contact

00:54:46,160 --> 00:54:50,480
information and answer some questions

00:54:51,200 --> 00:54:58,960
uh map filter

00:54:54,319 --> 00:55:02,000
um how would you let's see

00:54:58,960 --> 00:55:03,839
the trinity map filter reduce fold

00:55:02,000 --> 00:55:06,319
do you have any examples of these with a

00:55:03,839 --> 00:55:06,319
lambda

00:55:06,559 --> 00:55:10,000
not in this talk we don't um on our

00:55:09,119 --> 00:55:12,880
youtube channel

00:55:10,000 --> 00:55:14,319
we do have a few more examples of how to

00:55:12,880 --> 00:55:17,200
work with lambda expressions

00:55:14,319 --> 00:55:19,359
and most of those related to callbacks

00:55:17,200 --> 00:55:22,720
but that sounds like a great topic so

00:55:19,359 --> 00:55:25,839
maybe we'll cover that in a future video

00:55:22,720 --> 00:55:27,280
um how would you wrap lambdas using std

00:55:25,839 --> 00:55:29,680
function

00:55:27,280 --> 00:55:30,960
well there's really not much wrapping

00:55:29,680 --> 00:55:33,599
involved in it because

00:55:30,960 --> 00:55:34,240
std function can store any function

00:55:33,599 --> 00:55:36,640
object

00:55:34,240 --> 00:55:37,680
so you just assign the lambda expression

00:55:36,640 --> 00:55:40,400
to some

00:55:37,680 --> 00:55:41,839
variable of the type std function with

00:55:40,400 --> 00:55:44,480
the appropriate signature

00:55:41,839 --> 00:55:46,079
and it's implicitly converted if that

00:55:44,480 --> 00:55:48,400
didn't answer your question please post

00:55:46,079 --> 00:55:48,400
again

00:55:49,280 --> 00:55:52,880
sorry it takes a moment to read these is

00:55:51,359 --> 00:55:56,079
there an equivalent wrap or two

00:55:52,880 --> 00:55:59,119
that allows non-copyable closures

00:55:56,079 --> 00:56:01,440
not based on the definition yeah

00:55:59,119 --> 00:56:03,200
that's kind of a regrettable oversight

00:56:01,440 --> 00:56:03,760
in the standard that they don't have a

00:56:03,200 --> 00:56:06,960
move

00:56:03,760 --> 00:56:08,960
only function object container

00:56:06,960 --> 00:56:10,720
um and i actually saw something on

00:56:08,960 --> 00:56:12,240
twitter a couple of weeks ago somebody

00:56:10,720 --> 00:56:14,960
was i forget the name

00:56:12,240 --> 00:56:16,640
was mentioning if your code base doesn't

00:56:14,960 --> 00:56:18,960
have a move only

00:56:16,640 --> 00:56:20,799
um function object wrapper now is

00:56:18,960 --> 00:56:22,559
probably the day to write it

00:56:20,799 --> 00:56:24,160
so yeah no there's there's nothing in

00:56:22,559 --> 00:56:26,319
the standard for that but it's

00:56:24,160 --> 00:56:29,040
not yet it's pretty common but they do

00:56:26,319 --> 00:56:33,280
take they do take submissions

00:56:29,040 --> 00:56:35,520
so do you use uh function templates

00:56:33,280 --> 00:56:37,599
well i i will say that we just rewrote a

00:56:35,520 --> 00:56:40,400
major section of copper spice

00:56:37,599 --> 00:56:40,960
that was released last week um rewriting

00:56:40,400 --> 00:56:43,599
however

00:56:40,960 --> 00:56:45,040
we read the whole question yeah of of

00:56:43,599 --> 00:56:47,760
how variants work and

00:56:45,040 --> 00:56:50,079
we do make heavy use in copper spice of

00:56:47,760 --> 00:56:51,839
lambda expressions

00:56:50,079 --> 00:56:54,160
but i would say the question of do you

00:56:51,839 --> 00:56:55,599
typically use function templates for std

00:56:54,160 --> 00:56:58,799
function parameters

00:56:55,599 --> 00:57:00,559
um in when we're in copper spice and

00:56:58,799 --> 00:57:02,720
we would typically use function

00:57:00,559 --> 00:57:04,799
templates the reason being

00:57:02,720 --> 00:57:06,640
that most of our our code is quite

00:57:04,799 --> 00:57:09,599
template heavy to begin with

00:57:06,640 --> 00:57:10,960
so it's very natural to do this really

00:57:09,599 --> 00:57:14,160
the only reason to use

00:57:10,960 --> 00:57:16,480
std function is if you want the

00:57:14,160 --> 00:57:18,559
type erasure behavior and you're willing

00:57:16,480 --> 00:57:20,559
to lose the closure data type

00:57:18,559 --> 00:57:22,559
and you're willing to pay a runtime cost

00:57:20,559 --> 00:57:25,520
for it because it does require a heap

00:57:22,559 --> 00:57:27,440
allocation to store the function object

00:57:25,520 --> 00:57:31,359
so in in general if you can use a

00:57:27,440 --> 00:57:31,359
template prefer that and we usually can

00:57:31,920 --> 00:57:36,799
are there any more questions i see that

00:57:34,480 --> 00:57:40,880
our screen is blank and we have about

00:57:36,799 --> 00:57:43,920
three more minutes or so um

00:57:40,880 --> 00:57:45,440
well if that's it then um thank you so

00:57:43,920 --> 00:57:47,359
much for attending

00:57:45,440 --> 00:57:48,480
uh we appreciate your being ooh there's

00:57:47,359 --> 00:57:51,440
another question

00:57:48,480 --> 00:57:52,559
what are the most observed gotchas to me

00:57:51,440 --> 00:57:54,720
the most observed one

00:57:52,559 --> 00:57:55,760
is a capture where you've done a move

00:57:54,720 --> 00:57:58,559
capture

00:57:55,760 --> 00:57:59,599
and then somebody tries to access that

00:57:58,559 --> 00:58:02,240
variable

00:57:59,599 --> 00:58:04,160
um not realizing that it's been captured

00:58:02,240 --> 00:58:07,760
and it's already been

00:58:04,160 --> 00:58:09,680
moved into the lambda expression

00:58:07,760 --> 00:58:11,920
one of the other things that we saw when

00:58:09,680 --> 00:58:14,880
we were i said rewriting q

00:58:11,920 --> 00:58:16,559
variant and the variant classes in

00:58:14,880 --> 00:58:19,760
copper spice

00:58:16,559 --> 00:58:20,480
and we were using std visit we were

00:58:19,760 --> 00:58:23,040
using

00:58:20,480 --> 00:58:24,400
um some lambda expressions that got a

00:58:23,040 --> 00:58:27,680
little bit lengthy

00:58:24,400 --> 00:58:28,559
and they do use if constexpr and so the

00:58:27,680 --> 00:58:30,799
syntax

00:58:28,559 --> 00:58:31,680
you have to watch how you break up the

00:58:30,799 --> 00:58:35,520
lines

00:58:31,680 --> 00:58:36,559
and and format the code and if we didn't

00:58:35,520 --> 00:58:39,760
format it well

00:58:36,559 --> 00:58:42,400
it was hard to debug and hard to read um

00:58:39,760 --> 00:58:44,079
so that made it easier and actually

00:58:42,400 --> 00:58:47,359
formatting it well made it easier

00:58:44,079 --> 00:58:49,839
for um our code review

00:58:47,359 --> 00:58:50,720
another really interesting behavior that

00:58:49,839 --> 00:58:54,000
i've noticed

00:58:50,720 --> 00:58:55,760
is um very few people use

00:58:54,000 --> 00:58:58,079
lambda expressions with the mutable

00:58:55,760 --> 00:58:59,680
keyword so normally when you capture

00:58:58,079 --> 00:59:01,280
something it's it's constant and it

00:58:59,680 --> 00:59:02,880
doesn't change throughout the lifetime

00:59:01,280 --> 00:59:04,960
of the closure

00:59:02,880 --> 00:59:06,559
if you start using lambdas that have

00:59:04,960 --> 00:59:08,480
mutable data in them

00:59:06,559 --> 00:59:10,319
you will discover places in the code

00:59:08,480 --> 00:59:12,640
base where you were copying

00:59:10,319 --> 00:59:14,000
closures and this means you're getting a

00:59:12,640 --> 00:59:16,160
copy of all the state

00:59:14,000 --> 00:59:18,480
in the closure and this can be really

00:59:16,160 --> 00:59:20,559
surprising sometimes because you invoke

00:59:18,480 --> 00:59:22,240
it one time and you modify the data

00:59:20,559 --> 00:59:24,079
and then it gets invoked another time in

00:59:22,240 --> 00:59:25,920
a different piece of code and the data

00:59:24,079 --> 00:59:28,079
is back to what it had been

00:59:25,920 --> 00:59:30,480
so watch for that carefully that's

00:59:28,079 --> 00:59:33,520
another reason to use a move only

00:59:30,480 --> 00:59:36,880
function object container

00:59:33,520 --> 00:59:39,119
i not sure how long they talked about it

00:59:36,880 --> 00:59:39,119
um

00:59:39,280 --> 00:59:42,960
that's that's that's an interesting

00:59:40,640 --> 00:59:44,640
history question um i believe

00:59:42,960 --> 00:59:46,160
lambda expressions well they were added

00:59:44,640 --> 00:59:48,720
in 11 and

00:59:46,160 --> 00:59:49,680
i'm not sure how long the proposals

00:59:48,720 --> 00:59:51,440
existed

00:59:49,680 --> 00:59:52,799
but based on other things that have been

00:59:51,440 --> 00:59:55,520
added to the standard

00:59:52,799 --> 00:59:56,640
i would suspect it was quite a few years

00:59:55,520 --> 00:59:58,319
if somebody else

00:59:56,640 --> 01:00:00,400
has some information from the standards

00:59:58,319 --> 01:00:02,559
committee of when the initial proposal

01:00:00,400 --> 01:00:03,599
started um that's something we could

01:00:02,559 --> 01:00:06,880
probably look up

01:00:03,599 --> 01:00:08,400
and and post that in in the chat later

01:00:06,880 --> 01:00:10,720
on

01:00:08,400 --> 01:00:12,480
and it's it is clear that however long

01:00:10,720 --> 01:00:14,240
they spent standardizing lambda

01:00:12,480 --> 01:00:16,640
expressions before 11

01:00:14,240 --> 01:00:18,000
it wasn't quite long enough because it

01:00:16,640 --> 01:00:21,119
meant that

01:00:18,000 --> 01:00:23,359
um in c plus 11 lambdas were basically

01:00:21,119 --> 01:00:24,160
unusable with move only types and you

01:00:23,359 --> 01:00:27,200
didn't really get

01:00:24,160 --> 01:00:29,119
that until generalized capture in 14.

01:00:27,200 --> 01:00:31,200
so i would view lambda expressions in c

01:00:29,119 --> 01:00:32,240
plus plus 11 as sort of being a beta

01:00:31,200 --> 01:00:33,680
race

01:00:32,240 --> 01:00:36,559
yes there were a lot of things changed

01:00:33,680 --> 01:00:40,319
in 14 and in 17

01:00:36,559 --> 01:00:42,400
um especially like with capturing this

01:00:40,319 --> 01:00:44,799
so they're clearly still under active

01:00:42,400 --> 01:00:47,839
development yes

01:00:44,799 --> 01:00:50,160
so i think our time is up uh thank you

01:00:47,839 --> 01:00:51,280
everyone for attending we appreciate it

01:00:50,160 --> 01:00:53,280
if you have other questions we're going

01:00:51,280 --> 01:00:56,319
to be on the hallway track and

01:00:53,280 --> 01:00:56,799
that completes our presentation thank

01:00:56,319 --> 01:01:11,839
you

01:00:56,799 --> 01:01:11,839
thank you

01:01:17,920 --> 01:01:20,000

YouTube URL: https://www.youtube.com/watch?v=ZIPNFcw6V9o


