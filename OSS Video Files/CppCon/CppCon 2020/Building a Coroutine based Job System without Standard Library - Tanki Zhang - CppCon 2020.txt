Title: Building a Coroutine based Job System without Standard Library - Tanki Zhang - CppCon 2020
Publication date: 2020-09-27
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/building_a_coroutine_based_job_system_without_standard_library/building_a_coroutine_based_job_system_without_standard_library__tanki_zhang__cppcon_2020.pdf
---
A job system is a common game engine component to improve total CPU throughput. In this talk, I will walk through building a coroutine-based job system and explain the advantages of using coroutines over the typical ways to build a job system.

We shipped coroutines in C++20, but why does it matter for users, especially since there’s no standard library support? The answer is the coroutine semantics. Developers can customize the behavior of `co_return`, `co_yield`, `co_await` to build their own systems without any dependency of the standard library. For game developers, this is important because many game studios forbid the use of the standard library. The coroutine language feature itself is flexible enough to build a system with 100% control, which is exactly what engine developers want—no black box, no magic.

I will discuss the design decision I made, trade-offs, and current limitations. This talk is a crash course for system developers who want to build systems independently from the standard library and will also discuss possible future directions for this language feature.

This is an advanced coroutine talk and I expect attendees to have basic understanding about how (c++)coroutine works. Here is a useful link for some related materials if you want more information before attending this talk: https://gist.github.com/MattPD/9b55db49537a90545a90447392ad3aeb

---
Tanki Zhang
Real-time Rendering Engineer, NVIDIA

Tanki is a real-time rendering engineer at NVIDIA. He has been an active member of both the C++ community and the graphics community. As a game developer focused on game engine technics, he is passionate about different new knowledge and is excited to try things out.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,240 --> 00:00:11,200
hi

00:00:08,559 --> 00:00:13,679
everyone tanki here thanks for coming to

00:00:11,200 --> 00:00:13,679
my talk

00:00:15,679 --> 00:00:21,279
before we get started just quick

00:00:18,720 --> 00:00:23,279
self introduction about my background

00:00:21,279 --> 00:00:24,000
i'm a real-time rendering engineer at

00:00:23,279 --> 00:00:26,720
nvidia

00:00:24,000 --> 00:00:29,039
working on the rtx rendering on nurse

00:00:26,720 --> 00:00:29,679
before that i was a rendering engineer

00:00:29,039 --> 00:00:32,000
intern

00:00:29,679 --> 00:00:33,600
on the rendering team of unreal engine

00:00:32,000 --> 00:00:36,320
at epic games

00:00:33,600 --> 00:00:37,760
but today instead of pixels i'm going to

00:00:36,320 --> 00:00:41,440
talk about another thing

00:00:37,760 --> 00:00:43,600
in game jobs specifically

00:00:41,440 --> 00:00:44,480
based on c plus plus coroutine which we

00:00:43,600 --> 00:00:49,200
shipped in c

00:00:44,480 --> 00:00:50,879
plus 20 without standard library support

00:00:49,200 --> 00:00:52,719
because the contents are pretty

00:00:50,879 --> 00:00:55,280
connected so i will take

00:00:52,719 --> 00:00:56,800
all the questions at the end and because

00:00:55,280 --> 00:00:59,039
this is a virtual conference

00:00:56,800 --> 00:00:59,920
feel free to put any questions in the qa

00:00:59,039 --> 00:01:04,559
section

00:00:59,920 --> 00:01:07,200
during the talk and good notice

00:01:04,559 --> 00:01:08,960
to avoid missing all the qa session i

00:01:07,200 --> 00:01:12,080
would recommend not to pause the video

00:01:08,960 --> 00:01:14,320
stream during the talk

00:01:12,080 --> 00:01:15,920
before we dive into assistant i want to

00:01:14,320 --> 00:01:18,320
take 10 minutes

00:01:15,920 --> 00:01:20,960
and to have a quick recap about c plus

00:01:18,320 --> 00:01:23,200
protein and shares and gaucho moments

00:01:20,960 --> 00:01:25,600
i found due to the complexity of the

00:01:23,200 --> 00:01:26,000
spec people can be pretty overwhelmed by

00:01:25,600 --> 00:01:28,320
all

00:01:26,000 --> 00:01:31,200
different turns not to mention to put

00:01:28,320 --> 00:01:33,200
them together to form knowledge system

00:01:31,200 --> 00:01:34,880
i hope the following information can be

00:01:33,200 --> 00:01:37,119
helpful and i attach some

00:01:34,880 --> 00:01:38,880
links in the slides a pointer to

00:01:37,119 --> 00:01:40,640
different part of the specs

00:01:38,880 --> 00:01:43,040
people that need more reference and

00:01:40,640 --> 00:01:46,240
details

00:01:43,040 --> 00:01:47,280
so first promise object it's a user

00:01:46,240 --> 00:01:49,439
defined type

00:01:47,280 --> 00:01:51,200
it's part of the coding frame this is

00:01:49,439 --> 00:01:53,840
the major

00:01:51,200 --> 00:01:56,479
customization point for users to store

00:01:53,840 --> 00:01:59,680
persistent protein related data

00:01:56,479 --> 00:02:01,840
then we have quality handle which are

00:01:59,680 --> 00:02:03,680
basically just handles

00:02:01,840 --> 00:02:05,680
we have different two different types

00:02:03,680 --> 00:02:09,039
one is a general handle and the

00:02:05,680 --> 00:02:11,680
other one is typed by the promise object

00:02:09,039 --> 00:02:12,640
the one typewrite the promise object

00:02:11,680 --> 00:02:15,120
give

00:02:12,640 --> 00:02:16,720
give us extra prizes that give us extra

00:02:15,120 --> 00:02:20,160
access to the underlying um

00:02:16,720 --> 00:02:23,280
a promise object where while the

00:02:20,160 --> 00:02:26,560
general handle can only check the

00:02:23,280 --> 00:02:26,560
status of coating

00:02:27,599 --> 00:02:31,519
and i found it surprisingly hard at the

00:02:29,520 --> 00:02:32,080
beginning when i tried to figure out how

00:02:31,519 --> 00:02:35,200
can i

00:02:32,080 --> 00:02:37,760
access among those three objects

00:02:35,200 --> 00:02:38,400
so let's say here notice i did not

00:02:37,760 --> 00:02:41,840
explain

00:02:38,400 --> 00:02:42,640
how we can and retrieve from a general

00:02:41,840 --> 00:02:46,640
handle

00:02:42,640 --> 00:02:49,440
to a promise object because now it's

00:02:46,640 --> 00:02:51,040
it just doesn't really just works and

00:02:49,440 --> 00:02:52,160
requires some effort and tricks

00:02:51,040 --> 00:02:57,040
according to

00:02:52,160 --> 00:02:57,040
um the the the context

00:02:57,599 --> 00:03:01,840
so then we have code weight code is

00:02:59,920 --> 00:03:04,159
unary operator

00:03:01,840 --> 00:03:05,760
because it's operator that means in case

00:03:04,159 --> 00:03:08,239
compiler can find a

00:03:05,760 --> 00:03:10,640
definition of the operator then the

00:03:08,239 --> 00:03:12,959
expression is valid

00:03:10,640 --> 00:03:13,840
then we have a weightable which is

00:03:12,959 --> 00:03:17,040
basically

00:03:13,840 --> 00:03:20,239
a type that supports code operator

00:03:17,040 --> 00:03:22,800
then we have a waiter which is type that

00:03:20,239 --> 00:03:23,920
has three customization point function

00:03:22,800 --> 00:03:26,959
defined which are

00:03:23,920 --> 00:03:28,319
a way ready a way suspend and that will

00:03:26,959 --> 00:03:30,400
resume

00:03:28,319 --> 00:03:32,480
there are a set of rules applied at

00:03:30,400 --> 00:03:34,959
compilation time and translate the code

00:03:32,480 --> 00:03:37,440
with expression into code

00:03:34,959 --> 00:03:38,720
and first it tried to retreat a waiter

00:03:37,440 --> 00:03:43,200
and a weightable

00:03:38,720 --> 00:03:43,200
then it tried to await on a waiter

00:03:44,480 --> 00:03:48,959
okay so time for the big boss the major

00:03:47,200 --> 00:03:51,040
my struggle i had when i tried to

00:03:48,959 --> 00:03:53,519
understand how color team works

00:03:51,040 --> 00:03:54,799
is there are so many customization

00:03:53,519 --> 00:03:57,200
points

00:03:54,799 --> 00:03:58,239
and it's like an extreme version of

00:03:57,200 --> 00:04:01,120
iterator so

00:03:58,239 --> 00:04:02,000
it's hard to connect everything together

00:04:01,120 --> 00:04:04,239
in code

00:04:02,000 --> 00:04:05,920
especially when compiler try to mess

00:04:04,239 --> 00:04:08,080
with those things

00:04:05,920 --> 00:04:09,360
um so let's review the black box here

00:04:08,080 --> 00:04:11,760
and flush out as much

00:04:09,360 --> 00:04:12,799
as we can here we have a simple code

00:04:11,760 --> 00:04:14,959
example

00:04:12,799 --> 00:04:16,400
one is a sum function that adds two

00:04:14,959 --> 00:04:18,639
numbers together

00:04:16,400 --> 00:04:20,720
and another way fancier function that

00:04:18,639 --> 00:04:23,520
add four numbers together

00:04:20,720 --> 00:04:23,840
as we all know if we want to add these a

00:04:23,520 --> 00:04:27,520
b

00:04:23,840 --> 00:04:30,720
c d together we first add a b together

00:04:27,520 --> 00:04:33,360
then we add cd to editor and as their

00:04:30,720 --> 00:04:33,360
sum together

00:04:33,840 --> 00:04:38,080
so first let's look how compiler

00:04:35,680 --> 00:04:40,240
transforms some protein

00:04:38,080 --> 00:04:43,840
i know this is a little bit overwhelming

00:04:40,240 --> 00:04:43,840
but don't worry about it

00:04:44,560 --> 00:04:58,160
this goes out where we're gonna start

00:04:56,080 --> 00:05:00,560
so we invoke a quote in some function

00:04:58,160 --> 00:05:00,560
first

00:05:02,479 --> 00:05:06,160
and this is what we write in source code

00:05:04,960 --> 00:05:10,639
which is what we think

00:05:06,160 --> 00:05:12,400
we are calling

00:05:10,639 --> 00:05:16,560
and this is what we are actually calling

00:05:12,400 --> 00:05:16,560
at runtime because compilation happens

00:05:18,160 --> 00:05:23,039
and according to respect several things

00:05:20,479 --> 00:05:25,759
happens when we invoke a core routine

00:05:23,039 --> 00:05:26,240
we first construct the coating frame

00:05:25,759 --> 00:05:29,039
second

00:05:26,240 --> 00:05:30,880
we generate the return object and there

00:05:29,039 --> 00:05:33,199
are other steps happen in this

00:05:30,880 --> 00:05:34,080
resume function but let's just call it

00:05:33,199 --> 00:05:39,199
the first time

00:05:34,080 --> 00:05:40,960
we call into the resume

00:05:39,199 --> 00:05:42,880
we don't really need to worry about all

00:05:40,960 --> 00:05:45,199
the code for the coding frame

00:05:42,880 --> 00:05:46,960
but there are two parts we do care about

00:05:45,199 --> 00:05:49,120
here

00:05:46,960 --> 00:05:51,199
the first one is the parameters which

00:05:49,120 --> 00:05:52,880
include other input parameters of the

00:05:51,199 --> 00:05:54,800
functions

00:05:52,880 --> 00:05:57,840
the second part is initial suspend

00:05:54,800 --> 00:05:59,840
awaitable and final suspend weightable

00:05:57,840 --> 00:06:01,039
we'll see them in many times in the rest

00:05:59,840 --> 00:06:02,880
of the talk

00:06:01,039 --> 00:06:06,800
but and they will have like different

00:06:02,880 --> 00:06:10,080
names in the java system

00:06:06,800 --> 00:06:13,759
then next we invoke get return object

00:06:10,080 --> 00:06:16,560
function to generate the written object

00:06:13,759 --> 00:06:18,240
as you can see in the original function

00:06:16,560 --> 00:06:21,440
it matches the return type

00:06:18,240 --> 00:06:23,520
of our original quality type quality

00:06:21,440 --> 00:06:26,639
return type

00:06:23,520 --> 00:06:28,800
so that's how we get that task object

00:06:26,639 --> 00:06:30,639
it's not something we directly return by

00:06:28,800 --> 00:06:34,000
writing a return statement

00:06:30,639 --> 00:06:37,440
it's returned by implementing get return

00:06:34,000 --> 00:06:38,800
object also notice i will list all the

00:06:37,440 --> 00:06:40,960
customization

00:06:38,800 --> 00:06:43,680
points at the top right corner as a

00:06:40,960 --> 00:06:43,680
quick recap

00:06:45,199 --> 00:06:50,880
finally after these steps we are ready

00:06:47,360 --> 00:06:50,880
to run some actual logics

00:06:52,080 --> 00:06:56,479
notice that we have this sum resume

00:06:54,240 --> 00:06:58,880
function which is generally a big state

00:06:56,479 --> 00:07:01,680
machine generated by compiler

00:06:58,880 --> 00:07:02,240
this function is invoked when we call ko

00:07:01,680 --> 00:07:05,840
root

00:07:02,240 --> 00:07:05,840
coaching handle resume

00:07:06,240 --> 00:07:10,000
during the execution of coding there are

00:07:08,240 --> 00:07:11,440
a couple of different steps we'll be

00:07:10,000 --> 00:07:15,120
involved

00:07:11,440 --> 00:07:17,919
the first is initial suspend and then

00:07:15,120 --> 00:07:19,360
we start the main logic and after

00:07:17,919 --> 00:07:23,919
everything is done

00:07:19,360 --> 00:07:23,919
we do the final span and clean up

00:07:24,880 --> 00:07:31,840
so first we have initial spin

00:07:28,000 --> 00:07:31,840
it does several things

00:07:31,919 --> 00:07:35,759
we first retrieve initial suspend

00:07:33,680 --> 00:07:37,440
available which are returned by the

00:07:35,759 --> 00:07:41,440
initial suspend method

00:07:37,440 --> 00:07:41,440
defined on the promise object

00:07:41,680 --> 00:07:46,560
then we start to ask the question are

00:07:43,919 --> 00:07:46,560
you ready

00:07:47,440 --> 00:07:52,000
if not okay let's suspend you both are

00:07:50,240 --> 00:07:54,879
wait ready and always suspend our

00:07:52,000 --> 00:07:57,440
customization points

00:07:54,879 --> 00:07:58,080
once in words notice is here remember

00:07:57,440 --> 00:08:00,720
what are we

00:07:58,080 --> 00:08:03,840
passing into the away suspend it's our

00:08:00,720 --> 00:08:08,240
current coating being executed

00:08:03,840 --> 00:08:08,240
this is important we'll see later on

00:08:09,360 --> 00:08:12,639
then after initial suspend the current

00:08:12,000 --> 00:08:15,440
team may

00:08:12,639 --> 00:08:16,479
or may not be suspended but anyway when

00:08:15,440 --> 00:08:20,479
it is resumed

00:08:16,479 --> 00:08:23,599
eventually hopefully we are ready to run

00:08:20,479 --> 00:08:23,599
our actual logic

00:08:24,000 --> 00:08:28,400
how curtin is implemented and generally

00:08:26,319 --> 00:08:31,120
break the whole execution into several

00:08:28,400 --> 00:08:33,919
parts and compose the whole process

00:08:31,120 --> 00:08:36,000
as a state machine and use coding frame

00:08:33,919 --> 00:08:38,399
to maintain the necessary intermediate

00:08:36,000 --> 00:08:38,399
states

00:08:38,479 --> 00:08:42,479
in this example we first call away

00:08:41,839 --> 00:08:45,519
resume

00:08:42,479 --> 00:08:48,480
for initial suspender wait then we do

00:08:45,519 --> 00:08:48,480
some housekeeping

00:08:49,519 --> 00:08:55,839
then eventually we are adding two

00:08:51,680 --> 00:08:55,839
numbers now

00:08:57,760 --> 00:09:02,800
then here we have a co-return expression

00:09:00,880 --> 00:09:04,720
depends on whether there is an

00:09:02,800 --> 00:09:07,519
expression after the code return

00:09:04,720 --> 00:09:08,160
we call either return value or return

00:09:07,519 --> 00:09:11,360
void

00:09:08,160 --> 00:09:11,360
to report the result

00:09:12,399 --> 00:09:18,640
and after we have done everything it's

00:09:14,880 --> 00:09:18,640
time to call the final suspend

00:09:20,720 --> 00:09:24,480
the structure of the finance system

00:09:22,480 --> 00:09:28,080
looks very similar

00:09:24,480 --> 00:09:28,080
to the initial suspend

00:09:30,240 --> 00:09:33,440
again we first retrieve the final

00:09:32,080 --> 00:09:35,120
suspend available

00:09:33,440 --> 00:09:37,040
and then we ask the question are you

00:09:35,120 --> 00:09:40,000
ready if you're not

00:09:37,040 --> 00:09:40,000
let's suspend you

00:09:42,000 --> 00:09:46,160
notice here we have something called

00:09:44,399 --> 00:09:48,640
symmetric transfer

00:09:46,160 --> 00:09:50,000
it's a behavior designed in the spec to

00:09:48,640 --> 00:09:52,959
immediately resume its

00:09:50,000 --> 00:09:54,000
parent coating please refer to spec for

00:09:52,959 --> 00:09:56,240
more detail

00:09:54,000 --> 00:09:57,200
but generally this is the whole journey

00:09:56,240 --> 00:10:00,080
of our

00:09:57,200 --> 00:10:00,080
sum core routine

00:10:02,000 --> 00:10:05,519
okay now that we've walked through the

00:10:04,640 --> 00:10:08,079
sun coating

00:10:05,519 --> 00:10:09,600
i think we are more ready to look at the

00:10:08,079 --> 00:10:12,079
more complicated one

00:10:09,600 --> 00:10:12,079
some four

00:10:13,279 --> 00:10:18,000
for the coding frame we can see that we

00:10:15,680 --> 00:10:21,440
need to capture some extra information

00:10:18,000 --> 00:10:25,120
now the actual two input parameters

00:10:21,440 --> 00:10:25,120
and some intermediate revivals

00:10:27,519 --> 00:10:31,360
the initial suspend and final suspend

00:10:29,839 --> 00:10:35,200
are basically the same

00:10:31,360 --> 00:10:35,200
so let's focus on the logic part

00:10:37,120 --> 00:10:41,200
this is what happens when we try to

00:10:39,040 --> 00:10:43,200
co-waste some a b

00:10:41,200 --> 00:10:44,640
we store the available return from

00:10:43,200 --> 00:10:47,040
operator code await

00:10:44,640 --> 00:10:48,000
and start to ask a question are you

00:10:47,040 --> 00:10:52,000
ready

00:10:48,000 --> 00:10:52,000
if not let's suspend you

00:10:53,600 --> 00:10:57,360
and when we resume we retrieve the

00:10:56,000 --> 00:11:00,160
return value

00:10:57,360 --> 00:11:00,880
and in that case it's assigned to a

00:11:00,160 --> 00:11:03,200
variable

00:11:00,880 --> 00:11:03,200
a b

00:11:06,160 --> 00:11:10,800
same thing happens after we co-weight on

00:11:08,160 --> 00:11:10,800
the next one

00:11:10,959 --> 00:11:15,279
and store the return value from away

00:11:13,120 --> 00:11:19,120
resume

00:11:15,279 --> 00:11:19,120
and again for another expression

00:11:19,200 --> 00:11:25,440
you might find the repeat pattern here

00:11:22,720 --> 00:11:27,519
this is this looks familiar right and

00:11:25,440 --> 00:11:29,360
it's actually similar to our initial

00:11:27,519 --> 00:11:33,040
suspended final span

00:11:29,360 --> 00:11:36,560
we first retrieve the avoidable then

00:11:33,040 --> 00:11:38,240
we do suspend or resume it's because

00:11:36,560 --> 00:11:40,079
these are what happened for

00:11:38,240 --> 00:11:41,279
generally for all the co-weight

00:11:40,079 --> 00:11:43,040
expressions

00:11:41,279 --> 00:11:44,880
and before what we were doing were

00:11:43,040 --> 00:11:46,399
simply just cold weight initial

00:11:44,880 --> 00:11:48,399
suspended weight bowl

00:11:46,399 --> 00:11:51,040
and the cold way final suspender weight

00:11:48,399 --> 00:11:53,600
board both are just a special kind of a

00:11:51,040 --> 00:11:53,600
revolves

00:11:54,720 --> 00:11:59,120
so quick recap for several important

00:11:56,800 --> 00:12:01,360
conclusions here

00:11:59,120 --> 00:12:04,399
away resume returns the return value for

00:12:01,360 --> 00:12:08,079
codeway expression

00:12:04,399 --> 00:12:10,160
then second we notice this if away ready

00:12:08,079 --> 00:12:11,360
if you're not ready to spend if you're

00:12:10,160 --> 00:12:15,040
ready just resume

00:12:11,360 --> 00:12:18,399
the kind of pattern which is the pattern

00:12:15,040 --> 00:12:21,760
for cold weight expression

00:12:18,399 --> 00:12:24,240
third remember for those away suspend

00:12:21,760 --> 00:12:25,839
and we're passing the actual handle we

00:12:24,240 --> 00:12:28,079
can have templated

00:12:25,839 --> 00:12:31,120
away suspend functions so that we can

00:12:28,079 --> 00:12:33,360
access the underlying promise object

00:12:31,120 --> 00:12:34,160
and finally since all those things are

00:12:33,360 --> 00:12:36,839
struct

00:12:34,160 --> 00:12:39,120
the structures are also available for

00:12:36,839 --> 00:12:41,120
customizations

00:12:39,120 --> 00:12:42,639
okay finally we are ready to talk about

00:12:41,120 --> 00:12:45,760
the job system

00:12:42,639 --> 00:12:49,279
so what is a job system job system

00:12:45,760 --> 00:12:50,000
is a kind of task system usually user

00:12:49,279 --> 00:12:53,839
will define

00:12:50,000 --> 00:12:57,279
a bunch of workload and submit them to

00:12:53,839 --> 00:12:59,120
the assistant the system will pick them

00:12:57,279 --> 00:13:00,959
up and execute them according to the

00:12:59,120 --> 00:13:03,360
certain dependency order on different

00:13:00,959 --> 00:13:06,079
threads of fiber etc

00:13:03,360 --> 00:13:08,800
it's also a general practice to engage

00:13:06,079 --> 00:13:11,279
and to have databases thread to handle

00:13:08,800 --> 00:13:13,680
and specialize the job types for example

00:13:11,279 --> 00:13:15,920
to have a dedicated ios thread to avoid

00:13:13,680 --> 00:13:18,079
fighting over the ios access

00:13:15,920 --> 00:13:20,880
and the network thread to only handle

00:13:18,079 --> 00:13:23,120
network traffic well the major goal of

00:13:20,880 --> 00:13:24,720
the drop system is to have an overall

00:13:23,120 --> 00:13:28,000
cpu overhead

00:13:24,720 --> 00:13:31,440
sorry cpu support which means ideally

00:13:28,000 --> 00:13:33,920
i would want to want us red to be busy

00:13:31,440 --> 00:13:35,440
and have things to do all the time and

00:13:33,920 --> 00:13:39,440
we want to avoid bubbles

00:13:35,440 --> 00:13:41,920
which are spared time frames in the cpu

00:13:39,440 --> 00:13:41,920
timeline

00:13:44,320 --> 00:13:51,199
so voila this is our system

00:13:48,000 --> 00:13:53,440
it's pretty exciting right

00:13:51,199 --> 00:13:55,680
token promise is the main space that

00:13:53,440 --> 00:13:58,160
glues our system encoding semantics

00:13:55,680 --> 00:13:58,160
together

00:13:58,880 --> 00:14:02,160
token is the tax object type in the

00:14:01,199 --> 00:14:04,720
system

00:14:02,160 --> 00:14:05,519
the reason i use token instead of text

00:14:04,720 --> 00:14:09,440
is because

00:14:05,519 --> 00:14:11,920
task tags tasks actually

00:14:09,440 --> 00:14:12,800
means a subset or token that have extra

00:14:11,920 --> 00:14:16,800
features

00:14:12,800 --> 00:14:18,720
which we'll see later

00:14:16,800 --> 00:14:21,600
and the token holds that coating handle

00:14:18,720 --> 00:14:23,600
for convenient coating access

00:14:21,600 --> 00:14:25,600
and there are initial suspend avoidable

00:14:23,600 --> 00:14:27,680
and final suspense weightable as we

00:14:25,600 --> 00:14:30,399
mentioned before

00:14:27,680 --> 00:14:33,839
they are from the initial suspend method

00:14:30,399 --> 00:14:33,839
and final suspend method

00:14:34,320 --> 00:14:39,040
in our system initial system available

00:14:37,120 --> 00:14:42,839
is called token dispatcher

00:14:39,040 --> 00:14:44,320
we customize this type to dispatch our

00:14:42,839 --> 00:14:46,480
jobs

00:14:44,320 --> 00:14:47,360
and finally suspend a weight bowl is

00:14:46,480 --> 00:14:50,000
called final

00:14:47,360 --> 00:14:51,040
weight this is where resumed parent

00:14:50,000 --> 00:14:53,120
happens

00:14:51,040 --> 00:14:56,240
we'll get back to the concept of resume

00:14:53,120 --> 00:14:56,240
parent in a second

00:14:56,480 --> 00:15:02,800
and of course the heart of the system is

00:14:59,519 --> 00:15:04,639
jobs scheduler don't interact with

00:15:02,800 --> 00:15:06,800
corrupting directly

00:15:04,639 --> 00:15:07,839
that's how we can implement a scheduler

00:15:06,800 --> 00:15:10,240
in whatever we

00:15:07,839 --> 00:15:11,600
want which is not included this in this

00:15:10,240 --> 00:15:14,160
talk by the way

00:15:11,600 --> 00:15:16,800
and potentially we can even handle both

00:15:14,160 --> 00:15:19,760
quality and non-coding type of jobs

00:15:16,800 --> 00:15:22,160
in the same scheduler but anyway here

00:15:19,760 --> 00:15:25,199
the job is a very lightweight object

00:15:22,160 --> 00:15:26,959
and many stores are quoting handle and

00:15:25,199 --> 00:15:29,920
we will have two ways to construct and

00:15:26,959 --> 00:15:29,920
dispatch jobs

00:15:30,399 --> 00:15:34,399
the first pass is when we invoke a new

00:15:33,120 --> 00:15:36,399
coaching

00:15:34,399 --> 00:15:37,519
it happens again in the initial

00:15:36,399 --> 00:15:41,040
suspended label

00:15:37,519 --> 00:15:43,759
aka token dispatcher when we invoke a

00:15:41,040 --> 00:15:43,759
waste suspend

00:15:44,320 --> 00:15:49,360
and the second is when we finish a

00:15:46,399 --> 00:15:52,959
coating and we need to resume the parent

00:15:49,360 --> 00:15:56,000
that was suspended that happens

00:15:52,959 --> 00:15:58,160
in the final suspend available

00:15:56,000 --> 00:15:59,040
when we finish the execution of current

00:15:58,160 --> 00:16:03,680
protein

00:15:59,040 --> 00:16:03,680
and we reschedule the suspended parent

00:16:05,360 --> 00:16:10,959
but then it's natural to have the

00:16:07,120 --> 00:16:14,160
question where is the parent from right

00:16:10,959 --> 00:16:16,720
well the this is from when we call co

00:16:14,160 --> 00:16:18,079
await our token object and we ask the

00:16:16,720 --> 00:16:20,160
question are you ready

00:16:18,079 --> 00:16:21,759
if not okay we're gonna suspend you in

00:16:20,160 --> 00:16:24,320
the oasis band

00:16:21,759 --> 00:16:27,040
where we will have the handle and we

00:16:24,320 --> 00:16:30,160
will suspend the parent coding

00:16:27,040 --> 00:16:33,199
notice this pattern background color

00:16:30,160 --> 00:16:33,839
that means these are these two are same

00:16:33,199 --> 00:16:35,759
object

00:16:33,839 --> 00:16:38,399
and we store that so that later we can

00:16:35,759 --> 00:16:38,399
resume it

00:16:38,480 --> 00:16:41,839
combine them together we have the second

00:16:40,560 --> 00:16:45,120
pass

00:16:41,839 --> 00:16:48,560
and this is the core how dependencies

00:16:45,120 --> 00:16:48,560
are handled in the system

00:16:49,600 --> 00:16:53,040
as we all know we have a pandemic going

00:16:52,000 --> 00:16:54,800
on so

00:16:53,040 --> 00:16:56,079
let's say for example we're going to end

00:16:54,800 --> 00:16:59,360
this pentagon

00:16:56,079 --> 00:17:02,720
pandemic by offering everyone a vaccine

00:16:59,360 --> 00:17:02,720
and save the world

00:17:03,040 --> 00:17:07,120
but technically we cannot pause the time

00:17:05,280 --> 00:17:09,520
and say hold on no more time moving

00:17:07,120 --> 00:17:11,919
forward before we end this pandemic

00:17:09,520 --> 00:17:12,880
but for simplicity let's say we gonna

00:17:11,919 --> 00:17:18,000
wait

00:17:12,880 --> 00:17:20,559
before we do everything else

00:17:18,000 --> 00:17:21,439
what we need to do well if we introduce

00:17:20,559 --> 00:17:23,439
something

00:17:21,439 --> 00:17:25,600
we create a function and we hope the

00:17:23,439 --> 00:17:27,439
function will do what we want

00:17:25,600 --> 00:17:30,240
but before this is the coding type we

00:17:27,439 --> 00:17:30,240
create a quality

00:17:31,039 --> 00:17:34,160
using what we discussed in the previous

00:17:33,039 --> 00:17:37,039
6a slides

00:17:34,160 --> 00:17:38,559
we have this timeline so when we call

00:17:37,039 --> 00:17:40,880
into the protein

00:17:38,559 --> 00:17:41,760
again we first construct the coding

00:17:40,880 --> 00:17:44,720
frame

00:17:41,760 --> 00:17:46,320
which are not shown here and then we

00:17:44,720 --> 00:17:49,919
call get return object

00:17:46,320 --> 00:17:52,799
to get the token object then finally

00:17:49,919 --> 00:17:54,799
we call into the steam machine call

00:17:52,799 --> 00:17:58,400
initial suspend

00:17:54,799 --> 00:18:01,840
and ask are you ready and in this system

00:17:58,400 --> 00:18:01,840
the answer will always be no

00:18:02,640 --> 00:18:07,840
and then we suspend and call into the

00:18:05,039 --> 00:18:07,840
oasis span

00:18:08,720 --> 00:18:13,039
this is how this small piece of the

00:18:10,480 --> 00:18:16,480
system fit into the picture

00:18:13,039 --> 00:18:18,559
or in the code form notice from now

00:18:16,480 --> 00:18:19,760
all coding customization functions are

00:18:18,559 --> 00:18:21,520
in snake case

00:18:19,760 --> 00:18:25,440
and all functions are defined in the

00:18:21,520 --> 00:18:25,440
system are big camel case

00:18:25,840 --> 00:18:31,200
as we know we will have those two

00:18:28,000 --> 00:18:34,080
structs token promise and token

00:18:31,200 --> 00:18:35,600
so first recall the translated code we

00:18:34,080 --> 00:18:37,600
were discussing before

00:18:35,600 --> 00:18:38,720
the first customization point we need to

00:18:37,600 --> 00:18:40,960
handle is

00:18:38,720 --> 00:18:44,080
to provide a way to return a token

00:18:40,960 --> 00:18:47,039
object which is the get return object

00:18:44,080 --> 00:18:47,039
function here

00:18:47,200 --> 00:18:51,919
this is a little bit too long so let's

00:18:49,280 --> 00:18:53,840
shorten a little bit

00:18:51,919 --> 00:18:56,240
from promise is the function we want to

00:18:53,840 --> 00:18:58,400
use here this is the case we want to

00:18:56,240 --> 00:19:00,880
retrieve a coating handle from the

00:18:58,400 --> 00:19:00,880
promise

00:19:02,240 --> 00:19:06,000
and on the other hand after we have the

00:19:04,880 --> 00:19:10,000
quoting handle

00:19:06,000 --> 00:19:12,080
we can schedule the job

00:19:10,000 --> 00:19:13,039
and combine them together this is what

00:19:12,080 --> 00:19:15,600
happened

00:19:13,039 --> 00:19:16,640
the bars in the top represent the

00:19:15,600 --> 00:19:19,760
timeline and the

00:19:16,640 --> 00:19:20,640
show this shows how our system interacts

00:19:19,760 --> 00:19:25,200
in the code

00:19:20,640 --> 00:19:27,679
when we invoke the quality

00:19:25,200 --> 00:19:29,520
i still have not explained what happens

00:19:27,679 --> 00:19:32,880
in the initial suspend weight ball

00:19:29,520 --> 00:19:36,559
or say token dispatcher all magic

00:19:32,880 --> 00:19:36,559
happens in the initial span

00:19:37,200 --> 00:19:43,440
notice what we're passing here is is

00:19:40,480 --> 00:19:43,440
unmanned thread

00:19:44,960 --> 00:19:49,039
and when we construct a token dispatcher

00:19:47,360 --> 00:19:52,320
we store data to control

00:19:49,039 --> 00:19:54,799
whether we want to suspend it

00:19:52,320 --> 00:19:55,840
we do it in the away suspend instead of

00:19:54,799 --> 00:19:58,160
wait ready

00:19:55,840 --> 00:19:59,840
because we want to access the underlying

00:19:58,160 --> 00:20:02,159
promise object

00:19:59,840 --> 00:20:04,240
and according to respect when we return

00:20:02,159 --> 00:20:06,799
bull for a waste of spend

00:20:04,240 --> 00:20:08,559
if we return true that means the protein

00:20:06,799 --> 00:20:11,679
is suspended

00:20:08,559 --> 00:20:13,760
if it is false that means we do

00:20:11,679 --> 00:20:16,320
we did not suspend it and it will be

00:20:13,760 --> 00:20:19,200
resumed immediately

00:20:16,320 --> 00:20:20,799
so here you can notice how we use this

00:20:19,200 --> 00:20:24,480
is our men's thread

00:20:20,799 --> 00:20:28,559
is to treat that as a switch to decide

00:20:24,480 --> 00:20:31,200
whether we need to actually schedule it

00:20:28,559 --> 00:20:32,080
the idea is if it's on workers thread

00:20:31,200 --> 00:20:34,240
already

00:20:32,080 --> 00:20:37,679
we don't need to schedule it and it's

00:20:34,240 --> 00:20:37,679
safe to directly run it

00:20:39,280 --> 00:20:44,080
another thing worth notice is this line

00:20:42,400 --> 00:20:47,360
is generally wrong

00:20:44,080 --> 00:20:49,280
except for several special cases

00:20:47,360 --> 00:20:51,679
for this case because it's initial

00:20:49,280 --> 00:20:52,960
suspend we know the exact type of

00:20:51,679 --> 00:20:56,640
quality handle pass

00:20:52,960 --> 00:20:58,480
into the function so we do not need to

00:20:56,640 --> 00:21:03,840
template the whole function

00:20:58,480 --> 00:21:03,840
which further slows down the compilation

00:21:04,240 --> 00:21:08,159
so through explaining how

00:21:05,840 --> 00:21:11,919
applicabilization is involved

00:21:08,159 --> 00:21:14,480
we derive this part of the system

00:21:11,919 --> 00:21:16,159
and as we discussed token dispatcher

00:21:14,480 --> 00:21:16,960
which is the initial suspended weight

00:21:16,159 --> 00:21:20,480
ball

00:21:16,960 --> 00:21:20,480
lifts encoding frame

00:21:21,200 --> 00:21:25,280
and promise object will be passed into

00:21:23,360 --> 00:21:27,840
get return object

00:21:25,280 --> 00:21:31,840
and initial suspend is the customization

00:21:27,840 --> 00:21:31,840
point in the promise

00:21:32,240 --> 00:21:35,679
until this point if we compile the code

00:21:34,880 --> 00:21:37,919
we will have

00:21:35,679 --> 00:21:40,000
compilation arrow because we need to

00:21:37,919 --> 00:21:42,400
define two extra things

00:21:40,000 --> 00:21:43,280
the first one is final awaitable which

00:21:42,400 --> 00:21:45,840
we will discuss

00:21:43,280 --> 00:21:45,840
later

00:21:46,480 --> 00:21:50,799
and another one because we do not return

00:21:48,880 --> 00:21:54,480
any actual thing here

00:21:50,799 --> 00:21:56,480
so define return void and that's it we

00:21:54,480 --> 00:21:57,039
just launched our job to save the world

00:21:56,480 --> 00:21:59,840
and hope

00:21:57,039 --> 00:21:59,840
it will be fast

00:22:02,640 --> 00:22:06,400
at this point i want to discuss how

00:22:04,320 --> 00:22:08,640
should we template the token so that it

00:22:06,400 --> 00:22:10,559
can carry out result

00:22:08,640 --> 00:22:13,840
the first step of course we just

00:22:10,559 --> 00:22:13,840
template everything

00:22:14,400 --> 00:22:20,080
and instead of return void we will need

00:22:16,400 --> 00:22:20,080
to actually return a value

00:22:20,720 --> 00:22:24,480
and cash out the return value for future

00:22:22,720 --> 00:22:26,559
use

00:22:24,480 --> 00:22:27,760
in practice we will need to put certain

00:22:26,559 --> 00:22:30,320
constraints on

00:22:27,760 --> 00:22:31,600
this value type to limit what user can

00:22:30,320 --> 00:22:35,679
pass into

00:22:31,600 --> 00:22:38,640
for code return we will have ways in the

00:22:35,679 --> 00:22:41,679
system to retrieve this result

00:22:38,640 --> 00:22:43,520
the first one is code await as we've

00:22:41,679 --> 00:22:45,520
seen before

00:22:43,520 --> 00:22:47,120
and at the same time we still need a way

00:22:45,520 --> 00:22:49,760
to get the result

00:22:47,120 --> 00:22:50,720
without turning a normal function into a

00:22:49,760 --> 00:22:55,840
protein

00:22:50,720 --> 00:22:55,840
which i call decoding

00:22:58,640 --> 00:23:03,280
to do that what we need to provide an

00:23:01,280 --> 00:23:05,840
extra side channel

00:23:03,280 --> 00:23:07,440
of say a back door we store a future

00:23:05,840 --> 00:23:11,039
pointer

00:23:07,440 --> 00:23:13,919
notice here future is not the std future

00:23:11,039 --> 00:23:15,039
std future has too much overhead for our

00:23:13,919 --> 00:23:17,520
usage here

00:23:15,039 --> 00:23:19,919
this is a utility type provided in the

00:23:17,520 --> 00:23:19,919
system

00:23:21,280 --> 00:23:24,799
how it is implemented is pretty

00:23:23,280 --> 00:23:28,000
straightforward

00:23:24,799 --> 00:23:29,280
it internally cash out the value and

00:23:28,000 --> 00:23:31,600
here you can see

00:23:29,280 --> 00:23:32,960
we have this single consumer counter

00:23:31,600 --> 00:23:35,200
event

00:23:32,960 --> 00:23:36,559
it's implemented based on the operating

00:23:35,200 --> 00:23:38,799
system api

00:23:36,559 --> 00:23:42,159
and in my case i use wake or single

00:23:38,799 --> 00:23:42,159
object in windows

00:23:44,000 --> 00:23:48,000
when the caller trying to ask for the

00:23:45,840 --> 00:23:50,000
result it registers itself as a

00:23:48,000 --> 00:23:52,640
temporary worker for the scheduler

00:23:50,000 --> 00:23:55,120
and registers itself when the event gets

00:23:52,640 --> 00:23:55,120
triggered

00:23:59,120 --> 00:24:03,440
where that point to point to is the

00:24:01,039 --> 00:24:06,080
future we store in the token

00:24:03,440 --> 00:24:06,799
and outside the coding context we can

00:24:06,080 --> 00:24:10,880
call this

00:24:06,799 --> 00:24:10,880
result function to retrieve the result

00:24:12,080 --> 00:24:18,320
for call wait it's more straightforward

00:24:15,679 --> 00:24:21,039
what we need to do is follow the spec

00:24:18,320 --> 00:24:22,880
and return the value in or we resume

00:24:21,039 --> 00:24:24,240
because as we mentioned before the

00:24:22,880 --> 00:24:27,440
return value of which

00:24:24,240 --> 00:24:33,039
of away resume will be used as a result

00:24:27,440 --> 00:24:35,600
of the co-await expression

00:24:33,039 --> 00:24:36,559
go back to our save word mission we all

00:24:35,600 --> 00:24:39,120
know that

00:24:36,559 --> 00:24:41,919
an empty function won't work we need to

00:24:39,120 --> 00:24:45,200
do something real

00:24:41,919 --> 00:24:47,200
so well we take steps i explain the

00:24:45,200 --> 00:24:49,279
detail of sequential flow but for now

00:24:47,200 --> 00:24:52,400
this is just another coating which

00:24:49,279 --> 00:24:52,400
does something

00:24:54,880 --> 00:24:58,720
and record this slide similar thing

00:24:57,760 --> 00:25:00,559
happens again

00:24:58,720 --> 00:25:04,080
we are waiting on something and we

00:25:00,559 --> 00:25:04,080
invoke a waste of span

00:25:04,320 --> 00:25:09,120
which is like this the difference is

00:25:06,640 --> 00:25:12,240
literally only the names

00:25:09,120 --> 00:25:16,799
so it was sun a b

00:25:12,240 --> 00:25:16,799
and then we change that to seq4

00:25:18,080 --> 00:25:22,960
and this is our apply immunization we

00:25:21,200 --> 00:25:24,960
walk through the process

00:25:22,960 --> 00:25:26,240
we will get the token and initial

00:25:24,960 --> 00:25:29,039
suspend

00:25:26,240 --> 00:25:30,080
and then we invoke the sequential for

00:25:29,039 --> 00:25:34,240
same process

00:25:30,080 --> 00:25:36,640
but in this graph there are more details

00:25:34,240 --> 00:25:39,440
and eventually it will be scheduled on

00:25:36,640 --> 00:25:39,440
the scheduler

00:25:40,720 --> 00:25:44,880
then outside the function we immediately

00:25:43,360 --> 00:25:49,679
invoke operator code

00:25:44,880 --> 00:25:49,679
weight on the return token object

00:25:51,200 --> 00:25:56,000
and we will suspend it because a web

00:25:53,600 --> 00:25:58,080
ready will always return false

00:25:56,000 --> 00:26:00,640
when we suspend we'll call set

00:25:58,080 --> 00:26:01,360
continuation to remember what we need to

00:26:00,640 --> 00:26:03,520
resume

00:26:01,360 --> 00:26:05,840
after we are done with the sequential

00:26:03,520 --> 00:26:05,840
form

00:26:06,720 --> 00:26:12,000
then when sequential 4 is almost done we

00:26:09,440 --> 00:26:14,320
will invoke final suspense

00:26:12,000 --> 00:26:16,480
where we call scheduled parent to

00:26:14,320 --> 00:26:19,120
reschedule the appliementation on the

00:26:16,480 --> 00:26:19,120
scheduler

00:26:19,919 --> 00:26:25,840
and eventually applying musician will

00:26:22,080 --> 00:26:25,840
resume again

00:26:28,000 --> 00:26:34,080
so again in this case apply immization

00:26:31,120 --> 00:26:34,400
is the bottom part and the sequential

00:26:34,080 --> 00:26:38,240
for

00:26:34,400 --> 00:26:41,200
is the top part

00:26:38,240 --> 00:26:43,440
okay now let's talk about some code this

00:26:41,200 --> 00:26:45,679
time i strip out the most of the graph

00:26:43,440 --> 00:26:47,200
and let's look at those pieces one at a

00:26:45,679 --> 00:26:49,440
time

00:26:47,200 --> 00:26:51,279
but focus on how the parent coding

00:26:49,440 --> 00:26:54,080
handle changes

00:26:51,279 --> 00:26:57,279
first for this part this is where set

00:26:54,080 --> 00:26:57,279
continuation happens

00:26:57,919 --> 00:27:02,080
and by the way set continuation is here

00:27:03,760 --> 00:27:07,679
and in our code we construct a weight

00:27:06,480 --> 00:27:10,960
object

00:27:07,679 --> 00:27:13,919
where we define a waste suspend function

00:27:10,960 --> 00:27:15,520
then inside we have the access of the

00:27:13,919 --> 00:27:18,880
parent coating

00:27:15,520 --> 00:27:22,399
so that we can remember it and resume it

00:27:18,880 --> 00:27:22,399
when it's eventually ready

00:27:24,159 --> 00:27:29,679
on the other hand we resume it when

00:27:26,399 --> 00:27:29,679
sequential 4 is done

00:27:31,360 --> 00:27:36,320
and we invoke schedule pattern to

00:27:33,200 --> 00:27:36,320
reschedule it again

00:27:37,600 --> 00:27:42,559
in code we need to go back to here it's

00:27:40,320 --> 00:27:46,080
time to explain this final awaitable

00:27:42,559 --> 00:27:46,080
which we've skipped before

00:27:46,159 --> 00:27:49,760
and it's a waste of span we run schedule

00:27:48,720 --> 00:27:51,760
parent

00:27:49,760 --> 00:27:53,760
and as we mentioned before we always

00:27:51,760 --> 00:27:57,039
return false for our weight ready

00:27:53,760 --> 00:27:57,760
so that we can have access to promise

00:27:57,039 --> 00:28:02,080
object

00:27:57,760 --> 00:28:04,240
when we run the logic

00:28:02,080 --> 00:28:05,919
so far we say we need to put it on the

00:28:04,240 --> 00:28:08,480
scheduler but potentially

00:28:05,919 --> 00:28:09,520
we can construct the job and immediately

00:28:08,480 --> 00:28:13,679
declare it

00:28:09,520 --> 00:28:13,679
to avoid the overhead of scheduling

00:28:14,960 --> 00:28:19,760
so back to the save war mission again i

00:28:17,760 --> 00:28:20,159
feel like so far we are only writing

00:28:19,760 --> 00:28:23,520
some

00:28:20,159 --> 00:28:25,440
empty check and i i think we really need

00:28:23,520 --> 00:28:28,880
to stop that and do something

00:28:25,440 --> 00:28:31,440
practical because we do not have much

00:28:28,880 --> 00:28:34,240
time left

00:28:31,440 --> 00:28:36,399
to achieve this we have three steps

00:28:34,240 --> 00:28:39,600
first one is to research and develop

00:28:36,399 --> 00:28:41,760
a vaccine then when we have a recipe we

00:28:39,600 --> 00:28:45,360
produce those vaccines and apply those

00:28:41,760 --> 00:28:47,120
in clinics and we can do those things in

00:28:45,360 --> 00:28:49,440
parallel

00:28:47,120 --> 00:28:51,120
we don't need to stock enough vaccine

00:28:49,440 --> 00:28:54,720
and then start to use them

00:28:51,120 --> 00:28:56,720
they're more like producer and consumer

00:28:54,720 --> 00:28:58,080
but definitely we cannot do anything

00:28:56,720 --> 00:29:01,760
before we figure out

00:28:58,080 --> 00:29:01,760
an effective vaccine

00:29:02,559 --> 00:29:06,240
and we can do those in parallel

00:29:06,880 --> 00:29:11,039
so we have those two kind of jobs

00:29:08,720 --> 00:29:13,120
composition job composition

00:29:11,039 --> 00:29:14,880
sequential in parallel sequential

00:29:13,120 --> 00:29:17,120
express a chain of tasks

00:29:14,880 --> 00:29:18,080
that has to be finished in determined

00:29:17,120 --> 00:29:20,000
order

00:29:18,080 --> 00:29:22,559
parallel means they can be done at the

00:29:20,000 --> 00:29:22,559
same time

00:29:23,760 --> 00:29:30,080
so look at what happens here so first we

00:29:27,520 --> 00:29:33,200
transform each job into a new job

00:29:30,080 --> 00:29:36,000
it first waits on the previous job then

00:29:33,200 --> 00:29:40,159
execute the workload and the whole new

00:29:36,000 --> 00:29:41,039
job can be weighted by the next job and

00:29:40,159 --> 00:29:43,760
notice that

00:29:41,039 --> 00:29:45,200
because the composition we want the job

00:29:43,760 --> 00:29:48,799
cannot be executed

00:29:45,200 --> 00:29:48,799
until the dependency is done

00:29:49,919 --> 00:29:54,320
on the other hand for parallel what we

00:29:52,559 --> 00:29:57,840
need is a counter

00:29:54,320 --> 00:30:02,320
we decrement on finishing each job

00:29:57,840 --> 00:30:02,320
and we wait on counting between zero

00:30:04,080 --> 00:30:08,960
so what's the advantage of that well

00:30:06,640 --> 00:30:11,120
this is how i implement in my system

00:30:08,960 --> 00:30:12,480
and as you can see it's very easy to

00:30:11,120 --> 00:30:14,559
implement

00:30:12,480 --> 00:30:15,840
and it can be pretty efficient if the

00:30:14,559 --> 00:30:19,440
overhead of creating

00:30:15,840 --> 00:30:19,440
this batching job is low

00:30:20,159 --> 00:30:25,679
but to achieve this feature

00:30:23,360 --> 00:30:27,360
we require a little bit more for the

00:30:25,679 --> 00:30:30,559
from the token

00:30:27,360 --> 00:30:32,720
we basically require a lazy type jobs

00:30:30,559 --> 00:30:34,880
that we just create a job but never

00:30:32,720 --> 00:30:36,559
dispatch it until we really need to do

00:30:34,880 --> 00:30:39,520
so

00:30:36,559 --> 00:30:40,159
to do that well we add another template

00:30:39,520 --> 00:30:44,159
from

00:30:40,159 --> 00:30:46,000
template parameter in the token class

00:30:44,159 --> 00:30:50,240
and for deferred token it just simply

00:30:46,000 --> 00:30:52,799
always be true

00:30:50,240 --> 00:30:56,559
to implement that record this slide we

00:30:52,799 --> 00:31:00,640
were discussing the token dispatcher

00:30:56,559 --> 00:31:00,640
this is the change we need to make to it

00:31:00,799 --> 00:31:04,720
so basically if this is a different task

00:31:03,120 --> 00:31:07,279
we always pretend

00:31:04,720 --> 00:31:09,679
this is already scheduled but we do not

00:31:07,279 --> 00:31:13,519
actually schedule it

00:31:09,679 --> 00:31:13,519
until you co-wait

00:31:13,760 --> 00:31:17,600
we schedule it when someone is waiting

00:31:15,679 --> 00:31:20,480
on it which is in this

00:31:17,600 --> 00:31:22,960
cold weight operator where we define a

00:31:20,480 --> 00:31:22,960
weightable

00:31:27,120 --> 00:31:30,320
this is essentially provide a lazy job

00:31:29,519 --> 00:31:32,960
mechanism

00:31:30,320 --> 00:31:36,080
if no one ever waits on the job the job

00:31:32,960 --> 00:31:36,080
will not be scheduled

00:31:41,200 --> 00:31:46,399
so so far we haven't quite discussed

00:31:43,919 --> 00:31:49,039
about the lifetime of the jobs

00:31:46,399 --> 00:31:51,360
or which is directly pointing to what's

00:31:49,039 --> 00:31:53,840
the lifetime for the core teams

00:31:51,360 --> 00:31:56,399
which means the timing that we call

00:31:53,840 --> 00:31:59,360
handled or destroyed

00:31:56,399 --> 00:31:59,679
it's a little bit more complicated than

00:31:59,360 --> 00:32:02,880
i

00:31:59,679 --> 00:32:05,279
expected because i end up with

00:32:02,880 --> 00:32:07,440
these multiple elimination points in the

00:32:05,279 --> 00:32:09,279
system

00:32:07,440 --> 00:32:12,000
the first one is the destructor for

00:32:09,279 --> 00:32:13,279
token that means if no one is waiting

00:32:12,000 --> 00:32:16,480
for the result

00:32:13,279 --> 00:32:19,440
it's safe to destroy the token

00:32:16,480 --> 00:32:19,440
and the handle

00:32:19,760 --> 00:32:24,000
then the second is the destructor for a

00:32:22,000 --> 00:32:26,559
weight ball returned from the operator

00:32:24,000 --> 00:32:26,559
call weight

00:32:27,679 --> 00:32:31,919
and the third one is the drop when the

00:32:31,039 --> 00:32:35,440
work is done

00:32:31,919 --> 00:32:39,200
i can potentially release the handle

00:32:35,440 --> 00:32:43,279
but can i only have one of those three

00:32:39,200 --> 00:32:44,880
the answer is no if i only have the one

00:32:43,279 --> 00:32:47,840
for the job

00:32:44,880 --> 00:32:49,760
that means the operate but the operating

00:32:47,840 --> 00:32:50,880
code way will need some way to fetch a

00:32:49,760 --> 00:32:52,960
result

00:32:50,880 --> 00:32:54,720
and it needs to know the status of

00:32:52,960 --> 00:32:57,200
execution

00:32:54,720 --> 00:32:58,399
plus i want the data dependency is one

00:32:57,200 --> 00:33:02,320
direction which means

00:32:58,399 --> 00:33:02,320
tokens depends on the promise

00:33:02,640 --> 00:33:09,679
and the second is can i only

00:33:05,679 --> 00:33:12,080
have that for the destructor in token

00:33:09,679 --> 00:33:12,720
this still answer is no because i want

00:33:12,080 --> 00:33:15,440
to support

00:33:12,720 --> 00:33:16,159
lunch and forget of type of job so the

00:33:15,440 --> 00:33:19,519
lifetime

00:33:16,159 --> 00:33:22,720
is better not with the token because

00:33:19,519 --> 00:33:23,039
maybe no one is holding that and third

00:33:22,720 --> 00:33:25,519
one

00:33:23,039 --> 00:33:27,279
is can we only just have the effort

00:33:25,519 --> 00:33:30,080
avoidable

00:33:27,279 --> 00:33:31,760
same the answer is no because people

00:33:30,080 --> 00:33:34,240
don't necessarily want to wait on

00:33:31,760 --> 00:33:34,240
something

00:33:34,799 --> 00:33:38,080
my solution for that is a last way to

00:33:37,600 --> 00:33:40,880
release

00:33:38,080 --> 00:33:43,039
which is kind of rough counting

00:33:40,880 --> 00:33:45,840
basically when we enter each scope

00:33:43,039 --> 00:33:47,120
we bump up the ref and when we leave

00:33:45,840 --> 00:33:50,559
each scope

00:33:47,120 --> 00:33:54,480
we decrement the ref and if the ref

00:33:50,559 --> 00:33:54,480
happens to be zero we destroy it

00:33:54,559 --> 00:33:58,240
this works is because during the whole

00:33:57,360 --> 00:34:01,360
execution

00:33:58,240 --> 00:34:04,399
of a job or say the lifetime of the job

00:34:01,360 --> 00:34:07,679
the ref count will

00:34:04,399 --> 00:34:09,839
increase then decrease and eventually

00:34:07,679 --> 00:34:13,119
when it goes to zero

00:34:09,839 --> 00:34:16,720
it it's promised that no one is

00:34:13,119 --> 00:34:16,720
no one else is holding on it

00:34:19,599 --> 00:34:23,839
my friend anna proposed another

00:34:22,480 --> 00:34:27,119
interesting idea is

00:34:23,839 --> 00:34:29,599
we can directly just expose the

00:34:27,119 --> 00:34:31,520
concept of a lifetime to user we can

00:34:29,599 --> 00:34:32,839
forward the coaching ownership to the

00:34:31,520 --> 00:34:36,240
reiap

00:34:32,839 --> 00:34:40,800
object which will own the

00:34:36,240 --> 00:34:42,320
coating frame sorry quoting handle

00:34:40,800 --> 00:34:44,159
and they will destroy it in the

00:34:42,320 --> 00:34:46,320
destructor

00:34:44,159 --> 00:34:48,320
and user will hold within the scope and

00:34:46,320 --> 00:34:50,000
manually release it

00:34:48,320 --> 00:34:53,359
then we can design some high-level

00:34:50,000 --> 00:34:57,119
system and impose different mechanisms

00:34:53,359 --> 00:34:57,119
for whatever way they want

00:34:57,760 --> 00:35:02,640
so if you try my example code this is

00:35:00,160 --> 00:35:06,480
what you get

00:35:02,640 --> 00:35:06,480
we launched five laps and

00:35:06,960 --> 00:35:13,599
sadly only one laps find it

00:35:10,400 --> 00:35:16,960
in the same round of the explorer

00:35:13,599 --> 00:35:20,000
and the lab to also find it

00:35:16,960 --> 00:35:20,720
for convenient i print out the stats per

00:35:20,000 --> 00:35:24,400
frame

00:35:20,720 --> 00:35:26,240
sorry per second and you can see here

00:35:24,400 --> 00:35:28,720
at the beginning we have 3 thousand

00:35:26,240 --> 00:35:30,720
people who are healthy and new vaccine

00:35:28,720 --> 00:35:32,480
then when we find the vaccine we start

00:35:30,720 --> 00:35:34,400
to produce it

00:35:32,480 --> 00:35:37,200
then eventually we have a little bit of

00:35:34,400 --> 00:35:39,920
vaccine out

00:35:37,200 --> 00:35:42,480
the reason that the vaccine left here

00:35:39,920 --> 00:35:44,640
always zero is because i assume

00:35:42,480 --> 00:35:45,599
we consume vaccine way faster than the

00:35:44,640 --> 00:35:48,160
production

00:35:45,599 --> 00:35:52,160
so once a vaccine is created it

00:35:48,160 --> 00:35:52,160
immediately get consumed by clinics

00:35:55,119 --> 00:36:01,040
so what's our gain

00:35:58,240 --> 00:36:02,240
i mean obviously it's more than syntax

00:36:01,040 --> 00:36:05,200
trigger right

00:36:02,240 --> 00:36:06,720
um the first thing is the dependency

00:36:05,200 --> 00:36:09,760
management is gone

00:36:06,720 --> 00:36:10,720
we don't do any more bookkeeping and the

00:36:09,760 --> 00:36:13,760
overhead is

00:36:10,720 --> 00:36:16,160
greatly reduced and we also have the

00:36:13,760 --> 00:36:19,520
potential chance to

00:36:16,160 --> 00:36:21,839
do some immediate execution of the job

00:36:19,520 --> 00:36:23,920
and we have a cleaner interface now we

00:36:21,839 --> 00:36:26,079
don't need to deal with the user data

00:36:23,920 --> 00:36:28,480
because it's handled by the protein

00:36:26,079 --> 00:36:31,760
frame which is handled by the compiler

00:36:28,480 --> 00:36:34,000
and in our older system we usually will

00:36:31,760 --> 00:36:35,040
let users to construct a struct by

00:36:34,000 --> 00:36:38,000
themselves which is

00:36:35,040 --> 00:36:39,359
also managed by themselves and they will

00:36:38,000 --> 00:36:42,400
have the option to

00:36:39,359 --> 00:36:43,200
pass in a void pointer and then in the

00:36:42,400 --> 00:36:46,160
job that's

00:36:43,200 --> 00:36:47,599
itself it will cast it back and access

00:36:46,160 --> 00:36:50,400
their contacts

00:36:47,599 --> 00:36:53,119
or another way lambda we can have a

00:36:50,400 --> 00:36:55,680
lambda and have a bunch of capture

00:36:53,119 --> 00:36:56,800
in the lambda which goes through another

00:36:55,680 --> 00:36:59,680
issue is

00:36:56,800 --> 00:37:02,400
it increa it adds a lot of syntax noise

00:36:59,680 --> 00:37:02,400
in the system

00:37:02,640 --> 00:37:06,480
so and and you require certain tricks of

00:37:05,520 --> 00:37:09,200
type erasure

00:37:06,480 --> 00:37:10,640
or something like that for the system to

00:37:09,200 --> 00:37:12,720
use the lambda

00:37:10,640 --> 00:37:13,839
which is kind of the work of recreating

00:37:12,720 --> 00:37:17,200
std function

00:37:13,839 --> 00:37:19,280
in some way and the memory allocation is

00:37:17,200 --> 00:37:22,880
also improved

00:37:19,280 --> 00:37:24,880
the first is we the heap allocations can

00:37:22,880 --> 00:37:27,280
be voided in some cases

00:37:24,880 --> 00:37:29,040
once the compiler can determine the

00:37:27,280 --> 00:37:32,240
scope of the coating

00:37:29,040 --> 00:37:32,960
it will it can then say okay it's in

00:37:32,240 --> 00:37:35,520
this scope

00:37:32,960 --> 00:37:36,079
i can just allocate the coating frame in

00:37:35,520 --> 00:37:38,960
the stack

00:37:36,079 --> 00:37:40,560
instead and the second a lot of cases

00:37:38,960 --> 00:37:44,079
for us we have some custom

00:37:40,560 --> 00:37:45,200
allocator and it also can be integrated

00:37:44,079 --> 00:37:48,160
pretty easily

00:37:45,200 --> 00:37:48,960
in a sense we just need to override a

00:37:48,160 --> 00:37:51,599
provided

00:37:48,960 --> 00:37:54,000
operator new function in the promise

00:37:51,599 --> 00:37:54,000
object

00:37:56,240 --> 00:38:02,839
and sadly the word is not perfect

00:37:59,760 --> 00:38:05,520
um there is a certain challenge or

00:38:02,839 --> 00:38:07,599
disadvantage that we need to work out

00:38:05,520 --> 00:38:08,800
before the feature can be used in

00:38:07,599 --> 00:38:10,720
production

00:38:08,800 --> 00:38:12,320
the first is i found that it's quite a

00:38:10,720 --> 00:38:15,359
big challenge to integrate

00:38:12,320 --> 00:38:19,280
profiler to this kind of

00:38:15,359 --> 00:38:21,200
system the first issue is because

00:38:19,280 --> 00:38:22,560
we chop the protein into different

00:38:21,200 --> 00:38:24,800
pieces and

00:38:22,560 --> 00:38:25,920
they can potentially resume in different

00:38:24,800 --> 00:38:28,560
threads

00:38:25,920 --> 00:38:29,200
so when we draw a visualization which is

00:38:28,560 --> 00:38:32,400
usually

00:38:29,200 --> 00:38:34,320
a time frame flame graph it's

00:38:32,400 --> 00:38:35,839
hard to visualize it because they're

00:38:34,320 --> 00:38:37,680
going to be scattered in different

00:38:35,839 --> 00:38:41,760
threads now

00:38:37,680 --> 00:38:44,839
and the second is it missed some handy

00:38:41,760 --> 00:38:47,839
preprocessor like curtin suspension

00:38:44,839 --> 00:38:47,839
point

00:38:48,160 --> 00:38:52,640
for if we have that we can work on that

00:38:50,800 --> 00:38:55,200
and improve our profiler

00:38:52,640 --> 00:38:57,280
can kind of re-gather the necessary

00:38:55,200 --> 00:38:59,680
information together

00:38:57,280 --> 00:39:02,079
and the third one is that i ii style

00:38:59,680 --> 00:39:05,280
mechanism is broken

00:39:02,079 --> 00:39:06,560
in some stress sensitive context imagine

00:39:05,280 --> 00:39:09,040
you have something

00:39:06,560 --> 00:39:11,680
which has some threat local or you

00:39:09,040 --> 00:39:15,599
remember the threat index

00:39:11,680 --> 00:39:18,400
and because coaching resumed and

00:39:15,599 --> 00:39:19,119
suspended and kind of jumped around it

00:39:18,400 --> 00:39:22,240
cannot

00:39:19,119 --> 00:39:24,560
have the assumption of okay we um

00:39:22,240 --> 00:39:26,480
we are running on this threat and this

00:39:24,560 --> 00:39:30,240
it's not aware of the switch of

00:39:26,480 --> 00:39:32,640
relocal or something like that

00:39:30,240 --> 00:39:33,839
and also it's quite a challenge for a

00:39:32,640 --> 00:39:36,960
system developer to

00:39:33,839 --> 00:39:39,599
implement a system like this so first we

00:39:36,960 --> 00:39:42,720
don't have really good tool support

00:39:39,599 --> 00:39:45,119
so far and second

00:39:42,720 --> 00:39:46,640
because how compiler works it generated

00:39:45,119 --> 00:39:49,839
a lot of code and

00:39:46,640 --> 00:39:52,400
it's generally just hard for users to

00:39:49,839 --> 00:39:54,960
step through these functions and see

00:39:52,400 --> 00:39:58,000
what's going on

00:39:54,960 --> 00:40:01,040
and also we just been through over

00:39:58,000 --> 00:40:02,560
40 40 minutes to talk about how i

00:40:01,040 --> 00:40:05,040
implemented this system

00:40:02,560 --> 00:40:06,560
but it was way more involved when i

00:40:05,040 --> 00:40:10,560
tried to learn the host back

00:40:06,560 --> 00:40:13,280
and try to implement it

00:40:10,560 --> 00:40:14,160
and so far there's a lot of detail we

00:40:13,280 --> 00:40:18,079
haven't discussed

00:40:14,160 --> 00:40:20,800
which which actually gonna

00:40:18,079 --> 00:40:22,960
it which actually is important in the

00:40:20,800 --> 00:40:26,400
production

00:40:22,960 --> 00:40:28,240
and finally to use such system the user

00:40:26,400 --> 00:40:30,800
gonna need more knowledge

00:40:28,240 --> 00:40:32,400
than the usual because now they need to

00:40:30,800 --> 00:40:34,640
understand the code team and also

00:40:32,400 --> 00:40:36,720
understand how system works

00:40:34,640 --> 00:40:39,839
so that they don't make make mistakes

00:40:36,720 --> 00:40:39,839
and trap themselves

00:40:41,520 --> 00:40:44,880
and finally i'm i feel really grateful

00:40:44,160 --> 00:40:47,119
about

00:40:44,880 --> 00:40:48,560
all my good friends and thanks for all

00:40:47,119 --> 00:40:50,880
the help that makes this

00:40:48,560 --> 00:40:52,160
talk possible and i hope everyone likes

00:40:50,880 --> 00:40:55,760
it

00:40:52,160 --> 00:40:59,119
and we have about 15 minutes

00:40:55,760 --> 00:41:00,640
any questions okay so i see people are

00:40:59,119 --> 00:41:03,760
very

00:41:00,640 --> 00:41:07,200
curious about how can we

00:41:03,760 --> 00:41:10,720
observe what the compiler is doing or is

00:41:07,200 --> 00:41:13,280
it is there any flag or similar

00:41:10,720 --> 00:41:14,960
thing to outputting the media code i

00:41:13,280 --> 00:41:18,560
sniff around and sadly

00:41:14,960 --> 00:41:19,680
the answer is no the closest thing you

00:41:18,560 --> 00:41:22,820
can get is

00:41:19,680 --> 00:41:22,820
[Music]

00:41:30,520 --> 00:41:36,319
[Music]

00:41:33,200 --> 00:41:36,319
expose available features

00:41:37,760 --> 00:41:52,240
any questions

00:41:48,720 --> 00:41:52,240
uh can you hear me

00:41:55,680 --> 00:42:03,839
okay all right that's great

00:42:12,560 --> 00:42:18,880
thanks very much um i see there are two

00:42:16,290 --> 00:42:21,440
[Music]

00:42:18,880 --> 00:42:21,920
okay how does your drop system decide

00:42:21,440 --> 00:42:25,200
which

00:42:21,920 --> 00:42:28,400
coating to run um

00:42:25,200 --> 00:42:31,040
so this when you say decide

00:42:28,400 --> 00:42:31,680
which coating to run i assume it's it

00:42:31,040 --> 00:42:34,480
means like

00:42:31,680 --> 00:42:36,640
which job to run this is part of the

00:42:34,480 --> 00:42:39,359
decision scheduler can make

00:42:36,640 --> 00:42:40,800
for me if you see my code which will

00:42:39,359 --> 00:42:44,079
release later

00:42:40,800 --> 00:42:46,319
um but basically it's a scheduler and it

00:42:44,079 --> 00:42:50,000
has a drop queue and it's just

00:42:46,319 --> 00:42:51,359
dequeuing items one by one if you want

00:42:50,000 --> 00:42:54,400
have something

00:42:51,359 --> 00:42:56,240
for priority or you see like some job

00:42:54,400 --> 00:42:58,560
type what you can do is

00:42:56,240 --> 00:42:59,359
we have the token and now we have two

00:42:58,560 --> 00:43:02,880
different

00:42:59,359 --> 00:43:05,440
um two different uh template parameters

00:43:02,880 --> 00:43:06,560
one is the deferred the second is the

00:43:05,440 --> 00:43:09,040
actual type t

00:43:06,560 --> 00:43:10,240
you you for the return value um then you

00:43:09,040 --> 00:43:13,119
can add other things

00:43:10,240 --> 00:43:15,280
for example you can add an eden to say

00:43:13,119 --> 00:43:18,800
like what's the job category

00:43:15,280 --> 00:43:21,680
or another one to specify the job

00:43:18,800 --> 00:43:22,480
priority then you can hand that

00:43:21,680 --> 00:43:25,119
information

00:43:22,480 --> 00:43:26,240
to the job you know struct when you

00:43:25,119 --> 00:43:27,680
construct a job

00:43:26,240 --> 00:43:29,599
and the scheduler will have that

00:43:27,680 --> 00:43:31,760
information and they will have

00:43:29,599 --> 00:43:34,720
you know different um scheduling

00:43:31,760 --> 00:43:37,359
strategies something like that

00:43:34,720 --> 00:43:39,200
and then what learning resources were

00:43:37,359 --> 00:43:44,240
the most used for

00:43:39,200 --> 00:43:47,680
when preparing this talk

00:43:44,240 --> 00:43:51,920
uh i are you saying preparing the talk

00:43:47,680 --> 00:43:54,319
uh i i'm not sure i

00:43:51,920 --> 00:43:56,560
prepared something specifically for a

00:43:54,319 --> 00:43:59,040
talk

00:43:56,560 --> 00:43:59,839
if you're seeing like technical detail

00:43:59,040 --> 00:44:02,240
um

00:43:59,839 --> 00:44:03,040
there are several things you want to

00:44:02,240 --> 00:44:04,319
look at

00:44:03,040 --> 00:44:06,800
but basically they are allowing my

00:44:04,319 --> 00:44:09,520
slides i highly recommend you

00:44:06,800 --> 00:44:10,720
you check out all of them and but

00:44:09,520 --> 00:44:13,520
basically several things

00:44:10,720 --> 00:44:14,240
you definitely need to look into first

00:44:13,520 --> 00:44:17,280
is

00:44:14,240 --> 00:44:18,400
the you know black box magic compiler

00:44:17,280 --> 00:44:22,079
magic

00:44:18,400 --> 00:44:25,760
and which i provide a guidebook link

00:44:22,079 --> 00:44:28,560
and also my slide has some explanation

00:44:25,760 --> 00:44:30,079
and also there's a link in my talk

00:44:28,560 --> 00:44:32,720
description which is

00:44:30,079 --> 00:44:34,640
kind of like an index of other coaching

00:44:32,720 --> 00:44:38,640
resources available

00:44:34,640 --> 00:44:38,640
currently so you can check out that

00:44:39,040 --> 00:44:44,640
okay let me check out this is that code

00:44:42,319 --> 00:44:45,440
is the code that you will release crop

00:44:44,640 --> 00:44:47,520
platform

00:44:45,440 --> 00:44:48,880
i heard you mention windows uh so so

00:44:47,520 --> 00:44:52,400
here's the thing

00:44:48,880 --> 00:44:55,119
i didn't make it portable

00:44:52,400 --> 00:44:57,599
but i tried to make sure you need to

00:44:55,119 --> 00:44:59,119
change the minimal code to make it work

00:44:57,599 --> 00:45:01,920
so far there are several things you need

00:44:59,119 --> 00:45:04,480
to change the first thing is the

00:45:01,920 --> 00:45:05,680
the cmake file only works on windows so

00:45:04,480 --> 00:45:07,520
you probably need to like

00:45:05,680 --> 00:45:09,200
change some flags something like that

00:45:07,520 --> 00:45:12,640
and the second there's a

00:45:09,200 --> 00:45:16,400
youtube hpp something like that

00:45:12,640 --> 00:45:17,119
and there's some platform api you will

00:45:16,400 --> 00:45:20,560
need to

00:45:17,119 --> 00:45:23,359
change the next one so then everything

00:45:20,560 --> 00:45:23,359
else sure works

00:45:25,280 --> 00:45:30,560
how do you schedule these tasks do you

00:45:27,760 --> 00:45:33,760
combine it with multi-threading

00:45:30,560 --> 00:45:35,280
okay so again um it's more about

00:45:33,760 --> 00:45:36,800
scheduler but basically you have a

00:45:35,280 --> 00:45:39,119
scheduler

00:45:36,800 --> 00:45:40,240
then you the scheduler will spawn

00:45:39,119 --> 00:45:42,000
several workers

00:45:40,240 --> 00:45:44,240
according to how many strats you have

00:45:42,000 --> 00:45:46,319
for my case or some system they use

00:45:44,240 --> 00:45:46,800
fiverr but that's another issue um but

00:45:46,319 --> 00:45:49,760
anyway

00:45:46,800 --> 00:45:51,440
some kind of you know running contacts

00:45:49,760 --> 00:45:53,760
and then it spawned them

00:45:51,440 --> 00:45:55,119
for my system in the example it did very

00:45:53,760 --> 00:45:56,880
simple things

00:45:55,119 --> 00:45:58,240
the queue is a lot cute that means it

00:45:56,880 --> 00:46:00,240
has a mule text

00:45:58,240 --> 00:46:02,480
so anyone try to access it apply the

00:46:00,240 --> 00:46:04,720
move text or you're going to just wait

00:46:02,480 --> 00:46:06,000
then the worker giant gun just like grab

00:46:04,720 --> 00:46:08,880
an item from the queue

00:46:06,000 --> 00:46:10,720
and try to run the code team and

00:46:08,880 --> 00:46:14,240
everything internally it's

00:46:10,720 --> 00:46:16,880
you know you just call our resume

00:46:14,240 --> 00:46:18,000
and everything just happens and it

00:46:16,880 --> 00:46:21,280
hooked up by the

00:46:18,000 --> 00:46:22,400
um but we have we mentioned the final

00:46:21,280 --> 00:46:25,119
suspend

00:46:22,400 --> 00:46:26,079
and a weight both span that set the

00:46:25,119 --> 00:46:28,560
protein

00:46:26,079 --> 00:46:31,119
continuation and reschedule them to the

00:46:28,560 --> 00:46:31,119
scheduler

00:46:31,280 --> 00:46:36,400
how does your job system do that okay we

00:46:33,680 --> 00:46:39,440
go over this already

00:46:36,400 --> 00:46:42,160
what are the best alternative to coding

00:46:39,440 --> 00:46:44,240
when we should use qrt and when

00:46:42,160 --> 00:46:47,520
callbacks are good enough

00:46:44,240 --> 00:46:51,520
okay so uh i

00:46:47,520 --> 00:46:55,680
i'm not sure what you mean callback

00:46:51,520 --> 00:46:58,240
i assume you mean like after

00:46:55,680 --> 00:46:59,599
the execution of a job you want to

00:46:58,240 --> 00:47:02,880
launch another job

00:46:59,599 --> 00:47:04,480
so that's generally possible people have

00:47:02,880 --> 00:47:06,240
different ways to handle that usually

00:47:04,480 --> 00:47:06,720
people just declare the dependency

00:47:06,240 --> 00:47:10,160
between

00:47:06,720 --> 00:47:12,079
two jobs but like a callback is

00:47:10,160 --> 00:47:13,680
i assume it's it's kind of assumption

00:47:12,079 --> 00:47:17,680
for a job system say like

00:47:13,680 --> 00:47:20,480
every job will have a optional callback

00:47:17,680 --> 00:47:21,280
and if it's registered then it can call

00:47:20,480 --> 00:47:24,720
you out

00:47:21,280 --> 00:47:27,680
um i think the callback

00:47:24,720 --> 00:47:28,960
issue is there are several things for

00:47:27,680 --> 00:47:32,319
the callback the first

00:47:28,960 --> 00:47:34,960
is you you want you and

00:47:32,319 --> 00:47:36,559
figure need to figure out a way to

00:47:34,960 --> 00:47:39,839
capture the contacts

00:47:36,559 --> 00:47:40,319
so they can be accessed in the callback

00:47:39,839 --> 00:47:43,040
which

00:47:40,319 --> 00:47:45,200
is the advantage we mentioned for the

00:47:43,040 --> 00:47:48,160
core team

00:47:45,200 --> 00:47:49,280
the second is if you imagine how you're

00:47:48,160 --> 00:47:52,800
gonna

00:47:49,280 --> 00:47:56,400
code the job system in a callback mesh

00:47:52,800 --> 00:47:58,559
fashion or say um declarative dependency

00:47:56,400 --> 00:48:00,079
you'll see how the code write is very

00:47:58,559 --> 00:48:00,640
different from how you're going to read

00:48:00,079 --> 00:48:03,200
it

00:48:00,640 --> 00:48:05,520
and it's non-linear so it's it's kind of

00:48:03,200 --> 00:48:08,400
a little bit harder to understand

00:48:05,520 --> 00:48:09,280
but other than that i think you can

00:48:08,400 --> 00:48:13,839
pretty much

00:48:09,280 --> 00:48:16,960
achieve a similar result if you

00:48:13,839 --> 00:48:17,920
basically have a system to enforce

00:48:16,960 --> 00:48:20,079
certain

00:48:17,920 --> 00:48:21,280
manually enforce certain things coaching

00:48:20,079 --> 00:48:24,319
do for example

00:48:21,280 --> 00:48:25,839
you try to capture the these members and

00:48:24,319 --> 00:48:28,720
do hit allocation

00:48:25,839 --> 00:48:30,000
to capture the sorry not members the the

00:48:28,720 --> 00:48:32,079
contacts arrivals

00:48:30,000 --> 00:48:33,520
then to keep allocation or some sort of

00:48:32,079 --> 00:48:36,079
allocation

00:48:33,520 --> 00:48:37,359
to keep these things and then resume

00:48:36,079 --> 00:48:39,599
them manually

00:48:37,359 --> 00:48:40,720
and then you keep track of the

00:48:39,599 --> 00:48:43,839
dependency order

00:48:40,720 --> 00:48:48,640
and resume well

00:48:43,839 --> 00:48:50,480
run the job once you you can and um

00:48:48,640 --> 00:48:52,079
and well keep tracking how many

00:48:50,480 --> 00:48:52,880
dependencies you have something like

00:48:52,079 --> 00:48:55,119
that

00:48:52,880 --> 00:48:56,640
does that make sense please tell me if

00:48:55,119 --> 00:48:56,880
anything doesn't make sense you can type

00:48:56,640 --> 00:48:59,920
in

00:48:56,880 --> 00:49:03,040
chat on our response okay so

00:48:59,920 --> 00:49:06,160
next one you mentioned there was some

00:49:03,040 --> 00:49:08,880
tools support needed to

00:49:06,160 --> 00:49:10,800
help debug in the profile implantation

00:49:08,880 --> 00:49:11,839
how did you debug it without that

00:49:10,800 --> 00:49:15,680
support

00:49:11,839 --> 00:49:19,119
okay here are several things when

00:49:15,680 --> 00:49:22,800
for example there is one thing is uh

00:49:19,119 --> 00:49:26,319
resume uh presumably that already

00:49:22,800 --> 00:49:27,440
reached finance expand is undefined

00:49:26,319 --> 00:49:31,680
behavior

00:49:27,440 --> 00:49:33,839
and how mvc implemented is it insert a

00:49:31,680 --> 00:49:34,800
debug very basically an instruction

00:49:33,839 --> 00:49:38,319
industry

00:49:34,800 --> 00:49:40,240
um then say it will just crash or if

00:49:38,319 --> 00:49:40,720
it's in debug mode it will just stop

00:49:40,240 --> 00:49:44,160
here

00:49:40,720 --> 00:49:47,119
and i don't know why so i i got some

00:49:44,160 --> 00:49:48,000
help from the msvc i i emailed and asked

00:49:47,119 --> 00:49:50,960
questions

00:49:48,000 --> 00:49:52,480
so they kind of helped me out and

00:49:50,960 --> 00:49:54,079
another part is

00:49:52,480 --> 00:49:56,079
at the beginning of learning these

00:49:54,079 --> 00:49:58,960
things i i

00:49:56,079 --> 00:50:01,839
well i asked another person who is who

00:49:58,960 --> 00:50:04,960
has more knowledge about the core team

00:50:01,839 --> 00:50:07,280
so that he can give me some instruction

00:50:04,960 --> 00:50:09,520
and like verify my understanding

00:50:07,280 --> 00:50:10,720
so that's about like person connections

00:50:09,520 --> 00:50:14,319
and another thing

00:50:10,720 --> 00:50:16,880
then i use a lot is i mean

00:50:14,319 --> 00:50:18,079
at the end of word it's assembly right

00:50:16,880 --> 00:50:20,800
instructions

00:50:18,079 --> 00:50:22,319
so you can kinda go go to the assemble

00:50:20,800 --> 00:50:24,480
the assembly and

00:50:22,319 --> 00:50:26,960
stepping through and according to the i

00:50:24,480 --> 00:50:27,200
mean you you cannot see the intermediate

00:50:26,960 --> 00:50:29,680
c

00:50:27,200 --> 00:50:30,319
plus plus source code but because it's

00:50:29,680 --> 00:50:32,720
compiled

00:50:30,319 --> 00:50:33,920
you can still see the the function name

00:50:32,720 --> 00:50:35,839
the disassembly

00:50:33,920 --> 00:50:37,680
so you can kind of see where it's

00:50:35,839 --> 00:50:42,240
jumping into

00:50:37,680 --> 00:50:44,880
and another way to help you to

00:50:42,240 --> 00:50:46,319
kind of go through this is you can print

00:50:44,880 --> 00:50:49,920
a lot of printf

00:50:46,319 --> 00:50:52,960
in each customization point and you can

00:50:49,920 --> 00:50:56,480
also do like um

00:50:52,960 --> 00:50:58,559
um like put breakpoints to uh verify

00:50:56,480 --> 00:51:01,370
certain assumptions that you have

00:50:58,559 --> 00:51:03,280
and another one is

00:51:01,370 --> 00:51:05,760
[Music]

00:51:03,280 --> 00:51:07,760
another one yeah i actually i think

00:51:05,760 --> 00:51:08,640
that's that's a basically two very

00:51:07,760 --> 00:51:12,000
important

00:51:08,640 --> 00:51:14,800
method and because the the

00:51:12,000 --> 00:51:15,680
how new this feature is i highly

00:51:14,800 --> 00:51:19,520
recommend

00:51:15,680 --> 00:51:21,520
you don't assume anything works ideally

00:51:19,520 --> 00:51:22,640
and compiler sometimes can have some

00:51:21,520 --> 00:51:37,839
bugs

00:51:22,640 --> 00:51:37,839
there are also softwares

00:51:45,119 --> 00:51:47,200

YouTube URL: https://www.youtube.com/watch?v=KWi793v5uA8


