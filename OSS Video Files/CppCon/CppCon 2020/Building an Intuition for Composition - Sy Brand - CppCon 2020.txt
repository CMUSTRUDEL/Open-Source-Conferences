Title: Building an Intuition for Composition - Sy Brand - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
If you're fed up of reading articles about "monads" and "endofunctors" that don't give you an understanding of how they can actually help your C++ programming, this talk is for you.

Function and data composition are becoming increasingly important in C++ due to features like ranges, continuable futures, and new error handling techniques. Using real-world examples and C++ programming idioms, I'll help you build an intuition for the mathematical concepts which underpin these so that you can make the most of them in your code and build your own abstractions built on the same foundations.

---
Sy Brand is Microsoftâ€™s C++ Developer Advocate. Their background is in compilers and debuggers for embedded accelerators, but theyâ€™re also interested in generic library design, metaprogramming, functional-style C++, undefined behaviour, and making our communities more welcoming and inclusive.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,440 --> 00:00:12,880
welcome to building an intuition for

00:00:11,679 --> 00:00:14,960
composition

00:00:12,880 --> 00:00:16,880
my name is sai brand and microsoft

00:00:14,960 --> 00:00:19,920
sequels plus developer advocate

00:00:16,880 --> 00:00:23,359
and i have a confession to make

00:00:19,920 --> 00:00:25,199
i'm bad at maths i'm like way worse at

00:00:23,359 --> 00:00:26,720
math than you might expect

00:00:25,199 --> 00:00:29,039
you know i did mass all the way through

00:00:26,720 --> 00:00:31,359
high school uh right till the end

00:00:29,039 --> 00:00:32,559
and you know i did okay i passed just

00:00:31,359 --> 00:00:34,480
about

00:00:32,559 --> 00:00:36,239
and then when i went to university to

00:00:34,480 --> 00:00:38,160
study computer science i had to do maths

00:00:36,239 --> 00:00:40,160
again in my first year

00:00:38,160 --> 00:00:42,079
and the course was pretty much identical

00:00:40,160 --> 00:00:43,360
to the one i'd done in high school

00:00:42,079 --> 00:00:45,120
so you'd think that you know after a

00:00:43,360 --> 00:00:47,360
year of more studying

00:00:45,120 --> 00:00:49,200
i would understand the concepts better i

00:00:47,360 --> 00:00:52,719
would have got better but

00:00:49,200 --> 00:00:54,559
i actually got worse and it wasn't just

00:00:52,719 --> 00:00:58,160
to do with marking schemes

00:00:54,559 --> 00:01:00,480
it was to do with sitting and looking a

00:00:58,160 --> 00:01:02,719
whiteboard full of mathematical notation

00:01:00,480 --> 00:01:03,840
and just having my entire brain glaze

00:01:02,719 --> 00:01:06,080
over

00:01:03,840 --> 00:01:07,439
i just couldn't do it so yeah i'm bad at

00:01:06,080 --> 00:01:09,760
maths

00:01:07,439 --> 00:01:10,960
but i am interested in maths i'm

00:01:09,760 --> 00:01:12,560
interested in

00:01:10,960 --> 00:01:14,080
all of the concepts which help us in

00:01:12,560 --> 00:01:16,000
computer science which

00:01:14,080 --> 00:01:17,680
make our code better which make our code

00:01:16,000 --> 00:01:21,040
faster things like

00:01:17,680 --> 00:01:22,479
set theory like um category theory

00:01:21,040 --> 00:01:25,520
abstract algebra i'm

00:01:22,479 --> 00:01:27,600
interested in all of these things so

00:01:25,520 --> 00:01:29,520
i wanted to learn i want to teach myself

00:01:27,600 --> 00:01:30,320
these things so i'd look for a bunch of

00:01:29,520 --> 00:01:32,240
resources

00:01:30,320 --> 00:01:33,680
and i'd come across the same problems i

00:01:32,240 --> 00:01:37,360
had at university

00:01:33,680 --> 00:01:39,520
lots of just mathematical notation which

00:01:37,360 --> 00:01:40,640
for some reason i just could not fathom

00:01:39,520 --> 00:01:44,000
i couldn't get any

00:01:40,640 --> 00:01:45,840
understanding or intuition out of it

00:01:44,000 --> 00:01:47,280
and i thought this was just me you know

00:01:45,840 --> 00:01:48,159
i'd look at a bunch of wikipedia

00:01:47,280 --> 00:01:49,920
articles

00:01:48,159 --> 00:01:51,439
and brain freeze and then i saw this

00:01:49,920 --> 00:01:53,520
tweet recently

00:01:51,439 --> 00:01:55,759
i used to think i wasn't smart enough to

00:01:53,520 --> 00:01:56,880
understand wikipedia articles on math

00:01:55,759 --> 00:01:58,000
and computing

00:01:56,880 --> 00:02:00,560
and have recently come to the

00:01:58,000 --> 00:02:03,040
realization that no the articles are

00:02:00,560 --> 00:02:04,479
just badly written

00:02:03,040 --> 00:02:06,719
maybe there are some people that these

00:02:04,479 --> 00:02:10,479
articles work for but

00:02:06,719 --> 00:02:11,200
certainly not me so the point of this

00:02:10,479 --> 00:02:15,440
talk

00:02:11,200 --> 00:02:17,760
was to be the kind of talk i needed

00:02:15,440 --> 00:02:19,520
when i was trying to teach myself a lot

00:02:17,760 --> 00:02:21,040
of the concepts from these branches of

00:02:19,520 --> 00:02:23,120
mathematics and just

00:02:21,040 --> 00:02:25,520
completely failing i want the kind of

00:02:23,120 --> 00:02:27,280
talk that i could have given to myself

00:02:25,520 --> 00:02:29,040
and being like hey watch this it can

00:02:27,280 --> 00:02:30,959
give you an understanding of how

00:02:29,040 --> 00:02:32,239
these things can help you in your

00:02:30,959 --> 00:02:34,720
day-to-day coding

00:02:32,239 --> 00:02:36,720
without having to build up a bunch of

00:02:34,720 --> 00:02:39,200
like really theoretical mathematical

00:02:36,720 --> 00:02:41,599
understanding

00:02:39,200 --> 00:02:42,239
so i'm not aiming for accuracy in this

00:02:41,599 --> 00:02:44,480
talk

00:02:42,239 --> 00:02:46,400
i'm gonna throw a bunch of arrows a

00:02:44,480 --> 00:02:48,000
bunch of examples out there

00:02:46,400 --> 00:02:50,080
to try and help you build up your own

00:02:48,000 --> 00:02:50,800
understanding of how these things can

00:02:50,080 --> 00:02:52,640
help you

00:02:50,800 --> 00:02:54,319
if you want accuracy look for a

00:02:52,640 --> 00:02:57,360
different resource

00:02:54,319 --> 00:02:57,360
maybe not wikipedia

00:02:57,840 --> 00:03:01,840
before i get started on the real meat of

00:03:00,800 --> 00:03:03,680
the talk

00:03:01,840 --> 00:03:06,159
as i mentioned i work at microsoft we

00:03:03,680 --> 00:03:07,280
have a bunch of stuff at cppcon a bunch

00:03:06,159 --> 00:03:09,680
of announcements

00:03:07,280 --> 00:03:11,200
we have 10 talks so if you have any

00:03:09,680 --> 00:03:12,720
questions about any of our talks

00:03:11,200 --> 00:03:15,120
including this one

00:03:12,720 --> 00:03:15,760
please come talk to us at the expo hall

00:03:15,120 --> 00:03:18,400
we have a

00:03:15,760 --> 00:03:20,239
table there we also have our own room

00:03:18,400 --> 00:03:22,480
feel free to ask your questions

00:03:20,239 --> 00:03:23,360
give us your feedback let us know any

00:03:22,480 --> 00:03:25,440
issues you have

00:03:23,360 --> 00:03:27,760
we also have our survey as we do every

00:03:25,440 --> 00:03:30,560
year which helps us to tune our tools to

00:03:27,760 --> 00:03:32,319
help you better and you can also win a

00:03:30,560 --> 00:03:34,000
copy of flight simulator which is always

00:03:32,319 --> 00:03:36,239
nice

00:03:34,000 --> 00:03:38,480
all right let's talk about stood

00:03:36,239 --> 00:03:40,799
accumulate

00:03:38,480 --> 00:03:42,400
city cumulate is an algorithm which is

00:03:40,799 --> 00:03:44,400
not in the algorithms

00:03:42,400 --> 00:03:46,000
header it's in numerics it's one of

00:03:44,400 --> 00:03:48,400
those siebels plus things

00:03:46,000 --> 00:03:50,560
but you may be familiar with it we can

00:03:48,400 --> 00:03:53,200
give it a range of iterators

00:03:50,560 --> 00:03:54,319
and an initial element and it will sum

00:03:53,200 --> 00:03:56,400
all of these up

00:03:54,319 --> 00:03:57,439
so if we have a vector one two three

00:03:56,400 --> 00:03:59,280
then we add

00:03:57,439 --> 00:04:01,040
zero to one to two to three and we get

00:03:59,280 --> 00:04:03,920
six okay

00:04:01,040 --> 00:04:06,480
fairly straightforward but we don't just

00:04:03,920 --> 00:04:08,159
have to use the plus operator we could

00:04:06,480 --> 00:04:10,720
for example specify

00:04:08,159 --> 00:04:13,200
multiplies we want to multiply one to

00:04:10,720 --> 00:04:14,959
one to two to three

00:04:13,200 --> 00:04:17,519
so we can change the binary operator

00:04:14,959 --> 00:04:19,919
we're using

00:04:17,519 --> 00:04:22,320
this is um in a lot of literature

00:04:19,919 --> 00:04:24,320
referred to as a fold

00:04:22,320 --> 00:04:26,479
and you can kind of see why like if we

00:04:24,320 --> 00:04:29,280
have a bunch of elements

00:04:26,479 --> 00:04:29,840
and we want to accumulate them using

00:04:29,280 --> 00:04:33,280
plus

00:04:29,840 --> 00:04:35,759
we kind of fold this operator

00:04:33,280 --> 00:04:37,360
over all of the elements until we

00:04:35,759 --> 00:04:40,720
eventually end up with a nice

00:04:37,360 --> 00:04:40,720
origami crane or something

00:04:41,680 --> 00:04:45,520
of course it's not just integers we can

00:04:43,360 --> 00:04:46,160
accumulate we can accumulate a multitude

00:04:45,520 --> 00:04:49,199
of things

00:04:46,160 --> 00:04:50,080
uh for example strings this will join

00:04:49,199 --> 00:04:53,360
together

00:04:50,080 --> 00:04:55,199
hello and cppcon which just uses the the

00:04:53,360 --> 00:04:57,280
plus operator on stud string

00:04:55,199 --> 00:04:59,360
and uses the empty string as the initial

00:04:57,280 --> 00:05:01,600
element so we can accumulate ends we can

00:04:59,360 --> 00:05:03,840
accumulate strings

00:05:01,600 --> 00:05:04,800
we can also implement other algorithms

00:05:03,840 --> 00:05:07,759
in tur

00:05:04,800 --> 00:05:09,360
in terms of accumulate so this example

00:05:07,759 --> 00:05:12,400
takes

00:05:09,360 --> 00:05:14,160
an input range and a predicate calls

00:05:12,400 --> 00:05:16,160
that predicate on every element in the

00:05:14,160 --> 00:05:19,360
range and accumulates them using

00:05:16,160 --> 00:05:22,160
logical and this

00:05:19,360 --> 00:05:23,199
is an implementation of stood all of or

00:05:22,160 --> 00:05:25,759
at least

00:05:23,199 --> 00:05:26,560
it's similar to all of all of will short

00:05:25,759 --> 00:05:28,400
circuit

00:05:26,560 --> 00:05:30,000
and this doesn't but it's it will give

00:05:28,400 --> 00:05:32,080
you the same answer unless you're doing

00:05:30,000 --> 00:05:34,240
something weird

00:05:32,080 --> 00:05:35,520
we could then just change the name and

00:05:34,240 --> 00:05:38,240
flip the predicate

00:05:35,520 --> 00:05:39,840
in order to get none of and we could

00:05:38,240 --> 00:05:43,120
make a few other changes

00:05:39,840 --> 00:05:44,320
to get stood any of the point i'm making

00:05:43,120 --> 00:05:46,560
here is that

00:05:44,320 --> 00:05:47,919
you can implement a lot of algorithms in

00:05:46,560 --> 00:05:50,240
terms of

00:05:47,919 --> 00:05:52,240
accumulate in fact most of the

00:05:50,240 --> 00:05:54,560
algorithms in the algorithms header

00:05:52,240 --> 00:05:57,600
you could implement using accumulate if

00:05:54,560 --> 00:05:57,600
you tried hard enough

00:05:57,840 --> 00:06:02,080
so if most um functions in the c plus

00:06:00,400 --> 00:06:03,520
plus standard library are kind of like a

00:06:02,080 --> 00:06:05,680
screwdriver you know

00:06:03,520 --> 00:06:06,560
it works on flathead screws of a certain

00:06:05,680 --> 00:06:10,720
size

00:06:06,560 --> 00:06:13,120
it's kind of specific

00:06:10,720 --> 00:06:14,319
then accumulate is more like a sonic

00:06:13,120 --> 00:06:15,919
screwdriver

00:06:14,319 --> 00:06:17,759
if you're not familiar with doctor who

00:06:15,919 --> 00:06:19,520
then this is just way more powerful and

00:06:17,759 --> 00:06:23,520
a screwdriver can do way more things

00:06:19,520 --> 00:06:23,520
work in a bunch of different situations

00:06:24,639 --> 00:06:28,400
it's so general we actually invented our

00:06:27,120 --> 00:06:31,840
own syntax

00:06:28,400 --> 00:06:34,240
to do this using variatic templates

00:06:31,840 --> 00:06:36,639
and this was in siebels 17 it's called

00:06:34,240 --> 00:06:39,680
full expressions

00:06:36,639 --> 00:06:41,840
so we see something like this a

00:06:39,680 --> 00:06:43,120
function template which takes a variatic

00:06:41,840 --> 00:06:45,919
pack of arguments

00:06:43,120 --> 00:06:47,520
then we can fold the plus operator over

00:06:45,919 --> 00:06:51,440
that pack using this

00:06:47,520 --> 00:06:54,000
tease plus dot dot dot syntax

00:06:51,440 --> 00:06:55,520
so we call this sum function with one

00:06:54,000 --> 00:06:57,680
two and three

00:06:55,520 --> 00:06:59,120
then this will generate a function which

00:06:57,680 --> 00:07:02,160
looks like this

00:06:59,120 --> 00:07:04,800
returns an int takes three integers

00:07:02,160 --> 00:07:05,280
and just sums them all up and uses zero

00:07:04,800 --> 00:07:08,160
as

00:07:05,280 --> 00:07:08,160
the initial element

00:07:09,599 --> 00:07:13,759
so let's look in a bit more detail at

00:07:12,080 --> 00:07:16,400
this accumulate call

00:07:13,759 --> 00:07:17,759
so we have an input range we have an

00:07:16,400 --> 00:07:22,160
initial element

00:07:17,759 --> 00:07:23,919
and we have a binary operator

00:07:22,160 --> 00:07:25,759
and we can change this binary operator

00:07:23,919 --> 00:07:27,280
from plus to multiplies

00:07:25,759 --> 00:07:28,720
but now we have a problem because you

00:07:27,280 --> 00:07:31,840
know if you multiply anything by zero

00:07:28,720 --> 00:07:31,840
you're going to get 0 at the end

00:07:33,599 --> 00:07:38,960
so we want this to went to 1. now

00:07:37,039 --> 00:07:40,800
this initial element what we usually

00:07:38,960 --> 00:07:45,039
want to use here is called

00:07:40,800 --> 00:07:47,199
the identity element

00:07:45,039 --> 00:07:48,319
the identity element is a special

00:07:47,199 --> 00:07:50,479
element of a set

00:07:48,319 --> 00:07:52,720
which does not change the other input to

00:07:50,479 --> 00:07:54,800
a binary operator

00:07:52,720 --> 00:07:55,759
some examples which we've seen already

00:07:54,800 --> 00:07:58,560
in this talk

00:07:55,759 --> 00:08:00,240
for in and plus then zero is the

00:07:58,560 --> 00:08:01,680
identity element because

00:08:00,240 --> 00:08:03,360
at anything's zero you get the thing

00:08:01,680 --> 00:08:05,360
back and

00:08:03,360 --> 00:08:07,280
multiplication is one because multiply

00:08:05,360 --> 00:08:10,479
anything by one you get it back

00:08:07,280 --> 00:08:11,599
string plus empty string you kind of get

00:08:10,479 --> 00:08:14,080
the picture

00:08:11,599 --> 00:08:15,759
other examples set union if you union an

00:08:14,080 --> 00:08:18,479
empty set with anything else you get

00:08:15,759 --> 00:08:21,919
back the original set

00:08:18,479 --> 00:08:23,759
um bool and logical and true

00:08:21,919 --> 00:08:26,000
is the identity element for logical or

00:08:23,759 --> 00:08:28,400
it's false you get the picture

00:08:26,000 --> 00:08:30,960
the point is that the identity element

00:08:28,400 --> 00:08:33,519
does not just depend on your data type

00:08:30,960 --> 00:08:35,279
it depends on the pair of the data type

00:08:33,519 --> 00:08:38,399
and the binary operator

00:08:35,279 --> 00:08:38,399
which you're accumulating

00:08:39,519 --> 00:08:42,560
so that's all i want to say about

00:08:40,640 --> 00:08:45,040
identity elements let's look at this

00:08:42,560 --> 00:08:47,519
binary operator

00:08:45,040 --> 00:08:48,160
here's the example we had earlier of

00:08:47,519 --> 00:08:51,760
summing up

00:08:48,160 --> 00:08:52,720
10 integers now we could have way more

00:08:51,760 --> 00:08:55,760
than this

00:08:52,720 --> 00:08:56,160
we might want to distribute this data

00:08:55,760 --> 00:08:58,640
set

00:08:56,160 --> 00:09:00,560
across some number of cores or

00:08:58,640 --> 00:09:02,720
processors or computers

00:09:00,560 --> 00:09:04,000
might want to parallelize and we can do

00:09:02,720 --> 00:09:06,000
that by splitting up

00:09:04,000 --> 00:09:07,120
the input giving parts of it to

00:09:06,000 --> 00:09:09,040
different computers

00:09:07,120 --> 00:09:10,320
and we can use the identity element

00:09:09,040 --> 00:09:12,080
anywhere which

00:09:10,320 --> 00:09:13,760
we you know we don't have enough input

00:09:12,080 --> 00:09:15,360
for

00:09:13,760 --> 00:09:17,519
so we can just sum up everything on one

00:09:15,360 --> 00:09:20,240
machine and then

00:09:17,519 --> 00:09:20,800
sum the results and sum the results back

00:09:20,240 --> 00:09:24,160
together

00:09:20,800 --> 00:09:27,760
to get our final result great

00:09:24,160 --> 00:09:27,760
we've parallelized our computation

00:09:27,920 --> 00:09:32,720
what if we wanted to use minus maybe a

00:09:31,279 --> 00:09:34,480
little bit contrived but

00:09:32,720 --> 00:09:36,240
this is just for demonstration purposes

00:09:34,480 --> 00:09:38,160
say we want to use minus we

00:09:36,240 --> 00:09:40,160
fold the minus operator over and over

00:09:38,160 --> 00:09:45,440
until we get our result minus

00:09:40,160 --> 00:09:48,160
53. now if we try and parallelize this

00:09:45,440 --> 00:09:50,080
then we get a different answer we get

00:09:48,160 --> 00:09:51,760
minus 23.

00:09:50,080 --> 00:09:53,920
this isn't great you know if we do

00:09:51,760 --> 00:09:56,160
something sequentially or in parallel

00:09:53,920 --> 00:09:56,480
we'd quite like to get the right answer

00:09:56,160 --> 00:09:59,600
out

00:09:56,480 --> 00:10:01,680
at the end and the problem is that doing

00:09:59,600 --> 00:10:05,120
this parallelization work depends

00:10:01,680 --> 00:10:07,040
on the associativity of the binary

00:10:05,120 --> 00:10:09,200
operator

00:10:07,040 --> 00:10:11,200
where associativity an associative

00:10:09,200 --> 00:10:12,800
operator is one where the grouping of

00:10:11,200 --> 00:10:15,839
the operands does not

00:10:12,800 --> 00:10:18,959
matter or perhaps

00:10:15,839 --> 00:10:22,959
more concretely if you have

00:10:18,959 --> 00:10:25,440
a star b star c for some binary operator

00:10:22,959 --> 00:10:26,320
star then that should be the same thing

00:10:25,440 --> 00:10:29,360
as

00:10:26,320 --> 00:10:32,640
a star b star c

00:10:29,360 --> 00:10:34,959
okay there is actually an algorithm

00:10:32,640 --> 00:10:37,839
which was introduced in simpleplus17

00:10:34,959 --> 00:10:40,240
called reduce and that does exactly this

00:10:37,839 --> 00:10:42,560
it parallelizes your accumulation

00:10:40,240 --> 00:10:43,680
and requires the associativity of the

00:10:42,560 --> 00:10:46,720
binary operator

00:10:43,680 --> 00:10:47,120
it also requires commutativity but i'm

00:10:46,720 --> 00:10:50,399
not

00:10:47,120 --> 00:10:50,399
too fussed about that right now

00:10:50,480 --> 00:10:55,519
so what we have is one a data type

00:10:53,839 --> 00:10:57,839
two a binary operator which is

00:10:55,519 --> 00:10:58,959
associative and returns the same type as

00:10:57,839 --> 00:11:02,399
its arguments

00:10:58,959 --> 00:11:04,640
and three an identity element

00:11:02,399 --> 00:11:07,200
this turns out to be a really really

00:11:04,640 --> 00:11:08,880
common structure which pervades across

00:11:07,200 --> 00:11:11,040
a whole bunch of computer science and

00:11:08,880 --> 00:11:14,800
mathematics and it's called

00:11:11,040 --> 00:11:18,240
amonoid kind of a fancy term

00:11:14,800 --> 00:11:19,440
but it works for a very specific for a

00:11:18,240 --> 00:11:23,920
very general

00:11:19,440 --> 00:11:23,920
um structure of mathematics

00:11:24,399 --> 00:11:28,160
so if you have types you're composing

00:11:26,160 --> 00:11:31,600
often you may be able to expose

00:11:28,160 --> 00:11:33,440
ammonoid and doing so allows you to

00:11:31,600 --> 00:11:34,480
clearly define what object composition

00:11:33,440 --> 00:11:36,640
means

00:11:34,480 --> 00:11:39,600
to turn binary functions into any

00:11:36,640 --> 00:11:43,839
functions using accumulate or reduce

00:11:39,600 --> 00:11:46,399
and by unlocking parallelism

00:11:43,839 --> 00:11:47,839
so here's an example of where if you're

00:11:46,399 --> 00:11:49,519
looking for monoids if you're looking

00:11:47,839 --> 00:11:51,839
for composition you find it in

00:11:49,519 --> 00:11:54,000
maybe some unexpected places so this

00:11:51,839 --> 00:11:56,639
here's an example where we

00:11:54,000 --> 00:11:57,680
accumulate over in range and we're just

00:11:56,639 --> 00:12:00,399
taking the max

00:11:57,680 --> 00:12:02,480
of the two elements so we could this is

00:12:00,399 --> 00:12:04,320
stood max element

00:12:02,480 --> 00:12:06,240
and we noticed that this is a monod

00:12:04,320 --> 00:12:07,920
because we're accumulating over it we

00:12:06,240 --> 00:12:08,839
have an initial element we have a binary

00:12:07,920 --> 00:12:12,399
operator

00:12:08,839 --> 00:12:16,079
dissociative so this ordering

00:12:12,399 --> 00:12:17,920
forms a monoid over the integers great

00:12:16,079 --> 00:12:20,240
what about the ordering functions

00:12:17,920 --> 00:12:23,519
themselves can we compose those

00:12:20,240 --> 00:12:26,240
does that make sense what would it mean

00:12:23,519 --> 00:12:28,079
say we have a session type you know

00:12:26,240 --> 00:12:30,240
every session has a presenter

00:12:28,079 --> 00:12:32,000
has a title has a start time and a

00:12:30,240 --> 00:12:33,279
duration you know the duration might

00:12:32,000 --> 00:12:34,399
change but

00:12:33,279 --> 00:12:37,360
you know we try and stick to the

00:12:34,399 --> 00:12:38,480
duration we might want to display this

00:12:37,360 --> 00:12:40,079
information

00:12:38,480 --> 00:12:42,800
in different ways in very different

00:12:40,079 --> 00:12:45,440
contexts so sometimes we might want to

00:12:42,800 --> 00:12:47,360
you know sort by presenter sometimes we

00:12:45,440 --> 00:12:47,920
might want to sort on start time or get

00:12:47,360 --> 00:12:51,440
the

00:12:47,920 --> 00:12:53,360
greatest or few or smallest duration

00:12:51,440 --> 00:12:54,639
uh sometimes we might want to sort on

00:12:53,360 --> 00:12:56,720
presenter then

00:12:54,639 --> 00:12:58,800
title like i have three talks at this

00:12:56,720 --> 00:13:00,720
conference so maybe we want to

00:12:58,800 --> 00:13:02,240
sort alphabetically on presenter and

00:13:00,720 --> 00:13:05,040
then make sure that the titles are all

00:13:02,240 --> 00:13:06,959
sorted as well

00:13:05,040 --> 00:13:08,079
we might not want to bake this into our

00:13:06,959 --> 00:13:10,160
type

00:13:08,079 --> 00:13:11,120
you know we might not want an operator

00:13:10,160 --> 00:13:13,760
less than

00:13:11,120 --> 00:13:16,000
which just takes two session objects and

00:13:13,760 --> 00:13:16,880
hard codes in some decision about how to

00:13:16,000 --> 00:13:19,519
order

00:13:16,880 --> 00:13:21,200
this type we want to do this ad hoc

00:13:19,519 --> 00:13:24,480
we're going to make decisions

00:13:21,200 --> 00:13:27,519
at our use case so you might imagine

00:13:24,480 --> 00:13:28,320
an interface kind of like this we could

00:13:27,519 --> 00:13:30,959
have some

00:13:28,320 --> 00:13:32,480
function called order by which takes a

00:13:30,959 --> 00:13:34,160
member pointer

00:13:32,480 --> 00:13:35,519
and that will produce an ordering

00:13:34,160 --> 00:13:38,720
function which will

00:13:35,519 --> 00:13:40,160
order sessions by that member so we

00:13:38,720 --> 00:13:42,720
could use it by

00:13:40,160 --> 00:13:44,959
calling max element with your sessions

00:13:42,720 --> 00:13:48,880
and say order by the presenter

00:13:44,959 --> 00:13:51,199
and that will use our presenter as

00:13:48,880 --> 00:13:52,720
the the thing we want to order on i'm

00:13:51,199 --> 00:13:53,440
not too fussed by the implementation of

00:13:52,720 --> 00:13:56,079
order by

00:13:53,440 --> 00:13:58,320
it's implementable you can ask me how

00:13:56,079 --> 00:14:00,160
later

00:13:58,320 --> 00:14:02,399
now what if we wanted to do that

00:14:00,160 --> 00:14:03,120
lexicographic sort we wanted to order by

00:14:02,399 --> 00:14:07,360
presenter

00:14:03,120 --> 00:14:09,760
then um by title how would we do that

00:14:07,360 --> 00:14:12,079
well maybe we could compose together our

00:14:09,760 --> 00:14:14,560
orderings and produce a new one

00:14:12,079 --> 00:14:15,199
it might look something like this we

00:14:14,560 --> 00:14:17,120
could say

00:14:15,199 --> 00:14:18,560
we have an operator bar which takes two

00:14:17,120 --> 00:14:20,000
ordering functions

00:14:18,560 --> 00:14:21,920
of course you'd want to constrain this

00:14:20,000 --> 00:14:23,920
using concepts or something that you

00:14:21,920 --> 00:14:25,519
know slidewear

00:14:23,920 --> 00:14:27,760
we take two orderings and we compose

00:14:25,519 --> 00:14:32,480
them by returning a new ordering

00:14:27,760 --> 00:14:35,680
this ordering is first gonna call f1

00:14:32,480 --> 00:14:36,720
if one if f1 does have something to say

00:14:35,680 --> 00:14:40,160
about whether a

00:14:36,720 --> 00:14:40,160
is greater than or less than b

00:14:40,320 --> 00:14:45,360
um then we're going to just return that

00:14:43,760 --> 00:14:47,040
this stood weak ordering equivalent

00:14:45,360 --> 00:14:50,959
thing is from the

00:14:47,040 --> 00:14:52,160
spaceship operator and if f1 says that

00:14:50,959 --> 00:14:53,760
they're equivalent then we're going to

00:14:52,160 --> 00:14:56,160
return f2

00:14:53,760 --> 00:14:56,800
so we were first order by f1 then we

00:14:56,160 --> 00:14:58,959
ordered by

00:14:56,800 --> 00:15:01,440
f2 and now we have composed two

00:14:58,959 --> 00:15:01,440
orderings

00:15:01,600 --> 00:15:04,639
it would look something like this in the

00:15:02,959 --> 00:15:06,639
api

00:15:04,639 --> 00:15:08,240
we call max element with sessions and we

00:15:06,639 --> 00:15:09,040
say we have to order by presenter and

00:15:08,240 --> 00:15:12,880
then order by

00:15:09,040 --> 00:15:14,480
title it's kind of a nice api i think um

00:15:12,880 --> 00:15:16,000
we can convince ourselves that this

00:15:14,480 --> 00:15:19,199
actually does form a monoid

00:15:16,000 --> 00:15:21,680
by uh having on our identity

00:15:19,199 --> 00:15:24,079
which is an ordering which always says

00:15:21,680 --> 00:15:25,440
that two things are equivalent

00:15:24,079 --> 00:15:27,519
and then we can further convince

00:15:25,440 --> 00:15:30,079
ourselves by um

00:15:27,519 --> 00:15:31,440
trying to fold this operator and you can

00:15:30,079 --> 00:15:33,680
see this would work you might not want

00:15:31,440 --> 00:15:35,680
to call compose orderings

00:15:33,680 --> 00:15:37,279
but this is the kind of thing where if

00:15:35,680 --> 00:15:37,839
you're looking for composition if you're

00:15:37,279 --> 00:15:40,880
looking

00:15:37,839 --> 00:15:42,240
for monoids then these things come to

00:15:40,880 --> 00:15:43,680
the surface

00:15:42,240 --> 00:15:45,600
if you'd like to learn more about

00:15:43,680 --> 00:15:48,000
monoids i'd highly recommend going

00:15:45,600 --> 00:15:50,240
watching all of ben dean's talks i mean

00:15:48,000 --> 00:15:53,360
i'd recommend doing that in general

00:15:50,240 --> 00:15:56,160
he's albino he's currently in the chat

00:15:53,360 --> 00:15:56,480
uh so say hi to ben he has lots of talks

00:15:56,160 --> 00:15:59,600
on

00:15:56,480 --> 00:16:00,480
one odds and it's generally awesome in

00:15:59,600 --> 00:16:03,120
fact i cripped

00:16:00,480 --> 00:16:04,800
all of this slide from one of his talks

00:16:03,120 --> 00:16:06,720
where this is solenoids which

00:16:04,800 --> 00:16:07,680
turn up in statistics they turn up all

00:16:06,720 --> 00:16:08,639
the time you know you want to

00:16:07,680 --> 00:16:10,639
parallelize

00:16:08,639 --> 00:16:12,079
your statistical analysis if you use

00:16:10,639 --> 00:16:15,440
some of these algorithms

00:16:12,079 --> 00:16:17,440
then you can make the most of that

00:16:15,440 --> 00:16:18,560
i love seeing everyone saying hi to ben

00:16:17,440 --> 00:16:22,560
in the chat this is

00:16:18,560 --> 00:16:25,759
this totally made my day

00:16:22,560 --> 00:16:28,000
okay let's talk about this

00:16:25,759 --> 00:16:29,920
if you oh you're actually at bending on

00:16:28,000 --> 00:16:31,839
twitter i'm sorry you're helping

00:16:29,920 --> 00:16:33,120
other places anyway let's talk about

00:16:31,839 --> 00:16:35,920
this if you're not familiar with

00:16:33,120 --> 00:16:37,839
circuit diagrams then maybe you're more

00:16:35,920 --> 00:16:41,360
familiar with this

00:16:37,839 --> 00:16:43,440
it's uh stood transform or maybe let's

00:16:41,360 --> 00:16:44,639
talk about stood ranges views transform

00:16:43,440 --> 00:16:47,839
instead because you know we love our

00:16:44,639 --> 00:16:51,279
name spaces and civil source 20.

00:16:47,839 --> 00:16:54,000
the idea is this say we have some cats

00:16:51,279 --> 00:16:55,759
and we want some cute cats you know we

00:16:54,000 --> 00:16:57,759
always want cute cats

00:16:55,759 --> 00:16:59,519
so maybe one way we could do this is

00:16:57,759 --> 00:17:01,440
loop over all of our cats

00:16:59,519 --> 00:17:02,560
and call me cute on them and push them

00:17:01,440 --> 00:17:05,199
back into the

00:17:02,560 --> 00:17:07,280
cute cat's vector this is one way we

00:17:05,199 --> 00:17:10,400
could implement this

00:17:07,280 --> 00:17:10,880
another way is we could use transform we

00:17:10,400 --> 00:17:12,959
could

00:17:10,880 --> 00:17:15,120
take our cat's vector and we could pipe

00:17:12,959 --> 00:17:17,839
it into transform

00:17:15,120 --> 00:17:19,280
and give transform make q what this does

00:17:17,839 --> 00:17:21,600
is creates a view

00:17:19,280 --> 00:17:23,199
which we'll call make cute on every one

00:17:21,600 --> 00:17:25,280
of our cats

00:17:23,199 --> 00:17:26,400
and it just kind of expresses our intent

00:17:25,280 --> 00:17:28,720
a bit better right

00:17:26,400 --> 00:17:29,919
like here we have a loop we don't like

00:17:28,720 --> 00:17:33,039
raw loops if you look

00:17:29,919 --> 00:17:34,559
you know listen to sean parents um

00:17:33,039 --> 00:17:36,080
it just expresses our intent a lot

00:17:34,559 --> 00:17:37,520
better we have cats we pipe it into

00:17:36,080 --> 00:17:42,080
transform we'll make them all

00:17:37,520 --> 00:17:44,880
cute great about optionals

00:17:42,080 --> 00:17:45,520
uh if we have an optional cap we could

00:17:44,880 --> 00:17:48,880
check

00:17:45,520 --> 00:17:50,320
if um we have a cat and if we do we call

00:17:48,880 --> 00:17:51,919
me cute on it

00:17:50,320 --> 00:17:54,720
and then we do a bunch of other stuff

00:17:51,919 --> 00:17:58,480
otherwise we're gonna you know exit the

00:17:54,720 --> 00:17:59,760
if statement but we could do a very

00:17:58,480 --> 00:18:03,360
similar thing

00:17:59,760 --> 00:18:05,200
we could pipe c to some transform it

00:18:03,360 --> 00:18:06,240
just doesn't work with stood ranges

00:18:05,200 --> 00:18:09,360
views transform

00:18:06,240 --> 00:18:11,120
and um and stood optional but you could

00:18:09,360 --> 00:18:12,400
implement something like this you pipe c

00:18:11,120 --> 00:18:14,080
to transform make q

00:18:12,400 --> 00:18:16,799
if there was a cat it calls make you

00:18:14,080 --> 00:18:21,120
otherwise you get an empty option

00:18:16,799 --> 00:18:25,120
nope this is this is the same structure

00:18:21,120 --> 00:18:27,039
right another example

00:18:25,120 --> 00:18:28,480
say we want to get a cat but you know

00:18:27,039 --> 00:18:30,960
it's going to take some time

00:18:28,480 --> 00:18:32,160
um maybe we need to go to shelter all

00:18:30,960 --> 00:18:32,960
that stuff we might want to do some

00:18:32,160 --> 00:18:35,840
other things

00:18:32,960 --> 00:18:37,440
while we're waiting on a call back so

00:18:35,840 --> 00:18:38,559
we'll do a bunch of stuff and then maybe

00:18:37,440 --> 00:18:41,360
eventually we

00:18:38,559 --> 00:18:42,080
will call wait and we'll we'll call me

00:18:41,360 --> 00:18:45,440
cute

00:18:42,080 --> 00:18:46,640
on the cat which we got uh

00:18:45,440 --> 00:18:48,480
you know this isn't great we're having

00:18:46,640 --> 00:18:52,000
to wait on our future

00:18:48,480 --> 00:18:53,760
we have to care about um you know when

00:18:52,000 --> 00:18:55,280
we're getting this cat

00:18:53,760 --> 00:18:58,240
all that stuff what we'd really like to

00:18:55,280 --> 00:19:01,600
do is just cue up these operations

00:18:58,240 --> 00:19:02,400
so we could just pipe f into transform

00:19:01,600 --> 00:19:05,440
make cute

00:19:02,400 --> 00:19:06,880
so we say we'll get a cat and at some

00:19:05,440 --> 00:19:08,480
point we'll have the cat and then we'll

00:19:06,880 --> 00:19:10,880
make it cute we don't care

00:19:08,480 --> 00:19:12,559
about when this happens we just care

00:19:10,880 --> 00:19:14,880
about the the library making this

00:19:12,559 --> 00:19:18,160
decision for us we're queuing up

00:19:14,880 --> 00:19:19,679
or composing operations and again this

00:19:18,160 --> 00:19:21,840
is exactly the same structure we've just

00:19:19,679 --> 00:19:24,080
seen

00:19:21,840 --> 00:19:25,840
so if uh accumulate is more like a sonic

00:19:24,080 --> 00:19:28,080
screwdriver

00:19:25,840 --> 00:19:29,120
then transform is more like a drill you

00:19:28,080 --> 00:19:31,919
know we're drilling

00:19:29,120 --> 00:19:33,600
into these contexts to get the values we

00:19:31,919 --> 00:19:34,000
don't care about the structure which is

00:19:33,600 --> 00:19:35,840
built

00:19:34,000 --> 00:19:39,440
up around them we just care about

00:19:35,840 --> 00:19:41,120
changing what's in there

00:19:39,440 --> 00:19:43,440
you can imagine if we implemented this

00:19:41,120 --> 00:19:45,039
as a non-member function

00:19:43,440 --> 00:19:46,480
here's an example of how it could look

00:19:45,039 --> 00:19:47,360
you wouldn't actually implement it like

00:19:46,480 --> 00:19:50,080
this but

00:19:47,360 --> 00:19:52,000
just for demonstration purposes function

00:19:50,080 --> 00:19:54,320
called transform

00:19:52,000 --> 00:19:55,919
which takes some temple of t so this

00:19:54,320 --> 00:19:58,559
could be like stood optional of

00:19:55,919 --> 00:20:00,480
int or stood vector all cool if you

00:19:58,559 --> 00:20:04,400
really wanted

00:20:00,480 --> 00:20:07,679
then it takes a function from t to r

00:20:04,400 --> 00:20:10,799
and returns a temple of r so if we had

00:20:07,679 --> 00:20:12,799
uh stood optional of int

00:20:10,799 --> 00:20:14,640
and then a function from instabules then

00:20:12,799 --> 00:20:17,360
we'd get our stood optional

00:20:14,640 --> 00:20:18,159
bool we're maintaining the template

00:20:17,360 --> 00:20:22,720
argument

00:20:18,159 --> 00:20:22,720
but changing the values at it okay

00:20:22,960 --> 00:20:26,080
other fun other programming languages

00:20:24,960 --> 00:20:29,120
might call it map

00:20:26,080 --> 00:20:29,120
or fmap

00:20:30,000 --> 00:20:34,559
what we have is a container of ts and a

00:20:32,640 --> 00:20:37,840
function which transforms the t's

00:20:34,559 --> 00:20:40,960
inside the container the uh

00:20:37,840 --> 00:20:44,080
container this word is used a lot for

00:20:40,960 --> 00:20:44,880
um for this construct it's not that

00:20:44,080 --> 00:20:47,280
great because you know

00:20:44,880 --> 00:20:48,159
it's a future container of teas it's

00:20:47,280 --> 00:20:50,960
more like

00:20:48,159 --> 00:20:51,679
a computational context you know some

00:20:50,960 --> 00:20:54,080
some t

00:20:51,679 --> 00:20:56,720
along with the context of we're gonna be

00:20:54,080 --> 00:20:59,120
getting this later

00:20:56,720 --> 00:21:02,080
so we could instead say that we have t's

00:20:59,120 --> 00:21:04,000
in some computational context and a

00:21:02,080 --> 00:21:06,880
function which transforms the t's

00:21:04,000 --> 00:21:08,640
while maintaining the context i.e you

00:21:06,880 --> 00:21:10,880
know if you have a vector events

00:21:08,640 --> 00:21:12,080
and you map them to a vector of rules we

00:21:10,880 --> 00:21:14,799
don't want

00:21:12,080 --> 00:21:17,840
the size of the vector to change that

00:21:14,799 --> 00:21:17,840
doesn't make sense

00:21:18,080 --> 00:21:22,480
this is called a functor again turns out

00:21:21,760 --> 00:21:24,880
to be

00:21:22,480 --> 00:21:25,919
a concept which pervades throughout

00:21:24,880 --> 00:21:28,799
computer science

00:21:25,919 --> 00:21:30,880
now i'm not talking about the c plus

00:21:28,799 --> 00:21:33,840
usage of functor which is quite common

00:21:30,880 --> 00:21:36,400
the like function object a structure a

00:21:33,840 --> 00:21:38,240
class which has a call operator

00:21:36,400 --> 00:21:39,840
this is the the term which is used in

00:21:38,240 --> 00:21:42,720
haskell which is

00:21:39,840 --> 00:21:44,400
then taken from category theory there's

00:21:42,720 --> 00:21:47,280
actually an article by jackie k

00:21:44,400 --> 00:21:48,000
from a few years back uh on exactly this

00:21:47,280 --> 00:21:50,080
topic

00:21:48,000 --> 00:21:52,320
stop calling function objects functors

00:21:50,080 --> 00:21:55,360
uh i would recommend going to read that

00:21:52,320 --> 00:21:55,360
it's quite amusing

00:21:55,679 --> 00:21:59,520
along with those there are some functor

00:21:57,760 --> 00:22:01,679
laws which essentially say

00:21:59,520 --> 00:22:04,799
here's how your functor should behave in

00:22:01,679 --> 00:22:08,720
order to not be surprising

00:22:04,799 --> 00:22:11,039
um so i've tried to show these in c plus

00:22:08,720 --> 00:22:12,000
one imagine that we have this id

00:22:11,039 --> 00:22:14,799
function which

00:22:12,000 --> 00:22:17,440
takes some argument and returns it back

00:22:14,799 --> 00:22:20,080
doesn't do any modifications

00:22:17,440 --> 00:22:20,799
one functor law is that if we have some

00:22:20,080 --> 00:22:22,960
functor

00:22:20,799 --> 00:22:24,640
and we transform it using the id

00:22:22,960 --> 00:22:28,320
function we should get the same

00:22:24,640 --> 00:22:29,280
function we had out for example if we

00:22:28,320 --> 00:22:32,000
have a vector

00:22:29,280 --> 00:22:32,559
and we call id on every single element

00:22:32,000 --> 00:22:33,840
then

00:22:32,559 --> 00:22:35,840
this shouldn't change any of the

00:22:33,840 --> 00:22:36,960
elements it should not also change the

00:22:35,840 --> 00:22:40,240
size of our vector

00:22:36,960 --> 00:22:42,080
or anything like that all right

00:22:40,240 --> 00:22:44,159
of course in c plus there's some more

00:22:42,080 --> 00:22:45,840
complexities because

00:22:44,159 --> 00:22:47,919
uh you know the interfaces for these

00:22:45,840 --> 00:22:49,919
things copy and whatnot but

00:22:47,919 --> 00:22:52,720
i hope you get what i'm trying to

00:22:49,919 --> 00:22:52,720
express with this

00:22:52,880 --> 00:22:56,799
similarly the second functor law is that

00:22:55,280 --> 00:22:57,200
if we have a functor and we transform it

00:22:56,799 --> 00:22:59,919
with f

00:22:57,200 --> 00:23:01,120
and we transform it with g then that

00:22:59,919 --> 00:23:03,440
should be the same

00:23:01,120 --> 00:23:04,960
as transforming it with the composition

00:23:03,440 --> 00:23:08,400
of f and g

00:23:04,960 --> 00:23:10,720
the um the intuition here is that

00:23:08,400 --> 00:23:12,240
you know having a vector which we loop

00:23:10,720 --> 00:23:14,480
over once to call

00:23:12,240 --> 00:23:16,080
f on everything and then loop over again

00:23:14,480 --> 00:23:17,840
to call g on everything should be the

00:23:16,080 --> 00:23:18,080
same as just having one loop which calls

00:23:17,840 --> 00:23:22,240
f

00:23:18,080 --> 00:23:23,919
and g it shouldn't make a difference

00:23:22,240 --> 00:23:25,600
all right so if you have types you're

00:23:23,919 --> 00:23:27,840
manipulating the structure of

00:23:25,600 --> 00:23:30,400
just change the values then you may be

00:23:27,840 --> 00:23:32,159
able to expose a functor

00:23:30,400 --> 00:23:34,080
and doing that allows you to abstract

00:23:32,159 --> 00:23:38,320
away the handling of the context

00:23:34,080 --> 00:23:38,320
and write code at the level of intent

00:23:39,200 --> 00:23:44,480
in fact looking back to 1994 where the

00:23:42,480 --> 00:23:46,320
standard template library this is from a

00:23:44,480 --> 00:23:50,880
presentation to the

00:23:46,320 --> 00:23:51,840
standards committee um iterators were

00:23:50,880 --> 00:23:55,440
one of the main

00:23:51,840 --> 00:23:56,640
concepts which really made the standard

00:23:55,440 --> 00:23:59,679
template library what

00:23:56,640 --> 00:24:00,320
is and iterators kind of go some of the

00:23:59,679 --> 00:24:03,440
way

00:24:00,320 --> 00:24:06,720
to exposing functors in c

00:24:03,440 --> 00:24:08,320
plus plus to the extent that some ranges

00:24:06,720 --> 00:24:10,799
or at least most ranges in c

00:24:08,320 --> 00:24:11,840
plus are functions right if we have some

00:24:10,799 --> 00:24:14,799
input range

00:24:11,840 --> 00:24:16,000
then we can transform it so one like

00:24:14,799 --> 00:24:19,120
very specific

00:24:16,000 --> 00:24:20,960
call to action i can have is

00:24:19,120 --> 00:24:22,159
look at your types think is this type a

00:24:20,960 --> 00:24:26,080
range

00:24:22,159 --> 00:24:29,360
like does it have um some like operator

00:24:26,080 --> 00:24:31,120
bra square braces uh

00:24:29,360 --> 00:24:34,400
should i instead express this as

00:24:31,120 --> 00:24:36,559
iterators so i can easily transform it

00:24:34,400 --> 00:24:38,080
does it expose anything which is a range

00:24:36,559 --> 00:24:41,279
do i have a function like

00:24:38,080 --> 00:24:45,520
get nth child which takes an index

00:24:41,279 --> 00:24:48,080
should i instead expose a children range

00:24:45,520 --> 00:24:49,520
which you could then transform if this

00:24:48,080 --> 00:24:53,279
thing is non-const

00:24:49,520 --> 00:24:54,880
things like that so think about

00:24:53,279 --> 00:24:56,080
whether you have ranges in your types

00:24:54,880 --> 00:24:57,840
because you might be able to expose

00:24:56,080 --> 00:25:00,559
functors

00:24:57,840 --> 00:25:01,120
all right let's talk about stood ranges

00:25:00,559 --> 00:25:05,440
views

00:25:01,120 --> 00:25:08,159
join say we have two functions

00:25:05,440 --> 00:25:10,080
a function which takes a cat picture and

00:25:08,159 --> 00:25:12,640
makes the cat smaller

00:25:10,080 --> 00:25:14,320
which obviously makes it cuter then we

00:25:12,640 --> 00:25:15,760
have a function which makes cat's eye

00:25:14,320 --> 00:25:17,919
sparkle

00:25:15,760 --> 00:25:18,880
but this might fail you know the cat

00:25:17,919 --> 00:25:20,400
might

00:25:18,880 --> 00:25:21,760
like have its back turned to us or

00:25:20,400 --> 00:25:23,200
something we might not be able to see

00:25:21,760 --> 00:25:25,039
its eyes so we're gonna return an

00:25:23,200 --> 00:25:27,600
optional cat picture and if we can't

00:25:25,039 --> 00:25:32,000
make it size sparkle we're gonna return

00:25:27,600 --> 00:25:33,919
a lot and say we have a maybe cat

00:25:32,000 --> 00:25:36,240
what we'd like to do is say something

00:25:33,919 --> 00:25:38,240
like okay take our baby cat

00:25:36,240 --> 00:25:41,840
transform it by making its eye sparkle

00:25:38,240 --> 00:25:43,440
and then transform it by making it

00:25:41,840 --> 00:25:46,159
know this kind of expresses our intent

00:25:43,440 --> 00:25:48,159
but the problem is we have

00:25:46,159 --> 00:25:50,159
this make eye sparkle is returning an

00:25:48,159 --> 00:25:52,240
optional cat pic

00:25:50,159 --> 00:25:54,080
so what we then get is an optional

00:25:52,240 --> 00:25:54,799
optional cat pick which we're passing

00:25:54,080 --> 00:25:57,520
around

00:25:54,799 --> 00:25:59,200
so this won't compile and it becomes a

00:25:57,520 --> 00:26:02,240
mess

00:25:59,200 --> 00:26:06,159
what we can do to fix that is use

00:26:02,240 --> 00:26:08,080
a join a join will take

00:26:06,159 --> 00:26:09,840
in ranges terms at least a range of

00:26:08,080 --> 00:26:11,440
ranges and collapse it into a single

00:26:09,840 --> 00:26:13,440
range so if you have like a vector of

00:26:11,440 --> 00:26:15,200
vectors it will collapse it all together

00:26:13,440 --> 00:26:16,559
and you can imagine how you would do a

00:26:15,200 --> 00:26:18,159
similar thing for

00:26:16,559 --> 00:26:20,240
stood optional if you have an optional

00:26:18,159 --> 00:26:21,679
of optionals then as long as both of

00:26:20,240 --> 00:26:22,880
those are engaged you'll get something

00:26:21,679 --> 00:26:24,320
at the end and if

00:26:22,880 --> 00:26:26,799
either of them are not then you'll get

00:26:24,320 --> 00:26:28,480
null upped so it's a join operation on

00:26:26,799 --> 00:26:30,880
your optionals

00:26:28,480 --> 00:26:32,360
this is fine but you can imagine that as

00:26:30,880 --> 00:26:34,480
soon as you start adding more

00:26:32,360 --> 00:26:36,400
transformations then we just have to

00:26:34,480 --> 00:26:38,880
pepper join

00:26:36,400 --> 00:26:39,600
all over the place we could instead have

00:26:38,880 --> 00:26:43,120
some function

00:26:39,600 --> 00:26:44,640
called and then or uh other languages

00:26:43,120 --> 00:26:48,480
might call this bind

00:26:44,640 --> 00:26:53,600
which does a transform and then a join

00:26:48,480 --> 00:26:56,080
in one call makes sense

00:26:53,600 --> 00:26:57,520
this is the code um which we would write

00:26:56,080 --> 00:26:59,360
if we weren't using

00:26:57,520 --> 00:27:00,799
transform and then by the way you know

00:26:59,360 --> 00:27:02,960
we check if we have a cat

00:27:00,799 --> 00:27:04,559
and we call make eye spark and we check

00:27:02,960 --> 00:27:04,799
we have a cat and we call our top hat

00:27:04,559 --> 00:27:06,799
and

00:27:04,799 --> 00:27:08,799
check we have a cat and comic smaller

00:27:06,799 --> 00:27:10,799
and it's we're having to handle the

00:27:08,799 --> 00:27:12,640
context ourselves

00:27:10,799 --> 00:27:14,799
we're having to deal with all of this

00:27:12,640 --> 00:27:20,080
unpacking whereas we should be focusing

00:27:14,799 --> 00:27:22,880
on that work we need to get done

00:27:20,080 --> 00:27:24,320
futures say we have a cat and we want to

00:27:22,880 --> 00:27:25,279
pat its head and we want to scratch its

00:27:24,320 --> 00:27:26,559
belly

00:27:25,279 --> 00:27:28,720
now these are things we might want to do

00:27:26,559 --> 00:27:32,640
but they also take time you know

00:27:28,720 --> 00:27:34,960
my cat at least likes head past take

00:27:32,640 --> 00:27:36,080
30 seconds a few minutes so we might

00:27:34,960 --> 00:27:38,240
want to do other things might want to

00:27:36,080 --> 00:27:40,640
drink some tea or

00:27:38,240 --> 00:27:41,360
look at twitter maybe make some terrible

00:27:40,640 --> 00:27:44,320
tweets

00:27:41,360 --> 00:27:45,039
i don't know but say we have a good boy

00:27:44,320 --> 00:27:48,480
then

00:27:45,039 --> 00:27:50,960
we could pat his head then say then we

00:27:48,480 --> 00:27:52,640
want to scratch his belly

00:27:50,960 --> 00:27:54,240
we don't want to care about unpacking

00:27:52,640 --> 00:27:55,840
the future we don't care about when this

00:27:54,240 --> 00:27:57,440
happens we just have its head and we

00:27:55,840 --> 00:27:59,039
scratch the belly we want to cue up

00:27:57,440 --> 00:28:00,399
these operations we don't care about

00:27:59,039 --> 00:28:02,320
context we care

00:28:00,399 --> 00:28:05,919
about the values which are going through

00:28:02,320 --> 00:28:05,919
and the transformations on those values

00:28:06,080 --> 00:28:10,159
another example where this kind of

00:28:07,600 --> 00:28:12,240
pattern turns up is parsers

00:28:10,159 --> 00:28:13,919
now you've heard a parser for things as

00:28:12,240 --> 00:28:16,399
a function from strings to lists of

00:28:13,919 --> 00:28:18,080
pairs of things and strings this might

00:28:16,399 --> 00:28:19,840
not immediately look like a definition

00:28:18,080 --> 00:28:22,480
of parser because

00:28:19,840 --> 00:28:24,640
in especially in c plus we quite often

00:28:22,480 --> 00:28:26,960
use more imperatively styled

00:28:24,640 --> 00:28:28,720
parser implementations but this is a way

00:28:26,960 --> 00:28:30,000
you can build up parsers using

00:28:28,720 --> 00:28:33,200
functional languages

00:28:30,000 --> 00:28:35,120
it looks something like this say we

00:28:33,200 --> 00:28:36,399
want to build a parser which matches a

00:28:35,120 --> 00:28:38,720
character

00:28:36,399 --> 00:28:40,640
then we could return a function which

00:28:38,720 --> 00:28:42,799
takes some string as input

00:28:40,640 --> 00:28:44,640
and then it's going to return all of the

00:28:42,799 --> 00:28:46,399
possible ways we could parse

00:28:44,640 --> 00:28:49,520
this character which is only gonna be

00:28:46,399 --> 00:28:51,039
one so we check if the input is empty

00:28:49,520 --> 00:28:52,799
and we make sure that the first

00:28:51,039 --> 00:28:55,200
character is the one we want if it's not

00:28:52,799 --> 00:28:57,360
we're going to return an empty list

00:28:55,200 --> 00:28:59,120
if we did match the character then we

00:28:57,360 --> 00:29:02,559
return the character we matched

00:28:59,120 --> 00:29:04,000
along with the um the part of the input

00:29:02,559 --> 00:29:05,679
we did not use

00:29:04,000 --> 00:29:07,279
all right obviously you wouldn't

00:29:05,679 --> 00:29:10,480
implement this this way

00:29:07,279 --> 00:29:13,520
with stood list and everything just for

00:29:10,480 --> 00:29:14,799
demonstration purposes and then you

00:29:13,520 --> 00:29:15,600
could use it like this you have some

00:29:14,799 --> 00:29:17,200
input

00:29:15,600 --> 00:29:18,720
which says hello and you can build a

00:29:17,200 --> 00:29:21,760
parcel which says i want to match

00:29:18,720 --> 00:29:23,039
h then we can assert that if we call our

00:29:21,760 --> 00:29:26,080
parser on our input

00:29:23,039 --> 00:29:28,720
then we're going to um

00:29:26,080 --> 00:29:29,679
have h as the thing we parsed and ello

00:29:28,720 --> 00:29:32,480
is going to be

00:29:29,679 --> 00:29:34,720
the the rest which we did not consume

00:29:32,480 --> 00:29:37,600
this isn't very useful on its own

00:29:34,720 --> 00:29:39,520
but we can the real interesting stuff

00:29:37,600 --> 00:29:41,360
happens when we start to compose these

00:29:39,520 --> 00:29:43,840
operations

00:29:41,360 --> 00:29:44,720
so as a silly example we could build a

00:29:43,840 --> 00:29:48,320
parser for

00:29:44,720 --> 00:29:50,720
true or false by first matching t or f

00:29:48,320 --> 00:29:51,919
and then checking if we got t in which

00:29:50,720 --> 00:29:55,039
case matching rou

00:29:51,919 --> 00:29:56,720
otherwise matching false okay so that

00:29:55,039 --> 00:29:57,919
you can see we're taking the input from

00:29:56,720 --> 00:29:59,919
one parser

00:29:57,919 --> 00:30:01,840
and we're piping it into the other

00:29:59,919 --> 00:30:02,960
person we're not having to deal with any

00:30:01,840 --> 00:30:05,200
of the additional

00:30:02,960 --> 00:30:06,559
context of like the things that we

00:30:05,200 --> 00:30:08,240
haven't parsed

00:30:06,559 --> 00:30:11,520
all of that it's all handled by the

00:30:08,240 --> 00:30:11,520
implementation of and then

00:30:12,320 --> 00:30:15,440
in fact there's another talk from ben

00:30:14,640 --> 00:30:17,440
dean uh

00:30:15,440 --> 00:30:18,559
and jason turner called constance for

00:30:17,440 --> 00:30:20,399
all the things where

00:30:18,559 --> 00:30:22,480
they use exactly these techniques for

00:30:20,399 --> 00:30:24,000
building up a json parser at compile

00:30:22,480 --> 00:30:26,080
time

00:30:24,000 --> 00:30:28,240
so this is an example which they had

00:30:26,080 --> 00:30:29,679
which i modified very slightly

00:30:28,240 --> 00:30:30,799
i don't want to get into the details of

00:30:29,679 --> 00:30:32,640
it i just want to show that you can

00:30:30,799 --> 00:30:33,760
build up complex parsers using these

00:30:32,640 --> 00:30:36,799
kinds of interfaces

00:30:33,760 --> 00:30:39,919
this one for example first checks for

00:30:36,799 --> 00:30:41,919
a one to nine character and then for

00:30:39,919 --> 00:30:43,840
a sequence of zero to nine and it builds

00:30:41,919 --> 00:30:46,159
up an integer representation as it goes

00:30:43,840 --> 00:30:46,159
along

00:30:47,039 --> 00:30:50,640
so transform is more like a drill then

00:30:49,200 --> 00:30:54,080
and then is more like a

00:30:50,640 --> 00:30:57,679
pipe with some duct tape you know we can

00:30:54,080 --> 00:30:58,399
take functions whose return types don't

00:30:57,679 --> 00:31:00,159
quite match

00:30:58,399 --> 00:31:02,159
because they have some extra contacts to

00:31:00,159 --> 00:31:04,000
deal with and we can just

00:31:02,159 --> 00:31:05,600
duct tape them together to really focus

00:31:04,000 --> 00:31:07,440
on the values which are flowing through

00:31:05,600 --> 00:31:10,159
the functions and not have to focus on

00:31:07,440 --> 00:31:10,159
the context

00:31:10,480 --> 00:31:13,519
so we have some t's in a computational

00:31:12,559 --> 00:31:15,279
context

00:31:13,519 --> 00:31:16,640
and we have a function which composes

00:31:15,279 --> 00:31:19,519
operations

00:31:16,640 --> 00:31:21,760
producing that context this is called a

00:31:19,519 --> 00:31:23,039
monad

00:31:21,760 --> 00:31:25,679
now i'd like to take some time to

00:31:23,039 --> 00:31:26,799
contractually myself because this is one

00:31:25,679 --> 00:31:29,519
of the few c

00:31:26,799 --> 00:31:30,240
plus talks where i have not made any of

00:31:29,519 --> 00:31:33,279
the obvious

00:31:30,240 --> 00:31:35,360
monad jokes so please drop

00:31:33,279 --> 00:31:38,159
your congratulations in the chat window

00:31:35,360 --> 00:31:40,399
thank you very much

00:31:38,159 --> 00:31:42,080
of course there are also a bunch of laws

00:31:40,399 --> 00:31:42,559
which say here's how your monad should

00:31:42,080 --> 00:31:44,720
behave

00:31:42,559 --> 00:31:46,320
in order for it not to be surprising so

00:31:44,720 --> 00:31:48,559
i ported all of these to c

00:31:46,320 --> 00:31:49,840
plus and i plan to talk about them a

00:31:48,559 --> 00:31:51,200
bunch and then i realized it was really

00:31:49,840 --> 00:31:52,880
confusing and boring

00:31:51,200 --> 00:31:55,440
so i'm not going to do that uh if you

00:31:52,880 --> 00:31:57,840
want to learn more about monad laws

00:31:55,440 --> 00:32:00,159
come talk to me later look them up

00:31:57,840 --> 00:32:02,159
somewhere that isn't wikipedia

00:32:00,159 --> 00:32:03,200
you know so if you're manually

00:32:02,159 --> 00:32:05,120
marshaling data

00:32:03,200 --> 00:32:08,159
in and out of context to manipulate them

00:32:05,120 --> 00:32:10,000
you may be able to expose a monad

00:32:08,159 --> 00:32:11,600
and that similarly to functions allows

00:32:10,000 --> 00:32:13,200
you to abstract away the handling of the

00:32:11,600 --> 00:32:16,399
context and write code

00:32:13,200 --> 00:32:16,399
at the level of intent

00:32:16,720 --> 00:32:24,399
so one area which bonus pop-up which you

00:32:20,720 --> 00:32:24,399
might not think about is co routines

00:32:24,480 --> 00:32:29,679
here is an example which i stole from

00:32:27,679 --> 00:32:31,840
one of goronishnov's talks from five

00:32:29,679 --> 00:32:34,880
years ago now

00:32:31,840 --> 00:32:35,279
this is a tcp reader function so it

00:32:34,880 --> 00:32:38,320
takes

00:32:35,279 --> 00:32:39,120
it creates some tcp connection and it

00:32:38,320 --> 00:32:41,440
then

00:32:39,120 --> 00:32:42,640
loops over the tcp connection reading a

00:32:41,440 --> 00:32:46,240
set amount of data

00:32:42,640 --> 00:32:47,120
until we're done now this is a

00:32:46,240 --> 00:32:50,080
synchronous

00:32:47,120 --> 00:32:51,120
function connecting to tcp socket might

00:32:50,080 --> 00:32:53,440
take some time

00:32:51,120 --> 00:32:54,640
reading from a tcp p socket might take

00:32:53,440 --> 00:32:57,600
some time

00:32:54,640 --> 00:32:58,960
we might want this to be asynchronous so

00:32:57,600 --> 00:33:01,919
we can transform

00:32:58,960 --> 00:33:04,159
this code into an asynchronous version

00:33:01,919 --> 00:33:08,960
by doing something like this

00:33:04,159 --> 00:33:11,919
oops this there we go ah

00:33:08,960 --> 00:33:12,399
there we go don't try and read this code

00:33:11,919 --> 00:33:14,240
um

00:33:12,399 --> 00:33:16,080
my point is it looks horrible we're

00:33:14,240 --> 00:33:18,000
having to like dynamically allocate some

00:33:16,080 --> 00:33:20,320
state we're having to have multiple

00:33:18,000 --> 00:33:21,360
nested lambdas which are parsing stuff

00:33:20,320 --> 00:33:23,360
between them

00:33:21,360 --> 00:33:25,200
and this is using that like and then

00:33:23,360 --> 00:33:27,120
magnatic style

00:33:25,200 --> 00:33:28,320
which works really well sometimes and

00:33:27,120 --> 00:33:31,200
does not work well

00:33:28,320 --> 00:33:34,240
here um because it's really turning all

00:33:31,200 --> 00:33:35,919
of the control flow inside out and

00:33:34,240 --> 00:33:37,760
it's it's a pain i don't want to write

00:33:35,919 --> 00:33:38,399
this code i don't know anyone who would

00:33:37,760 --> 00:33:41,360
choose

00:33:38,399 --> 00:33:41,360
to write this code

00:33:41,919 --> 00:33:46,480
well if instead we could change our

00:33:45,120 --> 00:33:50,960
synchronous version

00:33:46,480 --> 00:33:54,320
into an asynchronous version just by

00:33:50,960 --> 00:33:56,640
decorating our code this is what co

00:33:54,320 --> 00:33:59,039
routines allow us to do

00:33:56,640 --> 00:34:00,880
we write in co-await and that's going to

00:33:59,039 --> 00:34:04,240
suspend the core routine

00:34:00,880 --> 00:34:07,840
until we get our data

00:34:04,240 --> 00:34:10,399
we then change the return type to

00:34:07,840 --> 00:34:11,919
it could be a task or some future which

00:34:10,399 --> 00:34:14,720
supports core routines

00:34:11,919 --> 00:34:16,720
and now we've taken our synchronous code

00:34:14,720 --> 00:34:19,440
and we transformed it into asynchronous

00:34:16,720 --> 00:34:21,760
code purely by decorating

00:34:19,440 --> 00:34:22,639
the the synchronous version so what

00:34:21,760 --> 00:34:25,919
we've done

00:34:22,639 --> 00:34:28,000
is we focused in on all the operations

00:34:25,919 --> 00:34:30,399
which we wanted to perform all of the

00:34:28,000 --> 00:34:32,879
data flowing through these operations

00:34:30,399 --> 00:34:34,879
and we've pushed all the handling the

00:34:32,879 --> 00:34:37,280
context aside

00:34:34,879 --> 00:34:39,760
so co routines in c plus plus 20 are a

00:34:37,280 --> 00:34:43,200
way of exploiting the magnetic nature

00:34:39,760 --> 00:34:46,399
of asynchronous programming

00:34:43,200 --> 00:34:47,200
which is kind of cool uh it turns out

00:34:46,399 --> 00:34:49,200
that they're

00:34:47,200 --> 00:34:50,639
even more general than you might expect

00:34:49,200 --> 00:34:52,240
and the uh

00:34:50,639 --> 00:34:53,679
you know if we have some functions which

00:34:52,240 --> 00:34:56,079
return optionals

00:34:53,679 --> 00:34:58,240
this is some code i told still from toby

00:34:56,079 --> 00:35:01,280
alsop

00:34:58,240 --> 00:35:02,240
then we could implement some co-routine

00:35:01,280 --> 00:35:05,680
handler

00:35:02,240 --> 00:35:08,000
which works with optionals and then

00:35:05,680 --> 00:35:09,680
we could write code like this and we

00:35:08,000 --> 00:35:13,440
co-weight on f1

00:35:09,680 --> 00:35:15,119
we call f2 we call f3 if any of these

00:35:13,440 --> 00:35:18,320
functions return

00:35:15,119 --> 00:35:19,280
a null opt then we're going to exit out

00:35:18,320 --> 00:35:22,720
of the core routine

00:35:19,280 --> 00:35:25,200
and return to the caller so this is the

00:35:22,720 --> 00:35:28,160
same kind of thing as if we were piping

00:35:25,200 --> 00:35:28,960
like and then all the way down this but

00:35:28,160 --> 00:35:31,520
it's just

00:35:28,960 --> 00:35:32,240
implemented in co routines it's kind of

00:35:31,520 --> 00:35:35,280
cool

00:35:32,240 --> 00:35:37,200
um so this might look

00:35:35,280 --> 00:35:38,320
like do notation in haskell if you're

00:35:37,200 --> 00:35:41,440
familiar with it

00:35:38,320 --> 00:35:42,880
um in haskell do notation is essentially

00:35:41,440 --> 00:35:45,520
syntactic sugar for

00:35:42,880 --> 00:35:46,480
transforming uh what looks like straight

00:35:45,520 --> 00:35:49,520
line code

00:35:46,480 --> 00:35:52,079
into um a bunch of lambdas with

00:35:49,520 --> 00:35:53,599
binds between them core routines get you

00:35:52,079 --> 00:35:56,800
some of the way there it's not

00:35:53,599 --> 00:35:58,800
quite there though like this core

00:35:56,800 --> 00:35:59,680
routine will get split up into multiple

00:35:58,800 --> 00:36:02,240
functions

00:35:59,680 --> 00:36:03,839
on each of those co-weight boundaries

00:36:02,240 --> 00:36:06,720
but the coroutine

00:36:03,839 --> 00:36:09,040
um implementation doesn't give you a way

00:36:06,720 --> 00:36:09,680
to get at those functions you couldn't

00:36:09,040 --> 00:36:11,920
like

00:36:09,680 --> 00:36:13,119
run part of a core routine multiple

00:36:11,920 --> 00:36:17,359
times

00:36:13,119 --> 00:36:17,359
which is required for for some lone ads

00:36:17,520 --> 00:36:23,119
so co routines do allow you to um

00:36:20,720 --> 00:36:24,320
to implement some to exploit some

00:36:23,119 --> 00:36:26,880
monetic structures

00:36:24,320 --> 00:36:29,119
mostly for asynchronous programming and

00:36:26,880 --> 00:36:31,359
also for doing this kind of thing

00:36:29,119 --> 00:36:32,320
if you want to i wouldn't recommend

00:36:31,359 --> 00:36:34,400
doing this it's just

00:36:32,320 --> 00:36:36,160
it's kind of an interesting thing which

00:36:34,400 --> 00:36:38,800
falls out of the implementation of

00:36:36,160 --> 00:36:38,800
co-routines

00:36:38,960 --> 00:36:45,119
another is static exceptions

00:36:42,160 --> 00:36:46,240
or herb sections this is a proposal from

00:36:45,119 --> 00:36:49,520
herb sutter

00:36:46,240 --> 00:36:50,079
which um tries to deal with a lot of the

00:36:49,520 --> 00:36:54,480
pro

00:36:50,079 --> 00:36:57,440
problems of dynamic exceptions here's a

00:36:54,480 --> 00:36:58,800
example i stole from the paper we have a

00:36:57,440 --> 00:37:00,640
convert function which is going to

00:36:58,800 --> 00:37:02,560
convert a string to an integer

00:37:00,640 --> 00:37:04,480
and then we have something which calls

00:37:02,560 --> 00:37:07,520
that and multiplies it by

00:37:04,480 --> 00:37:08,160
some other end so we have this

00:37:07,520 --> 00:37:11,440
decoration

00:37:08,160 --> 00:37:13,200
throws this is not a dynamic

00:37:11,440 --> 00:37:14,480
exception specifier this is very very

00:37:13,200 --> 00:37:17,280
different

00:37:14,480 --> 00:37:18,800
what this throws keyword does is it says

00:37:17,280 --> 00:37:19,520
actually i'm not a function which

00:37:18,800 --> 00:37:22,000
returns an

00:37:19,520 --> 00:37:23,040
int i'm actually a function which

00:37:22,000 --> 00:37:26,320
returns

00:37:23,040 --> 00:37:29,599
like a union of an int and some

00:37:26,320 --> 00:37:32,640
statically known error type or

00:37:29,599 --> 00:37:34,640
um a variant of int error or

00:37:32,640 --> 00:37:35,680
stood expected of int error if you're

00:37:34,640 --> 00:37:37,920
familiar with that

00:37:35,680 --> 00:37:39,119
or result from rust it's the same kind

00:37:37,920 --> 00:37:41,200
of thing

00:37:39,119 --> 00:37:42,960
and then when we say throw inside a

00:37:41,200 --> 00:37:43,359
function like this what we're not saying

00:37:42,960 --> 00:37:45,760
is

00:37:43,359 --> 00:37:47,760
dynamically allocate this and then you

00:37:45,760 --> 00:37:48,640
know unwind the stack and find a call

00:37:47,760 --> 00:37:50,880
hand

00:37:48,640 --> 00:37:52,400
catch handler and all that nonsense now

00:37:50,880 --> 00:37:55,440
this just means

00:37:52,400 --> 00:37:58,480
okay we're going to return the

00:37:55,440 --> 00:38:02,960
variant type engaged to the error state

00:37:58,480 --> 00:38:06,079
all right then when we call convert

00:38:02,960 --> 00:38:07,280
if we get an integer out at e convert

00:38:06,079 --> 00:38:08,400
return normally

00:38:07,280 --> 00:38:10,480
then it's all great we're going to

00:38:08,400 --> 00:38:14,480
continue as we went along

00:38:10,480 --> 00:38:18,560
if the convert function through

00:38:14,480 --> 00:38:21,440
as in it returned the um the error type

00:38:18,560 --> 00:38:22,560
then stir multiply itself is also going

00:38:21,440 --> 00:38:26,560
to return

00:38:22,560 --> 00:38:28,640
the error type and percolate it upwards

00:38:26,560 --> 00:38:30,720
so it's very similar to dynamic

00:38:28,640 --> 00:38:32,000
exceptions but it can eliminate a lot of

00:38:30,720 --> 00:38:35,920
the overhead because the error

00:38:32,000 --> 00:38:37,680
type is known at compile time

00:38:35,920 --> 00:38:39,520
and you might notice this is very

00:38:37,680 --> 00:38:41,520
similar

00:38:39,520 --> 00:38:43,280
in fact what we're doing is focusing in

00:38:41,520 --> 00:38:44,400
on the data which is flowing through

00:38:43,280 --> 00:38:46,480
these functions

00:38:44,400 --> 00:38:48,320
and we're passing the handling of the

00:38:46,480 --> 00:38:50,960
error context aside into the

00:38:48,320 --> 00:38:52,640
implementation

00:38:50,960 --> 00:38:54,480
so static exceptions are a way of

00:38:52,640 --> 00:38:56,960
exploiting the magic nature of error

00:38:54,480 --> 00:38:56,960
handling

00:38:57,520 --> 00:39:01,040
turns out monads are everywhere it's

00:38:58,800 --> 00:39:04,880
kind of cool so this is

00:39:01,040 --> 00:39:06,400
um a proposed paper which

00:39:04,880 --> 00:39:08,000
the committee is currently looking at

00:39:06,400 --> 00:39:09,440
isn't standard yet i can see chat

00:39:08,000 --> 00:39:13,119
talking about this

00:39:09,440 --> 00:39:15,440
so yeah go read the paper

00:39:13,119 --> 00:39:18,000
it's really really interesting um i'm

00:39:15,440 --> 00:39:20,560
particularly a huge fan of it because

00:39:18,000 --> 00:39:21,920
it really lets you express clearly your

00:39:20,560 --> 00:39:22,800
intentions we just want to write our

00:39:21,920 --> 00:39:24,960
good code

00:39:22,800 --> 00:39:26,400
we don't want to focus on percolating

00:39:24,960 --> 00:39:29,680
things and we also don't want to pay

00:39:26,400 --> 00:39:32,400
for dynamic exceptions

00:39:29,680 --> 00:39:32,880
we could of course transform this code

00:39:32,400 --> 00:39:34,960
into

00:39:32,880 --> 00:39:36,320
normal c plus plus or at least something

00:39:34,960 --> 00:39:39,280
which is functionally equivalent

00:39:36,320 --> 00:39:40,960
by if we change our return type to an

00:39:39,280 --> 00:39:43,359
expected int and error

00:39:40,960 --> 00:39:45,680
and then instead of throw we return an

00:39:43,359 --> 00:39:48,480
unexpected

00:39:45,680 --> 00:39:48,720
then we flip the stir multiply to return

00:39:48,480 --> 00:39:50,640
an

00:39:48,720 --> 00:39:52,400
error as well then the last change we

00:39:50,640 --> 00:39:55,520
need to make is

00:39:52,400 --> 00:39:56,640
we pipe convert into transform it's the

00:39:55,520 --> 00:39:58,560
same kind of thing

00:39:56,640 --> 00:39:59,760
and you could see that if stir multiply

00:39:58,560 --> 00:40:02,480
was doing something else which

00:39:59,760 --> 00:40:04,720
could it could itself fail then we'd use

00:40:02,480 --> 00:40:07,760
and then instead of transform

00:40:04,720 --> 00:40:11,280
so this is a simple transformation

00:40:07,760 --> 00:40:15,440
of um our cbox plus code is just

00:40:11,280 --> 00:40:15,440
really surfacing our intent a lot better

00:40:16,720 --> 00:40:19,920
so look out for monoids functors and

00:40:19,280 --> 00:40:24,400
monads

00:40:19,920 --> 00:40:27,440
in your code expose them in your api

00:40:24,400 --> 00:40:29,839
this allows you to both make the

00:40:27,440 --> 00:40:31,200
the client code clearly express

00:40:29,839 --> 00:40:35,119
composition

00:40:31,200 --> 00:40:38,640
and write code at the level of intent

00:40:35,119 --> 00:40:40,319
thank you very much i finish off i will

00:40:38,640 --> 00:40:43,440
take questions so please uh

00:40:40,319 --> 00:40:45,680
type them in and uh i'll

00:40:43,440 --> 00:40:46,560
quickly tell you about our other talks

00:40:45,680 --> 00:40:48,319
we have

00:40:46,560 --> 00:40:50,319
while you're all formulating your

00:40:48,319 --> 00:40:51,920
questions so

00:40:50,319 --> 00:40:54,880
like i said we do have a table in our

00:40:51,920 --> 00:40:56,480
expo hall please come say hi

00:40:54,880 --> 00:40:59,280
we do also have our survey where you can

00:40:56,480 --> 00:41:00,800
win flight simulator

00:40:59,280 --> 00:41:03,040
and these are some of the other sessions

00:41:00,800 --> 00:41:05,200
we had whereas yesterday

00:41:03,040 --> 00:41:07,119
uh myself and marion talks about all the

00:41:05,200 --> 00:41:08,800
new stuff in visual studio and julia

00:41:07,119 --> 00:41:11,280
talked about vs code

00:41:08,800 --> 00:41:13,920
we had some cool announcements like cpus

00:41:11,280 --> 00:41:16,800
plus 20 co routines and modules are

00:41:13,920 --> 00:41:18,800
um are all feature complete uh visual

00:41:16,800 --> 00:41:22,079
studio code cbs plus

00:41:18,800 --> 00:41:24,160
is uh 1.0 which is great

00:41:22,079 --> 00:41:25,359
uh we have talks about static analysis

00:41:24,160 --> 00:41:28,240
stl today

00:41:25,359 --> 00:41:30,240
tomorrow i have another talk on dynamic

00:41:28,240 --> 00:41:31,599
polymorphism with magic classes and code

00:41:30,240 --> 00:41:33,200
injection which

00:41:31,599 --> 00:41:35,200
uh i really like this talk it should be

00:41:33,200 --> 00:41:38,319
great and then we have talks from

00:41:35,200 --> 00:41:40,160
erica and nick about cross-platform dev

00:41:38,319 --> 00:41:43,520
and code spaces and finally finishing

00:41:40,160 --> 00:41:47,359
off with um open source fuzzing

00:41:43,520 --> 00:41:50,800
i am not seeing any questions

00:41:47,359 --> 00:41:52,880
in the chat or q a

00:41:50,800 --> 00:41:54,319
so i will assume that i was perfectly

00:41:52,880 --> 00:41:56,560
clear in everything but if i was not

00:41:54,319 --> 00:41:59,839
please come talk to me i have a q a

00:41:56,560 --> 00:42:02,160
the ask me anything session which is on

00:41:59,839 --> 00:42:04,400
wednesday tomorrow after my dynamic

00:42:02,160 --> 00:42:06,800
polymorphism talk so feel free to come

00:42:04,400 --> 00:42:07,520
chat to me then and thank you very much

00:42:06,800 --> 00:42:11,040
for listening

00:42:07,520 --> 00:42:12,079
goodbye oh there are questions oh

00:42:11,040 --> 00:42:14,480
now i'm seeing the questions why did

00:42:12,079 --> 00:42:16,800
these not pop up before jesus okay

00:42:14,480 --> 00:42:18,319
right uh questions sorry do we need

00:42:16,800 --> 00:42:19,839
different overloads of the pipe operator

00:42:18,319 --> 00:42:21,040
to compose different types of functions

00:42:19,839 --> 00:42:25,359
differently

00:42:21,040 --> 00:42:28,160
uh yes so the the definition of and then

00:42:25,359 --> 00:42:30,000
is very much tied to what your type is

00:42:28,160 --> 00:42:33,440
so you know for

00:42:30,000 --> 00:42:35,359
optional it's gonna um

00:42:33,440 --> 00:42:36,720
it's gonna check if you have an optional

00:42:35,359 --> 00:42:38,400
and if there

00:42:36,720 --> 00:42:40,880
is one then it will call it otherwise it

00:42:38,400 --> 00:42:43,200
will return empty optional

00:42:40,880 --> 00:42:44,000
for vector it's gonna have to collapse

00:42:43,200 --> 00:42:47,280
the vectors

00:42:44,000 --> 00:42:48,640
together for um for

00:42:47,280 --> 00:42:50,720
future it's going to have to cue up

00:42:48,640 --> 00:42:52,400
continuations so yeah the

00:42:50,720 --> 00:42:54,240
the definition of and then is very much

00:42:52,400 --> 00:42:58,880
going to um differ

00:42:54,240 --> 00:43:01,599
on um on the the monad which you are

00:42:58,880 --> 00:43:02,800
composing any comment about bringing the

00:43:01,599 --> 00:43:05,200
pipe operator for c

00:43:02,800 --> 00:43:06,079
plus plus oh that's uh is he's paper

00:43:05,200 --> 00:43:09,760
yeah great

00:43:06,079 --> 00:43:14,160
love it or some frequent use cases

00:43:09,760 --> 00:43:17,520
for full expressions um

00:43:14,160 --> 00:43:19,760
basically when you have uh well

00:43:17,520 --> 00:43:20,640
one of the times i've used it most is

00:43:19,760 --> 00:43:23,280
folding the

00:43:20,640 --> 00:43:24,319
comma operator over things like if you

00:43:23,280 --> 00:43:26,160
have a variatic

00:43:24,319 --> 00:43:28,160
template and you want to call something

00:43:26,160 --> 00:43:29,920
on um

00:43:28,160 --> 00:43:31,599
every argument you get you can use the

00:43:29,920 --> 00:43:35,040
comma operator to fold

00:43:31,599 --> 00:43:37,920
um all the calls over that but then also

00:43:35,040 --> 00:43:38,400
things like my my sum are kind of silly

00:43:37,920 --> 00:43:40,720
but

00:43:38,400 --> 00:43:42,000
anything which you have an operator

00:43:40,720 --> 00:43:42,800
where you want to collapse all your

00:43:42,000 --> 00:43:45,680
variatic

00:43:42,800 --> 00:43:47,040
arguments uh that's a use case for fold

00:43:45,680 --> 00:43:50,400
expressions

00:43:47,040 --> 00:43:53,200
slide 69 uh

00:43:50,400 --> 00:43:53,760
nice which one was slide 69 identity

00:43:53,200 --> 00:43:57,839
shouldn't be

00:43:53,760 --> 00:44:00,840
zero or type should be unsigned

00:43:57,839 --> 00:44:03,200
which is slide 69

00:44:00,840 --> 00:44:04,560
[Music]

00:44:03,200 --> 00:44:07,920
i'm sure there's a shortcut to go to

00:44:04,560 --> 00:44:10,560
slide 69 but i don't know what it is

00:44:07,920 --> 00:44:14,400
size 69

00:44:10,560 --> 00:44:16,880
uh identity shouldn't be zero or type

00:44:14,400 --> 00:44:18,160
should be unsigned i assume you're

00:44:16,880 --> 00:44:19,680
talking about a different slide because

00:44:18,160 --> 00:44:21,680
i have no idea what that means for this

00:44:19,680 --> 00:44:22,800
can we have links to ben stock in chat i

00:44:21,680 --> 00:44:25,119
assume people hopefully

00:44:22,800 --> 00:44:27,119
link to ben's talks they're great is the

00:44:25,119 --> 00:44:28,480
def programming definition of monad

00:44:27,119 --> 00:44:30,319
equivalent to the mathematical

00:44:28,480 --> 00:44:34,000
definition that's a really good question

00:44:30,319 --> 00:44:35,440
um so the

00:44:34,000 --> 00:44:37,119
the definition which is used in

00:44:35,440 --> 00:44:42,720
functional programming for monad

00:44:37,119 --> 00:44:46,880
is um is derived from category theory

00:44:42,720 --> 00:44:48,640
um but it's not like

00:44:46,880 --> 00:44:50,880
we're essentially taking that definition

00:44:48,640 --> 00:44:54,240
and applying it to the category

00:44:50,880 --> 00:44:55,359
of um of types in our programming

00:44:54,240 --> 00:44:58,800
language

00:44:55,359 --> 00:45:01,200
so it's the mapping is almost there uh

00:44:58,800 --> 00:45:02,560
even pure programming languages pure

00:45:01,200 --> 00:45:03,440
functional programming languages like

00:45:02,560 --> 00:45:05,599
haskell

00:45:03,440 --> 00:45:06,560
have some holes in there like haskell

00:45:05,599 --> 00:45:10,000
has this

00:45:06,560 --> 00:45:12,240
idea of the bottom type for

00:45:10,000 --> 00:45:13,440
expressing certain things which does not

00:45:12,240 --> 00:45:16,240
map into the

00:45:13,440 --> 00:45:16,960
the real definition of a category of

00:45:16,240 --> 00:45:20,079
types

00:45:16,960 --> 00:45:22,160
so um yeah the definition of monad is

00:45:20,079 --> 00:45:22,800
derived from that in category theory

00:45:22,160 --> 00:45:24,720
it's not

00:45:22,800 --> 00:45:25,839
exactly equivalent because you know

00:45:24,720 --> 00:45:28,880
we're dealing with

00:45:25,839 --> 00:45:31,040
programming languages which are not um

00:45:28,880 --> 00:45:33,200
pure maths generally can you explain the

00:45:31,040 --> 00:45:36,319
difference between monad and a monad

00:45:33,200 --> 00:45:39,440
yes so the monoid was the the triple

00:45:36,319 --> 00:45:41,280
of the data type the binary operator

00:45:39,440 --> 00:45:43,119
and the identity element whereas the

00:45:41,280 --> 00:45:46,160
monad is

00:45:43,119 --> 00:45:50,000
um the um

00:45:46,160 --> 00:45:52,480
and then function which can um

00:45:50,000 --> 00:45:53,040
compose functions which are returning

00:45:52,480 --> 00:45:56,079
things

00:45:53,040 --> 00:45:56,640
wrapped in your context so the monoid is

00:45:56,079 --> 00:46:00,079
for

00:45:56,640 --> 00:46:03,200
like um folding over things and

00:46:00,079 --> 00:46:06,480
parallelizing uh data operations

00:46:03,200 --> 00:46:07,920
and moan ads or for composing operations

00:46:06,480 --> 00:46:11,119
within a context

00:46:07,920 --> 00:46:12,800
and building up pipelines

00:46:11,119 --> 00:46:14,960
uh do you think it would be useful to

00:46:12,800 --> 00:46:18,240
have vocabulary types for monoids

00:46:14,960 --> 00:46:18,720
monads and c plus plus i think that

00:46:18,240 --> 00:46:20,640
there's

00:46:18,720 --> 00:46:22,400
there's some difficulty here especially

00:46:20,640 --> 00:46:23,440
in you know how we express these things

00:46:22,400 --> 00:46:26,079
like

00:46:23,440 --> 00:46:26,720
as i said for monoids the the identity

00:46:26,079 --> 00:46:28,880
element

00:46:26,720 --> 00:46:29,760
is predicated not only on your data type

00:46:28,880 --> 00:46:32,640
but also

00:46:29,760 --> 00:46:34,319
on your binary operator so you need to

00:46:32,640 --> 00:46:37,119
have some way of like

00:46:34,319 --> 00:46:39,200
specializing a trait to say oh for this

00:46:37,119 --> 00:46:42,960
data type and this operation

00:46:39,200 --> 00:46:45,119
then this is my identity element

00:46:42,960 --> 00:46:46,000
uh which i've seen done people have

00:46:45,119 --> 00:46:47,280
implemented this

00:46:46,000 --> 00:46:49,520
it's just there's some there's some

00:46:47,280 --> 00:46:54,079
design decisions there

00:46:49,520 --> 00:46:55,680
um vocabulary transform and then

00:46:54,079 --> 00:46:57,920
like i said these things have been

00:46:55,680 --> 00:47:01,359
proposed there there has been a

00:46:57,920 --> 00:47:01,760
proposal for a general monadic interface

00:47:01,359 --> 00:47:05,200
for c

00:47:01,760 --> 00:47:05,680
plus plus uh i think the the author of

00:47:05,200 --> 00:47:08,960
it

00:47:05,680 --> 00:47:11,599
had to to pull it for um

00:47:08,960 --> 00:47:12,880
i'm not sure what the reasons were but

00:47:11,599 --> 00:47:15,839
yeah these things have been

00:47:12,880 --> 00:47:16,800
proposed there's possibilities there's a

00:47:15,839 --> 00:47:20,319
wide design

00:47:16,800 --> 00:47:23,760
space there um i'm not sure where we'll

00:47:20,319 --> 00:47:27,119
end up i think at least for now

00:47:23,760 --> 00:47:29,119
for things like the the main types which

00:47:27,119 --> 00:47:31,200
expose or which should expose these

00:47:29,119 --> 00:47:32,960
magnetic interfaces they can be added on

00:47:31,200 --> 00:47:35,920
a case-by-case basis like

00:47:32,960 --> 00:47:37,440
optional expected um these are the main

00:47:35,920 --> 00:47:38,960
ones which i see i have a

00:47:37,440 --> 00:47:41,440
paper which proposes a magnetic

00:47:38,960 --> 00:47:43,920
interface first adoptional

00:47:41,440 --> 00:47:46,000
do you find it confusing when things

00:47:43,920 --> 00:47:47,119
like coroutines are close to monoids but

00:47:46,000 --> 00:47:49,040
don't quite meet

00:47:47,119 --> 00:47:50,400
all the requirements proteins are close

00:47:49,040 --> 00:47:54,000
to monads not

00:47:50,400 --> 00:47:57,280
not monoids but yes uh like when i saw

00:47:54,000 --> 00:47:58,400
the toby allison implemented um magnetic

00:47:57,280 --> 00:48:02,000
optional

00:47:58,400 --> 00:48:04,400
with co routines i was like cool so

00:48:02,000 --> 00:48:05,200
do we have do notation and then i looked

00:48:04,400 --> 00:48:09,280
into

00:48:05,200 --> 00:48:10,640
implementing the um the list monad where

00:48:09,280 --> 00:48:13,359
you know if you if you have like a

00:48:10,640 --> 00:48:13,760
vector and if you have functions which

00:48:13,359 --> 00:48:15,839
are

00:48:13,760 --> 00:48:17,119
themselves returning vectors then in

00:48:15,839 --> 00:48:19,680
theory you could like

00:48:17,119 --> 00:48:20,640
co-await on all of these operations and

00:48:19,680 --> 00:48:22,960
you would just

00:48:20,640 --> 00:48:23,680
build up a single vector of all of the

00:48:22,960 --> 00:48:25,760
results

00:48:23,680 --> 00:48:27,280
i was like hey this this could be a cool

00:48:25,760 --> 00:48:28,880
deadline i went to implement it and it's

00:48:27,280 --> 00:48:31,839
not possible because

00:48:28,880 --> 00:48:32,880
of the the way that you can't have

00:48:31,839 --> 00:48:34,559
access to the sub

00:48:32,880 --> 00:48:36,960
functions which occur routine is broken

00:48:34,559 --> 00:48:40,000
up into so yeah i do find it confusing

00:48:36,960 --> 00:48:41,599
when things are close to monads but not

00:48:40,000 --> 00:48:44,319
quite

00:48:41,599 --> 00:48:46,559
um is throws like the either monad

00:48:44,319 --> 00:48:49,359
throws is exactly the either monad yes

00:48:46,559 --> 00:48:50,480
either is a another word for the

00:48:49,359 --> 00:48:53,359
expected or

00:48:50,480 --> 00:48:54,240
result or or what what have you so yeah

00:48:53,359 --> 00:48:56,079
froze is

00:48:54,240 --> 00:48:57,839
is just an implementation of either

00:48:56,079 --> 00:48:59,359
monad in the language

00:48:57,839 --> 00:49:00,960
do you have any plans to propose your

00:48:59,359 --> 00:49:03,040
implementation of tl

00:49:00,960 --> 00:49:05,040
expected to the standard so i have an

00:49:03,040 --> 00:49:08,000
implementation of stood expected

00:49:05,040 --> 00:49:08,640
which has an extended monadic interface

00:49:08,000 --> 00:49:11,760
um

00:49:08,640 --> 00:49:13,920
since state expected is still not in

00:49:11,760 --> 00:49:15,440
yeah i don't know what the plans are

00:49:13,920 --> 00:49:18,640
like jf knows that my

00:49:15,440 --> 00:49:21,119
extensions exist and

00:49:18,640 --> 00:49:22,480
things like that so yeah i'm not sure

00:49:21,119 --> 00:49:25,280
where that's gonna end up

00:49:22,480 --> 00:49:27,440
uh for now you can use my tl expected

00:49:25,280 --> 00:49:30,640
slide number may have been off by a few

00:49:27,440 --> 00:49:33,440
okay uh i guess i'm looking for that

00:49:30,640 --> 00:49:36,700
identity thing again

00:49:33,440 --> 00:49:38,319
i'm not gonna do that if you if you can

00:49:36,700 --> 00:49:40,000
[Music]

00:49:38,319 --> 00:49:42,000
compose your question a way which uh

00:49:40,000 --> 00:49:43,520
will jog my memory then maybe i can

00:49:42,000 --> 00:49:45,200
can answer but yeah i'm not sure what's

00:49:43,520 --> 00:49:48,720
your favorite monad

00:49:45,200 --> 00:49:49,680
oh i don't know i think the the writer

00:49:48,720 --> 00:49:51,119
monad was the

00:49:49,680 --> 00:49:52,720
first one which really made me

00:49:51,119 --> 00:49:54,720
understand

00:49:52,720 --> 00:49:55,839
what's going on the writer monad being

00:49:54,720 --> 00:49:58,160
essentially

00:49:55,839 --> 00:49:59,040
something which keeps an audit trail of

00:49:58,160 --> 00:50:01,040
your

00:49:59,040 --> 00:50:02,160
your functions you know you can like

00:50:01,040 --> 00:50:04,240
write into a string

00:50:02,160 --> 00:50:06,079
which will accumulate um some

00:50:04,240 --> 00:50:06,720
information like logging information

00:50:06,079 --> 00:50:08,559
about

00:50:06,720 --> 00:50:10,160
the functions you've called so yeah i'll

00:50:08,559 --> 00:50:11,440
say writer my ad because that's the one

00:50:10,160 --> 00:50:14,559
which

00:50:11,440 --> 00:50:16,240
made me have my like light bulb moment

00:50:14,559 --> 00:50:18,079
do you think it's worth striving for

00:50:16,240 --> 00:50:19,119
pure functional programming in c plus

00:50:18,079 --> 00:50:21,119
plus or would you

00:50:19,119 --> 00:50:22,880
suggest using functional programming

00:50:21,119 --> 00:50:24,640
concepts to augment the typical

00:50:22,880 --> 00:50:28,319
imperative style

00:50:24,640 --> 00:50:31,520
um i think it depends on the

00:50:28,319 --> 00:50:34,640
context it depends on your

00:50:31,520 --> 00:50:37,520
um your constraints and

00:50:34,640 --> 00:50:38,079
the the behavior of your types and of

00:50:37,520 --> 00:50:39,680
course

00:50:38,079 --> 00:50:42,480
on a bunch of things which are more

00:50:39,680 --> 00:50:45,200
sociological problems than technological

00:50:42,480 --> 00:50:46,800
like how much legacy code you have or

00:50:45,200 --> 00:50:50,640
code you cannot change from

00:50:46,800 --> 00:50:54,240
other people um i think that

00:50:50,640 --> 00:50:55,839
striving to um to work with in a pure

00:50:54,240 --> 00:50:57,839
functional style in c

00:50:55,839 --> 00:50:59,520
plus can help as long as you're not

00:50:57,839 --> 00:51:02,000
being dogmatic about it

00:50:59,520 --> 00:51:03,520
um trying to make sure that your

00:51:02,000 --> 00:51:07,520
functions

00:51:03,520 --> 00:51:08,960
um don't make uh changes to mutable

00:51:07,520 --> 00:51:10,559
state and things like that can help in

00:51:08,960 --> 00:51:12,960
so many situations

00:51:10,559 --> 00:51:14,800
so i think it's very useful to always

00:51:12,960 --> 00:51:17,200
have in the back your mind when you're

00:51:14,800 --> 00:51:18,880
designing and writing code and not

00:51:17,200 --> 00:51:20,400
necessarily being like

00:51:18,880 --> 00:51:22,319
we have to write everything pure

00:51:20,400 --> 00:51:25,920
functional that just ends in

00:51:22,319 --> 00:51:28,240
in tears there are some good libraries

00:51:25,920 --> 00:51:29,839
which can help in doing

00:51:28,240 --> 00:51:31,760
more pure functional stuff because of

00:51:29,839 --> 00:51:34,400
course if you're doing pure functional

00:51:31,760 --> 00:51:36,000
programming you end up making a lot of

00:51:34,400 --> 00:51:38,400
copies of things because you

00:51:36,000 --> 00:51:39,359
you're not mutating states so that can

00:51:38,400 --> 00:51:41,359
be very efficient

00:51:39,359 --> 00:51:43,680
inefficient in c plus so there's things

00:51:41,359 --> 00:51:46,800
like uh the imer library

00:51:43,680 --> 00:51:49,040
um which tries to

00:51:46,800 --> 00:51:51,200
to make this actually reasonable to do

00:51:49,040 --> 00:51:52,559
in c plus i'd recommend having a look at

00:51:51,200 --> 00:51:54,160
that

00:51:52,559 --> 00:51:56,079
can we compile the snippets that you

00:51:54,160 --> 00:52:00,240
show us in which c

00:51:56,079 --> 00:52:00,880
plus standard i believe everything which

00:52:00,240 --> 00:52:05,119
i

00:52:00,880 --> 00:52:09,359
presented apart from her perceptions

00:52:05,119 --> 00:52:12,880
should be compilable in siebels 20.

00:52:09,359 --> 00:52:16,240
um i think i i tested all of this stuff

00:52:12,880 --> 00:52:19,520
in msbc so you should be able to

00:52:16,240 --> 00:52:20,640
to compile everything there slide 68

00:52:19,520 --> 00:52:23,599
running max across

00:52:20,640 --> 00:52:25,920
a range of all the negative ins will

00:52:23,599 --> 00:52:30,400
have an issue with an identity

00:52:25,920 --> 00:52:30,400
a value of zero oh yeah sure that's the

00:52:30,839 --> 00:52:35,680
uh

00:52:33,200 --> 00:52:35,680
this one

00:52:36,400 --> 00:52:40,319
you need to change the identity element

00:52:38,000 --> 00:52:41,280
yeah sure the developer's already done

00:52:40,319 --> 00:52:43,119
the kind of

00:52:41,280 --> 00:52:44,960
the work of checking with a specific

00:52:43,119 --> 00:52:46,880
type follows the laws of monads or

00:52:44,960 --> 00:52:50,960
monoids you laid out

00:52:46,880 --> 00:52:53,200
are alluded to using type traits

00:52:50,960 --> 00:52:53,200
um

00:52:54,720 --> 00:52:58,559
i think that that's not generally

00:52:56,480 --> 00:53:01,760
possible in c plus plus like

00:52:58,559 --> 00:53:04,640
type because type implementations are

00:53:01,760 --> 00:53:05,520
is so often subtly different and we

00:53:04,640 --> 00:53:09,280
don't have

00:53:05,520 --> 00:53:11,280
a built-in method of exposing whether

00:53:09,280 --> 00:53:14,480
something is associative

00:53:11,280 --> 00:53:18,480
and things like that we don't have a

00:53:14,480 --> 00:53:21,520
programmable and queryable way

00:53:18,480 --> 00:53:25,839
of um

00:53:21,520 --> 00:53:29,200
of inflicting semantic constraints

00:53:25,839 --> 00:53:32,079
on our types behaviors like we have

00:53:29,200 --> 00:53:34,240
we might get contracts in c 23 which are

00:53:32,079 --> 00:53:35,040
useful for checking semantic constraints

00:53:34,240 --> 00:53:38,319
but

00:53:35,040 --> 00:53:40,000
we wouldn't have um

00:53:38,319 --> 00:53:41,760
at least the i thought of something

00:53:40,000 --> 00:53:43,440
which really makes it easy to work out

00:53:41,760 --> 00:53:46,800
some things like associative

00:53:43,440 --> 00:53:50,960
and whether it behaves in a way which

00:53:46,800 --> 00:53:52,559
uh conforms to the functor or monad laws

00:53:50,960 --> 00:53:54,559
do you think proteins could be expanded

00:53:52,559 --> 00:53:57,040
in a backwards compatible way

00:53:54,559 --> 00:53:59,040
so they would be equivalent or as

00:53:57,040 --> 00:54:01,440
expressive as do notation

00:53:59,040 --> 00:54:02,720
i honestly have not looked into that

00:54:01,440 --> 00:54:03,440
enough to be able to answer that

00:54:02,720 --> 00:54:07,280
question

00:54:03,440 --> 00:54:10,480
um like intuitively

00:54:07,280 --> 00:54:13,680
i'd say that if you if we had

00:54:10,480 --> 00:54:14,240
exposure to the the sub functions which

00:54:13,680 --> 00:54:16,240
are

00:54:14,240 --> 00:54:18,160
are generated by the compiler then you

00:54:16,240 --> 00:54:19,520
would be able to like jury rig something

00:54:18,160 --> 00:54:22,160
for most monads

00:54:19,520 --> 00:54:22,880
but uh i haven't considered whether it

00:54:22,160 --> 00:54:25,920
would be

00:54:22,880 --> 00:54:28,000
general enough is my

00:54:25,920 --> 00:54:30,319
dynamic polymorphism talk the same as

00:54:28,000 --> 00:54:31,200
the one that's already on youtube yes if

00:54:30,319 --> 00:54:33,520
you've seen my

00:54:31,200 --> 00:54:34,720
dynamic polymorphism talk from pure

00:54:33,520 --> 00:54:38,079
virtual c bus plus

00:54:34,720 --> 00:54:40,480
a few months ago then you've already

00:54:38,079 --> 00:54:41,920
seen the talk i'm going to give tomorrow

00:54:40,480 --> 00:54:43,440
given your reference many interesting

00:54:41,920 --> 00:54:44,799
libraries how do you know if you can

00:54:43,440 --> 00:54:48,400
trust their high quality

00:54:44,799 --> 00:54:52,160
slash going to be maintained uh

00:54:48,400 --> 00:54:55,920
i mean that this is the the eternal

00:54:52,160 --> 00:54:56,319
sociological uh technology question

00:54:55,920 --> 00:54:59,839
right

00:54:56,319 --> 00:55:00,960
like how do we know if if something's

00:54:59,839 --> 00:55:04,480
going to be maintained

00:55:00,960 --> 00:55:06,000
is uh a question which you have to ask

00:55:04,480 --> 00:55:07,760
yourself about what what your

00:55:06,000 --> 00:55:10,240
constraints for your business are

00:55:07,760 --> 00:55:12,400
and why uh having some of this stuff in

00:55:10,240 --> 00:55:15,839
the standard really helps

00:55:12,400 --> 00:55:18,079
um yeah if you're

00:55:15,839 --> 00:55:19,119
using third-party libraries then you

00:55:18,079 --> 00:55:22,160
have to to

00:55:19,119 --> 00:55:24,000
take into account that they might not be

00:55:22,160 --> 00:55:27,520
maintained to the same level of

00:55:24,000 --> 00:55:29,200
of standard or um for the same longevity

00:55:27,520 --> 00:55:32,000
as the standard library

00:55:29,200 --> 00:55:34,640
in the code examples was pipe and then

00:55:32,000 --> 00:55:35,280
for the optional some third-party

00:55:34,640 --> 00:55:39,040
library

00:55:35,280 --> 00:55:42,240
if it was where can we find it um so the

00:55:39,040 --> 00:55:46,720
the pipe and then uh i think

00:55:42,240 --> 00:55:50,240
the vittorio's skeletal library

00:55:46,720 --> 00:55:52,960
maybe has that uh my implementation of

00:55:50,240 --> 00:55:53,680
stood optional tl optional uses dot and

00:55:52,960 --> 00:55:56,079
then

00:55:53,680 --> 00:55:57,599
i use the the bar and then in this talk

00:55:56,079 --> 00:56:01,280
because it's more

00:55:57,599 --> 00:56:03,200
um in line with what ranges does and

00:56:01,280 --> 00:56:04,400
um i wanted to have that nice like

00:56:03,200 --> 00:56:08,240
visual

00:56:04,400 --> 00:56:11,599
um symmetry uh but it's

00:56:08,240 --> 00:56:11,599
it's a very similar

00:56:12,079 --> 00:56:16,000
it's very similar to the the dot and

00:56:14,000 --> 00:56:18,240
then you can you can implement

00:56:16,000 --> 00:56:20,240
it in a different way um actually using

00:56:18,240 --> 00:56:23,680
python then instead of dot and then

00:56:20,240 --> 00:56:24,880
avoid some very obscure issues to do

00:56:23,680 --> 00:56:28,000
with how

00:56:24,880 --> 00:56:30,319
um svna friendly

00:56:28,000 --> 00:56:31,760
unfriendly callables interact with

00:56:30,319 --> 00:56:34,799
member function overloads

00:56:31,760 --> 00:56:36,880
which is a lot of fun and you can talk

00:56:34,799 --> 00:56:38,880
to me later if you're interested

00:56:36,880 --> 00:56:41,520
but i think i've worked through all of

00:56:38,880 --> 00:56:43,359
my questions thank you so much for all

00:56:41,520 --> 00:56:44,960
of those

00:56:43,359 --> 00:56:47,280
it makes up for me going a little bit

00:56:44,960 --> 00:56:50,480
fast on the talk so we're about

00:56:47,280 --> 00:56:52,640
time so thank you very much please come

00:56:50,480 --> 00:56:54,559
chat to me either just grab me the

00:56:52,640 --> 00:56:59,839
conference find me at the expo hall

00:56:54,559 --> 00:56:59,839
wherever and enjoy the conference bye

00:57:17,599 --> 00:57:19,680

YouTube URL: https://www.youtube.com/watch?v=AGRWRwi7rD0


