Title: Calling Functions: A Tutorial - Klaus Iglberger - CppCon 2020
Publication date: 2020-09-23
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/calling_functions_a_tutorial/calling_functions_a_tutorial__klaus_iglberger__cppcon_2020.pdf
---

How is a function call resolved? How does the compiler find the right function and how does the compiler choose from a set of available functions? This talk will give an overview of the individual steps taken during the resolution of a function call. It will primarily focus on the different kinds of name lookup, argument deduction, and on overload resolution. Attendees will gain insight into the mechanics of (un-)qualified lookup, argument dependent lookup, two-phase lookup, name hiding, SFINAE, (viable) candiate functions, and ambiguous function calls. They will leave the talk with a much better understanding of the (sometimes surprising) details of function calls.

---
Klaus Iglberger is a freelancing C++ trainer and consultant. He has finished his PhD in computer science in 2010 and since then is focused on large-scale C++ software design. He shares his experience in popular advanced C++ courses around the world (mainly in Germany, but also the EU and US). Additionally, he is the initiator and lead designer of the Blaze C++ math library (https://bitbucket.org/blaze-lib/blaze/src/master/) and one of the organizers of the Munich C++ user group (https://www.meetup.com/MUCplusplus/).

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,800 --> 00:00:12,880
hey wonderful good evening

00:00:10,320 --> 00:00:13,679
good afternoon or good morning wherever

00:00:12,880 --> 00:00:15,759
you are

00:00:13,679 --> 00:00:16,880
and welcome to calling functions a

00:00:15,759 --> 00:00:19,520
tutorial

00:00:16,880 --> 00:00:20,720
allow me to quickly introduce myself my

00:00:19,520 --> 00:00:22,720
name is klaus

00:00:20,720 --> 00:00:26,240
and i'm working as a freelancing c plus

00:00:22,720 --> 00:00:28,080
plus trainer since approximately 2016.

00:00:26,240 --> 00:00:29,439
apparently uh during class plus on my

00:00:28,080 --> 00:00:31,599
job is not enough c plus

00:00:29,439 --> 00:00:33,520
for me i'm also doing class plus my free

00:00:31,599 --> 00:00:34,000
time for instance i'm the author of the

00:00:33,520 --> 00:00:36,239
c plus

00:00:34,000 --> 00:00:38,079
math library called blaze and i'm also

00:00:36,239 --> 00:00:39,360
one of the organizers of the munich c

00:00:38,079 --> 00:00:42,160
plus os user group

00:00:39,360 --> 00:00:44,000
which as a side note may actually be one

00:00:42,160 --> 00:00:47,280
of the largest and most active c plus

00:00:44,000 --> 00:00:49,840
user groups worldwide this talk

00:00:47,280 --> 00:00:51,840
is about calling functions and in

00:00:49,840 --> 00:00:52,480
particular this is about the individual

00:00:51,840 --> 00:00:54,800
steps

00:00:52,480 --> 00:00:56,559
the mechanical steps that happen when

00:00:54,800 --> 00:00:58,559
you call a function

00:00:56,559 --> 00:01:00,399
it is not the low level thing that

00:00:58,559 --> 00:01:03,600
happens in a compiler

00:01:00,399 --> 00:01:05,119
or in a cpu it is truly the individual

00:01:03,600 --> 00:01:08,159
steps that the language itself

00:01:05,119 --> 00:01:10,640
defines so we will take a close look at

00:01:08,159 --> 00:01:12,080
name lookup there is a step called

00:01:10,640 --> 00:01:13,680
template argument deduction

00:01:12,080 --> 00:01:15,920
we'll take a close look at overload

00:01:13,680 --> 00:01:17,840
resolution access labels

00:01:15,920 --> 00:01:19,360
function template specializations

00:01:17,840 --> 00:01:22,479
virtual dispatch

00:01:19,360 --> 00:01:24,080
and deleting functions

00:01:22,479 --> 00:01:25,759
so this will be quite a challenge for a

00:01:24,080 --> 00:01:28,080
60-minute talk

00:01:25,759 --> 00:01:30,560
this is also why i can unfortunately not

00:01:28,080 --> 00:01:32,240
go into detail about every single detail

00:01:30,560 --> 00:01:34,479
i will for instance not be able to talk

00:01:32,240 --> 00:01:36,000
about template argument deduction

00:01:34,479 --> 00:01:37,520
there's excellent material on that

00:01:36,000 --> 00:01:39,600
however

00:01:37,520 --> 00:01:41,119
so um this should get you covered and

00:01:39,600 --> 00:01:43,040
also will not be able to talk about

00:01:41,119 --> 00:01:45,200
virtual dispatch

00:01:43,040 --> 00:01:46,240
else we will indeed get a complete

00:01:45,200 --> 00:01:47,840
overview of

00:01:46,240 --> 00:01:50,560
all the eventual steps how they're

00:01:47,840 --> 00:01:51,200
connected and why sometimes for calling

00:01:50,560 --> 00:01:54,479
functions

00:01:51,200 --> 00:01:57,759
is a pretty surprising endeavor

00:01:54,479 --> 00:01:59,439
still still i should

00:01:57,759 --> 00:02:01,040
give you some ideas what you can expect

00:01:59,439 --> 00:02:02,079
and what you cannot expect in this talk

00:02:01,040 --> 00:02:05,200
so this talk

00:02:02,079 --> 00:02:07,439
does focus on the basic mechanics indeed

00:02:05,200 --> 00:02:09,280
primarily because i found that this is

00:02:07,439 --> 00:02:10,959
teaching material that is missing

00:02:09,280 --> 00:02:12,800
has been missing so far you find the

00:02:10,959 --> 00:02:15,280
details but

00:02:12,800 --> 00:02:16,560
not really in one talk putting them

00:02:15,280 --> 00:02:18,239
together

00:02:16,560 --> 00:02:19,920
i will also point out the surprising

00:02:18,239 --> 00:02:21,760
details and

00:02:19,920 --> 00:02:23,040
whenever necessary i will give you

00:02:21,760 --> 00:02:25,840
further references

00:02:23,040 --> 00:02:28,319
um to other talks other material

00:02:25,840 --> 00:02:31,440
whenever it is appropriate

00:02:28,319 --> 00:02:32,480
this talk does not show all possible

00:02:31,440 --> 00:02:34,239
examples

00:02:32,480 --> 00:02:35,599
that is hardly possible then we would

00:02:34,239 --> 00:02:38,160
probably need an entire day

00:02:35,599 --> 00:02:39,040
you can get close to that and it also

00:02:38,160 --> 00:02:41,519
does not mention

00:02:39,040 --> 00:02:43,599
every single detail so i will for

00:02:41,519 --> 00:02:46,959
instance not give you every possible

00:02:43,599 --> 00:02:48,879
um case in overload resolution i believe

00:02:46,959 --> 00:02:52,319
as soon as you understand how it works

00:02:48,879 --> 00:02:54,560
in general you will have an easy

00:02:52,319 --> 00:02:56,080
time to to deal with this yourself and

00:02:54,560 --> 00:02:58,879
it also does not try to

00:02:56,080 --> 00:03:00,480
be bleeding edge so i will stick to the

00:02:58,879 --> 00:03:03,440
important details

00:03:00,480 --> 00:03:05,360
and i try to be as blissful as 20 talk

00:03:03,440 --> 00:03:07,519
so with having said that

00:03:05,360 --> 00:03:10,239
let's first of all get an overview of

00:03:07,519 --> 00:03:12,720
the individual steps in calling function

00:03:10,239 --> 00:03:14,239
the very first step is called name

00:03:12,720 --> 00:03:16,480
lookup

00:03:14,239 --> 00:03:17,599
the purpose of name lookup is to first

00:03:16,480 --> 00:03:20,879
of all find

00:03:17,599 --> 00:03:23,360
possible candidate functions that so all

00:03:20,879 --> 00:03:25,280
functions with a certain name

00:03:23,360 --> 00:03:26,799
we'll see exactly how this works but

00:03:25,280 --> 00:03:29,360
name lookup comes up

00:03:26,799 --> 00:03:31,040
potentially with quite quite a number of

00:03:29,360 --> 00:03:32,879
names

00:03:31,040 --> 00:03:34,560
the second step directly taken

00:03:32,879 --> 00:03:35,760
afterwards is template argument

00:03:34,560 --> 00:03:37,840
deduction

00:03:35,760 --> 00:03:39,920
some of these candidate functions might

00:03:37,840 --> 00:03:41,360
actually be function templates

00:03:39,920 --> 00:03:43,200
these function templates need to be

00:03:41,360 --> 00:03:45,360
instantiated in order to produce

00:03:43,200 --> 00:03:46,720
functions that we can ultimately call

00:03:45,360 --> 00:03:48,640
there's a couple of pretty interesting

00:03:46,720 --> 00:03:49,519
mechanisms at work here as well such as

00:03:48,640 --> 00:03:51,120
finae

00:03:49,519 --> 00:03:53,120
as i said unfortunately it cannot go

00:03:51,120 --> 00:03:55,519
into detail here

00:03:53,120 --> 00:03:57,360
but imagine that now i extended the set

00:03:55,519 --> 00:03:58,959
by some additional functions

00:03:57,360 --> 00:04:00,879
and this additional set of emitted

00:03:58,959 --> 00:04:02,640
functions now goes into the overload

00:04:00,879 --> 00:04:04,480
resolution

00:04:02,640 --> 00:04:07,040
the purpose of the overload resolution

00:04:04,480 --> 00:04:08,159
is to find the one function that we deem

00:04:07,040 --> 00:04:11,040
to be the best

00:04:08,159 --> 00:04:13,120
match it might not be perfect match but

00:04:11,040 --> 00:04:16,879
from all the given candidate functions

00:04:13,120 --> 00:04:16,879
we find out which one fits best

00:04:17,359 --> 00:04:20,880
this one function might actually be a

00:04:19,680 --> 00:04:23,199
member function

00:04:20,880 --> 00:04:23,919
then we should take a look at the access

00:04:23,199 --> 00:04:26,880
labels

00:04:23,919 --> 00:04:28,080
so see if it actually can be called the

00:04:26,880 --> 00:04:31,440
one selected function

00:04:28,080 --> 00:04:32,560
might be a function template then we

00:04:31,440 --> 00:04:33,800
also have to

00:04:32,560 --> 00:04:35,680
consider function template

00:04:33,800 --> 00:04:39,199
specializations

00:04:35,680 --> 00:04:41,199
which is not um quite um as obvious as

00:04:39,199 --> 00:04:43,280
it sounds

00:04:41,199 --> 00:04:44,240
and the selected function might be a

00:04:43,280 --> 00:04:47,040
virtual function

00:04:44,240 --> 00:04:50,000
in that case uh we have to uh trigger a

00:04:47,040 --> 00:04:50,000
virtual dispatch

00:04:50,080 --> 00:04:53,440
and the last possible case is that the

00:04:51,840 --> 00:04:56,400
given function might actually

00:04:53,440 --> 00:04:58,400
have been deleted explicitly via equal

00:04:56,400 --> 00:05:01,520
delete

00:04:58,400 --> 00:05:02,160
so all of these steps now are explicitly

00:05:01,520 --> 00:05:04,400
dealt with

00:05:02,160 --> 00:05:05,840
we now walk through this um these

00:05:04,400 --> 00:05:07,360
individual steps and talk about all of

00:05:05,840 --> 00:05:08,880
them intuitively

00:05:07,360 --> 00:05:10,639
before we get started there is one

00:05:08,880 --> 00:05:12,479
comment that is actually fundamental to

00:05:10,639 --> 00:05:13,919
understanding how a lot of these steps

00:05:12,479 --> 00:05:16,880
interact

00:05:13,919 --> 00:05:19,280
this let's call its algorithm is a

00:05:16,880 --> 00:05:21,840
strict one-way street

00:05:19,280 --> 00:05:23,440
once name lookup is finished finding

00:05:21,840 --> 00:05:25,680
some function

00:05:23,440 --> 00:05:26,560
and then i come to uh to compilation

00:05:25,680 --> 00:05:29,600
error later

00:05:26,560 --> 00:05:33,280
i never go back to preceding step i

00:05:29,600 --> 00:05:34,639
always report the error as error

00:05:33,280 --> 00:05:36,560
now this is something that we'll see in

00:05:34,639 --> 00:05:38,080
a couple of places

00:05:36,560 --> 00:05:39,680
and this is very important to keep in

00:05:38,080 --> 00:05:42,800
mind in order to understand

00:05:39,680 --> 00:05:43,600
the complete behavior all right with

00:05:42,800 --> 00:05:46,000
having said that

00:05:43,600 --> 00:05:47,440
let's first take a look at name lookup

00:05:46,000 --> 00:05:49,759
the very first step

00:05:47,440 --> 00:05:52,080
dealing with just finding the functions

00:05:49,759 --> 00:05:54,720
that we are supposed to call

00:05:52,080 --> 00:05:56,080
so the example i have is a function that

00:05:54,720 --> 00:05:58,800
takes a double

00:05:56,080 --> 00:06:00,080
a function called f then a namespace

00:05:58,800 --> 00:06:03,120
called namespace1

00:06:00,080 --> 00:06:04,240
n1 with an additional function that

00:06:03,120 --> 00:06:08,000
takes an end

00:06:04,240 --> 00:06:10,160
this is my one this is my function two

00:06:08,000 --> 00:06:12,960
in the main function i now call func

00:06:10,160 --> 00:06:15,360
function f with a one point zero

00:06:12,960 --> 00:06:16,560
not surprisingly this will call function

00:06:15,360 --> 00:06:18,800
one

00:06:16,560 --> 00:06:20,240
this is called unqualified lookup i do

00:06:18,800 --> 00:06:23,280
not explicitly

00:06:20,240 --> 00:06:24,800
make any specifications i just find the

00:06:23,280 --> 00:06:29,039
function that is

00:06:24,800 --> 00:06:31,919
most appropriate if i call f with a 42

00:06:29,039 --> 00:06:33,759
however i do not go to function2 because

00:06:31,919 --> 00:06:35,759
at this point the compiler does not even

00:06:33,759 --> 00:06:38,160
consider namespace in one

00:06:35,759 --> 00:06:39,120
it only finds and exclusively finds

00:06:38,160 --> 00:06:40,479
function one

00:06:39,120 --> 00:06:42,319
this is the only match and as you see

00:06:40,479 --> 00:06:45,120
later it actually can be called

00:06:42,319 --> 00:06:46,960
so again unqualified lookup calls

00:06:45,120 --> 00:06:49,360
function1

00:06:46,960 --> 00:06:51,919
if from that call site from the main

00:06:49,360 --> 00:06:54,240
function i really want to call function

00:06:51,919 --> 00:06:55,599
the function f in the namespace in one i

00:06:54,240 --> 00:06:58,639
have to explicitly

00:06:55,599 --> 00:07:01,840
say so i have to explicitly qualify with

00:06:58,639 --> 00:07:03,680
n1 column colon f this now calls

00:07:01,840 --> 00:07:06,400
function2

00:07:03,680 --> 00:07:08,960
and this is called qualified lookup

00:07:06,400 --> 00:07:10,720
qualified lookup looks for a specific

00:07:08,960 --> 00:07:14,080
function a function is specific

00:07:10,720 --> 00:07:16,960
namespace or sometimes also class scope

00:07:14,080 --> 00:07:20,240
unqualified lookup finds the best match

00:07:16,960 --> 00:07:20,240
from the given call site

00:07:20,800 --> 00:07:24,880
now let's imagine that the function in

00:07:22,960 --> 00:07:27,919
the namespace n1 doesn't exist

00:07:24,880 --> 00:07:30,080
i only have function1 then

00:07:27,919 --> 00:07:30,960
the first two crisis will still call

00:07:30,080 --> 00:07:33,280
function one

00:07:30,960 --> 00:07:34,800
the last call the qualified lookup

00:07:33,280 --> 00:07:36,960
however is now ill-formed

00:07:34,800 --> 00:07:38,080
there simply isn't the function f in

00:07:36,960 --> 00:07:40,000
namespace in one

00:07:38,080 --> 00:07:41,680
the name lookup comes up handy

00:07:40,000 --> 00:07:43,840
empty-handed

00:07:41,680 --> 00:07:46,000
and reports this as an error it does not

00:07:43,840 --> 00:07:48,080
continue looking because it is qualified

00:07:46,000 --> 00:07:50,240
lookup after all you are specifying that

00:07:48,080 --> 00:07:52,479
you want to call a specific function a

00:07:50,240 --> 00:07:56,160
function from a specific namespace

00:07:52,479 --> 00:07:57,599
in the first place now let's assume that

00:07:56,160 --> 00:07:59,680
i get my function to back

00:07:57,599 --> 00:08:00,960
but that i have two additional functions

00:07:59,680 --> 00:08:04,319
g and h

00:08:00,960 --> 00:08:07,680
g calls in one cold colon f h

00:08:04,319 --> 00:08:10,800
cause f without qualification

00:08:07,680 --> 00:08:12,800
both use a double argument now the first

00:08:10,800 --> 00:08:14,560
function i call is the function g from

00:08:12,800 --> 00:08:16,960
the n1 namespace

00:08:14,560 --> 00:08:18,560
n uses qualified lookup and for that

00:08:16,960 --> 00:08:21,840
reason we'll definitely call

00:08:18,560 --> 00:08:23,919
function2 despite the fact that the

00:08:21,840 --> 00:08:24,639
double now of course has been squeezed

00:08:23,919 --> 00:08:28,080
into an int

00:08:24,639 --> 00:08:30,240
this is called a conversion

00:08:28,080 --> 00:08:32,479
so this calls with qualified lookup

00:08:30,240 --> 00:08:35,519
function 2.

00:08:32,479 --> 00:08:37,760
if i call function h

00:08:35,519 --> 00:08:39,519
then i would hope for perhaps that

00:08:37,760 --> 00:08:42,000
function 1 is selected

00:08:39,519 --> 00:08:43,360
but perhaps surprisingly this also calls

00:08:42,000 --> 00:08:46,480
function2

00:08:43,360 --> 00:08:49,600
this time with unqualified lookup

00:08:46,480 --> 00:08:51,920
if the name lookup tries to find the

00:08:49,600 --> 00:08:54,160
equating function from that call site

00:08:51,920 --> 00:08:55,360
the first thing that a compiler finds is

00:08:54,160 --> 00:08:57,519
this f

00:08:55,360 --> 00:08:58,720
that is the only f in this particular

00:08:57,519 --> 00:09:01,279
namespace

00:08:58,720 --> 00:09:02,720
the only f that has been seen so far and

00:09:01,279 --> 00:09:05,279
so the name lookup is

00:09:02,720 --> 00:09:07,600
satisfied finishes its job and passes

00:09:05,279 --> 00:09:10,880
this over as the only viable candidate

00:09:07,600 --> 00:09:13,839
to the next step this function is not

00:09:10,880 --> 00:09:14,320
even found by name lookup this is what

00:09:13,839 --> 00:09:17,040
we call

00:09:14,320 --> 00:09:17,440
hiding function2 because it has the same

00:09:17,040 --> 00:09:22,480
name

00:09:17,440 --> 00:09:25,360
heights function f f1

00:09:22,480 --> 00:09:26,640
hiding is a pretty important mechanism

00:09:25,360 --> 00:09:29,279
to keep in mind

00:09:26,640 --> 00:09:30,959
the rationale is this must be the most

00:09:29,279 --> 00:09:33,360
specific function because it is

00:09:30,959 --> 00:09:35,519
closest to the call side this is why the

00:09:33,360 --> 00:09:36,480
compiler does not even consider anything

00:09:35,519 --> 00:09:38,160
else

00:09:36,480 --> 00:09:40,480
this is supposed to protect you from

00:09:38,160 --> 00:09:42,640
surprising behavior

00:09:40,480 --> 00:09:44,320
and of course in many situations this

00:09:42,640 --> 00:09:45,839
works just as intended

00:09:44,320 --> 00:09:48,880
we'll see a couple of places where this

00:09:45,839 --> 00:09:51,600
is indeed very surprising

00:09:48,880 --> 00:09:53,360
this is even true if f takes a string

00:09:51,600 --> 00:09:54,720
argument

00:09:53,360 --> 00:09:56,560
the compiler would only find this

00:09:54,720 --> 00:09:59,279
particular f and so both

00:09:56,560 --> 00:09:59,920
calls both the call from g and the call

00:09:59,279 --> 00:10:02,959
from f

00:09:59,920 --> 00:10:04,560
would be h would be ill-formed the

00:10:02,959 --> 00:10:08,079
compiler comes up with

00:10:04,560 --> 00:10:09,519
um f it function two

00:10:08,079 --> 00:10:11,680
this is the only function that the

00:10:09,519 --> 00:10:12,640
compiler comes up with and later of

00:10:11,680 --> 00:10:14,480
course

00:10:12,640 --> 00:10:16,240
in the overload resolution step we find

00:10:14,480 --> 00:10:20,079
that this is not a match at all

00:10:16,240 --> 00:10:22,800
the repo reports a compilation error

00:10:20,079 --> 00:10:24,640
and as i said before we never go back to

00:10:22,800 --> 00:10:27,440
try to find another f

00:10:24,640 --> 00:10:28,399
at this point overlap resolution fails

00:10:27,440 --> 00:10:30,240
because the name

00:10:28,399 --> 00:10:32,079
lookup simply didn't find this function

00:10:30,240 --> 00:10:35,680
so again it's this hiding effect

00:10:32,079 --> 00:10:35,680
function two hides function one

00:10:36,720 --> 00:10:40,720
this is also true if we have types or

00:10:39,360 --> 00:10:43,279
any kind of variables

00:10:40,720 --> 00:10:44,000
it is about the name it is called name

00:10:43,279 --> 00:10:47,120
lookup

00:10:44,000 --> 00:10:48,079
and so if we have an variable constant

00:10:47,120 --> 00:10:50,720
or anything

00:10:48,079 --> 00:10:52,079
with the according name the name lookup

00:10:50,720 --> 00:10:54,640
would at this point

00:10:52,079 --> 00:10:55,920
find this it would report it then later

00:10:54,640 --> 00:10:59,279
we would find that this

00:10:55,920 --> 00:11:01,600
f cannot be used as a function so

00:10:59,279 --> 00:11:02,399
it is name lookup it is not function

00:11:01,600 --> 00:11:06,800
lookup

00:11:02,399 --> 00:11:06,800
any name is taken into consideration

00:11:08,399 --> 00:11:11,440
now let's assume that the second

00:11:09,920 --> 00:11:14,560
function is

00:11:11,440 --> 00:11:16,640
gone again then function g is suddenly

00:11:14,560 --> 00:11:20,079
ill-formed there is no function

00:11:16,640 --> 00:11:22,560
uh um in the name in one namespace

00:11:20,079 --> 00:11:24,240
function h however now calls function

00:11:22,560 --> 00:11:26,720
one

00:11:24,240 --> 00:11:28,399
pilot does not find anything in asus n1

00:11:26,720 --> 00:11:30,079
where the call originates

00:11:28,399 --> 00:11:31,760
and for that reason and for that reason

00:11:30,079 --> 00:11:33,760
only it continues looking

00:11:31,760 --> 00:11:35,360
in the next scope which here is the

00:11:33,760 --> 00:11:38,800
global scope

00:11:35,360 --> 00:11:40,000
no f in n1 but then finally i find an f

00:11:38,800 --> 00:11:41,680
in the global namespace

00:11:40,000 --> 00:11:45,279
that must be the function call and

00:11:41,680 --> 00:11:45,279
ultimately it is indeed called

00:11:45,760 --> 00:11:49,600
so i now get my function to back but i

00:11:48,959 --> 00:11:52,800
get rid

00:11:49,600 --> 00:11:55,200
of the explicit n1 qualifier

00:11:52,800 --> 00:11:56,079
this is now explicitly specifying i want

00:11:55,200 --> 00:11:58,480
to call a function

00:11:56,079 --> 00:11:59,680
from the global namespace for that

00:11:58,480 --> 00:12:02,320
reason now

00:11:59,680 --> 00:12:03,200
f calls function1 in the global

00:12:02,320 --> 00:12:06,880
namespace

00:12:03,200 --> 00:12:08,959
and h calls just as before function2

00:12:06,880 --> 00:12:11,839
qualifiedlookup versus unqualified

00:12:08,959 --> 00:12:14,079
lookup again

00:12:11,839 --> 00:12:15,360
note that nothing changes with regard to

00:12:14,079 --> 00:12:18,320
which functions called

00:12:15,360 --> 00:12:20,000
if i come up with a third function a

00:12:18,320 --> 00:12:22,160
function f that takes a double in

00:12:20,000 --> 00:12:25,120
namespace n1

00:12:22,160 --> 00:12:26,160
this function is only defined after the

00:12:25,120 --> 00:12:29,360
call site

00:12:26,160 --> 00:12:31,200
so officially it hasn't been seen yet so

00:12:29,360 --> 00:12:32,959
it cannot be considered

00:12:31,200 --> 00:12:35,279
name lookup only considers all those

00:12:32,959 --> 00:12:37,200
functions that already have been seen

00:12:35,279 --> 00:12:39,279
and then of course as i said before in

00:12:37,200 --> 00:12:41,120
order based on the namespace

00:12:39,279 --> 00:12:43,440
based on the location of the call site

00:12:41,120 --> 00:12:46,560
so function 3 is never an option for

00:12:43,440 --> 00:12:46,560
these two function calls

00:12:48,560 --> 00:12:53,279
let's introduce struct s which also has

00:12:51,920 --> 00:12:54,720
a function f

00:12:53,279 --> 00:12:56,800
function takes an int this is my

00:12:54,720 --> 00:12:57,279
function three and additionally comes

00:12:56,800 --> 00:12:59,839
with

00:12:57,279 --> 00:13:01,519
a function called g which calls f with a

00:12:59,839 --> 00:13:03,440
double value

00:13:01,519 --> 00:13:04,639
if in my main function i first create an

00:13:03,440 --> 00:13:08,079
s and then call

00:13:04,639 --> 00:13:10,240
s dot g then the first function that

00:13:08,079 --> 00:13:11,440
is found in this context is function

00:13:10,240 --> 00:13:13,760
three i

00:13:11,440 --> 00:13:14,800
first start looking in the scope of s it

00:13:13,760 --> 00:13:17,760
finds the function

00:13:14,800 --> 00:13:20,240
three calls function three both two and

00:13:17,760 --> 00:13:24,560
one are never considered because again

00:13:20,240 --> 00:13:26,800
of hiding if function 3 is gone

00:13:24,560 --> 00:13:28,880
then the compiler is uh doesn't find

00:13:26,800 --> 00:13:30,240
anything in struct s

00:13:28,880 --> 00:13:32,959
it's free to explore the surrounding

00:13:30,240 --> 00:13:35,600
namespace and finds function2

00:13:32,959 --> 00:13:36,800
again function 4 is not an option

00:13:35,600 --> 00:13:40,000
because it's defined

00:13:36,800 --> 00:13:40,800
after the call site so function2 is

00:13:40,000 --> 00:13:43,440
called

00:13:40,800 --> 00:13:45,279
which however again hides function1 and

00:13:43,440 --> 00:13:46,160
if i would get rid of the second

00:13:45,279 --> 00:13:49,199
function

00:13:46,160 --> 00:13:51,360
then finally i would um not

00:13:49,199 --> 00:13:52,880
find something in s i would not find any

00:13:51,360 --> 00:13:55,120
if in n1

00:13:52,880 --> 00:13:58,000
and so i would call function one without

00:13:55,120 --> 00:13:58,000
any kind of hiding

00:13:58,639 --> 00:14:06,399
note that so far we have only dealt with

00:14:03,519 --> 00:14:08,480
fundamental types still the effects that

00:14:06,399 --> 00:14:09,519
i described are pretty important to keep

00:14:08,480 --> 00:14:11,199
in mind

00:14:09,519 --> 00:14:13,120
and this is one of the examples that is

00:14:11,199 --> 00:14:14,560
always confusing to

00:14:13,120 --> 00:14:16,399
especially new programmers and

00:14:14,560 --> 00:14:18,000
particularly programmers that come from

00:14:16,399 --> 00:14:20,240
java or c-sharp

00:14:18,000 --> 00:14:22,079
languages that put more emphasis on

00:14:20,240 --> 00:14:24,639
class scope

00:14:22,079 --> 00:14:26,000
i create now a derived object and a

00:14:24,639 --> 00:14:28,639
drive object

00:14:26,000 --> 00:14:31,360
is deriving from a base class the base

00:14:28,639 --> 00:14:33,040
class comes with two f's

00:14:31,360 --> 00:14:35,519
and after takes an int and then after

00:14:33,040 --> 00:14:36,880
takes a double this is function one this

00:14:35,519 --> 00:14:39,839
is function two

00:14:36,880 --> 00:14:40,639
the drive class introduces a third

00:14:39,839 --> 00:14:43,120
function

00:14:40,639 --> 00:14:44,399
which of course overwrites function um

00:14:43,120 --> 00:14:47,839
2.

00:14:44,399 --> 00:14:50,480
so this is my function 3.

00:14:47,839 --> 00:14:52,160
i use this d and i call a function f

00:14:50,480 --> 00:14:55,760
with a 42

00:14:52,160 --> 00:14:57,279
an integer obviously still despite the

00:14:55,760 --> 00:14:58,959
fact that this is an integer

00:14:57,279 --> 00:15:00,639
despite the fact that in this class

00:14:58,959 --> 00:15:02,480
hierarchy eventually the

00:15:00,639 --> 00:15:04,160
name lookup might find a function that

00:15:02,480 --> 00:15:06,639
takes an end this will

00:15:04,160 --> 00:15:09,120
call function three for exactly the

00:15:06,639 --> 00:15:11,279
reasons explained before

00:15:09,120 --> 00:15:13,199
the one additional information is that

00:15:11,279 --> 00:15:16,720
the call here originates

00:15:13,199 --> 00:15:17,440
essentially from the scope i looking up

00:15:16,720 --> 00:15:20,399
a function

00:15:17,440 --> 00:15:21,600
from the scope of derived name lookup

00:15:20,399 --> 00:15:23,760
finds a function f

00:15:21,600 --> 00:15:25,199
function three because it finds a

00:15:23,760 --> 00:15:27,279
function with the according name it does

00:15:25,199 --> 00:15:29,279
not continue looking elsewhere

00:15:27,279 --> 00:15:31,120
so this function ultimately is called

00:15:29,279 --> 00:15:32,320
because i can convert an integer into a

00:15:31,120 --> 00:15:35,120
double

00:15:32,320 --> 00:15:36,959
function one and two are again hidden

00:15:35,120 --> 00:15:38,560
the compiler cannot see them

00:15:36,959 --> 00:15:40,000
and therefore they're not taken into

00:15:38,560 --> 00:15:42,000
account this

00:15:40,000 --> 00:15:43,519
is confusing this is something that

00:15:42,000 --> 00:15:45,519
surprises people

00:15:43,519 --> 00:15:48,240
this is something that really really

00:15:45,519 --> 00:15:48,240
should remember

00:15:48,880 --> 00:15:53,519
now as before so far we have only an

00:15:51,279 --> 00:15:56,079
exclusive dealt with fundamental types

00:15:53,519 --> 00:15:57,440
let's introduce a class type struct s

00:15:56,079 --> 00:15:59,759
which is empty

00:15:57,440 --> 00:16:00,560
bit but which comes with an additional

00:15:59,759 --> 00:16:04,079
function f

00:16:00,560 --> 00:16:06,240
that takes an s now a special effect

00:16:04,079 --> 00:16:09,600
comes into play

00:16:06,240 --> 00:16:12,240
i create an s and i pass this s to a

00:16:09,600 --> 00:16:12,240
function f

00:16:13,759 --> 00:16:18,000
despite the fact that i said before that

00:16:16,560 --> 00:16:20,480
only the things that have been seen

00:16:18,000 --> 00:16:21,120
in a called actually this will call

00:16:20,480 --> 00:16:24,480
function

00:16:21,120 --> 00:16:27,759
3 a function that is not

00:16:24,480 --> 00:16:29,680
in the global namespace but in namespace

00:16:27,759 --> 00:16:32,240
n1

00:16:29,680 --> 00:16:33,839
this effect is called argument dependent

00:16:32,240 --> 00:16:36,639
lookup

00:16:33,839 --> 00:16:37,759
the type s is from the namespace n1 and

00:16:36,639 --> 00:16:39,759
so the compiler

00:16:37,759 --> 00:16:40,959
is now additionally considering the

00:16:39,759 --> 00:16:43,920
namespace n1

00:16:40,959 --> 00:16:44,959
to find functions so in this context it

00:16:43,920 --> 00:16:47,519
finds both

00:16:44,959 --> 00:16:49,040
function one two and three and then

00:16:47,519 --> 00:16:51,199
ultimately besides that function three

00:16:49,040 --> 00:16:53,199
is the right thing to call

00:16:51,199 --> 00:16:54,240
all functions are take into account

00:16:53,199 --> 00:16:56,880
because of

00:16:54,240 --> 00:16:58,160
the namespace of one of the operands one

00:16:56,880 --> 00:17:02,000
of the arguments

00:16:58,160 --> 00:17:02,000
hence argument dependent lookup

00:17:02,079 --> 00:17:05,839
if i would introduce a function g in a

00:17:04,720 --> 00:17:08,720
global namespace

00:17:05,839 --> 00:17:10,959
prior to namespace n1 and the thing that

00:17:08,720 --> 00:17:13,679
i passed this t

00:17:10,959 --> 00:17:14,720
would call the function f could be any

00:17:13,679 --> 00:17:17,600
type here

00:17:14,720 --> 00:17:18,000
function template and if in my main

00:17:17,600 --> 00:17:21,839
function

00:17:18,000 --> 00:17:24,799
i call g and pass an s still

00:17:21,839 --> 00:17:25,679
function three would be called despite

00:17:24,799 --> 00:17:28,400
the fact that g

00:17:25,679 --> 00:17:29,120
is defined before the name switch in one

00:17:28,400 --> 00:17:32,480
and so

00:17:29,120 --> 00:17:34,640
itself hasn't seen this f

00:17:32,480 --> 00:17:36,160
due to the late instantiation of this

00:17:34,640 --> 00:17:36,799
function still this is taking the

00:17:36,160 --> 00:17:39,039
account

00:17:36,799 --> 00:17:42,320
argument dependent lookup works

00:17:39,039 --> 00:17:42,320
perfectly in this context

00:17:43,280 --> 00:17:49,120
note that i said it additionally takes

00:17:46,559 --> 00:17:51,840
namespace and one into account

00:17:49,120 --> 00:17:53,280
if i would introduce another f in the

00:17:51,840 --> 00:17:56,320
global namespace

00:17:53,280 --> 00:17:59,440
that takes an n1s

00:17:56,320 --> 00:18:01,760
then a call to any f via g

00:17:59,440 --> 00:18:04,000
or f directly would actually be an

00:18:01,760 --> 00:18:04,640
ambiguous function call between function

00:18:04,000 --> 00:18:07,440
three and

00:18:04,640 --> 00:18:09,120
four the compiler would now find all

00:18:07,440 --> 00:18:11,120
these functions

00:18:09,120 --> 00:18:13,200
and three and four unfortunately are so

00:18:11,120 --> 00:18:14,400
similar that the compiler cannot decide

00:18:13,200 --> 00:18:15,919
which one is better

00:18:14,400 --> 00:18:17,600
this is the point where we say a

00:18:15,919 --> 00:18:19,200
function call is in biggest

00:18:17,600 --> 00:18:20,880
yeah we'll revisit this again when we

00:18:19,200 --> 00:18:23,120
talk about overload resolution

00:18:20,880 --> 00:18:25,039
but it finds both three and four both

00:18:23,120 --> 00:18:27,919
are equally well matched

00:18:25,039 --> 00:18:30,720
the compiler will fail in the oval

00:18:27,919 --> 00:18:32,799
resolution stage

00:18:30,720 --> 00:18:34,640
so guideline remember that argument

00:18:32,799 --> 00:18:36,000
dependent lookup only works for

00:18:34,640 --> 00:18:38,720
user-defined types

00:18:36,000 --> 00:18:40,080
does not work for fundamental types like

00:18:38,720 --> 00:18:43,840
int double

00:18:40,080 --> 00:18:43,840
pointers etc

00:18:44,160 --> 00:18:47,520
there is one additional thing that i

00:18:46,160 --> 00:18:49,600
want you to remember

00:18:47,520 --> 00:18:50,559
let's imagine that my s has a swap

00:18:49,600 --> 00:18:53,840
function

00:18:50,559 --> 00:18:56,080
that is supposed to swap to s

00:18:53,840 --> 00:18:57,360
now at some point for instance in a

00:18:56,080 --> 00:18:59,280
generic function g

00:18:57,360 --> 00:19:01,280
that takes two arguments i am calling

00:18:59,280 --> 00:19:04,640
the swap function

00:19:01,280 --> 00:19:08,480
so i have two s's s1 and s2

00:19:04,640 --> 00:19:10,080
i call g actually with s1 and s2 type on

00:19:08,480 --> 00:19:12,000
the slide

00:19:10,080 --> 00:19:13,919
these two ss are supposed to be swapped

00:19:12,000 --> 00:19:16,640
by means of this function

00:19:13,919 --> 00:19:17,600
which is actually not what is happening

00:19:16,640 --> 00:19:20,559
this will call

00:19:17,600 --> 00:19:22,160
std swap so it will call the function

00:19:20,559 --> 00:19:25,760
that i explicitly

00:19:22,160 --> 00:19:28,880
asked for std swap

00:19:25,760 --> 00:19:29,600
in order for adl to work i have to

00:19:28,880 --> 00:19:32,400
really use

00:19:29,600 --> 00:19:34,559
unqualified lookup so the advice here is

00:19:32,400 --> 00:19:38,080
not to qualify swap

00:19:34,559 --> 00:19:38,880
but to say using stdswap and to call the

00:19:38,080 --> 00:19:42,080
function

00:19:38,880 --> 00:19:42,559
unqualified standard swap is now an

00:19:42,080 --> 00:19:45,919
option

00:19:42,559 --> 00:19:48,000
but since i do find a batteries match

00:19:45,919 --> 00:19:50,080
thanks to argument dependent lookup the

00:19:48,000 --> 00:19:50,880
right swap function so the swap that

00:19:50,080 --> 00:19:53,840
swaps to s

00:19:50,880 --> 00:19:53,840
is called

00:19:54,320 --> 00:19:58,160
so prefer unqualified name log up to

00:19:56,720 --> 00:20:00,559
qualified name lookup

00:19:58,160 --> 00:20:02,720
and especially in generic code consider

00:20:00,559 --> 00:20:06,159
core guidelines c1 and 65

00:20:02,720 --> 00:20:08,720
use using for customization points this

00:20:06,159 --> 00:20:11,600
and only this will allow adl to do its

00:20:08,720 --> 00:20:11,600
job properly

00:20:12,000 --> 00:20:15,120
now there's one more effect in name

00:20:13,440 --> 00:20:18,559
lookup that i should mention

00:20:15,120 --> 00:20:20,880
and that is called two-phase lookup

00:20:18,559 --> 00:20:22,000
let's consider a function f that takes a

00:20:20,880 --> 00:20:24,159
double

00:20:22,000 --> 00:20:26,080
um this is my function one again

00:20:24,159 --> 00:20:28,320
function g from before

00:20:26,080 --> 00:20:29,919
now an additional function two in the

00:20:28,320 --> 00:20:33,120
global namespace defined

00:20:29,919 --> 00:20:34,240
after g and again struct s with the

00:20:33,120 --> 00:20:38,000
according function f

00:20:34,240 --> 00:20:39,120
this is my function three if in a main

00:20:38,000 --> 00:20:42,159
function i pass an

00:20:39,120 --> 00:20:44,080
s to g then this will actually call

00:20:42,159 --> 00:20:47,039
function three the write function

00:20:44,080 --> 00:20:48,000
based on argument dependent lookup

00:20:47,039 --> 00:20:49,760
because this works

00:20:48,000 --> 00:20:51,039
well many people would expect that the

00:20:49,760 --> 00:20:54,720
next call g

00:20:51,039 --> 00:20:56,799
of 42 will call function two

00:20:54,720 --> 00:20:58,559
but it doesn't well let me say it

00:20:56,799 --> 00:20:59,200
shouldn't some compilers actually did

00:20:58,559 --> 00:21:02,480
this wrong

00:20:59,200 --> 00:21:04,240
um so some years ago now hopefully

00:21:02,480 --> 00:21:05,840
everything's fixed this should call

00:21:04,240 --> 00:21:07,679
function one

00:21:05,840 --> 00:21:10,400
this is a fundamental type and so all

00:21:07,679 --> 00:21:12,080
the rules for fundamental types apply

00:21:10,400 --> 00:21:13,600
function two has not been seen

00:21:12,080 --> 00:21:16,080
officially at the point where g

00:21:13,600 --> 00:21:17,200
is defined so only function one is an

00:21:16,080 --> 00:21:19,520
option

00:21:17,200 --> 00:21:20,880
and so this function should ultimately

00:21:19,520 --> 00:21:24,240
be called

00:21:20,880 --> 00:21:24,960
since this g is instantiated only the

00:21:24,240 --> 00:21:28,159
point of

00:21:24,960 --> 00:21:30,400
call and since uh therefore it there is

00:21:28,159 --> 00:21:31,360
kind of two phases for looking up things

00:21:30,400 --> 00:21:33,760
in

00:21:31,360 --> 00:21:35,760
templates it's called to face lookup

00:21:33,760 --> 00:21:37,520
still the rules that as as i've

00:21:35,760 --> 00:21:39,840
explained them before are in effect

00:21:37,520 --> 00:21:42,000
archipelago argument dependent lookup

00:21:39,840 --> 00:21:43,919
for class types

00:21:42,000 --> 00:21:45,840
and the regular lookup for fundamental

00:21:43,919 --> 00:21:49,200
types

00:21:45,840 --> 00:21:49,760
so this concludes lookup if you have any

00:21:49,200 --> 00:21:51,760
questions

00:21:49,760 --> 00:21:53,760
please note them down i will answer any

00:21:51,760 --> 00:21:55,520
kind of question at the end of the talk

00:21:53,760 --> 00:21:57,039
please also additionally note down slide

00:21:55,520 --> 00:21:59,600
numbers which make

00:21:57,039 --> 00:22:02,480
will make it much much easier to go back

00:21:59,600 --> 00:22:04,080
to a specific slide

00:22:02,480 --> 00:22:07,600
so the next thing that we are taking a

00:22:04,080 --> 00:22:09,520
look at is template argument deduction

00:22:07,600 --> 00:22:11,360
template argument deduction however is a

00:22:09,520 --> 00:22:14,240
pretty complex beast in itself

00:22:11,360 --> 00:22:15,360
and so i defer you to talk from cppcon

00:22:14,240 --> 00:22:17,039
2014.

00:22:15,360 --> 00:22:18,480
scott myers had talked about type

00:22:17,039 --> 00:22:21,440
deduction why you care

00:22:18,480 --> 00:22:23,919
and this is a one over one hour talk

00:22:21,440 --> 00:22:25,840
just about c plus was type deduction

00:22:23,919 --> 00:22:27,919
not aware of any talk that summarizes

00:22:25,840 --> 00:22:30,080
this better this really explains how

00:22:27,919 --> 00:22:33,679
type deduction works the simpler cases

00:22:30,080 --> 00:22:35,600
but also the more complex cases

00:22:33,679 --> 00:22:36,720
there's always another effect that you

00:22:35,600 --> 00:22:39,280
might consider

00:22:36,720 --> 00:22:40,080
something called sphinae also here i

00:22:39,280 --> 00:22:42,720
have hardly

00:22:40,080 --> 00:22:44,480
uh enough time to mention it but there

00:22:42,720 --> 00:22:45,280
is a good talk about this special effect

00:22:44,480 --> 00:22:48,159
given by arthur

00:22:45,280 --> 00:22:48,159
dwyer called us

00:22:48,799 --> 00:22:52,159
so as he himself says at the very

00:22:50,480 --> 00:22:54,320
beginning of the talk the hardest thing

00:22:52,159 --> 00:22:56,240
about this talk is probably the title

00:22:54,320 --> 00:22:58,000
superstar means a very small quantity of

00:22:56,240 --> 00:22:59,840
something so it is intended to be a

00:22:58,000 --> 00:23:01,360
beginner-friendly introduction

00:22:59,840 --> 00:23:04,000
of something that's not necessarily

00:23:01,360 --> 00:23:06,159
beginner friendly so watch this talk

00:23:04,000 --> 00:23:07,440
any other talk about spinae they will

00:23:06,159 --> 00:23:09,760
give you a pretty good idea what to

00:23:07,440 --> 00:23:11,600
expect here

00:23:09,760 --> 00:23:14,880
which however brings us directly to the

00:23:11,600 --> 00:23:16,640
third step overlap resolution

00:23:14,880 --> 00:23:18,240
overlap resolution is probably one of

00:23:16,640 --> 00:23:21,440
the most complex steps

00:23:18,240 --> 00:23:24,080
in this entire thing and definitely also

00:23:21,440 --> 00:23:25,760
takes a lot of space in the standard

00:23:24,080 --> 00:23:28,880
itself

00:23:25,760 --> 00:23:31,760
all the resolution itself is

00:23:28,880 --> 00:23:33,760
split into two steps the first step is

00:23:31,760 --> 00:23:36,159
to compile a list of

00:23:33,760 --> 00:23:37,280
viable candidates so from all the

00:23:36,159 --> 00:23:38,880
functions that i get

00:23:37,280 --> 00:23:41,039
from both name lookup and template

00:23:38,880 --> 00:23:42,080
argument deduction figure out which

00:23:41,039 --> 00:23:45,279
functions are actually

00:23:42,080 --> 00:23:47,679
callable by the given arguments

00:23:45,279 --> 00:23:48,960
so what is a viable or not viable

00:23:47,679 --> 00:23:51,440
candidate

00:23:48,960 --> 00:23:52,320
so assuming that i have a function f

00:23:51,440 --> 00:23:55,600
where i pass

00:23:52,320 --> 00:23:57,200
a 42. not a single argument a single

00:23:55,600 --> 00:23:58,799
integer argument

00:23:57,200 --> 00:24:00,480
then a viable candidate could be a

00:23:58,799 --> 00:24:02,720
function that takes an int

00:24:00,480 --> 00:24:04,559
that would be a so-called identity or

00:24:02,720 --> 00:24:06,480
exact match

00:24:04,559 --> 00:24:08,799
it could be a function that requires me

00:24:06,480 --> 00:24:10,960
to pass a consonant ref

00:24:08,799 --> 00:24:12,559
this is called a trivial conversion i

00:24:10,960 --> 00:24:14,480
simply add a const

00:24:12,559 --> 00:24:16,400
to this end which is always possible

00:24:14,480 --> 00:24:17,760
this is fine

00:24:16,400 --> 00:24:19,600
i could also call a function that

00:24:17,760 --> 00:24:21,520
requires me to convert the integer to

00:24:19,600 --> 00:24:25,200
something that it can be converted to

00:24:21,520 --> 00:24:26,480
so a standard conversion i could also

00:24:25,200 --> 00:24:29,520
call a function

00:24:26,480 --> 00:24:32,080
that uses expects a class type

00:24:29,520 --> 00:24:34,320
because this class type might actually

00:24:32,080 --> 00:24:36,080
have a non-explicit constructor

00:24:34,320 --> 00:24:37,360
that allows a conversion from a

00:24:36,080 --> 00:24:40,000
particular argument

00:24:37,360 --> 00:24:41,600
into class type then this function is an

00:24:40,000 --> 00:24:43,679
option

00:24:41,600 --> 00:24:44,720
i could also call functions that take

00:24:43,679 --> 00:24:46,559
more arguments

00:24:44,720 --> 00:24:48,400
but where all the arguments that i do

00:24:46,559 --> 00:24:50,400
not pass explicitly have default

00:24:48,400 --> 00:24:52,640
arguments

00:24:50,400 --> 00:24:53,840
also all the functions that have

00:24:52,640 --> 00:24:56,400
matching constraints

00:24:53,840 --> 00:24:58,080
are an option so this function expects

00:24:56,400 --> 00:25:01,120
any kind of integral

00:24:58,080 --> 00:25:01,679
and so this works splendidly and of

00:25:01,120 --> 00:25:04,400
course

00:25:01,679 --> 00:25:05,440
as a last resort all functions that take

00:25:04,400 --> 00:25:09,120
ellipses arguments

00:25:05,440 --> 00:25:10,559
also would work non-viable candidates

00:25:09,120 --> 00:25:13,760
would be functions that take

00:25:10,559 --> 00:25:16,880
less parameters than i have arguments or

00:25:13,760 --> 00:25:19,919
more parameters than i have arguments

00:25:16,880 --> 00:25:21,919
functions that provide expect things

00:25:19,919 --> 00:25:23,440
that i cannot convert to

00:25:21,919 --> 00:25:25,200
like here in this example for instance a

00:25:23,440 --> 00:25:28,080
standard string or

00:25:25,200 --> 00:25:30,480
last but not least functions that have

00:25:28,080 --> 00:25:34,159
constraints that i cannot

00:25:30,480 --> 00:25:37,600
match so violated constraints

00:25:34,159 --> 00:25:40,159
so i already have removed a couple of

00:25:37,600 --> 00:25:41,360
the candidates and i'm left with viable

00:25:40,159 --> 00:25:44,400
candidates

00:25:41,360 --> 00:25:45,919
with these viable candidates i now try

00:25:44,400 --> 00:25:47,679
to find the best match

00:25:45,919 --> 00:25:49,039
i determine from all of these functions

00:25:47,679 --> 00:25:53,120
the one function

00:25:49,039 --> 00:25:55,039
that i should call in the end

00:25:53,120 --> 00:25:56,880
in order to make this a little simpler i

00:25:55,039 --> 00:25:59,360
know just passing a single argument

00:25:56,880 --> 00:26:00,799
i'll tell you afterwards how we deal

00:25:59,360 --> 00:26:02,640
with several parameters

00:26:00,799 --> 00:26:04,320
but for understanding the thing a single

00:26:02,640 --> 00:26:09,200
parameter is probably

00:26:04,320 --> 00:26:12,720
good enough so the first

00:26:09,200 --> 00:26:14,960
the thing i do is i actually rank things

00:26:12,720 --> 00:26:16,720
the best thing that can happen to me is

00:26:14,960 --> 00:26:19,200
an exact or identity

00:26:16,720 --> 00:26:20,880
match the second best thing that could

00:26:19,200 --> 00:26:22,799
happen is that i just have to add a

00:26:20,880 --> 00:26:24,320
const or something trivial

00:26:22,799 --> 00:26:26,880
these kinds of trivial conversion are

00:26:24,320 --> 00:26:29,760
also absolutely fine

00:26:26,880 --> 00:26:30,480
these two things are ranked as one

00:26:29,760 --> 00:26:32,080
officially

00:26:30,480 --> 00:26:34,880
there is in the standard the

00:26:32,080 --> 00:26:38,000
specification that this is a rank one

00:26:34,880 --> 00:26:39,520
match then there is something called a

00:26:38,000 --> 00:26:41,440
promotion

00:26:39,520 --> 00:26:44,480
and of course a promotion could be

00:26:41,440 --> 00:26:47,760
combined with a trivial conversion

00:26:44,480 --> 00:26:50,559
these two are ranked as two

00:26:47,760 --> 00:26:52,559
so they're not as good as rank one but

00:26:50,559 --> 00:26:55,760
the second best thing

00:26:52,559 --> 00:26:57,520
after that i have standard conversions

00:26:55,760 --> 00:26:59,840
and of course also standard conversions

00:26:57,520 --> 00:27:03,120
plus trivial conversions

00:26:59,840 --> 00:27:03,919
this is ranked three yeah and as such it

00:27:03,120 --> 00:27:06,799
is

00:27:03,919 --> 00:27:07,360
not as good as an exact match or a rank

00:27:06,799 --> 00:27:10,640
one or

00:27:07,360 --> 00:27:13,679
in two but it is still better than

00:27:10,640 --> 00:27:15,760
a user-defined conversion a user-defined

00:27:13,679 --> 00:27:17,520
conversion with a triple conversion

00:27:15,760 --> 00:27:19,279
or a user-defined conversion and a

00:27:17,520 --> 00:27:21,440
standard conversion

00:27:19,279 --> 00:27:23,600
these do not have an official rank but

00:27:21,440 --> 00:27:26,559
mentally we can give it a rank of course

00:27:23,600 --> 00:27:27,200
like rank four and the last thing that

00:27:26,559 --> 00:27:29,360
could happen

00:27:27,200 --> 00:27:31,279
is calling an ellipsis argument this

00:27:29,360 --> 00:27:34,399
would be something like a rank five

00:27:31,279 --> 00:27:36,399
inofficially of course now let's take a

00:27:34,399 --> 00:27:39,840
look at a couple of examples

00:27:36,399 --> 00:27:43,120
so let's say that i have an integer 42

00:27:39,840 --> 00:27:44,480
and then i pass this to function f

00:27:43,120 --> 00:27:46,480
name lookup came up with these two

00:27:44,480 --> 00:27:48,559
functions function f that takes an

00:27:46,480 --> 00:27:50,640
integer reference and a function that

00:27:48,559 --> 00:27:54,000
takes a double

00:27:50,640 --> 00:27:55,600
now the process is pretty simple i rank

00:27:54,000 --> 00:27:58,480
these functions based on the given

00:27:55,600 --> 00:28:01,360
arguments for function one i actually

00:27:58,480 --> 00:28:04,080
get a rank one it's an identity match i

00:28:01,360 --> 00:28:06,000
don't even have to add a const here

00:28:04,080 --> 00:28:09,200
for function two i rank this as a

00:28:06,000 --> 00:28:11,600
conversion so rank three

00:28:09,200 --> 00:28:14,080
so it's obvious function one should be

00:28:11,600 --> 00:28:16,559
called because it has a much lower rank

00:28:14,080 --> 00:28:18,320
than the second function so function one

00:28:16,559 --> 00:28:20,480
is called

00:28:18,320 --> 00:28:22,559
if in this example i add a third

00:28:20,480 --> 00:28:24,799
function a function takes a

00:28:22,559 --> 00:28:26,240
constant integer it becomes a little

00:28:24,799 --> 00:28:28,640
more interesting

00:28:26,240 --> 00:28:29,679
function one is still ranked one

00:28:28,640 --> 00:28:32,399
function three

00:28:29,679 --> 00:28:32,720
sorry two is still ranked rank three and

00:28:32,399 --> 00:28:35,679
the

00:28:32,720 --> 00:28:36,799
third function is actually also ranked

00:28:35,679 --> 00:28:40,559
one

00:28:36,799 --> 00:28:43,039
a trivial conversion is still a rank one

00:28:40,559 --> 00:28:45,120
still intuitively we would argue that

00:28:43,039 --> 00:28:46,640
function one is a little bit better

00:28:45,120 --> 00:28:48,960
because after all the inter that i'm

00:28:46,640 --> 00:28:50,640
passing here is not const qualified

00:28:48,960 --> 00:28:53,120
so we believe the identity match is

00:28:50,640 --> 00:28:55,039
better than the trigger conversion

00:28:53,120 --> 00:28:57,520
still they're both rank one this is why

00:28:55,039 --> 00:29:00,240
we need a tie breaker

00:28:57,520 --> 00:29:01,600
if you for instance go to cpp reference

00:29:00,240 --> 00:29:03,840
you will actually find

00:29:01,600 --> 00:29:04,880
a very very good article about overlap

00:29:03,840 --> 00:29:07,120
resolution

00:29:04,880 --> 00:29:08,000
it is a pretty lengthy article but it is

00:29:07,120 --> 00:29:10,080
definitely

00:29:08,000 --> 00:29:12,240
worth to read in its entirety to get a

00:29:10,080 --> 00:29:14,640
better feeling of what is possible

00:29:12,240 --> 00:29:16,240
so i simply scroll down now to the point

00:29:14,640 --> 00:29:18,320
that gives us an indication what happens

00:29:16,240 --> 00:29:20,640
in this particular case

00:29:18,320 --> 00:29:22,159
so we are ranking implicit conversions

00:29:20,640 --> 00:29:24,080
now

00:29:22,159 --> 00:29:25,520
and it says a standard conversion

00:29:24,080 --> 00:29:27,520
sequence s1

00:29:25,520 --> 00:29:29,840
is better than a standard conversion

00:29:27,520 --> 00:29:32,240
sequence as to if

00:29:29,840 --> 00:29:33,279
now we have to scroll down a little more

00:29:32,240 --> 00:29:35,200
if both

00:29:33,279 --> 00:29:38,240
s1 and s2 are binding to reference

00:29:35,200 --> 00:29:39,520
parameter only different in top level cv

00:29:38,240 --> 00:29:42,559
qualification

00:29:39,520 --> 00:29:44,320
and s1's type is less c way qualified

00:29:42,559 --> 00:29:46,080
than s2s

00:29:44,320 --> 00:29:48,399
so it also gives the example that i just

00:29:46,080 --> 00:29:49,840
have function f that has a constant ref

00:29:48,399 --> 00:29:51,840
and an interest

00:29:49,840 --> 00:29:53,600
and if i just pass an int which is not

00:29:51,840 --> 00:29:55,200
const qualified the first function

00:29:53,600 --> 00:29:57,760
should win

00:29:55,200 --> 00:29:59,760
so this is exactly what happens here too

00:29:57,760 --> 00:30:01,120
this will call function one thanks to

00:29:59,760 --> 00:30:02,960
this special rule

00:30:01,120 --> 00:30:05,919
that breaks the tie between these two

00:30:02,960 --> 00:30:05,919
rank one functions

00:30:07,520 --> 00:30:13,360
so if indeed two functions

00:30:10,880 --> 00:30:15,279
are matched equally so for instance in

00:30:13,360 --> 00:30:17,840
this example where i have two functions

00:30:15,279 --> 00:30:18,720
f one takes a float function one one

00:30:17,840 --> 00:30:22,000
takes a double

00:30:18,720 --> 00:30:23,600
function two and i pass an integer then

00:30:22,000 --> 00:30:24,720
both functions would be ranked as

00:30:23,600 --> 00:30:27,120
standard conversion

00:30:24,720 --> 00:30:27,919
rank three yes it's different standard

00:30:27,120 --> 00:30:29,760
conversions

00:30:27,919 --> 00:30:32,000
but still none of them is considered

00:30:29,760 --> 00:30:34,480
better it is both rank three

00:30:32,000 --> 00:30:36,799
there is no special rule available this

00:30:34,480 --> 00:30:40,640
function is now ambiguous

00:30:36,799 --> 00:30:43,679
same rank no special rule

00:30:40,640 --> 00:30:45,840
if you have an ambiguous function call

00:30:43,679 --> 00:30:47,200
as i said before there's no going back

00:30:45,840 --> 00:30:48,960
looking for other functions

00:30:47,200 --> 00:30:50,640
this is a hard compilation error it

00:30:48,960 --> 00:30:51,919
would stop at this point and you would

00:30:50,640 --> 00:30:54,080
get an error message

00:30:51,919 --> 00:30:55,919
that pretty clearly expresses that the

00:30:54,080 --> 00:30:56,640
compiler cannot decide which function to

00:30:55,919 --> 00:30:58,480
call

00:30:56,640 --> 00:31:00,159
usually we'll also get a list of all

00:30:58,480 --> 00:31:02,000
functions that are considered viable

00:31:00,159 --> 00:31:04,080
candidates

00:31:02,000 --> 00:31:05,200
and you will see close matches for those

00:31:04,080 --> 00:31:09,200
that are considered

00:31:05,200 --> 00:31:09,200
as best matches so far

00:31:10,720 --> 00:31:14,799
there is one very interesting special

00:31:12,640 --> 00:31:17,840
rule that is also to some extent

00:31:14,799 --> 00:31:19,200
uh confusing sometimes let's keep the

00:31:17,840 --> 00:31:21,440
example as it was before

00:31:19,200 --> 00:31:23,279
i call a function f with an integer but

00:31:21,440 --> 00:31:26,480
now the two functions are

00:31:23,279 --> 00:31:27,039
a non-template function one and a

00:31:26,480 --> 00:31:28,640
template

00:31:27,039 --> 00:31:31,120
where i use one of these new fancy c

00:31:28,640 --> 00:31:34,559
plus 20 constants

00:31:31,120 --> 00:31:36,399
both functions are viable candidates

00:31:34,559 --> 00:31:38,320
in the argument deduction phase function

00:31:36,399 --> 00:31:38,799
2 is transformed into function can

00:31:38,320 --> 00:31:41,519
actually

00:31:38,799 --> 00:31:42,320
call which would be something like that

00:31:41,519 --> 00:31:44,320
it's a function

00:31:42,320 --> 00:31:47,679
resulting from a template and this

00:31:44,320 --> 00:31:49,279
function takes an integer 2.

00:31:47,679 --> 00:31:50,640
the interesting thing to note here is

00:31:49,279 --> 00:31:51,200
that these two functions are now

00:31:50,640 --> 00:31:53,760
virtually

00:31:51,200 --> 00:31:55,279
identical that can happen due to

00:31:53,760 --> 00:31:57,600
template instantiation

00:31:55,279 --> 00:31:58,840
i have two functions that take exactly

00:31:57,600 --> 00:32:02,000
the same

00:31:58,840 --> 00:32:02,799
argument and still we can come to

00:32:02,000 --> 00:32:05,200
conclusion

00:32:02,799 --> 00:32:06,799
so of course both would now be ranked

00:32:05,200 --> 00:32:09,039
one

00:32:06,799 --> 00:32:10,720
again there's a special rule in the

00:32:09,039 --> 00:32:14,720
overlord resolution

00:32:10,720 --> 00:32:17,360
set of rules so it is this one

00:32:14,720 --> 00:32:19,120
f1 function one is determined to be

00:32:17,360 --> 00:32:21,200
better function than f2

00:32:19,120 --> 00:32:22,720
if implicit conversions for all

00:32:21,200 --> 00:32:24,960
arguments of f1 are

00:32:22,720 --> 00:32:27,039
not worse than the implicit conversions

00:32:24,960 --> 00:32:30,960
for all arguments f2

00:32:27,039 --> 00:32:34,080
and special case f1 is a none

00:32:30,960 --> 00:32:35,919
template function while f2 is a template

00:32:34,080 --> 00:32:37,919
for specialization

00:32:35,919 --> 00:32:41,200
a specialization used here as

00:32:37,919 --> 00:32:44,000
instantiation of a template

00:32:41,200 --> 00:32:44,559
so none templates if indeed they are

00:32:44,000 --> 00:32:47,120
equally

00:32:44,559 --> 00:32:49,840
well matched have preference so in this

00:32:47,120 --> 00:32:52,000
case function one would be called

00:32:49,840 --> 00:32:53,200
this usually only happens if you really

00:32:52,000 --> 00:32:56,320
have best match

00:32:53,200 --> 00:32:58,640
or identity matches so rank once because

00:32:56,320 --> 00:33:00,399
templates tend to be exact matches or

00:32:58,640 --> 00:33:02,399
identity matches

00:33:00,399 --> 00:33:04,080
but in that case the none template is

00:33:02,399 --> 00:33:04,960
preferred because else it wouldn't be

00:33:04,080 --> 00:33:06,640
called anywhere

00:33:04,960 --> 00:33:10,480
couldn't be called anywhere it's a

00:33:06,640 --> 00:33:14,799
pretty reasonable rule

00:33:10,480 --> 00:33:17,039
so let's talk about promotions rank two

00:33:14,799 --> 00:33:18,480
the standard defines a small set of

00:33:17,039 --> 00:33:21,120
special conversions

00:33:18,480 --> 00:33:23,360
which we call promotions so for instance

00:33:21,120 --> 00:33:24,399
an unsigned short can be converted to an

00:33:23,360 --> 00:33:27,200
unsending

00:33:24,399 --> 00:33:29,440
print depending on your platform a short

00:33:27,200 --> 00:33:32,159
can be converted into nint

00:33:29,440 --> 00:33:32,640
a jar can be converted into need runs

00:33:32,159 --> 00:33:34,880
and didn't

00:33:32,640 --> 00:33:37,279
depending on your platform and a bool

00:33:34,880 --> 00:33:40,720
can be converted to int

00:33:37,279 --> 00:33:41,200
that is integral promotions and there is

00:33:40,720 --> 00:33:43,440
also

00:33:41,200 --> 00:33:46,159
one available floating point promotion

00:33:43,440 --> 00:33:49,360
float can be converted to double

00:33:46,159 --> 00:33:53,120
and this is considered better than other

00:33:49,360 --> 00:33:56,159
kinds of conversions so rank two

00:33:53,120 --> 00:33:59,039
promotion is considered better than

00:33:56,159 --> 00:34:00,080
any other kind of conversion so for

00:33:59,039 --> 00:34:02,960
instance here

00:34:00,080 --> 00:34:04,080
i have a short again set to 42 and i

00:34:02,960 --> 00:34:07,200
call f within

00:34:04,080 --> 00:34:08,720
with this short i only have a function f

00:34:07,200 --> 00:34:11,040
that takes an end and one that takes a

00:34:08,720 --> 00:34:11,040
double

00:34:11,520 --> 00:34:15,679
for from everything i've said so far you

00:34:13,760 --> 00:34:18,399
would assume it's both conversions

00:34:15,679 --> 00:34:19,280
but now i mentioned these promotions the

00:34:18,399 --> 00:34:21,839
first function

00:34:19,280 --> 00:34:22,320
is actually a special kind of conversion

00:34:21,839 --> 00:34:25,679
short

00:34:22,320 --> 00:34:27,839
to int it gets a rank two and the other

00:34:25,679 --> 00:34:30,639
one gets only rank three

00:34:27,839 --> 00:34:31,440
so function one wins because it is

00:34:30,639 --> 00:34:34,079
better ranked

00:34:31,440 --> 00:34:36,399
as a lower rank i prefer the promotion

00:34:34,079 --> 00:34:40,720
to the standard conversion

00:34:36,399 --> 00:34:44,240
if instead i would have a float

00:34:40,720 --> 00:34:46,320
then okay also typos

00:34:44,240 --> 00:34:48,240
shouldn't be called f but then in this

00:34:46,320 --> 00:34:51,440
case i would actually prefer

00:34:48,240 --> 00:34:52,800
the second function the first would be a

00:34:51,440 --> 00:34:55,599
standard conversion

00:34:52,800 --> 00:34:57,680
rank three the second would be a

00:34:55,599 --> 00:35:00,640
promotional float to double

00:34:57,680 --> 00:35:00,640
is a promotion

00:35:01,119 --> 00:35:04,960
so this calls function two in this

00:35:02,880 --> 00:35:07,520
example

00:35:04,960 --> 00:35:08,640
everything else everything that is not a

00:35:07,520 --> 00:35:11,040
promotion

00:35:08,640 --> 00:35:13,440
is a standard conversion and there is a

00:35:11,040 --> 00:35:15,599
whole bunch of possibilities here

00:35:13,440 --> 00:35:17,920
there's of course integral conversions

00:35:15,599 --> 00:35:19,760
conversions between two integers

00:35:17,920 --> 00:35:21,359
there is floating point conversions

00:35:19,760 --> 00:35:22,079
conversions between two floating point

00:35:21,359 --> 00:35:23,599
numbers

00:35:22,079 --> 00:35:25,760
there's integral to floating point

00:35:23,599 --> 00:35:27,680
conversions and also floating point to

00:35:25,760 --> 00:35:29,920
integral conversions

00:35:27,680 --> 00:35:31,760
there is pointer conversions so for

00:35:29,920 --> 00:35:34,880
instance you can always convert

00:35:31,760 --> 00:35:36,400
derived pointed to derived to a pointer

00:35:34,880 --> 00:35:38,240
to base

00:35:36,400 --> 00:35:40,000
and you can always convert a pointer to

00:35:38,240 --> 00:35:43,680
void pointer

00:35:40,000 --> 00:35:44,160
bool a lot of things can also be

00:35:43,680 --> 00:35:47,920
converted

00:35:44,160 --> 00:35:50,640
to bool so um

00:35:47,920 --> 00:35:51,280
integers can be converted to bool just

00:35:50,640 --> 00:35:53,839
as any

00:35:51,280 --> 00:35:58,320
expression that um evaluates to anything

00:35:53,839 --> 00:36:01,440
that can be converted to bool

00:35:58,320 --> 00:36:04,320
so one example if i have an unsigned int

00:36:01,440 --> 00:36:05,760
42 again i put this into the function

00:36:04,320 --> 00:36:08,079
then this

00:36:05,760 --> 00:36:10,240
function this can be actually be called

00:36:08,079 --> 00:36:10,960
i would simply convert the onset into

00:36:10,240 --> 00:36:13,280
double

00:36:10,960 --> 00:36:15,359
and this would be ranked three standard

00:36:13,280 --> 00:36:17,599
conversion

00:36:15,359 --> 00:36:18,800
if i would have a function it takes an

00:36:17,599 --> 00:36:20,880
end

00:36:18,800 --> 00:36:22,960
it also could be called this would be a

00:36:20,880 --> 00:36:26,160
conversion from unsending to int

00:36:22,960 --> 00:36:30,480
so again this is rank three i call

00:36:26,160 --> 00:36:33,119
function1 interestingly

00:36:30,480 --> 00:36:34,240
and perhaps a little unintuitively if

00:36:33,119 --> 00:36:36,640
the functions

00:36:34,240 --> 00:36:38,880
f with double and function f with int

00:36:36,640 --> 00:36:42,000
come together

00:36:38,880 --> 00:36:44,000
then this call here is not calling

00:36:42,000 --> 00:36:45,040
function2 despite the fact that this is

00:36:44,000 --> 00:36:47,839
integral

00:36:45,040 --> 00:36:49,680
now both functions are considered

00:36:47,839 --> 00:36:52,800
standard conversions

00:36:49,680 --> 00:36:53,680
both are ranked with three there is no

00:36:52,800 --> 00:36:55,680
special rule

00:36:53,680 --> 00:36:57,200
to say that this unsigned integer should

00:36:55,680 --> 00:36:59,359
go to the end

00:36:57,200 --> 00:37:01,119
this will again be an ambiguous function

00:36:59,359 --> 00:37:04,240
call same rank

00:37:01,119 --> 00:37:05,520
no special rule to keep them apart so a

00:37:04,240 --> 00:37:09,359
standard conversion

00:37:05,520 --> 00:37:11,280
even if it is um so in

00:37:09,359 --> 00:37:13,599
integral to integral is not better than

00:37:11,280 --> 00:37:15,280
any other kind of conversion

00:37:13,599 --> 00:37:17,440
which is again something that is

00:37:15,280 --> 00:37:22,240
supposed to protect you from

00:37:17,440 --> 00:37:24,560
unfortunate conversions

00:37:22,240 --> 00:37:26,480
of course this works as i said before in

00:37:24,560 --> 00:37:28,960
uh class hierarchies as well

00:37:26,480 --> 00:37:30,400
so just as one quick example let's

00:37:28,960 --> 00:37:33,520
consider a class a

00:37:30,400 --> 00:37:36,720
that is used to define a b

00:37:33,520 --> 00:37:38,880
which is used to define a c if i have

00:37:36,720 --> 00:37:40,960
two functions that

00:37:38,880 --> 00:37:42,160
one function that takes an a pointer and

00:37:40,960 --> 00:37:45,280
one function takes a b

00:37:42,160 --> 00:37:46,079
pointer function one and two again and

00:37:45,280 --> 00:37:49,440
if a c

00:37:46,079 --> 00:37:51,599
pass the address of c to this f

00:37:49,440 --> 00:37:53,040
then actually function two would be

00:37:51,599 --> 00:37:55,440
called both

00:37:53,040 --> 00:37:56,640
are pointer conversions both would be

00:37:55,440 --> 00:37:58,480
ranked of three

00:37:56,640 --> 00:37:59,920
but for that particular case there's

00:37:58,480 --> 00:38:02,720
again a special rule

00:37:59,920 --> 00:38:04,800
that actually helps to disambiguate so

00:38:02,720 --> 00:38:07,760
this will call function2

00:38:04,800 --> 00:38:09,440
because the pointer to c is a little

00:38:07,760 --> 00:38:11,839
closer to the pointer to b

00:38:09,440 --> 00:38:13,839
than it is to the point of a pretty

00:38:11,839 --> 00:38:17,280
reasonable and intuitive again

00:38:13,839 --> 00:38:19,839
so again here it works in this way as

00:38:17,280 --> 00:38:19,839
you would expect

00:38:22,320 --> 00:38:26,960
everything that goes beyond standard

00:38:24,400 --> 00:38:30,160
conversions is user-defined conversions

00:38:26,960 --> 00:38:31,599
so for instance if a widget class that i

00:38:30,160 --> 00:38:34,240
define myself

00:38:31,599 --> 00:38:35,760
has a construct that takes an int and a

00:38:34,240 --> 00:38:38,079
constructor takes a double

00:38:35,760 --> 00:38:40,480
these two constructors which both are

00:38:38,079 --> 00:38:43,599
non-explicit can be used to convert

00:38:40,480 --> 00:38:45,119
from fundamental types to widget and

00:38:43,599 --> 00:38:46,880
also

00:38:45,119 --> 00:38:49,680
you could have in a class so-called

00:38:46,880 --> 00:38:51,760
conversion operators

00:38:49,680 --> 00:38:52,880
they cure is because they do not have a

00:38:51,760 --> 00:38:54,800
return type

00:38:52,880 --> 00:38:56,480
but the return type implicitly is the

00:38:54,800 --> 00:38:58,240
thing that you are

00:38:56,480 --> 00:39:00,000
mentioning after so this conversion

00:38:58,240 --> 00:39:02,160
operator allows you to convert a widget

00:39:00,000 --> 00:39:03,839
into an int this conversion operator

00:39:02,160 --> 00:39:05,599
allows you to convert a widget into

00:39:03,839 --> 00:39:07,359
double

00:39:05,599 --> 00:39:09,359
both constructors and conversion

00:39:07,359 --> 00:39:10,400
operators can be used for user defined

00:39:09,359 --> 00:39:13,280
conversions

00:39:10,400 --> 00:39:14,240
for instance in the following way again

00:39:13,280 --> 00:39:16,880
i have an integer

00:39:14,240 --> 00:39:17,599
that i pass to a function and now i have

00:39:16,880 --> 00:39:21,680
two functions

00:39:17,599 --> 00:39:23,440
f one takes a long one takes a widget

00:39:21,680 --> 00:39:25,200
a note again the widget has a

00:39:23,440 --> 00:39:27,760
constructor that takes an

00:39:25,200 --> 00:39:30,079
int so i can construct a widget by means

00:39:27,760 --> 00:39:32,720
of an int

00:39:30,079 --> 00:39:33,920
in this particular example function one

00:39:32,720 --> 00:39:37,040
would be ranked

00:39:33,920 --> 00:39:40,079
three it would be a conversion from into

00:39:37,040 --> 00:39:43,040
too long so a standard conversion

00:39:40,079 --> 00:39:45,200
the second function however is ranked as

00:39:43,040 --> 00:39:48,480
a user-defined conversion

00:39:45,200 --> 00:39:52,560
so in this particular case function one

00:39:48,480 --> 00:39:53,040
wins despite the fact that this widget

00:39:52,560 --> 00:39:56,560
takes an

00:39:53,040 --> 00:39:58,960
int and a half an it either way

00:39:56,560 --> 00:39:59,680
standard conversions are always ranked

00:39:58,960 --> 00:40:01,760
better

00:39:59,680 --> 00:40:04,000
considered to be better than any kind of

00:40:01,760 --> 00:40:05,200
user conversion even if it appears to

00:40:04,000 --> 00:40:08,800
match better

00:40:05,200 --> 00:40:10,319
intuitively so there is also one

00:40:08,800 --> 00:40:12,400
special rule that explains this pretty

00:40:10,319 --> 00:40:13,599
well in the ranking of implicit

00:40:12,400 --> 00:40:17,200
conversion sequence

00:40:13,599 --> 00:40:17,599
uh part a standard conversion sequence

00:40:17,200 --> 00:40:20,160
is

00:40:17,599 --> 00:40:21,760
always better than a user-defined

00:40:20,160 --> 00:40:24,160
conversion sequence

00:40:21,760 --> 00:40:25,839
or an ellipsis conversion sequence so

00:40:24,160 --> 00:40:26,880
indeed we can think of a user-defined

00:40:25,839 --> 00:40:29,440
conversion

00:40:26,880 --> 00:40:31,520
as an inofficial rank 4 which doesn't

00:40:29,440 --> 00:40:33,599
exist officially but

00:40:31,520 --> 00:40:36,000
we can imagine that it indeed is ranked

00:40:33,599 --> 00:40:36,000
as such

00:40:36,560 --> 00:40:39,839
now if you have user-defined conversions

00:40:39,280 --> 00:40:41,760
only

00:40:39,839 --> 00:40:43,920
like here in this example we have a

00:40:41,760 --> 00:40:46,079
widget that takes an int

00:40:43,920 --> 00:40:47,760
a constructor that takes an int and a

00:40:46,079 --> 00:40:50,800
widget constructor it takes a double

00:40:47,760 --> 00:40:52,400
constructor one constructor two and i

00:40:50,800 --> 00:40:54,240
have a function takes widget

00:40:52,400 --> 00:40:57,839
and i call this function by means of an

00:40:54,240 --> 00:41:00,720
int again the intuitive things happen

00:40:57,839 --> 00:41:02,240
it is a user defined conversion because

00:41:00,720 --> 00:41:05,280
i have to create a widget

00:41:02,240 --> 00:41:07,520
from this integer but constructor one

00:41:05,280 --> 00:41:09,280
is just a user-defined conversion

00:41:07,520 --> 00:41:10,000
whereas constructor 2 is a user-defined

00:41:09,280 --> 00:41:12,480
diversion

00:41:10,000 --> 00:41:13,200
and a standard conversion so integer has

00:41:12,480 --> 00:41:16,000
to addition

00:41:13,200 --> 00:41:17,680
be additionally converted to a double

00:41:16,000 --> 00:41:20,800
this is why constructor 1

00:41:17,680 --> 00:41:24,880
is considered better better match

00:41:20,800 --> 00:41:28,800
so i call function1 and

00:41:24,880 --> 00:41:28,800
function2 is not considered anymore

00:41:30,160 --> 00:41:34,079
if however i have a short i again set to

00:41:33,520 --> 00:41:37,119
00:41:34,079 --> 00:41:38,960
and call function f accordingly then

00:41:37,119 --> 00:41:40,400
this is a user defined program version

00:41:38,960 --> 00:41:41,839
plus a promotion

00:41:40,400 --> 00:41:43,680
whereas function 2 is again a

00:41:41,839 --> 00:41:45,359
user-defined coloration plus a standard

00:41:43,680 --> 00:41:46,960
conversion

00:41:45,359 --> 00:41:48,400
a promotion is always better than a

00:41:46,960 --> 00:41:51,200
standard conversion

00:41:48,400 --> 00:41:52,000
so i again consider function one the

00:41:51,200 --> 00:41:53,440
better match

00:41:52,000 --> 00:41:55,440
and call function one instead of

00:41:53,440 --> 00:41:58,240
function two

00:41:55,440 --> 00:41:59,839
there is the according um the

00:41:58,240 --> 00:42:01,440
descriptions again in cp

00:41:59,839 --> 00:42:03,680
reference or of course the standard

00:42:01,440 --> 00:42:04,319
itself we just have to scroll down a

00:42:03,680 --> 00:42:07,680
little bit

00:42:04,319 --> 00:42:10,720
and go to item 4 here

00:42:07,680 --> 00:42:12,880
a user defined conversion sequence u1 is

00:42:10,720 --> 00:42:14,480
better than a user-defined conversion

00:42:12,880 --> 00:42:17,119
sequence u2

00:42:14,480 --> 00:42:18,800
if they call the same constructor slash

00:42:17,119 --> 00:42:20,400
user-defined conversion function

00:42:18,800 --> 00:42:22,000
or initialize the same class with our

00:42:20,400 --> 00:42:24,800
cricut installation

00:42:22,000 --> 00:42:26,720
station and in either case the second

00:42:24,800 --> 00:42:28,880
standard conversion sequence in u1

00:42:26,720 --> 00:42:31,520
is better than the second standard

00:42:28,880 --> 00:42:33,280
conversion sequence in u2

00:42:31,520 --> 00:42:34,880
so if i do have a user-defined

00:42:33,280 --> 00:42:37,920
conversion in both cases

00:42:34,880 --> 00:42:39,839
i pick the one that is better with

00:42:37,920 --> 00:42:44,560
regard to the following

00:42:39,839 --> 00:42:46,560
uh the subsequent standard conversion

00:42:44,560 --> 00:42:47,599
now this explains how the compiler

00:42:46,560 --> 00:42:49,920
selects a single

00:42:47,599 --> 00:42:50,960
function as a function with a single

00:42:49,920 --> 00:42:53,119
argument

00:42:50,960 --> 00:42:55,680
but what about multiple arguments or

00:42:53,119 --> 00:42:58,000
multiple parameters

00:42:55,680 --> 00:43:00,720
this process is actually just a

00:42:58,000 --> 00:43:00,720
consequent

00:43:00,880 --> 00:43:04,960
application of the rules that i've

00:43:02,480 --> 00:43:06,640
explained so far

00:43:04,960 --> 00:43:08,720
for several arguments the compliance

00:43:06,640 --> 00:43:12,160
compiler applies the same rules to

00:43:08,720 --> 00:43:14,400
every single argument if one function

00:43:12,160 --> 00:43:15,760
of the ones in consideration is

00:43:14,400 --> 00:43:18,960
considered better for

00:43:15,760 --> 00:43:20,960
at least one argument and equally good

00:43:18,960 --> 00:43:23,119
for all the other arguments

00:43:20,960 --> 00:43:26,000
then this function is considered a best

00:43:23,119 --> 00:43:27,440
match else the function call is ambigus

00:43:26,000 --> 00:43:30,640
so for instance consider these two

00:43:27,440 --> 00:43:33,280
functions function one and function two

00:43:30,640 --> 00:43:35,280
the first function takes three integers

00:43:33,280 --> 00:43:37,599
the second one takes one integer and two

00:43:35,280 --> 00:43:39,440
doubles

00:43:37,599 --> 00:43:41,440
now i admit that this is a little

00:43:39,440 --> 00:43:42,880
artificial and probably will not appear

00:43:41,440 --> 00:43:44,240
in real code in this form

00:43:42,880 --> 00:43:46,880
but it definitely explains what is

00:43:44,240 --> 00:43:49,599
happening i am passing an integer

00:43:46,880 --> 00:43:52,160
i'm passing a short i'm passing an

00:43:49,599 --> 00:43:54,000
unsigned integer

00:43:52,160 --> 00:43:55,920
the first argument the integer is

00:43:54,000 --> 00:43:58,640
actually a rank one for both

00:43:55,920 --> 00:43:59,920
functions so at this point i cannot make

00:43:58,640 --> 00:44:02,880
a decision

00:43:59,920 --> 00:44:03,760
the second argument is actually a

00:44:02,880 --> 00:44:06,800
promotion

00:44:03,760 --> 00:44:08,319
for if in the second case sorry in the

00:44:06,800 --> 00:44:11,440
first function

00:44:08,319 --> 00:44:14,079
that is a rank two but it would only be

00:44:11,440 --> 00:44:15,520
a standard conversion for the second

00:44:14,079 --> 00:44:19,040
function

00:44:15,520 --> 00:44:21,599
and the unsigned end that is

00:44:19,040 --> 00:44:24,000
a conversion in the first and in the

00:44:21,599 --> 00:44:26,400
second case

00:44:24,000 --> 00:44:28,480
because of the second argument because

00:44:26,400 --> 00:44:30,079
this is a promotion only

00:44:28,480 --> 00:44:32,480
function one is actually a little bit

00:44:30,079 --> 00:44:35,760
better than the second one

00:44:32,480 --> 00:44:38,640
function one is at least as good

00:44:35,760 --> 00:44:39,520
in all the arguments as this one but one

00:44:38,640 --> 00:44:41,920
is better

00:44:39,520 --> 00:44:45,440
and so function one is selected and

00:44:41,920 --> 00:44:47,920
called it's considered the best match

00:44:45,440 --> 00:44:50,079
if i change the second argument from an

00:44:47,920 --> 00:44:52,720
unsigned into float

00:44:50,079 --> 00:44:53,920
things change a little bit still i can

00:44:52,720 --> 00:44:57,119
consider the first one

00:44:53,920 --> 00:44:59,839
as a tie between these two functions

00:44:57,119 --> 00:45:02,160
i can consider this a promotion and this

00:44:59,839 --> 00:45:06,160
a conversion again

00:45:02,160 --> 00:45:09,520
now the float is converted into an int

00:45:06,160 --> 00:45:12,640
rank three but promoted to double

00:45:09,520 --> 00:45:14,800
rank two now in both

00:45:12,640 --> 00:45:16,000
cases and for both functions i have one

00:45:14,800 --> 00:45:19,040
argument

00:45:16,000 --> 00:45:21,680
one parameter one case

00:45:19,040 --> 00:45:22,960
where i have where it's better than the

00:45:21,680 --> 00:45:25,119
other function

00:45:22,960 --> 00:45:26,800
as soon as this situation rises and

00:45:25,119 --> 00:45:28,480
isn't completely irrelevant how many

00:45:26,800 --> 00:45:30,480
other

00:45:28,480 --> 00:45:31,520
extra points the other function gets so

00:45:30,480 --> 00:45:34,000
how many uh

00:45:31,520 --> 00:45:35,599
are better as soon as both functions

00:45:34,000 --> 00:45:38,240
have one argument that is better

00:45:35,599 --> 00:45:39,280
this is considered an ambiguous function

00:45:38,240 --> 00:45:41,440
call

00:45:39,280 --> 00:45:43,359
so the compiler does not make a decision

00:45:41,440 --> 00:45:46,560
here you have to disambiguate

00:45:43,359 --> 00:45:48,240
by cleaning up the arguments which

00:45:46,560 --> 00:45:50,079
however shows

00:45:48,240 --> 00:45:51,520
that complex situations should be

00:45:50,079 --> 00:45:53,440
avoided so one of my

00:45:51,520 --> 00:45:55,119
guidelines for you would be to prevent

00:45:53,440 --> 00:45:57,119
complex overloading situations

00:45:55,119 --> 00:45:58,880
that may result in surprises during

00:45:57,119 --> 00:46:02,960
overload resolution

00:45:58,880 --> 00:46:05,280
and also consider core guidelines c163

00:46:02,960 --> 00:46:06,640
overload only for operations that are

00:46:05,280 --> 00:46:09,280
roughly equivalent

00:46:06,640 --> 00:46:10,800
so it really pays off to only overload

00:46:09,280 --> 00:46:13,680
if things are really

00:46:10,800 --> 00:46:14,880
doing similar things so the overlord

00:46:13,680 --> 00:46:18,960
situation should be

00:46:14,880 --> 00:46:21,760
easier to resolve should be more natural

00:46:18,960 --> 00:46:23,119
all right this was a big sub chapter if

00:46:21,760 --> 00:46:26,240
there's any questions please

00:46:23,119 --> 00:46:28,960
um post them i will um

00:46:26,240 --> 00:46:31,280
take them at the end uh try to answer as

00:46:28,960 --> 00:46:35,599
many questions as possible

00:46:31,280 --> 00:46:38,240
which brings us to the excess labels

00:46:35,599 --> 00:46:40,319
which may seem a little boring but

00:46:38,240 --> 00:46:42,800
surprisingly there's a lot

00:46:40,319 --> 00:46:44,720
that we have to consider as well and

00:46:42,800 --> 00:46:48,160
this is one of the examples that is

00:46:44,720 --> 00:46:52,000
also confusing for um for beginners in c

00:46:48,160 --> 00:46:54,800
plus i have a class called object

00:46:52,000 --> 00:46:57,599
which comes with two functions f the

00:46:54,800 --> 00:47:01,040
first function f is in the public part

00:46:57,599 --> 00:47:02,800
and takes an integer my function 1 again

00:47:01,040 --> 00:47:05,359
then i have a second function f that

00:47:02,800 --> 00:47:07,599
takes a double that one is

00:47:05,359 --> 00:47:08,480
declared in the private section of this

00:47:07,599 --> 00:47:12,480
object

00:47:08,480 --> 00:47:14,720
my function 2. now i create an object

00:47:12,480 --> 00:47:16,880
and i call function f with a double

00:47:14,720 --> 00:47:19,599
value

00:47:16,880 --> 00:47:20,960
a lot of students now argue that of

00:47:19,599 --> 00:47:23,440
course this must

00:47:20,960 --> 00:47:24,559
call function1 it's the only public

00:47:23,440 --> 00:47:26,240
function and as such

00:47:24,559 --> 00:47:28,960
it's the only thing that i can access

00:47:26,240 --> 00:47:28,960
from outside

00:47:29,520 --> 00:47:33,599
well in this particular case this will

00:47:31,839 --> 00:47:36,079
result in an excess

00:47:33,599 --> 00:47:38,160
violation message from the compiler

00:47:36,079 --> 00:47:40,319
which essentially means you're trying to

00:47:38,160 --> 00:47:41,680
call function2

00:47:40,319 --> 00:47:43,839
but unfortunately this function is

00:47:41,680 --> 00:47:46,160
declared private and therefore cannot be

00:47:43,839 --> 00:47:46,160
called

00:47:46,640 --> 00:47:51,680
perhaps you already understand this

00:47:48,640 --> 00:47:54,720
based on what i've said before

00:47:51,680 --> 00:47:56,800
the very first step is name lookup

00:47:54,720 --> 00:47:58,160
we start in the scope of object because

00:47:56,800 --> 00:48:00,079
this is where we

00:47:58,160 --> 00:48:02,400
start to look for the function and the

00:48:00,079 --> 00:48:04,319
compiler finds both functions

00:48:02,400 --> 00:48:05,680
at this point these labels are not taken

00:48:04,319 --> 00:48:08,960
into account at all

00:48:05,680 --> 00:48:10,559
there is two functions f there is no

00:48:08,960 --> 00:48:11,440
template so i go to the overlaid

00:48:10,559 --> 00:48:13,839
resolution

00:48:11,440 --> 00:48:14,720
which decides that function two is the

00:48:13,839 --> 00:48:17,119
better match

00:48:14,720 --> 00:48:18,240
i have a double argument and so it's an

00:48:17,119 --> 00:48:20,640
identity match here

00:48:18,240 --> 00:48:23,520
but it would be a rank 3 call here so

00:48:20,640 --> 00:48:26,079
function 2 is selected

00:48:23,520 --> 00:48:27,200
only afterwards i actually take a look

00:48:26,079 --> 00:48:30,079
at these labels

00:48:27,200 --> 00:48:30,720
and find that this is this function has

00:48:30,079 --> 00:48:33,520
been

00:48:30,720 --> 00:48:35,760
has been put into the private section i

00:48:33,520 --> 00:48:38,079
have an access violation

00:48:35,760 --> 00:48:40,800
there is a very good reason why this is

00:48:38,079 --> 00:48:42,800
uh it is working this order

00:48:40,800 --> 00:48:44,319
because again it is supposed to prevent

00:48:42,800 --> 00:48:47,200
you from

00:48:44,319 --> 00:48:47,200
from surprises

00:48:47,359 --> 00:48:50,880
regardless of from wherever i call this

00:48:50,240 --> 00:48:54,480
function

00:48:50,880 --> 00:48:56,880
wherever i have a call to f in

00:48:54,480 --> 00:48:58,960
f with this double value it should

00:48:56,880 --> 00:49:00,720
always resolve to the same function

00:48:58,960 --> 00:49:02,400
so regardless of whether i call this

00:49:00,720 --> 00:49:05,520
from the outside like here

00:49:02,400 --> 00:49:08,640
or somewhere inside the class it still

00:49:05,520 --> 00:49:11,359
should resolve to this one function no

00:49:08,640 --> 00:49:12,960
change no no difference here and so the

00:49:11,359 --> 00:49:16,480
this label here is indeed

00:49:12,960 --> 00:49:19,760
checked after the overload resolution

00:49:16,480 --> 00:49:20,319
which means that this here is truly an

00:49:19,760 --> 00:49:23,599
excess

00:49:20,319 --> 00:49:27,040
label it is not a visibility label

00:49:23,599 --> 00:49:30,960
in c plus everything inside a class

00:49:27,040 --> 00:49:33,839
is visible everything

00:49:30,960 --> 00:49:35,760
and this basically led to the um

00:49:33,839 --> 00:49:39,680
introduction of a new keyword in c plus

00:49:35,760 --> 00:49:40,400
20 which is glass yeah we have indeed a

00:49:39,680 --> 00:49:42,960
glass

00:49:40,400 --> 00:49:44,000
object now of course this is a joke yeah

00:49:42,960 --> 00:49:46,480
so there is no glass

00:49:44,000 --> 00:49:48,640
keyword but actually it would very very

00:49:46,480 --> 00:49:50,960
nicely express what this truly is

00:49:48,640 --> 00:49:52,000
um this is something where you can see

00:49:50,960 --> 00:49:54,880
everything

00:49:52,000 --> 00:49:56,640
but it cannot access everything and so

00:49:54,880 --> 00:49:59,119
please consider this

00:49:56,640 --> 00:50:00,079
these labels as truly excess labels

00:49:59,119 --> 00:50:02,240
remember that

00:50:00,079 --> 00:50:03,920
everything inside the class is visible

00:50:02,240 --> 00:50:07,040
public protected and private

00:50:03,920 --> 00:50:08,400
are merely excess labels now this is

00:50:07,040 --> 00:50:09,200
very different from other program

00:50:08,400 --> 00:50:12,240
language

00:50:09,200 --> 00:50:15,040
and as such indeed a little surprising

00:50:12,240 --> 00:50:17,599
okay if you have questions please again

00:50:15,040 --> 00:50:19,200
write them down

00:50:17,599 --> 00:50:20,800
the next step would be function template

00:50:19,200 --> 00:50:22,559
specialization which

00:50:20,800 --> 00:50:24,640
is a step that i cannot really go into

00:50:22,559 --> 00:50:25,280
detail at least i want to give you a

00:50:24,640 --> 00:50:27,760
feeling

00:50:25,280 --> 00:50:29,839
that this is indeed a step that happens

00:50:27,760 --> 00:50:32,240
very very late

00:50:29,839 --> 00:50:33,040
the first function i have is a base

00:50:32,240 --> 00:50:36,240
template

00:50:33,040 --> 00:50:36,720
a function f that takes some t the

00:50:36,240 --> 00:50:38,839
second

00:50:36,720 --> 00:50:40,640
function is a function template

00:50:38,839 --> 00:50:43,119
specialization

00:50:40,640 --> 00:50:43,680
i specialize this template for character

00:50:43,119 --> 00:50:46,720
pointers

00:50:43,680 --> 00:50:47,920
specifically the third function is a

00:50:46,720 --> 00:50:51,040
base template again

00:50:47,920 --> 00:50:54,559
that takes t pointers not t being

00:50:51,040 --> 00:50:57,760
any type if in the main function

00:50:54,559 --> 00:51:01,599
i have initialized a chart pointer

00:50:57,760 --> 00:51:04,319
and then called a function surprisingly

00:51:01,599 --> 00:51:08,160
it is not this function that is called

00:51:04,319 --> 00:51:09,920
but function 3.

00:51:08,160 --> 00:51:11,680
function template specializations are

00:51:09,920 --> 00:51:12,400
not considered during the overload

00:51:11,680 --> 00:51:15,680
resolution

00:51:12,400 --> 00:51:17,760
but only here in this step only function

00:51:15,680 --> 00:51:19,440
1 and function 3 are considered during

00:51:17,760 --> 00:51:21,200
the overload resolution

00:51:19,440 --> 00:51:22,800
at this point the compiler finds that

00:51:21,200 --> 00:51:25,440
function three is actually

00:51:22,800 --> 00:51:27,119
better matched it is dealing with

00:51:25,440 --> 00:51:28,000
pointers whereas function one is taking

00:51:27,119 --> 00:51:29,440
any type

00:51:28,000 --> 00:51:31,280
so because function three is a little

00:51:29,440 --> 00:51:33,920
more specialized for pointers

00:51:31,280 --> 00:51:35,520
function three selected and ultimately

00:51:33,920 --> 00:51:37,760
called

00:51:35,520 --> 00:51:39,119
function 2 is a specialization of base

00:51:37,760 --> 00:51:42,559
template 1 only

00:51:39,119 --> 00:51:43,280
and as such only if this base template

00:51:42,559 --> 00:51:45,040
is selected

00:51:43,280 --> 00:51:46,480
this specialization can be taken into

00:51:45,040 --> 00:51:49,040
account

00:51:46,480 --> 00:51:49,760
the game changes a little bit if i

00:51:49,040 --> 00:51:53,040
switch

00:51:49,760 --> 00:51:55,040
function three and two because suddenly

00:51:53,040 --> 00:51:56,480
this here is a specialization of

00:51:55,040 --> 00:51:58,240
function three

00:51:56,480 --> 00:52:00,240
before it was defined before so it

00:51:58,240 --> 00:52:01,119
couldn't be but now it specializes this

00:52:00,240 --> 00:52:02,960
function

00:52:01,119 --> 00:52:04,160
now with the same call in the code and

00:52:02,960 --> 00:52:06,720
domain function

00:52:04,160 --> 00:52:08,559
i actually call function2 function3

00:52:06,720 --> 00:52:11,040
selected in the overload resolution

00:52:08,559 --> 00:52:12,240
and now in this step i can consider its

00:52:11,040 --> 00:52:14,720
specializations

00:52:12,240 --> 00:52:15,440
and function 2 is better it is more

00:52:14,720 --> 00:52:18,559
special for

00:52:15,440 --> 00:52:21,680
char pointers note

00:52:18,559 --> 00:52:24,800
that sometimes syntax gets in the way

00:52:21,680 --> 00:52:25,520
you're always allowed to define this

00:52:24,800 --> 00:52:28,960
function f

00:52:25,520 --> 00:52:32,160
in this form you can explicitly

00:52:28,960 --> 00:52:32,800
say how you're specializing it this

00:52:32,160 --> 00:52:34,400
however

00:52:32,800 --> 00:52:36,319
unfortunately is now again a

00:52:34,400 --> 00:52:38,319
specialization of function one

00:52:36,319 --> 00:52:39,440
because this t here matches this

00:52:38,319 --> 00:52:41,200
perfectly

00:52:39,440 --> 00:52:42,960
it's not the same pattern as in function

00:52:41,200 --> 00:52:44,880
three therefore

00:52:42,960 --> 00:52:46,000
if i select function three there is no

00:52:44,880 --> 00:52:48,800
specialization anymore

00:52:46,000 --> 00:52:50,640
and again i would call function 3. this

00:52:48,800 --> 00:52:52,960
is just something to keep in mind

00:52:50,640 --> 00:52:54,960
and also it is important to keep in mind

00:52:52,960 --> 00:52:55,760
that function template specializations

00:52:54,960 --> 00:52:58,079
are considered

00:52:55,760 --> 00:52:59,440
only after the base tendlate has been

00:52:58,079 --> 00:53:02,079
selected

00:52:59,440 --> 00:53:03,839
so the takeaway is prefer function

00:53:02,079 --> 00:53:05,760
overloading to function template

00:53:03,839 --> 00:53:08,640
specialization

00:53:05,760 --> 00:53:10,720
but i admit that this was rather short i

00:53:08,640 --> 00:53:12,640
refer you to an excellent talk given

00:53:10,720 --> 00:53:13,440
about the prawn on c plus plus function

00:53:12,640 --> 00:53:16,160
templates

00:53:13,440 --> 00:53:17,280
it's a one hour 20 minute talk just on

00:53:16,160 --> 00:53:18,880
this topic

00:53:17,280 --> 00:53:20,559
and after this talk you will truly know

00:53:18,880 --> 00:53:21,200
everything that there is about function

00:53:20,559 --> 00:53:24,319
templates

00:53:21,200 --> 00:53:26,839
including how they um interact in

00:53:24,319 --> 00:53:28,880
overlaid resolution and this entire call

00:53:26,839 --> 00:53:32,160
mechanism

00:53:28,880 --> 00:53:35,200
all right which brings us

00:53:32,160 --> 00:53:38,559
to virtual dispatch which i said

00:53:35,200 --> 00:53:40,559
i will not explain in detail again i can

00:53:38,559 --> 00:53:42,480
only forward you to an excellent talk by

00:53:40,559 --> 00:53:44,160
stefan t larvey

00:53:42,480 --> 00:53:46,160
which is not just one talk there's

00:53:44,160 --> 00:53:48,880
actually an entire series of talks

00:53:46,160 --> 00:53:50,480
called called core c plus plus the

00:53:48,880 --> 00:53:51,920
fourth part is the one that you're

00:53:50,480 --> 00:53:53,520
interested in if you're interested in

00:53:51,920 --> 00:53:55,040
virtual functions

00:53:53,520 --> 00:53:57,119
and this is where he really explains

00:53:55,040 --> 00:53:58,720
pretty well how virtual dispatch works

00:53:57,119 --> 00:54:01,440
in detail

00:53:58,720 --> 00:54:04,000
highly recommended and also of course

00:54:01,440 --> 00:54:07,599
watch the other core c plus plus talks

00:54:04,000 --> 00:54:09,200
about name lookup function template

00:54:07,599 --> 00:54:12,400
argument deduction and of course

00:54:09,200 --> 00:54:15,200
also overlap resolution

00:54:12,400 --> 00:54:18,319
so this leads us to the last step

00:54:15,200 --> 00:54:18,319
deleting functions

00:54:18,880 --> 00:54:23,040
let's consider that i call a function f

00:54:21,440 --> 00:54:25,760
with 42

00:54:23,040 --> 00:54:27,200
and i have two functions one takes an

00:54:25,760 --> 00:54:28,880
into one takes a double

00:54:27,200 --> 00:54:30,720
this double function is explicitly

00:54:28,880 --> 00:54:33,119
deleted

00:54:30,720 --> 00:54:35,280
then perhaps surprisingly this function

00:54:33,119 --> 00:54:36,480
here not surprisingly this function will

00:54:35,280 --> 00:54:40,319
call function one

00:54:36,480 --> 00:54:42,400
no problem if i call function f with a

00:54:40,319 --> 00:54:45,280
double however

00:54:42,400 --> 00:54:47,040
it is not calling function one but

00:54:45,280 --> 00:54:50,640
instead you get a compilation error that

00:54:47,040 --> 00:54:53,599
you're trying to call function two

00:54:50,640 --> 00:54:55,280
equal delete is not changing anything

00:54:53,599 --> 00:54:57,440
with regard to the declaration

00:54:55,280 --> 00:54:58,960
and it definitely does not get rid of

00:54:57,440 --> 00:55:01,839
this function it does not

00:54:58,960 --> 00:55:02,960
remove it on a country equal delete is a

00:55:01,839 --> 00:55:05,040
definition

00:55:02,960 --> 00:55:07,280
that says this function has no

00:55:05,040 --> 00:55:09,599
implementation

00:55:07,280 --> 00:55:11,040
so function f that takes double function

00:55:09,599 --> 00:55:13,040
two does exist

00:55:11,040 --> 00:55:16,000
and if you try to call it you will get

00:55:13,040 --> 00:55:18,640
the according compilation error

00:55:16,000 --> 00:55:19,200
so equal delete doesn't delete a

00:55:18,640 --> 00:55:21,520
function

00:55:19,200 --> 00:55:22,799
despite the name but declares it as

00:55:21,520 --> 00:55:24,400
uncallable

00:55:22,799 --> 00:55:27,359
any attempt to call a function will

00:55:24,400 --> 00:55:28,960
result in a compilation error

00:55:27,359 --> 00:55:30,960
this is something that of course you can

00:55:28,960 --> 00:55:32,799
use if indeed you have a function that

00:55:30,960 --> 00:55:33,520
must not be called you can explicitly

00:55:32,799 --> 00:55:36,400
delete it

00:55:33,520 --> 00:55:37,920
in order to make it perfectly clear to a

00:55:36,400 --> 00:55:40,160
caller

00:55:37,920 --> 00:55:42,559
but of course there's also implications

00:55:40,160 --> 00:55:46,079
and you might remember the rule of five

00:55:42,559 --> 00:55:49,359
which is c21 in the core guidelines

00:55:46,079 --> 00:55:50,880
that suggests that you delete uh some of

00:55:49,359 --> 00:55:52,319
these special member functions whenever

00:55:50,880 --> 00:55:54,480
necessary

00:55:52,319 --> 00:55:55,440
however deleting for instance the move

00:55:54,480 --> 00:55:58,720
constructor

00:55:55,440 --> 00:56:01,119
has different implications than um

00:55:58,720 --> 00:56:02,000
than not writing it if i delete the

00:56:01,119 --> 00:56:05,119
function and

00:56:02,000 --> 00:56:05,920
try to call it then i get a compilation

00:56:05,119 --> 00:56:08,960
error

00:56:05,920 --> 00:56:11,760
i must not delete you called the delete

00:56:08,960 --> 00:56:12,960
uh sorry you must not move you called

00:56:11,760 --> 00:56:16,559
the move function

00:56:12,960 --> 00:56:17,920
um it's a compilation error if i omit it

00:56:16,559 --> 00:56:20,240
however

00:56:17,920 --> 00:56:21,359
then the implicit fallback is copy and

00:56:20,240 --> 00:56:24,000
suddenly this works

00:56:21,359 --> 00:56:24,960
by calling the copy constructor so

00:56:24,000 --> 00:56:27,839
indeed

00:56:24,960 --> 00:56:28,799
um calling uh deleting something

00:56:27,839 --> 00:56:31,200
explicitly

00:56:28,799 --> 00:56:33,440
makes a difference so please remember

00:56:31,200 --> 00:56:36,720
core guidelines c21

00:56:33,440 --> 00:56:39,200
and also remember that sometimes

00:56:36,720 --> 00:56:42,640
not writing some functions may actually

00:56:39,200 --> 00:56:45,359
express better what you have in mind

00:56:42,640 --> 00:56:47,359
so which brings me to the summary this

00:56:45,359 --> 00:56:48,559
was now a complete overview of the

00:56:47,359 --> 00:56:50,720
individual steps

00:56:48,559 --> 00:56:51,599
in calling a function the complete

00:56:50,720 --> 00:56:54,319
mechanics

00:56:51,599 --> 00:56:56,079
from name lookup to deleting functions

00:56:54,319 --> 00:56:57,520
how this was helpful in order to get an

00:56:56,079 --> 00:56:58,960
overview of what happens

00:56:57,520 --> 00:57:00,960
and i highly encourage you to take a

00:56:58,960 --> 00:57:02,079
closer look at either the cpp reference

00:57:00,960 --> 00:57:04,480
page that i showed

00:57:02,079 --> 00:57:06,880
or the standard in order to get a full

00:57:04,480 --> 00:57:08,559
and complete overview

00:57:06,880 --> 00:57:10,000
so thank you for your attention and

00:57:08,559 --> 00:57:13,200
perhaps there is still a little time

00:57:10,000 --> 00:57:16,640
left to answer one or two questions

00:57:13,200 --> 00:57:18,640
okay and indeed there is one what are

00:57:16,640 --> 00:57:20,480
pointer conversions considered

00:57:18,640 --> 00:57:22,559
for instance i suppose conversion from

00:57:20,480 --> 00:57:23,280
short pointed to in pointer is not a

00:57:22,559 --> 00:57:25,680
promotional

00:57:23,280 --> 00:57:27,440
like it would be for shorting it

00:57:25,680 --> 00:57:29,680
absolutely correct

00:57:27,440 --> 00:57:31,520
pointers are special in this regard

00:57:29,680 --> 00:57:34,960
because you don't want to

00:57:31,520 --> 00:57:36,079
deal with what you do you don't want to

00:57:34,960 --> 00:57:40,240
deal with

00:57:36,079 --> 00:57:42,480
short values as integers

00:57:40,240 --> 00:57:43,920
that would require you to use a reim

00:57:42,480 --> 00:57:45,520
reinterpret cast

00:57:43,920 --> 00:57:47,680
you explicitly would have to tell the

00:57:45,520 --> 00:57:48,160
compiler please treat these underlying

00:57:47,680 --> 00:57:51,359
shorts

00:57:48,160 --> 00:57:52,400
as integers this is not a valid

00:57:51,359 --> 00:57:54,640
conversion at all

00:57:52,400 --> 00:57:55,440
so this would be a function if you have

00:57:54,640 --> 00:57:57,760
a

00:57:55,440 --> 00:57:59,040
function that has a short or in pointer

00:57:57,760 --> 00:58:00,160
and it would call a function with the

00:57:59,040 --> 00:58:02,160
other kind of pointer

00:58:00,160 --> 00:58:04,079
it would always be considered a

00:58:02,160 --> 00:58:05,760
non-viable candidate

00:58:04,079 --> 00:58:07,200
so indeed pointers are different in this

00:58:05,760 --> 00:58:10,160
regard

00:58:07,200 --> 00:58:12,160
second question can you quickly explain

00:58:10,160 --> 00:58:14,079
two-phase name lookup

00:58:12,160 --> 00:58:15,280
versus an early example where matching

00:58:14,079 --> 00:58:19,760
function was declared

00:58:15,280 --> 00:58:19,760
after the calling template function

00:58:21,680 --> 00:58:26,480
so there's unfortunately a slight number

00:58:23,520 --> 00:58:27,920
so this is a little tricky to explain

00:58:26,480 --> 00:58:30,079
i don't know exactly what you're

00:58:27,920 --> 00:58:31,440
referring to um so

00:58:30,079 --> 00:58:33,760
please find me afterwards at the

00:58:31,440 --> 00:58:34,319
conference or um contact me any other

00:58:33,760 --> 00:58:37,280
way

00:58:34,319 --> 00:58:38,480
uh probably can figure this out that's

00:58:37,280 --> 00:58:41,119
the third question

00:58:38,480 --> 00:58:42,480
slide 105 this is something i can go

00:58:41,119 --> 00:58:45,920
back to

00:58:42,480 --> 00:58:48,160
on delete if you call f with a 1.0

00:58:45,920 --> 00:58:50,240
f we get a compilation error because

00:58:48,160 --> 00:58:50,880
then compiler tries to promote float to

00:58:50,240 --> 00:58:52,079
double

00:58:50,880 --> 00:58:54,319
instead of performing standard

00:58:52,079 --> 00:58:58,160
conversion absolutely correct

00:58:54,319 --> 00:59:00,799
yeah you basically got the idea

00:58:58,160 --> 00:59:02,480
the name of lookup finds both if overlet

00:59:00,799 --> 00:59:04,319
resolution detects or

00:59:02,480 --> 00:59:06,400
determines that the second function is

00:59:04,319 --> 00:59:08,240
better and at the very end of this

00:59:06,400 --> 00:59:09,760
entire pipeline i actually figure out

00:59:08,240 --> 00:59:11,520
that this is a deleted function

00:59:09,760 --> 00:59:12,880
and that it must not be called so if i

00:59:11,520 --> 00:59:15,599
pass a float

00:59:12,880 --> 00:59:18,480
it still is a compilation error because

00:59:15,599 --> 00:59:20,640
function2 is selected

00:59:18,480 --> 00:59:21,839
okay and there is a question about slide

00:59:20,640 --> 00:59:24,079
00:59:21,839 --> 00:59:25,359
which i'm going to have to find real

00:59:24,079 --> 00:59:28,720
quick

00:59:25,359 --> 00:59:31,119
65. um

00:59:28,720 --> 00:59:32,079
don't reference conversions work pretty

00:59:31,119 --> 00:59:35,200
much the same as

00:59:32,079 --> 00:59:38,960
pointer conversions minus conversion

00:59:35,200 --> 00:59:41,520
to a void um

00:59:38,960 --> 00:59:43,599
it is not explicitly listed as far as i

00:59:41,520 --> 00:59:45,920
know but i may be mistaken perhaps i

00:59:43,599 --> 00:59:47,839
just overlooked this

00:59:45,920 --> 00:59:49,520
it actually works in a similar form

00:59:47,839 --> 00:59:51,760
absolutely correct

00:59:49,520 --> 00:59:51,760
um

00:59:53,280 --> 00:59:56,640
i didn't list it here because i didn't

00:59:56,000 --> 00:59:59,839
see it

00:59:56,640 --> 01:00:01,040
i think if you have a derived reference

00:59:59,839 --> 01:00:02,799
and you pass to a

01:00:01,040 --> 01:00:05,280
base reference of course it works in

01:00:02,799 --> 01:00:07,440
exactly the way um that point does work

01:00:05,280 --> 01:00:08,799
so perhaps i just failed to mention it

01:00:07,440 --> 01:00:13,119
um either way

01:00:08,799 --> 01:00:14,720
things were around okay that's it

01:00:13,119 --> 01:00:16,799
thank you very much for your attention

01:00:14,720 --> 01:00:19,440
thanks for choosing this this track

01:00:16,799 --> 01:00:29,839
i hope it was a helpful talk for you

01:00:19,440 --> 01:00:29,839
thank you

01:00:40,240 --> 01:00:42,319

YouTube URL: https://www.youtube.com/watch?v=GydNMuyQzWo


