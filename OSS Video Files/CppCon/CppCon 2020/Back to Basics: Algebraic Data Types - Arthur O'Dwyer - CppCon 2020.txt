Title: Back to Basics: Algebraic Data Types - Arthur O'Dwyer - CppCon 2020
Publication date: 2020-09-26
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_algebraic_data_types/back_to_basics_algebraic_data_types__arthur_odwyer__cppcon_2020.pdf
---
One of the hallmarks of "modern C++" is a transition from classic object-orientation to value semantics with algebraic data types such as `variant` and `tuple`. In this session we'll explain the math behind the name, and we'll delve deep into the meaning and usage of all of the algebraic data types in C++17: pair, tuple, optional, and variant. These types have some commonalities, such as the use of type-traits to access their component types, and a common approach to implicit conversions and comparisons. We'll show how to use std::optional for deferred initialization and how to replace dynamic polymorphism with visitation over a std::variant. We'll even deliver some guidance on when NOT to return a tuple, and on how you should think about variant's "valueless by exception" state.
Attendees will leave this session with a newfound appreciation for C++'s algebraic data types.

---
Arthur O'Dwyer is the author of "Mastering the C++17 STL" (Packt 2017) and of professional training courses such as "Intro to C++," "Classic STL: Algorithms, Containers, Iterators," and "The STL From Scratch." (Ask me about training your new hires!) Arthur is occasionally active on the C++ Standards Committee and has a blog mostly about C++. He is also the author of "Colossal Cave: The Board Game," an avid club juggler, and the recipient of four Knuth checks.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,320 --> 00:00:12,719
all right good afternoon folks

00:00:10,160 --> 00:00:13,280
welcome to back to basics algebraic data

00:00:12,719 --> 00:00:15,839
types

00:00:13,280 --> 00:00:16,320
this is part of the back to basics track

00:00:15,839 --> 00:00:18,240
um

00:00:16,320 --> 00:00:19,840
i'm arthur dwyer by the way i am the

00:00:18,240 --> 00:00:22,000
chair of the back to basics track

00:00:19,840 --> 00:00:23,760
so i was involved with putting together

00:00:22,000 --> 00:00:26,240
the uh

00:00:23,760 --> 00:00:27,840
the the track that you've seen so far uh

00:00:26,240 --> 00:00:31,039
and i hope you're all enjoying it

00:00:27,840 --> 00:00:32,800
please let me know um

00:00:31,039 --> 00:00:34,640
talk in the in the slack and so on let

00:00:32,800 --> 00:00:35,680
us know how how the back to basics track

00:00:34,640 --> 00:00:39,680
has been for you

00:00:35,680 --> 00:00:41,520
um especially by friday um

00:00:39,680 --> 00:00:43,040
did you learn things how's it going what

00:00:41,520 --> 00:00:44,239
could we do better we're always trying

00:00:43,040 --> 00:00:46,719
to improve

00:00:44,239 --> 00:00:48,079
uh also i do see plus plus training if

00:00:46,719 --> 00:00:48,960
you're looking for someone to train your

00:00:48,079 --> 00:00:53,360
new hires

00:00:48,960 --> 00:00:55,520
or uh brush up on c plus plus 17 or 20

00:00:53,360 --> 00:00:56,879
um you might want to get in touch with

00:00:55,520 --> 00:00:59,120
me i also

00:00:56,879 --> 00:01:00,239
at the end of cppcon this year have a

00:00:59,120 --> 00:01:03,680
three-day course

00:01:00,239 --> 00:01:05,199
on classic stl programming uh there's

00:01:03,680 --> 00:01:06,400
still time to sign up for my class if

00:01:05,199 --> 00:01:07,840
you want to do that

00:01:06,400 --> 00:01:09,920
but today we're not going to talk about

00:01:07,840 --> 00:01:11,680
stl stuff we're going to talk about a

00:01:09,920 --> 00:01:15,439
different part of the standard library

00:01:11,680 --> 00:01:18,960
algebraic data types so

00:01:15,439 --> 00:01:19,680
uh by the way um ask questions during

00:01:18,960 --> 00:01:22,000
the talk

00:01:19,680 --> 00:01:23,360
put them in the q a tab there will be

00:01:22,000 --> 00:01:25,200
question breaks we don't get to the

00:01:23,360 --> 00:01:26,159
first one until about slide 40. i'm

00:01:25,200 --> 00:01:29,840
going to do

00:01:26,159 --> 00:01:31,680
a quick overview um tell you about

00:01:29,840 --> 00:01:33,360
how the memory footprint of these types

00:01:31,680 --> 00:01:35,360
looks like why you might want to use

00:01:33,360 --> 00:01:37,840
them as very quick motivation

00:01:35,360 --> 00:01:39,759
going to explain some terminology that

00:01:37,840 --> 00:01:40,479
is common among all the algebraic data

00:01:39,759 --> 00:01:42,159
types

00:01:40,479 --> 00:01:43,520
and then i'm going to pause and take

00:01:42,159 --> 00:01:45,040
some questions and then we're going to

00:01:43,520 --> 00:01:47,520
talk a little bit more about

00:01:45,040 --> 00:01:49,680
uh common patterns that you see with

00:01:47,520 --> 00:01:51,439
with uh stud optional

00:01:49,680 --> 00:01:52,960
and then common patterns with variant

00:01:51,439 --> 00:01:55,920
and with pair and tuple and i'll take

00:01:52,960 --> 00:02:00,320
questions about those specific types

00:01:55,920 --> 00:02:03,040
after we've covered the type so

00:02:00,320 --> 00:02:03,759
what do i mean when i say algebraic data

00:02:03,040 --> 00:02:06,000
types

00:02:03,759 --> 00:02:07,520
well i'm talking about these four types

00:02:06,000 --> 00:02:09,920
in the standard library

00:02:07,520 --> 00:02:12,560
uh this did pair stood tuple stood

00:02:09,920 --> 00:02:15,599
optional and stood variant

00:02:12,560 --> 00:02:16,480
pair came in with the original stl with

00:02:15,599 --> 00:02:20,720
stepanov's

00:02:16,480 --> 00:02:23,040
stl the original algebraic data type

00:02:20,720 --> 00:02:24,480
tuple came in in 11 and then c plus plus

00:02:23,040 --> 00:02:26,959
17 gave us optional

00:02:24,480 --> 00:02:27,920
invariant uh and variance constructors

00:02:26,959 --> 00:02:31,120
had little

00:02:27,920 --> 00:02:34,160
bug fixes in c plus plus 20 but uh

00:02:31,120 --> 00:02:35,920
it's largely unchanged um

00:02:34,160 --> 00:02:37,840
why do i call these four types

00:02:35,920 --> 00:02:41,200
specifically the algebraic

00:02:37,840 --> 00:02:43,360
data types uh well it's about the types

00:02:41,200 --> 00:02:46,160
number of possible values the size of

00:02:43,360 --> 00:02:49,200
the domain the cardinality of the domain

00:02:46,160 --> 00:02:51,040
of the type how many possible states

00:02:49,200 --> 00:02:52,400
does the object have how many possible

00:02:51,040 --> 00:02:54,480
values does it have

00:02:52,400 --> 00:02:56,640
if i look at a char let's say an 8-bit

00:02:54,480 --> 00:02:58,480
char uh it has two to the eighth

00:02:56,640 --> 00:03:01,760
possible states that it can be in

00:02:58,480 --> 00:03:04,080
256 possible different values for char

00:03:01,760 --> 00:03:06,000
uh if i look at the data type bool it

00:03:04,080 --> 00:03:07,599
only has two possible values right true

00:03:06,000 --> 00:03:09,040
and false it can only ever be in one of

00:03:07,599 --> 00:03:11,040
those two states

00:03:09,040 --> 00:03:12,879
but if i put them together in a stid

00:03:11,040 --> 00:03:15,360
pair and i have a pair

00:03:12,879 --> 00:03:16,000
of a char and a bool one next to the

00:03:15,360 --> 00:03:18,480
other

00:03:16,000 --> 00:03:19,599
then the char can be in any of its 256

00:03:18,480 --> 00:03:21,360
possible states

00:03:19,599 --> 00:03:22,800
the bool can be in one of its two

00:03:21,360 --> 00:03:25,519
possible states

00:03:22,800 --> 00:03:26,080
so the total number of possible states

00:03:25,519 --> 00:03:28,000
of

00:03:26,080 --> 00:03:29,200
a stid pair of char and bull is the

00:03:28,000 --> 00:03:32,319
cartesian product

00:03:29,200 --> 00:03:33,280
of 256 and two right there are 512

00:03:32,319 --> 00:03:35,599
possible values

00:03:33,280 --> 00:03:36,560
that that pair can take on it could be

00:03:35,599 --> 00:03:38,720
one and true

00:03:36,560 --> 00:03:40,400
one and false two and true two and false

00:03:38,720 --> 00:03:43,120
and so on right

00:03:40,400 --> 00:03:44,560
so you count them all up you get 512. uh

00:03:43,120 --> 00:03:45,040
if i have a tuple of two jars in the

00:03:44,560 --> 00:03:46,720
pool

00:03:45,040 --> 00:03:48,239
how many possible values does it have

00:03:46,720 --> 00:03:52,239
well we multiply

00:03:48,239 --> 00:03:56,319
256 times 256 times two and we get

00:03:52,239 --> 00:03:58,799
you know 130 1072. um

00:03:56,319 --> 00:03:59,439
so we say that pair and tuple are

00:03:58,799 --> 00:04:02,480
product

00:03:59,439 --> 00:04:04,000
types for this reason that when we are

00:04:02,480 --> 00:04:06,879
asking how many

00:04:04,000 --> 00:04:08,720
uh values are in the domain of a pair

00:04:06,879 --> 00:04:11,120
type or a tuple type

00:04:08,720 --> 00:04:12,319
we get that number by multiplying its

00:04:11,120 --> 00:04:15,360
element types

00:04:12,319 --> 00:04:16,799
sizes uh if i have a pair of a and b

00:04:15,360 --> 00:04:18,560
how many possible values does it have

00:04:16,799 --> 00:04:19,280
well it's the number of possible values

00:04:18,560 --> 00:04:21,040
of an a

00:04:19,280 --> 00:04:22,639
times the number of possible values of a

00:04:21,040 --> 00:04:24,880
b if i have a tuple of

00:04:22,639 --> 00:04:26,400
an a a b and c and so on uh then i

00:04:24,880 --> 00:04:28,240
multiply all those sizes together and

00:04:26,400 --> 00:04:31,040
that tells me

00:04:28,240 --> 00:04:32,880
how many different possible values this

00:04:31,040 --> 00:04:34,960
tuple might take on

00:04:32,880 --> 00:04:35,919
right and for this reason we call

00:04:34,960 --> 00:04:39,120
parental

00:04:35,919 --> 00:04:42,479
product types in memory

00:04:39,120 --> 00:04:44,639
a pair or a tuple is

00:04:42,479 --> 00:04:45,680
basically the same as the layout of a

00:04:44,639 --> 00:04:48,960
plain old data

00:04:45,680 --> 00:04:50,000
struct right a pair of a and b has space

00:04:48,960 --> 00:04:52,960
for an a

00:04:50,000 --> 00:04:54,080
followed by space for a b uh a tuple of

00:04:52,960 --> 00:04:56,560
a b and c has

00:04:54,080 --> 00:04:57,520
an a a b and a c and they're all at

00:04:56,560 --> 00:05:00,400
different addresses

00:04:57,520 --> 00:05:01,919
right um within this the memory

00:05:00,400 --> 00:05:03,280
footprint of this class type

00:05:01,919 --> 00:05:05,199
notice that we're not doing any heap

00:05:03,280 --> 00:05:08,320
allocation here the the

00:05:05,199 --> 00:05:10,479
pair or the tuple contains the

00:05:08,320 --> 00:05:11,919
constituent types the element types

00:05:10,479 --> 00:05:14,880
within itself

00:05:11,919 --> 00:05:15,680
um now in real life this uh diagram is

00:05:14,880 --> 00:05:17,840
not right

00:05:15,680 --> 00:05:19,520
right uh in real life we would have some

00:05:17,840 --> 00:05:21,280
padding for alignment

00:05:19,520 --> 00:05:23,120
uh the fields might be in a different

00:05:21,280 --> 00:05:26,639
order so in fact what you actually

00:05:23,120 --> 00:05:27,199
see if you ask for the size of a pair of

00:05:26,639 --> 00:05:30,160
let's say

00:05:27,199 --> 00:05:32,560
a was char and b was int here so i've

00:05:30,160 --> 00:05:35,680
drawn it out so that a is one box and b

00:05:32,560 --> 00:05:37,600
is the size of four boxes um

00:05:35,680 --> 00:05:39,280
if i have a pair of char and an end i

00:05:37,600 --> 00:05:41,520
would expect to see three bytes of

00:05:39,280 --> 00:05:44,080
padding between the a and the b

00:05:41,520 --> 00:05:45,360
and if i have a tuple of let's say uh i

00:05:44,080 --> 00:05:46,400
think you can see my yes you can see my

00:05:45,360 --> 00:05:50,880
mouse pointer

00:05:46,400 --> 00:05:51,199
um the a is one byte the b is four bytes

00:05:50,880 --> 00:05:52,800
the c

00:05:51,199 --> 00:05:54,639
is two bytes let's say we're going to

00:05:52,800 --> 00:05:55,919
see some you know some bytes of padding

00:05:54,639 --> 00:05:57,520
here between the a and the b

00:05:55,919 --> 00:05:58,720
and some bytes of tail padding at the

00:05:57,520 --> 00:05:59,759
end to make the alignment come out

00:05:58,720 --> 00:06:03,039
correctly

00:05:59,759 --> 00:06:04,720
right so

00:06:03,039 --> 00:06:07,280
i guess there is some padding going on

00:06:04,720 --> 00:06:09,360
here but essentially you get the size of

00:06:07,280 --> 00:06:10,319
a pair or a tuple by just adding up the

00:06:09,360 --> 00:06:13,440
size of

00:06:10,319 --> 00:06:15,680
of its constituent element types

00:06:13,440 --> 00:06:18,000
and then adjust for padding by the way

00:06:15,680 --> 00:06:18,639
this is lib c-plus plus this is the llvm

00:06:18,000 --> 00:06:20,720
project's

00:06:18,639 --> 00:06:22,160
standard library if you look at the new

00:06:20,720 --> 00:06:23,120
standard library or the microsoft

00:06:22,160 --> 00:06:24,960
standard library

00:06:23,120 --> 00:06:26,479
they have the same uh in-memory layout

00:06:24,960 --> 00:06:28,000
for pair but they actually reverse the

00:06:26,479 --> 00:06:29,600
order of the fields in the tuple

00:06:28,000 --> 00:06:32,880
right different standard libraries are

00:06:29,600 --> 00:06:36,240
allowed to have different avis

00:06:32,880 --> 00:06:39,280
you can't uh you know have a variable

00:06:36,240 --> 00:06:41,199
in one translation unit compiled with

00:06:39,280 --> 00:06:42,800
uh one standard library and expect to be

00:06:41,199 --> 00:06:44,880
able to use that

00:06:42,800 --> 00:06:46,160
same variable in a translation unit

00:06:44,880 --> 00:06:47,600
compiled with a different standard

00:06:46,160 --> 00:06:48,880
library right you have to use the same

00:06:47,600 --> 00:06:50,160
standard library across your whole

00:06:48,880 --> 00:06:53,520
product

00:06:50,160 --> 00:06:55,120
um okay so uh right gcc and msbc

00:06:53,520 --> 00:06:57,039
they switch the order of the fields not

00:06:55,120 --> 00:06:58,960
a problem but for pair

00:06:57,039 --> 00:07:00,319
they always lay it out with the the

00:06:58,960 --> 00:07:02,479
first element first and the second

00:07:00,319 --> 00:07:05,599
element second

00:07:02,479 --> 00:07:06,720
um oh by the way uh some hypothetical

00:07:05,599 --> 00:07:08,720
library api

00:07:06,720 --> 00:07:10,000
could actually save you four bytes by

00:07:08,720 --> 00:07:12,800
reordering the

00:07:10,000 --> 00:07:13,919
the elements of the tuple in a size

00:07:12,800 --> 00:07:15,360
order right put b

00:07:13,919 --> 00:07:17,120
first and then c and then a there's no

00:07:15,360 --> 00:07:18,400
rule against that as far as i know

00:07:17,120 --> 00:07:20,880
nobody does that

00:07:18,400 --> 00:07:22,560
um but it would be kind of cool maybe uh

00:07:20,880 --> 00:07:25,840
when someone starts a new library

00:07:22,560 --> 00:07:26,800
we might see something like that so a

00:07:25,840 --> 00:07:30,240
stid pair of a

00:07:26,800 --> 00:07:32,960
and b is basically a struct right

00:07:30,240 --> 00:07:34,720
uh its layout is probably going to be

00:07:32,960 --> 00:07:38,000
the same on every

00:07:34,720 --> 00:07:38,639
uh avi every library um doesn't have to

00:07:38,000 --> 00:07:41,919
be

00:07:38,639 --> 00:07:45,759
but the standard library specifies

00:07:41,919 --> 00:07:48,800
that a stid pair of a and b is

00:07:45,759 --> 00:07:50,000
basically to a first approximation it's

00:07:48,800 --> 00:07:53,440
a simple struct

00:07:50,000 --> 00:07:55,680
struct pair and it has uh

00:07:53,440 --> 00:07:56,879
the first element of the first type and

00:07:55,680 --> 00:07:59,280
its name is

00:07:56,879 --> 00:08:00,000
first and then it has another data

00:07:59,280 --> 00:08:01,440
member

00:08:00,000 --> 00:08:03,520
second data member of the second type

00:08:01,440 --> 00:08:05,360
and its name is second

00:08:03,520 --> 00:08:06,639
right uh so the first one must be

00:08:05,360 --> 00:08:08,240
located offset zero

00:08:06,639 --> 00:08:09,680
and then the second one comes somewhere

00:08:08,240 --> 00:08:12,400
after that

00:08:09,680 --> 00:08:13,360
um and that's basically all that's did

00:08:12,400 --> 00:08:15,840
pair is

00:08:13,360 --> 00:08:16,639
it's it's a struct template with two

00:08:15,840 --> 00:08:18,160
data members

00:08:16,639 --> 00:08:21,280
the first one is named first the second

00:08:18,160 --> 00:08:22,960
one is name second and those

00:08:21,280 --> 00:08:25,280
so to use that you just access those

00:08:22,960 --> 00:08:27,520
numbers um

00:08:25,280 --> 00:08:29,360
but that was just product types there is

00:08:27,520 --> 00:08:30,160
another algebraic operation that we can

00:08:29,360 --> 00:08:34,479
use here

00:08:30,160 --> 00:08:36,399
um and that is addition so

00:08:34,479 --> 00:08:38,560
if i take my char in my bool and instead

00:08:36,399 --> 00:08:40,959
of putting them into a pair or tuple

00:08:38,560 --> 00:08:42,240
a product type suppose i put them into a

00:08:40,959 --> 00:08:44,880
variant

00:08:42,240 --> 00:08:47,360
now a variant is kind of like a union

00:08:44,880 --> 00:08:50,640
when i have a variant of char kamabul

00:08:47,360 --> 00:08:53,760
that means that it can hold a char or

00:08:50,640 --> 00:08:56,880
a bool but not both at the same time

00:08:53,760 --> 00:08:59,120
so the variant here can hold

00:08:56,880 --> 00:09:00,399
any one of the 256 possible values of

00:08:59,120 --> 00:09:02,800
char

00:09:00,399 --> 00:09:04,560
or it could hold true or it could hold

00:09:02,800 --> 00:09:06,480
false the two values of bool

00:09:04,560 --> 00:09:08,000
so to figure out how many possible

00:09:06,480 --> 00:09:10,240
states could it be in

00:09:08,000 --> 00:09:11,519
what we do is we take those 256 possible

00:09:10,240 --> 00:09:14,160
states and add them to those two

00:09:11,519 --> 00:09:17,680
possible states and we get 258

00:09:14,160 --> 00:09:21,440
right so variant would be called

00:09:17,680 --> 00:09:25,040
a sum type

00:09:21,440 --> 00:09:26,560
if we get the yes um so

00:09:25,040 --> 00:09:28,480
define the size of the domain of a

00:09:26,560 --> 00:09:29,680
variant type that is to say a sum type

00:09:28,480 --> 00:09:32,160
we're going to take the sum

00:09:29,680 --> 00:09:33,920
of the cardinalities of the domains of

00:09:32,160 --> 00:09:35,360
of its alternative types

00:09:33,920 --> 00:09:36,399
when we're talking about a variant by

00:09:35,360 --> 00:09:38,560
the way i'm going to try to use the

00:09:36,399 --> 00:09:39,839
phrase alternatives to describe its

00:09:38,560 --> 00:09:43,120
elements

00:09:39,839 --> 00:09:43,440
tuples and pairs have elements variants

00:09:43,120 --> 00:09:45,279
have

00:09:43,440 --> 00:09:47,920
alternatives but it means the same thing

00:09:45,279 --> 00:09:50,560
it means the template parameters

00:09:47,920 --> 00:09:51,680
so a variant of a and b has a plus b

00:09:50,560 --> 00:09:54,640
possible values

00:09:51,680 --> 00:09:55,440
a variant of abc and so on you just add

00:09:54,640 --> 00:09:57,120
up

00:09:55,440 --> 00:09:58,480
the number of possible states of each of

00:09:57,120 --> 00:09:58,959
those individual things because it might

00:09:58,480 --> 00:10:02,079
hold an

00:09:58,959 --> 00:10:03,519
a it might hold a b it might hold a c so

00:10:02,079 --> 00:10:04,480
you add up all those possibilities that

00:10:03,519 --> 00:10:05,920
gives you the total number of

00:10:04,480 --> 00:10:07,920
possibilities

00:10:05,920 --> 00:10:09,680
so variant is known as a sum type so

00:10:07,920 --> 00:10:10,560
when i talk about algebraic data types

00:10:09,680 --> 00:10:14,320
i'm talking about

00:10:10,560 --> 00:10:14,320
product types and sum types

00:10:15,440 --> 00:10:19,760
here's the memory layout of a sum type

00:10:18,000 --> 00:10:22,880
as opposed to a product type

00:10:19,760 --> 00:10:24,560
so up top here i have a tuple of a b

00:10:22,880 --> 00:10:26,160
and c and again this is our conceptual

00:10:24,560 --> 00:10:27,680
picture i'm not worrying about uh

00:10:26,160 --> 00:10:30,240
padding or anything here

00:10:27,680 --> 00:10:30,800
um so it holds an a and then next to it

00:10:30,240 --> 00:10:34,160
a b

00:10:30,800 --> 00:10:35,839
next to it a c uh variant on the other

00:10:34,160 --> 00:10:37,920
hand only needs to store one of its

00:10:35,839 --> 00:10:42,240
alternatives at any single time

00:10:37,920 --> 00:10:44,160
so it can hold an a or a b or a c

00:10:42,240 --> 00:10:45,839
and it can reuse the same memory for

00:10:44,160 --> 00:10:47,120
each of these it lays them out basically

00:10:45,839 --> 00:10:50,480
one on top of the other

00:10:47,120 --> 00:10:52,320
just like in a union all at offset zero

00:10:50,480 --> 00:10:54,560
we're all at the same offset we don't

00:10:52,320 --> 00:10:56,800
really know what the abi is here but

00:10:54,560 --> 00:10:58,079
this is our conceptual picture that a

00:10:56,800 --> 00:11:00,480
tuple has an a

00:10:58,079 --> 00:11:02,560
and a b and a c next to each other a

00:11:00,480 --> 00:11:04,000
variant has an a a b and a c

00:11:02,560 --> 00:11:07,440
all living in the same place right on

00:11:04,000 --> 00:11:09,200
top of each other mass hysteria

00:11:07,440 --> 00:11:10,480
but this picture misses something right

00:11:09,200 --> 00:11:11,839
the conceptual picture in the previous

00:11:10,480 --> 00:11:13,120
slide is not quite right and it's not

00:11:11,839 --> 00:11:15,279
just because of padding

00:11:13,120 --> 00:11:17,920
it's because of type safety the stl's

00:11:15,279 --> 00:11:20,959
variant is designed to be type safe

00:11:17,920 --> 00:11:23,680
a c-style union is not type safe it

00:11:20,959 --> 00:11:27,120
doesn't know what type it holds

00:11:23,680 --> 00:11:28,079
when i say i have a union here of an int

00:11:27,120 --> 00:11:31,360
and a float

00:11:28,079 --> 00:11:33,760
and i put 3.14 into the float member

00:11:31,360 --> 00:11:35,279
and then i read out of the int member

00:11:33,760 --> 00:11:36,399
that's totally fine i mean it's probably

00:11:35,279 --> 00:11:38,560
undefined behavior

00:11:36,399 --> 00:11:40,640
but i don't know certainly don't rely on

00:11:38,560 --> 00:11:42,320
it i get some you know one billion

00:11:40,640 --> 00:11:44,320
some some number that's definitely not

00:11:42,320 --> 00:11:46,399
3.14 so

00:11:44,320 --> 00:11:47,839
uh this is not very type safe i can put

00:11:46,399 --> 00:11:49,440
in a float and get out in the int

00:11:47,839 --> 00:11:51,279
and the compiler doesn't complain at me

00:11:49,440 --> 00:11:54,560
and the runtime doesn't complain at me

00:11:51,279 --> 00:11:55,040
and it just does garbage variant on the

00:11:54,560 --> 00:11:57,440
other hand

00:11:55,040 --> 00:11:58,720
is type safe in the c plus plus sense i

00:11:57,440 --> 00:12:01,440
put a float

00:11:58,720 --> 00:12:02,240
into it and then later i try to get out

00:12:01,440 --> 00:12:04,560
an int

00:12:02,240 --> 00:12:06,399
we'll we'll see the the stid get syntax

00:12:04,560 --> 00:12:09,600
um in a few slides

00:12:06,399 --> 00:12:11,680
um and when i do this the variant

00:12:09,600 --> 00:12:13,279
knows that it does not hold an int it

00:12:11,680 --> 00:12:16,320
holds a float

00:12:13,279 --> 00:12:18,880
right so it throws an exception

00:12:16,320 --> 00:12:19,920
just like uh you know if i try to access

00:12:18,880 --> 00:12:22,000
um

00:12:19,920 --> 00:12:23,600
out of range of a vector using the

00:12:22,000 --> 00:12:25,360
vector dot at

00:12:23,600 --> 00:12:26,800
method it would throw an exception this

00:12:25,360 --> 00:12:27,760
will also throw an exception because i'm

00:12:26,800 --> 00:12:30,880
doing something that

00:12:27,760 --> 00:12:32,480
dynamically is not correct i'm trying to

00:12:30,880 --> 00:12:34,000
get out an int and it doesn't hold in it

00:12:32,480 --> 00:12:37,760
it holds a float right now

00:12:34,000 --> 00:12:40,639
so i get an exception cool

00:12:37,760 --> 00:12:42,720
so actually variant also has to store

00:12:40,639 --> 00:12:44,560
has to remember this index field

00:12:42,720 --> 00:12:45,760
that tells it which of its three

00:12:44,560 --> 00:12:48,160
alternatives or however many

00:12:45,760 --> 00:12:51,600
alternatives is currently active

00:12:48,160 --> 00:12:53,600
so uh you can access

00:12:51,600 --> 00:12:55,200
uh the index there's a getter for index

00:12:53,600 --> 00:12:57,200
it's called index

00:12:55,200 --> 00:12:58,959
um and it's a const member function and

00:12:57,200 --> 00:13:01,760
tells you which alternative is active

00:12:58,959 --> 00:13:02,320
uh as a as a size t zero one or two in

00:13:01,760 --> 00:13:05,120
this case

00:13:02,320 --> 00:13:05,839
zero would mean a one would mean b uh 2

00:13:05,120 --> 00:13:07,839
would mean c

00:13:05,839 --> 00:13:11,040
because that's the order of the template

00:13:07,839 --> 00:13:14,560
parameters in this case

00:13:11,040 --> 00:13:14,560
um right

00:13:14,800 --> 00:13:19,200
finally there's one more sum type which

00:13:17,360 --> 00:13:20,959
is actually the most useful one in my

00:13:19,200 --> 00:13:24,000
opinion in c plus plus

00:13:20,959 --> 00:13:26,000
and that is optional so like pair

00:13:24,000 --> 00:13:27,760
optional has been optimized for certain

00:13:26,000 --> 00:13:31,600
common use cases

00:13:27,760 --> 00:13:33,440
uh it only takes one template parameter

00:13:31,600 --> 00:13:35,440
you can't have an optional of a comma b

00:13:33,440 --> 00:13:38,480
it's just optional of a

00:13:35,440 --> 00:13:39,680
and that can either store an a a value

00:13:38,480 --> 00:13:42,079
of type a

00:13:39,680 --> 00:13:43,040
or it can store the special value

00:13:42,079 --> 00:13:44,720
nulloped

00:13:43,040 --> 00:13:46,160
which is of a special library type

00:13:44,720 --> 00:13:50,160
called stid null opt

00:13:46,160 --> 00:13:52,000
t of thunder square t um

00:13:50,160 --> 00:13:53,680
so it's essentially a variant of a

00:13:52,000 --> 00:13:56,639
common null opti

00:13:53,680 --> 00:13:58,480
um but it's always that and so it is it

00:13:56,639 --> 00:14:01,120
can be optimized for that

00:13:58,480 --> 00:14:02,000
so it's also an algebraic data type it's

00:14:01,120 --> 00:14:03,279
an algebraic

00:14:02,000 --> 00:14:05,040
expression that tells us how many

00:14:03,279 --> 00:14:06,959
possible values because an optional a

00:14:05,040 --> 00:14:09,760
store and the answer is

00:14:06,959 --> 00:14:11,920
a plus one it could store an a or it

00:14:09,760 --> 00:14:15,040
could store this extra one state that we

00:14:11,920 --> 00:14:15,040
have than the log state

00:14:15,440 --> 00:14:18,800
so optional also has to store an index

00:14:17,120 --> 00:14:20,560
field for type safety but its index

00:14:18,800 --> 00:14:23,519
field is just a bool it says

00:14:20,560 --> 00:14:24,000
do i have a uh on this slide i'm calling

00:14:23,519 --> 00:14:26,480
it c

00:14:24,000 --> 00:14:27,760
i suppose uh do i have a c inside myself

00:14:26,480 --> 00:14:30,800
or do i have

00:14:27,760 --> 00:14:32,079
nothing do i have null opt the null op

00:14:30,800 --> 00:14:33,600
does not need to be stored physically in

00:14:32,079 --> 00:14:35,760
memory you can never get a reference to

00:14:33,600 --> 00:14:37,279
the null opt

00:14:35,760 --> 00:14:39,760
and so it's basically just do i have a c

00:14:37,279 --> 00:14:39,760
or not

00:14:40,079 --> 00:14:43,760
um right so an optional will tend to be

00:14:42,639 --> 00:14:46,560
smaller

00:14:43,760 --> 00:14:46,560
than a variant

00:14:48,720 --> 00:14:52,160
so some of you are probably wondering

00:14:50,639 --> 00:14:55,519
what about stid any

00:14:52,160 --> 00:14:56,079
right we often hear that c plus plus 17

00:14:55,519 --> 00:14:58,399
gave us

00:14:56,079 --> 00:14:59,600
optional invariant in any all in the

00:14:58,399 --> 00:15:01,760
same breath

00:14:59,600 --> 00:15:02,800
all right but i'm not talking about did

00:15:01,760 --> 00:15:05,680
any in

00:15:02,800 --> 00:15:06,800
this talk because it is not an algebraic

00:15:05,680 --> 00:15:09,920
data type

00:15:06,800 --> 00:15:13,120
uh it doesn't follow any of these rules

00:15:09,920 --> 00:15:16,240
of using arithmetic operations um

00:15:13,120 --> 00:15:18,240
products and sums to describe

00:15:16,240 --> 00:15:20,000
its set of possible values its set of

00:15:18,240 --> 00:15:22,160
possible values is

00:15:20,000 --> 00:15:23,920
anything at all that is copyable right

00:15:22,160 --> 00:15:24,480
anything that is copyable i can store it

00:15:23,920 --> 00:15:26,720
in a stid

00:15:24,480 --> 00:15:28,560
any it is a type erasure type similar to

00:15:26,720 --> 00:15:30,320
stid function anything that is callable

00:15:28,560 --> 00:15:31,279
i can store it in an appropriate stid

00:15:30,320 --> 00:15:33,680
function

00:15:31,279 --> 00:15:35,600
um i have a talk on type erasure i gave

00:15:33,680 --> 00:15:37,120
it last year in the back to basics track

00:15:35,600 --> 00:15:40,079
if you're interested in that

00:15:37,120 --> 00:15:41,839
check out my cppcon 2019 talk back to

00:15:40,079 --> 00:15:44,560
basics type erasure

00:15:41,839 --> 00:15:45,839
um so steady not going to talk about it

00:15:44,560 --> 00:15:49,440
it's type erasure

00:15:45,839 --> 00:15:50,800
see it last year um but uh because it

00:15:49,440 --> 00:15:53,040
came in at the same time it still has

00:15:50,800 --> 00:15:54,320
some common vocabulary between studenti

00:15:53,040 --> 00:15:55,680
and instead variant or

00:15:54,320 --> 00:15:59,199
other algebraic types so i'll try to

00:15:55,680 --> 00:16:02,959
mention um when that comes up

00:15:59,199 --> 00:16:05,839
so let's very quickly motivate e

00:16:02,959 --> 00:16:07,360
future outbreak types error top optional

00:16:05,839 --> 00:16:09,680
and variant

00:16:07,360 --> 00:16:10,959
where in the standard library would i

00:16:09,680 --> 00:16:14,240
use pair

00:16:10,959 --> 00:16:14,959
um the classic stl uses pair all over

00:16:14,240 --> 00:16:17,040
the place

00:16:14,959 --> 00:16:18,079
it was so important to them to have a

00:16:17,040 --> 00:16:21,680
way of referring

00:16:18,079 --> 00:16:24,880
to two things at once

00:16:21,680 --> 00:16:26,079
for example stid map uses did pair as

00:16:24,880 --> 00:16:28,320
its element type right because the

00:16:26,079 --> 00:16:31,279
elements of a map are key value pairs

00:16:28,320 --> 00:16:32,720
um and you have a key and a value and

00:16:31,279 --> 00:16:34,079
you sort of have to put them together

00:16:32,720 --> 00:16:38,639
and we put them together in

00:16:34,079 --> 00:16:40,720
using the stid pair utility template

00:16:38,639 --> 00:16:42,160
so here if i dereference my map dot

00:16:40,720 --> 00:16:43,120
begin that gives me an element of the

00:16:42,160 --> 00:16:45,360
map

00:16:43,120 --> 00:16:46,160
that element is of types did pair and

00:16:45,360 --> 00:16:47,680
command

00:16:46,160 --> 00:16:49,680
actually the first end is const but

00:16:47,680 --> 00:16:51,680
never mind that

00:16:49,680 --> 00:16:53,519
also when i try to insert into the map

00:16:51,680 --> 00:16:55,279
maps reject duplicates

00:16:53,519 --> 00:16:56,720
and so there are two pieces of

00:16:55,279 --> 00:16:57,360
information that might come back from

00:16:56,720 --> 00:16:59,199
insert

00:16:57,360 --> 00:17:01,040
right there's the iterator of where did

00:16:59,199 --> 00:17:02,560
you insert it

00:17:01,040 --> 00:17:04,640
or where was the collision if there was

00:17:02,560 --> 00:17:06,319
a collision and then there's a boolean

00:17:04,640 --> 00:17:08,400
that says was there a collision or not

00:17:06,319 --> 00:17:11,120
did you actually succeed in inserting it

00:17:08,400 --> 00:17:12,480
or did the insertion fail that's two

00:17:11,120 --> 00:17:13,679
pieces of information that we want to

00:17:12,480 --> 00:17:17,600
get back from insert

00:17:13,679 --> 00:17:19,600
and so the standard library uses a pair

00:17:17,600 --> 00:17:21,280
to simulate multiple return values two

00:17:19,600 --> 00:17:22,240
return values at once by returning a

00:17:21,280 --> 00:17:25,360
pair

00:17:22,240 --> 00:17:26,559
um stidpair is also returned for that

00:17:25,360 --> 00:17:28,400
same reason

00:17:26,559 --> 00:17:30,480
when you call some algorithms us did

00:17:28,400 --> 00:17:32,240
mismatch equal range

00:17:30,480 --> 00:17:34,559
uninitialized movend actually returns a

00:17:32,240 --> 00:17:36,799
pair why not um

00:17:34,559 --> 00:17:39,360
we're getting away from that in uh c

00:17:36,799 --> 00:17:41,600
plus plus 20. a lot of the new ranges

00:17:39,360 --> 00:17:43,280
algorithms return a lot of information

00:17:41,600 --> 00:17:44,160
to you but they'll do it as a named

00:17:43,280 --> 00:17:46,720
struct type

00:17:44,160 --> 00:17:48,160
not as a generic pair of two things but

00:17:46,720 --> 00:17:48,960
they will actually make up their own

00:17:48,160 --> 00:17:50,559
struct type

00:17:48,960 --> 00:17:52,160
with meaningful names for the members

00:17:50,559 --> 00:17:54,880
and i'm going to revisit that

00:17:52,160 --> 00:17:57,600
at the very last slide says do that

00:17:54,880 --> 00:17:57,600
that's a good idea

00:17:57,840 --> 00:18:01,600
so why would we use tuple well since the

00:17:59,840 --> 00:18:03,039
stl uses pair to simulate returning

00:18:01,600 --> 00:18:05,039
multiple results you might imagine

00:18:03,039 --> 00:18:05,679
returning tuple to simulate multiple

00:18:05,039 --> 00:18:08,559
results

00:18:05,679 --> 00:18:09,200
right if i have a function min max that

00:18:08,559 --> 00:18:11,360
takes a

00:18:09,200 --> 00:18:13,200
and b and then returns the minimum and

00:18:11,360 --> 00:18:14,720
the maximum of those two right basically

00:18:13,200 --> 00:18:16,559
it's a sorting algorithm

00:18:14,720 --> 00:18:18,240
but not in memory it's a register

00:18:16,559 --> 00:18:20,640
sorting algorithm that says

00:18:18,240 --> 00:18:22,000
uh give me back the minimum in the first

00:18:20,640 --> 00:18:24,480
element and the maximum and the second

00:18:22,000 --> 00:18:26,960
element of the pair

00:18:24,480 --> 00:18:28,240
so if i had a three element function a

00:18:26,960 --> 00:18:31,760
three argument function

00:18:28,240 --> 00:18:35,280
min mid max that returned me those three

00:18:31,760 --> 00:18:37,039
ins in order right the first element of

00:18:35,280 --> 00:18:38,480
the tuple would be the min

00:18:37,039 --> 00:18:40,400
the second element would be the middle

00:18:38,480 --> 00:18:42,720
element and the third element would be

00:18:40,400 --> 00:18:45,679
the max element um

00:18:42,720 --> 00:18:47,679
i could do this however as i said c plus

00:18:45,679 --> 00:18:49,200
plus 20 moved away from doing that

00:18:47,679 --> 00:18:51,360
they probably wouldn't even return a

00:18:49,200 --> 00:18:53,120
pair from min max

00:18:51,360 --> 00:18:55,039
they would have a dedicated struct type

00:18:53,120 --> 00:18:56,640
and i recommend you do the same

00:18:55,039 --> 00:18:58,240
you could also imagine using a tuple to

00:18:56,640 --> 00:19:00,160
hold a pack of of

00:18:58,240 --> 00:19:01,600
data members or something that's not a

00:19:00,160 --> 00:19:03,200
very back to basics topic

00:19:01,600 --> 00:19:05,280
i'm not going to talk anymore about that

00:19:03,200 --> 00:19:06,480
but that is a case where you might have

00:19:05,280 --> 00:19:08,000
a bunch of stuff that you don't really

00:19:06,480 --> 00:19:10,320
know what it is

00:19:08,000 --> 00:19:13,120
and you just stick it in a stid tuple

00:19:10,320 --> 00:19:13,120
and it just works

00:19:13,760 --> 00:19:17,039
tuple is also used very arcanely to

00:19:15,679 --> 00:19:17,760
forward sets of arguments to pairs

00:19:17,039 --> 00:19:19,760
constructor

00:19:17,760 --> 00:19:21,919
we will see this come back later when we

00:19:19,760 --> 00:19:24,400
talk about pair and tuple

00:19:21,919 --> 00:19:28,080
after questions here we'll also see a

00:19:24,400 --> 00:19:28,080
couple useful idioms with stid tie

00:19:28,160 --> 00:19:33,360
which we'll come back to um

00:19:31,760 --> 00:19:34,880
so optional right so that was pair and

00:19:33,360 --> 00:19:37,120
tuple why would we use optional

00:19:34,880 --> 00:19:39,440
optional is not used in the stl there is

00:19:37,120 --> 00:19:40,720
no functions in the standard library

00:19:39,440 --> 00:19:43,360
that return an optional

00:19:40,720 --> 00:19:46,160
or take optional but it is the most

00:19:43,360 --> 00:19:48,240
useful for your own code

00:19:46,160 --> 00:19:49,919
when i have a function that has a return

00:19:48,240 --> 00:19:52,960
type of stid optional

00:19:49,919 --> 00:19:53,679
that's like saying maybe it's like

00:19:52,960 --> 00:19:56,799
saying

00:19:53,679 --> 00:19:59,600
maybe i return uh an answer and

00:19:56,799 --> 00:20:00,559
maybe i don't have an answer for you

00:19:59,600 --> 00:20:02,559
right it's like

00:20:00,559 --> 00:20:04,240
it's like nullable if you're coming from

00:20:02,559 --> 00:20:07,440
uh kotlin i guess they have

00:20:04,240 --> 00:20:08,159
nullable things um and a lot of

00:20:07,440 --> 00:20:10,480
languages have

00:20:08,159 --> 00:20:11,520
maybe it's the same idea you're saying

00:20:10,480 --> 00:20:13,679
uh

00:20:11,520 --> 00:20:15,039
okay you told me to look up this name of

00:20:13,679 --> 00:20:15,919
this environment variable i tried to

00:20:15,039 --> 00:20:18,400
look it up in

00:20:15,919 --> 00:20:20,400
the environment and i found it and here

00:20:18,400 --> 00:20:22,799
is its value as a string

00:20:20,400 --> 00:20:24,559
or there is another alternative which is

00:20:22,799 --> 00:20:27,919
that i didn't find it and in that case

00:20:24,559 --> 00:20:27,919
i'm going to return nulloped

00:20:28,720 --> 00:20:32,320
this could also be used in codebases

00:20:31,360 --> 00:20:34,320
that

00:20:32,320 --> 00:20:35,520
would maybe normally throw an exception

00:20:34,320 --> 00:20:37,120
right i didn't find it i'll throw an

00:20:35,520 --> 00:20:39,440
exception but that's slow and maybe my

00:20:37,120 --> 00:20:41,600
code base doesn't uh like exceptions

00:20:39,440 --> 00:20:43,679
um so instead i'll return an optional

00:20:41,600 --> 00:20:44,880
right that allows me to just signal

00:20:43,679 --> 00:20:46,320
there was some something went wrong i

00:20:44,880 --> 00:20:47,280
didn't get the answer doesn't let me

00:20:46,320 --> 00:20:49,280
signal what it is

00:20:47,280 --> 00:20:51,760
just either i have an answer for you or

00:20:49,280 --> 00:20:54,880
i don't

00:20:51,760 --> 00:20:57,360
in a variable such as a data member uh

00:20:54,880 --> 00:21:00,400
you can use optional to represent

00:20:57,360 --> 00:21:01,200
has no setting that's different from set

00:21:00,400 --> 00:21:04,480
to empty

00:21:01,200 --> 00:21:05,039
if it is different right so i might have

00:21:04,480 --> 00:21:07,679
inside

00:21:05,039 --> 00:21:09,919
a compiler or something i might have uh

00:21:07,679 --> 00:21:11,039
a getter for the include path

00:21:09,919 --> 00:21:12,960
i have a data member here that

00:21:11,039 --> 00:21:16,880
represents the include path uh

00:21:12,960 --> 00:21:19,120
that was given by the uh

00:21:16,880 --> 00:21:21,039
the programmer right if they provided

00:21:19,120 --> 00:21:22,000
one to me then i put it in the include

00:21:21,039 --> 00:21:24,880
path member

00:21:22,000 --> 00:21:26,640
but if they didn't pass dash i at all

00:21:24,880 --> 00:21:28,960
they didn't give me an include path

00:21:26,640 --> 00:21:30,960
um then in that case i want to just use

00:21:28,960 --> 00:21:33,120
user include

00:21:30,960 --> 00:21:34,480
right so i make a second variable i say

00:21:33,120 --> 00:21:36,400
if they give me an include path

00:21:34,480 --> 00:21:38,159
then i'll set has include path to true

00:21:36,400 --> 00:21:39,039
and i'll set include path the thing they

00:21:38,159 --> 00:21:42,320
gave me

00:21:39,039 --> 00:21:43,679
um which might be empty

00:21:42,320 --> 00:21:46,000
and if in clue path is false then i'll

00:21:43,679 --> 00:21:48,400
use user include

00:21:46,000 --> 00:21:49,919
in c plus plus 17 and later it would be

00:21:48,400 --> 00:21:53,600
idiomatic to instead

00:21:49,919 --> 00:21:57,520
use an optional string right now

00:21:53,600 --> 00:21:58,960
i can say uh uh if it is null opt

00:21:57,520 --> 00:22:00,400
which happens to be the default

00:21:58,960 --> 00:22:01,679
constructed state of an optional by the

00:22:00,400 --> 00:22:03,760
way it's default constructed

00:22:01,679 --> 00:22:06,000
in the disengaged state with with no

00:22:03,760 --> 00:22:06,880
value uh in that case i'm going to use

00:22:06,000 --> 00:22:09,280
user include

00:22:06,880 --> 00:22:10,400
but if they gave me a value i'll store

00:22:09,280 --> 00:22:12,720
it in this optional

00:22:10,400 --> 00:22:14,799
right and so that's one line shorter

00:22:12,720 --> 00:22:16,240
here it's it's we have a nice accessor

00:22:14,799 --> 00:22:17,600
here instead of having to use the

00:22:16,240 --> 00:22:19,919
ternary operator

00:22:17,600 --> 00:22:21,440
uh it's just all around nicer to use

00:22:19,919 --> 00:22:23,360
optional to represent

00:22:21,440 --> 00:22:27,840
no setting when that's distinct from the

00:22:23,360 --> 00:22:27,840
empty state the the empty string

00:22:29,039 --> 00:22:32,480
optional can also be used to represent

00:22:30,640 --> 00:22:33,760
not initialized yet for types with no

00:22:32,480 --> 00:22:35,520
default constructor this gives us the

00:22:33,760 --> 00:22:38,640
benefit of dynamic lifetime

00:22:35,520 --> 00:22:41,200
without heap usage right classical c

00:22:38,640 --> 00:22:41,840
plus says the way you get dynamic object

00:22:41,200 --> 00:22:44,640
lifetime

00:22:41,840 --> 00:22:46,159
is dynamic memory allocation optional

00:22:44,640 --> 00:22:48,880
lets us get away from that

00:22:46,159 --> 00:22:50,240
where before i might have said i don't

00:22:48,880 --> 00:22:52,480
always have

00:22:50,240 --> 00:22:53,440
a setting for obj it's some complicated

00:22:52,480 --> 00:22:54,400
object it doesn't have a default

00:22:53,440 --> 00:22:56,640
constructor

00:22:54,400 --> 00:22:57,760
uh i will keep allocate one when i need

00:22:56,640 --> 00:23:01,440
it

00:22:57,760 --> 00:23:03,280
in c plus 17 using optional we can say

00:23:01,440 --> 00:23:04,640
i may have a complicated object i don't

00:23:03,280 --> 00:23:07,440
have one right now

00:23:04,640 --> 00:23:09,760
i will emplace it when i need it and

00:23:07,440 --> 00:23:12,080
there's no heap allocation involved

00:23:09,760 --> 00:23:13,760
um here's the same thing in a memory

00:23:12,080 --> 00:23:16,240
footprint diagram

00:23:13,760 --> 00:23:17,440
here with the unique putter this is the

00:23:16,240 --> 00:23:20,080
old style of code

00:23:17,440 --> 00:23:22,000
uh i would say when it when it is

00:23:20,080 --> 00:23:24,559
engaged when there is

00:23:22,000 --> 00:23:26,080
a controlled object then i have a

00:23:24,559 --> 00:23:27,919
pointer to it and it's out here on the

00:23:26,080 --> 00:23:29,919
heap and i own that object

00:23:27,919 --> 00:23:31,760
and then when i'm done with the object i

00:23:29,919 --> 00:23:32,960
clean it up and i set the pointer to

00:23:31,760 --> 00:23:34,880
null

00:23:32,960 --> 00:23:36,159
that's fine but it uses heap allocation

00:23:34,880 --> 00:23:37,039
if i want to get away from heap

00:23:36,159 --> 00:23:39,120
allocation

00:23:37,039 --> 00:23:40,320
for the cost of making my stack size

00:23:39,120 --> 00:23:41,679
slightly bigger

00:23:40,320 --> 00:23:43,440
right i can store it right here on the

00:23:41,679 --> 00:23:48,320
stack i can say uh

00:23:43,440 --> 00:23:51,039
it is engaged true that it has a value

00:23:48,320 --> 00:23:53,360
and here it is or it's disengaged it

00:23:51,039 --> 00:23:55,760
doesn't have a value

00:23:53,360 --> 00:23:57,919
and in both cases there's no heap usage

00:23:55,760 --> 00:23:57,919
here

00:23:59,120 --> 00:24:04,240
why might i use variant um

00:24:02,240 --> 00:24:05,600
i don't have any really good motivating

00:24:04,240 --> 00:24:08,799
examples for variant

00:24:05,600 --> 00:24:09,840
um i think that it's a relatively

00:24:08,799 --> 00:24:11,600
special

00:24:09,840 --> 00:24:13,279
purpose thing if you need it you

00:24:11,600 --> 00:24:17,200
probably know you need it

00:24:13,279 --> 00:24:19,600
um but here's an example where i have

00:24:17,200 --> 00:24:20,720
a class representing a chess move which

00:24:19,600 --> 00:24:22,880
can be either a

00:24:20,720 --> 00:24:24,080
simple non-capturing move a capturing

00:24:22,880 --> 00:24:28,960
move or

00:24:24,080 --> 00:24:28,960
a castling and

00:24:30,880 --> 00:24:37,600
so that in english i said i

00:24:34,480 --> 00:24:39,840
it's either this or this or this so

00:24:37,600 --> 00:24:42,159
uh in the code i can write that out

00:24:39,840 --> 00:24:43,679
using a sum type like variant i can say

00:24:42,159 --> 00:24:46,159
well it's a variant of a simple a

00:24:43,679 --> 00:24:48,400
capture or a castle

00:24:46,159 --> 00:24:49,919
and then i can have these getters here

00:24:48,400 --> 00:24:53,039
just showing that i can

00:24:49,919 --> 00:24:55,200
figure out whether it has

00:24:53,039 --> 00:24:57,440
a simple a capture or a castle inside

00:24:55,200 --> 00:24:59,679
itself based on the index

00:24:57,440 --> 00:25:01,279
accessor i don't have to have a separate

00:24:59,679 --> 00:25:02,960
tag that tells me

00:25:01,279 --> 00:25:04,720
because the variant is type safe and the

00:25:02,960 --> 00:25:06,240
variant remembers what was put in it

00:25:04,720 --> 00:25:09,360
last

00:25:06,240 --> 00:25:10,480
um so yes i could open code this using a

00:25:09,360 --> 00:25:13,520
union

00:25:10,480 --> 00:25:14,240
add a little tag at the top but variant

00:25:13,520 --> 00:25:19,520
does all that

00:25:14,240 --> 00:25:20,799
hard work for me um so that's nice

00:25:19,520 --> 00:25:22,080
so now you know how they look in memory

00:25:20,799 --> 00:25:23,360
and have some general motivation for

00:25:22,080 --> 00:25:24,720
them let's talk about this equals plus

00:25:23,360 --> 00:25:26,840
side of things let's talk about common

00:25:24,720 --> 00:25:29,600
concepts and vocabulary

00:25:26,840 --> 00:25:30,080
um but also i think there are some q and

00:25:29,600 --> 00:25:31,760
a

00:25:30,080 --> 00:25:34,559
even though we're not up to a question

00:25:31,760 --> 00:25:37,679
slide uh i will take a little look here

00:25:34,559 --> 00:25:38,960
and someone asks is a pair superior to a

00:25:37,679 --> 00:25:41,039
tuple of length two

00:25:38,960 --> 00:25:42,400
is there a reason for me to use stid

00:25:41,039 --> 00:25:45,200
pair of a b

00:25:42,400 --> 00:25:45,760
over stid tuple of a b uh and i would

00:25:45,200 --> 00:25:48,720
say

00:25:45,760 --> 00:25:50,159
uh no neither is better than the other

00:25:48,720 --> 00:25:52,480
um

00:25:50,159 --> 00:25:53,279
uh obviously if you don't know how many

00:25:52,480 --> 00:25:55,520
elements you have

00:25:53,279 --> 00:25:57,039
right if it's like a pack coming in you

00:25:55,520 --> 00:25:59,679
have to use tuple

00:25:57,039 --> 00:26:01,120
if you know that you have exactly two uh

00:25:59,679 --> 00:26:04,240
it really doesn't matter whether you use

00:26:01,120 --> 00:26:05,919
pair or topple

00:26:04,240 --> 00:26:08,400
they behave very similarly as we're

00:26:05,919 --> 00:26:08,400
about to see

00:26:08,559 --> 00:26:12,640
someone says a variant has a performance

00:26:10,480 --> 00:26:15,120
penalty uh relative to union

00:26:12,640 --> 00:26:16,559
um yes it totally does uh and we

00:26:15,120 --> 00:26:18,320
actually kind of saw that

00:26:16,559 --> 00:26:19,679
on that slide that had the memory layout

00:26:18,320 --> 00:26:23,520
right the uh

00:26:19,679 --> 00:26:26,400
the memory layout of a variant

00:26:23,520 --> 00:26:27,520
versus optional versus a union the

00:26:26,400 --> 00:26:29,520
variant has

00:26:27,520 --> 00:26:30,960
it's gonna be you know at least four

00:26:29,520 --> 00:26:32,400
bytes bigger because it has that index

00:26:30,960 --> 00:26:33,279
field a union won't have that index

00:26:32,400 --> 00:26:37,200
field

00:26:33,279 --> 00:26:39,840
um so you know it has to maintain that

00:26:37,200 --> 00:26:41,600
i wouldn't expect there to be any super

00:26:39,840 --> 00:26:45,600
big performance difference

00:26:41,600 --> 00:26:49,360
um not attributable in some way to that

00:26:45,600 --> 00:26:52,640
or to just you know variant having a lot

00:26:49,360 --> 00:26:54,720
of uh member functions helper functions

00:26:52,640 --> 00:26:56,559
uh you might pay an abstraction penalty

00:26:54,720 --> 00:26:58,559
if you're compiling in debug mode

00:26:56,559 --> 00:27:01,039
right you need the inliner really to get

00:26:58,559 --> 00:27:02,480
rid of some of that library craft

00:27:01,039 --> 00:27:04,400
uh you need the inliner turned on you

00:27:02,480 --> 00:27:04,720
need optimizations turned on that's true

00:27:04,400 --> 00:27:05,840
for

00:27:04,720 --> 00:27:08,240
anything though right that's true for

00:27:05,840 --> 00:27:09,919
vector right the point of variant

00:27:08,240 --> 00:27:11,840
is it does all the work for you just

00:27:09,919 --> 00:27:15,120
like vector right

00:27:11,840 --> 00:27:16,400
you don't have to write it yourself um

00:27:15,120 --> 00:27:18,159
there's a question about pragma pack

00:27:16,400 --> 00:27:20,880
that i think i'm going to come back to

00:27:18,159 --> 00:27:21,520
um but the short answer is i don't know

00:27:20,880 --> 00:27:22,880
um

00:27:21,520 --> 00:27:24,880
and there's a question about a stid

00:27:22,880 --> 00:27:28,640
variant versus boost variant and

00:27:24,880 --> 00:27:31,600
qtq variant um and

00:27:28,640 --> 00:27:32,960
uh i know boost variant can be recursive

00:27:31,600 --> 00:27:34,080
uh which i'm not going to talk about in

00:27:32,960 --> 00:27:37,919
this talk um

00:27:34,080 --> 00:27:40,159
i don't know anything about qvarian um

00:27:37,919 --> 00:27:40,159
right

00:27:42,640 --> 00:27:46,720
oops i was looking for my question slide

00:27:45,279 --> 00:27:48,799
and forgot that i didn't do a question

00:27:46,720 --> 00:27:52,480
slide yet all right

00:27:48,799 --> 00:27:55,840
so let's talk about some of this um

00:27:52,480 --> 00:27:55,840
common vocabulary

00:27:56,159 --> 00:28:01,120
so we have uh these two words which i

00:27:58,320 --> 00:28:02,159
have already used engaged and disengaged

00:28:01,120 --> 00:28:04,799
um

00:28:02,159 --> 00:28:06,399
these are i think not terms you'll find

00:28:04,799 --> 00:28:08,640
in the standard but they're common

00:28:06,399 --> 00:28:10,559
uh when you're talking about optional

00:28:08,640 --> 00:28:12,720
like types an optional which holds a

00:28:10,559 --> 00:28:14,320
value is often said to be engaged

00:28:12,720 --> 00:28:16,720
and optional which is empty is said to

00:28:14,320 --> 00:28:18,000
be disengaged um

00:28:16,720 --> 00:28:19,679
these terms are not relevant to any of

00:28:18,000 --> 00:28:20,480
the other algebraic data types just

00:28:19,679 --> 00:28:22,799
optional

00:28:20,480 --> 00:28:23,840
um but they're very useful you know if

00:28:22,799 --> 00:28:26,480
you if

00:28:23,840 --> 00:28:28,000
uh you know a coworker says uh this

00:28:26,480 --> 00:28:29,600
optional is disengaged now you know what

00:28:28,000 --> 00:28:30,880
that means it means it's empty it's null

00:28:29,600 --> 00:28:33,039
opt

00:28:30,880 --> 00:28:34,240
you can test the engagedness of an

00:28:33,039 --> 00:28:37,279
optional

00:28:34,240 --> 00:28:39,919
by asking it do you have a value

00:28:37,279 --> 00:28:41,600
o dot has value where o is an optional

00:28:39,919 --> 00:28:43,520
that member function will give you back

00:28:41,600 --> 00:28:46,080
a bool

00:28:43,520 --> 00:28:47,279
that says weather has a value optionals

00:28:46,080 --> 00:28:49,120
are also

00:28:47,279 --> 00:28:50,799
explicitly convertible to bool so you

00:28:49,120 --> 00:28:53,200
can test them

00:28:50,799 --> 00:28:54,720
in an if statement right here i'm using

00:28:53,200 --> 00:28:56,720
my getend function that we saw in the

00:28:54,720 --> 00:29:00,080
previous slide that returns an optional

00:28:56,720 --> 00:29:01,200
i'm storing its return value the the

00:29:00,080 --> 00:29:04,720
thing of type

00:29:01,200 --> 00:29:08,159
stid optional of stood string into o

00:29:04,720 --> 00:29:09,200
and i'm using this uh declaration inside

00:29:08,159 --> 00:29:12,559
and if condition

00:29:09,200 --> 00:29:14,240
uh to test o at the same time

00:29:12,559 --> 00:29:15,919
or once i already have o in scope i can

00:29:14,240 --> 00:29:18,880
just say if o that means the same thing

00:29:15,919 --> 00:29:21,600
as if o has value

00:29:18,880 --> 00:29:24,320
um by the way there are some other types

00:29:21,600 --> 00:29:26,960
that are not optional but have this same

00:29:24,320 --> 00:29:28,720
uh nullable idea where they're not

00:29:26,960 --> 00:29:30,399
pointers but they

00:29:28,720 --> 00:29:32,159
uh they own some unique resource and

00:29:30,399 --> 00:29:34,159
they tend to have some disengaged state

00:29:32,159 --> 00:29:35,520
uh type erase types likes did any and

00:29:34,159 --> 00:29:38,720
stid function

00:29:35,520 --> 00:29:40,000
um uh tend to have a disengaged state i

00:29:38,720 --> 00:29:42,720
can have a disengaged

00:29:40,000 --> 00:29:44,159
uh any um and i can find out if it's in

00:29:42,720 --> 00:29:44,880
that state by asking it do you have a

00:29:44,159 --> 00:29:46,640
value

00:29:44,880 --> 00:29:47,919
dot has value that's exactly the same

00:29:46,640 --> 00:29:48,720
spelling that i would use with an

00:29:47,919 --> 00:29:51,760
optional

00:29:48,720 --> 00:29:52,480
uh stid function uh does not have a has

00:29:51,760 --> 00:29:54,320
value

00:29:52,480 --> 00:29:56,480
method but it is implicitly or

00:29:54,320 --> 00:29:59,120
explicitly convertible to bool

00:29:56,480 --> 00:29:59,600
um so optional actually supports both of

00:29:59,120 --> 00:30:01,360
those

00:29:59,600 --> 00:30:02,960
right it was added after those and they

00:30:01,360 --> 00:30:06,559
just said okay we'll just do both

00:30:02,960 --> 00:30:06,559
and you can use either one that you want

00:30:06,720 --> 00:30:10,720
other uh types which own unique

00:30:08,399 --> 00:30:13,440
resources include future unique lock

00:30:10,720 --> 00:30:14,240
uh promise thread uh those could all be

00:30:13,440 --> 00:30:15,919
in a state

00:30:14,240 --> 00:30:17,360
uh where they do not actually have the

00:30:15,919 --> 00:30:18,960
resource at the moment

00:30:17,360 --> 00:30:20,640
uh and you might refer to one of them as

00:30:18,960 --> 00:30:23,840
being disengaged uh

00:30:20,640 --> 00:30:23,840
in that context

00:30:23,919 --> 00:30:27,039
another verb that you'll see that came

00:30:25,440 --> 00:30:30,480
in with c plus plus 11

00:30:27,039 --> 00:30:33,279
was m place you can think of a variant

00:30:30,480 --> 00:30:35,440
or an optional as a buffer that may or

00:30:33,279 --> 00:30:38,880
may not hold a value of some given type

00:30:35,440 --> 00:30:41,200
and if you want to put an object into it

00:30:38,880 --> 00:30:42,399
into that buffer you call that in

00:30:41,200 --> 00:30:44,640
placing

00:30:42,399 --> 00:30:45,919
uh we can explicitly emplace an object

00:30:44,640 --> 00:30:47,440
in the buffer the same way we might

00:30:45,919 --> 00:30:49,919
emplace an element into a

00:30:47,440 --> 00:30:51,679
stl container like a vector or a set

00:30:49,919 --> 00:30:54,480
right when i say

00:30:51,679 --> 00:30:55,760
vector of string dot m place back and

00:30:54,480 --> 00:30:57,679
then i give it some

00:30:55,760 --> 00:30:59,600
arguments these arguments get perfectly

00:30:57,679 --> 00:31:01,840
forwarded to the constructor

00:30:59,600 --> 00:31:02,799
of string in this case and i construct a

00:31:01,840 --> 00:31:05,039
new string

00:31:02,799 --> 00:31:06,640
with these exact arguments as they were

00:31:05,039 --> 00:31:09,679
perfectly forwarded

00:31:06,640 --> 00:31:11,200
and that creates a new object

00:31:09,679 --> 00:31:12,720
in the case of vector it creates a new

00:31:11,200 --> 00:31:14,000
object at the end of the container

00:31:12,720 --> 00:31:15,679
right it doesn't overwrite anything it

00:31:14,000 --> 00:31:17,120
makes the container bigger in the case

00:31:15,679 --> 00:31:18,640
of optional invariant

00:31:17,120 --> 00:31:20,799
we're in placing directly into the

00:31:18,640 --> 00:31:22,399
buffer inside the object itself

00:31:20,799 --> 00:31:24,480
and that means we have to kick out the

00:31:22,399 --> 00:31:25,360
old value before we can construct the

00:31:24,480 --> 00:31:27,519
new one

00:31:25,360 --> 00:31:28,480
so when i am place into an optional

00:31:27,519 --> 00:31:30,880
string

00:31:28,480 --> 00:31:31,760
that will call strings destructor to

00:31:30,880 --> 00:31:33,039
destroy

00:31:31,760 --> 00:31:34,960
the string that was already there if

00:31:33,039 --> 00:31:37,360
there was one there if it was engaged

00:31:34,960 --> 00:31:39,279
if it was disengaged nothing happens and

00:31:37,360 --> 00:31:41,360
then it will construct

00:31:39,279 --> 00:31:43,600
a new string perfectly forwarding these

00:31:41,360 --> 00:31:46,000
arguments to the constructor of string

00:31:43,600 --> 00:31:46,799
if i have a variant of string and int i

00:31:46,000 --> 00:31:48,960
can say

00:31:46,799 --> 00:31:50,720
m place but now i have to pass a

00:31:48,960 --> 00:31:52,399
template argument you see this template

00:31:50,720 --> 00:31:54,960
argument down here

00:31:52,399 --> 00:31:55,440
that says which alternative do i want to

00:31:54,960 --> 00:31:58,720
emplace

00:31:55,440 --> 00:31:59,919
the int or the string and again those

00:31:58,720 --> 00:32:00,640
arguments are going to be perfectly

00:31:59,919 --> 00:32:03,120
forwarded

00:32:00,640 --> 00:32:03,919
to the initialization of the string

00:32:03,120 --> 00:32:05,600
member

00:32:03,919 --> 00:32:08,399
uh and no matter what was there before

00:32:05,600 --> 00:32:10,240
whether it was an int or a string

00:32:08,399 --> 00:32:12,320
it will be destroyed it will be

00:32:10,240 --> 00:32:15,360
destroyed first and then we'll in place

00:32:12,320 --> 00:32:16,720
over it

00:32:15,360 --> 00:32:18,720
to construct a very interruptional with

00:32:16,720 --> 00:32:19,600
an object already in place you have two

00:32:18,720 --> 00:32:21,919
options

00:32:19,600 --> 00:32:23,120
um so the easy option the basic option

00:32:21,919 --> 00:32:24,159
the one that's appropriate for the back

00:32:23,120 --> 00:32:27,360
the basics track

00:32:24,159 --> 00:32:29,840
is just use the equal sign right

00:32:27,360 --> 00:32:31,440
simple um or direct initialization if

00:32:29,840 --> 00:32:32,159
you like the curly brackets i don't i

00:32:31,440 --> 00:32:35,840
like the

00:32:32,159 --> 00:32:37,200
equal sign um so they're all implicitly

00:32:35,840 --> 00:32:38,159
convertible from their alternative type

00:32:37,200 --> 00:32:39,600
so i can say

00:32:38,159 --> 00:32:41,279
i have an optional string initialized

00:32:39,600 --> 00:32:42,399
with foo that does the obvious thing i

00:32:41,279 --> 00:32:43,519
have a variant of intent string

00:32:42,399 --> 00:32:44,640
initialized with foo

00:32:43,519 --> 00:32:47,600
that does the obvious thing it

00:32:44,640 --> 00:32:50,880
initializes the string member with foo

00:32:47,600 --> 00:32:52,159
um by the way that this line i know is

00:32:50,880 --> 00:32:54,320
very close to

00:32:52,159 --> 00:32:55,840
an example that did the wrong thing in c

00:32:54,320 --> 00:32:58,080
plus plus

00:32:55,840 --> 00:33:00,399
uh and is related to why the constructor

00:32:58,080 --> 00:33:02,000
overload set changed a teeny little bit

00:33:00,399 --> 00:33:03,840
in c plus plus 20. they had to do a

00:33:02,000 --> 00:33:05,120
little bug fix i think the uh

00:33:03,840 --> 00:33:07,600
the problem there was if this was a

00:33:05,120 --> 00:33:09,200
variant of bool and string

00:33:07,600 --> 00:33:11,120
uh this chart pointer would rather

00:33:09,200 --> 00:33:11,919
convert to a bool than a stid string

00:33:11,120 --> 00:33:16,000
they fixed that

00:33:11,919 --> 00:33:18,240
that's not a problem anymore um

00:33:16,000 --> 00:33:19,279
so generally speaking the implicit

00:33:18,240 --> 00:33:20,880
conversion here

00:33:19,279 --> 00:33:22,799
from the alternative type will work

00:33:20,880 --> 00:33:24,559
absolutely fine the only place it

00:33:22,799 --> 00:33:24,960
wouldn't work is if the stored type is

00:33:24,559 --> 00:33:27,840
not

00:33:24,960 --> 00:33:28,960
movable if i have some complicated type

00:33:27,840 --> 00:33:31,360
that does not have

00:33:28,960 --> 00:33:32,240
a copy constructor or a move constructor

00:33:31,360 --> 00:33:36,000
then i can't

00:33:32,240 --> 00:33:39,279
get it from the right-hand side

00:33:36,000 --> 00:33:41,039
of the equal sign over into the the spot

00:33:39,279 --> 00:33:44,080
in the variant that needs to go

00:33:41,039 --> 00:33:44,320
in that case uh we do have what's called

00:33:44,080 --> 00:33:47,120
an

00:33:44,320 --> 00:33:48,000
in-place constructor for both optional

00:33:47,120 --> 00:33:51,120
and variant

00:33:48,000 --> 00:33:52,640
when i construct an optional uh i can

00:33:51,120 --> 00:33:56,000
construct it

00:33:52,640 --> 00:33:58,480
uh passing the constructor the special

00:33:56,000 --> 00:34:00,399
tag stood in place this is just a global

00:33:58,480 --> 00:34:03,679
variable of some

00:34:00,399 --> 00:34:06,399
empty struct tag type um

00:34:03,679 --> 00:34:07,760
what else works this way um sort of like

00:34:06,399 --> 00:34:08,639
true type and false type if you're

00:34:07,760 --> 00:34:10,240
familiar with them

00:34:08,639 --> 00:34:13,119
it's the same kind of idea it's a tag

00:34:10,240 --> 00:34:14,879
type where it's only purpose is to be a

00:34:13,119 --> 00:34:16,320
unique type that we can recognize ah

00:34:14,879 --> 00:34:17,200
they passed me stood in place and what

00:34:16,320 --> 00:34:18,879
that means

00:34:17,200 --> 00:34:20,879
is that i should take all of the other

00:34:18,879 --> 00:34:22,079
arguments here and perfectly forward

00:34:20,879 --> 00:34:24,560
them onto the constructor

00:34:22,079 --> 00:34:26,800
and construct that string in place the

00:34:24,560 --> 00:34:28,639
string never exists anywhere except

00:34:26,800 --> 00:34:30,639
in the buffer of this specific optional

00:34:28,639 --> 00:34:34,159
o2

00:34:30,639 --> 00:34:36,960
similarly with v2 here i'm using uh

00:34:34,159 --> 00:34:38,079
the special tag in place type of stid

00:34:36,960 --> 00:34:39,520
string

00:34:38,079 --> 00:34:42,000
and these arguments get perfectly

00:34:39,520 --> 00:34:44,639
forwarded onto the constructor of string

00:34:42,000 --> 00:34:45,599
here again in place index of one so i

00:34:44,639 --> 00:34:48,560
can

00:34:45,599 --> 00:34:49,200
construct i can in place either using

00:34:48,560 --> 00:34:52,560
the

00:34:49,200 --> 00:34:55,919
name of the type if it is unique or

00:34:52,560 --> 00:34:58,640
the index of the alternative

00:34:55,919 --> 00:35:00,839
so zero would refer to int one would

00:34:58,640 --> 00:35:04,079
refer to string

00:35:00,839 --> 00:35:07,200
um by the way this same

00:35:04,079 --> 00:35:08,720
uh set of vocabulary is also used by

00:35:07,200 --> 00:35:10,079
stid any i told you i would

00:35:08,720 --> 00:35:12,320
come back just did any when it was

00:35:10,079 --> 00:35:14,160
appropriate um so even though state any

00:35:12,320 --> 00:35:15,359
is not an algebraic type it shares this

00:35:14,160 --> 00:35:18,000
vocabulary

00:35:15,359 --> 00:35:19,760
i can in place construct an any using

00:35:18,000 --> 00:35:22,160
the in place type or in place in

00:35:19,760 --> 00:35:22,800
or sorry not in place index because any

00:35:22,160 --> 00:35:24,400
doesn't have

00:35:22,800 --> 00:35:26,079
indices right it doesn't have template

00:35:24,400 --> 00:35:29,280
parameters but i can say

00:35:26,079 --> 00:35:31,119
i want to in place construct a string or

00:35:29,280 --> 00:35:32,640
i want to destroy what was already there

00:35:31,119 --> 00:35:35,040
and in place a string

00:35:32,640 --> 00:35:35,040
instead

00:35:36,720 --> 00:35:42,480
so uh stood get stid get is vocabulary

00:35:40,640 --> 00:35:44,640
that means map an index to a value

00:35:42,480 --> 00:35:45,839
you can think of a pair tuple or array

00:35:44,640 --> 00:35:47,920
as a mapping from an

00:35:45,839 --> 00:35:49,680
index to a value where the index is in

00:35:47,920 --> 00:35:53,760
the range zero up to

00:35:49,680 --> 00:35:56,880
however many uh t's are in the

00:35:53,760 --> 00:35:58,560
template parameter list so you use did

00:35:56,880 --> 00:35:59,119
get of index to extract the index the

00:35:58,560 --> 00:36:01,200
value

00:35:59,119 --> 00:36:02,400
here i have a pair of an n to the bool

00:36:01,200 --> 00:36:06,160
the zeroth

00:36:02,400 --> 00:36:07,920
argument is e int

00:36:06,160 --> 00:36:10,079
after element type the first element

00:36:07,920 --> 00:36:12,320
type is bool so when i say state get of

00:36:10,079 --> 00:36:13,680
zero for p that's a synonym for get me

00:36:12,320 --> 00:36:15,280
the first thing which in pair

00:36:13,680 --> 00:36:17,200
specifically i can also refer to as p

00:36:15,280 --> 00:36:19,040
dot first uh

00:36:17,200 --> 00:36:21,599
here i'm using it as an l value i'm

00:36:19,040 --> 00:36:24,640
saying assign into p dot second

00:36:21,599 --> 00:36:26,400
uh the value false totally fine um

00:36:24,640 --> 00:36:28,240
it sort of forwards on the value

00:36:26,400 --> 00:36:30,640
category of the thing

00:36:28,240 --> 00:36:32,079
uh that you pass to it so this is

00:36:30,640 --> 00:36:32,960
perfectly fine to appear on the left

00:36:32,079 --> 00:36:35,200
hand side

00:36:32,960 --> 00:36:36,000
of an equal sign i can also use it for

00:36:35,200 --> 00:36:39,760
stit array

00:36:36,000 --> 00:36:43,040
i can also use it for stid tuple um

00:36:39,760 --> 00:36:46,079
stidget works for all of these

00:36:43,040 --> 00:36:48,160
variant also has a stid get so

00:36:46,079 --> 00:36:49,200
variant has a stidget but it's only a

00:36:48,160 --> 00:36:51,920
partial mapping

00:36:49,200 --> 00:36:52,400
right you try to get the zeroth element

00:36:51,920 --> 00:36:55,440
of

00:36:52,400 --> 00:36:57,359
this variant and it says okay no problem

00:36:55,440 --> 00:36:58,000
that is the active alternative i have a

00:36:57,359 --> 00:37:00,880
zeroth

00:36:58,000 --> 00:37:01,520
alternative to give you if i try to get

00:37:00,880 --> 00:37:04,480
at the

00:37:01,520 --> 00:37:06,320
string member though uh that will throw

00:37:04,480 --> 00:37:07,520
an exception of types did bad variant

00:37:06,320 --> 00:37:09,440
access

00:37:07,520 --> 00:37:11,520
uh and if i try to get it something that

00:37:09,440 --> 00:37:13,280
just flat out never exists you know i

00:37:11,520 --> 00:37:14,960
compile time i would get a compile time

00:37:13,280 --> 00:37:17,119
error that says that's just ill form you

00:37:14,960 --> 00:37:19,839
can't do that

00:37:17,119 --> 00:37:20,560
so again using stidget variant remains

00:37:19,839 --> 00:37:23,280
type safe

00:37:20,560 --> 00:37:25,280
it does not allow me access to

00:37:23,280 --> 00:37:28,079
alternatives that don't exist

00:37:25,280 --> 00:37:28,079
unlike union

00:37:28,480 --> 00:37:32,000
stidget can also map type to a value i

00:37:30,480 --> 00:37:35,359
can say get me the int member

00:37:32,000 --> 00:37:36,079
get me the string member that works out

00:37:35,359 --> 00:37:37,280
very easily

00:37:36,079 --> 00:37:38,720
the implementation is just that there

00:37:37,280 --> 00:37:39,680
are two overloads of stit get in the

00:37:38,720 --> 00:37:41,920
standard library

00:37:39,680 --> 00:37:43,040
there's one that takes a size t and

00:37:41,920 --> 00:37:43,839
there's a separate one that takes a

00:37:43,040 --> 00:37:46,800
class

00:37:43,839 --> 00:37:48,480
or a type name and uh you know it can

00:37:46,800 --> 00:37:51,359
tell whether you're passing a type name

00:37:48,480 --> 00:37:54,800
or a for a value

00:37:51,359 --> 00:37:56,079
so uh all of these things are easy to

00:37:54,800 --> 00:37:58,320
include and declare

00:37:56,079 --> 00:37:59,119
uh for the ones that look like sequences

00:37:58,320 --> 00:38:01,839
you just use

00:37:59,119 --> 00:38:03,200
uh brace initializer sequences for the

00:38:01,839 --> 00:38:04,320
ones that behave like values like

00:38:03,200 --> 00:38:06,079
optional i can just say i have an

00:38:04,320 --> 00:38:08,320
optional int initialized with nine

00:38:06,079 --> 00:38:09,440
no problem i can initialize it null opt

00:38:08,320 --> 00:38:11,760
no problem

00:38:09,440 --> 00:38:13,200
uh for a variant i can say here's a char

00:38:11,760 --> 00:38:13,760
put it in this variant which can hold

00:38:13,200 --> 00:38:17,119
chars

00:38:13,760 --> 00:38:20,480
no problem easy peasy uh they all

00:38:17,119 --> 00:38:22,720
also support ctad uh that is uh cons

00:38:20,480 --> 00:38:23,680
uh class template argument deduction uh

00:38:22,720 --> 00:38:25,119
which came in in c

00:38:23,680 --> 00:38:27,119
plus 17. we're not really going to talk

00:38:25,119 --> 00:38:29,520
about that back to basics i recommend

00:38:27,119 --> 00:38:32,079
you stay away from it

00:38:29,520 --> 00:38:33,119
um they all have recursive default

00:38:32,079 --> 00:38:35,680
construction

00:38:33,119 --> 00:38:37,040
um they uh construct their members so if

00:38:35,680 --> 00:38:38,240
i have a pair of string and int and i

00:38:37,040 --> 00:38:40,400
default construct it that default

00:38:38,240 --> 00:38:42,400
constructs the string and the int

00:38:40,400 --> 00:38:44,000
um and when i see default construct i

00:38:42,400 --> 00:38:44,960
really mean value initialized they come

00:38:44,000 --> 00:38:47,359
out with zero

00:38:44,960 --> 00:38:48,960
uh tuple we value initialize the end we

00:38:47,359 --> 00:38:50,880
value initialize the char

00:38:48,960 --> 00:38:52,880
with optional optional is special it

00:38:50,880 --> 00:38:55,839
does not give me an int with value zero

00:38:52,880 --> 00:38:57,040
instead it gives me disengaged um it

00:38:55,839 --> 00:38:59,440
gives me null opt

00:38:57,040 --> 00:39:00,480
and with a variant a default constructed

00:38:59,440 --> 00:39:02,400
variant

00:39:00,480 --> 00:39:04,160
uh value initializes its first

00:39:02,400 --> 00:39:07,359
alternative the end this will give me an

00:39:04,160 --> 00:39:07,359
int with value zero

00:39:08,480 --> 00:39:11,839
they also besides default construction

00:39:10,400 --> 00:39:13,359
they all inherit special member

00:39:11,839 --> 00:39:14,079
functions from their constituent types

00:39:13,359 --> 00:39:17,280
in the natural

00:39:14,079 --> 00:39:19,520
way so a tuple of

00:39:17,280 --> 00:39:21,359
abc is going to be copy constructable

00:39:19,520 --> 00:39:23,040
only if a and b and c are all copy

00:39:21,359 --> 00:39:24,400
constructable if any one of them isn't

00:39:23,040 --> 00:39:26,000
then it won't be copy constructable

00:39:24,400 --> 00:39:27,200
it'll be move constructable unless one

00:39:26,000 --> 00:39:29,359
of its alternatives is not move

00:39:27,200 --> 00:39:31,440
constructable

00:39:29,359 --> 00:39:32,720
same for assignment operators same for

00:39:31,440 --> 00:39:34,320
default construction

00:39:32,720 --> 00:39:36,640
except for the caveats we saw in the

00:39:34,320 --> 00:39:39,040
previous slide for a variant it only

00:39:36,640 --> 00:39:40,560
needs to have its a alternative its

00:39:39,040 --> 00:39:42,720
first alternative

00:39:40,560 --> 00:39:44,160
b default constructable and that will be

00:39:42,720 --> 00:39:46,240
good enough to make the variant default

00:39:44,160 --> 00:39:47,839
constructable

00:39:46,240 --> 00:39:49,200
but in general they inherit their

00:39:47,839 --> 00:39:52,480
special members in exactly the way you

00:39:49,200 --> 00:39:52,480
would think and it all works out

00:39:53,359 --> 00:39:57,839
they also all have natural comparison

00:39:55,440 --> 00:40:00,880
operators so with pair and tuple

00:39:57,839 --> 00:40:01,119
these are ordered sequences right it's a

00:40:00,880 --> 00:40:04,240
an

00:40:01,119 --> 00:40:05,359
int and then a char or whatever um

00:40:04,240 --> 00:40:07,040
and so we can compare them

00:40:05,359 --> 00:40:07,599
lexicographically compare their first

00:40:07,040 --> 00:40:09,440
element

00:40:07,599 --> 00:40:10,640
if that if one is greater than or less

00:40:09,440 --> 00:40:12,079
than the other we're done

00:40:10,640 --> 00:40:13,359
if they happen to have the same first

00:40:12,079 --> 00:40:14,240
element we go on and compare their

00:40:13,359 --> 00:40:15,760
second element

00:40:14,240 --> 00:40:17,520
and we keep going until we run out of

00:40:15,760 --> 00:40:19,200
elements um

00:40:17,520 --> 00:40:20,640
so that's called lexicographical

00:40:19,200 --> 00:40:24,079
comparison

00:40:20,640 --> 00:40:26,079
um optional is inherits comparison

00:40:24,079 --> 00:40:27,200
from t it works just like comparing two

00:40:26,079 --> 00:40:29,440
t values

00:40:27,200 --> 00:40:30,480
um null of compares less than anything

00:40:29,440 --> 00:40:34,240
else

00:40:30,480 --> 00:40:36,720
um variant uh

00:40:34,240 --> 00:40:38,880
compares flexographically if you sort of

00:40:36,720 --> 00:40:41,599
look at it sideways you can think of it

00:40:38,880 --> 00:40:43,359
as either an ordered sequence of two

00:40:41,599 --> 00:40:46,640
values first you compare which

00:40:43,359 --> 00:40:49,839
alternative is active right if if my

00:40:46,640 --> 00:40:51,599
variant if the left-hand variant is uh

00:40:49,839 --> 00:40:53,520
alternative one and the other one is

00:40:51,599 --> 00:40:54,960
alternative three well one is less than

00:40:53,520 --> 00:40:55,920
three so this variant is less than that

00:40:54,960 --> 00:40:58,000
variant

00:40:55,920 --> 00:41:01,040
um if they have the same active index

00:40:58,000 --> 00:41:03,119
then you go and you look at the values

00:41:01,040 --> 00:41:04,720
so uh so all of these things the reason

00:41:03,119 --> 00:41:06,160
that they have comparison operators is

00:41:04,720 --> 00:41:09,839
so that we can use them

00:41:06,160 --> 00:41:10,880
as keys in sets and maps uh so that we

00:41:09,839 --> 00:41:12,640
can sort them

00:41:10,880 --> 00:41:14,160
you know in preparation for uniquing

00:41:12,640 --> 00:41:16,480
them or something like that right

00:41:14,160 --> 00:41:17,760
they play very well with the stl

00:41:16,480 --> 00:41:19,440
algorithms

00:41:17,760 --> 00:41:20,960
and containers and if you want to learn

00:41:19,440 --> 00:41:23,359
more about sdl algorithms and containers

00:41:20,960 --> 00:41:26,720
have i got a class for you

00:41:23,359 --> 00:41:27,200
um so now we're finally up to the first

00:41:26,720 --> 00:41:29,520
question

00:41:27,200 --> 00:41:32,079
slide with like 15 minutes left in the

00:41:29,520 --> 00:41:32,079
talk wow

00:41:32,839 --> 00:41:36,960
um

00:41:34,640 --> 00:41:38,160
i think we've actually answered one of

00:41:36,960 --> 00:41:39,520
these questions the

00:41:38,160 --> 00:41:41,359
the guaranteed way to construct an

00:41:39,520 --> 00:41:44,880
object in place in the optional

00:41:41,359 --> 00:41:47,200
um are there any gotchas for trying to

00:41:44,880 --> 00:41:49,359
use variant as a substitute for expected

00:41:47,200 --> 00:41:50,240
um not specifically but it's not very

00:41:49,359 --> 00:41:53,920
ergonomic

00:41:50,240 --> 00:41:55,520
i actually had a bonus slide on that um

00:41:53,920 --> 00:41:57,040
i think i'm going to go on because we

00:41:55,520 --> 00:41:58,400
have 17 minutes left in the talk

00:41:57,040 --> 00:42:01,119
according to my timer

00:41:58,400 --> 00:42:03,440
so let's talk a little bit more about

00:42:01,119 --> 00:42:06,000
optional

00:42:03,440 --> 00:42:07,040
so recall that an optional t is a type

00:42:06,000 --> 00:42:09,040
that we use when we mean

00:42:07,040 --> 00:42:10,079
either we have a value of type t or we

00:42:09,040 --> 00:42:11,920
have nothing

00:42:10,079 --> 00:42:13,920
so you'll see this used a lot in

00:42:11,920 --> 00:42:14,319
business logic this is the most useful

00:42:13,920 --> 00:42:17,440
type

00:42:14,319 --> 00:42:18,319
for most purposes of all the types we're

00:42:17,440 --> 00:42:20,960
talking about

00:42:18,319 --> 00:42:22,560
it gives us distinct states for the user

00:42:20,960 --> 00:42:23,839
didn't give me a password and

00:42:22,560 --> 00:42:26,079
they gave me a password which is the

00:42:23,839 --> 00:42:29,920
empty string

00:42:26,079 --> 00:42:32,000
or for a non-default constructable type

00:42:29,920 --> 00:42:33,280
when i say a certificate maybe doesn't

00:42:32,000 --> 00:42:35,359
have a default

00:42:33,280 --> 00:42:37,440
constructor but if i stick it in an

00:42:35,359 --> 00:42:39,119
optional now the optional is default

00:42:37,440 --> 00:42:41,680
constructable it constructs to the

00:42:39,119 --> 00:42:43,040
disengaged state and when i have a

00:42:41,680 --> 00:42:45,359
certificate to put in it

00:42:43,040 --> 00:42:46,240
that's when i embrace the certificate

00:42:45,359 --> 00:42:48,640
right so it

00:42:46,240 --> 00:42:50,640
so it gets around the fact that this

00:42:48,640 --> 00:42:52,560
type is not default constructable

00:42:50,640 --> 00:42:53,760
it gives us a state for for i don't have

00:42:52,560 --> 00:42:56,000
one

00:42:53,760 --> 00:42:57,280
um someone asks are two disengaged

00:42:56,000 --> 00:42:59,520
optionals equal

00:42:57,280 --> 00:43:01,359
yes they are not locked equals null opt

00:42:59,520 --> 00:43:03,040
um

00:43:01,359 --> 00:43:04,400
and what's the difference between make

00:43:03,040 --> 00:43:06,000
optional and

00:43:04,400 --> 00:43:09,119
the previously shown instead in place

00:43:06,000 --> 00:43:10,839
constructor um

00:43:09,119 --> 00:43:12,400
personally i would stay away from make

00:43:10,839 --> 00:43:16,400
optional

00:43:12,400 --> 00:43:19,440
i am not sure that it has a benefit

00:43:16,400 --> 00:43:22,400
um but i think the short answer is there

00:43:19,440 --> 00:43:22,400
may not be a difference

00:43:24,839 --> 00:43:29,920
um

00:43:27,760 --> 00:43:31,680
i suppose if i had a vector of optionals

00:43:29,920 --> 00:43:34,240
i could and place back

00:43:31,680 --> 00:43:35,680
into that vector of optionals using the

00:43:34,240 --> 00:43:37,920
in-place constructor

00:43:35,680 --> 00:43:39,520
um by passing it in place as the first

00:43:37,920 --> 00:43:42,319
argument to one place back

00:43:39,520 --> 00:43:42,880
um i could not in place in in place

00:43:42,319 --> 00:43:44,240
using

00:43:42,880 --> 00:43:46,000
make optional because that would then

00:43:44,240 --> 00:43:47,839
have to move construct an optional

00:43:46,000 --> 00:43:49,920
from the return value of make optional

00:43:47,839 --> 00:43:51,200
into the vector come see me at a table

00:43:49,920 --> 00:43:55,119
afterward i can

00:43:51,200 --> 00:43:58,319
explain that better so using optional

00:43:55,119 --> 00:44:00,480
uh when we have this uh

00:43:58,319 --> 00:44:02,640
optional certificate and now i have my

00:44:00,480 --> 00:44:04,160
getter that says i want to get a

00:44:02,640 --> 00:44:06,319
certificate and uh

00:44:04,160 --> 00:44:07,200
if we have a certificate here if cert.

00:44:06,319 --> 00:44:09,920
has value

00:44:07,200 --> 00:44:11,119
then return the value of that optional

00:44:09,920 --> 00:44:12,880
otherwise

00:44:11,119 --> 00:44:15,440
uh get some default search and return

00:44:12,880 --> 00:44:18,560
that right

00:44:15,440 --> 00:44:19,680
so dot value again if the optional is

00:44:18,560 --> 00:44:21,440
disengaged

00:44:19,680 --> 00:44:23,440
this is type safe it will not give me

00:44:21,440 --> 00:44:24,720
garbage it will throw an exception

00:44:23,440 --> 00:44:26,240
technically this means we have a

00:44:24,720 --> 00:44:26,880
redundant check here we're checking in

00:44:26,240 --> 00:44:29,040
the if

00:44:26,880 --> 00:44:30,800
and then inside.value the standard

00:44:29,040 --> 00:44:32,720
library is checking again for us to see

00:44:30,800 --> 00:44:35,520
if it needs to throw an exception or not

00:44:32,720 --> 00:44:38,079
um so technically this is redundant but

00:44:35,520 --> 00:44:40,000
in practice i wouldn't worry about it

00:44:38,079 --> 00:44:42,240
this this will all be in line the

00:44:40,000 --> 00:44:42,880
compiler will eliminate the the second

00:44:42,240 --> 00:44:44,720
check

00:44:42,880 --> 00:44:46,640
but if you really wanted to get around

00:44:44,720 --> 00:44:47,520
that you could use the unchecked

00:44:46,640 --> 00:44:49,520
interface

00:44:47,520 --> 00:44:51,119
um this looks very much like using

00:44:49,520 --> 00:44:54,400
pointers um

00:44:51,119 --> 00:44:55,839
you say uh if sir this is just this uses

00:44:54,400 --> 00:44:57,599
the conversion to boolean it's the same

00:44:55,839 --> 00:45:00,640
thing as dot has value

00:44:57,599 --> 00:45:02,319
but here where i say star cert uh

00:45:00,640 --> 00:45:04,319
that's using the overloaded operator

00:45:02,319 --> 00:45:07,680
star of

00:45:04,319 --> 00:45:08,960
the optional type its operator star is

00:45:07,680 --> 00:45:12,240
like that value

00:45:08,960 --> 00:45:13,920
but if it is disengaged then you get

00:45:12,240 --> 00:45:16,319
undefined behavior

00:45:13,920 --> 00:45:17,440
just like dereferencing a null pointer

00:45:16,319 --> 00:45:20,880
or

00:45:17,440 --> 00:45:24,240
using square brackets on a vector

00:45:20,880 --> 00:45:27,359
with an out of range uh index so

00:45:24,240 --> 00:45:29,440
the terse punctuation heavy version

00:45:27,359 --> 00:45:30,880
tends to have undefined behavior

00:45:29,440 --> 00:45:33,119
eliminates the checks

00:45:30,880 --> 00:45:34,880
if you want the checks you use the named

00:45:33,119 --> 00:45:36,880
accessor functions

00:45:34,880 --> 00:45:39,359
this is consistent with the rest of the

00:45:36,880 --> 00:45:39,359
stl

00:45:39,760 --> 00:45:44,160
uh even simpler i could say something

00:45:42,400 --> 00:45:46,319
like this i could say

00:45:44,160 --> 00:45:47,920
get me the value of the cert or if it

00:45:46,319 --> 00:45:51,200
doesn't have a value

00:45:47,920 --> 00:45:52,480
then use get default certificate instead

00:45:51,200 --> 00:45:55,119
so this is a library provided

00:45:52,480 --> 00:45:56,319
convenience method uh value underscore

00:45:55,119 --> 00:45:57,920
or

00:45:56,319 --> 00:45:59,599
but watch out for side effects if get

00:45:57,920 --> 00:46:02,319
default certificate is slow

00:45:59,599 --> 00:46:03,359
or has some uh effect on the state of

00:46:02,319 --> 00:46:07,520
the program

00:46:03,359 --> 00:46:09,839
here i am on

00:46:07,520 --> 00:46:10,640
it in order to get argument to pass to

00:46:09,839 --> 00:46:12,640
value or

00:46:10,640 --> 00:46:14,800
i always call get default certificate so

00:46:12,640 --> 00:46:16,240
this is different behavior from what we

00:46:14,800 --> 00:46:18,160
saw on the previous

00:46:16,240 --> 00:46:19,359
slide where i would only call get

00:46:18,160 --> 00:46:22,480
default certificate

00:46:19,359 --> 00:46:24,160
uh if the cert didn't have a value so if

00:46:22,480 --> 00:46:25,040
that matters watch out for it but if

00:46:24,160 --> 00:46:26,400
that doesn't matter

00:46:25,040 --> 00:46:28,160
value war is going to be a big time

00:46:26,400 --> 00:46:31,680
saver or

00:46:28,160 --> 00:46:33,280
line of code saver um

00:46:31,680 --> 00:46:35,440
so suppose i have one of these optional

00:46:33,280 --> 00:46:38,640
fields how should i write the setter

00:46:35,440 --> 00:46:40,480
for this optional field so here i have

00:46:38,640 --> 00:46:41,440
my optional cert and i have a setcert

00:46:40,480 --> 00:46:43,680
function

00:46:41,440 --> 00:46:46,400
um i recommend that when you write a

00:46:43,680 --> 00:46:47,839
setter for an optional field you write

00:46:46,400 --> 00:46:49,680
you know i just take an optional by

00:46:47,839 --> 00:46:52,640
value and then i still move it

00:46:49,680 --> 00:46:54,560
into my member using move assignment um

00:46:52,640 --> 00:46:56,240
that's usually what you want

00:46:54,560 --> 00:46:57,599
you might save a move by adding an

00:46:56,240 --> 00:47:01,839
overload that takes

00:46:57,599 --> 00:47:03,839
like a an r value to the

00:47:01,839 --> 00:47:05,040
element type uh that might save you a

00:47:03,839 --> 00:47:07,760
move in this case

00:47:05,040 --> 00:47:09,839
um don't take when in this specific

00:47:07,760 --> 00:47:11,119
example don't take optionals by

00:47:09,839 --> 00:47:14,000
construct

00:47:11,119 --> 00:47:16,240
um saying oh i don't need my own

00:47:14,000 --> 00:47:16,960
optional i just need a reference to your

00:47:16,240 --> 00:47:18,400
optional

00:47:16,960 --> 00:47:20,559
my caller is optional because your

00:47:18,400 --> 00:47:21,599
caller probably doesn't have an optional

00:47:20,559 --> 00:47:23,359
right they're probably giving you a

00:47:21,599 --> 00:47:24,000
certificate or giving you a null opt

00:47:23,359 --> 00:47:26,240
they they

00:47:24,000 --> 00:47:28,079
won't make an optional uh unless they

00:47:26,240 --> 00:47:28,960
need to so as long as an optional is

00:47:28,079 --> 00:47:31,280
getting made

00:47:28,960 --> 00:47:32,800
uh it probably makes sense to to give

00:47:31,280 --> 00:47:34,960
you ownership of it

00:47:32,800 --> 00:47:36,400
and let you move out of it that's why i

00:47:34,960 --> 00:47:38,079
say for setters

00:47:36,400 --> 00:47:40,079
this first option is probably what i

00:47:38,079 --> 00:47:41,359
want

00:47:40,079 --> 00:47:45,119
don't force your caller to create a

00:47:41,359 --> 00:47:46,160
temporary that you can't modify

00:47:45,119 --> 00:47:48,800
if they're going to create a temporary

00:47:46,160 --> 00:47:50,400
anyway let me modify it

00:47:48,800 --> 00:47:52,480
all right you can also use optional for

00:47:50,400 --> 00:47:54,079
optional parameters um

00:47:52,480 --> 00:47:55,920
so you can write a signature something

00:47:54,079 --> 00:47:57,040
like this i can say uh open connection

00:47:55,920 --> 00:48:00,559
to this host

00:47:57,040 --> 00:48:03,440
um and maybe it's going to use a secure

00:48:00,559 --> 00:48:04,240
you know certificate maybe it's not so

00:48:03,440 --> 00:48:06,720
this

00:48:04,240 --> 00:48:07,760
function with the default uh function

00:48:06,720 --> 00:48:10,079
argument

00:48:07,760 --> 00:48:11,599
allows me to say open a connection to

00:48:10,079 --> 00:48:12,319
example.com using the specific

00:48:11,599 --> 00:48:15,040
certificate

00:48:12,319 --> 00:48:16,480
or using no certificate or i could pass

00:48:15,040 --> 00:48:18,319
null opt explicitly

00:48:16,480 --> 00:48:20,000
and that also works because null opt is

00:48:18,319 --> 00:48:22,559
convertible to stid optional

00:48:20,000 --> 00:48:23,839
of any type so this might be exactly

00:48:22,559 --> 00:48:26,240
what you're looking for

00:48:23,839 --> 00:48:28,480
personally i never use default arguments

00:48:26,240 --> 00:48:31,599
i say don't use them

00:48:28,480 --> 00:48:32,800
and so i would expect one of two things

00:48:31,599 --> 00:48:34,400
to be true about

00:48:32,800 --> 00:48:36,079
any any place where you wanted an

00:48:34,400 --> 00:48:38,400
optional parameter like this

00:48:36,079 --> 00:48:41,040
either we're using optional cert as the

00:48:38,400 --> 00:48:42,000
vocabulary type across my entire product

00:48:41,040 --> 00:48:44,079
to mean

00:48:42,000 --> 00:48:45,040
maybe a certificate maybe not in which

00:48:44,079 --> 00:48:46,559
case

00:48:45,040 --> 00:48:47,760
uh the caller already has a maybe

00:48:46,559 --> 00:48:48,480
certificate maybe not they got from

00:48:47,760 --> 00:48:50,160
someone else

00:48:48,480 --> 00:48:51,440
and they are just forwarding along to me

00:48:50,160 --> 00:48:52,240
and i forward it along to someone else

00:48:51,440 --> 00:48:54,400
and everyone

00:48:52,240 --> 00:48:55,760
in the code base understands that this

00:48:54,400 --> 00:48:57,280
is the type we're using

00:48:55,760 --> 00:48:59,200
whenever we have a maybe certificate

00:48:57,280 --> 00:49:01,359
maybe not in that case

00:48:59,200 --> 00:49:03,119
that would be a great place to use a

00:49:01,359 --> 00:49:03,920
const reference to say i bet you have an

00:49:03,119 --> 00:49:07,359
optional

00:49:03,920 --> 00:49:09,359
just give me a reference to that um

00:49:07,359 --> 00:49:10,720
or else i have two very different

00:49:09,359 --> 00:49:12,400
functionalities here i have create a

00:49:10,720 --> 00:49:13,200
secure connection and create an insecure

00:49:12,400 --> 00:49:15,839
connection

00:49:13,200 --> 00:49:17,520
and i never want to be able to mix those

00:49:15,839 --> 00:49:18,559
up by accidentally forgetting an

00:49:17,520 --> 00:49:20,079
argument

00:49:18,559 --> 00:49:21,200
and i want to give those different names

00:49:20,079 --> 00:49:22,160
and have them not be in the same

00:49:21,200 --> 00:49:23,680
overload set

00:49:22,160 --> 00:49:24,880
and for that i would write two different

00:49:23,680 --> 00:49:26,400
signatures and i'd give them two

00:49:24,880 --> 00:49:28,079
different names as shown at the bottom

00:49:26,400 --> 00:49:30,319
of this slide

00:49:28,079 --> 00:49:31,920
so if you're using optionals for

00:49:30,319 --> 00:49:36,079
parameters

00:49:31,920 --> 00:49:36,079
my feeling is reconsider

00:49:36,880 --> 00:49:40,160
and with that we're up to questions on

00:49:38,400 --> 00:49:41,680
optional um since i know there's a

00:49:40,160 --> 00:49:44,079
little bit of the delay

00:49:41,680 --> 00:49:45,280
i am going to move on but feel free to

00:49:44,079 --> 00:49:48,640
drop your questions in the q

00:49:45,280 --> 00:49:50,240
a tab let's talk about variant

00:49:48,640 --> 00:49:51,839
detect the active alternative of a

00:49:50,240 --> 00:49:53,520
variant we've already said

00:49:51,839 --> 00:49:55,680
there's an index method that gives you

00:49:53,520 --> 00:49:58,079
the active index as a size t

00:49:55,680 --> 00:49:58,800
there is also a free functions did holds

00:49:58,079 --> 00:50:00,720
alternative

00:49:58,800 --> 00:50:02,240
i've never seen a use for this it's very

00:50:00,720 --> 00:50:04,640
verbose um

00:50:02,240 --> 00:50:05,680
there's a there's a better way to do it

00:50:04,640 --> 00:50:10,160
which is did get

00:50:05,680 --> 00:50:13,200
if so get if uh returns a pointer to the

00:50:10,160 --> 00:50:15,040
specified alternative if it is active

00:50:13,200 --> 00:50:17,200
if the alternative you have named is not

00:50:15,040 --> 00:50:19,680
active it returns null pointer

00:50:17,200 --> 00:50:21,599
um so here we have uh trying to visit a

00:50:19,680 --> 00:50:23,839
variant of three things using

00:50:21,599 --> 00:50:26,000
index right if if it contains an n to do

00:50:23,839 --> 00:50:28,880
this it contains a double do this

00:50:26,000 --> 00:50:30,000
um this code works it's ugly and error

00:50:28,880 --> 00:50:32,720
prone i have to type out

00:50:30,000 --> 00:50:35,359
it's a lot of repetition here so a

00:50:32,720 --> 00:50:38,000
better idea is to use get if here

00:50:35,359 --> 00:50:39,839
compare getif to anycast remember this

00:50:38,000 --> 00:50:41,839
is another similarity with stid any if

00:50:39,839 --> 00:50:45,200
you watch my studenti talk i talk about

00:50:41,839 --> 00:50:47,599
anycast as the go fish operation it says

00:50:45,200 --> 00:50:49,200
are you holding an int and if it is it

00:50:47,599 --> 00:50:49,839
has to give you all its ins and if it's

00:50:49,200 --> 00:50:53,040
not

00:50:49,839 --> 00:50:54,640
it says go fish and you get an exception

00:50:53,040 --> 00:50:56,000
the same thing happens with get if

00:50:54,640 --> 00:50:57,280
except instead of getting an exception

00:50:56,000 --> 00:50:59,680
you get a

00:50:57,280 --> 00:51:01,599
a null pointer which you can then test

00:50:59,680 --> 00:51:02,640
because a null pointer is falsy and any

00:51:01,599 --> 00:51:06,079
other pointer is

00:51:02,640 --> 00:51:09,680
truthy so i say

00:51:06,079 --> 00:51:11,200
get if of int of this variant

00:51:09,680 --> 00:51:13,200
notice i have to pass the variant by

00:51:11,200 --> 00:51:16,079
address by pointer here

00:51:13,200 --> 00:51:16,880
um that will give me back an instar if

00:51:16,079 --> 00:51:20,160
that n star

00:51:16,880 --> 00:51:21,520
is non-null then it points to the end

00:51:20,160 --> 00:51:24,319
inside this variant

00:51:21,520 --> 00:51:25,760
and i print it out if it's null i go on

00:51:24,319 --> 00:51:26,880
to my else and i say do you have a

00:51:25,760 --> 00:51:28,800
double for me

00:51:26,880 --> 00:51:30,000
and if that's null i skip here and

00:51:28,800 --> 00:51:30,880
otherwise i print it out and if it's

00:51:30,000 --> 00:51:33,280
null i say

00:51:30,880 --> 00:51:34,960
do you have a string for me uh this

00:51:33,280 --> 00:51:37,520
should always be true given that

00:51:34,960 --> 00:51:38,640
i don't know the other ones were true

00:51:37,520 --> 00:51:42,160
hand wave

00:51:38,640 --> 00:51:44,720
um so there we go we can do this

00:51:42,160 --> 00:51:45,280
however we can do even better because

00:51:44,720 --> 00:51:48,400
notice

00:51:45,280 --> 00:51:50,960
that all three of my

00:51:48,400 --> 00:51:51,760
bodies here are now basically the same

00:51:50,960 --> 00:51:52,960
thing

00:51:51,760 --> 00:51:55,119
right there's no difference in the

00:51:52,960 --> 00:51:56,559
spelling and so i can wrap that up into

00:51:55,119 --> 00:51:59,520
a generic lambda

00:51:56,559 --> 00:52:00,160
that does that same shape of c outing

00:51:59,520 --> 00:52:02,960
the thing

00:52:00,160 --> 00:52:04,559
whatever the thing is right so i

00:52:02,960 --> 00:52:05,280
parametrize this i stick it in a generic

00:52:04,559 --> 00:52:07,920
lambda

00:52:05,280 --> 00:52:09,599
and then i can use this helper function

00:52:07,920 --> 00:52:11,520
stid visit

00:52:09,599 --> 00:52:13,040
this is provided by the standard library

00:52:11,520 --> 00:52:14,720
it is a free function

00:52:13,040 --> 00:52:16,640
uh and what you do is you give it

00:52:14,720 --> 00:52:18,000
something that is callable with a ver or

00:52:16,640 --> 00:52:20,800
something that's callable with

00:52:18,000 --> 00:52:21,599
a anything like a generic lambda for

00:52:20,800 --> 00:52:24,480
example

00:52:21,599 --> 00:52:26,000
and then you give it a variant and

00:52:24,480 --> 00:52:27,680
internally it will do exactly the same

00:52:26,000 --> 00:52:29,440
thing as on the previous slide

00:52:27,680 --> 00:52:30,800
modulo it might do some optimizations

00:52:29,440 --> 00:52:32,160
because it's the library and it can do

00:52:30,800 --> 00:52:34,079
that

00:52:32,160 --> 00:52:36,319
so it will check the index and then it

00:52:34,079 --> 00:52:39,760
will branch to an instantiation

00:52:36,319 --> 00:52:40,480
of printme for whatever happens to be in

00:52:39,760 --> 00:52:41,839
the variant

00:52:40,480 --> 00:52:43,599
if there's an int it will call print me

00:52:41,839 --> 00:52:45,040
event if there's a double it will call

00:52:43,599 --> 00:52:46,960
print view double and so on it can do

00:52:45,040 --> 00:52:47,920
this because it knows exactly what types

00:52:46,960 --> 00:52:49,440
are possible

00:52:47,920 --> 00:52:51,119
this is something that's not possible

00:52:49,440 --> 00:52:52,319
with stid any because it's type erased

00:52:51,119 --> 00:52:53,839
and that's why we're not talking about

00:52:52,319 --> 00:52:56,480
it

00:52:53,839 --> 00:52:57,680
notice with stid visit the lambda comes

00:52:56,480 --> 00:52:59,359
first

00:52:57,680 --> 00:53:00,960
standard library functions usually when

00:52:59,359 --> 00:53:01,680
they take a callable they take it as the

00:53:00,960 --> 00:53:04,480
last

00:53:01,680 --> 00:53:06,319
argument so that it you can sort of put

00:53:04,480 --> 00:53:09,119
it in there and sort of overflow

00:53:06,319 --> 00:53:11,119
onto the next line with visit it takes

00:53:09,119 --> 00:53:13,119
it first and this is weird

00:53:11,119 --> 00:53:14,640
but the reason it does it is that you

00:53:13,119 --> 00:53:17,119
can actually

00:53:14,640 --> 00:53:18,480
call stid visit with multiple variants

00:53:17,119 --> 00:53:20,160
and it will do the whole cartesian

00:53:18,480 --> 00:53:21,440
product of all of these variants

00:53:20,160 --> 00:53:22,720
you know if this if the first one holds

00:53:21,440 --> 00:53:23,440
an int and the second one holds an end

00:53:22,720 --> 00:53:24,960
to do this

00:53:23,440 --> 00:53:26,319
if it holds an int and a double do this

00:53:24,960 --> 00:53:28,800
if it holds a double and an end to do

00:53:26,319 --> 00:53:30,240
this um and you can do this with any

00:53:28,800 --> 00:53:31,599
number of variants so with a two

00:53:30,240 --> 00:53:33,440
parameter lambda print us

00:53:31,599 --> 00:53:34,960
you could call stid visit or print us

00:53:33,440 --> 00:53:36,800
comma v1 comma v2

00:53:34,960 --> 00:53:38,640
and you can extend that to a three

00:53:36,800 --> 00:53:42,640
argument lambda for argument lambda and

00:53:38,640 --> 00:53:45,119
so on

00:53:42,640 --> 00:53:46,240
now i did say uh and i said hand wave

00:53:45,119 --> 00:53:49,520
when i when i said

00:53:46,240 --> 00:53:52,559
that this lambda of uh n string

00:53:49,520 --> 00:53:54,319
and uh double could only hold one of

00:53:52,559 --> 00:53:56,800
those three things that's not true

00:53:54,319 --> 00:53:58,640
variants also have a state that you

00:53:56,800 --> 00:54:01,040
might refer to as disengaged where the

00:53:58,640 --> 00:54:02,960
variant does not hold any value at all

00:54:01,040 --> 00:54:04,720
uh and this is called the valueless by

00:54:02,960 --> 00:54:06,240
exception state

00:54:04,720 --> 00:54:08,319
the reason it's called valueless by

00:54:06,240 --> 00:54:09,760
exception is that pretty much the only

00:54:08,319 --> 00:54:12,000
way you can get into it

00:54:09,760 --> 00:54:13,119
is involving exception handling if

00:54:12,000 --> 00:54:14,720
you're not using exception handling

00:54:13,119 --> 00:54:16,240
don't worry about this

00:54:14,720 --> 00:54:18,079
and in fact in general don't worry about

00:54:16,240 --> 00:54:19,680
this this is certainly an exceptional

00:54:18,079 --> 00:54:21,520
situation but here's how you would get

00:54:19,680 --> 00:54:23,040
into it

00:54:21,520 --> 00:54:24,640
you would say i have a variant of two

00:54:23,040 --> 00:54:29,920
different types both of which

00:54:24,640 --> 00:54:33,760
involve dynamically allocated resources

00:54:29,920 --> 00:54:37,119
i put a unique putter into my variant

00:54:33,760 --> 00:54:39,040
and then i try to emplace

00:54:37,119 --> 00:54:42,000
a string into it right so this is using

00:54:39,040 --> 00:54:44,720
the one alternative which is stid string

00:54:42,000 --> 00:54:45,440
and i'm trying to make a copy of string

00:54:44,720 --> 00:54:47,920
x

00:54:45,440 --> 00:54:49,359
string x does not get the small string

00:54:47,920 --> 00:54:50,880
optimization it's too long

00:54:49,359 --> 00:54:52,720
so this needs to do a heap allocation

00:54:50,880 --> 00:54:55,839
that heap allocation might fail

00:54:52,720 --> 00:54:58,160
if it fails it throws bad alloc now

00:54:55,839 --> 00:55:00,480
it fails during the construction of the

00:54:58,160 --> 00:55:03,520
string into the variant

00:55:00,480 --> 00:55:05,280
by that point remember emplace means

00:55:03,520 --> 00:55:07,040
construct a new thing and before i can

00:55:05,280 --> 00:55:08,559
do that i need to kick out the old thing

00:55:07,040 --> 00:55:10,880
so the old thing has gotten kicked out

00:55:08,559 --> 00:55:12,640
and destroyed i have now freed that

00:55:10,880 --> 00:55:15,599
unique putter that unique putter is gone

00:55:12,640 --> 00:55:16,000
127 is no longer on the heap the variant

00:55:15,599 --> 00:55:18,000
is now

00:55:16,000 --> 00:55:19,520
empty now i'm trying to construct a

00:55:18,000 --> 00:55:22,480
string into it

00:55:19,520 --> 00:55:23,599
that fails now i don't have a string and

00:55:22,480 --> 00:55:24,880
i don't have a unique putter anymore

00:55:23,599 --> 00:55:25,680
because i destroyed it to make room for

00:55:24,880 --> 00:55:27,599
the string

00:55:25,680 --> 00:55:30,000
in this situation we say that v is

00:55:27,599 --> 00:55:31,440
valueless by exception

00:55:30,000 --> 00:55:34,160
this is the only situation where you can

00:55:31,440 --> 00:55:35,760
get into this uh in this situation there

00:55:34,160 --> 00:55:36,480
is an accessor that will tell you that

00:55:35,760 --> 00:55:38,720
this is the

00:55:36,480 --> 00:55:39,680
the case also if you call dot index it

00:55:38,720 --> 00:55:41,920
will give you back

00:55:39,680 --> 00:55:44,079
uh minus one size d of minus one like

00:55:41,920 --> 00:55:48,400
like the biggest possible size date

00:55:44,079 --> 00:55:50,319
um uh if the state ever happens

00:55:48,400 --> 00:55:51,920
uh you will get some sort of exception

00:55:50,319 --> 00:55:54,880
and you will be able to test for it here

00:55:51,920 --> 00:55:56,559
and uh please get the variant out of

00:55:54,880 --> 00:55:57,040
that state before exiting the catch

00:55:56,559 --> 00:55:58,480
block

00:55:57,040 --> 00:56:00,480
right or or know that you're going to

00:55:58,480 --> 00:56:02,799
destroy the the variant

00:56:00,480 --> 00:56:04,319
but you should try very hard uh if you

00:56:02,799 --> 00:56:06,960
care about the state at all which most

00:56:04,319 --> 00:56:06,960
people do not

00:56:07,680 --> 00:56:10,559
but even if you think you do care about

00:56:09,040 --> 00:56:11,920
it you should care about it only inside

00:56:10,559 --> 00:56:15,520
catch blocks

00:56:11,920 --> 00:56:16,960
so um by the way this is only a problem

00:56:15,520 --> 00:56:18,480
with in place because in place means

00:56:16,960 --> 00:56:19,200
kick out the old value before you put in

00:56:18,480 --> 00:56:22,559
the new one

00:56:19,200 --> 00:56:23,280
um if you are using a regular old

00:56:22,559 --> 00:56:25,440
assignment

00:56:23,280 --> 00:56:26,799
that will do the equivalent of copy and

00:56:25,440 --> 00:56:30,960
swap if it needs to to make sure you

00:56:26,799 --> 00:56:33,440
never end up in the state

00:56:30,960 --> 00:56:35,440
and without questions on variant which

00:56:33,440 --> 00:56:38,079
again i will steamroll over because

00:56:35,440 --> 00:56:41,839
we're now at like four minutes or so

00:56:38,079 --> 00:56:41,839
and let's talk about pair and tuple

00:56:42,079 --> 00:56:44,960
pairs and doubles represent sequences it

00:56:43,760 --> 00:56:47,040
makes sense to initialize them with

00:56:44,960 --> 00:56:48,799
braced initializer lists where possible

00:56:47,040 --> 00:56:50,799
there are also two helper functions

00:56:48,799 --> 00:56:52,559
provided by the stls did make tuple and

00:56:50,799 --> 00:56:54,799
stid make pair

00:56:52,559 --> 00:56:56,079
these are regular old functions uh you

00:56:54,799 --> 00:56:58,000
do not give them

00:56:56,079 --> 00:56:59,520
template arguments they will do template

00:56:58,000 --> 00:57:01,119
deduction and figure out that you're

00:56:59,520 --> 00:57:02,240
passing it let's say three inch you want

00:57:01,119 --> 00:57:04,319
the tuple events

00:57:02,240 --> 00:57:07,119
uh you're passing it an int and a bool

00:57:04,319 --> 00:57:10,880
you want a pair of ink and bool

00:57:07,119 --> 00:57:12,640
um now what's interesting here you can't

00:57:10,880 --> 00:57:14,400
make an optional of a reference type or

00:57:12,640 --> 00:57:16,400
a variant of a reference type but you

00:57:14,400 --> 00:57:17,599
can make a couple of reference types and

00:57:16,400 --> 00:57:19,200
if you do that

00:57:17,599 --> 00:57:21,280
so here i have a tuple of interac and

00:57:19,200 --> 00:57:22,160
interef that is initialized with

00:57:21,280 --> 00:57:24,960
reference to a

00:57:22,160 --> 00:57:25,520
and a reference to b if you do that the

00:57:24,960 --> 00:57:27,680
tuple

00:57:25,520 --> 00:57:29,599
assignment operator will have a sign

00:57:27,680 --> 00:57:32,480
through behavior

00:57:29,599 --> 00:57:33,040
so this assigns from c and d into a and

00:57:32,480 --> 00:57:35,520
b

00:57:33,040 --> 00:57:37,680
setting a to three and b to four that's

00:57:35,520 --> 00:57:39,200
kind of cool

00:57:37,680 --> 00:57:42,480
you can implicitly create a couple of

00:57:39,200 --> 00:57:45,599
references in at least three ways

00:57:42,480 --> 00:57:46,480
one way is to use make tuple but instead

00:57:45,599 --> 00:57:49,520
of passing it

00:57:46,480 --> 00:57:51,200
a and b you pass it reference wrappers

00:57:49,520 --> 00:57:54,640
to a and b make tuple

00:57:51,200 --> 00:57:56,720
will generally create a tuple of values

00:57:54,640 --> 00:57:58,079
but if you pass it reference wrappers it

00:57:56,720 --> 00:57:59,920
will not create a couple of reference

00:57:58,079 --> 00:58:00,799
wrappers it will actually decay them i

00:57:59,920 --> 00:58:03,280
call this process

00:58:00,799 --> 00:58:04,079
library decay uh several things behave

00:58:03,280 --> 00:58:06,400
this way stid

00:58:04,079 --> 00:58:08,160
threads constructor comes to mind uh if

00:58:06,400 --> 00:58:10,799
you pass it a reference wrapper

00:58:08,160 --> 00:58:12,559
uh it will decay it into an actual

00:58:10,799 --> 00:58:14,880
native language reference

00:58:12,559 --> 00:58:16,480
um there's also stid tie you give it

00:58:14,880 --> 00:58:18,319
some l values that creates you a couple

00:58:16,480 --> 00:58:20,720
of l value references

00:58:18,319 --> 00:58:22,559
uh also forward as tuple which we'll see

00:58:20,720 --> 00:58:25,280
in a minute um

00:58:22,559 --> 00:58:27,520
and in all three of these cases um the

00:58:25,280 --> 00:58:28,559
decal type of of this thing is going to

00:58:27,520 --> 00:58:31,040
be a couple of

00:58:28,559 --> 00:58:31,040
refs

00:58:31,680 --> 00:58:35,200
um so remember a discussion of in-place

00:58:33,440 --> 00:58:36,640
construction well for pair and tuple

00:58:35,200 --> 00:58:38,160
they have multiple elements so this

00:58:36,640 --> 00:58:41,040
doesn't work we have to give two

00:58:38,160 --> 00:58:43,200
or n constructor argument lists so we

00:58:41,040 --> 00:58:45,200
don't just say construct me in place

00:58:43,200 --> 00:58:46,960
with this stuff forwarded to the

00:58:45,200 --> 00:58:49,520
constructor we need to say

00:58:46,960 --> 00:58:50,160
construct me piecewise with these

00:58:49,520 --> 00:58:52,559
arguments

00:58:50,160 --> 00:58:54,160
forwarded on to the first constructor

00:58:52,559 --> 00:58:56,000
these arguments forwarded on to the

00:58:54,160 --> 00:58:57,680
second constructor

00:58:56,000 --> 00:58:59,599
and then if this were a tuple i could

00:58:57,680 --> 00:59:01,200
add even more these go to the third

00:58:59,599 --> 00:59:03,119
constructor and so on

00:59:01,200 --> 00:59:04,559
uh this is the reason that forward as

00:59:03,119 --> 00:59:07,599
tuple exists

00:59:04,559 --> 00:59:10,400
is for use with the piecewise construct

00:59:07,599 --> 00:59:11,839
tag uh when you were constructing pair

00:59:10,400 --> 00:59:14,400
and tuple

00:59:11,839 --> 00:59:14,400
very niche

00:59:14,880 --> 00:59:18,079
we're getting close to the end that

00:59:16,000 --> 00:59:20,000
we're going to go over a little bit

00:59:18,079 --> 00:59:22,319
i hope that's okay multiple assignment

00:59:20,000 --> 00:59:24,799
with tie we can use a sign through

00:59:22,319 --> 00:59:26,319
on tuples of references to simulate

00:59:24,799 --> 00:59:29,040
multiple assignment

00:59:26,319 --> 00:59:30,480
so here i have an iterator named it i

00:59:29,040 --> 00:59:34,240
have a bool named

00:59:30,480 --> 00:59:37,680
inserted and i can take the return value

00:59:34,240 --> 00:59:38,480
of set insert which remember returns us

00:59:37,680 --> 00:59:41,920
a pair

00:59:38,480 --> 00:59:43,839
of iterator comma bool and instead of

00:59:41,920 --> 00:59:46,559
capturing that whole pair

00:59:43,839 --> 00:59:48,799
i can actually use assignment to assign

00:59:46,559 --> 00:59:49,440
it into this tuple of references this is

00:59:48,799 --> 00:59:52,880
a tuple

00:59:49,440 --> 00:59:54,559
of iterator ref bool ref

00:59:52,880 --> 00:59:57,040
so i can assign it into this this will

00:59:54,559 --> 00:59:58,079
assign through changing the values of my

00:59:57,040 --> 01:00:00,960
variables it

00:59:58,079 --> 01:00:02,400
and inserted and updating them uh with

01:00:00,960 --> 01:00:03,359
the values of the pair on the right hand

01:00:02,400 --> 01:00:05,119
side

01:00:03,359 --> 01:00:07,680
so this allows us to simulate a multiple

01:00:05,119 --> 01:00:07,680
assignment

01:00:08,079 --> 01:00:12,319
um the stl provides a special tag type

01:00:10,559 --> 01:00:13,359
stit ignore we're doing a lot of tag

01:00:12,319 --> 01:00:17,280
types today

01:00:13,359 --> 01:00:20,240
right so there's this did ignore tag

01:00:17,280 --> 01:00:21,680
if you tie with stit ignore whatever

01:00:20,240 --> 01:00:23,359
argument is in that position

01:00:21,680 --> 01:00:24,720
on the right hand side will not be

01:00:23,359 --> 01:00:26,319
assigned to anything it will just be

01:00:24,720 --> 01:00:29,200
dropped on the floor

01:00:26,319 --> 01:00:30,000
so here i am tying together a reference

01:00:29,200 --> 01:00:33,280
to x

01:00:30,000 --> 01:00:35,599
a reference to y and a reference to this

01:00:33,280 --> 01:00:36,160
global variable ignore which is of some

01:00:35,599 --> 01:00:39,359
magic

01:00:36,160 --> 01:00:40,480
type that when you assign to it uh it

01:00:39,359 --> 01:00:42,799
accepts whatever you give it and

01:00:40,480 --> 01:00:44,720
swallows it and it has no effect

01:00:42,799 --> 01:00:46,960
so here i have a function that gives me

01:00:44,720 --> 01:00:50,480
back a couple of three things

01:00:46,960 --> 01:00:52,640
and i capture two of them

01:00:50,480 --> 01:00:55,280
using this multiple assignment trick and

01:00:52,640 --> 01:00:58,480
the third one i just drop on the floor

01:00:55,280 --> 01:01:00,160
and that's totally fine um so that's

01:00:58,480 --> 01:01:00,960
neat and that is the only reason to use

01:01:00,160 --> 01:01:03,119
stit ignore

01:01:00,960 --> 01:01:07,280
as far as i know is in this particular

01:01:03,119 --> 01:01:07,280
idiom it was invented with this in mind

01:01:08,160 --> 01:01:10,640
a caveat though on this multiple

01:01:09,440 --> 01:01:12,160
assignment you might be thinking oh this

01:01:10,640 --> 01:01:13,760
is awesome i'm gonna go like rewrite my

01:01:12,160 --> 01:01:14,480
whole code base to use multiple assign

01:01:13,760 --> 01:01:17,520
please don't

01:01:14,480 --> 01:01:19,599
please please do not um

01:01:17,520 --> 01:01:21,599
so here's an example of a pitfall that

01:01:19,599 --> 01:01:24,880
you might see with multiple assignment

01:01:21,599 --> 01:01:26,400
uh using this trick and that is

01:01:24,880 --> 01:01:28,079
let's say i have x and y and i want to

01:01:26,400 --> 01:01:30,400
exchange their values

01:01:28,079 --> 01:01:32,319
in some languages i could say x comma y

01:01:30,400 --> 01:01:35,920
is assigned y comma x

01:01:32,319 --> 01:01:39,119
and that would just work uh in c plus

01:01:35,920 --> 01:01:42,240
i can do something similar i can say uh

01:01:39,119 --> 01:01:43,040
make me a tuple of interefs in ref comma

01:01:42,240 --> 01:01:46,559
in ref

01:01:43,040 --> 01:01:48,880
uh referring to x and referring to y and

01:01:46,559 --> 01:01:49,760
assign through to those things the

01:01:48,880 --> 01:01:52,720
values

01:01:49,760 --> 01:01:54,160
found in this tuple which is a copy of y

01:01:52,720 --> 01:01:57,200
and a copy of x

01:01:54,160 --> 01:01:59,680
this line happens to work fine

01:01:57,200 --> 01:02:00,720
however the two lines below it do not

01:01:59,680 --> 01:02:03,599
work

01:02:00,720 --> 01:02:04,799
because in both of those cases the thing

01:02:03,599 --> 01:02:07,119
that you have here on the right hand

01:02:04,799 --> 01:02:08,640
side is itself a tuple of references

01:02:07,119 --> 01:02:10,799
this is saying the same thing as like

01:02:08,640 --> 01:02:13,039
assign y to x

01:02:10,799 --> 01:02:15,200
and then assign x to y but you've

01:02:13,039 --> 01:02:17,119
already overwritten the value in

01:02:15,200 --> 01:02:19,280
in the local variable x by the time you

01:02:17,119 --> 01:02:20,720
get to reading its value again

01:02:19,280 --> 01:02:23,119
so neither of these things is going to

01:02:20,720 --> 01:02:24,559
do what you want

01:02:23,119 --> 01:02:26,960
the solution here is don't try to be

01:02:24,559 --> 01:02:28,240
clever don't overuse did tie

01:02:26,960 --> 01:02:30,079
write one assignment for line and of

01:02:28,240 --> 01:02:32,000
course in this particular case we're

01:02:30,079 --> 01:02:34,880
trying to exchange the values of x and y

01:02:32,000 --> 01:02:36,160
we should use stid swap we shouldn't be

01:02:34,880 --> 01:02:39,039
trying to be clever with this at all we

01:02:36,160 --> 01:02:39,039
should use did swap

01:02:39,280 --> 01:02:42,319
the other thing tai is useful for

01:02:40,880 --> 01:02:45,119
besides multiple assignment

01:02:42,319 --> 01:02:46,960
is compare through uh when you compare

01:02:45,119 --> 01:02:49,039
tuples of references you're actually

01:02:46,960 --> 01:02:53,119
doing lexicographic comparison

01:02:49,039 --> 01:02:54,640
on the referred to objects

01:02:53,119 --> 01:02:56,559
so here i have a name that consists of a

01:02:54,640 --> 01:02:57,760
first name and a last name but when i

01:02:56,559 --> 01:03:01,039
compare

01:02:57,760 --> 01:03:02,799
two names for less than

01:03:01,039 --> 01:03:04,160
i want to actually compare the last name

01:03:02,799 --> 01:03:05,200
first and i could write that out

01:03:04,160 --> 01:03:07,520
longhand

01:03:05,200 --> 01:03:09,599
or i could delegate the job of

01:03:07,520 --> 01:03:11,680
lexicographic comparison

01:03:09,599 --> 01:03:13,680
to tuple because tuple already

01:03:11,680 --> 01:03:14,160
implements lexicographic comparison for

01:03:13,680 --> 01:03:16,079
me

01:03:14,160 --> 01:03:18,480
what i'm going to do is create a tuple

01:03:16,079 --> 01:03:20,559
of references using stidhai

01:03:18,480 --> 01:03:22,400
the first element of the tuple is is my

01:03:20,559 --> 01:03:22,880
last name the second element is my first

01:03:22,400 --> 01:03:24,559
name

01:03:22,880 --> 01:03:26,319
and because it's a tuple of references

01:03:24,559 --> 01:03:27,920
i'm not making copies of them i'm just

01:03:26,319 --> 01:03:29,839
taking references to them this is very

01:03:27,920 --> 01:03:31,760
cheap

01:03:29,839 --> 01:03:33,359
i create a couple of references for a i

01:03:31,760 --> 01:03:34,480
create a couple of references for b

01:03:33,359 --> 01:03:36,480
and then i compare them

01:03:34,480 --> 01:03:38,960
lexicographically using

01:03:36,480 --> 01:03:40,960
tuples operator less than this does

01:03:38,960 --> 01:03:43,920
lexicographic comparison

01:03:40,960 --> 01:03:44,799
and it does the right thing so i like

01:03:43,920 --> 01:03:47,680
this idiom

01:03:44,799 --> 01:03:49,280
um with us equals plus 20 this idiom

01:03:47,680 --> 01:03:51,039
still applies although you you might

01:03:49,280 --> 01:03:52,400
change the name of this from less than

01:03:51,039 --> 01:03:56,160
to operator spaceship

01:03:52,400 --> 01:03:58,319
you could still use this same idiom uh

01:03:56,160 --> 01:04:00,000
to order the fields of your struct

01:03:58,319 --> 01:04:01,200
notice in this case defaulting operator

01:04:00,000 --> 01:04:02,720
spaceship wouldn't actually have done

01:04:01,200 --> 01:04:04,240
the right thing because i deliberately

01:04:02,720 --> 01:04:04,960
put first name last name in the wrong

01:04:04,240 --> 01:04:07,039
order

01:04:04,960 --> 01:04:09,200
um just to be sneaky on this slide all

01:04:07,039 --> 01:04:09,200
right

01:04:09,760 --> 01:04:13,839
uh so i said i'd get back to this tuple

01:04:12,000 --> 01:04:14,480
is not that great for public apis if you

01:04:13,839 --> 01:04:16,799
have

01:04:14,480 --> 01:04:17,680
a function that returns three pieces of

01:04:16,799 --> 01:04:20,960
information

01:04:17,680 --> 01:04:22,559
uh or even two um don't just wrap them

01:04:20,960 --> 01:04:24,319
up in a pair or a tuple

01:04:22,559 --> 01:04:26,559
um here i have a function generate

01:04:24,319 --> 01:04:29,520
default cert that returns a host name

01:04:26,559 --> 01:04:31,119
a certificate and a time to live all uh

01:04:29,520 --> 01:04:34,559
three pieces of information

01:04:31,119 --> 01:04:37,520
um and someone might say i should

01:04:34,559 --> 01:04:39,119
um you know i have two pieces to return

01:04:37,520 --> 01:04:40,079
i'll just put them all in a tuple and

01:04:39,119 --> 01:04:41,839
i'll return it like that

01:04:40,079 --> 01:04:44,160
and then if you want to get out the host

01:04:41,839 --> 01:04:45,359
name uh you just you know the host name

01:04:44,160 --> 01:04:46,240
is the first thing in the tuple no

01:04:45,359 --> 01:04:48,160
problem

01:04:46,240 --> 01:04:49,680
please don't do this though this is so

01:04:48,160 --> 01:04:52,240
ugly right to have to say

01:04:49,680 --> 01:04:52,720
get zero and know that that means the

01:04:52,240 --> 01:04:55,039
string

01:04:52,720 --> 01:04:56,160
member the host name member that that

01:04:55,039 --> 01:04:58,880
that seems

01:04:56,160 --> 01:05:01,119
awful and it would be much better to

01:04:58,880 --> 01:05:03,920
just go ahead and make a named struct

01:05:01,119 --> 01:05:04,400
give it uh meaningful values for each of

01:05:03,920 --> 01:05:06,400
its

01:05:04,400 --> 01:05:08,160
uh members uh this also gives you

01:05:06,400 --> 01:05:10,720
somewhere to hang uh special

01:05:08,160 --> 01:05:12,319
member functions if you decide that you

01:05:10,720 --> 01:05:13,119
need a member function for like the ttl

01:05:12,319 --> 01:05:15,200
has expired

01:05:13,119 --> 01:05:17,280
you don't have to actually fetch out the

01:05:15,200 --> 01:05:19,680
the double like you're on your way to

01:05:17,280 --> 01:05:23,280
class based design here this is great

01:05:19,680 --> 01:05:26,000
um so i highly recommend named types

01:05:23,280 --> 01:05:27,200
over tuples um you know don't get

01:05:26,000 --> 01:05:28,559
carried away with this stuff

01:05:27,200 --> 01:05:31,119
i showed you how to use it but use it

01:05:28,559 --> 01:05:32,960
wisely um

01:05:31,119 --> 01:05:34,400
so in conclusion use optional for maybe

01:05:32,960 --> 01:05:36,480
a tea or for a

01:05:34,400 --> 01:05:38,400
dynamic lifetime it's not a t yet but it

01:05:36,480 --> 01:05:40,640
might be soon or it was

01:05:38,400 --> 01:05:42,240
that's a good case first optional pair

01:05:40,640 --> 01:05:45,359
and tuple mostly used for implementation

01:05:42,240 --> 01:05:48,960
details prefer to use named classes

01:05:45,359 --> 01:05:50,720
in multiple interfaces remember that it

01:05:48,960 --> 01:05:52,640
is possible to construct these things in

01:05:50,720 --> 01:05:54,079
place using the in-place and piecewise

01:05:52,640 --> 01:05:56,799
construct tags

01:05:54,079 --> 01:05:57,599
um don't overuse those normally you

01:05:56,799 --> 01:05:59,920
don't need it

01:05:57,599 --> 01:06:01,599
um but if you find yourself dealing with

01:05:59,920 --> 01:06:03,680
immovable types

01:06:01,599 --> 01:06:05,039
types without move constructors remember

01:06:03,680 --> 01:06:07,920
that these things exist and they are

01:06:05,039 --> 01:06:07,920
possible to use

01:06:08,799 --> 01:06:11,920
remember if you have hosted variant you

01:06:10,559 --> 01:06:14,960
probably are going to use

01:06:11,920 --> 01:06:16,400
visit at some point and uh if you have a

01:06:14,960 --> 01:06:18,079
variant

01:06:16,400 --> 01:06:19,839
know that valueless by exception is a

01:06:18,079 --> 01:06:20,880
thing but also know that you don't have

01:06:19,839 --> 01:06:23,760
to worry about it

01:06:20,880 --> 01:06:25,200
right it's a a very rare case uh if

01:06:23,760 --> 01:06:28,079
you're in the back the basics track

01:06:25,200 --> 01:06:29,200
um don't go out of your way to try to

01:06:28,079 --> 01:06:30,720
figure out what to do about it because

01:06:29,200 --> 01:06:32,240
the right answer is

01:06:30,720 --> 01:06:34,319
it's just gonna work don't worry about

01:06:32,240 --> 01:06:36,160
it um

01:06:34,319 --> 01:06:38,960
and with that we are finally done i'm

01:06:36,160 --> 01:06:40,400
sure we're a little bit over time

01:06:38,960 --> 01:06:43,359
uh i would still like to take some

01:06:40,400 --> 01:06:47,280
questions if we can uh nikail if that's

01:06:43,359 --> 01:06:50,559
cool and if there are any questions um

01:06:47,280 --> 01:06:51,839
it looks like there were a couple so if

01:06:50,559 --> 01:06:53,839
one of the

01:06:51,839 --> 01:06:55,520
variant alternatives is not implicitly

01:06:53,839 --> 01:06:58,640
convertible to a string will it fail

01:06:55,520 --> 01:06:58,640
at compile time

01:06:59,440 --> 01:07:03,119
in the uh in that case back there where

01:07:01,839 --> 01:07:06,319
we were printing out

01:07:03,119 --> 01:07:06,799
um the bits of the top of this bit yeah

01:07:06,319 --> 01:07:09,920
so

01:07:06,799 --> 01:07:12,000
here uh the compiler will be

01:07:09,920 --> 01:07:13,520
instantiating that generic lambda for

01:07:12,000 --> 01:07:15,440
every one of the types

01:07:13,520 --> 01:07:17,920
in the variant and if the body of the

01:07:15,440 --> 01:07:18,480
lambda doesn't compile for one of those

01:07:17,920 --> 01:07:21,039
types

01:07:18,480 --> 01:07:22,880
then uh you get some crazy template

01:07:21,039 --> 01:07:25,839
error message yes

01:07:22,880 --> 01:07:26,880
um so you want to you could use if const

01:07:25,839 --> 01:07:29,119
exper or

01:07:26,880 --> 01:07:30,400
requires clause or something to try to

01:07:29,119 --> 01:07:31,760
to work around that if you had that

01:07:30,400 --> 01:07:33,680
situation

01:07:31,760 --> 01:07:35,680
um and what would i recommend for

01:07:33,680 --> 01:07:38,640
optional parameters if not optional t

01:07:35,680 --> 01:07:39,760
um pretty much i don't think i have

01:07:38,640 --> 01:07:42,960
anything

01:07:39,760 --> 01:07:44,000
really to say with that other than that

01:07:42,960 --> 01:07:47,839
one slide

01:07:44,000 --> 01:07:50,160
that gave some options here um so

01:07:47,839 --> 01:07:50,880
either there's a situation where

01:07:50,160 --> 01:07:52,079
optional t

01:07:50,880 --> 01:07:53,680
is fine but you probably want to take it

01:07:52,079 --> 01:07:55,039
by const reference because someone else

01:07:53,680 --> 01:07:55,440
has an optional and you just want to

01:07:55,039 --> 01:07:58,079
view

01:07:55,440 --> 01:07:59,599
they're optional or they don't have an

01:07:58,079 --> 01:08:00,240
optional and they really just have two

01:07:59,599 --> 01:08:02,559
different

01:08:00,240 --> 01:08:04,000
things that they're trying to do one is

01:08:02,559 --> 01:08:05,680
they want to pass the argument the other

01:08:04,000 --> 01:08:07,839
is they don't want to pass the argument

01:08:05,680 --> 01:08:09,200
and i wouldn't want to give those two

01:08:07,839 --> 01:08:10,720
things the same signature so that

01:08:09,200 --> 01:08:12,160
someone could accidentally forget the

01:08:10,720 --> 01:08:13,520
argument i'd rather give them different

01:08:12,160 --> 01:08:16,080
signatures

01:08:13,520 --> 01:08:18,159
um so in general where people think they

01:08:16,080 --> 01:08:22,839
want optional parameters

01:08:18,159 --> 01:08:24,960
um i think quite often they probably

01:08:22,839 --> 01:08:27,279
don't

01:08:24,960 --> 01:08:27,279
um

01:08:31,520 --> 01:08:35,759
i'm just checking the q a tab here or

01:08:33,920 --> 01:08:36,480
make pair make tuples still useful with

01:08:35,759 --> 01:08:39,679
ctad

01:08:36,480 --> 01:08:42,319
um if you're in c plus plus um

01:08:39,679 --> 01:08:43,199
17 and you have class template argument

01:08:42,319 --> 01:08:46,080
deduction

01:08:43,199 --> 01:08:47,839
should you use stid make pair of some

01:08:46,080 --> 01:08:52,239
stuff or should you use stid pair

01:08:47,839 --> 01:08:54,480
of some stuff um and

01:08:52,239 --> 01:08:56,000
there is one thing that make t make

01:08:54,480 --> 01:08:58,799
payer and make tupple do

01:08:56,000 --> 01:09:00,000
which the ctad version does not if i

01:08:58,799 --> 01:09:02,880
just said here stid

01:09:00,000 --> 01:09:04,560
tupple of stidgraf instead ref i would

01:09:02,880 --> 01:09:06,319
get a couple of reference wrappers which

01:09:04,560 --> 01:09:07,440
is not what i want that would not do a

01:09:06,319 --> 01:09:09,199
sign through

01:09:07,440 --> 01:09:10,560
uh if i want to make a couple of

01:09:09,199 --> 01:09:13,040
references

01:09:10,560 --> 01:09:15,440
i should use make tuple with stidgraph

01:09:13,040 --> 01:09:15,440
like this

01:09:15,920 --> 01:09:19,520
in general that would probably work fine

01:09:19,759 --> 01:09:24,239
i'm not a huge fan of ctad we can take

01:09:21,440 --> 01:09:26,560
that offline um

01:09:24,239 --> 01:09:28,239
but that is the one big difference is if

01:09:26,560 --> 01:09:30,239
you're using stid ref

01:09:28,239 --> 01:09:31,600
in the one case with ctad you will get

01:09:30,239 --> 01:09:33,440
reference wrappers

01:09:31,600 --> 01:09:36,239
in the case that you use make tuple it

01:09:33,440 --> 01:09:37,920
will do library decay

01:09:36,239 --> 01:09:40,880
or make pair we'll do library decay and

01:09:37,920 --> 01:09:40,880
we'll give you references

01:09:41,920 --> 01:09:48,960
um cool

01:09:45,440 --> 01:09:50,560
i see no further questions so i think

01:09:48,960 --> 01:09:52,319
thank you for coming enjoy the back to

01:09:50,560 --> 01:10:03,840
basics track

01:09:52,319 --> 01:10:03,840
come to my class i'm arthur o'dwyer

01:10:14,640 --> 01:10:16,719

YouTube URL: https://www.youtube.com/watch?v=OJzmWqCCZaM


