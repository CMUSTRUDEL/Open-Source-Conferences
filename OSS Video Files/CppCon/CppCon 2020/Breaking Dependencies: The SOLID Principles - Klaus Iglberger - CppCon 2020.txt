Title: Breaking Dependencies: The SOLID Principles - Klaus Iglberger - CppCon 2020
Publication date: 2020-09-23
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/breaking_dependencies_the_solid_principles/breaking_dependencies_the_solid_principles__klaus_iglberger__cppcon_2020.pdf
---

SOLID is an abbreviation for five of the most important software design principles:
- (S)ingle Responsibility Principle
- (O)pen-Closed Principle
- (L)iskov Substitution Principle
- (I)nterface Segregation Principle
- (D)ependency Inversion Principle

For almost two decades, these principles have proven to be a valuable set of guidelines to cope with software dependencies. Although initially introduced as guidelines for object-oriented programming, they have become a universal set of guidelines that can be used equally well for procedural, functional or generic programming. In this talk I'll recap the SOLID principles and explain why they form such a valuable set of universal design guidelines. Also, I'll go into detail about several common misconceptions.

---
Klaus Iglberger is a freelancing C++ trainer and consultant. He has finished his PhD in computer science in 2010 and since then is focused on large-scale C++ software design. He shares his experience in popular advanced C++ courses around the world (mainly in Germany, but also the EU and US). Additionally, he is the initiator and lead designer of the Blaze C++ math library (https://bitbucket.org/blaze-lib/blaze/src/master/) and one of the organizers of the Munich C++ user group (https://www.meetup.com/MUCplusplus/).

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,559 --> 00:00:11,360
so

00:00:08,960 --> 00:00:12,160
wonderful good afternoon good evening or

00:00:11,360 --> 00:00:14,400
good morning

00:00:12,160 --> 00:00:15,440
depending wherever you are and welcome

00:00:14,400 --> 00:00:17,440
to this talk about

00:00:15,440 --> 00:00:19,279
the solid principles allow me to

00:00:17,440 --> 00:00:21,760
introduce myself first

00:00:19,279 --> 00:00:23,439
my name is claus i'm a sincere blessous

00:00:21,760 --> 00:00:27,199
trainer since approximately

00:00:23,439 --> 00:00:28,400
2016. additionally i also do see blessed

00:00:27,199 --> 00:00:30,080
with my free time

00:00:28,400 --> 00:00:32,480
so i'm for instance the author of a c

00:00:30,080 --> 00:00:35,040
plus bus library called blaze

00:00:32,480 --> 00:00:36,640
and i'm one of the core organizers of

00:00:35,040 --> 00:00:38,719
the municiples user group

00:00:36,640 --> 00:00:40,079
which as i said remark maybe one of the

00:00:38,719 --> 00:00:43,200
biggest and most active

00:00:40,079 --> 00:00:45,440
c plus user groups worldwide

00:00:43,200 --> 00:00:46,800
today in this talk we're talking about

00:00:45,440 --> 00:00:48,399
software

00:00:46,800 --> 00:00:50,079
and as this may not come a surprise

00:00:48,399 --> 00:00:51,600
because probably all talks at this

00:00:50,079 --> 00:00:55,360
conference are about software

00:00:51,600 --> 00:00:56,800
this is really about software

00:00:55,360 --> 00:00:58,320
there is a reason that software is

00:00:56,800 --> 00:01:01,039
called software because we have a

00:00:58,320 --> 00:01:03,600
certain expectation in software

00:01:01,039 --> 00:01:04,479
the soft actually means that it's easy

00:01:03,600 --> 00:01:07,920
to change

00:01:04,479 --> 00:01:09,520
and easy to extend that was initially

00:01:07,920 --> 00:01:10,240
the reason why software was called

00:01:09,520 --> 00:01:12,000
software

00:01:10,240 --> 00:01:14,720
in comparison to hardware which is

00:01:12,000 --> 00:01:17,200
difficult to change

00:01:14,720 --> 00:01:18,320
however unfortunately you may have

00:01:17,200 --> 00:01:20,799
experienced this yourself

00:01:18,320 --> 00:01:22,479
it may not be true that software is easy

00:01:20,799 --> 00:01:24,799
to change

00:01:22,479 --> 00:01:26,560
now so it may depend on where you work

00:01:24,799 --> 00:01:28,560
but especially larger frameworks

00:01:26,560 --> 00:01:30,000
tend to be harder to change harder to

00:01:28,560 --> 00:01:32,159
extend

00:01:30,000 --> 00:01:33,520
and that ultimately may be due to

00:01:32,159 --> 00:01:36,000
dependencies

00:01:33,520 --> 00:01:37,600
so perhaps to quote uh david thomas and

00:01:36,000 --> 00:01:40,320
andrew hunt on this one

00:01:37,600 --> 00:01:42,479
coupling is the enemy of change because

00:01:40,320 --> 00:01:44,799
it links together things that must not

00:01:42,479 --> 00:01:48,000
must change in parallel

00:01:44,799 --> 00:01:50,159
and the second expert ken beck said

00:01:48,000 --> 00:01:51,600
dependency is the key problem in

00:01:50,159 --> 00:01:54,880
software development

00:01:51,600 --> 00:01:57,680
at all scales so dependency

00:01:54,880 --> 00:01:59,040
coupling as another word is exactly the

00:01:57,680 --> 00:01:59,680
problem that we need to overcome in

00:01:59,040 --> 00:02:02,640
order to

00:01:59,680 --> 00:02:04,240
write large-scale software unfortunately

00:02:02,640 --> 00:02:06,000
this is not an easy problem

00:02:04,240 --> 00:02:08,959
on the contrary this is a particularly

00:02:06,000 --> 00:02:11,200
difficult problem but luckily there is a

00:02:08,959 --> 00:02:14,080
couple of guidelines that help us

00:02:11,200 --> 00:02:16,080
this is exactly what this talk is about

00:02:14,080 --> 00:02:17,680
this is about the solid principles a set

00:02:16,080 --> 00:02:20,160
of guidelines that allows us

00:02:17,680 --> 00:02:21,520
to deal with dependencies in different

00:02:20,160 --> 00:02:24,000
ways

00:02:21,520 --> 00:02:24,640
so behind the solid acronyms there is

00:02:24,000 --> 00:02:27,200
five

00:02:24,640 --> 00:02:30,239
um principles the first one is called

00:02:27,200 --> 00:02:32,000
the single responsibility principle

00:02:30,239 --> 00:02:33,680
as this name already suggests quite a

00:02:32,000 --> 00:02:35,519
bit this is probably one of the most

00:02:33,680 --> 00:02:36,800
misinterpreted principles

00:02:35,519 --> 00:02:39,680
and definitely we have to talk about

00:02:36,800 --> 00:02:41,920
this in detail the second one is called

00:02:39,680 --> 00:02:44,239
the open close principle

00:02:41,920 --> 00:02:45,760
this name does not suggest a lot but

00:02:44,239 --> 00:02:47,599
believe it or not this is actually

00:02:45,760 --> 00:02:49,760
one of the most important principles

00:02:47,599 --> 00:02:51,760
that i can tell you

00:02:49,760 --> 00:02:53,200
then comes the aliska substitution

00:02:51,760 --> 00:02:56,239
principle

00:02:53,200 --> 00:02:57,200
much more much wider known and even if

00:02:56,239 --> 00:02:59,599
you don't know this

00:02:57,200 --> 00:03:00,560
haven't heard about this before you will

00:02:59,599 --> 00:03:04,480
definitely

00:03:00,560 --> 00:03:06,319
use this on a daily basis i assume

00:03:04,480 --> 00:03:07,599
the i is the interface segregation

00:03:06,319 --> 00:03:09,360
principle

00:03:07,599 --> 00:03:11,280
this name again suggests a lot so it's

00:03:09,360 --> 00:03:14,000
about segregating interfaces

00:03:11,280 --> 00:03:15,840
we talk about why and how and the last

00:03:14,000 --> 00:03:19,200
one is the so-called dependency

00:03:15,840 --> 00:03:21,360
inversion principle

00:03:19,200 --> 00:03:23,120
now allow me one or two sentences about

00:03:21,360 --> 00:03:24,879
the history of these principles

00:03:23,120 --> 00:03:26,319
they are not particularly new so for

00:03:24,879 --> 00:03:27,840
instance the open close principle and

00:03:26,319 --> 00:03:31,200
the list of substitution principle

00:03:27,840 --> 00:03:34,000
have been formulated in 1988

00:03:31,200 --> 00:03:34,799
but only in the year 2000 the left of

00:03:34,000 --> 00:03:37,760
these gentlemen

00:03:34,799 --> 00:03:38,879
robert martin he actually selected these

00:03:37,760 --> 00:03:41,200
five principles as

00:03:38,879 --> 00:03:41,920
the most important software design

00:03:41,200 --> 00:03:43,440
principles

00:03:41,920 --> 00:03:45,599
at that time he selected them as the

00:03:43,440 --> 00:03:47,120
most important object-oriented design

00:03:45,599 --> 00:03:49,519
principles

00:03:47,120 --> 00:03:51,040
we're going to talk about that too a

00:03:49,519 --> 00:03:53,040
couple of years later only

00:03:51,040 --> 00:03:54,720
michael feathers realized that if you

00:03:53,040 --> 00:03:56,640
arrange these five principles in

00:03:54,720 --> 00:03:59,040
exactly this order then the first

00:03:56,640 --> 00:04:00,799
letters give you solid

00:03:59,040 --> 00:04:02,159
and this is when officially these solid

00:04:00,799 --> 00:04:04,080
principles were born

00:04:02,159 --> 00:04:05,439
as a very very important set of

00:04:04,080 --> 00:04:08,159
guidelines to write

00:04:05,439 --> 00:04:08,159
clean code

00:04:08,640 --> 00:04:12,080
now in wikipedia solid is mentioned as

00:04:10,560 --> 00:04:14,400
well however

00:04:12,080 --> 00:04:17,519
you might see this it's a little small

00:04:14,400 --> 00:04:19,280
but this is about object-oriented design

00:04:17,519 --> 00:04:21,040
in this talk i'm trying to do this a

00:04:19,280 --> 00:04:22,800
little differently

00:04:21,040 --> 00:04:24,080
so in this talk i will introduce this

00:04:22,800 --> 00:04:26,320
all principles

00:04:24,080 --> 00:04:27,440
it's a guideline a set of guidelines not

00:04:26,320 --> 00:04:28,639
limited to object object-oriented

00:04:27,440 --> 00:04:30,639
programming alone

00:04:28,639 --> 00:04:32,080
i will try to introduce them as a

00:04:30,639 --> 00:04:33,440
general set of guidelines

00:04:32,080 --> 00:04:34,720
for object-oriented programming

00:04:33,440 --> 00:04:35,680
functional programming generic

00:04:34,720 --> 00:04:37,520
programming

00:04:35,680 --> 00:04:39,759
and basically for all the languages that

00:04:37,520 --> 00:04:41,840
you might be using so in other words

00:04:39,759 --> 00:04:42,880
i try to introduce them as a universal

00:04:41,840 --> 00:04:46,800
set of design

00:04:42,880 --> 00:04:48,720
guidelines now i will do them in order

00:04:46,800 --> 00:04:52,560
and the very first of these principles

00:04:48,720 --> 00:04:54,560
is the single responsibility principle

00:04:52,560 --> 00:04:56,639
if you would not have heard about this

00:04:54,560 --> 00:04:58,720
principle before i believe you would

00:04:56,639 --> 00:05:00,960
first of all go to wikipedia

00:04:58,720 --> 00:05:02,400
and try to get a first idea what this

00:05:00,960 --> 00:05:04,240
principle is about

00:05:02,400 --> 00:05:06,639
so this is what wikipedia has to say

00:05:04,240 --> 00:05:08,639
about this principle

00:05:06,639 --> 00:05:10,000
the single responsibility principle

00:05:08,639 --> 00:05:12,400
states that every

00:05:10,000 --> 00:05:13,680
module or class should have a

00:05:12,400 --> 00:05:15,759
responsibility over a

00:05:13,680 --> 00:05:17,919
single part of the functionality

00:05:15,759 --> 00:05:19,919
provided by the software

00:05:17,919 --> 00:05:22,560
and that responsibility should be

00:05:19,919 --> 00:05:25,840
entirely encapsulated by the class

00:05:22,560 --> 00:05:27,880
module or function all its services

00:05:25,840 --> 00:05:30,720
should be narrowly aligned with that

00:05:27,880 --> 00:05:33,120
responsibility

00:05:30,720 --> 00:05:34,400
whereas this may sound pretty nice

00:05:33,120 --> 00:05:37,600
pretty reasonable

00:05:34,400 --> 00:05:38,800
and intuitive i believe there's a lot of

00:05:37,600 --> 00:05:40,840
questions in there

00:05:38,800 --> 00:05:42,639
especially the question about

00:05:40,840 --> 00:05:44,800
responsibility

00:05:42,639 --> 00:05:46,240
what is the responsibility so in other

00:05:44,800 --> 00:05:48,639
words what should my

00:05:46,240 --> 00:05:50,560
class modular function should have only

00:05:48,639 --> 00:05:53,199
one off

00:05:50,560 --> 00:05:54,639
this is a seriously difficult question

00:05:53,199 --> 00:05:56,880
and unfortunately

00:05:54,639 --> 00:05:58,000
this uh principle therefore has been

00:05:56,880 --> 00:06:00,400
simplified

00:05:58,000 --> 00:06:02,080
and perhaps to some extent distorted

00:06:00,400 --> 00:06:05,360
into something like that

00:06:02,080 --> 00:06:06,960
everything should do just one thing

00:06:05,360 --> 00:06:08,639
that is what i would call the common

00:06:06,960 --> 00:06:11,360
knowledge

00:06:08,639 --> 00:06:13,520
although this may sound simpler it's

00:06:11,360 --> 00:06:16,160
probably even more vague

00:06:13,520 --> 00:06:16,639
should do just one thing what is this

00:06:16,160 --> 00:06:20,639
one

00:06:16,639 --> 00:06:22,240
thing really hard to answer

00:06:20,639 --> 00:06:24,880
and so is looking for a better

00:06:22,240 --> 00:06:26,479
explanation of what srp is truly about

00:06:24,880 --> 00:06:28,080
how we can understand the single

00:06:26,479 --> 00:06:30,319
responsibility principle

00:06:28,080 --> 00:06:32,560
and i found a quote in a book called the

00:06:30,319 --> 00:06:35,199
pragmatic programmer

00:06:32,560 --> 00:06:37,280
these two guys david hunt uh andrea hunt

00:06:35,199 --> 00:06:39,280
and david thomas do not talk about

00:06:37,280 --> 00:06:42,560
the single responsibility principle they

00:06:39,280 --> 00:06:45,319
actually talk about orthogonality

00:06:42,560 --> 00:06:47,039
we want to design components that are

00:06:45,319 --> 00:06:49,680
self-contained

00:06:47,039 --> 00:06:51,840
independent and with a single

00:06:49,680 --> 00:06:55,039
well-defined purpose

00:06:51,840 --> 00:06:57,440
they use the word cohesion here when

00:06:55,039 --> 00:07:00,560
components are isolated from one another

00:06:57,440 --> 00:07:01,759
you know that you can change one without

00:07:00,560 --> 00:07:05,120
having to worry about

00:07:01,759 --> 00:07:06,479
the rest so i have to admit i like this

00:07:05,120 --> 00:07:08,720
quote much better

00:07:06,479 --> 00:07:09,680
because it basically gives us an idea

00:07:08,720 --> 00:07:14,000
that this is about

00:07:09,680 --> 00:07:15,440
change we truly want to change easily

00:07:14,000 --> 00:07:18,160
and they do not use the word

00:07:15,440 --> 00:07:21,280
responsibility but purpose

00:07:18,160 --> 00:07:21,680
and this other word cohesion and i

00:07:21,280 --> 00:07:26,319
believe

00:07:21,680 --> 00:07:28,080
together with a quote from tom demarco

00:07:26,319 --> 00:07:30,400
the idea of the single responsibility

00:07:28,080 --> 00:07:32,960
principle becomes clear

00:07:30,400 --> 00:07:34,800
cohesion is a measure of the strength of

00:07:32,960 --> 00:07:36,000
association of the elements inside a

00:07:34,800 --> 00:07:38,319
module

00:07:36,000 --> 00:07:39,120
a highly cohesive module is a collection

00:07:38,319 --> 00:07:41,919
of statements

00:07:39,120 --> 00:07:42,479
and data items that should be treated as

00:07:41,919 --> 00:07:45,520
a whole

00:07:42,479 --> 00:07:47,680
because they are so closely related

00:07:45,520 --> 00:07:50,000
any attempt to divide them up would only

00:07:47,680 --> 00:07:53,680
result in increased coupling

00:07:50,000 --> 00:07:54,400
and decreased readability so ultimately

00:07:53,680 --> 00:07:57,759
of course

00:07:54,400 --> 00:08:01,599
our idea is to decrease coupling to

00:07:57,759 --> 00:08:03,440
increase the coherence of things

00:08:01,599 --> 00:08:05,599
so the single responsibility principle

00:08:03,440 --> 00:08:08,960
is not about doing one thing

00:08:05,599 --> 00:08:12,000
which is really way too awake it's about

00:08:08,960 --> 00:08:14,400
the structure of code those things that

00:08:12,000 --> 00:08:15,120
truly belong together that you cannot

00:08:14,400 --> 00:08:17,360
separate

00:08:15,120 --> 00:08:18,479
intuitively those things should go

00:08:17,360 --> 00:08:20,319
together

00:08:18,479 --> 00:08:22,800
but everything that does not belong

00:08:20,319 --> 00:08:25,360
everything that is an orthogonal aspect

00:08:22,800 --> 00:08:27,520
a separate aspect should be separated

00:08:25,360 --> 00:08:28,879
into a different software unit

00:08:27,520 --> 00:08:31,280
this could be a different function a

00:08:28,879 --> 00:08:32,240
different class a different module

00:08:31,280 --> 00:08:34,320
altogether

00:08:32,240 --> 00:08:35,360
but it definitely should be separated

00:08:34,320 --> 00:08:38,479
from this other

00:08:35,360 --> 00:08:38,479
orthogonal aspect

00:08:38,560 --> 00:08:43,120
so robert martin the one who put all

00:08:41,519 --> 00:08:43,519
these solid principles together simply

00:08:43,120 --> 00:08:45,839
said

00:08:43,519 --> 00:08:46,560
a class should only have one reason to

00:08:45,839 --> 00:08:48,880
change

00:08:46,560 --> 00:08:49,839
so indeed ultimately it's about changing

00:08:48,880 --> 00:08:53,120
things easily

00:08:49,839 --> 00:08:55,680
changing things in isolation

00:08:53,120 --> 00:08:57,440
so how does this work i want me to give

00:08:55,680 --> 00:09:00,720
you an example

00:08:57,440 --> 00:09:02,720
a circle class okay okay

00:09:00,720 --> 00:09:03,760
i know a circle class may not be what

00:09:02,720 --> 00:09:06,640
you expect as a

00:09:03,760 --> 00:09:07,200
realistic bigger example but we tend to

00:09:06,640 --> 00:09:09,200
understand

00:09:07,200 --> 00:09:10,480
circles and other kinds of shapes pretty

00:09:09,200 --> 00:09:12,560
easily

00:09:10,480 --> 00:09:14,880
and let's face it it's kind of tradition

00:09:12,560 --> 00:09:16,640
to introduce things by means of some

00:09:14,880 --> 00:09:19,440
circle or animal hierarchy

00:09:16,640 --> 00:09:21,279
or shape or animal hierarchy so let's

00:09:19,440 --> 00:09:24,240
deal with a circle here

00:09:21,279 --> 00:09:25,360
this circle first of all has and gets a

00:09:24,240 --> 00:09:27,600
radius

00:09:25,360 --> 00:09:29,839
which it gives to data member and there

00:09:27,600 --> 00:09:32,880
may be some other data members like

00:09:29,839 --> 00:09:34,959
some center position some orientation

00:09:32,880 --> 00:09:36,080
whatever we need there may be a couple

00:09:34,959 --> 00:09:39,120
of getters that allow us

00:09:36,080 --> 00:09:41,600
access to this to all these data members

00:09:39,120 --> 00:09:43,120
then we can translate a circle meaning

00:09:41,600 --> 00:09:44,320
move the center point to another

00:09:43,120 --> 00:09:46,800
position

00:09:44,320 --> 00:09:48,880
of course we can rotate it everything

00:09:46,800 --> 00:09:51,200
needs to rotate of course

00:09:48,880 --> 00:09:52,959
and then it can be drawn to the screen

00:09:51,200 --> 00:09:54,880
drawn to the printer

00:09:52,959 --> 00:09:57,200
and it can be serialized to some byte

00:09:54,880 --> 00:09:57,200
stream

00:09:58,399 --> 00:10:02,839
of course this class is not perfect with

00:10:01,040 --> 00:10:05,680
regard to the single responsibility

00:10:02,839 --> 00:10:08,000
principle it may sound like an

00:10:05,680 --> 00:10:09,120
amazing idea to actually put everything

00:10:08,000 --> 00:10:11,920
that the circle ever

00:10:09,120 --> 00:10:13,360
can do inside the circle to give a user

00:10:11,920 --> 00:10:16,720
the ability to draw

00:10:13,360 --> 00:10:18,800
to serialize and to whatnot but

00:10:16,720 --> 00:10:20,720
it's not necessarily a good idea from a

00:10:18,800 --> 00:10:23,440
coupling point of view

00:10:20,720 --> 00:10:24,240
so my problem is primarily these three

00:10:23,440 --> 00:10:25,920
functions

00:10:24,240 --> 00:10:27,920
and potentially all the functions that

00:10:25,920 --> 00:10:29,839
are not visible

00:10:27,920 --> 00:10:31,279
these three functions make it harder to

00:10:29,839 --> 00:10:33,600
deal with a circle in general

00:10:31,279 --> 00:10:34,880
these three functions make it hard to

00:10:33,600 --> 00:10:38,560
change

00:10:34,880 --> 00:10:41,200
the circle so let's think about

00:10:38,560 --> 00:10:42,959
when does a circle change when do i have

00:10:41,200 --> 00:10:44,839
to go to the circle class and make

00:10:42,959 --> 00:10:48,160
changes

00:10:44,839 --> 00:10:50,320
well first of all i probably have to do

00:10:48,160 --> 00:10:51,680
changes if some basic properties of the

00:10:50,320 --> 00:10:54,160
circle change

00:10:51,680 --> 00:10:55,920
well this may of course be if we decide

00:10:54,160 --> 00:10:58,320
that the radius is not what we need

00:10:55,920 --> 00:10:59,600
we want to use the diameter instead i

00:10:58,320 --> 00:11:04,160
think this is a fairly

00:10:59,600 --> 00:11:06,720
rare case but still it's a possibility

00:11:04,160 --> 00:11:08,079
this circle also changes if the screen

00:11:06,720 --> 00:11:09,600
class changes

00:11:08,079 --> 00:11:11,040
then we have to go back to the draw

00:11:09,600 --> 00:11:12,000
function and adapt the function

00:11:11,040 --> 00:11:13,440
accordingly

00:11:12,000 --> 00:11:15,360
and of course the same is true for the

00:11:13,440 --> 00:11:17,680
printer class if printer changes

00:11:15,360 --> 00:11:18,640
we add up something in circle and of

00:11:17,680 --> 00:11:21,920
course

00:11:18,640 --> 00:11:24,320
it also is true for right string

00:11:21,920 --> 00:11:26,079
the circle also changes if the

00:11:24,320 --> 00:11:29,920
implementation details of draw

00:11:26,079 --> 00:11:32,399
change so if you decide that we do not

00:11:29,920 --> 00:11:33,920
want to draw by means of opengl anymore

00:11:32,399 --> 00:11:34,720
but that we want to use something more

00:11:33,920 --> 00:11:37,760
modern

00:11:34,720 --> 00:11:41,440
unlike metal or vulcan

00:11:37,760 --> 00:11:43,360
then we are changing the circle class

00:11:41,440 --> 00:11:44,480
and of course the same also holds true

00:11:43,360 --> 00:11:46,800
for all the other functions

00:11:44,480 --> 00:11:48,720
for instance serialize serialize may

00:11:46,800 --> 00:11:49,920
change if you decide that we don't want

00:11:48,720 --> 00:11:52,720
to use big endian but

00:11:49,920 --> 00:11:55,200
literally indian and so implementation

00:11:52,720 --> 00:11:56,880
details of circle would change

00:11:55,200 --> 00:11:59,040
and of course there may be many many

00:11:56,880 --> 00:12:02,160
more reasons why i have to go back

00:11:59,040 --> 00:12:05,279
and change circle ultimately this is

00:12:02,160 --> 00:12:07,440
exactly what we do not want to have

00:12:05,279 --> 00:12:10,480
and just for the single reason of not

00:12:07,440 --> 00:12:12,880
introducing too many dependencies

00:12:10,480 --> 00:12:14,000
if you visualize these dependencies then

00:12:12,880 --> 00:12:17,360
this may look

00:12:14,000 --> 00:12:17,839
something like that so there is a circle

00:12:17,360 --> 00:12:19,279
class

00:12:17,839 --> 00:12:21,200
and came out comes along with its

00:12:19,279 --> 00:12:23,279
brother square

00:12:21,200 --> 00:12:25,200
and both circle and square are aware of

00:12:23,279 --> 00:12:28,000
screens and printers

00:12:25,200 --> 00:12:29,680
and the byte stream also now imagine

00:12:28,000 --> 00:12:31,440
that eventually

00:12:29,680 --> 00:12:33,120
i went to compute overlaps between

00:12:31,440 --> 00:12:34,959
different kinds of shapes so this is an

00:12:33,120 --> 00:12:37,200
entire module with functionality just

00:12:34,959 --> 00:12:39,120
for that purpose

00:12:37,200 --> 00:12:40,560
computing the overlap between circles

00:12:39,120 --> 00:12:43,040
and squares has nothing to do with

00:12:40,560 --> 00:12:45,920
screens printers and byte streams

00:12:43,040 --> 00:12:46,959
yet still overlap knows about them due

00:12:45,920 --> 00:12:50,079
to this

00:12:46,959 --> 00:12:52,880
hidden dependency and that of course

00:12:50,079 --> 00:12:54,079
is unfortunate because every time i add

00:12:52,880 --> 00:12:56,399
up something in screen

00:12:54,079 --> 00:12:57,360
there is the danger of a change in

00:12:56,399 --> 00:13:00,560
overlap too

00:12:57,360 --> 00:13:02,320
etc etc this kind of dependency is

00:13:00,560 --> 00:13:03,200
exactly what makes it so hard to deal

00:13:02,320 --> 00:13:05,200
with things

00:13:03,200 --> 00:13:07,839
this is what makes it so hard to change

00:13:05,200 --> 00:13:10,399
things in isolation

00:13:07,839 --> 00:13:11,600
a much better approach would be to

00:13:10,399 --> 00:13:14,480
handle things

00:13:11,600 --> 00:13:16,399
in this way so overlap simply knows only

00:13:14,480 --> 00:13:18,160
about circle and square

00:13:16,399 --> 00:13:20,720
and you might imagine some module that

00:13:18,160 --> 00:13:22,079
deals with drawing and that module of

00:13:20,720 --> 00:13:23,040
course also knows about circle and

00:13:22,079 --> 00:13:26,320
squares

00:13:23,040 --> 00:13:27,680
but also about the screen printing with

00:13:26,320 --> 00:13:30,560
additional need the printer

00:13:27,680 --> 00:13:31,279
serialization might need the bite stream

00:13:30,560 --> 00:13:34,000
everything

00:13:31,279 --> 00:13:35,920
is much easier also it's much more

00:13:34,000 --> 00:13:37,920
honest about the dependencies

00:13:35,920 --> 00:13:39,760
there's no hidden dependencies things

00:13:37,920 --> 00:13:42,320
that make my life harder

00:13:39,760 --> 00:13:43,120
so ultimately indeed these three

00:13:42,320 --> 00:13:46,240
functions

00:13:43,120 --> 00:13:46,959
draw so to draw and serialize should not

00:13:46,240 --> 00:13:49,920
be part

00:13:46,959 --> 00:13:52,560
of the circle in order to minimize

00:13:49,920 --> 00:13:52,560
dependencies

00:13:55,040 --> 00:13:59,600
a couple of further examples so for

00:13:57,199 --> 00:14:01,360
instance the design of the sdl

00:13:59,600 --> 00:14:02,959
very very nicely follows the single

00:14:01,360 --> 00:14:06,399
responsibility principle

00:14:02,959 --> 00:14:08,800
data structures algorithms allocators

00:14:06,399 --> 00:14:10,320
very nicely separated of course they

00:14:08,800 --> 00:14:13,040
share a common interface

00:14:10,320 --> 00:14:14,399
such like iterators but they don't have

00:14:13,040 --> 00:14:16,480
to know about each other

00:14:14,399 --> 00:14:18,240
i can change one without having to worry

00:14:16,480 --> 00:14:21,199
about the rest

00:14:18,240 --> 00:14:22,720
very nice example also i would argue

00:14:21,199 --> 00:14:24,560
standard vector follows the single

00:14:22,720 --> 00:14:26,480
responsibility principle nicely

00:14:24,560 --> 00:14:28,160
because all of the functions are truly

00:14:26,480 --> 00:14:31,600
focused on managing

00:14:28,160 --> 00:14:34,160
a dynamic array

00:14:31,600 --> 00:14:34,639
standard string on the other hand does

00:14:34,160 --> 00:14:35,839
not

00:14:34,639 --> 00:14:37,920
perfectly follow the single

00:14:35,839 --> 00:14:39,360
responsibility principle standard string

00:14:37,920 --> 00:14:40,560
does not come just with the functions

00:14:39,360 --> 00:14:42,399
that vector provides

00:14:40,560 --> 00:14:43,600
but it comes with a myriad of another

00:14:42,399 --> 00:14:46,160
additional functions

00:14:43,600 --> 00:14:47,839
set of additional functions that can

00:14:46,160 --> 00:14:48,800
virtually do anything to a string so

00:14:47,839 --> 00:14:51,040
there is find

00:14:48,800 --> 00:14:52,959
functions there is replace functions

00:14:51,040 --> 00:14:55,680
there is substring functions

00:14:52,959 --> 00:14:56,959
a lot of functions that actually could

00:14:55,680 --> 00:15:00,320
be represented

00:14:56,959 --> 00:15:02,079
differently and today we know they are

00:15:00,320 --> 00:15:03,920
historically string is just older than

00:15:02,079 --> 00:15:05,279
standard vector it was not part of the

00:15:03,920 --> 00:15:07,760
stl initially

00:15:05,279 --> 00:15:08,800
so string is the counter example of what

00:15:07,760 --> 00:15:11,199
we should do

00:15:08,800 --> 00:15:13,120
vector is the example of what we should

00:15:11,199 --> 00:15:14,639
do today

00:15:13,120 --> 00:15:16,399
but of course the single responsibility

00:15:14,639 --> 00:15:19,279
principle also uh

00:15:16,399 --> 00:15:20,639
is applicable to functions themselves so

00:15:19,279 --> 00:15:22,800
imagine for instance

00:15:20,639 --> 00:15:23,680
this withdraw money function that is

00:15:22,800 --> 00:15:26,959
implemented as

00:15:23,680 --> 00:15:28,320
a member function of bank account so if

00:15:26,959 --> 00:15:30,720
you want to withdraw money

00:15:28,320 --> 00:15:32,399
then first of all you should verify the

00:15:30,720 --> 00:15:34,399
excess of a given user

00:15:32,399 --> 00:15:36,320
is this user actually allowed to

00:15:34,399 --> 00:15:38,160
withdraw money from this account

00:15:36,320 --> 00:15:40,639
then probably you have to verify the

00:15:38,160 --> 00:15:41,920
balance in the account and of course

00:15:40,639 --> 00:15:45,199
update the amount

00:15:41,920 --> 00:15:48,320
accordingly if this function

00:15:45,199 --> 00:15:51,759
would be implementing all of these

00:15:48,320 --> 00:15:53,120
aspects these orthogonal aspects itself

00:15:51,759 --> 00:15:55,279
it would clearly violate the same

00:15:53,120 --> 00:15:57,360
responsibility principle it would be

00:15:55,279 --> 00:15:59,839
very very hard to deal with all of these

00:15:57,360 --> 00:16:01,759
aspects in just a single function

00:15:59,839 --> 00:16:03,440
not a good idea and also of course i

00:16:01,759 --> 00:16:06,560
would have to change this function for

00:16:03,440 --> 00:16:09,600
many many different reasons

00:16:06,560 --> 00:16:10,480
if however this function would just call

00:16:09,600 --> 00:16:13,839
other functions

00:16:10,480 --> 00:16:14,959
so forward requests to something like

00:16:13,839 --> 00:16:17,680
verify access

00:16:14,959 --> 00:16:18,639
verify balance and update balance this

00:16:17,680 --> 00:16:20,079
actually would

00:16:18,639 --> 00:16:22,320
follow the single responsibility

00:16:20,079 --> 00:16:23,279
principle and it would give us the

00:16:22,320 --> 00:16:26,320
opportunity

00:16:23,279 --> 00:16:28,000
to separate even more verify access does

00:16:26,320 --> 00:16:29,199
not have to be a function in this

00:16:28,000 --> 00:16:31,279
particular class

00:16:29,199 --> 00:16:33,759
it is a completely orthogonal aspect in

00:16:31,279 --> 00:16:35,360
itself so perhaps a different class or a

00:16:33,759 --> 00:16:37,839
completely different module would be

00:16:35,360 --> 00:16:37,839
even better

00:16:38,079 --> 00:16:43,519
so this function does one thing brings

00:16:41,279 --> 00:16:45,199
together all of these three aspects but

00:16:43,519 --> 00:16:47,839
it's a very very

00:16:45,199 --> 00:16:48,480
hard argument to make so primarily think

00:16:47,839 --> 00:16:52,240
about

00:16:48,480 --> 00:16:54,320
changing when would this function change

00:16:52,240 --> 00:16:56,079
i would argue it would change if the

00:16:54,320 --> 00:16:56,959
general algorithm how to withdraw money

00:16:56,079 --> 00:17:00,000
changes

00:16:56,959 --> 00:17:01,360
and for that reason it does one thing so

00:17:00,000 --> 00:17:04,000
as a takeaway

00:17:01,360 --> 00:17:06,160
prefer cohesive software entities

00:17:04,000 --> 00:17:07,120
everything that does not strictly belong

00:17:06,160 --> 00:17:09,919
together

00:17:07,120 --> 00:17:12,319
should be separated that ultimately is

00:17:09,919 --> 00:17:14,959
the single responsibility principle

00:17:12,319 --> 00:17:16,000
i know it is hard to apply in in

00:17:14,959 --> 00:17:18,000
practice

00:17:16,000 --> 00:17:19,280
and it's also pretty hard to reason

00:17:18,000 --> 00:17:21,919
about things

00:17:19,280 --> 00:17:22,400
but my experience is if you face a

00:17:21,919 --> 00:17:24,959
problem

00:17:22,400 --> 00:17:25,679
in changing things then very very often

00:17:24,959 --> 00:17:29,200
srp

00:17:25,679 --> 00:17:32,799
is indeed violated in some regard

00:17:29,200 --> 00:17:34,799
and it helps to separate concerns

00:17:32,799 --> 00:17:36,960
so of course i'm very happy to answer

00:17:34,799 --> 00:17:38,799
questions my suggestion is that you just

00:17:36,960 --> 00:17:41,360
post them in the q a section

00:17:38,799 --> 00:17:42,960
and i'll try to answer as many questions

00:17:41,360 --> 00:17:45,280
as possible in the end

00:17:42,960 --> 00:17:46,880
that would probably work pretty well

00:17:45,280 --> 00:17:48,240
please note the slide numbers this would

00:17:46,880 --> 00:17:52,559
definitely help to

00:17:48,240 --> 00:17:54,000
go to specific back to specific slides

00:17:52,559 --> 00:17:55,760
all right after having handled the

00:17:54,000 --> 00:17:57,440
single responsibility principle let's

00:17:55,760 --> 00:18:00,799
talk about the second one

00:17:57,440 --> 00:18:03,039
the open closed principle that name

00:18:00,799 --> 00:18:05,120
unfortunately does not give away a lot

00:18:03,039 --> 00:18:06,720
but still it can be intuitively

00:18:05,120 --> 00:18:09,919
explained

00:18:06,720 --> 00:18:13,039
so in 1988 bertrand meyer argued that

00:18:09,919 --> 00:18:14,400
software artifacts classes modules

00:18:13,039 --> 00:18:17,600
functions etc

00:18:14,400 --> 00:18:20,880
should be open for extension but

00:18:17,600 --> 00:18:23,679
closed for modification

00:18:20,880 --> 00:18:24,240
so what he has in mind is that at any

00:18:23,679 --> 00:18:27,200
point

00:18:24,240 --> 00:18:29,440
you should be able to extend software to

00:18:27,200 --> 00:18:31,679
add new functionality

00:18:29,440 --> 00:18:33,840
but at the time you're doing this you

00:18:31,679 --> 00:18:35,520
should not have to change existing

00:18:33,840 --> 00:18:38,000
software

00:18:35,520 --> 00:18:38,559
so in a perfect sense you just write new

00:18:38,000 --> 00:18:41,679
code

00:18:38,559 --> 00:18:44,240
and don't have to touch old code let's

00:18:41,679 --> 00:18:46,080
take a look at a slightly longer example

00:18:44,240 --> 00:18:48,559
this time we truly want to draw

00:18:46,080 --> 00:18:50,720
different kinds of shapes

00:18:48,559 --> 00:18:52,000
and i start with a procedural approach

00:18:50,720 --> 00:18:52,640
something that you definitely have seen

00:18:52,000 --> 00:18:54,400
before

00:18:52,640 --> 00:18:56,240
something that reminds you a little bit

00:18:54,400 --> 00:18:58,720
about good old c programming

00:18:56,240 --> 00:19:00,320
so in other words i start with a good

00:18:58,720 --> 00:19:02,480
old enumeration type

00:19:00,320 --> 00:19:04,080
it's called shape type and at this point

00:19:02,480 --> 00:19:04,960
it tells us that there are circles and

00:19:04,080 --> 00:19:07,039
squares

00:19:04,960 --> 00:19:08,080
apparently there's only these two but of

00:19:07,039 --> 00:19:09,919
course

00:19:08,080 --> 00:19:11,919
we will later think ahead and try to add

00:19:09,919 --> 00:19:15,039
new things

00:19:11,919 --> 00:19:17,120
then there is a base class called shape

00:19:15,039 --> 00:19:19,679
the curious thing about this shape base

00:19:17,120 --> 00:19:21,120
class and indeed is a base class as a

00:19:19,679 --> 00:19:23,600
virtual instructor

00:19:21,120 --> 00:19:24,400
is that it in the constructor takes one

00:19:23,600 --> 00:19:27,840
of these

00:19:24,400 --> 00:19:28,880
enumerators and stores it as a data

00:19:27,840 --> 00:19:31,039
member

00:19:28,880 --> 00:19:32,320
so in other words this shape remembers

00:19:31,039 --> 00:19:35,679
what it truly is

00:19:32,320 --> 00:19:37,840
a circle or a square

00:19:35,679 --> 00:19:39,600
and this is for instance used to define

00:19:37,840 --> 00:19:42,559
a circle

00:19:39,600 --> 00:19:43,120
the circle class public derives from

00:19:42,559 --> 00:19:45,200
shape

00:19:43,120 --> 00:19:47,039
and for that reason of course has to

00:19:45,200 --> 00:19:50,160
call the constructor of shape

00:19:47,039 --> 00:19:52,240
by initializing this shape well

00:19:50,160 --> 00:19:53,280
it's a circle so i should use the

00:19:52,240 --> 00:19:56,480
circular numerator

00:19:53,280 --> 00:19:58,960
i should remember that i'm a circle

00:19:56,480 --> 00:20:00,160
so it has a radius of course a couple of

00:19:58,960 --> 00:20:02,720
other data members as

00:20:00,160 --> 00:20:04,240
we've argued before a couple of getters

00:20:02,720 --> 00:20:06,559
also

00:20:04,240 --> 00:20:07,679
and additionally it has the necessary

00:20:06,559 --> 00:20:10,320
functionality

00:20:07,679 --> 00:20:11,520
so i can translate circles i can rotate

00:20:10,320 --> 00:20:15,120
them

00:20:11,520 --> 00:20:18,080
and of course i can also draw circles

00:20:15,120 --> 00:20:20,799
note that i'm actually now choosing the

00:20:18,080 --> 00:20:22,720
free function approach so draw is no

00:20:20,799 --> 00:20:25,520
longer part of the circle

00:20:22,720 --> 00:20:29,440
it's extracted in order not to couple

00:20:25,520 --> 00:20:31,919
the drawing aspect strongly to a circle

00:20:29,440 --> 00:20:34,880
so then i mentioned the brother of

00:20:31,919 --> 00:20:37,120
circle before square

00:20:34,880 --> 00:20:38,960
square is also shape but the primary

00:20:37,120 --> 00:20:41,440
difference is that it initializes the

00:20:38,960 --> 00:20:44,000
base class with the square innovator

00:20:41,440 --> 00:20:45,600
so the square of course remembers that

00:20:44,000 --> 00:20:47,520
it is a square

00:20:45,600 --> 00:20:49,280
else it's probably exactly the same

00:20:47,520 --> 00:20:51,679
thing pretty much

00:20:49,280 --> 00:20:53,600
a copy and paste uh issue but it also

00:20:51,679 --> 00:20:56,240
comes with a set of functions that deals

00:20:53,600 --> 00:20:56,240
with squares

00:20:56,799 --> 00:20:59,919
now i for instance want not just to draw

00:20:59,120 --> 00:21:02,080
single

00:20:59,919 --> 00:21:03,360
shapes i would like to draw a whole

00:21:02,080 --> 00:21:05,679
bunch of shapes

00:21:03,360 --> 00:21:07,919
for instance i would like to draw all

00:21:05,679 --> 00:21:09,760
the shapes that are part of a vector

00:21:07,919 --> 00:21:12,080
so as an argument i get a vector of

00:21:09,760 --> 00:21:14,559
shape pointers

00:21:12,080 --> 00:21:15,200
and i want to draw all of them so first

00:21:14,559 --> 00:21:17,200
of all

00:21:15,200 --> 00:21:19,360
of course i'm traversing all these

00:21:17,200 --> 00:21:22,080
shapes

00:21:19,360 --> 00:21:22,799
and now i have to ask what they truly

00:21:22,080 --> 00:21:25,039
are

00:21:22,799 --> 00:21:27,120
so it's just a shape pointer i have to

00:21:25,039 --> 00:21:29,280
figure out what it truly is

00:21:27,120 --> 00:21:31,760
so i'm asking for the type for the

00:21:29,280 --> 00:21:35,120
numerator and i switch

00:21:31,760 --> 00:21:35,600
is it a circle well if it is a circle

00:21:35,120 --> 00:21:38,640
then

00:21:35,600 --> 00:21:40,880
i have to cast to circle pointer

00:21:38,640 --> 00:21:41,679
and call the according draw function

00:21:40,880 --> 00:21:44,240
else

00:21:41,679 --> 00:21:45,440
if it is a square then i cast to square

00:21:44,240 --> 00:21:47,200
pointer

00:21:45,440 --> 00:21:49,600
and of course call the according draw

00:21:47,200 --> 00:21:52,799
function

00:21:49,600 --> 00:21:55,679
this works this is easily proven by just

00:21:52,799 --> 00:21:56,400
creating a couple of shapes so a circle

00:21:55,679 --> 00:21:59,200
a square

00:21:56,400 --> 00:22:01,039
and a second circle pushing them into a

00:21:59,200 --> 00:22:03,520
vector of shape pointers

00:22:01,039 --> 00:22:06,880
and drawing them all it indeed works i

00:22:03,520 --> 00:22:06,880
see something on the screen

00:22:07,280 --> 00:22:13,440
however so first of all i go back

00:22:10,720 --> 00:22:15,919
to these translate rotate and draw

00:22:13,440 --> 00:22:15,919
functions

00:22:16,000 --> 00:22:20,240
at this point you might be thinking oh

00:22:17,600 --> 00:22:22,320
my this is all this is so bad

00:22:20,240 --> 00:22:23,600
there is one aspect about this code that

00:22:22,320 --> 00:22:27,120
is actually positive

00:22:23,600 --> 00:22:28,720
and this is very interesting this code

00:22:27,120 --> 00:22:31,440
actually fulfills the open close

00:22:28,720 --> 00:22:34,080
principle in terms of functions

00:22:31,440 --> 00:22:35,600
i can add new operations if i just

00:22:34,080 --> 00:22:37,120
follow the example of adding three

00:22:35,600 --> 00:22:39,919
functions

00:22:37,120 --> 00:22:40,960
nobody can hinder me to write according

00:22:39,919 --> 00:22:43,120
through functions

00:22:40,960 --> 00:22:45,039
function and of course even third-party

00:22:43,120 --> 00:22:47,120
people yeah

00:22:45,039 --> 00:22:49,360
people that use this as a library can

00:22:47,120 --> 00:22:50,480
add new functionality by introducing new

00:22:49,360 --> 00:22:52,320
free function

00:22:50,480 --> 00:22:54,480
and since this is chosen by this library

00:22:52,320 --> 00:22:55,440
as well it feels kind of natural and

00:22:54,480 --> 00:22:59,440
intuitive

00:22:55,440 --> 00:23:02,240
in this regard it actually fulfills ocp

00:22:59,440 --> 00:23:03,840
but okay i should mention that i talked

00:23:02,240 --> 00:23:07,039
about this particular aspect

00:23:03,840 --> 00:23:09,840
in a talk um at cppcon 2017

00:23:07,039 --> 00:23:11,360
talk called freer functions it was

00:23:09,840 --> 00:23:13,360
primarily focused on explaining that

00:23:11,360 --> 00:23:16,080
free functions have a design

00:23:13,360 --> 00:23:17,360
advantage in many many aspects the open

00:23:16,080 --> 00:23:21,120
close principle was

00:23:17,360 --> 00:23:22,480
just one of them however of course

00:23:21,120 --> 00:23:25,360
and this is what you would complain

00:23:22,480 --> 00:23:28,640
about this idea this design

00:23:25,360 --> 00:23:30,320
fails if you want to add new types

00:23:28,640 --> 00:23:31,919
so just as a thought experience let's

00:23:30,320 --> 00:23:35,039
add a rectangle

00:23:31,919 --> 00:23:38,240
so i extend the uh the enumeration

00:23:35,039 --> 00:23:41,440
add a new enumerator

00:23:38,240 --> 00:23:44,480
and this change is visible for instance

00:23:41,440 --> 00:23:46,080
in circle because circle knows about

00:23:44,480 --> 00:23:49,200
this enumeration

00:23:46,080 --> 00:23:50,960
it is also visible in square and for

00:23:49,200 --> 00:23:52,240
that reason circle and square both have

00:23:50,960 --> 00:23:54,000
to recompile

00:23:52,240 --> 00:23:55,360
things may change yeah the underlying

00:23:54,000 --> 00:24:00,000
size of uh that they

00:23:55,360 --> 00:24:04,159
remember might change positive possibly

00:24:00,000 --> 00:24:05,200
and of course i have to add a new case

00:24:04,159 --> 00:24:06,960
statement

00:24:05,200 --> 00:24:08,240
the case statement itself is actually

00:24:06,960 --> 00:24:10,400
not a problem

00:24:08,240 --> 00:24:11,840
it's pretty easy to put into this code

00:24:10,400 --> 00:24:13,679
to get it right

00:24:11,840 --> 00:24:16,080
suddenly i can draw rectangles that's

00:24:13,679 --> 00:24:19,360
fine the bigger issue

00:24:16,080 --> 00:24:21,679
is that everywhere where i

00:24:19,360 --> 00:24:22,480
switch based on the type in all the

00:24:21,679 --> 00:24:25,200
places where

00:24:22,480 --> 00:24:27,120
i have a switch statement and if else if

00:24:25,200 --> 00:24:30,159
cascade or anything similar

00:24:27,120 --> 00:24:32,080
i now have to change code

00:24:30,159 --> 00:24:33,520
and in the bigger framework this may

00:24:32,080 --> 00:24:37,520
actually be

00:24:33,520 --> 00:24:40,159
dozens or even hundreds of places

00:24:37,520 --> 00:24:41,120
and how do i find all of these places

00:24:40,159 --> 00:24:43,440
how do i

00:24:41,120 --> 00:24:45,120
actually get a guarantee or do i get a

00:24:43,440 --> 00:24:47,120
guarantee that i found all the places

00:24:45,120 --> 00:24:50,159
that i need to change

00:24:47,120 --> 00:24:51,840
probably no and so this is a nightmare

00:24:50,159 --> 00:24:53,919
situation a situation that

00:24:51,840 --> 00:24:56,000
really makes the difference between

00:24:53,919 --> 00:25:00,000
adding things easily

00:24:56,000 --> 00:25:02,799
and very very difficult so scott myers

00:25:00,000 --> 00:25:04,640
said about this that this kind of type

00:25:02,799 --> 00:25:05,360
based programming has a long history in

00:25:04,640 --> 00:25:07,120
c

00:25:05,360 --> 00:25:08,880
and one of the things we know about it

00:25:07,120 --> 00:25:09,679
is that yields programs that are

00:25:08,880 --> 00:25:12,799
essentially

00:25:09,679 --> 00:25:15,520
unmaintainable so this

00:25:12,799 --> 00:25:18,559
in terms of adding four adding types is

00:25:15,520 --> 00:25:21,360
not a particularly good design

00:25:18,559 --> 00:25:22,799
and of course you're thinking why why

00:25:21,360 --> 00:25:25,200
don't we add

00:25:22,799 --> 00:25:26,320
yes of course a couple of virtual

00:25:25,200 --> 00:25:29,440
functions

00:25:26,320 --> 00:25:31,600
so if you redesign this entire thing and

00:25:29,440 --> 00:25:34,320
use an object-oriented approach

00:25:31,600 --> 00:25:36,720
we would define a base class that has a

00:25:34,320 --> 00:25:38,880
couple of virtual functions instead

00:25:36,720 --> 00:25:40,960
no enumeration anymore no data member

00:25:38,880 --> 00:25:41,520
anymore this now is a true interface

00:25:40,960 --> 00:25:43,760
class

00:25:41,520 --> 00:25:44,559
protocol class in the sense that it only

00:25:43,760 --> 00:25:46,480
has

00:25:44,559 --> 00:25:48,000
virtual functions so the structure and a

00:25:46,480 --> 00:25:50,000
virtual translate rotate and draw

00:25:48,000 --> 00:25:51,760
function

00:25:50,000 --> 00:25:53,679
everything that rise from this class now

00:25:51,760 --> 00:25:56,400
has to implement these functions

00:25:53,679 --> 00:25:58,640
so for instance circle there's no need

00:25:56,400 --> 00:26:01,279
to initialize the base class anymore

00:25:58,640 --> 00:26:01,760
initialization required but of course i

00:26:01,279 --> 00:26:04,559
now

00:26:01,760 --> 00:26:06,880
have to implement these functions and

00:26:04,559 --> 00:26:07,919
the same is true for every class so also

00:26:06,880 --> 00:26:10,480
for square

00:26:07,919 --> 00:26:12,480
every class arriving from shape i also

00:26:10,480 --> 00:26:15,039
have to implement these functions from

00:26:12,480 --> 00:26:16,400
for square of course this is the

00:26:15,039 --> 00:26:18,080
functions that before

00:26:16,400 --> 00:26:21,919
i'd implemented the three functions they

00:26:18,080 --> 00:26:21,919
have just moved into the class

00:26:22,720 --> 00:26:25,840
the draw function now suddenly becomes

00:26:24,720 --> 00:26:28,799
something very

00:26:25,840 --> 00:26:30,000
very easy very easy to change very easy

00:26:28,799 --> 00:26:32,880
to adapt

00:26:30,000 --> 00:26:35,120
in fact i probably will never go back

00:26:32,880 --> 00:26:36,799
and change or adapt it

00:26:35,120 --> 00:26:38,480
because this function now very very

00:26:36,799 --> 00:26:40,159
nicely fulfills this open class

00:26:38,480 --> 00:26:42,400
principle with regard to types

00:26:40,159 --> 00:26:43,440
it is completely oblivious of any kind

00:26:42,400 --> 00:26:46,240
of shape

00:26:43,440 --> 00:26:48,559
type no concrete type anything can be

00:26:46,240 --> 00:26:50,159
drawn

00:26:48,559 --> 00:26:51,919
and this still works with exactly the

00:26:50,159 --> 00:26:54,159
same main function as before

00:26:51,919 --> 00:26:55,200
so still create a circle a square in the

00:26:54,159 --> 00:27:00,000
second circle

00:26:55,200 --> 00:27:00,000
and we'll just draw the thing as before

00:27:01,679 --> 00:27:05,200
so the decisive thing is that we have

00:27:03,600 --> 00:27:08,159
now switched to virtual functions

00:27:05,200 --> 00:27:10,320
this makes it easy to add new types new

00:27:08,159 --> 00:27:11,679
types are simply added to the code i do

00:27:10,320 --> 00:27:14,720
not have to go back

00:27:11,679 --> 00:27:16,799
and change other pieces of code

00:27:14,720 --> 00:27:18,159
however if you want to watch closely

00:27:16,799 --> 00:27:21,520
then you do realize

00:27:18,159 --> 00:27:23,520
that i have another problem now

00:27:21,520 --> 00:27:25,679
i'm back to having the draw function

00:27:23,520 --> 00:27:27,360
inside the shapes

00:27:25,679 --> 00:27:29,360
but that of course i'm coupling the

00:27:27,360 --> 00:27:32,799
implementation details of drawing

00:27:29,360 --> 00:27:34,480
and of course by that i actually do not

00:27:32,799 --> 00:27:37,520
no longer adhere to their single

00:27:34,480 --> 00:27:39,679
responsibility principle

00:27:37,520 --> 00:27:42,240
so if you have not seen this problem

00:27:39,679 --> 00:27:45,279
before if you have not seen this

00:27:42,240 --> 00:27:46,640
contradiction between srp and ocp then

00:27:45,279 --> 00:27:48,480
you have not been involved in a

00:27:46,640 --> 00:27:50,480
discussion that is currently ongoing

00:27:48,480 --> 00:27:52,559
is this truly the right approach for

00:27:50,480 --> 00:27:55,360
general purpose in

00:27:52,559 --> 00:27:57,200
programming so indeed in the phil in the

00:27:55,360 --> 00:28:00,640
community there is a discussion of

00:27:57,200 --> 00:28:03,600
whether we can do things better

00:28:00,640 --> 00:28:05,039
i talked about this in detail at a talk

00:28:03,600 --> 00:28:07,279
in

00:28:05,039 --> 00:28:09,760
bucharest in february the talk was

00:28:07,279 --> 00:28:13,039
called embrace no paradigm programming

00:28:09,760 --> 00:28:15,120
in this talk i compared seven

00:28:13,039 --> 00:28:18,000
and yes in 60 minutes seven different

00:28:15,120 --> 00:28:19,679
approaches to drawing shapes

00:28:18,000 --> 00:28:21,440
and of course i compared the two

00:28:19,679 --> 00:28:22,399
solutions that we've seen for so far but

00:28:21,440 --> 00:28:25,600
also

00:28:22,399 --> 00:28:28,240
modern um c plus uh patterns

00:28:25,600 --> 00:28:31,279
like for instance variant approaches

00:28:28,240 --> 00:28:33,600
type erased approaches etc

00:28:31,279 --> 00:28:35,520
the conclusion is indeed that the modern

00:28:33,600 --> 00:28:38,240
approaches are better

00:28:35,520 --> 00:28:40,240
and one of the takeaways for you is

00:28:38,240 --> 00:28:41,279
indeed i have to choose in dynamic

00:28:40,240 --> 00:28:44,720
memory

00:28:41,279 --> 00:28:46,960
indian dynamic polymorphism between the

00:28:44,720 --> 00:28:49,679
two different versions or

00:28:46,960 --> 00:28:50,640
facets of ocp adding operations or

00:28:49,679 --> 00:28:52,960
adding types

00:28:50,640 --> 00:28:53,919
you will probably as long as you want to

00:28:52,960 --> 00:28:56,960
be dynamic

00:28:53,919 --> 00:28:58,000
not achieve both

00:28:56,960 --> 00:29:00,320
if this is something that you're

00:28:58,000 --> 00:29:02,159
interested in i recommend a talk uh

00:29:00,320 --> 00:29:03,600
one of the first talks on wednesday

00:29:02,159 --> 00:29:05,600
given by cybrant

00:29:03,600 --> 00:29:07,279
dynamic polymorphism with code injection

00:29:05,600 --> 00:29:09,679
and meta classes

00:29:07,279 --> 00:29:12,240
this code will explain why we are to

00:29:09,679 --> 00:29:14,960
some extent moving away from these

00:29:12,240 --> 00:29:15,360
virtual functions how we can actually

00:29:14,960 --> 00:29:19,039
make

00:29:15,360 --> 00:29:23,279
extending things easier yeah how we can

00:29:19,039 --> 00:29:23,279
bring srp and ocp together

00:29:24,159 --> 00:29:27,919
however i should also show at least

00:29:26,320 --> 00:29:28,640
briefly that the open close principle

00:29:27,919 --> 00:29:30,799
can of course

00:29:28,640 --> 00:29:33,760
also be applied to functions not just

00:29:30,799 --> 00:29:35,760
classes or class hierarchies

00:29:33,760 --> 00:29:37,120
i have chosen the copy function function

00:29:35,760 --> 00:29:39,360
from the sdl because

00:29:37,120 --> 00:29:40,880
copy is actually very very great in

00:29:39,360 --> 00:29:43,360
terms of ocp

00:29:40,880 --> 00:29:44,880
so the copy function works for all

00:29:43,360 --> 00:29:47,440
copyable types

00:29:44,880 --> 00:29:49,200
it works for integers strings it works

00:29:47,440 --> 00:29:51,600
for you types and it also works for the

00:29:49,200 --> 00:29:54,799
types that you're writing tomorrow

00:29:51,600 --> 00:29:56,320
it works because it basically provides

00:29:54,799 --> 00:29:59,520
you with a couple of

00:29:56,320 --> 00:30:01,279
concepts named template parameters

00:29:59,520 --> 00:30:04,880
and everything that adheres to these

00:30:01,279 --> 00:30:04,880
concepts just works

00:30:05,520 --> 00:30:09,279
and i do not have to adapt this function

00:30:07,600 --> 00:30:12,080
for new types

00:30:09,279 --> 00:30:13,520
no as long as the types provide all the

00:30:12,080 --> 00:30:15,600
necessary operations

00:30:13,520 --> 00:30:16,720
this function is actually closed for any

00:30:15,600 --> 00:30:19,919
kind of

00:30:16,720 --> 00:30:22,159
changes for any kind of extension

00:30:19,919 --> 00:30:25,600
this is a good design in general so this

00:30:22,159 --> 00:30:28,480
works uh pretty pretty well

00:30:25,600 --> 00:30:28,960
so the takeaway is that you should

00:30:28,480 --> 00:30:30,559
prefer

00:30:28,960 --> 00:30:32,880
software design that allows the addition

00:30:30,559 --> 00:30:35,360
of types or operations

00:30:32,880 --> 00:30:37,120
without the need to modify existing code

00:30:35,360 --> 00:30:37,679
because until that makes your life truly

00:30:37,120 --> 00:30:40,960
easy

00:30:37,679 --> 00:30:42,159
only that will in the long run allow you

00:30:40,960 --> 00:30:45,919
to

00:30:42,159 --> 00:30:45,919
maintain the code for a long period

00:30:46,720 --> 00:30:52,159
all right so again if you have questions

00:30:50,240 --> 00:30:56,000
please post them i will try to answer as

00:30:52,159 --> 00:30:56,000
many as possible in the end

00:30:56,640 --> 00:31:02,799
which brings us to the third principle

00:31:00,080 --> 00:31:04,720
the lisk of substitution principle

00:31:02,799 --> 00:31:06,519
the lisk of substitution principle as

00:31:04,720 --> 00:31:09,039
the name suggests is about

00:31:06,519 --> 00:31:11,919
substitutability

00:31:09,039 --> 00:31:13,840
so in order to explain it i first of all

00:31:11,919 --> 00:31:16,880
can show you the original

00:31:13,840 --> 00:31:17,679
statement of barbara liskov what is

00:31:16,880 --> 00:31:19,080
wanted here

00:31:17,679 --> 00:31:21,760
is something like the following

00:31:19,080 --> 00:31:25,519
substitution property

00:31:21,760 --> 00:31:29,200
if for each object or one of type s

00:31:25,519 --> 00:31:32,559
there is an object o2 of type t

00:31:29,200 --> 00:31:34,080
such that for all programs p defined in

00:31:32,559 --> 00:31:36,320
terms of t

00:31:34,080 --> 00:31:38,640
the behavior of p is unchanged when o

00:31:36,320 --> 00:31:43,279
one is substituted for row two

00:31:38,640 --> 00:31:46,080
then s is a subtype of t

00:31:43,279 --> 00:31:46,799
so actually this is very very concrete

00:31:46,080 --> 00:31:50,080
and

00:31:46,799 --> 00:31:53,279
very very accurate for a mathematician

00:31:50,080 --> 00:31:55,200
however for all the other people

00:31:53,279 --> 00:31:56,960
a simplified form might be sufficient

00:31:55,200 --> 00:31:59,279
although it's nowhere close to being as

00:31:56,960 --> 00:32:01,120
accurate as the first statement

00:31:59,279 --> 00:32:04,640
the idea is that subtypes must be

00:32:01,120 --> 00:32:04,640
substitutable for the base types

00:32:05,679 --> 00:32:08,799
initially you would think this is only

00:32:07,120 --> 00:32:10,960
for inheritance hierarchies

00:32:08,799 --> 00:32:12,480
i will show you in an example later that

00:32:10,960 --> 00:32:14,399
this is not necessarily

00:32:12,480 --> 00:32:15,519
not necessarily just about inheritance

00:32:14,399 --> 00:32:18,000
hierarchies

00:32:15,519 --> 00:32:18,880
however intuitively it is about

00:32:18,000 --> 00:32:22,640
behavioral

00:32:18,880 --> 00:32:26,080
subtyping this is what we simplified

00:32:22,640 --> 00:32:26,960
called an is a relation behavioral

00:32:26,080 --> 00:32:30,159
subtyping

00:32:26,960 --> 00:32:30,720
means that i have an expectation on some

00:32:30,159 --> 00:32:32,880
type

00:32:30,720 --> 00:32:34,000
and these expectations should be

00:32:32,880 --> 00:32:37,120
fulfilled

00:32:34,000 --> 00:32:39,440
either by some other creed type

00:32:37,120 --> 00:32:40,240
which fulfills some kind of template

00:32:39,440 --> 00:32:43,440
parameter

00:32:40,240 --> 00:32:45,360
or by some driving class that implements

00:32:43,440 --> 00:32:48,559
a base class

00:32:45,360 --> 00:32:50,880
behavioral subtyping includes that

00:32:48,559 --> 00:32:52,559
method arguments are contravariant

00:32:50,880 --> 00:32:57,360
variant

00:32:52,559 --> 00:33:00,080
return types are covariant

00:32:57,360 --> 00:33:01,760
the preconditions cannot be strengthened

00:33:00,080 --> 00:33:05,120
in a subtype

00:33:01,760 --> 00:33:08,080
and post conditions cannot be weakened

00:33:05,120 --> 00:33:11,200
if these hold it actually might work

00:33:08,080 --> 00:33:12,480
pretty well and also there is something

00:33:11,200 --> 00:33:15,039
about invariance

00:33:12,480 --> 00:33:16,880
the invariance of the supertype must be

00:33:15,039 --> 00:33:19,600
preserved in a subtype

00:33:16,880 --> 00:33:22,399
so if i have some expectations important

00:33:19,600 --> 00:33:25,840
expectations on the supertype

00:33:22,399 --> 00:33:25,840
the subtype cannot break them

00:33:26,720 --> 00:33:29,760
so again i have a code example which is

00:33:29,120 --> 00:33:32,399
definitely

00:33:29,760 --> 00:33:34,320
easier to understand than some some

00:33:32,399 --> 00:33:36,320
theory slides

00:33:34,320 --> 00:33:38,320
this is now a very very common

00:33:36,320 --> 00:33:40,559
explanation or common example

00:33:38,320 --> 00:33:41,360
for the risk of substitution principle

00:33:40,559 --> 00:33:44,320
in other words

00:33:41,360 --> 00:33:44,720
you might actually have seen it before

00:33:44,320 --> 00:33:47,760
so

00:33:44,720 --> 00:33:49,679
don't post anything to the chat do not

00:33:47,760 --> 00:33:51,360
give this away

00:33:49,679 --> 00:33:53,600
because everybody who has not seen this

00:33:51,360 --> 00:33:55,519
before should get at least a couple of

00:33:53,600 --> 00:33:57,279
seconds to actually digest the problem

00:33:55,519 --> 00:33:59,200
and think about this

00:33:57,279 --> 00:34:01,360
so the question is which of the

00:33:59,200 --> 00:34:04,480
following two implementations would you

00:34:01,360 --> 00:34:05,039
choose so there's two to choose from and

00:34:04,480 --> 00:34:08,079
both

00:34:05,039 --> 00:34:10,159
implement an inheritance hierarchy i

00:34:08,079 --> 00:34:13,440
admit i stick to shapes

00:34:10,159 --> 00:34:15,040
and so option a is about a square and a

00:34:13,440 --> 00:34:19,599
rectangle

00:34:15,040 --> 00:34:21,679
i start with a class called square

00:34:19,599 --> 00:34:23,280
a square class first of all has a data

00:34:21,679 --> 00:34:26,079
memory called width

00:34:23,280 --> 00:34:28,000
a square has a width and it comes with a

00:34:26,079 --> 00:34:30,159
virtual function that allows me to set

00:34:28,000 --> 00:34:33,440
the width

00:34:30,159 --> 00:34:34,240
additionally i have a virtual git area

00:34:33,440 --> 00:34:36,639
function

00:34:34,240 --> 00:34:37,280
which not surprisingly is implemented as

00:34:36,639 --> 00:34:41,040
return

00:34:37,280 --> 00:34:44,720
width times width so i can actually get

00:34:41,040 --> 00:34:47,520
um the width of a square quite nicely

00:34:44,720 --> 00:34:48,480
there may be more um functions but this

00:34:47,520 --> 00:34:51,760
is the ones

00:34:48,480 --> 00:34:54,320
that are really interesting for us

00:34:51,760 --> 00:34:55,119
this square class now serves as a base

00:34:54,320 --> 00:34:58,400
class for

00:34:55,119 --> 00:34:59,520
a class called rectangle the rectangle

00:34:58,400 --> 00:35:01,680
class

00:34:59,520 --> 00:35:03,599
needs a second data member because a

00:35:01,680 --> 00:35:06,720
rectangle does not just have a width

00:35:03,599 --> 00:35:08,720
it additionally has a height too

00:35:06,720 --> 00:35:10,160
and so in addition it also comes with an

00:35:08,720 --> 00:35:12,320
additional setter

00:35:10,160 --> 00:35:14,079
the set height function set height sets

00:35:12,320 --> 00:35:17,839
the height and of course hit width

00:35:14,079 --> 00:35:17,839
continues to set the width

00:35:18,000 --> 00:35:22,240
the get area function is now not doing

00:35:20,640 --> 00:35:24,240
the right thing anymore

00:35:22,240 --> 00:35:26,480
but it's a virtual function so i cannot

00:35:24,240 --> 00:35:29,359
write it and i'll write it

00:35:26,480 --> 00:35:31,119
as return width times height now it's

00:35:29,359 --> 00:35:34,560
doing the right thing again

00:35:31,119 --> 00:35:34,960
and everything works this rectangle

00:35:34,560 --> 00:35:37,119
class

00:35:34,960 --> 00:35:38,079
this deriving class now extends the

00:35:37,119 --> 00:35:41,359
functionality

00:35:38,079 --> 00:35:45,839
of the base class it adds new behavior

00:35:41,359 --> 00:35:45,839
set height and it adds a new data member

00:35:46,240 --> 00:35:53,520
this is option a on the right hand side

00:35:50,160 --> 00:35:53,839
we have option b which is to some extent

00:35:53,520 --> 00:35:58,320
the

00:35:53,839 --> 00:36:01,520
inverse of this of solution a

00:35:58,320 --> 00:36:03,359
i start with the rectangle class and as

00:36:01,520 --> 00:36:04,960
we've said before a rectangle needs two

00:36:03,359 --> 00:36:07,440
data members with an height

00:36:04,960 --> 00:36:08,320
and for that reason also has two setters

00:36:07,440 --> 00:36:11,599
set width

00:36:08,320 --> 00:36:12,800
and set height it again has a get area

00:36:11,599 --> 00:36:14,960
function

00:36:12,800 --> 00:36:17,359
which of course is implemented as return

00:36:14,960 --> 00:36:19,520
width times height

00:36:17,359 --> 00:36:21,200
again there may be more functions but

00:36:19,520 --> 00:36:23,680
this is what is interesting for our

00:36:21,200 --> 00:36:23,680
purposes

00:36:25,359 --> 00:36:30,160
the square class now implements the

00:36:27,839 --> 00:36:32,560
rectangle class so it publicly drives

00:36:30,160 --> 00:36:35,520
from rectangle

00:36:32,560 --> 00:36:36,000
a square actually only has one side

00:36:35,520 --> 00:36:38,160
length

00:36:36,000 --> 00:36:40,880
which means right now it has a little

00:36:38,160 --> 00:36:43,520
too much it tries to

00:36:40,880 --> 00:36:43,920
restrict the interface of the base class

00:36:43,520 --> 00:36:46,800
by

00:36:43,920 --> 00:36:48,400
implementing overriding both of these

00:36:46,800 --> 00:36:51,760
virtual setters

00:36:48,400 --> 00:36:52,640
set width is implemented to set both

00:36:51,760 --> 00:36:55,599
width and height

00:36:52,640 --> 00:36:56,160
and also set height is implemented in

00:36:55,599 --> 00:36:59,359
setting

00:36:56,160 --> 00:37:01,760
both the width and the height

00:36:59,359 --> 00:37:03,440
so this is how square actually fulfills

00:37:01,760 --> 00:37:05,599
its own invariant

00:37:03,440 --> 00:37:07,680
it only has one side length let's just

00:37:05,599 --> 00:37:10,720
saw it twice

00:37:07,680 --> 00:37:12,240
if i do that if i do it this way then

00:37:10,720 --> 00:37:13,839
arm get area actually does the right

00:37:12,240 --> 00:37:16,160
thing width and height are always equal

00:37:13,839 --> 00:37:18,560
circuit area will return the right area

00:37:16,160 --> 00:37:20,880
i can optionally override it i don't

00:37:18,560 --> 00:37:20,880
have to

00:37:21,200 --> 00:37:27,200
so this is what i usually ask people in

00:37:24,480 --> 00:37:29,119
my training classes and i make them

00:37:27,200 --> 00:37:31,839
choose which of these two

00:37:29,119 --> 00:37:33,760
is the right choice which one they would

00:37:31,839 --> 00:37:36,400
choose

00:37:33,760 --> 00:37:37,760
and a surprising large number of people

00:37:36,400 --> 00:37:39,680
choose option b

00:37:37,760 --> 00:37:40,960
i would argue it's approximately 70

00:37:39,680 --> 00:37:42,720
percent

00:37:40,960 --> 00:37:44,240
there is always a couple of people that

00:37:42,720 --> 00:37:46,800
choose option a

00:37:44,240 --> 00:37:47,760
because they actually fear that option b

00:37:46,800 --> 00:37:50,320
is a trap

00:37:47,760 --> 00:37:51,920
something is not right also they don't

00:37:50,320 --> 00:37:53,119
like the fact that the square has two

00:37:51,920 --> 00:37:56,000
data members

00:37:53,119 --> 00:37:56,560
but the primary the largest number of

00:37:56,000 --> 00:38:00,880
students

00:37:56,560 --> 00:38:03,280
choose option b the surprise is big

00:38:00,880 --> 00:38:05,839
if i explain them then option b doesn't

00:38:03,280 --> 00:38:05,839
work

00:38:06,000 --> 00:38:10,000
it doesn't work because actually it does

00:38:08,160 --> 00:38:11,680
not fulfill this lisk of substitution

00:38:10,000 --> 00:38:15,280
principle

00:38:11,680 --> 00:38:17,200
a square has to change both data members

00:38:15,280 --> 00:38:18,480
so if i call set height it has to change

00:38:17,200 --> 00:38:21,359
both

00:38:18,480 --> 00:38:21,760
the surprise is big for rectangle if you

00:38:21,359 --> 00:38:24,240
change

00:38:21,760 --> 00:38:26,160
one side length call the area function

00:38:24,240 --> 00:38:27,200
and find that the area is not what you

00:38:26,160 --> 00:38:29,440
expected

00:38:27,200 --> 00:38:30,560
now that two data members instead of

00:38:29,440 --> 00:38:32,880
just one

00:38:30,560 --> 00:38:34,880
changed well the expectation in

00:38:32,880 --> 00:38:36,320
rectangle is that i can set the data

00:38:34,880 --> 00:38:38,960
members individually

00:38:36,320 --> 00:38:40,079
which is no longer true in square so

00:38:38,960 --> 00:38:42,800
this square

00:38:40,079 --> 00:38:45,280
does not behave like i would expect of

00:38:42,800 --> 00:38:47,280
this rectangle

00:38:45,280 --> 00:38:48,720
so option b is a bad choice in

00:38:47,280 --> 00:38:50,320
inheritance hierarchy and for that

00:38:48,720 --> 00:38:51,359
reason for a long time was actually

00:38:50,320 --> 00:38:55,040
listed as

00:38:51,359 --> 00:38:56,640
a um a breaking or

00:38:55,040 --> 00:38:59,359
violation of the lisk of substitution

00:38:56,640 --> 00:39:02,560
principle in wikipedia

00:38:59,359 --> 00:39:03,520
however option a is unfortunately in no

00:39:02,560 --> 00:39:06,000
way better

00:39:03,520 --> 00:39:08,480
it is exactly the same problem just with

00:39:06,000 --> 00:39:10,560
a different twist

00:39:08,480 --> 00:39:11,760
in case of a square i expect it has one

00:39:10,560 --> 00:39:13,520
side length

00:39:11,760 --> 00:39:15,839
which no longer is true with the

00:39:13,520 --> 00:39:18,880
rectangle a rectangle certainly has

00:39:15,839 --> 00:39:20,000
two and so again if i set via the base

00:39:18,880 --> 00:39:21,599
class the width

00:39:20,000 --> 00:39:23,040
and call the area function with a

00:39:21,599 --> 00:39:26,839
certain expectation

00:39:23,040 --> 00:39:29,599
it might not hold so both

00:39:26,839 --> 00:39:31,440
versions do not adhere to the lisk of

00:39:29,599 --> 00:39:33,520
substitution principle

00:39:31,440 --> 00:39:35,040
the takeaway is of this is not that

00:39:33,520 --> 00:39:37,280
inheritance generally is broken

00:39:35,040 --> 00:39:39,119
the takeaway is that we are very very

00:39:37,280 --> 00:39:41,359
easily misled

00:39:39,119 --> 00:39:42,560
especially the right version is natural

00:39:41,359 --> 00:39:45,599
and intuitive

00:39:42,560 --> 00:39:47,680
in math naively speaking

00:39:45,599 --> 00:39:49,119
a square has this relationship to

00:39:47,680 --> 00:39:51,359
rectangle

00:39:49,119 --> 00:39:54,240
but in computer science this might not

00:39:51,359 --> 00:39:55,040
be true it depends on the expectations

00:39:54,240 --> 00:39:58,400
in the base type

00:39:55,040 --> 00:40:02,480
it depends on the interface

00:39:58,400 --> 00:40:04,240
so if you inherit from some base type

00:40:02,480 --> 00:40:06,800
and there is expectations

00:40:04,240 --> 00:40:07,839
make absolutely sure that you understand

00:40:06,800 --> 00:40:10,079
the requirements

00:40:07,839 --> 00:40:12,000
that they understand that the type the

00:40:10,079 --> 00:40:13,599
contract on the base type

00:40:12,000 --> 00:40:17,440
that is the one thing that the lisk of

00:40:13,599 --> 00:40:17,440
substitution principle tries to teach us

00:40:17,839 --> 00:40:24,800
exactly the same is true however for

00:40:20,480 --> 00:40:26,480
templates in general i again chose the

00:40:24,800 --> 00:40:28,960
copy function because it

00:40:26,480 --> 00:40:29,920
again serves my purposes it is about the

00:40:28,960 --> 00:40:34,720
two data members

00:40:29,920 --> 00:40:34,720
input and output input it output it

00:40:34,800 --> 00:40:38,800
everything that you pass to the copy

00:40:36,800 --> 00:40:41,359
function should behave like

00:40:38,800 --> 00:40:42,720
an input iterator and output operator

00:40:41,359 --> 00:40:45,839
respectively

00:40:42,720 --> 00:40:48,640
so if you pass anything that does not

00:40:45,839 --> 00:40:51,599
behave as expected so it does not really

00:40:48,640 --> 00:40:54,240
do something reasonable with regard to

00:40:51,599 --> 00:40:55,200
increment or comparison it just doesn't

00:40:54,240 --> 00:40:57,200
work

00:40:55,200 --> 00:40:59,359
also here you have expectations and

00:40:57,200 --> 00:41:01,359
these expectations must be fulfilled

00:40:59,359 --> 00:41:04,000
so also here you can apply the lisk of

00:41:01,359 --> 00:41:06,319
substitution principle

00:41:04,000 --> 00:41:08,319
so copy works if the given input iterate

00:41:06,319 --> 00:41:10,160
adheres to the required concept

00:41:08,319 --> 00:41:12,319
and of course also the output iterator

00:41:10,160 --> 00:41:14,079
adheres to the required output iterator

00:41:12,319 --> 00:41:17,920
concept

00:41:14,079 --> 00:41:21,040
so the takeaway here is make sure

00:41:17,920 --> 00:41:21,839
that inheritance is about behavior not

00:41:21,040 --> 00:41:23,760
about data

00:41:21,839 --> 00:41:25,359
as soon as a virtual function that

00:41:23,760 --> 00:41:29,040
raises expectations

00:41:25,359 --> 00:41:30,640
this is what inheritance truly is about

00:41:29,040 --> 00:41:32,160
make sure that the contract of base

00:41:30,640 --> 00:41:34,319
types is adhered to

00:41:32,160 --> 00:41:35,440
if there are expectations they need to

00:41:34,319 --> 00:41:38,480
be fulfilled

00:41:35,440 --> 00:41:41,440
else the inheritance relationship might

00:41:38,480 --> 00:41:44,319
break in surprising and unexpected

00:41:41,440 --> 00:41:47,520
uh situations and make sure to achieve

00:41:44,319 --> 00:41:50,319
your required concepts in templated code

00:41:47,520 --> 00:41:50,800
that is to some extent the equivalent of

00:41:50,319 --> 00:41:54,079
the

00:41:50,800 --> 00:41:54,079
the base class idea

00:41:55,119 --> 00:42:00,079
all right this was that was the third of

00:41:57,920 --> 00:42:02,880
the solid principles

00:42:00,079 --> 00:42:06,079
the fourth one is called the interface

00:42:02,880 --> 00:42:06,079
segregation principle

00:42:06,480 --> 00:42:10,800
from my own personal point of view this

00:42:08,880 --> 00:42:12,720
is indeed a special case of the first

00:42:10,800 --> 00:42:16,640
one the single responsibility principle

00:42:12,720 --> 00:42:17,200
but a very important case robert martin

00:42:16,640 --> 00:42:19,760
states

00:42:17,200 --> 00:42:23,280
that clients should not force to depend

00:42:19,760 --> 00:42:23,280
on methods that they do not use

00:42:23,520 --> 00:42:29,520
and wikipedia probably even

00:42:26,560 --> 00:42:30,000
uses an easy explanation many kind

00:42:29,520 --> 00:42:32,560
specific

00:42:30,000 --> 00:42:35,599
interfaces are better than one general

00:42:32,560 --> 00:42:35,599
purpose interface

00:42:36,880 --> 00:42:41,520
so i again have an example let's

00:42:39,440 --> 00:42:43,760
remember that we started

00:42:41,520 --> 00:42:46,079
or i should say end it with a shape

00:42:43,760 --> 00:42:49,280
class that had virtual functions

00:42:46,079 --> 00:42:50,319
the big problem now is that circles

00:42:49,280 --> 00:42:52,480
might contain

00:42:50,319 --> 00:42:54,400
implementation details of drawing an

00:42:52,480 --> 00:42:55,760
aspect that might change frequently

00:42:54,400 --> 00:42:57,359
where perhaps even when they have

00:42:55,760 --> 00:42:58,480
several different kinds of

00:42:57,359 --> 00:43:00,720
implementations

00:42:58,480 --> 00:43:02,720
so this probably is not flexible and

00:43:00,720 --> 00:43:04,880
extensible enough

00:43:02,720 --> 00:43:05,920
for that reason i now reach for a design

00:43:04,880 --> 00:43:09,119
pattern

00:43:05,920 --> 00:43:11,280
namely the strategy design pattern

00:43:09,119 --> 00:43:13,040
the strategy design pattern is one of

00:43:11,280 --> 00:43:14,960
the classic design patterns from the

00:43:13,040 --> 00:43:17,040
gang of four book

00:43:14,960 --> 00:43:18,880
this is exactly copied from the book but

00:43:17,040 --> 00:43:19,440
for our purposes i now adapt the name

00:43:18,880 --> 00:43:21,760
such

00:43:19,440 --> 00:43:23,200
that we understand what's going on so on

00:43:21,760 --> 00:43:25,599
the left hand side

00:43:23,200 --> 00:43:27,839
i have the shape hierarchy with a draw

00:43:25,599 --> 00:43:27,839
function

00:43:28,000 --> 00:43:31,280
i want to extract the implementation

00:43:29,599 --> 00:43:33,599
details of draw and i do

00:43:31,280 --> 00:43:36,000
this now by means of introducing another

00:43:33,599 --> 00:43:39,359
hierarchy draw strategy

00:43:36,000 --> 00:43:41,280
shape owns one of these base classes

00:43:39,359 --> 00:43:42,560
and of course this year can have

00:43:41,280 --> 00:43:44,800
multiple different

00:43:42,560 --> 00:43:46,240
kinds of implementation there can be an

00:43:44,800 --> 00:43:48,560
opengl strategy

00:43:46,240 --> 00:43:49,520
a vtk strategy a metal and vulcan

00:43:48,560 --> 00:43:52,800
strategy

00:43:49,520 --> 00:43:55,839
and of course also test strategies this

00:43:52,800 --> 00:43:57,599
is um one of these strategies is usually

00:43:55,839 --> 00:43:58,960
passed to the ship via the constructor

00:43:57,599 --> 00:44:00,800
where via some setters

00:43:58,960 --> 00:44:03,200
this is what we call dependency

00:44:00,800 --> 00:44:06,560
injection this allows me to extract the

00:44:03,200 --> 00:44:08,560
implementation details from shape

00:44:06,560 --> 00:44:10,880
so if i transfer this in code

00:44:08,560 --> 00:44:13,359
intuitively perhaps a little naively

00:44:10,880 --> 00:44:14,000
i'm out might now implement this in this

00:44:13,359 --> 00:44:16,560
form

00:44:14,000 --> 00:44:17,280
i introduce a draw strategy which comes

00:44:16,560 --> 00:44:19,040
with a virtual

00:44:17,280 --> 00:44:21,440
draw function for all the available

00:44:19,040 --> 00:44:24,480
shapes so we had circles and squares

00:44:21,440 --> 00:44:26,720
in these examples

00:44:24,480 --> 00:44:28,240
this is now the base class of the

00:44:26,720 --> 00:44:31,119
strategy design pattern

00:44:28,240 --> 00:44:32,720
and this i can implement this in various

00:44:31,119 --> 00:44:36,400
ways

00:44:32,720 --> 00:44:39,440
shape actually doesn't have to change

00:44:36,400 --> 00:44:41,680
the derived classes change a little bit

00:44:39,440 --> 00:44:43,520
in addition to the other data members

00:44:41,680 --> 00:44:44,960
they now for instance in the constructor

00:44:43,520 --> 00:44:48,240
take a pointer to the straw

00:44:44,960 --> 00:44:50,560
to a draw strategy this straw

00:44:48,240 --> 00:44:51,920
stretchy is first of all moved into the

00:44:50,560 --> 00:44:54,160
data member

00:44:51,920 --> 00:44:54,960
i own the strategy now and whenever

00:44:54,160 --> 00:44:57,760
somebody calls

00:44:54,960 --> 00:44:59,839
draw i simply forward the draw request

00:44:57,760 --> 00:45:01,599
to my draw strategy

00:44:59,839 --> 00:45:03,359
so i no longer have to deal with

00:45:01,599 --> 00:45:05,280
implementation details

00:45:03,359 --> 00:45:07,599
i can forward this request to some other

00:45:05,280 --> 00:45:11,200
implementation

00:45:07,599 --> 00:45:13,040
the idea is sound although of course i

00:45:11,200 --> 00:45:15,040
introduced a second virtual function

00:45:13,040 --> 00:45:16,160
which is something that we should think

00:45:15,040 --> 00:45:18,560
about but

00:45:16,160 --> 00:45:21,280
there is a problem with regard to the

00:45:18,560 --> 00:45:23,280
interface aggregation principle

00:45:21,280 --> 00:45:24,480
for some reason we have the tendency to

00:45:23,280 --> 00:45:27,119
put all things that

00:45:24,480 --> 00:45:29,280
are named similarly together in a class

00:45:27,119 --> 00:45:32,720
so like here i have two draw functions

00:45:29,280 --> 00:45:35,040
i put both of them in the draw strategy

00:45:32,720 --> 00:45:37,200
that is a violation of interface

00:45:35,040 --> 00:45:39,280
aggregation

00:45:37,200 --> 00:45:40,480
think about it what happens if i add

00:45:39,280 --> 00:45:42,960
another draw function

00:45:40,480 --> 00:45:45,599
so for instance a draw function that a

00:45:42,960 --> 00:45:48,480
draw function for a rectangle

00:45:45,599 --> 00:45:49,119
well then both circle and also square on

00:45:48,480 --> 00:45:50,480
all the other

00:45:49,119 --> 00:45:54,079
shapes that already know about the

00:45:50,480 --> 00:45:55,440
strategy would see the change

00:45:54,079 --> 00:45:57,280
and for that reason might have to

00:45:55,440 --> 00:46:00,400
recompile again and

00:45:57,280 --> 00:46:01,920
might have to change again and in other

00:46:00,400 --> 00:46:04,640
words there is coupling

00:46:01,920 --> 00:46:07,359
unfortunate coupling because i put these

00:46:04,640 --> 00:46:09,280
two functions together

00:46:07,359 --> 00:46:10,800
the right solution the solution

00:46:09,280 --> 00:46:11,520
according to the interface segregation

00:46:10,800 --> 00:46:14,400
principle

00:46:11,520 --> 00:46:16,319
is to have a draw strategy for every

00:46:14,400 --> 00:46:19,119
single kind of shape

00:46:16,319 --> 00:46:21,040
so there is probably a circle strategy

00:46:19,119 --> 00:46:23,040
there is a draw square strategy

00:46:21,040 --> 00:46:24,640
with every new shape that i introduce i

00:46:23,040 --> 00:46:28,000
additionally introduce a new

00:46:24,640 --> 00:46:30,480
strategy although this is of course a

00:46:28,000 --> 00:46:32,160
proliferation of the base classes it

00:46:30,480 --> 00:46:34,400
still is exactly the right thing to do

00:46:32,160 --> 00:46:36,240
in order to cut dependencies

00:46:34,400 --> 00:46:37,839
this is pretty important to keep things

00:46:36,240 --> 00:46:40,079
under control and to not

00:46:37,839 --> 00:46:43,839
couple artificially this is truly

00:46:40,079 --> 00:46:43,839
artificial coupling nothing more

00:46:46,000 --> 00:46:51,760
so of course this is just to sum this up

00:46:49,680 --> 00:46:53,760
circle does now get the draw circled

00:46:51,760 --> 00:46:56,240
strategy and stores it accordingly

00:46:53,760 --> 00:46:57,520
and square gets the draw square strategy

00:46:56,240 --> 00:46:59,520
now every shape

00:46:57,520 --> 00:47:02,640
only knows about the strategy that it

00:46:59,520 --> 00:47:02,640
truly needs to know about

00:47:02,880 --> 00:47:07,440
again interface aggregation is not just

00:47:05,359 --> 00:47:08,720
for class hierarchies so it's not just

00:47:07,440 --> 00:47:12,400
for oo programming

00:47:08,720 --> 00:47:14,640
we can also apply this to generic code

00:47:12,400 --> 00:47:16,319
and again it's centered around the

00:47:14,640 --> 00:47:18,720
concepts

00:47:16,319 --> 00:47:20,559
ultimately concepts are the template

00:47:18,720 --> 00:47:23,839
equivalent of base classes

00:47:20,559 --> 00:47:25,520
they are a set of requirements if this

00:47:23,839 --> 00:47:28,559
set of requirements is

00:47:25,520 --> 00:47:30,400
kept at a minimum copy actually follows

00:47:28,559 --> 00:47:31,280
this interface aggregation principle

00:47:30,400 --> 00:47:34,800
also

00:47:31,280 --> 00:47:37,440
so this copy function only requires an

00:47:34,800 --> 00:47:38,800
input iterator and not something that is

00:47:37,440 --> 00:47:41,520
much more

00:47:38,800 --> 00:47:42,960
demanding and it also only requires an

00:47:41,520 --> 00:47:44,720
output iterator

00:47:42,960 --> 00:47:46,880
minimum requirements for this particular

00:47:44,720 --> 00:47:49,839
function and so

00:47:46,880 --> 00:47:51,839
i have minimal requirements uh in total

00:47:49,839 --> 00:47:54,000
this is why copy works together with

00:47:51,839 --> 00:47:58,319
files

00:47:54,000 --> 00:48:00,000
with virtually anything if i would

00:47:58,319 --> 00:48:02,880
just different kinds of iterators i

00:48:00,000 --> 00:48:05,520
might actually restrict the users

00:48:02,880 --> 00:48:08,079
so interface segregation applied to

00:48:05,520 --> 00:48:08,079
concepts

00:48:08,160 --> 00:48:14,640
the takeaway here is that

00:48:12,160 --> 00:48:16,240
make sure interfaces don't induce

00:48:14,640 --> 00:48:18,079
unnecessary dependencies

00:48:16,240 --> 00:48:20,480
make sure that you do not artificially

00:48:18,079 --> 00:48:24,000
couple things together

00:48:20,480 --> 00:48:25,839
it is however to some extent a special

00:48:24,000 --> 00:48:26,720
case of the single responsibility

00:48:25,839 --> 00:48:29,359
principle

00:48:26,720 --> 00:48:30,000
so if you try to adhere to that you

00:48:29,359 --> 00:48:32,880
might

00:48:30,000 --> 00:48:34,559
automatically perhaps accidentally also

00:48:32,880 --> 00:48:35,200
deal with the interface segregation

00:48:34,559 --> 00:48:39,599
principle

00:48:35,200 --> 00:48:41,920
it is a special but important case

00:48:39,599 --> 00:48:42,800
now this was the fourth one of the solid

00:48:41,920 --> 00:48:45,920
principles

00:48:42,800 --> 00:48:48,160
there's only one more to go which

00:48:45,920 --> 00:48:49,359
is unfortunately a little more complex

00:48:48,160 --> 00:48:52,079
and now

00:48:49,359 --> 00:48:54,000
means that we have a little excretion

00:48:52,079 --> 00:48:55,440
into architecture as well

00:48:54,000 --> 00:49:00,000
so the fifth of these principle is

00:48:55,440 --> 00:49:00,000
called dependency inversion principle

00:49:00,400 --> 00:49:05,280
robert martin tried to explain it like

00:49:02,079 --> 00:49:07,839
this the dependency inversion principle

00:49:05,280 --> 00:49:09,760
short dip tells us that the most

00:49:07,839 --> 00:49:12,000
flexible systems are those

00:49:09,760 --> 00:49:14,240
in which source code dependencies refer

00:49:12,000 --> 00:49:18,160
only to abstractions

00:49:14,240 --> 00:49:20,079
not to concretions and you refined the

00:49:18,160 --> 00:49:22,800
statement by

00:49:20,079 --> 00:49:23,839
the following two rules high-level

00:49:22,800 --> 00:49:27,040
modules should

00:49:23,839 --> 00:49:29,599
not depend on low-level modules both

00:49:27,040 --> 00:49:31,359
should depend on abstractions

00:49:29,599 --> 00:49:32,720
and abstractions should not depend on

00:49:31,359 --> 00:49:36,720
details

00:49:32,720 --> 00:49:40,000
details should depend on abstractions

00:49:36,720 --> 00:49:41,839
so this is very abstract in itself so

00:49:40,000 --> 00:49:43,440
allow me to explain by means of an

00:49:41,839 --> 00:49:45,680
example

00:49:43,440 --> 00:49:47,680
so for a long time so for the entire

00:49:45,680 --> 00:49:48,559
time so far we have dealt with drawing

00:49:47,680 --> 00:49:51,839
circles

00:49:48,559 --> 00:49:54,079
now let's try to refactor all the stuff

00:49:51,839 --> 00:49:55,040
drawing is now a completely separate

00:49:54,079 --> 00:49:57,440
separate aspect

00:49:55,040 --> 00:49:59,520
in a different component so in the

00:49:57,440 --> 00:50:02,240
drawing component i deal with drawing

00:49:59,520 --> 00:50:04,079
with the geometry component contains

00:50:02,240 --> 00:50:07,280
circles squares and all the other

00:50:04,079 --> 00:50:07,280
geometric primitives

00:50:08,079 --> 00:50:12,319
i now assume that did you make

00:50:10,400 --> 00:50:14,240
primitives are a little more close to

00:50:12,319 --> 00:50:18,079
the center of my architecture

00:50:14,240 --> 00:50:20,559
so this is why i call this high level

00:50:18,079 --> 00:50:22,240
drawing however is something that is a

00:50:20,559 --> 00:50:24,640
little more

00:50:22,240 --> 00:50:26,000
outside of the center so this is

00:50:24,640 --> 00:50:28,880
something where for instance

00:50:26,000 --> 00:50:29,839
might to introduce um new ways of

00:50:28,880 --> 00:50:32,240
drawing things

00:50:29,839 --> 00:50:35,520
this is why i expect more change so this

00:50:32,240 --> 00:50:35,520
is more low level

00:50:35,599 --> 00:50:39,440
in this setting however things do not

00:50:37,680 --> 00:50:42,480
work well

00:50:39,440 --> 00:50:43,200
circle now directly depends on draw

00:50:42,480 --> 00:50:45,440
circle

00:50:43,200 --> 00:50:47,200
draw circle being the implementation of

00:50:45,440 --> 00:50:50,319
drawing a circle

00:50:47,200 --> 00:50:52,240
if that truly is the case then circle

00:50:50,319 --> 00:50:54,000
might change often

00:50:52,240 --> 00:50:55,280
it might change whenever draw circle

00:50:54,000 --> 00:50:57,200
changes

00:50:55,280 --> 00:50:58,319
that is exactly what i would like to

00:50:57,200 --> 00:51:00,640
avoid

00:50:58,319 --> 00:51:01,680
i do not want to change the high level

00:51:00,640 --> 00:51:03,200
stuff often

00:51:01,680 --> 00:51:06,880
and i definitely do not want it to

00:51:03,200 --> 00:51:10,559
depend on the lower level details

00:51:06,880 --> 00:51:12,800
for that reason it is always

00:51:10,559 --> 00:51:14,240
recommended to introduce some kind of

00:51:12,800 --> 00:51:16,160
abstraction

00:51:14,240 --> 00:51:18,800
and you know do this again in terms of a

00:51:16,160 --> 00:51:18,800
base class

00:51:19,280 --> 00:51:22,480
this has a couple of very positive side

00:51:21,839 --> 00:51:24,720
effects

00:51:22,480 --> 00:51:26,800
first of all i do not depend on the

00:51:24,720 --> 00:51:28,720
implementation details anymore

00:51:26,800 --> 00:51:30,800
second of course now i'm able to

00:51:28,720 --> 00:51:31,839
introduce different kinds of drawing

00:51:30,800 --> 00:51:34,880
easily

00:51:31,839 --> 00:51:38,480
circle only depends on this

00:51:34,880 --> 00:51:40,559
abstraction and indeed i have

00:51:38,480 --> 00:51:41,520
some kind of local inversion of

00:51:40,559 --> 00:51:44,800
dependencies

00:51:41,520 --> 00:51:45,920
because the error the direction of this

00:51:44,800 --> 00:51:49,680
error has

00:51:45,920 --> 00:51:51,760
reversed has been inverted

00:51:49,680 --> 00:51:53,440
unfortunately many explanations of the

00:51:51,760 --> 00:51:55,440
dependency inversion principle stop at

00:51:53,440 --> 00:51:57,839
this point

00:51:55,440 --> 00:51:59,040
right now we did not really fix our

00:51:57,839 --> 00:52:02,160
architecture

00:51:59,040 --> 00:52:06,160
still the high level depends on

00:52:02,160 --> 00:52:08,640
low level details so circle depends

00:52:06,160 --> 00:52:11,119
and i said this explicitly before on

00:52:08,640 --> 00:52:13,040
this interface

00:52:11,119 --> 00:52:15,359
if i really want to have a proper

00:52:13,040 --> 00:52:19,200
architecture if i really want

00:52:15,359 --> 00:52:21,440
to have proper dependencies

00:52:19,200 --> 00:52:22,720
then this is not what really works i

00:52:21,440 --> 00:52:25,520
have to make one more

00:52:22,720 --> 00:52:27,359
very very important and decisive change

00:52:25,520 --> 00:52:30,160
i have to move the interface from the

00:52:27,359 --> 00:52:32,480
right side to the left side

00:52:30,160 --> 00:52:33,680
this may seem like a trivial thing to do

00:52:32,480 --> 00:52:35,839
in the first

00:52:33,680 --> 00:52:36,880
first glance because tractually nothing

00:52:35,839 --> 00:52:38,800
changed

00:52:36,880 --> 00:52:40,800
but architecturally this is a

00:52:38,800 --> 00:52:42,880
fundamental change

00:52:40,800 --> 00:52:44,400
i no longer have an error pointing from

00:52:42,880 --> 00:52:46,640
light left to right

00:52:44,400 --> 00:52:47,520
now the arrow really points from right

00:52:46,640 --> 00:52:49,839
to left

00:52:47,520 --> 00:52:51,200
and it's no coincidence that uml uses

00:52:49,839 --> 00:52:54,800
this uh error

00:52:51,200 --> 00:52:57,839
it points to towards the base class

00:52:54,800 --> 00:53:00,240
the change is um

00:52:57,839 --> 00:53:02,319
it is a big one now circle doesn't

00:53:00,240 --> 00:53:05,440
depend on this interface anymore

00:53:02,319 --> 00:53:08,000
it owns the interface circle itself

00:53:05,440 --> 00:53:09,359
specifies what it needs in order to draw

00:53:08,000 --> 00:53:12,839
itself

00:53:09,359 --> 00:53:14,800
so circle owns it and can change it in

00:53:12,839 --> 00:53:17,040
time draw circle

00:53:14,800 --> 00:53:18,079
the implementation now depends on this

00:53:17,040 --> 00:53:20,400
interface

00:53:18,079 --> 00:53:21,839
and has to implement it based on the

00:53:20,400 --> 00:53:23,520
requirements that

00:53:21,839 --> 00:53:25,760
circle and probably all the other shapes

00:53:23,520 --> 00:53:28,720
pose

00:53:25,760 --> 00:53:30,000
so i have truly inverted dependency and

00:53:28,720 --> 00:53:32,000
only to do that

00:53:30,000 --> 00:53:33,119
little change moving the interface on

00:53:32,000 --> 00:53:35,920
the left hand side

00:53:33,119 --> 00:53:37,839
i can now add a lot of different kinds

00:53:35,920 --> 00:53:40,880
of implementation on the right-hand side

00:53:37,839 --> 00:53:41,440
without having to change the left-hand

00:53:40,880 --> 00:53:43,680
side

00:53:41,440 --> 00:53:45,760
the higher level now no longer depends

00:53:43,680 --> 00:53:49,440
on the details

00:53:45,760 --> 00:53:52,640
that is true um dependency inversion

00:53:49,440 --> 00:53:56,079
that is actually pretty important

00:53:52,640 --> 00:53:58,160
if you really think bigger think about

00:53:56,079 --> 00:53:59,680
architecture and for that reason i have

00:53:58,160 --> 00:54:01,119
a slightly bigger example

00:53:59,680 --> 00:54:03,359
i wanted to show you a model view

00:54:01,119 --> 00:54:07,280
controller

00:54:03,359 --> 00:54:07,280
i know there is a lot of different

00:54:07,359 --> 00:54:10,400
names and ideas where the model view

00:54:09,520 --> 00:54:12,480
control is

00:54:10,400 --> 00:54:14,160
so i stick to the definition given in

00:54:12,480 --> 00:54:16,880
wikipedia

00:54:14,160 --> 00:54:18,960
so a model view controller is three

00:54:16,880 --> 00:54:21,119
components that work together

00:54:18,960 --> 00:54:22,240
there is a controller that gives some

00:54:21,119 --> 00:54:25,440
kind of input

00:54:22,240 --> 00:54:27,040
which is forwarded to a model the model

00:54:25,440 --> 00:54:27,599
is supposed to contain the business

00:54:27,040 --> 00:54:31,200
logic

00:54:27,599 --> 00:54:34,720
the things that should change as

00:54:31,200 --> 00:54:35,760
rarely as possible but gives an answer

00:54:34,720 --> 00:54:39,119
to this input

00:54:35,760 --> 00:54:41,119
and passes this on to a view

00:54:39,119 --> 00:54:42,160
any kind of view right you could imagine

00:54:41,119 --> 00:54:45,520
some screen

00:54:42,160 --> 00:54:48,559
a terminal anything

00:54:45,520 --> 00:54:50,880
architecturally this is where i would

00:54:48,559 --> 00:54:52,480
draw an architectural boundary

00:54:50,880 --> 00:54:54,559
the model should be part of the high

00:54:52,480 --> 00:54:56,880
level truly at the top

00:54:54,559 --> 00:54:58,960
high controllers and views should be at

00:54:56,880 --> 00:54:59,520
the bottom because i can imagine that i

00:54:58,960 --> 00:55:01,440
can add

00:54:59,520 --> 00:55:03,119
many many different controllers many

00:55:01,440 --> 00:55:05,200
kinds of use

00:55:03,119 --> 00:55:07,520
but i probably will not change my model

00:55:05,200 --> 00:55:10,559
very often

00:55:07,520 --> 00:55:14,640
this however only works if i really

00:55:10,559 --> 00:55:17,200
think hard about my dependencies

00:55:14,640 --> 00:55:18,640
if these errors as i have them right now

00:55:17,200 --> 00:55:20,319
are the dependencies then i have a

00:55:18,640 --> 00:55:22,319
broken architecture

00:55:20,319 --> 00:55:24,000
what i truly need is a dependency from

00:55:22,319 --> 00:55:27,440
controller to model

00:55:24,000 --> 00:55:29,280
and from view to model and so especially

00:55:27,440 --> 00:55:29,920
in right-hand side i truly have an

00:55:29,280 --> 00:55:33,119
inversion

00:55:29,920 --> 00:55:34,559
of dependencies and i achieve this by

00:55:33,119 --> 00:55:37,680
having the interfaces

00:55:34,559 --> 00:55:39,119
on the model side model again defines

00:55:37,680 --> 00:55:41,280
itself

00:55:39,119 --> 00:55:42,720
um how to deal with controllers how to

00:55:41,280 --> 00:55:44,400
deal with views

00:55:42,720 --> 00:55:46,880
and this allows me this allows even

00:55:44,400 --> 00:55:48,799
third-party people to add new kinds of

00:55:46,880 --> 00:55:52,160
controllers and new kinds of use

00:55:48,799 --> 00:55:55,680
without the model having to change

00:55:52,160 --> 00:55:55,680
so true dependency inversion

00:55:56,079 --> 00:55:59,200
again i started with inheritance

00:55:58,400 --> 00:56:00,960
hierarchies

00:55:59,200 --> 00:56:02,480
but again you can apply this to

00:56:00,960 --> 00:56:04,240
templated code as well

00:56:02,480 --> 00:56:05,680
and for the fourth time i now use the

00:56:04,240 --> 00:56:08,559
copy function

00:56:05,680 --> 00:56:10,079
simply it really works also here and

00:56:08,559 --> 00:56:14,160
again it is about

00:56:10,079 --> 00:56:15,760
the concepts concepts just the space

00:56:14,160 --> 00:56:17,680
classes represent a

00:56:15,760 --> 00:56:20,079
set of requirements a set of

00:56:17,680 --> 00:56:24,640
specifications which function you should

00:56:20,079 --> 00:56:28,319
uh provide and how they should work

00:56:24,640 --> 00:56:30,799
if you pass me an input iterator that

00:56:28,319 --> 00:56:31,440
supports comparison that supports

00:56:30,799 --> 00:56:33,359
increment

00:56:31,440 --> 00:56:35,680
that supports the reference and where i

00:56:33,359 --> 00:56:40,160
can read from the d referent thing

00:56:35,680 --> 00:56:42,240
then you can use copy however copy

00:56:40,160 --> 00:56:43,359
doesn't rely on you to do the right

00:56:42,240 --> 00:56:46,160
thing

00:56:43,359 --> 00:56:46,960
in the sense that it owns its its

00:56:46,160 --> 00:56:49,599
concept

00:56:46,960 --> 00:56:51,280
it itself specifies what operations are

00:56:49,599 --> 00:56:54,799
required

00:56:51,280 --> 00:56:57,200
and so interestingly

00:56:54,799 --> 00:56:58,240
um so copy is implemented in terms of

00:56:57,200 --> 00:57:01,280
these requirements

00:56:58,240 --> 00:57:01,680
and interestingly this is why you depend

00:57:01,280 --> 00:57:05,520
on

00:57:01,680 --> 00:57:07,359
copy copy doesn't depend on you

00:57:05,520 --> 00:57:08,960
you have to follow rules the copy lays

00:57:07,359 --> 00:57:12,640
out for you else

00:57:08,960 --> 00:57:14,799
just doesn't work this is why

00:57:12,640 --> 00:57:16,559
you depend on the standard library and

00:57:14,799 --> 00:57:19,040
not the standard library on you

00:57:16,559 --> 00:57:19,680
this is why the standard library is um

00:57:19,040 --> 00:57:21,359
not

00:57:19,680 --> 00:57:22,960
at the bottom of your architecture but

00:57:21,359 --> 00:57:26,079
usually pretty high

00:57:22,960 --> 00:57:27,119
that you depend on this essentially

00:57:26,079 --> 00:57:29,200
everywhere

00:57:27,119 --> 00:57:31,280
of course this is a very clever and very

00:57:29,200 --> 00:57:33,680
correct way to implement a standard

00:57:31,280 --> 00:57:33,680
library

00:57:34,000 --> 00:57:37,839
so the takeaway here is to prefer to

00:57:36,240 --> 00:57:39,440
depend on abstractions

00:57:37,839 --> 00:57:42,480
whether this is abstract classes or

00:57:39,440 --> 00:57:46,400
concepts instead of a concrete type

00:57:42,480 --> 00:57:48,880
this enables you to um yeah

00:57:46,400 --> 00:57:50,160
protect yourself against changes that

00:57:48,880 --> 00:57:51,920
happen often

00:57:50,160 --> 00:57:54,240
but it only works if you truly think

00:57:51,920 --> 00:57:56,000
about where the abstractions should be

00:57:54,240 --> 00:57:57,599
so a fundamental question of this

00:57:56,000 --> 00:58:02,240
dependency inversion principle is

00:57:57,599 --> 00:58:02,240
where does the the abstraction belong to

00:58:02,319 --> 00:58:08,400
so this was now almost 60 minutes

00:58:05,359 --> 00:58:09,440
about the solid principles so we have

00:58:08,400 --> 00:58:11,920
talked about

00:58:09,440 --> 00:58:12,960
each and single day each each of these

00:58:11,920 --> 00:58:14,720
ones

00:58:12,960 --> 00:58:16,160
and hopefully i could show you that all

00:58:14,720 --> 00:58:19,440
of them somehow

00:58:16,160 --> 00:58:23,040
deal with dependencies in your code

00:58:19,440 --> 00:58:24,960
so to summarize first of all the solid

00:58:23,040 --> 00:58:25,839
principle more than just a set of oo

00:58:24,960 --> 00:58:28,000
guidelines

00:58:25,839 --> 00:58:29,440
i believe they are truly a universal set

00:58:28,000 --> 00:58:33,359
of guidelines that helps with

00:58:29,440 --> 00:58:35,680
any kind of coupling so let's use the

00:58:33,359 --> 00:58:38,400
solid principles to reduce coupling

00:58:35,680 --> 00:58:39,760
and facilitate change if you follow them

00:58:38,400 --> 00:58:41,839
you should have a much much

00:58:39,760 --> 00:58:45,119
easier time to change things to extend

00:58:41,839 --> 00:58:46,640
things and to deal with dependencies

00:58:45,119 --> 00:58:48,720
the single responsibility principle

00:58:46,640 --> 00:58:50,480
helps you to isolate changes

00:58:48,720 --> 00:58:52,799
that is definitely something very very

00:58:50,480 --> 00:58:53,359
valuable the open close principle

00:58:52,799 --> 00:58:56,079
however

00:58:53,359 --> 00:58:58,000
helps you to to add things to extend

00:58:56,079 --> 00:59:00,240
things more easily

00:58:58,000 --> 00:59:02,559
that of course is also pretty important

00:59:00,240 --> 00:59:04,480
for long-term maintenance

00:59:02,559 --> 00:59:05,760
the list of substitution principle is

00:59:04,480 --> 00:59:08,400
about

00:59:05,760 --> 00:59:10,160
what is a good abstraction what is not

00:59:08,400 --> 00:59:12,720
so it tells you how to write

00:59:10,160 --> 00:59:15,200
abstractions in the first place

00:59:12,720 --> 00:59:17,040
the interface segregation principle is

00:59:15,200 --> 00:59:18,160
about minimizing dependencies in

00:59:17,040 --> 00:59:20,799
interfaces

00:59:18,160 --> 00:59:23,760
which as i said is a special case of srp

00:59:20,799 --> 00:59:25,200
but a really important special case

00:59:23,760 --> 00:59:26,880
and the dependency inversion principle

00:59:25,200 --> 00:59:27,760
helps you helps you to steer

00:59:26,880 --> 00:59:30,319
dependencies

00:59:27,760 --> 00:59:32,400
in a specific direction only that truly

00:59:30,319 --> 00:59:35,440
enables you to modularize

00:59:32,400 --> 00:59:37,680
things and to separate things on a

00:59:35,440 --> 00:59:38,720
bigger scale scale so of course you've

00:59:37,680 --> 00:59:42,559
seen with copy

00:59:38,720 --> 00:59:42,559
definitely also works on a small scale

00:59:43,040 --> 00:59:46,960
with that i'm very happy to take a

00:59:45,680 --> 00:59:50,079
couple of questions

00:59:46,960 --> 00:59:52,559
if there have been couple

00:59:50,079 --> 00:59:53,599
so there was a question i probably have

00:59:52,559 --> 00:59:55,520
to read it

00:59:53,599 --> 00:59:57,520
so for open closed you're saying you

00:59:55,520 --> 00:59:59,440
have to choose which is a priority

00:59:57,520 --> 01:00:01,040
optimize for new types versus new

00:59:59,440 --> 01:00:04,720
operations

01:00:01,040 --> 01:00:06,160
yes unfortunately so as long as you want

01:00:04,720 --> 01:00:08,480
dynamic polymorphism you

01:00:06,160 --> 01:00:09,760
indeed have to choose what is more

01:00:08,480 --> 01:00:12,720
important to you

01:00:09,760 --> 01:00:14,079
even modern schemes like using standard

01:00:12,720 --> 01:00:14,720
variant which allows you to add

01:00:14,079 --> 01:00:17,520
operations

01:00:14,720 --> 01:00:19,359
really easy or something like type

01:00:17,520 --> 01:00:20,960
erasure which allows you to add types

01:00:19,359 --> 01:00:23,599
really conveniently

01:00:20,960 --> 01:00:24,079
um in all of these approaches still you

01:00:23,599 --> 01:00:26,799
have to

01:00:24,079 --> 01:00:29,280
favor one over the other so i am not

01:00:26,799 --> 01:00:32,160
aware of any solution that allows you to

01:00:29,280 --> 01:00:33,760
very easily add operations and types in

01:00:32,160 --> 01:00:36,640
dynamic polymorphism

01:00:33,760 --> 01:00:37,680
static polymorphism is easy in this case

01:00:36,640 --> 01:00:39,920
but still

01:00:37,680 --> 01:00:42,640
you may be restricted depending on what

01:00:39,920 --> 01:00:44,079
what your design truly is however it is

01:00:42,640 --> 01:00:46,000
important to keep in mind that there is

01:00:44,079 --> 01:00:48,400
these two dimensions of ocp

01:00:46,000 --> 01:00:49,839
it's not just the one thing you

01:00:48,400 --> 01:00:53,839
primarily think about adding

01:00:49,839 --> 01:00:55,680
types it's also about adding operations

01:00:53,839 --> 01:00:57,040
okay question two for the list of

01:00:55,680 --> 01:00:59,359
substitution principle

01:00:57,040 --> 01:01:00,720
in my square rectangle example uh the

01:00:59,359 --> 01:01:02,559
better choice is to have screen

01:01:00,720 --> 01:01:03,760
rectangle is two separate classes that

01:01:02,559 --> 01:01:06,799
don't inherit

01:01:03,760 --> 01:01:07,440
absolutely um strictly speaking it

01:01:06,799 --> 01:01:11,280
depends

01:01:07,440 --> 01:01:13,359
on how you implement your two setters

01:01:11,280 --> 01:01:14,960
if you do have two setters if you do

01:01:13,359 --> 01:01:17,200
have set with and set

01:01:14,960 --> 01:01:18,880
set height separately it will not work

01:01:17,200 --> 01:01:21,200
in an inheritance relationship you

01:01:18,880 --> 01:01:24,400
cannot uphold the invariance

01:01:21,200 --> 01:01:24,880
of the base class if you have a set

01:01:24,400 --> 01:01:26,640
booth

01:01:24,880 --> 01:01:28,079
function and i cannot think of a better

01:01:26,640 --> 01:01:30,720
rate name right now

01:01:28,079 --> 01:01:32,319
so a function allows you to give both uh

01:01:30,720 --> 01:01:34,319
height and width

01:01:32,319 --> 01:01:35,920
then this is an awkward interface for a

01:01:34,319 --> 01:01:38,319
square but this

01:01:35,920 --> 01:01:40,400
might work but since it's awkward i

01:01:38,319 --> 01:01:42,559
would also not go there

01:01:40,400 --> 01:01:45,839
if you don't have any setters you could

01:01:42,559 --> 01:01:48,640
use it but then it's very inflexible

01:01:45,839 --> 01:01:50,720
i would truly prefer to not have square

01:01:48,640 --> 01:01:52,319
and rectangle have a relation

01:01:50,720 --> 01:01:53,920
one of the things that you might think

01:01:52,319 --> 01:01:57,359
of is a shape

01:01:53,920 --> 01:01:59,920
based class that does not have any um

01:01:57,359 --> 01:02:02,000
uh where you don't have any expectations

01:01:59,920 --> 01:02:02,880
on the form or properties of the driving

01:02:02,000 --> 01:02:05,839
class

01:02:02,880 --> 01:02:06,400
so perhaps square rectangle in computer

01:02:05,839 --> 01:02:08,079
science

01:02:06,400 --> 01:02:10,480
simply do not have anything to do with

01:02:08,079 --> 01:02:10,480
each other

01:02:10,799 --> 01:02:15,839
okay now question three

01:02:14,079 --> 01:02:17,599
uh about the lisk of substitution

01:02:15,839 --> 01:02:19,599
principle again does something like a

01:02:17,599 --> 01:02:23,039
polygon interface with gate area and get

01:02:19,599 --> 01:02:23,039
perimeter solve the problem

01:02:24,880 --> 01:02:28,960
get perimeter so i probably have to

01:02:27,520 --> 01:02:32,319
think about this too

01:02:28,960 --> 01:02:35,359
um it might i totally might

01:02:32,319 --> 01:02:37,839
my personal preference however is to try

01:02:35,359 --> 01:02:41,280
to separate concerns as much as possible

01:02:37,839 --> 01:02:45,119
and so lsp is tricky

01:02:41,280 --> 01:02:49,280
also i don't want to run into subtle

01:02:45,119 --> 01:02:52,160
problems later so i tend to argue

01:02:49,280 --> 01:02:53,039
the uh the less coupling the better so

01:02:52,160 --> 01:02:56,559
perhaps this

01:02:53,039 --> 01:02:58,960
this approach works perhaps it doesn't

01:02:56,559 --> 01:03:03,839
okay i hope this was helpful for you

01:02:58,960 --> 01:03:03,839
thank you very much for attending

01:03:20,319 --> 01:03:22,400

YouTube URL: https://www.youtube.com/watch?v=Ntraj80qN2k


