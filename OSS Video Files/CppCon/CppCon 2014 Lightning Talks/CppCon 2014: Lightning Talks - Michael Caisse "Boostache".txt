Title: CppCon 2014: Lightning Talks - Michael Caisse "Boostache"
Publication date: 2020-10-27
Playlist: CppCon 2014 Lightning Talks
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Michael Caisse has been crafting code in C++ for nearly 25-years. He is the owner of Ciere Consulting which provides software consulting and contracting services, C++ training, and Project Recovery for failing multidisciplinary engineering projects. :: ciere.com
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,190
michael is the owner of sea air sigh

00:00:01,949 --> 00:00:06,899
right it's kira kira consulting enjoys

00:00:05,190 --> 00:00:10,620
teaching others about c++ writing

00:00:06,899 --> 00:00:21,210
template metaprogramming he's going to

00:00:10,620 --> 00:00:24,920
tell you about mustache okay so boost

00:00:21,210 --> 00:00:30,000
dash is a library in a week that was um

00:00:24,920 --> 00:00:32,460
sponsored at this last CPP C++ now wrong

00:00:30,000 --> 00:00:34,350
conference s2 plus plus now C++ now has

00:00:32,460 --> 00:00:36,630
a zero track which is called library in

00:00:34,350 --> 00:00:38,969
a week and started with buscando 2008

00:00:36,630 --> 00:00:40,350
and for people who can figure out how to

00:00:38,969 --> 00:00:44,340
get to the conference center early

00:00:40,350 --> 00:00:46,110
enough in the morning we argue about how

00:00:44,340 --> 00:00:47,370
the libraries to be developed and then

00:00:46,110 --> 00:00:50,760
we spent a couple days trying to develop

00:00:47,370 --> 00:00:52,520
a library and the concept this year was

00:00:50,760 --> 00:00:56,219
something that eventually became named

00:00:52,520 --> 00:00:58,170
boost dash or boost ish or depending

00:00:56,219 --> 00:01:04,710
upon where you live it might even be

00:00:58,170 --> 00:01:08,010
boost ache so yeah the idea of this was

00:01:04,710 --> 00:01:09,630
if you've seen template and not like

00:01:08,010 --> 00:01:11,250
templates like we think about templates

00:01:09,630 --> 00:01:12,390
but templates like maybe web people or

00:01:11,250 --> 00:01:14,850
other people who are trying to generate

00:01:12,390 --> 00:01:17,700
text output or other output it was a

00:01:14,850 --> 00:01:20,130
template engine and so you provide to it

00:01:17,700 --> 00:01:22,500
some description and I'm it was modeled

00:01:20,130 --> 00:01:24,600
after a mustache and then it would take

00:01:22,500 --> 00:01:26,310
a data structure in and it would apply

00:01:24,600 --> 00:01:29,840
the two and then and then put something

00:01:26,310 --> 00:01:32,939
out and what we came up with is

00:01:29,840 --> 00:01:37,680
something that actually looks like this

00:01:32,939 --> 00:01:39,420
the the the idea is that we have a

00:01:37,680 --> 00:01:41,009
template and some user data coming in

00:01:39,420 --> 00:01:46,409
the the template was going to be

00:01:41,009 --> 00:01:49,259
compiled into an AST and then the user

00:01:46,409 --> 00:01:51,930
data and the compiled template data

00:01:49,259 --> 00:01:55,170
would be ran through a vm engine and

00:01:51,930 --> 00:01:57,240
then there'd be some output and so let's

00:01:55,170 --> 00:02:00,229
just look at this one this one side for

00:01:57,240 --> 00:02:04,140
a moment which we wrote that week

00:02:00,229 --> 00:02:06,869
basically the template is a text

00:02:04,140 --> 00:02:08,789
description and it goes through boost

00:02:06,869 --> 00:02:11,670
spirit the output is an abstract syntax

00:02:08,789 --> 00:02:13,020
tree that absent abstract syntax tree is

00:02:11,670 --> 00:02:14,860
then

00:02:13,020 --> 00:02:17,400
grovelled over with some modern

00:02:14,860 --> 00:02:21,490
techniques that allow a very declarative

00:02:17,400 --> 00:02:24,400
description of how you transfer this AST

00:02:21,490 --> 00:02:27,190
into the AST that you want and that is

00:02:24,400 --> 00:02:28,360
the engine primitive a stn you might

00:02:27,190 --> 00:02:29,560
think why in the world would you want to

00:02:28,360 --> 00:02:31,450
do that you already had a perfectly good

00:02:29,560 --> 00:02:33,100
AST and the reason is because kate wants

00:02:31,450 --> 00:02:36,610
to write her actually own template

00:02:33,100 --> 00:02:38,860
language and so we support then the k

00:02:36,610 --> 00:02:40,150
template mustache template in Django

00:02:38,860 --> 00:02:42,670
template and you can just keep adding

00:02:40,150 --> 00:02:45,340
templates beyond the grammars to write

00:02:42,670 --> 00:02:48,070
for spirit are very very simple the

00:02:45,340 --> 00:02:50,890
declarative rules to write in order how

00:02:48,070 --> 00:02:52,180
to describe one AST into another a str

00:02:50,890 --> 00:02:54,310
very simple to write and now we have a

00:02:52,180 --> 00:02:56,970
common AST that describes the

00:02:54,310 --> 00:03:00,400
instruction sets for the compiler the

00:02:56,970 --> 00:03:02,320
the other side taking user data and

00:03:00,400 --> 00:03:03,550
apply it into the vm that a lot of

00:03:02,320 --> 00:03:09,100
questions come up with this like what

00:03:03,550 --> 00:03:12,130
does user data look like wow sometimes

00:03:09,100 --> 00:03:14,050
it does look like that so like what

00:03:12,130 --> 00:03:16,989
structure should you use for this data

00:03:14,050 --> 00:03:19,030
and you know should be JSON should it be

00:03:16,989 --> 00:03:22,480
some variant that's a recursive data

00:03:19,030 --> 00:03:23,920
structure should it be maps vectors what

00:03:22,480 --> 00:03:25,360
are you going to use and really what we

00:03:23,920 --> 00:03:27,550
wanted to use the design goal was to be

00:03:25,360 --> 00:03:30,100
able to use whatever the user had inside

00:03:27,550 --> 00:03:31,450
of their native C++ program you probably

00:03:30,100 --> 00:03:32,860
have some recursive data structure we

00:03:31,450 --> 00:03:37,090
would like to take that and throw it at

00:03:32,860 --> 00:03:39,989
it ends up that that's hard so we didn't

00:03:37,090 --> 00:03:43,900
accomplish that by the end of the week

00:03:39,989 --> 00:03:45,850
but I had a long plane trip from

00:03:43,900 --> 00:03:49,150
Virginia back to California last month

00:03:45,850 --> 00:03:50,560
and so I spent some time on that and you

00:03:49,150 --> 00:03:52,209
can he'll throw just about anything at

00:03:50,560 --> 00:03:54,970
it and it uses something called

00:03:52,209 --> 00:03:56,769
categories in order to figure out at

00:03:54,970 --> 00:04:01,170
compile time what a recursive data

00:03:56,769 --> 00:04:04,570
structure is non-intrusive lee and and

00:04:01,170 --> 00:04:06,880
can work with that so here is for

00:04:04,570 --> 00:04:08,260
example I just threw this together it's

00:04:06,880 --> 00:04:10,060
using something called extended variant

00:04:08,260 --> 00:04:11,739
it is something in spirit that just

00:04:10,060 --> 00:04:14,140
allows you to treat variants like their

00:04:11,739 --> 00:04:16,030
objects so you can declare them early

00:04:14,140 --> 00:04:17,410
and use them recursively as opposed to

00:04:16,030 --> 00:04:20,950
all the ugliness that you have to do

00:04:17,410 --> 00:04:23,680
with non types that are variant so here

00:04:20,950 --> 00:04:26,200
maps and lists and whatever's and you

00:04:23,680 --> 00:04:28,030
just throw that at the data side

00:04:26,200 --> 00:04:29,320
or any recursive data structure that you

00:04:28,030 --> 00:04:30,580
might have and it will understand how to

00:04:29,320 --> 00:04:36,850
grovel through that and pull the data

00:04:30,580 --> 00:04:39,940
out as as its processing so we now have

00:04:36,850 --> 00:04:42,100
the data AST instruction AST at some

00:04:39,940 --> 00:04:43,810
point goes insight to the virtual

00:04:42,100 --> 00:04:46,780
machine engine and in and we have an

00:04:43,810 --> 00:04:50,740
output so this is useful for a whole lot

00:04:46,780 --> 00:04:52,810
of different things the our company here

00:04:50,740 --> 00:04:54,070
is taking and moving this on and i'm

00:04:52,810 --> 00:04:55,270
going to continue to work on it we

00:04:54,070 --> 00:04:57,240
actually have something that would call

00:04:55,270 --> 00:04:58,990
kira labs where it's our open source

00:04:57,240 --> 00:05:00,310
things that we've been able to do

00:04:58,990 --> 00:05:03,160
internally for either clients or

00:05:00,310 --> 00:05:04,960
ourselves and we move on and an open

00:05:03,160 --> 00:05:07,210
source ax you can find more information

00:05:04,960 --> 00:05:09,910
akira labs org including lots of

00:05:07,210 --> 00:05:11,290
tutorials about spirit and the

00:05:09,910 --> 00:05:13,510
techniques that we're using the modern

00:05:11,290 --> 00:05:15,910
set c++ techniques were using and I'm

00:05:13,510 --> 00:05:27,610
github com care labs you'll find that

00:05:15,910 --> 00:05:31,120
source code for boost dash we actually

00:05:27,610 --> 00:05:33,370
wrote a vm engine yeah it's very simple

00:05:31,120 --> 00:05:35,260
to write using you know modern

00:05:33,370 --> 00:05:38,170
declarative techniques you can write BM

00:05:35,260 --> 00:05:41,350
engines very quickly we in our company

00:05:38,170 --> 00:05:45,730
the last two years have written three

00:05:41,350 --> 00:05:50,110
four very significant large languages

00:05:45,730 --> 00:05:52,570
it's not part of me yeah beans on github

00:05:50,110 --> 00:05:54,430
a don't don't be thinking something

00:05:52,570 --> 00:05:56,880
amazing since the video that's supposed

00:05:54,430 --> 00:05:56,880

YouTube URL: https://www.youtube.com/watch?v=hTnoEjqUZjI


