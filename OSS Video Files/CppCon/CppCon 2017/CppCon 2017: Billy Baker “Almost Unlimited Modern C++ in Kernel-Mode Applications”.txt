Title: CppCon 2017: Billy Baker “Almost Unlimited Modern C++ in Kernel-Mode Applications”
Publication date: 2017-10-06
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Rian Quinn's "Making C++ and the STL Work in the Linux/Windows Kernels" from CppCon 2016 showed the difficulty of making C++ code work correctly in kernel mode. For some real-time systems, though, developing C++ applications that run in kernel mode "just works" as most of the necessary runtime support for Modern C++ is already available. Platform limitations, though, can offset the development gains that come with easy access to hardware.

This talk will present a variety of issues — such as limited filesystem functionality, missing memory protection, limited debugging and performance monitoring tools, and constrained resources — that impact usage of standard C++ functionality and require additional due diligence on the part of the developer. Topics will include testing in user mode; kernel-mode exceptions; and programming the Intel performance monitoring hardware.
— 
Billy Baker: FlightSafety International, Senior Staff Software Engineer

Billy Baker has developed deterministic real-time flight simulation software using C++ for FlightSafety International, Evans and Sutherland and Boeing since 1997. At C++ committee meetings, he can most likely be found in LWG. He received his B.S. and M.S in Applied Mathematics from the University of Tulsa and is currently working on a Ph.D. in Computer Science. If asked, he will tell stories from his research semester at NCSA when web browsers did not yet have forms support.Website: http://www.flightsafety.com
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,280 --> 00:00:06,330
thank you everyone for attending our

00:00:03,659 --> 00:00:09,510
talk gone almost unlimited C++ and

00:00:06,330 --> 00:00:10,920
chrome applications and you know you may

00:00:09,510 --> 00:00:12,480
be wondering why you're here I'm sure

00:00:10,920 --> 00:00:16,170
it's because you're expecting death

00:00:12,480 --> 00:00:17,369
destruction mayhem and panic because you

00:00:16,170 --> 00:00:20,580
know that's sort of what you get and you

00:00:17,369 --> 00:00:22,740
program in the kernel and if you did not

00:00:20,580 --> 00:00:27,269
believe that obviously we can step back

00:00:22,740 --> 00:00:29,640
in time and see some quotes now I did

00:00:27,269 --> 00:00:33,270
not verify these quotes I did not change

00:00:29,640 --> 00:00:36,140
these quotes but urban legend says

00:00:33,270 --> 00:00:39,300
they're true right twenty-five years ago

00:00:36,140 --> 00:00:41,489
maybe it wasn't a good idea and this

00:00:39,300 --> 00:00:46,110
continued on with saying exceptions are

00:00:41,489 --> 00:00:48,180
bad memory allocations we don't like to

00:00:46,110 --> 00:00:52,430
see those I have plenty of co-workers

00:00:48,180 --> 00:00:58,230
that malign C++ for the same reason and

00:00:52,430 --> 00:01:01,340
it's problematic for me this doesn't

00:00:58,230 --> 00:01:05,519
help this popped up about 20 days ago

00:01:01,340 --> 00:01:08,549
the left-hand side says I'm going to

00:01:05,519 --> 00:01:11,100
call through a function pointer do it's

00:01:08,549 --> 00:01:14,070
never actually sipped anything but the

00:01:11,100 --> 00:01:16,560
compiler has assumed that never called

00:01:14,070 --> 00:01:17,759
was executed at some point because

00:01:16,560 --> 00:01:20,100
otherwise the program would be

00:01:17,759 --> 00:01:21,509
ill-formed and if you can read the

00:01:20,100 --> 00:01:23,909
disassembly on the right you see that

00:01:21,509 --> 00:01:28,680
it's going to remove all the files or at

00:01:23,909 --> 00:01:29,880
least attempt to so if you hear the rest

00:01:28,680 --> 00:01:31,229
of the week Wednesday and Friday there's

00:01:29,880 --> 00:01:32,000
a couple of other talks on undefined

00:01:31,229 --> 00:01:34,920
behavior

00:01:32,000 --> 00:01:37,500
now 2004 was a very interesting year

00:01:34,920 --> 00:01:39,329
evidently because windows had some

00:01:37,500 --> 00:01:41,310
discussions about programming with C++

00:01:39,329 --> 00:01:45,360
in the kernel as well the bold here is

00:01:41,310 --> 00:01:48,630
my Edition and it explicitly says that

00:01:45,360 --> 00:01:49,770
while we may not expect to use C++ in

00:01:48,630 --> 00:01:51,689
the kernel given the right

00:01:49,770 --> 00:01:58,890
implementation and the right execution

00:01:51,689 --> 00:02:02,579
environment all things are possible 2012

00:01:58,890 --> 00:02:04,259
to jump ahead a little bit visual C++

00:02:02,579 --> 00:02:06,960
wind up getting this little option

00:02:04,259 --> 00:02:10,470
I know game programmers I talked to love

00:02:06,960 --> 00:02:12,959
to disable exceptions love to turn off

00:02:10,470 --> 00:02:14,819
our TTI

00:02:12,959 --> 00:02:16,290
new and delete we're back to their the

00:02:14,819 --> 00:02:18,930
only problem here that I see is that we

00:02:16,290 --> 00:02:21,810
also limit the instruction sets we can

00:02:18,930 --> 00:02:24,090
use so if we really wanted to do

00:02:21,810 --> 00:02:26,180
something other than maybe a brick

00:02:24,090 --> 00:02:28,920
driver a network drive or something that

00:02:26,180 --> 00:02:31,010
used the full capabilities of the CPU

00:02:28,920 --> 00:02:34,260
we're out of luck

00:02:31,010 --> 00:02:38,640
unless you might do some own assembly

00:02:34,260 --> 00:02:43,230
programming or other things nikkor how

00:02:38,640 --> 00:02:46,250
lucky am i it's just a blue screen I'm

00:02:43,230 --> 00:02:48,930
sure we've all gotten them

00:02:46,250 --> 00:02:52,440
ok so 20 years of programming flight

00:02:48,930 --> 00:02:54,299
simulation this is a smattering of the

00:02:52,440 --> 00:02:59,879
different environments that I've either

00:02:54,299 --> 00:03:02,489
directly worked with or read code from a

00:02:59,879 --> 00:03:06,000
lot of them are UNIX like the three

00:03:02,489 --> 00:03:09,780
bolded ones are very interesting we're

00:03:06,000 --> 00:03:13,379
gonna use Windows visual C++ and try and

00:03:09,780 --> 00:03:16,170
do something real-time and the first one

00:03:13,379 --> 00:03:16,560
there on time is different than the

00:03:16,170 --> 00:03:18,950
other two

00:03:16,560 --> 00:03:24,170
and that it is a pure operating system

00:03:18,950 --> 00:03:27,000
for the end time and r-tx choices their

00:03:24,170 --> 00:03:28,980
system actually boots to Windows so

00:03:27,000 --> 00:03:32,220
there is an operating system on subset

00:03:28,980 --> 00:03:33,780
of subset of the cords then you have

00:03:32,220 --> 00:03:35,730
this other operating system sort of

00:03:33,780 --> 00:03:37,620
hanging down in your system not flight

00:03:35,730 --> 00:03:39,870
virtualization but it's taking the rest

00:03:37,620 --> 00:03:47,280
of your course and that's where all the

00:03:39,870 --> 00:03:48,599
magic happens now please as a 164 these

00:03:47,280 --> 00:03:51,450
were the platforms that were in the

00:03:48,599 --> 00:03:53,400
platform directory I did not look at 165

00:03:51,450 --> 00:03:56,910
sorry

00:03:53,400 --> 00:03:59,849
it covers half of my list when the

00:03:56,910 --> 00:04:01,530
previous one for that end time and r-tx

00:03:59,849 --> 00:04:04,079
windows options that I had on the

00:04:01,530 --> 00:04:06,150
previous slide those are mostly going to

00:04:04,079 --> 00:04:10,010
be directed at win32 here because they

00:04:06,150 --> 00:04:10,010
are trying to emulate the windows API

00:04:12,620 --> 00:04:15,870
alright

00:04:14,370 --> 00:04:19,260
has anyone here actually done Linux

00:04:15,870 --> 00:04:24,960
real-time programming okay we got one

00:04:19,260 --> 00:04:27,180
hand pretty common diagram it did not

00:04:24,960 --> 00:04:29,520
take me long to find these I could could

00:04:27,180 --> 00:04:32,040
have ample anymore basically we look to

00:04:29,520 --> 00:04:35,130
do things like separate your non

00:04:32,040 --> 00:04:40,190
real-time processes from your real-time

00:04:35,130 --> 00:04:42,840
processes the image on the right shows

00:04:40,190 --> 00:04:45,120
explicitly doing real-time on half the

00:04:42,840 --> 00:04:49,229
cores and non-critical applications on

00:04:45,120 --> 00:04:56,450
the other half so I will directly ask

00:04:49,229 --> 00:04:56,450
Jeff pretty common this particular oh

00:04:57,110 --> 00:05:05,010
it's pretty common Jeff okay so for

00:05:03,900 --> 00:05:06,810
Windows in real-time

00:05:05,010 --> 00:05:08,430
obviously Windows itself is not going to

00:05:06,810 --> 00:05:10,110
be real-time but if we look at these two

00:05:08,430 --> 00:05:12,780
extensions in time and r-tx there are

00:05:10,110 --> 00:05:13,800
really a lot of like the pretty much

00:05:12,780 --> 00:05:16,560
limited to the intel and AMD

00:05:13,800 --> 00:05:17,729
architectures they do the same thing

00:05:16,560 --> 00:05:20,070
that I showed on the previous slide they

00:05:17,729 --> 00:05:23,400
want to segregate CPUs that are doing

00:05:20,070 --> 00:05:26,190
real time from the other CPUs there's a

00:05:23,400 --> 00:05:29,539
big problem though in a lot of this real

00:05:26,190 --> 00:05:33,180
time work we don't have latest NIC

00:05:29,539 --> 00:05:37,020
hardware we have lots of old kamba stuff

00:05:33,180 --> 00:05:39,570
sitting out there and that really is low

00:05:37,020 --> 00:05:41,789
volume stuff and it a lot of times does

00:05:39,570 --> 00:05:46,110
not use latest interrupt architectures

00:05:41,789 --> 00:05:47,669
so these two particular solutions don't

00:05:46,110 --> 00:05:51,150
allow you to share interrupts between

00:05:47,669 --> 00:05:53,160
two devices between a real-time device

00:05:51,150 --> 00:05:55,860
and a Windows device and it gets worse

00:05:53,160 --> 00:05:57,570
even something like a PCI Express Bridge

00:05:55,860 --> 00:06:00,270
chip that might take an interrupt can't

00:05:57,570 --> 00:06:01,460
be shared with one of these devices just

00:06:00,270 --> 00:06:03,630
a bummer

00:06:01,460 --> 00:06:05,490
likewise you see here the shared

00:06:03,630 --> 00:06:08,190
libraries are an issue these two

00:06:05,490 --> 00:06:14,430
platforms want to explicitly deny you

00:06:08,190 --> 00:06:15,930
all access to Windows DLLs and then

00:06:14,430 --> 00:06:18,090
there's the big difference there in time

00:06:15,930 --> 00:06:21,330
wants to do user mode lots of protection

00:06:18,090 --> 00:06:23,220
and RT X doesn't so I hope you can see

00:06:21,330 --> 00:06:25,229
what we're going here if we're going to

00:06:23,220 --> 00:06:27,419
talk about C++ programming in the kernel

00:06:25,229 --> 00:06:28,139
and I've highlighted things in bold

00:06:27,419 --> 00:06:33,509
we're probably

00:06:28,139 --> 00:06:37,680
but r-tx this is a image out of the end

00:06:33,509 --> 00:06:39,779
time documentation being a user mode

00:06:37,680 --> 00:06:42,210
application they look very much towards

00:06:39,779 --> 00:06:44,729
separating memory spaces between the

00:06:42,210 --> 00:06:47,930
processes and that gives them a higher

00:06:44,729 --> 00:06:47,930
level of reliability

00:06:48,379 --> 00:06:53,960
RTX though in down in kernel mode not so

00:06:53,189 --> 00:06:57,060
much

00:06:53,960 --> 00:07:02,029
shared memory across the board windows

00:06:57,060 --> 00:07:05,490
apps r-tx all access the same memory

00:07:02,029 --> 00:07:07,860
driver creation under r-tx much simpler

00:07:05,490 --> 00:07:10,080
as in anything you would ever do in

00:07:07,860 --> 00:07:11,699
Windows pretty much you make one

00:07:10,080 --> 00:07:17,939
function call to register an interrupt

00:07:11,699 --> 00:07:21,050
handler and that's it now a couple of

00:07:17,939 --> 00:07:23,430
weeks ago there was this conference and

00:07:21,050 --> 00:07:26,699
one of the consumers of flight

00:07:23,430 --> 00:07:28,319
simulators and didn't have some very

00:07:26,699 --> 00:07:30,180
good things to say about the products

00:07:28,319 --> 00:07:32,490
they've been receiving to the point

00:07:30,180 --> 00:07:34,860
where they really do not want a Windows

00:07:32,490 --> 00:07:37,319
product anymore whether it had an end

00:07:34,860 --> 00:07:39,210
time extension or an RT X extension and

00:07:37,319 --> 00:07:42,779
some of these things that they list here

00:07:39,210 --> 00:07:44,849
are not even real time related iOS here

00:07:42,779 --> 00:07:48,779
is an instructor operating station not

00:07:44,849 --> 00:07:51,419
the Mac operating system pure Windows

00:07:48,779 --> 00:07:56,039
application they're saying that they

00:07:51,419 --> 00:07:58,229
hate their product basically and of

00:07:56,039 --> 00:08:01,159
course my response to them would be okay

00:07:58,229 --> 00:08:05,330
you want Linux but there's plenty of

00:08:01,159 --> 00:08:10,110
examples where you can do bad things

00:08:05,330 --> 00:08:15,240
yeah Toyota break case scandal and you

00:08:10,110 --> 00:08:21,360
may have a Toyota this thermostat lots

00:08:15,240 --> 00:08:22,860
of cold cold people all right so there's

00:08:21,360 --> 00:08:26,159
a book if it's on the table

00:08:22,860 --> 00:08:30,360
Chris will not attempt its last name

00:08:26,159 --> 00:08:32,550
talks about real-time C++ and he and the

00:08:30,360 --> 00:08:34,019
preface talks about the in the CPU

00:08:32,550 --> 00:08:35,310
environment that he works with and

00:08:34,019 --> 00:08:38,640
that's much more towards the

00:08:35,310 --> 00:08:40,780
microcontroller so small memories I

00:08:38,640 --> 00:08:45,560
small code size

00:08:40,780 --> 00:08:50,590
yeah but that's not what we're gonna

00:08:45,560 --> 00:08:53,660
work with lots of cores lots of memory

00:08:50,590 --> 00:08:55,280
for a flight simulator airplane in

00:08:53,660 --> 00:08:57,140
general you have lots of distributed

00:08:55,280 --> 00:08:59,660
system sensors all over the place lots

00:08:57,140 --> 00:09:03,410
of black boxes and from a simulation

00:08:59,660 --> 00:09:05,330
standpoint that same vendor that didn't

00:09:03,410 --> 00:09:07,940
like having windows also doesn't want to

00:09:05,330 --> 00:09:09,830
have a lot of boxes that they have to

00:09:07,940 --> 00:09:11,540
boot so they really want you to bring in

00:09:09,830 --> 00:09:14,030
all of these simulations of different

00:09:11,540 --> 00:09:15,650
pieces and put them onto one system we

00:09:14,030 --> 00:09:17,150
have lots of cores now we have a

00:09:15,650 --> 00:09:21,100
real-time operating system that will

00:09:17,150 --> 00:09:24,790
take advantage of them go for it

00:09:21,100 --> 00:09:28,400
so talked about an operating system

00:09:24,790 --> 00:09:30,830
talked about CPU architecture compiler

00:09:28,400 --> 00:09:33,350
we certainly be using visual C++ in this

00:09:30,830 --> 00:09:36,620
talk and there's this issue of

00:09:33,350 --> 00:09:37,610
freestanding versus hosted if we were

00:09:36,620 --> 00:09:41,540
only going to stick with the

00:09:37,610 --> 00:09:44,300
freestanding 16 headers there absolutely

00:09:41,540 --> 00:09:47,740
no problem whether it's in user mode or

00:09:44,300 --> 00:09:55,070
kernel in this particular case the other

00:09:47,740 --> 00:09:56,630
headers not so much and and that's where

00:09:55,070 --> 00:09:58,640
most of this talk will be going is

00:09:56,630 --> 00:09:59,780
talking about the problems that we

00:09:58,640 --> 00:10:09,170
encounter and some of these other

00:09:59,780 --> 00:10:14,140
headers okay random device start with

00:10:09,170 --> 00:10:17,450
something simple very simple application

00:10:14,140 --> 00:10:19,400
we just want to potentially access a

00:10:17,450 --> 00:10:24,700
piece of hardware to give us random

00:10:19,400 --> 00:10:28,450
numbers for

00:10:24,700 --> 00:10:30,220
C++ 2012 the constructor calls an

00:10:28,450 --> 00:10:33,250
external function which winds up calling

00:10:30,220 --> 00:10:39,340
R and s from the C runtime which looks

00:10:33,250 --> 00:10:44,110
for RTL Jen random via DLL of course

00:10:39,340 --> 00:10:46,410
that fails I most certainly did Marshall

00:10:44,110 --> 00:10:50,520
keep that thought

00:10:46,410 --> 00:10:52,720
so for 2012 we returned Ino mem

00:10:50,520 --> 00:10:55,720
exception gets thrown we can handle it

00:10:52,720 --> 00:10:57,640
as Michonne in the previous example we

00:10:55,720 --> 00:11:00,940
jumped forward just a few years some

00:10:57,640 --> 00:11:06,040
more than newer Windows 10 SDKs randa's

00:11:00,940 --> 00:11:10,180
changed just slightly now there's the

00:11:06,040 --> 00:11:12,730
system function 0 3 6 of course we all

00:11:10,180 --> 00:11:19,120
know what that is it's basically a

00:11:12,730 --> 00:11:20,800
synonym for the RTL gen random in making

00:11:19,120 --> 00:11:23,260
this change they also said there is no

00:11:20,800 --> 00:11:27,750
fallback windows will always have system

00:11:23,260 --> 00:11:33,070
function 0 3 6 so we abort now

00:11:27,750 --> 00:11:36,340
bad things happen so yes Marshall you

00:11:33,070 --> 00:11:39,100
asked about shared objects for working

00:11:36,340 --> 00:11:40,890
in linux kernel module access other

00:11:39,100 --> 00:11:45,280
kernel modules everything's great

00:11:40,890 --> 00:11:47,190
windows during a kernel macaron export

00:11:45,280 --> 00:11:51,730
drivers all that stuff goes together

00:11:47,190 --> 00:11:59,260
RTX yes no dll's different entry points

00:11:51,730 --> 00:12:02,710
etc but we can still fix this sort of we

00:11:59,260 --> 00:12:06,720
can supply our own R and s system

00:12:02,710 --> 00:12:11,170
function 0 3 6 is available and for the

00:12:06,720 --> 00:12:15,520
infinite tests I ran of 2

00:12:11,170 --> 00:12:19,090
it always returns 0 so no random numbers

00:12:15,520 --> 00:12:21,940
there most likely solution here is just

00:12:19,090 --> 00:12:24,450
right R and s always return email mem be

00:12:21,940 --> 00:12:24,450
done with it

00:12:27,589 --> 00:12:41,189
so let's move on to the file system

00:12:29,819 --> 00:12:42,899
I know for bare-metal very constrained

00:12:41,189 --> 00:12:44,879
systems we probably don't have a file

00:12:42,899 --> 00:12:47,790
system most likely we're just going to

00:12:44,879 --> 00:12:51,239
put our data into memory it's at address

00:12:47,790 --> 00:12:53,040
whatever zip through it but here's the

00:12:51,239 --> 00:12:57,199
basically equivalent of what the file

00:12:53,040 --> 00:12:59,459
system specification says for file size

00:12:57,199 --> 00:13:00,899
they say we're gonna call stab we're

00:12:59,459 --> 00:13:04,980
gonna get the sizeof function and return

00:13:00,899 --> 00:13:07,230
it so for RTX this winds up giving us

00:13:04,980 --> 00:13:10,139
eight unresolved externals when using

00:13:07,230 --> 00:13:12,480
the windows SDK this is all interesting

00:13:10,139 --> 00:13:14,639
because if you looked at this

00:13:12,480 --> 00:13:17,069
implementation you'd find that fine

00:13:14,639 --> 00:13:19,589
clothes happens to be in an unnamed

00:13:17,069 --> 00:13:22,619
namespace with a couple of structs and

00:13:19,589 --> 00:13:25,910
tech dips that aren't even used so we

00:13:22,619 --> 00:13:28,559
have a false dependency peak named pipe

00:13:25,910 --> 00:13:34,769
we might want to stat a pipe as well as

00:13:28,559 --> 00:13:37,049
a file so it's in there to stat if that

00:13:34,769 --> 00:13:38,369
were the only problem and may work

00:13:37,049 --> 00:13:41,850
around it but there's more

00:13:38,369 --> 00:13:43,290
we have no environment either so we have

00:13:41,850 --> 00:13:45,809
no current working directory which means

00:13:43,290 --> 00:13:51,449
we have no relative file paths we have

00:13:45,809 --> 00:13:54,540
no directory traversals and on and on in

00:13:51,449 --> 00:13:56,549
the standard level tightest winners a

00:13:54,540 --> 00:13:59,839
few others came up with this proposal to

00:13:56,549 --> 00:14:02,489
say file systems in general or a problem

00:13:59,839 --> 00:14:05,009
we might want to do some user injection

00:14:02,489 --> 00:14:07,470
file systems for testing I talked to

00:14:05,009 --> 00:14:10,079
Titus in Toronto and and there's a

00:14:07,470 --> 00:14:11,669
possibility whether I implement a full

00:14:10,079 --> 00:14:13,439
file system specification or something

00:14:11,669 --> 00:14:20,549
like this if I really want those things

00:14:13,439 --> 00:14:22,410
to work still up in the air path another

00:14:20,549 --> 00:14:27,329
part of the file system that's part of

00:14:22,410 --> 00:14:30,749
our vocabulary in some respects for 2012

00:14:27,329 --> 00:14:35,129
2013 Microsoft shipped an implementation

00:14:30,749 --> 00:14:37,559
of path that was just pre technical

00:14:35,129 --> 00:14:39,030
specification the character type was

00:14:37,559 --> 00:14:46,280
char

00:14:39,030 --> 00:14:51,000
header only path worked well 2015-2017

00:14:46,280 --> 00:14:53,970
got a rewrite and now we have this

00:14:51,000 --> 00:14:55,860
dependency on some external code the

00:14:53,970 --> 00:14:59,130
external code winds up bringing in lots

00:14:55,860 --> 00:15:00,560
and lots of file system related api's

00:14:59,130 --> 00:15:06,170
from windows they just aren't available

00:15:00,560 --> 00:15:09,420
so no file system functions no path

00:15:06,170 --> 00:15:18,870
we're back to probably mapping files

00:15:09,420 --> 00:15:20,340
into memory and going from there yes

00:15:18,870 --> 00:15:22,230
Marshall was making comments about not

00:15:20,340 --> 00:15:25,290
having a file system having file system

00:15:22,230 --> 00:15:33,260
functions fail is perfectly within the

00:15:25,290 --> 00:15:36,360
standard correct all right

00:15:33,260 --> 00:15:43,410
random numbers file system how about

00:15:36,360 --> 00:15:47,220
threading anybody want to guess how well

00:15:43,410 --> 00:15:48,930
threading is supported there's a pretty

00:15:47,220 --> 00:15:50,250
simple example we're just gonna create a

00:15:48,930 --> 00:15:53,940
thread that does nothing and we're gonna

00:15:50,250 --> 00:15:57,810
join on it yeah so for 2012 we wind up

00:15:53,940 --> 00:16:00,480
with 17 unresolved externals you got a

00:15:57,810 --> 00:16:02,910
little better for 2017 Microsoft changes

00:16:00,480 --> 00:16:04,620
their runtime from using concurrency

00:16:02,910 --> 00:16:06,200
their own concurrence to runtime to

00:16:04,620 --> 00:16:09,660
making correct operating system calls

00:16:06,200 --> 00:16:13,320
still a lot of unresolved externals if

00:16:09,660 --> 00:16:16,100
you deep down in the layers of the

00:16:13,320 --> 00:16:19,770
Microsoft runtime you'll see that

00:16:16,100 --> 00:16:22,710
creating a thread winds up being to do

00:16:19,770 --> 00:16:25,260
some sort of synchronization its thread

00:16:22,710 --> 00:16:27,960
creation level so it's got mutexes and

00:16:25,260 --> 00:16:32,700
condition variables that are going on

00:16:27,960 --> 00:16:34,920
and r-tx has a history of about 20 years

00:16:32,700 --> 00:16:36,780
and they never had the need for a

00:16:34,920 --> 00:16:40,020
condition variable so immediately that

00:16:36,780 --> 00:16:42,270
one's out mutex they implement the

00:16:40,020 --> 00:16:44,700
Windows api's from you text but there's

00:16:42,270 --> 00:16:47,960
something else going on there that makes

00:16:44,700 --> 00:16:51,020
that one problematic as well

00:16:47,960 --> 00:16:55,880
okay handle we're in the kernel we don't

00:16:51,020 --> 00:16:58,000
duplicate handles it's just the thing so

00:16:55,880 --> 00:17:01,100
that's a problem as well

00:16:58,000 --> 00:17:05,720
boost though we have to congratulate

00:17:01,100 --> 00:17:08,170
Vincent de for his work only 300

00:17:05,720 --> 00:17:11,020
resolved externals for the same example

00:17:08,170 --> 00:17:15,560
the first one though is actually

00:17:11,020 --> 00:17:17,900
available in our TX and the second one

00:17:15,560 --> 00:17:20,330
we want to know how many processors that

00:17:17,900 --> 00:17:21,980
we could use for currency so we get

00:17:20,330 --> 00:17:23,690
calling to get logical processor

00:17:21,980 --> 00:17:28,520
information the third one's kind of

00:17:23,690 --> 00:17:32,300
interesting local free down in the

00:17:28,520 --> 00:17:34,820
system error when we call a message for

00:17:32,300 --> 00:17:36,140
system error category it winds up

00:17:34,820 --> 00:17:37,730
needing to call format message on

00:17:36,140 --> 00:17:40,130
Windows to take the error code and get a

00:17:37,730 --> 00:17:42,080
message back and if you don't pre

00:17:40,130 --> 00:17:45,290
allocate the memory that function will

00:17:42,080 --> 00:17:50,230
allocate it for you if it does that then

00:17:45,290 --> 00:17:52,160
you have to call local free okay

00:17:50,230 --> 00:17:54,170
Microsoft and their implementation

00:17:52,160 --> 00:17:57,980
though does something a little

00:17:54,170 --> 00:18:00,920
differently they go ahead and

00:17:57,980 --> 00:18:05,900
pre-allocate the memory and they do it

00:18:00,920 --> 00:18:07,550
twice first time is a narrow allocation

00:18:05,900 --> 00:18:10,670
the second time they're actually calling

00:18:07,550 --> 00:18:13,760
format message W so you have what UW

00:18:10,670 --> 00:18:20,560
chars convert it to narrow and on down

00:18:13,760 --> 00:18:28,580
the chain okay so we're still in threads

00:18:20,560 --> 00:18:32,360
stacks windows kernel 12 and 24 k RT x

00:18:28,580 --> 00:18:37,220
8k very small amount of work that we can

00:18:32,360 --> 00:18:41,110
do in there although quite powerful

00:18:37,220 --> 00:18:41,110
amount of work if you think about it

00:18:42,370 --> 00:18:50,030
currently for thread and the standard we

00:18:48,770 --> 00:18:52,610
have no way of actually changing the

00:18:50,030 --> 00:18:55,190
stack and there's at least two proposals

00:18:52,610 --> 00:18:58,010
to talk about at least exploring the

00:18:55,190 --> 00:19:01,100
idea of are there requirements that we

00:18:58,010 --> 00:19:04,490
should capture and do things to expand

00:19:01,100 --> 00:19:05,480
on our capabilities with threatens other

00:19:04,490 --> 00:19:09,289
problems that we have here there's no

00:19:05,480 --> 00:19:12,080
start there's no stack guard pages so if

00:19:09,289 --> 00:19:17,240
you've got 8k 16 K whatever you go off

00:19:12,080 --> 00:19:21,580
the end of it you can keep going alright

00:19:17,240 --> 00:19:24,980
since this is Windows Visual C++ r-tx

00:19:21,580 --> 00:19:26,450
from a testing standpoint we can jump

00:19:24,980 --> 00:19:28,070
back over to Windows and create our

00:19:26,450 --> 00:19:31,429
threads with this stack size parameter

00:19:28,070 --> 00:19:33,919
reservation so when we say 16k 32k

00:19:31,429 --> 00:19:37,090
whatever you do get a guard page on

00:19:33,919 --> 00:19:40,279
windows so you can test if you go over

00:19:37,090 --> 00:19:42,590
exception pops up you know I need to

00:19:40,279 --> 00:19:45,919
create my threads with a larger stack

00:19:42,590 --> 00:19:48,019
size likewise there's no memory

00:19:45,919 --> 00:19:51,200
protection so if everyone's ever dug

00:19:48,019 --> 00:19:53,029
into address sanitizer you'll see that

00:19:51,200 --> 00:19:55,159
at some point it's doing something to

00:19:53,029 --> 00:20:00,159
manipulate the pages in memory to make

00:19:55,159 --> 00:20:00,159
them read-only not gonna work here

00:20:01,059 --> 00:20:09,649
alright so summary on RT x and c++

00:20:05,990 --> 00:20:12,590
concurrency Atomics and lock guards work

00:20:09,649 --> 00:20:20,480
really well just about everything else

00:20:12,590 --> 00:20:23,889
very problematic Igor was supposed to be

00:20:20,480 --> 00:20:25,820
here co-routines again very problematic

00:20:23,889 --> 00:20:28,240
the compiler is going to have to

00:20:25,820 --> 00:20:31,700
generate calls behind the scenes for you

00:20:28,240 --> 00:20:37,159
just won't work call once I'm listing

00:20:31,700 --> 00:20:39,429
here is being unknown because it should

00:20:37,159 --> 00:20:39,429
work

00:20:42,510 --> 00:20:49,559
we're going to investigate that a little

00:20:44,130 --> 00:20:53,160
bit more a very simple example we have a

00:20:49,559 --> 00:20:58,070
function with a static and we have to do

00:20:53,160 --> 00:21:00,720
constructor call if you compiled this in

00:20:58,070 --> 00:21:02,660
twenty twelve let's say you get

00:21:00,720 --> 00:21:05,010
something like this disassembling

00:21:02,660 --> 00:21:06,900
there's two function calls in there once

00:21:05,010 --> 00:21:14,040
to the constructor the other is to add

00:21:06,900 --> 00:21:17,880
exit not a lot going on however in 2015

00:21:14,040 --> 00:21:20,429
and the default was at it thread-safe

00:21:17,880 --> 00:21:21,780
and it if you look closely at this

00:21:20,429 --> 00:21:24,450
disassembly you'll see that there's an

00:21:21,780 --> 00:21:26,520
it thread header and then a knit thread

00:21:24,450 --> 00:21:31,350
footer what's going on we're also

00:21:26,520 --> 00:21:34,620
accessing TSS lots of weird things going

00:21:31,350 --> 00:21:36,540
on here and in this particular case when

00:21:34,620 --> 00:21:41,460
I tested this the other day it actually

00:21:36,540 --> 00:21:44,490
crashed the application oh good you can

00:21:41,460 --> 00:21:47,390
disable this ZC thread safe and it -

00:21:44,490 --> 00:21:47,390
it's gone

00:21:53,390 --> 00:22:01,710
clocks another of the real-time

00:21:58,940 --> 00:22:03,570
functional areas that everyone has to do

00:22:01,710 --> 00:22:05,250
something with this is pretty much the

00:22:03,570 --> 00:22:09,030
same example that you'll see from Howard

00:22:05,250 --> 00:22:14,340
in it and stack overflow it's in the

00:22:09,030 --> 00:22:18,330
real-time C++ book few other places our

00:22:14,340 --> 00:22:23,280
time duration years 100 nanosecond units

00:22:18,330 --> 00:22:25,680
Windows pretty commonly uses that in

00:22:23,280 --> 00:22:27,420
some cases I've seen people implement

00:22:25,680 --> 00:22:31,470
these clocks using the time step

00:22:27,420 --> 00:22:36,630
counters just an RTT SC for Intel and

00:22:31,470 --> 00:22:39,660
that's great fast access as long as you

00:22:36,630 --> 00:22:42,600
stay on one core you're guaranteed of

00:22:39,660 --> 00:22:44,970
having timing numbers that you can

00:22:42,600 --> 00:22:46,860
believe in once we start going off cores

00:22:44,970 --> 00:22:48,960
then there is no real synchronization

00:22:46,860 --> 00:22:51,570
between these two in the case of having

00:22:48,960 --> 00:22:53,850
windows and this other extension we see

00:22:51,570 --> 00:22:57,180
Windows Start try and synchronize all

00:22:53,850 --> 00:22:58,830
the TS CS and then some point later this

00:22:57,180 --> 00:23:00,600
other operating system starts up and

00:22:58,830 --> 00:23:02,430
decides it wants to synchronize all of

00:23:00,600 --> 00:23:04,380
its cores so now I only have this large

00:23:02,430 --> 00:23:09,390
delta T between two operating systems

00:23:04,380 --> 00:23:11,700
that are sharing the same system there's

00:23:09,390 --> 00:23:15,780
lots of other timing sources in your

00:23:11,700 --> 00:23:19,260
PC's there's the DRAM fresh cloth

00:23:15,780 --> 00:23:24,120
there's the USB clock this one was in

00:23:19,260 --> 00:23:26,670
introduced in about 2004 and gets really

00:23:24,120 --> 00:23:28,050
squirrely even if you have 64-bit

00:23:26,670 --> 00:23:31,050
Windows operating systems a lot of times

00:23:28,050 --> 00:23:32,510
it put it it is put into 32-bit mode and

00:23:31,050 --> 00:23:35,670
[Music]

00:23:32,510 --> 00:23:41,970
it's more expensive to read time values

00:23:35,670 --> 00:23:44,280
from this but they are going to be one

00:23:41,970 --> 00:23:47,310
single clock value all your cores be

00:23:44,280 --> 00:23:48,900
fine we're going to go through a little

00:23:47,310 --> 00:23:51,660
bit the implementation that I was

00:23:48,900 --> 00:23:55,680
working on for this many years ago and

00:23:51,660 --> 00:23:58,890
this implementation took the view of I'm

00:23:55,680 --> 00:24:02,400
in the kernel obviously nobody else is

00:23:58,890 --> 00:24:04,140
using this so I'm going to enable it and

00:24:02,400 --> 00:24:06,030
when I'm done with it I'm going to

00:24:04,140 --> 00:24:10,500
disable it set it back to zero

00:24:06,030 --> 00:24:12,680
because I can anybody want to guess what

00:24:10,500 --> 00:24:19,470
happened

00:24:12,680 --> 00:24:22,530
Odin so I'll give you a helper here

00:24:19,470 --> 00:24:24,120
there's two operating systems I just

00:24:22,530 --> 00:24:27,420
made a big assumption that I'm in

00:24:24,120 --> 00:24:29,820
control I really should've done

00:24:27,420 --> 00:24:34,290
something like this if you're familiar

00:24:29,820 --> 00:24:35,730
with the the title of this slide a it

00:24:34,290 --> 00:24:36,630
comes from the movie The Day the Earth

00:24:35,730 --> 00:24:38,580
Stood Still

00:24:36,630 --> 00:24:41,910
so if Windows is over here using this

00:24:38,580 --> 00:24:45,630
particular source for its clock and you

00:24:41,910 --> 00:24:48,840
go and set it to zero you're rebooting

00:24:45,630 --> 00:24:51,780
or you're waiting however long it took

00:24:48,840 --> 00:24:55,280
for your system uptime for the clock to

00:24:51,780 --> 00:24:55,280
come back around and get you out

00:24:58,310 --> 00:25:10,290
exceptions I have absolutely no problems

00:25:04,680 --> 00:25:12,740
with exceptions even in real time part

00:25:10,290 --> 00:25:15,840
that's because of other developers

00:25:12,740 --> 00:25:18,300
certainly being in the kernel I want to

00:25:15,840 --> 00:25:20,850
know when things happen and we have a

00:25:18,300 --> 00:25:26,310
very simple example here an example that

00:25:20,850 --> 00:25:28,140
I see quite a bit the string that's

00:25:26,310 --> 00:25:31,200
passed in once we throw the exception

00:25:28,140 --> 00:25:34,230
needs someplace to live other than well

00:25:31,200 --> 00:25:35,970
it's a string little so a copy winds up

00:25:34,230 --> 00:25:38,190
being made of this string so we wind up

00:25:35,970 --> 00:25:40,980
allocating memory to hold this string

00:25:38,190 --> 00:25:42,450
we've already thrown in we've already in

00:25:40,980 --> 00:25:44,190
an error case we're throwing an

00:25:42,450 --> 00:25:47,070
exception we've probably jumped out of

00:25:44,190 --> 00:25:50,430
our real-time deterministic execution

00:25:47,070 --> 00:25:54,510
Network and allocate memory in this case

00:25:50,430 --> 00:25:56,190
of Windows RT x windows in time your

00:25:54,510 --> 00:25:58,470
memory still basically comes for windows

00:25:56,190 --> 00:26:00,780
it has to know what's available so

00:25:58,470 --> 00:26:03,060
whenever we allocate memory like this we

00:26:00,780 --> 00:26:07,230
have to do some bookkeeping back over to

00:26:03,060 --> 00:26:09,210
Windows as it turns out we have to

00:26:07,230 --> 00:26:11,670
complete all other threads that might be

00:26:09,210 --> 00:26:14,400
ready as well before we do the jump back

00:26:11,670 --> 00:26:15,630
to Windows so now we've had an error

00:26:14,400 --> 00:26:17,940
condition we've decided throw an

00:26:15,630 --> 00:26:19,049
exception we've needed to allocate

00:26:17,940 --> 00:26:22,320
memory

00:26:19,049 --> 00:26:24,239
we just destroyed our timing sequence

00:26:22,320 --> 00:26:30,179
because we executed everything out of

00:26:24,239 --> 00:26:32,610
order pretty bad possible solution just

00:26:30,179 --> 00:26:41,580
create your own exceptions that return

00:26:32,610 --> 00:26:42,720
the string in this case so now we still

00:26:41,580 --> 00:26:44,070
the our case we're gonna throw an

00:26:42,720 --> 00:26:46,590
exception but we're not gonna allocate

00:26:44,070 --> 00:26:50,190
we're still gonna execute an order and

00:26:46,590 --> 00:26:59,039
at least some of what we expected will

00:26:50,190 --> 00:27:00,629
still occur correctly the other part of

00:26:59,039 --> 00:27:05,940
exceptions getting away from the

00:27:00,629 --> 00:27:08,340
standard on Microsoft if you didn't know

00:27:05,940 --> 00:27:10,830
we have set on a handled exception

00:27:08,340 --> 00:27:14,759
filter if you compile everything with

00:27:10,830 --> 00:27:17,730
/tha which is a different mode of

00:27:14,759 --> 00:27:19,470
exception handling you can actually

00:27:17,730 --> 00:27:22,320
catch things like floating point

00:27:19,470 --> 00:27:25,769
exceptions access violations stack

00:27:22,320 --> 00:27:28,799
overflows etc if you also happen to be

00:27:25,769 --> 00:27:30,480
in 64-bit land you can do a pretty good

00:27:28,799 --> 00:27:34,649
job of capturing all your registers and

00:27:30,480 --> 00:27:36,119
your stack back trays so your work for

00:27:34,649 --> 00:27:38,340
liability this would be something that

00:27:36,119 --> 00:27:40,159
you'd want to build in and it's

00:27:38,340 --> 00:27:43,350
something that's very possible

00:27:40,159 --> 00:27:45,960
now I boost just recently Anthony

00:27:43,350 --> 00:27:48,809
provided a nice library to do stack

00:27:45,960 --> 00:27:50,429
traces and there's at least three

00:27:48,809 --> 00:27:53,970
options that are available for Windows

00:27:50,429 --> 00:27:55,499
in this particular case though the first

00:27:53,970 --> 00:27:59,179
two that actually try and do something

00:27:55,499 --> 00:28:03,440
with the stack both want to use comm

00:27:59,179 --> 00:28:05,879
we're in the kernel no calm okay so

00:28:03,440 --> 00:28:10,039
another library that's not available to

00:28:05,879 --> 00:28:10,039
us well unless we just want no hops

00:28:11,659 --> 00:28:17,249
other problems being in the kernel

00:28:13,970 --> 00:28:19,980
completely different loader than what

00:28:17,249 --> 00:28:21,869
Windows is using completely different

00:28:19,980 --> 00:28:23,970
loader from what Visual Studio and all

00:28:21,869 --> 00:28:26,759
the debug tools was expecting to be used

00:28:23,970 --> 00:28:29,970
so now you've got addresses that are

00:28:26,759 --> 00:28:32,820
nowhere close to what your pdb thought

00:28:29,970 --> 00:28:36,659
they were gonna be so in this particular

00:28:32,820 --> 00:28:39,389
case we're having to compute offsets not

00:28:36,659 --> 00:28:42,990
actual addresses and then post-process

00:28:39,389 --> 00:28:58,919
our stack traces with those offset

00:28:42,990 --> 00:29:00,799
information here talked a lot about

00:28:58,919 --> 00:29:05,700
various things within the runtime

00:29:00,799 --> 00:29:07,970
modules really better not cause any more

00:29:05,700 --> 00:29:10,289
heartache here it shouldn't be

00:29:07,970 --> 00:29:11,610
unfortunately right now Microsoft's

00:29:10,289 --> 00:29:14,009
implementation since we're talking about

00:29:11,610 --> 00:29:16,049
visual c++ is only providing the dll

00:29:14,009 --> 00:29:19,190
runtime versions of the interface

00:29:16,049 --> 00:29:21,120
libraries it's not a technical issue

00:29:19,190 --> 00:29:23,429
it's the only thing that they put out

00:29:21,120 --> 00:29:26,399
they're not supporting r-tx so they

00:29:23,429 --> 00:29:35,659
wouldn't see this is a must need to put

00:29:26,399 --> 00:29:38,700
that out but small issue right home so

00:29:35,659 --> 00:29:41,879
we've talked about c++ in this

00:29:38,700 --> 00:29:43,950
particular case there are at least three

00:29:41,879 --> 00:29:47,039
other languages that i've managed to

00:29:43,950 --> 00:29:52,830
stick into the RT x environment fortran

00:29:47,039 --> 00:29:55,529
quite a bit d not so much certainly

00:29:52,830 --> 00:29:58,529
possible and I've had several functions

00:29:55,529 --> 00:30:02,519
from D working but I won't say that I'm

00:29:58,529 --> 00:30:05,100
an expert in D lua though perfectly

00:30:02,519 --> 00:30:08,100
acceptable to link into the kernel in

00:30:05,100 --> 00:30:10,200
this particular case there are some

00:30:08,100 --> 00:30:11,480
pieces of lua that are filesystem

00:30:10,200 --> 00:30:14,759
related

00:30:11,480 --> 00:30:18,509
imagine that and I forget the other

00:30:14,759 --> 00:30:21,000
piece that do create problems but if you

00:30:18,509 --> 00:30:26,820
just want to use a lua script and do

00:30:21,000 --> 00:30:29,309
some things no problems okay so much

00:30:26,820 --> 00:30:31,429
like c++ we're gonna do a little

00:30:29,309 --> 00:30:35,129
dissection here of the Fortran runtime

00:30:31,429 --> 00:30:39,450
math functions fortran's certainly wants

00:30:35,129 --> 00:30:43,169
to use math functions in this case Intel

00:30:39,450 --> 00:30:44,820
Fortran not optimizing the code most of

00:30:43,169 --> 00:30:46,830
the math functions can be satisfied with

00:30:44,820 --> 00:30:49,170
the C runtime there's

00:30:46,830 --> 00:30:55,440
let's say in the order of 10 that can't

00:30:49,170 --> 00:30:57,630
be if you look at strings it has a

00:30:55,440 --> 00:30:59,610
little different story the Intel

00:30:57,630 --> 00:31:02,210
compiler for Fortran generates at least

00:30:59,610 --> 00:31:05,010
3 runtime calls to do comparisons

00:31:02,210 --> 00:31:10,130
concatenations and copying of strings

00:31:05,010 --> 00:31:10,130
and if you've ever worked with Fortran

00:31:10,220 --> 00:31:15,600
things get interesting with strings

00:31:12,300 --> 00:31:18,720
because we want to pad with spaces at

00:31:15,600 --> 00:31:21,330
the end instead of null termination and

00:31:18,720 --> 00:31:24,290
so comparison and concatenation winds up

00:31:21,330 --> 00:31:25,890
with some quite strange algorithms

00:31:24,290 --> 00:31:29,300
compact Fortran

00:31:25,890 --> 00:31:32,070
slightly older than the Intel work

00:31:29,300 --> 00:31:34,110
didn't have any problems as far as

00:31:32,070 --> 00:31:38,810
needing runtime calls it just

00:31:34,110 --> 00:31:38,810
implemented everything right in line

00:31:39,530 --> 00:31:45,960
Fortran compilers recent years have also

00:31:43,320 --> 00:31:48,990
had modes where you can enable bounds

00:31:45,960 --> 00:31:52,260
checking and of course when it bounced

00:31:48,990 --> 00:31:54,210
check violation occurs it wants to call

00:31:52,260 --> 00:31:56,070
into some error reporting function and

00:31:54,210 --> 00:32:01,430
the error reporting function wants to

00:31:56,070 --> 00:32:01,430
pop up a dialog it doesn't happen

00:32:01,700 --> 00:32:08,190
compact Fortran did not have such an

00:32:04,050 --> 00:32:10,950
option so in this particular case taking

00:32:08,190 --> 00:32:14,100
Intel Fortran compiling that into kernel

00:32:10,950 --> 00:32:16,140
provide a few math functions provide the

00:32:14,100 --> 00:32:18,240
three string functions and provide

00:32:16,140 --> 00:32:21,140
little something for error reporting if

00:32:18,240 --> 00:32:25,350
you're in the bounds checking mode and

00:32:21,140 --> 00:32:28,050
speaking of bounds checking with newer

00:32:25,350 --> 00:32:31,260
Intel architectures we have some new

00:32:28,050 --> 00:32:35,090
registers some new instructions and we

00:32:31,260 --> 00:32:35,090
can do some of this in hardware and

00:32:35,180 --> 00:32:38,970
since we're already implementing our own

00:32:37,440 --> 00:32:42,870
thread library evidently we can then

00:32:38,970 --> 00:32:45,570
just add this as well currently if

00:32:42,870 --> 00:32:48,390
you've got an application that's trying

00:32:45,570 --> 00:32:50,280
to use MPX you wind up having something

00:32:48,390 --> 00:32:52,860
else setting out there that's hooking

00:32:50,280 --> 00:32:55,860
the create thread call so it can create

00:32:52,860 --> 00:32:58,520
all the necessary resources to do this

00:32:55,860 --> 00:33:04,300
particular work

00:32:58,520 --> 00:33:06,860
and if you happen to be on GCC it's

00:33:04,300 --> 00:33:11,270
interesting conversation that popped up

00:33:06,860 --> 00:33:13,730
on the mailing list recently I guess I

00:33:11,270 --> 00:33:15,490
have not used this on GCC but there was

00:33:13,730 --> 00:33:18,440
a perception that they were going to

00:33:15,490 --> 00:33:24,860
deprecated this at least one person

00:33:18,440 --> 00:33:28,640
thought so anyway and upon posting I a

00:33:24,860 --> 00:33:32,450
change to deprecated it the response was

00:33:28,640 --> 00:33:34,010
no we aren't deprecating it I don't know

00:33:32,450 --> 00:33:37,130
what's going on so it's it's still an

00:33:34,010 --> 00:33:41,540
GCC if you continued on the mailing list

00:33:37,130 --> 00:33:42,980
trend it said that it is problematic in

00:33:41,540 --> 00:33:46,370
some ways although it did not go into

00:33:42,980 --> 00:33:49,460
details for visual C++ this got added in

00:33:46,370 --> 00:33:52,880
update one and you can give the nice

00:33:49,460 --> 00:33:54,950
command-line option there of D to MPX as

00:33:52,880 --> 00:34:01,970
well as adding the additional resources

00:33:54,950 --> 00:34:08,659
to hook the create thread calls it's a

00:34:01,970 --> 00:34:10,129
performance monitor absolutely none of

00:34:08,659 --> 00:34:12,830
the applications that you might want to

00:34:10,129 --> 00:34:15,080
use or available to you since you're

00:34:12,830 --> 00:34:16,879
running in the kernel that doesn't mean

00:34:15,080 --> 00:34:19,070
that you still can't compile your code

00:34:16,879 --> 00:34:22,429
for Windows compiled for Linux run the

00:34:19,070 --> 00:34:25,369
same applications but hey we're in the

00:34:22,429 --> 00:34:26,659
kernel we can execute read model

00:34:25,369 --> 00:34:29,060
specific register and write model

00:34:26,659 --> 00:34:32,810
specific register so we can actually

00:34:29,060 --> 00:34:35,659
implement our own perf our own until pmu

00:34:32,810 --> 00:34:37,159
your own vtune whatever we want likewise

00:34:35,659 --> 00:34:39,859
you can go out to the memory controller

00:34:37,159 --> 00:34:43,369
and get your bytes read and bytes

00:34:39,859 --> 00:34:45,320
written you can let the cache management

00:34:43,369 --> 00:34:51,440
it you can deal with quality service io

00:34:45,320 --> 00:34:53,540
and on and on and on in the case of

00:34:51,440 --> 00:34:55,909
performance counters you don't really

00:34:53,540 --> 00:34:58,670
have the restrictions that you had with

00:34:55,909 --> 00:35:01,430
the H pets I said earlier in that the

00:34:58,670 --> 00:35:03,830
model specific registers are per CPU so

00:35:01,430 --> 00:35:07,670
we can actually collect per thread per

00:35:03,830 --> 00:35:09,560
CPU whatever we want memory controllers

00:35:07,670 --> 00:35:15,260
a little different

00:35:09,560 --> 00:35:17,270
that's per system if you have one CPU

00:35:15,260 --> 00:35:19,130
its first system so if you've got

00:35:17,270 --> 00:35:24,110
windows and r-tx setting in this system

00:35:19,130 --> 00:35:25,460
you're gonna have those and I'm gonna be

00:35:24,110 --> 00:35:27,910
done really early so I hope you have

00:35:25,460 --> 00:35:30,320
lots of questions

00:35:27,910 --> 00:35:33,110
you didn't ask any while we were going

00:35:30,320 --> 00:35:39,230
through so the purpose of this

00:35:33,110 --> 00:35:41,650
particular talk really was to frighten

00:35:39,230 --> 00:35:44,590
lightning I guess to let you know that

00:35:41,650 --> 00:35:48,020
you know sometimes you're given

00:35:44,590 --> 00:35:51,830
scenarios that really don't work

00:35:48,020 --> 00:35:55,610
together and the Microsoft Visual C++

00:35:51,830 --> 00:35:58,060
team is not supporting r-tx interval

00:35:55,610 --> 00:36:02,030
zero is not really supporting Visual C++

00:35:58,060 --> 00:36:03,800
so it's as a developer I have to do all

00:36:02,030 --> 00:36:05,990
of these little things like providing a

00:36:03,800 --> 00:36:08,990
R and s if I wanted providing a thread

00:36:05,990 --> 00:36:10,910
library if if that's needed modifying

00:36:08,990 --> 00:36:14,600
boost if that's the decision that we

00:36:10,910 --> 00:36:15,800
want to make and with that I will open

00:36:14,600 --> 00:36:17,800
the floor for questions

00:36:15,800 --> 00:36:20,480
[Music]

00:36:17,800 --> 00:36:34,250
Odin will walk up to the microphone and

00:36:20,480 --> 00:36:37,510
ask his question you mentioned that you

00:36:34,250 --> 00:36:41,870
are testing by compiling to Windows

00:36:37,510 --> 00:36:45,320
cropper that has a page guard to detect

00:36:41,870 --> 00:36:48,050
like stack overflow but two questions

00:36:45,320 --> 00:36:50,930
there if you're doing customizations

00:36:48,050 --> 00:36:52,760
like like you know swapping out calls to

00:36:50,930 --> 00:36:56,260
dll's or kernels or whatever you're not

00:36:52,760 --> 00:36:59,240
executing the same code for one and

00:36:56,260 --> 00:37:01,970
especially in light of exceptions you're

00:36:59,240 --> 00:37:04,130
like you're probably not following all

00:37:01,970 --> 00:37:06,650
theoretical possible paths so how are

00:37:04,130 --> 00:37:09,440
you sure that you saw a Mac step that so

00:37:06,650 --> 00:37:12,940
the first part if I'm testing in Windows

00:37:09,440 --> 00:37:17,120
I'm not exactly testing what I'm running

00:37:12,940 --> 00:37:21,050
absolutely correct and I will say that I

00:37:17,120 --> 00:37:23,830
spend quite a bit of time trying to make

00:37:21,050 --> 00:37:26,960
both environments as close as possible

00:37:23,830 --> 00:37:28,670
so that I can say that I am executing as

00:37:26,960 --> 00:37:31,390
many of the code paths that I would in

00:37:28,670 --> 00:37:36,050
both environments the second part was

00:37:31,390 --> 00:37:38,390
like ROS that could potentially be you

00:37:36,050 --> 00:37:41,570
know thinking Machiavellian case a

00:37:38,390 --> 00:37:44,000
longer exception sorry a deeper stack

00:37:41,570 --> 00:37:47,630
than if you didn't throw or if you have

00:37:44,000 --> 00:37:50,420
some surely weird yeah so you know you'd

00:37:47,630 --> 00:37:52,370
like to say the post initialization

00:37:50,420 --> 00:37:55,760
absolutely no exceptions are ever gonna

00:37:52,370 --> 00:37:58,190
occur right and so our call stacks will

00:37:55,760 --> 00:37:59,690
always be the same and our timing

00:37:58,190 --> 00:38:03,770
information will always be the same it

00:37:59,690 --> 00:38:08,930
will always work the way it's supposed

00:38:03,770 --> 00:38:12,310
to no that's not the case some people

00:38:08,930 --> 00:38:15,420
will use exceptions for flow control

00:38:12,310 --> 00:38:15,420
[Music]

00:38:16,180 --> 00:38:21,350
very important to monitor the system I

00:38:18,790 --> 00:38:23,540
mean if you're not monitoring you don't

00:38:21,350 --> 00:38:25,720
know that somebody has done these type

00:38:23,540 --> 00:38:28,400
of things so being a library developer

00:38:25,720 --> 00:38:30,260
I'm not going to be reviewing millions

00:38:28,400 --> 00:38:32,750
of lines of code to know where somebody

00:38:30,260 --> 00:38:36,380
actually decided to throw I can report

00:38:32,750 --> 00:38:39,290
than an exception occurred I can provide

00:38:36,380 --> 00:38:40,910
the framework so that all of the timing

00:38:39,290 --> 00:38:42,560
is always being done so it's constantly

00:38:40,910 --> 00:38:44,690
monitoring the system to know if

00:38:42,560 --> 00:38:47,300
something is executing not the way we

00:38:44,690 --> 00:38:51,080
expected it to you that's pretty much my

00:38:47,300 --> 00:38:55,130
answer is at some point everybody has to

00:38:51,080 --> 00:38:57,680
get on board and accept that if you're

00:38:55,130 --> 00:38:59,410
throwing exceptions you're you're

00:38:57,680 --> 00:39:03,880
starting to go outside the bounds of

00:38:59,410 --> 00:39:03,880
what the system was intended to you

00:39:05,990 --> 00:39:11,900
yes Jeff did I understand you to say

00:39:09,560 --> 00:39:15,349
that you're using Fortran in kernel mode

00:39:11,900 --> 00:39:16,640
and if so what was the application so 20

00:39:15,349 --> 00:39:20,390
years of flight simulation there's

00:39:16,640 --> 00:39:24,140
there's even another 20 years of Fortran

00:39:20,390 --> 00:39:26,480
code out there yeah lots and lots of

00:39:24,140 --> 00:39:31,000
Fortran codes that when you start

00:39:26,480 --> 00:39:35,119
talking about having an aerodynamicist

00:39:31,000 --> 00:39:37,130
program who's still in those Fortran the

00:39:35,119 --> 00:39:39,020
execution environment has been given to

00:39:37,130 --> 00:39:41,089
them they were totally unaware of that

00:39:39,020 --> 00:39:43,369
they compiled the Fortran code it

00:39:41,089 --> 00:39:48,890
produces an object file it gets linked

00:39:43,369 --> 00:39:50,570
into something and off we go if you

00:39:48,890 --> 00:39:52,339
switch to something like MATLAB instead

00:39:50,570 --> 00:39:54,580
of programming directly in Fortran then

00:39:52,339 --> 00:40:00,890
you've got you know super code bloat and

00:39:54,580 --> 00:40:03,410
other issues but as Marshall was

00:40:00,890 --> 00:40:04,760
commenting and once you start going

00:40:03,410 --> 00:40:06,680
through code generators that produce

00:40:04,760 --> 00:40:07,910
lots of code then you have a whole other

00:40:06,680 --> 00:40:15,710
set of problems

00:40:07,910 --> 00:40:17,480
so yes Fortran definitely it's in 20

00:40:15,710 --> 00:40:21,410
years it's been trending away from

00:40:17,480 --> 00:40:24,530
Fortran more people are more people view

00:40:21,410 --> 00:40:28,240
Fortran as being a dead language and so

00:40:24,530 --> 00:40:30,230
from a personal standpoint they say I

00:40:28,240 --> 00:40:37,609
want to do something that's more modern

00:40:30,230 --> 00:40:40,730
I want to use C++ yes sir just curious I

00:40:37,609 --> 00:40:43,490
mean in Windows and tours to deal with

00:40:40,730 --> 00:40:45,290
long cold stacks or sometimes when like

00:40:43,490 --> 00:40:47,480
in case of file systems or networking

00:40:45,290 --> 00:40:50,089
it's hard to control how deep gonna be

00:40:47,480 --> 00:40:53,030
stack they introduced you can request

00:40:50,089 --> 00:40:54,740
another stack as long as you control

00:40:53,030 --> 00:41:01,220
those points where they could get expand

00:40:54,740 --> 00:41:08,570
you could do that so dealing with the

00:41:01,220 --> 00:41:10,430
stack yeah pretty much you can do

00:41:08,570 --> 00:41:14,480
whatever you want to if I had wanted to

00:41:10,430 --> 00:41:15,980
I could have put in my own code that

00:41:14,480 --> 00:41:18,560
detected how far we're going the stack

00:41:15,980 --> 00:41:20,769
oh we're about to cross a boundary let's

00:41:18,560 --> 00:41:23,150
do something else he

00:41:20,769 --> 00:41:27,229
but that gets back to Odin this question

00:41:23,150 --> 00:41:28,940
about what are we testing do I want to

00:41:27,229 --> 00:41:30,559
produce more and more code that I have

00:41:28,940 --> 00:41:33,259
to test it may be different between the

00:41:30,559 --> 00:41:36,019
two environments or do I want to sort of

00:41:33,259 --> 00:41:38,829
do some faith here and say I will test

00:41:36,019 --> 00:41:41,660
it in Windows I will have the stat guard

00:41:38,829 --> 00:41:44,029
once I've got results then I will switch

00:41:41,660 --> 00:41:46,819
back over now we start talking about a

00:41:44,029 --> 00:41:50,529
flight simulator switches all over the

00:41:46,819 --> 00:41:53,059
cockpit you can't test everything I

00:41:50,529 --> 00:41:54,650
probably missed this part but when

00:41:53,059 --> 00:41:56,089
you're saying switch back between what

00:41:54,650 --> 00:41:59,289
two environments I switch in user mode

00:41:56,089 --> 00:42:01,690
and kernel mode or Linux and windows so

00:41:59,289 --> 00:42:04,069
Windows would certainly be user mode

00:42:01,690 --> 00:42:06,650
most of what I was talking about those

00:42:04,069 --> 00:42:09,589
dealing with kernel mode yeah so if I'm

00:42:06,650 --> 00:42:12,709
in kernel mode I can manipulate the

00:42:09,589 --> 00:42:16,190
thread block however I wanted to and

00:42:12,709 --> 00:42:18,979
replaced X and do much what I warranty I

00:42:16,190 --> 00:42:21,380
don't want to do that but it's a

00:42:18,979 --> 00:42:23,420
standard API now it's not that you have

00:42:21,380 --> 00:42:27,349
to do that it's just it's a standard API

00:42:23,420 --> 00:42:33,079
in Windows within the Linux and Linux

00:42:27,349 --> 00:42:41,170
okay thank you the other side of the

00:42:33,079 --> 00:42:41,170
room can ask questions too yes sir

00:42:46,449 --> 00:42:57,829
Cortines so a cover tune to the user

00:42:56,509 --> 00:43:02,630
looks like a normal function would you

00:42:57,829 --> 00:43:05,779
say I mean you don't see any explicit

00:43:02,630 --> 00:43:08,589
calls to anything - well you've got the

00:43:05,779 --> 00:43:11,569
awaits and yields and things like that

00:43:08,589 --> 00:43:17,949
what the compiler generates for those

00:43:11,569 --> 00:43:17,949
particular spots and allocation yes

00:43:17,970 --> 00:43:23,280
so this borders more into the business

00:43:21,700 --> 00:43:28,480
side not the technical side in that

00:43:23,280 --> 00:43:31,090
curry teens is quite new when we talk

00:43:28,480 --> 00:43:36,490
about a real-time system we we tend back

00:43:31,090 --> 00:43:38,170
into the the old beliefs that o only C

00:43:36,490 --> 00:43:40,360
can be used I've got this legacy

00:43:38,170 --> 00:43:43,690
compiler that's never being updated on

00:43:40,360 --> 00:43:45,940
and on and on the operating system that

00:43:43,690 --> 00:43:50,550
I was showing and talking about r-tx it

00:43:45,940 --> 00:43:52,540
tends to lag behind so even if I was

00:43:50,550 --> 00:43:53,980
using Co routines

00:43:52,540 --> 00:43:55,780
there is a very good chance that

00:43:53,980 --> 00:43:57,580
whatever run time calls we're needed to

00:43:55,780 --> 00:43:59,440
make that Co team work weren't going to

00:43:57,580 --> 00:44:02,250
be available so you would get unresolved

00:43:59,440 --> 00:44:02,250
externals as well

00:44:29,820 --> 00:44:34,120
so I I was hoping that Gore was going to

00:44:32,410 --> 00:44:36,850
be here so that we could have a little

00:44:34,120 --> 00:44:40,330
more discussion on that if you want to

00:44:36,850 --> 00:44:42,610
talk to me tomorrow the rest of the week

00:44:40,330 --> 00:44:48,310
I'll cut something up and give you a

00:44:42,610 --> 00:44:50,100
more definitive answer yes sir you

00:44:48,310 --> 00:44:53,080
mentioned in the beginning that you were

00:44:50,100 --> 00:44:57,190
working in like kernel-mode

00:44:53,080 --> 00:45:00,130
callbacks or I accuse so for the

00:44:57,190 --> 00:45:01,870
interrupt handlers yeah I don't know how

00:45:00,130 --> 00:45:04,690
the Windows kernel works but don't you

00:45:01,870 --> 00:45:07,710
have like a really hard deadline of how

00:45:04,690 --> 00:45:12,670
much time you can or you know how much

00:45:07,710 --> 00:45:13,900
how long you can take in a so from the

00:45:12,670 --> 00:45:16,870
window side where general purpose

00:45:13,900 --> 00:45:19,050
operating system we don't want to delay

00:45:16,870 --> 00:45:23,200
we wouldn't want to give an unresponsive

00:45:19,050 --> 00:45:25,030
environment to a human user most of what

00:45:23,200 --> 00:45:27,730
I've been talking about for flight

00:45:25,030 --> 00:45:30,790
simulation there's no real user involved

00:45:27,730 --> 00:45:34,150
as far as through a GUI we're processing

00:45:30,790 --> 00:45:37,480
i/o we're computing equations of motion

00:45:34,150 --> 00:45:41,500
etc so in that particular case the

00:45:37,480 --> 00:45:44,860
interrupts are still an issue we

00:45:41,500 --> 00:45:46,360
certainly don't want to delay some of

00:45:44,860 --> 00:45:47,920
our execution because we're handling

00:45:46,360 --> 00:45:52,980
interrupts and I think that really gets

00:45:47,920 --> 00:45:55,600
back to knowing the system and I can say

00:45:52,980 --> 00:45:57,610
writing your own network stack writing

00:45:55,600 --> 00:45:59,500
your own network drivers when somebody

00:45:57,610 --> 00:46:00,220
plugs in another system on your network

00:45:59,500 --> 00:46:02,320
and all the sudden you're getting

00:46:00,220 --> 00:46:04,480
spanning trees and other things if

00:46:02,320 --> 00:46:06,040
you're not detecting those things all

00:46:04,480 --> 00:46:09,250
you know is your system sort of becomes

00:46:06,040 --> 00:46:12,370
unresponsive so again that gets back to

00:46:09,250 --> 00:46:14,470
my response about we're monitoring these

00:46:12,370 --> 00:46:16,150
things we see oh all the sudden we've

00:46:14,470 --> 00:46:18,090
got more interrupts per second all of a

00:46:16,150 --> 00:46:20,950
sudden our interrupts time has shot up

00:46:18,090 --> 00:46:23,310
something's going on and something needs

00:46:20,950 --> 00:46:27,580
to be done it's kind of funny because

00:46:23,310 --> 00:46:30,100
when you report these things saying that

00:46:27,580 --> 00:46:32,620
hey you know what somebody is sending me

00:46:30,100 --> 00:46:35,560
art every now and then but you know that

00:46:32,620 --> 00:46:36,880
systems not on this network some people

00:46:35,560 --> 00:46:39,370
sort of take offense to that it's like

00:46:36,880 --> 00:46:40,300
well you know I'm using the operating

00:46:39,370 --> 00:46:43,660
system that everybody

00:46:40,300 --> 00:46:45,340
else is using you're not and you're the

00:46:43,660 --> 00:46:50,950
person that's telling me I'm in trouble

00:46:45,340 --> 00:46:53,110
and it's like yes because you are does

00:46:50,950 --> 00:46:56,920
that answer your question enough pretty

00:46:53,110 --> 00:47:02,110
much yeah I guess one sort of variation

00:46:56,920 --> 00:47:06,010
on it like how do you reason about you

00:47:02,110 --> 00:47:11,470
know longest theoretical processor so

00:47:06,010 --> 00:47:12,820
worst case execution I think some of the

00:47:11,470 --> 00:47:14,320
people that I've worked with say that I

00:47:12,820 --> 00:47:19,900
just sort of walk out and put my hands

00:47:14,320 --> 00:47:24,730
on systems and go yeah it's good but

00:47:19,900 --> 00:47:29,980
that's not what should happen in some

00:47:24,730 --> 00:47:33,220
cases there are systems that are so the

00:47:29,980 --> 00:47:39,520
flight simulation itself is much more

00:47:33,220 --> 00:47:42,220
tolerant let's say of higher jitter the

00:47:39,520 --> 00:47:44,020
systems that are much higher frequency

00:47:42,220 --> 00:47:45,730
that have hardware in the loop they

00:47:44,020 --> 00:47:48,580
aren't what we're running the same

00:47:45,730 --> 00:47:51,670
software in both cases so we sort of

00:47:48,580 --> 00:47:54,910
used that hardware very intolerant

00:47:51,670 --> 00:47:56,740
system as our baseline and if we can do

00:47:54,910 --> 00:47:59,740
that one then everything else should

00:47:56,740 --> 00:48:01,180
fall out from there okay but it's still

00:47:59,740 --> 00:48:05,820
just guessing and then testing

00:48:01,180 --> 00:48:10,780
essentially yeah yeah okay yes in tests

00:48:05,820 --> 00:48:12,520
yes yeah yeah I feel your pain I mean I

00:48:10,780 --> 00:48:14,980
work on a lot of strange consoles and

00:48:12,520 --> 00:48:17,380
things and our os's are not really

00:48:14,980 --> 00:48:20,530
standard and we end up with similar

00:48:17,380 --> 00:48:25,630
issues here and there about using fancy

00:48:20,530 --> 00:48:28,720
C++ features so interesting talk thank

00:48:25,630 --> 00:48:30,910
you what what do you end up doing about

00:48:28,720 --> 00:48:33,460
much of this stuff is kind of my

00:48:30,910 --> 00:48:35,230
question though are you asking do we

00:48:33,460 --> 00:48:38,670
contribute back to booth so that

00:48:35,230 --> 00:48:42,570
everybody you could do this or like sure

00:48:38,670 --> 00:48:45,880
so for example what do you do about it

00:48:42,570 --> 00:48:48,340
so as far as boost I will say that in

00:48:45,880 --> 00:48:50,050
the past I've talked to plenty of loose

00:48:48,340 --> 00:48:51,950
developers and I've said things like oh

00:48:50,050 --> 00:48:53,960
yeah I don't use boost

00:48:51,950 --> 00:48:56,270
and the example that I showed for booze

00:48:53,960 --> 00:48:58,010
thread actually was worse let's say 10

00:48:56,270 --> 00:49:02,420
years ago there were more in resolved

00:48:58,010 --> 00:49:03,920
externals it's gotten better and that's

00:49:02,420 --> 00:49:06,829
a big generalization I don't use boost

00:49:03,920 --> 00:49:09,440
boost is huge certainly not everything

00:49:06,829 --> 00:49:11,720
in boost uses the operating system so

00:49:09,440 --> 00:49:14,440
there is plenty of boost it could be

00:49:11,720 --> 00:49:21,950
used in this particular environment

00:49:14,440 --> 00:49:24,079
beyond what do I do try and keep the

00:49:21,950 --> 00:49:26,329
hardware as long as possible

00:49:24,079 --> 00:49:28,579
much like a console try and keep the

00:49:26,329 --> 00:49:31,700
compilers the same as long as possible

00:49:28,579 --> 00:49:34,790
which gets back into our oh I'm a new

00:49:31,700 --> 00:49:36,530
developer in school I was using a newer

00:49:34,790 --> 00:49:43,940
version of Visual Studio why aren't we

00:49:36,530 --> 00:49:46,549
using that here problem hardware

00:49:43,940 --> 00:49:52,240
operating system likewise operating

00:49:46,549 --> 00:49:54,619
system we try and keep the same firewall

00:49:52,240 --> 00:49:57,740
flight simulation though a lot of

00:49:54,619 --> 00:49:59,390
military customers so when the

00:49:57,740 --> 00:50:04,339
government says everybody goes to

00:49:59,390 --> 00:50:05,809
Windows 10 if this particular real-time

00:50:04,339 --> 00:50:07,849
extension isn't currently supporting

00:50:05,809 --> 00:50:11,390
Windows 10 it does by the way then

00:50:07,849 --> 00:50:12,829
that's a problem so most most of the

00:50:11,390 --> 00:50:15,470
requirements you can pretty much nail

00:50:12,829 --> 00:50:18,109
down and say much like a gaming console

00:50:15,470 --> 00:50:20,000
this is it I don't have to think about

00:50:18,109 --> 00:50:22,609
other things but then we get those

00:50:20,000 --> 00:50:24,680
things like information assurance cyber

00:50:22,609 --> 00:50:27,200
security that plays a role in

00:50:24,680 --> 00:50:28,579
determining what like ways

00:50:27,200 --> 00:50:31,609
you know contracts people like to come

00:50:28,579 --> 00:50:33,559
out and say much like my example where

00:50:31,609 --> 00:50:36,260
they don't like Windows they could come

00:50:33,559 --> 00:50:40,520
out and say provide us a solution on

00:50:36,260 --> 00:50:44,960
Linux and we can either do a non

00:50:40,520 --> 00:50:48,380
compliant big we can do no bid we can

00:50:44,960 --> 00:50:50,920
say yes we want to do this and make

00:50:48,380 --> 00:50:50,920
everything happen

00:50:53,320 --> 00:51:02,400
we're probably about done ten minutes

00:50:56,400 --> 00:51:02,400
still time for questions nine minutes

00:51:03,000 --> 00:51:09,510
thank you everyone

00:51:04,580 --> 00:51:09,510

YouTube URL: https://www.youtube.com/watch?v=4AMhgkLjVHM


