Title: CppCon 2017: Peter Sommerlad “Mocking Frameworks considered harmful”
Publication date: 2017-10-13
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Software development without test automation can no longer be considered professional. 
However, you might have existing code bases or want to rely on external libraries that may make writing effective and fast unit tests hard or even near to impossible. A typical work-around for these situations is to introduce test stubs for such external dependencies to make your code testable. 

Some propose to use mocking frameworks, such as GoogleMock, together with unit testing frameworks to ease the specification of the replacement objects. These mocking frameworks often come with their own domain-specific language (DSL) to describe the behavior and expected usage of the mock object. In addition to a learning curve, the DSLs often do not help much, when things do not work. The current lack of standardized reflection in addition requires macro trickery making fixing problems even harder. A second issue, is that existing code often must be prepared to suite the mocking frameworks interception mechanism to allow to inject the mock objects. Last but not least test-driven-development (TDD) together with the use of a mocking framework can lead to high coupling, that TDD usually strives to reduce. 


This talk demonstrates "classical" mocking frameworks, shows the problems and demonstrates how Cevelop's Mockator approach can help refactoring existing code to get it under test and how a very simple plain C++ solution can be used instead of complicated mocking framework for unit tests with dependent code replaced by test stubs or mocks. 

Outline: 
* Introduction 
** Fowler's Whisky Warehouse - classic example for Mocking Frameworks in C++ 
* Feathers' Seams: Dependency Injection 
** Refactoring to Object Seams 
** Refactoring to Template Seams 
** Linker Seams 
** Preprocessor Seams as a last resort 
* Problem with "classic" Mocking Frameworks 
* Simpler Mocking with Mockator 
* Why and when you should not Mock 

With a longer slot, more of the underlying test automation theory, based on xunitpatterns.com can be given. 
— 
Peter Sommerlad: IFS Institute for Software, Professor

Prof. Peter Sommerlad is director of IFS Institute for Software at FHO HSR Rapperswil where he inspired the C++ IDE Cevelop. Peter is co-author of the books POSA Vol.1 and Security Patterns. His goal is to make software simpler by Decremental Development: Refactoring software down to 10% its size with better architecture, testability and quality and functionality. Peter is a member of the C++ standardization committee, ACCU, ACM, IEEE Computer Society.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,570 --> 00:00:06,750
i'm peter sollett talk topic today is

00:00:04,589 --> 00:00:10,019
mocking frameworks considered harmful

00:00:06,750 --> 00:00:12,360
and even after I submitted the talk I

00:00:10,019 --> 00:00:15,809
figured out well you could read that in

00:00:12,360 --> 00:00:18,990
a couple of senses and some of them I

00:00:15,809 --> 00:00:22,410
try to list there is it mocking

00:00:18,990 --> 00:00:25,230
frameworks considered harmful or mocking

00:00:22,410 --> 00:00:28,250
frameworks considered harmful or mocking

00:00:25,230 --> 00:00:31,590
in frameworks considered harmful

00:00:28,250 --> 00:00:33,930
by the way for those who are not in the

00:00:31,590 --> 00:00:35,969
ISO sea plasters committee what you see

00:00:33,930 --> 00:00:37,620
in the background is our campus and very

00:00:35,969 --> 00:00:41,930
beautiful town of rapperswil

00:00:37,620 --> 00:00:45,480
in Switzerland that's where makes tunes

00:00:41,930 --> 00:00:47,430
WG 21 meeting will take place so if you

00:00:45,480 --> 00:00:49,350
consider joining these standardization

00:00:47,430 --> 00:00:52,199
committee that's actually one of the

00:00:49,350 --> 00:00:55,140
places to go to the other one is Kona

00:00:52,199 --> 00:01:00,870
Hawaii where we had the meeting this

00:00:55,140 --> 00:01:03,890
spring now as a professor I always want

00:01:00,870 --> 00:01:06,689
to teach something to people and

00:01:03,890 --> 00:01:08,760
considered harmful is something that has

00:01:06,689 --> 00:01:11,970
an ancient meaning in the programming

00:01:08,760 --> 00:01:15,450
era when people started writing about go

00:01:11,970 --> 00:01:19,470
to considered harmful and usually it's

00:01:15,450 --> 00:01:22,590
something a tool that you might overuse

00:01:19,470 --> 00:01:25,020
or use too much we learned yesterday

00:01:22,590 --> 00:01:26,549
from beyond that goto is no longer

00:01:25,020 --> 00:01:28,979
something we use because it's so

00:01:26,549 --> 00:01:30,479
primitive with mocking frameworks I'm

00:01:28,979 --> 00:01:34,439
not really sure of the primitive

00:01:30,479 --> 00:01:36,299
argument actually is the right one I'd

00:01:34,439 --> 00:01:39,540
like to show you when there are useful

00:01:36,299 --> 00:01:42,720
or when the mocking themselves is useful

00:01:39,540 --> 00:01:45,360
and show you some means what's in there

00:01:42,720 --> 00:01:47,579
and what to look out for and that's the

00:01:45,360 --> 00:01:49,619
idea of my talk today and by the way

00:01:47,579 --> 00:01:51,930
this hat if you come next year to wrap a

00:01:49,619 --> 00:01:55,340
spiel I might provide another batch of

00:01:51,930 --> 00:01:55,340
these hats for those who come

00:01:56,450 --> 00:02:03,570
now I usually ask my students questions

00:02:00,810 --> 00:02:05,670
about that so my question is who is

00:02:03,570 --> 00:02:11,130
using and mocking frameworks for writing

00:02:05,670 --> 00:02:18,810
automated tests who is refactoring their

00:02:11,130 --> 00:02:21,269
code often ok let's see if my let's say

00:02:18,810 --> 00:02:23,160
my musings share with your experiences

00:02:21,269 --> 00:02:28,799
and I'm happy to learn otherwise in the

00:02:23,160 --> 00:02:32,910
end a lot of has been written about

00:02:28,799 --> 00:02:35,700
testing and other stuff mainly targeting

00:02:32,910 --> 00:02:39,090
or people from the let's say oh oh ja by

00:02:35,700 --> 00:02:43,799
community actually are exposed to these

00:02:39,090 --> 00:02:45,630
things but the wisdom in these books

00:02:43,799 --> 00:02:48,269
especially these two I was roof I'm

00:02:45,630 --> 00:02:51,810
referring to is actually valuable for a

00:02:48,269 --> 00:02:55,290
c-plus for people as well so there's X

00:02:51,810 --> 00:02:58,440
unit test patterns and X unit stands for

00:02:55,290 --> 00:03:00,810
all these famous unit testing framework

00:02:58,440 --> 00:03:05,220
starting with s unit for small talk back

00:03:00,810 --> 00:03:07,290
and back and J unit by Kent and Eric

00:03:05,220 --> 00:03:11,910
gamma and all the others we have meant

00:03:07,290 --> 00:03:13,980
plenty of those for C++ as well and the

00:03:11,910 --> 00:03:17,250
good thing about these patterns is they

00:03:13,980 --> 00:03:19,440
are language agnostic most often and

00:03:17,250 --> 00:03:21,510
they tell you something about the idea

00:03:19,440 --> 00:03:25,140
and if you read any kind of pattern

00:03:21,510 --> 00:03:27,690
always look for the fine print it's not

00:03:25,140 --> 00:03:29,549
always this is a great solution a good

00:03:27,690 --> 00:03:31,530
pattern description gives you also hints

00:03:29,549 --> 00:03:34,680
about the drawbacks you have to pay for

00:03:31,530 --> 00:03:36,600
if you apply it and that's some of the

00:03:34,680 --> 00:03:38,430
drawbacks that are actually explained in

00:03:36,600 --> 00:03:40,549
the X unit test patterns in the very

00:03:38,430 --> 00:03:44,750
fine print I'd like to point out today

00:03:40,549 --> 00:03:48,120
another very interesting book that is

00:03:44,750 --> 00:03:50,160
that might also be under appreciated is

00:03:48,120 --> 00:03:54,540
working effectively with legacy code by

00:03:50,160 --> 00:03:57,959
Michael feathers and for him legacy code

00:03:54,540 --> 00:04:01,980
is actually code that hat doesn't have

00:03:57,959 --> 00:04:03,810
enough tests and code with our tests is

00:04:01,980 --> 00:04:07,150
bad code and when you says tests he

00:04:03,810 --> 00:04:09,460
means automated tests

00:04:07,150 --> 00:04:11,590
his book is actually about how to get

00:04:09,460 --> 00:04:16,410
stuff on the test and that's where you

00:04:11,590 --> 00:04:19,750
might actually need and appreciate the

00:04:16,410 --> 00:04:23,140
mechanism of mocking and what that is

00:04:19,750 --> 00:04:24,610
let's go to that I'm also referring to

00:04:23,140 --> 00:04:28,030
another article because that's where I

00:04:24,610 --> 00:04:30,880
stole the example I'm using today it's

00:04:28,030 --> 00:04:34,810
by Martin Fowler who's also writing a

00:04:30,880 --> 00:04:37,240
lot of stuff about a jell-o design and

00:04:34,810 --> 00:04:39,130
so on and he says not even about mocks

00:04:37,240 --> 00:04:42,700
aren't stops and I'm stealing his

00:04:39,130 --> 00:04:44,710
example and deliberately because I've

00:04:42,700 --> 00:04:47,640
seen talks about mocking frameworks that

00:04:44,710 --> 00:04:52,600
use this example and I'm trying to

00:04:47,640 --> 00:04:57,510
elaborate on that anybody not knowing

00:04:52,600 --> 00:05:01,180
Martin Fowler by name good

00:04:57,510 --> 00:05:04,420
so the he has an interesting example

00:05:01,180 --> 00:05:07,180
that's quite simple he wants to test an

00:05:04,420 --> 00:05:12,160
order class that relies on a warehouse

00:05:07,180 --> 00:05:13,600
class for fulfilling the order and if

00:05:12,160 --> 00:05:16,600
you consider that it's completely

00:05:13,600 --> 00:05:20,410
unrealistic except for the example that

00:05:16,600 --> 00:05:22,870
use the telescope whiskey to get it from

00:05:20,410 --> 00:05:26,290
the warehouse or a whole batch of

00:05:22,870 --> 00:05:28,350
telescope whiskey bottles and it has

00:05:26,290 --> 00:05:30,640
some interesting design tifa's

00:05:28,350 --> 00:05:32,440
deficiencies that i don't want to show

00:05:30,640 --> 00:05:35,320
you right now and if you can't read the

00:05:32,440 --> 00:05:41,260
diagrams i'm not sure if it really

00:05:35,320 --> 00:05:43,330
eligible there doesn't matter the

00:05:41,260 --> 00:05:45,520
Intendant behavior of the order object

00:05:43,330 --> 00:05:47,290
is if you want to fill an order it asks

00:05:45,520 --> 00:05:50,230
the warehouse do you have enough stuff

00:05:47,290 --> 00:05:52,660
in there and if yes remove it from the

00:05:50,230 --> 00:05:54,490
warehouse and and memorize that the

00:05:52,660 --> 00:05:57,790
order is filled and it's kind of a

00:05:54,490 --> 00:06:00,340
stateful thing if the inventory is not

00:05:57,790 --> 00:06:02,730
sufficient it will just fail to fill the

00:06:00,340 --> 00:06:02,730
order

00:06:03,949 --> 00:06:09,960
now if we just want to test the order

00:06:07,440 --> 00:06:12,090
class without a real warehouse that is

00:06:09,960 --> 00:06:14,340
delivering the telesco and if you run

00:06:12,090 --> 00:06:15,990
the test you don't want to ship the 50

00:06:14,340 --> 00:06:18,120
bottles of telesco that you want to test

00:06:15,990 --> 00:06:22,669
for so that's why you actually want to

00:06:18,120 --> 00:06:26,340
replace that warehouse object with the

00:06:22,669 --> 00:06:28,650
fake object that is actually doing

00:06:26,340 --> 00:06:31,319
nothing or pretending to be a real rare

00:06:28,650 --> 00:06:38,130
house without doing anything useful so

00:06:31,319 --> 00:06:40,770
you want to actually check the order

00:06:38,130 --> 00:06:47,759
class if it behaves like that and you

00:06:40,770 --> 00:06:54,659
want to check if these interactions

00:06:47,759 --> 00:06:57,180
happen as you plant them now let's see

00:06:54,659 --> 00:06:58,710
what we can do about that that's the

00:06:57,180 --> 00:07:03,990
underlying example that I stole from

00:06:58,710 --> 00:07:07,110
Martin if you look at the xunit patterns

00:07:03,990 --> 00:07:10,050
there's a generic diagram that happens

00:07:07,110 --> 00:07:11,849
over and over again and the basic idea

00:07:10,050 --> 00:07:14,430
is when you write a test case you have

00:07:11,849 --> 00:07:16,889
something where you set up the tests you

00:07:14,430 --> 00:07:19,889
exercise the methods of functionality

00:07:16,889 --> 00:07:20,580
that you want to check from the system

00:07:19,889 --> 00:07:24,050
under test

00:07:20,580 --> 00:07:26,580
SUT and then you verify if the test was

00:07:24,050 --> 00:07:28,169
fulfilled that's where you actually have

00:07:26,580 --> 00:07:29,969
a test failure and then you have the

00:07:28,169 --> 00:07:34,159
teardown phase where you actually clean

00:07:29,969 --> 00:07:36,960
up in C++ that teardown phase is usually

00:07:34,159 --> 00:07:40,080
trivial let's address the curly closing

00:07:36,960 --> 00:07:42,240
brace because we have destructors and if

00:07:40,080 --> 00:07:44,990
you have to clear theater on something

00:07:42,240 --> 00:07:47,729
the destructor will take care of that

00:07:44,990 --> 00:07:49,430
for a terminology at least on my slide

00:07:47,729 --> 00:07:55,469
and in the X unit patterns

00:07:49,430 --> 00:07:59,070
SUT is a system under test and the do C

00:07:55,469 --> 00:08:01,889
is the dependent other component in an

00:07:59,070 --> 00:08:04,199
ideal world you can test this system

00:08:01,889 --> 00:08:07,289
under test with our external

00:08:04,199 --> 00:08:10,560
dependencies but if you come like

00:08:07,289 --> 00:08:12,839
microfiber scribes from legacy code that

00:08:10,560 --> 00:08:14,820
doesn't have sufficient tests you will

00:08:12,839 --> 00:08:16,919
actually end up with situations you have

00:08:14,820 --> 00:08:19,620
other components that you repent on

00:08:16,919 --> 00:08:22,319
and now how do you test that you can

00:08:19,620 --> 00:08:24,930
test that on a system level but if the

00:08:22,319 --> 00:08:27,389
other component is slow and let's say

00:08:24,930 --> 00:08:29,669
doing a database or communicating over

00:08:27,389 --> 00:08:32,310
network your tests will run slow and you

00:08:29,669 --> 00:08:40,200
will have a very slow feedback so you

00:08:32,310 --> 00:08:41,940
need to do something about that and that

00:08:40,200 --> 00:08:44,510
gives you one of the situations where

00:08:41,940 --> 00:08:47,240
you want to actually do something about

00:08:44,510 --> 00:08:51,959
replacing that dependent other component

00:08:47,240 --> 00:08:56,190
by a replacement and there several words

00:08:51,959 --> 00:08:58,320
used for that test stop test or mock or

00:08:56,190 --> 00:09:00,089
test dooble and I might use them

00:08:58,320 --> 00:09:03,120
interchangeably and I will give a little

00:09:00,089 --> 00:09:06,570
bit differencing what what a mock is in

00:09:03,120 --> 00:09:09,029
it actually what a stub is so one thing

00:09:06,570 --> 00:09:11,940
is the real object that you're testing

00:09:09,029 --> 00:09:14,310
with which is the dependent of the

00:09:11,940 --> 00:09:16,949
component not the system on the test has

00:09:14,310 --> 00:09:18,959
not an immune istic behavior like how do

00:09:16,949 --> 00:09:25,410
you test something it relies on random

00:09:18,959 --> 00:09:29,250
number or relies on external input like

00:09:25,410 --> 00:09:31,440
the stock market code the real object is

00:09:29,250 --> 00:09:33,930
difficult to set up it might require

00:09:31,440 --> 00:09:37,949
network connections database connections

00:09:33,930 --> 00:09:40,019
or whatever the real object your system

00:09:37,949 --> 00:09:41,699
under test depends on it's hard to

00:09:40,019 --> 00:09:45,360
trigger behavior how do you test for

00:09:41,699 --> 00:09:48,810
let's say file system failures or the

00:09:45,360 --> 00:09:51,810
lock is full failures real object is

00:09:48,810 --> 00:09:53,850
slow this is also something that's a

00:09:51,810 --> 00:09:57,800
problem it can be a problem especially

00:09:53,850 --> 00:10:07,459
if you write software for real Hardware

00:09:57,800 --> 00:10:07,459
beyond just the tip it runs on and like

00:10:08,180 --> 00:10:15,570
automotive or like other control stuff

00:10:12,420 --> 00:10:18,000
then you need to have to do something

00:10:15,570 --> 00:10:20,370
about some of you might be able to test

00:10:18,000 --> 00:10:23,699
your software fast and without actually

00:10:20,370 --> 00:10:25,769
hardware moving around if your software

00:10:23,699 --> 00:10:27,209
still has box you don't want to have the

00:10:25,769 --> 00:10:29,870
hardware and destroy the hardware from

00:10:27,209 --> 00:10:33,250
that real object hairs or

00:10:29,870 --> 00:10:37,490
user interface or it's a user itself

00:10:33,250 --> 00:10:39,620
herself or himself and one thing we're

00:10:37,490 --> 00:10:42,710
mocking actually is interesting about is

00:10:39,620 --> 00:10:47,990
the tests need to know if the real

00:10:42,710 --> 00:10:50,570
object is actually used correct for

00:10:47,990 --> 00:10:55,630
example was a callback triggered or

00:10:50,570 --> 00:10:55,630
things like that or it doesn't yet exist

00:10:56,020 --> 00:11:00,860
if you have a large system you might

00:10:59,000 --> 00:11:02,870
want to write tests for a component that

00:11:00,860 --> 00:11:07,130
it has to rely on some other components

00:11:02,870 --> 00:11:09,400
that are not yet implemented and how do

00:11:07,130 --> 00:11:13,220
you do that

00:11:09,400 --> 00:11:17,020
so the basic idea is actually that you

00:11:13,220 --> 00:11:21,080
replaced this non-existent or missing or

00:11:17,020 --> 00:11:25,610
badly behaving other component by a

00:11:21,080 --> 00:11:28,250
so-called testable a replacement so you

00:11:25,610 --> 00:11:32,150
need to means to actually parameterize

00:11:28,250 --> 00:11:36,620
the system under test with a replacement

00:11:32,150 --> 00:11:38,150
component that's hard to do if this one

00:11:36,620 --> 00:11:40,339
actually in Senshi Eights

00:11:38,150 --> 00:11:44,600
that this other component based on a

00:11:40,339 --> 00:11:47,420
concrete class or uses it like calling

00:11:44,600 --> 00:11:49,610
an operating system function that you

00:11:47,420 --> 00:11:53,240
need to replace because that might do

00:11:49,610 --> 00:11:55,430
i/o so we want to avoid slight slow

00:11:53,240 --> 00:12:04,480
tests and we want to actually be able to

00:11:55,430 --> 00:12:08,450
test this system under test if we and

00:12:04,480 --> 00:12:11,990
only if we want to go to check if the

00:12:08,450 --> 00:12:16,150
system under test actually uses the

00:12:11,990 --> 00:12:19,490
other component correctly that's when

00:12:16,150 --> 00:12:21,589
Jeremy Cyrus called what Cameron calls

00:12:19,490 --> 00:12:24,830
mock object and that's one of the

00:12:21,589 --> 00:12:28,610
aspects of martin fowler's article i was

00:12:24,830 --> 00:12:31,160
referring to you want to actually check

00:12:28,610 --> 00:12:33,230
that the system under test uses this

00:12:31,160 --> 00:12:35,630
other component correctly and you verify

00:12:33,230 --> 00:12:39,610
that in the end that is used correctly

00:12:35,630 --> 00:12:39,610
and that's

00:12:40,160 --> 00:12:47,130
we're mocking comes in so the setup

00:12:43,830 --> 00:12:49,980
actually needs to set up a replacement

00:12:47,130 --> 00:12:53,340
object and this replacement object needs

00:12:49,980 --> 00:12:56,850
to verify if it's used correctly either

00:12:53,340 --> 00:12:58,920
violets use or in the end and the

00:12:56,850 --> 00:13:01,380
verification step in our test case is

00:12:58,920 --> 00:13:03,780
actually doing something useful for the

00:13:01,380 --> 00:13:07,110
final verification that is what what

00:13:03,780 --> 00:13:09,450
mocking is about for those of you have

00:13:07,110 --> 00:13:13,410
who are using mocking frameworks is that

00:13:09,450 --> 00:13:19,640
what you are actually doing some heads

00:13:13,410 --> 00:13:19,640
are going down some waving okay

00:13:20,870 --> 00:13:28,350
now many mocking frameworks actually

00:13:24,120 --> 00:13:32,670
provide you with something that sera

00:13:28,350 --> 00:13:34,800
calls the configurable test tool how do

00:13:32,670 --> 00:13:37,800
we tell a test to be what to return it

00:13:34,800 --> 00:13:40,140
and expect or expect and that's in my

00:13:37,800 --> 00:13:42,720
opinion is an idea that's quite often

00:13:40,140 --> 00:13:46,500
overused in the mocking frameworks that

00:13:42,720 --> 00:13:48,660
you encounter because a lot of the

00:13:46,500 --> 00:13:51,900
mocking frameworks allow you actually to

00:13:48,660 --> 00:13:54,930
set expectations return values while

00:13:51,900 --> 00:13:57,930
configuring that testable or the mock

00:13:54,930 --> 00:14:02,310
and then in the end in the verification

00:13:57,930 --> 00:14:04,740
phase the test tool or some magic will

00:14:02,310 --> 00:14:13,260
actually check if the expectations have

00:14:04,740 --> 00:14:15,960
been met and if you checking

00:14:13,260 --> 00:14:18,330
expectations okay but having everything

00:14:15,960 --> 00:14:21,000
spell out spelling these things out

00:14:18,330 --> 00:14:23,370
that's actually but the where the

00:14:21,000 --> 00:14:25,740
problems might come from and I will give

00:14:23,370 --> 00:14:28,950
you some examples later on so you can

00:14:25,740 --> 00:14:34,560
appreciate my red block there what this

00:14:28,950 --> 00:14:37,260
means so what do we actually get in a

00:14:34,560 --> 00:14:39,270
mocking framework one thing is we need

00:14:37,260 --> 00:14:43,950
to provide something that people

00:14:39,270 --> 00:14:46,710
actually have many names for one fancy

00:14:43,950 --> 00:14:48,450
name is dependency injection and when

00:14:46,710 --> 00:14:50,490
you see that you always think you get

00:14:48,450 --> 00:14:51,059
you get some some kind of shot for

00:14:50,490 --> 00:14:54,089
immuno

00:14:51,059 --> 00:14:56,129
sation or whatever it's not that magic

00:14:54,089 --> 00:14:58,409
it's just provide a parameter to your

00:14:56,129 --> 00:15:02,429
object so you can actually replace what

00:14:58,409 --> 00:15:04,439
you pass in instead of having hard-coded

00:15:02,429 --> 00:15:07,499
dependencies to concrete other stuff

00:15:04,439 --> 00:15:09,419
that are hard to replace so what you

00:15:07,499 --> 00:15:11,669
actually would need to do is what

00:15:09,419 --> 00:15:15,239
Michael feathers calls you introduce a

00:15:11,669 --> 00:15:18,269
seam to make your system and a test more

00:15:15,239 --> 00:15:23,009
testable by being able to replace the

00:15:18,269 --> 00:15:25,619
dependent other component what a mocking

00:15:23,009 --> 00:15:27,509
framework usually then provides very

00:15:25,619 --> 00:15:29,729
often the dependency injection is

00:15:27,509 --> 00:15:31,859
something you have to do yourself or you

00:15:29,729 --> 00:15:33,299
might have tools for refactoring and

00:15:31,859 --> 00:15:36,839
I'll show you some of them that we

00:15:33,299 --> 00:15:38,549
created created for our IDE and then the

00:15:36,839 --> 00:15:42,109
next thing is you actually have to

00:15:38,549 --> 00:15:45,149
replace the dependent other component

00:15:42,109 --> 00:15:48,509
one example is just by a fake object

00:15:45,149 --> 00:15:50,189
that gives pre-defined canned results so

00:15:48,509 --> 00:15:52,649
the system and the tests can be run

00:15:50,189 --> 00:15:55,799
without the real thing and provide

00:15:52,649 --> 00:15:58,619
something useful for the test case if

00:15:55,799 --> 00:15:59,999
there is an interesting interface that

00:15:58,619 --> 00:16:02,069
you want to actually check if it's

00:15:59,999 --> 00:16:03,659
elaborated correctly between the system

00:16:02,069 --> 00:16:06,919
and the test and the other component

00:16:03,659 --> 00:16:10,409
then you might want to trace the calls

00:16:06,919 --> 00:16:13,049
while it's of the that the system under

00:16:10,409 --> 00:16:15,719
test us against the other component the

00:16:13,049 --> 00:16:20,069
testable and then you want to match if

00:16:15,719 --> 00:16:22,279
the calls and the arguments made on the

00:16:20,069 --> 00:16:24,689
other component that is replaced are

00:16:22,279 --> 00:16:27,269
correctly and these are the core

00:16:24,689 --> 00:16:30,989
elements would go into a mocking

00:16:27,269 --> 00:16:38,269
framework and that's what many people

00:16:30,989 --> 00:16:41,909
actually use I've chosen three examples

00:16:38,269 --> 00:16:44,099
there are three mocking frameworks one

00:16:41,909 --> 00:16:45,779
is G mock because it's the most popular

00:16:44,099 --> 00:16:47,459
one and quite ancient one then another

00:16:45,779 --> 00:16:49,919
one that's a little bit more modern C

00:16:47,459 --> 00:16:53,309
plus was 14 ich hab Ian Fowler and

00:16:49,919 --> 00:16:57,659
actually his target I believe a CCU or

00:16:53,309 --> 00:17:01,979
some other event actually triggered me

00:16:57,659 --> 00:17:03,000
giving this talk because trompe l'oeil

00:17:01,979 --> 00:17:05,579
is a

00:17:03,000 --> 00:17:09,900
right framework but using mocking

00:17:05,579 --> 00:17:11,490
frameworks easily makes code that and

00:17:09,900 --> 00:17:13,800
I'll show you that and the third one is

00:17:11,490 --> 00:17:15,959
that actually one of my former students

00:17:13,800 --> 00:17:18,780
created in its massive thesis it's

00:17:15,959 --> 00:17:21,689
called Mercator and it's integrated into

00:17:18,780 --> 00:17:27,689
our civil of our de you might hear me

00:17:21,689 --> 00:17:30,540
speaking about in several occasions now

00:17:27,689 --> 00:17:33,090
the first thing is micro feathers tells

00:17:30,540 --> 00:17:35,460
us introducing a seam so we have

00:17:33,090 --> 00:17:38,460
existing code and we want to make it

00:17:35,460 --> 00:17:40,770
better testable so we actually need to

00:17:38,460 --> 00:17:43,440
do something about where we can alter

00:17:40,770 --> 00:17:45,930
the behavior of our system on the test

00:17:43,440 --> 00:17:49,760
without editing the system under test

00:17:45,930 --> 00:17:49,760
because we want to test the real thing

00:17:49,850 --> 00:17:55,830
there are some mechanisms that Michael

00:17:52,920 --> 00:17:59,370
actually presents the classic power

00:17:55,830 --> 00:18:01,560
which one is a so-called object scene we

00:17:59,370 --> 00:18:04,380
extracted in the face of our dependent

00:18:01,560 --> 00:18:06,870
other components and change our system

00:18:04,380 --> 00:18:09,750
and the tests to just use that interface

00:18:06,870 --> 00:18:15,000
instead of using a concrete component

00:18:09,750 --> 00:18:17,610
and that's the thing that all mocking

00:18:15,000 --> 00:18:19,560
frameworks support but not actually the

00:18:17,610 --> 00:18:21,510
extra interface if you're using language

00:18:19,560 --> 00:18:24,270
like Java where you have a very good

00:18:21,510 --> 00:18:26,370
refactoring infrastructure it's almost

00:18:24,270 --> 00:18:29,010
automatic so you don't have to do a lot

00:18:26,370 --> 00:18:32,450
editing in other languages you might

00:18:29,010 --> 00:18:35,250
need a little bit more things develop

00:18:32,450 --> 00:18:37,620
provide some refactorings to get there

00:18:35,250 --> 00:18:40,470
like extract interface refactoring but

00:18:37,620 --> 00:18:43,590
again you have to introduce a dynamic

00:18:40,470 --> 00:18:49,170
polymorphism to enable that which is not

00:18:43,590 --> 00:18:51,780
always a good idea and C++ code with C++

00:18:49,170 --> 00:18:54,540
in contrast to Java we have something

00:18:51,780 --> 00:18:57,750
that Michael feathers calls compile C

00:18:54,540 --> 00:19:00,720
and we have corresponding refactoring in

00:18:57,750 --> 00:19:04,410
the develop IDE but you can do that by

00:19:00,720 --> 00:19:08,480
hand as well you just make the other

00:19:04,410 --> 00:19:10,740
components type a template parameter and

00:19:08,480 --> 00:19:12,840
provide a default argument for the

00:19:10,740 --> 00:19:14,460
template parameter being the concrete

00:19:12,840 --> 00:19:16,020
other components so you don't have to

00:19:14,460 --> 00:19:19,080
change the

00:19:16,020 --> 00:19:21,840
the codebase route but then you can

00:19:19,080 --> 00:19:23,970
actually compile your system on the test

00:19:21,840 --> 00:19:28,260
with the different template argument

00:19:23,970 --> 00:19:31,050
where you pass in the testable and there

00:19:28,260 --> 00:19:33,570
Michael also shows some more interesting

00:19:31,050 --> 00:19:36,450
scene things in cases that are more

00:19:33,570 --> 00:19:39,930
pathological where you have dependencies

00:19:36,450 --> 00:19:42,210
on system libraries or even more

00:19:39,930 --> 00:19:44,640
interesting things that are very hard to

00:19:42,210 --> 00:19:46,500
replace and there are things like of

00:19:44,640 --> 00:19:49,140
last resort where you can actually use

00:19:46,500 --> 00:19:51,480
the preprocessor to change a function

00:19:49,140 --> 00:19:54,180
name to something else where you can

00:19:51,480 --> 00:19:57,300
replace it or you can use a linker or LD

00:19:54,180 --> 00:20:01,410
preload with the dll to exchange system

00:19:57,300 --> 00:20:03,750
library functions to do so and I won't

00:20:01,410 --> 00:20:05,430
go into those details because let's be

00:20:03,750 --> 00:20:08,550
one beyond what I want to show right now

00:20:05,430 --> 00:20:11,880
so what we actually do is we want to use

00:20:08,550 --> 00:20:14,760
a zipper to be able to replace our

00:20:11,880 --> 00:20:16,980
warehouse object our warehouse class so

00:20:14,760 --> 00:20:18,960
what we actually need to do is extract

00:20:16,980 --> 00:20:21,870
an interface class I called it I

00:20:18,960 --> 00:20:24,090
warehouse write your unit change the

00:20:21,870 --> 00:20:25,980
order that it's using the I warehouse

00:20:24,090 --> 00:20:28,920
instead of the the concrete warehouse

00:20:25,980 --> 00:20:31,980
class the unit tests then will provide a

00:20:28,920 --> 00:20:34,710
mock or stop warehouse that is actually

00:20:31,980 --> 00:20:36,870
used for a specific test only instead of

00:20:34,710 --> 00:20:42,300
the concrete warehouse that might do

00:20:36,870 --> 00:20:46,680
actually the shipping go to just this to

00:20:42,300 --> 00:20:49,860
test the order class anybody done things

00:20:46,680 --> 00:20:54,390
like that for testability okay you're

00:20:49,860 --> 00:20:56,760
all experts while you're here now to

00:20:54,390 --> 00:20:59,340
show off a little bit if we have a

00:20:56,760 --> 00:21:02,550
warehouse with some implementation and

00:20:59,340 --> 00:21:05,940
our order using that warehouse in the

00:21:02,550 --> 00:21:07,830
film member function what you can

00:21:05,940 --> 00:21:09,330
actually do you can call the extract

00:21:07,830 --> 00:21:11,220
interface refactoring and it will

00:21:09,330 --> 00:21:16,320
actually extract the warehouse interface

00:21:11,220 --> 00:21:18,240
the pure virtual functions and make the

00:21:16,320 --> 00:21:21,420
warehouse just implement that interface

00:21:18,240 --> 00:21:23,490
and it will also in the corresponding

00:21:21,420 --> 00:21:25,140
places of the order class changed the

00:21:23,490 --> 00:21:28,920
warehouse to wit the warehouse interface

00:21:25,140 --> 00:21:29,730
so these blue bars show what's actually

00:21:28,920 --> 00:21:31,230
changed

00:21:29,730 --> 00:21:36,810
automatically generated by the

00:21:31,230 --> 00:21:38,940
refactoring and you see it's a toy

00:21:36,810 --> 00:21:41,430
example so in real world code you might

00:21:38,940 --> 00:21:44,030
have let's say slightly more interesting

00:21:41,430 --> 00:21:47,130
effects and it might not work completely

00:21:44,030 --> 00:21:51,020
automatically so but that's the idea

00:21:47,130 --> 00:21:54,330
what and you can do that by hand as well

00:21:51,020 --> 00:21:58,380
for things if you want to have an a

00:21:54,330 --> 00:22:00,330
template extraction we provide an

00:21:58,380 --> 00:22:03,090
extract template parameter refactoring I

00:22:00,330 --> 00:22:05,460
don't show you it and the interesting

00:22:03,090 --> 00:22:09,270
thing about templates if you look back

00:22:05,460 --> 00:22:11,820
here all member functions have been

00:22:09,270 --> 00:22:14,430
given and they are generated as pure

00:22:11,820 --> 00:22:17,460
virtual because they might be used by

00:22:14,430 --> 00:22:19,650
order and if you have as do a

00:22:17,460 --> 00:22:22,290
replacement for that you have to

00:22:19,650 --> 00:22:25,820
implement all of them because if it's

00:22:22,290 --> 00:22:29,670
pure virtual you have to implement it so

00:22:25,820 --> 00:22:32,520
with templates that's a very nice

00:22:29,670 --> 00:22:35,000
feature only what is used needs to

00:22:32,520 --> 00:22:42,030
actually provided by a template argument

00:22:35,000 --> 00:22:46,050
and the compiled seam refactoring

00:22:42,030 --> 00:22:48,600
actually will tell you ok if you see the

00:22:46,050 --> 00:22:50,730
mock warehouse is actually empty if you

00:22:48,600 --> 00:22:53,190
look closely it's a screenshot and it

00:22:50,730 --> 00:22:56,480
will tell you ok you didn't implement

00:22:53,190 --> 00:23:00,270
all of the requirements of functions yet

00:22:56,480 --> 00:23:02,970
and if you do that it will actually

00:23:00,270 --> 00:23:04,830
create the missing member functions for

00:23:02,970 --> 00:23:08,250
you but only those that have been

00:23:04,830 --> 00:23:11,670
actually called by the test case so it

00:23:08,250 --> 00:23:14,070
does actually a analysis how order is

00:23:11,670 --> 00:23:15,840
implemented to figure out what needs to

00:23:14,070 --> 00:23:18,780
be really be provided by the mock

00:23:15,840 --> 00:23:21,020
warehouse that's a cool thing even if

00:23:18,780 --> 00:23:24,570
you want to change the code afterwards

00:23:21,020 --> 00:23:29,730
now remember we want to actually check

00:23:24,570 --> 00:23:32,850
if these calls are made from our

00:23:29,730 --> 00:23:35,660
replacement warehouse and we want to

00:23:32,850 --> 00:23:35,660
test for that

00:23:42,880 --> 00:23:50,300
so we write our tests down here with an

00:23:47,540 --> 00:23:55,160
empty warehouse we can generate that

00:23:50,300 --> 00:23:57,860
class and again we will be helped by the

00:23:55,160 --> 00:23:59,870
IDE or doing it by hand

00:23:57,860 --> 00:24:02,000
to add all the missing member functions

00:23:59,870 --> 00:24:04,130
that we need to implement and these are

00:24:02,000 --> 00:24:07,990
completely auto-generated with default

00:24:04,130 --> 00:24:10,670
returns so it so that they will compile

00:24:07,990 --> 00:24:14,420
and the nice thing because the default

00:24:10,670 --> 00:24:16,640
return of a bool is false and our empty

00:24:14,420 --> 00:24:21,100
warehouse we expect the order not to be

00:24:16,640 --> 00:24:25,550
filled from so our test case just runs

00:24:21,100 --> 00:24:28,370
that's a very quick thing to go around

00:24:25,550 --> 00:24:30,770
our circle of writing the test writing

00:24:28,370 --> 00:24:39,740
the code that fulfills the test refactor

00:24:30,770 --> 00:24:41,960
and write the test again that was the

00:24:39,740 --> 00:24:45,500
case that you would apply if you do it

00:24:41,960 --> 00:24:50,320
by hand or with some support from your

00:24:45,500 --> 00:24:53,950
IDE what would it look like with the

00:24:50,320 --> 00:25:01,220
mocking frameworks that I prepared for

00:24:53,950 --> 00:25:03,710
this talk most of the existing for C++

00:25:01,220 --> 00:25:06,320
and the two examples I have chosen gee

00:25:03,710 --> 00:25:08,780
mark and Trumpler requires you to use

00:25:06,320 --> 00:25:12,230
the extract interface with the pure

00:25:08,780 --> 00:25:15,880
virtual functions and then if you want

00:25:12,230 --> 00:25:19,880
to provide a mock you have to use

00:25:15,880 --> 00:25:22,790
interesting macros to actually specify

00:25:19,880 --> 00:25:24,200
the over-riders of the member function

00:25:22,790 --> 00:25:27,620
and the macros will actually generate

00:25:24,200 --> 00:25:29,420
magic code for you so that the rest of

00:25:27,620 --> 00:25:35,170
the mocking frameworks can work with

00:25:29,420 --> 00:25:39,650
your mock warehouse objects so for a

00:25:35,170 --> 00:25:43,320
Const member function taking one

00:25:39,650 --> 00:25:47,520
parameter you write mock Const method 1

00:25:43,320 --> 00:25:53,210
in G mock or intron play it's almost

00:25:47,520 --> 00:25:57,240
it's make Const mock one so very close

00:25:53,210 --> 00:26:01,290
that is one thing some people like I

00:25:57,240 --> 00:26:04,830
hate it because it changes the language

00:26:01,290 --> 00:26:06,540
syntax and as a tool builder it's very

00:26:04,830 --> 00:26:14,420
hard to work with code that actually

00:26:06,540 --> 00:26:17,100
employs macros if everything is fine ok

00:26:14,420 --> 00:26:24,210
but if we make a typo in one of the

00:26:17,100 --> 00:26:27,480
macro arguments and you might consider

00:26:24,210 --> 00:26:32,790
why do I need to write 1 & 2 here well

00:26:27,480 --> 00:26:35,220
for the macro it might not be able to

00:26:32,790 --> 00:26:37,320
recognize all the commas there correctly

00:26:35,220 --> 00:26:41,220
depending on what you're using there

00:26:37,320 --> 00:26:45,020
like you might have a templated type

00:26:41,220 --> 00:26:47,790
with multiple template arguments and the

00:26:45,020 --> 00:26:51,330
macro will just take the template comma

00:26:47,790 --> 00:26:55,530
s something interesting we has run into

00:26:51,330 --> 00:26:58,560
that with cold yeah that's a cool thing

00:26:55,530 --> 00:27:01,070
to debug especially the compiler massive

00:26:58,560 --> 00:27:04,410
error messages might be very interesting

00:27:01,070 --> 00:27:08,340
and very confusing especially if you

00:27:04,410 --> 00:27:13,560
don't know that you have macro there so

00:27:08,340 --> 00:27:15,420
I hate macros in C++ code but a lot of

00:27:13,560 --> 00:27:19,490
mocking frameworks do that so one of the

00:27:15,420 --> 00:27:19,490
considered harmful things that hurt

00:27:20,190 --> 00:27:26,370
now if we just want to fake and that

00:27:23,130 --> 00:27:30,240
means we want to provide default result

00:27:26,370 --> 00:27:32,760
for our functions replacement functions

00:27:30,240 --> 00:27:35,040
if you do it yourself the default for

00:27:32,760 --> 00:27:38,990
has inventory for this case with the

00:27:35,040 --> 00:27:41,850
empty warehouse it's returning false

00:27:38,990 --> 00:27:46,410
with the mocking frameworks we actually

00:27:41,850 --> 00:27:49,880
cannot just say return false no many of

00:27:46,410 --> 00:27:52,920
those provide you with a specific

00:27:49,880 --> 00:27:57,510
infrastructure to actually specify how a

00:27:52,920 --> 00:28:00,950
function should behave and in addition

00:27:57,510 --> 00:28:04,620
to that they come with as a side effect

00:28:00,950 --> 00:28:06,990
not only specifying how to behave but

00:28:04,620 --> 00:28:12,930
also specifying how the system on the

00:28:06,990 --> 00:28:15,750
test should actually call the object the

00:28:12,930 --> 00:28:20,220
Google mock people provide a macro

00:28:15,750 --> 00:28:23,610
called on-call providing the object and

00:28:20,220 --> 00:28:26,520
the function and the arguments and then

00:28:23,610 --> 00:28:30,230
you can say ok will by default return

00:28:26,520 --> 00:28:33,840
false which reason reads nicely if you

00:28:30,230 --> 00:28:37,170
read English but not that nicely if you

00:28:33,840 --> 00:28:41,820
want to read the C++ code because it's

00:28:37,170 --> 00:28:47,990
not C++ ish under the hood they will

00:28:41,820 --> 00:28:50,670
build infrastructure to actually create

00:28:47,990 --> 00:28:54,510
expression object that will be evaluated

00:28:50,670 --> 00:29:00,480
at runtime to provide the return of

00:28:54,510 --> 00:29:02,790
false but it's not that obvious and you

00:29:00,480 --> 00:29:06,750
have to learn the language and the right

00:29:02,790 --> 00:29:09,360
spelling and the interesting thing the

00:29:06,750 --> 00:29:12,530
google mark documentation actually tells

00:29:09,360 --> 00:29:16,560
us on call is something that is

00:29:12,530 --> 00:29:21,930
underused many people write expect call

00:29:16,560 --> 00:29:24,330
and I figure out why on call if you run

00:29:21,930 --> 00:29:27,150
your test cases and you use on call to

00:29:24,330 --> 00:29:31,920
just fake something generates you a

00:29:27,150 --> 00:29:33,170
warning it says okay you can just ignore

00:29:31,920 --> 00:29:35,030
it but it

00:29:33,170 --> 00:29:37,550
less generates warning so you have the

00:29:35,030 --> 00:29:39,920
mental overhead of checking out is that

00:29:37,550 --> 00:29:43,520
a real problem or is it just something

00:29:39,920 --> 00:29:46,340
that happens because I used on call so

00:29:43,520 --> 00:29:48,320
if you're really want to work with a lot

00:29:46,340 --> 00:29:50,690
of tests and stuff any warning actually

00:29:48,320 --> 00:29:52,520
triggers some bad feeling so you better

00:29:50,690 --> 00:29:54,770
write your code and your test so they

00:29:52,520 --> 00:29:58,790
don't trigger warnings it just go green

00:29:54,770 --> 00:30:02,270
and pass and that might be one of the

00:29:58,790 --> 00:30:05,150
reasons I own call is under use so many

00:30:02,270 --> 00:30:08,030
people over specify saying okay we

00:30:05,150 --> 00:30:13,310
expect that this has inventory is

00:30:08,030 --> 00:30:16,240
actually called and if you if the order

00:30:13,310 --> 00:30:19,250
object fill member function doesn't call

00:30:16,240 --> 00:30:21,500
has inventory with exact these

00:30:19,250 --> 00:30:29,290
parameters that argument exact these

00:30:21,500 --> 00:30:33,620
arguments the test will fail Trumpler

00:30:29,290 --> 00:30:37,640
provide a instead of expect call allows

00:30:33,620 --> 00:30:43,010
require call but it also allows allow

00:30:37,640 --> 00:30:45,500
call so it can actually specify the like

00:30:43,010 --> 00:30:48,110
the on call a default behavior without

00:30:45,500 --> 00:30:50,900
actually requiring that the call is made

00:30:48,110 --> 00:30:52,670
so that if T if you refactor your fill

00:30:50,900 --> 00:30:55,730
member function doing something else by

00:30:52,670 --> 00:30:58,160
fit and figuring out if the inventory is

00:30:55,730 --> 00:31:02,900
empty it's still possible to do so

00:30:58,160 --> 00:31:06,020
without having the test fail now we see

00:31:02,900 --> 00:31:07,460
here we assert false or is filled or in

00:31:06,020 --> 00:31:12,310
in the other framework that I'm using

00:31:07,460 --> 00:31:12,310
down here assert not order is filled

00:31:15,040 --> 00:31:21,320
where does the test thing that the

00:31:18,230 --> 00:31:26,720
expectation actually happened is

00:31:21,320 --> 00:31:29,150
fulfilled happen well it happens when

00:31:26,720 --> 00:31:32,960
the mock warehouse object the warehouse

00:31:29,150 --> 00:31:38,270
here is actually destroyed so it's under

00:31:32,960 --> 00:31:41,600
step I'm unwinding which is a little bit

00:31:38,270 --> 00:31:44,870
late in my opinion and that's one of the

00:31:41,600 --> 00:31:47,049
other problems many of these C++ mocking

00:31:44,870 --> 00:31:49,779
frameworks carry they test

00:31:47,049 --> 00:31:51,669
stuff at the structure if you have

00:31:49,779 --> 00:31:55,119
another problem where an exception is

00:31:51,669 --> 00:31:57,850
thrown you might end up with with

00:31:55,119 --> 00:32:04,809
interesting things because the checks

00:31:57,850 --> 00:32:07,149
are coming very late so I already talked

00:32:04,809 --> 00:32:10,320
about the behavior verification by

00:32:07,149 --> 00:32:14,980
providing the expect call explanation

00:32:10,320 --> 00:32:17,889
sometimes you have interesting api's

00:32:14,980 --> 00:32:22,239
here that you want to make sure that

00:32:17,889 --> 00:32:24,999
they help the problem is if you specify

00:32:22,239 --> 00:32:27,399
a lot what should happen here you over

00:32:24,999 --> 00:32:29,169
specify the internal behavior of the

00:32:27,399 --> 00:32:31,090
system under test so you might end up

00:32:29,169 --> 00:32:32,830
with fragile test when you refactor your

00:32:31,090 --> 00:32:36,940
system under test that you're just

00:32:32,830 --> 00:32:39,249
evolving and I have some better

00:32:36,940 --> 00:32:42,399
visualization for that so if you want to

00:32:39,249 --> 00:32:46,799
fill aware from fill something from a

00:32:42,399 --> 00:32:50,919
full warehouse we actually can say ok

00:32:46,799 --> 00:32:52,809
back to this you first have to ask for

00:32:50,919 --> 00:32:54,940
has inventory if that's true we want to

00:32:52,809 --> 00:33:01,869
actually remove the Talisker 50 bottles

00:32:54,940 --> 00:33:05,080
from the warehouse to do so we again

00:33:01,869 --> 00:33:08,590
employ our expect call with these

00:33:05,080 --> 00:33:11,409
arguments we'll return true and then we

00:33:08,590 --> 00:33:14,379
expect another call that it's actually

00:33:11,409 --> 00:33:16,450
removed to make sure that these two

00:33:14,379 --> 00:33:18,970
calls are made in the correct order

00:33:16,450 --> 00:33:21,100
first checking and then removing we

00:33:18,970 --> 00:33:23,919
actually have to introduce magic by this

00:33:21,100 --> 00:33:27,759
in sequence object and remark to check

00:33:23,919 --> 00:33:29,889
out okay first this call and then that

00:33:27,759 --> 00:33:32,440
call and it's by magic because only

00:33:29,889 --> 00:33:36,759
because this in sequence object happens

00:33:32,440 --> 00:33:39,249
to be there these expect calls are

00:33:36,759 --> 00:33:41,559
actually checked in the sequence and

00:33:39,249 --> 00:33:43,840
that's again magic on distraction of

00:33:41,559 --> 00:33:47,440
that in sequence object object that

00:33:43,840 --> 00:33:49,749
things like that happen drum play is a

00:33:47,440 --> 00:33:52,149
little bit more explicit you also have

00:33:49,749 --> 00:33:55,359
this sequence object here but you pass

00:33:52,149 --> 00:33:57,999
it into your require call so it's more

00:33:55,359 --> 00:33:59,740
obvious that the sequence is required

00:33:57,999 --> 00:34:03,980
from these calls

00:33:59,740 --> 00:34:06,140
but both frameworks suffer that the

00:34:03,980 --> 00:34:11,480
actual check that the calls have been

00:34:06,140 --> 00:34:16,609
made in that sequence is done here or

00:34:11,480 --> 00:34:18,440
here but you have to check that the

00:34:16,609 --> 00:34:20,359
order is filmed before so if you have

00:34:18,440 --> 00:34:22,520
logic error that the order is not filled

00:34:20,359 --> 00:34:24,830
even these calls are made you might

00:34:22,520 --> 00:34:27,619
actually fail here and have multiple

00:34:24,830 --> 00:34:30,889
issues within a single test and that's

00:34:27,619 --> 00:34:34,669
also bad about test cases if a test case

00:34:30,889 --> 00:34:36,590
has multiple reasons to fail it's very

00:34:34,669 --> 00:34:39,050
bad because you never know what went

00:34:36,590 --> 00:34:41,450
wrong immediately you have to start

00:34:39,050 --> 00:34:44,030
debugging your test cases who is doing

00:34:41,450 --> 00:34:49,879
using the debugger to figure out if test

00:34:44,030 --> 00:34:53,210
cases are wrong ah plenty go home look

00:34:49,879 --> 00:34:55,340
into the mirror and say I should ride my

00:34:53,210 --> 00:34:59,600
test cases so that I don't need to be

00:34:55,340 --> 00:35:06,890
pakka to figure out what's wrong that's

00:34:59,600 --> 00:35:08,810
one thing to take home no debugging core

00:35:06,890 --> 00:35:11,660
dumps are fine we have opposed to here

00:35:08,810 --> 00:35:12,170
let's ask or dams for gecko dams are so

00:35:11,660 --> 00:35:15,410
retro

00:35:12,170 --> 00:35:18,140
chorim's are fine interactive debugging

00:35:15,410 --> 00:35:23,150
is the biggest time waster for

00:35:18,140 --> 00:35:27,650
developers I get one thumb up more ok

00:35:23,150 --> 00:35:29,540
and the other issue is many of these

00:35:27,650 --> 00:35:31,460
mocking frameworks provide you with

00:35:29,540 --> 00:35:34,640
their own language for specifying

00:35:31,460 --> 00:35:37,310
behavior while we are programming C++

00:35:34,640 --> 00:35:39,440
why isn't C++ used for specifying the

00:35:37,310 --> 00:35:40,760
behavior I'll give you some of the

00:35:39,440 --> 00:35:45,160
reasons later just to give you an

00:35:40,760 --> 00:35:50,869
overview trample a has a nice to feed

00:35:45,160 --> 00:35:52,970
cheat sheet how it's to be used and I

00:35:50,869 --> 00:35:55,520
don't want to explain details go to pure

00:35:52,970 --> 00:35:57,740
in stock if they are listen to one of

00:35:55,520 --> 00:35:59,900
his video recorded talks where he

00:35:57,740 --> 00:36:02,960
explains how a great Trempealeau works

00:35:59,900 --> 00:36:05,060
but just interesting thing you write EQ

00:36:02,960 --> 00:36:06,890
that's so Fortran ish who remembers

00:36:05,060 --> 00:36:11,300
Fortran

00:36:06,890 --> 00:36:14,620
it was dot EQ dot but nevertheless well

00:36:11,300 --> 00:36:16,600
we have equals and other things so

00:36:14,620 --> 00:36:18,880
interesting things and because of

00:36:16,600 --> 00:36:22,160
implementation and language problems

00:36:18,880 --> 00:36:24,110
there are things oh I have references or

00:36:22,160 --> 00:36:24,740
local stuff I need to take care about

00:36:24,110 --> 00:36:28,640
that

00:36:24,740 --> 00:36:30,500
well that's because magic happens in the

00:36:28,640 --> 00:36:32,780
destructor and your local smite began

00:36:30,500 --> 00:36:38,620
while you're checking things that's a

00:36:32,780 --> 00:36:41,720
problem now when we perceived Mercator

00:36:38,620 --> 00:36:44,030
with the tooling in the framework I was

00:36:41,720 --> 00:36:46,100
thinking about Kent Beck remembering

00:36:44,030 --> 00:36:50,410
he's saying do the simplest thing that

00:36:46,100 --> 00:36:53,420
could possibly work when in doubt I

00:36:50,410 --> 00:36:55,940
figure out is that really true from I

00:36:53,420 --> 00:36:58,610
remember it Kent saying it but actually

00:36:55,940 --> 00:37:00,530
it was Ward Cunningham working with Kent

00:36:58,610 --> 00:37:01,760
saying can't do the simplest thing that

00:37:00,530 --> 00:37:04,520
could possibly work when they were a

00:37:01,760 --> 00:37:06,740
pair programming for those who anybody

00:37:04,520 --> 00:37:10,610
not knowing who what Kahneman is what he

00:37:06,740 --> 00:37:16,030
invented some of them he's the inventor

00:37:10,610 --> 00:37:22,220
of the wiki wiki rather not Wikipedia or

00:37:16,030 --> 00:37:29,600
but the wiki wiki vet in 1992 more

00:37:22,220 --> 00:37:33,880
belief so I can figure that out so what

00:37:29,600 --> 00:37:36,860
were my constraints I'd hate macros and

00:37:33,880 --> 00:37:39,710
I want just regular C plasters code and

00:37:36,860 --> 00:37:43,520
it was just after c-plus was 11 was

00:37:39,710 --> 00:37:46,610
available in regular compilers so we

00:37:43,520 --> 00:37:50,360
provided and we were writing against an

00:37:46,610 --> 00:37:52,850
IDE so we have tools for generating and

00:37:50,360 --> 00:37:56,180
analyzing code and that makes things

00:37:52,850 --> 00:37:59,750
simpler in my opinion and those of you

00:37:56,180 --> 00:38:04,960
who still use let's say ancient IDs or

00:37:59,750 --> 00:38:04,960
no ideas at all an IDE called Emacs I

00:38:06,250 --> 00:38:15,620
believe that's very retro even more than

00:38:11,120 --> 00:38:20,240
kora Dom's so

00:38:15,620 --> 00:38:22,190
we provide is introducing refactorings

00:38:20,240 --> 00:38:25,220
for all kinds of seams mica feathers

00:38:22,190 --> 00:38:27,680
probably tells about we generate regular

00:38:25,220 --> 00:38:32,810
C++ code that you can actually change

00:38:27,680 --> 00:38:35,150
and the stuff will still work we

00:38:32,810 --> 00:38:36,890
generate regular C++ code for tracing

00:38:35,150 --> 00:38:38,480
calls and that's where the simplest

00:38:36,890 --> 00:38:40,730
thing that could possibly work what we

00:38:38,480 --> 00:38:45,650
trace calls I just provide generating

00:38:40,730 --> 00:38:47,570
strings or a little bit fin slightly

00:38:45,650 --> 00:38:50,030
fancier mechanism for generating strings

00:38:47,570 --> 00:38:52,430
and we use a vector with these call

00:38:50,030 --> 00:38:55,210
objects with our strings for tracing the

00:38:52,430 --> 00:38:59,090
calls and you jump then just can compare

00:38:55,210 --> 00:39:02,180
the vector that is generated with the

00:38:59,090 --> 00:39:05,000
vector that you pre set in the test case

00:39:02,180 --> 00:39:07,490
to figure out if there's a back or not

00:39:05,000 --> 00:39:09,320
so you set your expectations and it

00:39:07,490 --> 00:39:11,450
looks like that you have a call to the

00:39:09,320 --> 00:39:13,700
constructor you have a call to has

00:39:11,450 --> 00:39:16,850
inventory and you call to remove and

00:39:13,700 --> 00:39:19,370
these calls are actually happening in

00:39:16,850 --> 00:39:23,390
that sequence as you spell them out you

00:39:19,370 --> 00:39:27,290
just accessor equal the trace object

00:39:23,390 --> 00:39:30,110
with your expected calls and if that's

00:39:27,290 --> 00:39:32,030
okay everything is fine if not you get

00:39:30,110 --> 00:39:34,130
an interesting error message and I show

00:39:32,030 --> 00:39:35,720
you in a second how that looks and if

00:39:34,130 --> 00:39:37,850
you have more interesting stuff that

00:39:35,720 --> 00:39:39,500
should go on if you want to check more

00:39:37,850 --> 00:39:41,720
interesting stuff you still have the

00:39:39,500 --> 00:39:43,280
power of C plus and reg X and you're

00:39:41,720 --> 00:39:46,000
let's say interesting

00:39:43,280 --> 00:39:48,260
STL algorithms to figure out if the

00:39:46,000 --> 00:39:54,260
expectations are actually Mak match

00:39:48,260 --> 00:39:56,330
without learning any extra magic and if

00:39:54,260 --> 00:39:58,310
you learn more about the details they're

00:39:56,330 --> 00:40:00,800
nice screen casts made by my former

00:39:58,310 --> 00:40:05,150
student on Mercator comm and everything

00:40:00,800 --> 00:40:08,690
is available in Sevilla and if you try

00:40:05,150 --> 00:40:10,910
it out and find backs please tell us we

00:40:08,690 --> 00:40:12,380
need our user feedback to improve I just

00:40:10,910 --> 00:40:15,650
found a back when preparing the slides

00:40:12,380 --> 00:40:19,970
and it's already fixed by my assistants

00:40:15,650 --> 00:40:21,650
so it's most of the time box back fixes

00:40:19,970 --> 00:40:23,570
are small unless you have a big design

00:40:21,650 --> 00:40:25,800
problem but that is also something that

00:40:23,570 --> 00:40:28,570
might have from time to time

00:40:25,800 --> 00:40:31,420
just to give you an example all this

00:40:28,570 --> 00:40:34,900
blue bar stuff is actually generated

00:40:31,420 --> 00:40:37,270
from develop and then that's the example

00:40:34,900 --> 00:40:39,820
we've seen already and if you have an

00:40:37,270 --> 00:40:43,870
expectation that is not met because we

00:40:39,820 --> 00:40:48,910
have our has inventory actually returns

00:40:43,870 --> 00:40:51,130
false remove will not be called and we

00:40:48,910 --> 00:40:54,970
see immediately in the B few from our

00:40:51,130 --> 00:40:57,670
running test cases what's missing from

00:40:54,970 --> 00:41:00,670
the actual output and that's very

00:40:57,670 --> 00:41:02,530
obvious to see and that something is

00:41:00,670 --> 00:41:05,080
wrong either our expectation is wrong

00:41:02,530 --> 00:41:07,030
which is it in that case or our

00:41:05,080 --> 00:41:11,470
implementation is wrong which we could

00:41:07,030 --> 00:41:14,950
figure out that and it's an assertion

00:41:11,470 --> 00:41:16,870
that's explicit in our test case so we

00:41:14,950 --> 00:41:20,860
actually know what failed and where it

00:41:16,870 --> 00:41:25,350
failed not at some kind of curly brace

00:41:20,860 --> 00:41:25,350
happening magic where things go wrong

00:41:26,640 --> 00:41:34,000
now why is it as bad as I say and why

00:41:30,580 --> 00:41:38,020
did I invent together with Michael Rick

00:41:34,000 --> 00:41:40,660
something different well if you look for

00:41:38,020 --> 00:41:46,840
the history of mocking frameworks they

00:41:40,660 --> 00:41:51,130
stem from a time of the mid 90s late

00:41:46,840 --> 00:41:55,780
nineties Java code base where people

00:41:51,130 --> 00:42:01,180
started using j-unit and other people

00:41:55,780 --> 00:42:02,950
invented a mock and easy mock and for

00:42:01,180 --> 00:42:04,690
example google mark actually stems from

00:42:02,950 --> 00:42:07,740
these same designs they even claimed

00:42:04,690 --> 00:42:11,320
reduce descent from j mark and easy mock

00:42:07,740 --> 00:42:14,140
java comes with built in reflection it

00:42:11,320 --> 00:42:16,390
only has classes an object always has

00:42:14,140 --> 00:42:18,460
dynamic polymorphism even if they tell

00:42:16,390 --> 00:42:22,180
something else and it didn't have any

00:42:18,460 --> 00:42:28,410
lambdas then so the only means to

00:42:22,180 --> 00:42:28,410
specify code pieces in the method was to

00:42:29,280 --> 00:42:35,950
invent some mechanism to easily specify

00:42:32,170 --> 00:42:38,920
code that is not code because I didn't

00:42:35,950 --> 00:42:41,559
have lambdas are not easy lambdas in

00:42:38,920 --> 00:42:47,410
classes for everything also not that

00:42:41,559 --> 00:42:49,270
nice in Java so what happened under the

00:42:47,410 --> 00:42:51,280
hood the mocking frameworks provides up

00:42:49,270 --> 00:42:54,880
classing with method implementation for

00:42:51,280 --> 00:42:58,329
reflection and the lack of lambdas

00:42:54,880 --> 00:43:00,400
provide made them invent dsls

00:42:58,329 --> 00:43:04,359
domain-specific languages to specify the

00:43:00,400 --> 00:43:06,339
behavior and not just plain code and the

00:43:04,359 --> 00:43:08,049
problem is if you inherit the design

00:43:06,339 --> 00:43:10,450
because you think it's the best thing

00:43:08,049 --> 00:43:12,490
since sliced bread without having the

00:43:10,450 --> 00:43:16,290
same contract constraints you might end

00:43:12,490 --> 00:43:19,930
up with a design that's not just fitting

00:43:16,290 --> 00:43:25,990
so if you follow Java design and C++

00:43:19,930 --> 00:43:30,220
code bad we don't have useful reflection

00:43:25,990 --> 00:43:32,380
yet in C++ so you might need macros for

00:43:30,220 --> 00:43:35,099
some stuff and you write unit testing

00:43:32,380 --> 00:43:37,900
frameworks but you might not need that

00:43:35,099 --> 00:43:39,819
for defining stops but mocking

00:43:37,900 --> 00:43:45,210
frameworks do so because they inherit

00:43:39,819 --> 00:43:47,980
that features from the Java frameworks

00:43:45,210 --> 00:43:51,579
relying only on virtual member funds I

00:43:47,980 --> 00:43:53,589
remember at at an era when Google Mach

00:43:51,579 --> 00:43:56,290
and Google has only worked with an

00:43:53,589 --> 00:44:01,079
urchin member functions nothing else it

00:43:56,290 --> 00:44:05,380
is bad it's not C++ ish anymore other

00:44:01,079 --> 00:44:08,200
mocking frameworks like HIPAA marks do

00:44:05,380 --> 00:44:10,750
very low-level machine specific ABI

00:44:08,200 --> 00:44:14,290
tricks like replacing virtual table

00:44:10,750 --> 00:44:16,210
entries which is possible if you know

00:44:14,290 --> 00:44:20,079
how your compiler does your Wii table

00:44:16,210 --> 00:44:22,119
layout but it's also in the range of

00:44:20,079 --> 00:44:23,680
undefined behavior that is not really

00:44:22,119 --> 00:44:28,900
portable and might break with new

00:44:23,680 --> 00:44:32,230
version of compilers a lot of work goes

00:44:28,900 --> 00:44:36,430
into a DSL to specify and that often

00:44:32,230 --> 00:44:40,450
also employs macro magic with implicit

00:44:36,430 --> 00:44:43,240
matching behavior instead of X and that

00:44:40,450 --> 00:44:45,460
in the destructor of the magic objects

00:44:43,240 --> 00:44:47,950
that are generated from that and it's

00:44:45,460 --> 00:44:49,990
very fragile especially it's fragile

00:44:47,950 --> 00:44:51,900
with respect to refactoring because

00:44:49,990 --> 00:44:57,660
refactoring tools cannot under

00:44:51,900 --> 00:45:00,599
thank code like that and it turns out

00:44:57,660 --> 00:45:02,900
the tests actually get loaded because if

00:45:00,599 --> 00:45:05,490
you have let's say a more interesting

00:45:02,900 --> 00:45:08,000
interaction like you're a turtle object

00:45:05,490 --> 00:45:10,500
that's taken from the google mark

00:45:08,000 --> 00:45:12,359
documentation you have quite a lot of

00:45:10,500 --> 00:45:14,970
things to figure out what's actually

00:45:12,359 --> 00:45:17,460
happening so on the first call get y

00:45:14,970 --> 00:45:21,869
will return 100 then it will return 200

00:45:17,460 --> 00:45:27,660
and then it will stick at 300 and so

00:45:21,869 --> 00:45:32,990
what does that actually mean there's

00:45:27,660 --> 00:45:32,990
also the curse of too much mocking

00:45:33,170 --> 00:45:38,119
because when I write employer mocking

00:45:36,119 --> 00:45:41,160
framework were when I check actually the

00:45:38,119 --> 00:45:42,720
internal workings interworking of the

00:45:41,160 --> 00:45:46,170
system and attack with the dependent of

00:45:42,720 --> 00:45:49,710
the component I write white box tests

00:45:46,170 --> 00:45:54,119
white box tests actually make things

00:45:49,710 --> 00:45:59,240
frozen remember white ice snow frozen

00:45:54,119 --> 00:46:04,230
actually is is blue but think of snow

00:45:59,240 --> 00:46:07,200
it's hard to refactor for tools and

00:46:04,230 --> 00:46:08,819
manually and a lot of design flexibility

00:46:07,200 --> 00:46:12,839
where you want to actually evolve your

00:46:08,819 --> 00:46:16,710
design and change your code is lost it

00:46:12,839 --> 00:46:23,849
also fosters stateful api's who is a fan

00:46:16,710 --> 00:46:28,140
of stateful api's good like ok said this

00:46:23,849 --> 00:46:32,490
that that and then do it one Karissa's

00:46:28,140 --> 00:46:34,380
many of the graphics frameworks inherit

00:46:32,490 --> 00:46:41,660
from turtle graphics with which is

00:46:34,380 --> 00:46:46,520
inherently stateful who loves cairo ok

00:46:41,660 --> 00:46:49,870
GUI programmers or graphics programmers

00:46:46,520 --> 00:47:01,030
okay that explains a lot

00:46:49,870 --> 00:47:05,320
I think I already told you that just to

00:47:01,030 --> 00:47:08,770
make sure remember if you use the

00:47:05,320 --> 00:47:12,460
mocking framework in a way like that you

00:47:08,770 --> 00:47:14,110
have a lot of elaborated setup code and

00:47:12,460 --> 00:47:17,410
you have that implicit checking of

00:47:14,110 --> 00:47:21,570
expectations actually after the

00:47:17,410 --> 00:47:25,120
verification call and what happens then

00:47:21,570 --> 00:47:27,720
you actually put superglue between your

00:47:25,120 --> 00:47:30,310
test case and the system under test and

00:47:27,720 --> 00:47:33,730
between the system under test and the

00:47:30,310 --> 00:47:36,850
dependent other components that's where

00:47:33,730 --> 00:47:39,490
the tied coupling if you overuse mocking

00:47:36,850 --> 00:47:41,860
frameworks comes from because you do

00:47:39,490 --> 00:47:44,140
this as a white box test so you actually

00:47:41,860 --> 00:47:47,230
put the glue in and you can no longer

00:47:44,140 --> 00:47:50,700
change what's happening within your

00:47:47,230 --> 00:47:53,560
system on the test which is not good and

00:47:50,700 --> 00:47:57,010
it also means your test cases are so

00:47:53,560 --> 00:47:59,560
elaborate and and long that you no

00:47:57,010 --> 00:48:06,690
longer appreciate changing them and

00:47:59,560 --> 00:48:09,280
simply find them in frozen code is bad

00:48:06,690 --> 00:48:13,360
because your requirements will never be

00:48:09,280 --> 00:48:19,600
frozen I skip musing on the stateful

00:48:13,360 --> 00:48:22,390
api's just that's my cairo example who

00:48:19,600 --> 00:48:26,230
can see on the first on one simple

00:48:22,390 --> 00:48:29,560
glimpse what's happening there it's very

00:48:26,230 --> 00:48:32,380
hard and just that's just example code

00:48:29,560 --> 00:48:40,870
from the cairo documentation nothing

00:48:32,380 --> 00:48:45,300
fancy stateful api's are bad if you need

00:48:40,870 --> 00:48:50,020
sequencing wrap things around like

00:48:45,300 --> 00:48:55,540
nesting calls or nesting objects and

00:48:50,020 --> 00:48:58,750
then you have sequencing implicit when

00:48:55,540 --> 00:49:01,110
do i need actually checking the sequence

00:48:58,750 --> 00:49:04,260
when you have an existing

00:49:01,110 --> 00:49:08,610
API that your system on the test has to

00:49:04,260 --> 00:49:13,560
depend on and that a P I is frozen and

00:49:08,610 --> 00:49:15,750
stateful then it might make sense to

00:49:13,560 --> 00:49:19,860
employ a mocking framework check if it's

00:49:15,750 --> 00:49:22,680
used correctly one bad example that we

00:49:19,860 --> 00:49:25,550
have delivered is a classic SI saket API

00:49:22,680 --> 00:49:28,740
who has written a C socket server socket

00:49:25,550 --> 00:49:33,350
who was copying the code from the manual

00:49:28,740 --> 00:49:36,540
pages or took or some some other source

00:49:33,350 --> 00:49:38,130
why because it's elaborate multiple

00:49:36,540 --> 00:49:44,460
steps that you have to do to get

00:49:38,130 --> 00:49:46,560
actually get the connection if you have

00:49:44,460 --> 00:49:49,530
another reason tell me afterwards on

00:49:46,560 --> 00:49:55,860
Twitter or wherever I think if you don't

00:49:49,530 --> 00:49:58,620
have a existing API then don't employ

00:49:55,860 --> 00:50:04,830
mocking you still have might have to use

00:49:58,620 --> 00:50:08,550
faking but don't mock so if you need to

00:50:04,830 --> 00:50:10,320
test legacy code introduce seams stop

00:50:08,550 --> 00:50:13,500
your dependent as the components and

00:50:10,320 --> 00:50:17,700
might maybe mock you it but don't do it

00:50:13,500 --> 00:50:23,270
everywhere take the power of RDS and C++

00:50:17,700 --> 00:50:28,800
not macros and CH code or Java code and

00:50:23,270 --> 00:50:31,980
only if you have to test the code of API

00:50:28,800 --> 00:50:36,420
so that are fixed and stateful employ

00:50:31,980 --> 00:50:38,070
mocks so that are good be aware of the

00:50:36,420 --> 00:50:40,370
dangers and the power of mocking

00:50:38,070 --> 00:50:43,740
frameworks they are like superglue

00:50:40,370 --> 00:50:46,020
fixing your design and code in a mean

00:50:43,740 --> 00:50:49,380
not that this good but that it's

00:50:46,020 --> 00:50:56,250
unchangeable which is bad for code it's

00:50:49,380 --> 00:50:58,890
called software for a reason do not use

00:50:56,250 --> 00:51:03,210
mocking frameworks too liberally when

00:50:58,890 --> 00:51:05,820
you mock non existing code and keep it

00:51:03,210 --> 00:51:10,040
simple or keep it stupidly simple

00:51:05,820 --> 00:51:10,040
applies to test automation as well

00:51:14,060 --> 00:51:17,060
questions

00:51:19,069 --> 00:51:29,970
and by the way is anybody using Swift on

00:51:23,730 --> 00:51:35,430
an on Mac OS we are working on a swift

00:51:29,970 --> 00:51:38,819
IDE for Linux cult if ik that's a

00:51:35,430 --> 00:51:42,660
question please so Google mark has a

00:51:38,819 --> 00:51:46,710
nice feature argument matchers is there

00:51:42,660 --> 00:51:49,260
an equivalent in locator if you want to

00:51:46,710 --> 00:51:53,819
do that what you actually would do let

00:51:49,260 --> 00:51:56,010
me show you a piece of code what you

00:51:53,819 --> 00:52:00,030
would actually do if you want to have a

00:51:56,010 --> 00:52:02,099
specific argument its traced here so you

00:52:00,030 --> 00:52:05,730
can actually match that down here in

00:52:02,099 --> 00:52:07,710
your call yes but what if I want to have

00:52:05,730 --> 00:52:10,200
a wild-card I don't care what are the

00:52:07,710 --> 00:52:12,720
values of they argue just don't trace it

00:52:10,200 --> 00:52:14,819
here because it goes into a string you

00:52:12,720 --> 00:52:17,910
just don't put it in the string and you

00:52:14,819 --> 00:52:20,760
don't put it in the string down there so

00:52:17,910 --> 00:52:22,319
it's very simple it's just strings or

00:52:20,760 --> 00:52:24,480
you put an underscore there if you

00:52:22,319 --> 00:52:28,200
really want to have the same look and

00:52:24,480 --> 00:52:32,940
look and feel and the C++ code is very

00:52:28,200 --> 00:52:34,680
obvious to see that's just C plus it's

00:52:32,940 --> 00:52:36,839
just that is just string concatenation

00:52:34,680 --> 00:52:38,760
it's just a little bit of magic so you

00:52:36,839 --> 00:52:46,349
don't have to do it manually for

00:52:38,760 --> 00:52:47,880
yourself so it's very very simple even

00:52:46,349 --> 00:52:50,339
simpler than you might have thought of

00:52:47,880 --> 00:52:51,900
other questions please so I've been

00:52:50,339 --> 00:52:54,210
using this stuff for a couple years now

00:52:51,900 --> 00:52:55,950
and after you do it for a while you

00:52:54,210 --> 00:52:58,140
check two it becomes really apparent

00:52:55,950 --> 00:53:02,210
that none of this stuff has any

00:52:58,140 --> 00:53:05,490
first-class support from C++ so and I

00:53:02,210 --> 00:53:07,290
didn't get the the beginning of your can

00:53:05,490 --> 00:53:10,440
you say it again so I've been using this

00:53:07,290 --> 00:53:12,030
tougher quite a while and stuff mocking

00:53:10,440 --> 00:53:14,130
unit testing all that kind of stuff a

00:53:12,030 --> 00:53:16,230
and it becomes very obvious that there's

00:53:14,130 --> 00:53:18,089
no real first-class support and C++ to

00:53:16,230 --> 00:53:21,299
do this a good example is the need to

00:53:18,089 --> 00:53:23,940
mark things virtual although you bring

00:53:21,299 --> 00:53:25,740
up the fact that mockery probably

00:53:23,940 --> 00:53:26,700
doesn't have that same problem but at

00:53:25,740 --> 00:53:29,760
least a lot of other frameworks

00:53:26,700 --> 00:53:31,609
definitely do well you can use templates

00:53:29,760 --> 00:53:33,769
for that is there

00:53:31,609 --> 00:53:36,109
any since you're on the committee is

00:53:33,769 --> 00:53:38,779
there any work being done to actually

00:53:36,109 --> 00:53:42,019
provide decent support in C++ for unit

00:53:38,779 --> 00:53:44,809
testing and mocking is a lot of work

00:53:42,019 --> 00:53:47,499
going on currently on having a decent

00:53:44,809 --> 00:53:49,940
reflection support at compile time

00:53:47,499 --> 00:53:52,130
within the library and language but it

00:53:49,940 --> 00:53:53,989
still takes a couple of years to make

00:53:52,130 --> 00:53:55,880
mature to actually being able to

00:53:53,989 --> 00:53:59,599
standardize it but there are people

00:53:55,880 --> 00:54:01,609
working hard on that it's not simple

00:53:59,599 --> 00:54:03,529
yeah a lot of other languages have had

00:54:01,609 --> 00:54:05,059
this kind of stuff for years is it

00:54:03,529 --> 00:54:06,920
surprising that that's one of the

00:54:05,059 --> 00:54:12,079
reasons why we did that in the IDE

00:54:06,920 --> 00:54:14,920
because it's very hard to be able to do

00:54:12,079 --> 00:54:18,049
it at compile with the compiler only

00:54:14,920 --> 00:54:19,729
yeah okay I'm just curious if there is

00:54:18,049 --> 00:54:21,410
anything going but but there are people

00:54:19,729 --> 00:54:23,690
who will actually tell you don't do

00:54:21,410 --> 00:54:26,479
reflection in C plus B because it's the

00:54:23,690 --> 00:54:29,539
code gets too big and that's true

00:54:26,479 --> 00:54:33,249
because you need all the stuff around at

00:54:29,539 --> 00:54:40,069
runtime bad things might happen yeah

00:54:33,249 --> 00:54:41,900
thank you I just wanted to update the

00:54:40,069 --> 00:54:43,309
record on one point that Google Mach was

00:54:41,900 --> 00:54:45,529
the was the only framework where you

00:54:43,309 --> 00:54:48,319
didn't have a listed author the main

00:54:45,529 --> 00:54:51,079
author of Google Mach is named Jean Jung

00:54:48,319 --> 00:54:52,219
Hwan he's he actually works in the in

00:54:51,079 --> 00:54:52,519
the Kirkland office a few miles from

00:54:52,219 --> 00:54:54,949
here

00:54:52,519 --> 00:54:56,900
I'm sure that and it's I just couldn't

00:54:54,949 --> 00:54:59,509
figure it out yeah and I made that slide

00:54:56,900 --> 00:55:01,489
a morning when I noticed that I checked

00:54:59,509 --> 00:55:02,809
our documentation doesn't credit to him

00:55:01,489 --> 00:55:04,759
and it really should it wasn't obvious

00:55:02,809 --> 00:55:06,739
at least yeah so I'll see you about

00:55:04,759 --> 00:55:08,569
fixing that but just for the record I

00:55:06,739 --> 00:55:16,130
think it's really excellent piece of

00:55:08,569 --> 00:55:19,219
work yeah sorry for that sure so you

00:55:16,130 --> 00:55:22,130
mentioned the need for for reflections

00:55:19,219 --> 00:55:26,269
to be able to write at least you know

00:55:22,130 --> 00:55:29,420
decent mocking framework I tested

00:55:26,269 --> 00:55:32,660
framework well for mocking framework I

00:55:29,420 --> 00:55:34,759
mean if I look at something like an N

00:55:32,660 --> 00:55:36,469
substitute for for C sharp which is

00:55:34,759 --> 00:55:39,140
fantastic of course they have like

00:55:36,469 --> 00:55:41,989
compile-time and run-time reflection and

00:55:39,140 --> 00:55:45,160
they can do all sorts of crazy things I

00:55:41,989 --> 00:55:48,940
think with a static reflection would be

00:55:45,160 --> 00:55:53,289
to you know have some templated class

00:55:48,940 --> 00:55:55,869
which can mock any virtual function of

00:55:53,289 --> 00:55:59,349
the of the template parameter class

00:55:55,869 --> 00:56:00,910
that's you give it and then then you

00:55:59,349 --> 00:56:02,289
don't blow the code right because it's

00:56:00,910 --> 00:56:05,049
static reflection it's not in the

00:56:02,289 --> 00:56:06,940
runtime and then you could have a list

00:56:05,049 --> 00:56:11,289
of all the function that you would want

00:56:06,940 --> 00:56:13,210
to mock in in such a framework so the

00:56:11,289 --> 00:56:16,599
question is similar to the previous

00:56:13,210 --> 00:56:17,799
question right so since we know that the

00:56:16,599 --> 00:56:22,529
committee is working on static

00:56:17,799 --> 00:56:25,890
reflection is there anyone working on a

00:56:22,529 --> 00:56:29,140
mocking framework based on that proposal

00:56:25,890 --> 00:56:32,109
currently and if not why not because

00:56:29,140 --> 00:56:36,039
that that would be my first use case for

00:56:32,109 --> 00:56:39,640
it for it it's also my use case for for

00:56:36,039 --> 00:56:43,119
reflection in C++ the problem is it's

00:56:39,640 --> 00:56:45,460
not fleshed out yet exactly what should

00:56:43,119 --> 00:56:49,660
go into the standard mm-hmm so they are

00:56:45,460 --> 00:56:51,640
slightly competing right strategies how

00:56:49,660 --> 00:56:56,019
to achieve what what you need for a

00:56:51,640 --> 00:56:58,539
static reflection and the the problem is

00:56:56,019 --> 00:57:00,460
it's a chicken and egg problem so you

00:56:58,539 --> 00:57:02,319
you don't want to commit with the

00:57:00,460 --> 00:57:04,390
mocking frame or with the testing

00:57:02,319 --> 00:57:07,690
framework without having the the working

00:57:04,390 --> 00:57:09,460
implementation and so you wouldn't be

00:57:07,690 --> 00:57:11,819
able to write tests and you wouldn't

00:57:09,460 --> 00:57:14,289
want to change too much unless it's

00:57:11,819 --> 00:57:16,869
right but it would be a fantastic use

00:57:14,289 --> 00:57:18,430
case to help in the design of the

00:57:16,869 --> 00:57:20,259
specification it might be people who

00:57:18,430 --> 00:57:23,289
actually work on that but I'm not aware

00:57:20,259 --> 00:57:25,539
it's not only let's say on the agenda of

00:57:23,289 --> 00:57:29,349
the east and a Senate committee yet

00:57:25,539 --> 00:57:33,039
understand quick other question is so

00:57:29,349 --> 00:57:34,960
all those IDE tricks that you're using

00:57:33,039 --> 00:57:37,269
in civil up is that available in eclipse

00:57:34,960 --> 00:57:40,119
as well or is available in our Eclipse

00:57:37,269 --> 00:57:42,220
derived develop right some of the stuff

00:57:40,119 --> 00:57:44,950
you might be able to install directly as

00:57:42,220 --> 00:57:47,230
a plug-in or something within Eclipse as

00:57:44,950 --> 00:57:49,240
a plugin and if you're more interested I

00:57:47,230 --> 00:57:51,069
have some fliers here I can take them

00:57:49,240 --> 00:57:51,400
home and you can ask me all right I'll

00:57:51,069 --> 00:57:53,500
do that

00:57:51,400 --> 00:57:56,529
Thanks and if you tried and things fail

00:57:53,500 --> 00:57:57,490
tell us please tell us sure I'm not sure

00:57:56,529 --> 00:58:07,119
was

00:57:57,490 --> 00:58:11,530
next I really like you bringing the

00:58:07,119 --> 00:58:13,690
vector recording of calls to the

00:58:11,530 --> 00:58:16,750
forefront thank you

00:58:13,690 --> 00:58:19,390
the reason being vectors are regular if

00:58:16,750 --> 00:58:21,460
they're full of regular types which

00:58:19,390 --> 00:58:23,320
means you can save the recording and

00:58:21,460 --> 00:58:25,030
then compare it to a trusted component

00:58:23,320 --> 00:58:27,820
recording it so you don't have to hard

00:58:25,030 --> 00:58:29,619
code your calls so if you have a

00:58:27,820 --> 00:58:32,980
component that works correctly you can

00:58:29,619 --> 00:58:35,490
actually record the trace and then test

00:58:32,980 --> 00:58:40,060
an untrusted component with that trace

00:58:35,490 --> 00:58:44,140
yes and no other framework actually

00:58:40,060 --> 00:58:50,380
allows you to do that because you can't

00:58:44,140 --> 00:58:52,690
just copy the damn thing so yeah we

00:58:50,380 --> 00:58:58,599
should really have that in every mocking

00:58:52,690 --> 00:59:01,030
framework I would like to comment him on

00:58:58,599 --> 00:59:02,820
that was the topic that you've the name

00:59:01,030 --> 00:59:05,650
of the of the presentation which is

00:59:02,820 --> 00:59:09,010
mocking frame was considered harmful and

00:59:05,650 --> 00:59:10,530
for my personal experience I was doing

00:59:09,010 --> 00:59:13,540
mocking a long time before I knew about

00:59:10,530 --> 00:59:15,220
mocking frameworks and I found that when

00:59:13,540 --> 00:59:17,170
I actually started to use mocking

00:59:15,220 --> 00:59:18,640
frameworks they limit my ability because

00:59:17,170 --> 00:59:20,589
there's a specific language you need to

00:59:18,640 --> 00:59:22,570
know about and they're only certain

00:59:20,589 --> 00:59:25,000
things you can do it often limits the

00:59:22,570 --> 00:59:27,240
capability of a programmer to write as

00:59:25,000 --> 00:59:30,010
flexible tests as he would like and

00:59:27,240 --> 00:59:32,200
sometimes it's much easier just to go

00:59:30,010 --> 00:59:34,810
and spend the time that it takes to spin

00:59:32,200 --> 00:59:36,250
off an interface and write the state

00:59:34,810 --> 00:59:38,500
machine within that interface within the

00:59:36,250 --> 00:59:40,240
implementation and then to do custom

00:59:38,500 --> 00:59:42,220
stuff which maybe can't be expressed so

00:59:40,240 --> 00:59:43,780
easily with a macro or with the

00:59:42,220 --> 00:59:45,550
framework because there you only have a

00:59:43,780 --> 00:59:47,470
specific tools that you can actually use

00:59:45,550 --> 00:59:51,490
and what I've seen is that people write

00:59:47,470 --> 00:59:53,410
very long convoluted tests but don't we

00:59:51,490 --> 00:59:55,420
test much they test trivial things like

00:59:53,410 --> 00:59:56,950
I put in a variable I want to see what

00:59:55,420 --> 00:59:59,220
comes out and we all know that that

00:59:56,950 --> 01:00:01,839
works what's really important is

00:59:59,220 --> 01:00:04,060
domain-specific behavior that it

01:00:01,839 --> 01:00:06,910
sometimes requires much more than just a

01:00:04,060 --> 01:00:09,550
simple macro or providing a delegate or

01:00:06,910 --> 01:00:10,630
a lambda which are not stateful and very

01:00:09,550 --> 01:00:13,720
difficult to

01:00:10,630 --> 01:00:14,500
relate complex behavior I want to hear

01:00:13,720 --> 01:00:16,089
what you think what do you think about

01:00:14,500 --> 01:00:20,019
that and do you think that's also an

01:00:16,089 --> 01:00:23,349
aspect of harmful behaviors in mocking

01:00:20,019 --> 01:00:27,190
frameworks let's say if you do mocking

01:00:23,349 --> 01:00:29,470
by hand that's good because then you

01:00:27,190 --> 01:00:32,079
actually suffer from your bad design and

01:00:29,470 --> 01:00:34,930
you write real code that it's easily

01:00:32,079 --> 01:00:38,440
where you can see what it does and you

01:00:34,930 --> 01:00:39,970
can refactor it as you have observed the

01:00:38,440 --> 01:00:43,180
mocking frameworks give you some

01:00:39,970 --> 01:00:46,059
handcuffs that look first very nice and

01:00:43,180 --> 01:00:48,789
interesting but I hate it and you seem

01:00:46,059 --> 01:00:50,140
to hate it as well right and that's why

01:00:48,789 --> 01:00:52,109
I made this talk and you should have

01:00:50,140 --> 01:00:55,180
spoken up before I started again I

01:00:52,109 --> 01:00:57,759
complete motivation in your okay thank

01:00:55,180 --> 01:01:00,970
you contribution and I think we run out

01:00:57,759 --> 01:01:03,970
of time and I thank you very much if you

01:01:00,970 --> 01:01:05,680
need to want to know more about civil op

01:01:03,970 --> 01:01:08,950
or whatever we are doing at our

01:01:05,680 --> 01:01:12,460
University speak up to me I'll be around

01:01:08,950 --> 01:01:14,310
until Friday morning and take some

01:01:12,460 --> 01:01:20,000
flyers

01:01:14,310 --> 01:01:20,000

YouTube URL: https://www.youtube.com/watch?v=uhuHZXTRfH4


