Title: CppCon 2017: Alisdair Meredith “Recreational C++”
Publication date: 2017-10-13
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
C++ is a language full of curiosities, and entices the curious. This session will will walk through half a dozen little code explorations of ideas that might have been solved in 5 minutes, but piqued my curiosity to keep digging and see just how completely or thoroughly they might be solved, and what we can learn about the language and the way it holds together along the way. Fundamentally, it is about the joy of exploring code long after the problem has been solved, to find those satisfying solutions to problems that don't need solving! 

There will not be much deep learning; instead, there will be numerous insights into corners of the language that are often (for good reason!) unexplored, that might help with the big picture when debugging some obscure bugs. In particular, constexpr and templates will be exercised, and some compiler limits may be tested. We will demonstrating code that will the the gamut of C++98 though to C++17, and even poke into experimental pending features such as concepts. 
— 
Alisdair Meredith: Bloomberg LP, Senior Software Developer

Alisdair Meredith is a software developer at BloombergLP in New York, and the C++ Standard Committee Library Working Group chair.

He has been an active member of the C++ committee for just over a decade, and by a lucky co-incidence his first meeting was the kick-off meeting for the project that would become C++11, and also fixed the contents of the original library TR.

He is currently working on the BDE project, BloombergLP's open source libraries that offer a foundation for C++ development, including a standard library implementation supporting the polymorphic allocator model proposed for standardization.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,039 --> 00:00:03,869
Okay, so, the title of this talk is "Recreational C++."

00:00:04,509 --> 00:00:08,428
This is basically me having fun playing around with our language...

00:00:09,280 --> 00:00:13,770
A few puzzles and corner cases and things that have amused me over the years.

00:00:14,469 --> 00:00:17,278
So we'll start with this. What is this?

00:00:20,740 --> 00:00:22,740
It's a terrible pun.

00:00:25,630 --> 00:00:27,630
So we've got that out of the way.

00:00:30,789 --> 00:00:32,999
So what is "Recreational C++"?

00:00:33,000 --> 00:00:39,599
My notion here is I'm playing around with code for fun. Because when we play, we're in a great environment to learn.

00:00:40,149 --> 00:00:42,299
So I'll be solving a lot of well-known problems.

00:00:43,000 --> 00:00:49,139
I've got nothing inspirational and new as far as I'm aware. This is just kind of what amusingly inspired me.

00:00:49,140 --> 00:00:53,250
And hopefully this will amusingly inspire you to find your own little corner cases and puzzles.

00:00:53,250 --> 00:00:55,250
Maybe we can share some of those as we go through.

00:00:58,899 --> 00:01:04,859
I'm describing this as lots of more smaller scale problems — if you're familiar with the ideas of toys and pets?

00:01:05,680 --> 00:01:11,610
Toys and pets, in development circles, are the idea of you've got that little go-to project

00:01:11,610 --> 00:01:14,760
that every time you have a new environment you need to learn and understand —

00:01:15,159 --> 00:01:17,999
I'm being exposed to a new operating system for the first time —

00:01:18,000 --> 00:01:24,269
I'm going to write my familiar little toy, my pet, that I feed and nurture over the years. So that might be something like, you know, a chat application across the network,

00:01:25,180 --> 00:01:26,790
like how does that work in the new environment...?

00:01:26,790 --> 00:01:33,839
or, a classic example, a parser for a simple mathematical script?

00:01:33,840 --> 00:01:39,210
And these are the kinds of things that you evolve over years. They're a much larger scale thing than I'm talking about here.

00:01:39,820 --> 00:01:43,229
I'm a careless guardian. I'm afraid all my pets have slowly withered and died... so...

00:01:46,509 --> 00:01:49,559
Because I got too busy really hooked up with C++.

00:01:50,920 --> 00:01:55,710
So what we're going to look at is a bunch of my ideas and things I just had, playing around.

00:01:56,770 --> 00:02:01,229
Essentially implementing little parts of the C++ standard library for the most part.

00:02:02,770 --> 00:02:06,390
Ideas of coding conventions come up when you start playing and doing things for yourself;

00:02:08,200 --> 00:02:11,489
Some C++ trivia corners, because trivia is always fun;

00:02:12,270 --> 00:02:16,409
How this helps me learn about some of the new language features as they come through.

00:02:17,740 --> 00:02:22,499
And yeah, playing around with the bug reporting systems of various compilers as I push them to breaking point.

00:02:24,160 --> 00:02:27,359
And some ideas about implementing and testing the standard library.

00:02:28,240 --> 00:02:33,900
So my own personal bad habit here that I'm fessing up to, for those who haven't figured this one out yet,

00:02:33,900 --> 00:02:37,709
is every time I have a new version of the standard, I sit down to reimplement the standard library again.

00:02:38,590 --> 00:02:44,910
I've never completed it yet. Oddly enough. And it gets larger every time. I don't know how I'm ever going to get caught up

00:02:45,700 --> 00:02:50,669
The last few times, I really didn't get much beyond type traits... tuple...

00:02:51,610 --> 00:02:56,580
and perhaps we start on the containers and so forth. The thing that kills me these days is I got too

00:02:56,580 --> 00:03:01,290
good at writing test drivers. And to confidently finish testing something I

00:03:01,840 --> 00:03:04,649
Can probably finish one type-trait before the next standard rolls out?

00:03:05,740 --> 00:03:11,850
As an example: last time I was writing my test drivers for the type-traits, starting with a simple thing like is_integral,

00:03:12,310 --> 00:03:17,790
I had about 10,000 lines of different static assertions for the different types I was trying to test just for that one trait.

00:03:17,790 --> 00:03:23,459
And that would try that same battery of types on every single trait.

00:03:23,459 --> 00:03:25,459
So I had a consistent set to test.

00:03:25,959 --> 00:03:28,919
And that brings up a new problem, of how do you audit?

00:03:29,500 --> 00:03:34,679
10,000 static assertions that they all have the right true or false value? Are you testing what you think you're testing correctly?

00:03:35,080 --> 00:03:38,459
So I wasn't particularly happy with THAT iteration. So we go round again.

00:03:38,459 --> 00:03:43,649
And I start writing meta code to generate my tests, and then — so, well, is the metaprogram correct?

00:03:43,990 --> 00:03:48,719
So I keep chasing my tail on these things. You can see how I never quite get to the end of actually

00:03:49,240 --> 00:03:52,889
Convincing myself I've testing the type traits, in order to start on the next component.

00:03:53,680 --> 00:04:00,900
But it's always fun to start over here, so let's go. Implementing the type traits! Who figured this would be first?

00:04:01,959 --> 00:04:08,219
We start with type traits because the vast majority of the library, when you're implementing templates, is going to query a trait at some point somewhere in that implementation.

00:04:08,220 --> 00:04:13,020
So this is really the ground level of the standard library.

00:04:14,560 --> 00:04:23,220
It will give us an early exposure to testing our traits — and don't worry, I don't have too much on the test drivers here — just insights of what they brought me.

00:04:23,610 --> 00:04:28,729
So my first design question, thinking about type traits, coming into it new for C++17:

00:04:29,310 --> 00:04:34,430
Is there a minimum overhead kind of implementation that I can come up with for the type traits?

00:04:34,670 --> 00:04:38,059
How can I cut out any of that latent fat that might be there?

00:04:39,240 --> 00:04:41,240
So, this is what I came up with.

00:04:42,090 --> 00:04:48,800
You can see from the top we start implementing the — I'm doing the is_function trait — and I start with the *variable* template.

00:04:49,710 --> 00:04:55,190
Because when I'm doing all of my boolean predicate logic. I want to be querying boolean values.

00:04:55,190 --> 00:05:01,040
I don't want to be jumping into types trying to do funky metaprogramming with types that compute a value and then come back out to the trait;

00:05:01,040 --> 00:05:04,429
I just want to be in boolean logic all the way.

00:05:04,430 --> 00:05:10,490
So I'm going to make the "underscore-v" of the variable template my primary implementation and

00:05:11,130 --> 00:05:19,640
And then for the trait at the bottom, you can see I'm using an alias template for is_function; it's just the bool_constant of is_function_v.

00:05:22,590 --> 00:05:28,650
So the question is, is this actually conforming? and what does it buy us?

00:05:28,650 --> 00:05:34,530
So the rules in the standard says your trait's going to have a "base characteristic" of integral_constant.

00:05:34,530 --> 00:05:44,000
That was generally assumed to mean I'll derive publicly and unambiguously from that integral_constant type.

00:05:45,210 --> 00:05:50,359
But my interpretation, as you saw, is I'm going to try and use an alias template.

00:05:50,700 --> 00:05:58,999
That means I'm actually creating fewer class templates in my code, because an alias template doesn't create a new type. Everything is just an alias to true_type or false_type.

00:06:00,420 --> 00:06:07,010
The downside of this, of course, is now no one gets to specialize my trait unless they try specializing the "_v" things,

00:06:07,010 --> 00:06:12,890
which the standard doesn't tell them about because the standard is specified in terms of the regular class type trait.

00:06:12,890 --> 00:06:19,249
But the standard also tells users they're not allowed to specialize them. So if they try and do that they'll actually get an error, on my system.

00:06:19,410 --> 00:06:21,410
So I think that's a win.

00:06:23,700 --> 00:06:29,779
The same computing "_v" is now my primary system, so I have an easier time working in my logic with my traits.

00:06:29,780 --> 00:06:32,690
They'll be a lot simpler. So this is what you get thinking about these problems.

00:06:33,930 --> 00:06:37,970
But the only problem is some programs that are actually conforming will fail to compile.

00:06:38,460 --> 00:06:43,430
If you look at my awkward template here, it derives from is_object<T> and is_enum<T>.

00:06:43,680 --> 00:06:49,760
So if T is a reference type, if both of those are false_type, then I've got duplicate base classes, which are not allowed.

00:06:51,030 --> 00:06:54,919
So it's a nice idea, but doesn't quite work.

00:06:56,580 --> 00:06:59,630
But this is recreational C++. How much do I care about that?

00:06:59,630 --> 00:07:03,200
I'm not shipping a standard library, so I'm going to do things my easy way. Thank you very much.

00:07:05,090 --> 00:07:11,000
The other thing I did try to test — to demonstrate the wonderful performance winner, me, having far fewer actual traits being generated —

00:07:11,400 --> 00:07:17,179
was I'd write a simple test function, a function template taking in all the traits by const reference and so forth,

00:07:17,820 --> 00:07:23,839
and anyway, it spewed out thousands and thousands of these class templates coming out of my test driver and I felt very smug...

00:07:23,840 --> 00:07:27,200
because I was trying to emulate the notion of tag dispatch, because one of the reasons that you have these base characteristics is you want to do tag dispatch

00:07:27,840 --> 00:07:38,269
by passing a function your trait, they all slice to either true_type or false_type, and that guides your overload resolution.

00:07:38,970 --> 00:07:41,749
As soon as I put those actually down to slice into true_type and false_type

00:07:41,750 --> 00:07:47,149
rather than taking the thing in by value and querying the type out — so doing tag dispatch as it would be used — my advantage completely vanished.

00:07:47,150 --> 00:07:52,850
So it was a nice illusion while it lasted.

00:07:53,130 --> 00:07:57,350
But I still think it's an easier way to implement these. And it's my library; I can have fun.

00:08:00,090 --> 00:08:05,510
So this is where we start getting a little bit more participative. We're going to implement the is_function type trait.

00:08:06,690 --> 00:08:12,169
So nice thing we have C++11 almost. We have variadic templates.

00:08:12,870 --> 00:08:20,450
So the primary state is, an arbitrary type is not a function. And we now have — if I can make the laser work —

00:08:23,160 --> 00:08:30,049
First time playing with these things. My aim is terrible. Okay...

00:08:31,589 --> 00:08:33,589
Nope my aim really is terrible.

00:08:35,159 --> 00:08:41,929
Anything that's got a parameter of the form ResultType, parens — and a list of arguments — and the pack can be empty —

00:08:42,390 --> 00:08:44,839
That corresponds to everything that can be a function!

00:08:45,750 --> 00:08:48,320
Nice starting point. But.

00:08:49,500 --> 00:08:53,150
How many problems do we see? how many kinds of function is this missing?

00:08:57,060 --> 00:09:01,310
I'll start with the first one because I love this piece of syntax.

00:09:01,980 --> 00:09:07,909
A C-style ellipsis doesn't match the parameter pack. So I need to have this extra signature.

00:09:09,870 --> 00:09:14,359
It also means I get six dots in a row, which is a wonderful perverse corner. Unfortunately compilers like to warn you about this.

00:09:14,640 --> 00:09:18,739
So I put an extra comma in there just a silence the stupid compilers.

00:09:19,860 --> 00:09:25,430
And I think in C++20 we will now be requiring that comma. Because people had certain problems they wanted to solve with variadic macros,

00:09:25,430 --> 00:09:33,079
and there's a certain regularity that comes out if this comma ceases to be optional

00:09:33,720 --> 00:09:38,900
But that's on the road for C++20, it's not in '17. The requirement's not in '17 yet.

00:09:39,990 --> 00:09:44,930
What we do get in '17, of course, is exception specifications are part of the type system.

00:09:46,290 --> 00:09:55,579
So I now need at least four of these specializations before my trait is correct. And — can we see where this is going?

00:09:58,410 --> 00:10:01,820
We have these wonderful types — what I like to call "abominable" function types —

00:10:02,730 --> 00:10:06,829
Where the const/volatile qualifier is also part of the function type.

00:10:07,290 --> 00:10:11,839
If you've never met these horrible things, be blissful in your ignorance!

00:10:12,209 --> 00:10:17,059
But this is what happens when you start playing with your code and people start throwing whole test cases at you.

00:10:17,790 --> 00:10:22,640
This is the type of a member function — it can't be the type of a regular function, you can't make a pointer to these, you can't make a reference to these —

00:10:22,709 --> 00:10:31,189
You can never actually hold one in your code in a meaningful way, but they're in the type system.

00:10:33,209 --> 00:10:36,259
Because when you have a pointer to member...

00:10:37,380 --> 00:10:46,430
the type that the pointer member points to when you have a cv-qualified member function is one of these things.

00:10:48,029 --> 00:10:53,388
And if you're perverse you can even declare member functions using typedefs of these types.

00:10:53,389 --> 00:10:56,359
But that is really horrible. I don't want to go down that corridor.

00:10:58,079 --> 00:11:05,419
So we've now got these four, with the extra ellipsis version AND the extra noexcept version; so what is that, sixteen now?

00:11:06,899 --> 00:11:10,789
And then of course we've got reference qualifiers were added in C++11.

00:11:11,850 --> 00:11:17,060
With rvalue-reference-qualified versions, with the noexcepts and the ellipses...

00:11:18,630 --> 00:11:24,169
We've now got an awful lot of partial specializations in addition to the primary template

00:11:24,690 --> 00:11:28,579
just to try to get our is_function template correct.

00:11:28,579 --> 00:11:34,009
This is no longer looking like the neat quick fix that I was hoping that that wonderful pack expansion was going to give me.

00:11:35,579 --> 00:11:37,819
Yeah, recreation can sometimes be frustrating.

00:11:38,339 --> 00:11:45,349
I'm not even spoken about doing the extra specializations for "extern C" linkage — partly because I forgot and I can't remember either way.

00:11:46,139 --> 00:11:50,599
And we do have problems in certain environments where compilers have their own extensions for function types.

00:11:50,760 --> 00:11:59,040
Like Microsoft's got various declspec calling conventions that also ended up needing specialization here.

00:11:59,040 --> 00:12:01,219
Perhaps this isn't the right solution after all.

00:12:02,880 --> 00:12:08,449
Does anyone have an idea how else we might go about this? I'm not going to ask the man there that knows an answer.

00:12:09,810 --> 00:12:11,810
He's nodding far too happily.

00:12:14,010 --> 00:12:19,999
Asked the compiler. It'd be great if the compiler gave us an intrinsic for is_function. That is the best answer.

00:12:20,880 --> 00:12:30,049
Unfortunately, I'm not a compiler implementer. I'm a library implementer, and I'm looking for portable C++. I don't know I'll have that intrinsic on all my compilers.

00:12:32,670 --> 00:12:34,199
Hmm?

00:12:34,199 --> 00:12:36,439
The suggestion is that we call remove_cv.

00:12:37,470 --> 00:12:48,439
Now the problem is that cv-qualifier on your function type is not actually a cv-qualifier.

00:12:49,889 --> 00:12:55,589
If I call remove_cv and pass it one of these strange function types... Function types cannot be cv-qualified.

00:12:55,589 --> 00:13:03,009
It's a qualifier on the "this" pointer when I call a function.

00:13:04,190 --> 00:13:15,730
So it LOOKS like a cv-qualifier. If you play around with macros rather than typedefs you might start getting strange behavior where the compiler tries to treat these things as const/volatile in different places.

00:13:15,730 --> 00:13:17,730
But no, that's not a cv-qualifier, so it's not going to help me.

00:13:18,290 --> 00:13:22,149
But it is a nice exploration of the type system. Thank you.

00:13:24,890 --> 00:13:28,539
Okay, this is how clang solves a problem?

00:13:32,300 --> 00:13:35,200
Now I'll be fair the yellow

00:13:35,200 --> 00:13:41,919
Text is all is object and the blue is is reference so we can collapse this down into just three traits

00:13:42,350 --> 00:13:48,520
But those traits in turn are composites that are implemented in terms of I've basically in lined the whole operation

00:13:49,760 --> 00:13:57,249
So if I'm not a floating-point typing integral type in enumeration an array a pointer a member pointer

00:13:57,800 --> 00:13:59,630
not patottie a

00:13:59,630 --> 00:14:01,630
class or a union

00:14:02,600 --> 00:14:08,740
Void or any kind of reference all that's left is I must be a function

00:14:11,330 --> 00:14:13,330
And it works

00:14:16,730 --> 00:14:20,289
Interesting one is you have to check both is class and is Union

00:14:20,810 --> 00:14:23,109
The language says unions are class types

00:14:23,510 --> 00:14:30,129
But the library says you care about this distinction so we gave them two traits and his class will return false for reunion

00:14:30,620 --> 00:14:32,620
You have to query both

00:14:32,630 --> 00:14:35,979
That was another one. I learnt while going through this wonderful little exercise

00:14:37,279 --> 00:14:39,279
but yeah that works, and it's

00:14:39,920 --> 00:14:46,990
It's nice it fits on the slide, but it's not exactly the simple solution. I was looking for although. It's much simpler than

00:14:48,050 --> 00:14:50,050
48 different parts of specializations

00:14:51,470 --> 00:14:53,360
Eric nibbler

00:14:53,360 --> 00:14:57,459
Came up with this really neat solution and posted this online

00:14:58,520 --> 00:15:00,520
And I think you can find it on Stack, Overflow

00:15:02,360 --> 00:15:04,160
Start at the top on the bottom

00:15:04,160 --> 00:15:06,339
We're creating this priority tag type

00:15:06,339 --> 00:15:11,708
which is a type that recursively inherits, and I say I'm going to have this many different tag types and

00:15:12,410 --> 00:15:13,570
so I

00:15:13,570 --> 00:15:16,239
Tacked up. We're going to have three or four of these overlords on our tag

00:15:16,240 --> 00:15:20,979
type three derives from tag type to derive from tag type 1 derives from tag type 0

00:15:21,500 --> 00:15:26,650
So I can plug in the biggest tag type at the top and you all go down through the overload set and see which thing

00:15:26,650 --> 00:15:28,220
It matches

00:15:28,220 --> 00:15:30,220
Which is what we're doing at the bottom

00:15:30,350 --> 00:15:32,350
the test is simply saying

00:15:33,350 --> 00:15:40,930
It's fucking import of the size that I get from calling is function imple for my tag type says that's what

00:15:41,510 --> 00:15:43,510
Type of T. Was going to match

00:15:43,610 --> 00:15:48,820
So this is our filtering logic. You can see we're returning arrays of size 1 2 3 4 toes

00:15:48,820 --> 00:15:52,539
We can identify on the size of the return type in the unevaluated

00:15:53,570 --> 00:15:55,570
deckle type context

00:15:55,580 --> 00:15:57,290
what the

00:15:57,290 --> 00:16:00,430
wick of these filters got triggered and

00:16:01,310 --> 00:16:03,140
then we're using

00:16:03,140 --> 00:16:05,229
little trick with spin eye

00:16:05,570 --> 00:16:11,140
We're going to have a defaulted template parameter for a bunch of these function templates and in fact function template

00:16:11,140 --> 00:16:15,069
Matvey is you're going to get your strongest match and that is the overload or be selected

00:16:16,100 --> 00:16:23,350
So if we go see if I can get the laser working, this is going to match as it says here all array type

00:16:26,090 --> 00:16:30,340
Coming on down with a say, okay, I've not got an array I because arrays can't be

00:16:31,430 --> 00:16:34,419
Some promotions, I'll have anything can be returned from a function

00:16:35,180 --> 00:16:37,720
unlike an array so this will match all

00:16:38,480 --> 00:16:41,560
Other object types reference types and so forth in the system

00:16:42,740 --> 00:16:48,760
But you might spot as a problem with abstract types because you cannot return an abstract object type from a function

00:16:48,980 --> 00:16:52,660
So we need to filter those before we get down to this set before we get down to this set

00:16:53,300 --> 00:16:59,050
So this is a property based evaluation to say we know that function types can't be returned from functions

00:16:59,660 --> 00:17:02,559
If I can filter everything else this way

00:17:03,290 --> 00:17:05,649
I'm having the compiler do the work for telling me

00:17:06,740 --> 00:17:10,000
What can come out and is an actual function type?

00:17:10,790 --> 00:17:13,899
So the map you want to hit is this one at the top

00:17:13,900 --> 00:17:16,329
I've got an array of size 1 car, so that's what I'm actually

00:17:17,600 --> 00:17:20,439
Sincere at the end so that is our is function implementation

00:17:21,949 --> 00:17:23,949
Which I thought was quite neat

00:17:24,890 --> 00:17:31,839
Then we can go back to why was I generating 10,000 different test types to throw at these battery of tests so

00:17:32,450 --> 00:17:34,370
We can start with all going to have

00:17:34,370 --> 00:17:39,520
all the fundamental interval built-in types and the C be qualified versions of those and

00:17:39,920 --> 00:17:46,989
then point us to those and pointers to pointers to those and C be qualified versions of pointers to pointers to those and

00:17:47,360 --> 00:17:51,250
Then references to those into the point isn't to the pointers to the pointers

00:17:52,550 --> 00:17:58,060
then we can have arrays of all of the above apartment of the references and

00:17:58,910 --> 00:18:03,729
We're going to do two three dimensional arrays because you have got a recursive implementation of my trait

00:18:03,730 --> 00:18:10,150
I want to make sure that that recursion keeps playing through correctly. I found bugs and implementations of my code in the past

00:18:10,670 --> 00:18:16,329
By going up to the third but the fourth and beyond it was actually catching the recursion issues as long as I went to three

00:18:18,890 --> 00:18:20,330
And

00:18:20,330 --> 00:18:24,160
In order to support the largest possible typing the type system that

00:18:24,680 --> 00:18:26,680
annex B of compiler

00:18:26,720 --> 00:18:28,580
limitations tells me I'm allowed a

00:18:28,580 --> 00:18:32,800
Type of up to two to the eighth have to support the type of at least two to the 18 bytes

00:18:33,320 --> 00:18:35,320
so if I make an array of

00:18:35,870 --> 00:18:41,709
two two two two two two two two and I have 18 of those an 18 dimensional array I can have an ID net that

00:18:41,710 --> 00:18:46,750
Makes a little ray of cos where each is two so I'll test up to 18 dimensions

00:18:46,750 --> 00:18:51,010
Just because to make sure we're not falling out of any other surprising resource limits

00:18:52,580 --> 00:18:54,580
Then we get to function types

00:18:54,830 --> 00:19:01,900
so of course without coming up to 256 arguments with me that ellipses and no accept nor all those other wonderful things and

00:19:02,510 --> 00:19:04,510
McNab pointers and references to those

00:19:05,030 --> 00:19:08,829
We might want those to be taking and returning some interesting arguments

00:19:09,590 --> 00:19:12,400
We've also got pointers to members doing this same thing

00:19:13,580 --> 00:19:18,340
Then we've got actually getting down to creating the interesting things. We've got enumerations which can be

00:19:19,010 --> 00:19:23,979
In classes or regular enum, so it might just be a forward declared enum with a fixed base

00:19:23,980 --> 00:19:29,500
Type is so you think that came in C++, Aladdin, so these are all different parts of the type system to play with?

00:19:30,410 --> 00:19:37,209
And then we actually get around to doing the real interesting stuff, which is creating a variety of classes that are perverse in different ways

00:19:37,909 --> 00:19:43,869
They've got your ambiguous construction if you try and call them with the wrong things their move on me. They're not movable at all

00:19:45,320 --> 00:19:51,220
And so forth they'll overload the address of operator, but that's much more of a problem deepa d'amour library

00:19:52,129 --> 00:19:55,299
So having a battery of ten thousand test types. What do I learn?

00:19:56,720 --> 00:19:58,720
Eric's got a bug in

00:20:00,379 --> 00:20:02,379
One very odd corner

00:20:03,350 --> 00:20:07,719
If he's got an array of an incomplete class type

00:20:08,269 --> 00:20:13,029
Which is valid in the type system and has to be supported by this meta function

00:20:14,000 --> 00:20:16,000
He's going to say. That's a function

00:20:19,100 --> 00:20:25,779
So yes I might be utterly in saying in the depth of test vocabulary I use, but whoa it does stuff

00:20:28,639 --> 00:20:30,699
Thirteen was just because I thought this was unlucky

00:20:34,340 --> 00:20:38,590
It's a good question now, I forget getting really obscure and finding something right on the corner

00:20:38,659 --> 00:20:43,329
but one of the other funny things I found doing this which is come down to compile a bug reports I

00:20:44,149 --> 00:20:49,659
Think I was testing his integer at the time, or is enum, maybe Newseum. I had an enum

00:20:50,360 --> 00:20:54,789
forward declared with a bool as the underlying representation

00:20:56,450 --> 00:21:03,549
And it turned out with a purely if the enum was forward declared and only if bull was the underlying type a

00:21:04,309 --> 00:21:06,309
Debug build of crying would assert

00:21:09,679 --> 00:21:13,839
So they've got a nice little bug report and fixed it before the next release went out Jamie

00:21:13,840 --> 00:21:20,199
I expect nobody else was going to see or reported their buggy and spent developers time fixing about nobody else was going to see

00:21:22,820 --> 00:21:29,649
So this was my approach which was small enough just having got on to Twitter. I got to fit it on a single tweet yay

00:21:31,460 --> 00:21:33,460
So the idea here is

00:21:34,399 --> 00:21:38,529
Function types as we said earlier cannot actually have CV qualifiers

00:21:39,889 --> 00:21:43,359
So I know that my function type is never Const

00:21:44,870 --> 00:21:49,089
References have that same property, so I don't want it to be a reference either

00:21:50,029 --> 00:21:50,789
and

00:21:50,789 --> 00:21:53,988
Finally because I know T is. Not C be qualified

00:21:56,159 --> 00:21:59,868
Constantiy if I have a function type will still not be CB qualified

00:22:00,629 --> 00:22:05,449
So if I check if T and Conti are the same I have a function type

00:22:06,929 --> 00:22:08,929
And that passes my battery of tests

00:22:10,320 --> 00:22:11,489
and

00:22:11,489 --> 00:22:15,439
Then your highness job actually go back to me said we can actually make this slightly simpler

00:22:15,440 --> 00:22:18,529
So this is the final final answer coming down the rabbit hole

00:22:19,109 --> 00:22:23,749
I can just get is Const of T Const and that means

00:22:24,479 --> 00:22:28,939
It solves that wholly same thing so that was really neat and that really does pick it a single tweet

00:22:31,379 --> 00:22:33,738
And then we have the joy of Twitter

00:22:35,639 --> 00:22:37,819
I'll have to rate hang on last test

00:22:38,009 --> 00:22:46,009
You'll notice everything in that slide was actually simple enough apart from some of the variable template stuff to implement in C++ 98

00:22:47,099 --> 00:22:48,690
so this will work for

00:22:48,690 --> 00:22:54,649
functions of any number of argument types with with ellipses and all these things that were really hard to do without

00:22:55,649 --> 00:22:57,649
Just putting imposing arbitrary limits

00:22:58,289 --> 00:23:04,098
So this seemed quite neat we're actually using this now is our implementation at Bloomberg having me come down this rabbit hole

00:23:04,099 --> 00:23:10,399
I thought that would really neat and of course we're now filing complaints against all our still C++ 98 in those three vendors about

00:23:10,619 --> 00:23:12,619
V that you don't handle them

00:23:13,109 --> 00:23:17,659
Abominable functions that well, or you're actually allowing C. Be qualifiers on your references

00:23:18,659 --> 00:23:21,528
So it mostly works in 98 C

00:23:21,529 --> 00:23:25,998
It would work if you had they were fully conforming 98 compiler, but I'm not sure if any of those ever shipped

00:23:25,999 --> 00:23:29,478
I think most conformance came in by the time we had those had 11

00:23:29,999 --> 00:23:31,999
other than those wonderful folks at EDD

00:23:33,179 --> 00:23:35,478
Who actually implemented export back in the day?

00:23:36,570 --> 00:23:40,639
And the other fun thing I had throwing this against my wonderful battery of tests of course is

00:23:42,299 --> 00:23:44,129
Yeah, I

00:23:44,129 --> 00:23:50,389
Have I'm trying to talk to a different slide? I've got another bug report. That's coming up

00:23:52,440 --> 00:23:56,389
Or the other one that's right now came up with this and for unfortunately

00:23:58,559 --> 00:24:02,628
Compilers like to warn about ignoring that extra cons so although I've got a nice input

00:24:03,230 --> 00:24:09,589
New York implementation of the trait it might be very noisy when you compile a large code base against it with lots of useless warnings

00:24:10,559 --> 00:24:12,299
Yes, I know. It's

00:24:12,299 --> 00:24:14,299
being ignored

00:24:14,640 --> 00:24:20,780
So try benchmarking it to say yes, I've got this wonderful neat small implementation. That's testing much less than that

00:24:22,470 --> 00:24:27,260
Version after clang it's not doing all the big specializations the other libraries are doing and

00:24:27,960 --> 00:24:33,919
It was very disappointing most compilers even in debug mode saw through all this and optimized it all the way anyway

00:24:33,919 --> 00:24:36,889
And I didn't even spot a compile time win which is what I was hoping for

00:24:37,440 --> 00:24:39,440
So while it was a fun exercise

00:24:40,049 --> 00:24:42,109
I'll probably do my implementation this way I

00:24:43,020 --> 00:24:45,679
Couldn't actually measure a real real win from it

00:24:46,260 --> 00:24:52,910
But that's okay that was the goal of recreational C. Pass us by having fun and more learning things including working that

00:24:54,480 --> 00:24:58,939
Optimizing the heck out of something if you've not measured you're probably not optimizing at all

00:25:00,390 --> 00:25:07,910
And this is where I get to find got an interesting name mangling burg on VC C, but it's getting collisions on

00:25:10,049 --> 00:25:14,179
Abominable function type so it's things for the CV qualifiers and no accept

00:25:14,460 --> 00:25:20,720
Specifications because when they put that into the type system they didn't happen to check whether or not they're hashing algorithm for their types

00:25:20,940 --> 00:25:23,960
With or map for the mangling was going to give a distinct type

00:25:24,179 --> 00:25:30,409
But they got it reported in time so that when 7-1 was released it was already resolved so hopefully you'll never see that bug

00:25:31,620 --> 00:25:34,099
But the joy of playing with crazy things

00:25:35,100 --> 00:25:39,770
So this is where Twitter came back to me as soon as I can fit is function onto a tweet

00:25:40,290 --> 00:25:43,609
And the experiment comes back is can you do his integral and?

00:25:44,309 --> 00:25:49,339
This one was a lot more fun, and this one. I am going to start pulling the room a bit more for

00:25:50,610 --> 00:25:52,610
So what is an integral type?

00:25:53,160 --> 00:25:55,459
It's any of that list of 15

00:25:56,340 --> 00:25:59,240
specifically that list of 15 types at the top and

00:26:00,150 --> 00:26:07,280
Any C be qualified variations of those of course and any extended integer types that your system supports?

00:26:08,610 --> 00:26:10,610
It does not include

00:26:11,730 --> 00:26:13,730
Floating-point types

00:26:14,380 --> 00:26:21,420
Enumerations references to these things so I've got to make sure I can't simply match the reference take pointers to these types are rays

00:26:22,090 --> 00:26:24,480
types convertible to integer mustn't match either

00:26:25,870 --> 00:26:32,489
So how simply can I implement this if I'm going to try a strategy? That is not just?

00:26:33,070 --> 00:26:35,070
specialized those 15 types

00:26:40,300 --> 00:26:42,389
Shrine user is a non type temple argument

00:26:43,300 --> 00:26:46,109
That's right remember where that went. I mean Google drama

00:26:46,630 --> 00:26:52,439
Enums and pointers can be done that way so it's a start for a filter. It's not the one I chose

00:26:59,140 --> 00:27:01,439
Can I try using it as the

00:27:01,810 --> 00:27:09,029
Fixed base of an enum type because those by the language are required to be integral types that was exactly where I started

00:27:09,760 --> 00:27:13,709
It turns out that's not a spinner constraint even with the generalized, spin, I rules

00:27:15,060 --> 00:27:20,519
I write hard on that for days trying to float that into a swing I constraint doesn't work

00:27:22,390 --> 00:27:24,390
Any other ideas

00:27:26,770 --> 00:27:34,499
The size of an array an enum would fit in there, but I could just filter on enum I

00:27:35,860 --> 00:27:38,699
Did not try that one on that I have a suspicion

00:27:38,700 --> 00:27:43,950
I must have tried it and I'm trying to think what else may meant that was unraveling before me

00:27:44,560 --> 00:27:46,919
It's not the answer. We're going to see but it's a good try

00:27:49,330 --> 00:27:53,400
Because I try to start with a simple things and become more complicated as we go I

00:27:54,910 --> 00:27:57,959
Have to get back to you on that when it failed for more than just the enum case

00:27:58,660 --> 00:28:00,660
But accountant on what the other cases were

00:28:04,450 --> 00:28:06,280
Yeah

00:28:06,280 --> 00:28:07,840
Okay

00:28:07,840 --> 00:28:10,470
We're going to go with the first step and just try and do is arithmetic

00:28:11,170 --> 00:28:14,609
Because if I can do is arithmetic I can then start filtering down a bit further

00:28:16,840 --> 00:28:22,500
So an arithmetic type those same set of integral types we saw and the floating-point types

00:28:25,379 --> 00:28:29,179
It's a subset of the scalar type so scalar types are those types

00:28:29,700 --> 00:28:31,700
plus pointer types

00:28:31,919 --> 00:28:32,970
enumerations

00:28:32,970 --> 00:28:34,970
pointers the members are not - see and

00:28:35,970 --> 00:28:39,079
Doesn't include references classes and the raisins and so forth

00:28:41,759 --> 00:28:43,759
Anyone getting an insight with this yet

00:28:44,879 --> 00:28:48,019
anyone spot anything distinct about the subset of

00:28:48,960 --> 00:28:51,769
arithmetic types from the other types

00:28:52,440 --> 00:28:54,440
That make up scalar types

00:28:59,070 --> 00:29:02,210
Multiplication you're jumping about five slides ahead

00:29:05,220 --> 00:29:07,220
Thank you

00:29:08,700 --> 00:29:10,700
Key thing I spotted here is

00:29:11,460 --> 00:29:16,999
These are all built in fundamental types, and these are all composite types

00:29:21,629 --> 00:29:28,549
Now one of the properties of a fundamental type is that you cannot overload the operators for it?

00:29:34,289 --> 00:29:36,768
So let's take a look at unary operator plus

00:29:37,889 --> 00:29:44,659
if I write something that will match any type or provide the unit plus implementation in my namespace for

00:29:45,330 --> 00:29:47,330
generic type T

00:29:47,609 --> 00:29:53,029
That will not be called for any of the fundamental types, but it will match for everything else

00:29:53,029 --> 00:29:55,029
Or it wasn't a scalar typing it will

00:29:55,769 --> 00:29:58,128
Not go down there. I make sense of what we want scalar types of match

00:29:59,940 --> 00:30:05,809
So I'm going to have a sniffer function that can detect did I have a type that allows me to overload unary operator +

00:30:07,830 --> 00:30:09,830
So here we go

00:30:10,279 --> 00:30:12,059
I

00:30:12,059 --> 00:30:13,289
Have a

00:30:13,289 --> 00:30:20,329
Whole list of what don't work. Yes. I'll have an operator plus that will match any type and my primary template

00:30:20,330 --> 00:30:23,029
They're going to have type name void here for a reason. We will see shortly

00:30:23,789 --> 00:30:25,789
is arithmetic is false and

00:30:26,820 --> 00:30:32,359
I'm not going to describe it today, but this is a wonderful addition to C++ was this 14 or 17

00:30:33,389 --> 00:30:35,389
17 sir

00:30:35,700 --> 00:30:37,759
17 bunyan c++ 17

00:30:38,580 --> 00:30:40,580
creating swing I constraints on

00:30:41,280 --> 00:30:43,280
textual property yeah

00:30:43,350 --> 00:30:45,179
semantic properties or

00:30:45,179 --> 00:30:47,179
syntactical properties of code

00:30:47,820 --> 00:30:49,820
much much simple to create

00:30:50,580 --> 00:30:53,270
so if my condition matches

00:30:54,870 --> 00:30:59,809
This choice and void is a more specialized template. I lock my mouse pointer

00:31:03,660 --> 00:31:05,220
Hmm

00:31:05,220 --> 00:31:13,160
Okay, the the lower template is a more specialized template and therefore will match in preference to the primary template so for anything that

00:31:13,160 --> 00:31:14,220
has

00:31:14,220 --> 00:31:20,750
The ability to support, how are we going in unary operator plus on the default constructed or at value initialized?

00:31:21,690 --> 00:31:23,580
version of that object

00:31:23,580 --> 00:31:28,880
That doesn't hit this operation because that returns void and I'm not allowed to create

00:31:30,750 --> 00:31:32,750
Get the hang of pointing this thing

00:31:35,429 --> 00:31:39,798
But I'm making a reference to this so because my operator returns void I

00:31:40,320 --> 00:31:45,320
Can't create a reference to void so this is how I force the spin I constraint all the way through

00:31:47,400 --> 00:31:51,139
So now I have a syntax that says this will only match for arithmetic types

00:31:53,549 --> 00:32:00,799
No I made a bad assumption pointers and arrays also actually it turns out to match here

00:32:02,190 --> 00:32:08,419
So we're going to have to do a little bit more code to filter those out, and we'll use the multiplication operator. Thank you

00:32:09,929 --> 00:32:12,048
So with that to filter out the other types

00:32:12,049 --> 00:32:18,589
I now make sure that I've got a I want to make sure I've not got to use a different type that implements multiplication

00:32:18,590 --> 00:32:24,439
So I've still got to do my test for was I fundamental type, but this finally gives me is arithmetic

00:32:25,890 --> 00:32:27,890
and it works, so

00:32:29,160 --> 00:32:31,160
Now I want to do is integral

00:32:31,380 --> 00:32:35,390
Chuck I've already given the slide away unfortunately, I've got mom don't want some jump forward yet

00:32:35,669 --> 00:32:38,389
I just need to filter out those float types

00:32:38,970 --> 00:32:44,390
and I can do that with the percent operator float doesn't support this and

00:32:44,910 --> 00:32:49,429
Neither do arrays and pointers, so I don't even need this other constraint as well

00:32:50,429 --> 00:32:57,079
So now I have is integral implemented as per requested, but in two tweets sorry

00:32:57,960 --> 00:33:03,139
Can only go so far but apparently has off today. I might be able to get it into one tweet after all

00:33:03,660 --> 00:33:05,660
They're upping the limit

00:33:12,120 --> 00:33:14,630
So yep as I said this passed all my tests with quang

00:33:16,320 --> 00:33:22,850
It fails for a reason I have not yet figured out on GCC so I might be ahead of myself in thinking

00:33:22,850 --> 00:33:25,189
this is a great perfect solution or

00:33:25,890 --> 00:33:27,890
more possibly more likely, I'm

00:33:28,380 --> 00:33:33,320
Preferred to trust the compiler rather than myself, but I might have another bug report. I need to file on GCC here

00:33:34,080 --> 00:33:38,029
When it starts trying to do this when I constraint on this

00:33:38,730 --> 00:33:44,390
Calling here, but some ways. It's complaining about taking the address of a temporary array

00:33:45,960 --> 00:33:49,369
Now I I have no idea why it's trying to take an address of anything

00:33:50,040 --> 00:33:57,050
Nevermind temporary array, so I think it's a compiler, bug, but I've got no clue where to start reporting ongoing here some really wacky codes

00:33:58,620 --> 00:34:00,450
Please find the bug

00:34:00,450 --> 00:34:03,529
But that's somewhat to-do list when I get back to the hotel tonight

00:34:04,080 --> 00:34:10,819
I've not tried compiling this with microsoft c++ c++ and 14 week is it will obviously has to have a tie-break try another compiler

00:34:11,280 --> 00:34:16,729
But the last video c++ compiler I had access to before coming out was nothing vc

00:34:16,830 --> 00:34:21,830
2015 and didn't yet have support the variable templates, so I couldn't just quickly plug it in

00:34:22,800 --> 00:34:25,459
If somebody else can run that in the meantime that would be fantastic

00:34:29,040 --> 00:34:31,040
Sorry can you repeat the?

00:34:32,160 --> 00:34:36,379
Question is does this not require T to be default constructible and

00:34:38,160 --> 00:34:43,160
To an extent the answer is yes, this will only ever match true for a T that is default indestructible

00:34:43,290 --> 00:34:50,150
And we know that all the types are required to be supported our default constructible if T is not default constructible

00:34:50,730 --> 00:34:55,040
It's actually going to fail to form these things here in the void T

00:34:55,040 --> 00:34:59,570
And that will immediately spin, Iowa so anytime that's not default constructible

00:35:00,180 --> 00:35:03,350
Fails in a spin friendly manner and is filtered out

00:35:04,240 --> 00:35:09,040
I can't thank water enough for this trick is I thought I don't you solve all the problems in this space

00:35:09,040 --> 00:35:14,769
I didn't need this toy, but oh boy. It's so handy once you start using it it really simplifies things

00:35:18,260 --> 00:35:20,260
So

00:35:21,500 --> 00:35:23,500
I'm prompt tells me I might have been in

00:35:24,170 --> 00:35:28,599
For that thought I got more content than I did, but we'll keep going and we'll see how quickly we end

00:35:29,450 --> 00:35:31,450
standard pair was my next little

00:35:31,700 --> 00:35:36,250
Point of playing and we're going to pair through the ages is back into the trivia domain

00:35:37,550 --> 00:35:43,899
It turns out every version of the standard we tweak pair in some way even in C++. L3

00:35:45,530 --> 00:35:49,929
So in fact we've changed the signature of make pair

00:35:49,930 --> 00:35:53,830
Maybe subtly in every standard until C++ 17

00:35:54,680 --> 00:35:56,680
C++ 17 did not tweak the signature

00:35:56,869 --> 00:36:04,419
But it did clean out the normative wording of what that signature will actually do to fix some holes in the specification there there

00:36:04,420 --> 00:36:06,200
So we didn't get away scot-free

00:36:06,200 --> 00:36:08,409
but at least make pair survived, Sigma

00:36:09,680 --> 00:36:16,089
In fact so C++ 98 we take pair with make pair takes two cons references

00:36:17,480 --> 00:36:24,760
C-plus plus l3 we pass by value instead should anyone give me a 1 what one my answer for why that might be useful

00:36:26,810 --> 00:36:28,810
00:36:30,200 --> 00:36:33,369
If I want me to make pair with an auto pointer I

00:36:34,220 --> 00:36:39,310
Couldn't pass an auto pointer by constant reference because I'm going to modify the thing as I move it

00:36:39,800 --> 00:36:42,849
Implicitly if we pass by value we support

00:36:43,250 --> 00:36:50,169
movable types like Auto pointer of course some c++ c 11 we're going to go with perfect forwarding because now we actually know how to

00:36:50,480 --> 00:36:55,000
Do real move on the types and get perfect forwarding right and of course this broke code

00:36:57,589 --> 00:37:02,349
Which I think surprised a few people anyone know the use cases that this broke

00:37:08,360 --> 00:37:14,209
I have silence around the room okay imagine. I've got a map

00:37:15,690 --> 00:37:22,429
And I mean certain. I'm hearing somebody called it here. Do we want to have a say the microphone. Sorry you're being named and shamed

00:37:24,270 --> 00:37:29,060
There oh the answer is bound to be a map of some kind yes, so I'm trying to insert into a map

00:37:29,060 --> 00:37:31,060
I'm going to do make pair

00:37:32,820 --> 00:37:37,880
Big I could just have created the pair directly, but no I'm going to do make pair dammit and

00:37:39,090 --> 00:37:42,319
I'm going to make pair because I want to say the first

00:37:43,260 --> 00:37:46,940
Parameter is definitely a string and I'll deduce the second parameter

00:37:47,580 --> 00:37:49,729
so I do make pair string comma

00:37:51,270 --> 00:37:54,530
Second up as an explicit template parameter to my call

00:37:55,050 --> 00:38:01,459
That now means I'm no longer did using the first argument it has to be an R value to a string

00:38:02,220 --> 00:38:04,640
If the code I was passing there had an L value

00:38:06,090 --> 00:38:08,749
that no longer matches the function call and

00:38:09,930 --> 00:38:16,219
There's no easy way to rewrite that function that is saying. I really want that to deduce one, but not both parameters

00:38:17,670 --> 00:38:23,959
So there's a specific idiom there that actually Wiis all the way in the corner although this looks so much better than this

00:38:26,100 --> 00:38:28,160
This would have continued working and

00:38:30,270 --> 00:38:32,220
Are we saving the move

00:38:32,220 --> 00:38:34,670
Well you have to movie that yes. Oh yeah

00:38:35,190 --> 00:38:39,469
Probably the better answer, but it was an interesting corner that you uncover as you go

00:38:40,140 --> 00:38:42,890
Look for 14 hits simple. We just add Const x per but

00:38:46,020 --> 00:38:53,030
The puzzle that interests me at the moment is let's implement get because we've given the tuple API to pair

00:38:54,390 --> 00:38:56,930
So the string is fairly simple. I've got a

00:38:57,510 --> 00:39:01,969
It's called sex perform each time using the c++ 17 walls of their switch. I think looks the same as

00:39:02,790 --> 00:39:05,060
No, I think yeah, all the same is 14. I think Const

00:39:05,910 --> 00:39:08,119
That cost expend might be new to 17. I can't remember

00:39:08,820 --> 00:39:12,680
but we're going to call get on a pair and

00:39:13,230 --> 00:39:16,550
going pass an index, and we're going to get out of the first or second out and

00:39:17,130 --> 00:39:21,630
The obvious way you would implement. This is using partial specialization on the index and

00:39:22,150 --> 00:39:24,150
Yes

00:39:26,110 --> 00:39:32,789
Sorry it's integral we have confirmation works with visual C++ today awesome

00:39:36,670 --> 00:39:44,610
That's freaking back to this okay, so the obvious answer here is use partial specialization with the obvious caveat that you can't specialized function templates

00:39:45,250 --> 00:39:47,140
oops

00:39:47,140 --> 00:39:49,140
so

00:39:49,990 --> 00:39:51,990
We go back to wonderful C++

00:39:52,390 --> 00:39:58,949
98 here our technology we create a class template in this case between your pair util

00:39:59,320 --> 00:40:02,669
so I can partially specialize the pair utila pumpkin and

00:40:03,310 --> 00:40:05,310
Therefore within that I can call

00:40:05,710 --> 00:40:08,610
I can specialize the whole util for

00:40:09,610 --> 00:40:16,410
1 and 0 and just have a function called get within there and it returns out the first or second and now that we start

00:40:16,410 --> 00:40:18,310
Need to go through this whole

00:40:18,310 --> 00:40:23,910
What we call the tuple elements syntax kids I know that it's going to be t or you accordingly

00:40:24,610 --> 00:40:29,039
So that's a relatively straightforward implementation of get

00:40:30,460 --> 00:40:35,880
Any other ideas how I might implement this in c++ ninety eighty or a technology safe a standard library TR one

00:40:41,290 --> 00:40:43,290
Mentioned it earlier we can do tag dispatch

00:40:44,560 --> 00:40:49,439
So this gets away with a class template and that funky partial specialization. I just have to overloads on

00:40:50,380 --> 00:40:53,339
0 and what interval constant of zero and one so

00:40:55,000 --> 00:40:58,739
Depending upon your choice of style this may or may not be simpler

00:41:00,190 --> 00:41:02,190
preferences

00:41:03,910 --> 00:41:05,910
My preference is c++ 17

00:41:06,970 --> 00:41:08,970
We now have if Const x bar

00:41:09,610 --> 00:41:12,870
So I no longer need to do a dispatch at all

00:41:14,890 --> 00:41:22,140
Because a low p first and p second are returning different types, so one of those return statements is going to fail to compile

00:41:22,930 --> 00:41:25,440
with if Const x per only the

00:41:26,110 --> 00:41:28,919
Desired branch is actually going to be evaluated so

00:41:31,780 --> 00:41:34,199
This seems like you know really neat use of a new language and

00:41:34,750 --> 00:41:36,750
Is the fun you get when you start implementing?

00:41:36,800 --> 00:41:43,360
Pair from first principles every time you get a new standard library you start finding the new corners where the new language features can go

00:41:43,360 --> 00:41:45,360
in

00:41:47,330 --> 00:41:49,330
But can we get a funkier

00:41:51,980 --> 00:41:54,820
There's a strong analogy between pair and tuple

00:41:56,240 --> 00:41:58,100
and

00:41:58,100 --> 00:42:02,259
There's some nice idioms about how we implement to pool that might make this

00:42:02,510 --> 00:42:07,389
Implementation fall out especially if it can reuse the tuple code, so I've got smaller code base

00:42:08,390 --> 00:42:13,540
So the basic notion of a tuple implementation for those of you, who've not implemented tuple before is

00:42:14,390 --> 00:42:21,460
I'm going to have I've got a couple of parameters, and I'm going to want to derive from a wrapper

00:42:22,160 --> 00:42:24,490
Of each element and that gives me a base

00:42:24,490 --> 00:42:29,229
Just expand that base class now now got a bunch or that gives me the data structure for top one

00:42:29,230 --> 00:42:31,230
I've actually got it on the next slide

00:42:31,370 --> 00:42:35,769
basic idea is I'm going to have an implementation class which I forward declare and

00:42:37,190 --> 00:42:39,250
using C++ 14 type

00:42:40,130 --> 00:42:43,000
index sequence, which will make me an

00:42:43,610 --> 00:42:49,929
In-depth sequence of notes to end well or n minus 1 where n is the number of types in the parameter pack

00:42:49,930 --> 00:42:52,389
I will now have two parameter packs here of

00:42:53,030 --> 00:42:55,419
index and types of exactly the same length I

00:42:56,870 --> 00:43:00,789
Can just derive from my wrap class week

00:43:00,790 --> 00:43:05,139
You'll see it on the slide or two which is indexed by a number and the type

00:43:08,090 --> 00:43:15,879
Do we everyone know why I need to wrap with an index number here rather than just using a base expansion expand all the types

00:43:21,770 --> 00:43:24,310
Perfect answer if I have a tuple of two int I

00:43:25,190 --> 00:43:28,810
Can't have repeated base classes, so we need to make sure the taps are all distinct

00:43:28,810 --> 00:43:32,049
so I just generate an index that lets me count up to them and

00:43:32,480 --> 00:43:40,030
then might want meditation itself is simply I derived from that base class using index sequence for that will generate this type for me and

00:43:40,580 --> 00:43:43,090
Inherit my constructors, and it just works so

00:43:43,700 --> 00:43:48,010
Tipple is actually fairly simple all the funnies are in the Constructors another fun stuff here

00:43:49,310 --> 00:43:55,479
that part is not exactly what we're doing for pair, but this is for example what our

00:43:56,570 --> 00:44:00,370
wrapped wrap type might look like I'm going to have a

00:44:01,670 --> 00:44:09,399
Value of type T. Whatever I'm wrapping at this index. I'm valuing utilizing it because that's a rule for constructing tuples

00:44:10,520 --> 00:44:12,520
We'll talk about the validity of that later

00:44:13,790 --> 00:44:20,199
And creating a conversion to reference for all the various CB qualifiers. I'm going to be interested in

00:44:21,650 --> 00:44:23,650
and

00:44:24,860 --> 00:44:26,860
In order to call get I

00:44:29,750 --> 00:44:31,899
Really need to get better at my aiming skills

00:44:36,680 --> 00:44:38,680
Nope

00:44:38,960 --> 00:44:45,580
Wait at the bottom there we can see I'm calling my access function with just my tuple, but I'm calling access index n

00:44:46,550 --> 00:44:49,899
The access function I've got it almost this time

00:44:51,500 --> 00:44:53,649
Simply is parametrized on

00:44:54,440 --> 00:44:59,290
My wrap type with index, and whatever type it happens to match I will deduce the type

00:44:59,290 --> 00:45:00,760
I'm at I give it the index

00:45:00,760 --> 00:45:02,760
I slice to that base

00:45:02,840 --> 00:45:09,579
By reference and then by returning that value I call my reference operator overload and that gives me access to the element

00:45:09,740 --> 00:45:15,520
I've got all the different CB quality or constant and reference qualifiers here are value reference qualifiers here

00:45:15,590 --> 00:45:20,019
Because we overload for those four with get calls we have to ultimately support the whole set so

00:45:20,600 --> 00:45:23,019
That's how get works for

00:45:25,070 --> 00:45:27,879
Triple its does this really nice simple slicing function

00:45:28,730 --> 00:45:31,270
So can we do something similar for pair?

00:45:32,020 --> 00:45:34,170
if I implement my pair as

00:45:35,650 --> 00:45:40,289
to rap based classes and rather than having value as the data member I

00:45:40,870 --> 00:45:43,680
specialize for index zero and say it's called first and

00:45:44,530 --> 00:45:47,370
Specialize for the second index and say it's called

00:45:48,400 --> 00:45:55,739
Second and put the appropriate type depth in there and appropriately overload the reference function syntax is I can now use the exact same

00:45:56,110 --> 00:45:58,110
implementation that I actually had for a

00:45:58,540 --> 00:46:00,540
four tuple

00:46:01,060 --> 00:46:03,060
It seems kind of neat

00:46:03,340 --> 00:46:05,729
in fact that I've generalized the whole thing trying to use a

00:46:06,520 --> 00:46:11,070
Deco type Auto, which I believe is the form to return and preserve the reference on the return type

00:46:11,070 --> 00:46:14,190
so I'm not even happy to go through the whole tuple element stuff and

00:46:15,130 --> 00:46:20,999
You'll notice I'm passing something called to polish this will work with support. It'll work for pair. It'll work for not

00:46:21,000 --> 00:46:28,770
It'll not work for array because arrays doesn't build with this particular scheme, but anything that uses this kind of I wrap for a I

00:46:29,740 --> 00:46:31,740
inherit from a bunch of wrappers

00:46:32,080 --> 00:46:36,719
And now have one function and it implements all those libraries, so I felt kind of neat how

00:46:38,980 --> 00:46:40,980
Well does this conform to the standard

00:46:41,290 --> 00:46:46,590
I've now got a pair with two funky base classes does that match and drive with what the standard says

00:46:49,750 --> 00:46:53,130
Was there hearing a no why does it not match I

00:46:57,580 --> 00:47:01,709
Don't but the observation is pair is supposed to be standard layout

00:47:01,710 --> 00:47:03,930
I do not believe we make that requirement

00:47:04,330 --> 00:47:09,809
We indicate that it will look like a struct with two members first and second

00:47:11,380 --> 00:47:18,209
But we do not mandate that will be a standard layout strip, you can still have whatever crazy base class implementation details

00:47:18,210 --> 00:47:20,210
We want to have

00:47:22,000 --> 00:47:26,219
I'm not a hundred percent convinced. I have the layout guarantees

00:47:26,220 --> 00:47:29,490
I need that because it's an a struct with first followed

00:47:29,490 --> 00:47:34,740
But followed by second these are two public data members of a class I can do pointer arithmetic

00:47:35,170 --> 00:47:40,049
Between them and so forth I'm not sure that the standard is required to layout the class

00:47:40,420 --> 00:47:43,139
Explicitly in the order room with no padding that I would like here

00:47:43,870 --> 00:47:45,870
But I think it works

00:47:48,340 --> 00:47:53,249
Of course the next one is can we go all the way to say I want to have my pair

00:47:53,530 --> 00:47:55,980
use the very attic template form and

00:47:57,310 --> 00:48:02,940
We've C++. 20 we can because now we can say it requires that the size of types is 2

00:48:03,640 --> 00:48:06,269
0 1 1 will not works 3 or more will not work

00:48:06,270 --> 00:48:12,030
This will make only if I have exactly two types, and now I transform my T in you

00:48:12,820 --> 00:48:14,820
Into a bona fide a parameter pack

00:48:15,610 --> 00:48:17,610
Why is that a nice idea?

00:48:18,100 --> 00:48:25,620
It means that I can gently little utley exploit my tuple and pair to have the same implementation for all the free functions

00:48:25,870 --> 00:48:27,900
So the six comparison operators

00:48:28,450 --> 00:48:30,250
swap

00:48:30,250 --> 00:48:32,280
to blow method tuple sighs Mehta functions

00:48:32,280 --> 00:48:38,400
And it turns out when you get to the get overload says 12 for pair and 8 for tuple

00:48:38,400 --> 00:48:42,599
And I just need the eight overall so it does give me a small and neater

00:48:43,360 --> 00:48:44,830
solution

00:48:44,830 --> 00:48:50,549
Also looks quite bizarre. It's a lot of fun to make I'm not convinced. It's the right answer but

00:48:51,130 --> 00:48:53,130
darn, it was fun finding out I

00:48:57,370 --> 00:49:02,880
Don't know you picked up whether I have some unusual coding conventions there or whether some of those are begging interest

00:49:03,790 --> 00:49:06,090
The general knows you know how you do modern C++

00:49:06,090 --> 00:49:10,769
Now but one of the things I have when I'm playing around with my code is I get to play with coding conventions

00:49:11,110 --> 00:49:14,759
And this is one of those things you often take for granted with your code

00:49:14,760 --> 00:49:19,590
But if you start thinking about the way you're structuring your code the choice of

00:49:20,500 --> 00:49:21,840
layout of symbols

00:49:21,840 --> 00:49:29,789
And how you portray things it helps you understand what your code is trying to communicate and to a large extent

00:49:31,120 --> 00:49:36,779
Software development is about communicating information from the codes to the reader coming after you

00:49:38,380 --> 00:49:41,190
So I have a little bit of fun every time

00:49:41,190 --> 00:49:45,629
I started comes out I try and look for interesting new tweets and perversions I can do with the syntax

00:49:46,330 --> 00:49:48,330
Most I'm hopefully a fairly straightforward

00:49:48,640 --> 00:49:53,519
Good choice. I can do if a and B. Or if a double ampersand B

00:49:53,620 --> 00:49:56,959
Who prefers if a and I'm looking for a hands?

00:49:57,600 --> 00:50:02,120
I'm singing a small number of hands who prefers if a double ampersand B

00:50:02,790 --> 00:50:09,410
I'm seeing substantially more hands. Okay. I'll come to the second one. We've got tracked death a B or

00:50:11,250 --> 00:50:17,300
Using B is equal to a these are equivalent sin taxes now since c++ c 11 who prefers to type def

00:50:19,020 --> 00:50:22,550
I'm seeing a small smattering of hands who prefers the using

00:50:23,550 --> 00:50:29,390
Okay, so C++. 11 is definitely winning out on the second one of course the first ones both are valid in c++ out 98

00:50:30,210 --> 00:50:31,620
I

00:50:31,620 --> 00:50:34,039
On the first one definitely prefer using my hand

00:50:35,670 --> 00:50:41,030
Because this makes it very clear that I'm reserving double ampersand now to always mean an r-value reference

00:50:41,820 --> 00:50:44,390
And I have many more are very references running around my code

00:50:44,390 --> 00:50:48,559
Then I really would like the other group grep and see these things quite clearly

00:50:49,470 --> 00:50:52,880
Also in all Pascal hands so and really didn't surprise me too much

00:50:54,600 --> 00:50:58,819
It also means when I see a single ampersand all that could be confused with a reference

00:50:58,820 --> 00:51:04,189
This is much less frequently that you see a bitwise operator, and it means that if I see a single ampersand

00:51:04,190 --> 00:51:08,330
I'm not confused whether a double ampersand was meant and accidentally omitted

00:51:08,330 --> 00:51:15,469
It's a very deliberate total change of form of syntax, and I find that actually jumps out and helps me the clarity of the code

00:51:18,750 --> 00:51:25,429
And the questions wouldn't using bit hand also accomplish the same thing and yes, it would be

00:51:30,480 --> 00:51:34,910
And yes he would mean that ampersand was much more clear to preserve for regular references

00:51:35,010 --> 00:51:38,780
But I find the use of bitwise operations in my code base is small enough that

00:51:39,780 --> 00:51:45,650
The Swick of symbology is a much bigger jump to the eye, but in having better underscore in front of the end

00:51:46,290 --> 00:51:52,759
Also, you really want your operators to be small between the code that you're joining so I can read the predicates on either side much

00:51:52,760 --> 00:51:54,760
more clearly

00:51:56,070 --> 00:51:58,070
That's what's happening?

00:51:58,110 --> 00:51:59,220
Yeah

00:51:59,220 --> 00:52:05,900
But I had typed FA B. I always have to stop and pause and go which way around is this doing the aliasing and the

00:52:06,480 --> 00:52:07,520
assignment

00:52:07,520 --> 00:52:12,909
operator in there even though it's on an assignment operator disassemble always makes it implicitly clear to me I

00:52:13,849 --> 00:52:16,899
Liked it so much. I actually went then push the change request the

00:52:17,810 --> 00:52:22,629
ISO stand is actually available in github if you want to make editorial change it requests there

00:52:23,450 --> 00:52:25,070
This was a fairly substantial

00:52:25,070 --> 00:52:30,699
Editorial request you don't want to think about doing anything like this unless you speaking with the project editors who will be responsible for

00:52:30,859 --> 00:52:33,909
Landing your request. It's not just gonna go in for free

00:52:34,910 --> 00:52:36,140
but

00:52:36,140 --> 00:52:42,430
Yeah, it was popular enough to active the C++ 17 standard is now exclusively using this form in the standard library

00:52:42,430 --> 00:52:44,330
So I'm quite pleased about that little thing

00:52:44,330 --> 00:52:49,299
And the other problem of course being recreational C++ are now getting to recreation where the thing with standard

00:52:49,300 --> 00:52:51,999
And I got carried away playing around with the indexes as well

00:52:52,000 --> 00:52:56,050
so if you find the indexes of C++ 17 a bit better than they used to be

00:52:57,200 --> 00:52:59,740
Yeah, that's a danger of having this thing available on github now

00:53:02,150 --> 00:53:08,379
Other things that come with conventions is our choice of keywords. We're doing declaring a class template do we do?

00:53:08,990 --> 00:53:13,030
template classics or template type name a Supra first class

00:53:15,980 --> 00:53:19,060
Yeah about the half-dozen hands who prefers type name

00:53:20,420 --> 00:53:22,420
But it's longer

00:53:22,640 --> 00:53:24,640
Still seeing a fair number hands go up. Okay

00:53:25,250 --> 00:53:26,750
next rejection

00:53:26,750 --> 00:53:30,790
Doing a class a template template parameter since C++

00:53:30,790 --> 00:53:36,939
17 we can use type name here as well, so same question who prefers class in this context

00:53:39,380 --> 00:53:45,310
Few more hands for the familiar syntax who wants to move to type name in this syntax in this convention already C

00:53:45,310 --> 00:53:48,549
Is slightly over half the room so bit more debate on that one

00:53:50,690 --> 00:53:52,690
For an enum class

00:53:52,910 --> 00:53:59,410
Do I use enum class that we always was proposed in the paper or the equivalent enum struct just because I can

00:54:00,140 --> 00:54:02,140
Who prefers enum class?

00:54:03,710 --> 00:54:07,480
About 80% of the room who would still rather use enum stroke because they can

00:54:10,130 --> 00:54:11,420
Okay I

00:54:11,420 --> 00:54:14,409
See about half dozen hands there last one

00:54:14,930 --> 00:54:16,930
Do we prefer by default?

00:54:17,210 --> 00:54:19,210
to go with classics or

00:54:19,700 --> 00:54:25,270
Structure who prefers to default teams in the class keyword you can go out to provide member functions and so forth

00:54:28,730 --> 00:54:36,579
Eighty-seven seventy percent of the room who prefers going this struct anyway yeah about 25-30 percent

00:54:39,589 --> 00:54:43,269
My suggestion is class is always wrong I would love to deprecated it if I could

00:54:45,440 --> 00:54:47,530
This is what I've been doing in my homebrew code now

00:54:49,609 --> 00:54:52,719
The reason is yes class is shorter. I don't care

00:54:54,680 --> 00:55:02,530
Struct but especially you come to struct in class correct has the right defaults because it's going to default to public inheritance and public inheritance

00:55:02,530 --> 00:55:05,469
Is the right kind of inheritance I'm inheriting an interface?

00:55:06,079 --> 00:55:07,869
If I'm using private inheritance

00:55:07,869 --> 00:55:09,520
I'm inheriting implementation details

00:55:09,520 --> 00:55:16,569
And they're much better encapsulated and hidden using composition private inheritance would really be a rarity, and it shouldn't be our default

00:55:17,240 --> 00:55:22,629
It also means that when I start listing members of the class unless I want to go into a private straightaway

00:55:22,630 --> 00:55:28,210
I'm going to start listing the public interface, and this tells me what I can do with the class

00:55:28,210 --> 00:55:30,970
It's information for the use to say how do I use this thing so?

00:55:32,720 --> 00:55:38,349
Public by default actually tends to be my view when I was coming with my own brief coding conventions and

00:55:38,660 --> 00:55:42,280
Thinking and figure out your value systems seems to be the right default for me

00:55:44,150 --> 00:55:48,730
Now if you're leading the class and making everything private you're saying something different

00:55:49,700 --> 00:55:52,869
But you are saying something about the values of your code

00:55:52,869 --> 00:55:59,078
And you're saying the implementation data structure of how this code composed with other code

00:55:59,079 --> 00:56:04,568
And so I can reason about the bits flying around the system and have a much more hands-on

00:56:04,880 --> 00:56:07,569
Implementation level view of the system is what matters to me

00:56:08,000 --> 00:56:11,290
And if that is the nature what matters to you class probably

00:56:11,390 --> 00:56:14,890
Really is the right thing and that's the reason we use class at Bloomberg this?

00:56:15,020 --> 00:56:20,649
Might look how they actually work with professionally is going to be default to class and it's actually the right choice for what we do

00:56:21,410 --> 00:56:25,089
But by sitting around and playing with this the idea of recreational C++

00:56:26,300 --> 00:56:29,649
You get to better understand what your codes are trying to communicate to you

00:56:30,170 --> 00:56:33,159
And as I heard from the floor down here when you come to enum struct

00:56:34,070 --> 00:56:38,199
Struct is the right answer because it conveys its all public wiki it is

00:56:39,950 --> 00:56:44,410
So, that's where you go to type name on my templates now. I just want to retire class from my codebase entirely

00:56:44,410 --> 00:56:46,899
I have no use for it nor type def I

00:56:54,290 --> 00:56:56,350
Think the room says it all where

00:56:58,460 --> 00:57:04,120
But I did have fun with this because this is what I found on the Internet I

00:57:05,570 --> 00:57:11,499
Love this. This is fantastic. You'll notice. It's C code. Not C++. Oh it is both

00:57:12,920 --> 00:57:18,970
This is funky ideally I can read down to understand. I've got the right markers

00:57:19,310 --> 00:57:26,620
They're much more clearly ynette which code is where it's just odd to find that the semicolon terminating this statement is on the next wine

00:57:28,550 --> 00:57:30,999
But visually, I like my code very two-dimensional

00:57:31,820 --> 00:57:34,989
Although this gets our laugh when people see it. I really like it

00:57:36,050 --> 00:57:38,620
The problem is I tried writing C++ with it

00:57:39,980 --> 00:57:46,570
And we have too many decorators in our type system, so once you go beyond the simple wire so you're getting with C

00:57:46,570 --> 00:57:52,570
I mean it kind of works, but there's too much noise. I'm not getting the structure out the same as I want it

00:57:52,570 --> 00:57:54,570
There's also a small example and that doesn't help

00:57:57,350 --> 00:58:00,459
That's a yeah playing around with syntax is always fun

00:58:01,640 --> 00:58:07,869
Another example for playing around with syntax earlier on herb was suggesting this back at CPP con the very first one I believe

00:58:08,300 --> 00:58:10,300
always Auto everywhere

00:58:10,400 --> 00:58:13,119
Which was a bit more extreme than I was going with my auto usage

00:58:13,120 --> 00:58:16,089
So I sat around and I played with it. I know other people have done this as well

00:58:16,220 --> 00:58:20,500
It's a really neat idea the idea to got'em to two ways of declaring

00:58:21,470 --> 00:58:26,650
My class here if I use auto the compiler definitely knows. It's going to get the right type

00:58:28,130 --> 00:58:30,759
Most the time I can just reduce and don't have to say anything

00:58:30,760 --> 00:58:37,390
but the time this I want to be explicit and say you really are this time the notion is that we just

00:58:38,420 --> 00:58:40,780
Construct it on the right hand side as the right type and therefore

00:58:40,780 --> 00:58:43,630
It's going to deduce to be that so variables are

00:58:43,970 --> 00:58:48,010
Consistently and always introduced by the keyword Auto this basically says variable now

00:58:48,079 --> 00:58:53,379
And it gives you a simple consistent coding style you can be everywhere and I believe in C++

00:58:53,380 --> 00:58:58,900
17 someone correct me if I'm wrong, but with the new rules on copy of working and so forth being mandatory

00:58:58,900 --> 00:59:02,740
I think these two are now genuinely equivalent rather than having an implicit

00:59:03,980 --> 00:59:11,139
Optimization to have to occur there and the requirement that the type actually be movable. I think this work even four types aren't movable now

00:59:13,040 --> 00:59:15,040
My experience was that

00:59:15,079 --> 00:59:20,649
When you're writing function templates Auto is fantastic because did use him the right type that you're getting reexpress

00:59:20,650 --> 00:59:23,650
And you can't write code to do that, but it's always with Panther loved it

00:59:26,089 --> 00:59:31,719
In code that I'm frequently changing where I don't want to keep jumping and changing types because it's malleable

00:59:31,720 --> 00:59:34,659
I'm evolving I'm doing you rapid development iterative

00:59:35,240 --> 00:59:37,240
Auto was really helpful there

00:59:37,550 --> 00:59:42,039
Once I moved to a more stable code base saying okay, Mary why be failing maturing. I'm testing it

00:59:42,040 --> 00:59:47,050
I want this code to be fairly stable I hate to be found out like having explicit types in my type system

00:59:47,050 --> 00:59:51,099
And I found this syntax was just a bit too. Heavy wait for me to get it

00:59:51,710 --> 00:59:55,240
But I didn't know until I tried playing with it and your experience might be different

00:59:55,240 --> 01:00:00,339
That's the fun of playing around with your humbler projects play around with coding style see what comes up

01:00:01,849 --> 01:00:05,169
Function declarations, I've got the same overload set for different ways here

01:00:06,410 --> 01:00:08,440
First one is what you would get from C++. Cell sorry

01:00:09,319 --> 01:00:15,819
Second one is my first attempt at switching to C++ 11. I just went consistently. Let's always use the weight specified return type

01:00:17,240 --> 01:00:21,819
So the option was well a void function doesn't have a return type

01:00:21,819 --> 01:00:25,539
So I'll consistently use the white space pod return type apart from void

01:00:25,869 --> 01:00:30,279
Because don't you just know it conveniently matches up with auto is having four characters

01:00:30,410 --> 01:00:33,730
So it preserves the property that all my function names are line

01:00:34,130 --> 01:00:38,859
Which I didn't have in the oh three property so starting with

01:00:39,530 --> 01:00:45,369
Auto or void give me a really nice property when I'm trying to read through overload sets partly my settings over

01:00:45,369 --> 01:00:46,430
I'll just make this wide

01:00:46,430 --> 01:00:51,790
and the final option of course was I could go all the way down and say well ball is another four character things so I

01:00:51,790 --> 01:00:54,759
Don't want to pay the overhead of trying to write this extra thing out the far side

01:00:55,190 --> 01:00:58,750
Maybe this fourth character symbols might car a blessed

01:00:59,500 --> 01:01:02,229
And in practice. That's the one I found that worked well for me

01:01:03,110 --> 01:01:05,110
Hand at the back

01:01:05,930 --> 01:01:07,930
Sorry

01:01:09,020 --> 01:01:12,399
Would I do the same thing for long that would be down in this category

01:01:12,400 --> 01:01:14,860
I was playing around with anything that was four characters, I would

01:01:15,410 --> 01:01:19,600
Avoid myself to be this because all I wanted was the everything lining up property

01:01:19,970 --> 01:01:23,290
but in practice I found I preferred the consistency of a

01:01:23,570 --> 01:01:29,919
Result always went on the right-hand side and void was the exception because there is no result on the right-hand side

01:01:30,350 --> 01:01:33,189
It's a happy cancer there happens to be four characters

01:01:36,590 --> 01:01:41,679
Would I change this if void becomes regular know because void will not become regular darn it

01:01:44,990 --> 01:01:46,820
So I'm done

01:01:46,820 --> 01:01:48,820
last life a fan keyword games

01:01:49,340 --> 01:01:50,360
I

01:01:50,360 --> 01:01:52,599
Think I wrote it's an April 1st proposal on camera

01:01:52,600 --> 01:01:56,709
And I submitted it was the idea that people were looking ins around the era of C plus

01:01:56,710 --> 01:02:01,090
You know 2008 to have some kind of atomic keyword to introduce atomic variables

01:02:01,090 --> 01:02:07,299
And I said we don't want to introduce a new keyword we can handle it with existing keywords entirely do not break while using this

01:02:08,930 --> 01:02:12,879
So that when it came time for acceptance specifications we have do not throw a while using this

01:02:14,390 --> 01:02:19,150
So the fun game is what's the longest sentence you construct using just keywords?

01:02:19,730 --> 01:02:21,590
so here I have you know a

01:02:21,590 --> 01:02:26,739
Union guy threatening some poor warrior. Do not try this law out Auto Union case or else I

01:02:28,160 --> 01:02:30,160
Am sure you can do better

01:02:31,370 --> 01:02:33,639
But notice I'm heating I'm using not twice

01:02:36,110 --> 01:02:38,110
And without go out the end, thank you

01:02:43,250 --> 01:02:48,119

YouTube URL: https://www.youtube.com/watch?v=ovxNM865WaU


