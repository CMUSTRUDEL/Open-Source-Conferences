Title: CppCon 2017: Matt Godbolt “What Has My Compiler Done for Me Lately? Unbolting the Compiler's Lid”
Publication date: 2017-10-02
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
In 2012, Matt and a colleague were arguing whether it was efficient to use the then-new-fangled range for. During the discussion a bash script was written to quickly compile C++ source and dump the assembly. Five years later and that script has grown into a website relied on by many to quickly see the code their compiler emits, to compare different compilers' code generation and behaviour, to quickly prototype and share code, and investigate the effect of optimization flags. 

In this talk Matt will not only show you how easy (and fun!) it is to understand the assembly code generated by your compiler, but also how important it can be. He'll explain how he uses Compiler Explorer in his day job programming low-latency trading systems, and show some real-world examples. He'll demystify assembly code and give you the tools to understand and appreciate how hard your compiler works for you. 

He'll also talk a little about how Compiler Explorer works behind the scenes, how it is maintained and deployed, and  share some stories about how it has changed over the years. By the end of this session you'll be itching to take your favourite code snippets and start exploring what your compiler does with them. 
— 
Matt Godbolt: DRW, Senior Software Engineer

Matt Godbolt is a software engineer with trading firm DRW, and the creator of the Compiler Explorer website. He is passionate about writing efficient code. He has previously worked at on mobile apps at Google, run his own C++ tools company and spent more than a decade making console games. When he's not hacking on Compiler Explorer, Matt enjoys writing emulators for old 8-bit computer hardware.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,751 --> 00:00:03,756
- My talk is called What Has My Compiler Done for Me Lately?

00:00:03,756 --> 00:00:05,486
Unbolting the Compiler's Lid.

00:00:05,486 --> 00:00:09,049
Which is the longest and most complicated title I've seen.

00:00:09,049 --> 00:00:11,713
Titles, it turns out, are very hard.

00:00:11,713 --> 00:00:15,380
So why am I up here staring back at you all?

00:00:16,285 --> 00:00:18,958
It's definitely a question I'm asking myself at the moment.

00:00:18,958 --> 00:00:20,513
(audience laughter)

00:00:20,513 --> 00:00:22,765
As Jason, in his wonderful introduction, has said,

00:00:22,765 --> 00:00:27,408
my name has rather unexpectedly become a noun and a verb,

00:00:27,408 --> 00:00:31,017
which has led to some extraordinarily surreal conversations

00:00:31,017 --> 00:00:33,003
this last week.

00:00:33,003 --> 00:00:35,432
I've not only had people come up to me that,

00:00:35,432 --> 00:00:37,944
oh, had people come up to me and introduce themselves

00:00:37,944 --> 00:00:39,291
as if we're old friends, and I'm looking

00:00:39,291 --> 00:00:40,634
at them smiling going, "Who are you?"

00:00:40,634 --> 00:00:41,904
And then they say, "Thank you for Compiler Explorer,"

00:00:41,904 --> 00:00:43,321
which is amazing.

00:00:44,376 --> 00:00:46,300
Or I've been in conferences and people

00:00:46,300 --> 00:00:47,731
have been talking about Godbolt and, you know,

00:00:47,731 --> 00:00:49,697
like how there are those neurons in your brain

00:00:49,697 --> 00:00:51,702
that are always background process listening out

00:00:51,702 --> 00:00:54,165
for your own name, and I'm just looking around like this,

00:00:54,165 --> 00:00:55,433
so it's been very very very surreal,

00:00:55,433 --> 00:00:58,146
but thank you for the very warm reception.

00:00:58,146 --> 00:00:59,978
I'm going to talk a little bit about me

00:00:59,978 --> 00:01:02,395
just so you know how it is that I came to come up

00:01:02,395 --> 00:01:05,079
with this idea for Compiler Explorer.

00:01:05,079 --> 00:01:08,287
Like a lot of people, I'm sure, I started,

00:01:08,287 --> 00:01:10,269
a long time ago, programming on

00:01:10,269 --> 00:01:12,626
these 8 bit computers here, which is,

00:01:12,626 --> 00:01:15,779
as Jason alluded to, still kind of a hobby of mine,

00:01:15,779 --> 00:01:19,862
I'm still hacking around on the 6502 and the Z80.

00:01:21,129 --> 00:01:24,892
After a few years of trying to write my own games,

00:01:24,892 --> 00:01:26,949
I've been writing stuff in assembly 'cause that's

00:01:26,949 --> 00:01:29,137
the only way you could get anything done performantly

00:01:29,137 --> 00:01:30,934
back in those days.

00:01:30,934 --> 00:01:32,856
I moved over to the ARM processor,

00:01:32,856 --> 00:01:35,075
I sort of hung onto the 8 bit era rather too long

00:01:35,075 --> 00:01:37,050
and then, when the leap came, I made it

00:01:37,050 --> 00:01:38,981
all the way to 32 bit.

00:01:38,981 --> 00:01:41,355
And back in those days, there wasn't a version

00:01:41,355 --> 00:01:44,821
of GCC for my computer, so I was stuck still

00:01:44,821 --> 00:01:46,825
writing assembly code.

00:01:46,825 --> 00:01:49,318
I even ended up writing a whole IRC chat client

00:01:49,318 --> 00:01:51,622
in assembly, complete with windowing and scripting

00:01:51,622 --> 00:01:52,966
and everything built in just because

00:01:52,966 --> 00:01:56,826
that was pretty much the only option open to me.

00:01:56,826 --> 00:01:59,204
When I finally was introduced to C,

00:01:59,204 --> 00:02:03,346
I considered it a bit of a macro assembler.

00:02:03,346 --> 00:02:06,235
It was kind of like one of these things was an annoyance,

00:02:06,235 --> 00:02:07,585
it got in the way of me writing the assembly

00:02:07,585 --> 00:02:10,012
that I wanted to write.

00:02:10,012 --> 00:02:12,501
But when I got to university and discovered that,

00:02:12,501 --> 00:02:16,064
oh, wow, suddenly it's very dark in here.

00:02:16,064 --> 00:02:17,903
Nobody falling asleep, right?

00:02:17,903 --> 00:02:19,002
When I got to university and realized

00:02:19,002 --> 00:02:20,900
that the only way that I could actually like

00:02:20,900 --> 00:02:23,031
write software that would run on more than just

00:02:23,031 --> 00:02:26,476
my one ARM computer that I had, I realized I had to learn C.

00:02:26,476 --> 00:02:30,197
And at that point, things moved on, and eventually C++ too.

00:02:30,197 --> 00:02:32,530
That led to me getting a job

00:02:33,486 --> 00:02:36,150
in the games industry, where I spent 10 happy years.

00:02:36,150 --> 00:02:37,462
Still kind of on the fence between

00:02:37,462 --> 00:02:41,763
writing assembly code and C code and maybe a bit of C++.

00:02:41,763 --> 00:02:45,288
After that, I had a dabble in writing C++ tools,

00:02:45,288 --> 00:02:47,799
so for those people who work on C++ tools,

00:02:47,799 --> 00:02:50,215
I have a huge amount of sympathy for you.

00:02:50,215 --> 00:02:51,851
The language is absolutely dreadful

00:02:51,851 --> 00:02:54,312
and is the worst thing to have to parse.

00:02:54,312 --> 00:02:55,946
So if you see anyone from like JetBrains

00:02:55,946 --> 00:02:57,678
or anything like that, give them a good firm handshake,

00:02:57,678 --> 00:02:59,146
or anyone from Eclipse.

00:02:59,146 --> 00:03:03,331
I then worked at a small Internet startup.

00:03:03,331 --> 00:03:07,652
And then I moved on to DRW, which is the company I'm at now

00:03:07,652 --> 00:03:10,892
where I do sort of low latency stuff.

00:03:10,892 --> 00:03:12,687
So you can sort of say I've always stayed

00:03:12,687 --> 00:03:14,854
pretty close to the metal.

00:03:16,086 --> 00:03:17,314
So what about this talk?

00:03:17,314 --> 00:03:18,702
It's an amazing opportunity to speak

00:03:18,702 --> 00:03:20,752
to so many C++ developers, and I thought to myself,

00:03:20,752 --> 00:03:23,164
what am I gonna do with this time?

00:03:23,164 --> 00:03:26,648
What do I love, what do I wanna tell people about?

00:03:26,648 --> 00:03:28,449
I love assembly, you've probably realized that

00:03:28,449 --> 00:03:29,958
from the last few slides.

00:03:29,958 --> 00:03:32,582
So I wanna make sure that you guys

00:03:32,582 --> 00:03:35,660
are happy and aren't scared looking at assembly,

00:03:35,660 --> 00:03:38,653
it's a useful thing to do and you should be doing it.

00:03:38,653 --> 00:03:40,284
Not all the time, and I'm not saying

00:03:40,284 --> 00:03:43,296
that you should go out and learn how to write assembly code

00:03:43,296 --> 00:03:45,243
or that you should even ever write assembly code,

00:03:45,243 --> 00:03:47,280
but you should be able to look at the output

00:03:47,280 --> 00:03:49,661
of your compiler and, with some confidence,

00:03:49,661 --> 00:03:51,546
know what it's doing.

00:03:51,546 --> 00:03:52,779
And when you do that, you'll appreciate

00:03:52,779 --> 00:03:55,076
how much work has gone into the compiler

00:03:55,076 --> 00:03:57,741
and how clever the compiler is.

00:03:57,741 --> 00:03:58,973
There's a lot of glamorous features

00:03:58,973 --> 00:04:00,199
that come out in the language.

00:04:00,199 --> 00:04:01,955
You know, all these new meta classes,

00:04:01,955 --> 00:04:04,081
Herb's awesome meta classes ideas.

00:04:04,081 --> 00:04:05,486
Reflection is coming and all

00:04:05,486 --> 00:04:07,593
the template meta programming tricks that you can do

00:04:07,593 --> 00:04:08,737
with the compiler, that's awesome.

00:04:08,737 --> 00:04:10,462
But that's all in the frontend.

00:04:10,462 --> 00:04:11,813
It's very important as well that the code

00:04:11,813 --> 00:04:13,082
that comes out at the other end,

00:04:13,082 --> 00:04:15,703
the thing that actually is going to run on the computer

00:04:15,703 --> 00:04:18,782
is efficient, well, first, is correct,

00:04:18,782 --> 00:04:22,882
and secondly, is about as efficient as it can be.

00:04:22,882 --> 00:04:24,396
So the outline of this talk is that,

00:04:24,396 --> 00:04:25,670
and I give a little bit of a backstory

00:04:25,670 --> 00:04:28,640
as to how Compiler Explorer came about.

00:04:28,640 --> 00:04:32,991
I wanna give you a very quick x86 assembly overview.

00:04:32,991 --> 00:04:33,976
I wanna ask the question,

00:04:33,976 --> 00:04:35,712
"What has my compiler done for me lately?"

00:04:35,712 --> 00:04:37,225
Which is just to say I'm gonna look at

00:04:37,225 --> 00:04:39,501
some of the optimizations, some of the cool optimizations

00:04:39,501 --> 00:04:40,363
that compilers do.

00:04:40,363 --> 00:04:42,656
Now, of course, these are all gonna be slide examples,

00:04:42,656 --> 00:04:44,866
so they're all totally contrived,

00:04:44,866 --> 00:04:47,384
but hopefully you'll get, it'll whet your appetite for it.

00:04:47,384 --> 00:04:49,144
And then I'm gonna talk a little bit about what happens

00:04:49,144 --> 00:04:50,737
when you type into my website,

00:04:50,737 --> 00:04:54,250
what's happening behind the scenes to give you your

00:04:54,250 --> 00:04:57,741
code results back in front of you.

00:04:57,741 --> 00:05:00,907
So in 2012, a friend and I were at work

00:05:00,907 --> 00:05:02,271
and we were discussing whether or not

00:05:02,271 --> 00:05:04,688
it would be possible for us to start turning on

00:05:04,688 --> 00:05:06,981
the C++0x flag or the C++11 flag on the compiler

00:05:06,981 --> 00:05:08,542
and start using some of these new features

00:05:08,542 --> 00:05:10,984
that were coming through, you know.

00:05:10,984 --> 00:05:15,335
Things like range fors, auto variables, things like that.

00:05:15,335 --> 00:05:18,297
And being a high frequency trading shop,

00:05:18,297 --> 00:05:20,759
we can't just say to everyone, "Go ahead,

00:05:20,759 --> 00:05:22,809
"just use whatever cool new feature is available,"

00:05:22,809 --> 00:05:25,830
we need to make sure that we haven't done any harm.

00:05:25,830 --> 00:05:28,284
So we concocted an example bit of code like this,

00:05:28,284 --> 00:05:31,237
which is, as you can see, it's just taking a vector

00:05:31,237 --> 00:05:33,703
by reference, vector of integers by reference,

00:05:33,703 --> 00:05:35,519
and it's just summing them all up.

00:05:35,519 --> 00:05:37,541
Yes, this could just be std::accumulate, I know,

00:05:37,541 --> 00:05:39,286
but bear with me.

00:05:39,286 --> 00:05:41,777
And we wondered that this traditional way of writing it,

00:05:41,777 --> 00:05:45,366
that is just a looping over an iterator by using an index

00:05:45,366 --> 00:05:48,505
into that, looping over a container, I'm sorry,

00:05:48,505 --> 00:05:50,848
by using an index into that container.

00:05:50,848 --> 00:05:51,912
That would be how we'd write it before,

00:05:51,912 --> 00:05:53,425
we wondered whether or not we could replace it with

00:05:53,425 --> 00:05:57,719
the much nicer code here just using, you know, range for.

00:05:57,719 --> 00:06:00,087
We've been bitten before by other languages because

00:06:00,087 --> 00:06:01,779
some managed languages in particular

00:06:01,779 --> 00:06:05,672
that we had some experience with will construct iterators

00:06:05,672 --> 00:06:09,937
in order to iterate over a container like that

00:06:09,937 --> 00:06:12,412
And that would generate garbage and ultimately

00:06:12,412 --> 00:06:14,299
things would go on behind the scenes, obviously,

00:06:14,299 --> 00:06:16,996
C++ doesn't have garbage, but we just didn't know,

00:06:16,996 --> 00:06:18,010
we would like to check, you know,

00:06:18,010 --> 00:06:19,485
we should test these things.

00:06:19,485 --> 00:06:20,914
Which one of these is better than the other?

00:06:20,914 --> 00:06:24,298
And that would be kind of like the leg into us,

00:06:24,298 --> 00:06:27,871
me talking about how Compiler Explorer came about.

00:06:27,871 --> 00:06:29,925
And if my clicker works, we'll go to the next one.

00:06:29,925 --> 00:06:31,500
Before I get into a whole bunch of assembly,

00:06:31,500 --> 00:06:32,764
we're gonna sort of tell you, give you

00:06:32,764 --> 00:06:34,744
at least enough information to know about

00:06:34,744 --> 00:06:37,903
how to read assembly, I'm gonna give you a big warning here.

00:06:37,903 --> 00:06:40,031
It's really beguiling to stare at the output

00:06:40,031 --> 00:06:43,782
of your compiler and start to kid yourself

00:06:43,782 --> 00:06:45,176
that you can see what it's doing

00:06:45,176 --> 00:06:47,665
and know instinctively that this is better than that

00:06:47,665 --> 00:06:49,183
or this other thing is best or like,

00:06:49,183 --> 00:06:52,012
there are fewer instructions and so it must be faster,

00:06:52,012 --> 00:06:53,321
things like that.

00:06:53,321 --> 00:06:55,569
If any of you were in here before for Chandler's talk,

00:06:55,569 --> 00:06:57,632
he gave just a tiny glimmer of the kind of

00:06:57,632 --> 00:06:59,489
complicated things that are going on inside

00:06:59,489 --> 00:07:03,992
a modern processor and you really can't predict.

00:07:03,992 --> 00:07:05,546
While you can obviously develop an intuition

00:07:05,546 --> 00:07:08,055
about what's going on, you should always measure

00:07:08,055 --> 00:07:09,201
and you should definitely use something like

00:07:09,201 --> 00:07:11,599
Google Benchmark or one of the other benchmarking libraries

00:07:11,599 --> 00:07:13,275
that's out there that have done their best

00:07:13,275 --> 00:07:15,919
to try and make it as bulletproof as possible,

00:07:15,919 --> 00:07:18,299
although microbenchmarks have their own problem.

00:07:18,299 --> 00:07:20,209
Or you can, a quick shout out to Fred

00:07:20,209 --> 00:07:23,780
if he's in the audience somewhere for his site, quick-bench.

00:07:23,780 --> 00:07:25,208
Hey.

00:07:25,208 --> 00:07:27,911
Which is an awesome online tool that allows you

00:07:27,911 --> 00:07:29,225
to check out two different snippets

00:07:29,225 --> 00:07:30,661
and compare the performance, again,

00:07:30,661 --> 00:07:31,910
using Google Benchmark behind the scenes,

00:07:31,910 --> 00:07:34,155
but also in an interactive online way.

00:07:34,155 --> 00:07:36,124
And I've, I click a down, whoops.

00:07:36,124 --> 00:07:38,256
So let's talk a little bit about x86.

00:07:38,256 --> 00:07:40,588
Well, first of all, I guess, how many of you

00:07:40,588 --> 00:07:44,679
compile for x86 platforms by raise of hands?

00:07:44,679 --> 00:07:45,746
Good.

00:07:45,746 --> 00:07:47,340
I had this terrible fear that suddenly,

00:07:47,340 --> 00:07:49,513
everyone was gonna say, "No no, we do ARM now."

00:07:49,513 --> 00:07:51,892
All right, who does ARM, ARM predominantly?

00:07:51,892 --> 00:07:53,707
There's a few hands.

00:07:53,707 --> 00:07:57,982
What about 32 bit x86, is that still being targeted?

00:07:57,982 --> 00:07:59,705
A smattering.

00:07:59,705 --> 00:08:01,107
Anyone got a more exotic processor

00:08:01,107 --> 00:08:02,889
that they regularly build for?

00:08:02,889 --> 00:08:04,732
Oh, yes, some PDP-11, right?

00:08:04,732 --> 00:08:07,226
(laughs)

00:08:07,226 --> 00:08:09,339
All right, well, that gives me at least some legs,

00:08:09,339 --> 00:08:10,241
it would be really embarrassing now

00:08:10,241 --> 00:08:14,629
if suddenly I had to invent another architecture

00:08:14,629 --> 00:08:16,568
to talk about, but we're gonna talk about x86,

00:08:16,568 --> 00:08:18,568
and specifically x86-64.

00:08:19,491 --> 00:08:20,764
We don't need to know too much about it.

00:08:20,764 --> 00:08:23,116
All you need to know, it has registers.

00:08:23,116 --> 00:08:26,151
These are 64 bit values and there are 16 of them.

00:08:26,151 --> 00:08:28,073
Back in the 32 bit version of the chip,

00:08:28,073 --> 00:08:30,657
there were only eight of them with these funny names,

00:08:30,657 --> 00:08:32,477
ax, bx, cx, dx and all these things,

00:08:32,477 --> 00:08:34,332
and some of them have like special meanings as well,

00:08:34,332 --> 00:08:36,262
but for the most part, you can think of them

00:08:36,262 --> 00:08:38,605
as general purpose like variables.

00:08:38,605 --> 00:08:41,103
Luckily, when AMD decided to extend out

00:08:41,103 --> 00:08:44,410
to the 64 bit version, they added in eight more registers,

00:08:44,410 --> 00:08:47,001
which was handy, and instead of inventing new funny names,

00:08:47,001 --> 00:08:51,200
they just called them the far more sensible r8 to r15.

00:08:51,200 --> 00:08:52,485
Those are where the integers are stored,

00:08:52,485 --> 00:08:55,494
that's like your integer variables inside the processor.

00:08:55,494 --> 00:08:57,398
There are some other registers, the xmm registers

00:08:57,398 --> 00:08:59,922
or ymm and zmm, depending on which revision

00:08:59,922 --> 00:09:01,313
of the processor you've got.

00:09:01,313 --> 00:09:02,754
Any of your sort of floating point operations

00:09:02,754 --> 00:09:05,082
will happen in there, and any sort of packed operations

00:09:05,082 --> 00:09:06,520
will happen in those registers too,

00:09:06,520 --> 00:09:08,789
but by and large, and at least for this talk,

00:09:08,789 --> 00:09:11,507
I'm not gonna talk about those registers.

00:09:11,507 --> 00:09:13,015
The only other thing you need to know is that

00:09:13,015 --> 00:09:15,785
there's an ABI, there's a way that functions

00:09:15,785 --> 00:09:18,093
talk to each other, and that's by convention.

00:09:18,093 --> 00:09:20,930
And that convention is that, when I call a function,

00:09:20,930 --> 00:09:24,766
the arguments of that function wilL be an rdi, rsi, rdx,

00:09:24,766 --> 00:09:26,828
and then some other registers.

00:09:26,828 --> 00:09:28,141
And then, if you're returning a value,

00:09:28,141 --> 00:09:31,044
an integer value, that is, you're gonna leave it in rax.

00:09:31,044 --> 00:09:32,719
And there are rules about which registers

00:09:32,719 --> 00:09:35,325
you're allowed to overwrite and which registers

00:09:35,325 --> 00:09:37,667
you have to preserve, but if you're not writing assembly,

00:09:37,667 --> 00:09:39,410
you don't need to know.

00:09:39,410 --> 00:09:43,577
That's kind of like our ABI for talking between functions.

00:09:45,986 --> 00:09:48,667
Now, registers, as I've said, are 64 bit.

00:09:48,667 --> 00:09:51,659
But they have all these different names.

00:09:51,659 --> 00:09:53,925
So this is, I've given rax as an example here,

00:09:53,925 --> 00:09:56,853
but this is true also for rbx, rcx, all the other ones,

00:09:56,853 --> 00:09:59,640
and even, you know, r8 through r15.

00:09:59,640 --> 00:10:00,742
If we put an r at the beginning,

00:10:00,742 --> 00:10:03,227
we mean the whole 64 bits of the register.

00:10:03,227 --> 00:10:06,354
If we say eax, we mean a 32 bit version of the register.

00:10:06,354 --> 00:10:08,502
And we just get the bottom 32 bits.

00:10:08,502 --> 00:10:11,210
And for complicated reasons, if you write to eax,

00:10:11,210 --> 00:10:14,119
it zeroes out the top 32 bits.

00:10:14,119 --> 00:10:16,248
That's not true of ax, ah and al,

00:10:16,248 --> 00:10:18,233
which are these names for the bottom 16 bits

00:10:18,233 --> 00:10:22,067
and then the two bottom bytes, which are kind of legacy.

00:10:22,067 --> 00:10:24,272
I mean, this is kind of how Intel have maintained

00:10:24,272 --> 00:10:26,834
backwards compatibility right back up to the,

00:10:26,834 --> 00:10:30,429
I think the 8088, by having essentially just

00:10:30,429 --> 00:10:32,346
adding on these, widening the registers

00:10:32,346 --> 00:10:35,468
and giving them new names each time.

00:10:35,468 --> 00:10:38,449
Once you've got registers, you have to do things with them.

00:10:38,449 --> 00:10:41,561
So that's when we finally get to talk about instructions.

00:10:41,561 --> 00:10:42,746
So instructions can take anywhere

00:10:42,746 --> 00:10:46,913
between zero and three operands, and unlike Chandler's talk,

00:10:48,435 --> 00:10:51,102
I'm using the Intel syntax here.

00:10:52,504 --> 00:10:53,758
Yeah (laughs).

00:10:53,758 --> 00:10:54,716
(applause)

00:10:54,716 --> 00:10:56,645
God, I had a whole routine done for like tabs

00:10:56,645 --> 00:10:58,031
vs spaces and things, but I didn't realize

00:10:58,031 --> 00:11:00,628
it was gonna get that much of a clap.

00:11:00,628 --> 00:11:02,854
By show of hands, who uses Intel syntax

00:11:02,854 --> 00:11:04,618
when they're looking at assembly?

00:11:04,618 --> 00:11:08,504
Oh, okay, and who uses the AT&T syntax?

00:11:08,504 --> 00:11:12,457
Oh, oh good, I thought I was gonna make some enemies today.

00:11:12,457 --> 00:11:15,799
This is why Compiler Explorer, listen to me,

00:11:15,799 --> 00:11:17,668
Compiler Explorer has Intel assembly by default,

00:11:17,668 --> 00:11:20,003
because it makes sense and because I grew up--

00:11:20,003 --> 00:11:21,400
(audience laughter)

00:11:21,400 --> 00:11:23,178
And everyone else is wrong, I'm sorry.

00:11:23,178 --> 00:11:26,806
No, because I grew up, again, with ARM and 6502,

00:11:26,806 --> 00:11:28,031
and they all have like the destination

00:11:28,031 --> 00:11:29,051
on the left hand side.

00:11:29,051 --> 00:11:30,368
So if you see anything on my slides,

00:11:30,368 --> 00:11:31,849
the destination of the instruction

00:11:31,849 --> 00:11:34,017
is gonna be the left hand parameter.

00:11:34,017 --> 00:11:37,095
So operations could be things like call, return,

00:11:37,095 --> 00:11:39,271
add, subtract, exclusive or, and,

00:11:39,271 --> 00:11:41,693
all those kind of bits and pieces.

00:11:41,693 --> 00:11:45,611
And then sort of uniquely to x86, well, not uniquely.

00:11:45,611 --> 00:11:48,566
Specific to CISC type machines like x86 is,

00:11:48,566 --> 00:11:51,585
those destination and source registers, sorry,

00:11:51,585 --> 00:11:54,497
things that are up there don't have to be registers.

00:11:54,497 --> 00:11:56,731
They often are, but they can (audio cuts out)

00:11:56,731 --> 00:11:58,320
references to memory.

00:11:58,320 --> 00:12:01,495
And being as complicated as it is,

00:12:01,495 --> 00:12:03,049
the reference to memory can actually be

00:12:03,049 --> 00:12:04,584
more than just a memory address.

00:12:04,584 --> 00:12:07,094
We get this huge let of options at the bottom here,

00:12:07,094 --> 00:12:09,377
we get like a base, which is a constant.

00:12:09,377 --> 00:12:10,636
We can pick another register and say

00:12:10,636 --> 00:12:12,231
add that register to it.

00:12:12,231 --> 00:12:13,924
And then we can also pick yet another register

00:12:13,924 --> 00:12:17,871
and add a multiple of one, two, four or eight to it.

00:12:17,871 --> 00:12:19,387
Obviously, this is handy for things like arrays

00:12:19,387 --> 00:12:21,238
because you wanna have a pointer to the beginning

00:12:21,238 --> 00:12:22,786
of the array, and then you wanna get like

00:12:22,786 --> 00:12:25,505
the ith element, you're gonna put i in one of the registers

00:12:25,505 --> 00:12:27,541
and then you're gonna multiply it by one, two, four, eight

00:12:27,541 --> 00:12:30,178
to kind of move it forward that number of bytes.

00:12:30,178 --> 00:12:32,065
So that's really powerful.

00:12:32,065 --> 00:12:33,250
But it sorts of blurs the line

00:12:33,250 --> 00:12:35,030
about what a single instruction should be.

00:12:35,030 --> 00:12:37,211
I mean, if you can do all this on like an add.

00:12:37,211 --> 00:12:38,808
And in fact, this is the kind of thing

00:12:38,808 --> 00:12:40,896
we're talking about here, we've got a bunch

00:12:40,896 --> 00:12:43,074
of instructions there, I also put the C equivalent

00:12:43,074 --> 00:12:44,574
on the other side.

00:12:45,861 --> 00:12:47,413
You can kind of see the pattern there, I think,

00:12:47,413 --> 00:12:50,287
where like, the first one is just reading from r14,

00:12:50,287 --> 00:12:52,522
it says r14 is an address and I'm gonna read four bytes

00:12:52,522 --> 00:12:56,054
from it and interpret it as an integer, put it into eax.

00:12:56,054 --> 00:12:58,439
Second one is just adding two registers together.

00:12:58,439 --> 00:13:00,073
Then we can start to see these more sophisticated

00:13:00,073 --> 00:13:02,572
addressing modes where we can add

00:13:02,572 --> 00:13:06,240
whatever's r14 plus a small constant into eax,

00:13:06,240 --> 00:13:08,305
it would read out like the first element of an array

00:13:08,305 --> 00:13:10,473
if r14 was an integer array.

00:13:10,473 --> 00:13:14,526
And then that subtracts sub eax, DWORD PTR, blah blah blah.

00:13:14,526 --> 00:13:16,760
That is doing that array index operation

00:13:16,760 --> 00:13:18,264
that I was just saying about.

00:13:18,264 --> 00:13:20,497
Now, it turns out that the array indexing stuff

00:13:20,497 --> 00:13:23,019
is so powerful and so useful that there's an instruction

00:13:23,019 --> 00:13:25,151
that just says hey, compute the address

00:13:25,151 --> 00:13:26,790
that I would otherwise want to read from

00:13:26,790 --> 00:13:28,260
and just give me the result of what

00:13:28,260 --> 00:13:30,159
that address computation is.

00:13:30,159 --> 00:13:32,580
That's that penultimate instruction at the lea,

00:13:32,580 --> 00:13:34,601
the load effective address.

00:13:34,601 --> 00:13:36,533
It's kind of a glorified add, it was designed

00:13:36,533 --> 00:13:39,227
to effectively do like the C code equivalent shows,

00:13:39,227 --> 00:13:42,392
like take the address of some element in a subarray.

00:13:42,392 --> 00:13:44,442
But it is also effectively just adding

00:13:44,442 --> 00:13:46,910
a bunch of things together in a more sensible way,

00:13:46,910 --> 00:13:49,779
you might argue, than the actual add instruction.

00:13:49,779 --> 00:13:50,887
And then it's worth calling out this thing

00:13:50,887 --> 00:13:54,009
on the bottom here, that xor edx, edx.

00:13:54,009 --> 00:13:54,842
It seems kind of weird

00:13:54,842 --> 00:13:58,118
to do exclusive or on something with itself.

00:13:58,118 --> 00:13:59,265
But as you've probably worked out,

00:13:59,265 --> 00:14:02,131
if you take any number and exclusive or it with itself,

00:14:02,131 --> 00:14:04,172
you end up with zero, so this is a fancy way

00:14:04,172 --> 00:14:06,847
of setting edx to zero.

00:14:06,847 --> 00:14:09,069
Why might you want to do it that way?

00:14:09,069 --> 00:14:12,765
Well, in order to encode a move instruction,

00:14:12,765 --> 00:14:15,246
move eax, 0, you would need to put the instruction

00:14:15,246 --> 00:14:17,791
for move down and then you'd have to put the four bytes

00:14:17,791 --> 00:14:20,085
that correspond to the zero that came through.

00:14:20,085 --> 00:14:22,243
Whereas this exclusive or is only two bytes

00:14:22,243 --> 00:14:24,442
to encode the op code, so it's smaller

00:14:24,442 --> 00:14:26,855
and more compact in terms of code efficiency.

00:14:26,855 --> 00:14:28,200
There are also some architectural reasons

00:14:28,200 --> 00:14:30,397
inside which are super exciting and interesting,

00:14:30,397 --> 00:14:34,137
but I don't have time to go into here.

00:14:34,137 --> 00:14:36,533
So in summary, funny 64 bit registers,

00:14:36,533 --> 00:14:38,788
they have different names, parameters are passed

00:14:38,788 --> 00:14:42,463
in rdi and rsi first, result comes out in rax,

00:14:42,463 --> 00:14:45,593
operations are with the destination on the left hand side

00:14:45,593 --> 00:14:47,640
and destination and source can be registers

00:14:47,640 --> 00:14:49,890
or those memory references.

00:14:51,178 --> 00:14:55,345
Okay, so now you all know how to read x86 assembly.

00:14:58,156 --> 00:15:00,126
Where were we, we were here, we were comparing

00:15:00,126 --> 00:15:03,287
these two implementations of effectively standard accumulate

00:15:03,287 --> 00:15:05,129
over a vector of ints.

00:15:05,129 --> 00:15:08,540
Which is better, well, let's have a look at it.

00:15:08,540 --> 00:15:09,437
Let's have a look at the assembly,

00:15:09,437 --> 00:15:10,538
that's how we look at these things.

00:15:10,538 --> 00:15:14,705
This is Compiler Explorer version 0.1, it's a shell command.

00:15:15,974 --> 00:15:20,064
So I was running g++ on a temp file,

00:15:20,064 --> 00:15:21,244
putting the optimizer on, telling it

00:15:21,244 --> 00:15:25,378
to just output the assembly instead of assembling it,

00:15:25,378 --> 00:15:28,660
outputting to dash, which is standard out.

00:15:28,660 --> 00:15:33,202
And of course, the very important masm=intel.

00:15:33,202 --> 00:15:35,418
Pipe it through c++filt because the mangled names

00:15:35,418 --> 00:15:37,921
don't mean anything to me, and then this funny grep here

00:15:37,921 --> 00:15:39,889
is just removing all of the funny lines,

00:15:39,889 --> 00:15:42,792
the dot directives the compiler needs to put in

00:15:42,792 --> 00:15:44,944
in order to talk to the assembler in order to get like

00:15:44,944 --> 00:15:47,524
a real program out but I'm not interested in.

00:15:47,524 --> 00:15:49,909
And we got something like this.

00:15:49,909 --> 00:15:52,452
I don't know if you know about the Unix watch command.

00:15:52,452 --> 00:15:54,152
It's a command that takes another command

00:15:54,152 --> 00:15:55,747
and it just sits there and runs it in a loop

00:15:55,747 --> 00:15:57,920
and it keeps running it over and over again.

00:15:57,920 --> 00:15:59,556
And you can even put --dif, and it will show you

00:15:59,556 --> 00:16:01,540
a difference from the previous time it ran.

00:16:01,540 --> 00:16:04,170
And so I just split my terminal in half with tmux,

00:16:04,170 --> 00:16:06,715
ran that in one side and run vi on the other.

00:16:06,715 --> 00:16:09,382
There you go, Compiler Explorer.

00:16:11,793 --> 00:16:13,268
We found it so useful.

00:16:13,268 --> 00:16:14,665
We were able to answer all sorts of questions

00:16:14,665 --> 00:16:16,755
about how the code was being compiled,

00:16:16,755 --> 00:16:18,398
and once you've got a tool like this,

00:16:18,398 --> 00:16:22,640
you start thinking hmm, I wonder what else we can do.

00:16:22,640 --> 00:16:25,144
So I went home that night, and it was hurting me

00:16:25,144 --> 00:16:28,704
that this was a great solution, but it was not very pretty.

00:16:28,704 --> 00:16:30,343
And so what do you do when something doesn't look

00:16:30,343 --> 00:16:34,226
very pretty, you could use a cool graphical toolkit, right.

00:16:34,226 --> 00:16:37,171
Or you could go to the web.

00:16:37,171 --> 00:16:39,952
So, oh gosh, I'm so glad that loaded.

00:16:39,952 --> 00:16:43,247
This is Compiler Explorer, many of you have seen it before.

00:16:43,247 --> 00:16:46,054
And this is the example, so this is the embedded view.

00:16:46,054 --> 00:16:49,165
But I'm not gonna show the embedded view because, frankly,

00:16:49,165 --> 00:16:52,339
it is too small, oh, I'm gonna have to...

00:16:52,339 --> 00:16:54,918
All right, is that just about readable?

00:16:54,918 --> 00:16:57,335
Yeah, oh good, and the yellow shows up, hooray.

00:16:57,335 --> 00:16:58,168
Okay.

00:16:58,168 --> 00:16:59,949
So here's our example.

00:16:59,949 --> 00:17:01,963
And on the left hand side, we have the code.

00:17:01,963 --> 00:17:03,515
On the right hand side, we have the assembly

00:17:03,515 --> 00:17:05,455
that comes from it.

00:17:05,455 --> 00:17:08,079
I'm compiling with GCC 7, 7.1 here,

00:17:08,079 --> 00:17:09,971
it's the version I wrote this talk with

00:17:09,971 --> 00:17:11,478
and I'm paranoid about changing anything

00:17:11,478 --> 00:17:13,506
in case it all moves around.

00:17:13,506 --> 00:17:16,829
Inside the compiler options here, I'm using O2

00:17:16,829 --> 00:17:20,322
and C++1z and arch=haswell.

00:17:20,322 --> 00:17:22,834
Haswell is an Intel variant that's about five years old

00:17:22,834 --> 00:17:25,615
and is in most servers, it's a fairly safe baseline

00:17:25,615 --> 00:17:27,032
in my experience.

00:17:29,183 --> 00:17:31,139
Just to sort of give a brief sort of wave,

00:17:31,139 --> 00:17:32,687
hand-wavy introduction, we're gonna go

00:17:32,687 --> 00:17:34,495
into a little bit more detail in a second.

00:17:34,495 --> 00:17:36,514
If I mouse over this yellow area here,

00:17:36,514 --> 00:17:37,991
you can see that there are two yellow areas

00:17:37,991 --> 00:17:40,340
on the right hand side that have sort of become

00:17:40,340 --> 00:17:43,401
a bit bolder, although it's difficult to see on that screen.

00:17:43,401 --> 00:17:46,712
The color coding tries to match up the source lines

00:17:46,712 --> 00:17:48,476
with the assembly output.

00:17:48,476 --> 00:17:51,028
So although we don't really know that much about assembly,

00:17:51,028 --> 00:17:53,045
apart from my crash course I've just given you,

00:17:53,045 --> 00:17:57,614
we can see the int result = 0 corresponds to xor eax, eax.

00:17:57,614 --> 00:17:59,826
So we know that xor eax, eax is the same

00:17:59,826 --> 00:18:02,488
as eax = 0, so we can at least sort of see

00:18:02,488 --> 00:18:05,493
a parallel between those two things.

00:18:05,493 --> 00:18:07,672
Similarly, if I look at this red block here,

00:18:07,672 --> 00:18:09,966
this is where we're accumulating into the result.

00:18:09,966 --> 00:18:13,237
Now again, because we're xoring eax with zero,

00:18:13,237 --> 00:18:17,129
we might reasonably intuit that the compiler is using eax

00:18:17,129 --> 00:18:19,010
to hold the value of the result while it's running

00:18:19,010 --> 00:18:19,948
through its loop.

00:18:19,948 --> 00:18:21,872
And indeed, this is backed up by us looking at

00:18:21,872 --> 00:18:25,402
the add eax, DWORD PTR [rdx], which is it just saying

00:18:25,402 --> 00:18:28,081
I'm gonna accumulate into eax with

00:18:28,081 --> 00:18:32,305
whatever is pointed at by rdx, and then it moves rdx on.

00:18:32,305 --> 00:18:35,157
And then you'll notice that this return result is white,

00:18:35,157 --> 00:18:38,190
there's no actual assembly instruction corresponding to it.

00:18:38,190 --> 00:18:40,703
That's because, when the compiler

00:18:40,703 --> 00:18:44,348
is finished executing this loop of adding things up,

00:18:44,348 --> 00:18:45,782
the result is already in the eax,

00:18:45,782 --> 00:18:47,599
which is where we needed to leave

00:18:47,599 --> 00:18:49,652
the return value for our caller.

00:18:49,652 --> 00:18:51,387
So there's actually no instruction.

00:18:51,387 --> 00:18:53,025
I mean, typically, I guess you could argue

00:18:53,025 --> 00:18:55,403
this red here should be attributed to the result,

00:18:55,403 --> 00:18:58,841
but it's not perfect how these things are lined up.

00:18:58,841 --> 00:19:01,653
Okay, so before I get too far into this,

00:19:01,653 --> 00:19:02,636
I would just like to show you what happens

00:19:02,636 --> 00:19:05,202
if we turn the optimizer off.

00:19:05,202 --> 00:19:07,582
So optimizer off, and I'm not gonna go through all this,

00:19:07,582 --> 00:19:10,534
but the compiler does pretty much exactly what we asked it.

00:19:10,534 --> 00:19:12,135
So this is kind of interesting and useful

00:19:12,135 --> 00:19:14,655
just to sort of see fully what it is

00:19:14,655 --> 00:19:16,136
that you have asked the compiler to do.

00:19:16,136 --> 00:19:18,592
And we can see that there's a whole bunch of code

00:19:18,592 --> 00:19:20,653
that's been generated here, these vector operations

00:19:20,653 --> 00:19:22,246
have been emitted.

00:19:22,246 --> 00:19:24,114
And if you went to the linker talk earlier today

00:19:24,114 --> 00:19:26,665
you'd know that they were marked as weak

00:19:26,665 --> 00:19:28,700
and things like that.

00:19:28,700 --> 00:19:29,700
But on O1...

00:19:32,136 --> 00:19:34,910
Yeah, we've got a mov eax, 0 here,

00:19:34,910 --> 00:19:37,123
it's funny that GCC has decided that just

00:19:37,123 --> 00:19:40,339
replacing mov eax, 0 with xor eax, eax

00:19:40,339 --> 00:19:42,171
is just not worth doing at O1.

00:19:42,171 --> 00:19:44,282
I don't know quite what the rationale is there.

00:19:44,282 --> 00:19:47,582
And then if you put it on O3, which is the one true setting

00:19:47,582 --> 00:19:50,415
but not very good for, as we know.

00:19:52,232 --> 00:19:53,702
It's amazing.

00:19:53,702 --> 00:19:55,517
I mean, look at this stuff.

00:19:55,517 --> 00:19:56,665
There's pages of it, and I'm sure

00:19:56,665 --> 00:19:58,586
it's all super super awesome and it uses

00:19:58,586 --> 00:20:00,222
all these vector instructions,

00:20:00,222 --> 00:20:03,529
which are super cool and everything.

00:20:03,529 --> 00:20:04,750
But we'd have to benchmark to make sure

00:20:04,750 --> 00:20:07,133
that was actually faster than the simple version.

00:20:07,133 --> 00:20:09,482
I trust the compilers a lot, but anyway,

00:20:09,482 --> 00:20:10,637
it's too much to fit on the slide,

00:20:10,637 --> 00:20:13,750
so I'm kind of settling for O2 for most of this stuff.

00:20:13,750 --> 00:20:15,014
All right, anyway, what was our original question?

00:20:15,014 --> 00:20:17,469
It was are we okay to do a range for?

00:20:17,469 --> 00:20:20,636
Now, I am gonna drag down one of those

00:20:22,231 --> 00:20:24,825
and I'm gonna paste the code down here and I'm going to

00:20:24,825 --> 00:20:28,792
hide away the hidden set of code that I've put there.

00:20:28,792 --> 00:20:30,596
The font size is slightly too big here,

00:20:30,596 --> 00:20:31,825
but I'm sure you'll give me the benefit

00:20:31,825 --> 00:20:33,630
of the doubt for a second, so I'm gonna go

00:20:33,630 --> 00:20:37,837
for (auto x : v) result += x, and I'm gonna delete

00:20:37,837 --> 00:20:39,918
those two lines, and nothing's happened,

00:20:39,918 --> 00:20:42,513
'cause all I've done is I've created an edit window.

00:20:42,513 --> 00:20:44,397
The UI is such that I need to now actually

00:20:44,397 --> 00:20:46,163
slave a compiler to that window,

00:20:46,163 --> 00:20:47,473
so I'm gonna pick up a compiler

00:20:47,473 --> 00:20:49,190
and I'm gonna put it over here.

00:20:49,190 --> 00:20:50,619
And then, just to make it a fair fight,

00:20:50,619 --> 00:20:53,513
I am gonna grab the same command line options

00:20:53,513 --> 00:20:55,359
and paste them in there.

00:20:55,359 --> 00:20:56,692
Okay, well, I can scroll up and down

00:20:56,692 --> 00:20:58,375
and see that there's 14 instructions there

00:20:58,375 --> 00:20:59,535
and there's 18 instructions there,

00:20:59,535 --> 00:21:01,130
but there's a better way to sort of see what's going on,

00:21:01,130 --> 00:21:02,818
I'm gonna bring down a diff view

00:21:02,818 --> 00:21:04,591
and I'm gonna maximize it, all right.

00:21:04,591 --> 00:21:07,513
This is all good, there we go.

00:21:07,513 --> 00:21:08,616
All right, this is what I wanted to see.

00:21:08,616 --> 00:21:11,919
This is the two versions side by side with a difference.

00:21:11,919 --> 00:21:14,056
So you can see, on the left hand side

00:21:14,056 --> 00:21:17,255
is the version that is using the loop over from

00:21:17,255 --> 00:21:21,554
zero to v.size and just accessing it by an index,

00:21:21,554 --> 00:21:22,901
and on the right hand side is the version

00:21:22,901 --> 00:21:24,753
that's using the range for.

00:21:24,753 --> 00:21:26,576
Now, again, with the caveat that you have to

00:21:26,576 --> 00:21:28,289
measure everything and you can't just look

00:21:28,289 --> 00:21:31,499
at these things, we can at least draw one thing,

00:21:31,499 --> 00:21:32,887
which is that, although there's a bit of difference

00:21:32,887 --> 00:21:36,259
at the beginning, this region here, from line 7 through 11

00:21:36,259 --> 00:21:39,627
or 10 to 14, is identical on both sides.

00:21:39,627 --> 00:21:40,940
So even though we wrote the code

00:21:40,940 --> 00:21:43,216
in two completely different ways,

00:21:43,216 --> 00:21:44,765
the core loop, the bit that's actually

00:21:44,765 --> 00:21:46,338
running over everything and summing them up,

00:21:46,338 --> 00:21:48,060
is identical in both cases.

00:21:48,060 --> 00:21:50,777
And the difference in the top bit is

00:21:50,777 --> 00:21:52,369
of a couple of instructions.

00:21:52,369 --> 00:21:54,532
We might reasonably expect them

00:21:54,532 --> 00:21:57,694
to perform very very similarly.

00:21:57,694 --> 00:22:00,697
Oh, hang on a second, I was gonna do one other thing.

00:22:00,697 --> 00:22:01,761
And that is, for the purists among you

00:22:01,761 --> 00:22:05,359
that are saying why don't we use std::accumulate.

00:22:05,359 --> 00:22:09,526
Accumulate begin(v), end(v).

00:22:10,728 --> 00:22:13,558
Typing under pressure is never easy.

00:22:13,558 --> 00:22:14,619
Ta-da!

00:22:14,619 --> 00:22:17,161
Now, if you are eagle eyed, you'll spot that that's

00:22:17,161 --> 00:22:20,310
absolutely identical, give or take one reordered instruction

00:22:20,310 --> 00:22:22,637
from the handwritten for loop.

00:22:22,637 --> 00:22:24,480
So use your standard algorithms

00:22:24,480 --> 00:22:26,980
I think is the takeaway there.

00:22:29,220 --> 00:22:30,782
Let's just quickly take apart that code.

00:22:30,782 --> 00:22:33,088
So this is an example of how, if I were reading some code,

00:22:33,088 --> 00:22:35,497
I would take it apart and try to intuit

00:22:35,497 --> 00:22:38,338
what's actually going on and why are they different at all.

00:22:38,338 --> 00:22:39,605
So if you remember, we're taking

00:22:39,605 --> 00:22:42,239
a vector of integers by reference.

00:22:42,239 --> 00:22:44,290
Now, there's no such thing as a reference

00:22:44,290 --> 00:22:46,517
in terms of the hardware, it's all pointers

00:22:46,517 --> 00:22:48,158
as far as the processor's concerned,

00:22:48,158 --> 00:22:50,149
so effectively, what we've done is we passed

00:22:50,149 --> 00:22:54,506
a pointer to a vector of integers to this function.

00:22:54,506 --> 00:22:56,351
The first parameter, the first and only parameter,

00:22:56,351 --> 00:22:57,736
will be an rdi.

00:22:57,736 --> 00:22:59,279
And you can see these first two instructions

00:22:59,279 --> 00:23:02,279
are reading from rdi and rdi+8.

00:23:03,694 --> 00:23:05,471
Now, it would be easy for you to sort of fall

00:23:05,471 --> 00:23:07,329
into the trap of thinking that rdi is pointing

00:23:07,329 --> 00:23:09,431
at the list of integers itself, it isn't.

00:23:09,431 --> 00:23:11,778
It's pointing at the vector.

00:23:11,778 --> 00:23:14,422
And in at least GCC's implementation of the STL,

00:23:14,422 --> 00:23:16,222
this is what ultimately, if you boil through

00:23:16,222 --> 00:23:18,532
all the template stuff, you get to.

00:23:18,532 --> 00:23:19,724
And that is we got a structure

00:23:19,724 --> 00:23:21,864
which has three pointers in it.

00:23:21,864 --> 00:23:24,528
The first pointer points to the beginning of the array.

00:23:24,528 --> 00:23:27,294
The second pointer points to the one past the end

00:23:27,294 --> 00:23:30,192
of the array, and the third pointer points to the end of

00:23:30,192 --> 00:23:34,359
the allocated region of storage for that particular vector.

00:23:35,468 --> 00:23:37,108
So that means that we can have more space

00:23:37,108 --> 00:23:38,565
than we're actually using, and as you know,

00:23:38,565 --> 00:23:40,521
vectors will grow to fill the amount of space

00:23:40,521 --> 00:23:42,805
that they need, and they will shrink down,

00:23:42,805 --> 00:23:44,047
well, they won't shrink down unless you ask them to.

00:23:44,047 --> 00:23:46,434
Sorry, I'm getting carried away here, but

00:23:46,434 --> 00:23:48,070
the interesting thing here is that the size itself

00:23:48,070 --> 00:23:49,871
is not encoded inside that structure,

00:23:49,871 --> 00:23:51,877
we just have two pointers.

00:23:51,877 --> 00:23:53,853
This will become interesting.

00:23:53,853 --> 00:23:55,989
So here is the difference bit, the difference bit,

00:23:55,989 --> 00:23:58,365
here are the bits that's different.

00:23:58,365 --> 00:24:01,893
On the left hand side, we've got the traditional

00:24:01,893 --> 00:24:03,714
counting based approach, and on the right hand,

00:24:03,714 --> 00:24:05,493
we've got the range based approach.

00:24:05,493 --> 00:24:08,010
Those first three instructions on the traditional side,

00:24:08,010 --> 00:24:10,227
the sub, the mov and the shift right

00:24:10,227 --> 00:24:12,678
are effectively taking the end pointer

00:24:12,678 --> 00:24:14,391
and subtracting it from the begin.

00:24:14,391 --> 00:24:16,118
That tells us how many bytes are there

00:24:16,118 --> 00:24:18,631
between the beginning and the end of our vector.

00:24:18,631 --> 00:24:21,412
And then that shift right by two is dividing it down

00:24:21,412 --> 00:24:23,291
by four, you know, if you shift anything right,

00:24:23,291 --> 00:24:24,768
you're gonna be dividing by two,

00:24:24,768 --> 00:24:27,762
and if you shift right twice, you get a divide by four.

00:24:27,762 --> 00:24:30,859
So what we've effectively done there is

00:24:30,859 --> 00:24:32,865
that's the size call.

00:24:32,865 --> 00:24:35,199
So the size call's been made.

00:24:35,199 --> 00:24:37,302
And we now know how many elements there are

00:24:37,302 --> 00:24:41,728
in our vector that we're gonna be iterating over.

00:24:41,728 --> 00:24:43,242
Implicit in that shift right is

00:24:43,242 --> 00:24:45,082
a sort of comparison with zero.

00:24:45,082 --> 00:24:49,734
So if we got a zero result, the equal flag will be set

00:24:49,734 --> 00:24:52,064
and that je, jump if equal, will disappear

00:24:52,064 --> 00:24:54,566
after the .L4, which is the there was nothing to do,

00:24:54,566 --> 00:24:58,015
just return zero part of the program.

00:24:58,015 --> 00:25:00,232
So so far, we've said is size equal to zero,

00:25:00,232 --> 00:25:03,012
if so, we're done, great.

00:25:03,012 --> 00:25:05,553
So now we might reasonably expect it to use that

00:25:05,553 --> 00:25:07,598
while it counts up until it hits

00:25:07,598 --> 00:25:10,493
the end of the, like counts a loop iterator

00:25:10,493 --> 00:25:13,003
until it hits that size, but something interesting

00:25:13,003 --> 00:25:14,474
has happened here, the compiler has realized

00:25:14,474 --> 00:25:17,483
that we never used that index inside the loop.

00:25:17,483 --> 00:25:19,818
And then we're just reading an array one after another,

00:25:19,818 --> 00:25:21,669
and it's basically gone in and rewritten

00:25:21,669 --> 00:25:23,593
the whole thing for us in terms of generating

00:25:23,593 --> 00:25:25,989
a pointer to the end of the array and then walking

00:25:25,989 --> 00:25:28,124
a pointer forwards through the whole array.

00:25:28,124 --> 00:25:30,584
So it now needs to know where the end of the array is,

00:25:30,584 --> 00:25:33,242
which we all know is actually in or was in

00:25:33,242 --> 00:25:34,932
rcx at the beginning.

00:25:34,932 --> 00:25:36,737
Compiler has unfortunately not noticed that,

00:25:36,737 --> 00:25:39,507
and so it's had to add rdx back into rcx

00:25:39,507 --> 00:25:40,943
in order to reconstitute the end point

00:25:40,943 --> 00:25:44,968
that we had to start with, unfortunate.

00:25:44,968 --> 00:25:48,285
And then it sets the result to zero there.

00:25:48,285 --> 00:25:49,884
So a little bit of extra work's happened here,

00:25:49,884 --> 00:25:51,758
and I think, I mean, there are probably

00:25:51,758 --> 00:25:54,178
some compiler writers here, you could probably,

00:25:54,178 --> 00:25:55,089
I don't think I'm speaking out of turn

00:25:55,089 --> 00:25:58,124
to think that that could be optimized by the compiler,

00:25:58,124 --> 00:25:59,557
I don't know if there's anything, oh,

00:25:59,557 --> 00:26:01,548
there's a note there, (mumbles).

00:26:01,548 --> 00:26:05,715
(background noise drowns out audience member)

00:26:14,904 --> 00:26:15,737
Oh, okay.

00:26:15,737 --> 00:26:16,830
So I think the comment was that Clang

00:26:16,830 --> 00:26:19,298
was giving the same output, that it might be actually a bug.

00:26:19,298 --> 00:26:20,131
Is that right, we--

00:26:20,131 --> 00:26:24,298
(background noise drowns out audience member)

00:26:25,214 --> 00:26:26,047
I see.

00:26:26,047 --> 00:26:30,214
(background noise drowns out audience member)

00:26:31,117 --> 00:26:31,969
Okay.

00:26:31,969 --> 00:26:34,109
It's difficult to communicate.

00:26:34,109 --> 00:26:35,291
Yeah.

00:26:35,291 --> 00:26:38,725
The comment was that there was an issue with the way,

00:26:38,725 --> 00:26:40,079
or there may be an issue with the way Clang,

00:26:40,079 --> 00:26:41,223
if we could talk about it at the end,

00:26:41,223 --> 00:26:42,273
perhaps that would be clarified,

00:26:42,273 --> 00:26:44,659
'cause otherwise we're gonna be derailed forever here.

00:26:44,659 --> 00:26:46,381
But that's great, there are compiler people here,

00:26:46,381 --> 00:26:48,470
they can help me make this better.

00:26:48,470 --> 00:26:50,616
On the range side, of course, what's really happening

00:26:50,616 --> 00:26:53,402
is that range for is being rewritten to be

00:26:53,402 --> 00:26:55,320
get the begin, get the end, make an iterator

00:26:55,320 --> 00:26:57,618
and walk it from begin to end.

00:26:57,618 --> 00:27:00,011
And so that's exactly what the compiler's done.

00:27:00,011 --> 00:27:01,394
So there's no funny working out

00:27:01,394 --> 00:27:03,013
how many iterations we need to do

00:27:03,013 --> 00:27:04,208
and then effectively throwing away

00:27:04,208 --> 00:27:07,365
the number of iterations there.

00:27:07,365 --> 00:27:09,473
The loop, we already saw, was identical in both cases,

00:27:09,473 --> 00:27:11,771
so I don't think I need to go into too much detail.

00:27:11,771 --> 00:27:14,820
We're just reading each integer one at a time

00:27:14,820 --> 00:27:16,089
and adding them to the accumulator.

00:27:16,089 --> 00:27:18,753
And then, when the iterator hits the end,

00:27:18,753 --> 00:27:20,141
we stop looping around and we just hit

00:27:20,141 --> 00:27:22,578
that return instruction.

00:27:22,578 --> 00:27:26,745
I think we can probably conclude that, give or take,

00:27:28,548 --> 00:27:30,763
a couple of instructions right at the beginning,

00:27:30,763 --> 00:27:33,032
they're identical, which is great, really,

00:27:33,032 --> 00:27:34,498
because that means that we can say to everyone,

00:27:34,498 --> 00:27:38,178
go ahead, use the much better C++ idiom of range for

00:27:38,178 --> 00:27:39,689
rather than counting.

00:27:39,689 --> 00:27:41,106
That's excellent.

00:27:42,087 --> 00:27:43,549
Also, we learned that the optimizer settings

00:27:43,549 --> 00:27:45,779
make a huge difference.

00:27:45,779 --> 00:27:47,688
And in fairness, I haven't actually compiled

00:27:47,688 --> 00:27:49,573
the two versions with O3 and spent any time

00:27:49,573 --> 00:27:51,205
working out whether or not there's some other thing

00:27:51,205 --> 00:27:54,254
that changes if we try counting versus the range thing.

00:27:54,254 --> 00:27:57,054
I'm not sure that we would, but it would definitely

00:27:57,054 --> 00:27:58,284
be worth checking, and of course,

00:27:58,284 --> 00:28:00,843
you would benchmark it if it really mattered to you.

00:28:00,843 --> 00:28:02,561
And we saw that standard accumulate is identical,

00:28:02,561 --> 00:28:06,108
so we should really just be using standard accumulate.

00:28:06,108 --> 00:28:08,013
Okay, so that's an example of the kind of things

00:28:08,013 --> 00:28:10,472
you can do if you start sitting down and looking at code.

00:28:10,472 --> 00:28:12,725
And as I say, you start discovering these amazing things

00:28:12,725 --> 00:28:14,892
the compiler does for you.

00:28:18,079 --> 00:28:18,912
So the first thing I'm gonna talk

00:28:18,912 --> 00:28:21,354
to you about is multiplication.

00:28:21,354 --> 00:28:23,695
Again, as I said in the beginning,

00:28:23,695 --> 00:28:26,682
these are all slide examples so they're all necessarily

00:28:26,682 --> 00:28:29,697
very small and very simple, but they're pretty cool.

00:28:29,697 --> 00:28:32,640
So this is what a multiply x by y routine looks like,

00:28:32,640 --> 00:28:35,951
passing two things, x and y, edi will have

00:28:35,951 --> 00:28:38,556
the first parameter, esi will have the second parameter.

00:28:38,556 --> 00:28:40,776
And we need to get the multiplicated, multiplicated,

00:28:40,776 --> 00:28:44,408
listed to me, the multiplied version into eax.

00:28:44,408 --> 00:28:46,175
And this is what the compiler emits.

00:28:46,175 --> 00:28:47,283
That's cool.

00:28:47,283 --> 00:28:49,514
But can we do better than that?

00:28:49,514 --> 00:28:51,150
Multiplication, if you remember from grade school,

00:28:51,150 --> 00:28:54,144
looks something like this, this is a four bit multiplied

00:28:54,144 --> 00:28:55,574
done by hand.

00:28:55,574 --> 00:28:57,068
I'm sure there are much cleverer things

00:28:57,068 --> 00:28:58,623
going inside the processor, but ultimately,

00:28:58,623 --> 00:29:00,332
there's a lot of adds happening,

00:29:00,332 --> 00:29:02,064
and this is only a four bit multiply,

00:29:02,064 --> 00:29:05,030
so there's gonna be four adds in the middle.

00:29:05,030 --> 00:29:07,252
So on a Haswell, where you're gonna be running

00:29:07,252 --> 00:29:09,957
at least a 32 bit multiply most of the time.

00:29:09,957 --> 00:29:11,888
It's a miracle that they can get that to happen

00:29:11,888 --> 00:29:13,832
in four CPU cycles.

00:29:13,832 --> 00:29:17,064
Now, a CPU cycle is roughly a third of a nanosecond,

00:29:17,064 --> 00:29:18,575
so just get that around your head, right,

00:29:18,575 --> 00:29:20,167
we're still talking about something which doesn't take

00:29:20,167 --> 00:29:23,980
much more than a nanosecond, so it's crazy.

00:29:23,980 --> 00:29:26,313
But an add is one cycle.

00:29:26,313 --> 00:29:29,541
So maybe there's a faster way of doing this.

00:29:29,541 --> 00:29:31,313
Or maybe my clicker will work, there we are.

00:29:31,313 --> 00:29:32,987
What happens if we happen to know

00:29:32,987 --> 00:29:34,536
that we're multiplying by a constant?

00:29:34,536 --> 00:29:35,825
We know it happens all the time.

00:29:35,825 --> 00:29:37,171
You might be walking an array or getting

00:29:37,171 --> 00:29:38,362
the ith element of an array, and you need

00:29:38,362 --> 00:29:42,548
to be able to multiply by the size of the object.

00:29:42,548 --> 00:29:44,643
We might reasonably expect it to use that shift

00:29:44,643 --> 00:29:48,787
as a shifter where we can shift up by a power of two, sorry,

00:29:48,787 --> 00:29:51,120
shift up and therefore multiply by a power two,

00:29:51,120 --> 00:29:53,372
so we might expect it would shift it up by one.

00:29:53,372 --> 00:29:54,372
Let's check.

00:29:55,242 --> 00:29:56,325
Oh, no shift.

00:29:57,534 --> 00:30:00,576
It's that funny lea instruction.

00:30:00,576 --> 00:30:02,049
Like I said, it's a glorified add,

00:30:02,049 --> 00:30:03,073
you have to think of it as an add,

00:30:03,073 --> 00:30:05,082
but the cool thing about lea is that

00:30:05,082 --> 00:30:07,499
you can have a different destination from the source,

00:30:07,499 --> 00:30:10,710
whereas the shift on x86 is in place.

00:30:10,710 --> 00:30:12,265
So it avoided an instruction here

00:30:12,265 --> 00:30:14,080
just to move things around into the right place

00:30:14,080 --> 00:30:16,898
and instead it said okay, add rdi to rdi, great,

00:30:16,898 --> 00:30:21,177
and then put the result into eax, we're done, brilliant.

00:30:21,177 --> 00:30:22,852
What about some other numbers?

00:30:22,852 --> 00:30:27,019
Surely, it's gonna need a shift if we make it for.

00:30:28,999 --> 00:30:31,254
Well no, because we can use the lea again.

00:30:31,254 --> 00:30:32,898
All right, well, now we know that the lea instruction

00:30:32,898 --> 00:30:34,543
can do one, two, four or eight.

00:30:34,543 --> 00:30:37,070
So there'll be no surprises in store for us here,

00:30:37,070 --> 00:30:39,096
and there actually aren't.

00:30:39,096 --> 00:30:41,556
If we go to 16, we're gonna see it using those shifts,

00:30:41,556 --> 00:30:42,939
and there you can see the two instructions

00:30:42,939 --> 00:30:44,482
that it would otherwise had to have used

00:30:44,482 --> 00:30:46,405
if it was just using shifts alone.

00:30:46,405 --> 00:30:48,293
Now, again, for anyone who was at Chandler's talk,

00:30:48,293 --> 00:30:49,722
you can see how clever that processor is

00:30:49,722 --> 00:30:51,297
at moving things around and reordering them,

00:30:51,297 --> 00:30:53,321
it's very very clever but it's still worth it

00:30:53,321 --> 00:30:56,063
to not have two instructions for your pipeline.

00:30:56,063 --> 00:30:59,466
But what happens if we do something like that?

00:30:59,466 --> 00:31:01,420
Okay, it's given up on us.

00:31:01,420 --> 00:31:03,758
So there's obviously a limitation in the compiler,

00:31:03,758 --> 00:31:06,167
compiler writers are not as clever as they make out.

00:31:06,167 --> 00:31:07,064
I know.

00:31:07,064 --> 00:31:08,129
(audience laughter)

00:31:08,129 --> 00:31:09,645
I know that--

00:31:09,645 --> 00:31:11,905
(applause)

00:31:11,905 --> 00:31:15,112
Oh, no, wrong one, sorry, I need to do this.

00:31:15,112 --> 00:31:17,995
I know that I can build that multiply myself.

00:31:17,995 --> 00:31:22,162
I know that 65599 is 65536 plus 64 minus 1, right,

00:31:25,791 --> 00:31:27,632
so that kind of, I can build out of those operations,

00:31:27,632 --> 00:31:29,757
so I'm gonna do that and I'm gonna make

00:31:29,757 --> 00:31:32,676
better code than the compiler, I know best.

00:31:32,676 --> 00:31:34,240
Oh.

00:31:34,240 --> 00:31:36,209
(audience laughter)

00:31:36,209 --> 00:31:39,083
(applause)

00:31:39,083 --> 00:31:40,833
Well, that's awkward.

00:31:43,119 --> 00:31:46,407
So yeah, it turns out the compiler is smarter than me.

00:31:46,407 --> 00:31:47,960
No surprise there.

00:31:47,960 --> 00:31:50,583
So not only is it smart enough to know that the multiply

00:31:50,583 --> 00:31:52,792
is faster than all the shifts and adds and subtracts

00:31:52,792 --> 00:31:54,230
that it would otherwise have to do.

00:31:54,230 --> 00:31:56,391
It has worked out that my sequence of shifts and adds

00:31:56,391 --> 00:31:58,699
is actually equivalent to a multiply and it said well,

00:31:58,699 --> 00:32:00,716
I'm gonna save you from yourself here.

00:32:00,716 --> 00:32:02,355
(audience laughter)

00:32:02,355 --> 00:32:05,622
That, of course, is only true on more modern processors.

00:32:05,622 --> 00:32:10,316
If we go back to the golden age, let's go i486.

00:32:10,316 --> 00:32:11,483
Yeah, you see.

00:32:12,629 --> 00:32:14,993
I am still channeling Michael Abrash's

00:32:14,993 --> 00:32:17,210
big book of awesome optimizations

00:32:17,210 --> 00:32:20,517
and I can still write better code than the compiler.

00:32:20,517 --> 00:32:22,651
Well, no, still.

00:32:22,651 --> 00:32:24,288
If I turn this into the multiply

00:32:24,288 --> 00:32:27,389
that it really should've been all along,

00:32:27,389 --> 00:32:28,618
the compiler is actually even smarter

00:32:28,618 --> 00:32:29,635
than that sequence of instructions,

00:32:29,635 --> 00:32:30,705
I have no idea what it's doing though,

00:32:30,705 --> 00:32:32,490
I haven't bothered to work it out.

00:32:32,490 --> 00:32:35,740
So the thing that, the answer really is

00:32:35,740 --> 00:32:38,517
let the compiler do the things for you,

00:32:38,517 --> 00:32:39,821
it's gonna be smarter than you.

00:32:39,821 --> 00:32:41,459
And I guess as a sort of secondary thing there

00:32:41,459 --> 00:32:43,301
is like telling it what architecture you're targeting

00:32:43,301 --> 00:32:45,350
is probably important as well.

00:32:45,350 --> 00:32:46,861
I mean, I don't think multiply has been that slow

00:32:46,861 --> 00:32:48,123
for a long time, so I think you're safe

00:32:48,123 --> 00:32:50,538
on this particular one, but always take a look.

00:32:50,538 --> 00:32:51,684
All right.

00:32:51,684 --> 00:32:52,988
That's multiplication, and multiplication

00:32:52,988 --> 00:32:55,782
with a constant as well, so it's a bit of a special case.

00:32:55,782 --> 00:32:57,339
What about division?

00:32:57,339 --> 00:32:59,378
If you hated doing long multiplication as a kid,

00:32:59,378 --> 00:33:01,925
you probably, like me, loathed doing long division.

00:33:01,925 --> 00:33:05,446
And processors don't like it any more than you.

00:33:05,446 --> 00:33:07,816
So this is the code that comes out if you do

00:33:07,816 --> 00:33:09,447
a divide or a modulus.

00:33:09,447 --> 00:33:11,764
It turns out that the circuitry that

00:33:11,764 --> 00:33:13,158
they use to make a divide also gives you

00:33:13,158 --> 00:33:15,181
the remainder at the same time, so the only difference

00:33:15,181 --> 00:33:16,777
between these two routines is whether or not

00:33:16,777 --> 00:33:19,906
it picks to return eax or edx.

00:33:19,906 --> 00:33:22,167
So it's one of those funny cases where the instruction,

00:33:22,167 --> 00:33:23,849
the idea of instruction effectively outputs

00:33:23,849 --> 00:33:26,599
the two registers that aren't even named

00:33:26,599 --> 00:33:28,373
in the instruction, it's crazy.

00:33:28,373 --> 00:33:29,206
Anyway.

00:33:31,095 --> 00:33:35,471
A 32 bit divide on a Haswell takes 22 to 29 cycles.

00:33:35,471 --> 00:33:37,238
That's eternity.

00:33:37,238 --> 00:33:40,191
I mean, it's still only 10 nanoseconds, okay.

00:33:40,191 --> 00:33:43,107
But it's eternity compared to all those movs.

00:33:43,107 --> 00:33:44,833
The other thing that I haven't put up on the slide here

00:33:44,833 --> 00:33:48,642
is that there is only one divider for each core

00:33:48,642 --> 00:33:50,638
on your Intel chip.

00:33:50,638 --> 00:33:52,419
And it's not even fully pipelined.

00:33:52,419 --> 00:33:55,497
So those multiplies, for a start, there might be

00:33:55,497 --> 00:33:58,103
multiple multiplies on the chip, which means you can have

00:33:58,103 --> 00:34:00,169
multiple concurrent multiplies going on.

00:34:00,169 --> 00:34:01,891
They're also pipelined, which means

00:34:01,891 --> 00:34:03,086
that you can start a new multiplier

00:34:03,086 --> 00:34:06,245
every cycle and get the result four cycles later,

00:34:06,245 --> 00:34:09,461
but least if you have a chain of them going on dependent,

00:34:09,461 --> 00:34:13,930
you can kind of get one multiplier result every cycle.

00:34:13,930 --> 00:34:15,682
The divider, no chance.

00:34:15,682 --> 00:34:17,336
The divider, you're just, it's wedged,

00:34:17,336 --> 00:34:18,559
it's gonna be, you're gonna be waiting

00:34:18,559 --> 00:34:20,336
for 20 to 30 cycles before you get the result

00:34:20,336 --> 00:34:23,329
and no one else can use it.

00:34:23,329 --> 00:34:25,373
Can we do better?

00:34:25,373 --> 00:34:27,414
Click, there we go.

00:34:27,414 --> 00:34:30,163
Well obviously, trivially, we divide by a constant,

00:34:30,163 --> 00:34:31,927
and that constant is a power of two,

00:34:31,927 --> 00:34:34,613
we're back into shift land, right.

00:34:34,613 --> 00:34:37,473
So I have moved over to using unsigned numbers here

00:34:37,473 --> 00:34:39,685
just to avoid extra code, but you can do this trick

00:34:39,685 --> 00:34:41,327
with signed numbers too.

00:34:41,327 --> 00:34:44,701
So now there no magic lea instruction type trick

00:34:44,701 --> 00:34:46,874
to save us here, it's just gonna do the shift,

00:34:46,874 --> 00:34:48,018
which is cool.

00:34:48,018 --> 00:34:49,002
And you can't even see the code

00:34:49,002 --> 00:34:50,027
because I scaled everything up

00:34:50,027 --> 00:34:52,454
to try and let you see it, okay.

00:34:52,454 --> 00:34:54,232
So there it is, x over 2, we're just shifting right,

00:34:54,232 --> 00:34:57,664
and you know, no surprise, or we'll do x divided by 16,

00:34:57,664 --> 00:35:00,020
it's gonna shift it times by 4 and so on and so forth.

00:35:00,020 --> 00:35:02,407
But how often, I mean, in fairness,

00:35:02,407 --> 00:35:04,352
how often do you do integer division,

00:35:04,352 --> 00:35:08,611
but how often do you do inter-division by a power of two?

00:35:08,611 --> 00:35:10,554
Not that often, I'm guessing.

00:35:10,554 --> 00:35:12,500
So let's try three, what happens here?

00:35:12,500 --> 00:35:13,858
Ah.

00:35:13,858 --> 00:35:15,133
We've lost a divide, there's still no divide

00:35:15,133 --> 00:35:16,986
on the right hand side.

00:35:16,986 --> 00:35:18,919
We've got some movs and things with

00:35:18,919 --> 00:35:22,651
a funny scary looking constant and a multiply.

00:35:22,651 --> 00:35:23,833
What's going on here?

00:35:23,833 --> 00:35:26,500
Well, compiler cleverness again.

00:35:27,424 --> 00:35:30,390
What's happening is that aaaaaaab value

00:35:30,390 --> 00:35:34,557
is actually two thirds shifted up into the sort of,

00:35:35,878 --> 00:35:37,128
by 2 to the 32.

00:35:38,492 --> 00:35:41,369
So like effectively a fixed point two thirds

00:35:41,369 --> 00:35:45,892
where the fixed point dot is between 32 and a lower 32,

00:35:45,892 --> 00:35:47,360
so it's 32.32.

00:35:47,360 --> 00:35:50,386
So if we multiply by it, we get the answer out,

00:35:50,386 --> 00:35:52,219
shifted up by 32 bits.

00:35:54,080 --> 00:35:56,946
And if we just discard the bottom bits here,

00:35:56,946 --> 00:35:58,712
which is what that mov eax is doing,

00:35:58,712 --> 00:36:00,431
then what we've got is the answer

00:36:00,431 --> 00:36:02,713
with a fixed point multiplied by two thirds.

00:36:02,713 --> 00:36:04,448
And then we halve it.

00:36:04,448 --> 00:36:06,879
So why are we multiplying by two thirds?

00:36:06,879 --> 00:36:08,889
Well, it turns out that, in order to cover

00:36:08,889 --> 00:36:10,664
the entire range of an integer,

00:36:10,664 --> 00:36:13,552
an unsigned integer at least, there's just one fewer bit

00:36:13,552 --> 00:36:15,482
to do it by a third directly, you have to do it

00:36:15,482 --> 00:36:17,042
by two thirds and then shift it down.

00:36:17,042 --> 00:36:19,030
And there are some very well published algorithms

00:36:19,030 --> 00:36:20,415
for determining the exact sequence

00:36:20,415 --> 00:36:22,380
of operations you need to do in order to cover

00:36:22,380 --> 00:36:25,126
a particular range of value in a particular way.

00:36:25,126 --> 00:36:28,752
And I saw some copies of, was it Bit Hacks or whatever,

00:36:28,752 --> 00:36:30,919
there's a book, I saw some outside in the library earlier,

00:36:30,919 --> 00:36:32,336
oh, that's great.

00:36:33,698 --> 00:36:35,463
Sorry, cancel.

00:36:35,463 --> 00:36:36,482
I've been clicking report problem,

00:36:36,482 --> 00:36:39,247
but nothing seems to happen.

00:36:39,247 --> 00:36:41,497
So anyway, that's division.

00:36:42,722 --> 00:36:44,281
So if we've done division, we ought to look

00:36:44,281 --> 00:36:45,896
at what modulus does.

00:36:45,896 --> 00:36:47,812
And modulus is effectively just a divide

00:36:47,812 --> 00:36:50,735
so that the bit is grayed out at the top there.

00:36:50,735 --> 00:36:53,401
It's a bit that's, sorry, we do the divide,

00:36:53,401 --> 00:36:55,581
and then we just multiply it back up again by three,

00:36:55,581 --> 00:36:57,306
and you'll see it's using the lea instruction here

00:36:57,306 --> 00:37:00,510
to multiply it by three by adding it to itself times two,

00:37:00,510 --> 00:37:01,896
that's quite clever.

00:37:01,896 --> 00:37:03,449
And then it subtracts it from the original number

00:37:03,449 --> 00:37:05,095
and you get the remainder.

00:37:05,095 --> 00:37:09,139
So why am I banging about moduli, moduluses, modulants?

00:37:09,139 --> 00:37:10,053
Well, they're used in hash maps,

00:37:10,053 --> 00:37:13,063
which is everyone's favorite container, right?

00:37:13,063 --> 00:37:14,900
So if you've got a hash value,

00:37:14,900 --> 00:37:16,335
you've probably got a 64 bit number

00:37:16,335 --> 00:37:17,881
that's come out of you like doing

00:37:17,881 --> 00:37:19,740
whatever crazy operation on your string.

00:37:19,740 --> 00:37:23,687
And now you've got your 1,021 buckets in your hash tree

00:37:23,687 --> 00:37:26,008
that you need to, sorry, your hash list,

00:37:26,008 --> 00:37:29,013
that you need to start indexing from to look for the result.

00:37:29,013 --> 00:37:30,946
And the only way to kind of take your 64 bit value

00:37:30,946 --> 00:37:33,818
and smoosh it into the number of buckets you have

00:37:33,818 --> 00:37:35,450
is to modulus by the number of buckets,

00:37:35,450 --> 00:37:37,530
which is great but we've just seen,

00:37:37,530 --> 00:37:39,044
it's about the slowest thing you can do.

00:37:39,044 --> 00:37:42,086
Now, obviously, if you know ahead of time

00:37:42,086 --> 00:37:43,595
that your container is always going to have

00:37:43,595 --> 00:37:46,889
exactly 1,021 buckets, then you can write the code

00:37:46,889 --> 00:37:50,413
that does mod 1,021, compiler jumps in and goes,

00:37:50,413 --> 00:37:51,965
ah, modulus by a constant, I'll generate

00:37:51,965 --> 00:37:53,608
that cool code for you.

00:37:53,608 --> 00:37:55,371
And you're done.

00:37:55,371 --> 00:37:57,234
But of course, most of the time in general purpose code,

00:37:57,234 --> 00:38:01,861
we don't know how big our sets and maps are going to be,

00:38:01,861 --> 00:38:03,210
unordered ones anyway.

00:38:03,210 --> 00:38:04,962
And so there's going to be a dynamic number

00:38:04,962 --> 00:38:06,824
of how many buckets I currently have, and that's

00:38:06,824 --> 00:38:08,591
just gonna mean there's gonna be a divide in there.

00:38:08,591 --> 00:38:10,654
And that's unfortunate because hash maps

00:38:10,654 --> 00:38:12,210
are meant to be the fast thing.

00:38:12,210 --> 00:38:13,736
Again, we're only talking about, you know,

00:38:13,736 --> 00:38:17,315
10 nanoseconds, but these things do make a difference.

00:38:17,315 --> 00:38:19,295
In fact, so much of a difference

00:38:19,295 --> 00:38:22,119
that libc++, after a certain point,

00:38:22,119 --> 00:38:24,299
gives up using prime numbers, which is like

00:38:24,299 --> 00:38:27,022
the good way of doing the number of buckets that you've got,

00:38:27,022 --> 00:38:29,972
and it starts using powers of two, even though that's

00:38:29,972 --> 00:38:32,614
not actually like perfect, but for a sufficiently large

00:38:32,614 --> 00:38:34,560
number of buckets, it's probably okay.

00:38:34,560 --> 00:38:36,913
And at that point then, it just uses an and trick

00:38:36,913 --> 00:38:40,156
to pick the bottom few bits rather than going into a divide.

00:38:40,156 --> 00:38:42,041
So obviously, people are thinking about this,

00:38:42,041 --> 00:38:43,225
some smart people, I'm looking,

00:38:43,225 --> 00:38:44,701
some people are looking at me and nodding at the moment,

00:38:44,701 --> 00:38:45,980
so I'm assuming it's them, some people

00:38:45,980 --> 00:38:47,750
are thinking about this kind of stuff.

00:38:47,750 --> 00:38:51,790
And in the case of say boost multi_index,

00:38:51,790 --> 00:38:53,469
there is an even cleverer thing where

00:38:53,469 --> 00:38:56,552
they have like a certain set of allowable sizes

00:38:56,552 --> 00:38:58,605
of the buckets so they just know that like this,

00:38:58,605 --> 00:39:01,296
we have 20 different possible sizes of the index,

00:39:01,296 --> 00:39:02,854
each of which is a prime number.

00:39:02,854 --> 00:39:05,374
And then instead of just modulusing by the actual size,

00:39:05,374 --> 00:39:07,806
they do a switch statement on how big is it at the moment

00:39:07,806 --> 00:39:11,556
and they have case 1021 return hash mod 1021.

00:39:13,088 --> 00:39:16,250
Or the equivalent, I think it's done by an ordinal value.

00:39:16,250 --> 00:39:18,805
Which means that yes, you've got a big switch statement,

00:39:18,805 --> 00:39:20,360
and yes, the compiler's gonna have to dispatch

00:39:20,360 --> 00:39:23,159
and jump to the right part, but when you get there,

00:39:23,159 --> 00:39:26,279
you're just gonna do a couple of adds and a multiply.

00:39:26,279 --> 00:39:28,806
It's obviously worth thinking about.

00:39:28,806 --> 00:39:30,976
People cleverer than me are thinking about this anyway.

00:39:30,976 --> 00:39:32,804
And that actually is relying on the fact that the compiler

00:39:32,804 --> 00:39:34,773
is going to do this optimization for them, right,

00:39:34,773 --> 00:39:36,329
you wouldn't write it that way

00:39:36,329 --> 00:39:40,146
if you didn't know that that's what was gonna happen.

00:39:40,146 --> 00:39:43,207
Who went to Phil Nash's talk earlier?

00:39:43,207 --> 00:39:44,758
There's a few.

00:39:44,758 --> 00:39:49,659
Cool, I thought he was gonna still my thunder on this part.

00:39:49,659 --> 00:39:52,364
There are a number of data structures

00:39:52,364 --> 00:39:54,172
for which it is convenient to be able to count

00:39:54,172 --> 00:39:56,113
the number of set bits in an integer.

00:39:56,113 --> 00:39:59,395
Now, who has ever actually had to do that?

00:39:59,395 --> 00:40:01,370
Gosh, actually a lot more than I thought,

00:40:01,370 --> 00:40:03,469
I mean, Phil's hand's up, of course.

00:40:03,469 --> 00:40:04,726
That's surprising, I thought I was gonna give

00:40:04,726 --> 00:40:06,504
this sort of example and everyone would look blankly at me,

00:40:06,504 --> 00:40:07,992
like, why would we do that?

00:40:07,992 --> 00:40:08,843
But anyway.

00:40:08,843 --> 00:40:12,926
So this is a way to count the number of set bits.

00:40:14,658 --> 00:40:17,357
We're gonna pass in a value a and we'll say,

00:40:17,357 --> 00:40:20,592
while there are still bits in a, increment the count.

00:40:20,592 --> 00:40:23,113
And then at a &= (a-1), it's like one of

00:40:23,113 --> 00:40:25,271
the oldest bit twiddling tricks in the world

00:40:25,271 --> 00:40:28,436
for clearing the bottom set bit.

00:40:28,436 --> 00:40:30,287
Go around again, once we've got no bits left,

00:40:30,287 --> 00:40:32,102
we're done, we return the count.

00:40:32,102 --> 00:40:36,308
Let's see what our compiler does with this.

00:40:36,308 --> 00:40:37,558
So this is GCC.

00:40:38,779 --> 00:40:41,529
GCC has done something quite clever here.

00:40:41,529 --> 00:40:43,520
It has got a loop.

00:40:43,520 --> 00:40:45,702
You can sort of see the yellow bit is the loop bit there.

00:40:45,702 --> 00:40:49,150
And then the red line there, the a &= (a-1),

00:40:49,150 --> 00:40:52,347
it's replaced with a blsr instruction.

00:40:52,347 --> 00:40:54,203
I'd never seen the blsr instruction before

00:40:54,203 --> 00:40:55,921
until I actually prepared for this talk,

00:40:55,921 --> 00:40:59,193
and it turns out it's custom made for doing this operation.

00:40:59,193 --> 00:41:03,295
It clears the bottom set bit and lets you

00:41:03,295 --> 00:41:04,562
kind of put it into another register,

00:41:04,562 --> 00:41:06,493
so there is just, you know, clearing the bottom set bit.

00:41:06,493 --> 00:41:07,922
That's pretty cool.

00:41:07,922 --> 00:41:10,170
So it's picked an instruction which does

00:41:10,170 --> 00:41:13,183
exactly what I want, that's super clever.

00:41:13,183 --> 00:41:15,821
Can we do better than that though?

00:41:15,821 --> 00:41:18,100
I imagine there's some people stroking their chin

00:41:18,100 --> 00:41:19,984
at the moment.

00:41:19,984 --> 00:41:22,082
Oh yeah, we can do much better.

00:41:22,082 --> 00:41:25,576
So turns out there is an x86 instruction

00:41:25,576 --> 00:41:29,537
whose only reason to be is to count the number of set bits,

00:41:29,537 --> 00:41:30,742
it's so common that people wanted it

00:41:30,742 --> 00:41:33,155
that Intel put it into the instruction set.

00:41:33,155 --> 00:41:36,353
Now, just have a think about what Clang must've done here.

00:41:36,353 --> 00:41:38,162
Like, there's no bearing on the right hand side,

00:41:38,162 --> 00:41:39,674
there's no hint there that says I am counting

00:41:39,674 --> 00:41:41,234
the number of set bits.

00:41:41,234 --> 00:41:43,456
There are some builtin pop count things

00:41:43,456 --> 00:41:45,618
that you can do which tell the compiler

00:41:45,618 --> 00:41:48,820
I wish to do this, and therefore, the intrinsic

00:41:48,820 --> 00:41:52,346
will let you either emit the code that does this

00:41:52,346 --> 00:41:53,742
or the instruction if it's supported

00:41:53,742 --> 00:41:55,192
on the architecture I've picked.

00:41:55,192 --> 00:41:58,259
But I was blown away when this happened, this was amazing.

00:41:58,259 --> 00:42:00,368
So all the bits of code that I have

00:42:00,368 --> 00:42:01,954
that actually used the pop count instruction

00:42:01,954 --> 00:42:04,237
could be replaced with the much much more readable,

00:42:04,237 --> 00:42:06,704
human, well, I guess depends on (audio cuts out)

00:42:06,704 --> 00:42:07,921
bit manipulation and stuff, but you know,

00:42:07,921 --> 00:42:11,303
more readable to me, sensible, straight line code.

00:42:11,303 --> 00:42:13,803
That's an awesome achievement.

00:42:16,286 --> 00:42:17,842
The last one I'm gonna talk about is, again,

00:42:17,842 --> 00:42:19,699
a bit of a toy example.

00:42:19,699 --> 00:42:21,630
So standard caveats apply.

00:42:21,630 --> 00:42:24,169
And that is this summation, and I've written a routine here

00:42:24,169 --> 00:42:26,017
and I've used constexpr because I've realized

00:42:26,017 --> 00:42:29,662
that this is all C so far and that makes it C++, right?

00:42:29,662 --> 00:42:32,790
(audience laughter)

00:42:32,790 --> 00:42:34,345
So we're gonna sum up to the value x,

00:42:34,345 --> 00:42:35,666
and so we're just gonna do the obvious thing

00:42:35,666 --> 00:42:37,506
of starting at zero, counting up to it

00:42:37,506 --> 00:42:38,978
and adding it to our sum, brilliant.

00:42:38,978 --> 00:42:40,624
And then we're gonna like write a little main routine,

00:42:40,624 --> 00:42:42,381
it's gonna sum up to 20.

00:42:42,381 --> 00:42:44,233
And so we're gonna have a look at what the compiler does,

00:42:44,233 --> 00:42:46,139
how does it, oh, oh right, okay.

00:42:46,139 --> 00:42:47,810
Well, it's constexpr, right.

00:42:47,810 --> 00:42:50,515
Constexpr means it can only possibly happen

00:42:50,515 --> 00:42:55,062
in the compiler, right, well, I'm not using it

00:42:55,062 --> 00:42:56,645
in the constexpr context, it turns out,

00:42:56,645 --> 00:42:59,508
but let's just replace it with static instead

00:42:59,508 --> 00:43:02,535
or let's replace it with an error, why don't we do that?

00:43:02,535 --> 00:43:03,929
It's still the same, right.

00:43:03,929 --> 00:43:05,746
So the compiler can see it, the compiler knows the game

00:43:05,746 --> 00:43:07,509
we're up to and it says, I'm gonna spend some time

00:43:07,509 --> 00:43:09,477
just working out if this boils down to a number.

00:43:09,477 --> 00:43:12,834
Now, this is a stupidly trivial example of this.

00:43:12,834 --> 00:43:15,202
In general, you might find this happens

00:43:15,202 --> 00:43:18,460
in code snippets that you're pasting into

00:43:18,460 --> 00:43:20,145
Compiler Explorer, and the trick for this

00:43:20,145 --> 00:43:21,543
is to make sure it depends on something

00:43:21,543 --> 00:43:22,894
the compiler doesn't know.

00:43:22,894 --> 00:43:24,207
So in this case, the compiler doesn't know

00:43:24,207 --> 00:43:25,935
how many arguments they're passing into the function,

00:43:25,935 --> 00:43:27,209
so there we are.

00:43:27,209 --> 00:43:29,535
Now we can actually see the loop in its glory.

00:43:29,535 --> 00:43:31,458
And again, GCC's done a cool thing.

00:43:31,458 --> 00:43:34,166
It's unrolled, no it hasn't, I told a lie, sorry,

00:43:34,166 --> 00:43:35,476
that's the next bit.

00:43:35,476 --> 00:43:37,871
Okay, so it's a pretty straightforward thing here.

00:43:37,871 --> 00:43:39,022
I'm not gonna bore you by going through it,

00:43:39,022 --> 00:43:40,368
but you can see the shape of it,

00:43:40,368 --> 00:43:42,386
and you know, if we wanna really go to town,

00:43:42,386 --> 00:43:44,247
we can turn on the O3 again, you can see,

00:43:44,247 --> 00:43:47,091
look at how cool, again, I love all this stuff.

00:43:47,091 --> 00:43:49,110
I mean, I'm sure, I don't know

00:43:49,110 --> 00:43:50,747
how many command line arguments I need to pass

00:43:50,747 --> 00:43:53,168
before that's more efficient than

00:43:53,168 --> 00:43:56,382
the previous version, I don't know.

00:43:56,382 --> 00:44:00,687
But let's have a look at what Clang does again.

00:44:00,687 --> 00:44:03,393
Oh, that's interesting, there's no loop.

00:44:03,393 --> 00:44:05,192
There's a test in that blue region,

00:44:05,192 --> 00:44:06,544
and that test is just saying if it's less than

00:44:06,544 --> 00:44:08,855
or equal to zero, then the answer's zero.

00:44:08,855 --> 00:44:11,285
And then that yellow block, which apparently corresponds

00:44:11,285 --> 00:44:13,496
to sum += i, I don't know how the compiler

00:44:13,496 --> 00:44:16,922
came to that conclusion, but it's just a move,

00:44:16,922 --> 00:44:19,062
a funny lea and a multiply.

00:44:19,062 --> 00:44:21,374
What's going on there?

00:44:21,374 --> 00:44:23,458
Well, as most of you probably know,

00:44:23,458 --> 00:44:26,274
there is a closed form solution to summation.

00:44:26,274 --> 00:44:28,979
Clang has worked out, again, what I'm doing,

00:44:28,979 --> 00:44:31,507
and it's replaced a code with a closed form summation,

00:44:31,507 --> 00:44:33,597
yeah, that's pretty awesome, right.

00:44:33,600 --> 00:44:37,380
(applause)

00:44:38,840 --> 00:44:40,762
Even more interestingly, it hasn't actually used

00:44:40,762 --> 00:44:44,386
the thing that I've always used, the x(x + 1) over 2.

00:44:44,386 --> 00:44:48,066
It has, in fact, replaced it with x + (x - 1) over 2.

00:44:48,066 --> 00:44:49,252
They're equivalent.

00:44:49,252 --> 00:44:50,398
The reason being is that what happens

00:44:50,398 --> 00:44:52,705
if we passed an INT_MAX, right?

00:44:52,705 --> 00:44:54,603
It would've worked, the loop version would've worked

00:44:54,603 --> 00:44:55,911
for INT_MAX, but it wouldn't have worked

00:44:55,911 --> 00:44:58,283
if we had to do x(x + 1), we would've overflown,

00:44:58,283 --> 00:44:59,843
it would've all gone horribly wrong.

00:44:59,843 --> 00:45:01,872
I mean, how you'd get INT_MAX command line arguments

00:45:01,872 --> 00:45:05,137
in to a prime function is another problem, but you know,

00:45:05,137 --> 00:45:07,142
essentially, they've dealt with the overflow case as well.

00:45:07,142 --> 00:45:09,481
And it turns out you can tinker with that code quite a bit

00:45:09,481 --> 00:45:11,471
and it will like, move things around and ultimately

00:45:11,471 --> 00:45:13,938
just give you a close form solution every time.

00:45:13,938 --> 00:45:15,540
Just think about what that's doing, it's taken

00:45:15,540 --> 00:45:19,107
an order n piece of code I wrote and turned it into

00:45:19,107 --> 00:45:21,792
a linear, sorry, a constant time operation,

00:45:21,792 --> 00:45:24,129
there's another hand going up here, hi.

00:45:24,129 --> 00:45:28,068
(background noise drowns out audience member)

00:45:28,068 --> 00:45:31,386
Right, so the observation was that

00:45:31,386 --> 00:45:33,992
overflowing an integer is an undefined operation,

00:45:33,992 --> 00:45:35,860
and so why should it compile?

00:45:35,860 --> 00:45:37,624
It's because the compiler isn't allowed

00:45:37,624 --> 00:45:39,470
to start doing undefined behavior on my behalf,

00:45:39,470 --> 00:45:41,720
my x wasn't overflowing.

00:45:44,167 --> 00:45:46,432
Yeah, so you can't introduce, you can't add one to x ever,

00:45:46,432 --> 00:45:47,619
because for all it knows, the value

00:45:47,619 --> 00:45:50,816
was actually intmax beforehand and nowhere in my code

00:45:50,816 --> 00:45:52,715
did it overflow the integer, so it can't introduce

00:45:52,715 --> 00:45:54,066
undefined behavior.

00:45:54,066 --> 00:45:56,607
We can talk about it afterwards, anyway.

00:45:56,607 --> 00:45:59,389
Okay, these are dumb examples, they're all C examples.

00:45:59,389 --> 00:46:02,029
The compiler does so much more than this.

00:46:02,029 --> 00:46:03,868
I tried to get a slide together that explained

00:46:03,868 --> 00:46:05,715
some of my favorite things.

00:46:05,715 --> 00:46:09,173
I'm an old school sort of 00, unfashionable kind of a guy.

00:46:09,173 --> 00:46:11,787
So I still use the keyword virtual, I'm a bad person,

00:46:11,787 --> 00:46:13,664
I know, but compilers are getting much better

00:46:13,664 --> 00:46:16,136
at seeing through that too.

00:46:16,136 --> 00:46:17,772
They can do static devirtualization

00:46:17,772 --> 00:46:19,051
in all the cases where they can prove

00:46:19,051 --> 00:46:20,901
that a type is of a particular type

00:46:20,901 --> 00:46:23,476
and they can get rid of the virtual function call overhead.

00:46:23,476 --> 00:46:25,753
And now they're getting cleverer and cleverer,

00:46:25,753 --> 00:46:27,846
like saying I've looked at your entire program

00:46:27,846 --> 00:46:29,526
because of LTO and I've said seeing that

00:46:29,526 --> 00:46:31,713
there is exactly one implementation of this interface,

00:46:31,713 --> 00:46:34,304
and so I'm going to assume that every call

00:46:34,304 --> 00:46:38,050
to that interface is to that particular implementation.

00:46:38,050 --> 00:46:40,219
It still has to check, so it does a quick check

00:46:40,219 --> 00:46:42,639
on the vtable pointer or the actual address

00:46:42,639 --> 00:46:44,901
of the function it's gonna call to,

00:46:44,901 --> 00:46:46,373
in case you've dlopened something

00:46:46,373 --> 00:46:47,684
and loaded another implementation.

00:46:47,684 --> 00:46:49,646
But ultimately, it's effectively inlining in the code

00:46:49,646 --> 00:46:51,243
and put a big check at the front.

00:46:51,243 --> 00:46:54,429
And that's pretty cool, but again, didn't fit it there.

00:46:54,429 --> 00:46:56,555
And of course, the compilers doing range analysis

00:46:56,555 --> 00:47:00,059
and it's doing constant propagation and it's doing things

00:47:00,059 --> 00:47:01,955
I don't understand, I'm not a compiler writer,

00:47:01,955 --> 00:47:04,329
I'm just a guy at the other end of the pub line

00:47:04,329 --> 00:47:08,602
looking up in awe and wonder going wow, that's so clever.

00:47:08,602 --> 00:47:11,538
And I think back to that 20-something me,

00:47:11,538 --> 00:47:13,762
who always thought that the C compiler

00:47:13,762 --> 00:47:16,184
was basically a glorified macro assembler,

00:47:16,184 --> 00:47:19,914
and now I just realise how wrong I was.

00:47:19,914 --> 00:47:22,044
The compiler has done an awful lot for you,

00:47:22,044 --> 00:47:23,927
you should really be thankful for the hard, hard work

00:47:23,927 --> 00:47:28,526
the compiler writers put into making the code efficient

00:47:28,526 --> 00:47:31,351
and most often correct too.

00:47:31,351 --> 00:47:35,184
All right, so that's my big sort of love story

00:47:36,264 --> 00:47:38,350
for compiler writers, and now I'm gonna tell you

00:47:38,350 --> 00:47:40,740
a little bit about how G-Compiler Explorer,

00:47:40,740 --> 00:47:42,751
I nearly said GCC Explorer again, gosh.

00:47:42,751 --> 00:47:45,371
Compiler Explorer works.

00:47:45,371 --> 00:47:47,039
This is the second talk of this conference

00:47:47,039 --> 00:47:51,897
where I'm gonna talk about JavaScript, I feel so bad.

00:47:51,897 --> 00:47:54,492
So yeah, it's written in Node.js,

00:47:54,492 --> 00:47:57,711
which is a common JavaScript framework.

00:47:57,711 --> 00:48:01,850
And I know we sometimes give C++ a bit of a bad rap

00:48:01,850 --> 00:48:06,324
for having funny defaults and weird odd edge cases, but

00:48:06,324 --> 00:48:08,433
if you just take a look at JavaScript, really.

00:48:08,433 --> 00:48:10,202
(audience laughter)

00:48:10,202 --> 00:48:12,944
I mean, honestly, you can just Google for it

00:48:12,944 --> 00:48:15,172
and you'll find three cases at least

00:48:15,172 --> 00:48:17,183
that will make you just, I don't know,

00:48:17,183 --> 00:48:19,762
give up on the whole thing, but it's ubiquitous,

00:48:19,762 --> 00:48:22,593
it's easy to stop then get up and running quickly,

00:48:22,593 --> 00:48:24,367
and once you start a project and

00:48:24,367 --> 00:48:26,347
it becomes really successful, it's kind of hard for you

00:48:26,347 --> 00:48:27,676
to like go oh, I should really rewrite this

00:48:27,676 --> 00:48:28,863
in something else.

00:48:28,863 --> 00:48:30,458
And the irony is, the only other sort

00:48:30,458 --> 00:48:32,989
of big open source libraries I have, big is relative,

00:48:32,989 --> 00:48:35,239
is a web server written in C++, so you'd think

00:48:35,239 --> 00:48:37,953
I would've used that, but never mind.

00:48:37,953 --> 00:48:40,013
So it runs on Amazon's infrastructure.

00:48:40,013 --> 00:48:42,428
Oh, this is what Node.js looks like, it's horrible.

00:48:42,428 --> 00:48:45,367
But you know, this is not that much more code

00:48:45,367 --> 00:48:48,444
gives you a very primitive version of Compiler Explorer.

00:48:48,444 --> 00:48:50,512
You just say hey, I'm gonna get some requests

00:48:50,512 --> 00:48:52,520
being posted to me at this URL,

00:48:52,520 --> 00:48:56,007
feed them to the compiler, see what it comes out with,

00:48:56,007 --> 00:48:59,967
maybe do a bit of primitive text processing

00:48:59,967 --> 00:49:01,357
and then give it back.

00:49:01,357 --> 00:49:03,342
So straightforward, I wish it was as easy

00:49:03,342 --> 00:49:05,090
to do some things like that in C++,

00:49:05,090 --> 00:49:06,194
and I'm sure there are people in room,

00:49:06,194 --> 00:49:07,791
who can tell me libraries that I should be using

00:49:07,791 --> 00:49:10,114
to make it that easy.

00:49:10,114 --> 00:49:12,243
Behind the scenes, it all runs on Amazon's infrastructure,

00:49:12,243 --> 00:49:16,255
that means EC2, which is their Elastic Compute Cloud.

00:49:16,255 --> 00:49:18,223
I have an edge cache, oh, first it's worth saying

00:49:18,223 --> 00:49:20,550
that it started out as like on the free tier,

00:49:20,550 --> 00:49:22,424
so literally the world's smallest computer

00:49:22,424 --> 00:49:24,725
that Amazon would give me for a year for free.

00:49:24,725 --> 00:49:27,021
And as demand increased, it got more

00:49:27,021 --> 00:49:28,367
and more sophisticated, which is to say

00:49:28,367 --> 00:49:31,560
that the onion layers have grown and grown around it

00:49:31,560 --> 00:49:34,545
and now it's just a bit of a dev ops nightmare.

00:49:34,545 --> 00:49:38,019
But anyway, it's now fully cached at the edge.

00:49:38,019 --> 00:49:39,367
So hopefully, when you load the page,

00:49:39,367 --> 00:49:41,209
it comes up pretty quickly.

00:49:41,209 --> 00:49:44,069
There's a load balancer behind the edge cache.

00:49:44,069 --> 00:49:45,865
So when you actually make your post,

00:49:45,865 --> 00:49:47,813
it gets fed out to one of the many instances

00:49:47,820 --> 00:49:49,860
that I have in the background.

00:49:49,860 --> 00:49:53,500
Those instances are VMs that are running Ubuntu.

00:49:53,500 --> 00:49:55,520
And within those VMs, (as I told you it's onion layers)

00:49:55,520 --> 00:49:57,333
there are Docker images.

00:49:57,333 --> 00:49:59,831
So Docker is this sort of very lightweight container thing

00:49:59,831 --> 00:50:02,497
which allows you to bundle together data

00:50:02,497 --> 00:50:04,727
and sort of run a process in a namespace,

00:50:04,727 --> 00:50:07,360
which means it can only see a subset of the computer,

00:50:07,360 --> 00:50:08,980
so it's a bit like a VM within a VM,

00:50:08,980 --> 00:50:10,712
although much lighter weight.

00:50:10,712 --> 00:50:12,102
That gives me a certain amount of protection

00:50:12,102 --> 00:50:14,864
from all the crazy code you guys put into the site

00:50:14,864 --> 00:50:17,339
not taking down the whole thing.

00:50:17,339 --> 00:50:18,858
And also, it gives me a way of like making sure

00:50:18,858 --> 00:50:20,512
I can run the exact binaries locally

00:50:20,512 --> 00:50:23,693
that were gonna be deployed to the site.

00:50:23,693 --> 00:50:27,092
Most of the time, I don't break it when I update the site.

00:50:27,092 --> 00:50:28,192
And for a long time, I used to build

00:50:28,192 --> 00:50:29,620
all of the compiler images actually

00:50:29,620 --> 00:50:31,224
into those Docker images.

00:50:31,224 --> 00:50:34,274
And that started getting less fun

00:50:34,280 --> 00:50:37,360
when you get 40 or 50 gigabytes worth of compilers

00:50:37,360 --> 00:50:40,480
and you try and build a Node-sorry a Docker image for it

00:50:40,480 --> 00:50:42,192
and then you have to try and push it to all of the nodes,

00:50:42,192 --> 00:50:44,346
and you know, it takes like 10 or 15 minutes

00:50:44,346 --> 00:50:46,213
for a node to start up, because it has to pull down

00:50:46,213 --> 00:50:48,770
all this data before it can even start.

00:50:48,770 --> 00:50:51,260
I solved it with the cheesiest hack in the world,

00:50:51,260 --> 00:50:52,963
and that is I just have a big NFS mount

00:50:52,963 --> 00:50:57,308
that everything stays on, so it seems to work.

00:50:57,308 --> 00:51:00,902
The compilers themselves, as I said, initially,

00:51:00,902 --> 00:51:03,115
I started out by apt-get installing them.

00:51:03,115 --> 00:51:05,499
So the Docker images kind of looked like little VMs,

00:51:05,499 --> 00:51:07,065
and so you would shell into them, and then I'd have

00:51:07,065 --> 00:51:09,107
all these commands, I would like sudo apt-get install

00:51:09,107 --> 00:51:12,593
gcc-blah blah blah blah or whatever.

00:51:12,593 --> 00:51:15,154
That was great, it was very convenient.

00:51:15,154 --> 00:51:17,248
But then I was finding that the compilers

00:51:17,248 --> 00:51:20,122
I'd originally put on the site for like Ubuntu 11

00:51:20,122 --> 00:51:22,326
were being deprecated and they wouldn't install

00:51:22,326 --> 00:51:25,930
on GCC 12 or 14 or 16, so I was keeping an container around

00:51:25,930 --> 00:51:27,732
just because it had some ancient compiler

00:51:27,732 --> 00:51:28,881
that I wanted to keep.

00:51:28,881 --> 00:51:30,689
And I wanna make sure that the URLs

00:51:30,689 --> 00:51:34,144
that you guys are sharing around are always gonna work,

00:51:34,144 --> 00:51:35,950
which is a whole other story, you know,

00:51:35,950 --> 00:51:38,616
URLs are forever, forget like any kind of radiation thing,

00:51:38,616 --> 00:51:42,231
it's like URLs stick around absolutely forever.

00:51:42,231 --> 00:51:44,719
So now they're built through these Docker images,

00:51:44,719 --> 00:51:48,719
I've spend quite a bunch of time trying to learn

00:51:49,961 --> 00:51:51,845
good practices for building compilers,

00:51:51,845 --> 00:51:53,075
and so I've kind of canonified that,

00:51:53,075 --> 00:51:56,144
it's all on my website, which I should link towards the end.

00:51:56,144 --> 00:51:58,587
And they're built in Docker images just because then

00:51:58,587 --> 00:51:59,886
I have reproducible builds, which is something

00:51:59,886 --> 00:52:01,737
I'm very passionate about, I want anyone else

00:52:01,737 --> 00:52:03,546
to be able to clone this down and be able to build

00:52:03,546 --> 00:52:06,552
the same compiler the Compiler Explorer is using.

00:52:06,552 --> 00:52:07,875
And more to the point, actually, once I've built them,

00:52:07,875 --> 00:52:10,351
I chucked them on S3 and then marked public.

00:52:10,351 --> 00:52:12,322
And I keep getting emails from Amazon

00:52:12,322 --> 00:52:13,793
because there have a lot of people recently

00:52:13,793 --> 00:52:15,719
who's discovered that they have public information

00:52:15,719 --> 00:52:18,248
on S3 and they didn't mean to.

00:52:18,248 --> 00:52:20,342
Well, I actually mean to, the reason that they're public

00:52:20,342 --> 00:52:21,895
is that you can actually run a shell script

00:52:21,895 --> 00:52:24,192
and if you have enough hard disk space,

00:52:24,192 --> 00:52:26,874
you're gonna get 40 gigs worth of open source compilers

00:52:26,874 --> 00:52:28,542
dumped onto your hard disk, which is cool

00:52:28,542 --> 00:52:30,119
because then you can run your own local instance

00:52:30,119 --> 00:52:32,276
of Compiler Explorer if you don't wanna ship

00:52:32,276 --> 00:52:35,172
your code to me, for example.

00:52:35,172 --> 00:52:37,018
That's the open source ones.

00:52:37,018 --> 00:52:39,299
Very kindly, Intel have provided me with licenses as well

00:52:39,299 --> 00:52:41,868
for the ICC- they're somewhere else.

00:52:41,868 --> 00:52:45,011
And the Microsoft compilers also currently run via WINE,

00:52:45,011 --> 00:52:49,246
which is a bit of an admission of my lack

00:52:49,246 --> 00:52:51,307
of understanding of how to administrate Windows

00:52:51,307 --> 00:52:53,044
more than anything else.

00:52:53,044 --> 00:52:55,805
I'm glad to say I've met up with Andrew

00:52:55,805 --> 00:52:57,242
and some of the other Microsoft folks

00:52:57,242 --> 00:52:58,360
who are gonna help me and we're hoping

00:52:58,360 --> 00:53:01,812
to get some proper support for the Windows compilers

00:53:01,812 --> 00:53:04,279
into Compiler Explorer, so that's

00:53:04,279 --> 00:53:06,693
a really exciting thing that's coming up.

00:53:06,700 --> 00:53:10,440
(applause)

00:53:10,940 --> 00:53:13,238
Thank them, thank them.

00:53:13,238 --> 00:53:14,591
And you know, security.

00:53:14,591 --> 00:53:16,631
Well, I only got an email this morning, actually,

00:53:16,631 --> 00:53:18,268
from someone who thinks they've hacked my site

00:53:18,268 --> 00:53:20,866
and maybe they have, I don't know.

00:53:20,866 --> 00:53:25,525
Turns out a compiler is a gigantic security hole

00:53:25,525 --> 00:53:28,492
waiting to happen, it's a huge attack vector.

00:53:28,492 --> 00:53:30,920
Compiler writers are awesome, as I think

00:53:30,920 --> 00:53:33,048
I've already said enough times.

00:53:33,048 --> 00:53:34,475
They're not really security experts

00:53:34,475 --> 00:53:36,339
and they're not really, they don't have to be, right,

00:53:36,339 --> 00:53:37,443
they're on a trusted system.

00:53:37,443 --> 00:53:41,910
But I had no idea how many ways there were to inject code

00:53:41,910 --> 00:53:42,861
into a compiler.

00:53:42,861 --> 00:53:44,451
You know, you think a compiler just builds the code,

00:53:44,451 --> 00:53:46,500
I'm not actually executing it, right, I'm just.

00:53:46,500 --> 00:53:48,227
But GCC has a plugin architecture,

00:53:48,227 --> 00:53:49,954
you can supply a -F plugin and point it

00:53:49,954 --> 00:53:52,749
at something which is a load as a dynamic library.

00:53:52,749 --> 00:53:55,868
So if you can cause the compiler to crash,

00:53:55,868 --> 00:53:57,927
but having written the file somewhere,

00:53:57,927 --> 00:54:00,549
and then my cleanup code doesn't work immediately,

00:54:00,549 --> 00:54:02,439
then you might be able to guess the path of it

00:54:02,439 --> 00:54:05,524
and then do another compile with -F plugin equals boo,

00:54:05,524 --> 00:54:07,417
and then you're in.

00:54:07,417 --> 00:54:08,900
Only happened once.

00:54:08,900 --> 00:54:11,629
(audience laughter)

00:54:11,629 --> 00:54:13,436
Also behind the scenes.

00:54:13,436 --> 00:54:15,340
GCC uses something called specs files,

00:54:15,340 --> 00:54:17,226
which I don't claim to understand,

00:54:17,226 --> 00:54:19,118
but it seems to be part of the processes,

00:54:19,118 --> 00:54:22,057
the many, many pipelined processes

00:54:22,057 --> 00:54:24,494
that comprise the compilation, from the preprocessor

00:54:24,494 --> 00:54:27,565
through CC1+ through the AS assembler

00:54:27,565 --> 00:54:29,120
and all that kind of stuff, and essentially,

00:54:29,120 --> 00:54:31,679
it's a set of shell commands to run.

00:54:31,679 --> 00:54:32,988
And of course, you can say, actually,

00:54:32,988 --> 00:54:34,811
I'd like you to use my specs file over here.

00:54:34,811 --> 00:54:36,452
And again, you're back in the same world where,

00:54:36,452 --> 00:54:38,596
as long as you can write a file somewhere on the disk

00:54:38,596 --> 00:54:42,692
that says run, I don't know, netcat or something,

00:54:42,692 --> 00:54:45,561
then you know, you're in.

00:54:45,561 --> 00:54:47,776
I sort of started down a route of trying

00:54:47,776 --> 00:54:49,453
to harden everything, and then eventually

00:54:49,453 --> 00:54:50,903
I came to the conclusion that there's just no way

00:54:50,903 --> 00:54:53,031
I can make it completely bulletproof.

00:54:53,031 --> 00:54:55,625
And so I've accepted that the principle of

00:54:55,625 --> 00:54:57,856
what's the worst that can happen, it should apply.

00:54:57,856 --> 00:55:00,654
And that is, you can hack one of my nodes

00:55:00,654 --> 00:55:02,796
and you can take down the Docker instance,

00:55:02,796 --> 00:55:06,280
and even if you don't get out of the Docker container,

00:55:06,280 --> 00:55:08,637
the worst you can do is stop it from running

00:55:08,637 --> 00:55:10,461
and then something else will come and kill the process

00:55:10,461 --> 00:55:12,358
and it'll start up again.

00:55:12,358 --> 00:55:14,295
So hopefully, that's not too bad.

00:55:14,295 --> 00:55:16,787
Even if you escape the Docker sort of CH route,

00:55:16,787 --> 00:55:19,443
namespace jail, which I'm told is possible.

00:55:19,443 --> 00:55:22,536
You're in a VM which has no privileges to anything.

00:55:22,536 --> 00:55:24,179
I'm saying this for where it is being recorded,

00:55:24,179 --> 00:55:26,342
someone's gonna email me and say, "Ah, this is good,

00:55:26,342 --> 00:55:28,675
"actually, true," but oh well.

00:55:28,675 --> 00:55:30,076
Anyway.

00:55:30,076 --> 00:55:32,542
So Docker protects me in some ways from this.

00:55:32,542 --> 00:55:35,603
And I experimented for a long time using LD_PRELOAD tricks,

00:55:35,603 --> 00:55:38,564
which is a Unix specific thing where you can force

00:55:38,564 --> 00:55:41,778
a dynamic library to be loaded before an executable is run

00:55:41,778 --> 00:55:43,787
and then you can replace some of the system routines,

00:55:43,787 --> 00:55:45,886
so I have a little bit of code that basically

00:55:45,886 --> 00:55:48,060
replaces open and read and all that kind of stuff

00:55:48,060 --> 00:55:50,244
and just has a blacklist and whitelist

00:55:50,244 --> 00:55:52,186
of all the different files that you,

00:55:52,186 --> 00:55:53,660
that I was allowing the compiler to read,

00:55:53,660 --> 00:55:55,791
and that was my way of preventing people from doing like

00:55:55,791 --> 00:55:59,042
#include/etc/passwd, ha ha ha.

00:55:59,042 --> 00:56:00,309
Which is essentially the kind of thing

00:56:00,309 --> 00:56:02,142
that people try first.

00:56:03,022 --> 00:56:05,313
Turns out though the compiler needs to read /etc/passwd,

00:56:05,313 --> 00:56:07,122
'cause he wants to know which user's running it.

00:56:07,122 --> 00:56:09,133
And I thought well, okay, we'll allow that.

00:56:09,133 --> 00:56:11,464
And then it was oh, now it's trying to read

00:56:11,464 --> 00:56:14,230
/proc/cpuinfo, I'm like, well, that's a bit dodgy.

00:56:14,230 --> 00:56:15,932
Why should I let it read the proc file system?

00:56:15,932 --> 00:56:17,198
And it's like, well, because people wanna type

00:56:17,198 --> 00:56:19,840
mach=native, and how else is the compiler gonna find out

00:56:19,840 --> 00:56:21,394
what CPU it's running on?

00:56:21,394 --> 00:56:23,089
And so on and so forth, and before I knew it,

00:56:23,089 --> 00:56:25,121
everything was basically fair game for the compiler,

00:56:25,121 --> 00:56:26,953
I just threw my hands up and said, well, sod it.

00:56:26,953 --> 00:56:29,036
(laughs)

00:56:30,041 --> 00:56:31,069
So I guess we should talk a little bit

00:56:31,069 --> 00:56:33,317
about that frontend, the bit you see.

00:56:33,317 --> 00:56:35,634
So another huge props to Microsoft here.

00:56:35,634 --> 00:56:38,339
Visual Studio Code's editor is a separate project

00:56:38,339 --> 00:56:40,535
that you can, written in JavaScript,

00:56:40,535 --> 00:56:42,282
that you can just take and plonk in your project,

00:56:42,282 --> 00:56:45,122
and it's awesome, it's a fully featured editor.

00:56:45,122 --> 00:56:47,483
And it does everything I'd ever want.

00:56:47,483 --> 00:56:50,287
That diff view, for example, that diff view

00:56:50,287 --> 00:56:53,710
is just a native thing that my code can do.

00:56:53,710 --> 00:56:56,121
It had long been on my backlog to have a diff.

00:56:56,121 --> 00:56:57,329
Things like bug number three.

00:56:57,329 --> 00:56:59,800
And then, when I moved over to Monaco from CodeMirror,

00:56:59,800 --> 00:57:02,497
which was the previous JavaScript library I was using,

00:57:02,497 --> 00:57:03,802
it had this diff feature.

00:57:03,802 --> 00:57:05,839
I was like oh, that's cool, and it was just

00:57:05,839 --> 00:57:08,612
two lines of code to enable it, it was awesome.

00:57:08,612 --> 00:57:10,603
And then the funny sort of drag and drop thing

00:57:10,603 --> 00:57:13,510
that I see other people wrestling with,

00:57:13,510 --> 00:57:15,349
which is more of a testament to how rubbish I am

00:57:15,349 --> 00:57:19,228
at user experience design, is golden layout,

00:57:19,228 --> 00:57:21,507
and I'd like to, thanks to both the teams

00:57:21,507 --> 00:57:24,364
behind those things, it's awesome that they open sourced

00:57:24,364 --> 00:57:26,480
those things, it made it very easy to sort of like

00:57:26,480 --> 00:57:28,991
copy paste the website together.

00:57:28,991 --> 00:57:29,935
And clicker.

00:57:29,935 --> 00:57:31,362
So the code's on GitHub.

00:57:31,362 --> 00:57:33,342
There are two repositories, the first one

00:57:33,342 --> 00:57:36,835
has all of the Node's code and all of the frontend code,

00:57:36,835 --> 00:57:39,760
so effectively, if you have Node on your machine,

00:57:39,760 --> 00:57:41,066
you should be able to git clone that

00:57:41,066 --> 00:57:43,490
and type make, and then you're done.

00:57:43,490 --> 00:57:45,133
You'll have your own local running version

00:57:45,133 --> 00:57:47,477
of Compiler Explorer.

00:57:47,477 --> 00:57:51,081
The second line there is the image,

00:57:51,081 --> 00:57:53,047
which has all of the Amazon stuff,

00:57:53,047 --> 00:57:54,394
it has all of the Docker container stuff,

00:57:54,394 --> 00:57:56,327
it has all of the compiler scripts, it has everything.

00:57:56,327 --> 00:57:57,570
So basically, if I were to be knocked over

00:57:57,570 --> 00:57:58,959
by a bus tomorrow, you should be able

00:57:58,959 --> 00:58:02,853
to reconstitute Compiler Explorer with what's there.

00:58:02,853 --> 00:58:05,853
And if you, oh, I've done that one.

00:58:05,853 --> 00:58:07,427
And there will be more about this running in

00:58:07,427 --> 00:58:11,594
the next C++ Weekly, Jason's weekly YouTube thingamajig.

00:58:15,074 --> 00:58:18,194
So this is a slide I plonked in earlier

00:58:18,194 --> 00:58:19,826
so I haven't really thought about what I'm gonna say.

00:58:19,826 --> 00:58:22,062
But this is inspired by the conversations

00:58:22,062 --> 00:58:24,035
I've had with you, you folks.

00:58:24,035 --> 00:58:26,896
And that is, I think you've got a flavor for how

00:58:26,896 --> 00:58:30,255
I use Compiler Explorer, why it was made.

00:58:30,255 --> 00:58:32,400
And I've been surprised at how differently

00:58:32,400 --> 00:58:34,665
everyone else seems to use it.

00:58:34,665 --> 00:58:36,882
There are a few people who like to show

00:58:36,882 --> 00:58:38,602
cool and cute optimizations the compiler does,

00:58:38,602 --> 00:58:42,579
but it has become this sort of defacto code pastebin.

00:58:42,579 --> 00:58:45,079
I think Jason alluded to that in the introduction saying

00:58:45,079 --> 00:58:46,938
that, you know, it's how we share stuff now,

00:58:46,938 --> 00:58:51,048
which is, you know, hugely exciting for me.

00:58:51,048 --> 00:58:52,639
And I know that some of the compiler teams

00:58:52,639 --> 00:58:54,722
are using it internally to test out things

00:58:54,722 --> 00:58:58,472
that they're doing and I did a search on both

00:58:59,325 --> 00:59:01,426
the Clang and the GCC bug forums,

00:59:01,426 --> 00:59:04,440
and there are over 100 bugs that have citations

00:59:04,440 --> 00:59:06,563
to Compiler Explorer links.

00:59:06,563 --> 00:59:08,939
And people use it to like sort of bisect quickly, you know,

00:59:08,939 --> 00:59:10,762
you can just drop, the drop down has like

00:59:10,762 --> 00:59:12,353
so many compilers, you just go and flick up and down here,

00:59:12,353 --> 00:59:16,270
oh, it was introduced in 6.2, and that's great.

00:59:17,157 --> 00:59:18,629
I've also seen people or heard of people

00:59:18,629 --> 00:59:21,191
using it as a kind of REPL.

00:59:21,191 --> 00:59:22,192
Which, you know, if you're doing

00:59:22,192 --> 00:59:24,427
a bit of template meta programming, you can write tests,

00:59:24,427 --> 00:59:27,976
you can write, you know, constexpr codes

00:59:27,976 --> 00:59:30,057
that uses it or static asserts.

00:59:30,057 --> 00:59:32,964
And you can start like noodling and typing code.

00:59:32,964 --> 00:59:36,256
I think this sort of shows the deficiency in our tooling.

00:59:36,256 --> 00:59:39,171
It's a nicer experience to type into a website

00:59:39,171 --> 00:59:41,848
which posts your code across the Internet

00:59:41,848 --> 00:59:44,393
to someone else's machine that builds it and sends it back

00:59:44,393 --> 00:59:45,788
than it is to just do it locally.

00:59:45,788 --> 00:59:49,758
So I wonder if tools persons in the audience

00:59:49,758 --> 00:59:52,029
might have some ideas from that.

00:59:52,029 --> 00:59:53,181
And I've also seen people using it

00:59:53,181 --> 00:59:55,877
as a training resource, which is also really rewarding,

00:59:55,877 --> 00:59:59,806
you know, to be on this point in the opening keynote,

00:59:59,806 --> 01:00:02,375
you know, teaching C++ and making sure

01:00:02,375 --> 01:00:04,206
people understand how to write this code

01:00:04,206 --> 01:00:05,928
and understanding the processes that we go through

01:00:05,928 --> 01:00:08,576
when we write code is important, and it's nice that

01:00:08,576 --> 01:00:12,467
I feel like Compiler Explorer can help with that.

01:00:12,467 --> 01:00:14,234
Quick sneak, sneak?

01:00:14,234 --> 01:00:16,981
Yeah, sneak peak, I always get those the wrong way around,

01:00:16,981 --> 01:00:18,951
of things that are coming soon.

01:00:18,951 --> 01:00:22,157
There is CFG, that is a control flow graph viewer

01:00:22,157 --> 01:00:23,307
coming very very soon, in fact,

01:00:23,307 --> 01:00:26,224
it's on the beta site or beta site.

01:00:27,722 --> 01:00:31,715
So if you go to godbolt.org/beta,

01:00:31,715 --> 01:00:35,269
then you'll see that there is a new icon

01:00:35,269 --> 01:00:37,299
on the far right hand side of the assembly pane

01:00:37,299 --> 01:00:39,231
you can click and drag, and you get like a view

01:00:39,231 --> 01:00:43,007
that shows how the different basic blocks interact.

01:00:43,007 --> 01:00:44,902
I'm also looking to unify all the languages,

01:00:44,902 --> 01:00:47,263
so you've noticed that it's inappropriately,

01:00:47,263 --> 01:00:50,293
as many people have said, called gcc.godbolt.org.

01:00:50,293 --> 01:00:51,804
It should just be godbolt.org, well,

01:00:51,804 --> 01:00:53,741
should really just be compilerexplorer.com,

01:00:53,741 --> 01:00:54,886
but you know, no one's gonna let me get away

01:00:54,886 --> 01:00:56,993
with renaming it now.

01:00:56,993 --> 01:00:58,384
So I'd like to have all the different languages,

01:00:58,384 --> 01:01:00,403
you know, there are other languages supported, D,

01:01:00,403 --> 01:01:03,858
there's Haskell, there's Swift, there's ISPC.

01:01:03,858 --> 01:01:05,213
They're all there, and it would be nice

01:01:05,213 --> 01:01:06,762
to have them all in one places so instead of hitting

01:01:06,762 --> 01:01:08,231
different URLs, you could actually bring up

01:01:08,231 --> 01:01:10,964
two different editors from two different languages, right.

01:01:10,964 --> 01:01:13,333
The Go version and the C version of something,

01:01:13,333 --> 01:01:16,369
and then see how the assembly works out side by side.

01:01:16,369 --> 01:01:17,884
I fear that will lead to some flame wars,

01:01:17,884 --> 01:01:21,656
so I'm not taking any responsibility for that.

01:01:21,656 --> 01:01:24,739
And then the one thing everybody always asks me about

01:01:24,739 --> 01:01:26,665
is executing the code.

01:01:26,665 --> 01:01:28,515
I mean, it's fair to say, there are other online compilers

01:01:28,515 --> 01:01:30,491
out there and they are very good and you should

01:01:30,491 --> 01:01:31,798
check them out as well, there's OneBox

01:01:31,798 --> 01:01:34,893
and other ones that escape my mind right now.

01:01:34,893 --> 01:01:37,744
But they have, some of those have execution support,

01:01:37,744 --> 01:01:40,172
and that's awesome, because it's nice to write the code,

01:01:40,172 --> 01:01:42,844
it's even better if you can see what it actually does.

01:01:42,844 --> 01:01:45,341
But you've seen my amateur hour devops and security setup,

01:01:45,341 --> 01:01:47,119
so I've really gotta get my head around that

01:01:47,119 --> 01:01:50,639
before I allow arbitrary code to be run.

01:01:50,639 --> 01:01:52,769
But it is coming soon and I'm taking advice from people

01:01:52,769 --> 01:01:55,856
who know much more about this than me.

01:01:55,856 --> 01:01:56,785
Okay.

01:01:56,785 --> 01:01:58,211
We're at the end now and I just wanna say thanks.

01:01:58,211 --> 01:01:59,901
This is not just me.

01:01:59,901 --> 01:02:03,641
Compiler Explorer is now, I'm glad to say,

01:02:03,641 --> 01:02:05,430
getting a lot of contributions from external people,

01:02:05,430 --> 01:02:09,944
so Ruben, Gabriel, Simon Brand, Johan, Jared, Chedy.

01:02:09,944 --> 01:02:12,747
And the other people that have both filed issues

01:02:12,747 --> 01:02:14,471
or taken the time to contact me directly

01:02:14,471 --> 01:02:16,657
and tell me about issues that they found

01:02:16,657 --> 01:02:18,940
or have suggestions for the site and,

01:02:18,940 --> 01:02:21,522
you know, it's awesome, it's lovely to have something

01:02:21,522 --> 01:02:22,788
that has been a labor of love,

01:02:22,788 --> 01:02:24,771
that you were scratching your own itch and then find

01:02:24,771 --> 01:02:26,080
that actually, it's useful for other people,

01:02:26,080 --> 01:02:27,310
and not only that, that they are willing

01:02:27,310 --> 01:02:28,903
to help you with it.

01:02:28,903 --> 01:02:31,818
Thanks also to the Patreon folks who help pay the bill.

01:02:31,818 --> 01:02:34,127
I'm in an embarrassing situation of actually making

01:02:34,127 --> 01:02:35,848
a small amount of money at the moment out of this,

01:02:35,848 --> 01:02:38,907
which is awkward, so I keep upping the number of instances

01:02:38,907 --> 01:02:40,883
just to counteract it, so if you put more money,

01:02:40,883 --> 01:02:42,228
then you'll get faster compiles.

01:02:42,228 --> 01:02:44,648
(audience laughter)

01:02:44,648 --> 01:02:47,923
Thanks to the awesome C++ community, oh, ooh,

01:02:47,923 --> 01:02:49,813
there we go, spoiled the ending.

01:02:49,813 --> 01:02:53,884
Thanks to the awesome C++ community, the folks on Slack

01:02:53,884 --> 01:02:57,105
have been a great source of inspiration, idea bouncing,

01:02:57,105 --> 01:02:59,235
and of course, thanks to you for sitting through

01:02:59,235 --> 01:03:02,147
while I talk about my funny little website.

01:03:02,147 --> 01:03:05,320
Go and read some assembly, thank you.

01:03:05,320 --> 01:03:07,570
(applause)

01:03:17,924 --> 01:03:19,555
Thank you.

01:03:19,555 --> 01:03:22,846
We've got time for some questions until

01:03:22,846 --> 01:03:25,556
I'm told otherwise, so yeah, hi.

01:03:25,556 --> 01:03:26,863
- [Male Audience Member] Can you go back to the slide

01:03:26,863 --> 01:03:30,306
where you showed the summation or the equation?

01:03:30,306 --> 01:03:33,556
- Oh, you're gonna find a hole in my amateur maths, yeah.

01:03:33,556 --> 01:03:36,556
I'm not, I'm, oh, somewhere in here.

01:03:38,157 --> 01:03:38,990
Hold up.

01:03:41,768 --> 01:03:44,074
I think it would stick out like a sore thumb, right?

01:03:44,074 --> 01:03:44,982
There it is.

01:03:44,982 --> 01:03:45,927
All right.

01:03:45,927 --> 01:03:50,238
- Yeah, so the interesting thing is that actually,

01:03:50,238 --> 01:03:52,652
the Clang transformed this to have this like

01:03:52,652 --> 01:03:56,005
x - 1 'cause it's worried about overflow,

01:03:56,005 --> 01:03:58,748
but the multiply can also overflow because

01:03:58,748 --> 01:04:01,057
the whole thing cannot overflow, right.

01:04:01,057 --> 01:04:04,019
So if you look at the assembly, you will see that

01:04:04,019 --> 01:04:06,373
it uses some very weird instructions and actually

01:04:06,373 --> 01:04:09,987
in the compiler, it models it as a 33 bits.

01:04:09,987 --> 01:04:11,242
Yeah.

01:04:11,242 --> 01:04:12,640
- Oh, I see, well, there's somebody

01:04:12,640 --> 01:04:14,003
who actually knows what they're talking about.

01:04:14,003 --> 01:04:15,403
(laughs)

01:04:15,403 --> 01:04:18,148
- [Male Audience Member] Yeah, I hope that 15.6 MSVC

01:04:18,148 --> 01:04:19,753
will also have this.

01:04:19,753 --> 01:04:21,687
- I don't know, we've got some MSVC folks in here.

01:04:21,687 --> 01:04:22,915
Thank you.

01:04:22,915 --> 01:04:24,689
I guess on this side, hi.

01:04:24,689 --> 01:04:27,348
- I actually had a question about scope.

01:04:27,348 --> 01:04:31,359
Other tools that I've used as like a pastebin for code

01:04:31,359 --> 01:04:35,882
provide external libraries like Boost or ranges.

01:04:35,882 --> 01:04:38,697
Any plans, or is that even in scope for this project?

01:04:38,697 --> 01:04:40,497
- Let's have a look, hang on.

01:04:40,497 --> 01:04:42,907
Just the other day, some kind soul, oh look,

01:04:42,907 --> 01:04:44,213
thank you, Twitter.

01:04:44,213 --> 01:04:45,486
Oh, go away.

01:04:45,486 --> 01:04:46,548
(laughs)

01:04:46,548 --> 01:04:49,978
Never do things live, let's go to the live website.

01:04:49,978 --> 01:04:52,313
So we now have a relatively straightforward way

01:04:52,313 --> 01:04:54,927
of adding libraries in, and I'm glad to say Abseil

01:04:54,927 --> 01:04:56,569
is one of the more recent ones that we put in.

01:04:56,569 --> 01:04:57,402
- [Male Audience Member] That is awesome.

01:04:57,402 --> 01:04:58,235
(applause)

01:04:58,235 --> 01:05:01,556
- So thank you, Google, heads up on that.

01:05:01,556 --> 01:05:03,806
Oh, thank you, I guess, hi.

01:05:05,099 --> 01:05:05,932
- Hi.

01:05:05,932 --> 01:05:07,883
Okay, so you said you like people

01:05:07,883 --> 01:05:09,995
to use it to share code, right?

01:05:09,995 --> 01:05:13,196
Any way of making links shorter?

01:05:13,196 --> 01:05:15,633
- Well, the link shortening.

01:05:15,633 --> 01:05:17,909
So I have a thing.

01:05:17,909 --> 01:05:21,113
At least at the moment, I'm not storing any data at all,

01:05:21,113 --> 01:05:23,217
I think I should make that clear, I don't care about

01:05:23,217 --> 01:05:26,522
your code, my life is far too complicated and short

01:05:26,522 --> 01:05:28,074
to read your code, so I don't do anything with it

01:05:28,074 --> 01:05:30,174
other than compile it and throw it away.

01:05:30,174 --> 01:05:31,803
And I don't even wanna store it long term at the moment

01:05:31,803 --> 01:05:33,545
until I have like some privacy policy and things,

01:05:33,545 --> 01:05:36,525
so what actually happens in the URL has everything,

01:05:36,525 --> 01:05:41,032
so when we do the long URL, if I were to get a share here.

01:05:41,032 --> 01:05:42,765
You've seen it, it's like, it's giant.

01:05:42,765 --> 01:05:44,277
So then I use Google's link shortener

01:05:44,277 --> 01:05:46,332
to turn it into the smaller version that it is

01:05:46,332 --> 01:05:48,461
and I've been reliably, what's that, sorry?

01:05:48,461 --> 01:05:49,647
- [Male Audience Member] It fails at some point.

01:05:49,647 --> 01:05:51,657
- Yes, it fails at 8,000 characters.

01:05:51,657 --> 01:05:54,629
So I'm gonna have to pony up at some point

01:05:54,629 --> 01:05:57,404
and actually store your data, I think, in order to give you

01:05:57,404 --> 01:05:59,951
the sort of features that people are asking for.

01:05:59,951 --> 01:06:01,508
And we've got some ideas about how to do that

01:06:01,508 --> 01:06:03,739
and to do it in a way that means that

01:06:03,739 --> 01:06:06,676
your data is safe and backed up,

01:06:06,676 --> 01:06:08,970
because I never want those URLs to go away,

01:06:08,970 --> 01:06:10,407
that's really important to me that people

01:06:10,407 --> 01:06:12,616
can still go back to Stack Overflow five years ago

01:06:12,616 --> 01:06:14,509
and find some awesome reply to something

01:06:14,509 --> 01:06:16,602
and then still have it work.

01:06:16,602 --> 01:06:17,435
- [Male Audience Member] Okay, thanks.

01:06:17,435 --> 01:06:18,435
- Thank you.

01:06:19,759 --> 01:06:20,592
Hi.

01:06:20,592 --> 01:06:22,704
- Regarding that optimization you were talking about

01:06:22,704 --> 01:06:27,596
with the hash table where you have a set of fixed choices

01:06:27,596 --> 01:06:28,429
of the length of the hash table--

01:06:28,429 --> 01:06:30,412
- [Matt] Right, the boost multi_index one, yeah.

01:06:30,412 --> 01:06:32,171
- And then you do a switch.

01:06:32,171 --> 01:06:35,339
Well, those possible fixed choices aren't right next

01:06:35,339 --> 01:06:37,466
to each other, they're all spread apart.

01:06:37,466 --> 01:06:40,424
So you're gonna wind up having to do a binary search,

01:06:40,424 --> 01:06:42,864
which is a whole bunch of ifs, so you stall the pipeline.

01:06:42,864 --> 01:06:43,822
- Yeah, yeah.

01:06:43,822 --> 01:06:46,123
I simplified for the purposes, what I believe

01:06:46,123 --> 01:06:48,720
it actually does is it just has the set of ordinal values.

01:06:48,720 --> 01:06:52,166
So say it has 20 different choices of size of buckets

01:06:52,166 --> 01:06:54,523
and it switches between 0 and 20 then.

01:06:54,523 --> 01:06:56,772
And it knows that the 9th possible size of buckets

01:06:56,772 --> 01:06:59,977
is 1,021, I know I described it as case 1,021,

01:06:59,977 --> 01:07:02,858
but it was actually like, it would be switch case 9,

01:07:02,858 --> 01:07:05,025
return hash percent 1,021.

01:07:05,901 --> 01:07:08,656
Does that make more sense?

01:07:08,656 --> 01:07:10,546
- [Male Audience Member] Well, what I don't understand is,

01:07:10,546 --> 01:07:14,114
if you have a bunch of cases that are really far apart,

01:07:14,114 --> 01:07:16,279
you can't have a jump--

01:07:16,279 --> 01:07:18,056
- Right, they wouldn't be far apart, as I said,

01:07:18,056 --> 01:07:20,870
they would just be numbers between 0 and say 20

01:07:20,870 --> 01:07:22,855
as the 20 possible sizes.

01:07:22,855 --> 01:07:24,241
And then, of course, it just uses a jump table

01:07:24,241 --> 01:07:26,209
and so you just jumped to the right bit of code.

01:07:26,209 --> 01:07:28,707
Yeah, I'm sorry, I oversimplified that, I was thinking

01:07:28,707 --> 01:07:30,932
that otherwise I'd spend ages trying to explain it,

01:07:30,932 --> 01:07:34,299
and as you've probably realized, I'm not the best.

01:07:34,299 --> 01:07:36,032
I guess you were here first, yeah, go.

01:07:36,032 --> 01:07:37,021
- Hi.

01:07:37,021 --> 01:07:40,183
Do you have any idea to support execution?

01:07:40,183 --> 01:07:42,882
So I think that, if you support WebAssembly,

01:07:42,882 --> 01:07:44,979
I think it can be supported.

01:07:44,979 --> 01:07:47,131
- That's right, so yeah, using WebAssembly.

01:07:47,131 --> 01:07:48,746
I mean, it's already been the case that people have asked me

01:07:48,746 --> 01:07:50,675
to put JavaScript's backend support,

01:07:50,675 --> 01:07:53,520
and so I can compile the JavaScript and web,

01:07:53,520 --> 01:07:55,720
asm.js and then WebAssembly would be another thing.

01:07:55,720 --> 01:07:59,803
And so yes, there is a potential for compiling to

01:08:00,648 --> 01:08:03,478
WebAssembly, shipping it back to the client and saying,

01:08:03,478 --> 01:08:05,169
well, you can play with it as much as you like,

01:08:05,169 --> 01:08:07,145
the only computer you're breaking is your own.

01:08:07,145 --> 01:08:08,618
That has a certain appeal to it,

01:08:08,618 --> 01:08:09,857
but there are many many compilers here

01:08:09,857 --> 01:08:13,538
that don't have backends for WebAssembly.

01:08:13,538 --> 01:08:16,131
And so, I mean, I guess one thing I've thought about doing,

01:08:16,131 --> 01:08:17,560
I mean, if you came to my other talk, you know,

01:08:17,560 --> 01:08:20,780
I'm sort of strangely passionate about emulating things.

01:08:20,780 --> 01:08:22,624
And if you've ever seen any of my YouTube videos,

01:08:22,624 --> 01:08:24,560
I also love talking about microarchitecture

01:08:24,560 --> 01:08:27,193
and how the internals of processors work.

01:08:27,193 --> 01:08:29,381
In my dream job, I would sit down

01:08:29,381 --> 01:08:31,858
and I would write a JavaScript emulator for the x86

01:08:31,858 --> 01:08:32,958
with all the pipelines and everything,

01:08:32,958 --> 01:08:34,352
and then I could like complete the circle

01:08:34,352 --> 01:08:35,775
and have everything together, and then

01:08:35,775 --> 01:08:37,082
you could execute it locally and see

01:08:37,082 --> 01:08:39,913
how all the caches work and everything, it will be awesome.

01:08:39,913 --> 01:08:41,586
But no, at the moment, I think execution

01:08:41,586 --> 01:08:44,162
will probably remain on the server side.

01:08:44,162 --> 01:08:44,995
- [Male Audience Member] Okay, thank you.

01:08:44,995 --> 01:08:45,828
- Thank you.

01:08:45,828 --> 01:08:46,661
Oh yeah, go.

01:08:46,661 --> 01:08:47,494
- [Male Audience Member] I have one more--

01:08:47,494 --> 01:08:49,354
- Of course, go for it.

01:08:49,354 --> 01:08:53,897
- I just came here, you know, C++ conference, with

01:08:53,897 --> 01:08:56,898
my team members working for the Linux kernel,

01:08:56,898 --> 01:09:01,065
and do you have any idea to support the Linux kernel's code?

01:09:01,936 --> 01:09:05,787
- I would suggest that grab the code locally,

01:09:05,787 --> 01:09:07,963
point it at your own compiler, there are no restrictions

01:09:07,963 --> 01:09:10,034
on which files it can pick out when it's local,

01:09:10,034 --> 01:09:11,383
it's not running in a Docker container

01:09:11,383 --> 01:09:13,834
when you run it locally, so you can do -I

01:09:13,834 --> 01:09:15,382
and point it at user, include Linux

01:09:15,382 --> 01:09:17,925
or whatever you'd like it do, and that's what I do.

01:09:17,925 --> 01:09:19,950
So when I'm using Compiler Explorer at work,

01:09:19,950 --> 01:09:22,955
I'll use it locally and I'll do -I in my project path,

01:09:22,955 --> 01:09:25,370
and then I can just #include, you know,

01:09:25,370 --> 01:09:27,260
my thing that I'm interested in looking at .h

01:09:27,260 --> 01:09:28,517
and then write a little test function,

01:09:28,517 --> 01:09:29,874
I can see how the assembly's generated.

01:09:29,874 --> 01:09:32,503
So I think you could probably use the same approach there.

01:09:32,503 --> 01:09:34,179
- [Male Audience Member] Oh, okay, thank you very much.

01:09:34,179 --> 01:09:35,510
- You're welcome.

01:09:35,510 --> 01:09:37,023
- I appreciate it if you don't wanna get into this,

01:09:37,023 --> 01:09:39,248
but how much does this cost?

01:09:39,248 --> 01:09:42,217
- Oh, I don't mind telling you at all.

01:09:42,217 --> 01:09:46,614
I'm spending about $120 on Amazon costs just straight up,

01:09:46,614 --> 01:09:50,682
and then there's, just on like CPUs and stuff.

01:09:50,682 --> 01:09:53,304
And then there's like transfer costs and then there's

01:09:53,304 --> 01:09:55,392
the other miscellaneous, the bill, but it's, you know,

01:09:55,392 --> 01:09:57,473
about 150 on that, and then there's a bunch of other things

01:09:57,473 --> 01:09:58,540
that I have like, you know--

01:09:58,540 --> 01:10:00,227
- [Male Audience Member] 150 per.

01:10:00,227 --> 01:10:01,333
- Month, sorry.

01:10:01,333 --> 01:10:02,368
150 a month.

01:10:02,368 --> 01:10:03,269
And then there's a bunch of other stuff,

01:10:03,269 --> 01:10:06,881
it ends up being of around about $200 a month.

01:10:06,881 --> 01:10:09,509
And you know, I dither on what I'm gonna spend the surplus,

01:10:09,509 --> 01:10:11,724
so my patrons are currently about 300, which is,

01:10:11,724 --> 01:10:14,057
you know, awesome, so I'm like net up,

01:10:14,057 --> 01:10:15,162
although if you count--

01:10:15,162 --> 01:10:16,486
- [Male Audience Member] Well, it's gonna go up

01:10:16,486 --> 01:10:18,223
by 10 or something like that.

01:10:18,223 --> 01:10:19,200
It's just gonna keep going up.

01:10:19,200 --> 01:10:21,124
- I mean, maybe.

01:10:21,124 --> 01:10:24,764
Don't make it anymore awkward than it is.

01:10:24,764 --> 01:10:27,138
So yeah, if people have got ideas about how to improve it

01:10:27,138 --> 01:10:30,013
that may involve larger sums of money rather than that,

01:10:30,013 --> 01:10:31,615
then I'm all ears for adding stuff

01:10:31,615 --> 01:10:34,973
that's like a mouse click away particularly.

01:10:34,973 --> 01:10:35,806
Thank you.

01:10:37,366 --> 01:10:39,365
Oh, I guess now I've lost track of who is next,

01:10:39,365 --> 01:10:42,372
so I'm gonna just go alternating.

01:10:42,372 --> 01:10:44,859
- Do you think it's possible to support

01:10:44,859 --> 01:10:48,431
like LLVM intermediate representations in--

01:10:48,431 --> 01:10:50,421
- Yes, absolutely.

01:10:50,421 --> 01:10:53,373
- Like I think 'cause it will help LLVM folks,

01:10:53,373 --> 01:10:57,344
especially for people who's ramping up on that who like--

01:10:57,344 --> 01:10:59,644
- Can anyone remember what, lvo, lve?

01:10:59,644 --> 01:11:02,479
(audience chatter)

01:11:02,479 --> 01:11:03,749
Oh, well, there you are, that works, apparently.

01:11:03,749 --> 01:11:06,935
So it already is, don't clap, don't clap that,

01:11:06,935 --> 01:11:08,157
I can just put command line options in it

01:11:08,157 --> 01:11:09,476
and it just works, right.

01:11:09,476 --> 01:11:10,309
It looks--

01:11:10,309 --> 01:11:11,855
(laughs) (applause)

01:11:11,855 --> 01:11:13,968
Yeah, so it's sort of supported only because

01:11:13,968 --> 01:11:15,602
it will just dump whatever the compiler gives me,

01:11:15,602 --> 01:11:16,856
I'm not being clever here.

01:11:16,856 --> 01:11:18,285
But we have got some, I mean, you can see

01:11:18,285 --> 01:11:20,546
there's a load of redness in here that isn't that great.

01:11:20,546 --> 01:11:22,442
We're gonna be putting in like better support for

01:11:22,442 --> 01:11:25,684
syntax highlighting of LLVM, but you can do that already.

01:11:25,684 --> 01:11:28,533
And it would be nice to like filter it as well so, you know.

01:11:28,533 --> 01:11:30,074
It's gotten more and more sophisticated,

01:11:30,074 --> 01:11:31,206
the filtering that I do has gotten more

01:11:31,206 --> 01:11:32,869
and more sophisticated 'cause I really just wanna show

01:11:32,869 --> 01:11:34,219
the function that you're interested in

01:11:34,219 --> 01:11:36,161
and not all the fluff that comes in.

01:11:36,161 --> 01:11:38,973
I don't know enough about LLVM intermediate representation

01:11:38,973 --> 01:11:41,117
to know how to do that, but I think it'll be something

01:11:41,117 --> 01:11:42,992
that'll be coming down the line.

01:11:42,992 --> 01:11:44,547
- [Male Audience Member] Yeah, I think it looks pretty cool.

01:11:44,547 --> 01:11:46,636
- It also support -e, which is preprocessing, yeah,

01:11:46,636 --> 01:11:49,175
which is how people do the horrible like include line,

01:11:49,175 --> 01:11:50,489
we do have that over here, you know,

01:11:50,489 --> 01:11:53,739
#includes passwd.h, whatever.

01:11:53,739 --> 01:11:54,717
Yeah.

01:11:54,717 --> 01:11:55,550
Does that answer your question?

01:11:55,550 --> 01:11:56,383
- [Male Audience Member] Yeah yeah, thanks.

01:11:56,383 --> 01:11:57,216
- Thank you.

01:11:57,216 --> 01:11:59,091
All right, over this side now, hi.

01:11:59,091 --> 01:12:04,081
- I'll bring this comment on because you mentioned it.

01:12:04,081 --> 01:12:08,449
As far as I know, there is an x86 emulator in JavaScript.

01:12:08,449 --> 01:12:10,147
Yeah, you can look it up in Google,

01:12:10,147 --> 01:12:12,413
the one I know is in bellard.org.

01:12:12,413 --> 01:12:15,073
And it runs an entire Linux, it has a compiler,

01:12:15,073 --> 01:12:18,816
it runs everything even somewhat fast.

01:12:18,816 --> 01:12:20,898
I don't know how, that guy's crazy.

01:12:20,898 --> 01:12:22,243
- That would be fun.

01:12:22,243 --> 01:12:25,405
Yeah okay, thank you, that's a great idea, thanks.

01:12:25,405 --> 01:12:28,307
I think, last question by the look of it.

01:12:28,307 --> 01:12:30,936
- How do you get the association from C++ lines

01:12:30,936 --> 01:12:32,004
to assembly lines?

01:12:32,004 --> 01:12:32,942
- Oh, magic.

01:12:32,942 --> 01:12:36,289
No, I just pass -g, whatever you type in,

01:12:36,289 --> 01:12:38,390
there's always a -g in there and luckily,

01:12:38,390 --> 01:12:41,445
the assembly output has the dot lock things,

01:12:41,445 --> 01:12:45,170
the hint to the assembler to emit the dwarf debug

01:12:45,170 --> 01:12:46,401
and I parse that out.

01:12:46,401 --> 01:12:47,755
I also support STABs because

01:12:47,755 --> 01:12:49,525
there's some ancient compilers that do that as well,

01:12:49,525 --> 01:12:52,104
but it's not that sophisticated and

01:12:52,104 --> 01:12:55,211
I've filed a few bugs with, both I think GCC and Clang

01:12:55,211 --> 01:12:59,211
about like where they decide to plonk which line

01:13:00,470 --> 01:13:02,031
is correspondence to what, and because

01:13:02,031 --> 01:13:03,649
there's some obvious glaring ones, we're like, come on,

01:13:03,649 --> 01:13:05,450
guys, I'm sure that you could attribute this

01:13:05,450 --> 01:13:08,200
to the right spot, but we'll see.

01:13:09,564 --> 01:13:12,137
Okay, I, oh, is there, no, I think we're done.

01:13:12,137 --> 01:13:13,481
Thank you, everyone, thank you so much.

01:13:13,481 --> 01:13:15,731
(applause)

01:13:21,443 --> 01:13:22,276
(bright music)

01:13:22,276 --> 01:13:24,803
- Bash Films can shoot your even with multiple cameras,

01:13:24,803 --> 01:13:27,144
link to presentation slides, add titles

01:13:27,144 --> 01:13:29,872
and edit your event live for a full broadcast experience.

01:13:29,872 --> 01:13:31,938
- How is this even working?

01:13:31,938 --> 01:13:34,453
So this is actually a more interesting program to,

01:13:34,453 --> 01:13:38,177
you know, look at in a lot of ways.

01:13:38,177 --> 01:13:40,274
So let's profile it.

01:13:40,274 --> 01:13:42,635
Do a little bit of time to do a profile for us.

01:13:42,635 --> 01:13:46,141
Let's see exactly what it is that's making this faster

01:13:46,141 --> 01:13:47,927
or slower based on the different inputs.

01:13:47,927 --> 01:13:50,108
We could really gain a lot of insight by actually looking

01:13:50,108 --> 01:13:52,323
at the profile like this.

01:13:52,323 --> 01:13:54,696
- I worked at Sesame Street, I got brought on

01:13:54,696 --> 01:13:55,798
to be a writer's assistant on

01:13:55,798 --> 01:13:58,218
a show called Sesame Street English,

01:13:58,218 --> 01:14:01,453
which was to teach English to kids in China and Japan.

01:14:01,453 --> 01:14:04,042
It seems very simple, the shows that they put together,

01:14:04,042 --> 01:14:07,435
but it's actually really hard to design a show

01:14:07,435 --> 01:14:11,486
that is not only for young kids, but also the parents.

01:14:11,486 --> 01:14:13,705
- Confession like this is therapeutic,

01:14:13,705 --> 01:14:15,231
I hope you all get something out of this,

01:14:15,231 --> 01:14:17,236
but if you don't, the therapy will have been good for me,

01:14:17,236 --> 01:14:18,319
so thank you.

01:14:19,649 --> 01:14:22,687
Seven years ago, I was working, I wasn't working

01:14:22,687 --> 01:14:24,981
at (mumbles) for my previous employer,

01:14:24,981 --> 01:14:27,492
which was a large multinational investment bank.

01:14:27,492 --> 01:14:31,821
I had what was up to that point the worst day of my career.

01:14:31,821 --> 01:14:33,677
- And then came the anger.

01:14:33,677 --> 01:14:37,479
Anger at ourselves, because we knew we were responsible

01:14:37,479 --> 01:14:40,912
for America's first space disaster.

01:14:40,912 --> 01:14:43,283
We wrote two more words into our vocabularies

01:14:43,283 --> 01:14:45,710
as mission controllers, tough and competent.

01:14:45,710 --> 01:14:47,276
Tough meaning we will never again shirk

01:14:47,276 --> 01:14:50,117
from our responsibilities because we are forever accountable

01:14:50,117 --> 01:14:52,461
for what we do, competent, we'll never again

01:14:52,461 --> 01:14:54,439
take anything for granted.

01:14:54,439 --> 01:14:56,199
We will never stop learning, from now on,

01:14:56,199 --> 01:14:59,090
the teams and mission control will be perfect.

01:14:59,090 --> 01:15:02,360
Because as a team, we must never fail.

01:15:02,360 --> 01:15:03,860
- One other thing.

01:15:05,833 --> 01:15:08,699
We're all in a very fortunate position,

01:15:08,699 --> 01:15:11,698
we've been very lucky in our lives and so forth.

01:15:11,698 --> 01:15:13,832
And I think, as part of the mission,

01:15:13,832 --> 01:15:17,999
it's also good sometimes to take that fortune and give back.

01:15:20,052 --> 01:15:22,895
(applause)

01:15:22,895 --> 01:15:25,754
To make sure that we take this platform

01:15:25,754 --> 01:15:28,419
and use it towards worthy causes.

01:15:28,419 --> 01:15:31,823
That's good karma, that's good stuff in the universe.

01:15:31,823 --> 01:15:33,843
- We understand that your even will have needs

01:15:33,843 --> 01:15:36,015
that are specific to your organization.

01:15:36,015 --> 01:15:38,360
Please, email or call us directly to discuss

01:15:38,360 --> 01:15:39,875
your particular event.

01:15:39,875 --> 01:15:41,885
We look forward to discussing your goals

01:15:41,885 --> 01:15:45,023

YouTube URL: https://www.youtube.com/watch?v=bSkpMdDe4g4


