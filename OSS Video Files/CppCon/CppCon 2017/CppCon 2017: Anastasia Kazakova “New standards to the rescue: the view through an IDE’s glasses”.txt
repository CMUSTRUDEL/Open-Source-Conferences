Title: CppCon 2017: Anastasia Kazakova “New standards to the rescue: the view through an IDE’s glasses”
Publication date: 2017-10-04
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
We often talk about how new language features can help developers to write more accurate and concise code. There is another type of discussion to be had on how tools help leverage language issues and support developers. How about quite a third perspective? Which is about how language can help tools to do better. 

As C++ tools vendors, we use to share our experience with C++ language trickiness and peculiarities, including preprocessor and non-trivial parsing. It’s time now to talk about the view on the upcoming language changes through the IDE’s glasses. 

In this talk I’ll identify the most important issues with the language from the IDE’s perspective and will show how new language standards, as well as other initiatives like C++ Core Guidelines, are helpful and beneficial to the IDEs. I’ll cover a variety of features from if constexpr to Concepts and Modules, as well as std2 and some other initiatives that are no more than proposals at this point. Come and see the language from our perspective.
— 
Anastasia Kazakova: JetBrains, Product Marketing Manager

As a C and C++ software developer, Anastasia Kazakova created real-time *nix-based systems and pushed them to production for 8 years. She has a passion for networking algorithms and embedded programming and believes in good tooling. With all her love for C++, she is now the Product Marketing Manager on the JetBrains CLion team. Besides, Anastasia runs a C++ user group in Saint-Petersburg, Russia 
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,410
my name is Anastasia because a comment

00:00:01,949 --> 00:00:06,450
from jetbrains but today I'm not gonna

00:00:04,410 --> 00:00:07,859
talk about our tools so if you're

00:00:06,450 --> 00:00:11,190
interested please come to our booth on

00:00:07,859 --> 00:00:13,469
Wednesday and Thursday I'm gonna talk

00:00:11,190 --> 00:00:15,000
about the new standards and before I

00:00:13,469 --> 00:00:16,350
start I would like to say a little bit

00:00:15,000 --> 00:00:18,119
sorry for my voice I'm a little bit

00:00:16,350 --> 00:00:22,199
running out of it but I'll try to make

00:00:18,119 --> 00:00:24,960
this work for this one hour so talking

00:00:22,199 --> 00:00:27,150
about myself for quite a bit I was

00:00:24,960 --> 00:00:30,720
working as a civil spots developer for

00:00:27,150 --> 00:00:33,000
eight years doing some networking and

00:00:30,720 --> 00:00:34,800
embedded stuff and then I moved to

00:00:33,000 --> 00:00:36,090
JetBrains working most as product

00:00:34,800 --> 00:00:39,719
marketing manager or just some

00:00:36,090 --> 00:00:41,430
evangelism around the tools and I'm also

00:00:39,719 --> 00:00:44,760
running my own special group in

00:00:41,430 --> 00:00:48,450
Petersburg in Russia so uh this talk is

00:00:44,760 --> 00:00:50,820
mostly about the triangle between like

00:00:48,450 --> 00:00:53,940
developers languages and tools and how

00:00:50,820 --> 00:00:56,300
they are connected and related so uh if

00:00:53,940 --> 00:00:59,309
I start thinking so we have a developer

00:00:56,300 --> 00:01:01,260
who's actually start working on some

00:00:59,309 --> 00:01:03,149
tasks in a particular area and he starts

00:01:01,260 --> 00:01:04,619
with selecting a proper language I'm a

00:01:03,149 --> 00:01:07,229
type of the person who believes there

00:01:04,619 --> 00:01:09,270
are no Universal languages and so if

00:01:07,229 --> 00:01:13,380
he's like C++ that he has no reason for

00:01:09,270 --> 00:01:15,119
that it's especially rare for that so

00:01:13,380 --> 00:01:18,150
language features they actually they are

00:01:15,119 --> 00:01:20,880
to help developers to write some

00:01:18,150 --> 00:01:22,860
accurate and concise code to so their

00:01:20,880 --> 00:01:24,900
particular problems for the area they

00:01:22,860 --> 00:01:26,790
are working in and to provide some

00:01:24,900 --> 00:01:28,619
necessary performance and actually fit

00:01:26,790 --> 00:01:34,290
into their business environment the

00:01:28,619 --> 00:01:36,270
whole infrastructure they have so if we

00:01:34,290 --> 00:01:38,909
come with the tools actually developers

00:01:36,270 --> 00:01:42,240
they need tools to leverage some

00:01:38,909 --> 00:01:44,280
language issues to make developers more

00:01:42,240 --> 00:01:46,290
productive with some routine tasks and

00:01:44,280 --> 00:01:48,000
also to push some guidelines the

00:01:46,290 --> 00:01:50,100
Superbird core deadlines that Bjorn is

00:01:48,000 --> 00:01:52,320
talking about and any type of guidelines

00:01:50,100 --> 00:01:53,729
you have so they're just impossible

00:01:52,320 --> 00:01:55,229
without the tools because you will

00:01:53,729 --> 00:01:57,180
completely forgot about all the

00:01:55,229 --> 00:02:00,149
guidelines when you have a project with

00:01:57,180 --> 00:02:02,700
a deadline back yesterday and like 50

00:02:00,149 --> 00:02:04,740
people working on a project and whatever

00:02:02,700 --> 00:02:09,690
it is also that but anyways happen your

00:02:04,740 --> 00:02:11,640
project so language they need tools for

00:02:09,690 --> 00:02:14,340
pushing this kind of guidelines and

00:02:11,640 --> 00:02:16,110
good practices and actually for wide

00:02:14,340 --> 00:02:18,750
adoption of the new language features

00:02:16,110 --> 00:02:20,819
because like if the tool is throwing it

00:02:18,750 --> 00:02:23,130
into your face like how to modernize it

00:02:20,819 --> 00:02:24,600
killed you're more likely using more

00:02:23,130 --> 00:02:27,569
than language features then just without

00:02:24,600 --> 00:02:29,990
that but how about the other side how

00:02:27,569 --> 00:02:32,670
the language can help stools do better

00:02:29,990 --> 00:02:34,650
chem tools benefit from the new language

00:02:32,670 --> 00:02:37,620
features or there any issues with that

00:02:34,650 --> 00:02:38,850
so how this relationship revolves this

00:02:37,620 --> 00:02:42,150
is what we are going to talk here about

00:02:38,850 --> 00:02:45,330
this kind of relationship so before that

00:02:42,150 --> 00:02:47,880
let's see how our symbols plus reality

00:02:45,330 --> 00:02:50,850
actually looks like and how we cope and

00:02:47,880 --> 00:02:53,130
how will leave in all this stuff so

00:02:50,850 --> 00:02:55,350
talking about the ID expectation when I

00:02:53,130 --> 00:02:57,810
ask people what they expect from the IDE

00:02:55,350 --> 00:03:00,300
usually they start the word correctness

00:02:57,810 --> 00:03:02,430
like we expect 100 correctness from the

00:03:00,300 --> 00:03:04,800
tool so that you can cope with any

00:03:02,430 --> 00:03:07,769
syphilis +4 right and you're perfect for

00:03:04,800 --> 00:03:10,470
that that's good but then we come with

00:03:07,769 --> 00:03:13,500
the performance so they wanted to work

00:03:10,470 --> 00:03:15,239
quickly on the fly and then they think

00:03:13,500 --> 00:03:17,180
about some kind of a smartness so they

00:03:15,239 --> 00:03:20,130
would like to have some fancy

00:03:17,180 --> 00:03:23,070
highlighting Oracle completion that is

00:03:20,130 --> 00:03:25,140
working like immediately they also want

00:03:23,070 --> 00:03:27,450
the tool to know about the whole project

00:03:25,140 --> 00:03:29,910
like to refracture the whole project

00:03:27,450 --> 00:03:31,950
that's one translation you need or do

00:03:29,910 --> 00:03:34,829
whatever study needs how to find usages

00:03:31,950 --> 00:03:36,750
across the whole project and they want

00:03:34,829 --> 00:03:38,640
it to be how full that means that ID

00:03:36,750 --> 00:03:39,299
actually has to cope with the incorrect

00:03:38,640 --> 00:03:46,739
cute

00:03:39,299 --> 00:03:49,019
so the like the level of the errors that

00:03:46,739 --> 00:03:50,820
the ID can code differs from compiler

00:03:49,019 --> 00:03:53,700
completely so the compiler just stops

00:03:50,820 --> 00:03:57,120
the ID couldn't stop it has to deal

00:03:53,700 --> 00:03:59,489
further and the people actually they're

00:03:57,120 --> 00:04:01,829
expected although like the tools that

00:03:59,489 --> 00:04:03,600
have just exist in the world to be built

00:04:01,829 --> 00:04:06,540
into their IDE

00:04:03,600 --> 00:04:09,989
some of the tools they work with the est

00:04:06,540 --> 00:04:12,570
some not but any kind of tools like that

00:04:09,989 --> 00:04:14,459
you haven't bored believe me or not the

00:04:12,570 --> 00:04:15,450
people will be blaming the IDE you the

00:04:14,459 --> 00:04:19,470
tools are not working

00:04:15,450 --> 00:04:21,120
that's just our reality but okay let's

00:04:19,470 --> 00:04:23,070
just leave the whole list that just

00:04:21,120 --> 00:04:24,790
takes it first to correctness and

00:04:23,070 --> 00:04:27,250
performance

00:04:24,790 --> 00:04:29,920
and actually for Sybil's class

00:04:27,250 --> 00:04:32,650
especially this is some kind of balance

00:04:29,920 --> 00:04:34,780
question so you have to provide the

00:04:32,650 --> 00:04:37,450
correct tool but still you have to be

00:04:34,780 --> 00:04:39,610
quick and each time with each problem

00:04:37,450 --> 00:04:41,110
you have to think about this balance and

00:04:39,610 --> 00:04:44,250
I'll come back to this balance and a

00:04:41,110 --> 00:04:47,710
couple of slides back and you'll see why

00:04:44,250 --> 00:04:49,870
so as I said idea works with any killed

00:04:47,710 --> 00:04:52,320
so it could be like this he killed it is

00:04:49,870 --> 00:04:55,180
back in many years and it's quite old

00:04:52,320 --> 00:04:57,430
mmm no one rides the Cure that way and

00:04:55,180 --> 00:04:59,050
it could be more than standards and the

00:04:57,430 --> 00:05:01,540
people are actually asking for new

00:04:59,050 --> 00:05:04,450
features before they even arrive the

00:05:01,540 --> 00:05:06,520
kind of Sybil's standard or even

00:05:04,450 --> 00:05:08,500
technical specification they just come

00:05:06,520 --> 00:05:11,800
in and say hey I need this feature right

00:05:08,500 --> 00:05:14,440
now and sometimes these things coexist

00:05:11,800 --> 00:05:16,470
so they have some legacy project and

00:05:14,440 --> 00:05:18,820
they want to use some new features and

00:05:16,470 --> 00:05:22,360
think about the incorrect code that I

00:05:18,820 --> 00:05:24,910
already mentioned like the Aurora cover

00:05:22,360 --> 00:05:29,410
level that is completely different from

00:05:24,910 --> 00:05:32,160
what we have compilers in the beginning

00:05:29,410 --> 00:05:34,420
of this year we made a big research on

00:05:32,160 --> 00:05:37,720
suppose suppose developers not only our

00:05:34,420 --> 00:05:42,610
users it was quite expensive so in total

00:05:37,720 --> 00:05:45,360
we got nine thousand responses and there

00:05:42,610 --> 00:05:47,770
here we have two graphs the big one is

00:05:45,360 --> 00:05:49,780
which standard of the people I using so

00:05:47,770 --> 00:05:53,100
that not exclusive so the total is

00:05:49,780 --> 00:05:56,800
bigger than 100 don't be surprised and

00:05:53,100 --> 00:06:00,370
this round one is if you're gonna move

00:05:56,800 --> 00:06:02,350
to new standard and you see like half of

00:06:00,370 --> 00:06:04,930
the respondents are not gonna move to a

00:06:02,350 --> 00:06:07,260
new standard at all and you see that the

00:06:04,930 --> 00:06:10,240
biggest part is actually using C++ 11

00:06:07,260 --> 00:06:11,920
but I required a big part of people who

00:06:10,240 --> 00:06:15,240
are actually gonna move to suppose

00:06:11,920 --> 00:06:18,250
fountain that's huge that's really great

00:06:15,240 --> 00:06:20,050
but that shows the difference that shows

00:06:18,250 --> 00:06:22,330
the variety so there is no like

00:06:20,050 --> 00:06:26,530
something on a trend so the people

00:06:22,330 --> 00:06:28,420
select different things and I would like

00:06:26,530 --> 00:06:32,410
to place some kind of a game here with

00:06:28,420 --> 00:06:34,390
you so I call it are they different so I

00:06:32,410 --> 00:06:36,600
will be actually showing you some pieces

00:06:34,390 --> 00:06:39,120
of code with a very similar lines

00:06:36,600 --> 00:06:41,870
and you have to decide if the slides are

00:06:39,120 --> 00:06:44,310
different not so here is the for example

00:06:41,870 --> 00:06:46,530
there were actually two lights in the

00:06:44,310 --> 00:06:50,340
end of the test function one with K and

00:06:46,530 --> 00:06:52,320
1 with owl they look very similar but

00:06:50,340 --> 00:06:59,760
the question is are they different I

00:06:52,320 --> 00:07:04,890
will give you some seconds to think hey

00:06:59,760 --> 00:07:07,200
I see about smiling yeah so actually are

00:07:04,890 --> 00:07:12,390
different so one is template and one is

00:07:07,200 --> 00:07:22,950
binary expression okay let's plan on the

00:07:12,390 --> 00:07:25,320
round are these lines different and

00:07:22,950 --> 00:07:27,060
actually the answer is yes again so the

00:07:25,320 --> 00:07:29,610
first one is the constructor with

00:07:27,060 --> 00:07:34,230
parameter X and the second is variables

00:07:29,610 --> 00:07:37,170
add house type X okay another example

00:07:34,230 --> 00:07:39,570
another two lines in the end of the test

00:07:37,170 --> 00:07:49,500
function and again the same question are

00:07:39,570 --> 00:07:51,960
they different yeah I hope you got it so

00:07:49,500 --> 00:07:54,030
yes they are different as well and so

00:07:51,960 --> 00:07:58,440
the first one is a caste and the second

00:07:54,030 --> 00:08:01,560
one is an expression and the lamp old

00:07:58,440 --> 00:08:04,350
for this game is actually this one -

00:08:01,560 --> 00:08:07,740
lights we're similar in the beginning

00:08:04,350 --> 00:08:15,750
they have just difference in the end and

00:08:07,740 --> 00:08:18,300
are these lines different and actually

00:08:15,750 --> 00:08:20,460
the answer is also yes because first one

00:08:18,300 --> 00:08:22,640
is the list of declarations and the

00:08:20,460 --> 00:08:25,380
second one is the list of expressions

00:08:22,640 --> 00:08:27,720
and you know what's interesting to get

00:08:25,380 --> 00:08:30,540
it we have to read the line until the

00:08:27,720 --> 00:08:33,930
very end and this could be some kind of

00:08:30,540 --> 00:08:36,450
an infinite input and I'll think about

00:08:33,930 --> 00:08:39,120
the language - you're working with so

00:08:36,450 --> 00:08:41,400
you have an IDE that has to do somehow

00:08:39,120 --> 00:08:43,289
with you killed and it has to make the

00:08:41,400 --> 00:08:45,300
difference in this kind of situation to

00:08:43,289 --> 00:08:47,980
make the highlighting different to make

00:08:45,300 --> 00:08:50,019
the code formatting different

00:08:47,980 --> 00:08:55,120
provide some different intellisense for

00:08:50,019 --> 00:08:57,279
you and in each place or this like some

00:08:55,120 --> 00:08:59,470
curve like this it has to distinguish

00:08:57,279 --> 00:09:01,120
types from non types and that's the

00:08:59,470 --> 00:09:03,130
magic question for simplest class and

00:09:01,120 --> 00:09:05,829
for language tools working with siblings

00:09:03,130 --> 00:09:09,070
plus that's actually the Biggers

00:09:05,829 --> 00:09:11,470
challenge so we have to distinguish

00:09:09,070 --> 00:09:15,850
types from non types and we need it

00:09:11,470 --> 00:09:18,600
everywhere and to do that we actually

00:09:15,850 --> 00:09:23,070
need to parse and resolve the code

00:09:18,600 --> 00:09:23,070
because without that that's impossible

00:09:23,160 --> 00:09:27,639
let's think about what affects the

00:09:25,240 --> 00:09:31,029
resolve so there are some simple things

00:09:27,639 --> 00:09:34,930
like what are the definitions that is

00:09:31,029 --> 00:09:37,360
simple default arguments so you have to

00:09:34,930 --> 00:09:39,550
check all the signatures to see what are

00:09:37,360 --> 00:09:42,850
the default arguments and if it fits a

00:09:39,550 --> 00:09:46,240
Nadia case and of course the overload

00:09:42,850 --> 00:09:49,870
resolution all the things are in general

00:09:46,240 --> 00:09:52,779
quite easy but still the language tool

00:09:49,870 --> 00:09:56,350
has to do with that has to do that has

00:09:52,779 --> 00:09:57,970
to understand all this code and actually

00:09:56,350 --> 00:10:00,339
this kid could be spread around the

00:09:57,970 --> 00:10:05,860
whole your projects with it should not

00:10:00,339 --> 00:10:09,339
be just one file okay so the language

00:10:05,860 --> 00:10:12,279
tool has to parse and result it killed

00:10:09,339 --> 00:10:15,399
what does it need it for actually for

00:10:12,279 --> 00:10:17,829
everything so not just for some smart

00:10:15,399 --> 00:10:20,769
refactoring ACOTA logic but for the

00:10:17,829 --> 00:10:22,600
simple things like just formatted code

00:10:20,769 --> 00:10:26,079
properly or highlight here killed

00:10:22,600 --> 00:10:28,180
properly and there is a very like easy

00:10:26,079 --> 00:10:33,130
things like highlighting could we

00:10:28,180 --> 00:10:36,430
highlight with the lecture in C++ like

00:10:33,130 --> 00:10:41,079
this code could not be compiled properly

00:10:36,430 --> 00:10:44,560
with all civil fast version because it

00:10:41,079 --> 00:10:49,329
required a space between the last two

00:10:44,560 --> 00:10:51,850
angles in the life like this fine like

00:10:49,329 --> 00:10:53,529
and this is all about the C++ like in

00:10:51,850 --> 00:10:55,360
symbols past eleven there is a

00:10:53,529 --> 00:10:57,220
description in the standard how you

00:10:55,360 --> 00:10:59,769
should deal with that and you can like

00:10:57,220 --> 00:11:00,950
leave without a space now and because

00:10:59,769 --> 00:11:02,990
the parser will just

00:11:00,950 --> 00:11:05,660
yet if it's tablet or not and there is a

00:11:02,990 --> 00:11:10,670
rule actually doing an actual resolve

00:11:05,660 --> 00:11:12,740
inside the standard description and to

00:11:10,670 --> 00:11:14,990
be honest that's the only language I

00:11:12,740 --> 00:11:19,630
know that has these big problems coming

00:11:14,990 --> 00:11:19,630
out of there we actually see examples

00:11:19,750 --> 00:11:24,080
another example about highlighting with

00:11:22,100 --> 00:11:28,330
relaxer like a very simple could I

00:11:24,080 --> 00:11:32,750
highlight just keywords with relaxer and

00:11:28,330 --> 00:11:35,480
the answer again is not because here if

00:11:32,750 --> 00:11:38,510
I highlight public that won't be corrupt

00:11:35,480 --> 00:11:40,490
because they have a macro and actually

00:11:38,510 --> 00:11:43,610
this is a variable called public public

00:11:40,490 --> 00:11:51,800
here so it's not correct just to use the

00:11:43,610 --> 00:11:55,070
lecture for highlighting so how would

00:11:51,800 --> 00:11:57,320
you actually there is some kind of a

00:11:55,070 --> 00:11:59,840
game of parsers happening I you know

00:11:57,320 --> 00:12:03,110
language toasting all IDs so there are

00:11:59,840 --> 00:12:05,510
different ways like tools they have

00:12:03,110 --> 00:12:09,020
heuristics they have some fuzzy parsers

00:12:05,510 --> 00:12:12,110
they have like using several parsers at

00:12:09,020 --> 00:12:14,300
the time and they are trying to be based

00:12:12,110 --> 00:12:18,230
on Clank and whatever ways there are

00:12:14,300 --> 00:12:21,950
many things happening so IDs learn to be

00:12:18,230 --> 00:12:24,470
smart with C++ like and to find some

00:12:21,950 --> 00:12:26,810
kind of a balance between again Caracas

00:12:24,470 --> 00:12:29,840
it's a performance for example it would

00:12:26,810 --> 00:12:31,970
take the clang format tool it's very

00:12:29,840 --> 00:12:33,500
nice and quick tool for formatting but

00:12:31,970 --> 00:12:35,870
no do know that it's not using a

00:12:33,500 --> 00:12:38,120
complete parser it's using some kind of

00:12:35,870 --> 00:12:40,070
a fuzzy parser so it's not looking into

00:12:38,120 --> 00:12:41,840
the header files it's not like

00:12:40,070 --> 00:12:44,030
personally care properly just because

00:12:41,840 --> 00:12:45,980
it's for another task it's for quickly

00:12:44,030 --> 00:12:49,640
formatting your code but it could be

00:12:45,980 --> 00:12:53,720
confused in case of C++ because things

00:12:49,640 --> 00:12:55,850
have like IDs they are doing a lot of

00:12:53,720 --> 00:12:59,660
stuff here so I'm not I'm talking very

00:12:55,850 --> 00:13:02,420
detailed about these ways but like there

00:12:59,660 --> 00:13:04,580
are a lot of things happening in the way

00:13:02,420 --> 00:13:06,620
of optimizing the parser so it different

00:13:04,580 --> 00:13:10,250
from the typical parser that the

00:13:06,620 --> 00:13:12,290
compiler is actually using like the

00:13:10,250 --> 00:13:14,200
compiler usually resolve the name

00:13:12,290 --> 00:13:16,720
immediately when it meets

00:13:14,200 --> 00:13:18,820
could sometimes postpone and it really

00:13:16,720 --> 00:13:23,680
helps like to say the time to increase

00:13:18,820 --> 00:13:25,570
the performance like IDs they like the

00:13:23,680 --> 00:13:27,820
global includes because these asking

00:13:25,570 --> 00:13:30,130
kind of the same heaters same era files

00:13:27,820 --> 00:13:33,520
included into each translation unit so

00:13:30,130 --> 00:13:35,620
they can cash and that's good until you

00:13:33,520 --> 00:13:40,720
write some kind of her define before you

00:13:35,620 --> 00:13:42,490
global include local repairs is also a

00:13:40,720 --> 00:13:45,090
good thing when you could save on

00:13:42,490 --> 00:13:48,640
performance because you can for example

00:13:45,090 --> 00:13:51,220
skip the whole function body and just

00:13:48,640 --> 00:13:53,710
parse the function signature until you

00:13:51,220 --> 00:13:56,380
use the auto return type because in that

00:13:53,710 --> 00:13:58,150
case you have to parse the function body

00:13:56,380 --> 00:14:01,680
to understand actually what's going back

00:13:58,150 --> 00:14:01,680
from this function what's returned back

00:14:02,100 --> 00:14:07,960
so there are many tricky ways and who

00:14:06,370 --> 00:14:11,410
doesn't understand and let's now look at

00:14:07,960 --> 00:14:14,320
the actual features that are coming from

00:14:11,410 --> 00:14:17,790
the new standards this is the some kind

00:14:14,320 --> 00:14:20,530
of place that I'm gonna work for for now

00:14:17,790 --> 00:14:25,830
let's start with if Const expert that

00:14:20,530 --> 00:14:28,570
will already have so this is the example

00:14:25,830 --> 00:14:31,480
let it Sullivan a pretty easy task like

00:14:28,570 --> 00:14:34,330
get value depending on either its

00:14:31,480 --> 00:14:38,500
pointer or not and here's the

00:14:34,330 --> 00:14:41,470
implementation using enable if that's

00:14:38,500 --> 00:14:45,400
quite like nice and maybe something

00:14:41,470 --> 00:14:48,190
first coming into her mind but now let's

00:14:45,400 --> 00:14:52,570
look from the point of a tool if we

00:14:48,190 --> 00:14:55,660
manage to find get value call somewhere

00:14:52,570 --> 00:15:00,130
and we try to find out what what is that

00:14:55,660 --> 00:15:02,920
actually we have to look and compare

00:15:00,130 --> 00:15:05,410
because actually there is it first or is

00:15:02,920 --> 00:15:08,200
the second one so we have to calculate

00:15:05,410 --> 00:15:11,670
this enable if and we have to understand

00:15:08,200 --> 00:15:17,020
what's what what exactly is the function

00:15:11,670 --> 00:15:18,940
is there a better way actually T's so I

00:15:17,020 --> 00:15:21,040
could really write this nice function

00:15:18,940 --> 00:15:23,620
with if Const expert and just hide

00:15:21,040 --> 00:15:25,660
everything inside and that's actually a

00:15:23,620 --> 00:15:27,340
good thing because I'm hiding

00:15:25,660 --> 00:15:30,970
the implementation details actually

00:15:27,340 --> 00:15:33,850
inside the function and not the idea has

00:15:30,970 --> 00:15:35,950
just one function it has outer adjourn

00:15:33,850 --> 00:15:39,010
type which his head is not very nice but

00:15:35,950 --> 00:15:42,370
so it's like one function so if you just

00:15:39,010 --> 00:15:44,740
find usages you just go and look all of

00:15:42,370 --> 00:15:49,300
them and you just don't find what's

00:15:44,740 --> 00:15:52,540
inside until you really have to okay

00:15:49,300 --> 00:15:55,480
this is about of concepts per now let's

00:15:52,540 --> 00:15:57,820
talk about the concept actually concepts

00:15:55,480 --> 00:16:00,720
is a very good thing from the point of

00:15:57,820 --> 00:16:04,330
language tool from some to some extent

00:16:00,720 --> 00:16:05,980
because it's like a template with the

00:16:04,330 --> 00:16:08,890
proper interface because what is

00:16:05,980 --> 00:16:12,490
templates from the language tool it just

00:16:08,890 --> 00:16:14,860
said text it has nothing before it was

00:16:12,490 --> 00:16:18,400
used so to understand what's there in

00:16:14,860 --> 00:16:20,080
the template the language tool the IDE

00:16:18,400 --> 00:16:21,820
has to find the user ships has to

00:16:20,080 --> 00:16:26,350
understand how the template is

00:16:21,820 --> 00:16:28,780
accentuated how it's used but if we have

00:16:26,350 --> 00:16:31,150
a concept then we could make some

00:16:28,780 --> 00:16:34,690
decisions based on this concept we could

00:16:31,150 --> 00:16:37,900
cache some information and later we

00:16:34,690 --> 00:16:39,880
could check if like it's fitting the

00:16:37,900 --> 00:16:43,990
concept or not with this kind of cache

00:16:39,880 --> 00:16:47,710
information and we could even do more we

00:16:43,990 --> 00:16:50,380
could suggest some completion for

00:16:47,710 --> 00:16:52,900
example if the concepts is saying that

00:16:50,380 --> 00:16:55,030
there is some kind of function exists in

00:16:52,900 --> 00:16:57,310
the air so we could for example complete

00:16:55,030 --> 00:16:58,390
we could make some checks we could

00:16:57,310 --> 00:17:00,640
provide some additional information

00:16:58,390 --> 00:17:02,560
about this text and so you while you're

00:17:00,640 --> 00:17:04,750
writing this template you could benefit

00:17:02,560 --> 00:17:09,850
from some intelligence that is better

00:17:04,750 --> 00:17:11,710
than just simple text and actually like

00:17:09,850 --> 00:17:14,350
talking about the cache when I said that

00:17:11,710 --> 00:17:16,420
we could try and catch some information

00:17:14,350 --> 00:17:18,430
that means that we could do some

00:17:16,420 --> 00:17:20,470
performance improvements on the stage of

00:17:18,430 --> 00:17:24,130
check and if something complies this

00:17:20,470 --> 00:17:28,660
concept okay

00:17:24,130 --> 00:17:31,330
now includes like what is includes in

00:17:28,660 --> 00:17:35,020
C++ just the text includes text

00:17:31,330 --> 00:17:38,980
substitution that's really bad if you

00:17:35,020 --> 00:17:42,930
look at this example under writers right

00:17:38,980 --> 00:17:45,220
and you just get that this line with ax

00:17:42,930 --> 00:17:47,440
from the sample from the game

00:17:45,220 --> 00:17:50,350
it actually has different meaning

00:17:47,440 --> 00:17:53,730
depending on what magic is because it

00:17:50,350 --> 00:17:56,740
different like it's either type or

00:17:53,730 --> 00:17:59,920
x-axis just an integer and it depends on

00:17:56,740 --> 00:18:02,350
this magic and so if you have like this

00:17:59,920 --> 00:18:04,630
header file if you parse it you get all

00:18:02,350 --> 00:18:07,480
information to understand what's really

00:18:04,630 --> 00:18:09,970
in your code you have to find out what

00:18:07,480 --> 00:18:12,070
this magic is and if someone is changing

00:18:09,970 --> 00:18:14,050
it you have to parse the whole thing and

00:18:12,070 --> 00:18:17,290
change all the information in your code

00:18:14,050 --> 00:18:20,260
and it's just insane for the tools so

00:18:17,290 --> 00:18:22,930
when you have lots of header files built

00:18:20,260 --> 00:18:25,030
like that don't be surprised that you

00:18:22,930 --> 00:18:27,640
see that your tool is going mad because

00:18:25,030 --> 00:18:32,950
it's trying to reverse the thing all the

00:18:27,640 --> 00:18:35,940
time like you see that the problem here

00:18:32,950 --> 00:18:39,460
is that actually the information is

00:18:35,940 --> 00:18:41,320
affected by this kind of context and it

00:18:39,460 --> 00:18:43,840
takes most of the time for the language

00:18:41,320 --> 00:18:46,300
tool to understand what's inside to

00:18:43,840 --> 00:18:48,790
parse to take information from this

00:18:46,300 --> 00:18:50,080
header files and these headers they

00:18:48,790 --> 00:18:52,780
could be included in different

00:18:50,080 --> 00:18:54,640
translation units with different context

00:18:52,780 --> 00:18:57,700
and then you have to store all

00:18:54,640 --> 00:19:04,570
information again and again with using

00:18:57,700 --> 00:19:06,940
this context and the one story is that

00:19:04,570 --> 00:19:09,100
one that's global include and another

00:19:06,940 --> 00:19:11,080
story is completely one this is kind of

00:19:09,100 --> 00:19:13,270
local include somewhere inside your

00:19:11,080 --> 00:19:16,450
simplest function somewhere in the

00:19:13,270 --> 00:19:18,700
beginning or somewhere in the middle so

00:19:16,450 --> 00:19:20,500
this and they're also like you formed

00:19:18,700 --> 00:19:25,210
includes that makes the whole story even

00:19:20,500 --> 00:19:28,420
worse what is better model is of course

00:19:25,210 --> 00:19:31,180
like because this is the thing very

00:19:28,420 --> 00:19:33,400
similar to what we for example have in

00:19:31,180 --> 00:19:36,910
Java we have inverts but a very clear

00:19:33,400 --> 00:19:39,940
interface defined and if we know what's

00:19:36,910 --> 00:19:41,410
inside that's actually great because we

00:19:39,940 --> 00:19:44,320
could gasps that there should be this

00:19:41,410 --> 00:19:46,210
kind of functions and we could complete

00:19:44,320 --> 00:19:48,250
them and we could say no if you're

00:19:46,210 --> 00:19:49,930
making a mistake in the function forget

00:19:48,250 --> 00:19:50,760
like highlight in red and sand now it's

00:19:49,930 --> 00:19:54,390
not from this

00:19:50,760 --> 00:19:57,919
from this model so and models are

00:19:54,390 --> 00:20:03,770
hopefully her last context-dependent and

00:19:57,919 --> 00:20:06,090
if we think about yesterday too

00:20:03,770 --> 00:20:08,700
like when Alistair was talking about

00:20:06,090 --> 00:20:11,070
yesterday - I suppose plus now I was

00:20:08,700 --> 00:20:12,390
very glad to hear that he was talking

00:20:11,070 --> 00:20:15,410
about this kind of direction with

00:20:12,390 --> 00:20:18,720
concept and model Sonesta T - because

00:20:15,410 --> 00:20:21,960
what for example we do in our tools for

00:20:18,720 --> 00:20:24,059
acid elaborate now we do some hacks we

00:20:21,960 --> 00:20:26,850
try to guess what's inside this standard

00:20:24,059 --> 00:20:29,190
library for this architecture cache this

00:20:26,850 --> 00:20:31,290
information and use it but that's not

00:20:29,190 --> 00:20:34,110
legal because that's just text include

00:20:31,290 --> 00:20:37,620
but if it's a model this has become more

00:20:34,110 --> 00:20:40,500
official so it do it like in a true and

00:20:37,620 --> 00:20:44,700
natural way and this actually optimizes

00:20:40,500 --> 00:20:47,100
the work and make your actually a word

00:20:44,700 --> 00:20:50,130
with the code easier because like you

00:20:47,100 --> 00:20:56,669
have you already helping you struggling

00:20:50,130 --> 00:20:59,429
with your texting now let's talk a

00:20:56,669 --> 00:21:03,120
little bit about contracts I won't be

00:20:59,429 --> 00:21:05,940
talking about them a lot but I would

00:21:03,120 --> 00:21:09,990
like just to show the possibility that

00:21:05,940 --> 00:21:12,690
it could be bringing to the language

00:21:09,990 --> 00:21:15,390
tools because like what the contracts

00:21:12,690 --> 00:21:18,030
are they're just the runtime checks but

00:21:15,390 --> 00:21:20,700
what if you're took check them before

00:21:18,030 --> 00:21:23,190
you run the application that's actually

00:21:20,700 --> 00:21:25,440
possible you just need to do the data

00:21:23,190 --> 00:21:27,480
flow analysis and to include these

00:21:25,440 --> 00:21:29,610
conditions into these analysis and

00:21:27,480 --> 00:21:34,410
hopefully they could be checked to some

00:21:29,610 --> 00:21:36,929
extent like that's doable so we did data

00:21:34,410 --> 00:21:38,340
flow analysis in sea lions who and we

00:21:36,929 --> 00:21:40,470
know that actually some of these

00:21:38,340 --> 00:21:42,690
conditions could be checked as well so

00:21:40,470 --> 00:21:45,419
the conference if you think about them

00:21:42,690 --> 00:21:51,960
like just a runtime conditions that's

00:21:45,419 --> 00:21:54,809
good but maybe we could do more now

00:21:51,960 --> 00:21:57,020
let's talk about reflection there are

00:21:54,809 --> 00:22:00,630
actually two parts of reflection

00:21:57,020 --> 00:22:01,910
introspection and care generation if we

00:22:00,630 --> 00:22:04,640
take the introspection

00:22:01,910 --> 00:22:07,730
it's just the ability to inspect a type

00:22:04,640 --> 00:22:11,060
and retrieve various qualities from the

00:22:07,730 --> 00:22:14,330
type so you might want to introspect

00:22:11,060 --> 00:22:16,160
like object dealer members a member

00:22:14,330 --> 00:22:20,350
function some inheritance hierarchy

00:22:16,160 --> 00:22:23,180
whatever and the good thing is that

00:22:20,350 --> 00:22:25,310
tools language so since the parts decode

00:22:23,180 --> 00:22:28,130
we have all the information for your

00:22:25,310 --> 00:22:31,670
introspection so they can provide it to

00:22:28,130 --> 00:22:36,170
use it is not an issue and it could be

00:22:31,670 --> 00:22:38,630
quick and that's actually good but if we

00:22:36,170 --> 00:22:41,770
talk about reflection we should talk

00:22:38,630 --> 00:22:45,620
also about the car generation and

00:22:41,770 --> 00:22:47,630
generation card is it's actually a big

00:22:45,620 --> 00:22:53,390
and huge opportunity that you could get

00:22:47,630 --> 00:22:55,100
into your code and like I will switch to

00:22:53,390 --> 00:22:59,030
this slide with matter class is talking

00:22:55,100 --> 00:23:04,100
about K generation you know flexion

00:22:59,030 --> 00:23:05,870
because mana clause is actually a great

00:23:04,100 --> 00:23:08,690
thing from the developer point of view

00:23:05,870 --> 00:23:11,750
it helps us to avoid boilerplate killed

00:23:08,690 --> 00:23:15,200
and these herps proposal actually is

00:23:11,750 --> 00:23:19,340
intended to help us to follow some

00:23:15,200 --> 00:23:22,310
constraints to get some this all without

00:23:19,340 --> 00:23:25,610
an actual without an another compiler

00:23:22,310 --> 00:23:28,400
different from suppose path compiler but

00:23:25,610 --> 00:23:30,890
for the language tool it means that it

00:23:28,400 --> 00:23:33,650
has to generate all these kills this is

00:23:30,890 --> 00:23:36,290
the sample from herbs proposal that's

00:23:33,650 --> 00:23:39,770
very simple for you just write this

00:23:36,290 --> 00:23:42,980
small shape code in the top right corner

00:23:39,770 --> 00:23:46,580
and you have this kind of her manner

00:23:42,980 --> 00:23:48,980
classes interface definition so we're

00:23:46,580 --> 00:23:52,040
hopefully in some standard library for

00:23:48,980 --> 00:23:53,690
mattock losses and you just get this

00:23:52,040 --> 00:23:56,810
kind of shape with some information

00:23:53,690 --> 00:23:59,390
generated out of it and it could be much

00:23:56,810 --> 00:24:04,640
more so you can generate a long list of

00:23:59,390 --> 00:24:06,410
functions the other stuff there but the

00:24:04,640 --> 00:24:09,290
thing is that from the point of view of

00:24:06,410 --> 00:24:11,390
the language tool you has to generate

00:24:09,290 --> 00:24:13,929
this code and you can't postpone it

00:24:11,390 --> 00:24:16,210
because you'll start using this kind

00:24:13,929 --> 00:24:19,899
shapes trucks this kind of a shape

00:24:16,210 --> 00:24:22,360
interface over there and you'll need all

00:24:19,899 --> 00:24:25,619
these functions to be completed you have

00:24:22,360 --> 00:24:27,940
your ID to check these constraints that

00:24:25,619 --> 00:24:29,950
you don't it now you have only these

00:24:27,940 --> 00:24:32,259
functions don't have any other functions

00:24:29,950 --> 00:24:35,320
so this is something that we can't

00:24:32,259 --> 00:24:37,299
postpone and we have to do and this is

00:24:35,320 --> 00:24:41,789
some kind of her single pass interpreter

00:24:37,299 --> 00:24:44,499
that's happening inside your which tool

00:24:41,789 --> 00:24:47,320
there could be like some ways to cheat

00:24:44,499 --> 00:24:49,570
so we could just allow everything and

00:24:47,320 --> 00:24:52,269
like say like do whatever you want

00:24:49,570 --> 00:24:54,759
until you compile it well we could just

00:24:52,269 --> 00:24:56,559
treat everything as text but that's not

00:24:54,759 --> 00:24:59,379
a good way because it doesn't help you

00:24:56,559 --> 00:25:02,440
in any way the better way is not indeed

00:24:59,379 --> 00:25:04,539
to check these kind of conditions and to

00:25:02,440 --> 00:25:07,389
parse or this all the definitions and

00:25:04,539 --> 00:25:09,429
probably if we parse the matter class

00:25:07,389 --> 00:25:12,190
definitions we could even provide some

00:25:09,429 --> 00:25:14,529
in thousands insight inside this matter

00:25:12,190 --> 00:25:18,100
class of definitions so not to treat

00:25:14,529 --> 00:25:20,860
them as text like not to treat this

00:25:18,100 --> 00:25:22,539
piece on left just as text but to

00:25:20,860 --> 00:25:23,679
provide some highlighting and completion

00:25:22,539 --> 00:25:27,940
there that would be awesome

00:25:23,679 --> 00:25:36,700
but that needs always code to be parsed

00:25:27,940 --> 00:25:38,499
and that's really tough like that's the

00:25:36,700 --> 00:25:44,830
story about the reflection care

00:25:38,499 --> 00:25:47,070
generation and matter classes and also I

00:25:44,830 --> 00:25:53,259
would like to talk here about the

00:25:47,070 --> 00:25:56,350
modernized tools so we have them coming

00:25:53,259 --> 00:25:59,980
more or less so we have the civil score

00:25:56,350 --> 00:26:02,710
guidelines we have support native

00:25:59,980 --> 00:26:05,759
support for coordinate lines in visual

00:26:02,710 --> 00:26:08,230
studio and some guidelines supported in

00:26:05,759 --> 00:26:10,960
hospital of tool and the clonked ID

00:26:08,230 --> 00:26:13,749
that's a very powerful clonk family

00:26:10,960 --> 00:26:16,960
based tool that provides a lot of

00:26:13,749 --> 00:26:20,289
modernized features and it's actually

00:26:16,960 --> 00:26:24,609
helping to transform you coded form

00:26:20,289 --> 00:26:26,640
waterway so and

00:26:24,609 --> 00:26:29,490
I just want to

00:26:26,640 --> 00:26:32,540
and to show those who never saw how the

00:26:29,490 --> 00:26:35,100
clunks ID works just a small example of

00:26:32,540 --> 00:26:38,100
integration that we have climbed and

00:26:35,100 --> 00:26:40,530
they're just running the whole client ID

00:26:38,100 --> 00:26:44,520
bunch of stuff with some other nice

00:26:40,530 --> 00:26:46,980
checks on the code so it actually finds

00:26:44,520 --> 00:26:49,320
the issues and fix it so you can just

00:26:46,980 --> 00:26:52,200
run it with - fixed option and it will

00:26:49,320 --> 00:26:54,480
update your kilt and that means that it

00:26:52,200 --> 00:26:57,030
could bring you care from the like whole

00:26:54,480 --> 00:27:00,600
legacy stage so the more more than

00:26:57,030 --> 00:27:02,880
killed that is maybe easier and for your

00:27:00,600 --> 00:27:07,679
language tool and the language tool can

00:27:02,880 --> 00:27:09,780
help better with it so if you would like

00:27:07,679 --> 00:27:11,640
to see more about the tools I will

00:27:09,780 --> 00:27:14,700
actually be doing another talk about the

00:27:11,640 --> 00:27:18,480
tools tomorrow so showing you like a

00:27:14,700 --> 00:27:21,750
lots of a bunch of that stuff but for

00:27:18,480 --> 00:27:25,260
now I get actually that's it I guess it

00:27:21,750 --> 00:27:28,140
was quite but there are some useful

00:27:25,260 --> 00:27:30,290
reference is here if you're interested

00:27:28,140 --> 00:27:34,230
in some more details of what I was

00:27:30,290 --> 00:27:36,690
talking here actually the last one is

00:27:34,230 --> 00:27:39,240
exactly about some optimization

00:27:36,690 --> 00:27:42,360
happening in language tools Inc a person

00:27:39,240 --> 00:27:44,700
to compiler the talk on lvl meeting was

00:27:42,360 --> 00:27:47,100
quite short but there is a slide from

00:27:44,700 --> 00:27:50,520
the long talk that was happening it my

00:27:47,100 --> 00:27:53,250
user group so I know we have lots of

00:27:50,520 --> 00:28:08,040
precious time for questions so I'm ready

00:27:53,250 --> 00:28:10,290
to answer whatever you have yeah sir I

00:28:08,040 --> 00:28:13,799
guess they will be published somewhere

00:28:10,290 --> 00:28:16,160
at least they organizes arsons to store

00:28:13,799 --> 00:28:18,840
the slides

00:28:16,160 --> 00:28:21,419
yeah so I guess somewhere under the each

00:28:18,840 --> 00:28:30,590
video will be think so I guess you'll

00:28:21,419 --> 00:28:30,590
find all questions

00:28:30,760 --> 00:28:43,790
there any changes that you would like

00:28:41,930 --> 00:28:46,010
yeah everything I was talking here is

00:28:43,790 --> 00:28:48,380
the change that we would like to see to

00:28:46,010 --> 00:28:51,260
some expand like maybe the matter clause

00:28:48,380 --> 00:28:52,790
is not our biggest fan are like from the

00:28:51,260 --> 00:28:54,800
developer point they are very

00:28:52,790 --> 00:28:59,000
interesting from the point of language

00:28:54,800 --> 00:29:01,070
till they're tough but anyway like all

00:28:59,000 --> 00:29:04,280
this stuff about models and concept

00:29:01,070 --> 00:29:05,720
seems very interesting and bright very

00:29:04,280 --> 00:29:07,760
interesting abilities like very

00:29:05,720 --> 00:29:09,860
interesting features that could be built

00:29:07,760 --> 00:29:11,720
upon these language features in the

00:29:09,860 --> 00:29:16,060
language tools and this really great

00:29:11,720 --> 00:29:16,060
like there are New Horizons is coming

00:29:18,910 --> 00:29:39,890
yeah we always have to deal with

00:29:38,120 --> 00:29:42,080
incomplete you know it doesn't matter

00:29:39,890 --> 00:29:46,670
like if you have all language features

00:29:42,080 --> 00:29:49,070
or like simple sound but like that's the

00:29:46,670 --> 00:29:51,920
usual thing so we have to deal somehow

00:29:49,070 --> 00:29:54,080
we have to store some things for some

00:29:51,920 --> 00:29:56,420
time to wait until you finish some

00:29:54,080 --> 00:30:00,260
constructs just not to spoil everything

00:29:56,420 --> 00:30:02,690
on your screen but that's the like

00:30:00,260 --> 00:30:06,230
typical thing we try to deal with that

00:30:02,690 --> 00:30:09,320
so at least maybe not like you know blob

00:30:06,230 --> 00:30:12,260
he killed until you type the the end of

00:30:09,320 --> 00:30:15,280
the statement but that's the typical

00:30:12,260 --> 00:30:18,080
rule so he got to it quite quickly so

00:30:15,280 --> 00:30:20,960
nothing no rocket science actually there

00:30:18,080 --> 00:30:23,240
just just the thing that you have to

00:30:20,960 --> 00:30:25,130
keep in mind we're always when you're

00:30:23,240 --> 00:30:27,370
like current implementing this kind of

00:30:25,130 --> 00:30:27,370
stuff

00:30:30,650 --> 00:30:40,460
okay her questions okay you can come

00:30:37,310 --> 00:30:41,750
later to me or to the booth and I can

00:30:40,460 --> 00:30:45,210
answer more if you have some more

00:30:41,750 --> 00:30:49,619
questions in mind thank you

00:30:45,210 --> 00:30:49,619

YouTube URL: https://www.youtube.com/watch?v=cBpPxantld8


