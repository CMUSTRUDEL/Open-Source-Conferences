Title: CppCon 2017: Sven Over “folly::Function: A Non-copyable Alternative to std::function”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
We have often found it limiting that std::function cannot store callable objects if they are not copyable, so we developed and open-sourced folly::Function, a function wrapper that can store move-only callable objects. This presentation outlines the design decisions behind folly::Function and illustrates their consequences and our experiences after 18 months of wide production use at Facebook. 

We find folly::Function is more appropriate than std::function for typical use cases, such as storing callback functions and submitting tasks for asynchronous execution. Other features of folly::Function include that it is noexcept-movable, and it avoids some known issues regarding const-correctness in std::function, which allows to invoke non-const operations on a const reference. Instead, folly::Function lets you declare whether a callable may or may not mutate its state (e.g. folly::Function＜void() const＞).
— 
Sven Over: Software Engineer, Facebook

Sven completed a PhD in astro-particle physics before he turned full time software engineer. He worked on C++ data services at Last.fm, and is now at Facebook London.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,060
all right so hello everyone I'm I'm a

00:00:03,449 --> 00:00:07,560
software engineer at Facebook London I'm

00:00:06,060 --> 00:00:09,389
going to talk about fully-functioning a

00:00:07,560 --> 00:00:13,349
non copyable alternative to standard

00:00:09,389 --> 00:00:18,300
function which i started working on a

00:00:13,349 --> 00:00:20,369
you know half ago it's been modified and

00:00:18,300 --> 00:00:22,680
different issues been fixed by some of

00:00:20,369 --> 00:00:25,949
my facebook colleagues as well and

00:00:22,680 --> 00:00:29,279
should be in a pretty good shape now I

00:00:25,949 --> 00:00:30,840
guess most of you being seasoned C++

00:00:29,279 --> 00:00:32,250
developers know what standard function

00:00:30,840 --> 00:00:35,219
have used it before so let me start with

00:00:32,250 --> 00:00:36,809
a tldr for you so far a function is a

00:00:35,219 --> 00:00:40,200
replacement for standard function which

00:00:36,809 --> 00:00:42,840
unlike send function is not copyable so

00:00:40,200 --> 00:00:45,719
to move only type it is no except

00:00:42,840 --> 00:00:48,180
moveable and also unlike cell function

00:00:45,719 --> 00:00:51,329
and enforces correctly cons correctness

00:00:48,180 --> 00:00:53,910
I go more into detail back about that

00:00:51,329 --> 00:00:55,680
obviously later it's as fast or faster

00:00:53,910 --> 00:00:59,070
than standard function in terms of

00:00:55,680 --> 00:01:00,780
execution speeds and also compile speeds

00:00:59,070 --> 00:01:03,210
on the relevant platforms where we

00:01:00,780 --> 00:01:05,610
tested it it's been now in production

00:01:03,210 --> 00:01:06,689
use at Facebook for about 18 months so I

00:01:05,610 --> 00:01:09,060
can tell you a little bit about the

00:01:06,689 --> 00:01:10,170
experiences we've made and if you want

00:01:09,060 --> 00:01:11,520
to have a look at it you can check it

00:01:10,170 --> 00:01:14,189
out it's part of the following year

00:01:11,520 --> 00:01:15,840
fully library which is Facebook's

00:01:14,189 --> 00:01:19,229
there's a new collection of useful

00:01:15,840 --> 00:01:22,310
things that we put together and a

00:01:19,229 --> 00:01:25,740
library which you can get at github

00:01:22,310 --> 00:01:29,100
right in this talk I shall tell you a

00:01:25,740 --> 00:01:31,890
little bit of a theoretical introduction

00:01:29,100 --> 00:01:34,020
going from callable types to function

00:01:31,890 --> 00:01:35,460
repos but then I will tell you

00:01:34,020 --> 00:01:37,530
specifically about the problems that we

00:01:35,460 --> 00:01:39,329
had using standard function which

00:01:37,530 --> 00:01:40,860
obviously led to the design decisions

00:01:39,329 --> 00:01:43,049
for fully function so I tell you about

00:01:40,860 --> 00:01:44,970
that and I will just tell you more about

00:01:43,049 --> 00:01:47,430
like what our experiences war was

00:01:44,970 --> 00:01:49,380
changing from one to the other and

00:01:47,430 --> 00:01:51,799
during like I said the the regular

00:01:49,380 --> 00:01:55,079
production news that we have seen now

00:01:51,799 --> 00:01:57,149
okay so this theoretical introduction

00:01:55,079 --> 00:01:59,340
callable types in C++

00:01:57,149 --> 00:02:02,009
they include function pointers or

00:01:59,340 --> 00:02:04,380
function references obviously lambdas

00:02:02,009 --> 00:02:05,850
and any class was struck that unifying

00:02:04,380 --> 00:02:09,450
yourself if you define an invocation

00:02:05,850 --> 00:02:11,670
operator if you happen to use a lambda

00:02:09,450 --> 00:02:14,820
that doesn't catch capture any data or

00:02:11,670 --> 00:02:16,620
if you define two

00:02:14,820 --> 00:02:19,110
if you happen to define a member

00:02:16,620 --> 00:02:22,590
function of your strength or class

00:02:19,110 --> 00:02:24,360
aesthetic then those can all be cast

00:02:22,590 --> 00:02:26,730
into function pointers and they're

00:02:24,360 --> 00:02:28,650
completely stateless which means they

00:02:26,730 --> 00:02:32,390
essentially just a pointer to the code

00:02:28,650 --> 00:02:34,800
that the compiler generated but often

00:02:32,390 --> 00:02:36,570
you want to pass a little bit of data a

00:02:34,800 --> 00:02:38,700
little bit of context with your callable

00:02:36,570 --> 00:02:41,250
object so that would be in the case of

00:02:38,700 --> 00:02:43,800
lambda when you capture some data and in

00:02:41,250 --> 00:02:44,750
the code block that you define you have

00:02:43,800 --> 00:02:48,210
access to that data

00:02:44,750 --> 00:02:50,190
all in your struct or class when you

00:02:48,210 --> 00:02:52,170
define member functions or the

00:02:50,190 --> 00:02:55,140
invocation operator as soon as it's

00:02:52,170 --> 00:02:57,960
non-static the code in here will have

00:02:55,140 --> 00:03:01,340
access to all the states of this class

00:02:57,960 --> 00:03:05,250
objects you can go one step further and

00:03:01,340 --> 00:03:08,100
define your lambda as mutable or your

00:03:05,250 --> 00:03:12,680
member function as non Const and in that

00:03:08,100 --> 00:03:18,690
case you only have access at the state

00:03:12,680 --> 00:03:22,740
you can also mutate it all right so what

00:03:18,690 --> 00:03:24,540
is this useful form so passing caller

00:03:22,740 --> 00:03:28,380
belts generally is useful this is a like

00:03:24,540 --> 00:03:30,450
stupid example if you were to have a

00:03:28,380 --> 00:03:32,640
function work that takes an integer and

00:03:30,450 --> 00:03:35,100
returns a string and you want to quote

00:03:32,640 --> 00:03:36,720
an asynchronous version of that then you

00:03:35,100 --> 00:03:38,130
would probably hold it in the sense that

00:03:36,720 --> 00:03:40,290
it takes the input parameters and

00:03:38,130 --> 00:03:43,170
instead of returning the result right

00:03:40,290 --> 00:03:44,580
now it will later invoke a little

00:03:43,170 --> 00:03:47,670
function that you pass it with the

00:03:44,580 --> 00:03:49,560
result when it said when it has that the

00:03:47,670 --> 00:03:51,810
problem here when you when you use this

00:03:49,560 --> 00:03:54,000
as your API like I said like a function

00:03:51,810 --> 00:03:56,940
point is very much stateless so you give

00:03:54,000 --> 00:03:58,200
it a function process with that function

00:03:56,940 --> 00:04:01,130
will later only have access to like

00:03:58,200 --> 00:04:03,120
globally define data variables and

00:04:01,130 --> 00:04:05,010
usually when you do this you want to

00:04:03,120 --> 00:04:06,720
pass a little bit of context with it so

00:04:05,010 --> 00:04:10,160
that the process results function later

00:04:06,720 --> 00:04:12,720
knows what a piece of work it was

00:04:10,160 --> 00:04:15,750
getting the the results from something

00:04:12,720 --> 00:04:19,680
like that so a function point that's not

00:04:15,750 --> 00:04:22,410
the best thing to use in this API if you

00:04:19,680 --> 00:04:23,910
if you like work with order API to

00:04:22,410 --> 00:04:26,120
sometimes see that you would pass to

00:04:23,910 --> 00:04:28,090
work asynchronously also avoid point

00:04:26,120 --> 00:04:30,850
and later gets passed through your

00:04:28,090 --> 00:04:33,470
process without function was a

00:04:30,850 --> 00:04:35,449
workaround around that but a void

00:04:33,470 --> 00:04:37,430
pointers are not good they are they are

00:04:35,449 --> 00:04:39,740
not ripe safe and all that so much

00:04:37,430 --> 00:04:42,169
better we use a function wrapper so

00:04:39,740 --> 00:04:43,880
instead of declaring your process result

00:04:42,169 --> 00:04:45,949
parameter as a function pointer you use

00:04:43,880 --> 00:04:47,930
a function wrapper class which is a

00:04:45,949 --> 00:04:49,669
template class and the template

00:04:47,930 --> 00:04:52,699
signature is only the signature of the

00:04:49,669 --> 00:04:55,060
function or more generally callable

00:04:52,699 --> 00:04:57,020
object that you mean so anything that

00:04:55,060 --> 00:05:00,260
takes a standard string as an argument

00:04:57,020 --> 00:05:01,520
and returns void in this case should be

00:05:00,260 --> 00:05:03,520
something that you can put into this

00:05:01,520 --> 00:05:05,720
function wrapper to pass it to your API

00:05:03,520 --> 00:05:07,550
and I give you here like a super

00:05:05,720 --> 00:05:10,120
simplified version how you would

00:05:07,550 --> 00:05:12,979
implement such a function wrapper

00:05:10,120 --> 00:05:14,270
simplified and incomplete but the idea

00:05:12,979 --> 00:05:17,020
is that your function wrapper will have

00:05:14,270 --> 00:05:20,210
to store some function pointers and

00:05:17,020 --> 00:05:23,150
while the type of the function wrapper

00:05:20,210 --> 00:05:24,860
itself doesn't say yet which kind of

00:05:23,150 --> 00:05:27,610
object you later reppin it because it

00:05:24,860 --> 00:05:30,650
only gives you the function signature

00:05:27,610 --> 00:05:33,260
this is called type erasure basic e the

00:05:30,650 --> 00:05:35,360
magic happens when you define templated

00:05:33,260 --> 00:05:37,039
construction constructors and assignment

00:05:35,360 --> 00:05:39,590
operators that can take any type and

00:05:37,039 --> 00:05:43,400
then instantiate some bit of static code

00:05:39,590 --> 00:05:46,310
that can later run take a pointer to the

00:05:43,400 --> 00:05:47,810
to the state that you store probably on

00:05:46,310 --> 00:05:50,630
the heap or somewhere else in this

00:05:47,810 --> 00:05:54,440
function wrapper to execute your

00:05:50,630 --> 00:05:56,030
function so it will populate a function

00:05:54,440 --> 00:05:57,410
pointer for execution in this data

00:05:56,030 --> 00:05:59,270
structure and you probably need more you

00:05:57,410 --> 00:06:00,650
probably also need a function pointer to

00:05:59,270 --> 00:06:02,090
something that can later on destroy the

00:06:00,650 --> 00:06:04,010
object when your function wrapper gets

00:06:02,090 --> 00:06:05,870
destroyed okay so this is super

00:06:04,010 --> 00:06:07,370
simplified and this obviously exists in

00:06:05,870 --> 00:06:09,169
a more fleshed-out version and it's

00:06:07,370 --> 00:06:12,260
called standard function so that's there

00:06:09,169 --> 00:06:16,610
already what does the standard function

00:06:12,260 --> 00:06:19,580
look like on our standard platform the

00:06:16,610 --> 00:06:25,039
GC C standard library on x86 64 usually

00:06:19,580 --> 00:06:27,590
has 48 bytes and 16 of those bikes are

00:06:25,039 --> 00:06:30,260
used for two function pointers similar

00:06:27,590 --> 00:06:33,200
to what I just shown you it stores a

00:06:30,260 --> 00:06:35,900
function pointer for executing or

00:06:33,200 --> 00:06:37,310
invoking your object and it's also

00:06:35,900 --> 00:06:38,460
second function pointer for little

00:06:37,310 --> 00:06:41,460
management function that

00:06:38,460 --> 00:06:43,050
instantiate switch can copy your object

00:06:41,460 --> 00:06:45,479
or can delete your object and so on and

00:06:43,050 --> 00:06:47,819
all the remaining space 32 bytes can be

00:06:45,479 --> 00:06:50,340
used to store your actual object in the

00:06:47,819 --> 00:06:54,720
faction wrapper itself if it fits into

00:06:50,340 --> 00:06:57,060
32 bytes you can avoid another heap

00:06:54,720 --> 00:06:59,310
allocation and to store it in place if

00:06:57,060 --> 00:07:01,139
it doesn't fit in there obviously send

00:06:59,310 --> 00:07:03,479
function will make a heap allocation and

00:07:01,139 --> 00:07:07,560
only store the pointer to the object on

00:07:03,479 --> 00:07:09,150
the heap inside this space as well as a

00:07:07,560 --> 00:07:11,970
matter of fact standard function is

00:07:09,150 --> 00:07:13,680
copyable and when you make a copy of a

00:07:11,970 --> 00:07:16,380
standard function it makes a copy of the

00:07:13,680 --> 00:07:20,060
wrapped object as well and as a matter

00:07:16,380 --> 00:07:24,360
of fact is also not know except moveable

00:07:20,060 --> 00:07:27,620
which will become or the relevance of

00:07:24,360 --> 00:07:32,729
which further become clear in a moment

00:07:27,620 --> 00:07:35,070
okay so typical use cases some you I'm

00:07:32,729 --> 00:07:37,259
working at Facebook and we have a large

00:07:35,070 --> 00:07:38,940
code base using C++ okay looking I can

00:07:37,259 --> 00:07:41,370
look inside and see you like what our

00:07:38,940 --> 00:07:43,620
typical use cases is how we use this and

00:07:41,370 --> 00:07:46,169
the two things that I sort of see

00:07:43,620 --> 00:07:48,720
everywhere the two classes of use cases

00:07:46,169 --> 00:07:51,509
is either passing standard function as a

00:07:48,720 --> 00:07:53,039
little task to libraries for execution

00:07:51,509 --> 00:07:54,960
at a later time or in a different threat

00:07:53,039 --> 00:07:57,750
or something like this and the other

00:07:54,960 --> 00:07:59,909
thing is to store those tasks for later

00:07:57,750 --> 00:08:02,099
execution for instance in the

00:07:59,909 --> 00:08:03,659
implementation of those libraries in

00:08:02,099 --> 00:08:04,830
either case you you pass those tasks

00:08:03,659 --> 00:08:08,250
around and typically they are only

00:08:04,830 --> 00:08:09,719
executed once anyway so there's very

00:08:08,250 --> 00:08:12,479
little reason why you need the standard

00:08:09,719 --> 00:08:14,669
function thing to be copyable for us as

00:08:12,479 --> 00:08:16,320
a matter of fact in in those 10 cases

00:08:14,669 --> 00:08:19,590
there's there's never the need to make a

00:08:16,320 --> 00:08:21,180
copy of them okay I want to give you a

00:08:19,590 --> 00:08:24,060
little bit more detailed examples here

00:08:21,180 --> 00:08:25,919
what it looks like so in this Foley

00:08:24,060 --> 00:08:28,199
library which is open source so you can

00:08:25,919 --> 00:08:30,930
look at it and use it if you like we

00:08:28,199 --> 00:08:32,640
have a abstract base class an interface

00:08:30,930 --> 00:08:35,310
called fully executor which is basically

00:08:32,640 --> 00:08:37,620
an interface defining things that can

00:08:35,310 --> 00:08:39,479
execute tasks for you so an

00:08:37,620 --> 00:08:42,149
implementation could be a CPU thread

00:08:39,479 --> 00:08:44,459
pool so you pass tasks to this executor

00:08:42,149 --> 00:08:48,449
and thread pool execute it when a threat

00:08:44,459 --> 00:08:50,300
is available and what we use is standard

00:08:48,449 --> 00:08:54,500
function or it

00:08:50,300 --> 00:08:56,630
to pass those tasks around because funny

00:08:54,500 --> 00:08:58,339
executor is a abstract based class and

00:08:56,630 --> 00:09:01,279
there's ad method that you use to edit

00:08:58,339 --> 00:09:04,070
task is virtual we can't use templates

00:09:01,279 --> 00:09:06,440
we have to use a specific type so the

00:09:04,070 --> 00:09:10,610
type that wheels obviously is or was

00:09:06,440 --> 00:09:14,570
standard function to illustrate the

00:09:10,610 --> 00:09:18,649
other use case and folly we also have an

00:09:14,570 --> 00:09:20,690
implementation of the future and promise

00:09:18,649 --> 00:09:22,970
pattern which you also know from the

00:09:20,690 --> 00:09:24,500
standard library but ours is a bit more

00:09:22,970 --> 00:09:26,240
fleshed out and feature-rich and we

00:09:24,500 --> 00:09:27,920
couldn't wait or didn't want to wait

00:09:26,240 --> 00:09:29,899
onto the standard library offers these

00:09:27,920 --> 00:09:32,360
features and I don't like the standard

00:09:29,899 --> 00:09:36,170
library our future also has a dot then

00:09:32,360 --> 00:09:38,029
method where you can give it a the task

00:09:36,170 --> 00:09:42,620
that will be executed when your future

00:09:38,029 --> 00:09:45,290
actually has a value and the result of

00:09:42,620 --> 00:09:48,050
the dot then returns the future again

00:09:45,290 --> 00:09:49,519
for the result of your little lambda so

00:09:48,050 --> 00:09:51,019
you can change them and all that it's

00:09:49,519 --> 00:09:53,959
super useful and we use this a lot

00:09:51,019 --> 00:09:55,760
obviously again the implementation use a

00:09:53,959 --> 00:09:57,950
standard function to store the callback

00:09:55,760 --> 00:09:59,899
because when you call dot then the

00:09:57,950 --> 00:10:01,430
future typically doesn't have a value

00:09:59,899 --> 00:10:03,380
yet so we store the Quebec and later

00:10:01,430 --> 00:10:05,959
when the future has a value can execute

00:10:03,380 --> 00:10:07,970
really the task so that's all nice and

00:10:05,959 --> 00:10:11,089
well what is the problem with standard

00:10:07,970 --> 00:10:14,690
function for us so the biggest problem

00:10:11,089 --> 00:10:16,399
was that we often wanted to use move

00:10:14,690 --> 00:10:18,589
only types and capture them in those

00:10:16,399 --> 00:10:21,200
little tasks so typically you would like

00:10:18,589 --> 00:10:23,720
to be able to store a unique pointer or

00:10:21,200 --> 00:10:26,690
a promise of this future and promise

00:10:23,720 --> 00:10:30,200
pattern it neatly the tasks to make use

00:10:26,690 --> 00:10:32,270
of them the problem here is that when

00:10:30,200 --> 00:10:33,800
you store non copyable objects in your

00:10:32,270 --> 00:10:34,310
lambda your lambda itself becomes non

00:10:33,800 --> 00:10:38,390
copyable

00:10:34,310 --> 00:10:40,790
and and now this doesn't compile because

00:10:38,390 --> 00:10:42,140
this gets eventually converted into a

00:10:40,790 --> 00:10:43,430
standard function and instead of

00:10:42,140 --> 00:10:45,529
function only works with copyable

00:10:43,430 --> 00:10:49,130
objects so this will get you a compiler

00:10:45,529 --> 00:10:50,690
error which is bad and people still want

00:10:49,130 --> 00:10:55,730
to do what they wanted to do is so they

00:10:50,690 --> 00:10:59,060
find workarounds one workaround was this

00:10:55,730 --> 00:11:01,190
is the clean one you just move your move

00:10:59,060 --> 00:11:03,470
only object on the heap and use a share

00:11:01,190 --> 00:11:04,160
pointer to refer to it share pointers

00:11:03,470 --> 00:11:06,710
are copyable

00:11:04,160 --> 00:11:09,050
obviously even if your object itself

00:11:06,710 --> 00:11:11,870
wasn't copyable so you can capture the

00:11:09,050 --> 00:11:15,140
SharePoint on your lambda use that that

00:11:11,870 --> 00:11:17,750
works that is fine to some degree but it

00:11:15,140 --> 00:11:20,270
comes with overheads so it impacts

00:11:17,750 --> 00:11:22,280
performance because a now you have

00:11:20,270 --> 00:11:24,070
always extra memory allocations to store

00:11:22,280 --> 00:11:26,540
every single object on the heap and

00:11:24,070 --> 00:11:28,130
secondly as you pass these things around

00:11:26,540 --> 00:11:31,130
you have to increment and increment

00:11:28,130 --> 00:11:33,680
atomic reference counts which can also

00:11:31,130 --> 00:11:35,660
mess with your with your caching and and

00:11:33,680 --> 00:11:36,860
all this so this can have performance

00:11:35,660 --> 00:11:38,780
over it especially because this

00:11:36,860 --> 00:11:42,350
sometimes we're using code that executes

00:11:38,780 --> 00:11:44,660
very often and has to be fast so people

00:11:42,350 --> 00:11:47,780
came up with a different workaround and

00:11:44,660 --> 00:11:50,420
this is a bit nasty so there's a class

00:11:47,780 --> 00:11:52,280
in Foley as well so like I said you can

00:11:50,420 --> 00:11:54,470
look at it if you want it's got more

00:11:52,280 --> 00:11:57,230
effort it's a template class and

00:11:54,470 --> 00:11:59,920
basically it's a it's a wrapper on an

00:11:57,230 --> 00:12:03,380
object of type T and the move wrapper

00:11:59,920 --> 00:12:07,430
implements the copy constructor by

00:12:03,380 --> 00:12:09,740
moving the contained object this is bad

00:12:07,430 --> 00:12:11,270
because it breaks copy semantics making

00:12:09,740 --> 00:12:13,760
a copy of a move wrapper doesn't really

00:12:11,270 --> 00:12:15,800
give you to duplicate objects afterwards

00:12:13,760 --> 00:12:20,300
but one valid object that received the

00:12:15,800 --> 00:12:21,710
object and one leftover empty shell you

00:12:20,300 --> 00:12:23,300
can think of folly being free but if you

00:12:21,710 --> 00:12:25,280
were to put a unique point on to move

00:12:23,300 --> 00:12:27,800
wrapper that's essentially the old

00:12:25,280 --> 00:12:30,160
standard Auto pointer and everyone loved

00:12:27,800 --> 00:12:32,390
that so that must be a good idea right

00:12:30,160 --> 00:12:34,430
so if you have any code that makes

00:12:32,390 --> 00:12:36,950
copies of objects and then assumes that

00:12:34,430 --> 00:12:38,720
it has two valid objects afterwards it

00:12:36,950 --> 00:12:41,180
just breaks when you pass these things

00:12:38,720 --> 00:12:42,470
around on the other end this doesn't

00:12:41,180 --> 00:12:44,840
come with the performance overhead of

00:12:42,470 --> 00:12:46,130
the share point of solution so if you

00:12:44,840 --> 00:12:48,050
happen to know that your implementation

00:12:46,130 --> 00:12:50,390
about us that it never has to make

00:12:48,050 --> 00:12:51,830
copies then that kind of works but the

00:12:50,390 --> 00:12:54,500
compiler could help you enforce these

00:12:51,830 --> 00:12:56,360
things and so that point we thought like

00:12:54,500 --> 00:13:00,590
ok we need a different function wrapper

00:12:56,360 --> 00:13:02,900
to solve those problems we requiring

00:13:00,590 --> 00:13:04,760
that all callable objects that you store

00:13:02,900 --> 00:13:07,490
in a function wrapper to be copyable is

00:13:04,760 --> 00:13:09,440
painful for us and for most of our you

00:13:07,490 --> 00:13:11,660
cases it's not helpful it's not useful

00:13:09,440 --> 00:13:13,460
because we never make those copies and

00:13:11,660 --> 00:13:14,920
if we did it breaks

00:13:13,460 --> 00:13:16,899
anyway now our code base

00:13:14,920 --> 00:13:18,220
people use this move repeting so

00:13:16,899 --> 00:13:19,690
basically what you want the code from

00:13:18,220 --> 00:13:21,070
earlier you just want this to work this

00:13:19,690 --> 00:13:24,130
should compile and it should behave as

00:13:21,070 --> 00:13:26,620
expected okay

00:13:24,130 --> 00:13:29,670
standard function problem there's

00:13:26,620 --> 00:13:33,149
another problem that wasn't maybe super

00:13:29,670 --> 00:13:38,470
obvious for us but while we're at it

00:13:33,149 --> 00:13:40,930
standard function also has a Lex idea of

00:13:38,470 --> 00:13:42,490
compromise so static functions of

00:13:40,930 --> 00:13:44,769
function wrapper and Senate function

00:13:42,490 --> 00:13:47,620
itself has an invocation operator and

00:13:44,769 --> 00:13:49,149
that is declared Const which means even

00:13:47,620 --> 00:13:50,860
if you only have a constant reference to

00:13:49,149 --> 00:13:53,560
your standard function you can invoke

00:13:50,860 --> 00:13:55,540
your object but it's happy with taking

00:13:53,560 --> 00:13:58,510
objects that have to have non conscious

00:13:55,540 --> 00:14:01,060
references to be cause so something that

00:13:58,510 --> 00:14:02,500
mutates a state when you call it you

00:14:01,060 --> 00:14:03,760
just put it in a standard function and

00:14:02,500 --> 00:14:05,740
then now it looks like something that

00:14:03,760 --> 00:14:09,850
you can call it without it mutating it

00:14:05,740 --> 00:14:11,350
States this is not necessarily a bucket

00:14:09,850 --> 00:14:13,300
serve the problem is just like the

00:14:11,350 --> 00:14:15,310
compiler can't help you anymore when you

00:14:13,300 --> 00:14:18,010
do this wrong normally consecrate must

00:14:15,310 --> 00:14:19,570
help you enforce or enforcing

00:14:18,010 --> 00:14:22,000
constraints helps you find those bugs

00:14:19,570 --> 00:14:23,440
and avoid those bugs the compiler can't

00:14:22,000 --> 00:14:26,740
help you now you have to make sure you

00:14:23,440 --> 00:14:32,079
write all co-direct so here comes fully

00:14:26,740 --> 00:14:34,660
functioning fully function okay how is

00:14:32,079 --> 00:14:37,060
it design obviously non copyable when i

00:14:34,660 --> 00:14:38,980
say obviously so the thing is what we

00:14:37,060 --> 00:14:42,760
wanted is we wanted to be able to store

00:14:38,980 --> 00:14:45,420
non compute colobus um but we also want

00:14:42,760 --> 00:14:47,769
to do this without like bad performance

00:14:45,420 --> 00:14:50,079
impacts so it shouldn't internally do

00:14:47,769 --> 00:14:51,699
the standard SharePoint or trick because

00:14:50,079 --> 00:14:53,920
I said that means two extra memory

00:14:51,699 --> 00:14:55,630
locations and it's expensive and all

00:14:53,920 --> 00:14:56,980
that and also to maintain value

00:14:55,630 --> 00:14:59,500
semantics you should think of it as a

00:14:56,980 --> 00:15:00,940
thing containing and owning an object

00:14:59,500 --> 00:15:03,940
and as you pass it around you pass

00:15:00,940 --> 00:15:06,750
ownership of that around as well so

00:15:03,940 --> 00:15:09,310
basically what that means that the fully

00:15:06,750 --> 00:15:10,800
function the reporting itself must also

00:15:09,310 --> 00:15:14,470
be non copyable

00:15:10,800 --> 00:15:17,230
but that's fine because we hardly ever

00:15:14,470 --> 00:15:19,380
want to copy it the other decision we

00:15:17,230 --> 00:15:21,550
made is it took me know it said movable

00:15:19,380 --> 00:15:25,149
which is kind of important for non

00:15:21,550 --> 00:15:26,740
copyable types because you want to be

00:15:25,149 --> 00:15:27,470
able to use those types with STL

00:15:26,740 --> 00:15:29,660
containers and

00:15:27,470 --> 00:15:31,400
say send a back door if it has to

00:15:29,660 --> 00:15:34,220
reallocate and move all your object

00:15:31,400 --> 00:15:36,230
around it will only use move semantics

00:15:34,220 --> 00:15:38,120
if it was guaranteed not to throw

00:15:36,230 --> 00:15:39,830
because I will be a problem if in the

00:15:38,120 --> 00:15:41,740
middle it throws and then what do you do

00:15:39,830 --> 00:15:44,440
move the rest back that man throws well

00:15:41,740 --> 00:15:46,550
no the stein containers would copy

00:15:44,440 --> 00:15:48,590
objects if they're not know except

00:15:46,550 --> 00:15:50,870
moveable which obviously is a problem if

00:15:48,590 --> 00:15:52,400
your object is not copyable so it's kind

00:15:50,870 --> 00:15:55,190
of like if you think about it

00:15:52,400 --> 00:15:58,580
non copyable types really have to be no

00:15:55,190 --> 00:16:02,630
except movable and the other thing is

00:15:58,580 --> 00:16:04,370
that if you think about it we expect

00:16:02,630 --> 00:16:06,380
many of our own classes to have fully

00:16:04,370 --> 00:16:08,120
functional members and if all the

00:16:06,380 --> 00:16:09,650
function wasn't know except movable then

00:16:08,120 --> 00:16:11,900
it would be like kind of contagious all

00:16:09,650 --> 00:16:13,760
those other data structures that contain

00:16:11,900 --> 00:16:15,740
phony function will become no acceptable

00:16:13,760 --> 00:16:17,720
and we rather want to live in a world

00:16:15,740 --> 00:16:21,410
where roughly everything is no except

00:16:17,720 --> 00:16:24,320
movable so yeah that's what we decided

00:16:21,410 --> 00:16:26,620
for that we also decide to make a

00:16:24,320 --> 00:16:29,480
conscripts and like I said earlier

00:16:26,620 --> 00:16:32,840
Senate function kind of makes a mistake

00:16:29,480 --> 00:16:34,880
if you will that it accepts functions

00:16:32,840 --> 00:16:36,890
that mutate their states but the Pierce

00:16:34,880 --> 00:16:39,590
is a thing that does not rotate at state

00:16:36,890 --> 00:16:41,390
and now you can choose whether you

00:16:39,590 --> 00:16:43,940
should go the way where the states will

00:16:41,390 --> 00:16:46,790
be mutate abbu then you can accept

00:16:43,940 --> 00:16:48,170
anything but you also need a Const non

00:16:46,790 --> 00:16:50,420
conscious reference of your function

00:16:48,170 --> 00:16:51,680
wrapper to be able to call it or you go

00:16:50,420 --> 00:16:55,910
the other way and say everything is

00:16:51,680 --> 00:16:58,190
Const we only accept colobus that do not

00:16:55,910 --> 00:16:59,450
mutaters day when we call them and then

00:16:58,190 --> 00:17:02,270
it's find that the fawley function is

00:16:59,450 --> 00:17:03,710
also called as a constant those are the

00:17:02,270 --> 00:17:05,420
two options then we basically have both

00:17:03,710 --> 00:17:05,750
of them so it comes in two flavors that

00:17:05,420 --> 00:17:09,200
falli

00:17:05,750 --> 00:17:11,270
function templates which takes the

00:17:09,200 --> 00:17:12,710
function signature here you can add

00:17:11,270 --> 00:17:14,420
constant at the end and then it's the

00:17:12,710 --> 00:17:19,660
cons behavior otherwise it's the mood of

00:17:14,420 --> 00:17:21,350
the behavior implementation details

00:17:19,660 --> 00:17:23,240
comparing with what I told you about

00:17:21,350 --> 00:17:25,610
standard function earlier funny function

00:17:23,240 --> 00:17:29,960
objects are a little bit larger they

00:17:25,610 --> 00:17:31,640
occupy 64 bytes the implementation is

00:17:29,960 --> 00:17:34,190
actually pretty similar to a host and

00:17:31,640 --> 00:17:36,590
function works so fully function also

00:17:34,190 --> 00:17:39,140
contains two function pointers one that

00:17:36,590 --> 00:17:40,850
calls your actual object and the other

00:17:39,140 --> 00:17:42,710
one that calls a management function

00:17:40,850 --> 00:17:44,870
or moving your object deleting object

00:17:42,710 --> 00:17:49,850
etcetera and then there's now 48 bytes

00:17:44,870 --> 00:17:51,049
left for in-place storage the reason why

00:17:49,850 --> 00:17:53,360
we made it a little bit bigger I mean

00:17:51,049 --> 00:17:55,220
this is a trade-off the larger you make

00:17:53,360 --> 00:17:57,049
the wrapper the more objects you can

00:17:55,220 --> 00:17:59,750
store in line without extra memory

00:17:57,049 --> 00:18:01,730
allocations but the larger you make it

00:17:59,750 --> 00:18:03,950
the more memory you just waste if you

00:18:01,730 --> 00:18:05,360
end up storing small objects in it so

00:18:03,950 --> 00:18:07,789
it's kind of like you can you can pick

00:18:05,360 --> 00:18:10,190
your size and we we just came down on 64

00:18:07,789 --> 00:18:12,140
bytes because it aligns nicely with like

00:18:10,190 --> 00:18:15,770
cache lines on our standard architecture

00:18:12,140 --> 00:18:18,169
I think formula that 64 bytes is good

00:18:15,770 --> 00:18:20,240
because then we can store a standard

00:18:18,169 --> 00:18:21,919
function object if we those if we have

00:18:20,240 --> 00:18:24,020
those two lying around in our code base

00:18:21,919 --> 00:18:26,510
we can wrap this here without an extra

00:18:24,020 --> 00:18:28,400
memory location however that argument

00:18:26,510 --> 00:18:30,260
doesn't really work because like I said

00:18:28,400 --> 00:18:32,990
earlier standard functions don't know

00:18:30,260 --> 00:18:35,090
acceptable and in order to have fully

00:18:32,990 --> 00:18:37,340
function no except moveable we have to

00:18:35,090 --> 00:18:39,890
put all objects that are not know except

00:18:37,340 --> 00:18:41,929
mover on the heap because the pointer to

00:18:39,890 --> 00:18:44,240
the hoop object we can always leave that

00:18:41,929 --> 00:18:48,110
without throwing exceptions but we might

00:18:44,240 --> 00:18:53,150
not be able to move the object itself so

00:18:48,110 --> 00:18:55,909
yeah speaking of wrapping one in the

00:18:53,150 --> 00:18:58,220
other of those two you can absolutely

00:18:55,909 --> 00:19:00,409
wrap a stand a function object in a

00:18:58,220 --> 00:19:00,830
fully function but not the other way

00:19:00,409 --> 00:19:02,659
around

00:19:00,830 --> 00:19:06,230
the reason is just in copy ability

00:19:02,659 --> 00:19:07,549
requirements because fully functions are

00:19:06,230 --> 00:19:09,830
copy ability installed in the standard

00:19:07,549 --> 00:19:12,140
function other way around works fine

00:19:09,830 --> 00:19:15,260
which is a good thing as you migrate

00:19:12,140 --> 00:19:17,480
your code base and your API is it's it's

00:19:15,260 --> 00:19:19,010
mostly kind of backwards compatible if

00:19:17,480 --> 00:19:21,679
you change functions to take fully

00:19:19,010 --> 00:19:24,830
functions they can still accept standard

00:19:21,679 --> 00:19:28,730
function passed to them okay and then we

00:19:24,830 --> 00:19:30,470
migrate it to fully function it works

00:19:28,730 --> 00:19:35,059
mostly as a drop-in replacement for

00:19:30,470 --> 00:19:37,010
Senate function the places where it

00:19:35,059 --> 00:19:38,419
doesn't work as a as a simple drop-in

00:19:37,010 --> 00:19:41,059
replacement are those where you actually

00:19:38,419 --> 00:19:41,870
need copy ability of your function

00:19:41,059 --> 00:19:44,360
wrapper

00:19:41,870 --> 00:19:47,090
those cases are surprisingly rare I

00:19:44,360 --> 00:19:48,950
really didn't find many of those the

00:19:47,090 --> 00:19:51,169
other thing is if you rely on this Lex

00:19:48,950 --> 00:19:53,179
cons correctness behavior of standards

00:19:51,169 --> 00:19:55,100
function then you might run into

00:19:53,179 --> 00:19:57,020
problems when you switch to fully

00:19:55,100 --> 00:20:00,200
function but I think that is a good

00:19:57,020 --> 00:20:02,480
thing because if your code only works

00:20:00,200 --> 00:20:03,799
when constructors are not enforced then

00:20:02,480 --> 00:20:08,150
that's kind of a bug that should be

00:20:03,799 --> 00:20:11,150
fixed anyway what we also learned is of

00:20:08,150 --> 00:20:14,600
those two variants the immutable and the

00:20:11,150 --> 00:20:16,909
conspirator fully function most in most

00:20:14,600 --> 00:20:18,950
places we need the immutable one like

00:20:16,909 --> 00:20:22,240
all constant function is used

00:20:18,950 --> 00:20:25,070
occasionally but not very often

00:20:22,240 --> 00:20:26,779
and what I also saw when I was migrating

00:20:25,070 --> 00:20:30,559
API is that we often pass them that

00:20:26,779 --> 00:20:32,690
function as constant references which

00:20:30,559 --> 00:20:37,370
led to many sort of accident or copies

00:20:32,690 --> 00:20:39,440
of standard function and what you have

00:20:37,370 --> 00:20:40,789
to do in order to make it work with

00:20:39,440 --> 00:20:42,970
fully functions you have to pass them

00:20:40,789 --> 00:20:46,640
either as non conscious references or

00:20:42,970 --> 00:20:48,110
r-value references most of the times are

00:20:46,640 --> 00:20:53,390
very references because we've kind of

00:20:48,110 --> 00:20:55,039
leave them down your API layers this

00:20:53,390 --> 00:20:56,720
basically applies only to the mutable

00:20:55,039 --> 00:20:58,610
variant or fully function if your if

00:20:56,720 --> 00:21:00,320
they have the constant or fully function

00:20:58,610 --> 00:21:04,340
that you can also pass it as a constant

00:21:00,320 --> 00:21:07,220
reference at least if you want to

00:21:04,340 --> 00:21:08,409
execute the function in the function

00:21:07,220 --> 00:21:13,700
that you pass it to

00:21:08,409 --> 00:21:16,700
anyway so migration has happened in many

00:21:13,700 --> 00:21:18,620
places the adoption of Facebook is such

00:21:16,700 --> 00:21:22,480
that in the examples that I showed you

00:21:18,620 --> 00:21:25,520
earlier for the api's I showed you the

00:21:22,480 --> 00:21:27,230
fully future example that is not based

00:21:25,520 --> 00:21:29,659
on fully function and that was an

00:21:27,230 --> 00:21:31,340
instant win because no user code had to

00:21:29,659 --> 00:21:34,250
change but from that time on people

00:21:31,340 --> 00:21:36,590
could just move capture data in the

00:21:34,250 --> 00:21:38,419
lambdas if only times as well and it

00:21:36,590 --> 00:21:39,730
just worked it compiled and it works as

00:21:38,419 --> 00:21:42,529
expected

00:21:39,730 --> 00:21:43,909
fully function also replaced and

00:21:42,529 --> 00:21:47,130
function for the other example the

00:21:43,909 --> 00:21:49,720
fawley executor the space class

00:21:47,130 --> 00:21:51,429
we can pass tasks to some

00:21:49,720 --> 00:21:53,590
implementations that execute the tasks

00:21:51,429 --> 00:21:55,570
later that was a little bit more work

00:21:53,590 --> 00:21:57,250
because being a base class we have a

00:21:55,570 --> 00:21:58,059
good number of implementations so you

00:21:57,250 --> 00:21:59,500
had to go through all the

00:21:58,059 --> 00:22:01,779
implementations and see if you could

00:21:59,500 --> 00:22:03,279
just flip the type whether the

00:22:01,779 --> 00:22:05,470
implementation would still work or

00:22:03,279 --> 00:22:07,570
whether copies were made which usually

00:22:05,470 --> 00:22:09,100
were just accidental copies it was just

00:22:07,570 --> 00:22:10,690
copies where people forget to write

00:22:09,100 --> 00:22:14,289
standard move not copies they made

00:22:10,690 --> 00:22:15,490
because they actually wanted to and in

00:22:14,289 --> 00:22:17,799
those cases where the migration was

00:22:15,490 --> 00:22:20,470
actually non-trivial it usually pointed

00:22:17,799 --> 00:22:23,710
to other problems in the codes for us

00:22:20,470 --> 00:22:25,269
especially when you actually make copies

00:22:23,710 --> 00:22:26,980
of objects that was a problem because

00:22:25,269 --> 00:22:29,019
other parts of the codebase never

00:22:26,980 --> 00:22:32,620
expected that to happen so they use this

00:22:29,019 --> 00:22:33,580
horrendous volume for everything but

00:22:32,620 --> 00:22:37,450
after all it wasn't that difficult

00:22:33,580 --> 00:22:39,250
really now we have both we have standard

00:22:37,450 --> 00:22:44,769
function we have fully function and both

00:22:39,250 --> 00:22:47,019
can be useful so when you have functions

00:22:44,769 --> 00:22:48,639
when you have code that actually wants

00:22:47,019 --> 00:22:51,070
to get a function pass and will Nate

00:22:48,639 --> 00:22:53,139
will later have to make copies of that

00:22:51,070 --> 00:22:55,870
standard functions exactly what you need

00:22:53,139 --> 00:22:57,909
I would say in pretty much every other

00:22:55,870 --> 00:22:59,440
case fully functions better because it's

00:22:57,909 --> 00:23:01,480
less restrictive for the user if you

00:22:59,440 --> 00:23:06,870
don't need to make copies don't force a

00:23:01,480 --> 00:23:09,519
user to give you something copyable well

00:23:06,870 --> 00:23:11,169
and then the thing for our code base

00:23:09,519 --> 00:23:13,870
that might not be the same problem for

00:23:11,169 --> 00:23:15,279
everyone but because we have lifts along

00:23:13,870 --> 00:23:16,720
with standard functions and the problems

00:23:15,279 --> 00:23:19,090
and we make these workarounds and we'll

00:23:16,720 --> 00:23:20,590
just follow move rep as a workaround we

00:23:19,090 --> 00:23:23,200
have this fully move repla now in many

00:23:20,590 --> 00:23:24,880
places in the code base that makes it

00:23:23,200 --> 00:23:26,740
difficult to use standard function for

00:23:24,880 --> 00:23:29,260
its intended purpose because if you use

00:23:26,740 --> 00:23:31,029
then function with the intention to

00:23:29,260 --> 00:23:33,220
actually make copies you might still

00:23:31,029 --> 00:23:35,500
until people passing you move wrapper

00:23:33,220 --> 00:23:36,159
objects and then copies are not possible

00:23:35,500 --> 00:23:38,350
at all

00:23:36,159 --> 00:23:42,010
but that's that's like maybe a problem

00:23:38,350 --> 00:23:43,450
problem specific to our code base all

00:23:42,010 --> 00:23:46,679
right I should show you some benchmarks

00:23:43,450 --> 00:23:50,559
so I said it was as fast or better in

00:23:46,679 --> 00:23:52,240
run time speed as fully function so this

00:23:50,559 --> 00:23:54,340
is a benchmark the benchmark coat itself

00:23:52,240 --> 00:23:55,539
is also part of the falli repository so

00:23:54,340 --> 00:23:57,789
when you check it out on github you can

00:23:55,539 --> 00:23:59,730
rerun this yourself and this is only a

00:23:57,789 --> 00:24:02,390
subset of the benchmark that it runs

00:23:59,730 --> 00:24:04,860
but roughly speaking the upper half II

00:24:02,390 --> 00:24:06,150
what is compared he is invoking a

00:24:04,860 --> 00:24:08,010
function invoking a function pointer

00:24:06,150 --> 00:24:09,570
invoking a standard function and opening

00:24:08,010 --> 00:24:11,460
a fully function

00:24:09,570 --> 00:24:13,200
standard memory and if you're interested

00:24:11,460 --> 00:24:18,960
and basically the important thing is

00:24:13,200 --> 00:24:21,210
just a wrong button it's just this here

00:24:18,960 --> 00:24:23,610
invoking a sin function takes two point

00:24:21,210 --> 00:24:25,590
three nanoseconds invoking a boolean

00:24:23,610 --> 00:24:27,510
function takes two nanoseconds so it's

00:24:25,590 --> 00:24:29,430
even slightly better and then there's

00:24:27,510 --> 00:24:31,110
another benchmark which first creates

00:24:29,430 --> 00:24:33,630
one of those objects and then invokes it

00:24:31,110 --> 00:24:38,820
so creating a function pointer doesn't

00:24:33,630 --> 00:24:42,480
really take any time so I guess that's

00:24:38,820 --> 00:24:44,550
probably a measurement error here that

00:24:42,480 --> 00:24:46,850
it's slightly faster but then creating a

00:24:44,550 --> 00:24:52,140
sudden function object and afterwards

00:24:46,850 --> 00:24:55,520
invoking it ah there we are

00:24:52,140 --> 00:24:58,170
take 3 nanoseconds I was off by one lakh

00:24:55,520 --> 00:24:59,280
take 3 nanoseconds for sin function and

00:24:58,170 --> 00:25:01,140
for folly function to point a in

00:24:59,280 --> 00:25:03,150
nanoseconds so it's not really that

00:25:01,140 --> 00:25:04,650
important that it's faster it was only

00:25:03,150 --> 00:25:07,650
important for us that we don't like

00:25:04,650 --> 00:25:12,110
invent a performance regression and

00:25:07,650 --> 00:25:14,850
that's obviously not the case all right

00:25:12,110 --> 00:25:17,040
conclusions all the things that I've

00:25:14,850 --> 00:25:18,860
said before for the function is mostly

00:25:17,040 --> 00:25:21,330
drop-in replacement first and function

00:25:18,860 --> 00:25:23,670
lifts the requirement for culpability of

00:25:21,330 --> 00:25:25,310
your wrapped objects the migration to

00:25:23,670 --> 00:25:27,720
volley function is usually fairly easy

00:25:25,310 --> 00:25:29,970
makes the code look nicer in many places

00:25:27,720 --> 00:25:31,530
it imposes constraints which is good

00:25:29,970 --> 00:25:33,990
because the compiler can help you spot

00:25:31,530 --> 00:25:36,540
marks it's as fast or better standard

00:25:33,990 --> 00:25:39,680
forms at runtime and after 18 months we

00:25:36,540 --> 00:25:42,570
are pretty happy I guess I spoke with it

00:25:39,680 --> 00:25:44,010
with that I thank you all for coming and

00:25:42,570 --> 00:25:47,680
I think we probably have a few minutes

00:25:44,010 --> 00:25:55,779
left for questions if there are any

00:25:47,680 --> 00:25:55,779
[Applause]

00:26:05,700 --> 00:26:17,110
so Const I don't know if this is now

00:26:11,080 --> 00:26:18,700
more confusing or helpful but it's

00:26:17,110 --> 00:26:21,279
basically the cons that you would put

00:26:18,700 --> 00:26:24,639
here in your own function so constant

00:26:21,279 --> 00:26:25,960
means that you can't mutate the state

00:26:24,639 --> 00:26:28,330
that you have packaged with your

00:26:25,960 --> 00:26:30,549
callable objects so in a lambda when you

00:26:28,330 --> 00:26:33,070
capture some data you can't change that

00:26:30,549 --> 00:26:34,899
data unless you declare that lambda

00:26:33,070 --> 00:26:38,049
mutable then you're allowed and the

00:26:34,899 --> 00:26:41,440
mutable lambda is not Const

00:26:38,049 --> 00:26:46,950
can't be wrapped as a constant whereas

00:26:41,440 --> 00:26:46,950
the non mutable lambda is constants fine

00:26:51,210 --> 00:26:57,519
yes basically Const means that your

00:26:54,970 --> 00:26:59,710
object can be invoked from a constant

00:26:57,519 --> 00:27:01,570
reference if it's non constant you need

00:26:59,710 --> 00:27:20,070
a non conference for your object to

00:27:01,570 --> 00:27:22,379
actually call it I don't want to say 0

00:27:20,070 --> 00:27:25,359
there's always the odd case where

00:27:22,379 --> 00:27:27,129
there's like a little chain of things

00:27:25,359 --> 00:27:29,769
where you weigh C yet you don't have to

00:27:27,129 --> 00:27:31,570
change one API but like sort of a

00:27:29,769 --> 00:27:34,720
dependency chain of a pis and at some

00:27:31,570 --> 00:27:37,269
point it gets maybe complicated but like

00:27:34,720 --> 00:27:39,639
in general it just turned out to be

00:27:37,269 --> 00:27:41,409
easier than I thought as as in in

00:27:39,639 --> 00:27:43,840
general in most places it was a fairly

00:27:41,409 --> 00:27:45,879
one-to-one replacement and the most

00:27:43,840 --> 00:27:47,590
things I had to change and for example

00:27:45,879 --> 00:27:51,369
implementers of this executor class were

00:27:47,590 --> 00:27:53,590
that people were not careful and making

00:27:51,369 --> 00:27:55,299
copies of the tasks even though they

00:27:53,590 --> 00:27:56,799
didn't have to just because they didn't

00:27:55,299 --> 00:27:59,649
write standard move and that that kind

00:27:56,799 --> 00:28:01,899
of thing so just swapping the type broke

00:27:59,649 --> 00:28:02,190
the builds but that was super easy to

00:28:01,899 --> 00:28:04,980
fake

00:28:02,190 --> 00:28:08,280
and in the few cases where it wasn't

00:28:04,980 --> 00:28:12,770
trivial to fix it was really pointing to

00:28:08,280 --> 00:28:12,770
an underlying problem I would say oh

00:28:13,310 --> 00:28:32,670
sorry so say that again then okay yeah

00:28:30,720 --> 00:28:34,680
that's more like a workflow thing we we

00:28:32,670 --> 00:28:37,110
basically statically link everything and

00:28:34,680 --> 00:28:39,180
build everything from current master so

00:28:37,110 --> 00:28:41,100
it didn't have to be binary compatible

00:28:39,180 --> 00:28:43,680
good point I never thought about that

00:28:41,100 --> 00:28:45,480
because working on Facebook and linking

00:28:43,680 --> 00:29:00,230
everything statically I never had to so

00:28:45,480 --> 00:29:03,510
yeah thanks for the question okay so

00:29:00,230 --> 00:29:07,020
this is somewhat and optimization thing

00:29:03,510 --> 00:29:09,090
as well so basically the code that the

00:29:07,020 --> 00:29:10,890
compiler has to instantiate separately

00:29:09,090 --> 00:29:14,430
for every type that you want to wrap in

00:29:10,890 --> 00:29:16,260
it is obviously invoking your object but

00:29:14,430 --> 00:29:17,790
then instead of function you have to be

00:29:16,260 --> 00:29:19,140
able to make a copy of that object when

00:29:17,790 --> 00:29:20,730
the standard function itself is copied

00:29:19,140 --> 00:29:23,790
you have to be able to destroy the

00:29:20,730 --> 00:29:26,460
object when well when the send function

00:29:23,790 --> 00:29:27,840
is destroyed standard function also has

00:29:26,460 --> 00:29:29,940
a couple of other things that we never

00:29:27,840 --> 00:29:31,800
needed like getting a type ID from the

00:29:29,940 --> 00:29:33,660
rep type and and things like this and

00:29:31,800 --> 00:29:36,450
they basically bundled everything that

00:29:33,660 --> 00:29:37,890
is not invocation into one function so

00:29:36,450 --> 00:29:40,080
that you don't have to store that many

00:29:37,890 --> 00:29:42,150
function pointers in it and it's like

00:29:40,080 --> 00:29:43,530
the trade of is like okay invocation is

00:29:42,150 --> 00:29:45,750
the standard use case that should be

00:29:43,530 --> 00:29:47,670
fast so we have a dedicated function

00:29:45,750 --> 00:29:51,150
pointer in the object to quickly execute

00:29:47,670 --> 00:29:52,710
the function everything else operations

00:29:51,150 --> 00:29:54,120
that don't happen so often so we bundle

00:29:52,710 --> 00:29:55,980
them all into one function so we only

00:29:54,120 --> 00:29:59,450
have to one store one function pointer

00:29:55,980 --> 00:29:59,450
that makes sense

00:29:59,730 --> 00:30:16,030
obviously not Oh No so think of it in

00:30:13,090 --> 00:30:18,070
the implementation of the assignment

00:30:16,030 --> 00:30:21,010
operator and the constructor that can

00:30:18,070 --> 00:30:22,540
take any anytime basically they're the

00:30:21,010 --> 00:30:24,850
compiler instantiate some other

00:30:22,540 --> 00:30:26,920
templated static functions and stores

00:30:24,850 --> 00:30:28,180
their financial pointers so it's the

00:30:26,920 --> 00:30:30,700
compiler doing the work for you for

00:30:28,180 --> 00:30:33,400
every type that you have a pass to those

00:30:30,700 --> 00:30:47,800
function wrappers I get a sessions over

00:30:33,400 --> 00:30:49,930
sign there was like half a question so

00:30:47,800 --> 00:30:52,900
you mean this management function so the

00:30:49,930 --> 00:30:54,670
point and the the question is where the

00:30:52,900 --> 00:30:57,640
poly function does the same trick with

00:30:54,670 --> 00:30:59,380
this bundled function that does there is

00:30:57,640 --> 00:31:01,870
management function yes the

00:30:59,380 --> 00:31:03,490
implementation is fairly similar to

00:31:01,870 --> 00:31:04,930
standard standard function it's really

00:31:03,490 --> 00:31:06,520
just the decisions you have to decide

00:31:04,930 --> 00:31:08,470
whether your type is copyable or not and

00:31:06,520 --> 00:31:09,880
we made a different decision but we kind

00:31:08,470 --> 00:31:11,530
of use all the same tricks in standard

00:31:09,880 --> 00:31:13,420
function the implementation otherwise

00:31:11,530 --> 00:31:15,500
all right sessions over thank you all

00:31:13,420 --> 00:31:19,569
very much for coming

00:31:15,500 --> 00:31:19,569

YouTube URL: https://www.youtube.com/watch?v=SToaMS3jNH0


