Title: CppCon 2017: Herb Sutter “Meta: Thoughts on generative C++”
Publication date: 2017-09-28
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Two years ago, I started to focus on exploring ways that we might evolve the C++ language itself to make C++ programming both more powerful and simpler. The only way to accomplish both of those goals at the same time is by adding abstractions that let programmers directly express their intent—to elevate comments and documentation to testable code, and elevate coding patterns and idioms into compiler-checkable declarations. The work came up with several potential candidate features where judiciously adding some power to the language could simplify code dramatically, while staying true to C++'s core values of efficient abstraction, closeness to hardware, and the zero-overhead principle. 

The first two potential candidate features from that work to be further developed and proposed for ISO C++ are the ＜=＞ unified comparison operator (minor) and what I've provisionally called "metaclasses" as a way to generatively write C++ types (major). This talk is about the latter, and includes design motivation, current progress, and some live online compiler demos using the prototype Clang-based compiler built by Andrew Sutton and hosted at godbolt.org.
— 
Herb Sutter - Software architect, Microsoft

Herb chairs the ISO C++ committee and is the primary author or co-author of a number of Standard C++ features, including nullptr, enum class, parallel algorithms, C++17 structured bindings, and the in-progress unified ＜=＞ comparison operator.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:10,950
have you done so just before we get

00:00:07,290 --> 00:00:13,469
started thank you very much to over 70

00:00:10,950 --> 00:00:16,199
people who responded to this challenge

00:00:13,469 --> 00:00:18,570
before the Monday night cutoff that made

00:00:16,199 --> 00:00:20,670
it very hard to pick winners I could

00:00:18,570 --> 00:00:22,320
only pick two so first of all many of

00:00:20,670 --> 00:00:24,869
you gave him very nice solutions thank

00:00:22,320 --> 00:00:26,970
you and since I had to pick two let me

00:00:24,869 --> 00:00:29,310
describe very briefly the exercise and

00:00:26,970 --> 00:00:31,320
then show you the two who have some

00:00:29,310 --> 00:00:33,090
wonderful iPads that I'm told run great

00:00:31,320 --> 00:00:37,500
Google search and Microsoft Office as

00:00:33,090 --> 00:00:39,090
well the idea is I want to write a case

00:00:37,500 --> 00:00:40,260
insensitive string class it's a straw

00:00:39,090 --> 00:00:43,350
man example there are other ways you

00:00:40,260 --> 00:00:45,840
could do it but if I wanted this kind of

00:00:43,350 --> 00:00:49,050
type how many comparison operators would

00:00:45,840 --> 00:00:51,809
I have to write today in C plus 17 the

00:00:49,050 --> 00:00:55,739
latest modern stuff we just shipped in

00:00:51,809 --> 00:00:59,129
order to provide comparisons between CI

00:00:55,739 --> 00:01:02,010
string and CI string CI string char star

00:00:59,129 --> 00:01:05,189
seesaw strings and of course that has to

00:01:02,010 --> 00:01:06,689
be symmetric and even the CI string CI

00:01:05,189 --> 00:01:08,130
string I would like to be symmetric

00:01:06,689 --> 00:01:12,299
because you want conversions on both

00:01:08,130 --> 00:01:12,810
sides the answer is yeah 12 ought to do

00:01:12,299 --> 00:01:15,330
it no way

00:01:12,810 --> 00:01:18,470
18 ought to do it and how many of you

00:01:15,330 --> 00:01:20,610
have enjoyed writing code like this

00:01:18,470 --> 00:01:24,180
sorry how many of you have written code

00:01:20,610 --> 00:01:28,470
like this way more hands only a couple

00:01:24,180 --> 00:01:31,470
of enjoyers so thank you to in Coweta

00:01:28,470 --> 00:01:32,759
invite up Manuel Bella and Ben Dean can

00:01:31,470 --> 00:01:35,689
you give them a hand please wherever you

00:01:32,759 --> 00:01:35,689
are come on right up

00:01:39,180 --> 00:01:43,840
man well I enjoyed that you use string

00:01:42,340 --> 00:01:45,610
view so you can actually take more than

00:01:43,840 --> 00:01:47,860
const char star that which was which was

00:01:45,610 --> 00:01:49,330
needed and I like that you showed an if

00:01:47,860 --> 00:01:51,100
theft preferred way I do it in

00:01:49,330 --> 00:01:52,870
production code for real but here's what

00:01:51,100 --> 00:01:54,370
you're probably looking for I like that

00:01:52,870 --> 00:01:58,060
I mean both were actually good answers

00:01:54,370 --> 00:01:59,770
and also been I picked you before I

00:01:58,060 --> 00:02:02,680
realized you were a fellow speaker so oh

00:01:59,770 --> 00:02:05,500
well ad but that's okay because we're we

00:02:02,680 --> 00:02:07,660
preferred either way and I like that you

00:02:05,500 --> 00:02:10,060
also had a very nice solution that

00:02:07,660 --> 00:02:12,310
avoided extra conversion operators

00:02:10,060 --> 00:02:14,530
allocations you didn't just convert to a

00:02:12,310 --> 00:02:16,600
CI string and compare those and you

00:02:14,530 --> 00:02:19,150
refer to my paper about this spaceship

00:02:16,600 --> 00:02:20,380
operator to simplify this so that was

00:02:19,150 --> 00:02:22,510
really good so that was a good awareness

00:02:20,380 --> 00:02:24,930
so thank you both of you enjoy your

00:02:22,510 --> 00:02:24,930
iPad's

00:02:25,890 --> 00:02:31,090
and thank you again to Stevens Capital

00:02:29,470 --> 00:02:32,680
Management for providing those as well

00:02:31,090 --> 00:02:35,170
as other iPads for some of the other

00:02:32,680 --> 00:02:39,010
questions and in the contest from the

00:02:35,170 --> 00:02:41,320
speakers this year now this is actually

00:02:39,010 --> 00:02:42,880
semi related to the talk it has actually

00:02:41,320 --> 00:02:45,250
nothing to do technically with the talk

00:02:42,880 --> 00:02:47,590
but it has a lot to do in principle so

00:02:45,250 --> 00:02:49,000
the reason I picked this example was I

00:02:47,590 --> 00:02:50,140
have a completely different proposal

00:02:49,000 --> 00:02:51,910
that's currently making its way through

00:02:50,140 --> 00:02:54,100
committee it builds on the work of many

00:02:51,910 --> 00:02:56,440
others including Baroness true strip and

00:02:54,100 --> 00:02:58,840
others who have done other proposals in

00:02:56,440 --> 00:03:02,440
the area of comparisons Lawrence Krauss

00:02:58,840 --> 00:03:03,580
and this proposal is currently on its

00:03:02,440 --> 00:03:05,290
way through it's been improved by the

00:03:03,580 --> 00:03:06,700
evolution groups and so it should go

00:03:05,290 --> 00:03:08,980
into worrying review and hopefully if

00:03:06,700 --> 00:03:11,410
nothing blows up it'll be in C++ 20

00:03:08,980 --> 00:03:13,300
draft in the next meeting or two the

00:03:11,410 --> 00:03:15,040
idea is that we invent something that

00:03:13,300 --> 00:03:16,810
other languages already have but the

00:03:15,040 --> 00:03:19,239
idea of a three-way comparison operator

00:03:16,810 --> 00:03:20,980
other languages have the three-way

00:03:19,239 --> 00:03:22,330
comparison spaceship operator because

00:03:20,980 --> 00:03:25,180
that's what it looks like Darth Vader's

00:03:22,330 --> 00:03:27,880
TIE fighter but it's something that even

00:03:25,180 --> 00:03:30,880
in C we've had the stur comp does this

00:03:27,880 --> 00:03:32,650
so we've had functions and if you're

00:03:30,880 --> 00:03:34,330
familiar with Perl Python some others

00:03:32,650 --> 00:03:37,540
they have similar things under different

00:03:34,330 --> 00:03:39,310
names the idea if this proposal is

00:03:37,540 --> 00:03:42,489
accepted is that instead of writing

00:03:39,310 --> 00:03:44,680
those 18 functions you write to notice

00:03:42,489 --> 00:03:46,060
they are members they don't need to be

00:03:44,680 --> 00:03:49,030
non-member friends to get conversions

00:03:46,060 --> 00:03:49,480
and to get symmetry you say I want to

00:03:49,030 --> 00:03:52,300
compare

00:03:49,480 --> 00:03:54,310
against another CI string by the way

00:03:52,300 --> 00:03:56,230
that returns a week ordering that means

00:03:54,310 --> 00:03:59,010
it's an ordering so I generate all six

00:03:56,230 --> 00:04:02,080
others not just equality inequality and

00:03:59,010 --> 00:04:04,360
I actually have more information because

00:04:02,080 --> 00:04:06,489
it says what kind of ordering it is

00:04:04,360 --> 00:04:08,140
which we do not have expressed in code

00:04:06,489 --> 00:04:10,780
today oh and by the way there's another

00:04:08,140 --> 00:04:13,000
one I also want to compare against C

00:04:10,780 --> 00:04:14,709
style strings that could be even better

00:04:13,000 --> 00:04:16,930
as a string of you as several of you in

00:04:14,709 --> 00:04:19,150
your solutions pointed out and it also

00:04:16,930 --> 00:04:20,829
returns a weak ordering and so the nice

00:04:19,150 --> 00:04:23,020
thing about this all I say is weak

00:04:20,829 --> 00:04:25,900
ordering that means I generate six or in

00:04:23,020 --> 00:04:27,610
the second case twelve these the effect

00:04:25,900 --> 00:04:28,900
of twelve functions doesn't actually

00:04:27,610 --> 00:04:30,520
generate the functions it just makes

00:04:28,900 --> 00:04:33,280
those operators available in your code

00:04:30,520 --> 00:04:36,010
and they get rewritten to call us of the

00:04:33,280 --> 00:04:37,930
spaceship operator it's efficient

00:04:36,010 --> 00:04:39,130
because in the previous solution I

00:04:37,930 --> 00:04:41,650
showed you might have noticed that a

00:04:39,130 --> 00:04:43,449
common thing we do is we implement four

00:04:41,650 --> 00:04:46,270
of the operators in terms of equals and

00:04:43,449 --> 00:04:47,889
less than which is inefficient because

00:04:46,270 --> 00:04:49,900
on the common if you do for instance

00:04:47,889 --> 00:04:52,090
less than equals in terms of less than

00:04:49,900 --> 00:04:54,510
or equals turns out you have to traverse

00:04:52,090 --> 00:04:57,940
the common prefix the equal prefix twice

00:04:54,510 --> 00:04:59,470
depending on how you code and so that's

00:04:57,940 --> 00:05:01,150
undesirable this is guaranteed to be

00:04:59,470 --> 00:05:02,830
single pass it's guaranteed to be

00:05:01,150 --> 00:05:05,770
symmetric documents that there's a weak

00:05:02,830 --> 00:05:07,840
order and there's a lot less boilerplate

00:05:05,770 --> 00:05:09,990
to write the key is it's allowing the

00:05:07,840 --> 00:05:14,050
ideas to allow people to express intent

00:05:09,990 --> 00:05:16,720
directly so this has nothing to do with

00:05:14,050 --> 00:05:17,530
this talk and yes it looks like it's a

00:05:16,720 --> 00:05:19,270
TIE fighter

00:05:17,530 --> 00:05:23,229
Vader's in particular but I choose the

00:05:19,270 --> 00:05:25,300
Falcon so sue me it also kind of is that

00:05:23,229 --> 00:05:27,099
shape if you squint just right but the

00:05:25,300 --> 00:05:29,889
reason this was a nice segue here is

00:05:27,099 --> 00:05:31,389
because the rest of this talk especially

00:05:29,889 --> 00:05:32,830
the part about metaclasses

00:05:31,389 --> 00:05:35,830
they'll give an overview of related

00:05:32,830 --> 00:05:38,320
features first as well like the

00:05:35,830 --> 00:05:40,479
spaceship operator is about making C++

00:05:38,320 --> 00:05:42,099
code simpler we're adding features to

00:05:40,479 --> 00:05:45,280
the language so the language is growing

00:05:42,099 --> 00:05:48,760
incrementally but C++ code should be

00:05:45,280 --> 00:05:50,860
simpler to write how by letting

00:05:48,760 --> 00:05:55,599
programmers state their intent more

00:05:50,860 --> 00:05:56,860
directly instead of circuitous Li say

00:05:55,599 --> 00:05:58,390
things that in fact we're already

00:05:56,860 --> 00:06:00,130
writing so we're not inventing new

00:05:58,390 --> 00:06:03,630
requirements these are things we are

00:06:00,130 --> 00:06:06,610
already doing it's just hard

00:06:03,630 --> 00:06:08,020
they do it by generating things for you

00:06:06,610 --> 00:06:09,760
transparently so we're gonna have to

00:06:08,020 --> 00:06:11,050
have some way of letting the programmers

00:06:09,760 --> 00:06:13,320
see what's going on when that's

00:06:11,050 --> 00:06:16,540
necessary for example in debugging and

00:06:13,320 --> 00:06:19,600
that means tools are necessary to make

00:06:16,540 --> 00:06:22,840
sure these features not only work to

00:06:19,600 --> 00:06:24,760
write code ones but make sure that code

00:06:22,840 --> 00:06:26,920
that you write is also continues to be

00:06:24,760 --> 00:06:30,940
easy to debug to maintain as you release

00:06:26,920 --> 00:06:32,500
it over time so with that let me switch

00:06:30,940 --> 00:06:35,170
to the main topic for today which is

00:06:32,500 --> 00:06:37,360
thoughts on generative C++ and again the

00:06:35,170 --> 00:06:40,750
goal is to make C plus more powerful

00:06:37,360 --> 00:06:45,700
means we're adding capabilities but for

00:06:40,750 --> 00:06:48,160
C++ code to be simpler it is possible if

00:06:45,700 --> 00:06:52,630
you do that right to actually simplify

00:06:48,160 --> 00:06:54,490
the language additively which is seems

00:06:52,630 --> 00:06:58,240
like an oxymoron but you do it by adding

00:06:54,490 --> 00:06:59,920
abstractions the way that I have gone

00:06:58,240 --> 00:07:02,550
through this exercise so for the last

00:06:59,920 --> 00:07:05,590
two two-and-a-half years in particular

00:07:02,550 --> 00:07:07,720
I've decided to focus on spending the

00:07:05,590 --> 00:07:09,190
the time I have to write standards

00:07:07,720 --> 00:07:11,190
proposals from the hundred things we

00:07:09,190 --> 00:07:13,300
could write and add to the language

00:07:11,190 --> 00:07:16,780
specifically to things that might

00:07:13,300 --> 00:07:20,320
simplify c plus code and that was a very

00:07:16,780 --> 00:07:22,530
general a very broad exercise and from

00:07:20,320 --> 00:07:24,460
that I'm now taking some things and as

00:07:22,530 --> 00:07:26,260
appropriate one at a time and bringing

00:07:24,460 --> 00:07:28,150
them to the committee the spaceship

00:07:26,260 --> 00:07:29,980
operator was a target of opportunity the

00:07:28,150 --> 00:07:31,720
committee was already talking about that

00:07:29,980 --> 00:07:33,310
the design I had in my pocket was

00:07:31,720 --> 00:07:35,260
already informed by that discussion

00:07:33,310 --> 00:07:37,660
Laurence Crowell and others and since

00:07:35,260 --> 00:07:39,280
after rejecting it for C+ 17 they

00:07:37,660 --> 00:07:40,930
continued to talk about it I said well

00:07:39,280 --> 00:07:43,330
fine let's have a proposal and do it

00:07:40,930 --> 00:07:44,980
right and see if that's something that

00:07:43,330 --> 00:07:48,810
could get consensus and happily it has

00:07:44,980 --> 00:07:51,700
building on other people's work as well

00:07:48,810 --> 00:07:55,360
but the whole exercise to find out ways

00:07:51,700 --> 00:07:57,820
to simplify C++ has been driven by one

00:07:55,360 --> 00:07:59,680
thing that helps to keep on course and

00:07:57,820 --> 00:08:01,660
and I think it's important to have help

00:07:59,680 --> 00:08:03,280
at least I need help to stay on course

00:08:01,660 --> 00:08:05,320
from all the wonderful gadgety features

00:08:03,280 --> 00:08:07,990
that we could imagine to ones that

00:08:05,320 --> 00:08:09,790
really simplify code and the way that

00:08:07,990 --> 00:08:13,090
I've chosen to do it is to look for

00:08:09,790 --> 00:08:14,410
people digging with spoons how many of

00:08:13,090 --> 00:08:15,250
you have written template better

00:08:14,410 --> 00:08:18,550
programs

00:08:15,250 --> 00:08:22,660
on purpose okay that was it was it just

00:08:18,550 --> 00:08:24,220
a joke how many of you like template

00:08:22,660 --> 00:08:25,690
better programs that you express

00:08:24,220 --> 00:08:27,130
important things but wish you could do

00:08:25,690 --> 00:08:31,480
it without writing the template

00:08:27,130 --> 00:08:33,250
metaprogramming hands that's what the

00:08:31,480 --> 00:08:36,400
committee as a whole is working toward

00:08:33,250 --> 00:08:38,500
and what this talk is about so if you

00:08:36,400 --> 00:08:41,950
find something that people are already

00:08:38,500 --> 00:08:44,620
doing with inadequate tools that express

00:08:41,950 --> 00:08:45,220
things indirectly like look templates or

00:08:44,620 --> 00:08:46,720
turing-complete

00:08:45,220 --> 00:08:49,180
I'll bet we can compute some stuff at

00:08:46,720 --> 00:08:51,100
compile time with that and they're

00:08:49,180 --> 00:08:52,540
willing to endure that much pain to get

00:08:51,100 --> 00:08:56,680
that effect that tells you there's a

00:08:52,540 --> 00:08:59,080
market for shovels and it tells you that

00:08:56,680 --> 00:09:01,390
yes you are not inventing some new

00:08:59,080 --> 00:09:03,190
feature that's taking C++ and turning it

00:09:01,390 --> 00:09:05,950
into a different language taking it into

00:09:03,190 --> 00:09:10,120
a different direction this is something

00:09:05,950 --> 00:09:12,730
C++ programmers all ready do it's just

00:09:10,120 --> 00:09:14,560
hard and that's important because it

00:09:12,730 --> 00:09:16,900
demonstrates the market need it also

00:09:14,560 --> 00:09:19,960
demonstrates it really is C++ it's what

00:09:16,900 --> 00:09:21,760
we are already doing so a good tool

00:09:19,960 --> 00:09:22,810
should make those things easier and more

00:09:21,760 --> 00:09:25,300
things possible

00:09:22,810 --> 00:09:26,680
so we observe people digging with the

00:09:25,300 --> 00:09:28,360
spoon of template metaprogramming to

00:09:26,680 --> 00:09:30,040
compute values and types of compile time

00:09:28,360 --> 00:09:31,540
so we've been adding concepts per

00:09:30,040 --> 00:09:33,820
functions we're doing much more of that

00:09:31,540 --> 00:09:36,790
that I'll talk about to have first class

00:09:33,820 --> 00:09:38,410
compiled time programming express your

00:09:36,790 --> 00:09:40,660
intent more directly what you're already

00:09:38,410 --> 00:09:42,550
doing we observe that people are

00:09:40,660 --> 00:09:44,320
creating interface definition languages

00:09:42,550 --> 00:09:47,080
side languages and compilers that know

00:09:44,320 --> 00:09:50,890
about things like properties or the comm

00:09:47,080 --> 00:09:52,930
classes or acute classes and they do

00:09:50,890 --> 00:09:54,400
this because they need to express

00:09:52,930 --> 00:09:56,530
something that they can't express in the

00:09:54,400 --> 00:09:57,880
language is there a way to let them

00:09:56,530 --> 00:10:00,130
express that in the language so you

00:09:57,880 --> 00:10:03,280
don't need the side compilers you don't

00:10:00,130 --> 00:10:04,660
need the non-portable extensions again

00:10:03,280 --> 00:10:08,380
something people are already doing

00:10:04,660 --> 00:10:10,540
usually multiple ways multiple times can

00:10:08,380 --> 00:10:13,150
we bring that into C+ sauce more

00:10:10,540 --> 00:10:15,490
directly everything I'm going to talk

00:10:13,150 --> 00:10:17,140
about is under construction what we are

00:10:15,490 --> 00:10:18,640
going to talk about is you know it's

00:10:17,140 --> 00:10:20,589
always exciting stuff especially at the

00:10:18,640 --> 00:10:22,690
beginning where you're liable to say oh

00:10:20,589 --> 00:10:25,089
great can I use this like in my project

00:10:22,690 --> 00:10:28,089
in six months no probably not even the

00:10:25,089 --> 00:10:29,709
earliest parts of this are early

00:10:28,089 --> 00:10:31,779
reflection is one of the earliest that

00:10:29,709 --> 00:10:34,209
is currently actively undergoing wording

00:10:31,779 --> 00:10:36,670
review so that has a good chance of

00:10:34,209 --> 00:10:39,399
being in C+ 20 perhaps we'll have to see

00:10:36,670 --> 00:10:42,249
but the rest is longer term but look at

00:10:39,399 --> 00:10:44,470
this as an arc of where we are going

00:10:42,249 --> 00:10:46,480
that should reassure us that C++ is

00:10:44,470 --> 00:10:49,540
going in a good direction that will help

00:10:46,480 --> 00:10:50,949
us and expect also that much of the

00:10:49,540 --> 00:10:53,439
syntax I'm going to show you is gonna

00:10:50,949 --> 00:10:56,290
change it's just strawman syntax some of

00:10:53,439 --> 00:10:59,199
the concepts may get tweaked but let's

00:10:56,290 --> 00:11:03,490
see how far we can go to replacing some

00:10:59,199 --> 00:11:04,779
spoons with shovels in our language most

00:11:03,490 --> 00:11:06,879
of the talk is going to be on the bottom

00:11:04,779 --> 00:11:08,410
thing metaclasses but I want to take a

00:11:06,879 --> 00:11:10,779
few minutes first to talk about the

00:11:08,410 --> 00:11:12,339
foundation that's being built and give

00:11:10,779 --> 00:11:14,649
you some references to papers where you

00:11:12,339 --> 00:11:16,120
can find out more about that especially

00:11:14,649 --> 00:11:18,699
for a reflection compile-time

00:11:16,120 --> 00:11:22,059
programming and injections let's focus

00:11:18,699 --> 00:11:24,069
on just that part for now as the

00:11:22,059 --> 00:11:26,259
foundational work that is already in

00:11:24,069 --> 00:11:28,180
progress the reflection is of the most

00:11:26,259 --> 00:11:29,949
advanced stage so far in committee the

00:11:28,180 --> 00:11:32,980
other two are still being more incubated

00:11:29,949 --> 00:11:34,120
and then see what we can then do to

00:11:32,980 --> 00:11:37,929
build on those things

00:11:34,120 --> 00:11:41,139
assuming they exist so first reflection

00:11:37,929 --> 00:11:42,309
thank you to many people but three of

00:11:41,139 --> 00:11:45,819
the main people who've been working on

00:11:42,309 --> 00:11:47,769
this for a long time Mattos axel David

00:11:45,819 --> 00:11:50,410
several of you are here in the room

00:11:47,769 --> 00:11:51,579
thank you to your company's global logic

00:11:50,410 --> 00:11:53,499
sir and Bloomberg and the other

00:11:51,579 --> 00:11:55,420
companies that send people to committee

00:11:53,499 --> 00:11:58,420
meetings help them write papers do

00:11:55,420 --> 00:12:00,279
implementations and you can find much of

00:11:58,420 --> 00:12:01,689
what they've written here if you're

00:12:00,279 --> 00:12:04,149
looking for information here are

00:12:01,689 --> 00:12:06,009
cherry-picking a few of the papers these

00:12:04,149 --> 00:12:07,509
people recommend you read so thank you

00:12:06,009 --> 00:12:09,189
again for your review on these slides as

00:12:07,509 --> 00:12:11,079
well but if you want to find out more

00:12:09,189 --> 00:12:13,529
thank you to all these people let's give

00:12:11,079 --> 00:12:13,529
them a hand

00:12:16,460 --> 00:12:23,190
so really briefly what's the idea

00:12:20,180 --> 00:12:25,589
the syntax may change but think okay

00:12:23,190 --> 00:12:31,740
prefix dollar two some expressions some

00:12:25,589 --> 00:12:33,750
type gives you a Const meta colon colon

00:12:31,740 --> 00:12:36,240
type so it might be a medic colon colon

00:12:33,750 --> 00:12:38,720
function or a medical and colon variable

00:12:36,240 --> 00:12:41,070
or a medical and colon type that

00:12:38,720 --> 00:12:42,839
represents a class so then you can

00:12:41,070 --> 00:12:45,360
iterate over its member functions and

00:12:42,839 --> 00:12:47,160
its data members things like that query

00:12:45,360 --> 00:12:50,279
things like their types their constants

00:12:47,160 --> 00:12:52,200
of parameters and in general ask for

00:12:50,279 --> 00:12:55,050
information about the program that you

00:12:52,200 --> 00:12:57,630
can then query and find out more about

00:12:55,050 --> 00:12:59,700
and then do things with we don't

00:12:57,630 --> 00:13:01,709
currently have proposals we do have some

00:12:59,700 --> 00:13:03,450
early thinking but proposals to reflect

00:13:01,709 --> 00:13:06,720
on statements and expressions so the

00:13:03,450 --> 00:13:10,350
bodies of functions but declarations are

00:13:06,720 --> 00:13:12,450
well along the idea is that we can put

00:13:10,350 --> 00:13:13,770
apply these this reflection and ordinary

00:13:12,450 --> 00:13:16,080
code where it's just another read-only

00:13:13,770 --> 00:13:18,300
value which the compiler may or may not

00:13:16,080 --> 00:13:21,930
need to even bake into the object file

00:13:18,300 --> 00:13:23,700
if it in lines the results but you can't

00:13:21,930 --> 00:13:25,320
take its address because it may or may

00:13:23,700 --> 00:13:28,980
not be in the object file that's why

00:13:25,320 --> 00:13:30,450
it's a PR value of pure temporary but in

00:13:28,980 --> 00:13:32,760
compile time code it's just an ordinary

00:13:30,450 --> 00:13:34,440
variable in ordinary temporary and I'll

00:13:32,760 --> 00:13:38,400
discuss compile time code in a moment

00:13:34,440 --> 00:13:40,110
but there's the nutshell summary I'm

00:13:38,400 --> 00:13:42,120
gonna show the bike shedding thing only

00:13:40,110 --> 00:13:43,980
once but assume that this appears on

00:13:42,120 --> 00:13:44,400
every single slide for the rest of the

00:13:43,980 --> 00:13:46,950
talk

00:13:44,400 --> 00:13:49,500
syntax may change it may be prefix

00:13:46,950 --> 00:13:50,850
dollar expression there are lots of

00:13:49,500 --> 00:13:52,080
concerns about that including

00:13:50,850 --> 00:13:54,209
interaction with existing code

00:13:52,080 --> 00:13:56,760
generation tools that already staking a

00:13:54,209 --> 00:13:58,230
solid claim on the dollar symbol so we

00:13:56,760 --> 00:13:59,940
may not want to escape that all the time

00:13:58,230 --> 00:14:01,860
we may want reflects per with angle

00:13:59,940 --> 00:14:04,440
brackets or with round brackets we may

00:14:01,860 --> 00:14:06,630
want some underbars who knows as long as

00:14:04,440 --> 00:14:09,300
I can spell it some reasonable way I'm a

00:14:06,630 --> 00:14:12,149
happy camper for the purposes of today

00:14:09,300 --> 00:14:15,510
I'll use prefix dollar again all of this

00:14:12,149 --> 00:14:17,490
is subject to change so what can I do

00:14:15,510 --> 00:14:19,589
with this well a very simple example is

00:14:17,490 --> 00:14:21,600
let's say I have an enumeration and I

00:14:19,589 --> 00:14:23,880
just want to print iterate over all the

00:14:21,600 --> 00:14:27,170
enumerator values so you might want to

00:14:23,880 --> 00:14:30,260
say reflect on my entire

00:14:27,170 --> 00:14:32,000
and if that's a type that has in this

00:14:30,260 --> 00:14:33,470
case if we expose those enumerators as

00:14:32,000 --> 00:14:35,800
variables or it might the reflection

00:14:33,470 --> 00:14:38,089
might return eight an actual enumerators

00:14:35,800 --> 00:14:40,940
function then I just go through and

00:14:38,089 --> 00:14:43,550
create each of their names and so this

00:14:40,940 --> 00:14:46,790
gives me the ability to look at my type

00:14:43,550 --> 00:14:51,019
and then do something compute something

00:14:46,790 --> 00:14:53,120
based on what that type is so I'm really

00:14:51,019 --> 00:14:56,209
getting a view like a compiler into that

00:14:53,120 --> 00:14:57,980
type one of the nice things about this

00:14:56,209 --> 00:15:00,110
by the way is as soon as you show the

00:14:57,980 --> 00:15:01,699
very first example like this and by the

00:15:00,110 --> 00:15:04,100
way yes you could constrain type name

00:15:01,699 --> 00:15:05,510
using concepts in C++ 20 you can

00:15:04,100 --> 00:15:06,949
constrain that to just enumerators

00:15:05,510 --> 00:15:09,430
things like that so it only compiled

00:15:06,949 --> 00:15:11,510
it's only available for renumeration x'

00:15:09,430 --> 00:15:13,310
but one of the nice things as soon as

00:15:11,510 --> 00:15:17,480
you do this is you get all the other

00:15:13,310 --> 00:15:21,889
benefits that we have in C++ for example

00:15:17,480 --> 00:15:24,380
when or templates instantiate it when

00:15:21,889 --> 00:15:25,910
they're used we don't go stamp out a

00:15:24,380 --> 00:15:28,579
million templates for all the types you

00:15:25,910 --> 00:15:31,250
might decide to write in the future just

00:15:28,579 --> 00:15:35,420
the ones you asked for so when you ask

00:15:31,250 --> 00:15:37,310
for print strings of state if that is

00:15:35,420 --> 00:15:40,610
the only instance of print strings the

00:15:37,310 --> 00:15:43,459
use of prints in your program that is

00:15:40,610 --> 00:15:46,370
the only enumeration whose values are

00:15:43,459 --> 00:15:47,990
stored in your object file or in fact an

00:15:46,370 --> 00:15:50,899
optimizer could optimize that away and

00:15:47,990 --> 00:15:54,680
not store them but just store only the

00:15:50,899 --> 00:15:56,990
labels only the text for example but all

00:15:54,680 --> 00:15:58,760
this work is done at compile time only

00:15:56,990 --> 00:16:00,980
in calling programs that actually use it

00:15:58,760 --> 00:16:03,500
so I could ship these four lines as a

00:16:00,980 --> 00:16:04,970
header only library and in every

00:16:03,500 --> 00:16:06,680
translation unit for now and in the

00:16:04,970 --> 00:16:07,970
future it's used it would be

00:16:06,680 --> 00:16:08,779
instantiated only through the

00:16:07,970 --> 00:16:11,329
enumerations

00:16:08,779 --> 00:16:14,630
that that program actually asks about

00:16:11,329 --> 00:16:16,880
and only in that program which is nice

00:16:14,630 --> 00:16:18,740
and efficient it's this is dear to our

00:16:16,880 --> 00:16:21,589
hearts because what do we believe in

00:16:18,740 --> 00:16:23,839
more than anything else in C++ don't pay

00:16:21,589 --> 00:16:25,850
for what you don't use this is that and

00:16:23,839 --> 00:16:29,600
we just naturally get to have take

00:16:25,850 --> 00:16:31,760
advantage of those things so once we've

00:16:29,600 --> 00:16:33,319
looked at reflection thanks again to

00:16:31,760 --> 00:16:35,569
those people and now let's move to

00:16:33,319 --> 00:16:37,040
compile time code that can use

00:16:35,569 --> 00:16:38,370
reflection so that's where you really

00:16:37,040 --> 00:16:40,320
start to

00:16:38,370 --> 00:16:42,089
get the benefit of it and in particular

00:16:40,320 --> 00:16:43,529
there are many many more committee

00:16:42,089 --> 00:16:46,290
members I could thank but in particular

00:16:43,529 --> 00:16:49,710
de vivre and award of EDG Louie Dion at

00:16:46,290 --> 00:16:51,240
Amazon on Tony pollution at Yandex I

00:16:49,710 --> 00:16:52,740
know at least Louie's in the room and

00:16:51,240 --> 00:16:55,830
many others here are some of their

00:16:52,740 --> 00:16:57,930
papers thank you to them and many more

00:16:55,830 --> 00:16:59,040
for working on this and helping us get

00:16:57,930 --> 00:17:00,600
what I'm about to show on the next

00:16:59,040 --> 00:17:04,580
slides but let's give them a round of

00:17:00,600 --> 00:17:04,580
applause as well this is hard work

00:17:07,069 --> 00:17:12,179
I'll tell you these papers do not write

00:17:09,449 --> 00:17:14,480
themselves and it takes a lot of

00:17:12,179 --> 00:17:18,270
discipline and time and expertise to

00:17:14,480 --> 00:17:19,140
really follow throughout a proposal so

00:17:18,270 --> 00:17:22,170
where are we today

00:17:19,140 --> 00:17:23,699
well thanks to in particular Gabi dos

00:17:22,170 --> 00:17:26,490
Reis who I believe is at the audience

00:17:23,699 --> 00:17:29,250
today we have context period C plus 11

00:17:26,490 --> 00:17:30,840
we have more concepts per in C++ 14 what

00:17:29,250 --> 00:17:33,300
you want more than one return statement

00:17:30,840 --> 00:17:35,880
oh all right we you can do that in 14

00:17:33,300 --> 00:17:37,520
but not 11 you want to loop oh you can

00:17:35,880 --> 00:17:40,770
do that now where you couldn't before

00:17:37,520 --> 00:17:42,510
you want lambdas you want if cost expert

00:17:40,770 --> 00:17:44,640
will now other people get into the fray

00:17:42,510 --> 00:17:46,950
and so thank you to gabby faisal and

00:17:44,640 --> 00:17:49,679
vena in particular but also to many

00:17:46,950 --> 00:17:52,410
others for getting us more and more

00:17:49,679 --> 00:17:55,110
concepts for in the language so Vela in

00:17:52,410 --> 00:17:58,080
particular for if concepts per faisal

00:17:55,110 --> 00:18:05,790
for generic lambdas and for context per

00:17:58,080 --> 00:18:06,900
lambdas but would you like more good

00:18:05,790 --> 00:18:09,780
because you're gonna get it whether you

00:18:06,900 --> 00:18:13,740
really want it or not so thanks to some

00:18:09,780 --> 00:18:16,230
of those same people anthony devide we

00:18:13,740 --> 00:18:18,600
are now looking at papers post c+ no 17

00:18:16,230 --> 00:18:21,410
to make virtually all of the algorithms

00:18:18,600 --> 00:18:25,220
in the standard library cost expert

00:18:21,410 --> 00:18:25,220
think about what that means

00:18:28,500 --> 00:18:32,830
why shouldn't I find different compile

00:18:31,059 --> 00:18:33,940
time instead of writing my recursive

00:18:32,830 --> 00:18:38,049
functional style template

00:18:33,940 --> 00:18:39,460
metaprogramming algorithm I want a

00:18:38,049 --> 00:18:41,740
container because I can do all this with

00:18:39,460 --> 00:18:43,510
arrays fixed sized arrays wouldn't

00:18:41,740 --> 00:18:45,070
vector be nice to have something vector

00:18:43,510 --> 00:18:47,049
like well it turns out their proposals

00:18:45,070 --> 00:18:49,299
about that and the question is how far

00:18:47,049 --> 00:18:51,340
can you go and earlier this year at C

00:18:49,299 --> 00:18:54,220
puzzles now and 48 hours ago at this

00:18:51,340 --> 00:18:56,470
very conference the answer was thanks to

00:18:54,220 --> 00:18:58,830
Ben also who just got an iPad it wasn't

00:18:56,470 --> 00:19:01,000
for that but thank you Ben and Jason

00:18:58,830 --> 00:19:03,010
well let's just make everything cost

00:19:01,000 --> 00:19:06,340
expert so we'll see how far down that

00:19:03,010 --> 00:19:10,740
road we go but we're seeing much much

00:19:06,340 --> 00:19:13,299
more already what more can we do right

00:19:10,740 --> 00:19:15,549
now and we have concepts for functions

00:19:13,299 --> 00:19:18,279
they may run a compiled timer may not

00:19:15,549 --> 00:19:19,779
and if we want to have an actual piece

00:19:18,279 --> 00:19:22,090
of code that is guaranteed to run a

00:19:19,779 --> 00:19:23,950
compile time that is one of the current

00:19:22,090 --> 00:19:25,419
proposals I cited earlier the idea of a

00:19:23,950 --> 00:19:27,940
context per block is the current

00:19:25,419 --> 00:19:31,330
thinking which I can put at statement

00:19:27,940 --> 00:19:34,779
scope so inside inside a function body I

00:19:31,330 --> 00:19:37,270
could put it class scope at name space

00:19:34,779 --> 00:19:40,090
scope now I start being able to write

00:19:37,270 --> 00:19:41,770
imperative code in a lot more places but

00:19:40,090 --> 00:19:45,190
again is this something weird and not

00:19:41,770 --> 00:19:47,080
C++ am i turning C++ into Lisp not that

00:19:45,190 --> 00:19:49,149
that would be a bad thing actually it

00:19:47,080 --> 00:19:52,029
would be because the design goals are

00:19:49,149 --> 00:19:55,059
different No again remember this is

00:19:52,029 --> 00:19:58,659
letting us write more directly the

00:19:55,059 --> 00:20:01,149
things we are already writing and that

00:19:58,659 --> 00:20:02,919
is helps us to have that guiding star to

00:20:01,149 --> 00:20:04,720
make sure yeah we're not just doing some

00:20:02,919 --> 00:20:09,460
weird other thing and a big left turn or

00:20:04,720 --> 00:20:13,750
right turn this is still C++ just easier

00:20:09,460 --> 00:20:17,440
and C++ just easier it's something we

00:20:13,750 --> 00:20:18,730
can all get behind I think so the idea

00:20:17,440 --> 00:20:21,070
of in my normal code I could have a

00:20:18,730 --> 00:20:22,809
context for block which means that II's

00:20:21,070 --> 00:20:24,789
can highlight it like this or I can see

00:20:22,809 --> 00:20:29,320
it visually very clearly in my code

00:20:24,789 --> 00:20:30,610
where my compile time code runs helps me

00:20:29,320 --> 00:20:32,529
to distinguish it between those two

00:20:30,610 --> 00:20:35,409
boxes on the left and right the normal

00:20:32,529 --> 00:20:37,059
code versus the compile time code now

00:20:35,409 --> 00:20:39,530
the next question as soon as you say

00:20:37,059 --> 00:20:41,840
that and it's by these same people of

00:20:39,530 --> 00:20:44,330
horse are saying well but wait if I now

00:20:41,840 --> 00:20:47,660
have a context for block of compiled

00:20:44,330 --> 00:20:48,950
time code within normal code what if I

00:20:47,660 --> 00:20:51,380
want to go the other way I want to write

00:20:48,950 --> 00:20:53,420
normal code generate it from within a

00:20:51,380 --> 00:20:57,050
context per block how many of you were

00:20:53,420 --> 00:20:59,260
already thinking that yes how many of

00:20:57,050 --> 00:21:01,700
you are now thinking about it yeah so

00:20:59,260 --> 00:21:04,160
the idea here is we have an injection

00:21:01,700 --> 00:21:07,250
operator and the currents of a proposal

00:21:04,160 --> 00:21:08,690
in a Pio 6:33 and related papers is the

00:21:07,250 --> 00:21:11,480
arrow sign there might be some

00:21:08,690 --> 00:21:13,640
ambiguities there so a word like inject

00:21:11,480 --> 00:21:16,160
might be better again the syntax is all

00:21:13,640 --> 00:21:19,280
strawman but the idea is that I can

00:21:16,160 --> 00:21:22,280
doubt in my compile time computation say

00:21:19,280 --> 00:21:24,710
okay I now want to inject a declaration

00:21:22,280 --> 00:21:27,920
into the surrounding code by default

00:21:24,710 --> 00:21:31,550
into the enclosing scope or perhaps into

00:21:27,920 --> 00:21:35,720
a certain nested outer class or

00:21:31,550 --> 00:21:38,060
namespace one place where this shows up

00:21:35,720 --> 00:21:40,640
is in the very simple example we just

00:21:38,060 --> 00:21:44,600
saw where instead of printing every

00:21:40,640 --> 00:21:47,570
enumerator value of an enumeration what

00:21:44,600 --> 00:21:50,930
if we just want to print the the actual

00:21:47,570 --> 00:21:54,290
name in source code of the enumerator

00:21:50,930 --> 00:21:56,930
at runtime of a given enumeration

00:21:54,290 --> 00:21:59,480
numerator value so then I can write a to

00:21:56,930 --> 00:22:02,150
string function for an enumerator again

00:21:59,480 --> 00:22:03,940
I can constrain it with concepts and now

00:22:02,150 --> 00:22:06,950
notice that there's a switch statement

00:22:03,940 --> 00:22:08,750
in the side which is a context per block

00:22:06,950 --> 00:22:11,500
which all it's doing is for every

00:22:08,750 --> 00:22:13,880
variable injects a case statement

00:22:11,500 --> 00:22:16,430
so once the compile time code has run

00:22:13,880 --> 00:22:18,950
what do you have switch case case case

00:22:16,430 --> 00:22:23,360
case case could you have written that by

00:22:18,950 --> 00:22:24,700
hand sure I won't even ask for the show

00:22:23,360 --> 00:22:26,720
of hands because I know many of you have

00:22:24,700 --> 00:22:30,470
then what happens when you add an

00:22:26,720 --> 00:22:32,630
enumerator right what happens when you

00:22:30,470 --> 00:22:34,220
change in a numerator value you know

00:22:32,630 --> 00:22:36,260
it's hard to keep these things in sync

00:22:34,220 --> 00:22:38,150
because you say something twice you will

00:22:36,260 --> 00:22:40,550
lie now we're in the future I mean we

00:22:38,150 --> 00:22:42,350
just can't help it authors of fiction

00:22:40,550 --> 00:22:43,760
novels can't even get there the middle

00:22:42,350 --> 00:22:46,910
initial of their main character straight

00:22:43,760 --> 00:22:51,680
from page 52 to page 123 right

00:22:46,910 --> 00:22:52,669
we will lie this will lie less because

00:22:51,680 --> 00:22:54,470
it asks what is

00:22:52,669 --> 00:22:56,720
the truth there's one source of truth

00:22:54,470 --> 00:22:58,700
which is the type system and man if you

00:22:56,720 --> 00:23:00,460
got to pick a source of truth type

00:22:58,700 --> 00:23:04,279
system is the one you want to pick and

00:23:00,460 --> 00:23:06,889
then ask it what is the truth about say

00:23:04,279 --> 00:23:09,440
this enumerator and now I can use this

00:23:06,889 --> 00:23:10,789
with with the various enumerations I

00:23:09,440 --> 00:23:13,879
have it again just like any other

00:23:10,789 --> 00:23:17,419
template we instantiate it only in the

00:23:13,879 --> 00:23:19,820
the programs that actually use it at

00:23:17,419 --> 00:23:22,159
compile time and only for the Doom's

00:23:19,820 --> 00:23:24,889
that are actually queried which is a

00:23:22,159 --> 00:23:26,929
nice feature to have much better than

00:23:24,889 --> 00:23:28,609
just injecting all the numerator names

00:23:26,929 --> 00:23:30,139
and making them into your XE just in

00:23:28,609 --> 00:23:32,480
case they might be used which is what we

00:23:30,139 --> 00:23:36,519
resort to you today because it's hard to

00:23:32,480 --> 00:23:39,289
be more precise about these things as

00:23:36,519 --> 00:23:40,429
soon as I talk about injection like this

00:23:39,289 --> 00:23:43,909
might have come up before but especially

00:23:40,429 --> 00:23:49,100
with injection the concern about

00:23:43,909 --> 00:23:50,840
injection is but what about being able

00:23:49,100 --> 00:23:54,619
to debug this what about being able to

00:23:50,840 --> 00:23:58,999
maintain it because if we go back to

00:23:54,619 --> 00:24:00,499
here I just showed you how to automate

00:23:58,999 --> 00:24:03,739
writing all your case labels how many of

00:24:00,499 --> 00:24:05,450
you thought that was pretty nice how

00:24:03,739 --> 00:24:09,109
many of you worried about that you can't

00:24:05,450 --> 00:24:11,239
see that code good that's a healthy

00:24:09,109 --> 00:24:15,139
reaction almost as many hands you should

00:24:11,239 --> 00:24:17,929
worry about that just like in many other

00:24:15,139 --> 00:24:20,090
places in the language even back to C

00:24:17,929 --> 00:24:22,940
and any language with abstractions

00:24:20,090 --> 00:24:24,470
already hides information so let's see

00:24:22,940 --> 00:24:27,919
what we do about it because we'll do the

00:24:24,470 --> 00:24:29,119
same thing here so we already do things

00:24:27,919 --> 00:24:32,179
that are less transparent there's two

00:24:29,119 --> 00:24:34,909
arguments to be made here as to why we

00:24:32,179 --> 00:24:36,379
should just go forward and pursue this

00:24:34,909 --> 00:24:38,600
direction even though there is a

00:24:36,379 --> 00:24:41,029
transparency issue the first thing is

00:24:38,600 --> 00:24:42,379
remember you're going to get sick and

00:24:41,029 --> 00:24:45,529
tired of me saying this but it's so

00:24:42,379 --> 00:24:47,749
important we are already doing this this

00:24:45,529 --> 00:24:50,659
is making code easier to write that we

00:24:47,749 --> 00:24:53,179
are already doing in nasty ways like

00:24:50,659 --> 00:24:54,769
template metaprogramming and even if

00:24:53,179 --> 00:24:58,039
this is hard to debug it will be less

00:24:54,769 --> 00:24:59,720
bad than the things we are doing now how

00:24:58,039 --> 00:25:03,230
many of you have debug template

00:24:59,720 --> 00:25:04,789
metaprogramming if you by the way just

00:25:03,230 --> 00:25:06,910
curious how many of you are in shops

00:25:04,789 --> 00:25:08,840
that do not allow

00:25:06,910 --> 00:25:11,480
non-library use of template

00:25:08,840 --> 00:25:12,920
metaprogramming production code like i

00:25:11,480 --> 00:25:14,900
said besides something you got like from

00:25:12,920 --> 00:25:15,950
boost they just don't allow you to write

00:25:14,900 --> 00:25:19,760
to have the matter programs in

00:25:15,950 --> 00:25:21,830
production code a few because of debug

00:25:19,760 --> 00:25:22,690
ability maintainability those kinds of

00:25:21,830 --> 00:25:25,520
things

00:25:22,690 --> 00:25:28,070
so it will be at least less bad even if

00:25:25,520 --> 00:25:30,560
we do nothing in tools but we already

00:25:28,070 --> 00:25:32,150
have cases like this for instance the

00:25:30,560 --> 00:25:34,610
compiler generated functions let's say

00:25:32,150 --> 00:25:37,280
you have a class type with you know ten

00:25:34,610 --> 00:25:41,480
members but I want to use compiler

00:25:37,280 --> 00:25:42,710
generated destructor assignment copy how

00:25:41,480 --> 00:25:44,810
many of you have already wished you

00:25:42,710 --> 00:25:47,900
could step into in the debugger and see

00:25:44,810 --> 00:25:49,250
what was going on in each of those how

00:25:47,900 --> 00:25:52,970
many of you actually have a tool that

00:25:49,250 --> 00:25:55,940
does that much smaller number they exist

00:25:52,970 --> 00:26:00,980
but yours I know is your own research

00:25:55,940 --> 00:26:02,660
project so yes exactly Peter so the you

00:26:00,980 --> 00:26:05,960
have so few hands that I could actually

00:26:02,660 --> 00:26:08,450
see individual faces to see who what

00:26:05,960 --> 00:26:10,640
tools they're using so we already have

00:26:08,450 --> 00:26:12,560
this problem and yet nobody is burned or

00:26:10,640 --> 00:26:13,730
bent out of shape saying oh we shouldn't

00:26:12,560 --> 00:26:16,820
have special member functions are too

00:26:13,730 --> 00:26:18,260
scary we like them they're convenient we

00:26:16,820 --> 00:26:21,380
could still have better tooling than we

00:26:18,260 --> 00:26:23,450
even have today so let me just take a

00:26:21,380 --> 00:26:26,300
moment before we switch to metaclasses

00:26:23,450 --> 00:26:28,490
for the rest of the talk so just talk

00:26:26,300 --> 00:26:30,230
about this general principle because I

00:26:28,490 --> 00:26:32,930
think it's worth I added these slides

00:26:30,230 --> 00:26:34,550
last night because this has already come

00:26:32,930 --> 00:26:36,560
up multiple times in the last two days

00:26:34,550 --> 00:26:38,750
of this conference including at the

00:26:36,560 --> 00:26:40,640
panel that we have on Monday night in

00:26:38,750 --> 00:26:41,810
hallway discussions and so let me just

00:26:40,640 --> 00:26:44,380
address one thing that I think is

00:26:41,810 --> 00:26:46,700
important to remember when we talk about

00:26:44,380 --> 00:26:52,160
language abstractions and especially

00:26:46,700 --> 00:26:57,350
tooling by definition abstractions are

00:26:52,160 --> 00:27:00,260
hiders they hide stuff it's what they're

00:26:57,350 --> 00:27:01,940
for if they didn't do that they would be

00:27:00,260 --> 00:27:04,670
useless they would not have the value

00:27:01,940 --> 00:27:07,520
that we have so it's not a problem it's

00:27:04,670 --> 00:27:09,170
the point now having said that you can

00:27:07,520 --> 00:27:12,500
use this to gloss over many things that

00:27:09,170 --> 00:27:14,150
should never be put into into languages

00:27:12,500 --> 00:27:17,270
I'll talk about that a little at the end

00:27:14,150 --> 00:27:18,950
but abstractions are good we cannot

00:27:17,270 --> 00:27:20,330
build our civilization without

00:27:18,950 --> 00:27:23,210
abstraction

00:27:20,330 --> 00:27:25,640
are so deep in the layers of software

00:27:23,210 --> 00:27:28,640
that we write we could never have scaled

00:27:25,640 --> 00:27:30,470
to what we have today without lots and

00:27:28,640 --> 00:27:31,730
lots of abstractions and we're see

00:27:30,470 --> 00:27:33,890
fossil shines as it makes those

00:27:31,730 --> 00:27:36,140
abstraction layers thinner more

00:27:33,890 --> 00:27:37,399
efficient which is why C++ will always

00:27:36,140 --> 00:27:39,620
have a future because we'll always be

00:27:37,399 --> 00:27:41,659
building bigger and deeper things where

00:27:39,620 --> 00:27:44,600
thinness of the layer matters that's

00:27:41,659 --> 00:27:48,559
where we shine but let's just go back to

00:27:44,600 --> 00:27:50,630
the 70s abstractions have always needed

00:27:48,559 --> 00:27:52,669
tools support so variables hide their

00:27:50,630 --> 00:27:54,409
values so in a tool yes you could do

00:27:52,669 --> 00:27:57,380
printf style debugging then you're just

00:27:54,409 --> 00:27:58,820
writing your own tool but any IDE will

00:27:57,380 --> 00:28:00,380
give you a watch window any debugger

00:27:58,820 --> 00:28:02,059
will give you a watch window so you can

00:28:00,380 --> 00:28:05,450
see the value why did you need that

00:28:02,059 --> 00:28:07,519
because the variable X nicely abstracts

00:28:05,450 --> 00:28:09,019
away its current value so you can just

00:28:07,519 --> 00:28:10,820
talk about the value in the abstract

00:28:09,019 --> 00:28:13,970
which is wonderful we've been doing this

00:28:10,820 --> 00:28:16,940
since the 50s it's really important but

00:28:13,970 --> 00:28:19,279
even that is an abstraction a function

00:28:16,940 --> 00:28:22,909
hides code notice the word hide appears

00:28:19,279 --> 00:28:24,260
all over the place now that's ok we just

00:28:22,909 --> 00:28:26,419
want to think about the documented

00:28:24,260 --> 00:28:28,519
semantics and not worry about the how it

00:28:26,419 --> 00:28:30,409
does the work but sometimes you want to

00:28:28,519 --> 00:28:32,149
step into especially when you're

00:28:30,409 --> 00:28:34,970
debugging your own functions in a

00:28:32,149 --> 00:28:37,340
cascade so you need go to definition you

00:28:34,970 --> 00:28:39,139
need step into in your debugger pointers

00:28:37,340 --> 00:28:40,519
hide in directions you need visualizers

00:28:39,139 --> 00:28:43,880
let you see what the data structure

00:28:40,519 --> 00:28:46,429
actually looks like include hides

00:28:43,880 --> 00:28:48,950
dependencies because include files could

00:28:46,429 --> 00:28:50,960
include other files so build systems

00:28:48,950 --> 00:28:52,490
need to be aware of that that's the

00:28:50,960 --> 00:28:54,230
first thing the second thing is they

00:28:52,490 --> 00:28:55,789
need to see when the file timestamp has

00:28:54,230 --> 00:28:58,220
been updated usually unless you're in a

00:28:55,789 --> 00:29:00,860
database repo or something like that so

00:28:58,220 --> 00:29:02,539
that they can say ah this changed and

00:29:00,860 --> 00:29:03,950
therefore based on the dependency graph

00:29:02,539 --> 00:29:07,220
I will go and build all these other

00:29:03,950 --> 00:29:08,630
things but we're not scared of these

00:29:07,220 --> 00:29:09,950
things we'd like to do better at some of

00:29:08,630 --> 00:29:11,720
them like include files but we're not

00:29:09,950 --> 00:29:14,720
scared of them they're very useful even

00:29:11,720 --> 00:29:16,549
though they do require build support C++

00:29:14,720 --> 00:29:19,010
has been very successful even in its

00:29:16,549 --> 00:29:20,899
early years for classes guess what they

00:29:19,010 --> 00:29:23,450
hide code and data it's the whole point

00:29:20,899 --> 00:29:25,730
we have built a whole generation of

00:29:23,450 --> 00:29:27,919
software tools on classes in many

00:29:25,730 --> 00:29:30,020
languages because it's good they

00:29:27,919 --> 00:29:31,909
abstract behavior they encapsulate

00:29:30,020 --> 00:29:33,470
behavior which means they hide code and

00:29:31,909 --> 00:29:34,160
data which means you need most of what

00:29:33,470 --> 00:29:37,669
we just talked to

00:29:34,160 --> 00:29:39,260
in your tools overloads hide static

00:29:37,669 --> 00:29:41,240
polymorphism I could have said templates

00:29:39,260 --> 00:29:42,530
but we always go for that one let's say

00:29:41,240 --> 00:29:43,850
overloads because that's another form

00:29:42,530 --> 00:29:46,010
people don't often think about that

00:29:43,850 --> 00:29:48,169
means we need better warning and error

00:29:46,010 --> 00:29:50,470
messages as if you've had compilers

00:29:48,169 --> 00:29:52,850
early on that didn't have them you know

00:29:50,470 --> 00:29:54,470
because you want to know oh I couldn't

00:29:52,850 --> 00:29:56,980
call this but here were the candidates

00:29:54,470 --> 00:29:59,419
right that's important to know

00:29:56,980 --> 00:30:01,370
virtual functions they hide dynamic

00:29:59,419 --> 00:30:02,090
polymorphism again a different kind of

00:30:01,370 --> 00:30:06,919
tool support

00:30:02,090 --> 00:30:10,039
so that's C++ up to about 1718 years ago

00:30:06,919 --> 00:30:11,450
in C 12 of 17 I could mention a few more

00:30:10,039 --> 00:30:13,760
things but along the way we've added

00:30:11,450 --> 00:30:18,260
more context Boro context for functions

00:30:13,760 --> 00:30:19,330
hide computations that can be done at

00:30:18,260 --> 00:30:21,710
compile time

00:30:19,330 --> 00:30:23,270
so with concept tree functions today

00:30:21,710 --> 00:30:24,590
because they could be compile time or

00:30:23,270 --> 00:30:27,320
run time you can fake it out by

00:30:24,590 --> 00:30:29,210
executing them as if at runtime but you

00:30:27,320 --> 00:30:32,000
basically are starting to see a need for

00:30:29,210 --> 00:30:35,450
compile time debug support why because

00:30:32,000 --> 00:30:37,760
that's where you're running your code if

00:30:35,450 --> 00:30:39,470
Const expert more of that we hide

00:30:37,760 --> 00:30:41,120
whether code even has to compile so just

00:30:39,470 --> 00:30:43,520
like you have your macro and debug and

00:30:41,120 --> 00:30:44,900
you you your IDE often Gray's out the

00:30:43,520 --> 00:30:46,400
code that isn't actually being built

00:30:44,900 --> 00:30:48,500
which is actually a useful thing to see

00:30:46,400 --> 00:30:50,270
I would expect tools to do the same

00:30:48,500 --> 00:30:52,340
thing with F Const expert because

00:30:50,270 --> 00:30:55,130
whatever appears in there isn't going to

00:30:52,340 --> 00:30:57,940
be compiled in an if Const X / false

00:30:55,130 --> 00:31:01,010
block so again we need to we'll support

00:30:57,940 --> 00:31:02,780
I'm spending so much time three four

00:31:01,010 --> 00:31:04,610
minutes talking about this because this

00:31:02,780 --> 00:31:06,740
is not a new problem and it's important

00:31:04,610 --> 00:31:08,990
to emphasize it's not a new problem so

00:31:06,740 --> 00:31:12,490
that oh darn I've run out of space let's

00:31:08,990 --> 00:31:14,750
fix that if we now go into the future

00:31:12,490 --> 00:31:17,630
modules I have heard even at this

00:31:14,750 --> 00:31:20,270
conference some angsting about well the

00:31:17,630 --> 00:31:21,650
modules are they are fundamentally

00:31:20,270 --> 00:31:24,110
different are they going to need more

00:31:21,650 --> 00:31:25,460
build system support sure half of that

00:31:24,110 --> 00:31:27,260
build system supports what we already

00:31:25,460 --> 00:31:28,789
have to know when a files touched yeah

00:31:27,260 --> 00:31:31,730
we do that with headers we can see where

00:31:28,789 --> 00:31:33,679
the compiled module has been touched yes

00:31:31,730 --> 00:31:36,679
we need to look inside modules to see

00:31:33,679 --> 00:31:40,130
which modules this module transitively

00:31:36,679 --> 00:31:42,590
uses yeah which is not that different

00:31:40,130 --> 00:31:43,970
from what we do for headers as well does

00:31:42,590 --> 00:31:47,630
the build system need to be aware of it

00:31:43,970 --> 00:31:49,790
absolutely but notice again

00:31:47,630 --> 00:31:52,760
like the header the module in a better

00:31:49,790 --> 00:31:55,790
way is an abstraction it hides stuff

00:31:52,760 --> 00:31:57,830
this is the point of modules it bundles

00:31:55,790 --> 00:32:00,050
stuff up it doesn't mean you can't look

00:31:57,830 --> 00:32:02,660
at it you can go in and look at it but

00:32:00,050 --> 00:32:04,070
it gives you an abstraction and so we

00:32:02,660 --> 00:32:06,980
need to support for that this is not

00:32:04,070 --> 00:32:09,590
surprising compile time variables

00:32:06,980 --> 00:32:11,390
compile time functions just like regular

00:32:09,590 --> 00:32:12,980
variables and functions we need to we'll

00:32:11,390 --> 00:32:15,530
support for those but they need to be

00:32:12,980 --> 00:32:17,420
able to run at compile time and when we

00:32:15,530 --> 00:32:19,250
talk about injection now this brings us

00:32:17,420 --> 00:32:22,220
all the way back to our previous slide

00:32:19,250 --> 00:32:24,620
when we talk about injection and meta

00:32:22,220 --> 00:32:27,110
classes which depend on compile time

00:32:24,620 --> 00:32:29,210
computation and injection we are

00:32:27,110 --> 00:32:31,190
generating stuff so we need to visualize

00:32:29,210 --> 00:32:33,230
that and I'll show an example as we go

00:32:31,190 --> 00:32:34,730
but remember the thing at the very top

00:32:33,230 --> 00:32:38,210
don't lose sight of the title of this

00:32:34,730 --> 00:32:41,750
slide abstractions are hiders this is a

00:32:38,210 --> 00:32:44,330
feature not a bug it's the point and it

00:32:41,750 --> 00:32:46,490
does mean the the tool support now I

00:32:44,330 --> 00:32:50,210
promise at the end of the slide to put

00:32:46,490 --> 00:32:51,980
make one caveat good abstractions also

00:32:50,210 --> 00:32:54,530
need to be toolable this is a two-way

00:32:51,980 --> 00:32:57,020
contract please do not use everything I

00:32:54,530 --> 00:32:59,180
just said to justify some awful

00:32:57,020 --> 00:33:00,560
languages feature design that is not a

00:32:59,180 --> 00:33:02,930
cohesive abstraction that is

00:33:00,560 --> 00:33:05,300
undisciplined and say yeah of tools

00:33:02,930 --> 00:33:07,520
should just make it better like for

00:33:05,300 --> 00:33:09,710
instance with if Const expert the

00:33:07,520 --> 00:33:11,390
Standards Committee was very careful to

00:33:09,710 --> 00:33:13,100
make sure that you couldn't just

00:33:11,390 --> 00:33:15,560
generate arbitrary source text like

00:33:13,100 --> 00:33:17,720
let's generate half a class and then

00:33:15,560 --> 00:33:19,670
stop or generate the back end of a class

00:33:17,720 --> 00:33:20,630
close the current class open another one

00:33:19,670 --> 00:33:24,470
and do something else

00:33:20,630 --> 00:33:27,740
in a single if context per block that's

00:33:24,470 --> 00:33:30,890
not scoped it's not nested so it was

00:33:27,740 --> 00:33:33,110
very careful to make sure that an if

00:33:30,890 --> 00:33:35,300
cost per block was a scope and we had

00:33:33,110 --> 00:33:38,240
very clear rules about the scope guess

00:33:35,300 --> 00:33:40,310
what that makes it more toolable so you

00:33:38,240 --> 00:33:41,720
please do not use the oh you know yeah

00:33:40,310 --> 00:33:44,420
you're never have to write tools anyway

00:33:41,720 --> 00:33:46,520
though it's those lazy tool writers it's

00:33:44,420 --> 00:33:49,550
their job they'll use that as an excuse

00:33:46,520 --> 00:33:51,350
for a bad language feature a good

00:33:49,550 --> 00:33:54,350
abstraction however does have a

00:33:51,350 --> 00:33:56,240
responsibility to also answer is this

00:33:54,350 --> 00:33:58,610
gonna be right only code or is it gonna

00:33:56,240 --> 00:34:00,620
be code I can debug and maintain so it

00:33:58,610 --> 00:34:02,180
has to be toolable

00:34:00,620 --> 00:34:04,130
and then we can reasonably say okay

00:34:02,180 --> 00:34:06,380
let's make sure we build the tools for

00:34:04,130 --> 00:34:08,210
that and the closer we can show how it's

00:34:06,380 --> 00:34:12,250
similar to things we were already doing

00:34:08,210 --> 00:34:15,770
in tools the better so having said that

00:34:12,250 --> 00:34:17,780
let's now move to the back part of the

00:34:15,770 --> 00:34:20,570
talk where I'm going to assume all of

00:34:17,780 --> 00:34:22,820
those things exist and the question that

00:34:20,570 --> 00:34:27,080
I was interested in and the piece of my

00:34:22,820 --> 00:34:30,710
broader simplifying C++ exploration that

00:34:27,080 --> 00:34:33,620
I'm bringing forward here is how can we

00:34:30,710 --> 00:34:36,440
get rid of things like compile time code

00:34:33,620 --> 00:34:37,639
by convention by tools that weren't

00:34:36,440 --> 00:34:39,290
designed for it like template

00:34:37,639 --> 00:34:41,000
metaprogramming just because they happen

00:34:39,290 --> 00:34:43,760
to be turing-complete doesn't mean you

00:34:41,000 --> 00:34:48,350
have to try and complete them and how

00:34:43,760 --> 00:34:50,570
can we use that to make C++ code simpler

00:34:48,350 --> 00:34:54,620
again focusing on things we already are

00:34:50,570 --> 00:34:58,540
doing just harder so the idea of

00:34:54,620 --> 00:35:01,700
metaclasses is covered in my paper Pio

00:34:58,540 --> 00:35:03,740
707 many reviewers thank you to them and

00:35:01,700 --> 00:35:04,670
a special thanks to Anderson where are

00:35:03,740 --> 00:35:09,200
you and ER can you

00:35:04,670 --> 00:35:11,420
yellow wave yo in the back thank you and

00:35:09,200 --> 00:35:13,700
Raqqah because besides being mr.

00:35:11,420 --> 00:35:16,760
concepts implementer having written the

00:35:13,700 --> 00:35:18,380
concepts implementation in GCC he is now

00:35:16,760 --> 00:35:20,690
actively doing the metaclasses

00:35:18,380 --> 00:35:22,100
implementation in clang so thank you

00:35:20,690 --> 00:35:23,540
very much to all the reviewers and to

00:35:22,100 --> 00:35:26,560
Andrew for all their help on everything

00:35:23,540 --> 00:35:26,560
about the presenter

00:35:28,980 --> 00:35:32,770
I'll give you links at the end to a

00:35:31,180 --> 00:35:34,420
couple of Hawks Andrews giving about the

00:35:32,770 --> 00:35:35,710
implementation details they're not so

00:35:34,420 --> 00:35:37,420
much about the use but about the

00:35:35,710 --> 00:35:39,340
implementation details this afternoon

00:35:37,420 --> 00:35:41,590
and tomorrow morning look for those in

00:35:39,340 --> 00:35:43,150
your schedule too if you care about the

00:35:41,590 --> 00:35:44,290
implementation detail side of things I

00:35:43,150 --> 00:35:45,640
know there are a lot of client hackers

00:35:44,290 --> 00:35:50,170
in the room so you'll find that

00:35:45,640 --> 00:35:51,760
interesting but the most important shot

00:35:50,170 --> 00:35:53,260
out I want to give is to somebody who I

00:35:51,760 --> 00:35:55,450
think is not currently in the room

00:35:53,260 --> 00:35:57,730
because he had to take a flight right

00:35:55,450 --> 00:36:01,390
now but I want to especially ignore much

00:35:57,730 --> 00:36:04,090
be honest rooster nothing I am about to

00:36:01,390 --> 00:36:07,360
tell you would be possible if he had not

00:36:04,090 --> 00:36:10,900
held the Lord in a principled strong way

00:36:07,360 --> 00:36:12,370
on a unified type system in C++

00:36:10,900 --> 00:36:14,080
let me talk about that for a second so

00:36:12,370 --> 00:36:16,000
here's a movie that's playing everywhere

00:36:14,080 --> 00:36:17,020
in theaters okay it's not actually not

00:36:16,000 --> 00:36:19,060
going to talk about James and the Giant

00:36:17,020 --> 00:36:21,490
Peach I'm gonna talk about bjorna and

00:36:19,060 --> 00:36:24,910
the unified universe because when we

00:36:21,490 --> 00:36:26,950
take a look at the whole universe of all

00:36:24,910 --> 00:36:29,440
these C++ types that we can express

00:36:26,950 --> 00:36:30,760
there are so many we talk about value

00:36:29,440 --> 00:36:32,170
types they're the ones that are favored

00:36:30,760 --> 00:36:33,760
by default with the special member

00:36:32,170 --> 00:36:36,310
functions that get generated by the

00:36:33,760 --> 00:36:39,160
language but we have plain old data

00:36:36,310 --> 00:36:40,960
structs they're blessed with a name in

00:36:39,160 --> 00:36:42,730
the standard although you know you can't

00:36:40,960 --> 00:36:45,910
actually quite see them in source code

00:36:42,730 --> 00:36:48,520
as clearly but people write calm classes

00:36:45,910 --> 00:36:50,680
they write functors callable types a

00:36:48,520 --> 00:36:53,200
very different thing but it's still just

00:36:50,680 --> 00:36:55,090
a class a single inheritance Base Class

00:36:53,200 --> 00:36:57,550
obeys different rules we write down what

00:36:55,090 --> 00:36:59,110
the rules are in English but it's just a

00:36:57,550 --> 00:37:01,810
Class C fossil sort does not have a

00:36:59,110 --> 00:37:04,150
separate interface concept for that we

00:37:01,810 --> 00:37:07,900
write expression templates properties

00:37:04,150 --> 00:37:13,030
korba interfaces any variant so some

00:37:07,900 --> 00:37:17,230
types product types it is fundamentally

00:37:13,030 --> 00:37:20,850
a strength of C++ that every single one

00:37:17,230 --> 00:37:23,380
of these can be expressed as a class

00:37:20,850 --> 00:37:27,130
that we have not bifurcated the type

00:37:23,380 --> 00:37:29,740
system and nothing I'm about to say

00:37:27,130 --> 00:37:31,360
would be possible without that the the

00:37:29,740 --> 00:37:33,850
trouble is that right now we're writing

00:37:31,360 --> 00:37:35,680
all of these things and much more but

00:37:33,850 --> 00:37:36,880
we're doing it by convention so some of

00:37:35,680 --> 00:37:38,140
these are documented in the core

00:37:36,880 --> 00:37:41,140
guidelines as to how you should write

00:37:38,140 --> 00:37:43,269
them or in Scots or my books or others

00:37:41,140 --> 00:37:49,660
and we described them in English instead

00:37:43,269 --> 00:37:52,990
of as code can we do better so the goal

00:37:49,660 --> 00:37:55,839
of metaclasses in a nutshell is to give

00:37:52,990 --> 00:38:02,200
a name a name is a word of power if it's

00:37:55,839 --> 00:38:04,420
compiled about to give a name to a

00:38:02,200 --> 00:38:06,450
specific subset of the universe of

00:38:04,420 --> 00:38:08,980
classes that have common characteristics

00:38:06,450 --> 00:38:11,470
what common characteristics I want to

00:38:08,980 --> 00:38:13,539
express those using compiled time code

00:38:11,470 --> 00:38:17,799
all the stuff we just had a very brief

00:38:13,539 --> 00:38:19,930
overview of a moment ago and the goal is

00:38:17,799 --> 00:38:21,730
to make classes easier to write because

00:38:19,930 --> 00:38:24,700
I don't have to remember English rules I

00:38:21,730 --> 00:38:26,260
don't have to override the universal

00:38:24,700 --> 00:38:28,960
defaults for what gets generated for me

00:38:26,260 --> 00:38:32,529
to make them appropriate for my kind of

00:38:28,960 --> 00:38:34,029
class in fact every single meta class

00:38:32,529 --> 00:38:35,170
that we should write this and this is

00:38:34,029 --> 00:38:37,269
important especially to committee

00:38:35,170 --> 00:38:39,250
members who worry about opt in we often

00:38:37,269 --> 00:38:41,019
talk about new features and oh can we

00:38:39,250 --> 00:38:42,730
make them retroactive to old code no we

00:38:41,019 --> 00:38:44,430
want people to opt in so they know what

00:38:42,730 --> 00:38:47,829
they're getting

00:38:44,430 --> 00:38:51,490
every metaclass you write is a single

00:38:47,829 --> 00:38:53,259
word that is a bundle of opt-ins that is

00:38:51,490 --> 00:38:55,750
a powerful thing to be able to write and

00:38:53,259 --> 00:38:59,460
customize yourself because you are

00:38:55,750 --> 00:39:02,859
saying I want this and now a lot of the

00:38:59,460 --> 00:39:04,720
stress and anxiety about providing

00:39:02,859 --> 00:39:08,500
useful things by default but what if

00:39:04,720 --> 00:39:10,329
they weren't needed melts away because

00:39:08,500 --> 00:39:12,069
the user asked for it so a very

00:39:10,329 --> 00:39:14,559
important contribution I hope of

00:39:12,069 --> 00:39:19,210
metaclasses is to have a generalized way

00:39:14,559 --> 00:39:21,220
of writing and opt-in to say I want this

00:39:19,210 --> 00:39:24,250
and you know what what you say you want

00:39:21,220 --> 00:39:26,589
it then we can go wild and help you it's

00:39:24,250 --> 00:39:31,529
about helping the developer express

00:39:26,589 --> 00:39:35,200
intent let's see the nutshell example I

00:39:31,529 --> 00:39:36,880
want to write a metaclass is a very very

00:39:35,200 --> 00:39:38,950
simple thing this is the current vision

00:39:36,880 --> 00:39:40,299
we're we're trying and evolving it and

00:39:38,950 --> 00:39:41,410
I'm sure it's going to be sure and

00:39:40,299 --> 00:39:42,789
especially with feedback from the

00:39:41,410 --> 00:39:44,920
committee who saw this for the first

00:39:42,789 --> 00:39:46,359
time a couple of months ago in July and

00:39:44,920 --> 00:39:49,329
we're going to continue to improve this

00:39:46,359 --> 00:39:51,549
this is a multi-year effort no it's not

00:39:49,329 --> 00:39:53,410
in C+ less 20 my goodness no this is

00:39:51,549 --> 00:39:55,140
look this is incubating still it's not

00:39:53,410 --> 00:39:57,990
lift the a first proposal to

00:39:55,140 --> 00:40:00,450
to evolution yet it's incubating but I

00:39:57,990 --> 00:40:02,370
hope it's promising so everything may

00:40:00,450 --> 00:40:04,470
change but the current idea is its

00:40:02,370 --> 00:40:06,870
accustomed transformation from the

00:40:04,470 --> 00:40:09,570
source code you write to an ordinary

00:40:06,870 --> 00:40:11,310
class definition now let me explain what

00:40:09,570 --> 00:40:14,040
I mean by that because we already have

00:40:11,310 --> 00:40:16,220
it except I can't write it myself I have

00:40:14,040 --> 00:40:19,680
to be a compiler writer today or a

00:40:16,220 --> 00:40:22,050
standards proposal writer in the

00:40:19,680 --> 00:40:26,070
language today I write class point into

00:40:22,050 --> 00:40:29,490
X comma Y or I write struct my class :

00:40:26,070 --> 00:40:31,550
base void F I have all sorts of language

00:40:29,490 --> 00:40:35,790
rules that apply class point

00:40:31,550 --> 00:40:37,830
automatically gets X and y be private so

00:40:35,790 --> 00:40:39,990
I didn't write an access specifier but I

00:40:37,830 --> 00:40:43,140
get one as if I had written it right we

00:40:39,990 --> 00:40:44,370
know these are the rules oh by the way I

00:40:43,140 --> 00:40:46,110
didn't say anything that would prevent

00:40:44,370 --> 00:40:47,580
generating the special member function

00:40:46,110 --> 00:40:50,130
so I get a default constructor a

00:40:47,580 --> 00:40:52,230
destructor a copy constructor a copy

00:40:50,130 --> 00:40:56,820
assignment operator a move constructor a

00:40:52,230 --> 00:41:00,780
move assignment operator for free this

00:40:56,820 --> 00:41:03,510
is great unless you didn't want them but

00:41:00,780 --> 00:41:05,460
here I do so this is great and it's done

00:41:03,510 --> 00:41:08,370
for me I didn't have to write all that

00:41:05,460 --> 00:41:11,940
stuff this is a feature not a bug with

00:41:08,370 --> 00:41:13,640
my class I inherit publicly by default

00:41:11,940 --> 00:41:17,070
from the base because I said struct and

00:41:13,640 --> 00:41:21,210
notice that the function f is virtual if

00:41:17,070 --> 00:41:23,310
it happens to have a signature the same

00:41:21,210 --> 00:41:24,540
signature of virtual in the base so I

00:41:23,310 --> 00:41:26,670
didn't write virtual here but I

00:41:24,540 --> 00:41:29,250
implicitly get virtual because I

00:41:26,670 --> 00:41:31,800
inherited from the base class like or

00:41:29,250 --> 00:41:33,030
hate that feature it can be useful and

00:41:31,800 --> 00:41:35,220
it is something the language already

00:41:33,030 --> 00:41:37,380
does for us so when you think of this

00:41:35,220 --> 00:41:41,190
here's what I wrote in source and here

00:41:37,380 --> 00:41:42,510
is the actual definition of the type you

00:41:41,190 --> 00:41:45,420
can think of it as if the compiler

00:41:42,510 --> 00:41:47,790
executed this italicized pseudocode for

00:41:45,420 --> 00:41:49,320
each member if there's no access

00:41:47,790 --> 00:41:51,090
specifier then oh if they said class

00:41:49,320 --> 00:41:53,610
make it private otherwise if they said

00:41:51,090 --> 00:41:55,290
struck make it public oh by the way for

00:41:53,610 --> 00:41:57,960
every function if it's virtual in the

00:41:55,290 --> 00:42:00,750
base class and it's not defined as

00:41:57,960 --> 00:42:03,630
virtual here then make it virtual if

00:42:00,750 --> 00:42:06,880
it's virtual if it's not virtual in the

00:42:03,630 --> 00:42:10,160
base class but they said override here

00:42:06,880 --> 00:42:11,750
they named it an error you wrote a

00:42:10,160 --> 00:42:13,580
function that says override but it does

00:42:11,750 --> 00:42:16,120
not actually override a function in the

00:42:13,580 --> 00:42:18,440
base class right and so on

00:42:16,120 --> 00:42:22,010
all of these rules in the middle are

00:42:18,440 --> 00:42:23,660
already things we use every day they're

00:42:22,010 --> 00:42:25,820
in the standard they're in compilers

00:42:23,660 --> 00:42:28,790
today they are written the standard ease

00:42:25,820 --> 00:42:29,330
and they are implemented by compiler

00:42:28,790 --> 00:42:33,590
writers

00:42:29,330 --> 00:42:35,720
I like standardise but only a few dozen

00:42:33,590 --> 00:42:38,330
people in the world can write it I'm not

00:42:35,720 --> 00:42:41,060
always one of them I rely on people like

00:42:38,330 --> 00:42:44,110
gents and Richard so do most of the

00:42:41,060 --> 00:42:47,450
Committee for core wording standardise I

00:42:44,110 --> 00:42:51,350
like compiler writers but there are only

00:42:47,450 --> 00:42:53,690
a few hundred of them in the world what

00:42:51,350 --> 00:42:56,900
I would like to do is to be able to have

00:42:53,690 --> 00:43:00,080
more people in a disciplined way not not

00:42:56,900 --> 00:43:03,470
in a free range all rules are off wild

00:43:00,080 --> 00:43:07,220
west way but in a disciplined way be

00:43:03,470 --> 00:43:11,030
able to write just that code and give it

00:43:07,220 --> 00:43:13,640
a name so is it true that C pluses

00:43:11,030 --> 00:43:16,130
defaults are all wrong people say this

00:43:13,640 --> 00:43:17,990
sometimes and they're right when they're

00:43:16,130 --> 00:43:20,120
writing a kind of class that wasn't

00:43:17,990 --> 00:43:23,000
intended as the common case when we pick

00:43:20,120 --> 00:43:25,640
the default so really the main problem

00:43:23,000 --> 00:43:27,830
with C pluses defaults in many cases is

00:43:25,640 --> 00:43:29,030
that especially the class-based ones

00:43:27,830 --> 00:43:34,100
that I just described in the middle

00:43:29,030 --> 00:43:37,160
there is it's one size fits all the

00:43:34,100 --> 00:43:39,920
class like every single class has this

00:43:37,160 --> 00:43:42,980
same set of rules and defaults even if

00:43:39,920 --> 00:43:44,720
it's a functor or a combi sclab or a

00:43:42,980 --> 00:43:46,700
plain old data struct I couldn't say

00:43:44,720 --> 00:43:48,860
those things and that means I have to

00:43:46,700 --> 00:43:50,420
equals default or equals delete the

00:43:48,860 --> 00:43:52,400
things that did or didn't get generated

00:43:50,420 --> 00:43:55,010
that I actually wanted when I when the

00:43:52,400 --> 00:43:58,070
single heuristic for the whole universe

00:43:55,010 --> 00:44:01,190
of classes guessed wrong right so if you

00:43:58,070 --> 00:44:03,770
can only pick one rule for everyone in a

00:44:01,190 --> 00:44:05,300
diverse universe it's gonna be wrong at

00:44:03,770 --> 00:44:07,490
a lot of the time that's why we have

00:44:05,300 --> 00:44:11,300
equals default equals delete for the

00:44:07,490 --> 00:44:13,790
purposes of opting in and out so instead

00:44:11,300 --> 00:44:16,760
the key question is what if you could

00:44:13,790 --> 00:44:18,800
write your own code here and give a name

00:44:16,760 --> 00:44:20,420
to a group of defaults and behaviors and

00:44:18,800 --> 00:44:22,520
you can people

00:44:20,420 --> 00:44:23,780
sometimes said oh I what kind of code is

00:44:22,520 --> 00:44:26,510
this is so strange

00:44:23,780 --> 00:44:28,190
it's code put it in the library put it

00:44:26,510 --> 00:44:30,410
in a namespace do all the things we

00:44:28,190 --> 00:44:31,910
already do with code share it on github

00:44:30,410 --> 00:44:34,010
then compile it with somebody else's

00:44:31,910 --> 00:44:37,880
compiler that supports this language

00:44:34,010 --> 00:44:40,070
feature that's the intention again I

00:44:37,880 --> 00:44:43,070
want to be clear about we are proposing

00:44:40,070 --> 00:44:45,410
and what we aren't proposing only

00:44:43,070 --> 00:44:49,010
participating in interpreting the source

00:44:45,410 --> 00:44:53,300
code definition that you wrote and what

00:44:49,010 --> 00:44:57,890
gets generated as the definition the one

00:44:53,300 --> 00:45:00,110
definition of the type we are not trying

00:44:57,890 --> 00:45:02,120
to make this immutable language that

00:45:00,110 --> 00:45:04,610
would be madness or at least if it's not

00:45:02,120 --> 00:45:05,990
I don't want to explore and I'm not

00:45:04,610 --> 00:45:07,970
interested in going there and seeing

00:45:05,990 --> 00:45:10,820
whether it's really as crazy as it looks

00:45:07,970 --> 00:45:12,740
I could get what I want without that so

00:45:10,820 --> 00:45:16,930
I'm not interested in exploring that I

00:45:12,740 --> 00:45:19,820
am also supremely uninterested in

00:45:16,930 --> 00:45:23,210
violating the odr the one definition

00:45:19,820 --> 00:45:25,550
rule is great a c+ benefits strongly

00:45:23,210 --> 00:45:27,170
from it BR and it was very wise to

00:45:25,550 --> 00:45:29,810
insist on that from the early days of

00:45:27,170 --> 00:45:31,940
C++ now it is paying off in spades with

00:45:29,810 --> 00:45:35,900
new features like modules that really

00:45:31,940 --> 00:45:38,060
rely on the one definition rule so when

00:45:35,900 --> 00:45:40,460
we generate something it's just a class

00:45:38,060 --> 00:45:43,250
what we generated from is just the

00:45:40,460 --> 00:45:44,930
normal C++ grammar except that instead

00:45:43,250 --> 00:45:46,580
of the word class I could put in

00:45:44,930 --> 00:45:48,680
something more specific that's the only

00:45:46,580 --> 00:45:51,440
grammar change other than that I want to

00:45:48,680 --> 00:45:57,230
leave the language alone and let it

00:45:51,440 --> 00:45:59,150
evolve orthogonal e so give a name to a

00:45:57,230 --> 00:46:01,850
group of related classes that have

00:45:59,150 --> 00:46:04,460
common behavior give it a single hook

00:46:01,850 --> 00:46:07,760
that is a translation customization from

00:46:04,460 --> 00:46:09,710
source to definition and I hope that

00:46:07,760 --> 00:46:11,000
this could replace many uses along with

00:46:09,710 --> 00:46:12,710
the other features that we saw of

00:46:11,000 --> 00:46:15,110
template metaprogramming macros and

00:46:12,710 --> 00:46:17,510
non-portable language extensions it's

00:46:15,110 --> 00:46:19,940
not an open grammar not a way to violate

00:46:17,510 --> 00:46:21,830
the odr and it is not specific to object

00:46:19,940 --> 00:46:23,030
orientation or virtual functions even

00:46:21,830 --> 00:46:24,980
though that's the first example I'll

00:46:23,030 --> 00:46:27,740
show most of the examples I already

00:46:24,980 --> 00:46:31,070
cited have nothing to do with oo but see

00:46:27,740 --> 00:46:33,369
pulse does do oo and this is C++ so you

00:46:31,070 --> 00:46:36,290
can use it for that too

00:46:33,369 --> 00:46:38,480
so the current idea is that I can write

00:46:36,290 --> 00:46:40,609
instead of a class $1 class that's the

00:46:38,480 --> 00:46:42,530
current syntax tree of meta class and it

00:46:40,609 --> 00:46:45,380
contains the rules as a context for

00:46:42,530 --> 00:46:46,880
block of compiled time code of the

00:46:45,380 --> 00:46:48,619
things to apply to whatever the source

00:46:46,880 --> 00:46:51,050
code was that I wrote and then I can

00:46:48,619 --> 00:46:53,359
apply it in the place of the word class

00:46:51,050 --> 00:46:56,450
to say interface shape for example

00:46:53,359 --> 00:46:59,210
instead of class shape and if my dollar

00:46:56,450 --> 00:47:01,550
class interface had all the rules to

00:46:59,210 --> 00:47:03,560
require that functions be public and

00:47:01,550 --> 00:47:07,580
virtual make them that way by default

00:47:03,560 --> 00:47:09,710
make sure there's no data then when I

00:47:07,580 --> 00:47:13,190
say interface shape I am opting in see

00:47:09,710 --> 00:47:15,500
there's that big red opt-in button that

00:47:13,190 --> 00:47:18,349
says I want all of that and all I had to

00:47:15,500 --> 00:47:20,180
write was one word that's convenient

00:47:18,349 --> 00:47:21,920
it's important to opt in be explicit

00:47:20,180 --> 00:47:24,080
what we also want to make it convenient

00:47:21,920 --> 00:47:25,820
the best way you can do that is to get

00:47:24,080 --> 00:47:28,580
people a way to write a customized

00:47:25,820 --> 00:47:30,890
opt-in and then if I say interface shape

00:47:28,580 --> 00:47:32,599
then I get those defaults my functions

00:47:30,890 --> 00:47:34,550
are public and virtual by default I

00:47:32,599 --> 00:47:36,950
can't write anything other than that and

00:47:34,550 --> 00:47:39,650
the typical things that meta classes are

00:47:36,950 --> 00:47:41,990
used for in our experiments so far have

00:47:39,650 --> 00:47:44,660
been to enforce rules to provide

00:47:41,990 --> 00:47:47,030
defaults and to provide generated

00:47:44,660 --> 00:47:50,000
functions many of the things already

00:47:47,030 --> 00:47:55,609
done in the language with just the word

00:47:50,000 --> 00:47:57,290
class so here isn't an example of how we

00:47:55,609 --> 00:47:58,810
write code today and how I would like to

00:47:57,290 --> 00:48:01,609
be able to write it in the future

00:47:58,810 --> 00:48:04,070
today we write interfaces just fine we

00:48:01,609 --> 00:48:06,230
call them abstract base classes ABCs and

00:48:04,070 --> 00:48:08,599
they even have a cutesy name because

00:48:06,230 --> 00:48:10,430
we're so notice we're trying to give

00:48:08,599 --> 00:48:14,359
them a name even though I can't say the

00:48:10,430 --> 00:48:16,369
name in code yet today the name reminds

00:48:14,359 --> 00:48:18,950
us of the pattern we learned as English

00:48:16,369 --> 00:48:21,500
and that may be a linter will help us

00:48:18,950 --> 00:48:24,440
with but I just remember I make every

00:48:21,500 --> 00:48:26,780
single function public I write virtual I

00:48:24,440 --> 00:48:29,300
write equals 0 I have a virtual

00:48:26,780 --> 00:48:31,430
destructor let's make it know except

00:48:29,300 --> 00:48:34,040
while we're at it and then I am very

00:48:31,430 --> 00:48:36,170
careful not to write a data member a non

00:48:34,040 --> 00:48:38,119
public function and on virtual function

00:48:36,170 --> 00:48:40,160
and I have to make sure that my future

00:48:38,119 --> 00:48:43,040
self who's maintaining this or their

00:48:40,160 --> 00:48:44,420
successor keeps the rule so today what

00:48:43,040 --> 00:48:45,410
happens if under maintenance I actually

00:48:44,420 --> 00:48:48,020
acts

00:48:45,410 --> 00:48:51,830
we add a data member on the left hand

00:48:48,020 --> 00:48:54,140
side code compiles and runs it's not

00:48:51,830 --> 00:48:55,790
what I wanted though it may mess with

00:48:54,140 --> 00:48:58,070
the size and alignment of things in a

00:48:55,790 --> 00:48:59,810
way I hadn't expected or it may just

00:48:58,070 --> 00:49:03,470
violate the fact if I have a non-virtual

00:48:59,810 --> 00:49:04,940
function that may violate semantics but

00:49:03,470 --> 00:49:06,200
I don't have a way to write that unless

00:49:04,940 --> 00:49:08,030
I want to resort to writing lots of

00:49:06,200 --> 00:49:11,290
static asserts and nobody does that with

00:49:08,030 --> 00:49:14,240
reflection the proposed ways to write

00:49:11,290 --> 00:49:16,160
interface shape and then write your

00:49:14,240 --> 00:49:18,170
functions notice I did not write public

00:49:16,160 --> 00:49:19,760
because it's public by default I did not

00:49:18,170 --> 00:49:22,580
write virtual because it's virtual by

00:49:19,760 --> 00:49:24,470
default and I could enforce that I

00:49:22,580 --> 00:49:27,020
didn't write any data members copy/move

00:49:24,470 --> 00:49:30,320
that kind of thing here is how it looks

00:49:27,020 --> 00:49:32,810
in code and again standard disclaimer

00:49:30,320 --> 00:49:35,420
this is strawman syntax so by dollar

00:49:32,810 --> 00:49:38,420
class interface first declares the

00:49:35,420 --> 00:49:39,620
destructor and then has this cost extra

00:49:38,420 --> 00:49:41,270
block I just showed you before it so

00:49:39,620 --> 00:49:43,160
it's building on these other proposals

00:49:41,270 --> 00:49:44,900
that we hope to get anyway and says well

00:49:43,160 --> 00:49:48,230
how can I use them now I want to write

00:49:44,900 --> 00:49:50,150
compile time code which requires that

00:49:48,230 --> 00:49:52,490
reflect on interface or reflect on

00:49:50,150 --> 00:49:54,380
myself is the the current syntax for

00:49:52,490 --> 00:49:57,410
that that I have no data members

00:49:54,380 --> 00:50:00,200
variables is empty otherwise I will omit

00:49:57,410 --> 00:50:02,420
a compile time error which can be

00:50:00,200 --> 00:50:04,220
integrated with the compilers native

00:50:02,420 --> 00:50:06,200
error handling and controlled by the

00:50:04,220 --> 00:50:09,230
same switches if you are writing a

00:50:06,200 --> 00:50:12,080
compiler extension here interfaces may

00:50:09,230 --> 00:50:14,300
not contain data members for every

00:50:12,080 --> 00:50:16,760
function require that it's not copy or

00:50:14,300 --> 00:50:18,650
move otherwise say interfaces may not

00:50:16,760 --> 00:50:20,950
copy or move consider a virtual clone

00:50:18,650 --> 00:50:24,170
you can be creative this is a good thing

00:50:20,950 --> 00:50:28,520
if it doesn't have an access specifier

00:50:24,170 --> 00:50:32,330
make it public and then require that

00:50:28,520 --> 00:50:37,220
it's public and make it pure virtual so

00:50:32,330 --> 00:50:41,030
then when I say interface shape that

00:50:37,220 --> 00:50:42,950
meta program runs on the things that I

00:50:41,030 --> 00:50:46,630
wrote the declarations in the scope of

00:50:42,950 --> 00:50:46,630
shape that's the idea

00:50:48,950 --> 00:50:52,490
one of the nice things I think about

00:50:50,660 --> 00:50:54,560
this is I didn't write any standardise

00:50:52,490 --> 00:50:56,180
no standardise was harmed no core

00:50:54,560 --> 00:50:59,600
wording was harmed in the making of this

00:50:56,180 --> 00:51:01,130
code once we have the feature I can

00:50:59,600 --> 00:51:03,020
write this and put it in github and have

00:51:01,130 --> 00:51:05,090
you try it out and debug it for me I can

00:51:03,020 --> 00:51:06,920
use debugging tools I can write unit

00:51:05,090 --> 00:51:10,340
tests for this which I cannot write for

00:51:06,920 --> 00:51:12,680
standardise I can do this on my own on a

00:51:10,340 --> 00:51:14,300
weekend much faster than writing a paper

00:51:12,680 --> 00:51:16,850
and going to a committee meeting and

00:51:14,300 --> 00:51:18,860
then trying to get it through evolution

00:51:16,850 --> 00:51:23,570
and core and then wait for my compiler

00:51:18,860 --> 00:51:26,810
to implement it years later and my claim

00:51:23,570 --> 00:51:29,480
my hope but I'll say claim because I

00:51:26,810 --> 00:51:32,240
believe I have evidence that this is

00:51:29,480 --> 00:51:36,290
going to pan out is that it is without

00:51:32,240 --> 00:51:39,590
loss of usability expressiveness error

00:51:36,290 --> 00:51:41,720
message quality or performance even

00:51:39,590 --> 00:51:45,460
compared to other languages that build

00:51:41,720 --> 00:51:50,300
the feature in as a first-class entity

00:51:45,460 --> 00:51:51,680
now that's rainbows and pixie dust like

00:51:50,300 --> 00:51:55,760
that's the holy grail if we could do

00:51:51,680 --> 00:51:59,480
that I have some reason to think that we

00:51:55,760 --> 00:52:01,910
can achieve that so if we compare to the

00:51:59,480 --> 00:52:03,710
c-sharp language here is how the

00:52:01,910 --> 00:52:06,050
interface concept is implemented in the

00:52:03,710 --> 00:52:08,330
current c-sharp specification that's

00:52:06,050 --> 00:52:10,940
actually a a zoomed out version of the

00:52:08,330 --> 00:52:13,900
c-sharp specification it's about 18

00:52:10,940 --> 00:52:16,340
pages of English so standard ease for us

00:52:13,900 --> 00:52:18,320
the proposed is on the right hand side

00:52:16,340 --> 00:52:22,070
which is about 10 lines of unit testable

00:52:18,320 --> 00:52:25,850
code that I can ship on github in a

00:52:22,070 --> 00:52:29,600
library in proposed C++ that's already

00:52:25,850 --> 00:52:31,100
some benefit but what about the use case

00:52:29,600 --> 00:52:33,200
so is he sharpen Java I can write

00:52:31,100 --> 00:52:36,710
interface shape into area void scale by

00:52:33,200 --> 00:52:39,920
double factor the proposal as I'm

00:52:36,710 --> 00:52:41,870
showing it here has exactly all of that

00:52:39,920 --> 00:52:43,430
except T this is C++ so you have to

00:52:41,870 --> 00:52:47,000
write a semicolon at the end of the

00:52:43,430 --> 00:52:48,590
class it's okay we can get over the

00:52:47,000 --> 00:52:50,390
semicolon oh and by the way you can

00:52:48,590 --> 00:52:52,280
write things like Const which you can't

00:52:50,390 --> 00:52:54,920
write at least not with the same meaning

00:52:52,280 --> 00:52:56,900
in other languages so you get to use

00:52:54,920 --> 00:53:01,040
whatever C pluses rich language features

00:52:56,900 --> 00:53:02,870
are already and let me just show the

00:53:01,040 --> 00:53:05,420
difference in philosophy because

00:53:02,870 --> 00:53:07,970
in Java the eye and and c-sharp the idea

00:53:05,420 --> 00:53:09,290
is well we built make something in as a

00:53:07,970 --> 00:53:11,030
language feature that way it gets

00:53:09,290 --> 00:53:13,490
first-class support it's gonna be

00:53:11,030 --> 00:53:14,870
efficient and we do that with interface

00:53:13,490 --> 00:53:17,210
we do that with lock which or

00:53:14,870 --> 00:53:19,630
synchronized in Java which is a language

00:53:17,210 --> 00:53:22,430
feature that lets you do local locking

00:53:19,630 --> 00:53:27,980
but that's not who we are as c plus us

00:53:22,430 --> 00:53:30,500
users and in language authors we want to

00:53:27,980 --> 00:53:34,040
write general things such as lock guard

00:53:30,500 --> 00:53:36,080
in the bottom right where I could have

00:53:34,040 --> 00:53:37,910
almost the same convenient syntax notice

00:53:36,080 --> 00:53:40,330
this is C plus a 17 I didn't even have

00:53:37,910 --> 00:53:43,430
to write lock guard angle mutex angle I

00:53:40,330 --> 00:53:46,550
can get just about this inconvenience

00:53:43,430 --> 00:53:50,330
but the right-hand side is just as

00:53:46,550 --> 00:53:52,580
usable and it's more flexible because

00:53:50,330 --> 00:53:56,270
you can't do timed locks on the left

00:53:52,580 --> 00:53:57,470
hand side you can and if it wasn't in

00:53:56,270 --> 00:54:00,260
the standard you could easily write your

00:53:57,470 --> 00:54:02,810
own type to do a timed lock with back

00:54:00,260 --> 00:54:04,430
off on the right hand side and get the

00:54:02,810 --> 00:54:09,350
same usability in the same experience

00:54:04,430 --> 00:54:11,600
because we're library writers we have a

00:54:09,350 --> 00:54:14,090
language that is arguably the best in

00:54:11,600 --> 00:54:17,120
the world for writing libraries and we

00:54:14,090 --> 00:54:20,110
want to make that even more powerful so

00:54:17,120 --> 00:54:22,730
let me just demonstrate that real quick

00:54:20,110 --> 00:54:28,210
here is C sharp is that all right if I

00:54:22,730 --> 00:54:30,530
show some c-sharp okay nervous laughter

00:54:28,210 --> 00:54:32,900
better laughter that sounded more

00:54:30,530 --> 00:54:34,880
relaxed so here I have interface shape

00:54:32,900 --> 00:54:40,070
and and I can write this in c-sharp

00:54:34,880 --> 00:54:44,480
today and if I say for instance oh let's

00:54:40,070 --> 00:54:47,000
say I make that private-owned Otis I got

00:54:44,480 --> 00:54:49,100
a red squiggle and so it says o in shape

00:54:47,000 --> 00:54:51,290
area the modifier private is not valid

00:54:49,100 --> 00:54:54,140
for this item okay I can't have a

00:54:51,290 --> 00:54:58,940
private member function a private method

00:54:54,140 --> 00:55:01,490
in c-sharp what if I added a data member

00:54:58,940 --> 00:55:03,950
oh it doesn't like that either if I

00:55:01,490 --> 00:55:06,280
hover over it says interfaces cannot

00:55:03,950 --> 00:55:10,730
contain fields which is C sharpies for

00:55:06,280 --> 00:55:12,470
non-static data members the word fields

00:55:10,730 --> 00:55:14,450
might be better but hey we've doubled

00:55:12,470 --> 00:55:15,730
down on non-static data members not a

00:55:14,450 --> 00:55:18,940
salary data members it is

00:55:15,730 --> 00:55:22,450
they can have fields now what I'd like

00:55:18,940 --> 00:55:24,310
to be able to do in C++ is write

00:55:22,450 --> 00:55:25,960
something like very much like what I

00:55:24,310 --> 00:55:27,340
just showed on the street and so here is

00:55:25,960 --> 00:55:29,260
basically the same thing I showed on the

00:55:27,340 --> 00:55:30,880
screen in this version of the the

00:55:29,260 --> 00:55:32,680
prototype compiler there's still a dot

00:55:30,880 --> 00:55:33,880
on the four that's going to go away as

00:55:32,680 --> 00:55:35,680
this goes through committee and we

00:55:33,880 --> 00:55:37,510
follow the guidance of the committee

00:55:35,680 --> 00:55:40,900
other than that I think it's the same as

00:55:37,510 --> 00:55:44,140
what I just showed you and also there's

00:55:40,900 --> 00:55:47,050
a way that you can debug you can

00:55:44,140 --> 00:55:48,130
actually output what gets generated now

00:55:47,050 --> 00:55:51,010
I'm asking for something that doesn't

00:55:48,130 --> 00:55:55,800
exist yet so let me just I love this

00:55:51,010 --> 00:55:58,480
part pardon me cut and paste c-sharp

00:55:55,800 --> 00:56:00,130
into C++ because of course that's the

00:55:58,480 --> 00:56:05,590
thing we always are able to do today

00:56:00,130 --> 00:56:06,970
right and then you'll notice oh he

00:56:05,590 --> 00:56:09,580
doesn't compile why somebody already

00:56:06,970 --> 00:56:13,750
noticed so this is C plus so we got to

00:56:09,580 --> 00:56:16,109
write that semicolon and then it

00:56:13,750 --> 00:56:16,109
compiles

00:56:21,590 --> 00:56:26,450
and and compiler debug shows you in this

00:56:24,950 --> 00:56:27,830
case what it generated so if you were

00:56:26,450 --> 00:56:29,390
doing this to the command line you could

00:56:27,830 --> 00:56:31,130
have that printout notice that debug

00:56:29,390 --> 00:56:33,290
statements is running at compile time in

00:56:31,130 --> 00:56:35,420
this context per block and you can see

00:56:33,290 --> 00:56:36,950
what it generated this is important

00:56:35,420 --> 00:56:38,990
because if you remember nothing else

00:56:36,950 --> 00:56:41,120
from this talk remember that these

00:56:38,990 --> 00:56:44,390
things need to be toolable right there

00:56:41,120 --> 00:56:46,100
and the bottom right of that demo is the

00:56:44,390 --> 00:56:48,500
thing that tools need to build so you

00:56:46,100 --> 00:56:50,450
can step into that's it right there this

00:56:48,500 --> 00:56:51,920
is not just demo where there's a reason

00:56:50,450 --> 00:56:54,680
I put this demo in the talk just to show

00:56:51,920 --> 00:56:58,010
you look we can see what we got but

00:56:54,680 --> 00:56:59,690
that's also the first step of tool

00:56:58,010 --> 00:57:01,640
ability is to be able to see what we've

00:56:59,690 --> 00:57:04,130
got and then IDs can build from there

00:57:01,640 --> 00:57:05,570
but we already have that today so thank

00:57:04,130 --> 00:57:07,370
you again andrew for doing this

00:57:05,570 --> 00:57:08,510
implementation so far and we continue to

00:57:07,370 --> 00:57:11,780
make more of the examples in the

00:57:08,510 --> 00:57:13,570
paperwork only if you do so far but

00:57:11,780 --> 00:57:15,920
remember I said with equal efficiency

00:57:13,570 --> 00:57:18,620
compared to other languages that do this

00:57:15,920 --> 00:57:20,120
as a built-in language feature well this

00:57:18,620 --> 00:57:22,510
is all the compile time so the run time

00:57:20,120 --> 00:57:26,870
efficiency is the same I just built a

00:57:22,510 --> 00:57:29,110
C++ class same as any other C++ class I

00:57:26,870 --> 00:57:32,600
just wrote it more conveniently right

00:57:29,110 --> 00:57:34,940
but what about diagnostic quality I said

00:57:32,600 --> 00:57:38,210
well let's try some of these same things

00:57:34,940 --> 00:57:42,110
let's try int oh I because I have

00:57:38,210 --> 00:57:43,640
keyboard bounce error interfaces may not

00:57:42,110 --> 00:57:45,290
contain data memories okay let's compare

00:57:43,640 --> 00:57:49,220
that to c-sharp where if I'd written

00:57:45,290 --> 00:57:53,110
what was the LSP let's say oh I do you

00:57:49,220 --> 00:57:56,240
say interfaces cannot contain fields

00:57:53,110 --> 00:58:00,440
yeah that's a wash I'll say we have

00:57:56,240 --> 00:58:03,230
equal Diagnostics here fields might be

00:58:00,440 --> 00:58:04,640
still a shorter name but just saying but

00:58:03,230 --> 00:58:06,440
now what if I wrote

00:58:04,640 --> 00:58:09,890
oh yeah and c-sharp what if I made this

00:58:06,440 --> 00:58:12,380
private I have a private method and then

00:58:09,890 --> 00:58:13,510
I see the modifier private is not valid

00:58:12,380 --> 00:58:17,030
for this item

00:58:13,510 --> 00:58:19,100
what's an item this is the kind of

00:58:17,030 --> 00:58:21,560
generic error message that you get or

00:58:19,100 --> 00:58:23,060
part way generic when you're a compiler

00:58:21,560 --> 00:58:24,440
writer who has to write just a general

00:58:23,060 --> 00:58:26,360
error message framework it's not

00:58:24,440 --> 00:58:28,100
specific to a particular thing although

00:58:26,360 --> 00:58:30,170
it could be in this case because

00:58:28,100 --> 00:58:31,970
interface is baked into the language but

00:58:30,170 --> 00:58:34,740
it's just using a general thing say

00:58:31,970 --> 00:58:36,150
can't use this modifier in this context

00:58:34,740 --> 00:58:38,250
so to save space they're using a

00:58:36,150 --> 00:58:41,490
reasoning and error message so private

00:58:38,250 --> 00:58:43,290
is specific this item is generic so it's

00:58:41,490 --> 00:58:47,520
a half way generic error message whereas

00:58:43,290 --> 00:58:52,020
here what's the natural thing i get what

00:58:47,520 --> 00:58:54,480
i write private i get error interface

00:58:52,020 --> 00:58:56,369
functions must be public now why is this

00:58:54,480 --> 00:58:59,339
is important it's only that I can get

00:58:56,369 --> 00:59:00,480
better diagnostics but the example I

00:58:59,339 --> 00:59:01,830
just showed you because c-sharp could

00:59:00,480 --> 00:59:03,900
easily done the same thing the visual

00:59:01,830 --> 00:59:05,580
studio folks looking at this on YouTube

00:59:03,900 --> 00:59:07,050
will say oh yeah we could make that

00:59:05,580 --> 00:59:10,470
better check it in in the next version

00:59:07,050 --> 00:59:14,180
of open dotnet or whatever has has the

00:59:10,470 --> 00:59:18,300
fix and has an equal error message but

00:59:14,180 --> 00:59:19,950
this is what you get by defaults for

00:59:18,300 --> 00:59:22,530
language baked in features because

00:59:19,950 --> 00:59:24,510
compiler writers write generic are by

00:59:22,530 --> 00:59:27,960
default right and very general grammar

00:59:24,510 --> 00:59:30,390
based Diagnostics this is a grammar

00:59:27,960 --> 00:59:33,780
based diagnostic when we write

00:59:30,390 --> 00:59:35,820
Diagnostics with meta classes we are

00:59:33,780 --> 00:59:41,420
thinking about the meta class that we

00:59:35,820 --> 00:59:43,440
are writing we naturally write this

00:59:41,420 --> 00:59:45,660
because it's what we're thinking it's

00:59:43,440 --> 00:59:48,780
the rule we're implementing as we go so

00:59:45,660 --> 00:59:51,660
I think that not only am i hopeful that

00:59:48,780 --> 00:59:53,760
as I claimed here that we have the same

00:59:51,660 --> 00:59:56,580
usability expressiveness and even

00:59:53,760 --> 00:59:58,650
Diagnostics as other languages that

00:59:56,580 --> 01:00:01,460
build many of these things in as direct

00:59:58,650 --> 01:00:04,320
compiler supported plumbed in features I

01:00:01,460 --> 01:00:06,859
think that not only can you get parody

01:00:04,320 --> 01:00:09,270
but it's just naturally you get better

01:00:06,859 --> 01:00:10,859
Diagnostics because you are already

01:00:09,270 --> 01:00:11,849
thinking specifically about the thing

01:00:10,859 --> 01:00:15,960
that you are authoring now the

01:00:11,849 --> 01:00:17,910
abstraction that I'm having here so

01:00:15,960 --> 01:00:21,750
that's one example here's another

01:00:17,910 --> 01:00:23,490
example a value type a regular type then

01:00:21,750 --> 01:00:25,530
we can argue over a beer whether regular

01:00:23,490 --> 01:00:28,619
types include comparison operators or

01:00:25,530 --> 01:00:32,490
not let's be embraced let's embrace them

01:00:28,619 --> 01:00:36,420
for this slide today in sitio so 17 I

01:00:32,490 --> 01:00:38,520
write a bunch of stuff and I have to

01:00:36,420 --> 01:00:40,200
write my I have to reinstate my default

01:00:38,520 --> 01:00:42,270
constructor notice that very first red

01:00:40,200 --> 01:00:47,339
line why do I have to reinstate it

01:00:42,270 --> 01:00:48,440
equals default I seen in the front rows

01:00:47,339 --> 01:00:50,640
like

01:00:48,440 --> 01:00:54,480
right because it was suppressed by who

01:00:50,640 --> 01:00:55,980
by point and int you wrote a constructor

01:00:54,480 --> 01:00:57,240
so we didn't give you a default one you

01:00:55,980 --> 01:00:58,590
can always reinstate it with equals

01:00:57,240 --> 01:01:01,560
default that's what we teach people

01:00:58,590 --> 01:01:04,320
today it's true it works and I have to

01:01:01,560 --> 01:01:07,230
write my comparisons I make them friends

01:01:04,320 --> 01:01:08,430
because it's easier than just declaring

01:01:07,230 --> 01:01:11,100
them and then defining them out of line

01:01:08,430 --> 01:01:13,800
but I want to just write them here and

01:01:11,100 --> 01:01:16,200
this way I get conversions on both sides

01:01:13,800 --> 01:01:18,390
as well if point is convertible to from

01:01:16,200 --> 01:01:21,240
some other type and I write my

01:01:18,390 --> 01:01:23,280
comparisons the proposal is that I can

01:01:21,240 --> 01:01:25,860
just write I would be able to write a

01:01:23,280 --> 01:01:27,600
value metaclass that does those things

01:01:25,860 --> 01:01:31,680
and I'll show it on the next slide the

01:01:27,600 --> 01:01:33,840
next slides value point would say Oh

01:01:31,680 --> 01:01:35,040
data members those are private by

01:01:33,840 --> 01:01:37,200
default because that's what we tell

01:01:35,040 --> 01:01:39,420
people to do anyway so let's use the

01:01:37,200 --> 01:01:42,150
opportunity make data members private by

01:01:39,420 --> 01:01:44,370
default functions public by default oh

01:01:42,150 --> 01:01:45,420
and a value always has a default

01:01:44,370 --> 01:01:47,010
constructor because that's part of being

01:01:45,420 --> 01:01:50,610
a regular type so I don't need to

01:01:47,010 --> 01:01:52,020
reinstate it so on the left hand side I

01:01:50,610 --> 01:01:55,500
had to write point per n for N equals

01:01:52,020 --> 01:02:00,260
default semicolon to reinstate it that's

01:01:55,500 --> 01:02:03,450
an opt-in it would be tempting but wrong

01:02:00,260 --> 01:02:06,690
to say that the opt-in evaporates on the

01:02:03,450 --> 01:02:11,340
right hand side no the opt-in is folded

01:02:06,690 --> 01:02:14,460
into the word value and that value is

01:02:11,340 --> 01:02:16,470
the same opt in for yes I do want a

01:02:14,460 --> 01:02:19,800
default constructor as it is for yes I

01:02:16,470 --> 01:02:22,890
want the comparison functions and yes I

01:02:19,800 --> 01:02:26,160
want copy construction copy assignment

01:02:22,890 --> 01:02:27,990
move construction move assignment and a

01:02:26,160 --> 01:02:30,210
non-virtual destructor which I can

01:02:27,990 --> 01:02:32,220
enforce for a value and I can't get it

01:02:30,210 --> 01:02:33,930
wrong even under maintenance now what if

01:02:32,220 --> 01:02:36,270
under maintenance I write value point

01:02:33,930 --> 01:02:37,860
and today I require that it can't have a

01:02:36,270 --> 01:02:39,810
virtual function or a virtual destructor

01:02:37,860 --> 01:02:41,940
because that's not what values are right

01:02:39,810 --> 01:02:43,620
you don't want to slice them and you

01:02:41,940 --> 01:02:45,060
would only use virtual if you're doing

01:02:43,620 --> 01:02:46,890
something like that or protected have a

01:02:45,060 --> 01:02:48,600
protective member what if under

01:02:46,890 --> 01:02:50,190
maintenance I did want to add that well

01:02:48,600 --> 01:02:53,130
if I did it by accident as soon as I

01:02:50,190 --> 01:02:55,680
write in I maintain the right hand side

01:02:53,130 --> 01:02:57,720
and I add a virtual function or a

01:02:55,680 --> 01:03:01,020
protected member I would get an error

01:02:57,720 --> 01:03:02,100
that doesn't mean I can't do it it just

01:03:01,020 --> 01:03:07,110
means I can't do

01:03:02,100 --> 01:03:09,930
silently I can write a protected

01:03:07,110 --> 01:03:13,680
function and/or a virtual function on

01:03:09,930 --> 01:03:15,900
point but to do it I will have to change

01:03:13,680 --> 01:03:18,630
its category from value to something

01:03:15,900 --> 01:03:22,440
else and this is nothing but goodness

01:03:18,630 --> 01:03:24,870
because it means I can't do it silently

01:03:22,440 --> 01:03:27,200
by default make the mistake but if I

01:03:24,870 --> 01:03:30,990
really meant dude I can say it clearly

01:03:27,200 --> 01:03:34,410
concisely and explicitly without a lot

01:03:30,990 --> 01:03:36,600
of boilerplate so having a single word

01:03:34,410 --> 01:03:40,140
of power to opt into a group of defaults

01:03:36,600 --> 01:03:42,120
is I think really really important and

01:03:40,140 --> 01:03:46,770
it all comes down to letting the

01:03:42,120 --> 01:03:49,740
programmer express intent yes I just

01:03:46,770 --> 01:03:52,620
started this talk by mentioning Pio 515

01:03:49,740 --> 01:03:55,290
the CIM the spaceship operator even with

01:03:52,620 --> 01:03:58,020
the spaceship operator so C + o 17 +

01:03:55,290 --> 01:03:59,520
that proposal would be even shorter but

01:03:58,020 --> 01:04:01,830
you still have the octave for the

01:03:59,520 --> 01:04:03,360
default constructor and so forth so I

01:04:01,830 --> 01:04:05,370
still think even with that there's value

01:04:03,360 --> 01:04:08,010
in the spaceship operator that is

01:04:05,370 --> 01:04:09,960
orthogonal and metaclasses

01:04:08,010 --> 01:04:14,250
give you further value on top of it

01:04:09,960 --> 01:04:15,720
that's again independent here's what the

01:04:14,250 --> 01:04:17,190
implementation would look like I won't

01:04:15,720 --> 01:04:21,210
go through it in detail but you'll

01:04:17,190 --> 01:04:25,350
notice that at the the top you get all

01:04:21,210 --> 01:04:28,320
your your basic functions and we can

01:04:25,350 --> 01:04:29,940
actually go through and we require that

01:04:28,320 --> 01:04:31,710
they be defaulted you could actually

01:04:29,940 --> 01:04:34,290
write code that just tests for them and

01:04:31,710 --> 01:04:36,480
injects them if they're not there then

01:04:34,290 --> 01:04:38,610
in the context of LOC we make sure that

01:04:36,480 --> 01:04:40,500
all the variables if they're if they

01:04:38,610 --> 01:04:43,860
haven't access don't have an access

01:04:40,500 --> 01:04:45,810
specifier made are made private and if

01:04:43,860 --> 01:04:47,820
for every function if there's no access

01:04:45,810 --> 01:04:49,350
specifier its public and we make sure

01:04:47,820 --> 01:04:51,060
it's not protected virtual or a

01:04:49,350 --> 01:04:54,740
destructor with a nice high quality

01:04:51,060 --> 01:04:57,990
error message and then we compose

01:04:54,740 --> 01:05:01,820
metaclass value from it is a basic value

01:04:57,990 --> 01:05:04,080
which has all those things and ordered

01:05:01,820 --> 01:05:06,240
which I'm not showing but it's the one

01:05:04,080 --> 01:05:08,010
that generates you the comparison

01:05:06,240 --> 01:05:10,260
functions today and again with spaceship

01:05:08,010 --> 01:05:13,080
operator you would just use the

01:05:10,260 --> 01:05:15,060
spaceship operator inside ordered

01:05:13,080 --> 01:05:17,130
and then I could write value point as

01:05:15,060 --> 01:05:19,410
shown before and I can write code that

01:05:17,130 --> 01:05:21,270
does equality that works it's fine

01:05:19,410 --> 01:05:23,970
I can write set of point which requires

01:05:21,270 --> 01:05:26,760
less than and it works and all I wrote

01:05:23,970 --> 01:05:30,360
was value point int int and a

01:05:26,760 --> 01:05:33,690
constructor and I've opted in to all of

01:05:30,360 --> 01:05:36,030
that power now here's another thing we

01:05:33,690 --> 01:05:40,170
do in c + o 17 for those of you who

01:05:36,030 --> 01:05:43,260
can't read in the front row it's class

01:05:40,170 --> 01:05:44,610
pair it is I believe the current from

01:05:43,260 --> 01:05:46,740
the current working draft or maybe a

01:05:44,610 --> 01:05:48,690
couple of working drafts old the

01:05:46,740 --> 01:05:51,210
definition of class pair because pair is

01:05:48,690 --> 01:05:55,080
such a simple class it couldn't possibly

01:05:51,210 --> 01:05:57,440
be hard to write so what kind of class

01:05:55,080 --> 01:06:01,260
is pair what can I can't I do with it

01:05:57,440 --> 01:06:02,580
read the code read CPP reference I would

01:06:01,260 --> 01:06:06,140
very much like to be able to write

01:06:02,580 --> 01:06:08,580
literal value pair t1 first T two second

01:06:06,140 --> 01:06:09,810
I'm not showing the code for that the

01:06:08,580 --> 01:06:11,610
code for literal value is the one

01:06:09,810 --> 01:06:13,950
example I use that I don't show the code

01:06:11,610 --> 01:06:16,170
into paper but presumably by now you can

01:06:13,950 --> 01:06:17,700
see ah I already have an inkling here's

01:06:16,170 --> 01:06:18,960
how I would write that code because I

01:06:17,700 --> 01:06:20,520
would want to generate all the things on

01:06:18,960 --> 01:06:23,910
the left hand side if they're not

01:06:20,520 --> 01:06:27,090
written already this was actually a

01:06:23,910 --> 01:06:28,680
challenge that I put to several cos

01:06:27,090 --> 01:06:31,680
committee members about five years ago

01:06:28,680 --> 01:06:33,510
when we were just kept on adding stuff

01:06:31,680 --> 01:06:35,070
to pair turns out pair is really hard

01:06:33,510 --> 01:06:39,030
Marshall are you in the audience

01:06:35,070 --> 01:06:41,490
somewhere Marshall am i roughly quoting

01:06:39,030 --> 01:06:43,320
you correctly when I said that that it

01:06:41,490 --> 01:06:46,170
was a pair was a variant that's right at

01:06:43,320 --> 01:06:47,910
the edge of what we know how to do it

01:06:46,170 --> 01:06:51,210
was tuple okay which is kind of which is

01:06:47,910 --> 01:06:54,630
more like pair excellent and if that if

01:06:51,210 --> 01:06:57,090
that oh yes so the answer was yes and if

01:06:54,630 --> 01:06:59,250
hearing that from the one of the main

01:06:57,090 --> 01:07:05,250
authors of the clang standard library

01:06:59,250 --> 01:07:06,660
implementation worries you we understand

01:07:05,250 --> 01:07:09,390
that the we want to make these things

01:07:06,660 --> 01:07:11,970
easier a simple thing should be simple

01:07:09,390 --> 01:07:13,920
as BR Anna rightly says this is simple

01:07:11,970 --> 01:07:15,780
we should be able to make it simple and

01:07:13,920 --> 01:07:18,570
write literal value that we can reuse

01:07:15,780 --> 01:07:22,050
for pair and for tuple and defined pair

01:07:18,570 --> 01:07:23,700
and tuple in this way this is the only

01:07:22,050 --> 01:07:25,740
proposal I've seen that would let me

01:07:23,700 --> 01:07:29,280
actually write

01:07:25,740 --> 01:07:30,990
hair as t1 first t2 second I think this

01:07:29,280 --> 01:07:33,330
is a very good litmus test at least for

01:07:30,990 --> 01:07:34,619
me a litmus test on a are we on the

01:07:33,330 --> 01:07:36,360
right track because like here's an

01:07:34,619 --> 01:07:38,310
example of stuff we're doing today even

01:07:36,360 --> 01:07:40,260
though it's hard and we'd like to do it

01:07:38,310 --> 01:07:42,750
more directly this is a poster child

01:07:40,260 --> 01:07:44,430
example of stuff we need to do today and

01:07:42,750 --> 01:07:47,520
we're digging with a spoon

01:07:44,430 --> 01:07:51,110
can we give find the right kind of

01:07:47,520 --> 01:07:52,950
shovel that can make this clear to do

01:07:51,110 --> 01:07:55,640
here's another example

01:07:52,950 --> 01:07:58,200
Eames enums are baked into the language

01:07:55,640 --> 01:07:59,820
imagine that we had a basic enum

01:07:58,200 --> 01:08:01,170
metaclass again I'm following the

01:07:59,820 --> 01:08:02,970
standard library convention for

01:08:01,170 --> 01:08:07,890
extracting common stuff into a basic

01:08:02,970 --> 01:08:10,830
underscore prefixed type and notice it

01:08:07,890 --> 01:08:12,600
is a value the strawman syntax is

01:08:10,830 --> 01:08:15,780
inheritance like syntax maybe something

01:08:12,600 --> 01:08:18,810
else is better but the idea is run the

01:08:15,780 --> 01:08:21,450
metaclass value and then run this

01:08:18,810 --> 01:08:23,910
because this is a more specific form of

01:08:21,450 --> 01:08:26,370
a value so value already gives it copy

01:08:23,910 --> 01:08:28,350
constructors and no virtual functions

01:08:26,370 --> 01:08:30,750
and those kinds of things and what we're

01:08:28,350 --> 01:08:33,000
going to say is basic genome is a type

01:08:30,750 --> 01:08:35,549
that first of all can't be empty so we

01:08:33,000 --> 01:08:38,670
require that the number of variables is

01:08:35,549 --> 01:08:40,109
greater than zero that's data members we

01:08:38,670 --> 01:08:42,000
require that this here's a cute little

01:08:40,109 --> 01:08:43,970
trick if you're wondering data members

01:08:42,000 --> 01:08:46,470
that evenings don't have data members

01:08:43,970 --> 01:08:48,240
know but there sure are a lot like a

01:08:46,470 --> 01:08:52,250
class that has nothing but public

01:08:48,240 --> 01:08:54,450
context for data members the enumerators

01:08:52,250 --> 01:08:57,150
so if you think of the enumerators as

01:08:54,450 --> 01:08:59,430
public contexts for data members well

01:08:57,150 --> 01:09:01,770
let's say all of the variables are if

01:08:59,430 --> 01:09:04,950
it's not doesn't have access by default

01:09:01,770 --> 01:09:06,750
is public and then we'd force that if it

01:09:04,950 --> 01:09:08,940
doesn't have a storage duration make it

01:09:06,750 --> 01:09:11,880
context per and then enforce that if it

01:09:08,940 --> 01:09:14,609
doesn't have a type set the type to the

01:09:11,880 --> 01:09:16,950
read the code I skipped looks at the

01:09:14,609 --> 01:09:19,290
type of the first elements and if it's

01:09:16,950 --> 01:09:21,600
auto we just pick int and if it's

01:09:19,290 --> 01:09:24,839
otherwise we use its type the for the

01:09:21,600 --> 01:09:27,410
first element and then we provide the

01:09:24,839 --> 01:09:29,850
explicit conversion operator and such so

01:09:27,410 --> 01:09:32,009
we are composing a meta class we're

01:09:29,850 --> 01:09:35,490
composing the value so this is a basic

01:09:32,009 --> 01:09:37,710
UNAM is a more specific value we apply

01:09:35,490 --> 01:09:38,830
defaults public Const expert and then

01:09:37,710 --> 01:09:40,000
enforce them and

01:09:38,830 --> 01:09:42,609
could also enforce that there are no

01:09:40,000 --> 01:09:43,990
functions although this particular code

01:09:42,609 --> 01:09:45,550
doesn't do that I'm sure you can see

01:09:43,990 --> 01:09:47,589
exactly how to cut and paste two lines

01:09:45,550 --> 01:09:51,430
to also enforce that there are no

01:09:47,589 --> 01:09:55,140
functions and then I can say an enum

01:09:51,430 --> 01:09:59,710
class for example the C++ 11 anoon class

01:09:55,140 --> 01:10:04,150
is a basic genome where the I also add a

01:09:59,710 --> 01:10:08,080
cantos extra block to default the values

01:10:04,150 --> 01:10:10,480
to one above the previous one unless it

01:10:08,080 --> 01:10:12,550
was set explicitly and so then I can

01:10:10,480 --> 01:10:15,730
write a new in class state notice it's a

01:10:12,550 --> 01:10:17,470
new underscore class state Auto started

01:10:15,730 --> 01:10:19,900
equals 1 comma leading comma stopped and

01:10:17,470 --> 01:10:21,760
that is even syntactically thanks to

01:10:19,900 --> 01:10:26,410
Dennis Ritchie making emus look similar

01:10:21,760 --> 01:10:27,940
to classes that is already already very

01:10:26,410 --> 01:10:30,190
close to what you actually write with

01:10:27,940 --> 01:10:33,520
Enuma space class instead of it's that

01:10:30,190 --> 01:10:35,440
you put the base type in as a the

01:10:33,520 --> 01:10:37,420
underlying type as a base with enum

01:10:35,440 --> 01:10:39,520
class in the language you say state :

01:10:37,420 --> 01:10:42,070
int say whereas here you just say int

01:10:39,520 --> 01:10:43,540
started equals 1 etc and there's a

01:10:42,070 --> 01:10:47,800
semicolon at the end because we love

01:10:43,540 --> 01:10:50,740
semicolons semicolons they rule and then

01:10:47,800 --> 01:10:53,650
I can have Ascot games diamond starts at

01:10:50,740 --> 01:10:56,680
9 hearts is 10 spades is 11 clubs is 12

01:10:53,650 --> 01:11:00,760
godness 24 and I can do all my normal

01:10:56,680 --> 01:11:02,890
enews if we had had this 30 years ago

01:11:00,760 --> 01:11:04,690
would we need a separate Enuma in the

01:11:02,890 --> 01:11:09,760
standard that's bifurcating our type

01:11:04,690 --> 01:11:13,270
system maybe not and again look no

01:11:09,760 --> 01:11:15,910
standardise and i claim no loss and

01:11:13,270 --> 01:11:17,440
usability expressiveness air quality or

01:11:15,910 --> 01:11:18,880
performance especially runtime

01:11:17,440 --> 01:11:22,120
performance compile time performance we

01:11:18,880 --> 01:11:23,620
have to make sure that we get enough but

01:11:22,120 --> 01:11:26,730
definitely runtime performance because

01:11:23,620 --> 01:11:29,470
all of this happens at compile time and

01:11:26,730 --> 01:11:31,930
then once I have all that I can easily

01:11:29,470 --> 01:11:34,570
write a flag in oom this simply declares

01:11:31,930 --> 01:11:36,130
the bitwise operations and has a

01:11:34,570 --> 01:11:39,010
different context for block which

01:11:36,130 --> 01:11:40,930
instead of doing +1 does powers of 2 and

01:11:39,010 --> 01:11:42,490
doesn't let you write any of the values

01:11:40,930 --> 01:11:46,660
yourself because it's always powers of 2

01:11:42,490 --> 01:11:49,120
and this is just code the first half is

01:11:46,660 --> 01:11:51,010
all declarations it's regular C puzzles

01:11:49,120 --> 01:11:52,420
grammar declarations and then there's a

01:11:51,010 --> 01:11:54,460
context for block of composite

01:11:52,420 --> 01:11:57,489
I'm code which is just regular see

01:11:54,460 --> 01:11:59,199
fossils code whatever is allowed that we

01:11:57,489 --> 01:12:02,679
decide is allowed inside a context per

01:11:59,199 --> 01:12:06,580
block and then I set in using reflection

01:12:02,679 --> 01:12:08,260
I reflect on and set the values and now

01:12:06,580 --> 01:12:09,910
I've got a flag Inu

01:12:08,260 --> 01:12:12,880
how many of you have reinvented your own

01:12:09,910 --> 01:12:14,410
flag Enuma types yes how many of yous

01:12:12,880 --> 01:12:18,070
views environments where there are non

01:12:14,410 --> 01:12:20,800
portable proprietary flag Inu types yes

01:12:18,070 --> 01:12:24,219
we keep in reinventing this should we

01:12:20,800 --> 01:12:26,320
standardize one in the language there's

01:12:24,219 --> 01:12:27,900
probably some demand should be

01:12:26,320 --> 01:12:29,860
standardized interface in the language

01:12:27,900 --> 01:12:34,540
that's a common thing there's probably

01:12:29,860 --> 01:12:37,239
demand it'll never happen it doesn't

01:12:34,540 --> 01:12:39,130
carry its weight as a language feature

01:12:37,239 --> 01:12:41,560
do we really want to airlift those

01:12:39,130 --> 01:12:45,730
eighteen pages of the c-sharp spec for

01:12:41,560 --> 01:12:47,140
interface into C++ I mean were Rd will

01:12:45,730 --> 01:12:50,380
get to 2,000 pages that much faster

01:12:47,140 --> 01:12:51,940
right do we really want that and how

01:12:50,380 --> 01:12:54,190
many of them could we afford to add in

01:12:51,940 --> 01:12:55,630
the language but if you let people write

01:12:54,190 --> 01:12:58,300
them as libraries suddenly they get

01:12:55,630 --> 01:13:00,610
cheap to add assuming the language

01:12:58,300 --> 01:13:02,020
feature bears out the under the general

01:13:00,610 --> 01:13:03,880
underlying language feature of

01:13:02,020 --> 01:13:05,199
metaclasses that supports it now I

01:13:03,880 --> 01:13:06,850
actually wrote a bug the first time I

01:13:05,199 --> 01:13:09,730
wrote this so first of all let me point

01:13:06,850 --> 01:13:12,190
out we have a relationship between basic

01:13:09,730 --> 01:13:14,290
value a value is a basic value a basic

01:13:12,190 --> 01:13:16,030
UNAM is a value and we've got these

01:13:14,290 --> 01:13:19,210
relationships so you can compose meta

01:13:16,030 --> 01:13:23,320
classes but the first time I wrote this

01:13:19,210 --> 01:13:25,120
is I actually forgot the XOR and a nor

01:13:23,320 --> 01:13:30,550
of course oh yeah that's right XOR and

01:13:25,120 --> 01:13:32,140
so what I'm about to claim many people

01:13:30,550 --> 01:13:33,940
in the evolution working group in the

01:13:32,140 --> 01:13:37,270
committee agree with so this is not just

01:13:33,940 --> 01:13:39,370
me saying this I forgot it so it took me

01:13:37,270 --> 01:13:40,960
15 seconds to add it because I just cut

01:13:39,370 --> 01:13:44,250
and pasted those too so those two lines

01:13:40,960 --> 01:13:46,390
and just changed the bar to a caret

01:13:44,250 --> 01:13:48,429
adding in to standardise wording would

01:13:46,390 --> 01:13:49,989
have taken at least an hour and if you

01:13:48,429 --> 01:13:52,810
don't believe me you haven't been to

01:13:49,989 --> 01:13:54,070
evolution working group in core and the

01:13:52,810 --> 01:13:55,960
answer I've got from committee members

01:13:54,070 --> 01:13:57,340
who've seen these slides is but

01:13:55,960 --> 01:14:01,239
universally you'd never get it through

01:13:57,340 --> 01:14:05,110
in an hour because it's it's expensive

01:14:01,239 --> 01:14:07,750
to work with standardise and

01:14:05,110 --> 01:14:09,760
with an English specification that tries

01:14:07,750 --> 01:14:12,970
to say precisely in an imprecise

01:14:09,760 --> 01:14:16,000
language what a precise language rule

01:14:12,970 --> 01:14:19,330
ought to do code on the other hand is

01:14:16,000 --> 01:14:25,090
precise code don't lie code compiles

01:14:19,330 --> 01:14:29,070
code unit tests we love code here's

01:14:25,090 --> 01:14:31,210
another example a property this has been

01:14:29,070 --> 01:14:32,620
proposed to be standardized but again

01:14:31,210 --> 01:14:34,690
one of those things that just has not

01:14:32,620 --> 01:14:37,090
gotten enough traction to be put into

01:14:34,690 --> 01:14:39,790
the language but people keep reinventing

01:14:37,090 --> 01:14:43,630
so today I might have a hidden data

01:14:39,790 --> 01:14:45,940
member int value and provide get and set

01:14:43,630 --> 01:14:48,340
functions by the way disclaimer our

01:14:45,940 --> 01:14:50,080
properties the the solution to world

01:14:48,340 --> 01:14:53,140
hunger of course not

01:14:50,080 --> 01:14:55,780
can they be over you overused and abused

01:14:53,140 --> 01:14:57,220
like a knife yes just like a mugger in

01:14:55,780 --> 01:15:00,010
an alley can use a knife on you in a way

01:14:57,220 --> 01:15:01,090
that you do not appreciate but that

01:15:00,010 --> 01:15:02,170
doesn't mean you don't want them in the

01:15:01,090 --> 01:15:03,460
kitchen you just don't want them lying

01:15:02,170 --> 01:15:06,580
around on the floor or in the wrong

01:15:03,460 --> 01:15:09,010
people's hands so properties yes they're

01:15:06,580 --> 01:15:10,810
overused but they're still useful that's

01:15:09,010 --> 01:15:13,000
why we keep reinventing them and again

01:15:10,810 --> 01:15:14,380
I'll I'll keep harping on the same thing

01:15:13,000 --> 01:15:19,030
that I keep boring you with because it's

01:15:14,380 --> 01:15:22,780
important we C++ programmers already do

01:15:19,030 --> 01:15:24,700
it we keep inventing these dotnet there

01:15:22,780 --> 01:15:27,340
are not dotnet C fossil C X has them

01:15:24,700 --> 01:15:29,740
cute has them every ID under the Sun

01:15:27,340 --> 01:15:31,900
adds you some support for properties and

01:15:29,740 --> 01:15:33,730
C++ they're just non-standard they all

01:15:31,900 --> 01:15:34,870
work a little differently but there's a

01:15:33,730 --> 01:15:36,490
need but it's something we've never

01:15:34,870 --> 01:15:38,740
standardized in the language because

01:15:36,490 --> 01:15:41,260
it's too expensive and too controversial

01:15:38,740 --> 01:15:44,260
I would like to be able to write a

01:15:41,260 --> 01:15:46,510
property metaclass that is templatized

01:15:44,260 --> 01:15:48,100
so think of property as a template at

01:15:46,510 --> 01:15:50,650
metaclass that takes the type the

01:15:48,100 --> 01:15:54,100
underlying type that you want gives it a

01:15:50,650 --> 01:15:55,360
value and if you leave it empty could

01:15:54,100 --> 01:15:57,580
even make the forward declaration do

01:15:55,360 --> 01:15:59,200
this but if you leave it empty by

01:15:57,580 --> 01:16:00,670
default it says oh look you didn't

01:15:59,200 --> 01:16:02,770
define a data member here let me define

01:16:00,670 --> 01:16:04,720
one for you you didn't define a getter

01:16:02,770 --> 01:16:06,160
Asset function let me define one for you

01:16:04,720 --> 01:16:08,550
and so that you get the same thing

01:16:06,160 --> 01:16:12,930
that's on the right hand side now

01:16:08,550 --> 01:16:16,360
property event because it's it is a

01:16:12,930 --> 01:16:18,220
class that's generated just property

01:16:16,360 --> 01:16:20,620
event value generates a net

01:16:18,220 --> 01:16:23,200
stood class inside my class which is not

01:16:20,620 --> 01:16:24,880
the same as the right-hand side but you

01:16:23,200 --> 01:16:27,430
might have noticed I am using a meta

01:16:24,880 --> 01:16:29,470
class also on my class

01:16:27,430 --> 01:16:32,620
I'm calling it's a class X extended

01:16:29,470 --> 01:16:35,200
class what does it do among other things

01:16:32,620 --> 01:16:38,770
iterates and notices any properties and

01:16:35,200 --> 01:16:42,040
inlines them into the base class so they

01:16:38,770 --> 01:16:43,930
can refer to each other so this is how

01:16:42,040 --> 01:16:46,330
you can another way to compose the two

01:16:43,930 --> 01:16:48,280
and we can default it enforce that you

01:16:46,330 --> 01:16:50,200
can only write get at set functions we

01:16:48,280 --> 01:16:51,730
can enforce that you can write them with

01:16:50,200 --> 01:16:54,100
conversions just like the standards

01:16:51,730 --> 01:16:56,890
stood function that you can if it's a

01:16:54,100 --> 01:16:59,320
property of int that you can write a get

01:16:56,890 --> 01:17:01,120
that return something that's convertible

01:16:59,320 --> 01:17:02,740
from int or you can write a set that

01:17:01,120 --> 01:17:05,920
takes something convertible to int

01:17:02,740 --> 01:17:08,080
things like that very flexible type safe

01:17:05,920 --> 01:17:11,110
but convenient you can write all that in

01:17:08,080 --> 01:17:13,870
your meta class and if you want to write

01:17:11,110 --> 01:17:15,370
a custom once a string Val your own get

01:17:13,870 --> 01:17:17,230
and set functions you can do that and we

01:17:15,370 --> 01:17:19,260
can make sure you do it right in the

01:17:17,230 --> 01:17:22,450
type system

01:17:19,260 --> 01:17:24,250
now I mentioned cute uses these so today

01:17:22,450 --> 01:17:25,600
in cute you write a cute property back

01:17:24,250 --> 01:17:27,430
row and this is just a subset of the

01:17:25,600 --> 01:17:31,120
features that are available with cute

01:17:27,430 --> 01:17:33,970
macros but you write your value you you

01:17:31,120 --> 01:17:34,900
use annotations to say oh well these get

01:17:33,970 --> 01:17:38,080
inset functions

01:17:34,900 --> 01:17:39,910
relate to that value and I would like to

01:17:38,080 --> 01:17:42,160
be able to write it something like the

01:17:39,910 --> 01:17:44,140
right-hand side instead and again have

01:17:42,160 --> 01:17:48,490
cue class do all the things that acute

01:17:44,140 --> 01:17:50,200
class needs to do including treat any

01:17:48,490 --> 01:17:52,300
nested property is the way that cute

01:17:50,200 --> 01:17:54,940
property is ought to be treated and be

01:17:52,300 --> 01:17:56,050
able to write this in C++ code instead

01:17:54,940 --> 01:17:57,670
of putting it through a separate

01:17:56,050 --> 01:17:59,770
compiler and still have the all the

01:17:57,670 --> 01:18:02,260
options I can have a different stored

01:17:59,770 --> 01:18:05,470
type and a custom getter and setter and

01:18:02,260 --> 01:18:06,910
still be able to write that myself but

01:18:05,470 --> 01:18:09,070
on the right hand side I have a pair of

01:18:06,910 --> 01:18:11,350
braces that define an abstraction and

01:18:09,070 --> 01:18:15,160
that's powerful and they reuse this

01:18:11,350 --> 01:18:16,870
well-known word today cute does this

01:18:15,160 --> 01:18:18,190
with a more complex build chain you

01:18:16,870 --> 01:18:21,070
write a header file that includes

01:18:18,190 --> 01:18:23,320
extensions hidden by macros you run it

01:18:21,070 --> 01:18:25,630
through a mock compiler as well as your

01:18:23,320 --> 01:18:27,280
C++ compiler and combine the results I

01:18:25,630 --> 01:18:28,720
would like to just write this as C++

01:18:27,280 --> 01:18:30,969
code that goes through my normal

01:18:28,720 --> 01:18:32,739
straight tool chain

01:18:30,969 --> 01:18:34,900
and you can do other things besides

01:18:32,739 --> 01:18:36,219
properties for examples signals and

01:18:34,900 --> 01:18:37,869
slots or another thing that we're

01:18:36,219 --> 01:18:40,289
currently actively investigating with

01:18:37,869 --> 01:18:42,729
trying this out with cute as one of our

01:18:40,289 --> 01:18:46,420
examples that were testing out over the

01:18:42,729 --> 01:18:48,969
coming year or so look instead of saying

01:18:46,420 --> 01:18:51,579
signals : and avoid my signal could I

01:18:48,969 --> 01:18:53,710
say signal my signal and then do all the

01:18:51,579 --> 01:18:56,199
processing for a signal that's a

01:18:53,710 --> 01:18:58,030
well-known return type that the cue

01:18:56,199 --> 01:19:01,989
class metaclass can recognize for

01:18:58,030 --> 01:19:03,880
example but it's not just about cute

01:19:01,989 --> 01:19:05,530
remember I said everybody and their kid

01:19:03,880 --> 01:19:08,949
brother framework reinvents properties

01:19:05,530 --> 01:19:11,320
well so did the the windows team with

01:19:08,949 --> 01:19:14,800
over the last decade they're a new

01:19:11,320 --> 01:19:17,349
version of Windows apps and so C + s CX

01:19:14,800 --> 01:19:19,300
had to support that well you can't talk

01:19:17,349 --> 01:19:21,849
about properties and portable c++ so we

01:19:19,300 --> 01:19:23,320
added extensions for that we decided to

01:19:21,849 --> 01:19:25,210
do it in the language so you needed an

01:19:23,320 --> 01:19:27,400
Augmented compiler that took a superset

01:19:25,210 --> 01:19:29,199
of C++ the good news is you still have a

01:19:27,400 --> 01:19:30,699
single tool chain the bad news is it's

01:19:29,199 --> 01:19:34,479
still not portable so still won't work

01:19:30,699 --> 01:19:36,579
in clang and it still it opens you to

01:19:34,479 --> 01:19:39,400
accusations of proprietary extensions

01:19:36,579 --> 01:19:41,829
but you either support properties and

01:19:39,400 --> 01:19:44,229
put the information somewhere or you

01:19:41,829 --> 01:19:46,479
don't support properties so this is one

01:19:44,229 --> 01:19:49,719
approach is to put it inside an extended

01:19:46,479 --> 01:19:51,820
C++ compiler the current C Faso slash

01:19:49,719 --> 01:19:54,159
WinRT work that can occur and the

01:19:51,820 --> 01:19:55,900
colleagues are doing goes a bit back to

01:19:54,159 --> 01:19:58,690
the calm approach of putting it in a

01:19:55,900 --> 01:19:59,979
separate middle compiler so you still

01:19:58,690 --> 01:20:02,289
have the extra information but we'll

01:19:59,979 --> 01:20:04,059
keep it away from the c4s compiler but

01:20:02,289 --> 01:20:05,949
we still have a separate compiler this

01:20:04,059 --> 01:20:08,619
is much more like the cute mock model

01:20:05,949 --> 01:20:10,929
and I would like to be able to have just

01:20:08,619 --> 01:20:13,030
my single compiler be able to compile

01:20:10,929 --> 01:20:14,739
all this which includes omitting

01:20:13,030 --> 01:20:17,019
information that's needed by the

01:20:14,739 --> 01:20:21,460
framework cute omits some metadata they

01:20:17,019 --> 01:20:23,469
need the windows team has to admit a win

01:20:21,460 --> 01:20:25,719
MD file of Windows metadata so I have to

01:20:23,469 --> 01:20:27,789
be able to do some file i/o at compile

01:20:25,719 --> 01:20:29,979
time as well or as a separate build step

01:20:27,789 --> 01:20:32,380
I can write generate a function that I

01:20:29,979 --> 01:20:34,710
run as a build step that generates that

01:20:32,380 --> 01:20:37,360
from the metadata that I reflected over

01:20:34,710 --> 01:20:39,099
so how do would this look the general

01:20:37,360 --> 01:20:41,550
idea I wouldn't worry about the

01:20:39,099 --> 01:20:44,340
specifics the general idea is look

01:20:41,550 --> 01:20:46,989
non-standard non-portable complex code

01:20:44,340 --> 01:20:48,729
potentially standard portable simpler

01:20:46,989 --> 01:20:52,269
code that's the takeaway

01:20:48,729 --> 01:20:53,979
and if I say Archie interface that's my

01:20:52,269 --> 01:20:56,789
generalized opt-in that can say things

01:20:53,979 --> 01:21:00,400
like aia inherit from my inspectable I

01:20:56,789 --> 01:21:03,159
must have only public datum public

01:21:00,400 --> 01:21:06,059
member member variables things like that

01:21:03,159 --> 01:21:09,670
and all of my functions that I declare

01:21:06,059 --> 01:21:11,170
must be under the covers transformed so

01:21:09,670 --> 01:21:12,849
that whatever their actual return type

01:21:11,170 --> 01:21:15,760
that I declared in the source code was

01:21:12,849 --> 01:21:17,829
becomes an out parameter and a pointer

01:21:15,760 --> 01:21:18,519
to that and gets replaced by H results

01:21:17,829 --> 01:21:21,400
because that's what the underlying

01:21:18,519 --> 01:21:23,499
system needs all of that is done by a

01:21:21,400 --> 01:21:25,360
separate compiler today it would be nice

01:21:23,499 --> 01:21:27,999
if we could do that transformation by

01:21:25,360 --> 01:21:33,820
transforming the source to the generated

01:21:27,999 --> 01:21:35,409
C++ type in C++ one other example just

01:21:33,820 --> 01:21:38,260
so you know it's not just about cute and

01:21:35,409 --> 01:21:40,090
Windows I gave a version a smaller

01:21:38,260 --> 01:21:44,099
version of this talk about a month ago

01:21:40,090 --> 01:21:47,889
to a group of physicists and

01:21:44,099 --> 01:21:49,809
particularly at audio the how do project

01:21:47,889 --> 01:21:52,239
they do something similar again they

01:21:49,809 --> 01:21:54,579
write yamo that goes that gets run

01:21:52,239 --> 01:21:57,400
through a compiler and here is their

01:21:54,579 --> 01:22:00,280
llamo script they write example screw

01:21:57,400 --> 01:22:01,690
hit : that's going to be a type and then

01:22:00,280 --> 01:22:02,860
if there's a description and author and

01:22:01,690 --> 01:22:04,989
there are some members that look

01:22:02,860 --> 01:22:06,849
specific looks suspiciously member like

01:22:04,989 --> 01:22:10,179
but except that they're bullet list of

01:22:06,849 --> 01:22:12,699
text and from this they generate through

01:22:10,179 --> 01:22:15,209
the siamo script five interrelated

01:22:12,699 --> 01:22:17,199
classes with a separate code generator

01:22:15,209 --> 01:22:22,690
wouldn't it be nice if they could just

01:22:17,199 --> 01:22:24,429
say patio : : data type and then yes

01:22:22,690 --> 01:22:26,229
anything the string we treat that as a

01:22:24,429 --> 01:22:28,239
context for spring for a string for your

01:22:26,229 --> 01:22:29,650
description and author your data members

01:22:28,239 --> 01:22:32,530
we know what those are and then we

01:22:29,650 --> 01:22:36,130
generate those same five overlapping and

01:22:32,530 --> 01:22:37,869
interrelated types from just this one

01:22:36,130 --> 01:22:41,440
that contains all the information that

01:22:37,869 --> 01:22:45,550
we have today as a non c+ a script can

01:22:41,440 --> 01:22:47,489
we bring it into the language there's a

01:22:45,550 --> 01:22:49,749
new book out if you haven't already you

01:22:47,489 --> 01:22:51,429
run don't walk because I think the

01:22:49,749 --> 01:22:52,719
bookstore sold its last copy yesterday

01:22:51,429 --> 01:22:55,209
already but they might be getting more

01:22:52,719 --> 01:22:55,840
so thank you should've heed to dog and

01:22:55,209 --> 01:22:59,410
to Niko

01:22:55,840 --> 01:23:01,570
who is also here today - for writing

01:22:59,410 --> 01:23:04,660
this very nice book second edition of

01:23:01,570 --> 01:23:05,740
C++ templates and I just had to page

01:23:04,660 --> 01:23:07,900
through it when I saw it for the first

01:23:05,740 --> 01:23:12,010
time on Sunday night and so I took a

01:23:07,900 --> 01:23:13,980
picture I love phones and so I think

01:23:12,010 --> 01:23:16,750
this is fair use sorry guys

01:23:13,980 --> 01:23:18,400
there's this page 495 about the

01:23:16,750 --> 01:23:19,690
curiously recurring template pattern you

01:23:18,400 --> 01:23:22,270
will see in a moment why I flipped

01:23:19,690 --> 01:23:23,470
straight to that page the very first

01:23:22,270 --> 01:23:25,180
thing you might notice about the first

01:23:23,470 --> 01:23:27,040
three lines is that you might call them

01:23:25,180 --> 01:23:29,050
the curiously recurring curiously

01:23:27,040 --> 01:23:31,950
recurring template powder and CRT P

01:23:29,050 --> 01:23:35,470
pattern because they repeat that whole

01:23:31,950 --> 01:23:38,470
string in those first three lines but

01:23:35,470 --> 01:23:42,460
the idea is that you template i's a base

01:23:38,470 --> 01:23:45,310
class and the derived type gets stuck in

01:23:42,460 --> 01:23:46,450
as the base parameter and once you see

01:23:45,310 --> 01:23:49,390
this first of all how many of you have

01:23:46,450 --> 01:23:51,850
seen or used CRT P it's one of those

01:23:49,390 --> 01:23:53,410
acronyms of consonants that we invent

01:23:51,850 --> 01:23:57,220
because see puzzles can never have

01:23:53,410 --> 01:23:58,600
enough of those NS DMI is any one but

01:23:57,220 --> 01:24:01,150
there's one question that you should ask

01:23:58,600 --> 01:24:04,020
yourself about the curiously recurring

01:24:01,150 --> 01:24:04,020
template pattern

01:24:06,610 --> 01:24:12,260
why do we do it what's it for

01:24:10,340 --> 01:24:18,710
in a nutshell yell it out a couple of

01:24:12,260 --> 01:24:21,020
words composition to query the derived

01:24:18,710 --> 01:24:23,840
class yes so we customize the base class

01:24:21,020 --> 01:24:25,780
based on the derived class sound

01:24:23,840 --> 01:24:29,630
familiar

01:24:25,780 --> 01:24:34,100
here's an example from the book slightly

01:24:29,630 --> 01:24:36,560
cleaned up of a CRT pe quality

01:24:34,100 --> 01:24:40,360
comparable again templatized by its

01:24:36,560 --> 01:24:43,490
derive type it exists just to inject the

01:24:40,360 --> 01:24:45,620
not equals operator into the derive type

01:24:43,490 --> 01:24:47,690
and then the derive type says class X

01:24:45,620 --> 01:24:54,350
colon public equality comparable of me

01:24:47,690 --> 01:24:59,120
of X and passes itself in just about

01:24:54,350 --> 01:25:00,830
line for line because CRT P I'm still

01:24:59,120 --> 01:25:02,360
going through the exploration but it

01:25:00,830 --> 01:25:04,580
seems to me that all the users I've seen

01:25:02,360 --> 01:25:06,680
so far of CRT P are doing what

01:25:04,580 --> 01:25:09,170
metaclasses aim to do in a more general

01:25:06,680 --> 01:25:11,690
way you are trying to query something

01:25:09,170 --> 01:25:13,490
about the the derive type and provide

01:25:11,690 --> 01:25:15,560
something in the base that customizes it

01:25:13,490 --> 01:25:18,710
and of course reflection will only help

01:25:15,560 --> 01:25:20,840
CRT P do more things wouldn't it be nice

01:25:18,710 --> 01:25:24,250
if we could give a shovel to say it more

01:25:20,840 --> 01:25:27,620
directly instead of abusing a useful but

01:25:24,250 --> 01:25:30,530
not designed for it of the language

01:25:27,620 --> 01:25:33,650
feature which is templates here's one

01:25:30,530 --> 01:25:35,240
other example and again very similarly I

01:25:33,650 --> 01:25:37,430
don't have the exact syntax yet for

01:25:35,240 --> 01:25:39,560
rejecting those wrapper functions but

01:25:37,430 --> 01:25:41,660
again it's one for one what we do with

01:25:39,560 --> 01:25:43,790
meta classes and we're doing it already

01:25:41,660 --> 01:25:45,320
so some open questions we have to

01:25:43,790 --> 01:25:46,010
validate the compile times are going to

01:25:45,320 --> 01:25:48,500
be good enough

01:25:46,010 --> 01:25:51,020
is this still c-plus also are we turning

01:25:48,500 --> 01:25:54,620
this into Lisp which could also generate

01:25:51,020 --> 01:25:56,390
compile time stuff to the extent that we

01:25:54,620 --> 01:25:58,040
make sure that we are automating and

01:25:56,390 --> 01:26:00,920
providing direct support for things we

01:25:58,040 --> 01:26:02,990
are already doing in C++ we can be sure

01:26:00,920 --> 01:26:05,240
that yes we are still c++ that we

01:26:02,990 --> 01:26:08,450
haven't turned a corner and garna stray

01:26:05,240 --> 01:26:10,660
somewhere will this create divergence

01:26:08,450 --> 01:26:14,150
what if n companies define interface

01:26:10,660 --> 01:26:16,730
absolutely when BR Anna gave us classes

01:26:14,150 --> 01:26:19,300
what if AC programmer had said to you oh

01:26:16,730 --> 01:26:20,559
darn it classes

01:26:19,300 --> 01:26:23,170
people can write their own data types

01:26:20,559 --> 01:26:29,670
that way lies madness I mean everybody

01:26:23,170 --> 01:26:34,239
might write their own string type true

01:26:29,670 --> 01:26:35,650
they did but classes are still useful

01:26:34,239 --> 01:26:37,030
and we wouldn't want could not live

01:26:35,650 --> 01:26:40,840
without them and they still have driven

01:26:37,030 --> 01:26:42,579
a generation of the industry into far

01:26:40,840 --> 01:26:45,989
larger and productive and scalable

01:26:42,579 --> 01:26:49,239
systems so a meta class is another

01:26:45,989 --> 01:26:51,159
encapsulation and how will we debug this

01:26:49,239 --> 01:26:54,429
will I sit in the example see the

01:26:51,159 --> 01:26:57,099
compiler debug we already have generated

01:26:54,429 --> 01:26:59,829
functions we already need support for

01:26:57,099 --> 01:27:01,659
step into generated function anything we

01:26:59,829 --> 01:27:03,670
do for meta classes will directly help

01:27:01,659 --> 01:27:04,840
those existing uses we already have and

01:27:03,670 --> 01:27:07,449
the way to think about this a key

01:27:04,840 --> 01:27:09,369
mindset here is just go back to always

01:27:07,449 --> 01:27:11,230
thinking hey the idea of meta classes is

01:27:09,369 --> 01:27:13,480
the class instruct are the first two

01:27:11,230 --> 01:27:15,730
meta classes and a Newman Union the

01:27:13,480 --> 01:27:16,960
third the second and fourth that but

01:27:15,730 --> 01:27:19,090
they're just baked into the language

01:27:16,960 --> 01:27:21,610
could I write me some of those using

01:27:19,090 --> 01:27:25,510
compiled time code please that's the

01:27:21,610 --> 01:27:28,389
idea and notice the keyword already is

01:27:25,510 --> 01:27:30,340
all over that slide it's still very C+

01:27:28,389 --> 01:27:33,070
us because we're already doing these

01:27:30,340 --> 01:27:35,530
things they curiously recur we should

01:27:33,070 --> 01:27:37,530
ask ourselves why and that give

01:27:35,530 --> 01:27:42,010
something direct for it

01:27:37,530 --> 01:27:43,420
so recall abstractions or hiders and the

01:27:42,010 --> 01:27:46,239
whole point of the example I gave is

01:27:43,420 --> 01:27:48,099
that I already showing you that yes we

01:27:46,239 --> 01:27:52,800
need to expose what is generated the

01:27:48,099 --> 01:27:55,329
actual definition doing that using

01:27:52,800 --> 01:27:57,400
concepts for compiler debug is a first

01:27:55,329 --> 01:28:01,770
step but it's exactly the kind of thing

01:27:57,400 --> 01:28:03,909
the debuggers and ids will need to do a

01:28:01,770 --> 01:28:06,969
last thought about making see Foss is

01:28:03,909 --> 01:28:11,409
powerful and simpler the way you make

01:28:06,969 --> 01:28:15,070
something bigger but more simple to use

01:28:11,409 --> 01:28:17,199
is to add abstraction and there's two

01:28:15,070 --> 01:28:20,559
kinds of abstraction ones built into the

01:28:17,199 --> 01:28:22,150
language and user-defined ones ones

01:28:20,559 --> 01:28:24,790
where the users can make their own word

01:28:22,150 --> 01:28:28,059
of power we only have two of those in

01:28:24,790 --> 01:28:29,349
C++ today the function and the class now

01:28:28,059 --> 01:28:30,730
some of you might say well that's that's

01:28:29,349 --> 01:28:33,190
not right we have so many features

01:28:30,730 --> 01:28:34,840
templates but templates

01:28:33,190 --> 01:28:36,100
amateur eyes types and functions they

01:28:34,840 --> 01:28:38,500
don't encapsulate anything they don't

01:28:36,100 --> 01:28:40,890
capsulate behavior overloading

01:28:38,500 --> 01:28:44,140
absolutely static polymorphism wonderful

01:28:40,890 --> 01:28:46,830
but it doesn't hide anything it's not an

01:28:44,140 --> 01:28:49,719
encapsulating user-defined abstraction

01:28:46,830 --> 01:28:51,820
even modules groups things together and

01:28:49,719 --> 01:28:54,610
it is an isolation boundary that's very

01:28:51,820 --> 01:28:57,250
important it's not doesn't encapsulate

01:28:54,610 --> 01:28:58,690
behavior so much as grouping so it's not

01:28:57,250 --> 01:29:01,449
creating a new behavioral thing like a

01:28:58,690 --> 01:29:03,160
class does all of those are absolutely

01:29:01,449 --> 01:29:05,590
valid and useful we want more of them

01:29:03,160 --> 01:29:08,650
but I'm hopeful that meta classes might

01:29:05,590 --> 01:29:11,710
be the third of those things that

01:29:08,650 --> 01:29:14,199
actually let users define words of power

01:29:11,710 --> 01:29:16,690
in a way that simplifies how we use the

01:29:14,199 --> 01:29:19,330
language so we want to expand our

01:29:16,690 --> 01:29:21,670
attraction vocabulary use it for

01:29:19,330 --> 01:29:23,350
everything from enforcing using

01:29:21,670 --> 01:29:25,540
reflection and compile-time programming

01:29:23,350 --> 01:29:27,520
to enforce coding standards to write

01:29:25,540 --> 01:29:30,460
language extensions as library code and

01:29:27,520 --> 01:29:32,469
many kinds of them then we don't have to

01:29:30,460 --> 01:29:34,000
wait for new compilers we can share

01:29:32,469 --> 01:29:36,040
language features what would otherwise

01:29:34,000 --> 01:29:39,100
be language features like property as a

01:29:36,040 --> 01:29:41,860
library and that means we can also take

01:29:39,100 --> 01:29:43,180
not all but at least some of the

01:29:41,860 --> 01:29:45,130
language feature proposals that are

01:29:43,180 --> 01:29:46,810
going through committee and perhaps

01:29:45,130 --> 01:29:49,180
treat them as libraries which are easier

01:29:46,810 --> 01:29:50,739
to debug much less expensive to process

01:29:49,180 --> 01:29:53,620
and you don't have to wait as long to

01:29:50,739 --> 01:29:54,580
get them in your implementations so

01:29:53,620 --> 01:29:56,320
remember all of this is under

01:29:54,580 --> 01:29:58,270
construction but I picked this example

01:29:56,320 --> 01:30:02,880
for a reason I believe that is the

01:29:58,270 --> 01:30:05,770
construction in Hyderabad in India of a

01:30:02,880 --> 01:30:07,870
monorail system and you'll notice that

01:30:05,770 --> 01:30:09,310
you know you haven't gone off track when

01:30:07,870 --> 01:30:12,940
you stay parallel to your original

01:30:09,310 --> 01:30:14,800
traffic road the same is true in c+ offs

01:30:12,940 --> 01:30:16,690
we can generate all sorts of bridges to

01:30:14,800 --> 01:30:19,449
nowhere that don't belong in our

01:30:16,690 --> 01:30:21,130
language the way we stay rooted and make

01:30:19,449 --> 01:30:23,590
sure that we're doing things that belong

01:30:21,130 --> 01:30:26,560
in our language is to make the roads we

01:30:23,590 --> 01:30:29,080
are already traveling easier cheaper

01:30:26,560 --> 01:30:32,530
more direct more high bandwidth to

01:30:29,080 --> 01:30:35,020
travel if we can find people who are

01:30:32,530 --> 01:30:37,930
digging with spoons that gives us the

01:30:35,020 --> 01:30:39,880
examples and use cases it demonstrates

01:30:37,930 --> 01:30:41,350
the need and value of what we're doing

01:30:39,880 --> 01:30:43,480
and so I'm trying very hard to stick

01:30:41,350 --> 01:30:44,830
close to that if you want to find out

01:30:43,480 --> 01:30:46,690
more about how some of these things are

01:30:44,830 --> 01:30:48,280
implemented see Andrews talks at

01:30:46,690 --> 01:30:50,110
clock today at at nine o'clock tomorrow

01:30:48,280 --> 01:30:51,820
morning again warning it's not about

01:30:50,110 --> 01:30:55,090
using them you won't see examples that

01:30:51,820 --> 01:30:56,739
are of uses like we did today going

01:30:55,090 --> 01:30:58,390
through but you will see what does it

01:30:56,739 --> 01:31:00,699
take to implement this incline how did

01:30:58,390 --> 01:31:02,469
he as he was implementing these things

01:31:00,699 --> 01:31:04,150
what did it teach him about how she

01:31:02,469 --> 01:31:06,160
process works and how these things need

01:31:04,150 --> 01:31:08,469
to integrate in so especially if you

01:31:06,160 --> 01:31:11,050
have an implementation mindset check out

01:31:08,469 --> 01:31:12,430
his talks we have a couple of minutes

01:31:11,050 --> 01:31:14,080
left for questions and a couple of

01:31:12,430 --> 01:31:16,480
microphones would anyone like to ask a

01:31:14,080 --> 01:31:18,900
few questions and then you can stop me

01:31:16,480 --> 01:31:18,900
when we're done

01:31:24,950 --> 01:31:30,960
hello I think that uh an important

01:31:29,160 --> 01:31:33,660
subject matter in your presentation is

01:31:30,960 --> 01:31:35,610
that they standardise because it is

01:31:33,660 --> 01:31:38,970
written in English doesn't help pretty

01:31:35,610 --> 01:31:41,850
much anybody so is he not a good

01:31:38,970 --> 01:31:44,490
proposition to build a language to

01:31:41,850 --> 01:31:49,490
specify things into the language so that

01:31:44,490 --> 01:31:52,580
the specification is code so that is a

01:31:49,490 --> 01:31:55,350
valid approach Lisp did that for example

01:31:52,580 --> 01:31:57,780
this is you might view it as somewhat in

01:31:55,350 --> 01:32:00,810
an attempt to that but there has been no

01:31:57,780 --> 01:32:04,890
work on a general meta C++ meta language

01:32:00,810 --> 01:32:06,630
that describes C++ that VR net has has

01:32:04,890 --> 01:32:08,160
stuck very close to make sure the

01:32:06,630 --> 01:32:09,870
c-pulse of standard library can be

01:32:08,160 --> 01:32:12,390
implemented in C++ which is almost

01:32:09,870 --> 01:32:14,130
entirely true but not that the whole

01:32:12,390 --> 01:32:15,510
language can be SPECT so no there's been

01:32:14,130 --> 01:32:19,220
no work in that but other languages have

01:32:15,510 --> 01:32:22,680
tried that it leads to different places

01:32:19,220 --> 01:32:24,360
hi there I was listening to your talking

01:32:22,680 --> 01:32:26,310
I was a bit skeptical after all you're

01:32:24,360 --> 01:32:29,310
about to give us a very sharp knife here

01:32:26,310 --> 01:32:32,370
right so you had me when you talked

01:32:29,310 --> 01:32:33,690
about flack in ohms because that is very

01:32:32,370 --> 01:32:35,460
clearly thing that would be useful to

01:32:33,690 --> 01:32:39,210
have but it's kind of very clearly thing

01:32:35,460 --> 01:32:40,620
to which the flack enums are it's very

01:32:39,210 --> 01:32:42,180
clearly a thing that it's not worth like

01:32:40,620 --> 01:32:43,920
making it a language feature but it

01:32:42,180 --> 01:32:47,190
would be good to have so I saw like okay

01:32:43,920 --> 01:32:48,840
this could be really useful what made me

01:32:47,190 --> 01:32:51,120
a little bit concerned is when you said

01:32:48,840 --> 01:32:52,710
like it would be very difficult to agree

01:32:51,120 --> 01:32:54,600
in the standards committee on what an

01:32:52,710 --> 01:32:56,850
interface should look like it's much

01:32:54,600 --> 01:32:59,130
easier if we have this meta feature so

01:32:56,850 --> 01:33:01,860
people can define interface ah

01:32:59,130 --> 01:33:03,900
and I just bet you that you still do the

01:33:01,860 --> 01:33:06,000
work in the Standards Committee and

01:33:03,900 --> 01:33:07,800
agree on what an interface and an enum

01:33:06,000 --> 01:33:09,600
and all that is so that you specify it

01:33:07,800 --> 01:33:11,400
and you can ship a standards library

01:33:09,600 --> 01:33:13,800
that comes with them because otherwise

01:33:11,400 --> 01:33:16,350
everyone is going to build on themselves

01:33:13,800 --> 01:33:18,150
so so I still do the work it might be

01:33:16,350 --> 01:33:19,530
easier if you have like a framework for

01:33:18,150 --> 01:33:21,990
that kind of work so so let me

01:33:19,530 --> 01:33:23,720
completely agree with you and clarify

01:33:21,990 --> 01:33:27,600
something to make sure it's really clear

01:33:23,720 --> 01:33:28,890
just like with classes very common and I

01:33:27,600 --> 01:33:31,890
guess I forgot to say this and very

01:33:28,890 --> 01:33:33,890
common widely used metaclasses

01:33:31,890 --> 01:33:36,370
would also be put in the namespace STD

01:33:33,890 --> 01:33:38,170
why right interface more than once

01:33:36,370 --> 01:33:39,550
where I was where I was going with that

01:33:38,170 --> 01:33:41,530
the reason it wouldn't be standardized

01:33:39,550 --> 01:33:42,580
is not because of controversy property

01:33:41,530 --> 01:33:45,010
probably would fail because of

01:33:42,580 --> 01:33:46,600
controversy interface wouldn't but just

01:33:45,010 --> 01:33:49,150
because is it really worth its Freight

01:33:46,600 --> 01:33:50,920
is it worth 18 pages or whatever our

01:33:49,150 --> 01:33:52,690
standard ease and potentially

01:33:50,920 --> 01:33:55,750
bifurcating the type system again as we

01:33:52,690 --> 01:33:57,100
did with EMU to add it as a baked in

01:33:55,750 --> 01:33:58,360
language feature compiler writers would

01:33:57,100 --> 01:33:58,870
have to implement doesn't seem

01:33:58,360 --> 01:34:00,990
worthwhile

01:33:58,870 --> 01:34:03,730
yes it's useful but it's not that useful

01:34:00,990 --> 01:34:05,260
whereas if I had a general feature like

01:34:03,730 --> 01:34:08,110
this and I could write it as a 10 line

01:34:05,260 --> 01:34:09,280
library I'll bet you dollars to donuts

01:34:08,110 --> 01:34:12,340
that would sail through library

01:34:09,280 --> 01:34:13,660
evolution working group okay it's just

01:34:12,340 --> 01:34:15,700
like don't give us the knife if you

01:34:13,660 --> 01:34:18,190
don't give us like some nicely calm oh

01:34:15,700 --> 01:34:20,020
absolutely you so ready or we will hurt

01:34:18,190 --> 01:34:21,640
like all other abstractions we should

01:34:20,020 --> 01:34:23,410
standardize common ones and then we can

01:34:21,640 --> 01:34:24,880
but then because it's code we can have a

01:34:23,410 --> 01:34:29,890
much better time agreeing on exactly

01:34:24,880 --> 01:34:32,350
what it should be rkc Thanks can you go

01:34:29,890 --> 01:34:37,120
back to any slides as you're iterating

01:34:32,350 --> 01:34:40,480
over a cast member functions can you

01:34:37,120 --> 01:34:43,360
just ask the question verbally okay okay

01:34:40,480 --> 01:34:47,410
can you go back to any slides which are

01:34:43,360 --> 01:34:49,480
you eating over crossmembers yeah I

01:34:47,410 --> 01:34:51,220
understood but I was just thinking of

01:34:49,480 --> 01:34:52,030
saving the time to go back to a slide oh

01:34:51,220 --> 01:34:57,820
sorry

01:34:52,030 --> 01:34:59,860
let's set me yeah somewhere around size

01:34:57,820 --> 01:35:02,800
that you have the full loop and make

01:34:59,860 --> 01:35:07,210
songs how about that one yeah so you I

01:35:02,800 --> 01:35:11,590
saw you use the syntax or to F :

01:35:07,210 --> 01:35:15,100
so this cop is the same generated from

01:35:11,590 --> 01:35:19,350
function sequence right so it's it seems

01:35:15,100 --> 01:35:21,850
that when you're modifying F the changes

01:35:19,350 --> 01:35:25,750
directly propagate you into the language

01:35:21,850 --> 01:35:29,620
but what if I won't have a destroying

01:35:25,750 --> 01:35:32,530
copy of the metal object pointed to by F

01:35:29,620 --> 01:35:33,580
and make changes over there and swept it

01:35:32,530 --> 01:35:36,070
back yes

01:35:33,580 --> 01:35:38,110
so the the short answer to your question

01:35:36,070 --> 01:35:41,650
will besides go also see Andrews talk

01:35:38,110 --> 01:35:44,410
but the current syntax uses an in-place

01:35:41,650 --> 01:35:46,390
semantics that is I'm modifying my

01:35:44,410 --> 01:35:47,770
meadow class as if in place there are

01:35:46,390 --> 01:35:49,989
good reasons why we're probably going to

01:35:47,770 --> 01:35:51,400
switch to a source destination

01:35:49,989 --> 01:35:53,499
syntax where basically the code is the

01:35:51,400 --> 01:35:54,969
same but I believe in the current

01:35:53,499 --> 01:35:57,730
prototype you would actually say dollar

01:35:54,969 --> 01:35:59,739
prototype dot functions so it's another

01:35:57,730 --> 01:36:01,480
class and then you would inject each one

01:35:59,739 --> 01:36:03,610
instead of it having to be there so the

01:36:01,480 --> 01:36:05,199
structure is the same but you're right

01:36:03,610 --> 01:36:06,159
this has in place semantics and that's

01:36:05,199 --> 01:36:07,780
one of the things we're looking at

01:36:06,159 --> 01:36:10,239
saying is that really the right thing or

01:36:07,780 --> 01:36:13,090
should it be copied from here and

01:36:10,239 --> 01:36:15,099
generate here could lead to clearer code

01:36:13,090 --> 01:36:15,789
yes so we're definitely pursuing that

01:36:15,099 --> 01:36:18,849
Thanks

01:36:15,789 --> 01:36:21,010
yeah good observation I had a couple of

01:36:18,849 --> 01:36:24,400
questions possible added to that last

01:36:21,010 --> 01:36:25,690
question in the literal type example I

01:36:24,400 --> 01:36:28,090
talked about generating they make

01:36:25,690 --> 01:36:30,249
underscore functions as well but that

01:36:28,090 --> 01:36:32,099
would be outside the class or its

01:36:30,249 --> 01:36:34,510
intention to be something like France

01:36:32,099 --> 01:36:36,610
contrasting with e if Const expert which

01:36:34,510 --> 01:36:38,829
definitely maintains the scope for good

01:36:36,610 --> 01:36:40,809
reason so all of the examples that I

01:36:38,829 --> 01:36:42,159
show in the paper and all of the

01:36:40,809 --> 01:36:43,599
examples that the prototype compiler

01:36:42,159 --> 01:36:46,690
currently supports although that's about

01:36:43,599 --> 01:36:49,269
to change is transfer transforming one

01:36:46,690 --> 01:36:52,989
class written in source code to generate

01:36:49,269 --> 01:36:55,630
one class the pod IO example already

01:36:52,989 --> 01:36:57,670
goes from one to five and generating

01:36:55,630 --> 01:36:59,889
non-members or injecting into enclosing

01:36:57,670 --> 01:37:02,110
namespaces absolutely as necessary and

01:36:59,889 --> 01:37:03,429
so that will be added as well because

01:37:02,110 --> 01:37:04,960
then otherwise you wouldn't be able to

01:37:03,429 --> 01:37:07,239
do literal value because it requires

01:37:04,960 --> 01:37:10,420
generating non-member functions as well

01:37:07,239 --> 01:37:11,980
yeah so okay great the other question I

01:37:10,420 --> 01:37:15,099
had was also that literal value assuming

01:37:11,980 --> 01:37:16,630
literal value is clear enough that it

01:37:15,099 --> 01:37:20,800
would easily go into the standard

01:37:16,630 --> 01:37:22,900
library of medic asses would you then

01:37:20,800 --> 01:37:24,639
consider it likely that we would see

01:37:22,900 --> 01:37:27,519
things like pair restated in the

01:37:24,639 --> 01:37:29,409
standard as literal type maybe rather

01:37:27,519 --> 01:37:31,809
than all the standard these we have now

01:37:29,409 --> 01:37:33,039
so this this is all very speculative but

01:37:31,809 --> 01:37:34,780
you know granting for the sake of

01:37:33,039 --> 01:37:36,219
discussion that this goes anywhere that

01:37:34,780 --> 01:37:38,440
it works that it becomes standardized

01:37:36,219 --> 01:37:40,570
that you have a standard literal literal

01:37:38,440 --> 01:37:43,630
value then we can have the discussion as

01:37:40,570 --> 01:37:47,320
we always do is can the standard library

01:37:43,630 --> 01:37:48,940
adopt the new language feature without a

01:37:47,320 --> 01:37:50,469
breaking change because then you then

01:37:48,940 --> 01:37:51,940
the standard library vendors would have

01:37:50,469 --> 01:37:54,730
to think about what would this be an ABI

01:37:51,940 --> 01:37:55,900
break maybe for the existing ones will

01:37:54,730 --> 01:37:57,670
still write them the way we did before

01:37:55,900 --> 01:38:00,460
but new things will write using the new

01:37:57,670 --> 01:38:01,130
tool perhaps will deprecated those ones

01:38:00,460 --> 01:38:03,560
and then

01:38:01,130 --> 01:38:05,179
transition people over or maybe it's not

01:38:03,560 --> 01:38:06,860
a breaking change at all we will be

01:38:05,179 --> 01:38:08,810
careful to write the literal value

01:38:06,860 --> 01:38:10,820
metaclass so it generates exactly what

01:38:08,810 --> 01:38:13,580
we have now and then we can just go do

01:38:10,820 --> 01:38:15,020
it that would be the exercise you would

01:38:13,580 --> 01:38:16,820
get to at that point that's like three

01:38:15,020 --> 01:38:18,440
or four steps major steps beyond where

01:38:16,820 --> 01:38:20,090
we are but that's the kind of thing that

01:38:18,440 --> 01:38:22,639
we would do and that we do already with

01:38:20,090 --> 01:38:24,530
other proposals where the standard

01:38:22,639 --> 01:38:27,800
library is adopting a new language

01:38:24,530 --> 01:38:30,020
feature thank you Peter my main question

01:38:27,800 --> 01:38:31,760
about composability has mostly been

01:38:30,020 --> 01:38:34,159
answered already by the last two

01:38:31,760 --> 01:38:36,800
questions and thank you for giving my

01:38:34,159 --> 01:38:39,260
students next decade of a lot of

01:38:36,800 --> 01:38:43,179
interesting work to do

01:38:39,260 --> 01:38:43,179
thank you and you're welcome I think I

01:38:43,780 --> 01:38:48,530
thank you for a great talk and to my

01:38:46,340 --> 01:38:51,469
question I'm just curious how far can we

01:38:48,530 --> 01:38:53,989
go and how far are we from templates for

01:38:51,469 --> 01:38:56,060
many classes oh we absolutely need

01:38:53,989 --> 01:38:58,520
template and meta classes so one example

01:38:56,060 --> 01:39:01,070
that was in these slides is property so

01:38:58,520 --> 01:39:04,610
you would define that A's template class

01:39:01,070 --> 01:39:06,350
T dollar class property because that's

01:39:04,610 --> 01:39:09,080
how you would say I want a property of

01:39:06,350 --> 01:39:13,130
type int and you could say property

01:39:09,080 --> 01:39:16,670
angle into angle my property okay thank

01:39:13,130 --> 01:39:18,860
you yes not that you already don't have

01:39:16,670 --> 01:39:20,110
enough to do with meta classes but have

01:39:18,860 --> 01:39:24,080
you given any thought to having

01:39:20,110 --> 01:39:25,730
inheritance a meta classes for example

01:39:24,080 --> 01:39:28,639
if you're in a company and you want to

01:39:25,730 --> 01:39:31,130
specify that all classes have an

01:39:28,639 --> 01:39:32,389
assignment operator or they all have

01:39:31,130 --> 01:39:35,120
something which would give you the major

01:39:32,389 --> 01:39:36,650
minor version of that class so everyone

01:39:35,120 --> 01:39:40,130
in the company could start with that

01:39:36,650 --> 01:39:42,590
base interface and then create their own

01:39:40,130 --> 01:39:44,659
interfaces from that yes and again this

01:39:42,590 --> 01:39:46,639
is so some people will view this as a

01:39:44,659 --> 01:39:48,679
wonderful thing and I think it is some

01:39:46,639 --> 01:39:50,780
people will exactly be worried about the

01:39:48,679 --> 01:39:52,790
bifurcation of companies specific styles

01:39:50,780 --> 01:39:55,370
so what else what I'll point out using

01:39:52,790 --> 01:39:56,900
this as an example is that the way you

01:39:55,370 --> 01:39:58,969
phrase your question shows your company

01:39:56,900 --> 01:40:00,590
is in fact already doing this probably

01:39:58,969 --> 01:40:02,780
just enforcing it with linters and other

01:40:00,590 --> 01:40:04,429
kinds of tools or not enforcing it so it

01:40:02,780 --> 01:40:07,280
again it's something we are already

01:40:04,429 --> 01:40:10,100
doing we will do it much more rigorously

01:40:07,280 --> 01:40:12,139
and predictably and correctly and simply

01:40:10,100 --> 01:40:13,510
if we can just say it in code another

01:40:12,139 --> 01:40:15,730
example that's come up when

01:40:13,510 --> 01:40:18,730
like usability studies one of the things

01:40:15,730 --> 01:40:20,230
we learned is everybody comes up with a

01:40:18,730 --> 01:40:21,520
use they could use in their current

01:40:20,230 --> 01:40:23,710
project for metaclasses and they're all

01:40:21,520 --> 01:40:25,480
different one is for coding guidelines

01:40:23,710 --> 01:40:27,910
or custom conventions like you have

01:40:25,480 --> 01:40:30,130
another one was that they said in their

01:40:27,910 --> 01:40:32,610
shop they use a robotics library

01:40:30,130 --> 01:40:34,750
it was a machine library or so the is a

01:40:32,610 --> 01:40:37,600
controlled machine numerically

01:40:34,750 --> 01:40:39,700
controlled machine and to use this

01:40:37,600 --> 01:40:41,350
library the library required all of your

01:40:39,700 --> 01:40:43,720
classes had to follow a certain pattern

01:40:41,350 --> 01:40:45,580
which right now they do by hand they

01:40:43,720 --> 01:40:47,320
forget them things break and it's hard

01:40:45,580 --> 01:40:48,910
to debug where they could just write the

01:40:47,320 --> 01:40:50,260
pattern once as a meta class they

01:40:48,910 --> 01:40:52,600
figured they could do it in like 20 30

01:40:50,260 --> 01:40:54,460
lines and then they'd never have to

01:40:52,600 --> 01:40:55,989
worry about that problem again and it

01:40:54,460 --> 01:40:57,670
would be just okay here is the

01:40:55,989 --> 01:40:59,890
convention in code of what this library

01:40:57,670 --> 01:41:01,840
requires so that's probably similar to

01:40:59,890 --> 01:41:03,550
your execu you know thank you

01:41:01,840 --> 01:41:05,170
we probably have time for just one or

01:41:03,550 --> 01:41:06,730
two more so let me take one each

01:41:05,170 --> 01:41:08,080
apologies to everybody else who's

01:41:06,730 --> 01:41:10,540
waiting but I'll be up here for a bit

01:41:08,080 --> 01:41:13,239
after so how does your compiler don't

01:41:10,540 --> 01:41:15,190
require differ from a static research

01:41:13,239 --> 01:41:17,860
how does compiler that require differ

01:41:15,190 --> 01:41:20,110
from static I served a look at my paper

01:41:17,860 --> 01:41:22,060
Pio 7:07 there's a discussion of that in

01:41:20,110 --> 01:41:23,770
there the short version is it can be

01:41:22,060 --> 01:41:26,200
integrated into compiler error messages

01:41:23,770 --> 01:41:28,030
you have some usability benefits that

01:41:26,200 --> 01:41:31,270
that you don't have with static assert

01:41:28,030 --> 01:41:34,960
for example in a meta class you can

01:41:31,270 --> 01:41:38,070
write that what's the example I'm trying

01:41:34,960 --> 01:41:40,360
to think of let's say you want to try to

01:41:38,070 --> 01:41:45,700
if I remembering the example on the fly

01:41:40,360 --> 01:41:47,200
right you're trying to ensure that I'm

01:41:45,700 --> 01:41:49,810
writing a container like vector of tea

01:41:47,200 --> 01:41:54,810
and I want to be copyable not just

01:41:49,810 --> 01:41:56,950
movable if T is copyable not movable

01:41:54,810 --> 01:41:59,110
where do you write that static assert

01:41:56,950 --> 01:42:01,030
today because you can't write it inside

01:41:59,110 --> 01:42:02,230
the instantiate some of them sometimes

01:42:01,030 --> 01:42:04,239
you can write that inside the

01:42:02,230 --> 01:42:05,620
instantiation of vector but you have to

01:42:04,239 --> 01:42:07,210
write it after vector has been

01:42:05,620 --> 01:42:09,790
instantiated and some of these you have

01:42:07,210 --> 01:42:11,650
to write outside the class today was

01:42:09,790 --> 01:42:13,330
static assert where as a matter class

01:42:11,650 --> 01:42:15,220
would give you a nice clean place to put

01:42:13,330 --> 01:42:18,340
it I might have missed remember the

01:42:15,220 --> 01:42:19,630
particular company example but that's

01:42:18,340 --> 01:42:22,300
the one I remembered off the top of my

01:42:19,630 --> 01:42:23,980
head is when you can't write it is the

01:42:22,300 --> 01:42:25,000
static assert you know in that location

01:42:23,980 --> 01:42:28,900
today

01:42:25,000 --> 01:42:31,030
all right thanks hi

01:42:28,900 --> 01:42:33,010
I guess I had mixed feelings of your

01:42:31,030 --> 01:42:34,720
discussion on CRT P I'm glad that you

01:42:33,010 --> 01:42:37,780
mentioned it but I was sorry that you

01:42:34,720 --> 01:42:39,790
mentioned it's so late so in all the

01:42:37,780 --> 01:42:42,100
code comparisons on the left you have 17

01:42:39,790 --> 01:42:44,110
code on the right you have the metaclass

01:42:42,100 --> 01:42:46,900
code and it looks much nicer but

01:42:44,110 --> 01:42:49,210
reflection is a precondition and see our

01:42:46,900 --> 01:42:51,880
DP already exists in the language so if

01:42:49,210 --> 01:42:54,160
we on the left instead took CRT P like

01:42:51,880 --> 01:42:56,590
greatly enhanced by reflection and maybe

01:42:54,160 --> 01:42:57,820
also injection I mean so you kind of

01:42:56,590 --> 01:43:00,160
framed it as oh like we're not gonna

01:42:57,820 --> 01:43:01,750
need CRT P anymore it's not meant for

01:43:00,160 --> 01:43:04,480
that I think the not meant for that ship

01:43:01,750 --> 01:43:07,150
has sailed in C++ a long time ago but

01:43:04,480 --> 01:43:09,790
you know we use CRT P it works so won't

01:43:07,150 --> 01:43:13,150
see RT p + reflection and maybe

01:43:09,790 --> 01:43:15,010
injection cover almost all of the

01:43:13,150 --> 01:43:17,530
examples most of what we want to use

01:43:15,010 --> 01:43:19,270
metaclasses for and you know leave

01:43:17,530 --> 01:43:21,880
metaclass is not able to carry their own

01:43:19,270 --> 01:43:25,320
weight as a new feature excellent

01:43:21,880 --> 01:43:28,450
question to end on the CRT P is a spoon

01:43:25,320 --> 01:43:30,730
we are digging with it it was never

01:43:28,450 --> 01:43:32,830
designed for it it is it is it is a

01:43:30,730 --> 01:43:35,020
glorious hack like it Rick it works

01:43:32,830 --> 01:43:37,090
effectively but it can't do everything I

01:43:35,020 --> 01:43:40,440
was careful to say I think the recording

01:43:37,090 --> 01:43:43,180
will tell me whether on the wire that

01:43:40,440 --> 01:43:44,890
metaclasses let you do a superset let

01:43:43,180 --> 01:43:47,010
you do everything see RTP does I think

01:43:44,890 --> 01:43:50,800
of the examples I've seen so far and

01:43:47,010 --> 01:43:54,130
more for example with CRT P because of

01:43:50,800 --> 01:43:55,320
because of C pluses rules remember CRT P

01:43:54,130 --> 01:43:58,060
is the base class

01:43:55,320 --> 01:44:00,400
you tell it with the derived classes so

01:43:58,060 --> 01:44:02,170
it can it can inspect it and such so

01:44:00,400 --> 01:44:04,630
reflection will let you do more CRT P

01:44:02,170 --> 01:44:05,980
absolutely but it will always be doing

01:44:04,630 --> 01:44:07,090
things in the base class which can be

01:44:05,980 --> 01:44:08,590
hidden by the things in the derived

01:44:07,090 --> 01:44:10,780
class it's not fold it's not putting

01:44:08,590 --> 01:44:13,150
them together it's going to have trouble

01:44:10,780 --> 01:44:14,380
generating non-member functions it's

01:44:13,150 --> 01:44:16,510
going to have trouble generating

01:44:14,380 --> 01:44:18,940
multiple classes like the patio example

01:44:16,510 --> 01:44:20,620
I gave that the the certain people are

01:44:18,940 --> 01:44:23,410
doing where from one script they are

01:44:20,620 --> 01:44:25,000
creating five classes you can do but

01:44:23,410 --> 01:44:27,070
you'll need five CRT peas and you'll

01:44:25,000 --> 01:44:29,890
need to invoke them all every time you

01:44:27,070 --> 01:44:33,040
can't just say audio data type this and

01:44:29,890 --> 01:44:35,350
then generate all the things so I'm not

01:44:33,040 --> 01:44:37,330
trying to diss CRT P it has been very

01:44:35,350 --> 01:44:38,999
useful that's wise Curia that's why is

01:44:37,330 --> 01:44:41,409
curiously recurring

01:44:38,999 --> 01:44:42,579
that's why it's recurring it's curious

01:44:41,409 --> 01:44:44,199
because it's not what templates were

01:44:42,579 --> 01:44:47,079
meant for and it seems like that we're

01:44:44,199 --> 01:44:48,429
trying to say something indirectly and

01:44:47,079 --> 01:44:50,439
we would like a way to say it directly

01:44:48,429 --> 01:44:52,599
so I'm trying to address mostly the

01:44:50,439 --> 01:44:54,329
curious part it's absolutely recurring

01:44:52,599 --> 01:44:58,269
and it will be even more useful with

01:44:54,329 --> 01:44:59,800
with injection and with reflection but

01:44:58,269 --> 01:45:01,059
it's don't be able to do the full

01:44:59,800 --> 01:45:03,069
generality of things because it just

01:45:01,059 --> 01:45:06,069
wasn't designed for that it's a coding

01:45:03,069 --> 01:45:07,569
pattern or idiom not a language feature

01:45:06,069 --> 01:45:10,479
in its own right that we can make do

01:45:07,569 --> 01:45:11,679
what we want and make general so I'll

01:45:10,479 --> 01:45:13,329
hang around for a few more thank you

01:45:11,679 --> 01:45:17,129
very much for coming enjoy your lunch

01:45:13,329 --> 01:45:17,129
and then the lightning session

01:45:20,270 --> 01:45:24,690
bosch films can shoot your event with

01:45:22,620 --> 01:45:26,730
multiple cameras linked to presentation

01:45:24,690 --> 01:45:29,310
slides add titles and edit your event

01:45:26,730 --> 01:45:31,350
live for a full broadcast experience how

01:45:29,310 --> 01:45:33,830
is this even working so this is actually

01:45:31,350 --> 01:45:37,530
a more interesting program to you know

01:45:33,830 --> 01:45:39,750
look at in a lot of ways so let's

01:45:37,530 --> 01:45:42,270
profile it give a little bit of time to

01:45:39,750 --> 01:45:45,120
do a profile for us I'll see exactly

01:45:42,270 --> 01:45:46,500
what it is that's making this faster or

01:45:45,120 --> 01:45:48,000
slower based on the different inputs

01:45:46,500 --> 01:45:49,290
when you could really gain a lot of

01:45:48,000 --> 01:45:52,020
insight by actually looking at the

01:45:49,290 --> 01:45:54,210
profile like this I worked at Sesame

01:45:52,020 --> 01:45:56,130
Street I got brought on to be a writers

01:45:54,210 --> 01:45:58,500
assistant on a show called Sesame Street

01:45:56,130 --> 01:46:01,110
English which was to teach English to

01:45:58,500 --> 01:46:02,520
kids in China and Japan it seems very

01:46:01,110 --> 01:46:05,250
simple the shows that they put together

01:46:02,520 --> 01:46:07,739
but it's it's actually really hard to

01:46:05,250 --> 01:46:11,340
design a show that is not only for young

01:46:07,739 --> 01:46:13,110
kids but also the parents confession

01:46:11,340 --> 01:46:14,520
like this is therapeutic I hope you all

01:46:13,110 --> 01:46:15,810
get something out of this but if you

01:46:14,520 --> 01:46:19,469
don't the therapy will have been good

01:46:15,810 --> 01:46:21,960
for me so thank you seven years ago I

01:46:19,469 --> 01:46:24,270
was working I wasn't working through

01:46:21,960 --> 01:46:26,340
those but my previous employer which was

01:46:24,270 --> 01:46:28,500
large multinational investment bank I

01:46:26,340 --> 01:46:32,219
had what was up to that point the worst

01:46:28,500 --> 01:46:35,070
day of my career and then came the anger

01:46:32,219 --> 01:46:37,500
anger at ourselves because we knew we

01:46:35,070 --> 01:46:40,920
were responsible for America's first

01:46:37,500 --> 01:46:42,570
space disaster we wrote two more words

01:46:40,920 --> 01:46:44,730
into our vocabularies mission

01:46:42,570 --> 01:46:46,320
controllers tough and competent tough

01:46:44,730 --> 01:46:48,090
meeting we will never again shirk from

01:46:46,320 --> 01:46:49,830
our responsibilities because we are

01:46:48,090 --> 01:46:52,050
forever accountable for what we do

01:46:49,830 --> 01:46:54,360
competent will never again take anything

01:46:52,050 --> 01:46:56,100
for granted we will never stop learning

01:46:54,360 --> 01:46:58,710
from now and the teams and Mission

01:46:56,100 --> 01:47:01,679
Control will be perfect because as a

01:46:58,710 --> 01:47:06,270
team they must never fail one other

01:47:01,679 --> 01:47:08,850
thing we're all in a very fortunate

01:47:06,270 --> 01:47:11,850
position we've been very lucky in our

01:47:08,850 --> 01:47:14,330
lives and so forth and I think is part

01:47:11,850 --> 01:47:19,730
of the mission it's also good sometimes

01:47:14,330 --> 01:47:19,730
take that portion and get back

01:47:20,940 --> 01:47:26,710
to make sure you take this pipe one and

01:47:24,820 --> 01:47:30,070
use it towards worthy causes

01:47:26,710 --> 01:47:31,870
that's good karma that's good stuff in

01:47:30,070 --> 01:47:33,490
the universe we understand that your

01:47:31,870 --> 01:47:36,130
event will have needs that are specific

01:47:33,490 --> 01:47:37,570
to your organization please email or

01:47:36,130 --> 01:47:39,580
call us directly to discuss your

01:47:37,570 --> 01:47:41,500
particular event we look forward to

01:47:39,580 --> 01:47:44,340
discussing your goals and helping make

01:47:41,500 --> 01:47:44,340

YouTube URL: https://www.youtube.com/watch?v=4AfRAVcThyA


