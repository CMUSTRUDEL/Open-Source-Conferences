Title: CppCon 2017: Walter E. Brown “Programming with C++ Constraints: Background, Utility, and Gotchas"
Publication date: 2017-10-03
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Compile-time constraints will likely soon become part of our routine C++ programming vocabulary. Why? Such constraints are induced by new core language features (requires-clauses and requires-expressions) that are on the horizon for C++. What are these all about? 

Almost every function imposes requirements on its users; violating those requirements typically leads to incorrect programs. Historically, such requirements had to be expressed in comments or other documentation, as there was little machinery to express them in code. Soon we will be able to express more requirements in code, thus allowing compilers to detect and address more violations. 

This talk aims to prepare both new and veteran C++ programmers with the necessary background, tutorial information, and advice to exploit this powerful new supplement to function declarations. A case study, illustrating an unexpected gotcha, will conclude the presentation.
— 
Walter E. Brown: retired

With broad experience in industry, academia, consulting, and research, Dr. Walter E. Brown has been a C++ programmer for over thirty-five years, joining the C++ standards effort in 2000. Among numerous other contributions, he is responsible for introducing such now-standard C++ library features as cbegin/cend, common_type, gcd, and void_t, as well as headers ＜ random ＞ and cend, common_type, gcd, and void_t, as well as headers  ＜ ratio＞. He has also significantly impacted such core language features as alias templates, contextual conversions, variable templates, and static_assert. He conceived and served as project editor for the International Standard on Special Mathematical Functions in C++, now part of the forthcoming C++17.

When not playing with his grandchildren, Dr. Brown is an Emeritus participant in the C++ standards process, with several more core and library proposals under consideration.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,340 --> 00:00:10,000
Well, good morning, everyone. Thanks very much for coming to this talk.

00:00:10,040 --> 00:00:20,680
As you can see from the title, about "Programming with Constraints".

00:00:31,240 --> 00:00:38,520
I picked this topic for a very simple reason: I believe that thinking about constraints is going to become a routine part of our daily tasks.

00:00:42,850 --> 00:00:48,000
And this is because it looks like we have a new keyword, namely requires,

00:00:48,760 --> 00:00:54,120
coming down the pipeline for C++20. Some of you may be familiar with it from the Concepts or Concepts Lite Technical Specification,

00:00:59,200 --> 00:01:02,970
and I'll tell you all about that. We've made some progress with respect to that.

00:01:04,180 --> 00:01:07,739
And the purpose of a requires keyword will be to introduce

00:01:08,259 --> 00:01:12,599
what are called requires clauses and requires expressions.

00:01:13,210 --> 00:01:15,210
So we'll talk about that.

00:01:15,850 --> 00:01:21,629
But it turns out that although the syntax obviously is going to be new to C++,

00:01:22,450 --> 00:01:26,369
the ideas are not at all new.

00:01:28,030 --> 00:01:35,669
Accordingly, in this talk I want to explore what these ideas mean for us at a technical level, and

00:01:36,429 --> 00:01:43,888
how they have affected our code of the past, and how they will continue to affect our code today and in the future.

00:01:46,359 --> 00:01:51,839
Some of this material is adapted from a paper I wrote for WG21, the Standards Committee,

00:01:52,479 --> 00:01:55,528
earlier this year. You're welcome to go look it up if you like.

00:01:56,350 --> 00:02:02,489
And with that let's start by looking at what I like to call the bigger picture.

00:02:04,149 --> 00:02:09,389
So let's start by looking at six terms of art, if you will. A

00:02:10,060 --> 00:02:14,550
left column and a right column: take a moment if you'd be so kind -- now

00:02:14,550 --> 00:02:20,649
this is not a quiz; don't raise your hand, don't shout out any answers, but take a moment and see if you can

00:02:21,260 --> 00:02:25,090
look at those and see what they have in common.

00:02:26,689 --> 00:02:32,739
The second column is headed with constraints; the first column is headed with preconditions. It's not an accident.

00:02:34,819 --> 00:02:42,578
So from my perspective, what all of these things have in common is the notion of expressing requirements.

00:02:44,599 --> 00:02:50,408
Requirements that some component, often a function, but not necessarily just functions,

00:02:52,939 --> 00:02:55,779
A requirement that is imposed by a component and that

00:02:57,200 --> 00:03:01,839
the component is entitled to expect, or assume if you prefer,

00:03:02,989 --> 00:03:05,649
always holds true.

00:03:07,220 --> 00:03:10,989
Therefore we as programmers can write those components accordingly.

00:03:11,320 --> 00:03:16,300
It's not something we test for, it's something we assume to be true.

00:03:17,680 --> 00:03:19,680
So here's an interesting question:

00:03:20,269 --> 00:03:23,168
how do these terms of art differ?

00:03:23,959 --> 00:03:29,499
Why don't we just have the word requirement? Why do we have all of this vocabulary?

00:03:30,139 --> 00:03:33,459
It turns out there are some differences among them and

00:03:35,030 --> 00:03:42,729
the differences turn out to be the way the component responds

00:03:44,209 --> 00:03:48,878
when the requirement fails to hold, when it is not satisfied.

00:03:50,329 --> 00:03:52,329
Some of these requirements

00:03:52,790 --> 00:03:56,169
affect the correct use of the component.

00:03:57,260 --> 00:04:00,489
But others affect the component's

00:04:01,129 --> 00:04:02,659
existence.

00:04:02,659 --> 00:04:04,779
Of course, if it doesn't exist you can't use it.

00:04:05,720 --> 00:04:07,459
Right?

00:04:07,459 --> 00:04:09,518
So let's talk briefly about

00:04:10,400 --> 00:04:17,650
preconditions first. As most of us, I think, know, a function's precondition is typically a predicate

00:04:18,320 --> 00:04:20,659
that the function assumes

00:04:21,290 --> 00:04:23,160
to be true.

00:04:23,160 --> 00:04:24,450
When?

00:04:24,450 --> 00:04:26,930
At the point that the function is called.

00:04:29,700 --> 00:04:31,590
Okay?

00:04:31,590 --> 00:04:35,360
That typically means it holds at runtime, but nowadays

00:04:35,360 --> 00:04:42,140
we live in a constexpr world, so that can move up to compile time sometimes. But the point is that

00:04:42,500 --> 00:04:46,820
that precondition has to hold when the function is called.

00:04:47,820 --> 00:04:49,680
No sooner, and later

00:04:49,680 --> 00:04:53,479
we don't really care. Okay? And it has to hold each time.

00:04:54,420 --> 00:05:00,229
Doesn't have to hold in between, but at the point the function is called, the precondition has to hold.

00:05:01,380 --> 00:05:08,719
Now for example, I think many programmers believe that, let's say from the standard library, the square root function in

00:05:09,480 --> 00:05:14,059
<cmath>. I think a lot of programmers would believe that there's a precondition that

00:05:14,940 --> 00:05:17,210
the value you supply must

00:05:17,970 --> 00:05:19,970
not be negative.

00:05:20,010 --> 00:05:21,660
That's not true.

00:05:21,660 --> 00:05:26,029
The function has perfectly well-defined behavior if you happen to give it a negative number.

00:05:26,610 --> 00:05:33,110
It gives you an errno, for example. That's well defined behavior. So that is not a precondition.

00:05:33,810 --> 00:05:35,810
All right?

00:05:35,910 --> 00:05:38,779
You know a lot of programmers write their functions,

00:05:38,780 --> 00:05:43,340
and they test for the validity of the precondition. if you do that you don't have a precondition.

00:05:43,560 --> 00:05:46,100
"Pre", as in, before you make the call.

00:05:47,130 --> 00:05:51,499
It's not the function's responsibility. It's the caller's responsibility. Okay?

00:05:54,690 --> 00:05:56,690
The standard, the C++ standard --

00:05:56,760 --> 00:06:02,900
and this is not new, this has been there all along, and there's the citation if you choose to look it up -- if

00:06:03,300 --> 00:06:05,250
you call a function

00:06:05,250 --> 00:06:11,510
when the precondition fails to hold, you get undefined behavior. It might do what you expect,

00:06:13,020 --> 00:06:15,020
but you're not entitled to count on that.

00:06:16,500 --> 00:06:19,460
It is undefined behavior to call a function

00:06:20,100 --> 00:06:22,159
"out of contract", we say.

00:06:22,920 --> 00:06:29,030
So, you're probably aware, that precondition is part of what we call a function's contract with its clients.

00:06:30,120 --> 00:06:34,770
We have some relatively recent new nomenclature. I'm not sure why we needed this,

00:06:35,290 --> 00:06:41,879
but if you have a function that has no preconditions, we say that it has a wide contract. Wide, as in wide open.

00:06:42,970 --> 00:06:48,779
If there are any preconditions -- one, or more -- then we say the function has a narrow contract.

00:06:49,900 --> 00:06:56,370
From my perspective, I can tell the difference between zero and anything bigger than zero, but that's the nomenclature we use these days.

00:06:58,120 --> 00:07:00,100
But this is really

00:07:01,240 --> 00:07:04,320
only tangential to our main topic of the day, which is constraints.

00:07:05,080 --> 00:07:10,020
So I'm not going to talk very much more about preconditions, except to have noted the distinction.

00:07:11,290 --> 00:07:14,399
But here's a little breadcrumb for the future: keep your eye out for

00:07:15,340 --> 00:07:22,829
a new attribute sometime in the future, maybe C++20, maybe C++23, not sure, still in progress.

00:07:23,380 --> 00:07:25,380
It will be labeled [[expects]].

00:07:25,930 --> 00:07:27,930
Okay?

00:07:28,270 --> 00:07:32,009
Now, how do constraints differ from preconditions?

00:07:33,400 --> 00:07:38,340
Well, a constraint is always a compile time predicate.

00:07:39,880 --> 00:07:41,880
Always, always, always.

00:07:42,040 --> 00:07:47,399
It's associated with some program component -- could be a function, could be a template, for example,

00:07:47,980 --> 00:07:49,980
could be any kind of template.

00:07:49,990 --> 00:07:52,919
Could be a variable template, could be a class template, doesn't matter,

00:07:53,740 --> 00:07:59,280
can have a constraint on it. And the constraint MUST be satisfied.

00:08:00,310 --> 00:08:06,389
There's no "what if". It must be satisfied.

00:08:07,270 --> 00:08:09,270
Or else!

00:08:10,120 --> 00:08:14,489
Now, I suspect you're all thinking the same thing that I am: "or else what?"

00:08:16,480 --> 00:08:19,230
Or else the component

00:08:20,410 --> 00:08:21,970
won't and

00:08:21,970 --> 00:08:23,970
mustn't be compiled.

00:08:26,200 --> 00:08:29,640
Effectively it will not exist if the constraint is unsatisfied.

00:08:30,400 --> 00:08:33,780
Will not exist.

00:08:34,450 --> 00:08:42,420
So if it's a function you mustn't call it. It doesn't exist. You can't take its address. It doesn't exist. You can't use it.

00:08:43,600 --> 00:08:50,039
But the fact that it won't be compiled is not necessarily, in and of itself, an error.

00:08:50,800 --> 00:08:55,770
You might get a consequential error: you try to use it, and it doesn't exist; that's an error.

00:08:56,320 --> 00:09:01,409
That's not the fault of the component. That's your code that's trying to use a non-existent component.

00:09:02,500 --> 00:09:09,599
But we all have some experience with this, In this particular regard, it is not unlike

00:09:10,450 --> 00:09:12,450
conditional pre-processing.

00:09:12,580 --> 00:09:14,580
Just because something is not

00:09:14,920 --> 00:09:21,000
compiled does not necessarily, in and of itself, mean that there's anything wrong. This may be a desired outcome.

00:09:21,550 --> 00:09:23,550
It depends on what the predicate is, right?

00:09:24,190 --> 00:09:30,749
But when you're talking about a constraint, and if you take away nothing else, remember this: if the constraint is not satisfied,

00:09:31,540 --> 00:09:35,190
the component will not be compiled.

00:09:36,910 --> 00:09:41,940
Some cases may give you a diagnostic; it depends on how it's how its coded,

00:09:42,580 --> 00:09:49,650
but not necessarily, and that's not necessarily a bad thing. That may be a desired result.

00:09:50,860 --> 00:09:54,719
You may have an overload situation, for example.

00:09:55,270 --> 00:09:58,889
You have multiple constraints, one of them is satisfied, the others aren't.

00:09:59,700 --> 00:10:01,720
You can only call the one that exists.

00:10:03,760 --> 00:10:10,080
Now, I'd like to point out that this is not at all new. I know I said this before, but here are some examples.

00:10:11,320 --> 00:10:14,669
C++ is all about constraints, from day one.

00:10:15,550 --> 00:10:23,099
I mean, you can say this about any language that features strong type checking, and of course C++ is famous for strong type checking.

00:10:23,470 --> 00:10:24,550
Right?

00:10:24,550 --> 00:10:28,109
Well, when you assign a type to a variable,

00:10:29,140 --> 00:10:36,419
when you make that binding, you are imposing a constraint on that variable; a constraint on how you can use it.

00:10:37,030 --> 00:10:38,980
You can't assign a

00:10:38,980 --> 00:10:40,980
string to an int.

00:10:41,320 --> 00:10:45,599
That's a constraint violation; that won't compile, will it? That'll give you a diagnostic.

00:10:46,690 --> 00:10:49,409
So we are all familiar with

00:10:49,990 --> 00:10:55,669
constraints, but perhaps have not thought of it in quite these terms before. I'll give you some more examples shortly.

00:10:58,830 --> 00:11:06,499
The era that we refer to as C++98, C++03, limited us to sort of these implicit techniques.

00:11:08,310 --> 00:11:11,869
But we have had newer technologies now for almost a decade.

00:11:13,770 --> 00:11:15,770
Because C++11, and

00:11:16,170 --> 00:11:23,510
even before that if you count TR1 for example, we have had some new tools for, let's say, explicit

00:11:24,120 --> 00:11:28,400
programming with constraints. For example we got static_assert in C++11.

00:11:29,310 --> 00:11:35,000
You put that inside a component; that component will not compile unless that predicate is true.

00:11:35,040 --> 00:11:37,580
And you'll get a diagnostic of your choice.

00:11:39,270 --> 00:11:45,020
Unless you're programming in C++17 where the literal became optional. I had a little something to do with that.

00:11:47,730 --> 00:11:52,099
We got, in C++11 in the standard library, we got enable_if,

00:11:54,000 --> 00:11:58,309
typically used in a SFINAE context -- we'll talk a little more about that shortly --

00:11:58,860 --> 00:12:03,530
to prevent the template's instantiation. And of course if it's not instantiated, it can't be compiled.

00:12:04,080 --> 00:12:06,530
The constraint fails: it won't be compiled.

00:12:08,520 --> 00:12:10,520
We got expression SFINAE,

00:12:10,980 --> 00:12:17,089
which is not as well known, but it's an expansion of the contexts in which you can apply such techniques.

00:12:18,150 --> 00:12:24,769
Before then we had a limited number of contexts, now we have a lot more, ever since C++11.

00:12:27,000 --> 00:12:30,440
And even more recently, we got more good stuff in this particular area.

00:12:31,240 --> 00:12:35,020
C++17 has void_t in the standard library.

00:12:35,130 --> 00:12:39,859
I had a lot to do with that and will not speak about that further today, but if you're interested,

00:12:40,050 --> 00:12:44,539
please go look at the video of my talk here at CppCon from 2014.

00:12:44,730 --> 00:12:48,560
That's when I first sprung void_t on the world. The last half-hour

00:12:49,080 --> 00:12:52,189
approximately of — it's a two hour talk. And by the way

00:12:52,190 --> 00:12:57,200
thank you to the 40,000 people who've watched that. That's an unbelievable number, considering my name

00:12:57,200 --> 00:13:00,799
isn't Bjarne or Herb you know, but thank you all.

00:13:02,160 --> 00:13:09,040
We also got, in C++17, the constexpr if -- spelled if constexpr,

00:13:10,339 --> 00:13:17,049
but the feature is called constexpr if -- and with it you get discarded statements. The predicate doesn't hold?

00:13:18,320 --> 00:13:20,320
That part doesn't get compiled.

00:13:21,320 --> 00:13:22,550
Okay?

00:13:22,550 --> 00:13:29,169
And we've been working on C++20 already. C++17 by now is old hat for the Standards Committee.

00:13:29,480 --> 00:13:33,430
We've been working on C++20 now for six months or so, and

00:13:34,760 --> 00:13:41,559
we have recently added to the working draft, and that's freely publicly available if you choose to download it,

00:13:42,260 --> 00:13:47,260
if you're not used to reading legalese you probably don't want to read the actual standard.

00:13:47,260 --> 00:13:50,589
It's a 1400 page legal document is what it boils down to.

00:13:51,320 --> 00:13:54,700
We were very careful with the wording, because in some

00:13:54,890 --> 00:13:59,919
jurisdictions it actually has the force of law. It gets incorporated by reference into contracts and things like that.

00:14:00,290 --> 00:14:06,640
So putting out a C++ standard is like negotiating an international treaty in many respects. It's a little surprising.

00:14:07,580 --> 00:14:09,580
But we've added the

00:14:10,130 --> 00:14:15,429
Concepts requires keyword, and of course, I'll talk much more about that later on.

00:14:16,640 --> 00:14:22,270
So let me start by talking a little more about what I'm going to call pre-modern constraints.

00:14:23,120 --> 00:14:25,120
So, suppose -

00:14:26,720 --> 00:14:28,720
Yes, notice it's down near the bottom?

00:14:29,240 --> 00:14:31,240
This is how we used to have to write the code.

00:14:31,730 --> 00:14:38,050
And by the way, this slide gave me more trouble in PowerPoint than any other. PowerPoint really wants to show things from top down!

00:14:40,970 --> 00:14:43,750
So we need a C++ programmer to fix that, but okay!

00:14:45,170 --> 00:14:50,079
So let me use this example. This is gonna be a running example. We'll revisit this two or three times.

00:14:50,089 --> 00:14:54,279
Suppose what I want to do is just: give me a value,

00:14:54,279 --> 00:14:58,059
and I'll raise it to a given power, where the power is known at compile time.

00:14:59,360 --> 00:15:03,880
So, you know, a little simple bit of metaprogramming, but no big deal.

00:15:04,260 --> 00:15:08,260
And the algorithm that I want to use is one that'll give me

00:15:09,320 --> 00:15:10,459
logarithmic

00:15:10,459 --> 00:15:13,419
behavior in terms of number of multiplications. The naive approach,

00:15:13,459 --> 00:15:19,089
I mean what you teach kids to start with when they first learn exponents is, you multiply it so many times.

00:15:19,339 --> 00:15:23,049
You raise to the nth power, you have n-1 multiplications.

00:15:23,750 --> 00:15:26,830
Okay, well we can do better. If you want, say, x to the 8th,

00:15:27,050 --> 00:15:31,149
you square x, you square that, you square that, you're done. Three multiplications.

00:15:31,660 --> 00:15:34,839
That's logarithmic behavior. So suppose I want that algorithm.

00:15:36,230 --> 00:15:40,570
It turns out the easiest way to code that is with some specializations.

00:15:40,570 --> 00:15:44,499
A primary template and a couple of specializations.

00:15:46,130 --> 00:15:52,029
But I want to make this a function, and you can't partially specialize functions in C++.

00:15:52,370 --> 00:15:59,080
So what technique did we have to use? We have to dispatch to something else that you can partially specialize, right?

00:16:03,380 --> 00:16:05,950
So you've got to declare that up above.

00:16:08,510 --> 00:16:11,859
So it's my helper that will implement that log n behavior.

00:16:12,440 --> 00:16:16,059
So I'll have a primary template with two partial specializations.

00:16:16,339 --> 00:16:21,609
There's the primary, and it turns out it will only operate on

00:16:22,339 --> 00:16:24,339
values of n that are odd.

00:16:25,100 --> 00:16:27,100
Now that's not obvious by inspection,

00:16:27,560 --> 00:16:34,000
but it'll turn out that the specializations will handle all the evens. So the only thing left for the primary will be the odds.

00:16:34,340 --> 00:16:37,300
But please notice the stuff in yellow.

00:16:38,600 --> 00:16:42,840
In particular, notice the third template parameter: a bool,

00:16:43,970 --> 00:16:47,140
not named. I never have to refer to it, so it doesn't need a name.

00:16:50,089 --> 00:16:54,759
And the predicate is the answer to the question, "is n an even number?"

00:16:57,890 --> 00:16:59,890
Okay?

00:16:59,959 --> 00:17:01,339
So now the

00:17:01,339 --> 00:17:07,749
specializations. If that's true -- so here's where evens get handled -- if that's true,

00:17:07,750 --> 00:17:12,099
we do the naive square the thing and then reduce n by half.

00:17:14,540 --> 00:17:21,579
Except you need another case to handle the case of zero, which is even, but I don't want any multiplications.

00:17:23,300 --> 00:17:28,269
So that's kind of how you would do this thing, and you know, you can play some tricks and do a little bit better

00:17:28,270 --> 00:17:30,609
job, but this is kind of straightforward to look at.

00:17:31,610 --> 00:17:34,120
This is what we would do in C++98.

00:17:35,960 --> 00:17:39,789
But we can do better, and I'll return to this example twice more.

00:17:40,970 --> 00:17:42,970
But those are constraints.

00:17:43,159 --> 00:17:47,199
When you specialize a template, you're putting a constraint on that

00:17:47,720 --> 00:17:52,329
specialization. [If] the constraint isn't met, that specialization won't be compiled.

00:17:53,509 --> 00:17:55,509
Okay?

00:17:56,090 --> 00:18:01,120
Now in C++11, I mentioned we got enable_if among other things.

00:18:02,540 --> 00:18:08,000
If you're not familiar with it, let me give you a real fast overview. It's a metafunction.

00:18:08,320 --> 00:18:12,420
You hand it a predicate, you hand it a type. [If] the predicate is true,

00:18:13,000 --> 00:18:20,720
you get back an alias to the type. If the predicate is false, there is no alias.

00:18:21,880 --> 00:18:24,740
This is a feature you can only do in metaprogramming.

00:18:24,759 --> 00:18:27,189
You can't write a function that refuses to give you an answer.

00:18:27,190 --> 00:18:31,539
I mean yes, you can throw exceptions, you can call std::terminate, things like that,

00:18:31,540 --> 00:18:35,620
but if you have a normal return, you can't have a function that gives you no answer.

00:18:36,100 --> 00:18:42,800
But in metaprogramming, you can. And what does it look like? Well it's a primary template and one specialization,

00:18:43,180 --> 00:18:51,000
I've chosen to have the primary handle the case where it's true, and you'll notice there's the alias: using type = T,

00:18:51,980 --> 00:18:57,580
and then the specialization: when the predicate is false, a constraint,

00:18:58,520 --> 00:19:01,440
there is no alias.

00:19:02,080 --> 00:19:04,080
Empty braces, right?

00:19:04,490 --> 00:19:07,809
So this is enable_if. This is how it's almost always implemented.

00:19:07,809 --> 00:19:11,018
I mean you can flip the role of the primary and the specialization,

00:19:11,840 --> 00:19:15,129
but there's almost no other way to implement this.

00:19:15,820 --> 00:19:19,960
And you can say ok, that's pretty straightforward, but what good is that? So what?

00:19:20,380 --> 00:19:23,140
Well, first think about one thing.

00:19:24,700 --> 00:19:27,500
Think about a call to that metafunction

00:19:28,369 --> 00:19:33,429
where the predicate is false, but you're asking for the type anyway.

00:19:34,460 --> 00:19:36,460
As if there were an alias.

00:19:38,900 --> 00:19:43,420
And most programmers who have not seen this before would say well, that's got to be an error.

00:19:44,100 --> 00:19:45,480
Well...

00:19:45,840 --> 00:19:48,980
It is sometimes an error...

00:19:49,400 --> 00:19:51,700
and welcome to SFINAE!

00:19:51,900 --> 00:19:54,920
Now what has that got to do with constraint programming?

00:19:55,380 --> 00:19:58,340
Well, we have to talk about SFINAE a little bit first.

00:19:58,800 --> 00:20:02,380
And I know I've spoken about this before and some of you are familiar with SFINAE,

00:20:02,390 --> 00:20:06,200
but there's a new wrinkle in C++17 that you may not yet have encountered.

00:20:06,560 --> 00:20:09,900
So let me go through it at a sort of high-level, okay?

00:20:10,820 --> 00:20:16,720
There are two main steps in instantiating any template declaration.

00:20:16,730 --> 00:20:20,270
I mean yes, there are lots more details I don't propose to go into,

00:20:20,780 --> 00:20:27,980
but there are two principle steps. And the first one has got to be: what are my arguments?

00:20:28,340 --> 00:20:30,340
What are the template arguments?

00:20:32,200 --> 00:20:35,960
So how does the compiler determine

00:20:36,680 --> 00:20:42,340
either -- well, you can see it's up there -- sometimes deduce, sometimes just get your hands on,

00:20:42,810 --> 00:20:45,859
how do you obtain the template argument?

00:20:46,440 --> 00:20:53,330
And it turns out there are now four ways this can happen. There used to be three, we now have four.

00:20:54,060 --> 00:20:57,280
New in C++17. Okay?

00:20:57,800 --> 00:21:02,320
And they can arise in combination if you have multiple template arguments.

00:21:02,970 --> 00:21:08,060
One can come about this way, one can come about a different way. Okay, so what are the four?

00:21:08,820 --> 00:21:10,820
Well, I've labeled them a, b, c, d.

00:21:12,120 --> 00:21:16,370
Obviously if the client supplies the argument, we take it verbatim, we're done.

00:21:18,270 --> 00:21:25,879
Otherwise, if it's a function template the compiler can go and look at the actual arguments in the call, and

00:21:26,580 --> 00:21:32,569
say, "Okay, what are the types of those arguments?" and deduce, and get the template argument that way.

00:21:33,840 --> 00:21:40,580
c), which is new for 17: if you have a class template, we now have a feature called

00:21:41,580 --> 00:21:43,580
deduction guides.

00:21:45,600 --> 00:21:51,020
Previously if you wanted to declare a std::vector you always had to say std::vector of some type.

00:21:51,850 --> 00:21:55,030
std::vector<int>, std::vector<double>, std::vector<my_type>...

00:21:56,210 --> 00:22:03,610
You don't necessarily have to say that anymore. The compiler can figure it out under certain circumstances, if you provide the appropriate

00:22:04,190 --> 00:22:06,020
initializers.

00:22:06,020 --> 00:22:09,039
Now this is off topic, so treat

00:22:09,039 --> 00:22:13,539
this as a breadcrumb: something you might want to look into for the future, but this is new.

00:22:14,419 --> 00:22:20,949
And the final fallback, if none of the above work, maybe there are some defaults in the declaration of the template.

00:22:22,520 --> 00:22:29,619
Okay, so we now have four possibilities for the compiler to consider, and this is all still the first step of

00:22:30,320 --> 00:22:32,320
instantiating a template declaration.

00:22:33,110 --> 00:22:36,880
So what's the second step? Well. now that you know what the arguments

00:22:36,880 --> 00:22:41,049
are, it's time to use them, and this is what's referred to as the substitution step.

00:22:42,140 --> 00:22:47,140
Every placeholder, which are the template parameters, has to be replaced by the corresponding argument.

00:22:48,760 --> 00:22:54,800
All right, so there are two possible outcomes.

00:22:57,900 --> 00:23:02,000
I mean, simply put, it can go well, or it can go ill.

00:23:02,560 --> 00:23:05,380
So if all goes well,

00:23:05,540 --> 00:23:10,179
you end up with a well-formed declaration, and you just proceed normally.

00:23:10,179 --> 00:23:14,949
Maybe the next step is overload resolution, whatever comes next in your compiler.

00:23:15,799 --> 00:23:17,799
Just keep going, no big deal.

00:23:18,860 --> 00:23:20,860
But what if it doesn't work out?

00:23:22,760 --> 00:23:27,939
If the resulting declaration is not well formed, and of course we call that ill-formed,

00:23:28,720 --> 00:23:32,480
it is considered not viable.

00:23:32,620 --> 00:23:36,480
And that's a term of art in the standard. It's not viable.

00:23:37,360 --> 00:23:40,520
Why not? Well in this case, it's because of substitution failure.

00:23:41,870 --> 00:23:47,979
Things didn't work out. And what happens? It's not an error.

00:23:49,920 --> 00:23:53,980
That component, that declaration is

00:23:54,600 --> 00:23:57,060
silently discarded.

00:23:57,260 --> 00:23:59,060
There is no diagnostic.

00:24:00,660 --> 00:24:02,660
In other words,

00:24:03,560 --> 00:24:11,880
Substitution Failure Is Not An Error. SFINAE. The term was coined in the early 2000s by Daveed Vandevoorde, I believe.

00:24:15,250 --> 00:24:19,140
So in a nutshell, that's how SFINAE works, and there's some other speakers this week

00:24:19,140 --> 00:24:21,600
who will talk more about SFINAE, I'm told.

00:24:22,780 --> 00:24:26,320
So, the question is: what is this good for?

00:24:26,880 --> 00:24:30,500
How does this affect programming with constraints?

00:24:32,400 --> 00:24:35,100
Well the most common use of

00:24:35,560 --> 00:24:40,760
SFINAE is via enable_if. So I'm about to show you a

00:24:42,160 --> 00:24:44,160
set of three

00:24:44,230 --> 00:24:46,649
functions constituting an overload set.

00:24:47,620 --> 00:24:50,790
And if you look at the predicates, at the constraints,

00:24:51,640 --> 00:24:58,230
you will find that at most one of them can be true, and the other two will not hold. Will be unsatisfied.

00:24:58,990 --> 00:25:00,700
Which means,

00:25:00,700 --> 00:25:05,080
those two will be silently discarded, and I'm left with exactly one.

00:25:05,680 --> 00:25:07,680
So let's return to my example.

00:25:08,500 --> 00:25:14,040
Three overloads to do those three parts of my algorithm.

00:25:15,040 --> 00:25:18,200
All right, if N is 0,

00:25:20,020 --> 00:25:22,020
return 1.

00:25:22,780 --> 00:25:28,200
But notice enable_if requires here that N be exactly 0.

00:25:31,060 --> 00:25:33,060
Ok, well what if it isn't?

00:25:33,600 --> 00:25:36,520
Well, then there is no return type for this function:

00:25:36,880 --> 00:25:39,060
enable_if has nothing to return.

00:25:39,840 --> 00:25:43,460
And the declaration becomes ill-formed, and is silently discarded.

00:25:45,020 --> 00:25:46,480
Alternatively,

00:25:46,480 --> 00:25:51,689
here's an overload. Notice: the same function. Same function signature. It's an overload; same name.

00:25:52,240 --> 00:25:54,540
But with a different predicate.

00:25:54,900 --> 00:25:58,100
This time, if N is nonzero

00:25:58,440 --> 00:26:01,320
and even, do it this way.

00:26:03,730 --> 00:26:10,200
If that doesn't hold, that's also going to be ill-formed for exactly the same reason, and it won't be compiled .silently

00:26:10,920 --> 00:26:15,400
Not a bad thing, because I'm going to want the case when it's odd.

00:26:16,420 --> 00:26:19,080
So I've written my constraints so that they're mutually exclusive.

00:26:19,870 --> 00:26:24,390
At most one will be well-formed; the other two are silently discarded.

00:26:25,300 --> 00:26:31,529
And this is a typical use for enable_if in the standard library. And of course

00:26:31,530 --> 00:26:38,280
as I said, we've had this since C++11. We've actually had it since TR1, but not everybody used TR1.

00:26:39,610 --> 00:26:45,719
So programming with constraints is really not new. So why aren't we happy with enable_if? I mean, what's wrong with it?

00:26:46,630 --> 00:26:51,930
Well, nothing really, but I mean let's be honest. There are some limitations to this idiom.

00:26:51,930 --> 00:26:56,820
For openers, it requires a template. You can't apply it to non templates.

00:26:58,570 --> 00:27:04,739
If you want to apply it to a function that's a constructor, it's a little more challenging because there's no return type.

00:27:05,680 --> 00:27:07,680
So where do you put the enable_if?

00:27:08,020 --> 00:27:14,099
You can make it an extra argument maybe, but that's visible to the user. You can make it an extra template parameter,

00:27:14,100 --> 00:27:15,910
but that's visible to the user.

00:27:15,910 --> 00:27:21,810
You get the idea. It's a little more challenging. There's some design issues all of a sudden. Okay?

00:27:22,510 --> 00:27:27,359
And let's be honest further: what you get is not exactly transparent.

00:27:28,480 --> 00:27:36,600
If this were the first time that you encountered enable_if, you might say, what the Dickens is this? What's going on here?

00:27:37,560 --> 00:27:41,880
Because you really have to understand the idiom to be able to read code like that.

00:27:42,360 --> 00:27:44,360
Once you do, it's fine.

00:27:44,530 --> 00:27:51,839
But it's like anything else: you have to become familiar with it. People like to use the word weird. That just means unfamiliar.

00:27:52,300 --> 00:27:54,749
All right, that's weird. That's because you don't get it yet.

00:27:55,300 --> 00:28:02,940
Once you understand it, it's no longer weird, right? It's familiar. And it turns out we have newer techniques. Which brings us to

00:28:03,480 --> 00:28:07,420
what I've called Modern & Post-Modern Constraints.

00:28:11,200 --> 00:28:15,300
So, C++17, as I said, gave us constexpr if.

00:28:17,020 --> 00:28:23,380
And along with it we got what are called discarded statements.

00:28:24,480 --> 00:28:30,220
Remember my theme: if the constraint doesn't hold, it's not compiled.

00:28:30,300 --> 00:28:36,740
Here, they explicitly become discarded statements. Be a little bit careful, if you haven't used this before.

00:28:36,920 --> 00:28:41,960
There is a requirement that even discarded statements have to be well-formed.

00:28:42,160 --> 00:28:48,720
That's a little stronger than is actually true, but that's a good guideline to start with. So for example:

00:28:48,720 --> 00:28:51,940
don't put a static_assert in a constexpr if.

00:28:53,480 --> 00:28:57,560
Here's a trivia question for you. Do you know what part of speech is a static_assert?

00:28:58,880 --> 00:29:01,160
It's a declaration.

00:29:01,720 --> 00:29:08,100
It's considered a declaration, if you look at the standard. There's your C++ trivia for the day.

00:29:08,780 --> 00:29:15,280
So, every branch of a constexpr if has to be at least parsable.

00:29:16,040 --> 00:29:23,520
So it differs from #if in this regard: if it's not there, we don't really care.

00:29:25,159 --> 00:29:31,689
So, using a constexpr if, we get what I think is the most readable version of my algorithm so far.

00:29:31,690 --> 00:29:33,690
It's one function,

00:29:33,740 --> 00:29:37,179
as it should be. I don't have to mess with overloading,

00:29:37,820 --> 00:29:41,409
and my constraints are embedded in the constexpr if.

00:29:42,860 --> 00:29:49,149
Right? if constexpr N is zero, return this, and the other becomes a discarded statement.

00:29:50,480 --> 00:29:53,230
It's not there when N is zero.

00:29:53,750 --> 00:29:58,869
And if N is not zero, this branch is a discarded statement. It's not present.

00:30:00,520 --> 00:30:04,240
Else if it's even, do this; else it must be odd, do that.

00:30:06,460 --> 00:30:14,180
So I like this a lot, and I hope you consider it, as I do, a great improvement on our coding style and technique.

00:30:16,540 --> 00:30:20,020
But it still doesn't fit all

00:30:20,140 --> 00:30:22,140
situations. It fits a lot,

00:30:22,760 --> 00:30:25,869
but it's still not a universal solution.

00:30:28,190 --> 00:30:30,190
Which brings us to:

00:30:30,830 --> 00:30:32,830
Concepts.

00:30:33,950 --> 00:30:40,299
Only because we published something called the Concepts Technical Specification, TS.

00:30:41,090 --> 00:30:43,870
This is a feature that started out life being called

00:30:44,030 --> 00:30:49,899
Concepts Lite. Somewhere along the way we dropped the "lite" part of it. So maybe this is now Concepts Heavy, I'm not sure.

00:30:50,930 --> 00:30:54,279
But it's the Concepts Technical Specification,

00:30:54,280 --> 00:30:59,259
and that's what, formally, has introduced the requires keyword,

00:31:00,140 --> 00:31:05,650
and brought us what is called the requires clause. That was the first specification.

00:31:05,960 --> 00:31:09,880
And I'll tell you how that's been progressing in the Standards Committee.

00:31:10,070 --> 00:31:14,859
It wasn't quite ready for C++17. Part of it was; the part

00:31:14,860 --> 00:31:18,430
I want to talk about, I thought was ready for C++17.

00:31:18,430 --> 00:31:25,419
And I proposed that we split it, and take what was ready, and leave the rest for later. I got shouted down.

00:31:26,000 --> 00:31:30,880
There were some people who just took a scorched-earth approach, "all or nothing!" Well, they got nothing.

00:31:31,460 --> 00:31:35,620
I consider that very unfortunate. Nonetheless,

00:31:36,220 --> 00:31:39,820
as it happens, a requires clause can be applied to

00:31:40,550 --> 00:31:48,279
any kind of template. Any kind of template: variable template, alias template, class template, of course, function template.

00:31:48,980 --> 00:31:55,300
Okay, any kind of template, but also to an ordinary garden-variety function.

00:31:58,400 --> 00:32:05,920
The status with lambdas is a little unclear at this point, but I'm hopeful that we'll get it in that context as well.

00:32:09,620 --> 00:32:15,280
If you apply it in the case of an ordinary function, we have special nomenclature: we call it a trailing

00:32:15,340 --> 00:32:23,200
requires clause, because it follows the typical declaration of the function. Like a trailing return type, it actually follows that.

00:32:25,840 --> 00:32:29,600
So here are a couple of technical details about requires.

00:32:29,740 --> 00:32:34,420
A requires clause induces constraints.

00:32:34,600 --> 00:32:38,060
Now in a technical sense, I've been slightly

00:32:38,380 --> 00:32:40,620
abusing the term constraints.

00:32:42,320 --> 00:32:50,169
We now are going to get a technical definition of constraint. Now let me start by drawing an analogy for you, okay?

00:32:50,929 --> 00:32:52,580
A lot of C++

00:32:52,580 --> 00:32:59,540
programmers informally speak of -- they say they have a lambda, and at some point they call the lambda.

00:33:01,220 --> 00:33:05,480
Well that's technically wrong. You can't call a lambda.

00:33:06,080 --> 00:33:13,680
When you evaluate, when the lambda's evaluated, you get a kind of function object.

00:33:14,260 --> 00:33:17,120
That's what you get when you evaluate a lambda.

00:33:17,700 --> 00:33:19,700
And that function object

00:33:19,700 --> 00:33:27,220
has a parens operator. That's what gets called. That function object is known as a...

00:33:31,220 --> 00:33:36,080
No no no, there's a special term for this... closure!

00:33:36,800 --> 00:33:40,100
When you evaluate a lambda you get a closure.

00:33:40,840 --> 00:33:47,420
It's not a function. A closure is a special kind of function object. Why do you need that? Because you have to do the captures.

00:33:48,160 --> 00:33:55,320
You need a place to put the stuff you've captured: that goes into the function object, into the closure. Okay? So it becomes closed.

00:33:55,760 --> 00:33:58,160
That's why it's called the closure.

00:33:58,480 --> 00:34:07,020
So [how does this analogy apply] here? Well technically, when you write a requires clause, you're not writing constraints.

00:34:07,600 --> 00:34:13,320
You write a predicate, and the compiler will turn that into

00:34:13,760 --> 00:34:19,840
the appropriate constraints. So we say the constraints are induced by the requires clause.

00:34:20,920 --> 00:34:25,620
It's a slight shift in nomenclature. I'm gonna stick with the informal,

00:34:25,620 --> 00:34:32,100
I'm gonna call it a constraint, but please be aware: technically, the constraint is what the compiler turns this into.

00:34:33,720 --> 00:34:36,840
And of course if the constraint is not satisfied,

00:34:37,080 --> 00:34:44,900
this component to which you've attached the requires clause will not be instantiated or compiled in any way. Just, it won't exist.

00:34:46,919 --> 00:34:48,919
Okay?

00:34:49,320 --> 00:34:52,680
That component simply is ignored.

00:34:53,100 --> 00:34:55,100
Much like SFINAE.

00:34:55,560 --> 00:35:00,019
The machinery is slightly different, but the outcome is very similar.

00:35:00,020 --> 00:35:08,900
It won't exist. That's the theme of this talk: if the constraint isn't satisfied, the component won't exist.

00:35:09,120 --> 00:35:11,700
And that can be a good thing, as we've already seen.

00:35:11,880 --> 00:35:16,100
You just have to be careful in your code. Don't use a

00:35:16,460 --> 00:35:18,380
non-existent component.

00:35:18,390 --> 00:35:20,390
That's an error.

00:35:20,460 --> 00:35:25,159
Well, that makes sense; it's always been an error. Call a function f, you don't have a function f? That's an error.

00:35:25,920 --> 00:35:27,920
Same idea.

00:35:28,820 --> 00:35:36,620
What comes along with this is a new consideration, known as subsumption.

00:35:37,340 --> 00:35:41,260
Because constraints can be related to each other.

00:35:43,860 --> 00:35:45,860
One constraint can

00:35:46,020 --> 00:35:47,640
subsume

00:35:47,640 --> 00:35:50,329
another. It's like a subset relationship.

00:35:51,260 --> 00:35:56,860
And this is a way of comparing constraints, because one constraint can be more

00:35:57,160 --> 00:35:59,360
constraining than another.

00:35:59,960 --> 00:36:07,100
Think about my example. I have a constraint "N is even". I have another constraint "N is zero".

00:36:07,560 --> 00:36:09,860
Well, in that case N is also even.

00:36:10,620 --> 00:36:13,780
But this is more constrained.

00:36:14,820 --> 00:36:21,800
And this can be important. The compiler can now tell, comparing two constraints,

00:36:21,800 --> 00:36:24,050
which is the more constrained.

00:36:24,570 --> 00:36:25,880
This is one of the reasons

00:36:25,880 --> 00:36:32,580
why, technically, you don't write the constraints; the compiler does. It puts it into a form so it can do this kind of analysis.

00:36:34,440 --> 00:36:35,800
Okay.

00:36:37,400 --> 00:36:44,200
Notice, please: nothing I have said relies on concepts per se.

00:36:45,620 --> 00:36:49,320
Yet, this is all machinery that's necessary

00:36:49,840 --> 00:36:52,020
for concepts.

00:36:52,020 --> 00:36:56,720
It doesn't require that we use concepts at all. I have been programming almost

00:36:56,960 --> 00:37:03,320
exclusively with requires clauses for over three, maybe four years now. They're wonderful. I love them.

00:37:04,640 --> 00:37:09,900
I have not written a concept in three and a half years, that I can recall.

00:37:10,920 --> 00:37:13,260
This is the kind of programming that I do.

00:37:13,880 --> 00:37:15,880
It doesn't require concepts.

00:37:16,200 --> 00:37:23,500
Now, concepts are better in a certain sense, and that gets into philosophical issues of what makes a good concept.

00:37:23,880 --> 00:37:26,540
And as far as I know, nobody has yet

00:37:26,850 --> 00:37:32,089
really addressed that to any detail. We have some ideas of what makes a good concept.

00:37:32,340 --> 00:37:40,249
Nobody has ever set forth a set of guidelines yet. "A good concept should satisfy criteria A, B, C". I'm waiting for that.

00:37:41,160 --> 00:37:43,600
But I'm probably not going to be the one to do that.

00:37:44,420 --> 00:37:47,300
But programming with constraints,

00:37:48,260 --> 00:37:50,260
it's wonderful.

00:37:51,000 --> 00:37:55,260
Here's an example. Suppose I have three different transmit functions.

00:37:56,820 --> 00:38:00,980
And of course transmission relies heavily on endianness.

00:38:01,700 --> 00:38:05,300
I mean, there are other ways of coding this, but imagine for a second.

00:38:06,330 --> 00:38:10,489
But I think you'll agree, this is an unusual overload set.

00:38:12,540 --> 00:38:14,540
How come?

00:38:15,440 --> 00:38:17,740
Because they all have the same signature!

00:38:19,020 --> 00:38:21,020
You're not supposed to do this!

00:38:21,500 --> 00:38:25,000
Well, now you can, with the requires clause.

00:38:26,220 --> 00:38:33,140
How can that work? The answer is almost too simple: the requires clause becomes part of the signature.

00:38:34,460 --> 00:38:37,400
So now you can tell them apart again. Right?

00:38:40,120 --> 00:38:47,200
And what happens when you have one that has no requires clause, and another one...? We've got answers for all of those interesting questions.

00:38:49,000 --> 00:38:54,500
So as you can imagine by now, only declarations whose constraint is satisfied --

00:38:54,760 --> 00:38:56,760
constraint in the informal sense --

00:38:56,870 --> 00:39:04,599
go into the overload set of viable candidates, and then overload resolution takes over, and so on and so forth.

00:39:05,140 --> 00:39:07,880
And if the constraint isn't satisfied,

00:39:09,080 --> 00:39:14,740
it doesn't exist, so it's not an issue. Now,

00:39:15,800 --> 00:39:17,260
since most of us,

00:39:17,260 --> 00:39:21,730
I think, are new to requires clauses, let me tell you a little bit about what they look like.

00:39:21,980 --> 00:39:26,040
You can put any predicate you want after the keyword requires.

00:39:26,680 --> 00:39:33,440
Any predicate you want. And in my case, a particularly useful kind of predicate is a type trait.

00:39:35,760 --> 00:39:41,940
I want this function only to be operative, or this template to be operative, only if you hand me an integer type, or

00:39:42,200 --> 00:39:48,879
a floating-point type, or a this, or a that. Or it has to be copyable, or it has to be movable, etc.

00:39:49,640 --> 00:39:53,589
Okay? And those are type traits, so I personally find those useful.

00:39:53,590 --> 00:39:58,090
But I've used constraints of many different kinds. The point is, any predicate works.

00:39:59,420 --> 00:40:02,340
Now if you happen to

00:40:02,740 --> 00:40:07,680
lump a bunch of requirements together and give that collection a name,

00:40:07,940 --> 00:40:09,940
you have a concept.

00:40:11,300 --> 00:40:18,550
So if you've done that, then you can refer to that collection by name. You don't have to repeat all the pieces of that collection.

00:40:19,730 --> 00:40:21,819
That's a form of factoring, right?

00:40:22,370 --> 00:40:25,120
So if you have a concept and it happens to be named C,

00:40:25,120 --> 00:40:30,099
just to keep it short for a moment, then you can say requires C<T>.

00:40:30,230 --> 00:40:36,429
And it looks like a template instantiation, and in some sense it is. It isn't quite, but it's similar.

00:40:36,650 --> 00:40:38,650
You can just say "requires C of T".

00:40:40,300 --> 00:40:43,560
Or, there are some shorter forms

00:40:43,760 --> 00:40:45,760
that are possible.

00:40:46,070 --> 00:40:53,350
Alexander Stepanov, for 20 years now has been lobbying for us to be able to write template<C T>,

00:40:54,100 --> 00:41:00,569
which is absolutely equivalent to the longer form class T ... requires C<T>.

00:41:01,480 --> 00:41:08,980
That's what I mean by a shorter form. There might be others as well; that's a little bit up in the air right now.

00:41:09,480 --> 00:41:12,140
But this is a syntax that we've been using for some time,

00:41:12,220 --> 00:41:19,400
and this is one of particular interest to Alexander Stepanov. If you go online and watch his videos on YouTube, which I highly

00:41:19,620 --> 00:41:23,560
recommend, first of all, set aside a week or two of your time.

00:41:24,240 --> 00:41:30,680
Because not only are there a lot of them, they are deep. And you will want to think hard about what you're hearing.

00:41:31,360 --> 00:41:35,249
I mean the man was a first class -- he's now retired, that's why I say was --

00:41:36,100 --> 00:41:40,949
first class mathematician. One of the few people I know who've read Euclid in the original Greek.

00:41:42,420 --> 00:41:44,900
One of the few people I know who've read Euclid!

00:41:46,500 --> 00:41:51,020
So what I'd like to do now, is to walk you through a case study that

00:41:51,100 --> 00:41:55,199
happened to me late last year, and I wrote it up early this year.

00:41:57,190 --> 00:42:02,550
Like so many things, I stepped in this.

00:42:05,260 --> 00:42:08,310
Since I've since I've been retired, I get to play.

00:42:08,980 --> 00:42:10,980
I get to work on what I want to work on.

00:42:11,440 --> 00:42:14,160
And I've always been interested in the standard library.

00:42:14,280 --> 00:42:18,300
And I never had the chance to do much with a standard library of my own.

00:42:18,300 --> 00:42:23,939
So I now have a private implementation of what I call the interesting part of the standard library.

00:42:23,940 --> 00:42:27,120
And I'm not going to do it all, ever. I'm not interested in all of it.

00:42:27,720 --> 00:42:35,060
But I'm interested mostly in utility components. Because I've been a library writer for most of my professional career.

00:42:35,500 --> 00:42:38,460
So I write things for other programmers to use.

00:42:39,040 --> 00:42:41,580
And there's a certain knack to that.

00:42:42,940 --> 00:42:48,720
So in particular, I mean how much more basic can you get, than std::swap?

00:42:50,100 --> 00:42:51,300
Right?

00:42:51,660 --> 00:42:55,500
We should be using std::swap a lot more than we do.

00:42:56,410 --> 00:42:59,910
A lot of times, you should not use assignment; you should use std::swap.

00:43:01,870 --> 00:43:05,519
If you do things with concurrent programming: do the work, and

00:43:06,040 --> 00:43:07,500
when you're ready,

00:43:07,500 --> 00:43:11,550
get the lock, swap your result into place, and release the lock.

00:43:12,700 --> 00:43:18,689
So std::swap is an incredibly important component. It has given WG21, the Standards Committee,

00:43:19,270 --> 00:43:23,340
headaches ever since we brought it in to the standard.

00:43:24,910 --> 00:43:29,970
Because there are types that want to customize how they swap.

00:43:31,630 --> 00:43:34,920
Imagine how you swap a vector.

00:43:35,680 --> 00:43:38,879
You don't change everything from one vector to the other!

00:43:39,400 --> 00:43:44,070
You take the pointer from here, and the pointer from there, and you swap the pointers. You've done! It's very fast.

00:43:45,240 --> 00:43:48,120
So we want to be able to customize swap.

00:43:48,540 --> 00:43:53,440
So it's what we call a customization point. But that's another talk.

00:43:54,880 --> 00:43:57,600
But what I did is: I've implemented

00:43:57,900 --> 00:44:01,340
swap for our purposes twice. I've done it many more times,

00:44:01,900 --> 00:44:05,640
but imagine that I did it twice. Once, I use let's say the now-classical

00:44:05,940 --> 00:44:11,720
enable_if technology, and the second time I used only this requires technology.

00:44:12,820 --> 00:44:20,340
Okay? And it turned out the bodies of the function, which are not very interesting, it's a traditional three step swap, right?

00:44:21,780 --> 00:44:24,100
You know how I used to teach swap to freshmen?

00:44:24,670 --> 00:44:27,510
You got a little kid who likes to drink chocolate milk.

00:44:27,510 --> 00:44:31,469
You got another little kid who likes to drink white milk. They all have their own

00:44:31,470 --> 00:44:36,300
cups. You accidentally put them in the wrong cups. How do you swap the milk? You get a third cup.

00:44:36,880 --> 00:44:38,880
Right?

00:44:39,849 --> 00:44:45,509
Three step swap. Every freshman understands that. I don't know, maybe freshmen like chocolate milk. I'm not sure.

00:44:46,990 --> 00:44:48,990
But

00:44:49,630 --> 00:44:53,099
std::swap is absolutely fundamental, so I did this a couple of times.

00:44:53,710 --> 00:44:55,349
The function bodies were the same,

00:44:55,349 --> 00:45:02,060
but the function introductions obviously were different, because one had the enable_if, the other one had requires. And there was no overlap.

00:45:03,910 --> 00:45:10,589
And then of course I wanted to be sure that I did it right, that it passes tests. And instead of writing my own tests,

00:45:11,140 --> 00:45:14,250
I used publicly- and also privately-available test suites.

00:45:14,770 --> 00:45:18,239
For example, clang has a test suite, GCC has a public test suite,

00:45:18,240 --> 00:45:24,929
and I run my stuff through those test suites, and I sometimes write my own. And I have access to some private test suites as well.

00:45:25,600 --> 00:45:29,040
And I was completely surprised.

00:45:30,600 --> 00:45:38,120
Because I ended up with a subtle, totally unexpected difference in the behavior.

00:45:39,120 --> 00:45:42,980
Shockingly surprised. Let me walk you through it, if I may.

00:45:46,840 --> 00:45:54,060
So let me just refresh our memories: this is what the standard says about swap. This is what the declaration has to look like.

00:45:55,509 --> 00:46:01,649
I've elided the stuff in the noexcept clause; that's not really relevant to this discussion. It's messy.

00:46:03,999 --> 00:46:05,999
And then --

00:46:06,009 --> 00:46:10,619
and I'm quoting directly: look at the highlighted yellow words, please.

00:46:13,539 --> 00:46:20,849
We call things like that "words of power". They have a special significance in the standard.

00:46:23,349 --> 00:46:30,838
It's a formula. You'll find that over, and over, and over again if you read the standard. And it specifies a special kind of constraint.

00:46:31,920 --> 00:46:35,900
It tells the implementer something he has to do.

00:46:38,200 --> 00:46:45,180
These words mean we need SFINAE — well, it used to mean "SFINAE"; now I say "SFINAE-like" — behavior.

00:46:46,210 --> 00:46:48,210
Namely:

00:46:48,730 --> 00:46:50,730
This swap

00:46:50,859 --> 00:46:55,498
must not be instantiated if the type is

00:46:56,140 --> 00:46:58,140
not movable.

00:47:00,520 --> 00:47:03,340
Now please recall: moveable

00:47:04,260 --> 00:47:06,260
implies copyable.

00:47:06,820 --> 00:47:14,960
You don't have to have move functionality. If you have copy functionality, it's considered movable. It's also considered movable if you have move operations.

00:47:15,180 --> 00:47:19,220
If they're available, we'll use them; if they're not available, we'll fall back to copy.

00:47:19,360 --> 00:47:21,880
So that's all subsumed by calling it movable.

00:47:24,640 --> 00:47:29,140
But we must not instantiate this if we don't have movability.

00:47:30,480 --> 00:47:37,360
If you try to call it and your type doesn't have movability, you can't do a swap using std::swap. That makes sense.

00:47:39,800 --> 00:47:46,360
So here's what I did. And I'm only going to show you the declarations, because the bodies are not really very interesting for our purposes.

00:47:46,820 --> 00:47:49,160
So here's what the enable_if looks like.

00:47:49,520 --> 00:47:54,000
enable_if, and the predicate is is_movable,

00:47:55,620 --> 00:48:03,060
and if it is movable, the return type is void, and if it's not movable there's no return type. It's ill-formed, etc. Won't be compiled.

00:48:04,160 --> 00:48:10,040
So that's what I call the classical way of satisfying the constraint, right?

00:48:10,980 --> 00:48:15,889
And just to spell it out in detail: the enable_if is the return type; there are two possibilities.

00:48:15,890 --> 00:48:21,230
If it holds is basically what I told of. You get void; it's well-formed, everything's fine.

00:48:21,230 --> 00:48:25,939
The predicate doesn't hold, there's no return type. Ill-formed; SFINAE; gone.

00:48:26,880 --> 00:48:29,090
Everybody with me? Okay, good.

00:48:30,210 --> 00:48:32,210
Then I did it again.

00:48:32,420 --> 00:48:35,840
And the second one -- I mean, this should be pretty straightforward.

00:48:36,360 --> 00:48:38,360
There's a requires clause.

00:48:39,840 --> 00:48:46,729
This is a template: notice where it goes. It's a requirement on the template parameters, so it goes after the template,

00:48:47,460 --> 00:48:49,760
and before the function declaration.

00:48:51,060 --> 00:48:54,919
requires is_movable. And there's an ordinary return type now, right?

00:48:56,760 --> 00:49:03,499
It's the requires clause that induces the constraint. I'm meeting the same constraint: is_movable.

00:49:04,440 --> 00:49:06,440
And again, there are two possibilities.

00:49:06,690 --> 00:49:08,690
If the constraint is satisfied,

00:49:09,240 --> 00:49:16,280
the declaration is well-formed; it becomes viable; all is fine. If the constraint is not satisfied,

00:49:16,980 --> 00:49:19,760
the declaration is non viable and it's discarded

00:49:20,240 --> 00:49:22,420
in a SFINAE-like way.

00:49:23,180 --> 00:49:26,600
It's not exactly SFINAE, but you get the same net effect.

00:49:26,880 --> 00:49:27,920
Cool.

00:49:28,820 --> 00:49:33,460
And then came validation. As I said, I ran through some test suites.

00:49:35,400 --> 00:49:37,400
swap worked like a champ.

00:49:40,420 --> 00:49:46,380
But the test suite also had a test for a trait in the standard library named

00:49:46,680 --> 00:49:48,440
is_swappable.

00:49:48,920 --> 00:49:52,400
I hand you a type, and you tell me yes or no:

00:49:52,880 --> 00:49:55,560
you can call swap on your type?

00:49:56,780 --> 00:50:04,440
Not necessarily std::swap. There is a swap that will work with your type. That's what is_swappable is for.

00:50:05,500 --> 00:50:08,520
enable_if worked like a champ,

00:50:09,260 --> 00:50:11,480
requires clause failed!

00:50:12,140 --> 00:50:15,780
How did it fail? Now, here are the details.

00:50:16,160 --> 00:50:20,200
Condensed. I had to change some of the names to shorten them so that they fit.

00:50:20,780 --> 00:50:25,100
So the test has its own namespace, ns in this case.

00:50:25,400 --> 00:50:32,880
It introduces just a trivial type named A, and then in the same namespace,

00:50:33,890 --> 00:50:35,450
a swap.

00:50:35,450 --> 00:50:39,460
Now, right now, there's no overload here, because they're in different namespaces.

00:50:40,120 --> 00:50:43,380
So what happens when you put them into the same namespace?

00:50:43,600 --> 00:50:49,620
And you can do that with a using declaration, you can do that with... there's several ways to do that.

00:50:49,940 --> 00:50:56,290
So consider these three statements in a row. Let's declare a pair of variables of this new type, a and b.

00:50:57,500 --> 00:51:00,760
Let's bring the standard swap into scope,

00:51:01,520 --> 00:51:04,860
with a using, and now let's call swap,

00:51:05,060 --> 00:51:06,760
unqualified.

00:51:08,200 --> 00:51:13,720
This reads like a final exam for second term freshmen or something, right?

00:51:14,390 --> 00:51:16,390
So what's gonna happen?

00:51:16,910 --> 00:51:20,770
Now, this is not a quiz. I'm not here to tease you or anything like that. It goes like this:

00:51:21,530 --> 00:51:23,420
you get two lookups.

00:51:23,420 --> 00:51:29,740
You get ordinary or unqualified lookup, and of course it's gonna find std::swap, because that's in scope directly,

00:51:29,740 --> 00:51:31,740
It's the only swap that's in scope.

00:51:33,590 --> 00:51:35,590
And then ADL kicks in,

00:51:36,110 --> 00:51:43,809
and it's going to find the swap in the associated namespace, because the variables come from namespace ns, and there's a swap in there.

00:51:43,809 --> 00:51:47,740
So we go look in there, and we find it. Now I have an overload set.

00:51:48,760 --> 00:51:55,180
So now we have to do overload resolution, and part of overload resolution -- which finds both to be viable --

00:51:56,140 --> 00:51:58,280
so which one's better?

00:51:59,800 --> 00:52:03,940
And the part of overload resolution that answers this question is called partial ordering.

00:52:03,980 --> 00:52:07,320
You want to put an order to these. Which one is better?

00:52:08,700 --> 00:52:11,040
And the answer is: neither.

00:52:13,000 --> 00:52:15,000
It's ambiguous.

00:52:15,920 --> 00:52:19,089
Can't make the call, it's ambiguous.

00:52:20,119 --> 00:52:23,949
The actual line that tested this was a static_assert,

00:52:24,859 --> 00:52:27,068
and notice the negation in the predicate.

00:52:28,060 --> 00:52:30,700
The test passes if

00:52:30,920 --> 00:52:35,000
the type A is not swappable.

00:52:37,130 --> 00:52:39,130
Right? Because of ambiguity.

00:52:41,440 --> 00:52:44,200
The test passes if it's not swappable.

00:52:44,620 --> 00:52:49,900
And it turns out that works fine for the enable_if, and it fails for the requires. So what's different?

00:52:51,040 --> 00:52:54,540
Requires clauses bring new rules! Or, a new rule.

00:52:55,840 --> 00:52:58,780
It's a new tie breaker.

00:52:59,380 --> 00:53:03,320
It's along the lines of what we have today. More specialized,

00:53:03,940 --> 00:53:05,940
more constrained.

00:53:07,960 --> 00:53:13,380
You have two candidates. They're both viable.

00:53:14,560 --> 00:53:20,260
Look at the constraints: which one is more constrained? That's the winner.

00:53:21,580 --> 00:53:23,580
Subsumption, remember?

00:53:23,960 --> 00:53:26,710
If one subsumes the other, it's more

00:53:27,349 --> 00:53:29,349
constrained: that's your winner.

00:53:30,140 --> 00:53:31,340
Okay?

00:53:31,960 --> 00:53:39,600
So, in my second implementation, std::swap was constrained with a requires clause, therefore this rule kicks in.

00:53:40,400 --> 00:53:47,120
Even though the private one in the namespace was not constrained, the rule still kicks in.

00:53:48,340 --> 00:53:53,980
If you think about it, an unconstrained template is like saying "requires true". It's always satisfied.

00:53:54,940 --> 00:54:01,220
So the new rule applies. The test code is no longer ambiguous!

00:54:02,940 --> 00:54:08,280
But the test expects ambiguity, and therefore the test now fails.

00:54:10,000 --> 00:54:12,000
I stepped in it!

00:54:12,220 --> 00:54:14,220
This was not expected.

00:54:15,060 --> 00:54:22,020
Now, quick caveat: what I'm presenting of course is not yet in the standard. Look at the next

00:54:22,020 --> 00:54:24,020
standard that we're still working on, right?

00:54:24,240 --> 00:54:29,360
But this works today, has worked for many years with gcc -fconcepts.

00:54:31,180 --> 00:54:32,380
Recent developments:

00:54:32,500 --> 00:54:38,780
we've taken much of the wording -- not all, but we've taken a lot of the wording -- out of the TS. Out of the Concepts TS.

00:54:38,880 --> 00:54:42,380
It's in the working draft. It's already been tweaked quite a bit,

00:54:42,390 --> 00:54:47,789
it's probably going to be tweaked some more, because discussions are ongoing. We've got a few years before C++20.

00:54:48,339 --> 00:54:50,339
So what I'm telling you today

00:54:50,589 --> 00:54:52,589
might still be true, or

00:54:52,960 --> 00:54:58,540
it might be slightly -- or not so slightly -- different. I can't predict the future; I don't have that kind of crystal ball.

00:54:59,860 --> 00:55:03,180
But the principles I think will hold up.

00:55:04,600 --> 00:55:06,600
Namely:

00:55:08,640 --> 00:55:17,480
C++ core language constraints, when we get them, are more than just a language replacement for enable_if.

00:55:20,020 --> 00:55:22,340
Some people would say much more.

00:55:23,500 --> 00:55:27,560
If one is present, the constraint comes into play

00:55:28,240 --> 00:55:32,819
whenever you instantiate a template, whenever you use the name of a template.

00:55:33,069 --> 00:55:38,459
It comes in during overload resolution as we've seen, especially during partial ordering as we've seen.

00:55:39,120 --> 00:55:42,160
Here's an example of what you can't do.

00:55:42,460 --> 00:55:47,820
So here's a trivial function where the constraint is never satisfied, right? "requires false"?

00:55:48,600 --> 00:55:55,300
So that just doesn't exist! So of course you can't call it. You can't take its address.

00:55:56,200 --> 00:56:02,060
You can't even say decltype of that thing. It doesn't exist; it doesn't have a type.

00:56:04,240 --> 00:56:08,060
You must not use a component if it doesn't exist.

00:56:08,620 --> 00:56:12,400
And I'm quite confident that that will always hold true.

00:56:15,080 --> 00:56:18,500
Constraints become an integral part of a declaration.

00:56:19,940 --> 00:56:23,680
Traditional declarations that aren't constrained this way,

00:56:24,160 --> 00:56:27,780
namely with a requires clause, aren't quite the same.

00:56:28,970 --> 00:56:32,560
You get an extra set of rules for overload resolution, for example.

00:56:33,260 --> 00:56:36,040
We have to be aware of those rules.

00:56:36,980 --> 00:56:42,879
And it's become clear to me that many of these details, maybe most of them,

00:56:43,849 --> 00:56:46,659
are not yet very widely well understood,

00:56:47,450 --> 00:56:50,679
and even among experts. I mean, there was a recent posting --

00:56:51,410 --> 00:56:56,920
I'm withholding the name of who did it. An expert; someone I consider an expert in C++.

00:56:58,040 --> 00:57:00,040
His advice is

00:57:00,960 --> 00:57:03,220
ALMOST right.

00:57:03,860 --> 00:57:07,860
You have to do something out of the ordinary

00:57:08,000 --> 00:57:09,660
to see the difference.

00:57:09,980 --> 00:57:14,860
But it is, as we've seen, detectable. As I said, I stepped in it!

00:57:19,300 --> 00:57:25,920
Andrew Sutton, who is actually the editor of the Concepts Technical Specification -- he's here at this conference,

00:57:25,930 --> 00:57:27,930
I think he's speaking later this week --

00:57:28,600 --> 00:57:32,620
he wrote me at one point, and he said this, among other things:

00:57:33,140 --> 00:57:41,800
that if you add constraints to an existing overload set that's unconstrained, it potentially changes the result.

00:57:44,120 --> 00:57:47,180
So you need to think about that very very hard.

00:57:48,400 --> 00:57:55,480
You can't just replace enable_if with requires without thinking about it, because there is a tiny

00:57:55,880 --> 00:57:58,320
detectable semantic difference. It may make no difference; it

00:57:59,140 --> 00:58:01,140
usually will make no difference.

00:58:01,500 --> 00:58:05,320
But it potentially can make a difference.

00:58:06,800 --> 00:58:11,140
Vendors of the standard library are free to do this today.

00:58:11,540 --> 00:58:18,560
There's no rule that says they have to wait for C++20 to make use of this technology. It's in compilers already.

00:58:18,880 --> 00:58:25,280
And boy, can it make life easier for standard library and other library implementers!

00:58:25,949 --> 00:58:32,569
It's a wonderful, wonderful tool, and I recommend it highly. As I say, I've been using it for years, near exclusively.

00:58:33,380 --> 00:58:40,160
But as I said, it's detectable, and it has the potential to affect code in certain edge cases.

00:58:40,640 --> 00:58:43,840
You may have to go on a scavenger hunt to find those cases,

00:58:43,859 --> 00:58:49,668
but they exist, as I've shown. And with that, thank you very much. Do we have a couple minutes?

00:58:49,669 --> 00:58:51,449
We have a minute or two for questions.

00:58:51,449 --> 00:58:54,460
If you have a question please come to a microphone.

00:58:54,900 --> 00:58:56,320
Anybody?

00:58:56,940 --> 00:59:00,800
Ah, looks like we got two. All right, I'll do my best sir.

00:59:01,020 --> 00:59:06,520
[Q] Thanks for the talk, first of all. [WEB] My pleasure. [Q] You mention that

00:59:07,109 --> 00:59:11,928
in order to be able to tell the different overloads with requires clause apart,

00:59:12,060 --> 00:59:19,340
the requires actually becomes part of the signature. Does that also imply that during name mangling,

00:59:19,560 --> 00:59:23,320
the expression in the requires gets mangled into the name of the function?

00:59:25,079 --> 00:59:31,728
[WEB] The standard does not mandate anything about mangling. That does sound to me like a viable implementation technique,

00:59:31,728 --> 00:59:36,120
if potentially awkward, but I'm not the right person to address that.

00:59:37,460 --> 00:59:40,060
If this becomes standard,

00:59:40,220 --> 00:59:44,120
the compiler writer has to make it work. [Q] Okay. Thanks.

00:59:44,340 --> 00:59:47,420
[WEB] We just say how it has to behave; you figure out how to get it done.

00:59:48,180 --> 00:59:52,460
[Q] I had a question about the example you showed in this

00:59:52,780 --> 00:59:55,280
circumstance whereby one would add a

00:59:55,700 --> 00:59:57,239
requirements clause

00:59:57,240 --> 01:00:01,140
to a function that had no template arguments.

01:00:03,700 --> 01:00:10,519
And then you had a clause there which had a variable or something that was called local,

01:00:10,519 --> 01:00:14,329
and it was totally unclear where that would come from.

01:00:14,329 --> 01:00:18,528
[WEB] I should have addressed that at the time, forgive me for interrupting you,

01:00:18,989 --> 01:00:22,879
assume for the moment that there is some kind of global by that name.

01:00:23,519 --> 01:00:27,349
Okay? And that there is an enum...

01:00:28,200 --> 01:00:34,560
I expected -- sorry, I should have mentioned that the working paper actually has

01:00:36,120 --> 01:00:39,140
byte ordering primitives in it now.

01:00:39,140 --> 01:00:43,740
I don't know if they'll stay in the present form, but I try to use the names that we have for the moment.

01:00:44,240 --> 01:00:48,400
[Q] So the functions that would be selected might be

01:00:49,040 --> 01:00:55,940
determined by some global variables of constant values which are determined at compile time?

01:00:56,380 --> 01:00:59,200
[WEB] Correct. [Q] Does that sound like a great idea?

01:00:59,940 --> 01:01:06,220
[WEB] Depends how you use it. I mean, does a saw sound like a great idea? I wouldn't give it to a five-year-old.

01:01:09,940 --> 01:01:16,360
One tip: I'm hopeful that you will all go and share this knowledge with your colleagues.

01:01:18,300 --> 01:01:23,020
I'd like to offer a suggestion, if I may. Think about your audience.

01:01:23,240 --> 01:01:30,020
For people like us who've been in the business a while, I've presented this material in a direction I call bottom-up.

01:01:30,600 --> 01:01:33,500
For people who are novices or apprentices,

01:01:34,020 --> 01:01:36,580
think about presenting this top-down.

01:01:36,780 --> 01:01:42,100
They don't need to know all the ins and outs, they just need to know what the behaviors are, and

01:01:42,480 --> 01:01:47,980
how to use it and when to use it. They don't need to know that this is "constraint programming".

01:01:48,440 --> 01:01:52,920
I've got some hidden slides by the way, so if you go and download what I'm going to upload,

01:01:53,220 --> 01:01:58,069
you'll find a couple extra slides that I did because I was gonna run out of time. One final question. I'm sorry,

01:01:58,069 --> 01:02:02,600
I'm gonna run out. If you want, I'll be happy to talk to you in the hallway. Thank you.

01:02:03,080 --> 01:02:05,080
[Q] Do you anticipate that

01:02:05,640 --> 01:02:11,680
"requires" will completely subsume SFINAE, or there is some set of problems you will still

01:02:12,240 --> 01:02:17,359
use SFINAE for? [WEB] I think there is still a role for SFINAE; I believe it's going to diminish.

01:02:17,360 --> 01:02:21,860
But we have large code bases that aren't going to go away anytime soon, so

01:02:22,380 --> 01:02:27,800
we'll be dealing with SFINAE for a very long time to come. [Q] But moving forward? [WEB] New code,

01:02:28,890 --> 01:02:30,890
starting in C++20,

01:02:31,950 --> 01:02:39,439
I would assume that once the word gets out, that requires clauses will take over from SFINAE.

01:02:40,440 --> 01:02:47,100
It somehow seems more intuitive, I hope you'll agree with me. Anyway, thank you all very much. I appreciate your being here. Thank you.

01:02:47,100 --> 01:02:49,800

YouTube URL: https://www.youtube.com/watch?v=n4ie7tPMXOQ


