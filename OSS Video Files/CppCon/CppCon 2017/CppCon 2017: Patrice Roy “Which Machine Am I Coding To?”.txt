Title: CppCon 2017: Patrice Roy “Which Machine Am I Coding To?”
Publication date: 2017-10-03
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
When writing a C++ program, we tend to think of the strengths and weaknesses of our computer, just as we think of our algorithms, data structures, and probably of language features we want to use (or we want to avoid), and we code accordingly. 

To some, it might be surprising to learn that C++ is actually specified in terms of an abstract machine, with its own characteristics. If this is indeed a surprise for you, then you might be interested in knowing more about this machine. It's been there for a long time, and it influences the way we program as well as the way the language was, and is. 

The aim of this talk is to provide a practical overview of what the C++ abstract machine is, how it affects the way we program and how it affects language design itself. It will probably most interesting to intermediate audiences who would like a closer look to some of the abstract underpinnings of the language. 
— 
Patrice Roy: Université de Sherbrooke / Collège Lionel-Groulx, Professor

Patrice Roy has been playing with C++, either professionally, for pleasure or (most of the time) both for over 20 years. After a few years doing R&D and working on military flight simulators, he moved on to academics and has been teaching computer science since 1998. Since 2005, he’s been involved more specifically in helping graduate students and professionals from the fields of real-time systems and game programming develop the skills they need to face today’s challenges. The rapid evolution of C++ in recent years has made his job even more enjoyable. He’s been a participating member in the ISO C++ Standards Committee since late 2014 and has been involved with the ISO Programming Language Vulnerabilities Committee since late 2015. He has five kids, and his wife ensures their house is home to a continuously changing number of cats, dogs and other animals.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:07,890
hello are you doing so you decided to be

00:00:05,490 --> 00:00:11,820
sloppy with me for the next hour or so I

00:00:07,890 --> 00:00:13,769
hope you'll have fun this is not it's

00:00:11,820 --> 00:00:16,080
going to be weird C++ talk as there's

00:00:13,769 --> 00:00:17,550
almost no shita stress in it and I tried

00:00:16,080 --> 00:00:20,119
that thing in Montreal for ridiculous

00:00:17,550 --> 00:00:23,460
best user group about two months ago

00:00:20,119 --> 00:00:24,990
crowd reaction was surprising people

00:00:23,460 --> 00:00:26,970
actually liked it which came as a

00:00:24,990 --> 00:00:30,810
surprise to me it seemed to be a right

00:00:26,970 --> 00:00:32,550
topic of sorts but you see so well I

00:00:30,810 --> 00:00:34,710
should you not know about me well I have

00:00:32,550 --> 00:00:36,660
a few kids I used to do military flights

00:00:34,710 --> 00:00:40,050
inators I had the significant number of

00:00:36,660 --> 00:00:42,059
animals due to my wife Maurice but I

00:00:40,050 --> 00:00:44,430
also like 15 cats and the number of dogs

00:00:42,059 --> 00:00:46,890
and all that I've been teaching for

00:00:44,430 --> 00:00:49,559
about 20 years now 19 to be honest

00:00:46,890 --> 00:00:51,780
and one of my peculiar clean out there

00:00:49,559 --> 00:00:54,800
is the video game people so I worked

00:00:51,780 --> 00:00:57,780
with the number of games gaming

00:00:54,800 --> 00:00:59,219
companies well-known ones and I work at

00:00:57,780 --> 00:01:02,039
University and college at the same time

00:00:59,219 --> 00:01:04,170
so I teach a lot one of the things I do

00:01:02,039 --> 00:01:07,710
in the Standards Committee where I am

00:01:04,170 --> 00:01:10,590
others a room r2 is I'm involved with SG

00:01:07,710 --> 00:01:12,659
14 which is the low latency study group

00:01:10,590 --> 00:01:14,640
and a few others but this is the one I'm

00:01:12,659 --> 00:01:16,530
seeing more stuff in that I'll be there

00:01:14,640 --> 00:01:20,909
on Wednesday should you all be there too

00:01:16,530 --> 00:01:22,500
you'll be welcome so yeah so you can ask

00:01:20,909 --> 00:01:24,720
questions wherever you want it's

00:01:22,500 --> 00:01:27,030
probably simpler to wait a bit but I'll

00:01:24,720 --> 00:01:31,380
catch you if you if you do something in

00:01:27,030 --> 00:01:35,100
time and of mine although I'm going to

00:01:31,380 --> 00:01:37,920
be reading standards text if to be as

00:01:35,100 --> 00:01:39,720
exciting as Michael cases reading last

00:01:37,920 --> 00:01:40,829
year for the over earlier this year if

00:01:39,720 --> 00:01:43,470
you heard about it you actually did a

00:01:40,829 --> 00:01:45,720
slam with it it's not that's what I'm

00:01:43,470 --> 00:01:47,820
going to do so and I I won't have all

00:01:45,720 --> 00:01:49,880
the answers maybe but I'm at a few so I

00:01:47,820 --> 00:01:54,240
hope it's going to work out for you guys

00:01:49,880 --> 00:01:56,100
so as I said I'm a very terrible barcode

00:01:54,240 --> 00:01:59,430
user this this one has way too much text

00:01:56,100 --> 00:02:01,619
but still so when you're writing a

00:01:59,430 --> 00:02:03,479
program you're you tend to be thinking

00:02:01,619 --> 00:02:06,719
okay I'm going to be using this feature

00:02:03,479 --> 00:02:09,300
this feature going to do and people tend

00:02:06,719 --> 00:02:10,460
to think in terms of okay I'm going to

00:02:09,300 --> 00:02:12,410
be

00:02:10,460 --> 00:02:14,810
my variables they're going to be on the

00:02:12,410 --> 00:02:16,400
stack I'm going to be this and that and

00:02:14,810 --> 00:02:18,800
they work for some kind of machine that

00:02:16,400 --> 00:02:20,630
they had in their hands which is not the

00:02:18,800 --> 00:02:21,920
machine they're really coding to they're

00:02:20,630 --> 00:02:23,600
coding to be abstract machine if you

00:02:21,920 --> 00:02:25,520
look in the standard the sender doesn't

00:02:23,600 --> 00:02:28,870
care about the same things use it if

00:02:25,520 --> 00:02:31,700
there's about very peculiar very

00:02:28,870 --> 00:02:33,980
different instead of considerations that

00:02:31,700 --> 00:02:36,470
people when people work with actual

00:02:33,980 --> 00:02:40,100
hardware do so I purpose of this talk is

00:02:36,470 --> 00:02:41,690
for people who are not aware of that to

00:02:40,100 --> 00:02:42,560
get the core better acquainted with the

00:02:41,690 --> 00:02:44,690
machine they're actually writing

00:02:42,560 --> 00:02:47,270
programs for so the one this you were

00:02:44,690 --> 00:02:49,130
going to run programs arm what is going

00:02:47,270 --> 00:02:51,620
to influence what you do so this is

00:02:49,130 --> 00:02:54,320
essentially what's written in there so

00:02:51,620 --> 00:02:56,540
to provide a practical overview of what

00:02:54,320 --> 00:02:59,510
that check machine is and how it affects

00:02:56,540 --> 00:03:02,060
the way you cold or maybe you should

00:02:59,510 --> 00:03:04,730
count the number of people I get in a

00:03:02,060 --> 00:03:06,530
room with me or tell me this is the way

00:03:04,730 --> 00:03:09,470
things work of doing that no it's not is

00:03:06,530 --> 00:03:11,210
the way your compiler is doing it but it

00:03:09,470 --> 00:03:12,920
stuck with the newt sense and what

00:03:11,210 --> 00:03:15,320
you're writing make it look like that

00:03:12,920 --> 00:03:17,960
way today it might not work the same way

00:03:15,320 --> 00:03:24,470
tomorrow refugees compilers you might be

00:03:17,960 --> 00:03:25,970
in for a few surprises so there's a plan

00:03:24,470 --> 00:03:28,040
there which I will skip but you can read

00:03:25,970 --> 00:03:29,540
it if you have time when the thing gets

00:03:28,040 --> 00:03:33,440
published online but this pretty much

00:03:29,540 --> 00:03:34,910
plays we're going to do so there so what

00:03:33,440 --> 00:03:36,560
is an abstract machine it's not the same

00:03:34,910 --> 00:03:39,530
thing as a virtual machine at least in

00:03:36,560 --> 00:03:40,940
most people's view I tried to look

00:03:39,530 --> 00:03:43,520
around on the internet to see what

00:03:40,940 --> 00:03:45,080
people were saying about that there seem

00:03:43,520 --> 00:03:47,570
to have been a few discussions two years

00:03:45,080 --> 00:03:49,430
back so there's this guy there azúcar

00:03:47,570 --> 00:03:50,810
who's a nice guy it was here in silicon

00:03:49,430 --> 00:03:53,030
he has a thought later on today if I

00:03:50,810 --> 00:03:55,670
remember properly who says something

00:03:53,030 --> 00:03:57,830
like is a simplest imaginary computer

00:03:55,670 --> 00:04:00,350
that can actually run a program that you

00:03:57,830 --> 00:04:02,030
wrote in the source language or in the

00:04:00,350 --> 00:04:03,440
set of languages when it was referring

00:04:02,030 --> 00:04:06,170
to the JVM where there's a number of

00:04:03,440 --> 00:04:08,840
he's running so that's that's one point

00:04:06,170 --> 00:04:10,220
it's a simplification of the actual

00:04:08,840 --> 00:04:12,290
hardware that you can actually write

00:04:10,220 --> 00:04:16,460
programs for in your mind at the very

00:04:12,290 --> 00:04:18,980
least there's this person I don't know

00:04:16,460 --> 00:04:20,989
um I don't know who said well at all

00:04:18,980 --> 00:04:23,720
which

00:04:20,989 --> 00:04:26,210
nice execution and we design premium

00:04:23,720 --> 00:04:28,970
languages for a range of targets and

00:04:26,210 --> 00:04:31,699
this kind of abstracts the details of

00:04:28,970 --> 00:04:34,340
the actual hardware minor okay so you're

00:04:31,699 --> 00:04:36,069
I think for a specific architecture

00:04:34,340 --> 00:04:39,970
you're writing for something different

00:04:36,069 --> 00:04:47,479
enlarges your vision or innocence

00:04:39,970 --> 00:04:49,910
there's this other person we said it's a

00:04:47,479 --> 00:04:52,970
theoretical model of a computer that you

00:04:49,910 --> 00:04:55,099
can use in theory I guess okay

00:04:52,970 --> 00:04:58,190
very general terms when people probably

00:04:55,099 --> 00:05:00,110
use that you said not to be confused

00:04:58,190 --> 00:05:01,940
with virtual machine because these are

00:05:00,110 --> 00:05:03,650
actually big beasts that do very

00:05:01,940 --> 00:05:05,780
different things that net1 that your

00:05:03,650 --> 00:05:08,419
other one they're very different and

00:05:05,780 --> 00:05:09,979
there's this somewhat long text but that

00:05:08,419 --> 00:05:11,720
you can read if you want to read the

00:05:09,979 --> 00:05:14,360
slides afterwards it's a very nice text

00:05:11,720 --> 00:05:20,599
from mr. mortu ray is the author of a

00:05:14,360 --> 00:05:23,330
leaf language makes a very nice case of

00:05:20,599 --> 00:05:26,539
why you would need or want an abstract

00:05:23,330 --> 00:05:29,860
machine saying well your poems

00:05:26,539 --> 00:05:32,419
instructions really and and you you you

00:05:29,860 --> 00:05:33,830
you don't want to write your program for

00:05:32,419 --> 00:05:35,570
a specific piece of hardware you want to

00:05:33,830 --> 00:05:37,009
write it in a general way and transpose

00:05:35,570 --> 00:05:39,320
it to the actual hardware at some point

00:05:37,009 --> 00:05:40,550
so it's it's a very useful tool for

00:05:39,320 --> 00:05:42,349
thinking to have an abstract machine

00:05:40,550 --> 00:05:44,270
something that you write for that's the

00:05:42,349 --> 00:05:46,460
tight with specific set of registers or

00:05:44,270 --> 00:05:48,560
this kind of memory or that kind of mean

00:05:46,460 --> 00:05:51,380
really this kind of value elevate the

00:05:48,560 --> 00:05:53,180
discourse a bit and adds at the end and

00:05:51,380 --> 00:05:54,349
I used to say rightfully but someone in

00:05:53,180 --> 00:05:57,259
one of the rooms where I give this talk

00:05:54,349 --> 00:05:59,090
for said rightfully or disagreeing Wow

00:05:57,259 --> 00:06:00,500
in academia Turing machines and the

00:05:59,090 --> 00:06:02,569
calculus are examples of extract

00:06:00,500 --> 00:06:04,039
machines they are know that there are

00:06:02,569 --> 00:06:06,500
some people disagree with them sir more

00:06:04,039 --> 00:06:10,819
terrain in this case but it's a point of

00:06:06,500 --> 00:06:12,229
view so the one we have in C++ taken

00:06:10,819 --> 00:06:13,990
from one of the texts that we Arnie

00:06:12,229 --> 00:06:17,569
wrote about ten years or so ago

00:06:13,990 --> 00:06:19,490
well I'll said we're using C++ in a lot

00:06:17,569 --> 00:06:21,050
of application areas of course is part

00:06:19,490 --> 00:06:23,240
of what he said this morning I mean

00:06:21,050 --> 00:06:26,360
interesting about thing about C++ is

00:06:23,240 --> 00:06:26,780
what we can do with it so how do we do

00:06:26,360 --> 00:06:30,139
that

00:06:26,780 --> 00:06:31,780
well we try to add an active abstraction

00:06:30,139 --> 00:06:33,160
layer we try to have zero cut

00:06:31,780 --> 00:06:35,320
because the corrections as much as we

00:06:33,160 --> 00:06:36,760
can and we're not writing for a specific

00:06:35,320 --> 00:06:39,610
piece of hardware of course it would be

00:06:36,760 --> 00:06:40,840
very inefficient so we try to map

00:06:39,610 --> 00:06:43,000
directly on tour and wear as much as

00:06:40,840 --> 00:06:45,490
it's reasonable to do so we have basic

00:06:43,000 --> 00:06:49,230
types that tend to map to various

00:06:45,490 --> 00:06:54,160
entities bytes words or so our pointers

00:06:49,230 --> 00:06:57,640
represent contiguous address model of

00:06:54,160 --> 00:07:00,040
memory that we were off from see why not

00:06:57,640 --> 00:07:01,120
there's no abstract mathematical model

00:07:00,040 --> 00:07:03,220
that gets in the way between which

00:07:01,120 --> 00:07:05,169
you're coding and actual hardware so we

00:07:03,220 --> 00:07:08,590
try to make something as very thin such

00:07:05,169 --> 00:07:10,060
that you can actually reason something

00:07:08,590 --> 00:07:13,570
that really looks like a real machine no

00:07:10,060 --> 00:07:14,980
it's not so of course you have to be

00:07:13,570 --> 00:07:17,770
careful because the math being of types

00:07:14,980 --> 00:07:22,650
of hardware it doesn't always not in the

00:07:17,770 --> 00:07:22,650
ways people expect so a char is about

00:07:25,110 --> 00:07:29,200
but an int is not necessarily very

00:07:27,070 --> 00:07:30,310
register or the same science could be

00:07:29,200 --> 00:07:34,690
different so we have to be careful with

00:07:30,310 --> 00:07:38,850
them and we don't grow up from to see

00:07:34,690 --> 00:07:42,460
with this so the idea is we can express

00:07:38,850 --> 00:07:44,530
cash Marine unit rum we look in the city

00:07:42,460 --> 00:07:46,540
go there we can we get explicit if we

00:07:44,530 --> 00:07:49,479
want to we can get close to a hardware

00:07:46,540 --> 00:07:53,680
but we don't have machine that says you

00:07:49,479 --> 00:07:55,780
have a cache so there's another guy

00:07:53,680 --> 00:07:58,060
named just now might not know much we

00:07:55,780 --> 00:08:01,600
gave the really nice introduction to the

00:07:58,060 --> 00:08:03,490
see abstract machine saying that well

00:08:01,600 --> 00:08:05,260
things like language to Thruxton to map

00:08:03,490 --> 00:08:07,360
to and submission instructions very

00:08:05,260 --> 00:08:09,120
closely which helps you to think in

00:08:07,360 --> 00:08:12,669
terms of the efficiency you being to get

00:08:09,120 --> 00:08:14,710
it's working very hard and see to avoid

00:08:12,669 --> 00:08:17,320
things that cost you something which

00:08:14,710 --> 00:08:19,240
brings us to the zero cost abstraction

00:08:17,320 --> 00:08:21,090
model of C++ you don't have a garbage

00:08:19,240 --> 00:08:24,220
condition it could cost you something

00:08:21,090 --> 00:08:25,630
you don't mount checks bounced check new

00:08:24,220 --> 00:08:27,610
raise because it would cost you

00:08:25,630 --> 00:08:29,320
something you can do it if you want but

00:08:27,610 --> 00:08:32,169
it's not something we do for you and

00:08:29,320 --> 00:08:34,440
something it's you accept pay should you

00:08:32,169 --> 00:08:37,750
should you want it

00:08:34,440 --> 00:08:40,030
you have your memory in see it exposed

00:08:37,750 --> 00:08:42,880
as memory of mice essentially that's

00:08:40,030 --> 00:08:44,980
what you think of it and you think of it

00:08:42,880 --> 00:08:47,080
as a flatter a loose not always exactly

00:08:44,980 --> 00:08:48,700
what's going on Duryea in real life you

00:08:47,080 --> 00:08:51,130
have typed addresses so you have

00:08:48,700 --> 00:08:52,570
typewriters of something and you can

00:08:51,130 --> 00:08:55,150
reason terms of written take based on

00:08:52,570 --> 00:09:00,160
that and it's simple insufficient it

00:08:55,150 --> 00:09:01,990
works I mean it lets you think about

00:09:00,160 --> 00:09:06,040
that at some point also saying phrasing

00:09:01,990 --> 00:09:07,630
that most simple it's efficient it's not

00:09:06,040 --> 00:09:10,300
well to hire little concepts like

00:09:07,630 --> 00:09:12,280
generators and others there's a lot to

00:09:10,300 --> 00:09:15,310
be said about that even though some

00:09:12,280 --> 00:09:16,600
people complain of course so we have we

00:09:15,310 --> 00:09:18,070
have this big beast and then the

00:09:16,600 --> 00:09:20,740
standard that says things about the

00:09:18,070 --> 00:09:24,940
abstract machine that defines the rules

00:09:20,740 --> 00:09:26,460
and the playground for us so without

00:09:24,940 --> 00:09:29,740
rush a surprise

00:09:26,460 --> 00:09:32,560
it appears early on in the text so in

00:09:29,740 --> 00:09:35,320
the first pages you will see most of the

00:09:32,560 --> 00:09:37,870
meat was going out here if you've never

00:09:35,320 --> 00:09:42,700
read this beautiful piece of literature

00:09:37,870 --> 00:09:45,580
there's a standard the first few hundred

00:09:42,700 --> 00:09:47,920
pages are essentially maintained by four

00:09:45,580 --> 00:09:50,260
of which are members in this room

00:09:47,920 --> 00:09:51,490
including me I tend to stay right there

00:09:50,260 --> 00:09:54,220
because I really like it

00:09:51,490 --> 00:09:58,720
and the higher pages are essentially a

00:09:54,220 --> 00:10:01,540
library play around and in between these

00:09:58,720 --> 00:10:04,090
two person groups that write the paper

00:10:01,540 --> 00:10:09,550
you'll see differences in style now core

00:10:04,090 --> 00:10:11,530
has been said to be dry it also has the

00:10:09,550 --> 00:10:14,770
most beautiful examples for those of you

00:10:11,530 --> 00:10:16,480
who have a very twisted mind so if you

00:10:14,770 --> 00:10:18,190
look at the very beginning of the

00:10:16,480 --> 00:10:20,140
document you'll see things like what you

00:10:18,190 --> 00:10:22,240
see up there I tried to put emphasis on

00:10:20,140 --> 00:10:24,640
some of the pieces and the links that

00:10:22,240 --> 00:10:25,330
you see yielded is there they're

00:10:24,640 --> 00:10:28,390
officially

00:10:25,330 --> 00:10:30,550
maintained now by by the ISO standard

00:10:28,390 --> 00:10:33,010
foundation so we can actually say that

00:10:30,550 --> 00:10:34,720
they're real excerpts from the standard

00:10:33,010 --> 00:10:37,450
you can actually use that and be

00:10:34,720 --> 00:10:38,890
confident that it works so if you click

00:10:37,450 --> 00:10:41,530
on these which I want because my

00:10:38,890 --> 00:10:43,600
internet connection is you will see that

00:10:41,530 --> 00:10:46,360
your excerpts from which I'm picking up

00:10:43,600 --> 00:10:47,300
this stuff we might like being slightly

00:10:46,360 --> 00:10:48,860
differ from what

00:10:47,300 --> 00:10:51,740
put their because they did this slice in

00:10:48,860 --> 00:10:54,140
February and then in June based on the

00:10:51,740 --> 00:10:56,150
February text and there's been an update

00:10:54,140 --> 00:10:57,680
in July but it's very very close I don't

00:10:56,150 --> 00:11:00,530
think anything is changed but I didn't

00:10:57,680 --> 00:11:03,440
like verifying every single word so this

00:11:00,530 --> 00:11:06,890
one says that it's standard text with

00:11:03,440 --> 00:11:11,440
ripe this the we define a perimeter eyes

00:11:06,890 --> 00:11:13,370
and then deterministic astra machine

00:11:11,440 --> 00:11:17,150
non-deterministic tends to make people

00:11:13,370 --> 00:11:18,740
react i'm not habitually writing think

00:11:17,150 --> 00:11:20,990
there's a specific meaning for that

00:11:18,740 --> 00:11:25,420
we'll come back to it so confirming

00:11:20,990 --> 00:11:25,420
implementations i have to any light

00:11:25,900 --> 00:11:30,110
observable behavior the machine so

00:11:28,610 --> 00:11:31,970
you're writing things in terms of that

00:11:30,110 --> 00:11:34,190
abstract machine which is an exist in

00:11:31,970 --> 00:11:35,810
your compiler as to transform your KO in

00:11:34,190 --> 00:11:38,960
such a way that it behaves as what you

00:11:35,810 --> 00:11:43,100
read what she wrote it's pretty cool as

00:11:38,960 --> 00:11:48,620
long as you following the rules I think

00:11:43,100 --> 00:11:51,020
for an undetermined but so there's this

00:11:48,620 --> 00:11:53,690
provision that says if we call it has it

00:11:51,020 --> 00:11:54,860
flow with with ports everyone refers to

00:11:53,690 --> 00:11:57,440
it it actually has a name actually

00:11:54,860 --> 00:11:59,270
exists and what it essentially says is

00:11:57,440 --> 00:12:03,410
that we can do the compiler can do a

00:11:59,270 --> 00:12:06,050
number of transformations that would

00:12:03,410 --> 00:12:08,720
hurt your heart if you saw them because

00:12:06,050 --> 00:12:12,560
you write your code with care and with

00:12:08,720 --> 00:12:14,480
love and we don't care anyway but we're

00:12:12,560 --> 00:12:17,180
going to try very hard not read the

00:12:14,480 --> 00:12:19,670
benders we'll try to work very hard to

00:12:17,180 --> 00:12:21,830
keep up to keep the observable behavior

00:12:19,670 --> 00:12:23,480
of what you wrote if you follow the

00:12:21,830 --> 00:12:26,480
rules they're supposed to keep that for

00:12:23,480 --> 00:12:28,760
you so it's as if they did nothing

00:12:26,480 --> 00:12:32,630
except that works faster and better or

00:12:28,760 --> 00:12:33,950
anything so parameterize a

00:12:32,630 --> 00:12:37,190
non-deterministic in a very specific

00:12:33,950 --> 00:12:41,120
sense which is to see what I just said

00:12:37,190 --> 00:12:43,970
so that means the program can not do

00:12:41,120 --> 00:12:45,470
things that you wrote if the compiler

00:12:43,970 --> 00:12:48,350
judges

00:12:45,470 --> 00:12:50,750
there's no point there's no observable

00:12:48,350 --> 00:12:52,040
behavior tied to that so I put a link

00:12:50,750 --> 00:12:53,990
there but normally I would click on it

00:12:52,040 --> 00:12:58,240
but since my internet connection is

00:12:53,990 --> 00:13:01,190
shaky I cheated and I used Matt's

00:12:58,240 --> 00:13:04,250
writing this thing it's a very very bad

00:13:01,190 --> 00:13:06,140
piece of code if I but I use it very

00:13:04,250 --> 00:13:08,270
often I have students who come into my

00:13:06,140 --> 00:13:10,130
class especially when they're especially

00:13:08,270 --> 00:13:12,530
when they're beginners it was me this

00:13:10,130 --> 00:13:14,450
very deep question should I use while

00:13:12,530 --> 00:13:18,610
the while or for loops which one is

00:13:14,450 --> 00:13:20,840
faster the first time my arms just fell

00:13:18,610 --> 00:13:22,160
but then you have to remember that

00:13:20,840 --> 00:13:23,690
people start they have no idea if this

00:13:22,160 --> 00:13:25,790
makes sense or not they're really

00:13:23,690 --> 00:13:27,170
worried and they want to sound efficient

00:13:25,790 --> 00:13:28,580
you know so they're wondering what kind

00:13:27,170 --> 00:13:31,760
of loop they shouldn't stick to and

00:13:28,580 --> 00:13:33,620
forget all the others so the first thing

00:13:31,760 --> 00:13:37,580
is you read the code I wrote a program

00:13:33,620 --> 00:13:38,780
that think that accumulates and should

00:13:37,580 --> 00:13:40,760
be late

00:13:38,780 --> 00:13:42,770
I had numbers from one to ten in three

00:13:40,760 --> 00:13:44,240
different loops and you write that thing

00:13:42,770 --> 00:13:46,610
and you show them and you see all of

00:13:44,240 --> 00:13:48,230
this code and if you look at it so yeah

00:13:46,610 --> 00:13:50,120
there's an additional jump somewhere in

00:13:48,230 --> 00:13:53,230
the for loop because you have to step

00:13:50,120 --> 00:13:56,510
over the the incrementation everything

00:13:53,230 --> 00:13:58,190
so they look at this hmm

00:13:56,510 --> 00:14:03,220
first of all loops are very expensive

00:13:58,190 --> 00:14:06,230
there's no out there and then then you

00:14:03,220 --> 00:14:07,460
you add something you optimize the code

00:14:06,230 --> 00:14:09,020
as you can see right now there's an

00:14:07,460 --> 00:14:11,090
optimization there's no level of

00:14:09,020 --> 00:14:16,010
transition whatsoever and when you add

00:14:11,090 --> 00:14:18,350
or twist it's much nicer because because

00:14:16,010 --> 00:14:19,610
because they're they're not noticing of

00:14:18,350 --> 00:14:21,890
course that you're not doing anything

00:14:19,610 --> 00:14:23,630
with the computation you did so you're

00:14:21,890 --> 00:14:25,370
just computing things and never

00:14:23,630 --> 00:14:27,650
displaying or saving anything there's no

00:14:25,370 --> 00:14:32,150
yio there's no servile behavior to your

00:14:27,650 --> 00:14:36,110
program so it's poink it's almost like

00:14:32,150 --> 00:14:37,910
the question was pointless so so so this

00:14:36,110 --> 00:14:39,260
shows kind of like Jerry was the ring

00:14:37,910 --> 00:14:40,250
this morning if you're optimizing your

00:14:39,260 --> 00:14:42,800
code you get what you deserve

00:14:40,250 --> 00:14:44,150
yeah but but but if you do put on the

00:14:42,800 --> 00:14:46,910
optimizer sometimes well you realize

00:14:44,150 --> 00:14:50,750
that he has a fool this is a compiler

00:14:46,910 --> 00:14:53,000
say well pointless so this is perfectly

00:14:50,750 --> 00:14:54,410
legal you don't have to stick to my

00:14:53,000 --> 00:14:56,840
Shero the computer doesn't really care

00:14:54,410 --> 00:14:58,290
as long as there are rules and they're

00:14:56,840 --> 00:15:01,060
being followed

00:14:58,290 --> 00:15:02,800
another one is I've heard from

00:15:01,060 --> 00:15:05,080
colleagues so people have been teaching

00:15:02,800 --> 00:15:09,730
for longer and I have for more than 20

00:15:05,080 --> 00:15:12,760
years like I want to do be fine on a

00:15:09,730 --> 00:15:14,770
victor and I want to do a find on a set

00:15:12,760 --> 00:15:16,870
and I've been told that Victor is very

00:15:14,770 --> 00:15:18,460
fast so I'm reading your search but

00:15:16,870 --> 00:15:20,920
you'll see the cache bah bah bah bah bah

00:15:18,460 --> 00:15:22,030
and yeah different depending on what

00:15:20,920 --> 00:15:24,520
you're doing sometimes one is better

00:15:22,030 --> 00:15:25,720
here sometimes there is better so they

00:15:24,520 --> 00:15:28,000
come to me with something like this I

00:15:25,720 --> 00:15:32,230
did a vector fine that it is set fine

00:15:28,000 --> 00:15:36,480
and I used Fred I think it's tango it's

00:15:32,230 --> 00:15:38,590
bench Martino hey let's see you mmm nice

00:15:36,480 --> 00:15:40,900
so and there's a poster about it

00:15:38,590 --> 00:15:43,450
downstairs if you want to go through so

00:15:40,900 --> 00:15:44,890
this very small thing that essentially

00:15:43,450 --> 00:15:47,860
does the same thing in terms of

00:15:44,890 --> 00:15:51,580
conceptual stuff inserting a same number

00:15:47,860 --> 00:15:54,030
of numbers from 1 to so-and-so and then

00:15:51,580 --> 00:15:56,650
doing a number of finds in both cases

00:15:54,030 --> 00:16:02,170
and of course if you do it like this

00:15:56,650 --> 00:16:05,920
like there seems to be very slow and

00:16:02,170 --> 00:16:07,360
obviously since optimization is oh one

00:16:05,920 --> 00:16:09,400
this case you get what you deserve

00:16:07,360 --> 00:16:11,770
because if you change it to my session

00:16:09,400 --> 00:16:14,490
level you get something different since

00:16:11,770 --> 00:16:17,200
it's not faster or slower it's just that

00:16:14,490 --> 00:16:18,730
comparing notice it's tough and probably

00:16:17,200 --> 00:16:20,710
in this case the stepped is doing more

00:16:18,730 --> 00:16:23,020
memory allocation which could be

00:16:20,710 --> 00:16:25,150
observable I guess so there's something

00:16:23,020 --> 00:16:29,350
costly there going on whereas in Victor

00:16:25,150 --> 00:16:30,850
well not much so you have to be careful

00:16:29,350 --> 00:16:33,190
with that so the answer fool please roll

00:16:30,850 --> 00:16:34,330
it does you enjoy it

00:16:33,190 --> 00:16:37,360
and as long as you're careful with it

00:16:34,330 --> 00:16:40,000
it's pretty nice so what is gave you now

00:16:37,360 --> 00:16:43,180
well yeah you have side effects there I

00:16:40,000 --> 00:16:45,940
owe from library something that calls

00:16:43,180 --> 00:16:49,450
such I owes you you read then object

00:16:45,940 --> 00:16:50,920
that's all or something so yeah that's

00:16:49,450 --> 00:16:53,170
what you have to pay attention to if

00:16:50,920 --> 00:16:55,240
there's none of that your code may go

00:16:53,170 --> 00:16:57,090
away but you didn't need it in the first

00:16:55,240 --> 00:16:58,740
place

00:16:57,090 --> 00:17:00,900
so it's very powerful you want it you

00:16:58,740 --> 00:17:02,370
have to be careful when you have more

00:17:00,900 --> 00:17:05,810
than what thread you have shared state

00:17:02,370 --> 00:17:08,010
you have two six let's see what you mean

00:17:05,810 --> 00:17:11,580
otherwise compadre might assume stuff

00:17:08,010 --> 00:17:13,770
like there's no threads and I've been

00:17:11,580 --> 00:17:15,900
I've been reminded by people you know

00:17:13,770 --> 00:17:17,520
you can have empty programs and with

00:17:15,900 --> 00:17:19,590
only two instructions if you look at God

00:17:17,520 --> 00:17:21,720
mold and they're much bigger when you

00:17:19,590 --> 00:17:23,370
run them it's because there's libraries

00:17:21,720 --> 00:17:25,440
involved and you link with them and so

00:17:23,370 --> 00:17:26,700
and so depends on your quality level you

00:17:25,440 --> 00:17:29,340
have to be careful with your assumptions

00:17:26,700 --> 00:17:31,250
there and so there's assumptions that

00:17:29,340 --> 00:17:34,440
you might have that are necessarily true

00:17:31,250 --> 00:17:37,380
so you have implementation different

00:17:34,440 --> 00:17:39,570
stuff like the size of an int the number

00:17:37,380 --> 00:17:44,310
of people we need this for we never say

00:17:39,570 --> 00:17:47,820
that and I've been taught myself sizeof

00:17:44,310 --> 00:17:49,710
int is the size of a memory word I hail

00:17:47,820 --> 00:17:52,320
that this belief until actually read the

00:17:49,710 --> 00:17:54,270
text and we don't say that it tends to

00:17:52,320 --> 00:17:56,220
be that way you know we tend to for

00:17:54,270 --> 00:18:00,920
historical reasons to want a short name

00:17:56,220 --> 00:18:04,200
type int to be the first one that and

00:18:00,920 --> 00:18:07,130
some T which might change even in some

00:18:04,200 --> 00:18:12,570
patters as a string depending on your

00:18:07,130 --> 00:18:15,240
different members you can count the size

00:18:12,570 --> 00:18:18,510
of char being one but that's the big

00:18:15,240 --> 00:18:20,400
bits it's probably in this so they're

00:18:18,510 --> 00:18:23,100
the implementation find little things

00:18:20,400 --> 00:18:26,070
they constitute the parameters of the

00:18:23,100 --> 00:18:27,930
abstract machine we have a very

00:18:26,070 --> 00:18:30,840
interesting presentation in Toronto this

00:18:27,930 --> 00:18:32,160
year by Lisa which I haven't seen I

00:18:30,840 --> 00:18:34,140
don't know if she's here this week she

00:18:32,160 --> 00:18:37,230
was here last we got last year there

00:18:34,140 --> 00:18:38,340
interesting thing where she used I put a

00:18:37,230 --> 00:18:41,310
reference if you want to read about it

00:18:38,340 --> 00:18:45,090
she used the abstract machine as a as

00:18:41,310 --> 00:18:48,210
leverage to make programs more resilient

00:18:45,090 --> 00:18:52,140
and make reasoning about assertions

00:18:48,210 --> 00:18:53,850
stronger very deep things so please use

00:18:52,140 --> 00:18:55,800
that thing it's actually model the

00:18:53,850 --> 00:18:58,820
execution has been machined using these

00:18:55,800 --> 00:19:02,010
as parameters for interesting thoughts

00:18:58,820 --> 00:19:03,270
you have also on top of the

00:19:02,010 --> 00:19:04,950
implementation defined stuff you have

00:19:03,270 --> 00:19:09,570
unspecified so there are things we don't

00:19:04,950 --> 00:19:10,890
say people assume things so when you

00:19:09,570 --> 00:19:15,630
have a new expression with

00:19:10,890 --> 00:19:18,720
arguments in which order are they we

00:19:15,630 --> 00:19:20,280
don't say we don't say especially if we

00:19:18,720 --> 00:19:22,200
fail to get me you don't say much about

00:19:20,280 --> 00:19:26,550
that so if you have beliefs that's fair

00:19:22,200 --> 00:19:27,960
but who can say so so these things are

00:19:26,550 --> 00:19:30,180
funny kills your compiler will do

00:19:27,960 --> 00:19:32,280
something you just don't have any

00:19:30,180 --> 00:19:35,760
horrible assumption as to it would be

00:19:32,280 --> 00:19:37,560
done so this is what we call in standard

00:19:35,760 --> 00:19:39,810
is a non deterministic aspect so tell us

00:19:37,560 --> 00:19:42,230
that is it sing no if you stick to a

00:19:39,810 --> 00:19:44,220
specific compiler you'll probably get

00:19:42,230 --> 00:19:45,840
stable behavior although you cannot

00:19:44,220 --> 00:19:48,300
count on them so they are doing

00:19:45,840 --> 00:19:50,340
something it's fair it's not dangerous

00:19:48,300 --> 00:19:52,770
but the assumptions on which you base

00:19:50,340 --> 00:19:55,590
things are none portable my you know

00:19:52,770 --> 00:19:57,300
seeds but money I'm sorry my my other

00:19:55,590 --> 00:20:00,960
thing there as another word on that

00:19:57,300 --> 00:20:02,940
there are people want to fix an order to

00:20:00,960 --> 00:20:03,990
evaluate when we evaluate some

00:20:02,940 --> 00:20:06,480
expressions that we give an expression

00:20:03,990 --> 00:20:08,400
and there are levels to which I person

00:20:06,480 --> 00:20:10,470
would stop and are things that I think

00:20:08,400 --> 00:20:13,620
are fine there are fantastical arguments

00:20:10,470 --> 00:20:16,500
about that but these these things that

00:20:13,620 --> 00:20:20,910
are reasonable but depend on the

00:20:16,500 --> 00:20:22,260
implementation the exist so and there

00:20:20,910 --> 00:20:24,900
are undefined things which you might

00:20:22,260 --> 00:20:27,960
have heard about these are things of

00:20:24,900 --> 00:20:31,080
evil and so modifying a constant check

00:20:27,960 --> 00:20:33,680
doing all kinds of evil casts well if

00:20:31,080 --> 00:20:38,250
you do that and not even sorry for you

00:20:33,680 --> 00:20:40,710
so we impose no requirement and programs

00:20:38,250 --> 00:20:43,760
that behave that badly you're on your

00:20:40,710 --> 00:20:48,000
own initiative that it's not work

00:20:43,760 --> 00:20:51,480
network so a conforming implementation

00:20:48,000 --> 00:20:53,300
that executes a welfare program will

00:20:51,480 --> 00:20:56,700
produce the same adorable behavior voila

00:20:53,300 --> 00:20:58,920
however should you be an evil person who

00:20:56,700 --> 00:21:01,470
has even one of these undefined

00:20:58,920 --> 00:21:03,630
operations well we please no requirement

00:21:01,470 --> 00:21:07,920
even if the operations that are evil are

00:21:03,630 --> 00:21:10,410
below and the code above seems nice we

00:21:07,920 --> 00:21:14,630
don't care if you do that you decided to

00:21:10,410 --> 00:21:17,100
go on your own playground and have fun I

00:21:14,630 --> 00:21:18,330
didn't put a link to that on the

00:21:17,100 --> 00:21:19,890
presentation because it said of talk

00:21:18,330 --> 00:21:22,170
about and if I'm behavior but there's

00:21:19,890 --> 00:21:24,510
this very nice tweet we had a few we had

00:21:22,170 --> 00:21:26,400
a few weeks ago that made us talk

00:21:24,510 --> 00:21:27,990
among ourselves where someone had

00:21:26,400 --> 00:21:33,930
written the function some people already

00:21:27,990 --> 00:21:35,460
doing this hookah did RM / - RF / on a

00:21:33,930 --> 00:21:37,860
function that's never being called and

00:21:35,460 --> 00:21:39,780
the generated code calls it nonetheless

00:21:37,860 --> 00:21:44,250
because someone is accessing a null

00:21:39,780 --> 00:21:47,840
pointer it's very easy - it's very easy

00:21:44,250 --> 00:21:51,000
to do things like that and you'll get

00:21:47,840 --> 00:21:54,000
I've been reminded by some I saw people

00:21:51,000 --> 00:21:56,580
from other groups the safety language

00:21:54,000 --> 00:22:00,330
the safety programming languages group

00:21:56,580 --> 00:22:02,730
so that if you're using a standardized

00:22:00,330 --> 00:22:05,250
language like C++ you're actually liable

00:22:02,730 --> 00:22:06,900
to get sued or stuff like that if you're

00:22:05,250 --> 00:22:08,370
going that direction because you're

00:22:06,900 --> 00:22:10,710
expected to be an expert doing

00:22:08,370 --> 00:22:12,420
reasonable stuff now some companies will

00:22:10,710 --> 00:22:15,510
hire you because you're writing using a

00:22:12,420 --> 00:22:16,370
standardized language so please don't do

00:22:15,510 --> 00:22:18,840
this

00:22:16,370 --> 00:22:20,010
so we have some real tight program

00:22:18,840 --> 00:22:22,500
execution that's very nice

00:22:20,010 --> 00:22:23,580
REI idioms like that actually part

00:22:22,500 --> 00:22:25,530
they're not named like that in the

00:22:23,580 --> 00:22:27,060
standard of course but they're part of

00:22:25,530 --> 00:22:30,630
the execution and models you can see

00:22:27,060 --> 00:22:33,360
that there is a link with the posting

00:22:30,630 --> 00:22:34,860
brace and some coding excited you can

00:22:33,360 --> 00:22:38,280
count on that it's reasonable makes

00:22:34,860 --> 00:22:40,530
sense we define the rules tied to

00:22:38,280 --> 00:22:42,030
lifetime of your objects just sender

00:22:40,530 --> 00:22:45,840
dies you can count on that as long as

00:22:42,030 --> 00:22:47,490
you're following the rules of course and

00:22:45,840 --> 00:22:52,080
there's a number of other things that we

00:22:47,490 --> 00:22:53,670
mentioned briefly as long as you didn't

00:22:52,080 --> 00:22:56,850
break anything like throwing from an

00:22:53,670 --> 00:22:59,070
Excel function I own everything there's

00:22:56,850 --> 00:23:02,550
a set of things that are named and said

00:22:59,070 --> 00:23:05,040
to me the observable behavior program so

00:23:02,550 --> 00:23:07,170
your implementation can be stronger they

00:23:05,040 --> 00:23:08,550
can do more and ask more of you but

00:23:07,170 --> 00:23:13,620
there's a baseline on which you can

00:23:08,550 --> 00:23:16,410
count it's standardized we assign things

00:23:13,620 --> 00:23:20,280
such as the order of evaluation of

00:23:16,410 --> 00:23:23,220
expressions how the operators in what

00:23:20,280 --> 00:23:24,360
order are the operators evaluated in the

00:23:23,220 --> 00:23:26,220
complex expression that's all

00:23:24,360 --> 00:23:30,050
standardized we are these things that

00:23:26,220 --> 00:23:30,050
are very nice we

00:23:30,139 --> 00:23:39,529
exelon me of the expressions it's it

00:23:33,139 --> 00:23:41,360
used to be so simple I almost feel bad

00:23:39,529 --> 00:23:44,210
swinging I don't show that the students

00:23:41,360 --> 00:23:47,870
anymore because the Africa so we have

00:23:44,210 --> 00:23:49,399
these generalized L values the death

00:23:47,870 --> 00:23:54,649
actually has the main in standard ensues

00:23:49,399 --> 00:23:57,230
as such so the pure are values that we

00:23:54,649 --> 00:23:59,090
use when you have unnamed results from

00:23:57,230 --> 00:24:01,909
function calls of expressions or

00:23:59,090 --> 00:24:04,340
anywhere that's pretty cool the expiring

00:24:01,909 --> 00:24:32,090
values that will die sorry for those who

00:24:04,340 --> 00:24:33,350
have things in there so there we have

00:24:32,090 --> 00:24:37,039
all these categories because if they

00:24:33,350 --> 00:24:39,200
roll I won't get into the main official

00:24:37,039 --> 00:24:41,720
there's a guy named Eddie Chevy that

00:24:39,200 --> 00:24:44,539
okay seriously I think he is because I

00:24:41,720 --> 00:24:46,070
saw a tweet by in a morning we tried to

00:24:44,539 --> 00:24:47,840
make a recursive main and it was very

00:24:46,070 --> 00:24:52,129
very happy that he was doing Fibonacci

00:24:47,840 --> 00:24:54,110
using Maine it's illegal it might work

00:24:52,129 --> 00:24:55,549
for a compiler but we actually say no

00:24:54,110 --> 00:24:58,039
you shouldn't do that you cannot call me

00:24:55,549 --> 00:25:00,590
in your program yourself the characters

00:24:58,039 --> 00:25:02,149
on it it should return an int there's

00:25:00,590 --> 00:25:05,389
number of rules like to remain special

00:25:02,149 --> 00:25:07,159
so and there there's only way with the

00:25:05,389 --> 00:25:09,889
first paragraph that lets us the cast

00:25:07,159 --> 00:25:12,889
fenders play tricks on embedded systems

00:25:09,889 --> 00:25:14,389
to save slice but essentially there are

00:25:12,889 --> 00:25:15,799
rules like tonight if you returned from

00:25:14,389 --> 00:25:19,249
Maine you quarantine exit

00:25:15,799 --> 00:25:21,019
programs over so it's it's it's written

00:25:19,249 --> 00:25:22,820
it's not something that people thought

00:25:21,019 --> 00:25:25,610
of like and started spreading rumors

00:25:22,820 --> 00:25:27,889
Maine especial the function men shall

00:25:25,610 --> 00:25:29,450
not be used within a program it's think

00:25:27,889 --> 00:25:31,850
it is the permutation defined blah blah

00:25:29,450 --> 00:25:34,369
blah so you cannot have a caustic remain

00:25:31,850 --> 00:25:36,990
as far as I know so there's rule tied to

00:25:34,369 --> 00:25:40,530
that so you can do anything you want

00:25:36,990 --> 00:25:42,480
hey Gary this morning mentioned memory

00:25:40,530 --> 00:25:44,850
model when he was saying that he shows

00:25:42,480 --> 00:25:47,220
sometimes people students how to write

00:25:44,850 --> 00:25:48,780
their own kind of vector it's tricky to

00:25:47,220 --> 00:25:49,980
are things that right now are hard to do

00:25:48,780 --> 00:25:53,160
when you're not in the standard library

00:25:49,980 --> 00:25:54,150
with that when you write strings and I

00:25:53,160 --> 00:25:55,500
was saying at some point you have to

00:25:54,150 --> 00:25:57,690
dirty your hands and touch a memory

00:25:55,500 --> 00:26:02,100
model in class otherwise it remains

00:25:57,690 --> 00:26:04,230
matching which is kind of true well if

00:26:02,100 --> 00:26:07,890
you put that thing in it priming looks

00:26:04,230 --> 00:26:10,860
like magic so we have bytes there that's

00:26:07,890 --> 00:26:14,070
a fundamental storage unit if they bite

00:26:10,860 --> 00:26:19,230
today char before and there's no fight

00:26:14,070 --> 00:26:21,510
to bite a byte is eight bits under there

00:26:19,230 --> 00:26:23,910
says well at least every second it

00:26:21,510 --> 00:26:25,890
supports two bytes of unique addresses

00:26:23,910 --> 00:26:27,020
well that's part of the machine you can

00:26:25,890 --> 00:26:29,340
count on that

00:26:27,020 --> 00:26:31,320
sometimes you want to compare unequal

00:26:29,340 --> 00:26:34,380
pointers to objects and you're doing

00:26:31,320 --> 00:26:36,150
dirty things like comparing the think

00:26:34,380 --> 00:26:38,400
objects and saying they're equal or

00:26:36,150 --> 00:26:39,630
something so you have rules there if

00:26:38,400 --> 00:26:41,270
you're pointing to with different

00:26:39,630 --> 00:26:43,710
elements of a sigma-ring

00:26:41,270 --> 00:26:46,320
pointing to different nuns like that the

00:26:43,710 --> 00:26:47,940
members are the same object and this is

00:26:46,320 --> 00:26:50,340
the last one there otherwise neither

00:26:47,940 --> 00:26:52,800
pointer compares later than the others

00:26:50,340 --> 00:26:54,600
you can actually have situations where

00:26:52,800 --> 00:26:56,220
you compare it to pointers and a is not

00:26:54,600 --> 00:26:59,450
lower than B & B isn't taller than a

00:26:56,220 --> 00:27:01,559
they're not equal and you're confused

00:26:59,450 --> 00:27:02,280
confusion stems from the standard you

00:27:01,559 --> 00:27:19,260
shouldn't do that

00:27:02,280 --> 00:27:21,450
you're a bad person this guy said just

00:27:19,260 --> 00:27:23,640
for the recording if you're using

00:27:21,450 --> 00:27:30,300
something else on less than what happens

00:27:23,640 --> 00:27:32,220
right any tech record keys so yep so

00:27:30,300 --> 00:27:34,380
they can compilers can reorder your

00:27:32,220 --> 00:27:35,850
operations according to you as a fool

00:27:34,380 --> 00:27:37,550
and you like that but your hope will get

00:27:35,850 --> 00:27:40,020
faster in most cases

00:27:37,550 --> 00:27:41,960
be careful with multi-threading as we

00:27:40,020 --> 00:27:43,429
said and we offer you

00:27:41,960 --> 00:27:45,970
three new guarantees we should actually

00:27:43,429 --> 00:27:48,770
say that if you're playing nice with us

00:27:45,970 --> 00:27:50,409
your code will be sequentially

00:27:48,770 --> 00:27:53,450
consistent so you will look at the

00:27:50,409 --> 00:27:55,850
output it will be reasonable based on

00:27:53,450 --> 00:27:56,960
your source code I think it does not

00:27:55,850 --> 00:28:00,350
have something called the data race

00:27:56,960 --> 00:28:02,899
which is at least two threads touching

00:28:00,350 --> 00:28:04,610
the same object currently without

00:28:02,899 --> 00:28:07,669
synchronization and one of these is

00:28:04,610 --> 00:28:09,200
doing a right in which case you're way

00:28:07,669 --> 00:28:11,390
off and then if any of your land and

00:28:09,200 --> 00:28:14,809
we're not looking at you anymore so

00:28:11,390 --> 00:28:16,760
there and she will say rules for them

00:28:14,809 --> 00:28:18,020
because of course you cannot write the

00:28:16,760 --> 00:28:19,789
sake of the threaded code if you know

00:28:18,020 --> 00:28:22,070
that rules for these things because the

00:28:19,789 --> 00:28:26,330
optimizer will pass by and disregard all

00:28:22,070 --> 00:28:28,429
of your presumptions so you have

00:28:26,330 --> 00:28:31,640
civilization operations they're defined

00:28:28,429 --> 00:28:35,059
there there's a modification order of an

00:28:31,640 --> 00:28:37,039
object objects yes like machine specific

00:28:35,059 --> 00:28:39,770
orders now there's no requirement that

00:28:37,039 --> 00:28:40,940
you can totally order everything all the

00:28:39,770 --> 00:28:43,039
time I think that's our really

00:28:40,940 --> 00:28:46,880
concurrent the same time in a given

00:28:43,039 --> 00:28:48,740
program it might make sense why not but

00:28:46,880 --> 00:28:51,169
yeah if you're if you wrote the correct

00:28:48,740 --> 00:28:53,840
program you look at it at the end and

00:28:51,169 --> 00:28:57,289
you ask all the threads what happens

00:28:53,840 --> 00:29:00,380
based on the order in which your rights

00:28:57,289 --> 00:29:02,179
to shared objects occurred and they will

00:29:00,380 --> 00:29:03,529
agree they wanted me beforehand but it

00:29:02,179 --> 00:29:07,100
will it create angry afterward as to

00:29:03,529 --> 00:29:10,070
what happens can a street debug code

00:29:07,100 --> 00:29:14,450
when that happens whereas you might not

00:29:10,070 --> 00:29:16,460
in other circumstances so we have a

00:29:14,450 --> 00:29:19,700
swing attack machine titled memory model

00:29:16,460 --> 00:29:21,669
number rules as you want people could

00:29:19,700 --> 00:29:26,630
explain their hidden I do but still

00:29:21,669 --> 00:29:28,370
synchronizes with which says there are

00:29:26,630 --> 00:29:29,960
relations that describe our right to a

00:29:28,370 --> 00:29:31,970
variable and a thread and read from a

00:29:29,960 --> 00:29:33,950
state variable and another thread can

00:29:31,970 --> 00:29:37,909
behave depending on what she wrote it's

00:29:33,950 --> 00:29:40,580
pretty nice to have about that sequence

00:29:37,909 --> 00:29:42,440
before which says in which order things

00:29:40,580 --> 00:29:43,970
are expected to happen or at least if

00:29:42,440 --> 00:29:45,320
there's a dependence between them that's

00:29:43,970 --> 00:29:47,779
part of the machine so if you're

00:29:45,320 --> 00:29:50,330
following the rules shall get reasonable

00:29:47,779 --> 00:29:51,410
behavior carries dependency which I

00:29:50,330 --> 00:29:54,590
would

00:29:51,410 --> 00:29:57,500
get too far in because it's tight murder

00:29:54,590 --> 00:29:59,240
consume which is where we're supporting

00:29:57,500 --> 00:30:01,490
on stat exactly as we would like it to

00:29:59,240 --> 00:30:03,650
be but it says that if you have

00:30:01,490 --> 00:30:05,480
operations where the result of one is

00:30:03,650 --> 00:30:07,850
involved in the computation of another

00:30:05,480 --> 00:30:09,260
we will not reorder things in such a way

00:30:07,850 --> 00:30:09,950
we will broke your Cobra control if you

00:30:09,260 --> 00:30:13,610
can avoid it

00:30:09,950 --> 00:30:15,290
thank you we have time at least we have

00:30:13,610 --> 00:30:17,420
things like inter trans before it's

00:30:15,290 --> 00:30:19,910
pretty nice too so there are ways to say

00:30:17,420 --> 00:30:22,700
what happens there will happen before

00:30:19,910 --> 00:30:24,650
something there this is fine so if you

00:30:22,700 --> 00:30:25,790
follow rules we'll get back it's a

00:30:24,650 --> 00:30:31,760
pretty nice machine if you think of it

00:30:25,790 --> 00:30:34,340
so so when I talk to my games people and

00:30:31,760 --> 00:30:37,010
they come to me I'll say ok that's all

00:30:34,340 --> 00:30:44,930
very abstract I'm doing real things I'm

00:30:37,010 --> 00:30:48,500
doing real work so what about a step III

00:30:44,930 --> 00:30:58,310
put variables on the stack where is that

00:30:48,500 --> 00:31:00,650
where are the rules about that so if you

00:30:58,310 --> 00:31:02,600
if you take the PDF version of the

00:31:00,650 --> 00:31:05,510
standards text you look for the word

00:31:02,600 --> 00:31:07,070
stack you'll find a steady stack which

00:31:05,510 --> 00:31:10,130
is a container and then after two

00:31:07,070 --> 00:31:11,900
container at least you could call it

00:31:10,130 --> 00:31:15,710
yourself it's something from the mental

00:31:11,900 --> 00:31:17,870
the machine so and for good reasons I

00:31:15,710 --> 00:31:18,590
mean we have things coming in like

00:31:17,870 --> 00:31:22,450
co-routines

00:31:18,590 --> 00:31:26,900
that might not be using a stack at all

00:31:22,450 --> 00:31:29,180
as our machines where you have more than

00:31:26,900 --> 00:31:33,020
one stack per thread you can make with

00:31:29,180 --> 00:31:35,150
that so the the thing the thought that

00:31:33,020 --> 00:31:37,340
some of us have saying well you have a

00:31:35,150 --> 00:31:39,950
single stack per thread and that's where

00:31:37,340 --> 00:31:41,630
the arguments go that's per vendor

00:31:39,950 --> 00:31:45,050
things that's something that the

00:31:41,630 --> 00:31:46,670
abstract machine describes so then if we

00:31:45,050 --> 00:31:49,400
if we look for it to see stock unwinding

00:31:46,670 --> 00:31:50,660
I to the behavior of programs and

00:31:49,400 --> 00:31:52,340
exceptions it's wrong

00:31:50,660 --> 00:31:54,080
so the word stack is there technically

00:31:52,340 --> 00:31:55,970
speaking and there's a number of

00:31:54,080 --> 00:31:59,040
appearances of stack intersection where

00:31:55,970 --> 00:32:02,100
the library talks about STDs that

00:31:59,040 --> 00:32:04,290
that's about it so it might be

00:32:02,100 --> 00:32:12,180
surprising to some who start with that

00:32:04,290 --> 00:32:14,070
assumption so they're okay fair yeah so

00:32:12,180 --> 00:32:16,020
what about buying my registers no I have

00:32:14,070 --> 00:32:18,870
these things that hurt as big as an int

00:32:16,020 --> 00:32:21,720
in my mind where there's actual work

00:32:18,870 --> 00:32:27,390
being done so how does the structure she

00:32:21,720 --> 00:32:29,190
expressed this concept this idea no it

00:32:27,390 --> 00:32:30,510
doesn't exist in terms of sex machine at

00:32:29,190 --> 00:32:31,920
least doesn't mean your machine doesn't

00:32:30,510 --> 00:32:33,720
have a register it just means that the

00:32:31,920 --> 00:32:35,510
attract machine doesn't doesn't talk

00:32:33,720 --> 00:32:37,650
about it maybe it does maybe it doesn't

00:32:35,510 --> 00:32:39,630
well if you look for the word register

00:32:37,650 --> 00:32:42,120
you'll see the register key word which

00:32:39,630 --> 00:32:45,830
is a used right now we deprecated it's

00:32:42,120 --> 00:32:50,220
older usage and then we removed it and

00:32:45,830 --> 00:32:52,890
I'm sure come back in strength at some

00:32:50,220 --> 00:32:55,650
point once we all accepted the fact that

00:32:52,890 --> 00:32:58,620
scale because it's very nice it's so

00:32:55,650 --> 00:33:00,780
reserved but if you do register in for a

00:32:58,620 --> 00:33:04,710
four loop counter because you're still

00:33:00,780 --> 00:33:06,390
being in the seventies you might have

00:33:04,710 --> 00:33:12,090
some compiler options to set to make it

00:33:06,390 --> 00:33:14,520
work so you give things when an object

00:33:12,090 --> 00:33:17,760
of class type X in releases beautiful

00:33:14,520 --> 00:33:20,160
three is passed to or return from a

00:33:17,760 --> 00:33:21,870
function if each copy constructor remove

00:33:20,160 --> 00:33:25,140
constructor and destructor of X is

00:33:21,870 --> 00:33:27,750
either trigger related and X has at

00:33:25,140 --> 00:33:28,380
least one non deleted copy or move

00:33:27,750 --> 00:33:30,930
Astroturf

00:33:28,380 --> 00:33:32,940
beautiful is it if the way these

00:33:30,930 --> 00:33:34,620
implementations are permitted to create

00:33:32,940 --> 00:33:37,400
a temporary object to hold the function

00:33:34,620 --> 00:33:39,990
parameter or the result of a koala and

00:33:37,400 --> 00:33:41,910
there's their store register in the node

00:33:39,990 --> 00:33:44,610
there's there's one occurrence of the

00:33:41,910 --> 00:33:46,500
word register it says this latitude is

00:33:44,610 --> 00:33:48,060
printed to allow objects of class type

00:33:46,500 --> 00:33:50,010
to be passed to or returned from

00:33:48,060 --> 00:33:51,870
functions and registers but that's what

00:33:50,010 --> 00:33:53,250
we call them non normative notes so it's

00:33:51,870 --> 00:33:56,280
not something that's binding it's an

00:33:53,250 --> 00:33:58,380
explanation so should you be using

00:33:56,280 --> 00:34:00,870
registers well you have leeway there

00:33:58,380 --> 00:34:05,310
we're giving you some space aren't we

00:34:00,870 --> 00:34:07,970
nice so yeah number table participation

00:34:05,310 --> 00:34:07,970
is a part of your rules

00:34:08,500 --> 00:34:13,330
so if you're writing a program and you

00:34:10,810 --> 00:34:16,600
want the correct program you have to

00:34:13,330 --> 00:34:18,810
come from it's important if you rely on

00:34:16,600 --> 00:34:23,200
the patient specific stuff or

00:34:18,810 --> 00:34:25,990
unspecified stuff it's going to work it

00:34:23,200 --> 00:34:27,610
will never be really broken but your

00:34:25,990 --> 00:34:29,649
assumptions might not be met that you

00:34:27,610 --> 00:34:33,340
change compiler version or technology

00:34:29,649 --> 00:34:34,629
even what you do most vendors can be

00:34:33,340 --> 00:34:36,580
expected to be pretty careful

00:34:34,629 --> 00:34:38,550
I guess so they won't break your code

00:34:36,580 --> 00:34:41,440
but they're vegan they will do

00:34:38,550 --> 00:34:44,950
unreasonable things but which you vote

00:34:41,440 --> 00:34:48,040
is that something you can don't write

00:34:44,950 --> 00:34:50,889
life-support system and if you're

00:34:48,040 --> 00:34:54,220
writing define B if you're using code

00:34:50,889 --> 00:34:57,490
you're writing a time bomb but anything

00:34:54,220 --> 00:35:00,760
could happen and you deserve so let's

00:34:57,490 --> 00:35:03,100
this one is a nice one because I use

00:35:00,760 --> 00:35:05,850
that an example last year the class was

00:35:03,100 --> 00:35:09,760
giving a low fuse

00:35:05,850 --> 00:35:11,400
you won't see anything make it bigger

00:35:09,760 --> 00:35:13,930
give me a second

00:35:11,400 --> 00:35:15,580
so I was writing this thing about the

00:35:13,930 --> 00:35:18,190
timing counters because we're discussing

00:35:15,580 --> 00:35:21,750
other things in the class for giving and

00:35:18,190 --> 00:35:23,850
there's threads there that are using in

00:35:21,750 --> 00:35:25,930
concurrently will of synchronization

00:35:23,850 --> 00:35:29,680
incrementing it a number of times like

00:35:25,930 --> 00:35:32,080
this and at the end returning the world

00:35:29,680 --> 00:35:35,350
that the value of n passed the

00:35:32,080 --> 00:35:39,760
implementations so two times the million

00:35:35,350 --> 00:35:46,780
plus plus and the same thing with an

00:35:39,760 --> 00:35:48,220
atomic at the end and people were saying

00:35:46,780 --> 00:35:52,480
well does that really make a difference

00:35:48,220 --> 00:35:56,080
so we checked and if you if you run this

00:35:52,480 --> 00:35:57,940
thing it's funny because you get without

00:35:56,080 --> 00:35:59,740
too much of a surprise on that compiler

00:35:57,940 --> 00:36:04,240
with a raw edge you get the wrong number

00:35:59,740 --> 00:36:07,000
but very fast and and and with the

00:36:04,240 --> 00:36:09,070
atomic int the right number but you paid

00:36:07,000 --> 00:36:10,570
something and the degree to which you

00:36:09,070 --> 00:36:11,680
pay can reframe compiler to compile

00:36:10,570 --> 00:36:12,820
error can be up to ten times or

00:36:11,680 --> 00:36:17,230
something but then we get the wrong

00:36:12,820 --> 00:36:19,450
answer this case and and if someone in

00:36:17,230 --> 00:36:20,560
the room was very very nice came to me

00:36:19,450 --> 00:36:24,400
after class and said

00:36:20,560 --> 00:36:25,030
I tried it and I get the right numbers

00:36:24,400 --> 00:36:28,990
all the time

00:36:25,030 --> 00:36:31,810
I give the right numbers so why should I

00:36:28,990 --> 00:36:34,600
use the tonics and that's very

00:36:31,810 --> 00:36:36,760
interesting and I picked one box in this

00:36:34,600 --> 00:36:38,770
case because it uses a recent GCC and

00:36:36,760 --> 00:36:40,420
it's effectively if you run this code

00:36:38,770 --> 00:36:43,090
it's the same code I didn't show you but

00:36:40,420 --> 00:36:47,950
it's the same same thing called Ryan

00:36:43,090 --> 00:36:50,350
Davis and the exact correct number

00:36:47,950 --> 00:36:51,910
beautiful and you know what the

00:36:50,350 --> 00:36:54,910
differences between these two because I

00:36:51,910 --> 00:36:57,520
have a same source code the second one

00:36:54,910 --> 00:37:01,560
does optimization the first one was that

00:36:57,520 --> 00:37:06,460
optimization level and this one used o

00:37:01,560 --> 00:37:07,870
to so what happens which I think it's a

00:37:06,460 --> 00:37:12,130
beautiful example what we've just been

00:37:07,870 --> 00:37:13,900
saying about UB is that in the first

00:37:12,130 --> 00:37:17,140
case up there we're doing concurrent

00:37:13,900 --> 00:37:19,570
rights to a coming in in two separate

00:37:17,140 --> 00:37:20,470
threads those equations no

00:37:19,570 --> 00:37:23,560
synchronizations

00:37:20,470 --> 00:37:26,280
whatsoever so we get unbidden if i

00:37:23,560 --> 00:37:27,880
behavior we're dealing with broken code

00:37:26,280 --> 00:37:30,970
comparators very nice

00:37:27,880 --> 00:37:37,750
it's guessing what I wanted to do we did

00:37:30,970 --> 00:37:41,080
it I totally correct wrong program it's

00:37:37,750 --> 00:37:42,850
a thing of beauty and it's extremely

00:37:41,080 --> 00:37:45,670
fast so that you could make a point

00:37:42,850 --> 00:37:48,490
saying undefined leaders is tremendous

00:37:45,670 --> 00:37:50,080
it's making my code better or you could

00:37:48,490 --> 00:37:51,820
be surprised and we're in saying can I

00:37:50,080 --> 00:37:54,180
count them that was that right

00:37:51,820 --> 00:37:57,160
assumption probably wasn't in this case

00:37:54,180 --> 00:37:59,350
so in this case probably better paying

00:37:57,160 --> 00:38:02,590
for what you want because you'll get

00:37:59,350 --> 00:38:04,510
more portable results but it's fun

00:38:02,590 --> 00:38:06,460
better to compiler and the way this

00:38:04,510 --> 00:38:11,680
thing's being processed changes

00:38:06,460 --> 00:38:13,630
instructive so yeah

00:38:11,680 --> 00:38:16,390
the difference in the results wire were

00:38:13,630 --> 00:38:18,550
the atomic writes slower because the

00:38:16,390 --> 00:38:20,560
included synchronization takes something

00:38:18,550 --> 00:38:21,520
and if you want to have very fast

00:38:20,560 --> 00:38:24,040
correct program

00:38:21,520 --> 00:38:25,780
don't use shared state incremental

00:38:24,040 --> 00:38:28,930
convertibles and add them to your show

00:38:25,780 --> 00:38:30,520
state at the end much faster so if you

00:38:28,930 --> 00:38:31,060
use the higher optimization level like I

00:38:30,520 --> 00:38:34,250
just did

00:38:31,060 --> 00:38:35,810
your results will vary if you use

00:38:34,250 --> 00:38:37,340
as for other this right thing if you use

00:38:35,810 --> 00:38:39,980
the mix of compiler here you get a very

00:38:37,340 --> 00:38:41,860
fast wrong program if you use clang or

00:38:39,980 --> 00:38:44,000
GCC you'll get a very fast

00:38:41,860 --> 00:38:46,490
apparently correct but totally broken

00:38:44,000 --> 00:38:50,050
program it's broken in all cases in one

00:38:46,490 --> 00:38:50,050
case it shows in the others it's hidden

00:38:51,310 --> 00:38:56,660
so yeah the code is very very bad and as

00:38:54,440 --> 00:38:58,370
I said don't use shared state until the

00:38:56,660 --> 00:39:02,570
very end and then write to it only if

00:38:58,370 --> 00:39:04,910
you really need to so honest

00:39:02,570 --> 00:39:06,410
under this impact what we do with the

00:39:04,910 --> 00:39:09,020
standard and with the language I know

00:39:06,410 --> 00:39:10,790
that because it's me I have another talk

00:39:09,020 --> 00:39:12,260
tomorrow where I'm going to talk about

00:39:10,790 --> 00:39:14,690
something at work he had been working on

00:39:12,260 --> 00:39:17,480
for a few years now and I have a feature

00:39:14,690 --> 00:39:20,090
that my users need and that just doesn't

00:39:17,480 --> 00:39:22,430
fit they want to specify the stack size

00:39:20,090 --> 00:39:25,400
of their threads it's hard to do we

00:39:22,430 --> 00:39:28,160
don't have a stack so we have to find a

00:39:25,400 --> 00:39:29,930
way to see what the user wants without

00:39:28,160 --> 00:39:31,460
polluting the standard with things that

00:39:29,930 --> 00:39:32,810
the standard doesn't need because it

00:39:31,460 --> 00:39:34,940
would be harmful to things that such as

00:39:32,810 --> 00:39:37,160
cool routines that we don't need it so

00:39:34,940 --> 00:39:40,010
should you want to write your own

00:39:37,160 --> 00:39:42,610
proposal for a standard considering

00:39:40,010 --> 00:39:45,710
which we've just been skimming through

00:39:42,610 --> 00:39:47,210
well the one of things that you can do

00:39:45,710 --> 00:39:48,590
is risk being three restricting yourself

00:39:47,210 --> 00:39:50,150
to features that are actually part of

00:39:48,590 --> 00:39:53,420
the language so if you're saying I'm

00:39:50,150 --> 00:39:55,610
going to make registers access much

00:39:53,420 --> 00:40:01,910
faster you're probably better off

00:39:55,610 --> 00:40:03,400
talking to your vendor we're going to do

00:40:01,910 --> 00:40:06,200
everything we can not to be in the way

00:40:03,400 --> 00:40:08,900
but we are not considering what your

00:40:06,200 --> 00:40:11,720
specific architecture is doing it's none

00:40:08,900 --> 00:40:14,180
of our business rate our job is to that

00:40:11,720 --> 00:40:17,960
the vendors right the biscuit batters

00:40:14,180 --> 00:40:19,490
they can and should you want as I said

00:40:17,960 --> 00:40:21,710
to add something it doesn't fit really

00:40:19,490 --> 00:40:24,200
really well it's trickier because you

00:40:21,710 --> 00:40:26,390
have to find an abstraction that's that

00:40:24,200 --> 00:40:29,410
hides this in a way such that the

00:40:26,390 --> 00:40:32,000
standard remains clean at least of such

00:40:29,410 --> 00:40:34,520
considerations that are not that would

00:40:32,000 --> 00:40:35,150
not be in the right place and yet just

00:40:34,520 --> 00:40:37,370
yourself

00:40:35,150 --> 00:40:39,410
we did that something if you really want

00:40:37,370 --> 00:40:41,450
to speak about a hardware register in

00:40:39,410 --> 00:40:43,460
the standard will simply be better after

00:40:41,450 --> 00:40:45,170
that unless you have a very consumer

00:40:43,460 --> 00:40:46,400
convincing argument to the effect people

00:40:45,170 --> 00:40:48,830
probably say no

00:40:46,400 --> 00:40:50,680
and it won't pass and then you probably

00:40:48,830 --> 00:40:52,790
be thinking well there are idiots

00:40:50,680 --> 00:40:54,710
because of course it one knows that

00:40:52,790 --> 00:40:56,530
should your proposal not passes because

00:40:54,710 --> 00:41:00,830
everyone in the standard is an idiot

00:40:56,530 --> 00:41:03,980
which which I can confidently say it's

00:41:00,830 --> 00:41:08,030
not true these people actually pretty

00:41:03,980 --> 00:41:09,710
bright so for those who are interested

00:41:08,030 --> 00:41:11,500
in we didn't know but then there's less

00:41:09,710 --> 00:41:14,630
and less people don't know about them

00:41:11,500 --> 00:41:17,300
for the comparisons I did not good bolts

00:41:14,630 --> 00:41:19,100
to is amazing for the benchmark it's

00:41:17,300 --> 00:41:22,160
much younger but spherical fed stuff is

00:41:19,100 --> 00:41:23,510
very very cool and Tim songs think to

00:41:22,160 --> 00:41:26,330
explore a standard even though I didn't

00:41:23,510 --> 00:41:28,340
link to it with the slides because my

00:41:26,330 --> 00:41:30,530
interrogation is that it's actually

00:41:28,340 --> 00:41:31,940
lovely and you can actually count on it

00:41:30,530 --> 00:41:33,890
because it's officially supported so

00:41:31,940 --> 00:41:36,290
really really nice if you want to go to

00:41:33,890 --> 00:41:38,120
standard yourself or look at specific

00:41:36,290 --> 00:41:41,960
parts of it it does highlighting and

00:41:38,120 --> 00:41:44,960
everything is very cool so I used for my

00:41:41,960 --> 00:41:46,190
post the standard from February the most

00:41:44,960 --> 00:41:50,300
important one should there be

00:41:46,190 --> 00:41:52,670
discrepancies there my fault the

00:41:50,300 --> 00:41:55,460
articles that I used as reference or as

00:41:52,670 --> 00:41:59,540
quotes are also in there

00:41:55,460 --> 00:42:02,200
interesting so that the talk by Lisa is

00:41:59,540 --> 00:42:04,730
there I strongly urge you to read it

00:42:02,200 --> 00:42:06,110
personally and I have my website which

00:42:04,730 --> 00:42:08,210
is all established in France in French

00:42:06,110 --> 00:42:10,070
so somebody will say yeah

00:42:08,210 --> 00:42:14,300
most of you will react like that will

00:42:10,070 --> 00:42:20,440
react to the color scheme sorry I don't

00:42:14,300 --> 00:42:20,440
see colors all that well so they're okay

00:42:25,900 --> 00:42:31,999
didn't make any sense

00:42:28,420 --> 00:42:43,069
sure questions

00:42:31,999 --> 00:42:46,190
goodness threats and so in a

00:42:43,069 --> 00:42:49,279
hypothetical universe where yeah where I

00:42:46,190 --> 00:42:52,009
actually have a compiler that's giving

00:42:49,279 --> 00:42:54,890
me a bite that is not eight bits oh

00:42:52,009 --> 00:42:56,630
there are many there are yeah if you go

00:42:54,890 --> 00:42:57,109
to DSPs and other stuff you'll get many

00:42:56,630 --> 00:42:59,509
of that

00:42:57,109 --> 00:43:00,920
yeah you know if you're using general

00:42:59,509 --> 00:43:02,839
purpose hardware you're running line

00:43:00,920 --> 00:43:04,279
next probably won't meet them but yet

00:43:02,839 --> 00:43:06,049
you're using specific hardware there are

00:43:04,279 --> 00:43:10,869
a number of these how do you deal with

00:43:06,049 --> 00:43:13,910
that like as a as a programmer there's a

00:43:10,869 --> 00:43:16,009
different tell you there's char bits you

00:43:13,910 --> 00:43:17,180
can limits that H or its limits if you

00:43:16,009 --> 00:43:18,799
write C cluster that tells you have been

00:43:17,180 --> 00:43:21,650
a bit sir and the charms well we have a

00:43:18,799 --> 00:43:24,200
macro for that if this was a fixed thing

00:43:21,650 --> 00:43:27,950
if you in C++ you can use numeric limits

00:43:24,200 --> 00:43:29,630
unsigned char : : digits you want to use

00:43:27,950 --> 00:43:31,309
the unsigned one because the sign one

00:43:29,630 --> 00:43:35,319
will not count the sign bits and you'll

00:43:31,309 --> 00:43:39,469
get surprised you get an odd number that

00:43:35,319 --> 00:43:40,880
would be surprising ideas so the short

00:43:39,469 --> 00:43:42,559
answer to your question is most of the

00:43:40,880 --> 00:43:43,849
software addition you would try to use

00:43:42,559 --> 00:43:46,009
that it's not a word that would probably

00:43:43,849 --> 00:43:49,299
be broken due to the wrong assumptions

00:43:46,009 --> 00:43:51,799
let's say well everyone knows that

00:43:49,299 --> 00:43:56,269
ensures are four bytes everyone knows

00:43:51,799 --> 00:43:57,619
that so I it's my home that if you're

00:43:56,269 --> 00:43:59,989
getting out of this room and you don't

00:43:57,619 --> 00:44:01,729
write starter broken software the whole

00:43:59,989 --> 00:44:07,160
world will benefit from this that

00:44:01,729 --> 00:44:08,390
doesn't mean you should you should at

00:44:07,160 --> 00:44:14,259
least tell them with set against at

00:44:08,390 --> 00:44:16,819
first so given that I can only count on

00:44:14,259 --> 00:44:19,749
observable the observable behavior it's

00:44:16,819 --> 00:44:21,680
actually happening my program and

00:44:19,749 --> 00:44:24,559
something that otherwise would look like

00:44:21,680 --> 00:44:26,690
a dead store to memory happens to be

00:44:24,559 --> 00:44:28,640
into a memory mapped file should I

00:44:26,690 --> 00:44:34,210
always access my memory mapped files to

00:44:28,640 --> 00:44:34,210
pointers to volatile it's probably

00:44:34,670 --> 00:44:37,790
question you probably have to look at

00:44:36,200 --> 00:44:39,110
what your vendors providing because

00:44:37,790 --> 00:44:40,940
memory-mapped files are outside of the

00:44:39,110 --> 00:44:42,590
scope and standard - we don't have any

00:44:40,940 --> 00:44:45,620
standard ones why we're not that fools

00:44:42,590 --> 00:44:48,770
for them compilers will be sometimes

00:44:45,620 --> 00:44:50,630
stricter as to what the rules are so for

00:44:48,770 --> 00:44:52,490
their given platform so the volatile

00:44:50,630 --> 00:44:54,350
rules for Microsoft for example were

00:44:52,490 --> 00:44:59,060
traditionally more stringent than what

00:44:54,350 --> 00:45:00,740
the standard should said it's very much

00:44:59,060 --> 00:45:03,140
under specified right now it's hard to

00:45:00,740 --> 00:45:04,400
use properly so what you should check is

00:45:03,140 --> 00:45:05,630
what your lender is providing for that's

00:45:04,400 --> 00:45:07,460
to stick to all and make sure that

00:45:05,630 --> 00:45:11,060
you're following the rules for that

00:45:07,460 --> 00:45:13,400
because until we have STD kong-kong

00:45:11,060 --> 00:45:22,010
memory-mapped file it's hard to answer

00:45:13,400 --> 00:45:25,160
that question problem yeah in your

00:45:22,010 --> 00:45:27,320
example you you told us that somebody

00:45:25,160 --> 00:45:29,590
was using a new fan behavior but the

00:45:27,320 --> 00:45:32,300
compiler detected what it's supposed to

00:45:29,590 --> 00:45:35,240
developer meant and that's something

00:45:32,300 --> 00:45:37,250
that kind of worked I'm a bit scared

00:45:35,240 --> 00:45:39,170
when my compiler tries to determine when

00:45:37,250 --> 00:45:40,760
I meant I mean I've been in HTML

00:45:39,170 --> 00:45:42,170
developer in the past and I all know

00:45:40,760 --> 00:45:43,520
that all problems come back from the

00:45:42,170 --> 00:45:48,380
fact that when you forget to close a

00:45:43,520 --> 00:45:50,300
racket it just tries to guess what you

00:45:48,380 --> 00:45:52,280
wanted wouldn't it be better if you eat

00:45:50,300 --> 00:45:54,950
just through a warning or an error or

00:45:52,280 --> 00:46:08,000
just refuse compiler why are we even

00:45:54,950 --> 00:46:10,040
doing that there are probably compare

00:46:08,000 --> 00:46:12,050
settings that you can check because it's

00:46:10,040 --> 00:46:13,910
a per vendor can I think you know what

00:46:12,050 --> 00:46:17,290
we since then it is we won't say

00:46:13,910 --> 00:46:17,290
anything about your program you're dead

00:46:23,170 --> 00:46:27,590
another thing you try it it's you want

00:46:26,120 --> 00:46:29,720
to try it you do some sector functions

00:46:27,590 --> 00:46:32,480
because you're not allowed to use and

00:46:29,720 --> 00:46:34,280
find the original secret functions so at

00:46:32,480 --> 00:46:35,510
least this will reveal some things that

00:46:34,280 --> 00:46:37,430
might not have been read a lot of why's

00:46:35,510 --> 00:46:39,350
that being said they're not all as

00:46:37,430 --> 00:46:40,880
strict as they should be with that but

00:46:39,350 --> 00:46:42,620
should they want to be if you're using

00:46:40,880 --> 00:46:44,640
unsigned given context of functions that

00:46:42,620 --> 00:46:49,289
supposed to compile

00:46:44,640 --> 00:46:52,890
that may be nice alright so this is more

00:46:49,289 --> 00:46:55,950
of a comment yeah so for example when

00:46:52,890 --> 00:46:57,690
you were talking about CC well dunno re

00:46:55,950 --> 00:47:00,150
checking for you but you also said that

00:46:57,690 --> 00:47:02,130
you can do that yourself and I have a

00:47:00,150 --> 00:47:04,559
comment about that that if you think

00:47:02,130 --> 00:47:06,779
that in general C++ doesn't have enough

00:47:04,559 --> 00:47:08,670
defined behavior well you can use a

00:47:06,779 --> 00:47:12,480
library that defines it for you if

00:47:08,670 --> 00:47:14,730
you're annoyed that int does not

00:47:12,480 --> 00:47:17,970
guarantee anything on overflow you can

00:47:14,730 --> 00:47:20,760
make your own integer type which throws

00:47:17,970 --> 00:47:23,760
an exception raps as if it was just

00:47:20,760 --> 00:47:26,670
complement and you know you can get

00:47:23,760 --> 00:47:29,190
basically Java and C++ if you just

00:47:26,670 --> 00:47:31,650
rewrite all the behavior of the java

00:47:29,190 --> 00:47:35,160
virtual machine on those things so

00:47:31,650 --> 00:47:37,380
really some people would like to see all

00:47:35,160 --> 00:47:39,660
undefined behavior gone from the C++

00:47:37,380 --> 00:47:41,819
standard but if you have a behavior that

00:47:39,660 --> 00:47:44,549
works well for your platform well do

00:47:41,819 --> 00:47:49,319
that instead of using the abstract

00:47:44,549 --> 00:47:52,079
machine so of course but we do have a

00:47:49,319 --> 00:47:53,400
study group in g12 that works on and if

00:47:52,079 --> 00:47:57,059
I'm behavior right now and it's trying

00:47:53,400 --> 00:47:59,099
to reduce the cases where it appears so

00:47:57,059 --> 00:48:01,349
there are things where they were always

00:47:59,099 --> 00:48:04,920
be some ideas but we are working on

00:48:01,349 --> 00:48:09,329
reducing them such things as doing a mem

00:48:04,920 --> 00:48:11,190
copy to some storage which could be

00:48:09,329 --> 00:48:13,410
undefined but could I show get birth to

00:48:11,190 --> 00:48:15,869
an object say some casts which are

00:48:13,410 --> 00:48:18,089
improper but kind of make sense to

00:48:15,869 --> 00:48:19,680
programmers why not give them a meaning

00:48:18,089 --> 00:48:22,859
there are things we can do with that as

00:48:19,680 --> 00:48:24,599
we're saying indeed you given that we

00:48:22,859 --> 00:48:26,640
have a language that lets us do if we

00:48:24,599 --> 00:48:29,160
want to zero cost abstractions we can

00:48:26,640 --> 00:48:30,599
actually use it why not there are people

00:48:29,160 --> 00:48:32,339
in the room right now we're working on

00:48:30,599 --> 00:48:33,869
floating a fixpoint numbers and doing

00:48:32,339 --> 00:48:36,119
very efficient stuff and defining

00:48:33,869 --> 00:48:37,230
behavior as much as they can if you want

00:48:36,119 --> 00:48:38,490
exceptions all over the place the thing

00:48:37,230 --> 00:48:41,069
is stuffing you of course you can use

00:48:38,490 --> 00:48:44,250
vector at if you're a very strange

00:48:41,069 --> 00:48:45,630
person or you can actually use the tools

00:48:44,250 --> 00:48:47,069
that well remove that for you using the

00:48:45,630 --> 00:48:48,660
range for loops and everything they will

00:48:47,069 --> 00:48:50,299
probably move out those birds from your

00:48:48,660 --> 00:48:52,950
code in first place but in supposed us

00:48:50,299 --> 00:48:54,839
really reduces the number of cases you

00:48:52,950 --> 00:48:56,190
have to look out for so yeah I agree

00:48:54,839 --> 00:48:57,940
with you library solutions are probably

00:48:56,190 --> 00:48:59,200
better than yachine I

00:48:57,940 --> 00:49:01,569
I doubt we will change the exact machine

00:48:59,200 --> 00:49:02,890
to please those people it would be

00:49:01,569 --> 00:49:06,420
counterproductive from the thickest

00:49:02,890 --> 00:49:06,420
possible integer all right

00:49:11,660 --> 00:49:17,949

YouTube URL: https://www.youtube.com/watch?v=KoqY50HSuQg


