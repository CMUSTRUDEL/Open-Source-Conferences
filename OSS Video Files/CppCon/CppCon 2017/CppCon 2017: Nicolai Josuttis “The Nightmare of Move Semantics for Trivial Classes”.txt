Title: CppCon 2017: Nicolai Josuttis “The Nightmare of Move Semantics for Trivial Classes”
Publication date: 2017-10-12
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Assume, we implement a very simple class having just multiple string members. Even ordinary application programmer prefer to make it simple and fast. 

You think you know how to do it? Well beware! It can become a lot harder than you initially might assume. 

So, let’s look at a trivial class with multiple string members and use live coding to see the effect using different implementation approaches (using constructors passing by value, by reference, by perfect forwarding, or doing more sophisticated tricks). 

Sooner than later we will fall into the deep darkness of universal/forwarding references, enable_if, type traits, and concepts.
— 
Nicolai Josuttis: IT Communication

Nicolai Josuttis (http://www.josuttis.com) is an independent system architect, technical manager, author, and consultant. He designs mid-sized and large software systems for the telecommunications, traffic, finance, and manufacturing industries.

He is well known in the programming community because he not only speaks and writes with authority (being the (co-)author of the world-wide best sellers The C++ Standard Library (www.cppstdlib.com), C++ Templates, and SOA in Practice), but is also an innovative presenter, having talked at various conferences and events.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,269 --> 00:00:06,750
my name is Nikolai Azotus you might not

00:00:04,020 --> 00:00:09,630
know my name very well but you might

00:00:06,750 --> 00:00:11,550
know my books a little bit of them

00:00:09,630 --> 00:00:16,740
actually at least well let me see my

00:00:11,550 --> 00:00:19,710
focus is not where it should be so I'm

00:00:16,740 --> 00:00:22,859
an author of a couple of books about

00:00:19,710 --> 00:00:25,230
template standard library etc and there

00:00:22,859 --> 00:00:29,939
are some new books about templates and

00:00:25,230 --> 00:00:31,980
c++ 17 and i should point out that i

00:00:29,939 --> 00:00:35,610
always write because I don't understand

00:00:31,980 --> 00:00:37,829
C++ and I need a book to explain it to

00:00:35,610 --> 00:00:39,360
me again and again and again because I

00:00:37,829 --> 00:00:41,309
forget everything and everything gets

00:00:39,360 --> 00:00:45,690
crazy and more crazy and even crazier

00:00:41,309 --> 00:00:47,219
and this is what the talk is about the

00:00:45,690 --> 00:00:51,410
talk is about the problem

00:00:47,219 --> 00:00:54,449
an ordinary stupid maybe naive

00:00:51,410 --> 00:00:57,680
application programmer has when they

00:00:54,449 --> 00:01:02,100
want to write is pretty simple class

00:00:57,680 --> 00:01:06,540
just having two strings and make it

00:01:02,100 --> 00:01:10,380
perfect here's the class I want to write

00:01:06,540 --> 00:01:13,710
with you together the class is a class

00:01:10,380 --> 00:01:17,280
customer with three members a first name

00:01:13,710 --> 00:01:20,369
a last name and an ID and the first name

00:01:17,280 --> 00:01:24,509
in the last names are strings so what's

00:01:20,369 --> 00:01:28,320
a problem here well first of all we need

00:01:24,509 --> 00:01:30,990
a constructor and I will only talk about

00:01:28,320 --> 00:01:35,189
this constructor the whole hour nothing

00:01:30,990 --> 00:01:41,100
else and the problem with this

00:01:35,189 --> 00:01:44,070
constructor is it was not obvious we do

00:01:41,100 --> 00:01:47,430
it the way we learned it so we take a

00:01:44,070 --> 00:01:49,380
con string reference because we don't

00:01:47,430 --> 00:01:51,060
want a copy the string when it gets

00:01:49,380 --> 00:01:53,880
passed because copying a string is

00:01:51,060 --> 00:01:56,070
pretty expensive so we take them by

00:01:53,880 --> 00:01:57,689
reference and by the way the second and

00:01:56,070 --> 00:01:59,820
the third argument have default

00:01:57,689 --> 00:02:02,100
arguments that we can pass on the one

00:01:59,820 --> 00:02:06,860
string and we initialize first name last

00:02:02,100 --> 00:02:10,319
name and ID by the past arguments so I

00:02:06,860 --> 00:02:13,520
want to create a customer see initialize

00:02:10,319 --> 00:02:15,680
with two string literals and an integer

00:02:13,520 --> 00:02:16,850
and here's my first question to you for

00:02:15,680 --> 00:02:19,520
the morning to wake up

00:02:16,850 --> 00:02:24,740
how many expensive string calls are done

00:02:19,520 --> 00:02:28,960
here I mean how often do I copy or copy

00:02:24,740 --> 00:02:32,300
assign a string and with listen may lock

00:02:28,960 --> 00:02:36,100
unless we have short string optimization

00:02:32,300 --> 00:02:40,720
so it's a potential expensive operation

00:02:36,100 --> 00:02:45,890
think about you have your number okay

00:02:40,720 --> 00:02:50,840
let's see in the program somewhere we

00:02:45,890 --> 00:02:54,320
have the two literals Joe and fix their

00:02:50,840 --> 00:02:57,470
arguments expect a string so we have to

00:02:54,320 --> 00:02:59,750
create two strings to be able to pass

00:02:57,470 --> 00:03:01,430
them by reference so that means we

00:02:59,750 --> 00:03:03,320
create two strings and that means we

00:03:01,430 --> 00:03:05,750
have the first Maalox unless we have

00:03:03,320 --> 00:03:07,520
short string optimization so assume for

00:03:05,750 --> 00:03:09,650
the moment these are strings with more

00:03:07,520 --> 00:03:10,580
than 15 characters then you have always

00:03:09,650 --> 00:03:15,560
a problem

00:03:10,580 --> 00:03:18,140
and now let's we have first the first

00:03:15,560 --> 00:03:20,390
and the second argument and now we have

00:03:18,140 --> 00:03:23,960
to initialize first and last and because

00:03:20,390 --> 00:03:27,440
we pass by a constant reference they are

00:03:23,960 --> 00:03:32,300
copied again to create our final object

00:03:27,440 --> 00:03:36,860
and the initial temporary F and L would

00:03:32,300 --> 00:03:41,090
get distracted okay you probably know

00:03:36,860 --> 00:03:45,800
that maybe all of you so we have form

00:03:41,090 --> 00:03:48,770
Alex or for potential Mel's too because

00:03:45,800 --> 00:03:52,310
we create the temporaries too because we

00:03:48,770 --> 00:03:56,810
copy them to the members of the customer

00:03:52,310 --> 00:03:57,770
class so we are we have C++ we want to

00:03:56,810 --> 00:04:00,560
make it perfect

00:03:57,770 --> 00:04:02,930
sometimes performance matters so the

00:04:00,560 --> 00:04:07,130
question is how can we make this perfect

00:04:02,930 --> 00:04:09,830
how can we improve things so first of

00:04:07,130 --> 00:04:11,150
all what we have done before we went

00:04:09,830 --> 00:04:13,970
into C++ 11

00:04:11,150 --> 00:04:18,020
we usually overloaded for Khan's

00:04:13,970 --> 00:04:21,410
character star so because then we can

00:04:18,020 --> 00:04:24,110
directly take an address of a string

00:04:21,410 --> 00:04:26,790
literal as an argument and directly

00:04:24,110 --> 00:04:31,800
initialize the members by

00:04:26,790 --> 00:04:36,380
we passed pointers so we save two melons

00:04:31,800 --> 00:04:36,380
to Malick's only to creates we have here

00:04:37,490 --> 00:04:45,720
let's create a string and pass a string

00:04:40,590 --> 00:04:49,230
and string that all Oh too bad because

00:04:45,720 --> 00:04:50,970
now only the first French mattress so we

00:04:49,230 --> 00:04:54,270
have three Maalox and one of it is not

00:04:50,970 --> 00:04:57,600
necessary yeah because we have the

00:04:54,270 --> 00:05:00,000
initial problem again and so of course

00:04:57,600 --> 00:05:03,780
we overload for all four functions for

00:05:00,000 --> 00:05:06,710
all four combinations and that's what we

00:05:03,780 --> 00:05:15,810
do if we want to make it perfect in C++

00:05:06,710 --> 00:05:19,260
well three and ninety eight good now we

00:05:15,810 --> 00:05:22,440
have move semantics so what happens if

00:05:19,260 --> 00:05:24,960
we move so we don't no longer need the

00:05:22,440 --> 00:05:32,000
string s here so I want to move it into

00:05:24,960 --> 00:05:32,000
the created object how many minutes -

00:05:34,340 --> 00:05:41,760
because that's a move support in the

00:05:37,950 --> 00:05:49,470
constructor of the string class so we

00:05:41,760 --> 00:05:53,670
create a copy when we initialize it so

00:05:49,470 --> 00:05:56,940
that means yes we we pass it to the

00:05:53,670 --> 00:05:59,970
parameter F but when taking F to

00:05:56,940 --> 00:06:02,760
initialize first we create a copy and we

00:05:59,970 --> 00:06:07,380
the second copy is for creating the

00:06:02,760 --> 00:06:09,590
temporary which is not good well not

00:06:07,380 --> 00:06:15,150
perfect I should say it's usually fine

00:06:09,590 --> 00:06:18,990
so how can we make this perfect overload

00:06:15,150 --> 00:06:24,930
for an r-value reference so use move

00:06:18,990 --> 00:06:26,220
semantics in the constructor okay let's

00:06:24,930 --> 00:06:29,580
do that

00:06:26,220 --> 00:06:32,280
let's overload for an l-value reference

00:06:29,580 --> 00:06:37,220
and constant L value reference for all

00:06:32,280 --> 00:06:40,340
the places where we where we don't need

00:06:37,220 --> 00:06:43,020
move semantics and let's use another

00:06:40,340 --> 00:06:47,490
your reference form of semantics and by

00:06:43,020 --> 00:06:50,370
the way move Simon discovers both move l

00:06:47,490 --> 00:06:53,550
value so move existing objects with name

00:06:50,370 --> 00:06:56,880
and temporary so a string literal will

00:06:53,550 --> 00:06:59,940
be covered by that so we don't need the

00:06:56,880 --> 00:07:05,630
cons character star overload for the

00:06:59,940 --> 00:07:09,600
moment so when we have now our initial

00:07:05,630 --> 00:07:11,370
our creation of a customer C and we have

00:07:09,600 --> 00:07:16,680
our string literals somewhere in the

00:07:11,370 --> 00:07:21,420
program we create F and L we call the

00:07:16,680 --> 00:07:24,030
second constructor so we create and a

00:07:21,420 --> 00:07:27,660
string we still need a string but this

00:07:24,030 --> 00:07:29,640
string is a temporary and the good thing

00:07:27,660 --> 00:07:32,940
with a shrimper re when we have move

00:07:29,640 --> 00:07:37,020
semantics we can steal the value so what

00:07:32,940 --> 00:07:42,080
happened here is when we then initialize

00:07:37,020 --> 00:07:48,169
the string we steal the heap memory of

00:07:42,080 --> 00:07:53,640
Joe and we steal the heap memory of fix

00:07:48,169 --> 00:07:55,800
which means to Maalox only because we

00:07:53,640 --> 00:08:02,790
still create temporaries but copying

00:07:55,800 --> 00:08:05,850
them got cheap that's our final object

00:08:02,790 --> 00:08:09,020
and we create the temp if we delete the

00:08:05,850 --> 00:08:14,870
temporaries we just practice temporaries

00:08:09,020 --> 00:08:17,430
so we have to Maalox here too to create

00:08:14,870 --> 00:08:20,400
the temporary and then we steal the

00:08:17,430 --> 00:08:23,190
memory so we move the strings and move

00:08:20,400 --> 00:08:27,630
is pretty cheap it's not perfectly cheap

00:08:23,190 --> 00:08:31,440
but it's it's fine okay so of course

00:08:27,630 --> 00:08:35,789
again we need all the overloads for all

00:08:31,440 --> 00:08:38,580
combinations so here are some other

00:08:35,789 --> 00:08:39,830
examples of that for example if we pass

00:08:38,580 --> 00:08:43,100
the string

00:08:39,830 --> 00:08:47,030
String little we have not three but two

00:08:43,100 --> 00:08:49,280
Maalox and with move semantics we have

00:08:47,030 --> 00:08:57,140
now one may lock and that's that's

00:08:49,280 --> 00:09:02,510
almost perfect ten minutes gone and I've

00:08:57,140 --> 00:09:12,730
explained C++ it's easy let's just do it

00:09:02,510 --> 00:09:12,730
oh let's pass only one argument

00:09:14,320 --> 00:09:27,320
it doesn't compile you know what you

00:09:17,840 --> 00:09:31,040
know why we have too many default values

00:09:27,320 --> 00:09:33,920
in our constructors we blindly copied

00:09:31,040 --> 00:09:37,130
all the defaults and that means for

00:09:33,920 --> 00:09:43,010
customer F we now have two matching

00:09:37,130 --> 00:09:53,060
constructors which is the second and the

00:09:43,010 --> 00:09:56,450
last oops I'm one too far both match so

00:09:53,060 --> 00:10:00,860
if we overload for all these versions

00:09:56,450 --> 00:10:03,170
and you have default arguments be sure

00:10:00,860 --> 00:10:05,270
that you have the default arguments for

00:10:03,170 --> 00:10:10,130
only one combination and not to make

00:10:05,270 --> 00:10:12,320
things and biggest okay so let's remove

00:10:10,130 --> 00:10:15,260
some default arguments where we don't

00:10:12,320 --> 00:10:17,480
need them let's for example choose the

00:10:15,260 --> 00:10:25,970
default arguments to be used only when

00:10:17,480 --> 00:10:28,480
we have other your references let's try

00:10:25,970 --> 00:10:31,480
out something different let's use copy

00:10:28,480 --> 00:10:31,480
initialization

00:10:32,620 --> 00:10:37,300
this does not compile and by the way it

00:10:35,140 --> 00:10:43,240
never compiled in any of the versions I

00:10:37,300 --> 00:10:45,610
showed you which is surprising I mean I

00:10:43,240 --> 00:10:51,940
create a customer customer I can take a

00:10:45,610 --> 00:10:55,090
string and I pass a nickel and it

00:10:51,940 --> 00:10:57,220
doesn't work and this in general is a

00:10:55,090 --> 00:10:59,320
problem this is a problem we have inner

00:10:57,220 --> 00:11:02,350
nd in the language because here we have

00:10:59,320 --> 00:11:04,930
two user device we find conversions so

00:11:02,350 --> 00:11:06,600
we first convert the string a little to

00:11:04,930 --> 00:11:09,160
an string using a user-defined

00:11:06,600 --> 00:11:11,980
constructor the library counts as user

00:11:09,160 --> 00:11:14,230
defined here and then we convert the

00:11:11,980 --> 00:11:19,750
string the resulting temporary string to

00:11:14,230 --> 00:11:21,250
a customer so this does not compile what

00:11:19,750 --> 00:11:30,490
you see here that's a reason and that

00:11:21,250 --> 00:11:34,720
has always been the case in C++ so what

00:11:30,490 --> 00:11:40,680
can we do with that oh it seems we still

00:11:34,720 --> 00:11:40,680
need our cons character star overloads

00:11:41,160 --> 00:11:46,540
and of course all the combinations well

00:11:44,740 --> 00:11:49,240
strictly speaking we don't need all the

00:11:46,540 --> 00:11:51,750
combinations because this problem with G

00:11:49,240 --> 00:11:55,900
can only apply to the first argument

00:11:51,750 --> 00:11:58,450
because initial a copy initialization

00:11:55,900 --> 00:12:01,330
without list initialize new so with our

00:11:58,450 --> 00:12:04,720
curly braces is only possible with one

00:12:01,330 --> 00:12:07,510
argument but not to make it too

00:12:04,720 --> 00:12:14,350
complicated let's overload all nine

00:12:07,510 --> 00:12:16,480
combinations you like C++ don't you and

00:12:14,350 --> 00:12:23,830
beware that you make the default

00:12:16,480 --> 00:12:27,100
arguments right to wide ambiguities to

00:12:23,830 --> 00:12:30,100
Malick's here the good thing is we now

00:12:27,100 --> 00:12:32,320
have make it a little bit better because

00:12:30,100 --> 00:12:34,990
we don't have moves any more involved

00:12:32,320 --> 00:12:37,530
when we pass to string literals because

00:12:34,990 --> 00:12:40,300
we have not dead constructors taking the

00:12:37,530 --> 00:12:43,930
pointers directly so we have to

00:12:40,300 --> 00:12:45,860
varrick's here to Maalox here one malloc

00:12:43,930 --> 00:12:48,380
here and that is by the way

00:12:45,860 --> 00:12:52,550
that is perfect it can't become better

00:12:48,380 --> 00:12:55,130
because we create three things we pass

00:12:52,550 --> 00:12:58,100
five string littles so we had eight five

00:12:55,130 --> 00:13:07,040
creates and we pass one string which we

00:12:58,100 --> 00:13:09,950
move it can't become better we should

00:13:07,040 --> 00:13:14,959
sort at least talk about passing by

00:13:09,950 --> 00:13:17,089
value because all this trouble is this

00:13:14,959 --> 00:13:20,930
driven by the fact that we that we pass

00:13:17,089 --> 00:13:24,339
by reference and how many of the

00:13:20,930 --> 00:13:28,399
problems here can be avoided by taking

00:13:24,339 --> 00:13:37,790
the arguments by value ooh by value it's

00:13:28,399 --> 00:13:39,860
dream let's see well first of all we

00:13:37,790 --> 00:13:42,260
still have the problem with the two

00:13:39,860 --> 00:13:42,890
user-defined convergence so let's make

00:13:42,260 --> 00:13:46,910
it correct

00:13:42,890 --> 00:13:49,940
let's add it let's add this add this

00:13:46,910 --> 00:13:55,640
additional single constructor taking a

00:13:49,940 --> 00:14:00,199
cons character sir now let's count and

00:13:55,640 --> 00:14:06,760
see what happens first constructor has

00:14:00,199 --> 00:14:09,589
form Alex that's not good but it works

00:14:06,760 --> 00:14:12,260
because we create the strings and

00:14:09,589 --> 00:14:15,110
because we have by value we don't have

00:14:12,260 --> 00:14:20,240
references we pass them to get copied to

00:14:15,110 --> 00:14:22,100
first and last to the members we have

00:14:20,240 --> 00:14:25,160
the same problem here

00:14:22,100 --> 00:14:27,829
and the same problem here so these are

00:14:25,160 --> 00:14:30,230
eleven Malick's that's a lot worse than

00:14:27,829 --> 00:14:35,209
the optimal perfect version of five

00:14:30,230 --> 00:14:41,329
having five for these recalls so what is

00:14:35,209 --> 00:14:44,089
the fix what is the fix move yes

00:14:41,329 --> 00:14:46,279
move the temporaries into the members

00:14:44,089 --> 00:14:49,459
because you create them and you pass

00:14:46,279 --> 00:14:52,510
them so move them to the member because

00:14:49,459 --> 00:14:52,510
we don't need that anymore

00:14:52,750 --> 00:15:03,579
and now what does that mean to my Luck's

00:14:57,879 --> 00:15:06,670
here because we we create two strings by

00:15:03,579 --> 00:15:12,129
well be creative a new value string here

00:15:06,670 --> 00:15:16,300
and then we move this temporary F and L

00:15:12,129 --> 00:15:20,290
or this argument I should say F and L to

00:15:16,300 --> 00:15:28,120
the members first and last two bailouts

00:15:20,290 --> 00:15:30,040
here one because we copy the string yes

00:15:28,120 --> 00:15:31,269
and that's good we still need the string

00:15:30,040 --> 00:15:33,730
we didn't move the string into the

00:15:31,269 --> 00:15:37,660
object and one to create the temperature

00:15:33,730 --> 00:15:40,120
there the the temporary string for the

00:15:37,660 --> 00:15:42,360
second argument and then here we have

00:15:40,120 --> 00:15:57,360
Marwan Malik because we moved the string

00:15:42,360 --> 00:16:01,839
into the member of first and cool done

00:15:57,360 --> 00:16:05,889
so remember where we came from we

00:16:01,839 --> 00:16:08,410
started with the problem of having lost

00:16:05,889 --> 00:16:11,709
the string constructor single string

00:16:08,410 --> 00:16:16,540
constructor taking objects by reference

00:16:11,709 --> 00:16:21,730
and it ended up to have something like

00:16:16,540 --> 00:16:25,240
between seven and nine overloads to make

00:16:21,730 --> 00:16:29,230
it perfect and with this we have two

00:16:25,240 --> 00:16:32,290
versions and we are almost perfect

00:16:29,230 --> 00:16:36,339
the additional overhead here is the

00:16:32,290 --> 00:16:40,740
moves or at least one which we have

00:16:36,339 --> 00:16:40,740
because we pass s with move semantics

00:16:42,269 --> 00:16:49,089
but of course we have something else in

00:16:46,209 --> 00:16:51,569
the standard which is called perfect

00:16:49,089 --> 00:16:51,569
forward

00:16:57,930 --> 00:17:08,640
so you have an alternative approach

00:17:01,740 --> 00:17:11,560
which is let's pass the elements as a

00:17:08,640 --> 00:17:14,850
universal reference or as it is called

00:17:11,560 --> 00:17:17,620
now the standard forwarding reference

00:17:14,850 --> 00:17:25,240
which listen other your reference of a

00:17:17,620 --> 00:17:28,900
template parameter and use forward not

00:17:25,240 --> 00:17:34,240
that easy to implement but we learnt it

00:17:28,900 --> 00:17:43,150
that way this covers all dying

00:17:34,240 --> 00:17:48,360
combinations and even more good now when

00:17:43,150 --> 00:17:54,960
we create a customer see and pass to

00:17:48,360 --> 00:17:59,679
string that words then F and L our

00:17:54,960 --> 00:18:03,580
arguments become Universal references of

00:17:59,679 --> 00:18:05,380
forwarding references to these literals

00:18:03,580 --> 00:18:11,710
so we don't copy anything we just

00:18:05,380 --> 00:18:14,860
introduce new names for them and the key

00:18:11,710 --> 00:18:17,830
thing with forward is it does a bright

00:18:14,860 --> 00:18:23,050
thing but it almost always does a bad

00:18:17,830 --> 00:18:26,740
thing I should say so in this case when

00:18:23,050 --> 00:18:30,610
we have a temporary now in this case

00:18:26,740 --> 00:18:32,830
when we have an L value in a string

00:18:30,610 --> 00:18:37,210
literal in original it's an L value it

00:18:32,830 --> 00:18:40,140
takes this to initialize the two members

00:18:37,210 --> 00:18:40,140
first and last

00:18:45,530 --> 00:18:56,760
to Madam's that's it perfect that's why

00:18:51,480 --> 00:19:00,560
we call it perfect following let's pass

00:18:56,760 --> 00:19:09,420
the string we have already to Malik's

00:19:00,560 --> 00:19:14,040
perfect one copy of s1 create for the

00:19:09,420 --> 00:19:19,020
fix by the way in this version the type

00:19:14,040 --> 00:19:25,040
s1 is STD string and the type as two is

00:19:19,020 --> 00:19:25,040
cons character star am i right

00:19:25,100 --> 00:19:33,600
no why don't you scream hey you are

00:19:28,710 --> 00:19:37,470
tired still we pass by reference my

00:19:33,600 --> 00:19:38,760
reference means if you pass temple

00:19:37,470 --> 00:19:41,400
arguments by reference

00:19:38,760 --> 00:19:45,000
they don't decay though they keep the

00:19:41,400 --> 00:19:51,090
original type which means that the type

00:19:45,000 --> 00:19:55,140
of s2 is an array of four Khan's

00:19:51,090 --> 00:20:03,420
characters but it works that's a good

00:19:55,140 --> 00:20:05,220
thing and we can move and we have what

00:20:03,420 --> 00:20:08,970
weird we have one Malek because we move

00:20:05,220 --> 00:20:17,490
the spring into first and we create one

00:20:08,970 --> 00:20:18,510
for the temporary done thank you very

00:20:17,490 --> 00:20:29,580
much for your attention

00:20:18,510 --> 00:20:31,980
oh why don't I get any applause because

00:20:29,580 --> 00:20:34,440
you knew you knew all of that that's a

00:20:31,980 --> 00:20:37,920
problem huh nothing new what the hell is

00:20:34,440 --> 00:20:47,390
this guy telling you well I I want to

00:20:37,920 --> 00:20:47,390
motivate the problem let's create a

00:20:48,080 --> 00:20:53,420
single customer plus passing one

00:20:51,030 --> 00:20:53,420
argument

00:20:54,070 --> 00:21:08,650
does this compile know what is the price

00:21:00,650 --> 00:21:11,320
if the title is hit but the error is

00:21:08,650 --> 00:21:13,909
conversion from Khan's character five

00:21:11,320 --> 00:21:17,919
area five Khan's characters to a non

00:21:13,909 --> 00:21:21,490
scala type customers requested yes yes

00:21:17,919 --> 00:21:21,490
so what's the problem

00:21:21,520 --> 00:21:26,990
the good news is the good thing is we

00:21:24,110 --> 00:21:29,990
have different compilers what compiler

00:21:26,990 --> 00:21:32,149
gives me that another compiler gives me

00:21:29,990 --> 00:21:35,809
that and that's a little bit helpful or

00:21:32,149 --> 00:21:42,860
more helpful no viable conversion from

00:21:35,809 --> 00:21:46,220
Khan's character five mm candidates at

00:21:42,860 --> 00:21:47,870
lists I think it's it's clang here one

00:21:46,220 --> 00:21:48,679
Kenny the template has the following

00:21:47,870 --> 00:21:51,500
problem

00:21:48,679 --> 00:22:01,460
I couldn't infer the template argument

00:21:51,500 --> 00:22:05,390
s2 because template arguments with

00:22:01,460 --> 00:22:10,039
default values or templates arguments

00:22:05,390 --> 00:22:12,470
for access a template parameters for

00:22:10,039 --> 00:22:16,820
call arguments with default values are

00:22:12,470 --> 00:22:21,320
not deduced you all know that rule don't

00:22:16,820 --> 00:22:25,220
you so what is it Lucien

00:22:21,320 --> 00:22:29,450
well let's we have to also place a

00:22:25,220 --> 00:22:33,679
default for the template parameter and

00:22:29,450 --> 00:22:37,640
what is the default here contra

00:22:33,679 --> 00:22:40,970
character star what would be we could

00:22:37,640 --> 00:22:42,860
also say an array of one cons character

00:22:40,970 --> 00:22:46,580
but that seems to be a little bit

00:22:42,860 --> 00:22:52,120
stretch so let's do it that way and

00:22:46,580 --> 00:22:55,120
let's compile let's compile it with GCC

00:22:52,120 --> 00:22:55,120
fine

00:22:56,800 --> 00:23:06,450
let's compile it with clang fine let's

00:23:03,280 --> 00:23:06,450
compile it with Visual Studio

00:23:11,610 --> 00:23:21,120
actually I don't know which compilers

00:23:14,800 --> 00:23:23,710
right we wrote a new template book of

00:23:21,120 --> 00:23:28,870
850 pages and I don't know which

00:23:23,710 --> 00:23:30,190
compiler is right I have to confess who

00:23:28,870 --> 00:23:38,590
knows which one is right

00:23:30,190 --> 00:23:40,630
anybody here the way I prepared a few of

00:23:38,590 --> 00:23:41,380
the slides over the last two days I

00:23:40,630 --> 00:23:45,520
found it

00:23:41,380 --> 00:23:47,620
yesterday I just said oh and let's let's

00:23:45,520 --> 00:23:50,560
make a last try and by the way why do I

00:23:47,620 --> 00:23:53,500
always say the default argument for s2

00:23:50,560 --> 00:23:55,060
is SCD string let's use cons care Acosta

00:23:53,500 --> 00:24:00,700
and suddenly it didn't compile on what

00:23:55,060 --> 00:24:03,280
compiler okay so the good thing is it

00:24:00,700 --> 00:24:15,610
works if you use STD string on our

00:24:03,280 --> 00:24:18,580
compilers you like C++ don't you okay

00:24:15,610 --> 00:24:20,740
all problems are gone but let's extend

00:24:18,580 --> 00:24:22,840
the test suite because we found that we

00:24:20,740 --> 00:24:26,230
should try out everything for this

00:24:22,840 --> 00:24:30,700
simple class so the next test we do is

00:24:26,230 --> 00:24:35,530
let's call a copy constructor couple of

00:24:30,700 --> 00:24:40,990
you know what happens now it doesn't

00:24:35,530 --> 00:24:43,720
compile we have no matching constructor

00:24:40,990 --> 00:24:46,360
for the initiation of an STD string note

00:24:43,720 --> 00:24:49,210
in instantiation of that function

00:24:46,360 --> 00:24:53,590
template specialization customer taking

00:24:49,210 --> 00:24:56,110
a customer for the customer in ciated as

00:24:53,590 --> 00:25:01,290
a customer reference customer reference

00:24:56,110 --> 00:25:01,290
okay and an STD string is requested here

00:25:01,500 --> 00:25:04,500
okay

00:25:05,770 --> 00:25:15,200
accounts customer copy to another

00:25:08,930 --> 00:25:18,170
customer compiled and probably most of

00:25:15,200 --> 00:25:22,520
you have seen this problem also sometime

00:25:18,170 --> 00:25:27,260
before the problem is here the problem

00:25:22,520 --> 00:25:31,190
is that we pass a customer and not a

00:25:27,260 --> 00:25:34,700
const customer and the compiler now

00:25:31,190 --> 00:25:37,820
finds two matching functions one is a

00:25:34,700 --> 00:25:40,040
predefined copy constructor the

00:25:37,820 --> 00:25:41,020
predefined copy constructor takes the

00:25:40,040 --> 00:25:46,730
Const

00:25:41,020 --> 00:25:49,130
customer reference we don't pass a

00:25:46,730 --> 00:25:55,400
current customer we pass a customer here

00:25:49,130 --> 00:25:57,830
at minimum and so our template fide

00:25:55,400 --> 00:26:01,910
constructor is a better match by

00:25:57,830 --> 00:26:04,970
language rules so it will be used and as

00:26:01,910 --> 00:26:07,910
it will be used it is in sense eiated

00:26:04,970 --> 00:26:09,410
for the first time to be a customer by

00:26:07,910 --> 00:26:10,610
the way to be a customer reference we

00:26:09,410 --> 00:26:13,130
come to that in a moment

00:26:10,610 --> 00:26:15,530
and as a second time because we don't

00:26:13,130 --> 00:26:21,890
pass a second argument with STD string

00:26:15,530 --> 00:26:25,970
so this is used to to be compiled and

00:26:21,890 --> 00:26:30,350
the problem is that the moment the F is

00:26:25,970 --> 00:26:38,210
a customer here and we try to initialize

00:26:30,350 --> 00:26:46,610
the member first by the customer F there

00:26:38,210 --> 00:26:48,680
was question no the question is why it's

00:26:46,610 --> 00:26:52,180
a predefined copy constructors copy

00:26:48,680 --> 00:26:55,250
constructors are almost always there

00:26:52,180 --> 00:26:58,460
unless you delete them before C+ or self

00:26:55,250 --> 00:26:59,600
11 they were always there so it's

00:26:58,460 --> 00:27:01,490
different from the default constructor

00:26:59,600 --> 00:27:02,960
which is only there if there is no other

00:27:01,490 --> 00:27:05,300
constructor but the copy con circuits

00:27:02,960 --> 00:27:07,670
are almost always there the only

00:27:05,300 --> 00:27:10,310
exception is if you have explicitly

00:27:07,670 --> 00:27:13,330
defined move constructors or move

00:27:10,310 --> 00:27:13,330
assignment operators

00:27:16,460 --> 00:27:22,110
so this is a this is a significant

00:27:19,559 --> 00:27:25,440
problem we run into it all the time even

00:27:22,110 --> 00:27:27,270
in our standard library and we have to

00:27:25,440 --> 00:27:28,830
deal with it unfortunately we didn't fix

00:27:27,270 --> 00:27:30,720
the language here we shouldn't you

00:27:28,830 --> 00:27:32,760
should have done that and it may be

00:27:30,720 --> 00:27:36,059
standardized C++ 11 but now it's

00:27:32,760 --> 00:27:38,700
probably too late so we should say here

00:27:36,059 --> 00:27:45,690
the inbuilt copy constructor is a better

00:27:38,700 --> 00:27:48,330
match but it isn't and therefore we we

00:27:45,690 --> 00:27:52,559
have a problem here and the usual way to

00:27:48,330 --> 00:27:57,059
solve this is to use spinning or enable

00:27:52,559 --> 00:28:00,630
if enable if says is the idea to say I

00:27:57,059 --> 00:28:03,480
want to ignore this constructor if the

00:28:00,630 --> 00:28:06,149
following is the case and I want to

00:28:03,480 --> 00:28:10,500
ignore this template constructor if I

00:28:06,149 --> 00:28:12,480
pass a customer because as a first

00:28:10,500 --> 00:28:15,059
argument because then I mean a copy

00:28:12,480 --> 00:28:18,120
constructor and I want to have this copy

00:28:15,059 --> 00:28:21,179
constructor called and not my function

00:28:18,120 --> 00:28:26,370
will is only there to initialize my

00:28:21,179 --> 00:28:30,510
members by strings so the way we can

00:28:26,370 --> 00:28:33,510
program that since even before C++ 11 is

00:28:30,510 --> 00:28:35,940
with something like enabled if but in

00:28:33,510 --> 00:28:38,309
C++ 11 we have standardized to Fiedler

00:28:35,940 --> 00:28:40,080
so we can use a standard enable if with

00:28:38,309 --> 00:28:42,750
some tricky template techniques here

00:28:40,080 --> 00:28:46,789
involved which roughly means behind the

00:28:42,750 --> 00:28:51,390
scenes enable if checks whether the

00:28:46,789 --> 00:28:55,200
check is s1 the same as a type customer

00:28:51,390 --> 00:28:58,230
is true or false at compile time and if

00:28:55,200 --> 00:29:02,789
this is false it the whole template is

00:28:58,230 --> 00:29:05,220
gone is a way it's not there so if we

00:29:02,789 --> 00:29:11,220
pass a customer as in a copy constructor

00:29:05,220 --> 00:29:12,570
this is not used well in theory if we

00:29:11,220 --> 00:29:17,909
make everything right

00:29:12,570 --> 00:29:20,000
we don't have done that already yeah we

00:29:17,909 --> 00:29:24,090
called it by the way spin it out so

00:29:20,000 --> 00:29:26,279
Google became about a verb sweeney

00:29:24,090 --> 00:29:28,320
became also a verb and i'm wondering

00:29:26,279 --> 00:29:33,299
what it is in the

00:29:28,320 --> 00:29:35,279
so any other dictionary it's our fault

00:29:33,299 --> 00:29:39,380
in the first edition of CSS templates we

00:29:35,279 --> 00:29:43,139
introduced that time I apologize

00:29:39,380 --> 00:29:46,919
Marshall told us that by that's almost

00:29:43,139 --> 00:29:51,950
worst acronym we have in C++ there's

00:29:46,919 --> 00:29:51,950
only one worse which is our ai ai

00:29:52,039 --> 00:30:01,710
okay so okay this is this is actually

00:29:57,539 --> 00:30:05,129
syntax isn't it it is me

00:30:01,710 --> 00:30:08,220
but we have other burdens and C++ 11 so

00:30:05,129 --> 00:30:13,730
for example one ugliness is because

00:30:08,220 --> 00:30:16,259
enable if yeah it's a type the type is

00:30:13,730 --> 00:30:20,220
void and is ignored the whole trick is

00:30:16,259 --> 00:30:22,860
to say we have here track but there's no

00:30:20,220 --> 00:30:24,960
reason we introduce a template to

00:30:22,860 --> 00:30:28,549
argument the third template argument is

00:30:24,960 --> 00:30:31,320
only there to introduce this check and

00:30:28,549 --> 00:30:34,440
it yields the type and because it yields

00:30:31,320 --> 00:30:39,870
a type we need type name before STD

00:30:34,440 --> 00:30:43,259
enable if so in C++ 14 we introduce

00:30:39,870 --> 00:30:46,679
something like enable if underscore T so

00:30:43,259 --> 00:30:49,679
that we have can scape both one leading

00:30:46,679 --> 00:30:53,190
type name in front of STD NABF and the

00:30:49,679 --> 00:30:57,539
trailing colon colon type and by the way

00:30:53,190 --> 00:31:01,679
that was so cool that I think it was

00:30:57,539 --> 00:31:03,929
water brown Thank You Balter proposed to

00:31:01,679 --> 00:31:05,730
say well we want to have it also for for

00:31:03,929 --> 00:31:10,950
traits where we have colon colon value

00:31:05,730 --> 00:31:15,450
and so in C pass our 17 we now can write

00:31:10,950 --> 00:31:17,669
it at least on one line provided the

00:31:15,450 --> 00:31:27,559
name of the tag type trade is not too

00:31:17,669 --> 00:31:27,559
long we have some of them okay

00:31:27,850 --> 00:31:38,440
we still have the error why that because

00:31:34,389 --> 00:31:41,080
you see it here you see that this

00:31:38,440 --> 00:31:45,340
template is in sense yet not for

00:31:41,080 --> 00:31:47,590
customer when we pass a customer it's

00:31:45,340 --> 00:31:52,570
incense eiated for reference this is a

00:31:47,590 --> 00:31:58,470
template enunciated for reference why

00:31:52,570 --> 00:32:03,460
that it's a fault of perfect forwarding

00:31:58,470 --> 00:32:05,799
because when we perfect forward or no

00:32:03,460 --> 00:32:08,739
excuse me a forwarding is a fault the

00:32:05,799 --> 00:32:11,859
problem is if we have move semantics and

00:32:08,739 --> 00:32:13,929
we pass something with move semantics so

00:32:11,859 --> 00:32:19,539
we declare something as an r-value

00:32:13,929 --> 00:32:24,970
reference when we use it it's an L value

00:32:19,539 --> 00:32:28,169
and the reason is that move semantics

00:32:24,970 --> 00:32:32,649
should not be automatically before word

00:32:28,169 --> 00:32:37,629
because if that would be the case and we

00:32:32,649 --> 00:32:39,929
use our argument twice the first use we

00:32:37,629 --> 00:32:43,659
would use the value with the first use

00:32:39,929 --> 00:32:46,179
so we have a special very interesting

00:32:43,659 --> 00:32:50,649
woods in the standard saying that there

00:32:46,179 --> 00:32:55,269
are some special cases involved to more

00:32:50,649 --> 00:32:57,429
or less make forward do the right thing

00:32:55,269 --> 00:33:02,679
so something sometimes calling move and

00:32:57,429 --> 00:33:06,999
sometimes not and we need an ampersand

00:33:02,679 --> 00:33:12,159
here because when we pass this customer

00:33:06,999 --> 00:33:15,879
object F the template argument s1 is

00:33:12,159 --> 00:33:19,840
deduced as an l-value

00:33:15,879 --> 00:33:20,499
and here's a rule by the way it's pretty

00:33:19,840 --> 00:33:22,570
obvious

00:33:20,499 --> 00:33:24,789
it says everything so why don't you only

00:33:22,570 --> 00:33:29,549
read them the standard and you

00:33:24,789 --> 00:33:31,559
understood C++ is the parameter type

00:33:29,549 --> 00:33:35,169
which is f here

00:33:31,559 --> 00:33:39,519
it's an earlier reference which is the

00:33:35,169 --> 00:33:41,710
case we have two ampersand to an CV

00:33:39,519 --> 00:33:44,650
unqualified template parameter

00:33:41,710 --> 00:33:47,230
we have a template parameter s1 and it's

00:33:44,650 --> 00:33:52,510
not neither qualified with constant or

00:33:47,230 --> 00:33:54,970
with volatile and the argument is an

00:33:52,510 --> 00:33:59,530
elder you yes we pass an argument as an

00:33:54,970 --> 00:34:03,520
airway F is an l-value the type ever you

00:33:59,530 --> 00:34:07,800
reference to T is used in place of T for

00:34:03,520 --> 00:34:12,340
type deduction and again this is to make

00:34:07,800 --> 00:34:14,230
move semantics work fine in generic more

00:34:12,340 --> 00:34:16,480
less and generic oh that we don't need

00:34:14,230 --> 00:34:24,220
overloads or that we can perfect forward

00:34:16,480 --> 00:34:25,960
things done we have solved our problem

00:34:24,220 --> 00:34:32,830
thank you very much for your attention

00:34:25,960 --> 00:34:42,030
you've got it yeah let's see what other

00:34:32,830 --> 00:34:48,820
applause goes goes raise a small ring

00:34:42,030 --> 00:34:56,320
hello oh hi oh you used my class

00:34:48,820 --> 00:35:04,480
superclass awesome wha-what how you

00:34:56,320 --> 00:35:08,200
derive it well it's clear you have

00:35:04,480 --> 00:35:13,140
whipped customers VIP customers oh I

00:35:08,200 --> 00:35:16,000
forgot you're VIP customers okay

00:35:13,140 --> 00:35:18,970
publicly derived from customer I tell

00:35:16,000 --> 00:35:22,960
you what you will get the problem I just

00:35:18,970 --> 00:35:25,030
fixed so please have using declaration

00:35:22,960 --> 00:35:28,330
so that we inherit all the abilities of

00:35:25,030 --> 00:35:32,550
this cast of this constructor so that we

00:35:28,330 --> 00:35:41,170
again can pass one or two strings and

00:35:32,550 --> 00:35:49,350
optionally and it does everything still

00:35:41,170 --> 00:35:49,350
work thus everything still work

00:35:50,530 --> 00:35:55,880
if you don't if you know the answer

00:35:53,180 --> 00:36:01,599
there's no reason to buy our new C++

00:35:55,880 --> 00:36:06,290
templates book although I say it's okay

00:36:01,599 --> 00:36:06,770
shameless advertisement yes everything

00:36:06,290 --> 00:36:09,859
works

00:36:06,770 --> 00:36:15,369
I can initialize even my VIP with the

00:36:09,859 --> 00:36:20,869
equal sign I can use a copy constructor

00:36:15,369 --> 00:36:24,079
so this where the tricky cases here and

00:36:20,869 --> 00:36:28,910
everything else will also works fine so

00:36:24,079 --> 00:36:37,339
great we're then what what what do you

00:36:28,910 --> 00:36:40,690
say you have a problem why oh oh you try

00:36:37,339 --> 00:36:48,890
to create a customer and pass the VIP oh

00:36:40,690 --> 00:36:52,760
that doesn't compile too bad so what is

00:36:48,890 --> 00:36:55,040
the problem here we disable this

00:36:52,760 --> 00:37:00,140
template ID customer in the base class

00:36:55,040 --> 00:37:04,450
only if we pass a customer reference but

00:37:00,140 --> 00:37:06,710
what we pass here is a VIP reference

00:37:04,450 --> 00:37:09,680
this is perfectly legal

00:37:06,710 --> 00:37:12,170
the VIP is a customer because it's

00:37:09,680 --> 00:37:17,839
publicly derived but this does not

00:37:12,170 --> 00:37:21,170
compile the strange error we got is you

00:37:17,839 --> 00:37:29,089
are not allowed to initialize first the

00:37:21,170 --> 00:37:32,480
string first with the VIP okay so we

00:37:29,089 --> 00:37:34,310
can't use is same we should use a

00:37:32,480 --> 00:37:37,670
different type trait say a couple of

00:37:34,310 --> 00:37:39,890
interesting options here for example

00:37:37,670 --> 00:37:43,040
it's an interesting discussion should be

00:37:39,890 --> 00:37:45,980
use is convertible or is constructible

00:37:43,040 --> 00:37:48,500
here and just to confuse the Russians

00:37:45,980 --> 00:37:54,859
the order is different depending on

00:37:48,500 --> 00:37:57,260
which one of them you use just to

00:37:54,859 --> 00:37:59,560
confuse North Korean I should say these

00:37:57,260 --> 00:37:59,560
days

00:38:02,790 --> 00:38:08,980
you're still getting era oh yeah well I

00:38:06,670 --> 00:38:11,770
skipped the M percent but anyway it's

00:38:08,980 --> 00:38:15,070
okay because the M percent is no longer

00:38:11,770 --> 00:38:18,040
necessary because it converts a Reverend

00:38:15,070 --> 00:38:21,640
converts to a non reference so what is

00:38:18,040 --> 00:38:29,680
the problem here think about it which

00:38:21,640 --> 00:38:32,290
language rules is broken here without

00:38:29,680 --> 00:38:36,180
saying the answer who knows what the

00:38:32,290 --> 00:38:44,560
problem here is please raise your hand

00:38:36,180 --> 00:38:49,300
one two three four good cool guys I sent

00:38:44,560 --> 00:38:53,440
a back report to Jonathan because when I

00:38:49,300 --> 00:38:55,990
tried this out I got the error message

00:38:53,440 --> 00:39:08,290
and the error message was this so now

00:38:55,990 --> 00:39:10,680
you understand what's going wrong so now

00:39:08,290 --> 00:39:10,680
you got it

00:39:16,320 --> 00:39:23,260
the problem is similar to a problem when

00:39:20,470 --> 00:39:26,200
you get a car dump and you're lucky

00:39:23,260 --> 00:39:29,440
because you had undefined behavior and

00:39:26,200 --> 00:39:32,860
if you didn't got the quorum even worse

00:39:29,440 --> 00:39:35,710
things could have happened and the

00:39:32,860 --> 00:39:41,440
problem is simple it's a logical error

00:39:35,710 --> 00:39:45,100
which we do what we do here we define a

00:39:41,440 --> 00:39:47,380
constructor and why we define a

00:39:45,100 --> 00:39:50,530
constructor we say we want to have it if

00:39:47,380 --> 00:39:57,160
an argument is convertible to a type

00:39:50,530 --> 00:40:00,820
cast what needs a constructor so by

00:39:57,160 --> 00:40:05,350
defining the rules for how can I create

00:40:00,820 --> 00:40:09,940
a customer I asked myself whether I'm

00:40:05,350 --> 00:40:12,850
available or not so we were lucky to get

00:40:09,940 --> 00:40:15,340
this this error by the way

00:40:12,850 --> 00:40:17,830
when I try this out there's a longer

00:40:15,340 --> 00:40:19,990
story behind it in some words it did

00:40:17,830 --> 00:40:22,360
work fine and then I switched to a

00:40:19,990 --> 00:40:25,480
slightly different way of enable if here

00:40:22,360 --> 00:40:31,869
it suddenly the compiler crashed which

00:40:25,480 --> 00:40:34,030
can also be the result of this yeah we

00:40:31,869 --> 00:40:36,310
made something wrong here we can't use

00:40:34,030 --> 00:40:38,410
is convertible to cus we have to

00:40:36,310 --> 00:40:41,740
formulate it the other way around we

00:40:38,410 --> 00:40:43,600
have to say is our can can say is not

00:40:41,740 --> 00:40:45,970
convertible to class so we have to say

00:40:43,600 --> 00:40:48,690
is convertible to string so we have to

00:40:45,970 --> 00:40:51,460
formulate it positively because string

00:40:48,690 --> 00:40:55,260
is not what we define here and we can

00:40:51,460 --> 00:40:55,260
use the type thread for Strings here

00:41:01,410 --> 00:41:18,490
John ah perfect thank you very much if

00:41:13,900 --> 00:41:22,270
you don't like the way you have to

00:41:18,490 --> 00:41:28,200
disable this template there's like on

00:41:22,270 --> 00:41:31,840
the horizon which is called C++ 20

00:41:28,200 --> 00:41:33,760
because in C++ 20 we will have a

00:41:31,840 --> 00:41:38,830
language feature as a side effect of

00:41:33,760 --> 00:41:41,830
concept which is called requires so that

00:41:38,830 --> 00:41:45,790
we can formulate this requirement not as

00:41:41,830 --> 00:41:48,720
a strange and able if type trait library

00:41:45,790 --> 00:41:54,430
feature we have now a language feature

00:41:48,720 --> 00:41:58,150
disabling templates for some cases so we

00:41:54,430 --> 00:42:01,150
simply write this requires that the type

00:41:58,150 --> 00:42:05,619
s1 is convertible to a string otherwise

00:42:01,150 --> 00:42:08,980
this template will be ignored so we are

00:42:05,619 --> 00:42:11,950
looking forward to c++ 20 and i'm yeah i

00:42:08,980 --> 00:42:14,740
hate it when we when we world C++

00:42:11,950 --> 00:42:17,830
templates that the new addition I don't

00:42:14,740 --> 00:42:21,940
know how often I thought I hate to write

00:42:17,830 --> 00:42:25,240
an able if here was a big mistake really

00:42:21,940 --> 00:42:25,829
big mistake that with concepts we played

00:42:25,240 --> 00:42:28,650
the all

00:42:25,829 --> 00:42:30,359
nothing game which is a serious problem

00:42:28,650 --> 00:42:34,170
we have in the standard committee right

00:42:30,359 --> 00:42:38,430
now people want to have concept all or

00:42:34,170 --> 00:42:40,890
nothing and we should have standardized

00:42:38,430 --> 00:42:44,279
requires at least requires because it's

00:42:40,890 --> 00:42:47,910
obvious that we need it because we have

00:42:44,279 --> 00:42:49,739
enable if all over the place if you look

00:42:47,910 --> 00:42:52,680
into standard libraries implemented

00:42:49,739 --> 00:42:55,769
there's there's a huge number of enable

00:42:52,680 --> 00:42:57,479
if statements to fix the problems you

00:42:55,769 --> 00:43:08,940
just saw on and a couple of others

00:42:57,479 --> 00:43:11,039
problems let's summarize yeah there's no

00:43:08,940 --> 00:43:20,430
further trap there's no further trip I

00:43:11,039 --> 00:43:25,579
know yet let's think about these three

00:43:20,430 --> 00:43:31,039
statements let's think about C D and E

00:43:25,579 --> 00:43:34,589
initialized by two string literals by a

00:43:31,039 --> 00:43:38,299
string and a string little and by a move

00:43:34,589 --> 00:43:41,089
string and a string little and

00:43:38,299 --> 00:43:44,219
everything else should still work fine

00:43:41,089 --> 00:43:47,009
so we started with we want to have

00:43:44,219 --> 00:43:51,660
perfect performance for this little

00:43:47,009 --> 00:43:53,400
customer class and when we try to reach

00:43:51,660 --> 00:43:57,680
this perfect performance we run into

00:43:53,400 --> 00:44:01,349
trouble and we try to solve this trouble

00:43:57,680 --> 00:44:04,369
so the initial version no as a

00:44:01,349 --> 00:44:07,259
side-effect after some versions we tried

00:44:04,369 --> 00:44:12,599
we came back to the question why don't

00:44:07,259 --> 00:44:14,989
we pass strings by value here and it

00:44:12,599 --> 00:44:18,599
turned out that this is pretty expensive

00:44:14,989 --> 00:44:20,969
eleven potential Maalox unless we have

00:44:18,599 --> 00:44:23,190
short string optimizations because we

00:44:20,969 --> 00:44:25,109
have four creates and expensive as

00:44:23,190 --> 00:44:27,119
things that we got with three these

00:44:25,109 --> 00:44:30,900
three statements as a summary we got

00:44:27,119 --> 00:44:36,089
seven copies expensive string copies and

00:44:30,900 --> 00:44:38,340
one more so the solution was here to use

00:44:36,089 --> 00:44:42,550
a CD move

00:44:38,340 --> 00:44:44,890
for the initial item for the past for

00:44:42,550 --> 00:44:50,080
the by value pass argument F and L and

00:44:44,890 --> 00:44:55,020
we we were almost perfect we got five

00:44:50,080 --> 00:44:58,320
medics because four creates and one copy

00:44:55,020 --> 00:45:00,670
which is exactly what we had we had to

00:44:58,320 --> 00:45:02,260
creates for the first statement because

00:45:00,670 --> 00:45:04,450
we have to spring literals then one

00:45:02,260 --> 00:45:06,340
spring little at the second statement

00:45:04,450 --> 00:45:09,070
and once recalled sunny spring literal

00:45:06,340 --> 00:45:12,580
at the third statements so that we can't

00:45:09,070 --> 00:45:15,610
avoid that and one copy because the

00:45:12,580 --> 00:45:19,540
second the second constructor takes us

00:45:15,610 --> 00:45:22,810
by value and it should be its own copy

00:45:19,540 --> 00:45:28,530
and then we have but the the overhead to

00:45:22,810 --> 00:45:33,670
a perfect solution is five moves that's

00:45:28,530 --> 00:45:39,580
pretty pretty good the next alternative

00:45:33,670 --> 00:45:42,570
were five medics so that was a perfect

00:45:39,580 --> 00:45:52,540
solution but we needed all the overloads

00:45:42,570 --> 00:45:57,090
at least seven seven or online and then

00:45:52,540 --> 00:46:02,950
we got our easy solution having only one

00:45:57,090 --> 00:46:05,920
declaration and this was is also perfect

00:46:02,950 --> 00:46:09,330
but it has a strange enable if syntax

00:46:05,920 --> 00:46:12,970
and by the way take your picture now

00:46:09,330 --> 00:46:15,340
because now the slide is complete the

00:46:12,970 --> 00:46:18,660
first two will you still have the cons

00:46:15,340 --> 00:46:20,860
carica star problem so when we use copy

00:46:18,660 --> 00:46:23,980
initialization initialization with the

00:46:20,860 --> 00:46:26,770
equal sign and pass a string little then

00:46:23,980 --> 00:46:30,580
so therefore in the first two versions

00:46:26,770 --> 00:46:35,440
to make this aid available to enable

00:46:30,580 --> 00:46:37,960
this you need one other constructor and

00:46:35,440 --> 00:46:43,350
the other constructor should just take

00:46:37,960 --> 00:46:43,350
one cons character star and that's all

00:46:48,170 --> 00:46:56,490
that's all I want to say who's the

00:46:51,000 --> 00:46:58,770
winner who who thinks but we don't vote

00:46:56,490 --> 00:47:00,930
for the first version of course who

00:46:58,770 --> 00:47:06,210
thinks the second word and pass by value

00:47:00,930 --> 00:47:09,180
is the best solution here okay

00:47:06,210 --> 00:47:13,410
who's saying the third version is the

00:47:09,180 --> 00:47:16,610
best solution here who thinks the last

00:47:13,410 --> 00:47:21,990
version is the best solution here and

00:47:16,610 --> 00:47:26,370
all the others hate zip as possible well

00:47:21,990 --> 00:47:31,820
it's an alternative like I missed spring

00:47:26,370 --> 00:47:36,600
view oh how many minutes do we have

00:47:31,820 --> 00:47:46,430
string view okay I forgot that to be

00:47:36,600 --> 00:47:50,720
honest but spring view is not better

00:47:46,430 --> 00:47:54,300
it's an alternative but it's not better

00:47:50,720 --> 00:48:04,530
with string you let me think with string

00:47:54,300 --> 00:48:06,750
view we have we create if we pass an STD

00:48:04,530 --> 00:48:09,930
string we can use it as a string view

00:48:06,750 --> 00:48:13,410
that's fine and if we use a string you

00:48:09,930 --> 00:48:19,740
too in it so the problem is if you pass

00:48:13,410 --> 00:48:21,510
an STD string to a string view and then

00:48:19,740 --> 00:48:23,850
use the string view argument to

00:48:21,510 --> 00:48:27,300
initialize your string you call the

00:48:23,850 --> 00:48:32,850
constructor so you you still need some

00:48:27,300 --> 00:48:35,960
overloads for that so yeah next next

00:48:32,850 --> 00:48:35,960
time I will discuss that

00:48:39,630 --> 00:48:50,970
okay any other alternative what about

00:48:44,970 --> 00:48:52,830
aggregate initialization if I make all

00:48:50,970 --> 00:49:04,650
feeds public are you serious with this

00:48:52,830 --> 00:49:06,120
question so then you directly can pass

00:49:04,650 --> 00:49:09,210
the elements

00:49:06,120 --> 00:49:11,700
there's no argument involved in a

00:49:09,210 --> 00:49:15,530
constructor so it's better yeah so so

00:49:11,700 --> 00:49:24,360
the rule is make all the feeds public

00:49:15,530 --> 00:49:30,860
thank you very much I next time I have

00:49:24,360 --> 00:49:33,120
slide for that well any other great

00:49:30,860 --> 00:49:39,690
contribution what else we could do

00:49:33,120 --> 00:49:43,110
sorry for that what string litotes

00:49:39,690 --> 00:49:45,990
internally in the class in the

00:49:43,110 --> 00:50:05,400
initialization string little what do you

00:49:45,990 --> 00:50:07,200
mean by string that was yes though he

00:50:05,400 --> 00:50:10,320
said he's saying when I when I overall

00:50:07,200 --> 00:50:12,570
for constraint character Stan I avoid

00:50:10,320 --> 00:50:16,460
some overloads yeah that but that we had

00:50:12,570 --> 00:50:16,460
that already yeah okay

00:50:21,450 --> 00:50:29,220
the question is can we in the in the

00:50:23,700 --> 00:50:32,940
second case rely on an optimizer to have

00:50:29,220 --> 00:50:36,480
the same performance as as a as a third

00:50:32,940 --> 00:50:42,089
row bot so the to to to to help with the

00:50:36,480 --> 00:50:46,760
moves well in a practice this is not

00:50:42,089 --> 00:50:46,760
done mmm

00:50:53,809 --> 00:51:06,119
I'm not sure I'm only an application

00:50:57,390 --> 00:51:07,740
problem so anyway summary we can

00:51:06,119 --> 00:51:09,480
afterwards discuss a lot and you can

00:51:07,740 --> 00:51:11,910
send me emails I'm fine

00:51:09,480 --> 00:51:14,099
and I know I'm not perfect I only

00:51:11,910 --> 00:51:19,380
present my view as an application

00:51:14,099 --> 00:51:22,740
program and you aren't again and again

00:51:19,380 --> 00:51:27,359
C++ is tricky you can do everything and

00:51:22,740 --> 00:51:32,099
you can make even every mistake the next

00:51:27,359 --> 00:51:36,089
thing is oh that's missing my animations

00:51:32,099 --> 00:51:41,040
are wrong here second topit was added

00:51:36,089 --> 00:51:47,069
late because it turned out that finally

00:51:41,040 --> 00:51:54,349
I decided that the second option the

00:51:47,069 --> 00:51:54,349
second bullet is a winner so that we say

00:52:03,230 --> 00:52:10,340
no doesn't work no we come to that so

00:52:06,890 --> 00:52:13,520
yeah here it is so we that we pass by

00:52:10,340 --> 00:52:16,010
value is incredible good it's not

00:52:13,520 --> 00:52:20,060
perfect but I would recommend this in

00:52:16,010 --> 00:52:25,070
this case because we have to teach C++

00:52:20,060 --> 00:52:29,080
to people the usage of an a belief is a

00:52:25,070 --> 00:52:29,080
nightmare for application programmers

00:52:30,670 --> 00:52:38,090
and by the way we you might think of

00:52:36,410 --> 00:52:41,390
that requires makes it a little bit

00:52:38,090 --> 00:52:43,700
better we are currently discussing a

00:52:41,390 --> 00:52:45,260
couple of trouble we probably get when

00:52:43,700 --> 00:52:48,890
we have the requires clause in the

00:52:45,260 --> 00:52:52,070
standard library because the requires

00:52:48,890 --> 00:52:55,880
Clause changes the signature of function

00:52:52,070 --> 00:53:00,980
and the moment you have a required

00:52:55,880 --> 00:53:03,710
Clause standardized and you want to

00:53:00,980 --> 00:53:07,160
change your requirements you break

00:53:03,710 --> 00:53:09,980
binary compatibility which will be a

00:53:07,160 --> 00:53:12,320
serious issue we currently discuss where

00:53:09,980 --> 00:53:14,750
to apply concepts and how to apply

00:53:12,320 --> 00:53:32,930
concepts in the library we have no

00:53:14,750 --> 00:53:35,600
solution for that yet yeah the argument

00:53:32,930 --> 00:53:37,940
wall said that the problem of the

00:53:35,600 --> 00:53:39,410
expensive copying is not there if we

00:53:37,940 --> 00:53:41,240
have short strings and our

00:53:39,410 --> 00:53:44,240
implementation uses a short spring

00:53:41,240 --> 00:53:47,210
optimization which listen most compilers

00:53:44,240 --> 00:53:50,840
now the case usually up to 15 characters

00:53:47,210 --> 00:53:53,210
so if in your programming language or in

00:53:50,840 --> 00:53:56,450
your application your customer names are

00:53:53,210 --> 00:54:01,670
less than 15 characters that's fine

00:53:56,450 --> 00:54:04,119
that's perfect well almost perfect there

00:54:01,670 --> 00:54:06,530
there are applications there are

00:54:04,119 --> 00:54:08,750
applications of this problem having a

00:54:06,530 --> 00:54:11,060
customer with a string member which is a

00:54:08,750 --> 00:54:12,740
pretty common thing I think where

00:54:11,060 --> 00:54:17,830
strings are longer than 50 characters

00:54:12,740 --> 00:54:17,830
and by the way yeah yeah sorry

00:54:18,900 --> 00:54:23,890
if we won't have default arguments yeah

00:54:22,240 --> 00:54:27,340
we would not have needed yeah you're

00:54:23,890 --> 00:54:28,660
right yeah sometimes we have default

00:54:27,340 --> 00:54:32,650
arguments or sometimes we have a

00:54:28,660 --> 00:54:36,760
constructor taking only one string so it

00:54:32,650 --> 00:54:39,760
happens yeah so the workaround is you

00:54:36,760 --> 00:54:41,310
are not allowed only to pass the first

00:54:39,760 --> 00:54:44,350
thing yes

00:54:41,310 --> 00:54:47,110
let our api's derive from the

00:54:44,350 --> 00:54:49,200
constraints the language gives us good

00:54:47,110 --> 00:54:53,350
advice

00:54:49,200 --> 00:54:56,020
we have C++ 17 support now it's it's

00:54:53,350 --> 00:54:59,260
good so some of the features I discussed

00:54:56,020 --> 00:55:03,880
here are than C++ 17 especially the the

00:54:59,260 --> 00:55:05,740
improvements of the type traits we had a

00:55:03,880 --> 00:55:11,880
lot of issues oh there's another

00:55:05,740 --> 00:55:11,880
question pan-pan

00:55:13,590 --> 00:55:18,730
what kind false starts to support c plus

00:55:16,930 --> 00:55:19,570
or 17 but the maintenance of policies in

00:55:18,730 --> 00:55:23,260
clan foyer

00:55:19,570 --> 00:55:25,800
this is yep so it's it's plus it's for

00:55:23,260 --> 00:55:28,170
plus at 7 class we also have GCC 8 yeah

00:55:25,800 --> 00:55:30,400
thank you

00:55:28,170 --> 00:55:32,650
templates are tricky you got you saw a

00:55:30,400 --> 00:55:34,600
couple of problems here which we

00:55:32,650 --> 00:55:37,270
described now in the book and i have to

00:55:34,600 --> 00:55:40,300
say i'm not the expert the experts are

00:55:37,270 --> 00:55:43,030
the two other authors I only try to

00:55:40,300 --> 00:55:50,860
understand what they write that was my

00:55:43,030 --> 00:55:53,440
task in this book and just as a hint I'm

00:55:50,860 --> 00:55:56,580
also currently writing a complete book

00:55:53,440 --> 00:56:00,580
guide about C++ 17 if you are interested

00:55:56,580 --> 00:56:02,080
go there it will be published in a

00:56:00,580 --> 00:56:04,150
different model than the other books it

00:56:02,080 --> 00:56:07,150
will be published as soon as a third of

00:56:04,150 --> 00:56:10,240
the book is done as an e-book and you

00:56:07,150 --> 00:56:12,250
can buy it for very low money and then

00:56:10,240 --> 00:56:14,650
get for free the updates because

00:56:12,250 --> 00:56:17,500
otherwise I need one more year to make

00:56:14,650 --> 00:56:20,530
this all done I have a huge list of

00:56:17,500 --> 00:56:23,680
issues I learned already this week when

00:56:20,530 --> 00:56:25,540
I listen to the other other talks so if

00:56:23,680 --> 00:56:27,820
you're interested look at that and I'm

00:56:25,540 --> 00:56:29,890
still looking for reviewers of that book

00:56:27,820 --> 00:56:33,250
the first version will be come out

00:56:29,890 --> 00:56:38,200
probably four weeks or so and I'm

00:56:33,250 --> 00:56:42,090
looking forward to C++ 24 requires some

00:56:38,200 --> 00:56:45,600
other things that's it

00:56:42,090 --> 00:56:49,240
I'm here I'm still here the whole week

00:56:45,600 --> 00:56:52,720
so tomorrow I will tell you my my other

00:56:49,240 --> 00:56:56,560
interesting findings about what I

00:56:52,720 --> 00:57:00,040
learned about templates in when we wrote

00:56:56,560 --> 00:57:02,350
this second edition training a pedal

00:57:00,040 --> 00:57:05,080
book signing will be there and on

00:57:02,350 --> 00:57:07,870
Saturday I talk a whole day about move

00:57:05,080 --> 00:57:10,420
semantics there is more to tell that's

00:57:07,870 --> 00:57:10,960
it thank you very much please talk to me

00:57:10,420 --> 00:57:13,740
later

00:57:10,960 --> 00:57:13,740

YouTube URL: https://www.youtube.com/watch?v=PNRju6_yn3o


