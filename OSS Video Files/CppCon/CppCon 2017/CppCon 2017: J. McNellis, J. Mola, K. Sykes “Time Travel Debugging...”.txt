Title: CppCon 2017: J. McNellis, J. Mola, K. Sykes “Time Travel Debugging...”
Publication date: 2017-10-06
Playlist: CppCon 2017
Description: 
	Time Travel Debugging: Root Causing Bugs in Commercial Scale Software

http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
We’ve all heard horror stories about bugs that were near-impossible to root-cause, and many of us have at least a few stories of our own. Corrupted or uninitialized memory. Resource leaks. API misuse and race conditions. Occasional and inconsistent crashes where all you have to go on are a series of unhelpful crash dumps. These kinds of problems are often time-consuming and tedious to debug, and can be both draining and infuriating.

Time Travel Debugging (TTD) is a reverse debugging toolkit for Windows that makes debugging these kinds of problems far easier, in both small programs and commercial-scale software like Windows and Office.  It's been an invaluable debugging tool for software developers and escalation engineers within Microsoft for many years.  We’ve spent the last couple of years improving performance, scalability, and usability, and are excited to finally be able to release a public preview of Time Travel Debugging.

In this interactive and hands-on session, we'll show you how to download and make use of our first public preview of Time Travel Debugging, demonstrate how to use TTD, and walk through the root cause analysis of some typically difficult-to-solve bugs like memory corruption, API misuse, and race conditions.
— 
James McNellis: Microsoft, Senior Software Engineer

James is a senior engineer on the Windows Debugger team at Microsoft, where he works on the Time Travel Debugging (TTD) reverse debugging toolkit. Prior to joining the Debuggers team in 2016, he was a member of the Visual C++ team, where he was responsible for the Microsoft C Runtime (CRT) and C Standard Library implementation. Passionate about all things related to C++, he is a frequent speaker at C++ conferences around the world and is a former top contributor on StackOverflow. He can be found on Twitter at @JamesMcNellis.

Jordi Mola: Mircosoft Corp., Principal Software Eng Lead

Jordi is a Principal Software Engineer Lead at Microsoft Corporation that has a passion for engineering productivity and efficiency. Except for a couple of years working on the Windows 8 copy UI, Jordi has spent his entire Microsoft career working on productivity tools, many of which are still internal to Microsoft. One of Jordi’s goals when he joined the debugger team a few years ago was to simplify the debugging of C / C++ and several of the tough problems that come with systems level programming. That simplifying goal has been a key driver for Jordi to lead and architect the Time Travel Debugging space within Microsoft over the last few years.

Ken Sykes: Microsoft, Principal Software Development Engineer

Ken is a Principal Software Developer at Microsoft Corporation and has worked on every consumer version of Windows since Windows 3.0. He recently joined the Windows Debugger team to help developers everywhere become more productive and maybe even make debugging a little bit fun! The C++11 standard finally convinced Ken that C++ was good for more than implementing COM classes and started a journey into TMP, compile-time polymorphism and CppCon conferences.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,480
thank you everyone for coming it's a

00:00:01,860 --> 00:00:07,140
privilege to be here today with my

00:00:03,480 --> 00:00:09,480
colleagues Ken hello and James it's nice

00:00:07,140 --> 00:00:11,580
to see you all here this morning my name

00:00:09,480 --> 00:00:12,570
is Jordi Molla I'm the architect and

00:00:11,580 --> 00:00:14,250
engineering lead for this time-travel

00:00:12,570 --> 00:00:15,660
debugging tools and we are happy to

00:00:14,250 --> 00:00:18,570
present them to you today

00:00:15,660 --> 00:00:20,189
so I got the clue from a great present

00:00:18,570 --> 00:00:23,130
at one time to start with questions up

00:00:20,189 --> 00:00:25,140
front so I'm going to open notepad and

00:00:23,130 --> 00:00:26,699
type of few questions from the audience

00:00:25,140 --> 00:00:38,460
if there is any question before we start

00:00:26,699 --> 00:00:41,850
just go ahead how does these differ from

00:00:38,460 --> 00:00:44,360
our are ok there was another question

00:00:41,850 --> 00:00:44,360
here up front

00:00:44,390 --> 00:01:01,219
sorry windows-only Oh which versions of

00:00:55,739 --> 00:01:04,019
Windows ok let's let's just start with

00:01:01,219 --> 00:01:05,339
with those and then I'm sure that there

00:01:04,019 --> 00:01:10,920
will be more questions as we go forward

00:01:05,339 --> 00:01:13,680
so what is time trouble debugging ok

00:01:10,920 --> 00:01:15,330
time trouble debugging TTD not

00:01:13,680 --> 00:01:17,520
test-driven development just time

00:01:15,330 --> 00:01:19,950
trouble debugging for short TDD is a

00:01:17,520 --> 00:01:21,720
reversible acting solution so we record

00:01:19,950 --> 00:01:23,490
the execution of the process think of it

00:01:21,720 --> 00:01:26,549
as a movie we take a movie of the

00:01:23,490 --> 00:01:28,710
process execution and as a movie when

00:01:26,549 --> 00:01:30,119
you have a DVR or DVD or some other

00:01:28,710 --> 00:01:32,549
since you can go forwards and backwards

00:01:30,119 --> 00:01:35,250
to look for things but also you can

00:01:32,549 --> 00:01:38,040
search through the traces using queries

00:01:35,250 --> 00:01:40,560
can we'll do a demo on how to do queries

00:01:38,040 --> 00:01:42,750
to search through the trace when we look

00:01:40,560 --> 00:01:45,170
at debugging we should have to solve a

00:01:42,750 --> 00:01:48,149
few problems debugging is time-consuming

00:01:45,170 --> 00:01:50,130
I'm sure all of us here have a single

00:01:48,149 --> 00:01:51,659
step through a function painfully to

00:01:50,130 --> 00:01:53,310
make sure we didn't get past the point

00:01:51,659 --> 00:01:55,110
of the function that was of interest and

00:01:53,310 --> 00:01:57,049
spend an hour just single stepping to

00:01:55,110 --> 00:01:59,640
not yet be at the point we want it

00:01:57,049 --> 00:02:01,290
debugging is is really hard we actually

00:01:59,640 --> 00:02:04,469
will do a demo today of debugging a

00:02:01,290 --> 00:02:06,450
garbage collection black that can be

00:02:04,469 --> 00:02:10,200
very nasty to debug without some of

00:02:06,450 --> 00:02:11,849
these tools debugging is complex so we

00:02:10,200 --> 00:02:13,530
made sure that we didn't have to learn

00:02:11,849 --> 00:02:16,560
new things

00:02:13,530 --> 00:02:18,870
all of the things that you are used when

00:02:16,560 --> 00:02:22,110
you die back life breakpoints single

00:02:18,870 --> 00:02:26,310
stepping going memory breakpoints work

00:02:22,110 --> 00:02:28,230
on backwards debugging and finally this

00:02:26,310 --> 00:02:30,330
is a pet peeve of mine the number of

00:02:28,230 --> 00:02:31,920
many times you have to repro back when

00:02:30,330 --> 00:02:34,140
you are debugging normally you have to

00:02:31,920 --> 00:02:36,330
go and oh I learned something a start

00:02:34,140 --> 00:02:37,620
over because it was a little earlier

00:02:36,330 --> 00:02:39,959
than I thought now I learned something

00:02:37,620 --> 00:02:41,660
else a start over and in in time trouble

00:02:39,959 --> 00:02:44,550
debugging just simply have to go back

00:02:41,660 --> 00:02:46,709
some of us have used the trick of binary

00:02:44,550 --> 00:02:48,540
searching a bug just look for a place is

00:02:46,709 --> 00:02:49,950
the back happening not yet okay this

00:02:48,540 --> 00:02:53,580
isn't the second half of the trace and

00:02:49,950 --> 00:02:55,860
move on a little bit of background and

00:02:53,580 --> 00:02:57,900
key features for this this is based on a

00:02:55,860 --> 00:03:00,260
Microsoft research project that was

00:02:57,900 --> 00:03:03,750
internally available about ten years ago

00:03:00,260 --> 00:03:05,580
but three four years ago we decided to

00:03:03,750 --> 00:03:09,720
make this publicly available so we went

00:03:05,580 --> 00:03:12,150
on did work to convert the excuse me the

00:03:09,720 --> 00:03:15,600
research code into production code that

00:03:12,150 --> 00:03:17,040
was an effort we also feel that we are

00:03:15,600 --> 00:03:19,170
ready for preview but is the preview is

00:03:17,040 --> 00:03:21,750
not final we still have some bugs and

00:03:19,170 --> 00:03:23,880
several areas to work on in particular

00:03:21,750 --> 00:03:26,480
for those that have worked at Microsoft

00:03:23,880 --> 00:03:28,890
has used that research technology our

00:03:26,480 --> 00:03:31,019
replay is about two orders of magnitude

00:03:28,890 --> 00:03:34,440
faster than it was for the old tool

00:03:31,019 --> 00:03:35,970
record is still as much overhead as it

00:03:34,440 --> 00:03:37,920
was before is something we will be

00:03:35,970 --> 00:03:41,340
working on on the upcoming months and

00:03:37,920 --> 00:03:43,350
years it's written in C++ but it's C++

00:03:41,340 --> 00:03:45,030
of different kinds the recorder is a

00:03:43,350 --> 00:03:46,769
piece of code that we inject inside of

00:03:45,030 --> 00:03:49,140
the process that we are recording so

00:03:46,769 --> 00:03:51,090
that uses no exceptions can not allocate

00:03:49,140 --> 00:03:53,190
memory it has a bunch of restrictions

00:03:51,090 --> 00:03:55,829
that resemble embedded systems on the

00:03:53,190 --> 00:03:59,130
other hand the replay code is normal

00:03:55,829 --> 00:04:00,090
modern C++ it uses coroutines vectors

00:03:59,130 --> 00:04:02,280
Maps

00:04:00,090 --> 00:04:04,440
the parallel library I mean it is a

00:04:02,280 --> 00:04:07,200
normal C++ piece of code performance

00:04:04,440 --> 00:04:09,540
sensitive but normal okay

00:04:07,200 --> 00:04:11,070
our recorder is multi-core that's one of

00:04:09,540 --> 00:04:12,840
the differences with the our our project

00:04:11,070 --> 00:04:15,180
since was one of the questions we do not

00:04:12,840 --> 00:04:18,390
single-core the execution of the process

00:04:15,180 --> 00:04:20,430
to actually record it if you have 50

00:04:18,390 --> 00:04:23,220
runnable threads and 50 course we will

00:04:20,430 --> 00:04:25,140
use all 50 course this is important for

00:04:23,220 --> 00:04:27,270
us at Microsoft because this is used on

00:04:25,140 --> 00:04:30,060
things like a change servers that

00:04:27,270 --> 00:04:31,650
to run on 64 core machines 128 core

00:04:30,060 --> 00:04:34,020
machines so it was an important aspect

00:04:31,650 --> 00:04:35,490
for us to make sure that we could use a

00:04:34,020 --> 00:04:38,370
significant amount of that machine when

00:04:35,490 --> 00:04:41,810
we were recording and this is used a lot

00:04:38,370 --> 00:04:43,919
in escalation cases when you get to

00:04:41,810 --> 00:04:45,810
escalation engineers at Microsoft that

00:04:43,919 --> 00:04:49,470
are working with you and your company or

00:04:45,810 --> 00:04:50,879
you in your consumer side and you get to

00:04:49,470 --> 00:04:53,430
people that have to debug your machine

00:04:50,879 --> 00:04:56,750
this tool is used often having coding

00:04:53,430 --> 00:04:59,340
numbers above the 50% of the cases so

00:04:56,750 --> 00:05:00,960
the two supports shared memory and a

00:04:59,340 --> 00:05:04,710
synchronous i/o another different with

00:05:00,960 --> 00:05:06,960
the our our project and we have the

00:05:04,710 --> 00:05:08,669
ability to query the trace and again can

00:05:06,960 --> 00:05:10,050
will do atom of that which we've we

00:05:08,669 --> 00:05:13,229
think it's an interesting approach to

00:05:10,050 --> 00:05:14,970
debugging if you take one thing out of

00:05:13,229 --> 00:05:15,389
this here is these two runs in three

00:05:14,970 --> 00:05:17,550
steps

00:05:15,389 --> 00:05:18,780
you record the execution you index

00:05:17,550 --> 00:05:20,310
execution the debugger does it

00:05:18,780 --> 00:05:21,870
automatically for you when you open the

00:05:20,310 --> 00:05:24,419
trace for the first time and then you

00:05:21,870 --> 00:05:28,139
replay you can zoom the trace in the

00:05:24,419 --> 00:05:29,849
debugger we have done a few blog post we

00:05:28,139 --> 00:05:31,740
will do more there is a bunch of

00:05:29,849 --> 00:05:34,409
documents there is how to download this

00:05:31,740 --> 00:05:39,120
you have here a link to go on play with

00:05:34,409 --> 00:05:40,229
it how we use this at Microsoft how do

00:05:39,120 --> 00:05:41,819
you use some trouble debugging at

00:05:40,229 --> 00:05:44,849
Microsoft we use it to resolve problems

00:05:41,819 --> 00:05:46,289
from customers and we use it to resolve

00:05:44,849 --> 00:05:48,930
problems internally there are teams at

00:05:46,289 --> 00:05:51,750
Microsoft in Windows which is the

00:05:48,930 --> 00:05:53,159
organization we are in that will not ask

00:05:51,750 --> 00:05:54,779
you for a reproof aback they will ask

00:05:53,159 --> 00:05:56,669
you for a trace of a bug that race is

00:05:54,779 --> 00:05:59,099
essentially one of our recordings so you

00:05:56,669 --> 00:06:00,719
don't give them do these 15 steps to

00:05:59,099 --> 00:06:02,729
rippln then you get back that it doesn't

00:06:00,719 --> 00:06:05,520
rip from my box which we all have used

00:06:02,729 --> 00:06:08,159
as an excuse at one time or two or three

00:06:05,520 --> 00:06:10,650
few times you get a trace to them and

00:06:08,159 --> 00:06:12,000
that also bugs that have traces on them

00:06:10,650 --> 00:06:13,590
have a much higher chance of getting

00:06:12,000 --> 00:06:16,080
fixed at bugs that don't have to resist

00:06:13,590 --> 00:06:18,300
with them this is also for bugs that are

00:06:16,080 --> 00:06:20,009
difficult to repro if you have captured

00:06:18,300 --> 00:06:22,560
the Reaper on a trace you have it use

00:06:20,009 --> 00:06:24,120
omit anything else a corrupted memory we

00:06:22,560 --> 00:06:26,039
will see that on an example race

00:06:24,120 --> 00:06:30,449
conditions resource leaks it works very

00:06:26,039 --> 00:06:34,800
well at this type of problems how to get

00:06:30,449 --> 00:06:37,949
it it's part of of the windbg preview to

00:06:34,800 --> 00:06:40,780
set and here you have a link on on the

00:06:37,949 --> 00:06:43,840
post that has how to install it

00:06:40,780 --> 00:06:46,270
video how to use it channel 9 there's a

00:06:43,840 --> 00:06:48,550
sticker on one of the sides of the of

00:06:46,270 --> 00:06:50,860
the laptop for that but instead of

00:06:48,550 --> 00:06:53,590
explaining a lot of of you know what it

00:06:50,860 --> 00:06:59,740
is and how to do it let's go for them

00:06:53,590 --> 00:07:01,870
all so James Thank You Jordy so yes some

00:06:59,740 --> 00:07:03,700
things are much easier to show than to

00:07:01,870 --> 00:07:05,590
talk about so I'm going to walk through

00:07:03,700 --> 00:07:07,720
two demos of using time travel debugging

00:07:05,590 --> 00:07:09,280
in the first example I'm going to show

00:07:07,720 --> 00:07:11,290
how you can record execution of a

00:07:09,280 --> 00:07:12,880
process and then take the trace that is

00:07:11,290 --> 00:07:15,400
produced and actually debug it in the

00:07:12,880 --> 00:07:18,100
debugger so the first thing that you're

00:07:15,400 --> 00:07:19,360
going to need to do is open windbg as an

00:07:18,100 --> 00:07:21,010
administrator so you have to have it

00:07:19,360 --> 00:07:23,169
open as an administrator in order to

00:07:21,010 --> 00:07:25,900
record a process if you've never used

00:07:23,169 --> 00:07:28,120
when dbg before this is it if you have

00:07:25,900 --> 00:07:29,440
used windbg before this may look a

00:07:28,120 --> 00:07:31,960
little different than what you're used

00:07:29,440 --> 00:07:33,820
to so this is a few weeks ago we

00:07:31,960 --> 00:07:37,510
released the first preview of this new

00:07:33,820 --> 00:07:39,160
windbg UI so it's we're trying to make

00:07:37,510 --> 00:07:40,360
some major user interface improvements

00:07:39,160 --> 00:07:42,430
that should hopefully be a lot easier to

00:07:40,360 --> 00:07:43,720
use but it uses the same debugger engine

00:07:42,430 --> 00:07:45,850
under the hood so if you're familiar

00:07:43,720 --> 00:07:47,500
with you know a bunch of windbg commands

00:07:45,850 --> 00:07:49,540
all of that works you know just as well

00:07:47,500 --> 00:07:51,190
as it did in the old one we're really

00:07:49,540 --> 00:07:52,960
happy that we've made some big steps

00:07:51,190 --> 00:07:54,400
forward with windbg here and now that

00:07:52,960 --> 00:07:56,229
we're adding the reverse debugging we're

00:07:54,400 --> 00:08:00,370
looking forward to making a lot of steps

00:07:56,229 --> 00:08:01,990
backward as well so what I'm going to do

00:08:00,370 --> 00:08:04,240
is I'm going to go to the file menu and

00:08:01,990 --> 00:08:05,470
we have two options here that support

00:08:04,240 --> 00:08:07,510
time travel debugging so we can either

00:08:05,470 --> 00:08:09,669
launch a new program or we can attach to

00:08:07,510 --> 00:08:11,169
a running program so I want to run my

00:08:09,669 --> 00:08:14,830
own little test program so I'm going to

00:08:11,169 --> 00:08:17,410
pick launch executable and I'm going to

00:08:14,830 --> 00:08:19,900
type in the name of my program which

00:08:17,410 --> 00:08:21,400
I've conveniently named test XE and then

00:08:19,900 --> 00:08:23,530
I'm going to check this record process

00:08:21,400 --> 00:08:25,030
with time travel debugging now when I

00:08:23,530 --> 00:08:26,650
click OK what's going to happen is the

00:08:25,030 --> 00:08:27,970
debugger will run this program and it

00:08:26,650 --> 00:08:30,340
will be recording everything that it

00:08:27,970 --> 00:08:31,870
does it won't the debugger won't be

00:08:30,340 --> 00:08:33,610
attached to the program it's just going

00:08:31,870 --> 00:08:37,349
to be letting it run normally with the

00:08:33,610 --> 00:08:39,760
recording active so I'll click OK and

00:08:37,349 --> 00:08:41,320
we'll see the program start up and it's

00:08:39,760 --> 00:08:44,800
just a little test program so it prints

00:08:41,320 --> 00:08:46,150
out some strings and then returns I'm

00:08:44,800 --> 00:08:48,930
going to open the source file so we can

00:08:46,150 --> 00:08:48,930
take a look at it

00:08:49,320 --> 00:08:53,820
and so we can see here just this very

00:08:51,810 --> 00:08:56,190
simple program in our main function we

00:08:53,820 --> 00:08:58,110
have a vector of strings we iterate over

00:08:56,190 --> 00:09:00,210
the first ten letters of the alphabet we

00:08:58,110 --> 00:09:01,380
create a string for each letter we print

00:09:00,210 --> 00:09:02,910
it so we have something interesting to

00:09:01,380 --> 00:09:05,130
look at while we're running the program

00:09:02,910 --> 00:09:06,390
we add the string to the vector and then

00:09:05,130 --> 00:09:07,650
we sleep for a little while so that the

00:09:06,390 --> 00:09:10,620
program actually takes a little time to

00:09:07,650 --> 00:09:11,970
run and doesn't exit immediately the

00:09:10,620 --> 00:09:14,910
first thing to note is that when you

00:09:11,970 --> 00:09:16,590
open a trace it starts off at the very

00:09:14,910 --> 00:09:18,420
beginning of where you started recording

00:09:16,590 --> 00:09:20,880
so here we can see we're very early in

00:09:18,420 --> 00:09:23,790
the execution of the process now I want

00:09:20,880 --> 00:09:24,720
to get us into the into the main

00:09:23,790 --> 00:09:26,250
function so I'm going to add a

00:09:24,720 --> 00:09:29,940
breakpoint at the end of the loop and

00:09:26,250 --> 00:09:31,470
I'm just going to click go and so what

00:09:29,940 --> 00:09:34,260
the debugger has now done is it's

00:09:31,470 --> 00:09:35,850
replayed execution of the program to the

00:09:34,260 --> 00:09:38,340
first point that it hits that breakpoint

00:09:35,850 --> 00:09:39,810
so we can see in the stack window we're

00:09:38,340 --> 00:09:41,700
inside of the main function which is

00:09:39,810 --> 00:09:43,200
where the breakpoint is and we can see

00:09:41,700 --> 00:09:45,030
in the locals window we can actually see

00:09:43,200 --> 00:09:46,200
all of the local variables just like we

00:09:45,030 --> 00:09:47,460
would if we were debugging a live

00:09:46,200 --> 00:09:48,900
program so we can see the current

00:09:47,460 --> 00:09:51,150
characters a we're in the first

00:09:48,900 --> 00:09:54,720
iteration of this loop and there's one

00:09:51,150 --> 00:09:57,240
string inside of the vector so if we go

00:09:54,720 --> 00:09:58,800
you know a couple more times we can see

00:09:57,240 --> 00:10:00,420
it advances through the program and it

00:09:58,800 --> 00:10:03,150
just keeps hitting that debug or that

00:10:00,420 --> 00:10:05,550
breakpoint over and over again so as a

00:10:03,150 --> 00:10:09,300
few things to point out here the first

00:10:05,550 --> 00:10:11,910
is that so all of the visualizations so

00:10:09,300 --> 00:10:13,740
for example windbg use is the same natf

00:10:11,910 --> 00:10:15,720
is visualizers that Visual Studio does

00:10:13,740 --> 00:10:17,670
so you get all of the rich you know

00:10:15,720 --> 00:10:19,680
ability to inspect STL containers here I

00:10:17,670 --> 00:10:21,210
mean this is a vector of strings looking

00:10:19,680 --> 00:10:23,970
at that just in raw memory can be rather

00:10:21,210 --> 00:10:26,940
tedious and painful now the other thing

00:10:23,970 --> 00:10:28,410
is that all of the debug debugger

00:10:26,940 --> 00:10:30,450
commands are used to with live process

00:10:28,410 --> 00:10:32,820
generally work so for example we have a

00:10:30,450 --> 00:10:35,550
G command to go forward one step or one

00:10:32,820 --> 00:10:36,990
that will run the program and you can

00:10:35,550 --> 00:10:39,990
see that we've advanced again to the

00:10:36,990 --> 00:10:41,610
next time that that breakpoint is hit in

00:10:39,990 --> 00:10:43,050
general most of the commands are used to

00:10:41,610 --> 00:10:44,730
using will work the one set of things

00:10:43,050 --> 00:10:46,230
you can't do is you can't do anything

00:10:44,730 --> 00:10:47,760
that would change the state of the

00:10:46,230 --> 00:10:49,980
program because again the programs not

00:10:47,760 --> 00:10:52,890
executing right now we're just replaying

00:10:49,980 --> 00:10:56,310
what already happened finally I wanted

00:10:52,890 --> 00:10:59,070
to note here that you'll notice that you

00:10:56,310 --> 00:11:00,630
don't actually see the console window so

00:10:59,070 --> 00:11:01,920
when we ran the program originally you

00:11:00,630 --> 00:11:02,460
could see the console window printing

00:11:01,920 --> 00:11:04,410
out the TEC

00:11:02,460 --> 00:11:06,470
the reason for that is when we replay

00:11:04,410 --> 00:11:08,250
the program or when we replay the trace

00:11:06,470 --> 00:11:09,960
everything is contained within the

00:11:08,250 --> 00:11:11,550
debugger so we don't actually do any of

00:11:09,960 --> 00:11:13,950
the side-effects that the program had so

00:11:11,550 --> 00:11:15,390
for example if it did any ion the disk

00:11:13,950 --> 00:11:17,040
or on the network we're not going to

00:11:15,390 --> 00:11:18,870
actually go back and try and read read

00:11:17,040 --> 00:11:21,180
those files or do that network i/o again

00:11:18,870 --> 00:11:22,620
which is very important additionally if

00:11:21,180 --> 00:11:25,020
while you were running your program and

00:11:22,620 --> 00:11:26,700
tracing at your computer lit on fire and

00:11:25,020 --> 00:11:28,110
you somehow salvaged the trace don't

00:11:26,700 --> 00:11:29,640
worry if you run it in the debugger your

00:11:28,110 --> 00:11:33,630
computer isn't going to you know catch

00:11:29,640 --> 00:11:35,310
on fire a second time so all of that is

00:11:33,630 --> 00:11:36,899
well and good but this is a reverse

00:11:35,310 --> 00:11:39,690
debugger so we also want to be able to

00:11:36,899 --> 00:11:40,920
well reverse execution so you can see

00:11:39,690 --> 00:11:43,050
here on the ribbon we have the normal

00:11:40,920 --> 00:11:45,149
flow control buttons to go and step into

00:11:43,050 --> 00:11:46,920
and we also have for time travel

00:11:45,149 --> 00:11:49,230
debugging traces reverse flow control

00:11:46,920 --> 00:11:52,050
buttons so we can go back or step into

00:11:49,230 --> 00:11:53,670
back so if I click the go back what it

00:11:52,050 --> 00:11:55,410
will do is it will be as if it replays

00:11:53,670 --> 00:11:57,630
the program backwards and it'll stop

00:11:55,410 --> 00:11:59,520
wherever the previous stop was so in

00:11:57,630 --> 00:12:01,470
this case it'll stop the previous time

00:11:59,520 --> 00:12:04,380
that this breakpoint was hit so if I

00:12:01,470 --> 00:12:05,820
click that you'll see we're still at the

00:12:04,380 --> 00:12:07,320
breakpoint we've just hit it the

00:12:05,820 --> 00:12:08,760
previous time that it was hit so in the

00:12:07,320 --> 00:12:10,500
locals window you can see instead of the

00:12:08,760 --> 00:12:12,300
current letter being D it's now C

00:12:10,500 --> 00:12:15,150
there's only three elements in the

00:12:12,300 --> 00:12:17,190
vector whereas there were four before so

00:12:15,150 --> 00:12:18,779
we had a G command in the command window

00:12:17,190 --> 00:12:20,940
that would let the program go forward

00:12:18,779 --> 00:12:22,920
there's an equivalent G - that goes

00:12:20,940 --> 00:12:24,720
backwards so if I run that we're now

00:12:22,920 --> 00:12:27,630
again in the previous iteration of the

00:12:24,720 --> 00:12:30,390
loop if you're familiar with using the P

00:12:27,630 --> 00:12:33,240
and T commands for stepping there's also

00:12:30,390 --> 00:12:36,870
P and P - and T - commands for stepping

00:12:33,240 --> 00:12:38,580
in Reverse so those are the basics of

00:12:36,870 --> 00:12:42,750
how time travel debugging works in the

00:12:38,580 --> 00:12:45,990
debugger but it's a lot more interesting

00:12:42,750 --> 00:12:49,740
if we look at how to actually debug a

00:12:45,990 --> 00:12:51,089
real bug so to that end I thought since

00:12:49,740 --> 00:12:52,709
we were the first breakout session I

00:12:51,089 --> 00:12:54,209
would welcome you all to the conference

00:12:52,709 --> 00:12:56,940
so I little I wrote a little program to

00:12:54,209 --> 00:12:58,380
print out a greeting for you so we can

00:12:56,940 --> 00:13:01,079
see here it says hello everyone and

00:12:58,380 --> 00:13:06,180
welcome to CPP con 2017 enjoy the

00:13:01,079 --> 00:13:10,440
conference so consider yourself welcomed

00:13:06,180 --> 00:13:14,339
oh it also seems to have crashed that's

00:13:10,440 --> 00:13:16,620
kind of unfortunate so thankfully I have

00:13:14,339 --> 00:13:18,210
a crash dump for this that we can take a

00:13:16,620 --> 00:13:19,440
look at so I'm going to open up that

00:13:18,210 --> 00:13:24,089
crash dump and we'll see if we can

00:13:19,440 --> 00:13:25,560
figure out what went wrong so I'll open

00:13:24,089 --> 00:13:27,480
the crash dump that we had for that and

00:13:25,560 --> 00:13:29,190
I'll look at the stack window because

00:13:27,480 --> 00:13:31,470
hopefully it'll show us where the the

00:13:29,190 --> 00:13:34,940
problem occurred and I see we're inside

00:13:31,470 --> 00:13:38,910
of a bunch of exception handling and

00:13:34,940 --> 00:13:44,850
then I see here that doesn't look like

00:13:38,910 --> 00:13:47,820
any of our code and nope can't hmm this

00:13:44,850 --> 00:13:49,680
is not a lot of information here so I

00:13:47,820 --> 00:13:51,750
also saw this bug happened this morning

00:13:49,680 --> 00:13:53,580
so I also recorded a trace so I'm gonna

00:13:51,750 --> 00:13:56,580
go and open the trace and see if we can

00:13:53,580 --> 00:13:58,260
debug it a little easier so this is the

00:13:56,580 --> 00:14:00,300
trace I recorded earlier you can open it

00:13:58,260 --> 00:14:03,029
there's that open trace option on the

00:14:00,300 --> 00:14:04,290
start on the file menu and again when we

00:14:03,029 --> 00:14:07,050
open the trace it starts off at the

00:14:04,290 --> 00:14:08,640
beginning of the trace so one thing that

00:14:07,050 --> 00:14:10,380
you can do if you want to move to

00:14:08,640 --> 00:14:14,160
another location we have a bang TT

00:14:10,380 --> 00:14:15,779
command so I can run bang TT and one

00:14:14,160 --> 00:14:17,670
option is you can pass it a percentage

00:14:15,779 --> 00:14:19,190
so I'm going to pass 100% which will

00:14:17,670 --> 00:14:21,750
move it to the end of the program and

00:14:19,190 --> 00:14:24,029
what I wanted to point out here is where

00:14:21,750 --> 00:14:26,490
you know this shows you we're in almost

00:14:24,029 --> 00:14:28,470
the exact same place we were in in the

00:14:26,490 --> 00:14:30,510
crash dump so again the program was

00:14:28,470 --> 00:14:31,890
crashing so you know that this is where

00:14:30,510 --> 00:14:34,380
we would expect the end of the trace to

00:14:31,890 --> 00:14:34,770
be as well and I can move back to the

00:14:34,380 --> 00:14:38,540
beginning

00:14:34,770 --> 00:14:41,550
using bang TT with zero to go back to 0%

00:14:38,540 --> 00:14:44,070
so since the program crashed I'm going

00:14:41,550 --> 00:14:45,690
to assume that it's because an exception

00:14:44,070 --> 00:14:47,040
occurred and the exception was not

00:14:45,690 --> 00:14:48,870
handled in the program I don't know if

00:14:47,040 --> 00:14:51,180
it was a C++ exception or something else

00:14:48,870 --> 00:14:53,070
but chances are it was an exception and

00:14:51,180 --> 00:14:54,779
so I want to find where during execution

00:14:53,070 --> 00:14:56,339
of the program that exception occurred

00:14:54,779 --> 00:14:59,550
and to do that I'm going to use a

00:14:56,339 --> 00:15:01,079
feature of the of the debugger a

00:14:59,550 --> 00:15:03,089
relatively new feature called the

00:15:01,079 --> 00:15:05,430
debugger data model so the data model

00:15:03,089 --> 00:15:07,260
provides a uniform and simple way to get

00:15:05,430 --> 00:15:08,820
all sorts of information about the thing

00:15:07,260 --> 00:15:11,490
that you're debugging in this case the

00:15:08,820 --> 00:15:13,470
trace so I'm going to use the DX command

00:15:11,490 --> 00:15:15,150
which is used to query the data model

00:15:13,470 --> 00:15:17,970
and I'm going to look at the current

00:15:15,150 --> 00:15:20,420
process which is kind of one of the

00:15:17,970 --> 00:15:22,649
route each things that you can look at

00:15:20,420 --> 00:15:24,240
so in here we can see the name of the

00:15:22,649 --> 00:15:26,250
program while we were tracing it is

00:15:24,240 --> 00:15:28,709
greeting XE that was the name of my test

00:15:26,250 --> 00:15:30,360
program we can see the process idea that

00:15:28,709 --> 00:15:32,430
it had while it was running and then we

00:15:30,360 --> 00:15:34,740
can see a bunch of other information

00:15:32,430 --> 00:15:35,910
that we can expand now the information

00:15:34,740 --> 00:15:37,740
we're looking for is time travel

00:15:35,910 --> 00:15:41,100
debugging civics I'm going to expand

00:15:37,740 --> 00:15:42,569
this TTD node here and then we're

00:15:41,100 --> 00:15:45,420
looking for an exception event so I'm

00:15:42,569 --> 00:15:48,000
going to expand the events list so the

00:15:45,420 --> 00:15:50,009
events list will have an event in it for

00:15:48,000 --> 00:15:51,930
every time that a dll is loaded or

00:15:50,009 --> 00:15:53,730
unloaded in the process it'll have an

00:15:51,930 --> 00:15:55,649
event for any time a thread was created

00:15:53,730 --> 00:15:56,970
or terminated and then it'll have an

00:15:55,649 --> 00:16:00,300
event for every exception that was

00:15:56,970 --> 00:16:02,160
raised so if we see here there's one

00:16:00,300 --> 00:16:04,290
exception in the list so that's probably

00:16:02,160 --> 00:16:05,970
what we're looking for so I'm going to

00:16:04,290 --> 00:16:07,680
click that entry and then click

00:16:05,970 --> 00:16:10,380
exception to see the exception specific

00:16:07,680 --> 00:16:11,759
properties of it so we can see here it

00:16:10,380 --> 00:16:12,899
was a hardware exception so it was

00:16:11,759 --> 00:16:15,120
something that was actually raised by

00:16:12,899 --> 00:16:17,339
the CPU it wasn't a C++ exception or

00:16:15,120 --> 00:16:18,779
some other kind of software exception we

00:16:17,339 --> 00:16:21,240
can see the program counter where the

00:16:18,779 --> 00:16:23,459
exception occurred we can see the the

00:16:21,240 --> 00:16:25,170
exception code so in this case I know

00:16:23,459 --> 00:16:27,180
this is the exception code for an access

00:16:25,170 --> 00:16:28,920
violation so it's likely that our

00:16:27,180 --> 00:16:30,420
program either tried to read write or

00:16:28,920 --> 00:16:32,790
execute some memory we didn't have

00:16:30,420 --> 00:16:34,680
proper access to but most importantly

00:16:32,790 --> 00:16:37,079
also has this position field which tells

00:16:34,680 --> 00:16:38,550
us the exact location during execution

00:16:37,079 --> 00:16:41,399
of the program where the exception

00:16:38,550 --> 00:16:43,649
occurred so what I can do is I can click

00:16:41,399 --> 00:16:45,149
this time-travel link which will

00:16:43,649 --> 00:16:47,760
actually take us directly to that point

00:16:45,149 --> 00:16:49,290
so that's move to the debugger so we're

00:16:47,760 --> 00:16:50,699
now looking exactly at the exact point

00:16:49,290 --> 00:16:54,089
where the exception was raised during

00:16:50,699 --> 00:16:55,589
execution of the program now we can see

00:16:54,089 --> 00:16:57,149
here in the stack window unfortunately

00:16:55,589 --> 00:16:58,860
it still doesn't tell us where it

00:16:57,149 --> 00:17:00,149
happened we can see that instruction

00:16:58,860 --> 00:17:02,069
pointer which was the instruction

00:17:00,149 --> 00:17:03,389
pointer where the exception occurred but

00:17:02,069 --> 00:17:04,860
the debugger hasn't been able to decode

00:17:03,389 --> 00:17:06,600
it it hasn't been able to tell us like

00:17:04,860 --> 00:17:08,790
what function it was in or even just

00:17:06,600 --> 00:17:11,309
what dll that was in so that's not

00:17:08,790 --> 00:17:14,010
particularly useful additionally I

00:17:11,309 --> 00:17:15,959
noticed that the the stack pointer here

00:17:14,010 --> 00:17:17,669
and the base pointer are pointing to two

00:17:15,959 --> 00:17:20,280
completely different locations in memory

00:17:17,669 --> 00:17:22,020
so between these two things I'm kind of

00:17:20,280 --> 00:17:23,699
guessing this was a stack corruption so

00:17:22,020 --> 00:17:25,230
someone over ran a buffer on the stack

00:17:23,699 --> 00:17:27,600
or otherwise corrupted something on the

00:17:25,230 --> 00:17:30,030
stack and then when a call when they

00:17:27,600 --> 00:17:32,010
returned from the function that ended up

00:17:30,030 --> 00:17:33,280
corrupting the CPU State with an invalid

00:17:32,010 --> 00:17:37,060
instruction pointer and

00:17:33,280 --> 00:17:38,530
address so you know from our crash dump

00:17:37,060 --> 00:17:39,880
a we wouldn't have even gotten to this

00:17:38,530 --> 00:17:41,350
point like it would have been very

00:17:39,880 --> 00:17:43,660
difficult for us to figure out what was

00:17:41,350 --> 00:17:45,520
going on here now if we had a live repro

00:17:43,660 --> 00:17:47,350
it might be inconsistent it could be

00:17:45,520 --> 00:17:48,940
very difficult to you know to figure out

00:17:47,350 --> 00:17:50,620
from that we don't have either of those

00:17:48,940 --> 00:17:52,240
we have a trace we know exactly what the

00:17:50,620 --> 00:17:54,940
program did and so we can just walk

00:17:52,240 --> 00:17:56,800
backwards and see what happened so in

00:17:54,940 --> 00:17:59,020
this case I want to get back to before

00:17:56,800 --> 00:18:00,520
the CPU state was corrupted so before

00:17:59,020 --> 00:18:03,760
that return statement you know loaded

00:18:00,520 --> 00:18:06,160
that invalid instruction pointer so that

00:18:03,760 --> 00:18:07,810
we can look at kind of get an idea of

00:18:06,160 --> 00:18:09,160
where the exception happened now I think

00:18:07,810 --> 00:18:10,990
that happened recently so I'm just going

00:18:09,160 --> 00:18:13,570
to step back a few times until we get a

00:18:10,990 --> 00:18:16,600
reasonable looking context so I'll step

00:18:13,570 --> 00:18:19,300
back once and that didn't change so I'm

00:18:16,600 --> 00:18:21,040
going to step back a second time and you

00:18:19,300 --> 00:18:22,540
can see now we've stepped backwards the

00:18:21,040 --> 00:18:24,370
next instruction that the debugger would

00:18:22,540 --> 00:18:26,830
execute is a return instruction so we've

00:18:24,370 --> 00:18:28,330
stepped back to before the return and so

00:18:26,830 --> 00:18:29,860
we see now that the instruction pointer

00:18:28,330 --> 00:18:31,720
the debugger now knows where we are

00:18:29,860 --> 00:18:34,570
weren't where we are we're inside of the

00:18:31,720 --> 00:18:36,040
main function the base pointer is still

00:18:34,570 --> 00:18:37,800
incorrect though because we haven't

00:18:36,040 --> 00:18:39,790
stepped back to before that was

00:18:37,800 --> 00:18:43,750
corrupted so I'm just going to step back

00:18:39,790 --> 00:18:45,220
once more and now we can see most of the

00:18:43,750 --> 00:18:48,820
stack and we can see we're on the last

00:18:45,220 --> 00:18:50,560
line of the of the main function I mean

00:18:48,820 --> 00:18:52,570
we still can't see our caller and the

00:18:50,560 --> 00:18:54,760
reason for that is that we step back to

00:18:52,570 --> 00:18:55,930
before the CPU state was corrupted but

00:18:54,760 --> 00:18:57,910
we still haven't found where the stack

00:18:55,930 --> 00:19:01,240
itself was corrupted so the the return

00:18:57,910 --> 00:19:02,860
address is still incorrect now I'm just

00:19:01,240 --> 00:19:04,270
curious so I'm gonna now that we have

00:19:02,860 --> 00:19:06,430
our base pointer I'm curious what's

00:19:04,270 --> 00:19:08,470
there on the stack now we'd expect there

00:19:06,430 --> 00:19:10,120
to be two pointers there would expect

00:19:08,470 --> 00:19:12,070
the instruction pointer to be there and

00:19:10,120 --> 00:19:13,810
we'd expect the previous frames base

00:19:12,070 --> 00:19:15,100
pointer so I'm going to open up the

00:19:13,810 --> 00:19:18,660
memory window and just copy that address

00:19:15,100 --> 00:19:21,610
in and take a look at what's there that

00:19:18,660 --> 00:19:22,930
does not look like pointers that looks

00:19:21,610 --> 00:19:25,140
like the end of the string I printed out

00:19:22,930 --> 00:19:27,550
earlier and if we scroll up a little bit

00:19:25,140 --> 00:19:29,260
we can see yes there's the rest of the

00:19:27,550 --> 00:19:32,410
string so definitely we've corrupted the

00:19:29,260 --> 00:19:34,840
stack somewhere so the trick now is to

00:19:32,410 --> 00:19:36,070
figure out where did that happen and so

00:19:34,840 --> 00:19:37,750
what I'm going to do is I'm going to use

00:19:36,070 --> 00:19:39,970
a breakpoint and then run the program

00:19:37,750 --> 00:19:41,700
backwards and have that breakpoint

00:19:39,970 --> 00:19:44,170
stopped on the exact point where the

00:19:41,700 --> 00:19:46,030
where we corrupted the stack so to do

00:19:44,170 --> 00:19:46,380
that I'm going to use this be a command

00:19:46,030 --> 00:19:49,320
witch

00:19:46,380 --> 00:19:53,400
break on access I'm interested only in

00:19:49,320 --> 00:19:54,660
rights to the 4-byte location starting

00:19:53,400 --> 00:19:56,790
at that base address so basically

00:19:54,660 --> 00:20:00,120
whoever writes to that pointer this will

00:19:56,790 --> 00:20:03,510
stop and at that point all I have to do

00:20:00,120 --> 00:20:05,130
is click go back and we've now stopped

00:20:03,510 --> 00:20:07,770
at the exact instruction that corrupted

00:20:05,130 --> 00:20:09,990
that pointer and we can see so it's

00:20:07,770 --> 00:20:11,610
inside of the string copy function which

00:20:09,990 --> 00:20:12,810
is expected we were copying you know

00:20:11,610 --> 00:20:15,120
some string into this buffer on the

00:20:12,810 --> 00:20:16,650
stack I expect the bug isn't in the

00:20:15,120 --> 00:20:18,360
string copy function I used to work on

00:20:16,650 --> 00:20:19,770
the C runtime and I'm pretty sure we

00:20:18,360 --> 00:20:22,020
didn't have bugs in that particular C

00:20:19,770 --> 00:20:24,420
runtime function so I'm going to look in

00:20:22,020 --> 00:20:26,100
this get CPP Con greeting function which

00:20:24,420 --> 00:20:29,250
is the first function in our program on

00:20:26,100 --> 00:20:30,750
the stack so we can see in here this

00:20:29,250 --> 00:20:33,450
function just takes a wide character

00:20:30,750 --> 00:20:35,460
buffer and the size of the buffer it has

00:20:33,450 --> 00:20:38,400
the welcome message and then it copies

00:20:35,460 --> 00:20:40,620
that message into the buffer we can see

00:20:38,400 --> 00:20:42,590
in the locals window we can see the

00:20:40,620 --> 00:20:47,790
message points to the complete message

00:20:42,590 --> 00:20:48,900
we can see that the buffer has only part

00:20:47,790 --> 00:20:50,640
of the message and the reason is that

00:20:48,900 --> 00:20:52,260
we've stopped partially weaith partway

00:20:50,640 --> 00:20:55,050
through the copying of the message into

00:20:52,260 --> 00:20:57,660
the buffer and then we can see that the

00:20:55,050 --> 00:21:02,070
size of the buffer is allegedly a

00:20:57,660 --> 00:21:03,540
hundred characters or hex 64 so I'm

00:21:02,070 --> 00:21:05,130
going to guess that that's not correct

00:21:03,540 --> 00:21:06,540
given that we've overrun the actual

00:21:05,130 --> 00:21:10,440
buffer so I'm going to look at our

00:21:06,540 --> 00:21:12,660
caller and see what it passed in so we

00:21:10,440 --> 00:21:15,570
can see here the buffer actually only

00:21:12,660 --> 00:21:17,790
has 50 characters hmm well there's our

00:21:15,570 --> 00:21:19,290
problem and the problem is well I

00:21:17,790 --> 00:21:21,330
accidentally passed sizeof greeting

00:21:19,290 --> 00:21:22,620
instead of greeting dot size so I passed

00:21:21,330 --> 00:21:25,800
the number of bytes instead of the

00:21:22,620 --> 00:21:28,790
number of characters so whoops I'm gonna

00:21:25,800 --> 00:21:28,790
blame my code reviewers

00:21:29,600 --> 00:21:34,919
but actually here the so with this

00:21:33,389 --> 00:21:36,330
little test program it's only 20 lines

00:21:34,919 --> 00:21:37,830
of code like we could easily have gone

00:21:36,330 --> 00:21:38,940
and just looked at the code and diagnose

00:21:37,830 --> 00:21:40,769
this and figure out what was going on

00:21:38,940 --> 00:21:42,389
but in a large program you know

00:21:40,769 --> 00:21:45,630
debugging this kind of thing especially

00:21:42,389 --> 00:21:47,429
if it's a hard to repro bug or if it

00:21:45,630 --> 00:21:48,750
only occurs occasionally or if you're

00:21:47,429 --> 00:21:50,669
just getting crash dumps from the field

00:21:48,750 --> 00:21:52,019
this can be extremely tedious and

00:21:50,669 --> 00:21:53,759
difficult to debug so time travel

00:21:52,019 --> 00:21:55,350
debugging you know works just as well

00:21:53,759 --> 00:21:57,360
with large programs as it does with

00:21:55,350 --> 00:21:59,789
small ones and geordie will be showing

00:21:57,360 --> 00:22:06,179
an example in a minute of debugging a

00:21:59,789 --> 00:22:07,679
large program so so in our first demo I

00:22:06,179 --> 00:22:09,600
showed you how you can actually record a

00:22:07,679 --> 00:22:11,129
process using the debugger I showed how

00:22:09,600 --> 00:22:12,600
you can step forward and backwards that

00:22:11,129 --> 00:22:15,149
you can use all the same commands you're

00:22:12,600 --> 00:22:17,279
used to using with debugging live

00:22:15,149 --> 00:22:21,090
processes with the exception of things

00:22:17,279 --> 00:22:23,490
that modify the the state of the program

00:22:21,090 --> 00:22:24,929
in the second example I showed you this

00:22:23,490 --> 00:22:26,879
debugger data model that provides you a

00:22:24,929 --> 00:22:28,200
very rich way of querying information

00:22:26,879 --> 00:22:30,389
about the process and you'll see more of

00:22:28,200 --> 00:22:32,070
that later in our in our upcoming demos

00:22:30,389 --> 00:22:34,320
I showed you how you can find events

00:22:32,070 --> 00:22:36,090
easily so we were very quickly able to

00:22:34,320 --> 00:22:37,679
find the exception and navigate right to

00:22:36,090 --> 00:22:39,929
that point during the execution of the

00:22:37,679 --> 00:22:41,340
program and then I finally showed how

00:22:39,929 --> 00:22:43,379
you can use memory breakpoints to

00:22:41,340 --> 00:22:45,480
quickly find who last modified something

00:22:43,379 --> 00:22:47,070
which is often the thing that we do most

00:22:45,480 --> 00:22:49,590
with these traces right like you see

00:22:47,070 --> 00:22:51,509
some data you say hmm how did that get

00:22:49,590 --> 00:22:53,100
there well this makes it very easy to go

00:22:51,509 --> 00:22:54,690
and find that right there's you don't

00:22:53,100 --> 00:22:56,789
have to go hunting around and see all

00:22:54,690 --> 00:22:58,379
the places that might riped and try and

00:22:56,789 --> 00:23:00,029
divine where they came from you can

00:22:58,379 --> 00:23:02,899
actually go directly to the location

00:23:00,029 --> 00:23:07,830
where where that right happened and and

00:23:02,899 --> 00:23:11,279
find it directly so with that Jordi is

00:23:07,830 --> 00:23:15,090
going to show a much more I guess large

00:23:11,279 --> 00:23:17,490
example thank you James

00:23:15,090 --> 00:23:19,200
so we wanted to show you an example with

00:23:17,490 --> 00:23:21,419
production code code that is used

00:23:19,200 --> 00:23:22,860
normally so we peaked at the chakra

00:23:21,419 --> 00:23:26,940
engine this is the JavaScript engine

00:23:22,860 --> 00:23:28,379
that is used in edge-on in IE and I need

00:23:26,940 --> 00:23:29,909
an excuse to put the console debugger

00:23:28,379 --> 00:23:31,559
here since I'm a console debugger user

00:23:29,909 --> 00:23:33,090
so we are going to them the chakra

00:23:31,559 --> 00:23:35,820
engine inside of the debugger the

00:23:33,090 --> 00:23:39,779
debugger scriptable in JavaScript and we

00:23:35,820 --> 00:23:40,669
are going to just look at a back in

00:23:39,779 --> 00:23:42,980
chakra

00:23:40,669 --> 00:23:45,139
that way so what we did was inject a

00:23:42,980 --> 00:23:46,669
back in the chakra engine that is not

00:23:45,139 --> 00:23:48,889
that different from the box that

00:23:46,669 --> 00:23:50,600
happened normally in production except

00:23:48,889 --> 00:23:52,190
it has a nice common next to it when we

00:23:50,600 --> 00:23:56,389
find it it will be obvious that we are

00:23:52,190 --> 00:24:03,019
their brawn click so with that I'm going

00:23:56,389 --> 00:24:07,159
to launch the debugger convene you in

00:24:03,019 --> 00:24:12,470
the debuggers folder and I'm going to

00:24:07,159 --> 00:24:16,789
run this life first so when the debugger

00:24:12,470 --> 00:24:18,109
comes up I'm going to just use the

00:24:16,789 --> 00:24:19,730
console debugger is the same debugger we

00:24:18,109 --> 00:24:29,299
were using in the console and I'm going

00:24:19,730 --> 00:24:33,320
to load the JavaScript engine that has

00:24:29,299 --> 00:24:37,220
the back injected in it so let me put

00:24:33,320 --> 00:24:40,970
the backslash here just in case it loads

00:24:37,220 --> 00:24:43,159
it and then I'm going to run and a

00:24:40,970 --> 00:24:44,779
script a JavaScript script that all it

00:24:43,159 --> 00:24:46,489
does is allocate some memory use some

00:24:44,779 --> 00:24:47,809
memory and for some garbage collection

00:24:46,489 --> 00:24:49,279
so I just put some pressure on the

00:24:47,809 --> 00:24:55,340
garbage collector it really doesn't do

00:24:49,279 --> 00:24:56,929
much more than that and okay it has

00:24:55,340 --> 00:25:00,470
loaded the script and it has a secure

00:24:56,929 --> 00:25:03,710
eight second time okay this third time

00:25:00,470 --> 00:25:06,739
it crashed and if we looked at it it's

00:25:03,710 --> 00:25:10,909
an access violation we see here that is

00:25:06,739 --> 00:25:13,970
trying to read from this awful memory

00:25:10,909 --> 00:25:15,859
location here which is - - probably not

00:25:13,970 --> 00:25:23,210
the right address and we see an a stack

00:25:15,859 --> 00:25:25,850
that is quite intimidating in fact okay

00:25:23,210 --> 00:25:27,859
this is memory memory recycler realloc

00:25:25,850 --> 00:25:30,590
if I have to figure out where I got this

00:25:27,859 --> 00:25:32,419
- - from this color stack is going to be

00:25:30,590 --> 00:25:34,789
painful in particular garbage collection

00:25:32,419 --> 00:25:37,940
bugs to have the root cause usually at a

00:25:34,789 --> 00:25:39,799
distance at a distance from the side

00:25:37,940 --> 00:25:42,200
effect in fact if you took a dump from

00:25:39,799 --> 00:25:43,909
this and look for this - - pattern you

00:25:42,200 --> 00:25:45,919
will actually not find it that much into

00:25:43,909 --> 00:25:47,779
the trace into the into the dump it's

00:25:45,919 --> 00:25:51,200
not there so that makes things a little

00:25:47,779 --> 00:25:52,740
bit harder let's repeat this case now

00:25:51,200 --> 00:25:54,330
with brick

00:25:52,740 --> 00:25:57,240
holding a trace so what I'm going to do

00:25:54,330 --> 00:26:02,550
is do the same thing I'm just going to

00:25:57,240 --> 00:26:03,929
record it and when I launch it what you

00:26:02,550 --> 00:26:05,400
will see is that there is some overhead

00:26:03,929 --> 00:26:09,900
with the record in fact the debugger has

00:26:05,400 --> 00:26:11,880
not yet come up if I have time at the

00:26:09,900 --> 00:26:17,010
end I will show you a case where things

00:26:11,880 --> 00:26:18,330
are a lot of overhead still usable but a

00:26:17,010 --> 00:26:20,120
lot of overhead let me do the same

00:26:18,330 --> 00:26:25,050
things as before

00:26:20,120 --> 00:26:28,770
Jia's provider DLL load the guy that has

00:26:25,050 --> 00:26:34,920
the back let's run the script that we

00:26:28,770 --> 00:26:37,380
were running before and you can see it's

00:26:34,920 --> 00:26:38,910
a little bit as lower and despite this

00:26:37,380 --> 00:26:40,440
as I said this is used and more than

00:26:38,910 --> 00:26:42,240
half the support cases from escalation

00:26:40,440 --> 00:26:44,220
engineers and that was before the

00:26:42,240 --> 00:26:48,600
performance improvements that we did in

00:26:44,220 --> 00:26:50,850
the consumption side so it crashed like

00:26:48,600 --> 00:26:53,220
the other one it's indexing so for

00:26:50,850 --> 00:26:55,230
expediency I'm going to debug this same

00:26:53,220 --> 00:26:57,240
thing that I have recorded on an an

00:26:55,230 --> 00:26:59,850
optimized trace there is an upcoming

00:26:57,240 --> 00:27:01,559
Channel 9 video I think comes out next

00:26:59,850 --> 00:27:03,720
week is on post-production where we

00:27:01,559 --> 00:27:05,190
debug this both optimized and on

00:27:03,720 --> 00:27:07,620
optimized so you can see that it works

00:27:05,190 --> 00:27:09,240
on both cases this is a trace of the

00:27:07,620 --> 00:27:12,720
recording and optimized so it makes more

00:27:09,240 --> 00:27:14,580
C++ debugging and James already showed

00:27:12,720 --> 00:27:16,260
us that we can look at events to find

00:27:14,580 --> 00:27:17,760
the exception so I'm going to do it

00:27:16,260 --> 00:27:21,390
differently which is just tell the

00:27:17,760 --> 00:27:24,480
debugger to go and it will stop at the

00:27:21,390 --> 00:27:26,850
exception is you know first chance

00:27:24,480 --> 00:27:30,480
exception this exception may be handled

00:27:26,850 --> 00:27:32,429
ok to show to you guys a little bit how

00:27:30,480 --> 00:27:38,090
this also works the other direction and

00:27:32,429 --> 00:27:41,340
is let me go to the end of the trace and

00:27:38,090 --> 00:27:43,530
go backwards G - and we are stopped on

00:27:41,340 --> 00:27:46,530
the same spot so that that's a little

00:27:43,530 --> 00:27:46,950
bit of how it it work forwards and

00:27:46,530 --> 00:27:49,320
backwards

00:27:46,950 --> 00:27:52,110
everything works normally as before we

00:27:49,320 --> 00:27:54,809
have this wonderful minus 2 here in fact

00:27:52,110 --> 00:27:56,820
it's the disk pointer here - - let's go

00:27:54,809 --> 00:27:58,290
back a little bit and see if I can

00:27:56,820 --> 00:28:02,900
figure out where this value comes from

00:27:58,290 --> 00:28:06,120
some tea - to go back or if you prefer

00:28:02,900 --> 00:28:06,660
press the button in the UI now here we

00:28:06,120 --> 00:28:10,440
have the

00:28:06,660 --> 00:28:13,740
the C++ expression main block main block

00:28:10,440 --> 00:28:16,530
is also minus 2 so that DX command that

00:28:13,740 --> 00:28:18,510
James was talking to us about can be

00:28:16,530 --> 00:28:22,080
used to also look at the local variables

00:28:18,510 --> 00:28:25,350
main block and it has a C++ in text

00:28:22,080 --> 00:28:27,000
parser so the unprecedent sign in C++

00:28:25,350 --> 00:28:29,370
gives us the address the ampersand sign

00:28:27,000 --> 00:28:32,610
will give us the address so this is the

00:28:29,370 --> 00:28:34,590
address of that -2 value so I'm going to

00:28:32,610 --> 00:28:37,470
do the same thing that James was doing

00:28:34,590 --> 00:28:40,049
put a breakpoint eight bytes ba when

00:28:37,470 --> 00:28:41,640
someone writes these eight bytes on this

00:28:40,049 --> 00:28:44,669
address and I'm going to ask the

00:28:41,640 --> 00:28:46,799
debugger to go backwards and what this

00:28:44,669 --> 00:28:49,830
does is it stops at the spot where we

00:28:46,799 --> 00:28:51,630
wrote the value now memory breakpoints

00:28:49,830 --> 00:28:54,299
when you're debugging on a processor a

00:28:51,630 --> 00:28:56,070
stop at the instruction after the action

00:28:54,299 --> 00:28:58,650
took place is the same here so this is

00:28:56,070 --> 00:29:01,409
instruction after the right happened if

00:28:58,650 --> 00:29:02,490
I do wanna step backwards now we are at

00:29:01,409 --> 00:29:05,580
the instruction where this thing

00:29:02,490 --> 00:29:07,380
happened which is member lock will get

00:29:05,580 --> 00:29:09,780
the value assigned and in fact you see

00:29:07,380 --> 00:29:12,630
mem block has the previous value still

00:29:09,780 --> 00:29:15,270
here I don't see free object list so let

00:29:12,630 --> 00:29:23,370
me explain that this pointer o is this

00:29:15,270 --> 00:29:27,960
pointer membership fine DX free object

00:29:23,370 --> 00:29:30,570
list this would work or the X this free

00:29:27,960 --> 00:29:33,929
object list the same thing and as before

00:29:30,570 --> 00:29:36,390
an ampersand boo get me the address so

00:29:33,929 --> 00:29:39,000
now I can do the same thing as before

00:29:36,390 --> 00:29:41,610
put a breakpoint on these address that I

00:29:39,000 --> 00:29:43,940
have here and as the debugger to go

00:29:41,610 --> 00:29:46,770
backwards know a couple of observations

00:29:43,940 --> 00:29:48,510
the others I just was looking at these

00:29:46,770 --> 00:29:51,630
first address is no longer of interest

00:29:48,510 --> 00:29:53,460
to me this is the value that now has the

00:29:51,630 --> 00:29:56,549
previous value is no longer the -2 so

00:29:53,460 --> 00:29:58,740
I'm going to disable this and the other

00:29:56,549 --> 00:30:00,809
thing is the debugger when it's running

00:29:58,740 --> 00:30:02,640
life has a limit of how many Hardware

00:30:00,809 --> 00:30:05,460
break points how many access breakpoints

00:30:02,640 --> 00:30:07,289
you can put in Intel processors tends to

00:30:05,460 --> 00:30:09,120
be for now the processors may be

00:30:07,289 --> 00:30:10,710
different with debugging a trace you

00:30:09,120 --> 00:30:12,919
have no limits you can put a hundred of

00:30:10,710 --> 00:30:15,150
these very points and it will just work

00:30:12,919 --> 00:30:17,220
so that's another advantage of debugging

00:30:15,150 --> 00:30:18,470
trees and another reason why it's is

00:30:17,220 --> 00:30:22,669
used often

00:30:18,470 --> 00:30:24,380
of the Microsoft as before we stopped

00:30:22,669 --> 00:30:27,890
now I stopped on the instruction after

00:30:24,380 --> 00:30:30,380
so let me go wanna step backwards and I

00:30:27,890 --> 00:30:31,010
see this here I look at man block it has

00:30:30,380 --> 00:30:36,289
an address

00:30:31,010 --> 00:30:38,360
I see free object list and if I it has

00:30:36,289 --> 00:30:41,559
the new value the OL value not the new

00:30:38,360 --> 00:30:44,510
value let me stack into the function

00:30:41,559 --> 00:30:47,659
this is the same function as before let

00:30:44,510 --> 00:30:50,179
me look at the values here it's minus 1

00:30:47,659 --> 00:30:55,220
naught minus 2 but if I look at this

00:30:50,179 --> 00:30:57,140
piece of code here in fact if we go back

00:30:55,220 --> 00:31:01,070
we can we can we can see it that's how

00:30:57,140 --> 00:31:03,169
the minus 2 came to be okay so now the

00:31:01,070 --> 00:31:06,110
question is who put this minus 1 here

00:31:03,169 --> 00:31:09,500
let me copy this address let me step

00:31:06,110 --> 00:31:13,130
backwards let me put a sorry let me put

00:31:09,500 --> 00:31:15,440
a breakpoint and type correctly that the

00:31:13,130 --> 00:31:16,789
term that mean is the breakpoints let me

00:31:15,440 --> 00:31:19,100
remove the last one I checked because

00:31:16,789 --> 00:31:23,210
it's no longer of interest and go

00:31:19,100 --> 00:31:26,870
backwards and now here I see the value

00:31:23,210 --> 00:31:29,539
minus 1 which looks promising and I see

00:31:26,870 --> 00:31:32,240
this demo introduced back so that's the

00:31:29,539 --> 00:31:34,190
back that we were looking for and to be

00:31:32,240 --> 00:31:35,840
clear I am not familiar with this code

00:31:34,190 --> 00:31:37,100
base I have only used it to prepare for

00:31:35,840 --> 00:31:38,419
these the emotive person that did the

00:31:37,100 --> 00:31:40,659
JavaScript integration on the debugger

00:31:38,419 --> 00:31:43,280
in our team is not me someone else and

00:31:40,659 --> 00:31:44,990
we made something that was hard and

00:31:43,280 --> 00:31:46,700
difficult quite easy to do it was

00:31:44,990 --> 00:31:49,490
mechanical let's just follow the recipe

00:31:46,700 --> 00:31:51,650
and it's not always that easy but it

00:31:49,490 --> 00:31:57,049
often is this easy to debug backs this

00:31:51,650 --> 00:31:59,570
way now if we had to do this normally

00:31:57,049 --> 00:32:01,640
for those that have enough memory this

00:31:59,570 --> 00:32:04,640
stack looks nothing like the stack that

00:32:01,640 --> 00:32:07,159
we had on the crash in fact this crash

00:32:04,640 --> 00:32:09,409
happens over a hundred million

00:32:07,159 --> 00:32:10,789
instructions before the root cause so

00:32:09,409 --> 00:32:14,330
this is not going to be something that

00:32:10,789 --> 00:32:16,909
you can do manually by hand the

00:32:14,330 --> 00:32:19,150
old-fashioned way so let me stop

00:32:16,909 --> 00:32:22,490
debugging let me go back to the slides

00:32:19,150 --> 00:32:24,140
let's take a look what we have seen is

00:32:22,490 --> 00:32:26,330
that there is overhead when we record

00:32:24,140 --> 00:32:28,490
you get a lot of value out of it but

00:32:26,330 --> 00:32:30,530
there is some price to pay I said inside

00:32:28,490 --> 00:32:32,360
of Microsoft we use this a lot so we

00:32:30,530 --> 00:32:33,910
find the price reasonable

00:32:32,360 --> 00:32:36,230
and it's something we will be working on

00:32:33,910 --> 00:32:38,120
if we have time at the end I will show

00:32:36,230 --> 00:32:40,010
an a scenario where it's much more clear

00:32:38,120 --> 00:32:42,410
that there is overhead how problems

00:32:40,010 --> 00:32:44,720
become easy I said I have not seen this

00:32:42,410 --> 00:32:46,880
codebase before I just followed a

00:32:44,720 --> 00:32:48,860
mechanical recipe of just follow the

00:32:46,880 --> 00:32:50,840
breadcrumbs backwards till you find the

00:32:48,860 --> 00:32:53,270
place where it does not look like the

00:32:50,840 --> 00:32:55,100
right thing to do and the other thing is

00:32:53,270 --> 00:32:56,510
I had one trace to do these I did not

00:32:55,100 --> 00:32:57,710
have to restart the debug or over and

00:32:56,510 --> 00:32:59,570
over every time I learned something

00:32:57,710 --> 00:33:02,480
where this came from or since these

00:32:59,570 --> 00:33:10,160
backwards us go and find it and so with

00:33:02,480 --> 00:33:18,980
that Ken thanks Joey that was pretty

00:33:10,160 --> 00:33:21,050
awesome like that okay so okay so what

00:33:18,980 --> 00:33:23,420
we've seen so far is a pretty familiar

00:33:21,050 --> 00:33:26,240
debugging experience setting breakpoints

00:33:23,420 --> 00:33:30,590
looking at the stack executing forwards

00:33:26,240 --> 00:33:33,080
now executing backwards but time travel

00:33:30,590 --> 00:33:35,930
debugging allows us to look at code

00:33:33,080 --> 00:33:39,110
execution another way it lets us look at

00:33:35,930 --> 00:33:42,860
it as a queryable data source so what do

00:33:39,110 --> 00:33:45,890
I mean by that imagine you had a sequel

00:33:42,860 --> 00:33:47,660
database table where each row was a

00:33:45,890 --> 00:33:50,570
point in time in the in your execution

00:33:47,660 --> 00:33:52,610
and that there was a set of columns that

00:33:50,570 --> 00:33:54,650
met represented the register state of

00:33:52,610 --> 00:33:57,050
your processor and the contents of your

00:33:54,650 --> 00:33:59,300
address space that would be a really big

00:33:57,050 --> 00:34:02,690
table but you could imagine doing

00:33:59,300 --> 00:34:05,390
queries that would find a specific call

00:34:02,690 --> 00:34:08,780
patterns memory access patterns thing

00:34:05,390 --> 00:34:10,790
like things like that what we have done

00:34:08,780 --> 00:34:16,490
is we have enabled this kind of querying

00:34:10,790 --> 00:34:18,560
in time travel debugging another kind of

00:34:16,490 --> 00:34:21,560
way to think about it is if you've used

00:34:18,560 --> 00:34:24,260
the system journals tool process monitor

00:34:21,560 --> 00:34:26,750
right you have a workflow of capturing

00:34:24,260 --> 00:34:29,240
activity in a file then you go to the

00:34:26,750 --> 00:34:30,860
filter and you narrow it down to your

00:34:29,240 --> 00:34:34,070
specific problem that you're interested

00:34:30,860 --> 00:34:37,870
in and we were trying to bring that kind

00:34:34,070 --> 00:34:42,290
of power to debugging your programs so

00:34:37,870 --> 00:34:44,240
to illustrate that we took a Windows SDK

00:34:42,290 --> 00:34:45,530
sample for a media player and we

00:34:44,240 --> 00:34:49,450
introduced a bug into it

00:34:45,530 --> 00:34:49,450
and so let's see what that looks like

00:34:50,110 --> 00:34:55,100
okay so imagine it's 4:00 p.m. on a

00:34:53,330 --> 00:34:58,610
Friday you're getting ready to go home

00:34:55,100 --> 00:35:00,560
and you get an email like this one I was

00:34:58,610 --> 00:35:03,370
trying to use your program and this is

00:35:00,560 --> 00:35:06,740
what I get and we see we have the

00:35:03,370 --> 00:35:09,230
dubious error message that operation

00:35:06,740 --> 00:35:12,220
completed successfully so how many

00:35:09,230 --> 00:35:13,910
people have seen this one in the wild I

00:35:12,220 --> 00:35:16,430
excellent excellent

00:35:13,910 --> 00:35:18,410
so all right well let's see if we can

00:35:16,430 --> 00:35:20,210
use time travel debugging to solve this

00:35:18,410 --> 00:35:28,340
quickly so we can get out of the office

00:35:20,210 --> 00:35:30,170
so we are going to go here so you know I

00:35:28,340 --> 00:35:31,490
could have asked Geordi for repro steps

00:35:30,170 --> 00:35:35,570
maybe he didn't remember what exactly

00:35:31,490 --> 00:35:37,520
what he did exactly or I could sit in

00:35:35,570 --> 00:35:40,160
this office and have him hover over me

00:35:37,520 --> 00:35:42,950
while I try to debug it which is kind of

00:35:40,160 --> 00:35:44,690
intimidating so I just asked him please

00:35:42,950 --> 00:35:49,120
send me a trace file and so he sent me a

00:35:44,690 --> 00:35:54,190
trace file and so let's open it up and

00:35:49,120 --> 00:35:57,440
see what it looks like and let's

00:35:54,190 --> 00:36:02,090
actually let's stop debugging just to

00:35:57,440 --> 00:36:07,430
make sure open it up and we'll close

00:36:02,090 --> 00:36:09,710
some of these old files there great so

00:36:07,430 --> 00:36:12,980
we're sitting at the start of the trace

00:36:09,710 --> 00:36:14,960
and I'm gonna start off by making an

00:36:12,980 --> 00:36:18,890
assumption that Geordi probably stopped

00:36:14,960 --> 00:36:21,020
recording after he saw the message box

00:36:18,890 --> 00:36:25,210
come up so I'm just gonna push the Go

00:36:21,020 --> 00:36:29,750
button and go to the end of the trace

00:36:25,210 --> 00:36:32,810
okay and so we look down at the stack

00:36:29,750 --> 00:36:35,270
and we see that the message box is still

00:36:32,810 --> 00:36:38,990
on the stack there so our theory was

00:36:35,270 --> 00:36:42,230
right and again this emphasizes the fact

00:36:38,990 --> 00:36:45,770
that you know when you have your repro

00:36:42,230 --> 00:36:47,120
captured and there's really no cost to

00:36:45,770 --> 00:36:49,010
like going past where you want to

00:36:47,120 --> 00:36:50,240
execute you can just test theories and

00:36:49,010 --> 00:36:52,610
if they don't work out you try something

00:36:50,240 --> 00:36:57,020
else so in this case the theory was

00:36:52,610 --> 00:36:59,210
right so let's take a look at what this

00:36:57,020 --> 00:37:03,260
code is doing when it calls

00:36:59,210 --> 00:37:07,430
messagebox will scroll up a little bit

00:37:03,260 --> 00:37:09,890
and so this is fairly typical code it it

00:37:07,430 --> 00:37:12,950
calls get last error to find out what

00:37:09,890 --> 00:37:14,960
the error code was it formats it using

00:37:12,950 --> 00:37:20,030
format message and then it displays it

00:37:14,960 --> 00:37:21,890
using message box now the fact that it

00:37:20,030 --> 00:37:24,849
says operation completed successfully

00:37:21,890 --> 00:37:28,010
that likely means the error code was 0

00:37:24,849 --> 00:37:32,589
we can prove that by using a standard

00:37:28,010 --> 00:37:35,030
windbg command GL e forget last error

00:37:32,589 --> 00:37:36,220
yep there it is operation completed

00:37:35,030 --> 00:37:41,089
successfully

00:37:36,220 --> 00:37:44,000
okay so let's see how queries can help

00:37:41,089 --> 00:37:50,200
us find this problem so the first thing

00:37:44,000 --> 00:37:53,240
so our basic idea is that in win32 a

00:37:50,200 --> 00:37:55,640
common pattern is when 8 api's fail they

00:37:53,240 --> 00:37:57,559
return false and if you want more

00:37:55,640 --> 00:37:59,930
information you have to call get last

00:37:57,559 --> 00:38:04,730
error to get the information via a more

00:37:59,930 --> 00:38:06,680
detailed error code now if you forget to

00:38:04,730 --> 00:38:09,349
call get last error soon enough e and

00:38:06,680 --> 00:38:11,299
you call some other win32 api it usually

00:38:09,349 --> 00:38:14,299
gets the error code gets set back to 0

00:38:11,299 --> 00:38:18,680
and you end up with lovely message boxes

00:38:14,299 --> 00:38:21,470
like that so what we're looking for is a

00:38:18,680 --> 00:38:23,859
error code that was returned that was

00:38:21,470 --> 00:38:27,020
non zero before message box was called

00:38:23,859 --> 00:38:32,809
so let's use queries and see what that

00:38:27,020 --> 00:38:35,150
looks like so for now I'm going to slide

00:38:32,809 --> 00:38:40,280
this over so you have plenty of room and

00:38:35,150 --> 00:38:41,930
I'm going to clear the console window so

00:38:40,280 --> 00:38:46,000
we access queries through the debugger

00:38:41,930 --> 00:38:49,549
data model that we talked about earlier

00:38:46,000 --> 00:38:50,750
yeah through the DX command and what

00:38:49,549 --> 00:38:53,809
we're going to do is we're going to

00:38:50,750 --> 00:38:57,730
capture all of the calls to get last

00:38:53,809 --> 00:39:00,559
error into message box and I'm going to

00:38:57,730 --> 00:39:02,450
assign it to a variable so that we can

00:39:00,559 --> 00:39:05,170
do some other things to it after it's

00:39:02,450 --> 00:39:11,330
ready so we're going to

00:39:05,170 --> 00:39:13,460
current session use the tab key to you

00:39:11,330 --> 00:39:19,910
have intellisense help us find some of

00:39:13,460 --> 00:39:31,220
this and I know Colonel bass has get

00:39:19,910 --> 00:39:37,400
last error and user 32 has message box W

00:39:31,220 --> 00:39:40,580
on the stack hit enter and it runs for a

00:39:37,400 --> 00:39:43,370
few seconds and it has it returns some

00:39:40,580 --> 00:39:45,640
results okay so that doesn't look like

00:39:43,370 --> 00:39:48,710
very interesting results so let's just

00:39:45,640 --> 00:39:53,150
clear the screen and display it as a

00:39:48,710 --> 00:39:56,870
table and to do that we use - G for the

00:39:53,150 --> 00:40:01,130
grid command and I'm going to use my

00:39:56,870 --> 00:40:02,900
previous variable and we can see this

00:40:01,130 --> 00:40:07,130
time that the results came up much

00:40:02,900 --> 00:40:10,720
quicker so it caches query results in

00:40:07,130 --> 00:40:15,370
memory as you execute them to save time

00:40:10,720 --> 00:40:17,570
okay so here's our table of information

00:40:15,370 --> 00:40:21,500
one of the things I noticed is look at

00:40:17,570 --> 00:40:23,510
all these zeros a lot of the times

00:40:21,500 --> 00:40:25,430
there's no error but code is continually

00:40:23,510 --> 00:40:28,640
calling get last error getting a zero

00:40:25,430 --> 00:40:30,170
and so that's a lot of noise we'd like

00:40:28,640 --> 00:40:33,950
to get that out of the way

00:40:30,170 --> 00:40:38,420
so let's filter out the zeros so I'm

00:40:33,950 --> 00:40:41,090
gonna clear the screen again and use the

00:40:38,420 --> 00:40:44,960
up arrow key to bring up a previous

00:40:41,090 --> 00:40:49,490
query and we'll add to this and so here

00:40:44,960 --> 00:40:51,830
we're going to use a link query and this

00:40:49,490 --> 00:40:58,250
is linked with a cue not a K this is not

00:40:51,830 --> 00:41:01,010
the linker and link is a a query

00:40:58,250 --> 00:41:02,930
technology that's common in c-sharp and

00:41:01,010 --> 00:41:07,130
we have more information about it on our

00:41:02,930 --> 00:41:09,680
blog if you haven't seen it before what

00:41:07,130 --> 00:41:11,120
we're gonna do is use the tab key we're

00:41:09,680 --> 00:41:14,470
going to do a where clause and we're

00:41:11,120 --> 00:41:14,470
gonna limit what we see

00:41:14,990 --> 00:41:20,790
and the where clause takes a lambda so

00:41:18,810 --> 00:41:25,170
I'm just gonna use X to represent one

00:41:20,790 --> 00:41:30,530
particular call and say okay I want to

00:41:25,170 --> 00:41:37,440
keep anything where the function name

00:41:30,530 --> 00:41:39,510
contains a message box because I noticed

00:41:37,440 --> 00:41:43,200
that message box returns zero we don't

00:41:39,510 --> 00:41:48,930
want to filter that out or the return

00:41:43,200 --> 00:41:50,690
value is not equal to zero okay so we'll

00:41:48,930 --> 00:41:54,900
do that

00:41:50,690 --> 00:41:58,320
okay now when we scroll up we don't see

00:41:54,900 --> 00:42:00,510
any zero error codes that's nice

00:41:58,320 --> 00:42:02,510
we actually filtered out about 90% of

00:42:00,510 --> 00:42:05,550
the calls in this particular trace file

00:42:02,510 --> 00:42:07,710
so now the other going back to what our

00:42:05,550 --> 00:42:10,320
goal was our goal was to find an error

00:42:07,710 --> 00:42:12,510
code that was set before message box was

00:42:10,320 --> 00:42:14,460
called and so what we need to do is sort

00:42:12,510 --> 00:42:17,670
these things by the time that they

00:42:14,460 --> 00:42:21,320
occurred in okay so I'm gonna move this

00:42:17,670 --> 00:42:24,630
green up arrow again so you can just

00:42:21,320 --> 00:42:27,570
refine things over time here and I'm

00:42:24,630 --> 00:42:30,420
gonna use an order by which is another

00:42:27,570 --> 00:42:33,930
link method that also takes a lambda and

00:42:30,420 --> 00:42:37,880
the lambda tells us which field we want

00:42:33,930 --> 00:42:45,690
to sort on so I'm gonna sort on the time

00:42:37,880 --> 00:42:48,630
start field okay and I also noticed that

00:42:45,690 --> 00:42:50,580
down here if you get it shows a hundred

00:42:48,630 --> 00:42:54,630
results by default and we see that

00:42:50,580 --> 00:42:57,170
there's some ellipsis here and so I'm

00:42:54,630 --> 00:43:00,840
gonna make one more refinement to this

00:42:57,170 --> 00:43:02,790
which is I'm gonna add a comma on the

00:43:00,840 --> 00:43:06,350
end and I'm just gonna say give me like

00:43:02,790 --> 00:43:10,470
a thousand results okay so now I have

00:43:06,350 --> 00:43:15,119
all of my results and now let's see if

00:43:10,470 --> 00:43:17,790
we can find the message box okay so I

00:43:15,119 --> 00:43:20,609
found the message box call and we see

00:43:17,790 --> 00:43:23,400
that before that the let first non zero

00:43:20,609 --> 00:43:27,000
error code was a - that's an interesting

00:43:23,400 --> 00:43:27,840
error code it's um it's go time travel

00:43:27,000 --> 00:43:30,660
there and

00:43:27,840 --> 00:43:35,060
take a look at what we got so we click

00:43:30,660 --> 00:43:43,200
on that and it shows us the time travel

00:43:35,060 --> 00:43:43,680
in here and there is my scroll out there

00:43:43,200 --> 00:43:46,200
it is

00:43:43,680 --> 00:43:49,140
Thank You scroll bar okay and we click

00:43:46,200 --> 00:43:53,550
on time travel and it takes us to the

00:43:49,140 --> 00:44:00,480
time travel position and we see our

00:43:53,550 --> 00:44:04,650
error completed successfully and let's

00:44:00,480 --> 00:44:06,210
go down see here click on the right one

00:44:04,650 --> 00:44:12,420
I don't think I think I missed the right

00:44:06,210 --> 00:44:15,020
the right one here clicking can be

00:44:12,420 --> 00:44:19,370
challenging at times

00:44:15,020 --> 00:44:19,370
let's go up to message box

00:44:23,960 --> 00:44:43,190
okay and we go to on file open and our

00:44:34,820 --> 00:44:48,320
file name 0 there that's not good oh I

00:44:43,190 --> 00:44:52,339
forgot the time thank you thank you okay

00:44:48,320 --> 00:44:55,580
all right this looks better so we do get

00:44:52,339 --> 00:44:58,280
last error and there's our system cannot

00:44:55,580 --> 00:45:00,770
find the file specified you see we're

00:44:58,280 --> 00:45:04,580
calling into the media player let's go

00:45:00,770 --> 00:45:07,190
to open file and we see that the file

00:45:04,580 --> 00:45:09,980
name was passed in with CP pecan demo

00:45:07,190 --> 00:45:13,640
dot txt that's not a very good media

00:45:09,980 --> 00:45:27,140
player oops in there Geordi okay so

00:45:13,640 --> 00:45:29,930
problem solved okay going back to the

00:45:27,140 --> 00:45:31,990
slides what we have learned is the

00:45:29,930 --> 00:45:34,400
nation I don't know how to open files

00:45:31,990 --> 00:45:36,200
send me a trace not a repro as we said

00:45:34,400 --> 00:45:38,240
before that that's something that works

00:45:36,200 --> 00:45:41,210
very well the power of queries and then

00:45:38,240 --> 00:45:46,070
a little bit of C sharp at CPP con no

00:45:41,210 --> 00:45:48,940
link so what's next

00:45:46,070 --> 00:45:51,410
what are we planning for the future

00:45:48,940 --> 00:45:52,880
improve our recording experience we

00:45:51,410 --> 00:45:54,800
talked there is some overhead we have

00:45:52,880 --> 00:45:56,480
done work from the days that the

00:45:54,800 --> 00:45:58,670
research set out to prove that this was

00:45:56,480 --> 00:46:01,280
doable to shipping on the performance of

00:45:58,670 --> 00:46:03,710
the of the replace ID on a couple of

00:46:01,280 --> 00:46:05,210
orders of magnitude improvement and the

00:46:03,710 --> 00:46:06,770
reason is people record for five minutes

00:46:05,210 --> 00:46:09,619
and they replay for four or five hours

00:46:06,770 --> 00:46:12,320
so cutting an hour out of those four was

00:46:09,619 --> 00:46:15,859
a bigger wind and cutting a minute out

00:46:12,320 --> 00:46:17,720
of five very powerful query support we

00:46:15,859 --> 00:46:19,790
want to invest that in data space

00:46:17,720 --> 00:46:21,589
heavily we want to do dynamic code

00:46:19,790 --> 00:46:23,089
analysis we have a trace that explains

00:46:21,589 --> 00:46:25,430
us everything that happened so we want

00:46:23,089 --> 00:46:28,160
to use it to find leaks or to find fleas

00:46:25,430 --> 00:46:32,119
double fries of use after free or this

00:46:28,160 --> 00:46:34,130
kind of stuff and then we want to add

00:46:32,119 --> 00:46:35,860
kernel level tracing support to these

00:46:34,130 --> 00:46:38,380
tools so you can

00:46:35,860 --> 00:46:41,020
Duke this on a driver that you are

00:46:38,380 --> 00:46:43,390
developing for Windows or whatever it

00:46:41,020 --> 00:46:44,500
happens to be if you want to know how we

00:46:43,390 --> 00:46:46,180
are going to do some of these things

00:46:44,500 --> 00:46:49,210
there is a clue at the bottom right hand

00:46:46,180 --> 00:46:52,780
side corner of the slide and with that

00:46:49,210 --> 00:46:57,670
I'm going to move to questions that I

00:46:52,780 --> 00:47:03,550
didn't save do you remember the

00:46:57,670 --> 00:47:06,880
questions Geordi yeah you forgot to save

00:47:03,550 --> 00:47:08,050
him again didn't you yes well with this

00:47:06,880 --> 00:47:10,300
happened a fair amount while we were

00:47:08,050 --> 00:47:13,180
practicing so I didn't tell you this but

00:47:10,300 --> 00:47:15,070
I I secretly recorded the no pass

00:47:13,180 --> 00:47:20,020
session when you were typing the

00:47:15,070 --> 00:47:27,370
questions so that we have a hope please

00:47:20,020 --> 00:47:31,420
okay okay all right I hope this works

00:47:27,370 --> 00:47:41,190
let's see here okay

00:47:31,420 --> 00:47:41,190
oh okay so we'll stop debugging here and

00:47:41,460 --> 00:47:46,740
open file

00:47:52,430 --> 00:48:09,570
documents down here and documents TV

00:48:07,830 --> 00:48:11,940
traces uh here we are

00:48:09,570 --> 00:48:15,510
so before I open this I just wanted to

00:48:11,940 --> 00:48:18,210
point out briefly you can see that when

00:48:15,510 --> 00:48:19,560
we when we launched notepad you might

00:48:18,210 --> 00:48:21,600
have noticed it took a little while to

00:48:19,560 --> 00:48:24,150
launch but the typing speed was pretty

00:48:21,600 --> 00:48:27,900
interactive and it produced a file

00:48:24,150 --> 00:48:31,620
that's roughly 200 megabytes that's not

00:48:27,900 --> 00:48:33,260
so bad it probably contains about on the

00:48:31,620 --> 00:48:36,060
order of 200 million instructions

00:48:33,260 --> 00:48:43,020
something like that so let's open the

00:48:36,060 --> 00:48:46,290
file and so what I did is I made a

00:48:43,020 --> 00:48:50,190
little JavaScript file that's going to

00:48:46,290 --> 00:48:54,390
try to dig out these dig out these

00:48:50,190 --> 00:49:00,900
things go down to here and we'll open up

00:48:54,390 --> 00:49:04,520
our JavaScript great and let's give

00:49:00,900 --> 00:49:04,520
ourselves some room to see the code here

00:49:05,060 --> 00:49:11,430
so this is a feature of windbg that you

00:49:08,820 --> 00:49:13,820
can actually write JavaScript and do

00:49:11,430 --> 00:49:15,900
imperative things like executing

00:49:13,820 --> 00:49:17,130
instructions immediately or you can

00:49:15,900 --> 00:49:19,440
actually extend the data model that

00:49:17,130 --> 00:49:23,340
we've been talking about so invoke

00:49:19,440 --> 00:49:26,190
script it's like Maine and C++ and debug

00:49:23,340 --> 00:49:30,750
logs just like printf so the basic idea

00:49:26,190 --> 00:49:33,480
is notepad uses a window edit control

00:49:30,750 --> 00:49:37,140
and the edit control holds a piece of

00:49:33,480 --> 00:49:40,830
locally alloc memory and so if notepad

00:49:37,140 --> 00:49:42,000
one and two load or save text from what

00:49:40,830 --> 00:49:45,150
you're typing it would have to be able

00:49:42,000 --> 00:49:47,520
to get at that memory and in Windows the

00:49:45,150 --> 00:49:51,330
way you get at that memory is through a

00:49:47,520 --> 00:49:53,370
message so I'll briefly show you you

00:49:51,330 --> 00:49:57,420
know we I have some code that finds the

00:49:53,370 --> 00:49:59,280
text handle that it remembers what

00:49:57,420 --> 00:50:01,820
position it's at so it can restore to

00:49:59,280 --> 00:50:06,590
that point when it's done

00:50:01,820 --> 00:50:08,750
and it finds the text locations where

00:50:06,590 --> 00:50:11,960
the text was updated and then does some

00:50:08,750 --> 00:50:13,970
simple things like appending to a vector

00:50:11,960 --> 00:50:17,540
finding unique strings and prints them

00:50:13,970 --> 00:50:19,700
out and in particular one to show you

00:50:17,540 --> 00:50:21,260
that you can do queries inside of

00:50:19,700 --> 00:50:23,960
JavaScript as well and it looks very

00:50:21,260 --> 00:50:26,480
similar to DX here we start with the

00:50:23,960 --> 00:50:31,010
host current session when we go to T TD

00:50:26,480 --> 00:50:35,000
calls look for send message and the Edit

00:50:31,010 --> 00:50:39,020
handle message which is parameter 1 of

00:50:35,000 --> 00:50:42,830
send message and then we do another

00:50:39,020 --> 00:50:46,670
query to find the memory and hopefully

00:50:42,830 --> 00:50:50,600
with for all got it right bring our yeah

00:50:46,670 --> 00:50:52,540
I met over and it says here are the

00:50:50,600 --> 00:50:54,770
unique lines from the notepad session

00:50:52,540 --> 00:50:56,930
this looks like the question we asked at

00:50:54,770 --> 00:51:05,240
the beginning so there you go Jordi

00:50:56,930 --> 00:51:06,710
thank you so before answering the

00:51:05,240 --> 00:51:09,260
questions let's go back to the slides

00:51:06,710 --> 00:51:12,890
for a moment and let's see what we learn

00:51:09,260 --> 00:51:14,270
on this can save the day again the

00:51:12,890 --> 00:51:16,070
debugger is our scriptable and now we

00:51:14,270 --> 00:51:17,810
did see sharp at the CPB con and are we

00:51:16,070 --> 00:51:19,880
doing JavaScript at the CPP con

00:51:17,810 --> 00:51:22,820
so apparently C++ is not the only

00:51:19,880 --> 00:51:26,210
language we can use now going back to

00:51:22,820 --> 00:51:30,400
the questions how does this differ from

00:51:26,210 --> 00:51:32,320
our our single core versus multi-core

00:51:30,400 --> 00:51:34,780
different characteristics on the

00:51:32,320 --> 00:51:37,370
performance overhead during record

00:51:34,780 --> 00:51:38,450
depends on the type of program and the

00:51:37,370 --> 00:51:40,460
number of course you have a new machine

00:51:38,450 --> 00:51:43,310
one will be better than the other and

00:51:40,460 --> 00:51:46,370
the overhead that you see but the basic

00:51:43,310 --> 00:51:48,410
principles are the same on how this

00:51:46,370 --> 00:51:51,710
works is these windows only or which

00:51:48,410 --> 00:51:54,590
version of Windows actually this is on

00:51:51,710 --> 00:51:56,990
the windbg preview so you actually have

00:51:54,590 --> 00:51:59,180
to have an up-to-date version of Windows

00:51:56,990 --> 00:52:01,070
10 this will be available on the kids

00:51:59,180 --> 00:52:02,540
then some of the restrictions will be

00:52:01,070 --> 00:52:06,260
lifted but right now is an up-to-date

00:52:02,540 --> 00:52:09,080
version of Windows 10 ok and with that

00:52:06,260 --> 00:52:12,340
now for real let's let's open the floor

00:52:09,080 --> 00:52:12,340
for questions and

00:52:17,600 --> 00:52:23,390
since let me let me show and what I'm

00:52:20,960 --> 00:52:25,460
going to do is use this moment to also

00:52:23,390 --> 00:52:27,410
show a case where our overhead is

00:52:25,460 --> 00:52:29,930
significant so that you guys see that

00:52:27,410 --> 00:52:32,360
sometimes in notepad you saw a Stipe and

00:52:29,930 --> 00:52:34,280
that came as fine or even on the

00:52:32,360 --> 00:52:37,160
debugger you saw as you use this so if

00:52:34,280 --> 00:52:39,170
I'm going to use lunch actually meat

00:52:37,160 --> 00:52:41,420
lunch a notepad this way and I'm sorry

00:52:39,170 --> 00:52:43,610
from here lunch executable click this

00:52:41,420 --> 00:52:46,130
check box record process with time

00:52:43,610 --> 00:52:49,160
travel debugging and that will launch in

00:52:46,130 --> 00:52:53,510
this case the debugger if I do something

00:52:49,160 --> 00:52:57,500
as uninteresting as this and click on

00:52:53,510 --> 00:53:01,670
the record it should launch notepad and

00:52:57,500 --> 00:53:04,580
now typing works normally however if I

00:53:01,670 --> 00:53:06,470
want to show the Open File dialog this

00:53:04,580 --> 00:53:08,270
will take a while and the reason is

00:53:06,470 --> 00:53:10,880
desire log does a ton of work this run

00:53:08,270 --> 00:53:14,690
dialog launches 14 threads calculates

00:53:10,880 --> 00:53:18,140
icons and thumbnails 8 actually you know

00:53:14,690 --> 00:53:22,360
it's still usable but there is some

00:53:18,140 --> 00:53:22,360
overhead sometimes and as we said that's

00:53:25,120 --> 00:53:30,830
none this will record in fact it's one

00:53:28,730 --> 00:53:32,480
of the conditions we had since we

00:53:30,830 --> 00:53:33,710
support code that sometimes we haven't

00:53:32,480 --> 00:53:35,420
written at Microsoft we don't have

00:53:33,710 --> 00:53:37,520
symbols for it or we don't have anything

00:53:35,420 --> 00:53:39,230
these works just fine yeah so that's

00:53:37,520 --> 00:53:40,640
just the normal notepad like that's

00:53:39,230 --> 00:53:42,950
installed with Windows it's not no

00:53:40,640 --> 00:53:44,480
special modification the only thing with

00:53:42,950 --> 00:53:46,730
it is we creat it and a start menu

00:53:44,480 --> 00:53:53,240
shortcut to launch it onto the recorder

00:53:46,730 --> 00:53:54,950
but that that was it no you need symbols

00:53:53,240 --> 00:53:56,630
if you want to debug with symbols but I

00:53:54,950 --> 00:53:59,810
have the back without symbols just fine

00:53:56,630 --> 00:54:02,210
with this and this is a normal machine

00:53:59,810 --> 00:54:03,740
with public symbols of Microsoft so we

00:54:02,210 --> 00:54:05,720
have the public symbols of of notepad

00:54:03,740 --> 00:54:10,010
sorry there was a question on the back

00:54:05,720 --> 00:54:11,390
in the middle people could go to the

00:54:10,010 --> 00:54:13,850
microphones that would be easiest to

00:54:11,390 --> 00:54:14,840
keep repeating questions in fact if you

00:54:13,850 --> 00:54:17,770
don't mind I'm going to change my

00:54:14,840 --> 00:54:17,770
glasses so I see you

00:54:18,870 --> 00:54:24,560
how what size of files are the traces

00:54:21,960 --> 00:54:28,530
like how much resources does that take

00:54:24,560 --> 00:54:31,140
so the size of the trace bear is by the

00:54:28,530 --> 00:54:32,520
number of instructions we execute the

00:54:31,140 --> 00:54:34,080
more instructions you distribute the

00:54:32,520 --> 00:54:35,460
better what we do is when we start

00:54:34,080 --> 00:54:38,130
recording we take a dump put all the

00:54:35,460 --> 00:54:40,680
oops a dump of the entire process so

00:54:38,130 --> 00:54:43,140
that is a participant and then on a

00:54:40,680 --> 00:54:46,650
steady record we do a bit per

00:54:43,140 --> 00:54:49,500
instruction okay but it will it will

00:54:46,650 --> 00:54:51,690
bury the open file dialog is actually

00:54:49,500 --> 00:54:53,370
disasters for us but there are other

00:54:51,690 --> 00:54:55,620
places where we can do much less than

00:54:53,370 --> 00:54:58,620
that but that's that's approximately

00:54:55,620 --> 00:55:00,660
case the overhead is mainly record this

00:54:58,620 --> 00:55:02,490
is some overhead replay some cases will

00:55:00,660 --> 00:55:06,780
be faster than life debugging some case

00:55:02,490 --> 00:55:09,390
is not and the overhead of the recorder

00:55:06,780 --> 00:55:10,890
is memory intensive right now we have

00:55:09,390 --> 00:55:32,490
work on the record site as we said to

00:55:10,890 --> 00:55:34,230
improve that no that was a fast I have

00:55:32,490 --> 00:55:38,240
actually two questions one of them can I

00:55:34,230 --> 00:55:43,170
attach the recorder while the process is

00:55:38,240 --> 00:55:45,450
executing so few notes you can attach to

00:55:43,170 --> 00:55:47,340
anything that you can debug pretty much

00:55:45,450 --> 00:55:49,320
there are a couple of corner cases but

00:55:47,340 --> 00:55:51,180
in general you can debug it you can you

00:55:49,320 --> 00:55:53,790
can you can attach to it or you can

00:55:51,180 --> 00:55:55,800
launch it you can attach to UWE

00:55:53,790 --> 00:55:57,570
processes you cannot not launch them

00:55:55,800 --> 00:56:00,600
under the tree search as yet the other

00:55:57,570 --> 00:56:04,140
thing to note is when you stop we

00:56:00,600 --> 00:56:05,970
terminate the process aha okay that's

00:56:04,140 --> 00:56:08,430
that's relevant we have a couple of work

00:56:05,970 --> 00:56:11,250
items to remove that but that's thank

00:56:08,430 --> 00:56:13,590
you and in general I also had a question

00:56:11,250 --> 00:56:16,470
what are the limitations so that we know

00:56:13,590 --> 00:56:18,150
what to not expect if you cannot evac

00:56:16,470 --> 00:56:20,670
the process we have actually done work

00:56:18,150 --> 00:56:23,610
to avoid us recording things that you

00:56:20,670 --> 00:56:24,990
cannot debug that means sometimes if you

00:56:23,610 --> 00:56:29,370
have antivirus software on your machine

00:56:24,990 --> 00:56:30,630
that blocks process right across we will

00:56:29,370 --> 00:56:33,210
not work you have to disable the

00:56:30,630 --> 00:56:36,599
antivirus software that makes any sense

00:56:33,210 --> 00:56:39,720
I'd also like to add if if you're using

00:56:36,599 --> 00:56:41,640
public symbols with queries right now it

00:56:39,720 --> 00:56:43,770
doesn't resolve the names it'll just say

00:56:41,640 --> 00:56:46,260
unknown symbols so that's another thing

00:56:43,770 --> 00:56:48,270
we need to fix if you know your own code

00:56:46,260 --> 00:56:51,990
where you have full PDB information it's

00:56:48,270 --> 00:56:54,109
no problem but like pulling out colonel

00:56:51,990 --> 00:57:27,780
bases name there

00:56:54,109 --> 00:57:30,240
today requires private symbols that will

00:57:27,780 --> 00:57:33,150
be a long question to answer

00:57:30,240 --> 00:57:37,140
movie at the table outside to answer it

00:57:33,150 --> 00:57:38,970
I have recorded this for hours but the

00:57:37,140 --> 00:57:41,880
traces come back really really really

00:57:38,970 --> 00:57:44,880
really big just just to set expectations

00:57:41,880 --> 00:57:49,380
we use it for honest on a change servers

00:57:44,880 --> 00:57:51,569
which are 64 gigs of RAM fully packed

00:57:49,380 --> 00:57:52,890
and it works but the overhead is is is

00:57:51,569 --> 00:57:55,440
measurable you will see it with the

00:57:52,890 --> 00:57:58,859
naked eye the overhead just just to set

00:57:55,440 --> 00:58:00,480
expectations since we've still have time

00:57:58,859 --> 00:58:02,819
but if not if you see people with these

00:58:00,480 --> 00:58:07,799
shirts you can ask them questions as

00:58:02,819 --> 00:58:10,020
well and just putting up here the other

00:58:07,799 --> 00:58:12,599
Microsoft talks so that you guys know

00:58:10,020 --> 00:58:14,700
where they are please I have two

00:58:12,599 --> 00:58:19,130
questions first of them is it possible

00:58:14,700 --> 00:58:21,510
to record on lead 3 2 seconds of

00:58:19,130 --> 00:58:25,950
application last time when the

00:58:21,510 --> 00:58:27,750
application working before crash you

00:58:25,950 --> 00:58:29,280
need to know how to stop a start

00:58:27,750 --> 00:58:30,809
recording but for example if you touch

00:58:29,280 --> 00:58:33,089
the debugger and you have a particular

00:58:30,809 --> 00:58:35,460
event and in the debugger then you do

00:58:33,089 --> 00:58:36,990
were to suspend the process and that's

00:58:35,460 --> 00:58:39,299
there are there are things to do there

00:58:36,990 --> 00:58:41,460
is an area where we will be making

00:58:39,299 --> 00:58:44,520
things easier for you I show the

00:58:41,460 --> 00:58:45,480
situation I start test and test agents

00:58:44,520 --> 00:58:48,089
and

00:58:45,480 --> 00:58:51,570
under debug intent when test crashed

00:58:48,089 --> 00:58:52,710
sometimes I need last seconds to

00:58:51,570 --> 00:58:54,300
understand what happened

00:58:52,710 --> 00:58:57,000
you still need to start recording

00:58:54,300 --> 00:58:58,260
yourself yeah you can start since you

00:58:57,000 --> 00:59:01,500
can attach you can start the recorder

00:58:58,260 --> 00:59:06,030
when you see fit and second question was

00:59:01,500 --> 00:59:08,339
about administrative rights is it

00:59:06,030 --> 00:59:12,420
possible to not use administratively is

00:59:08,339 --> 00:59:16,290
because test agents must be clean not at

00:59:12,420 --> 00:59:18,150
this moment in time we we have been

00:59:16,290 --> 00:59:19,800
talking inside of Microsoft on how to

00:59:18,150 --> 00:59:21,540
remove that requirement but right now we

00:59:19,800 --> 00:59:23,730
rely on a couple of ApS that require

00:59:21,540 --> 00:59:33,060
admin rights we are working through that

00:59:23,730 --> 00:59:37,530
okay so we are working with the visual

00:59:33,060 --> 00:59:39,030
studio team and the analyzing the

00:59:37,530 --> 00:59:40,950
product and how it would integrate if

00:59:39,030 --> 00:59:44,790
you have if you would like to give them

00:59:40,950 --> 00:59:47,250
feedback email TT d vs at microsoft.com

00:59:44,790 --> 00:59:49,040
and give them your your thoughts and

00:59:47,250 --> 00:59:52,319
they will be happy to hear about that

00:59:49,040 --> 00:59:54,839
and to be clear that's they expect

00:59:52,319 --> 01:00:04,349
someone to email them if if if if you

00:59:54,839 --> 01:00:06,500
want to that so please do sorry for

01:00:04,349 --> 01:00:06,500
those

01:00:13,500 --> 01:00:18,880
for those that did not hear that the the

01:00:16,330 --> 01:00:20,980
the person without the microphone if

01:00:18,880 --> 01:00:22,600
you've sent an email it will really

01:00:20,980 --> 01:00:24,910
increase the chances of this happening

01:00:22,600 --> 01:00:30,100
so please do if you want to see this

01:00:24,910 --> 01:00:32,080
happen thank you Andrew hello okay what

01:00:30,100 --> 01:00:33,100
sorry we're out of time I'm happy to

01:00:32,080 --> 01:00:35,700
answer questions but just to be clear

01:00:33,100 --> 01:00:35,700

YouTube URL: https://www.youtube.com/watch?v=l1YJTg_A914


