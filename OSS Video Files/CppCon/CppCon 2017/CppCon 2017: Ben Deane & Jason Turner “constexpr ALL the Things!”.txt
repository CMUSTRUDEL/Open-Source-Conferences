Title: CppCon 2017: Ben Deane & Jason Turner “constexpr ALL the Things!”
Publication date: 2017-10-05
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
constexpr: in C++11, a curiosity; in C++14, viable for more uses; now with added power, in C++17 will it become an important tool in the programmer's toolkit? 

In this talk we will examine the possibilities and power of constexpr and explore what can (and what should) be done at compile-time with C++17. We'll present techniques for building constexpr data structures and algorithms, and look at what the standard provides and where it can improve. We'll also explore constexpr use of user defined literals for expressive compile-time abstractions. 

Compile-time computation offers perhaps the ultimate zero-cost abstraction, and this talk attempts to gauge the power available with C++17 constexpr. 
— 
Ben Deane: Principal Software Engineer, Blizzard Entertainment

Ben has been writing games for almost 20 years, and in C++ for most of that. He is currently a Principal Engineer at Blizzard Entertainment where he works on the Battle.net team. He's always looking for useful new techniques in C++, and he likes functional programming.

Jason Turner: Developer, Trainer, Speaker

Host of C++Weekly https://www.youtube.com/c/JasonTurner-lefticus, Co-host of CppCast http://cppcast.com, Co-creator and maintainer of the embedded scripting language for C++, ChaiScript http://chaiscript.com, and author and curator of the forkable coding standards document http://cppbestpractices.com. 

I'm available for contracting and onsite training.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,120 --> 00:00:04,980
welcome to context brought all the

00:00:02,010 --> 00:00:07,680
things this as you I'm sure many of you

00:00:04,980 --> 00:00:09,360
know is Jason Turner he is a independent

00:00:07,680 --> 00:00:13,380
contractor and trainer working out of

00:00:09,360 --> 00:00:16,080
Denver he does C++ weekly on YouTube he

00:00:13,380 --> 00:00:18,900
is one of the co-hosts of CVP cast along

00:00:16,080 --> 00:00:21,900
with Rob oving he speaks at lots of

00:00:18,900 --> 00:00:24,840
conferences and he finds time to do also

00:00:21,900 --> 00:00:27,539
setting up sites and this is Ben Dean

00:00:24,840 --> 00:00:30,599
who is a principal engineer at Blizzard

00:00:27,539 --> 00:00:32,189
been working and gaming for 20 years

00:00:30,599 --> 00:00:33,930
most of it in C++

00:00:32,189 --> 00:00:35,520
he is a functional programming geek

00:00:33,930 --> 00:00:40,410
which will definitely come up in this

00:00:35,520 --> 00:00:42,530
talk a little a little and and you're on

00:00:40,410 --> 00:00:45,960
the battle got in that team that's right

00:00:42,530 --> 00:00:48,360
alright so in the interest of not hiding

00:00:45,960 --> 00:00:51,180
anything when I first heard about

00:00:48,360 --> 00:00:53,940
context bruh this is what an and about

00:00:51,180 --> 00:00:56,370
using the fine literals I thought this

00:00:53,940 --> 00:01:00,000
should be possible at some point can we

00:00:56,370 --> 00:01:01,920
embed JSON literals in C++ have them

00:01:00,000 --> 00:01:04,049
work at compile time and have them

00:01:01,920 --> 00:01:06,030
control configuration in code there's

00:01:04,049 --> 00:01:09,890
one example and this I think is a great

00:01:06,030 --> 00:01:12,390
bellwether for what concepts bro can do

00:01:09,890 --> 00:01:15,270
so when I first like I say when I first

00:01:12,390 --> 00:01:18,560
heard about context bruh and about used

00:01:15,270 --> 00:01:21,030
to find the tools I wanted to do this

00:01:18,560 --> 00:01:23,070
JSON the is ubiquitous JSON is used for

00:01:21,030 --> 00:01:26,880
a lot of things it's very useful it's

00:01:23,070 --> 00:01:29,159
very well known it's simple but it's

00:01:26,880 --> 00:01:33,380
also recursive so it's sufficiently

00:01:29,159 --> 00:01:33,380
interesting to try and do this with oh

00:01:34,939 --> 00:01:39,840
you want me to do yeah okay sorry we did

00:01:37,770 --> 00:01:42,630
this differently in aspect so of course

00:01:39,840 --> 00:01:44,369
the promise of Const expert is that we

00:01:42,630 --> 00:01:47,430
get runtime efficiency by moving things

00:01:44,369 --> 00:01:50,340
from runtime to compile time all so that

00:01:47,430 --> 00:01:52,290
we can simplify code through compile

00:01:50,340 --> 00:01:54,780
time computation so where we would have

00:01:52,290 --> 00:01:58,530
magic numbers in code perhaps we could

00:01:54,780 --> 00:02:00,060
now just write more expressive the more

00:01:58,530 --> 00:02:01,500
expressive expressions that we use to

00:02:00,060 --> 00:02:04,079
compute those magic numbers and they get

00:02:01,500 --> 00:02:05,790
done at compile time we don't need to

00:02:04,079 --> 00:02:07,409
muck about with a preprocessor to be

00:02:05,790 --> 00:02:12,150
sure of things not making into the

00:02:07,409 --> 00:02:13,650
runtime and less cross-platform pain is

00:02:12,150 --> 00:02:15,900
nice

00:02:13,650 --> 00:02:17,520
if you can move things into the compiler

00:02:15,900 --> 00:02:19,020
that were previously in some other step

00:02:17,520 --> 00:02:21,450
in your tool chain so if you can do

00:02:19,020 --> 00:02:23,250
things concept for wise now using the

00:02:21,450 --> 00:02:25,350
compiler rather than say generating code

00:02:23,250 --> 00:02:26,760
to produce your constants or whatever

00:02:25,350 --> 00:02:28,680
that's nice and if you're working

00:02:26,760 --> 00:02:32,820
cross-platform reducing steps in your

00:02:28,680 --> 00:02:35,670
tool chain is very nice

00:02:32,820 --> 00:02:36,990
so moving very quickly along just a

00:02:35,670 --> 00:02:40,470
quick recap of where we are with

00:02:36,990 --> 00:02:42,180
concepts were up till now so there have

00:02:40,470 --> 00:02:45,480
been three ages of course expert by my

00:02:42,180 --> 00:02:48,480
thinking C purpose 11 was very limited

00:02:45,480 --> 00:02:50,100
we had one return value per function we

00:02:48,480 --> 00:02:53,610
had to do everything with extreme

00:02:50,100 --> 00:02:56,430
recursion and we saw things like math

00:02:53,610 --> 00:02:58,830
functions FN v 1 string hashing so you

00:02:56,430 --> 00:03:00,300
may have seen this very kind of this

00:02:58,830 --> 00:03:04,980
linear recursive technique down the

00:03:00,300 --> 00:03:07,050
string something like that and then when

00:03:04,980 --> 00:03:08,610
super plus 14 comes along we get

00:03:07,050 --> 00:03:11,100
generalized concepts so we're no longer

00:03:08,610 --> 00:03:12,600
limited to this kind of very recursive

00:03:11,100 --> 00:03:14,720
technique we can write more

00:03:12,600 --> 00:03:17,610
straight-line C++ code that we used to

00:03:14,720 --> 00:03:18,840
and we get because of that we get you

00:03:17,610 --> 00:03:21,060
know custom concept but libraries

00:03:18,840 --> 00:03:24,870
appearing we get MoMA 3 hashing instead

00:03:21,060 --> 00:03:26,970
of F n V 1 hashing and now so now we're

00:03:24,870 --> 00:03:29,519
at the dawn of C + 17 and we have some

00:03:26,970 --> 00:03:32,250
more features available in context Perl

00:03:29,519 --> 00:03:33,810
and one of them is if Const X bruh and

00:03:32,250 --> 00:03:35,580
that's going to simplify is simplifying

00:03:33,810 --> 00:03:37,860
and we'll simplify meta programming a

00:03:35,580 --> 00:03:40,019
lot we get a lot of concepts for stuff

00:03:37,860 --> 00:03:42,269
in the STL in particular things like

00:03:40,019 --> 00:03:45,630
string view which are more or less borne

00:03:42,269 --> 00:03:47,730
into context perl world we get context /

00:03:45,630 --> 00:03:50,160
lambdas that is that the lambdas have

00:03:47,730 --> 00:03:54,540
their a function called operator now as

00:03:50,160 --> 00:03:56,489
Const exper and who knows we might get

00:03:54,540 --> 00:03:59,970
concepts for it that by default on a few

00:03:56,489 --> 00:04:03,840
things but one of the problems with

00:03:59,970 --> 00:04:06,780
context / up till now is that you can't

00:04:03,840 --> 00:04:08,100
tell when you are evaluating when you're

00:04:06,780 --> 00:04:09,540
in the evaluation of your function you

00:04:08,100 --> 00:04:12,709
can't tell whether you're being

00:04:09,540 --> 00:04:14,640
evaluated at compile time or at run time

00:04:12,709 --> 00:04:15,150
and this is something we'll touch on a

00:04:14,640 --> 00:04:17,010
bit later

00:04:15,150 --> 00:04:18,120
we'll come to talk about some proposals

00:04:17,010 --> 00:04:19,979
that deal with this and some other

00:04:18,120 --> 00:04:21,720
things concepts rise but this

00:04:19,979 --> 00:04:23,039
fundamentally is one of the main

00:04:21,720 --> 00:04:24,690
problems even if you write a nice

00:04:23,039 --> 00:04:26,610
concepts bro code if it doesn't get

00:04:24,690 --> 00:04:27,050
evaluated and assigned to a concept /

00:04:26,610 --> 00:04:28,550
variable

00:04:27,050 --> 00:04:30,020
there's no guarantee it'll happen at

00:04:28,550 --> 00:04:32,659
compile time when it might accidentally

00:04:30,020 --> 00:04:33,889
be emitted in your runtime and you can

00:04:32,659 --> 00:04:36,340
try things there are various things you

00:04:33,889 --> 00:04:39,650
can try like spin a on context furnace

00:04:36,340 --> 00:04:41,509
it tends to be a little bit brittle and

00:04:39,650 --> 00:04:43,789
you know certainly a lot more code than

00:04:41,509 --> 00:04:47,690
you probably want to take on but we'll

00:04:43,789 --> 00:04:49,220
touch on more stuff later on so take it

00:04:47,690 --> 00:04:53,990
away Jason for the next partner all

00:04:49,220 --> 00:04:56,120
right so this is effectively a JSON

00:04:53,990 --> 00:04:57,860
value that we want to be able to parse

00:04:56,120 --> 00:04:59,539
that we were just showing so we've got

00:04:57,860 --> 00:05:01,789
the problems of how do we represent JSON

00:04:59,539 --> 00:05:05,690
values and how do we parse them at

00:05:01,789 --> 00:05:10,580
compile time JSON is a discriminated

00:05:05,690 --> 00:05:15,259
union of null boolean number string and

00:05:10,580 --> 00:05:19,210
an array of values and also object types

00:05:15,259 --> 00:05:19,210
which is a map of string to the values

00:05:19,270 --> 00:05:24,110
so we're gonna need some sort of

00:05:21,500 --> 00:05:26,870
recursion in our parsing and we're going

00:05:24,110 --> 00:05:29,900
to need context for ways of dealing with

00:05:26,870 --> 00:05:31,009
string vector and map and well all that

00:05:29,900 --> 00:05:32,090
turned out to be a little bit easier

00:05:31,009 --> 00:05:35,900
than I think we're afraid it was going

00:05:32,090 --> 00:05:38,090
to be but we will get in there contacts

00:05:35,900 --> 00:05:41,990
for Strings now interestingly C++ 17

00:05:38,090 --> 00:05:43,250
adds standard string view I have a hard

00:05:41,990 --> 00:05:44,900
time with using this in a lot of

00:05:43,250 --> 00:05:49,610
constructs for context because I feel

00:05:44,900 --> 00:05:51,919
like it is you know it it's not intended

00:05:49,610 --> 00:05:54,440
for storing a string and we're talking

00:05:51,919 --> 00:06:01,849
about storing strings and it can only

00:05:54,440 --> 00:06:04,009
hold values we can't build strings so we

00:06:01,849 --> 00:06:05,389
need some way to pass and store strings

00:06:04,009 --> 00:06:07,940
in a general work with character string

00:06:05,389 --> 00:06:09,229
literals and so string view like I said

00:06:07,940 --> 00:06:10,849
it would technically work for some of

00:06:09,229 --> 00:06:12,650
these things again I feel like it mixes

00:06:10,849 --> 00:06:15,169
metaphors don't like using it for

00:06:12,650 --> 00:06:17,389
compile time stuff so we built up the

00:06:15,169 --> 00:06:21,319
static string class which looks like

00:06:17,389 --> 00:06:24,110
this which uses a templated array

00:06:21,319 --> 00:06:27,830
constructor to pull in the data from my

00:06:24,110 --> 00:06:31,219
character from my character literal that

00:06:27,830 --> 00:06:34,250
is and we can make all of our methods

00:06:31,219 --> 00:06:38,000
Const exper and it's pretty

00:06:34,250 --> 00:06:39,919
straightforward although and not

00:06:38,000 --> 00:06:40,230
directly related to this talk kind of

00:06:39,919 --> 00:06:41,670
way

00:06:40,230 --> 00:06:42,990
when I've gone back and looked at this

00:06:41,670 --> 00:06:44,640
talk I have noticed that there's

00:06:42,990 --> 00:06:46,980
something kind of missing from these

00:06:44,640 --> 00:06:48,180
slides I think from these lines so you

00:06:46,980 --> 00:06:52,110
might have any comments and what we

00:06:48,180 --> 00:06:57,660
could add to these declarations for our

00:06:52,110 --> 00:07:00,890
methods anyone you have to talk to us

00:06:57,660 --> 00:07:04,470
yeah what's that

00:07:00,890 --> 00:07:06,180
am i slicing oh oh no no I don't mean

00:07:04,470 --> 00:07:08,370
add a new method just in the

00:07:06,180 --> 00:07:10,170
declarations of these methods they could

00:07:08,370 --> 00:07:12,780
all be no except I just want to point

00:07:10,170 --> 00:07:16,230
that out but we didn't make him no

00:07:12,780 --> 00:07:18,590
except right we doubled them up and I

00:07:16,230 --> 00:07:20,760
said right this part of the type system

00:07:18,590 --> 00:07:24,090
we you wouldn't have to double them up

00:07:20,760 --> 00:07:25,650
here but we do have other stuff and so

00:07:24,090 --> 00:07:30,480
not all concepts for methods are no

00:07:25,650 --> 00:07:32,220
accept but they many of them can be so

00:07:30,480 --> 00:07:33,930
our vector ends up looking like this

00:07:32,220 --> 00:07:37,290
we're just taking advantage of the fact

00:07:33,930 --> 00:07:40,350
that C++ 17 now has a context burn rate

00:07:37,290 --> 00:07:42,690
enabled standard array and we have our

00:07:40,350 --> 00:07:44,310
data and our current size iterators

00:07:42,690 --> 00:07:47,850
pushback and all this is pretty easy to

00:07:44,310 --> 00:07:49,910
write we just push something or add to

00:07:47,850 --> 00:07:54,240
add a value to it and increment the size

00:07:49,910 --> 00:07:57,120
does that make sense right and the size

00:07:54,240 --> 00:07:58,710
is fixed yes the maximum size is fixed

00:07:57,120 --> 00:08:02,220
so that as a template and you can see

00:07:58,710 --> 00:08:05,450
right there it says size equals 5 that

00:08:02,220 --> 00:08:07,620
becomes a problem in a minute

00:08:05,450 --> 00:08:09,780
but in the early slides you'll see

00:08:07,620 --> 00:08:11,280
limitations you see you know we'll get

00:08:09,780 --> 00:08:14,580
to hopefully removing some of those

00:08:11,280 --> 00:08:20,550
limitations later yes so as we can see

00:08:14,580 --> 00:08:23,730
on the pushback oh that was weird if our

00:08:20,550 --> 00:08:25,740
size grows beyond the maximum size

00:08:23,730 --> 00:08:29,780
that's allowed by our templated size

00:08:25,740 --> 00:08:33,599
type we throw an exception and this is

00:08:29,780 --> 00:08:35,370
perfectly fine in context for context

00:08:33,599 --> 00:08:37,229
because if it were to throw the

00:08:35,370 --> 00:08:40,940
exception during a context for

00:08:37,229 --> 00:08:40,940
evaluation then it would fail to compile

00:08:41,030 --> 00:08:46,920
right and in fact if you if you didn't

00:08:45,150 --> 00:08:49,350
have to throw there and you went beyond

00:08:46,920 --> 00:08:50,640
the array size in the context for

00:08:49,350 --> 00:08:51,540
context you would still get a compile

00:08:50,640 --> 00:08:53,490
time which still

00:08:51,540 --> 00:08:54,990
yes because if you try to index past the

00:08:53,490 --> 00:08:56,400
end of array and accounts text for

00:08:54,990 --> 00:08:58,620
context you need a compile time error

00:08:56,400 --> 00:09:01,530
also but this allows us to work with it

00:08:58,620 --> 00:09:05,540
both in a context per and runtime

00:09:01,530 --> 00:09:07,500
context rising Li right so also it's

00:09:05,540 --> 00:09:09,810
interesting to note here that we were

00:09:07,500 --> 00:09:16,350
not able to use standard next for

00:09:09,810 --> 00:09:18,330
incrementing here so we can see using

00:09:16,350 --> 00:09:21,200
this little tool that some of you may

00:09:18,330 --> 00:09:25,110
have heard of before compiler Explorer

00:09:21,200 --> 00:09:27,660
that there's a bug in GCC 7.2 is

00:09:25,110 --> 00:09:30,990
implementation of standard next that

00:09:27,660 --> 00:09:33,780
it's unable to increment because of its

00:09:30,990 --> 00:09:37,170
iterator category but right these things

00:09:33,780 --> 00:09:40,260
are fixed in trunk yes I believe so yes

00:09:37,170 --> 00:09:43,410
so next advanced which I think next

00:09:40,260 --> 00:09:45,900
users and distance systems yes they are

00:09:43,410 --> 00:09:48,840
all contexts were in the standard they

00:09:45,900 --> 00:09:51,030
just happened to be a bug with them in

00:09:48,840 --> 00:09:57,210
the current GC and then GCC 7.2 that we

00:09:51,030 --> 00:09:59,550
were using today right so now we can

00:09:57,210 --> 00:10:03,270
naturally use our constructs per vector

00:09:59,550 --> 00:10:05,640
like this or more to the point like this

00:10:03,270 --> 00:10:09,030
we can write a context for function at

00:10:05,640 --> 00:10:11,340
compile time populate our vector assign

00:10:09,030 --> 00:10:13,140
it to a context for variable and our

00:10:11,340 --> 00:10:15,060
main and then actually do a compile time

00:10:13,140 --> 00:10:16,860
check with static assert to prove than

00:10:15,060 --> 00:10:22,950
we added in fact add something to our

00:10:16,860 --> 00:10:25,650
vector this cool to everyone so now that

00:10:22,950 --> 00:10:27,180
we have a vector that we can use a

00:10:25,650 --> 00:10:32,730
context for context we can build up

00:10:27,180 --> 00:10:34,710
strings so we can building on the model

00:10:32,730 --> 00:10:36,540
of how the standard libraries basic

00:10:34,710 --> 00:10:40,400
string is built implement our own basic

00:10:36,540 --> 00:10:43,410
string that inherits from our vector and

00:10:40,400 --> 00:10:45,300
simply you know builds a string out of

00:10:43,410 --> 00:10:49,230
it we have done a little bit of a cheat

00:10:45,300 --> 00:10:51,630
and that all contexts remember variables

00:10:49,230 --> 00:10:55,050
must be or all number variables of

00:10:51,630 --> 00:10:57,030
context / types must be initialized so

00:10:55,050 --> 00:10:59,280
we know that the underlying array is

00:10:57,030 --> 00:11:00,990
going to be initialized all zeros so

00:10:59,280 --> 00:11:02,060
we've taken the cheater step of knowing

00:11:00,990 --> 00:11:03,380
that we're going to have an old

00:11:02,060 --> 00:11:07,490
Nader at the end of our streams

00:11:03,380 --> 00:11:09,110
automatically for us and we have not yet

00:11:07,490 --> 00:11:14,200
provided any methods for shrinking the

00:11:09,110 --> 00:11:14,200
strings but that's should be easy to do

00:11:14,290 --> 00:11:19,490
and then continuing from there we have

00:11:17,600 --> 00:11:25,430
our constructs per map which we needed

00:11:19,490 --> 00:11:27,500
for our JSON type here and we did it's

00:11:25,430 --> 00:11:31,610
it's it's maybe it shouldn't be called

00:11:27,500 --> 00:11:35,750
map it's more like unordered flat map or

00:11:31,610 --> 00:11:37,340
yes yeah I know that it's unordered all

00:11:35,750 --> 00:11:38,480
their linear searches but they all

00:11:37,340 --> 00:11:40,160
happen at compile time with small

00:11:38,480 --> 00:11:42,440
objects that it's kind of irrelevant

00:11:40,160 --> 00:11:46,490
it's a map implemented as a vector of

00:11:42,440 --> 00:11:51,980
pairs yes so it's a vector of pairs as

00:11:46,490 --> 00:11:53,990
he said we have stood array and yeah

00:11:51,980 --> 00:11:56,900
we'll call that out yeah so anytime you

00:11:53,990 --> 00:11:58,760
see a CX qualification namespace here

00:11:56,900 --> 00:12:01,190
that's our cut that's our context birth

00:11:58,760 --> 00:12:02,570
namespace that usually in the case that

00:12:01,190 --> 00:12:04,130
there was some limitation we found in

00:12:02,570 --> 00:12:06,830
the standard libraries implementation in

00:12:04,130 --> 00:12:11,380
this case of stood pair yeah we couldn't

00:12:06,830 --> 00:12:11,380
use it concepts bro that's unfortunate

00:12:11,500 --> 00:12:20,650
so then this gives us the ability to do

00:12:14,150 --> 00:12:20,650
something like this oh I fixed it okay

00:12:20,680 --> 00:12:29,480
so we can have our context for map of

00:12:24,860 --> 00:12:31,550
colors with names and then we get actual

00:12:29,480 --> 00:12:33,320
compile time error on the last line of

00:12:31,550 --> 00:12:34,940
our main because we tried to look up a

00:12:33,320 --> 00:12:37,490
key that doesn't exist and reevaluating

00:12:34,940 --> 00:12:39,620
this in a context for context this is I

00:12:37,490 --> 00:12:41,840
feel like personally in some ways

00:12:39,620 --> 00:12:45,170
equivalent to or almost as good as an

00:12:41,840 --> 00:12:47,510
enumeration it's I mean an enumeration

00:12:45,170 --> 00:12:49,040
is also in a way a magic value of a

00:12:47,510 --> 00:12:51,650
string that's all checked at compile

00:12:49,040 --> 00:12:53,270
time and you know Jason is looking for

00:12:51,650 --> 00:12:54,950
arguments you can I'm looking for

00:12:53,270 --> 00:12:57,380
arguments yeah you throw stuff out here

00:12:54,950 --> 00:13:02,350
at me that's that's how I roll anyone

00:12:57,380 --> 00:13:02,350
argue with me all right

00:13:03,160 --> 00:13:09,200
so why not standard pair again compiler

00:13:06,950 --> 00:13:14,000
Explorer showing us why it's failing to

00:13:09,200 --> 00:13:19,190
compile here non conspiration this is

00:13:14,000 --> 00:13:21,200
the it's scrolling off the edge the

00:13:19,190 --> 00:13:24,980
assignment operator of standard pair is

00:13:21,200 --> 00:13:27,770
not contacts per right which is terribly

00:13:24,980 --> 00:13:29,540
doesn't understand it yes yes this is

00:13:27,770 --> 00:13:31,910
not a bug in this particular

00:13:29,540 --> 00:13:35,210
implementation it is simply not

00:13:31,910 --> 00:13:37,430
specified as being constructs per and as

00:13:35,210 --> 00:13:39,200
far as I know it totally could be do we

00:13:37,430 --> 00:13:43,910
have any standard library implementers

00:13:39,200 --> 00:13:47,870
that wants to argue all right I guess

00:13:43,910 --> 00:13:49,970
Marshall yeah I marshalese not here but

00:13:47,870 --> 00:13:51,950
this is a actually to touch on that

00:13:49,970 --> 00:13:53,510
that's a sort of common thing right now

00:13:51,950 --> 00:13:56,420
with console expert in the standard

00:13:53,510 --> 00:14:00,290
there's a lot of places where maybe not

00:13:56,420 --> 00:14:02,660
a lot but there are places where things

00:14:00,290 --> 00:14:04,340
that should by our thinking be able to

00:14:02,660 --> 00:14:06,530
be console expert just aren't specified

00:14:04,340 --> 00:14:08,090
as concepts for it in the standard and

00:14:06,530 --> 00:14:09,530
it's just because nobody's got around to

00:14:08,090 --> 00:14:10,850
it yet nobody's on the proposal nobody's

00:14:09,530 --> 00:14:12,950
quite thought about it in that way yet

00:14:10,850 --> 00:14:15,830
some things and some things that's it's

00:14:12,950 --> 00:14:17,780
like a weird little hole like everything

00:14:15,830 --> 00:14:20,720
about standard pair except for the

00:14:17,780 --> 00:14:24,050
assignment operator right and of course

00:14:20,720 --> 00:14:26,660
if you have a standard pair with two

00:14:24,050 --> 00:14:29,030
things that are context bura you can do

00:14:26,660 --> 00:14:30,290
you know dot first assignment second

00:14:29,030 --> 00:14:32,360
design and effectively you have

00:14:30,290 --> 00:14:34,520
assignment so to not have assignment

00:14:32,360 --> 00:14:38,870
operator on the pair it's probably an

00:14:34,520 --> 00:14:42,860
oversight yeah so we needed some sort of

00:14:38,870 --> 00:14:47,500
a find to implement our map and does any

00:14:42,860 --> 00:14:47,500
you know anyone recognize this find if

00:14:48,160 --> 00:14:52,160
yeah I mean this is literally how it's

00:14:50,630 --> 00:14:54,230
specified like in the standard this is

00:14:52,160 --> 00:14:56,690
taken straight from cpp reference com

00:14:54,230 --> 00:14:58,490
the only difference is it now says Const

00:14:56,690 --> 00:15:03,230
exper in front of it none of the

00:14:58,490 --> 00:15:05,690
standard algorithms in the well one min

00:15:03,230 --> 00:15:09,220
element max element min and Max are

00:15:05,690 --> 00:15:09,220
contacts birth the restaurant

00:15:10,499 --> 00:15:15,160
yes and once we have find if of course

00:15:12,610 --> 00:15:19,300
that's what makes the map work yes nice

00:15:15,160 --> 00:15:20,850
format right so then we've got bryce

00:15:19,300 --> 00:15:23,079
here

00:15:20,850 --> 00:15:24,730
let's see reviewing code I wrote last

00:15:23,079 --> 00:15:27,069
week I found three implementations of

00:15:24,730 --> 00:15:30,129
Const expert or transform context for

00:15:27,069 --> 00:15:33,490
algorithms please and we totally agree

00:15:30,129 --> 00:15:35,470
with Bryce yes but he won't let us have

00:15:33,490 --> 00:15:37,420
console expert parallel algorithms we

00:15:35,470 --> 00:15:39,819
have counts exper algorithm parallel

00:15:37,420 --> 00:15:43,089
algorithms may as well just the compiler

00:15:39,819 --> 00:15:44,499
implementation detail right yeah we're

00:15:43,089 --> 00:15:48,910
not worried about what the compiler I

00:15:44,499 --> 00:15:52,319
said yeah all right so we also had to

00:15:48,910 --> 00:15:55,149
implement mismatch equal and copy and

00:15:52,319 --> 00:15:56,199
found uses for several of them as the

00:15:55,149 --> 00:15:57,730
slide says here

00:15:56,199 --> 00:15:59,829
I was recently playing with some more

00:15:57,730 --> 00:16:03,129
context for containers myself on the

00:15:59,829 --> 00:16:05,249
flight here and implemented everything

00:16:03,129 --> 00:16:07,360
necessary to do a sorted container and

00:16:05,249 --> 00:16:08,860
it's again just taking the

00:16:07,360 --> 00:16:11,079
implementations day from CBP reference

00:16:08,860 --> 00:16:19,269
track on adding context word to the

00:16:11,079 --> 00:16:22,660
front of it works just fine so we end up

00:16:19,269 --> 00:16:26,800
with this which is our recursive

00:16:22,660 --> 00:16:30,129
declaration of our JSON thing using our

00:16:26,800 --> 00:16:31,839
CX vector + CX map and our static stream

00:16:30,129 --> 00:16:33,910
that we were just discussing now I

00:16:31,839 --> 00:16:34,959
completely lacked the imagination to

00:16:33,910 --> 00:16:38,379
actually figure out how to implement

00:16:34,959 --> 00:16:41,290
this and then had the the idea for our

00:16:38,379 --> 00:16:45,790
first attempt here it gets better but as

00:16:41,290 --> 00:16:50,079
you can see hopefully this has the max

00:16:45,790 --> 00:16:53,529
depth specified in the template argument

00:16:50,079 --> 00:16:55,329
on the first line and that means we are

00:16:53,529 --> 00:16:58,089
specifying that this is going to a max

00:16:55,329 --> 00:17:00,730
recursive depth of 5 so you could have

00:16:58,089 --> 00:17:05,890
at most 5 nested elements in your JSON

00:17:00,730 --> 00:17:06,940
thing and this was expensive at compile

00:17:05,890 --> 00:17:10,220
time

00:17:06,940 --> 00:17:12,500
yes it gets to be kind of expensive at

00:17:10,220 --> 00:17:13,910
compile this is this is the this is the

00:17:12,500 --> 00:17:15,350
simplest thing I thought of that could

00:17:13,910 --> 00:17:16,610
possibly work so this was kind of the

00:17:15,350 --> 00:17:18,410
proof of concept that we went through

00:17:16,610 --> 00:17:20,089
yeah he threw it out there I implemented

00:17:18,410 --> 00:17:24,589
it and I'm like that's amazing it works

00:17:20,089 --> 00:17:26,110
I said lacked the imagination for it yes

00:17:24,589 --> 00:17:31,880
go ahead sorry

00:17:26,110 --> 00:17:33,050
absolutely oh why didn't we use Union

00:17:31,880 --> 00:17:33,950
that's the one thing I didn't fix

00:17:33,050 --> 00:17:35,660
because I wanted to give you the

00:17:33,950 --> 00:17:39,620
opportunity to explain this I died

00:17:35,660 --> 00:17:42,410
and I forgot about that we did we are

00:17:39,620 --> 00:17:44,540
using Union now yes we we weren't

00:17:42,410 --> 00:17:47,000
because there wasn't a misunderstanding

00:17:44,540 --> 00:17:48,410
between myself and the compiler for what

00:17:47,000 --> 00:17:50,540
was allowed to be initialized and

00:17:48,410 --> 00:17:53,270
modified at compile time and a context

00:17:50,540 --> 00:17:55,820
for context with unions it can't work

00:17:53,270 --> 00:17:57,140
here yes yeah the final the

00:17:55,820 --> 00:17:58,670
implementation on github is still Union

00:17:57,140 --> 00:18:01,490
right because I thought you had one way

00:17:58,670 --> 00:18:02,510
or using Union now okay I know I mean I

00:18:01,490 --> 00:18:04,130
knew we were but then I thought you had

00:18:02,510 --> 00:18:06,440
another misunderstanding again with

00:18:04,130 --> 00:18:10,510
clang later once you trying to update it

00:18:06,440 --> 00:18:13,700
decline I don't for that okay cool so

00:18:10,510 --> 00:18:16,190
yes you could use Union here but that

00:18:13,700 --> 00:18:18,890
you have to be just aware of the fact

00:18:16,190 --> 00:18:21,410
that everything has to be initialized in

00:18:18,890 --> 00:18:23,240
context remember variables and that

00:18:21,410 --> 00:18:26,120
comes into play with the union because

00:18:23,240 --> 00:18:34,120
Union by default is not initialized to

00:18:26,120 --> 00:18:34,120
anything not the question oh sorry what

00:18:39,100 --> 00:18:42,100
yes

00:18:56,950 --> 00:19:01,610
so the question is by adding Const

00:18:59,930 --> 00:19:02,840
expert to these things if I check to see

00:19:01,610 --> 00:19:05,300
if they're still running at the same

00:19:02,840 --> 00:19:08,030
speed as the regular algorithms I would

00:19:05,300 --> 00:19:10,370
say I have not but I can also say I have

00:19:08,030 --> 00:19:13,610
never seen adding Const expert to an

00:19:10,370 --> 00:19:15,590
algorithm hurt anything but I can

00:19:13,610 --> 00:19:18,470
further qualify that by saying the

00:19:15,590 --> 00:19:20,930
textbook examples of these algorithms is

00:19:18,470 --> 00:19:22,640
not necessarily how they're actually

00:19:20,930 --> 00:19:24,080
implemented in the standard libraries

00:19:22,640 --> 00:19:26,510
because I know like some of them like GC

00:19:24,080 --> 00:19:28,940
C standard library algorithm

00:19:26,510 --> 00:19:30,620
implementations have some like default

00:19:28,940 --> 00:19:33,440
unrolling built into them and that kind

00:19:30,620 --> 00:19:35,300
of thing and and these textbook

00:19:33,440 --> 00:19:36,970
implementations don't have any kind of

00:19:35,300 --> 00:19:41,330
optimizations that rely on the compiler

00:19:36,970 --> 00:19:43,670
optimizer to do them but no I just to

00:19:41,330 --> 00:19:45,500
clarify no I have not done any direct

00:19:43,670 --> 00:19:47,660
comparisons and and just to be

00:19:45,500 --> 00:19:49,580
completely clear and transparent when we

00:19:47,660 --> 00:19:51,890
say we've made console expert vector and

00:19:49,580 --> 00:19:53,720
context format they are nowhere near

00:19:51,890 --> 00:19:55,790
what standard veteran standard map

00:19:53,720 --> 00:19:57,560
support right just what we need for the

00:19:55,790 --> 00:19:59,060
compile time parts although we do get

00:19:57,560 --> 00:20:01,190
pretty far along the way was yeah I'm

00:19:59,060 --> 00:20:07,790
most of the functions but they they're

00:20:01,190 --> 00:20:11,060
very serviceable yes so then we are able

00:20:07,790 --> 00:20:14,690
to do Const x4 you know keep building on

00:20:11,060 --> 00:20:15,650
this and throw so again we're taking

00:20:14,690 --> 00:20:17,630
advantage of the fact that if you were

00:20:15,650 --> 00:20:19,370
to throw an error at compile time or

00:20:17,630 --> 00:20:23,330
throw an exception at compile time that

00:20:19,370 --> 00:20:25,970
you get a compile time error and well we

00:20:23,330 --> 00:20:29,540
can access the arrays of things and we

00:20:25,970 --> 00:20:32,840
are able to basically do this at compile

00:20:29,540 --> 00:20:35,240
time and it works go back one slide yes

00:20:32,840 --> 00:20:36,860
so I just want to point out so you see

00:20:35,240 --> 00:20:38,990
two array here you can imagine the other

00:20:36,860 --> 00:20:40,850
functions so there's a conversion on

00:20:38,990 --> 00:20:43,300
conversion they return contraire for

00:20:40,850 --> 00:20:46,130
mutable ref to the underlying thing as

00:20:43,300 --> 00:20:48,470
for two array so for two object a

00:20:46,130 --> 00:20:50,810
boolean to number two string yes right

00:20:48,470 --> 00:20:53,170
yes this is just a tiny snippet of all

00:20:50,810 --> 00:20:53,170
the things

00:20:55,390 --> 00:21:00,710
so yeah we looked at that sorry

00:20:58,250 --> 00:21:01,400
why not variant we touched on this

00:21:00,710 --> 00:21:03,830
already

00:21:01,400 --> 00:21:05,960
similar to pair it's missing a couple of

00:21:03,830 --> 00:21:07,820
key things that are kind of critical we

00:21:05,960 --> 00:21:12,440
don't have a constant for copy

00:21:07,820 --> 00:21:17,240
constructor for variant a move

00:21:12,440 --> 00:21:19,700
constructor or copy assignment or move

00:21:17,240 --> 00:21:22,870
assignment operators for variant right

00:21:19,700 --> 00:21:25,480
and this comes down to the fact that

00:21:22,870 --> 00:21:30,110
variant wants to do placement new

00:21:25,480 --> 00:21:32,270
basically for these things but and

00:21:30,110 --> 00:21:33,500
that's not allowed at compile time it's

00:21:32,270 --> 00:21:36,740
not allowed at compile time there are

00:21:33,500 --> 00:21:39,830
ways to work around it I don't know

00:21:36,740 --> 00:21:41,990
there are yes they they also this so

00:21:39,830 --> 00:21:42,860
it's an interesting side note but I

00:21:41,990 --> 00:21:46,190
should probably move a little bit

00:21:42,860 --> 00:21:48,110
quicker here that the standard does

00:21:46,190 --> 00:21:51,730
guarantee that if all of the things

00:21:48,110 --> 00:21:54,380
inside your variant are trivially

00:21:51,730 --> 00:21:55,970
destructible then it is also trivially

00:21:54,380 --> 00:21:58,400
destructible and it takes a little bit

00:21:55,970 --> 00:22:00,800
of gymnastics to implement that but

00:21:58,400 --> 00:22:03,200
there's no reason why we couldn't make

00:22:00,800 --> 00:22:05,720
some of the same calculations for if

00:22:03,200 --> 00:22:10,850
they're trivially default constructible

00:22:05,720 --> 00:22:12,470
and that kind of thing so real quick all

00:22:10,850 --> 00:22:13,970
the retirements requirements of our

00:22:12,470 --> 00:22:16,640
compile time types if you're looking in

00:22:13,970 --> 00:22:19,340
the standard these are known as literal

00:22:16,640 --> 00:22:22,910
types they must have at least one

00:22:19,340 --> 00:22:25,400
context per constructor and they must be

00:22:22,910 --> 00:22:26,540
trivially destructible so that's it when

00:22:25,400 --> 00:22:29,450
you're thinking about deploying Const

00:22:26,540 --> 00:22:33,470
exper in your in your code that's what

00:22:29,450 --> 00:22:35,390
you have to worry about so as we've

00:22:33,470 --> 00:22:38,270
already mentioned we've got some

00:22:35,390 --> 00:22:39,680
shortcomings an array string string

00:22:38,270 --> 00:22:41,930
string obviously can't be using a

00:22:39,680 --> 00:22:44,900
constructs or contact right string view

00:22:41,930 --> 00:22:46,610
can't grow or change pair and optional

00:22:44,900 --> 00:22:49,520
and variant have the assignment problems

00:22:46,610 --> 00:22:52,190
and standard swap is simply not context

00:22:49,520 --> 00:22:54,380
per which right that one confuses me a

00:22:52,190 --> 00:22:55,520
little bit too and some of these some of

00:22:54,380 --> 00:22:57,620
these are shortcomings in the actual

00:22:55,520 --> 00:23:01,280
standard and some of them are just as we

00:22:57,620 --> 00:23:03,560
saw some implementation things but yeah

00:23:01,280 --> 00:23:04,620
for swap that's why I'm gonna see a

00:23:03,560 --> 00:23:06,570
reason why

00:23:04,620 --> 00:23:08,130
it shouldn't just be defined context

00:23:06,570 --> 00:23:11,090
unless it comes down to some sort of no

00:23:08,130 --> 00:23:13,260
accept guarantees or something but that

00:23:11,090 --> 00:23:15,960
should be something that can be worked

00:23:13,260 --> 00:23:17,520
with them for sure so art containers

00:23:15,960 --> 00:23:20,309
have a fixed maximum size they currently

00:23:17,520 --> 00:23:21,780
can't string shrink and they required

00:23:20,309 --> 00:23:23,220
all the types that a default

00:23:21,780 --> 00:23:25,470
constructible since we have to default

00:23:23,220 --> 00:23:26,730
initialize all the things inside of our

00:23:25,470 --> 00:23:31,800
containers they must be default

00:23:26,730 --> 00:23:34,980
constructible so we're almost to the

00:23:31,800 --> 00:23:39,230
parser right mm-hmm a few more slaves

00:23:34,980 --> 00:23:41,429
so we could one option for making our

00:23:39,230 --> 00:23:43,260
containers so that they don't require

00:23:41,429 --> 00:23:45,900
things that are default constructible x'

00:23:43,260 --> 00:23:48,150
that we could put an optional like make

00:23:45,900 --> 00:23:49,710
basically arrays of optionals of things

00:23:48,150 --> 00:23:51,540
and then they wouldn't have to be

00:23:49,710 --> 00:23:56,660
initialized and then we could initialize

00:23:51,540 --> 00:23:59,309
them on will when we needed to know

00:23:56,660 --> 00:24:02,700
stood optional well it's it's constant

00:23:59,309 --> 00:24:04,650
expert constructible but not assignable

00:24:02,700 --> 00:24:09,120
I believe because it comes down to the

00:24:04,650 --> 00:24:11,280
placement new again oh no I mean we have

00:24:09,120 --> 00:24:14,940
our own implementation of optional also

00:24:11,280 --> 00:24:18,300
that's I believe a tiny type over here

00:24:14,940 --> 00:24:31,940
we could an optional like thing is that

00:24:18,300 --> 00:24:34,679
good right so yes and it's okay right I

00:24:31,940 --> 00:24:37,650
like the idea of being able to make all

00:24:34,679 --> 00:24:41,640
of the standard containers constant X

00:24:37,650 --> 00:24:43,860
per so this is CVP reference comm for

00:24:41,640 --> 00:24:47,160
what is required for a minimal a locator

00:24:43,860 --> 00:24:49,590
and there's nothing in here that

00:24:47,160 --> 00:24:51,960
inherently couldn't be constructs BER so

00:24:49,590 --> 00:24:53,910
I say we just make these things con

00:24:51,960 --> 00:24:55,530
sticks per like we have been doing or at

00:24:53,910 --> 00:24:58,410
least you know make them optionally

00:24:55,530 --> 00:24:59,490
Const exper and well that's not doesn't

00:24:58,410 --> 00:25:00,960
exercise to the reader just to go out

00:24:59,490 --> 00:25:02,340
and make your own constructs for

00:25:00,960 --> 00:25:03,540
alligators roll it into one of the

00:25:02,340 --> 00:25:05,570
standard containers let me know how it

00:25:03,540 --> 00:25:05,570
goes

00:25:06,399 --> 00:25:11,480
that may be coming for some people we'll

00:25:10,700 --> 00:25:14,000
come back to that later

00:25:11,480 --> 00:25:16,130
yes now let's take tackle the other

00:25:14,000 --> 00:25:18,679
problem so Jason just talked about the

00:25:16,130 --> 00:25:20,630
how we actually represent JSON values

00:25:18,679 --> 00:25:23,480
right so it's got some idea of how to do

00:25:20,630 --> 00:25:25,610
that with the recursive template so that

00:25:23,480 --> 00:25:27,500
the kind of behalf that fell to me was

00:25:25,610 --> 00:25:29,809
how do we how do we pass these things

00:25:27,500 --> 00:25:36,679
how do we turn string view literals into

00:25:29,809 --> 00:25:38,240
JSON values and so to answer that

00:25:36,679 --> 00:25:40,639
question first we have to answer the

00:25:38,240 --> 00:25:42,080
question what is a parser and if doctors

00:25:40,639 --> 00:25:43,669
you should been a computer scientist he

00:25:42,080 --> 00:25:45,620
might have said something like this I'm

00:25:43,669 --> 00:25:48,200
positive for things is a function from

00:25:45,620 --> 00:25:49,299
strings to lists a pairs of things and

00:25:48,200 --> 00:25:53,769
strings

00:25:49,299 --> 00:25:56,299
this actually is this this quote is from

00:25:53,769 --> 00:26:01,250
fritz Roy who's a functional programming

00:25:56,299 --> 00:26:03,019
lecturer at Willamette University but so

00:26:01,250 --> 00:26:05,149
at the top here you can see I put a

00:26:03,019 --> 00:26:07,250
Haskell function signature and you'll

00:26:05,149 --> 00:26:09,590
see in a few slides coming you'll see

00:26:07,250 --> 00:26:12,110
the old Haskell function signature if

00:26:09,590 --> 00:26:14,120
you if if it if you can read it great

00:26:12,110 --> 00:26:16,490
Haskell is a great language just for

00:26:14,120 --> 00:26:18,559
specifying function signatures but this

00:26:16,490 --> 00:26:21,110
just means the type of a parser of a and

00:26:18,559 --> 00:26:23,809
a is like our template parameter is a

00:26:21,110 --> 00:26:28,039
function from string to list of pair of

00:26:23,809 --> 00:26:30,620
a string now in C++ we might say

00:26:28,039 --> 00:26:34,159
something like what's on the bottom this

00:26:30,620 --> 00:26:36,669
is a this is a template alias which is a

00:26:34,159 --> 00:26:40,580
function but there are a few things

00:26:36,669 --> 00:26:45,429
wrong with this C++ wise because we

00:26:40,580 --> 00:26:48,740
don't really quite mean list or or

00:26:45,429 --> 00:26:51,649
string right or even function when we

00:26:48,740 --> 00:26:53,470
say string we'd much rather say string

00:26:51,649 --> 00:26:55,610
view because that's that's context Brook

00:26:53,470 --> 00:26:58,760
it's a compile time string like thing

00:26:55,610 --> 00:27:00,769
and when we say list well then what the

00:26:58,760 --> 00:27:01,940
list represents here in the pars is that

00:27:00,769 --> 00:27:04,100
you might be having multiple ways to

00:27:01,940 --> 00:27:06,110
parse something so we're just going to

00:27:04,100 --> 00:27:08,899
condense that down to optional meaning

00:27:06,110 --> 00:27:10,960
the paths can either succeed or fail and

00:27:08,899 --> 00:27:13,159
we can do that in context for a world

00:27:10,960 --> 00:27:16,100
using our own kind of optional thing

00:27:13,159 --> 00:27:18,710
that's right that works and when we say

00:27:16,100 --> 00:27:19,430
function we mean of course something

00:27:18,710 --> 00:27:23,150
invoke

00:27:19,430 --> 00:27:28,280
and they see purpose 17 we mean context

00:27:23,150 --> 00:27:31,250
bruh lambdas so let's look at a very

00:27:28,280 --> 00:27:33,380
simple parser that we could make so on

00:27:31,250 --> 00:27:35,210
top here I just have some some aliases

00:27:33,380 --> 00:27:38,270
that make life simpler a parser input is

00:27:35,210 --> 00:27:41,050
a string view and a result of a parser

00:27:38,270 --> 00:27:43,760
is this optional of a pair of thing and

00:27:41,050 --> 00:27:45,470
rest of string right so you pause the

00:27:43,760 --> 00:27:48,230
thing out of the string you've got some

00:27:45,470 --> 00:27:50,450
rest of string to work on and you've got

00:27:48,230 --> 00:27:53,080
your tea that comes out of it so that's

00:27:50,450 --> 00:27:56,840
what input T and result pass result TR

00:27:53,080 --> 00:27:58,580
so Matt's char here this is this will we

00:27:56,840 --> 00:28:00,950
pass it an input and we pass it a char

00:27:58,580 --> 00:28:02,990
and it's going to return this the pass

00:28:00,950 --> 00:28:05,510
result and the way it can do that is it

00:28:02,990 --> 00:28:07,520
very you know you can read the code it's

00:28:05,510 --> 00:28:09,230
very simple if the string is empty or

00:28:07,520 --> 00:28:13,400
doesn't match the char we fail and that

00:28:09,230 --> 00:28:16,429
means returning null opt otherwise we

00:28:13,400 --> 00:28:19,010
just return the the wrapped-up pair of

00:28:16,429 --> 00:28:22,880
the char that we passed and the rest of

00:28:19,010 --> 00:28:26,600
the the rest of the string V I hope

00:28:22,880 --> 00:28:28,100
that's clear now but if you're paying

00:28:26,600 --> 00:28:31,160
attention you'll note that matched chart

00:28:28,100 --> 00:28:35,450
isn't quite yet a parser because we said

00:28:31,160 --> 00:28:38,210
that the signature and parser was pars

00:28:35,450 --> 00:28:40,340
input T to house result T and it this

00:28:38,210 --> 00:28:43,100
takes the char as well right so it's not

00:28:40,340 --> 00:28:45,350
quite the parser but we have context

00:28:43,100 --> 00:28:47,480
where lambdas so what we could do is

00:28:45,350 --> 00:28:51,470
capture that char and return the lambda

00:28:47,480 --> 00:28:54,170
which is itself a parser and that that's

00:28:51,470 --> 00:28:57,020
what this is so now make char parser

00:28:54,170 --> 00:29:00,050
will make us a parser that matches the

00:28:57,020 --> 00:29:02,660
character we give it so we capture the

00:29:00,050 --> 00:29:05,090
character in the lambda and what we're

00:29:02,660 --> 00:29:07,820
returning is a lambda which is a parser

00:29:05,090 --> 00:29:09,320
because there's a function from string

00:29:07,820 --> 00:29:13,130
to list of pair thing a strength or

00:29:09,320 --> 00:29:14,840
optional pair right and that so this

00:29:13,130 --> 00:29:15,800
code on this slide is exactly the code

00:29:14,840 --> 00:29:17,360
you saw on the previous slide we just

00:29:15,800 --> 00:29:20,450
put into a lambda and it's now capturing

00:29:17,360 --> 00:29:22,309
the character so make char parser will

00:29:20,450 --> 00:29:24,120
give us a positive or any child that we

00:29:22,309 --> 00:29:27,090
give it

00:29:24,120 --> 00:29:29,220
so now that we can do that we can think

00:29:27,090 --> 00:29:31,260
about some other sort of primitive

00:29:29,220 --> 00:29:35,730
pauses we can so far we can make up

00:29:31,260 --> 00:29:37,289
child of parser for chars fundamentally

00:29:35,730 --> 00:29:39,720
parsing works on strings so we're going

00:29:37,289 --> 00:29:41,640
to want a few more things it's gonna be

00:29:39,720 --> 00:29:44,400
useful to match any one of a number of

00:29:41,640 --> 00:29:47,130
chars that we give it and so here is

00:29:44,400 --> 00:29:50,120
here is this function one off again it

00:29:47,130 --> 00:29:52,799
returns a lambda it's returning a parser

00:29:50,120 --> 00:29:54,690
and it's just doing you know the kind of

00:29:52,799 --> 00:29:57,450
obvious string you see if the thing at

00:29:54,690 --> 00:30:01,140
the beginning of your input is in your

00:29:57,450 --> 00:30:07,350
set your set of strings your string V

00:30:01,140 --> 00:30:10,049
that you captured so that I hope is

00:30:07,350 --> 00:30:12,600
clear similarly to one of we can write

00:30:10,049 --> 00:30:13,890
none of which I'm not showing the body

00:30:12,600 --> 00:30:16,049
of but it works exactly the same way

00:30:13,890 --> 00:30:17,010
only of the logics inverted you're just

00:30:16,049 --> 00:30:18,990
checking to see if the thing at the

00:30:17,010 --> 00:30:22,289
beginning of the string view is none of

00:30:18,990 --> 00:30:23,669
the things that you captured and also we

00:30:22,289 --> 00:30:26,720
can make a parser that matches a whole

00:30:23,669 --> 00:30:28,470
string just by capturing that string and

00:30:26,720 --> 00:30:30,870
doing the obvious thing to check the

00:30:28,470 --> 00:30:35,309
string view and that uses a context

00:30:30,870 --> 00:30:36,860
brush good mismatch so everything clear

00:30:35,309 --> 00:30:40,140
up to this point everyone happy with

00:30:36,860 --> 00:30:42,600
housing Charles parsing strings etc all

00:30:40,140 --> 00:30:44,520
right now once now we have these these

00:30:42,600 --> 00:30:46,110
kind of primitives now we can think

00:30:44,520 --> 00:30:50,299
about ways to combine them together to

00:30:46,110 --> 00:30:55,230
build up towards passing greater things

00:30:50,299 --> 00:30:57,179
and some of the things we're going to

00:30:55,230 --> 00:30:58,350
want to do here might start to look

00:30:57,179 --> 00:31:00,210
familiar if you know the kind of

00:30:58,350 --> 00:31:02,429
functional patterns involved one of the

00:31:00,210 --> 00:31:04,559
things we'd like to do is change the

00:31:02,429 --> 00:31:06,240
result type of a parser so right now we

00:31:04,559 --> 00:31:08,549
have a parser for chars if that char

00:31:06,240 --> 00:31:11,070
represented a digit we might want to

00:31:08,549 --> 00:31:12,809
change it into an integer and so we want

00:31:11,070 --> 00:31:13,710
to put the function in there that just

00:31:12,809 --> 00:31:15,570
we now have to write a function that

00:31:13,710 --> 00:31:19,140
changes a single digit to an integer

00:31:15,570 --> 00:31:20,610
we're and we want to apply that to our

00:31:19,140 --> 00:31:23,850
parser that pauses chars to make a

00:31:20,610 --> 00:31:25,919
parser that pauses integers so we can

00:31:23,850 --> 00:31:27,210
write that function these are kind of

00:31:25,919 --> 00:31:30,240
piles of combinators that we want to

00:31:27,210 --> 00:31:32,700
write to hold things together we might

00:31:30,240 --> 00:31:34,080
want to run one parser and then run a

00:31:32,700 --> 00:31:36,990
second one based on the result the first

00:31:34,080 --> 00:31:37,650
one we might want to alternate to parses

00:31:36,990 --> 00:31:40,070
so

00:31:37,650 --> 00:31:42,930
try one and if it fails try another one

00:31:40,070 --> 00:31:44,550
and we might want to run two pauses in

00:31:42,930 --> 00:31:48,510
sequence and then combine their results

00:31:44,550 --> 00:31:49,860
together so I'm not gonna go deeply into

00:31:48,510 --> 00:31:51,810
the the functional programming aspect

00:31:49,860 --> 00:31:55,080
but if you know these patterns

00:31:51,810 --> 00:31:56,850
they'll look familiar so this is f map

00:31:55,080 --> 00:31:59,640
this is the thing that you know changes

00:31:56,850 --> 00:32:00,150
are charring to an int for example so it

00:31:59,640 --> 00:32:01,680
takes

00:32:00,150 --> 00:32:03,780
and again the Haskell type signatures

00:32:01,680 --> 00:32:05,400
are at the top if you're familiar with

00:32:03,780 --> 00:32:10,230
those but it takes fundamentally the

00:32:05,400 --> 00:32:12,060
function f and the pars of P and again

00:32:10,230 --> 00:32:16,290
well it's going to return is itself a

00:32:12,060 --> 00:32:18,750
parser a lambda and what we do is

00:32:16,290 --> 00:32:22,220
capture the function and the parser

00:32:18,750 --> 00:32:26,540
that's kind of where we've got to change

00:32:22,220 --> 00:32:31,170
we've run the parser that you can see on

00:32:26,540 --> 00:32:33,930
this line if the parser fails then we

00:32:31,170 --> 00:32:36,840
have to fail but if the parcel succeeds

00:32:33,930 --> 00:32:40,200
all we do is run the function on what it

00:32:36,840 --> 00:32:46,080
produced wrap that back up in our thing

00:32:40,200 --> 00:32:50,640
and rest of string and return that so so

00:32:46,080 --> 00:32:54,540
that F map similarly we've got this is

00:32:50,640 --> 00:32:56,730
this is alternation so this this time we

00:32:54,540 --> 00:32:57,840
take two pauses and the bit of template

00:32:56,730 --> 00:32:59,040
metaprogramming at the top just says

00:32:57,840 --> 00:33:00,720
that they're going to have to return the

00:32:59,040 --> 00:33:02,910
same type because what we're building

00:33:00,720 --> 00:33:05,670
has to return either one and we need to

00:33:02,910 --> 00:33:08,010
know what type to return so we take two

00:33:05,670 --> 00:33:11,520
pauses p1 and p2 and we return the

00:33:08,010 --> 00:33:15,210
parser that in its body just says try

00:33:11,520 --> 00:33:16,620
running p1 if that fails if that

00:33:15,210 --> 00:33:21,570
succeeds you're done but if that fails

00:33:16,620 --> 00:33:23,160
try running p2 and the thing at the

00:33:21,570 --> 00:33:24,420
bottom here is just a useful thing for

00:33:23,160 --> 00:33:28,470
building up combinators which is the

00:33:24,420 --> 00:33:29,610
puzzle that always fails so you can but

00:33:28,470 --> 00:33:31,800
you can make it be of whatever type you

00:33:29,610 --> 00:33:34,140
need right so it's gonna it's just going

00:33:31,800 --> 00:33:36,110
to always fail and return no op that

00:33:34,140 --> 00:33:39,570
turns out to be useful in some cases

00:33:36,110 --> 00:33:42,660
so that was alternation the final kind

00:33:39,570 --> 00:33:45,120
of primitive Combinator that I want to

00:33:42,660 --> 00:33:47,460
show you is I call it combine for lack

00:33:45,120 --> 00:33:49,770
of a better word but what this does is

00:33:47,460 --> 00:33:51,040
runs instead of running what trying one

00:33:49,770 --> 00:33:54,140
and then

00:33:51,040 --> 00:33:55,870
diverting to the other this runs one and

00:33:54,140 --> 00:34:00,260
then runs the other one in sequence

00:33:55,870 --> 00:34:01,880
takes the two results combines them and

00:34:00,260 --> 00:34:03,070
this turns out to be very useful so you

00:34:01,880 --> 00:34:06,470
can see what it's doing it's saying

00:34:03,070 --> 00:34:08,120
consort or r1 equals p1 of you know it's

00:34:06,470 --> 00:34:12,409
running the first pars are there if that

00:34:08,120 --> 00:34:14,510
fails you fail then you run p2 on the on

00:34:12,409 --> 00:34:15,800
the leftover string from p1 the first

00:34:14,510 --> 00:34:17,990
you've run the first party you want to

00:34:15,800 --> 00:34:19,960
run the second one what's left over if

00:34:17,990 --> 00:34:22,580
that fails again you still have to fail

00:34:19,960 --> 00:34:26,629
otherwise you just return the result of

00:34:22,580 --> 00:34:27,950
calling the function on both results so

00:34:26,629 --> 00:34:29,149
it's a way of running to positive

00:34:27,950 --> 00:34:31,490
sequence and then combining their

00:34:29,149 --> 00:34:35,929
outputs to make a positive for the

00:34:31,490 --> 00:34:38,840
output of the function so this turns out

00:34:35,929 --> 00:34:41,060
to be very useful there are a couple of

00:34:38,840 --> 00:34:43,340
very useful patterns of this and it's

00:34:41,060 --> 00:34:45,500
useful for like when you don't care to

00:34:43,340 --> 00:34:47,179
save the result of the pass so you just

00:34:45,500 --> 00:34:48,740
want to say something like well there I

00:34:47,179 --> 00:34:50,030
know there has to be a comma here but

00:34:48,740 --> 00:34:51,560
I'm not interested in the comer I want

00:34:50,030 --> 00:34:53,030
to see the next thing right so I'm

00:34:51,560 --> 00:34:54,649
pausing something and I know there's

00:34:53,030 --> 00:34:56,540
gonna be a comma but the commas not

00:34:54,649 --> 00:34:59,000
going to be part of my output it's the

00:34:56,540 --> 00:35:00,470
thing I'm interested in let's say and so

00:34:59,000 --> 00:35:01,850
you just want to throw away either the

00:35:00,470 --> 00:35:05,330
left-hand side of the pars or the

00:35:01,850 --> 00:35:07,370
right-hand side and so what I did was I

00:35:05,330 --> 00:35:09,890
overloaded operate the less than and

00:35:07,370 --> 00:35:11,810
operator greater than just to do this

00:35:09,890 --> 00:35:13,850
combined pattern where you throw away

00:35:11,810 --> 00:35:15,440
the thing on the left hand side if

00:35:13,850 --> 00:35:16,550
you're like good you know the other way

00:35:15,440 --> 00:35:20,240
around on the left on the right hand

00:35:16,550 --> 00:35:22,700
side if you're doing greater than so you

00:35:20,240 --> 00:35:24,800
can see that when we call combine here

00:35:22,700 --> 00:35:26,810
we give it the pauses the function we

00:35:24,800 --> 00:35:33,910
give it just throws away the left hand

00:35:26,810 --> 00:35:36,890
argument and returns the right hand okay

00:35:33,910 --> 00:35:38,390
few more combinators and now you can

00:35:36,890 --> 00:35:39,590
start to see perhaps what we're building

00:35:38,390 --> 00:35:42,020
up to now I'm just showing you the

00:35:39,590 --> 00:35:43,490
Haskell type signatures for these but

00:35:42,020 --> 00:35:44,930
maybe you can imagine kind of having

00:35:43,490 --> 00:35:47,990
seen some of those c-plus vocal these

00:35:44,930 --> 00:35:48,890
how these might be implemented and think

00:35:47,990 --> 00:35:50,960
these have in common is their

00:35:48,890 --> 00:35:54,770
accumulation style so they work in the

00:35:50,960 --> 00:35:56,960
same way as stood accumulate many takes

00:35:54,770 --> 00:35:58,850
a parser and the initial value that's

00:35:56,960 --> 00:36:00,890
that's the B and then it takes a

00:35:58,850 --> 00:36:02,619
function that folds the result of that

00:36:00,890 --> 00:36:04,950
piles it into B's

00:36:02,619 --> 00:36:07,690
and what you get as a parlour of bees

00:36:04,950 --> 00:36:09,579
right so it's very much like accumulate

00:36:07,690 --> 00:36:12,160
you give it an initial value you give it

00:36:09,579 --> 00:36:14,170
a function to combine values and what

00:36:12,160 --> 00:36:17,049
you get out is the final value only this

00:36:14,170 --> 00:36:22,569
time it works on pauses so many will

00:36:17,049 --> 00:36:25,869
match zero or many runs of the parser

00:36:22,569 --> 00:36:29,979
many one matches at least one pass but

00:36:25,869 --> 00:36:31,989
again potentially unbounded exactly n

00:36:29,979 --> 00:36:33,880
you can probably guess what that does it

00:36:31,989 --> 00:36:35,920
takes the int argument is its second

00:36:33,880 --> 00:36:37,960
argument and so it runs a parser exactly

00:36:35,920 --> 00:36:42,940
n times combines the results together

00:36:37,960 --> 00:36:45,430
and then separated by and you can see

00:36:42,940 --> 00:36:46,809
where this is going Pat it takes two

00:36:45,430 --> 00:36:48,910
pauses one of which is kind of you're

00:36:46,809 --> 00:36:50,499
you're positive for things and then the

00:36:48,910 --> 00:36:52,450
piles are X here is like the in-between

00:36:50,499 --> 00:36:54,489
parser so if you're pausing a list of

00:36:52,450 --> 00:36:58,719
things in JSON you're gonna want to pass

00:36:54,489 --> 00:37:00,160
value comma value comma value comma etc

00:36:58,719 --> 00:37:03,309
and that's what separated by this so

00:37:00,160 --> 00:37:05,769
it'll pass values separated by housing

00:37:03,309 --> 00:37:08,710
commas and again the initial value and

00:37:05,769 --> 00:37:12,279
the fold function and what we get out is

00:37:08,710 --> 00:37:15,549
the result so I'm not going to you know

00:37:12,279 --> 00:37:16,839
give you a wall of text for the C++ on

00:37:15,549 --> 00:37:18,640
these things but you know given what

00:37:16,839 --> 00:37:21,999
we've talked about maybe you can see

00:37:18,640 --> 00:37:23,079
that these can be implemented all right

00:37:21,999 --> 00:37:25,509
so let's take a look at a couple of

00:37:23,079 --> 00:37:28,690
parses just so you get a feel for for

00:37:25,509 --> 00:37:30,670
for what these look like this parser

00:37:28,690 --> 00:37:34,420
just eats whitespace just one of the

00:37:30,670 --> 00:37:36,160
simplest parses we can make so we're and

00:37:34,420 --> 00:37:37,779
it eats you know just just a very

00:37:36,160 --> 00:37:42,130
limited subset of whitespace of that so

00:37:37,779 --> 00:37:45,339
space or tab or new line or carriage

00:37:42,130 --> 00:37:47,049
return those are our child pauses we're

00:37:45,339 --> 00:37:49,539
alternating them all together with the

00:37:47,049 --> 00:37:51,489
bar operator and then we're saying the

00:37:49,539 --> 00:37:54,819
whitespace parser is is many of those

00:37:51,489 --> 00:37:56,410
and you know the the accumulation

00:37:54,819 --> 00:37:59,049
function we don't we don't care to catch

00:37:56,410 --> 00:38:01,529
whitespace so we're just pausing passing

00:37:59,049 --> 00:38:05,469
through mono state and throwing away so

00:38:01,529 --> 00:38:07,150
C++ 17 makes constructs lambdas enabled

00:38:05,469 --> 00:38:09,999
for constructs for use that's correct

00:38:07,150 --> 00:38:12,279
how much more code do you think it would

00:38:09,999 --> 00:38:13,230
have taken without being able to use C++

00:38:12,279 --> 00:38:18,030
Seventeen's

00:38:13,230 --> 00:38:19,410
here to be honest I don't know I don't

00:38:18,030 --> 00:38:22,830
know that I don't know if it would even

00:38:19,410 --> 00:38:24,750
be possible I would like you'd be

00:38:22,830 --> 00:38:27,119
talking about simulating lambdas by

00:38:24,750 --> 00:38:30,210
returning local structural functions or

00:38:27,119 --> 00:38:34,050
something areum yeah I don't want to

00:38:30,210 --> 00:38:35,310
think about that too much okay but an

00:38:34,050 --> 00:38:36,780
important thing to note there is forgot

00:38:35,310 --> 00:38:38,900
about a few slides so you can see that

00:38:36,780 --> 00:38:41,220
all of these functions returned lambdas

00:38:38,900 --> 00:38:43,140
but there isn't actually a context for

00:38:41,220 --> 00:38:46,530
there on the lambda itself and that's

00:38:43,140 --> 00:38:48,060
because one of the defaults you know for

00:38:46,530 --> 00:38:50,040
lambdas now lambdas are by default

00:38:48,060 --> 00:38:51,780
concepts bruh unlike regular functions

00:38:50,040 --> 00:38:53,280
so you don't actually have to put the

00:38:51,780 --> 00:38:55,619
concepts per keyword in there by default

00:38:53,280 --> 00:38:57,480
if they meet the requirements of being

00:38:55,619 --> 00:38:59,369
contracts right if they can because

00:38:57,480 --> 00:39:01,790
which one wonders why we don't do that

00:38:59,369 --> 00:39:04,680
to all the functions at this point right

00:39:01,790 --> 00:39:08,670
okay so that one eats white space this

00:39:04,680 --> 00:39:11,820
one pauses a decimal integer a positive

00:39:08,670 --> 00:39:14,609
decimal integer and so what we're doing

00:39:11,820 --> 00:39:17,880
here is building up the pawza

00:39:14,609 --> 00:39:19,260
Combinator's we're saying one off one

00:39:17,880 --> 00:39:22,170
through nine because the decimal integer

00:39:19,260 --> 00:39:23,880
won't start with a zero and we're gonna

00:39:22,170 --> 00:39:27,510
bind the result of that and pause it and

00:39:23,880 --> 00:39:30,450
pass it into the next the the function

00:39:27,510 --> 00:39:31,800
that we pass which you know so one

00:39:30,450 --> 00:39:34,320
through nine will be that char X

00:39:31,800 --> 00:39:35,850
parameter to our next function and then

00:39:34,320 --> 00:39:38,190
inside of that we're saying well after

00:39:35,850 --> 00:39:41,490
you've passed that one through nine do

00:39:38,190 --> 00:39:43,830
many of one of zero through nine so you

00:39:41,490 --> 00:39:46,859
can have any of those idiots many times

00:39:43,830 --> 00:39:48,560
after your initial digit and then we're

00:39:46,859 --> 00:39:53,670
accumulating in the obvious way of

00:39:48,560 --> 00:39:59,369
shifting and adding so that I hope is

00:39:53,670 --> 00:40:05,310
clear here we have a very simple string

00:39:59,369 --> 00:40:07,890
pass it a positive four strings is

00:40:05,310 --> 00:40:09,210
basically you pause a quote followed by

00:40:07,890 --> 00:40:11,820
a bunch of things that aren't too quote

00:40:09,210 --> 00:40:13,020
followed by another quote and you can

00:40:11,820 --> 00:40:15,510
see at the bottom here that's where this

00:40:13,020 --> 00:40:17,369
greater less than operator overload gets

00:40:15,510 --> 00:40:19,050
to be really nice because that's all

00:40:17,369 --> 00:40:21,150
that's that's setting it's saying do a

00:40:19,050 --> 00:40:23,940
quote throw away that do the string

00:40:21,150 --> 00:40:25,920
parser that's not quotes keep that and

00:40:23,940 --> 00:40:27,250
then do a quote parse our afterwards and

00:40:25,920 --> 00:40:29,720
throw that away

00:40:27,250 --> 00:40:33,740
all right so now we're getting towards

00:40:29,720 --> 00:40:35,690
the toolkit for building JSON pauses so

00:40:33,740 --> 00:40:37,610
a reason because JSON is a discriminated

00:40:35,690 --> 00:40:39,620
Union a reasonable attempt to pausing it

00:40:37,610 --> 00:40:41,390
is to have pauses for six different

00:40:39,620 --> 00:40:44,510
types of things and alternate them

00:40:41,390 --> 00:40:46,400
together and so that's what this does is

00:40:44,510 --> 00:40:49,790
a bit of a wall of text but you can see

00:40:46,400 --> 00:40:50,990
there's basically six six or seven

00:40:49,790 --> 00:40:52,250
different alternations here you can see

00:40:50,990 --> 00:40:53,930
there's a pause off a null in there

00:40:52,250 --> 00:40:56,330
there's a pause of for true and false

00:40:53,930 --> 00:40:59,080
there's a number posit a string parser

00:40:56,330 --> 00:41:01,880
and then an array and object parser and

00:40:59,080 --> 00:41:04,340
we're doing a skip whitespace before we

00:41:01,880 --> 00:41:10,490
pass a value so that all gets stripped

00:41:04,340 --> 00:41:11,900
out now I need to be that don't I yes

00:41:10,490 --> 00:41:14,350
that's the rest of the the previous

00:41:11,900 --> 00:41:16,820
slide there's a rain a red objects are

00:41:14,350 --> 00:41:20,810
pausing key values in that we're using

00:41:16,820 --> 00:41:22,400
that separated by parser now all of

00:41:20,810 --> 00:41:25,370
these at this point are function

00:41:22,400 --> 00:41:27,260
templates right because our JSON object

00:41:25,370 --> 00:41:29,030
is itself a template and in order to be

00:41:27,260 --> 00:41:30,770
able to pass a thing at any depth of the

00:41:29,030 --> 00:41:33,200
tree we need the equivalent function

00:41:30,770 --> 00:41:37,460
template instantiated outlet depth or

00:41:33,200 --> 00:41:40,640
for that depth so that as it goes

00:41:37,460 --> 00:41:42,110
actually works and that was the simplest

00:41:40,640 --> 00:41:43,970
kind of proof-of-concept this was how we

00:41:42,110 --> 00:41:45,410
knew we were on the right track for

00:41:43,970 --> 00:41:48,940
suitable values and works which is to

00:41:45,410 --> 00:41:51,590
say limited recursion depth and limited

00:41:48,940 --> 00:41:54,640
array size and object size it's got a

00:41:51,590 --> 00:41:57,770
few problems so problem number one is a

00:41:54,640 --> 00:42:00,500
JSON number isn't just a simple decimal

00:41:57,770 --> 00:42:04,370
positive integer it's it's this thing

00:42:00,500 --> 00:42:06,110
this is from JSON org but actually if

00:42:04,370 --> 00:42:08,780
you look at this and think about our

00:42:06,110 --> 00:42:10,220
combinators we have all the toolkits all

00:42:08,780 --> 00:42:13,010
the things that our toolkit that we need

00:42:10,220 --> 00:42:14,390
to write the parser for this it's just a

00:42:13,010 --> 00:42:18,100
little more complicated than I can put

00:42:14,390 --> 00:42:21,890
on the slide for you but it can be done

00:42:18,100 --> 00:42:23,960
similarly a JSON string isn't actually a

00:42:21,890 --> 00:42:25,820
string view because it's got escape

00:42:23,960 --> 00:42:27,260
characters and in general the like you

00:42:25,820 --> 00:42:28,760
don't get a one-to-one mapping of input

00:42:27,260 --> 00:42:30,740
to output you can't just say I'll

00:42:28,760 --> 00:42:33,890
passing a string is just taking a subset

00:42:30,740 --> 00:42:36,620
of main put string and it's this thing

00:42:33,890 --> 00:42:38,390
but again we have all the parts we need

00:42:36,620 --> 00:42:42,500
to build a parser

00:42:38,390 --> 00:42:45,140
and with Jason's string the concept of

00:42:42,500 --> 00:42:47,240
vector string we have the ability to put

00:42:45,140 --> 00:42:49,730
our output separately from our input so

00:42:47,240 --> 00:42:51,710
we can build this again it's a bit too

00:42:49,730 --> 00:42:54,410
much to show you but you can imagine how

00:42:51,710 --> 00:42:56,799
this can be built problem 3 is a little

00:42:54,410 --> 00:42:56,799
trickier

00:42:57,650 --> 00:43:05,809
what kind of compile times are we seeing

00:42:59,480 --> 00:43:10,299
at this stage minutes least yeah it was

00:43:05,809 --> 00:43:14,630
I mean it worked but it wasn't nice yes

00:43:10,299 --> 00:43:16,880
so and problem before is you know this

00:43:14,630 --> 00:43:18,859
even if we get past problem 3 this is

00:43:16,880 --> 00:43:21,589
pretty much a killer for any kind of

00:43:18,859 --> 00:43:24,500
actual use right you can't just say oh

00:43:21,589 --> 00:43:25,940
by the way your strings can only be so

00:43:24,500 --> 00:43:27,440
many characters or your depth can only

00:43:25,940 --> 00:43:29,029
be this much or you're not allowed more

00:43:27,440 --> 00:43:30,890
than 6 things in your right I think

00:43:29,029 --> 00:43:35,720
that's 255 characters should be enough

00:43:30,890 --> 00:43:40,400
for anyone right alright so we need to

00:43:35,720 --> 00:43:42,019
get rid of templates and at them so this

00:43:40,400 --> 00:43:44,900
is a reminder this is part of our JSON

00:43:42,019 --> 00:43:46,730
value so in our vector in our map we're

00:43:44,900 --> 00:43:51,950
recursing the templates using the depth

00:43:46,730 --> 00:43:55,940
minus 1 parameter so we just built a

00:43:51,950 --> 00:43:58,009
pausing framework why don't we use it to

00:43:55,940 --> 00:43:59,930
help us solve this problem what we're

00:43:58,009 --> 00:44:02,660
passing out right now is the JSON value

00:43:59,930 --> 00:44:06,079
but we don't have to parse out the value

00:44:02,660 --> 00:44:08,000
we could make a parser that returns the

00:44:06,079 --> 00:44:11,210
number of values that will be required

00:44:08,000 --> 00:44:13,059
to store the object and that actually is

00:44:11,210 --> 00:44:15,740
easier than parsing the object itself

00:44:13,059 --> 00:44:17,240
because all we do is reuse our kind of

00:44:15,740 --> 00:44:18,650
structural code that knows how to parse

00:44:17,240 --> 00:44:20,599
strings and numbers and all that stuff

00:44:18,650 --> 00:44:23,329
but instead of actually outputting the

00:44:20,599 --> 00:44:25,130
values we just output the number of

00:44:23,329 --> 00:44:27,680
values that we need so an array is just

00:44:25,130 --> 00:44:29,450
one value for the array plus number of

00:44:27,680 --> 00:44:32,900
values and it's children object the same

00:44:29,450 --> 00:44:34,069
everything else is just one and we reuse

00:44:32,900 --> 00:44:40,119
all the structural components and the

00:44:34,069 --> 00:44:40,119
number of values parser works so

00:44:40,569 --> 00:44:45,910
now that we have the number of values

00:44:42,999 --> 00:44:49,829
Pazza the JSON value doesn't need to be

00:44:45,910 --> 00:44:52,359
a template anymore

00:44:49,829 --> 00:44:56,259
that's all that's coming up okay so so

00:44:52,359 --> 00:44:57,880
the struct itself the kind of record the

00:44:56,259 --> 00:45:00,069
struct record that was holding all our

00:44:57,880 --> 00:45:01,359
pausing functions that was enabling us

00:45:00,069 --> 00:45:04,839
to do mutual recursion on the parsing

00:45:01,359 --> 00:45:08,559
functions now instead of the functions

00:45:04,839 --> 00:45:10,239
being templates the struct itself as a

00:45:08,559 --> 00:45:11,919
template that just knows how many values

00:45:10,239 --> 00:45:15,309
were going to need and we'll use our

00:45:11,919 --> 00:45:17,380
compiled time vector and then the JSON

00:45:15,309 --> 00:45:19,959
value itself is no longer a template

00:45:17,380 --> 00:45:22,959
either because inside the vector or the

00:45:19,959 --> 00:45:26,289
map instead of having you know the next

00:45:22,959 --> 00:45:28,359
level depth objects all we need to do is

00:45:26,289 --> 00:45:32,469
store the offsets into the externalize

00:45:28,359 --> 00:45:33,910
storage so to help you understand that a

00:45:32,469 --> 00:45:36,099
little bit here's an example kind of how

00:45:33,910 --> 00:45:38,049
the object layout happens so if we're

00:45:36,099 --> 00:45:39,369
passing this array and it's got three

00:45:38,049 --> 00:45:42,160
elements and one of those elements is

00:45:39,369 --> 00:45:44,279
itself an array but the object layout

00:45:42,160 --> 00:45:46,779
comes out like we see here so the

00:45:44,279 --> 00:45:49,650
element zero is an array and it's

00:45:46,779 --> 00:45:52,390
children are elements one two and five

00:45:49,650 --> 00:45:56,829
those are actually offsets from itself

00:45:52,390 --> 00:45:58,749
they aren't absolute offsets so you can

00:45:56,829 --> 00:46:01,869
see that at number position two we've

00:45:58,749 --> 00:46:05,229
got the child array and its children are

00:46:01,869 --> 00:46:09,459
offsets one and two from it and so

00:46:05,229 --> 00:46:12,759
that's kind of how how that works and

00:46:09,459 --> 00:46:14,559
then to drive the pars to figure out the

00:46:12,759 --> 00:46:16,630
number of objects ahead of time we need

00:46:14,559 --> 00:46:19,029
this this is actually a new extension

00:46:16,630 --> 00:46:22,929
right now can really clang support it so

00:46:19,029 --> 00:46:25,859
it's this templated operator quote for

00:46:22,929 --> 00:46:30,249
the user-defined literals this is n

00:46:25,859 --> 00:46:31,569
$35.99 I believe was a proposal it's not

00:46:30,249 --> 00:46:35,069
under standard yet but it is implemented

00:46:31,569 --> 00:46:37,059
by canoe and client a GCC and clang and

00:46:35,069 --> 00:46:38,529
there's no real reason it shouldn't be

00:46:37,059 --> 00:46:40,059
understand that especially since it

00:46:38,529 --> 00:46:42,309
enables things like this and there are

00:46:40,059 --> 00:46:44,289
other ways of declaring are your string

00:46:42,309 --> 00:46:45,549
literals but some of them we couldn't

00:46:44,289 --> 00:46:46,929
get them to compile even though our

00:46:45,549 --> 00:46:47,880
reading of the standard says that it

00:46:46,929 --> 00:46:59,400
should have

00:46:47,880 --> 00:47:02,069
I believe possibly exactly they techne

00:46:59,400 --> 00:47:03,990
templated so this is not quite standard

00:47:02,069 --> 00:47:05,640
because the templated operator the

00:47:03,990 --> 00:47:06,930
template the operator for this form of

00:47:05,640 --> 00:47:09,329
user-defined literal is not in the

00:47:06,930 --> 00:47:12,240
standard but it is implemented by GCC in

00:47:09,329 --> 00:47:16,430
claim because the tie this particular

00:47:12,240 --> 00:47:19,589
form of the udl yes is templated yes

00:47:16,430 --> 00:47:21,150
okay so but having done that we now have

00:47:19,589 --> 00:47:22,890
solved problem three and the cost of an

00:47:21,150 --> 00:47:25,890
extra pass to figure out how many values

00:47:22,890 --> 00:47:27,509
we want we get much quicker compilation

00:47:25,890 --> 00:47:29,009
there's no recursive templates anymore

00:47:27,509 --> 00:47:30,390
that all those function templates all

00:47:29,009 --> 00:47:32,809
those recursive function templates are

00:47:30,390 --> 00:47:34,799
gone replaced by just plain functions

00:47:32,809 --> 00:47:36,329
and that means there's no arbitrary

00:47:34,799 --> 00:47:37,829
hard-coded limit to the depth of our

00:47:36,329 --> 00:47:39,869
JSON object so we can have tests that

00:47:37,829 --> 00:47:44,509
say things like this where I just mash

00:47:39,869 --> 00:47:46,799
on the bracket and and that works

00:47:44,509 --> 00:47:48,839
problem for we still have these

00:47:46,799 --> 00:47:51,569
arbitrary limits on string size array

00:47:48,839 --> 00:47:53,490
size and object size right so I thought

00:47:51,569 --> 00:47:56,069
about this and I thought well can we use

00:47:53,490 --> 00:47:57,869
the same technique of pre computing size

00:47:56,069 --> 00:48:02,130
to get around these and the answer is

00:47:57,869 --> 00:48:04,170
for Strings yes because what we can do

00:48:02,130 --> 00:48:07,200
is in the same way we're pre computing

00:48:04,170 --> 00:48:08,940
the the number of values required we can

00:48:07,200 --> 00:48:10,920
pre compute the total string space we're

00:48:08,940 --> 00:48:14,369
going to need and we use exactly the

00:48:10,920 --> 00:48:15,960
same kind of technique do that we where

00:48:14,369 --> 00:48:18,390
we would where we previously have right

00:48:15,960 --> 00:48:20,009
size the value buffer will just write

00:48:18,390 --> 00:48:24,210
size a character buffer for the string

00:48:20,009 --> 00:48:26,789
and then strings will become effectively

00:48:24,210 --> 00:48:30,269
string views into that buffer as we pass

00:48:26,789 --> 00:48:32,519
and we can wrap up that number of values

00:48:30,269 --> 00:48:34,470
parser and the total string size parser

00:48:32,519 --> 00:48:35,549
they're fundamentally working they can

00:48:34,470 --> 00:48:37,500
work at the same time because they're

00:48:35,549 --> 00:48:40,289
producing independent results from the

00:48:37,500 --> 00:48:42,720
same pass of the input and just return

00:48:40,289 --> 00:48:45,990
the pair of sizes and so that's what

00:48:42,720 --> 00:48:48,930
this looks like so if we have you know a

00:48:45,990 --> 00:48:50,819
JSON object with strings in it and we've

00:48:48,930 --> 00:48:52,859
right-sized the value buffer and we've

00:48:50,819 --> 00:48:54,599
right-sized the string buffer then our

00:48:52,859 --> 00:48:56,519
pars ends up looking like this in terms

00:48:54,599 --> 00:48:58,470
of memory layout we've got our values

00:48:56,519 --> 00:49:00,150
again for the string ones you'll see

00:48:58,470 --> 00:49:02,550
that the strings can

00:49:00,150 --> 00:49:10,020
effectively the string views into the

00:49:02,550 --> 00:49:13,530
character buffer we still have limits on

00:49:10,020 --> 00:49:15,120
array size object size then and these

00:49:13,530 --> 00:49:16,620
are we can't naively get around these in

00:49:15,120 --> 00:49:19,320
the same way because parsing is

00:49:16,620 --> 00:49:20,510
fundamentally recursive thing is

00:49:19,320 --> 00:49:24,300
fundamentally doing a depth-first

00:49:20,510 --> 00:49:26,220
traversal of the parse tree and so for

00:49:24,300 --> 00:49:27,660
that reason things in an array don't

00:49:26,220 --> 00:49:29,730
have to be contiguous you can see in

00:49:27,660 --> 00:49:31,820
this example that because the second

00:49:29,730 --> 00:49:34,920
element of that array is itself an array

00:49:31,820 --> 00:49:36,930
the the object layout is not contiguous

00:49:34,920 --> 00:49:38,880
the children of the top-level array are

00:49:36,930 --> 00:49:41,250
not contiguous that means we can't

00:49:38,880 --> 00:49:43,830
represent them naively with offset plus

00:49:41,250 --> 00:49:47,160
extent because they could be arbitrarily

00:49:43,830 --> 00:49:50,880
nested so again the answer is we've got

00:49:47,160 --> 00:49:52,970
a positive framework let's use it and we

00:49:50,880 --> 00:49:56,700
can add another pass to make a

00:49:52,970 --> 00:49:57,930
positively breadth-first and the way

00:49:56,700 --> 00:50:01,170
that works is that when you're doing the

00:49:57,930 --> 00:50:03,360
initial pass over an array what you're

00:50:01,170 --> 00:50:05,160
going to store is just the unpassed

00:50:03,360 --> 00:50:07,410
string view representing that array or

00:50:05,160 --> 00:50:09,900
your structural stuff works but you get

00:50:07,410 --> 00:50:12,840
out is not the recursed into values but

00:50:09,900 --> 00:50:14,400
just the string view of that array and

00:50:12,840 --> 00:50:15,600
then once you've done that for all the

00:50:14,400 --> 00:50:18,270
children of the array then you can go

00:50:15,600 --> 00:50:20,160
back and do your parsing and put the

00:50:18,270 --> 00:50:21,510
values at the end where they belong and

00:50:20,160 --> 00:50:26,550
get all your values in your children

00:50:21,510 --> 00:50:27,720
contiguous so with that approach what we

00:50:26,550 --> 00:50:29,370
see is this is kind of an interim

00:50:27,720 --> 00:50:32,280
intermediate stage of parsing this array

00:50:29,370 --> 00:50:34,020
so we've passed the array itself the

00:50:32,280 --> 00:50:38,250
array object becomes the thing at 0 and

00:50:34,020 --> 00:50:41,430
then it's 3 children so far we've just

00:50:38,250 --> 00:50:42,750
done the we've just passed out what the

00:50:41,430 --> 00:50:45,780
extents that they have in the string

00:50:42,750 --> 00:50:47,520
view and then we can go back having done

00:50:45,780 --> 00:50:50,780
this and made our children contiguous we

00:50:47,520 --> 00:50:53,570
can go back in in positions 4 and 5 and

00:50:50,780 --> 00:50:57,180
yeah so in position 1 we'll end up with

00:50:53,570 --> 00:51:00,450
with a number 1 in position 2 we'll end

00:50:57,180 --> 00:51:03,000
up with an array whose children are 4

00:51:00,450 --> 00:51:06,510
and 5 and in position 3 we'll end up

00:51:03,000 --> 00:51:09,900
with number 4 but now you can see that

00:51:06,510 --> 00:51:11,670
all of the children of an array are

00:51:09,900 --> 00:51:13,890
contiguous and so when the array can be

00:51:11,670 --> 00:51:16,530
stored as offset plus extent

00:51:13,890 --> 00:51:20,040
right we don't need to store n values in

00:51:16,530 --> 00:51:21,990
the array and we've done that with

00:51:20,040 --> 00:51:24,990
narae's so we can do it with objects as

00:51:21,990 --> 00:51:26,880
well because objects are just an array

00:51:24,990 --> 00:51:28,740
of pairs of keys and values and the keys

00:51:26,880 --> 00:51:31,020
are strings and we know how to do

00:51:28,740 --> 00:51:33,270
strings and the values we don't have to

00:51:31,020 --> 00:51:35,460
do so we can apply the same technique

00:51:33,270 --> 00:51:39,990
that we applied to arrays to linearize

00:51:35,460 --> 00:51:41,880
the object children and here's the

00:51:39,990 --> 00:51:44,010
result of that so so an object is really

00:51:41,880 --> 00:51:50,520
an array of alternating strings and

00:51:44,010 --> 00:51:51,900
values so with all those techniques

00:51:50,520 --> 00:51:55,110
together finally we get to point where

00:51:51,900 --> 00:51:57,240
no templates and no limits on the

00:51:55,110 --> 00:52:00,380
recursive depth on our array size on the

00:51:57,240 --> 00:52:03,960
object size and this is kind of what our

00:52:00,380 --> 00:52:04,980
final although you know the extent of

00:52:03,960 --> 00:52:07,830
you is repeated three times really

00:52:04,980 --> 00:52:10,080
doesn't need to be here but for the sake

00:52:07,830 --> 00:52:11,880
of the talk but this is kind of the

00:52:10,080 --> 00:52:20,250
final representation of our JSON value

00:52:11,880 --> 00:52:22,980
as parsed out by our puzzle so I think

00:52:20,250 --> 00:52:27,270
we're in that time but the conclusion to

00:52:22,980 --> 00:52:29,430
pausing is that concept for lambdas

00:52:27,270 --> 00:52:31,530
really enable this right so that was the

00:52:29,430 --> 00:52:34,170
whole reason that I was able to build up

00:52:31,530 --> 00:52:37,620
the parts of Combinator's and actually

00:52:34,170 --> 00:52:39,540
make this work at all and they enable a

00:52:37,620 --> 00:52:40,920
lot more complex literals so once you

00:52:39,540 --> 00:52:43,230
have those combinators you can plug them

00:52:40,920 --> 00:52:45,270
together in arbitrary ways to pass a

00:52:43,230 --> 00:52:47,550
bunch of things JSON is just kind of one

00:52:45,270 --> 00:52:52,620
example of what can be attacked with

00:52:47,550 --> 00:52:54,150
this kind of technique thanks to that

00:52:52,620 --> 00:52:56,070
template user-defined literal operator

00:52:54,150 --> 00:52:59,340
which I hope becomes standard but at

00:52:56,070 --> 00:53:01,440
least it is in clang and GCC you can do

00:52:59,340 --> 00:53:03,780
multiple passes and that means that you

00:53:01,440 --> 00:53:07,710
can vaguely solve almost any problem

00:53:03,780 --> 00:53:09,720
with multiple pauses and I don't know

00:53:07,710 --> 00:53:11,930
but maybe there's a concept applicable

00:53:09,720 --> 00:53:11,930
here

00:53:12,480 --> 00:53:17,440
now up to you I think we want to do the

00:53:15,670 --> 00:53:18,670
demo well you know I don't want to show

00:53:17,440 --> 00:53:23,610
you I don't want to like go through all

00:53:18,670 --> 00:53:26,550
this stuff and then not show you guys or

00:53:23,610 --> 00:53:29,560
not show people you know the proof here

00:53:26,550 --> 00:53:36,280
so I just want to show you that this

00:53:29,560 --> 00:53:39,400
actually does work here is the example

00:53:36,280 --> 00:53:43,090
that you saw at the top of the talk so

00:53:39,400 --> 00:53:44,740
here we've got a JSON object and in

00:53:43,090 --> 00:53:46,330
particular we've got a key value here

00:53:44,740 --> 00:53:48,490
which is feature of X and the feature X

00:53:46,330 --> 00:53:50,080
enabled true right and then I've got an

00:53:48,490 --> 00:53:52,030
if context Pro which is going to output

00:53:50,080 --> 00:53:53,800
the appropriate thing depending on

00:53:52,030 --> 00:53:55,540
whether the features enabled or not and

00:53:53,800 --> 00:53:57,730
this is everything here is context pro

00:53:55,540 --> 00:54:00,070
well stood out it's not constant

00:53:57,730 --> 00:54:01,000
obviously but you can see that you know

00:54:00,070 --> 00:54:02,500
when I compile this

00:54:01,000 --> 00:54:03,970
I'll get either one output or the other

00:54:02,500 --> 00:54:08,590
depending on whether this context per

00:54:03,970 --> 00:54:15,460
thing is true so I'm just gonna make a

00:54:08,590 --> 00:54:19,330
shell here over here and I think I built

00:54:15,460 --> 00:54:20,620
it earlier so I could just run but you

00:54:19,330 --> 00:54:24,780
know what I'm gonna actually show you

00:54:20,620 --> 00:54:31,420
guys how long it takes to compile oh oh

00:54:24,780 --> 00:54:36,070
I'm in my okay okay so I'm gonna do a

00:54:31,420 --> 00:54:40,300
mate cleaning and this is a few years

00:54:36,070 --> 00:54:41,830
old laptop so and if I hit make then

00:54:40,300 --> 00:54:45,310
you'll see approximately how long it

00:54:41,830 --> 00:54:47,320
takes to compile and this laptop is not

00:54:45,310 --> 00:54:51,570
very fast but you know it was it

00:54:47,320 --> 00:54:51,570
actually built and then if I run it

00:54:51,870 --> 00:54:56,610
where are we oh we're in build yes

00:54:56,920 --> 00:55:13,650
so it's in sauce test test test cpp con

00:55:07,290 --> 00:55:13,650
number one and it says feature X enabled

00:55:19,020 --> 00:55:24,370
so as I was saying and and so I have a

00:55:22,690 --> 00:55:26,200
question for you Jason there because a

00:55:24,370 --> 00:55:28,060
couple of days ago I started working up

00:55:26,200 --> 00:55:31,000
a little extra demo which Jason doesn't

00:55:28,060 --> 00:55:32,050
know about apparently but you know I was

00:55:31,000 --> 00:55:36,970
saying that this isn't just applicable

00:55:32,050 --> 00:55:38,620
JSON the question I have for you Jason

00:55:36,970 --> 00:55:41,230
is do you think it would be useful in

00:55:38,620 --> 00:55:42,850
choice group for example uh-huh if you

00:55:41,230 --> 00:55:44,560
could do regular expressions at compile

00:55:42,850 --> 00:55:46,360
time or regular expressions at compile

00:55:44,560 --> 00:55:49,480
time would be helpful I think for all of

00:55:46,360 --> 00:55:52,570
us I know you had you had talked about

00:55:49,480 --> 00:55:56,440
wanting to do that but parsing regular

00:55:52,570 --> 00:55:58,000
expressions is not trivial and I and I

00:55:56,440 --> 00:56:08,140
hasten to add that this is very much a

00:55:58,000 --> 00:56:11,860
work in progress but so here here I have

00:56:08,140 --> 00:56:15,100
a context for a regular expression with

00:56:11,860 --> 00:56:16,600
an underscore re literal and you can see

00:56:15,100 --> 00:56:18,310
that it's just like the simplest email

00:56:16,600 --> 00:56:20,440
that you could ever imagine

00:56:18,310 --> 00:56:22,270
sympathy email check and here's jason's

00:56:20,440 --> 00:56:23,860
email and now we've got some driver code

00:56:22,270 --> 00:56:24,610
this is test code right now so this is

00:56:23,860 --> 00:56:26,440
work in progress

00:56:24,610 --> 00:56:28,870
but you can see i've got static asserts

00:56:26,440 --> 00:56:32,280
that the captured values are going to be

00:56:28,870 --> 00:56:34,870
jason and empty crate comm right this is

00:56:32,280 --> 00:56:38,440
even more impressive than JSON parsing

00:56:34,870 --> 00:56:43,290
and i honestly have not seen this until

00:56:38,440 --> 00:56:45,580
just now this is totally new to jason so

00:56:43,290 --> 00:56:48,580
they're keeping it real like i've

00:56:45,580 --> 00:56:50,530
unplanned demos yeah well I had to

00:56:48,580 --> 00:56:53,830
change something up since Aspen a Paris

00:56:50,530 --> 00:56:56,260
so again I'm gonna make clean so you

00:56:53,830 --> 00:56:59,710
guys can see so people can see you know

00:56:56,260 --> 00:57:01,390
how quick this is to compile or at least

00:56:59,710 --> 00:57:04,030
that it's it's it's usable in real life

00:57:01,390 --> 00:57:08,050
in terms of compile speed yeah

00:57:04,030 --> 00:57:09,700
and then if I run well actually there

00:57:08,050 --> 00:57:12,630
there is no output but the fact that

00:57:09,700 --> 00:57:12,630
compiled in fact

00:57:17,160 --> 00:57:22,980
that needs a standard proposal right

00:57:19,900 --> 00:57:26,170
there Ben we all need one expert

00:57:22,980 --> 00:57:28,030
Russians well okay so I'm going to set a

00:57:26,170 --> 00:57:30,940
new world record for how quickly I move

00:57:28,030 --> 00:57:33,099
through 20 slides yes don't want to go

00:57:30,940 --> 00:57:37,260
out for lunch we won't be offended but I

00:57:33,099 --> 00:57:40,180
think the right window more focus hmm

00:57:37,260 --> 00:57:44,440
what do I need to click on here try that

00:57:40,180 --> 00:57:49,180
okay all right okay so problems and

00:57:44,440 --> 00:57:51,040
things so you cannot anything that has a

00:57:49,180 --> 00:57:53,319
non-trivial destructor cannot be used in

00:57:51,040 --> 00:57:56,800
two contexts for context so we're gonna

00:57:53,319 --> 00:57:58,300
do a quick quiz is this struct trivially

00:57:56,800 --> 00:57:59,670
destructible everyone raise your hand if

00:57:58,300 --> 00:58:02,230
you think it's too real destructible

00:57:59,670 --> 00:58:03,760
all right everyone agrees yes it is

00:58:02,230 --> 00:58:07,109
trivially destructible is this one

00:58:03,760 --> 00:58:09,579
trivially destructible we all agree

00:58:07,109 --> 00:58:11,380
mostly still trivially except a

00:58:09,579 --> 00:58:17,470
destructible is this trivially

00:58:11,380 --> 00:58:20,109
destructible I saw so somebody like this

00:58:17,470 --> 00:58:22,060
real quick no this is not trivially

00:58:20,109 --> 00:58:23,920
destructible because it has a unique

00:58:22,060 --> 00:58:25,180
pointer inside it which is itself not

00:58:23,920 --> 00:58:27,670
trivially destructible in the

00:58:25,180 --> 00:58:29,170
automatically defined destructor there's

00:58:27,670 --> 00:58:40,720
not going to be trivially destructible

00:58:29,170 --> 00:58:42,490
is this trivially destructible what yes

00:58:40,720 --> 00:58:46,150
simply mentioning the destructor means

00:58:42,490 --> 00:58:49,230
it's no longer trivially destructible so

00:58:46,150 --> 00:58:52,270
that this is not trivially destructible

00:58:49,230 --> 00:58:54,520
so and it's the same if you put equals

00:58:52,270 --> 00:58:57,940
default there no V but equals default

00:58:54,520 --> 00:59:00,160
then it is still trivially okay if if

00:58:57,940 --> 00:59:04,150
the default lead to find one would be

00:59:00,160 --> 00:59:07,390
trivial than it is trivial excuse me

00:59:04,150 --> 00:59:09,069
so this matters because if we wanted to

00:59:07,390 --> 00:59:10,930
somehow create one of our compile-time

00:59:09,069 --> 00:59:14,260
constant for vectors or something that

00:59:10,930 --> 00:59:17,170
could grow beyond the allowed space that

00:59:14,260 --> 00:59:18,849
we specified we are perfectly allowed to

00:59:17,170 --> 00:59:20,680
write something like this where our push

00:59:18,849 --> 00:59:23,190
back now they don't actually implement

00:59:20,680 --> 00:59:25,710
code like this it's horrible but

00:59:23,190 --> 00:59:29,099
push back if it grows beyond a certain

00:59:25,710 --> 00:59:32,040
size is able to allocate memory we can

00:59:29,099 --> 00:59:33,150
do that if it happens at runtime we

00:59:32,040 --> 00:59:35,640
can't do it at Abbott's at compile time

00:59:33,150 --> 00:59:37,829
so this is great we could plausibly make

00:59:35,640 --> 00:59:39,480
containers that are highly efficient at

00:59:37,829 --> 00:59:42,510
compile time and can expand at runtime

00:59:39,480 --> 00:59:44,339
if they need to as soon as we add the

00:59:42,510 --> 00:59:48,180
destructor the class is no longer

00:59:44,339 --> 00:59:50,430
constructs were enabled and we can build

00:59:48,180 --> 00:59:52,560
this thing but we are basically required

00:59:50,430 --> 00:59:54,270
to leak memory because we don't have any

00:59:52,560 --> 01:00:00,030
way of calling the destructor if it

00:59:54,270 --> 01:00:02,010
needed to be called at runtime so there

01:00:00,030 --> 01:00:03,660
is a proposal out there I don't have the

01:00:02,010 --> 01:00:07,050
number for it or anything where we can

01:00:03,660 --> 01:00:11,369
do this and say if the body of the

01:00:07,050 --> 01:00:13,890
destructor is empty then it counts as

01:00:11,369 --> 01:00:16,109
trivially destructible or is allowed at

01:00:13,890 --> 01:00:19,140
compile time in context for context to

01:00:16,109 --> 01:00:21,270
neo that doesn't solve this problem

01:00:19,140 --> 01:00:25,430
though because I have to make a bit of a

01:00:21,270 --> 01:00:27,510
compile time runtime decision I

01:00:25,430 --> 01:00:29,280
personally think that our destructor

01:00:27,510 --> 01:00:31,440
should be de treated like any other

01:00:29,280 --> 01:00:33,359
constructs per code that anything that

01:00:31,440 --> 01:00:35,700
you do at compile time that's allowed at

01:00:33,359 --> 01:00:37,020
compile time is allowed and if you try

01:00:35,700 --> 01:00:38,520
to do something at compile time that's

01:00:37,020 --> 01:00:39,960
not allowed at compile time then it

01:00:38,520 --> 01:00:41,700
would fail to compile so I could put a

01:00:39,960 --> 01:00:44,280
delete in here and it would only fail to

01:00:41,700 --> 01:00:53,579
compile if it actually called the the

01:00:44,280 --> 01:00:58,099
delete so I'm gonna skip that side the

01:00:53,579 --> 01:01:00,690
wrong line is the answer yeah so the the

01:00:58,099 --> 01:01:02,490
we throughout the course of developing

01:01:00,690 --> 01:01:04,230
this we had problems debugging it

01:01:02,490 --> 01:01:06,390
because actually debugging compile time

01:01:04,230 --> 01:01:08,760
errors in this kind of context can be

01:01:06,390 --> 01:01:11,520
rather gruesome there was a couple cases

01:01:08,760 --> 01:01:13,500
where I had to like remove context burr

01:01:11,520 --> 01:01:15,960
so that it would fail at run time

01:01:13,500 --> 01:01:18,089
instead of compile time and then hop

01:01:15,960 --> 01:01:19,770
into the debugger and be like oh I had

01:01:18,089 --> 01:01:24,540
an off by one error or something and it

01:01:19,770 --> 01:01:27,329
was difficult to do so so so we're was

01:01:24,540 --> 01:01:29,069
had to think very hard about types yes

01:01:27,329 --> 01:01:31,740
yeah you had to think very hard about

01:01:29,069 --> 01:01:36,180
types I had to think about it like index

01:01:31,740 --> 01:01:39,270
yeah so there's several proposals out

01:01:36,180 --> 01:01:42,300
there all of them by David right so

01:01:39,270 --> 01:01:43,920
we've got a yes a context per operator

01:01:42,300 --> 01:01:46,830
that would help you determine if

01:01:43,920 --> 01:01:49,080
something is being evaluated at in the

01:01:46,830 --> 01:01:51,720
context for context that could be a lot

01:01:49,080 --> 01:01:53,940
of fun for us contact sport race and

01:01:51,720 --> 01:01:55,260
context burr assert give you more

01:01:53,940 --> 01:01:56,580
debugging facilities so something

01:01:55,260 --> 01:01:58,980
happens at compile time you could get

01:01:56,580 --> 01:02:01,230
immense message printed out and there's

01:01:58,980 --> 01:02:03,750
someone who hacked together a static

01:02:01,230 --> 01:02:05,940
print version of this for GCC that I've

01:02:03,750 --> 01:02:07,260
played with that was awesome we probably

01:02:05,940 --> 01:02:08,880
should have used that to develop this

01:02:07,260 --> 01:02:10,500
stuff it would have cut down we have but

01:02:08,880 --> 01:02:14,730
it didn't exist when we first develop to

01:02:10,500 --> 01:02:17,369
us true but okay well earlier this year

01:02:14,730 --> 01:02:18,960
they exist at some point of me we can

01:02:17,369 --> 01:02:21,690
use it probably yeah that'd be really

01:02:18,960 --> 01:02:24,270
useful and then devide also has this

01:02:21,690 --> 01:02:26,730
context Perfector idea which is

01:02:24,270 --> 01:02:28,290
basically in the vector that I was

01:02:26,730 --> 01:02:31,080
playing with but it can actually keep

01:02:28,290 --> 01:02:37,380
growing at compile time so it would be a

01:02:31,080 --> 01:02:42,930
built-in thing mm-hmm and also I alluded

01:02:37,380 --> 01:02:44,910
to this earlier so Antony and Alexander

01:02:42,930 --> 01:02:48,150
and I'd cannot pronounce their last

01:02:44,910 --> 01:02:50,730
names have written this paper on

01:02:48,150 --> 01:02:55,410
actually implementing context for

01:02:50,730 --> 01:02:58,080
allocators so that we can you you could

01:02:55,410 --> 01:03:00,030
they made a version of vector that had a

01:02:58,080 --> 01:03:02,550
context for allocator plugged into it or

01:03:00,030 --> 01:03:05,070
you could do a regular runtime allocator

01:03:02,550 --> 01:03:08,880
with it and it works I've seen the code

01:03:05,070 --> 01:03:12,869
it's neat what they did and I we should

01:03:08,880 --> 01:03:14,760
probably be moving in this direction yes

01:03:12,869 --> 01:03:17,460
and actually Alexander pointed that out

01:03:14,760 --> 01:03:19,280
to us after we gave the talk yeah let's

01:03:17,460 --> 01:03:21,870
see this was now

01:03:19,280 --> 01:03:26,640
as we already said all the algorithms

01:03:21,870 --> 01:03:28,470
they need to be constant for these three

01:03:26,640 --> 01:03:30,810
stable certain place Marge

01:03:28,470 --> 01:03:34,110
excuse me in place merge and stable

01:03:30,810 --> 01:03:36,510
partition all have the option of

01:03:34,110 --> 01:03:38,490
allocating memory at runtime for

01:03:36,510 --> 01:03:42,570
efficiency complexity guarantees right

01:03:38,490 --> 01:03:44,700
yes but but the way the standards

01:03:42,570 --> 01:03:46,200
actually written they are allowed not to

01:03:44,700 --> 01:03:49,290
do that and fall back to a weaker

01:03:46,200 --> 01:03:50,760
complexity so they could be context for

01:03:49,290 --> 01:03:52,170
and it would technically be in line with

01:03:50,760 --> 01:03:54,030
the current standard but of course at

01:03:52,170 --> 01:03:58,770
compile time they wouldn't be able to

01:03:54,030 --> 01:04:00,450
offer the the better complexity right we

01:03:58,770 --> 01:04:02,490
ran into some problems with iterators

01:04:00,450 --> 01:04:04,620
there but there's no reason why it

01:04:02,490 --> 01:04:07,290
couldn't all be concepts were again so

01:04:04,620 --> 01:04:09,690
back insert iterator yeah I was not even

01:04:07,290 --> 01:04:11,160
wrote our own back into iterator just

01:04:09,690 --> 01:04:13,860
because we had a console expert vector

01:04:11,160 --> 01:04:15,180
and that was fine but there's no reason

01:04:13,860 --> 01:04:17,070
why that couldn't be even if the vector

01:04:15,180 --> 01:04:20,100
itself isn't but if we're building our

01:04:17,070 --> 01:04:22,650
other constructs for containers so

01:04:20,100 --> 01:04:25,590
things that should be we mentioned swap

01:04:22,650 --> 01:04:28,230
we did not mention exchange so dislike

01:04:25,590 --> 01:04:31,170
swab it's yes exchange should totally be

01:04:28,230 --> 01:04:33,000
constructs but it's not yet as to pair

01:04:31,170 --> 01:04:35,220
out and tubal we didn't explicitly

01:04:33,000 --> 01:04:36,690
mention tuple yet had the same problem

01:04:35,220 --> 01:04:41,160
with our assignment operators back

01:04:36,690 --> 01:04:43,770
insert all of standard array except for

01:04:41,160 --> 01:04:46,350
the fill member function its context per

01:04:43,770 --> 01:04:51,630
that one I'm really confused about

01:04:46,350 --> 01:04:53,340
personally reference wrapper you know

01:04:51,630 --> 01:04:55,500
I've actually thought more about this

01:04:53,340 --> 01:04:58,920
since we put this on here and I'm not a

01:04:55,500 --> 01:05:01,590
mind I'm not positive yes all right but

01:04:58,920 --> 01:05:03,420
it's a plausibility initializer lists

01:05:01,590 --> 01:05:06,390
have issues that we can't get into in

01:05:03,420 --> 01:05:11,100
the next negative minutes that we have

01:05:06,390 --> 01:05:13,500
available structured bindings also have

01:05:11,100 --> 01:05:14,910
things that every student yeah I was

01:05:13,500 --> 01:05:15,990
actually quite surprised because you

01:05:14,910 --> 01:05:17,580
know structured bindings that see

01:05:15,990 --> 01:05:19,920
purpose 17 they're born into a world of

01:05:17,580 --> 01:05:22,530
context per they are not contacts can I

01:05:19,920 --> 01:05:26,210
be used in a context for context yes and

01:05:22,530 --> 01:05:26,210
of course everything else

01:05:27,470 --> 01:05:32,520
there we we didn't really mention this

01:05:30,900 --> 01:05:33,630
maybe touched on a little bit that as we

01:05:32,520 --> 01:05:34,800
are developing this we've noticed lots

01:05:33,630 --> 01:05:36,240
of holes in standard library

01:05:34,800 --> 01:05:38,130
implementations even the ones that are

01:05:36,240 --> 01:05:41,520
like we're done we're C++ seventeen

01:05:38,130 --> 01:05:44,670
complete and this is by no means a slur

01:05:41,520 --> 01:05:46,170
on the implementers no like no don't

01:05:44,670 --> 01:05:47,970
take it that way this is this is just

01:05:46,170 --> 01:05:49,880
how I think the fact that it is clear

01:05:47,970 --> 01:05:52,020
that standard library movement ations

01:05:49,880 --> 01:05:53,340
basically neither doubling up of all

01:05:52,020 --> 01:05:56,160
their tests to deal with concepts for

01:05:53,340 --> 01:05:59,010
yeah and the one that I think is kind of

01:05:56,160 --> 01:06:01,200
personally a little humorous as yeah I

01:05:59,010 --> 01:06:03,720
mean and not and again not a job of the

01:06:01,200 --> 01:06:06,720
implementers at all but that's and GCC

01:06:03,720 --> 01:06:09,750
7.2 still you cannot actually construct

01:06:06,720 --> 01:06:12,060
a string view context per because it

01:06:09,750 --> 01:06:14,730
tries to call the non context per stream

01:06:12,060 --> 01:06:17,030
line to calculate the length of the

01:06:14,730 --> 01:06:21,720
character literal and you promised ring

01:06:17,030 --> 01:06:23,190
from a character literal well but my

01:06:21,720 --> 01:06:25,560
regular expression thing does that I

01:06:23,190 --> 01:06:27,000
think where you're not I think you you

01:06:25,560 --> 01:06:28,890
have to if you give it the pointer and

01:06:27,000 --> 01:06:30,240
the length it can if you give it just

01:06:28,890 --> 01:06:31,380
the point you're giving it they get

01:06:30,240 --> 01:06:33,810
usually defined that's to be literal

01:06:31,380 --> 01:06:38,580
video that's a different constructor I

01:06:33,810 --> 01:06:40,590
believe oh okay yes yeah because you're

01:06:38,580 --> 01:06:43,380
right okay so that works cool

01:06:40,590 --> 01:06:45,420
so just a bad child pointer can echo yes

01:06:43,380 --> 01:06:48,840
aberrant a bear comes car literal it

01:06:45,420 --> 01:06:50,490
tails on right right so well flat data

01:06:48,840 --> 01:06:53,850
structures were easy for me to reason

01:06:50,490 --> 01:06:55,560
about but once we started in these

01:06:53,850 --> 01:06:57,480
nested things that it became a pain I

01:06:55,560 --> 01:06:59,210
couldn't I lack the imagination for it

01:06:57,480 --> 01:07:02,280
been figured it out

01:06:59,210 --> 01:07:03,930
context sir code and a good way forces

01:07:02,280 --> 01:07:05,550
you to think about what the lifetime of

01:07:03,930 --> 01:07:06,600
your objects are and then I'm really big

01:07:05,550 --> 01:07:10,380
about making people think about the

01:07:06,600 --> 01:07:11,760
lifetime of their objects and and I

01:07:10,380 --> 01:07:13,830
could just said tree-like data structure

01:07:11,760 --> 01:07:16,140
too difficult to reason about for me and

01:07:13,830 --> 01:07:17,940
if you're building your data structures

01:07:16,140 --> 01:07:19,530
you have to select a size somehow you

01:07:17,940 --> 01:07:22,230
can write a parser of a parser of

01:07:19,530 --> 01:07:23,880
parsers to do it or you have to just

01:07:22,230 --> 01:07:26,380
come up with an arbitrary number at some

01:07:23,880 --> 01:07:30,440
point right

01:07:26,380 --> 01:07:33,080
and air that was your line item right

01:07:30,440 --> 01:07:36,860
there yeah I was getting some quite long

01:07:33,080 --> 01:07:38,690
error messages let's just say that okay

01:07:36,860 --> 01:07:39,830
that's why I'm like well I just had to

01:07:38,690 --> 01:07:41,720
go back and think about the types and

01:07:39,830 --> 01:07:44,000
the error message will give me a clue

01:07:41,720 --> 01:07:46,490
sometimes so then already showed how

01:07:44,000 --> 01:07:47,540
fast those builds worked but yeah this

01:07:46,490 --> 01:07:48,560
little would like sit about five years

01:07:47,540 --> 01:07:51,710
old yes

01:07:48,560 --> 01:07:54,560
I'd like to point this out those were

01:07:51,710 --> 01:07:56,480
not debug builds right because in

01:07:54,560 --> 01:07:57,290
context pretend there's nothing to debug

01:07:56,480 --> 01:07:59,150
right

01:07:57,290 --> 01:08:01,040
there's no runtime but if you're doing

01:07:59,150 --> 01:08:02,330
context / work in your regular full

01:08:01,040 --> 01:08:04,640
application you might want to make a

01:08:02,330 --> 01:08:07,010
debug build this is what GCC's numbers

01:08:04,640 --> 01:08:09,580
GCC 7.2 is still held a bit true when I

01:08:07,010 --> 01:08:13,430
was just playing with this basically my

01:08:09,580 --> 01:08:16,370
laptop can't compile this in debug build

01:08:13,430 --> 01:08:18,319
take six gigs of RAM so it's thrashing

01:08:16,370 --> 01:08:20,960
all over swap space depending on what

01:08:18,319 --> 01:08:24,890
I'm doing more than two minutes to build

01:08:20,960 --> 01:08:27,020
and resulted in a 338 K binary keep in

01:08:24,890 --> 01:08:29,990
mind this is a 338 K binary that does

01:08:27,020 --> 01:08:31,790
nothing at runtime right because

01:08:29,990 --> 01:08:32,859
everything was calculated at compile try

01:08:31,790 --> 01:08:36,260
it

01:08:32,859 --> 01:08:36,620
this is very dependent on the debug

01:08:36,260 --> 01:08:39,080
level

01:08:36,620 --> 01:08:40,400
yeah and found out Chiqui tweaking the

01:08:39,080 --> 01:08:42,170
debug level don't have it use effect

01:08:40,400 --> 01:08:44,510
this is a line item for compiler

01:08:42,170 --> 01:08:47,299
implement as I suspect yeah

01:08:44,510 --> 01:08:49,160
they get to do the hard work so the

01:08:47,299 --> 01:08:51,680
release build I measured here it was

01:08:49,160 --> 01:08:53,839
only 328 Meg's of RAM not the 6 gigs

01:08:51,680 --> 01:08:56,450
about 5 seconds on my laptop it looked

01:08:53,839 --> 01:08:59,660
like you're on the ball don't you show

01:08:56,450 --> 01:09:03,260
me build it yeah 9 k binary cos well

01:08:59,660 --> 01:09:04,819
it's not doing anything and I just

01:09:03,260 --> 01:09:06,620
wanted to make a quick comparison before

01:09:04,819 --> 01:09:08,480
we wrap this up anyone want to take a

01:09:06,620 --> 01:09:13,609
guess as to how long this takes to

01:09:08,480 --> 01:09:16,880
compile with GCC today this is a full

01:09:13,609 --> 01:09:18,770
program yeah this is regular standard

01:09:16,880 --> 01:09:23,630
library not contacts per just using regs

01:09:18,770 --> 01:09:25,130
yeah three seconds I hear about five

01:09:23,630 --> 01:09:26,780
seconds it's about the same time as

01:09:25,130 --> 01:09:28,719
compiling our stuff that's doing it all

01:09:26,780 --> 01:09:33,650
compiled time

01:09:28,719 --> 01:09:38,089
so we say all the algorithms can become

01:09:33,650 --> 01:09:39,230
the expert and standard library

01:09:38,089 --> 01:09:42,020
implementations might need some more

01:09:39,230 --> 01:09:43,279
concepts for testing yes and this is a

01:09:42,020 --> 01:09:44,810
great that way great way for anyone to

01:09:43,279 --> 01:09:47,600
contribute to standard libraries I think

01:09:44,810 --> 01:09:49,520
we are hysts and you know programming in

01:09:47,600 --> 01:09:52,670
a concept for mindset changes the way

01:09:49,520 --> 01:09:55,280
you look at these things though oh yes

01:09:52,670 --> 01:09:58,730
see math is not constant for that's a

01:09:55,280 --> 01:10:00,290
problem for some things and let's see

01:09:58,730 --> 01:10:02,150
and context where lambdas are all

01:10:00,290 --> 01:10:04,820
powerful there

01:10:02,150 --> 01:10:07,010
I will there all right sorry for taking

01:10:04,820 --> 01:10:09,020
long and starting late in load uh yes

01:10:07,010 --> 01:10:09,170
bit longer and thank you very much thank

01:10:09,020 --> 01:10:14,449
you

01:10:09,170 --> 01:10:14,449

YouTube URL: https://www.youtube.com/watch?v=PJwd4JLYJJY


