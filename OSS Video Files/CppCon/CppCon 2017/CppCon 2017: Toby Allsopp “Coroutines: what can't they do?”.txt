Title: CppCon 2017: Toby Allsopp “Coroutines: what can't they do?”
Publication date: 2017-10-05
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Coroutines are coming. They're coming for your asynchronous operations. They're coming for your lazy generators. This much we know. But once they're here, will they be satisfied with these offerings? They will not. They will require feeding, lest they devour our very souls. We present some fun ways to keep their incessant hunger at bay. I, for one, welcome our new coroutine overlords. 

The Coroutines Technical Specification is an experimental extension to the C++ language that allows functions to be suspended and resumed, with the primary aim of simplifying code that invokes asynchronous operations. We present a short introduction to Coroutines followed by some possibly non-obvious ways they can help to simplify your code. 

Have you ever wanted to elegantly compose operations that might fail? Coroutines can help. Have you ever wished for a zero-overhead type-erased function wrapper? Coroutines can help. We show you how and more.
— 
Toby Allsopp: Senior Software Engineer, WhereScape Software Limited

Toby Allsopp has been using C++ for over 20 years and hasn't given up yet. His interests include cutting edge language features, functional programming, and solving the hard problems. Toby lives in Auckland, New Zealand, where he organizes the Auckland C++ Meetup.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:04,980
so hi I'm Toby

00:00:03,179 --> 00:00:08,360
thanks for coming it's really great to

00:00:04,980 --> 00:00:11,400
be here so kuroh teens what can they do

00:00:08,360 --> 00:00:14,549
what can they do what are they how do

00:00:11,400 --> 00:00:17,609
they work hopefully we'll make a little

00:00:14,549 --> 00:00:21,689
bit of progress answering or at least I

00:00:17,609 --> 00:00:24,240
hope you're asking these questions so

00:00:21,689 --> 00:00:27,029
start with a little intro to set the

00:00:24,240 --> 00:00:28,130
context so what am I going to be talking

00:00:27,029 --> 00:00:31,040
about

00:00:28,130 --> 00:00:33,360
so there's lots of different things that

00:00:31,040 --> 00:00:35,670
get called co-routines there's lots of

00:00:33,360 --> 00:00:36,960
things called co-routines and languages

00:00:35,670 --> 00:00:40,410
that aren't siculus first there's lots

00:00:36,960 --> 00:00:44,489
of things called co-routines in C++ but

00:00:40,410 --> 00:00:47,489
I'm specifically talking about the

00:00:44,489 --> 00:00:49,399
technical specification called C++

00:00:47,489 --> 00:00:55,980
extensions for co-routines

00:00:49,399 --> 00:00:59,579
also known as in four six eight zero to

00:00:55,980 --> 00:01:01,829
its friends currently so I'll just refer

00:00:59,579 --> 00:01:04,680
to that as the TS from now on there's a

00:01:01,829 --> 00:01:06,150
little little link here it's just a

00:01:04,680 --> 00:01:09,510
little there's a little screenshot of

00:01:06,150 --> 00:01:12,810
the front page just to give you a flavor

00:01:09,510 --> 00:01:14,340
for how exciting it is inside it's

00:01:12,810 --> 00:01:16,799
actually it's actually quite quite an

00:01:14,340 --> 00:01:20,310
easy read it's quite short it's quite

00:01:16,799 --> 00:01:23,490
nice so but what's the what's the TS

00:01:20,310 --> 00:01:28,170
talking about well apart from carotenes

00:01:23,490 --> 00:01:31,500
it is an extension to C++ it includes

00:01:28,170 --> 00:01:34,020
three new keywords and some new

00:01:31,500 --> 00:01:36,170
customization points so that's largely

00:01:34,020 --> 00:01:38,310
what I'll be talking about in this talk

00:01:36,170 --> 00:01:41,130
how those keywords work what the

00:01:38,310 --> 00:01:44,759
customization points are and what it

00:01:41,130 --> 00:01:51,210
does is enables some some new kinds of

00:01:44,759 --> 00:01:55,229
control flow well new to C++ so an

00:01:51,210 --> 00:01:58,140
expert's sort of run through how they

00:01:55,229 --> 00:02:00,930
how the transformation inside the

00:01:58,140 --> 00:02:03,570
compiler works not in complete low-level

00:02:00,930 --> 00:02:07,380
detail but sort of Error error source

00:02:03,570 --> 00:02:09,869
transformation level so first of all

00:02:07,380 --> 00:02:11,730
what Sakura teen so it is a

00:02:09,869 --> 00:02:13,500
generalization of a function so

00:02:11,730 --> 00:02:16,170
co-routines are functions

00:02:13,500 --> 00:02:19,230
but they're functions that have extra

00:02:16,170 --> 00:02:22,110
capabilities so on the on the left there

00:02:19,230 --> 00:02:24,960
is a diagram that shows a caller calling

00:02:22,110 --> 00:02:27,300
a normal function so when you call a

00:02:24,960 --> 00:02:28,880
function control flow transferred to the

00:02:27,300 --> 00:02:31,850
function the function runs to completion

00:02:28,880 --> 00:02:34,110
until it returns and in control flow

00:02:31,850 --> 00:02:36,540
transfers back to the caller at the

00:02:34,110 --> 00:02:39,270
point where it called the called the

00:02:36,540 --> 00:02:41,370
function so that should be pretty

00:02:39,270 --> 00:02:46,290
familiar to people who have called

00:02:41,370 --> 00:02:48,060
functions before the interesting thing

00:02:46,290 --> 00:02:51,630
about that well I guess the boring thing

00:02:48,060 --> 00:02:52,800
about that is that is that the the

00:02:51,630 --> 00:02:55,590
function that's called runs to

00:02:52,800 --> 00:02:57,660
completion and the caller waits for it

00:02:55,590 --> 00:03:01,620
and doesn't continue until the function

00:02:57,660 --> 00:03:05,190
is finished so on the right we have a Co

00:03:01,620 --> 00:03:06,570
routine so in this particular case the

00:03:05,190 --> 00:03:10,470
caller calls the core routine so that's

00:03:06,570 --> 00:03:12,120
the same as calling a function but this

00:03:10,470 --> 00:03:13,650
shows off a couple of the extra

00:03:12,120 --> 00:03:16,739
capabilities of co-routines

00:03:13,650 --> 00:03:18,269
so one is the curtain can suspend which

00:03:16,739 --> 00:03:20,459
transfers control flow back to its

00:03:18,269 --> 00:03:24,299
caller and then the caller carries on

00:03:20,459 --> 00:03:26,970
and then at some point later the caller

00:03:24,299 --> 00:03:28,709
can initiate a resume of the Karoo team

00:03:26,970 --> 00:03:30,989
which transfers control flow back to the

00:03:28,709 --> 00:03:33,150
co routine and it resumes at the point

00:03:30,989 --> 00:03:35,730
where it was suspended and then when the

00:03:33,150 --> 00:03:37,380
curtain returns it's just like her

00:03:35,730 --> 00:03:42,380
function of returning control flow goes

00:03:37,380 --> 00:03:42,380
back to the calling the calling function

00:03:43,370 --> 00:03:49,200
so there's a couple of other interesting

00:03:46,230 --> 00:03:52,049
things that make proteins different to

00:03:49,200 --> 00:03:55,950
functions or at least more capable than

00:03:52,049 --> 00:03:59,790
functions then non co-routine function

00:03:55,950 --> 00:04:01,829
so I should say so on the left there we

00:03:59,790 --> 00:04:06,510
see pretty much the same thing as we had

00:04:01,829 --> 00:04:09,090
on the previous slide but the the first

00:04:06,510 --> 00:04:12,329
caller can actually return back to its

00:04:09,090 --> 00:04:15,720
caller without resuming the curry teen

00:04:12,329 --> 00:04:17,489
and the co routine stays alive so the

00:04:15,720 --> 00:04:20,370
lifetime of a bokor routine is not

00:04:17,489 --> 00:04:21,870
intimately tied to the lifetime of its

00:04:20,370 --> 00:04:24,140
caller like a like a regular function

00:04:21,870 --> 00:04:24,140
errs

00:04:24,340 --> 00:04:30,840
so then we can have some other function

00:04:26,280 --> 00:04:30,840
resume the co-routine sometime later and

00:04:31,500 --> 00:04:36,480
that other function can be running on

00:04:33,880 --> 00:04:40,450
some other thread for example so there's

00:04:36,480 --> 00:04:41,560
there's an interesting control flow from

00:04:40,450 --> 00:04:43,330
the point of view of the curry chain

00:04:41,560 --> 00:04:45,610
that's possible there where the curry

00:04:43,330 --> 00:04:47,970
teen can suspend the one to read and

00:04:45,610 --> 00:04:52,630
potentially resume on a different thread

00:04:47,970 --> 00:04:54,430
and the other interesting control flow

00:04:52,630 --> 00:04:57,070
that curry teens have is they can be

00:04:54,430 --> 00:04:59,320
destroyed so on the right there

00:04:57,070 --> 00:05:02,560
we see one caller calls the coyote and

00:04:59,320 --> 00:05:04,660
the curtain suspends the control flow

00:05:02,560 --> 00:05:08,440
transfers back to the caller and then

00:05:04,660 --> 00:05:11,169
later on the curry teen can be destroyed

00:05:08,440 --> 00:05:13,030
which transfers the flow of control

00:05:11,169 --> 00:05:14,410
right to the very end of the co-routine

00:05:13,030 --> 00:05:16,720
where the destructors and everything run

00:05:14,410 --> 00:05:18,300
everything gets cleaned up and the bit

00:05:16,720 --> 00:05:20,950
in the middle of the go routine is

00:05:18,300 --> 00:05:23,980
completely skipped and that's that's

00:05:20,950 --> 00:05:29,110
quite useful as we'll see a bit later on

00:05:23,980 --> 00:05:32,919
so here's a here's a really simple

00:05:29,110 --> 00:05:34,510
example of a curry routine and it's on

00:05:32,919 --> 00:05:38,530
the on the right hand side there the co

00:05:34,510 --> 00:05:40,840
routine it's called calculate it's it's

00:05:38,530 --> 00:05:46,810
Co routine that's so nice I wrote it

00:05:40,840 --> 00:05:48,910
twice the so it all all that does is it

00:05:46,810 --> 00:05:51,610
perform some expensive calculation and

00:05:48,910 --> 00:05:54,070
then returns the result so you can see

00:05:51,610 --> 00:05:58,540
there the first of the three new

00:05:54,070 --> 00:06:00,400
keywords Co returned and the the other

00:05:58,540 --> 00:06:02,919
interesting thing is the return type of

00:06:00,400 --> 00:06:04,720
this Co routine so this lazy type is

00:06:02,919 --> 00:06:07,320
something that I've just invented out of

00:06:04,720 --> 00:06:12,820
whole cloth for this presentation you

00:06:07,320 --> 00:06:16,780
and it's um that is where a lot of the

00:06:12,820 --> 00:06:18,820
customization points set so this slide

00:06:16,780 --> 00:06:21,580
shows two different two different ways

00:06:18,820 --> 00:06:23,380
that this curry team can be can be used

00:06:21,580 --> 00:06:26,560
so the first one over on the top is

00:06:23,380 --> 00:06:30,400
where the caller calls the Co routine

00:06:26,560 --> 00:06:33,460
but never uses the result so in that

00:06:30,400 --> 00:06:36,669
case you can see when this lazy resolve

00:06:33,460 --> 00:06:37,689
goes out of scope goes out of scope the

00:06:36,669 --> 00:06:42,159
destructor of the career

00:06:37,689 --> 00:06:44,199
called destroys the carotene sorry the

00:06:42,159 --> 00:06:46,769
destructor of their lazy class destroys

00:06:44,199 --> 00:06:49,809
the curry routine and the expensive work

00:06:46,769 --> 00:06:53,559
is not done in that case because nobody

00:06:49,809 --> 00:06:57,759
wanted it the second case you can see

00:06:53,559 --> 00:07:00,429
the caller calls the this gate which

00:06:57,759 --> 00:07:07,299
resumed the carotene performs the

00:07:00,429 --> 00:07:13,749
expensive work returns a result and all

00:07:07,299 --> 00:07:18,249
as well so so this shows sort of a an

00:07:13,749 --> 00:07:21,239
artist's impression I guess of of what

00:07:18,249 --> 00:07:25,169
the compiler does to the curry teen body

00:07:21,239 --> 00:07:27,849
so this is not a this is not exact it is

00:07:25,169 --> 00:07:31,119
it's not specified like this in the TS

00:07:27,849 --> 00:07:32,649
but this is kind of what it yeah the t

00:07:31,119 --> 00:07:36,339
it has an example like this I didn't

00:07:32,649 --> 00:07:38,709
just make it up so so so there on the

00:07:36,339 --> 00:07:40,059
left there is the carotene body just the

00:07:38,709 --> 00:07:44,079
same as on the previous slide except

00:07:40,059 --> 00:07:48,219
slightly more colorful and on the right

00:07:44,079 --> 00:07:50,679
is what the what the compiler kind of

00:07:48,219 --> 00:07:52,360
generates under the covers so the first

00:07:50,679 --> 00:07:54,039
thing it does is it needs to find out

00:07:52,360 --> 00:07:56,289
the promise type so there that is the

00:07:54,039 --> 00:07:59,199
primary customization point for a

00:07:56,289 --> 00:08:00,579
protein so it looks that up using using

00:07:59,199 --> 00:08:03,789
this class template called co-routine

00:08:00,579 --> 00:08:06,699
traits so it feeds into that as template

00:08:03,789 --> 00:08:09,639
parameters the return type of the Co

00:08:06,699 --> 00:08:11,169
routine and the types of any parameters

00:08:09,639 --> 00:08:15,519
so there are no parameters in this case

00:08:11,169 --> 00:08:17,769
which makes it easy so there that

00:08:15,519 --> 00:08:22,689
couraging trade specialization needs to

00:08:17,769 --> 00:08:25,629
define a promise type so then and an

00:08:22,689 --> 00:08:27,039
object of that type is created looks

00:08:25,629 --> 00:08:29,079
like a local variable here but it's

00:08:27,039 --> 00:08:32,139
actually stored in something called the

00:08:29,079 --> 00:08:34,209
kuru teen state which is a say for a

00:08:32,139 --> 00:08:38,949
block of memory so I'll describe that

00:08:34,209 --> 00:08:45,279
soon so then the the the promise object

00:08:38,949 --> 00:08:47,980
P here that gets asked for the return

00:08:45,279 --> 00:08:49,750
object which is what the caller of the

00:08:47,980 --> 00:08:51,580
co-routine will receive as the return

00:08:49,750 --> 00:08:53,920
value

00:08:51,580 --> 00:08:55,960
and then the promise has given an

00:08:53,920 --> 00:08:58,990
opportunity to provide an initial

00:08:55,960 --> 00:09:02,200
suspend so the that allows the

00:08:58,990 --> 00:09:05,410
co-routine to suspend before executing

00:09:02,200 --> 00:09:06,880
any of the body in the case of lazy

00:09:05,410 --> 00:09:09,520
that's quite important because there

00:09:06,880 --> 00:09:11,620
that's what allows it to not go and do

00:09:09,520 --> 00:09:15,250
the expensive work in there in the body

00:09:11,620 --> 00:09:18,520
of the courage in until ask for so I'll

00:09:15,250 --> 00:09:20,890
explain what coal wait does shortly SoCo

00:09:18,520 --> 00:09:25,720
await is the second of the three new

00:09:20,890 --> 00:09:29,740
keywords so then the body of the

00:09:25,720 --> 00:09:36,460
original body of the carotene is it is

00:09:29,740 --> 00:09:38,830
executed Co return turns into a call to

00:09:36,460 --> 00:09:41,920
return value on the promise object so

00:09:38,830 --> 00:09:43,420
the promise object can decide what

00:09:41,920 --> 00:09:45,940
happens with that value that's being

00:09:43,420 --> 00:09:49,390
returned and then because we're

00:09:45,940 --> 00:09:51,250
returning from the carotene is a we skip

00:09:49,390 --> 00:09:52,690
over the rest of the body with that go

00:09:51,250 --> 00:09:56,530
to business there's no rest of the body

00:09:52,690 --> 00:09:59,050
in this case if an exception is thrown

00:09:56,530 --> 00:10:01,540
by the carotene body the the promise

00:09:59,050 --> 00:10:08,050
object gets a chance to handle that in

00:10:01,540 --> 00:10:10,510
its unhandled exception member and then

00:10:08,050 --> 00:10:12,160
at the end of the body is the final

00:10:10,510 --> 00:10:17,740
suspend point so the promise again gets

00:10:12,160 --> 00:10:19,660
a chance to to suspend the curry teen at

00:10:17,740 --> 00:10:22,810
the end of the body which is not useful

00:10:19,660 --> 00:10:24,610
for lazy but it can be useful for for

00:10:22,810 --> 00:10:28,030
other things and then after that is the

00:10:24,610 --> 00:10:34,600
point where where a destroy of the

00:10:28,030 --> 00:10:39,400
curtain will jump to so the carotene

00:10:34,600 --> 00:10:42,790
state is where the promise object copies

00:10:39,400 --> 00:10:45,220
of any parameters to the curry team any

00:10:42,790 --> 00:10:50,620
local variables that the Korean users

00:10:45,220 --> 00:10:53,890
and also any information that that is

00:10:50,620 --> 00:10:57,070
needed to identify where to resume the

00:10:53,890 --> 00:10:59,200
curry teen is stored so this is this is

00:10:57,070 --> 00:11:04,630
sun block of memory which is dynamically

00:10:59,200 --> 00:11:05,240
allocated in a number of cases and given

00:11:04,630 --> 00:11:07,820
a session

00:11:05,240 --> 00:11:10,910
they smart compiler that that allocation

00:11:07,820 --> 00:11:15,110
can be collided but in general there has

00:11:10,910 --> 00:11:17,420
to be a dynamic allocation and the the

00:11:15,110 --> 00:11:21,170
exact way that allocation happens is

00:11:17,420 --> 00:11:23,089
under under the control of of the

00:11:21,170 --> 00:11:26,390
promise object again rather promise type

00:11:23,089 --> 00:11:28,640
stop so that so the skirting stack gets

00:11:26,390 --> 00:11:31,940
created when the curtain is called and

00:11:28,640 --> 00:11:34,130
gets destroyed at the end when control

00:11:31,940 --> 00:11:35,330
flows off the end of the body so that

00:11:34,130 --> 00:11:38,209
can be either when the curtain is

00:11:35,330 --> 00:11:45,440
destroyed or when it when it finishes

00:11:38,209 --> 00:11:48,050
its final suspend so Khoa wait there

00:11:45,440 --> 00:11:52,310
again expands into more kind of

00:11:48,050 --> 00:11:56,870
pseudocode so on the left there and

00:11:52,310 --> 00:12:00,490
we've got a call to Kowal so X there is

00:11:56,870 --> 00:12:04,310
the thing that is being collated

00:12:00,490 --> 00:12:05,899
sometimes called unavoidable but I have

00:12:04,310 --> 00:12:07,279
used the word available to mean

00:12:05,899 --> 00:12:08,959
something subtly different in this talk

00:12:07,279 --> 00:12:12,320
so that this confusion over that

00:12:08,959 --> 00:12:15,860
terminology apologize for that so why is

00:12:12,320 --> 00:12:19,850
what Co await returns what's the result

00:12:15,860 --> 00:12:23,480
of the color weight expression so on the

00:12:19,850 --> 00:12:29,209
right there is what the compiler does

00:12:23,480 --> 00:12:31,370
for you so this this H is occurring in

00:12:29,209 --> 00:12:34,040
handle so I'll say more about co-routine

00:12:31,370 --> 00:12:37,220
and in soon but that's what that's what

00:12:34,040 --> 00:12:39,380
allows the promised end and and

00:12:37,220 --> 00:12:44,990
cooperating classes to control the Co

00:12:39,380 --> 00:12:47,630
routine so first off the promised object

00:12:44,990 --> 00:12:52,130
is given a chance to transform the

00:12:47,630 --> 00:12:54,050
awaited object so if there's an await

00:12:52,130 --> 00:12:58,060
transform member in the promised type

00:12:54,050 --> 00:12:59,839
then that gets past past X there that's

00:12:58,060 --> 00:13:02,000
optional so that doesn't have to be

00:12:59,839 --> 00:13:06,399
there if that's not there then a just

00:13:02,000 --> 00:13:09,980
becomes X so then there's this new

00:13:06,399 --> 00:13:13,730
operator called Cole wait so if there's

00:13:09,980 --> 00:13:16,070
a if there's a operator cold wait for

00:13:13,730 --> 00:13:17,900
whatever a is then that gets called and

00:13:16,070 --> 00:13:19,010
the result of that is used if there

00:13:17,900 --> 00:13:23,200
isn't one thin

00:13:19,010 --> 00:13:26,810
he just becomes a so then we've got E

00:13:23,200 --> 00:13:33,620
which is which is what I'm going to

00:13:26,810 --> 00:13:35,570
refer to as an available so that is

00:13:33,620 --> 00:13:38,990
another thing that allows you to

00:13:35,570 --> 00:13:43,400
customize the behavior of of Kowal

00:13:38,990 --> 00:13:44,480
weight so that has three members so the

00:13:43,400 --> 00:13:47,210
first is a weight really

00:13:44,480 --> 00:13:50,210
so that returns a ball and that if

00:13:47,210 --> 00:13:52,130
that's true then it means the curtain

00:13:50,210 --> 00:13:56,060
will not suspend and it will immediately

00:13:52,130 --> 00:13:58,730
carry on if it's false then the curtain

00:13:56,060 --> 00:14:01,340
is considered suspended and when the

00:13:58,730 --> 00:14:04,700
curtain is suspended that means it can

00:14:01,340 --> 00:14:08,840
be resumed or or destroyed so if it is

00:14:04,700 --> 00:14:10,820
if it is suspended then a weight suspend

00:14:08,840 --> 00:14:12,890
is called and that's passed the

00:14:10,820 --> 00:14:16,100
co-routine handle so that gets a chance

00:14:12,890 --> 00:14:17,690
to do something to the co-routine it

00:14:16,100 --> 00:14:19,760
might want to stash it handle away it

00:14:17,690 --> 00:14:23,210
might want to destroy the co-routine it

00:14:19,760 --> 00:14:26,030
could even resume the co-routine so

00:14:23,210 --> 00:14:29,330
after that if the curtain is still

00:14:26,030 --> 00:14:35,750
suspended then control goes back to the

00:14:29,330 --> 00:14:37,790
caller and then once the caller resumes

00:14:35,750 --> 00:14:41,000
the kuroh team control comes back here

00:14:37,790 --> 00:14:43,240
at that resume label and then the

00:14:41,000 --> 00:14:46,960
curtained is considered resumed

00:14:43,240 --> 00:14:50,270
so then after all that's happened

00:14:46,960 --> 00:14:52,960
the away table gets a chance to supply

00:14:50,270 --> 00:15:00,770
the results of the collate expression

00:14:52,960 --> 00:15:06,320
via a wait resume SoCo yield is the

00:15:00,770 --> 00:15:07,520
third of the new keywords and if you

00:15:06,320 --> 00:15:08,720
weren't looking carefully you might not

00:15:07,520 --> 00:15:11,870
have seen anything change on the screen

00:15:08,720 --> 00:15:16,990
there so it's pretty much exactly the

00:15:11,870 --> 00:15:20,600
same as coal wait two differences one is

00:15:16,990 --> 00:15:22,820
the first customization point that the

00:15:20,600 --> 00:15:28,100
promise gets crack at is called yield

00:15:22,820 --> 00:15:29,500
value instead of a wait transform the

00:15:28,100 --> 00:15:31,630
other

00:15:29,500 --> 00:15:33,850
is it sets in a slightly different point

00:15:31,630 --> 00:15:36,790
than the grammar so the precedence rules

00:15:33,850 --> 00:15:43,570
are different but otherwise it works

00:15:36,790 --> 00:15:44,830
exactly the same so while we're going

00:15:43,570 --> 00:15:47,650
through these transformations there's a

00:15:44,830 --> 00:15:49,900
there's an extra one extra bit of syntax

00:15:47,650 --> 00:15:51,460
called for coal weight which is just

00:15:49,900 --> 00:15:54,100
like a range for loop with a color

00:15:51,460 --> 00:15:57,340
weight stuck in it and that there gets

00:15:54,100 --> 00:16:00,730
transformed into the same thing as a

00:15:57,340 --> 00:16:03,250
range for loop but with Khoa weight

00:16:00,730 --> 00:16:06,220
stuck in it in a couple of places so in

00:16:03,250 --> 00:16:09,640
particular there's a cola weight on the

00:16:06,220 --> 00:16:12,700
result of begin on the range which means

00:16:09,640 --> 00:16:15,040
that can be could be an asynchronous

00:16:12,700 --> 00:16:19,060
operation or whatever the whatever the

00:16:15,040 --> 00:16:22,030
kuru teen actually is whatever color

00:16:19,060 --> 00:16:25,230
weight means in this context and the

00:16:22,030 --> 00:16:29,080
other places when we're iterating the

00:16:25,230 --> 00:16:30,790
incrementing the iterator so that other

00:16:29,080 --> 00:16:33,820
wise it works just like a just like a

00:16:30,790 --> 00:16:37,360
range for loop except the thing that's

00:16:33,820 --> 00:16:41,800
being ranged over is not it's not a not

00:16:37,360 --> 00:16:44,560
a range as per normal it's sort of a

00:16:41,800 --> 00:16:46,980
sort of a an away table range it's a

00:16:44,560 --> 00:16:50,710
different sort of concept where the

00:16:46,980 --> 00:16:52,300
begin on the range and the increment on

00:16:50,710 --> 00:16:55,690
the iterator has a slightly different

00:16:52,300 --> 00:16:59,080
type because it can be Co awaited well

00:16:55,690 --> 00:17:00,550
it must be cooperated so I'll show an

00:16:59,080 --> 00:17:01,630
example of why this might be useful

00:17:00,550 --> 00:17:06,280
later

00:17:01,630 --> 00:17:11,319
so carotene handle I mentioned so this

00:17:06,280 --> 00:17:16,720
is kind of like an on owning pointer to

00:17:11,319 --> 00:17:18,160
the curry teen state so it has its

00:17:16,720 --> 00:17:22,630
destructive doesn't do anything that's

00:17:18,160 --> 00:17:24,459
the important thing to remember and it

00:17:22,630 --> 00:17:28,329
has a default constructed state where it

00:17:24,459 --> 00:17:29,770
doesn't point at any carotene so there's

00:17:28,329 --> 00:17:31,690
an operator ball which tells you whether

00:17:29,770 --> 00:17:36,100
it is in the default constructed state

00:17:31,690 --> 00:17:38,560
whether it's not provides a way of

00:17:36,100 --> 00:17:42,190
getting at the promise object which is

00:17:38,560 --> 00:17:43,539
really useful you can also go from the

00:17:42,190 --> 00:17:46,899
promise object to

00:17:43,539 --> 00:17:48,789
a corresponding Korean handle so these

00:17:46,899 --> 00:17:52,749
things can be trivially marked ravioli

00:17:48,789 --> 00:17:54,389
but easily copied there they're really

00:17:52,749 --> 00:17:58,749
cheap they're just a pointer basically

00:17:54,389 --> 00:18:02,169
and the guts of the guts of what the

00:17:58,749 --> 00:18:05,049
curtain handlers is for as it allows you

00:18:02,169 --> 00:18:07,059
to resume or destroy the co-routine so

00:18:05,049 --> 00:18:10,749
if you're dealing with one of these you

00:18:07,059 --> 00:18:15,519
need to know whether the co-routine is

00:18:10,749 --> 00:18:17,950
currently suspended or not if it is not

00:18:15,519 --> 00:18:18,729
suspended then you must not call resume

00:18:17,950 --> 00:18:21,070
or destroy

00:18:18,729 --> 00:18:26,139
there's not really any assistance for

00:18:21,070 --> 00:18:28,809
you in that regard so yeah this is kind

00:18:26,139 --> 00:18:31,840
of for dealing with corroding handles

00:18:28,809 --> 00:18:34,059
writing the curtain abstractions as is

00:18:31,840 --> 00:18:41,789
kind of for for people who are thinking

00:18:34,059 --> 00:18:44,769
very carefully and it's fun to debug -

00:18:41,789 --> 00:18:48,239
okay so quick word about return values

00:18:44,769 --> 00:18:51,190
so Soaker routines transfer control back

00:18:48,239 --> 00:18:52,749
in more than one way so there's there's

00:18:51,190 --> 00:18:54,099
the first time they transfer control

00:18:52,749 --> 00:18:56,710
back to their caller and that's when

00:18:54,099 --> 00:19:01,869
they return the actual return value of

00:18:56,710 --> 00:19:06,210
the curry team the other the other way

00:19:01,869 --> 00:19:12,369
they transfer control back is is when

00:19:06,210 --> 00:19:15,549
when they suspend so when the curry teen

00:19:12,369 --> 00:19:19,059
suspends and it will transfer control

00:19:15,549 --> 00:19:23,559
back evil to the caller or although

00:19:19,059 --> 00:19:25,210
other azuma so there's just a minor

00:19:23,559 --> 00:19:27,129
difference in terminology cook the

00:19:25,210 --> 00:19:29,169
caller is what's expecting the actual

00:19:27,129 --> 00:19:30,820
return value of the curry teen a resume

00:19:29,169 --> 00:19:32,679
IRR is something that that doesn't get

00:19:30,820 --> 00:19:35,769
any return value back so the first time

00:19:32,679 --> 00:19:37,690
the care routine returns every auto

00:19:35,769 --> 00:19:39,399
spins it goes to its caller and it

00:19:37,690 --> 00:19:41,259
returns the value of subsequent times it

00:19:39,399 --> 00:19:46,659
goes to a resume and doesn't return a

00:19:41,259 --> 00:19:49,929
value okay so how do we actually

00:19:46,659 --> 00:19:52,470
implement this lazy lazy kind of Co

00:19:49,929 --> 00:19:52,470
routine thing

00:19:54,350 --> 00:20:00,150
so what we need to do is we need to

00:19:57,740 --> 00:20:03,090
implement a promise type which I'm

00:20:00,150 --> 00:20:05,930
calling lazy promise which are for were

00:20:03,090 --> 00:20:08,550
declared because the lazy class itself

00:20:05,930 --> 00:20:11,430
needs to refer to it and it needs to

00:20:08,550 --> 00:20:13,740
refer to the lazy class so first of all

00:20:11,430 --> 00:20:20,150
we're define the the lazy class template

00:20:13,740 --> 00:20:22,890
itself so start with its private stuff

00:20:20,150 --> 00:20:26,160
so the constructor is private because

00:20:22,890 --> 00:20:29,250
it's only it's only ever constructed by

00:20:26,160 --> 00:20:30,600
the promise by the promise object so

00:20:29,250 --> 00:20:33,360
that's why the that's why the promise

00:20:30,600 --> 00:20:36,870
type has made a friend there's other

00:20:33,360 --> 00:20:39,690
ways of handling that but for exposition

00:20:36,870 --> 00:20:41,940
of them up that way so when it's

00:20:39,690 --> 00:20:44,429
constructed it gets passed a product it

00:20:41,940 --> 00:20:46,350
gets passed a reference to the promise

00:20:44,429 --> 00:20:48,110
object and it just converted into a

00:20:46,350 --> 00:20:52,730
clarity and handle and stores that away

00:20:48,110 --> 00:20:56,610
it also has an optional storing the

00:20:52,730 --> 00:20:59,790
value that's that's been computed starts

00:20:56,610 --> 00:21:04,800
out empty to indicate that we haven't

00:20:59,790 --> 00:21:10,260
computed the value again so then the

00:21:04,800 --> 00:21:15,000
public interface of of lazy is basically

00:21:10,260 --> 00:21:16,470
just as get member so what we do in

00:21:15,000 --> 00:21:17,070
there as we say if we haven't got the

00:21:16,470 --> 00:21:18,540
value yet

00:21:17,070 --> 00:21:21,000
we'll go and calculate the value and

00:21:18,540 --> 00:21:25,140
then we'll return the value so in order

00:21:21,000 --> 00:21:28,260
to calculate the value we we resume the

00:21:25,140 --> 00:21:32,130
co-routine so there's a little bit of an

00:21:28,260 --> 00:21:36,660
awkward interaction which seems to often

00:21:32,130 --> 00:21:39,210
come up with the stuff where we need to

00:21:36,660 --> 00:21:41,010
tell the promise where it should store

00:21:39,210 --> 00:21:44,840
the value once it's been calculated

00:21:41,010 --> 00:21:47,700
because resume doesn't return anything

00:21:44,840 --> 00:21:49,620
so the there we're passing off the

00:21:47,700 --> 00:21:51,960
address of the optional that we're

00:21:49,620 --> 00:21:56,429
storing the storing the value in after

00:21:51,960 --> 00:22:01,710
the promise and then we resume the car

00:21:56,429 --> 00:22:05,030
routine so that resume will return once

00:22:01,710 --> 00:22:09,669
the car routine has finished executing

00:22:05,030 --> 00:22:11,840
then we null out our co-routine handle

00:22:09,669 --> 00:22:15,110
which is important if you look at the

00:22:11,840 --> 00:22:19,669
destructor there so in the destructor of

00:22:15,110 --> 00:22:20,990
lazy if we still have a corrosion handle

00:22:19,669 --> 00:22:23,030
of the Kuragin handle still points at a

00:22:20,990 --> 00:22:25,190
KO routine which means that nobody ever

00:22:23,030 --> 00:22:27,410
called get then we can destroy the

00:22:25,190 --> 00:22:31,309
carotene and skip over the expensive

00:22:27,410 --> 00:22:33,650
calculation so the lazy promise on the

00:22:31,309 --> 00:22:38,900
right there you can see it has a pointer

00:22:33,650 --> 00:22:42,020
to to an optional which gets set when

00:22:38,900 --> 00:22:45,799
the lazy is ready to resume to receive

00:22:42,020 --> 00:22:48,950
the value that's calculated so get

00:22:45,799 --> 00:22:51,830
returned object returns returns one of

00:22:48,950 --> 00:22:54,590
these lazy objects passing a passing a

00:22:51,830 --> 00:22:57,440
reference to the promised initial

00:22:54,590 --> 00:22:59,390
suspend uses the special type which is

00:22:57,440 --> 00:23:01,940
in which is but part of the co-wrote

00:22:59,390 --> 00:23:05,480
entity is called suspend always so

00:23:01,940 --> 00:23:09,350
that's that's a that's an avoidable type

00:23:05,480 --> 00:23:11,120
that always returns false from await

00:23:09,350 --> 00:23:16,100
ready so that says we're going to

00:23:11,120 --> 00:23:17,690
suspend at the unit or suspend point so

00:23:16,100 --> 00:23:20,410
return value so that's when the KO

00:23:17,690 --> 00:23:23,570
routine calls ko return and then we

00:23:20,410 --> 00:23:28,790
populate the optional with with the

00:23:23,570 --> 00:23:31,280
value that was returned unhandled

00:23:28,790 --> 00:23:33,860
exception we swallow and do nothing

00:23:31,280 --> 00:23:42,559
because I didn't write that part so that

00:23:33,860 --> 00:23:44,059
there's also yeah there's yeah you

00:23:42,559 --> 00:23:48,590
should probably do something with the

00:23:44,059 --> 00:23:50,750
exception in that case so final suspend

00:23:48,590 --> 00:23:54,200
we use suspend never which is another

00:23:50,750 --> 00:23:55,700
provided avoidable type which just

00:23:54,200 --> 00:23:57,410
returns true from normal weight really

00:23:55,700 --> 00:23:58,970
so we don't suspend at the final suspend

00:23:57,410 --> 00:24:02,120
point which means that the curry teen

00:23:58,970 --> 00:24:03,950
will be will fall off the end and be

00:24:02,120 --> 00:24:06,440
cleaned up after it's after it's

00:24:03,950 --> 00:24:10,400
returned and then the final part of the

00:24:06,440 --> 00:24:15,320
puzzle is to specialize co-routine

00:24:10,400 --> 00:24:17,299
traits for co-routines that return any

00:24:15,320 --> 00:24:18,860
kind of lazy and take any arguments and

00:24:17,299 --> 00:24:23,650
we just

00:24:18,860 --> 00:24:26,660
say the promise typers our lazy promise

00:24:23,650 --> 00:24:31,700
okay so now I'm gonna say a few things

00:24:26,660 --> 00:24:35,750
about the usual suspects for Kura jeans

00:24:31,700 --> 00:24:37,090
so lazy sequences and async stuff I'm

00:24:35,750 --> 00:24:40,880
not going to say a lot about these

00:24:37,090 --> 00:24:42,799
there's I think this is probably better

00:24:40,880 --> 00:24:48,200
talks about that stuff at this very

00:24:42,799 --> 00:24:51,799
conference so lazy sequences or

00:24:48,200 --> 00:24:54,230
generators the the curry team is on

00:24:51,799 --> 00:24:57,200
right here so we've got something that

00:24:54,230 --> 00:25:00,650
returns a a generator event which which

00:24:57,200 --> 00:25:05,630
just gives you a more or less infinite

00:25:00,650 --> 00:25:07,549
list of prime numbers and the caller's

00:25:05,630 --> 00:25:11,990
on the left there it just looks like a

00:25:07,549 --> 00:25:14,720
normal loop and it is a normal loop the

00:25:11,990 --> 00:25:16,429
the nice thing there is that the the

00:25:14,720 --> 00:25:18,380
curry routine doesn't need to care about

00:25:16,429 --> 00:25:20,720
the termination condition that's taken

00:25:18,380 --> 00:25:23,630
care of in the caller so the caller just

00:25:20,720 --> 00:25:27,020
stops calling it when it when it's had

00:25:23,630 --> 00:25:28,850
enough and and the carotene won't won't

00:25:27,020 --> 00:25:35,710
deliver anymore values if it's not asked

00:25:28,850 --> 00:25:38,390
for them so async stuff this is probably

00:25:35,710 --> 00:25:41,210
you know that one of the big two killer

00:25:38,390 --> 00:25:44,630
features for curry teens which I'm not

00:25:41,210 --> 00:25:51,049
saying much about in the store so let's

00:25:44,630 --> 00:25:52,490
say we wanted to have some sort of I

00:25:51,049 --> 00:25:54,470
don't know web service or something that

00:25:52,490 --> 00:25:56,419
that tells us where there are numbers

00:25:54,470 --> 00:25:58,820
prime and we want that to be

00:25:56,419 --> 00:26:01,790
asynchronous because it could take a

00:25:58,820 --> 00:26:04,400
while so on the right there we've got a

00:26:01,790 --> 00:26:07,630
KO routine that does a couple of

00:26:04,400 --> 00:26:13,400
asynchronous operations uses coal weight

00:26:07,630 --> 00:26:15,410
to suspend if the value is not available

00:26:13,400 --> 00:26:18,320
immediately so that this this return

00:26:15,410 --> 00:26:20,840
type task here is not completely

00:26:18,320 --> 00:26:22,309
invented out of whole cloth but it's not

00:26:20,840 --> 00:26:26,780
it's not part of the current into years

00:26:22,309 --> 00:26:30,250
it's something that you need to you need

00:26:26,780 --> 00:26:30,250
to provide or find in a library

00:26:31,240 --> 00:26:37,040
so then the caller gets this task object

00:26:35,570 --> 00:26:38,960
back and then in order to get the value

00:26:37,040 --> 00:26:42,800
out of it it needs to use color weight

00:26:38,960 --> 00:26:44,900
so the caller needs to be a corroding in

00:26:42,800 --> 00:26:48,230
this particular case you you could have

00:26:44,900 --> 00:26:49,730
a you could have a return value that

00:26:48,230 --> 00:26:53,900
doesn't require the caller to be a co

00:26:49,730 --> 00:26:57,740
routine but things things kind of line

00:26:53,900 --> 00:26:59,240
up more nicely if if they are so so the

00:26:57,740 --> 00:27:01,580
nice thing about the nice thing about

00:26:59,240 --> 00:27:05,390
this is you can write your code you can

00:27:01,580 --> 00:27:08,240
write normal loops and if some things as

00:27:05,390 --> 00:27:10,250
though everything with synchronous just

00:27:08,240 --> 00:27:12,410
sprinkle a color wait here in there but

00:27:10,250 --> 00:27:14,600
it's actually asynchronous and will

00:27:12,410 --> 00:27:20,960
suspend the operation until the results

00:27:14,600 --> 00:27:27,290
really so you can combine the two and

00:27:20,960 --> 00:27:28,520
have an async generator so that's

00:27:27,290 --> 00:27:31,460
something that works just like a

00:27:28,520 --> 00:27:33,800
generator but instead of using a range

00:27:31,460 --> 00:27:40,610
for loop over it you can use a range for

00:27:33,800 --> 00:27:45,560
color weight loop so if you want to use

00:27:40,610 --> 00:27:47,600
this stuff now you can so as far as I

00:27:45,560 --> 00:27:50,840
know there are two two working

00:27:47,600 --> 00:27:53,870
implementations of the of the TS Visual

00:27:50,840 --> 00:27:57,290
Studio has head and implementation since

00:27:53,870 --> 00:27:59,500
2015 I think 2017 is recommended you

00:27:57,290 --> 00:28:06,320
just need the Statue white flag and

00:27:59,500 --> 00:28:10,310
clang 5.0 with with a Lib C plus bus it

00:28:06,320 --> 00:28:16,130
has an implementation which is pretty

00:28:10,310 --> 00:28:18,200
cool so that just gives you the raw TS

00:28:16,130 --> 00:28:21,230
which gives you curtain handle

00:28:18,200 --> 00:28:23,150
encouraging traits and a couple of other

00:28:21,230 --> 00:28:24,860
things it doesn't really let you build

00:28:23,150 --> 00:28:26,540
well lets you build everything but it

00:28:24,860 --> 00:28:28,190
doesn't give you any any high-level

00:28:26,540 --> 00:28:31,940
abstractions so there's a few libraries

00:28:28,190 --> 00:28:34,040
that I know of that provide some of

00:28:31,940 --> 00:28:39,130
these abstractions so one called cpp

00:28:34,040 --> 00:28:41,060
quorum or Corona so that provides task

00:28:39,130 --> 00:28:43,970
generator async generator

00:28:41,060 --> 00:28:44,330
some async music stuff some other some

00:28:43,970 --> 00:28:47,330
other

00:28:44,330 --> 00:28:51,590
really cool stuff for dealing with

00:28:47,330 --> 00:28:56,360
dealing with async things highly

00:28:51,590 --> 00:28:59,090
recommend their the range v3 library has

00:28:56,360 --> 00:29:03,290
a generator implementation which works

00:28:59,090 --> 00:29:07,910
nicely with with with the range v3

00:29:03,290 --> 00:29:10,910
library I am certain there are others so

00:29:07,910 --> 00:29:12,800
if you are working on any or know of any

00:29:10,910 --> 00:29:15,500
that are awesome please let me know I'm

00:29:12,800 --> 00:29:19,220
always interested to find it find it out

00:29:15,500 --> 00:29:22,730
about this stuff so it's gonna say a

00:29:19,220 --> 00:29:24,170
couple of things about slightly

00:29:22,730 --> 00:29:27,260
unconventional things you can do with

00:29:24,170 --> 00:29:31,040
curtains so this is this is my personal

00:29:27,260 --> 00:29:35,770
interest in the my sub interest in the

00:29:31,040 --> 00:29:40,120
in the curry chain space so let's

00:29:35,770 --> 00:29:44,300
consider an example where we have some

00:29:40,120 --> 00:29:48,590
some some functions that return optional

00:29:44,300 --> 00:29:52,310
values so say say we're wanting to pass

00:29:48,590 --> 00:29:53,870
some values out of a out of a stream so

00:29:52,310 --> 00:29:56,150
we can read a word and it'll either

00:29:53,870 --> 00:29:59,090
return a string which is the word or any

00:29:56,150 --> 00:30:02,870
empty optional which would be the case

00:29:59,090 --> 00:30:04,670
if there isn't a word in the stream so

00:30:02,870 --> 00:30:06,470
similarly we can pass an int it either

00:30:04,670 --> 00:30:09,320
gives you an int if there is one or if

00:30:06,470 --> 00:30:12,500
there isn't doesn't and pass double and

00:30:09,320 --> 00:30:15,680
then the interesting thing which we're

00:30:12,500 --> 00:30:18,410
going to implement is a combination of

00:30:15,680 --> 00:30:22,160
paws and and pass double called paws

00:30:18,410 --> 00:30:24,170
vector so we're going to pass the count

00:30:22,160 --> 00:30:28,730
first which is an int and then that many

00:30:24,170 --> 00:30:32,810
doubles and it either gives you a victor

00:30:28,730 --> 00:30:35,780
or if if the stream doesn't contain and

00:30:32,810 --> 00:30:39,910
into followed by that many doubles then

00:30:35,780 --> 00:30:48,010
then it will give you anybody optional

00:30:39,910 --> 00:30:52,670
so so this is kind of how I'd write that

00:30:48,010 --> 00:30:54,350
not not using anything fancy so so we

00:30:52,670 --> 00:30:56,780
call posit that gives us an optional

00:30:54,350 --> 00:30:58,100
back we need to check if it's empty and

00:30:56,780 --> 00:31:01,490
we can return empty

00:30:58,100 --> 00:31:04,070
if it's not that we can carry on use

00:31:01,490 --> 00:31:05,120
their number and then we just loop over

00:31:04,070 --> 00:31:07,790
that many times

00:31:05,120 --> 00:31:11,030
call pass double it gives us an optional

00:31:07,790 --> 00:31:13,640
you check if it's empty if it if it is

00:31:11,030 --> 00:31:17,840
emptied we return empty otherwise we

00:31:13,640 --> 00:31:20,840
carry on to the next one so it is

00:31:17,840 --> 00:31:27,550
possible to write this as a KO routine

00:31:20,840 --> 00:31:31,040
and remove a lot of the boilerplate code

00:31:27,550 --> 00:31:34,160
so you'll notice the ifs have gone and

00:31:31,040 --> 00:31:36,020
all the early returns have gone but this

00:31:34,160 --> 00:31:38,630
actually works the same way as the

00:31:36,020 --> 00:31:42,200
previous one so we've put we've put cola

00:31:38,630 --> 00:31:48,430
weight in the places where where we want

00:31:42,200 --> 00:31:52,250
to unwrap an optional and inside that

00:31:48,430 --> 00:31:55,280
that can cause the co routine to exit

00:31:52,250 --> 00:32:01,550
early and return an anybody optional or

00:31:55,280 --> 00:32:02,890
it can carry on so how can this be

00:32:01,550 --> 00:32:05,360
possible

00:32:02,890 --> 00:32:06,710
well strictly speaking it's kind of not

00:32:05,360 --> 00:32:11,650
if you're talking about standard

00:32:06,710 --> 00:32:15,890
optional is a my understanding is that

00:32:11,650 --> 00:32:17,030
it's not allowed to specialize a a class

00:32:15,890 --> 00:32:22,000
template from the standard namespace

00:32:17,030 --> 00:32:27,620
without any user-defined types in it but

00:32:22,000 --> 00:32:35,420
it works anyway so you can yeah you can

00:32:27,620 --> 00:32:37,220
yeah it works so so we're we're using a

00:32:35,420 --> 00:32:40,310
we're specifying a promise type here

00:32:37,220 --> 00:32:45,080
called optional promise so this optional

00:32:40,310 --> 00:32:47,600
promise in it's a weight transform it

00:32:45,080 --> 00:32:50,800
says that you're allowed to await well

00:32:47,600 --> 00:32:53,060
if you await on any kind of optional and

00:32:50,800 --> 00:32:56,660
then we're going to return the special

00:32:53,060 --> 00:32:59,840
optional away table type which is going

00:32:56,660 --> 00:33:05,180
to control suspension etc so the away

00:32:59,840 --> 00:33:07,040
table so in a weight really if the

00:33:05,180 --> 00:33:08,930
optional that was Co awaited on has a

00:33:07,040 --> 00:33:11,660
value of in a weight really returns true

00:33:08,930 --> 00:33:15,860
which means the curtain just carries on

00:33:11,660 --> 00:33:17,780
without suspending and then goes to a

00:33:15,860 --> 00:33:20,600
wait resume which is just takes the

00:33:17,780 --> 00:33:22,670
value out of the optional if the

00:33:20,600 --> 00:33:24,980
optional doesn't have a value then we go

00:33:22,670 --> 00:33:28,100
into a wait suspend we get given a

00:33:24,980 --> 00:33:32,570
handle to the curry team and then we

00:33:28,100 --> 00:33:35,210
just destroy the KO routine and well we

00:33:32,570 --> 00:33:37,630
will you tell the promise somehow that

00:33:35,210 --> 00:33:40,220
we're going to return anybody optional

00:33:37,630 --> 00:33:42,050
that that's a bit tricky I have a

00:33:40,220 --> 00:33:44,450
mentioned that here there's code on

00:33:42,050 --> 00:33:47,540
github if you want the gory details of

00:33:44,450 --> 00:33:48,920
how that works but we destroy the car

00:33:47,540 --> 00:33:54,070
routine which means that we don't

00:33:48,920 --> 00:33:58,270
execute the rest of it so what if

00:33:54,070 --> 00:33:58,270
optional is not quite enough information

00:33:58,420 --> 00:34:05,510
well luckily the exact same approach

00:34:02,750 --> 00:34:08,900
works if you've got something that's

00:34:05,510 --> 00:34:12,380
like optional so for example if you had

00:34:08,900 --> 00:34:14,210
a an expected class template which could

00:34:12,380 --> 00:34:18,500
either either be a value or some kind of

00:34:14,210 --> 00:34:20,810
error you could use that the the

00:34:18,500 --> 00:34:26,690
implementation of the karate and stuff

00:34:20,810 --> 00:34:29,270
for that is pretty much the same so if

00:34:26,690 --> 00:34:32,120
you want to play with play with optional

00:34:29,270 --> 00:34:33,710
coroutines there's you know I wouldn't

00:34:32,120 --> 00:34:35,500
say if you want to use it in production

00:34:33,710 --> 00:34:39,160
but if you want to play with it there's

00:34:35,500 --> 00:34:42,620
so there's some stuff on on my github

00:34:39,160 --> 00:34:47,270
which works with standard optional but

00:34:42,620 --> 00:34:49,669
only works on Clan unfortunately there's

00:34:47,270 --> 00:34:54,890
a basic expected implementation as well

00:34:49,669 --> 00:34:57,710
there just recently the fully optional

00:34:54,890 --> 00:35:00,410
type from Facebook has grown support for

00:34:57,710 --> 00:35:01,760
co-routines which so that's not standard

00:35:00,410 --> 00:35:04,550
option but it's still pretty good

00:35:01,760 --> 00:35:07,880
optional it's a good option you could

00:35:04,550 --> 00:35:12,620
say so and the magic there as that works

00:35:07,880 --> 00:35:17,270
on claying and enemies PC which is which

00:35:12,620 --> 00:35:18,560
is pretty clever so there's there's also

00:35:17,270 --> 00:35:21,830
a follow you expected which it doesn't

00:35:18,560 --> 00:35:24,440
yet have curtayne support so that would

00:35:21,830 --> 00:35:25,490
be there would be a quite a quite a good

00:35:24,440 --> 00:35:27,530
little project

00:35:25,490 --> 00:35:28,760
if someone wanted to say around with the

00:35:27,530 --> 00:35:33,349
stuff I'm sure they'd appreciate a pull

00:35:28,760 --> 00:35:37,070
request so the other potentially

00:35:33,349 --> 00:35:42,619
interesting idea so this is something

00:35:37,070 --> 00:35:46,280
that I stole from from from Gore is that

00:35:42,619 --> 00:35:49,940
you can you can get a kind of type

00:35:46,280 --> 00:35:54,020
erasure out of out of the corroding

00:35:49,940 --> 00:35:57,160
machinery so the the interesting thing

00:35:54,020 --> 00:36:00,619
well I don't know but the thing is that

00:35:57,160 --> 00:36:04,400
the body of ocurro teen can can have

00:36:00,619 --> 00:36:07,099
more type information than the actual

00:36:04,400 --> 00:36:09,349
than the return type of the kuru teen so

00:36:07,099 --> 00:36:14,390
this this is probably a bit hard to

00:36:09,349 --> 00:36:17,030
digest source code honestly but but what

00:36:14,390 --> 00:36:20,690
we've got we've got a we've got a a KO

00:36:17,030 --> 00:36:23,660
routine there this that create function

00:36:20,690 --> 00:36:25,369
there as a KO routine so it's a it's a

00:36:23,660 --> 00:36:26,900
it's a static member function which is

00:36:25,369 --> 00:36:31,700
cool coatings can be static or non

00:36:26,900 --> 00:36:35,780
static member functions so this this is

00:36:31,700 --> 00:36:39,770
a template also so that that template

00:36:35,780 --> 00:36:42,740
parameter F is more specific type of

00:36:39,770 --> 00:36:44,420
information than is apparent in the

00:36:42,740 --> 00:36:49,400
return value of their career team so

00:36:44,420 --> 00:36:51,230
that KO routine and to return type just

00:36:49,400 --> 00:36:53,810
encodes the the return type and the

00:36:51,230 --> 00:36:59,390
arguments of the function not the actual

00:36:53,810 --> 00:37:05,240
type of the function and when that curry

00:36:59,390 --> 00:37:07,910
teen yields the function the yield value

00:37:05,240 --> 00:37:09,770
member in the promise type on the right

00:37:07,910 --> 00:37:14,210
there gets called and that can be a

00:37:09,770 --> 00:37:19,010
template so that can recover the the

00:37:14,210 --> 00:37:20,359
exact type of the function so using this

00:37:19,010 --> 00:37:23,510
you can build something that's kind of

00:37:20,359 --> 00:37:26,680
like kind of like stead function but

00:37:23,510 --> 00:37:26,680
just works could that you differently

00:37:30,490 --> 00:37:36,650
so one of the nice things about that is

00:37:33,680 --> 00:37:39,200
that if if the compiler can see

00:37:36,650 --> 00:37:43,310
everything you're putting into this into

00:37:39,200 --> 00:37:48,170
this this this Co routine funk thing and

00:37:43,310 --> 00:37:50,420
it can see the caller then then it can

00:37:48,170 --> 00:37:53,290
potentially inline everything and get

00:37:50,420 --> 00:37:56,240
rid of all of the all of the allocations

00:37:53,290 --> 00:37:59,000
and make all of the co-routine machinery

00:37:56,240 --> 00:38:02,240
go away it's quite a quite a cool thing

00:37:59,000 --> 00:38:05,630
to see when I when I say is a compiler I

00:38:02,240 --> 00:38:08,080
mean Claire currently but hopefully

00:38:05,630 --> 00:38:10,280
other compilers in the future as well

00:38:08,080 --> 00:38:12,260
otherwise if the compiler can't see

00:38:10,280 --> 00:38:13,580
everything it's it has it's gonna have

00:38:12,260 --> 00:38:15,230
over here it's gonna have dynamic

00:38:13,580 --> 00:38:17,840
allocation it's going to have

00:38:15,230 --> 00:38:19,760
essentially essentially virtual dispatch

00:38:17,840 --> 00:38:22,730
in there so it's not going to be much

00:38:19,760 --> 00:38:26,630
different to just it function I think

00:38:22,730 --> 00:38:28,880
mostly this is interesting just as a

00:38:26,630 --> 00:38:32,600
sort of bit of a head-scratcher and a

00:38:28,880 --> 00:38:34,450
and a you know that's interesting what

00:38:32,600 --> 00:38:37,670
can we build what can we build with that

00:38:34,450 --> 00:38:39,290
so there's some this some code on my

00:38:37,670 --> 00:38:41,480
github to play with I wouldn't say it's

00:38:39,290 --> 00:38:49,640
useful as it is but it's um it's

00:38:41,480 --> 00:38:52,190
intriguing so in summary kuroh teens are

00:38:49,640 --> 00:38:54,620
a generalization of functions so that's

00:38:52,190 --> 00:38:58,250
that's a message that I think is

00:38:54,620 --> 00:39:00,410
important to to bear in mind co-routines

00:38:58,250 --> 00:39:04,730
are functions they're just functions

00:39:00,410 --> 00:39:07,490
that have extra capabilities so the

00:39:04,730 --> 00:39:11,050
usual suspects for Recruiting's that we

00:39:07,490 --> 00:39:14,750
talked about generators async things and

00:39:11,050 --> 00:39:18,500
async generators even and I think that's

00:39:14,750 --> 00:39:21,620
probably going to be the the vast

00:39:18,500 --> 00:39:24,500
majority of users of kuroh teens and I

00:39:21,620 --> 00:39:26,570
think there's a lot of other interesting

00:39:24,500 --> 00:39:28,520
applications with co-routines that we're

00:39:26,570 --> 00:39:32,320
only just starting to explore so there's

00:39:28,520 --> 00:39:34,910
the optional and expected case and I'm

00:39:32,320 --> 00:39:38,320
currently working on trying to extend

00:39:34,910 --> 00:39:40,670
that to two other magnetic operations

00:39:38,320 --> 00:39:42,420
there's the type erasure example which

00:39:40,670 --> 00:39:43,859
I'm sure has

00:39:42,420 --> 00:39:50,309
interesting applications and I really

00:39:43,859 --> 00:39:53,040
want to hear what they are so thank you

00:39:50,309 --> 00:40:13,559
very much your attention and I'll be

00:39:53,040 --> 00:40:16,950
able to take any questions yeah go ahead

00:40:13,559 --> 00:40:21,630
um hi as someone who programs in Haskell

00:40:16,950 --> 00:40:23,640
occasionally my spidey sense tingle

00:40:21,630 --> 00:40:26,880
it seems like co-routines are very

00:40:23,640 --> 00:40:29,970
similar or an extension of or a special

00:40:26,880 --> 00:40:32,670
case of monads I was wondering if you

00:40:29,970 --> 00:40:38,520
could talk about that at all yeah sure

00:40:32,670 --> 00:40:42,450
so yeah that's um that's that's along my

00:40:38,520 --> 00:40:44,609
line of thinking exactly the so so

00:40:42,450 --> 00:40:48,960
co-routines themselves don't have a lot

00:40:44,609 --> 00:40:50,790
to do with monads I think but you can

00:40:48,960 --> 00:40:53,940
build something similar to her skull to

00:40:50,790 --> 00:40:56,700
do notation which is what what I was

00:40:53,940 --> 00:41:02,700
thinking with the optional the optional

00:40:56,700 --> 00:41:05,910
example there so I don't think you can

00:41:02,700 --> 00:41:09,750
build the full general generality of of

00:41:05,910 --> 00:41:14,180
monads using kuru teens for example the

00:41:09,750 --> 00:41:16,680
non-determinism Oh Ned requires requires

00:41:14,180 --> 00:41:19,109
going back and executing parts of the

00:41:16,680 --> 00:41:21,180
kuru teen again and that's simply not

00:41:19,109 --> 00:41:24,930
possible with the curtains - yes you can

00:41:21,180 --> 00:41:29,869
only move forward and can't go back in

00:41:24,930 --> 00:41:33,650
time so unfortunately we can't build

00:41:29,869 --> 00:41:36,420
build everything that Haskell has but

00:41:33,650 --> 00:41:39,150
it's certainly possible to build a

00:41:36,420 --> 00:41:41,250
really useful subset and I'd love

00:41:39,150 --> 00:41:44,010
somebody to tell me what category

00:41:41,250 --> 00:41:47,339
theoretical subsets bettors well those

00:41:44,010 --> 00:41:49,349
are the mono in the category of endo

00:41:47,339 --> 00:41:50,040
functors did you know that I have no

00:41:49,349 --> 00:41:51,980
idea what that means

00:41:50,040 --> 00:41:54,070
yeah no I thought they were burritos but

00:41:51,980 --> 00:41:59,960
[Laughter]

00:41:54,070 --> 00:42:04,310
awesome thank you thank you oh oh

00:41:59,960 --> 00:42:04,850
alternate so you spoke about the type of

00:42:04,310 --> 00:42:07,580
rais'd

00:42:04,850 --> 00:42:11,090
callable so you said like in principle

00:42:07,580 --> 00:42:12,980
if the compiler can see you know this

00:42:11,090 --> 00:42:16,100
much of the code then it can optimize

00:42:12,980 --> 00:42:18,230
things away it seems to me that that's

00:42:16,100 --> 00:42:20,390
pretty similar to saying like if on line

00:42:18,230 --> 00:42:22,460
one you assign a lambda to a state

00:42:20,390 --> 00:42:25,100
function and then on line two you call

00:42:22,460 --> 00:42:27,650
it the compiler can optimize that out

00:42:25,100 --> 00:42:31,550
because it knows what that stud function

00:42:27,650 --> 00:42:37,580
holds so I guess I didn't really sort of

00:42:31,550 --> 00:42:41,960
get it like what is what our co-routines

00:42:37,580 --> 00:42:44,600
letting us do here that's unique I guess

00:42:41,960 --> 00:42:46,520
because it seems like the situation is

00:42:44,600 --> 00:42:48,950
still pretty much the same like if you

00:42:46,520 --> 00:42:51,890
type a race you might be able to get the

00:42:48,950 --> 00:42:53,420
optimization if the compiler can see

00:42:51,890 --> 00:42:55,730
enough code and sort of draw a line

00:42:53,420 --> 00:42:57,290
between them and if not then generally

00:42:55,730 --> 00:43:02,270
you won't so what's different with

00:42:57,290 --> 00:43:04,340
co-routines not a lot yeah yeah your

00:43:02,270 --> 00:43:05,720
observation is correct there's nothing

00:43:04,340 --> 00:43:09,670
stopping the compiler doing the same

00:43:05,720 --> 00:43:09,670
optimizations for a first aid function

00:43:11,320 --> 00:43:15,920
so I mean I'm not even claiming that

00:43:14,270 --> 00:43:19,090
there's really an advantage to the

00:43:15,920 --> 00:43:21,800
current version it's it's just it's just

00:43:19,090 --> 00:43:26,540
interesting that their capability exists

00:43:21,800 --> 00:43:29,330
within the co-routine system and mostly

00:43:26,540 --> 00:43:31,070
I want to sort of prod people into

00:43:29,330 --> 00:43:32,390
thinking about what cool stuff they can

00:43:31,070 --> 00:43:33,590
build with that because I'm sure there's

00:43:32,390 --> 00:43:36,619
something cool you can build there I

00:43:33,590 --> 00:43:38,150
haven't figured it out and yeah yeah

00:43:36,619 --> 00:43:44,660
that the function thing is just an

00:43:38,150 --> 00:43:46,119
example to show that it can work I don't

00:43:44,660 --> 00:43:48,920
have a better answer I'm sorry okay

00:43:46,119 --> 00:43:55,280
thanks so I think I think we probably

00:43:48,920 --> 00:43:57,890
need to wrap up now oh no well I can

00:43:55,280 --> 00:44:01,070
take a couple more questions come right

00:43:57,890 --> 00:44:03,650
so on the slide there's like two of n

00:44:01,070 --> 00:44:05,730
for implementing lazy if you made a

00:44:03,650 --> 00:44:07,780
comment about the

00:44:05,730 --> 00:44:10,660
called it like a friction of having the

00:44:07,780 --> 00:44:13,030
promise and the value having like both

00:44:10,660 --> 00:44:16,210
know where the result is gonna be and I

00:44:13,030 --> 00:44:18,580
noticed that you put the storage in the

00:44:16,210 --> 00:44:20,380
return value and pass a pointer the

00:44:18,580 --> 00:44:22,300
address of that into the promise sort of

00:44:20,380 --> 00:44:24,160
after the fact when I was playing with

00:44:22,300 --> 00:44:26,830
co-routines my intuition was to do it

00:44:24,160 --> 00:44:28,150
the opposite way and I was wondering if

00:44:26,830 --> 00:44:29,290
you could just elaborate why you did it

00:44:28,150 --> 00:44:30,910
that way if there's pros and cons

00:44:29,290 --> 00:44:32,410
because I actually put the storage for

00:44:30,910 --> 00:44:34,300
the return value in the promise and just

00:44:32,410 --> 00:44:40,920
gave the return value no it's where that

00:44:34,300 --> 00:44:43,750
was so in that particular case it so

00:44:40,920 --> 00:44:45,790
yeah in that particular case is because

00:44:43,750 --> 00:44:47,350
I wanted to be able to destroy the

00:44:45,790 --> 00:44:51,790
co-routine well I have to have the curry

00:44:47,350 --> 00:44:54,130
team cleaned up while the lazy object

00:44:51,790 --> 00:44:57,160
itself was still alive

00:44:54,130 --> 00:45:00,100
so if the curry teen runs off the end

00:44:57,160 --> 00:45:01,570
the promise gets destroyed so if the

00:45:00,100 --> 00:45:04,150
value is stored in promise it won't be

00:45:01,570 --> 00:45:05,860
available after the execution is

00:45:04,150 --> 00:45:07,870
finished no it's it's possible to

00:45:05,860 --> 00:45:10,210
implement it such that the curry teen

00:45:07,870 --> 00:45:12,460
suspends at the at the inn and then the

00:45:10,210 --> 00:45:14,740
promise is available still so that's a

00:45:12,460 --> 00:45:16,150
that's a completely valid if imitation

00:45:14,740 --> 00:45:17,350
great as well I think that's actually

00:45:16,150 --> 00:45:19,060
what I end up doing now that you

00:45:17,350 --> 00:45:21,100
described it and is there something that

00:45:19,060 --> 00:45:24,600
comes to mind as to what what the

00:45:21,100 --> 00:45:28,420
advantages or disadvantages would be

00:45:24,600 --> 00:45:33,640
well the only thing the only advantage I

00:45:28,420 --> 00:45:35,110
can think of of well I think in the Lazy

00:45:33,640 --> 00:45:37,630
case there's not much advantage to

00:45:35,110 --> 00:45:42,370
keeping the co-routine state around it's

00:45:37,630 --> 00:45:44,680
just kind of wasted wasted memory the in

00:45:42,370 --> 00:45:46,570
more complicated cases the promise has

00:45:44,680 --> 00:45:51,060
more responsibilities and and it would

00:45:46,570 --> 00:45:55,000
be it would be a different trade-off all

00:45:51,060 --> 00:45:56,500
right two concerns and like highly

00:45:55,000 --> 00:45:59,230
threaded environments using co-routines

00:45:56,500 --> 00:46:01,030
one the co-routine state there doesn't

00:45:59,230 --> 00:46:05,260
seem to be an alligator that can be

00:46:01,030 --> 00:46:08,350
passed into co-routines the so yeah

00:46:05,260 --> 00:46:12,600
there is there is a customization point

00:46:08,350 --> 00:46:12,600
for allocation the the there's a

00:46:13,340 --> 00:46:22,610
if there's a operator new in the promise

00:46:17,810 --> 00:46:27,220
type and it gets that gets used so in

00:46:22,610 --> 00:46:30,620
terms of passing an alligator in that is

00:46:27,220 --> 00:46:32,300
possible and the parameter the

00:46:30,620 --> 00:46:35,450
parameters to the coyote and get passed

00:46:32,300 --> 00:46:36,830
to the operator new so it's possible to

00:46:35,450 --> 00:46:38,470
extract the alligator it's a bit awkward

00:46:36,830 --> 00:46:42,020
but it's possible

00:46:38,470 --> 00:46:46,580
my concern is previously like on Windows

00:46:42,020 --> 00:46:48,680
using fibers for co-routine style coding

00:46:46,580 --> 00:46:51,050
I had a huge issue with red local

00:46:48,680 --> 00:46:53,480
storage with their context switching is

00:46:51,050 --> 00:46:57,850
that still an issue with this

00:46:53,480 --> 00:47:01,970
co-routines library so I'm not sure what

00:46:57,850 --> 00:47:04,100
what issue you a heavens nation there

00:47:01,970 --> 00:47:06,290
there's a old bug in Windows where we

00:47:04,100 --> 00:47:10,220
screw up the threads of whole storage

00:47:06,290 --> 00:47:11,840
using their fiber implementation they

00:47:10,220 --> 00:47:13,400
they fixed it with a compiler flag

00:47:11,840 --> 00:47:14,960
there's a lot of old libraries you could

00:47:13,400 --> 00:47:16,460
eventually pull in or if they didn't

00:47:14,960 --> 00:47:17,630
compile it with that special flag you'd

00:47:16,460 --> 00:47:21,770
still get screwed up thread-local

00:47:17,630 --> 00:47:24,320
storage ok I'm not I'm not familiar with

00:47:21,770 --> 00:47:26,180
the issue so I couldn't say if it if it

00:47:24,320 --> 00:47:27,170
is an issue with coaching's I mean

00:47:26,180 --> 00:47:29,720
something to be aware of with

00:47:27,170 --> 00:47:33,890
thread-local storage in a quarantine is

00:47:29,720 --> 00:47:36,680
that in some cases the curtain might

00:47:33,890 --> 00:47:38,450
change threads in the middle every rat

00:47:36,680 --> 00:47:40,580
suspends it could resume on a different

00:47:38,450 --> 00:47:42,620
thread so thread-local storage might not

00:47:40,580 --> 00:47:44,360
do what you expect I don't know if

00:47:42,620 --> 00:47:46,730
that's related to the issue you talking

00:47:44,360 --> 00:47:50,240
about or not has there any thoughts of

00:47:46,730 --> 00:47:56,540
like co-routine local storage in this

00:47:50,240 --> 00:47:57,740
proposal right now there any is anyone

00:47:56,540 --> 00:48:01,660
thinking about adding co-routine

00:47:57,740 --> 00:48:07,160
officers ah not that I'm aware of

00:48:01,660 --> 00:48:10,850
thank you all right ok thanks everyone

00:48:07,160 --> 00:48:12,820
feel free to grab me grab me around the

00:48:10,850 --> 00:48:14,630
conference and talk about the stuff

00:48:12,820 --> 00:48:18,110
thank you

00:48:14,630 --> 00:48:18,110

YouTube URL: https://www.youtube.com/watch?v=mlP1MKP8d_Q


