Title: CppCon 2017: Sergey Zubkov “From security to performance to GPU programming...”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	From security to performance to GPU programming: exploring modern allocators

http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Want to make fast linked lists? Want to store sensitive data in memory? Want to place std::unordered_map in thread-local memory? Shared memory? How about GPU memory? You can do that in today’s C++ with allocators, the secret components of every STL container. Allocators went through a quiet revolution in C++11 and a major expansion in C++17. What did that give us? We'll look at the allocators available today in C++17, boost, TBB, and other popular libraries, and demonstrate some of the amazing things that can be achieved by taking the step beyond the stack and the heap. 
This talk is not about allocator implementation, but is a showcase of the things that can be done with off-the-shelf allocators available now and with C++17.
— 
Sergey Zubkov: Morgan Stanley

Sergey is a former biochemistry researcher and OS developer, who now works in finance and spends his free time editing cppreference.com and helping out with the C++ Core Guidelines.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:07,620
hello my name is Sergei Zhukov and I'm

00:00:03,030 --> 00:00:10,559
an alligator yes and so are many other

00:00:07,620 --> 00:00:13,860
problems anyone who uses standard vector

00:00:10,559 --> 00:00:15,000
standard string any standard type that

00:00:13,860 --> 00:00:18,020
does what it does

00:00:15,000 --> 00:00:21,270
using alligators behind the scenes

00:00:18,020 --> 00:00:24,029
alligators can be well-earned faded

00:00:21,270 --> 00:00:25,410
being difficult to write I've had to do

00:00:24,029 --> 00:00:27,840
that a couple times myself and I'm not

00:00:25,410 --> 00:00:29,789
going to tell you that it was easy what

00:00:27,840 --> 00:00:34,950
I want to talk about is what that work

00:00:29,789 --> 00:00:38,640
achieves so first a brief refresher

00:00:34,950 --> 00:00:41,520
what do alligators do despite the name

00:00:38,640 --> 00:00:43,980
they do not just allocate an alligator

00:00:41,520 --> 00:00:47,010
is a customization point that controls

00:00:43,980 --> 00:00:49,070
five different policies it determines

00:00:47,010 --> 00:00:52,500
where an initialized memories are from

00:00:49,070 --> 00:00:55,020
how an initialized memory is disposed of

00:00:52,500 --> 00:00:56,940
our objects are created in that memory

00:00:55,020 --> 00:00:58,859
how obvious they removed from that

00:00:56,940 --> 00:01:02,129
memory and what it actually means to

00:00:58,859 --> 00:01:05,600
point an object in that memory Oh show a

00:01:02,129 --> 00:01:08,220
couple of examples of how that works and

00:01:05,600 --> 00:01:09,869
of course we now have two complimentary

00:01:08,220 --> 00:01:14,150
ways to use an alligator in suppose

00:01:09,869 --> 00:01:17,070
class we can provide an alligator as a

00:01:14,150 --> 00:01:24,630
simple parameter just like any other

00:01:17,070 --> 00:01:26,869
static policy and all we can use the

00:01:24,630 --> 00:01:29,250
cheapest pass on a team approach and

00:01:26,869 --> 00:01:31,380
provide alligator as a constructor

00:01:29,250 --> 00:01:37,140
argument to one of the containers from

00:01:31,380 --> 00:01:39,240
the PMR namespace in which case all the

00:01:37,140 --> 00:01:42,259
containers have the same type even

00:01:39,240 --> 00:01:42,259
though they're using different allergies

00:01:42,590 --> 00:01:48,930
there are benefits and drawbacks from

00:01:46,259 --> 00:01:52,680
either of those approaches and as always

00:01:48,930 --> 00:01:54,899
as an engineering decision how to use

00:01:52,680 --> 00:01:56,610
issuance and going through

00:01:54,899 --> 00:01:58,350
implementation details of that would

00:01:56,610 --> 00:02:02,790
take forever and we have plenty of talks

00:01:58,350 --> 00:02:04,590
at this very conference on doing just

00:02:02,790 --> 00:02:06,150
that in fact at all my eyes donors if

00:02:04,590 --> 00:02:08,470
they just ended

00:02:06,150 --> 00:02:12,370
and that hole was talking about the

00:02:08,470 --> 00:02:16,690
details of PMR so enough for the

00:02:12,370 --> 00:02:19,510
refresher for now let's talk about what

00:02:16,690 --> 00:02:21,280
we can do with alligators this is a

00:02:19,510 --> 00:02:23,489
short talk so all I'm going to do is

00:02:21,280 --> 00:02:27,720
look at a few of the alligators

00:02:23,489 --> 00:02:30,610
available in the wild in particular

00:02:27,720 --> 00:02:33,670
we'll try to cover each of the ways and

00:02:30,610 --> 00:02:36,780
luck eaters are used and show a few

00:02:33,670 --> 00:02:40,060
examples over all of these approaches

00:02:36,780 --> 00:02:42,069
the simplest alligator like an that have

00:02:40,060 --> 00:02:44,800
encountered that's not simply our

00:02:42,069 --> 00:02:46,750
instrumentation not simply an instrument

00:02:44,800 --> 00:02:48,760
an alligator used for testing or

00:02:46,750 --> 00:02:51,100
operation was the something called

00:02:48,760 --> 00:02:52,330
secure alligator very invented over

00:02:51,100 --> 00:02:56,680
another in different libraries so what

00:02:52,330 --> 00:03:00,900
it does is it attempts to make sure that

00:02:56,680 --> 00:03:03,250
passwords he's sensitive information

00:03:00,900 --> 00:03:07,150
does not end up in memory outside your

00:03:03,250 --> 00:03:09,549
control so on allocation it looks memory

00:03:07,150 --> 00:03:11,950
pages so that if your application is

00:03:09,549 --> 00:03:14,920
swap out the passwords are not in a swap

00:03:11,950 --> 00:03:17,110
file on the allocation he turned out

00:03:14,920 --> 00:03:20,500
somewhere and also wipes the data out of

00:03:17,110 --> 00:03:24,040
memory is an appropriate api's because

00:03:20,500 --> 00:03:28,299
as you should know memset is not enough

00:03:24,040 --> 00:03:30,640
in most cases now this may be debated

00:03:28,299 --> 00:03:32,440
whether this is a useful security

00:03:30,640 --> 00:03:34,209
measure but it is a pervasive pattern

00:03:32,440 --> 00:03:36,310
that appears over now so let's

00:03:34,209 --> 00:03:39,340
demonstrate how we you such an alligator

00:03:36,310 --> 00:03:43,180
so imagine you have a standard string

00:03:39,340 --> 00:03:45,310
that holds some sensitive data and it

00:03:43,180 --> 00:03:47,380
lives on some scope and a scope we talk

00:03:45,310 --> 00:03:48,880
to the user may be compared the pesos

00:03:47,380 --> 00:03:53,350
let's pretend it did not come from a

00:03:48,880 --> 00:03:55,870
static car see in this room so at the

00:03:53,350 --> 00:03:59,950
end of the scope this thing goes away

00:03:55,870 --> 00:04:02,530
the password is destroyed right or not

00:03:59,950 --> 00:04:03,640
exactly if we were able to get access to

00:04:02,530 --> 00:04:06,130
the heap and they looked at it they

00:04:03,640 --> 00:04:09,819
might find that exact password still on

00:04:06,130 --> 00:04:11,140
the hip in this case hopefully

00:04:09,819 --> 00:04:13,030
wiped out the first eight bytes but

00:04:11,140 --> 00:04:15,340
still we have most of that password

00:04:13,030 --> 00:04:17,670
right there so what do we do if you want

00:04:15,340 --> 00:04:20,970
to get rid of a proper

00:04:17,670 --> 00:04:24,280
we just changed our string to something

00:04:20,970 --> 00:04:28,390
in this particular case Bitcoin support

00:04:24,280 --> 00:04:31,090
library called secure stream nothing

00:04:28,390 --> 00:04:33,460
else need to do to code and the password

00:04:31,090 --> 00:04:36,520
is done from the hip so what does that

00:04:33,460 --> 00:04:39,010
secure stream it is a simply a basic

00:04:36,520 --> 00:04:44,680
string whose allocated type was replaced

00:04:39,010 --> 00:04:47,290
by secure locking this is a case of the

00:04:44,680 --> 00:04:50,590
most traditional use of elevator was a

00:04:47,290 --> 00:04:53,620
template parameter has no special state

00:04:50,590 --> 00:04:57,120
has no special rules just as simple as

00:04:53,620 --> 00:04:59,140
it gets and I'm not going to go into

00:04:57,120 --> 00:05:00,400
implementation details of an invisible

00:04:59,140 --> 00:05:02,730
Achilles because I'm looking at this

00:05:00,400 --> 00:05:05,470
from the point of view of the user right

00:05:02,730 --> 00:05:07,000
how do we use our key design code if you

00:05:05,470 --> 00:05:08,800
want to talk about implementation there

00:05:07,000 --> 00:05:13,990
are plenty of talks at this very

00:05:08,800 --> 00:05:16,420
conference this by the way I think is an

00:05:13,990 --> 00:05:17,980
example of where the fact that I like it

00:05:16,420 --> 00:05:19,810
in fact that type of a container is

00:05:17,980 --> 00:05:22,390
useful because type system is going to

00:05:19,810 --> 00:05:25,780
prevent or make it harder for us to move

00:05:22,390 --> 00:05:29,610
secure data from secured into insecure

00:05:25,780 --> 00:05:32,370
one now for something that I actually

00:05:29,610 --> 00:05:37,200
had to do at one point

00:05:32,370 --> 00:05:40,510
imagine you have a system which has a

00:05:37,200 --> 00:05:42,190
bunch of producers consumers aggregators

00:05:40,510 --> 00:05:47,410
all sort of actors with a process in

00:05:42,190 --> 00:05:52,450
advance and we need to have a long

00:05:47,410 --> 00:05:54,070
uptime on a hub limited memory system in

00:05:52,450 --> 00:05:56,200
my case the uptime requirement was one

00:05:54,070 --> 00:05:58,120
year was a lot longer good to you and

00:05:56,200 --> 00:06:01,840
had a burst rate of maybe a million

00:05:58,120 --> 00:06:03,520
events per second and we had dynamically

00:06:01,840 --> 00:06:06,210
reconfigurable system because once again

00:06:03,520 --> 00:06:08,500
you cannot reboot right so we had

00:06:06,210 --> 00:06:10,450
containers that had queues holyshit

00:06:08,500 --> 00:06:13,170
pointers to events in this case I'm

00:06:10,450 --> 00:06:15,640
gonna build a little demo which shows

00:06:13,170 --> 00:06:19,120
how it could have possibly work so had

00:06:15,640 --> 00:06:21,160
imagined I have a vector of data event

00:06:19,120 --> 00:06:22,600
and I my producers created pointers to

00:06:21,160 --> 00:06:25,000
those put them on a queue which is

00:06:22,600 --> 00:06:26,919
simply list of SharePoint aside and

00:06:25,000 --> 00:06:29,510
consumer presumably takes it off the

00:06:26,919 --> 00:06:34,970
queue maybe modifies and

00:06:29,510 --> 00:06:37,870
dr. so can anyone a civil to the problem

00:06:34,970 --> 00:06:40,310
if you're underscoring here right

00:06:37,870 --> 00:06:45,070
the problem is memory fragmentation I

00:06:40,310 --> 00:06:49,220
ran a little demo last week and just

00:06:45,070 --> 00:06:51,170
with $50,000 I ended up with the system

00:06:49,220 --> 00:06:54,320
break of mongooses gigabytes at the end

00:06:51,170 --> 00:06:57,380
of run double the events double the

00:06:54,320 --> 00:06:59,950
system break those numbers come from

00:06:57,380 --> 00:07:03,860
mounting for system calls this was just

00:06:59,950 --> 00:07:06,230
unmodified usual playing Linux it of

00:07:03,860 --> 00:07:08,720
course we could fix that but by maybe

00:07:06,230 --> 00:07:12,350
using different Malik but the

00:07:08,720 --> 00:07:13,910
traditional and successful approach the

00:07:12,350 --> 00:07:17,150
general memory fragmentation has always

00:07:13,910 --> 00:07:21,950
been to use pool of Iquitos which are

00:07:17,150 --> 00:07:23,810
now thankfully part of standard C++ so

00:07:21,950 --> 00:07:28,820
how do you poor kid how to plug a pool

00:07:23,810 --> 00:07:32,300
alligator into your program in C++ we

00:07:28,820 --> 00:07:34,010
need to create a pool object which has

00:07:32,300 --> 00:07:36,590
to have a scope larger than the scope of

00:07:34,010 --> 00:07:40,070
all containers see pass class now has a

00:07:36,590 --> 00:07:40,880
whole set of different pool types I'm

00:07:40,070 --> 00:07:43,180
gonna pick this one

00:07:40,880 --> 00:07:46,190
some obsession for multiple threads I

00:07:43,180 --> 00:07:51,020
have to replace my STD that reverse the

00:07:46,190 --> 00:07:53,060
GPM our vector and provide a constructor

00:07:51,020 --> 00:07:55,970
argument which tells you which pool to

00:07:53,060 --> 00:07:57,620
use this is an example of a stateful

00:07:55,970 --> 00:07:58,580
alligator alligator that takes the

00:07:57,620 --> 00:08:02,270
constructor argument

00:07:58,580 --> 00:08:04,130
and so every standard continue has

00:08:02,270 --> 00:08:07,430
constructors that take alligator

00:08:04,130 --> 00:08:09,800
arguments if you have a constructor for

00:08:07,430 --> 00:08:11,960
that exercise that is it a strategy size

00:08:09,800 --> 00:08:14,330
and anarchie if you have a constructor

00:08:11,960 --> 00:08:16,130
for the actor takes a pair of iterators

00:08:14,330 --> 00:08:19,490
you have another one takes pair of

00:08:16,130 --> 00:08:24,980
iterators an alligator and this applies

00:08:19,490 --> 00:08:28,340
to both PMR alligators and the old other

00:08:24,980 --> 00:08:29,720
kids at a part of the time so all the

00:08:28,340 --> 00:08:32,150
how to do is provided as a setter

00:08:29,720 --> 00:08:34,370
element picked a right container type

00:08:32,150 --> 00:08:36,290
and does it except for make sure that

00:08:34,370 --> 00:08:37,460
had to spell out what goes on behind the

00:08:36,290 --> 00:08:39,409
scenes a little

00:08:37,460 --> 00:08:41,330
but if you are working the standard

00:08:39,409 --> 00:08:43,669
containers that's very easy to plug in a

00:08:41,330 --> 00:08:46,010
pool or like it or not but I had to do

00:08:43,669 --> 00:08:50,710
it I had to write my own but as I said

00:08:46,010 --> 00:08:55,100
that's not what you want to talk about

00:08:50,710 --> 00:08:58,910
so now my system break doesn't grow when

00:08:55,100 --> 00:09:02,839
number illusions grows and it stays in a

00:08:58,910 --> 00:09:05,529
much reasonable size the effects over

00:09:02,839 --> 00:09:08,209
using hoola locators there's a

00:09:05,529 --> 00:09:11,149
multi-dimensional there are many

00:09:08,209 --> 00:09:13,430
different measures by which you can see

00:09:11,149 --> 00:09:15,860
the effects on performance and if you

00:09:13,430 --> 00:09:17,870
want to learn all about that visit

00:09:15,860 --> 00:09:22,100
tomorrow's talk but John Lakers called

00:09:17,870 --> 00:09:23,990
local arena memory alligators this is

00:09:22,100 --> 00:09:25,880
here's number so much more reliable than

00:09:23,990 --> 00:09:28,240
my one off the magnet I just ran

00:09:25,880 --> 00:09:31,310
[Applause]

00:09:28,240 --> 00:09:32,930
speaking of those definitions of

00:09:31,310 --> 00:09:36,050
performance though one finish with the

00:09:32,930 --> 00:09:38,060
obvious is that we have single

00:09:36,050 --> 00:09:40,160
synchronized memory pool access for

00:09:38,060 --> 00:09:42,470
multiple threads so obviously I should

00:09:40,160 --> 00:09:45,100
be contention and this will not scale if

00:09:42,470 --> 00:09:49,100
I increase the number of friends

00:09:45,100 --> 00:09:51,110
solution to that is another popular pool

00:09:49,100 --> 00:09:55,850
of Akira provided by intelligent

00:09:51,110 --> 00:09:57,380
building blocks this alligator is a size

00:09:55,850 --> 00:09:59,480
aggregate pool akhator meaning each

00:09:57,380 --> 00:10:02,630
allocation size goes on some pool and

00:09:59,480 --> 00:10:04,880
it's also that specific so each parent

00:10:02,630 --> 00:10:06,770
has its own set of balls and there's

00:10:04,880 --> 00:10:08,300
really no contention many people use

00:10:06,770 --> 00:10:11,630
this without knowing it exists because

00:10:08,300 --> 00:10:12,890
all TBB containers use one of their own

00:10:11,630 --> 00:10:16,580
alligators by the fourth element

00:10:12,890 --> 00:10:18,529
standard orifice but you can also plug

00:10:16,580 --> 00:10:20,930
it into your own containers very easily

00:10:18,529 --> 00:10:24,850
again doesn't take any special arguments

00:10:20,930 --> 00:10:24,850
it goes into your template argument list

00:10:25,150 --> 00:10:30,140
just as a straightforward replacement

00:10:27,680 --> 00:10:32,930
for STD alligator so in my case if I go

00:10:30,140 --> 00:10:34,910
and replace my vector into another int

00:10:32,930 --> 00:10:37,970
comma scalable Archaea

00:10:34,910 --> 00:10:41,560
and I replace my list and I replace my

00:10:37,970 --> 00:10:41,560
make sure that with our cage shell

00:10:41,640 --> 00:10:47,589
then even though this demo wasn't really

00:10:45,970 --> 00:10:50,050
built to the mastercards it was a bill

00:10:47,589 --> 00:10:51,970
to demonstrate fragmentation is still

00:10:50,050 --> 00:10:55,750
concurrency effects are quite visible

00:10:51,970 --> 00:10:57,730
here with TVB allocator I don't see any

00:10:55,750 --> 00:11:00,750
change in the time it takes to transmit

00:10:57,730 --> 00:11:02,680
this large number of events whereas the

00:11:00,750 --> 00:11:05,020
synchronized pull allocate includes

00:11:02,680 --> 00:11:07,350
encounters increasing contention notice

00:11:05,020 --> 00:11:10,029
the vertical scale here is logarithmic

00:11:07,350 --> 00:11:15,700
number of seconds so they took it took

00:11:10,029 --> 00:11:17,529
to run so those were a couple of pull

00:11:15,700 --> 00:11:19,120
Akitas you can use today just now just

00:11:17,529 --> 00:11:22,240
right right away

00:11:19,120 --> 00:11:23,620
except C++ 17 kilometers I don't think

00:11:22,240 --> 00:11:26,320
they're being implemented here playing

00:11:23,620 --> 00:11:28,450
in the vendors so I had to actually use

00:11:26,320 --> 00:11:29,110
the boost implementation of that and

00:11:28,450 --> 00:11:30,820
cheat a little

00:11:29,110 --> 00:11:34,959
but hopefully that will be available as

00:11:30,820 --> 00:11:37,029
soon as we have full C++ 17 support so

00:11:34,959 --> 00:11:43,089
now for something a bit more fancy

00:11:37,029 --> 00:11:46,980
literally imagine you have to profess a

00:11:43,089 --> 00:11:50,800
lot of data as fast as possible using

00:11:46,980 --> 00:11:53,529
thread unsafe code that's not hard to do

00:11:50,800 --> 00:11:55,570
once and the solution that came to was

00:11:53,529 --> 00:11:58,060
to use shared memory put all our data in

00:11:55,570 --> 00:11:59,890
a large shared memory container create

00:11:58,060 --> 00:12:03,810
multiple processes issue which was

00:11:59,890 --> 00:12:07,029
manipulating elements in a container

00:12:03,810 --> 00:12:09,160
concurrently with other processes so

00:12:07,029 --> 00:12:11,890
that each process you have only one copy

00:12:09,160 --> 00:12:14,440
of that thread unsafe library and the

00:12:11,890 --> 00:12:16,480
contents of the shared memory had to be

00:12:14,440 --> 00:12:19,120
a fairly complicated data structure

00:12:16,480 --> 00:12:22,870
which in our case was a map holding

00:12:19,120 --> 00:12:27,670
streams vectors list solid maps so they

00:12:22,870 --> 00:12:30,279
really non-trivial simples class

00:12:27,670 --> 00:12:32,230
contained so but for the sake of the

00:12:30,279 --> 00:12:33,579
demo let's talk about vector what

00:12:32,230 --> 00:12:35,680
happens if you put the reactor in shared

00:12:33,579 --> 00:12:37,810
memory in this case I'm going to use a

00:12:35,680 --> 00:12:39,790
boost API which is pretty

00:12:37,810 --> 00:12:41,740
straightforward you have you got a shell

00:12:39,790 --> 00:12:43,390
on this segment you can call that

00:12:41,740 --> 00:12:45,250
constructor method takes the type to

00:12:43,390 --> 00:12:48,040
construct and the constructor arguments

00:12:45,250 --> 00:12:51,010
to forward and it just places that

00:12:48,040 --> 00:12:53,769
object in the feminine from go ahead and

00:12:51,010 --> 00:12:55,779
do that and I another process attached

00:12:53,769 --> 00:12:59,019
the same segment pull out the same

00:12:55,779 --> 00:13:01,179
object I'm gonna get in a sec hold when

00:12:59,019 --> 00:13:06,100
I try to access its elements so why does

00:13:01,179 --> 00:13:08,290
that have so let's look at what is

00:13:06,100 --> 00:13:11,350
actually in the vector vector is a data

00:13:08,290 --> 00:13:13,449
structure with four elements for data

00:13:11,350 --> 00:13:16,239
members right because the data pointer

00:13:13,449 --> 00:13:18,009
decides the capacity and allocate the

00:13:16,239 --> 00:13:19,869
data pointer points to the array of

00:13:18,009 --> 00:13:23,920
elements which exist somewhere where the

00:13:19,869 --> 00:13:25,629
allocator told it to exist in this case

00:13:23,920 --> 00:13:27,339
in process number one I have the shared

00:13:25,629 --> 00:13:31,029
memory segment in which I placed the

00:13:27,339 --> 00:13:32,529
object but the data pointer is still

00:13:31,029 --> 00:13:36,549
pointing at my heap because as used the

00:13:32,529 --> 00:13:38,319
default allocate which was the secret

00:13:36,549 --> 00:13:40,809
template parameter of any external

00:13:38,319 --> 00:13:43,649
container my second process I attached

00:13:40,809 --> 00:13:49,679
to the same segment I saw the adapter

00:13:43,649 --> 00:13:52,689
started iteration and I got a set fault

00:13:49,679 --> 00:13:54,850
so to fix that obviously need to get an

00:13:52,689 --> 00:13:56,499
allocated to a point in data you have to

00:13:54,850 --> 00:13:59,379
back into the same shared memory

00:13:56,499 --> 00:14:01,329
segments as where they are placed in

00:13:59,379 --> 00:14:05,619
your own Delta now writing that was

00:14:01,329 --> 00:14:07,540
really non-trivial but those has resume

00:14:05,619 --> 00:14:10,619
allocated it does just that it's like a

00:14:07,540 --> 00:14:13,959
whole bunch of Archaea still just that

00:14:10,619 --> 00:14:15,189
so to use that it's another case of a

00:14:13,959 --> 00:14:18,189
knowledge iterative cost part of your

00:14:15,189 --> 00:14:21,670
type so you just supply to the Container

00:14:18,189 --> 00:14:23,410
as a template argument but it's a

00:14:21,670 --> 00:14:25,179
stateful vaquita so it has to use one of

00:14:23,410 --> 00:14:28,839
those constructors that every continue

00:14:25,179 --> 00:14:31,509
has that take an extra hour ki darga so

00:14:28,839 --> 00:14:33,749
in my case I'm going to use the

00:14:31,509 --> 00:14:37,389
constructor it takes an iterative pair

00:14:33,749 --> 00:14:39,279
and I also have to give it instance of

00:14:37,389 --> 00:14:41,019
an alligator or the constructors convert

00:14:39,279 --> 00:14:45,669
or anonymous convertible to an auditor

00:14:41,019 --> 00:14:48,639
type and now the vector is constructed

00:14:45,669 --> 00:14:50,339
in that segment and it's data also in

00:14:48,639 --> 00:14:56,949
the same segment in my other process

00:14:50,339 --> 00:15:00,610
attaches to that is it just fine right

00:14:56,949 --> 00:15:02,049
and but as I said I've had a nested

00:15:00,610 --> 00:15:03,560
container right I had a map holding

00:15:02,049 --> 00:15:12,240
other things

00:15:03,560 --> 00:15:14,820
so if we try to do that with if I try to

00:15:12,240 --> 00:15:16,770
just take regular nectar or letters for

00:15:14,820 --> 00:15:18,600
it for example and if if we use a

00:15:16,770 --> 00:15:20,550
standard director of wind as the row

00:15:18,600 --> 00:15:23,130
type you're going to have a sec food for

00:15:20,550 --> 00:15:25,560
the exact same reason as before because

00:15:23,130 --> 00:15:28,080
even though my outer container uses

00:15:25,560 --> 00:15:30,870
analogy that places the rows in that

00:15:28,080 --> 00:15:32,940
same shared memory segment that in a

00:15:30,870 --> 00:15:35,310
vector has no idea that it's going to

00:15:32,940 --> 00:15:37,650
shell us 7s using the default allocator

00:15:35,310 --> 00:15:41,280
and is still putting its data on my hip

00:15:37,650 --> 00:15:44,520
so another process our and my attached

00:15:41,280 --> 00:15:46,740
to that same vector of letters stop

00:15:44,520 --> 00:15:51,000
iteration and I get my egg fault just as

00:15:46,740 --> 00:15:53,610
before now if I were to replace the

00:15:51,000 --> 00:15:55,950
detector event up there in a row type

00:15:53,610 --> 00:15:57,600
the director of n comma alligator for

00:15:55,950 --> 00:16:00,330
shed lemon it wouldn't even compile

00:15:57,600 --> 00:16:03,000
because that alligator requires an

00:16:00,330 --> 00:16:05,100
argument and there is no way for me to

00:16:03,000 --> 00:16:08,550
pass that constructor argument on to the

00:16:05,100 --> 00:16:09,840
Rohtang the solution for that boost

00:16:08,550 --> 00:16:14,580
actually has a song solution which

00:16:09,840 --> 00:16:19,400
predates C++ 11 but as of C++ 11 not not

00:16:14,580 --> 00:16:22,260
a 19 but we have spot the lakita adapter

00:16:19,400 --> 00:16:24,420
I really wish it were available when I

00:16:22,260 --> 00:16:27,270
had to use this but it's go tell the

00:16:24,420 --> 00:16:28,980
caterer adapter take does exactly what I

00:16:27,270 --> 00:16:32,430
want to do here it takes the custard

00:16:28,980 --> 00:16:35,760
argument I pass to the outer container

00:16:32,430 --> 00:16:39,030
and then forwards the custard argument

00:16:35,760 --> 00:16:41,790
to the nested containers recursively

00:16:39,030 --> 00:16:44,340
forever so if I have a vector of vectors

00:16:41,790 --> 00:16:47,700
of vectors of maps of strings all of

00:16:44,340 --> 00:16:49,950
them will be constructed with the same

00:16:47,700 --> 00:16:54,150
construct an argument they pass to the

00:16:49,950 --> 00:16:55,770
outer container in my demo I'm placing

00:16:54,150 --> 00:16:58,140
the director of letters in shared memory

00:16:55,770 --> 00:17:00,930
I'm givin it my cantata argument that

00:16:58,140 --> 00:17:02,220
specifies the segment to use and now I

00:17:00,930 --> 00:17:05,970
can do whatever I want with a data

00:17:02,220 --> 00:17:09,780
structure can create new rows by those

00:17:05,970 --> 00:17:12,209
calls and I will use the same segment in

00:17:09,780 --> 00:17:13,590
our process I can attach it specify the

00:17:12,209 --> 00:17:18,080
same allocator and use a

00:17:13,590 --> 00:17:20,910
and I will see all my elements just fine

00:17:18,080 --> 00:17:23,190
scope allocator adapter is really

00:17:20,910 --> 00:17:25,800
intimidating if you look at the step so

00:17:23,190 --> 00:17:28,250
don't look at the step just use its it's

00:17:25,800 --> 00:17:28,250
not that hard

00:17:29,240 --> 00:17:32,970
so even I said I'm not going to talking

00:17:31,410 --> 00:17:34,590
about implementations that is one

00:17:32,970 --> 00:17:40,230
implementation you tell us actually

00:17:34,590 --> 00:17:42,120
worth noting when you attach to a shared

00:17:40,230 --> 00:17:44,610
memory segment from different processes

00:17:42,120 --> 00:17:47,870
that segment appears in a different

00:17:44,610 --> 00:17:51,350
address in each process memory space

00:17:47,870 --> 00:17:56,570
which means the reactors data pointer

00:17:51,350 --> 00:18:00,150
cannot be an address it cannot point to

00:17:56,570 --> 00:18:02,310
to your process memory there has to be a

00:18:00,150 --> 00:18:05,250
relative offset from something to exist

00:18:02,310 --> 00:18:07,710
in the same memory in a same shared

00:18:05,250 --> 00:18:12,060
memory segment and in case of boosters

00:18:07,710 --> 00:18:13,740
actually called offset point this is an

00:18:12,060 --> 00:18:15,320
example where an alligator has to change

00:18:13,740 --> 00:18:18,180
what that means to point to an object

00:18:15,320 --> 00:18:21,630
this facilities was called fancy

00:18:18,180 --> 00:18:26,160
pointers like that fancy German where

00:18:21,630 --> 00:18:28,110
happen or synthetic pointers as Bob

00:18:26,160 --> 00:18:29,610
stabilized to call and if you want to

00:18:28,110 --> 00:18:32,190
learn more about those don't miss that

00:18:29,610 --> 00:18:35,790
presentation from C++ now which talks

00:18:32,190 --> 00:18:37,230
about how well synthetic pointers are

00:18:35,790 --> 00:18:43,230
supported by different libraries and

00:18:37,230 --> 00:18:45,420
what you can do with them shared memory

00:18:43,230 --> 00:18:48,330
is the typical poster Java chef pointers

00:18:45,420 --> 00:18:49,770
these days but it's not only one it's

00:18:48,330 --> 00:18:53,130
not only key not only case when you have

00:18:49,770 --> 00:18:54,450
special memory needs and special union

00:18:53,130 --> 00:18:56,700
to what it means to point to something

00:18:54,450 --> 00:19:00,840
that is also something that's used in

00:18:56,700 --> 00:19:03,960
the GPU program something called pin

00:19:00,840 --> 00:19:06,000
memory in memories never it exists some

00:19:03,960 --> 00:19:07,680
specific address and is used to

00:19:06,000 --> 00:19:09,690
communicate with GPU devices act is

00:19:07,680 --> 00:19:12,480
visible from the host memory social

00:19:09,690 --> 00:19:14,670
visible from the GPU you can can use

00:19:12,480 --> 00:19:17,820
direct memory access to communicate and

00:19:14,670 --> 00:19:20,670
something you get in CUDA with could

00:19:17,820 --> 00:19:22,440
host a lock and you can get a Tanaka CLS

00:19:20,670 --> 00:19:24,750
European but for appropriate flags and

00:19:22,440 --> 00:19:27,059
of course if you want to put a container

00:19:24,750 --> 00:19:30,090
in that memory you know they use a holic

00:19:27,059 --> 00:19:31,679
a right which much every GPO libel has

00:19:30,090 --> 00:19:35,640
something like that Frost has

00:19:31,679 --> 00:19:37,860
interlocutor tensorflow has an alligator

00:19:35,640 --> 00:19:39,840
but that is not exactly steel compatible

00:19:37,860 --> 00:19:41,280
and boosts computer has an alligator

00:19:39,840 --> 00:19:43,380
which is also called they know lucky

00:19:41,280 --> 00:19:47,400
they just like a defrost one difference

00:19:43,380 --> 00:19:49,470
that boost uses a fancy pointer which

00:19:47,400 --> 00:19:53,159
holds a reference to device buffer and

00:19:49,470 --> 00:19:55,470
the minutes because this library is

00:19:53,159 --> 00:19:58,260
built to actually operate the data that

00:19:55,470 --> 00:20:02,840
lives on a GPU and that's one case where

00:19:58,260 --> 00:20:08,460
I had to use non-standard laughter a

00:20:02,840 --> 00:20:10,830
reason being standard the library is

00:20:08,460 --> 00:20:13,169
designed with fancy pointers that have a

00:20:10,830 --> 00:20:14,880
map into host memory because when you

00:20:13,169 --> 00:20:16,799
call the square brackets on your vector

00:20:14,880 --> 00:20:19,470
you're gonna get a real reference not a

00:20:16,799 --> 00:20:21,200
fancy synthetic reference it should be

00:20:19,470 --> 00:20:23,640
able to access them directly

00:20:21,200 --> 00:20:26,100
so this pointer is a bit too fancy for

00:20:23,640 --> 00:20:28,140
that but if you use frost it has the

00:20:26,100 --> 00:20:30,690
same alligator which uses a regular

00:20:28,140 --> 00:20:41,580
plane or the originality star as the

00:20:30,690 --> 00:20:44,390
data point now right there are many more

00:20:41,580 --> 00:20:49,500
crazy available alligators out there

00:20:44,390 --> 00:20:51,990
suggest the first few search results in

00:20:49,500 --> 00:20:55,289
Damian corsage because I was on page 3

00:20:51,990 --> 00:20:57,900
out of 45 and I could be talking about

00:20:55,289 --> 00:21:01,409
them for all all day but the main point

00:20:57,900 --> 00:21:03,659
I want to make is that you don't have to

00:21:01,409 --> 00:21:06,000
write alligators yourself you can but

00:21:03,659 --> 00:21:08,280
you don't have to the whole reason

00:21:06,000 --> 00:21:11,309
alligators being what they are is that

00:21:08,280 --> 00:21:17,490
they are reusable parish library

00:21:11,309 --> 00:21:20,850
components components that quite quite

00:21:17,490 --> 00:21:22,200
possibly have been written and if they

00:21:20,850 --> 00:21:25,580
haven't they should be written in a way

00:21:22,200 --> 00:21:25,580
that other people can benefit

00:21:26,640 --> 00:21:31,470
and if you do want to write them

00:21:29,490 --> 00:21:34,890
yourself there are plenty of talks about

00:21:31,470 --> 00:21:36,440
doing just that in this particular

00:21:34,890 --> 00:21:39,210
context

00:21:36,440 --> 00:22:33,090
so I think we have time for a few

00:21:39,210 --> 00:22:36,419
questions some of the question was that

00:22:33,090 --> 00:22:39,030
Kryten allocator aware types is on yours

00:22:36,419 --> 00:22:42,330
because of all the allocated trades that

00:22:39,030 --> 00:22:44,130
I have to look at and the allocated

00:22:42,330 --> 00:22:46,890
propagation semantics you have to take

00:22:44,130 --> 00:22:49,710
care of whether existing library

00:22:46,890 --> 00:22:52,860
simplifies that so no I thought if there

00:22:49,710 --> 00:22:54,780
is one that stopped by Alistair Meredith

00:22:52,860 --> 00:22:57,059
just before this one was about one of

00:22:54,780 --> 00:23:00,450
the ideas of how it could be made

00:22:57,059 --> 00:23:05,370
simpler in future and I believe I don't

00:23:00,450 --> 00:23:07,260
buy probable hop turn will be about the

00:23:05,370 --> 00:23:10,770
details of propagation trace and all

00:23:07,260 --> 00:23:13,230
those little things but yeah the status

00:23:10,770 --> 00:23:15,260
quo is that right in your own allocator

00:23:13,230 --> 00:23:20,160
or where continue is not you know

00:23:15,260 --> 00:23:21,570
especially if you want to be able to use

00:23:20,160 --> 00:23:23,580
that allocator into something that

00:23:21,570 --> 00:23:26,059
propagated down the chain to something

00:23:23,580 --> 00:23:26,059
you hold

00:23:50,980 --> 00:23:55,130
so question was whether there are

00:23:53,360 --> 00:23:57,470
alligators and generate random memory

00:23:55,130 --> 00:24:01,490
problems

00:23:57,470 --> 00:24:03,050
I imagine yes I've seen alligators and

00:24:01,490 --> 00:24:05,600
I've used alligators that I used for

00:24:03,050 --> 00:24:07,340
instruments and debugging and analyzing

00:24:05,600 --> 00:24:11,720
knowledge problems like and allocate is

00:24:07,340 --> 00:24:13,160
used for unit tests haven't is the prize

00:24:11,720 --> 00:24:15,140
in hockey theirs would be a nice segue

00:24:13,160 --> 00:24:20,870
to our next stop which right after this

00:24:15,140 --> 00:24:23,030
or not yeah it will be interesting after

00:24:20,870 --> 00:24:45,380
that someone what that available right

00:24:23,030 --> 00:24:46,600
now I haven't done characters yet okay

00:24:45,380 --> 00:24:48,800
okay sure

00:24:46,600 --> 00:24:51,980
yeah the question was what happens to

00:24:48,800 --> 00:24:54,350
future reference offensive pointer to

00:24:51,980 --> 00:24:56,630
get from boost computing device point

00:24:54,350 --> 00:24:58,430
what you get from that is a special

00:24:56,630 --> 00:25:01,040
iterator that they provide the device

00:24:58,430 --> 00:25:04,040
iterator which is quite which is

00:25:01,040 --> 00:25:09,470
essentially a fancier accessor to the

00:25:04,040 --> 00:25:11,620
data it's not directly pluggable into

00:25:09,470 --> 00:25:14,720
standard containers because it's not our

00:25:11,620 --> 00:25:16,340
teachers iterator you cannot just take

00:25:14,720 --> 00:25:18,910
us under Azzam do a pointer arithmetic

00:25:16,340 --> 00:25:18,910
on map

00:25:35,220 --> 00:25:40,300
some question was what was a 5000 ex was

00:25:38,260 --> 00:25:43,900
about in my slide or memory

00:25:40,300 --> 00:25:49,420
fragmentation improvement so when I ran

00:25:43,900 --> 00:25:51,190
this general use a standard allocated a

00:25:49,420 --> 00:25:53,380
Linux like I got my system break off a

00:25:51,190 --> 00:25:54,940
gigabytes so when you use malloc on

00:25:53,380 --> 00:25:56,710
Linux you have your allocation goes

00:25:54,940 --> 00:26:00,730
either in the system break which is the

00:25:56,710 --> 00:26:03,370
first like continued continuous heap

00:26:00,730 --> 00:26:05,650
space or those internal map areas which

00:26:03,370 --> 00:26:07,240
are all over the hill and ystem break

00:26:05,650 --> 00:26:09,430
usually just grows it doesn't shrink and

00:26:07,240 --> 00:26:11,650
if you they are lucky it's something you

00:26:09,430 --> 00:26:13,030
don't actually incur a system call you

00:26:11,650 --> 00:26:14,260
just leave a hole in your system break

00:26:13,030 --> 00:26:15,850
and if you're lucky it's going to be

00:26:14,260 --> 00:26:21,490
filled back in if the molokai

00:26:15,850 --> 00:26:23,110
understands if it was able to find it

00:26:21,490 --> 00:26:25,210
next time and allocate something in the

00:26:23,110 --> 00:26:27,220
same size I had many mismatch size

00:26:25,210 --> 00:26:29,410
allocation here and those mismatches

00:26:27,220 --> 00:26:33,040
course that you build up a very

00:26:29,410 --> 00:26:35,740
fragmented heap so I had a massive

00:26:33,040 --> 00:26:37,180
system of a gigabytes whereas when I ran

00:26:35,740 --> 00:26:40,600
through the pool allocator I ended up

00:26:37,180 --> 00:26:44,680
with not growing that system like at all

00:26:40,600 --> 00:26:46,320
at the end of the run I have only three

00:26:44,680 --> 00:26:50,440
megabytes

00:26:46,320 --> 00:26:53,770
now this is one of them so your mileage

00:26:50,440 --> 00:26:55,180
may vary but it represents something

00:26:53,770 --> 00:26:57,280
that we actually saw in production

00:26:55,180 --> 00:26:59,730
didn't do something transparent for a

00:26:57,280 --> 00:26:59,730
year at a time

00:27:05,870 --> 00:27:16,340
right else going once going twice

00:27:16,640 --> 00:27:23,760
alright thank you for this

00:27:20,540 --> 00:27:23,760

YouTube URL: https://www.youtube.com/watch?v=HdQ4aOZyuHw


