Title: CppCon 2017: Arthur O'Dwyer “dynamic_cast From Scratch”
Publication date: 2017-10-13
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
This session will introduce you to the C++ object model: the rules by which C++ class objects are translated into memory layouts. We'll quickly cover polymorphic class types and multiple and virtual inheritance. We'll discuss the anatomy of a virtual method call, the difference between `static_cast` and `reinterpret_cast`, and what's contained in a vtable besides function pointers. We'll see that the way `dynamic_cast` thinks about the class hierarchy is slightly different from the way we're used to drawing it; and that `dynamic_cast` is expensive enough that sometimes we can find cheaper ways to ask an object for its type! The climax will be a complete, bug-free, and fast implementation of C++'s built-in `dynamic_cast`, using our own hand-crafted artisanal run-time type information (RTTI).

Attendees will incidentally be exposed to several features of the modern C++ language, including type traits and the `final` qualifier.

This session will mostly be talking about the Itanium C++ ABI, which is the standard on Linux and OS X systems. Mapping these concepts to the MSVC ABI will be left as an exercise for the reader of the project's GitHub repo: https://github.com/Quuxplusone/from-scratch/tree/master/dynamic-cast#dynamic_cast-from-scratch
— 
Arthur O'Dwyer: Core Engineering, Nominum

Arthur O'Dwyer worked for many years at Green Hills Software, making the world's most optimizing C and C++ compilers. Now he works at Nominum in San Francisco. Arthur is the showrunner of the Bay Area C++ meetup, which meets practically every week these days.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:05,500
Hello, everyone. I'm Arthur O'Dwyer, and I am here to tell you about...

00:00:05,500 --> 00:00:07,720
dynamic_cast From Scratch.

00:00:07,720 --> 00:00:09,840
Which you can't see, because it's on the first slide, and I already went past that one...

00:00:09,880 --> 00:00:13,400
And I'm too scared to go back, because I don't want it to crash on me.

00:00:14,640 --> 00:00:21,000
I'm going to tell you all about dynamic_cast; about what it is, what it does...

00:00:21,000 --> 00:00:25,500
a little bit about how it's implemented, and mostly about how it SHOULD be implemented.

00:00:26,500 --> 00:00:30,620
And I'm going to show that how it SHOULD be implemented is better than how it IS implemented.

00:00:30,620 --> 00:00:38,240
I hope that there's someone in this audience who owns a dynamic_cast implementation. That would be awesome. Come talk to me afterward.

00:00:39,760 --> 00:00:46,080
All right, so, in Part 1, I'm gonna tell you what it does. And in Part 2 I'm gonna tell you—

00:00:46,320 --> 00:00:54,920
Well, hang on. In Part 1 I'm gonna tell you the background: what is polymorphism, and what are all the different toys that we have to play with.

00:00:54,940 --> 00:01:00,220
In Part 2 I'm gonna tell you what dynamic_cast does with those toys; how we implement it; and I'm going to show you my implementation.

00:01:01,629 --> 00:01:03,629
All right. Quick recap of polymorphism.

00:01:03,879 --> 00:01:07,018
Classical object-oriented polymorphism.

00:01:07,600 --> 00:01:13,710
We have a class `Animal`. An Animal has some `legs`, and it has a couple of virtual methods.

00:01:14,460 --> 00:01:19,580
The virtual methods are basically function pointers held in a vtable...

00:01:19,580 --> 00:01:25,300
and the `Animal` object instance has a vptr as its first member...

00:01:25,300 --> 00:01:33,380
—usually. In the Linux ABI. — I'll be talking a lot about the Itanium ABI, about the ABI that's used on OSX and on Linux.

00:01:33,420 --> 00:01:41,080
For Windows, this is largely the same, with some differences around virtual bases. I will mostly not be talking about Windows.

00:01:41,740 --> 00:01:43,740
Be aware.

00:01:43,930 --> 00:01:47,189
All right, so we have a vptr in the Animal instance.

00:01:47,189 --> 00:01:51,560
And then we have `class Cat`. A Cat is an Animal. Cat inherits from Animal publicly.

00:01:51,560 --> 00:01:55,020
A Cat has all the stuff an Animal has; and it also has a number of `tails`.

00:01:56,040 --> 00:02:02,200
It can override one of the virtual methods of the base class Animal,

00:02:02,200 --> 00:02:08,120
so where, when an Animal in general speaks, it says "hi"; when a Cat speaks, it says "ouch".

00:02:08,160 --> 00:02:19,900
And, when a Cat speaks, and it says "ouch", it also knows about all of the data held in the Cat, as well as all the data held in the Animal. Right?

00:02:20,320 --> 00:02:25,200
All right. And the way that we implement that is, that the Cat looks just like an Animal.

00:02:25,200 --> 00:02:28,600
It has a vptr, and the `legs`; and then it has the extra stuff — the `tails`.

00:02:28,600 --> 00:02:34,340
And its vtable, that is pointed to BY the vptr, also looks physically just like the vtable for an Animal.

00:02:34,780 --> 00:02:39,540
It's got the `speak` method, and it's got the destructor — in that order, at those offsets —

00:02:39,540 --> 00:02:44,849
and that's important because that means when we have a pointer to a Cat we can treat it like it was a pointer to an Animal,

00:02:44,850 --> 00:02:47,040
and we'll get the right physical behavior.

00:02:48,600 --> 00:02:59,580
For example, if I have a pointer to an Animal, let's say, `a`; and I call `a->speak()`, what that does physically in the assembly is—

00:03:00,100 --> 00:03:04,940
go get the thing at offset zero from %rdi — that'd be the vptr —

00:03:04,940 --> 00:03:11,960
follow it and go get the first thing out of the vtable — that'd be *%rax here — and call that.

00:03:11,960 --> 00:03:15,660
So if `a` actually is the address of a Cat, I get `Cat::speak()`;

00:03:15,660 --> 00:03:19,840
if it's the address of a base Animal I get `Animal::speak()`;

00:03:19,840 --> 00:03:25,660
If it's the address of some other kind of Animal, I get that Animal's `speak` method.

00:03:27,760 --> 00:03:31,580
So there are several different graphical representations — ways we can represent this idea.

00:03:32,260 --> 00:03:36,400
One of them is just in speech. I like to say a Cat IS-AN Animal.

00:03:36,600 --> 00:03:39,600
Cat inherits from Animal. A Cat IS-AN Animal.

00:03:40,200 --> 00:03:45,280
We can also represent it graphically by drawing out the struct layout.

00:03:45,280 --> 00:03:51,920
This is a representation of what the compiler actually will generate as the struct layout for a `Cat`...

00:03:51,940 --> 00:03:55,880
Notice that it has, first, the vptr in the Animal data — at the start of the Cat —

00:03:55,880 --> 00:03:58,520
And then has the Cat-specific data after that.

00:03:58,600 --> 00:04:04,940
This is what gives us this happy coincidence that the first part of a Cat looks physically exactly like an Animal,

00:04:04,940 --> 00:04:08,380
and allows us to use an `Animal*` to get into it.

00:04:08,740 --> 00:04:18,080
And then also over here, I've got a graphical representation of a Cat descending from an Animal. We'll see a lot more of that soon.

00:04:18,820 --> 00:04:20,080
Multiple inheritance.

00:04:20,090 --> 00:04:22,209
All right. Now we get to the Dreaded Diamond.

00:04:22,209 --> 00:04:27,620
And interestingly, we just heard Titus Winters in the keynote ["C++ as a Live-at-Head Language"] talking about a different kind of dreaded diamond.

00:04:27,620 --> 00:04:30,040
This is ALSO a dreaded diamond.

00:04:30,580 --> 00:04:35,820
Here we have `class Animal`. It has a virtual destructor (because why not)...

00:04:36,440 --> 00:04:40,580
and we have Cat IS-AN Animal; Dog IS-AN Animal;

00:04:40,640 --> 00:04:44,660
And then we have a `CatDog` which inherits from both `Cat` and `Dog`.

00:04:47,600 --> 00:04:52,400
Notice the lack of `virtual` keywords here — `public Animal`, `public Animal` — this is intentional.

00:04:54,040 --> 00:04:56,800
So graphically we have something that looks like this.

00:04:57,080 --> 00:05:00,500
Here's the layout of a CatDog.

00:05:00,500 --> 00:05:07,240
A CatDog has, physically, its first base and then its second base.

00:05:07,880 --> 00:05:11,700
Its first base is a Cat; and the Cat has a base that's an Animal.

00:05:11,980 --> 00:05:14,920
So that part we've seen before — the Cat has an Animal base, that all looks the same —

00:05:14,920 --> 00:05:20,740
But then after that we also have the Dog part; and the Dog also has an Animal, IS-AN Animal.

00:05:20,980 --> 00:05:24,320
And then we have the CatDog-specific data down at the bottom.

00:05:24,440 --> 00:05:27,140
All right, so now we have a question.

00:05:27,260 --> 00:05:32,060
IS-A CatDog an Animal? How many people think a CatDog IS-AN animal? [MANY HANDS]

00:05:32,260 --> 00:05:36,200
How many people think a CatDog is NOT an Animal? [ONE HAND]

00:05:36,340 --> 00:05:39,720
All right, well, I'm going to make YOU happy.

00:05:39,720 --> 00:05:44,720
It's NOT. A CatDog is NOT an Animal. A CatDog is two Animals.

00:05:44,720 --> 00:05:47,140
It's got two Animal subobjects.

00:05:47,200 --> 00:05:49,940
It is not AN Animal.

00:05:51,940 --> 00:05:59,800
Because if I were to point to this CatDog and say, "Mommy, can I have THAT animal?" —

00:05:59,800 --> 00:06:04,220
she'd be like, "Which one do you mean?" Right? It's not one Animal, it's two Animals.

00:06:04,220 --> 00:06:08,460
When I point to the CatDog, I have no idea what Animal I'm talking about.

00:06:08,660 --> 00:06:13,780
However, we can fix this! If we can give the CatDog just one Animal subobject,

00:06:13,820 --> 00:06:19,140
then when I point to it and say "I would like that Animal," you know exactly which one I mean. And we do that with virtual inheritance.

00:06:19,300 --> 00:06:24,320
So in C++ we have the idea of virtual inheritance,

00:06:25,099 --> 00:06:30,879
where I can inherit by saying `class Cat : public virtual Animal`, `class Dog : public virtual Animal`...

00:06:31,580 --> 00:06:33,580
and now that Animal base subobject sort of de-duplicates itself.

00:06:36,770 --> 00:06:43,270
Whenever I have something that inherits from a Cat or inherits from a Dog, that Animal virtual base sort of floats down to the bottom.

00:06:43,370 --> 00:06:46,900
Even after the CatDog-specific data. It just floats all the way down, and de-duplicates itself.

00:06:49,220 --> 00:06:57,460
So that now the Cat's virtual base and the Dog's virtual base have both combined, and we have only one Animal virtual base.

00:06:57,520 --> 00:07:02,920
And so we have a happy CatDog, because it is only one Animal.

00:07:03,740 --> 00:07:06,500
All right, but now we've changed how a Cat looks, right?

00:07:06,500 --> 00:07:12,780
A Cat used to look physically like an Animal, so we could have an `Animal*` that secretly points to a `Cat`,

00:07:12,780 --> 00:07:18,070
And we could just treat it like it was an Animal because physically they were identical.

00:07:18,070 --> 00:07:23,499
Now we've changed how a Cat looks, so now we have a problem. Now if I have, let's say, a `Cat*`,

00:07:23,500 --> 00:07:29,260
and I want to access its number of `legs` — which is part of its Animal virtual base —

00:07:29,260 --> 00:07:32,020
how do I actually get at that Animal data anymore?

00:07:32,020 --> 00:07:37,680
I don't have a way to sort of offset into it, because there could be arbitrary stuff in between.

00:07:37,680 --> 00:07:41,520
There could be nothing in between, there could be a Dog in between — I have no idea.

00:07:41,800 --> 00:07:45,740
So we have to distinguish between objects that are really just Cats —

00:07:45,740 --> 00:07:50,740
— like, literally it is, dynamically it is, a Cat; its actual TYPE is Cat —

00:07:50,740 --> 00:07:55,940
and objects that are "Cat but maybe more." Maybe it's a CatDog, maybe it's a Tiger, I don't know.

00:07:55,940 --> 00:08:00,460
It's some kind of Cat, but I don't know what else it might ALSO be.

00:08:00,520 --> 00:08:05,320
Cat objects that are just literally just a Cat, dynamically a Cat, they have a fixed concrete layout.

00:08:05,320 --> 00:08:12,240
Cat objects that are "maybe more" have a fixed layout for all their base sub-object pieces, but you have to do some work to figure out where those pieces are located.

00:08:12,920 --> 00:08:17,760
To generalize this away from cats into C++ classes,

00:08:17,760 --> 00:08:23,880
objects that are "most derived" have a fixed concrete layout dictated by their "most derived type."

00:08:24,440 --> 00:08:30,420
and if I have an object of unknown dynamic type, it has a fixed layout for all its base subobject pieces, but...

00:08:30,420 --> 00:08:35,160
to access a virtual base, you first have to figure out what is the most derived type of this object.

00:08:35,160 --> 00:08:40,320
That tells you its fixed concrete layout, and THAT tells you where its virtual bases are located.

00:08:40,960 --> 00:08:44,600
So how do we figure that out? how do we find out, at runtime,

00:08:44,660 --> 00:08:52,400
given that I have a pointer to a Cat, given that I have a pointer to an Animal, how do I figure out its most derived type?

00:08:52,400 --> 00:08:54,020
I can't do that statically.

00:08:54,020 --> 00:08:56,820
I have to do that dynamically somehow at runtime. How do I do that?

00:08:57,080 --> 00:09:03,480
Well, we have a place for stuff that's determined dynamically at runtime. That place is the vtable.

00:09:03,800 --> 00:09:06,460
So. Vtables.

00:09:06,460 --> 00:09:09,220
Vtables have two things going on in them, right?

00:09:09,220 --> 00:09:18,340
There's the SCHEMA of the vtable, of what stuff does it contain — it contains a pointer to my `speak` method, a pointer to my destructor —

00:09:18,460 --> 00:09:27,140
— you know — um, the vptr itself is located at offset zero — those are sort of the SCHEMA of the vtable.

00:09:27,140 --> 00:09:30,400
They define the SHAPE of the data. But then there's also the VALUE.

00:09:30,420 --> 00:09:38,360
Where does that vptr point? What actually is the behavior of the `speak` method? what actually is the behavior of the destructor?

00:09:38,360 --> 00:09:40,620
That's the data, or the values in the vtable.

00:09:40,820 --> 00:09:44,140
The schema of the vtable is dictated by the object's static type.

00:09:44,140 --> 00:09:51,240
If I know I have an `Animal*` — right now I have a `Cat*` — the `Animal*` will always point to something that looks physically like an `Animal`.

00:09:51,240 --> 00:09:54,140
It has all of the Animal bits in known places.

00:09:54,140 --> 00:09:57,580
A `Cat*` will point to something that has all the Cat bits in known places.

00:10:00,280 --> 00:10:03,400
And then I just have to go look at actually what are those bits.

00:10:03,460 --> 00:10:08,080
And those bits' values will be dictated by the object's most derived type, by the dynamic type.

00:10:08,300 --> 00:10:11,520
So in this example I have a `Cat*...

00:10:11,520 --> 00:10:19,080
and the fact that the `Cat` object HAS a virtual base Animal is dictated statically by the fact that the object IS-A Cat.

00:10:19,640 --> 00:10:23,700
Every Cat has a virtual base Animal; I just might not know WHERE it is.

00:10:23,700 --> 00:10:30,180
So the PRESENCE of it is dictated statically; the actual LOCATION of it is dictated dynamically by the most derived type.

00:10:30,820 --> 00:10:34,020
And the place where all this stuff comes together is in the vtable.

00:10:34,020 --> 00:10:39,920
So we should assume that we can find our virtual base Animal by querying our Cat object's vtable.

00:10:40,100 --> 00:10:44,720
All right. This is how our memory layout looked on slide 4...

00:10:44,720 --> 00:10:46,500
let's update it... hopefully...

00:10:46,840 --> 00:10:50,520
Let's see... this is not virtual inheritance, this was regular inheritance...

00:10:50,520 --> 00:10:55,360
Here's virtual inheritance. Our Animal virtual bases floated down to the bottom of the Cat...

00:10:55,360 --> 00:11:01,660
And now because Animal is also a polymorphic type, it also has a vptr, right? So we have a vptr for the Cat and a vptr for the Animal,

00:11:01,660 --> 00:11:07,700
and they both happen to point to two vtables whose data is controlled by `Cat`.

00:11:07,700 --> 00:11:12,780
In fact, this isn't even quite right; we really have something more like this.

00:11:12,780 --> 00:11:21,780
This needs to be a vtable for the Animal SUBOBJECT of a Cat, whereas that is a vtable for the Cat object itself.

00:11:21,780 --> 00:11:26,320
The difference is these little asterisks, these little red stars.

00:11:26,600 --> 00:11:31,440
`Cat::speak` with a little asterisk is identical to `Cat::speak`, EXCEPT...

00:11:31,440 --> 00:11:35,980
That when you call this you're calling it because you have a pointer to an Animal.

00:11:35,980 --> 00:11:42,540
But `Cat::speak`, the actual method, expects a pointer to a Cat as its `this` pointer.

00:11:42,620 --> 00:11:47,640
And if I have a pointer to the Animal there...

00:11:47,640 --> 00:11:50,800
if I have a pointer to this Animal,

00:11:50,920 --> 00:11:58,140
That's 16 bytes offset from the actual pointer to the Cat, which is what `Cat::speak` wants.

00:11:58,140 --> 00:12:07,000
So when I call `Cat::speak` with a little asterisk next to it, I actually need to first subtract 16 from my `this` pointer before I can dispatch to `Cat::speak`.

00:12:07,000 --> 00:12:09,700
This is called a "thunk."

00:12:10,240 --> 00:12:14,060
Because that's the noise it makes.

00:12:14,920 --> 00:12:16,920
All right.

00:12:18,440 --> 00:12:20,440
So when in doubt, it's in the vtable.

00:12:20,540 --> 00:12:27,440
If we're looking for something where its PRESENCE is statically determined — It definitely HAS one of these things...

00:12:27,440 --> 00:12:31,120
but we need to find out what it actually IS.

00:12:31,160 --> 00:12:34,360
In this case the thing we're looking for that we know it HAS, but we want to know what it IS...

00:12:34,360 --> 00:12:39,840
We know it HAS a most derived type, but we'd like to know what IS its most derived type.

00:12:40,040 --> 00:12:46,320
So anything where we know statically it's got one, we just want to know what it is, is gonna live in the vtable,

00:12:46,320 --> 00:12:52,300
because the schema of the vtable is controlled by the static type, and the stuff in it is controlled by that dynamic type.

00:12:52,300 --> 00:12:56,520
And "most derived type" is a synonym for "dynamic type."

00:12:56,960 --> 00:12:59,200
All right, so in our vtable...

00:12:59,200 --> 00:13:00,880
[LAUGHTER IN THE NEXT ROOM OVER]

00:13:00,880 --> 00:13:05,220
Next door is having fun. You probably can't hear that in the video. There's all sorts of stuff going on over there.

00:13:06,060 --> 00:13:13,080
So it offset zero we have `Cat::speak`; at offset 8 we have Cat's destructor,

00:13:13,080 --> 00:13:16,700
but also at the negative offsets we have room to put things.

00:13:16,840 --> 00:13:20,640
and so we're actually going to put things there — in the Itanium ABI.

00:13:21,060 --> 00:13:27,980
What we're gonna put at offset -1, we're gonna put a pointer to the type_info for the most derived type.

00:13:28,060 --> 00:13:30,320
This is super convenient.

00:13:30,520 --> 00:13:35,620
So now even when I've got `a`, which is a pointer to an Animal,

00:13:35,620 --> 00:13:42,160
if I want to know its typeid, so I do `typeid(*a)`, what do I do?

00:13:42,480 --> 00:13:54,420
I follow the pointer, and I get the vptr, and I follow that, and I subtract eight from it, and I dereference it... and now I have typeid-of-Cat!

00:13:54,420 --> 00:13:59,080
So typeid(*a) is typeid(Cat), which is true. It is, in fact, a Cat.

00:13:59,160 --> 00:14:03,160
Somehow the Animal virtual base "just knew" that this was a Cat.

00:14:03,160 --> 00:14:07,400
And the reason that it can know that is because this vptr is getting filled in by Cat's constructor...

00:14:07,440 --> 00:14:15,280
and it's initializing it to point to the vtable for Animal-in-Cat, and not the vtable for Animal-in-Dog, or Animal-anywhere-else.

00:14:16,560 --> 00:14:19,320
All right.

00:14:21,120 --> 00:14:25,440
Getting at Animal data. How do we get at the Animal base object of a Cat?

00:14:26,440 --> 00:14:33,640
So here we have a `Cat*`, and I would like to know how many `legs` this Cat has.

00:14:33,880 --> 00:14:43,220
So I can no longer just index, and add 16 or add 24, to get down to how many legs this Cat has,

00:14:43,220 --> 00:14:46,580
because it might be "more." It might be a CatDog. It might be a Tiger.

00:14:47,700 --> 00:14:49,700
So what I have to do is,

00:14:50,720 --> 00:14:59,160
I follow its vptr, and— Now, I know statically that this IS-A Cat; that it's pointing to a vtable for a Cat-in-something larger — possibly —

00:14:59,860 --> 00:15:04,020
And I know a Cat has a virtual base of type Animal.

00:15:04,020 --> 00:15:10,920
I know that it is PRESENT; I just want to know where it IS. And so where do we put that? We put that in the vtable!

00:15:10,920 --> 00:15:15,000
Somewhere in the vtable we also have... Oh, I kind of skipped over this...

00:15:15,000 --> 00:15:19,880
`md-offset = 0`, the "most derived offset", says that this object that I'm pointing to right here, this vptr —

00:15:19,880 --> 00:15:24,260
is actually at the beginning of the object. There's nothing before it.

00:15:25,320 --> 00:15:33,780
And, even before that, I I have the fact that my Animal virtual base is at offset 16, in this most derived type.

00:15:34,880 --> 00:15:41,340
Remember, this vptr points to a vtable which is controlled by the dynamic type, by the most derived type,

00:15:41,340 --> 00:15:44,660
and it knows everything about this object, by definition.

00:15:44,800 --> 00:15:49,800
Because it is the MOST derived type. It's the type that was ACTUALLY constructed here.

00:15:50,000 --> 00:15:53,500
This is the object we ACTUALLY have that we will ACTUALLY destroy later.

00:15:53,500 --> 00:16:00,480
And so it knows everything about itself — such as where its virtual bases are located — and it can expose that through the vtable.

00:16:02,780 --> 00:16:08,060
So here I have a function that takes a Cat and returns how many legs that Cat has.

00:16:08,060 --> 00:16:12,760
You run this through a compiler, you run it through godbolt.org, and you see that...

00:16:14,900 --> 00:16:19,820
Here's `c` in %rdi. We dereference it once;

00:16:19,820 --> 00:16:26,460
we dereference it again and subtract 24 — that gets us our animal offset;

00:16:26,460 --> 00:16:34,760
We add that to our original `this` pointer — so, vptr plus 16 — gets us `legs`.

00:16:35,000 --> 00:16:36,740
More or less. Ah, plus 8.

00:16:36,740 --> 00:16:46,360
Yeah. This address, plus that 16 to get us to the beginning of the Animal, plus the 8 that's the offset of `legs` in Animal...

00:16:46,360 --> 00:16:48,460
gets us the number of `legs` in this Cat.

00:16:48,460 --> 00:16:56,880
So accessing a data member of a virtual base actually requires three dereferences,

00:16:56,880 --> 00:17:02,720
where if it were a non-virtual base it would only require one dereference.

00:17:05,020 --> 00:17:11,900
And here's a little vtable layout recap. Again, this is the Itanium ABI. MSVC is much more complicated.

00:17:14,320 --> 00:17:17,400
Any questions so far? We'll do a little pause.

00:17:18,240 --> 00:17:24,920
[AUDIENCE] I'm still a little fuzzy on, when you talk about the difference between `Animal::speak` and `Cat::speak`,

00:17:24,920 --> 00:17:31,740
why I just store it twice. It wasn't really obvious to me why you only have to store twice

00:17:31,740 --> 00:17:37,760
when we have virtual inheritance and not when we have normal multiple inheritance or something like that.

00:17:38,140 --> 00:17:49,460
[ARTHUR] So the question was, why when we have virtual inheritance do we have two vptrs pointing to different vtables with thunks

00:17:49,460 --> 00:17:54,160
whereas when we have non-virtual inheritance we can somehow get away with only one vptr?

00:17:54,160 --> 00:17:57,880
[AUDIENCE] Specifically, why is `speak` listed in both?

00:17:58,700 --> 00:18:03,500
Well in this case, this up here is a base Animal, and it has a `speak`;

00:18:03,500 --> 00:18:14,320
and here we have a Cat that also IS-AN Animal and so it physically looks like an Animal, but it actually speaks like a Cat.

00:18:14,320 --> 00:18:22,280
And we can get away with this because we don't have to do any offset adjustment. There's no multiple inheritance going on here.

00:18:23,060 --> 00:18:30,380
In a sense you could think of it as, this one is BOTH `Cat::speak` and `Cat::speak` with the little red asterisk.

00:18:30,380 --> 00:18:35,380
It's just that the offset we're applying to the `this` pointer is zero in this case.

00:18:35,380 --> 00:18:41,680
So we can get away with just having the vptr do double duty for both `Animal` and for `Cat`.

00:18:41,680 --> 00:18:44,480
[AUDIENCE] If you have multiple inheritance, though, you might need an offset.

00:18:44,480 --> 00:18:49,220
If you have multiple inheritance... then...

00:18:50,560 --> 00:18:58,320
If you're multiply inheriting from, let's say, `Cat`, then you won't need an offset. We'll have, ah...

00:18:58,660 --> 00:19:03,140
We'll have something like this. Each `Animal` has its own vptr here, because there are two Animals.

00:19:03,260 --> 00:19:09,980
But the Dog can share its vptr with its Animal; Cat can share its vptr with its Animal.

00:19:10,100 --> 00:19:12,100
So. It works out.

00:19:14,980 --> 00:19:21,380
All right. So in the subtitle, which you didn't really see because I had it already at the outline when we started recording,

00:19:21,840 --> 00:19:29,300
The subtitle is "Two kinds of inheritance graphs." So I'm going to talk now about how I visualize complex class layout.

00:19:30,560 --> 00:19:35,860
When I decided that I was going to figure out how `dynamic_cast` worked and then I was going to implement it myself,

00:19:36,280 --> 00:19:39,280
there were a lot of test cases involved in this.

00:19:40,380 --> 00:19:43,140
And a fair number of bug reports, for that matter.

00:19:43,140 --> 00:19:50,460
And when figuring out, like, "What is it that dynamic_cast was SUPPOSED to do in this instance?"

00:19:50,460 --> 00:19:56,440
I found that I needed a way to take an auto-generated class hierarchy

00:19:56,440 --> 00:20:02,860
and put it on a whiteboard, so that I could trace through it myself and figure out what I expected to happen.

00:20:02,860 --> 00:20:07,580
And so this is the system I came up with for whiteboarding complex class hierarchies.

00:20:07,800 --> 00:20:15,840
Does anyone think that whiteboarding complex class hierarchies will be a useful job skill for them? I'm just curious.

00:20:16,600 --> 00:20:25,380
We have a few tentative hands. All right — I was hoping it wouldn't be, like, everybody. That would be the sorry state of the industry.

00:20:25,620 --> 00:20:30,000
But I do hope this is useful for some people, at least.

00:20:31,120 --> 00:20:39,020
All right. So what I do is, I pick which class am I interested in diagramming...

00:20:39,020 --> 00:20:44,960
So in this case I'm making the diagram for `CatDog`. And I put it at the very bottom of my little tree here.

00:20:44,960 --> 00:20:50,420
And then for each of its bases, I make another little circle, and I put the name of that class.

00:20:50,420 --> 00:20:56,820
So I have `CatDog` inherits from a `Cat`, inherits from a `Dog`. It has a `Cat` subobject, and it has a `Dog` subobject.

00:20:56,820 --> 00:21:02,700
And then, for each of THEIR bases, I make a little circle and I draw a line up there. A `Cat` has an `Animal` subobject. A `Dog` has an `Animal` subobject.

00:21:02,720 --> 00:21:05,020
Notice that this is not virtual inheritance.

00:21:05,400 --> 00:21:17,340
Therefore if I turn this sideways, it looks an awful lot like the diagrams we were drawing with the big boxes; it's just more compact.

00:21:18,920 --> 00:21:26,120
In the case that there's non public inheritance, I'm going to draw a little dotted line instead of a solid line.

00:21:26,120 --> 00:21:32,980
So here, `Dog` has a non-public `Animal` base. That will become relevant when we talk about dynamic_cast.

00:21:33,520 --> 00:21:37,840
And then the last kind of inheritance we can have — we can have virtual inheritance.

00:21:37,840 --> 00:21:46,220
When you have virtual inheritance, remember, your virtual bases sort of float down to the bottom and de-duplicate themselves.

00:21:46,220 --> 00:21:54,180
So to indicate virtual inheritance I put a big solid circle around the virtual base and everyone points to that.

00:21:54,180 --> 00:22:00,360
As soon as there's a big solid circle around that, there's only gonna be one big-solid-circled `Animal` in any given diagram,

00:22:00,360 --> 00:22:04,080
because all the virtual bases are going to end up being shared.

00:22:04,580 --> 00:22:06,580
Quick question.

00:22:10,720 --> 00:22:14,660
Virtual bases only de-duplicate themselves with other virtual bases. Yes.

00:22:14,660 --> 00:22:20,100
I could have one or more non-circled Animals also in this diagram.

00:22:24,400 --> 00:22:29,800
Notice also here that `Animal` is a public virtual base of `CatDog`.

00:22:30,020 --> 00:22:36,860
There is a public path from `CatDog` to `Animal`, but not from `Dog` to `Animal`, and that will also become relevant soon.

00:22:37,100 --> 00:22:45,540
Alright, so lines indicate inheritance, nodes indicate subobjects, dotted lines indicate non-public inheritance, heavy circles indicate virtual inheritance.

00:22:45,540 --> 00:22:48,120
The root of the graph, down at the bottom, is the most derived object.

00:22:48,320 --> 00:22:53,760
There's always a single one of those. Because I'm interested in that class at the moment, not some other class.

00:22:53,760 --> 00:23:01,820
Some other class might have a graph that was just a subgraph of this graph, or it might have a graph that looks significantly different.

00:23:01,820 --> 00:23:05,220
mostly due to virtual bases.

00:23:05,860 --> 00:23:08,780
We also don't have a great way to indicate inheritance order here...

00:23:08,780 --> 00:23:14,280
such as, you know, `CatDog` inherited from `public Cat, public Dog` and not vice versa.

00:23:14,280 --> 00:23:17,380
That does affect the struct layout, of course,

00:23:17,380 --> 00:23:22,420
but inheritance order is not supposed to matter to `dynamic_cast`.

00:23:24,750 --> 00:23:30,829
If we had time for guessing games, I would not give you the solutions to these, but in the interest of time...

00:23:30,829 --> 00:23:36,000
Here's some possible graphs [on the left]; here are some impossible graphs [on the right].

00:23:36,000 --> 00:23:37,620
So these are all possible.

00:23:37,620 --> 00:23:47,980
Here's an example of Gaspar's point about having a virtual base `L` and a non-virtual base `L` in the same class layout.

00:23:49,340 --> 00:23:59,360
And over on the right-hand side we have EFGH, where it's reasonable except that G has no business being in there.

00:23:59,360 --> 00:24:05,400
It's not part of H. We clearly don't care about it right now. G shouldn't be there. Or something like that.

00:24:06,480 --> 00:24:14,280
Over here, U, the object at the root of this hierarchy, has been marked as a virtual base... of what? That doesn't make sense.

00:24:14,280 --> 00:24:18,100
Over here Z inherits from Y twice. That also doesn't make sense.

00:24:18,120 --> 00:24:23,120
Not to mention that both Ys are circled, indicating they're virtual bases and so there should only be one of it.

00:24:23,120 --> 00:24:31,120
And then this last one is a little more subtle. Here we have X inherits from W, and Y inherits from W, and W inherits from V...

00:24:31,160 --> 00:24:37,660
But in one case W inherits from V publicly, and in the other case W inherits from V privately.

00:24:37,660 --> 00:24:45,440
But W is a class. It it has to either inherit publicly or privately [from V]; it can't do both. That's not a thing.

00:24:45,980 --> 00:24:48,460
So that's also an impossible graph.

00:24:48,680 --> 00:24:53,080
Again, these are not graphs you "have to avoid," or anything. I'm just pointing out that by these conventions,

00:24:53,400 --> 00:25:01,520
these [right-hand] graphs make literally no sense. Those [left-hand] graphs are possible to get from C++ programs.

00:25:03,060 --> 00:25:11,100
And we can match these graphs to their code... I'll leave that up for the video, and then I'm just going to go on.

00:25:13,460 --> 00:25:17,740
Now we've gotten to a break. How am I doing on time?

00:25:17,740 --> 00:25:19,800
Not bad.

00:25:19,800 --> 00:25:22,260
Now I'm going to start actually talking about `dynamic_cast`.

00:25:22,260 --> 00:25:26,320
We have now completely explained everything there is to know about classical polymorphism

00:25:26,320 --> 00:25:30,560
and now I'm going to talk about what is `dynamic_cast` and what does it do.

00:25:30,560 --> 00:25:34,600
Are there any questions about anything at this point?

00:25:36,800 --> 00:25:39,400
So what should `dynamic_cast` do?

00:25:39,500 --> 00:25:43,900
Let's say I have this little function `test()`. All this does is,

00:25:43,900 --> 00:25:49,520
it takes a pointer to an `Animal` and it says, "I would like that Cat, please!"

00:25:52,620 --> 00:25:54,620
It takes a pointer to an Animal.

00:25:55,400 --> 00:26:02,580
So I'm at the pet shop here, and I point to this [leftmost] Animal, and I say "I would like this Cat, please"...

00:26:02,580 --> 00:26:07,760
and the pet store owner says "Okay. Here. Have this Cat." Easy.

00:26:07,760 --> 00:26:10,020
Because this Cat is this Animal.

00:26:10,020 --> 00:26:13,520
I point to this Animal [the subobject of Dog] and I say, "I would like this Cat, please"...

00:26:13,580 --> 00:26:17,160
Now there's a problem, because this is not actually a Cat.

00:26:17,160 --> 00:26:21,260
And so what `dynamic_cast<Cat*>` is going to do in this case is it's going to give you back `nullptr`.

00:26:21,300 --> 00:26:29,520
If I tried to cast it with `dynamic_cast<Cat&>(animal)`, it would throw `std::bad_cast`.

00:26:29,520 --> 00:26:37,040
I'm gonna stick with casting pointers here because pointers are nice, and I can just say "this gives you null."

00:26:37,040 --> 00:26:40,480
And we can implement one behavior in terms of the other easily enough.

00:26:41,020 --> 00:26:47,980
Okay, so I have a pointer to this Animal, I say "give me this Cat," and it gives me null. Because this Animal is not a Cat.

00:26:47,980 --> 00:26:51,580
Now I have a pointer to this [next] Animal, and I say, "Give me this Cat."

00:26:51,840 --> 00:26:56,560
Now in this case this Animal is a base subobject of a HappyCatDog, which is a Cat.

00:26:56,760 --> 00:27:03,760
Besides which, this Animal is a base subobject of a Cat; so it says, "Sure. Here. Have this Cat." It gives me a pointer to this Cat.

00:27:04,460 --> 00:27:09,220
Let's go over here. Now I have a pointer to this Animal, and I say, "Give me this Cat." — Everyone sees my mouse pointer, I hope.

00:27:09,740 --> 00:27:14,160
I say "give me this Cat." This Animal is the base of a Cat. "Here you go, have a Cat."

00:27:14,520 --> 00:27:21,240
Now we get to a more interesting case. I point to THIS Animal and I say, "Mommy, I would like this Cat."

00:27:21,240 --> 00:27:23,920
I am clearly pointing to something that is a Dog.

00:27:24,000 --> 00:27:29,400
But this Dog is part of a CatDog... and the CatDog is a Cat...

00:27:29,400 --> 00:27:31,140
Now, a CatDog [an AngryCatDog] is not an Animal.

00:27:31,140 --> 00:27:34,420
I'm pointing to this Animal, and saying "give me this Cat,"

00:27:34,420 --> 00:27:40,760
and the Animal I'm pointing to is not a subobject of a Cat... and in fact the most derived object is not even an Animal!

00:27:40,760 --> 00:27:43,459
I'm pointing to the Animal, but it's not an Animal.

00:27:44,120 --> 00:27:47,000
And I'm saying, "Give me this Cat."

00:27:47,240 --> 00:27:51,380
And it says "Okay," and it gives me this Cat.

00:27:52,040 --> 00:27:56,140
Because I'm definitely pointing to an Animal, right? and—

00:27:56,420 --> 00:27:59,600
there's only one Cat I could be talking about.

00:27:59,880 --> 00:28:05,740
So `dynamic_cast` is defined in such a way that it will say "Okay."

00:28:05,740 --> 00:28:09,780
It tries to make me happy. "I will give you this Cat," it says.

00:28:10,160 --> 00:28:14,960
All right, now I point to this Animal and I say give me this Cat. Now there's a problem.

00:28:14,960 --> 00:28:19,920
Now this Animal is a base of two different Cats, and so it's not going to give me a Cat.

00:28:19,920 --> 00:28:25,140
It says... just like before, where we saw the AngryCatDog was not an Animal,

00:28:25,140 --> 00:28:30,020
Now we have an Animal which is not a Cat. It's two Cats.

00:28:30,740 --> 00:28:33,640
I know that's not what a Siamese cat is.

00:28:33,640 --> 00:28:35,640
[LAUGHTER]

00:28:41,360 --> 00:28:43,280
So, ambiguous bases. Right.

00:28:43,280 --> 00:28:48,420
We have an Animal here which is two different Cats, and I don't know which Cat I want. It's ambiguous.

00:28:48,420 --> 00:28:50,020
Oh. Question.

00:28:50,020 --> 00:28:54,060
[AUDIENCE] In the first graph, if you `dynamic_cast` that Animal to Cat, will the pointer value change?

00:28:55,340 --> 00:29:00,640
[ARTHUR] If I `dynamic_cast` this Animal to Cat, will the pointer value change — in the sense of does it point to a different memory address.

00:29:00,640 --> 00:29:07,080
Well, it depends on how `Cat` is defined. Given how we've been defining `Cat`, no. A `Cat` physically is an `Animal`— or, no, I'm sorry —

00:29:07,080 --> 00:29:12,680
this is a virtual base, so I believe it will? But don't quote me on that. Just go try it.

00:29:12,680 --> 00:29:14,280
Question.

00:29:14,280 --> 00:29:19,840
[INAUDIBLE FROM AUDIENCE]

00:29:19,840 --> 00:29:21,840
Then we would have the AngryCatDog.

00:29:21,840 --> 00:29:23,860
[INAUDIBLE FROM AUDIENCE]

00:29:23,960 --> 00:29:26,080
Oh. This would be a Cat in the Cat. Yeah. Okay.

00:29:26,880 --> 00:29:31,140
And we pointed at this Animal, we said give me a Cat, it would give me this Cat— oh, repeat the question. Right.

00:29:31,140 --> 00:29:36,200
If this Animal were not virtual, and so there were Animal/Animal, on both sides here,

00:29:36,200 --> 00:29:40,580
this Animal, the left Animal, would be the left Cat and the right Animal would be the right Cat.

00:29:40,680 --> 00:29:46,020
It's again unambiguous — I'm pointing to an Animal, it definitely IS that Cat, `dynamic_cast` will try to make me happy.

00:29:47,320 --> 00:29:49,000
All right.

00:29:49,320 --> 00:30:00,220
So this problem is actually analogous to a problem we face in the other dynamic run-time-type-info-based thing that we do in C++,

00:30:00,260 --> 00:30:03,280
Which is try/catch.

00:30:03,280 --> 00:30:10,140
Right? If I throw a SiameseCat and I try to catch it as a Cat — is a SiameseCat a Cat?

00:30:10,140 --> 00:30:12,680
No! It's two Cats.

00:30:12,860 --> 00:30:16,940
So this will actually not hit that first `catch` handler,

00:30:17,160 --> 00:30:22,580
But it will hit the second one, because the SiameseCat is a single Animal.

00:30:26,640 --> 00:30:30,020
So this raises one more question. What about this case?

00:30:30,020 --> 00:30:34,620
So here I have a pointer to the right Cat. As type `RightCat`.

00:30:34,620 --> 00:30:39,120
And I say, "I would like this Cat, please." Which Cat do I mean?

00:30:39,260 --> 00:30:41,800
Now in this case the answer is,

00:30:41,940 --> 00:30:49,940
There IS a specific Cat that is more like this RightCat than the other one. So yes. We do the right thing here. `dynamic_cast` tries to make us happy.

00:30:50,520 --> 00:30:54,500
And also! Yes, my slide corrects me here.

00:30:54,500 --> 00:31:00,660
This is not really a truly dynamic cast. In this case `RightCat` actually inherits from `Cat`.

00:31:00,660 --> 00:31:02,880
So not only is the RightCat a Cat,

00:31:02,880 --> 00:31:06,280
But the compiler knows at compile time that the RightCat is a Cat.

00:31:06,280 --> 00:31:10,660
And when you point to a RightCat and you say you want the Cat, you obviously want the Cat that's a base subobject of that.

00:31:10,660 --> 00:31:14,260
And the compiler can compute that! It actually turns into a `static_cast`.

00:31:14,360 --> 00:31:19,500
As long as it's an accessible and unambiguous base class of RightCat.

00:31:21,260 --> 00:31:27,440
And if it's an inaccessible base class — you're trying to cast to a private base class and you're not a friend —

00:31:27,840 --> 00:31:31,560
Then the `dynamic_cast` is ill-formed and you get a compile-time error.

00:31:31,760 --> 00:31:34,240
So this is not a truly dynamic cast.

00:31:34,240 --> 00:31:39,540
And we're going to distinguish now between things that the compiler can figure out on its own

00:31:39,540 --> 00:31:43,280
and things that really have to be done truly dynamically at runtime.

00:31:43,520 --> 00:31:45,520
All right. `dynamic_cast`!

00:31:45,540 --> 00:31:49,260
Per the Itanium spec, there are three truly dynamic casts.

00:31:49,280 --> 00:31:52,280
First, `dynamic_cast` to the most derived class.

00:31:52,280 --> 00:31:56,000
So I can actually get a pointer — a void pointer — to the most derived class.

00:31:56,000 --> 00:32:03,320
It has to be `void*` because I don't know what the most derived class is, by definition, so it can't be `ThatType*`.

00:32:03,320 --> 00:32:06,840
It has to be a pointer that can point to anything, so it's going to be a `void*`.

00:32:06,840 --> 00:32:11,300
To the most derived class. And that's illustrated over there on the left: "to Most Derived Object [MDO]."

00:32:12,360 --> 00:32:16,660
Second, `dynamic_cast` across the hierarchy, from `Cat` to `Dog`, to a sibling base.

00:32:16,660 --> 00:32:20,800
Or third, `dynamic_cast` from a base to derived.

00:32:20,800 --> 00:32:27,500
Now, going the other way, from derived to base — from Cat to Animal — that's a `static_cast`. That's not truly dynamic.

00:32:27,500 --> 00:32:31,660
You can express it with a `dynamic_cast`, but it will just happen at compile time.

00:32:32,220 --> 00:32:39,700
But we need a fourth one as well. And ironically the fourth one IS cast to base. But dynamically.

00:32:39,900 --> 00:32:47,520
So if I have a pointer to the most derived object, such as I got from `dynamic_cast<void*>`,

00:32:48,360 --> 00:32:52,100
And I have a pointer to the most derived object, and I want to know

00:32:52,440 --> 00:32:59,100
Is a SiameseCat a Cat? Is a SiameseCat a RightCat? — for the purposes of catching.

00:32:59,100 --> 00:33:07,260
Then I actually need to dynamically cast to a base where I have an object that I don't know — statically — I don't know what it is.

00:33:07,260 --> 00:33:11,760
but dynamically I have a pointer to it — I have its address, that is —

00:33:11,760 --> 00:33:17,320
and I want to know if that is a `Dog`. So that's the FOURTH truly dynamic cast.

00:33:19,440 --> 00:33:22,640
So let's implement `dynamic_cast` to most derived class.

00:33:22,640 --> 00:33:24,500
Now, don't do this at home.

00:33:24,500 --> 00:33:26,860
Or, do this ONLY at home. Don't do this at work.

00:33:30,020 --> 00:33:37,540
`dynamic_cast` to `void*`. That's literally just, "find me the address of the most derived object."

00:33:37,540 --> 00:33:44,500
And the address of the most derived object is just the MDO offset — the -16 there — plus the `this` pointer.

00:33:44,500 --> 00:33:49,860
So just load up my vptr and grab that offset and add it, and I'm done.

00:33:50,360 --> 00:33:58,060
That's like two instructions; every major compiler does inline it; they generate optimal inline code; great. Awesome.

00:33:58,700 --> 00:34:00,320
`dynamic_cast` to sibling base.

00:34:00,340 --> 00:34:04,740
In this case, we have a `Cat&` and we're trying to convert it to a `Dog&`. Or we have a `Cat*`, trying to convert it to a `Dog*`.

00:34:04,740 --> 00:34:08,580
The compiler already knows statically that `Cat` and `Dog` are unrelated.

00:34:08,720 --> 00:34:09,960
Why?

00:34:10,260 --> 00:34:17,760
Because if `Cat` inherited from `Dog`, then this would be a `static_cast` that wouldn't be truly dynamic, and I wouldn't be trying to do it.

00:34:17,760 --> 00:34:24,060
And if `Dog` inherited from `Cat`, this would be the downcast that we're going to look at next.

00:34:24,060 --> 00:34:27,740
So in this case we know that they're not related. Not all Cats are Dogs, not all Dogs are Cats.

00:34:27,740 --> 00:34:32,000
The only way for this `dynamic_cast` to succeed is if some Dogs are Cats.

00:34:32,000 --> 00:34:36,660
If someone has made a `CatDog` by inheriting from both of them.

00:34:37,300 --> 00:34:44,520
So what this means is that if either of these classes is `final`,

00:34:44,520 --> 00:34:48,320
then this `dynamic_cast` MUST fail. It must give us `nullptr`.

00:34:48,320 --> 00:34:52,060
The compiler knows this statically. It knows whether these two are `final`.

00:34:52,840 --> 00:34:56,600
And so it should give us optimal codegen. But it doesn't.

00:34:56,660 --> 00:35:02,960
Clang will optimize if the source is `final` but not if the destination is `final`; and none of the other major compilers do it.

00:35:03,800 --> 00:35:07,580
Here's how we do it, assuming they're not `final`. There might be a `CatDog`.

00:35:07,580 --> 00:35:13,660
And this might be a `CatDog`. In that case what we do is we cast to the most derived class...

00:35:13,880 --> 00:35:21,260
and we ask for its `typeid` — that's just in its vtable — and if that's still the `typeid` of Cat, then we haven't changed it.

00:35:21,260 --> 00:35:24,260
And we can just fail. This actually was "just a Cat."

00:35:24,440 --> 00:35:29,800
Otherwise, it's something else. It's something that someone else has Frankensteined together, and it might contain a `Dog`.

00:35:29,800 --> 00:35:35,020
So in that case, I have a thing that I don't know what it is — but I have a pointer to it —

00:35:35,020 --> 00:35:38,520
— and it might be a `Dog`, and I would like to find out if it is.

00:35:38,520 --> 00:35:44,440
This is exactly the case that we have when we `catch` an object of polymorphic type,

00:35:44,540 --> 00:35:50,000
and we want to know should this `catch` handler apply. "Is this thing a Dog? Should it be caught as a Dog?"

00:35:50,000 --> 00:35:59,860
So in that case we want to use our "cast to base"... which we're going to write. But that's exactly the same operation we would do in a catch handler.

00:35:59,860 --> 00:36:02,980
So let's do that "cast to base."

00:36:03,340 --> 00:36:07,880
This is where I diverge from the Itanium ABI.

00:36:08,600 --> 00:36:16,020
I say, "I just want to solve the problem at hand." Which is, I have a pointer to a thing, and I have its vptr.

00:36:16,020 --> 00:36:23,460
I have its vtable. I have its `typeid` in its vtable. I have some `type_info` about it. I have its RTTI, basically.

00:36:23,460 --> 00:36:26,500
And I would like to know if it is a Dog.

00:36:27,040 --> 00:36:34,600
So, I could just write a function that tells me if this thing is a Dog; and just put a pointer to it in the RTTI.

00:36:34,600 --> 00:36:40,220
In the run-time type info. In the vtable somewhere.

00:36:40,580 --> 00:36:44,780
And it would look something like this.

00:36:44,780 --> 00:36:51,320
This is just sort of a list, for each class, of its bases,

00:36:52,400 --> 00:37:00,340
Where if you name one of its bases — one of its public, unambiguous bases —

00:37:00,340 --> 00:37:02,740
it just gives you a pointer to that base.

00:37:02,740 --> 00:37:06,000
"Ask me for a base, and I will give it to you, if I know about it."

00:37:06,000 --> 00:37:10,800
"And if I don't know about it then it's not a base of me — and so I'll give you nullptr."

00:37:10,800 --> 00:37:18,420
This coincidentally is exactly the behavior I want from `dynamic_cast`. This is also exactly the behavior I want from `catch`.

00:37:22,000 --> 00:37:28,900
This is a HappyCatDog, so it has one Animal subobject,

00:37:28,900 --> 00:37:35,100
so if you ask the HappyCatDog for its Animal base, it will give you its Animal base because it IS-AN Animal.

00:37:35,100 --> 00:37:42,160
The AngryCatDog, with non-virtual inheritance, has two Animal subobjects, so the AngryCatDog is not an Animal;

00:37:42,160 --> 00:37:48,860
and if you ask it for its Animal subobject, it doesn't know about it. It's going to give you `nullptr` in that case.

00:37:50,360 --> 00:37:52,760
All right, so let's do a quick example here...

00:37:53,200 --> 00:38:01,300
Here I have a function `test()`; it takes an `Animal*`; it tries to convert it to a `Dog*` dynamically.

00:38:01,300 --> 00:38:06,200
So I have a pointer to an `Animal`. This is inside a `CatDog`, by the way, as it happens. I don't know that yet.

00:38:06,200 --> 00:38:11,660
All I see is, I see a pointer to this Animal object.

00:38:11,660 --> 00:38:13,640
But it's polymorphic so it has a vptr.

00:38:13,640 --> 00:38:17,980
and I'm trying to `dynamic_cast` it. So step 1, so I get the vptr.

00:38:18,560 --> 00:38:24,760
I go over there, and I get the `offset` to the most derived object. "-40". Cool.

00:38:24,760 --> 00:38:29,060
Now I take my original Animal `this` pointer, and I subtract 40, and I go up there.

00:38:29,080 --> 00:38:33,300
Now I have the address of the vptr of the most derived object.

00:38:33,300 --> 00:38:39,700
I no longer have any idea what the type of that is. I know it's the most derived type...

00:38:39,700 --> 00:38:44,520
which has somewhere within it an Animal subobject; and that's all I know about it.

00:38:44,520 --> 00:38:46,580
But I know this is a vptr, so I'm gonna follow it.

00:38:46,580 --> 00:38:53,820
It's a vptr for some polymorphic type, so I know that I can get its `type_info` — its `typeid` — from a known offset.

00:38:53,840 --> 00:38:57,520
Or in this case let's just pretend that the function pointer is in the vtable.

00:38:57,640 --> 00:39:06,820
And I call that function with the pointer to that highlighted address,

00:39:06,820 --> 00:39:14,880
the beginning of the most derived object, and I call it with the `typeid` of `Dog`, which is what I'm looking for...

00:39:14,880 --> 00:39:20,880
and I just trust that it will tell me if this thing has a `Dog` subobject. If it doesn't, that's also nice to know.

00:39:20,880 --> 00:39:23,460
And in this case, hooray, I get it.

00:39:24,520 --> 00:39:28,300
But actually this is not how either Itanium or MSVC do it!

00:39:28,300 --> 00:39:37,020
They don't just write this little function. They actually generate data — read-only data — that represents the entire class hierarchy,

00:39:37,020 --> 00:39:41,260
and when they want to know if one thing is another thing, they will do a graph algorithm.

00:39:41,260 --> 00:39:44,739
They will do some Dijkstra's algorithm and stuff to try to figure out if there's a path from A to B

00:39:44,740 --> 00:39:47,720
And they get it wrong. And there are bugs.

00:39:47,720 --> 00:39:51,600
You won't run into those bugs in practice, but I will file those bugs.

00:39:52,380 --> 00:39:54,160
Is there a question?

00:39:55,900 --> 00:39:59,000
[INAUDIBLE FROM AUDIENCE]

00:39:59,520 --> 00:40:04,460
[APPLAUSE FROM TONY'S SESSION NEXT DOOR]

00:40:09,260 --> 00:40:15,140
[CONTINUED INAUDIBLE FROM AUDIENCE]

00:40:17,860 --> 00:40:19,860
[ARTHUR] Yes... from base to derived...

00:40:27,730 --> 00:40:29,840
To most derived.

00:40:29,840 --> 00:40:36,020
The first case is going to the most derived object. `dynamic_cast` to `void*`? That's the easy case.

00:40:36,020 --> 00:40:41,340
Yeah. And then what we're doing to go to sibling, is, we're actually simplifying that into,

00:40:41,340 --> 00:40:50,720
first go to the most derived object, and then ask whether that object — whose dynamic type I don't know — ask it whether it can be this type, and if so, get that pointer.

00:40:50,720 --> 00:40:53,760
[AUDIENCE] How do you know you're going to the most derived object? You don't know beforehand—

00:40:53,760 --> 00:41:02,040
[ARTHUR] We know that we're going to the most derived object because we know every object of polymorphic type HAS a most derived object —

00:41:02,040 --> 00:41:04,000
But we don't know WHAT it is —

00:41:04,000 --> 00:41:10,760
But the fact that it HAS one means that we can put WHERE it is in its vtable, at a known offset. Which is what we do.

00:41:10,760 --> 00:41:13,820
And that is actually what Itanium does as well.

00:41:14,540 --> 00:41:19,640
[INAUDIBLE FROM AUDIENCE]

00:41:21,240 --> 00:41:27,820
You CAN know statically that the `dynamic_cast` wants the most derived object,

00:41:27,820 --> 00:41:32,040
because the user told you that that's what they want. They say, `dynamic_cast<void*>`.

00:41:32,040 --> 00:41:35,840
Or they say `dynamic_cast` to some sibling base, which is unrelated,

00:41:35,860 --> 00:41:40,440
in which case how we do that is, first we cast to `void*` and then we ask that object for...

00:41:40,440 --> 00:41:42,440
Yep.

00:41:42,680 --> 00:41:49,160
[NEW QUESTION FROM AUDIENCE, ABOUT FINAL CLASSES IN CLANG]

00:41:51,040 --> 00:41:58,240
It's a missing optimization. But it's one fewer missing optimization than GCC, MSVC, or ICC.

00:41:59,260 --> 00:42:04,500
And one of these days they'll fix it. It's like a one-line change. They could fix it.

00:42:06,780 --> 00:42:13,520
All right. Quick digression on "accessible" versus "public," because I've been using both of those terms here.

00:42:15,000 --> 00:42:21,400
Here I have a `Sponge`. A Sponge IS-AN Animal. But it's not widely known that a Sponge IS-AN Animal.

00:42:21,400 --> 00:42:23,400
[LAUGHTER]

00:42:24,020 --> 00:42:29,120
So if I'm in a context that knows about sponges... is a `friend` of sponges...

00:42:29,120 --> 00:42:31,480
then static_casting from `Sponge` to `Animal` is okay.

00:42:31,760 --> 00:42:37,220
Right? I point to a Sponge. I say, "I would like this Animal." And it says, "All right, here. Here's the Animal."

00:42:37,220 --> 00:42:40,420
Now if I'm in a context which is not a friend of sponges,

00:42:40,420 --> 00:42:45,420
And I say — I point to a Sponge, and say, "I would like this Animal, please,"

00:42:45,420 --> 00:42:50,060
the compiler will say, "That doesn't LOOK like an Animal..."

00:42:50,060 --> 00:42:54,440
And you'll get an error. Because you're trying to `static_cast` to something that looks unrelated.

00:42:54,660 --> 00:43:00,100
So both `static_cast` and `dynamic_cast` from derived to base require that the target base be unambiguous

00:43:00,100 --> 00:43:03,300
and accessible in the current lexical scope.

00:43:03,480 --> 00:43:08,040
And remember, `dynamic_cast` from derived to base is really just a `static_cast` in disguise.

00:43:08,100 --> 00:43:13,600
So it has the same requirements as `static_cast`.

00:43:13,800 --> 00:43:17,060
But now let's try throw/catch.

00:43:17,060 --> 00:43:19,940
Which again goes from derived to base, right?

00:43:19,940 --> 00:43:23,260
I throw a `Sponge` and I try to catch an `Animal`.

00:43:23,260 --> 00:43:25,760
"Here comes the Sponge! Catch that Animal!"

00:43:25,760 --> 00:43:28,260
It doesn't LOOK like an Animal...

00:43:28,300 --> 00:43:34,740
And now lexical scope doesn't matter. Because at runtime there is no such thing as lexical scope.

00:43:34,940 --> 00:43:40,800
If I'm at runtime, and all my lexical scopes are gone — all I have is machine code and library functions,

00:43:40,800 --> 00:43:44,180
and they don't really understand the concept of scope...

00:43:44,180 --> 00:43:47,400
"Here comes a Sponge! Catch that Animal!"

00:43:47,400 --> 00:43:51,600
It would be wrong to catch it...

00:43:51,600 --> 00:43:57,560
because that would imply knowledge of the Sponge-Animal relationship, which not everyone has.

00:43:57,560 --> 00:44:02,780
And so all of these operations in the C++ Standard are defined

00:44:02,780 --> 00:44:08,540
so that runtime knows nothing. Runtime is not your `friend`. Runtime is nobody's `friend`.

00:44:09,480 --> 00:44:14,620
I throw the Sponge, I attempt to catch an Animal, it doesn't look like an Animal, I don't catch it.

00:44:14,620 --> 00:44:17,520
It doesn't matter where I am lexically.

00:44:17,520 --> 00:44:21,300
There's no such thing as lexical scope at runtime.

00:44:22,140 --> 00:44:27,480
So that's why castToBase here, which is used by `catch` and which is also used by `dynamic_cast` to a sibling base,

00:44:27,480 --> 00:44:33,220
requires that the target base be unambiguous and public. Not just accessible, but public.

00:44:33,220 --> 00:44:36,620
Because there is no such thing as lexical scope at runtime.

00:44:36,900 --> 00:44:43,800
All right, we are now down to the last case, which is casting from base to derived.

00:44:43,800 --> 00:44:49,320
I have a pointer to an Animal and I would like that Cat, please.

00:44:49,320 --> 00:44:54,040
So again, I don't know statically — if I have an `Animal*`, I don't know that it is a `Cat`.

00:44:54,040 --> 00:44:58,380
So I have to do something at runtime to find out if it's a Cat.

00:44:58,380 --> 00:45:02,860
And now I can't use that same trick.

00:45:02,860 --> 00:45:06,480
One reason I can't use that same trick is the `SiameseCat` issue.

00:45:06,480 --> 00:45:09,620
The other reason is that...

00:45:10,470 --> 00:45:15,649
I might have, let's say, a coral reef. Which in this example IS-A `Fish` and IS-A `Sponge`.

00:45:15,649 --> 00:45:20,020
This is horrible... this is not Liskov-substitutable at all...

00:45:20,020 --> 00:45:22,600
Please, again, don't try this at work.

00:45:22,600 --> 00:45:27,160
But let's say a `Reef` has a `Fish` and a `Sponge`. IS-A `Fish` and a `Sponge`.

00:45:27,160 --> 00:45:32,940
And a Fish IS-AN Animal. And a Sponge IS-AN Animal but hardly anybody knows it.

00:45:32,940 --> 00:45:38,700
And now I point to this Animal [the subobject of Fish]...

00:45:38,700 --> 00:45:46,260
and I say, "I would like this Sponge, please."

00:45:46,260 --> 00:45:48,820
This cast works.

00:45:48,820 --> 00:45:52,580
Because this Animal is a Reef...

00:45:52,580 --> 00:45:56,980
and a Reef IS-A Sponge... and there's only one Sponge I could possibly be talking about...

00:45:57,000 --> 00:45:59,280
Everybody knows it...

00:45:59,280 --> 00:46:00,640
We get that `Sponge`.

00:46:00,640 --> 00:46:05,720
But if I point to this Animal, the right-hand Animal that is actually a subobject of Sponge,

00:46:05,720 --> 00:46:08,640
and I say "I would like this Sponge,"

00:46:10,160 --> 00:46:14,800
That actually doesn't work. That will give me `nullptr`.

00:46:14,840 --> 00:46:26,100
Because that would require the runtime to admit that this Animal is a Sponge... this is the Animal subobject of a Sponge...

00:46:26,100 --> 00:46:32,540
but you're not supposed to know that a Sponge has an Animal subobject at all!

00:46:32,540 --> 00:46:40,680
So actually the cast from the left-hand Animal to Sponge works, and the cast from the right-hand Animal to Sponge actually doesn't work.

00:46:41,160 --> 00:46:45,320
Because there's no lexical scopes, because runtime is not your friend.

00:46:46,160 --> 00:46:47,419
All right.

00:46:47,420 --> 00:46:52,460
So how are we actually going to do this? This now gets tricky, right? because we can't use our trick anymore. I'm gonna point that out.

00:46:52,460 --> 00:46:59,460
We can't just say I will go to the most derived object (which is `Reef`) and then I will ask it for its public base `Sponge`.

00:46:59,460 --> 00:47:04,340
That would actually always give us `Sponge` in this case, and that's not what `dynamic_cast` wants to do.

00:47:04,340 --> 00:47:07,400
So we can't implement `dynamic_cast` that way.

00:47:07,400 --> 00:47:13,100
We have to have a new trick to make one of these casts work and the other one not work.

00:47:13,100 --> 00:47:20,020
So here's what we're going to do. We're going to find the most derived object, and then at this point we're going to ask it two questions.

00:47:20,040 --> 00:47:30,460
We're going to ask it, "Is that Animal subobject that we started with a public base of a Sponge subobject, whether you're supposed to know about it or not?"

00:47:30,460 --> 00:47:33,440
And it can tell us that. And otherwise,

00:47:33,440 --> 00:47:37,380
"Is that Animal subobject that we started with a public base of yourself?"

00:47:37,380 --> 00:47:44,960
If so, then it's okay to give me your public `Sponge` subobject.

00:47:45,280 --> 00:47:47,720
And here's code for that.

00:47:50,340 --> 00:47:51,860
All right.

00:47:51,860 --> 00:47:54,440
And now I've explained that. I'm going a little bit fast here because I saw we only have ten minutes...

00:47:54,440 --> 00:47:59,620
but suddenly I have fewer slides than I thought, so, we'll go back to that slide for me to ask, are there any questions?

00:48:00,880 --> 00:48:06,380
[INAUDIBLE FROM AUDIENCE]

00:48:07,680 --> 00:48:09,680
Right.

00:48:21,340 --> 00:48:27,340
When I'm going from an `Animal` to a `Cat` in a `SiameseCat`, how do I know which `Cat` to go to?

00:48:27,340 --> 00:48:33,180
Because, if that `Animal` that I started with is a public base of a `Cat` subobject,

00:48:33,180 --> 00:48:39,180
the most derived object will know that statically, when we do the struct layout of the most derived object,

00:48:39,180 --> 00:48:45,020
and so it will be able to answer this question in the affirmative and say, "Yes. I can see—"

00:48:45,080 --> 00:48:49,380
"I can see you're pointing to the left Animal, so you want the left Cat. I can see you're pointing to the right Animal, you want the right Cat."

00:48:49,380 --> 00:48:51,920
It knows that.

00:48:53,440 --> 00:49:00,280
That function will know the full graph layout of the most derived object because it is generated as part of the RTTI of that most derived type

00:49:00,280 --> 00:49:05,800
at the time we're doing the struct layout for the most derived type.

00:49:06,100 --> 00:49:12,540
It knows everything about the struct layout. Yes. It knows everything about the struct layout of that type.

00:49:12,780 --> 00:49:16,600
Because it's generated as the RTTI for that type.

00:49:17,160 --> 00:49:23,380
So here's a possible implementation. Again, this is not what Itanium or Visual Studio do.

00:49:23,380 --> 00:49:30,860
They actually do a whole graph. They depth-first search this graph. It is slow. It is buggy. Graph algorithms are hard.

00:49:30,860 --> 00:49:37,180
And when you try to do them efficiently, they get harder; and ironically, you make more bugs.

00:49:37,800 --> 00:49:40,920
Let's put everything together and see what we've ended up with.

00:49:40,920 --> 00:49:45,200
So I wrote this template called `dynamicast`.

00:49:45,920 --> 00:49:56,220
And it takes `P`, which here is a pointer type representing what we want to dynamic-cast to,

00:49:56,340 --> 00:50:02,720
and it deduces what we've got as the argument `From`; it deduces `From`,

00:50:03,160 --> 00:50:07,700
and here `To` is the type we're casting to — and yeah, it's just `remove_pointer_t<P>`.

00:50:08,320 --> 00:50:10,380
So here's what `dynamic_cast` should do.

00:50:10,380 --> 00:50:14,600
Number one, if we're casting to the same type, just return the object and we're done.

00:50:14,600 --> 00:50:25,700
Number two, if this is a public— or, sorry, an accessible— an accessible unambiguous base, just cast to that and we're done.

00:50:25,700 --> 00:50:31,000
I'm using a C-style cast, which is sneaky, because that can actually cast to private bases,

00:50:31,000 --> 00:50:37,400
and you can't actually check for accessibility with type traits. So even for private bases, this will just make it work.

00:50:38,100 --> 00:50:45,260
Then, if we're casting to `void*`, that means the user is asking for a pointer to the most derived object and they don't care what it is,

00:50:45,260 --> 00:50:51,540
so I'll just return the most derived object. I'll show code for that on the next slide.

00:50:52,700 --> 00:51:04,440
If we're casting— let's see, we're casting down the hierarchy— from the base to a derived class,

00:51:04,440 --> 00:51:09,820
I've got some code for that — and otherwise we have unrelated sibling classes, and we're casting between them.

00:51:09,820 --> 00:51:14,520
So first of all, here's the non-portable stuff. The stuff that you're not supposed to do at work.

00:51:14,520 --> 00:51:18,920
A truly dynamic cast to the most derived object means...

00:51:19,600 --> 00:51:22,620
take the vptr. Now, this is a pointer to a polymorphic object,

00:51:22,620 --> 00:51:28,680
which means in the Itanium ABI, the thing at that offset, that's going to be a vptr and I can just go grab it.

00:51:28,680 --> 00:51:33,200
That's not true of MSVC. It gets a little bit more complicated. Look at my repo...

00:51:33,200 --> 00:51:37,780
which I hope is linked from one of these slides... to see how it's done on MSVC.

00:51:38,460 --> 00:51:44,720
We go grab the offset to MDO [most derived object] and we add it to our `this` pointer, and we return our `this` pointer.

00:51:44,720 --> 00:51:48,840
That concludes casting to `void*`.

00:51:48,840 --> 00:51:59,220
We also have this function `dynamic_typeid()`. What that does is get the `type_info` of some polymorphic object, whose type, again, I don't know...

00:51:59,220 --> 00:52:04,180
But I know how to go into its vtable and grab that `typeid` out.

00:52:04,180 --> 00:52:06,620
So you can write that. Again, not at work.

00:52:06,620 --> 00:52:12,560
`truly_dynamic_from_base_to_derived()`... I'm gonna skip this, I think, because we're running out of time...

00:52:12,560 --> 00:52:16,080
`truly_dynamic_between_unrelated_classes()`...

00:52:16,680 --> 00:52:21,640
Here's our completed code. It looks the same as the previous code because I skipped the implementations...

00:52:22,630 --> 00:52:24,640
I wanted to get to the benchmark numbers.

00:52:24,640 --> 00:52:26,519
So I wrote this Python script as part of this.

00:52:26,520 --> 00:52:33,360
I was testing this, trying to, you know, make sure I could actually write `dynamic_cast`, and so I needed to write some tests.

00:52:33,360 --> 00:52:36,020
And so I decided the right way to do that was with a fuzzer.

00:52:36,020 --> 00:52:42,520
I highly recommend this if you're doing any kind of operating on something that looks kind of like a language.

00:52:42,520 --> 00:52:45,800
Write yourself a little fuzzer. Write a test case generator.

00:52:45,800 --> 00:52:54,020
So I wrote a test case generator. It would generate ten random classes, starting with `class1`, `class2`, class3`, all of which had no base classes...

00:52:54,020 --> 00:53:00,520
And then it would start putting them together in different ways. "public virtual class1, private virtual class2, public virtual..."

00:53:00,520 --> 00:53:05,440
you know, "private, private, public..." It would put them all together, in various combinations, until it got down to class10,

00:53:05,440 --> 00:53:09,760
And then it would generate all possible dynamic_casts.

00:53:09,760 --> 00:53:14,860
From `class1*` to `class10*`. From `class1*` to `class3*`. From `class3*` to `class5*`.

00:53:14,860 --> 00:53:18,360
It would generate all of them, and then it would run them.

00:53:18,840 --> 00:53:25,140
And it would make sure that the output corresponded to what I got running it through libc++ or libstdc++,

00:53:25,140 --> 00:53:27,880
and that's how I found a bunch of bugs.

00:53:28,760 --> 00:53:33,040
And then as long as I had that test case generator I wrote a benchmark, because why not.

00:53:33,040 --> 00:53:37,660
So the benchmark code looks something like this. This is the link to the github with all of the code

00:53:39,180 --> 00:53:47,030
And I ran my benchmark comparing my `dynamicast`, using the templates and the extremely non-portable Itanium ABI magic that we just saw,

00:53:47,190 --> 00:53:52,730
and I got these numbers out, and I said, "Huh. All right. Well, I didn't do any worse."

00:53:53,880 --> 00:53:58,399
But I really — you know, maybe I'm egotistical, but I really expected to do better.

00:53:59,060 --> 00:54:05,180
I really expected to do better than the default libc++ library implementation that's on my MacBook,

00:54:05,180 --> 00:54:08,340
because this is all templates, it should all get inlined, it should all...

00:54:08,340 --> 00:54:11,320
"Inlined." Right. Right right right.

00:54:11,320 --> 00:54:18,100
`-O3`. Okay! Yes. That other graph — that was `-O0`. This is when you turn on optimizations.

00:54:18,100 --> 00:54:22,540
The green bars here are — basically —

00:54:24,420 --> 00:54:28,360
Left side faster, fewer milliseconds. Right side slower, more milliseconds.

00:54:28,360 --> 00:54:35,040
The units don't matter because this is extremely munged, but, leftward faster, rightward slower.

00:54:37,320 --> 00:54:44,800
The green bars are a histogram of my performance on these randomly generated, extremely non-realistic casts from one type to the other.

00:54:47,180 --> 00:54:52,180
And in red, that's the native `dynamic_cast` on the same data.

00:54:52,180 --> 00:54:57,340
On the top here, pulled out in a separate histogram...

00:54:57,340 --> 00:54:59,760
and a much less interesting histogram,

00:54:59,760 --> 00:55:01,880
That's casting to `void*`.

00:55:01,880 --> 00:55:08,920
And you see that we're exactly the same because compilers do generate inlined perfectly efficient code for casting to `void*`.

00:55:09,320 --> 00:55:14,860
But anything where you're calling the library implementation of `__dynamic_cast`,

00:55:15,140 --> 00:55:18,520
that library routine will NOT get inlined; it can't be.

00:55:18,540 --> 00:55:25,220
It will not get any more optimized based on different things, such as being `final` or not,

00:55:25,220 --> 00:55:29,100
And so it turns out I can do better.

00:55:29,100 --> 00:55:34,940
And then the last slide I have is a slightly more realistic benchmark,

00:55:34,940 --> 00:55:40,560
where I'm only compiling my custom RTTI functions with `-O3` and everything else is `-O0`.

00:55:42,480 --> 00:55:46,920
That's under the assumption that

00:55:46,920 --> 00:55:55,000
–that libc++ would be compiled with `-O3`, and then your code, I can't really control what your code does.

00:55:55,000 --> 00:55:58,180
And there I'm doing just a little bit better. It's not as dramatic.

00:55:59,960 --> 00:56:05,680
That, I think, is the entire talk; and we have like two minutes for questions. Thank you for coming.

00:56:06,020 --> 00:56:12,560
[APPLAUSE]

00:56:14,760 --> 00:56:16,180
Back there.

00:56:16,180 --> 00:56:22,560
[AUDIENCE] I'm just curious, did you look at the size of the generated binary? It seems like maybe with your approach,

00:56:22,560 --> 00:56:30,300
generating all these functions to hardcode the answers, basically, maybe there's a space versus speed tradeoff.

00:56:30,300 --> 00:56:38,920
So the question is, how does the size of these generated functions compare to the size in data of the RTTI data.

00:56:39,060 --> 00:56:43,280
And the answer is, I don't know, I didn't look at that.

00:56:43,280 --> 00:56:47,660
I would expect them to be roughly comparable. Notice that most of these functions — vast majority of these functions —

00:56:47,660 --> 00:56:54,220
are just `return nullptr`, which is like three bytes on x86, so.

00:56:54,220 --> 00:57:00,940
[ASKING IF THE BENCHMARK IS UNREALISTIC]

00:57:00,960 --> 00:57:01,980
Yes.

00:57:01,980 --> 00:57:04,760
[ASKING IF ARTHUR HAS REALISTIC NUMBERS]

00:57:04,760 --> 00:57:06,400
No.

00:57:08,540 --> 00:57:16,940
But if you have a realistic class hierarchy and you would like to try this out, I would be very interested to know realistic numbers.

00:57:18,100 --> 00:57:36,180
[INAUDIBLE]

00:57:36,180 --> 00:57:42,220
[INAUDIBLE, SOMETHING ABOUT DLLS]

00:57:42,220 --> 00:57:59,140
[INAUDIBLE]

00:57:59,140 --> 00:58:07,380
The observation was that on some platforms `dynamic_cast` can actually do string comparisons instead of pointer comparisons.

00:58:07,380 --> 00:58:11,460
Like in this slide where I've got— I didn't really do this slide, but the underlined things here

00:58:11,460 --> 00:58:16,400
It says like `ti == _To_`, and that's the typeid of the `To` type.

00:58:16,400 --> 00:58:22,700
And that comparison could be a string comparison on some platforms.

00:58:22,700 --> 00:58:26,980
In general— I think in the old days it actually used to be a string comparison more often.

00:58:27,060 --> 00:58:30,960
These days they will at least try to compare the addresses first,

00:58:30,960 --> 00:58:34,280
and only then fall back to string comparison.

00:58:34,280 --> 00:58:40,580
So I don't think that they would do the string comparisons in this case. You would still be paying for that extra branch, maybe.

00:58:41,460 --> 00:58:42,580
But yes.

00:58:42,580 --> 00:58:47,960

YouTube URL: https://www.youtube.com/watch?v=QzJL-8WbpuU


