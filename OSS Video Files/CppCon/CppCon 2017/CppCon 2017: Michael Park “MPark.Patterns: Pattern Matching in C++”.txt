Title: CppCon 2017: Michael Park “MPark.Patterns: Pattern Matching in C++”
Publication date: 2017-10-13
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Pattern matching brings a declarative approach to destructuring and inspecting complex data types. It’s a very powerful abstraction provided by many programming languages such as Haskell and OCaml, and more recently, Rust, Scala, and Swift. 

We’ll see a glimpse of pattern matching in C++17 and their current limitations through features such as structured bindings, `apply`, and `visit`. We’ll then jump into MPark.Patterns, an experimental pattern matching library for C++. The following is an example of `fizzbuzz` written with the library: 

void fizzbuzz() { 
   for (int i = 1; i ＜= 100; ++i) { 
    using namespace mpark::patterns; 
    match(i % 3, i % 5)( 
      pattern(0, 0) = [] { std::cout ＜＜ "fizzbuzz\n"; }, 
      pattern(0, _) = [] { std::cout ＜＜ "fizz\n"; }, 
      pattern(_, 0) = [] { std::cout ＜＜ "buzz\n"; }, 
      pattern(_, _) = [i] { std::cout ＜＜ i ＜＜ '\n'; }); 
  } 
} 

We’ll see many more examples like this that lead to simpler, declarative code that focuses on the desired shape/state of the data, rather than a sequence of imperative code that tries to inspect the data in piecemeal. 

The goal of the library, and the talk is to gain experience and exposure to pattern matching in order to potentially help guide the design of a language-based pattern matching mechanism.
— 
Michael Park: Mesosphere, Software Engineer

I’m a committer for the Apache Mesos project, and work as a Distributed Systems Engineer at Mesosphere. Within the realm of computer science, I’m very much intrigued by language design, compiler construction, and distributed systems. I’m also an active member of the ISO C++ Standards Committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,589
all right thank you everyone thank you

00:00:02,040 --> 00:00:07,020
everyone for coming this is a park

00:00:04,589 --> 00:00:08,460
patterns pattern matching in c++ this is

00:00:07,020 --> 00:00:11,460
gonna be a talk about a library that I

00:00:08,460 --> 00:00:14,759
wrote in sequence was seventeen to try

00:00:11,460 --> 00:00:16,619
to support pattern matching well we'll

00:00:14,759 --> 00:00:18,960
go through a lot of the intricacies of

00:00:16,619 --> 00:00:21,270
it today so my name is Michael Park

00:00:18,960 --> 00:00:23,580
perhaps made better known as M park to

00:00:21,270 --> 00:00:25,400
the community I'm currently a software

00:00:23,580 --> 00:00:27,900
engineer at a company called mesosphere

00:00:25,400 --> 00:00:29,460
where I'm building out the visions to

00:00:27,900 --> 00:00:31,800
see what it would look like to have an

00:00:29,460 --> 00:00:33,390
operating system in a datacenter I'm

00:00:31,800 --> 00:00:35,340
also a member of the statistical

00:00:33,390 --> 00:00:37,469
Standards Committee and I'm also the

00:00:35,340 --> 00:00:41,550
author of the standard variant

00:00:37,469 --> 00:00:43,410
implementation for loops equals plus so

00:00:41,550 --> 00:00:45,930
to set the stage for the talk I'm gonna

00:00:43,410 --> 00:00:50,070
cover a brief history of how pattern

00:00:45,930 --> 00:00:51,390
matching has gone through history over

00:00:50,070 --> 00:00:54,750
time for in different programming

00:00:51,390 --> 00:00:57,600
languages so finally started all the way

00:00:54,750 --> 00:01:00,000
back in 1960s originally with snowball

00:00:57,600 --> 00:01:02,250
and it provided a language level support

00:01:00,000 --> 00:01:05,159
for pattern matching on strings now

00:01:02,250 --> 00:01:06,689
snowball was a text-based text and

00:01:05,159 --> 00:01:09,619
symbol based programming language and so

00:01:06,689 --> 00:01:12,180
this made a lot of sense for them in

00:01:09,619 --> 00:01:14,970
1987 Perl came along and he bawled that

00:01:12,180 --> 00:01:18,150
idea and they basically introduced by

00:01:14,970 --> 00:01:20,700
far the most popular and well-known well

00:01:18,150 --> 00:01:22,740
who stood former parametric today and we

00:01:20,700 --> 00:01:26,700
all know we all know that technique as

00:01:22,740 --> 00:01:28,590
regular expressions so ml took that idea

00:01:26,700 --> 00:01:30,450
of pattern matching on strings and

00:01:28,590 --> 00:01:34,079
generalized it to more complex data

00:01:30,450 --> 00:01:37,979
types like tuples and variants in the

00:01:34,079 --> 00:01:39,990
1990s Haskell Haskell I know camo were

00:01:37,979 --> 00:01:44,240
introduced with pattern matching support

00:01:39,990 --> 00:01:48,030
I lost my cursor yeah there we go

00:01:44,240 --> 00:01:49,079
sorry so yeah high school okay well

00:01:48,030 --> 00:01:52,979
we're introduced with pattern matching

00:01:49,079 --> 00:01:54,509
support and in fact it's actually the at

00:01:52,979 --> 00:01:56,850
the very core of most functional

00:01:54,509 --> 00:01:58,950
functional programming languages and

00:01:56,850 --> 00:02:00,869
more recently many mainstream languages

00:01:58,950 --> 00:02:02,820
have also adopted the feature the most

00:02:00,869 --> 00:02:03,420
popular ones from my perspective are

00:02:02,820 --> 00:02:06,180
Escala

00:02:03,420 --> 00:02:09,479
rust and swift but other languages like

00:02:06,180 --> 00:02:13,900
C sharp Java have also picked up

00:02:09,479 --> 00:02:15,930
pattern matching as well and for suppose

00:02:13,900 --> 00:02:18,730
there's been two efforts that I know of

00:02:15,930 --> 00:02:20,830
towards introducing pattern matching the

00:02:18,730 --> 00:02:23,890
first one is a paper called open open

00:02:20,830 --> 00:02:27,280
pattern matching for c++ by yuri Gabi

00:02:23,890 --> 00:02:29,349
and Yana which was published in 2013 and

00:02:27,280 --> 00:02:33,010
is shipped with them shipped with a

00:02:29,349 --> 00:02:37,720
library solution called Mach 7 which

00:02:33,010 --> 00:02:39,069
involved a lot of macros in 2015 22

00:02:37,720 --> 00:02:40,959
years ago at this conference

00:02:39,069 --> 00:02:43,959
John banned Oleg introduce simple match

00:02:40,959 --> 00:02:48,459
which was a C+ 14 library solution with

00:02:43,959 --> 00:02:51,549
no macros and that's about it so 35

00:02:48,459 --> 00:02:52,900
years in the C++ almost 35 years we

00:02:51,549 --> 00:02:54,250
still don't have the full extent of what

00:02:52,900 --> 00:02:57,480
pattern matching gives us at our

00:02:54,250 --> 00:03:01,329
disposal so I have a question which is

00:02:57,480 --> 00:03:06,359
what is the most common answer to this

00:03:01,329 --> 00:03:11,349
question why doesn't C++ have feature X

00:03:06,359 --> 00:03:14,650
most common answer Michael no one

00:03:11,349 --> 00:03:16,450
proposed it okay so we need a service

00:03:14,650 --> 00:03:18,489
proposal some kind of proposal to

00:03:16,450 --> 00:03:19,150
actually add added to the language so in

00:03:18,489 --> 00:03:21,790
00:03:19,150 --> 00:03:23,349
David's ankle wrote a service proposal

00:03:21,790 --> 00:03:25,299
to introduce pattern matching and this

00:03:23,349 --> 00:03:28,989
paper included a language level variant

00:03:25,299 --> 00:03:30,340
purple specification as well the next

00:03:28,989 --> 00:03:32,169
revision of the paper will tackle

00:03:30,340 --> 00:03:33,880
pattern matching separate from language

00:03:32,169 --> 00:03:37,780
level variants and for which I'll be a

00:03:33,880 --> 00:03:40,630
co-author so look forward to that time

00:03:37,780 --> 00:03:42,819
why I now stood that's when three will

00:03:40,630 --> 00:03:44,019
be made later on I don't know what I

00:03:42,819 --> 00:03:48,250
don't know what the plan is for that yet

00:03:44,019 --> 00:03:50,349
so what's the purpose of this talk for

00:03:48,250 --> 00:03:52,079
my experience in the community so far I

00:03:50,349 --> 00:03:54,760
found that a lot of people actually are

00:03:52,079 --> 00:03:56,950
exposed to functional style pattern

00:03:54,760 --> 00:03:58,239
matching and so I want to introduce and

00:03:56,950 --> 00:04:00,790
familiarize the idea within the

00:03:58,239 --> 00:04:03,069
community so that we can actually have a

00:04:00,790 --> 00:04:04,239
conversation where we actually know what

00:04:03,069 --> 00:04:07,660
we're talking about when we talk to each

00:04:04,239 --> 00:04:09,340
other secondly I'm seeking to find out

00:04:07,660 --> 00:04:12,579
some question answer to answers to some

00:04:09,340 --> 00:04:14,500
questions first one is why now why do i

00:04:12,579 --> 00:04:16,660
why do we care now what's changed

00:04:14,500 --> 00:04:18,220
alright we've it's been thirty something

00:04:16,660 --> 00:04:21,909
years why do we need pattern matching

00:04:18,220 --> 00:04:24,010
now and the other thing is can a modern

00:04:21,909 --> 00:04:25,630
library solution be good enough we've

00:04:24,010 --> 00:04:29,080
been adding more and more likely

00:04:25,630 --> 00:04:30,790
teachers and libraries library we're

00:04:29,080 --> 00:04:34,630
getting more power to be able to write

00:04:30,790 --> 00:04:37,050
more powerful libraries can we actually

00:04:34,630 --> 00:04:40,780
have pattern matching in library form

00:04:37,050 --> 00:04:42,220
available and we have a bunch of

00:04:40,780 --> 00:04:47,050
facilities that are considered good

00:04:42,220 --> 00:04:50,260
enough right tuple variant pair not good

00:04:47,050 --> 00:04:54,540
enough to everyone but by the committee

00:04:50,260 --> 00:04:56,470
by the community there's not been enough

00:04:54,540 --> 00:04:57,640
pushback against having library

00:04:56,470 --> 00:05:00,610
solutions and it seems to be working

00:04:57,640 --> 00:05:02,650
okay for us so on the other hand there

00:05:00,610 --> 00:05:04,840
are also libraries such as boost lambda

00:05:02,650 --> 00:05:06,820
which warranted a language language

00:05:04,840 --> 00:05:12,520
little feature because it just wasn't it

00:05:06,820 --> 00:05:14,710
just wasn't going to fly and lastly if a

00:05:12,520 --> 00:05:17,050
modest libraries we if we deem a library

00:05:14,710 --> 00:05:19,060
solution to be not sufficient then at

00:05:17,050 --> 00:05:21,340
least we can gain exchange experience

00:05:19,060 --> 00:05:24,040
from having built one to guide the

00:05:21,340 --> 00:05:25,210
language design at least for me

00:05:24,040 --> 00:05:26,980
so that I can guide the language stuff

00:05:25,210 --> 00:05:28,930
so this is the overview of the talk

00:05:26,980 --> 00:05:31,960
we're going to briefly we're gonna have

00:05:28,930 --> 00:05:34,380
one slide algebraic data types I'm gonna

00:05:31,960 --> 00:05:36,970
try to explain what pattern matching is

00:05:34,380 --> 00:05:38,950
I'm at a more fundamental level and

00:05:36,970 --> 00:05:40,420
which one is trying to achieve we're

00:05:38,950 --> 00:05:41,920
gonna see various forms of pattern

00:05:40,420 --> 00:05:44,470
matching very restricted forms of

00:05:41,920 --> 00:05:47,800
pattern matching that you see and use in

00:05:44,470 --> 00:05:50,260
C++ today then I will introduce my

00:05:47,800 --> 00:05:52,660
library we'll go through some examples

00:05:50,260 --> 00:05:57,250
and I'll show some interesting features

00:05:52,660 --> 00:06:00,100
that I can't leave out because they're

00:05:57,250 --> 00:06:01,030
so interesting to me but I think I'll

00:06:00,100 --> 00:06:03,970
but I think you'll find them interesting

00:06:01,030 --> 00:06:06,970
as well so algebraic data types it comes

00:06:03,970 --> 00:06:09,370
in two forms the first one is the

00:06:06,970 --> 00:06:11,380
product type so when we say product time

00:06:09,370 --> 00:06:13,990
we're talking about a data type that can

00:06:11,380 --> 00:06:16,030
compose up that can be composed of

00:06:13,990 --> 00:06:18,850
multiple multiple data types and they

00:06:16,030 --> 00:06:20,290
hold an instance of both or how many

00:06:18,850 --> 00:06:22,720
ever how many other types you throw it

00:06:20,290 --> 00:06:25,540
right so yeah so examples are like a

00:06:22,720 --> 00:06:28,090
tuple where you can say two bowl of X Y

00:06:25,540 --> 00:06:30,880
and throw a store an instance of x and y

00:06:28,090 --> 00:06:34,630
and the name product comes from the fact

00:06:30,880 --> 00:06:36,460
that we're counting the the number of

00:06:34,630 --> 00:06:38,710
the number of possible states of these

00:06:36,460 --> 00:06:39,380
types and so for a product type the

00:06:38,710 --> 00:06:42,290
number of possible

00:06:39,380 --> 00:06:44,510
States for a tuple XY can be in is the

00:06:42,290 --> 00:06:47,780
number of states that X can be times the

00:06:44,510 --> 00:06:49,880
number of states that Y can be in on the

00:06:47,780 --> 00:06:51,530
other axis we have some types where we

00:06:49,880 --> 00:06:54,830
can have one of the types that we gave

00:06:51,530 --> 00:06:59,090
it so an example of this is a variant XY

00:06:54,830 --> 00:07:02,780
it's going to store an X or Y and it's

00:06:59,090 --> 00:07:05,210
not going to store both ok and we'll

00:07:02,780 --> 00:07:07,220
start with a claim my claim here is that

00:07:05,210 --> 00:07:10,090
pattern matching is the best tool for

00:07:07,220 --> 00:07:14,870
decomposing algebraic data types and

00:07:10,090 --> 00:07:17,180
we'll see examples and back it up so

00:07:14,870 --> 00:07:20,480
what is pattern matching this is a quote

00:07:17,180 --> 00:07:21,980
from Haskell wikibooks it says in

00:07:20,480 --> 00:07:24,290
pattern matching we attempt to match

00:07:21,980 --> 00:07:26,750
values against patterns and if so

00:07:24,290 --> 00:07:31,340
desired bind variables to successful

00:07:26,750 --> 00:07:34,760
matches here's a trivial example from

00:07:31,340 --> 00:07:39,160
rust written in rust we declare a point

00:07:34,760 --> 00:07:42,380
class with fields x and y we declare a

00:07:39,160 --> 00:07:46,210
variable of type point with value 0 and

00:07:42,380 --> 00:07:49,280
7 and 0 we're gonna match on the P and

00:07:46,210 --> 00:07:51,080
we're going to provide the cases that we

00:07:49,280 --> 00:07:52,760
want to match in order so we're going to

00:07:51,080 --> 00:07:55,730
so so the rest is actually going to

00:07:52,760 --> 00:07:58,670
check these cases in order and in this

00:07:55,730 --> 00:08:01,280
case it's going to fall into the FIR the

00:07:58,670 --> 00:08:05,840
second case because the Y is 0 and we're

00:08:01,280 --> 00:08:11,510
going to print x-axis is 7 pretty simple

00:08:05,840 --> 00:08:13,610
everyone follow ok I see nods so the

00:08:11,510 --> 00:08:15,440
traditional way in which we would write

00:08:13,610 --> 00:08:17,240
this at Z plus plus might look was Mike

00:08:15,440 --> 00:08:20,630
might look something like this right we

00:08:17,240 --> 00:08:22,790
can say we can manually go and check the

00:08:20,630 --> 00:08:26,650
individual fields and do the correct

00:08:22,790 --> 00:08:28,910
thing so what's the difference well

00:08:26,650 --> 00:08:31,640
pattern matching is a declarative

00:08:28,910 --> 00:08:33,560
approach in lieu of manually testing for

00:08:31,640 --> 00:08:35,360
value for a value with sequence of

00:08:33,560 --> 00:08:37,160
conditionals and extracting the desired

00:08:35,360 --> 00:08:39,710
components all right so the color coding

00:08:37,160 --> 00:08:41,690
here I'm trying to emphasize that the

00:08:39,710 --> 00:08:44,060
patterns that were picked before is a

00:08:41,690 --> 00:08:45,830
sequence of conditionals now and it's a

00:08:44,060 --> 00:08:48,370
declarative way of describing your

00:08:45,830 --> 00:08:48,370
conditionals

00:08:50,360 --> 00:08:55,579
so even if we have a more elaborate

00:08:52,759 --> 00:08:57,529
example here which is to evaluate

00:08:55,579 --> 00:09:01,339
expressions so this is an expression

00:08:57,529 --> 00:09:03,769
tree we have the experts / basically a

00:09:01,339 --> 00:09:08,839
variant here which is going to store one

00:09:03,769 --> 00:09:11,179
of int negative add or multiply the box

00:09:08,839 --> 00:09:12,739
is basically a pointer because it's

00:09:11,179 --> 00:09:14,929
going to be a recursive recursive type

00:09:12,739 --> 00:09:19,519
and we would have to do this do this in

00:09:14,929 --> 00:09:21,350
C++ as well and as you as we will see so

00:09:19,519 --> 00:09:23,959
this is one way to write our eval

00:09:21,350 --> 00:09:26,600
function we can take an instance of

00:09:23,959 --> 00:09:29,629
expert match on the expert and provide

00:09:26,600 --> 00:09:32,420
our cases we can say if it's an int find

00:09:29,629 --> 00:09:34,639
the value the bind the value inside the

00:09:32,420 --> 00:09:39,049
int just to value it I'm going to return

00:09:34,639 --> 00:09:43,600
that for negative recursively call eval

00:09:39,049 --> 00:09:46,970
and negative negate it add multiply

00:09:43,600 --> 00:09:51,350
write evaluate both sides do the right

00:09:46,970 --> 00:09:53,029
thing pretty simple and you can see that

00:09:51,350 --> 00:09:56,089
on this axis vertically we're matching

00:09:53,029 --> 00:09:58,459
some types the the alternatives of the

00:09:56,089 --> 00:10:01,189
some type and horizontal you were

00:09:58,459 --> 00:10:03,619
matched Matt it's decomposing a power

00:10:01,189 --> 00:10:05,480
type right so we're so we have a bunch

00:10:03,619 --> 00:10:07,249
of values and we're going to compose

00:10:05,480 --> 00:10:09,589
that in two fields that I made and give

00:10:07,249 --> 00:10:13,089
it names that we want to refer to to use

00:10:09,589 --> 00:10:16,279
it in the right hand side and note that

00:10:13,089 --> 00:10:19,339
patterns are composable so here we have

00:10:16,279 --> 00:10:22,730
one layer of pattern which is the sum

00:10:19,339 --> 00:10:23,989
type pattern and then within the sum

00:10:22,730 --> 00:10:26,269
type pattern we're going to decompose

00:10:23,989 --> 00:10:30,009
the part the product type into their

00:10:26,269 --> 00:10:37,720
names so that's two does two layers of

00:10:30,009 --> 00:10:41,209
nesting so this is the analogous hard

00:10:37,720 --> 00:10:43,129
example in C++ I'm gonna use a shared

00:10:41,209 --> 00:10:45,519
Porter here you might have noticed that

00:10:43,129 --> 00:10:47,809
that's just for me to cheat later on

00:10:45,519 --> 00:10:49,610
you'll see how I cheat later I'm not

00:10:47,809 --> 00:10:54,199
gonna hide the fact that I'm cheating

00:10:49,610 --> 00:10:56,299
here okay so this is one way in which

00:10:54,199 --> 00:10:59,480
you might write your eval function you

00:10:56,299 --> 00:11:02,389
check for every case that you have with

00:10:59,480 --> 00:11:03,790
the dynamic cast and rely on the

00:11:02,389 --> 00:11:05,410
implicit conversion

00:11:03,790 --> 00:11:08,800
and the fact that dynamic cast is going

00:11:05,410 --> 00:11:10,030
to return null pointer if if it's not

00:11:08,800 --> 00:11:12,220
actually the thing that you asked for

00:11:10,030 --> 00:11:14,710
and the challenge here for the

00:11:12,220 --> 00:11:16,960
programmer is that the if statement is a

00:11:14,710 --> 00:11:18,520
very flexible language constructs right

00:11:16,960 --> 00:11:20,830
the operation that we're trying to

00:11:18,520 --> 00:11:23,110
perform is actually quite structured and

00:11:20,830 --> 00:11:25,960
we're trying to use an overly general

00:11:23,110 --> 00:11:27,700
language feature to solve this

00:11:25,960 --> 00:11:29,770
particular problem and trying to get it

00:11:27,700 --> 00:11:31,750
and and relying on the programmer to get

00:11:29,770 --> 00:11:34,230
it right and oftentimes we don't get it

00:11:31,750 --> 00:11:36,940
right and it's often the source of bugs

00:11:34,230 --> 00:11:38,290
and it's also very unlikely for that to

00:11:36,940 --> 00:11:40,450
be a warning if and when there's a

00:11:38,290 --> 00:11:42,310
missing case mainly because the heart is

00:11:40,450 --> 00:11:44,290
open but also because the cases are

00:11:42,310 --> 00:11:46,240
spread out as different predicates in an

00:11:44,290 --> 00:11:47,800
if statement it's really hard for

00:11:46,240 --> 00:11:50,830
compilers to be able to reason across

00:11:47,800 --> 00:11:52,420
and actually actually tell you that you

00:11:50,830 --> 00:11:56,080
were doing something wrong when you're

00:11:52,420 --> 00:11:58,450
using something this general and alright

00:11:56,080 --> 00:12:01,030
you might say oh come on and park no

00:11:58,450 --> 00:12:03,100
one's gonna write this code in practice

00:12:01,030 --> 00:12:05,010
who would actually write this I would do

00:12:03,100 --> 00:12:08,770
I would use visitors or something and

00:12:05,010 --> 00:12:11,140
all right so here I'm just illustrating

00:12:08,770 --> 00:12:13,900
that we're testing manually forced with

00:12:11,140 --> 00:12:17,590
a sequence of conditionals what we want

00:12:13,900 --> 00:12:20,560
and then do this is our incredible

00:12:17,590 --> 00:12:23,770
imperative approach okay

00:12:20,560 --> 00:12:27,660
so yeah no one would write this this is

00:12:23,770 --> 00:12:27,660
code that I pulled out of LLVM

00:12:29,240 --> 00:12:35,730
then cast is faster but it's essentially

00:12:33,509 --> 00:12:36,870
gonna be cast if it's not storing the

00:12:35,730 --> 00:12:39,690
thing that you asked for it's going to

00:12:36,870 --> 00:12:43,470
give you a double pointer and this is

00:12:39,690 --> 00:12:46,079
all over I love you not to say that

00:12:43,470 --> 00:12:49,500
that's bad per se I'll be I'm is a high

00:12:46,079 --> 00:12:51,060
poly suppose cross-project but this is

00:12:49,500 --> 00:12:55,440
something that's pretty difficult to

00:12:51,060 --> 00:12:59,670
maintain in my opinion and you might say

00:12:55,440 --> 00:13:03,470
visitors better well that's that's a lot

00:12:59,670 --> 00:13:08,550
of code compared to what we had before

00:13:03,470 --> 00:13:12,569
we have this weird return returning

00:13:08,550 --> 00:13:16,949
values idiom yeah I don't I don't I

00:13:12,569 --> 00:13:18,509
don't have to do that okay so a little

00:13:16,949 --> 00:13:21,089
insight from Swift while I was doing

00:13:18,509 --> 00:13:24,930
research for this talk I found this

00:13:21,089 --> 00:13:27,240
quote that I thought was insightful and

00:13:24,930 --> 00:13:29,399
it said this was from this is from the

00:13:27,240 --> 00:13:31,319
document which was used during the

00:13:29,399 --> 00:13:34,170
design phase of introducing pattern

00:13:31,319 --> 00:13:35,220
matching to Swift and it said pattern

00:13:34,170 --> 00:13:37,110
matching was probably a foregone

00:13:35,220 --> 00:13:38,699
conclusion but I wanted to spell out

00:13:37,110 --> 00:13:41,250
that having ATP's in the language

00:13:38,699 --> 00:13:43,589
algebraic data types is in the language

00:13:41,250 --> 00:13:45,269
is really what is what really forces our

00:13:43,589 --> 00:13:47,310
hand because the alternatives are so bad

00:13:45,269 --> 00:13:49,680
and we just took a thicker look at the

00:13:47,310 --> 00:13:51,899
two alternatives that we we just took a

00:13:49,680 --> 00:13:57,829
look at two alternatives that were so

00:13:51,899 --> 00:14:01,709
bad and I think that this answers my

00:13:57,829 --> 00:14:05,100
first question which was why now and why

00:14:01,709 --> 00:14:07,079
do we care what changed right algebraic

00:14:05,100 --> 00:14:09,500
data out the support for algebraic data

00:14:07,079 --> 00:14:13,439
types in C++ is pretty new

00:14:09,500 --> 00:14:16,010
we had to pool introduced in C++ 11 and

00:14:13,439 --> 00:14:18,810
variant only came in she was for 17

00:14:16,010 --> 00:14:20,430
before that we had structs which we

00:14:18,810 --> 00:14:23,399
couldn't be compose in any reasonable

00:14:20,430 --> 00:14:26,220
way aside from actually naming the

00:14:23,399 --> 00:14:30,120
fields and we had class hierarchies

00:14:26,220 --> 00:14:31,860
which we didn't look at as a subtype we

00:14:30,120 --> 00:14:33,899
kind of came from the object-oriented

00:14:31,860 --> 00:14:38,189
side of it and didn't consider them to

00:14:33,899 --> 00:14:41,730
be part of the algebra theater family so

00:14:38,189 --> 00:14:44,550
I think that answers my question for why

00:14:41,730 --> 00:14:46,050
we want it now okay various forms of

00:14:44,550 --> 00:14:51,060
higher matching you may have seen in the

00:14:46,050 --> 00:14:53,100
wild in C++ let's start with simple

00:14:51,060 --> 00:14:54,300
types and we'll talk about how product

00:14:53,100 --> 00:14:56,880
types and subtypes are matched things

00:14:54,300 --> 00:14:58,800
equal sequence was today so matching

00:14:56,880 --> 00:15:01,079
simple types is pretty common right we

00:14:58,800 --> 00:15:05,610
can reuse switches all over the place to

00:15:01,079 --> 00:15:07,319
match integrals in this case I just have

00:15:05,610 --> 00:15:12,779
an integer X and I'm gonna use a switch

00:15:07,319 --> 00:15:14,040
to perform some actions and of course

00:15:12,779 --> 00:15:15,510
someone will come along and say why

00:15:14,040 --> 00:15:18,480
can't I metric mattress string and

00:15:15,510 --> 00:15:19,110
you'll be like well it only works for

00:15:18,480 --> 00:15:22,829
integrals

00:15:19,110 --> 00:15:25,230
all right efficiency but if it's

00:15:22,829 --> 00:15:27,329
actually what you want she'll be able to

00:15:25,230 --> 00:15:29,459
do it I think so here's an alternative

00:15:27,329 --> 00:15:32,610
way to do it this is Python style switch

00:15:29,459 --> 00:15:34,680
right you can construct your own map and

00:15:32,610 --> 00:15:39,120
then you can index into it and call

00:15:34,680 --> 00:15:42,180
whatever action you want to call two

00:15:39,120 --> 00:15:44,699
ways of doing it here's what it looks

00:15:42,180 --> 00:15:47,339
like to decompose product types so to

00:15:44,699 --> 00:15:50,040
set it up let's have a pair XY

00:15:47,339 --> 00:15:56,850
called P and we'll have a tuple of pair

00:15:50,040 --> 00:15:59,730
XY and Z cool in C++ 17 we have still

00:15:56,850 --> 00:16:02,760
apply which will allow you to unpack a

00:15:59,730 --> 00:16:06,809
tuple or a pair or any tuple like type

00:16:02,760 --> 00:16:08,790
and we can decompose that into arguments

00:16:06,809 --> 00:16:10,829
into a function alright so we can say

00:16:08,790 --> 00:16:13,079
apply of this lambda which takes X&Y

00:16:10,829 --> 00:16:16,439
give it a P and it's going to expand the

00:16:13,079 --> 00:16:17,790
P into function as the arguments on the

00:16:16,439 --> 00:16:19,319
right hand side I'm showing what it

00:16:17,790 --> 00:16:22,050
looks like if you had the nested

00:16:19,319 --> 00:16:25,350
restructuring it's not pretty

00:16:22,050 --> 00:16:27,990
you have to apply the first level with T

00:16:25,350 --> 00:16:30,480
and then you have to expect expand again

00:16:27,990 --> 00:16:32,339
with the second layer and you're going

00:16:30,480 --> 00:16:34,139
to have it let's suppose you have four

00:16:32,339 --> 00:16:35,779
layers of expansion that you want to do

00:16:34,139 --> 00:16:38,819
you're gonna be going in

00:16:35,779 --> 00:16:41,040
depending on how how many spaces you end

00:16:38,819 --> 00:16:43,679
up with if you it ends up with two let's

00:16:41,040 --> 00:16:48,809
say four four levels you're at 810 that

00:16:43,679 --> 00:16:51,029
deep right there's a also a new way to

00:16:48,809 --> 00:16:54,089
do it suppose to 17 introduce search

00:16:51,029 --> 00:16:56,610
structured bindings we can now say Auto

00:16:54,089 --> 00:16:59,939
sy equals P and we're about to expand

00:16:56,610 --> 00:17:02,730
the P into the variables x and y on the

00:16:59,939 --> 00:17:06,480
right hand side I'm trying to show how t

00:17:02,730 --> 00:17:09,000
would be decomposed the last line is

00:17:06,480 --> 00:17:11,010
something that you might think that it's

00:17:09,000 --> 00:17:13,799
possible intuitively but this is

00:17:11,010 --> 00:17:17,189
actually not supported and so again we

00:17:13,799 --> 00:17:20,069
have multiple levels of nesting when we

00:17:17,189 --> 00:17:28,919
try to actually decompose complex data

00:17:20,069 --> 00:17:32,340
types so let's change the hierarchy a

00:17:28,919 --> 00:17:35,460
little bit and use a variant so that we

00:17:32,340 --> 00:17:38,940
can visit it easily rather than having

00:17:35,460 --> 00:17:42,809
to do the whole setting up of the

00:17:38,940 --> 00:17:44,190
visitor hierarchy and the code looks

00:17:42,809 --> 00:17:48,450
more or less the same except we're using

00:17:44,190 --> 00:17:52,220
state visit now and again I'll point out

00:17:48,450 --> 00:17:55,470
that if you were to nest your classes

00:17:52,220 --> 00:17:57,860
your your types for example if you

00:17:55,470 --> 00:18:03,360
wanted to reach it to Meg in the

00:17:57,860 --> 00:18:06,600
negation case and look in to visit the

00:18:03,360 --> 00:18:08,760
expert inside the negation then we're

00:18:06,600 --> 00:18:14,909
gonna have to do another layer of

00:18:08,760 --> 00:18:18,929
visitation which is nested inside okay

00:18:14,909 --> 00:18:21,659
this brings us to my library so I have

00:18:18,929 --> 00:18:23,580
four goals for the library one is that I

00:18:21,659 --> 00:18:25,620
want this to be declarative I would like

00:18:23,580 --> 00:18:28,230
to avoid having to spell out the state

00:18:25,620 --> 00:18:31,080
that I'm looking for I want to just

00:18:28,230 --> 00:18:34,770
describe what I want and then see if it

00:18:31,080 --> 00:18:37,529
matches number two I wanted to be

00:18:34,770 --> 00:18:39,090
structured the chain of it as we as we

00:18:37,529 --> 00:18:42,110
discussed the chain of F else's are

00:18:39,090 --> 00:18:45,990
overly general for the task at hand

00:18:42,110 --> 00:18:49,289
cohesiveness the reason why I showed the

00:18:45,990 --> 00:18:51,779
I think it was seven or eight different

00:18:49,289 --> 00:18:55,200
ways in which we can decompose algebraic

00:18:51,779 --> 00:18:58,649
data types in C++ right the we just went

00:18:55,200 --> 00:19:01,440
through three three paths and each of

00:18:58,649 --> 00:19:03,750
them had two solutions at least two

00:19:01,440 --> 00:19:05,580
solutions so the various forms of

00:19:03,750 --> 00:19:08,850
pattern matching we explored are very

00:19:05,580 --> 00:19:14,130
hodgepodge unsatisfying to lose

00:19:08,850 --> 00:19:15,720
- pretty simple test ahead and and and

00:19:14,130 --> 00:19:17,970
each of them had their own limitations

00:19:15,720 --> 00:19:21,540
switches with their integrals visitation

00:19:17,970 --> 00:19:22,890
with their difficulty to nest as well as

00:19:21,540 --> 00:19:25,620
structured bindings even the newest

00:19:22,890 --> 00:19:28,470
stuff has limitations that we're not all

00:19:25,620 --> 00:19:30,540
not happy with and most importantly it

00:19:28,470 --> 00:19:32,640
needs to be composable and the reason

00:19:30,540 --> 00:19:36,300
why patterns must be composable is

00:19:32,640 --> 00:19:39,540
because a DTS are composable because

00:19:36,300 --> 00:19:42,420
algebraic data types we because we build

00:19:39,540 --> 00:19:45,150
values out of smaller components and we

00:19:42,420 --> 00:19:47,150
build on top of each other we need to be

00:19:45,150 --> 00:19:53,220
able to do the same thing with patterns

00:19:47,150 --> 00:19:55,760
to be able to to be able to reduce our

00:19:53,220 --> 00:19:58,230
cognitive overhead

00:19:55,760 --> 00:19:58,770
so this syntactically this is what it

00:19:58,230 --> 00:20:01,170
looks like

00:19:58,770 --> 00:20:03,390
it's the biggest basic structure all of

00:20:01,170 --> 00:20:07,050
the you can just include and park slash

00:20:03,390 --> 00:20:08,430
patterns on HTTP the using namespace is

00:20:07,050 --> 00:20:12,030
going to pull into all the necessary

00:20:08,430 --> 00:20:13,980
components you can match on multiple

00:20:12,030 --> 00:20:16,560
expressions and then provide multiple

00:20:13,980 --> 00:20:19,160
multiple patterns provide your bindings

00:20:16,560 --> 00:20:26,400
and it's going to execute them in order

00:20:19,160 --> 00:20:31,140
in order first fit execution okay so

00:20:26,400 --> 00:20:34,290
let's get back to the point example we

00:20:31,140 --> 00:20:36,390
have we had points XY we're going to

00:20:34,290 --> 00:20:38,340
instantiate our create an instance of

00:20:36,390 --> 00:20:41,250
point with seven zero and we're going to

00:20:38,340 --> 00:20:45,630
say match p we're going to provide the

00:20:41,250 --> 00:20:48,120
DES pattern this is the the structuring

00:20:45,630 --> 00:20:51,090
pattern and we're going to say the first

00:20:48,120 --> 00:20:52,320
one needs to be zero or anything the

00:20:51,090 --> 00:20:53,730
second one's going to be anything or

00:20:52,320 --> 00:20:57,450
zero the last one can be anything

00:20:53,730 --> 00:20:59,670
anything and you can see the the

00:20:57,450 --> 00:21:01,530
variable bindings being introduced as

00:20:59,670 --> 00:21:04,770
the function parameters of the lambda of

00:21:01,530 --> 00:21:07,470
the right hand side so arg is the

00:21:04,770 --> 00:21:10,350
binding pattern and it's going to match

00:21:07,470 --> 00:21:12,300
any value and pass that value on to the

00:21:10,350 --> 00:21:13,920
handler on the right hand side and if

00:21:12,300 --> 00:21:16,350
there are multiple arms it's going to

00:21:13,920 --> 00:21:20,240
pass them over in in the order in which

00:21:16,350 --> 00:21:20,240
they appear in the pattern

00:21:20,790 --> 00:21:29,480
pretty clear and getting back to the

00:21:25,410 --> 00:21:33,870
evaluating expression this example we

00:21:29,480 --> 00:21:36,600
now specialized variant size here and

00:21:33,870 --> 00:21:40,830
this is to communicate to the library

00:21:36,600 --> 00:21:44,910
that I am a variant like concept that I

00:21:40,830 --> 00:21:46,800
modeled a variant like concept so just a

00:21:44,910 --> 00:21:49,640
side note if you're using structured

00:21:46,800 --> 00:21:51,930
bindings and you for example say

00:21:49,640 --> 00:21:55,380
introduce a struct that inherits from a

00:21:51,930 --> 00:21:56,820
tuple and you try to structure a binding

00:21:55,380 --> 00:21:58,560
on that that will give you an error

00:21:56,820 --> 00:22:00,350
because of this exact because of this

00:21:58,560 --> 00:22:03,210
exact issue it's going to think that

00:22:00,350 --> 00:22:05,220
your type is doesn't model tuple like

00:22:03,210 --> 00:22:08,550
because you don't you didn't specialize

00:22:05,220 --> 00:22:11,340
tuple size so triple size and variant

00:22:08,550 --> 00:22:13,260
size are the the customization points

00:22:11,340 --> 00:22:15,540
for which you communicate to the

00:22:13,260 --> 00:22:20,730
language feature or my library that you

00:22:15,540 --> 00:22:25,380
are tuple like or very alike okay so

00:22:20,730 --> 00:22:27,930
this the evaluation might look like this

00:22:25,380 --> 00:22:30,600
we match on the expert and the ass

00:22:27,930 --> 00:22:33,660
pattern is a new pattern and this is

00:22:30,600 --> 00:22:36,060
going to be the the matcher

00:22:33,660 --> 00:22:39,270
the pattern that matches polymorphic

00:22:36,060 --> 00:22:41,370
types variant like types and any any any

00:22:39,270 --> 00:22:43,680
like types by any I mean the stood any

00:22:41,370 --> 00:22:45,300
that was introduced in sequence of 17 so

00:22:43,680 --> 00:22:47,630
you could throw whatever it's won any

00:22:45,300 --> 00:22:49,980
and get get stuff out within any cast

00:22:47,630 --> 00:22:52,980
with this with this pattern you could

00:22:49,980 --> 00:22:55,440
get stuff out of any cast sorry you can

00:22:52,980 --> 00:22:58,800
get stuff on up on any by the library

00:22:55,440 --> 00:23:00,870
executing the any cast operation so here

00:22:58,800 --> 00:23:02,430
we have a parent or at least something

00:23:00,870 --> 00:23:05,540
that we opted into as a variant like

00:23:02,430 --> 00:23:10,380
type and we're going to provide our

00:23:05,540 --> 00:23:12,870
alternatives and and we're going to also

00:23:10,380 --> 00:23:15,120
provide the nested pattern here we also

00:23:12,870 --> 00:23:17,940
we already saw the vs pattern which was

00:23:15,120 --> 00:23:21,870
the structuring pattern and that appears

00:23:17,940 --> 00:23:25,050
within the as pattern and we're going to

00:23:21,870 --> 00:23:27,320
bind the desired parts onto the right

00:23:25,050 --> 00:23:27,320
hand side

00:23:29,450 --> 00:23:34,950
there's another example here I have an

00:23:32,460 --> 00:23:37,290
optional flag example suppose we have a

00:23:34,950 --> 00:23:43,200
optional command line flag and we're

00:23:37,290 --> 00:23:45,420
going to analyze analyze the input so we

00:23:43,200 --> 00:23:48,380
matching the flag and the first one and

00:23:45,420 --> 00:23:53,570
so and so the new patterns here are some

00:23:48,380 --> 00:23:56,490
none any of and a different use of Arc

00:23:53,570 --> 00:24:00,270
so let's go through it so some is a

00:23:56,490 --> 00:24:02,820
pattern that the syntax would be some of

00:24:00,270 --> 00:24:05,160
some pattern inside so I could say some

00:24:02,820 --> 00:24:07,740
underscore which search we could say

00:24:05,160 --> 00:24:10,590
some Arg which would say if you're an

00:24:07,740 --> 00:24:12,870
optional and you have a value then gave

00:24:10,590 --> 00:24:15,420
me the value you could say some

00:24:12,870 --> 00:24:17,070
underscore which is a wild-card which I

00:24:15,420 --> 00:24:19,020
actually haven't introduced but it's

00:24:17,070 --> 00:24:20,040
pretty intuitive you it just ignores any

00:24:19,020 --> 00:24:21,780
value that binds to it

00:24:20,040 --> 00:24:26,370
and so if you say some underscore that

00:24:21,780 --> 00:24:28,080
it's going to match an optional if it if

00:24:26,370 --> 00:24:30,929
if it has a value but it's going to be

00:24:28,080 --> 00:24:34,830
dropped about for example none will

00:24:30,929 --> 00:24:37,140
match if the optional is empty any of is

00:24:34,830 --> 00:24:38,820
typically seen as the as the pipe

00:24:37,140 --> 00:24:40,650
operator in functional languages

00:24:38,820 --> 00:24:42,809
it's the alternation pattern you can

00:24:40,650 --> 00:24:43,980
give it multiple patterns and the whole

00:24:42,809 --> 00:24:49,040
thing will match it for one of the

00:24:43,980 --> 00:24:51,660
patterns match the use of Arg here is

00:24:49,040 --> 00:24:54,780
basically okay so what we're trying to

00:24:51,660 --> 00:24:56,850
do is we want to match the optional if

00:24:54,780 --> 00:24:59,250
the optional is set and the value is

00:24:56,850 --> 00:25:00,510
underscore V or under other verbose then

00:24:59,250 --> 00:25:02,670
you want to map they want to dispatched

00:25:00,510 --> 00:25:05,610
in this case now once we get into the

00:25:02,670 --> 00:25:08,130
case how do we how do we know which one

00:25:05,610 --> 00:25:09,270
matched right we don't know whether it

00:25:08,130 --> 00:25:11,309
matches because of because it was

00:25:09,270 --> 00:25:16,170
another V or because it was another

00:25:11,309 --> 00:25:18,720
under dash dash verbose so by wrapping

00:25:16,170 --> 00:25:21,570
the Arg around the the pattern that

00:25:18,720 --> 00:25:24,570
matches the value it'll Matt it'll it'll

00:25:21,570 --> 00:25:26,929
pass the entire value that matched at

00:25:24,570 --> 00:25:29,910
that level on to the on to the handler

00:25:26,929 --> 00:25:32,130
so on the right hand side we get you

00:25:29,910 --> 00:25:35,460
know the string that match then you can

00:25:32,130 --> 00:25:39,840
it'll be it'll have to be - B or -

00:25:35,460 --> 00:25:42,350
that's for both the second Oh the second

00:25:39,840 --> 00:25:44,899
one in the second case we introduced

00:25:42,350 --> 00:25:48,409
guard so the one Clause there that's

00:25:44,899 --> 00:25:50,840
bolded so the sum argh as I described

00:25:48,409 --> 00:25:53,240
will match a optional that has a value

00:25:50,840 --> 00:25:56,389
and pass whatever value it's holding on

00:25:53,240 --> 00:25:59,899
to the handler and the when guard will

00:25:56,389 --> 00:26:03,590
execute and it will only execute the

00:25:59,899 --> 00:26:05,360
handler if the one guard succeeds so if

00:26:03,590 --> 00:26:07,789
the wine guard fails the difference

00:26:05,360 --> 00:26:10,039
between when and an if would be that an

00:26:07,789 --> 00:26:12,259
if it would you would still stay within

00:26:10,039 --> 00:26:15,940
that handler whereas whereas if or when

00:26:12,259 --> 00:26:19,179
fails you fall through to the next case

00:26:15,940 --> 00:26:19,179
does that make sense

00:26:19,360 --> 00:26:26,269
good okay all right so summary of the

00:26:23,870 --> 00:26:28,159
patterns that I've introduced so far we

00:26:26,269 --> 00:26:29,870
have expression pattern so the

00:26:28,159 --> 00:26:33,440
expression pattern we saw in the first

00:26:29,870 --> 00:26:37,610
example whatever matching zero right

00:26:33,440 --> 00:26:44,509
we saw Arg and wild card yeah we saw

00:26:37,610 --> 00:26:47,990
well card did okay oh yeah I drew this

00:26:44,509 --> 00:26:50,509
it okay cool so the structure pattern we

00:26:47,990 --> 00:26:52,490
saw first and the destructor pattern

00:26:50,509 --> 00:26:55,519
works worst operates off of a concept as

00:26:52,490 --> 00:26:58,190
well and the concept is an array and

00:26:55,519 --> 00:27:00,379
when I say array I mean a see array an

00:26:58,190 --> 00:27:03,409
aggregate or a to polite and by tuple

00:27:00,379 --> 00:27:07,519
like I mean the the tuple size tuple

00:27:03,409 --> 00:27:11,629
elements and yet interface that

00:27:07,519 --> 00:27:13,309
structured binding uses so so this is

00:27:11,629 --> 00:27:15,110
really useful and that's why our initial

00:27:13,309 --> 00:27:18,350
point example worked without any

00:27:15,110 --> 00:27:21,590
boilerplate of introducing tuple size

00:27:18,350 --> 00:27:24,620
and get and stuff like that so the as

00:27:21,590 --> 00:27:27,230
pattern as I mentioned matches some

00:27:24,620 --> 00:27:30,049
types polymorphic types very very like

00:27:27,230 --> 00:27:32,809
types anything any like optional matches

00:27:30,049 --> 00:27:34,730
pointer like types so the example that I

00:27:32,809 --> 00:27:36,649
showed was with a stand optional but you

00:27:34,730 --> 00:27:40,159
could also match pointers with it for

00:27:36,649 --> 00:27:42,230
example and alternation yeah it's going

00:27:40,159 --> 00:27:44,059
to imagine and one of the end patterns

00:27:42,230 --> 00:27:46,450
and then dispatch to the handler if any

00:27:44,059 --> 00:27:46,450
of them matches

00:27:48,799 --> 00:27:51,799
okay

00:27:51,870 --> 00:28:03,960
this is it this is our big example okay

00:28:00,679 --> 00:28:05,549
so what we're gonna do is take the

00:28:03,960 --> 00:28:07,350
expression tree that we've been working

00:28:05,549 --> 00:28:09,570
with the latest one that we saw with the

00:28:07,350 --> 00:28:13,260
variant and we're gonna simplify the

00:28:09,570 --> 00:28:14,789
expression tree and there's and the

00:28:13,260 --> 00:28:17,880
simplification rules that will cover our

00:28:14,789 --> 00:28:21,360
double negation plus 0 multiplied by 1

00:28:17,880 --> 00:28:25,500
and what's that was the last one

00:28:21,360 --> 00:28:28,559
multiplied by 0 and we want to keep the

00:28:25,500 --> 00:28:32,090
original tree intact and we want to

00:28:28,559 --> 00:28:32,090
share as many notes as possible

00:28:34,190 --> 00:28:38,549
okay so just the review just a refresher

00:28:36,720 --> 00:28:45,299
on the expression tree that we've been

00:28:38,549 --> 00:28:47,610
looking at nothing's changed so the

00:28:45,299 --> 00:28:49,889
first tip will go through a case by case

00:28:47,610 --> 00:28:53,130
so the first one is a simple case where

00:28:49,889 --> 00:28:55,409
we just simplifying an int we take some

00:28:53,130 --> 00:28:58,350
expression tree we match the expression

00:28:55,409 --> 00:28:59,580
and if it holds an int we don't even

00:28:58,350 --> 00:29:04,320
care what it holds we're just going to

00:28:59,580 --> 00:29:06,029
return the expression directly so if

00:29:04,320 --> 00:29:07,740
that's the expression our result is

00:29:06,029 --> 00:29:11,419
going to be just another share pointer

00:29:07,740 --> 00:29:11,419
that that points to the same integer

00:29:11,659 --> 00:29:18,539
here's the double negation case so so so

00:29:16,559 --> 00:29:20,669
refer to just a reminder on the colors

00:29:18,539 --> 00:29:22,529
the purple is the value that we're

00:29:20,669 --> 00:29:24,690
matching the pink is the patterns that

00:29:22,529 --> 00:29:27,809
we're matching with the yellow is the

00:29:24,690 --> 00:29:33,929
variables that we're introducing and the

00:29:27,809 --> 00:29:36,539
green represents the tree so the double

00:29:33,929 --> 00:29:38,220
the double negative case so we're going

00:29:36,539 --> 00:29:41,130
to first match the outer layer with the

00:29:38,220 --> 00:29:44,130
negation node within that we're going to

00:29:41,130 --> 00:29:46,289
D structure the negation node into their

00:29:44,130 --> 00:29:48,840
parts into its part which it only has an

00:29:46,289 --> 00:29:50,970
expression we're going to then because

00:29:48,840 --> 00:29:52,590
it's just because it's a pointer we're

00:29:50,970 --> 00:29:54,630
going to access the value inside the

00:29:52,590 --> 00:29:58,220
pointer which is the expression with the

00:29:54,630 --> 00:30:01,020
sum we then match another negation node

00:29:58,220 --> 00:30:01,770
alright so if any of these fail so for

00:30:01,020 --> 00:30:03,510
example if the

00:30:01,770 --> 00:30:07,440
if the sharePort share pointer is null

00:30:03,510 --> 00:30:08,850
which in our case it can't be it would

00:30:07,440 --> 00:30:10,770
it would actually not match this pattern

00:30:08,850 --> 00:30:13,410
at all all right so we're not so we're

00:30:10,770 --> 00:30:15,000
not running into some null pointer

00:30:13,410 --> 00:30:18,210
exceptions or anything like that or no

00:30:15,000 --> 00:30:19,650
like you referencing null pointers or

00:30:18,210 --> 00:30:22,440
anything like that

00:30:19,650 --> 00:30:25,500
and then when we get to the part that we

00:30:22,440 --> 00:30:27,180
want we're going to dispatch buying the

00:30:25,500 --> 00:30:30,000
value that we actually want and we're

00:30:27,180 --> 00:30:30,990
going to simplify it simplify that and

00:30:30,000 --> 00:30:32,520
that's what that's going to be our

00:30:30,990 --> 00:30:35,280
result we're going to recursively

00:30:32,520 --> 00:30:36,660
simplify throwing out the two negations

00:30:35,280 --> 00:30:39,450
we're going to we're going to simplify

00:30:36,660 --> 00:30:42,870
the expression that lies stands two to

00:30:39,450 --> 00:30:45,750
two that's two levels deep so this is

00:30:42,870 --> 00:30:50,670
our result all right we simplified they

00:30:45,750 --> 00:30:54,840
can - - 17 - just 17 go through the rest

00:30:50,670 --> 00:30:57,870
of it a little bit faster perhaps here's

00:30:54,840 --> 00:30:59,490
plus zero now we have two cases we're

00:30:57,870 --> 00:31:02,610
gonna match zero of anything and

00:30:59,490 --> 00:31:04,800
anything with zero so we have the as

00:31:02,610 --> 00:31:06,690
pattern again match the add we're going

00:31:04,800 --> 00:31:11,430
to be the structure that add which has

00:31:06,690 --> 00:31:13,530
two two components and so the left-hand

00:31:11,430 --> 00:31:16,590
side we're gonna say if that thing

00:31:13,530 --> 00:31:17,370
actually holds a zero right we're where

00:31:16,590 --> 00:31:22,020
we're going

00:31:17,370 --> 00:31:24,630
add we're going to add int and also

00:31:22,020 --> 00:31:26,250
checking that that value is zero on the

00:31:24,630 --> 00:31:27,270
right hand side we don't care and then

00:31:26,250 --> 00:31:29,730
we're going to simple enter we're going

00:31:27,270 --> 00:31:31,530
to throw out the zero and simplify the

00:31:29,730 --> 00:31:34,830
other side so in this case we have

00:31:31,530 --> 00:31:41,700
expert left and right and our result is

00:31:34,830 --> 00:31:43,440
going to be just 17 x one it looks

00:31:41,700 --> 00:31:45,120
exactly the same except we change

00:31:43,440 --> 00:31:49,680
multiplication change it to

00:31:45,120 --> 00:31:52,560
multiplication and one same case so

00:31:49,680 --> 00:31:56,460
we'll just skip what with that the x is

00:31:52,560 --> 00:31:58,140
zero case is pretty interesting so

00:31:56,460 --> 00:31:59,670
similar pattern right we have we have a

00:31:58,140 --> 00:32:02,670
multiplication we have multiplication

00:31:59,670 --> 00:32:05,100
and we're gonna inspect both sides zero

00:32:02,670 --> 00:32:07,740
or anything anything or zero and we

00:32:05,100 --> 00:32:09,120
don't care what the anything is because

00:32:07,740 --> 00:32:12,090
we're gonna return zero

00:32:09,120 --> 00:32:13,830
but remember one of the requirements

00:32:12,090 --> 00:32:15,450
that I mentioned at the beginning of the

00:32:13,830 --> 00:32:18,299
this exercise which is that what this

00:32:15,450 --> 00:32:20,730
share as many notes as possible so what

00:32:18,299 --> 00:32:22,559
that means is when we have we want the

00:32:20,730 --> 00:32:24,360
return zero here but we don't want to

00:32:22,559 --> 00:32:26,610
create another note for zero we want to

00:32:24,360 --> 00:32:29,070
actually reuse the you reuse the zero

00:32:26,610 --> 00:32:32,510
that's already there and so this is

00:32:29,070 --> 00:32:35,789
where I use the org pattern that binds a

00:32:32,510 --> 00:32:37,799
bigger portion of the portion of the

00:32:35,789 --> 00:32:41,700
pattern that you wanted so here I'm I'm

00:32:37,799 --> 00:32:43,649
actually saying look down and see if

00:32:41,700 --> 00:32:45,510
there's a zero and if there is one give

00:32:43,649 --> 00:32:47,429
me the whole give me the entire share

00:32:45,510 --> 00:32:49,380
pointer so that I can copy that right

00:32:47,429 --> 00:32:52,130
because otherwise I don't I don't have

00:32:49,380 --> 00:32:55,519
access to the actual the pointer to zero

00:32:52,130 --> 00:32:58,500
so in this case I'm gonna actually get

00:32:55,519 --> 00:32:59,669
the result to be zero and it's not going

00:32:58,500 --> 00:33:07,110
to be a new zero it's going to be an

00:32:59,669 --> 00:33:10,799
existing one simplifying negative in the

00:33:07,110 --> 00:33:15,029
general so if when it's not a negative

00:33:10,799 --> 00:33:17,730
double negative then we're going to we

00:33:15,029 --> 00:33:20,549
the case is actually pretty simple so

00:33:17,730 --> 00:33:23,580
we're going to first try to simplify the

00:33:20,549 --> 00:33:27,029
thing underneath the negative and if

00:33:23,580 --> 00:33:28,950
that changes anything then if it doesn't

00:33:27,029 --> 00:33:31,440
change then we're just going to return

00:33:28,950 --> 00:33:33,450
the result so and if so basically the

00:33:31,440 --> 00:33:35,250
first case here the first the first case

00:33:33,450 --> 00:33:39,899
of the conditional is the left-hand side

00:33:35,250 --> 00:33:42,149
diagram and we try to simplify E and the

00:33:39,899 --> 00:33:44,070
simple e comes out to be always the same

00:33:42,149 --> 00:33:45,720
thing okay well if it's the same thing

00:33:44,070 --> 00:33:49,889
and you can simplify that just return

00:33:45,720 --> 00:33:52,860
the thing that you had before if if you

00:33:49,889 --> 00:33:56,309
try to simplify and you don't get the

00:33:52,860 --> 00:33:59,429
same thing as e so here we have the

00:33:56,309 --> 00:34:02,250
simple e at 17 as opposed to e which is

00:33:59,429 --> 00:34:04,169
pointing at the plus alright so if it's

00:34:02,250 --> 00:34:06,720
not the same then what that means is

00:34:04,169 --> 00:34:09,270
that we were actually able to simplify

00:34:06,720 --> 00:34:12,570
some stuff and so we need to make a new

00:34:09,270 --> 00:34:16,139
new node reattach it and then this is

00:34:12,570 --> 00:34:18,330
our result and this is because we want

00:34:16,139 --> 00:34:19,740
the first requirement which was that we

00:34:18,330 --> 00:34:22,470
want to keep the original tree intact

00:34:19,740 --> 00:34:24,569
right we don't want to modify the top

00:34:22,470 --> 00:34:26,339
level minus to point at 17 we want to

00:34:24,569 --> 00:34:33,179
actually keep that one intact and leave

00:34:26,339 --> 00:34:34,710
it alone looks more complicated but it's

00:34:33,179 --> 00:34:36,119
exactly the same thing we simplify the

00:34:34,710 --> 00:34:40,379
left-hand side simplify the right-hand

00:34:36,119 --> 00:34:43,980
side and we check whether anything

00:34:40,379 --> 00:34:46,020
changed if they changed then we return

00:34:43,980 --> 00:34:48,000
the result if something changed in this

00:34:46,020 --> 00:34:50,190
case for example then we're going to

00:34:48,000 --> 00:34:55,080
create a new node reattach and return

00:34:50,190 --> 00:34:57,750
the result and multiplication here is

00:34:55,080 --> 00:34:59,460
exactly the same thing so if it didn't

00:34:57,750 --> 00:35:03,180
change return the tree if something

00:34:59,460 --> 00:35:07,380
changed create a new node it reattached

00:35:03,180 --> 00:35:11,760
the trend result and putting it all

00:35:07,380 --> 00:35:14,819
together I've consolidated a bunch of

00:35:11,760 --> 00:35:17,670
the cases with any of which was the

00:35:14,819 --> 00:35:21,569
alternation pattern and so you can see

00:35:17,670 --> 00:35:24,720
that if it's negative negative negative

00:35:21,569 --> 00:35:27,089
negative be B plus 0 or be multiplied by

00:35:24,720 --> 00:35:29,400
one all of them we just simply just

00:35:27,089 --> 00:35:32,520
ignore the thing and simplify the

00:35:29,400 --> 00:35:35,460
expression if in the zero case it's a

00:35:32,520 --> 00:35:39,480
little different where we find some sub

00:35:35,460 --> 00:35:41,160
sub portion of the of the value and we

00:35:39,480 --> 00:35:45,839
saw some of the more complex cases in

00:35:41,160 --> 00:35:47,640
this generic generic cases so what I'm

00:35:45,839 --> 00:35:51,089
trying to highlight what this example is

00:35:47,640 --> 00:35:52,800
the nesting right maybe that's obvious

00:35:51,089 --> 00:35:55,830
maybe it's not but I would like to point

00:35:52,800 --> 00:35:58,170
it out explicitly because it's that's

00:35:55,830 --> 00:36:00,869
that's really the power of pattern

00:35:58,170 --> 00:36:03,000
matching which is to describe the full

00:36:00,869 --> 00:36:05,849
list the full state of the value that

00:36:03,000 --> 00:36:09,569
you're looking for and we just see if

00:36:05,849 --> 00:36:11,790
it's there and this is basically what I

00:36:09,569 --> 00:36:13,230
just said the real power of pattern

00:36:11,790 --> 00:36:20,010
matching is that the patterns are built

00:36:13,230 --> 00:36:23,490
the same way as values I will show you a

00:36:20,010 --> 00:36:24,720
few more things these are some of the

00:36:23,490 --> 00:36:27,450
challenges that I ran through and some

00:36:24,720 --> 00:36:29,790
of the cool things I found so one of the

00:36:27,450 --> 00:36:31,680
challenges is the identifiers

00:36:29,790 --> 00:36:33,480
all right introducing identifiers

00:36:31,680 --> 00:36:35,160
there's so many there's only so many

00:36:33,480 --> 00:36:39,600
contexts and so many ways and you can

00:36:35,160 --> 00:36:42,840
introduce our data fires in C++ and in

00:36:39,600 --> 00:36:44,220
languages like rust that we saw well are

00:36:42,840 --> 00:36:47,340
sort of rustic as a functional language

00:36:44,220 --> 00:36:49,500
per se but they allow you to introduce

00:36:47,340 --> 00:36:53,430
identifiers within the pattern right so

00:36:49,500 --> 00:36:56,910
when we said point XY we're introducing

00:36:53,430 --> 00:36:58,980
new identifiers in place and can we use

00:36:56,910 --> 00:37:00,900
that on the right hand side we don't

00:36:58,980 --> 00:37:02,700
have that luxury in C++

00:37:00,900 --> 00:37:05,220
I can't just introduce our data fires

00:37:02,700 --> 00:37:07,440
within the expression and so my current

00:37:05,220 --> 00:37:10,230
solution is to say all right let me just

00:37:07,440 --> 00:37:11,520
fill it in with placeholders called args

00:37:10,230 --> 00:37:13,440
here and that actually give it the name

00:37:11,520 --> 00:37:16,260
on the lambdas on the right hand side

00:37:13,440 --> 00:37:17,880
but from the examples based on the

00:37:16,260 --> 00:37:20,130
examples you saw you can see that it's

00:37:17,880 --> 00:37:22,200
actually very verbose and difficult to

00:37:20,130 --> 00:37:24,420
read because when you look at the

00:37:22,200 --> 00:37:27,870
pattern you just see a sequence of arms

00:37:24,420 --> 00:37:30,690
right argh argh argh argh argh okay what

00:37:27,870 --> 00:37:31,800
what is that right if they if the fields

00:37:30,690 --> 00:37:32,940
actually have some meaning and you were

00:37:31,800 --> 00:37:36,870
able to give them names there would

00:37:32,940 --> 00:37:38,550
actually be a lot better so patterns do

00:37:36,870 --> 00:37:41,910
not have any other fires so can't do

00:37:38,550 --> 00:37:43,800
something about this and before we get

00:37:41,910 --> 00:37:47,040
to whether we can do anything about it

00:37:43,800 --> 00:37:50,670
this is what you saw you saw an example

00:37:47,040 --> 00:37:53,730
of pattern guard before simple example

00:37:50,670 --> 00:37:55,050
of Fibonacci where if it's if the value

00:37:53,730 --> 00:37:56,880
is less than equal to let's say you go

00:37:55,050 --> 00:38:01,830
to zero there is kind of a return zero

00:37:56,880 --> 00:38:04,560
and the reason why this one is inside

00:38:01,830 --> 00:38:07,170
the lambda and not closer to the pattern

00:38:04,560 --> 00:38:09,360
which is which is what most of you would

00:38:07,170 --> 00:38:11,190
probably expect is for the when to be

00:38:09,360 --> 00:38:13,020
right next to the pattern right because

00:38:11,190 --> 00:38:15,030
that's the whole criteria for which you

00:38:13,020 --> 00:38:17,580
need to satisfy before the handler gets

00:38:15,030 --> 00:38:20,790
called but this one is inside the lambda

00:38:17,580 --> 00:38:22,710
because if I were to pull the one out

00:38:20,790 --> 00:38:23,850
and put it beside the pattern that I

00:38:22,710 --> 00:38:27,420
need another way to introduce

00:38:23,850 --> 00:38:28,920
identifiers and this way I'm actually

00:38:27,420 --> 00:38:30,300
leveraging the fact that I already

00:38:28,920 --> 00:38:32,040
introduced identifiers with the lambda

00:38:30,300 --> 00:38:33,480
and I want to read I want to just be

00:38:32,040 --> 00:38:40,380
able to refer to that and use it

00:38:33,480 --> 00:38:45,420
immediately it's inside because we want

00:38:40,380 --> 00:38:47,400
to reuse the other fire mm-hmm so this

00:38:45,420 --> 00:38:51,570
is another this another experiment that

00:38:47,400 --> 00:38:53,260
I've conducted and I actually quite

00:38:51,570 --> 00:38:54,400
liked it but I haven't flushed it out

00:38:53,260 --> 00:38:57,160
fully yet but I still think it's pretty

00:38:54,400 --> 00:38:59,890
cool so you can say you can introduce

00:38:57,160 --> 00:39:02,020
identifiers before the entire thing so

00:38:59,890 --> 00:39:04,480
it's a little unfortunate that you have

00:39:02,020 --> 00:39:05,950
to be you know you know you have to you

00:39:04,480 --> 00:39:07,360
have to list off all that if I reserved

00:39:05,950 --> 00:39:12,970
we're gonna use it all the patterns up

00:39:07,360 --> 00:39:14,620
front but it's really it's really on you

00:39:12,970 --> 00:39:16,750
know in the lambdas or before the

00:39:14,620 --> 00:39:18,220
expressions so this is the only other

00:39:16,750 --> 00:39:23,290
place that I was able to find something

00:39:18,220 --> 00:39:28,120
okay and we can and we can let me go

00:39:23,290 --> 00:39:30,250
back and we can and we can use the

00:39:28,120 --> 00:39:32,380
identifiers that we introduced X&Y in

00:39:30,250 --> 00:39:34,840
inside the pattern and so for example if

00:39:32,380 --> 00:39:36,640
you had more meaningful names it would

00:39:34,840 --> 00:39:38,980
be helpful inside a pattern because you

00:39:36,640 --> 00:39:41,680
don't you no longer just see our guard

00:39:38,980 --> 00:39:53,110
guard maybe you see first name comma

00:39:41,680 --> 00:39:58,620
last name so the cool part here so the

00:39:53,110 --> 00:39:58,620
identifiers it's all in caps which means

00:39:59,970 --> 00:40:04,120
it's a macro why is it a macro if it's

00:40:03,130 --> 00:40:05,830
just the argh

00:40:04,120 --> 00:40:08,830
what couldn't you have just echo type

00:40:05,830 --> 00:40:10,750
org and then just gave it names and the

00:40:08,830 --> 00:40:13,270
fancy thing here is that repeated I if I

00:40:10,750 --> 00:40:16,240
repeated identifiers mean the values

00:40:13,270 --> 00:40:18,280
have to be equal and this is I find this

00:40:16,240 --> 00:40:19,480
really cool because most functional

00:40:18,280 --> 00:40:24,130
languages actually don't support this

00:40:19,480 --> 00:40:27,100
and it's interesting because I think the

00:40:24,130 --> 00:40:28,090
reason why they do it is related to the

00:40:27,100 --> 00:40:30,910
fact that they're introducing

00:40:28,090 --> 00:40:32,920
identifiers in place right there either

00:40:30,910 --> 00:40:34,630
introducing identify identifiers in

00:40:32,920 --> 00:40:37,900
place and they're saying well you

00:40:34,630 --> 00:40:39,580
introduce another identifier it's you

00:40:37,900 --> 00:40:42,760
have a duplicate identifier essentially

00:40:39,580 --> 00:40:44,950
right as opposed to saying okay you said

00:40:42,760 --> 00:40:46,240
this thing again and we'll take that to

00:40:44,950 --> 00:40:48,340
mean that you want it to be the same

00:40:46,240 --> 00:40:50,410
value as the first one that you declared

00:40:48,340 --> 00:40:52,870
right same reason why we can't declare

00:40:50,410 --> 00:40:55,440
multiple multiple value multiple

00:40:52,870 --> 00:40:58,360
variable isn't the same name in C++

00:40:55,440 --> 00:41:00,520
whereas if I declare it upfront when I

00:40:58,360 --> 00:41:03,390
refer to it twice it's pretty clear that

00:41:00,520 --> 00:41:06,880
I'm referring to the one that I already

00:41:03,390 --> 00:41:09,460
introduced previously so here's a

00:41:06,880 --> 00:41:14,859
just kind of a dumb example but we have

00:41:09,460 --> 00:41:18,730
a triple 101 202 101 and I can provide

00:41:14,859 --> 00:41:24,609
my patterns x XX or XY x and it's trying

00:41:18,730 --> 00:41:29,970
to do what you expect good

00:41:24,609 --> 00:41:33,220
I find it fine back to the Paragard

00:41:29,970 --> 00:41:34,630
because I've taken on this burden of

00:41:33,220 --> 00:41:38,230
having to introduce our antivirus

00:41:34,630 --> 00:41:39,839
beforehand I should be able to use it

00:41:38,230 --> 00:41:45,150
right somehow

00:41:39,839 --> 00:41:49,059
so this is a way in which you can create

00:41:45,150 --> 00:41:51,730
lambdas in place similar to how boost

00:41:49,059 --> 00:41:54,009
Phoenix would do it where you have some

00:41:51,730 --> 00:41:56,680
magic placeholder you perform some

00:41:54,009 --> 00:41:59,200
operations on it and I'm gonna hijack

00:41:56,680 --> 00:42:04,089
those operators and create a lambda for

00:41:59,200 --> 00:42:09,720
you and so this is implemented and works

00:42:04,089 --> 00:42:11,559
I don't know about the e DSL approach I

00:42:09,720 --> 00:42:14,529
don't know which one I hate more

00:42:11,559 --> 00:42:17,309
basically the when macro inside the

00:42:14,529 --> 00:42:23,049
lambda is the distance is a bit far and

00:42:17,309 --> 00:42:28,890
macro and this one's it's kind of it's

00:42:23,049 --> 00:42:33,519
kind of nice but dsls yes so missed of

00:42:28,890 --> 00:42:35,549
experimenting this is the cool thing

00:42:33,519 --> 00:42:38,920
that I found that I wanted to show you

00:42:35,549 --> 00:42:41,440
very otic pattern another thing that a

00:42:38,920 --> 00:42:42,970
lot of function languages don't have but

00:42:41,440 --> 00:42:45,700
a lot of function languages also don't

00:42:42,970 --> 00:42:47,529
have very are templates so that's I

00:42:45,700 --> 00:42:49,839
think where the difference is so this

00:42:47,529 --> 00:42:52,440
pattern can appear exactly once inside

00:42:49,839 --> 00:42:54,789
of a DES pattern the destructor pattern

00:42:52,440 --> 00:42:56,619
and it's going to repeat itself

00:42:54,789 --> 00:42:59,440
how many other times it likes how many

00:42:56,619 --> 00:43:02,259
how many other times it needs to so you

00:42:59,440 --> 00:43:04,509
could even appear as the first first

00:43:02,259 --> 00:43:06,190
argument in the in a destructor pattern

00:43:04,509 --> 00:43:08,829
and it's going to expand itself how many

00:43:06,190 --> 00:43:11,619
other times it needs to so here's a

00:43:08,829 --> 00:43:15,400
quick example another triple and we're

00:43:11,619 --> 00:43:17,829
going to say decomposer two three three

00:43:15,400 --> 00:43:20,560
parts or I could also say varied a card

00:43:17,829 --> 00:43:25,120
and it's actually not any

00:43:20,560 --> 00:43:26,740
shorter so that's unfortunate where it

00:43:25,120 --> 00:43:30,010
gets interesting though is when we throw

00:43:26,740 --> 00:43:31,780
it inside of a template so we create a

00:43:30,010 --> 00:43:34,540
template here we have some tuple and

00:43:31,780 --> 00:43:36,730
with the R comma R Camargue approach

00:43:34,540 --> 00:43:39,280
well we would have we would have had to

00:43:36,730 --> 00:43:41,620
somehow get the tuple size expand that

00:43:39,280 --> 00:43:44,350
into an index sequence and then have the

00:43:41,620 --> 00:43:45,580
order to expand out that many times this

00:43:44,350 --> 00:43:47,980
way we can actually just say vary the

00:43:45,580 --> 00:43:49,960
card and that will actually just expand

00:43:47,980 --> 00:43:52,120
how many Retired sometimes it needs to

00:43:49,960 --> 00:43:55,510
based on the two polar comes in that it

00:43:52,120 --> 00:43:57,250
gets it accentuated with pretty cool

00:43:55,510 --> 00:43:59,050
what is what does it look it looks kind

00:43:57,250 --> 00:44:02,920
of familiar this is actually supposed to

00:43:59,050 --> 00:44:06,250
seven can apply right we can take some

00:44:02,920 --> 00:44:10,390
function a tuple we match on that tuple

00:44:06,250 --> 00:44:13,090
we're gonna expand it and our handler is

00:44:10,390 --> 00:44:17,620
just the function that we're calling all

00:44:13,090 --> 00:44:21,130
right cute we can get a little fancier

00:44:17,620 --> 00:44:24,430
though we have this is almost to the cat

00:44:21,130 --> 00:44:29,350
the almost part we'll see if anyone sees

00:44:24,430 --> 00:44:32,170
why so we have we have another triple we

00:44:29,350 --> 00:44:36,340
this is just showing that remember we

00:44:32,170 --> 00:44:40,120
can expand the tuple with DES Verena

00:44:36,340 --> 00:44:44,200
Clark so if we can expand a single tuple

00:44:40,120 --> 00:44:48,340
with des very Odegard then if we have n

00:44:44,200 --> 00:44:51,730
tuples how do we expand all that we

00:44:48,340 --> 00:44:55,960
would have we would have des very card

00:44:51,730 --> 00:45:00,900
comma V s very card comma P H very card

00:44:55,960 --> 00:45:05,890
kadam right so okay that looks similar

00:45:00,900 --> 00:45:10,090
so we'll have very attic vs very otic

00:45:05,890 --> 00:45:13,120
arg will take how many other tuples we

00:45:10,090 --> 00:45:14,620
get expand all of that the argue is

00:45:13,120 --> 00:45:17,650
going to expand how many other times it

00:45:14,620 --> 00:45:21,100
needs to they dispatch to the handler in

00:45:17,650 --> 00:45:23,200
order of how they appeared and it only

00:45:21,100 --> 00:45:25,450
appears once but once it's expanded if

00:45:23,200 --> 00:45:30,300
they appear but multiple times in order

00:45:25,450 --> 00:45:33,930
so we pass all of those along creditable

00:45:30,300 --> 00:45:33,930
where is the almost

00:45:36,720 --> 00:45:42,010
it looked fine to me

00:45:39,840 --> 00:45:46,930
but to poke at does this weird thing

00:45:42,010 --> 00:45:49,360
where if you take two poll of exes catid

00:45:46,930 --> 00:45:53,830
by tubalove wise it will always give you

00:45:49,360 --> 00:45:58,990
tuple of X's and Y's whereas here if I

00:45:53,830 --> 00:46:02,320
have if I have if I have two poles that

00:45:58,990 --> 00:46:05,530
have references in it for example this

00:46:02,320 --> 00:46:07,570
will always create a great values right

00:46:05,530 --> 00:46:10,540
it's kind of decay all about all the all

00:46:07,570 --> 00:46:13,030
the elements and decay construct values

00:46:10,540 --> 00:46:16,180
out of the references so it doesn't

00:46:13,030 --> 00:46:20,470
exactly do tuple cat but hey it's still

00:46:16,180 --> 00:46:23,740
pretty cool people might be concerned

00:46:20,470 --> 00:46:26,950
about cup of performance so to be honest

00:46:23,740 --> 00:46:29,050
I don't care about performance and and

00:46:26,950 --> 00:46:31,690
what I mean by that is for for this

00:46:29,050 --> 00:46:34,360
particular project and that's because

00:46:31,690 --> 00:46:37,330
the open pattern matching for C++ that

00:46:34,360 --> 00:46:39,040
Yuri Gabi and Rihanna did has a lot of

00:46:37,330 --> 00:46:41,020
research as to how we can actually get

00:46:39,040 --> 00:46:43,960
performance out of these constructs so

00:46:41,020 --> 00:46:45,900
what I'm mainly focused on is how do we

00:46:43,960 --> 00:46:48,790
introduce our data fires and where and

00:46:45,900 --> 00:46:52,210
how do we actually get this API to be

00:46:48,790 --> 00:46:54,160
usable because actually because if you

00:46:52,210 --> 00:46:55,870
actually compare the library examples to

00:46:54,160 --> 00:46:57,520
some of the examples you will find in

00:46:55,870 --> 00:47:00,430
functional programming it's actually

00:46:57,520 --> 00:47:02,910
very verbose so I'm more focused on how

00:47:00,430 --> 00:47:06,190
to get focus on getting the API clean

00:47:02,910 --> 00:47:08,050
and experiment experimenting with what

00:47:06,190 --> 00:47:09,670
kind of patterns are out there what kind

00:47:08,050 --> 00:47:13,300
of problems exist specifically

00:47:09,670 --> 00:47:17,830
specifically specifically for C++ but I

00:47:13,300 --> 00:47:19,930
did this experiment because I was

00:47:17,830 --> 00:47:23,980
curious so I went on top bolt plug

00:47:19,930 --> 00:47:26,620
doesn't plug this in this is a simple

00:47:23,980 --> 00:47:29,350
implementation of fizzbuzz where I enter

00:47:26,620 --> 00:47:34,240
a through 1/200 I'm gonna Mach 3 mod 5

00:47:29,350 --> 00:47:36,070
do the multiple values match 0-0

00:47:34,240 --> 00:47:40,330
fizzbuzz zero that is there anything

00:47:36,070 --> 00:47:41,710
buzz anything is anything zero buzz and

00:47:40,330 --> 00:47:44,620
anything anything that's pretty good

00:47:41,710 --> 00:47:46,490
number and here's how I would really

00:47:44,620 --> 00:47:49,369
need the same program

00:47:46,490 --> 00:47:51,680
and regular C was fast basically the

00:47:49,369 --> 00:47:53,090
fastest way I know how to write it while

00:47:51,680 --> 00:47:56,540
maintaining the same semantics as the

00:47:53,090 --> 00:48:00,470
previous program and they both compile

00:47:56,540 --> 00:48:06,950
down to this exact sequence of assembly

00:48:00,470 --> 00:48:08,960
they generate the exact same code there

00:48:06,950 --> 00:48:13,390
are other examples that don't but this

00:48:08,960 --> 00:48:17,510
others and I think and I think this is

00:48:13,390 --> 00:48:19,820
more so credit to the compilers not to

00:48:17,510 --> 00:48:22,520
me because I actually didn't do anything

00:48:19,820 --> 00:48:26,210
to make your performance so kudos to

00:48:22,520 --> 00:48:29,350
compiler vendors and that's Janice and

00:48:26,210 --> 00:48:33,590
that's actually true for clang and GCC

00:48:29,350 --> 00:48:35,720
so some future work I want to so what I

00:48:33,590 --> 00:48:38,480
haven't shown you that you typically

00:48:35,720 --> 00:48:43,190
expect from a pattern matching mechanism

00:48:38,480 --> 00:48:44,660
is expanding lists ranges the difficulty

00:48:43,190 --> 00:48:47,330
there is that for functional languages

00:48:44,660 --> 00:48:49,250
lists are recursive they're essentially

00:48:47,330 --> 00:48:51,109
just pairs of pairs of pairs right you

00:48:49,250 --> 00:48:53,900
just cost them on to each other and you

00:48:51,109 --> 00:48:56,210
break them up into two parts whereas for

00:48:53,900 --> 00:48:58,730
us they're actually ranges which have

00:48:56,210 --> 00:49:01,520
begin an end and that's fundamentally

00:48:58,730 --> 00:49:05,240
different way to represent lists and so

00:49:01,520 --> 00:49:09,560
when so so for example if I match up

00:49:05,240 --> 00:49:10,310
Vector how do I break that apart I can

00:49:09,560 --> 00:49:12,950
say argh

00:49:10,310 --> 00:49:15,500
to pull out the first element and then

00:49:12,950 --> 00:49:17,390
how do I describe rest right I need to

00:49:15,500 --> 00:49:20,060
say I need to describe somehow the

00:49:17,390 --> 00:49:22,250
notion of tail we don't really have a

00:49:20,060 --> 00:49:25,400
good mechanism to the two to describe

00:49:22,250 --> 00:49:28,400
tail in a range maybe Eric's range

00:49:25,400 --> 00:49:29,930
library will help experiment folder

00:49:28,400 --> 00:49:32,810
further with identifier is the current

00:49:29,930 --> 00:49:36,290
state it's it's okay but it's not great

00:49:32,810 --> 00:49:40,550
and lastly exhaust Li was checking I

00:49:36,290 --> 00:49:41,690
haven't done any work there but it would

00:49:40,550 --> 00:49:45,380
be really interesting to figure out I

00:49:41,690 --> 00:49:47,869
find out what we can do there so that's

00:49:45,380 --> 00:49:52,790
all I have I think we have ten minutes

00:49:47,869 --> 00:49:56,090
left for questions if we don't have any

00:49:52,790 --> 00:49:56,240
questions I have some more stuff all

00:49:56,090 --> 00:49:59,170
right

00:49:56,240 --> 00:49:59,170
any questions

00:50:02,470 --> 00:50:11,290
yeah well there's no TS there so so the

00:50:09,190 --> 00:50:13,900
question is what's the size that yes the

00:50:11,290 --> 00:50:16,810
answer is that there is no TS there was

00:50:13,900 --> 00:50:18,609
a proposal that was written but I don't

00:50:16,810 --> 00:50:22,780
think was discussed at the committee

00:50:18,609 --> 00:50:29,130
meetings will we'll see what the next

00:50:22,780 --> 00:50:31,990
paper next iteration of that paper sir

00:50:29,130 --> 00:50:33,369
the language variant one oh yeah yeah

00:50:31,990 --> 00:50:38,609
that's what I'm talking about so that

00:50:33,369 --> 00:50:39,730
paper I'm not sure if it was this yeah

00:50:38,609 --> 00:50:50,310
okay

00:50:39,730 --> 00:51:02,680
and was there any news there weren't so

00:50:50,310 --> 00:51:03,849
there what yeah right okay so the

00:51:02,680 --> 00:51:06,339
question was what's the status of the

00:51:03,849 --> 00:51:07,359
paper that was written that one the one

00:51:06,339 --> 00:51:10,210
that I mentioned at the beginning of the

00:51:07,359 --> 00:51:13,420
talk the status of it is that it was

00:51:10,210 --> 00:51:15,700
discussed in Oulu and we're waiting for

00:51:13,420 --> 00:51:17,470
the next generation for which I'm a

00:51:15,700 --> 00:51:23,790
co-author so I guess some of that's on

00:51:17,470 --> 00:51:23,790
me to deliver yeah Jason

00:52:14,930 --> 00:52:21,030
okay so let me so let me try to surprise

00:52:17,700 --> 00:52:22,470
that so so Jason's comment was that what

00:52:21,030 --> 00:52:24,240
I when I talk about introducing

00:52:22,470 --> 00:52:26,339
identifiers what we're really talking

00:52:24,240 --> 00:52:28,490
about is introducing free variables for

00:52:26,339 --> 00:52:32,099
which we're trying to resolve its value

00:52:28,490 --> 00:52:33,299
and there might be type constraints that

00:52:32,099 --> 00:52:37,140
we wanted to put on them and stuff like

00:52:33,299 --> 00:52:41,700
that in conclusion he thinks that I may

00:52:37,140 --> 00:52:48,329
have hit on the the reason why we it

00:52:41,700 --> 00:52:52,650
needs to be a language teacher yeah

00:52:48,329 --> 00:52:55,049
maybe I don't know but but but but the

00:52:52,650 --> 00:52:57,210
only comment that I have is the comment

00:52:55,049 --> 00:53:00,539
about constraining types like oh I want

00:52:57,210 --> 00:53:02,670
this pattern to be an int right now in

00:53:00,539 --> 00:53:06,960
the library I actually get some of that

00:53:02,670 --> 00:53:10,619
with those type checking right like if

00:53:06,960 --> 00:53:13,710
like if the if the if the rest of if the

00:53:10,619 --> 00:53:16,890
rest of the values are integers like you

00:53:13,710 --> 00:53:21,420
can't type system won't let you put

00:53:16,890 --> 00:53:22,980
anything else there and so so forth so

00:53:21,420 --> 00:53:24,930
for example if I have a three tuple and

00:53:22,980 --> 00:53:27,059
I try to match that with a pattern des

00:53:24,930 --> 00:53:29,700
underscore on the score that's not

00:53:27,059 --> 00:53:32,059
that's not a compile it's not gonna just

00:53:29,700 --> 00:53:34,710
ignore it and continue is just a compile

00:53:32,059 --> 00:53:36,779
and so in some sense the type system

00:53:34,710 --> 00:53:39,630
helps me with some of the exhaustive

00:53:36,779 --> 00:53:42,029
miss checking right in the sense that we

00:53:39,630 --> 00:53:43,920
have patterns that are never gonna match

00:53:42,029 --> 00:53:45,730
because the pipes don't match and I'm

00:53:43,920 --> 00:53:47,440
not gonna execute those because

00:53:45,730 --> 00:53:49,420
well I'm gonna tell you it not compile

00:53:47,440 --> 00:53:55,050
because I know this is never gonna work

00:53:49,420 --> 00:53:55,050
never gonna run so it's kind of yeah

00:54:00,660 --> 00:54:10,780
yeah yes right yeah so the comment was

00:54:07,480 --> 00:54:12,910
that the visitor or the the as pattern

00:54:10,780 --> 00:54:14,770
introduces types and the alternatives

00:54:12,910 --> 00:54:17,260
and that's very similar to visitor and

00:54:14,770 --> 00:54:19,510
that's just it's essentially a type

00:54:17,260 --> 00:54:23,020
search and if you can do exhaustive is

00:54:19,510 --> 00:54:29,400
checking on that then we can it'll be

00:54:23,020 --> 00:54:29,400
very useful any other questions

00:54:31,680 --> 00:54:36,430
okay if there are no questions I have

00:54:34,540 --> 00:54:46,600
five minutes if you guys want to see a

00:54:36,430 --> 00:54:48,850
peek of the implementation all right so

00:54:46,600 --> 00:54:50,670
this is a structure as I described

00:54:48,850 --> 00:54:54,040
earlier

00:54:50,670 --> 00:54:58,530
so the pattern here is going to generate

00:54:54,040 --> 00:55:02,800
or give a return the value of this

00:54:58,530 --> 00:55:04,900
prophecy intermediate class which has an

00:55:02,800 --> 00:55:07,320
operator equals which returns something

00:55:04,900 --> 00:55:10,300
that it probably shouldn't be returning

00:55:07,320 --> 00:55:12,730
its namely it's not pattern ref we're

00:55:10,300 --> 00:55:15,130
returning some completely other a

00:55:12,730 --> 00:55:17,050
completely different type so we have

00:55:15,130 --> 00:55:21,670
we're returning some case and this case

00:55:17,050 --> 00:55:23,800
comes from this equals here so

00:55:21,670 --> 00:55:26,920
considering that whole thing we should

00:55:23,800 --> 00:55:29,740
we return this whole case and the match

00:55:26,920 --> 00:55:32,020
is going to return this intermediate

00:55:29,740 --> 00:55:33,850
type which the operator paren which is

00:55:32,020 --> 00:55:37,480
how we are able to actually make that

00:55:33,850 --> 00:55:39,780
step second second set of parental and

00:55:37,480 --> 00:55:45,490
it's going to take a sequence of cases

00:55:39,780 --> 00:55:47,560
and it's going to store the values and

00:55:45,490 --> 00:55:50,050
once we actually call the operator

00:55:47,560 --> 00:55:52,780
friend then we're going to try each of

00:55:50,050 --> 00:55:54,400
the cases in turn so the try match

00:55:52,780 --> 00:55:59,200
function there is the customization

00:55:54,400 --> 00:56:08,109
point for to introduce new patterns

00:55:59,200 --> 00:56:11,790
so to hear something this is where we

00:56:08,109 --> 00:56:11,790
can do best match instead of first match

00:56:12,540 --> 00:56:20,349
Passover they what first time right

00:56:17,890 --> 00:56:21,609
right yeah yeah so yes and this is where

00:56:20,349 --> 00:56:25,150
I would do exhausting this checking as

00:56:21,609 --> 00:56:27,900
well so the reason why I'm not so

00:56:25,150 --> 00:56:29,650
concerned why optimistic about

00:56:27,900 --> 00:56:31,540
exhausting this checking and stuff like

00:56:29,650 --> 00:56:34,299
that is because because I know I have

00:56:31,540 --> 00:56:36,490
all the information in place right it's

00:56:34,299 --> 00:56:37,780
not like oh I don't know if I'm actually

00:56:36,490 --> 00:56:39,520
gonna have enough information to be able

00:56:37,780 --> 00:56:41,680
to do it like I know I haven't I just

00:56:39,520 --> 00:56:43,569
need to read papers to figure out how to

00:56:41,680 --> 00:56:45,900
do exactly chucking and then we'll

00:56:43,569 --> 00:56:45,900
figure it out

00:56:46,109 --> 00:56:50,490
best that best match I think is

00:56:48,400 --> 00:56:55,750
something that I don't really want to do

00:56:50,490 --> 00:56:58,089
if you look at so like so we have a lot

00:56:55,750 --> 00:56:59,980
of pattern matching mechanisms in C++

00:56:58,089 --> 00:57:03,549
namely like overload resolution for

00:56:59,980 --> 00:57:06,520
example is the best match best fit

00:57:03,549 --> 00:57:08,109
pattern matching and overload resolution

00:57:06,520 --> 00:57:09,339
rules are so complicated because we're

00:57:08,109 --> 00:57:10,839
trying to figure out which one is best

00:57:09,339 --> 00:57:12,460
as opposed to just saying oh yeah this

00:57:10,839 --> 00:57:14,319
was this was fine all right this was

00:57:12,460 --> 00:57:16,510
matches and so we have all these rules

00:57:14,319 --> 00:57:19,410
around integral conversion sequences and

00:57:16,510 --> 00:57:21,579
I think the complexity that it adds I

00:57:19,410 --> 00:57:25,990
mean it's nice but I'm not sure if it's

00:57:21,579 --> 00:57:27,339
worth it okay let's move on so ok ha so

00:57:25,990 --> 00:57:29,319
first up first up first of all this

00:57:27,339 --> 00:57:31,960
would've been to two functions if it

00:57:29,319 --> 00:57:34,089
weren't for its this context part and

00:57:31,960 --> 00:57:36,280
I'm using if house expert like all over

00:57:34,089 --> 00:57:38,559
the library I think yes so last night I

00:57:36,280 --> 00:57:40,960
counted and I have like I have 48

00:57:38,559 --> 00:57:45,280
instances of it it cost exported the

00:57:40,960 --> 00:57:48,400
library right now which is my new like

00:57:45,280 --> 00:57:50,770
my new favorite language feature so what

00:57:48,400 --> 00:57:54,160
is this result here this result has type

00:57:50,770 --> 00:57:56,799
match result and it returns a its it

00:57:54,160 --> 00:57:58,119
inherits from optional forwarder and the

00:57:56,799 --> 00:57:59,619
forwarder thing is there because

00:57:58,119 --> 00:58:02,619
optional doesn't let you put references

00:57:59,619 --> 00:58:04,089
in it and my what I call the function it

00:58:02,619 --> 00:58:05,530
might actually give me references an

00:58:04,089 --> 00:58:08,950
hour I actually need to forward that

00:58:05,530 --> 00:58:10,530
reference pop out properly so that's why

00:58:08,950 --> 00:58:13,190
that's there we're not going to

00:58:10,530 --> 00:58:15,450
forwarder it just Ford's stuff through

00:58:13,190 --> 00:58:21,930
it's not all that interesting but it's

00:58:15,450 --> 00:58:24,450
tricky to get right so here's match

00:58:21,930 --> 00:58:30,330
result aware invoke so if you call it

00:58:24,450 --> 00:58:31,500
call regular invoke then you're going to

00:58:30,330 --> 00:58:32,790
you're going to have to deal with void

00:58:31,500 --> 00:58:37,770
and stuff like that right because Matt

00:58:32,790 --> 00:58:39,360
hasn't finishes paper the papers done

00:58:37,770 --> 00:58:41,910
matt is tried to push regular voice

00:58:39,360 --> 00:58:43,650
through C++ how's it happen yet so for

00:58:41,910 --> 00:58:46,380
now I have to deal with this stuff is

00:58:43,650 --> 00:58:47,880
void if it's void then create the void

00:58:46,380 --> 00:58:50,610
type and make sure you propagate the

00:58:47,880 --> 00:58:52,350
void properly and if it's a match result

00:58:50,610 --> 00:58:54,660
don't don't layer match results on top

00:58:52,350 --> 00:58:56,850
of each other etc and this function is

00:58:54,660 --> 00:58:58,830
what is what these is what the try match

00:58:56,850 --> 00:59:00,750
function uses so here's the

00:58:58,830 --> 00:59:02,880
implementation of try match for expert

00:59:00,750 --> 00:59:05,280
expert pattern and the expert pattern is

00:59:02,880 --> 00:59:06,630
like it's just a name right it's got to

00:59:05,280 --> 00:59:10,020
take any value and just compare it

00:59:06,630 --> 00:59:12,300
equality a comparison so we take some

00:59:10,020 --> 00:59:13,920
value we could we perform a quality

00:59:12,300 --> 00:59:15,690
comparison with some with the with the

00:59:13,920 --> 00:59:18,030
value that we're trying to match and the

00:59:15,690 --> 00:59:22,110
and the third argument there is the is

00:59:18,030 --> 00:59:25,500
the function that you give you give all

00:59:22,110 --> 00:59:27,330
of the all of the the values that you

00:59:25,500 --> 00:59:30,870
want to pass to the handler to that

00:59:27,330 --> 00:59:33,090
function so in this case a expression

00:59:30,870 --> 00:59:36,750
pattern doesn't match anything so it's

00:59:33,090 --> 00:59:40,260
going to just call F with value whereas

00:59:36,750 --> 00:59:43,230
the art pattern which actually passes

00:59:40,260 --> 00:59:45,600
the value over is going to if you look

00:59:43,230 --> 00:59:48,270
at the invocation for match invoke

00:59:45,600 --> 00:59:51,990
there's going to pass that value over to

00:59:48,270 --> 00:59:53,250
the handler and if if the art has if the

00:59:51,990 --> 00:59:54,660
if it's if it's a more sophisticated

00:59:53,250 --> 00:59:56,310
form of arg where it has a nested

00:59:54,660 --> 01:00:00,470
pattern they were rather just to

00:59:56,310 --> 01:00:04,380
delegate that to istic the inner pattern

01:00:00,470 --> 01:00:06,200
make sense that's it this is not for you

01:00:04,380 --> 01:00:09,140
to see

01:00:06,200 --> 01:00:14,719
thank you everyone for coming by

01:00:09,140 --> 01:00:14,719

YouTube URL: https://www.youtube.com/watch?v=HaZ1UQXnuC8


