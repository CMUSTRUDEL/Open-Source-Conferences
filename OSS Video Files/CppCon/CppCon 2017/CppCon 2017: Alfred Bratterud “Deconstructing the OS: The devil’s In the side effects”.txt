Title: CppCon 2017: Alfred Bratterud “Deconstructing the OS: The devil’s In the side effects”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
IncludeOS is a library operating system, where your C++ application pulls in exactly what it needs and turns it into a bootable binary. But once you have your standalone program with standard libraries, what do you really need from an operating system? In this talk we’ll show you some exciting developments in unikernel OS- and hypervisor design, ranging from a single-function do-it-all hardware interface for everything needed to run a web server, to a full on object-oriented ecosystem giving your C++ application total control over everything from devices, drivers and plugins, to every protocol in an internet enabled host. We’re running a full IP stack on platforms ranging from full blown server hardware to inside a single unit test in userspace and we still want more. We’ll discuss how minimal can be combined with maximal - giving you lots of modern abstractions while keeping the final binary as lean and mean as possible.
— 
Alfred Bratterud: IncludeOS, CTO

Alfred Bratterud is the creator of IncludeOS, the C++ unikernel. The work on IncludeOS started as a PhD research project but has since evolved into a full time venture for the IncludeOS developer team. Alfred holds BSc and MSc in computer science from the University of Oslo, with focus on logic and computability. He has 10+ years of industrial programming experience.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:08,960
okay hello everybody nice to see you my

00:00:05,730 --> 00:00:11,519
name is Alfred I'm the CTO of include OS

00:00:08,960 --> 00:00:14,759
today I'm going to deconstruct the

00:00:11,519 --> 00:00:18,060
operating system actually I'm going to

00:00:14,759 --> 00:00:21,090
build or show you how to build a tiny

00:00:18,060 --> 00:00:24,810
little operating system from the bottom

00:00:21,090 --> 00:00:26,580
up so if you're not familiar with

00:00:24,810 --> 00:00:28,890
including us how many knows about

00:00:26,580 --> 00:00:33,030
include to us from before ok good

00:00:28,890 --> 00:00:35,460
how many knows about unicron's yeah so

00:00:33,030 --> 00:00:38,520
including us is a zero operating zero

00:00:35,460 --> 00:00:42,000
overhead library operating system and is

00:00:38,520 --> 00:00:44,579
written from scratch in modern C++

00:00:42,000 --> 00:00:46,680
if you add single address space to that

00:00:44,579 --> 00:00:49,379
definition you'll fulfill the

00:00:46,680 --> 00:00:51,690
requirements for a unicorn so when it's

00:00:49,379 --> 00:00:53,520
a single address base operating system

00:00:51,690 --> 00:00:56,250
that kind of implies that it's also a

00:00:53,520 --> 00:00:59,670
single process so we're making a library

00:00:56,250 --> 00:01:02,070
operating system designed to make your

00:00:59,670 --> 00:01:06,479
elf binary bootable and completely

00:01:02,070 --> 00:01:08,780
self-contained so I want to repeat this

00:01:06,479 --> 00:01:11,490
fact there's zero percent Linux inside

00:01:08,780 --> 00:01:13,049
you know we've given talks about

00:01:11,490 --> 00:01:15,479
including West so we've told people that

00:01:13,049 --> 00:01:17,549
it's written from scratch in C++ still

00:01:15,479 --> 00:01:19,320
after an hour an hour people raise their

00:01:17,549 --> 00:01:22,110
hands and ask you know but there is

00:01:19,320 --> 00:01:26,430
Linux inside right no there is no Linux

00:01:22,110 --> 00:01:29,130
inside it's all C++ so I'm going to

00:01:26,430 --> 00:01:32,670
start with a question this is a real

00:01:29,130 --> 00:01:35,810
stack overflow question from 2015 how to

00:01:32,670 --> 00:01:37,829
boot my simple hello world program

00:01:35,810 --> 00:01:41,250
suppose I have a simple hello world

00:01:37,829 --> 00:01:45,409
program which is built in C now how can

00:01:41,250 --> 00:01:45,409
I put it during start my PC

00:01:45,960 --> 00:01:52,300
okay never mind the the syntax is it a

00:01:50,620 --> 00:01:55,390
fair question how many things is a fair

00:01:52,300 --> 00:01:56,920
question if you were a moderator on

00:01:55,390 --> 00:02:01,150
Stack Overflow would you allow this

00:01:56,920 --> 00:02:03,250
question not many of you who would deny

00:02:01,150 --> 00:02:07,510
this question I would say it's it's not

00:02:03,250 --> 00:02:09,490
an okay question none of you well the

00:02:07,510 --> 00:02:10,660
people of Stack Overflow didn't think it

00:02:09,490 --> 00:02:13,720
was a fair question

00:02:10,660 --> 00:02:16,300
it got down voted it was closed that's

00:02:13,720 --> 00:02:19,690
too broad you know people were actually

00:02:16,300 --> 00:02:21,550
quite rude with this guy so this guy is

00:02:19,690 --> 00:02:23,740
saying sorry to burst your bubble here

00:02:21,550 --> 00:02:25,270
the very fact that you asked how to do

00:02:23,740 --> 00:02:27,340
it means you don't have a deep enough

00:02:25,270 --> 00:02:30,780
understanding of computer science to be

00:02:27,340 --> 00:02:35,050
able to do it I mean that's pretty rude

00:02:30,780 --> 00:02:36,880
but where does this come from what is

00:02:35,050 --> 00:02:38,470
this idea that it's so hard to boot

00:02:36,880 --> 00:02:38,770
analog world program where does it come

00:02:38,470 --> 00:02:41,320
from

00:02:38,770 --> 00:02:43,180
it comes from the fact that on your

00:02:41,320 --> 00:02:45,220
computers you have these huge operating

00:02:43,180 --> 00:02:47,380
systems and you're used to the fact that

00:02:45,220 --> 00:02:49,210
you know that's just how it is but it

00:02:47,380 --> 00:02:52,000
doesn't have to so let's go back in time

00:02:49,210 --> 00:02:53,980
a little there used to be a time when

00:02:52,000 --> 00:02:55,840
users were in control of their computers

00:02:53,980 --> 00:02:59,230
are you guys in control of your

00:02:55,840 --> 00:03:00,760
computers your programmers right I don't

00:02:59,230 --> 00:03:03,700
feel I'm in control control of this

00:03:00,760 --> 00:03:05,680
computer I mean I think Apple is to be

00:03:03,700 --> 00:03:07,720
honest I think see these updates I don't

00:03:05,680 --> 00:03:09,459
know what's going on I say okay well

00:03:07,720 --> 00:03:13,180
they do something to my computers

00:03:09,459 --> 00:03:15,760
probably fine but you know as a systems

00:03:13,180 --> 00:03:18,430
programmer and as a C++ programmer I

00:03:15,760 --> 00:03:22,000
like to be able to control my own

00:03:18,430 --> 00:03:23,320
computing you know that's also a famous

00:03:22,000 --> 00:03:25,720
statement from somebody else let's not

00:03:23,320 --> 00:03:29,950
go there but I like to be able to

00:03:25,720 --> 00:03:31,959
control my computer so let's look at an

00:03:29,950 --> 00:03:34,660
ad this is an ad for an IBM personal

00:03:31,959 --> 00:03:36,670
computer because the guy wanted to know

00:03:34,660 --> 00:03:39,700
how he could boot his HelloWorld program

00:03:36,670 --> 00:03:42,430
on a PC so you know here's a PC this is

00:03:39,700 --> 00:03:45,730
an IBM personal computer XT okay so it's

00:03:42,430 --> 00:03:47,830
it's not the original IBM PC B it's the

00:03:45,730 --> 00:03:50,380
extended version where you got on hard

00:03:47,830 --> 00:03:52,400
drive all right so it's it's slightly

00:03:50,380 --> 00:03:57,060
more sophisticated

00:03:52,400 --> 00:03:59,940
so IBM sold these first pcs with 16 to

00:03:57,060 --> 00:04:02,250
64 kilobytes of memory would it have

00:03:59,940 --> 00:04:04,080
been a fair question back then I mean

00:04:02,250 --> 00:04:06,630
I'm absolutely certain that the

00:04:04,080 --> 00:04:08,280
operating systems that were you know

00:04:06,630 --> 00:04:12,480
popular at the time I think Microsoft

00:04:08,280 --> 00:04:14,670
DOS was probably on this one it was a

00:04:12,480 --> 00:04:17,010
tiny tiny tiny thing compared to what

00:04:14,670 --> 00:04:19,079
you have on your systems today so I

00:04:17,010 --> 00:04:21,630
think maybe the fact that you know

00:04:19,079 --> 00:04:24,840
machines have become so large that could

00:04:21,630 --> 00:04:27,120
be a contributing factor but I think the

00:04:24,840 --> 00:04:29,220
fact that you want to run so many things

00:04:27,120 --> 00:04:31,889
at the same time it's kind of the main

00:04:29,220 --> 00:04:34,010
factor for for why operating systems are

00:04:31,889 --> 00:04:38,479
very complex these days

00:04:34,010 --> 00:04:41,190
so let's deconstruct let's try to make

00:04:38,479 --> 00:04:43,440
the smallest possible operating system

00:04:41,190 --> 00:04:45,330
for running hello world I know it's

00:04:43,440 --> 00:04:47,190
probably not an interesting example but

00:04:45,330 --> 00:04:50,040
it kind of is and we'll get somewhere

00:04:47,190 --> 00:04:51,630
more interesting later so I'd like to

00:04:50,040 --> 00:04:54,630
start here this is what happens when you

00:04:51,630 --> 00:04:58,200
start your computer with an empty hard

00:04:54,630 --> 00:05:01,500
drive ok and this is actually how

00:04:58,200 --> 00:05:03,600
include OS started I was doing research

00:05:01,500 --> 00:05:05,130
into cloud computing and I was

00:05:03,600 --> 00:05:07,620
interested in virtual machines I wanted

00:05:05,130 --> 00:05:09,330
to run thousands or actually if I could

00:05:07,620 --> 00:05:11,010
I would like to run millions of virtual

00:05:09,330 --> 00:05:12,560
machines to do interesting research on

00:05:11,010 --> 00:05:14,700
cloud computing so I thought you know

00:05:12,560 --> 00:05:16,169
actually HelloWorld is quite a good

00:05:14,700 --> 00:05:17,970
place to start to figure out you know

00:05:16,169 --> 00:05:21,240
what is it that makes these virtual

00:05:17,970 --> 00:05:24,360
machines large and how can we make them

00:05:21,240 --> 00:05:27,330
smaller so I'd like to answer this

00:05:24,360 --> 00:05:29,490
question and I'd like to answer it in

00:05:27,330 --> 00:05:31,530
the spirit of darkness no strips zero

00:05:29,490 --> 00:05:34,530
overhead principle now why should we

00:05:31,530 --> 00:05:40,310
listen to be honest restroom well he

00:05:34,530 --> 00:05:40,310
actually just won a medal right yeah

00:05:40,830 --> 00:05:48,070
did you guys win medals I didn't win any

00:05:44,710 --> 00:05:48,669
medals so I'm inclined to listen to this

00:05:48,070 --> 00:05:51,130
guy

00:05:48,669 --> 00:05:53,590
so let's try to boot your service and

00:05:51,130 --> 00:05:54,970
and to apply this No zero over principle

00:05:53,590 --> 00:05:56,110
and not pay for what you don't need

00:05:54,970 --> 00:06:02,320
right

00:05:56,110 --> 00:06:05,350
is it possible yes it's possible this is

00:06:02,320 --> 00:06:08,050
a bootable HelloWorld program if you're

00:06:05,350 --> 00:06:10,060
interested in x86 assembly code you

00:06:08,050 --> 00:06:13,330
might want to study this I'm not going

00:06:10,060 --> 00:06:16,900
to go into the details it's about 30

00:06:13,330 --> 00:06:22,390
lines so that wasn't so hard right I

00:06:16,900 --> 00:06:24,400
proved it hello world well I wrote hello

00:06:22,390 --> 00:06:28,900
world and this is how you boot it it's

00:06:24,400 --> 00:06:32,440
two lines to assemble and then use in

00:06:28,900 --> 00:06:34,419
this case a virtualization tool like

00:06:32,440 --> 00:06:36,190
ki-moon that's a that's a hypervisor

00:06:34,419 --> 00:06:39,280
that's something you can use on Linux or

00:06:36,190 --> 00:06:41,440
Mac you could also you boot this on

00:06:39,280 --> 00:06:45,580
VirtualBox or you could put it on your

00:06:41,440 --> 00:06:48,340
physical PC so this is what happens

00:06:45,580 --> 00:06:51,640
hello world so did I just do to the

00:06:48,340 --> 00:06:54,040
world yes

00:06:51,640 --> 00:06:58,510
this will also work on hardware so I

00:06:54,040 --> 00:07:01,330
would say I booted it on a PC oh but

00:06:58,510 --> 00:07:04,440
these guys don't agree they're actually

00:07:01,330 --> 00:07:06,700
gathering angrily outside Town Hall

00:07:04,440 --> 00:07:07,660
demonstrating pointing out what's wrong

00:07:06,700 --> 00:07:09,490
with this example

00:07:07,660 --> 00:07:11,890
first of all it's not C right he

00:07:09,490 --> 00:07:14,380
specified that he wanted to put his see

00:07:11,890 --> 00:07:16,090
hello world program okay so I gave him

00:07:14,380 --> 00:07:19,240
an assembly version that's that's not

00:07:16,090 --> 00:07:22,720
quite good enough 16 bits yes you know

00:07:19,240 --> 00:07:25,150
well catched well caught it's it's a 16

00:07:22,720 --> 00:07:27,550
bit instruction set you're using when

00:07:25,150 --> 00:07:30,729
you're when you're starting so and also

00:07:27,550 --> 00:07:33,789
you know one guy noticed that this is a

00:07:30,729 --> 00:07:35,830
this is not a generalizable solution you

00:07:33,789 --> 00:07:39,010
know inside of that first boot sector

00:07:35,830 --> 00:07:40,240
will only fit 512 bytes it's ok for all

00:07:39,010 --> 00:07:43,030
our world but you can't do much else

00:07:40,240 --> 00:07:46,360
well you can do a lot more but but not

00:07:43,030 --> 00:07:47,680
it's not completely generalizable so all

00:07:46,360 --> 00:07:50,830
this guy isn't angry he's just

00:07:47,680 --> 00:07:52,110
determined and ok so he's not happy with

00:07:50,830 --> 00:07:55,650
two lines he was

00:07:52,110 --> 00:07:58,260
one line so a one-liner to build and

00:07:55,650 --> 00:08:01,110
boot a hello world program that's

00:07:58,260 --> 00:08:02,540
something we were actually made in and

00:08:01,110 --> 00:08:05,880
we'll go through that

00:08:02,540 --> 00:08:08,640
so first let's address these issues the

00:08:05,880 --> 00:08:10,920
fact that it's not C or C++ that could

00:08:08,640 --> 00:08:12,330
be easily have alleviated obviously the

00:08:10,920 --> 00:08:15,270
compiler is much better at writing

00:08:12,330 --> 00:08:18,450
assembly then the I am so it could

00:08:15,270 --> 00:08:20,520
probably at least this for loop here and

00:08:18,450 --> 00:08:23,910
the actual print statement could be much

00:08:20,520 --> 00:08:25,410
nicer probably if you have if you a lot

00:08:23,910 --> 00:08:27,930
of the compiler to just output this code

00:08:25,410 --> 00:08:29,690
but there are some other problems we are

00:08:27,930 --> 00:08:31,920
using some privileged instructions here

00:08:29,690 --> 00:08:35,250
you can see that I'm saying

00:08:31,920 --> 00:08:35,670
CLI and halt at the list above the arrow

00:08:35,250 --> 00:08:39,990
there

00:08:35,670 --> 00:08:43,020
those are privileged also at the bottom

00:08:39,990 --> 00:08:45,390
I have this special statement - - to

00:08:43,020 --> 00:08:51,000
fill out the rest of the binary with

00:08:45,390 --> 00:08:54,330
zeros so that in total it forms a 512

00:08:51,000 --> 00:08:57,270
byte file and at the very end the last 2

00:08:54,330 --> 00:08:59,790
bytes is supposed to be a a 5 5 that's

00:08:57,270 --> 00:09:02,730
like the magical signature for a boot

00:08:59,790 --> 00:09:04,140
for the BIOS and it sees those last two

00:09:02,730 --> 00:09:05,790
bytes and then you know you're

00:09:04,140 --> 00:09:09,060
absolutely certain this has to be a

00:09:05,790 --> 00:09:14,160
high-quality bootloader some ayats are

00:09:09,060 --> 00:09:17,280
at the end right ok so the fact that is

00:09:14,160 --> 00:09:17,670
16 bits is that a problem for a long

00:09:17,280 --> 00:09:20,160
world

00:09:17,670 --> 00:09:22,080
maybe not it's not very generalizable

00:09:20,160 --> 00:09:24,480
obviously if you want to do something

00:09:22,080 --> 00:09:27,420
more interesting like compute do

00:09:24,480 --> 00:09:30,030
something critter cryptographic alure do

00:09:27,420 --> 00:09:32,010
do something that require speed and

00:09:30,030 --> 00:09:35,010
performance then you of course you'd

00:09:32,010 --> 00:09:36,870
expect my system to be able to alleviate

00:09:35,010 --> 00:09:42,090
the full instruction set of the

00:09:36,870 --> 00:09:44,630
architecture so let's consider this boot

00:09:42,090 --> 00:09:47,700
one liner that we're trying to make here

00:09:44,630 --> 00:09:51,030
we just want to say boot and then your

00:09:47,700 --> 00:09:52,560
program right so that statement has some

00:09:51,030 --> 00:09:55,140
interesting side effects and we're going

00:09:52,560 --> 00:09:57,090
to look at some side effects of various

00:09:55,140 --> 00:09:58,620
things that pop up when we're trying to

00:09:57,090 --> 00:09:59,940
make an operating system and we're

00:09:58,620 --> 00:10:02,010
trying we're going to try to address

00:09:59,940 --> 00:10:05,170
this 0 over principle to those to those

00:10:02,010 --> 00:10:07,910
side effects or those question

00:10:05,170 --> 00:10:09,589
so obviously it was an assembly solution

00:10:07,910 --> 00:10:11,600
we he wanted to see solutions and we

00:10:09,589 --> 00:10:15,800
have to link with printf that's part of

00:10:11,600 --> 00:10:18,079
the C standard library now printf isn't

00:10:15,800 --> 00:10:20,480
going to randomly start writing pixels

00:10:18,079 --> 00:10:22,399
on your screen right and you're you're

00:10:20,480 --> 00:10:24,079
probably happy it won't and it's not

00:10:22,399 --> 00:10:26,810
going to decide actually where that

00:10:24,079 --> 00:10:28,160
output is going printf is just a library

00:10:26,810 --> 00:10:31,189
function and of course it needs a

00:10:28,160 --> 00:10:32,839
back-end in terms of a system call so

00:10:31,189 --> 00:10:36,410
we're gonna have to implement that as

00:10:32,839 --> 00:10:38,149
well in origin to - you know satisfy the

00:10:36,410 --> 00:10:40,670
guy we didn't like that we used sixteen

00:10:38,149 --> 00:10:43,750
bits we need to switch to 32 or 64-bit

00:10:40,670 --> 00:10:48,050
mode we need to load an arbitrary sized

00:10:43,750 --> 00:10:51,410
C++ program not just 512 bytes so this

00:10:48,050 --> 00:10:53,750
becomes a generalizable solution you

00:10:51,410 --> 00:10:57,019
probably also really quickly want us to

00:10:53,750 --> 00:10:58,790
initialize heap and stack right at least

00:10:57,019 --> 00:11:00,829
you want the same stack so that you can

00:10:58,790 --> 00:11:03,980
use functions call functions have stack

00:11:00,829 --> 00:11:06,470
frames be created and destroyed without

00:11:03,980 --> 00:11:08,269
for example colliding with the heap you

00:11:06,470 --> 00:11:09,980
also want the heap so that you know it's

00:11:08,269 --> 00:11:12,769
a safe area where you know that you can

00:11:09,980 --> 00:11:14,300
use my local friends or you probably

00:11:12,769 --> 00:11:18,050
shouldn't use my local friends but you

00:11:14,300 --> 00:11:20,060
should use more sophisticated C++

00:11:18,050 --> 00:11:22,220
techniques for memory management and

00:11:20,060 --> 00:11:24,199
then eventually you want me to jump to

00:11:22,220 --> 00:11:26,689
your program and you also want me to

00:11:24,199 --> 00:11:30,170
kind of handle displaying that output on

00:11:26,689 --> 00:11:33,550
the screen so the linker can take care

00:11:30,170 --> 00:11:36,110
of the linking part if I provide a

00:11:33,550 --> 00:11:37,490
statically compiled C library and we do

00:11:36,110 --> 00:11:40,579
that that's part of the bundle you get

00:11:37,490 --> 00:11:43,459
when you installed include oh s now this

00:11:40,579 --> 00:11:46,550
part let's try to implement it how can

00:11:43,459 --> 00:11:51,769
we make a simple as simple the simplest

00:11:46,550 --> 00:11:53,540
possible back end for printf so printf

00:11:51,769 --> 00:11:55,910
is part of a library and of course this

00:11:53,540 --> 00:12:00,050
library will already have programmed

00:11:55,910 --> 00:12:01,910
into it a calls to the operating system

00:12:00,050 --> 00:12:05,000
and that's what we have to implement so

00:12:01,910 --> 00:12:07,490
this is the set of system calls that the

00:12:05,000 --> 00:12:09,889
new lip it's the version of lip see

00:12:07,490 --> 00:12:12,079
we're using so this is the minimal set

00:12:09,889 --> 00:12:14,630
of system calls that you need to

00:12:12,079 --> 00:12:17,430
implement in order to run Lib C

00:12:14,630 --> 00:12:19,620
so let's see what's needed for printf I

00:12:17,430 --> 00:12:23,190
think you can get away with only right

00:12:19,620 --> 00:12:25,110
there might be a call to is a TTY for

00:12:23,190 --> 00:12:26,940
printf it will check you know is this a

00:12:25,110 --> 00:12:29,790
terminal or is it a file do I have to do

00:12:26,940 --> 00:12:31,620
some output first but you know the one

00:12:29,790 --> 00:12:33,240
that's actually doing some IO and

00:12:31,620 --> 00:12:36,839
actually doing something dangerous

00:12:33,240 --> 00:12:40,529
that's the right statement so let's make

00:12:36,839 --> 00:12:42,540
a back end so this is a complete back

00:12:40,529 --> 00:12:45,510
end for printf it's a it's a minimal

00:12:42,540 --> 00:12:48,750
back end but it's complete and let's

00:12:45,510 --> 00:12:50,430
take a look so first we have some

00:12:48,750 --> 00:12:53,370
abstractions around the in and out

00:12:50,430 --> 00:12:56,130
instructions you can see I'm saying I'm

00:12:53,370 --> 00:12:57,839
using some inline assembly here that's

00:12:56,130 --> 00:12:59,550
because these are privileged

00:12:57,839 --> 00:13:01,800
instructions that the compiler isn't

00:12:59,550 --> 00:13:03,720
going to randomly just emit when you're

00:13:01,800 --> 00:13:06,330
building on program the reason for that

00:13:03,720 --> 00:13:08,640
is if you try to run these instructions

00:13:06,330 --> 00:13:12,089
on a normal user space linux or windows

00:13:08,640 --> 00:13:18,300
binary what's going to happen you'll get

00:13:12,089 --> 00:13:20,130
killed mercilessly right but okay we'll

00:13:18,300 --> 00:13:22,200
get to that part but you know we need

00:13:20,130 --> 00:13:24,810
them for this exercise of making a

00:13:22,200 --> 00:13:28,350
driver so we start by making some

00:13:24,810 --> 00:13:29,940
abstractions around those now we make a

00:13:28,350 --> 00:13:31,290
serial port driver that's quite small

00:13:29,940 --> 00:13:33,470
and this is one of the reasons why I

00:13:31,290 --> 00:13:36,240
would like the serial port it's the only

00:13:33,470 --> 00:13:37,830
you know peripheral that that really

00:13:36,240 --> 00:13:39,150
doesn't need anything in terms of a

00:13:37,830 --> 00:13:41,310
driver you can just start talking to

00:13:39,150 --> 00:13:43,290
that port and it's going to work you

00:13:41,310 --> 00:13:45,270
might need some initialization in

00:13:43,290 --> 00:13:47,130
advance you can you can look at the

00:13:45,270 --> 00:13:48,930
comment there to see where an include OS

00:13:47,130 --> 00:13:51,900
you can find this exact function we have

00:13:48,930 --> 00:13:53,339
this and then you know on some systems

00:13:51,900 --> 00:13:55,560
some platforms there might be some

00:13:53,339 --> 00:13:59,850
initialization ahead but it's really

00:13:55,560 --> 00:14:01,470
very straightforward so it's a for loop

00:13:59,850 --> 00:14:02,910
it's it's reading from the status

00:14:01,470 --> 00:14:04,620
register and it's checking that you know

00:14:02,910 --> 00:14:07,080
is this serial port ready to receive

00:14:04,620 --> 00:14:10,560
data and when once it is ready you know

00:14:07,080 --> 00:14:13,709
then you actually output the byte one by

00:14:10,560 --> 00:14:17,400
one and then we can do our first system

00:14:13,709 --> 00:14:19,380
call so we implement right let's ignore

00:14:17,400 --> 00:14:21,540
the first parameter for now and just see

00:14:19,380 --> 00:14:23,900
it's a pointer in the length so we pass

00:14:21,540 --> 00:14:26,649
that on to the serial print statement

00:14:23,900 --> 00:14:29,449
and that's

00:14:26,649 --> 00:14:31,040
should probably be implemented a bit

00:14:29,449 --> 00:14:33,920
more carefully but you know this is

00:14:31,040 --> 00:14:36,649
going to work and now finally we can

00:14:33,920 --> 00:14:38,949
make our int main printf hello world

00:14:36,649 --> 00:14:42,529
which is something I expect is a

00:14:38,949 --> 00:14:44,740
reasonable answer to the original

00:14:42,529 --> 00:14:47,839
question on Stack Overflow we have

00:14:44,740 --> 00:14:50,750
allowed you to use printf that's normal

00:14:47,839 --> 00:14:56,060
see we have implemented the back end for

00:14:50,750 --> 00:14:59,269
C and we have also you know done the

00:14:56,060 --> 00:15:00,889
necessary things to bake this together

00:14:59,269 --> 00:15:05,180
into a binary and we're going to look at

00:15:00,889 --> 00:15:06,910
some of the details of that oh these

00:15:05,180 --> 00:15:10,279
guys are worried

00:15:06,910 --> 00:15:12,529
how about kernel protection are you

00:15:10,279 --> 00:15:14,540
using blocking i/o that's crazy isn't

00:15:12,529 --> 00:15:19,970
out privileged yeah I mentioned that we

00:15:14,540 --> 00:15:22,430
probably have to address it so let's

00:15:19,970 --> 00:15:25,970
take a look there are some tricky side

00:15:22,430 --> 00:15:27,740
effects in B that's in BA in bite you

00:15:25,970 --> 00:15:31,100
know that's again using a privileged

00:15:27,740 --> 00:15:32,779
instruction but the important to heart

00:15:31,100 --> 00:15:37,910
here is that this while loop is going to

00:15:32,779 --> 00:15:40,190
be blocking okay so this is one way of

00:15:37,910 --> 00:15:43,220
communicating with devices this is a way

00:15:40,190 --> 00:15:46,370
you could implement a networking you

00:15:43,220 --> 00:15:48,170
could have port i/o talk directly to the

00:15:46,370 --> 00:15:49,819
device using in and out ports the

00:15:48,170 --> 00:15:55,459
problem with that is the CPU is going to

00:15:49,819 --> 00:15:58,370
be occupied 100% of the time and of

00:15:55,459 --> 00:15:59,870
course that's not very efficient so

00:15:58,370 --> 00:16:01,910
another thing you have to deal with is

00:15:59,870 --> 00:16:05,600
privileged instructions because they are

00:16:01,910 --> 00:16:08,630
supposed to trap we'll get back to that

00:16:05,600 --> 00:16:10,370
but you know it's also an interesting

00:16:08,630 --> 00:16:13,010
question should we context which hair

00:16:10,370 --> 00:16:14,690
usually when you do system calls I just

00:16:13,010 --> 00:16:17,720
call this a system call and nobody

00:16:14,690 --> 00:16:20,089
reacted you know but usually what our

00:16:17,720 --> 00:16:22,579
system calls learners just function

00:16:20,089 --> 00:16:26,540
calls are they are they just function

00:16:22,579 --> 00:16:30,319
calls no they're not system calls

00:16:26,540 --> 00:16:31,850
usually trigger a context switch where

00:16:30,319 --> 00:16:34,130
your process is actually completely

00:16:31,850 --> 00:16:36,350
scheduled out the kernel is scheduled in

00:16:34,130 --> 00:16:37,110
and it's running in a different CPU

00:16:36,350 --> 00:16:39,390
protection

00:16:37,110 --> 00:16:42,149
you know and that's necessary in order

00:16:39,390 --> 00:16:44,610
to do these privileged instructions so

00:16:42,149 --> 00:16:46,589
usually a system call isn't just a

00:16:44,610 --> 00:16:48,630
function call so we should probably ask

00:16:46,589 --> 00:16:51,089
ourselves well is this correct because

00:16:48,630 --> 00:16:52,500
this works so what's wrong is there

00:16:51,089 --> 00:16:55,560
something wrong here is there something

00:16:52,500 --> 00:16:57,690
important that I haven't implemented you

00:16:55,560 --> 00:16:59,579
know so we could ask ourselves that

00:16:57,690 --> 00:17:02,310
question should we do a complex which

00:16:59,579 --> 00:17:04,740
should we enter into a higher protection

00:17:02,310 --> 00:17:08,970
level or isn't that necessary

00:17:04,740 --> 00:17:10,049
what's the zero overt solution so we've

00:17:08,970 --> 00:17:12,600
talked a little bit about the privilege

00:17:10,049 --> 00:17:15,530
in context which is the important thing

00:17:12,600 --> 00:17:17,520
to point out is who are you protecting

00:17:15,530 --> 00:17:20,669
or are you actually trying to protect

00:17:17,520 --> 00:17:22,140
all right because these sensitive

00:17:20,669 --> 00:17:23,939
instructions or privileged instructions

00:17:22,140 --> 00:17:26,760
they are going to cause a trap but only

00:17:23,939 --> 00:17:29,190
if you are in a in an unprivileged state

00:17:26,760 --> 00:17:30,929
if the CPU is set to be an unprivileged

00:17:29,190 --> 00:17:33,600
state that's what it's going to cause a

00:17:30,929 --> 00:17:35,520
trap if you are in ring zero the default

00:17:33,600 --> 00:17:37,290
state and the most privileged state is

00:17:35,520 --> 00:17:40,140
it going to cause a trap no of course

00:17:37,290 --> 00:17:41,549
not because somebody at some point has

00:17:40,140 --> 00:17:47,400
to be able to actually talk to the

00:17:41,549 --> 00:17:50,250
devices right so I say that the zero of

00:17:47,400 --> 00:17:52,740
red solution for some use cases not all

00:17:50,250 --> 00:17:54,450
use cases is to stay in ring zero it's a

00:17:52,740 --> 00:17:56,549
surprising amount of things you can do

00:17:54,450 --> 00:17:58,470
there so yes you have a lot of privilege

00:17:56,549 --> 00:18:00,120
but remember that the compiler isn't

00:17:58,470 --> 00:18:02,460
going to emit these privileged

00:18:00,120 --> 00:18:06,390
instructions at random right so if you

00:18:02,460 --> 00:18:08,190
write normal C++ it's going to emit non

00:18:06,390 --> 00:18:11,580
privileged instructions and that's going

00:18:08,190 --> 00:18:12,600
to be quite okay so but if you want to

00:18:11,580 --> 00:18:14,520
start doing these privileged

00:18:12,600 --> 00:18:19,049
instructions you can but that's not

00:18:14,520 --> 00:18:21,540
going to be writing normal C++ so poor

00:18:19,049 --> 00:18:23,309
tile versus direct memory access the rip

00:18:21,540 --> 00:18:25,620
memory access is the usual way we do

00:18:23,309 --> 00:18:27,179
this and I don't think we're going to

00:18:25,620 --> 00:18:29,730
have time to look into the details but

00:18:27,179 --> 00:18:32,940
our network drivers are implemented in

00:18:29,730 --> 00:18:36,299
such a way so that we just use port i/o

00:18:32,940 --> 00:18:38,370
for signaling with a physical device and

00:18:36,299 --> 00:18:39,929
then for initializing the physical

00:18:38,370 --> 00:18:42,870
device we're not using it to transport

00:18:39,929 --> 00:18:45,960
data okay so the physical network the

00:18:42,870 --> 00:18:47,880
device is going to receive the packets

00:18:45,960 --> 00:18:48,180
off of the physical wire is going to put

00:18:47,880 --> 00:18:50,160
those

00:18:48,180 --> 00:18:51,780
gets up in my memory and then is going

00:18:50,160 --> 00:18:54,390
to interrupt me and tell me now you have

00:18:51,780 --> 00:18:56,520
packets right so I don't have to spend a

00:18:54,390 --> 00:18:57,210
lot of CPU cycles just fetching all

00:18:56,520 --> 00:18:58,620
these packets

00:18:57,210 --> 00:19:00,690
I'm just getting notified when it

00:18:58,620 --> 00:19:05,130
already there and the same thing goes in

00:19:00,690 --> 00:19:09,120
Reverse so for something that's even

00:19:05,130 --> 00:19:12,510
remotely performant you know we have to

00:19:09,120 --> 00:19:14,520
use the MA so so I think that's the

00:19:12,510 --> 00:19:16,620
serial over and solution this this case

00:19:14,520 --> 00:19:20,670
but but you know it might not be that

00:19:16,620 --> 00:19:22,920
simple and clear cut all the time so we

00:19:20,670 --> 00:19:25,050
make it platform dependent we are

00:19:22,920 --> 00:19:29,010
bundling parts of include OS into

00:19:25,050 --> 00:19:31,140
different bundles and one plat and we're

00:19:29,010 --> 00:19:34,650
called calling them platforms and we

00:19:31,140 --> 00:19:37,080
have one platform is called x86 PC and

00:19:34,650 --> 00:19:39,420
that contains all the components you

00:19:37,080 --> 00:19:41,460
need in order to talk to a modern x86

00:19:39,420 --> 00:19:43,500
hardware platform with advanced

00:19:41,460 --> 00:19:45,810
interrupt controllers advanced IQ

00:19:43,500 --> 00:19:48,300
controllers everything but then we also

00:19:45,810 --> 00:19:50,340
have this x8 a signal if you know that

00:19:48,300 --> 00:19:52,080
your program doesn't need any of that

00:19:50,340 --> 00:19:54,240
stuff for example we're making a chain

00:19:52,080 --> 00:19:57,390
loader all it needs is to read a binary

00:19:54,240 --> 00:20:00,720
and jump to it you know in that case you

00:19:57,390 --> 00:20:02,430
might not want to go through the trouble

00:20:00,720 --> 00:20:06,270
of you know initializing all of that

00:20:02,430 --> 00:20:08,430
hardware so let's get back to booting

00:20:06,270 --> 00:20:10,740
and let's reuse include OS parts to get

00:20:08,430 --> 00:20:13,140
this C program booted okay

00:20:10,740 --> 00:20:17,130
so the linker part is done we

00:20:13,140 --> 00:20:19,620
implemented the syscall so now we you

00:20:17,130 --> 00:20:21,030
need a boot loader we're not going to

00:20:19,620 --> 00:20:22,710
put this code inside the boot loader

00:20:21,030 --> 00:20:24,690
anymore which is essentially what we did

00:20:22,710 --> 00:20:27,150
in the first example but it only fits

00:20:24,690 --> 00:20:29,160
512 bytes so we're relying on a

00:20:27,150 --> 00:20:31,710
third-party boot loader or you could use

00:20:29,160 --> 00:20:34,860
our very simplistic rudimentary boot

00:20:31,710 --> 00:20:36,870
loader that we made to be able to do the

00:20:34,860 --> 00:20:39,210
smallest possible binary that's just a

00:20:36,870 --> 00:20:41,520
512 byte boot loader is going to lift

00:20:39,210 --> 00:20:44,010
your code up put it up in memory and

00:20:41,520 --> 00:20:47,190
then jump to it so this boot loader is

00:20:44,010 --> 00:20:49,890
going to switch to 32-bit we can bake in

00:20:47,190 --> 00:20:51,750
also or we by default we're going to

00:20:49,890 --> 00:20:53,610
also bake in the necessary assembler to

00:20:51,750 --> 00:20:55,770
the very beginning of your binary so

00:20:53,610 --> 00:20:56,880
that it will also switch into 64-bit so

00:20:55,770 --> 00:20:59,250
that you'll start in

00:20:56,880 --> 00:21:02,520
kind of in the most modern and x86

00:20:59,250 --> 00:21:05,040
environment when you boot so loading

00:21:02,520 --> 00:21:07,260
let's take you care of by the bootloader

00:21:05,040 --> 00:21:09,510
we also initialize heap stack in

00:21:07,260 --> 00:21:11,400
business etc we expect that you want

00:21:09,510 --> 00:21:16,830
this for something remotely more

00:21:11,400 --> 00:21:19,110
interesting than then hello world so you

00:21:16,830 --> 00:21:20,580
can look at that code there kernels

00:21:19,110 --> 00:21:23,460
start that's where all that is your

00:21:20,580 --> 00:21:24,930
that's also the the good place to start

00:21:23,460 --> 00:21:27,390
if you're interested in writing your own

00:21:24,930 --> 00:21:28,860
kernel so we have all these tooling

00:21:27,390 --> 00:21:30,690
around to make it easier to the boot and

00:21:28,860 --> 00:21:32,670
bake things in as a bootable binary and

00:21:30,690 --> 00:21:34,500
you know this is where you start if you

00:21:32,670 --> 00:21:35,850
want to implement your roll and then

00:21:34,500 --> 00:21:38,010
display the output on the screen we

00:21:35,850 --> 00:21:40,170
showed the original bootloader were

00:21:38,010 --> 00:21:42,090
suppose actually writing bytes directly

00:21:40,170 --> 00:21:44,640
into video memory so that's one way to

00:21:42,090 --> 00:21:46,350
get pixels on the screen we also showed

00:21:44,640 --> 00:21:47,130
you how to do serial port which is nicer

00:21:46,350 --> 00:21:49,170
if you're running in a virtual

00:21:47,130 --> 00:21:52,340
environment you'll get the output is

00:21:49,170 --> 00:21:55,410
actual data down out into your terminal

00:21:52,340 --> 00:21:57,360
so here's a one-liner we made this

00:21:55,410 --> 00:21:59,850
little tool it's a Python script and

00:21:57,360 --> 00:22:01,500
it's actually controlling ki-moon and

00:21:59,850 --> 00:22:03,060
we're going to work on you know

00:22:01,500 --> 00:22:05,820
improving that but it's quite useful

00:22:03,060 --> 00:22:06,870
already so if you have that code just

00:22:05,820 --> 00:22:08,790
the code that I had in the previous

00:22:06,870 --> 00:22:11,370
slide all the C code with the printf

00:22:08,790 --> 00:22:13,560
back end etc you put that in a file

00:22:11,370 --> 00:22:15,360
called service cpp you say boot dot

00:22:13,560 --> 00:22:19,560
after having installed include OS then

00:22:15,360 --> 00:22:21,630
this is going to happen okay so it's

00:22:19,560 --> 00:22:23,670
booted your hello world c program and it

00:22:21,630 --> 00:22:27,900
did it in a one-liner that was kind of

00:22:23,670 --> 00:22:30,060
the mission for this first project so

00:22:27,900 --> 00:22:33,330
this is an overview of the tooling we

00:22:30,060 --> 00:22:35,340
have libraries we have your program and

00:22:33,330 --> 00:22:37,890
it's going to for example if you say

00:22:35,340 --> 00:22:41,040
printf you know then the linker is going

00:22:37,890 --> 00:22:43,220
to pull in what the printer function the

00:22:41,040 --> 00:22:46,170
printer function again is the back end

00:22:43,220 --> 00:22:48,510
the system call and that's located in

00:22:46,170 --> 00:22:51,090
the OS dot a library so that's going to

00:22:48,510 --> 00:22:55,220
get pulled in you can attach drivers for

00:22:51,090 --> 00:22:57,720
various platforms and and you can also

00:22:55,220 --> 00:23:03,090
embed a memory disk so that you have a

00:22:57,720 --> 00:23:04,890
file system etc in there so with all

00:23:03,090 --> 00:23:07,890
that put together you don't have to

00:23:04,890 --> 00:23:10,060
write your own back-end for printf you

00:23:07,890 --> 00:23:13,390
can actually just write a normal

00:23:10,060 --> 00:23:15,780
C++ HelloWorld program and you can say

00:23:13,390 --> 00:23:18,460
you know int main printf hello world and

00:23:15,780 --> 00:23:21,370
you can just say boot dot and that's

00:23:18,460 --> 00:23:23,440
going to come up and do this slightly

00:23:21,370 --> 00:23:25,120
different output because we don't use

00:23:23,440 --> 00:23:27,280
the main signature by default but we

00:23:25,120 --> 00:23:29,290
made it you know made it into a weak

00:23:27,280 --> 00:23:32,560
symbol so that you can supply the main

00:23:29,290 --> 00:23:34,780
if that's what you prefer and and you

00:23:32,560 --> 00:23:37,300
know when Lane returns what's left to do

00:23:34,780 --> 00:23:38,620
I'm a single process operating system I

00:23:37,300 --> 00:23:40,480
can't really do anything else

00:23:38,620 --> 00:23:42,130
you know you're you're in charge your

00:23:40,480 --> 00:23:44,730
program exited so I'm just reporting the

00:23:42,130 --> 00:23:44,730
exit status

00:23:45,750 --> 00:23:52,660
these guys are rioting again hello world

00:23:49,540 --> 00:23:56,050
doesn't pay the rent so what pays the

00:23:52,660 --> 00:23:57,880
rent they want the web server so they

00:23:56,050 --> 00:23:59,830
want me to show you how to boot a simple

00:23:57,880 --> 00:24:01,870
web server and how to implement the back

00:23:59,830 --> 00:24:07,660
end for a simple web server should we do

00:24:01,870 --> 00:24:09,100
that yeah just use HTTP right not that

00:24:07,660 --> 00:24:12,580
hard how hard could it be

00:24:09,100 --> 00:24:14,380
I'm telling you that 90% of Inc of our

00:24:12,580 --> 00:24:16,690
efforts in include OS has gone into

00:24:14,380 --> 00:24:19,360
making that networking subsystem it's

00:24:16,690 --> 00:24:20,860
not by any means trivial we've done it

00:24:19,360 --> 00:24:24,430
and it's actually working really well

00:24:20,860 --> 00:24:27,550
but so I can't show you that in detail

00:24:24,430 --> 00:24:32,290
but I'm going to at least address your

00:24:27,550 --> 00:24:33,910
questions ok zero that's that's quite a

00:24:32,290 --> 00:24:36,010
tall order but you know we're getting

00:24:33,910 --> 00:24:38,680
there we actually we are there at the

00:24:36,010 --> 00:24:40,300
point where we can do this so let's see

00:24:38,680 --> 00:24:44,080
if we can get help from the system calls

00:24:40,300 --> 00:24:46,450
I want to write a hello world web server

00:24:44,080 --> 00:24:48,430
I have only system calls maybe if I

00:24:46,450 --> 00:24:51,220
implement all of them you know not just

00:24:48,430 --> 00:24:54,300
the right one maybe maybe I can get a

00:24:51,220 --> 00:24:57,610
web server do you think I don't think

00:24:54,300 --> 00:25:02,680
but let's take a look so the green one

00:24:57,610 --> 00:25:05,140
the s break that means extend the memory

00:25:02,680 --> 00:25:07,900
assigned to this process actually just

00:25:05,140 --> 00:25:09,700
give it more space that's actually the

00:25:07,900 --> 00:25:13,540
back end for malloc so malloc is

00:25:09,700 --> 00:25:15,790
provided by the Lipsy it's just an

00:25:13,540 --> 00:25:19,210
algorithm for handing out buffers of

00:25:15,790 --> 00:25:21,820
different size sizes and then it uses a

00:25:19,210 --> 00:25:25,630
very simple cisco s break in order to

00:25:21,820 --> 00:25:28,510
by that so that's useful certainly we

00:25:25,630 --> 00:25:29,320
need it but but it's not going to give

00:25:28,510 --> 00:25:31,090
us what we need

00:25:29,320 --> 00:25:33,250
but this reads this call you know that

00:25:31,090 --> 00:25:35,830
might be useful for actually reading off

00:25:33,250 --> 00:25:37,450
a socket you know you could use it for

00:25:35,830 --> 00:25:42,250
reading of a socket right so maybe we

00:25:37,450 --> 00:25:45,550
can start using that so this is a POSIX

00:25:42,250 --> 00:25:48,880
signature for the read function call or

00:25:45,550 --> 00:25:51,160
system call so maybe that's a good

00:25:48,880 --> 00:25:55,620
starting point or maybe it isn't it is

00:25:51,160 --> 00:25:58,870
this how you would start in modern C++

00:25:55,620 --> 00:26:02,620
if they were writing the backend for a

00:25:58,870 --> 00:26:04,960
web for a web server if you were writing

00:26:02,620 --> 00:26:07,570
that you know networking subsystem in

00:26:04,960 --> 00:26:08,080
C++ is this how we would start who would

00:26:07,570 --> 00:26:12,990
do that

00:26:08,080 --> 00:26:16,540
this is beautiful C++ well let's see

00:26:12,990 --> 00:26:19,690
well if you read the specification it's

00:26:16,540 --> 00:26:23,020
blocking by default so that means one of

00:26:19,690 --> 00:26:24,070
two things it's supposed to block right

00:26:23,020 --> 00:26:26,020
because you're supposed to have

00:26:24,070 --> 00:26:28,360
continuous execution here you're

00:26:26,020 --> 00:26:30,070
supposed to just say read how many bytes

00:26:28,360 --> 00:26:31,510
you want to read off of the TCP stream

00:26:30,070 --> 00:26:33,580
which might not be open yet who knows

00:26:31,510 --> 00:26:35,440
but you know you're supposed to just say

00:26:33,580 --> 00:26:38,110
read and it's going to sit there and

00:26:35,440 --> 00:26:39,460
wait until all those bytes are being

00:26:38,110 --> 00:26:42,850
have been filled

00:26:39,460 --> 00:26:48,190
there are async options to this call but

00:26:42,850 --> 00:26:51,160
the default is the block so I have a

00:26:48,190 --> 00:26:53,800
choice to either spin in a spinning loop

00:26:51,160 --> 00:26:55,210
spending a hundred percent CPU or I

00:26:53,800 --> 00:26:58,300
could do a context switch position which

00:26:55,210 --> 00:27:01,690
is really costly so I think this

00:26:58,300 --> 00:27:03,580
approach just already here I'm saying

00:27:01,690 --> 00:27:05,680
that's not that doesn't sound like zero

00:27:03,580 --> 00:27:08,110
overhead these context switches are

00:27:05,680 --> 00:27:09,970
costly I have to implement some kind of

00:27:08,110 --> 00:27:11,860
threading and some kind of stack

00:27:09,970 --> 00:27:14,460
switches I've multiple stacks that I

00:27:11,860 --> 00:27:17,110
have to juggle that's a lot of stuff

00:27:14,460 --> 00:27:19,480
just to be able to print hello world in

00:27:17,110 --> 00:27:22,530
a web server right and it might come in

00:27:19,480 --> 00:27:25,900
handy it might be that we need to have

00:27:22,530 --> 00:27:27,790
full-on pre-emptive scheduling with all

00:27:25,900 --> 00:27:29,140
these context switches but we don't need

00:27:27,790 --> 00:27:31,120
it yet and we don't want to implement

00:27:29,140 --> 00:27:32,269
stuff until we actually know why we need

00:27:31,120 --> 00:27:34,339
it

00:27:32,269 --> 00:27:36,799
this is another thing I don't think this

00:27:34,339 --> 00:27:39,080
is natural C++ to have this integers

00:27:36,799 --> 00:27:40,909
that are represented file descriptors

00:27:39,080 --> 00:27:43,249
what is the file descriptor I I have no

00:27:40,909 --> 00:27:45,919
idea what's behind this it's it's just

00:27:43,249 --> 00:27:48,679
an integer what's behind there is it a

00:27:45,919 --> 00:27:52,179
file is it a socket is it open is it

00:27:48,679 --> 00:27:55,459
closed what is it hmm

00:27:52,179 --> 00:27:58,099
yes it's magic exactly it's magic and

00:27:55,459 --> 00:27:59,719
it's opaque so is this what I should

00:27:58,099 --> 00:28:00,709
start implementing should I make these

00:27:59,719 --> 00:28:03,109
file descriptors

00:28:00,709 --> 00:28:05,239
it doesn't seem intuitive for me as a

00:28:03,109 --> 00:28:07,759
C++ developer does not seem intuitive at

00:28:05,239 --> 00:28:10,039
all to to our developer team they hated

00:28:07,759 --> 00:28:11,659
doing this I asked them to do POSIX and

00:28:10,039 --> 00:28:13,129
you know we've done a lot of POSIX but

00:28:11,659 --> 00:28:16,969
it's not something they do

00:28:13,129 --> 00:28:18,559
enthusiastically so it's a kind of

00:28:16,969 --> 00:28:21,440
polymorphism you could say it's like a

00:28:18,559 --> 00:28:24,200
it's like a poor-man's polymorphic

00:28:21,440 --> 00:28:25,549
interface politics is great for many

00:28:24,200 --> 00:28:27,559
things it's much better to have a

00:28:25,549 --> 00:28:28,729
standard and not to have a standard but

00:28:27,559 --> 00:28:31,639
it's not something I would start by

00:28:28,729 --> 00:28:33,589
implementing or this is not where I

00:28:31,639 --> 00:28:35,749
would start also you have this void

00:28:33,589 --> 00:28:37,519
pointer is that if that could C++ I

00:28:35,749 --> 00:28:41,119
don't know I have to do some kind of

00:28:37,519 --> 00:28:42,649
typecast there and then there's a point

00:28:41,119 --> 00:28:45,529
the fact that it's a pointer sized

00:28:42,649 --> 00:28:47,089
interface I've seen core guidelines at

00:28:45,529 --> 00:28:48,229
least since um revision of the core

00:28:47,089 --> 00:28:50,179
guidelines there was a recommendation

00:28:48,229 --> 00:28:52,849
that you should do spans instead of this

00:28:50,179 --> 00:28:56,049
I think that you know if you can have

00:28:52,849 --> 00:28:59,509
some more types of interface you should

00:28:56,049 --> 00:29:01,190
so but whatever the case may be however

00:28:59,509 --> 00:29:03,619
you might feel about this function

00:29:01,190 --> 00:29:05,599
signature the fact is I have to

00:29:03,619 --> 00:29:07,399
implement that magic that's supposed to

00:29:05,599 --> 00:29:10,129
be leaving behind that file descriptor

00:29:07,399 --> 00:29:12,679
you know that thing that makes the

00:29:10,129 --> 00:29:14,899
internet work inside your computer that

00:29:12,679 --> 00:29:16,309
has to be implemented and then I'm going

00:29:14,899 --> 00:29:19,789
to have to provide you with some kind of

00:29:16,309 --> 00:29:21,200
user friendly interface on top right so

00:29:19,789 --> 00:29:22,909
let's look at the other system calls if

00:29:21,200 --> 00:29:26,389
there's any help we have a lot of fun

00:29:22,909 --> 00:29:28,309
system ones that's quite a lot you know

00:29:26,389 --> 00:29:31,519
it regrets represents quite a large

00:29:28,309 --> 00:29:36,139
portion of the system calls backing

00:29:31,519 --> 00:29:40,279
newly and then we have this rarely

00:29:36,139 --> 00:29:42,130
needed for our purposes kill a single

00:29:40,279 --> 00:29:45,500
process operating system

00:29:42,130 --> 00:29:48,380
what are you going to kill you can only

00:29:45,500 --> 00:29:49,970
kill yourself yes you're allowed to do

00:29:48,380 --> 00:29:53,300
that we've implemented this because we

00:29:49,970 --> 00:29:55,490
have to but you know doesn't really make

00:29:53,300 --> 00:29:57,500
that much sense right environment

00:29:55,490 --> 00:29:59,810
variables are good for communicating

00:29:57,500 --> 00:30:01,070
small pieces of data between processes

00:29:59,810 --> 00:30:04,160
and between operating system and

00:30:01,070 --> 00:30:07,220
processes you know you can have them but

00:30:04,160 --> 00:30:09,320
you know in our and include to us it's

00:30:07,220 --> 00:30:11,540
much better to just go ask the operating

00:30:09,320 --> 00:30:15,170
system directly just fetch the values

00:30:11,540 --> 00:30:17,450
you want directly there's one here for

00:30:15,170 --> 00:30:19,400
timekeeping that's probably useful for a

00:30:17,450 --> 00:30:21,950
web server but it's not you know doesn't

00:30:19,400 --> 00:30:24,290
take us miles ahead and then we have

00:30:21,950 --> 00:30:26,840
these that are completely useless you

00:30:24,290 --> 00:30:29,210
know single process operating system

00:30:26,840 --> 00:30:31,160
Fork I can't work I don't know what

00:30:29,210 --> 00:30:33,830
processes I'm one process should I

00:30:31,160 --> 00:30:34,700
should i duplicate myself into - no it

00:30:33,830 --> 00:30:36,980
doesn't make sense

00:30:34,700 --> 00:30:40,760
waiting for another process also doesn't

00:30:36,980 --> 00:30:41,600
make any sense so oh let's just look at

00:30:40,760 --> 00:30:43,910
this very quickly

00:30:41,600 --> 00:30:45,710
why so much filesystem stuff and why so

00:30:43,910 --> 00:30:49,700
little networking stuff in the C

00:30:45,710 --> 00:30:50,990
standard library my only hypothesis is

00:30:49,700 --> 00:30:55,880
that this is what the internet looked

00:30:50,990 --> 00:30:57,710
like I remember this Internet I remember

00:30:55,880 --> 00:31:01,100
except it wasn't FedEx I never used

00:30:57,710 --> 00:31:03,440
FedEx I I had all these this gets in my

00:31:01,100 --> 00:31:05,240
backpack and and the bat and the disc s

00:31:03,440 --> 00:31:07,790
were taking out taken out of backpacks

00:31:05,240 --> 00:31:09,770
and put into other backpacks and they

00:31:07,790 --> 00:31:12,110
were of course never anything pirated on

00:31:09,770 --> 00:31:12,920
there but there was definitely a lot of

00:31:12,110 --> 00:31:14,990
games on there

00:31:12,920 --> 00:31:16,910
so that's how we exchange information so

00:31:14,990 --> 00:31:19,070
so maybe you know maybe that's why there

00:31:16,910 --> 00:31:21,320
are so such a file system focus on these

00:31:19,070 --> 00:31:23,860
system calls but it's not nearly enough

00:31:21,320 --> 00:31:26,210
for a web server so we have to do more

00:31:23,860 --> 00:31:28,700
so we actually have to implement this

00:31:26,210 --> 00:31:30,230
whole networking subsystem and we have

00:31:28,700 --> 00:31:33,470
to do with you with zero overhead

00:31:30,230 --> 00:31:36,200
because that's our mission and we also

00:31:33,470 --> 00:31:38,660
want to you know alleviate the the

00:31:36,200 --> 00:31:40,190
opportunities we have when we know that

00:31:38,660 --> 00:31:42,800
we actually don't have to worry about

00:31:40,190 --> 00:31:44,570
other processes getting in the way so we

00:31:42,800 --> 00:31:46,190
have some unique opportunities to do

00:31:44,570 --> 00:31:48,050
something different and then the

00:31:46,190 --> 00:31:49,700
question is you know when I implement

00:31:48,050 --> 00:31:52,340
all these subsystems I'm a library

00:31:49,700 --> 00:31:54,130
operating system right so I provide for

00:31:52,340 --> 00:31:57,410
example if I provide

00:31:54,130 --> 00:32:00,470
- you guys you're making the process I

00:31:57,410 --> 00:32:02,900
provide the TCP object what kind do I

00:32:00,470 --> 00:32:06,679
need like a extra set of interfaces on

00:32:02,900 --> 00:32:08,630
top I don't know but let's see okay so

00:32:06,679 --> 00:32:10,940
let's take a small survey of the

00:32:08,630 --> 00:32:12,770
subsystems in the modern operating

00:32:10,940 --> 00:32:15,049
systems we have memory we have file

00:32:12,770 --> 00:32:17,030
systems we have timekeeping networking

00:32:15,049 --> 00:32:19,100
parallelism and miscellaneous I probably

00:32:17,030 --> 00:32:23,000
forgot something but but these are at

00:32:19,100 --> 00:32:25,330
least some very important ones and and

00:32:23,000 --> 00:32:28,010
if you looked at Lib C I think this is

00:32:25,330 --> 00:32:33,159
I've used a very scientific model to

00:32:28,010 --> 00:32:37,460
derive this precise line here you know

00:32:33,159 --> 00:32:39,409
it roughly describes how Lipsy what kind

00:32:37,460 --> 00:32:41,960
of services Lipsy provides in terms of

00:32:39,409 --> 00:32:46,640
support for for-4 or access to these

00:32:41,960 --> 00:32:49,010
operating system subsystems so POSIX

00:32:46,640 --> 00:32:51,590
goes a lot further and it gives you a

00:32:49,010 --> 00:32:53,330
lot more I mean most notably obviously

00:32:51,590 --> 00:32:55,130
and you get the socket interface right

00:32:53,330 --> 00:32:57,860
so you actually get to create TCP

00:32:55,130 --> 00:32:59,210
sockets and you get to grate UDP socket

00:32:57,860 --> 00:33:01,130
so you can send data grams and you can

00:32:59,210 --> 00:33:01,730
open TCP streams that's a huge

00:33:01,130 --> 00:33:05,030
improvement

00:33:01,730 --> 00:33:06,530
obviously you also have P threads so now

00:33:05,030 --> 00:33:11,150
you can actually do threading you know

00:33:06,530 --> 00:33:14,270
that's nice lip C++ adds a lot of value

00:33:11,150 --> 00:33:17,900
on top of that again in terms of memory

00:33:14,270 --> 00:33:19,490
we have STL we have stood filesystem I

00:33:17,900 --> 00:33:22,460
think that's just recently gotten

00:33:19,490 --> 00:33:24,980
approved has it so so that's great we

00:33:22,460 --> 00:33:27,440
have stood chronal that's much better

00:33:24,980 --> 00:33:29,720
abstractions for timekeeping and then

00:33:27,440 --> 00:33:32,600
there's a networking tes that I'm hoping

00:33:29,720 --> 00:33:33,440
it's going to turn out great it's not

00:33:32,600 --> 00:33:35,990
there yet

00:33:33,440 --> 00:33:37,760
but of course in terms of concurrency

00:33:35,990 --> 00:33:39,350
there's a lot of work a lot of

00:33:37,760 --> 00:33:42,730
additional support losses ping to me as

00:33:39,350 --> 00:33:43,850
well as well stood threads facing

00:33:42,730 --> 00:33:46,940
coroutines

00:33:43,850 --> 00:33:49,159
etc so still some things might be

00:33:46,940 --> 00:33:52,070
missing I'm always interesting in the

00:33:49,159 --> 00:33:54,470
low-level stuff you know might just be

00:33:52,070 --> 00:33:57,320
me but I'm a systems programmer I think

00:33:54,470 --> 00:33:59,270
many of you guys are as well so we

00:33:57,320 --> 00:34:01,820
always when we talk to people we see a

00:33:59,270 --> 00:34:03,070
lot of people trying to get the Linux

00:34:01,820 --> 00:34:05,430
kernel out of the way

00:34:03,070 --> 00:34:09,100
and try to kind of get through this

00:34:05,430 --> 00:34:11,470
opaque barrier of system calls without

00:34:09,100 --> 00:34:13,210
going through the whole hassle of you

00:34:11,470 --> 00:34:15,040
know modifying the Linux kernel and

00:34:13,210 --> 00:34:17,770
writing kernels that's that's quite hard

00:34:15,040 --> 00:34:20,650
so you know having some very clean

00:34:17,770 --> 00:34:22,230
low-level interfaces you know I thought

00:34:20,650 --> 00:34:27,280
that would be interesting and obviously

00:34:22,230 --> 00:34:29,260
HTTPS is missing and also we contribute

00:34:27,280 --> 00:34:31,240
with our squiggly line it's it's not any

00:34:29,260 --> 00:34:33,730
straighter it's not a much cleaner line

00:34:31,240 --> 00:34:35,410
if you try to express it as a line but

00:34:33,730 --> 00:34:37,000
we have a lot more going on the

00:34:35,410 --> 00:34:38,470
networking side because we actually

00:34:37,000 --> 00:34:41,740
implemented the whole subsystem

00:34:38,470 --> 00:34:44,560
obviously that's not the job of the C++

00:34:41,740 --> 00:34:48,340
standard library at least I don't

00:34:44,560 --> 00:34:52,540
perceive it to be a butt but you know we

00:34:48,340 --> 00:34:55,870
had to do it for our purposes so we have

00:34:52,540 --> 00:34:57,910
added some stuff but instead of

00:34:55,870 --> 00:34:59,880
considering this a line I just want to

00:34:57,910 --> 00:35:01,900
talk about how we're doing it we're just

00:34:59,880 --> 00:35:06,400
implementing all these well-defined

00:35:01,900 --> 00:35:08,230
subsystems as C++ classes so it seems a

00:35:06,400 --> 00:35:10,000
bit artificial to draw this kind of

00:35:08,230 --> 00:35:12,100
absolute line this distinction between

00:35:10,000 --> 00:35:14,560
this barrier between operating system

00:35:12,100 --> 00:35:17,170
and the end user space it seems a bit

00:35:14,560 --> 00:35:19,090
artificial at least in our context so

00:35:17,170 --> 00:35:21,340
we're implementing all these subsystems

00:35:19,090 --> 00:35:24,160
we're providing a lot of high-level

00:35:21,340 --> 00:35:28,000
abstractions and we're also implementing

00:35:24,160 --> 00:35:29,470
objects for for the low-level so people

00:35:28,000 --> 00:35:31,900
might be missing this very clean

00:35:29,470 --> 00:35:33,730
boundary I don't know if you guys are

00:35:31,900 --> 00:35:35,890
but but it's it's of course an important

00:35:33,730 --> 00:35:38,770
question for me to ask myself when I'm

00:35:35,890 --> 00:35:40,780
saying that I don't really you know I

00:35:38,770 --> 00:35:42,550
don't want to shout hooray for the POSIX

00:35:40,780 --> 00:35:46,000
standard even though I I see it's

00:35:42,550 --> 00:35:48,370
important you know so some people might

00:35:46,000 --> 00:35:50,110
you know complain and they want might

00:35:48,370 --> 00:35:51,670
want these clean layers so we've been

00:35:50,110 --> 00:35:53,710
thinking about that and trying to figure

00:35:51,670 --> 00:35:57,250
out where should those clean boundaries

00:35:53,710 --> 00:35:59,380
be this is one place to draw the line if

00:35:57,250 --> 00:36:00,910
you want access address web developers

00:35:59,380 --> 00:36:02,470
this is one way to do it to just say

00:36:00,910 --> 00:36:05,500
let's just provide some really clean

00:36:02,470 --> 00:36:08,170
HTTP interfaces because obviously if you

00:36:05,500 --> 00:36:11,080
have an IP stack and TCP well you're

00:36:08,170 --> 00:36:13,240
gonna want it to be and that's all yeah

00:36:11,080 --> 00:36:14,010
that's true for web developers someone

00:36:13,240 --> 00:36:15,630
developers

00:36:14,010 --> 00:36:17,520
but it's certainly not true for systems

00:36:15,630 --> 00:36:20,400
developers so we want something more

00:36:17,520 --> 00:36:22,170
okay so you can get access to TCP

00:36:20,400 --> 00:36:24,210
connections are part of the TCP

00:36:22,170 --> 00:36:26,160
connections through these opaque file

00:36:24,210 --> 00:36:29,970
descriptors that you know there's just

00:36:26,160 --> 00:36:31,680
magic numbers that I don't know POSIX

00:36:29,970 --> 00:36:34,980
provides some of that you also have this

00:36:31,680 --> 00:36:37,410
other less clean interface POSIX also

00:36:34,980 --> 00:36:40,890
includes a whole set of tools it

00:36:37,410 --> 00:36:45,450
standardized actually you know a lot of

00:36:40,890 --> 00:36:47,730
these command line tools which to get

00:36:45,450 --> 00:36:51,570
all all together forms kind of an unholy

00:36:47,730 --> 00:36:53,670
mess a way to access all the parts of

00:36:51,570 --> 00:36:56,310
the systems but you know at least

00:36:53,670 --> 00:36:59,700
yes it's very useful and and that's just

00:36:56,310 --> 00:37:01,800
how things evolved I guess so but if you

00:36:59,700 --> 00:37:03,840
want you know a clean access to

00:37:01,800 --> 00:37:06,570
everything I don't know a simple way so

00:37:03,840 --> 00:37:08,280
we're trying to make that happen so some

00:37:06,570 --> 00:37:11,640
of this comes from some of these

00:37:08,280 --> 00:37:14,370
layering issues it comes from the

00:37:11,640 --> 00:37:16,050
protection boundary right and it makes a

00:37:14,370 --> 00:37:18,180
lot of sense let me stress that it makes

00:37:16,050 --> 00:37:20,040
a lot of sense it's absolutely no way to

00:37:18,180 --> 00:37:21,860
make a general purpose operating system

00:37:20,040 --> 00:37:24,090
without having this protection boundary

00:37:21,860 --> 00:37:26,520
obviously you can't have one process

00:37:24,090 --> 00:37:29,220
here your Microsoft Word hair and Google

00:37:26,520 --> 00:37:31,500
Chrome hair overwriting each other's

00:37:29,220 --> 00:37:33,320
memory there's just not possible you

00:37:31,500 --> 00:37:35,610
can't have it like that

00:37:33,320 --> 00:37:37,650
so for that reason you have these

00:37:35,610 --> 00:37:39,120
protection boundaries but you know once

00:37:37,650 --> 00:37:42,510
you don't need those anymore

00:37:39,120 --> 00:37:46,320
it opens up the space of opportunities

00:37:42,510 --> 00:37:48,240
so that's just a look inside to be more

00:37:46,320 --> 00:37:50,670
concrete these are some of the classes

00:37:48,240 --> 00:37:52,320
we've implemented we have the network

00:37:50,670 --> 00:37:55,080
interface card we have Ethernet we have

00:37:52,320 --> 00:37:57,240
TCP controller we have ICMP we have TCP

00:37:55,080 --> 00:38:00,540
connections for each of these protocol

00:37:57,240 --> 00:38:03,600
handlers we have implemented packets a

00:38:00,540 --> 00:38:06,660
simple clean C++ classes so you can

00:38:03,600 --> 00:38:08,160
actually get the actual IP for packet

00:38:06,660 --> 00:38:12,060
and you can access the members of that

00:38:08,160 --> 00:38:16,370
packet through a normal C++ interface so

00:38:12,060 --> 00:38:18,330
that's just what we did and then POSIX

00:38:16,370 --> 00:38:20,550
obviously we want this operating system

00:38:18,330 --> 00:38:24,060
to be useful we want it to be able to

00:38:20,550 --> 00:38:26,060
support legacy code yeah so we've we're

00:38:24,060 --> 00:38:29,380
making a POSIX compatibility layer

00:38:26,060 --> 00:38:32,180
top of there but it introduces some

00:38:29,380 --> 00:38:34,250
strange and unnecessary abstractions the

00:38:32,180 --> 00:38:36,320
first of which is blocking because our

00:38:34,250 --> 00:38:39,530
operating system is async by default

00:38:36,320 --> 00:38:41,480
we've used the simplest possible form of

00:38:39,530 --> 00:38:43,610
async programming which is the leanest

00:38:41,480 --> 00:38:45,620
the smallest way and that's callbacks

00:38:43,610 --> 00:38:47,690
you can build a lot of abstractions on

00:38:45,620 --> 00:38:50,270
top of that that's not the only paradigm

00:38:47,690 --> 00:38:54,290
we we we support you can use boost as

00:38:50,270 --> 00:38:56,780
your own top as well but you know having

00:38:54,290 --> 00:38:59,030
to put these POSIX compatibility layer

00:38:56,780 --> 00:39:01,490
on top it forces us to support blocking

00:38:59,030 --> 00:39:03,380
okay so we need to support context which

00:39:01,490 --> 00:39:05,300
is in order to have that it's not

00:39:03,380 --> 00:39:08,660
efficient but but we need to have that

00:39:05,300 --> 00:39:11,360
for this this legacy interface I say

00:39:08,660 --> 00:39:16,070
make your own layers you know we already

00:39:11,360 --> 00:39:19,160
have this C++ objects which are small

00:39:16,070 --> 00:39:19,970
api's in their own right representing

00:39:19,160 --> 00:39:21,620
well-defined

00:39:19,970 --> 00:39:23,990
objects we didn't look at the POSIX

00:39:21,620 --> 00:39:25,610
standard or we didn't primarily look at

00:39:23,990 --> 00:39:29,150
Linux when we implemented this we went

00:39:25,610 --> 00:39:32,150
to the source the RFC's you know IOT

00:39:29,150 --> 00:39:34,940
IETF if the standard standardizing body

00:39:32,150 --> 00:39:36,770
for the whole internet they have really

00:39:34,940 --> 00:39:39,020
well written standards for all these

00:39:36,770 --> 00:39:41,810
protocols so we went directly there and

00:39:39,020 --> 00:39:43,850
implemented using water C++ so the

00:39:41,810 --> 00:39:46,760
result is that we have all this quite

00:39:43,850 --> 00:39:48,290
well defined it's they're getting more

00:39:46,760 --> 00:39:50,810
and more useful we're actually using

00:39:48,290 --> 00:39:55,250
them to deploy software now and and and

00:39:50,810 --> 00:39:57,800
you know I think that's that's a in my

00:39:55,250 --> 00:40:00,260
mind what I need in my job I don't know

00:39:57,800 --> 00:40:05,390
what you need but I don't need POSIX but

00:40:00,260 --> 00:40:08,390
we're implementing it so obviously we

00:40:05,390 --> 00:40:09,950
want to to also stay synchronized with

00:40:08,390 --> 00:40:12,260
the standard libraries so there's a

00:40:09,950 --> 00:40:16,400
networking specification I think it

00:40:12,260 --> 00:40:19,820
scheduled for C++ 20 it looks like it's

00:40:16,400 --> 00:40:23,680
going to be working on top of POSIX so

00:40:19,820 --> 00:40:26,780
that means you'll have a rich set of C++

00:40:23,680 --> 00:40:29,720
abstractions from the standard on top of

00:40:26,780 --> 00:40:32,000
this opaque POSIX layer and if you have

00:40:29,720 --> 00:40:35,150
this running on top of include OS you

00:40:32,000 --> 00:40:38,210
know that's modern C++ on top of ancient

00:40:35,150 --> 00:40:40,400
C on top of modern C++

00:40:38,210 --> 00:40:42,440
it seems unfortunate so I hope we don't

00:40:40,400 --> 00:40:46,790
get there although it might seem

00:40:42,440 --> 00:40:49,400
unreasonable to have the stud network

00:40:46,790 --> 00:40:51,890
conform to the include OS IP stack I

00:40:49,400 --> 00:40:54,320
mean maybe sometime in the future might

00:40:51,890 --> 00:40:55,760
seem unreasonable but I think the

00:40:54,320 --> 00:40:58,000
artists rest have said today that all

00:40:55,760 --> 00:41:00,530
progress depends on the unreasonable man

00:40:58,000 --> 00:41:03,200
this is a quote from George Bernard Shaw

00:41:00,530 --> 00:41:06,859
so you know who knows I'm not giving up

00:41:03,200 --> 00:41:09,830
so anyways I thought I was done with

00:41:06,859 --> 00:41:13,190
these layers until I got this email from

00:41:09,830 --> 00:41:16,070
Daniel Ricciardo at IBM Research so they

00:41:13,190 --> 00:41:17,869
were running include OS on top and they

00:41:16,070 --> 00:41:20,810
were running the demo application we

00:41:17,869 --> 00:41:22,670
showed last year which is a lot of HTTP

00:41:20,810 --> 00:41:25,339
abstractions for making restful api s--

00:41:22,670 --> 00:41:29,710
and then we're running this application

00:41:25,339 --> 00:41:33,520
on top of their own their new very I

00:41:29,710 --> 00:41:37,190
would say avant-garde kind of hypervisor

00:41:33,520 --> 00:41:39,890
and very cool is that they reduced our

00:41:37,190 --> 00:41:40,640
boot time from 300 milliseconds to 10

00:41:39,890 --> 00:41:42,920
milliseconds

00:41:40,640 --> 00:41:45,530
I thought 300 milliseconds was quite

00:41:42,920 --> 00:41:49,220
good you know you know 10 milliseconds

00:41:45,530 --> 00:41:51,080
is much better so let's look at that so

00:41:49,220 --> 00:41:54,260
we have all these quickly lines and this

00:41:51,080 --> 00:41:58,400
is where solo 5 comes in right that's

00:41:54,260 --> 00:42:00,619
actually a pretty straight line and I'll

00:41:58,400 --> 00:42:03,200
validate this straight line by actually

00:42:00,619 --> 00:42:05,900
looking at their code so this is the

00:42:03,200 --> 00:42:07,760
interface this is the low-level hardware

00:42:05,900 --> 00:42:10,730
interface that these guys have defined

00:42:07,760 --> 00:42:15,109
and it's sufficient to run this very

00:42:10,730 --> 00:42:17,060
rich modern C++ application on top so

00:42:15,109 --> 00:42:19,359
they have network packet read network

00:42:17,060 --> 00:42:21,500
packet right well that sounds very

00:42:19,359 --> 00:42:24,380
intuitive I understand immediately what

00:42:21,500 --> 00:42:26,599
that means block device read block

00:42:24,380 --> 00:42:28,010
device right right so read a single

00:42:26,599 --> 00:42:29,690
block write a single block that's

00:42:28,010 --> 00:42:31,760
something it would put below a file

00:42:29,690 --> 00:42:33,140
system but it would also make it easier

00:42:31,760 --> 00:42:35,000
for you to figure out how to make your

00:42:33,140 --> 00:42:37,460
own file system or to experiment with

00:42:35,000 --> 00:42:39,470
different types of file systems and then

00:42:37,460 --> 00:42:41,450
you have fast console output obviously

00:42:39,470 --> 00:42:43,000
won't help it ok that sounds very nice

00:42:41,450 --> 00:42:44,440
and

00:42:43,000 --> 00:42:47,050
and you have two types of clock

00:42:44,440 --> 00:42:49,210
monotonic clock and wall clock sounds

00:42:47,050 --> 00:42:50,680
like all you need and then you have this

00:42:49,210 --> 00:42:53,110
very interesting one that actually

00:42:50,680 --> 00:42:55,330
replaces all of our ir q handling and

00:42:53,110 --> 00:42:56,200
all of the timers bundled into one

00:42:55,330 --> 00:42:59,560
single call

00:42:56,200 --> 00:43:03,010
it's called paul and it says sleep and

00:42:59,560 --> 00:43:05,170
number of nanoseconds or sleep until a

00:43:03,010 --> 00:43:09,070
number of nanoseconds have passed or

00:43:05,170 --> 00:43:10,600
until there was some yl so our whole

00:43:09,070 --> 00:43:14,380
event loop instead of waiting for

00:43:10,600 --> 00:43:15,880
interrupts we're just doing this call so

00:43:14,380 --> 00:43:19,090
we're looking at our timers and we say

00:43:15,880 --> 00:43:20,680
ok so no timers have expired yet when is

00:43:19,090 --> 00:43:22,480
the first time where that's going to

00:43:20,680 --> 00:43:24,010
expire the first timer that we have

00:43:22,480 --> 00:43:27,070
register is going to be expiring then

00:43:24,010 --> 00:43:29,710
and nanoseconds okay so I pass that

00:43:27,070 --> 00:43:32,560
number to this call here and that call

00:43:29,710 --> 00:43:36,300
is going to wake me up when a time rests

00:43:32,560 --> 00:43:38,830
occurred or when there has been some i/o

00:43:36,300 --> 00:43:40,810
so it replaces pretty much all of this

00:43:38,830 --> 00:43:44,020
now it's not true that it replaces it

00:43:40,810 --> 00:43:47,320
because soul v is just an interface but

00:43:44,020 --> 00:43:49,750
you know just to get an event loop

00:43:47,320 --> 00:43:52,300
running and to get timers running we had

00:43:49,750 --> 00:43:54,790
to implement a whole lot of stuff on x86

00:43:52,300 --> 00:43:59,770
you can look at that code it's a lot and

00:43:54,790 --> 00:44:02,850
this is not not even all of it ah this

00:43:59,770 --> 00:44:05,770
guy you know this blocking calls

00:44:02,850 --> 00:44:09,670
yes that's true there are blocking calls

00:44:05,770 --> 00:44:11,380
in the solo 5 interface and so this is

00:44:09,670 --> 00:44:12,910
one of the trickiest side effects number

00:44:11,380 --> 00:44:15,580
four I'm not going to go into detail

00:44:12,910 --> 00:44:17,620
about it but once you want DMA to happen

00:44:15,580 --> 00:44:20,260
what does that mean it means that you

00:44:17,620 --> 00:44:23,500
have a device that's supposed to put

00:44:20,260 --> 00:44:26,590
data into your memory and then you're

00:44:23,500 --> 00:44:28,830
going and then once it's put data into

00:44:26,590 --> 00:44:32,800
your memory it's going to interrupt you

00:44:28,830 --> 00:44:35,050
right and you know you could start

00:44:32,800 --> 00:44:37,000
thinking how in such interface look like

00:44:35,050 --> 00:44:38,680
a shared data structure like that you

00:44:37,000 --> 00:44:40,720
could say okay let's just have them all

00:44:38,680 --> 00:44:43,390
in our ordered array so I have a

00:44:40,720 --> 00:44:45,970
continuous area of network packets well

00:44:43,390 --> 00:44:48,010
that's great but you know how about

00:44:45,970 --> 00:44:49,720
fragmentation do you think network

00:44:48,010 --> 00:44:51,610
packets are always going to just line up

00:44:49,720 --> 00:44:54,340
like that then it's a lot of copying

00:44:51,610 --> 00:44:54,900
right so in order to avoid copying and

00:44:54,340 --> 00:44:56,489
set

00:44:54,900 --> 00:44:58,140
you need some sophisticated data

00:44:56,489 --> 00:45:00,539
structure and it's quite hard to test

00:44:58,140 --> 00:45:03,809
etcetera this is something tricky with

00:45:00,539 --> 00:45:07,200
DMA serie overhead solution I still

00:45:03,809 --> 00:45:08,819
think it is to have DMA but it's

00:45:07,200 --> 00:45:12,930
surprising how much you were able to do

00:45:08,819 --> 00:45:18,269
with solo 5 so it works like this this

00:45:12,930 --> 00:45:20,130
is just how the layer enters so Mirage

00:45:18,269 --> 00:45:23,450
that's another unicorn project from

00:45:20,130 --> 00:45:28,140
Cambridge acquired by docker those guys

00:45:23,450 --> 00:45:30,930
so they use a solo 5 as a overlay on top

00:45:28,140 --> 00:45:32,579
of their drivers for running on kayvyun

00:45:30,930 --> 00:45:34,650
so that's when we're running in full

00:45:32,579 --> 00:45:37,200
hardware virtualization they use this

00:45:34,650 --> 00:45:38,700
simple soul of 5 interface to get their

00:45:37,200 --> 00:45:40,200
application and the rest of their

00:45:38,700 --> 00:45:42,269
operating system running on top of their

00:45:40,200 --> 00:45:44,640
now IP stack etc it's all running on

00:45:42,269 --> 00:45:47,160
there so that means inside the virtual

00:45:44,640 --> 00:45:48,989
machine they have a set of drivers that

00:45:47,160 --> 00:45:51,059
again will implement this solo 5

00:45:48,989 --> 00:45:53,339
interface you know and it's all inside

00:45:51,059 --> 00:45:55,200
the virtual machine another way to run

00:45:53,339 --> 00:46:00,690
it which is how they are implemented it

00:45:55,200 --> 00:46:03,420
for us is that they actually put the

00:46:00,690 --> 00:46:05,160
devices they don't put the devices

00:46:03,420 --> 00:46:06,660
inside the virtual machine so that means

00:46:05,160 --> 00:46:09,180
they provide a network driver for

00:46:06,660 --> 00:46:10,799
include OS which just does does a

00:46:09,180 --> 00:46:14,249
trapping call whenever it wants to fetch

00:46:10,799 --> 00:46:17,279
a network packet so and this adds a lot

00:46:14,249 --> 00:46:19,140
more protection so you know it's hard to

00:46:17,279 --> 00:46:21,239
visualize all this stuff I I hope you

00:46:19,140 --> 00:46:24,509
can it's probably hard to follow but

00:46:21,239 --> 00:46:27,119
what's happening here is that is that

00:46:24,509 --> 00:46:29,579
the sole of 5 intercept is the bottom

00:46:27,119 --> 00:46:31,259
layer and below solo 5 we don't have any

00:46:29,579 --> 00:46:33,569
network drivers that we have implemented

00:46:31,259 --> 00:46:35,700
ourselves we just have this trapping

00:46:33,569 --> 00:46:37,529
call so essentially the work of the

00:46:35,700 --> 00:46:39,900
driver has been moved down to the host

00:46:37,529 --> 00:46:43,259
so the host is going to be in charge of

00:46:39,900 --> 00:46:45,779
moving network packets in and out so it

00:46:43,259 --> 00:46:49,170
adds a lot of flexibility and also they

00:46:45,779 --> 00:46:52,109
give us some security some real cool

00:46:49,170 --> 00:46:54,809
security guarantees when you run include

00:46:52,109 --> 00:46:56,759
us in solo 5 it's actually going to do

00:46:54,809 --> 00:46:59,489
memory protection of the elf binary

00:46:56,759 --> 00:47:01,380
because we provide an elf binary in that

00:46:59,489 --> 00:47:03,930
elf binary there are segments with

00:47:01,380 --> 00:47:05,160
different protection flags on them so

00:47:03,930 --> 00:47:06,730
with solar fire they will actually

00:47:05,160 --> 00:47:09,339
actually load that and

00:47:06,730 --> 00:47:11,829
the protection inside of the virtual

00:47:09,339 --> 00:47:13,630
machine memory from the layer below so

00:47:11,829 --> 00:47:16,119
that we inside of include OS can't

00:47:13,630 --> 00:47:17,800
change it and that gives you absolute

00:47:16,119 --> 00:47:20,200
protection if that's what what you guys

00:47:17,800 --> 00:47:23,079
want so that means you can actually have

00:47:20,200 --> 00:47:25,410
a guarantee that says you can not write

00:47:23,079 --> 00:47:27,250
to the same memory that you can execute

00:47:25,410 --> 00:47:29,200
so that means you have a strong

00:47:27,250 --> 00:47:31,930
guarantee inside of include OS there is

00:47:29,200 --> 00:47:33,880
no way that I can receive data write it

00:47:31,930 --> 00:47:36,099
into memory and then jump to that memory

00:47:33,880 --> 00:47:37,089
it has some interesting side effects for

00:47:36,099 --> 00:47:40,780
example we're doing something called

00:47:37,089 --> 00:47:42,160
live update that's not going to work we

00:47:40,780 --> 00:47:44,650
have live update where you can receive a

00:47:42,160 --> 00:47:46,540
new version of the include OS binary you

00:47:44,650 --> 00:47:48,280
can actually replace yourself so you can

00:47:46,540 --> 00:47:50,770
replace the whole contents of the

00:47:48,280 --> 00:47:52,060
virtual machine in five milliseconds or

00:47:50,770 --> 00:47:54,310
ten milliseconds or something

00:47:52,060 --> 00:47:56,230
it's really fast it was really really

00:47:54,310 --> 00:47:57,640
neat that's not going to work there so

00:47:56,230 --> 00:47:59,650
there's still some interesting work in

00:47:57,640 --> 00:48:02,500
figuring out exactly where this balance

00:47:59,650 --> 00:48:07,180
should be struck between security and

00:48:02,500 --> 00:48:09,280
the availabe ability to update etc this

00:48:07,180 --> 00:48:10,810
could also obviously be used as a

00:48:09,280 --> 00:48:13,000
hardware interface on bare metal as well

00:48:10,810 --> 00:48:16,060
I want to say give a shout out to bare

00:48:13,000 --> 00:48:18,369
flank this Ryan Quinn is here tonight

00:48:16,060 --> 00:48:20,980
today they're taking an even more

00:48:18,369 --> 00:48:24,520
radical approach so they're actually you

00:48:20,980 --> 00:48:26,859
know tossing KVM aside so solo v they

00:48:24,520 --> 00:48:29,410
they use an interface to KVM which is

00:48:26,859 --> 00:48:32,410
kernel module in Linux in order to run

00:48:29,410 --> 00:48:33,910
the virtual machines bare flank they're

00:48:32,410 --> 00:48:36,700
actually implementing all of this from

00:48:33,910 --> 00:48:38,290
scratch for both Windows and Linux I

00:48:36,700 --> 00:48:40,030
still don't know exactly how these

00:48:38,290 --> 00:48:42,160
interfaces between guests and hosts are

00:48:40,030 --> 00:48:44,920
going to look but I'm sure it's is it is

00:48:42,160 --> 00:48:47,200
it somewhere along these lines yeah yeah

00:48:44,920 --> 00:48:49,420
so so I'm really excited about that

00:48:47,200 --> 00:48:51,550
project as well this is pure C++ it's

00:48:49,420 --> 00:48:53,470
really well tested so go see Ron quints

00:48:51,550 --> 00:48:58,690
talk and then check out that work as

00:48:53,470 --> 00:49:00,730
well so approaching the end there we're

00:48:58,690 --> 00:49:03,369
we're saying that you know we're making

00:49:00,730 --> 00:49:07,569
an ecosystem we're implementing all

00:49:03,369 --> 00:49:10,420
these protocol objects this subsystem in

00:49:07,569 --> 00:49:13,920
C++ already it doesn't seem like we

00:49:10,420 --> 00:49:16,230
really need this neat POSIX layer on top

00:49:13,920 --> 00:49:18,540
you know but

00:49:16,230 --> 00:49:22,770
it looks like it's possible to make some

00:49:18,540 --> 00:49:25,230
very neat layers on the lower levels so

00:49:22,770 --> 00:49:27,450
we have a guideline for POSIX we want to

00:49:25,230 --> 00:49:29,700
implement the modern C++ variant first

00:49:27,450 --> 00:49:35,010
and then we do this optional POSIX layer

00:49:29,700 --> 00:49:36,720
on top so there are no perfect layers so

00:49:35,010 --> 00:49:41,300
how much should we allow the user access

00:49:36,720 --> 00:49:44,250
to and I think the answer is everything

00:49:41,300 --> 00:49:45,869
would you agree can you tell me one

00:49:44,250 --> 00:49:47,460
thing inside the operating system or

00:49:45,869 --> 00:49:50,310
inside the hardware that you want me to

00:49:47,460 --> 00:49:52,619
restrict access to something you

00:49:50,310 --> 00:49:55,109
absolutely certain that you never want

00:49:52,619 --> 00:49:56,910
access to I think the general answer has

00:49:55,109 --> 00:50:00,990
to be I want to be able to access

00:49:56,910 --> 00:50:02,540
everything so we want to give you access

00:50:00,990 --> 00:50:05,369
to everything but we don't want you to

00:50:02,540 --> 00:50:07,280
get everything at once we don't want you

00:50:05,369 --> 00:50:10,680
to pay for the parts that you don't need

00:50:07,280 --> 00:50:12,180
so unless you explicitly ask for it is

00:50:10,680 --> 00:50:14,570
not going to get included into the

00:50:12,180 --> 00:50:16,950
violent binary you also said today

00:50:14,570 --> 00:50:18,210
stro strict to that you should make a

00:50:16,950 --> 00:50:21,240
connection with hardware it's

00:50:18,210 --> 00:50:23,820
abstractions all the way down and and I

00:50:21,240 --> 00:50:26,820
agree unfortunately some of these

00:50:23,820 --> 00:50:30,950
abstractions are very opaque so if you

00:50:26,820 --> 00:50:34,320
go you know if you if you just start

00:50:30,950 --> 00:50:36,270
trying to interface with Linux you're

00:50:34,320 --> 00:50:38,280
going to see that you know you'll reach

00:50:36,270 --> 00:50:39,840
the level of the system calls and below

00:50:38,280 --> 00:50:41,760
you know it's just a black box

00:50:39,840 --> 00:50:44,100
really obviously it's open source which

00:50:41,760 --> 00:50:46,410
is great you can go in there rebuild

00:50:44,100 --> 00:50:49,020
Linux make your own kernel modules but

00:50:46,410 --> 00:50:51,570
we are trying to make an environment

00:50:49,020 --> 00:50:54,510
where you as a C++ programmer already

00:50:51,570 --> 00:50:58,530
has access to all these subsystems

00:50:54,510 --> 00:50:59,850
directly so we're trying to answer all

00:50:58,530 --> 00:51:01,440
these questions how do I boot my

00:50:59,850 --> 00:51:04,350
HelloWorld program we answered that

00:51:01,440 --> 00:51:06,240
today how do I boot my custom kernel we

00:51:04,350 --> 00:51:08,130
have tooling for that so that you can

00:51:06,240 --> 00:51:11,070
start implementing your own kernel and

00:51:08,130 --> 00:51:13,160
say boot dot and then boot that kernel

00:51:11,070 --> 00:51:16,350
code and then you know start working

00:51:13,160 --> 00:51:18,570
with the web server C++ web service with

00:51:16,350 --> 00:51:22,350
modern abstraction that we showed last

00:51:18,570 --> 00:51:24,450
year we're working on routers and

00:51:22,350 --> 00:51:26,100
firewalls and load balancers so these

00:51:24,450 --> 00:51:26,840
are systems where you typically needs

00:51:26,100 --> 00:51:29,120
part of

00:51:26,840 --> 00:51:30,890
a stack and not the whole IP stack so it

00:51:29,120 --> 00:51:33,590
makes a lot of sense for us to have a

00:51:30,890 --> 00:51:36,860
modular IP stack we don't just get this

00:51:33,590 --> 00:51:39,010
huge box or nothing you just get you can

00:51:36,860 --> 00:51:41,650
pick and choose the components you want

00:51:39,010 --> 00:51:44,150
so the green ones are available now

00:51:41,650 --> 00:51:45,650
firewall routing low bouncer those are

00:51:44,150 --> 00:51:49,550
in the works

00:51:45,650 --> 00:51:51,350
our CEO actually reported 13% faster

00:51:49,550 --> 00:51:54,320
that we were 13 percent faster than

00:51:51,350 --> 00:51:56,410
Linux when we were routing a ping flop

00:51:54,320 --> 00:51:59,000
so we're very good on latency it seems

00:51:56,410 --> 00:52:04,250
30% faster that's that's that's pretty

00:51:59,000 --> 00:52:07,550
cool yeah so he wants me to boot that

00:52:04,250 --> 00:52:08,840
web server I've been talking about it so

00:52:07,550 --> 00:52:11,240
this is how it looks

00:52:08,840 --> 00:52:14,300
I'm not going to have time to go into

00:52:11,240 --> 00:52:17,270
details there is a talk tomorrow where

00:52:14,300 --> 00:52:20,180
i'll cover more of that but this is how

00:52:17,270 --> 00:52:21,620
it looks and you might notice that we're

00:52:20,180 --> 00:52:25,430
making a unique pointer here to

00:52:21,620 --> 00:52:27,560
something just called an HTTP server but

00:52:25,430 --> 00:52:29,360
what I think is interesting is that this

00:52:27,560 --> 00:52:32,930
is just one of several abstractions we

00:52:29,360 --> 00:52:35,510
have available we have if you want just

00:52:32,930 --> 00:52:37,880
to have an example where you run TCP and

00:52:35,510 --> 00:52:41,290
write text directly to TCP you can do

00:52:37,880 --> 00:52:43,370
that this is an abstraction for HTTP and

00:52:41,290 --> 00:52:46,850
what I think is interesting is that

00:52:43,370 --> 00:52:49,040
you've built that HTTP server object on

00:52:46,850 --> 00:52:51,230
top of a very transparent set of

00:52:49,040 --> 00:52:53,030
subsystems so we have an IP stack that

00:52:51,230 --> 00:52:55,730
you can access and you can grab hold of

00:52:53,030 --> 00:52:58,400
the TCP part of that IP stack and then

00:52:55,730 --> 00:52:59,930
on top of that TCP part of that

00:52:58,400 --> 00:53:02,660
particular IP stack because you can have

00:52:59,930 --> 00:53:06,140
many so on top of that you attach your

00:53:02,660 --> 00:53:10,070
web server you can see already that we

00:53:06,140 --> 00:53:13,010
are this is our callback this is a way

00:53:10,070 --> 00:53:15,830
to do callbacks so on request and we're

00:53:13,010 --> 00:53:17,720
transmitting a long time there so

00:53:15,830 --> 00:53:20,360
whenever there's an HTTP request coming

00:53:17,720 --> 00:53:23,150
in this lambda is going to be executed

00:53:20,360 --> 00:53:26,690
that's not the optimal way of using this

00:53:23,150 --> 00:53:29,570
callback system and and but but it's

00:53:26,690 --> 00:53:31,250
very efficient but when you use

00:53:29,570 --> 00:53:32,990
delegates and delegates into the

00:53:31,250 --> 00:53:34,060
equation which I'm going to show you

00:53:32,990 --> 00:53:36,620
tomorrow

00:53:34,060 --> 00:53:37,790
you know that then it gets much easier

00:53:36,620 --> 00:53:41,540
to

00:53:37,790 --> 00:53:43,550
to work with so you can boot it now it

00:53:41,540 --> 00:53:45,800
has networking so if you if you boot

00:53:43,550 --> 00:53:47,990
something with networking and you wanted

00:53:45,800 --> 00:53:50,660
to be able to talk to the surrounding

00:53:47,990 --> 00:53:52,250
environment you say create bridge so

00:53:50,660 --> 00:53:53,750
we'll set up a bridge for you so that

00:53:52,250 --> 00:53:55,610
that virtual machine will come up and it

00:53:53,750 --> 00:53:58,370
will be i'll have kind of a virtual wire

00:53:55,610 --> 00:54:02,540
connected to a virtual bridge so that

00:53:58,370 --> 00:54:06,050
you can you can talk to it it boots

00:54:02,540 --> 00:54:08,180
something like this and then you go to

00:54:06,050 --> 00:54:11,120
the web browser and you yeah talk yeah

00:54:08,180 --> 00:54:15,560
you go to that IP address and hopefully

00:54:11,120 --> 00:54:19,760
you see that web page so how am I on

00:54:15,560 --> 00:54:22,310
time I actually have gone a little bit a

00:54:19,760 --> 00:54:24,380
little bit faster than I thought but so

00:54:22,310 --> 00:54:25,820
tomorrow I'm going to cover this code in

00:54:24,380 --> 00:54:28,670
more detail I never thought I'd get to

00:54:25,820 --> 00:54:31,910
the end of these slides but here we are

00:54:28,670 --> 00:54:35,660
so I'll introduce you to modern C++

00:54:31,910 --> 00:54:36,890
delegates and how we wire all these C++

00:54:35,660 --> 00:54:38,810
objects that I've talked so much about

00:54:36,890 --> 00:54:40,700
how we wire them using delegates that's

00:54:38,810 --> 00:54:43,130
a quite interesting technique and I'll

00:54:40,700 --> 00:54:46,610
show you much more code examples how to

00:54:43,130 --> 00:54:48,770
do fast DMA 0 copy IP stack with tens of

00:54:46,610 --> 00:54:51,190
thousands of concurrent connections and

00:54:48,770 --> 00:54:54,890
zero context which is on a single CPU

00:54:51,190 --> 00:54:58,040
that's a true statement we're doing that

00:54:54,890 --> 00:54:59,330
we're not doing any context which is but

00:54:58,040 --> 00:55:00,710
still we are getting a lot of

00:54:59,330 --> 00:55:02,510
performance for a lot of concurrent

00:55:00,710 --> 00:55:04,400
connections and the reason for that it

00:55:02,510 --> 00:55:06,680
was is that we have a very very slim and

00:55:04,400 --> 00:55:11,150
minimal sort of event loop that drives

00:55:06,680 --> 00:55:13,040
the whole thing so we're going to talk

00:55:11,150 --> 00:55:16,160
about delegates how they make this zero

00:55:13,040 --> 00:55:18,020
overhead async programming easier you

00:55:16,160 --> 00:55:19,010
can also build other stuff on top of

00:55:18,020 --> 00:55:21,530
that I mentioned boost

00:55:19,010 --> 00:55:23,320
Accio but that's also something it has a

00:55:21,530 --> 00:55:26,480
flexible back-end so that you can make

00:55:23,320 --> 00:55:29,420
include a wise back-end for it so there

00:55:26,480 --> 00:55:30,860
are alternatives but of course we're

00:55:29,420 --> 00:55:35,930
also going to point out some tricky

00:55:30,860 --> 00:55:37,820
issues it's not just easy so yeah we'll

00:55:35,930 --> 00:55:40,130
look at those and there are reasons for

00:55:37,820 --> 00:55:42,260
wanting Cortese channels multi-core

00:55:40,130 --> 00:55:44,450
abstractions we do have multiple cores

00:55:42,260 --> 00:55:47,540
in include OS and we do have a way for

00:55:44,450 --> 00:55:47,990
you to assign a function to us to will

00:55:47,540 --> 00:55:50,840
and

00:55:47,990 --> 00:55:54,880
core that's going to be a separate talk

00:55:50,840 --> 00:55:57,770
on on meeting C++ in Germany conclusions

00:55:54,880 --> 00:55:59,660
operating system sub Davis systems don't

00:55:57,770 --> 00:56:02,060
have to be sub anymore you can get

00:55:59,660 --> 00:56:04,700
access to all of them some unusual side

00:56:02,060 --> 00:56:06,860
effects you have to consider when you're

00:56:04,700 --> 00:56:09,500
programming for the operating system but

00:56:06,860 --> 00:56:12,260
the resulting environment that we

00:56:09,500 --> 00:56:15,070
provide is something where you'll feel

00:56:12,260 --> 00:56:17,660
like it's just programming normal C++

00:56:15,070 --> 00:56:21,320
but you are you actually are in full

00:56:17,660 --> 00:56:24,830
control politics isn't bad but I think

00:56:21,320 --> 00:56:26,780
it's bad simple plus it also has some

00:56:24,830 --> 00:56:27,950
costly side effects so and that's one

00:56:26,780 --> 00:56:29,840
reason why I don't think that's the

00:56:27,950 --> 00:56:31,820
perfect operating system abstraction

00:56:29,840 --> 00:56:34,190
anymore I'm not saying we shouldn't

00:56:31,820 --> 00:56:35,750
throw it out the window by all means but

00:56:34,190 --> 00:56:41,840
it's not the perfect abstraction not

00:56:35,750 --> 00:56:44,990
suitable for our purposes ok so that's

00:56:41,840 --> 00:56:52,300
it actually come find us if you have any

00:56:44,990 --> 00:56:55,580
questions I guess we have time yeah

00:56:52,300 --> 00:56:59,030
forearm oh that's a good question well

00:56:55,580 --> 00:57:01,820
one of the things we have done recently

00:56:59,030 --> 00:57:05,090
is or actually within the last year we

00:57:01,820 --> 00:57:06,950
switched from 32-bit to 64-bit and when

00:57:05,090 --> 00:57:10,160
we did we tried to keep support for

00:57:06,950 --> 00:57:11,990
32-bit so so that means if you go into

00:57:10,160 --> 00:57:13,250
the source directory it's all open

00:57:11,990 --> 00:57:15,560
source and available on github

00:57:13,250 --> 00:57:17,480
you already see that we have done a lot

00:57:15,560 --> 00:57:20,090
of work in terms of separating

00:57:17,480 --> 00:57:22,580
architecture specific stuff into

00:57:20,090 --> 00:57:23,750
separate places and the build system is

00:57:22,580 --> 00:57:26,810
integrated with that so that you can

00:57:23,750 --> 00:57:28,550
kind of specify which architecture you

00:57:26,810 --> 00:57:30,980
want to build for and it will produce

00:57:28,550 --> 00:57:33,050
Winery corresponding to that we are we

00:57:30,980 --> 00:57:34,730
have been running a lot of our tests and

00:57:33,050 --> 00:57:38,960
I think that IP stack has been run on

00:57:34,730 --> 00:57:41,359
art but you know the subsystem the the

00:57:38,960 --> 00:57:43,990
driver layer that's not implemented for

00:57:41,359 --> 00:57:47,450
arm we are planning we are moving into

00:57:43,990 --> 00:57:50,540
running on bare metal we've done

00:57:47,450 --> 00:57:52,790
successful tests running on x86 bare

00:57:50,540 --> 00:57:56,470
metal that was quite exciting and and I

00:57:52,790 --> 00:57:59,060
are miss obviously the natural next

00:57:56,470 --> 00:58:05,570
choice but I can't give you a particular

00:57:59,060 --> 00:58:09,260
date any other questions nope

00:58:05,570 --> 00:58:19,729
okay come find us go to the top

00:58:09,260 --> 00:58:19,729

YouTube URL: https://www.youtube.com/watch?v=h7D88U-5pKc


