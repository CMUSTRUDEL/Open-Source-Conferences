Title: Traits Go Mainstream...  Leor Zolman - [ CppCon 2015 ]
Publication date: 2015-10-21
Playlist: CppCon 2015 Lightning Talks
Description: 
	http://www.Cppcon.org
--
"Traits Go Mainstream (They're not just for library developers any more: a case study)"
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
 Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,060 --> 00:00:05,670
so one more this morning before you can

00:00:02,250 --> 00:00:07,980
go and get a coffee refill Lior is a

00:00:05,670 --> 00:00:13,139
principal of a Biddy software in Boston

00:00:07,980 --> 00:00:14,910
he does modern C++ training and he wants

00:00:13,139 --> 00:00:18,930
to focus on one particular modern thing

00:00:14,910 --> 00:00:21,029
type traits and yes it is before 9:00

00:00:18,930 --> 00:00:22,769
a.m. and we are going to have template

00:00:21,029 --> 00:00:24,980
metaprogramming so if you need to hold

00:00:22,769 --> 00:00:27,660
the hand with someone near you

00:00:24,980 --> 00:00:30,869
be prepared ready

00:00:27,660 --> 00:00:32,369
ready and I'm not a morning person and I

00:00:30,869 --> 00:00:33,390
have you haven't even had coffee this

00:00:32,369 --> 00:00:38,160
morning so this should be really

00:00:33,390 --> 00:00:40,230
interesting so to talk about it's a

00:00:38,160 --> 00:00:43,410
tutorial about type traits it's

00:00:40,230 --> 00:00:44,730
specifically one aspect of titrate type

00:00:43,410 --> 00:00:47,789
traits in conjunction with some new

00:00:44,730 --> 00:00:49,320
features in C++ 11 so going back type

00:00:47,789 --> 00:00:52,789
traits were first introduced in boost

00:00:49,320 --> 00:00:55,110
they were in T r1 and during that time

00:00:52,789 --> 00:00:57,120
traits use was mostly buried in

00:00:55,110 --> 00:00:58,980
libraries so clients and libraries

00:00:57,120 --> 00:01:01,050
didn't really need to understand how the

00:00:58,980 --> 00:01:03,510
type traits worked that we're powering

00:01:01,050 --> 00:01:05,909
some of the magic going on inside of

00:01:03,510 --> 00:01:08,970
their library but the introduction of

00:01:05,909 --> 00:01:10,710
wind specific feature in C++ 11 our

00:01:08,970 --> 00:01:13,470
value references and when they act as

00:01:10,710 --> 00:01:16,799
universal references as Scott has coined

00:01:13,470 --> 00:01:19,979
that term kind of changes things and I'm

00:01:16,799 --> 00:01:21,780
going to strive to explain why all of a

00:01:19,979 --> 00:01:24,479
sudden traits become more interesting

00:01:21,780 --> 00:01:26,280
more important to understand directly so

00:01:24,479 --> 00:01:29,250
before we do that little review of

00:01:26,280 --> 00:01:31,079
function overload function call overload

00:01:29,250 --> 00:01:32,970
resolution because that really plays a

00:01:31,079 --> 00:01:34,710
key part along when I talk about so when

00:01:32,970 --> 00:01:36,180
the compiler sees a function call how

00:01:34,710 --> 00:01:38,340
does it resolve that basically a

00:01:36,180 --> 00:01:42,060
three-step process if there's an exact

00:01:38,340 --> 00:01:44,430
match of the call to an existing non

00:01:42,060 --> 00:01:46,680
template function then it just uses that

00:01:44,430 --> 00:01:48,479
if there's not an exact matching but

00:01:46,680 --> 00:01:50,280
exactly I mean almost exact because

00:01:48,479 --> 00:01:52,740
references and constants can sometimes

00:01:50,280 --> 00:01:55,159
be flexible but essential exact if

00:01:52,740 --> 00:01:57,630
there's no exact non template it uses

00:01:55,159 --> 00:01:59,880
looks for a template that can be

00:01:57,630 --> 00:02:02,729
instantiated and if it finds one it uses

00:01:59,880 --> 00:02:05,250
it and if not then it reverts to the non

00:02:02,729 --> 00:02:07,460
template and considers conversions so

00:02:05,250 --> 00:02:08,750
that's basically the rules and

00:02:07,460 --> 00:02:10,039
it's gonna be a key here what we're

00:02:08,750 --> 00:02:13,310
going to talk about so for example

00:02:10,039 --> 00:02:14,690
here's two over loads of F an ordinary

00:02:13,310 --> 00:02:17,090
function it takes two floats and a

00:02:14,690 --> 00:02:20,000
function template in the main function

00:02:17,090 --> 00:02:22,569
the first line is a direct match for the

00:02:20,000 --> 00:02:25,520
non template it uses it the second line

00:02:22,569 --> 00:02:26,810
is not a direct match for the not in

00:02:25,520 --> 00:02:29,239
template because those aren't floats

00:02:26,810 --> 00:02:31,069
they're int so it considers the template

00:02:29,239 --> 00:02:32,330
it works great the third line there's a

00:02:31,069 --> 00:02:34,520
mixture of two different types it

00:02:32,330 --> 00:02:35,959
doesn't match the non template directly

00:02:34,520 --> 00:02:37,310
it can't match the template either

00:02:35,959 --> 00:02:39,290
because the types are different goes

00:02:37,310 --> 00:02:41,420
back and uses the non template with

00:02:39,290 --> 00:02:44,269
conversions of one of the arguments so

00:02:41,420 --> 00:02:46,850
that's just those rules in action now

00:02:44,269 --> 00:02:49,070
enter universal references when a

00:02:46,850 --> 00:02:52,190
universal reference appears which by the

00:02:49,070 --> 00:02:54,200
way as Scott defines universal

00:02:52,190 --> 00:02:56,140
references that say our value reference

00:02:54,200 --> 00:02:58,160
as a template parameter in a deduced

00:02:56,140 --> 00:03:00,260
context and this is very important

00:02:58,160 --> 00:03:01,820
compiler has to be able to be in a

00:03:00,260 --> 00:03:04,580
position of means to deduce that type

00:03:01,820 --> 00:03:07,700
well such a parameter tends to be greedy

00:03:04,580 --> 00:03:10,370
it hijacks any corresponding parameters

00:03:07,700 --> 00:03:11,840
for other overloads of that template but

00:03:10,370 --> 00:03:13,400
only for other templates still if

00:03:11,840 --> 00:03:15,829
there's a non template that's an exact

00:03:13,400 --> 00:03:18,049
match it'll still win but with that one

00:03:15,829 --> 00:03:19,970
exception the universal reference will

00:03:18,049 --> 00:03:23,110
end up resolving for just about

00:03:19,970 --> 00:03:25,820
everything for example we have a

00:03:23,110 --> 00:03:27,920
template F of top that takes universal

00:03:25,820 --> 00:03:29,329
reference another template that just

00:03:27,920 --> 00:03:31,010
takes reference to con so that one's

00:03:29,329 --> 00:03:34,459
actually never going to be selected and

00:03:31,010 --> 00:03:36,860
an ordinary function f5 calls down at

00:03:34,459 --> 00:03:39,049
the bottom the call of F of 10 is the

00:03:36,860 --> 00:03:41,900
direct match to the ordinary function so

00:03:39,049 --> 00:03:46,040
it uses it the other four are not so

00:03:41,900 --> 00:03:47,959
they end up being matched to the

00:03:46,040 --> 00:03:48,769
universal reference version and the one

00:03:47,959 --> 00:03:50,450
that might be a little bit of a surprise

00:03:48,769 --> 00:03:52,730
is the last one where it takes an

00:03:50,450 --> 00:03:53,959
unsigned 10 you because that's pretty

00:03:52,730 --> 00:03:56,000
close to an int you'd think it would

00:03:53,959 --> 00:03:58,790
match the end overload but no the

00:03:56,000 --> 00:04:01,130
universal reference is greedy and and it

00:03:58,790 --> 00:04:02,630
grabs that one and so that's kind of the

00:04:01,130 --> 00:04:05,480
crux of the problem here's an example

00:04:02,630 --> 00:04:08,410
with a class here's a class widget the

00:04:05,480 --> 00:04:11,000
salient thing about the widget is that

00:04:08,410 --> 00:04:12,739
it's it's a class type alright it has a

00:04:11,000 --> 00:04:15,070
little inserter that displays its value

00:04:12,739 --> 00:04:17,690
and it just holds an integer in it so

00:04:15,070 --> 00:04:20,209
here's two overloads of a function used

00:04:17,690 --> 00:04:21,139
Val the first one takes universal

00:04:20,209 --> 00:04:22,699
reference this

00:04:21,139 --> 00:04:24,979
second one the idea is it takes a long

00:04:22,699 --> 00:04:27,289
long and it's kind of supposed to handle

00:04:24,979 --> 00:04:29,449
all in two types right that's that's the

00:04:27,289 --> 00:04:32,509
idea anyway that somebody had writing

00:04:29,449 --> 00:04:34,400
that so for calls whether it's an

00:04:32,509 --> 00:04:36,020
l-value or our value widget it matches

00:04:34,400 --> 00:04:38,449
the universal and universal reference

00:04:36,020 --> 00:04:40,430
version which makes perfect sense

00:04:38,449 --> 00:04:42,680
widgets aren't an integer if I pass a

00:04:40,430 --> 00:04:44,779
long-long directly ten ll that will

00:04:42,680 --> 00:04:47,810
match the ordinary function because it's

00:04:44,779 --> 00:04:51,319
an exact match but plain old ten again

00:04:47,810 --> 00:04:52,729
ends up being matched with the universal

00:04:51,319 --> 00:04:54,590
reference which might be a bit of a

00:04:52,729 --> 00:04:57,080
surprise so how do we avoid the problem

00:04:54,590 --> 00:04:58,539
well don't overload the function pick

00:04:57,080 --> 00:05:01,069
different names for all the functions

00:04:58,539 --> 00:05:02,360
sometimes that works sometimes not if

00:05:01,069 --> 00:05:03,740
you're trying to overload constructor x'

00:05:02,360 --> 00:05:05,719
that won't work

00:05:03,740 --> 00:05:07,909
replace the universal reference with

00:05:05,719 --> 00:05:11,180
different types reference to Const or

00:05:07,909 --> 00:05:12,800
pass by value that may give you the

00:05:11,180 --> 00:05:14,539
right behavior but you might lose some

00:05:12,800 --> 00:05:16,520
efficiency and also you lose the ability

00:05:14,539 --> 00:05:18,469
to perfect forward arguments which could

00:05:16,520 --> 00:05:20,240
be a problem so sometimes you just need

00:05:18,469 --> 00:05:22,789
to have the universal reference version

00:05:20,240 --> 00:05:25,819
how do you make that happen here's where

00:05:22,789 --> 00:05:28,009
type traits and metaprogramming come in

00:05:25,819 --> 00:05:31,310
we can use tag dispatch here to

00:05:28,009 --> 00:05:33,289
disambiguate so the top the top function

00:05:31,310 --> 00:05:35,509
template uses values just one use Val

00:05:33,289 --> 00:05:38,110
now it takes a universal reference but

00:05:35,509 --> 00:05:41,029
it dispatches to an implementation

00:05:38,110 --> 00:05:43,490
function and I supply two versions of

00:05:41,029 --> 00:05:45,889
the implementation functions one of

00:05:43,490 --> 00:05:47,899
which both of which takes the universal

00:05:45,889 --> 00:05:51,409
reference as the first argument but one

00:05:47,899 --> 00:05:54,199
takes a true type which is a type that

00:05:51,409 --> 00:05:56,120
is conceptually true for overloading

00:05:54,199 --> 00:05:58,159
purposes and when taking a false type

00:05:56,120 --> 00:06:00,289
and then we make a decision of which of

00:05:58,159 --> 00:06:02,779
these two is going to be used with this

00:06:00,289 --> 00:06:06,139
tag dispatch technique so what we're

00:06:02,779 --> 00:06:09,050
asking is is T a widget basically is

00:06:06,139 --> 00:06:11,719
what all this says to do it kosha 'we

00:06:09,050 --> 00:06:14,120
have to spell it all out and if this

00:06:11,719 --> 00:06:14,719
about if this same expression evaluates

00:06:14,120 --> 00:06:17,360
to true

00:06:14,719 --> 00:06:20,149
it ends up resolving to this first

00:06:17,360 --> 00:06:22,580
implementation and if not it resolves to

00:06:20,149 --> 00:06:24,969
the second so if it's true it's a widget

00:06:22,580 --> 00:06:28,639
otherwise it's not a widget

00:06:24,969 --> 00:06:31,300
example of running that use vowel of w

00:06:28,639 --> 00:06:34,270
is a widget widget of five is an r-value

00:06:31,300 --> 00:06:36,970
widget 10 ll not a widget and finally

00:06:34,270 --> 00:06:39,580
plain old 10 also not a widget good and

00:06:36,970 --> 00:06:42,340
we've done that with a technique called

00:06:39,580 --> 00:06:44,319
tag dispatch so here's a reason to use

00:06:42,340 --> 00:06:46,569
that kind of a technique sort of a more

00:06:44,319 --> 00:06:49,330
mainstream code not just in library

00:06:46,569 --> 00:06:52,210
implementation necessarily C++ 14 lets

00:06:49,330 --> 00:06:54,220
you shorten the text a little bit so

00:06:52,210 --> 00:06:57,659
this text in white becomes remove

00:06:54,220 --> 00:07:01,030
reference T T a little bit shorter so

00:06:57,659 --> 00:07:03,400
limitations of tag dispatch tag dispatch

00:07:01,030 --> 00:07:05,129
is of course based on decisions based on

00:07:03,400 --> 00:07:07,509
tags and it requires extra

00:07:05,129 --> 00:07:10,659
instrumentation these helper functions

00:07:07,509 --> 00:07:13,210
have to be added there's another way to

00:07:10,659 --> 00:07:16,270
sort of get the same result and that

00:07:13,210 --> 00:07:18,759
requires understanding SVA so a quick

00:07:16,270 --> 00:07:21,550
review of SVA which is substitution

00:07:18,759 --> 00:07:23,289
failure is not an error let's say we

00:07:21,550 --> 00:07:24,789
have a widget class here and again the

00:07:23,289 --> 00:07:27,430
salient features of this one is it has

00:07:24,789 --> 00:07:30,550
nested types or nested members so it has

00:07:27,430 --> 00:07:33,699
a nested result type type and it has a

00:07:30,550 --> 00:07:34,990
nested member function process and then

00:07:33,699 --> 00:07:36,759
we're gonna show two overloads of a

00:07:34,990 --> 00:07:38,529
function called crunch one on this slide

00:07:36,759 --> 00:07:41,050
one on the next the one on this slide

00:07:38,529 --> 00:07:42,969
assumes it's working with something that

00:07:41,050 --> 00:07:44,710
has this structure it has a nested

00:07:42,969 --> 00:07:47,199
result type so you can see the return

00:07:44,710 --> 00:07:48,580
value of this function is T colon colon

00:07:47,199 --> 00:07:50,680
result type obviously this will only

00:07:48,580 --> 00:07:52,630
make sense for a type T that has a

00:07:50,680 --> 00:07:54,159
results type and then we have another

00:07:52,630 --> 00:07:58,930
crunch that just works with unsigned

00:07:54,159 --> 00:08:00,699
long long integer types again so the key

00:07:58,930 --> 00:08:03,490
here is to look at this call to crunched

00:08:00,699 --> 00:08:05,680
n using those resolution rules I

00:08:03,490 --> 00:08:08,199
mentioned earlier first it looks for an

00:08:05,680 --> 00:08:10,599
exact match there's no exact match so it

00:08:08,199 --> 00:08:13,719
considers templates now when it tries to

00:08:10,599 --> 00:08:15,699
plug that call into this template it

00:08:13,719 --> 00:08:17,770
immediately runs into a problem the type

00:08:15,699 --> 00:08:20,590
T is int int it doesn't have a nested

00:08:17,770 --> 00:08:22,270
result type that's illegal

00:08:20,590 --> 00:08:23,860
but instead of getting an error you get

00:08:22,270 --> 00:08:25,479
the compiler saying okay that's won't

00:08:23,860 --> 00:08:28,090
work and moves on to some other template

00:08:25,479 --> 00:08:30,069
and it keeps looking that's SGA it's not

00:08:28,090 --> 00:08:31,599
necessarily an error unless it never

00:08:30,069 --> 00:08:33,279
finds a match and then the error is

00:08:31,599 --> 00:08:34,839
there's no match it's not necessarily

00:08:33,279 --> 00:08:38,469
the error is here in this particular

00:08:34,839 --> 00:08:41,199
piece of code all right so that's as

00:08:38,469 --> 00:08:43,370
feigning and the library component that

00:08:41,199 --> 00:08:45,380
will leverage this is called enable

00:08:43,370 --> 00:08:48,320
so this is a little meta programming

00:08:45,380 --> 00:08:50,660
component that's used to turn code on or

00:08:48,320 --> 00:08:53,090
off based on some compile time logical

00:08:50,660 --> 00:08:55,550
condition the basic structure is enable

00:08:53,090 --> 00:08:57,770
if some boolean compile time expression

00:08:55,550 --> 00:09:00,190
because it's a template parameter and

00:08:57,770 --> 00:09:02,990
then a type if the boolean expression

00:09:00,190 --> 00:09:04,940
evaluates at compile time to true then

00:09:02,990 --> 00:09:07,940
this whole thing evaluates to this type

00:09:04,940 --> 00:09:09,830
and if it's false then something

00:09:07,940 --> 00:09:12,770
interesting happens this turns into bad

00:09:09,830 --> 00:09:14,930
code on purpose that becomes an illegal

00:09:12,770 --> 00:09:17,030
construct and it basically causes any

00:09:14,930 --> 00:09:18,470
piece of code in which disappears to

00:09:17,030 --> 00:09:20,810
become illegal and to disappear from the

00:09:18,470 --> 00:09:24,020
face of the compilation which is what

00:09:20,810 --> 00:09:26,750
you actually want so let's see how this

00:09:24,020 --> 00:09:29,810
will work so applying this to our crunch

00:09:26,750 --> 00:09:32,240
example earlier now I have to crunch

00:09:29,810 --> 00:09:34,520
function templates and I want the top

00:09:32,240 --> 00:09:38,210
one to be enabled for type T's that are

00:09:34,520 --> 00:09:39,860
our what am I looking for here class

00:09:38,210 --> 00:09:42,290
types that's all I'm just checking for a

00:09:39,860 --> 00:09:44,300
class type if the class type doesn't

00:09:42,290 --> 00:09:46,310
happen to have a process member function

00:09:44,300 --> 00:09:48,890
we'll get an error but just to keep this

00:09:46,310 --> 00:09:50,510
simple I'm saying if it's a class then I

00:09:48,890 --> 00:09:52,520
want to enable this thing and notice

00:09:50,510 --> 00:09:55,160
where the enable if appears it's part of

00:09:52,520 --> 00:09:56,900
the return type declaration so that's

00:09:55,160 --> 00:09:58,490
one of the two ways it can be used and I

00:09:56,900 --> 00:10:02,450
wanted to show you both so this is one

00:09:58,490 --> 00:10:04,760
of them and when crunch is called with

00:10:02,450 --> 00:10:07,130
some parameter that's not a class type

00:10:04,760 --> 00:10:11,830
this will not be considered for overload

00:10:07,130 --> 00:10:15,050
resolution the other one will and by

00:10:11,830 --> 00:10:17,330
rather than doing not class type I just

00:10:15,050 --> 00:10:19,610
chose is integral so this one is enabled

00:10:17,330 --> 00:10:20,780
for any integral type of T which is kind

00:10:19,610 --> 00:10:22,460
of the effect we've wanted all along

00:10:20,780 --> 00:10:26,000
where I wanted to work for longs on

00:10:22,460 --> 00:10:28,730
signs etc and so examples of calls

00:10:26,000 --> 00:10:34,810
processing with ten or with a short will

00:10:28,730 --> 00:10:36,770
use the integral version oops sorry

00:10:34,810 --> 00:10:38,150
actually I don't have code that example

00:10:36,770 --> 00:10:39,680
that shows an example of that this is

00:10:38,150 --> 00:10:41,480
actually a simpler example this is just

00:10:39,680 --> 00:10:44,180
a single processing function which I

00:10:41,480 --> 00:10:47,990
only want to enable for integers so I do

00:10:44,180 --> 00:10:51,680
that by using the enable if as part of a

00:10:47,990 --> 00:10:54,410
second parameter declaration that I

00:10:51,680 --> 00:10:56,000
default initialize to zero and clients

00:10:54,410 --> 00:10:56,850
never actually use this parameter it's

00:10:56,000 --> 00:10:58,529
just there

00:10:56,850 --> 00:11:00,930
to either cause the function to be legal

00:10:58,529 --> 00:11:03,540
or illegal at compile time so when I

00:11:00,930 --> 00:11:07,019
instantiate with any integral type this

00:11:03,540 --> 00:11:11,130
thing ends up producing that integral

00:11:07,019 --> 00:11:13,110
type enabling this piece of code and the

00:11:11,130 --> 00:11:16,709
function exists if it's not an integral

00:11:13,110 --> 00:11:18,630
type then this code is rendered illegal

00:11:16,709 --> 00:11:20,190
and it won't compile so we get an error

00:11:18,630 --> 00:11:21,540
when we try to pass a double or a

00:11:20,190 --> 00:11:24,870
pointer but it works fine with an

00:11:21,540 --> 00:11:27,000
integer or a short and here's the actual

00:11:24,870 --> 00:11:28,230
implementation of enable if just just

00:11:27,000 --> 00:11:31,319
showing it because I find it interesting

00:11:28,230 --> 00:11:33,630
the primary template is an empty class

00:11:31,319 --> 00:11:35,220
and that's why any attempt to take call

00:11:33,630 --> 00:11:36,839
and call and type on that is gonna yield

00:11:35,220 --> 00:11:39,870
a syntax error there's nothing in there

00:11:36,839 --> 00:11:42,240
and there's a specialization for when

00:11:39,870 --> 00:11:44,459
the first temporal parameter is true

00:11:42,240 --> 00:11:46,199
which actually does put that type in

00:11:44,459 --> 00:11:48,449
there so you can select it and makes the

00:11:46,199 --> 00:11:50,819
code legal so that's it this was

00:11:48,449 --> 00:11:53,850
inspired by an item in Scotts effective

00:11:50,819 --> 00:11:55,470
modern C++ course and book I having to

00:11:53,850 --> 00:11:57,360
teach the course as well and I just

00:11:55,470 --> 00:12:00,350
thought I would share that because I

00:11:57,360 --> 00:12:00,350

YouTube URL: https://www.youtube.com/watch?v=bVDX_z3PsfM


