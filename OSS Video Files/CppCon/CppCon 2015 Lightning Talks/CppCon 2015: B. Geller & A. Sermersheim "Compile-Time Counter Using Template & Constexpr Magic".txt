Title: CppCon 2015: B. Geller & A. Sermersheim "Compile-Time Counter Using Template & Constexpr Magic"
Publication date: 2015-10-21
Playlist: CppCon 2015 Lightning Talks
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,410
I'm Barbara this is Ansel we've done

00:00:02,010 --> 00:00:07,170
copper spice and oxy press what we're

00:00:04,410 --> 00:00:11,250
gonna be talking about is compile-time

00:00:07,170 --> 00:00:13,590
counters in the process of doing copper

00:00:11,250 --> 00:00:15,660
spice what we needed to do was we needed

00:00:13,590 --> 00:00:18,900
to do some registration for some meta

00:00:15,660 --> 00:00:22,170
type data the problem was how to do this

00:00:18,900 --> 00:00:24,449
it isn't practical to actually do all

00:00:22,170 --> 00:00:26,550
the code that you need to do and to

00:00:24,449 --> 00:00:29,189
write it all by hand so we needed a way

00:00:26,550 --> 00:00:35,820
to automate this process so what we came

00:00:29,189 --> 00:00:38,280
up with was a way that you actually do

00:00:35,820 --> 00:00:44,040
some information and then you chain

00:00:38,280 --> 00:00:45,719
everything and in the process so in the

00:00:44,040 --> 00:00:48,539
process what we actually want to do is

00:00:45,719 --> 00:00:51,210
we want to register some data and some

00:00:48,539 --> 00:00:53,940
metadata we want to do that in CS

00:00:51,210 --> 00:00:55,890
register 0 and we actually want to

00:00:53,940 --> 00:00:59,340
register the data and then call CS

00:00:55,890 --> 00:01:02,579
register one we want CS register 1 to do

00:00:59,340 --> 00:01:09,240
something and call CS register 2 the

00:01:02,579 --> 00:01:12,060
problem is 0 & 1 let's just call 0 & 1

00:01:09,240 --> 00:01:14,250
our values they're not data types and

00:01:12,060 --> 00:01:17,070
we're trying to use method overloading

00:01:14,250 --> 00:01:19,350
so the problem is how do you actually do

00:01:17,070 --> 00:01:21,390
this and use method overloading when

00:01:19,350 --> 00:01:27,630
these are numeric values and they're not

00:01:21,390 --> 00:01:29,520
data types and we put this slide in here

00:01:27,630 --> 00:01:32,610
for reference if anybody's unfamiliar

00:01:29,520 --> 00:01:34,020
with Const expert one of the things that

00:01:32,610 --> 00:01:36,119
we're going to be using in this talk is

00:01:34,020 --> 00:01:38,729
contacts / very heavily and it allows

00:01:36,119 --> 00:01:40,619
you to set up a value that has evaluated

00:01:38,729 --> 00:01:43,350
at compile time so you can use it for

00:01:40,619 --> 00:01:44,220
things like the size of an array we'll

00:01:43,350 --> 00:01:51,329
be using it in a slightly different

00:01:44,220 --> 00:01:52,950
context in a moment so as part of our

00:01:51,329 --> 00:01:54,930
solution we had to use templates because

00:01:52,950 --> 00:01:57,420
the solution to every complex problem in

00:01:54,930 --> 00:02:00,689
C++ involves templates in some fashion

00:01:57,420 --> 00:02:03,689
and what we need to do is we need to

00:02:00,689 --> 00:02:05,610
somehow have a value wrapped up as a

00:02:03,689 --> 00:02:07,890
data type now usually when you're using

00:02:05,610 --> 00:02:10,080
a template the reason you're using it is

00:02:07,890 --> 00:02:12,510
because you want to pass a data type as

00:02:10,080 --> 00:02:14,159
a parameter to some class or

00:02:12,510 --> 00:02:16,439
function or method or what have you and

00:02:14,159 --> 00:02:18,349
the question is can you pass an integer

00:02:16,439 --> 00:02:21,420
as a data type and of course you can

00:02:18,349 --> 00:02:23,760
what not as many people realize is that

00:02:21,420 --> 00:02:27,060
when you define a template of data type

00:02:23,760 --> 00:02:29,010
based on an integral parameter that

00:02:27,060 --> 00:02:31,230
results in a unique data type that's

00:02:29,010 --> 00:02:33,299
distinct from every other integer that

00:02:31,230 --> 00:02:41,190
you could pass to that template of data

00:02:33,299 --> 00:02:44,640
type so what we have here is this

00:02:41,190 --> 00:02:49,109
template CS int and what we're noticing

00:02:44,640 --> 00:02:50,879
here is CS int the N minus 1 so what

00:02:49,109 --> 00:02:54,120
this class does is it wraps up an

00:02:50,879 --> 00:02:55,590
integer inside a templated class but

00:02:54,120 --> 00:02:57,180
more importantly we've set up an

00:02:55,590 --> 00:02:59,760
inheritance relationship where 3

00:02:57,180 --> 00:03:01,829
inherits from - 2 inherits from one one

00:02:59,760 --> 00:03:04,560
inherits from 0 then we've had to

00:03:01,829 --> 00:03:06,480
specialize the templated class to stop

00:03:04,560 --> 00:03:08,129
the recursion at zero otherwise it would

00:03:06,480 --> 00:03:12,209
just continue infinitely into the

00:03:08,129 --> 00:03:16,409
negative numbers so what you're looking

00:03:12,209 --> 00:03:22,980
at is one too many slides yes so what

00:03:16,409 --> 00:03:25,230
we're looking at what we're looking at

00:03:22,980 --> 00:03:27,269
here is class ginger this is the

00:03:25,230 --> 00:03:30,060
beginning of a class there actually is a

00:03:27,269 --> 00:03:31,739
macro in the real code what we've done

00:03:30,060 --> 00:03:34,079
is we're showing the expansion here

00:03:31,739 --> 00:03:36,419
we've left out some of the details we're

00:03:34,079 --> 00:03:39,750
showing the main information and we're

00:03:36,419 --> 00:03:41,699
showing this templated method now this

00:03:39,750 --> 00:03:45,060
template and Method is what's going to

00:03:41,699 --> 00:03:46,650
catch the end of our chain this is a

00:03:45,060 --> 00:03:48,150
templated method that's good for any

00:03:46,650 --> 00:03:51,000
integer value and it will simply do

00:03:48,150 --> 00:03:53,220
nothing the second part of this is we're

00:03:51,000 --> 00:03:56,400
declaring a method called CS counter

00:03:53,220 --> 00:03:59,699
that takes a wrapped 0 and returns a

00:03:56,400 --> 00:04:01,769
wrapped 0 hold on to this line remember

00:03:59,699 --> 00:04:03,180
it will use it in a moment notice we're

00:04:01,769 --> 00:04:07,260
still at the opening curly so we're

00:04:03,180 --> 00:04:09,510
still inside this declaration so now

00:04:07,260 --> 00:04:12,000
what we have here is we're assuming that

00:04:09,510 --> 00:04:15,209
there's another macro on line 42 and

00:04:12,000 --> 00:04:16,829
then a macro on line 43 we're trying to

00:04:15,209 --> 00:04:18,090
show just the snippets of code that

00:04:16,829 --> 00:04:21,389
actually makes sense

00:04:18,090 --> 00:04:24,090
so the first top part is what's expanded

00:04:21,389 --> 00:04:26,440
for line 42 the bottom is what's on 43

00:04:24,090 --> 00:04:29,440
and the question is

00:04:26,440 --> 00:04:34,660
what is the value 42 and what is value

00:04:29,440 --> 00:04:44,530
43 anybody care to hazard a guess and

00:04:34,660 --> 00:04:47,320
why 42 very good I points for the

00:04:44,530 --> 00:04:49,390
reference so there's the static context

00:04:47,320 --> 00:04:55,170
fir and we are doing an assignment of

00:04:49,390 --> 00:05:01,150
value of 42 there's a deckle type

00:04:55,170 --> 00:05:03,400
there's the CS counter so the way that I

00:05:01,150 --> 00:05:05,050
like to look at deckle type it in this

00:05:03,400 --> 00:05:07,750
particular context we're using an

00:05:05,050 --> 00:05:09,490
expression deckle type the way I look at

00:05:07,750 --> 00:05:11,830
expression dekho type is it's a

00:05:09,490 --> 00:05:13,930
hypothetical statement is if I were to

00:05:11,830 --> 00:05:17,590
do this thing at this point in the code

00:05:13,930 --> 00:05:19,450
what data type would it evaluate to so

00:05:17,590 --> 00:05:22,870
in this case we're saying if I were to

00:05:19,450 --> 00:05:26,260
call CS counter with a wrapped 255 what

00:05:22,870 --> 00:05:28,890
would I get back and the answer is by

00:05:26,260 --> 00:05:32,440
the normal rules for method overloading

00:05:28,890 --> 00:05:34,450
it would match the zero and the reason

00:05:32,440 --> 00:05:36,970
for that is because 255 inherits from

00:05:34,450 --> 00:05:39,460
254 inherits from 253 all the way down

00:05:36,970 --> 00:05:41,560
to 0 and therefore you can successfully

00:05:39,460 --> 00:05:47,340
call the method that we declared on the

00:05:41,560 --> 00:05:47,340
previous slide so value 42 will be 0

00:05:47,610 --> 00:05:54,370
then on the following line what we do is

00:05:51,669 --> 00:05:56,680
we declare a new overload of the CS

00:05:54,370 --> 00:06:01,510
counter method that takes a wrapped one

00:05:56,680 --> 00:06:04,900
and returns a wrapped one therefore in

00:06:01,510 --> 00:06:07,540
the second half of the slide when we

00:06:04,900 --> 00:06:10,450
evaluate value 43 and you'll notice that

00:06:07,540 --> 00:06:12,970
value 42 and value 43 are initialized

00:06:10,450 --> 00:06:14,950
with exactly the same expression is

00:06:12,970 --> 00:06:18,400
exactly the same expression and it is

00:06:14,950 --> 00:06:21,460
Const expert however value 43 will get

00:06:18,400 --> 00:06:25,240
the value 1 because when the compiler

00:06:21,460 --> 00:06:28,830
resolves the overloaded method 255 is

00:06:25,240 --> 00:06:31,480
slightly closer to 1 than it is to 0

00:06:28,830 --> 00:06:32,890
therefore the overloaded method that

00:06:31,480 --> 00:06:35,529
will be found is the one we just

00:06:32,890 --> 00:06:37,569
declared that returns a 1 the visibility

00:06:35,529 --> 00:06:40,449
this is because it can only look up at

00:06:37,569 --> 00:06:42,789
this point it can't look down so it does

00:06:40,449 --> 00:06:47,259
compile it does actually work and so

00:06:42,789 --> 00:06:49,689
value 43 will be a one now notice in

00:06:47,259 --> 00:06:51,819
here that we're doing the same type of a

00:06:49,689 --> 00:06:53,169
code when you go to the next slide what

00:06:51,819 --> 00:06:56,139
you're gonna see is now we're expanding

00:06:53,169 --> 00:06:58,419
what really happened with 42 so again

00:06:56,139 --> 00:07:01,779
with 42 we're at a value of zero and

00:06:58,419 --> 00:07:04,119
what you can see is in the static void

00:07:01,779 --> 00:07:06,429
CS register we're actually calling our

00:07:04,119 --> 00:07:07,599
Stata meta object register method that's

00:07:06,429 --> 00:07:10,569
where we're actually doing what

00:07:07,599 --> 00:07:12,759
registration we've put in some V values

00:07:10,569 --> 00:07:14,799
in here we didn't expand all of the

00:07:12,759 --> 00:07:16,209
values simply because some of them got

00:07:14,799 --> 00:07:18,669
really long and it didn't fit on the

00:07:16,209 --> 00:07:20,739
slide but then notice at the end of that

00:07:18,669 --> 00:07:23,729
method this is where the chaining will

00:07:20,739 --> 00:07:28,359
take place and it will call cs register

00:07:23,729 --> 00:07:29,709
passing a1 so now the visibility is that

00:07:28,359 --> 00:07:33,329
it's calling something that isn't

00:07:29,709 --> 00:07:36,369
defined yet so it's visible below so

00:07:33,329 --> 00:07:38,409
that becomes the question if you look at

00:07:36,369 --> 00:07:42,249
the two highlighted points on the screen

00:07:38,409 --> 00:07:45,789
I mentioned that in the first case the

00:07:42,249 --> 00:07:47,469
compiler will only consider for overload

00:07:45,789 --> 00:07:51,039
resolution the methods that are already

00:07:47,469 --> 00:07:53,529
visible however in the second case down

00:07:51,039 --> 00:07:55,299
at the bottom of the screen we are able

00:07:53,529 --> 00:07:58,329
to call a method that has not yet been

00:07:55,299 --> 00:08:03,879
declared does anybody know why this is

00:07:58,329 --> 00:08:06,099
possible the standard defines when a

00:08:03,879 --> 00:08:08,199
class is complete and most of us all

00:08:06,099 --> 00:08:09,999
know that the end of the curly a class

00:08:08,199 --> 00:08:12,549
is complete this is one of the obvious

00:08:09,999 --> 00:08:14,649
cases we also talked about that

00:08:12,549 --> 00:08:16,629
something is complete between Curly's on

00:08:14,649 --> 00:08:19,329
an inline function but there's a couple

00:08:16,629 --> 00:08:22,149
of other very obscure exceptions in a

00:08:19,329 --> 00:08:25,179
standard and it turns out that those

00:08:22,149 --> 00:08:26,769
exceptions work in our favor the first

00:08:25,179 --> 00:08:29,379
exception which I'll mention for

00:08:26,769 --> 00:08:32,679
completeness is that after the equal

00:08:29,379 --> 00:08:36,339
sign that declares a default value for a

00:08:32,679 --> 00:08:38,019
parameter of a method the entire class

00:08:36,339 --> 00:08:39,339
is considered complete and therefore you

00:08:38,019 --> 00:08:42,909
can refer to things that have not yet

00:08:39,339 --> 00:08:45,819
been defined the other location where it

00:08:42,909 --> 00:08:48,600
is defined to be complete is after the

00:08:45,819 --> 00:08:52,560
equal sign of the default initialize

00:08:48,600 --> 00:08:55,740
for a non-static Const member variable

00:08:52,560 --> 00:08:57,149
and this becomes very important because

00:08:55,740 --> 00:09:00,209
if you'll note at the top of the screen

00:08:57,149 --> 00:09:02,399
what we have is a static Const member

00:09:00,209 --> 00:09:05,639
variable which means in this context at

00:09:02,399 --> 00:09:07,529
the top the compiler is not permitted to

00:09:05,639 --> 00:09:09,899
look at any methods that are declared

00:09:07,529 --> 00:09:12,620
below that line for purposes of

00:09:09,899 --> 00:09:15,180
evaluating that deckle type however

00:09:12,620 --> 00:09:17,550
inside the method at the bottom of the

00:09:15,180 --> 00:09:19,350
screen the compiler can see the entire

00:09:17,550 --> 00:09:22,589
class even methods that have not yet

00:09:19,350 --> 00:09:24,959
been declared so this is allowing you to

00:09:22,589 --> 00:09:27,480
actually create a counter based on

00:09:24,959 --> 00:09:29,730
runtime information and allows us to do

00:09:27,480 --> 00:09:32,430
a concatenation what this did is it gave

00:09:29,730 --> 00:09:34,730
us the ability to set up everything to

00:09:32,430 --> 00:09:37,170
have the macros that we established and

00:09:34,730 --> 00:09:38,970
it actually went through and set up

00:09:37,170 --> 00:09:41,250
everything and then every time we

00:09:38,970 --> 00:09:43,259
instantiate a class the registration

00:09:41,250 --> 00:09:45,660
happens automatically we don't have to

00:09:43,259 --> 00:09:48,360
keep track of the count it was pointed

00:09:45,660 --> 00:09:50,519
out to us the value of 255 that is the

00:09:48,360 --> 00:09:54,690
clang limitation which can be overridden

00:09:50,519 --> 00:09:56,940
by a parameter but the truth is this

00:09:54,690 --> 00:10:00,240
code gets optimized in a very amazing

00:09:56,940 --> 00:10:01,440
way we actually looked at the assembly

00:10:00,240 --> 00:10:04,380
dump on a lot of this

00:10:01,440 --> 00:10:06,959
and speaking of clay if you compile this

00:10:04,380 --> 00:10:10,139
code with claim my hats off to their

00:10:06,959 --> 00:10:12,389
optimization teenies because this code

00:10:10,139 --> 00:10:14,970
is compiled and optimized in the most

00:10:12,389 --> 00:10:17,760
amazing way possible the entire integer

00:10:14,970 --> 00:10:19,889
wrapper disappears all of the overloaded

00:10:17,760 --> 00:10:22,079
methods disappear and it tail call

00:10:19,889 --> 00:10:24,269
optimized --is all of the CS register

00:10:22,079 --> 00:10:26,670
methods together so this is a zero

00:10:24,269 --> 00:10:29,510
overhead mechanism for chaining method

00:10:26,670 --> 00:10:34,110
calls together in the body of a class

00:10:29,510 --> 00:10:36,149
and we believe that this is a useful

00:10:34,110 --> 00:10:39,000
technique if you should ever have a need

00:10:36,149 --> 00:10:41,819
for it you can actually store a counter

00:10:39,000 --> 00:10:44,100
in the overloaded method table of your

00:10:41,819 --> 00:10:46,500
compiler and it will work at standards

00:10:44,100 --> 00:10:49,199
compliant and C++ 11 and anything later

00:10:46,500 --> 00:10:52,170
it still works obviously in GCC there

00:10:49,199 --> 00:10:54,660
optimization isn't quite as excellent as

00:10:52,170 --> 00:10:57,180
playing but it's still really good in

00:10:54,660 --> 00:10:59,819
the GCC implementation all of the

00:10:57,180 --> 00:11:02,490
extraneous parts the integer wrapper is

00:10:59,819 --> 00:11:04,080
optimized away however it's not quite

00:11:02,490 --> 00:11:06,660
smart enough to see through the tail

00:11:04,080 --> 00:11:08,220
call nature of these methods so you do

00:11:06,660 --> 00:11:10,800
end up with separate registration

00:11:08,220 --> 00:11:14,930
methods for each integer not quite as

00:11:10,800 --> 00:11:18,300
low overhead but still quite impressive

00:11:14,930 --> 00:11:20,730
and just in case anyone's curious copper

00:11:18,300 --> 00:11:23,339
spies and doxy press everything is

00:11:20,730 --> 00:11:25,680
available off of our website we're

00:11:23,339 --> 00:11:27,600
available for questions and - over any

00:11:25,680 --> 00:11:29,640
of this code in case anybody wants to

00:11:27,600 --> 00:11:32,580
chat with us about it and we hope you'll

00:11:29,640 --> 00:11:35,990
take a look at both copper spice and oxy

00:11:32,580 --> 00:11:35,990

YouTube URL: https://www.youtube.com/watch?v=gI6Qtn4US9E


