Title: C++20 Lambdas: Familiar Template Syntax - Ben Deane - CppCon 2020
Publication date: 2020-10-15
Playlist: CppCon 2020 Lightning Talks
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Some simplifying use cases for the new "template head" ability with lambdas in C++20.

---
Ben was in the game industry for 23 years, at companies like EA and Blizzard. For the last couple of years he's been working in the finance industry at Quantlab. He's always looking for useful new techniques in C++, and he geeks out on algorithms, APIs, types and functional programming.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,519 --> 00:00:14,960
so i wanted to just highlight

00:00:11,280 --> 00:00:17,920
a little thing about c plus 20 lambdas

00:00:14,960 --> 00:00:18,720
in 14 we got generic lambdas as you know

00:00:17,920 --> 00:00:20,480
uh which

00:00:18,720 --> 00:00:22,320
allows us to template lambda but we only

00:00:20,480 --> 00:00:23,119
get to say auto in the function

00:00:22,320 --> 00:00:25,359
signature

00:00:23,119 --> 00:00:27,279
and we have to deal with the value

00:00:25,359 --> 00:00:29,840
categories in this weird way by

00:00:27,279 --> 00:00:32,719
decal type and it was cumbersome but in

00:00:29,840 --> 00:00:34,880
cpap plus 20 we got the ability to do

00:00:32,719 --> 00:00:37,280
what what the paper calls familiar

00:00:34,880 --> 00:00:39,520
templates syntax lambdas and and

00:00:37,280 --> 00:00:40,800
i haven't heard a really good adopted

00:00:39,520 --> 00:00:41,600
name this some people call them template

00:00:40,800 --> 00:00:42,800
lambdas but

00:00:41,600 --> 00:00:44,559
you know generic lambda is already

00:00:42,800 --> 00:00:46,320
templates anyway i'm going with what the

00:00:44,559 --> 00:00:48,160
paper says which is familiar template

00:00:46,320 --> 00:00:49,680
syntax

00:00:48,160 --> 00:00:51,199
which gives us this template head so we

00:00:49,680 --> 00:00:53,120
can name the types

00:00:51,199 --> 00:00:55,360
and get access to the deduce types much

00:00:53,120 --> 00:00:58,559
more easily

00:00:55,360 --> 00:00:59,440
okay it's easier so where would we use

00:00:58,559 --> 00:01:02,879
it

00:00:59,440 --> 00:01:04,320
well consider something like stood apply

00:01:02,879 --> 00:01:05,360
i know this is a lot of code for this

00:01:04,320 --> 00:01:06,560
time in the morning for those of you

00:01:05,360 --> 00:01:09,119
where it is the morning but

00:01:06,560 --> 00:01:11,600
um this is from cpreference.com this is

00:01:09,119 --> 00:01:13,280
a sample implementation of stood apply

00:01:11,600 --> 00:01:15,040
we can see that the main body at the

00:01:13,280 --> 00:01:17,360
bottom all it does

00:01:15,040 --> 00:01:19,920
is make the index sequence and then

00:01:17,360 --> 00:01:22,159
delegate to the helper function

00:01:19,920 --> 00:01:23,840
well with familiar template syntax

00:01:22,159 --> 00:01:24,720
lambdas we can collapse these two

00:01:23,840 --> 00:01:27,200
functions

00:01:24,720 --> 00:01:29,119
and make an immediately invoked familiar

00:01:27,200 --> 00:01:32,240
template syntax lambda

00:01:29,119 --> 00:01:32,880
or fts iilly because we like these

00:01:32,240 --> 00:01:35,920
things in c

00:01:32,880 --> 00:01:37,360
plus we like long acronyms

00:01:35,920 --> 00:01:39,600
and you can see the lambda captures by

00:01:37,360 --> 00:01:41,119
reference and inside the lambda we just

00:01:39,600 --> 00:01:44,640
do all the same forwarding

00:01:41,119 --> 00:01:46,079
but it's much more compact much more uh

00:01:44,640 --> 00:01:49,600
you know you need less code you've got

00:01:46,079 --> 00:01:49,600
less identifiers you're exposing

00:01:50,799 --> 00:01:56,079
so here's another example which is uh

00:01:54,240 --> 00:01:57,840
for each on tuples if you just want a

00:01:56,079 --> 00:01:59,759
simple unary for each on tuples

00:01:57,840 --> 00:02:01,680
you can get that using a regular

00:01:59,759 --> 00:02:04,399
invocation of stood apply

00:02:01,680 --> 00:02:05,840
uh like this with the with the familiar

00:02:04,399 --> 00:02:08,879
template syntax lambda

00:02:05,840 --> 00:02:10,879
having a uh pack and then

00:02:08,879 --> 00:02:12,879
forwarding the thing to each folding

00:02:10,879 --> 00:02:14,959
each thing in the alpaca to the function

00:02:12,879 --> 00:02:16,800
so this is for a unary function but if

00:02:14,959 --> 00:02:18,560
you want a binary function over two

00:02:16,800 --> 00:02:19,920
tuples or potentially an energy function

00:02:18,560 --> 00:02:22,319
over more tuples

00:02:19,920 --> 00:02:23,040
you need to do a little bit more work

00:02:22,319 --> 00:02:24,879
and

00:02:23,040 --> 00:02:28,080
uh jonathan bacara had a blog post on

00:02:24,879 --> 00:02:32,080
this called stl algorithms on tuples

00:02:28,080 --> 00:02:32,080
on fluentcpp.com a while back

00:02:32,160 --> 00:02:36,720
and you can see it uses the same kind of

00:02:34,239 --> 00:02:38,800
pattern as did apply

00:02:36,720 --> 00:02:40,640
so the the bottom function again is the

00:02:38,800 --> 00:02:44,160
function that the user calls

00:02:40,640 --> 00:02:46,319
and all it does is forward the tuple

00:02:44,160 --> 00:02:48,400
each each tuple and the function and

00:02:46,319 --> 00:02:49,920
then it does the make index sequence

00:02:48,400 --> 00:02:51,519
and in this case we're assuming that the

00:02:49,920 --> 00:02:52,400
two tuples are the same size but we

00:02:51,519 --> 00:02:54,000
probably have a

00:02:52,400 --> 00:02:56,000
a static assert in there probably that

00:02:54,000 --> 00:02:58,080
the tuple size of each tuple was

00:02:56,000 --> 00:02:59,599
the same which i've left out of this

00:02:58,080 --> 00:03:00,959
slide code

00:02:59,599 --> 00:03:03,120
uh but again you can see it's the same

00:03:00,959 --> 00:03:05,760
pattern as apply we're just

00:03:03,120 --> 00:03:06,959
we're destructuring the type just to

00:03:05,760 --> 00:03:09,200
just to call

00:03:06,959 --> 00:03:10,720
this ancillary function the the impul

00:03:09,200 --> 00:03:11,760
function or the function inside a detail

00:03:10,720 --> 00:03:13,280
namespace or whatever

00:03:11,760 --> 00:03:16,720
and that's what actually does the work

00:03:13,280 --> 00:03:16,720
so we can do the same thing here

00:03:17,200 --> 00:03:24,319
um make it a uh immediately invoked

00:03:21,200 --> 00:03:25,200
lambda with the new template head uh in

00:03:24,319 --> 00:03:28,879
this case

00:03:25,200 --> 00:03:30,319
we are using non-type template arc pack

00:03:28,879 --> 00:03:32,000
of size ts because that's what we get in

00:03:30,319 --> 00:03:34,400
the index sequence

00:03:32,000 --> 00:03:35,280
and so we're just rather than having two

00:03:34,400 --> 00:03:37,599
functions

00:03:35,280 --> 00:03:38,480
one of which just exists to destructure

00:03:37,599 --> 00:03:40,799
the type

00:03:38,480 --> 00:03:42,879
we can just stick the lambda in and get

00:03:40,799 --> 00:03:46,560
the familiar template syntax

00:03:42,879 --> 00:03:48,879
immediately invoked lambda expression

00:03:46,560 --> 00:03:50,879
and again the reference capture kind of

00:03:48,879 --> 00:03:54,000
means that we can

00:03:50,879 --> 00:03:55,680
uh it takes care of the the the

00:03:54,000 --> 00:03:57,360
forwarding for us we just forward inside

00:03:55,680 --> 00:03:58,640
the the lambda exactly the same as we

00:03:57,360 --> 00:04:01,680
would otherwise forward

00:03:58,640 --> 00:04:03,599
and the reference capture takes care of

00:04:01,680 --> 00:04:06,239
the value category preservation with

00:04:03,599 --> 00:04:06,239
that forwarding

00:04:06,879 --> 00:04:10,959
so that's it that's a highlight on

00:04:09,200 --> 00:04:11,360
familiar template syntax lambdas in c

00:04:10,959 --> 00:04:14,319
plus

00:04:11,360 --> 00:04:15,200
20. if you find yourself delegating to a

00:04:14,319 --> 00:04:16,560
function

00:04:15,200 --> 00:04:18,000
just for the purpose of destructuring a

00:04:16,560 --> 00:04:19,199
type like this particularly it happens

00:04:18,000 --> 00:04:22,000
with tuples i find

00:04:19,199 --> 00:04:24,160
although also with um things like uh

00:04:22,000 --> 00:04:27,759
boost mp list boost mp11

00:04:24,160 --> 00:04:28,240
mp list type lists um then consider this

00:04:27,759 --> 00:04:30,160
pattern

00:04:28,240 --> 00:04:31,360
consider just sticking in the

00:04:30,160 --> 00:04:32,000
immediately invoked lambda with the

00:04:31,360 --> 00:04:34,479
familiar

00:04:32,000 --> 00:04:35,840
template syntax uh it's a lot less

00:04:34,479 --> 00:04:37,360
visual noise

00:04:35,840 --> 00:04:39,360
uh it's simpler argument handling the

00:04:37,360 --> 00:04:40,960
reference capture kind of gives you

00:04:39,360 --> 00:04:42,720
takes away all that forwarding that you

00:04:40,960 --> 00:04:44,000
have to do and leaves it just the one

00:04:42,720 --> 00:04:46,080
place

00:04:44,000 --> 00:04:48,639
and like i say it's especially useful

00:04:46,080 --> 00:04:51,759
for tuples

00:04:48,639 --> 00:04:57,840
so i hope you don't hate the acronym but

00:04:51,759 --> 00:04:57,840
there you go thank you

00:05:13,199 --> 00:05:15,280

YouTube URL: https://www.youtube.com/watch?v=uOc6RPu9-CA


