Title: What's My Object? - Staffan TjernstrÃ¶m - CppCon 2020
Publication date: 2020-10-15
Playlist: CppCon 2020 Lightning Talks
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Looking outside-in from a user perspective at the ongoing saga of making objects appear in C++ from out-of-process (file mappings, message queues, device drivers, etc).

---
Staffan has been busting latency issues since the mid-80's. These days he's a C++ subject expert at Susquehanna International Group, where he spends his days working in an MSVC environment using Powershell and emacs.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,800 --> 00:00:12,719
okay

00:00:09,760 --> 00:00:14,400
i'm stefan schaunstrom from susquehanna

00:00:12,719 --> 00:00:16,480
and i'm going to talk about

00:00:14,400 --> 00:00:20,160
what's my object and the noises in the

00:00:16,480 --> 00:00:23,199
background are courtesy of my kitten

00:00:20,160 --> 00:00:24,960
so first i need to there we go have some

00:00:23,199 --> 00:00:28,560
dysfunctions out of the way

00:00:24,960 --> 00:00:30,960
and systems in computing these days

00:00:28,560 --> 00:00:32,239
generally are lots of communicating

00:00:30,960 --> 00:00:35,040
tasks

00:00:32,239 --> 00:00:35,600
if we get it right they all talk to each

00:00:35,040 --> 00:00:37,680
other

00:00:35,600 --> 00:00:39,520
but talking to each other means that we

00:00:37,680 --> 00:00:41,440
have messages

00:00:39,520 --> 00:00:42,640
and in the real system that can be

00:00:41,440 --> 00:00:46,000
hundreds if not

00:00:42,640 --> 00:00:49,280
thousands of different message types so

00:00:46,000 --> 00:00:52,960
how do we represent those messages well

00:00:49,280 --> 00:00:54,559
cnc plus 17 we've had a vocabulary type

00:00:52,960 --> 00:00:57,039
stood variant

00:00:54,559 --> 00:00:59,840
and the problem the stood variant is

00:00:57,039 --> 00:01:02,559
that we don't have a control

00:00:59,840 --> 00:01:04,080
as a user over the serialization layout

00:01:02,559 --> 00:01:07,280
on the wire for it

00:01:04,080 --> 00:01:08,640
so if we send a message from an arm box

00:01:07,280 --> 00:01:12,560
running linux

00:01:08,640 --> 00:01:15,520
to a windows box on ia32

00:01:12,560 --> 00:01:16,240
we're probably not going to be happy

00:01:15,520 --> 00:01:18,560
also

00:01:16,240 --> 00:01:19,360
there's an awful lot of boilerplate code

00:01:18,560 --> 00:01:22,080
involved

00:01:19,360 --> 00:01:23,759
in stood variant and that means that we

00:01:22,080 --> 00:01:27,439
have to auto generate

00:01:23,759 --> 00:01:29,439
huge files and whilst auto generation is

00:01:27,439 --> 00:01:31,360
a really really good thing

00:01:29,439 --> 00:01:32,960
when your file reaches over a million

00:01:31,360 --> 00:01:35,360
lines of code

00:01:32,960 --> 00:01:36,400
just the compile time alone is

00:01:35,360 --> 00:01:39,520
staggering

00:01:36,400 --> 00:01:40,799
and as we know stood this visit is just

00:01:39,520 --> 00:01:42,320
everything that's wrong with modern c

00:01:40,799 --> 00:01:44,960
plus plus

00:01:42,320 --> 00:01:47,119
so we could try doing the c way with the

00:01:44,960 --> 00:01:49,759
good old discriminated union

00:01:47,119 --> 00:01:50,159
and what we still have to generate all

00:01:49,759 --> 00:01:52,000
those

00:01:50,159 --> 00:01:53,520
millions of lines of header files

00:01:52,000 --> 00:01:56,159
because now we have to wrap everything

00:01:53,520 --> 00:01:57,759
in classes and so forth

00:01:56,159 --> 00:01:59,520
but the big problem with the

00:01:57,759 --> 00:02:02,079
discriminated union

00:01:59,520 --> 00:02:03,920
is that the size depends on the message

00:02:02,079 --> 00:02:07,840
maximum message size

00:02:03,920 --> 00:02:08,640
of a message not the actual message size

00:02:07,840 --> 00:02:12,319
now

00:02:08,640 --> 00:02:14,720
normally most messages are fairly short

00:02:12,319 --> 00:02:16,560
10 to 20 bytes maybe but there's

00:02:14,720 --> 00:02:19,440
guaranteed to be one that's going to be

00:02:16,560 --> 00:02:21,840
humongously big that occurs once a day

00:02:19,440 --> 00:02:23,680
and it could be a megabyte or two so

00:02:21,840 --> 00:02:25,760
that doesn't work

00:02:23,680 --> 00:02:27,040
and espiona showed in his keynote

00:02:25,760 --> 00:02:29,040
there's active research

00:02:27,040 --> 00:02:31,680
going on as to how to generate

00:02:29,040 --> 00:02:34,160
individual messages in the same manner

00:02:31,680 --> 00:02:35,440
and one way that's fairly common is just

00:02:34,160 --> 00:02:38,239
to examine bytes

00:02:35,440 --> 00:02:39,360
one at a time but the problem is that

00:02:38,239 --> 00:02:42,319
that's fraud

00:02:39,360 --> 00:02:44,160
it leads to a whole mess of aliasing

00:02:42,319 --> 00:02:46,720
violations that are just

00:02:44,160 --> 00:02:48,560
undefined behavior and we'd rather not

00:02:46,720 --> 00:02:51,680
go there

00:02:48,560 --> 00:02:52,959
but there was a paper p593 that really

00:02:51,680 --> 00:02:56,640
helps in this

00:02:52,959 --> 00:02:59,200
um basically what it enables is that

00:02:56,640 --> 00:03:00,159
it says that for a set of magical

00:02:59,200 --> 00:03:04,879
functions

00:03:00,159 --> 00:03:08,879
such as memset if you reinterpret cast

00:03:04,879 --> 00:03:10,319
into that buffer it's as if the object

00:03:08,879 --> 00:03:13,680
that you're reinterpreting

00:03:10,319 --> 00:03:16,480
to already exists in that spot

00:03:13,680 --> 00:03:18,480
which means that we can pull out our

00:03:16,480 --> 00:03:21,040
message header straight out of

00:03:18,480 --> 00:03:21,680
a plain bite buffer and we're perfectly

00:03:21,040 --> 00:03:24,720
okay

00:03:21,680 --> 00:03:25,840
we can inspect into the object it's

00:03:24,720 --> 00:03:29,200
defined behavior

00:03:25,840 --> 00:03:30,159
everything works the problem is as soon

00:03:29,200 --> 00:03:32,720
as we try to

00:03:30,159 --> 00:03:36,000
make sense from that header type and go

00:03:32,720 --> 00:03:38,400
to a different type for the message

00:03:36,000 --> 00:03:39,200
all bets are off we're back in pointer

00:03:38,400 --> 00:03:42,480
aliasing

00:03:39,200 --> 00:03:45,599
and we're now an undefined behavior land

00:03:42,480 --> 00:03:46,000
so yes we could reinterpret casts the

00:03:45,599 --> 00:03:48,319
from

00:03:46,000 --> 00:03:49,440
the side known size of the header into

00:03:48,319 --> 00:03:51,680
the rest of the buffer

00:03:49,440 --> 00:03:52,480
but now we have to know how far into the

00:03:51,680 --> 00:03:55,599
buffer to go

00:03:52,480 --> 00:03:56,480
and it it's fraught so reinterpret cast

00:03:55,599 --> 00:03:59,599
on its own

00:03:56,480 --> 00:04:01,120
aliasing undefined behavior my kitten

00:03:59,599 --> 00:04:05,120
has now had puppies

00:04:01,120 --> 00:04:07,920
and were off the wrist stood bitcast

00:04:05,120 --> 00:04:08,879
but that's really no use because it

00:04:07,920 --> 00:04:11,920
requires

00:04:08,879 --> 00:04:13,040
that the from and two types are equally

00:04:11,920 --> 00:04:15,840
sized

00:04:13,040 --> 00:04:16,880
and that's not the case with generic

00:04:15,840 --> 00:04:19,519
messages so

00:04:16,880 --> 00:04:20,959
can't use that well there is a missing

00:04:19,519 --> 00:04:23,680
piece

00:04:20,959 --> 00:04:24,960
593 had two sections there was the

00:04:23,680 --> 00:04:27,919
language piece

00:04:24,960 --> 00:04:30,000
which got accepted into c plus plus 20.

00:04:27,919 --> 00:04:33,680
and there is a library piece

00:04:30,000 --> 00:04:34,479
which has a medical function that's now

00:04:33,680 --> 00:04:37,520
called

00:04:34,479 --> 00:04:39,120
start lifetime ass was originally known

00:04:37,520 --> 00:04:41,280
as bless

00:04:39,120 --> 00:04:42,400
and but it didn't quite make it into c

00:04:41,280 --> 00:04:44,479
plus 20

00:04:42,400 --> 00:04:46,800
and i wasn't in the room so i don't know

00:04:44,479 --> 00:04:50,000
why but i'm guessing just time

00:04:46,800 --> 00:04:53,360
um the issue here is that it's

00:04:50,000 --> 00:04:55,840
the curse in a two bit determined paper

00:04:53,360 --> 00:04:56,960
for the wording so until that paper

00:04:55,840 --> 00:05:00,000
exists

00:04:56,960 --> 00:05:00,560
we're left stranded uh but we're almost

00:05:00,000 --> 00:05:03,120
there

00:05:00,560 --> 00:05:04,320
as long as the types involve the

00:05:03,120 --> 00:05:07,360
trivially copyable

00:05:04,320 --> 00:05:07,759
and has implicit lifetime start lifetime

00:05:07,360 --> 00:05:10,880
ass

00:05:07,759 --> 00:05:12,639
will work for us and with a little bit

00:05:10,880 --> 00:05:15,600
of extra work it'll even do

00:05:12,639 --> 00:05:17,120
magical things with map like containers

00:05:15,600 --> 00:05:25,840
and other special cases

00:05:17,120 --> 00:05:25,840
for details cp593 thank you

00:05:40,080 --> 00:05:42,160

YouTube URL: https://www.youtube.com/watch?v=FK74MRgU2yU


