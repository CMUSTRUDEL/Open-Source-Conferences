Title: Build all the things with Spack: a package manager for more than C++ - Todd Gamblin - CppCon 2020
Publication date: 2020-10-15
Playlist: CppCon 2020 Lightning Talks
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
You've heard of vcpkg and Conan, but have you heard of Spack? Spack is a package manager rapidly gaining popularity in High Performance Computing (HPC) that aims to address the complexities of multi-language, cross-platform dependency management. Spack isnâ€™t just for supercomputers, though, you can use it for any C++ project.

Unlike vcpkg and Conan, Spack is designed to build combinatorial versions of software. You can write one parameterized package file and generate tens or hundreds of builds. No need to rewrite your package every time a new version comes out. You can:

- Build the same package with many versions of boost to test compatibility.
- Build a whole graph of packages with different compiler flags
- Build with different combinations of compilers, MPI, BLAS, LAPACK, etc. to run on a supercomputer

Finally, Spack isn't just for C/C++. C++ doesn't exist in isolation, and developers routinely interact with Fortran, Python, R, Go, Perl, and many other package ecosystems. Why limit yourself?

With 4,300 packages and over 600 contributors, Spack's worth a look. This talk will introduce Spack and (quickly) go over the build model and some of the features above.

---
Todd Gamblin is a computer scientist in the Center for Applied Scientific Computing at Lawrence Livermore National Laboratory. His research focuses on scalable tools for measuring, analyzing, and visualizing parallel performance data. In addition to his research, Todd leads LLNL's DevRAMP (Reproducibility, Analysis, Monitoring, and Performance) team. He is the creator of Spack, a popular HPC package management tool, and he leads the Software Packaging Technologies area in the U.S. Exascale Computing Project. Todd has been at LLNL since 2008.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,559 --> 00:00:10,160
okay

00:00:09,040 --> 00:00:12,080
so i'm going to try to go through this

00:00:10,160 --> 00:00:13,519
fast uh because it's a lightning talk uh

00:00:12,080 --> 00:00:14,320
this is about building all the things

00:00:13,519 --> 00:00:15,839
with spec and

00:00:14,320 --> 00:00:17,600
we may find a solution to the previous

00:00:15,839 --> 00:00:19,600
talks problem um

00:00:17,600 --> 00:00:21,520
stack is used on a lot of hpc machines

00:00:19,600 --> 00:00:24,720
so this is fugaku it's a big arm

00:00:21,520 --> 00:00:25,359
64 fx machine in japan it's number one

00:00:24,720 --> 00:00:27,359
right now

00:00:25,359 --> 00:00:28,800
and uh you know we're used on a whole

00:00:27,359 --> 00:00:30,320
lot of super computers

00:00:28,800 --> 00:00:33,120
including some smaller sites around the

00:00:30,320 --> 00:00:34,800
world we have a pretty booming community

00:00:33,120 --> 00:00:36,719
uh we have a lot of contributions from

00:00:34,800 --> 00:00:39,200
different organizations um and

00:00:36,719 --> 00:00:40,559
almost 5 000 packages now so that that's

00:00:39,200 --> 00:00:43,680
pretty cool

00:00:40,559 --> 00:00:45,200
um the problem is that we're not as

00:00:43,680 --> 00:00:47,039
you know none of those things are quite

00:00:45,200 --> 00:00:48,960
as big as the c plus plus community so

00:00:47,039 --> 00:00:50,239
if you look at package managers in the c

00:00:48,960 --> 00:00:52,960
plus plus world

00:00:50,239 --> 00:00:54,800
we're here here's vc package here's

00:00:52,960 --> 00:00:55,520
conan here's nick's and here's build two

00:00:54,800 --> 00:00:58,559
so i guess we've

00:00:55,520 --> 00:01:01,280
built two but uh you know

00:00:58,559 --> 00:01:02,480
we'd like to be better known so uh we

00:01:01,280 --> 00:01:04,879
wanted to tell everyone

00:01:02,480 --> 00:01:06,080
uh that's back is here and uh that's

00:01:04,879 --> 00:01:08,159
what this talk is about

00:01:06,080 --> 00:01:10,159
so if you want to install spac um it's

00:01:08,159 --> 00:01:11,600
it's a flexible package manager you can

00:01:10,159 --> 00:01:13,920
you can just download it from github and

00:01:11,600 --> 00:01:15,520
go all you need is uh python

00:01:13,920 --> 00:01:17,439
and if you want to install something you

00:01:15,520 --> 00:01:19,520
could back install hdf5

00:01:17,439 --> 00:01:20,880
um i didn't know that the previous talk

00:01:19,520 --> 00:01:23,119
would be about hdf5 but

00:01:20,880 --> 00:01:24,080
it's somewhat convenient and that will

00:01:23,119 --> 00:01:25,600
go and install

00:01:24,080 --> 00:01:27,680
and build hdf5 and all of its

00:01:25,600 --> 00:01:28,960
dependencies that's not just a c

00:01:27,680 --> 00:01:30,880
plus package manager you can build

00:01:28,960 --> 00:01:32,560
anything you want with spec um you could

00:01:30,880 --> 00:01:34,960
build fortran you could build

00:01:32,560 --> 00:01:36,560
uh c you could build python we have lots

00:01:34,960 --> 00:01:39,360
of python and r packages

00:01:36,560 --> 00:01:40,000
um it's not language specific um and

00:01:39,360 --> 00:01:41,759
what's different

00:01:40,000 --> 00:01:44,159
about spag from other package managers

00:01:41,759 --> 00:01:45,600
is it it's very customizable you can

00:01:44,159 --> 00:01:47,920
customize and install on the command

00:01:45,600 --> 00:01:50,079
line so if you want to build hdf5

00:01:47,920 --> 00:01:51,439
and just get an hdf5 version which may

00:01:50,079 --> 00:01:52,079
be dangerous as you heard in the prior

00:01:51,439 --> 00:01:54,799
talk

00:01:52,079 --> 00:01:56,320
um you can just say spack install hdf5

00:01:54,799 --> 00:01:57,840
if you have specific needs for a

00:01:56,320 --> 00:01:59,280
particular version you can do that you

00:01:57,840 --> 00:01:59,520
can say i want a particular version of

00:01:59,280 --> 00:02:01,600
it

00:01:59,520 --> 00:02:04,159
uh you can say i want to build with gcc

00:02:01,600 --> 00:02:06,799
so you can say hey give me gcc 830 or

00:02:04,159 --> 00:02:08,479
gcc nine as you heard previously

00:02:06,799 --> 00:02:10,000
you can say what build options you want

00:02:08,479 --> 00:02:10,879
so you can customize that on the command

00:02:10,000 --> 00:02:12,800
line too

00:02:10,879 --> 00:02:14,720
um you can inject flags in the build if

00:02:12,800 --> 00:02:16,400
you want to and we know about specific

00:02:14,720 --> 00:02:16,959
target micro architectures so you can

00:02:16,400 --> 00:02:18,800
say

00:02:16,959 --> 00:02:20,080
i want to build for skylake or i want to

00:02:18,800 --> 00:02:21,280
build for cascade lake you can just

00:02:20,080 --> 00:02:22,640
write that on the command line and we

00:02:21,280 --> 00:02:23,840
have human understandable names for

00:02:22,640 --> 00:02:25,599
those things

00:02:23,840 --> 00:02:26,879
and all of that is customizable down to

00:02:25,599 --> 00:02:29,680
the dependencies too

00:02:26,879 --> 00:02:31,280
so um you you can tweak this lots and

00:02:29,680 --> 00:02:33,519
lots of different ways

00:02:31,280 --> 00:02:34,879
um the packages the way that we do this

00:02:33,519 --> 00:02:36,400
they're parameterized with the simple

00:02:34,879 --> 00:02:38,080
python dsl

00:02:36,400 --> 00:02:39,840
you may have heard this before through

00:02:38,080 --> 00:02:41,120
conan or some of the more popular c plus

00:02:39,840 --> 00:02:43,920
plus package managers

00:02:41,120 --> 00:02:45,599
but basically every package is a class

00:02:43,920 --> 00:02:47,200
it has a home page in the url this just

00:02:45,599 --> 00:02:48,480
looks familiar it looks kind of like a

00:02:47,200 --> 00:02:49,920
homebrew package

00:02:48,480 --> 00:02:51,680
but you can have multiple versions you

00:02:49,920 --> 00:02:52,959
can have build options uh you can have

00:02:51,680 --> 00:02:55,040
conditional dependencies

00:02:52,959 --> 00:02:56,720
and version ranges and things like that

00:02:55,040 --> 00:02:57,120
and then the install logic all goes down

00:02:56,720 --> 00:02:58,720
here

00:02:57,120 --> 00:03:00,480
and it's it's templated by these

00:02:58,720 --> 00:03:01,360
parameters so essentially this stuff up

00:03:00,480 --> 00:03:03,040
here tells you

00:03:01,360 --> 00:03:04,560
the space of things you could install

00:03:03,040 --> 00:03:05,760
and this stuff down here is how to

00:03:04,560 --> 00:03:08,879
install it

00:03:05,760 --> 00:03:10,400
um it's simple but expressive so if you

00:03:08,879 --> 00:03:12,319
look at spat packages they tend to be

00:03:10,400 --> 00:03:12,720
quite a bit shorter than say conan so i

00:03:12,319 --> 00:03:14,400
did a

00:03:12,720 --> 00:03:16,480
quick comparison of some common ones so

00:03:14,400 --> 00:03:18,480
zlib is like 55 lines of code it's back

00:03:16,480 --> 00:03:19,360
and much longer in conan and boost a

00:03:18,480 --> 00:03:21,440
complicated one

00:03:19,360 --> 00:03:22,879
is about half as long as back as conan

00:03:21,440 --> 00:03:24,400
and this includes you know all the

00:03:22,879 --> 00:03:25,599
versions and things that go in separate

00:03:24,400 --> 00:03:27,440
files in some of the other package

00:03:25,599 --> 00:03:29,519
managers

00:03:27,440 --> 00:03:30,799
we handle combinatorial complexity so

00:03:29,519 --> 00:03:33,120
essentially if you have

00:03:30,799 --> 00:03:34,239
a bunch of graphs that look like this

00:03:33,120 --> 00:03:36,560
and you want to install

00:03:34,239 --> 00:03:38,959
60 different versions of them we will do

00:03:36,560 --> 00:03:39,680
that so we'll hash those configurations

00:03:38,959 --> 00:03:40,959
and install

00:03:39,680 --> 00:03:42,400
all of the different versions of all of

00:03:40,959 --> 00:03:43,760
the things in different directories for

00:03:42,400 --> 00:03:46,080
you if you want to test

00:03:43,760 --> 00:03:47,120
things like that we use our paths pretty

00:03:46,080 --> 00:03:48,720
heavily to figure out

00:03:47,120 --> 00:03:50,239
where dependencies live so each of these

00:03:48,720 --> 00:03:51,920
directories where we install a package

00:03:50,239 --> 00:03:53,200
knows where its dependencies live so you

00:03:51,920 --> 00:03:55,920
don't have to worry about setting up

00:03:53,200 --> 00:03:57,519
your environment to run something

00:03:55,920 --> 00:03:58,879
we have dependency resolution so

00:03:57,519 --> 00:04:00,080
basically these things that you write on

00:03:58,879 --> 00:04:02,319
the command line are abstract

00:04:00,080 --> 00:04:03,760
specs we have a resolver that takes that

00:04:02,319 --> 00:04:04,879
turns it into a graph with some

00:04:03,760 --> 00:04:06,799
constraints on it

00:04:04,879 --> 00:04:08,159
fills in all the blanks and then stores

00:04:06,799 --> 00:04:09,439
really detailed information about what

00:04:08,159 --> 00:04:11,040
you build on disk

00:04:09,439 --> 00:04:12,480
which you can then query so if you're

00:04:11,040 --> 00:04:14,480
finding that your build explodes with

00:04:12,480 --> 00:04:15,439
one version of a library and you want to

00:04:14,480 --> 00:04:17,120
see why

00:04:15,439 --> 00:04:19,199
you can say oh that one was built with a

00:04:17,120 --> 00:04:21,759
version of boosts that is not compatible

00:04:19,199 --> 00:04:23,280
with my version of boost

00:04:21,759 --> 00:04:24,639
like i said we understand specific

00:04:23,280 --> 00:04:26,240
target micro architectures we actually

00:04:24,639 --> 00:04:27,680
have a separate python library for this

00:04:26,240 --> 00:04:29,440
that'll detect what kind of machine

00:04:27,680 --> 00:04:31,199
you're on and it knows the compatibility

00:04:29,440 --> 00:04:33,199
of things so you can do comparisons like

00:04:31,199 --> 00:04:36,240
is skylight compatible with broadwell

00:04:33,199 --> 00:04:37,600
or is zen compatible with x864 um and

00:04:36,240 --> 00:04:39,440
you can query those things inside your

00:04:37,600 --> 00:04:40,000
packages so it's easy to do things like

00:04:39,440 --> 00:04:41,919
say

00:04:40,000 --> 00:04:43,280
should i add the avx 512 argument to

00:04:41,919 --> 00:04:46,320
this thing should i add these other

00:04:43,280 --> 00:04:48,240
litany of cindy arcs um

00:04:46,320 --> 00:04:50,240
we support environments with uh

00:04:48,240 --> 00:04:51,280
manifests so that's a spec.yaml file

00:04:50,240 --> 00:04:52,960
that you could just version in a

00:04:51,280 --> 00:04:54,320
repository and we'll spit out a lock

00:04:52,960 --> 00:04:55,759
file with exactly what we built

00:04:54,320 --> 00:04:57,440
including all those configuration

00:04:55,759 --> 00:04:58,960
options that you saw earlier

00:04:57,440 --> 00:05:00,639
so it's easy to reproduce something

00:04:58,960 --> 00:05:01,840
functionally with a manifest and then

00:05:00,639 --> 00:05:02,720
resolve it differently on different

00:05:01,840 --> 00:05:04,320
systems or

00:05:02,720 --> 00:05:05,600
reproduce something exactly with a lock

00:05:04,320 --> 00:05:07,120
file where you want to reproduce the

00:05:05,600 --> 00:05:09,600
exact same thing

00:05:07,120 --> 00:05:11,280
in a separate build on the same system

00:05:09,600 --> 00:05:13,759
um the other kind of cool thing we do

00:05:11,280 --> 00:05:14,960
is uh this syntax isn't limited to just

00:05:13,759 --> 00:05:16,320
you know the command line

00:05:14,960 --> 00:05:17,840
you can use it in these environment

00:05:16,320 --> 00:05:19,360
files so if you want your manifest to

00:05:17,840 --> 00:05:20,800
have a build matrix like this where you

00:05:19,360 --> 00:05:22,639
want to build five different packages

00:05:20,800 --> 00:05:24,240
with three different mpi implementations

00:05:22,639 --> 00:05:25,199
or some other dependency like bloss or

00:05:24,240 --> 00:05:26,320
law pack

00:05:25,199 --> 00:05:27,600
three different compilers and two

00:05:26,320 --> 00:05:29,120
different targets you can do that and

00:05:27,600 --> 00:05:30,639
you can generate 90 different builds of

00:05:29,120 --> 00:05:32,000
five packages and that doesn't include

00:05:30,639 --> 00:05:33,280
the dependencies so that's a whole lot

00:05:32,000 --> 00:05:35,120
of builds

00:05:33,280 --> 00:05:36,720
um so that's where the build all the

00:05:35,120 --> 00:05:38,720
things comes from

00:05:36,720 --> 00:05:40,400
you can also take that and generate a ci

00:05:38,720 --> 00:05:41,440
pipeline from it so if you make a

00:05:40,400 --> 00:05:43,440
manifest like this

00:05:41,440 --> 00:05:44,800
with lots of different packages in it

00:05:43,440 --> 00:05:46,000
you can map them to containers build

00:05:44,800 --> 00:05:47,199
them in a cube cluster build them on

00:05:46,000 --> 00:05:48,800
bare metal or whatever

00:05:47,199 --> 00:05:50,960
um we'll generate a bunch of jobs that

00:05:48,800 --> 00:05:51,280
run in parallel in ci to build all of

00:05:50,960 --> 00:05:53,120
that

00:05:51,280 --> 00:05:54,800
and you can either cache build binaries

00:05:53,120 --> 00:05:56,400
or like the previous presenter said you

00:05:54,800 --> 00:05:58,639
can build everything from source all the

00:05:56,400 --> 00:06:00,400
time

00:05:58,639 --> 00:06:01,680
and other stuff that i don't really have

00:06:00,400 --> 00:06:03,280
time to talk about

00:06:01,680 --> 00:06:04,479
windows support is coming in next year

00:06:03,280 --> 00:06:05,919
that's probably the thing that will kill

00:06:04,479 --> 00:06:07,039
us the most in this community so we're

00:06:05,919 --> 00:06:08,960
working on that

00:06:07,039 --> 00:06:10,639
um it's not just for c plus it's for

00:06:08,960 --> 00:06:12,000
anything you can build lots of packages

00:06:10,639 --> 00:06:12,960
in parallel on a cluster even without

00:06:12,000 --> 00:06:14,880
gitlab

00:06:12,960 --> 00:06:16,080
um and we have this virtual dependency

00:06:14,880 --> 00:06:17,759
model that i haven't seen in other

00:06:16,080 --> 00:06:20,160
places except for moviegen 2

00:06:17,759 --> 00:06:22,080
where essentially we don't depend on mpi

00:06:20,160 --> 00:06:23,520
we we depend on the mpi api

00:06:22,080 --> 00:06:24,800
and you can swap independencies for

00:06:23,520 --> 00:06:26,560
these types of things instead of having

00:06:24,800 --> 00:06:29,039
to write a package

00:06:26,560 --> 00:06:30,160
where did that slide go that was crazy

00:06:29,039 --> 00:06:33,280
can you see it

00:06:30,160 --> 00:06:35,840
no no because you're at six minutes

00:06:33,280 --> 00:06:35,840
okay

00:06:53,199 --> 00:06:55,280

YouTube URL: https://www.youtube.com/watch?v=yuhV7iKRIJU


