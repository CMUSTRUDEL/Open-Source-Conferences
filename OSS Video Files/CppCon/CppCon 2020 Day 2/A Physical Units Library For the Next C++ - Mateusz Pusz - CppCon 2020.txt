Title: A Physical Units Library For the Next C++ - Mateusz Pusz - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020 Day 2
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/a_physical_units_library_for_the_next_cpp/a_physical_units_library_for_the_next_cpp__mateusz_pusz__cppcon_2020.pdf
---

During CppCon 2019 Mateusz provided an overview of current solutions on the market as well as challenges of implementing a modern C++ physical units library. This year's talk will focus on 'mp-units', the library that was developed by Mateusz and contributors, and which is proposed for C++ standardization. During the tutorial, we will get familiar with the building blocks of the library's framework and its most important concepts. Numerous code examples will present how to use and solve real-life problems with the library. The audience will learn how easy it is to extend it with new units, dimensions, or even whole new systems of quantities. Last but not least Mateusz will provide a fair comparison of how well this library performs in comparison to other products on the market.

---
A software architect, principal engineer, and security champion with more than 15 years of experience in designing, writing, and maintaining C++ code for fun and living. A trainer with 10 years of C++ teaching experience, consultant, conference speaker, and evangelist. His main areas of interest and expertise are Modern C++, code performance, low latency, safety, and maintainability.

Mateusz worked at Intel for 13 years, and now he is a Principal Software Engineer and the head of the C++ Competency Center at EPAM Systems. He is also a founder of Train IT that provides dedicated C++ trainings and consultant services to corporations around the world.

Mateusz is a contributor and an active voting member of the ISO C++ Committee (WG21) where, together with the best C++ experts in the world, he shapes the future of the C++ language. He is also a co-chair of WG21 Study Group 14 (SG14) responsible for driving performance and low latency subjects in the Committee. Recently also joined MISRA to help make self-driving cars safer.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,480 --> 00:00:12,320
okay

00:00:09,519 --> 00:00:12,719
let's start hello everyone good morning

00:00:12,320 --> 00:00:15,360
good

00:00:12,719 --> 00:00:16,960
afternoon good evening wherever you are

00:00:15,360 --> 00:00:18,640
physically we are connected here on

00:00:16,960 --> 00:00:21,840
cppcon the biggest event

00:00:18,640 --> 00:00:26,080
in the world in terms of c plus plus

00:00:21,840 --> 00:00:28,160
um today i will talk to you about the

00:00:26,080 --> 00:00:31,599
physical units library that we are

00:00:28,160 --> 00:00:33,840
working on for several years um

00:00:31,599 --> 00:00:35,680
i provided already a few talks about it

00:00:33,840 --> 00:00:37,680
but this talk will be more scoped on my

00:00:35,680 --> 00:00:38,879
labor rather than about the challenges

00:00:37,680 --> 00:00:41,760
about things to do

00:00:38,879 --> 00:00:41,760
and so on

00:00:42,800 --> 00:00:47,200
so we'll skip some parts of it we'll not

00:00:45,600 --> 00:00:49,840
talk about motivation today

00:00:47,200 --> 00:00:51,760
we'll not talk too much about existing

00:00:49,840 --> 00:00:53,840
practice and challenges

00:00:51,760 --> 00:00:55,280
because i covered this already on the

00:00:53,840 --> 00:00:57,840
talk a year ago

00:00:55,280 --> 00:01:00,160
so so you can find all the details there

00:00:57,840 --> 00:01:03,359
and today we'll speak more about

00:01:00,160 --> 00:01:04,799
what are the results of our work and how

00:01:03,359 --> 00:01:07,360
the library stands comparing to

00:01:04,799 --> 00:01:07,360
competition

00:01:08,479 --> 00:01:14,720
so here's the agenda for today

00:01:11,520 --> 00:01:17,600
uh we have a short introduction

00:01:14,720 --> 00:01:20,320
to the subject of physical units we'll

00:01:17,600 --> 00:01:22,799
talk about strong interfaces

00:01:20,320 --> 00:01:25,040
how they help in making the library

00:01:22,799 --> 00:01:27,439
better how they improve the

00:01:25,040 --> 00:01:30,400
user experience we'll talk about the

00:01:27,439 --> 00:01:32,799
performance runtime performance here

00:01:30,400 --> 00:01:34,720
we'll talk about user experience in

00:01:32,799 --> 00:01:37,119
general

00:01:34,720 --> 00:01:38,720
and and then i will provide some

00:01:37,119 --> 00:01:41,840
introduction to the framework

00:01:38,720 --> 00:01:42,640
it's not the whole framework

00:01:41,840 --> 00:01:45,119
introduction

00:01:42,640 --> 00:01:46,320
we don't cover all of the details here

00:01:45,119 --> 00:01:47,680
all of the details can be found in our

00:01:46,320 --> 00:01:49,759
documentation that i will

00:01:47,680 --> 00:01:51,040
describe you i provide you in a few

00:01:49,759 --> 00:01:52,960
minutes

00:01:51,040 --> 00:01:54,240
and at the end i will talk a bit about

00:01:52,960 --> 00:01:58,320
environment compatibility

00:01:54,240 --> 00:02:00,000
and next steps i will try to address the

00:01:58,320 --> 00:02:03,119
q and a

00:02:00,000 --> 00:02:04,159
backlog between those chapters so please

00:02:03,119 --> 00:02:05,680
provide questions

00:02:04,159 --> 00:02:07,280
while you provide questions regarding a

00:02:05,680 --> 00:02:08,479
specific slide number please provide a

00:02:07,280 --> 00:02:10,800
slide down number

00:02:08,479 --> 00:02:13,040
so i can easily come back to the

00:02:10,800 --> 00:02:17,200
specific slide and provide some

00:02:13,040 --> 00:02:21,200
answers so without the further ado

00:02:17,200 --> 00:02:22,959
let's start what the physical units is

00:02:21,200 --> 00:02:25,040
about

00:02:22,959 --> 00:02:27,200
with physical units we want to be able

00:02:25,040 --> 00:02:30,720
to provide different operations

00:02:27,200 --> 00:02:32,239
on physical units in some terms it's

00:02:30,720 --> 00:02:33,120
similar to what we have already in

00:02:32,239 --> 00:02:35,840
chrono

00:02:33,120 --> 00:02:36,640
especially chrono duration class so you

00:02:35,840 --> 00:02:39,760
can for example

00:02:36,640 --> 00:02:40,400
divide some some quantity of specific

00:02:39,760 --> 00:02:43,040
dimension

00:02:40,400 --> 00:02:43,680
and with some unit by a value by its

00:02:43,040 --> 00:02:47,519
color

00:02:43,680 --> 00:02:49,840
by some some and not a quantity

00:02:47,519 --> 00:02:52,800
in such a case you will just divide the

00:02:49,840 --> 00:02:54,959
value of the quantity right

00:02:52,800 --> 00:02:56,400
you can also convert between different

00:02:54,959 --> 00:02:58,159
units of the same dimension

00:02:56,400 --> 00:03:00,000
when working with time we can convert

00:02:58,159 --> 00:03:03,599
hours to seconds

00:03:00,000 --> 00:03:05,920
and compare them easily or we can

00:03:03,599 --> 00:03:06,959
add kilometers and meters and get

00:03:05,920 --> 00:03:09,519
results

00:03:06,959 --> 00:03:12,959
in meters so again it's similar to what

00:03:09,519 --> 00:03:12,959
we have already in chrono duration

00:03:13,200 --> 00:03:18,239
however this is new we can

00:03:16,720 --> 00:03:20,720
provide different operations on

00:03:18,239 --> 00:03:23,760
different uh on different quantities

00:03:20,720 --> 00:03:23,760
over different dimensions

00:03:24,159 --> 00:03:27,440
those operations are multiplication and

00:03:25,840 --> 00:03:29,519
division and they

00:03:27,440 --> 00:03:31,519
are used to change or provide a

00:03:29,519 --> 00:03:33,040
different quantity type

00:03:31,519 --> 00:03:35,200
on the as the result of the of the

00:03:33,040 --> 00:03:38,000
operation so for example

00:03:35,200 --> 00:03:38,480
if we divide the length by time we'll

00:03:38,000 --> 00:03:41,200
end up

00:03:38,480 --> 00:03:43,360
with the velocity here with speed in

00:03:41,200 --> 00:03:46,799
meters per second

00:03:43,360 --> 00:03:49,280
we can compare the speed obtained here

00:03:46,799 --> 00:03:50,239
in kilometers per second with meters per

00:03:49,280 --> 00:03:52,640
second

00:03:50,239 --> 00:03:54,080
all the conversions work as in the

00:03:52,640 --> 00:03:56,480
previous case

00:03:54,080 --> 00:03:57,519
we can multiply the speed by by time and

00:03:56,480 --> 00:04:01,200
get length

00:03:57,519 --> 00:04:03,519
we can divide length by speed and get

00:04:01,200 --> 00:04:05,920
time

00:04:03,519 --> 00:04:06,720
and of course we can also multiply the

00:04:05,920 --> 00:04:09,200
same

00:04:06,720 --> 00:04:10,879
dimension like length by length and get

00:04:09,200 --> 00:04:14,080
an area

00:04:10,879 --> 00:04:17,519
squared meters

00:04:14,080 --> 00:04:19,120
and the next one and is dividing

00:04:17,519 --> 00:04:20,799
length byte length so we can also divide

00:04:19,120 --> 00:04:23,680
the same dimension

00:04:20,799 --> 00:04:24,800
and get a dimensionless quantity with

00:04:23,680 --> 00:04:28,000
value 2

00:04:24,800 --> 00:04:31,280
in this case

00:04:28,000 --> 00:04:34,800
um at last we can divide

00:04:31,280 --> 00:04:36,880
the value by a quantity

00:04:34,800 --> 00:04:38,080
and get an inverse quantity of this of

00:04:36,880 --> 00:04:41,680
this type so

00:04:38,080 --> 00:04:44,320
when we divide time we get we can when

00:04:41,680 --> 00:04:45,840
we divide by time we get frequency right

00:04:44,320 --> 00:04:47,840
so this is something different something

00:04:45,840 --> 00:04:48,880
that was not in chrono duration

00:04:47,840 --> 00:04:50,960
quantitation was

00:04:48,880 --> 00:04:53,759
allowed us to divide the quantity by

00:04:50,960 --> 00:04:58,160
value but not the value by a quantity

00:04:53,759 --> 00:04:58,160
so this is also something new here

00:05:00,639 --> 00:05:04,320
just to answer the possible question

00:05:02,960 --> 00:05:07,600
from the previous slides

00:05:04,320 --> 00:05:11,759
we are using this prefix from for the

00:05:07,600 --> 00:05:11,759
user device literals underscore q

00:05:12,080 --> 00:05:15,440
and basically we plan to replace it with

00:05:15,120 --> 00:05:18,639
q

00:05:15,440 --> 00:05:20,160
underscore when we move to the if

00:05:18,639 --> 00:05:22,160
actually if we will be merged with

00:05:20,160 --> 00:05:24,960
standard february because it's not

00:05:22,160 --> 00:05:25,759
for sure we'll try to do it but it

00:05:24,960 --> 00:05:26,960
depends from the

00:05:25,759 --> 00:05:28,800
from the interest it depends from the

00:05:26,960 --> 00:05:31,199
amount of work needed to do it we'll

00:05:28,800 --> 00:05:33,120
find out if if it will happen or not

00:05:31,199 --> 00:05:34,479
but we are trying to be prepared for it

00:05:33,120 --> 00:05:38,000
and that's why i provided this q

00:05:34,479 --> 00:05:41,360
underscore prefix because um this prefix

00:05:38,000 --> 00:05:43,680
is a workaround to basically not collide

00:05:41,360 --> 00:05:45,039
with bit in literals

00:05:43,680 --> 00:05:46,880
for example if you would like just to

00:05:45,039 --> 00:05:52,160
type something like 2 f

00:05:46,880 --> 00:05:54,479
or 2 j or 2 w all of them already taken

00:05:52,160 --> 00:05:55,600
by the built-in literals for some

00:05:54,479 --> 00:05:58,639
floating point numbers

00:05:55,600 --> 00:06:01,440
and others and with this we have big

00:05:58,639 --> 00:06:04,080
problem for some units to express their

00:06:01,440 --> 00:06:07,039
their units in literals that's why we

00:06:04,080 --> 00:06:08,400
decided to go with q underscore and then

00:06:07,039 --> 00:06:10,080
unit like you've seen on the previous

00:06:08,400 --> 00:06:13,120
slide

00:06:10,080 --> 00:06:16,160
also we have some literals like

00:06:13,120 --> 00:06:18,319
s h or m right

00:06:16,160 --> 00:06:21,840
in chronoliters already and you don't

00:06:18,319 --> 00:06:21,840
want to collide with them too

00:06:23,759 --> 00:06:27,919
we are also working on alternative way

00:06:25,759 --> 00:06:28,560
to create quantities not only with udls

00:06:27,919 --> 00:06:30,000
but

00:06:28,560 --> 00:06:32,720
you can read more details about it on

00:06:30,000 --> 00:06:34,400
the issue 48 on our on our github

00:06:32,720 --> 00:06:36,720
but it is too early to talk about it

00:06:34,400 --> 00:06:36,720
right now

00:06:38,639 --> 00:06:42,639
talking about documentation we added a

00:06:41,199 --> 00:06:45,680
new documentation in last

00:06:42,639 --> 00:06:47,120
month it's based on sphinx

00:06:45,680 --> 00:06:48,479
it's challenging actually to provide the

00:06:47,120 --> 00:06:50,080
documentation for a project written in

00:06:48,479 --> 00:06:53,440
ec plus plus 20.

00:06:50,080 --> 00:06:55,759
uh start there is a tool chain

00:06:53,440 --> 00:06:57,120
of of tools we have to use we are using

00:06:55,759 --> 00:06:58,639
docs again we are using sphinx we are

00:06:57,120 --> 00:07:00,160
using brief to generate those

00:06:58,639 --> 00:07:02,800
and each of them has some problems with

00:07:00,160 --> 00:07:04,479
some specific plus 20 syntax

00:07:02,800 --> 00:07:06,319
so it was challenging but i think

00:07:04,479 --> 00:07:09,599
documentation is really nice

00:07:06,319 --> 00:07:09,919
and i really recommend you to go to it

00:07:09,599 --> 00:07:11,520
and

00:07:09,919 --> 00:07:13,919
and read if you are interested in the

00:07:11,520 --> 00:07:13,919
subject

00:07:14,880 --> 00:07:18,160
and actually you can find all of the

00:07:16,479 --> 00:07:20,479
details there will not cover everything

00:07:18,160 --> 00:07:20,479
today

00:07:21,680 --> 00:07:26,560
you can also test the library right away

00:07:24,160 --> 00:07:29,360
on the compiler explorer

00:07:26,560 --> 00:07:31,120
to do this you need to provide c plus 20

00:07:29,360 --> 00:07:31,680
as the parameter for the compiler will

00:07:31,120 --> 00:07:36,000
use some

00:07:31,680 --> 00:07:40,160
recent gcc and switch on the np unit

00:07:36,000 --> 00:07:43,440
library i released 060 version a few

00:07:40,160 --> 00:07:46,240
days ago so it's cppcon 2020 release

00:07:43,440 --> 00:07:47,680
and all of the examples here will work

00:07:46,240 --> 00:07:49,440
with this

00:07:47,680 --> 00:07:50,960
with this release even if you move

00:07:49,440 --> 00:07:53,440
further and break something

00:07:50,960 --> 00:07:55,440
break interfaces in the future so you

00:07:53,440 --> 00:07:59,599
can always refer to this students tag

00:07:55,440 --> 00:08:01,199
060 in order to be able to replay the

00:07:59,599 --> 00:08:03,599
code samples that we provided during

00:08:01,199 --> 00:08:03,599
this talk

00:08:07,120 --> 00:08:11,440
npuse is also available in conan you can

00:08:09,599 --> 00:08:12,960
find it in conon center

00:08:11,440 --> 00:08:15,199
i would like to thank you my friends

00:08:12,960 --> 00:08:17,360
from conan that i provided this kona

00:08:15,199 --> 00:08:20,639
center support yesterday in a few hours

00:08:17,360 --> 00:08:22,560
thank you very much guys so

00:08:20,639 --> 00:08:24,879
you can get it from from common center

00:08:22,560 --> 00:08:26,720
you can just type mpuni060

00:08:24,879 --> 00:08:28,400
and you get the latest release it's a

00:08:26,720 --> 00:08:30,960
header on library so it

00:08:28,400 --> 00:08:31,680
it's really easy to use remember to use

00:08:30,960 --> 00:08:35,440
in conan

00:08:31,680 --> 00:08:37,039
the compiler cpp std flag equals 20

00:08:35,440 --> 00:08:38,159
otherwise the library will not compile

00:08:37,039 --> 00:08:39,360
you have to specify that you're

00:08:38,159 --> 00:08:42,080
compiling with c plus

00:08:39,360 --> 00:08:42,080
20 enabled

00:08:43,360 --> 00:08:47,600
if you don't want to live with the

00:08:46,000 --> 00:08:48,800
latest release and wait for the next

00:08:47,600 --> 00:08:50,240
release for longer time and you would

00:08:48,800 --> 00:08:53,279
like to leave it ahead

00:08:50,240 --> 00:08:54,000
you are welcome to use a bin tray when

00:08:53,279 --> 00:08:56,560
we are hosting

00:08:54,000 --> 00:08:57,839
the latest versions of the of the of the

00:08:56,560 --> 00:09:00,399
stable packages

00:08:57,839 --> 00:09:02,959
that are created with every aca build

00:09:00,399 --> 00:09:04,880
every sea build that's successful

00:09:02,959 --> 00:09:07,120
and for this you will have to provide

00:09:04,880 --> 00:09:08,080
the different ide in conan and add the

00:09:07,120 --> 00:09:10,480
remote

00:09:08,080 --> 00:09:12,160
of our bin tray to your conon

00:09:10,480 --> 00:09:13,680
configuration

00:09:12,160 --> 00:09:15,600
also if you would like to stay at head

00:09:13,680 --> 00:09:19,519
it's good to use minus b

00:09:15,600 --> 00:09:21,360
outdated and minus you to update recipes

00:09:19,519 --> 00:09:24,080
every time they are updated by us

00:09:21,360 --> 00:09:24,080
in the bin tray

00:09:29,040 --> 00:09:32,959
requirements for the physicalist library

00:09:30,959 --> 00:09:36,320
that we provided

00:09:32,959 --> 00:09:39,680
and that we stated for ourselves are

00:09:36,320 --> 00:09:40,880
as follows first of all it is more

00:09:39,680 --> 00:09:42,720
important the most important

00:09:40,880 --> 00:09:44,480
part is to provide company time safety

00:09:42,720 --> 00:09:45,680
right the library should not compile if

00:09:44,480 --> 00:09:48,320
there is something wrong with our

00:09:45,680 --> 00:09:48,320
calculations

00:09:48,959 --> 00:09:52,240
second of all we should provide the best

00:09:50,800 --> 00:09:54,399
user experience

00:09:52,240 --> 00:09:56,320
so if something doesn't compile because

00:09:54,399 --> 00:09:58,640
you provided some some bad

00:09:56,320 --> 00:10:00,160
calculations the compiler errors should

00:09:58,640 --> 00:10:00,800
be easy to understand for everyone

00:10:00,160 --> 00:10:02,399
because the

00:10:00,800 --> 00:10:04,640
whole purpose of existing of this

00:10:02,399 --> 00:10:05,680
library is to generate errors every day

00:10:04,640 --> 00:10:08,800
for you

00:10:05,680 --> 00:10:12,320
to find problems in your code and also

00:10:08,800 --> 00:10:12,320
should be easy to debug this code right

00:10:12,880 --> 00:10:16,880
it should be fast those obstructions

00:10:15,600 --> 00:10:18,880
should not introduce any runtime

00:10:16,880 --> 00:10:21,680
overhead should be as fast as double

00:10:18,880 --> 00:10:21,680
or maybe faster

00:10:22,000 --> 00:10:25,920
it should be easy to extend because will

00:10:24,480 --> 00:10:27,440
not provide all of the units or the

00:10:25,920 --> 00:10:27,920
systems that you probably need so you

00:10:27,440 --> 00:10:30,959
can

00:10:27,920 --> 00:10:32,720
easily extend everything you can add

00:10:30,959 --> 00:10:35,760
units you can add dimensions you can add

00:10:32,720 --> 00:10:35,760
all the systems if you like

00:10:36,880 --> 00:10:40,000
there should be no macros in the user

00:10:38,399 --> 00:10:42,079
interface right because

00:10:40,000 --> 00:10:44,000
this is not a modern class plus we are

00:10:42,079 --> 00:10:45,839
not

00:10:44,000 --> 00:10:47,920
allowed to put macros as the user

00:10:45,839 --> 00:10:50,399
interface in the cpr standards library

00:10:47,920 --> 00:10:51,040
so if you plan to standardize it as a

00:10:50,399 --> 00:10:52,720
three-part

00:10:51,040 --> 00:10:54,640
presenting part of the standard library

00:10:52,720 --> 00:10:55,839
it doesn't have to it cannot have macros

00:10:54,640 --> 00:10:57,360
and it shouldn't have any external

00:10:55,839 --> 00:10:59,680
dependencies

00:10:57,360 --> 00:11:00,480
right now it has a few because there is

00:10:59,680 --> 00:11:04,079
no fmt

00:11:00,480 --> 00:11:04,320
in any compiler from c plus 20. also we

00:11:04,079 --> 00:11:07,680
are

00:11:04,320 --> 00:11:10,720
using msgsl for expects

00:11:07,680 --> 00:11:13,120
but actually it's not that important and

00:11:10,720 --> 00:11:15,200
this dependency can be easily dropped i

00:11:13,120 --> 00:11:16,160
hope that contracts will be in splatoon

00:11:15,200 --> 00:11:17,920
23 so we'll

00:11:16,160 --> 00:11:20,480
replace it in with contrast in c plus

00:11:17,920 --> 00:11:20,480
23.

00:11:23,360 --> 00:11:26,560
and that's all about the

00:11:27,200 --> 00:11:33,360
about the introduction i see a question

00:11:30,320 --> 00:11:34,880
so si is a particular source of base

00:11:33,360 --> 00:11:37,120
units for mass length time

00:11:34,880 --> 00:11:40,240
temperature etc how to choose other

00:11:37,120 --> 00:11:43,839
non-si based units

00:11:40,240 --> 00:11:44,480
uh it's actually really simple to use it

00:11:43,839 --> 00:11:47,120
with different

00:11:44,480 --> 00:11:47,680
systems we actually provide uh already

00:11:47,120 --> 00:11:51,279
in our

00:11:47,680 --> 00:11:52,399
repositories uh uh units from the

00:11:51,279 --> 00:11:55,519
international system

00:11:52,399 --> 00:11:56,000
from from us to u.s customer system we

00:11:55,519 --> 00:11:59,519
have all

00:11:56,000 --> 00:12:02,399
system for for foot pounds second and

00:11:59,519 --> 00:12:02,880
the closest term for cgs so centimeter

00:12:02,399 --> 00:12:06,320
gram

00:12:02,880 --> 00:12:07,760
and and second we also started to work

00:12:06,320 --> 00:12:08,800
and provide the support for natural

00:12:07,760 --> 00:12:10,240
units

00:12:08,800 --> 00:12:12,639
it's really easy to extend that there is

00:12:10,240 --> 00:12:14,560
a dedicated chapter in our documentation

00:12:12,639 --> 00:12:16,320
about how to create custom systems so i

00:12:14,560 --> 00:12:19,600
really encourage you to go there

00:12:16,320 --> 00:12:21,120
and and read it i can provide some

00:12:19,600 --> 00:12:22,959
insights during the talk and if you have

00:12:21,120 --> 00:12:23,760
time at the end i may provide also some

00:12:22,959 --> 00:12:26,000
additional

00:12:23,760 --> 00:12:27,680
details about it if there will be more

00:12:26,000 --> 00:12:30,160
interests about how to extend the

00:12:27,680 --> 00:12:30,160
library

00:12:32,240 --> 00:12:36,320
but si is the base and probably sa will

00:12:34,880 --> 00:12:37,920
be the first one that will be

00:12:36,320 --> 00:12:40,240
standardized if it will be standardized

00:12:37,920 --> 00:12:40,240
at all

00:12:41,600 --> 00:12:45,600
so we are moving to strong interfaces

00:12:50,079 --> 00:12:54,880
for our discussion on strong interfaces

00:12:52,720 --> 00:12:59,200
i would like us to work on such a simple

00:12:54,880 --> 00:13:01,360
toy example i will have a simple average

00:12:59,200 --> 00:13:03,760
speed function that takes length

00:13:01,360 --> 00:13:05,600
that takes time and returns as the

00:13:03,760 --> 00:13:07,839
average speed right so distance by the

00:13:05,600 --> 00:13:07,839
duration

00:13:08,959 --> 00:13:13,279
i would like to provide the speed both

00:13:10,639 --> 00:13:15,920
in kilometers and and time in hours

00:13:13,279 --> 00:13:17,440
but also in miles international miles

00:13:15,920 --> 00:13:19,040
and hours

00:13:17,440 --> 00:13:20,480
and in both cases if i provide

00:13:19,040 --> 00:13:23,760
kilometers and hours i would like to

00:13:20,480 --> 00:13:26,639
have a result in kilometers per hour

00:13:23,760 --> 00:13:28,480
and in case other case miles per hour

00:13:26,639 --> 00:13:30,880
right

00:13:28,480 --> 00:13:32,480
it should be comparable time save so all

00:13:30,880 --> 00:13:35,920
of the problems should be

00:13:32,480 --> 00:13:37,040
provided during compile time uh sub

00:13:35,920 --> 00:13:38,959
there should be support for multiple

00:13:37,040 --> 00:13:40,959
units and unit prefixes so you can see

00:13:38,959 --> 00:13:44,560
right now that it's supporting already

00:13:40,959 --> 00:13:44,560
in international units

00:13:45,199 --> 00:13:49,360
and there should be no runtime overhead

00:13:47,440 --> 00:13:50,720
it should be as fast as implemented with

00:13:49,360 --> 00:13:52,399
double

00:13:50,720 --> 00:13:53,760
and there should be no intermediate

00:13:52,399 --> 00:13:57,360
conversions being done

00:13:53,760 --> 00:13:57,360
to base units back for example

00:14:00,560 --> 00:14:04,320
so this is how you can implement this

00:14:02,399 --> 00:14:06,560
with plain double right this is what

00:14:04,320 --> 00:14:09,920
i've seen too many times in production

00:14:06,560 --> 00:14:10,959
working as a consultant uh in different

00:14:09,920 --> 00:14:12,399
companies

00:14:10,959 --> 00:14:14,000
and it's also really common in open

00:14:12,399 --> 00:14:16,639
source to see

00:14:14,000 --> 00:14:18,480
phoenix like this macros hours to

00:14:16,639 --> 00:14:21,839
seconds kilometers to meters

00:14:18,480 --> 00:14:23,600
and so on and then you just have a

00:14:21,839 --> 00:14:25,839
function that takes double

00:14:23,600 --> 00:14:27,199
and another double and returns double

00:14:25,839 --> 00:14:29,279
and there's a documentation saying the

00:14:27,199 --> 00:14:31,199
distance should be fighted in meters

00:14:29,279 --> 00:14:34,320
time should be in seconds speed should

00:14:31,199 --> 00:14:34,320
be meters per second

00:14:36,000 --> 00:14:40,399
and this is only documentation right and

00:14:37,680 --> 00:14:40,399
that has to be

00:14:41,040 --> 00:14:45,199
basically it's a contract and everyone

00:14:43,120 --> 00:14:48,480
has to obey it

00:14:45,199 --> 00:14:49,440
according to this to this contract so if

00:14:48,480 --> 00:14:51,040
you want to implement

00:14:49,440 --> 00:14:53,279
the story example one when we want to

00:14:51,040 --> 00:14:56,399
provide kilometers and and ours

00:14:53,279 --> 00:14:59,519
we take some two double values

00:14:56,399 --> 00:15:02,399
uh convert them to from kilometers

00:14:59,519 --> 00:15:03,680
to meters from hours to seconds to

00:15:02,399 --> 00:15:05,920
average speed and

00:15:03,680 --> 00:15:07,600
return this one because we have to

00:15:05,920 --> 00:15:08,639
convert back from meters per second to

00:15:07,600 --> 00:15:10,800
kilometers per hour

00:15:08,639 --> 00:15:13,839
let me do something similar to miles per

00:15:10,800 --> 00:15:13,839
hour right

00:15:14,079 --> 00:15:16,639
then if you want to print it of course

00:15:15,279 --> 00:15:18,240
it will print a double value so it will

00:15:16,639 --> 00:15:21,199
just print 110

00:15:18,240 --> 00:15:21,760
and 70. and this is correct results

00:15:21,199 --> 00:15:26,399
right but

00:15:21,760 --> 00:15:29,839
it's really easy to make errors here

00:15:26,399 --> 00:15:33,519
so you want to make it better

00:15:29,839 --> 00:15:33,519
let's see how boost units does it

00:15:34,639 --> 00:15:38,160
for all of the examples you can find the

00:15:36,000 --> 00:15:40,959
gold ball things here you can

00:15:38,160 --> 00:15:42,240
provide you can type them and see how

00:15:40,959 --> 00:15:45,839
they actually perform

00:15:42,240 --> 00:15:48,959
in godbolt and and see by yourself

00:15:45,839 --> 00:15:50,160
how it works so in order to provide this

00:15:48,959 --> 00:15:52,320
example simple example

00:15:50,160 --> 00:15:54,160
in boost units you have to include bunch

00:15:52,320 --> 00:15:56,240
of headers

00:15:54,160 --> 00:15:58,079
there are not many aggregated headers

00:15:56,240 --> 00:16:00,639
that will allow you to

00:15:58,079 --> 00:16:01,199
basically include only one thing and it

00:16:00,639 --> 00:16:02,800
will just

00:16:01,199 --> 00:16:04,480
include everything else you have to

00:16:02,800 --> 00:16:06,000
remember about every single header to

00:16:04,480 --> 00:16:07,920
put here

00:16:06,000 --> 00:16:09,920
it's really hard to provide all sets

00:16:07,920 --> 00:16:11,600
needed and sometimes error messages are

00:16:09,920 --> 00:16:13,440
not that helpful to notice

00:16:11,600 --> 00:16:15,600
and project information which header is

00:16:13,440 --> 00:16:17,920
missing

00:16:15,600 --> 00:16:20,079
and then we are implementing the average

00:16:17,920 --> 00:16:21,440
speed function we provide here a helper

00:16:20,079 --> 00:16:23,839
for boost units

00:16:21,440 --> 00:16:25,199
and we provided it takes quantity of

00:16:23,839 --> 00:16:28,800
length and quantity of time and

00:16:25,199 --> 00:16:28,800
resonance quantity of velocity

00:16:30,240 --> 00:16:33,440
and that's the calculation

00:16:33,839 --> 00:16:38,639
unfortunately there is no uh support in

00:16:37,040 --> 00:16:39,600
both units even though it's really huge

00:16:38,639 --> 00:16:41,680
library

00:16:39,600 --> 00:16:43,279
to non-coherent units so if you want to

00:16:41,680 --> 00:16:44,240
work with something different than meter

00:16:43,279 --> 00:16:45,920
and second

00:16:44,240 --> 00:16:48,079
you have to provide the support by

00:16:45,920 --> 00:16:50,399
yourself for many things

00:16:48,079 --> 00:16:52,240
you have to create stuff for kilometer

00:16:50,399 --> 00:16:54,399
for mile for hour

00:16:52,240 --> 00:16:57,040
for kilometers per hour for miles per

00:16:54,399 --> 00:16:59,120
hour provide your own dimensions and

00:16:57,040 --> 00:17:02,959
and and your only units for those and

00:16:59,120 --> 00:17:04,400
constants for of units of portals

00:17:02,959 --> 00:17:06,640
so it's not that easy to work with

00:17:04,400 --> 00:17:10,959
non-concurrent units in in boost

00:17:06,640 --> 00:17:12,640
units so coming towards the example with

00:17:10,959 --> 00:17:16,559
kilometers per hour

00:17:12,640 --> 00:17:19,280
we get length in kilometer time in hour

00:17:16,559 --> 00:17:20,400
we call our average speed but we have to

00:17:19,280 --> 00:17:23,600
explicitly

00:17:20,400 --> 00:17:26,720
uh convert every time

00:17:23,600 --> 00:17:29,840
to the destination destination was

00:17:26,720 --> 00:17:33,039
the remember length

00:17:29,840 --> 00:17:35,120
time and velocity and actually undertook

00:17:33,039 --> 00:17:37,360
means that these are si base units so

00:17:35,120 --> 00:17:39,360
meters seconds and meters per second

00:17:37,360 --> 00:17:40,799
it is not stated here clearly but it

00:17:39,360 --> 00:17:44,240
means that exactly

00:17:40,799 --> 00:17:45,039
so if you want to convert this length in

00:17:44,240 --> 00:17:46,480
kilometers

00:17:45,039 --> 00:17:48,480
to lengthy meters you have to do

00:17:46,480 --> 00:17:50,000
explicit conversion here even though the

00:17:48,480 --> 00:17:51,760
conversion is really safe and

00:17:50,000 --> 00:17:54,559
it could be done implicitly like it's

00:17:51,760 --> 00:17:57,679
being done by chrono duration

00:17:54,559 --> 00:17:58,880
and the same goes for miles per hour so

00:17:57,679 --> 00:18:00,720
there are no implicit conversions

00:17:58,880 --> 00:18:04,000
between quantities of the same dimension

00:18:00,720 --> 00:18:04,000
and comparable units

00:18:07,440 --> 00:18:11,200
if you want to use those boost unit uses

00:18:09,840 --> 00:18:11,919
this multiple syntax to create

00:18:11,200 --> 00:18:15,039
quantities

00:18:11,919 --> 00:18:19,280
so you create 220 times kilo

00:18:15,039 --> 00:18:22,240
times meters and two times hours

00:18:19,280 --> 00:18:22,720
and you get a result and then do the

00:18:22,240 --> 00:18:26,640
same for

00:18:22,720 --> 00:18:30,000
miles if you want to print it it prints

00:18:26,640 --> 00:18:31,919
quite a correct text for for miles per

00:18:30,000 --> 00:18:33,120
hour but for kilometers per hour i would

00:18:31,919 --> 00:18:43,600
say it's not the best

00:18:33,120 --> 00:18:45,600
output but still valid

00:18:43,600 --> 00:18:47,600
another labor that i would be referring

00:18:45,600 --> 00:18:51,200
here is a library

00:18:47,600 --> 00:18:53,679
named units implemented by nick holthaus

00:18:51,200 --> 00:18:54,559
in this library actually it says their

00:18:53,679 --> 00:18:57,039
own libraries

00:18:54,559 --> 00:18:59,679
with one single header that is really

00:18:57,039 --> 00:19:01,600
easy to include everything

00:18:59,679 --> 00:19:02,799
and then you provide a very speed of

00:19:01,600 --> 00:19:06,400
meter second

00:19:02,799 --> 00:19:09,360
and return velocity in meters per second

00:19:06,400 --> 00:19:10,160
and if you want to call it you provide

00:19:09,360 --> 00:19:13,120
kilometer

00:19:10,160 --> 00:19:14,720
hour as an argument and then they are

00:19:13,120 --> 00:19:17,440
implicitly converted to

00:19:14,720 --> 00:19:18,960
the proper types and then you return to

00:19:17,440 --> 00:19:21,360
convert the result back to kilometers

00:19:18,960 --> 00:19:21,360
per hour

00:19:22,240 --> 00:19:25,919
when you try to print it it even though

00:19:25,600 --> 00:19:28,080
it

00:19:25,919 --> 00:19:29,120
returns you kilometers per hour it

00:19:28,080 --> 00:19:33,039
prints it in

00:19:29,120 --> 00:19:34,720
base units meters per second

00:19:33,039 --> 00:19:39,840
so it's not exactly what we would like

00:19:34,720 --> 00:19:39,840
to have here

00:19:42,080 --> 00:19:46,160
i see there is a question is it possible

00:19:44,160 --> 00:19:49,840
to take a dimension to value and ignore

00:19:46,160 --> 00:19:49,840
the dimension in a given calculation

00:19:50,480 --> 00:19:55,440
yes it has interface similar to duration

00:19:53,600 --> 00:19:57,360
you can always get count

00:19:55,440 --> 00:19:59,039
and with count you just get a value from

00:19:57,360 --> 00:20:00,799
the quantity so you are losing all of

00:19:59,039 --> 00:20:03,760
this strong typing here

00:20:00,799 --> 00:20:05,760
just before you call count always

00:20:03,760 --> 00:20:06,880
remember about doing a quantity cast or

00:20:05,760 --> 00:20:08,799
a duration crossing because

00:20:06,880 --> 00:20:11,039
in case of duration because you want to

00:20:08,799 --> 00:20:14,159
make sure that the unit is exactly

00:20:11,039 --> 00:20:15,520
with which you intended here so do not

00:20:14,159 --> 00:20:17,679
make any assumptions like i

00:20:15,520 --> 00:20:18,960
may store different units in the type so

00:20:17,679 --> 00:20:20,480
make a quantity cast

00:20:18,960 --> 00:20:22,080
on the quantity and then you may do

00:20:20,480 --> 00:20:23,919
count and get the

00:20:22,080 --> 00:20:26,960
raw value and work with for example

00:20:23,919 --> 00:20:26,960
legacy interfaces

00:20:27,120 --> 00:20:35,840
but be careful this is losing all of the

00:20:30,000 --> 00:20:35,840
safety here

00:20:36,400 --> 00:20:39,440
and finally the mp units the library

00:20:38,880 --> 00:20:42,559
that

00:20:39,440 --> 00:20:45,919
i implemented with contributors uh

00:20:42,559 --> 00:20:48,159
we are including here the speed nsi and

00:20:45,919 --> 00:20:52,400
speed in international units

00:20:48,159 --> 00:20:55,039
systems um and we have

00:20:52,400 --> 00:20:57,280
the si length in meters as i time in

00:20:55,039 --> 00:20:58,400
seconds so here we are static explicitly

00:20:57,280 --> 00:21:00,080
that we are working with meters and

00:20:58,400 --> 00:21:02,320
seconds

00:21:00,080 --> 00:21:04,400
and we are turning meter per second and

00:21:02,320 --> 00:21:06,320
just doing the calculation

00:21:04,400 --> 00:21:07,520
then our example with kilometers and

00:21:06,320 --> 00:21:09,679
hours

00:21:07,520 --> 00:21:11,280
uh just implicitly converts those here

00:21:09,679 --> 00:21:11,840
because it's safe to convert kilometer

00:21:11,280 --> 00:21:14,799
to hour

00:21:11,840 --> 00:21:16,640
it's made kilometer to meter and hour to

00:21:14,799 --> 00:21:17,600
second it may not be safe to do it in a

00:21:16,640 --> 00:21:20,240
different

00:21:17,600 --> 00:21:21,360
order but in this case it's safe so you

00:21:20,240 --> 00:21:23,440
can do this implicitly

00:21:21,360 --> 00:21:25,840
this is the same rules as in case of

00:21:23,440 --> 00:21:27,600
chronological applies here

00:21:25,840 --> 00:21:30,799
and then we are quantity casting this to

00:21:27,600 --> 00:21:33,360
kilometer per hour and returning a type

00:21:30,799 --> 00:21:33,840
and the value in kilometers per hour and

00:21:33,360 --> 00:21:38,720
the same

00:21:33,840 --> 00:21:40,720
for miles per hour when you want to

00:21:38,720 --> 00:21:41,919
run this function you provide here for

00:21:40,720 --> 00:21:45,600
example one with

00:21:41,919 --> 00:21:46,559
220 quantity in kilometers to quantities

00:21:45,600 --> 00:21:50,400
in

00:21:46,559 --> 00:21:53,120
quantity of hours and

00:21:50,400 --> 00:21:53,919
you get the output printer printed

00:21:53,120 --> 00:21:59,840
properly

00:21:53,919 --> 00:21:59,840
as one would expect

00:22:05,039 --> 00:22:08,400
however uh until now we were always

00:22:07,360 --> 00:22:12,320
taking the

00:22:08,400 --> 00:22:14,400
uh we're always thinking the length in

00:22:12,320 --> 00:22:16,159
kilometers and timing hours then we're

00:22:14,400 --> 00:22:18,000
converting this to the base units so

00:22:16,159 --> 00:22:19,440
meters and seconds and then converting

00:22:18,000 --> 00:22:20,960
and getting the results in meter per

00:22:19,440 --> 00:22:22,240
second and then converting base to

00:22:20,960 --> 00:22:24,720
kilometers per hour

00:22:22,240 --> 00:22:26,880
and this is not the best idea in terms

00:22:24,720 --> 00:22:29,280
of performance right runtime performance

00:22:26,880 --> 00:22:30,000
you would like to be able to do this in

00:22:29,280 --> 00:22:32,240
one step

00:22:30,000 --> 00:22:33,360
if you provide kilometers and hours and

00:22:32,240 --> 00:22:34,720
we are interested in the speed in

00:22:33,360 --> 00:22:35,760
kilometers per hours

00:22:34,720 --> 00:22:37,280
there should be no intermediate

00:22:35,760 --> 00:22:39,039
conversions we should just divide

00:22:37,280 --> 00:22:42,559
kilometers per hours and get the results

00:22:39,039 --> 00:22:45,760
immediately right with one division

00:22:42,559 --> 00:22:47,440
so how to do it with doubles

00:22:45,760 --> 00:22:50,320
it is easy they will take everything

00:22:47,440 --> 00:22:51,840
right you just specify here that this is

00:22:50,320 --> 00:22:54,559
double in kilometers

00:22:51,840 --> 00:22:55,919
time in hours doubling miles and

00:22:54,559 --> 00:22:58,559
everything works

00:22:55,919 --> 00:22:58,559
simple right

00:23:01,120 --> 00:23:04,159
with both units it actually starts to be

00:23:03,360 --> 00:23:05,919
complicated

00:23:04,159 --> 00:23:08,240
we have to introduce templates and it's

00:23:05,919 --> 00:23:10,640
not that easy to specify those templates

00:23:08,240 --> 00:23:11,280
we are saying that it's a quantity of a

00:23:10,640 --> 00:23:13,520
unit

00:23:11,280 --> 00:23:15,280
of a length dimension and some system

00:23:13,520 --> 00:23:17,039
and some representation

00:23:15,280 --> 00:23:18,880
and this is our distance and you're

00:23:17,039 --> 00:23:20,000
doing the same for time and this is our

00:23:18,880 --> 00:23:22,400
time

00:23:20,000 --> 00:23:23,840
and to say we are returning speed we

00:23:22,400 --> 00:23:26,320
actually have to create

00:23:23,840 --> 00:23:27,120
the speed speed in kilometers per or the

00:23:26,320 --> 00:23:29,840
speed

00:23:27,120 --> 00:23:30,799
in the destination you need by ourselves

00:23:29,840 --> 00:23:33,600
saying that we are taking

00:23:30,799 --> 00:23:35,760
unit of length provided here of time

00:23:33,600 --> 00:23:38,960
provided here and we are dividing those

00:23:35,760 --> 00:23:42,960
so actually we are here manually

00:23:38,960 --> 00:23:42,960
re-implementing the logic of the library

00:23:43,600 --> 00:23:48,320
in case of nick hold house library

00:23:48,400 --> 00:23:51,840
it's also not that easy to do actually

00:23:50,240 --> 00:23:53,120
we cannot easily provide those

00:23:51,840 --> 00:23:54,159
specializations here like in the

00:23:53,120 --> 00:23:55,679
previous case but

00:23:54,159 --> 00:23:57,760
unfortunately there are type trades

00:23:55,679 --> 00:24:00,720
provided that you can use to

00:23:57,760 --> 00:24:02,240
provide enable if and and basically spin

00:24:00,720 --> 00:24:04,880
on specific types

00:24:02,240 --> 00:24:05,840
because if otherwise this will take

00:24:04,880 --> 00:24:08,480
everything

00:24:05,840 --> 00:24:10,159
strings vectors whatever right it's just

00:24:08,480 --> 00:24:12,000
a type t

00:24:10,159 --> 00:24:13,120
but with innate belief you can specify

00:24:12,000 --> 00:24:14,559
that the first one should be length

00:24:13,120 --> 00:24:16,240
another one should be time

00:24:14,559 --> 00:24:18,960
and it's not that easy to specify that

00:24:16,240 --> 00:24:20,799
should be a velocity returned back

00:24:18,960 --> 00:24:22,480
so this is on a static assert provided

00:24:20,799 --> 00:24:25,600
as an implementation detail here

00:24:22,480 --> 00:24:27,360
rather than the

00:24:25,600 --> 00:24:32,240
information provided directly in the in

00:24:27,360 --> 00:24:34,080
the function interface

00:24:32,240 --> 00:24:35,440
however we have come we've got concepts

00:24:34,080 --> 00:24:37,440
in c plus plus 20.

00:24:35,440 --> 00:24:39,039
when we add one additional header to

00:24:37,440 --> 00:24:40,480
both units

00:24:39,039 --> 00:24:42,320
we can work with this quantity of

00:24:40,480 --> 00:24:44,880
dimension type trade

00:24:42,320 --> 00:24:46,480
and we can create quantity of concept

00:24:44,880 --> 00:24:47,600
and then say that we have concept length

00:24:46,480 --> 00:24:49,520
that is quantity of

00:24:47,600 --> 00:24:52,159
length one time quantity of time

00:24:49,520 --> 00:24:53,520
velocity quantity of velocity

00:24:52,159 --> 00:24:55,679
and with this we can implement all of

00:24:53,520 --> 00:24:57,600
the function in this way

00:24:55,679 --> 00:24:59,520
with simpler plus 20 syntax of generic

00:24:57,600 --> 00:25:01,200
functions right the secondary function

00:24:59,520 --> 00:25:02,080
similar to what we know for generic

00:25:01,200 --> 00:25:03,679
lambdas

00:25:02,080 --> 00:25:06,480
every time you see an auto as a

00:25:03,679 --> 00:25:08,640
parameter of a function or a lambda

00:25:06,480 --> 00:25:11,200
then you know it's a template parameter

00:25:08,640 --> 00:25:11,200
under the hood

00:25:12,559 --> 00:25:15,760
descent can be done for nick hall house

00:25:14,240 --> 00:25:17,600
units you

00:25:15,760 --> 00:25:20,480
may say that length is its length time

00:25:17,600 --> 00:25:23,200
is this time velocity is velocity

00:25:20,480 --> 00:25:24,000
and then you have exactly the same

00:25:23,200 --> 00:25:28,000
implementation

00:25:24,000 --> 00:25:29,520
of the function so as you can see it

00:25:28,000 --> 00:25:31,039
makes everything simpler it makes

00:25:29,520 --> 00:25:33,440
everything generic

00:25:31,039 --> 00:25:34,159
and the it's really easy to maintain and

00:25:33,440 --> 00:25:35,840
understand

00:25:34,159 --> 00:25:38,799
and that's why this is the default and

00:25:35,840 --> 00:25:39,919
recommended case to work in our library

00:25:38,799 --> 00:25:42,320
all of those concepts are already

00:25:39,919 --> 00:25:44,720
provided and

00:25:42,320 --> 00:25:45,520
for all of the physical systems so if

00:25:44,720 --> 00:25:47,440
you want to say

00:25:45,520 --> 00:25:48,960
this is a length of any systems i don't

00:25:47,440 --> 00:25:50,880
care this is a time of any system i

00:25:48,960 --> 00:25:51,840
don't care this is a speed open system i

00:25:50,880 --> 00:25:55,039
don't care

00:25:51,840 --> 00:25:58,880
i just want to return correct values

00:25:55,039 --> 00:25:58,880
and this is what the code will do

00:26:04,880 --> 00:26:08,480
okay we have a new question sometimes

00:26:06,640 --> 00:26:11,360
non-coherent si units are necessary

00:26:08,480 --> 00:26:12,799
for to ensure appropriate numeric

00:26:11,360 --> 00:26:14,240
precision

00:26:12,799 --> 00:26:15,919
is there a support for non-coherent

00:26:14,240 --> 00:26:20,080
things expected to solve this

00:26:15,919 --> 00:26:20,080
are the regulators in library functions

00:26:22,840 --> 00:26:27,840
uh

00:26:24,240 --> 00:26:30,320
non-coherent sie units uh are supported

00:26:27,840 --> 00:26:30,960
and they're also really easy to provide

00:26:30,320 --> 00:26:33,039
those

00:26:30,960 --> 00:26:34,799
the only problem i'm aware of with

00:26:33,039 --> 00:26:35,679
working with non-coherent sa units and

00:26:34,799 --> 00:26:38,640
if they are not

00:26:35,679 --> 00:26:40,960
units that are basically derived with sa

00:26:38,640 --> 00:26:43,279
prefixes so multiplies of 10

00:26:40,960 --> 00:26:44,559
is that basically the ratios start to

00:26:43,279 --> 00:26:48,080
get really really big

00:26:44,559 --> 00:26:49,840
in some calculations so for example food

00:26:48,080 --> 00:26:51,120
has some pretty complicated ratio

00:26:49,840 --> 00:26:54,080
already com

00:26:51,120 --> 00:26:55,760
relative to meter but if you make then

00:26:54,080 --> 00:26:58,640
square foot or cubic foot

00:26:55,760 --> 00:27:00,480
it starts to be messy already and with

00:26:58,640 --> 00:27:02,880
some more operations or some

00:27:00,480 --> 00:27:05,200
more strange things like i don't know

00:27:02,880 --> 00:27:06,080
electron vault or maybe as astronomic

00:27:05,200 --> 00:27:09,120
unit

00:27:06,080 --> 00:27:12,000
you will find out that that ratio can go

00:27:09,120 --> 00:27:12,559
out of out of precision even though it

00:27:12,000 --> 00:27:17,600
uses

00:27:12,559 --> 00:27:19,679
64 64 bit integers under the hood

00:27:17,600 --> 00:27:21,120
so this is this is the only gotcha i

00:27:19,679 --> 00:27:24,159
know here

00:27:21,120 --> 00:27:25,919
with working with non-coherent units but

00:27:24,159 --> 00:27:28,000
as long as those are the current you

00:27:25,919 --> 00:27:30,159
non-covered units with essay prefixes so

00:27:28,000 --> 00:27:32,640
just an exponent of 10 you are free to

00:27:30,159 --> 00:27:35,840
use them easily

00:27:32,640 --> 00:27:38,960
and there should be no problems

00:27:35,840 --> 00:27:40,960
okay next chapter is about performance

00:27:38,960 --> 00:27:42,159
i make this transparent because you

00:27:40,960 --> 00:27:43,919
already see this code i don't want to

00:27:42,159 --> 00:27:45,440
spend time you reading this because we

00:27:43,919 --> 00:27:48,960
already analyzed this

00:27:45,440 --> 00:27:51,520
for double the operations for all of the

00:27:48,960 --> 00:27:53,760
conversions for the coherent units

00:27:51,520 --> 00:27:55,120
provide three multiplies two divides and

00:27:53,760 --> 00:27:57,840
a bunch of moves

00:27:55,120 --> 00:28:00,840
so some copies are being done actually i

00:27:57,840 --> 00:28:03,200
was surprised to see those copies in the

00:28:00,840 --> 00:28:06,080
assembly

00:28:03,200 --> 00:28:08,080
for both units it's pretty similar we

00:28:06,080 --> 00:28:08,799
save one divide so already both units is

00:28:08,080 --> 00:28:12,080
faster

00:28:08,799 --> 00:28:12,080
than pure doubles

00:28:13,440 --> 00:28:17,520
for nick holt house we don't have any of

00:28:15,600 --> 00:28:19,120
those copies

00:28:17,520 --> 00:28:21,600
but the same number of multipliers and

00:28:19,120 --> 00:28:23,679
divides

00:28:21,600 --> 00:28:24,799
and with our library we don't have

00:28:23,679 --> 00:28:26,559
copies again

00:28:24,799 --> 00:28:30,000
and we have only one division so it's

00:28:26,559 --> 00:28:31,919
faster than working on doubles

00:28:30,000 --> 00:28:34,480
at least in this case implemented on the

00:28:31,919 --> 00:28:34,480
previous slide

00:28:39,600 --> 00:28:42,720
well working with generic code so if you

00:28:41,520 --> 00:28:45,360
want to just

00:28:42,720 --> 00:28:46,960
divide the values then of course there's

00:28:45,360 --> 00:28:48,640
only division provided here right

00:28:46,960 --> 00:28:50,240
if you play kilometers and hours and

00:28:48,640 --> 00:28:51,760
once kilometers per hour you just divide

00:28:50,240 --> 00:28:52,880
those and don't provide any intermediate

00:28:51,760 --> 00:28:56,000
conversions

00:28:52,880 --> 00:28:57,840
and this is fine with a boost

00:28:56,000 --> 00:29:00,240
there's also only one division but some

00:28:57,840 --> 00:29:02,960
additional copies being done

00:29:00,240 --> 00:29:03,679
nick halthouse on the division our

00:29:02,960 --> 00:29:06,720
library

00:29:03,679 --> 00:29:07,360
on the division so as you can see you

00:29:06,720 --> 00:29:10,159
don't pay

00:29:07,360 --> 00:29:13,039
anything comparing to using row

00:29:10,159 --> 00:29:14,480
fundamental types with those additional

00:29:13,039 --> 00:29:15,679
abstractions that are that making

00:29:14,480 --> 00:29:17,760
everything type save

00:29:15,679 --> 00:29:19,120
and actually in some cases those

00:29:17,760 --> 00:29:21,039
obstructions provide even better

00:29:19,120 --> 00:29:23,039
performance than the role fundamental

00:29:21,039 --> 00:29:27,840
types used under the hood

00:29:23,039 --> 00:29:27,840
so it is type safe and fast in runtime

00:29:29,840 --> 00:29:34,480
user experience so as i said everything

00:29:33,520 --> 00:29:36,399
here is about

00:29:34,480 --> 00:29:37,520
generating errors right and verifying

00:29:36,399 --> 00:29:41,039
our

00:29:37,520 --> 00:29:43,600
our calculations if there is an error

00:29:41,039 --> 00:29:45,679
it should be found during compile time

00:29:43,600 --> 00:29:47,840
not run time

00:29:45,679 --> 00:29:49,600
so in case of doubles if you provide

00:29:47,840 --> 00:29:51,679
multiply instead of division and you say

00:29:49,600 --> 00:29:54,000
i want to have speed

00:29:51,679 --> 00:29:55,120
it's wrong but actually it will compile

00:29:54,000 --> 00:29:57,200
fine right

00:29:55,120 --> 00:29:58,960
so all sorts of bugs can be provided

00:29:57,200 --> 00:30:01,039
here there are errors of time

00:29:58,960 --> 00:30:02,960
there are errors at runtime but during

00:30:01,039 --> 00:30:05,039
company time everything compiles fine

00:30:02,960 --> 00:30:06,640
if it wouldn't compile then we wouldn't

00:30:05,039 --> 00:30:08,960
care and we'll never write this library

00:30:06,640 --> 00:30:10,880
because it will be already solved right

00:30:08,960 --> 00:30:12,159
the problem is to actually solve this

00:30:10,880 --> 00:30:14,399
problem

00:30:12,159 --> 00:30:16,320
that working on fundamental types is

00:30:14,399 --> 00:30:19,200
unsafe

00:30:16,320 --> 00:30:20,559
and in times where a car drives for us

00:30:19,200 --> 00:30:23,279
while we sleep or

00:30:20,559 --> 00:30:25,200
or play on the computer it gets even

00:30:23,279 --> 00:30:28,720
more important

00:30:25,200 --> 00:30:31,039
to make it type safe and maybe save

00:30:28,720 --> 00:30:31,039
lives

00:30:32,159 --> 00:30:36,320
if you made the same error for boost

00:30:34,840 --> 00:30:38,640
units

00:30:36,320 --> 00:30:39,440
this is what you get as an error in

00:30:38,640 --> 00:30:42,640
function

00:30:39,440 --> 00:30:42,640
and this is a function name

00:30:42,720 --> 00:30:45,760
if you will be careful you will find

00:30:44,240 --> 00:30:46,240
three dots at the end of this of the

00:30:45,760 --> 00:30:48,480
slide

00:30:46,240 --> 00:30:49,360
it means that it's not the end of the of

00:30:48,480 --> 00:30:50,960
the function name

00:30:49,360 --> 00:30:52,240
of the first line of the letter log

00:30:50,960 --> 00:30:53,760
because this is still the first line

00:30:52,240 --> 00:30:55,279
stating the function where the error

00:30:53,760 --> 00:30:58,880
happened

00:30:55,279 --> 00:31:01,279
this is the rest of the function name

00:30:58,880 --> 00:31:03,840
and there's an error could not convert

00:31:01,279 --> 00:31:07,200
some operator star

00:31:03,840 --> 00:31:10,480
again we are out of this slide screen

00:31:07,200 --> 00:31:10,480
this this light here

00:31:10,559 --> 00:31:14,559
and even more operator star

00:31:15,360 --> 00:31:23,279
and at the end from quantity 3.3 dots

00:31:19,200 --> 00:31:23,279
to quantity 3.3.3.

00:31:23,519 --> 00:31:29,120
and i assume you know everything right

00:31:26,080 --> 00:31:33,600
what happened here what is wrong

00:31:29,120 --> 00:31:35,440
or not is not the best user experience

00:31:33,600 --> 00:31:37,600
it doesn't compile it right it's good

00:31:35,440 --> 00:31:39,760
because because it is safe to use

00:31:37,600 --> 00:31:42,240
but then you spent hours finding out why

00:31:39,760 --> 00:31:44,080
your calculation doesn't compile

00:31:42,240 --> 00:31:47,840
and this is not the best user experience

00:31:44,080 --> 00:31:47,840
for anyone

00:31:49,600 --> 00:31:53,840
for nuclear house units there is a

00:31:52,159 --> 00:31:56,240
different approach

00:31:53,840 --> 00:31:57,360
there is no of that there is no overall

00:31:56,240 --> 00:31:59,120
resolution process

00:31:57,360 --> 00:32:00,640
finding here but there is a static

00:31:59,120 --> 00:32:02,480
assert

00:32:00,640 --> 00:32:04,799
stating static assertion failed units

00:32:02,480 --> 00:32:06,799
are not compatible

00:32:04,799 --> 00:32:08,399
so the error is short there is a nice

00:32:06,799 --> 00:32:09,440
error message at the end

00:32:08,399 --> 00:32:10,720
but actually there is instant

00:32:09,440 --> 00:32:12,720
information that there is instantiation

00:32:10,720 --> 00:32:14,080
of a function required from

00:32:12,720 --> 00:32:16,559
and please tell me what are the units

00:32:14,080 --> 00:32:18,080
here looking at the error log

00:32:16,559 --> 00:32:21,279
which units are not compatible what was

00:32:18,080 --> 00:32:21,279
expected what was provided

00:32:22,640 --> 00:32:27,360
a bunch of ratios right it's again

00:32:25,519 --> 00:32:29,840
really hard to understand what's going

00:32:27,360 --> 00:32:29,840
on here

00:32:33,279 --> 00:32:37,840
with the library we implemented

00:32:36,399 --> 00:32:40,799
you have the information that in

00:32:37,840 --> 00:32:43,279
function sa speed

00:32:40,799 --> 00:32:44,799
is a return return type of this of this

00:32:43,279 --> 00:32:47,919
function

00:32:44,799 --> 00:32:49,840
as i length in meters is the first

00:32:47,919 --> 00:32:52,000
argument as a time in seconds a second

00:32:49,840 --> 00:32:54,840
argument

00:32:52,000 --> 00:32:56,880
and we couldn't convert for the operator

00:32:54,840 --> 00:32:59,279
star from

00:32:56,880 --> 00:33:00,640
quantity of an unknown dimension because

00:32:59,279 --> 00:33:03,840
this unknown dimension had

00:33:00,640 --> 00:33:05,760
dimension length in exponent one

00:33:03,840 --> 00:33:07,600
and dimension time in exponent one right

00:33:05,760 --> 00:33:08,640
because we oh actually should have an

00:33:07,600 --> 00:33:10,000
error here

00:33:08,640 --> 00:33:12,080
sorry there should be a star it's a

00:33:10,000 --> 00:33:12,799
background slide because we should

00:33:12,080 --> 00:33:14,480
divide it

00:33:12,799 --> 00:33:16,159
and then it will be minus one here and

00:33:14,480 --> 00:33:18,480
this minus one will be speed

00:33:16,159 --> 00:33:19,840
but with multiply that it's not visible

00:33:18,480 --> 00:33:21,120
here there should be a multiply under

00:33:19,840 --> 00:33:24,320
the dot

00:33:21,120 --> 00:33:26,960
then uh you should see uh

00:33:24,320 --> 00:33:29,679
exactly this result so length multiplied

00:33:26,960 --> 00:33:31,600
by time so exponent one exponent one

00:33:29,679 --> 00:33:33,519
so library tells you explicitly that is

00:33:31,600 --> 00:33:36,159
an unknown dimension

00:33:33,519 --> 00:33:37,600
and it has unknown coherent unit for

00:33:36,159 --> 00:33:40,720
this unknown dimension

00:33:37,600 --> 00:33:45,519
and you end it trying to convert it

00:33:40,720 --> 00:33:45,519
to dimension speed in meters per second

00:33:45,919 --> 00:33:49,600
i would argue this is much better user

00:33:48,640 --> 00:33:53,440
experience

00:33:49,600 --> 00:33:55,120
for those error logs than in other

00:33:53,440 --> 00:33:56,960
solutions on the market that's what we

00:33:55,120 --> 00:33:59,200
scope for that's what we try to

00:33:56,960 --> 00:34:00,799
optimize for we are still trying to

00:33:59,200 --> 00:34:02,399
optimize it for we are

00:34:00,799 --> 00:34:04,799
considering maybe getting rid of the

00:34:02,399 --> 00:34:06,880
root of this exponent part here

00:34:04,799 --> 00:34:08,480
but it's not that easy there are always

00:34:06,880 --> 00:34:10,960
some some engineering trade-offs to be

00:34:08,480 --> 00:34:10,960
done here

00:34:15,359 --> 00:34:20,000
so as you can see the library preserves

00:34:18,000 --> 00:34:22,800
nicely

00:34:20,000 --> 00:34:24,399
from nicely named types by the user by

00:34:22,800 --> 00:34:26,240
not using aliases

00:34:24,399 --> 00:34:27,599
all other cases had those issues because

00:34:26,240 --> 00:34:28,399
they are using template aliases

00:34:27,599 --> 00:34:30,480
everywhere

00:34:28,399 --> 00:34:32,320
we are using strong types to define

00:34:30,480 --> 00:34:35,200
speed second

00:34:32,320 --> 00:34:36,800
length meter and so on not just template

00:34:35,200 --> 00:34:39,599
aliases which vanish during the

00:34:36,800 --> 00:34:39,599
compilation process

00:34:43,679 --> 00:34:48,159
another case is when you would like to

00:34:46,839 --> 00:34:52,159
assign an

00:34:48,159 --> 00:34:55,040
incorrect dimension to another dimension

00:34:52,159 --> 00:34:57,040
so for example here we want to create a

00:34:55,040 --> 00:35:00,400
quantity of acceleration

00:34:57,040 --> 00:35:04,160
a and we are basically in boost unit

00:35:00,400 --> 00:35:04,160
multiplying meters

00:35:04,640 --> 00:35:07,760
creating 100 meters and divided by

00:35:07,200 --> 00:35:09,680
seconds

00:35:07,760 --> 00:35:10,880
it should be second square not second so

00:35:09,680 --> 00:35:12,880
there is one

00:35:10,880 --> 00:35:14,000
multiplication missing here and that's

00:35:12,880 --> 00:35:16,640
why it's in correct

00:35:14,000 --> 00:35:18,720
calculation here right and this is an

00:35:16,640 --> 00:35:20,800
error lock

00:35:18,720 --> 00:35:23,440
error conversion from quantity units

00:35:20,800 --> 00:35:26,560
leaves 3.3.3.3.3 dots

00:35:23,440 --> 00:35:29,760
to non-scalar types 3.3.3.

00:35:26,560 --> 00:35:30,000
requested and again you know what's

00:35:29,760 --> 00:35:32,560
wrong

00:35:30,000 --> 00:35:32,560
here right

00:35:35,520 --> 00:35:39,680
initial class library we provided the

00:35:37,599 --> 00:35:41,680
same we want someone to have

00:35:39,680 --> 00:35:44,800
acceleration in meters per second

00:35:41,680 --> 00:35:48,880
squared and we again

00:35:44,800 --> 00:35:48,880
forgot to make square seconds here

00:35:49,359 --> 00:35:52,640
and you get an error that any

00:35:51,119 --> 00:35:55,839
instantiation

00:35:52,640 --> 00:35:59,200
of function convert with units ratio

00:35:55,839 --> 00:36:03,040
ratio ratio ratio ratio

00:35:59,200 --> 00:36:06,560
are required from another

00:36:03,040 --> 00:36:08,400
some type rate or type ratio ratio ratio

00:36:06,560 --> 00:36:09,680
static assertion failed units are not

00:36:08,400 --> 00:36:11,119
compatible

00:36:09,680 --> 00:36:12,800
but again it's really hard to find out

00:36:11,119 --> 00:36:16,000
what are the units here what was

00:36:12,800 --> 00:36:16,000
provided what was expected

00:36:17,760 --> 00:36:23,839
with the library we implemented

00:36:21,200 --> 00:36:24,560
we provided this acceleration expected

00:36:23,839 --> 00:36:26,960
in meter

00:36:24,560 --> 00:36:29,280
per second squared we provide the same

00:36:26,960 --> 00:36:31,440
wrong calculation here

00:36:29,280 --> 00:36:33,200
and there is information that error

00:36:31,440 --> 00:36:36,320
converted conversion from

00:36:33,200 --> 00:36:37,760
quantity of units physical si dimension

00:36:36,320 --> 00:36:41,760
speed

00:36:37,760 --> 00:36:44,560
to in in si meter per seconds

00:36:41,760 --> 00:36:47,280
to non-scalar type acceleration in meter

00:36:44,560 --> 00:36:47,280
per second square

00:36:47,760 --> 00:36:52,400
so as you can see the library took this

00:36:50,880 --> 00:36:55,760
length in meters

00:36:52,400 --> 00:36:57,440
this time in seconds and

00:36:55,760 --> 00:36:59,440
after the operation of the division on

00:36:57,440 --> 00:37:01,440
those it determined

00:36:59,440 --> 00:37:02,480
that it said dimension speed provided by

00:37:01,440 --> 00:37:05,200
the user

00:37:02,480 --> 00:37:06,640
as a strong type and the unit that's a

00:37:05,200 --> 00:37:09,359
result of this division

00:37:06,640 --> 00:37:10,640
is meter per second and it basically

00:37:09,359 --> 00:37:13,040
reconstructed

00:37:10,640 --> 00:37:14,640
the strong types provided by the user we

00:37:13,040 --> 00:37:16,160
call it the doncaster facility i was

00:37:14,640 --> 00:37:17,760
speaking about this on the previous talk

00:37:16,160 --> 00:37:18,160
on cppcon so if you're interested in

00:37:17,760 --> 00:37:20,839
this

00:37:18,160 --> 00:37:22,000
either see the talk or go to our

00:37:20,839 --> 00:37:23,920
documentation

00:37:22,000 --> 00:37:25,200
but with this the error look looks

00:37:23,920 --> 00:37:26,800
really nice

00:37:25,200 --> 00:37:28,880
right because we know the saturation we

00:37:26,800 --> 00:37:30,720
know this is speed library knows this is

00:37:28,880 --> 00:37:32,560
speed

00:37:30,720 --> 00:37:34,079
not an unknown dimension right unknown

00:37:32,560 --> 00:37:36,240
dimensions in previous case because it

00:37:34,079 --> 00:37:37,920
was something strange

00:37:36,240 --> 00:37:39,440
when something is correct then we have a

00:37:37,920 --> 00:37:42,320
correct unit here

00:37:39,440 --> 00:37:42,320
and correct dimension

00:37:46,480 --> 00:37:51,040
user experience is not only about error

00:37:48,240 --> 00:37:52,800
locks it's also about debugging

00:37:51,040 --> 00:37:54,960
so let's put a break point in our

00:37:52,800 --> 00:37:59,280
correct division operation here

00:37:54,960 --> 00:38:00,880
for boost units and get information that

00:37:59,280 --> 00:38:02,320
this is the generic function right this

00:38:00,880 --> 00:38:05,680
function that works with

00:38:02,320 --> 00:38:08,240
with any any dimension and and

00:38:05,680 --> 00:38:09,280
of length and the dimension of time and

00:38:08,240 --> 00:38:11,440
the units of those

00:38:09,280 --> 00:38:13,359
and returns as velocity based on the

00:38:11,440 --> 00:38:14,480
input dimensions right so just divide

00:38:13,359 --> 00:38:17,520
stuff

00:38:14,480 --> 00:38:20,800
kilometers per hours from kilometers per

00:38:17,520 --> 00:38:22,079
hour makes us the final velocity one

00:38:20,800 --> 00:38:23,359
division operation

00:38:22,079 --> 00:38:25,280
so we don't know exactly what are the

00:38:23,359 --> 00:38:26,960
types here it would like the compiler to

00:38:25,280 --> 00:38:28,880
tell us

00:38:26,960 --> 00:38:30,640
and this is what compiler tells us for

00:38:28,880 --> 00:38:32,320
boost units

00:38:30,640 --> 00:38:34,800
again we don't know exactly what was

00:38:32,320 --> 00:38:34,800
provided

00:38:35,280 --> 00:38:39,280
for nick holt house again we get a bunch

00:38:38,720 --> 00:38:42,079
of

00:38:39,280 --> 00:38:42,079
ratios on the list

00:38:44,079 --> 00:38:48,400
for our library we have information

00:38:46,880 --> 00:38:51,280
that's basically this is a break point

00:38:48,400 --> 00:38:54,320
in the function average speed

00:38:51,280 --> 00:38:55,520
that uh takes the first argument of

00:38:54,320 --> 00:38:58,160
dimensional length

00:38:55,520 --> 00:38:59,200
in kilometers and the second argument of

00:38:58,160 --> 00:39:02,320
dimension time

00:38:59,200 --> 00:39:02,960
in hours and now we know what we're

00:39:02,320 --> 00:39:05,200
working with

00:39:02,960 --> 00:39:05,200
right

00:39:06,400 --> 00:39:10,240
so again i argue this is a really good

00:39:09,119 --> 00:39:13,359
value added

00:39:10,240 --> 00:39:16,320
to this to this domain by my

00:39:13,359 --> 00:39:16,320
the solution that we used

00:39:21,440 --> 00:39:26,839
okay i don't see any questions from this

00:39:23,119 --> 00:39:29,839
chapter so let's continue to framework

00:39:26,839 --> 00:39:29,839
basics

00:39:31,680 --> 00:39:35,440
how do you feel about such an interface

00:39:36,079 --> 00:39:40,240
we have function full that takes void

00:39:38,640 --> 00:39:42,320
pointer

00:39:40,240 --> 00:39:44,960
of argument named t and the return is a

00:39:42,320 --> 00:39:44,960
void pointer

00:39:45,839 --> 00:39:49,280
this is something we are laughing at

00:39:47,520 --> 00:39:50,960
right this is something we know from c

00:39:49,280 --> 00:39:52,640
this is something that we say we are

00:39:50,960 --> 00:39:54,960
better because we have strong text in c

00:39:52,640 --> 00:39:56,640
plus plus

00:39:54,960 --> 00:39:59,119
right we don't do some such stupid

00:39:56,640 --> 00:40:00,960
problems we don't make

00:39:59,119 --> 00:40:02,880
problem problems with interfaces because

00:40:00,960 --> 00:40:04,400
we with strong types we are able to

00:40:02,880 --> 00:40:06,640
provide explicitly what we

00:40:04,400 --> 00:40:09,280
expect for this function to be provided

00:40:06,640 --> 00:40:12,720
and what it returns right

00:40:09,280 --> 00:40:15,599
so let's see what we do we are writing

00:40:12,720 --> 00:40:15,599
lambdas like this

00:40:16,960 --> 00:40:20,240
we are writing a function templates like

00:40:19,119 --> 00:40:22,480
this

00:40:20,240 --> 00:40:25,839
and actually use plus 20 generic

00:40:22,480 --> 00:40:25,839
functions we can type it this way

00:40:27,119 --> 00:40:34,720
we are writing classes like this

00:40:31,520 --> 00:40:35,760
how is it different in terms of the

00:40:34,720 --> 00:40:38,079
interface

00:40:35,760 --> 00:40:39,920
documentation interface specification

00:40:38,079 --> 00:40:42,240
then the c case

00:40:39,920 --> 00:40:43,599
of course from the runtime point of view

00:40:42,240 --> 00:40:45,520
it's totally different right

00:40:43,599 --> 00:40:46,800
this one will fail at runtime this one

00:40:45,520 --> 00:40:47,920
will find that compile time you provide

00:40:46,800 --> 00:40:49,680
something wrong

00:40:47,920 --> 00:40:51,200
but you'll know already that this error

00:40:49,680 --> 00:40:53,119
during compile time will be really long

00:40:51,200 --> 00:40:55,040
and hard to analyze

00:40:53,119 --> 00:40:57,359
and actually if you see something like

00:40:55,040 --> 00:40:59,520
this on cppreference.com

00:40:57,359 --> 00:41:00,960
or docsign or whatever other

00:40:59,520 --> 00:41:04,160
documentation tool

00:41:00,960 --> 00:41:06,319
as an api reference you will not

00:41:04,160 --> 00:41:08,880
know what is expected and what's being

00:41:06,319 --> 00:41:11,440
returned from this function

00:41:08,880 --> 00:41:13,280
that's why i claim that unconstrained

00:41:11,440 --> 00:41:15,760
template parameters are the void star of

00:41:13,280 --> 00:41:18,000
c plus plus

00:41:15,760 --> 00:41:21,839
and we should do better and we can use c

00:41:18,000 --> 00:41:21,839
plus 20 concepts

00:41:23,760 --> 00:41:27,359
so what are the basic concepts in the

00:41:25,200 --> 00:41:31,119
library

00:41:27,359 --> 00:41:33,040
the most basic concept is a unit

00:41:31,119 --> 00:41:35,920
everything depends on the unit as a

00:41:33,040 --> 00:41:38,480
building block of the library

00:41:35,920 --> 00:41:40,160
every unit of specific dimension is a

00:41:38,480 --> 00:41:43,280
scaled

00:41:40,160 --> 00:41:45,359
unit of of some reference unit so for

00:41:43,280 --> 00:41:48,560
example for for si system

00:41:45,359 --> 00:41:49,839
and system sprinted based on si like we

00:41:48,560 --> 00:41:52,000
have implementation of international

00:41:49,839 --> 00:41:54,560
system fps cgs and many others

00:41:52,000 --> 00:41:56,240
they still are based on sa units so they

00:41:54,560 --> 00:41:59,280
are convertible to say units

00:41:56,240 --> 00:42:00,640
they have the same reference unit so all

00:41:59,280 --> 00:42:04,079
of them are provided as

00:42:00,640 --> 00:42:07,280
ratios as some some scaled

00:42:04,079 --> 00:42:07,280
units of meter

00:42:07,520 --> 00:42:12,640
also as you can see every dimension here

00:42:10,319 --> 00:42:14,960
takes the unit

00:42:12,640 --> 00:42:15,760
as a so-called coherent unit coherent

00:42:14,960 --> 00:42:19,520
unit is a

00:42:15,760 --> 00:42:23,440
unit of of the dimension

00:42:19,520 --> 00:42:27,280
as specified without any prefixes so for

00:42:23,440 --> 00:42:29,280
for in si system velocity

00:42:27,280 --> 00:42:30,319
is specified in meters per second

00:42:29,280 --> 00:42:33,359
because the

00:42:30,319 --> 00:42:36,960
meter is a unit of length

00:42:33,359 --> 00:42:40,160
and time is a unit of seconds

00:42:36,960 --> 00:42:42,720
right for fps

00:42:40,160 --> 00:42:43,599
cgs and maybe other systems those will

00:42:42,720 --> 00:42:46,720
be different

00:42:43,599 --> 00:42:48,480
so this is system specific

00:42:46,720 --> 00:42:50,960
what is the current unit of specific

00:42:48,480 --> 00:42:50,960
dimension

00:42:52,560 --> 00:42:56,079
if you want to create a simple unit in

00:42:54,319 --> 00:42:58,640
our library so for example you want to

00:42:56,079 --> 00:43:02,319
extend the library with a simple unit

00:42:58,640 --> 00:43:05,839
you may create a named unit called meter

00:43:02,319 --> 00:43:06,480
we are using crtp a pattern here so crtp

00:43:05,839 --> 00:43:08,160
stands for

00:43:06,480 --> 00:43:10,240
curiosity occurring template parameter

00:43:08,160 --> 00:43:13,440
idiom

00:43:10,240 --> 00:43:15,280
and then next one is the symbol of this

00:43:13,440 --> 00:43:18,319
named unit

00:43:15,280 --> 00:43:20,079
and the prefix means that ssa prefix

00:43:18,319 --> 00:43:22,319
allowed to work with this unit so you

00:43:20,079 --> 00:43:23,280
can create kilometer from meter using si

00:43:22,319 --> 00:43:24,880
prefix

00:43:23,280 --> 00:43:26,880
and this is what we do here we take we

00:43:24,880 --> 00:43:29,440
want to create kilometer

00:43:26,880 --> 00:43:31,040
so we take prefix unit we provide crt

00:43:29,440 --> 00:43:34,240
again parameter here

00:43:31,040 --> 00:43:38,000
and then we say kilo meter kilo

00:43:34,240 --> 00:43:41,040
is the prefix of this prefix family

00:43:38,000 --> 00:43:42,800
for aside and then

00:43:41,040 --> 00:43:45,520
we provide the reference unit to be

00:43:42,800 --> 00:43:46,960
scaled so meter

00:43:45,520 --> 00:43:49,440
as you can see we are creating strong

00:43:46,960 --> 00:43:51,839
types here as an inheritance

00:43:49,440 --> 00:43:53,599
rather than using template aliases and

00:43:51,839 --> 00:43:56,480
that's why the types don't vanish during

00:43:53,599 --> 00:43:56,480
compilation process

00:43:58,000 --> 00:44:01,839
if you want to create something similar

00:43:59,280 --> 00:44:05,040
for time again you create a second

00:44:01,839 --> 00:44:07,760
we say that's an empty unit of symbol s

00:44:05,040 --> 00:44:08,720
with say prefix and then you can say

00:44:07,760 --> 00:44:12,240
that minute

00:44:08,720 --> 00:44:13,920
is the named scaled unit with the symbol

00:44:12,240 --> 00:44:15,119
mean

00:44:13,920 --> 00:44:17,200
there is no prefix there are no

00:44:15,119 --> 00:44:20,480
kilometers right or or centi

00:44:17,200 --> 00:44:23,520
minutes so there's no prefix for minutes

00:44:20,480 --> 00:44:26,800
it's ratio 60 of second

00:44:23,520 --> 00:44:26,800
so our reference unit

00:44:26,960 --> 00:44:30,720
our is again a name scale to unit of

00:44:30,000 --> 00:44:34,160
symbol

00:44:30,720 --> 00:44:36,319
h no prefix ratio 60 of minute

00:44:34,160 --> 00:44:38,400
notice that you can reference also other

00:44:36,319 --> 00:44:41,839
scale tunis not always the

00:44:38,400 --> 00:44:42,800
base reference unit directly so you can

00:44:41,839 --> 00:44:44,960
say

00:44:42,800 --> 00:44:46,000
that hour is 60 minutes and a minute is

00:44:44,960 --> 00:44:48,240
60 seconds

00:44:46,000 --> 00:44:49,440
and that is fine if you want to specify

00:44:48,240 --> 00:44:52,280
this this way

00:44:49,440 --> 00:44:53,440
of course you can also say that hour is

00:44:52,280 --> 00:44:55,599
00:44:53,440 --> 00:44:56,640
of seconds and it's also fine it's up to

00:44:55,599 --> 00:44:58,400
you to

00:44:56,640 --> 00:45:00,800
to decide how you want to specify your

00:44:58,400 --> 00:45:03,200
units

00:45:00,800 --> 00:45:04,240
for your unit of direct dimension direct

00:45:03,200 --> 00:45:06,880
quantity

00:45:04,240 --> 00:45:08,720
you specify meter per second we just say

00:45:06,880 --> 00:45:10,160
it's a unit meter per second we don't

00:45:08,720 --> 00:45:12,160
say anything about its ratio we don't

00:45:10,160 --> 00:45:13,760
say anything about its symbol

00:45:12,160 --> 00:45:15,680
because this symbol is being derived

00:45:13,760 --> 00:45:18,079
from the base unit

00:45:15,680 --> 00:45:19,119
right it will just take this m and s and

00:45:18,079 --> 00:45:22,480
will print it

00:45:19,119 --> 00:45:25,280
based on the recipe provided by the

00:45:22,480 --> 00:45:26,400
by the the dimension that says that

00:45:25,280 --> 00:45:30,640
basically

00:45:26,400 --> 00:45:32,000
velocity is length divided by speed

00:45:30,640 --> 00:45:34,319
and then you want to create kilometer

00:45:32,000 --> 00:45:35,280
per hour you can say that it's a deduced

00:45:34,319 --> 00:45:37,280
unit

00:45:35,280 --> 00:45:39,359
that used because it takes dimension

00:45:37,280 --> 00:45:41,760
speed that i will show you on the next

00:45:39,359 --> 00:45:44,319
slide how it's specified

00:45:41,760 --> 00:45:45,359
and based on the recipe and dimension

00:45:44,319 --> 00:45:47,839
speeds

00:45:45,359 --> 00:45:49,200
speed it applies kilometer for length

00:45:47,839 --> 00:45:51,760
hour for time

00:45:49,200 --> 00:45:53,920
and deduces what's the final ratio for

00:45:51,760 --> 00:45:55,680
kilometer per hour

00:45:53,920 --> 00:45:57,520
so you don't have to care about those

00:45:55,680 --> 00:46:00,000
ratios by yourself

00:45:57,520 --> 00:46:00,640
they will be just divided multiplied as

00:46:00,000 --> 00:46:02,240
needed

00:46:00,640 --> 00:46:04,640
and as provided in dimension speed

00:46:02,240 --> 00:46:06,079
recipe to just get the final ratio of

00:46:04,640 --> 00:46:09,280
kilometer per hour

00:46:06,079 --> 00:46:09,280
to meter per second

00:46:10,480 --> 00:46:13,599
so as i said unit is a building block

00:46:12,880 --> 00:46:16,640
that is

00:46:13,599 --> 00:46:18,480
basically uh every everything on of the

00:46:16,640 --> 00:46:21,599
library depends on

00:46:18,480 --> 00:46:21,599
then we have dimensions

00:46:21,839 --> 00:46:26,079
dimension matches a dimension of either

00:46:24,319 --> 00:46:27,839
a base or direct quantity right we have

00:46:26,079 --> 00:46:30,400
a base dimension here or the left in the

00:46:27,839 --> 00:46:32,160
right dimension

00:46:30,400 --> 00:46:33,920
basic measurement is instantiated with a

00:46:32,160 --> 00:46:35,440
unique symbol identifier

00:46:33,920 --> 00:46:37,920
for this base dimension and the base

00:46:35,440 --> 00:46:40,079
unit direct dimension

00:46:37,920 --> 00:46:41,920
has a list of exponents that can be

00:46:40,079 --> 00:46:43,200
either exponents of the base unit or

00:46:41,920 --> 00:46:45,440
other derived dimensions

00:46:43,200 --> 00:46:47,520
and it also takes a unit a current unit

00:46:45,440 --> 00:46:48,800
of direct dimension

00:46:47,520 --> 00:46:50,640
so for example you can specify that

00:46:48,800 --> 00:46:51,520
dimensional length is a base dimension

00:46:50,640 --> 00:46:55,280
with symbol

00:46:51,520 --> 00:46:57,520
l this is what iso specifies for al

00:46:55,280 --> 00:46:59,520
and the base unit of this length in si

00:46:57,520 --> 00:47:02,640
system is meter

00:46:59,520 --> 00:47:05,200
dimension time with symbol t and in si

00:47:02,640 --> 00:47:06,640
it will be second

00:47:05,200 --> 00:47:09,200
and then you can say the dimension speed

00:47:06,640 --> 00:47:11,920
is a direct dimension

00:47:09,200 --> 00:47:14,079
again crt parameter provided here with a

00:47:11,920 --> 00:47:15,440
current unit meter per second

00:47:14,079 --> 00:47:17,920
so the one provided on the previous

00:47:15,440 --> 00:47:19,040
slide and then we have exponent of

00:47:17,920 --> 00:47:21,680
dimension length one

00:47:19,040 --> 00:47:23,839
and exponent of dimension time minus one

00:47:21,680 --> 00:47:26,640
so this is the recipe to create

00:47:23,839 --> 00:47:27,599
our speed and this is how the kilometer

00:47:26,640 --> 00:47:30,000
per hour

00:47:27,599 --> 00:47:31,920
know knew that it has to divide the

00:47:30,000 --> 00:47:34,800
units provided for those

00:47:31,920 --> 00:47:34,800
on the previous slide

00:47:35,760 --> 00:47:40,960
then we have quantities quantity is a

00:47:38,559 --> 00:47:43,119
concrete amount of a unit

00:47:40,960 --> 00:47:46,400
for a specified dimension with a

00:47:43,119 --> 00:47:46,400
specific representation

00:47:47,839 --> 00:47:51,280
there are helpers provided like this

00:47:50,559 --> 00:47:52,800
length

00:47:51,280 --> 00:47:55,280
that's basically say that that is a

00:47:52,800 --> 00:47:56,720
quantity of dimensional length

00:47:55,280 --> 00:47:58,720
and you can just write unit and

00:47:56,720 --> 00:48:00,400
representation for it by default it's

00:47:58,720 --> 00:48:03,520
double

00:48:00,400 --> 00:48:06,319
and you can say s i length s i kilometer

00:48:03,520 --> 00:48:08,800
as a unit and representation type as an

00:48:06,319 --> 00:48:08,800
integer

00:48:11,200 --> 00:48:14,960
quantity point is an absolute quantity

00:48:13,520 --> 00:48:16,880
with respect to some origin

00:48:14,960 --> 00:48:18,800
so it's similar to time point that we

00:48:16,880 --> 00:48:20,800
have in clonal library

00:48:18,800 --> 00:48:23,119
it is created from another quantity

00:48:20,800 --> 00:48:23,119
value

00:48:24,880 --> 00:48:28,640
and concepts are really useful and they

00:48:26,640 --> 00:48:30,480
are used everywhere in our library

00:48:28,640 --> 00:48:32,880
we also have dimension specific concepts

00:48:30,480 --> 00:48:34,559
like speed saying that speed is quantity

00:48:32,880 --> 00:48:36,079
of dimension speed

00:48:34,559 --> 00:48:38,559
and what you're actually trying to do

00:48:36,079 --> 00:48:40,640
here is calculate fine for speeding

00:48:38,559 --> 00:48:44,000
we provide speed as an argument and the

00:48:40,640 --> 00:48:45,599
price as a return type

00:48:44,000 --> 00:48:48,079
so what is speed is the quantity of

00:48:45,599 --> 00:48:50,559
dimension speed

00:48:48,079 --> 00:48:51,760
what's quantity of quantity of is a

00:48:50,559 --> 00:48:54,800
quantity

00:48:51,760 --> 00:48:57,839
for t dimension for d and

00:48:54,800 --> 00:49:00,160
the dimension in t should be equivalent

00:48:57,839 --> 00:49:00,160
to d

00:49:01,200 --> 00:49:04,640
quantity right now it's a specialization

00:49:03,119 --> 00:49:06,079
of quantity but we are thinking about

00:49:04,640 --> 00:49:07,920
making this more generic

00:49:06,079 --> 00:49:10,079
for example to work with chrono duration

00:49:07,920 --> 00:49:10,079
too

00:49:10,240 --> 00:49:13,200
dimension is either base dimension or

00:49:12,000 --> 00:49:14,640
derived dimension as you've seen

00:49:13,200 --> 00:49:16,319
previously

00:49:14,640 --> 00:49:18,480
direct dimension is direct from

00:49:16,319 --> 00:49:21,359
specialization of direct dimension based

00:49:18,480 --> 00:49:24,960
class and base dimension is direct from

00:49:21,359 --> 00:49:26,720
precision of base dimension

00:49:24,960 --> 00:49:28,160
and with this everything works fine

00:49:26,720 --> 00:49:30,559
everything is strongly typed we know

00:49:28,160 --> 00:49:32,160
exactly what to provide to every

00:49:30,559 --> 00:49:34,640
bank in our framework and in user

00:49:32,160 --> 00:49:34,640
interface

00:49:40,000 --> 00:49:44,079
next point is to provide conversions

00:49:42,000 --> 00:49:45,440
between quantities

00:49:44,079 --> 00:49:47,839
for this we have quantity costs so

00:49:45,440 --> 00:49:50,160
similar to duration cost in chrono

00:49:47,839 --> 00:49:51,200
and we provide the destination quantity

00:49:50,160 --> 00:49:53,280
for the cast

00:49:51,200 --> 00:49:54,480
but what's different than chrono thanks

00:49:53,280 --> 00:49:56,240
to concepts

00:49:54,480 --> 00:49:58,240
we can specify quantity cost for

00:49:56,240 --> 00:50:00,800
dimension only for

00:49:58,240 --> 00:50:01,760
unit only or for representation only

00:50:00,800 --> 00:50:04,240
leaving all of the

00:50:01,760 --> 00:50:05,440
other parameters of the quantity intact

00:50:04,240 --> 00:50:06,720
so you don't have to provide all of the

00:50:05,440 --> 00:50:08,000
quantity all of the time if you want to

00:50:06,720 --> 00:50:13,839
change once one thing

00:50:08,000 --> 00:50:13,839
at the time

00:50:14,640 --> 00:50:17,920
i just see a question that does the

00:50:16,319 --> 00:50:19,680
library support no integral exponents

00:50:17,920 --> 00:50:21,680
for best units to make a direct unit

00:50:19,680 --> 00:50:23,440
yes it does support it so you can

00:50:21,680 --> 00:50:26,400
provide dimension

00:50:23,440 --> 00:50:26,960
you can provide the the length is one

00:50:26,400 --> 00:50:30,160
comma

00:50:26,960 --> 00:50:30,640
second comma two for example if you want

00:50:30,160 --> 00:50:33,119
to

00:50:30,640 --> 00:50:35,760
square root something if you square root

00:50:33,119 --> 00:50:38,640
the the dimension then you get the

00:50:35,760 --> 00:50:39,760
the non-integral exponents in the

00:50:38,640 --> 00:50:43,119
dimension

00:50:39,760 --> 00:50:44,720
it is supported i don't see the second

00:50:43,119 --> 00:50:47,839
question

00:50:44,720 --> 00:50:49,359
let's see how are operations like square

00:50:47,839 --> 00:50:50,559
root or cube root handled in the

00:50:49,359 --> 00:50:52,480
exponents

00:50:50,559 --> 00:50:54,160
exactly the same question as i said and

00:50:52,480 --> 00:50:54,720
those would be provided by no integral

00:50:54,160 --> 00:50:57,359
exponent

00:50:54,720 --> 00:50:57,359
parameters

00:50:58,559 --> 00:51:02,000
do the integral representation require

00:51:00,240 --> 00:51:05,040
the template types

00:51:02,000 --> 00:51:06,480
is five cube kilometer a double now a

00:51:05,040 --> 00:51:10,640
five q kilometer

00:51:06,480 --> 00:51:12,880
is right now an integer 64 t uh

00:51:10,640 --> 00:51:13,920
as it's compatible with with student

00:51:12,880 --> 00:51:15,440
duration

00:51:13,920 --> 00:51:17,280
but yeah we know that it might be a

00:51:15,440 --> 00:51:18,480
problem and we are considering making it

00:51:17,280 --> 00:51:20,480
double always

00:51:18,480 --> 00:51:22,880
or you just have to put five dot q

00:51:20,480 --> 00:51:25,280
kilometer to get to get a double

00:51:22,880 --> 00:51:27,520
in their presentation and at the head we

00:51:25,280 --> 00:51:29,520
are still working on something that's

00:51:27,520 --> 00:51:30,559
uh an alternative way to create to

00:51:29,520 --> 00:51:33,119
create units

00:51:30,559 --> 00:51:37,119
and quantities and but it's too early to

00:51:33,119 --> 00:51:38,800
talk about it

00:51:37,119 --> 00:51:39,680
and delivery appears to be benefit from

00:51:38,800 --> 00:51:41,040
concepts using a different

00:51:39,680 --> 00:51:44,079
capitalization scheme than

00:51:41,040 --> 00:51:47,280
types yes i've been

00:51:44,079 --> 00:51:49,839
i'm in the room in lwg when we discussed

00:51:47,280 --> 00:51:50,640
a standard case for concepts and this

00:51:49,839 --> 00:51:53,839
was

00:51:50,640 --> 00:51:56,319
really really bad for my library uh

00:51:53,839 --> 00:51:57,839
we have a thread on on the issues list

00:51:56,319 --> 00:52:00,880
in our github repository

00:51:57,839 --> 00:52:03,440
on moving to standard case for concepts

00:52:00,880 --> 00:52:04,720
but as it is it happens that it's not

00:52:03,440 --> 00:52:07,760
that easy

00:52:04,720 --> 00:52:08,640
because in some cases we have we want to

00:52:07,760 --> 00:52:10,800
have the type

00:52:08,640 --> 00:52:11,920
and the concept name the same like

00:52:10,800 --> 00:52:14,559
quantity and quantity

00:52:11,920 --> 00:52:15,920
ratio and the ratio and what to do in

00:52:14,559 --> 00:52:17,520
such a case we don't know

00:52:15,920 --> 00:52:19,440
yet we don't we cannot find a good name

00:52:17,520 --> 00:52:21,599
if you have a good solution good idea

00:52:19,440 --> 00:52:24,640
please go to our issues list

00:52:21,599 --> 00:52:25,680
and and help us i'm renaming those to

00:52:24,640 --> 00:52:27,200
standard case

00:52:25,680 --> 00:52:29,119
i know there will be very interesting

00:52:27,200 --> 00:52:30,079
discussion in lwg when we provide this

00:52:29,119 --> 00:52:33,839
paper

00:52:30,079 --> 00:52:33,839
about this

00:52:34,160 --> 00:52:40,880
our representation costs implicits uh

00:52:37,839 --> 00:52:42,319
representation costs uh implicit

00:52:40,880 --> 00:52:44,720
conversions for representations is being

00:52:42,319 --> 00:52:45,119
done in the same way as it being done in

00:52:44,720 --> 00:52:47,359
the

00:52:45,119 --> 00:52:48,480
chrono duration so you can always

00:52:47,359 --> 00:52:50,319
convert from

00:52:48,480 --> 00:52:51,920
integral representation to the double

00:52:50,319 --> 00:52:55,440
one but not from double to integral

00:52:51,920 --> 00:52:55,440
because it's truncating conversion

00:52:56,720 --> 00:53:00,319
okay and let's move on because we are

00:52:58,240 --> 00:53:01,440
tight on time and i don't want to go

00:53:00,319 --> 00:53:03,920
overtime but i

00:53:01,440 --> 00:53:06,400
i'm afraid i will go a bit so let's

00:53:03,920 --> 00:53:06,400
continue

00:53:06,880 --> 00:53:11,119
concepts are not just as impacting sugar

00:53:08,960 --> 00:53:13,440
over enable if or maybe some

00:53:11,119 --> 00:53:15,119
specializations of the of the type in

00:53:13,440 --> 00:53:16,720
function arguments

00:53:15,119 --> 00:53:18,720
for example you can with concepts you

00:53:16,720 --> 00:53:20,480
can easily constrain the function return

00:53:18,720 --> 00:53:22,000
type which is not easy to do with any

00:53:20,480 --> 00:53:23,760
other solutions we have in in the

00:53:22,000 --> 00:53:26,480
language

00:53:23,760 --> 00:53:28,480
you can easily constrain the user

00:53:26,480 --> 00:53:30,650
variable on the stack

00:53:28,480 --> 00:53:31,760
without any additional

00:53:30,650 --> 00:53:34,000
[Music]

00:53:31,760 --> 00:53:35,760
features with the language so you can't

00:53:34,000 --> 00:53:37,680
do this otherwise easily

00:53:35,760 --> 00:53:39,200
also you can constrain class template

00:53:37,680 --> 00:53:41,200
parameters easily

00:53:39,200 --> 00:53:42,640
without introducing additional

00:53:41,200 --> 00:53:43,599
parameters to the class template and

00:53:42,640 --> 00:53:44,960
having to provide partial

00:53:43,599 --> 00:53:48,480
specializations for some

00:53:44,960 --> 00:53:52,000
some specific uh

00:53:48,480 --> 00:53:54,720
spinner solutions here so this is

00:53:52,000 --> 00:53:56,400
way better than you working with with

00:53:54,720 --> 00:53:58,559
with spinner or way better than

00:53:56,400 --> 00:54:02,480
working with for example specializations

00:53:58,559 --> 00:54:02,480
of the types in function arguments here

00:54:03,280 --> 00:54:07,040
that's why we work with concepts and

00:54:05,119 --> 00:54:09,280
actually concepts also are much much

00:54:07,040 --> 00:54:12,960
faster in compile time than svena

00:54:09,280 --> 00:54:13,359
i measured it's way faster you can find

00:54:12,960 --> 00:54:16,720
the

00:54:13,359 --> 00:54:20,000
my my benchmark results on my talk

00:54:16,720 --> 00:54:20,000
during c plus person c

00:54:21,520 --> 00:54:25,119
benefits of music concepts can you state

00:54:23,839 --> 00:54:26,400
the design intent

00:54:25,119 --> 00:54:28,079
in the interface so if you see the

00:54:26,400 --> 00:54:29,520
documentation you know exactly what the

00:54:28,079 --> 00:54:32,160
author of the interface was meant

00:54:29,520 --> 00:54:33,599
what meant for this argument they

00:54:32,160 --> 00:54:35,280
embedded in template signature so

00:54:33,599 --> 00:54:38,720
present in documentation

00:54:35,280 --> 00:54:40,400
simplifying and extends fina so it's not

00:54:38,720 --> 00:54:41,760
only a belief not only voity

00:54:40,400 --> 00:54:44,640
but even in those cases it's much

00:54:41,760 --> 00:54:44,640
simpler and faster

00:54:45,040 --> 00:54:48,079
and greatly improved error messages

00:54:47,359 --> 00:54:49,920
because

00:54:48,079 --> 00:54:52,160
all of the all of their messages happen

00:54:49,920 --> 00:54:53,440
on the point of of usage of the function

00:54:52,160 --> 00:54:55,200
not deeply nested

00:54:53,440 --> 00:54:58,079
in the implementation error of specific

00:54:55,200 --> 00:54:58,079
function implementation

00:55:03,920 --> 00:55:09,040
another thing to discuss here is what

00:55:07,440 --> 00:55:11,359
would happen if unit was a constant

00:55:09,040 --> 00:55:13,359
because this was a common solution

00:55:11,359 --> 00:55:15,040
like 10 15 years ago for physical units

00:55:13,359 --> 00:55:17,040
libraries and that's actually brought

00:55:15,040 --> 00:55:19,440
even an icing lettuce committee lately

00:55:17,040 --> 00:55:21,359
that the unit should be should be

00:55:19,440 --> 00:55:24,319
constant rather than a type

00:55:21,359 --> 00:55:24,960
so let's say that meter is just one

00:55:24,319 --> 00:55:28,400
meter

00:55:24,960 --> 00:55:28,960
kilo is 1000 kilometer is 1000 meters

00:55:28,400 --> 00:55:32,839
right

00:55:28,960 --> 00:55:34,079
segment is one second hour is 3600

00:55:32,839 --> 00:55:35,599
seconds

00:55:34,079 --> 00:55:37,599
then you provide this to our average

00:55:35,599 --> 00:55:40,640
speed

00:55:37,599 --> 00:55:43,119
and then you get the result

00:55:40,640 --> 00:55:44,960
basically what it does it works always

00:55:43,119 --> 00:55:48,960
on the current units

00:55:44,960 --> 00:55:51,440
of the of the system so

00:55:48,960 --> 00:55:52,799
there are a lot of implicit conversions

00:55:51,440 --> 00:55:55,920
being done there are

00:55:52,799 --> 00:55:57,760
uh there's lots of precision being done

00:55:55,920 --> 00:55:58,640
there are some runtime performance that

00:55:57,760 --> 00:56:01,680
hits you

00:55:58,640 --> 00:56:02,400
because you are basically have doing all

00:56:01,680 --> 00:56:04,400
of those

00:56:02,400 --> 00:56:06,400
calculations and conversions at the

00:56:04,400 --> 00:56:09,280
runtime rather than remembering the time

00:56:06,400 --> 00:56:09,280
during compile time

00:56:11,839 --> 00:56:18,799
so we want to define units as types

00:56:16,319 --> 00:56:20,079
before super class 20 those definitions

00:56:18,799 --> 00:56:23,760
had to be done

00:56:20,079 --> 00:56:26,079
with a macros so

00:56:23,760 --> 00:56:27,280
for example this is an example of nick

00:56:26,079 --> 00:56:29,040
hold house

00:56:27,280 --> 00:56:30,559
this is the extension of this of this

00:56:29,040 --> 00:56:32,880
macro there are

00:56:30,559 --> 00:56:33,760
more macros here and each macro looks

00:56:32,880 --> 00:56:35,760
like this one

00:56:33,760 --> 00:56:37,280
providing many different instances of

00:56:35,760 --> 00:56:40,960
functions type trades and

00:56:37,280 --> 00:56:42,559
many other stuff to the library

00:56:40,960 --> 00:56:44,000
and they said in the requirements that

00:56:42,559 --> 00:56:45,280
you don't want to use macros and

00:56:44,000 --> 00:56:47,119
actually it's possible

00:56:45,280 --> 00:56:48,559
thanks to class types as multi-table

00:56:47,119 --> 00:56:49,119
parameters which is a new feature of

00:56:48,559 --> 00:56:52,880
class

00:56:49,119 --> 00:56:57,359
20. you can specify seconds minutes

00:56:52,880 --> 00:57:00,240
here and then provide the ratio

00:56:57,359 --> 00:57:01,520
and it works just fine we don't have we

00:57:00,240 --> 00:57:03,680
can provide all of the information

00:57:01,520 --> 00:57:07,680
needed for a unit in one definition in c

00:57:03,680 --> 00:57:07,680
plus without using any macros

00:57:08,000 --> 00:57:12,079
when you implement this this name you

00:57:09,760 --> 00:57:13,760
need there is a basic simple text which

00:57:12,079 --> 00:57:16,079
is entity parameter

00:57:13,760 --> 00:57:17,359
there's ratio one provided here

00:57:16,079 --> 00:57:19,280
implicitly

00:57:17,359 --> 00:57:20,960
this entity parameter you store this

00:57:19,280 --> 00:57:23,040
entity parameter inside the class as a

00:57:20,960 --> 00:57:26,079
static value

00:57:23,040 --> 00:57:26,720
when you do prefix t on it then you can

00:57:26,079 --> 00:57:28,799
easily

00:57:26,720 --> 00:57:30,640
multiply those entire parameters rather

00:57:28,799 --> 00:57:32,480
than using stood multi

00:57:30,640 --> 00:57:34,240
stood ratio multiply you can just

00:57:32,480 --> 00:57:34,640
multiply those because those are values

00:57:34,240 --> 00:57:36,960
not

00:57:34,640 --> 00:57:38,400
not types and you can easily merge

00:57:36,960 --> 00:57:40,400
symbols of the text

00:57:38,400 --> 00:57:44,079
for prefix and the unit because those

00:57:40,400 --> 00:57:44,079
are again values not types

00:57:48,400 --> 00:57:51,359
it turns out that it's something

00:57:49,520 --> 00:57:54,720
simplified a lot in our library for

00:57:51,359 --> 00:57:56,880
example when you wanted to create some

00:57:54,720 --> 00:57:58,319
base unit ratio for all of the exponents

00:57:56,880 --> 00:58:00,480
on the list we had to

00:57:58,319 --> 00:58:01,760
before we had to do some some

00:58:00,480 --> 00:58:05,680
traditional approach with

00:58:01,760 --> 00:58:07,280
those uh recursive template

00:58:05,680 --> 00:58:08,160
instantiations it's not recruiting but

00:58:07,280 --> 00:58:09,920
basically you

00:58:08,160 --> 00:58:11,839
truncate the list we get one and then

00:58:09,920 --> 00:58:14,480
calculate

00:58:11,839 --> 00:58:16,319
with using values we are able to just

00:58:14,480 --> 00:58:17,920
use fold expressions here

00:58:16,319 --> 00:58:23,839
which is much faster to compile much

00:58:17,920 --> 00:58:23,839
easier to maintain much easier to write

00:58:24,480 --> 00:58:28,160
i would argue that class types has not

00:58:26,000 --> 00:58:29,839
typed the parameters is probably one of

00:58:28,160 --> 00:58:31,200
the most significant improvements in the

00:58:29,839 --> 00:58:32,720
telepathic programming in the last

00:58:31,200 --> 00:58:34,880
decade

00:58:32,720 --> 00:58:37,359
if something behaves like a value it

00:58:34,880 --> 00:58:40,559
probably should be an nttp

00:58:37,359 --> 00:58:42,079
please think about it in your code to

00:58:40,559 --> 00:58:42,880
implement nttp i will not go into

00:58:42,079 --> 00:58:44,799
details here

00:58:42,880 --> 00:58:46,559
you have to make members public because

00:58:44,799 --> 00:58:48,240
those have to be structural types and

00:58:46,559 --> 00:58:50,079
structural types requirements require

00:58:48,240 --> 00:58:51,760
you to have public

00:58:50,079 --> 00:58:53,680
public members something similar to

00:58:51,760 --> 00:58:55,680
aggregates

00:58:53,680 --> 00:58:57,680
for basic string fixed string it's the

00:58:55,680 --> 00:58:58,079
interface that is typical to this to the

00:58:57,680 --> 00:59:00,400
string

00:58:58,079 --> 00:59:02,240
there are iterators constructors size

00:59:00,400 --> 00:59:06,720
history index operator

00:59:02,240 --> 00:59:06,720
iterators some operator plus

00:59:06,880 --> 00:59:11,359
and operator equals equals and starship

00:59:09,760 --> 00:59:13,119
operator which is one more

00:59:11,359 --> 00:59:14,880
feature of superplus 20 that i really

00:59:13,119 --> 00:59:16,880
love and it helps a lot in writing the

00:59:14,880 --> 00:59:22,160
library

00:59:16,880 --> 00:59:22,160
it just makes a lot of code to disappear

00:59:27,680 --> 00:59:31,599
talking about cpr 20 we support text

00:59:30,720 --> 00:59:33,599
output

00:59:31,599 --> 00:59:35,280
we can output by streams as you've seen

00:59:33,599 --> 00:59:37,119
already we can provide any quantity to

00:59:35,280 --> 00:59:39,599
stream and it will print correctly

00:59:37,119 --> 00:59:40,160
value and then the unit but we can also

00:59:39,599 --> 00:59:43,440
use

00:59:40,160 --> 00:59:46,160
this fmt format right now we are using

00:59:43,440 --> 00:59:47,440
the victor's library and waiting for the

00:59:46,160 --> 00:59:50,000
first implementation to come

00:59:47,440 --> 00:59:50,880
in the titles compiler so you can

00:59:50,000 --> 00:59:53,440
provide

00:59:50,880 --> 00:59:53,920
any format for the library you can print

00:59:53,440 --> 00:59:56,720
only

00:59:53,920 --> 00:59:57,280
values or only units or specify what's

00:59:56,720 --> 00:59:59,680
the

00:59:57,280 --> 01:00:01,920
separation between those and have it

00:59:59,680 --> 01:00:04,799
printed

01:00:01,920 --> 01:00:05,520
by default we support unicode but with

01:00:04,799 --> 01:00:07,920
the a

01:00:05,520 --> 01:00:09,680
modifier here you can specify that it

01:00:07,920 --> 01:00:09,920
should be ascii only output and then you

01:00:09,680 --> 01:00:14,079
will

01:00:09,920 --> 01:00:17,359
you'll get um micro u second square and

01:00:14,079 --> 01:00:17,359
an ascii representation of it

01:00:21,359 --> 01:00:24,960
we also cooperate with linear g black

01:00:24,319 --> 01:00:28,000
guys

01:00:24,960 --> 01:00:29,839
that are providing b 13 85

01:00:28,000 --> 01:00:32,160
paper and it's going probably to be

01:00:29,839 --> 01:00:33,760
standardized for cpr 23

01:00:32,160 --> 01:00:36,319
so you can create linear algebra of

01:00:33,760 --> 01:00:36,319
quantities

01:00:36,880 --> 01:00:43,280
i provide operations on those and get

01:00:40,160 --> 01:00:45,040
expected result

01:00:43,280 --> 01:00:46,640
you can also create quantities of linear

01:00:45,040 --> 01:00:48,960
algebra so

01:00:46,640 --> 01:00:50,640
reverse dependency now we're creating a

01:00:48,960 --> 01:00:53,520
length of a vector

01:00:50,640 --> 01:00:55,040
vector is a representation type here and

01:00:53,520 --> 01:00:58,240
again doing the operations

01:00:55,040 --> 01:00:58,720
and output this time all of this is

01:00:58,240 --> 01:01:00,799
meter

01:00:58,720 --> 01:01:02,960
rather than in previous case meters

01:01:00,799 --> 01:01:06,319
everyone everywhere in the

01:01:02,960 --> 01:01:06,319
in the vector or matrix

01:01:08,160 --> 01:01:11,839
just after sorry for being a bit

01:01:10,000 --> 01:01:15,440
overtime we had many questions

01:01:11,839 --> 01:01:17,760
and and yeah i will finish in three

01:01:15,440 --> 01:01:20,799
minutes

01:01:17,760 --> 01:01:22,640
environment compatibility next steps

01:01:20,799 --> 01:01:23,920
here the list of is the list of features

01:01:22,640 --> 01:01:24,960
that we are currently using in the

01:01:23,920 --> 01:01:27,280
library

01:01:24,960 --> 01:01:29,119
concepts class entities consistent and

01:01:27,280 --> 01:01:30,079
defaulted comparison explicit of bull

01:01:29,119 --> 01:01:32,319
down of type name

01:01:30,079 --> 01:01:34,160
lambdas in universe context immediate

01:01:32,319 --> 01:01:36,240
functions actually we plan to use

01:01:34,160 --> 01:01:38,000
soon and we are waiting for good modus

01:01:36,240 --> 01:01:39,599
implementations that we would

01:01:38,000 --> 01:01:41,599
work work with because it's really

01:01:39,599 --> 01:01:43,520
needed to provide si

01:01:41,599 --> 01:01:44,880
implementation for all the system at

01:01:43,520 --> 01:01:48,000
once for our case

01:01:44,880 --> 01:01:50,960
in with modules from library

01:01:48,000 --> 01:01:52,319
we are using context algorithms a lot i

01:01:50,960 --> 01:01:56,960
concepts library

01:01:52,319 --> 01:01:58,319
of course and and fmt

01:01:56,960 --> 01:02:01,200
which basically provides all of the

01:01:58,319 --> 01:02:01,200
formatting facility

01:02:01,520 --> 01:02:07,760
compiler support we use supported gc93

01:02:05,440 --> 01:02:09,520
until zero six zero in zero six zero

01:02:07,760 --> 01:02:11,359
that was released two days ago

01:02:09,520 --> 01:02:14,400
actually we had to drop it because of

01:02:11,359 --> 01:02:16,319
some um

01:02:14,400 --> 01:02:17,760
problems with it bugs and and the lack

01:02:16,319 --> 01:02:19,599
of features so

01:02:17,760 --> 01:02:20,880
right now libra is compatible with gcc

01:02:19,599 --> 01:02:24,319
10 plus

01:02:20,880 --> 01:02:26,880
and with the latest visual studio 16.7

01:02:24,319 --> 01:02:28,400
with a few exceptions

01:02:26,880 --> 01:02:31,119
the exceptions are that visual studio

01:02:28,400 --> 01:02:35,839
still does not support this nice

01:02:31,119 --> 01:02:37,359
tears constrain icon concept syntax

01:02:35,839 --> 01:02:40,880
you have to type something like this and

01:02:37,359 --> 01:02:44,640
then it works fine for viral studio

01:02:40,880 --> 01:02:44,640
we are still waiting for clank to catch

01:02:46,839 --> 01:02:49,839
up

01:02:52,079 --> 01:02:55,280
as i said there are plans for it to be

01:02:53,839 --> 01:02:58,079
standardized if the

01:02:55,280 --> 01:02:58,480
committee will decide that it's no then

01:02:58,079 --> 01:03:01,200
no

01:02:58,480 --> 01:03:02,000
will not force everyone to to

01:03:01,200 --> 01:03:04,240
standardize it

01:03:02,000 --> 01:03:06,000
uh there will be just the library on the

01:03:04,240 --> 01:03:07,520
github but anyway i

01:03:06,000 --> 01:03:09,920
recommend you trying it and provide the

01:03:07,520 --> 01:03:11,359
feedback uh we already

01:03:09,920 --> 01:03:13,039
dedicated a lot of hours in the

01:03:11,359 --> 01:03:14,960
committee about discussions it seems

01:03:13,039 --> 01:03:16,480
that there is a lot of interest in the

01:03:14,960 --> 01:03:19,760
committee and in the industry

01:03:16,480 --> 01:03:20,079
to get it standardized we for for now

01:03:19,760 --> 01:03:22,720
the

01:03:20,079 --> 01:03:24,559
feedback is really positive but actually

01:03:22,720 --> 01:03:26,160
we don't have it too much

01:03:24,559 --> 01:03:28,160
we need more field experience and

01:03:26,160 --> 01:03:29,839
feedback from people

01:03:28,160 --> 01:03:31,119
and getting to surprise 23 might be

01:03:29,839 --> 01:03:32,319
challenging because of it because we

01:03:31,119 --> 01:03:34,799
lack feedback

01:03:32,319 --> 01:03:35,599
for now also schedule is really tight we

01:03:34,799 --> 01:03:37,119
already lost

01:03:35,599 --> 01:03:39,200
like at least three meetings

01:03:37,119 --> 01:03:40,720
face-to-face meetings and we don't know

01:03:39,200 --> 01:03:45,839
what is the future

01:03:40,720 --> 01:03:45,839
and so the copy doesn't help here too

01:03:45,920 --> 01:03:49,599
and first of all we want to ensure that

01:03:47,520 --> 01:03:51,440
library is ready before we start the

01:03:49,599 --> 01:03:53,760
process of standardization

01:03:51,440 --> 01:03:54,960
and to make sure about that it's ready

01:03:53,760 --> 01:03:57,520
we really

01:03:54,960 --> 01:03:58,400
need feedback from you guys if it's if

01:03:57,520 --> 01:03:59,920
it's

01:03:58,400 --> 01:04:01,440
working for you or not if there are any

01:03:59,920 --> 01:04:05,119
requirements not covered

01:04:01,440 --> 01:04:06,480
or everything is fine so please try and

01:04:05,119 --> 01:04:08,319
tell us about your experience and

01:04:06,480 --> 01:04:09,440
requirements for companies

01:04:08,319 --> 01:04:11,920
please provide your feedback from

01:04:09,440 --> 01:04:13,440
production or maybe proof concept use

01:04:11,920 --> 01:04:14,640
and requirements you have for such a

01:04:13,440 --> 01:04:16,319
library

01:04:14,640 --> 01:04:17,920
for authors of other libraries

01:04:16,319 --> 01:04:20,319
implementation experience and production

01:04:17,920 --> 01:04:20,319
feedback

01:04:20,480 --> 01:04:25,039
github issues are not only to complain

01:04:22,559 --> 01:04:26,480
about something not working right right

01:04:25,039 --> 01:04:28,240
if you are happy with library please

01:04:26,480 --> 01:04:30,160
provide it too there

01:04:28,240 --> 01:04:31,920
say we are using this in the production

01:04:30,160 --> 01:04:33,359
it it works really well for us because

01:04:31,920 --> 01:04:34,880
this is a sign for us that is that's

01:04:33,359 --> 01:04:36,559
actually the slipper is actually being

01:04:34,880 --> 01:04:39,119
used and it proves to be correct

01:04:36,559 --> 01:04:42,799
and fine for your use cases it's really

01:04:39,119 --> 01:04:42,799
important for us to have such feedback

01:04:43,119 --> 01:04:48,160
so please go to our issues list you'll

01:04:46,319 --> 01:04:51,520
find a lot of discussions

01:04:48,160 --> 01:04:55,839
and next steps feedback and everything

01:04:51,520 --> 01:04:55,839
there it's not just to raise problems

01:04:57,680 --> 01:05:01,680
last part i would like to say thank you

01:04:59,680 --> 01:05:03,599
for everyone it's not just me

01:05:01,680 --> 01:05:05,520
this is a work of many many people so

01:05:03,599 --> 01:05:07,920
far i would like to

01:05:05,520 --> 01:05:09,200
thank you say thank you to every author

01:05:07,920 --> 01:05:12,160
of every librarian on

01:05:09,200 --> 01:05:13,920
the internet especially to stephen

01:05:12,160 --> 01:05:14,480
watanabe and christian schabel for boost

01:05:13,920 --> 01:05:16,559
units

01:05:14,480 --> 01:05:18,079
for nick hold house that basically was

01:05:16,559 --> 01:05:19,599
an inspiration for this library to

01:05:18,079 --> 01:05:21,599
provide some interfaces

01:05:19,599 --> 01:05:23,200
martin manor young center for their

01:05:21,599 --> 01:05:26,319
libraries which are really great and

01:05:23,200 --> 01:05:26,319
other authors too

01:05:27,280 --> 01:05:30,880
superclass physical units library is not

01:05:29,760 --> 01:05:32,559
it's nothing new

01:05:30,880 --> 01:05:34,480
we are working on this for many years we

01:05:32,559 --> 01:05:35,599
know how to do it properly we have

01:05:34,480 --> 01:05:36,960
working experience and production

01:05:35,599 --> 01:05:38,640
experience with it we just want to

01:05:36,960 --> 01:05:41,280
standardize the best modern interface

01:05:38,640 --> 01:05:41,280
for it right now

01:05:41,359 --> 01:05:44,559
i would like to thank you to my

01:05:42,319 --> 01:05:46,319
contributors that helped me a lot

01:05:44,559 --> 01:05:47,920
while writing the code helping me with

01:05:46,319 --> 01:05:49,359
the documentation we were writing first

01:05:47,920 --> 01:05:51,760
iso papers about it

01:05:49,359 --> 01:05:55,039
or just participating in the discussions

01:05:51,760 --> 01:05:55,039
and providing requirements

01:05:55,920 --> 01:05:59,200
contribution as i said is not only about

01:05:57,599 --> 01:05:59,920
developing code it's also about

01:05:59,200 --> 01:06:05,760
providing

01:05:59,920 --> 01:06:08,400
feedback sharing ideas and so on

01:06:05,760 --> 01:06:10,160
and special thanks to walter brown

01:06:08,400 --> 01:06:12,240
walter started to talk about

01:06:10,160 --> 01:06:13,200
about this about standardizing physical

01:06:12,240 --> 01:06:15,839
units

01:06:13,200 --> 01:06:17,119
many years ago here is a paper from 98

01:06:15,839 --> 01:06:19,280
from the conference

01:06:17,119 --> 01:06:21,920
when he's talking about si library for

01:06:19,280 --> 01:06:24,880
unit-based computation

01:06:21,920 --> 01:06:25,760
we may not agree further on many or some

01:06:24,880 --> 01:06:27,280
cases

01:06:25,760 --> 01:06:28,799
but the feedback from mortar is really

01:06:27,280 --> 01:06:31,039
appreciated and i really value his

01:06:28,799 --> 01:06:33,280
feedback here and help

01:06:31,039 --> 01:06:36,160
i would also say thank you to howard

01:06:33,280 --> 01:06:38,720
hinand for his chronological library

01:06:36,160 --> 01:06:40,240
those are awesome i really learned a lot

01:06:38,720 --> 01:06:41,520
from them and took a lot of inspiration

01:06:40,240 --> 01:06:43,680
for this library

01:06:41,520 --> 01:06:45,680
and last but not least i would like to

01:06:43,680 --> 01:06:49,119
thank jc developers

01:06:45,680 --> 01:06:50,720
that make basically gcc happen that made

01:06:49,119 --> 01:06:52,559
concepts ts as the only compiler

01:06:50,720 --> 01:06:54,880
supporting it in gc7 so

01:06:52,559 --> 01:06:57,119
three years ago and you could start

01:06:54,880 --> 01:06:59,119
writing our implementation with gcc 7

01:06:57,119 --> 01:07:02,720
and concept cs thanks to them

01:06:59,119 --> 01:07:02,720
thank you guys you are doing a great job

01:07:04,720 --> 01:07:07,839
last if you are interested about

01:07:06,559 --> 01:07:10,400
concepts want to learn more

01:07:07,839 --> 01:07:11,200
from my experience please join the

01:07:10,400 --> 01:07:14,559
concepts class

01:07:11,200 --> 01:07:17,839
after on monday

01:07:14,559 --> 01:07:19,760
and and that's all with this

01:07:17,839 --> 01:07:21,920
thank you very much guys uh there will

01:07:19,760 --> 01:07:25,039
be ams session right away in this room

01:07:21,920 --> 01:07:25,839
so we can discuss stuff after that and

01:07:25,039 --> 01:07:43,839
and

01:07:25,839 --> 01:07:43,839
thank you for being here and stay safe

01:07:49,520 --> 01:07:51,599

YouTube URL: https://www.youtube.com/watch?v=7dExYGSOJzo


