Title: Dealing with Embedded Limitations - Panel Discussion hosted by Ben Saks - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020 Day 2
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Many embedded systems have requirements on latency, memory usage, and resource consumption. This is especially true of safety-critical and security-related systems. Many programmers and organizations worry that using C++ features will prevent them from meeting these requirements. Some avoid using specific features such as exception handling, while others avoid using C++ entirely.

This panel will discuss the challenges and benefits of using C++ in embedded contexts. We will explore ways that embedded systems can leverage the power of Modern C++ features to meet their guarantees. We will discuss which concerns are based in fact and which concerns are based on misconceptions.
Feel free to bring your own questions about anything that you believe inhibits your use of modern C++ on an embedded system. We will discuss pre-selected questions as well as audience submissions.

---
Ben Saks
Chief Engineer, Saks & Associates

Michael Caisse
Ciere Consulting

Inbal Levi
Software Engineer, SolarEdge

Daniel Papke
Software Engineer, Collins Aerospace

Brett Searles
Principal Architect, Attobotics

Michael Wong
DE, Codeplay
---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,360 --> 00:00:12,799
okay

00:00:10,160 --> 00:00:13,840
hello everyone uh welcome to our

00:00:12,799 --> 00:00:16,960
embedded panel

00:00:13,840 --> 00:00:20,640
on dealing with embedded limitations

00:00:16,960 --> 00:00:23,199
uh some of the things that we regularly

00:00:20,640 --> 00:00:31,840
deal with when we're writing

00:00:23,199 --> 00:00:31,840
uh embedded systems

00:00:36,239 --> 00:00:43,200
let's try that um okay

00:00:39,840 --> 00:00:43,200
uh the

00:00:43,360 --> 00:00:48,320
uh so welcome again to the uh

00:00:46,960 --> 00:00:51,360
our panel on dealing with embedded

00:00:48,320 --> 00:00:53,120
limitations uh

00:00:51,360 --> 00:00:54,480
dealing with some of the issues that

00:00:53,120 --> 00:00:57,840
embedded developers often

00:00:54,480 --> 00:01:01,199
face in terms of

00:00:57,840 --> 00:01:03,039
on memory usage with uh

00:01:01,199 --> 00:01:05,040
difficulties using certain c plus plus

00:01:03,039 --> 00:01:07,280
features things like that

00:01:05,040 --> 00:01:08,479
uh i'm ben sacks for those of you who

00:01:07,280 --> 00:01:11,280
don't know me

00:01:08,479 --> 00:01:12,640
uh my company saxon associates does

00:01:11,280 --> 00:01:15,200
training for

00:01:12,640 --> 00:01:16,320
uh companies all over the companies all

00:01:15,200 --> 00:01:19,840
over the world in both c

00:01:16,320 --> 00:01:22,960
and c plus plus uh before this i

00:01:19,840 --> 00:01:25,600
worked for about a dozen years as an

00:01:22,960 --> 00:01:28,560
embedded developer on devices

00:01:25,600 --> 00:01:28,960
that monitored production line output

00:01:28,560 --> 00:01:30,880
and

00:01:28,960 --> 00:01:32,400
gathered statistical information based

00:01:30,880 --> 00:01:35,280
on that

00:01:32,400 --> 00:01:37,040
uh okay why don't we all go around and

00:01:35,280 --> 00:01:40,400
introduce ourselves

00:01:37,040 --> 00:01:44,399
um brett you want to start off sure

00:01:40,400 --> 00:01:47,680
my name is brett searles i work for

00:01:44,399 --> 00:01:49,759
a company called xkl that's my main

00:01:47,680 --> 00:01:50,479
employer but i'm also to have another

00:01:49,759 --> 00:01:53,759
company called

00:01:50,479 --> 00:01:57,439
adobotix xkl works in

00:01:53,759 --> 00:01:58,320
optical routers and antibiotics works in

00:01:57,439 --> 00:02:01,280
higher

00:01:58,320 --> 00:02:03,119
in holographics so some correlation

00:02:01,280 --> 00:02:06,399
between data there

00:02:03,119 --> 00:02:08,959
i've been in embedded for over 20 years

00:02:06,399 --> 00:02:11,440
and i'm looking forward to this

00:02:08,959 --> 00:02:11,440
discussion

00:02:19,360 --> 00:02:23,280
i guess we can go to daniel yeah i'm

00:02:22,319 --> 00:02:26,480
daniel papke

00:02:23,280 --> 00:02:29,599
i work at collins aerospace uh which is

00:02:26,480 --> 00:02:33,200
a subsection of raytheon technologies

00:02:29,599 --> 00:02:34,879
i've worked in embedded area for about

00:02:33,200 --> 00:02:37,920
11 years

00:02:34,879 --> 00:02:39,200
everything from radios to unmanned

00:02:37,920 --> 00:02:41,840
systems

00:02:39,200 --> 00:02:43,920
and uh i suppose my interests are mostly

00:02:41,840 --> 00:02:45,519
in finding ways to

00:02:43,920 --> 00:02:50,879
do things the best we can given the

00:02:45,519 --> 00:02:53,680
tools and constraints that we have

00:02:50,879 --> 00:02:55,440
i'm michael case and um i've been

00:02:53,680 --> 00:02:56,879
working in embedded systems for a little

00:02:55,440 --> 00:02:59,280
over 30 years

00:02:56,879 --> 00:03:00,400
um a variety of different things from

00:02:59,280 --> 00:03:03,440
fda and

00:03:00,400 --> 00:03:05,519
faa certified devices to scientific

00:03:03,440 --> 00:03:08,800
equipment and consumer products

00:03:05,519 --> 00:03:10,959
um deal with bare metal to

00:03:08,800 --> 00:03:12,319
bare metal with fpga and other types of

00:03:10,959 --> 00:03:13,920
boards to

00:03:12,319 --> 00:03:15,360
things running off the shelf and custom

00:03:13,920 --> 00:03:18,560
art tosses

00:03:15,360 --> 00:03:20,319
in addition to the contracting

00:03:18,560 --> 00:03:21,519
consulting work that we do at kiara for

00:03:20,319 --> 00:03:25,040
things like this

00:03:21,519 --> 00:03:26,959
we also um or i also teach um

00:03:25,040 --> 00:03:33,840
c plus plus bonder c plus plus classes

00:03:26,959 --> 00:03:33,840
for embedded systems

00:03:41,599 --> 00:03:45,840
my name is mike cowons i'm a

00:03:44,080 --> 00:03:48,000
distinguished engineer at codeplay we're

00:03:45,840 --> 00:03:50,400
a company that that works in um

00:03:48,000 --> 00:03:52,159
in high performance computing as well as

00:03:50,400 --> 00:03:53,599
autonomous vehicles so as such

00:03:52,159 --> 00:03:55,120
i've been deeply being involved with

00:03:53,599 --> 00:03:55,680
various forms of programming models

00:03:55,120 --> 00:03:58,879
research

00:03:55,680 --> 00:04:00,080
involving ai and machine learning and

00:03:58,879 --> 00:04:01,760
because these days um

00:04:00,080 --> 00:04:03,120
autonomous vehicles use embedded

00:04:01,760 --> 00:04:04,239
computing that is very much like a

00:04:03,120 --> 00:04:05,760
supercomputer

00:04:04,239 --> 00:04:07,439
so that's why i've been involved in

00:04:05,760 --> 00:04:09,920
things like sg14 i chair

00:04:07,439 --> 00:04:11,360
sg14 for cpa spots which has the

00:04:09,920 --> 00:04:13,519
embedded components in it

00:04:11,360 --> 00:04:15,360
sg19 for machine learning i'm also the

00:04:13,519 --> 00:04:18,799
chair of the directions group

00:04:15,360 --> 00:04:20,400
um and because of the adav stuff i'm

00:04:18,799 --> 00:04:20,959
also deeply interested in safety

00:04:20,400 --> 00:04:24,160
critical

00:04:20,959 --> 00:04:28,160
thank you hello

00:04:24,160 --> 00:04:31,600
everyone sure my name is imbal

00:04:28,160 --> 00:04:33,840
levy i used to work on voip systems and

00:04:31,600 --> 00:04:34,960
i'm currently working on storage we're

00:04:33,840 --> 00:04:37,520
doing

00:04:34,960 --> 00:04:39,840
smart horn management basically doing

00:04:37,520 --> 00:04:42,000
inverters for solar energy but

00:04:39,840 --> 00:04:43,680
i'm specifically on the field of smart

00:04:42,000 --> 00:04:46,400
home management

00:04:43,680 --> 00:04:48,000
and i'm very excited to be here i think

00:04:46,400 --> 00:04:50,320
this is a very important panel

00:04:48,000 --> 00:04:51,600
and it also represents the general

00:04:50,320 --> 00:04:54,639
direction

00:04:51,600 --> 00:04:55,360
of of c plus plus forwards embedded

00:04:54,639 --> 00:04:58,140
systems

00:04:55,360 --> 00:05:01,339
so i'm glad this is happening

00:04:58,140 --> 00:05:01,339
[Music]

00:05:09,120 --> 00:05:13,759
can we um if ben are you me um

00:05:14,400 --> 00:05:20,479
sorry i i was uh i was having

00:05:17,759 --> 00:05:21,360
i believe that uh having both remo and

00:05:20,479 --> 00:05:23,600
this open

00:05:21,360 --> 00:05:24,479
uh were was causing me a little bit of

00:05:23,600 --> 00:05:27,360
lag

00:05:24,479 --> 00:05:29,280
so uh hopefully that will be that's

00:05:27,360 --> 00:05:32,479
resolved now

00:05:29,280 --> 00:05:35,680
um but if not uh we will

00:05:32,479 --> 00:05:36,800
yeah it's a new experience for all of us

00:05:35,680 --> 00:05:38,800
trying to

00:05:36,800 --> 00:05:40,800
uh you know conducting conferences like

00:05:38,800 --> 00:05:42,960
this so

00:05:40,800 --> 00:05:44,800
we'll deal with it as best we can yeah

00:05:42,960 --> 00:05:47,600
just like the brady bunch we just gotta

00:05:44,800 --> 00:05:47,600
look at each other

00:05:47,759 --> 00:05:51,199
so yeah daniel uh it was your question

00:05:50,639 --> 00:05:55,280
on

00:05:51,199 --> 00:05:57,840
the embedded channel in in slack

00:05:55,280 --> 00:05:59,360
that originally led us to start talking

00:05:57,840 --> 00:06:00,960
about the things that motivated this

00:05:59,360 --> 00:06:03,280
panel so do you want to

00:06:00,960 --> 00:06:04,639
start off with uh just a brief

00:06:03,280 --> 00:06:06,639
description of

00:06:04,639 --> 00:06:08,080
some of the things that you were talking

00:06:06,639 --> 00:06:12,080
about there

00:06:08,080 --> 00:06:14,800
yeah absolutely so while i'm working

00:06:12,080 --> 00:06:15,919
in the various code bases that our

00:06:14,800 --> 00:06:19,440
company has

00:06:15,919 --> 00:06:20,000
you know there's lots of challenges that

00:06:19,440 --> 00:06:21,600
we come across

00:06:20,000 --> 00:06:23,840
these additional constraints that we

00:06:21,600 --> 00:06:25,520
deal with in the embedded area

00:06:23,840 --> 00:06:27,520
because we're worried about maybe

00:06:25,520 --> 00:06:30,960
certification concerns

00:06:27,520 --> 00:06:32,960
or safety concerns uh with the

00:06:30,960 --> 00:06:35,199
products that we make and so my

00:06:32,960 --> 00:06:38,160
interests are trying to

00:06:35,199 --> 00:06:39,919
find the best ways that we can to

00:06:38,160 --> 00:06:41,759
satisfy the problems and the constraints

00:06:39,919 --> 00:06:43,520
that we're dealing with but also

00:06:41,759 --> 00:06:45,120
make sure we're using the appropriate

00:06:43,520 --> 00:06:46,960
tools for the area

00:06:45,120 --> 00:06:48,400
and not just letting ourselves sort of

00:06:46,960 --> 00:06:50,960
coast along

00:06:48,400 --> 00:06:52,080
with you know the way we've done things

00:06:50,960 --> 00:06:54,000
before

00:06:52,080 --> 00:06:55,520
we want to be continually reevaluating

00:06:54,000 --> 00:06:58,240
what we have and make sure it's the best

00:06:55,520 --> 00:06:58,240
that we can get

00:06:59,759 --> 00:07:06,000
okay so um so you've i think

00:07:04,319 --> 00:07:07,520
when you talk about the best that we can

00:07:06,000 --> 00:07:10,800
get i think you mentioned

00:07:07,520 --> 00:07:11,120
uh one of the things on that discussion

00:07:10,800 --> 00:07:14,800
was

00:07:11,120 --> 00:07:16,880
that your tools are often uh

00:07:14,800 --> 00:07:18,319
rather out of date because they need to

00:07:16,880 --> 00:07:22,319
be certified

00:07:18,319 --> 00:07:26,240
right that you the process requires that

00:07:22,319 --> 00:07:27,919
you uh you verify the whole tool chain

00:07:26,240 --> 00:07:29,440
and once that's done

00:07:27,919 --> 00:07:31,599
you don't you only want to change that

00:07:29,440 --> 00:07:35,120
very rarely right

00:07:31,599 --> 00:07:37,360
right um so

00:07:35,120 --> 00:07:37,360
the

00:07:38,880 --> 00:07:42,400
now do you actually have the uh insight

00:07:41,039 --> 00:07:45,680
into how that

00:07:42,400 --> 00:07:48,720
certification processes process works

00:07:45,680 --> 00:07:50,639
um i haven't uh the machines i've done

00:07:48,720 --> 00:07:55,440
we didn't have quite that same strict

00:07:50,639 --> 00:07:55,440
uh requirement there so

00:07:55,680 --> 00:07:59,199
one of the other members might have a

00:07:57,280 --> 00:08:00,080
little more insight i just know that the

00:07:59,199 --> 00:08:03,280
compilers

00:08:00,080 --> 00:08:04,319
are certified so for example link sauce

00:08:03,280 --> 00:08:06,000
is one that we've

00:08:04,319 --> 00:08:07,360
used or sorry link sauce is the

00:08:06,000 --> 00:08:09,919
operating system lynx

00:08:07,360 --> 00:08:12,080
makes the compiler and that's certified

00:08:09,919 --> 00:08:13,599
and it's really expensive because

00:08:12,080 --> 00:08:16,479
it turns out making a compiler is

00:08:13,599 --> 00:08:16,479
somewhat difficult

00:08:16,800 --> 00:08:22,479
sure so so yeah um

00:08:20,240 --> 00:08:24,160
this is pretty standard practice in

00:08:22,479 --> 00:08:27,680
safety critical systems that

00:08:24,160 --> 00:08:29,360
that and and air aircraft maintain

00:08:27,680 --> 00:08:31,280
aircraft manufacturing aircraft

00:08:29,360 --> 00:08:33,919
components is probably one of the

00:08:31,280 --> 00:08:34,800
safest the most stringent safety

00:08:33,919 --> 00:08:37,519
critical

00:08:34,800 --> 00:08:38,159
uh well-regulated i mean after all you

00:08:37,519 --> 00:08:41,039
know we

00:08:38,159 --> 00:08:42,479
we investigate everything up to you know

00:08:41,039 --> 00:08:43,120
and it's and it's and it's for good

00:08:42,479 --> 00:08:45,120
reasons

00:08:43,120 --> 00:08:46,480
um and the same thing with automotive

00:08:45,120 --> 00:08:48,800
that i'm finding they have to be

00:08:46,480 --> 00:08:50,720
certified we call these things um

00:08:48,800 --> 00:08:52,080
safety integrity level i touched on this

00:08:50,720 --> 00:08:54,320
in my talk yesterday

00:08:52,080 --> 00:08:55,920
that these things have ways of allowing

00:08:54,320 --> 00:08:58,399
you to deal with the fact that you

00:08:55,920 --> 00:09:01,200
cannot make everything completely safe

00:08:58,399 --> 00:09:02,640
and faultless all we can do is make sure

00:09:01,200 --> 00:09:05,680
that things that can

00:09:02,640 --> 00:09:08,399
render renders these um these operations

00:09:05,680 --> 00:09:11,040
uncontrollable happens very rarely

00:09:08,399 --> 00:09:11,519
something like one in a million chance

00:09:11,040 --> 00:09:15,440
and

00:09:11,519 --> 00:09:18,880
so we we selectively

00:09:15,440 --> 00:09:19,600
push those items to very high safety

00:09:18,880 --> 00:09:23,040
levels like

00:09:19,600 --> 00:09:25,519
brake systems autopilot systems

00:09:23,040 --> 00:09:27,440
um things like that whereas other things

00:09:25,519 --> 00:09:28,720
that are not as important like maybe the

00:09:27,440 --> 00:09:31,040
windshield wiper

00:09:28,720 --> 00:09:31,839
doesn't have to be pushed to that that

00:09:31,040 --> 00:09:35,360
kind of level

00:09:31,839 --> 00:09:36,959
and that that that sil level

00:09:35,360 --> 00:09:38,880
comes with it a whole truckload of

00:09:36,959 --> 00:09:41,040
things from the conform from the

00:09:38,880 --> 00:09:42,959
configuration management tools that you

00:09:41,040 --> 00:09:43,839
need to use the language of compilers

00:09:42,959 --> 00:09:45,519
that you need to use

00:09:43,839 --> 00:09:47,920
the type of language tools that you need

00:09:45,519 --> 00:09:50,080
to use they all have to be certified

00:09:47,920 --> 00:09:51,440
and this is one of the things that has

00:09:50,080 --> 00:09:53,760
to do with embedded agreed

00:09:51,440 --> 00:09:55,120
you know when you talk about safety um

00:09:53,760 --> 00:09:57,839
you have to make sure that if

00:09:55,120 --> 00:09:59,440
in some cases um either the industry or

00:09:57,839 --> 00:10:00,800
the standard or the government mandates

00:09:59,440 --> 00:10:01,440
these kinds of things so that's why you

00:10:00,800 --> 00:10:02,720
have to have

00:10:01,440 --> 00:10:05,440
you have to have these kinds of things

00:10:02,720 --> 00:10:07,839
happen that's why it's expensive

00:10:05,440 --> 00:10:09,640
to change if someone if you want to

00:10:07,839 --> 00:10:12,640
update your tool that's a huge

00:10:09,640 --> 00:10:13,200
recertification which a lot of companies

00:10:12,640 --> 00:10:14,800
don't

00:10:13,200 --> 00:10:16,160
don't necessarily want to go through but

00:10:14,800 --> 00:10:17,040
they the governments make them go

00:10:16,160 --> 00:10:19,279
through it so

00:10:17,040 --> 00:10:20,959
it's a way to make us all all be safe

00:10:19,279 --> 00:10:22,079
when we are driving around and traveling

00:10:20,959 --> 00:10:23,760
in airplanes

00:10:22,079 --> 00:10:25,120
and things like that and we're in pain

00:10:23,760 --> 00:10:26,640
there's a real push and pull here

00:10:25,120 --> 00:10:28,000
because sometimes you

00:10:26,640 --> 00:10:29,519
sometimes you're being told not to

00:10:28,000 --> 00:10:30,399
update your tools because we haven't

00:10:29,519 --> 00:10:33,040
recertified

00:10:30,399 --> 00:10:34,000
those but at the same time sometimes

00:10:33,040 --> 00:10:36,880
you're being told

00:10:34,000 --> 00:10:38,560
no the new certified version is

00:10:36,880 --> 00:10:41,279
something else

00:10:38,560 --> 00:10:42,399
we need to you need to update to that

00:10:41,279 --> 00:10:45,839
now

00:10:42,399 --> 00:10:47,680
so daniel do you experience

00:10:45,839 --> 00:10:49,760
when you're trying to say let's go to c

00:10:47,680 --> 00:10:52,320
plus plus 17

00:10:49,760 --> 00:10:53,920
or because of the fact that the costs

00:10:52,320 --> 00:10:57,040
are pretty high

00:10:53,920 --> 00:10:58,000
to move to that package or are you

00:10:57,040 --> 00:11:00,640
talking about

00:10:58,000 --> 00:11:01,279
how do you make your system redundant

00:11:00,640 --> 00:11:04,560
and

00:11:01,279 --> 00:11:07,519
exception you know proof

00:11:04,560 --> 00:11:09,120
that we can handle the any any possible

00:11:07,519 --> 00:11:12,079
situation

00:11:09,120 --> 00:11:13,360
i think both of those would be um

00:11:12,079 --> 00:11:14,800
considerations

00:11:13,360 --> 00:11:17,360
uh you want to make sure you're

00:11:14,800 --> 00:11:18,720
respecting the actual like real limits

00:11:17,360 --> 00:11:21,839
you have and if you

00:11:18,720 --> 00:11:23,200
have a high assurance level that you're

00:11:21,839 --> 00:11:24,720
targeting

00:11:23,200 --> 00:11:26,160
you know you may not be able to use all

00:11:24,720 --> 00:11:27,839
the features of your language and that's

00:11:26,160 --> 00:11:30,959
okay

00:11:27,839 --> 00:11:31,760
but yes the compiler is definitely a big

00:11:30,959 --> 00:11:34,720
limiter

00:11:31,760 --> 00:11:35,519
in terms of what features you can use

00:11:34,720 --> 00:11:37,920
for example

00:11:35,519 --> 00:11:38,959
recently i was looking at a project i

00:11:37,920 --> 00:11:41,200
had just

00:11:38,959 --> 00:11:43,040
recently joined and they are using a

00:11:41,200 --> 00:11:47,279
relatively older compiler

00:11:43,040 --> 00:11:48,399
for gcc and i asked why that was and the

00:11:47,279 --> 00:11:50,160
answer was well

00:11:48,399 --> 00:11:52,240
some of the other targets that we're

00:11:50,160 --> 00:11:53,680
compiling for using something like link

00:11:52,240 --> 00:11:56,720
sauce for example

00:11:53,680 --> 00:11:59,760
and they can't support as certain

00:11:56,720 --> 00:12:01,519
constructs that have become normal so

00:11:59,760 --> 00:12:03,600
you know you have to use what you're

00:12:01,519 --> 00:12:05,440
targeting for and you gotta wait

00:12:03,600 --> 00:12:07,600
we sometimes blame these compilers for

00:12:05,440 --> 00:12:09,200
not keeping up with the c plus standard

00:12:07,600 --> 00:12:11,920
but sometimes it's the case that you

00:12:09,200 --> 00:12:13,360
know they just it's expensive and costly

00:12:11,920 --> 00:12:14,160
for them to recertify to the new

00:12:13,360 --> 00:12:16,160
standard

00:12:14,160 --> 00:12:17,360
so it's it's definitely a push and pull

00:12:16,160 --> 00:12:19,200
like you said

00:12:17,360 --> 00:12:20,560
well well i can tell you since i work

00:12:19,200 --> 00:12:24,240
with a company at work

00:12:20,560 --> 00:12:27,839
owns everything about the pdp 10. 10

00:12:24,240 --> 00:12:32,079
that yes the new compiler code

00:12:27,839 --> 00:12:35,120
will break the the uh

00:12:32,079 --> 00:12:38,160
the code that is being compiled

00:12:35,120 --> 00:12:39,920
for the pdp 10. so we can't work

00:12:38,160 --> 00:12:41,600
we're working with a compiler like 10

00:12:39,920 --> 00:12:44,240
years old because

00:12:41,600 --> 00:12:45,519
if we put in something new it's going

00:12:44,240 --> 00:12:49,200
it's going to break

00:12:45,519 --> 00:12:51,600
and so that's why we have to you know

00:12:49,200 --> 00:12:53,279
invest in the tools but we just have to

00:12:51,600 --> 00:12:54,560
invest in the product right now rather

00:12:53,279 --> 00:12:58,079
than the tools

00:12:54,560 --> 00:13:01,360
right i would like to jump in

00:12:58,079 --> 00:13:02,880
and say that i actually have a slightly

00:13:01,360 --> 00:13:06,399
different experience because

00:13:02,880 --> 00:13:09,360
we also have to uh to be

00:13:06,399 --> 00:13:10,800
under certificates uh regarding you know

00:13:09,360 --> 00:13:14,160
electricity and

00:13:10,800 --> 00:13:14,800
the grid and uh but but the fact is that

00:13:14,160 --> 00:13:17,680
we are

00:13:14,800 --> 00:13:18,240
actually facing uh a tool chain uh

00:13:17,680 --> 00:13:20,880
upgrade

00:13:18,240 --> 00:13:21,839
and like we're currently um in the

00:13:20,880 --> 00:13:25,279
process of that

00:13:21,839 --> 00:13:27,920
and i think i think there's two main

00:13:25,279 --> 00:13:29,440
problems here the first one would be and

00:13:27,920 --> 00:13:31,120
i think daniel actually mentioned that

00:13:29,440 --> 00:13:34,160
the first one would be

00:13:31,120 --> 00:13:34,880
the uh the common knowledge uh the

00:13:34,160 --> 00:13:38,720
common

00:13:34,880 --> 00:13:43,360
um um opinion that

00:13:38,720 --> 00:13:46,480
that we we don't wanna we want to avoid

00:13:43,360 --> 00:13:47,760
things that might end up with with

00:13:46,480 --> 00:13:50,720
errors and of course it's

00:13:47,760 --> 00:13:51,440
it's probably different with the safety

00:13:50,720 --> 00:13:54,079
critical

00:13:51,440 --> 00:13:55,120
uh topics but and and the other thing is

00:13:54,079 --> 00:13:58,240
that

00:13:55,120 --> 00:13:58,880
i mean i as part of my my talk on

00:13:58,240 --> 00:14:01,440
exceptions

00:13:58,880 --> 00:14:03,040
i think is also a very important topic

00:14:01,440 --> 00:14:06,320
for embedded

00:14:03,040 --> 00:14:08,880
i've looked for style guides

00:14:06,320 --> 00:14:10,160
and i've seen a style guide of google

00:14:08,880 --> 00:14:12,720
suggesting not to use

00:14:10,160 --> 00:14:13,839
templates because they are too

00:14:12,720 --> 00:14:17,760
complicated

00:14:13,839 --> 00:14:21,440
and that made me uh feel that

00:14:17,760 --> 00:14:23,680
like we need to we need to to identify

00:14:21,440 --> 00:14:27,040
the real problems and

00:14:23,680 --> 00:14:30,160
and maybe try to advance because

00:14:27,040 --> 00:14:31,199
embedded it's it's really it's rather

00:14:30,160 --> 00:14:35,040
ironic

00:14:31,199 --> 00:14:38,320
because embedded can gain most out of

00:14:35,040 --> 00:14:41,760
advanced compilers so yeah

00:14:38,320 --> 00:14:43,199
we'll be able to address that and simple

00:14:41,760 --> 00:14:45,600
past 20

00:14:43,199 --> 00:14:46,800
i'll just continue like it's a bit of a

00:14:45,600 --> 00:14:49,920
different topic but ziploc

00:14:46,800 --> 00:14:53,360
20 is is embedded focused

00:14:49,920 --> 00:14:56,480
i mean a lot of the features there are

00:14:53,360 --> 00:14:59,519
encouraging compile time and it's

00:14:56,480 --> 00:15:02,000
it's a really a tool that

00:14:59,519 --> 00:15:02,800
i would love to to have in my embedded

00:15:02,000 --> 00:15:06,480
systems

00:15:02,800 --> 00:15:09,600
whenever it will be available

00:15:06,480 --> 00:15:12,560
now connected to that um

00:15:09,600 --> 00:15:13,360
a question from the from the audience uh

00:15:12,560 --> 00:15:14,880
one of the

00:15:13,360 --> 00:15:16,959
issues that we sometimes face is not

00:15:14,880 --> 00:15:20,000
just getting the tools

00:15:16,959 --> 00:15:21,120
up to date but also keeping up to date

00:15:20,000 --> 00:15:25,839
ourselves

00:15:21,120 --> 00:15:29,120
uh especially a lot of people

00:15:25,839 --> 00:15:30,800
uh work on embedded systems they don't

00:15:29,120 --> 00:15:32,480
they didn't necessarily

00:15:30,800 --> 00:15:34,399
set out some of them didn't even

00:15:32,480 --> 00:15:36,160
necessarily set up to learn the c or c

00:15:34,399 --> 00:15:38,399
plus plus they were thinking in terms of

00:15:36,160 --> 00:15:41,360
being an electrical engineer

00:15:38,399 --> 00:15:43,440
and then this was something that also

00:15:41,360 --> 00:15:46,639
became relevant to their job

00:15:43,440 --> 00:15:49,440
other people they

00:15:46,639 --> 00:15:51,519
uh they have a little bit more of a

00:15:49,440 --> 00:15:53,600
formal training but they

00:15:51,519 --> 00:15:55,839
you know it may have been some years ago

00:15:53,600 --> 00:15:58,480
or there may be problems because we

00:15:55,839 --> 00:16:00,639
sometimes worry that

00:15:58,480 --> 00:16:03,199
educational materials that are suitable

00:16:00,639 --> 00:16:04,880
for a general audience

00:16:03,199 --> 00:16:06,320
there's other there are other factors

00:16:04,880 --> 00:16:07,279
that we need to take into account in

00:16:06,320 --> 00:16:08,959
embedded that

00:16:07,279 --> 00:16:10,399
we don't necessarily that those other

00:16:08,959 --> 00:16:12,800
things aren't thinking about

00:16:10,399 --> 00:16:14,160
so what do you what would you guys

00:16:12,800 --> 00:16:17,279
suggest in terms of

00:16:14,160 --> 00:16:20,000
resources for keeping

00:16:17,279 --> 00:16:21,040
up to date with new developments in the

00:16:20,000 --> 00:16:24,240
standard and

00:16:21,040 --> 00:16:25,279
staying on top of newer techniques that

00:16:24,240 --> 00:16:28,959
would be

00:16:25,279 --> 00:16:28,959
suitable for use in embedded systems

00:16:29,440 --> 00:16:36,399
um so so i i found that

00:16:34,399 --> 00:16:37,839
that the collected community of people

00:16:36,399 --> 00:16:40,000
who's embedded

00:16:37,839 --> 00:16:41,920
um have been doing their best at putting

00:16:40,000 --> 00:16:44,079
forward great talks

00:16:41,920 --> 00:16:45,759
um i'll say that when i prepare for my

00:16:44,079 --> 00:16:47,120
talk on embedded this morning i watched

00:16:45,759 --> 00:16:50,000
michael case's talk

00:16:47,120 --> 00:16:50,959
many of his talk i watch odin holmes's

00:16:50,000 --> 00:16:53,120
talk

00:16:50,959 --> 00:16:54,320
i watched a lot of the uh the other

00:16:53,120 --> 00:16:56,560
talks by some of the

00:16:54,320 --> 00:16:57,440
the deep experts that have been that i

00:16:56,560 --> 00:17:00,560
know of that's

00:16:57,440 --> 00:17:03,680
been an sg-14 um to

00:17:00,560 --> 00:17:06,079
and and um and dancex talks

00:17:03,680 --> 00:17:06,959
not ben sacks but ben sex talks as well

00:17:06,079 --> 00:17:07,839
but let's

00:17:06,959 --> 00:17:10,000
make sure that people know the

00:17:07,839 --> 00:17:11,439
difference in their names

00:17:10,000 --> 00:17:13,439
we talked about that just before but

00:17:11,439 --> 00:17:15,280
yeah um i talked i looked at a lot of

00:17:13,439 --> 00:17:16,240
the talks so these days does the talks

00:17:15,280 --> 00:17:18,079
are i think

00:17:16,240 --> 00:17:21,039
probably one of the best way to keep up

00:17:18,079 --> 00:17:23,439
today i hate to say but books are almost

00:17:21,039 --> 00:17:24,959
over in terms of learning keeping up to

00:17:23,439 --> 00:17:26,240
date on what's going on

00:17:24,959 --> 00:17:28,480
you know it used to be okay when the

00:17:26,240 --> 00:17:30,000
standard was like you know five years

00:17:28,480 --> 00:17:32,080
ten years revisions that you could

00:17:30,000 --> 00:17:34,480
have the time to write a book but it's

00:17:32,080 --> 00:17:36,720
almost impossible now that i find

00:17:34,480 --> 00:17:38,240
now obviously the caveat that control

00:17:36,720 --> 00:17:39,440
with watching internet stuff but

00:17:38,240 --> 00:17:41,760
if you know that it's coming from a

00:17:39,440 --> 00:17:43,120
respected authorities that uh

00:17:41,760 --> 00:17:45,120
that know their stuff you can pretty

00:17:43,120 --> 00:17:47,360
much believe that while 90 95

00:17:45,120 --> 00:17:49,440
this stuff is pretty accurate and so

00:17:47,360 --> 00:17:52,960
that's that's the best way i find

00:17:49,440 --> 00:17:53,440
um not to plug my own group in sg14 we

00:17:52,960 --> 00:17:55,360
are

00:17:53,440 --> 00:17:56,720
trying to discuss things that are

00:17:55,360 --> 00:17:58,480
pushing the envelope

00:17:56,720 --> 00:18:00,320
so it's not a great place to learn about

00:17:58,480 --> 00:18:01,600
what's the latest practice but it's a

00:18:00,320 --> 00:18:03,600
great place to learn about

00:18:01,600 --> 00:18:04,880
where is the latest envelope going so

00:18:03,600 --> 00:18:06,480
we're talking about things like

00:18:04,880 --> 00:18:07,919
how to do exception handling using a

00:18:06,480 --> 00:18:09,840
stack based routine

00:18:07,919 --> 00:18:11,280
as opposed to heap based routine that

00:18:09,840 --> 00:18:14,000
actually believe it or not solves a

00:18:11,280 --> 00:18:17,200
great deal of the determinism problem

00:18:14,000 --> 00:18:17,600
and we talk about you know um we talk

00:18:17,200 --> 00:18:20,799
about

00:18:17,600 --> 00:18:21,919
new um memory allocation routines that

00:18:20,799 --> 00:18:23,600
are much better

00:18:21,919 --> 00:18:25,039
uh that have low overhead like jc

00:18:23,600 --> 00:18:27,120
mallock and and

00:18:25,039 --> 00:18:28,559
and things like that that and those are

00:18:27,120 --> 00:18:29,840
new malloc routines that have been

00:18:28,559 --> 00:18:30,880
floating around out there that have been

00:18:29,840 --> 00:18:33,840
well tested

00:18:30,880 --> 00:18:36,080
to show that they have indeed excellent

00:18:33,840 --> 00:18:36,960
um characteristics now jc malone isn't

00:18:36,080 --> 00:18:39,840
the only one

00:18:36,960 --> 00:18:41,200
there's um you know sorry j.e malone's

00:18:39,840 --> 00:18:42,000
and the only one there's tc mellor

00:18:41,200 --> 00:18:43,919
there's old

00:18:42,000 --> 00:18:45,440
there's a whole bunch of other um memory

00:18:43,919 --> 00:18:47,280
allocation routines that are out there

00:18:45,440 --> 00:18:48,880
and we talk about things like we talk

00:18:47,280 --> 00:18:51,280
about um um

00:18:48,880 --> 00:18:52,000
how to push the envelope to in that way

00:18:51,280 --> 00:18:53,919
because

00:18:52,000 --> 00:18:55,360
because you know i find that that's

00:18:53,919 --> 00:18:56,320
pretty much the only way i can do it is

00:18:55,360 --> 00:18:58,640
to keep up that way

00:18:56,320 --> 00:19:00,400
there are no books but they

00:18:58,640 --> 00:19:01,760
fundamentally are pretty good at talking

00:19:00,400 --> 00:19:02,559
about things that don't change that

00:19:01,760 --> 00:19:05,280
quickly

00:19:02,559 --> 00:19:08,480
um safety practices best reliability

00:19:05,280 --> 00:19:08,480
practices and things like that

00:19:08,640 --> 00:19:11,919
i would love to to answer that as well i

00:19:11,039 --> 00:19:15,919
think

00:19:11,919 --> 00:19:18,160
um and unfortunately i'm not aware of

00:19:15,919 --> 00:19:19,679
of a good source for that but i would

00:19:18,160 --> 00:19:23,440
just suggest

00:19:19,679 --> 00:19:24,160
to go and uh and research the new

00:19:23,440 --> 00:19:27,679
features

00:19:24,160 --> 00:19:30,880
and and try to identify if uh

00:19:27,679 --> 00:19:34,000
if they're uh suitable uh

00:19:30,880 --> 00:19:37,039
in the in their regular um

00:19:34,000 --> 00:19:39,200
constraints that we're all familiar with

00:19:37,039 --> 00:19:41,200
if it's dynamic allocation in your

00:19:39,200 --> 00:19:44,880
system if it's

00:19:41,200 --> 00:19:46,960
compile time runtime errors

00:19:44,880 --> 00:19:50,000
i would just suggest address every

00:19:46,960 --> 00:19:53,120
feature and try to research in those

00:19:50,000 --> 00:19:56,480
in those with this guideline in mind

00:19:53,120 --> 00:19:57,840
and and that's how you yeah that'll be

00:19:56,480 --> 00:19:59,919
next to to summarize

00:19:57,840 --> 00:20:01,520
what all this the new features are how

00:19:59,919 --> 00:20:02,880
they work in the embedded domain

00:20:01,520 --> 00:20:04,640
and give a summary of something like

00:20:02,880 --> 00:20:06,240
that that would be a great paper

00:20:04,640 --> 00:20:08,159
a lot of people well i think i think

00:20:06,240 --> 00:20:10,799
first we need to identify

00:20:08,159 --> 00:20:13,360
what is the embedded domain oh let's not

00:20:10,799 --> 00:20:13,360
do that yet

00:20:14,080 --> 00:20:17,679
that's certainly part of the discussion

00:20:15,600 --> 00:20:21,120
we talked about safety

00:20:17,679 --> 00:20:22,880
before but yeah i mean

00:20:21,120 --> 00:20:24,960
there there's plenty of stuff on the

00:20:22,880 --> 00:20:28,320
internet that you can look at

00:20:24,960 --> 00:20:29,120
you just have to um you have to look at

00:20:28,320 --> 00:20:31,039
it really hard

00:20:29,120 --> 00:20:32,720
and and you're not always going to find

00:20:31,039 --> 00:20:35,840
the right answer right off the bat

00:20:32,720 --> 00:20:38,880
but yeah damn thank you for not

00:20:35,840 --> 00:20:40,400
not poking the double e too much

00:20:38,880 --> 00:20:43,440
maybe i should have added that to my bio

00:20:40,400 --> 00:20:46,159
at the beginning so you know

00:20:43,440 --> 00:20:46,159
i wasn't interested

00:20:47,760 --> 00:20:51,440
one of the interesting things that i i

00:20:50,320 --> 00:20:56,159
remember i think my

00:20:51,440 --> 00:20:59,360
my dad was uh saying to me about uh

00:20:56,159 --> 00:21:02,640
his experience in this is that uh

00:20:59,360 --> 00:21:04,640
he if he had a software that was writing

00:21:02,640 --> 00:21:05,919
building a team to build an embedded

00:21:04,640 --> 00:21:09,520
device and he could just hire

00:21:05,919 --> 00:21:11,600
one person who said hire a double e

00:21:09,520 --> 00:21:13,200
they'll get it working you know it's

00:21:11,600 --> 00:21:15,360
it's uh

00:21:13,200 --> 00:21:17,600
they will be able to connect all of the

00:21:15,360 --> 00:21:18,799
hardware pieces to all of the software

00:21:17,600 --> 00:21:21,919
pieces

00:21:18,799 --> 00:21:24,240
and uh they will figure it out

00:21:21,919 --> 00:21:26,240
when when the code starts getting larger

00:21:24,240 --> 00:21:28,400
that's when

00:21:26,240 --> 00:21:30,080
i'd want to hire some more software

00:21:28,400 --> 00:21:32,480
specific guys

00:21:30,080 --> 00:21:34,799
for that sort of thing or where you can

00:21:32,480 --> 00:21:38,640
hire a double lead that does software

00:21:34,799 --> 00:21:38,640
yeah yeah do that too there you go

00:21:38,880 --> 00:21:44,159
on that topic though of um sourcing are

00:21:41,520 --> 00:21:46,799
you selling your company

00:21:44,159 --> 00:21:47,919
i'm not going to sell my company but one

00:21:46,799 --> 00:21:50,640
of the uh

00:21:47,919 --> 00:21:51,200
one of the things is sometimes the

00:21:50,640 --> 00:21:54,000
problem

00:21:51,200 --> 00:21:56,000
is you have to give good motivation on

00:21:54,000 --> 00:21:58,400
why you would want to do that

00:21:56,000 --> 00:22:00,640
you know why in the world devote the

00:21:58,400 --> 00:22:02,640
time the energy in order to

00:22:00,640 --> 00:22:04,320
um take on all the new language features

00:22:02,640 --> 00:22:06,240
it's working just fine for me now why

00:22:04,320 --> 00:22:09,679
why would i want to invest in that right

00:22:06,240 --> 00:22:11,520
and so um i think there are a variety of

00:22:09,679 --> 00:22:13,440
different resources out from

00:22:11,520 --> 00:22:15,039
from some of the talks that michael's

00:22:13,440 --> 00:22:15,919
mentioned as well as others that you'll

00:22:15,039 --> 00:22:17,440
find where

00:22:15,919 --> 00:22:18,640
motivation is given on why you would

00:22:17,440 --> 00:22:21,200
want to do that there are business

00:22:18,640 --> 00:22:23,280
reasons as well as technical

00:22:21,200 --> 00:22:25,280
development reasons that most people

00:22:23,280 --> 00:22:27,280
would recognize as being

00:22:25,280 --> 00:22:28,559
this is this would make my life better

00:22:27,280 --> 00:22:31,440
to do this

00:22:28,559 --> 00:22:33,760
in a particular way um i'm gonna i'm

00:22:31,440 --> 00:22:36,880
gonna put a plug in for cpp ling

00:22:33,760 --> 00:22:38,880
um slack has an embedded channel

00:22:36,880 --> 00:22:40,400
and i think we're pretty active in there

00:22:38,880 --> 00:22:42,080
we're always happy to answer questions

00:22:40,400 --> 00:22:43,280
about learning and features and things

00:22:42,080 --> 00:22:45,760
of that sort

00:22:43,280 --> 00:22:47,039
that's great uh just to put people in

00:22:45,760 --> 00:22:49,520
with some context here the reason

00:22:47,039 --> 00:22:51,440
michael talked about ee versus cs

00:22:49,520 --> 00:22:52,559
is um they always been this ribbing

00:22:51,440 --> 00:22:54,640
about you know how

00:22:52,559 --> 00:22:56,320
different electrical engineers tend to

00:22:54,640 --> 00:22:56,720
dive in and start programming right away

00:22:56,320 --> 00:22:59,600
where

00:22:56,720 --> 00:23:00,880
cs tends to think and you know waterfall

00:22:59,600 --> 00:23:02,880
agile and all that

00:23:00,880 --> 00:23:04,400
and yes there's been there's been that

00:23:02,880 --> 00:23:05,440
and i talked about it today in my talk

00:23:04,400 --> 00:23:07,520
as well too

00:23:05,440 --> 00:23:09,840
and i'm not trying to rip anyone i think

00:23:07,520 --> 00:23:12,400
you're right you kind of need both

00:23:09,840 --> 00:23:13,280
and it would be great if people could be

00:23:12,400 --> 00:23:14,880
both eas

00:23:13,280 --> 00:23:16,640
electrical engineers and computer

00:23:14,880 --> 00:23:19,919
science specialists but

00:23:16,640 --> 00:23:23,600
you know these days you can get

00:23:19,919 --> 00:23:25,600
yeah um now one of the

00:23:23,600 --> 00:23:28,240
problems that we sometimes have another

00:23:25,600 --> 00:23:32,240
question from the audience

00:23:28,240 --> 00:23:34,320
has to do it there's some

00:23:32,240 --> 00:23:36,320
concern about how much of the the

00:23:34,320 --> 00:23:37,120
standard can i actually take advantage

00:23:36,320 --> 00:23:40,240
of

00:23:37,120 --> 00:23:44,000
given that it doesn't a lot of that rely

00:23:40,240 --> 00:23:45,440
on exception handling and dynamic memory

00:23:44,000 --> 00:23:49,279
allocation

00:23:45,440 --> 00:23:50,799
is that something that uh are we able to

00:23:49,279 --> 00:23:52,880
actually

00:23:50,799 --> 00:23:54,960
use much of the standard library or is

00:23:52,880 --> 00:23:57,919
it do we really need to focus on just on

00:23:54,960 --> 00:23:57,919
the language features

00:23:58,400 --> 00:24:01,520
so you know sorry i'll see a quick plug

00:24:00,960 --> 00:24:03,600
here

00:24:01,520 --> 00:24:05,200
that's that's exactly part of the

00:24:03,600 --> 00:24:08,000
problem because

00:24:05,200 --> 00:24:08,559
you there's a certification angle to

00:24:08,000 --> 00:24:11,200
that too

00:24:08,559 --> 00:24:11,760
when you want to certify you may often

00:24:11,200 --> 00:24:14,480
have to

00:24:11,760 --> 00:24:15,360
own the code that you're using because

00:24:14,480 --> 00:24:17,919
you have to

00:24:15,360 --> 00:24:20,400
maybe get path or decision coverage and

00:24:17,919 --> 00:24:22,640
so trying to figure out how to use

00:24:20,400 --> 00:24:24,880
third-party libraries of any kind let

00:24:22,640 --> 00:24:28,000
alone something that also has

00:24:24,880 --> 00:24:28,799
exceptions and dynamic memory is a real

00:24:28,000 --> 00:24:32,080
challenge you

00:24:28,799 --> 00:24:35,360
really really hate to have to reinvent

00:24:32,080 --> 00:24:36,720
or remake something yourself

00:24:35,360 --> 00:24:39,440
so we don't want to make stepping off

00:24:36,720 --> 00:24:40,240
sad right like this much of it is

00:24:39,440 --> 00:24:43,840
containers

00:24:40,240 --> 00:24:46,320
and this much of it is algorithms

00:24:43,840 --> 00:24:47,440
right right and so there are portions of

00:24:46,320 --> 00:24:49,760
it that obviously

00:24:47,440 --> 00:24:50,640
are difficult for us to use um which we

00:24:49,760 --> 00:24:53,520
just can't

00:24:50,640 --> 00:24:54,640
but there are so many parts of the

00:24:53,520 --> 00:24:58,320
standard library

00:24:54,640 --> 00:24:59,760
that are just accessible and usable um

00:24:58,320 --> 00:25:01,760
and we don't want to ignore those or

00:24:59,760 --> 00:25:02,000
repeat and remake them again right a lot

00:25:01,760 --> 00:25:03,440
of

00:25:02,000 --> 00:25:05,600
good work has already been put into that

00:25:03,440 --> 00:25:05,600
so

00:25:06,400 --> 00:25:11,039
i would love to add that um there's a

00:25:09,760 --> 00:25:14,000
great proposal

00:25:11,039 --> 00:25:15,120
called freestanding library and that's

00:25:14,000 --> 00:25:18,799
on the way now

00:25:15,120 --> 00:25:22,640
and um it's by ben craig and

00:25:18,799 --> 00:25:25,279
he's focusing on identifying the the

00:25:22,640 --> 00:25:26,000
the parts of the library that are

00:25:25,279 --> 00:25:29,200
visible

00:25:26,000 --> 00:25:32,320
for embedded systems and i would hope

00:25:29,200 --> 00:25:35,360
that that would be a direct

00:25:32,320 --> 00:25:39,039
a step in the right direction to

00:25:35,360 --> 00:25:39,600
be able to certificate the freestanding

00:25:39,039 --> 00:25:42,640
parts

00:25:39,600 --> 00:25:46,640
of the library and perhaps in that way

00:25:42,640 --> 00:25:49,440
you will have and i'm sorry i mean um

00:25:46,640 --> 00:25:50,880
i mean uh i'm sure ben you're all you're

00:25:49,440 --> 00:25:54,159
also involved with that so

00:25:50,880 --> 00:25:56,480
i haven't um but but

00:25:54,159 --> 00:25:57,840
in any way i think it's really uh it's

00:25:56,480 --> 00:25:58,880
going to be the right step in the right

00:25:57,840 --> 00:26:02,400
direction

00:25:58,880 --> 00:26:03,120
so that i agree you'll be able to have

00:26:02,400 --> 00:26:06,240
this

00:26:03,120 --> 00:26:09,279
library certificated once

00:26:06,240 --> 00:26:13,120
and i mean

00:26:09,279 --> 00:26:15,840
for all the all the users to to have

00:26:13,120 --> 00:26:16,880
well yeah there's that it's certainly

00:26:15,840 --> 00:26:19,760
true that

00:26:16,880 --> 00:26:21,520
uh there are some of this is on the

00:26:19,760 --> 00:26:23,679
committee's radar there are active

00:26:21,520 --> 00:26:25,919
proposals that are working on

00:26:23,679 --> 00:26:27,520
trying to address some of the questions

00:26:25,919 --> 00:26:29,120
of

00:26:27,520 --> 00:26:30,640
right now very little of the standard

00:26:29,120 --> 00:26:33,120
library is

00:26:30,640 --> 00:26:35,760
available is guaranteed to be available

00:26:33,120 --> 00:26:38,320
for embedded systems

00:26:35,760 --> 00:26:40,000
but there there are proposals to work on

00:26:38,320 --> 00:26:40,480
changing that there are proposals to

00:26:40,000 --> 00:26:43,520
work

00:26:40,480 --> 00:26:45,520
on uh making

00:26:43,520 --> 00:26:46,559
optional certain language features that

00:26:45,520 --> 00:26:50,159
are of concern

00:26:46,559 --> 00:26:53,600
to uh the embedded community

00:26:50,159 --> 00:26:57,440
but uh more broadly the

00:26:53,600 --> 00:26:59,679
um oh looks like we may have

00:26:57,440 --> 00:27:01,679
uh lost someone there okay well

00:26:59,679 --> 00:27:06,400
hopefully we'll be able to get

00:27:01,679 --> 00:27:10,400
michael back shortly um

00:27:06,400 --> 00:27:14,000
yeah uh in any case

00:27:10,400 --> 00:27:16,640
um the oh there we go

00:27:14,000 --> 00:27:18,480
uh so some of this certainly is on the

00:27:16,640 --> 00:27:21,520
committee's radar but i think

00:27:18,480 --> 00:27:22,960
that uh to the idea of certifying the

00:27:21,520 --> 00:27:23,919
library if i understood something that

00:27:22,960 --> 00:27:27,279
daniel was saying

00:27:23,919 --> 00:27:30,480
earlier it was that uh

00:27:27,279 --> 00:27:30,480
there was this problem of

00:27:30,640 --> 00:27:34,240
even if the standard library isn't

00:27:32,960 --> 00:27:37,360
necessarily just

00:27:34,240 --> 00:27:39,520
one library because

00:27:37,360 --> 00:27:41,120
there's each vendor's implementation of

00:27:39,520 --> 00:27:43,520
the standard library

00:27:41,120 --> 00:27:45,039
right and that that's that was one of

00:27:43,520 --> 00:27:47,760
the problems for certification if i

00:27:45,039 --> 00:27:49,919
remember correctly

00:27:47,760 --> 00:27:52,480
i think that's probably definitely true

00:27:49,919 --> 00:27:54,159
um in general

00:27:52,480 --> 00:27:56,159
one project i've worked on you

00:27:54,159 --> 00:27:59,360
effectively

00:27:56,159 --> 00:28:01,039
had to own something if it didn't meet

00:27:59,360 --> 00:28:03,279
whatever coding standard you're

00:28:01,039 --> 00:28:04,559
being held to and you might get some

00:28:03,279 --> 00:28:06,159
evaluation back

00:28:04,559 --> 00:28:07,760
that says yeah there's all these

00:28:06,159 --> 00:28:10,799
problems you had to fix them

00:28:07,760 --> 00:28:12,080
so you know that's the big thing i think

00:28:10,799 --> 00:28:14,159
people are worried about

00:28:12,080 --> 00:28:15,279
is you want to be responsible for

00:28:14,159 --> 00:28:16,960
thousands of lines

00:28:15,279 --> 00:28:18,559
of complicated code that you didn't

00:28:16,960 --> 00:28:20,880
write so you end up

00:28:18,559 --> 00:28:22,960
using something you wrote yourself or

00:28:20,880 --> 00:28:25,120
you don't use it at all

00:28:22,960 --> 00:28:26,559
when you say you you mean the individual

00:28:25,120 --> 00:28:30,159
engineer right

00:28:26,559 --> 00:28:32,480
the company this library

00:28:30,159 --> 00:28:36,320
that the organization the company or the

00:28:32,480 --> 00:28:36,320
individuals on the project you could say

00:28:36,480 --> 00:28:40,240
so this is um this is a fairly hey brad

00:28:39,279 --> 00:28:42,080
we're back

00:28:40,240 --> 00:28:43,520
so this is a fairly common problem in

00:28:42,080 --> 00:28:45,200
most companies in that

00:28:43,520 --> 00:28:47,360
the idea of using off-the-shelf

00:28:45,200 --> 00:28:49,120
components um

00:28:47,360 --> 00:28:51,200
and that you don't know the back history

00:28:49,120 --> 00:28:52,000
of oftentimes it's not permitted it's

00:28:51,200 --> 00:28:53,919
called the uh

00:28:52,000 --> 00:28:56,559
it's called the no suit problem you

00:28:53,919 --> 00:28:58,320
cannot you cannot be using the software

00:28:56,559 --> 00:29:01,279
of unknown providence

00:28:58,320 --> 00:29:02,080
this is pretty common and so so you know

00:29:01,279 --> 00:29:04,080
you know about

00:29:02,080 --> 00:29:05,200
if you don't know about seinfeld and the

00:29:04,080 --> 00:29:06,399
soup and the soup guy

00:29:05,200 --> 00:29:07,919
you know that's right that's where that

00:29:06,399 --> 00:29:09,919
comes from it's called it's called no

00:29:07,919 --> 00:29:12,640
soup for you

00:29:09,919 --> 00:29:13,440
now i'm glad ingle brought up that issue

00:29:12,640 --> 00:29:16,640
that

00:29:13,440 --> 00:29:19,120
um ben craig's proposal

00:29:16,640 --> 00:29:20,080
which is improving the standard for um

00:29:19,120 --> 00:29:23,200
for

00:29:20,080 --> 00:29:25,360
freestanding and this has been long

00:29:23,200 --> 00:29:27,520
needed because the standard still holds

00:29:25,360 --> 00:29:27,919
to its old definition of freestanding

00:29:27,520 --> 00:29:31,279
from

00:29:27,919 --> 00:29:32,799
when it inherited it was a really weak

00:29:31,279 --> 00:29:34,399
definition you can only use a few

00:29:32,799 --> 00:29:35,520
headers and things like that but these

00:29:34,399 --> 00:29:38,080
days embedders have

00:29:35,520 --> 00:29:39,200
vastly expanded to the amount of headers

00:29:38,080 --> 00:29:40,640
that they can use

00:29:39,200 --> 00:29:43,360
and that's what ben's proposal is

00:29:40,640 --> 00:29:43,360
heading towards

00:29:44,080 --> 00:29:47,200
and like you said it's a great start and

00:29:46,320 --> 00:29:49,679
what we need to do

00:29:47,200 --> 00:29:50,799
is more after that what we need to do

00:29:49,679 --> 00:29:53,440
and and you know

00:29:50,799 --> 00:29:54,720
i mentioned it during the talk that that

00:29:53,440 --> 00:29:56,080
most of the standard library

00:29:54,720 --> 00:29:58,559
unfortunately is not usable to the

00:29:56,080 --> 00:30:00,960
embedded because it requires the heap

00:29:58,559 --> 00:30:01,840
and some some inves better devices

00:30:00,960 --> 00:30:06,559
simply don't

00:30:01,840 --> 00:30:08,559
don't have a heap okay and so

00:30:06,559 --> 00:30:10,559
there are two there's a unique pointer

00:30:08,559 --> 00:30:12,960
which doesn't use the heap

00:30:10,559 --> 00:30:14,159
there is intrusive pointer which doesn't

00:30:12,960 --> 00:30:15,840
use the heap

00:30:14,159 --> 00:30:18,399
okay there are a few pointers that you

00:30:15,840 --> 00:30:21,679
could use that is out there

00:30:18,399 --> 00:30:23,279
um flat map um and a few other ones um i

00:30:21,679 --> 00:30:25,200
think i talked about that but

00:30:23,279 --> 00:30:26,960
so i've always been thinking about this

00:30:25,200 --> 00:30:28,240
and wondering is there a way to create

00:30:26,960 --> 00:30:30,880
some sort of an aspect

00:30:28,240 --> 00:30:31,360
view of the standard library that

00:30:30,880 --> 00:30:34,080
doesn't

00:30:31,360 --> 00:30:35,279
use the heap this has fundamentally been

00:30:34,080 --> 00:30:38,000
something that we've been

00:30:35,279 --> 00:30:39,840
thinking about even at affiliate senior

00:30:38,000 --> 00:30:42,000
level at super plus is that

00:30:39,840 --> 00:30:43,520
you know the standard library a lot of

00:30:42,000 --> 00:30:44,640
people and it's not just the embedded

00:30:43,520 --> 00:30:46,320
community they built

00:30:44,640 --> 00:30:48,159
different versions of different forms of

00:30:46,320 --> 00:30:50,000
the standard library for games

00:30:48,159 --> 00:30:51,840
like electronic odds have their own

00:30:50,000 --> 00:30:54,480
versions of it for game for

00:30:51,840 --> 00:30:56,559
games um other people have done the same

00:30:54,480 --> 00:30:59,120
thing i started working and i didn't

00:30:56,559 --> 00:31:00,480
i i you know ibm had their own versions

00:30:59,120 --> 00:31:02,720
for two sold other people

00:31:00,480 --> 00:31:04,399
and we've always wondered about that and

00:31:02,720 --> 00:31:05,919
that's this is certainly an ongoing

00:31:04,399 --> 00:31:07,919
debate that we need to resolve because

00:31:05,919 --> 00:31:08,559
the library is extremely important in

00:31:07,919 --> 00:31:11,279
this

00:31:08,559 --> 00:31:12,000
in this space so just remember no soup

00:31:11,279 --> 00:31:15,440
for you

00:31:12,000 --> 00:31:18,000
okay now one of the

00:31:15,440 --> 00:31:18,640
uh one of the classic concerns that

00:31:18,000 --> 00:31:20,240
we've had

00:31:18,640 --> 00:31:21,679
talk we talked a little bit earlier

00:31:20,240 --> 00:31:24,080
about

00:31:21,679 --> 00:31:24,799
uh you know wanting to be able to take

00:31:24,080 --> 00:31:27,519
advantage

00:31:24,799 --> 00:31:28,480
of some of the more recent c plus

00:31:27,519 --> 00:31:30,080
features but

00:31:28,480 --> 00:31:32,000
you know there we still also have the

00:31:30,080 --> 00:31:33,440
issue that

00:31:32,000 --> 00:31:35,840
some people in the embedded community

00:31:33,440 --> 00:31:37,740
are still prefer to use

00:31:35,840 --> 00:31:39,360
c there's this

00:31:37,740 --> 00:31:42,159
[Music]

00:31:39,360 --> 00:31:43,760
perception that you're gonna pay some

00:31:42,159 --> 00:31:47,519
kind of cost for using c

00:31:43,760 --> 00:31:50,559
plus plus uh over c

00:31:47,519 --> 00:31:53,919
and so uh

00:31:50,559 --> 00:31:54,399
to what extent do you guy is that true

00:31:53,919 --> 00:31:56,960
to your

00:31:54,399 --> 00:31:57,600
understanding to what extent does that

00:31:56,960 --> 00:31:59,600
uh

00:31:57,600 --> 00:32:02,720
has is that no longer the case or maybe

00:31:59,600 --> 00:32:06,000
it was never was the case

00:32:02,720 --> 00:32:06,000
oh it was definitely the case

00:32:07,919 --> 00:32:14,159
it was horrible um but compilers

00:32:12,640 --> 00:32:15,840
you know c plus plus i think it's now a

00:32:14,159 --> 00:32:18,960
flood you know the

00:32:15,840 --> 00:32:20,720
c plus compilers now um

00:32:18,960 --> 00:32:22,240
generally um

00:32:20,720 --> 00:32:25,519
[Music]

00:32:22,240 --> 00:32:26,000
will outperform the c compiler if

00:32:25,519 --> 00:32:29,519
written

00:32:26,000 --> 00:32:33,360
in really good modern techniques

00:32:29,519 --> 00:32:36,080
and that's also fearsome for

00:32:33,360 --> 00:32:37,519
some um embedded engineers they really

00:32:36,080 --> 00:32:38,960
don't like the idea that

00:32:37,519 --> 00:32:40,720
they stuck something in the compiler and

00:32:38,960 --> 00:32:42,000
what came out wasn't what they expected

00:32:40,720 --> 00:32:44,720
when they look at the the

00:32:42,000 --> 00:32:46,240
assembly um that that's also kind of a

00:32:44,720 --> 00:32:47,200
cultural thing that needs to be repaired

00:32:46,240 --> 00:32:49,039
but

00:32:47,200 --> 00:32:50,799
i i think the idea that somehow there's

00:32:49,039 --> 00:32:52,960
this baggage that you bring along

00:32:50,799 --> 00:32:54,320
there's not necessarily baggage that you

00:32:52,960 --> 00:32:56,320
bring along there is

00:32:54,320 --> 00:32:58,370
if you write bad code but you can write

00:32:56,320 --> 00:33:00,240
bad code in any language so

00:32:58,370 --> 00:33:04,480
[Music]

00:33:00,240 --> 00:33:08,960
yeah i agree i would love to um i had

00:33:04,480 --> 00:33:12,159
i have an experience of a

00:33:08,960 --> 00:33:15,919
certain company i was trying to convince

00:33:12,159 --> 00:33:19,279
a theme to move to uh to simpler class

00:33:15,919 --> 00:33:22,880
and what i did i simply took the code

00:33:19,279 --> 00:33:22,880
and rewrote

00:33:23,039 --> 00:33:30,399
the same the the same uh part of code

00:33:26,880 --> 00:33:33,600
using c plus plus that is very thin

00:33:30,399 --> 00:33:36,799
and and using uh

00:33:33,600 --> 00:33:41,519
mainly overload resolution operators

00:33:36,799 --> 00:33:44,640
etc things that are very um

00:33:41,519 --> 00:33:47,760
small bytes that are easy for for

00:33:44,640 --> 00:33:48,559
someone that is uh not using c plus plus

00:33:47,760 --> 00:33:51,919
currently to

00:33:48,559 --> 00:33:52,880
to comprehend and i've showed that this

00:33:51,919 --> 00:33:55,039
works

00:33:52,880 --> 00:33:56,720
this is more readable and it works

00:33:55,039 --> 00:34:00,080
exactly the same regarding

00:33:56,720 --> 00:34:02,880
uh um performance so i would

00:34:00,080 --> 00:34:03,760
suggest that anyone that wants to to

00:34:02,880 --> 00:34:06,799
advance

00:34:03,760 --> 00:34:09,359
in that direction would do something

00:34:06,799 --> 00:34:10,720
similar i think that i think the only

00:34:09,359 --> 00:34:14,079
way to i mean

00:34:10,720 --> 00:34:15,599
we're we know that benchmarking is the

00:34:14,079 --> 00:34:20,240
only way to know

00:34:15,599 --> 00:34:20,960
for for sure and i think that's at least

00:34:20,240 --> 00:34:24,079
taking the

00:34:20,960 --> 00:34:27,359
small steps to to break your libraries

00:34:24,079 --> 00:34:30,560
and to to move them that would be good

00:34:27,359 --> 00:34:34,240
for proving uh it's

00:34:30,560 --> 00:34:36,639
um it's viable

00:34:34,240 --> 00:34:37,440
and i think if you do it right as as

00:34:36,639 --> 00:34:40,000
michael said

00:34:37,440 --> 00:34:42,560
it's it's just a question of whether

00:34:40,000 --> 00:34:44,879
you're doing it correctly or not

00:34:42,560 --> 00:34:46,639
well i think that patrice roy had a good

00:34:44,879 --> 00:34:49,839
comment and that was

00:34:46,639 --> 00:34:52,960
you can't do everything in one tool

00:34:49,839 --> 00:34:56,159
so there are some areas that c

00:34:52,960 --> 00:34:56,639
excels at that c plus plus cannot excel

00:34:56,159 --> 00:34:58,880
at

00:34:56,639 --> 00:34:59,680
there's things that c plus plus excels

00:34:58,880 --> 00:35:02,800
at that

00:34:59,680 --> 00:35:06,000
c you just you're lost

00:35:02,800 --> 00:35:08,880
in recreating the the tools

00:35:06,000 --> 00:35:10,240
that c plus has it's it wouldn't be

00:35:08,880 --> 00:35:14,400
worth the time

00:35:10,240 --> 00:35:16,720
so like containers uh processing

00:35:14,400 --> 00:35:17,599
uh you know doing searches things like

00:35:16,720 --> 00:35:21,040
that

00:35:17,599 --> 00:35:24,960
i definitely recommend c plus plus

00:35:21,040 --> 00:35:28,240
uh but for like low-level hardware

00:35:24,960 --> 00:35:30,880
you're working with bit management

00:35:28,240 --> 00:35:32,160
i have i have a little difficulty maybe

00:35:30,880 --> 00:35:33,599
i can be convinced

00:35:32,160 --> 00:35:35,920
all right i got to convince you brad

00:35:33,599 --> 00:35:39,920
later man you and i okay

00:35:35,920 --> 00:35:41,630
let's sit at a table all right

00:35:39,920 --> 00:35:46,400
if you can find each other

00:35:41,630 --> 00:35:48,960
[Laughter]

00:35:46,400 --> 00:35:49,920
um so one of the questions that we're

00:35:48,960 --> 00:35:52,560
getting from the audience

00:35:49,920 --> 00:35:54,320
uh michael i think that this uh michael

00:35:52,560 --> 00:35:56,079
wong i think that this one might be

00:35:54,320 --> 00:35:57,680
specifically good for for you to take a

00:35:56,079 --> 00:36:01,040
look at there's this question

00:35:57,680 --> 00:36:01,839
uh well guidelines discussing moving

00:36:01,040 --> 00:36:05,280
from c to c

00:36:01,839 --> 00:36:07,680
plus plus be integrated into misra c

00:36:05,280 --> 00:36:08,560
plus plus guidelines for safety and

00:36:07,680 --> 00:36:12,560
critical

00:36:08,560 --> 00:36:15,440
uh or other embedded guidelines uh

00:36:12,560 --> 00:36:16,560
i think that you have some experience

00:36:15,440 --> 00:36:20,000
looking at the

00:36:16,560 --> 00:36:23,119
working with the misra group does that

00:36:20,000 --> 00:36:26,480
um can you talk a little bit about

00:36:23,119 --> 00:36:27,760
where a future that might be going sure

00:36:26,480 --> 00:36:29,119
so i think this is referring to this

00:36:27,760 --> 00:36:30,800
morning's talk where i kind of showed

00:36:29,119 --> 00:36:33,040
some guidelines about how to move from c

00:36:30,800 --> 00:36:35,280
to c plus plus whether you do it in one

00:36:33,040 --> 00:36:37,200
shot or gradual adoptions and the little

00:36:35,280 --> 00:36:40,400
the different rules and all that i don't

00:36:37,200 --> 00:36:42,320
really see that moving to misra mizrah

00:36:40,400 --> 00:36:44,160
it's kind of like one of these wisdom

00:36:42,320 --> 00:36:46,640
things that you gather all the time

00:36:44,160 --> 00:36:48,240
and it evolves kind of like what i think

00:36:46,640 --> 00:36:49,680
what inbound is trying to say

00:36:48,240 --> 00:36:51,119
is no you know we've got all these great

00:36:49,680 --> 00:36:53,119
new c plus house features we need the

00:36:51,119 --> 00:36:55,760
time to gather the wisdom to learn

00:36:53,119 --> 00:36:56,480
how well they work and embed it um

00:36:55,760 --> 00:36:58,079
things like that

00:36:56,480 --> 00:37:00,000
is not going to go to miserable is

00:36:58,079 --> 00:37:02,240
purely interested in having rules that

00:37:00,000 --> 00:37:03,520
are statically checkable by an automated

00:37:02,240 --> 00:37:05,200
checker

00:37:03,520 --> 00:37:07,119
so that when you have a million lines of

00:37:05,200 --> 00:37:08,960
code you can run this checker

00:37:07,119 --> 00:37:10,240
it comes out with a thousand issues that

00:37:08,960 --> 00:37:12,079
you better look at

00:37:10,240 --> 00:37:13,520
and you can't get out until you look at

00:37:12,079 --> 00:37:15,760
every single one of those

00:37:13,520 --> 00:37:16,800
either have a deviation record or

00:37:15,760 --> 00:37:19,040
explain to your boss

00:37:16,800 --> 00:37:20,240
why you're why you're ignoring that

00:37:19,040 --> 00:37:21,920
ignoring that advice

00:37:20,240 --> 00:37:23,440
maybe your answer is i am much smarter

00:37:21,920 --> 00:37:24,480
than these guys they don't know what

00:37:23,440 --> 00:37:25,760
they're talking about

00:37:24,480 --> 00:37:27,839
i don't know what i don't know what it

00:37:25,760 --> 00:37:30,960
is but just be sure

00:37:27,839 --> 00:37:33,280
if something happens in a court of law

00:37:30,960 --> 00:37:34,160
they're going to look at best practices

00:37:33,280 --> 00:37:35,440
and what they what

00:37:34,160 --> 00:37:37,200
they're going to say is well what is the

00:37:35,440 --> 00:37:38,720
industry best practice well there there

00:37:37,200 --> 00:37:40,240
is nothing in the standard okay well

00:37:38,720 --> 00:37:42,000
what do what does everyone else do if

00:37:40,240 --> 00:37:43,280
they're a competent top engineer

00:37:42,000 --> 00:37:45,440
or they're gonna they might say well we

00:37:43,280 --> 00:37:46,560
look at mizrah and um and we look at

00:37:45,440 --> 00:37:48,960
some of those rules

00:37:46,560 --> 00:37:49,760
rightly or wrongly i know that i'm not

00:37:48,960 --> 00:37:52,000
trying to prejudice

00:37:49,760 --> 00:37:53,680
anything either way but that's what

00:37:52,000 --> 00:37:55,599
that's what they did with the unintended

00:37:53,680 --> 00:37:58,480
acceleration case with the uh

00:37:55,599 --> 00:38:00,240
with the automotive stuff they looked at

00:37:58,480 --> 00:38:02,079
the code base that those guys wrote for

00:38:00,240 --> 00:38:03,520
the braking systems and the electronic

00:38:02,079 --> 00:38:05,920
throttle control system

00:38:03,520 --> 00:38:07,520
and saw that it had never ran through

00:38:05,920 --> 00:38:10,079
misera it was thousand

00:38:07,520 --> 00:38:10,960
it had a psychometric mckay complexity

00:38:10,079 --> 00:38:12,800
of seven

00:38:10,960 --> 00:38:14,480
which meant that it was 30 functions

00:38:12,800 --> 00:38:16,960
embedded within each other

00:38:14,480 --> 00:38:18,320
that pretty much equated hundreds of

00:38:16,960 --> 00:38:22,400
global variables

00:38:18,320 --> 00:38:24,160
all totally unguarded okay so

00:38:22,400 --> 00:38:26,160
you know even though they never found

00:38:24,160 --> 00:38:26,960
the flaw they consider that a smoking

00:38:26,160 --> 00:38:28,880
gun

00:38:26,960 --> 00:38:30,720
bad enough that in a civil court you

00:38:28,880 --> 00:38:33,040
will be you will be indicted

00:38:30,720 --> 00:38:34,320
okay so let's just okay i'm gonna get

00:38:33,040 --> 00:38:36,720
off my high hole so

00:38:34,320 --> 00:38:38,480
so metrics like so guidelines like that

00:38:36,720 --> 00:38:41,760
i've been i gather from the many

00:38:38,480 --> 00:38:44,400
uh wise wiser people than me um uh

00:38:41,760 --> 00:38:46,480
that are here and around i don't think

00:38:44,400 --> 00:38:48,960
they will make it into mizrah okay

00:38:46,480 --> 00:38:49,520
um that's not what misery is all about

00:38:48,960 --> 00:38:50,960
um

00:38:49,520 --> 00:38:53,280
they might you know at best we could

00:38:50,960 --> 00:38:55,119
probably do it into a kind of a

00:38:53,280 --> 00:38:56,720
technical report or something like that

00:38:55,119 --> 00:38:57,760
the technical reports rapidly get

00:38:56,720 --> 00:39:01,119
outdated the

00:38:57,760 --> 00:39:03,040
the point of iso tr is to record

00:39:01,119 --> 00:39:05,520
the current state of the odd on

00:39:03,040 --> 00:39:07,359
something okay

00:39:05,520 --> 00:39:08,560
hopefully so this is this brings up a

00:39:07,359 --> 00:39:11,119
good point which is that

00:39:08,560 --> 00:39:12,400
sometimes the limitations that we're

00:39:11,119 --> 00:39:12,960
talking about sometimes they're

00:39:12,400 --> 00:39:15,359
technical

00:39:12,960 --> 00:39:16,400
but at other times they might be legal

00:39:15,359 --> 00:39:19,520
or

00:39:16,400 --> 00:39:24,560
uh or have other restrictions in place

00:39:19,520 --> 00:39:27,440
um daniel i know that you talked about

00:39:24,560 --> 00:39:28,160
in your original question you had uh

00:39:27,440 --> 00:39:32,320
asked about

00:39:28,160 --> 00:39:34,480
this concern of um

00:39:32,320 --> 00:39:35,760
you you mentioned some resistance to

00:39:34,480 --> 00:39:37,680
adopting certain

00:39:35,760 --> 00:39:39,040
c plus plus techniques certain c plus

00:39:37,680 --> 00:39:43,119
plus features

00:39:39,040 --> 00:39:44,880
do you have a sense of whether that was

00:39:43,119 --> 00:39:46,480
more of a technical thing or really more

00:39:44,880 --> 00:39:50,000
of a

00:39:46,480 --> 00:39:51,760
uh more of other concerns

00:39:50,000 --> 00:39:53,440
well so you're asking it's sort of a

00:39:51,760 --> 00:39:56,079
social problem right

00:39:53,440 --> 00:39:57,680
uh nobody tells you in college you're

00:39:56,079 --> 00:39:59,119
like you're going to go do computer

00:39:57,680 --> 00:40:01,040
and what actually you're going to do is

00:39:59,119 --> 00:40:03,440
you're going to argue with people for 30

00:40:01,040 --> 00:40:05,520
years your life right

00:40:03,440 --> 00:40:07,359
so you need to be good at the social

00:40:05,520 --> 00:40:10,160
aspect as well as

00:40:07,359 --> 00:40:11,599
the technical aspect i think there's a

00:40:10,160 --> 00:40:14,160
little bit of both

00:40:11,599 --> 00:40:15,680
on one sense like sometimes the

00:40:14,160 --> 00:40:17,599
resistance of features

00:40:15,680 --> 00:40:20,079
has to do with a legitimate concern of

00:40:17,599 --> 00:40:22,480
the system such as determinism

00:40:20,079 --> 00:40:25,520
right for dynamic allocation and then

00:40:22,480 --> 00:40:27,760
other times it has to do with

00:40:25,520 --> 00:40:29,280
i think a cultural thing we haven't

00:40:27,760 --> 00:40:30,880
typically done things like this

00:40:29,280 --> 00:40:32,480
and so we'd like to continue sort of

00:40:30,880 --> 00:40:36,800
with that inertia

00:40:32,480 --> 00:40:39,839
um honestly i think sometimes

00:40:36,800 --> 00:40:39,839
aside from the

00:40:40,720 --> 00:40:45,680
integral uh dynamic aspect of it

00:40:43,599 --> 00:40:48,400
something like exceptions is like that

00:40:45,680 --> 00:40:49,920
people are very used to in some areas

00:40:48,400 --> 00:40:52,640
doing return codes

00:40:49,920 --> 00:40:53,680
and so they don't want to change to

00:40:52,640 --> 00:40:55,280
something different

00:40:53,680 --> 00:40:56,960
even though i think exceptions have some

00:40:55,280 --> 00:41:00,480
really good properties

00:40:56,960 --> 00:41:02,319
if you can solve the dynamic aspect so

00:41:00,480 --> 00:41:04,000
you have the hard part for me i guess is

00:41:02,319 --> 00:41:07,040
to find ways

00:41:04,000 --> 00:41:08,880
to convince somebody who's been

00:41:07,040 --> 00:41:12,319
sort of ingrained with this way of

00:41:08,880 --> 00:41:13,839
thinking for so long

00:41:12,319 --> 00:41:15,599
yeah well i think that one of the things

00:41:13,839 --> 00:41:20,079
that you mentioned was this notion

00:41:15,599 --> 00:41:25,200
that uh well i don't know what that

00:41:20,079 --> 00:41:28,800
feature is doing yeah i i don't actually

00:41:25,200 --> 00:41:30,000
i i don't trust it to be as good as the

00:41:28,800 --> 00:41:33,040
coding right now

00:41:30,000 --> 00:41:34,880
for something along those lines so i

00:41:33,040 --> 00:41:37,280
i have a perfect simple example for that

00:41:34,880 --> 00:41:39,920
one i had a conversation at one point

00:41:37,280 --> 00:41:41,440
with someone what you'd do for

00:41:39,920 --> 00:41:43,040
disallowing the

00:41:41,440 --> 00:41:45,040
default construction of an object was

00:41:43,040 --> 00:41:46,640
you'd move it to the protected or

00:41:45,040 --> 00:41:48,960
usually private area

00:41:46,640 --> 00:41:50,720
and then define it as you know empty or

00:41:48,960 --> 00:41:52,160
whatever and so you'd spend

00:41:50,720 --> 00:41:54,000
you know it's three lines of code big

00:41:52,160 --> 00:41:56,000
deal right

00:41:54,000 --> 00:41:57,920
well the big deal was that occasionally

00:41:56,000 --> 00:41:59,760
you'd see someone move it

00:41:57,920 --> 00:42:01,119
from the private area to the public

00:41:59,760 --> 00:42:01,599
because what they got was a compiler

00:42:01,119 --> 00:42:04,000
error

00:42:01,599 --> 00:42:04,960
that said oh it's private they go ah i

00:42:04,000 --> 00:42:06,240
know how to solve this

00:42:04,960 --> 00:42:08,720
and they move it to the public they

00:42:06,240 --> 00:42:10,960
didn't understand why

00:42:08,720 --> 00:42:12,480
it was so the next thing you do is you

00:42:10,960 --> 00:42:15,280
make an inheritance

00:42:12,480 --> 00:42:17,200
of a no copy and so it says no copy in

00:42:15,280 --> 00:42:19,359
it and you public inherit from that

00:42:17,200 --> 00:42:20,720
and now it's a little more clear about

00:42:19,359 --> 00:42:22,319
what you're trying to do

00:42:20,720 --> 00:42:24,240
you can't copy me you can't default

00:42:22,319 --> 00:42:27,040
construct me

00:42:24,240 --> 00:42:28,160
but the simple keyword of delete in c

00:42:27,040 --> 00:42:30,480
plus plus 11

00:42:28,160 --> 00:42:32,240
is perfect right it tells you exactly

00:42:30,480 --> 00:42:33,839
what you're trying to do

00:42:32,240 --> 00:42:35,599
you could ask why is it deleted and you

00:42:33,839 --> 00:42:38,560
get into that conversation

00:42:35,599 --> 00:42:38,960
but it's the clearest thing you can say

00:42:38,560 --> 00:42:41,280
and

00:42:38,960 --> 00:42:42,079
you get somebody who says or default

00:42:41,280 --> 00:42:44,079
same thing

00:42:42,079 --> 00:42:46,000
both of those they'd say how do i know

00:42:44,079 --> 00:42:46,480
that the compiler is going to do what i

00:42:46,000 --> 00:42:48,640
want

00:42:46,480 --> 00:42:51,040
when i have a default constructor so you

00:42:48,640 --> 00:42:52,400
go to cppreference.com you say okay

00:42:51,040 --> 00:42:54,560
here's the list of things that's going

00:42:52,400 --> 00:42:56,160
to happen when you do a default

00:42:54,560 --> 00:42:57,920
constructor

00:42:56,160 --> 00:42:59,440
or maybe you disassemble and prove it

00:42:57,920 --> 00:43:00,079
but it's like those are all a bunch of

00:42:59,440 --> 00:43:01,680
work

00:43:00,079 --> 00:43:03,760
that you have to do to sort of convince

00:43:01,680 --> 00:43:06,880
somebody

00:43:03,760 --> 00:43:10,480
and i would i would like to to say that

00:43:06,880 --> 00:43:11,760
uh c plus plus is very it's better than

00:43:10,480 --> 00:43:15,040
c

00:43:11,760 --> 00:43:19,760
for error spotting for

00:43:15,040 --> 00:43:25,280
her it's it's a stronger

00:43:19,760 --> 00:43:28,000
stronger type safe language and i think

00:43:25,280 --> 00:43:29,119
maybe this is something that needs to be

00:43:28,000 --> 00:43:31,520
considered when

00:43:29,119 --> 00:43:32,640
when we're comparing because it's not

00:43:31,520 --> 00:43:35,839
just

00:43:32,640 --> 00:43:39,760
it's if the code is is more

00:43:35,839 --> 00:43:42,800
complex to reason but it's also

00:43:39,760 --> 00:43:44,720
it gives you benefits uh that

00:43:42,800 --> 00:43:46,880
of the tooling and and and that's

00:43:44,720 --> 00:43:49,680
something that needs to be

00:43:46,880 --> 00:43:51,280
to be to be known i think i think that's

00:43:49,680 --> 00:43:53,359
the biggest part is that

00:43:51,280 --> 00:43:54,319
in c plus plus it's easier to develop

00:43:53,359 --> 00:43:59,839
tooling

00:43:54,319 --> 00:44:02,880
to check things and i would definitely

00:43:59,839 --> 00:44:06,160
propose to your company is that

00:44:02,880 --> 00:44:08,880
document what you need to find out

00:44:06,160 --> 00:44:10,160
or what you need to make sure is safe

00:44:08,880 --> 00:44:13,200
and critical

00:44:10,160 --> 00:44:13,920
and figure out how to tool it on your

00:44:13,200 --> 00:44:15,920
own

00:44:13,920 --> 00:44:17,520
to some degree though the compiler is

00:44:15,920 --> 00:44:21,520
your tooling right

00:44:17,520 --> 00:44:23,280
if you code in a way where um

00:44:21,520 --> 00:44:24,880
where you will basically error out if

00:44:23,280 --> 00:44:25,280
the composition is incorrect then you

00:44:24,880 --> 00:44:27,280
know

00:44:25,280 --> 00:44:28,319
via composition and it compiled you

00:44:27,280 --> 00:44:31,760
actually have

00:44:28,319 --> 00:44:33,920
a correctly formed program

00:44:31,760 --> 00:44:34,960
and there's so much to if you do that

00:44:33,920 --> 00:44:37,280
properly

00:44:34,960 --> 00:44:38,720
you can have a lot of confidence right

00:44:37,280 --> 00:44:41,390
off the bat in things that you can't

00:44:38,720 --> 00:44:43,920
have confidence that otherwise and see

00:44:41,390 --> 00:44:47,200
[Music]

00:44:43,920 --> 00:44:51,839
we got a great tool already right yeah

00:44:47,200 --> 00:44:51,839
yeah if you can use it right yes

00:44:52,480 --> 00:44:59,040
well i mean uh yes i mean

00:44:55,520 --> 00:45:02,640
concepts and other things also help

00:44:59,040 --> 00:45:04,079
with uh that with making sure the

00:45:02,640 --> 00:45:08,079
compile works according

00:45:04,079 --> 00:45:09,839
to the way you it's designed to

00:45:08,079 --> 00:45:11,359
manufacture or produce the code that

00:45:09,839 --> 00:45:15,839
you're

00:45:11,359 --> 00:45:15,839
writing to work the way it should be

00:45:17,359 --> 00:45:21,359
we have a uh a couple of related

00:45:20,560 --> 00:45:25,359
questions

00:45:21,359 --> 00:45:27,200
actually from the audience uh that

00:45:25,359 --> 00:45:30,319
michael actually why don't you read this

00:45:27,200 --> 00:45:33,359
off because i'm i have to admit that i'm

00:45:30,319 --> 00:45:36,560
uh getting a little bit lost in the

00:45:33,359 --> 00:45:39,520
in the text on my screen okay um

00:45:36,560 --> 00:45:40,079
i think this question is from um honey

00:45:39,520 --> 00:45:42,319
it's about

00:45:40,079 --> 00:45:43,200
in a typical safe that's an agile

00:45:42,319 --> 00:45:44,800
framework

00:45:43,200 --> 00:45:47,599
when do embedded product engineering

00:45:44,800 --> 00:45:49,440
teams performs sil or safety integrity

00:45:47,599 --> 00:45:51,760
level classification

00:45:49,440 --> 00:45:52,640
and fmea that's failure mold effect

00:45:51,760 --> 00:45:54,960
analysis and

00:45:52,640 --> 00:45:56,560
fta which is fault tree analysis

00:45:54,960 --> 00:45:58,240
considering longer term projects

00:45:56,560 --> 00:45:59,280
including several revamps right up from

00:45:58,240 --> 00:46:02,079
the arch okay so

00:45:59,280 --> 00:46:02,480
this is so fmea and fta isn't well known

00:46:02,079 --> 00:46:04,079
of

00:46:02,480 --> 00:46:05,920
a way of connecting failures and

00:46:04,079 --> 00:46:07,760
cascading carriers and understanding

00:46:05,920 --> 00:46:09,119
how failures can occur and it's a

00:46:07,760 --> 00:46:10,800
well-known thing in safety critical

00:46:09,119 --> 00:46:11,920
systems if you're in aviation or

00:46:10,800 --> 00:46:13,040
automotive you're going to hear a lot

00:46:11,920 --> 00:46:15,040
about these things

00:46:13,040 --> 00:46:16,880
so sil i talked about before it's a

00:46:15,040 --> 00:46:19,200
safety integrity level so the answer

00:46:16,880 --> 00:46:20,079
in this case here um is that you have to

00:46:19,200 --> 00:46:21,920
set your safety

00:46:20,079 --> 00:46:23,680
overall reliable requirement for a

00:46:21,920 --> 00:46:26,319
system right away

00:46:23,680 --> 00:46:27,839
um be because that's telling you whether

00:46:26,319 --> 00:46:29,520
you know what kind what are the tool

00:46:27,839 --> 00:46:31,359
chains what is the conform what is the

00:46:29,520 --> 00:46:31,839
configuration analysis and things like

00:46:31,359 --> 00:46:33,839
that

00:46:31,839 --> 00:46:35,280
so even before that okay you have to

00:46:33,839 --> 00:46:37,119
identify the critical

00:46:35,280 --> 00:46:38,880
critical component of your system you

00:46:37,119 --> 00:46:39,599
look at your system you see where can it

00:46:38,880 --> 00:46:41,680
fail

00:46:39,599 --> 00:46:44,079
that is a single point of failure so in

00:46:41,680 --> 00:46:46,000
the car you look at it and go okay

00:46:44,079 --> 00:46:47,359
the steering wheel goes that's probably

00:46:46,000 --> 00:46:49,839
a really bad thing

00:46:47,359 --> 00:46:50,640
okay if your brake stops working that's

00:46:49,839 --> 00:46:52,400
probably two

00:46:50,640 --> 00:46:54,240
that's your two single point of failure

00:46:52,400 --> 00:46:55,280
okay um it doesn't really matter if your

00:46:54,240 --> 00:46:56,800
window doesn't open

00:46:55,280 --> 00:46:58,480
okay okay well maybe it matters if

00:46:56,800 --> 00:46:59,280
you're you're in the water or something

00:46:58,480 --> 00:47:02,079
like that but

00:46:59,280 --> 00:47:03,760
but you know and then you go okay what

00:47:02,079 --> 00:47:06,000
is the safety integrity level

00:47:03,760 --> 00:47:08,160
of those critical critical components

00:47:06,000 --> 00:47:09,359
and you because these are basically

00:47:08,160 --> 00:47:11,200
saying if they fail

00:47:09,359 --> 00:47:13,440
death will usually occur it's pretty

00:47:11,200 --> 00:47:15,599
easy they are three or four

00:47:13,440 --> 00:47:17,839
okay and that means that now you've got

00:47:15,599 --> 00:47:19,680
to go to do a system breakdown

00:47:17,839 --> 00:47:21,119
of the failure mode analysis and your

00:47:19,680 --> 00:47:23,520
fta see

00:47:21,119 --> 00:47:25,040
what kind of failures can lead to these

00:47:23,520 --> 00:47:27,359
kinds of things whether it's a single

00:47:25,040 --> 00:47:29,440
failure or multiple change of failure of

00:47:27,359 --> 00:47:30,559
or cascading failures so that's the

00:47:29,440 --> 00:47:34,559
answer to one

00:47:30,559 --> 00:47:37,359
i believe um two

00:47:34,559 --> 00:47:39,200
is uh heard from some in automotive that

00:47:37,359 --> 00:47:40,800
many of the autosaw or legacy automotive

00:47:39,200 --> 00:47:41,440
code is written in log free programming

00:47:40,800 --> 00:47:43,839
style

00:47:41,440 --> 00:47:44,960
okay so autosar is the other big

00:47:43,839 --> 00:47:47,359
automotive

00:47:44,960 --> 00:47:48,960
safety group that is governing all the

00:47:47,359 --> 00:47:52,559
tool chains for automotive

00:47:48,960 --> 00:47:53,839
um for the um for the tier one

00:47:52,559 --> 00:47:56,800
automotive like bosch

00:47:53,839 --> 00:47:58,640
and and feel like that misra is mostly

00:47:56,800 --> 00:48:00,319
started from the uk

00:47:58,640 --> 00:48:02,160
although they have um spread to the

00:48:00,319 --> 00:48:05,280
world autosar is mostly

00:48:02,160 --> 00:48:06,880
started with um bmw and they're mostly

00:48:05,280 --> 00:48:08,160
european-based but they have also spread

00:48:06,880 --> 00:48:10,400
throughout the world because the

00:48:08,160 --> 00:48:11,440
the the supply chain goes all go ghost

00:48:10,400 --> 00:48:13,440
comes from all over the world

00:48:11,440 --> 00:48:15,440
and so the question here is asking do

00:48:13,440 --> 00:48:18,880
they do they seem to be writing things

00:48:15,440 --> 00:48:20,000
um in a lot free programming style i

00:48:18,880 --> 00:48:21,839
didn't think they would be

00:48:20,000 --> 00:48:23,920
i'm actually surprised by this question

00:48:21,839 --> 00:48:26,960
um because the kind of things they

00:48:23,920 --> 00:48:27,839
do is actually pretty far from lock free

00:48:26,960 --> 00:48:29,839
programming

00:48:27,839 --> 00:48:31,440
um first of all you you don't

00:48:29,839 --> 00:48:33,280
necessarily have the right experts to

00:48:31,440 --> 00:48:36,319
write it well enough

00:48:33,280 --> 00:48:37,920
i can only and part of that is because i

00:48:36,319 --> 00:48:39,359
can only count the number of really true

00:48:37,920 --> 00:48:41,920
lottery programming experts

00:48:39,359 --> 00:48:44,000
in the world on one hand or maybe one

00:48:41,920 --> 00:48:47,440
and a half hands and i'm not one of them

00:48:44,000 --> 00:48:48,720
okay so i think it's a hard thing for a

00:48:47,440 --> 00:48:50,400
someone who's in a different domain to

00:48:48,720 --> 00:48:51,520
be able to manage that but i could be

00:48:50,400 --> 00:48:54,880
wrong here i was in

00:48:51,520 --> 00:48:55,359
auto saw for quite a while um um though

00:48:54,880 --> 00:48:56,960
i

00:48:55,359 --> 00:48:58,720
only attended a few of their meetings so

00:48:56,960 --> 00:49:00,960
my sense is that they are not

00:48:58,720 --> 00:49:02,240
not necessarily the top um walk-free

00:49:00,960 --> 00:49:03,760
programming experts

00:49:02,240 --> 00:49:06,000
last question when working with auto

00:49:03,760 --> 00:49:06,640
autosome classic which is c based yes

00:49:06,000 --> 00:49:09,040
that's true

00:49:06,640 --> 00:49:10,160
do you think um using c plus plus

00:49:09,040 --> 00:49:11,839
without

00:49:10,160 --> 00:49:13,599
layer you see plus application layer

00:49:11,839 --> 00:49:14,480
won't make any issue so that has to do

00:49:13,599 --> 00:49:17,359
with the fact that

00:49:14,480 --> 00:49:18,640
autosol because and this confirms the

00:49:17,359 --> 00:49:20,559
reason why i didn't think they would be

00:49:18,640 --> 00:49:22,160
using log3 the traditional autosar is

00:49:20,559 --> 00:49:25,280
all basically single threaded

00:49:22,160 --> 00:49:26,880
sequential programming and it uses c

00:49:25,280 --> 00:49:28,880
uh there is some multi-threaded stuff

00:49:26,880 --> 00:49:30,640
but it's not a huge amount um there's a

00:49:28,880 --> 00:49:31,280
new one called adaptive bottle saw which

00:49:30,640 --> 00:49:33,520
is for

00:49:31,280 --> 00:49:34,640
parallels parallel auto saw and that's

00:49:33,520 --> 00:49:36,880
because some of the

00:49:34,640 --> 00:49:38,160
automotive chips are now coming out with

00:49:36,880 --> 00:49:40,319
three two cores and

00:49:38,160 --> 00:49:41,520
three threads i know that's that's a lot

00:49:40,319 --> 00:49:43,119
for an automotive

00:49:41,520 --> 00:49:44,880
because don't forget you're you're

00:49:43,119 --> 00:49:47,920
working in a high heat

00:49:44,880 --> 00:49:49,599
highly polluted environment so

00:49:47,920 --> 00:49:51,119
it just makes everything a hundred times

00:49:49,599 --> 00:49:52,880
worse i know to us that's nothing like

00:49:51,119 --> 00:49:53,599
we're used to working with 200 000

00:49:52,880 --> 00:49:55,839
threats

00:49:53,599 --> 00:49:57,280
right half a million cpu that's what i'm

00:49:55,839 --> 00:49:58,640
used to working with in high performance

00:49:57,280 --> 00:50:01,119
computing but no

00:49:58,640 --> 00:50:02,720
i don't think um so adaptive autosar is

00:50:01,119 --> 00:50:05,839
heading towards c plus plus

00:50:02,720 --> 00:50:07,920
um in the application layer and yes um

00:50:05,839 --> 00:50:09,520
this enables parallelism to some degree

00:50:07,920 --> 00:50:11,760
and they're doing it in a very

00:50:09,520 --> 00:50:13,440
a very very slow and deliberate manner

00:50:11,760 --> 00:50:15,119
to make sure that it that it's safe

00:50:13,440 --> 00:50:16,559
so i hope that i think that answers some

00:50:15,119 --> 00:50:18,960
of the questions

00:50:16,559 --> 00:50:20,960
okay so you're saying hyper threading

00:50:18,960 --> 00:50:22,319
versus multi-threading or are you doing

00:50:20,960 --> 00:50:27,839
multi-threading

00:50:22,319 --> 00:50:27,839
on the chips it's right

00:50:31,200 --> 00:50:35,200
another audience question has to do with

00:50:33,359 --> 00:50:36,880
uh

00:50:35,200 --> 00:50:39,040
one of the ques one of the issues that

00:50:36,880 --> 00:50:42,000
is often cited both with

00:50:39,040 --> 00:50:43,119
uh dynamic memory management and

00:50:42,000 --> 00:50:45,359
exception handling

00:50:43,119 --> 00:50:46,319
is this issue of non-determinism the

00:50:45,359 --> 00:50:48,559
idea that we

00:50:46,319 --> 00:50:51,359
won't know how long a particular

00:50:48,559 --> 00:50:54,800
operation will take to complete

00:50:51,359 --> 00:50:57,200
this question that uh

00:50:54,800 --> 00:50:59,599
are those really the same problem uh is

00:50:57,200 --> 00:51:02,640
it that the

00:50:59,599 --> 00:51:04,640
uh that the exception handling mechanism

00:51:02,640 --> 00:51:07,359
is actually relying on

00:51:04,640 --> 00:51:09,280
memory allocation and if you could solve

00:51:07,359 --> 00:51:11,359
that determinism issue

00:51:09,280 --> 00:51:14,880
would that solve the whole thing or is

00:51:11,359 --> 00:51:14,880
it is it more complicated than that

00:51:20,400 --> 00:51:27,119
uh yeah go ahead so

00:51:24,720 --> 00:51:27,839
yes but it's not the whole problem um

00:51:27,119 --> 00:51:30,400
dynamic

00:51:27,839 --> 00:51:32,000
memory is being is is called dynamic

00:51:30,400 --> 00:51:33,119
memory allocation is being called by

00:51:32,000 --> 00:51:35,599
exception handling

00:51:33,119 --> 00:51:36,880
mechanism so that's one of the problems

00:51:35,599 --> 00:51:38,640
um and when you do that

00:51:36,880 --> 00:51:40,559
obviously you get a bunch of other

00:51:38,640 --> 00:51:42,640
issues but there are other problems

00:51:40,559 --> 00:51:44,800
and because the dynamic because the

00:51:42,640 --> 00:51:46,160
exception is allocated through the heap

00:51:44,800 --> 00:51:47,920
and when it's because it's allocated to

00:51:46,160 --> 00:51:50,240
the heap it has to call dynamic memory

00:51:47,920 --> 00:51:51,680
but exception handling has has quite a

00:51:50,240 --> 00:51:55,280
few other problems that

00:51:51,680 --> 00:51:57,200
that um that you have to deal with um

00:51:55,280 --> 00:51:59,200
uh some of this has to do with that

00:51:57,200 --> 00:52:02,160
giant jump table that you have to build

00:51:59,200 --> 00:52:04,240
um that that makes it difficult to to

00:52:02,160 --> 00:52:07,520
manage the cost of exception handling

00:52:04,240 --> 00:52:09,920
is quite a it's quite a lot there is the

00:52:07,520 --> 00:52:10,800
issue with having to create the error or

00:52:09,920 --> 00:52:12,319
the exception

00:52:10,800 --> 00:52:13,760
so in that case the memory for the

00:52:12,319 --> 00:52:15,119
exception is allocated in some

00:52:13,760 --> 00:52:16,880
unspecified way that's what

00:52:15,119 --> 00:52:18,480
that's in the standard in acceptro

00:52:16,880 --> 00:52:19,920
that's what it says unspecified

00:52:18,480 --> 00:52:22,000
so it doesn't have to be the heap it

00:52:19,920 --> 00:52:22,640
could be the stack so as a consequence

00:52:22,000 --> 00:52:25,040
there's no

00:52:22,640 --> 00:52:26,319
um social um there's no uh customization

00:52:25,040 --> 00:52:27,920
point for this allocation

00:52:26,319 --> 00:52:29,599
and there's a lot of implementation

00:52:27,920 --> 00:52:31,520
that's simply just do a heap allocation

00:52:29,599 --> 00:52:33,599
even for a single integer

00:52:31,520 --> 00:52:34,880
um then the next problem has to do with

00:52:33,599 --> 00:52:36,480
the error propagation

00:52:34,880 --> 00:52:38,319
the standard doesn't mention how this

00:52:36,480 --> 00:52:39,760
transfer control is achieved

00:52:38,319 --> 00:52:41,760
so it does mandate though that the

00:52:39,760 --> 00:52:42,800
destructor has to be invoked for objects

00:52:41,760 --> 00:52:44,640
along the path

00:52:42,800 --> 00:52:46,000
from the throat to the handler this is

00:52:44,640 --> 00:52:48,880
called stack unwinding

00:52:46,000 --> 00:52:49,520
i believe that's in accept.ctor the next

00:52:48,880 --> 00:52:52,559
thing is

00:52:49,520 --> 00:52:54,880
the error recognition part the exception

00:52:52,559 --> 00:52:57,520
types are not required to match exactly

00:52:54,880 --> 00:52:58,880
they can match a whole class hierarchy

00:52:57,520 --> 00:53:00,319
that's another pain point because you

00:52:58,880 --> 00:53:02,160
have to go through the rtti

00:53:00,319 --> 00:53:04,319
to verify that it is part of your

00:53:02,160 --> 00:53:05,599
hierarchy so you can have polymorphic

00:53:04,319 --> 00:53:07,200
catching of exception

00:53:05,599 --> 00:53:09,200
which then requires determine the types

00:53:07,200 --> 00:53:10,319
of all the base classes of an object at

00:53:09,200 --> 00:53:12,800
runtime

00:53:10,319 --> 00:53:14,079
so exception class hierarchies are

00:53:12,800 --> 00:53:16,079
typically complex

00:53:14,079 --> 00:53:17,760
and this is one of the few places where

00:53:16,079 --> 00:53:20,880
uh multiple inheritance is still

00:53:17,760 --> 00:53:22,319
common so they exist um uh

00:53:20,880 --> 00:53:24,079
you know this is this is obviously a

00:53:22,319 --> 00:53:25,680
problem then the last thing is exception

00:53:24,079 --> 00:53:27,440
error identification you have to

00:53:25,680 --> 00:53:29,200
traverse the type info structure

00:53:27,440 --> 00:53:30,559
which is expensive and the type

00:53:29,200 --> 00:53:32,960
infrastructure is

00:53:30,559 --> 00:53:34,640
now it could be extended and things like

00:53:32,960 --> 00:53:36,160
that if you try to extend the time you

00:53:34,640 --> 00:53:38,079
know that's going to make it more

00:53:36,160 --> 00:53:40,160
even more complicated the runtime

00:53:38,079 --> 00:53:42,559
analysis is only possible if all the

00:53:40,160 --> 00:53:44,319
types are known beforehand

00:53:42,559 --> 00:53:46,880
if it's not known then you've got now

00:53:44,319 --> 00:53:49,359
have to run through that rtti table

00:53:46,880 --> 00:53:51,200
um so the rgti always brings a non-zero

00:53:49,359 --> 00:53:53,359
overhead to the binary size

00:53:51,200 --> 00:53:54,880
and so the type infrastructure contains

00:53:53,359 --> 00:53:57,599
more information basically than is

00:53:54,880 --> 00:54:00,720
really needed uh to do the matching the

00:53:57,599 --> 00:54:02,720
catch handler so um and so

00:54:00,720 --> 00:54:04,000
one thing you could do is restrict the

00:54:02,720 --> 00:54:06,240
um

00:54:04,000 --> 00:54:08,839
the matching of the clasp so that it's

00:54:06,240 --> 00:54:12,720
always a static type some people i

00:54:08,839 --> 00:54:14,640
um andrea's advice and support it has

00:54:12,720 --> 00:54:16,160
suggested that because most of the time

00:54:14,640 --> 00:54:17,040
you don't actually need to make this

00:54:16,160 --> 00:54:19,040
happen match

00:54:17,040 --> 00:54:20,480
multiple possible types most of the time

00:54:19,040 --> 00:54:21,280
the exception really only needs to match

00:54:20,480 --> 00:54:23,359
one day

00:54:21,280 --> 00:54:24,800
okay so there are many many solutions so

00:54:23,359 --> 00:54:26,720
a lot of that has been discussed through

00:54:24,800 --> 00:54:29,040
sg14 as well yeah

00:54:26,720 --> 00:54:29,040
yeah so

00:54:30,079 --> 00:54:34,000
have a talk on that i think so i mean

00:54:34,960 --> 00:54:39,200
no i mean everything

00:54:40,720 --> 00:54:46,240
my feeling is that you need to write

00:54:43,839 --> 00:54:47,680
great code and you need to understand

00:54:46,240 --> 00:54:51,200
what's going on

00:54:47,680 --> 00:54:53,200
exceptions are only for cases you can't

00:54:51,200 --> 00:54:57,040
predict is gonna happen

00:54:53,200 --> 00:54:59,359
and that's that's my thought so

00:54:57,040 --> 00:55:00,640
i i would just add that i i do have a

00:54:59,359 --> 00:55:02,240
talk about that because

00:55:00,640 --> 00:55:04,880
because i was interested in those

00:55:02,240 --> 00:55:07,760
questions that and and

00:55:04,880 --> 00:55:08,160
of course everything michael said is is

00:55:07,760 --> 00:55:10,880
is

00:55:08,160 --> 00:55:12,480
yeah that's there's a lot going on there

00:55:10,880 --> 00:55:15,839
and the stock and winding process

00:55:12,480 --> 00:55:18,240
by itself it's uh not always the same

00:55:15,839 --> 00:55:20,240
between different compilers msbc does it

00:55:18,240 --> 00:55:23,680
a bit differently and um

00:55:20,240 --> 00:55:26,319
but but but i think

00:55:23,680 --> 00:55:26,960
two things here are interesting uh and

00:55:26,319 --> 00:55:29,839
at least

00:55:26,960 --> 00:55:31,119
that's what i figure out when i when i

00:55:29,839 --> 00:55:34,319
uh wrote the talk is

00:55:31,119 --> 00:55:37,040
the first thing is that we have more uh

00:55:34,319 --> 00:55:37,359
freedom to control that than we think

00:55:37,040 --> 00:55:40,799
and

00:55:37,359 --> 00:55:43,599
and i i will i've tried to address

00:55:40,799 --> 00:55:45,680
how and and the second thing is and

00:55:43,599 --> 00:55:48,160
michael mentioned that

00:55:45,680 --> 00:55:50,400
i i would hope that the standard grid

00:55:48,160 --> 00:55:52,640
address is that we don't really need all

00:55:50,400 --> 00:55:54,160
the freedom that is described in

00:55:52,640 --> 00:55:55,839
currently inherited in the exception

00:55:54,160 --> 00:55:58,400
mechanism and we could

00:55:55,839 --> 00:55:59,359
perhaps i mean one of the one of the

00:55:58,400 --> 00:56:02,720
things that needed

00:55:59,359 --> 00:56:04,640
is um ability to

00:56:02,720 --> 00:56:05,920
the reason for dynamic allocation is the

00:56:04,640 --> 00:56:09,440
ability to pass

00:56:05,920 --> 00:56:13,520
a amount of information um

00:56:09,440 --> 00:56:17,520
that is by the by the developers uh

00:56:13,520 --> 00:56:17,839
um decision but but i'm not sure we need

00:56:17,520 --> 00:56:20,880
that

00:56:17,839 --> 00:56:24,640
so so all those things that

00:56:20,880 --> 00:56:27,359
that michael said that that could be um

00:56:24,640 --> 00:56:29,040
adjust adjusted and i i would think that

00:56:27,359 --> 00:56:29,680
that's something that we might want to

00:56:29,040 --> 00:56:31,760
consider

00:56:29,680 --> 00:56:33,680
for the following years and that's i

00:56:31,760 --> 00:56:34,480
mean it's already in the process clearly

00:56:33,680 --> 00:56:37,760
with herbs

00:56:34,480 --> 00:56:41,520
uh um low-cost deterministic uh

00:56:37,760 --> 00:56:43,440
sorry uh herbs uh determination

00:56:41,520 --> 00:56:45,599
yeah and and and the other paper of

00:56:43,440 --> 00:56:47,200
low-cost deterministic exceptions so i

00:56:45,599 --> 00:56:50,160
think

00:56:47,200 --> 00:56:50,720
we could we're we will address that in

00:56:50,160 --> 00:56:53,040
the future

00:56:50,720 --> 00:56:53,920
okay one quick we're coming to the end

00:56:53,040 --> 00:56:56,079
of our time

00:56:53,920 --> 00:56:57,280
uh one quick question that i want to

00:56:56,079 --> 00:57:01,040
close with

00:56:57,280 --> 00:57:02,720
uh if i'm new to

00:57:01,040 --> 00:57:05,599
developing for embedded systems if i'm

00:57:02,720 --> 00:57:08,480
not familiar with these limitations

00:57:05,599 --> 00:57:08,880
what can i do to get my feet wet uh what

00:57:08,480 --> 00:57:11,440
would

00:57:08,880 --> 00:57:13,839
what would we suggest in terms of

00:57:11,440 --> 00:57:15,040
platforms devices things like that that

00:57:13,839 --> 00:57:17,440
would be good

00:57:15,040 --> 00:57:20,319
starting points to learn more about

00:57:17,440 --> 00:57:20,319
embedded development

00:57:24,000 --> 00:57:30,559
there are tons of platforms and and dev

00:57:27,200 --> 00:57:32,079
boxes that you can grab um

00:57:30,559 --> 00:57:33,920
and we'll run out of time but i'll put

00:57:32,079 --> 00:57:35,920
some links inside of the chat

00:57:33,920 --> 00:57:37,359
you like a rasp those things are great

00:57:35,920 --> 00:57:41,200
and they're cheap

00:57:37,359 --> 00:57:41,920
yeah it strictly counts but i think it

00:57:41,200 --> 00:57:44,160
depends

00:57:41,920 --> 00:57:46,000
to some degree is this goes back to that

00:57:44,160 --> 00:57:49,440
question of what is embedded

00:57:46,000 --> 00:57:52,559
to some degree is this notion of

00:57:49,440 --> 00:57:54,240
yeah i think working on a

00:57:52,559 --> 00:57:55,599
a raspberry pi or something like that

00:57:54,240 --> 00:57:58,079
will get you access to

00:57:55,599 --> 00:58:00,079
some of the issues that you'd face on a

00:57:58,079 --> 00:58:01,839
typical embedded device

00:58:00,079 --> 00:58:03,520
it's certainly not going i don't think

00:58:01,839 --> 00:58:04,240
it's going to be the same experience as

00:58:03,520 --> 00:58:06,559
if you

00:58:04,240 --> 00:58:08,240
you're trying to get a job with with an

00:58:06,559 --> 00:58:10,960
8-bit micro microcontroller

00:58:08,240 --> 00:58:13,599
uh team that they're going to have

00:58:10,960 --> 00:58:16,880
issues that a raspberry pi doesn't

00:58:13,599 --> 00:58:16,880
that i think that's fair to say

00:58:18,480 --> 00:58:25,040
um but yeah i would i would just love to

00:58:22,480 --> 00:58:27,280
add uh shortly that i think the

00:58:25,040 --> 00:58:30,079
definition of embedded is gonna

00:58:27,280 --> 00:58:30,559
also might change in the following years

00:58:30,079 --> 00:58:33,440
because

00:58:30,559 --> 00:58:34,880
of iot because because we're gonna have

00:58:33,440 --> 00:58:39,520
a lot more devices

00:58:34,880 --> 00:58:42,720
that would be considered self-maintained

00:58:39,520 --> 00:58:43,440
and and and i think they'll be

00:58:42,720 --> 00:58:43,970
interesting

00:58:43,440 --> 00:58:47,060
as well

00:58:43,970 --> 00:58:47,060
[Music]

00:58:48,319 --> 00:58:52,960
yes look for more machine learning um ai

00:58:51,119 --> 00:58:55,839
types of edge devices now coming

00:58:52,960 --> 00:58:57,119
coming coming to episode near you skynet

00:58:55,839 --> 00:59:00,720
is coming to you

00:58:57,119 --> 00:59:00,720
all right 2022.

00:59:00,880 --> 00:59:04,880
so machine learning projects one of the

00:59:02,960 --> 00:59:06,160
ones to watch out for that's going to be

00:59:04,880 --> 00:59:08,720
a lot of the

00:59:06,160 --> 00:59:11,119
there's going to be some intersection

00:59:08,720 --> 00:59:13,040
there is what you're saying

00:59:11,119 --> 00:59:14,880
well yeah totally i mean the the google

00:59:13,040 --> 00:59:16,960
tensor processing unit

00:59:14,880 --> 00:59:18,000
hardware is just designed to do

00:59:16,960 --> 00:59:21,040
convolutions really

00:59:18,000 --> 00:59:21,440
well and or vision processing really

00:59:21,040 --> 00:59:23,119
well

00:59:21,440 --> 00:59:24,640
and you know those are those are now

00:59:23,119 --> 00:59:28,160
embedded devices they have massive

00:59:24,640 --> 00:59:28,160
processing powers in those things

00:59:30,160 --> 00:59:36,000
okay i i think that brings us to

00:59:33,280 --> 00:59:36,960
the end of our time uh thank you

00:59:36,000 --> 00:59:39,599
everyone for

00:59:36,960 --> 00:59:40,079
being here thank you to the audience for

00:59:39,599 --> 00:59:41,839
uh

00:59:40,079 --> 00:59:43,280
all for all of your questions for coming

00:59:41,839 --> 00:59:46,000
and watching us

00:59:43,280 --> 00:59:47,359
talk and hope you found it interesting

00:59:46,000 --> 00:59:48,559
um

00:59:47,359 --> 00:59:50,480
i think that some of us will be

00:59:48,559 --> 00:59:53,520
available in remo to

00:59:50,480 --> 00:59:55,520
answer questions uh for at least

00:59:53,520 --> 00:59:57,040
a little while i'm not gonna don't want

00:59:55,520 --> 00:59:58,000
to make any promises for anyone other

00:59:57,040 --> 01:00:01,200
than me

00:59:58,000 --> 01:00:15,839
um but yes thank you for coming uh

01:00:01,200 --> 01:00:15,839
and enjoy the rest of cppcon

01:00:23,520 --> 01:00:25,599

YouTube URL: https://www.youtube.com/watch?v=v_4D43nASt4


