Title: C++20: An (Almost) Complete Overview - Marc Gregoire - CppCon 2020
Publication date: 2020-09-26
Playlist: CppCon 2020 Day 2
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
The technical work on C++20 was finished in January 2020, and is now being pushed through ISO certification.

This presentation gives an overview of (almost) all new features in both the language and the Standard Library. Some more exotic features will be left out. New language features include modules, coroutines, concepts, templated lambdas, constexpr changes, designated initializers, the spaceship operator, string literals as template parameters, feature test macros, conditional explicit, immediate functions, and more.

The second part of the session discusses the changes to the Standard Library. This includes topics such as ranges, atomic smart pointers, cancellable threads, a synchronization library, calendars, time zones, span, a formatting library, features test macros, and more.

The material is mostly the same as the "C++20: What's in it for you?" session from CppCon 2019, but it has been updated with the final standard. If you want a complete overview of all C++20 features, including references to other more deep-dive sessions at CppCon 2020 on certain topics, then this session is for you.

---
Marc Gregoire is a software architect from Belgium. He worked 6 years as a consultant for Siemens and Nokia Siemens Networks on critical 2G and 3G software running on Solaris for telecom operators. This required working in international teams stretching from South America and the United States to Europe, the Middle East, Africa, and Asia. Now, Marc is a software architect at Nikon Metrology (www.nikonmetrology.com), a division of Nikon and a leading provider of precision optical instruments, X-ray machines, and metrology solutions for X-ray, CT, and 3D geometric inspection.

His main expertise is C/C++, specifically Microsoft VC++ and the MFC framework. He has experience in developing C++ programs running 24/7 on Windows and Linux platforms: for example, KNX/EIB home automation software. In addition to C/C++, Marc also likes C#.

Since April 2007, he has received the annual Microsoft MVP (Most Valuable Professional) award for his Visual C++ expertise.

Marc is the founder of the Belgian C++ Users Group (www.becpp.org), author of “Professional C++” 2nd, 3rd, and 4th Editions (Wiley/Wrox), co-author of “C++ Standard Library Quick Reference” 1st and 2nd Editions (Apress), technical editor for numerous books for several publishers, and regular speaker at the CppCon C++ conference. He maintains a blog at www.nuonsoft.com/blog/, and is passionate about traveling and gastronomic restaurants.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,920 --> 00:00:13,120
thank you john

00:00:10,719 --> 00:00:13,759
hello everyone and welcome to the second

00:00:13,120 --> 00:00:15,519
keynote

00:00:13,759 --> 00:00:18,240
i'll be talking about the major theme of

00:00:15,519 --> 00:00:19,840
this year which is c plus plus 20.

00:00:18,240 --> 00:00:22,160
and in this keynote i will be giving a

00:00:19,840 --> 00:00:22,880
high level overview of almost all new

00:00:22,160 --> 00:00:24,800
language

00:00:22,880 --> 00:00:27,039
and library features added to the c plus

00:00:24,800 --> 00:00:29,039
plus 20 standard

00:00:27,039 --> 00:00:30,160
so without further ado let's get started

00:00:29,039 --> 00:00:33,520
but first a little bit

00:00:30,160 --> 00:00:34,000
about myself i'm a software architect

00:00:33,520 --> 00:00:36,640
for

00:00:34,000 --> 00:00:40,160
nikon metrology and i'm based in belgium

00:00:36,640 --> 00:00:41,920
i'm a visual c plus plus mvp since 2007

00:00:40,160 --> 00:00:43,440
and author of a couple of books and i'm

00:00:41,920 --> 00:00:45,360
happy to announce that

00:00:43,440 --> 00:00:46,960
the fifth edition will be coming out

00:00:45,360 --> 00:00:47,760
later this year the fifth edition of

00:00:46,960 --> 00:00:49,520
professional c

00:00:47,760 --> 00:00:51,840
plus plus will be coming out later this

00:00:49,520 --> 00:00:52,399
year and it has been updated to include

00:00:51,840 --> 00:00:56,239
all

00:00:52,399 --> 00:00:58,320
c plus plus 20 features and i'm also the

00:00:56,239 --> 00:00:59,440
founder of the belgian c plus plus users

00:00:58,320 --> 00:01:02,719
group and

00:00:59,440 --> 00:01:06,479
we try to organize like three to four

00:01:02,719 --> 00:01:06,479
user groups events per year

00:01:07,200 --> 00:01:12,000
so let's get one thing straight c plus

00:01:10,720 --> 00:01:14,000
plus 20 is a major

00:01:12,000 --> 00:01:15,280
update it's big there are lots and lots

00:01:14,000 --> 00:01:17,600
of new features

00:01:15,280 --> 00:01:18,720
i think it's even bigger or at least at

00:01:17,600 --> 00:01:22,159
least as big as c

00:01:18,720 --> 00:01:23,280
plus plus 11. and good news on friday

00:01:22,159 --> 00:01:26,400
september the 4th

00:01:23,280 --> 00:01:28,080
so one and a half weeks ago let's see

00:01:26,400 --> 00:01:32,320
plus plus 20 standard price

00:01:28,080 --> 00:01:36,560
past iso voting so we expect it to be

00:01:32,320 --> 00:01:36,560
formally published by the end of 2020.

00:01:38,000 --> 00:01:42,079
what will i be talking about so first i

00:01:40,079 --> 00:01:44,320
will be i will be touching on the four

00:01:42,079 --> 00:01:48,079
major new features which are modules

00:01:44,320 --> 00:01:50,320
ranges co-routines and concepts

00:01:48,079 --> 00:01:52,720
then there are a couple of changes to

00:01:50,320 --> 00:01:55,920
how lambda expressions work

00:01:52,720 --> 00:01:57,759
changes to const expert functions

00:01:55,920 --> 00:01:59,600
there is new functionality for writing

00:01:57,759 --> 00:02:01,439
concurrent codes

00:01:59,600 --> 00:02:02,799
and finally there is a whole lot of

00:02:01,439 --> 00:02:05,680
other smaller features

00:02:02,799 --> 00:02:07,360
and and changes to both the language and

00:02:05,680 --> 00:02:09,200
the standard library

00:02:07,360 --> 00:02:11,599
so i'm not going to read this whole list

00:02:09,200 --> 00:02:12,640
right now but we will be touching on all

00:02:11,599 --> 00:02:16,640
of these

00:02:12,640 --> 00:02:18,959
topics briefly during this keynote

00:02:16,640 --> 00:02:20,879
but this session obviously since i have

00:02:18,959 --> 00:02:22,000
a lot of topics here obviously it's a

00:02:20,879 --> 00:02:25,200
high level overview

00:02:22,000 --> 00:02:27,840
so i will not have any deep dive

00:02:25,200 --> 00:02:28,879
into any specific feature here but there

00:02:27,840 --> 00:02:30,800
are other sessions

00:02:28,879 --> 00:02:32,879
this week that will cover specific

00:02:30,800 --> 00:02:34,800
features from this list

00:02:32,879 --> 00:02:36,480
and if that is the case there will be a

00:02:34,800 --> 00:02:38,879
small green rectangle

00:02:36,480 --> 00:02:39,840
on the slide with a reference to the

00:02:38,879 --> 00:02:41,360
session

00:02:39,840 --> 00:02:44,400
which you can follow to get more

00:02:41,360 --> 00:02:44,400
detailed information

00:02:46,239 --> 00:02:49,760
all right so there are a couple of new

00:02:47,760 --> 00:02:51,760
keywords added to the language first we

00:02:49,760 --> 00:02:53,599
have concepts and requires and

00:02:51,760 --> 00:02:56,560
these two keywords are used in the

00:02:53,599 --> 00:02:58,239
context of the concepts feature

00:02:56,560 --> 00:02:59,599
we have const init for constant

00:02:58,239 --> 00:03:01,599
initialization

00:02:59,599 --> 00:03:02,800
we have const eval for constant

00:03:01,599 --> 00:03:04,640
evaluation

00:03:02,800 --> 00:03:06,480
and then we have three keynotes related

00:03:04,640 --> 00:03:09,599
to co routines go away

00:03:06,480 --> 00:03:12,959
go return and go yield and finally

00:03:09,599 --> 00:03:15,440
one last new keyword is heart eight t

00:03:12,959 --> 00:03:17,680
and that one complements the hard 16 t

00:03:15,440 --> 00:03:18,000
and have 32 t that have been added to

00:03:17,680 --> 00:03:22,400
the c

00:03:18,000 --> 00:03:22,400
plus plus standard with c plus plus 11.

00:03:23,360 --> 00:03:27,840
there are also two new identifiers

00:03:25,760 --> 00:03:29,280
namely import and module

00:03:27,840 --> 00:03:31,440
and what is the difference between a

00:03:29,280 --> 00:03:33,840
keyword and an identifier

00:03:31,440 --> 00:03:34,799
a keyword you cannot use anywhere an

00:03:33,840 --> 00:03:37,040
identifier

00:03:34,799 --> 00:03:38,720
is reserved only in certain contexts so

00:03:37,040 --> 00:03:39,360
for example you could have a variable

00:03:38,720 --> 00:03:41,599
name

00:03:39,360 --> 00:03:43,440
with the name import but in certain

00:03:41,599 --> 00:03:46,400
context that is a reserved

00:03:43,440 --> 00:03:48,799
word previously we already had some

00:03:46,400 --> 00:03:51,360
identifiers and they were final and

00:03:48,799 --> 00:03:51,360
overwrite

00:03:52,720 --> 00:03:57,120
all right so let's get started with the

00:03:54,400 --> 00:04:01,519
first major feature of c plus plus 20

00:03:57,120 --> 00:04:03,439
modules what are modules modules

00:04:01,519 --> 00:04:04,720
basically they will replace other files

00:04:03,439 --> 00:04:06,640
on the long run

00:04:04,720 --> 00:04:08,159
and with a module you have to explicitly

00:04:06,640 --> 00:04:10,000
state what you want to

00:04:08,159 --> 00:04:11,680
export from the module for example you

00:04:10,000 --> 00:04:13,120
have to say which classes which

00:04:11,680 --> 00:04:16,160
functions

00:04:13,120 --> 00:04:18,079
which constants which

00:04:16,160 --> 00:04:20,079
enumeration classes and so on you want

00:04:18,079 --> 00:04:21,680
to export and only this exported

00:04:20,079 --> 00:04:24,160
functionality

00:04:21,680 --> 00:04:26,720
will be available for users that import

00:04:24,160 --> 00:04:28,400
your module

00:04:26,720 --> 00:04:29,919
then there is the concept of a module

00:04:28,400 --> 00:04:31,440
interface file and a module

00:04:29,919 --> 00:04:34,240
implementation file

00:04:31,440 --> 00:04:36,160
so you you could separate your code into

00:04:34,240 --> 00:04:37,840
an interface file and an implementation

00:04:36,160 --> 00:04:40,320
file just like you did in the past with

00:04:37,840 --> 00:04:42,880
header files and cpp files

00:04:40,320 --> 00:04:44,560
but with modules that is not a strict

00:04:42,880 --> 00:04:47,840
requirement anymore

00:04:44,560 --> 00:04:50,400
because for a module interface file

00:04:47,840 --> 00:04:52,720
only the function signatures are exp are

00:04:50,400 --> 00:04:55,600
part of the exported interface

00:04:52,720 --> 00:04:57,280
so even if you write any function body

00:04:55,600 --> 00:04:59,520
in a module interface file

00:04:57,280 --> 00:05:01,680
that will not be exported that will not

00:04:59,520 --> 00:05:04,000
be in the exported interface

00:05:01,680 --> 00:05:06,320
so if you modify that body you will not

00:05:04,000 --> 00:05:08,960
trigger any rebuild of users that are

00:05:06,320 --> 00:05:11,120
importing that module and that was one

00:05:08,960 --> 00:05:13,039
of the drawbacks with header files if

00:05:11,120 --> 00:05:13,919
you implement your functions inside your

00:05:13,039 --> 00:05:16,000
header file

00:05:13,919 --> 00:05:18,160
whenever you modify that the body of

00:05:16,000 --> 00:05:20,000
your function you trigger a rebuild of

00:05:18,160 --> 00:05:20,479
everybody that is including that header

00:05:20,000 --> 00:05:22,960
file

00:05:20,479 --> 00:05:23,759
that is not the case with modules still

00:05:22,960 --> 00:05:26,240
i think

00:05:23,759 --> 00:05:28,639
in certain cases it's a good idea to

00:05:26,240 --> 00:05:30,240
separate your module interface file

00:05:28,639 --> 00:05:32,240
and your code inside a module

00:05:30,240 --> 00:05:34,880
implementation file because that way

00:05:32,240 --> 00:05:39,199
your interface files stay clean without

00:05:34,880 --> 00:05:41,759
any implementation details

00:05:39,199 --> 00:05:43,440
if you want to add more structure to

00:05:41,759 --> 00:05:45,440
your module there are two things you can

00:05:43,440 --> 00:05:48,560
do you can either use sub modules or you

00:05:45,440 --> 00:05:50,320
can use so called partitions

00:05:48,560 --> 00:05:52,080
and nice thing about modules is that you

00:05:50,320 --> 00:05:54,000
don't need any include guards anymore

00:05:52,080 --> 00:05:55,600
you don't need to invent unique names if

00:05:54,000 --> 00:05:58,160
you have two modules that have

00:05:55,600 --> 00:05:58,639
the same name these two names will not

00:05:58,160 --> 00:06:01,039
clash

00:05:58,639 --> 00:06:03,120
they live in their own module of course

00:06:01,039 --> 00:06:04,720
if you import these two modules in

00:06:03,120 --> 00:06:08,080
another source file

00:06:04,720 --> 00:06:10,240
then you will have a linker error

00:06:08,080 --> 00:06:12,080
another interesting aspects of module is

00:06:10,240 --> 00:06:16,000
that they are processed only once so

00:06:12,080 --> 00:06:16,000
this will result in faster build times

00:06:16,240 --> 00:06:20,720
and also preprocessor macros will never

00:06:18,479 --> 00:06:22,960
have any influence on the code inside

00:06:20,720 --> 00:06:23,919
your module and any preprocessor macros

00:06:22,960 --> 00:06:26,080
that you have defined

00:06:23,919 --> 00:06:27,759
inside a module will never leak from

00:06:26,080 --> 00:06:30,160
that module

00:06:27,759 --> 00:06:32,080
and because of this the order of module

00:06:30,160 --> 00:06:33,840
imports is not important and this was

00:06:32,080 --> 00:06:35,680
important with header files because it

00:06:33,840 --> 00:06:37,759
would be that one header file

00:06:35,680 --> 00:06:39,280
defines some kind of preprocessor macros

00:06:37,759 --> 00:06:42,800
that was important for

00:06:39,280 --> 00:06:44,319
the next header file that you include

00:06:42,800 --> 00:06:46,880
so let's have a quick look at how you

00:06:44,319 --> 00:06:48,880
write a module so here i have a module

00:06:46,880 --> 00:06:51,759
it's in a file called cppcon

00:06:48,880 --> 00:06:52,960
dot cppm and the module starts with a

00:06:51,759 --> 00:06:55,360
module that relates

00:06:52,960 --> 00:06:56,639
declaration which just gives a name to

00:06:55,360 --> 00:06:58,800
this module

00:06:56,639 --> 00:06:59,840
next i define a namespace with two

00:06:58,800 --> 00:07:03,039
methods

00:06:59,840 --> 00:07:05,120
the first one get welcome helper

00:07:03,039 --> 00:07:07,680
is not exported and it just returns a

00:07:05,120 --> 00:07:09,919
string and the second one get welcome is

00:07:07,680 --> 00:07:13,199
exported and basically just forwards the

00:07:09,919 --> 00:07:13,199
work to the helper function

00:07:13,680 --> 00:07:18,080
how to consume this module well you

00:07:15,759 --> 00:07:21,280
simply do an import cppcon

00:07:18,080 --> 00:07:23,039
instead of any hash includes

00:07:21,280 --> 00:07:25,440
and then once you have done that you can

00:07:23,039 --> 00:07:26,400
start using the exported functionality

00:07:25,440 --> 00:07:28,800
so here at this

00:07:26,400 --> 00:07:31,840
location i will not be able to call get

00:07:28,800 --> 00:07:31,840
welcome helper

00:07:33,280 --> 00:07:36,319
so c plus plus 20 provides all the

00:07:35,520 --> 00:07:38,319
machinery

00:07:36,319 --> 00:07:39,680
for for support for modules but it does

00:07:38,319 --> 00:07:42,080
not specify if

00:07:39,680 --> 00:07:44,240
and even how to modularize the standard

00:07:42,080 --> 00:07:47,039
library itself

00:07:44,240 --> 00:07:49,199
but all c plus headers in the standard

00:07:47,039 --> 00:07:51,199
are so called importable so instead of

00:07:49,199 --> 00:07:53,599
writing hash include version

00:07:51,199 --> 00:07:54,639
version is one of the new c plus plus 12

00:07:53,599 --> 00:07:56,639
20 headers

00:07:54,639 --> 00:07:58,160
so instead of writing hash include

00:07:56,639 --> 00:08:00,720
version you can simply write

00:07:58,160 --> 00:08:01,360
import version what this does is

00:08:00,720 --> 00:08:03,199
everything

00:08:01,360 --> 00:08:04,639
that is in the version header will be

00:08:03,199 --> 00:08:07,199
implicitly exported

00:08:04,639 --> 00:08:09,120
including macros this is different

00:08:07,199 --> 00:08:11,120
compared to writing your own

00:08:09,120 --> 00:08:13,440
modules in which case markers are not

00:08:11,120 --> 00:08:16,400
exported but if you import

00:08:13,440 --> 00:08:18,879
these headers then all macros will be

00:08:16,400 --> 00:08:20,400
exported as well

00:08:18,879 --> 00:08:22,160
and just by doing this instead of

00:08:20,400 --> 00:08:23,680
writing hash include version

00:08:22,160 --> 00:08:25,280
you write import version you will

00:08:23,680 --> 00:08:27,599
improve your build throughput because

00:08:25,280 --> 00:08:28,639
now this version module will only be

00:08:27,599 --> 00:08:30,800
processed once

00:08:28,639 --> 00:08:32,719
so you can think of this as some kind of

00:08:30,800 --> 00:08:33,279
compiler independent pre-compiled

00:08:32,719 --> 00:08:36,080
headers

00:08:33,279 --> 00:08:36,719
header file feature so on friday there

00:08:36,080 --> 00:08:38,479
is

00:08:36,719 --> 00:08:40,159
a session by teamwork that goes a little

00:08:38,479 --> 00:08:42,719
bit deeper on on

00:08:40,159 --> 00:08:42,719
this feature

00:08:45,200 --> 00:08:48,959
and it's also possible as i explained

00:08:47,360 --> 00:08:50,720
with with the c plus plus headers they

00:08:48,959 --> 00:08:52,720
are importable it's also possible to

00:08:50,720 --> 00:08:54,480
make your own headers importable but how

00:08:52,720 --> 00:08:56,560
to do that is compiler dependent so

00:08:54,480 --> 00:08:57,120
please check your compiler documentation

00:08:56,560 --> 00:09:00,320
to

00:08:57,120 --> 00:09:00,320
find out how to do that

00:09:06,560 --> 00:09:10,720
the next big feature is ranges what is a

00:09:08,800 --> 00:09:12,640
range a range is basically an object

00:09:10,720 --> 00:09:15,839
that refers to a sequence

00:09:12,640 --> 00:09:18,160
of of uh continuous elements

00:09:15,839 --> 00:09:18,880
so basically it's kind of like a

00:09:18,160 --> 00:09:21,360
beginner and

00:09:18,880 --> 00:09:22,000
iterated pair but it's not the goal of

00:09:21,360 --> 00:09:24,399
the range to

00:09:22,000 --> 00:09:26,160
completely replace all begin iterator

00:09:24,399 --> 00:09:28,560
pairs and it will become clear

00:09:26,160 --> 00:09:30,720
with an example so why do we want the

00:09:28,560 --> 00:09:32,399
range here i have

00:09:30,720 --> 00:09:34,560
a vector of data i have three elements

00:09:32,399 --> 00:09:37,519
and i want to sort these elements

00:09:34,560 --> 00:09:39,040
so how to do this before c plus plus 20

00:09:37,519 --> 00:09:41,120
you use the sort

00:09:39,040 --> 00:09:42,880
uh algorithm that is available in the

00:09:41,120 --> 00:09:44,800
standard library and you just pass a

00:09:42,880 --> 00:09:47,200
begin and end the iterator pair

00:09:44,800 --> 00:09:48,959
and then the whole range will be sorted

00:09:47,200 --> 00:09:51,200
but in this case i really want to sort

00:09:48,959 --> 00:09:53,440
the whole container

00:09:51,200 --> 00:09:54,560
so with ranges you can really just say

00:09:53,440 --> 00:09:56,399
ranges sort

00:09:54,560 --> 00:09:59,040
data and my whole range my whole

00:09:56,399 --> 00:10:00,399
container will be sorted

00:09:59,040 --> 00:10:02,399
nice thing about this is that it's

00:10:00,399 --> 00:10:04,480
impossible to have mismatching begin

00:10:02,399 --> 00:10:05,920
and end iterators for example i could

00:10:04,480 --> 00:10:08,160
call the

00:10:05,920 --> 00:10:09,760
sort algorithm and pass it a begin

00:10:08,160 --> 00:10:11,839
iterator of one container

00:10:09,760 --> 00:10:13,440
and accidentally pass it the end

00:10:11,839 --> 00:10:15,600
iterator of another container the

00:10:13,440 --> 00:10:17,600
compiler will not complain

00:10:15,600 --> 00:10:19,040
but of course it will not do what you

00:10:17,600 --> 00:10:22,000
expect at runtime

00:10:19,040 --> 00:10:23,760
with ranges and the standard the

00:10:22,000 --> 00:10:26,480
algorithms that support the ranges you

00:10:23,760 --> 00:10:28,399
cannot make these mistakes

00:10:26,480 --> 00:10:29,920
and additionally there is the concept of

00:10:28,399 --> 00:10:32,640
range adapters that can

00:10:29,920 --> 00:10:34,880
lazily transform or filter your data

00:10:32,640 --> 00:10:38,640
before it is passed to any algorithm

00:10:34,880 --> 00:10:38,640
and we will see an example of that later

00:10:39,760 --> 00:10:43,040
there are a couple of major components

00:10:41,360 --> 00:10:45,200
that you need to know about

00:10:43,040 --> 00:10:46,240
when when working with ranges so first

00:10:45,200 --> 00:10:48,800
range itself

00:10:46,240 --> 00:10:51,360
that is defined as a concept a concept

00:10:48,800 --> 00:10:53,519
that defines the iteration requirements

00:10:51,360 --> 00:10:55,120
and all of the standard library

00:10:53,519 --> 00:10:58,880
containers that support begin

00:10:55,120 --> 00:11:00,640
and end they are valid ranges

00:10:58,880 --> 00:11:02,240
next we have the range-based algorithm

00:11:00,640 --> 00:11:04,160
so almost all standard library

00:11:02,240 --> 00:11:05,680
algorithms that previously accepted

00:11:04,160 --> 00:11:09,920
iterator pairs

00:11:05,680 --> 00:11:11,440
they are adapted to also accept ranges

00:11:09,920 --> 00:11:13,440
and a lot of these standard library

00:11:11,440 --> 00:11:17,040
algorithms that accept the range now

00:11:13,440 --> 00:11:19,440
they also accept a so-called projection

00:11:17,040 --> 00:11:20,560
and a projection is basically a callback

00:11:19,440 --> 00:11:22,800
that can transform

00:11:20,560 --> 00:11:24,480
the elements from your container before

00:11:22,800 --> 00:11:28,240
they are handed over to an

00:11:24,480 --> 00:11:30,240
algorithm next we have a view

00:11:28,240 --> 00:11:31,839
and a view that is basically the

00:11:30,240 --> 00:11:34,880
transform you can

00:11:31,839 --> 00:11:37,360
view can transform and filter a range

00:11:34,880 --> 00:11:39,040
and all of that is lazily done a view

00:11:37,360 --> 00:11:40,959
does not own anything

00:11:39,040 --> 00:11:43,200
and a view can also not modify the

00:11:40,959 --> 00:11:44,880
underlying elements

00:11:43,200 --> 00:11:47,519
and we will see an example of that on

00:11:44,880 --> 00:11:47,519
the next slide

00:11:47,600 --> 00:11:53,120
range factories can be constructed to

00:11:50,639 --> 00:11:54,880
produce values on demand for example a

00:11:53,120 --> 00:11:56,560
range factory exists that

00:11:54,880 --> 00:11:58,639
generates a sequence an infinite

00:11:56,560 --> 00:12:01,279
sequence of integers

00:11:58,639 --> 00:12:03,440
we will see an example of that as well

00:12:01,279 --> 00:12:05,279
and finally pipelining allows you to

00:12:03,440 --> 00:12:05,839
pipeline several transformations or

00:12:05,279 --> 00:12:09,440
several

00:12:05,839 --> 00:12:12,480
filter operations in a in a nice

00:12:09,440 --> 00:12:12,480
so-called pipeline

00:12:14,000 --> 00:12:18,480
let's see how this pipelining works so

00:12:16,480 --> 00:12:19,600
here i have a factor of data i have 10

00:12:18,480 --> 00:12:21,920
integers

00:12:19,600 --> 00:12:23,200
and as we saw on the previous slides the

00:12:21,920 --> 00:12:25,839
vector supports begin

00:12:23,200 --> 00:12:26,560
and end operations so this is a valid

00:12:25,839 --> 00:12:29,040
range

00:12:26,560 --> 00:12:31,680
so we start with with our range the

00:12:29,040 --> 00:12:33,440
complete range

00:12:31,680 --> 00:12:35,440
next we apply a so-called filter

00:12:33,440 --> 00:12:36,399
operation and what this filter operation

00:12:35,440 --> 00:12:38,480
is doing

00:12:36,399 --> 00:12:39,920
it will filter all the odd elements

00:12:38,480 --> 00:12:43,120
resulting in the following

00:12:39,920 --> 00:12:45,600
data we only keep the numbers 2 4 6 8

00:12:43,120 --> 00:12:45,600
and 10.

00:12:46,639 --> 00:12:50,880
next operation in our pipeline is a

00:12:48,720 --> 00:12:52,480
transform operation and this transform

00:12:50,880 --> 00:12:54,639
operation is just doubling

00:12:52,480 --> 00:12:55,600
all the remaining elements in our range

00:12:54,639 --> 00:12:59,839
so we get 4

00:12:55,600 --> 00:12:59,839
8 12 16 and 20.

00:13:00,240 --> 00:13:03,440
we drop the first two elements so we get

00:13:02,160 --> 00:13:06,880
12 16

00:13:03,440 --> 00:13:09,120
and 20. we reverse the elements

00:13:06,880 --> 00:13:09,920
and finally we transform them again and

00:13:09,120 --> 00:13:11,839
we convert

00:13:09,920 --> 00:13:13,680
the remaining elements in our range to

00:13:11,839 --> 00:13:17,360
strings the result

00:13:13,680 --> 00:13:17,920
is um three elements three string

00:13:17,360 --> 00:13:21,040
elements

00:13:17,920 --> 00:13:22,800
representing 20 16 and 12.

00:13:21,040 --> 00:13:24,959
so what you can see here is that

00:13:22,800 --> 00:13:28,639
transform does not always have to

00:13:24,959 --> 00:13:31,600
transform a certain element to

00:13:28,639 --> 00:13:33,040
to another element of the same type so

00:13:31,600 --> 00:13:36,160
in the first transform here

00:13:33,040 --> 00:13:37,839
i'm transforming transforming my my

00:13:36,160 --> 00:13:40,160
double into another double

00:13:37,839 --> 00:13:42,480
but here i'm transforming it into a

00:13:40,160 --> 00:13:42,480
string

00:13:43,600 --> 00:13:47,519
so just by constructing this result

00:13:45,519 --> 00:13:50,399
object here nothing has been

00:13:47,519 --> 00:13:52,399
evaluated yet everything is done lazily

00:13:50,399 --> 00:13:54,560
only at the moment when i iterate over

00:13:52,399 --> 00:13:55,760
the elements in my result object at that

00:13:54,560 --> 00:13:59,440
moment

00:13:55,760 --> 00:13:59,440
the whole pipeline is executed

00:14:00,079 --> 00:14:03,920
and because all this is lazily executed

00:14:02,240 --> 00:14:06,399
we can work with so-called infinite

00:14:03,920 --> 00:14:08,800
sequences

00:14:06,399 --> 00:14:10,079
so here i'm using a range adapter sorry

00:14:08,800 --> 00:14:11,760
a range factory

00:14:10,079 --> 00:14:13,680
and this one is creating an infinite

00:14:11,760 --> 00:14:16,800
sequence of integers starting with

00:14:13,680 --> 00:14:17,440
10 and i can just do anything what i

00:14:16,800 --> 00:14:19,040
want with this

00:14:17,440 --> 00:14:21,120
infinite sequence of elements i can

00:14:19,040 --> 00:14:22,639
filter it i can transform it i can drop

00:14:21,120 --> 00:14:24,880
elements reverse elements everything

00:14:22,639 --> 00:14:27,040
what you want

00:14:24,880 --> 00:14:27,920
and finally i'm just taking the first 10

00:14:27,040 --> 00:14:31,680
elements here

00:14:27,920 --> 00:14:33,519
to to limit my my

00:14:31,680 --> 00:14:35,120
my final result because of course if

00:14:33,519 --> 00:14:36,079
you're working with infinite sequences

00:14:35,120 --> 00:14:38,320
and i would be

00:14:36,079 --> 00:14:39,440
iterating over the result yeah that

00:14:38,320 --> 00:14:41,519
would result in an

00:14:39,440 --> 00:14:43,279
infinite loop so somehow you need to

00:14:41,519 --> 00:14:45,199
limit your elements in the range and in

00:14:43,279 --> 00:14:46,399
this case i'm just taking the first 10

00:14:45,199 --> 00:14:50,399
elements of the

00:14:46,399 --> 00:14:51,120
final range so on thursday there is a

00:14:50,399 --> 00:14:53,839
session about

00:14:51,120 --> 00:14:56,839
ranges given by tristan if you have more

00:14:53,839 --> 00:14:59,839
if you are interested in a more deep

00:14:56,839 --> 00:14:59,839
dive

00:15:02,959 --> 00:15:07,040
the third major feature is coroutines

00:15:05,279 --> 00:15:07,760
what is a core routine a co-routine is a

00:15:07,040 --> 00:15:09,279
function

00:15:07,760 --> 00:15:10,959
but not just any function it's a

00:15:09,279 --> 00:15:11,600
function that contains one of the three

00:15:10,959 --> 00:15:15,440
keywords

00:15:11,600 --> 00:15:18,160
go await go yield or core return

00:15:15,440 --> 00:15:19,839
ko wait suspends my co-routine while

00:15:18,160 --> 00:15:21,920
it's waiting for some other asynchronous

00:15:19,839 --> 00:15:24,160
computation to finish

00:15:21,920 --> 00:15:25,199
go yield it returns a value from my

00:15:24,160 --> 00:15:27,199
co-routine

00:15:25,199 --> 00:15:28,399
back to the caller it suspends my

00:15:27,199 --> 00:15:31,199
co-routine

00:15:28,399 --> 00:15:32,399
and subsequently when the caller calls

00:15:31,199 --> 00:15:34,720
my co routine again

00:15:32,399 --> 00:15:36,639
it is resumed at the statement after

00:15:34,720 --> 00:15:39,120
call yield

00:15:36,639 --> 00:15:40,240
and finally if you want to really stop

00:15:39,120 --> 00:15:42,079
your co routine if

00:15:40,240 --> 00:15:43,839
if your core routine is really finished

00:15:42,079 --> 00:15:45,680
you can do a core return

00:15:43,839 --> 00:15:47,199
and you cannot you cannot in a core

00:15:45,680 --> 00:15:48,720
routine you're not allowed to just use

00:15:47,199 --> 00:15:49,360
the return statement you have to use

00:15:48,720 --> 00:15:51,839
code

00:15:49,360 --> 00:15:51,839
return

00:15:52,399 --> 00:15:55,440
core routines what can they be used for

00:15:54,399 --> 00:15:57,519
well

00:15:55,440 --> 00:15:59,360
they can be used to write so-called

00:15:57,519 --> 00:16:00,320
generators we'll see an example of that

00:15:59,360 --> 00:16:01,680
on the next slide

00:16:00,320 --> 00:16:03,360
but they can also be used for

00:16:01,680 --> 00:16:05,519
asynchronous io

00:16:03,360 --> 00:16:09,839
for doing lazy computations event

00:16:05,519 --> 00:16:09,839
driving application and much more

00:16:10,639 --> 00:16:16,079
however with c plus 20

00:16:14,000 --> 00:16:17,920
the standard contains all the language

00:16:16,079 --> 00:16:19,839
additions all the machinery needed to

00:16:17,920 --> 00:16:21,519
support co routines so you can write

00:16:19,839 --> 00:16:23,440
your own core routines but the standard

00:16:21,519 --> 00:16:25,920
library does not yet include any helper

00:16:23,440 --> 00:16:29,120
classes such as these generators or

00:16:25,920 --> 00:16:32,399
or asynchronous io

00:16:29,120 --> 00:16:34,399
so we first want to get some more

00:16:32,399 --> 00:16:36,160
real world experience with working with

00:16:34,399 --> 00:16:38,480
co routines before any

00:16:36,160 --> 00:16:39,759
of these helper classes are standardized

00:16:38,480 --> 00:16:43,199
maybe in the next

00:16:39,759 --> 00:16:44,959
c plus plus standard and the thing is

00:16:43,199 --> 00:16:46,560
writing these co-routines yourself is

00:16:44,959 --> 00:16:48,720
actually pretty advanced and

00:16:46,560 --> 00:16:50,160
you need to know what you're doing so if

00:16:48,720 --> 00:16:52,480
you want to use coroutine

00:16:50,160 --> 00:16:54,399
at this moment i suggest that you search

00:16:52,480 --> 00:16:56,959
for some existing libraries that that

00:16:54,399 --> 00:16:59,680
provide you some core routines

00:16:56,959 --> 00:17:01,680
instead of writing your owns so visual

00:16:59,680 --> 00:17:03,600
studio comes with an experimental helper

00:17:01,680 --> 00:17:04,559
class called the generator and let's see

00:17:03,600 --> 00:17:07,520
how that one

00:17:04,559 --> 00:17:07,520
works in practice

00:17:10,000 --> 00:17:13,919
so here we have a simple co routine and

00:17:11,760 --> 00:17:15,839
the coroutine it just contains a for

00:17:13,919 --> 00:17:18,720
loop that starts at a given starting

00:17:15,839 --> 00:17:20,959
value that iterates a number of times

00:17:18,720 --> 00:17:22,319
on each iteration it just gets the

00:17:20,959 --> 00:17:24,160
system time

00:17:22,319 --> 00:17:27,039
it outputs the system time to the

00:17:24,160 --> 00:17:32,160
standard output and then finally

00:17:27,039 --> 00:17:34,960
it yields the current iteration value

00:17:32,160 --> 00:17:36,799
in main we just call our coroutine which

00:17:34,960 --> 00:17:39,600
returns you the generator

00:17:36,799 --> 00:17:41,520
and then main iterates over the values

00:17:39,600 --> 00:17:43,679
produced by the generator and on each

00:17:41,520 --> 00:17:46,320
iteration

00:17:43,679 --> 00:17:47,280
it outputs the value given by the

00:17:46,320 --> 00:17:49,200
generator

00:17:47,280 --> 00:17:51,120
and then waits for the user to press

00:17:49,200 --> 00:17:53,360
enter

00:17:51,120 --> 00:17:55,760
so the first time when main asks for the

00:17:53,360 --> 00:17:57,760
first value for from my generator

00:17:55,760 --> 00:17:59,760
my core routine starts executing the

00:17:57,760 --> 00:18:00,960
first loop until it reaches the core

00:17:59,760 --> 00:18:04,000
yield

00:18:00,960 --> 00:18:05,039
then the i the current i will be given

00:18:04,000 --> 00:18:07,280
back to main

00:18:05,039 --> 00:18:08,880
which outputs it to standard output

00:18:07,280 --> 00:18:12,400
waits for the user to press

00:18:08,880 --> 00:18:13,440
any key and then my main asks for a

00:18:12,400 --> 00:18:17,039
second value

00:18:13,440 --> 00:18:19,120
generated by the generator in which case

00:18:17,039 --> 00:18:20,960
the co routine will resume executing

00:18:19,120 --> 00:18:21,679
right after the statement of co yield

00:18:20,960 --> 00:18:24,160
and then

00:18:21,679 --> 00:18:27,280
it just starts in excitation and so on

00:18:24,160 --> 00:18:29,440
so the output is as follows the first

00:18:27,280 --> 00:18:30,559
output that i get is the date and the

00:18:29,440 --> 00:18:33,440
value 10

00:18:30,559 --> 00:18:35,440
and then every time when i press enter

00:18:33,440 --> 00:18:36,720
the next iteration of my co routine

00:18:35,440 --> 00:18:38,880
executes

00:18:36,720 --> 00:18:43,840
yielding the next value and main outputs

00:18:38,880 --> 00:18:43,840
that one to the standard outputs

00:18:45,280 --> 00:18:48,640
there are a couple of sessions there is

00:18:46,799 --> 00:18:52,400
one on tuesday and one on friday

00:18:48,640 --> 00:18:52,400
if you want more information about co

00:18:54,840 --> 00:18:57,840
routines

00:18:58,559 --> 00:19:02,080
and the fourth and final big new feature

00:19:00,880 --> 00:19:05,600
in c plus plus 20

00:19:02,080 --> 00:19:07,200
is concept concepts concepts are

00:19:05,600 --> 00:19:09,280
requirements named requirements to

00:19:07,200 --> 00:19:12,160
constrain template parameters of

00:19:09,280 --> 00:19:13,760
either class templates or function

00:19:12,160 --> 00:19:15,120
templates

00:19:13,760 --> 00:19:17,200
and they are predicates that are

00:19:15,120 --> 00:19:19,440
evaluated at compile time so they don't

00:19:17,200 --> 00:19:20,960
have any impact at runtime

00:19:19,440 --> 00:19:22,960
let's have a look how we can create a

00:19:20,960 --> 00:19:24,640
simple concept

00:19:22,960 --> 00:19:26,640
here i'm creating a concept called

00:19:24,640 --> 00:19:29,840
incrementable

00:19:26,640 --> 00:19:30,320
and i'm requiring that a type t supports

00:19:29,840 --> 00:19:34,320
both

00:19:30,320 --> 00:19:36,480
the postfix and prefix operations

00:19:34,320 --> 00:19:38,080
so what this statement says is basically

00:19:36,480 --> 00:19:40,480
that for a type t

00:19:38,080 --> 00:19:41,360
x plus plus and plus plus x should

00:19:40,480 --> 00:19:42,799
compile

00:19:41,360 --> 00:19:44,880
so this is not code that will be

00:19:42,799 --> 00:19:48,400
executed at runtime this quota is

00:19:44,880 --> 00:19:48,400
evaluated at compile time

00:19:48,799 --> 00:19:52,000
how to use this concept the first way to

00:19:50,960 --> 00:19:54,559
use this concept

00:19:52,000 --> 00:19:55,120
is instead of writing type name t i can

00:19:54,559 --> 00:19:58,320
just say

00:19:55,120 --> 00:19:58,720
incrementable t that's one way second

00:19:58,320 --> 00:20:02,080
way

00:19:58,720 --> 00:20:04,000
is to use a so-called required clause

00:20:02,080 --> 00:20:07,200
and you can just use type name t

00:20:04,000 --> 00:20:10,480
requires incremental t

00:20:07,200 --> 00:20:13,280
the requires clause can be either before

00:20:10,480 --> 00:20:15,200
the function signature or after

00:20:13,280 --> 00:20:17,200
and maybe the cleanest way to use it is

00:20:15,200 --> 00:20:18,640
to combine it with abbreviated function

00:20:17,200 --> 00:20:20,320
template syntax

00:20:18,640 --> 00:20:21,760
and then you get the following syntax

00:20:20,320 --> 00:20:24,240
you just say incrementable

00:20:21,760 --> 00:20:25,200
out of t so you don't have to specify

00:20:24,240 --> 00:20:27,760
any template

00:20:25,200 --> 00:20:27,760
line here

00:20:29,280 --> 00:20:34,080
of course this is a very simple simple

00:20:31,600 --> 00:20:36,159
concept here so let's look at how

00:20:34,080 --> 00:20:37,280
you can make some more powerful concepts

00:20:36,159 --> 00:20:39,039
and let's see

00:20:37,280 --> 00:20:41,520
let's write a concept that requires a

00:20:39,039 --> 00:20:43,280
non-throwing swap method

00:20:41,520 --> 00:20:46,559
and that requires a size method that

00:20:43,280 --> 00:20:48,799
returns a size t

00:20:46,559 --> 00:20:50,799
so since i want to say something about

00:20:48,799 --> 00:20:53,520
swap that means i will need two

00:20:50,799 --> 00:20:55,360
two parameters so we define our concept

00:20:53,520 --> 00:20:58,480
with two parameters in this case

00:20:55,360 --> 00:20:59,679
two references x and y once we have

00:20:58,480 --> 00:21:03,440
these we can say

00:20:59,679 --> 00:21:08,159
or we can require that x dot swap y

00:21:03,440 --> 00:21:11,200
compiles and is marked as no except

00:21:08,159 --> 00:21:13,360
we can also say that x dot size compiles

00:21:11,200 --> 00:21:15,760
and returns something that is

00:21:13,360 --> 00:21:18,480
convertible to a size

00:21:15,760 --> 00:21:21,120
and we can have as many requirements as

00:21:18,480 --> 00:21:21,120
we need here

00:21:24,880 --> 00:21:29,679
we can also combine existing concepts

00:21:27,840 --> 00:21:31,840
and one way to do this is using the

00:21:29,679 --> 00:21:33,360
requires clause so we can say something

00:21:31,840 --> 00:21:35,919
like this we have a template

00:21:33,360 --> 00:21:36,720
with one template parameter t which

00:21:35,919 --> 00:21:40,559
requires that

00:21:36,720 --> 00:21:42,400
t is incrementable and decrementable

00:21:40,559 --> 00:21:44,640
that's one way to combine concepts of

00:21:42,400 --> 00:21:46,960
course you can also just create

00:21:44,640 --> 00:21:47,760
a new concept i'm creating a new concept

00:21:46,960 --> 00:21:50,799
c which

00:21:47,760 --> 00:21:52,559
is incremental and decrementable and

00:21:50,799 --> 00:21:54,400
once we have this one you can just use

00:21:52,559 --> 00:21:57,600
again the abbreviated functions

00:21:54,400 --> 00:21:59,840
template syntax to use this new new

00:21:57,600 --> 00:21:59,840
concept

00:22:00,720 --> 00:22:04,640
and in the case of concepts the c plus

00:22:02,480 --> 00:22:06,400
plus 20 standard library actually does

00:22:04,640 --> 00:22:08,000
define a whole lot of predefined

00:22:06,400 --> 00:22:11,120
concepts so we have things like

00:22:08,000 --> 00:22:12,960
same derived from integral constructable

00:22:11,120 --> 00:22:14,960
convertible too

00:22:12,960 --> 00:22:16,960
and also more high level concept like

00:22:14,960 --> 00:22:19,280
sortable mergable permutable and

00:22:16,960 --> 00:22:21,200
and much much more there are a couple of

00:22:19,280 --> 00:22:22,400
dozen different standard concepts that

00:22:21,200 --> 00:22:25,200
are available

00:22:22,400 --> 00:22:25,600
so i suggest if you need a concept first

00:22:25,200 --> 00:22:27,280
check

00:22:25,600 --> 00:22:30,000
what exists in the current standard

00:22:27,280 --> 00:22:31,840
library and if it doesn't exist what you

00:22:30,000 --> 00:22:33,679
exactly need maybe you can use

00:22:31,840 --> 00:22:37,679
a combination of existing concepts

00:22:33,679 --> 00:22:37,679
instead of writing your own concept from

00:22:38,840 --> 00:22:41,919
scratch

00:22:40,080 --> 00:22:43,760
big benefit of using concept is that

00:22:41,919 --> 00:22:46,000
they help the compiler with

00:22:43,760 --> 00:22:47,520
producing better error messages let's

00:22:46,000 --> 00:22:49,679
look at an example i have here an

00:22:47,520 --> 00:22:52,880
abbreviated function template

00:22:49,679 --> 00:22:54,960
that requires d to be incrementable

00:22:52,880 --> 00:22:56,640
and next i define a class bar that

00:22:54,960 --> 00:22:58,480
doesn't define anything so obviously

00:22:56,640 --> 00:23:01,600
this one does not satisfy the

00:22:58,480 --> 00:23:03,200
incrementable concept and then in my

00:23:01,600 --> 00:23:04,960
main i'm just constructing a bar and

00:23:03,200 --> 00:23:06,880
then calling my foo with an instance of

00:23:04,960 --> 00:23:09,120
my bar

00:23:06,880 --> 00:23:10,159
and instead of any cryptic template

00:23:09,120 --> 00:23:12,080
error messages

00:23:10,159 --> 00:23:13,280
what i get is a very clean error message

00:23:12,080 --> 00:23:15,360
from the compiler it

00:23:13,280 --> 00:23:16,640
simply states that i cannot call through

00:23:15,360 --> 00:23:19,760
with a bar because

00:23:16,640 --> 00:23:20,799
bar is not incrementable and everybody

00:23:19,760 --> 00:23:22,880
that has worked with

00:23:20,799 --> 00:23:24,880
with templates especially more

00:23:22,880 --> 00:23:25,440
complicated templates if you provide the

00:23:24,880 --> 00:23:27,440
wrong

00:23:25,440 --> 00:23:28,720
types for those templates then you might

00:23:27,440 --> 00:23:31,679
have like hundreds of

00:23:28,720 --> 00:23:33,120
cryptic template error messages then you

00:23:31,679 --> 00:23:35,760
have to hunt down

00:23:33,120 --> 00:23:37,200
to find the location in your code that

00:23:35,760 --> 00:23:40,240
is causing the error

00:23:37,200 --> 00:23:43,279
and concepts will help a lot here there

00:23:40,240 --> 00:23:45,200
are two sessions one on friday and

00:23:43,279 --> 00:23:46,400
two parts on tuesday if you are

00:23:45,200 --> 00:23:51,840
interested in more

00:23:46,400 --> 00:23:51,840
content about concepts

00:23:55,360 --> 00:23:59,120
there are a few changes to lambda

00:23:56,880 --> 00:24:01,919
expressions the first one is

00:23:59,120 --> 00:24:04,080
before c plus plus 20 if you capture

00:24:01,919 --> 00:24:06,000
everything by default by value

00:24:04,080 --> 00:24:08,000
that would implicitly capture this this

00:24:06,000 --> 00:24:10,000
is not the case anymore so since epos

00:24:08,000 --> 00:24:12,000
20 you need to explicitly state that you

00:24:10,000 --> 00:24:15,360
want to capture everything by value

00:24:12,000 --> 00:24:16,960
and that you want to capture this

00:24:15,360 --> 00:24:19,840
so this might be a breaking change for

00:24:16,960 --> 00:24:19,840
certain code bases

00:24:21,039 --> 00:24:24,320
next is that we have support for

00:24:22,480 --> 00:24:26,559
templated lambda expressions

00:24:24,320 --> 00:24:27,360
and the syntax is as you would expect

00:24:26,559 --> 00:24:30,400
you just use

00:24:27,360 --> 00:24:32,080
type name t or any kind of any number of

00:24:30,400 --> 00:24:33,440
template parameters you need

00:24:32,080 --> 00:24:36,799
and then you can use these template

00:24:33,440 --> 00:24:38,960
parameters inside your lambda

00:24:36,799 --> 00:24:40,080
why do we need this so first motivation

00:24:38,960 --> 00:24:41,840
first example

00:24:40,080 --> 00:24:44,640
is suppose you have a generic lambda

00:24:41,840 --> 00:24:46,799
that accepts a vector of t

00:24:44,640 --> 00:24:48,240
and you want to know the type of t

00:24:46,799 --> 00:24:50,000
before pre before c

00:24:48,240 --> 00:24:52,320
plus plus 20 what you have to do is you

00:24:50,000 --> 00:24:53,279
have to use some decal type and dkt

00:24:52,320 --> 00:24:56,720
voodoo

00:24:53,279 --> 00:24:58,080
first you have to do dkt decal type

00:24:56,720 --> 00:25:00,559
thick and the result of this

00:24:58,080 --> 00:25:02,240
gives you the vector of t and once you

00:25:00,559 --> 00:25:04,159
have this vector you can ask the

00:25:02,240 --> 00:25:06,080
value type of the vector and that gives

00:25:04,159 --> 00:25:07,919
you the t and then once you have the t

00:25:06,080 --> 00:25:09,600
you can do whatever you want with the t

00:25:07,919 --> 00:25:11,520
that you want to do

00:25:09,600 --> 00:25:12,720
with c plus plus 20 and a templated

00:25:11,520 --> 00:25:14,480
lambda expression

00:25:12,720 --> 00:25:15,840
you don't need any of this decay and

00:25:14,480 --> 00:25:18,320
decal type and this

00:25:15,840 --> 00:25:18,960
type name and nested type alias and so

00:25:18,320 --> 00:25:22,240
on

00:25:18,960 --> 00:25:24,400
you can simply say type name t and then

00:25:22,240 --> 00:25:25,440
use instead of auto ref you can use a

00:25:24,400 --> 00:25:27,520
constant

00:25:25,440 --> 00:25:29,120
vector t ref and then you have direct

00:25:27,520 --> 00:25:32,799
access to the t in your

00:25:29,120 --> 00:25:32,799
in the body of your lambda expression

00:25:34,799 --> 00:25:38,720
and a second motivation is if you have a

00:25:37,679 --> 00:25:40,799
lambda expression

00:25:38,720 --> 00:25:42,159
with a variable number of templates and

00:25:40,799 --> 00:25:46,559
you want to forward this

00:25:42,159 --> 00:25:46,559
variatic sorry variatic

00:25:47,039 --> 00:25:50,720
set of parameters if you want to forward

00:25:48,880 --> 00:25:53,039
these to another function foo

00:25:50,720 --> 00:25:55,039
you had to use decal type again so you

00:25:53,039 --> 00:25:57,679
have to use forward decal type

00:25:55,039 --> 00:25:59,039
of the arguments with c plus 20 you can

00:25:57,679 --> 00:26:02,559
drop the decal type

00:25:59,039 --> 00:26:11,840
as you can just use a templated lambda

00:26:02,559 --> 00:26:11,840
expression with a variable template pack

00:26:12,000 --> 00:26:17,120
so before c plus plus 20 if we have a

00:26:15,440 --> 00:26:19,279
simple capture that was followed by an

00:26:17,120 --> 00:26:21,520
ellipsis like this

00:26:19,279 --> 00:26:23,200
this was a pack expansion that that

00:26:21,520 --> 00:26:25,919
worked perfectly fine

00:26:23,200 --> 00:26:26,320
but if you had an init capture like this

00:26:25,919 --> 00:26:29,840
x

00:26:26,320 --> 00:26:30,559
equals to move rx dot this was ill

00:26:29,840 --> 00:26:33,600
formed in

00:26:30,559 --> 00:26:34,320
in c plus plus 17 and older now it's c

00:26:33,600 --> 00:26:37,440
plus plus

00:26:34,320 --> 00:26:41,039
20 this is well formed and it does

00:26:37,440 --> 00:26:41,039
exactly what you expect it to do

00:26:48,480 --> 00:26:52,480
changes to const expert so now virtual

00:26:50,960 --> 00:26:54,960
functions

00:26:52,480 --> 00:26:57,039
can be marked as constexpr and a

00:26:54,960 --> 00:26:58,400
constexpr function can now also include

00:26:57,039 --> 00:27:01,120
calls to dynamic cast

00:26:58,400 --> 00:27:03,039
can use type id they can now actually do

00:27:01,120 --> 00:27:04,960
dynamic memory allocations you

00:27:03,039 --> 00:27:06,720
using new and delete but there is one

00:27:04,960 --> 00:27:08,000
caveat here

00:27:06,720 --> 00:27:09,600
and you need to make sure that you're

00:27:08,000 --> 00:27:10,559
using the global new and delete

00:27:09,600 --> 00:27:13,039
functions

00:27:10,559 --> 00:27:14,480
and also anything that you allocate in

00:27:13,039 --> 00:27:15,600
your constexpr function

00:27:14,480 --> 00:27:17,520
you need to make sure that you

00:27:15,600 --> 00:27:19,520
deallocated in the same constexpr

00:27:17,520 --> 00:27:21,200
function

00:27:19,520 --> 00:27:23,520
and finally try catch blocks are now

00:27:21,200 --> 00:27:26,240
allowed but a constexpr function is

00:27:23,520 --> 00:27:27,840
still not allowed to throw exceptions so

00:27:26,240 --> 00:27:30,399
it has to catch all the exceptions that

00:27:27,840 --> 00:27:30,399
could be thrown

00:27:31,200 --> 00:27:34,559
and with all these changes it was

00:27:32,640 --> 00:27:36,799
possible to make both string

00:27:34,559 --> 00:27:38,720
and vector const experts so now you can

00:27:36,799 --> 00:27:39,520
use string and vector in your own const

00:27:38,720 --> 00:27:42,399
expo

00:27:39,520 --> 00:27:43,760
functions and this is the first step to

00:27:42,399 --> 00:27:46,080
at one point support

00:27:43,760 --> 00:27:47,200
constant x per reflection in the future

00:27:46,080 --> 00:27:49,600
there is a session

00:27:47,200 --> 00:27:50,960
on tuesday by stefan that will go a

00:27:49,600 --> 00:27:53,679
little bit deeper on

00:27:50,960 --> 00:27:53,679
on this topic

00:27:57,279 --> 00:28:01,279
concurrency changes let's talk a little

00:27:59,039 --> 00:28:02,960
bit about shared putter

00:28:01,279 --> 00:28:05,279
is shared putter thread safe on the one

00:28:02,960 --> 00:28:06,640
hand yes the control block manipulation

00:28:05,279 --> 00:28:08,640
is thread safe

00:28:06,640 --> 00:28:10,240
so basically incrementing and

00:28:08,640 --> 00:28:11,840
decrementing the reference count is

00:28:10,240 --> 00:28:14,559
thread safe and this guarantees that the

00:28:11,840 --> 00:28:16,240
object is deallocated exactly once

00:28:14,559 --> 00:28:18,159
while it's not thread save is accessing

00:28:16,240 --> 00:28:19,679
the pointer because one thread could be

00:28:18,159 --> 00:28:21,360
reading the pointer and another could be

00:28:19,679 --> 00:28:23,120
storing a new pointer so that is not

00:28:21,360 --> 00:28:25,279
thread safe

00:28:23,120 --> 00:28:27,520
can we make it thread save of course we

00:28:25,279 --> 00:28:29,679
can manually use a mutex to protect

00:28:27,520 --> 00:28:31,840
access to the shared pointer

00:28:29,679 --> 00:28:33,279
or we can use the global non-member

00:28:31,840 --> 00:28:36,320
atomic operations like

00:28:33,279 --> 00:28:38,880
atomic loads atomic store and so on but

00:28:36,320 --> 00:28:42,399
this is error prone and i will show you

00:28:38,880 --> 00:28:45,120
on the next slide why it is error prone

00:28:42,399 --> 00:28:46,880
with c plus plus 20 we have now support

00:28:45,120 --> 00:28:48,480
for atomic shared pointer

00:28:46,880 --> 00:28:50,000
of course internally it might still use

00:28:48,480 --> 00:28:51,360
a mutex but you don't need to worry

00:28:50,000 --> 00:28:53,840
about that

00:28:51,360 --> 00:28:55,279
and additionally these global non-member

00:28:53,840 --> 00:28:58,799
atomic operations

00:28:55,279 --> 00:29:01,200
um have been deprecated

00:28:58,799 --> 00:29:04,080
so let's look at an example here i have

00:29:01,200 --> 00:29:06,399
a concurrent stack

00:29:04,080 --> 00:29:07,279
using the c plus plus 20 atomic smart

00:29:06,399 --> 00:29:09,200
pointers so

00:29:07,279 --> 00:29:11,520
one of the members is an atomic shared

00:29:09,200 --> 00:29:12,000
printer and wherever i'm using this for

00:29:11,520 --> 00:29:13,760
example

00:29:12,000 --> 00:29:15,440
here i have to do something like head

00:29:13,760 --> 00:29:18,399
dot load or

00:29:15,440 --> 00:29:20,399
head dot compare exchange week and so on

00:29:18,399 --> 00:29:20,799
so i cannot make any mistakes i have to

00:29:20,399 --> 00:29:23,200
use

00:29:20,799 --> 00:29:24,720
methods of my atomic shared pointer

00:29:23,200 --> 00:29:26,240
whenever i want to do something with

00:29:24,720 --> 00:29:29,279
that shared pointer

00:29:26,240 --> 00:29:31,360
while with c plus plus 11 for c plus

00:29:29,279 --> 00:29:33,919
plus 11 i would not use an atomic shared

00:29:31,360 --> 00:29:36,720
pointer but just a sharepointer

00:29:33,919 --> 00:29:39,039
and then instead of head.load i have to

00:29:36,720 --> 00:29:39,760
use the global nonmember function atomic

00:29:39,039 --> 00:29:41,360
loads

00:29:39,760 --> 00:29:43,120
and here also i have to use the global

00:29:41,360 --> 00:29:44,320
non-member function atomic compare

00:29:43,120 --> 00:29:45,679
exchange with

00:29:44,320 --> 00:29:47,679
what you see there is nothing that

00:29:45,679 --> 00:29:50,000
really prevent me from directly using

00:29:47,679 --> 00:29:52,159
the sharepoint and if you do that

00:29:50,000 --> 00:29:53,600
then again it's not thread safe so c

00:29:52,159 --> 00:29:56,240
plus plus 20

00:29:53,600 --> 00:29:59,840
safeguards you and it makes sure that

00:29:56,240 --> 00:29:59,840
you cannot make a mistake actually

00:30:01,520 --> 00:30:05,520
c plus plus 20 at supports for joining

00:30:03,840 --> 00:30:06,399
and cancelable threats so there is a new

00:30:05,520 --> 00:30:08,320
threat class

00:30:06,399 --> 00:30:09,840
j threat it also lives in the thread

00:30:08,320 --> 00:30:12,720
header file

00:30:09,840 --> 00:30:14,720
and this one has two new features one it

00:30:12,720 --> 00:30:16,559
supports cooperative cancellation

00:30:14,720 --> 00:30:18,320
and two the destructor will

00:30:16,559 --> 00:30:21,200
automatically cancel the thread

00:30:18,320 --> 00:30:24,159
and call join and why this is important

00:30:21,200 --> 00:30:26,399
we will see on the next slide

00:30:24,159 --> 00:30:27,200
how to cancel threat there are a threat

00:30:26,399 --> 00:30:30,240
there are three

00:30:27,200 --> 00:30:32,240
aspects here you have a stop token and

00:30:30,240 --> 00:30:34,240
a stop token is used to actively check

00:30:32,240 --> 00:30:36,799
if a stop has been requested so

00:30:34,240 --> 00:30:38,720
a threat that supports cancellation will

00:30:36,799 --> 00:30:40,399
have to periodically check if a stop is

00:30:38,720 --> 00:30:41,120
requested and that's why it's called

00:30:40,399 --> 00:30:43,120
corporate

00:30:41,120 --> 00:30:45,679
cooperative cancellation it requires

00:30:43,120 --> 00:30:47,279
work from the threat itself

00:30:45,679 --> 00:30:49,840
the nice thing is that stop token is

00:30:47,279 --> 00:30:50,159
compatible with condition variable any

00:30:49,840 --> 00:30:52,320
so

00:30:50,159 --> 00:30:53,520
if your threat is sleeping on some

00:30:52,320 --> 00:30:55,679
condition variables

00:30:53,520 --> 00:30:56,640
it can be woken up by a condition

00:30:55,679 --> 00:31:00,000
variable any

00:30:56,640 --> 00:31:03,919
when a stop token is erased to to

00:31:00,000 --> 00:31:05,600
stop the threat a second is a stop

00:31:03,919 --> 00:31:06,640
source and the stop source is the other

00:31:05,600 --> 00:31:08,960
side of the

00:31:06,640 --> 00:31:09,919
of of cancellation stop source is used

00:31:08,960 --> 00:31:12,720
to actually

00:31:09,919 --> 00:31:14,159
ask a threat to stop and finally we have

00:31:12,720 --> 00:31:16,000
a stop callback you can

00:31:14,159 --> 00:31:18,000
register a callback and then your

00:31:16,000 --> 00:31:20,799
callback will be called whenever a stop

00:31:18,000 --> 00:31:20,799
is requested

00:31:22,159 --> 00:31:26,480
so let's have a look at how this changes

00:31:25,600 --> 00:31:28,559
how you write

00:31:26,480 --> 00:31:31,039
your certain codes so here i have a

00:31:28,559 --> 00:31:33,919
function that creates a thread object

00:31:31,039 --> 00:31:34,720
it's doing some some work and in

00:31:33,919 --> 00:31:36,799
parallel with

00:31:34,720 --> 00:31:39,600
the work that this threat is doing i'm

00:31:36,799 --> 00:31:43,760
doing something else

00:31:39,600 --> 00:31:45,840
but i'm using the old threat object here

00:31:43,760 --> 00:31:48,000
so we have to be careful here because if

00:31:45,840 --> 00:31:50,559
the threat object is destroyed

00:31:48,000 --> 00:31:52,320
while it is still joinable then your

00:31:50,559 --> 00:31:54,080
application will terminate so i have to

00:31:52,320 --> 00:31:55,840
make sure that i call join

00:31:54,080 --> 00:31:57,760
at all the points in this function where

00:31:55,840 --> 00:31:58,880
it can enter where where the function

00:31:57,760 --> 00:32:02,000
can go

00:31:58,880 --> 00:32:03,440
where it function finishes and of course

00:32:02,000 --> 00:32:04,880
my do something else can throw an

00:32:03,440 --> 00:32:08,240
exception so i have to wrap

00:32:04,880 --> 00:32:09,760
this whole code inside a try catch block

00:32:08,240 --> 00:32:11,600
in the catch i have to catch all the

00:32:09,760 --> 00:32:12,080
exceptions i have to make sure to call

00:32:11,600 --> 00:32:14,240
join

00:32:12,080 --> 00:32:15,600
on my thread and then just rethrow the

00:32:14,240 --> 00:32:17,840
exception

00:32:15,600 --> 00:32:19,279
of course in the case do something else

00:32:17,840 --> 00:32:20,960
doesn't throw any exception

00:32:19,279 --> 00:32:23,440
i have to make sure that i join as well

00:32:20,960 --> 00:32:25,360
in that case

00:32:23,440 --> 00:32:26,960
so this is quite a lot of ugly

00:32:25,360 --> 00:32:29,200
boilerplate code

00:32:26,960 --> 00:32:31,360
with a j thread i don't have to write

00:32:29,200 --> 00:32:31,600
any boilerplate code i just construct my

00:32:31,360 --> 00:32:34,159
j

00:32:31,600 --> 00:32:35,919
thread as follows then do something else

00:32:34,159 --> 00:32:37,279
i don't need any try catch blocks i

00:32:35,919 --> 00:32:38,880
don't need any

00:32:37,279 --> 00:32:41,600
manual calls to join because the

00:32:38,880 --> 00:32:44,880
destructor of jthred will automatically

00:32:41,600 --> 00:32:47,440
one cancel the thread and to call join

00:32:44,880 --> 00:32:47,440
on the thread

00:32:48,480 --> 00:32:53,120
so how is this cooperative cancellation

00:32:50,399 --> 00:32:55,200
working so whenever i construct a j

00:32:53,120 --> 00:32:56,960
thread object

00:32:55,200 --> 00:32:59,120
the first parameter of my threat

00:32:56,960 --> 00:33:02,080
function can be a so-called stop token

00:32:59,120 --> 00:33:03,039
and then periodically your thread can

00:33:02,080 --> 00:33:04,960
check the token

00:33:03,039 --> 00:33:07,200
for a stop that has been requested or

00:33:04,960 --> 00:33:09,600
can use a condition variable any

00:33:07,200 --> 00:33:11,840
to get woken up when the stop token is

00:33:09,600 --> 00:33:11,840
triggered

00:33:12,080 --> 00:33:15,600
and then some somewhere else in your

00:33:13,600 --> 00:33:17,919
code you can say that the job

00:33:15,600 --> 00:33:20,159
should stop you can also ask for the

00:33:17,919 --> 00:33:22,080
stop source and then you can ask

00:33:20,159 --> 00:33:24,240
the threat to stop through this stop

00:33:22,080 --> 00:33:26,080
source and finally you can ask for a

00:33:24,240 --> 00:33:27,519
stop token as well and then you can

00:33:26,080 --> 00:33:31,360
through the token you can figure out

00:33:27,519 --> 00:33:31,360
whether a stop has been requested or not

00:33:34,880 --> 00:33:38,960
c 20 includes a couple of new

00:33:37,039 --> 00:33:40,960
synchronization primitives and the first

00:33:38,960 --> 00:33:42,640
one is a so-called semaphore that's a

00:33:40,960 --> 00:33:45,120
very lightweight synchronous

00:33:42,640 --> 00:33:47,279
synchronization primitive and this one

00:33:45,120 --> 00:33:49,600
can actually be used to implement

00:33:47,279 --> 00:33:52,880
almost any other synchronization concept

00:33:49,600 --> 00:33:55,039
such as mutex latches and barriers

00:33:52,880 --> 00:33:57,440
there are some that supports two types

00:33:55,039 --> 00:33:59,279
of semaphores one is accounting sima4

00:33:57,440 --> 00:34:02,080
and the other is a binary semaphore for

00:33:59,279 --> 00:34:04,000
example a binary soma4 has just one slot

00:34:02,080 --> 00:34:05,919
and this slot can either be free or not

00:34:04,000 --> 00:34:08,720
free so this is perfect for implementing

00:34:05,919 --> 00:34:08,720
your own mutex

00:34:11,040 --> 00:34:13,760
next we have the latches and barriers

00:34:12,639 --> 00:34:15,119
though they help with threat

00:34:13,760 --> 00:34:18,480
coordination a ledge

00:34:15,119 --> 00:34:20,480
it's a coordination point in a thread so

00:34:18,480 --> 00:34:21,520
a threat blocks when it arrives at a

00:34:20,480 --> 00:34:23,760
latch point

00:34:21,520 --> 00:34:25,440
until a number of given threats a given

00:34:23,760 --> 00:34:26,000
number of threads arrive at that point

00:34:25,440 --> 00:34:28,480
and

00:34:26,000 --> 00:34:30,079
once the number of given threats arrive

00:34:28,480 --> 00:34:32,800
at the point and all of the threats are

00:34:30,079 --> 00:34:34,320
unblocked and continue

00:34:32,800 --> 00:34:35,839
basically you say that at the

00:34:34,320 --> 00:34:38,079
coordination point i want

00:34:35,839 --> 00:34:40,079
five threads to arrive with each thread

00:34:38,079 --> 00:34:42,240
that arrives at the coordination point

00:34:40,079 --> 00:34:43,919
a counter is decremented once the

00:34:42,240 --> 00:34:45,280
counter reaches zero then all the

00:34:43,919 --> 00:34:46,800
threads are allowed to continue

00:34:45,280 --> 00:34:49,839
executing

00:34:46,800 --> 00:34:52,000
once the counter reaches zero it stays

00:34:49,839 --> 00:34:53,760
zero so basically a ledge is a single

00:34:52,000 --> 00:34:57,440
use

00:34:53,760 --> 00:35:00,560
object if you want multi-use you can use

00:34:57,440 --> 00:35:03,200
a so-called barrier and that is

00:35:00,560 --> 00:35:03,599
it it contains out of a number of faces

00:35:03,200 --> 00:35:05,760
so

00:35:03,599 --> 00:35:07,440
again every number of threads that block

00:35:05,760 --> 00:35:09,280
until a requested number of threads

00:35:07,440 --> 00:35:11,040
arrive at a certain point

00:35:09,280 --> 00:35:13,040
and at that point some kind of callback

00:35:11,040 --> 00:35:15,359
is executed

00:35:13,040 --> 00:35:19,040
the counter is reset the next phase

00:35:15,359 --> 00:35:19,040
starts and all the threads can continue

00:35:22,880 --> 00:35:26,880
we also have support for atomic

00:35:24,560 --> 00:35:30,000
reference now and they are

00:35:26,880 --> 00:35:32,800
sorry that was the next slide um so we

00:35:30,000 --> 00:35:33,200
can as the atomic has been augmented

00:35:32,800 --> 00:35:35,200
with

00:35:33,200 --> 00:35:37,920
three new methods wait notify one and

00:35:35,200 --> 00:35:40,160
notify all and they allow you to wait

00:35:37,920 --> 00:35:41,440
for an atomic object to change its value

00:35:40,160 --> 00:35:45,200
and this is more

00:35:41,440 --> 00:35:47,440
more performant than pulling

00:35:45,200 --> 00:35:48,640
and finally atomic reference basically

00:35:47,440 --> 00:35:50,960
the same as an

00:35:48,640 --> 00:35:53,440
std atomic but it works with references

00:35:50,960 --> 00:35:55,680
while an sd atomic always copies the

00:35:53,440 --> 00:35:58,800
value that it is provided

00:35:55,680 --> 00:35:59,440
so in certain cases atomic reference can

00:35:58,800 --> 00:36:02,000
be more

00:35:59,440 --> 00:36:02,000
efficient

00:36:02,720 --> 00:36:08,480
and then there are lots of more smaller

00:36:05,920 --> 00:36:10,320
changes first one we have so-called

00:36:08,480 --> 00:36:11,920
designated initialization for

00:36:10,320 --> 00:36:13,839
aggregates so here i have a simple

00:36:11,920 --> 00:36:16,480
structure containing an integer

00:36:13,839 --> 00:36:18,720
and a string and designated

00:36:16,480 --> 00:36:21,280
initialization means that you can

00:36:18,720 --> 00:36:22,079
initialize it based on the name of the

00:36:21,280 --> 00:36:26,000
member so you

00:36:22,079 --> 00:36:27,760
write dot a string is hello um

00:36:26,000 --> 00:36:31,200
anything that you don't initialize will

00:36:27,760 --> 00:36:31,200
keep its default values

00:36:35,040 --> 00:36:38,400
another one is spaceship operator

00:36:37,040 --> 00:36:40,880
officially it's called three-way

00:36:38,400 --> 00:36:42,800
comparison operator and basically with

00:36:40,880 --> 00:36:44,640
one operator call you can

00:36:42,800 --> 00:36:46,079
figure out whether an object is less

00:36:44,640 --> 00:36:48,079
than another object

00:36:46,079 --> 00:36:49,119
equal to another object or greater than

00:36:48,079 --> 00:36:51,200
another object

00:36:49,119 --> 00:36:52,240
so it's kind of similar to the old c

00:36:51,200 --> 00:36:54,400
style

00:36:52,240 --> 00:36:56,960
string compare which returns a negative

00:36:54,400 --> 00:36:57,920
value zero or a positive value depending

00:36:56,960 --> 00:36:59,839
whether the

00:36:57,920 --> 00:37:03,200
first string is less than equal or

00:36:59,839 --> 00:37:04,960
greater than a second string

00:37:03,200 --> 00:37:07,119
if you want to add support for the

00:37:04,960 --> 00:37:10,480
spaceship operator to your own

00:37:07,119 --> 00:37:11,119
classes you can simply write one single

00:37:10,480 --> 00:37:13,119
line

00:37:11,119 --> 00:37:15,520
like this and you can ask the compiler

00:37:13,119 --> 00:37:17,119
to implement it for you

00:37:15,520 --> 00:37:18,560
just by writing this single line the

00:37:17,119 --> 00:37:20,960
compiler will generate

00:37:18,560 --> 00:37:22,079
all six comparison operators to compare

00:37:20,960 --> 00:37:24,000
x and y

00:37:22,079 --> 00:37:26,320
and it will do the comparisons member

00:37:24,000 --> 00:37:28,800
wise and i say all six

00:37:26,320 --> 00:37:30,240
so just by writing this single single

00:37:28,800 --> 00:37:32,880
line of code

00:37:30,240 --> 00:37:36,160
it will also generate the equality

00:37:32,880 --> 00:37:38,320
operator for you

00:37:36,160 --> 00:37:40,560
of course you cannot always let the

00:37:38,320 --> 00:37:43,280
compiler do the member wise comparison

00:37:40,560 --> 00:37:45,359
in that case you should implement the

00:37:43,280 --> 00:37:47,599
spaceship operator yourself

00:37:45,359 --> 00:37:49,359
which means it will won't be defaulted

00:37:47,599 --> 00:37:50,160
which means you also need to write your

00:37:49,359 --> 00:37:54,160
own operator

00:37:50,160 --> 00:37:55,760
equal equal and if you write your own

00:37:54,160 --> 00:37:57,599
you have a choice of three kinds of

00:37:55,760 --> 00:38:00,079
return types you have a strong ordering

00:37:57,599 --> 00:38:01,839
partial ordering and weak ordering

00:38:00,079 --> 00:38:03,359
not going into all the details here

00:38:01,839 --> 00:38:05,680
what's what the difference is between

00:38:03,359 --> 00:38:08,079
them

00:38:05,680 --> 00:38:09,920
how to use it so here i'm just an

00:38:08,079 --> 00:38:10,720
integer and i want to compare the

00:38:09,920 --> 00:38:13,920
integer with

00:38:10,720 --> 00:38:15,680
zero so i just use a spaceship operator

00:38:13,920 --> 00:38:18,320
to compare it with zero

00:38:15,680 --> 00:38:20,000
and with this one operator call i know

00:38:18,320 --> 00:38:22,960
whether 42 is less than

00:38:20,000 --> 00:38:24,000
0 greater than 0 or equal to 0 and you

00:38:22,960 --> 00:38:26,400
can

00:38:24,000 --> 00:38:28,640
verify the result or you can analyze the

00:38:26,400 --> 00:38:30,640
result with with this syntax

00:38:28,640 --> 00:38:32,079
additionally there are named comparison

00:38:30,640 --> 00:38:33,200
functions so instead of writing

00:38:32,079 --> 00:38:36,000
something like result

00:38:33,200 --> 00:38:38,240
equal strong ordering less you can just

00:38:36,000 --> 00:38:42,160
use the name comparison function

00:38:38,240 --> 00:38:42,160
this less than result

00:38:43,920 --> 00:38:47,200
this has quite an impact on on the

00:38:45,920 --> 00:38:50,160
classes that you're at

00:38:47,200 --> 00:38:52,320
in c plus 17 if i had a point class with

00:38:50,160 --> 00:38:53,680
a simple x and a y number and i want to

00:38:52,320 --> 00:38:55,839
support all six

00:38:53,680 --> 00:38:59,119
comparison operators i have to write i

00:38:55,839 --> 00:39:01,359
have to implement all six of them

00:38:59,119 --> 00:39:02,160
of course once you have equal equal and

00:39:01,359 --> 00:39:03,920
less than

00:39:02,160 --> 00:39:05,680
the other ones you can implement in

00:39:03,920 --> 00:39:08,000
terms of these two but you still need to

00:39:05,680 --> 00:39:11,200
implement all of them

00:39:08,000 --> 00:39:12,480
in c plus 20 you simply include the

00:39:11,200 --> 00:39:14,560
compare header

00:39:12,480 --> 00:39:17,119
and you ask the compiler do all the work

00:39:14,560 --> 00:39:19,359
for me which in this case works because

00:39:17,119 --> 00:39:22,720
member wise comparison of x and y is

00:39:19,359 --> 00:39:22,720
is exactly what we want

00:39:23,760 --> 00:39:27,200
the standard library has full support

00:39:25,440 --> 00:39:28,000
for the spaceship operators so all the

00:39:27,200 --> 00:39:30,240
classes like

00:39:28,000 --> 00:39:32,320
map set vector string all of them

00:39:30,240 --> 00:39:34,240
support the spaceship operator

00:39:32,320 --> 00:39:35,359
and actually if you look at the diff of

00:39:34,240 --> 00:39:38,560
the standard

00:39:35,359 --> 00:39:40,320
document itself you can see that

00:39:38,560 --> 00:39:42,079
i'm looking here at the vector class you

00:39:40,320 --> 00:39:45,200
can see that operator

00:39:42,079 --> 00:39:47,200
spaceship has been added but it's not

00:39:45,200 --> 00:39:48,560
defaulted so that means we need to keep

00:39:47,200 --> 00:39:51,040
operator equal equal

00:39:48,560 --> 00:39:57,839
but all five other operators have simply

00:39:51,040 --> 00:39:57,839
been removed

00:40:00,560 --> 00:40:06,160
sc 17 initializes for switch statements

00:40:04,240 --> 00:40:07,440
were added so basic the syntax is as

00:40:06,160 --> 00:40:09,599
follows you can initialize

00:40:07,440 --> 00:40:11,680
any kind of variable you want here and

00:40:09,599 --> 00:40:14,079
then it's available here and in the body

00:40:11,680 --> 00:40:17,040
of the switch statement

00:40:14,079 --> 00:40:19,280
similar c plus plus 17 has added support

00:40:17,040 --> 00:40:21,760
for initializers in if statements

00:40:19,280 --> 00:40:23,599
same syntax you can initialize any

00:40:21,760 --> 00:40:25,280
variable you want here it's available in

00:40:23,599 --> 00:40:27,119
the in the expression here and in the

00:40:25,280 --> 00:40:29,680
body

00:40:27,119 --> 00:40:31,599
and now c plus plus 20 added supports

00:40:29,680 --> 00:40:33,680
for similar initializers in

00:40:31,599 --> 00:40:36,160
range based for loops again using the

00:40:33,680 --> 00:40:37,599
same syntax you can just initialize

00:40:36,160 --> 00:40:39,440
any variable you want here it's

00:40:37,599 --> 00:40:41,920
available in the expression here and in

00:40:39,440 --> 00:40:41,920
the body

00:40:44,560 --> 00:40:48,800
non-type template parameters in the past

00:40:46,560 --> 00:40:50,960
you had quite a lot of limitations so

00:40:48,800 --> 00:40:52,000
circle you cannot use classes you cannot

00:40:50,960 --> 00:40:55,119
use floating point

00:40:52,000 --> 00:40:56,880
types these style these limitations have

00:40:55,119 --> 00:40:57,920
been relaxed and now floating point

00:40:56,880 --> 00:41:00,560
types are allowed

00:40:57,920 --> 00:41:01,760
class types are allowed but class types

00:41:00,560 --> 00:41:04,400
are allowed with quite a lot of

00:41:01,760 --> 00:41:04,400
restrictions

00:41:04,480 --> 00:41:09,119
and one example use case is the ctre

00:41:07,520 --> 00:41:10,720
library the compile-time regular

00:41:09,119 --> 00:41:12,319
expression library

00:41:10,720 --> 00:41:14,400
and thanks to non-type template

00:41:12,319 --> 00:41:17,520
parameters

00:41:14,400 --> 00:41:19,440
the listing of the limitations

00:41:17,520 --> 00:41:20,720
what that library is able to do is you

00:41:19,440 --> 00:41:23,040
can construct a match

00:41:20,720 --> 00:41:26,319
object and pass it a regular expression

00:41:23,040 --> 00:41:29,760
as a non-type template parameter

00:41:26,319 --> 00:41:31,280
and by writing this the

00:41:29,760 --> 00:41:33,760
the regular expression is parsed at

00:41:31,280 --> 00:41:35,520
compile time and your match object is

00:41:33,760 --> 00:41:38,160
constructed at compile time instead of

00:41:35,520 --> 00:41:38,160
at runtime

00:41:41,359 --> 00:41:46,000
there are two new attributes added to

00:41:43,920 --> 00:41:47,280
the standard we have likely and unlikely

00:41:46,000 --> 00:41:49,040
and they allow you to

00:41:47,280 --> 00:41:51,520
to give hints to the compiler for

00:41:49,040 --> 00:41:53,760
certain optimizations so in this case

00:41:51,520 --> 00:41:55,359
if you know that case 2 is much more

00:41:53,760 --> 00:41:56,560
likely than the other cases you can put

00:41:55,359 --> 00:41:58,480
an attribute there

00:41:56,560 --> 00:42:01,040
if case 3 is less likely than anything

00:41:58,480 --> 00:42:02,640
else you can put an attribute there

00:42:01,040 --> 00:42:06,160
and the same thing can be done with

00:42:02,640 --> 00:42:06,160
branches of if statements

00:42:08,720 --> 00:42:11,920
the chrono library has been extended

00:42:10,480 --> 00:42:14,800
with quite a lot of features

00:42:11,920 --> 00:42:16,560
first calendar support has been added at

00:42:14,800 --> 00:42:18,400
the moment only the gregorian calendar

00:42:16,560 --> 00:42:19,760
is supported but you can add your own

00:42:18,400 --> 00:42:21,520
custom calendars

00:42:19,760 --> 00:42:23,520
and when you do that they will

00:42:21,520 --> 00:42:25,040
interoperate with anything else that is

00:42:23,520 --> 00:42:26,560
in chrono

00:42:25,040 --> 00:42:27,839
so let's have a look how you can create

00:42:26,560 --> 00:42:29,280
a year you can either use the

00:42:27,839 --> 00:42:31,520
constructor syntax

00:42:29,280 --> 00:42:32,800
or you can use a standard user defined

00:42:31,520 --> 00:42:34,560
literal

00:42:32,800 --> 00:42:36,400
a month can be constructed with a

00:42:34,560 --> 00:42:40,800
constructor or with one of the 12

00:42:36,400 --> 00:42:42,640
predefined instances

00:42:40,800 --> 00:42:44,560
and you can create a day similar like a

00:42:42,640 --> 00:42:45,359
year you can just use a constructor or

00:42:44,560 --> 00:42:48,640
you can use

00:42:45,359 --> 00:42:50,800
a standard user defined literal

00:42:48,640 --> 00:42:52,640
this just creates a single year single

00:42:50,800 --> 00:42:55,040
month and a single day but of course you

00:42:52,640 --> 00:42:58,000
can create a full date as follows

00:42:55,040 --> 00:42:59,839
one of these two syntaxes you can use

00:42:58,000 --> 00:43:00,720
and additionally you can say something

00:42:59,839 --> 00:43:03,680
like this

00:43:00,720 --> 00:43:07,520
i want to create a day that is the third

00:43:03,680 --> 00:43:07,520
monday of september 2020.

00:43:10,160 --> 00:43:13,200
there are a couple of new duration type

00:43:11,839 --> 00:43:15,680
aliases before

00:43:13,200 --> 00:43:16,240
in c plus plus 11 we already had seconds

00:43:15,680 --> 00:43:19,520
minutes

00:43:16,240 --> 00:43:22,720
hours now we have also days weeks

00:43:19,520 --> 00:43:24,960
months and year so if i have for example

00:43:22,720 --> 00:43:26,079
an object that represents one week i can

00:43:24,960 --> 00:43:28,400
convert it to

00:43:26,079 --> 00:43:28,400
days

00:43:31,040 --> 00:43:34,960
besides the the the system clock static

00:43:33,440 --> 00:43:36,640
clock and high resolution clock that

00:43:34,960 --> 00:43:37,200
we're already in the original chrono

00:43:36,640 --> 00:43:39,760
library

00:43:37,200 --> 00:43:41,440
we have four additional blocks now they

00:43:39,760 --> 00:43:44,480
are very specific they have very

00:43:41,440 --> 00:43:46,079
specific behavior

00:43:44,480 --> 00:43:47,599
i'm not going in all the details here

00:43:46,079 --> 00:43:49,280
but it's just so you know that there are

00:43:47,599 --> 00:43:51,520
additional clocks in case you ever need

00:43:49,280 --> 00:43:51,520
them

00:43:53,359 --> 00:43:57,839
one new type alias is this time and that

00:43:55,599 --> 00:44:00,000
is a time point of a system clock with a

00:43:57,839 --> 00:44:02,720
given duration and based with on

00:44:00,000 --> 00:44:04,480
this system type aliases there are two

00:44:02,720 --> 00:44:06,720
new type aliases

00:44:04,480 --> 00:44:08,079
seconds and sis days and these can be

00:44:06,720 --> 00:44:11,680
used as follows

00:44:08,079 --> 00:44:13,680
so here i have a date i have 15th of

00:44:11,680 --> 00:44:16,480
september 2020

00:44:13,680 --> 00:44:18,880
and thanks to the 6days type alias i can

00:44:16,480 --> 00:44:20,720
convert this to a time point

00:44:18,880 --> 00:44:22,800
the other way around is also possible if

00:44:20,720 --> 00:44:25,760
i have a time point i can convert it to

00:44:22,800 --> 00:44:27,599
a date using this syntax

00:44:25,760 --> 00:44:29,599
and these both of these examples are

00:44:27,599 --> 00:44:31,520
working with the resolution of a day

00:44:29,599 --> 00:44:33,359
because here i'm rounding in two days

00:44:31,520 --> 00:44:38,480
and here i'm using the sysdays

00:44:33,359 --> 00:44:38,480
type alias so resolution is a day

00:44:39,359 --> 00:44:43,440
of course you can combine date and time

00:44:41,280 --> 00:44:44,880
so here i'm constructing a date 15th of

00:44:43,440 --> 00:44:47,920
september 2020

00:44:44,880 --> 00:44:51,359
and 9 o'clock in the morning so by doing

00:44:47,920 --> 00:44:53,280
it like this this is actually a utc time

00:44:51,359 --> 00:44:54,640
once i have this i can convert this to

00:44:53,280 --> 00:44:56,560
any time zone

00:44:54,640 --> 00:44:58,880
in the world so with this syntax i'm

00:44:56,560 --> 00:45:02,400
converting my utc time

00:44:58,880 --> 00:45:05,119
to the denver time zone

00:45:02,400 --> 00:45:06,640
i can also ask what is my current zone

00:45:05,119 --> 00:45:09,200
and i can ask the system

00:45:06,640 --> 00:45:11,200
the current time of the system clock and

00:45:09,200 --> 00:45:13,359
then create a zone time

00:45:11,200 --> 00:45:15,920
and finally if i want to output any of

00:45:13,359 --> 00:45:20,720
these times you can just use

00:45:15,920 --> 00:45:20,720
the insertion operator like this

00:45:27,040 --> 00:45:31,760
next feature is spam a spam provides a

00:45:30,079 --> 00:45:34,160
view over some contiguous

00:45:31,760 --> 00:45:35,839
data span does not own anything so it

00:45:34,160 --> 00:45:36,960
will never allocate and de-allocate

00:45:35,839 --> 00:45:38,720
basically it's just

00:45:36,960 --> 00:45:40,960
a pointer to the first element of the

00:45:38,720 --> 00:45:43,359
continuous data

00:45:40,960 --> 00:45:44,960
and the size of the data so that's also

00:45:43,359 --> 00:45:46,880
why it's very cheap to copy and it's

00:45:44,960 --> 00:45:47,200
recommended to pass them by value just

00:45:46,880 --> 00:45:51,920
as

00:45:47,200 --> 00:45:53,920
as you do with a string view and also

00:45:51,920 --> 00:45:55,599
unlike string view string view always is

00:45:53,920 --> 00:45:57,839
a read only view of a string

00:45:55,599 --> 00:46:00,640
but a span can be either read or write

00:45:57,839 --> 00:46:02,800
and we'll see an example of that

00:46:00,640 --> 00:46:04,000
a spend can be either dynamic size to

00:46:02,800 --> 00:46:07,119
fix size

00:46:04,000 --> 00:46:10,240
so here i have a c style array and i

00:46:07,119 --> 00:46:13,440
construct the span over that with

00:46:10,240 --> 00:46:14,160
type int and size 42 so this is a fixed

00:46:13,440 --> 00:46:17,440
size

00:46:14,160 --> 00:46:19,520
span if i construct my span as follows

00:46:17,440 --> 00:46:22,480
i don't specify the 42 then it's the

00:46:19,520 --> 00:46:25,119
so-called dynamic size pen

00:46:22,480 --> 00:46:26,000
if i provided the wrong size for example

00:46:25,119 --> 00:46:28,160
50 while

00:46:26,000 --> 00:46:30,400
i only have 42 elements then i will get

00:46:28,160 --> 00:46:33,680
a compilation error

00:46:30,400 --> 00:46:36,240
if i have a pointer and a length to some

00:46:33,680 --> 00:46:38,560
part in memory i have a dynamic size

00:46:36,240 --> 00:46:40,800
span

00:46:38,560 --> 00:46:42,480
and all of these pens are read right so

00:46:40,800 --> 00:46:45,680
through the span i can modify

00:46:42,480 --> 00:46:48,000
the the elements in my data array

00:46:45,680 --> 00:46:49,920
if you don't want that and you want to

00:46:48,000 --> 00:46:52,800
construct a read-only span

00:46:49,920 --> 00:46:53,520
you should construct a span of constant

00:46:52,800 --> 00:46:57,839
and not

00:46:53,520 --> 00:46:57,839
a const span end

00:46:59,920 --> 00:47:03,359
and spam supports quite a lot of

00:47:02,160 --> 00:47:05,119
operations so of course

00:47:03,359 --> 00:47:07,359
that's full support for iterators so you

00:47:05,119 --> 00:47:08,800
can ask begin and end iterator and so on

00:47:07,359 --> 00:47:10,000
you can ask for the first element the

00:47:08,800 --> 00:47:13,040
last element you can

00:47:10,000 --> 00:47:15,200
access any element in the contiguous

00:47:13,040 --> 00:47:17,040
data using the square bracket operator

00:47:15,200 --> 00:47:17,920
you can ask for the size the size and

00:47:17,040 --> 00:47:20,079
bytes

00:47:17,920 --> 00:47:21,040
you can ask for a subspan you can ask

00:47:20,079 --> 00:47:22,720
for the first

00:47:21,040 --> 00:47:24,240
number of elements or the last number of

00:47:22,720 --> 00:47:26,160
elements or even

00:47:24,240 --> 00:47:28,400
a certain subspan in the middle of your

00:47:26,160 --> 00:47:28,400
span

00:47:31,119 --> 00:47:34,160
the next thing i want to talk about is

00:47:32,800 --> 00:47:36,000
feature testing macros

00:47:34,160 --> 00:47:37,839
so these allow you to check if your

00:47:36,000 --> 00:47:38,480
compiler supports certain language

00:47:37,839 --> 00:47:41,680
features

00:47:38,480 --> 00:47:43,520
or standard library features so here are

00:47:41,680 --> 00:47:45,440
some examples of language features you

00:47:43,520 --> 00:47:46,960
can check if your compiler supports the

00:47:45,440 --> 00:47:49,520
fall through attribute

00:47:46,960 --> 00:47:52,559
whether it supports binary literals

00:47:49,520 --> 00:47:54,240
co-routines and so on

00:47:52,559 --> 00:47:56,480
and similarly you can check standard

00:47:54,240 --> 00:47:58,160
library feature you can check if your

00:47:56,480 --> 00:47:59,920
implementation of the standard library

00:47:58,160 --> 00:48:01,839
that you're using supports concept

00:47:59,920 --> 00:48:03,599
ranges scope lock and so on there are

00:48:01,839 --> 00:48:06,319
quite a lot

00:48:03,599 --> 00:48:08,960
dozens and dozens of other feature

00:48:06,319 --> 00:48:10,640
testing markers that you can use

00:48:08,960 --> 00:48:12,000
let's have a look at a simple example

00:48:10,640 --> 00:48:13,680
here

00:48:12,000 --> 00:48:15,119
i first check if i have an optional

00:48:13,680 --> 00:48:17,520
header if i do have it

00:48:15,119 --> 00:48:18,880
i include it and then i double check if

00:48:17,520 --> 00:48:19,680
this optional header is actually

00:48:18,880 --> 00:48:21,839
defining

00:48:19,680 --> 00:48:23,839
the cpp lib option and if that is the

00:48:21,839 --> 00:48:25,359
case then we have optional

00:48:23,839 --> 00:48:26,880
if we don't have the optional header

00:48:25,359 --> 00:48:28,720
then we check if we have maybe the

00:48:26,880 --> 00:48:31,520
experimental optional header

00:48:28,720 --> 00:48:35,839
include it and check again what it

00:48:31,520 --> 00:48:35,839
exactly defines

00:48:37,040 --> 00:48:40,640
version is a new header file introduced

00:48:38,880 --> 00:48:42,079
in c plus plus 20 and it supplies

00:48:40,640 --> 00:48:45,520
implementation dependent

00:48:42,079 --> 00:48:49,359
information about the c plus plus

00:48:45,520 --> 00:48:51,760
compiler that you're using

00:48:49,359 --> 00:48:52,559
what it contains it depends on on your

00:48:51,760 --> 00:48:54,400
compiler

00:48:52,559 --> 00:48:56,800
some examples are it can be a version

00:48:54,400 --> 00:48:59,680
number copyright notice and so on

00:48:56,800 --> 00:49:00,880
one thing that is required for this

00:48:59,680 --> 00:49:02,960
header to include

00:49:00,880 --> 00:49:04,800
is it should give you support it should

00:49:02,960 --> 00:49:06,480
give you access to the library feature

00:49:04,800 --> 00:49:08,240
test macros

00:49:06,480 --> 00:49:12,079
so whenever you want to use these macros

00:49:08,240 --> 00:49:12,079
you have to include this version header

00:49:14,720 --> 00:49:19,040
const expert functions have been added a

00:49:17,440 --> 00:49:20,000
long time ago to the c plus plus

00:49:19,040 --> 00:49:23,440
standards

00:49:20,000 --> 00:49:25,040
but they allow functions to be executed

00:49:23,440 --> 00:49:27,359
at compile time but it's not a hard

00:49:25,040 --> 00:49:29,280
requirement let's look at an example

00:49:27,359 --> 00:49:30,960
i have a function here inch to

00:49:29,280 --> 00:49:31,920
millimeter and it's marked as cons

00:49:30,960 --> 00:49:33,839
expert

00:49:31,920 --> 00:49:35,520
if i call this function we're using a

00:49:33,839 --> 00:49:37,119
cons double

00:49:35,520 --> 00:49:39,119
everything is fine everything will be

00:49:37,119 --> 00:49:41,040
executed at compile time

00:49:39,119 --> 00:49:42,880
but if i call it with a double so not a

00:49:41,040 --> 00:49:45,359
const double but a double

00:49:42,880 --> 00:49:47,280
then everything will x be executed at

00:49:45,359 --> 00:49:48,960
runtime i will not have any compilation

00:49:47,280 --> 00:49:50,880
error it will just silently call my

00:49:48,960 --> 00:49:52,559
function at runtime

00:49:50,880 --> 00:49:54,079
and sometimes this is not what you want

00:49:52,559 --> 00:49:55,760
and if that's not what you want you can

00:49:54,079 --> 00:49:56,720
turn your function into a so called

00:49:55,760 --> 00:49:59,359
immediate

00:49:56,720 --> 00:50:01,359
function using the const evol keyword so

00:49:59,359 --> 00:50:03,920
instead of using const expert

00:50:01,359 --> 00:50:06,000
i just specify const evil and the rest

00:50:03,920 --> 00:50:08,240
remains the same

00:50:06,000 --> 00:50:09,119
now if i call this with a cons double of

00:50:08,240 --> 00:50:10,880
course

00:50:09,119 --> 00:50:12,400
everything is still fine everything is

00:50:10,880 --> 00:50:15,200
done at compile time

00:50:12,400 --> 00:50:16,880
but if i call it with a non-const double

00:50:15,200 --> 00:50:17,680
then i will actually get a compilation

00:50:16,880 --> 00:50:20,160
error because

00:50:17,680 --> 00:50:26,079
the compiler cannot evaluate this at

00:50:20,160 --> 00:50:28,319
compile time

00:50:26,079 --> 00:50:29,280
so const in it to help with uh well

00:50:28,319 --> 00:50:33,040
there is this thing called

00:50:29,280 --> 00:50:35,200
static initialization order fiasco

00:50:33,040 --> 00:50:36,720
um if you have dynamic initializers well

00:50:35,200 --> 00:50:38,319
you don't know in which order and

00:50:36,720 --> 00:50:40,240
everything will be initialized so that's

00:50:38,319 --> 00:50:41,760
really bad if you have constant

00:50:40,240 --> 00:50:44,400
initializers

00:50:41,760 --> 00:50:46,480
that's okay you know that the

00:50:44,400 --> 00:50:48,000
initializations will be okay but they're

00:50:46,480 --> 00:50:49,520
complex rules and it's not always

00:50:48,000 --> 00:50:51,280
trivial for

00:50:49,520 --> 00:50:52,800
for someone that is browsing your code

00:50:51,280 --> 00:50:54,640
to know whether some constant

00:50:52,800 --> 00:50:56,880
initialization is happening or dynamic

00:50:54,640 --> 00:50:58,720
initialization

00:50:56,880 --> 00:51:00,079
and with the const in its keywords you

00:50:58,720 --> 00:51:01,920
can actually force constant

00:51:00,079 --> 00:51:04,800
initialization so here

00:51:01,920 --> 00:51:06,960
i'm defining a variable a and i require

00:51:04,800 --> 00:51:08,720
constant initialization so if

00:51:06,960 --> 00:51:10,720
if here there is some kind of dynamic

00:51:08,720 --> 00:51:13,839
initialization then the compiler

00:51:10,720 --> 00:51:14,880
will give an error instead of giving you

00:51:13,839 --> 00:51:17,839
strange

00:51:14,880 --> 00:51:17,839
runtime behavior

00:51:20,319 --> 00:51:24,240
class enums well the class enums that

00:51:22,480 --> 00:51:27,760
have been introduced in c plus

00:51:24,240 --> 00:51:30,559
11 they were strongly typed um

00:51:27,760 --> 00:51:32,960
and also you always have to specify the

00:51:30,559 --> 00:51:35,920
uh the name of the class in them because

00:51:32,960 --> 00:51:38,240
the different values of the enum were

00:51:35,920 --> 00:51:40,480
not exported to the parent scope

00:51:38,240 --> 00:51:43,119
and sometimes it is cumbersome so now in

00:51:40,480 --> 00:51:44,960
c plus 20 you can use a using directive

00:51:43,119 --> 00:51:47,839
using enum card type suit

00:51:44,960 --> 00:51:49,359
suit and then you don't have to specify

00:51:47,839 --> 00:51:50,640
these all the time

00:51:49,359 --> 00:51:53,040
of course you have to be careful with

00:51:50,640 --> 00:51:54,079
using this feature um i would recommend

00:51:53,040 --> 00:51:56,000
to use this on

00:51:54,079 --> 00:51:57,280
a small scope as small as possible

00:51:56,000 --> 00:51:59,119
because otherwise

00:51:57,280 --> 00:52:00,720
you're exporting everything again to the

00:51:59,119 --> 00:52:02,559
parent scope and then

00:52:00,720 --> 00:52:04,319
you you might again have the problems

00:52:02,559 --> 00:52:07,040
like you have with the old c style

00:52:04,319 --> 00:52:07,040
enumerations

00:52:09,040 --> 00:52:12,079
text formatting there are two ways at

00:52:11,200 --> 00:52:14,160
the moment in

00:52:12,079 --> 00:52:16,480
in c plus plus 17 there are two ways to

00:52:14,160 --> 00:52:18,720
format text you can use i o streams

00:52:16,480 --> 00:52:20,079
they are save and extensible extensible

00:52:18,720 --> 00:52:21,839
you just have to

00:52:20,079 --> 00:52:23,599
overload the insertion and extraction

00:52:21,839 --> 00:52:25,200
operators

00:52:23,599 --> 00:52:27,119
but they are hard to read hard to

00:52:25,200 --> 00:52:29,680
localize because there is no separation

00:52:27,119 --> 00:52:31,680
of the format string and the arguments

00:52:29,680 --> 00:52:34,240
on the other end we have printf which is

00:52:31,680 --> 00:52:36,000
not safe not extensible

00:52:34,240 --> 00:52:37,680
but it's easier to read because you have

00:52:36,000 --> 00:52:39,280
a nice separation between the format

00:52:37,680 --> 00:52:40,559
string and the different arguments and

00:52:39,280 --> 00:52:44,880
because of that it's also

00:52:40,559 --> 00:52:46,000
easier to localize now sdd format in c

00:52:44,880 --> 00:52:48,640
plus plus 20

00:52:46,000 --> 00:52:49,359
combines the the advantages of both io

00:52:48,640 --> 00:52:52,480
streams

00:52:49,359 --> 00:52:54,640
and printf and the result is

00:52:52,480 --> 00:52:56,319
save and extensible you just have to

00:52:54,640 --> 00:52:58,480
implement a specialization

00:52:56,319 --> 00:53:00,480
sd formatter to add support for your own

00:52:58,480 --> 00:53:02,160
custom types

00:53:00,480 --> 00:53:03,839
they are easy to use because they have a

00:53:02,160 --> 00:53:05,280
nice separation of the format string and

00:53:03,839 --> 00:53:07,040
the arguments

00:53:05,280 --> 00:53:08,960
so that means they are also easily

00:53:07,040 --> 00:53:10,079
localizable

00:53:08,960 --> 00:53:12,640
and the nice thing is that they are

00:53:10,079 --> 00:53:15,680
actually more performant than s printf

00:53:12,640 --> 00:53:17,680
or string stream and two string

00:53:15,680 --> 00:53:19,760
so there is no reason not to switch to

00:53:17,680 --> 00:53:22,319
std format

00:53:19,760 --> 00:53:22,960
here is a simple example i'm outputting

00:53:22,319 --> 00:53:26,400
the string

00:53:22,960 --> 00:53:29,440
cppcon 20 in a field that is 19

00:53:26,400 --> 00:53:31,359
characters long with the text centered

00:53:29,440 --> 00:53:33,760
and using an equal sign as the fill

00:53:31,359 --> 00:53:33,760
character

00:53:34,079 --> 00:53:38,079
and in this second example i'm using i'm

00:53:36,960 --> 00:53:40,640
explicitly

00:53:38,079 --> 00:53:41,200
giving indices for my arguments so here

00:53:40,640 --> 00:53:43,760
this

00:53:41,200 --> 00:53:45,040
this placeholder is replaced with n and

00:53:43,760 --> 00:53:48,319
this placeholder is

00:53:45,040 --> 00:53:51,359
replaced with file1.txt and thanks to

00:53:48,319 --> 00:53:53,280
these positional arguments

00:53:51,359 --> 00:53:54,480
localization is pretty easy so if i

00:53:53,280 --> 00:53:56,960
translate this

00:53:54,480 --> 00:53:59,920
read zero bytes from one if i translate

00:53:56,960 --> 00:54:01,599
this to chinese in chinese we have to

00:53:59,920 --> 00:54:03,280
um change the order of the one and the

00:54:01,599 --> 00:54:05,040
zero arguments

00:54:03,280 --> 00:54:06,640
so you just have to modify your format

00:54:05,040 --> 00:54:11,839
string you don't have to

00:54:06,640 --> 00:54:11,839
modify the order of your arguments here

00:54:12,720 --> 00:54:16,720
there is a new header file called

00:54:14,559 --> 00:54:17,359
numbers and it defines it finally

00:54:16,720 --> 00:54:19,440
defines

00:54:17,359 --> 00:54:20,800
a number of mathematical mathematical

00:54:19,440 --> 00:54:22,800
constants such as pi

00:54:20,800 --> 00:54:24,079
e and so on and they are all living in

00:54:22,800 --> 00:54:27,040
the std

00:54:24,079 --> 00:54:27,040
numbers namespace

00:54:30,800 --> 00:54:35,119
source location source location is

00:54:33,280 --> 00:54:36,160
defined in the source location heather

00:54:35,119 --> 00:54:37,599
and

00:54:36,160 --> 00:54:39,200
an instance of a source location

00:54:37,599 --> 00:54:39,839
basically gives you information of a

00:54:39,200 --> 00:54:42,160
specific

00:54:39,839 --> 00:54:43,839
line number in your code column number

00:54:42,160 --> 00:54:44,720
gives you the file name and a function

00:54:43,839 --> 00:54:46,319
name

00:54:44,720 --> 00:54:48,480
and you can construct one using the

00:54:46,319 --> 00:54:51,200
static number current

00:54:48,480 --> 00:54:52,000
and this is very useful for lowing for

00:54:51,200 --> 00:54:54,880
example

00:54:52,000 --> 00:54:56,400
here i have a function log info it locks

00:54:54,880 --> 00:54:58,079
some kind of string

00:54:56,400 --> 00:55:00,559
and the second parameter is a source

00:54:58,079 --> 00:55:01,440
location and it has a default value of

00:55:00,559 --> 00:55:03,760
current

00:55:01,440 --> 00:55:06,079
and the trick here is that the

00:55:03,760 --> 00:55:10,000
evaluation of source location current

00:55:06,079 --> 00:55:11,680
is actually happening at the call side

00:55:10,000 --> 00:55:13,200
that means that location is actually

00:55:11,680 --> 00:55:15,760
filled in with the

00:55:13,200 --> 00:55:17,280
function name file name line number and

00:55:15,760 --> 00:55:20,240
column number of where i'm actually

00:55:17,280 --> 00:55:23,040
calling this log

00:55:20,240 --> 00:55:25,359
so this avoids so thanks to this you

00:55:23,040 --> 00:55:28,480
don't have to use any macros anymore to

00:55:25,359 --> 00:55:28,480
to to achieve this

00:55:31,280 --> 00:55:37,280
no discard attribute has been added to

00:55:34,400 --> 00:55:37,760
um in c plus 11 i think but now you can

00:55:37,280 --> 00:55:40,160
include

00:55:37,760 --> 00:55:41,680
a reason in textual form so you can say

00:55:40,160 --> 00:55:43,440
something like no discard

00:55:41,680 --> 00:55:46,559
and then give a reason why you should

00:55:43,440 --> 00:55:50,160
not discard this

00:55:46,559 --> 00:55:50,160
the return value of this function

00:55:52,160 --> 00:55:55,760
the standard library now has support for

00:55:54,079 --> 00:55:57,359
so-called bit operations

00:55:55,760 --> 00:55:58,960
and everything is defined in the bit

00:55:57,359 --> 00:56:01,119
header you can ask for

00:55:58,960 --> 00:56:02,799
rotating bits left or right or you can

00:56:01,119 --> 00:56:04,799
ask to count the number

00:56:02,799 --> 00:56:06,640
consecutive number of zero bits or one

00:56:04,799 --> 00:56:08,400
bit starting from the most significant

00:56:06,640 --> 00:56:10,720
or least significant bit

00:56:08,400 --> 00:56:14,720
and finally you can also ask for give me

00:56:10,720 --> 00:56:14,720
the total number of one bits in a bit

00:56:14,839 --> 00:56:18,640
sequence

00:56:16,480 --> 00:56:20,880
here is an example so the first one is

00:56:18,640 --> 00:56:24,799
constructing a bit set

00:56:20,880 --> 00:56:27,359
by rotating this given bit sequence

00:56:24,799 --> 00:56:29,200
two bits to the left and here we're just

00:56:27,359 --> 00:56:32,240
counting the number of one bits in my

00:56:29,200 --> 00:56:32,240
given bit sequence

00:56:34,160 --> 00:56:38,240
then there are a couple of smaller

00:56:36,720 --> 00:56:39,920
things additions to existing

00:56:38,240 --> 00:56:42,240
functionality so a string

00:56:39,920 --> 00:56:45,280
and a basic string and a string view now

00:56:42,240 --> 00:56:47,200
supports starts with and ends with

00:56:45,280 --> 00:56:49,040
we finally have a contains method for

00:56:47,200 --> 00:56:50,640
associative containers so before you

00:56:49,040 --> 00:56:51,680
always have to use either the find

00:56:50,640 --> 00:56:53,760
methods or

00:56:51,680 --> 00:56:55,440
the count method to figure out if a

00:56:53,760 --> 00:56:56,319
certain key is in an associative

00:56:55,440 --> 00:57:00,079
container

00:56:56,319 --> 00:57:00,079
now you can just use contains

00:57:00,160 --> 00:57:03,520
remove remove if and unique for list and

00:57:02,319 --> 00:57:05,280
forward list

00:57:03,520 --> 00:57:06,720
they now return the number of elements

00:57:05,280 --> 00:57:08,880
that that it removed

00:57:06,720 --> 00:57:11,200
and before it didn't return anything but

00:57:08,880 --> 00:57:14,559
since this is just a change in in return

00:57:11,200 --> 00:57:16,000
type this is not a breaking change

00:57:14,559 --> 00:57:18,000
we have two new algorithms in the

00:57:16,000 --> 00:57:20,079
algorithm header we have shift left and

00:57:18,000 --> 00:57:23,359
shift right

00:57:20,079 --> 00:57:24,559
and we have also sdd arrays and std

00:57:23,359 --> 00:57:27,040
erase if

00:57:24,559 --> 00:57:28,160
and by using these you don't have to use

00:57:27,040 --> 00:57:30,240
the so-called remove

00:57:28,160 --> 00:57:31,680
erase idiom anymore you can just ask a

00:57:30,240 --> 00:57:34,559
vector for example

00:57:31,680 --> 00:57:37,520
erase all the elements that satisfy a

00:57:34,559 --> 00:57:37,520
certain predicate

00:57:39,599 --> 00:57:44,319
and finally we have two mathematical new

00:57:42,480 --> 00:57:45,920
functions we have midpoint calculate the

00:57:44,319 --> 00:57:47,599
midpoint of two numbers

00:57:45,920 --> 00:57:49,280
and we have lerp to do some linear

00:57:47,599 --> 00:57:51,119
interpolation

00:57:49,280 --> 00:57:53,200
and then last thing is there is a new

00:57:51,119 --> 00:57:56,079
unsequence policy

00:57:53,200 --> 00:57:57,760
that you can use or to pass through an

00:57:56,079 --> 00:57:59,760
parallel algorithm and what this

00:57:57,760 --> 00:58:01,440
says is that the algorithm is allowed to

00:57:59,760 --> 00:58:03,440
vectorize its execution

00:58:01,440 --> 00:58:09,359
but it is not allowed to parallelize so

00:58:03,440 --> 00:58:12,319
only vectorization is allowed

00:58:09,359 --> 00:58:13,599
so that's it i that's all the the topics

00:58:12,319 --> 00:58:17,040
i want to touch

00:58:13,599 --> 00:58:20,000
today um i would like to thank peter von

00:58:17,040 --> 00:58:22,400
weird for um reviewing these slides and

00:58:20,000 --> 00:58:23,200
i'm not sure if we have any time left

00:58:22,400 --> 00:58:26,799
for for

00:58:23,200 --> 00:58:28,559
questions but let me switch to remo and

00:58:26,799 --> 00:58:37,839
see if there are any

00:58:28,559 --> 00:58:37,839
questions thank you

00:58:51,760 --> 00:58:53,839

YouTube URL: https://www.youtube.com/watch?v=FRkJCvHWdwQ


