Title: CppCon 2015: Fedor Pikus PART 1 “Live Lock-Free or Deadlock (Practical Lock-free Programming)"
Publication date: 2015-10-09
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Part I: Introduction to lock-free programming. We will cover the fundamentals of lock-free vs lock-based programming, explore the reasons to write lock-free programs as well as the reasons not to. We will learn, or be reminded, of the basic tools of lock-free programming and consider few simple examples. To make sure you stay on for part II, we will try something beyond the simple examples, for example, a lock-free list, just to see how insanely complex the problems can get. Part II: having been burned on the complexities of generic lock-free algorithms in part I, we take a more practical approach: assuming we are not all writing STL, what limitations can we really live with? Turns out that there are some inherent limitations imposed by the nature of the concurrent problem: is here really such a thing as “concurrent queue” (yes, sort of) and we can take advantages of these limitations (what an idea, concurrency actually makes something easier!) Then there are practical limitations that most application programmers can accept: is there really such a thing as a “lock-free queue” (may be, and you don’t need it). We will explore practical examples of (mostly) lock-free data structures, with actual implementations and performance measurements. Even if the specific limitations and simplifying assumptions used in this talk do not apply to your problem, the main idea to take away is how to find such assumptions and take advantage of them, because, chances are, you can use lock-free techniques and write code that works for you and is much simpler than what you learned before.
— 
Fedor G Pikus is a Chief Engineering Scientist in the Design to Silicon division of Mentor Graphics Corp. His earlier positions included a Senior Software Engineer at Google, and a Chief Software Architect for Calibre PERC, LVS, DFM at Mentor Graphics. He joined Mentor Graphics in 1998 when he made a switch from academic research in computational physics to software industry. His responsibilities as a Chief Scientist include planning long-term technical direction of Calibre products, directing and training the engineers who work on these products, design and architecture of the software, and research in new design and software technologies. Fedor has over 25 patents and over 90 papers and conference presentations on physics, EDA, software design, and C++ language.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:07,440
welcome to the first of the talks on

00:00:03,480 --> 00:00:09,719
Atomics and lock-free and all the

00:00:07,440 --> 00:00:13,049
concurrent stuff that there will be

00:00:09,719 --> 00:00:15,240
several more and I'll try to introduce

00:00:13,049 --> 00:00:19,650
some of the materials that will be

00:00:15,240 --> 00:00:27,960
covered later this is in two parts we'll

00:00:19,650 --> 00:00:31,109
find a good place to break so the

00:00:27,960 --> 00:00:36,180
roadmap well we'll get through all the

00:00:31,109 --> 00:00:37,710
stages yes I will do the double check

00:00:36,180 --> 00:00:40,559
locking everybody does it

00:00:37,710 --> 00:00:43,020
I have my own twist on it so I hope I

00:00:40,559 --> 00:00:45,000
can show you something interesting even

00:00:43,020 --> 00:00:54,780
though the subject has been beaten quite

00:00:45,000 --> 00:00:56,430
to death no this was on Wednesday I give

00:00:54,780 --> 00:01:05,909
a talk about handling exceptions this

00:00:56,430 --> 00:01:07,260
was supposed to happen then not now okay

00:01:05,909 --> 00:01:09,930
this one is not about handling

00:01:07,260 --> 00:01:12,150
exceptions so wait for exceptions for

00:01:09,930 --> 00:01:14,689
Wednesday this is about writing good

00:01:12,150 --> 00:01:19,650
concurrent program specifically with C++

00:01:14,689 --> 00:01:22,470
emphasis is on practical which means in

00:01:19,650 --> 00:01:25,979
practical applications not a library

00:01:22,470 --> 00:01:28,229
development okay how many people here

00:01:25,979 --> 00:01:32,220
write like applications you know the

00:01:28,229 --> 00:01:36,560
specific concrete very good

00:01:32,220 --> 00:01:39,810
who writes libraries well you may find

00:01:36,560 --> 00:01:43,170
something useful in this but you will be

00:01:39,810 --> 00:01:46,409
limited now I do like questions I didn't

00:01:43,170 --> 00:01:48,000
expect to be in in this room and here

00:01:46,409 --> 00:01:50,810
it's hard to pass mic so if you can

00:01:48,000 --> 00:01:54,720
project and something is unclear to you

00:01:50,810 --> 00:01:57,270
try to interrupt me and ask questions I

00:01:54,720 --> 00:01:59,009
don't like to leave anything unclear as

00:01:57,270 --> 00:02:00,750
we go through because as you know we

00:01:59,009 --> 00:02:02,820
have two hours of material if something

00:02:00,750 --> 00:02:04,590
is unclear by the time we get to the end

00:02:02,820 --> 00:02:07,020
of it in the first hour you will be

00:02:04,590 --> 00:02:10,140
missing a big chunk

00:02:07,020 --> 00:02:10,739
also there are while I try to be

00:02:10,140 --> 00:02:13,050
accurate

00:02:10,739 --> 00:02:13,830
I am explicitly not going to be precise

00:02:13,050 --> 00:02:15,610
I will be

00:02:13,830 --> 00:02:17,800
jumping over things I will be

00:02:15,610 --> 00:02:19,780
simplifying things and there are several

00:02:17,800 --> 00:02:22,480
talks following on if you want to know

00:02:19,780 --> 00:02:25,720
the real truth if you can handle the

00:02:22,480 --> 00:02:31,990
truth you go there and you learn all

00:02:25,720 --> 00:02:35,500
about some of the details the reason I

00:02:31,990 --> 00:02:36,970
put this on is not you know the regular

00:02:35,500 --> 00:02:38,560
slide about the authors how many papers

00:02:36,970 --> 00:02:40,750
how many of these how many of that it

00:02:38,560 --> 00:02:43,600
gives you the better understanding of

00:02:40,750 --> 00:02:46,000
your my perspective sort of everybody

00:02:43,600 --> 00:02:52,480
has a keyhole everybody has a lens they

00:02:46,000 --> 00:02:54,550
look at software this is mine I work on

00:02:52,480 --> 00:02:57,990
software that deals with very large

00:02:54,550 --> 00:03:00,940
scale problems we have solvents of

00:02:57,990 --> 00:03:04,030
course and hundreds of maybe hundreds of

00:03:00,940 --> 00:03:06,360
thousands of course running for

00:03:04,030 --> 00:03:09,190
sometimes for hours sometimes for days

00:03:06,360 --> 00:03:11,140
billions of objects at the same time and

00:03:09,190 --> 00:03:12,970
they're getting turned around you know

00:03:11,140 --> 00:03:15,460
if you're if you have one gigabyte of

00:03:12,970 --> 00:03:20,290
memory we probably have churned around a

00:03:15,460 --> 00:03:23,800
terabyte per hour or more we write

00:03:20,290 --> 00:03:25,750
software for sale we have to write it

00:03:23,800 --> 00:03:28,090
for whatever our customers running on

00:03:25,750 --> 00:03:30,850
how many people write software for like

00:03:28,090 --> 00:03:33,489
for sale to external you know basically

00:03:30,850 --> 00:03:37,360
your customers you live by the money

00:03:33,489 --> 00:03:39,040
they pay okay so you understand we have

00:03:37,360 --> 00:03:40,890
customers who are very conservative and

00:03:39,040 --> 00:03:43,450
the reason they're very conservative is

00:03:40,890 --> 00:03:46,209
you know not because they're stupid or

00:03:43,450 --> 00:03:49,690
anal but because if we screw up the

00:03:46,209 --> 00:03:52,530
production line on on a fab it could

00:03:49,690 --> 00:03:56,290
really be hundreds of millions per day

00:03:52,530 --> 00:03:58,810
so you know half of our customers are

00:03:56,290 --> 00:04:00,519
around on RedHat five right now the

00:03:58,810 --> 00:04:04,269
newest compiler you can get on a

00:04:00,519 --> 00:04:08,200
standard hat hat five is GCC is three

00:04:04,269 --> 00:04:15,840
four something or other which brings us

00:04:08,200 --> 00:04:18,850
to the subject writing log free programs

00:04:15,840 --> 00:04:22,230
writing log free programs is hard what's

00:04:18,850 --> 00:04:22,230
harder than writing log free programs

00:04:24,060 --> 00:04:34,110
incorrect love free programs in practice

00:04:31,860 --> 00:04:35,880
so you go to theory about lock-free and

00:04:34,110 --> 00:04:37,440
they tell you everything you know about

00:04:35,880 --> 00:04:40,350
all the problems with locks and all the

00:04:37,440 --> 00:04:42,450
reasons to go lock free and you go out

00:04:40,350 --> 00:04:43,740
and you forget it and you start writing

00:04:42,450 --> 00:04:50,130
log free code because you think it's

00:04:43,740 --> 00:04:51,930
faster that's 90 percent flood okay if

00:04:50,130 --> 00:04:53,460
you are after the best performance

00:04:51,930 --> 00:04:54,480
what's rule number one about performance

00:04:53,460 --> 00:05:01,410
who knows the rule number one of

00:04:54,480 --> 00:05:04,770
performance yes or the other ways never

00:05:01,410 --> 00:05:07,169
guess about performance you will be

00:05:04,770 --> 00:05:08,700
surprised pretty much every time log

00:05:07,169 --> 00:05:09,990
three algorithm surprisingly enough do

00:05:08,700 --> 00:05:13,260
not always provide better performance

00:05:09,990 --> 00:05:19,290
even when they are correct incorrect

00:05:13,260 --> 00:05:22,410
ones often provide better performance so

00:05:19,290 --> 00:05:24,030
I have these take-home points that I'm

00:05:22,410 --> 00:05:28,050
going to kind of accumulate throughout

00:05:24,030 --> 00:05:30,690
the talk if you leave this room and you

00:05:28,050 --> 00:05:35,790
remember at least one of them I have

00:05:30,690 --> 00:05:41,160
done my job well now speaking of doing

00:05:35,790 --> 00:05:41,820
my job well who knows what a Q is Q okay

00:05:41,160 --> 00:05:43,440
very good

00:05:41,820 --> 00:05:45,240
I'll ask the same question at the end of

00:05:43,440 --> 00:05:47,460
the talk at the end of second hour if at

00:05:45,240 --> 00:05:51,440
least one of you hesitates to raise your

00:05:47,460 --> 00:05:51,440
hand I have done my job really well

00:05:53,750 --> 00:05:59,100
since I brought up the question of C++

00:05:56,550 --> 00:06:02,729
11 C++ 11 has atomic support and has

00:05:59,100 --> 00:06:04,560
memory barrier support as I said for

00:06:02,729 --> 00:06:07,440
some OVA for some people like myself

00:06:04,560 --> 00:06:09,750
it's not yet available but not because

00:06:07,440 --> 00:06:11,640
we you know we can't port our code to

00:06:09,750 --> 00:06:14,220
say plus plus eleven compilers because a

00:06:11,640 --> 00:06:15,870
large portion of our customer base works

00:06:14,220 --> 00:06:17,910
and systems where these compilers would

00:06:15,870 --> 00:06:21,180
be a custom software would require a

00:06:17,910 --> 00:06:25,710
custom library load and nothing custom

00:06:21,180 --> 00:06:27,300
gets loaded on those machines it's in

00:06:25,710 --> 00:06:28,860
some way more complex than the

00:06:27,300 --> 00:06:31,229
simplified level I'm going to be talking

00:06:28,860 --> 00:06:35,010
about now don't be alarmed if you're

00:06:31,229 --> 00:06:36,710
using C++ 11 I will use a kind of pseudo

00:06:35,010 --> 00:06:38,930
code that map you could

00:06:36,710 --> 00:06:41,389
one two one two C++ 11 you could

00:06:38,930 --> 00:06:43,699
implement your own C++ library to that

00:06:41,389 --> 00:06:45,620
exact interface that I will be using you

00:06:43,699 --> 00:06:48,289
can map it one-to-one to boost Atomics

00:06:45,620 --> 00:06:50,710
and pretty much any library that

00:06:48,289 --> 00:06:55,490
provides memory barriers and lock free

00:06:50,710 --> 00:06:58,820
atomic primitives so if that's the only

00:06:55,490 --> 00:07:01,930
thing that you know stops you from using

00:06:58,820 --> 00:07:01,930
it this is the least of your worries

00:07:02,590 --> 00:07:12,740
okay time for acknowledging the great

00:07:06,889 --> 00:07:17,080
ones so last year herb setter was giving

00:07:12,740 --> 00:07:19,400
the talk on come on one lock free and

00:07:17,080 --> 00:07:20,720
this is a slide from his talk he was

00:07:19,400 --> 00:07:22,880
giving this analogy this is your

00:07:20,720 --> 00:07:25,880
single-threaded program at the top do we

00:07:22,880 --> 00:07:34,400
have the note that you need this right

00:07:25,880 --> 00:07:46,400
now well I'm not so much interested in

00:07:34,400 --> 00:07:52,010
that I'm interested in oh all right

00:07:46,400 --> 00:07:55,159
it was like I can see it on my hand okay

00:07:52,010 --> 00:07:59,030
so anyway single-threaded program very

00:07:55,159 --> 00:08:02,690
easy the traffic lights are like locks

00:07:59,030 --> 00:08:05,030
and the highway overpass is like your

00:08:02,690 --> 00:08:07,340
lottery program everything just flows

00:08:05,030 --> 00:08:12,220
smoothly at my speed nobody waits for

00:08:07,340 --> 00:08:12,220
anybody this is why it's much better

00:08:12,970 --> 00:08:18,349
since I'm talking about practical I will

00:08:16,009 --> 00:08:20,090
do everything as example driven so I'll

00:08:18,349 --> 00:08:22,400
do by example and we'll try to

00:08:20,090 --> 00:08:23,690
generalize the examples this is one of

00:08:22,400 --> 00:08:25,270
the simplest examples of local

00:08:23,690 --> 00:08:27,560
programming double check locking

00:08:25,270 --> 00:08:28,669
everybody knows about it everybody have

00:08:27,560 --> 00:08:31,639
seen it at least once

00:08:28,669 --> 00:08:32,899
it does have some twists that I like to

00:08:31,639 --> 00:08:34,000
expose that maybe you haven't seen

00:08:32,899 --> 00:08:39,320
before

00:08:34,000 --> 00:08:40,640
now before C++ 11 it was actually really

00:08:39,320 --> 00:08:42,200
important for you to know because there

00:08:40,640 --> 00:08:45,050
was a huge caveat that you'll see in a

00:08:42,200 --> 00:08:47,120
moment in C++ 11 they made the thread

00:08:45,050 --> 00:08:49,220
safe static initializer which made

00:08:47,120 --> 00:08:51,889
double check locking irrelevant

00:08:49,220 --> 00:08:54,709
children know it made one application of

00:08:51,889 --> 00:08:56,180
double check locking irrelevant you'll

00:08:54,709 --> 00:08:58,129
see more double check locking is

00:08:56,180 --> 00:08:59,839
actually very useful for practical

00:08:58,129 --> 00:09:03,439
luxury programming toward the end you'll

00:08:59,839 --> 00:09:05,269
see what well let's do the classic

00:09:03,439 --> 00:09:06,649
application of double check locking the

00:09:05,269 --> 00:09:08,209
classic application of double check

00:09:06,649 --> 00:09:11,420
locking is singleton initialization

00:09:08,209 --> 00:09:14,959
we have some magic yzma thingy

00:09:11,420 --> 00:09:17,810
which has a transmogrify method and that

00:09:14,959 --> 00:09:20,480
member of that method is thread safe in

00:09:17,810 --> 00:09:22,819
order to operate the magic thingy we

00:09:20,480 --> 00:09:24,889
need to create one and there is only one

00:09:22,819 --> 00:09:27,259
of them there is only one for the entire

00:09:24,889 --> 00:09:27,769
program and then we need to transmogrify

00:09:27,259 --> 00:09:30,470
it

00:09:27,769 --> 00:09:31,910
there's no purify thread safe even if

00:09:30,470 --> 00:09:34,129
you call it by multiple threads at the

00:09:31,910 --> 00:09:36,589
same time on the same object so the

00:09:34,129 --> 00:09:40,370
question of thread safety is that line

00:09:36,589 --> 00:09:43,279
with a static initializer is it thread

00:09:40,370 --> 00:09:45,230
safe and what do I mean but thread safe

00:09:43,279 --> 00:09:47,360
by design there should be only one of

00:09:45,230 --> 00:09:50,019
these objects in the entire program well

00:09:47,360 --> 00:09:53,899
that's what static normally says now

00:09:50,019 --> 00:09:56,990
unless multiple threads enter operate

00:09:53,899 --> 00:10:00,949
function at the same time then it's a

00:09:56,990 --> 00:10:04,670
little less clear C++ before C++ eleven

00:10:00,949 --> 00:10:06,910
C++ standard had exactly this to say on

00:10:04,670 --> 00:10:06,910
the subject

00:10:07,870 --> 00:10:11,290
what threads

00:10:13,100 --> 00:10:17,450
C++ 11 introduced the concept of threads

00:10:15,980 --> 00:10:19,310
and the memory model so they could now

00:10:17,450 --> 00:10:22,270
actually talk about it and they said yes

00:10:19,310 --> 00:10:26,510
it is thread safe and the compiler said

00:10:22,270 --> 00:10:28,610
okay kinda most like the modern

00:10:26,510 --> 00:10:31,400
compilers actually mostly get a try GCC

00:10:28,610 --> 00:10:35,090
got it right got it right after four or

00:10:31,400 --> 00:10:38,990
four I think 4.4 not four zero four they

00:10:35,090 --> 00:10:42,380
had a bug where it wasn't safe anyway

00:10:38,990 --> 00:10:43,730
it's still instructive to go through so

00:10:42,380 --> 00:10:45,170
what's the problem

00:10:43,730 --> 00:10:46,730
first step you understand why wouldn't

00:10:45,170 --> 00:10:48,710
it be thread safe what the static

00:10:46,730 --> 00:10:50,840
initialization really do you know what's

00:10:48,710 --> 00:10:55,220
behind that first line that first

00:10:50,840 --> 00:10:57,320
statement well we have a pointer which

00:10:55,220 --> 00:10:59,570
starts its life as now on its its linker

00:10:57,320 --> 00:11:01,760
initialized so it's initially now Eve

00:10:59,570 --> 00:11:03,470
that point we go through that context of

00:11:01,760 --> 00:11:06,320
code if the pointer is currently now we

00:11:03,470 --> 00:11:08,630
need to create new object store its

00:11:06,320 --> 00:11:11,720
address in the pointer otherwise we

00:11:08,630 --> 00:11:15,170
don't need to do anything well here is

00:11:11,720 --> 00:11:18,500
the problem the problem is we have a

00:11:15,170 --> 00:11:20,360
data race two threads come in both start

00:11:18,500 --> 00:11:24,080
executing this code they both see now

00:11:20,360 --> 00:11:26,720
they both go in construct the copy of an

00:11:24,080 --> 00:11:28,730
object now one of them leaks because you

00:11:26,720 --> 00:11:34,730
only have one pointer the other

00:11:28,730 --> 00:11:36,590
assignment got stomped on unprotected

00:11:34,730 --> 00:11:38,210
static immunization is not thread safe

00:11:36,590 --> 00:11:42,560
and what's the root of the problem the

00:11:38,210 --> 00:11:45,950
root of the problem is that the checking

00:11:42,560 --> 00:11:47,960
for now and handling the null as

00:11:45,950 --> 00:11:50,120
creating the object assigning the

00:11:47,960 --> 00:11:52,100
pointer to the address to the pointer

00:11:50,120 --> 00:11:54,470
has to be done atomically in a single

00:11:52,100 --> 00:11:57,860
transaction it the whole thing has to be

00:11:54,470 --> 00:12:00,980
done as one uninterruptible atomic

00:11:57,860 --> 00:12:02,450
operation this concept of atomic

00:12:00,980 --> 00:12:04,460
operations and i don't mean in the sense

00:12:02,450 --> 00:12:07,160
of hardware Atomics i mean in the sense

00:12:04,460 --> 00:12:09,050
of this whole operation either happen or

00:12:07,160 --> 00:12:12,130
didn't happen but it cannot have happen

00:12:09,050 --> 00:12:15,230
nothing else can go on while this

00:12:12,130 --> 00:12:16,190
uninterruptible atomic transaction is

00:12:15,230 --> 00:12:18,950
being processed

00:12:16,190 --> 00:12:22,460
so the concept of such atomic operations

00:12:18,950 --> 00:12:24,500
is central to all concurrent programming

00:12:22,460 --> 00:12:27,310
whether you use locks or not you have to

00:12:24,500 --> 00:12:27,310
start thinking in these terms

00:12:27,920 --> 00:12:34,500
okay so the usual way of dealing with

00:12:32,010 --> 00:12:36,330
that is of course if you need if you

00:12:34,500 --> 00:12:38,250
need an atomic operation you put lock

00:12:36,330 --> 00:12:39,840
around the whole section of code that

00:12:38,250 --> 00:12:41,280
you want to be atomic and

00:12:39,840 --> 00:12:44,250
non-interactive also we put a lock

00:12:41,280 --> 00:12:50,340
before check for pointer and we unlock

00:12:44,250 --> 00:12:53,660
after this works there is however a big

00:12:50,340 --> 00:12:56,970
waste going on here after the few

00:12:53,660 --> 00:12:58,470
threads go through this may be the few

00:12:56,970 --> 00:13:00,900
threads come in at the same time and

00:12:58,470 --> 00:13:02,670
they struggle for the locks and so on

00:13:00,900 --> 00:13:05,570
but eventually it'll get initialized

00:13:02,670 --> 00:13:07,920
after that it will always be non now and

00:13:05,570 --> 00:13:09,870
it'll always be initialized and nobody

00:13:07,920 --> 00:13:11,640
needs to create a new one however we're

00:13:09,870 --> 00:13:14,340
always taking the lock locking and

00:13:11,640 --> 00:13:16,470
unlocking every time so that's the big

00:13:14,340 --> 00:13:16,920
waste you know our program has run for

00:13:16,470 --> 00:13:22,340
an hour

00:13:16,920 --> 00:13:26,160
we're still looking and unlocking okay

00:13:22,340 --> 00:13:28,410
we can since we know that eventually the

00:13:26,160 --> 00:13:31,680
pointer will be known now we'll just

00:13:28,410 --> 00:13:33,420
check for the pointer if it's now we

00:13:31,680 --> 00:13:35,030
know that this could be a data race here

00:13:33,420 --> 00:13:37,500
so we're now we're going to take a look

00:13:35,030 --> 00:13:39,120
check again and this is atomic

00:13:37,500 --> 00:13:42,180
transaction inside the lock this is why

00:13:39,120 --> 00:13:47,100
it's called double check locking there's

00:13:42,180 --> 00:13:49,440
only one problem this doesn't work it

00:13:47,100 --> 00:13:51,540
may work on your compiler I am told that

00:13:49,440 --> 00:13:53,760
I don't personally know that some

00:13:51,540 --> 00:13:57,150
versions of Visual Studio detect this in

00:13:53,760 --> 00:14:00,270
the source code as a pattern and emit

00:13:57,150 --> 00:14:01,560
correct code if you reorder a couple

00:14:00,270 --> 00:14:07,110
statements they don't detect it as a

00:14:01,560 --> 00:14:11,490
pattern so what does the initialization

00:14:07,110 --> 00:14:12,960
really do well it does something like

00:14:11,490 --> 00:14:15,090
this first it has to allocate memory

00:14:12,960 --> 00:14:18,300
obviously nothing can go on before we

00:14:15,090 --> 00:14:20,880
allocate memory then it has to construct

00:14:18,300 --> 00:14:25,070
the object in that memory so that's a

00:14:20,880 --> 00:14:28,200
placement new and finally it has to

00:14:25,070 --> 00:14:29,790
initialize that static pointer with the

00:14:28,200 --> 00:14:34,200
address of the temporary memory that we

00:14:29,790 --> 00:14:38,060
just allocated that's of the things that

00:14:34,200 --> 00:14:38,060
the three things that that must happen

00:14:40,620 --> 00:14:51,490
well this is also valid implementation

00:14:48,510 --> 00:14:54,610
allocate memory store the address of

00:14:51,490 --> 00:14:56,260
that memory in the pointer it right now

00:14:54,610 --> 00:14:58,780
doesn't point to an object here that

00:14:56,260 --> 00:15:01,690
points to uninitialized memory then

00:14:58,780 --> 00:15:04,960
construct the object in that memory and

00:15:01,690 --> 00:15:08,110
now now you're back to the same exact

00:15:04,960 --> 00:15:10,270
same state we changed the order we first

00:15:08,110 --> 00:15:12,820
initialized the static pointer then we

00:15:10,270 --> 00:15:14,470
constructed object both are valid from

00:15:12,820 --> 00:15:16,270
the point of view of the C++ compiler

00:15:14,470 --> 00:15:18,070
which means that the compiler can

00:15:16,270 --> 00:15:22,210
implement this expression any way it

00:15:18,070 --> 00:15:24,040
wants both both options are valid this

00:15:22,210 --> 00:15:26,470
one doesn't work for us because the

00:15:24,040 --> 00:15:28,390
pointer will be known now other threads

00:15:26,470 --> 00:15:30,040
will go through C the pointer is known

00:15:28,390 --> 00:15:31,990
now and try to use the memory when the

00:15:30,040 --> 00:15:33,820
object hasn't been constructed yet this

00:15:31,990 --> 00:15:40,090
is a bad order we want to force the

00:15:33,820 --> 00:15:42,190
other one okay so we're going to force

00:15:40,090 --> 00:15:44,700
this order we're going to write it

00:15:42,190 --> 00:15:49,590
explicitly like this allocate first

00:15:44,700 --> 00:15:49,590
construct second initialize third

00:15:50,040 --> 00:15:55,120
optimizers do this that's what the

00:15:52,750 --> 00:15:56,980
compiler writer is getting paid for to

00:15:55,120 --> 00:16:04,060
detect those temporary variables and

00:15:56,980 --> 00:16:06,480
eliminate them so compiler probably

00:16:04,060 --> 00:16:09,400
reduces it to something like that

00:16:06,480 --> 00:16:11,530
just eliminate the temporary store the

00:16:09,400 --> 00:16:13,510
address of malloc right in the pointer

00:16:11,530 --> 00:16:17,310
and then call the call the constructor

00:16:13,510 --> 00:16:20,560
on that memory compiler wins this round

00:16:17,310 --> 00:16:30,280
but never underestimate the ingenuity of

00:16:20,560 --> 00:16:34,170
the programmers we have a big hammer in

00:16:30,280 --> 00:16:37,360
C++ and by God we're going to use that

00:16:34,170 --> 00:16:40,360
we're going to the problem was that

00:16:37,360 --> 00:16:43,120
memory acts can power your direct memory

00:16:40,360 --> 00:16:45,880
accesses we have this volatile thing

00:16:43,120 --> 00:16:48,940
which tells the compiler do not

00:16:45,880 --> 00:16:51,760
eliminate any reads or writes and do not

00:16:48,940 --> 00:16:52,769
reorder them this is exactly what we

00:16:51,760 --> 00:16:55,569
need

00:16:52,769 --> 00:16:57,279
well we're going through this volatile

00:16:55,569 --> 00:17:00,809
on every invocation so there may be some

00:16:57,279 --> 00:17:02,170
performance penalty but never mind that

00:17:00,809 --> 00:17:06,039
now

00:17:02,170 --> 00:17:07,929
compiler cannnot tree order really every

00:17:06,039 --> 00:17:09,789
read and write has to happen exactly in

00:17:07,929 --> 00:17:13,150
the order that I have written so

00:17:09,789 --> 00:17:14,829
allocation has to happen then it's the

00:17:13,150 --> 00:17:16,270
address of the allocation stores in the

00:17:14,829 --> 00:17:18,039
temporary variable temporary variable

00:17:16,270 --> 00:17:19,890
now cannot be eliminated cannot cannot

00:17:18,039 --> 00:17:22,990
get rid of all at all reads and writes

00:17:19,890 --> 00:17:25,600
and the last thing is an assignment of

00:17:22,990 --> 00:17:27,189
the static pointer and since the last

00:17:25,600 --> 00:17:32,309
thing is a read from volatile has to

00:17:27,189 --> 00:17:32,309
happen there has to be last okay we win

00:17:33,809 --> 00:17:41,950
the victory will be very short-lived

00:17:36,720 --> 00:17:46,090
unfortunately the volatile keyword only

00:17:41,950 --> 00:17:48,279
applies to the C++ compiler there if you

00:17:46,090 --> 00:17:55,600
look at the object code there is no

00:17:48,279 --> 00:17:58,539
volatile there so now we have to think

00:17:55,600 --> 00:18:00,460
about what will the hardware do and we

00:17:58,539 --> 00:18:03,549
know that the for you basically if you

00:18:00,460 --> 00:18:06,220
read and write at the same time on

00:18:03,549 --> 00:18:07,960
multiple CPUs this is in general not

00:18:06,220 --> 00:18:10,899
thread safe there are all sorts of race

00:18:07,960 --> 00:18:13,149
condition and hardware but this is a

00:18:10,899 --> 00:18:14,399
talk about luxury programming Atomics

00:18:13,149 --> 00:18:16,620
have to be in here somewhere

00:18:14,399 --> 00:18:21,539
so that's probably what's missing right

00:18:16,620 --> 00:18:24,130
we're missing Atomics let's put them in

00:18:21,539 --> 00:18:27,340
okay as I said I told you I'm not using

00:18:24,130 --> 00:18:31,590
C++ 11 but you can map that atomic but

00:18:27,340 --> 00:18:31,590
in this case by dropping the lower case

00:18:31,740 --> 00:18:39,220
doesn't so the static pointer will be

00:18:36,309 --> 00:18:40,779
atomic now if you noticed volatile

00:18:39,220 --> 00:18:42,940
disappeared there is an assumption that

00:18:40,779 --> 00:18:44,980
Atomics have the volatile semantics and

00:18:42,940 --> 00:18:46,480
if you look at how they're implemented

00:18:44,980 --> 00:18:54,630
like for example if you look at GCC

00:18:46,480 --> 00:18:57,520
assembler they do so we have Atomics now

00:18:54,630 --> 00:18:59,710
since the our main static pointer is

00:18:57,520 --> 00:19:04,179
atomic we have to load it atomically

00:18:59,710 --> 00:19:05,330
check for now then we take the lock with

00:19:04,179 --> 00:19:08,690
in the lock we cannot do it

00:19:05,330 --> 00:19:13,760
atomic matter and we have to do a filmic

00:19:08,690 --> 00:19:29,500
store okay

00:19:13,760 --> 00:19:30,940
volatile again sorry actually yep okay

00:19:29,500 --> 00:19:34,010
sorry

00:19:30,940 --> 00:19:36,470
okay so atomic has been introduced there

00:19:34,010 --> 00:19:39,500
are volatile semantics compared to the

00:19:36,470 --> 00:19:41,330
previous slide with volatile who thinks

00:19:39,500 --> 00:19:46,490
we fixed at least some of the race

00:19:41,330 --> 00:19:54,020
conditions here and who thinks we

00:19:46,490 --> 00:19:58,730
haven't fixed any single one yeah we

00:19:54,020 --> 00:20:00,590
didn't really fix anything and this is

00:19:58,730 --> 00:20:02,090
probably the most teachable moment in

00:20:00,590 --> 00:20:05,990
this whole double-check looking pattern

00:20:02,090 --> 00:20:09,740
so let's explore this this is what we're

00:20:05,990 --> 00:20:16,250
counting on here no this wasn't what

00:20:09,740 --> 00:20:19,870
we're counting on okay can you hear me

00:20:16,250 --> 00:20:19,870
if it's lower like this okay

00:20:20,300 --> 00:20:30,650
this look is better CPU issues some

00:20:27,620 --> 00:20:31,850
memory rights and four at first are the

00:20:30,650 --> 00:20:33,320
memory writes for the constructor

00:20:31,850 --> 00:20:36,650
whatever we're using to initialize the

00:20:33,320 --> 00:20:39,650
object and they happen first and they

00:20:36,650 --> 00:20:42,380
get committed to memory first second is

00:20:39,650 --> 00:20:44,240
the memory right that commits the value

00:20:42,380 --> 00:20:46,870
of the address into the static pointer

00:20:44,240 --> 00:20:49,580
and that gets committed to memory second

00:20:46,870 --> 00:20:53,750
this is what we're counting on this is

00:20:49,580 --> 00:20:55,280
not how the world works and the reason

00:20:53,750 --> 00:20:56,780
this is not how the world works is

00:20:55,280 --> 00:21:01,370
because we have those pesky things

00:20:56,780 --> 00:21:03,500
called caches and they're very annoying

00:21:01,370 --> 00:21:06,350
they're very inconvenient they make life

00:21:03,500 --> 00:21:07,880
very complicated in the second half of

00:21:06,350 --> 00:21:10,120
the talk you'll see why we still have

00:21:07,880 --> 00:21:10,120
them

00:21:10,450 --> 00:21:16,250
so CPU indeed issues the rights in the

00:21:14,000 --> 00:21:18,400
order that I just described the there is

00:21:16,250 --> 00:21:20,990
no cheating here first grow the rights

00:21:18,400 --> 00:21:23,740
first we write into the object second we

00:21:20,990 --> 00:21:27,380
write into the pointer that's true

00:21:23,740 --> 00:21:30,590
what's not true is not necessarily true

00:21:27,380 --> 00:21:32,750
is what happens that those rights get

00:21:30,590 --> 00:21:34,940
committed to memory in the same order

00:21:32,750 --> 00:21:36,560
what's entirely feasible because at this

00:21:34,940 --> 00:21:38,960
point CPU has no control over what's

00:21:36,560 --> 00:21:40,220
going on CPU finished its writing to

00:21:38,960 --> 00:21:42,800
cache has gone on to do some other

00:21:40,220 --> 00:21:45,590
things cache gradually flashes it into

00:21:42,800 --> 00:21:50,330
memory or maybe not gradual if you ask

00:21:45,590 --> 00:21:51,940
for it again but in any order it was in

00:21:50,330 --> 00:21:54,710
particular it's entirely possible that

00:21:51,940 --> 00:21:57,080
in the main memory the static pointer

00:21:54,710 --> 00:22:00,320
gets updated first it's pointing to the

00:21:57,080 --> 00:22:02,390
location of the object and what was

00:22:00,320 --> 00:22:04,190
what's in main memory at that location

00:22:02,390 --> 00:22:07,520
of the object whatever was there before

00:22:04,190 --> 00:22:08,620
the random garbage that's entirely

00:22:07,520 --> 00:22:12,290
possible

00:22:08,620 --> 00:22:14,450
now this same CPU if it starts reading

00:22:12,290 --> 00:22:17,090
will read from its cache so it'll see

00:22:14,450 --> 00:22:18,590
the correct picture another CPU that

00:22:17,090 --> 00:22:20,360
doesn't share the cache was this one

00:22:18,590 --> 00:22:23,270
will read from the main memory and will

00:22:20,360 --> 00:22:24,590
see incorrect picture okay we're one of

00:22:23,270 --> 00:22:28,220
the battle was the compiler we lost it

00:22:24,590 --> 00:22:32,710
to the hardware not good well at this

00:22:28,220 --> 00:22:36,410
point you should actually question okay

00:22:32,710 --> 00:22:46,690
if everything is so messed up how the

00:22:36,410 --> 00:22:46,690
locks actually work yeah

00:22:52,750 --> 00:22:58,010
hold on to that question there is more

00:22:55,790 --> 00:22:59,540
than one atomic actually if you want to

00:22:58,010 --> 00:23:02,870
really know how many atomic though there

00:22:59,540 --> 00:23:07,790
are come to Michael once talk but I'll

00:23:02,870 --> 00:23:09,830
give you a simplified picture there is a

00:23:07,790 --> 00:23:12,290
reason why I said atomic store I'll say

00:23:09,830 --> 00:23:18,140
a little bit later about what kind of

00:23:12,290 --> 00:23:24,380
atomic store okay why does this never

00:23:18,140 --> 00:23:26,240
happen with looks I have to introduce

00:23:24,380 --> 00:23:28,130
this concept of memory barriers Michael

00:23:26,240 --> 00:23:32,630
will talk about memory barriers in great

00:23:28,130 --> 00:23:37,660
details and specifically for C++ 1114

00:23:32,630 --> 00:23:40,040
and so on and if you want to know like

00:23:37,660 --> 00:23:42,890
really know about memory barriers also

00:23:40,040 --> 00:23:44,660
follow on with polemic a nice talk but

00:23:42,890 --> 00:23:48,800
I'll introduce a simplified view of

00:23:44,660 --> 00:23:51,380
memory barriers without memory barriers

00:23:48,800 --> 00:23:55,010
there is no concurrent programming locks

00:23:51,380 --> 00:23:56,540
or no logs synchronous because memory

00:23:55,010 --> 00:23:58,790
barriers are what provides

00:23:56,540 --> 00:24:02,750
synchronization of memory visibility

00:23:58,790 --> 00:24:05,960
across different CPUs memory barriers

00:24:02,750 --> 00:24:11,090
are implemented in Hardware they are in

00:24:05,960 --> 00:24:14,210
Hardware specific and the last line used

00:24:11,090 --> 00:24:19,760
to be true it's not true in C++ 11 there

00:24:14,210 --> 00:24:21,800
are portable memory barriers now okay as

00:24:19,760 --> 00:24:23,990
I said I'll give you a very simplified

00:24:21,800 --> 00:24:26,510
picture of memory barriers there are two

00:24:23,990 --> 00:24:27,710
talks that deal was what's really there

00:24:26,510 --> 00:24:29,320
you really want to know how the world

00:24:27,710 --> 00:24:32,960
works

00:24:29,320 --> 00:24:34,760
so I'll reduce the entire universe of

00:24:32,960 --> 00:24:38,990
memory barriers to two barriers acquire

00:24:34,760 --> 00:24:41,900
and release on x86 it's actually pretty

00:24:38,990 --> 00:24:44,720
much good enough for you to know not

00:24:41,900 --> 00:24:46,910
entirely but close enough acquire

00:24:44,720 --> 00:24:51,590
barrier guarantees that all memory

00:24:46,910 --> 00:24:54,530
operations that were scheduled after the

00:24:51,590 --> 00:24:56,120
barrier become visible after the barrier

00:24:54,530 --> 00:24:58,010
so whatever was in the program order

00:24:56,120 --> 00:25:00,680
after the barrier becomes visible after

00:24:58,010 --> 00:25:02,840
the barrier usually there is no acquire

00:25:00,680 --> 00:25:03,559
barrier per se a Quarrier is a modifier

00:25:02,840 --> 00:25:05,450
on some other

00:25:03,559 --> 00:25:07,370
structions like a choir read well Sam

00:25:05,450 --> 00:25:13,190
CPUs have a just just a barrier

00:25:07,370 --> 00:25:15,259
instruction so if we have if this was

00:25:13,190 --> 00:25:16,820
the program order then the memory

00:25:15,259 --> 00:25:20,360
visability order could be something like

00:25:16,820 --> 00:25:23,960
this you can go down through the choir

00:25:20,360 --> 00:25:25,659
barrier just can't go up well if there

00:25:23,960 --> 00:25:28,960
is a choir there has to be a release

00:25:25,659 --> 00:25:32,690
release has the opposite guarantee

00:25:28,960 --> 00:25:36,499
anything that was done before has to be

00:25:32,690 --> 00:25:42,559
visible before the barrier you can go up

00:25:36,499 --> 00:25:46,159
you just can't go down okay this is what

00:25:42,559 --> 00:25:49,070
locks do locks combined a choir barrier

00:25:46,159 --> 00:25:51,139
at the beginning and release barrier at

00:25:49,070 --> 00:25:55,669
the end to form what's called critical

00:25:51,139 --> 00:25:57,889
section anything that is done within the

00:25:55,669 --> 00:26:01,309
critical section cannot escape up or

00:25:57,889 --> 00:26:03,259
down any reads or writes that are done

00:26:01,309 --> 00:26:05,749
outside of critical section can enter a

00:26:03,259 --> 00:26:07,460
critical section and be done there but

00:26:05,749 --> 00:26:13,899
anything within critical section has to

00:26:07,460 --> 00:26:17,539
stay with the in critical section so

00:26:13,899 --> 00:26:18,950
that's actually why the name is you

00:26:17,539 --> 00:26:20,360
acquire the lock when you enter a

00:26:18,950 --> 00:26:22,039
critical section and you release the

00:26:20,360 --> 00:26:23,119
lock when you leave the critical section

00:26:22,039 --> 00:26:28,639
that's why the barriers are called this

00:26:23,119 --> 00:26:29,960
way now very important when you use

00:26:28,639 --> 00:26:31,669
locks it doesn't matter when you start

00:26:29,960 --> 00:26:35,179
doing lock three people forget all the

00:26:31,669 --> 00:26:40,639
time this gets you every time those

00:26:35,179 --> 00:26:42,830
memory barriers only work if both CPUs

00:26:40,639 --> 00:26:46,070
cooperate it's not like a push across

00:26:42,830 --> 00:26:48,379
the entire system both CPUs have to take

00:26:46,070 --> 00:26:49,909
a barrier instruction between you and

00:26:48,379 --> 00:26:55,789
then you get a synchronization between

00:26:49,909 --> 00:26:58,970
those if one of the CPUs does the

00:26:55,789 --> 00:27:00,649
barrier and the other one doesn't the

00:26:58,970 --> 00:27:05,389
second CPU can see whatever it wants in

00:27:00,649 --> 00:27:06,879
any order no guarantees its cooperation

00:27:05,389 --> 00:27:09,559
affair

00:27:06,879 --> 00:27:11,960
okay well Michael will actually cover

00:27:09,559 --> 00:27:15,170
this material in a lot more detail so in

00:27:11,960 --> 00:27:19,550
the interest of time I'll skip that

00:27:15,170 --> 00:27:21,560
I just saw his slide so I'm kind of

00:27:19,550 --> 00:27:24,830
adjusting some of the things

00:27:21,560 --> 00:27:25,700
you know he'll cover it in a lot a lot

00:27:24,830 --> 00:27:28,430
more accurately

00:27:25,700 --> 00:27:34,940
okay let's before before the break which

00:27:28,430 --> 00:27:37,040
is coming up let us finish this so now

00:27:34,940 --> 00:27:39,380
this really works this is a double check

00:27:37,040 --> 00:27:41,870
pattern that really works there was a

00:27:39,380 --> 00:27:46,250
question about store whether the store

00:27:41,870 --> 00:27:49,070
guarantees the store well it has to be a

00:27:46,250 --> 00:27:50,660
release store now on some platforms

00:27:49,070 --> 00:27:55,880
every store released store and some it

00:27:50,660 --> 00:27:58,130
isn't but if for whatever reason by luck

00:27:55,880 --> 00:28:00,320
or by intent your store is a released

00:27:58,130 --> 00:28:01,610
store and of course the load has to be

00:28:00,320 --> 00:28:03,680
acquired load remember I said there has

00:28:01,610 --> 00:28:06,830
to be two memory barriers on both both

00:28:03,680 --> 00:28:09,470
CPUs have to play then yes this is

00:28:06,830 --> 00:28:11,810
guaranteed to be executed in the proper

00:28:09,470 --> 00:28:12,140
order and become visible in the proper

00:28:11,810 --> 00:28:16,970
order

00:28:12,140 --> 00:28:19,910
so what does it mean release store older

00:28:16,970 --> 00:28:21,320
all the rights that were done before

00:28:19,910 --> 00:28:25,280
released or have to become visible

00:28:21,320 --> 00:28:26,930
before before so before you can read

00:28:25,280 --> 00:28:29,600
that that value from whatever was

00:28:26,930 --> 00:28:31,550
released stored all the previous rights

00:28:29,600 --> 00:28:32,780
have to be visible to you and what are

00:28:31,550 --> 00:28:34,250
the previous right well that's the

00:28:32,780 --> 00:28:37,640
construction initialization of the

00:28:34,250 --> 00:28:39,890
object so all of those rights which were

00:28:37,640 --> 00:28:41,750
done before we stored the address of the

00:28:39,890 --> 00:28:45,250
object into the static pointer will

00:28:41,750 --> 00:28:48,080
become visible before you read from the

00:28:45,250 --> 00:28:50,450
static pointer if you read with acquire

00:28:48,080 --> 00:28:55,430
a load so this double check pattern

00:28:50,450 --> 00:28:57,260
actually works atomic instructions

00:28:55,430 --> 00:28:57,880
that's why sama constructions are the

00:28:57,260 --> 00:29:00,650
easy part

00:28:57,880 --> 00:29:02,510
90% of all log free programming is about

00:29:00,650 --> 00:29:05,290
memory barriers and in general the

00:29:02,510 --> 00:29:05,290
visibility order

00:29:13,910 --> 00:29:33,770
a lock creates critical section now okay

00:29:31,490 --> 00:29:36,350
look at the look at the second line in

00:29:33,770 --> 00:29:40,010
the code that lion is outside of the log

00:29:36,350 --> 00:29:42,170
which means it happens before let's say

00:29:40,010 --> 00:29:43,910
that instead of a choir load imagine

00:29:42,170 --> 00:29:47,570
that a set of a choir load I said simply

00:29:43,910 --> 00:29:49,730
load which is no barrier load now that

00:29:47,570 --> 00:29:52,400
lion happens before the log which means

00:29:49,730 --> 00:29:55,130
no memory barriers have occurred on the

00:29:52,400 --> 00:29:57,170
CPU that is running this code so now

00:29:55,130 --> 00:30:00,080
there are no guarantees on memory

00:29:57,170 --> 00:30:02,900
visibility I can get an on now pointer

00:30:00,080 --> 00:30:06,020
from that second line of the code and

00:30:02,900 --> 00:30:07,520
the rights that were initializing the

00:30:06,020 --> 00:30:18,440
object may not be committed for another

00:30:07,520 --> 00:30:20,030
hour exactly so I have two CPUs the

00:30:18,440 --> 00:30:21,680
first one was really the first so the

00:30:20,030 --> 00:30:23,990
first CPU went through and said okay is

00:30:21,680 --> 00:30:26,630
the value now yes it is now because it's

00:30:23,990 --> 00:30:28,310
it's further first view let's do the

00:30:26,630 --> 00:30:29,960
lock okay fine we did the lock we're the

00:30:28,310 --> 00:30:31,490
only one okay let's check if it's if

00:30:29,960 --> 00:30:33,860
it's still now yeah it's still now where

00:30:31,490 --> 00:30:36,980
the first CPU going through construct

00:30:33,860 --> 00:30:40,040
the object really a release store unlock

00:30:36,980 --> 00:30:42,200
the second CPU is going through again

00:30:40,040 --> 00:30:44,330
imagine that instead of a choir load I

00:30:42,200 --> 00:30:47,900
say just plain load no barrier load

00:30:44,330 --> 00:30:50,570
reads the now yet soon on now

00:30:47,900 --> 00:30:55,040
I mean reason oh sorry that reads the

00:30:50,570 --> 00:30:56,990
static pointer gets not an owl okay do I

00:30:55,040 --> 00:31:00,080
have any guarantees on the memory of the

00:30:56,990 --> 00:31:01,550
gizmo object itself no I don't those

00:31:00,080 --> 00:31:03,290
rights are sitting still in the cache

00:31:01,550 --> 00:31:05,690
haven't propagated through main memory

00:31:03,290 --> 00:31:07,010
haven't propagated back up won't be

00:31:05,690 --> 00:31:10,010
propagated through main memory for the

00:31:07,010 --> 00:31:13,910
next hour in reality doesn't leave that

00:31:10,010 --> 00:31:15,380
long but standard you know that there is

00:31:13,910 --> 00:31:17,000
no current if you're not using barriers

00:31:15,380 --> 00:31:21,200
there is no guarantee I mean on some

00:31:17,000 --> 00:31:23,390
hardware it could be an hour so those

00:31:21,200 --> 00:31:25,850
rights haven't propagated through the

00:31:23,390 --> 00:31:27,220
system to main memory so if you didn't

00:31:25,850 --> 00:31:28,659
take the barrier you

00:31:27,220 --> 00:31:30,220
we'll never go into the lock which means

00:31:28,659 --> 00:31:31,960
you will never get any barriers at all

00:31:30,220 --> 00:31:36,640
which means there is no reason for your

00:31:31,960 --> 00:31:38,650
main memory to be updated ever remember

00:31:36,640 --> 00:31:41,080
if you don't take barriers memory

00:31:38,650 --> 00:31:42,490
updates are basically at the mercy of

00:31:41,080 --> 00:31:46,870
the hardware hardware may update them

00:31:42,490 --> 00:31:48,730
now or next day whatever so if you don't

00:31:46,870 --> 00:31:50,200
have that first acquire barrier you may

00:31:48,730 --> 00:31:54,010
run through this entire code and never

00:31:50,200 --> 00:32:01,480
hit a single memory barrier is that

00:31:54,010 --> 00:32:05,860
clear no second CPU sees that it's not

00:32:01,480 --> 00:32:07,720
now second CPU can see anything if it

00:32:05,860 --> 00:32:10,750
sees that it's now then it will try to

00:32:07,720 --> 00:32:13,030
initialize it again let's let's assume

00:32:10,750 --> 00:32:16,240
that it sees that it's not now you know

00:32:13,030 --> 00:32:18,330
any any subset of the rights can be made

00:32:16,240 --> 00:32:21,220
visible and the other subset non visible

00:32:18,330 --> 00:32:22,990
let's consider the example where the

00:32:21,220 --> 00:32:24,640
static pointer was made visible and

00:32:22,990 --> 00:32:30,240
nothing else was made visible

00:32:24,640 --> 00:32:33,669
now the second CPU see is not now and

00:32:30,240 --> 00:32:35,320
reads uninitialized memory from from the

00:32:33,669 --> 00:32:38,159
object itself because no other rights

00:32:35,320 --> 00:32:38,159
have been made visible

00:32:50,350 --> 00:32:57,890
okay let's well I think we actually have

00:32:54,950 --> 00:33:00,820
a what 30 minute break a break between

00:32:57,890 --> 00:33:05,750
the two talks if I'm not mistaken right

00:33:00,820 --> 00:33:07,850
sorry okay so okay so let me just go

00:33:05,750 --> 00:33:09,919
through all the way to the end and I'll

00:33:07,850 --> 00:33:14,059
take questions between and for the for

00:33:09,919 --> 00:33:15,440
the second half okay so as you saw and

00:33:14,059 --> 00:33:17,750
we had just had a confirmation lock-free

00:33:15,440 --> 00:33:19,190
program is mostly about memory order

00:33:17,750 --> 00:33:21,230
Atomics instructions were the easy part

00:33:19,190 --> 00:33:23,360
yeah I taught me to read atomic right

00:33:21,230 --> 00:33:24,740
every shared variable that you read and

00:33:23,360 --> 00:33:27,980
write was out the lock has to be atomic

00:33:24,740 --> 00:33:30,409
that's easy they have you have to take

00:33:27,980 --> 00:33:32,270
the correct memory barriers and order

00:33:30,409 --> 00:33:34,070
your code correctly between those memory

00:33:32,270 --> 00:33:37,340
barriers to make sure that what you

00:33:34,070 --> 00:33:46,490
think is done and should be visible is

00:33:37,340 --> 00:33:50,120
really visible now this law this whole

00:33:46,490 --> 00:33:54,230
thing went away with C++ 11 if you have

00:33:50,120 --> 00:33:58,179
C++ 11 and you want static singleton you

00:33:54,230 --> 00:34:00,500
do this and this according to standard

00:33:58,179 --> 00:34:02,510
is thread safe and is guaranteed to work

00:34:00,500 --> 00:34:05,419
what the compiler do is very much what I

00:34:02,510 --> 00:34:08,320
just shown you you can look at the

00:34:05,419 --> 00:34:12,109
assembly that's something very similar

00:34:08,320 --> 00:34:15,399
now the reason I'm still talking about

00:34:12,109 --> 00:34:19,010
it one it's relatively easy to explain

00:34:15,399 --> 00:34:22,179
it's not very easy but it's probably the

00:34:19,010 --> 00:34:25,070
easiest vehicle I have for explaining

00:34:22,179 --> 00:34:31,399
the memory dependency issues but more

00:34:25,070 --> 00:34:33,139
importantly while in like pretty much

00:34:31,399 --> 00:34:34,970
every talk on double check locking

00:34:33,139 --> 00:34:36,530
pattern uses that singleton Association

00:34:34,970 --> 00:34:38,990
that's not the general pattern that it's

00:34:36,530 --> 00:34:42,490
solving think for a moment what's the

00:34:38,990 --> 00:34:46,780
real problem that we are solving we have

00:34:42,490 --> 00:34:49,780
normal case which always happens and

00:34:46,780 --> 00:34:52,810
exceptional case which rarely happens

00:34:49,780 --> 00:34:56,010
when exception case actually happens

00:34:52,810 --> 00:34:58,200
it's difficult to handle

00:34:56,010 --> 00:35:00,090
there is a lot of data to be messed with

00:34:58,200 --> 00:35:02,340
so in general you want to have a lock

00:35:00,090 --> 00:35:04,620
protecting it it's not thread safe it's

00:35:02,340 --> 00:35:07,890
hard to make thread safe but you don't

00:35:04,620 --> 00:35:10,560
want to take that lock every time the

00:35:07,890 --> 00:35:12,810
problem is in order to test you have to

00:35:10,560 --> 00:35:15,600
test for the expecially and handle

00:35:12,810 --> 00:35:18,840
special case in an atomic transaction as

00:35:15,600 --> 00:35:22,230
a single non interruptible operation

00:35:18,840 --> 00:35:24,390
which means the only way to do it was a

00:35:22,230 --> 00:35:27,180
lock is to put a lock around both the

00:35:24,390 --> 00:35:30,390
test and the handler of this special

00:35:27,180 --> 00:35:32,520
case 99.9 percent of the time the

00:35:30,390 --> 00:35:34,140
handler doesn't need to run in case of

00:35:32,520 --> 00:35:37,500
singleton like almost never the handle

00:35:34,140 --> 00:35:39,780
doesn't need to run but the test is

00:35:37,500 --> 00:35:40,980
still guarded by the lock that's what

00:35:39,780 --> 00:35:43,560
we're trying to solve that's what we're

00:35:40,980 --> 00:35:45,300
trying to avoid now when can we use

00:35:43,560 --> 00:35:47,390
double check locking pattern let's

00:35:45,300 --> 00:35:50,730
assume that we have a very fast

00:35:47,390 --> 00:35:52,170
non-locking test for whether we are in

00:35:50,730 --> 00:35:54,060
trouble whether we need the exceptional

00:35:52,170 --> 00:35:57,950
handling and I don't mean C++ exceptions

00:35:54,060 --> 00:36:00,930
I mean just something that is not usual

00:35:57,950 --> 00:36:02,190
if there is no false success if the test

00:36:00,930 --> 00:36:04,890
says we're good we're good

00:36:02,190 --> 00:36:06,660
if the test says no we may be in an

00:36:04,890 --> 00:36:09,210
exceptional situation we may or may not

00:36:06,660 --> 00:36:10,440
be in an exceptional situation this is

00:36:09,210 --> 00:36:12,390
the case was that singled and if the

00:36:10,440 --> 00:36:14,100
pointer is not now assuming you have

00:36:12,390 --> 00:36:17,190
written it correctly if the pointer is

00:36:14,100 --> 00:36:19,530
not now go ahead and use the object if

00:36:17,190 --> 00:36:22,110
the pointer is now maybe the object

00:36:19,530 --> 00:36:23,760
needs to be created maybe it isn't maybe

00:36:22,110 --> 00:36:27,000
somebody's creating it right now in

00:36:23,760 --> 00:36:30,330
which case which you shouldn't be so

00:36:27,000 --> 00:36:32,700
this is the double check locking a

00:36:30,330 --> 00:36:36,390
pattern this is the case where it's used

00:36:32,700 --> 00:36:39,120
in general when you want to test for a

00:36:36,390 --> 00:36:42,030
special case very quickly a lot of times

00:36:39,120 --> 00:36:43,680
without a lock and if the for if the

00:36:42,030 --> 00:36:45,870
test for special case shows you that you

00:36:43,680 --> 00:36:47,370
may be in an exceptional situation then

00:36:45,870 --> 00:36:50,730
you take the lock and really figure out

00:36:47,370 --> 00:36:52,080
where you are in case of singleton once

00:36:50,730 --> 00:36:54,480
the test succeeded it always stays

00:36:52,080 --> 00:36:56,700
succeeded succeeded in general case that

00:36:54,480 --> 00:36:57,810
doesn't have to be true double check

00:36:56,700 --> 00:36:59,640
locking pattern actually doesn't depend

00:36:57,810 --> 00:37:02,250
on it you could go into it like

00:36:59,640 --> 00:37:03,510
basically if you handled your problem

00:37:02,250 --> 00:37:06,890
you may have to handle it again later

00:37:03,510 --> 00:37:06,890
just not very soon

00:37:07,410 --> 00:37:14,260
okay you will see why this is actually

00:37:10,900 --> 00:37:15,550
very useful in practice so this is this

00:37:14,260 --> 00:37:17,290
is kind of the pseudocode for the

00:37:15,550 --> 00:37:22,450
general double-check loading code

00:37:17,290 --> 00:37:25,330
pattern if the fast test fails we have

00:37:22,450 --> 00:37:26,650
to log we have to do the exact test we

00:37:25,330 --> 00:37:29,230
have to handle the problem and we have

00:37:26,650 --> 00:37:31,320
to unlock now there is another

00:37:29,230 --> 00:37:35,140
assumption here the assumption is that

00:37:31,320 --> 00:37:38,290
basically if the problem happens after

00:37:35,140 --> 00:37:40,120
the fact if one thread goes through does

00:37:38,290 --> 00:37:42,820
the fast test and the fastest succeeded

00:37:40,120 --> 00:37:45,100
you can actually keep using whatever you

00:37:42,820 --> 00:37:46,980
were you know whatever like your object

00:37:45,100 --> 00:37:49,360
or whatever it is you are trying to use

00:37:46,980 --> 00:37:51,430
even if the problem later happens so

00:37:49,360 --> 00:37:54,250
classic example is memory allocation if

00:37:51,430 --> 00:37:56,860
you you're testing for whether I have

00:37:54,250 --> 00:37:58,930
all my memory allocated if you do that

00:37:56,860 --> 00:38:00,430
memory is not going away even you

00:37:58,930 --> 00:38:02,410
already got it if the memory allocation

00:38:00,430 --> 00:38:04,480
fails you run out of memory whatever you

00:38:02,410 --> 00:38:06,430
are located is still there you may not

00:38:04,480 --> 00:38:13,750
be able to allocate new one you have to

00:38:06,430 --> 00:38:17,530
handle it so but the idea is basically

00:38:13,750 --> 00:38:19,210
if the fastest fast then you're good you

00:38:17,530 --> 00:38:23,460
know nothing that happens afterward can

00:38:19,210 --> 00:38:25,930
can break your well-defined behavior

00:38:23,460 --> 00:38:28,210
this will come very useful later during

00:38:25,930 --> 00:38:30,040
the second half okay good time to take a

00:38:28,210 --> 00:38:32,440
break if you have any questions come see

00:38:30,040 --> 00:38:35,470
me otherwise we'll resume for the second

00:38:32,440 --> 00:38:40,660
half where we change gears and look at

00:38:35,470 --> 00:38:43,050
some real log free programs start with

00:38:40,660 --> 00:38:43,050

YouTube URL: https://www.youtube.com/watch?v=lVBvHbJsg5Y


