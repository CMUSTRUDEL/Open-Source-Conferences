Title: CppCon 2015: Milian Wolff "Modern User Interfaces for C++”
Publication date: 2015-10-11
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
The C++ language evolved significantly in the recent past, and so did many frameworks and libraries in the big ecosystem surrounding it. 

For twenty years now, Qt is being used on a multitude of platforms to create native looking, compelling graphical user interfaces.

It offers C++ libraries and tools for building desktop, mobile and embedded applications. Qt gives engineers APIs for developing using two dimensional controls, integrating 3D using OpenGL, embedding web content, as well as a new declarative domain-specific language called QML, which is extensible using C++. Qt is also much more than a UI toolkit and provides a multitude of helper libraries for various use-cases, such as localization, database access, XML and JSON parsing and much more. 

During this talk, I will give an introduction to Qt and present its capabilities in how it can be utilized to write modern UIs using C++, both in 2D as well as 3D. Additionally, I will show how some of its features, like the integrated web engine or QML, can be leveraged to go beyond C++. While at it, I hope to clear up some outdated misconceptions about Qt and its relationship to standard C++ and the STL as well as Boost and other libraries.

Finally, I will present the KDE Frameworks, an open source collection of high quality, cross platform Qt libraries that are being used by the KDE Software Collection. KDE frameworks are to Qt as Boost is to the STL. Recent development makes it simpler than ever to use these libraries in external applications.
— 
Milian Wolff works as a Software Engineer at KDAB, an expert Qt, C++ and OpenGL consultancy. He contributes to Qt and KDE for several years now. Besides that, improving tooling around C++ development is of huge interest to him: As the co-maintainer of the KDevelop IDE, he is currently integrating Clang there
to replace the handwritten C++ parser and semantic analyzer. Performance of C++ code is very important to him,
and he wrote tools such as Massif-Visualizer and heaptrack to guide developers in finding issues in their code bases.
He holds a Master of Science in physics and is enthusiastic about Free Open Source Software in general and Linux and KDE in particular.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,589
okay great thanks welcome everyone I'm

00:00:02,070 --> 00:00:06,060
good to see you all it's a huge pleasure

00:00:04,589 --> 00:00:09,269
for me to be here

00:00:06,060 --> 00:00:12,540
I'm million I work for k-dub that's our

00:00:09,269 --> 00:00:14,849
logo we are not the cute company we are

00:00:12,540 --> 00:00:19,020
the second biggest so to say in the cute

00:00:14,849 --> 00:00:21,960
ecosystem I myself am a cute approver I

00:00:19,020 --> 00:00:24,779
work with cute now for I think seven

00:00:21,960 --> 00:00:27,869
years or so I even maintain a small

00:00:24,779 --> 00:00:30,029
module inside cute so um I would say I

00:00:27,869 --> 00:00:35,700
have a fair share of knowledge in that

00:00:30,029 --> 00:00:38,250
area and I followed CPP Khan and going

00:00:35,700 --> 00:00:40,550
native before that the last years from a

00:00:38,250 --> 00:00:44,190
home and building some of that even

00:00:40,550 --> 00:00:47,010
streamed life into our offices was quite

00:00:44,190 --> 00:00:49,079
nice but I always wondered like why is

00:00:47,010 --> 00:00:51,090
cute so Ana represented there there

00:00:49,079 --> 00:00:54,030
hasn't been a single talk about that at

00:00:51,090 --> 00:00:55,649
these conferences to my knowledge and I

00:00:54,030 --> 00:00:59,940
mean just a quick show of hands who have

00:00:55,649 --> 00:01:02,129
used using cute quite a lot I thought so

00:00:59,940 --> 00:01:03,809
I mean cute is being used by thousands

00:01:02,129 --> 00:01:08,280
of developers out there and it's a very

00:01:03,809 --> 00:01:11,909
very big part of the C++ ecosystem in my

00:01:08,280 --> 00:01:14,040
opinion and this talk here is going to

00:01:11,909 --> 00:01:15,689
be different from the talks I do usually

00:01:14,040 --> 00:01:17,580
it's not going to be very deeply

00:01:15,689 --> 00:01:20,130
technical rather it's going to be an

00:01:17,580 --> 00:01:22,439
overview of what you can do with cute

00:01:20,130 --> 00:01:29,400
why cute is in my opinion really amazing

00:01:22,439 --> 00:01:31,939
and fills the gap in C++ so I'll give

00:01:29,400 --> 00:01:35,909
you a short introduction of what cute is

00:01:31,939 --> 00:01:37,350
and that's probably only going to be

00:01:35,909 --> 00:01:41,640
interesting for those of you who are not

00:01:37,350 --> 00:01:43,770
using it already then I'll show examples

00:01:41,640 --> 00:01:46,890
of how you can create user interfaces

00:01:43,770 --> 00:01:49,409
with cute you can use widgets or you can

00:01:46,890 --> 00:01:54,409
use the new qml based cue quick API to

00:01:49,409 --> 00:01:57,479
do that and finally I want to dive into

00:01:54,409 --> 00:02:01,619
the essentials and add-ons because cute

00:01:57,479 --> 00:02:04,860
is a huge framework itself and there is

00:02:01,619 --> 00:02:07,740
a huge ecosystem around it as well

00:02:04,860 --> 00:02:11,790
extending it further adding new features

00:02:07,740 --> 00:02:13,390
and filling gaps and then last but not

00:02:11,790 --> 00:02:15,190
least I want to

00:02:13,390 --> 00:02:18,069
talk about a few misconceptions that I

00:02:15,190 --> 00:02:20,200
see again and again from very

00:02:18,069 --> 00:02:21,640
knowledgeable C++ people who are

00:02:20,200 --> 00:02:26,650
apparently not very knowledgeable about

00:02:21,640 --> 00:02:31,510
cute so yeah this is going to be what

00:02:26,650 --> 00:02:34,360
I'll be talking about cute um cute is

00:02:31,510 --> 00:02:36,550
been around for a long time it's more

00:02:34,360 --> 00:02:41,650
than 20 years of innovating what you can

00:02:36,550 --> 00:02:43,300
do with C++ many things it does by using

00:02:41,650 --> 00:02:46,150
for example code generators we'll get to

00:02:43,300 --> 00:02:49,500
that later it does stuff that you cannot

00:02:46,150 --> 00:02:52,660
do with normal C++ in many areas

00:02:49,500 --> 00:02:54,940
thousands if not dozens of thousands of

00:02:52,660 --> 00:02:58,090
people use a day-in day-out for their

00:02:54,940 --> 00:03:01,060
job we do that we see our customers

00:02:58,090 --> 00:03:05,550
doing that as a consultancy company we

00:03:01,060 --> 00:03:07,959
get called in and see the wealth of

00:03:05,550 --> 00:03:10,989
projects that use cute it's very

00:03:07,959 --> 00:03:14,500
astonishing in my opinion to see how

00:03:10,989 --> 00:03:17,530
well it works most of the time but sadly

00:03:14,500 --> 00:03:21,100
it's very underrepresented at many C++

00:03:17,530 --> 00:03:23,829
conferences cute is cross-platform

00:03:21,100 --> 00:03:27,100
whatever I'll show you here you can do

00:03:23,829 --> 00:03:29,890
in all kinds of platforms you can run it

00:03:27,100 --> 00:03:32,459
on the different flavors of Windows even

00:03:29,890 --> 00:03:37,000
compact about it if you like to do that

00:03:32,459 --> 00:03:39,000
you can run it on the Macs various Linux

00:03:37,000 --> 00:03:41,970
flavors especially interesting for

00:03:39,000 --> 00:03:44,980
embedded platforms in my opinion

00:03:41,970 --> 00:03:49,780
real-time operating systems I mean those

00:03:44,980 --> 00:03:54,000
of you who flew here with some come with

00:03:49,780 --> 00:03:56,829
a new machine it quite possibly the

00:03:54,000 --> 00:04:00,760
infotainment system is using cute

00:03:56,829 --> 00:04:02,860
already or it's cars that are getting

00:04:00,760 --> 00:04:05,049
developed and they will get new

00:04:02,860 --> 00:04:11,170
infotainment systems based on QNX

00:04:05,049 --> 00:04:14,500
or something else using heute and on the

00:04:11,170 --> 00:04:16,419
desktop platforms and phone platforms

00:04:14,500 --> 00:04:17,950
you get a native look and feel it's not

00:04:16,419 --> 00:04:20,799
pixel perfect but it's getting really

00:04:17,950 --> 00:04:24,550
close and fulfills its role very very

00:04:20,799 --> 00:04:26,620
well and the thing here is that queued

00:04:24,550 --> 00:04:28,660
has at its core at

00:04:26,620 --> 00:04:30,340
platform abstraction layer that scales

00:04:28,660 --> 00:04:32,650
really well otherwise this wouldn't have

00:04:30,340 --> 00:04:34,870
been possible and we see more more

00:04:32,650 --> 00:04:36,870
platforms being added and it works

00:04:34,870 --> 00:04:41,199
that's very nice

00:04:36,870 --> 00:04:43,800
so personally this is very biased why do

00:04:41,199 --> 00:04:46,780
I like cute why do I stand here

00:04:43,800 --> 00:04:49,300
motivated to talk to you about this I'm

00:04:46,780 --> 00:04:52,660
kind of passionate about it but first

00:04:49,300 --> 00:04:55,900
and foremost I like you because it's C++

00:04:52,660 --> 00:04:57,970
everyone who keeps saying cuties in C++

00:04:55,900 --> 00:05:01,150
I quite frankly can't get it because

00:04:57,970 --> 00:05:05,500
it's very much C++ it's dozens of lines

00:05:01,150 --> 00:05:07,630
of it and it really helps in writing

00:05:05,500 --> 00:05:11,410
efficient code if it wouldn't be C++ I

00:05:07,630 --> 00:05:14,889
would probably not use it then the thing

00:05:11,410 --> 00:05:17,650
that we at Kade up here especially when

00:05:14,889 --> 00:05:20,260
we do trainings and see new people

00:05:17,650 --> 00:05:22,419
learning cute while we teach it to them

00:05:20,260 --> 00:05:24,970
is that they say again and again the

00:05:22,419 --> 00:05:28,180
cute is very simple the API is

00:05:24,970 --> 00:05:31,660
consistent it's very straightforward to

00:05:28,180 --> 00:05:33,610
get into it there is no high entry

00:05:31,660 --> 00:05:35,950
barrier or anything like that and this

00:05:33,610 --> 00:05:40,750
is in my opinion very important for

00:05:35,950 --> 00:05:42,789
library to be used by many people then

00:05:40,750 --> 00:05:46,990
there is the open governance model which

00:05:42,789 --> 00:05:49,510
I as a open-source guy am very

00:05:46,990 --> 00:05:52,650
passionate about as well in my free time

00:05:49,510 --> 00:05:55,660
I work a lot on the KDE project and if

00:05:52,650 --> 00:05:58,150
cute wouldn't be open-source wouldn't

00:05:55,660 --> 00:06:00,940
allow open-source projects to use it

00:05:58,150 --> 00:06:03,400
such as cute Kady I wouldn't have

00:06:00,940 --> 00:06:05,560
learned it in the first place this was

00:06:03,400 --> 00:06:07,750
what drove me to using it and seeing

00:06:05,560 --> 00:06:12,160
okay this is actually very very cool

00:06:07,750 --> 00:06:14,080
tool set and the open governance model

00:06:12,160 --> 00:06:16,630
does not only mean it's open source but

00:06:14,080 --> 00:06:19,539
also that everyone has a voice I can go

00:06:16,630 --> 00:06:22,419
in make a change I can discuss with the

00:06:19,539 --> 00:06:23,530
maintainer of cute core why something

00:06:22,419 --> 00:06:25,900
should be done one way or another

00:06:23,530 --> 00:06:27,370
there's no one company that says okay

00:06:25,900 --> 00:06:29,080
this is how we are going to do it and

00:06:27,370 --> 00:06:31,720
they do it it's very important in my

00:06:29,080 --> 00:06:33,520
opinion and as I said already cute is

00:06:31,720 --> 00:06:35,620
highly versatile you can use it on the

00:06:33,520 --> 00:06:39,889
desktop you can use it for embedded

00:06:35,620 --> 00:06:43,400
platforms phones whatever and

00:06:39,889 --> 00:06:46,340
the people in the cute ecosystem or

00:06:43,400 --> 00:06:48,629
community are very practical and

00:06:46,340 --> 00:06:51,210
personally I like that I studied physics

00:06:48,629 --> 00:06:52,740
it was very theoretical in the end I

00:06:51,210 --> 00:06:55,409
decided that this isn't really not

00:06:52,740 --> 00:06:58,009
something for me I rather work on

00:06:55,409 --> 00:07:00,659
something as practical in a sense of I

00:06:58,009 --> 00:07:03,659
want to get stuff done instead of

00:07:00,659 --> 00:07:06,210
arguing about the theoretical best way

00:07:03,659 --> 00:07:09,530
it could possibly be done but then no

00:07:06,210 --> 00:07:13,319
one was ever going to do it right so

00:07:09,530 --> 00:07:16,710
this is something I really like there

00:07:13,319 --> 00:07:19,500
are lots of things I do not like about

00:07:16,710 --> 00:07:21,479
cute it's it's a big project I mean it's

00:07:19,500 --> 00:07:25,740
very unlikely that it's perfect in every

00:07:21,479 --> 00:07:29,099
aspect definitely not the three points I

00:07:25,740 --> 00:07:32,520
want to highlight here is first and

00:07:29,099 --> 00:07:35,699
foremost the coat like legacy then cute

00:07:32,520 --> 00:07:40,050
I mean it's 20 years old right there are

00:07:35,699 --> 00:07:42,750
places in the cute API where this really

00:07:40,050 --> 00:07:45,210
really shows the biggest example here is

00:07:42,750 --> 00:07:47,430
exceptions cute does not use exceptions

00:07:45,210 --> 00:07:49,289
itself you can use as a user of cute

00:07:47,430 --> 00:07:51,690
your exceptions that's fine and we'll

00:07:49,289 --> 00:07:54,690
handle that but internally it decided

00:07:51,690 --> 00:07:57,240
not to use exceptions because of the

00:07:54,690 --> 00:07:59,310
fact that back then I don't know 15

00:07:57,240 --> 00:08:01,379
years ago seventeen years ago they

00:07:59,310 --> 00:08:03,659
decided to support platforms where the

00:08:01,379 --> 00:08:07,020
compiler was not able to handle

00:08:03,659 --> 00:08:09,900
exceptions so they limited themselves by

00:08:07,020 --> 00:08:13,110
saying okay we want to support this

00:08:09,900 --> 00:08:15,839
platform and now 20 years later we still

00:08:13,110 --> 00:08:19,339
pay the price in that aspect and there

00:08:15,839 --> 00:08:22,259
are other cases where this is happening

00:08:19,339 --> 00:08:24,960
there are a few performance traps in the

00:08:22,259 --> 00:08:26,789
cute API I said it's very simple to use

00:08:24,960 --> 00:08:29,400
it that's true especially if you look at

00:08:26,789 --> 00:08:31,770
the containers I'll get to the

00:08:29,400 --> 00:08:34,740
containers later but they have lots of

00:08:31,770 --> 00:08:36,209
utility functions and you use them and

00:08:34,740 --> 00:08:38,550
you think like oh yeah my code is so

00:08:36,209 --> 00:08:41,519
nice it looks so awesome but actually

00:08:38,550 --> 00:08:44,310
it's going to be very badly performing

00:08:41,519 --> 00:08:46,170
compared to STL code where you are

00:08:44,310 --> 00:08:50,520
explicit when you shoot yourself in the

00:08:46,170 --> 00:08:52,870
foot and then the biggest issue I see

00:08:50,520 --> 00:08:56,130
right now in the cute

00:08:52,870 --> 00:08:58,330
immunity is that there is simply no

00:08:56,130 --> 00:09:01,180
interaction or very little interaction

00:08:58,330 --> 00:09:03,640
with the ongoing efforts of advancing

00:09:01,180 --> 00:09:07,450
C++ as a language so no one is actually

00:09:03,640 --> 00:09:10,240
being funded to go to the ISO CPP

00:09:07,450 --> 00:09:13,810
meetings and helping that out and I

00:09:10,240 --> 00:09:16,870
really do hope that the companies are

00:09:13,810 --> 00:09:19,000
going to send people there and improving

00:09:16,870 --> 00:09:22,000
that situation and also on the other

00:09:19,000 --> 00:09:24,820
hand do hope that people from the ISOs

00:09:22,000 --> 00:09:27,400
EPP community look at what we have in

00:09:24,820 --> 00:09:30,339
cute instead of reinventing the wheel in

00:09:27,400 --> 00:09:33,310
some aspects or at least to see what is

00:09:30,339 --> 00:09:37,870
needed by a real-world project to solve

00:09:33,310 --> 00:09:40,240
problems so while dislike these things I

00:09:37,870 --> 00:09:42,580
can actually understand and accept them

00:09:40,240 --> 00:09:45,370
their fact and I hope they will get

00:09:42,580 --> 00:09:48,360
resolved eventually but it's not as bad

00:09:45,370 --> 00:09:51,070
for me personally as you might think

00:09:48,360 --> 00:09:54,279
so with that short introduction done

00:09:51,070 --> 00:09:57,660
let's talk about widgets this talk is

00:09:54,279 --> 00:10:00,610
going to be at this part the next two

00:09:57,660 --> 00:10:03,640
sections is going to show you nice

00:10:00,610 --> 00:10:09,190
images mostly of what you can do with

00:10:03,640 --> 00:10:12,760
C++ a cute C++ the first part the

00:10:09,190 --> 00:10:14,980
widgets is what has been around for here

00:10:12,760 --> 00:10:18,820
20 years now it's very old technology

00:10:14,980 --> 00:10:22,390
that kept evolving over the years but

00:10:18,820 --> 00:10:32,290
it's definitely not dead this picture

00:10:22,390 --> 00:10:35,620
here is K mail my personal sorry for

00:10:32,290 --> 00:10:37,900
that that's my personal email client of

00:10:35,620 --> 00:10:40,089
choice and I picked it not because it's

00:10:37,900 --> 00:10:42,370
such an awesome email client which is

00:10:40,089 --> 00:10:44,170
this in my opinion but rather because

00:10:42,370 --> 00:10:47,770
it's very exemplar Tory for widget

00:10:44,170 --> 00:10:50,140
applications these kind of you is you

00:10:47,770 --> 00:10:52,650
still see and you will still see in 10

00:10:50,140 --> 00:10:56,550
years I'm pretty sure in house

00:10:52,650 --> 00:11:00,940
applications for example in financial

00:10:56,550 --> 00:11:03,760
companies or for logistics or anything

00:11:00,940 --> 00:11:06,250
very specific to a problem you need to

00:11:03,760 --> 00:11:09,100
solve where you show lots of data like

00:11:06,250 --> 00:11:11,290
here I mean you have tons of views you

00:11:09,100 --> 00:11:12,850
feed with models you have trees you can

00:11:11,290 --> 00:11:15,520
filter them you can search them it's

00:11:12,850 --> 00:11:18,370
always lots and lots of data and cute

00:11:15,520 --> 00:11:23,140
widget is perfect for that kind of

00:11:18,370 --> 00:11:26,080
application what you also see is text

00:11:23,140 --> 00:11:30,510
handling in curious very good and it's

00:11:26,080 --> 00:11:32,650
very good at adapting to the locale and

00:11:30,510 --> 00:11:35,680
internationalization of whatever the

00:11:32,650 --> 00:11:39,520
users doing for example if you would get

00:11:35,680 --> 00:11:42,580
a email from an person who can write

00:11:39,520 --> 00:11:44,790
Arabian then right-to-left text is just

00:11:42,580 --> 00:11:47,050
there you don't need to handle anything

00:11:44,790 --> 00:11:49,780
especially there in your application I

00:11:47,050 --> 00:11:53,860
really like that or you could even

00:11:49,780 --> 00:11:58,360
display HTML content if you have to or

00:11:53,860 --> 00:12:00,550
want to even but widget applications can

00:11:58,360 --> 00:12:02,920
also look very different this is an

00:12:00,550 --> 00:12:05,020
example I quite like because it's the

00:12:02,920 --> 00:12:07,270
Spotify Linux client which is still cute

00:12:05,020 --> 00:12:09,490
for bass but it looks super different

00:12:07,270 --> 00:12:11,410
right it's still a cute widget if your

00:12:09,490 --> 00:12:13,270
application as fast enough I couldn't

00:12:11,410 --> 00:12:15,550
look into the source but if you just run

00:12:13,270 --> 00:12:19,990
ldd on it you'll see what it links to

00:12:15,550 --> 00:12:23,050
and again what we see are lists that you

00:12:19,990 --> 00:12:26,020
can filter this probably again is fed by

00:12:23,050 --> 00:12:29,230
a model and then you have a special view

00:12:26,020 --> 00:12:32,080
on top of that and they just changed the

00:12:29,230 --> 00:12:34,210
visuals and that shows how even cute

00:12:32,080 --> 00:12:40,720
widgets can adapt to whatever you want

00:12:34,210 --> 00:12:43,570
to display right then the last picture I

00:12:40,720 --> 00:12:48,220
want to show is again project out of the

00:12:43,570 --> 00:12:50,920
KDE community its critter the yeah I

00:12:48,220 --> 00:12:53,410
don't know whether they actually started

00:12:50,920 --> 00:12:56,830
right out by saying we want to kill

00:12:53,410 --> 00:12:58,810
Photoshop they then decided to okay

00:12:56,830 --> 00:13:00,430
that's not going to work Photoshop can

00:12:58,810 --> 00:13:03,240
do lots and lots of things we cannot

00:13:00,430 --> 00:13:05,860
compete with that so instead let's

00:13:03,240 --> 00:13:10,930
concentrate on a very specific part on

00:13:05,860 --> 00:13:14,440
the visual artist that draws so a

00:13:10,930 --> 00:13:16,870
painting application it's not the in

00:13:14,440 --> 00:13:19,600
German we say il a avoid me so that the

00:13:16,870 --> 00:13:21,579
thing that can do everything from

00:13:19,600 --> 00:13:23,940
generating HTML for your website to

00:13:21,579 --> 00:13:27,910
whatever else Photoshop can do nowadays

00:13:23,940 --> 00:13:30,100
but rather it's meant for painters and

00:13:27,910 --> 00:13:32,310
it's very very good at that and more and

00:13:30,100 --> 00:13:35,079
more people are starting to adapt

00:13:32,310 --> 00:13:37,269
adapted in their professional companies

00:13:35,079 --> 00:13:39,459
even and the thing is it's again acute

00:13:37,269 --> 00:13:42,370
widget application there is the Open GL

00:13:39,459 --> 00:13:44,860
accelerated canvas here making it very

00:13:42,370 --> 00:13:48,149
efficient it's very nicely integrating

00:13:44,860 --> 00:13:51,009
with the graphics tablets you have

00:13:48,149 --> 00:13:52,990
custom widgets here for selecting

00:13:51,009 --> 00:13:55,569
brushes and things like that and all of

00:13:52,990 --> 00:14:00,819
that is quite straightforward to do with

00:13:55,569 --> 00:14:04,509
cute so how do you actually use it I

00:14:00,819 --> 00:14:06,730
mean the best way to do it in my opinion

00:14:04,509 --> 00:14:09,940
is you use or you start off by using the

00:14:06,730 --> 00:14:13,199
designer tool cuties on here it's shown

00:14:09,940 --> 00:14:16,060
embedded in cute creator the cute sdk

00:14:13,199 --> 00:14:18,759
let me put that straight cute creator

00:14:16,060 --> 00:14:20,529
it's cool if you want to use it use it

00:14:18,759 --> 00:14:23,399
but you don't have to use it if you use

00:14:20,529 --> 00:14:28,600
cute personally in my spare time I

00:14:23,399 --> 00:14:31,029
maintain the K develop API ID so I don't

00:14:28,600 --> 00:14:33,009
use cute creator at all and I know many

00:14:31,029 --> 00:14:35,319
people use Visual Studio that's fine or

00:14:33,009 --> 00:14:37,810
Eclipse again that's fine you don't

00:14:35,319 --> 00:14:39,850
bound to that right and with the

00:14:37,810 --> 00:14:41,410
designer which you can also run a

00:14:39,850 --> 00:14:44,319
sustained alone application you just

00:14:41,410 --> 00:14:46,750
click together how your dialog is

00:14:44,319 --> 00:14:49,240
supposed to look like and not only does

00:14:46,750 --> 00:14:51,519
that work really well compared to what I

00:14:49,240 --> 00:14:54,100
heard from other people using different

00:14:51,519 --> 00:14:58,060
design applications for their framework

00:14:54,100 --> 00:15:01,480
of choice also the things it creates

00:14:58,060 --> 00:15:03,579
that the dialogs they actually are very

00:15:01,480 --> 00:15:05,110
functional in a sense you can resize

00:15:03,579 --> 00:15:07,959
them easily and these kind of small

00:15:05,110 --> 00:15:12,509
things and it's still going to look good

00:15:07,959 --> 00:15:16,750
so it's super easy to use this tool and

00:15:12,509 --> 00:15:21,100
it works super well in my opinion on the

00:15:16,750 --> 00:15:25,750
C++ side we see the first use of a code

00:15:21,100 --> 00:15:28,930
generator in the cute field you include

00:15:25,750 --> 00:15:31,300
a generated header file which has the

00:15:28,930 --> 00:15:33,490
knowledge about how your dialog is

00:15:31,300 --> 00:15:39,100
supposed to look like and then you say

00:15:33,490 --> 00:15:41,649
I set up and do something I didn't show

00:15:39,100 --> 00:15:45,490
I don't show the header here but mu I is

00:15:41,649 --> 00:15:50,050
essentially a smartphone uh you could

00:15:45,490 --> 00:15:52,600
use make new here or whatever make

00:15:50,050 --> 00:15:57,220
unique I mean that's very easily doable

00:15:52,600 --> 00:15:59,230
and then your UI is the view part right

00:15:57,220 --> 00:16:02,230
and then you have a model somewhere data

00:15:59,230 --> 00:16:04,779
so you create that one and then just

00:16:02,230 --> 00:16:07,720
maybe put a proxy in between fulfill

00:16:04,779 --> 00:16:10,480
Turing purposes or maybe you want to

00:16:07,720 --> 00:16:13,779
sort stuff it's very nicely separated

00:16:10,480 --> 00:16:16,029
all of that and then you connect some

00:16:13,779 --> 00:16:19,660
signals and slots again very typical for

00:16:16,029 --> 00:16:21,930
cute by the way this is how you write

00:16:19,660 --> 00:16:25,209
signals and slots today and cute

00:16:21,930 --> 00:16:26,649
whenever you think or hear people saying

00:16:25,209 --> 00:16:29,410
yeah signals and slots are so

00:16:26,649 --> 00:16:31,480
inefficient lots of string comparisons

00:16:29,410 --> 00:16:33,640
that's cute four or three or whatever

00:16:31,480 --> 00:16:36,100
deads archaic you don't do that anymore

00:16:33,640 --> 00:16:38,620
in cute five cute five signal slots

00:16:36,100 --> 00:16:40,980
connections accept any color ball you

00:16:38,620 --> 00:16:47,050
can pass in lambdas you can pass in

00:16:40,980 --> 00:16:49,690
Rossie functions do it and you don't

00:16:47,050 --> 00:16:52,029
even need most of the craft that you

00:16:49,690 --> 00:16:56,410
needed in cute for anymore nowadays with

00:16:52,029 --> 00:16:57,970
modern cute this example I just showed

00:16:56,410 --> 00:17:01,089
it was a bit streamed down but

00:16:57,970 --> 00:17:03,100
essentially here is an example of how it

00:17:01,089 --> 00:17:06,130
could look like in the end this is from

00:17:03,100 --> 00:17:08,829
my heap Trek UI it's in my spare time

00:17:06,130 --> 00:17:10,990
also work on a profiler which I'll do a

00:17:08,829 --> 00:17:14,230
lightning talk about I think tomorrow

00:17:10,990 --> 00:17:16,449
and it took me maybe I don't know let's

00:17:14,230 --> 00:17:19,120
say one hour to write the model probably

00:17:16,449 --> 00:17:20,800
less and then five minutes to click

00:17:19,120 --> 00:17:23,620
together the UI and it's fully

00:17:20,800 --> 00:17:28,209
functional and works very well and I

00:17:23,620 --> 00:17:30,580
don't know any other C++ UI framework

00:17:28,209 --> 00:17:34,090
that lost this kind of functionality

00:17:30,580 --> 00:17:35,500
with such simplicity of use and most of

00:17:34,090 --> 00:17:38,730
them don't even provide you with any

00:17:35,500 --> 00:17:41,290
reusable widgets in the first place and

00:17:38,730 --> 00:17:45,040
remember this works then on Windows on

00:17:41,290 --> 00:17:47,120
Mac on wherever you compile it right so

00:17:45,040 --> 00:17:48,710
cute widgets it's a

00:17:47,120 --> 00:17:51,950
very proven technology it's been around

00:17:48,710 --> 00:17:54,380
for 20 years as I said and it's super

00:17:51,950 --> 00:17:57,890
for desktop applications these kind of

00:17:54,380 --> 00:18:00,020
in-house things or rich clients or

00:17:57,890 --> 00:18:03,530
whatever you you name it where you

00:18:00,020 --> 00:18:12,740
present lots of data sorry it's not

00:18:03,530 --> 00:18:15,740
going sorry um it's not going to die die

00:18:12,740 --> 00:18:21,679
and it allows you to create contemporary

00:18:15,740 --> 00:18:24,230
if not even modern UI for your code so

00:18:21,679 --> 00:18:29,720
with that said let's get to the second

00:18:24,230 --> 00:18:31,640
part or third part Q quick I said Q

00:18:29,720 --> 00:18:34,550
widget has been around for a long time

00:18:31,640 --> 00:18:37,270
and over the process of working on that

00:18:34,550 --> 00:18:40,280
the cute people realized that there are

00:18:37,270 --> 00:18:42,260
some problems that you cannot easily

00:18:40,280 --> 00:18:45,080
solve with the existing API

00:18:42,260 --> 00:18:46,960
the biggest problem there is getting

00:18:45,080 --> 00:18:50,870
something that is hardware accelerated

00:18:46,960 --> 00:18:53,929
cute widgets it's using of course you

00:18:50,870 --> 00:18:56,630
CPU sim de structures and whatever to

00:18:53,929 --> 00:18:58,550
make it as fast as possible but it won't

00:18:56,630 --> 00:19:01,160
actually use your graphics card for

00:18:58,550 --> 00:19:05,410
example to offload stuff it's super

00:19:01,160 --> 00:19:09,530
inefficient hard to get fluid animated

00:19:05,410 --> 00:19:15,350
interfaces with the widgets API so cute

00:19:09,530 --> 00:19:17,720
quick is originally it was developed in

00:19:15,350 --> 00:19:20,929
the Nokia de so that's where most of the

00:19:17,720 --> 00:19:22,730
work happened and cute when it trolltech

00:19:20,929 --> 00:19:24,890
was bought by Nokia undated wanted to

00:19:22,730 --> 00:19:26,510
put that technology onto the Nokia

00:19:24,890 --> 00:19:29,480
phones I actually don't know whether

00:19:26,510 --> 00:19:31,610
they ever did that or if there ever was

00:19:29,480 --> 00:19:35,840
a Nokia phone that used cute quick

00:19:31,610 --> 00:19:37,700
maybe the n9 m but what we do know is

00:19:35,840 --> 00:19:39,890
that these three phones are out there in

00:19:37,700 --> 00:19:42,740
the market right now from left to right

00:19:39,890 --> 00:19:45,380
it's the sailfish OS running on a Ola

00:19:42,740 --> 00:19:49,700
phone it's a blackberry Passport running

00:19:45,380 --> 00:19:52,580
the BlackBerry 10 OS and Ubuntu phone

00:19:49,700 --> 00:19:56,030
all of them use cute quick to latest

00:19:52,580 --> 00:19:58,460
cute v based IQ ml for their fluid

00:19:56,030 --> 00:20:01,390
interfaces it's nicely touch enabled

00:19:58,460 --> 00:20:04,190
it's hardware accelerated

00:20:01,390 --> 00:20:05,750
sadly none of these three platforms is

00:20:04,190 --> 00:20:08,059
really successful I don't personally

00:20:05,750 --> 00:20:13,820
think it's the fault of cute but rather

00:20:08,059 --> 00:20:15,890
the big contenders out out there I use a

00:20:13,820 --> 00:20:16,279
blackberry as well I'm very happy with

00:20:15,890 --> 00:20:20,570
it

00:20:16,279 --> 00:20:23,120
from the fluidity a point of view so I

00:20:20,570 --> 00:20:26,899
really think that cute quick is perfect

00:20:23,120 --> 00:20:29,450
for these kinda applications you can run

00:20:26,899 --> 00:20:33,529
it also on existing mobile platforms

00:20:29,450 --> 00:20:35,270
here it's this is Midland Valley's field

00:20:33,529 --> 00:20:38,419
move application it's meant for

00:20:35,270 --> 00:20:42,080
geologists to be used on the field to do

00:20:38,419 --> 00:20:45,710
whatever geologists do and you can see

00:20:42,080 --> 00:20:48,020
that this kind of touch enabled fancy UI

00:20:45,710 --> 00:20:53,840
is actually also usable to get real work

00:20:48,020 --> 00:20:55,909
done it works on iOS and I think it

00:20:53,840 --> 00:20:58,070
might also work on Android and I'm not

00:20:55,909 --> 00:20:59,860
too acquainted with that but it's a nice

00:20:58,070 --> 00:21:02,870
example of what you can do with it and

00:20:59,860 --> 00:21:04,669
then this is a screenshot that the cute

00:21:02,870 --> 00:21:06,409
company puts into their marketing

00:21:04,669 --> 00:21:08,690
material and I quite like it because it

00:21:06,409 --> 00:21:12,049
shows you the different form factors and

00:21:08,690 --> 00:21:15,289
platforms that you can put on your put

00:21:12,049 --> 00:21:18,350
your application on and here I

00:21:15,289 --> 00:21:20,899
explicitly took it because of these

00:21:18,350 --> 00:21:22,520
things like embedded platforms with a

00:21:20,899 --> 00:21:25,279
display it's becoming more and more

00:21:22,520 --> 00:21:28,039
common because it's so cheap nowadays to

00:21:25,279 --> 00:21:30,200
buy a touchscreen and you can hook it up

00:21:28,039 --> 00:21:32,980
to your industrial oven or something

00:21:30,200 --> 00:21:39,159
like that and having visually pleasing

00:21:32,980 --> 00:21:42,620
UI with the logic in C++ behind it on

00:21:39,159 --> 00:21:44,899
the desktop it's still oh it's becoming

00:21:42,620 --> 00:21:46,640
more more used as well you can use the

00:21:44,899 --> 00:21:49,279
so-called components to construct

00:21:46,640 --> 00:21:52,909
something which looks similar to widget

00:21:49,279 --> 00:21:55,190
applications here I show the plasma

00:21:52,909 --> 00:21:59,110
desktop from KDE so it's very common to

00:21:55,190 --> 00:22:03,320
see that on Linux or beast machines and

00:21:59,110 --> 00:22:06,409
this is again built on qm q ml 2 or q

00:22:03,320 --> 00:22:08,960
quick 2 on q ml and they are now working

00:22:06,409 --> 00:22:11,929
on pushing it to mobile phones as well

00:22:08,960 --> 00:22:14,360
showing how easy it is to adapt from one

00:22:11,929 --> 00:22:19,040
form factor to another

00:22:14,360 --> 00:22:21,740
a very different use case but something

00:22:19,040 --> 00:22:24,110
that many people need is that you have

00:22:21,740 --> 00:22:27,110
your existing 3d content rendered in

00:22:24,110 --> 00:22:29,120
OpenGL for example and you need to put

00:22:27,110 --> 00:22:32,660
text on top all you need to put controls

00:22:29,120 --> 00:22:37,640
on top qlq quick makes that super simple

00:22:32,660 --> 00:22:41,150
and the same is valid for multimedia

00:22:37,640 --> 00:22:44,090
content so you can put shader effects on

00:22:41,150 --> 00:22:46,670
the hardware accelerated multimedia

00:22:44,090 --> 00:22:49,250
stream you get and this is going to

00:22:46,670 --> 00:22:54,980
perform quite well even on embedded

00:22:49,250 --> 00:22:58,850
platforms the thing is when you write

00:22:54,980 --> 00:23:03,140
these kind of cue quick you eyes it's

00:22:58,850 --> 00:23:03,680
not C++ you write on the representation

00:23:03,140 --> 00:23:06,260
side

00:23:03,680 --> 00:23:10,130
this is QML it's a declarative language

00:23:06,260 --> 00:23:13,880
you state what should happen instead of

00:23:10,130 --> 00:23:18,830
how it should happen it's very easy to

00:23:13,880 --> 00:23:22,130
get into you simply bind properties to

00:23:18,830 --> 00:23:25,850
another like here the X properties or

00:23:22,130 --> 00:23:28,160
where the button is positioned on the

00:23:25,850 --> 00:23:30,680
left side it's bound to the checked

00:23:28,160 --> 00:23:33,230
property and if I would check that

00:23:30,680 --> 00:23:37,690
button it would flip from left to right

00:23:33,230 --> 00:23:41,120
this is what this binding does here and

00:23:37,690 --> 00:23:44,060
it's super cool then to add an animation

00:23:41,120 --> 00:23:47,750
for that as well and if you do these

00:23:44,060 --> 00:23:50,240
kind of things in C++ it's certainly

00:23:47,750 --> 00:23:53,480
doable it's not going to win any price

00:23:50,240 --> 00:23:56,330
on readability I'm pretty sure I do hope

00:23:53,480 --> 00:23:59,230
that people come up with parents on on

00:23:56,330 --> 00:24:03,230
what to do there right now the practical

00:23:59,230 --> 00:24:05,180
aspect of cute solved it by introducing

00:24:03,230 --> 00:24:08,920
this language with this which is

00:24:05,180 --> 00:24:13,460
actually not that bad but you must not

00:24:08,920 --> 00:24:16,640
make the error of saying okay qml and

00:24:13,460 --> 00:24:17,930
javascript will replace all of c++ that

00:24:16,640 --> 00:24:20,480
is not the case at all

00:24:17,930 --> 00:24:22,490
you quick is meant to provide you with a

00:24:20,480 --> 00:24:25,820
declarative language which you then use

00:24:22,490 --> 00:24:27,650
for saying how something should work it

00:24:25,820 --> 00:24:28,580
provides you with a hardware accelerated

00:24:27,650 --> 00:24:31,730
scene

00:24:28,580 --> 00:24:36,379
which is super efficient and very nice

00:24:31,730 --> 00:24:39,470
to use and makes it super easy to create

00:24:36,379 --> 00:24:41,509
fancy anime to do ice and thus thereby

00:24:39,470 --> 00:24:44,029
making it cool to use it on embedded

00:24:41,509 --> 00:24:46,610
devices or for OpenGL / lessons and

00:24:44,029 --> 00:24:48,590
whatnot but it's meant to be used for

00:24:46,610 --> 00:24:51,080
the representation only let me stress

00:24:48,590 --> 00:24:55,850
this point again put your data put your

00:24:51,080 --> 00:24:58,370
logic into C++ educator the companies

00:24:55,850 --> 00:25:02,179
that come to us that have problems with

00:24:58,370 --> 00:25:04,279
qml applications they always or not

00:25:02,179 --> 00:25:08,299
always but often make the mistake of

00:25:04,279 --> 00:25:10,879
putting too much into QML it's a the

00:25:08,299 --> 00:25:12,799
same issue you can have on C++ widgets

00:25:10,879 --> 00:25:14,600
application right you put all your view

00:25:12,799 --> 00:25:16,759
logic in all of your data into the

00:25:14,600 --> 00:25:19,460
widgets instead of separating between

00:25:16,759 --> 00:25:22,610
data and presentation it's a very bad

00:25:19,460 --> 00:25:26,600
mistake don't do it only use cue quick

00:25:22,610 --> 00:25:29,720
for the representation side use C++ for

00:25:26,600 --> 00:25:32,750
the obvious reasons for logic and data

00:25:29,720 --> 00:25:35,269
and do keep your JavaScript to a minimum

00:25:32,750 --> 00:25:37,519
it will kill performance it will make it

00:25:35,269 --> 00:25:43,029
harder to find bugs and fix them and all

00:25:37,519 --> 00:25:50,779
of the problems you have with JavaScript

00:25:43,029 --> 00:25:55,250
so with that said I want to come to the

00:25:50,779 --> 00:25:57,250
essential section because yes cutest

00:25:55,250 --> 00:25:58,610
first and foremost meant to be used for

00:25:57,250 --> 00:26:03,620
UI

00:25:58,610 --> 00:26:07,190
it's a UI to code after after all but

00:26:03,620 --> 00:26:09,950
cute is so much more than that if you

00:26:07,190 --> 00:26:12,529
start using cute and you realize that oh

00:26:09,950 --> 00:26:15,559
wait I need to connect to a sequel

00:26:12,529 --> 00:26:18,470
database and I need to access the data

00:26:15,559 --> 00:26:21,700
in their cute office you an API that is

00:26:18,470 --> 00:26:26,149
cross-platform and gets the job done you

00:26:21,700 --> 00:26:29,470
have access to a date/time API which

00:26:26,149 --> 00:26:32,149
also comes with support for time zones

00:26:29,470 --> 00:26:34,909
something that I think there are going

00:26:32,149 --> 00:26:38,179
to be more talks on at CPE Khan here

00:26:34,909 --> 00:26:40,039
very hard problem to get right here's

00:26:38,179 --> 00:26:41,780
one solution that's being used in many

00:26:40,039 --> 00:26:45,320
places already

00:26:41,780 --> 00:26:48,650
more or less satisfactory I mentioned

00:26:45,320 --> 00:26:51,620
already before that cute supports very

00:26:48,650 --> 00:26:54,590
well accessibility and localization so

00:26:51,620 --> 00:26:57,050
you can sort stuff based on the locale

00:26:54,590 --> 00:27:01,910
of your user you can format numbers the

00:26:57,050 --> 00:27:04,670
way he wants it to have it you can add

00:27:01,910 --> 00:27:07,520
accessibility such that blind people can

00:27:04,670 --> 00:27:13,150
operate your user interface so you can

00:27:07,520 --> 00:27:15,830
hook it up to screen readers you have

00:27:13,150 --> 00:27:18,670
Unicode strings pervasively throughout

00:27:15,830 --> 00:27:21,560
the cute api the in famous cue string

00:27:18,670 --> 00:27:24,440
yes it's not stood string it has no

00:27:21,560 --> 00:27:26,750
short string optimizations there are

00:27:24,440 --> 00:27:29,390
many things that may be wrong with it

00:27:26,750 --> 00:27:30,920
but from a practical point of view it

00:27:29,390 --> 00:27:33,070
gets the job done really really well

00:27:30,920 --> 00:27:36,620
it's super optimized for what it does

00:27:33,070 --> 00:27:39,230
utf-16 representation of strings so

00:27:36,620 --> 00:27:43,490
similar to what ICU uses internally or

00:27:39,230 --> 00:27:49,340
what windows uses for strings or java

00:27:43,490 --> 00:27:52,150
does the same and these strings have the

00:27:49,340 --> 00:27:55,550
string class has a very good api as well

00:27:52,150 --> 00:27:57,380
but talking about misconceptions people

00:27:55,550 --> 00:27:59,240
think that as soon as they start using

00:27:57,380 --> 00:28:01,640
cute they have to use cue string

00:27:59,240 --> 00:28:03,650
everywhere that's not the case only use

00:28:01,640 --> 00:28:06,670
it where you want to feed or show data

00:28:03,650 --> 00:28:09,680
to the user at that point you care about

00:28:06,670 --> 00:28:13,910
unicode data anywhere else for example

00:28:09,680 --> 00:28:16,070
if you parse raw let in one string so

00:28:13,910 --> 00:28:17,900
something like that from this do use

00:28:16,070 --> 00:28:20,450
either stood string or queue by the

00:28:17,900 --> 00:28:24,080
radio anything else cue string is only

00:28:20,450 --> 00:28:27,520
meant to be used for putting data or

00:28:24,080 --> 00:28:31,310
showing data to the user in the end

00:28:27,520 --> 00:28:33,680
there are the signals and slots in cute

00:28:31,310 --> 00:28:36,650
which are in my opinion really well done

00:28:33,680 --> 00:28:39,350
they come with a minimal amount of

00:28:36,650 --> 00:28:42,980
overhead if at all thanks to the code

00:28:39,350 --> 00:28:44,840
generator you can add things and slots

00:28:42,980 --> 00:28:47,660
later on while keeping binary

00:28:44,840 --> 00:28:53,300
compatibility which is also extremely

00:28:47,660 --> 00:28:55,460
cool there is a any type wrapper like

00:28:53,300 --> 00:28:58,510
boost any called cue variant

00:28:55,460 --> 00:29:01,490
if you need that it's there you can get

00:28:58,510 --> 00:29:04,880
file system access that's similar to

00:29:01,490 --> 00:29:07,960
what hopefully we'll get an stl sooner

00:29:04,880 --> 00:29:10,610
or later you get asynchronous i/o

00:29:07,960 --> 00:29:12,980
networking these kind of things you can

00:29:10,610 --> 00:29:17,240
even use state machines where by the way

00:29:12,980 --> 00:29:19,040
um the C++ API for state machines sucks

00:29:17,240 --> 00:29:20,750
it's so hard to write all the

00:29:19,040 --> 00:29:22,370
boilerplate code I'm not sure whether

00:29:20,750 --> 00:29:25,250
any one of you had the pleasure of

00:29:22,370 --> 00:29:28,400
working with the C++ state machine

00:29:25,250 --> 00:29:32,180
library it's really really bad the comp

00:29:28,400 --> 00:29:36,500
colleague of mine spend time on adding

00:29:32,180 --> 00:29:39,200
qml bindings for the state machine code

00:29:36,500 --> 00:29:41,780
and cute and suddenly you realize that

00:29:39,200 --> 00:29:44,600
oh right this is what you actually want

00:29:41,780 --> 00:29:47,030
to write and this is something we see

00:29:44,600 --> 00:29:51,350
more and more that people use QML the

00:29:47,030 --> 00:29:53,660
language so not the cute quick graphical

00:29:51,350 --> 00:29:58,160
part of it but rather just that the

00:29:53,660 --> 00:30:01,240
language itself as domain-specific

00:29:58,160 --> 00:30:04,610
language for whatever you need in your

00:30:01,240 --> 00:30:06,500
application and there's API to do just

00:30:04,610 --> 00:30:08,240
that so if you need if you look at the

00:30:06,500 --> 00:30:10,460
language and say oh this is actually

00:30:08,240 --> 00:30:12,380
nice I want to use it for I don't know

00:30:10,460 --> 00:30:15,740
my build system people in cute have done

00:30:12,380 --> 00:30:17,000
that for some reason or what else is

00:30:15,740 --> 00:30:18,620
there I don't know

00:30:17,000 --> 00:30:21,560
yeah state machines is the obvious

00:30:18,620 --> 00:30:24,200
example think UML is really cool and you

00:30:21,560 --> 00:30:25,970
should have a look at that it makes it

00:30:24,200 --> 00:30:27,710
much easier to maintain your code as

00:30:25,970 --> 00:30:35,120
well compared to writing all the crafts

00:30:27,710 --> 00:30:37,520
in C++ so um this is Q core or was Q

00:30:35,120 --> 00:30:39,710
core this is still cute core but also a

00:30:37,520 --> 00:30:42,680
few external modules they're cute itself

00:30:39,710 --> 00:30:46,190
is separated into multiple libraries so

00:30:42,680 --> 00:30:48,890
you don't have to use or pay the price

00:30:46,190 --> 00:30:53,020
of shipping megabytes of megabytes if

00:30:48,890 --> 00:30:56,210
you don't and use all of that but again

00:30:53,020 --> 00:30:59,360
all of this works on various platforms

00:30:56,210 --> 00:31:00,890
right it's if you start using it on one

00:30:59,360 --> 00:31:03,740
platform you can be sure that uh later

00:31:00,890 --> 00:31:07,070
on someone demands a Mac version of your

00:31:03,740 --> 00:31:08,930
application it will work so especially

00:31:07,070 --> 00:31:12,020
here I want to stress that you

00:31:08,930 --> 00:31:14,510
use it to access services via Bluetooth

00:31:12,020 --> 00:31:17,840
you have support for near field

00:31:14,510 --> 00:31:21,500
communication I showed the example for

00:31:17,840 --> 00:31:23,570
multimedia integration already you have

00:31:21,500 --> 00:31:26,210
perverse of support for printing and

00:31:23,570 --> 00:31:28,460
things like that it's very helpful and

00:31:26,210 --> 00:31:31,910
all of these are things that many people

00:31:28,460 --> 00:31:34,690
don't realize you need in a graphical

00:31:31,910 --> 00:31:38,030
application because oftentimes when you

00:31:34,690 --> 00:31:40,130
create an application after I don't know

00:31:38,030 --> 00:31:42,200
a few weeks someone says like ok it

00:31:40,130 --> 00:31:44,720
would be cool if you could hook up I

00:31:42,200 --> 00:31:47,390
don't know generate me a PDF report for

00:31:44,720 --> 00:31:49,370
the data I see on my UI right if you

00:31:47,390 --> 00:31:53,750
would then need to start looking for a

00:31:49,370 --> 00:31:55,460
separate library that does the job then

00:31:53,750 --> 00:31:57,890
you need to figure out how to integrate

00:31:55,460 --> 00:32:00,290
it with the rest of your code with cute

00:31:57,890 --> 00:32:03,530
that's super simple because many many

00:32:00,290 --> 00:32:05,390
features are there already were like

00:32:03,530 --> 00:32:10,940
inside cute itself or they are being

00:32:05,390 --> 00:32:14,150
provided by external provides yeah KDE

00:32:10,940 --> 00:32:17,870
again I'm connected to that I care about

00:32:14,150 --> 00:32:20,390
it and they spent a lot of time in the

00:32:17,870 --> 00:32:23,660
progression from cute 4 to cute 5 to

00:32:20,390 --> 00:32:25,340
upstream the various features they found

00:32:23,660 --> 00:32:27,470
were missing in cute

00:32:25,340 --> 00:32:30,080
they had it back then in KDE lips it was

00:32:27,470 --> 00:32:32,390
called and they upstream a tremendous

00:32:30,080 --> 00:32:35,240
amount of work into queued itself so now

00:32:32,390 --> 00:32:37,100
if you need for example temporary files

00:32:35,240 --> 00:32:42,740
or directories and things like that it's

00:32:37,100 --> 00:32:45,440
their log files standard path access and

00:32:42,740 --> 00:32:48,290
whatnot it's in queued proper some

00:32:45,440 --> 00:32:50,810
things are still separate and the

00:32:48,290 --> 00:32:53,300
so-called KD frameworks is a collection

00:32:50,810 --> 00:32:55,310
of these tools each one of these bullet

00:32:53,300 --> 00:32:58,670
points here is a more or less individual

00:32:55,310 --> 00:33:02,030
library and you can use them for example

00:32:58,670 --> 00:33:03,500
to access zip files or tau bolts or

00:33:02,030 --> 00:33:06,410
something like that there's a very nice

00:33:03,500 --> 00:33:10,760
cute API for compressed il called K

00:33:06,410 --> 00:33:14,560
archive you have a collection of high

00:33:10,760 --> 00:33:17,450
quality proxy models that do for example

00:33:14,560 --> 00:33:19,490
recursive searching in a tree model I

00:33:17,450 --> 00:33:22,010
feel free to use that it's all open

00:33:19,490 --> 00:33:25,820
source it's high-quality test

00:33:22,010 --> 00:33:28,820
for years and peer-reviewed and whatnot

00:33:25,820 --> 00:33:31,910
so I think in an abstract I said

00:33:28,820 --> 00:33:34,610
something like KDE is for Q what boost

00:33:31,910 --> 00:33:35,180
is for STL I think that's really the

00:33:34,610 --> 00:33:37,610
case

00:33:35,180 --> 00:33:39,470
KD is where the innovation takes place

00:33:37,610 --> 00:33:44,210
and then it gets upstream in the long

00:33:39,470 --> 00:33:48,200
run to acute problem then there is

00:33:44,210 --> 00:33:50,840
include org it's founded by Canelo

00:33:48,200 --> 00:33:53,240
Schumacher also from KD Fame and it's

00:33:50,840 --> 00:33:55,640
meant to give you a central website

00:33:53,240 --> 00:33:58,310
where you can go to if you're looking

00:33:55,640 --> 00:34:01,880
for anything that's missing in cute at

00:33:58,310 --> 00:34:04,970
the moment it lists 184 cute libraries

00:34:01,880 --> 00:34:07,160
that solve various problems and it makes

00:34:04,970 --> 00:34:09,409
it very easy to install them so it shows

00:34:07,160 --> 00:34:12,830
you the library where to the license

00:34:09,409 --> 00:34:14,899
were to get it even a ruby tool to

00:34:12,830 --> 00:34:18,169
install stuff the command line and

00:34:14,899 --> 00:34:20,960
update it and stuff like that so again

00:34:18,169 --> 00:34:24,760
if you use cute do have a look here if

00:34:20,960 --> 00:34:24,760
you ever find anything that's missing

00:34:24,790 --> 00:34:31,010
okay so this was the overview of what

00:34:28,970 --> 00:34:35,480
you can do with cute there's a lot I

00:34:31,010 --> 00:34:38,629
left out tremendous parts there but I

00:34:35,480 --> 00:34:41,030
felt it was important first to establish

00:34:38,629 --> 00:34:43,909
the baseline before going into the

00:34:41,030 --> 00:34:46,090
misconceptions I will talk about these

00:34:43,909 --> 00:34:50,389
four points here code generators

00:34:46,090 --> 00:34:52,669
containers C++ 11 or XY whatever didn't

00:34:50,389 --> 00:34:54,470
latest and greatest is and then in the

00:34:52,669 --> 00:34:58,310
end the development process of queued

00:34:54,470 --> 00:35:00,080
itself so let's start off with cute

00:34:58,310 --> 00:35:04,130
generate a code generators not cute

00:35:00,080 --> 00:35:06,680
generators people keep complaining about

00:35:04,130 --> 00:35:09,890
mock the metal object compared people

00:35:06,680 --> 00:35:12,850
even decide to fork an ancient version

00:35:09,890 --> 00:35:15,710
of cute to replace mock for some reason

00:35:12,850 --> 00:35:18,440
the thing is Marcus just one of many

00:35:15,710 --> 00:35:21,890
code generators being used in cute and

00:35:18,440 --> 00:35:26,810
the others are the UI compiler I showed

00:35:21,890 --> 00:35:29,990
that for generating dialogue layouts and

00:35:26,810 --> 00:35:33,380
things and the last one is the resource

00:35:29,990 --> 00:35:35,930
compiler both of them are never going to

00:35:33,380 --> 00:35:38,030
be replaced by C++ code I doubt

00:35:35,930 --> 00:35:41,630
that someone will start adding the

00:35:38,030 --> 00:35:45,109
ability to parse and read files from the

00:35:41,630 --> 00:35:46,970
disk and generate code from that because

00:35:45,109 --> 00:35:49,119
this is what you do here right the

00:35:46,970 --> 00:35:51,770
resource compiler takes for example

00:35:49,119 --> 00:35:54,230
image files and compresses them if

00:35:51,770 --> 00:35:56,780
needed and puts them as binary data

00:35:54,230 --> 00:35:59,180
directly into your executable making it

00:35:56,780 --> 00:36:02,510
super simple to deploy your code

00:35:59,180 --> 00:36:04,640
anywhere right you don't need to send

00:36:02,510 --> 00:36:06,500
the full folder with hundreds of images

00:36:04,640 --> 00:36:09,579
it's just going to be one executable

00:36:06,500 --> 00:36:09,579
that's going to work everywhere

00:36:09,760 --> 00:36:15,079
so the code generators are meant to

00:36:12,829 --> 00:36:16,599
improve the productivity of you as a

00:36:15,079 --> 00:36:19,819
developer

00:36:16,599 --> 00:36:23,150
they really simplify code maintenance

00:36:19,819 --> 00:36:26,210
especially UI compiler in KDE or even in

00:36:23,150 --> 00:36:29,329
customer code I've seen it k-dub there's

00:36:26,210 --> 00:36:32,869
still old code that uses the manual C++

00:36:29,329 --> 00:36:35,420
way of setting up a layout and it's such

00:36:32,869 --> 00:36:37,640
a hassle to update that whenever you

00:36:35,420 --> 00:36:40,099
need to like ok how does this actually

00:36:37,640 --> 00:36:42,020
look like you have to figure it out by

00:36:40,099 --> 00:36:44,150
just reading the code I don't work that

00:36:42,020 --> 00:36:47,089
way I want to like if I want to change

00:36:44,150 --> 00:36:48,920
something visual super cool to actually

00:36:47,089 --> 00:36:51,890
see it and then change for example the

00:36:48,920 --> 00:36:55,849
order of widgets or adding margins and

00:36:51,890 --> 00:36:57,710
padding's and whatever and the code

00:36:55,849 --> 00:37:00,170
generators are there to overcome

00:36:57,710 --> 00:37:01,790
limitations in the C++ language some of

00:37:00,170 --> 00:37:04,490
them hopefully will get resolved

00:37:01,790 --> 00:37:08,500
especially for mock overtime but others

00:37:04,490 --> 00:37:14,000
like UIC or RCC I don't ever see C++

00:37:08,500 --> 00:37:14,809
fixing that and also let me stress

00:37:14,000 --> 00:37:17,510
something here

00:37:14,809 --> 00:37:19,520
yes Q does use code generators as does

00:37:17,510 --> 00:37:21,829
many many other people's people or

00:37:19,520 --> 00:37:25,670
companies out there that maybe not use

00:37:21,829 --> 00:37:27,589
cute a very good example here is the

00:37:25,670 --> 00:37:31,339
keynote from Mike Acton from last year's

00:37:27,589 --> 00:37:33,890
CPP con he said that the games community

00:37:31,339 --> 00:37:35,450
at large uses many code generators in

00:37:33,890 --> 00:37:39,470
various places for efficiency reasons

00:37:35,450 --> 00:37:42,109
mostly or just to make writing code less

00:37:39,470 --> 00:37:45,230
mundane you can do it in C++ often time

00:37:42,109 --> 00:37:50,589
but that would mean repetitive code or

00:37:45,230 --> 00:37:50,589
very ugly macro based code bases

00:37:50,630 --> 00:37:56,550
so let's talk oh yeah before I continue

00:37:54,810 --> 00:37:58,800
going in-depth with mark

00:37:56,550 --> 00:38:03,120
I want to say something that also many

00:37:58,800 --> 00:38:05,640
people don't get for some reason these

00:38:03,120 --> 00:38:08,430
tools all of them that cute chips are

00:38:05,640 --> 00:38:11,190
very well integrated into various build

00:38:08,430 --> 00:38:14,460
tool chains better integrated than many

00:38:11,190 --> 00:38:16,940
other code generators like I don't know

00:38:14,460 --> 00:38:19,710
yak or bezel on or something like that

00:38:16,940 --> 00:38:22,650
you make obviously has NATO some more

00:38:19,710 --> 00:38:25,440
support for it but don't use cumec quite

00:38:22,650 --> 00:38:27,660
frankly it's it gets through a job done

00:38:25,440 --> 00:38:30,120
but in my opinion see make is a much

00:38:27,660 --> 00:38:33,900
superior build system and that one as

00:38:30,120 --> 00:38:38,280
well has native support for auto mark

00:38:33,900 --> 00:38:40,830
and running RCC and UIC transparently

00:38:38,280 --> 00:38:43,020
it's it's super easy to get done there

00:38:40,830 --> 00:38:45,840
is even a add-in for Visual Studio if

00:38:43,020 --> 00:38:48,390
you use that so you just run build and

00:38:45,840 --> 00:38:50,310
it will do its job it's not hard to

00:38:48,390 --> 00:38:55,460
integrate these tools into your tool

00:38:50,310 --> 00:38:58,350
chain at all so let's talk about mark um

00:38:55,460 --> 00:39:00,570
people think that the so called meta

00:38:58,350 --> 00:39:03,570
object compiler is mostly used for

00:39:00,570 --> 00:39:05,670
signals and slots it was definitely one

00:39:03,570 --> 00:39:08,430
of the main reasons back then but

00:39:05,670 --> 00:39:10,500
nowadays in modern q5 that's not the

00:39:08,430 --> 00:39:13,020
case anymore I mean sure you need it for

00:39:10,500 --> 00:39:14,820
signals that's true but for slots you

00:39:13,020 --> 00:39:16,470
don't need it at all oftentimes you

00:39:14,820 --> 00:39:19,950
don't even have slots anymore you just

00:39:16,470 --> 00:39:23,490
add a lambda and use the new signal slot

00:39:19,950 --> 00:39:26,370
connection syntax right but rather today

00:39:23,490 --> 00:39:28,050
in cute 5 you use it for reflection I

00:39:26,370 --> 00:39:31,290
mean this is an implementation of

00:39:28,050 --> 00:39:34,110
reflection you can use in C++ today I do

00:39:31,290 --> 00:39:37,650
hope that the work in an ISO cpp

00:39:34,110 --> 00:39:39,960
standard is going to extend what you can

00:39:37,650 --> 00:39:43,170
do with C++ so we can replace more and

00:39:39,960 --> 00:39:46,740
more of what mocked us by something that

00:39:43,170 --> 00:39:49,650
C++ offers you natively but the last

00:39:46,740 --> 00:39:52,260
time that Olevia go far the maintainer

00:39:49,650 --> 00:39:55,830
of mark looked at the standards papers

00:39:52,260 --> 00:39:58,560
they didn't he wasn't able to replace

00:39:55,830 --> 00:40:00,780
mock completely yet there's a very nice

00:39:58,560 --> 00:40:02,350
block entry written by him on the matter

00:40:00,780 --> 00:40:07,030
if you're interested in the lies

00:40:02,350 --> 00:40:10,360
on that and the queue meta object the

00:40:07,030 --> 00:40:15,070
reflection is also the basis in the cute

00:40:10,360 --> 00:40:17,680
world for wealth of features like IPC

00:40:15,070 --> 00:40:20,110
mechanisms or language bindings so qml

00:40:17,680 --> 00:40:22,180
of course is the obvious part here for

00:40:20,110 --> 00:40:24,010
the properties and property bindings

00:40:22,180 --> 00:40:26,770
it's essential to have the features that

00:40:24,010 --> 00:40:30,130
Mark gives you but it's also being used

00:40:26,770 --> 00:40:31,960
pervasively for Debose for web channel

00:40:30,130 --> 00:40:34,750
the module that I personally maintain

00:40:31,960 --> 00:40:38,470
with which you can transparently call

00:40:34,750 --> 00:40:42,300
queue object based C++ code from

00:40:38,470 --> 00:40:46,360
JavaScript running potentially inside

00:40:42,300 --> 00:40:48,790
cute WebKit or cute web engine view but

00:40:46,360 --> 00:40:51,490
also works with nodejs or anything else

00:40:48,790 --> 00:40:52,630
and then there's a project spearheaded

00:40:51,490 --> 00:40:54,400
by Ford

00:40:52,630 --> 00:40:58,720
we're also colleagues of mine working

00:40:54,400 --> 00:41:01,870
for helping them bringing it to

00:40:58,720 --> 00:41:06,670
fulfillment is the remote objects module

00:41:01,870 --> 00:41:10,720
which is IPC on a type safe level across

00:41:06,670 --> 00:41:16,360
C++ it's also very interesting project

00:41:10,720 --> 00:41:19,690
there so I said it already new signals

00:41:16,360 --> 00:41:22,360
lots you don't need to create the

00:41:19,690 --> 00:41:25,360
overhead of a queue object just to get

00:41:22,360 --> 00:41:27,580
the slot to then maybe run something in

00:41:25,360 --> 00:41:31,420
a delayed manner like here with cute v

00:41:27,580 --> 00:41:33,730
you just use Atlanta this is how you

00:41:31,420 --> 00:41:35,830
should use it there's no string

00:41:33,730 --> 00:41:41,040
comparison here nothing it's type

00:41:35,830 --> 00:41:41,040
checked at compile time like questions

00:41:42,240 --> 00:41:49,870
yes yes even the question was whether

00:41:47,650 --> 00:41:52,060
this was even across threats yes it does

00:41:49,870 --> 00:41:54,730
work across threats what you need for

00:41:52,060 --> 00:41:58,480
threats is just a declaration that the

00:41:54,730 --> 00:42:00,670
parameters you pass over that they are

00:41:58,480 --> 00:42:02,650
declared in Kanaka can be accepted

00:42:00,670 --> 00:42:05,410
encapsulated and moved across threats

00:42:02,650 --> 00:42:07,390
but this is the same for the old signals

00:42:05,410 --> 00:42:09,700
loading syntax so this is not related

00:42:07,390 --> 00:42:14,920
here at all so this is really what you

00:42:09,700 --> 00:42:16,290
should use everywhere and then let's

00:42:14,920 --> 00:42:18,750
talk a bit about

00:42:16,290 --> 00:42:22,320
efficiency mark has been around for 20

00:42:18,750 --> 00:42:25,800
years and I know that copper's biased is

00:42:22,320 --> 00:42:29,460
in famous new fork of the ancient cute

00:42:25,800 --> 00:42:33,840
4:8 version is not as old I don't want

00:42:29,460 --> 00:42:36,300
to say the code date road is really

00:42:33,840 --> 00:42:39,180
really bad but I just want to highlight

00:42:36,300 --> 00:42:40,770
here something that they probably do not

00:42:39,180 --> 00:42:42,840
take into account and that people in

00:42:40,770 --> 00:42:45,680
queued have taken into account for 20

00:42:42,840 --> 00:42:48,510
years now the code you generate with the

00:42:45,680 --> 00:42:51,750
code generator can be optimized really

00:42:48,510 --> 00:42:54,330
really well to the sense that the code

00:42:51,750 --> 00:42:57,360
it generates is shared across different

00:42:54,330 --> 00:42:59,640
applications and it is very minimal

00:42:57,360 --> 00:43:03,300
it can only emit the code it's actually

00:42:59,640 --> 00:43:05,610
needing so you can see here that the

00:43:03,300 --> 00:43:09,930
text and data sizes of the different

00:43:05,610 --> 00:43:12,720
library so this is cute for where cute

00:43:09,930 --> 00:43:16,350
GUI was still one monolithic block and

00:43:12,720 --> 00:43:18,690
then the second bar is for cute GUI and

00:43:16,350 --> 00:43:20,730
cute widgets in cute five where it was

00:43:18,690 --> 00:43:22,710
separated into two I took both into

00:43:20,730 --> 00:43:25,170
account here and then you have copper

00:43:22,710 --> 00:43:27,780
spice UI library so something that is

00:43:25,170 --> 00:43:30,150
relating to cute GUI in four eight so

00:43:27,780 --> 00:43:30,720
you can see the overhead is nearly twice

00:43:30,150 --> 00:43:33,630
as large

00:43:30,720 --> 00:43:34,950
if you dissect the binaries and look at

00:43:33,630 --> 00:43:37,620
where this comes from

00:43:34,950 --> 00:43:39,510
it's just signals and slots or they

00:43:37,620 --> 00:43:41,730
implementation thereof it has a huge

00:43:39,510 --> 00:43:44,040
overhead also when it comes to

00:43:41,730 --> 00:43:46,350
relocations which really really kills

00:43:44,040 --> 00:43:48,960
your startup speed for embedded

00:43:46,350 --> 00:43:51,360
platforms so as soon as you try to

00:43:48,960 --> 00:43:53,780
replace mark for the sake of replacing

00:43:51,360 --> 00:43:56,660
it please at least think about the

00:43:53,780 --> 00:44:01,880
impact that's going to have especially

00:43:56,660 --> 00:44:04,770
when it comes to the efficiency okay

00:44:01,880 --> 00:44:08,640
the next misconception I hear again and

00:44:04,770 --> 00:44:10,350
again from people trying out cute that

00:44:08,640 --> 00:44:14,310
you have to use the cute containers

00:44:10,350 --> 00:44:16,530
don't there are many of them if we use

00:44:14,310 --> 00:44:17,970
them do understand implicit sharing to

00:44:16,530 --> 00:44:21,660
copy and write pattern that cute

00:44:17,970 --> 00:44:23,700
implements you can write super efficient

00:44:21,660 --> 00:44:25,590
code when you leverage that properly but

00:44:23,700 --> 00:44:27,300
it's not a magic bullet you have to

00:44:25,590 --> 00:44:29,910
actually understand how to use it right

00:44:27,300 --> 00:44:32,099
if you do use them on

00:44:29,910 --> 00:44:35,130
use q vector and q hash by default and

00:44:32,099 --> 00:44:37,770
the rest only if you really find the hot

00:44:35,130 --> 00:44:40,349
spot that you profiler shows you I never

00:44:37,770 --> 00:44:43,020
had that case so really do not use Q

00:44:40,349 --> 00:44:45,240
list except if you have to interact with

00:44:43,020 --> 00:44:49,559
existing cute API that uses Q list

00:44:45,240 --> 00:44:51,359
it's a pity again code legacy but in

00:44:49,559 --> 00:44:53,490
your own data models for example it's

00:44:51,359 --> 00:44:56,160
super fine to use STL containers or

00:44:53,490 --> 00:44:58,230
boost containers they're very good and

00:44:56,160 --> 00:45:00,630
probably many parts even better than the

00:44:58,230 --> 00:45:03,539
cute counterparts there are the cases

00:45:00,630 --> 00:45:06,780
where the cute containers are better but

00:45:03,539 --> 00:45:10,760
only use them when you want to use them

00:45:06,780 --> 00:45:15,180
there's no reason you have to use them

00:45:10,760 --> 00:45:19,109
then C++ 11 and cubed people keep saying

00:45:15,180 --> 00:45:21,839
that Oh cute is so old because you

00:45:19,109 --> 00:45:25,380
cannot use a modern C++ with that this

00:45:21,839 --> 00:45:28,349
is not true it is true that up to 5.6

00:45:25,380 --> 00:45:32,309
the people working on cute inside cute

00:45:28,349 --> 00:45:34,710
libraries are not allowed to use C++ 11

00:45:32,309 --> 00:45:37,740
or not rely upon that but they do

00:45:34,710 --> 00:45:40,589
optionally enable a ton of features

00:45:37,740 --> 00:45:43,049
there like constant expert default

00:45:40,589 --> 00:45:45,480
deleted r-value references no accept

00:45:43,049 --> 00:45:47,130
null pointer whatever to improve the

00:45:45,480 --> 00:45:52,589
quality and the performance of the

00:45:47,130 --> 00:45:56,309
library today with 5.7 finally we can

00:45:52,589 --> 00:45:59,490
actually depend on a modern C++ in a

00:45:56,309 --> 00:46:02,520
little 11 enabled compiler to then use

00:45:59,490 --> 00:46:04,260
it inside cube for example this is going

00:46:02,520 --> 00:46:10,410
to be used to replace the handwritten

00:46:04,260 --> 00:46:13,589
assembly code for Atomics in cute and we

00:46:10,410 --> 00:46:16,289
will instead use STL counterparts there

00:46:13,589 --> 00:46:18,599
which is reducing the maintenance effort

00:46:16,289 --> 00:46:20,400
and ourside better integration with

00:46:18,599 --> 00:46:22,230
existing tools and whatnot so this is

00:46:20,400 --> 00:46:23,670
really something I look forward to but

00:46:22,230 --> 00:46:25,500
it is something for me as a cute

00:46:23,670 --> 00:46:28,200
developer looking forward to you as a

00:46:25,500 --> 00:46:29,880
user of queued on an application side

00:46:28,200 --> 00:46:32,849
you can use the latest and greatest

00:46:29,880 --> 00:46:36,960
these plus plus features now today and

00:46:32,849 --> 00:46:39,390
it's going to work and then last but not

00:46:36,960 --> 00:46:41,480
least I want to mention the development

00:46:39,390 --> 00:46:43,810
process because there again many people

00:46:41,480 --> 00:46:46,750
don't quite get it

00:46:43,810 --> 00:46:50,830
open governance I mentioned that already

00:46:46,750 --> 00:46:54,490
everyone can chime in everyone can add

00:46:50,830 --> 00:46:58,840
features or improve code it's open

00:46:54,490 --> 00:47:02,920
source but it's licensed it's dual

00:46:58,840 --> 00:47:05,890
license so you get the LGPL GPL codes or

00:47:02,920 --> 00:47:07,780
alternatively a commercial license when

00:47:05,890 --> 00:47:11,230
should you use one or the other that's

00:47:07,780 --> 00:47:14,560
your decision in my opinion as a company

00:47:11,230 --> 00:47:17,260
who invests money in a product and wants

00:47:14,560 --> 00:47:20,590
to make sure that it's available for the

00:47:17,260 --> 00:47:23,140
next coming what 10 years or so you

00:47:20,590 --> 00:47:26,410
should have an intention to actually

00:47:23,140 --> 00:47:28,630
fund third further EQ development by

00:47:26,410 --> 00:47:31,540
buying licenses from the cute company

00:47:28,630 --> 00:47:33,700
again not k-dub but you can go through

00:47:31,540 --> 00:47:36,010
us but it's not the thing right you want

00:47:33,700 --> 00:47:38,560
to make sure cute thrives and continues

00:47:36,010 --> 00:47:43,870
to develop and that's why you should buy

00:47:38,560 --> 00:47:45,840
licenses and there's one thing in queue

00:47:43,870 --> 00:47:48,460
which really stands out to me as

00:47:45,840 --> 00:47:52,030
exceptional that's the KDE free cube

00:47:48,460 --> 00:47:54,820
foundation it's been established years

00:47:52,030 --> 00:47:58,090
ago by the original founders of politic

00:47:54,820 --> 00:48:00,220
and they decided to make sure that no

00:47:58,090 --> 00:48:04,720
one can ever take the intellectual

00:48:00,220 --> 00:48:07,150
property of cute and kill it you cannot

00:48:04,720 --> 00:48:11,200
buy it and then just shove it onto the

00:48:07,150 --> 00:48:14,710
under the earth right this KT free cute

00:48:11,200 --> 00:48:17,770
foundation literally says that if new

00:48:14,710 --> 00:48:20,890
features get developed and our if the

00:48:17,770 --> 00:48:23,050
existing code gets changed without

00:48:20,890 --> 00:48:25,030
releasing it for one year then

00:48:23,050 --> 00:48:27,760
automatically all of the intellectual

00:48:25,030 --> 00:48:30,340
property and the rights there to go over

00:48:27,760 --> 00:48:34,450
to Katie evey there's a misconception

00:48:30,340 --> 00:48:36,340
people think that automatically all of Q

00:48:34,450 --> 00:48:40,570
becomes beast licensed that's not the

00:48:36,340 --> 00:48:43,930
case KDE V the nonprofit organization

00:48:40,570 --> 00:48:46,060
that runs KDE things gets the right to

00:48:43,930 --> 00:48:48,670
then decide what to do with it it can

00:48:46,060 --> 00:48:50,200
for example release it as beast but it

00:48:48,670 --> 00:48:54,850
could also say no let's create a

00:48:50,200 --> 00:48:57,110
consortium of companies in the field who

00:48:54,850 --> 00:48:59,270
are then maybe even allowed to do again

00:48:57,110 --> 00:49:03,080
sell licenses under a dual license model

00:48:59,270 --> 00:49:05,060
right don't mix that up and by the way

00:49:03,080 --> 00:49:07,970
this is also one of the main reasons for

00:49:05,060 --> 00:49:10,880
the CLA you have to sign when you

00:49:07,970 --> 00:49:13,430
contribute to cute that's for the sole

00:49:10,880 --> 00:49:18,520
purpose of being able to rely since as

00:49:13,430 --> 00:49:21,590
needed as the KDE evie decides to and

00:49:18,520 --> 00:49:35,330
with that I come to end there are any

00:49:21,590 --> 00:49:38,030
questions please the question was

00:49:35,330 --> 00:49:43,010
whether what the task based threading is

00:49:38,030 --> 00:49:46,010
I mentioned on the KT slide here that

00:49:43,010 --> 00:49:49,310
one that's the threat weaver library in

00:49:46,010 --> 00:49:51,200
KT frameworks it's my opinion far

00:49:49,310 --> 00:49:55,610
superior to what you get from cute

00:49:51,200 --> 00:49:57,680
concurrent or even plain stood a sink if

00:49:55,610 --> 00:50:00,140
you are interested interested in there

00:49:57,680 --> 00:50:01,420
to check it out its high quality I like

00:50:00,140 --> 00:50:08,240
it a lot

00:50:01,420 --> 00:50:11,060
yes I noticed a lot of gap in many

00:50:08,240 --> 00:50:13,970
places and accessibility think of

00:50:11,060 --> 00:50:18,850
accessibility is like wine they don't

00:50:13,970 --> 00:50:20,150
include colorblind or presbyopia or

00:50:18,850 --> 00:50:22,340
photosensitivity

00:50:20,150 --> 00:50:26,000
in the thing and what's the things they

00:50:22,340 --> 00:50:28,900
worry about so there's there's no fill

00:50:26,000 --> 00:50:32,090
of that gap what does he do and that

00:50:28,900 --> 00:50:34,930
quite frankly the question was regarding

00:50:32,090 --> 00:50:38,990
accessibility which is mentioned here

00:50:34,930 --> 00:50:42,890
whether cute except for caring for blind

00:50:38,990 --> 00:50:47,150
people also takes into account color

00:50:42,890 --> 00:50:49,610
blindness and other yeah issues I quite

00:50:47,150 --> 00:50:53,390
frankly can't answer that because I have

00:50:49,610 --> 00:50:55,310
not worked with the that yet but if you

00:50:53,390 --> 00:50:57,380
have any questions to their do contact

00:50:55,310 --> 00:51:00,260
federal at one he is the maintainer of

00:50:57,380 --> 00:51:03,710
the accessibility stack in cute and he

00:51:00,260 --> 00:51:05,570
cares very deeply about that so probably

00:51:03,710 --> 00:51:07,610
there are ways to get it done I know

00:51:05,570 --> 00:51:09,200
that in the KDE community which is very

00:51:07,610 --> 00:51:11,020
large and it's being used by many many

00:51:09,200 --> 00:51:13,550
people they are

00:51:11,020 --> 00:51:15,530
people that have these kind of issues so

00:51:13,550 --> 00:51:17,000
I don't know what they do there but I

00:51:15,530 --> 00:51:18,980
wouldn't be surprised if there's a

00:51:17,000 --> 00:51:19,340
solution to it but I can't tell you what

00:51:18,980 --> 00:51:38,600
it is

00:51:19,340 --> 00:51:42,290
sorry more questions okay the question

00:51:38,600 --> 00:51:46,880
is when we talk about cute quick that

00:51:42,290 --> 00:51:48,650
it's what here huemul and javascript and

00:51:46,880 --> 00:51:51,460
whether cute has the dependency on

00:51:48,650 --> 00:51:54,530
javascript right that was the question

00:51:51,460 --> 00:51:58,310
first let me put this straight you can

00:51:54,530 --> 00:51:58,790
use javascript in qml doesn't mean you

00:51:58,310 --> 00:52:01,490
should

00:51:58,790 --> 00:52:03,260
and for some places it's very handy to

00:52:01,490 --> 00:52:07,250
do so but you should keep it to a

00:52:03,260 --> 00:52:09,290
minimum and this is optional and you can

00:52:07,250 --> 00:52:11,390
for example use the cute script module

00:52:09,290 --> 00:52:14,690
it's again a separate module to get

00:52:11,390 --> 00:52:17,750
language bindings to JavaScript or use

00:52:14,690 --> 00:52:19,910
qml engine as a JavaScript engine to get

00:52:17,750 --> 00:52:21,950
language bindings you can do that but

00:52:19,910 --> 00:52:23,930
you don't have to in cute widgets for

00:52:21,950 --> 00:52:26,720
example you don't get any JavaScript at

00:52:23,930 --> 00:52:29,230
all does this answer your question okay

00:52:26,720 --> 00:52:29,230
thanks

00:52:29,410 --> 00:52:35,650
the question is whether you can use qml

00:52:31,940 --> 00:52:39,110
with just C++ yes I mean in the sense of

00:52:35,650 --> 00:52:41,630
you still write kml right this is not

00:52:39,110 --> 00:52:45,080
C++ and then all the rest the data and

00:52:41,630 --> 00:52:48,770
the logic is on C++ set this is the

00:52:45,080 --> 00:52:50,870
ideal case in my opinion quite often you

00:52:48,770 --> 00:52:53,090
will cut corners because it's just so

00:52:50,870 --> 00:52:56,180
much simpler to write one line of

00:52:53,090 --> 00:52:59,000
JavaScript instead of creating a C++

00:52:56,180 --> 00:53:02,270
function and then calling back and forth

00:52:59,000 --> 00:53:04,730
but most of the time yes you write the

00:53:02,270 --> 00:53:08,680
magnitude of code in logic in C++ and

00:53:04,730 --> 00:53:08,680
use qml just for the representation

00:53:12,860 --> 00:53:18,510
the question is what the output of the

00:53:15,300 --> 00:53:20,940
qml thing is it's actually a virtual

00:53:18,510 --> 00:53:26,040
machine machine so to say like by

00:53:20,940 --> 00:53:28,170
default it will produce binary

00:53:26,040 --> 00:53:30,450
code and then run that it's very

00:53:28,170 --> 00:53:32,160
efficient they spend a lot of effort in

00:53:30,450 --> 00:53:33,770
making it as fast as possible for this

00:53:32,160 --> 00:53:36,810
use case and it's very good at it

00:53:33,770 --> 00:53:39,090
there's also a commercial qml compiler

00:53:36,810 --> 00:53:41,640
it's a code to code transformer so it

00:53:39,090 --> 00:53:46,200
takes the Comal code and translates that

00:53:41,640 --> 00:53:49,440
into c++ which is then compiled by your

00:53:46,200 --> 00:53:52,050
compiler running all its optimizations

00:53:49,440 --> 00:53:54,030
on it and thereby creating even faster

00:53:52,050 --> 00:53:59,010
code with even less overhead and there's

00:53:54,030 --> 00:54:02,640
a sorry but qml compiler from the cute

00:53:59,010 --> 00:54:05,430
company and regarding the how to

00:54:02,640 --> 00:54:07,770
interact with qml and cute the

00:54:05,430 --> 00:54:10,260
documentation that Q has is very good

00:54:07,770 --> 00:54:13,770
you should have a look at that and they

00:54:10,260 --> 00:54:17,010
have lots of chapters on just that part

00:54:13,770 --> 00:54:19,230
like how to get data from C++ to qml and

00:54:17,010 --> 00:54:40,620
vice versa and there's support for that

00:54:19,230 --> 00:54:44,900
fair okay yes the question is about the

00:54:40,620 --> 00:54:47,280
Android support and whether the gap is

00:54:44,900 --> 00:54:48,600
reducing and what you can do on android

00:54:47,280 --> 00:54:51,570
compared to what you can do in other

00:54:48,600 --> 00:54:58,140
platforms especially widgets have been

00:54:51,570 --> 00:54:59,850
mentioned with OpenGL content I am again

00:54:58,140 --> 00:55:02,370
not the expert my colleague böck done

00:54:59,850 --> 00:55:04,710
would be the best person to ask there

00:55:02,370 --> 00:55:07,170
I'm pretty sure there has been a blog

00:55:04,710 --> 00:55:10,110
post maybe a few months ago and just

00:55:07,170 --> 00:55:13,470
that matter if I'm not mistaken on our

00:55:10,110 --> 00:55:16,140
website CARICOM slash block I think me

00:55:13,470 --> 00:55:19,170
and my colleagues put technical blocks

00:55:16,140 --> 00:55:22,340
there and he definitely had a very long

00:55:19,170 --> 00:55:24,530
series about Android and cute and

00:55:22,340 --> 00:55:27,050
I think he mentioned something there but

00:55:24,530 --> 00:55:28,220
again do content him directly or come to

00:55:27,050 --> 00:55:31,250
me afterwards and I'll get you the

00:55:28,220 --> 00:55:31,670
contact details does this answer your

00:55:31,250 --> 00:55:48,770
question

00:55:31,670 --> 00:55:50,930
oh sorry the question is how to figure

00:55:48,770 --> 00:55:55,460
out whether buck is fixed if you find it

00:55:50,930 --> 00:55:58,910
in 5.4 5.6 the answer is you look into

00:55:55,460 --> 00:56:02,480
the bug tracker there's it's open right

00:55:58,910 --> 00:56:04,220
it's you just either report the buck you

00:56:02,480 --> 00:56:04,970
find and then someone will try it out

00:56:04,220 --> 00:56:06,710
and say okay

00:56:04,970 --> 00:56:08,990
actually this is a duplicate this is

00:56:06,710 --> 00:56:11,720
here the main park and it's been fixed

00:56:08,990 --> 00:56:15,260
already alternatively you can go into

00:56:11,720 --> 00:56:17,030
Garrett or just get check out the latest

00:56:15,260 --> 00:56:20,240
and greatest and see whether the code

00:56:17,030 --> 00:56:22,460
has changed personally I really like

00:56:20,240 --> 00:56:24,620
this about cute it's open right you can

00:56:22,460 --> 00:56:27,500
actually look into what it is doing and

00:56:24,620 --> 00:56:29,360
if something goes wrong you go in there

00:56:27,500 --> 00:56:31,520
and either fix it yourself and submit a

00:56:29,360 --> 00:56:32,990
submit a patch or you check upstream

00:56:31,520 --> 00:56:35,540
whether it's been fixed already maybe

00:56:32,990 --> 00:56:38,450
you can even back port they fix then if

00:56:35,540 --> 00:56:42,350
you want to so yeah I would start with

00:56:38,450 --> 00:56:45,380
the the bug tracker if you use IRC

00:56:42,350 --> 00:56:48,170
there's also cute labs channel on or the

00:56:45,380 --> 00:56:49,850
cute channel on freenode where you can

00:56:48,170 --> 00:56:52,580
ask these kind of questions and people

00:56:49,850 --> 00:56:54,650
will help you out Stack Overflow is very

00:56:52,580 --> 00:56:56,720
active community there there are lots of

00:56:54,650 --> 00:56:58,640
mailing lists as well where people will

00:56:56,720 --> 00:57:01,640
help you out if you have any question

00:56:58,640 --> 00:57:04,160
there this is your channels and how to

00:57:01,640 --> 00:57:15,770
get in touch with us does this answer

00:57:04,160 --> 00:57:17,240
your question yeah okay show me one part

00:57:15,770 --> 00:57:19,340
of the UI and then I have to go further

00:57:17,240 --> 00:57:22,930
to see the second part in that same code

00:57:19,340 --> 00:57:22,930
that's the desktop show all of it

00:57:24,049 --> 00:57:29,660
that let me repeat the question as I got

00:57:27,259 --> 00:57:32,329
it and whether acute quick and qml

00:57:29,660 --> 00:57:34,339
supports storybuilder to adapt to

00:57:32,329 --> 00:57:37,339
different form factors in a sense that

00:57:34,339 --> 00:57:39,529
one screens only shown on a small

00:57:37,339 --> 00:57:43,099
display whereas multiple screens or

00:57:39,529 --> 00:57:46,999
content biases shown on the desktop for

00:57:43,099 --> 00:57:50,259
example if you mean with storybuilder

00:57:46,999 --> 00:57:53,059
some graphical application then no

00:57:50,259 --> 00:57:55,670
people from the automotive industry are

00:57:53,059 --> 00:57:58,249
investing money in improving cute

00:57:55,670 --> 00:58:01,309
tooling around these kind of things as

00:57:58,249 --> 00:58:03,709
far as I know but it's possible today to

00:58:01,309 --> 00:58:05,900
write qml code which automatically

00:58:03,709 --> 00:58:08,089
adapts to different form factors there's

00:58:05,900 --> 00:58:11,630
very good support for that for example

00:58:08,089 --> 00:58:15,829
to load different images based on the

00:58:11,630 --> 00:58:19,900
DPI or whatever to change the layout you

00:58:15,829 --> 00:58:23,779
can even here for example this kind of

00:58:19,900 --> 00:58:26,420
code could be a so-called component

00:58:23,779 --> 00:58:28,429
which you use in different files and you

00:58:26,420 --> 00:58:30,529
can load these components based on the

00:58:28,429 --> 00:58:33,410
DPI or resolution of your device right

00:58:30,529 --> 00:58:35,420
so you could have one component for a

00:58:33,410 --> 00:58:38,269
small form-factor in one component with

00:58:35,420 --> 00:58:39,920
slightly different code for larger

00:58:38,269 --> 00:58:42,709
screen and because it's so simple to

00:58:39,920 --> 00:58:46,999
write that it's actually working very

00:58:42,709 --> 00:58:49,579
well so does this answer your question

00:58:46,999 --> 00:58:52,509
ok so with that I have to come to an end

00:58:49,579 --> 00:58:52,509

YouTube URL: https://www.youtube.com/watch?v=RXTfC-35Nx8


