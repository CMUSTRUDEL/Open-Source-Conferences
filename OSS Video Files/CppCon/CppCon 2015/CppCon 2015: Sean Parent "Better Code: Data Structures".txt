Title: CppCon 2015: Sean Parent "Better Code: Data Structures"
Publication date: 2015-09-25
Playlist: CppCon 2015
Description: 
	http://www.cppcon.org
--
The standard library containers are often both misused and underused. Instead of creating new containers, applications are often structured with incidental data structures composed of objects referencing other object. This talk looks at some of the ways the standard containers can be better utilized and how creating (or using non-standard library) containers can greatly simplify code. The goal is no incidental data structures. 
--
Sean Parent is a principal scientist and software architect for Adobe’s mobile digital imaging group. Sean has been at Adobe since 1993 when he joined as a senior engineer working on Photoshop and later managed Adobe’s Software Technology Lab. In 2009 Sean spent a year at Google working on Chrome OS before returning to Adobe. From 1988 through 1993 Sean worked at Apple, where he was part of the system software team that developed the technologies allowing Apple’s successful transition to PowerPC.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,560
I'm Shawn parent I'm a principal

00:00:01,979 --> 00:00:08,910
scientist at Adobe Systems I've been

00:00:04,560 --> 00:00:10,200
there now just over 20 years so I've got

00:00:08,910 --> 00:00:13,519
a lot of things there lately I've been

00:00:10,200 --> 00:00:16,049
working on mobile digital imaging and

00:00:13,519 --> 00:00:19,590
some web-based digital imaging is pretty

00:00:16,049 --> 00:00:22,350
interesting work I gave a talk at the

00:00:19,590 --> 00:00:26,580
going native conference two years ago

00:00:22,350 --> 00:00:28,519
now that was entitled C++ seasoning how

00:00:26,580 --> 00:00:31,650
many people have seen the talk either

00:00:28,519 --> 00:00:34,140
wow yeah so lots of people have seen the

00:00:31,650 --> 00:00:36,570
talk it's like a hundred thousand views

00:00:34,140 --> 00:00:40,469
on them on the website now which is

00:00:36,570 --> 00:00:42,059
pretty stunning so it was very well

00:00:40,469 --> 00:00:45,350
received and a lot of people suggested

00:00:42,059 --> 00:00:49,110
that I write a book based off that talk

00:00:45,350 --> 00:00:51,840
so what I've done is I've started a book

00:00:49,110 --> 00:00:54,210
and I outline the chapters and each time

00:00:51,840 --> 00:00:57,030
I get invited to go give a talk I flesh

00:00:54,210 --> 00:00:58,649
out one of the chapters for the book so

00:00:57,030 --> 00:01:04,110
hopefully eventually this book will get

00:00:58,649 --> 00:01:05,489
written right now we are here now for

00:01:04,110 --> 00:01:07,409
people who have followed any of my talks

00:01:05,489 --> 00:01:09,350
I've done talks after this point and

00:01:07,409 --> 00:01:12,030
I've done talks before this point I

00:01:09,350 --> 00:01:14,760
haven't given this talk so I didn't I

00:01:12,030 --> 00:01:18,600
give the talk in the middle well it's a

00:01:14,760 --> 00:01:20,159
bridge talk kind of ties the start of

00:01:18,600 --> 00:01:21,869
the books towards the end of the book

00:01:20,159 --> 00:01:24,439
and I didn't think there was anything of

00:01:21,869 --> 00:01:28,530
particular interest to given this talk

00:01:24,439 --> 00:01:30,420
but last February I got invited to give

00:01:28,530 --> 00:01:33,799
a talk I gave a talk on concurrency as a

00:01:30,420 --> 00:01:37,950
keynote at meeting CPP in Moscow and

00:01:33,799 --> 00:01:41,880
after that John asked if I would repeat

00:01:37,950 --> 00:01:46,259
the talk at C++ now in Aspen I agreed

00:01:41,880 --> 00:01:48,689
and then a couple weeks before he sent

00:01:46,259 --> 00:01:51,060
me an email and said Shawn were short on

00:01:48,689 --> 00:01:56,430
tutorials and give that keynote as a

00:01:51,060 --> 00:01:57,930
tutorial so I obliged and I did and it

00:01:56,430 --> 00:02:01,759
worked out pretty well I got an award

00:01:57,930 --> 00:02:04,110
for best tutorial and most useful talk

00:02:01,759 --> 00:02:06,299
so then John asked could you give a talk

00:02:04,110 --> 00:02:08,520
at CPP con and I said well since they

00:02:06,299 --> 00:02:11,310
worked out for a tutorial this chapter

00:02:08,520 --> 00:02:13,230
would make a good tutorial talk so I

00:02:11,310 --> 00:02:13,920
proposed this talk and I get an email

00:02:13,230 --> 00:02:15,599
from John

00:02:13,920 --> 00:02:18,900
said we're very excited about your talk

00:02:15,599 --> 00:02:25,709
we're going to make it a keynote so

00:02:18,900 --> 00:02:28,349
thanks John so each chapter in this book

00:02:25,709 --> 00:02:30,959
to be written has a goal and the goal

00:02:28,349 --> 00:02:35,580
for this chapter is no incidental data

00:02:30,959 --> 00:02:37,380
structures and the word goal here is

00:02:35,580 --> 00:02:39,930
chosen very specifically this is a

00:02:37,380 --> 00:02:41,880
little different than guideline or rule

00:02:39,930 --> 00:02:44,670
or what you know what we've been talking

00:02:41,880 --> 00:02:47,850
about at some of the other keynote talks

00:02:44,670 --> 00:02:50,310
here in that a goal is something that

00:02:47,850 --> 00:02:54,180
can be very difficult to achieve right

00:02:50,310 --> 00:02:56,790
so if you've seen my C++ seasoning talk

00:02:54,180 --> 00:02:58,590
I have goals like no wrong lubes and all

00:02:56,790 --> 00:03:01,700
pointers you can go watch the talk if

00:02:58,590 --> 00:03:04,769
you want to know what that means okay

00:03:01,700 --> 00:03:06,959
but these are things that you strive and

00:03:04,769 --> 00:03:08,760
that you don't want to put down as a

00:03:06,959 --> 00:03:10,980
hard rule they're things that by

00:03:08,760 --> 00:03:13,560
striving to achieve them your code will

00:03:10,980 --> 00:03:18,299
get better so that's why I use the term

00:03:13,560 --> 00:03:22,530
goal but what is an incidental data

00:03:18,299 --> 00:03:24,390
structure okay to understand that we

00:03:22,530 --> 00:03:26,670
need to understand what is a data

00:03:24,390 --> 00:03:28,829
structure most of us have a pretty

00:03:26,670 --> 00:03:33,180
decent idea we're like well it's a list

00:03:28,829 --> 00:03:34,709
it's a vector it's a map I looked up the

00:03:33,180 --> 00:03:36,650
definition that's always a good thing to

00:03:34,709 --> 00:03:38,970
do if you want to know what something is

00:03:36,650 --> 00:03:41,150
definition is a data structure as a

00:03:38,970 --> 00:03:43,230
format for organizing and storing data

00:03:41,150 --> 00:03:45,720
I'm not sure that I agree completely

00:03:43,230 --> 00:03:47,670
with the and storing data part right a

00:03:45,720 --> 00:03:49,530
data structure can be just a format for

00:03:47,670 --> 00:03:51,390
organizing data you don't necessarily

00:03:49,530 --> 00:03:53,970
have to store the data inside the data

00:03:51,390 --> 00:03:58,709
structure but that's not a bad

00:03:53,970 --> 00:04:00,660
definition but in some ways it's a

00:03:58,709 --> 00:04:01,530
little unsatisfactory because it really

00:04:00,660 --> 00:04:05,160
doesn't tell us what we mean by

00:04:01,530 --> 00:04:09,269
formatting and organizing to understand

00:04:05,160 --> 00:04:12,540
that we need to understand what is a

00:04:09,269 --> 00:04:16,100
structure okay we can look up the

00:04:12,540 --> 00:04:19,280
definition of it right

00:04:16,100 --> 00:04:24,590
a structure is basically things that are

00:04:19,280 --> 00:04:27,530
related to other things okay so how many

00:04:24,590 --> 00:04:32,000
people here have architect in their

00:04:27,530 --> 00:04:34,940
title a few yeah software architect some

00:04:32,000 --> 00:04:40,840
way right what an architect does is an

00:04:34,940 --> 00:04:43,310
architect designs structures right so

00:04:40,840 --> 00:04:45,380
what that means is an architect is

00:04:43,310 --> 00:04:47,690
concerned about the relationships in the

00:04:45,380 --> 00:04:51,010
software from one component to another

00:04:47,690 --> 00:04:54,020
that's what an architect does and

00:04:51,010 --> 00:04:57,410
there's a problem here the problem is

00:04:54,020 --> 00:04:59,800
that computer scientists are very bad at

00:04:57,410 --> 00:04:59,800
relationships

00:05:00,880 --> 00:05:11,440
we just are okay so

00:05:13,720 --> 00:05:21,230
this slide represents nothing and I mean

00:05:17,570 --> 00:05:24,139
literally nothing it's wait there is no

00:05:21,230 --> 00:05:27,590
dimension here there is no width there

00:05:24,139 --> 00:05:29,780
is no height there is no time this is a

00:05:27,590 --> 00:05:32,300
dimensionless space if there could be

00:05:29,780 --> 00:05:38,630
such a thing right it is a mythical

00:05:32,300 --> 00:05:40,060
Haskel space okay within this space we

00:05:38,630 --> 00:05:43,310
have four bits

00:05:40,060 --> 00:05:49,540
those bits have always been there they

00:05:43,310 --> 00:05:49,540
will always be there and those bits

00:05:50,230 --> 00:05:59,860
represent four bananas that's what they

00:05:54,470 --> 00:06:03,050
mean or maybe they mean the color blue

00:05:59,860 --> 00:06:06,680
or maybe they just mean for an abstract

00:06:03,050 --> 00:06:09,710
for okay the reason why they mean that

00:06:06,680 --> 00:06:13,669
is because I said they mean that because

00:06:09,710 --> 00:06:15,770
I think they mean that okay that's a

00:06:13,669 --> 00:06:18,650
semantic relationship okay

00:06:15,770 --> 00:06:25,550
those bits have a relationship with the

00:06:18,650 --> 00:06:31,100
entity of four there's another

00:06:25,550 --> 00:06:38,380
relationship here okay those four bits

00:06:31,100 --> 00:06:43,220
collectively have a form a type they are

00:06:38,380 --> 00:06:45,289
related to a range negative eight to

00:06:43,220 --> 00:06:48,710
seven I bet a bunch of you thought they

00:06:45,289 --> 00:06:52,340
were unsigned right yeah but they're not

00:06:48,710 --> 00:06:58,669
why not because I said so okay this is

00:06:52,340 --> 00:07:03,770
my universe these relationships are

00:06:58,669 --> 00:07:07,700
incredibly important when we heard talks

00:07:03,770 --> 00:07:11,810
earlier and we were in herbes keynote he

00:07:07,700 --> 00:07:14,870
mentioned type safety lifetime safety

00:07:11,810 --> 00:07:16,780
bound safety what we're talking about

00:07:14,870 --> 00:07:20,180
when we talk about those things is

00:07:16,780 --> 00:07:22,280
maintaining this relationship okay if we

00:07:20,180 --> 00:07:23,090
lose the semantic relationship on our

00:07:22,280 --> 00:07:26,530
type

00:07:23,090 --> 00:07:31,040
the universe unravels missiles launch

00:07:26,530 --> 00:07:34,190
it's really bad okay we also have a

00:07:31,040 --> 00:07:37,460
notion of value safety right which is

00:07:34,190 --> 00:07:41,570
whether or not those bits zero one zero

00:07:37,460 --> 00:07:46,760
zero represent our four right if we lose

00:07:41,570 --> 00:07:50,540
that relationship right then we have

00:07:46,760 --> 00:07:55,639
lost value safety so when we lose that

00:07:50,540 --> 00:07:58,729
we say our value became invalid now the

00:07:55,639 --> 00:08:03,010
standard the C++ standard actually uses

00:07:58,729 --> 00:08:06,620
the term valid in two different ways

00:08:03,010 --> 00:08:11,270
okay in the first sense is talking about

00:08:06,620 --> 00:08:15,710
iterator validity so if I have an

00:08:11,270 --> 00:08:18,500
iterator and it points into a vector and

00:08:15,710 --> 00:08:21,590
I do a push back on my vector the vector

00:08:18,500 --> 00:08:24,139
might move and my iterator becomes

00:08:21,590 --> 00:08:26,810
invalid okay that's what the standard

00:08:24,139 --> 00:08:30,169
says the bits in that iterator didn't

00:08:26,810 --> 00:08:32,330
change what happened is the relationship

00:08:30,169 --> 00:08:36,890
that that iterator has with the vector

00:08:32,330 --> 00:08:39,050
was severed its meaning was lost it's

00:08:36,890 --> 00:08:41,120
now an invalid object the only thing

00:08:39,050 --> 00:08:42,620
that you can do with that invalid object

00:08:41,120 --> 00:08:44,810
right the type does not invalid it's

00:08:42,620 --> 00:08:46,790
still an iterator but its value is

00:08:44,810 --> 00:08:49,070
invalid the only thing that you can do

00:08:46,790 --> 00:08:51,230
that an invalid iterator is either

00:08:49,070 --> 00:08:53,540
restore meaning to it by assigning a

00:08:51,230 --> 00:08:57,860
value into it or letting it go and

00:08:53,540 --> 00:09:02,120
destructing it now the other way that

00:08:57,860 --> 00:09:06,410
the standard uses the term valid is in

00:09:02,120 --> 00:09:09,080
talking about the state of an object

00:09:06,410 --> 00:09:11,240
after it's been moved from or with the

00:09:09,080 --> 00:09:13,790
basic exception guarantee after an

00:09:11,240 --> 00:09:16,580
exception has been thrown and there the

00:09:13,790 --> 00:09:23,779
standard says that the value within the

00:09:16,580 --> 00:09:27,140
object is valid but unspecified that's a

00:09:23,779 --> 00:09:31,070
contradiction okay if it's unspecified

00:09:27,140 --> 00:09:33,520
it has lost its semantic relationship it

00:09:31,070 --> 00:09:36,280
is no longer a valid value

00:09:33,520 --> 00:09:38,260
okay it's type is still valid but that's

00:09:36,280 --> 00:09:40,840
a given just like an iterator type is

00:09:38,260 --> 00:09:43,810
still valid okay so these are somewhat

00:09:40,840 --> 00:09:45,550
contradictory senses so when we say with

00:09:43,810 --> 00:09:49,350
the exception basic exception guarantee

00:09:45,550 --> 00:09:55,900
or the state from a move from object

00:09:49,350 --> 00:09:58,000
that object is now invalid okay because

00:09:55,900 --> 00:09:59,950
it's lost that semantics relationship

00:09:58,000 --> 00:10:01,930
and the only thing meaningfully that we

00:09:59,950 --> 00:10:04,900
can do to it is we can establish a new

00:10:01,930 --> 00:10:07,420
value in its place with meaning or we

00:10:04,900 --> 00:10:08,770
can let it go and destruct it if you're

00:10:07,420 --> 00:10:10,630
familiar with the book elements of

00:10:08,770 --> 00:10:12,670
programming for malloc Stepanov he

00:10:10,630 --> 00:10:17,860
refers to an object and such in such a

00:10:12,670 --> 00:10:20,200
state is being partially formed so these

00:10:17,860 --> 00:10:22,420
are very important relationships right

00:10:20,200 --> 00:10:24,460
so when we talk about safety in

00:10:22,420 --> 00:10:27,640
programming what we mean by a safe

00:10:24,460 --> 00:10:30,430
operation is an operation that maintains

00:10:27,640 --> 00:10:33,640
the semantics relationship an unsafe

00:10:30,430 --> 00:10:36,910
operation is an operation that may sever

00:10:33,640 --> 00:10:39,610
the semantics relationship okay when we

00:10:36,910 --> 00:10:42,340
talk about invariants on a type what we

00:10:39,610 --> 00:10:47,620
mean are the properties that must hold

00:10:42,340 --> 00:10:52,930
in order for this value to remain valid

00:10:47,620 --> 00:10:59,500
to maintain its meaning okay everybody

00:10:52,930 --> 00:11:01,900
following that now we can have two

00:10:59,500 --> 00:11:04,360
objects within our universe here that

00:11:01,900 --> 00:11:10,810
have the same type and map into the same

00:11:04,360 --> 00:11:13,960
space and that allows us to establish a

00:11:10,810 --> 00:11:15,640
value relationship okay this is another

00:11:13,960 --> 00:11:19,150
type of relationship between those two

00:11:15,640 --> 00:11:21,250
things 4 is less than 3 that's a

00:11:19,150 --> 00:11:28,170
mathematical structure right it's a

00:11:21,250 --> 00:11:30,820
value-based structure we can also

00:11:28,170 --> 00:11:33,100
establish a relationship on just the

00:11:30,820 --> 00:11:35,590
representation right we just have these

00:11:33,100 --> 00:11:37,540
bits in memory we can hash the bits and

00:11:35,590 --> 00:11:41,530
we can talk about the bits being equal

00:11:37,540 --> 00:11:44,990
or not equal the reason why hash has

00:11:41,530 --> 00:11:47,649
meaning is because of the relationship

00:11:44,990 --> 00:11:50,300
that if two objects have the same

00:11:47,649 --> 00:11:52,940
representation then they represent the

00:11:50,300 --> 00:11:54,980
same value okay so we are now

00:11:52,940 --> 00:11:57,800
associating a representational

00:11:54,980 --> 00:11:59,810
relationship their hash with the value

00:11:57,800 --> 00:12:02,480
relationship and that's how we get

00:11:59,810 --> 00:12:04,790
meaning on hash now the converse is not

00:12:02,480 --> 00:12:06,320
necessarily true just because the hashes

00:12:04,790 --> 00:12:13,370
are equal doesn't mean the values are

00:12:06,320 --> 00:12:17,330
equal but we don't live in this mythical

00:12:13,370 --> 00:12:22,089
space we live in this space we live

00:12:17,330 --> 00:12:25,610
within an address space and what makes

00:12:22,089 --> 00:12:27,950
the four zero one zero zero in the

00:12:25,610 --> 00:12:32,060
middle they're different from those bits

00:12:27,950 --> 00:12:34,850
at the top is that those bits have no

00:12:32,060 --> 00:12:38,870
semantic meaning because I didn't give

00:12:34,850 --> 00:12:43,880
them any okay so if I have an integer on

00:12:38,870 --> 00:12:46,310
the stack and it's uninitialized right

00:12:43,880 --> 00:12:49,760
that is an object in a partially formed

00:12:46,310 --> 00:12:51,110
state it has no meaning the only thing

00:12:49,760 --> 00:12:54,610
that I can do to it is assign a new

00:12:51,110 --> 00:13:02,480
value to it to give it meaning right or

00:12:54,610 --> 00:13:05,540
let it destruct now my object within a

00:13:02,480 --> 00:13:07,850
space has a relationship with the space

00:13:05,540 --> 00:13:11,170
it's the address of the object and

00:13:07,850 --> 00:13:14,480
that's both spatial and temporal

00:13:11,170 --> 00:13:19,040
relationship right this object is here

00:13:14,480 --> 00:13:21,560
now okay so where did John go John in

00:13:19,040 --> 00:13:26,360
the audience here John's back here

00:13:21,560 --> 00:13:34,040
I think where's Marshall Marshalls back

00:13:26,360 --> 00:13:37,370
here so John and Marshall are involved

00:13:34,040 --> 00:13:39,470
in a relationship okay normally you

00:13:37,370 --> 00:13:42,649
would call this a structural

00:13:39,470 --> 00:13:44,089
relationship but since we're defining

00:13:42,649 --> 00:13:45,170
structure that's a bad term for this

00:13:44,089 --> 00:13:48,339
talk so I'm going to call this a

00:13:45,170 --> 00:13:48,339
physical relationship

00:13:48,620 --> 00:13:55,040
so John and Marshall are involved in a

00:13:51,230 --> 00:14:00,340
physical relationship see I'm getting

00:13:55,040 --> 00:14:00,340
back at John right apologies to Marshall

00:14:01,390 --> 00:14:07,550
now you guys laugh but you're all

00:14:05,660 --> 00:14:10,940
involved in a physical relationship

00:14:07,550 --> 00:14:14,860
she's a little scary okay that

00:14:10,940 --> 00:14:20,500
relationship has no meaning

00:14:14,860 --> 00:14:20,500
okay okay for some of you maybe it does

00:14:21,340 --> 00:14:28,040
okay these two items are involved in a

00:14:25,940 --> 00:14:30,260
physical relationship the address of the

00:14:28,040 --> 00:14:33,890
first object is less than the address of

00:14:30,260 --> 00:14:39,340
the other object that in and of itself

00:14:33,890 --> 00:14:44,500
has no meaning okay but we can ascribe

00:14:39,340 --> 00:14:46,670
meaning to it by sorting our objects and

00:14:44,500 --> 00:14:49,520
now what we've done is we've established

00:14:46,670 --> 00:14:53,060
the correlation between the values and

00:14:49,520 --> 00:14:55,430
between their physical location and that

00:14:53,060 --> 00:14:58,820
lets us associate meaning with their

00:14:55,430 --> 00:15:02,270
physical location okay this is an

00:14:58,820 --> 00:15:04,430
important property of having objects

00:15:02,270 --> 00:15:06,050
within an address space this is

00:15:04,430 --> 00:15:09,230
something that we can exploit when we're

00:15:06,050 --> 00:15:11,150
building software right there's a lot of

00:15:09,230 --> 00:15:14,180
languages that would like to ignore the

00:15:11,150 --> 00:15:16,640
fact that objects have physical

00:15:14,180 --> 00:15:21,410
relationships right we refer to those as

00:15:16,640 --> 00:15:23,230
the puritan languages right right we all

00:15:21,410 --> 00:15:26,860
know the physical relationships exist

00:15:23,230 --> 00:15:26,860
but they're being ignored

00:15:29,140 --> 00:15:32,900
now there is another possible

00:15:31,130 --> 00:15:34,970
relationship here if we take one of the

00:15:32,900 --> 00:15:38,510
mathematical relationships associated

00:15:34,970 --> 00:15:42,680
with our value and we associate it with

00:15:38,510 --> 00:15:48,290
a function we get a functional

00:15:42,680 --> 00:15:51,140
relationship okay so here we can add our

00:15:48,290 --> 00:15:52,930
two numbers we get seven as our result

00:15:51,140 --> 00:15:55,430
so that's a functional relationship

00:15:52,930 --> 00:15:57,620
functional relationships form dependency

00:15:55,430 --> 00:15:59,980
graphs and if you want to know more

00:15:57,620 --> 00:16:02,870
about that a little bit more anyways

00:15:59,980 --> 00:16:05,300
look up my concurrency talk I'm not

00:16:02,870 --> 00:16:07,580
going to talk too much about dependency

00:16:05,300 --> 00:16:10,460
graphs in this talk but I will mention

00:16:07,580 --> 00:16:12,200
that if we were adding two values that

00:16:10,460 --> 00:16:16,570
overflowed right remember these were

00:16:12,200 --> 00:16:20,000
signed values my result is unspecified

00:16:16,570 --> 00:16:22,640
right right what does that mean it means

00:16:20,000 --> 00:16:25,010
that my value in my result has no

00:16:22,640 --> 00:16:29,290
semantic relationship so this comes up

00:16:25,010 --> 00:16:29,290
over and over and over again right

00:16:30,640 --> 00:16:35,870
there's one more relationship that's a

00:16:34,010 --> 00:16:38,660
particular interest that I want to talk

00:16:35,870 --> 00:16:41,360
about and this is the whole part

00:16:38,660 --> 00:16:45,020
relationship this is defined in Chapter

00:16:41,360 --> 00:16:46,850
12 of yo P okay the whole part

00:16:45,020 --> 00:16:49,880
relationship is what allows us to talk

00:16:46,850 --> 00:16:52,640
about composite objects a whole part

00:16:49,880 --> 00:16:55,310
relationship has four properties to it

00:16:52,640 --> 00:16:57,380
the first property is connected and what

00:16:55,310 --> 00:16:59,900
that means is that if I have an object

00:16:57,380 --> 00:17:04,130
that's a part of another object that I

00:16:59,900 --> 00:17:06,260
can reach that part from the whole okay

00:17:04,130 --> 00:17:08,900
so if you have an automobile like a

00:17:06,260 --> 00:17:11,060
Honda Civic and you have a part of your

00:17:08,900 --> 00:17:16,250
Honda the part is connected to your

00:17:11,060 --> 00:17:17,780
Honda the second is non circular and I

00:17:16,250 --> 00:17:19,520
don't mean in the sense that back

00:17:17,780 --> 00:17:21,530
pointers are disallowed I mean that

00:17:19,520 --> 00:17:27,020
something cannot be a part of itself

00:17:21,530 --> 00:17:29,170
either directly or indirectly okay so no

00:17:27,020 --> 00:17:33,020
circular part relationships

00:17:29,170 --> 00:17:34,940
the third is logically disjoint again

00:17:33,020 --> 00:17:38,420
what I don't mean is that I

00:17:34,940 --> 00:17:39,920
can't have an object that is shared by

00:17:38,420 --> 00:17:41,840
two other objects but what I mean by

00:17:39,920 --> 00:17:43,910
logically disjoint is that if I change

00:17:41,840 --> 00:17:45,920
one object it cannot change the other

00:17:43,910 --> 00:17:48,190
object okay

00:17:45,920 --> 00:17:51,800
so there's kind of no mutable sharing

00:17:48,190 --> 00:17:56,060
that can be allowed so we don't have

00:17:51,800 --> 00:17:59,080
that and the third relationship third

00:17:56,060 --> 00:18:02,390
property of this relationship is

00:17:59,080 --> 00:18:04,400
ownership and what that means is that if

00:18:02,390 --> 00:18:07,550
I make a copy of the object it makes a

00:18:04,400 --> 00:18:12,110
copy of all the parts and I get two of

00:18:07,550 --> 00:18:14,570
them and if I destruct one it gets rid

00:18:12,110 --> 00:18:17,930
of that object and all of its parts okay

00:18:14,570 --> 00:18:18,800
those are two distinct disjoint objects

00:18:17,930 --> 00:18:21,620
if you've ever heard the term

00:18:18,800 --> 00:18:24,050
regular-type these are the properties

00:18:21,620 --> 00:18:29,600
that allow a composite object to behave

00:18:24,050 --> 00:18:31,610
like a regular type okay all the

00:18:29,600 --> 00:18:38,360
standard containers vectors lists things

00:18:31,610 --> 00:18:48,730
like that are composite objects so let's

00:18:38,360 --> 00:18:52,270
go back what is a structure right so a

00:18:48,730 --> 00:18:55,300
data structure is a structure utilizing

00:18:52,270 --> 00:18:57,470
value physical structural and

00:18:55,300 --> 00:18:59,930
representational relationships to encode

00:18:57,470 --> 00:19:03,830
semantic relationships on a collection

00:18:59,930 --> 00:19:05,900
of objects and the choice of encoding

00:19:03,830 --> 00:19:08,240
can make a dramatic difference in the

00:19:05,900 --> 00:19:11,510
performance of operations on these

00:19:08,240 --> 00:19:14,750
objects right and we know that right we

00:19:11,510 --> 00:19:16,970
know that that if I have a linked list

00:19:14,750 --> 00:19:19,130
that iterating over the link that

00:19:16,970 --> 00:19:21,980
indexing into the linked list is linear

00:19:19,130 --> 00:19:24,680
time and inserting into it is constant

00:19:21,980 --> 00:19:27,260
time and if I have a vector it's the

00:19:24,680 --> 00:19:29,270
reverse of that iterating over it or

00:19:27,260 --> 00:19:31,310
indexing into it is constant time

00:19:29,270 --> 00:19:33,740
inserting it into it is linear time

00:19:31,310 --> 00:19:35,040
right right and we know that I can have

00:19:33,740 --> 00:19:38,450
a map where I can look up

00:19:35,040 --> 00:19:41,460
long again and we know that I can have a

00:19:38,450 --> 00:19:43,800
closed hash map and get something close

00:19:41,460 --> 00:19:47,880
to constant time on a lookup we know

00:19:43,800 --> 00:19:50,820
these things something that I think a

00:19:47,880 --> 00:19:52,530
lot of people don't realize is how big

00:19:50,820 --> 00:19:55,110
of an impact these days the memory

00:19:52,530 --> 00:19:58,050
memory hierarchy has on the performance

00:19:55,110 --> 00:19:59,910
of data structures so I stole these

00:19:58,050 --> 00:20:01,530
numbers they actually come from Jeff

00:19:59,910 --> 00:20:04,710
Dean but I stole them out of a slide

00:20:01,530 --> 00:20:11,220
from shandler Jeff Dean also has a talk

00:20:04,710 --> 00:20:14,100
that's available online so these are the

00:20:11,220 --> 00:20:15,720
times on a typical desktop machine to

00:20:14,100 --> 00:20:17,880
access different pieces of memory

00:20:15,720 --> 00:20:20,820
there's basically an order of magnitude

00:20:17,880 --> 00:20:23,610
difference between each level in the

00:20:20,820 --> 00:20:26,700
memory hierarchy okay so by the time you

00:20:23,610 --> 00:20:31,110
get down to main memory it takes you 200

00:20:26,700 --> 00:20:34,070
more 200 times as much time to get to

00:20:31,110 --> 00:20:37,200
something as it does out of l1 cache

00:20:34,070 --> 00:20:40,110
that's huge when I started programming

00:20:37,200 --> 00:20:44,880
this was not the case not at all it was

00:20:40,110 --> 00:20:51,840
much more one-to-one on a modern machine

00:20:44,880 --> 00:20:55,380
Ram behaves much like a disk drive ok to

00:20:51,840 --> 00:21:00,690
put this in perspective log of a

00:20:55,380 --> 00:21:02,850
trillion is 40 ok so an algorithm that's

00:21:00,690 --> 00:21:07,770
n log n versus an algorithm that's

00:21:02,850 --> 00:21:12,480
linear ok can have can be more impacted

00:21:07,770 --> 00:21:16,680
on its performance by locality of the

00:21:12,480 --> 00:21:25,380
objects than by the Big O notation on

00:21:16,680 --> 00:21:29,370
the algorithm so locality matters use

00:21:25,380 --> 00:21:31,050
arrays use vectors when I was

00:21:29,370 --> 00:21:37,850
researching this talk I stumbled across

00:21:31,050 --> 00:21:41,090
an old post on lambda the ultimate that

00:21:37,850 --> 00:21:42,800
was citing the talk the person who

00:21:41,090 --> 00:21:44,930
who wrote this piece said it was either

00:21:42,800 --> 00:21:46,610
a talk that I had given or that Chris

00:21:44,930 --> 00:21:50,090
Cox who's a member of the Photoshop team

00:21:46,610 --> 00:21:53,750
had given I don't recall saying that in

00:21:50,090 --> 00:21:55,430
the talks all attributed to Chris but

00:21:53,750 --> 00:21:57,200
that the Photoshop application the

00:21:55,430 --> 00:22:00,980
number one data structure used in the

00:21:57,200 --> 00:22:03,110
application was vectors and the person

00:22:00,980 --> 00:22:04,940
on lambda the ultimate concluded that

00:22:03,110 --> 00:22:07,270
Photoshop had no interesting

00:22:04,940 --> 00:22:11,420
relationships within the application

00:22:07,270 --> 00:22:18,500
this is not the case okay the case is

00:22:11,420 --> 00:22:22,460
that the team understands performance so

00:22:18,500 --> 00:22:24,910
I want to give some examples here first

00:22:22,460 --> 00:22:32,600
example is utilizing parallel arrays

00:22:24,910 --> 00:22:36,290
with algorithms okay

00:22:32,600 --> 00:22:39,620
if you saw my C++ seasoning talk there

00:22:36,290 --> 00:22:41,750
was a I gave an example of an algorithm

00:22:39,620 --> 00:22:42,260
called gather which comes from Marshall

00:22:41,750 --> 00:22:46,880
Clos

00:22:42,260 --> 00:22:51,470
they uses two instances of stable

00:22:46,880 --> 00:22:54,350
partition in an interesting way I gave

00:22:51,470 --> 00:22:55,700
that talk and after that talk I went out

00:22:54,350 --> 00:22:57,620
to dinner and I was chatting with

00:22:55,700 --> 00:22:59,930
somebody at dinner I'm sorry I don't

00:22:57,620 --> 00:23:01,670
recall who it was who said I really

00:22:59,930 --> 00:23:03,980
liked your talk but you really cherry

00:23:01,670 --> 00:23:06,290
picked that example I think somebody

00:23:03,980 --> 00:23:09,410
here repeated kind of the gathering

00:23:06,290 --> 00:23:13,910
slide algorithms from from that talk in

00:23:09,410 --> 00:23:16,040
one of their talks and I said what he I

00:23:13,910 --> 00:23:18,590
said you know it was a talk so certainly

00:23:16,040 --> 00:23:20,030
I cherry picked but I didn't it wasn't

00:23:18,590 --> 00:23:21,830
that big of a stretch and he said well

00:23:20,030 --> 00:23:25,280
algorithms in real life are very

00:23:21,830 --> 00:23:27,530
complicated okay and I said for example

00:23:25,280 --> 00:23:34,250
he said for example you can't write

00:23:27,530 --> 00:23:37,550
stable partition simply yes I can okay

00:23:34,250 --> 00:23:41,300
so so what's stable partition right

00:23:37,550 --> 00:23:43,220
stable partition is you take all the

00:23:41,300 --> 00:23:46,010
good guys all the selected guys you have

00:23:43,220 --> 00:23:50,090
some predicate that Marx guys and you

00:23:46,010 --> 00:23:52,640
move them all to the front all the good

00:23:50,090 --> 00:23:53,750
guys go to the front and all the bad

00:23:52,640 --> 00:23:55,610
guys go to the back

00:23:53,750 --> 00:23:58,700
and it's stable because their relative

00:23:55,610 --> 00:24:02,420
order doesn't change okay so that's

00:23:58,700 --> 00:24:06,920
stable partition so we're going to write

00:24:02,420 --> 00:24:15,530
stable partition okay anybody know where

00:24:06,920 --> 00:24:16,760
to start Wow standard library we have

00:24:15,530 --> 00:24:24,410
stable partition but we're going to

00:24:16,760 --> 00:24:25,820
write it for a reason okay so what if we

00:24:24,410 --> 00:24:29,330
cut our space in half

00:24:25,820 --> 00:24:32,510
and somehow magically we were able to

00:24:29,330 --> 00:24:33,650
stable partition both of the halves we

00:24:32,510 --> 00:24:35,510
still don't have a right stable

00:24:33,650 --> 00:24:39,950
partition but we're just going to assume

00:24:35,510 --> 00:24:41,750
that we could do that okay by just

00:24:39,950 --> 00:24:43,600
calling stable partition two times we

00:24:41,750 --> 00:24:46,360
still need to write stable partition oh

00:24:43,600 --> 00:24:51,020
but this would work if we could do it

00:24:46,360 --> 00:24:53,480
okay now what do we have to do to get

00:24:51,020 --> 00:24:58,790
the good guys to the top and the bad

00:24:53,480 --> 00:25:02,380
guys down to the bottom right that range

00:24:58,790 --> 00:25:02,380
in the right order

00:25:04,060 --> 00:25:10,010
anybody know there's an algorithm for

00:25:06,080 --> 00:25:15,510
this rotate this is rotate my favorite

00:25:10,010 --> 00:25:24,670
algorithm so we rotate

00:25:15,510 --> 00:25:26,770
okay okay so we can do that and rotate

00:25:24,670 --> 00:25:28,420
is going to return the new midpoint

00:25:26,770 --> 00:25:32,830
that's our partition point so that's

00:25:28,420 --> 00:25:37,690
very handy okay so we can just return

00:25:32,830 --> 00:25:39,550
that out of our function so now all we

00:25:37,690 --> 00:25:40,930
need is an inductive basis where does

00:25:39,550 --> 00:25:43,210
this thing bottom out if we just

00:25:40,930 --> 00:25:45,490
recursing down just keep recursing down

00:25:43,210 --> 00:25:48,400
okay we can purse all the way down on

00:25:45,490 --> 00:25:50,170
tree what we're going to end up with one

00:25:48,400 --> 00:25:54,610
element which is either selected or not

00:25:50,170 --> 00:25:57,300
selected okay so we're going to apply a

00:25:54,610 --> 00:26:03,490
predicate to it and we're going to

00:25:57,300 --> 00:26:06,130
return I are there if it's selected okay

00:26:03,490 --> 00:26:07,740
so we're going to move F down or we're

00:26:06,130 --> 00:26:10,030
just going to return wherever F was

00:26:07,740 --> 00:26:13,030
right right so we're just going to add a

00:26:10,030 --> 00:26:19,690
zero or one to our location and that's

00:26:13,030 --> 00:26:21,280
our inductive basis okay so now we can

00:26:19,690 --> 00:26:23,020
put a little boilerplate around it we

00:26:21,280 --> 00:26:25,720
need to calculate how many elements we

00:26:23,020 --> 00:26:27,280
have we need to handle the zero case and

00:26:25,720 --> 00:26:33,010
we need to divide to get our midpoint

00:26:27,280 --> 00:26:37,240
and that stable partition we can execute

00:26:33,010 --> 00:26:40,120
that and it will do that okay people

00:26:37,240 --> 00:26:42,700
following that okay so it's pretty

00:26:40,120 --> 00:26:45,790
simple okay and in fact if you look at

00:26:42,700 --> 00:26:48,040
all the stl at the actual

00:26:45,790 --> 00:26:50,680
implementations what you see is pretty

00:26:48,040 --> 00:26:53,260
much everything in STL is a building

00:26:50,680 --> 00:27:00,880
block to build one algorithm just stable

00:26:53,260 --> 00:27:02,260
sort okay so rotate if people aren't

00:27:00,880 --> 00:27:05,500
aware the easiest way to implement

00:27:02,260 --> 00:27:09,580
rotate is three reverses okay

00:27:05,500 --> 00:27:12,010
so you can right rotate there's enough

00:27:09,580 --> 00:27:15,610
is an interesting thing there which is

00:27:12,010 --> 00:27:18,460
you can also write reverse in terms of

00:27:15,610 --> 00:27:23,080
rotate and if you do you get you can get

00:27:18,460 --> 00:27:23,830
an N log n version of reverse that works

00:27:23,080 --> 00:27:26,409
on forward

00:27:23,830 --> 00:27:32,080
generators that's left it as an exercise

00:27:26,409 --> 00:27:34,860
to you guys now there's something very

00:27:32,080 --> 00:27:38,590
interesting here in this piece of code

00:27:34,860 --> 00:27:43,630
the only place where our predicate is

00:27:38,590 --> 00:27:47,710
applied is one time to each object

00:27:43,630 --> 00:27:49,510
before that objects been moved okay so

00:27:47,710 --> 00:27:52,419
we're going to go all the way down to

00:27:49,510 --> 00:27:55,720
the bottom of our tree read each object

00:27:52,419 --> 00:28:00,940
exactly one time and then put everything

00:27:55,720 --> 00:28:02,350
back together how we wanted that's an

00:28:00,940 --> 00:28:04,360
amazing property and you probably

00:28:02,350 --> 00:28:06,630
wouldn't suspect that if you didn't know

00:28:04,360 --> 00:28:09,519
the implementation of stable partition

00:28:06,630 --> 00:28:11,380
okay and what that means is that we can

00:28:09,519 --> 00:28:15,539
get an interesting algorithm out of this

00:28:11,380 --> 00:28:18,760
algorithm by just removing that star

00:28:15,539 --> 00:28:22,210
okay so we can call this stable

00:28:18,760 --> 00:28:26,200
partition position right what this

00:28:22,210 --> 00:28:30,779
allows us to do is our predicate can now

00:28:26,200 --> 00:28:30,779
be a projection based off the position

00:28:32,100 --> 00:28:38,409
okay so let's call it let's see what I

00:28:35,830 --> 00:28:43,389
mean here right so I've got an array of

00:28:38,409 --> 00:28:46,990
integers at the top 1 2 3 4 5 5 4 3 2 1

00:28:43,389 --> 00:28:51,130
and I've got a boolean mask underneath

00:28:46,990 --> 00:28:55,480
that that happens to have a one true bit

00:28:51,130 --> 00:28:59,289
underneath every even value okay those

00:28:55,480 --> 00:29:02,289
are two parallel arrays and what I want

00:28:59,289 --> 00:29:04,799
to do is organize a so that all the even

00:29:02,289 --> 00:29:07,990
guys all the selected guys are up front

00:29:04,799 --> 00:29:11,049
maintaining the relative order and all

00:29:07,990 --> 00:29:14,740
the odd guys are at the end maintaining

00:29:11,049 --> 00:29:17,529
their their order and I can do that with

00:29:14,740 --> 00:29:18,669
the stable partition position okay so

00:29:17,529 --> 00:29:20,289
that's what it will print right I

00:29:18,669 --> 00:29:23,440
stopped in the middle there to put it

00:29:20,289 --> 00:29:28,230
out so the result what is in our a after

00:29:23,440 --> 00:29:30,850
we execute that is 2 4 4 2 1 3 5 5 31

00:29:28,230 --> 00:29:32,440
right my predicate there is a projection

00:29:30,850 --> 00:29:37,030
from a

00:29:32,440 --> 00:29:41,080
position in a into a position in B okay

00:29:37,030 --> 00:29:42,790
so if you saw my talk on what you can do

00:29:41,080 --> 00:29:45,010
with stable partition as far as gather

00:29:42,790 --> 00:29:47,410
within a UI I can have a bunch of

00:29:45,010 --> 00:29:49,540
selected objects and I can move them

00:29:47,410 --> 00:29:51,910
into one location now I don't have to

00:29:49,540 --> 00:29:54,580
keep the data about where my selection

00:29:51,910 --> 00:29:56,140
is in the same data structure with the

00:29:54,580 --> 00:29:58,030
rest of my data it doesn't have to

00:29:56,140 --> 00:29:59,950
pollute that and slow down my access

00:29:58,030 --> 00:30:02,440
times on that rest of the data when I

00:29:59,950 --> 00:30:04,570
don't need my selections I can keep it

00:30:02,440 --> 00:30:09,010
as a parallel structure it also means

00:30:04,570 --> 00:30:12,190
that I can take my my selection vector

00:30:09,010 --> 00:30:14,200
here my array of bits and I could encode

00:30:12,190 --> 00:30:16,090
it in a more efficient manner right

00:30:14,200 --> 00:30:18,640
maybe I could encode it as a set of

00:30:16,090 --> 00:30:20,530
inversion points to represent ranges

00:30:18,640 --> 00:30:25,360
that are selected and I can project into

00:30:20,530 --> 00:30:28,330
that okay so just changing that one

00:30:25,360 --> 00:30:34,530
character just removing the star the in

00:30:28,330 --> 00:30:34,530
stable partition gave me a new algorithm

00:30:36,870 --> 00:30:43,750
so another example algorithms in minimal

00:30:40,900 --> 00:30:46,930
work like stable partition a lot of

00:30:43,750 --> 00:30:48,760
algorithms in STL work in a

00:30:46,930 --> 00:30:50,890
divide-and-conquer fashion not just an

00:30:48,760 --> 00:30:52,120
STL a lot of algorithms in general work

00:30:50,890 --> 00:30:53,620
and divide and conquer

00:30:52,120 --> 00:30:56,740
right there's kind of two ways that that

00:30:53,620 --> 00:30:58,720
can happen you can as we saw with stable

00:30:56,740 --> 00:31:00,460
partition we can go all the way down to

00:30:58,720 --> 00:31:02,410
the bottom and then put everything back

00:31:00,460 --> 00:31:06,070
together on the way up or if you are

00:31:02,410 --> 00:31:09,040
doing something like a a quicksort you

00:31:06,070 --> 00:31:11,260
would pick a pivot element and you would

00:31:09,040 --> 00:31:14,320
partition at the top and then you would

00:31:11,260 --> 00:31:15,850
go down the tree doing partitions until

00:31:14,320 --> 00:31:18,400
you got to the bottom and then your

00:31:15,850 --> 00:31:20,860
whole thing would be sorted okay so

00:31:18,400 --> 00:31:22,990
there's kind of two approaches that you

00:31:20,860 --> 00:31:26,110
can take both of these approaches lend

00:31:22,990 --> 00:31:27,820
themselves to pruning the tree right if

00:31:26,110 --> 00:31:29,290
you've got a tree structure a lot of

00:31:27,820 --> 00:31:31,480
times you can figure out that you don't

00:31:29,290 --> 00:31:33,940
need to go all the way down to the

00:31:31,480 --> 00:31:38,020
bottom and we can utilize that to get

00:31:33,940 --> 00:31:41,530
performance so let's take a problem here

00:31:38,020 --> 00:31:44,650
okay I've got this time a vector of

00:31:41,530 --> 00:31:45,240
numbers okay the numbers I think here go

00:31:44,650 --> 00:31:48,330
from

00:31:45,240 --> 00:31:51,770
one two sixteen and they're randomly

00:31:48,330 --> 00:31:57,330
shuffled in there and I've got a range

00:31:51,770 --> 00:31:59,760
within that vector SF to SL that I want

00:31:57,330 --> 00:32:04,950
the values within that range sorted as

00:31:59,760 --> 00:32:08,310
if the entire vector were sorted okay so

00:32:04,950 --> 00:32:11,610
what I want is six seven eight nine in

00:32:08,310 --> 00:32:15,720
there okay but I don't actually care

00:32:11,610 --> 00:32:17,490
about anything outside of there okay so

00:32:15,720 --> 00:32:19,230
I could sort the whole thing and that

00:32:17,490 --> 00:32:24,620
would give it to me just wouldn't be as

00:32:19,230 --> 00:32:30,680
fast as I would like it to be okay

00:32:24,620 --> 00:32:35,100
where do we start writing this anybody

00:32:30,680 --> 00:32:36,600
partition yeah one vote let's see

00:32:35,100 --> 00:32:40,770
I got Marshall back there in the back

00:32:36,600 --> 00:32:42,540
did you would be tempted to start with

00:32:40,770 --> 00:32:44,490
partial sort partial sword is part of

00:32:42,540 --> 00:32:46,050
the answer right I can't just use

00:32:44,490 --> 00:32:48,410
partial sort here because partial sort

00:32:46,050 --> 00:32:54,060
always works at the beginning of a range

00:32:48,410 --> 00:32:56,400
what's that n that thank you okay so

00:32:54,060 --> 00:33:02,370
there is an algorithm in STL called n

00:32:56,400 --> 00:33:06,540
element so we can start with just the

00:33:02,370 --> 00:33:08,670
first guy in this SF and we can call n

00:33:06,540 --> 00:33:10,680
element and what that's going to do is

00:33:08,670 --> 00:33:13,260
is going to do a form of a partial sort

00:33:10,680 --> 00:33:16,260
that just pins the element at our

00:33:13,260 --> 00:33:18,750
iterator sf with the right value right

00:33:16,260 --> 00:33:20,310
so after I do this this is what my data

00:33:18,750 --> 00:33:22,410
is going to look like right the stuff

00:33:20,310 --> 00:33:25,530
above and below is still scrambled but

00:33:22,410 --> 00:33:27,210
six is where I want six to be right so

00:33:25,530 --> 00:33:30,120
you want to calculate a medium quickly

00:33:27,210 --> 00:33:34,140
with STL and element is how you can't

00:33:30,120 --> 00:33:38,340
calculate a median quickly okay okay how

00:33:34,140 --> 00:33:45,090
many people knew that yay no your

00:33:38,340 --> 00:33:48,030
algorithms okay so from there now it's

00:33:45,090 --> 00:33:53,150
pretty simple if we know something a

00:33:48,030 --> 00:33:56,370
little more about an element an element

00:33:53,150 --> 00:33:58,460
doesn't just pin the one element it also

00:33:56,370 --> 00:34:02,850
partitions our space

00:33:58,460 --> 00:34:05,040
specifically everything between F and s

00:34:02,850 --> 00:34:09,980
F is going to be less than or equal to

00:34:05,040 --> 00:34:12,450
the value that's at SF okay and

00:34:09,980 --> 00:34:18,870
everything down there is going to be

00:34:12,450 --> 00:34:22,379
greater how many people knew that Wow

00:34:18,870 --> 00:34:28,830
a few so about half as many people who

00:34:22,379 --> 00:34:31,679
knew what nth element was so now to

00:34:28,830 --> 00:34:33,270
complete things here we already got that

00:34:31,679 --> 00:34:37,379
guy in the right position so we can just

00:34:33,270 --> 00:34:41,580
skip over them and then we can just call

00:34:37,379 --> 00:34:45,419
partial sort okay so both nth element

00:34:41,580 --> 00:34:49,169
and partial sort are tree pruning

00:34:45,419 --> 00:34:54,000
algorithms okay so that's going to give

00:34:49,169 --> 00:34:56,070
us those guys in the right range okay so

00:34:54,000 --> 00:34:57,420
I can put a little boilerplate around

00:34:56,070 --> 00:34:59,310
here I want to handle the empty case

00:34:57,420 --> 00:35:03,450
right I don't want to call tenth element

00:34:59,310 --> 00:35:05,130
when there is no element there and I can

00:35:03,450 --> 00:35:06,900
just skip the whole nth element thing if

00:35:05,130 --> 00:35:11,340
I'm all if my range is already at the

00:35:06,900 --> 00:35:12,780
beginning and now I've got a very

00:35:11,340 --> 00:35:18,240
beautiful little algorithm called sort

00:35:12,780 --> 00:35:20,430
sub range if what I need is to sort of

00:35:18,240 --> 00:35:21,720
sub range and I might do it because I'm

00:35:20,430 --> 00:35:24,360
doing something like taking an average

00:35:21,720 --> 00:35:26,490
around a median or I might do it because

00:35:24,360 --> 00:35:29,250
I've got a view into a large collection

00:35:26,490 --> 00:35:33,750
of records and I just want to see this

00:35:29,250 --> 00:35:38,970
or the user told me to print page seven

00:35:33,750 --> 00:35:41,460
of 1,000 for my document okay there are

00:35:38,970 --> 00:35:43,980
many reasons by my point monthís data in

00:35:41,460 --> 00:35:45,960
practice this is going to be somewhere

00:35:43,980 --> 00:35:48,750
between about two and eight times faster

00:35:45,960 --> 00:35:50,400
than sorting all the data okay because

00:35:48,750 --> 00:35:59,370
we're cutting off the leaf nodes of the

00:35:50,400 --> 00:36:01,530
tree our sort sub range also inherits

00:35:59,370 --> 00:36:03,840
the same properties that we had in n

00:36:01,530 --> 00:36:07,530
element which is it also partitions the

00:36:03,840 --> 00:36:09,900
space so everything from F to SF is less

00:36:07,530 --> 00:36:10,510
than SF and everything from SL to L is

00:36:09,900 --> 00:36:11,740
great

00:36:10,510 --> 00:36:14,560
greater than or equal to the last

00:36:11,740 --> 00:36:21,400
element within our range and so if I

00:36:14,560 --> 00:36:23,740
need to extend it right down to NL I can

00:36:21,400 --> 00:36:30,010
just call partial sort and I can extend

00:36:23,740 --> 00:36:32,320
it okay so what I'm utilizing here is

00:36:30,010 --> 00:36:36,130
I'm establishing spatial relationships

00:36:32,320 --> 00:36:38,860
on my object that capture semantic

00:36:36,130 --> 00:36:41,530
relationships about their value ordering

00:36:38,860 --> 00:36:47,230
and I'm exploiting that to speed up my

00:36:41,530 --> 00:36:53,520
algorithm okay so this is a data

00:36:47,230 --> 00:36:59,460
structure this is structured data right

00:36:53,520 --> 00:37:02,260
so what is an incidental data structure

00:36:59,460 --> 00:37:04,480
well an incidental data structure is a

00:37:02,260 --> 00:37:06,220
data structure that occurs within a

00:37:04,480 --> 00:37:09,070
system where there is no object

00:37:06,220 --> 00:37:11,260
representing the structure as a whole or

00:37:09,070 --> 00:37:13,060
put another way its structure formed in

00:37:11,260 --> 00:37:20,620
the absence of a whole part relationship

00:37:13,060 --> 00:37:22,980
it is not a composite object so why

00:37:20,620 --> 00:37:26,380
don't we want them they cause

00:37:22,980 --> 00:37:28,120
ambiguities in our code right structural

00:37:26,380 --> 00:37:30,730
ambiguities which is a little different

00:37:28,120 --> 00:37:32,560
than value ambiguities they break our

00:37:30,730 --> 00:37:35,650
ability to locally reason about code

00:37:32,560 --> 00:37:39,100
they break the notion of value semantics

00:37:35,650 --> 00:37:44,180
within our code and they happen all the

00:37:39,100 --> 00:37:46,329
time okay

00:37:44,180 --> 00:37:48,619
they happen when we create delegates

00:37:46,329 --> 00:37:53,240
they happen when we have message

00:37:48,619 --> 00:37:56,690
handlers and the big biggest culprit is

00:37:53,240 --> 00:37:59,119
self referential interfaces right I

00:37:56,690 --> 00:38:01,849
remember when I was first learning C and

00:37:59,119 --> 00:38:03,950
I discovered this amazing thing where I

00:38:01,849 --> 00:38:06,500
could forward declare a class or a

00:38:03,950 --> 00:38:08,089
forward declare a struct and then within

00:38:06,500 --> 00:38:11,480
my struct I could have a pointer to

00:38:08,089 --> 00:38:13,910
myself and that's the basic concept with

00:38:11,480 --> 00:38:17,329
which I make a linked list and I thought

00:38:13,910 --> 00:38:23,990
how that's just amazing right right that

00:38:17,329 --> 00:38:28,010
that even works ok this API is also self

00:38:23,990 --> 00:38:32,240
referential API this is pretty much the

00:38:28,010 --> 00:38:35,869
API for UI element out of the windows

00:38:32,240 --> 00:38:37,660
API right stripped down and C++ I is dry

00:38:35,869 --> 00:38:41,809
they got rid of kind of the manage C++

00:38:37,660 --> 00:38:44,780
issues here ok so what have I got

00:38:41,809 --> 00:38:47,380
I've got elements I've got an element

00:38:44,780 --> 00:38:52,220
collection to which I can add elements

00:38:47,380 --> 00:38:56,780
I've got a panel which is an element ok

00:38:52,220 --> 00:39:01,359
and my panel has a bunch of children in

00:38:56,780 --> 00:39:03,230
an element collection which are elements

00:39:01,359 --> 00:39:05,930
and people tell me well what's the

00:39:03,230 --> 00:39:10,309
problem with this it's a hierarchy right

00:39:05,930 --> 00:39:16,970
I mean it works ok I put an object in

00:39:10,309 --> 00:39:18,859
there is it a hierarchy right what if I

00:39:16,970 --> 00:39:25,549
do that if I put the element into the

00:39:18,859 --> 00:39:30,859
panel again hmm ok well it's a dag we

00:39:25,549 --> 00:39:33,950
can deal with the dag it tags ok well

00:39:30,859 --> 00:39:42,160
what if I do that ok it's a dag with two

00:39:33,950 --> 00:39:42,160
routes or that

00:39:43,730 --> 00:39:51,650
okay my API doesn't constrict those okay

00:39:49,529 --> 00:39:54,000
you might think this is silly

00:39:51,650 --> 00:39:58,400
but I've actually seen people do

00:39:54,000 --> 00:40:05,240
horrible things like this in code okay

00:39:58,400 --> 00:40:09,750
with sometimes interesting results okay

00:40:05,240 --> 00:40:13,140
what's going on here we have managed in

00:40:09,750 --> 00:40:17,400
those four lines of code to violate

00:40:13,140 --> 00:40:19,890
every property of a composite type every

00:40:17,400 --> 00:40:29,000
single last one our panel is a part of

00:40:19,890 --> 00:40:32,220
itself right so it's circular okay so

00:40:29,000 --> 00:40:39,349
it's not just joint we have two panels

00:40:32,220 --> 00:40:45,630
they're sharing the same elements okay

00:40:39,349 --> 00:40:47,579
so we violated ownership if we

00:40:45,630 --> 00:40:55,710
destructed one the whole thing did not

00:40:47,579 --> 00:40:58,799
go away and potentially we have a retain

00:40:55,710 --> 00:41:03,539
loop on our panel and that would violate

00:40:58,799 --> 00:41:05,519
connectivity those four lines of code we

00:41:03,539 --> 00:41:14,700
violate every principle for a composite

00:41:05,519 --> 00:41:17,910
object so forests and hierarchies are so

00:41:14,700 --> 00:41:20,130
important because they appear in code

00:41:17,910 --> 00:41:21,839
all over the place and they had to add a

00:41:20,130 --> 00:41:24,809
huge amount of complexity to the code

00:41:21,839 --> 00:41:27,059
we've all gotten used to writing linked

00:41:24,809 --> 00:41:29,190
lists and vectors and things in terms of

00:41:27,059 --> 00:41:32,009
containers and yet for some reason we

00:41:29,190 --> 00:41:36,119
persist in writing forests and

00:41:32,009 --> 00:41:39,299
hierarchies as intrusive data structures

00:41:36,119 --> 00:41:42,049
where we embed the information about the

00:41:39,299 --> 00:41:44,490
structure into the structure itself and

00:41:42,049 --> 00:41:46,470
besides the structural ambiguities that

00:41:44,490 --> 00:41:49,049
I pointed out this leads to all kind of

00:41:46,470 --> 00:41:52,230
algorithmic ambiguities when I iterate

00:41:49,049 --> 00:41:56,369
over the children okay with

00:41:52,230 --> 00:41:59,900
and my panel am I just did a rating over

00:41:56,369 --> 00:42:04,800
the children or is that a pre-order

00:41:59,900 --> 00:42:07,830
depth-first search or maybe it's a post

00:42:04,800 --> 00:42:10,050
order depth-first operation right

00:42:07,830 --> 00:42:11,730
because I don't know as I call each of

00:42:10,050 --> 00:42:16,050
those children what they're doing with

00:42:11,730 --> 00:42:17,490
their children right right and a lot of

00:42:16,050 --> 00:42:21,410
people tell me well this isn't too bad

00:42:17,490 --> 00:42:24,359
because hierarchies tend to be log n ish

00:42:21,410 --> 00:42:28,980
actually is really bad hierarchies in

00:42:24,359 --> 00:42:32,310
real life tend more to be like and over

00:42:28,980 --> 00:42:34,260
to ish right right

00:42:32,310 --> 00:42:36,960
they don't fan out like that if you look

00:42:34,260 --> 00:42:38,730
at view hierarchies I have like a bunch

00:42:36,960 --> 00:42:44,250
of deep containers and then a bazillion

00:42:38,730 --> 00:42:46,910
children okay go like down and out that

00:42:44,250 --> 00:42:49,470
tends to be more of the structure right

00:42:46,910 --> 00:42:52,200
right they tend to be a very inefficient

00:42:49,470 --> 00:42:54,990
way if I want to do something like very

00:42:52,200 --> 00:42:57,270
quickly determine where a mouse clicked

00:42:54,990 --> 00:43:00,359
within a view hierarchy I don't want to

00:42:57,270 --> 00:43:02,490
go walk down my hierarchy and say say is

00:43:00,359 --> 00:43:04,590
it in you yes okay we'll check your

00:43:02,490 --> 00:43:07,040
children bonk bonk bonk all the way down

00:43:04,590 --> 00:43:09,240
what I want is something like a quadtree

00:43:07,040 --> 00:43:11,580
right where I can very quickly navigate

00:43:09,240 --> 00:43:12,600
to exactly the object I don't want the

00:43:11,580 --> 00:43:14,550
containment hierarchy

00:43:12,600 --> 00:43:16,890
I want parallel data structures to keep

00:43:14,550 --> 00:43:18,690
that information people tend to do event

00:43:16,890 --> 00:43:20,520
dispatching in these things where they

00:43:18,690 --> 00:43:21,960
keep throwing events back up to the top

00:43:20,520 --> 00:43:25,440
when really what they want to be doing

00:43:21,960 --> 00:43:27,210
is just calling another object directly

00:43:25,440 --> 00:43:29,130
a little over in the tree instead of

00:43:27,210 --> 00:43:34,410
percolating event up and down this

00:43:29,130 --> 00:43:36,210
hierarchy okay and forests are somewhat

00:43:34,410 --> 00:43:42,000
difficult structures now if I talk about

00:43:36,210 --> 00:43:47,040
a sequence how many positions are there

00:43:42,000 --> 00:43:48,420
in a sequence okay anybody I have a

00:43:47,040 --> 00:43:50,960
sequence of n elements how many

00:43:48,420 --> 00:43:53,369
positions in a sequence of n elements n

00:43:50,960 --> 00:43:55,109
plus 1 there are n plus 1 positions

00:43:53,369 --> 00:43:57,359
right right there I could go between

00:43:55,109 --> 00:43:58,619
each of the guys in the element those

00:43:57,359 --> 00:43:59,359
are all the places where I could insert

00:43:58,619 --> 00:44:01,650
some

00:43:59,359 --> 00:44:15,089
how many positions are there in a

00:44:01,650 --> 00:44:16,799
hierarchy anybody what does it mean okay

00:44:15,089 --> 00:44:19,640
first thing you have to define it is

00:44:16,799 --> 00:44:22,950
your hierarchy ordered or unordered

00:44:19,640 --> 00:44:26,369
right that makes a difference and what

00:44:22,950 --> 00:44:32,099
do you mean by position it's a difficult

00:44:26,369 --> 00:44:33,660
thing so a story here years ago I'm

00:44:32,099 --> 00:44:37,529
sitting on the floor with my youngest

00:44:33,660 --> 00:44:38,880
son and he's got a little fine motor

00:44:37,529 --> 00:44:41,760
skill toy

00:44:38,880 --> 00:44:43,859
it's just wooden beads and shoelaces

00:44:41,760 --> 00:44:46,799
right then you string the beads on the

00:44:43,859 --> 00:44:47,329
shoelaces how many people know what I'm

00:44:46,799 --> 00:44:55,890
talking about

00:44:47,329 --> 00:45:01,170
everybody good okay so you can do that

00:44:55,890 --> 00:45:02,730
put two beads on a shoelace now this is

00:45:01,170 --> 00:45:04,349
a pretty decent representation of a

00:45:02,730 --> 00:45:08,359
linked list and that tells me how many

00:45:04,349 --> 00:45:10,589
positions are in the linked list

00:45:08,359 --> 00:45:15,960
what would the corresponding structure

00:45:10,589 --> 00:45:17,519
be for forests right people are thinking

00:45:15,960 --> 00:45:23,400
probably a bunch of strings with a bunch

00:45:17,519 --> 00:45:25,079
of knots something messy okay so I'm

00:45:23,400 --> 00:45:27,539
sitting on the floor with my son and one

00:45:25,079 --> 00:45:33,390
of the shoelaces is tied into a loop

00:45:27,539 --> 00:45:35,099
it's tied at the top okay and the

00:45:33,390 --> 00:45:38,700
shoelace was fine enough that you could

00:45:35,099 --> 00:45:40,890
put the loop through a bead like that

00:45:38,700 --> 00:45:42,359
you couldn't pass back through the bead

00:45:40,890 --> 00:45:43,710
because it completely filled the bead

00:45:42,359 --> 00:45:44,910
that once you put the loop through the

00:45:43,710 --> 00:45:49,289
bead so you could only put a loop

00:45:44,910 --> 00:45:56,869
through the bead once okay so you could

00:45:49,289 --> 00:46:01,559
build a list this way okay but any place

00:45:56,869 --> 00:46:06,619
where you could pull out a loop you

00:46:01,559 --> 00:46:10,140
could put it through like that and

00:46:06,619 --> 00:46:15,059
create a forest or higher

00:46:10,140 --> 00:46:17,400
I was very excited by this like I spent

00:46:15,059 --> 00:46:20,190
four hours playing with this shoelace

00:46:17,400 --> 00:46:29,039
and beats anybody understand why I was

00:46:20,190 --> 00:46:32,490
so excited and no no something is it is

00:46:29,039 --> 00:46:35,069
a sequence okay so it has lots of

00:46:32,490 --> 00:46:37,079
amazing properties okay it is a physical

00:46:35,069 --> 00:46:38,250
model of a hierarchy and the only thing

00:46:37,079 --> 00:46:41,099
that you can build with this as a

00:46:38,250 --> 00:46:44,220
hierarchy okay the invariant that this

00:46:41,099 --> 00:46:46,170
thing stays as a hierarchy is part of

00:46:44,220 --> 00:46:50,190
the physical model of it you cannot

00:46:46,170 --> 00:46:52,230
build an on higher key this way okay

00:46:50,190 --> 00:46:54,000
there is nothing that you can build with

00:46:52,230 --> 00:46:58,349
this physical model except for

00:46:54,000 --> 00:47:02,069
hierarchies it also has some amazing

00:46:58,349 --> 00:47:04,440
properties in that right it's a little

00:47:02,069 --> 00:47:06,119
bit more complicated direction okay so

00:47:04,440 --> 00:47:07,619
we have the knot at the top that's the

00:47:06,119 --> 00:47:10,920
piece that we hold on to that's our

00:47:07,619 --> 00:47:12,960
forest okay we can add a directionality

00:47:10,920 --> 00:47:19,250
to the string as far as how it loops

00:47:12,960 --> 00:47:21,240
around okay each position here

00:47:19,250 --> 00:47:23,250
represents a position where we could

00:47:21,240 --> 00:47:25,740
draw that out and insert another node

00:47:23,250 --> 00:47:28,829
right we can tree parent things but we

00:47:25,740 --> 00:47:31,500
can put leaf nodes anywhere okay just

00:47:28,829 --> 00:47:33,960
like on our original string if we were

00:47:31,500 --> 00:47:36,059
just putting be done to form a list

00:47:33,960 --> 00:47:38,819
I can't move things further up without

00:47:36,059 --> 00:47:40,559
splicing okay but I can keep that

00:47:38,819 --> 00:47:43,710
ordering in a similar way I can always

00:47:40,559 --> 00:47:51,920
add leaf nodes to my tree but I can't

00:47:43,710 --> 00:47:51,920
reparent things okay every position

00:47:52,369 --> 00:48:00,480
within this list uniquely identifies a

00:47:57,619 --> 00:48:03,299
location within the tree without keeping

00:48:00,480 --> 00:48:05,309
a stack of information I can have an

00:48:03,299 --> 00:48:06,990
iterator that points to a node and I can

00:48:05,309 --> 00:48:13,430
just remember it and pick up from there

00:48:06,990 --> 00:48:13,430
and keep going in a traversal right

00:48:13,790 --> 00:48:18,770
if I give you this definition that says

00:48:16,550 --> 00:48:22,490
we have a leading and trailing edge on

00:48:18,770 --> 00:48:25,060
our nodes okay then if I mark off the

00:48:22,490 --> 00:48:27,470
leading edge where I come in on the top

00:48:25,060 --> 00:48:30,560
that is a pre-order depth-first

00:48:27,470 --> 00:48:35,080
traversal and coming up from the bottom

00:48:30,560 --> 00:48:40,070
is a post order depth-first traversal

00:48:35,080 --> 00:48:43,670
okay if I want to know what it means to

00:48:40,070 --> 00:48:46,220
erase elements from some point in my

00:48:43,670 --> 00:48:48,980
model to some other point in my model

00:48:46,220 --> 00:48:51,620
okay what I do is I grab those two

00:48:48,980 --> 00:48:54,440
locations on the string and I pick the

00:48:51,620 --> 00:48:59,390
whole thing up and the beads that fall

00:48:54,440 --> 00:49:03,680
off are the ones that get erased okay so

00:48:59,390 --> 00:49:07,520
above my fingers going towards the knot

00:49:03,680 --> 00:49:10,430
nothing can come off below my fingers

00:49:07,520 --> 00:49:12,770
things might get stuck if I grabbed

00:49:10,430 --> 00:49:15,140
along the same edge I might end up with

00:49:12,770 --> 00:49:16,850
a list of parents that I didn't fully

00:49:15,140 --> 00:49:19,400
select something asked the string has to

00:49:16,850 --> 00:49:23,000
go through twice for it to fall off

00:49:19,400 --> 00:49:24,560
between my two fingers okay this means

00:49:23,000 --> 00:49:29,090
that if I take this structure and I

00:49:24,560 --> 00:49:31,340
flatten it out and I encoded at within a

00:49:29,090 --> 00:49:33,560
UI it means that I know what it means if

00:49:31,340 --> 00:49:36,830
I click here and shift-click there and

00:49:33,560 --> 00:49:38,780
hit the delete button okay and the

00:49:36,830 --> 00:49:42,740
algorithm in the code for this actually

00:49:38,780 --> 00:49:45,530
works out to be see what beads fall off

00:49:42,740 --> 00:49:55,910
right it's quite a beautiful little

00:49:45,530 --> 00:49:57,980
thing okay so there's a force data

00:49:55,910 --> 00:50:00,170
structure that's in ASL that's been in

00:49:57,980 --> 00:50:03,410
ASL for years Adobe source libraries if

00:50:00,170 --> 00:50:05,600
you don't know what it is it's decaying

00:50:03,410 --> 00:50:07,220
a bit the source libraries are but I

00:50:05,600 --> 00:50:09,020
keep this up-to-date on github so you

00:50:07,220 --> 00:50:11,900
can find the ASL repository on github

00:50:09,020 --> 00:50:15,770
and this will build and this is what it

00:50:11,900 --> 00:50:17,690
looks like to insert things and in my

00:50:15,770 --> 00:50:18,560
opinion this is a really beautiful data

00:50:17,690 --> 00:50:19,880
structure it's not a particularly

00:50:18,560 --> 00:50:21,590
efficient data structure it's a

00:50:19,880 --> 00:50:23,090
node-based data structure but that's

00:50:21,590 --> 00:50:25,280
what you would probably create anyways

00:50:23,090 --> 00:50:26,050
but it has this wonderful safety

00:50:25,280 --> 00:50:30,340
attribute

00:50:26,050 --> 00:50:33,040
that I can't create a non hierarchy okay

00:50:30,340 --> 00:50:35,170
so it has these wonderful attributes

00:50:33,040 --> 00:50:37,240
that I can remember positions into it

00:50:35,170 --> 00:50:41,440
and deal with that that when I iterate

00:50:37,240 --> 00:50:43,960
arrange I can see what it is exactly

00:50:41,440 --> 00:50:45,700
that I'm iterating okay I'm not calling

00:50:43,960 --> 00:50:49,000
each node and saying you call your

00:50:45,700 --> 00:50:50,710
children somehow okay and I know if I

00:50:49,000 --> 00:50:53,500
want to do a pre-order or post order

00:50:50,710 --> 00:51:05,710
that becomes immediately apparent within

00:50:53,500 --> 00:51:11,260
the code so two weeks ago a little side

00:51:05,710 --> 00:51:12,850
story here my wife was babysitting my

00:51:11,260 --> 00:51:15,880
younger son whose beats I was playing

00:51:12,850 --> 00:51:18,160
with he's now 26 so my wife was

00:51:15,880 --> 00:51:21,300
babysitting and she keeps a box of old

00:51:18,160 --> 00:51:23,500
toys from when our kids were little and

00:51:21,300 --> 00:51:25,450
she took it out and she was babysitting

00:51:23,500 --> 00:51:27,880
and then that was a bag with the

00:51:25,450 --> 00:51:30,010
shoelaces and the beads the actual

00:51:27,880 --> 00:51:31,450
shoelaces and the beads and I had this

00:51:30,010 --> 00:51:34,210
very humorous thought that it's like

00:51:31,450 --> 00:51:36,640
well someday maybe in Computer History

00:51:34,210 --> 00:51:43,660
Museum next to Martin Newell's teapot

00:51:36,640 --> 00:51:45,400
there will be Sean's shoelace but I was

00:51:43,660 --> 00:51:49,030
surprisingly excited to see these and I

00:51:45,400 --> 00:51:50,770
was like ah I remember those beads and I

00:51:49,030 --> 00:51:53,530
asked my wife I said do you mind if I

00:51:50,770 --> 00:51:58,690
take those to the conference that I'm

00:51:53,530 --> 00:51:59,710
going to give a talk at and she said why

00:51:58,690 --> 00:52:02,790
would you want to take them to the

00:51:59,710 --> 00:52:05,890
conference so I tried to explain that

00:52:02,790 --> 00:52:09,490
you know this shoelace in this bead was

00:52:05,890 --> 00:52:11,680
a beautiful representation of a higher

00:52:09,490 --> 00:52:14,080
and that it maintained all these

00:52:11,680 --> 00:52:17,320
wonderful attributes my wife's a nurse

00:52:14,080 --> 00:52:21,640
and she wasn't looking at me like

00:52:17,320 --> 00:52:23,500
quizzically or with awe she was looking

00:52:21,640 --> 00:52:26,040
at me with something that was closer to

00:52:23,500 --> 00:52:26,040
discussed

00:52:26,620 --> 00:52:33,410
and she reached out and she took the

00:52:29,510 --> 00:52:37,790
beats back and she said that's what you

00:52:33,410 --> 00:52:45,250
remember so computer scientists were bad

00:52:37,790 --> 00:52:49,460
at relationships okay

00:52:45,250 --> 00:52:52,970
so conclusions understand the structure

00:52:49,460 --> 00:52:55,490
is created by relationships okay if you

00:52:52,970 --> 00:52:57,260
want to improve your code encapsulate

00:52:55,490 --> 00:52:59,600
structure and very mints in composite

00:52:57,260 --> 00:53:01,940
types and learn to use the tools that

00:52:59,600 --> 00:53:04,700
are already at your disposal and how to

00:53:01,940 --> 00:53:08,030
create new ones right last time I

00:53:04,700 --> 00:53:11,140
challenged you guys those who are here

00:53:08,030 --> 00:53:15,220
two years ago learn the stl algorithms

00:53:11,140 --> 00:53:18,590
right now I mean really learn them okay

00:53:15,220 --> 00:53:20,630
so don't just read the interface and

00:53:18,590 --> 00:53:25,090
learn them learn how they're implemented

00:53:20,630 --> 00:53:32,300
right learn how you would write your own

00:53:25,090 --> 00:53:35,990
ok STL is intended to be an example an

00:53:32,300 --> 00:53:38,570
example of how you code so not a

00:53:35,990 --> 00:53:45,010
beginning not an end it's an example

00:53:38,570 --> 00:53:51,800
right so no incidental data structures

00:53:45,010 --> 00:53:54,670
composite types and better code and

00:53:51,800 --> 00:53:54,670
that's it for my talk

00:54:02,760 --> 00:54:10,390
I've got plenty of time for questions

00:54:05,200 --> 00:54:12,820
people have any a question over here you

00:54:10,390 --> 00:54:15,310
might want to come up to the mic yeah so

00:54:12,820 --> 00:54:17,950
you mentioned we can learn from the STL

00:54:15,310 --> 00:54:20,680
and the implementation of the STL I'm

00:54:17,950 --> 00:54:23,140
also wondering and I guess we could

00:54:20,680 --> 00:54:26,020
start with ASL also could you point out

00:54:23,140 --> 00:54:29,920
some examples of C++ libraries today

00:54:26,020 --> 00:54:31,300
that best showcase the properties that

00:54:29,920 --> 00:54:35,079
you have thought about that we could

00:54:31,300 --> 00:54:37,089
also learn from by example right I mean

00:54:35,079 --> 00:54:38,980
I certainly think you see them in boost

00:54:37,089 --> 00:54:42,030
and then you know the common libraries

00:54:38,980 --> 00:54:44,500
that you would think of looking

00:54:42,030 --> 00:54:46,510
unfortunately STL itself the typical

00:54:44,500 --> 00:54:48,670
sources that are on your machine are so

00:54:46,510 --> 00:54:50,079
munched and so optimized that they can

00:54:48,670 --> 00:54:51,670
be very difficult to kind of plow

00:54:50,079 --> 00:54:54,190
through and learn from reading the

00:54:51,670 --> 00:54:57,400
implementation a lot of times I'll go

00:54:54,190 --> 00:55:00,130
back to Alex's old SGI implementations

00:54:57,400 --> 00:55:01,900
which are still online to actually read

00:55:00,130 --> 00:55:04,000
read the algorithms and what's going on

00:55:01,900 --> 00:55:06,849
there the other thing to keep in mind

00:55:04,000 --> 00:55:08,800
when you're going through this if you go

00:55:06,849 --> 00:55:10,150
through this exercise is I think there's

00:55:08,800 --> 00:55:11,650
a lot of opportunities where we could

00:55:10,150 --> 00:55:14,980
improve on things there's things like

00:55:11,650 --> 00:55:16,450
like rotate has an implementation for

00:55:14,980 --> 00:55:18,270
how you do a forward rotate and a

00:55:16,450 --> 00:55:21,990
bi-directional rotate and a random

00:55:18,270 --> 00:55:24,940
access rotate you know depending on on

00:55:21,990 --> 00:55:28,030
the concept satisfied by your iterators

00:55:24,940 --> 00:55:29,710
those are three different algorithms and

00:55:28,030 --> 00:55:31,839
I don't know that anybody has ever gone

00:55:29,710 --> 00:55:34,480
back and revisited I would almost guess

00:55:31,839 --> 00:55:40,180
that the forward iterator implementation

00:55:34,480 --> 00:55:42,760
for rotate beats the bi-directional

00:55:40,180 --> 00:55:47,109
iterator which is running backwards on

00:55:42,760 --> 00:55:48,599
our disk drive of memory and it might

00:55:47,109 --> 00:55:53,829
even be to the random access

00:55:48,599 --> 00:55:56,650
implementation right so so kind of keep

00:55:53,829 --> 00:55:58,260
the history in mind there as you go go

00:55:56,650 --> 00:56:02,440
back and look at the algorithms the

00:55:58,260 --> 00:56:04,060
other great resource is alex has course

00:56:02,440 --> 00:56:06,579
notes online which are a little more

00:56:04,060 --> 00:56:08,710
approachable than something like AOP

00:56:06,579 --> 00:56:10,030
right-eo P is a brilliant book so

00:56:08,710 --> 00:56:12,910
actually I have also a follow-up

00:56:10,030 --> 00:56:16,090
question do you know anything like notes

00:56:12,910 --> 00:56:18,040
on programming by Alexander step enough

00:56:16,090 --> 00:56:20,170
you're perhaps plan to write something

00:56:18,040 --> 00:56:23,110
because I would be very interested well

00:56:20,170 --> 00:56:24,550
as I said yeah maybe I'll write a book I

00:56:23,110 --> 00:56:26,050
keep telling people people are like how

00:56:24,550 --> 00:56:27,220
where's the book and I'm like well the

00:56:26,050 --> 00:56:32,080
only thing I have left to do at this

00:56:27,220 --> 00:56:33,310
point is write it but that actually

00:56:32,080 --> 00:56:35,380
means I've done a lot of work right

00:56:33,310 --> 00:56:36,880
right I've put together talks and notes

00:56:35,380 --> 00:56:38,560
and I've taught the class and so I have

00:56:36,880 --> 00:56:41,290
a big pile of material but anybody who's

00:56:38,560 --> 00:56:44,910
written a book I haven't but I've worked

00:56:41,290 --> 00:56:49,180
with people who have it's a lot of work

00:56:44,910 --> 00:56:52,930
so so yes I would like to get a book out

00:56:49,180 --> 00:56:55,450
right question over here hello I would

00:56:52,930 --> 00:56:58,330
like to present a hypothesis to you and

00:56:55,450 --> 00:57:02,950
get your opinion on it I think a common

00:56:58,330 --> 00:57:05,170
thread among your recent talks can be

00:57:02,950 --> 00:57:08,950
demonstrated if you consider code itself

00:57:05,170 --> 00:57:11,290
to be a data structure whether it's call

00:57:08,950 --> 00:57:13,690
graphs or a sequence of instructions or

00:57:11,290 --> 00:57:16,330
what have you and when you think about a

00:57:13,690 --> 00:57:17,530
raw loop and all of the pieces that go

00:57:16,330 --> 00:57:20,590
into making a raw loop you have

00:57:17,530 --> 00:57:22,180
iterators and increment operators that

00:57:20,590 --> 00:57:25,420
can be seen as an incidental data

00:57:22,180 --> 00:57:27,280
structure yes do you see a relationship

00:57:25,420 --> 00:57:29,400
here between how we craft good code and

00:57:27,280 --> 00:57:33,100
how we craft good data structures I do

00:57:29,400 --> 00:57:35,950
the the term incidental data structure

00:57:33,100 --> 00:57:39,640
was actually coined by echo yarv a who's

00:57:35,950 --> 00:57:42,450
a professor at Texas A&M it occurs in a

00:57:39,640 --> 00:57:45,840
paper I co-authored with them on on

00:57:42,450 --> 00:57:49,570
property models which is about

00:57:45,840 --> 00:57:52,210
dependency graphs and and flow of data

00:57:49,570 --> 00:57:54,460
within an application and that that

00:57:52,210 --> 00:57:56,950
creates a data structure if you want to

00:57:54,460 --> 00:58:01,270
know more about that as I mentioned see

00:57:56,950 --> 00:58:02,680
one of my concurrency talks or you can

00:58:01,270 --> 00:58:05,950
look online we've got a number of papers

00:58:02,680 --> 00:58:09,220
published published on the topic but yes

00:58:05,950 --> 00:58:10,900
absolutely in a more general sense like

00:58:09,220 --> 00:58:12,790
I said it's all about relationships and

00:58:10,900 --> 00:58:15,160
the structures formed in your code and

00:58:12,790 --> 00:58:17,020
to understand a large system you have to

00:58:15,160 --> 00:58:18,700
keep looking at how are the components

00:58:17,020 --> 00:58:20,680
connected and they're connected in a lot

00:58:18,700 --> 00:58:22,150
of ways right there's different types of

00:58:20,680 --> 00:58:23,920
relationships there's the functional

00:58:22,150 --> 00:58:25,750
relationships there's the value

00:58:23,920 --> 00:58:26,260
relationships there's the structural

00:58:25,750 --> 00:58:28,000
relation

00:58:26,260 --> 00:58:31,210
chips there's a representational

00:58:28,000 --> 00:58:32,110
relationships and we exploit all of

00:58:31,210 --> 00:58:33,520
those right and then we have

00:58:32,110 --> 00:58:35,620
higher-level relationships like

00:58:33,520 --> 00:58:40,290
whole-part relationships and we exploit

00:58:35,620 --> 00:58:42,970
that so as you're looking at your code

00:58:40,290 --> 00:58:45,220
what ultimately what we want is the

00:58:42,970 --> 00:58:46,900
ability to reason about a piece of code

00:58:45,220 --> 00:58:49,650
locally so if you look at every single

00:58:46,900 --> 00:58:52,210
chapter in here what the punchline is is

00:58:49,650 --> 00:58:54,430
how do I get my code in the point where

00:58:52,210 --> 00:58:56,440
I can sit down with one function and

00:58:54,430 --> 00:58:59,190
read that function and understand what

00:58:56,440 --> 00:59:01,660
in the world is going on with my code

00:58:59,190 --> 00:59:04,660
okay so it's all about understanding

00:59:01,660 --> 00:59:06,880
these relationships so that you can

00:59:04,660 --> 00:59:08,800
reason about your code locally and know

00:59:06,880 --> 00:59:12,760
that as a whole if it works locally it's

00:59:08,800 --> 00:59:15,280
going to work at scale so yes I agree

00:59:12,760 --> 00:59:17,770
so you shown the importance of data

00:59:15,280 --> 00:59:19,390
locality for performance reasons yes and

00:59:17,770 --> 00:59:21,160
as far as I understand the forest

00:59:19,390 --> 00:59:24,640
implementation that you've shown was

00:59:21,160 --> 00:59:27,040
note based so how do I do you actually

00:59:24,640 --> 00:59:29,230
suggest to implement something like a

00:59:27,040 --> 00:59:31,240
hierarchical structure while having

00:59:29,230 --> 00:59:36,550
contiguous memory to benefit from cache

00:59:31,240 --> 00:59:38,500
locality so the question here was my

00:59:36,550 --> 00:59:40,450
forest implementation is node based I

00:59:38,500 --> 00:59:42,010
mentioned that and yet I already talked

00:59:40,450 --> 00:59:45,370
about the performance that you want by

00:59:42,010 --> 00:59:49,210
keeping locality so could I recommend a

00:59:45,370 --> 00:59:53,230
structure for for a forest that would

00:59:49,210 --> 00:59:55,090
keep locality no I haven't written one

00:59:53,230 --> 01:00:02,050
yet I think somebody should maybe I

00:59:55,090 --> 01:00:03,460
should I think it's doable there's some

01:00:02,050 --> 01:00:05,530
hacks that you can do I think our forest

01:00:03,460 --> 01:00:07,930
like actually accepts allocators so you

01:00:05,530 --> 01:00:10,810
can pull the same trick that you do that

01:00:07,930 --> 01:00:13,360
can have a serious performance impact on

01:00:10,810 --> 01:00:16,000
I saw delete in dark so I I don't know

01:00:13,360 --> 01:00:19,090
what's that I saw a delete keyword in

01:00:16,000 --> 01:00:21,460
there so in the forest source code I

01:00:19,090 --> 01:00:23,260
delete keyword so I don't know if that's

01:00:21,460 --> 01:00:27,160
doable with the forest into my station

01:00:23,260 --> 01:00:30,940
ass yeah maybe not maybe not I I would I

01:00:27,160 --> 01:00:32,080
would have to go back and look but you

01:00:30,940 --> 01:00:33,550
know you could retrofit it for an

01:00:32,080 --> 01:00:34,220
alligator if it doesn't already support

01:00:33,550 --> 01:00:39,440
one I thought

01:00:34,220 --> 01:00:41,470
but I could be wrong old memories but

01:00:39,440 --> 01:00:44,030
yes I think that you could you could

01:00:41,470 --> 01:00:46,310
build a structure that exploited the

01:00:44,030 --> 01:00:53,630
same properties but had better locality

01:00:46,310 --> 01:00:56,030
for operations thank you yeah so one of

01:00:53,630 --> 01:00:59,330
the more well-established incidental

01:00:56,030 --> 01:01:01,550
data structures is that of iterators and

01:00:59,330 --> 01:01:04,550
the various containers that they iterate

01:01:01,550 --> 01:01:07,010
through have you given any thought to

01:01:04,550 --> 01:01:09,700
how we might sort of break that

01:01:07,010 --> 01:01:14,480
incidental data structure set up that

01:01:09,700 --> 01:01:18,010
permeates a lot of our code so I think

01:01:14,480 --> 01:01:21,830
most of the issues there come from

01:01:18,010 --> 01:01:28,970
misusing iterators I think you really

01:01:21,830 --> 01:01:31,220
want to to keep your iterator usage

01:01:28,970 --> 01:01:34,160
encapsulated right right the very fact

01:01:31,220 --> 01:01:38,000
that they can become invalidated means

01:01:34,160 --> 01:01:43,240
that that they they are in some sense

01:01:38,000 --> 01:01:46,670
unsafe and must be used in with care

01:01:43,240 --> 01:01:49,490
unsafe doesn't mean bad and recently I

01:01:46,670 --> 01:01:51,560
wrote a little blog post about move that

01:01:49,490 --> 01:01:53,810
you can find online that I think has a

01:01:51,560 --> 01:01:56,330
beautiful little proof that says that

01:01:53,810 --> 01:01:59,540
there's a fundamental trade-off between

01:01:56,330 --> 01:02:04,940
safety and efficiency and provably you

01:01:59,540 --> 01:02:07,010
cannot have both okay so that doesn't

01:02:04,940 --> 01:02:11,690
mean necessarily that that's a horrible

01:02:07,010 --> 01:02:14,540
state of affairs it just is the reality

01:02:11,690 --> 01:02:17,440
now there's a lot that we can do to to

01:02:14,540 --> 01:02:21,290
improve safety we've heard a lot at

01:02:17,440 --> 01:02:26,300
about the libraries that herb and in

01:02:21,290 --> 01:02:28,910
Viana announced where we can improve

01:02:26,300 --> 01:02:30,619
safety without a cost of efficiency and

01:02:28,910 --> 01:02:34,160
I think Eric Kneedler is going to give a

01:02:30,619 --> 01:02:35,690
talk on Friday about the range library

01:02:34,160 --> 01:02:37,550
and that gives us a higher level

01:02:35,690 --> 01:02:41,950
abstraction to deal with iterators to

01:02:37,550 --> 01:02:43,930
improve the safety around iterators but

01:02:41,950 --> 01:02:46,839
physicians exist

01:02:43,930 --> 01:02:49,660
and you know an iterator is just a

01:02:46,839 --> 01:02:51,819
position into something and positions

01:02:49,660 --> 01:02:54,099
are fragile and it's unfortunate but

01:02:51,819 --> 01:02:56,760
it's the reality and sometimes you need

01:02:54,099 --> 01:03:02,460
them right it's very difficult to have

01:02:56,760 --> 01:03:06,609
something like a a safe rotate operation

01:03:02,460 --> 01:03:08,289
where where you you don't just have a

01:03:06,609 --> 01:03:14,680
ROM midpoint that's required to be

01:03:08,289 --> 01:03:18,839
within a range so so there's trade-offs

01:03:14,680 --> 01:03:18,839
there right we can do better

01:03:19,410 --> 01:03:29,170
any other questions good okay so this

01:03:26,650 --> 01:03:31,720
was the very first time I've given this

01:03:29,170 --> 01:03:32,950
talk so I apologize for running a little

01:03:31,720 --> 01:03:34,299
short I actually thought I was going to

01:03:32,950 --> 01:03:39,130
run a little long but I think I talked

01:03:34,299 --> 01:03:40,650
faster than I expected to but you know

01:03:39,130 --> 01:03:42,670
if you have any feedback about it

01:03:40,650 --> 01:03:44,200
approach me afterwards because I'll

01:03:42,670 --> 01:03:45,670
probably repeat the talk at some point

01:03:44,200 --> 01:03:47,319
so I'd like to get your actual feedback

01:03:45,670 --> 01:03:50,020
in if you saw a typo on a slide or

01:03:47,319 --> 01:03:54,660
something to that to me but otherwise

01:03:50,020 --> 01:03:54,660

YouTube URL: https://www.youtube.com/watch?v=sWgDk-o-6ZE


