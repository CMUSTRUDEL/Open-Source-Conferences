Title: Simple, Extensible Pattern Matching in C++14 - John R. Bandela [ CppCon 2015 ]
Publication date: 2015-10-11
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Recently, there has been in increased interest in applying functional programming techniques to C++. A very convenient construct that is used in functional programming languages is pattern matching. Due to the features introduced in C++11 and C++14 we can actually write a simple, easy to use, understandable, and extensible pattern matching library that is header only and uses no macros.

In this talks we will discuss the motivations for pattern matching, and see examples of use from other languages. We will then go on to design and implement a pattern matching library in C++. Particular attention will be payed to new C++14 features that greatly simplify the implementation such as integer_sequence, function return type deduction, and generic lambdas. The implementation will also serve a practical guide to using variadic templates and std::tuple.

We will show how the library can be easily extended and customized by working through some examples of customization such as working with user defined classes and structs, pointers, tuples, boost::optional, and boost::variant. At the end of the session, the audience will have an appreciation for pattern matching, as well as a sense that the C++11/14 features open new paradigms without sacrificing understandable code.
— 
I first started programming in C++ at age 14 in 1994 when I cajoled my parents into buying me Visual C++ 1.0 for my birthday. It took a while, but as I learned the language, I decided I really liked C++. I attended the University of Florida and obtained my undergraduate degree in Computer and Information Science. During my undergraduate time, I created and submitted Boost.Tokenizer. I went on to medical school and neurosurgery residency, but decided to do something with a little less scary undefined behavior and returned to programming in C++. I am currently working for Transunion Specialized Risk Group as a Senior C++ programmer.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,000 --> 00:00:04,920
good afternoon everybody my name is John

00:00:03,360 --> 00:00:06,810
vandella and I'm going to be talking

00:00:04,920 --> 00:00:09,450
about simple extensible pattern matching

00:00:06,810 --> 00:00:13,110
in C++ 14 thank you all for coming out

00:00:09,450 --> 00:00:15,570
just a little bit about me I first

00:00:13,110 --> 00:00:17,880
started programming in C++ after I

00:00:15,570 --> 00:00:20,730
convinced my parents to buy me visual

00:00:17,880 --> 00:00:23,100
c++ 1 point 0 for my 14th birthday after

00:00:20,730 --> 00:00:25,019
that I went to undergrad at University

00:00:23,100 --> 00:00:27,599
of Florida and then I went to medical

00:00:25,019 --> 00:00:30,840
school and that did nurse surgery

00:00:27,599 --> 00:00:32,040
residency this is this is me right there

00:00:30,840 --> 00:00:34,890
this is actually from one of the

00:00:32,040 --> 00:00:38,129
surgeries the patient right here had I

00:00:34,890 --> 00:00:39,690
guess an epilepsy which is seizures from

00:00:38,129 --> 00:00:41,579
a part of the brain that that couldn't

00:00:39,690 --> 00:00:43,500
be treated with drugs unfortunately the

00:00:41,579 --> 00:00:45,780
bad part of the brain was right near the

00:00:43,500 --> 00:00:48,420
speech area so we don't want to take it

00:00:45,780 --> 00:00:51,030
out and make him not able to speak so

00:00:48,420 --> 00:00:53,550
basically put him to sleep open up the

00:00:51,030 --> 00:00:55,020
skull expose the brain then woke him up

00:00:53,550 --> 00:00:57,270
and then had all these electrodes

00:00:55,020 --> 00:00:59,190
monitoring everything and and basically

00:00:57,270 --> 00:01:00,449
the neuropsychology people asked him a

00:00:59,190 --> 00:01:03,600
bunch of questions like can you identify

00:01:00,449 --> 00:01:04,920
stuff and while we were like probing

00:01:03,600 --> 00:01:06,360
different parts of the brain to identify

00:01:04,920 --> 00:01:09,750
what he actually didn't need that we

00:01:06,360 --> 00:01:12,390
could take out yeah all very cool stuff

00:01:09,750 --> 00:01:14,310
after this I decided to do something

00:01:12,390 --> 00:01:19,200
with a little bit less scary undefined

00:01:14,310 --> 00:01:20,729
behavior so back to C++ all right so our

00:01:19,200 --> 00:01:22,350
goals for this talk we're going to have

00:01:20,729 --> 00:01:24,000
a very brief introduction to pattern

00:01:22,350 --> 00:01:26,490
matching we're going to look at some

00:01:24,000 --> 00:01:29,280
existing solutions and then we're going

00:01:26,490 --> 00:01:30,500
to design implement the library and then

00:01:29,280 --> 00:01:32,880
we'll have some question answer time

00:01:30,500 --> 00:01:35,159
basically the goal at the end of this

00:01:32,880 --> 00:01:36,960
talk is for you to understand how the

00:01:35,159 --> 00:01:39,770
library is implemented and have a

00:01:36,960 --> 00:01:42,770
feeling that hey I could do this myself

00:01:39,770 --> 00:01:45,509
all right so what is pattern matching

00:01:42,770 --> 00:01:47,310
this I guess you can have several for

00:01:45,509 --> 00:01:49,649
more or less formal definitions a good

00:01:47,310 --> 00:01:52,740
enough working definition is instead of

00:01:49,649 --> 00:01:55,140
explicitly extracting and testing values

00:01:52,740 --> 00:01:57,270
you basically you specify what you want

00:01:55,140 --> 00:01:59,100
the value to look like and then you

00:01:57,270 --> 00:02:02,159
specify an action to happen when that

00:01:59,100 --> 00:02:04,079
occurs it's kind of like you can think

00:02:02,159 --> 00:02:06,119
of it as a kind of level abstraction of

00:02:04,079 --> 00:02:09,239
using regular expressions with strings

00:02:06,119 --> 00:02:13,240
versus using like stud find and you know

00:02:09,239 --> 00:02:15,430
matching and trying to match that way

00:02:13,240 --> 00:02:18,970
how well does C++ 14 support pattern

00:02:15,430 --> 00:02:21,130
matching C++ 14 supports it very well it

00:02:18,970 --> 00:02:24,120
is probably in the top tier of support

00:02:21,130 --> 00:02:26,160
among widely used languages

00:02:24,120 --> 00:02:28,870
unfortunately it's all at compile time

00:02:26,160 --> 00:02:30,730
so at compile time we've got function

00:02:28,870 --> 00:02:33,580
overloading we got partial overloading

00:02:30,730 --> 00:02:35,110
of template functions we've got template

00:02:33,580 --> 00:02:37,090
specialization we've got partial

00:02:35,110 --> 00:02:38,680
template specialization it's on the

00:02:37,090 --> 00:02:41,950
family of pattern matching and it's

00:02:38,680 --> 00:02:47,890
actually quite good at runtime this is

00:02:41,950 --> 00:02:50,350
what we have right so on not too hot the

00:02:47,890 --> 00:02:52,570
good old switch statement which you know

00:02:50,350 --> 00:02:56,350
which yoyo you'll find somebody on Stack

00:02:52,570 --> 00:02:58,900
Overflow asking why can't I use a string

00:02:56,350 --> 00:03:02,070
there and complaining about what

00:02:58,900 --> 00:03:04,690
happened other languages for example

00:03:02,070 --> 00:03:08,050
Haskell which is a functional

00:03:04,690 --> 00:03:09,940
programming language they have pattern

00:03:08,050 --> 00:03:12,700
matching which support several ways you

00:03:09,940 --> 00:03:14,490
can do it so this is basically the

00:03:12,700 --> 00:03:16,660
equivalent of like a function

00:03:14,490 --> 00:03:17,890
declaration and then you can actually

00:03:16,660 --> 00:03:20,710
pattern match in the function

00:03:17,890 --> 00:03:22,780
declaration so ABC is actually a couple

00:03:20,710 --> 00:03:24,010
that's built into the language and so

00:03:22,780 --> 00:03:26,200
you're basically to get the first part

00:03:24,010 --> 00:03:28,780
of a you extract out the first plane and

00:03:26,200 --> 00:03:30,070
you ignore the rest here and the other

00:03:28,780 --> 00:03:32,590
way you can do it they have a case

00:03:30,070 --> 00:03:35,080
statement here and these square brackets

00:03:32,590 --> 00:03:42,040
are a list so an empty list a list of

00:03:35,080 --> 00:03:44,950
one or else a list of many this is how r

00:03:42,040 --> 00:03:49,900
us does it so they have this match

00:03:44,950 --> 00:03:52,480
statement so you have your your pattern

00:03:49,900 --> 00:03:55,810
here and then what to do afterward this

00:03:52,480 --> 00:04:00,250
means basically is the otherwise and

00:03:55,810 --> 00:04:02,830
that always matches you can also do

00:04:00,250 --> 00:04:06,490
stuff with tuples you can break them

00:04:02,830 --> 00:04:10,570
into parts and extract and tests on

00:04:06,490 --> 00:04:13,660
those parts and you can have algebraic

00:04:10,570 --> 00:04:14,650
data types so you have like email

00:04:13,660 --> 00:04:16,630
message so this is kind of like a

00:04:14,650 --> 00:04:19,150
variant and you can have different parts

00:04:16,630 --> 00:04:21,160
quit change color move right your match

00:04:19,150 --> 00:04:22,690
can extract and pull those out without

00:04:21,160 --> 00:04:25,169
having to do a bunch of it found

00:04:22,690 --> 00:04:28,919
statements there

00:04:25,169 --> 00:04:31,449
just a plug for URI here in the audience

00:04:28,919 --> 00:04:33,100
so there's actually a right there

00:04:31,449 --> 00:04:34,750
there's actually a very nice pattern

00:04:33,100 --> 00:04:37,509
library already available it's called

00:04:34,750 --> 00:04:39,850
Mach 7 there were some very nice

00:04:37,509 --> 00:04:43,300
presentations about it last year at CP

00:04:39,850 --> 00:04:47,050
pecan and also in the c++ now that you

00:04:43,300 --> 00:04:49,270
can watch online it does a bunch of a

00:04:47,050 --> 00:04:52,300
bunch of stuff for example here is an

00:04:49,270 --> 00:04:53,979
example from it dealing with boolean

00:04:52,300 --> 00:04:57,669
expressions so if you have a boolean

00:04:53,979 --> 00:05:00,550
expression basically to kind of evaluate

00:04:57,669 --> 00:05:03,669
that type of thing here's how you would

00:05:00,550 --> 00:05:07,050
set it up and here's how the pattern

00:05:03,669 --> 00:05:07,050
matching would look like in this library

00:05:07,500 --> 00:05:14,190
so my library is called simple match as

00:05:11,470 --> 00:05:18,789
opposed to that this is just made by

00:05:14,190 --> 00:05:20,620
yours truly Mach 7 works with older

00:05:18,789 --> 00:05:24,039
compilers I think as far back as visual

00:05:20,620 --> 00:05:26,050
c++ 2010 this one is c plus plus 14 only

00:05:24,039 --> 00:05:29,830
so basically you're looking at I think I

00:05:26,050 --> 00:05:36,060
G clanging 3.6 GCC 5 series and visual

00:05:29,830 --> 00:05:39,310
c++ 2015 a simple match has no macros

00:05:36,060 --> 00:05:41,789
it's basically a library no plans for

00:05:39,310 --> 00:05:45,430
any like future language features and

00:05:41,789 --> 00:05:48,639
the focus for this thing is not at the

00:05:45,430 --> 00:05:53,949
moment on performance but rather on

00:05:48,639 --> 00:05:56,590
clarity and simplicity as buren a said

00:05:53,949 --> 00:06:00,610
C++ 11 actually feels like a new

00:05:56,590 --> 00:06:02,650
language and the implementation of it so

00:06:00,610 --> 00:06:05,949
this is just you know WC minus L and all

00:06:02,650 --> 00:06:09,699
the implementation files was actually it

00:06:05,949 --> 00:06:11,380
was actually a lot less complicated and

00:06:09,699 --> 00:06:14,560
less code and actually I thought it

00:06:11,380 --> 00:06:19,780
would take so which is a testament to

00:06:14,560 --> 00:06:22,180
c++ 14 so just an example just the

00:06:19,780 --> 00:06:26,260
previous example of doing like the

00:06:22,180 --> 00:06:28,120
expression matching don't worry like for

00:06:26,260 --> 00:06:31,270
this example just you know this is here

00:06:28,120 --> 00:06:32,500
just for kind of reference we'll go

00:06:31,270 --> 00:06:35,050
through it and by the end of this talk

00:06:32,500 --> 00:06:37,810
you'll understand every line what he

00:06:35,050 --> 00:06:39,130
does and how its implemented so

00:06:37,810 --> 00:06:42,470
basically

00:06:39,130 --> 00:06:44,690
you you basically declare your strokes

00:06:42,470 --> 00:06:47,889
we're using boosts parent with recursive

00:06:44,690 --> 00:06:51,710
wrapper so recursive rapper basically

00:06:47,889 --> 00:06:54,410
keeps you keeps your space from blowing

00:06:51,710 --> 00:06:56,389
up infinitely so you can reference stuff

00:06:54,410 --> 00:06:58,820
like have recursive structures using

00:06:56,389 --> 00:07:02,680
boost variant I instead of like a valve

00:06:58,820 --> 00:07:05,840
type we just put in a bool and then we

00:07:02,680 --> 00:07:09,050
basically inherit from STD tupple and

00:07:05,840 --> 00:07:12,710
then we basically are using the temple

00:07:09,050 --> 00:07:16,130
constructors any questions about this or

00:07:12,710 --> 00:07:19,009
this is this should all be basically C++

00:07:16,130 --> 00:07:20,830
11 boost and then this is what our eval

00:07:19,009 --> 00:07:25,250
function is there's a couple of changes

00:07:20,830 --> 00:07:28,250
i'm using the variant boolean expression

00:07:25,250 --> 00:07:30,680
and i'm also this is constant so

00:07:28,250 --> 00:07:32,360
basically you do a match and then you

00:07:30,680 --> 00:07:34,940
say what you want to match and then you

00:07:32,360 --> 00:07:39,620
provide a lambda that that tells you

00:07:34,940 --> 00:07:42,580
what to do like i said at the end of

00:07:39,620 --> 00:07:44,389
this talk will will will basically

00:07:42,580 --> 00:07:55,550
understand and be able to implement

00:07:44,389 --> 00:08:03,610
every line yes they are they are yes

00:07:55,550 --> 00:08:07,610
simple match placeholders already and

00:08:03,610 --> 00:08:09,440
this is an added bonus if you forget

00:08:07,610 --> 00:08:12,620
something some not expression especially

00:08:09,440 --> 00:08:14,810
for this just for this case mainly you

00:08:12,620 --> 00:08:21,050
get this error message saying this type

00:08:14,810 --> 00:08:22,669
is not in the match not expression all

00:08:21,050 --> 00:08:25,520
right so let's talk about how we go

00:08:22,669 --> 00:08:27,770
about designing and building this so

00:08:25,520 --> 00:08:30,880
building blocks there's some nice c plus

00:08:27,770 --> 00:08:33,890
plus 14 language and library features

00:08:30,880 --> 00:08:37,789
function return type deduction generic

00:08:33,890 --> 00:08:41,200
lambdas and index sequence okay so

00:08:37,789 --> 00:08:44,390
function return type deduction basically

00:08:41,200 --> 00:08:47,209
the compiler knows what the return type

00:08:44,390 --> 00:08:50,230
of a function should be and instead of

00:08:47,209 --> 00:08:52,250
having to write it out yourself

00:08:50,230 --> 00:08:54,410
especially with generic code

00:08:52,250 --> 00:08:56,750
it can become a lot easier and simpler

00:08:54,410 --> 00:09:01,970
just to put in Auto and let the compiler

00:08:56,750 --> 00:09:04,220
do it generic lambdas instead of having

00:09:01,970 --> 00:09:06,590
to specify what the exact types of the

00:09:04,220 --> 00:09:09,790
lambda parameters are you can put auto

00:09:06,590 --> 00:09:13,790
there or Auto ampersand and the compiler

00:09:09,790 --> 00:09:19,160
will deduce it for you and you know and

00:09:13,790 --> 00:09:21,890
you can use it as as a generic index

00:09:19,160 --> 00:09:23,930
sequence index sequences unless you're

00:09:21,890 --> 00:09:27,080
familiar with it it seemed kind of like

00:09:23,930 --> 00:09:30,890
a little magical class for me but

00:09:27,080 --> 00:09:33,770
basically you can call make index

00:09:30,890 --> 00:09:35,720
sequence say like a five and get back

00:09:33,770 --> 00:09:39,820
this index sequence of zero one two

00:09:35,720 --> 00:09:43,850
three four we'll see where that is

00:09:39,820 --> 00:09:47,960
useful in just a little a little bit so

00:09:43,850 --> 00:09:50,360
the star of our show is STD tuple we

00:09:47,960 --> 00:09:53,150
will use that a lot and it will provide

00:09:50,360 --> 00:09:56,720
a lot of help for us all right so this

00:09:53,150 --> 00:09:59,660
is what top o everybody anybody here not

00:09:56,720 --> 00:10:02,240
familiar with STD tupple alright so

00:09:59,660 --> 00:10:04,700
basically you can make a couple gets

00:10:02,240 --> 00:10:12,020
extract stuff out of it all right

00:10:04,700 --> 00:10:15,140
anybody know what this is all right

00:10:12,020 --> 00:10:16,640
temple cat basically this is a really

00:10:15,140 --> 00:10:19,250
cool function that you give it two

00:10:16,640 --> 00:10:20,600
tuples and it returns you back at uppal

00:10:19,250 --> 00:10:25,990
with everything put together in one

00:10:20,600 --> 00:10:25,990
giant couple anyone know what this is

00:10:27,280 --> 00:10:36,860
stud tie all right this is the last one

00:10:31,910 --> 00:10:39,580
for a while anyway so stud tie basically

00:10:36,860 --> 00:10:42,020
creates a couple of L value references

00:10:39,580 --> 00:10:43,760
by the way this is a really easy way if

00:10:42,020 --> 00:10:46,280
you want to implement lexicographical

00:10:43,760 --> 00:10:48,620
comparison for multiple types you put an

00:10:46,280 --> 00:10:54,000
STD tie and then do a less than and

00:10:48,620 --> 00:10:57,690
it'll work out real nice all right apply

00:10:54,000 --> 00:11:00,090
apply is not yet in the c++ standard I

00:10:57,690 --> 00:11:04,640
think its proposed for like the one of

00:11:00,090 --> 00:11:08,010
the tss standard yet sterile experiment

00:11:04,640 --> 00:11:11,100
okay so it's in there this is what it

00:11:08,010 --> 00:11:12,980
looks like you're basically you give it

00:11:11,100 --> 00:11:17,490
a function and a couple and it calls the

00:11:12,980 --> 00:11:24,480
function with all the with all the

00:11:17,490 --> 00:11:27,450
arguments from the couple okay all right

00:11:24,480 --> 00:11:30,270
thank you very much so I did I pull this

00:11:27,450 --> 00:11:31,680
from like the N 3915 paper and basically

00:11:30,270 --> 00:11:35,070
this is what I'm using for the

00:11:31,680 --> 00:11:39,960
implementation here so it's just

00:11:35,070 --> 00:11:42,960
straight up still a c++ 14 so as you can

00:11:39,960 --> 00:11:46,110
see the trick is basically the index

00:11:42,960 --> 00:11:48,630
sequence with the integers basically we

00:11:46,110 --> 00:11:53,550
can expand the parameter pack here to

00:11:48,630 --> 00:11:57,360
actually make the function call alright

00:11:53,550 --> 00:12:00,300
so let's go on let's talk about the core

00:11:57,360 --> 00:12:04,280
of the library so the court of the

00:12:00,300 --> 00:12:09,570
library is a function called match and

00:12:04,280 --> 00:12:13,320
match is a is a is a very attic function

00:12:09,570 --> 00:12:17,640
so basically the first part is basically

00:12:13,320 --> 00:12:19,800
the the base case so we take the the t

00:12:17,640 --> 00:12:27,240
is that is basically the value that you

00:12:19,800 --> 00:12:30,180
want to match so T is the value writer

00:12:27,240 --> 00:12:31,920
match a is basically your pattern f is

00:12:30,180 --> 00:12:36,540
what you want to do afterward so you

00:12:31,920 --> 00:12:39,390
call match check passing in the value on

00:12:36,540 --> 00:12:43,020
a match and the pattern and if that

00:12:39,390 --> 00:12:45,420
returns true you call apply and with the

00:12:43,020 --> 00:12:48,180
result from match get which has which

00:12:45,420 --> 00:12:54,630
you pass in the the value and the

00:12:48,180 --> 00:12:57,150
pattern and match get returns couple so

00:12:54,630 --> 00:13:01,320
down here a base basically this is the

00:12:57,150 --> 00:13:02,640
very attic form of it it's a little bit

00:13:01,320 --> 00:13:04,770
different than a lot of times you may

00:13:02,640 --> 00:13:06,700
see because there's no empty case there

00:13:04,770 --> 00:13:09,670
has to be at least one match

00:13:06,700 --> 00:13:11,590
for it so basically the same as before

00:13:09,670 --> 00:13:13,120
except if we can't find it we pass it on

00:13:11,590 --> 00:13:15,520
to the next thing so this is basically

00:13:13,120 --> 00:13:17,860
what's called a first fit match we match

00:13:15,520 --> 00:13:27,520
the first thing that fits so the order

00:13:17,860 --> 00:13:29,760
is important yes actually I think I now

00:13:27,520 --> 00:13:32,110
made a subclass for but this is just

00:13:29,760 --> 00:13:34,690
yeah laziness initially yes correct

00:13:32,110 --> 00:13:38,880
there's a sub if you on the repo there's

00:13:34,690 --> 00:13:45,160
a subclass now but just for illustration

00:13:38,880 --> 00:13:47,530
all right match so match check basically

00:13:45,160 --> 00:13:52,840
basically look basically looks up

00:13:47,530 --> 00:13:54,840
matcher with the type of the type of the

00:13:52,840 --> 00:13:57,190
variable and the type of the pattern and

00:13:54,840 --> 00:14:00,250
based on that it calls a static function

00:13:57,190 --> 00:14:05,440
check and gap so basically this just

00:14:00,250 --> 00:14:08,290
passes it on and this is what it looks

00:14:05,440 --> 00:14:09,730
like as we go forward we will specialize

00:14:08,290 --> 00:14:17,800
this class and we'll get more stuff any

00:14:09,730 --> 00:14:28,570
questions about the core at this time in

00:14:17,800 --> 00:14:30,190
terms of correct the reason is I was

00:14:28,570 --> 00:14:31,720
going like one after the other there may

00:14:30,190 --> 00:14:39,520
be a whole bunch of checks without gets

00:14:31,720 --> 00:14:40,960
and it's like an if so here it's so you

00:14:39,520 --> 00:14:42,340
could combine into one but you'd have to

00:14:40,960 --> 00:14:45,280
keep like some other parameter or

00:14:42,340 --> 00:14:46,750
whatever with it and then for the other

00:14:45,280 --> 00:14:48,970
parts you may not be able to return a

00:14:46,750 --> 00:14:50,170
nice valid couple for it where's this

00:14:48,970 --> 00:14:57,250
thing you know that you can return

00:14:50,170 --> 00:14:59,680
something match check returns true that

00:14:57,250 --> 00:15:02,980
you're good match check returns hey this

00:14:59,680 --> 00:15:05,500
map we can go forward with Colin a match

00:15:02,980 --> 00:15:11,680
get this is a valid match this matches

00:15:05,500 --> 00:15:14,529
this pattern that's true correct so here

00:15:11,680 --> 00:15:16,480
match check same as up here and then if

00:15:14,529 --> 00:15:21,070
it doesn't match instead we pass it on

00:15:16,480 --> 00:15:26,620
to the next thing all right any other

00:15:21,070 --> 00:15:29,020
questions all right so so basically

00:15:26,620 --> 00:15:32,170
we'll start extending the score so right

00:15:29,020 --> 00:15:33,880
now it's pretty useless so we're going

00:15:32,170 --> 00:15:36,310
to make it useful by specializing

00:15:33,880 --> 00:15:37,959
silicon match match your lives and

00:15:36,310 --> 00:15:39,760
customization and that's also the

00:15:37,959 --> 00:15:45,370
customization hook for user-defined

00:15:39,760 --> 00:15:47,560
types all right so first of all we're

00:15:45,370 --> 00:15:49,930
going to start matching the same time so

00:15:47,560 --> 00:15:53,709
Matt say X is just some get in get you

00:15:49,930 --> 00:15:58,899
an integer one two three if it's we were

00:15:53,709 --> 00:16:02,550
answers one answers to interest rate and

00:15:58,899 --> 00:16:05,320
this is what we do we specialize matcher

00:16:02,550 --> 00:16:09,570
check is just if they're equal to each

00:16:05,320 --> 00:16:09,570
other and basically return empty tuple

00:16:10,170 --> 00:16:17,920
all right so that will work now if you

00:16:13,870 --> 00:16:20,529
have a string and constant char you know

00:16:17,920 --> 00:16:35,550
the types won't match so let's let's

00:16:20,529 --> 00:16:42,670
make this work as well so yes probably

00:16:35,550 --> 00:16:52,120
do you're correct yeah so basically just

00:16:42,670 --> 00:16:53,920
same thing at the 40 right right correct

00:16:52,120 --> 00:16:56,050
right so yeah we could probably do an

00:16:53,920 --> 00:17:00,160
enable if on it with with equals

00:16:56,050 --> 00:17:01,270
operator correct alright so let's do

00:17:00,160 --> 00:17:04,630
otherwise so this is basically

00:17:01,270 --> 00:17:07,630
equivalent of a default in a switch in

00:17:04,630 --> 00:17:10,089
the switch so basically so the

00:17:07,630 --> 00:17:17,140
underscore it lives in simple match

00:17:10,089 --> 00:17:22,030
placeholders so in place holders we have

00:17:17,140 --> 00:17:23,660
destruct otherwise t we create otherwise

00:17:22,030 --> 00:17:29,090
and underscore

00:17:23,660 --> 00:17:32,980
and this is the match type we just

00:17:29,090 --> 00:17:39,140
returned true and returned empty temple

00:17:32,980 --> 00:17:41,450
everybody good so far all right some

00:17:39,140 --> 00:17:43,580
more interesting stuff let's match and

00:17:41,450 --> 00:17:47,750
be able to actually get what value that

00:17:43,580 --> 00:17:51,350
we matched right so placeholders

00:17:47,750 --> 00:17:53,540
underscore X and basically it'll come

00:17:51,350 --> 00:17:56,540
out so we can come we can grab the X

00:17:53,540 --> 00:18:01,550
here and we can output or do whatever

00:17:56,540 --> 00:18:04,520
you want with it alright so we have

00:18:01,550 --> 00:18:07,370
match your predicate we just holds up

00:18:04,520 --> 00:18:08,840
basically a function object and then we

00:18:07,370 --> 00:18:11,720
have this helper thing make match a

00:18:08,840 --> 00:18:15,370
predicate that just you know type

00:18:11,720 --> 00:18:15,370
deduces it and creates the right type

00:18:15,790 --> 00:18:23,240
and then we specialize match the

00:18:19,820 --> 00:18:26,870
predicate basically we check returns

00:18:23,240 --> 00:18:32,420
true if if the if the predicate returns

00:18:26,870 --> 00:18:34,970
true and then then if it then forget we

00:18:32,420 --> 00:18:36,260
just return we tied there and so return

00:18:34,970 --> 00:18:43,430
like a couple of one whatever that

00:18:36,260 --> 00:18:46,430
matched so then placeholders we can have

00:18:43,430 --> 00:18:48,050
XY and z they're basically you know

00:18:46,430 --> 00:18:50,930
simple and you can add however many

00:18:48,050 --> 00:18:53,840
things now there is no difference

00:18:50,930 --> 00:18:56,750
between x y&z in terms of how they're

00:18:53,840 --> 00:19:02,120
handled so that just you put XX or XY XZ

00:18:56,750 --> 00:19:06,320
there's no significance to that alright

00:19:02,120 --> 00:19:08,720
so let's do relational operators now so

00:19:06,320 --> 00:19:15,320
one two we want to do X is less than ten

00:19:08,720 --> 00:19:20,480
or say X is in between 10 and 20 and

00:19:15,320 --> 00:19:22,100
otherwise and like I said we can do

00:19:20,480 --> 00:19:23,840
different stuff so we can do if we

00:19:22,100 --> 00:19:28,040
wanted to we can do the half open range

00:19:23,840 --> 00:19:30,080
or the other range so this is just

00:19:28,040 --> 00:19:31,340
example for operate or less basically

00:19:30,080 --> 00:19:34,730
all the other operators follow the same

00:19:31,340 --> 00:19:37,149
pattern we compare a match your

00:19:34,730 --> 00:19:40,419
predicate and a value and then

00:19:37,149 --> 00:19:41,919
we recurring we call the f Fung the

00:19:40,419 --> 00:19:45,849
predicate function on the metra

00:19:41,919 --> 00:19:49,239
predicate and the comparison operator

00:19:45,849 --> 00:19:52,179
and this is just with those reversed any

00:19:49,239 --> 00:19:55,450
questions about this and the reason it's

00:19:52,179 --> 00:19:58,469
that way is is basically no I thought

00:19:55,450 --> 00:20:01,450
this was a pretty nice range syntax that

00:19:58,469 --> 00:20:05,979
was compact and easy to see at a glance

00:20:01,450 --> 00:20:09,219
what's going on alright any questions

00:20:05,979 --> 00:20:14,309
here so these are the simple types here

00:20:09,219 --> 00:20:14,309
then we'll extend on to compound types

00:20:14,759 --> 00:20:22,629
alright so here's the example Mike

00:20:18,339 --> 00:20:24,249
remember what rested basically you are

00:20:22,629 --> 00:20:28,330
able to split up the couple and extract

00:20:24,249 --> 00:20:30,999
stuff so that's known as d structuring

00:20:28,330 --> 00:20:32,469
basically it's taken a larger structure

00:20:30,999 --> 00:20:34,659
breaking into its components and then

00:20:32,469 --> 00:20:37,779
you can pattern match further on the

00:20:34,659 --> 00:20:42,519
components for our case we're going to

00:20:37,779 --> 00:20:47,499
use tuples as the underlying case all

00:20:42,519 --> 00:20:51,580
right anybody everybody know fizzbuzz so

00:20:47,499 --> 00:20:54,700
yes so fizzbuzz actually by reginald

00:20:51,580 --> 00:20:56,739
Brathwaite and i think Jeff Atwood of a

00:20:54,700 --> 00:20:59,529
coding for is the one that popularized

00:20:56,739 --> 00:21:01,359
at least for me so basically it's based

00:20:59,529 --> 00:21:05,019
on I believe a children's game is that

00:21:01,359 --> 00:21:07,479
correct from from the UK i believe so

00:21:05,019 --> 00:21:09,909
basically have the numbers from 1 to 100

00:21:07,479 --> 00:21:13,289
if it's a multiple of 3 you print phys

00:21:09,909 --> 00:21:15,669
so the number multiple of five fit buzz

00:21:13,289 --> 00:21:19,169
multiples are both upenn fizzbuzz

00:21:15,669 --> 00:21:21,909
otherwise you print what the number is

00:21:19,169 --> 00:21:23,649
so i guess it's a children's game you go

00:21:21,909 --> 00:21:27,039
around the circle and whoever messes up

00:21:23,649 --> 00:21:29,019
gets kicked out of the circle all right

00:21:27,039 --> 00:21:31,359
so here is there's a million ways to

00:21:29,019 --> 00:21:34,570
implement in this here's a simple way to

00:21:31,359 --> 00:21:38,649
implement this with match so basically

00:21:34,570 --> 00:21:42,539
make a couple I modulo 3 I modulo 5 if

00:21:38,649 --> 00:21:46,419
both are 0 fizzbuzz 0 or anything phys

00:21:42,539 --> 00:21:48,609
anything or 0 buzz and otherwise we

00:21:46,419 --> 00:21:51,329
captured the I output it any questions

00:21:48,609 --> 00:21:51,329
about this example

00:21:53,549 --> 00:21:59,230
alright so now comes the fun part of

00:21:56,500 --> 00:22:02,559
implementing this so this is just like

00:21:59,230 --> 00:22:04,299
some adapters this will help us in the

00:22:02,559 --> 00:22:07,809
future when we want to try to adapt the

00:22:04,299 --> 00:22:10,149
class to topple so basically have this

00:22:07,809 --> 00:22:12,009
simple match get to poll which is

00:22:10,149 --> 00:22:14,799
basically the identity function for

00:22:12,009 --> 00:22:16,450
topple if there's a constant overload

00:22:14,799 --> 00:22:20,049
non-constant overload and then you have

00:22:16,450 --> 00:22:27,360
couple adapter which has a static get

00:22:20,049 --> 00:22:29,769
function that takes the index and then

00:22:27,360 --> 00:22:33,809
returns simple maps get top ones cause

00:22:29,769 --> 00:22:40,269
STD get on it any questions about that

00:22:33,809 --> 00:22:41,559
everybody yes it's going to be this guy

00:22:40,269 --> 00:22:43,509
right here this is the easiest

00:22:41,559 --> 00:22:45,159
customization point though this is also

00:22:43,509 --> 00:22:49,210
a customization point if this doesn't

00:22:45,159 --> 00:22:51,549
quite work for you you're welcome all

00:22:49,210 --> 00:22:53,529
right so this is what our matter is

00:22:51,549 --> 00:22:57,309
going to look like so we find the couple

00:22:53,529 --> 00:23:00,549
adapter now from right here and then

00:22:57,309 --> 00:23:03,730
topple len sizeof args minus one will

00:23:00,549 --> 00:23:07,120
get back to why we do minus one in a

00:23:03,730 --> 00:23:14,110
little bit and then we have our helper

00:23:07,120 --> 00:23:17,850
function so basically let's see it takes

00:23:14,110 --> 00:23:20,350
the first position and then the last one

00:23:17,850 --> 00:23:22,179
basically let's go on to the base case

00:23:20,350 --> 00:23:25,210
so we're the first of the last so this

00:23:22,179 --> 00:23:28,870
is the last one at the end so basically

00:23:25,210 --> 00:23:33,610
it calls match check and it pulls out

00:23:28,870 --> 00:23:36,940
the the element of the top position and

00:23:33,610 --> 00:23:40,590
and passes that to mass check as the

00:23:36,940 --> 00:23:45,549
variable being matched and it pulls out

00:23:40,590 --> 00:23:49,629
from here it pulls out the pattern here

00:23:45,549 --> 00:23:52,570
and passes out to matts check and then

00:23:49,629 --> 00:23:55,720
get does the same thing here so

00:23:52,570 --> 00:23:57,490
basically with this we can we can like

00:23:55,720 --> 00:23:59,529
compose stuff so everything that we have

00:23:57,490 --> 00:24:02,050
access to with the simple types we have

00:23:59,529 --> 00:24:04,210
access to in the temple as well

00:24:02,050 --> 00:24:05,890
alright and then this is this is the

00:24:04,210 --> 00:24:09,040
general case it does the same thing

00:24:05,890 --> 00:24:14,860
except it passes on to the phosphorus 12

00:24:09,040 --> 00:24:16,480
the to the helper any questions if

00:24:14,860 --> 00:24:18,790
there's any questions interrupt me stop

00:24:16,480 --> 00:24:24,280
me raise your hand we can like I said

00:24:18,790 --> 00:24:30,730
let's stop and talking and learn all

00:24:24,280 --> 00:24:31,960
right so check so Matt so matcher so

00:24:30,730 --> 00:24:34,060
these are the check and get things

00:24:31,960 --> 00:24:41,260
basically calls helper check forward it

00:24:34,060 --> 00:24:43,360
to that and help her get all right and

00:24:41,260 --> 00:24:44,650
then when we want to so we're going to

00:24:43,360 --> 00:24:46,600
create like a little helper function

00:24:44,650 --> 00:24:49,420
called be structure and then basically

00:24:46,600 --> 00:24:51,610
takes all these arguments make them at

00:24:49,420 --> 00:24:52,890
uppal now the reason we have this and

00:24:51,610 --> 00:24:56,860
the reason we did the length minus

00:24:52,890 --> 00:25:00,550
basically the size of minus one when i

00:24:56,860 --> 00:25:04,120
try to do this initially it got it at an

00:25:00,550 --> 00:25:06,010
ambiguity between TT and this thing so

00:25:04,120 --> 00:25:08,800
we add this extra type at the end that

00:25:06,010 --> 00:25:17,290
we just ignore and that keeps that keeps

00:25:08,800 --> 00:25:19,000
this from happening alright so let's see

00:25:17,290 --> 00:25:23,260
so how do we adapt a class so we got

00:25:19,000 --> 00:25:26,650
basically a point class x and y and you

00:25:23,260 --> 00:25:29,590
know we want to use it with this so

00:25:26,650 --> 00:25:31,690
basically let's create a match sure if

00:25:29,590 --> 00:25:36,160
it's 12 we output this otherwise we

00:25:31,690 --> 00:25:38,140
output output this alright so basically

00:25:36,160 --> 00:25:41,880
we can create a couple pass to it and

00:25:38,140 --> 00:25:44,620
create a point pass to it it all works

00:25:41,880 --> 00:25:48,190
so basically this is how you'd customize

00:25:44,620 --> 00:25:49,300
the type that you that yeah that you

00:25:48,190 --> 00:25:53,260
were creating that you want to work with

00:25:49,300 --> 00:25:55,540
this so you can do a constant overload

00:25:53,260 --> 00:26:01,420
if you want but basically this is all

00:25:55,540 --> 00:26:03,970
there is to it yes

00:26:01,420 --> 00:26:14,440
maybe I just did another thing well so

00:26:03,970 --> 00:26:16,240
you have to provide this yes you had to

00:26:14,440 --> 00:26:21,970
provide this for your types that you

00:26:16,240 --> 00:26:23,530
want to use with it correct correct yes

00:26:21,970 --> 00:26:25,480
yeah this is the this is the

00:26:23,530 --> 00:26:37,090
customization point so to be able to go

00:26:25,480 --> 00:26:39,010
in there yes if you overload by if you

00:26:37,090 --> 00:26:42,060
yeah if we if we didn't over them for

00:26:39,010 --> 00:26:42,060
that when we would be able to do it

00:26:43,500 --> 00:26:52,900
alright any questions about tuples all

00:26:48,970 --> 00:26:56,140
right so let's go on to pointers so

00:26:52,900 --> 00:26:58,540
basically in everybody familiar with

00:26:56,140 --> 00:27:00,970
like the maybe type or optional and

00:26:58,540 --> 00:27:02,350
functional programming basically if you

00:27:00,970 --> 00:27:05,020
have an error in turn throwing an

00:27:02,350 --> 00:27:06,790
exception you you can return a maybe and

00:27:05,020 --> 00:27:10,030
then you can pattern match determine

00:27:06,790 --> 00:27:12,100
what you want his little high school

00:27:10,030 --> 00:27:15,340
example basically dip safe keep from

00:27:12,100 --> 00:27:17,350
dividing by 0 if it's just something we

00:27:15,340 --> 00:27:22,210
say it otherwise provide that so it's

00:27:17,350 --> 00:27:24,430
justin nothing so we can kind of treat

00:27:22,210 --> 00:27:27,280
pointers as an optional so no partner

00:27:24,430 --> 00:27:28,660
means nothing valid point we can extract

00:27:27,280 --> 00:27:32,230
the value and then we can do further

00:27:28,660 --> 00:27:35,410
matching on the extracted value alright

00:27:32,230 --> 00:27:38,530
so here's what we can do so let's say

00:27:35,410 --> 00:27:42,160
we've got some unique pointers nothing 5

00:27:38,530 --> 00:27:47,920
10 12 right we match on it if it's a

00:27:42,160 --> 00:27:49,990
five so some will act 5 basically we

00:27:47,920 --> 00:27:53,260
print out five we can extract the value

00:27:49,990 --> 00:27:56,670
from it print it out some by itself will

00:27:53,260 --> 00:28:00,400
give you basically this will be int int

00:27:56,670 --> 00:28:02,740
ampersand and actually that's yes and

00:28:00,400 --> 00:28:07,030
then it'll be a copy of it anyway I'll

00:28:02,740 --> 00:28:08,320
put it none means nothing and the order

00:28:07,030 --> 00:28:09,910
is important here if we have this at the

00:28:08,320 --> 00:28:12,490
first the other two whenever we never

00:28:09,910 --> 00:28:14,850
get through any questions about this

00:28:12,490 --> 00:28:14,850
example

00:28:15,160 --> 00:28:23,530
alright so we will go on so for now

00:28:19,720 --> 00:28:26,140
ignore this type right here class we

00:28:23,530 --> 00:28:29,890
will get back with that so basically we

00:28:26,140 --> 00:28:34,570
specialize matcher for some tea and then

00:28:29,890 --> 00:28:38,640
Bay so we basically defer to that match

00:28:34,570 --> 00:28:42,610
your class to to do the check in the get

00:28:38,640 --> 00:28:46,570
and the same thing for now we have a nun

00:28:42,610 --> 00:28:48,490
t-type will defer to that this is what

00:28:46,570 --> 00:28:53,740
it looks like I said ignore class we'll

00:28:48,490 --> 00:28:58,000
get back to that so check so basically

00:28:53,740 --> 00:28:59,320
for void void so that means we'll see

00:28:58,000 --> 00:29:01,230
what this means basically this means you

00:28:59,320 --> 00:29:06,370
do not pass any further patterns to it

00:29:01,230 --> 00:29:09,220
so it calls a pointer getter get pointer

00:29:06,370 --> 00:29:11,290
no cast forwarding this if that's a no

00:29:09,220 --> 00:29:13,930
point it returns false otherwise returns

00:29:11,290 --> 00:29:18,340
true for here we call the same thing get

00:29:13,930 --> 00:29:24,070
point of no cast and we return basically

00:29:18,340 --> 00:29:27,100
at uppal with that pointer s2d tie if we

00:29:24,070 --> 00:29:29,230
have a matcher or a pattern with it we

00:29:27,100 --> 00:29:32,800
do the same thing except for the check

00:29:29,230 --> 00:29:35,650
we pass this on to the match check with

00:29:32,800 --> 00:29:38,410
that with the pointer as the value that

00:29:35,650 --> 00:29:41,410
we're testing and the match same thing

00:29:38,410 --> 00:29:55,420
with match get any questions about this

00:29:41,410 --> 00:29:57,460
yes correct exactly and like I said you

00:29:55,420 --> 00:30:03,850
know we're we're doing work twice but I

00:29:57,460 --> 00:30:07,600
said anyway so none the recall this is

00:30:03,850 --> 00:30:11,230
null for check and get just returns

00:30:07,600 --> 00:30:15,180
nothing all right so this is what it

00:30:11,230 --> 00:30:19,240
looks like for a pointer turn T naught T

00:30:15,180 --> 00:30:23,140
and then for use with it this is how we

00:30:19,240 --> 00:30:26,440
define none some with no parameters and

00:30:23,140 --> 00:30:28,580
some will you pass the matcher we pass a

00:30:26,440 --> 00:30:34,350
pattern

00:30:28,580 --> 00:30:48,660
any questions about any of this all

00:30:34,350 --> 00:30:50,940
right I'll go ahead have a question yeah

00:30:48,660 --> 00:30:53,880
that's a good good question the question

00:30:50,940 --> 00:30:57,570
was why we had an empty summon says some

00:30:53,880 --> 00:30:59,580
with the placeholder I guess I felt like

00:30:57,570 --> 00:31:02,760
it that day and just just just short of

00:30:59,580 --> 00:31:04,710
thing you know that so yeah I guess this

00:31:02,760 --> 00:31:07,650
was you know just the some non common

00:31:04,710 --> 00:31:10,350
case that may be useful but like i said

00:31:07,650 --> 00:31:17,340
it's it was basically more or less

00:31:10,350 --> 00:31:20,460
arbitrary any other questions all right

00:31:17,340 --> 00:31:23,280
so let's say instead Pat you want to

00:31:20,460 --> 00:31:26,700
actually do unique pointer instead of

00:31:23,280 --> 00:31:29,100
just you know then nothing got get same

00:31:26,700 --> 00:31:30,810
example as before so we just specialized

00:31:29,100 --> 00:31:32,910
unique pointer and there's a

00:31:30,810 --> 00:31:35,850
specialization 4shared pointer to so

00:31:32,910 --> 00:31:38,490
this the same code right here will work

00:31:35,850 --> 00:31:42,300
whether you pass it a unique pointer a

00:31:38,490 --> 00:31:46,230
shared pointer a raw pointer same

00:31:42,300 --> 00:31:49,140
pattern all right okay let's have some

00:31:46,230 --> 00:31:50,940
pump some with fun all right so let's

00:31:49,140 --> 00:31:53,460
say we have a base class called holder

00:31:50,940 --> 00:31:55,800
and then we have a template whole dirty

00:31:53,460 --> 00:32:00,900
that takes the type stores it and then

00:31:55,800 --> 00:32:03,810
the Rye is derived from holder okay we

00:32:00,900 --> 00:32:05,850
specialize the simple match gift I have

00:32:03,810 --> 00:32:10,140
a temple match get tuple just a little

00:32:05,850 --> 00:32:15,180
helper function alright so let's say you

00:32:10,140 --> 00:32:19,250
make holder 5 10 and 3.4 and then

00:32:15,180 --> 00:32:23,720
nothing so then we can basically say

00:32:19,250 --> 00:32:30,300
extract out of here only if this type is

00:32:23,720 --> 00:32:32,460
holder int extractive holder int some

00:32:30,300 --> 00:32:36,870
extract if it's anything so this will be

00:32:32,460 --> 00:32:40,120
a constant holder and it's consider

00:32:36,870 --> 00:32:42,340
holder and X and then if it's nothing

00:32:40,120 --> 00:32:45,660
and then we can do further pattern

00:32:42,340 --> 00:32:50,590
matching we can match you this in 25 or

00:32:45,660 --> 00:33:05,320
if if you want to extract an X and you

00:32:50,590 --> 00:33:11,430
go ahead Kurt correct yeah correct the

00:33:05,320 --> 00:33:11,430
with the summon the not correct yes

00:33:14,040 --> 00:33:19,060
alright this is how we do it so this is

00:33:16,270 --> 00:33:21,190
the class that we had before so

00:33:19,060 --> 00:33:23,830
basically our check and get exactly the

00:33:21,190 --> 00:33:25,710
same except instead of calling get

00:33:23,830 --> 00:33:33,670
pointer no cast we call get pointer

00:33:25,710 --> 00:33:35,560
class right here and here same same for

00:33:33,670 --> 00:33:39,160
the type without the matter the

00:33:35,560 --> 00:33:41,740
controversial type here alright and this

00:33:39,160 --> 00:33:45,010
is the full specialization for a pointer

00:33:41,740 --> 00:33:47,320
so we're using dynamic cast I think

00:33:45,010 --> 00:33:48,880
there's probably performance issues with

00:33:47,320 --> 00:33:51,010
this one but like i said the focus was

00:33:48,880 --> 00:33:54,840
on simplicity and clarity at this point

00:33:51,010 --> 00:34:00,550
instead of performance optimization and

00:33:54,840 --> 00:34:01,870
then is no all right and this is the

00:34:00,550 --> 00:34:05,770
whole class of functions that you can

00:34:01,870 --> 00:34:09,330
use with it so you can specify what

00:34:05,770 --> 00:34:13,860
class you want to do to extract out

00:34:09,330 --> 00:34:13,860
alright any questions about any of this

00:34:16,680 --> 00:34:25,330
alright next we're going to talk about

00:34:19,650 --> 00:34:27,160
integrating with the boost libraries so

00:34:25,330 --> 00:34:30,760
here's that safety of function using

00:34:27,160 --> 00:34:32,970
boost optional and this is actually in

00:34:30,760 --> 00:34:37,230
the standard now is STD optional correct

00:34:32,970 --> 00:34:41,350
leave at least in like a TS experimental

00:34:37,230 --> 00:34:45,610
expl not 14 right but potential

00:34:41,350 --> 00:34:49,180
potential 17 experimental so example has

00:34:45,610 --> 00:34:52,330
a match to if we're dividing by 0 return

00:34:49,180 --> 00:34:54,330
nothing here otherwise return x divided

00:34:52,330 --> 00:35:02,380
by y

00:34:54,330 --> 00:35:04,330
some nut to the optional thing and we

00:35:02,380 --> 00:35:08,349
can do safety for two I said you could

00:35:04,330 --> 00:35:11,280
do underscore X here this is how this

00:35:08,349 --> 00:35:15,190
and this is the specialization for boost

00:35:11,280 --> 00:35:17,710
what's so the pointer no cast so this

00:35:15,190 --> 00:35:19,150
notice this does not have the the get

00:35:17,710 --> 00:35:22,390
pointer that takes a class because

00:35:19,150 --> 00:35:25,630
there's no way like you know generic way

00:35:22,390 --> 00:35:27,910
like extract it out of out of optional

00:35:25,630 --> 00:35:34,750
so that will fail only if you have like

00:35:27,910 --> 00:35:37,660
uh some with a template parameter all

00:35:34,750 --> 00:35:43,150
right remember whole dirty whole dirty

00:35:37,660 --> 00:35:46,240
is a poor man's version of what yes

00:35:43,150 --> 00:35:47,859
boost any any is able to hold any type

00:35:46,240 --> 00:35:50,530
allows you to create an extract the type

00:35:47,859 --> 00:35:54,550
which is previously stored so we can

00:35:50,530 --> 00:35:57,640
then specialized specify this for any so

00:35:54,550 --> 00:36:01,750
any 510 basically if it's an integer

00:35:57,640 --> 00:36:04,510
extracted out same thing here with the

00:36:01,750 --> 00:36:08,940
cement none we can do we can do even

00:36:04,510 --> 00:36:13,210
more stuff but if we wanted to further

00:36:08,940 --> 00:36:16,359
and this is our specialization so get

00:36:13,210 --> 00:36:20,589
pointer so boost anycast if you pass it

00:36:16,359 --> 00:36:22,210
like any star it'll return a null

00:36:20,589 --> 00:36:27,280
pointer on failure instead of throwing

00:36:22,210 --> 00:36:31,510
an exception and then we just is no

00:36:27,280 --> 00:36:39,720
checks if it's empty alright this is the

00:36:31,510 --> 00:36:39,720
last one I promise anyway no that is yes

00:36:44,440 --> 00:36:48,040
so I was pretty bad that's the last one

00:36:45,940 --> 00:36:50,140
no more all right everybody familiar

00:36:48,040 --> 00:36:51,970
with boost variant so it's a type-safe

00:36:50,140 --> 00:36:55,660
Union it allows you to store one of a

00:36:51,970 --> 00:36:58,480
set of types one of the setup types and

00:36:55,660 --> 00:37:01,540
get back what you stored it can be

00:36:58,480 --> 00:37:04,480
recursive and common example for example

00:37:01,540 --> 00:37:10,569
is JSON where you can have no numbers

00:37:04,480 --> 00:37:13,030
string object or any so just a little

00:37:10,569 --> 00:37:15,640
bit of diversion into algebraic data

00:37:13,030 --> 00:37:19,540
types if you really wanted to learn

00:37:15,640 --> 00:37:22,079
about them David's talk yesterday was a

00:37:19,540 --> 00:37:26,170
great thing he went through the whole a

00:37:22,079 --> 00:37:28,540
whole thing from 0 to 12 product to some

00:37:26,170 --> 00:37:30,180
and with a bunch of math symbols in

00:37:28,540 --> 00:37:34,510
there too I don't have any math symbols

00:37:30,180 --> 00:37:36,310
just real small just real simple so

00:37:34,510 --> 00:37:38,710
basically a some type is either a union

00:37:36,310 --> 00:37:41,170
or variant and a product type is a

00:37:38,710 --> 00:37:42,750
structure tuple and then we can use

00:37:41,170 --> 00:37:47,470
pattern matching to break down the

00:37:42,750 --> 00:37:52,359
abstract break it down further this is

00:37:47,470 --> 00:37:55,900
the rust example so we have basically

00:37:52,359 --> 00:37:57,640
this is the some type and these are

00:37:55,900 --> 00:37:59,140
product type so it's the sum of products

00:37:57,640 --> 00:38:02,800
and you can break it and pull it out

00:37:59,140 --> 00:38:06,400
what you want so this is going to be our

00:38:02,800 --> 00:38:09,250
boost variant example so just a very

00:38:06,400 --> 00:38:16,260
very simple integer expression thing

00:38:09,250 --> 00:38:16,260
with add sub neg and mall so we create

00:38:17,040 --> 00:38:24,849
all right anyway so to create this

00:38:21,900 --> 00:38:27,579
variant I think I change the slide so

00:38:24,849 --> 00:38:31,000
expression same thing basically variant

00:38:27,579 --> 00:38:35,050
recursive wrapper and then we add and

00:38:31,000 --> 00:38:37,720
then we define the actual class of the

00:38:35,050 --> 00:38:43,240
structs themselves same is what we did

00:38:37,720 --> 00:38:45,700
at the beginning and then here's our

00:38:43,240 --> 00:38:47,140
match so we can match on the expression

00:38:45,700 --> 00:38:51,180
to make this actually should be math

00:38:47,140 --> 00:38:56,200
variant t and then we can extract some

00:38:51,180 --> 00:38:56,700
sub mole or an integer and extract the

00:38:56,200 --> 00:39:01,140
variables

00:38:56,700 --> 00:39:06,359
out of there this is our specialization

00:39:01,140 --> 00:39:13,200
for variant just get pointer we just

00:39:06,359 --> 00:39:16,740
call boost get and we pass it the if we

00:39:13,200 --> 00:39:20,670
pass it a variant star then we get back

00:39:16,740 --> 00:39:34,530
a note point of that fails sure right

00:39:20,670 --> 00:39:37,020
here all right and then X multi methods

00:39:34,530 --> 00:39:40,170
so simple example paper rock scissors

00:39:37,020 --> 00:39:41,490
right all derived from a base this candy

00:39:40,170 --> 00:39:44,310
apple full bunch of stuff say like

00:39:41,490 --> 00:39:46,440
collisions or different I guess

00:39:44,310 --> 00:39:50,960
collisions is also like another example

00:39:46,440 --> 00:39:55,589
for it so basically paper rock scissors

00:39:50,960 --> 00:39:59,310
you can tie that's couple and then you

00:39:55,589 --> 00:40:03,690
can do some paper some paper rock and so

00:39:59,310 --> 00:40:05,819
on for the next seven more any other

00:40:03,690 --> 00:40:23,609
questions about everything that we've

00:40:05,819 --> 00:40:32,190
done so far yes I did not do I I'd no I

00:40:23,609 --> 00:40:37,520
did not all right exhaustive pattern so

00:40:32,190 --> 00:40:37,520
what happens if we forget multiplication

00:40:38,510 --> 00:40:43,530
so pattern exhaustive pneus you make

00:40:42,180 --> 00:40:45,960
sure that the pattern match covers all

00:40:43,530 --> 00:40:48,750
possibilities hask I believe throws a

00:40:45,960 --> 00:40:53,280
runtime error Russ does exhaustive

00:40:48,750 --> 00:40:56,760
patterns at compile time so this is a

00:40:53,280 --> 00:40:58,980
non-exhaustive pattern so this is the

00:40:56,760 --> 00:41:04,710
error message we get with visual c++

00:40:58,980 --> 00:41:08,950
2015 when when we mess that up and GCC

00:41:04,710 --> 00:41:12,310
5.1 so how do we do that

00:41:08,950 --> 00:41:15,040
it's not really magic basically so

00:41:12,310 --> 00:41:17,170
here's how we do it will go over kind of

00:41:15,040 --> 00:41:18,849
quickly so we take this match so

00:41:17,170 --> 00:41:20,530
basically the previous match that we had

00:41:18,849 --> 00:41:22,540
before we'll move it to detail and

00:41:20,530 --> 00:41:26,079
rename it match helper so this right

00:41:22,540 --> 00:41:30,010
here is the previous match helper so we

00:41:26,079 --> 00:41:32,320
extract all the argument types we look

00:41:30,010 --> 00:41:35,079
up a customization exhaustion checker

00:41:32,320 --> 00:41:37,240
see what the type is and then we pass

00:41:35,079 --> 00:41:41,740
the argument types to the checker and

00:41:37,240 --> 00:41:43,300
then we assert on checker value so

00:41:41,740 --> 00:41:48,730
extracting out all the argument ice

00:41:43,300 --> 00:41:51,130
basically return a couple with you know

00:41:48,730 --> 00:42:01,530
with just the pattern types ignoring all

00:41:51,130 --> 00:42:03,940
the f's and then here come down to here

00:42:01,530 --> 00:42:07,180
so and then we have this fast for some

00:42:03,940 --> 00:42:09,990
exhaustive pneus so in the type we check

00:42:07,180 --> 00:42:11,920
if it has otherwise if it's otherwise

00:42:09,990 --> 00:42:13,720
basically we're done we basically

00:42:11,920 --> 00:42:15,790
specialized for something says return

00:42:13,720 --> 00:42:18,550
true cuz if it otherwise there's always

00:42:15,790 --> 00:42:21,190
an exhaustive match and then we have a

00:42:18,550 --> 00:42:23,200
sum exhaustion as helper here which is

00:42:21,190 --> 00:42:26,770
specialized for false where there is no

00:42:23,200 --> 00:42:29,589
otherwise we extract all the some

00:42:26,770 --> 00:42:31,770
classes we get that as a couple and then

00:42:29,589 --> 00:42:34,240
we call there's a helper function which

00:42:31,770 --> 00:42:36,400
which it's not in the slides but

00:42:34,240 --> 00:42:37,930
basically it checks that all the

00:42:36,400 --> 00:42:40,329
required types or in all the some

00:42:37,930 --> 00:42:42,400
classes it's just matter of some

00:42:40,329 --> 00:42:46,930
template metaprogramming have a value

00:42:42,400 --> 00:42:52,990
there and have a value here then for

00:42:46,930 --> 00:42:55,329
variant we have this helper fun helper

00:42:52,990 --> 00:42:57,640
function here we extract all the variant

00:42:55,329 --> 00:42:59,410
types and then depending on which

00:42:57,640 --> 00:43:02,260
compiler you have and what the things

00:42:59,410 --> 00:43:03,760
are I know with you had like it's either

00:43:02,260 --> 00:43:06,430
the very addicts or else you might have

00:43:03,760 --> 00:43:08,140
some I think they there's a boost no

00:43:06,430 --> 00:43:09,700
type or something that's appended to the

00:43:08,140 --> 00:43:12,430
end for those ones so we just discard

00:43:09,700 --> 00:43:17,589
those for these ones get that as a

00:43:12,430 --> 00:43:20,020
couple and then basically map some

00:43:17,589 --> 00:43:22,200
exhaustive pneus to the type that we're

00:43:20,020 --> 00:43:22,200
using

00:43:23,250 --> 00:43:30,160
so this is all available at j bank

00:43:26,260 --> 00:43:32,650
github gee abanilla simple match and as

00:43:30,160 --> 00:43:34,450
my daughter says most of the fun

00:43:32,650 --> 00:43:36,970
building stuff is actually being able to

00:43:34,450 --> 00:43:38,470
talk about it with other people so thank

00:43:36,970 --> 00:43:40,450
you all very much for attending this and

00:43:38,470 --> 00:43:42,310
giving me the privilege of talking about

00:43:40,450 --> 00:43:57,930
it and i'll be happy to take any other

00:43:42,310 --> 00:43:57,930
questions thank you sure yes go ahead

00:44:09,690 --> 00:44:19,930
correct no it does not support that yeah

00:44:18,460 --> 00:44:21,460
I actually I actually thought about that

00:44:19,930 --> 00:44:23,680
so is having pair pair we're both of the

00:44:21,460 --> 00:44:26,140
same type instead of having to do the

00:44:23,680 --> 00:44:28,150
placeholder X what I thought about doing

00:44:26,140 --> 00:44:29,640
was basically at the function level you

00:44:28,150 --> 00:44:31,690
declare like a variable called

00:44:29,640 --> 00:44:34,510
unification variable and you give it a

00:44:31,690 --> 00:44:36,700
type and then that type you'd pass you

00:44:34,510 --> 00:44:38,950
know say X and then you pass that X is

00:44:36,700 --> 00:44:40,480
the pear pear and the first time it did

00:44:38,950 --> 00:44:42,670
it it would it would basically be like

00:44:40,480 --> 00:44:44,650
have a boolean say hey whether I've been

00:44:42,670 --> 00:44:46,450
it's basically like an optional in there

00:44:44,650 --> 00:44:48,430
right whether it's been said or not if

00:44:46,450 --> 00:44:51,730
it's not been set you set it to whatever

00:44:48,430 --> 00:44:53,290
value you have if it has been set you

00:44:51,730 --> 00:44:55,600
compare it and then you returned to her

00:44:53,290 --> 00:44:59,860
false so I think that's the way you

00:44:55,600 --> 00:45:05,640
could go about doing that that makes

00:44:59,860 --> 00:45:05,640
sense to any other go ahead

00:45:07,270 --> 00:45:12,710
what about like usually you have like

00:45:10,210 --> 00:45:17,300
bases there are classes yes you would

00:45:12,710 --> 00:45:32,540
expect ability where you match when it

00:45:17,300 --> 00:45:39,920
arrives gloss and you have a case okay

00:45:32,540 --> 00:45:53,000
um correct okay so pointer holder say or

00:45:39,920 --> 00:46:09,920
you're talking okay that was that it yes

00:45:53,000 --> 00:46:17,750
I need to go up already so this will

00:46:09,920 --> 00:46:34,490
right here let's see you're talking

00:46:17,750 --> 00:46:37,340
about right okay and then add arrive

00:46:34,490 --> 00:46:40,760
they'll be derived from here correct I

00:46:37,340 --> 00:46:43,100
believe you could because this takes it

00:46:40,760 --> 00:46:45,140
by reference there and that's the drip

00:46:43,100 --> 00:46:46,820
and I believe that when match here but

00:46:45,140 --> 00:46:50,230
you'd only get the first two out unless

00:46:46,820 --> 00:46:50,230
you specialize it for the other one

00:46:55,750 --> 00:47:00,190
right but I think this may catch it here

00:46:58,700 --> 00:47:02,660
and then you could go from there but

00:47:00,190 --> 00:47:05,020
yeah they'll be definitely something i

00:47:02,660 --> 00:47:05,020
can check

00:47:12,250 --> 00:47:41,540
right I guess the only thing I was doing

00:47:37,220 --> 00:47:43,010
is I kind of like this this format in

00:47:41,540 --> 00:47:45,320
terms of you know with the comma

00:47:43,010 --> 00:47:47,180
separated you in terms of in terms

00:47:45,320 --> 00:47:50,480
instead of that then I guess without the

00:47:47,180 --> 00:48:29,960
stylistic choice that that was the main

00:47:50,480 --> 00:48:32,750
reason ok ok I guess the only advantage

00:48:29,960 --> 00:48:35,180
this can be more complicated than just

00:48:32,750 --> 00:48:38,710
you know straight up arguments like it

00:48:35,180 --> 00:48:38,710
could be X is less than one and then

00:49:14,750 --> 00:49:33,369
so you're talking

00:49:16,359 --> 00:49:37,299
so this one right here yeah you could so

00:49:33,369 --> 00:49:39,579
x and y or actually so they'll give you

00:49:37,299 --> 00:49:42,390
this expression e so then you could

00:49:39,579 --> 00:49:48,910
actually put like a des in here and then

00:49:42,390 --> 00:49:54,670
so you could do d s XY so W X Y Z you

00:49:48,910 --> 00:50:03,069
could do that if you want to do would be

00:49:54,670 --> 00:50:05,170
X Y W X Y Z linear lies yeah everything

00:50:03,069 --> 00:50:39,009
I linear lives no matter how deep this

00:50:05,170 --> 00:50:42,220
is over here basically you just a matter

00:50:39,009 --> 00:50:47,619
of specializing simple mats customizer

00:50:42,220 --> 00:50:48,849
matcher define the type and then for

00:50:47,619 --> 00:50:50,950
example you have to find a match to type

00:50:48,849 --> 00:50:52,420
and whatever type you want and then you

00:50:50,950 --> 00:50:55,680
can do whatever processing you want as

00:50:52,420 --> 00:50:55,680
long as you can do a check and again

00:50:57,839 --> 00:51:05,720
sure and then the

00:51:03,950 --> 00:51:07,520
thing like I said like you know for what

00:51:05,720 --> 00:51:10,040
I thought about those like like the end

00:51:07,520 --> 00:51:13,520
k plus 1 patterns things like that i can

00:51:10,040 --> 00:51:20,540
do that as an example any other

00:51:13,520 --> 00:51:22,900
questions comments all right thank you

00:51:20,540 --> 00:51:22,900

YouTube URL: https://www.youtube.com/watch?v=9IVCVSwn-fI


