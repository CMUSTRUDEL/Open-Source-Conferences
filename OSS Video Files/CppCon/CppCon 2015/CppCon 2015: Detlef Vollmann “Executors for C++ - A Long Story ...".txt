Title: CppCon 2015: Detlef Vollmann “Executors for C++ - A Long Story ..."
Publication date: 2015-10-11
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Detlef Vollmann “Executors for C++ - A Long Story Stuggling for a Base Concurrency Building Block”
--
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Executors will be a base building block in C++ for asynchronous, concurrent and parallel work. The job of an executor is simple: run the tasks that are posted. So the first proposals for executors in C++ had a very simple interface. However, being a building block, the executor should provide an interface that's useful for all kind of higher level abstractions and needs to work together with different types of concurrency, like co-operative multi-tasking or GPU like hardware. This presentation will look at the evolution of the executor proposals for C++ and what they'll provide for normal application programmers.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:11,940
this is to talk about executors for C++

00:00:03,770 --> 00:00:16,440
it's not how to use them it's what they

00:00:11,940 --> 00:00:23,670
can do for you and how hard it actually

00:00:16,440 --> 00:00:26,550
is to get executed right and it's called

00:00:23,670 --> 00:00:31,009
a long story and that long story hasn't

00:00:26,550 --> 00:00:38,160
ended yet so we don't have a final

00:00:31,009 --> 00:00:42,989
executor interface yet in C++ so what's

00:00:38,160 --> 00:00:47,910
the mission of an executor well some of

00:00:42,989 --> 00:00:50,160
you may know the async problem so if you

00:00:47,910 --> 00:00:55,160
look at the code and so with a set up

00:00:50,160 --> 00:01:00,239
here is not very optimal um who of you

00:00:55,160 --> 00:01:09,630
believes that this will put out hello

00:01:00,239 --> 00:01:12,979
world okay who of you think it will put

00:01:09,630 --> 00:01:12,979
out hello

00:01:15,439 --> 00:01:23,460
who of you think it will put out just

00:01:19,259 --> 00:01:28,320
college and or just a mix of those

00:01:23,460 --> 00:01:30,799
letters and who of you think it's just

00:01:28,320 --> 00:01:30,799
undefined

00:01:30,829 --> 00:01:35,700
okay daiva actually very few of the

00:01:33,930 --> 00:01:41,360
right answer because the right answer is

00:01:35,700 --> 00:01:45,750
it will guarantee put out hello world

00:01:41,360 --> 00:01:48,210
and that is not really known to a lot of

00:01:45,750 --> 00:01:51,049
people you have absolutely no

00:01:48,210 --> 00:01:51,049
concurrency here

00:01:51,960 --> 00:02:03,450
and the reason for that and that is a

00:01:56,159 --> 00:02:06,330
little bit the scientists the acing

00:02:03,450 --> 00:02:11,790
problem and the a thing actually that

00:02:06,330 --> 00:02:15,410
turns the future and normally these

00:02:11,790 --> 00:02:18,959
structures of the futures don't block

00:02:15,410 --> 00:02:21,380
except if the future comes from an

00:02:18,959 --> 00:02:21,380
amazing

00:02:21,620 --> 00:02:32,160
so in our code here well we don't

00:02:26,040 --> 00:02:37,880
actually capture the return value so you

00:02:32,160 --> 00:02:41,430
get a future out of the a think and well

00:02:37,880 --> 00:02:43,860
you don't capture their future so the

00:02:41,430 --> 00:02:52,850
destruct of their future is immediately

00:02:43,860 --> 00:02:57,150
called and the destructor blocks for the

00:02:52,850 --> 00:03:03,170
ending of the task and so you get

00:02:57,150 --> 00:03:07,860
absolutely no concurrency here and that

00:03:03,170 --> 00:03:10,110
is actually good because lifetime

00:03:07,860 --> 00:03:14,489
control is very important for the class

00:03:10,110 --> 00:03:17,220
class this is what makes c++ different

00:03:14,489 --> 00:03:20,600
from all those managed languages like C

00:03:17,220 --> 00:03:24,239
sharp or to our board or anything else

00:03:20,600 --> 00:03:26,430
and the problems with the a thing is you

00:03:24,239 --> 00:03:29,850
have absolutely no control about the

00:03:26,430 --> 00:03:36,780
execution agent agent that actually once

00:03:29,850 --> 00:03:40,350
your task and so you have no idea how

00:03:36,780 --> 00:03:45,930
long it actually wants and if their task

00:03:40,350 --> 00:03:49,380
actually uses references some of objects

00:03:45,930 --> 00:03:51,650
that are also used otherwise but you

00:03:49,380 --> 00:03:57,030
wouldn't need to know when it actually

00:03:51,650 --> 00:03:58,859
finishes to use those objects and this

00:03:57,030 --> 00:04:03,449
is why we have the blocking the blogging

00:03:58,859 --> 00:04:04,260
is actually good the problem is that we

00:04:03,449 --> 00:04:07,800
have

00:04:04,260 --> 00:04:10,260
for a future different behavior under

00:04:07,800 --> 00:04:13,230
destructor whether it comes from an

00:04:10,260 --> 00:04:15,750
async or from some grounds and the

00:04:13,230 --> 00:04:23,430
reason for that is well you simply have

00:04:15,750 --> 00:04:29,610
nothing to control when the lifetime of

00:04:23,430 --> 00:04:33,210
your async or of the task ends so that

00:04:29,610 --> 00:04:38,520
is why the ocean a thing is not really

00:04:33,210 --> 00:04:41,610
optimal another motivation motivation

00:04:38,520 --> 00:04:45,090
pipelines we actually had a proposal for

00:04:41,610 --> 00:04:48,889
that and well the example here comes

00:04:45,090 --> 00:04:53,039
from an old oops lab work shop how to

00:04:48,889 --> 00:04:56,880
pretend concurrency to students and so

00:04:53,039 --> 00:04:59,820
the exercise is actually okay you have a

00:04:56,880 --> 00:05:03,870
restaurant and you have number of orders

00:04:59,820 --> 00:05:06,600
coming in and then you have some chefs

00:05:03,870 --> 00:05:10,650
who could prepare the meals and then you

00:05:06,600 --> 00:05:13,349
have some waiters who actually deliver

00:05:10,650 --> 00:05:16,530
those meals and if there is nothing to

00:05:13,349 --> 00:05:20,310
do anymore everything else and this can

00:05:16,530 --> 00:05:23,490
easily be with using that pipeline

00:05:20,310 --> 00:05:25,110
proposal so you say you have Swiss chefs

00:05:23,490 --> 00:05:28,620
and for waiters and the orders

00:05:25,110 --> 00:05:33,470
conveniently orders come in to some

00:05:28,620 --> 00:05:36,330
communication mechanism to the chefs and

00:05:33,470 --> 00:05:40,550
the meals prepared part by the chef's

00:05:36,330 --> 00:05:45,240
comes with some communication mechanisms

00:05:40,550 --> 00:05:49,050
to the waiters and then eventually it

00:05:45,240 --> 00:05:57,510
ends and this can be won on a sweat pool

00:05:49,050 --> 00:06:01,520
on something else so what actually are

00:05:57,510 --> 00:06:06,650
the requirements for the executors well

00:06:01,520 --> 00:06:10,160
to hunt ours and to give some control

00:06:06,650 --> 00:06:10,160
about lifetime

00:06:12,180 --> 00:06:23,650
well so we got a very simple kaposin

00:06:17,350 --> 00:06:26,590
originally net came from Google that

00:06:23,650 --> 00:06:28,840
there was yeah somehow a similar purpose

00:06:26,590 --> 00:06:34,630
of Microsoft and eventually they just

00:06:28,840 --> 00:06:38,740
joined the proposal and so the executor

00:06:34,630 --> 00:06:46,630
interface well it wasn't a face class

00:06:38,740 --> 00:06:49,990
and it had one function just to put a

00:06:46,630 --> 00:06:54,250
new task to the executor and the execute

00:06:49,990 --> 00:06:56,050
eventually execute their task and as

00:06:54,250 --> 00:06:57,760
usual if you get some requirements to

00:06:56,050 --> 00:07:00,130
programmers they will give you more than

00:06:57,760 --> 00:07:01,990
you actually asked for maybe not exactly

00:07:00,130 --> 00:07:04,210
what you asked for but they will give

00:07:01,990 --> 00:07:08,080
you something so you also got the

00:07:04,210 --> 00:07:09,430
Commission initiated task count net

00:07:08,080 --> 00:07:14,710
turns ought to be pretty useful

00:07:09,430 --> 00:07:17,320
sometimes so that was nice that is not

00:07:14,710 --> 00:07:21,010
really the virtual interface but that is

00:07:17,320 --> 00:07:26,400
what it boiled on to and then we had a

00:07:21,010 --> 00:07:34,210
default executor and some mechanism to

00:07:26,400 --> 00:07:40,960
set the default executors oh that sounds

00:07:34,210 --> 00:07:43,389
nice and then the proposal also proposed

00:07:40,960 --> 00:07:46,180
some concrete executors not only the

00:07:43,389 --> 00:07:48,880
interface but also some real executors

00:07:46,180 --> 00:07:54,520
that actually do some work of course at

00:07:48,880 --> 00:07:58,450
that pool the last serial executor this

00:07:54,520 --> 00:08:00,570
just one one task after the other on the

00:07:58,450 --> 00:08:05,260
same threat but on a different thread

00:08:00,570 --> 00:08:07,720
then the caller the inline executor well

00:08:05,260 --> 00:08:12,849
that actually calls the function right

00:08:07,720 --> 00:08:14,830
away on your calling thread and the loop

00:08:12,849 --> 00:08:17,289
executor is something in between but

00:08:14,830 --> 00:08:19,539
it's also serial and then you have this

00:08:17,289 --> 00:08:21,700
great executor that just spawned of a

00:08:19,539 --> 00:08:23,160
new task a new set for each two

00:08:21,700 --> 00:08:28,480
allocated

00:08:23,160 --> 00:08:30,730
and those are actually interesting

00:08:28,480 --> 00:08:35,380
because they have completely different

00:08:30,730 --> 00:08:37,690
semantics concurrency wise the set

00:08:35,380 --> 00:08:40,090
executors which justice spawns a new

00:08:37,690 --> 00:08:43,680
threat for each task well that is a

00:08:40,090 --> 00:08:48,070
really concurrent the serial executor

00:08:43,680 --> 00:08:52,630
isn't really concurrent because it does

00:08:48,070 --> 00:08:57,130
one pass over the other nowadays we call

00:08:52,630 --> 00:08:58,089
that it has parallel execution semantics

00:08:57,130 --> 00:09:00,520
and that is a little bit

00:08:58,089 --> 00:09:03,910
counterintuitive parallel means it can

00:09:00,520 --> 00:09:09,850
actually be cereal while concurrent

00:09:03,910 --> 00:09:16,360
means it has to be in parallel this is

00:09:09,850 --> 00:09:18,370
how it is yeah the point is parallel

00:09:16,360 --> 00:09:20,980
runs on as many calls as you have and if

00:09:18,370 --> 00:09:29,220
you have only one core you don't get any

00:09:20,980 --> 00:09:32,770
authority yeah

00:09:29,220 --> 00:09:36,940
so with that proposes we can actually

00:09:32,770 --> 00:09:40,990
solve the icing problem so we can either

00:09:36,940 --> 00:09:43,570
define new launch policy say don't

00:09:40,990 --> 00:09:51,160
execute and put one on the default

00:09:43,570 --> 00:09:53,770
executors well maybe that's not such a

00:09:51,160 --> 00:09:56,260
great idea baby because it sometimes

00:09:53,770 --> 00:09:58,839
really makes a difference because you

00:09:56,260 --> 00:10:01,089
have the set default executors you have

00:09:58,839 --> 00:10:03,339
no idea what guarantees you actually get

00:10:01,089 --> 00:10:08,410
from the executor is it a concurrent one

00:10:03,339 --> 00:10:11,830
or just a parallel one and well but

00:10:08,410 --> 00:10:15,550
anyway you could use that one and even

00:10:11,830 --> 00:10:20,110
the normal standard async could use the

00:10:15,550 --> 00:10:22,540
default executor but it still has to

00:10:20,110 --> 00:10:27,550
block on the future destructor because

00:10:22,540 --> 00:10:29,680
this is what people expect now and as I

00:10:27,550 --> 00:10:33,100
said sometimes it's very important that

00:10:29,680 --> 00:10:36,100
you know then the lifetime of your

00:10:33,100 --> 00:10:39,220
thoughts has finish finished so you can

00:10:36,100 --> 00:10:44,050
just clean up all the global objects it

00:10:39,220 --> 00:10:47,019
might use and the most important

00:10:44,050 --> 00:10:50,740
interface would be the last one you just

00:10:47,019 --> 00:10:57,009
give it the specific executor you want

00:10:50,740 --> 00:10:59,170
to run the task on so that's nice if you

00:10:57,009 --> 00:11:04,120
look at the pipelines well this can

00:10:59,170 --> 00:11:12,490
really be implemented on the proposal as

00:11:04,120 --> 00:11:16,740
well so nice what result we have

00:11:12,490 --> 00:11:21,940
executors and that is why the

00:11:16,740 --> 00:11:28,079
concurrency study group decided to put

00:11:21,940 --> 00:11:31,899
this proposal into the concurrency tiers

00:11:28,079 --> 00:11:34,120
well we have used 15 minutes of the hour

00:11:31,899 --> 00:11:41,560
so you know it's not the end of the

00:11:34,120 --> 00:11:43,810
story because now the wheel discussion

00:11:41,560 --> 00:11:47,410
started well some of that already

00:11:43,810 --> 00:11:52,120
started before and one of the problems

00:11:47,410 --> 00:11:56,459
is the original propose just used an

00:11:52,120 --> 00:11:56,459
extract extract base class interface

00:11:56,579 --> 00:12:01,899
that actually is very useful it's not a

00:12:00,160 --> 00:12:07,569
template concept it's an actual base

00:12:01,899 --> 00:12:09,639
class it's not part of the time which is

00:12:07,569 --> 00:12:13,029
not really important for function but

00:12:09,639 --> 00:12:17,889
for structures that can be very

00:12:13,029 --> 00:12:19,480
important so we did that mistake I think

00:12:17,889 --> 00:12:21,160
it was a mistake with the containers

00:12:19,480 --> 00:12:24,160
that the allocate is actually part of

00:12:21,160 --> 00:12:30,790
the type and so we got scoped allocators

00:12:24,160 --> 00:12:34,029
in C++ 11 to work around that and so

00:12:30,790 --> 00:12:36,250
that is one point the executor if it's

00:12:34,029 --> 00:12:39,550
an extra base cause is not part of the

00:12:36,250 --> 00:12:43,060
time and the second thing is it can

00:12:39,550 --> 00:12:47,500
cause spinal interfaces so you can

00:12:43,060 --> 00:12:49,900
actually provide a lively that takes an

00:12:47,500 --> 00:12:52,390
executor

00:12:49,900 --> 00:12:55,420
and they're like we can be by the way

00:12:52,390 --> 00:12:57,580
only and it gets the executors it gets

00:12:55,420 --> 00:12:59,620
to the exit based art it knows what

00:12:57,580 --> 00:13:04,029
function it can call on that so

00:12:59,620 --> 00:13:07,450
everything is fine however sometimes it

00:13:04,029 --> 00:13:10,720
simply costs too much if you had it if

00:13:07,450 --> 00:13:14,890
you have a lot of very small tasks you

00:13:10,720 --> 00:13:17,020
don't want the overhead not only of one

00:13:14,890 --> 00:13:19,900
virtual function call but actually of to

00:13:17,020 --> 00:13:22,779
be because what you're at function

00:13:19,900 --> 00:13:26,080
actually takes it's a state function and

00:13:22,779 --> 00:13:29,470
that internally uses a virtual function

00:13:26,080 --> 00:13:32,080
call as well so we actually have two

00:13:29,470 --> 00:13:36,120
virtual function calls for each task

00:13:32,080 --> 00:13:43,540
that you startin that executor and

00:13:36,120 --> 00:13:47,529
sometimes that costs a lot and we got

00:13:43,540 --> 00:13:53,200
more requirements so one of them is

00:13:47,529 --> 00:13:56,529
stuck then so we have two then the ten

00:13:53,200 --> 00:14:00,190
proposals so the future to attend which

00:13:56,529 --> 00:14:04,240
is a continuation that the ones after

00:14:00,190 --> 00:14:07,300
that future is finish is ready so if

00:14:04,240 --> 00:14:12,150
your first house is has finished you

00:14:07,300 --> 00:14:15,970
know what you want to run after that and

00:14:12,150 --> 00:14:18,850
so you just startin anything with

00:14:15,970 --> 00:14:22,750
something and you this time you actually

00:14:18,850 --> 00:14:25,480
captured it you use that future that you

00:14:22,750 --> 00:14:29,700
get from the racing and yet when you say

00:14:25,480 --> 00:14:32,230
ok on this future you want to put

00:14:29,700 --> 00:14:38,709
continuation and that continuation

00:14:32,230 --> 00:14:39,580
should run on my specific executor okay

00:14:38,709 --> 00:14:43,120
that's fine

00:14:39,580 --> 00:14:45,820
that works with the old proposal the

00:14:43,120 --> 00:14:50,260
problem is if you don't give it an

00:14:45,820 --> 00:14:55,029
executor on which set should it

00:14:50,260 --> 00:14:58,060
preferably one well in a lot of cases it

00:14:55,029 --> 00:15:00,970
would be very useful if the continuation

00:14:58,060 --> 00:15:05,280
runs on the same sweat

00:15:00,970 --> 00:15:08,490
the original function the original task

00:15:05,280 --> 00:15:13,570
however how does the dot then know that

00:15:08,490 --> 00:15:19,780
if you don't control the whole library

00:15:13,570 --> 00:15:23,070
but only your very small things then you

00:15:19,780 --> 00:15:28,440
might have a problem to me to know that

00:15:23,070 --> 00:15:32,260
so you have no mechanism right now to

00:15:28,440 --> 00:15:34,710
transfer that information the previous

00:15:32,260 --> 00:15:39,040
proposal

00:15:34,710 --> 00:15:41,440
another thing is well I lives in the

00:15:39,040 --> 00:15:46,240
embedded world I'm just curious how many

00:15:41,440 --> 00:15:48,070
of you two embedded systems okay thanks

00:15:46,240 --> 00:15:49,810
interesting that would definitely be

00:15:48,070 --> 00:15:50,950
different in Switzerland for example

00:15:49,810 --> 00:15:53,200
because in Switzerland

00:15:50,950 --> 00:15:59,290
nearly all chief justices on embedded

00:15:53,200 --> 00:16:06,610
systems and sometimes I just have to use

00:15:59,290 --> 00:16:10,240
real-time and we talk priorities so we

00:16:06,610 --> 00:16:13,420
have something like the pipeline in this

00:16:10,240 --> 00:16:17,470
case it's just the data concentrator and

00:16:13,420 --> 00:16:23,320
it has two producers who wheat from data

00:16:17,470 --> 00:16:28,110
from two different devices and then we

00:16:23,320 --> 00:16:31,680
have a consumer that takes all the data

00:16:28,110 --> 00:16:35,410
does some calculations on those and

00:16:31,680 --> 00:16:38,680
finally we act on that one or stores it

00:16:35,410 --> 00:16:41,800
somewhere or whatever the main point

00:16:38,680 --> 00:16:44,080
here is you have to put use of that week

00:16:41,800 --> 00:16:46,180
from external devices and one of those

00:16:44,080 --> 00:16:49,240
devices doesn't really have an internal

00:16:46,180 --> 00:16:52,570
buffer so that really needs a very high

00:16:49,240 --> 00:16:54,670
priority so that you don't miss any data

00:16:52,570 --> 00:16:57,220
if it signals you okay

00:16:54,670 --> 00:17:00,340
data is available you really have to go

00:16:57,220 --> 00:17:02,380
for that data independent of all the

00:17:00,340 --> 00:17:05,020
other things that your core is currently

00:17:02,380 --> 00:17:07,660
doing so you need a very high priority

00:17:05,020 --> 00:17:11,050
on that one you don't really need high

00:17:07,660 --> 00:17:12,300
priority on the other ones so you want

00:17:11,050 --> 00:17:16,560
to run

00:17:12,300 --> 00:17:18,210
that concentrate concentrator well and

00:17:16,560 --> 00:17:21,860
one of the tasks has a different

00:17:18,210 --> 00:17:21,860
priority than the others

00:17:29,150 --> 00:17:39,630
next example a CEO who of you has

00:17:33,810 --> 00:17:41,430
already used boost a CEO oh so you know

00:17:39,630 --> 00:17:43,830
what I'm talking about so this is about

00:17:41,430 --> 00:17:46,350
asynchronous input output input output

00:17:43,830 --> 00:17:51,960
is asynchronous piety form by definition

00:17:46,350 --> 00:17:55,470
essentially and so this is really meant

00:17:51,960 --> 00:18:00,690
to be high-performance input-output

00:17:55,470 --> 00:18:05,280
library and so it generally wants to run

00:18:00,690 --> 00:18:09,110
the continuations of your i/o on the

00:18:05,280 --> 00:18:17,070
same set that the operating system

00:18:09,110 --> 00:18:18,900
returns from your i/o call and often you

00:18:17,070 --> 00:18:21,690
want to run concurrently but sometimes

00:18:18,900 --> 00:18:25,500
you actually want to run cooperatively

00:18:21,690 --> 00:18:28,640
on one single sweat so all your tasks

00:18:25,500 --> 00:18:32,330
don't have to synchronize anything and

00:18:28,640 --> 00:18:35,010
this is actually doable with a zero and

00:18:32,330 --> 00:18:37,860
it definitely doesn't want the overhead

00:18:35,010 --> 00:18:40,050
of the future because you just have to

00:18:37,860 --> 00:18:42,360
synchronize and if you want if you know

00:18:40,050 --> 00:18:44,730
you one of the singles Wed anyway well

00:18:42,360 --> 00:18:51,420
you don't want the overhead of the

00:18:44,730 --> 00:18:55,170
future and it wants well provides its

00:18:51,420 --> 00:18:58,530
own executor but it should also be able

00:18:55,170 --> 00:19:01,140
to run on user-defined executors which

00:18:58,530 --> 00:19:03,000
has additional knowledge about the

00:19:01,140 --> 00:19:07,380
system and maybe additional

00:19:03,000 --> 00:19:09,240
functionality so system specific

00:19:07,380 --> 00:19:11,610
asynchronous events like signaled

00:19:09,240 --> 00:19:13,770
interrupts mailboxes that you have some

00:19:11,610 --> 00:19:15,830
small embedded services and things like

00:19:13,770 --> 00:19:15,830
that

00:19:16,870 --> 00:19:24,830
well this is your live with actually

00:19:21,620 --> 00:19:27,980
videos by now and so there's a lot of

00:19:24,830 --> 00:19:30,650
experience with that one but of course

00:19:27,980 --> 00:19:35,710
that is very specific very specific

00:19:30,650 --> 00:19:35,710
requirements for asynchronous input on

00:19:36,730 --> 00:19:44,510
so now we have new requirements so we

00:19:40,550 --> 00:19:50,360
got new proposals so we were missing

00:19:44,510 --> 00:19:54,040
here and so the first proposal was

00:19:50,360 --> 00:19:58,130
actually by Chris Cole of based on Asia

00:19:54,040 --> 00:20:03,380
so if you had internally executors so he

00:19:58,130 --> 00:20:08,710
proposed just that and it has several

00:20:03,380 --> 00:20:13,130
interesting things one of them is it

00:20:08,710 --> 00:20:17,059
makes difference between the executors

00:20:13,130 --> 00:20:19,429
that you use as your interface and the

00:20:17,059 --> 00:20:23,480
execution context that actually holds

00:20:19,429 --> 00:20:26,360
all your stain the sweat if you have a

00:20:23,480 --> 00:20:29,600
thread pool you have to so that you have

00:20:26,360 --> 00:20:32,000
the queue with all the tasks to be run

00:20:29,600 --> 00:20:34,700
and so on there is a stage there is a

00:20:32,000 --> 00:20:38,120
very heavy very thing you don't want to

00:20:34,700 --> 00:20:41,290
copy that one you might want to move it

00:20:38,120 --> 00:20:46,220
but even though it might be pretty heavy

00:20:41,290 --> 00:20:48,380
but definitely not copier and the

00:20:46,220 --> 00:20:51,050
executor there is only a very very

00:20:48,380 --> 00:20:56,840
lightweight interface and handle to that

00:20:51,050 --> 00:21:01,070
one and but that is what you use as

00:20:56,840 --> 00:21:04,460
interface and he proposed several

00:21:01,070 --> 00:21:07,250
concrete executors the system executor

00:21:04,460 --> 00:21:10,010
which just start a new thread for each

00:21:07,250 --> 00:21:12,620
task the strength which is like to see

00:21:10,010 --> 00:21:18,200
you will execute or a thread pool of

00:21:12,620 --> 00:21:20,330
course and loop executor I have to admit

00:21:18,200 --> 00:21:23,900
I don't remember what this one exactly

00:21:20,330 --> 00:21:26,620
is only like the loop executors from the

00:21:23,900 --> 00:21:26,620
other proposal

00:21:26,630 --> 00:21:34,250
and it had a number of customisation

00:21:30,950 --> 00:21:37,730
points and that's interesting so one of

00:21:34,250 --> 00:21:45,139
the customisation points where the

00:21:37,730 --> 00:21:48,679
continuation tokens so you could

00:21:45,139 --> 00:21:51,820
actually use that to one the

00:21:48,679 --> 00:21:56,889
continuation of some IO

00:21:51,820 --> 00:22:00,409
atomically on the spec which did you IO

00:21:56,889 --> 00:22:02,899
so the continuation could be used

00:22:00,409 --> 00:22:06,230
synchronization as synchronization

00:22:02,899 --> 00:22:08,750
mechanism and yeah

00:22:06,230 --> 00:22:12,279
I think a better name for that would

00:22:08,750 --> 00:22:17,059
actually be synchronization - okay

00:22:12,279 --> 00:22:19,820
because it can also be used to define

00:22:17,059 --> 00:22:23,870
the concurrency mechanism that you use

00:22:19,820 --> 00:22:28,940
so he actually has also a continuation

00:22:23,870 --> 00:22:38,629
token that uses cooperative multitasking

00:22:28,940 --> 00:22:40,159
and just you this yield to wait for

00:22:38,629 --> 00:22:43,909
something right now to block for

00:22:40,159 --> 00:22:47,659
something and that yield then returns to

00:22:43,909 --> 00:22:53,000
your executor and that it can run

00:22:47,659 --> 00:22:55,309
something else the second customization

00:22:53,000 --> 00:22:58,639
point is she actually didn't have a

00:22:55,309 --> 00:23:04,120
single egg function but actually Sui

00:22:58,639 --> 00:23:06,730
functions this patch post and defer and

00:23:04,120 --> 00:23:11,480
if you look back to the original

00:23:06,730 --> 00:23:15,909
proposal they had an inline executor and

00:23:11,480 --> 00:23:18,500
a serial and all the other executors so

00:23:15,909 --> 00:23:23,480
the interesting thing of the inline

00:23:18,500 --> 00:23:28,149
executors was that it once a function

00:23:23,480 --> 00:23:32,649
the task right away so it actually locks

00:23:28,149 --> 00:23:32,649
for finishing that function

00:23:34,120 --> 00:23:40,870
and some people said well this might be

00:23:36,730 --> 00:23:45,460
very surprising to some of the people

00:23:40,870 --> 00:23:47,590
who use executors so that might not be a

00:23:45,460 --> 00:23:51,159
good idea so actually they actually

00:23:47,590 --> 00:23:53,980
dropped in line executors and said okay

00:23:51,159 --> 00:23:56,860
the eighth function is never allowed to

00:23:53,980 --> 00:23:59,799
block however sometimes it's actually

00:23:56,860 --> 00:24:03,730
useful to have such an inline executor

00:23:59,799 --> 00:24:06,250
so what Chris Colfer actually has

00:24:03,730 --> 00:24:09,970
proposed is to have a dispatch function

00:24:06,250 --> 00:24:13,090
which actually can do that it can run

00:24:09,970 --> 00:24:19,659
the function right away so it can

00:24:13,090 --> 00:24:23,020
actually block your caller until the

00:24:19,659 --> 00:24:26,649
task is done it doesn't have to but it

00:24:23,020 --> 00:24:28,630
can do that so that from the behavior

00:24:26,649 --> 00:24:30,909
definitely the different interface then

00:24:28,630 --> 00:24:33,669
the post function which is the newest

00:24:30,909 --> 00:24:36,880
one to the edge function so post is just

00:24:33,669 --> 00:24:39,909
okay here's a new task want it don't

00:24:36,880 --> 00:24:43,210
look for it right now and one it

00:24:39,909 --> 00:24:45,909
somewhere and then here's the third

00:24:43,210 --> 00:24:49,929
function the defer function which just

00:24:45,909 --> 00:24:52,240
says well they're tasks they give to you

00:24:49,929 --> 00:24:54,789
here is actually some kind of

00:24:52,240 --> 00:24:59,110
continuation of what I am currently

00:24:54,789 --> 00:25:03,159
doing so it might be useful to one their

00:24:59,110 --> 00:25:08,230
task may be on the same set that I'm

00:25:03,159 --> 00:25:11,770
currently running just when I wait for

00:25:08,230 --> 00:25:15,039
something or something else so it's it's

00:25:11,770 --> 00:25:16,840
more hint it's not really a different

00:25:15,039 --> 00:25:19,690
behavior it's just a hint to the

00:25:16,840 --> 00:25:25,330
executor and but it's a very useful in

00:25:19,690 --> 00:25:29,880
to get high-performance execution and

00:25:25,330 --> 00:25:33,090
the third customization point is the

00:25:29,880 --> 00:25:37,870
associated executor

00:25:33,090 --> 00:25:41,159
so I told you the executor in this

00:25:37,870 --> 00:25:44,049
propose is just a very lightweight thing

00:25:41,159 --> 00:25:47,030
and the wheel thing underneath is the

00:25:44,049 --> 00:25:51,100
execution context

00:25:47,030 --> 00:25:54,650
so you can actually define your own

00:25:51,100 --> 00:25:58,040
executor on top of an existing execution

00:25:54,650 --> 00:26:00,980
context so you don't have to implement

00:25:58,040 --> 00:26:04,190
your own thread pool just because you

00:26:00,980 --> 00:26:07,820
want to give some additional information

00:26:04,190 --> 00:26:10,370
or to use some additional information so

00:26:07,820 --> 00:26:16,370
for example I implemented my real-time

00:26:10,370 --> 00:26:19,460
executor just on top well in my case

00:26:16,370 --> 00:26:21,770
just the scratch executors so I just

00:26:19,460 --> 00:26:24,770
spawned a new thread for each thing

00:26:21,770 --> 00:26:30,140
because then the operating system

00:26:24,770 --> 00:26:34,130
priorities actually kick in and so that

00:26:30,140 --> 00:26:36,350
lightweight executed on top of that that

00:26:34,130 --> 00:26:38,600
actually contains the additional

00:26:36,350 --> 00:26:44,650
information whether something is a high

00:26:38,600 --> 00:26:49,730
priority task or low priority task so if

00:26:44,650 --> 00:26:55,340
we come back to my proposal here what

00:26:49,730 --> 00:27:03,440
you actually see is I have a different

00:26:55,340 --> 00:27:06,350
object here and this is an object that

00:27:03,440 --> 00:27:09,110
has just a different priority so I have

00:27:06,350 --> 00:27:11,300
two different executors here those are

00:27:09,110 --> 00:27:14,000
just like wait handles on the same

00:27:11,300 --> 00:27:16,490
execution context and one has no

00:27:14,000 --> 00:27:26,260
priority and one has a pretty high

00:27:16,490 --> 00:27:30,200
priority so this interface with the

00:27:26,260 --> 00:27:35,980
associated executor this in general

00:27:30,200 --> 00:27:39,640
allows for providing any info from the

00:27:35,980 --> 00:27:43,670
application point to the executor

00:27:39,640 --> 00:27:46,870
without my data concentrator needs to

00:27:43,670 --> 00:27:46,870
know anything about that

00:27:50,980 --> 00:27:59,220
so that was Chris Cole Oscar poser

00:27:54,750 --> 00:28:02,300
but we also got another proposal from

00:27:59,220 --> 00:28:06,450
Google Chris Mason was at this time and

00:28:02,300 --> 00:28:11,400
he actually started to work on the

00:28:06,450 --> 00:28:15,930
original Google proposal but just did a

00:28:11,400 --> 00:28:19,110
lot of work on that one and tried to fit

00:28:15,930 --> 00:28:23,750
into the new requirements and address

00:28:19,110 --> 00:28:27,750
the extra base class so what he actually

00:28:23,750 --> 00:28:33,570
proposes is an executor just as and as a

00:28:27,750 --> 00:28:37,470
concept so it's essentially a template

00:28:33,570 --> 00:28:42,150
based so templates can just take in

00:28:37,470 --> 00:28:47,910
executors as template argument and then

00:28:42,150 --> 00:28:51,440
you can use that interface so our X

00:28:47,910 --> 00:28:57,570
function which was renamed to spawn is

00:28:51,440 --> 00:29:01,170
not a virtual function anymore but it's

00:28:57,570 --> 00:29:03,570
again a template over the actual

00:29:01,170 --> 00:29:06,030
function time so you don't have to use

00:29:03,570 --> 00:29:10,620
the function so you don't get the

00:29:06,030 --> 00:29:17,820
overhead of the function here's our so

00:29:10,620 --> 00:29:22,580
we definitely addressed this one and the

00:29:17,820 --> 00:29:24,630
other things that he also edit was

00:29:22,580 --> 00:29:29,550
exactly something like The Associated

00:29:24,630 --> 00:29:32,940
executor so he proposed the task

00:29:29,550 --> 00:29:36,890
football and originally he made a

00:29:32,940 --> 00:29:41,660
mistake there but after some discussion

00:29:36,890 --> 00:29:45,270
now he actually does it the right way so

00:29:41,660 --> 00:29:49,640
that is fine but that's the only

00:29:45,270 --> 00:29:49,640
customization point he proposes

00:29:50,750 --> 00:29:59,200
and then we got a third proposal by the

00:29:54,610 --> 00:30:03,320
by Nvidia essentially because they've

00:29:59,200 --> 00:30:09,010
implementing the parallel orgasm tears

00:30:03,320 --> 00:30:12,140
and in that well originally in that

00:30:09,010 --> 00:30:15,320
proposal for the parallel algorithms

00:30:12,140 --> 00:30:18,770
we'll also execute the interface so you

00:30:15,320 --> 00:30:22,929
give an executor and you all do them

00:30:18,770 --> 00:30:27,350
we'll just one on that executor and well

00:30:22,929 --> 00:30:30,140
we did get out to the parallel audio

00:30:27,350 --> 00:30:35,299
isn't as a tears but not executors

00:30:30,140 --> 00:30:38,780
anywhere else so that was get off from

00:30:35,299 --> 00:30:41,840
the common tears but we still want to

00:30:38,780 --> 00:30:44,690
have it at some time so they looked into

00:30:41,840 --> 00:30:49,460
what do they actually need from an

00:30:44,690 --> 00:30:52,400
executor to implement the parallel

00:30:49,460 --> 00:30:56,330
algorithms on top of an executor

00:30:52,400 --> 00:31:00,890
interface and they decided not to come

00:30:56,330 --> 00:31:03,610
up with just another one another

00:31:00,890 --> 00:31:07,039
executor interface but they said well

00:31:03,610 --> 00:31:11,179
what we actually proposed is a trade

00:31:07,039 --> 00:31:18,190
class and this just adapt to whatever

00:31:11,179 --> 00:31:18,190
executor you have and that weight class

00:31:18,490 --> 00:31:26,600
first gives you the semantics of the

00:31:22,549 --> 00:31:30,429
actual executor so I talked before about

00:31:26,600 --> 00:31:32,750
the concurrent executors which is always

00:31:30,429 --> 00:31:35,450
more or less in parallel and the

00:31:32,750 --> 00:31:36,860
parallel executor which might be CEO

00:31:35,450 --> 00:31:39,770
will and then we also have weekly

00:31:36,860 --> 00:31:42,320
parallel where you are not allowed to do

00:31:39,770 --> 00:31:46,610
any synchronization at all at least no

00:31:42,320 --> 00:31:50,330
blocking synchronization and well if you

00:31:46,610 --> 00:31:53,919
implement something you typically want

00:31:50,330 --> 00:31:56,960
to know what semantics you actually get

00:31:53,919 --> 00:31:59,230
so they wanted to know this in the

00:31:56,960 --> 00:31:59,230
trades

00:31:59,570 --> 00:32:08,690
they wanted to know the future time that

00:32:03,740 --> 00:32:12,350
you actually get for the return then a

00:32:08,690 --> 00:32:14,900
tasket on that is something none of the

00:32:12,350 --> 00:32:16,820
other proposals actually covered but

00:32:14,900 --> 00:32:20,120
because they don't talk about futures

00:32:16,820 --> 00:32:23,120
and although the ACO proposal talks

00:32:20,120 --> 00:32:25,220
about that in some kind so one of those

00:32:23,120 --> 00:32:27,650
continuation tokens actually put you to

00:32:25,220 --> 00:32:33,500
the future but generally they say well

00:32:27,650 --> 00:32:37,130
it's not the job of the executor to deal

00:32:33,500 --> 00:32:39,560
with your results and to deal with any

00:32:37,130 --> 00:32:40,880
exceptions or things like that that is

00:32:39,560 --> 00:32:44,660
something else that has to deal with

00:32:40,880 --> 00:32:49,010
that but the parallel orders and air

00:32:44,660 --> 00:32:53,660
people they said well we need some kind

00:32:49,010 --> 00:32:55,520
of future and they want to know what

00:32:53,660 --> 00:32:58,070
type that actually is they said okay it

00:32:55,520 --> 00:33:00,050
doesn't have to be the future it can be

00:32:58,070 --> 00:33:01,090
some other future time but they need to

00:33:00,050 --> 00:33:06,230
know what time it is

00:33:01,090 --> 00:33:09,290
okay fine and of course they want to

00:33:06,230 --> 00:33:14,510
know how they have to start a new task

00:33:09,290 --> 00:33:18,260
and that ass has to return exactly the

00:33:14,510 --> 00:33:22,610
future time and they also want to stop a

00:33:18,260 --> 00:33:26,990
lot of tasks at the same time so they

00:33:22,610 --> 00:33:30,440
say okay well that is in video so they

00:33:26,990 --> 00:33:35,120
don't have one call or for course they

00:33:30,440 --> 00:33:40,000
have several hundred calls so they want

00:33:35,120 --> 00:33:43,660
to spawn off several hundred tasks and

00:33:40,000 --> 00:33:50,270
if you are then executed it might be

00:33:43,660 --> 00:33:53,210
much more efficient just to create 100

00:33:50,270 --> 00:33:57,050
tasks at the same time than one after

00:33:53,210 --> 00:34:01,040
the other so they came up with an

00:33:57,050 --> 00:34:04,780
additional interface okay we want to

00:34:01,040 --> 00:34:04,780
start so many times

00:34:08,080 --> 00:34:19,330
the interesting thing about the executor

00:34:12,770 --> 00:34:20,600
trade is the trades actually allow for

00:34:19,330 --> 00:34:24,260
weapon

00:34:20,600 --> 00:34:26,899
your executor and you can add all the

00:34:24,260 --> 00:34:30,500
functionality that this specific way it

00:34:26,899 --> 00:34:33,139
requires inside of the trade you don't

00:34:30,500 --> 00:34:37,040
have to do it in the executor so for

00:34:33,139 --> 00:34:42,770
example the future thing well as I said

00:34:37,040 --> 00:34:45,710
the north opposes don't really talk

00:34:42,770 --> 00:34:49,340
about futures well you can add that if

00:34:45,710 --> 00:34:52,879
your underlying executed doesn't provide

00:34:49,340 --> 00:34:56,570
such a bike interface well you just can

00:34:52,879 --> 00:35:03,770
write in your trades class you for loop

00:34:56,570 --> 00:35:07,040
and start all those carts so I think

00:35:03,770 --> 00:35:11,180
that's a very useful approach but of

00:35:07,040 --> 00:35:15,220
course this is again only one aspect one

00:35:11,180 --> 00:35:15,220
specific domain for the parallel order

00:35:18,490 --> 00:35:24,280
so what's the status quo what do we have

00:35:22,850 --> 00:35:30,830
right now

00:35:24,280 --> 00:35:34,720
well the suppose with several

00:35:30,830 --> 00:35:39,230
modifications was accepted by the

00:35:34,720 --> 00:35:44,720
concurrency of study cool into the

00:35:39,230 --> 00:35:49,600
concurrency yes February last year and

00:35:44,720 --> 00:35:49,600
Issaquah just just a few miles from here

00:35:49,990 --> 00:36:00,200
well that wasn't apparel in June last

00:35:54,620 --> 00:36:02,630
year people came back with school off

00:36:00,200 --> 00:36:06,080
until then never came to a meeting he

00:36:02,630 --> 00:36:07,940
just will proposes but he didn't come to

00:36:06,080 --> 00:36:13,670
the meetings and he was in the post view

00:36:07,940 --> 00:36:16,370
but Pete Marku actually presented that

00:36:13,670 --> 00:36:19,310
to the concurrency group and after their

00:36:16,370 --> 00:36:23,820
discussion well

00:36:19,310 --> 00:36:26,940
nearly everybody said okay we have to

00:36:23,820 --> 00:36:30,869
remove the original proposal from the

00:36:26,940 --> 00:36:36,570
compound CTS we are not there yet

00:36:30,869 --> 00:36:41,460
you cannot use that one as a TS and but

00:36:36,570 --> 00:36:44,340
also and this means strongly in favor in

00:36:41,460 --> 00:36:50,010
favor neutral again strongly against so

00:36:44,340 --> 00:36:52,650
only two people weakly against removing

00:36:50,010 --> 00:36:55,380
the original proposals from the tears

00:36:52,650 --> 00:36:58,100
but no strong opposition on that one on

00:36:55,380 --> 00:37:02,670
the other hand most people were not

00:36:58,100 --> 00:37:07,140
really happy with the ACO proposal a

00:37:02,670 --> 00:37:11,280
sixth and so they said well we need more

00:37:07,140 --> 00:37:15,090
work on that one so when we finally

00:37:11,280 --> 00:37:19,380
asked the question okay should we use

00:37:15,090 --> 00:37:23,609
now the the ACO proposed as the new

00:37:19,380 --> 00:37:27,859
executor model in our tears well the

00:37:23,609 --> 00:37:31,970
group was pretty much split so

00:37:27,859 --> 00:37:31,970
definitely no consensus on that one

00:37:32,119 --> 00:37:43,470
so sg1 decided to have an additional

00:37:40,740 --> 00:37:46,770
meeting between the La Paz middle

00:37:43,470 --> 00:37:51,660
meeting and the open a champagne meeting

00:37:46,770 --> 00:37:59,730
in October November last year so they

00:37:51,660 --> 00:38:02,700
met 2014 over in Redmond and there Chris

00:37:59,730 --> 00:38:09,869
Mason came with his new version of the

00:38:02,700 --> 00:38:12,420
Google proposal and well a lot of max of

00:38:09,869 --> 00:38:14,400
people there there were a lot of Google

00:38:12,420 --> 00:38:20,460
people there that meeting and they were

00:38:14,400 --> 00:38:22,830
all in favor of that proposal so when

00:38:20,460 --> 00:38:24,640
they are the question okay should we

00:38:22,830 --> 00:38:30,850
actually

00:38:24,640 --> 00:38:32,440
we start with this proposal yeah most

00:38:30,850 --> 00:38:35,740
people they're in favor of that and

00:38:32,440 --> 00:38:37,600
those two who were strongly against they

00:38:35,740 --> 00:38:41,230
are not even in Westmont they'd be on

00:38:37,600 --> 00:38:44,770
the phone and one of them was me and one

00:38:41,230 --> 00:38:47,620
of them was somebody from the UK maybe

00:38:44,770 --> 00:38:52,810
because we said well yeah that's not

00:38:47,620 --> 00:38:56,230
really what we need and the Nvidia

00:38:52,810 --> 00:38:59,770
proposal that was discussed in May and

00:38:56,230 --> 00:39:02,050
Lenexa but we didn't take vote we

00:38:59,770 --> 00:39:04,090
thought well okay it's a very

00:39:02,050 --> 00:39:07,440
interesting approach but we are not

00:39:04,090 --> 00:39:15,070
ready to vote on that one yet

00:39:07,440 --> 00:39:20,920
so that's the status quo so what do we

00:39:15,070 --> 00:39:24,130
really need and maybe it's actually

00:39:20,920 --> 00:39:26,520
useful to look a little bit at the

00:39:24,130 --> 00:39:33,450
bigger picture

00:39:26,520 --> 00:39:36,190
so the original C++ standard

00:39:33,450 --> 00:39:38,380
standardized the Istana template library

00:39:36,190 --> 00:39:41,200
and part of that standard template

00:39:38,380 --> 00:39:44,140
library were the educators but

00:39:41,200 --> 00:39:47,920
essentially nobody actually used ever

00:39:44,140 --> 00:39:52,390
that allocated directly that was used by

00:39:47,920 --> 00:39:55,300
the containers so the educators is a

00:39:52,390 --> 00:39:57,940
very low level building block and you

00:39:55,300 --> 00:40:01,120
put the interesting thing that's

00:39:57,940 --> 00:40:03,330
actually used by your programs for you

00:40:01,120 --> 00:40:09,400
applications

00:40:03,330 --> 00:40:12,820
well that isn't a middle layer and for

00:40:09,400 --> 00:40:19,360
the executors that middle layer might be

00:40:12,820 --> 00:40:23,140
an azo couple oh just a sink to start

00:40:19,360 --> 00:40:26,940
and you task well to do one a task on

00:40:23,140 --> 00:40:30,160
that executor and get a future back and

00:40:26,940 --> 00:40:33,560
two fiddling with all the future things

00:40:30,160 --> 00:40:35,540
like exceptions and things like that

00:40:33,560 --> 00:40:39,560
the pipeline couple that we have seen

00:40:35,540 --> 00:40:44,860
the flow graphs as it was in TVB also

00:40:39,560 --> 00:40:47,960
listen ptb be parallel algorithms

00:40:44,860 --> 00:40:51,680
something like an event loop that's very

00:40:47,960 --> 00:40:56,360
important in embedded systems but also

00:40:51,680 --> 00:40:59,060
in other systems so the executor

00:40:56,360 --> 00:41:02,570
actually isn't something that is used by

00:40:59,060 --> 00:41:05,680
applications directly but it's something

00:41:02,570 --> 00:41:10,910
that is used by the middle layer by some

00:41:05,680 --> 00:41:12,590
additional components then actually some

00:41:10,910 --> 00:41:15,920
of them might be standardized some of

00:41:12,590 --> 00:41:19,640
them might not but they will use the

00:41:15,920 --> 00:41:23,870
executor interface and there's a general

00:41:19,640 --> 00:41:29,690
you cool if you have more info then you

00:41:23,870 --> 00:41:34,820
can do a better job well what kind of

00:41:29,690 --> 00:41:39,410
information might be useful for the

00:41:34,820 --> 00:41:42,620
implementation of an executor well for

00:41:39,410 --> 00:41:51,860
example what's the relationship of the

00:41:42,620 --> 00:41:54,500
task 31 to your caller let my team Oh is

00:41:51,860 --> 00:41:57,470
the task that you're actually giving to

00:41:54,500 --> 00:41:59,930
the executor something gets long-running

00:41:57,470 --> 00:42:02,690
or something that is very short running

00:41:59,930 --> 00:42:06,290
just computed function and then you are

00:42:02,690 --> 00:42:11,590
done or is it something like a server

00:42:06,290 --> 00:42:11,590
which will live more or less forever

00:42:12,250 --> 00:42:24,950
it's a function it's a task actually

00:42:15,290 --> 00:42:27,110
contains it internal locking calls is it

00:42:24,950 --> 00:42:30,500
actually a terms that should be run

00:42:27,110 --> 00:42:35,300
again and again and again which is often

00:42:30,500 --> 00:42:38,720
done in a better system do you have some

00:42:35,300 --> 00:42:41,000
specific priority as we have already

00:42:38,720 --> 00:42:42,859
seen and

00:42:41,000 --> 00:42:47,750
how do you want to get the information

00:42:42,859 --> 00:42:50,750
back of your TAS maybe maybe you are not

00:42:47,750 --> 00:42:53,710
interested in that information at all if

00:42:50,750 --> 00:42:57,050
you are running the server for example

00:42:53,710 --> 00:43:00,109
its new spawning of a server you're not

00:42:57,050 --> 00:43:05,930
interested in any return you don't

00:43:00,109 --> 00:43:09,020
expect it to give you any return but all

00:43:05,930 --> 00:43:15,290
that information is very specific to

00:43:09,020 --> 00:43:17,150
some executors to some domains and only

00:43:15,290 --> 00:43:22,250
nothing of that should be directly in

00:43:17,150 --> 00:43:24,859
the interface of the executor but there

00:43:22,250 --> 00:43:29,390
should be a mechanism for me as

00:43:24,859 --> 00:43:32,839
application programmer to give this

00:43:29,390 --> 00:43:36,500
information to my underlying executor

00:43:32,839 --> 00:43:39,920
that I controlled as well if I start the

00:43:36,500 --> 00:43:41,480
pipeline on an executor I possibly

00:43:39,920 --> 00:43:46,220
created that executor

00:43:41,480 --> 00:43:48,440
so I know what executor I have as an

00:43:46,220 --> 00:43:51,650
application programmer but I don't

00:43:48,440 --> 00:43:55,250
control the actually call to the

00:43:51,650 --> 00:43:57,770
executor so I need some mechanism to

00:43:55,250 --> 00:44:02,319
give this information from the

00:43:57,770 --> 00:44:02,319
application to the underlying executor

00:44:06,280 --> 00:44:18,560
and well this is exactly what the

00:44:15,349 --> 00:44:21,380
Associated executors can do if you have

00:44:18,560 --> 00:44:23,960
that very lightweight handle because

00:44:21,380 --> 00:44:31,860
then you can just use that mechanism to

00:44:23,960 --> 00:44:35,460
transfer that information Wow

00:44:31,860 --> 00:44:39,390
yeah there's still a little bit more and

00:44:35,460 --> 00:44:44,940
I'm equip pretty heavy that car is

00:44:39,390 --> 00:44:51,360
sitting there pretty happy and well Kovu

00:44:44,940 --> 00:44:54,900
teens very important for some types of a

00:44:51,360 --> 00:44:57,800
synchronicity and a zero for example but

00:44:54,900 --> 00:45:01,350
pretty well together with co-routines

00:44:57,800 --> 00:45:03,690
but i believe i might be wrong but i

00:45:01,350 --> 00:45:06,230
believe that the current proposal that

00:45:03,690 --> 00:45:08,460
we have is the async with humor coach

00:45:06,230 --> 00:45:11,820
doesn't really work together with

00:45:08,460 --> 00:45:20,970
executors maybe we can do that do you

00:45:11,820 --> 00:45:23,660
know okay good to know

00:45:20,970 --> 00:45:27,810
I will definitely have to look okay so

00:45:23,660 --> 00:45:31,800
he go actually when Caesar made proposed

00:45:27,810 --> 00:45:35,700
awfully I think assume proposal he just

00:45:31,800 --> 00:45:40,440
told me that you can probably do exactly

00:45:35,700 --> 00:45:43,890
that by saying async and give that an

00:45:40,440 --> 00:45:45,780
executor and I have to admit I fully

00:45:43,890 --> 00:45:50,060
have to look at that part of the

00:45:45,780 --> 00:45:59,040
proposal and we really need that

00:45:50,060 --> 00:46:04,020
composability so I started quo is we

00:45:59,040 --> 00:46:10,380
don't have an executor interface so what

00:46:04,020 --> 00:46:12,440
do we need to do well executors are very

00:46:10,380 --> 00:46:15,320
very important building block for

00:46:12,440 --> 00:46:20,340
anything that is even remotely

00:46:15,320 --> 00:46:22,470
concurrent asynchronous parallel but

00:46:20,340 --> 00:46:26,040
they should be very low-level they

00:46:22,470 --> 00:46:29,190
should provide you the interface for the

00:46:26,040 --> 00:46:32,190
immediate layer they should not provide

00:46:29,190 --> 00:46:40,490
you an interface for the application

00:46:32,190 --> 00:46:45,080
program but what the interface will be

00:46:40,490 --> 00:46:45,080
we still have no agreement America

00:46:45,180 --> 00:46:52,609
and well we have some very specific

00:46:50,599 --> 00:46:56,940
experience so we have a lot experience

00:46:52,609 --> 00:46:59,089
from SEO we have experience now a little

00:46:56,940 --> 00:47:02,849
bit from the parallel algorithm people

00:46:59,089 --> 00:47:05,369
we also have the experience of all the

00:47:02,849 --> 00:47:10,950
Google people and what they have done in

00:47:05,369 --> 00:47:15,599
inside Google but I still believe that's

00:47:10,950 --> 00:47:19,589
not the whole story and we probably need

00:47:15,599 --> 00:47:27,000
a lot more use cases to see what we

00:47:19,589 --> 00:47:36,660
actually need so yeah well one question

00:47:27,000 --> 00:47:40,819
is what is a task so what information do

00:47:36,660 --> 00:47:46,190
you need to give to an executor if you

00:47:40,819 --> 00:47:51,029
give some higher level mechanism a task

00:47:46,190 --> 00:47:55,130
to run is it really just a function or

00:47:51,029 --> 00:48:01,289
is it the function plus some information

00:47:55,130 --> 00:48:06,779
and if it is plus some information well

00:48:01,289 --> 00:48:12,390
what information is it and how do you

00:48:06,779 --> 00:48:16,910
get that so what we will need to look

00:48:12,390 --> 00:48:20,039
into okay what interface do we need

00:48:16,910 --> 00:48:26,849
between the executor and the middle

00:48:20,039 --> 00:48:30,900
layer but in a way that the higher layer

00:48:26,849 --> 00:48:33,150
the application actually can transport

00:48:30,900 --> 00:48:39,119
all the fact all the information it

00:48:33,150 --> 00:48:41,220
wishes to the underlying executor and as

00:48:39,119 --> 00:48:45,720
I said we definitely shouldn't

00:48:41,220 --> 00:48:47,640
standardize everything but we should

00:48:45,720 --> 00:48:49,950
stand out as something that is open

00:48:47,640 --> 00:48:53,549
enough so that other people can build on

00:48:49,950 --> 00:48:55,970
that and to their own things outside of

00:48:53,549 --> 00:48:55,970
the stand

00:48:58,770 --> 00:49:08,200
so yeah I was actually one of those

00:49:04,810 --> 00:49:11,140
people who said well I really want to go

00:49:08,200 --> 00:49:13,329
forward to the ACO proposal not with the

00:49:11,140 --> 00:49:15,460
quiz nation proposal on the other hand I

00:49:13,329 --> 00:49:19,569
think the ACO proposal actually is very

00:49:15,460 --> 00:49:23,470
very complex and I actually have

00:49:19,569 --> 00:49:27,339
implemented my own executors on top of

00:49:23,470 --> 00:49:30,250
the ACO proposal and it just has

00:49:27,339 --> 00:49:36,730
something that I think you shouldn't

00:49:30,250 --> 00:49:40,119
need to do but the ACO proposal actually

00:49:36,730 --> 00:49:43,089
provides me those three customization

00:49:40,119 --> 00:49:45,520
points that I think are very useful but

00:49:43,089 --> 00:49:47,410
there might be more customization points

00:49:45,520 --> 00:49:51,790
that might be useful but I simply don't

00:49:47,410 --> 00:49:54,280
know them yet and Chris Mason's proposal

00:49:51,790 --> 00:49:57,339
only provides one of those customisation

00:49:54,280 --> 00:50:00,599
points the associated executor so it

00:49:57,339 --> 00:50:02,950
actually has that in interface to

00:50:00,599 --> 00:50:04,420
transport some information from the

00:50:02,950 --> 00:50:09,160
application they are down to the

00:50:04,420 --> 00:50:11,520
executor it's who the middle layer but

00:50:09,160 --> 00:50:16,810
it doesn't have anything like

00:50:11,520 --> 00:50:19,599
continuation tokens and it doesn't have

00:50:16,810 --> 00:50:21,339
the suite function interface and

00:50:19,599 --> 00:50:23,079
personally I don't really like the suite

00:50:21,339 --> 00:50:26,650
function interface I'm not completely

00:50:23,079 --> 00:50:29,619
sure that we only have those sweden's we

00:50:26,650 --> 00:50:34,440
want to give from the middle layer down

00:50:29,619 --> 00:50:37,230
to the executors so yeah you definitely

00:50:34,440 --> 00:50:40,900
need to do more work

00:50:37,230 --> 00:50:43,780
Thirteen's Gore just told me that they

00:50:40,900 --> 00:50:47,550
are more cooperative than I thought

00:50:43,780 --> 00:50:51,060
which is very very good thank you and

00:50:47,550 --> 00:50:54,420
well that's it

00:50:51,060 --> 00:50:54,420
any questions

00:51:03,290 --> 00:51:17,990
well I'll just stay seated so in using

00:51:14,660 --> 00:51:21,020
the executor that we have in the code

00:51:17,990 --> 00:51:23,780
that I work on one of the issues that

00:51:21,020 --> 00:51:27,620
comes up is you have a large number of

00:51:23,780 --> 00:51:31,370
tasks that need to be run and those

00:51:27,620 --> 00:51:33,710
tasks consume resources and you would

00:51:31,370 --> 00:51:36,320
really like the executor to be aware of

00:51:33,710 --> 00:51:41,590
the resource consumption so that it

00:51:36,320 --> 00:51:48,020
could choose tasks to perhaps pause or

00:51:41,590 --> 00:51:49,790
abandon or what have you and there are

00:51:48,020 --> 00:51:52,820
other things as well but I'll just leave

00:51:49,790 --> 00:51:54,400
the question out at that and I just

00:51:52,820 --> 00:52:01,520
wondered whether you'd given

00:51:54,400 --> 00:52:05,150
consideration to that kind of thing well

00:52:01,520 --> 00:52:08,500
I think everybody has hard to the

00:52:05,150 --> 00:52:08,500
question so I don't have to repeat it

00:52:09,220 --> 00:52:18,770
well yeah this is something that

00:52:15,320 --> 00:52:25,460
especially the ACO proposal has put a

00:52:18,770 --> 00:52:28,520
lot of thought into the head one and the

00:52:25,460 --> 00:52:32,560
point is there is a very interesting

00:52:28,520 --> 00:52:36,260
thing PPP because part of that is

00:52:32,560 --> 00:52:39,110
between my middle layer and the executor

00:52:36,260 --> 00:52:42,560
and part of that is between the

00:52:39,110 --> 00:52:48,380
application and the executor so it

00:52:42,560 --> 00:52:51,950
actually two different things and if I

00:52:48,380 --> 00:52:54,490
look back at those sweet customization

00:52:51,950 --> 00:52:54,490
points

00:52:58,000 --> 00:53:07,900
I have to admit I don't think that

00:53:04,030 --> 00:53:10,050
swinney come up it's definitely good

00:53:07,900 --> 00:53:10,050
input

00:53:15,330 --> 00:53:27,850
any other question yeah it's related to

00:53:25,110 --> 00:53:29,110
not necessarily just about the executor

00:53:27,850 --> 00:53:31,240
have you guys talked about the

00:53:29,110 --> 00:53:32,920
cancellations for the tasks in general

00:53:31,240 --> 00:53:35,830
and something that the executor could

00:53:32,920 --> 00:53:45,730
look at the task post consult before

00:53:35,830 --> 00:53:49,570
it's wrong so yeah actually say you put

00:53:45,730 --> 00:53:51,250
a tax on an executor and then you decide

00:53:49,570 --> 00:53:57,340
well you don't need it anymore so we

00:53:51,250 --> 00:53:59,520
cancel it and the executor shouldn't run

00:53:57,340 --> 00:53:59,520
it

00:53:59,910 --> 00:54:07,950
no we haven't thought about this use

00:54:04,330 --> 00:54:14,320
case and I think none of the proposals

00:54:07,950 --> 00:54:16,660
has any remove function so which says

00:54:14,320 --> 00:54:25,300
okay remove their tasks from your queue

00:54:16,660 --> 00:54:30,570
if it's not already started and then

00:54:25,300 --> 00:54:33,450
again doesn't fit very well into my

00:54:30,570 --> 00:54:36,850
middle layer and application they are

00:54:33,450 --> 00:54:38,320
seeing because sometimes it's a middle

00:54:36,850 --> 00:54:40,870
layer that they notice it's okay I don't

00:54:38,320 --> 00:54:42,550
need it anymore and that could actually

00:54:40,870 --> 00:54:44,800
do something but because that has a

00:54:42,550 --> 00:54:46,000
direct interface to the executor the

00:54:44,800 --> 00:54:48,300
applique about sometimes it's actually

00:54:46,000 --> 00:54:51,490
the application layer that's well okay I

00:54:48,300 --> 00:54:53,950
started here something use it whatever

00:54:51,490 --> 00:54:56,110
using whatever and you tast and but I

00:54:53,950 --> 00:54:58,390
don't need that anymore but it doesn't

00:54:56,110 --> 00:55:08,740
actually have a download interface to

00:54:58,390 --> 00:55:11,440
the executor so well and then executor

00:55:08,740 --> 00:55:15,340
definitely could have an interface like

00:55:11,440 --> 00:55:20,040
that I don't remember that it ever came

00:55:15,340 --> 00:55:23,640
up in the discussion but well that's

00:55:20,040 --> 00:55:23,640
definitely interesting input

00:55:24,940 --> 00:55:32,200
I just want a second that we have a we

00:55:30,400 --> 00:55:34,810
did I did a similar thing where we used

00:55:32,200 --> 00:55:37,570
a token we called it a token that we

00:55:34,810 --> 00:55:39,100
passed the tasks so that they know if

00:55:37,570 --> 00:55:40,930
they need to keep doing work and

00:55:39,100 --> 00:55:44,500
sometimes tasks would take longer to run

00:55:40,930 --> 00:55:46,810
then maybe our framework expected and

00:55:44,500 --> 00:55:48,760
and so we would kick off another task to

00:55:46,810 --> 00:55:53,370
help it these things could be on course

00:55:48,760 --> 00:55:55,870
they could be distributed it was it was

00:55:53,370 --> 00:55:57,760
we didn't build the framework to know if

00:55:55,870 --> 00:55:59,830
it was on that machine or distributed

00:55:57,760 --> 00:56:02,470
but these tasks would be sent out and if

00:55:59,830 --> 00:56:04,870
task for not coming back as fast as we

00:56:02,470 --> 00:56:06,310
wanted then we would kick off more but

00:56:04,870 --> 00:56:09,880
there was a plenty of opportunity for

00:56:06,310 --> 00:56:12,760
the token to tell the task hey it's been

00:56:09,880 --> 00:56:15,070
handled now stop your work or don't even

00:56:12,760 --> 00:56:16,750
kick you we created ten more but you

00:56:15,070 --> 00:56:23,770
don't need to send that out it was

00:56:16,750 --> 00:56:27,340
there's cost and sending out yeah okay

00:56:23,770 --> 00:56:32,110
but after that I actually think it might

00:56:27,340 --> 00:56:34,630
be doable just using that lightweight

00:56:32,110 --> 00:56:36,760
executor thing associated executable

00:56:34,630 --> 00:56:39,310
because there you can add whatever

00:56:36,760 --> 00:56:42,520
information you want and you can just

00:56:39,310 --> 00:56:45,880
put in a boolean for example okay don't

00:56:42,520 --> 00:56:50,140
run it anymore or yeah you still need to

00:56:45,880 --> 00:56:51,670
run it something like that but there is

00:56:50,140 --> 00:56:55,330
only if it really comes from the

00:56:51,670 --> 00:56:56,920
application if it comes from the medium

00:56:55,330 --> 00:56:59,230
layer well yeah

00:56:56,920 --> 00:57:00,370
one more question I think I missed the

00:56:59,230 --> 00:57:03,010
part at the beginning of your

00:57:00,370 --> 00:57:06,670
presentation when you talk about when a

00:57:03,010 --> 00:57:11,560
sync fires and it's lunch icing and you

00:57:06,670 --> 00:57:14,080
said it's desirable to know that the

00:57:11,560 --> 00:57:15,370
task will finish by the time the

00:57:14,080 --> 00:57:17,740
instruction happens for that future

00:57:15,370 --> 00:57:19,690
there I don't think it's desirable when

00:57:17,740 --> 00:57:20,950
the lunch is pacing

00:57:19,690 --> 00:57:24,430
I think it's desirable when it's

00:57:20,950 --> 00:57:26,380
deferred but when it's async why

00:57:24,430 --> 00:57:29,770
wouldn't I wait for the future

00:57:26,380 --> 00:57:37,990
explicitly why no that's not the point

00:57:29,770 --> 00:57:40,880
the point here is your task once it

00:57:37,990 --> 00:57:45,619
whoever wants some objects

00:57:40,880 --> 00:57:47,720
violet ones you must make sure that

00:57:45,619 --> 00:57:53,170
those objects are still available

00:57:47,720 --> 00:57:58,550
available then they toss exorcism and

00:57:53,170 --> 00:58:03,349
that is why you need control over then

00:57:58,550 --> 00:58:06,349
their task actually finishes sure wooden

00:58:03,349 --> 00:58:08,329
I done wait on my main threat on that

00:58:06,349 --> 00:58:08,869
future and then I know that hey it

00:58:08,329 --> 00:58:11,720
completed

00:58:08,869 --> 00:58:13,579
I can read exactly that is why they

00:58:11,720 --> 00:58:15,650
actually give you the future from the

00:58:13,579 --> 00:58:18,920
async because then you can bake on that

00:58:15,650 --> 00:58:22,010
future and everything is fine the

00:58:18,920 --> 00:58:24,260
problem is if you don't wait if you

00:58:22,010 --> 00:58:27,260
don't take that future and don't wait

00:58:24,260 --> 00:58:30,680
point then you have a problem

00:58:27,260 --> 00:58:34,280
are there usages for that like who do

00:58:30,680 --> 00:58:37,430
that well that is exactly the point when

00:58:34,280 --> 00:58:40,430
we originally designed future and I

00:58:37,430 --> 00:58:42,470
think we thought no there is no use for

00:58:40,430 --> 00:58:44,750
that but it turned out that a lot of

00:58:42,470 --> 00:58:49,250
people actually use it exactly that way

00:58:44,750 --> 00:58:50,810
they have fire-and-forget time so they

00:58:49,250 --> 00:58:55,310
are not interested in the future they

00:58:50,810 --> 00:58:56,839
just want to start their task and the

00:58:55,310 --> 00:58:59,839
point is we actually have two different

00:58:56,839 --> 00:59:04,579
use cases but only one interface for

00:58:59,839 --> 00:59:06,910
them and that is the problem I think we

00:59:04,579 --> 00:59:11,150
have time for one last quick question

00:59:06,910 --> 00:59:13,250
okay so in your slide about your real

00:59:11,150 --> 00:59:15,079
time priorities and your non non real

00:59:13,250 --> 00:59:18,290
time you gave the priority to the

00:59:15,079 --> 00:59:22,760
executor handle and not to the task that

00:59:18,290 --> 00:59:25,910
you fired off in my use case we actually

00:59:22,760 --> 00:59:28,190
need something that knows that this task

00:59:25,910 --> 00:59:30,349
takes a fifth of the memory that is

00:59:28,190 --> 00:59:32,869
available and you can only run five but

00:59:30,349 --> 00:59:36,349
you've got 32 cores so you need to sort

00:59:32,869 --> 00:59:40,700
of you know but knapsack the the RAM and

00:59:36,349 --> 00:59:44,300
it's doesn't work well the point here

00:59:40,700 --> 00:59:47,000
was that executors handler is a very

00:59:44,300 --> 00:59:50,570
very very light rating so you can

00:59:47,000 --> 00:59:55,790
actually create a new executor for

00:59:50,570 --> 00:59:58,700
single-task and this way you can just

00:59:55,790 --> 01:00:01,480
put the information that you would want

00:59:58,700 --> 01:00:05,050
to put to the task into that thing so

01:00:01,480 --> 01:00:08,210
actually it is a little bit of misnomer

01:00:05,050 --> 01:00:10,520
so it wasn't apparent to me but I looked

01:00:08,210 --> 01:00:12,830
at the interface that I could use it

01:00:10,520 --> 01:00:16,330
that way but after I actually work with

01:00:12,830 --> 01:00:21,770
it I found out about this is exactly the

01:00:16,330 --> 01:00:25,640
thing I need to put whatever information

01:00:21,770 --> 01:00:28,370
I want into the task and give it to the

01:00:25,640 --> 01:00:33,070
underlying execution context in this

01:00:28,370 --> 01:00:38,830
case so you can actually use it that way

01:00:33,070 --> 01:00:38,830

YouTube URL: https://www.youtube.com/watch?v=sAJGoHN6Xx8


