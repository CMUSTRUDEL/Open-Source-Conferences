Title: CppCon 2015: Matt Hargett “Advanced Unit Testing in C & C++”
Publication date: 2015-10-09
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
This session goes in-depth into advanced techniques to isolate and unit test C++ classes, especially those in legacy code that isn't easy to change. This builds on the Pragmatic Unit Testing in C++ talk from last year, with live code examples of safe refactorings, injecting mock objects, and potential pitfalls across different platforms and toolchains.
— 
Matt's first programming was on a TI 99/4a with his mother, and his first reverse engineering was on an 8086 to make shareware games easier to finish. Matt co-authored Pragmatic Unit Testing in C#, and has spoken at conferences around the world on network security, reverse engineering, unit testing, and static analysis. His hobbies include world travel, playing video games, and writing/publishing indie pop songs under the moniker "the making of the making of". Matt lives in San Francisco with his husband of 14 years. 
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,540
hello um Matt Hargett and some of you

00:00:03,270 --> 00:00:10,469
may have gone to my talk at CPP con last

00:00:06,540 --> 00:00:13,110
year about unit testing and I just want

00:00:10,469 --> 00:00:15,120
to start by saying thank you to all the

00:00:13,110 --> 00:00:17,910
people who like either we're here last

00:00:15,120 --> 00:00:19,410
year or saw the video on YouTube or

00:00:17,910 --> 00:00:21,869
wherever else it is and stuff like that

00:00:19,410 --> 00:00:24,330
and send me lots of nice notes over the

00:00:21,869 --> 00:00:27,269
last year and asked lots of follow-up

00:00:24,330 --> 00:00:28,650
questions and stuff like that I did like

00:00:27,269 --> 00:00:31,380
some remote pair programming with some

00:00:28,650 --> 00:00:33,630
people who like needed some help with

00:00:31,380 --> 00:00:36,000
their specific code I was happy to to do

00:00:33,630 --> 00:00:40,620
that so thanks to everybody for the warm

00:00:36,000 --> 00:00:42,210
reception and for reaching out so maybe

00:00:40,620 --> 00:00:47,039
some of the new attendees this year will

00:00:42,210 --> 00:00:50,610
will do the same so this is a this is

00:00:47,039 --> 00:00:52,379
kind of a part two to the talk last year

00:00:50,610 --> 00:00:54,719
and if you didn't see the talk last year

00:00:52,379 --> 00:00:59,820
that's fine I'm going to do a speedrun

00:00:54,719 --> 00:01:02,969
through extreme basics but if you didn't

00:00:59,820 --> 00:01:04,979
see the talk the 2014 CPP con talk

00:01:02,969 --> 00:01:07,650
whether you're here or you're watching

00:01:04,979 --> 00:01:09,930
it later on YouTube or whatever you

00:01:07,650 --> 00:01:12,180
should probably watch that one first you

00:01:09,930 --> 00:01:14,010
can watch it at 1.5 speed or 2x or

00:01:12,180 --> 00:01:18,810
whatever you can hear the Chipmunks talk

00:01:14,010 --> 00:01:20,939
about you know testing but one of the

00:01:18,810 --> 00:01:22,409
pieces of feedback I got is that the

00:01:20,939 --> 00:01:24,090
talk last year was a little too

00:01:22,409 --> 00:01:25,560
high-level focused too much on the

00:01:24,090 --> 00:01:27,030
selling points of unit testing rather

00:01:25,560 --> 00:01:28,890
than the technical point of unit testing

00:01:27,030 --> 00:01:30,900
so this year we're going to talk about

00:01:28,890 --> 00:01:33,270
some more technical point of view no

00:01:30,900 --> 00:01:35,820
testing and some of the difficulties

00:01:33,270 --> 00:01:43,020
with deep difficulties with real-world

00:01:35,820 --> 00:01:45,450
unit testing so without further ado so

00:01:43,020 --> 00:01:46,890
though there's a couple things I'm gonna

00:01:45,450 --> 00:01:53,460
repeat from the first from the talk from

00:01:46,890 --> 00:01:54,899
last year so the only reason to do unit

00:01:53,460 --> 00:01:56,880
testing is for a sustainable competitive

00:01:54,899 --> 00:01:59,100
business advantage a lot of people come

00:01:56,880 --> 00:02:01,020
at unit testing or any kind of testing

00:01:59,100 --> 00:02:02,880
from this kind of warm happy fuzzy

00:02:01,020 --> 00:02:04,439
quality place well the reason quality is

00:02:02,880 --> 00:02:06,630
important is purely for business reasons

00:02:04,439 --> 00:02:07,619
right so that your customers are happy

00:02:06,630 --> 00:02:09,379
so your developers are working

00:02:07,619 --> 00:02:13,150
efficiently so that you have a smaller

00:02:09,379 --> 00:02:14,860
small QA team and you can spend you

00:02:13,150 --> 00:02:17,260
spending two million dollars on an

00:02:14,860 --> 00:02:22,209
extended QA team you can spend that

00:02:17,260 --> 00:02:25,269
money on other stuff so in my experience

00:02:22,209 --> 00:02:28,870
unit testing is the most reliable route

00:02:25,269 --> 00:02:30,519
to a modular / object-oriented design

00:02:28,870 --> 00:02:32,470
some people will still have an allergy

00:02:30,519 --> 00:02:35,019
to the term object-oriented for some

00:02:32,470 --> 00:02:36,189
reason probably not as heat BP Khan but

00:02:35,019 --> 00:02:42,730
if you don't like that term you can just

00:02:36,189 --> 00:02:44,859
say modular so the the reason why is

00:02:42,730 --> 00:02:47,530
because to do really unit testing you

00:02:44,859 --> 00:02:48,970
have to be able to isolate each of the

00:02:47,530 --> 00:02:51,340
kind of behavioral modules in your

00:02:48,970 --> 00:02:53,349
system whether those are classes in a

00:02:51,340 --> 00:02:59,290
cpp for a single class in a single CPP

00:02:53,349 --> 00:03:02,439
file or a C file that that defines some

00:02:59,290 --> 00:03:04,209
module for whatever it does that has a

00:03:02,439 --> 00:03:06,220
single responsibility and complies with

00:03:04,209 --> 00:03:07,689
other kind of principles even if you're

00:03:06,220 --> 00:03:11,260
in C single responsibility principle

00:03:07,689 --> 00:03:12,370
still applies at the module level or if

00:03:11,260 --> 00:03:13,930
you don't have the source code if you're

00:03:12,370 --> 00:03:16,870
just dealing with here's a binary code

00:03:13,930 --> 00:03:17,799
file and that's all and you don't have

00:03:16,870 --> 00:03:21,609
the source code for it

00:03:17,799 --> 00:03:22,810
for some reason because you have to be

00:03:21,609 --> 00:03:24,370
able to your testing so you really have

00:03:22,810 --> 00:03:26,590
to pull those things apart and get them

00:03:24,370 --> 00:03:28,510
super isolated so that you can do proper

00:03:26,590 --> 00:03:31,840
unit testing on them mock out their

00:03:28,510 --> 00:03:35,169
collaborators and do what you have to do

00:03:31,840 --> 00:03:40,750
to get down each of the kind of deep

00:03:35,169 --> 00:03:44,220
branches in that module you basically

00:03:40,750 --> 00:03:47,199
have to be relatively compliant with

00:03:44,220 --> 00:03:48,729
just about every object-oriented

00:03:47,199 --> 00:03:51,069
principle and here I'm talking about the

00:03:48,729 --> 00:03:52,659
solidus single responsibility principle

00:03:51,069 --> 00:03:56,919
open-closed principle this cop

00:03:52,659 --> 00:03:58,359
substitution principle etc etc and so

00:03:56,919 --> 00:03:59,440
unit testing is kind of the proof that

00:03:58,359 --> 00:04:01,959
you're complying with those things

00:03:59,440 --> 00:04:03,190
because if the if testing is difficult

00:04:01,959 --> 00:04:04,930
for some reason and we'll go through

00:04:03,190 --> 00:04:07,930
some examples of where testing can be

00:04:04,930 --> 00:04:11,620
difficult chances are you have some

00:04:07,930 --> 00:04:13,209
encapsulation violation or something

00:04:11,620 --> 00:04:16,150
like that then that's the reason why the

00:04:13,209 --> 00:04:22,300
testing is difficult and then the last

00:04:16,150 --> 00:04:25,450
thing is that there's a way to do unit

00:04:22,300 --> 00:04:27,040
testing in a team or an organisation

00:04:25,450 --> 00:04:29,260
full full of teams

00:04:27,040 --> 00:04:32,830
where it will very quickly start to not

00:04:29,260 --> 00:04:34,870
pay for itself and so focusing on the

00:04:32,830 --> 00:04:37,270
ease of consumption of those tests and

00:04:34,870 --> 00:04:43,300
the maintenance of those ongoing

00:04:37,270 --> 00:04:45,340
maintenance of those tests is key so the

00:04:43,300 --> 00:04:46,990
way that I think about this is developer

00:04:45,340 --> 00:04:49,330
kind of user experience like what's the

00:04:46,990 --> 00:04:51,430
developer experience like even if even

00:04:49,330 --> 00:04:53,350
if you are a team who's not publishing

00:04:51,430 --> 00:04:55,360
api's I don't mean like what's it like

00:04:53,350 --> 00:04:56,620
to program to that REST API I mean what

00:04:55,360 --> 00:04:58,300
does it like to live and breathe in your

00:04:56,620 --> 00:05:00,490
codebase and work with your team and

00:04:58,300 --> 00:05:01,990
there's a whole lifecycle here with

00:05:00,490 --> 00:05:04,720
regards to not just your implementation

00:05:01,990 --> 00:05:06,760
code but your test code is it easy to

00:05:04,720 --> 00:05:10,270
read is it to write is it easy to build

00:05:06,760 --> 00:05:11,590
and is easy to debug and if you do you

00:05:10,270 --> 00:05:13,540
know two of those things but you don't

00:05:11,590 --> 00:05:15,070
do the other two you aren't capturing

00:05:13,540 --> 00:05:17,500
the whole kind of lifecycle of what the

00:05:15,070 --> 00:05:19,690
developer experience is like and so if

00:05:17,500 --> 00:05:21,640
you're right a whole lot of tests that

00:05:19,690 --> 00:05:23,410
nobody can read tests that are like you

00:05:21,640 --> 00:05:26,470
know 5,000 lines long a piece or

00:05:23,410 --> 00:05:27,880
something like that or it's hard to

00:05:26,470 --> 00:05:29,770
write tests because every time you add a

00:05:27,880 --> 00:05:32,200
test some other test fails because you

00:05:29,770 --> 00:05:34,510
have global state or other kind of kind

00:05:32,200 --> 00:05:36,280
of kinds of transitive problems or if

00:05:34,510 --> 00:05:37,480
the tests are really slow to build so

00:05:36,280 --> 00:05:39,460
people don't build them if they don't

00:05:37,480 --> 00:05:41,110
build them they can't run them or if the

00:05:39,460 --> 00:05:43,480
tests are hard to debug the test fails

00:05:41,110 --> 00:05:45,160
and then it you know takes like a day in

00:05:43,480 --> 00:05:47,590
gdb stepping through stuff to figure out

00:05:45,160 --> 00:05:50,500
what went wrong those are all ways that

00:05:47,590 --> 00:05:52,060
you can get an initial start with unit

00:05:50,500 --> 00:05:53,770
testing and be doing think you're doing

00:05:52,060 --> 00:05:56,440
a good job and then it will fall down as

00:05:53,770 --> 00:05:57,850
you try to scale it out to the rest of

00:05:56,440 --> 00:05:59,350
your team if you have a large team or

00:05:57,850 --> 00:06:02,170
the rest of your org if you have small

00:05:59,350 --> 00:06:03,400
teams in a large org it's important just

00:06:02,170 --> 00:06:05,380
to take care of that stuff upfront

00:06:03,400 --> 00:06:07,120
because if your unit testing is

00:06:05,380 --> 00:06:08,710
successful and it's finding bugs or

00:06:07,120 --> 00:06:10,720
preventing bugs for being introduced and

00:06:08,710 --> 00:06:12,910
all that stuff and people start to have

00:06:10,720 --> 00:06:16,630
a quick uptake on it if you aren't ready

00:06:12,910 --> 00:06:18,490
for that uptake you could have just like

00:06:16,630 --> 00:06:20,410
been like hey you know testing is great

00:06:18,490 --> 00:06:22,390
and then it just completely falls over

00:06:20,410 --> 00:06:23,710
because it doesn't scale and I ask

00:06:22,390 --> 00:06:25,060
people think about these things upfront

00:06:23,710 --> 00:06:28,930
because I like to see in a testing

00:06:25,060 --> 00:06:31,960
succeed in organizations over the longer

00:06:28,930 --> 00:06:33,850
term so here's the agenda brief

00:06:31,960 --> 00:06:34,570
refresher I'm gonna go through it very

00:06:33,850 --> 00:06:39,580
very fast

00:06:34,570 --> 00:06:40,940
and then I'm gonna talk about four

00:06:39,580 --> 00:06:43,640
different areas

00:06:40,940 --> 00:06:45,260
we're in real teams and real projects

00:06:43,640 --> 00:06:49,610
with real ship with real shipping

00:06:45,260 --> 00:06:53,540
product three or four areas where I've

00:06:49,610 --> 00:06:58,250
seen where it actually required some

00:06:53,540 --> 00:07:01,280
real engineering kind of problem-solving

00:06:58,250 --> 00:07:03,650
to figure out how do we test this where

00:07:01,280 --> 00:07:05,120
it's not just brain-dead easy and it's

00:07:03,650 --> 00:07:06,710
not the design problems that I talked

00:07:05,120 --> 00:07:09,050
about in last year's talk last year I

00:07:06,710 --> 00:07:11,120
talked about when implementations are in

00:07:09,050 --> 00:07:15,740
header files or you have template

00:07:11,120 --> 00:07:17,420
classes or other kinds of obstructions

00:07:15,740 --> 00:07:18,800
that make it make things difficult to

00:07:17,420 --> 00:07:20,660
test and how to fix up I talked about

00:07:18,800 --> 00:07:23,780
that last year not gonna I'm not gonna

00:07:20,660 --> 00:07:28,070
talk about those this year but there are

00:07:23,780 --> 00:07:31,600
some some kind of unique problems that

00:07:28,070 --> 00:07:34,700
I'm happy to share partial solutions or

00:07:31,600 --> 00:07:37,400
summarized solutions so the first one is

00:07:34,700 --> 00:07:39,080
unit testing kernel code specifically

00:07:37,400 --> 00:07:41,570
unit testing kernel code and I'm talking

00:07:39,080 --> 00:07:46,210
Linux kernel here but the same kind of

00:07:41,570 --> 00:07:48,740
thing could apply to Q and X or whatever

00:07:46,210 --> 00:07:50,540
whatever proprietary operating system

00:07:48,740 --> 00:07:53,690
you happen to be using testing that

00:07:50,540 --> 00:07:55,400
kernel code in user land and so you know

00:07:53,690 --> 00:07:57,980
to inject a unit testing framework into

00:07:55,400 --> 00:08:02,240
the kernel to get things to work

00:07:57,980 --> 00:08:04,370
mocking standard library functions you

00:08:02,240 --> 00:08:08,600
know basically like how do i how do i

00:08:04,370 --> 00:08:13,400
mock out receive and send and low-level

00:08:08,600 --> 00:08:14,930
lib see kind of i/o calls mocking with

00:08:13,400 --> 00:08:17,060
Singleton's and factories which i

00:08:14,930 --> 00:08:19,190
touched on one aspect of last year but

00:08:17,060 --> 00:08:21,470
the follow-up questions that I got via

00:08:19,190 --> 00:08:25,630
people sending me messages on LinkedIn

00:08:21,470 --> 00:08:25,630
or Twitter or whatever in an email

00:08:25,720 --> 00:08:32,479
illuminate for me that I left out an

00:08:29,300 --> 00:08:33,770
important mmm an important deeper detail

00:08:32,479 --> 00:08:41,440
of that that we're going to talk about

00:08:33,770 --> 00:08:44,360
and then the last thing is is excuse me

00:08:41,440 --> 00:08:46,850
framework customization of assertions or

00:08:44,360 --> 00:08:50,089
constraints and reporters there's kind

00:08:46,850 --> 00:08:51,530
of kind of you know the previous slide I

00:08:50,089 --> 00:08:52,900
talked about you know the reading the

00:08:51,530 --> 00:08:57,730
writing the

00:08:52,900 --> 00:09:02,350
was it reading reading writing building

00:08:57,730 --> 00:09:06,760
and debugging of unit tests and there's

00:09:02,350 --> 00:09:09,550
other kind of some finer points of

00:09:06,760 --> 00:09:11,140
making sure you have a deployment of a

00:09:09,550 --> 00:09:13,360
unit testing framework if you're in a

00:09:11,140 --> 00:09:15,070
large team or in a large ordered with

00:09:13,360 --> 00:09:17,590
lots of small teams that if you're all

00:09:15,070 --> 00:09:20,730
going to be on the same framework you

00:09:17,590 --> 00:09:23,130
should keep in mind so you don't hit

00:09:20,730 --> 00:09:26,530
deployment problems which I'll go into

00:09:23,130 --> 00:09:29,110
so like I did last year for the

00:09:26,530 --> 00:09:31,390
multitaskers I realize in the modern day

00:09:29,110 --> 00:09:33,490
of conference presentations that people

00:09:31,390 --> 00:09:36,720
are on their laptops or the tablets or

00:09:33,490 --> 00:09:39,220
their cyborg implant devices or whatever

00:09:36,720 --> 00:09:40,420
while I'm talking and I have made my

00:09:39,220 --> 00:09:43,900
peace with that

00:09:40,420 --> 00:09:47,440
so so if you didn't see the talk last

00:09:43,900 --> 00:09:49,810
year or you did but you need a refresher

00:09:47,440 --> 00:09:51,670
anyway you can go to those URLs and you

00:09:49,810 --> 00:09:53,530
can read a little bit about sea greenery

00:09:51,670 --> 00:09:54,970
a little bit of about mockito PP those

00:09:53,530 --> 00:09:56,560
are the two frameworks that my code is

00:09:54,970 --> 00:10:00,160
going to be my sample code is going to

00:09:56,560 --> 00:10:03,060
be in if you want to just do that in

00:10:00,160 --> 00:10:05,380
parallel with me talking or not

00:10:03,060 --> 00:10:10,420
undivided attention is great to remember

00:10:05,380 --> 00:10:11,980
the good old days so and you can just

00:10:10,420 --> 00:10:13,630
search for YouTube on YouTube for

00:10:11,980 --> 00:10:15,640
practical unit testing and C++ and the

00:10:13,630 --> 00:10:19,420
CPP Khan YouTube channel and you can

00:10:15,640 --> 00:10:23,530
find it don't watch the video on talking

00:10:19,420 --> 00:10:26,470
but that's that's not the multitasking

00:10:23,530 --> 00:10:27,910
thing I want you to do but the link is

00:10:26,470 --> 00:10:29,680
here and when I give the guys the

00:10:27,910 --> 00:10:32,140
presentation and they put it up on the

00:10:29,680 --> 00:10:33,900
website or whatever they do that link is

00:10:32,140 --> 00:10:43,510
right there so you can just click on it

00:10:33,900 --> 00:10:46,110
so here's the refresher so the entry

00:10:43,510 --> 00:10:49,330
points unit testing for me in any any

00:10:46,110 --> 00:10:51,670
team or company or whatever is what was

00:10:49,330 --> 00:10:54,880
the last major bug that you had that

00:10:51,670 --> 00:10:56,560
especially bugs that got deployed to

00:10:54,880 --> 00:10:58,030
customers or got out into the field

00:10:56,560 --> 00:10:59,260
somehow right because those are the bugs

00:10:58,030 --> 00:11:01,030
that got passed all of your other safety

00:10:59,260 --> 00:11:02,560
nuts they got past your QA or static

00:11:01,030 --> 00:11:04,600
analysis your code reviews your bla bla

00:11:02,560 --> 00:11:06,370
bla bla bla right so if it got past all

00:11:04,600 --> 00:11:06,670
of your safety nets assuming you have

00:11:06,370 --> 00:11:08,380
this

00:11:06,670 --> 00:11:11,620
series of safety nets let's be

00:11:08,380 --> 00:11:12,730
optimistic and assume that you do you

00:11:11,620 --> 00:11:14,350
know those bugs I get out to the field

00:11:12,730 --> 00:11:16,090
they're so expensive to fix you have to

00:11:14,350 --> 00:11:18,160
fix it and then deploy a fix and if that

00:11:16,090 --> 00:11:22,120
fix then introduces more problems and

00:11:18,160 --> 00:11:24,400
you're in a world of pain so so those

00:11:22,120 --> 00:11:26,170
are the kinds of pains and costs where

00:11:24,400 --> 00:11:28,300
it's like okay let's introduce unit

00:11:26,170 --> 00:11:30,070
testing it's not completely automated

00:11:28,300 --> 00:11:33,550
like we have to actually think about the

00:11:30,070 --> 00:11:34,510
tests that we're writing and so people

00:11:33,550 --> 00:11:36,250
go well we don't have time to write

00:11:34,510 --> 00:11:37,900
tests and it's like well you're gonna

00:11:36,250 --> 00:11:40,000
have time to write tests but you do have

00:11:37,900 --> 00:11:41,680
time to like do like emergency deploys

00:11:40,000 --> 00:11:42,970
to the field for the customer of three

00:11:41,680 --> 00:11:47,530
o'clock in the morning I don't

00:11:42,970 --> 00:11:48,700
understand that I mean everybody has

00:11:47,530 --> 00:11:51,850
their preferences on how they like to

00:11:48,700 --> 00:11:54,340
spend their time at 3 a.m. I'd rather

00:11:51,850 --> 00:11:56,110
write a unit test at 3 p.m. then wake up

00:11:54,340 --> 00:11:59,550
at 3 a.m. to do an emergency B debug

00:11:56,110 --> 00:12:03,430
session on a live piece of hardware so

00:11:59,550 --> 00:12:06,550
so here's a here's a condensed example

00:12:03,430 --> 00:12:09,220
from a real a real product that I worked

00:12:06,550 --> 00:12:12,130
on so the bug report says that there's a

00:12:09,220 --> 00:12:13,660
crash when some device is missing how do

00:12:12,130 --> 00:12:15,520
we test regardless of the hardware right

00:12:13,660 --> 00:12:16,690
because for unit testing we want to test

00:12:15,520 --> 00:12:18,730
the code that we're writing in our

00:12:16,690 --> 00:12:20,200
development environment right not on the

00:12:18,730 --> 00:12:21,400
board not on the appliance or whatever

00:12:20,200 --> 00:12:24,100
you can test there too and you should

00:12:21,400 --> 00:12:26,230
test there too but the first the first

00:12:24,100 --> 00:12:29,110
thing we want to do is make sure that

00:12:26,230 --> 00:12:32,680
the code that I wrote is what I intended

00:12:29,110 --> 00:12:36,190
it does what I intended it to do not we

00:12:32,680 --> 00:12:38,320
got not accounting for on the target

00:12:36,190 --> 00:12:40,840
board the compiler that you're using is

00:12:38,320 --> 00:12:42,070
going to have a wrong code bug that yes

00:12:40,840 --> 00:12:43,570
all that does happen and that's why

00:12:42,070 --> 00:12:44,620
integration test and system tests are

00:12:43,570 --> 00:12:46,540
good and you should do those too

00:12:44,620 --> 00:12:47,890
but for unit level testing we want to be

00:12:46,540 --> 00:12:50,920
in the development environment so I can

00:12:47,890 --> 00:12:53,320
build run modify build run modify build

00:12:50,920 --> 00:12:54,880
run modify in a very very tight loop if

00:12:53,320 --> 00:12:58,030
I have to upload to some embedded device

00:12:54,880 --> 00:12:59,830
on a 9600 bps UART every single time I

00:12:58,030 --> 00:13:01,390
make a modification I'm going to batch

00:12:59,830 --> 00:13:03,340
up my modifications have more

00:13:01,390 --> 00:13:05,950
modifications every time I upload the

00:13:03,340 --> 00:13:08,170
firmware image which means that there's

00:13:05,950 --> 00:13:09,520
gonna be more mistakes potentially so

00:13:08,170 --> 00:13:11,320
when something does go wrong I have a

00:13:09,520 --> 00:13:13,330
larger diff to look through and that

00:13:11,320 --> 00:13:15,610
gets in the way of me being a productive

00:13:13,330 --> 00:13:18,400
developer so how do we test regardless

00:13:15,610 --> 00:13:19,680
of the hardware and I it's big enough I

00:13:18,400 --> 00:13:22,560
think it's big enough

00:13:19,680 --> 00:13:29,089
for you guys anyway so here's a here's a

00:13:22,560 --> 00:13:31,770
small code example regarding PCI devices

00:13:29,089 --> 00:13:33,660
and so let's pretend like this is the

00:13:31,770 --> 00:13:36,060
implementation source file broadcast dot

00:13:33,660 --> 00:13:39,630
see the names may have been changed to

00:13:36,060 --> 00:13:41,580
protect the innocent so what we want to

00:13:39,630 --> 00:13:44,010
do is that we want to stub out the

00:13:41,580 --> 00:13:47,760
collaborators so how do we find out what

00:13:44,010 --> 00:13:51,959
those collaborators are well one thing

00:13:47,760 --> 00:13:55,380
that we we know what the function name

00:13:51,959 --> 00:13:58,709
is so in our main we declare that at the

00:13:55,380 --> 00:14:00,660
top because in the legacy code unless in

00:13:58,709 --> 00:14:02,700
a legacy code base just pound including

00:14:00,660 --> 00:14:04,980
one file can sometimes just bring in a

00:14:02,700 --> 00:14:06,690
whole world of crap of static

00:14:04,980 --> 00:14:09,480
constructors and macros with weird names

00:14:06,690 --> 00:14:10,890
and no namespaces and stuff like that so

00:14:09,480 --> 00:14:13,290
when I'm unit testing a brand new system

00:14:10,890 --> 00:14:15,330
I like to just here's the function I

00:14:13,290 --> 00:14:17,670
want I just want to take the dot o that

00:14:15,330 --> 00:14:20,399
contains that function and include is a

00:14:17,670 --> 00:14:23,550
few header files as I possibly can so we

00:14:20,399 --> 00:14:25,020
declared at the top if the header files

00:14:23,550 --> 00:14:27,300
are all fine and you can pan include

00:14:25,020 --> 00:14:28,290
them great but if you can't because they

00:14:27,300 --> 00:14:31,320
complicate things

00:14:28,290 --> 00:14:32,940
then don't and then I just have an int

00:14:31,320 --> 00:14:35,580
main I'm not using a test framework here

00:14:32,940 --> 00:14:37,350
yet I said an int main my neck I'll get

00:14:35,580 --> 00:14:41,490
broadcast ID from network which was the

00:14:37,350 --> 00:14:43,950
function on the previous page and as had

00:14:41,490 --> 00:14:46,800
to return zero so I go to compile that

00:14:43,950 --> 00:14:49,860
and it says hey there's an undefined

00:14:46,800 --> 00:14:52,260
reference to PCI fine device and device

00:14:49,860 --> 00:14:54,480
read packet this is what Michael

00:14:52,260 --> 00:14:56,400
feathers in his book working effectively

00:14:54,480 --> 00:15:02,520
with legacy code which I hope they have

00:14:56,400 --> 00:15:04,380
at the table excellent this what he

00:15:02,520 --> 00:15:06,029
calls leaning on the compiler or leaning

00:15:04,380 --> 00:15:08,730
on the tool chain right just like follow

00:15:06,029 --> 00:15:10,610
the error messages and that's great it

00:15:08,730 --> 00:15:13,260
can be actually quite idiomatic and this

00:15:10,610 --> 00:15:15,420
anyway it can be quite idiomatic

00:15:13,260 --> 00:15:16,709
which is also tedious potentially

00:15:15,420 --> 00:15:18,240
depending on how many error messages

00:15:16,709 --> 00:15:22,050
that you have but in this case we have

00:15:18,240 --> 00:15:23,670
to it can't find those two things so I'm

00:15:22,050 --> 00:15:25,800
gonna make another file where I'm going

00:15:23,670 --> 00:15:31,620
to stub out those things I'm going to

00:15:25,800 --> 00:15:32,750
call it a PCI mock so I make a PCI dead

00:15:31,620 --> 00:15:36,500
struct and

00:15:32,750 --> 00:15:38,000
make a PCI fine device and I'm just

00:15:36,500 --> 00:15:39,800
gonna return null right I'm just trying

00:15:38,000 --> 00:15:43,879
to get it to link before I get it to run

00:15:39,800 --> 00:15:47,029
right and just deal with one thing at a

00:15:43,879 --> 00:15:48,769
time right so okay we get it - we put

00:15:47,029 --> 00:15:51,319
our stubs in place we get it to compile

00:15:48,769 --> 00:15:52,910
it links we go to run it right and the

00:15:51,319 --> 00:15:55,579
bug was at it crashes than the device as

00:15:52,910 --> 00:15:56,990
a present so we expect a crash right but

00:15:55,579 --> 00:15:58,579
is this the right crash is this the

00:15:56,990 --> 00:16:03,110
crash that we actually expected to

00:15:58,579 --> 00:16:05,620
happen so and what if we need to like

00:16:03,110 --> 00:16:07,819
stub different values like we just made

00:16:05,620 --> 00:16:09,800
excuse me our implementation of that

00:16:07,819 --> 00:16:11,980
function that stub just returned null

00:16:09,800 --> 00:16:14,660
but what happens if we need to return

00:16:11,980 --> 00:16:17,540
not null or have a series of return

00:16:14,660 --> 00:16:18,529
values like I want to return something

00:16:17,540 --> 00:16:20,870
good something good something good

00:16:18,529 --> 00:16:25,279
something bad so we need something

00:16:20,870 --> 00:16:26,600
smarter than stubs which is mocks so we

00:16:25,279 --> 00:16:28,009
want to use mocks when we need to have a

00:16:26,600 --> 00:16:31,699
different return value each time the

00:16:28,009 --> 00:16:33,350
mock is called on a / function if we're

00:16:31,699 --> 00:16:35,000
talking about C or global functions or

00:16:33,350 --> 00:16:38,269
per instance if we're talking about

00:16:35,000 --> 00:16:39,860
object instances in C++ we need to do

00:16:38,269 --> 00:16:43,730
that so we can exercise robust code

00:16:39,860 --> 00:16:45,649
paths right and the the background I I

00:16:43,730 --> 00:16:49,750
really come from on this is like parsing

00:16:45,649 --> 00:16:51,620
binary networking protocols where

00:16:49,750 --> 00:16:53,569
especially if someone is trying to

00:16:51,620 --> 00:16:55,519
attack your protocol stack they are

00:16:53,569 --> 00:16:58,309
going to be messing with sending you

00:16:55,519 --> 00:17:00,199
messed up packets right and instead of

00:16:58,309 --> 00:17:01,519
just sending you like the first packet

00:17:00,199 --> 00:17:04,189
like the beginning of the handshake

00:17:01,519 --> 00:17:06,500
being messed up the real good bugs are

00:17:04,189 --> 00:17:10,429
underneath all of that right where it's

00:17:06,500 --> 00:17:13,010
like I get so far into the IPSec or the

00:17:10,429 --> 00:17:15,770
Ike negotiation and then it's like on

00:17:13,010 --> 00:17:18,829
packet number 18 into the handshake I

00:17:15,770 --> 00:17:20,299
introduce some kind of funky packet that

00:17:18,829 --> 00:17:22,610
causes a buffer overflow or some other

00:17:20,299 --> 00:17:24,949
kind of bug so we want to be able to

00:17:22,610 --> 00:17:29,330
exercise those robust code pads in these

00:17:24,949 --> 00:17:30,530
kind of critical systems and we want to

00:17:29,330 --> 00:17:31,940
do that without too much maintenance

00:17:30,530 --> 00:17:34,250
overhead right we don't want to have

00:17:31,940 --> 00:17:36,200
like a different like link time mock we

00:17:34,250 --> 00:17:39,169
don't have like mock PCI that returns

00:17:36,200 --> 00:17:41,960
one dot see mock PCI that returns to dot

00:17:39,169 --> 00:17:44,360
C mock PCI like that's ridiculous

00:17:41,960 --> 00:17:45,649
so it's ridiculous because of the amount

00:17:44,360 --> 00:17:46,340
of maintenance overhead where if I

00:17:45,649 --> 00:17:47,890
changed

00:17:46,340 --> 00:17:51,890
that function I have to now go edit

00:17:47,890 --> 00:17:54,080
however many files so don't that want

00:17:51,890 --> 00:17:56,900
that to happen and what would be really

00:17:54,080 --> 00:17:59,090
swell Anais is if that specification of

00:17:56,900 --> 00:18:00,380
like return this return this return this

00:17:59,090 --> 00:18:02,870
return this that sequence of return

00:18:00,380 --> 00:18:04,730
values and things worth in the scope of

00:18:02,870 --> 00:18:08,270
the tests so that I could just look in

00:18:04,730 --> 00:18:14,360
one place at the test and see what's

00:18:08,270 --> 00:18:16,429
going on so here's an example using AC

00:18:14,360 --> 00:18:18,200
green mocks like syntax even though

00:18:16,429 --> 00:18:20,840
we're still just in our main function

00:18:18,200 --> 00:18:25,880
here so I'm going to be able to write

00:18:20,840 --> 00:18:29,210
like expect PCI fine device will return

00:18:25,880 --> 00:18:31,490
null expect device get packet will

00:18:29,210 --> 00:18:37,520
return null and then I call get

00:18:31,490 --> 00:18:39,620
broadcast ID from network so that's cool

00:18:37,520 --> 00:18:43,010
because now instead of having to go to

00:18:39,620 --> 00:18:44,450
mock PCI Moxie and see what is it what

00:18:43,010 --> 00:18:44,840
does that stub return again I don't

00:18:44,450 --> 00:18:47,330
remember

00:18:44,840 --> 00:18:48,950
oh it returns null I can just see it

00:18:47,330 --> 00:18:50,630
right here and if I wanted to return non

00:18:48,950 --> 00:18:52,700
null it's all within the scope of that

00:18:50,630 --> 00:18:54,320
test it's all within those two curly

00:18:52,700 --> 00:18:55,750
braces and this is one of the things

00:18:54,320 --> 00:19:01,100
where we're optimizing for readability

00:18:55,750 --> 00:19:02,690
for us for our peers or whatever so and

00:19:01,100 --> 00:19:06,230
we need we want to prove details of a

00:19:02,690 --> 00:19:07,669
fix right so before it was crashing we

00:19:06,230 --> 00:19:10,460
don't want it to crash when the device

00:19:07,669 --> 00:19:12,399
is a present let's say that let's say

00:19:10,460 --> 00:19:16,250
that what we actually expect is that

00:19:12,399 --> 00:19:20,210
it'll do a print kay a criminal blog log

00:19:16,250 --> 00:19:22,880
print when the device isn't present so

00:19:20,210 --> 00:19:25,429
in the second example there I set my

00:19:22,880 --> 00:19:28,940
expectations for the collaborators those

00:19:25,429 --> 00:19:30,679
two global functions I'm mocking and

00:19:28,940 --> 00:19:35,510
then I set an expectation that print K

00:19:30,679 --> 00:19:37,820
will be called and in the see green mock

00:19:35,510 --> 00:19:39,440
parlance if I set an expectation senton

00:19:37,820 --> 00:19:43,210
will be called and I get out of the test

00:19:39,440 --> 00:19:43,210
and it wasn't called that as a failure

00:19:43,299 --> 00:19:47,659
again I'm going through this very

00:19:45,110 --> 00:19:49,039
quickly because I did this this stuff

00:19:47,659 --> 00:19:53,120
last year but I didn't want to like go

00:19:49,039 --> 00:19:55,010
into this completely cold so so see

00:19:53,120 --> 00:19:56,450
green and some of you may notice like

00:19:55,010 --> 00:19:58,820
see garena has moved to github so as

00:19:56,450 --> 00:19:59,879
machito peepee the other framework which

00:19:58,820 --> 00:20:03,079
has really

00:19:59,879 --> 00:20:06,059
stated a lot of activity which is great

00:20:03,079 --> 00:20:07,499
so all the examples are using C grain C

00:20:06,059 --> 00:20:09,749
green is cross language between C and

00:20:07,499 --> 00:20:11,489
C++ it's the exact same framework the

00:20:09,749 --> 00:20:13,859
exact same syntax where they're using C

00:20:11,489 --> 00:20:15,119
or C++ the reason why that was important

00:20:13,859 --> 00:20:16,469
to me for the projects I was on is

00:20:15,119 --> 00:20:18,269
because all of those projects had

00:20:16,469 --> 00:20:19,859
kernel-mode components which were

00:20:18,269 --> 00:20:21,599
written in C and then userland

00:20:19,859 --> 00:20:22,799
components which were written in C++ and

00:20:21,599 --> 00:20:24,059
having two different different

00:20:22,799 --> 00:20:25,529
frameworks with completely different

00:20:24,059 --> 00:20:28,379
syntaxes and completely different

00:20:25,529 --> 00:20:30,659
semantics between those two parts of the

00:20:28,379 --> 00:20:33,109
technology stack made the uptake of unit

00:20:30,659 --> 00:20:35,369
testing very difficult so C green

00:20:33,109 --> 00:20:38,190
basically is kind of one framework to

00:20:35,369 --> 00:20:39,779
rule them all across across all of both

00:20:38,190 --> 00:20:40,979
of all of those teams they could all

00:20:39,779 --> 00:20:43,259
read each other's tests they can all

00:20:40,979 --> 00:20:45,749
modify each other's tests and it was

00:20:43,259 --> 00:20:47,729
just reduced the kind of beared entry

00:20:45,749 --> 00:20:49,229
there the other thing is C green there's

00:20:47,729 --> 00:20:52,219
no kind of weird code generators in

00:20:49,229 --> 00:20:54,569
between here this is just pure C and C++

00:20:52,219 --> 00:20:55,979
there's some macros and stuff but we

00:20:54,569 --> 00:20:57,239
tried to keep that to a minimum we tried

00:20:55,979 --> 00:20:59,339
to make sure things are names based if

00:20:57,239 --> 00:21:05,669
you're using C++ so that everything

00:20:59,339 --> 00:21:10,409
plays really nice so so in C green we

00:21:05,669 --> 00:21:12,359
say describe whatever the system under

00:21:10,409 --> 00:21:14,489
test or the component on your test is

00:21:12,359 --> 00:21:16,049
and then we have before each and after

00:21:14,489 --> 00:21:17,819
each that's the setup and teardown that

00:21:16,049 --> 00:21:22,799
runs before each test and after each

00:21:17,819 --> 00:21:25,199
test and then the tests are the tests

00:21:22,799 --> 00:21:27,269
are phrase like ensure whatever the

00:21:25,199 --> 00:21:29,190
context is in this case TCP parser and

00:21:27,269 --> 00:21:31,499
then whatever however you want that to

00:21:29,190 --> 00:21:32,909
read it reading is English as a is nice

00:21:31,499 --> 00:21:37,769
because you can generate documentation

00:21:32,909 --> 00:21:43,499
from it we make a TCP parser and then we

00:21:37,769 --> 00:21:45,359
assert that parser underscore read parts

00:21:43,499 --> 00:21:46,859
or underscore read when I pass in the

00:21:45,359 --> 00:21:49,739
legitimate parser and I passed a null

00:21:46,859 --> 00:21:52,109
returns null so cert that parser read

00:21:49,739 --> 00:21:54,509
when I pass in parser null is null and

00:21:52,109 --> 00:21:57,419
in assert that the parser count when I

00:21:54,509 --> 00:21:58,529
pass in the parts pass in the parser

00:21:57,419 --> 00:22:01,349
that's hard to say

00:21:58,529 --> 00:22:02,940
when I pass in the parser that the

00:22:01,349 --> 00:22:04,969
parser count is zero so basically what

00:22:02,940 --> 00:22:08,249
it's saying is like oh if I tell you -

00:22:04,969 --> 00:22:09,659
if I tell you to parse a read but I give

00:22:08,249 --> 00:22:11,759
you an invalid argument don't increase

00:22:09,659 --> 00:22:13,110
that parse count that's the behavior

00:22:11,759 --> 00:22:16,950
that this test is pinning

00:22:13,110 --> 00:22:19,160
so I go to compile that test I go to run

00:22:16,950 --> 00:22:21,870
that test and then it fails saying

00:22:19,160 --> 00:22:25,260
expected parser count for parser two

00:22:21,870 --> 00:22:27,000
equals zero but I got one instead right

00:22:25,260 --> 00:22:29,160
I think it's nice about this and this is

00:22:27,000 --> 00:22:31,740
that readability piece of this is that I

00:22:29,160 --> 00:22:33,360
don't have to set a break point to see

00:22:31,740 --> 00:22:37,170
what the return value was I know what it

00:22:33,360 --> 00:22:39,630
is the test runner just told me and this

00:22:37,170 --> 00:22:41,460
is like the nice thing versus you know

00:22:39,630 --> 00:22:44,490
just using like flat out sea level

00:22:41,460 --> 00:22:47,100
asserts and stuff like that and and that

00:22:44,490 --> 00:22:48,600
little round trip there about what is

00:22:47,100 --> 00:22:51,000
what does it like for the developer when

00:22:48,600 --> 00:22:52,500
the test fails is a key part of

00:22:51,000 --> 00:22:54,600
developer or user experience especially

00:22:52,500 --> 00:22:56,580
when you're scaling up an engineering

00:22:54,600 --> 00:23:00,300
team or a development team or bringing

00:22:56,580 --> 00:23:01,950
in lots of juniors so see green supplies

00:23:00,300 --> 00:23:07,620
a mock framework like we talked a little

00:23:01,950 --> 00:23:19,470
bit about before and so in the previous

00:23:07,620 --> 00:23:21,330
test here nope nevermind so in the so in

00:23:19,470 --> 00:23:23,130
this particular thing what we're doing

00:23:21,330 --> 00:23:25,230
is that we are gonna mock out the

00:23:23,130 --> 00:23:26,520
function called stream read and it

00:23:25,230 --> 00:23:28,260
doesn't have to be here in the test file

00:23:26,520 --> 00:23:30,630
right it just needs to be there at link

00:23:28,260 --> 00:23:33,660
time so that when the consumer of stream

00:23:30,630 --> 00:23:35,220
read the consumer of street stream

00:23:33,660 --> 00:23:37,860
reidman we're linking it actually gets a

00:23:35,220 --> 00:23:40,920
stream read symbol to link to and here

00:23:37,860 --> 00:23:44,160
inside of it we're calling the mock

00:23:40,920 --> 00:23:47,220
macro of sea greens and the mock macro

00:23:44,160 --> 00:23:48,630
takes in the arguments and the argument

00:23:47,220 --> 00:23:51,980
name so takes in the names and the

00:23:48,630 --> 00:23:56,070
values using some preprocessor magic and

00:23:51,980 --> 00:23:58,140
then returns some some value so we're

00:23:56,070 --> 00:24:00,120
describing tcp parser the before and

00:23:58,140 --> 00:24:02,610
after before each and after each are

00:24:00,120 --> 00:24:04,050
empty and we're saying ensure tcp parser

00:24:02,610 --> 00:24:07,140
stops reading at the end of the stream

00:24:04,050 --> 00:24:08,610
so i make a tcp parser I'm gonna set my

00:24:07,140 --> 00:24:10,740
constants end of stream to be negative

00:24:08,610 --> 00:24:13,610
one and I'm gonna say expect stream read

00:24:10,740 --> 00:24:18,750
so expect that that will be called when

00:24:13,610 --> 00:24:21,030
the parameter named input named input is

00:24:18,750 --> 00:24:23,340
non null and then I want you to return

00:24:21,030 --> 00:24:24,810
end of stream right so what it's saying

00:24:23,340 --> 00:24:26,669
is when stream reading it's called I

00:24:24,810 --> 00:24:29,309
don't care what the input is as long as

00:24:26,669 --> 00:24:30,720
not null and when that happens return

00:24:29,309 --> 00:24:33,419
end of stream which in this case is

00:24:30,720 --> 00:24:35,489
negative one right and then we call

00:24:33,419 --> 00:24:37,470
parser next chunk and the implication

00:24:35,489 --> 00:24:39,119
here is that parser next chunk at some

00:24:37,470 --> 00:24:44,659
point collaborates with that global

00:24:39,119 --> 00:24:47,549
function called stream read and then

00:24:44,659 --> 00:24:49,440
write and then we go to run the test and

00:24:47,549 --> 00:24:50,759
it says I got more calls than expected

00:24:49,440 --> 00:24:52,710
to stream read we only gave it the

00:24:50,759 --> 00:24:55,169
expectation it would get called one time

00:24:52,710 --> 00:24:56,850
right because if it gets called and then

00:24:55,169 --> 00:24:57,899
that returns negative one you shouldn't

00:24:56,850 --> 00:24:59,700
get called again you got the end of

00:24:57,899 --> 00:25:01,889
stream why are you continuing to you

00:24:59,700 --> 00:25:05,549
know why would you continue to call it

00:25:01,889 --> 00:25:07,710
so so this is an example of you know

00:25:05,549 --> 00:25:09,989
stream read for whatever reason we

00:25:07,710 --> 00:25:12,239
wanted to mock it out maybe it had I Oh

00:25:09,989 --> 00:25:13,950
in it or it connected to the connected

00:25:12,239 --> 00:25:15,509
to the network connected to database did

00:25:13,950 --> 00:25:17,369
something computationally expensive who

00:25:15,509 --> 00:25:18,659
knows who cares right the main thing

00:25:17,369 --> 00:25:20,249
that we're testing here is it is the

00:25:18,659 --> 00:25:21,899
interaction right we're not testing

00:25:20,249 --> 00:25:24,179
stream read here we're unit testing the

00:25:21,899 --> 00:25:26,820
TCP parser and so we're trying to

00:25:24,179 --> 00:25:30,119
isolate the TCP parser from its real

00:25:26,820 --> 00:25:31,799
collaborators because the more real

00:25:30,119 --> 00:25:33,989
actors that you bring in the more real

00:25:31,799 --> 00:25:35,580
collaborators you bring into a test the

00:25:33,989 --> 00:25:36,960
harder it's going to be to debug the why

00:25:35,580 --> 00:25:40,950
to the surface area that you'll have to

00:25:36,960 --> 00:25:42,720
debug when something goes wrong and so

00:25:40,950 --> 00:25:45,330
by doing these mocks and isolating it

00:25:42,720 --> 00:25:47,580
this way we have exactly one file to

00:25:45,330 --> 00:25:50,820
look in right which is wherever the TCP

00:25:47,580 --> 00:25:52,080
parser object lives our mocks are right

00:25:50,820 --> 00:25:54,179
here in the test file we don't go

00:25:52,080 --> 00:25:59,070
anywhere to go look for them anything

00:25:54,179 --> 00:26:03,690
like that so that's link time mocks with

00:25:59,070 --> 00:26:12,960
global functions so what about actual

00:26:03,690 --> 00:26:14,549
C++ testing so so there's this other

00:26:12,960 --> 00:26:16,320
mock frameworks and I want to like go

00:26:14,549 --> 00:26:18,869
into like the pros and cons of each of

00:26:16,320 --> 00:26:21,450
them but the one that I recommend and

00:26:18,869 --> 00:26:24,239
use is mockito pee pee and basically

00:26:21,450 --> 00:26:26,009
with mockito pee pee you can what

00:26:24,239 --> 00:26:28,350
mockito pee pee ends up doing underneath

00:26:26,009 --> 00:26:31,559
which is like so really just utterly

00:26:28,350 --> 00:26:34,669
magical and amazing is it is that it

00:26:31,559 --> 00:26:37,259
creates anonymous classes at runtime

00:26:34,669 --> 00:26:39,970
based on a pure virtual class that you

00:26:37,259 --> 00:26:42,010
give it that's

00:26:39,970 --> 00:26:45,450
crux of how it works so here in this

00:26:42,010 --> 00:26:48,520
example to have a mouse there a laser

00:26:45,450 --> 00:26:50,530
anyway here in this example I have a

00:26:48,520 --> 00:26:53,920
struct stream and it has a pure virtual

00:26:50,530 --> 00:26:56,470
method on it called read and then in my

00:26:53,920 --> 00:27:01,540
C green test I make a mock object of

00:26:56,470 --> 00:27:05,790
stream and then I told that mock object

00:27:01,540 --> 00:27:11,080
of stream to expect a call to the read

00:27:05,790 --> 00:27:13,180
method on stream where the parameter

00:27:11,080 --> 00:27:18,300
being passed to it is a zero and I want

00:27:13,180 --> 00:27:20,380
you to want it to return zero and

00:27:18,300 --> 00:27:22,060
looking at the syntax are like what's

00:27:20,380 --> 00:27:23,770
the big deal who cares like yeah it's a

00:27:22,060 --> 00:27:25,480
couple lines of code go look at the

00:27:23,770 --> 00:27:28,150
implementation for this it's really

00:27:25,480 --> 00:27:30,240
really neat Trevor pounds whoo-hoo

00:27:28,150 --> 00:27:34,270
authored a mockito PP did a great job

00:27:30,240 --> 00:27:36,730
and then so then we need to pull out

00:27:34,270 --> 00:27:38,530
that stream type out of the mock so we

00:27:36,730 --> 00:27:41,410
say mock stream get instance and that

00:27:38,530 --> 00:27:42,970
gives us a stream reference and then we

00:27:41,410 --> 00:27:45,430
can pass that into the collaborator in

00:27:42,970 --> 00:27:47,380
this case it's TCP parser and then we

00:27:45,430 --> 00:27:49,510
call parser next chunk so these are

00:27:47,380 --> 00:27:50,620
basically two different examples of two

00:27:49,510 --> 00:27:52,030
different examples of the same thing

00:27:50,620 --> 00:27:53,860
except in one case we're mocking a

00:27:52,030 --> 00:27:55,900
global function and that's what we have

00:27:53,860 --> 00:27:59,350
to kind of do our mocks on and and

00:27:55,900 --> 00:28:02,470
insert a mock at link time here with C++

00:27:59,350 --> 00:28:03,640
and having a pure virtual interface and

00:28:02,470 --> 00:28:04,930
stuff we can do that same kind of

00:28:03,640 --> 00:28:08,940
composition at runtime where there's

00:28:04,930 --> 00:28:08,940
this awesome thing about C++ and objects

00:28:09,120 --> 00:28:17,440
so that is the as quick as I could

00:28:14,440 --> 00:28:21,040
reasonably make it refresher on the

00:28:17,440 --> 00:28:23,110
stuff from last year so now we're going

00:28:21,040 --> 00:28:24,730
to get into some deeper topics and I've

00:28:23,110 --> 00:28:29,650
hopefully less some time at the end so

00:28:24,730 --> 00:28:31,210
that you guys can also just like poke me

00:28:29,650 --> 00:28:33,850
in the eye with some really deep hard

00:28:31,210 --> 00:28:34,930
questions about like the code you'd like

00:28:33,850 --> 00:28:38,040
the own code your own code that you work

00:28:34,930 --> 00:28:44,890
on so unit testing kernel code is

00:28:38,040 --> 00:28:47,260
difficult because there's obviously ways

00:28:44,890 --> 00:28:49,240
you can dynamically load kernel modules

00:28:47,260 --> 00:28:50,650
that have unit testing frameworks in

00:28:49,240 --> 00:28:51,549
them and load them and unload them and

00:28:50,650 --> 00:28:54,820
run them that way

00:28:51,549 --> 00:28:59,049
but if something goes wrong you're going

00:28:54,820 --> 00:29:03,009
to panic either the VM that you're

00:28:59,049 --> 00:29:04,090
running in or your own or your own

00:29:03,009 --> 00:29:06,899
machine if you're doing it on your live

00:29:04,090 --> 00:29:10,269
machine and not inside of a VM but also

00:29:06,899 --> 00:29:12,940
you can't use Val grind you can't use

00:29:10,269 --> 00:29:14,049
you know the various address sanitizers

00:29:12,940 --> 00:29:16,889
and blah blah blah all the stuff that

00:29:14,049 --> 00:29:23,739
built-in the clogging in GCC now either

00:29:16,889 --> 00:29:25,149
and so so that kind of demands like okay

00:29:23,739 --> 00:29:29,080
we need to bring that stuff into user

00:29:25,149 --> 00:29:32,379
land somehow how do we do that because

00:29:29,080 --> 00:29:35,289
anybody who has tried and probably a lot

00:29:32,379 --> 00:29:40,299
of people here know that if I tried to

00:29:35,289 --> 00:29:43,059
compile a kernel mode C file a Linux

00:29:40,299 --> 00:29:47,470
kernel C file in user land with a user

00:29:43,059 --> 00:29:49,210
land compiler that doesn't work the

00:29:47,470 --> 00:29:50,649
kernel has its own idea of certain

00:29:49,210 --> 00:29:55,720
symbols certain low-level functions etc

00:29:50,649 --> 00:30:00,190
etc so so they just conflict with the

00:29:55,720 --> 00:30:02,049
user LAN Lib C so we need to do a couple

00:30:00,190 --> 00:30:03,580
of things we need to undefined certain

00:30:02,049 --> 00:30:06,460
symbols that are in the kernel headers

00:30:03,580 --> 00:30:10,559
that conflict with Lib C whether that's

00:30:06,460 --> 00:30:10,559
new Lib G let see whatever you name it

00:30:12,929 --> 00:30:18,039
redefine certain things before we

00:30:15,489 --> 00:30:19,389
include those kernel headers so that

00:30:18,039 --> 00:30:22,539
they don't conflict or so that we can

00:30:19,389 --> 00:30:24,789
intercept them we need to supply some

00:30:22,539 --> 00:30:28,389
link time mocks for some kernel

00:30:24,789 --> 00:30:30,249
functions that are either that or

00:30:28,389 --> 00:30:32,080
they're either macros and we don't want

00:30:30,249 --> 00:30:41,879
to define the whole macro right in our

00:30:32,080 --> 00:30:44,470
you know compiler command line or just

00:30:41,879 --> 00:30:46,600
inline functions that aren't macros but

00:30:44,470 --> 00:30:51,759
they're inline functions inside of the

00:30:46,600 --> 00:30:53,259
kernel header is that thank you that we

00:30:51,759 --> 00:30:55,960
need to be able to intercept and things

00:30:53,259 --> 00:30:58,029
like that and in a few cases we have to

00:30:55,960 --> 00:31:01,119
supply a few alternate data structures

00:30:58,029 --> 00:31:03,369
and I don't didn't quite understand why

00:31:01,119 --> 00:31:04,659
actually but it's what we ended up

00:31:03,369 --> 00:31:07,479
having to do at a company if

00:31:04,659 --> 00:31:09,609
years ago to make this work we also need

00:31:07,479 --> 00:31:12,009
to use some of the kernel compile flags

00:31:09,609 --> 00:31:13,840
but not all of them and I've listed and

00:31:12,009 --> 00:31:15,849
listened in here you need data sections

00:31:13,840 --> 00:31:17,470
and function sections but you definitely

00:31:15,849 --> 00:31:19,840
need to not have the memory model be the

00:31:17,470 --> 00:31:24,340
kernel memory model that won't work

00:31:19,840 --> 00:31:27,249
super great in user land and I will say

00:31:24,340 --> 00:31:28,779
that this is kind of fragile which is

00:31:27,249 --> 00:31:31,960
maybe a minor understate understatement

00:31:28,779 --> 00:31:33,940
and you may have to tweak your approach

00:31:31,960 --> 00:31:35,940
with this every time you do a kernel

00:31:33,940 --> 00:31:38,859
upgrade that changes the headers in any

00:31:35,940 --> 00:31:40,359
reasonably significant way because

00:31:38,859 --> 00:31:42,129
you're really kind of breaking the

00:31:40,359 --> 00:31:43,179
encapsulate like you're really trying to

00:31:42,129 --> 00:31:45,519
get these kernel headers to do things

00:31:43,179 --> 00:31:46,599
that they aren't designed to do and I

00:31:45,519 --> 00:31:48,489
don't think it's a design problem

00:31:46,599 --> 00:31:50,049
capsulation problem necessarily on the

00:31:48,489 --> 00:31:51,519
Linux kernels part that's not I'm not

00:31:50,049 --> 00:31:55,179
trying to disparage the Linux kernel or

00:31:51,519 --> 00:31:57,460
any other kind of embedded operating

00:31:55,179 --> 00:31:59,470
system kernel header files or structure

00:31:57,460 --> 00:32:00,849
or anything like that I mean what you're

00:31:59,470 --> 00:32:02,470
really doing is you're really breaking

00:32:00,849 --> 00:32:04,629
the encapsulation layer is quite

00:32:02,470 --> 00:32:07,229
purposefully to try to get kernel code

00:32:04,629 --> 00:32:12,039
to run in a way it was not supposed to

00:32:07,229 --> 00:32:13,509
so what does that look like and I've put

00:32:12,039 --> 00:32:21,639
the more complete thing up at that

00:32:13,509 --> 00:32:23,979
github gist so surprisingly you do have

00:32:21,639 --> 00:32:25,570
to undef' false and true those

00:32:23,979 --> 00:32:27,489
definitions that are in the Linux kernel

00:32:25,570 --> 00:32:29,440
handle header files will conflict with

00:32:27,489 --> 00:32:31,450
what GCC wants to do with those things

00:32:29,440 --> 00:32:34,450
or clang or whatever what to do with

00:32:31,450 --> 00:32:39,940
those things undef always in line again

00:32:34,450 --> 00:32:42,519
conflict they're changing some of these

00:32:39,940 --> 00:32:45,460
functions like and some of these struts

00:32:42,519 --> 00:32:48,119
like FD set dev tea timer tea block

00:32:45,460 --> 00:32:50,049
count and all these kind of things we're

00:32:48,119 --> 00:32:53,710
changing the names of those things so we

00:32:50,049 --> 00:32:59,249
can supply an alternate implementation

00:32:53,710 --> 00:33:02,409
at link time an effing bool that's right

00:32:59,249 --> 00:33:05,200
it's a little mind-blowing to look at

00:33:02,409 --> 00:33:10,720
this sometimes and this is cutoff on

00:33:05,200 --> 00:33:12,279
mine oh no it's not yeah so various

00:33:10,720 --> 00:33:15,789
header files have little things that

00:33:12,279 --> 00:33:18,400
will conflict with G Lib C and miss gave

00:33:15,789 --> 00:33:23,140
a shout to Alexei who I worked with

00:33:18,400 --> 00:33:25,260
at a company a few years ago he you know

00:33:23,140 --> 00:33:27,429
the challenge was basically thrown down

00:33:25,260 --> 00:33:29,470
where it's like well why can't you just

00:33:27,429 --> 00:33:31,929
test Colonel stuff and userland and no

00:33:29,470 --> 00:33:33,850
one could articulate in detail why and

00:33:31,929 --> 00:33:35,860
he sat down for however many days and

00:33:33,850 --> 00:33:37,150
just figured out this header file is

00:33:35,860 --> 00:33:38,200
this conflict this fire file is this

00:33:37,150 --> 00:33:39,760
conflict this header file is this

00:33:38,200 --> 00:33:41,110
conflict it was super tedious but at the

00:33:39,760 --> 00:33:43,090
end he was able to do a presentation we

00:33:41,110 --> 00:33:44,710
was like we're now testing our kernel

00:33:43,090 --> 00:33:47,020
components in user Lane and it's saving

00:33:44,710 --> 00:33:48,730
us this much time for each test run

00:33:47,020 --> 00:33:50,940
because I won't have to do a bunch of

00:33:48,730 --> 00:33:55,600
stuff to get our tests into the kernel

00:33:50,940 --> 00:33:57,460
so shout out to him so one thing to note

00:33:55,600 --> 00:33:59,710
is that we use the preprocessor that's

00:33:57,460 --> 00:34:05,980
pre printed out we use the preprocessor

00:33:59,710 --> 00:34:08,080
there to introduce mocks and that's you

00:34:05,980 --> 00:34:09,970
got to do what you got to do anybody

00:34:08,080 --> 00:34:11,770
who'd watch saw the talk last year I

00:34:09,970 --> 00:34:14,440
said that a lot you got to do what you

00:34:11,770 --> 00:34:16,480
got to do but preprocessor mocks are not

00:34:14,440 --> 00:34:18,010
ideal right and those are also mentioned

00:34:16,480 --> 00:34:19,720
in the Michael feathers book working

00:34:18,010 --> 00:34:21,940
effectively working effectively with

00:34:19,720 --> 00:34:25,000
legacy code and the reason why is

00:34:21,940 --> 00:34:28,300
because if in my implementation file I

00:34:25,000 --> 00:34:31,629
have to if I have an if death test then

00:34:28,300 --> 00:34:33,909
do something else it's no big deal to be

00:34:31,629 --> 00:34:36,429
like okay well I'll just you know when

00:34:33,909 --> 00:34:38,830
I'm compiling that implementation module

00:34:36,429 --> 00:34:40,540
for unit testing purposes I had the dash

00:34:38,830 --> 00:34:42,520
D test and that's easy in the bill and

00:34:40,540 --> 00:34:44,530
it's easing whatever who cares well the

00:34:42,520 --> 00:34:46,750
problem with that is is that you now

00:34:44,530 --> 00:34:49,359
can't you're now compiling the same code

00:34:46,750 --> 00:34:51,190
twice once for your implementation link

00:34:49,359 --> 00:34:52,780
once for your implementation that you're

00:34:51,190 --> 00:34:56,139
gonna link it into your final shipping

00:34:52,780 --> 00:34:58,890
thing and once for your test and for one

00:34:56,139 --> 00:35:02,140
object file that's small who cares but

00:34:58,890 --> 00:35:05,560
when you go to when you're when you set

00:35:02,140 --> 00:35:07,150
that precedent two things happen one is

00:35:05,560 --> 00:35:08,710
one of which is that you get these

00:35:07,150 --> 00:35:10,119
weird-ass if that's all throughout a

00:35:08,710 --> 00:35:13,060
source file they just clutter up the

00:35:10,119 --> 00:35:15,580
whole file I don't like that that's bad

00:35:13,060 --> 00:35:18,310
news and impairs readability etc etc but

00:35:15,580 --> 00:35:20,800
the other problem the more kind of

00:35:18,310 --> 00:35:22,480
operational problem is that if you're

00:35:20,800 --> 00:35:23,770
doing that often enough and enough of

00:35:22,480 --> 00:35:26,530
your source files you are building

00:35:23,770 --> 00:35:29,290
everything twice and if you do this

00:35:26,530 --> 00:35:31,630
properly and I'll just be judgmental

00:35:29,290 --> 00:35:32,260
properly if you do if you do things

00:35:31,630 --> 00:35:34,690
properly

00:35:32,260 --> 00:35:35,830
use natural modularity seams at link

00:35:34,690 --> 00:35:38,290
time where I can do link time

00:35:35,830 --> 00:35:39,850
substitution or at runtime where I have

00:35:38,290 --> 00:35:41,170
a pure virtual class or a function

00:35:39,850 --> 00:35:44,740
pointer and I can do substitution that

00:35:41,170 --> 00:35:46,840
way when you use those seams instead you

00:35:44,740 --> 00:35:49,090
compile your implementation module once

00:35:46,840 --> 00:35:50,950
and use that implementation module to

00:35:49,090 --> 00:35:53,560
link into your shipping code I love that

00:35:50,950 --> 00:35:54,910
you're nodding your head by the way you

00:35:53,560 --> 00:35:56,590
can use that same object files link into

00:35:54,910 --> 00:35:57,970
your shipping code and link into your

00:35:56,590 --> 00:36:00,790
unit test harness and I compiled at once

00:35:57,970 --> 00:36:02,800
right that's one thing and whether if

00:36:00,790 --> 00:36:04,390
you even if I'm using CC cache or just

00:36:02,800 --> 00:36:07,390
CC and I just have to speed that stuff

00:36:04,390 --> 00:36:08,890
up and you know this is just one of

00:36:07,390 --> 00:36:10,030
those death by a thousand cuts things

00:36:08,890 --> 00:36:14,260
that's important to get right the first

00:36:10,030 --> 00:36:16,330
time but also preprocessor mocks are

00:36:14,260 --> 00:36:17,890
often used when you're kind of hacking

00:36:16,330 --> 00:36:20,830
around some terrible design problem and

00:36:17,890 --> 00:36:22,180
in a legacy system where it's like well

00:36:20,830 --> 00:36:24,430
we don't have any tests and we're free

00:36:22,180 --> 00:36:26,020
to change anything so we don't want to

00:36:24,430 --> 00:36:29,260
make any design changes to introduce

00:36:26,020 --> 00:36:32,170
link time seams or runtime seams you can

00:36:29,260 --> 00:36:34,150
fall back on preprocessor seems as a way

00:36:32,170 --> 00:36:36,010
to get some tests in place so that you

00:36:34,150 --> 00:36:39,900
can refactor it to get you know better

00:36:36,010 --> 00:36:42,850
more modular scenes in place that's cool

00:36:39,900 --> 00:36:45,310
but it's not like oh yeah we have it

00:36:42,850 --> 00:36:48,369
some preprocessor seems there's - D you

00:36:45,310 --> 00:36:49,240
know test blah blah blah or I renamed a

00:36:48,369 --> 00:36:52,780
whole bunch of functions at the

00:36:49,240 --> 00:36:54,640
preprocessor level and now I'm going to

00:36:52,780 --> 00:36:55,960
enter a bug to go fix it later and I'm

00:36:54,640 --> 00:36:58,210
not going to see it for six years

00:36:55,960 --> 00:36:59,350
don't do that because those first tests

00:36:58,210 --> 00:37:01,270
you're right and the way that you do

00:36:59,350 --> 00:37:02,650
that is going to set the precedent for

00:37:01,270 --> 00:37:02,980
how people are going to do it in the

00:37:02,650 --> 00:37:05,020
future

00:37:02,980 --> 00:37:06,580
and if the test is successful and finds

00:37:05,020 --> 00:37:08,530
a bug or prevents a bug or whatever and

00:37:06,580 --> 00:37:09,700
people go like I'm gonna copy that test

00:37:08,530 --> 00:37:16,150
because that's the test that found the

00:37:09,700 --> 00:37:19,600
bug if you do a suboptimal job or don't

00:37:16,150 --> 00:37:21,460
I don't say that I'm basically if you

00:37:19,600 --> 00:37:23,350
don't do things right initially you'll

00:37:21,460 --> 00:37:24,910
find that the success unit testing will

00:37:23,350 --> 00:37:27,040
fall down pretty quickly because as it

00:37:24,910 --> 00:37:28,840
goes out to scale all across a dozen

00:37:27,040 --> 00:37:30,430
engineers or a dozen teams or whatever

00:37:28,840 --> 00:37:32,080
everybody starts to do the same crappy

00:37:30,430 --> 00:37:34,060
stuff that death by a thousand cuts

00:37:32,080 --> 00:37:36,550
builds up people go this would know this

00:37:34,060 --> 00:37:42,570
would never work and they think its

00:37:36,550 --> 00:37:45,410
intrinsic to unit testing so let's see

00:37:42,570 --> 00:37:47,570
in this particular case

00:37:45,410 --> 00:37:48,920
we have to use preprocessor seems

00:37:47,570 --> 00:37:50,480
they're just no getting around it

00:37:48,920 --> 00:37:52,880
because we can't read that we use those

00:37:50,480 --> 00:37:54,860
object files between the user land

00:37:52,880 --> 00:37:56,840
object file we compiled in the kernel

00:37:54,860 --> 00:38:01,880
mode object file anyway we have to

00:37:56,840 --> 00:38:04,550
compile it twice anyway so so that's why

00:38:01,880 --> 00:38:06,800
it's a little it's it's more okay and I

00:38:04,550 --> 00:38:08,540
don't know of another way to solve it so

00:38:06,800 --> 00:38:13,310
what I would say is avoid preprocessor

00:38:08,540 --> 00:38:14,960
seams in most scenarios favor link and

00:38:13,310 --> 00:38:17,000
runtime mocking but you got to do what

00:38:14,960 --> 00:38:18,440
you got to do realize that we need to

00:38:17,000 --> 00:38:21,410
use a preprocessor when you use a

00:38:18,440 --> 00:38:27,710
preprocessor seemed to mock stuff and it

00:38:21,410 --> 00:38:30,860
has this cost associated with it so next

00:38:27,710 --> 00:38:34,340
thing is so mocking standard Lib so in

00:38:30,860 --> 00:38:37,690
my experience typically when we when you

00:38:34,340 --> 00:38:40,100
want to do this it's not to mock malloc

00:38:37,690 --> 00:38:42,350
necessarily that's that's a common

00:38:40,100 --> 00:38:48,710
gotcha question people ask me like heavy

00:38:42,350 --> 00:38:50,450
a buck malloc smart guy and huh well

00:38:48,710 --> 00:38:55,130
there's ways to do I mean I have an

00:38:50,450 --> 00:38:56,540
answer I you can and so in in my

00:38:55,130 --> 00:38:57,890
experience the real world scenario is

00:38:56,540 --> 00:38:59,780
where you do this typically with IO

00:38:57,890 --> 00:39:02,270
calls like low-level I like AI calls

00:38:59,780 --> 00:39:04,580
like receive F open F close whatever I

00:39:02,270 --> 00:39:06,140
wanted a I want to avoid any IO in my

00:39:04,580 --> 00:39:10,580
test because any IO is gonna slow

00:39:06,140 --> 00:39:15,470
everything way down but also I want to

00:39:10,580 --> 00:39:19,010
be able to I want to be able to

00:39:15,470 --> 00:39:21,350
basically mock or simulate error

00:39:19,010 --> 00:39:23,870
conditions with those IO calls right

00:39:21,350 --> 00:39:25,220
where F open doesn't succeed or whatever

00:39:23,870 --> 00:39:27,370
but I don't want it to go actually touch

00:39:25,220 --> 00:39:30,770
the real filesystem because if I've got

00:39:27,370 --> 00:39:31,520
if I've got tests screwing around with a

00:39:30,770 --> 00:39:33,680
filesystem

00:39:31,520 --> 00:39:37,520
that's effectively global mutable state

00:39:33,680 --> 00:39:40,040
and that's bad news for having tests

00:39:37,520 --> 00:39:45,050
that are run that run consistently and

00:39:40,040 --> 00:39:47,300
all that kind of stuff so so machii-san

00:39:45,050 --> 00:39:48,470
your lips so preprocessor injection that

00:39:47,300 --> 00:39:52,640
thing that I just said we should try to

00:39:48,470 --> 00:39:55,190
avoid it's like well you could you could

00:39:52,640 --> 00:39:57,200
and maybe if you're using a compiler

00:39:55,190 --> 00:39:59,660
that doesn't have the switch I'm about

00:39:57,200 --> 00:40:01,880
to talk about excuse me maybe that's

00:39:59,660 --> 00:40:06,350
what you end up doing and there are

00:40:01,880 --> 00:40:08,210
worse fates to be sure so what I would

00:40:06,350 --> 00:40:10,220
say is favor isolating the system level

00:40:08,210 --> 00:40:12,410
interactions and encapsulate those

00:40:10,220 --> 00:40:13,790
platform specifics into its own module

00:40:12,410 --> 00:40:15,290
and anybody who works on a large enough

00:40:13,790 --> 00:40:16,370
codebase has to run on enough machines

00:40:15,290 --> 00:40:17,840
and I know the ton of video game

00:40:16,370 --> 00:40:20,950
developers here and everybody has their

00:40:17,840 --> 00:40:23,420
own cross-platform kind of like

00:40:20,950 --> 00:40:28,070
encapsulation layer or and stuff like

00:40:23,420 --> 00:40:29,780
that for every majors studio anyway so

00:40:28,070 --> 00:40:31,850
most people do this already but if you

00:40:29,780 --> 00:40:33,290
get all those low-level kind of platform

00:40:31,850 --> 00:40:37,220
specific interactions in this case

00:40:33,290 --> 00:40:40,550
platform specific being POSIX ECE kind

00:40:37,220 --> 00:40:42,800
of stuff into its own module then we can

00:40:40,550 --> 00:40:45,080
take that one module that's the only

00:40:42,800 --> 00:40:48,310
module that calls receive directly or

00:40:45,080 --> 00:40:53,150
that calls F open directly or that calls

00:40:48,310 --> 00:40:54,980
the F Locker lock F I programmed in

00:40:53,150 --> 00:40:57,830
hp-ux 9 a long time ago and it wasn't

00:40:54,980 --> 00:40:59,210
POSIX compliant and so it was flipped

00:40:57,830 --> 00:41:02,690
one way now I can never remember which

00:40:59,210 --> 00:41:04,850
way it is in actual POSIX but anyway all

00:41:02,690 --> 00:41:08,840
those low-level calls are then in that

00:41:04,850 --> 00:41:10,580
one module so we're gonna put those

00:41:08,840 --> 00:41:12,230
tests into their own binary and once

00:41:10,580 --> 00:41:14,540
they're in their own binary we can

00:41:12,230 --> 00:41:18,380
compile those tests with a flag - no

00:41:14,540 --> 00:41:20,570
standard Lib so when you use GCC or

00:41:18,380 --> 00:41:22,040
clang and you don't specify it to link

00:41:20,570 --> 00:41:24,260
against anything it's actually

00:41:22,040 --> 00:41:27,080
implicitly linking against a set of

00:41:24,260 --> 00:41:29,360
stuff that you're probably gonna use Lib

00:41:27,080 --> 00:41:31,310
C being one of them some math stuff

00:41:29,360 --> 00:41:32,900
being enough being another one and and

00:41:31,310 --> 00:41:35,150
the networking libraries and stuff like

00:41:32,900 --> 00:41:36,830
that so when you specify - no standard

00:41:35,150 --> 00:41:40,370
live you're saying don't do anything for

00:41:36,830 --> 00:41:43,520
me and that means that you may need to

00:41:40,370 --> 00:41:46,940
not May you will need to bring in

00:41:43,520 --> 00:41:48,410
individual things that you need and I'm

00:41:46,940 --> 00:41:48,920
gonna show an example of this in a

00:41:48,410 --> 00:41:52,280
second

00:41:48,920 --> 00:41:55,310
and for some compilers you may also need

00:41:52,280 --> 00:41:59,510
to disable intrinsics if if you have a

00:41:55,310 --> 00:42:02,420
weird custom tool chain for a weird

00:41:59,510 --> 00:42:04,490
custom embedded thing and they didn't

00:42:02,420 --> 00:42:06,740
want to make in lines in a header file

00:42:04,490 --> 00:42:08,839
and so they made intrinsic that do i/o

00:42:06,740 --> 00:42:11,329
stuff and not just math e stuff

00:42:08,839 --> 00:42:15,859
you may need to disable intrinsics I saw

00:42:11,329 --> 00:42:17,660
it happen one time so here's our

00:42:15,859 --> 00:42:20,239
implementation and here's the test that

00:42:17,660 --> 00:42:23,900
we want to write so on the Left we have

00:42:20,239 --> 00:42:27,710
a socket stream class it has a method on

00:42:23,900 --> 00:42:29,390
it called listen that calls receive on

00:42:27,710 --> 00:42:31,640
the right hand side we have our test a

00:42:29,390 --> 00:42:32,299
see green test we describe Saka stream

00:42:31,640 --> 00:42:34,190
blah blah blah

00:42:32,299 --> 00:42:36,410
we want to ensure socket stream calls

00:42:34,190 --> 00:42:40,849
the platform receive when listening a

00:42:36,410 --> 00:42:43,460
very basic test to be to be sure so I

00:42:40,849 --> 00:42:46,640
make my socket stream and I say expect

00:42:43,460 --> 00:42:47,839
receive when socket is non null I just

00:42:46,640 --> 00:42:49,009
cared that it's called with a non null

00:42:47,839 --> 00:42:52,160
socket I could do some more checking

00:42:49,009 --> 00:42:53,450
there potentially and then I call socket

00:42:52,160 --> 00:42:56,660
stream not listen and just to reiterate

00:42:53,450 --> 00:42:58,969
one more time if it gets to the end of

00:42:56,660 --> 00:43:00,319
that test and receive isn't called

00:42:58,969 --> 00:43:01,700
I set the expectation it would be called

00:43:00,319 --> 00:43:02,989
if it's not called the test will fail

00:43:01,700 --> 00:43:04,670
and I'll say hey this thing that you

00:43:02,989 --> 00:43:09,019
said you said an expectation for wasn't

00:43:04,670 --> 00:43:11,450
called so what does our receive mock

00:43:09,019 --> 00:43:14,239
look like right so this is what our

00:43:11,450 --> 00:43:15,710
receive mock looks like we include sis

00:43:14,239 --> 00:43:18,469
socket H we're still using the same

00:43:15,710 --> 00:43:20,749
header file under the presumption that

00:43:18,469 --> 00:43:23,210
the implementation for receive is an

00:43:20,749 --> 00:43:26,289
inline in the header file which it's not

00:43:23,210 --> 00:43:28,430
on the platforms that I have worked on I

00:43:26,289 --> 00:43:31,930
include the Seagram ox I uses the

00:43:28,430 --> 00:43:33,920
namespace C green and I have my own

00:43:31,930 --> 00:43:36,049
implementation of receive here that

00:43:33,920 --> 00:43:37,309
calls the C green mock macro and passes

00:43:36,049 --> 00:43:41,989
in all the arguments and does all that

00:43:37,309 --> 00:43:45,890
jazz so then I'm going to is a big one

00:43:41,989 --> 00:43:48,799
so you know how this reads up there so

00:43:45,890 --> 00:43:51,460
then i say g + + - no standard lib i

00:43:48,799 --> 00:43:54,979
give it the include path to the C green

00:43:51,460 --> 00:43:58,099
C green includes I'm compiling receive

00:43:54,979 --> 00:44:00,920
mock I'm compiling my socket test

00:43:58,099 --> 00:44:03,349
I'm statically linking against Lib C

00:44:00,920 --> 00:44:05,089
green a I'm compiling a shared library

00:44:03,349 --> 00:44:07,339
because that's how I do my test and see

00:44:05,089 --> 00:44:11,809
green and I'm gonna output that a socket

00:44:07,339 --> 00:44:14,299
test s oh and then we get just ton

00:44:11,809 --> 00:44:16,489
of linker errors as far as the eye can

00:44:14,299 --> 00:44:20,029
see and oh my god put the gun in my

00:44:16,489 --> 00:44:21,559
mouth now what am I going to do forget

00:44:20,029 --> 00:44:22,309
testing you forget C green I hate the

00:44:21,559 --> 00:44:26,449
universe

00:44:22,309 --> 00:44:27,349
thank you so here's and I think I said

00:44:26,449 --> 00:44:28,549
this last year too

00:44:27,349 --> 00:44:29,719
when you're especially when you're

00:44:28,549 --> 00:44:31,099
working with legacy code you're like

00:44:29,719 --> 00:44:32,410
getting like you're kind of leaning on

00:44:31,099 --> 00:44:34,640
the tool trained leaning on the compiler

00:44:32,410 --> 00:44:37,039
sometimes you will see just a

00:44:34,640 --> 00:44:39,349
preprocessor or the linker just like

00:44:37,039 --> 00:44:41,269
just vomit all over your face and you're

00:44:39,349 --> 00:44:45,229
just like oh my god how long is it gonna

00:44:41,269 --> 00:44:47,089
take me to fix this and the you know

00:44:45,229 --> 00:44:49,849
Hitchhiker's Guide don't panic

00:44:47,089 --> 00:44:51,259
right sometimes like it's the same

00:44:49,849 --> 00:44:52,849
complaints over and over and over and

00:44:51,259 --> 00:44:54,019
over and over again right so yes if they

00:44:52,849 --> 00:44:55,459
implement three mocks and the whole

00:44:54,019 --> 00:44:56,449
thing goes away or you have to do one

00:44:55,459 --> 00:45:00,819
little thing and the whole thing goes

00:44:56,449 --> 00:45:04,130
away so in this case I had to add - LC

00:45:00,819 --> 00:45:07,819
there was a bunch of things that see

00:45:04,130 --> 00:45:10,219
green uses file stuff console i/o stuff

00:45:07,819 --> 00:45:13,549
that I said no standard Lib I told it

00:45:10,219 --> 00:45:15,619
don't help me and it didn't right so I

00:45:13,549 --> 00:45:17,180
just added - LC to bring the low-level

00:45:15,619 --> 00:45:19,609
Lib C functions which still includes

00:45:17,180 --> 00:45:21,589
just which still excludes the networking

00:45:19,609 --> 00:45:24,289
functions I'd have that I would have to

00:45:21,589 --> 00:45:26,299
add - L net so still gonna call my mock

00:45:24,289 --> 00:45:28,489
receive my mock receive at link time is

00:45:26,299 --> 00:45:31,910
the only receive symbol in town right

00:45:28,489 --> 00:45:35,390
I'm sorry

00:45:31,910 --> 00:45:37,339
so one other cool thing here is that

00:45:35,390 --> 00:45:39,499
because we did it this way instead of

00:45:37,339 --> 00:45:42,589
with the preprocessor like - D receive

00:45:39,499 --> 00:45:44,239
equals receive mock or whatever we are

00:45:42,589 --> 00:45:45,799
we using the same socket stream object

00:45:44,239 --> 00:45:48,019
file like I just talked about which is

00:45:45,799 --> 00:45:49,519
like what we like to do it proves the

00:45:48,019 --> 00:45:51,739
modularity of our design as well as

00:45:49,519 --> 00:45:53,689
helps keep our build times low and I'm

00:45:51,739 --> 00:45:55,099
saying modularity rules when you see

00:45:53,689 --> 00:45:56,839
this stuff like work in a real codebase

00:45:55,099 --> 00:45:58,279
that's it's like one of the things that

00:45:56,839 --> 00:45:59,539
still gets me excited about programming

00:45:58,279 --> 00:46:00,890
we can just like plug different stuff

00:45:59,539 --> 00:46:07,749
together and all just works because the

00:46:00,890 --> 00:46:11,329
interfaces are nice it's ace so the next

00:46:07,749 --> 00:46:15,619
thorny issue thorny issue and I touched

00:46:11,329 --> 00:46:16,729
on Singleton's last year but some people

00:46:15,619 --> 00:46:18,199
are like well what about this scenario

00:46:16,729 --> 00:46:19,549
and I realized oh yeah that's a common

00:46:18,199 --> 00:46:25,729
scenario and it's just one I didn't

00:46:19,549 --> 00:46:27,799
mention last year so what some people do

00:46:25,729 --> 00:46:30,499
with Singleton's is that they think the

00:46:27,799 --> 00:46:32,329
point of the singleton design pattern

00:46:30,499 --> 00:46:34,650
where you like design patterns you hit

00:46:32,329 --> 00:46:37,200
the gang of four or whatever

00:46:34,650 --> 00:46:39,660
um they think it's an excuse to have a

00:46:37,200 --> 00:46:40,980
globally accessible symbol where they

00:46:39,660 --> 00:46:42,870
just have to pan include one header

00:46:40,980 --> 00:46:44,310
filed and access this one instance all

00:46:42,870 --> 00:46:45,300
of place right but it's really what's

00:46:44,310 --> 00:46:47,340
risk was to do Stu guarding it's

00:46:45,300 --> 00:46:49,950
creating more than one instance of

00:46:47,340 --> 00:46:53,040
whatever that thing is it's not to get

00:46:49,950 --> 00:46:56,720
global access to it from anywhere all

00:46:53,040 --> 00:46:59,370
the time so for non-trivial Singleton's

00:46:56,720 --> 00:47:01,350
that you collaborate with and what I

00:46:59,370 --> 00:47:02,880
talked about last year is that instead

00:47:01,350 --> 00:47:07,680
of just referring to the global symbol

00:47:02,880 --> 00:47:10,680
of I don't know statistics : : instance

00:47:07,680 --> 00:47:12,510
increment or you know arrow increment or

00:47:10,680 --> 00:47:14,930
whatever you're doing instead of just

00:47:12,510 --> 00:47:19,080
referring to that everywhere you

00:47:14,930 --> 00:47:20,550
parameterize to test statistics into the

00:47:19,080 --> 00:47:23,010
constructor of the class it's being used

00:47:20,550 --> 00:47:24,590
in so that your interface advertises its

00:47:23,010 --> 00:47:35,130
collaborators as much as possible

00:47:24,590 --> 00:47:37,260
generally good practice and extract a

00:47:35,130 --> 00:47:39,030
pure virtual based class for that

00:47:37,260 --> 00:47:40,880
whatever that's single whatever that

00:47:39,030 --> 00:47:43,200
singleton class is like statistics

00:47:40,880 --> 00:47:45,840
change the parameter of Erised version

00:47:43,200 --> 00:47:47,580
to the abstract the paper virtual now

00:47:45,840 --> 00:47:49,410
pure virtual base class and then guess

00:47:47,580 --> 00:47:53,820
what I can mock that pure virtual base

00:47:49,410 --> 00:47:55,860
class I can inject it whatever but what

00:47:53,820 --> 00:47:58,380
if you have Singleton's that are just

00:47:55,860 --> 00:48:00,090
universally accessed everywhere and the

00:47:58,380 --> 00:48:04,560
canonical example this is a logging

00:48:00,090 --> 00:48:06,540
system right so if it is universally

00:48:04,560 --> 00:48:10,020
accessed you know you don't want to go

00:48:06,540 --> 00:48:12,660
adding like you know abstract logger

00:48:10,020 --> 00:48:14,760
star to every single constructor in

00:48:12,660 --> 00:48:17,100
every single class that's nonsensical

00:48:14,760 --> 00:48:20,700
and it's dogmatix I mean seem at times

00:48:17,100 --> 00:48:22,410
I'm ultimately pragmatic but I have had

00:48:20,700 --> 00:48:23,820
to argue with people to be like no we're

00:48:22,410 --> 00:48:26,670
not going to add that to every

00:48:23,820 --> 00:48:28,620
constructor that's silly

00:48:26,670 --> 00:48:31,140
so if it's university access we can

00:48:28,620 --> 00:48:33,330
still do linked I'm mocking and that's

00:48:31,140 --> 00:48:34,860
still modular it's not runtime

00:48:33,330 --> 00:48:36,770
substitutability which is the awesome

00:48:34,860 --> 00:48:41,640
thing about C++ and objects and stuff

00:48:36,770 --> 00:48:43,080
but it still proves the modularity at

00:48:41,640 --> 00:48:45,060
link time link time substitute

00:48:43,080 --> 00:48:47,720
substitutability is still modularity and

00:48:45,060 --> 00:48:47,720
so that's still cool

00:48:47,970 --> 00:48:52,800
so the way to do this is that we have a

00:48:49,740 --> 00:48:54,870
link time Mach that wraps in Fords to

00:48:52,800 --> 00:48:58,320
mockito PP so that we can still use

00:48:54,870 --> 00:48:59,850
mockito PP or G test or RG Mach or

00:48:58,320 --> 00:49:02,940
whatever things you said we can still

00:48:59,850 --> 00:49:05,610
use those expectations in that syntax so

00:49:02,940 --> 00:49:07,500
the common implement the common header

00:49:05,610 --> 00:49:10,080
that we have here for this basic logger

00:49:07,500 --> 00:49:12,480
it's an it is it's a singleton with an

00:49:10,080 --> 00:49:15,390
instance and a static and it has two

00:49:12,480 --> 00:49:16,770
methods Boyd and fatal and notice that

00:49:15,390 --> 00:49:18,360
those aren't pure virtual by the way so

00:49:16,770 --> 00:49:21,270
that you could also use this if you're

00:49:18,360 --> 00:49:23,280
like I can't make a pure virtual base

00:49:21,270 --> 00:49:24,870
class for that singleton or for that

00:49:23,280 --> 00:49:26,850
whatever I'm gonna do link time

00:49:24,870 --> 00:49:27,930
substitution even though thank you even

00:49:26,850 --> 00:49:30,090
the runtime substitution but

00:49:27,930 --> 00:49:31,590
hypothetically bb-better and then on the

00:49:30,090 --> 00:49:34,440
right hand side we've just got a dumb

00:49:31,590 --> 00:49:39,150
implement dumb stub implement our knoll

00:49:34,440 --> 00:49:41,850
implementation of a logger there so

00:49:39,150 --> 00:49:44,190
here's where we have a link time mock

00:49:41,850 --> 00:49:47,550
that wraps mockito PP right so we

00:49:44,190 --> 00:49:49,410
include logger h PP that interface or

00:49:47,550 --> 00:49:53,640
that that header file which is not pure

00:49:49,410 --> 00:49:55,650
virtual at all and we pen include the

00:49:53,640 --> 00:50:00,330
makita PP mock object thing we use a

00:49:55,650 --> 00:50:03,600
namespace etc so for mockito PP to work

00:50:00,330 --> 00:50:05,520
it needs a pure virtual class but we

00:50:03,600 --> 00:50:07,230
don't want to mess with the actual

00:50:05,520 --> 00:50:09,780
logger implementation for some reason

00:50:07,230 --> 00:50:12,690
let's say which is perfectly fine so I

00:50:09,780 --> 00:50:14,790
have to make a parallel interface that

00:50:12,690 --> 00:50:16,860
the actual logger the real logger

00:50:14,790 --> 00:50:20,040
doesn't inherit from and that feels

00:50:16,860 --> 00:50:21,390
weird because it is weird but if you can

00:50:20,040 --> 00:50:24,270
inherit you can't change it or whatever

00:50:21,390 --> 00:50:25,920
you can still do this you just have a

00:50:24,270 --> 00:50:29,160
little bit more duplication a little bit

00:50:25,920 --> 00:50:31,920
more maintenance overhead so I make a

00:50:29,160 --> 00:50:34,440
mock objects logger I make a mock

00:50:31,920 --> 00:50:39,570
objects for that logger interface ID I

00:50:34,440 --> 00:50:42,090
just made and so here I am the next

00:50:39,570 --> 00:50:44,240
thing is I have a logger instance which

00:50:42,090 --> 00:50:47,160
is going to satisfy that header files

00:50:44,240 --> 00:50:48,660
declaration right that I have a static

00:50:47,160 --> 00:50:56,070
instance method that returns a constant

00:50:48,660 --> 00:51:00,780
logger star and what I'm then going to

00:50:56,070 --> 00:51:01,680
do is the the implementation methods

00:51:00,780 --> 00:51:03,690
like info

00:51:01,680 --> 00:51:05,279
and I didn't implement fatal here but it

00:51:03,690 --> 00:51:07,680
would do the same thing what those end

00:51:05,279 --> 00:51:11,010
up doing is that they're calling in they

00:51:07,680 --> 00:51:12,960
just forward into the machi OPP mock

00:51:11,010 --> 00:51:15,089
object for that interface where that

00:51:12,960 --> 00:51:18,089
interface happens to have the same

00:51:15,089 --> 00:51:21,809
methods and type signature as the longer

00:51:18,089 --> 00:51:23,220
class which I had a laser pointer or

00:51:21,809 --> 00:51:32,579
that there's a smaller room it's a good

00:51:23,220 --> 00:51:35,789
point did I like it I can't see it oh I

00:51:32,579 --> 00:51:38,339
okay now I see it yeah yeah sorry yeah

00:51:35,789 --> 00:51:39,200
so this line here is what I'm talking

00:51:38,339 --> 00:51:41,910
about

00:51:39,200 --> 00:51:43,799
note to Microsoft people who are here

00:51:41,910 --> 00:51:44,730
the office thing where it shows the the

00:51:43,799 --> 00:51:46,440
PowerPoint thing where it shows the

00:51:44,730 --> 00:51:48,150
slides over here is full screen in my

00:51:46,440 --> 00:51:49,770
notes here that's really cool but I'd

00:51:48,150 --> 00:51:52,559
love to see the mouse cursor as the

00:51:49,770 --> 00:51:55,200
audience sees it file a bug or a ticket

00:51:52,559 --> 00:51:56,430
or whatever at the oh I know the office

00:51:55,200 --> 00:52:02,039
team is here somewhere they're here last

00:51:56,430 --> 00:52:05,250
year so a polite feature request so so

00:52:02,039 --> 00:52:07,289
yeah so I'm satisfying the link time

00:52:05,250 --> 00:52:09,299
requirement that that logger header file

00:52:07,289 --> 00:52:12,750
setup which is that there is there's an

00:52:09,299 --> 00:52:15,779
instance method called info and I'm just

00:52:12,750 --> 00:52:20,279
forwarding it on to a static instance of

00:52:15,779 --> 00:52:22,079
a mock eat OPP mock object and then the

00:52:20,279 --> 00:52:24,720
next example the next topic I have I'm

00:52:22,079 --> 00:52:28,559
going to show you how I've been program

00:52:24,720 --> 00:52:29,940
that so mocking factories factories our

00:52:28,559 --> 00:52:32,220
life Singleton's right there kind of

00:52:29,940 --> 00:52:35,309
creation pattern creation object

00:52:32,220 --> 00:52:39,839
creation pattern II would be wobbly

00:52:35,309 --> 00:52:41,849
timey wimey type things so what some

00:52:39,839 --> 00:52:44,010
people will get into is they're like

00:52:41,849 --> 00:52:45,809
okay I'm gonna mock my factory

00:52:44,010 --> 00:52:48,150
but then that factory has to return

00:52:45,809 --> 00:52:49,260
mocks and then those objects that the

00:52:48,150 --> 00:52:51,480
mock factor returns

00:52:49,260 --> 00:52:54,210
also have to return mocks does it ever

00:52:51,480 --> 00:52:56,039
end is it Turtles all the way down mock

00:52:54,210 --> 00:53:03,150
Turtles all the way down I'm here all

00:52:56,039 --> 00:53:06,599
night so maybe maybe you have to mock

00:53:03,150 --> 00:53:10,770
that whole chain when doing deep testing

00:53:06,599 --> 00:53:14,369
of error handling maybe but at the same

00:53:10,770 --> 00:53:14,970
time if you have to like in your tests

00:53:14,369 --> 00:53:17,610
you

00:53:14,970 --> 00:53:20,190
you have to know what that whole chain

00:53:17,610 --> 00:53:22,920
of collaborators is and exactly like

00:53:20,190 --> 00:53:24,300
this returns this and that returns that

00:53:22,920 --> 00:53:26,730
and that returns that this is a

00:53:24,300 --> 00:53:27,420
violation of the law of Demeter and so

00:53:26,730 --> 00:53:32,910
or Demeter

00:53:27,420 --> 00:53:35,520
meter thank you and so some people are

00:53:32,910 --> 00:53:38,640
have opinions about this where they go

00:53:35,520 --> 00:53:40,050
law of Demeter is just dot counting or

00:53:38,640 --> 00:53:41,610
arrow counting and it's complete

00:53:40,050 --> 00:53:44,850
 and who cares but here's the

00:53:41,610 --> 00:53:47,070
thing is that when I have in my tests or

00:53:44,850 --> 00:53:50,220
in other parts of my code you know a

00:53:47,070 --> 00:53:53,340
arrow B arrow C arrow D arrow whatever

00:53:50,220 --> 00:53:56,070
if I go to change that structure in any

00:53:53,340 --> 00:53:57,630
way if I insert some new relationship

00:53:56,070 --> 00:53:59,850
into the middle that I don't have to go

00:53:57,630 --> 00:54:01,710
through my whole code base and change

00:53:59,850 --> 00:54:03,660
all those it breaks encapsulation is

00:54:01,710 --> 00:54:05,580
what it comes down to right and breaking

00:54:03,660 --> 00:54:07,530
an encapsulation is a nice way to say

00:54:05,580 --> 00:54:11,900
makes more work for you later that you

00:54:07,530 --> 00:54:15,150
will hate yourself for so so even though

00:54:11,900 --> 00:54:16,620
you can mock factories thank you and you

00:54:15,150 --> 00:54:19,050
can return mocks from those from those

00:54:16,620 --> 00:54:21,090
factories maybe you don't want to be

00:54:19,050 --> 00:54:23,490
returning mocks from those if you get to

00:54:21,090 --> 00:54:25,200
that point you probably have some minded

00:54:23,490 --> 00:54:26,820
design issue where you need to have an

00:54:25,200 --> 00:54:28,530
adapter source of some kind of some kind

00:54:26,820 --> 00:54:34,290
of wrapping clasp which is the thing

00:54:28,530 --> 00:54:35,820
that you ultimately mock so poor

00:54:34,290 --> 00:54:37,200
encapsulation is harder to test if

00:54:35,820 --> 00:54:40,650
you're testing and it seems hard or

00:54:37,200 --> 00:54:44,400
verbose probably some design issue not

00:54:40,650 --> 00:54:49,320
always probably probably and harder here

00:54:44,400 --> 00:54:52,350
means a long list of verbose mocks so I

00:54:49,320 --> 00:54:53,610
don't think that this is a bad example I

00:54:52,350 --> 00:54:55,290
think that this is a practical

00:54:53,610 --> 00:54:57,930
real-world example but I think if you

00:54:55,290 --> 00:54:59,640
want one level beyond this I would

00:54:57,930 --> 00:55:00,090
rethink really hard about what you were

00:54:59,640 --> 00:55:02,700
doing

00:55:00,090 --> 00:55:06,000
so this is another sea-green type test

00:55:02,700 --> 00:55:11,220
using a Makita PP so I have a proxy

00:55:06,000 --> 00:55:12,540
object and it takes a it takes a socket

00:55:11,220 --> 00:55:13,950
factory and I forgot to put a good

00:55:12,540 --> 00:55:18,090
instance in there

00:55:13,950 --> 00:55:20,850
it takes a socket factory and so I make

00:55:18,090 --> 00:55:24,240
a mock socket factory I pass it in as a

00:55:20,850 --> 00:55:27,600
collaborator adding a get instance on

00:55:24,240 --> 00:55:28,890
there if I were smart and I need that

00:55:27,600 --> 00:55:30,270
socket factory

00:55:28,890 --> 00:55:33,030
reading the name of the test here

00:55:30,270 --> 00:55:35,160
insurer proxy logs fatal message when

00:55:33,030 --> 00:55:37,830
control socket fails after second

00:55:35,160 --> 00:55:39,510
handshake right and these are the fun

00:55:37,830 --> 00:55:40,950
bugs these are the fun bugs that come in

00:55:39,510 --> 00:55:42,510
from the field and you're looking at the

00:55:40,950 --> 00:55:43,470
cord up and you're like what the hell

00:55:42,510 --> 00:55:45,510
just happened

00:55:43,470 --> 00:55:49,020
it's way deep in the weeds and you're

00:55:45,510 --> 00:55:52,890
like well how would I don't know you

00:55:49,020 --> 00:55:55,020
know neutrinos attenuation whatever

00:55:52,890 --> 00:55:57,570
right the bits get flipped if you're not

00:55:55,020 --> 00:56:01,170
using ECC Ram all kinds of stuff can

00:55:57,570 --> 00:56:03,180
happen so so I'm gonna make a mock oh

00:56:01,170 --> 00:56:06,330
that's right like I have a pointer here

00:56:03,180 --> 00:56:09,210
I'm gonna make a mock object of socket

00:56:06,330 --> 00:56:11,130
called working handshake socket and I

00:56:09,210 --> 00:56:12,780
have some commented out expectations

00:56:11,130 --> 00:56:14,610
here where I'm gonna set expectations so

00:56:12,780 --> 00:56:16,830
that those things will return values

00:56:14,610 --> 00:56:21,990
like they're working okay and then I

00:56:16,830 --> 00:56:24,000
have a can see there it is I have a

00:56:21,990 --> 00:56:25,890
broken handshake socket and I'm gonna

00:56:24,000 --> 00:56:28,520
assess some expectations on that so it

00:56:25,890 --> 00:56:32,070
returns bad data and misbehaves somehow

00:56:28,520 --> 00:56:35,310
so then I'm gonna tell the where the

00:56:32,070 --> 00:56:38,610
mock socket factory doctor seuss in the

00:56:35,310 --> 00:56:42,120
house the mock socket factory I'm gonna

00:56:38,610 --> 00:56:44,820
tell the creation method I'm gonna tell

00:56:42,120 --> 00:56:48,840
the creation method when it's called

00:56:44,820 --> 00:56:50,700
to return first a working handshake suck

00:56:48,840 --> 00:56:52,620
first to return a working handshake

00:56:50,700 --> 00:56:53,820
socket second time it's called return

00:56:52,620 --> 00:56:56,850
the working handshake socket again

00:56:53,820 --> 00:56:59,550
whoops and then the third time return

00:56:56,850 --> 00:57:03,350
the broken one right and then I'm going

00:56:59,550 --> 00:57:09,660
to tell the mock log or instance from

00:57:03,350 --> 00:57:13,650
back here I'm gonna tell that mock lager

00:57:09,660 --> 00:57:16,260
mock lager instance to expect a call to

00:57:13,650 --> 00:57:18,750
fatal with a standard string that says

00:57:16,260 --> 00:57:21,870
ouch in handshake three and then I call

00:57:18,750 --> 00:57:25,290
proxy Connect right so this is an

00:57:21,870 --> 00:57:27,990
example of i mocked the factory i mocked

00:57:25,290 --> 00:57:30,960
the things that the factory returns to a

00:57:27,990 --> 00:57:34,290
good testing end but it's not violating

00:57:30,960 --> 00:57:35,930
law of demeter right we aren't exposing

00:57:34,290 --> 00:57:37,500
like the whole chain of all of the

00:57:35,930 --> 00:57:41,370
relationship between all of these

00:57:37,500 --> 00:57:42,450
objects and what I say here one thing to

00:57:41,370 --> 00:57:43,980
think about when sit when

00:57:42,450 --> 00:57:45,119
these kind of expectations it's reading

00:57:43,980 --> 00:57:47,160
the test is one thing and that is

00:57:45,119 --> 00:57:49,200
important but think about if this fails

00:57:47,160 --> 00:57:50,880
what does the Mach output look like when

00:57:49,200 --> 00:57:53,160
the Mach expectation fails like what

00:57:50,880 --> 00:57:54,630
does that read like glad to if I have to

00:57:53,160 --> 00:57:56,099
go if they me the thing is it'll look

00:57:54,630 --> 00:57:58,079
like crap just set a breakpoint or

00:57:56,099 --> 00:57:59,099
something like that try to think about

00:57:58,079 --> 00:58:00,810
how you can write these things to that

00:57:59,099 --> 00:58:04,970
the failures are readable so the last

00:58:00,810 --> 00:58:07,079
thing here is deploying a test framework

00:58:04,970 --> 00:58:09,720
one of the problems that I've seen in

00:58:07,079 --> 00:58:13,020
multiple companies and not just with

00:58:09,720 --> 00:58:14,849
sea-green but also with G tests and even

00:58:13,020 --> 00:58:16,710
CPU and stuff like that is that when

00:58:14,849 --> 00:58:20,280
unit test a Stargate starts to get going

00:58:16,710 --> 00:58:21,660
at scale each team does customizations

00:58:20,280 --> 00:58:24,660
little customizations to the framework

00:58:21,660 --> 00:58:28,079
and then so on the build systems you end

00:58:24,660 --> 00:58:29,369
up with 20 30 plus copies of the same

00:58:28,079 --> 00:58:32,339
framework with a lot of tiny little

00:58:29,369 --> 00:58:33,690
changes and if you could get your LD

00:58:32,339 --> 00:58:34,710
library path a little bit wrong or

00:58:33,690 --> 00:58:36,060
whatever you're picking up some other

00:58:34,710 --> 00:58:37,500
teams version of the framework that

00:58:36,060 --> 00:58:38,790
doesn't have your changes or does and

00:58:37,500 --> 00:58:41,450
just becomes kind of deployment

00:58:38,790 --> 00:58:45,089
nightmare just like a guess a DLL hell

00:58:41,450 --> 00:58:46,650
kind of thing so in my experience teams

00:58:45,089 --> 00:58:48,780
and at warge will likely want to be able

00:58:46,650 --> 00:58:50,730
to customize assertion and slash

00:58:48,780 --> 00:58:51,960
constraint slash matters right they want

00:58:50,730 --> 00:58:54,740
to be able to write their own assert

00:58:51,960 --> 00:58:58,020
equal for their custom object types for

00:58:54,740 --> 00:59:01,290
deep comparison of some custom types or

00:58:58,020 --> 00:59:03,060
whatever that's pretty common and they

00:59:01,290 --> 00:59:05,160
might want to customize the reporters of

00:59:03,060 --> 00:59:08,400
the output right they want to do they

00:59:05,160 --> 00:59:09,810
want out put it in some file format that

00:59:08,400 --> 00:59:13,410
their custom continuous integration

00:59:09,810 --> 00:59:15,540
system can slurp up or whatever else so

00:59:13,410 --> 00:59:18,150
one piece of advice there's no code for

00:59:15,540 --> 00:59:19,920
this but it's a general general piece of

00:59:18,150 --> 00:59:21,780
advice pick a framework that allows you

00:59:19,920 --> 00:59:24,540
to customize those things without a

00:59:21,780 --> 00:59:26,819
recompile we talked we touched it we

00:59:24,540 --> 00:59:28,260
talked a lot about modularity and last

00:59:26,819 --> 00:59:30,829
year I said unit testability is

00:59:28,260 --> 00:59:33,270
modularity is object orientation etc etc

00:59:30,829 --> 00:59:35,490
pick a framework that embodies those

00:59:33,270 --> 00:59:38,220
values so that when people are using the

00:59:35,490 --> 00:59:41,640
framework they won't learn won't learn

00:59:38,220 --> 00:59:44,250
bad things so there's the links again to

00:59:41,640 --> 00:59:45,240
see green and mockito PP i-- if you're

00:59:44,250 --> 00:59:48,510
going to consume those things I would

00:59:45,240 --> 00:59:50,849
highly recognize emic if they keep their

00:59:48,510 --> 00:59:52,740
tests passing ice maybe they do I don't

00:59:50,849 --> 00:59:54,690
know I highly recommend tracking those

00:59:52,740 --> 00:59:56,240
repositories and building from source in

00:59:54,690 --> 01:00:00,240
your build

00:59:56,240 --> 01:00:01,890
thank you um thank you guys very much I

01:00:00,240 --> 01:00:03,840
hope this was useful and filled some

01:00:01,890 --> 01:00:05,670
gaps for you guys again I'm gonna

01:00:03,840 --> 01:00:07,500
out my music my musics at the making of

01:00:05,670 --> 01:00:09,270
the making of calm and it's on title

01:00:07,500 --> 01:00:11,100
iTunes Amazon Google Play and Spotify

01:00:09,270 --> 01:00:12,870
that's my twitter handle if you have

01:00:11,100 --> 01:00:14,550
questions for me you can tweet at me

01:00:12,870 --> 01:00:17,180
you can contact me by email you can

01:00:14,550 --> 01:00:20,010
contact me via LinkedIn stuff like that

01:00:17,180 --> 01:00:22,680
the next talks that are coming up after

01:00:20,010 --> 01:00:23,850
this talk context for introduction is in

01:00:22,680 --> 01:00:26,790
this room practical lock-free

01:00:23,850 --> 01:00:29,070
programming is in the feeder room which

01:00:26,790 --> 01:00:32,490
I guess is downstairs has called design

01:00:29,070 --> 01:00:34,260
patterns in C++ are in room 407 C++ and

01:00:32,490 --> 01:00:37,380
the audio industry is in room 406 and

01:00:34,260 --> 01:00:39,270
expression templates is in room 403

01:00:37,380 --> 01:00:40,740
amount of time so if you have any

01:00:39,270 --> 01:00:42,060
questions come up to me after the thing

01:00:40,740 --> 01:00:44,540
and I'll be glad to answer them for you

01:00:42,060 --> 01:00:44,540

YouTube URL: https://www.youtube.com/watch?v=Wmy6g-aVgZI


