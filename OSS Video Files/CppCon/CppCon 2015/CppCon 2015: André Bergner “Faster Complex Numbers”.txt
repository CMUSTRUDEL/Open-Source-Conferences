Title: CppCon 2015: André Bergner “Faster Complex Numbers”
Publication date: 2015-10-08
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Complex numbers are an important tool from mathematics enabling many problems to be written in a more generic form. The C++ standard library comes with an implementation to work with complex numbers in a natural way.

Motivated by useful real world examples from theoretical physics and audio dsp I will discuss benchmarks of std::complex and demonstrate how alternative implementations, naïve or advanced ones based on expression templates, outperform std::complex and can compete with hand-crafted C code (depending on compiler and std lib). A quick introduction to expression templates will be provided.
— 
André leads the Traktor software development team at Native Instruments. There he is taking an active role in modernizing the C++ coding standards by organizing tech talks and introducing new techniques and libraries. Some of his main interests are functional and generic programming and solving meta-programming puzzles. Besides that he is lecturer at the Beuth Hochschule in Berlin where he teaches C++ and is one of the organizers of the local Berlin C++ meetups.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:06,210
I have half an hour we need to talk

00:00:01,979 --> 00:00:07,500
about complex numbers in C++ my name is

00:00:06,210 --> 00:00:10,830
under Beckner and from native

00:00:07,500 --> 00:00:11,759
instruments from Berlin Germany for

00:00:10,830 --> 00:00:14,969
those of you who don't know how to

00:00:11,759 --> 00:00:18,990
rebuild the music software so our

00:00:14,969 --> 00:00:22,730
businesses sound it's like they're of

00:00:18,990 --> 00:00:26,460
course so in so complex i was not

00:00:22,730 --> 00:00:28,920
directly a topic but it could be if that

00:00:26,460 --> 00:00:32,610
would be better implement at all you

00:00:28,920 --> 00:00:34,649
would know more about that my background

00:00:32,610 --> 00:00:36,989
is also a physicist so I broke it off

00:00:34,649 --> 00:00:39,570
with this complex numbers in while doing

00:00:36,989 --> 00:00:42,000
my studying and also we American

00:00:39,570 --> 00:00:45,390
simulations but I come come to the

00:00:42,000 --> 00:00:48,450
applications in a moment so I assume

00:00:45,390 --> 00:00:50,610
everybody in the room knows what complex

00:00:48,450 --> 00:00:52,969
numbers on but more this anybody who

00:00:50,610 --> 00:00:55,860
doesn't know what a complex numbers

00:00:52,969 --> 00:00:57,660
anyway say a just for the case i

00:00:55,860 --> 00:00:59,699
prepared a quick summary so complex

00:00:57,660 --> 00:01:04,470
number is just a composed number of

00:00:59,699 --> 00:01:07,140
which is illegal in the negative part YG

00:01:04,470 --> 00:01:09,439
converse of two real values and the

00:01:07,140 --> 00:01:13,229
layers level we are two imaginary unit

00:01:09,439 --> 00:01:14,670
the purpose that will property that we

00:01:13,229 --> 00:01:19,710
have its minus 1 or the square root of

00:01:14,670 --> 00:01:24,360
minus 1 and following from that property

00:01:19,710 --> 00:01:26,580
of i we have the following algebra that

00:01:24,360 --> 00:01:29,880
basically comes just falls out from that

00:01:26,580 --> 00:01:32,670
property so adding two complex numbers

00:01:29,880 --> 00:01:34,829
is like adding real American imaginary

00:01:32,670 --> 00:01:36,990
parts respectively and multiplication is

00:01:34,829 --> 00:01:39,750
a little bit more complex or complicated

00:01:36,990 --> 00:01:43,770
operation due to the I squared you get

00:01:39,750 --> 00:01:48,240
the minus here and little bit strange

00:01:43,770 --> 00:01:52,200
behavior so it's but but still religious

00:01:48,240 --> 00:01:54,509
again a complex non-muscle and so just

00:01:52,200 --> 00:01:59,040
as a summary if you in case you didn't

00:01:54,509 --> 00:02:01,320
remember so also just just another

00:01:59,040 --> 00:02:03,240
picture so complex numbers usually if

00:02:01,320 --> 00:02:04,890
you draw them you of course since it's a

00:02:03,240 --> 00:02:06,810
real imaginary part you have offices

00:02:04,890 --> 00:02:08,580
really access in the military near

00:02:06,810 --> 00:02:10,319
excess or that's a complex plane and the

00:02:08,580 --> 00:02:13,020
complex number is basically kind of a

00:02:10,319 --> 00:02:13,640
vector in that plane which has like an

00:02:13,020 --> 00:02:16,970
absolute

00:02:13,640 --> 00:02:18,590
you in the face or angle so that's

00:02:16,970 --> 00:02:21,440
another way of seeing complex numbers

00:02:18,590 --> 00:02:22,910
and then you all know that like eddying

00:02:21,440 --> 00:02:24,200
and multiplying then there's certain

00:02:22,910 --> 00:02:26,030
properties so if you multiply two

00:02:24,200 --> 00:02:28,280
complex numbers you multiply their

00:02:26,030 --> 00:02:30,980
absolute values if you at the angles and

00:02:28,280 --> 00:02:33,230
things like that so and you quickly have

00:02:30,980 --> 00:02:36,110
depending on how its set up you can get

00:02:33,230 --> 00:02:41,420
cut can get rotation in the in the

00:02:36,110 --> 00:02:43,220
complex plane for instance so before I

00:02:41,420 --> 00:02:46,790
come back to that and few words about

00:02:43,220 --> 00:02:48,500
application so there's a big so actually

00:02:46,790 --> 00:02:51,110
it's applications are basically

00:02:48,500 --> 00:02:54,170
everywhere in any kind of engineering

00:02:51,110 --> 00:02:55,970
and scientific fields so most obvious

00:02:54,170 --> 00:02:57,530
one the signal processing electrical

00:02:55,970 --> 00:02:59,150
engineering that's they are just

00:02:57,530 --> 00:03:01,580
ubiquitous so there are complex numbers

00:02:59,150 --> 00:03:03,380
are just fundamental so every kind of

00:03:01,580 --> 00:03:05,269
process you model there it's that you

00:03:03,380 --> 00:03:07,940
don't use if you don't use complex

00:03:05,269 --> 00:03:10,250
number of you you it's everything gets

00:03:07,940 --> 00:03:12,230
much more complicated physics of course

00:03:10,250 --> 00:03:14,660
so unlike the Schrodinger equation in

00:03:12,230 --> 00:03:16,400
phantoms or the base of quantum theory

00:03:14,660 --> 00:03:19,820
is based on complex numbers so this is

00:03:16,400 --> 00:03:22,370
like it's just fundamental there and in

00:03:19,820 --> 00:03:23,780
many other processes they practice a

00:03:22,370 --> 00:03:25,850
little bit esoteric so the Mandelbrot

00:03:23,780 --> 00:03:27,860
set for instance is just an iteration of

00:03:25,850 --> 00:03:30,290
complex of a map of complex numbers and

00:03:27,860 --> 00:03:32,329
you just met ala Yeppoon of exponent and

00:03:30,290 --> 00:03:34,790
then you get that nice picture which is

00:03:32,329 --> 00:03:38,630
basically just a stability map of that

00:03:34,790 --> 00:03:40,670
complex equation then falling from that

00:03:38,630 --> 00:03:42,620
you have like chaos EU complex system so

00:03:40,670 --> 00:03:44,630
that's a field I work in and there you

00:03:42,620 --> 00:03:46,700
have a lot of complex numbers as well

00:03:44,630 --> 00:03:48,860
and then also I found something like

00:03:46,700 --> 00:03:51,620
radar system optical systems they use

00:03:48,860 --> 00:03:53,390
complex number so it's just everywhere

00:03:51,620 --> 00:03:55,730
and it's and as soon as you have

00:03:53,390 --> 00:03:58,850
software and you work and maybe one of

00:03:55,730 --> 00:04:01,489
those fields so in my case it was like

00:03:58,850 --> 00:04:03,560
koce complex systems physics and now

00:04:01,489 --> 00:04:06,049
it's mean it's the more less signal

00:04:03,560 --> 00:04:08,690
processing in the case of audio you it's

00:04:06,049 --> 00:04:11,000
pretty nice if you have if you can give

00:04:08,690 --> 00:04:17,840
as complex number in the streamlined and

00:04:11,000 --> 00:04:19,760
easy way so if you so if you do kind of

00:04:17,840 --> 00:04:22,190
that stuff you are usually interested in

00:04:19,760 --> 00:04:24,830
speaks so because you do you do numerics

00:04:22,190 --> 00:04:26,960
and you want stop fast so because if you

00:04:24,830 --> 00:04:27,570
do number crunching and usually when you

00:04:26,960 --> 00:04:30,420
do number

00:04:27,570 --> 00:04:32,490
if it's if it's really like stream

00:04:30,420 --> 00:04:33,630
processing already out throughput is

00:04:32,490 --> 00:04:35,670
important either you lose big

00:04:33,630 --> 00:04:37,620
simulations and you want to have them of

00:04:35,670 --> 00:04:40,050
course the costs for your simulation is

00:04:37,620 --> 00:04:43,680
it's expensive you want to minimize set

00:04:40,050 --> 00:04:45,990
on our case we do audio you want to hit

00:04:43,680 --> 00:04:47,640
like the user should be able to run as

00:04:45,990 --> 00:04:49,430
many synthesizers on as computer as

00:04:47,640 --> 00:04:52,080
possible for instance or there should be

00:04:49,430 --> 00:04:53,970
this should be possible so the slower

00:04:52,080 --> 00:04:56,190
the whole thing gets the less so a

00:04:53,970 --> 00:04:59,160
factor of two already means you can only

00:04:56,190 --> 00:05:01,530
run twice as many twice as less than

00:04:59,160 --> 00:05:09,060
their applications for instance on one

00:05:01,530 --> 00:05:11,160
system so there is the standard so the

00:05:09,060 --> 00:05:12,930
order sta i'm not i'm not sure quite of

00:05:11,160 --> 00:05:16,610
it's really part of the stl or it's like

00:05:12,930 --> 00:05:18,960
beyond the STA so I don't know with Alex

00:05:16,610 --> 00:05:22,380
put it in or beyond and put it in or

00:05:18,960 --> 00:05:24,210
somebody else but there is still complex

00:05:22,380 --> 00:05:26,450
so this is a less little class that

00:05:24,210 --> 00:05:28,620
comes bundled with the standard library

00:05:26,450 --> 00:05:30,930
basically since back in the days at

00:05:28,620 --> 00:05:33,710
least 98 I don't know when it came in so

00:05:30,930 --> 00:05:36,480
couldn't find anything about that and

00:05:33,710 --> 00:05:38,040
this gives basically access to wire

00:05:36,480 --> 00:05:40,920
operator overloading somebody is a

00:05:38,040 --> 00:05:43,230
classically C++ where you have a you

00:05:40,920 --> 00:05:47,220
have a complex number and you can deal

00:05:43,230 --> 00:05:48,690
with it in a streamlined fashion so

00:05:47,220 --> 00:05:51,180
that's basically almost it so in the

00:05:48,690 --> 00:05:53,250
mean usually if you do c++ I mean many

00:05:51,180 --> 00:05:54,990
people used to do and when still do for

00:05:53,250 --> 00:05:57,720
trend because everybody says for tennis

00:05:54,990 --> 00:06:00,360
affairs and blah blah blah I mean this

00:05:57,720 --> 00:06:03,360
is not really true to some extent it is

00:06:00,360 --> 00:06:05,220
kind of true but you can get of course

00:06:03,360 --> 00:06:06,480
the same performance with C and C++ but

00:06:05,220 --> 00:06:07,770
you have to know what you are doing but

00:06:06,480 --> 00:06:10,500
unfortunately a lot of stuff is just

00:06:07,770 --> 00:06:12,210
filled in so but nowadays of course

00:06:10,500 --> 00:06:14,100
Fortran is the sides of number-crunching

00:06:12,210 --> 00:06:17,010
photons are pretty ugly language and so

00:06:14,100 --> 00:06:19,320
a lot of modern scientists and engineers

00:06:17,010 --> 00:06:21,420
switch to c and c++ which is basically

00:06:19,320 --> 00:06:24,380
the only alternative out there if you

00:06:21,420 --> 00:06:27,420
leave on speed for number crunching and

00:06:24,380 --> 00:06:30,060
but then you're on your own soul c++ by

00:06:27,420 --> 00:06:31,980
default only basically brings its stead

00:06:30,060 --> 00:06:33,660
complex and there's valer e that most of

00:06:31,980 --> 00:06:35,430
people don't know this is like a vector

00:06:33,660 --> 00:06:37,140
of it which you can add and then there's

00:06:35,430 --> 00:06:38,730
a numeric header and that's in the mass

00:06:37,140 --> 00:06:41,490
and that's about it so there's not much

00:06:38,730 --> 00:06:43,770
so a lot of stuff is developed like like

00:06:41,490 --> 00:06:45,180
or the linear algebra numeric stuff it

00:06:43,770 --> 00:06:46,410
comes from outside and there are many

00:06:45,180 --> 00:06:49,259
many implementations or what they

00:06:46,410 --> 00:06:50,580
actually have nice to at least that the

00:06:49,259 --> 00:06:52,800
stuff that is here there should be a

00:06:50,580 --> 00:06:56,610
little bit more in the standard and this

00:06:52,800 --> 00:07:01,710
stuff should be at least working I come

00:06:56,610 --> 00:07:03,810
to that later so M so that's how you use

00:07:01,710 --> 00:07:05,639
it so for those of those who didn't know

00:07:03,810 --> 00:07:07,560
that there is a complex number in the st

00:07:05,639 --> 00:07:09,900
am so it looks like that so it's you

00:07:07,560 --> 00:07:12,889
just include header complex and so even

00:07:09,900 --> 00:07:16,650
see gotta some complex numbers now I

00:07:12,889 --> 00:07:18,569
think it's C 1999 as a template

00:07:16,650 --> 00:07:20,580
parameter say can specify float a double

00:07:18,569 --> 00:07:23,550
in theory it should be possible to add

00:07:20,580 --> 00:07:25,020
like also fixed point numbers there you

00:07:23,550 --> 00:07:27,840
initialize with your wheel imaginary

00:07:25,020 --> 00:07:30,599
part and there's also like a function

00:07:27,840 --> 00:07:32,190
constructor that constructive complex

00:07:30,599 --> 00:07:35,940
number from polar coordinates so from

00:07:32,190 --> 00:07:37,530
the radios and anger which is specify

00:07:35,940 --> 00:07:39,509
and it returns the complex number and

00:07:37,530 --> 00:07:41,069
then you can just work with them in in

00:07:39,509 --> 00:07:42,900
the mathematical way in the convenient

00:07:41,069 --> 00:07:49,080
way you just multiply and Adam so all

00:07:42,900 --> 00:07:52,440
the operations are overloaded so what

00:07:49,080 --> 00:07:56,219
can you do with it so the like a nice

00:07:52,440 --> 00:07:57,960
way to create a oscillator so really if

00:07:56,219 --> 00:08:00,360
you need an oscillation so you'll be

00:07:57,960 --> 00:08:02,699
really just a sine function for instance

00:08:00,360 --> 00:08:03,960
it would be an oscillator just like the

00:08:02,699 --> 00:08:06,570
fastest where you can write an

00:08:03,960 --> 00:08:09,630
oscillator and C++ using this complex

00:08:06,570 --> 00:08:12,240
class so yeah so a little oscillator

00:08:09,630 --> 00:08:13,650
class has like two complex numbers which

00:08:12,240 --> 00:08:15,360
is one is a state and the other one is

00:08:13,650 --> 00:08:17,849
basically the updates or the speed of

00:08:15,360 --> 00:08:20,130
rotation and then you just set your call

00:08:17,849 --> 00:08:21,750
operator and just simply updates the

00:08:20,130 --> 00:08:24,719
state by multiplying it with the

00:08:21,750 --> 00:08:26,789
rotation and returns the rear part so if

00:08:24,719 --> 00:08:30,000
you case your own interested in the real

00:08:26,789 --> 00:08:32,130
valued oscillation and yeah and the

00:08:30,000 --> 00:08:34,620
important part is the polar coordinate

00:08:32,130 --> 00:08:36,570
is like the absolute value as 1 and this

00:08:34,620 --> 00:08:38,550
would be the frequency so in the

00:08:36,570 --> 00:08:43,289
property of the complex numbers is that

00:08:38,550 --> 00:08:44,910
they start rotating the angles get edit

00:08:43,289 --> 00:08:47,579
under the multiplication and the radius

00:08:44,910 --> 00:08:49,200
get multiplied so the radios in that

00:08:47,579 --> 00:08:50,790
case or the absolute value is once or

00:08:49,200 --> 00:08:53,070
one times whatever the other one is

00:08:50,790 --> 00:08:55,310
Stacy value of the other one and the

00:08:53,070 --> 00:08:58,230
angles just get

00:08:55,310 --> 00:09:00,089
forwarded by that amount this just gets

00:08:58,230 --> 00:09:04,410
added to the angle of the state so

00:09:00,089 --> 00:09:06,540
that's why it's rotating it's you little

00:09:04,410 --> 00:09:09,660
picture Antonio sorry that has moved a

00:09:06,540 --> 00:09:11,220
little bit anyway that's it just

00:09:09,660 --> 00:09:12,839
illustrate it again so they physically

00:09:11,220 --> 00:09:16,470
the complex numbers rotating in the

00:09:12,839 --> 00:09:18,209
plane through that operation and the

00:09:16,470 --> 00:09:20,399
real part would look basically I guess

00:09:18,209 --> 00:09:23,189
so you get the sinusoidal output yeah

00:09:20,399 --> 00:09:25,050
also just for the fun of it I add also

00:09:23,189 --> 00:09:26,699
using C++ 14 you don't even have to

00:09:25,050 --> 00:09:28,350
write a class anymore you can just write

00:09:26,699 --> 00:09:30,689
a little function that returns a lambda

00:09:28,350 --> 00:09:33,300
and using those initializers here you

00:09:30,689 --> 00:09:35,370
can put the values right in there and

00:09:33,300 --> 00:09:37,160
have just a lambda that computes the

00:09:35,370 --> 00:09:39,899
complex numbers is just a nice little

00:09:37,160 --> 00:09:41,970
even more compact way to write an

00:09:39,899 --> 00:09:43,670
oscillator and C++ so that would be

00:09:41,970 --> 00:09:46,860
actually pretty neat if you could just

00:09:43,670 --> 00:09:51,540
do more mess that we compact and

00:09:46,860 --> 00:09:59,790
streamlined fashion and just hope that

00:09:51,540 --> 00:10:03,600
it's fast him so ok let's just think

00:09:59,790 --> 00:10:05,579
again a bit more complicated so another

00:10:03,600 --> 00:10:09,029
really interesting example I want to

00:10:05,579 --> 00:10:11,730
give you is the complex or complex

00:10:09,029 --> 00:10:13,160
resonator at sometimes called the Vedic

00:10:11,730 --> 00:10:15,720
is the simplest possible way to

00:10:13,160 --> 00:10:17,699
construct a bandpass filter so for those

00:10:15,720 --> 00:10:19,800
of you are not known so much about

00:10:17,699 --> 00:10:22,829
future theory and then filters ventas

00:10:19,800 --> 00:10:24,870
rates are simply a filter it means or

00:10:22,829 --> 00:10:27,120
when in engineering the defeat that

00:10:24,870 --> 00:10:29,220
filters out all the frequencies except

00:10:27,120 --> 00:10:30,810
for a certain band of frequency range

00:10:29,220 --> 00:10:32,130
which you can specify for the filter

00:10:30,810 --> 00:10:33,779
everything edge gets figured out so the

00:10:32,130 --> 00:10:35,550
side is typically radio effect for

00:10:33,779 --> 00:10:38,130
instance like old radio effect that

00:10:35,550 --> 00:10:40,680
would be a band pass filter so let me

00:10:38,130 --> 00:10:42,360
know kind of how it sounds like and the

00:10:40,680 --> 00:10:44,399
quickest way again is using state

00:10:42,360 --> 00:10:46,980
complex so you would basically the same

00:10:44,399 --> 00:10:48,870
as oscillator before oh yes your state

00:10:46,980 --> 00:10:50,639
and your rotation and now you simply

00:10:48,870 --> 00:10:52,740
have an external state that would be

00:10:50,639 --> 00:10:55,410
your input signal it creates the output

00:10:52,740 --> 00:10:57,089
signal and the way it works is simply

00:10:55,410 --> 00:10:58,980
you still have the same update but you

00:10:57,089 --> 00:11:01,110
just add the input signal and just

00:10:58,980 --> 00:11:03,589
naturally this event has returned your

00:11:01,110 --> 00:11:06,720
perfect control over it so because the

00:11:03,589 --> 00:11:08,070
radios kind of controls your bandwidth

00:11:06,720 --> 00:11:10,710
of your band pass filter

00:11:08,070 --> 00:11:12,660
the center frequency basically courts

00:11:10,710 --> 00:11:16,440
and control it's a position in the the

00:11:12,660 --> 00:11:18,210
frequency range so this is like this one

00:11:16,440 --> 00:11:20,820
this one is also a nice property of that

00:11:18,210 --> 00:11:22,950
band as without also that very stable so

00:11:20,820 --> 00:11:26,490
it you can go down to very low

00:11:22,950 --> 00:11:27,900
frequencies and you can easily modulate

00:11:26,490 --> 00:11:30,060
it because it only depends on its last

00:11:27,900 --> 00:11:31,830
state and not the second to last usually

00:11:30,060 --> 00:11:35,100
if you go if you use like those stenner

00:11:31,830 --> 00:11:37,350
GSP features or recessive also not one

00:11:35,100 --> 00:11:39,240
history step more and then it gets

00:11:37,350 --> 00:11:41,820
unstable under modulations but this one

00:11:39,240 --> 00:11:43,200
returns stay stable so it's also why

00:11:41,820 --> 00:11:44,960
it's nice to have complex numbers

00:11:43,200 --> 00:11:48,030
because it's real not only that it's

00:11:44,960 --> 00:11:51,270
that it's more streamlined it's also

00:11:48,030 --> 00:11:54,990
pretty it's more stable and easier to

00:11:51,270 --> 00:12:00,360
write so I had now coming to the

00:11:54,990 --> 00:12:01,740
actually part so about performance I had

00:12:00,360 --> 00:12:04,380
a little bit more complicated problem I

00:12:01,740 --> 00:12:06,600
was just working on some time ago a

00:12:04,380 --> 00:12:08,280
little side project of mine we're like a

00:12:06,600 --> 00:12:09,960
filter bank and a bunch of those

00:12:08,280 --> 00:12:11,340
resonators they were coupled with each

00:12:09,960 --> 00:12:13,940
others and it was a little bit more

00:12:11,340 --> 00:12:16,350
complicated expression so I thought hmm

00:12:13,940 --> 00:12:18,000
because I had other problems before way

00:12:16,350 --> 00:12:21,090
I'd like a little matrix vector

00:12:18,000 --> 00:12:25,500
multiplication in the friend of mine who

00:12:21,090 --> 00:12:27,180
so also of boost orient I told him yeah

00:12:25,500 --> 00:12:29,460
I would like to use expression templates

00:12:27,180 --> 00:12:32,100
here but he said no it should was just

00:12:29,460 --> 00:12:33,630
work out of the box and then I I tried

00:12:32,100 --> 00:12:35,250
it and it worked pretty fast but then I

00:12:33,630 --> 00:12:36,330
changed it in a bit and sandy was much

00:12:35,250 --> 00:12:38,730
slower and then I used the expression

00:12:36,330 --> 00:12:40,350
templates and was fast again so I

00:12:38,730 --> 00:12:42,000
certain I checked that I mean they are

00:12:40,350 --> 00:12:44,280
simpler than just the matrix and vector

00:12:42,000 --> 00:12:47,660
and maybe the compiler somehow knows

00:12:44,280 --> 00:12:50,580
about them and so I just checked if I

00:12:47,660 --> 00:12:52,110
just double checked with a head

00:12:50,580 --> 00:12:53,910
corrected version so let's play review

00:12:52,110 --> 00:12:57,420
so this is the same thing again as

00:12:53,910 --> 00:12:59,220
before almost hidden numbers a little

00:12:57,420 --> 00:13:02,490
bit different but this is basically what

00:12:59,220 --> 00:13:04,350
the compiler should create for us so

00:13:02,490 --> 00:13:07,680
this is how it should look like in

00:13:04,350 --> 00:13:10,230
theory I mean I happen in the in the

00:13:07,680 --> 00:13:12,570
example before I create a complex number

00:13:10,230 --> 00:13:14,430
here and then a signatory assigned I

00:13:12,570 --> 00:13:16,800
have to assignment operations now i have

00:13:14,430 --> 00:13:18,690
only only one saw their own only one

00:13:16,800 --> 00:13:20,620
temporary and then the direct assignment

00:13:18,690 --> 00:13:22,450
so there should be maybe one move less

00:13:20,620 --> 00:13:24,190
but that's about it so that's what I

00:13:22,450 --> 00:13:28,260
would expect from a compiler that this

00:13:24,190 --> 00:13:32,680
version should run at all just slightly

00:13:28,260 --> 00:13:37,180
bit slower and but what I have seen is

00:13:32,680 --> 00:13:39,460
this so the red one is step complex and

00:13:37,180 --> 00:13:42,160
the yellow one is the hand crafted

00:13:39,460 --> 00:13:44,410
version so i actually started out at

00:13:42,160 --> 00:13:46,000
claim originally because i always use

00:13:44,410 --> 00:13:47,830
playing i have a lot of templates

00:13:46,000 --> 00:13:49,450
usually my code and clang is still the

00:13:47,830 --> 00:13:52,330
best when it comes to optimizing

00:13:49,450 --> 00:13:54,100
templates away but i know of course when

00:13:52,330 --> 00:13:55,780
while preparing all of that i also

00:13:54,100 --> 00:13:57,640
checked the other compilers and did some

00:13:55,780 --> 00:14:00,820
more research how they perform what what

00:13:57,640 --> 00:14:02,800
are the problems there so the we see

00:14:00,820 --> 00:14:06,220
protein sources or run on this machine

00:14:02,800 --> 00:14:09,190
basically so I just sent that resonator

00:14:06,220 --> 00:14:11,170
you just saw was a whole big big signals

00:14:09,190 --> 00:14:14,800
or adversary just Nyquist frequency so

00:14:11,170 --> 00:14:16,630
alternating values and just measure the

00:14:14,800 --> 00:14:17,650
time sort of timeless blocking your

00:14:16,630 --> 00:14:22,300
milliseconds and of course that's

00:14:17,650 --> 00:14:25,390
averaged over many many runs um so the

00:14:22,300 --> 00:14:26,800
interesting thing is now a GCC the

00:14:25,390 --> 00:14:28,060
handcrafted version is still I mean this

00:14:26,800 --> 00:14:30,640
kind of the gap I would have expected

00:14:28,060 --> 00:14:33,640
maybe a little bit less patent claim is

00:14:30,640 --> 00:14:36,430
almost a factor of 3 and 0 to vc 14 is

00:14:33,640 --> 00:14:38,230
still slower compared to claim so i

00:14:36,430 --> 00:14:39,820
don't know which so it was run by a

00:14:38,230 --> 00:14:41,830
while so i don't know which kind of

00:14:39,820 --> 00:14:44,350
overheads it's eerie wine is not an

00:14:41,830 --> 00:14:47,200
emulator so it should be as fast so it

00:14:44,350 --> 00:14:49,240
should just wrap the cord to the win api

00:14:47,200 --> 00:14:51,430
but i don't know so there might be some

00:14:49,240 --> 00:14:54,490
overhead but my in my experience and

00:14:51,430 --> 00:14:56,640
it's anyway that i haven't seen the

00:14:54,490 --> 00:14:59,260
microsoft compiler perform very well on

00:14:56,640 --> 00:15:01,870
performing numerical things or usually

00:14:59,260 --> 00:15:03,970
has really a lot of more memory transfer

00:15:01,870 --> 00:15:06,030
operations then required and especially

00:15:03,970 --> 00:15:09,220
on recursive operations like the onion

00:15:06,030 --> 00:15:11,410
so doesn't surprise me wouldn't surprise

00:15:09,220 --> 00:15:14,200
me if it's really as fast as playing on

00:15:11,410 --> 00:15:17,590
GCC what would surprise me that with the

00:15:14,200 --> 00:15:20,920
fs so but yeah there's a big gap so what

00:15:17,590 --> 00:15:22,240
i am didn't originally I did okay I

00:15:20,920 --> 00:15:25,240
always wanted to do a little bit more

00:15:22,240 --> 00:15:26,500
this expression templates instead of

00:15:25,240 --> 00:15:27,880
looking into the details because I

00:15:26,500 --> 00:15:28,990
thought our they must have done it right

00:15:27,880 --> 00:15:31,310
and the

00:15:28,990 --> 00:15:32,810
it's probably X to the expression

00:15:31,310 --> 00:15:35,210
template from that the compiler just

00:15:32,810 --> 00:15:38,330
cannot optimize it so who has worked

00:15:35,210 --> 00:15:40,730
this expression templates okay so are we

00:15:38,330 --> 00:15:44,720
half of this so just to give you a quick

00:15:40,730 --> 00:15:47,300
summary of that or recap so expression

00:15:44,720 --> 00:15:48,650
templates is it's a technique a very

00:15:47,300 --> 00:15:50,030
common technique especially if you are

00:15:48,650 --> 00:15:51,530
doing your break stuff so if you want to

00:15:50,030 --> 00:15:53,690
have fast or if you are building an

00:15:51,530 --> 00:15:55,460
domain-specific language so you want to

00:15:53,690 --> 00:15:59,270
embed a customer language in your port

00:15:55,460 --> 00:16:00,980
and that does computations at compile

00:15:59,270 --> 00:16:02,960
time so it's one of those hardcore meta

00:16:00,980 --> 00:16:04,790
programming techniques and the core idea

00:16:02,960 --> 00:16:06,290
especially AI mean this was a think of

00:16:04,790 --> 00:16:09,500
originally also meant it for like linear

00:16:06,290 --> 00:16:12,880
algebra somewhere in the 90s so the core

00:16:09,500 --> 00:16:15,560
idea is that instead of computing so the

00:16:12,880 --> 00:16:20,660
idea is you don't compute the others I

00:16:15,560 --> 00:16:23,720
eagerly you you compute everything lazy

00:16:20,660 --> 00:16:25,220
so the other operations are overloaded

00:16:23,720 --> 00:16:27,380
and instead of returning the result

00:16:25,220 --> 00:16:30,460
immediately they return a proxy object

00:16:27,380 --> 00:16:32,870
that encapsulates the operation and the

00:16:30,460 --> 00:16:34,700
day reference to the operands so you

00:16:32,870 --> 00:16:37,190
don't so if you call the multiplication

00:16:34,700 --> 00:16:40,910
operator you don't compute the result

00:16:37,190 --> 00:16:43,550
you just return a in a proxy to the

00:16:40,910 --> 00:16:44,810
operation and the arguments and then if

00:16:43,550 --> 00:16:47,210
you put that together with the next

00:16:44,810 --> 00:16:49,250
operation you have a proxy to a proxy

00:16:47,210 --> 00:16:51,380
that has all the arguments and

00:16:49,250 --> 00:16:53,360
operations and it can be get very

00:16:51,380 --> 00:16:56,390
complicated if you have pic expressions

00:16:53,360 --> 00:16:58,460
and then they are collect a lot of meta

00:16:56,390 --> 00:17:01,160
programming techniques to the leg speed

00:16:58,460 --> 00:17:03,050
the whole thing up to make so to prune

00:17:01,160 --> 00:17:04,280
the tree and then filter that and all

00:17:03,050 --> 00:17:05,630
kind of sort of basically the technique

00:17:04,280 --> 00:17:07,550
to help the compiler streamlining

00:17:05,630 --> 00:17:09,980
operations or especially getting rid of

00:17:07,550 --> 00:17:12,079
temporary variables and also like

00:17:09,980 --> 00:17:13,459
getting rich unrolling for loops or just

00:17:12,079 --> 00:17:16,130
having one for loop instead of many and

00:17:13,459 --> 00:17:18,290
so on so for linear algebra usually

00:17:16,130 --> 00:17:19,880
still gives you a lot of performance for

00:17:18,290 --> 00:17:23,020
that I wouldn't have expected that the

00:17:19,880 --> 00:17:26,810
performance is much better actually so

00:17:23,020 --> 00:17:30,230
just a quick sketch of how that look

00:17:26,810 --> 00:17:31,880
like for those who don't know so the

00:17:30,230 --> 00:17:33,710
core idea is you overload the operator

00:17:31,880 --> 00:17:34,790
star for your here for your left hand

00:17:33,710 --> 00:17:37,100
right hand side so that with your

00:17:34,790 --> 00:17:38,810
complex number for instance and now

00:17:37,100 --> 00:17:42,090
instead of returning the results

00:17:38,810 --> 00:17:45,720
immediately you turn a expression that

00:17:42,090 --> 00:17:47,610
Slate's a somehow a tech or policy that

00:17:45,720 --> 00:17:50,159
describes the operation and then the

00:17:47,610 --> 00:17:52,230
left and right hand types and it stores

00:17:50,159 --> 00:17:53,730
the references to the type so that the

00:17:52,230 --> 00:17:55,919
expression could be as simple as that

00:17:53,730 --> 00:17:59,039
it's just holding references and then

00:17:55,919 --> 00:18:01,049
you have you need those three things you

00:17:59,039 --> 00:18:02,929
need their variation of the expression

00:18:01,049 --> 00:18:05,100
which called the operator on the

00:18:02,929 --> 00:18:07,080
evaluated left and right hand side and

00:18:05,100 --> 00:18:09,360
then you have a for beg for non

00:18:07,080 --> 00:18:12,330
expressions which does identity function

00:18:09,360 --> 00:18:13,970
and then your multiplication would for

00:18:12,330 --> 00:18:17,429
look for instance look like that so that

00:18:13,970 --> 00:18:19,919
has a member function apply whatever you

00:18:17,429 --> 00:18:21,779
call it to apply its coil here so those

00:18:19,919 --> 00:18:24,179
that apply which returns the actually

00:18:21,779 --> 00:18:26,100
multiplication so and you stick that all

00:18:24,179 --> 00:18:27,480
together in this you would overload your

00:18:26,100 --> 00:18:29,970
assignment operator of your complex

00:18:27,480 --> 00:18:32,730
number type so that if actually the

00:18:29,970 --> 00:18:34,740
assignment would then call the eval and

00:18:32,730 --> 00:18:36,929
the vibe will just go down the tree of

00:18:34,740 --> 00:18:38,460
operations so we cause evolved on you

00:18:36,929 --> 00:18:41,640
are in use of the left and right hand

00:18:38,460 --> 00:18:43,169
side so if those are numbers numbers but

00:18:41,640 --> 00:18:45,419
if left or right hand side is an

00:18:43,169 --> 00:18:47,309
expression again it before the eval of

00:18:45,419 --> 00:18:48,870
that expression and so on and so on

00:18:47,309 --> 00:18:51,419
until you reach the Leafs and then you

00:18:48,870 --> 00:18:53,279
in the end you get to pull result so

00:18:51,419 --> 00:18:58,649
this usually makes makes it for the

00:18:53,279 --> 00:19:03,570
compiler easier to get here to speed up

00:18:58,649 --> 00:19:06,450
the computation just for the sake of it

00:19:03,570 --> 00:19:07,980
i also thought okay of course I look in

00:19:06,450 --> 00:19:10,289
the headers but I didn't scan really in

00:19:07,980 --> 00:19:13,440
detail and usually they do a lot of

00:19:10,289 --> 00:19:16,070
stuff so in the header so it's hard to

00:19:13,440 --> 00:19:18,929
see what actually is happening sometimes

00:19:16,070 --> 00:19:21,210
so I thought okay just let's make it

00:19:18,929 --> 00:19:22,710
really simple naive so I called it a

00:19:21,210 --> 00:19:25,049
naive implementation but which would be

00:19:22,710 --> 00:19:26,730
the straight forward eagerly evaluating

00:19:25,049 --> 00:19:28,200
implementation so that means either a

00:19:26,730 --> 00:19:30,620
complex number of course I'm this

00:19:28,200 --> 00:19:33,059
trivial or your real and imaginary part

00:19:30,620 --> 00:19:34,470
the member functions to x sm and then

00:19:33,059 --> 00:19:35,970
your for instant again the

00:19:34,470 --> 00:19:38,520
multiplication operator would look like

00:19:35,970 --> 00:19:40,470
that you just implement the algebra of

00:19:38,520 --> 00:19:44,850
complex numbers or real part and just

00:19:40,470 --> 00:19:47,070
computer so now measuring those results

00:19:44,850 --> 00:19:49,710
it looks like this so this is all so

00:19:47,070 --> 00:19:51,590
much it's very interesting so obviously

00:19:49,710 --> 00:19:53,760
in the case of the Microsoft compiler

00:19:51,590 --> 00:19:55,980
expression templates head

00:19:53,760 --> 00:19:58,100
we needed compiler so this is the

00:19:55,980 --> 00:20:00,600
greenish one is the naive implementation

00:19:58,100 --> 00:20:02,010
which is still a little bit faster than

00:20:00,600 --> 00:20:06,450
the one from the stip complex for some

00:20:02,010 --> 00:20:09,050
reason and the expression template

00:20:06,450 --> 00:20:12,120
version is almost twice as fast or

00:20:09,050 --> 00:20:14,070
two-thirds maybe it's basically on

00:20:12,120 --> 00:20:15,240
parvis head corrected version at least

00:20:14,070 --> 00:20:18,090
for the Microsoft compiler the

00:20:15,240 --> 00:20:19,950
expression templates really hip and to

00:20:18,090 --> 00:20:23,160
speak up the optimization for the

00:20:19,950 --> 00:20:25,200
compiler and of course still I mean the

00:20:23,160 --> 00:20:29,750
obvious thing is if the stick complex

00:20:25,200 --> 00:20:34,290
and pretty slow and clang basically as

00:20:29,750 --> 00:20:36,150
expected would be the expression

00:20:34,290 --> 00:20:37,850
template and that youth implementation

00:20:36,150 --> 00:20:40,320
they are basically the same speech so

00:20:37,850 --> 00:20:42,870
there's no different but still both are

00:20:40,320 --> 00:20:45,540
slower than the and corrected version so

00:20:42,870 --> 00:20:48,840
still the hand crafted it cannot compile

00:20:45,540 --> 00:20:51,510
a doesn't quite get performance of the

00:20:48,840 --> 00:20:53,880
handcrafted version interesting the

00:20:51,510 --> 00:20:55,590
hosel at least the clang and the GCC

00:20:53,880 --> 00:20:57,900
handcrafted version they are same speed

00:20:55,590 --> 00:21:01,830
so at least though these are identical

00:20:57,900 --> 00:21:03,510
so you can get the speed of of GCC with

00:21:01,830 --> 00:21:05,790
splenda but you have to basically write

00:21:03,510 --> 00:21:07,500
it out so you don't can use abstraction

00:21:05,790 --> 00:21:10,320
but be one you're using sleep especially

00:21:07,500 --> 00:21:12,780
because we want abstraction so compiler

00:21:10,320 --> 00:21:14,280
should get better than that and even

00:21:12,780 --> 00:21:17,760
expression template maybe I thought

00:21:14,280 --> 00:21:19,380
about even overloading the assignment it

00:21:17,760 --> 00:21:21,450
says so that you have a ternary operator

00:21:19,380 --> 00:21:22,740
and then you could like the trick I was

00:21:21,450 --> 00:21:24,150
doing with the temporary though it's

00:21:22,740 --> 00:21:25,530
something like that maybe they are

00:21:24,150 --> 00:21:27,120
something i could assume that you can

00:21:25,530 --> 00:21:29,640
write some custom kernels for your

00:21:27,120 --> 00:21:31,710
expressions that maybe get to the speed

00:21:29,640 --> 00:21:33,630
but i mean then you start really lot of

00:21:31,710 --> 00:21:36,390
engineering for actually very simple

00:21:33,630 --> 00:21:39,150
problem so compiler should be able to do

00:21:36,390 --> 00:21:40,320
that and you basically coming to the

00:21:39,150 --> 00:21:43,800
next slide you will see that actually

00:21:40,320 --> 00:21:46,020
compilers can do that but actually only

00:21:43,800 --> 00:21:49,260
GCC has still again the best performance

00:21:46,020 --> 00:21:51,570
so basically it's always this case from

00:21:49,260 --> 00:21:53,640
my from my experience that if you want

00:21:51,570 --> 00:21:55,380
performance and you have the choice to

00:21:53,640 --> 00:21:57,930
choose a particular compiler and

00:21:55,380 --> 00:22:01,310
platform always use GCC because it's

00:21:57,930 --> 00:22:03,360
still the best so you see in that case

00:22:01,310 --> 00:22:04,260
but of course you still see that gap

00:22:03,360 --> 00:22:06,060
here so

00:22:04,260 --> 00:22:07,590
I also looked a little bit in the

00:22:06,060 --> 00:22:12,420
assembly output this is the assembly

00:22:07,590 --> 00:22:13,770
output of GCC left hand side step

00:22:12,420 --> 00:22:16,860
complex and right hand side a

00:22:13,770 --> 00:22:18,660
handcrafted so it's basically the same

00:22:16,860 --> 00:22:21,570
amount of operations but if you look at

00:22:18,660 --> 00:22:24,240
the details you have just plain assembly

00:22:21,570 --> 00:22:27,600
instructions and here is giving one that

00:22:24,240 --> 00:22:30,570
they call it with some more dc-3 so this

00:22:27,600 --> 00:22:32,660
is like really that is basically the

00:22:30,570 --> 00:22:37,890
reason why at least also in the GCC case

00:22:32,660 --> 00:22:41,220
it's slow on if you look at stood

00:22:37,890 --> 00:22:42,720
complex from clang basically similar

00:22:41,220 --> 00:22:44,970
things so this is basically your for

00:22:42,720 --> 00:22:47,660
loop now just a bunch of operation and

00:22:44,970 --> 00:22:51,420
here inside yet also again little call

00:22:47,660 --> 00:22:52,650
and now this is really insane so that

00:22:51,420 --> 00:23:01,950
function that gets called as this

00:22:52,650 --> 00:23:04,230
function yeah what is it doing that's

00:23:01,950 --> 00:23:05,430
the header so that's from the header so

00:23:04,230 --> 00:23:08,820
that's when the standard header so this

00:23:05,430 --> 00:23:11,460
is operator star yeah all right a star

00:23:08,820 --> 00:23:13,740
in the header and you see it's like

00:23:11,460 --> 00:23:16,460
training a lot of temporaries and then

00:23:13,740 --> 00:23:20,490
it's checking branching a lot so of them

00:23:16,460 --> 00:23:23,340
if none and left hand or right hand side

00:23:20,490 --> 00:23:25,530
or both yeah and then it's infinite and

00:23:23,340 --> 00:23:33,780
copy signed is now and again copy sign

00:23:25,530 --> 00:23:35,490
again yeah it's really yeah exactly so

00:23:33,780 --> 00:23:38,730
that what I found out so it's full I

00:23:35,490 --> 00:23:40,170
Triple E compliance and for instance

00:23:38,730 --> 00:23:41,880
then I was also searching little bit in

00:23:40,170 --> 00:23:43,860
the web so it princes for trend doesn't

00:23:41,880 --> 00:23:46,560
do that so then people were comparing

00:23:43,860 --> 00:23:48,150
like c++ best Fortran and then again for

00:23:46,560 --> 00:23:50,820
trend is much faster and blah blah blah

00:23:48,150 --> 00:23:52,770
and but the point is that for trendy

00:23:50,820 --> 00:23:55,980
stuff is not i triple e compliant so

00:23:52,770 --> 00:23:58,020
they just do it as you would do it I

00:23:55,980 --> 00:24:00,180
mean I I don't actually know about the

00:23:58,020 --> 00:24:03,390
background of that so I mean in reality

00:24:00,180 --> 00:24:05,730
from what I'm looking I can see there if

00:24:03,390 --> 00:24:08,910
my number is really infinite or not a

00:24:05,730 --> 00:24:11,370
number I I mean I'm screwed anyways and

00:24:08,910 --> 00:24:12,990
then I don't care about it if they're

00:24:11,370 --> 00:24:14,850
the sign is still correct or whatever

00:24:12,990 --> 00:24:16,680
that thing is doing so I just want to

00:24:14,850 --> 00:24:17,460
reside so I mean I have to take care of

00:24:16,680 --> 00:24:19,980
myself

00:24:17,460 --> 00:24:22,350
and also this is not in the idea of C++

00:24:19,980 --> 00:24:25,169
so that I don't pay for stuff I don't

00:24:22,350 --> 00:24:29,730
want so this is really not C++ mindset

00:24:25,169 --> 00:24:31,470
if you Pro it like that just a quick

00:24:29,730 --> 00:24:34,429
summary what I found in GCC saw this

00:24:31,470 --> 00:24:37,770
little coin GC basically was a call to a

00:24:34,429 --> 00:24:40,470
function it from the library of GCC

00:24:37,770 --> 00:24:42,450
which is doing the same so then I found

00:24:40,470 --> 00:24:44,250
out that they say actually there is a

00:24:42,450 --> 00:24:47,279
little option in CPCC which you can

00:24:44,250 --> 00:24:50,370
enable which called bath mats but only

00:24:47,279 --> 00:24:52,500
GCC has this option and actually if you

00:24:50,370 --> 00:24:55,380
enable that you get same performance for

00:24:52,500 --> 00:24:57,809
all of the implementations so at just

00:24:55,380 --> 00:25:00,120
one moment and so GCC fastest basically

00:24:57,809 --> 00:25:01,740
now whatever you do save complex naive

00:25:00,120 --> 00:25:04,860
expression template interested it's all

00:25:01,740 --> 00:25:08,039
the same so GCC is stirred it was the

00:25:04,860 --> 00:25:13,200
one that can can reach the perfect speed

00:25:08,039 --> 00:25:15,000
and so you should see without meds we've

00:25:13,200 --> 00:25:17,159
seen before and the other is like deep

00:25:15,000 --> 00:25:19,140
for so there is not such an option but

00:25:17,159 --> 00:25:21,870
just to get an overview of the

00:25:19,140 --> 00:25:35,850
comparison so yet your your question

00:25:21,870 --> 00:25:38,490
okay yeah yeah I would have checked that

00:25:35,850 --> 00:25:44,690
if I had it so I when I was working on

00:25:38,490 --> 00:25:44,690
the new site yeah yeah okay

00:25:55,360 --> 00:26:04,150
yeah yeah the point is it's not I mean

00:25:58,909 --> 00:26:06,470
this is it is kind of known it's for

00:26:04,150 --> 00:26:08,929
porting okay yet so I the question was

00:26:06,470 --> 00:26:12,620
there or the remark was that there is a

00:26:08,929 --> 00:26:14,450
option in this the c-in-c that you can

00:26:12,620 --> 00:26:15,860
disable enable that option by default

00:26:14,450 --> 00:26:20,809
and into compiler is it enabled by

00:26:15,860 --> 00:26:22,220
default so but the point is is all it

00:26:20,809 --> 00:26:25,340
first of all it's not really documented

00:26:22,220 --> 00:26:27,230
it's also not not you don't have that

00:26:25,340 --> 00:26:29,480
option in the compiler me some sound do

00:26:27,230 --> 00:26:32,149
it I'm down so it's you really have to

00:26:29,480 --> 00:26:34,940
pray and hope that it works and plus the

00:26:32,149 --> 00:26:37,309
overhead off I mean even if you're me

00:26:34,940 --> 00:26:39,970
that if you enable it the handcrafted

00:26:37,309 --> 00:26:42,559
version should be basically on purpose

00:26:39,970 --> 00:26:43,820
no there there's a naive version or the

00:26:42,559 --> 00:26:47,330
expression tablet version should be on

00:26:43,820 --> 00:26:51,049
par with this is an crafted but we don't

00:26:47,330 --> 00:26:55,820
get it speed unfortunately so okay no

00:26:51,049 --> 00:26:57,350
basically my conclusions so standards so

00:26:55,820 --> 00:26:59,659
on generate standard library is not

00:26:57,350 --> 00:27:02,539
cream lined for a number crunching code

00:26:59,659 --> 00:27:05,510
so you can do that but usually you have

00:27:02,539 --> 00:27:07,520
to do it on your own so for clang there

00:27:05,510 --> 00:27:08,750
is no such option I also from from the

00:27:07,520 --> 00:27:12,200
code you see there was no if there for

00:27:08,750 --> 00:27:13,909
anything and basically my room if you

00:27:12,200 --> 00:27:15,860
using complex numbers on Clank don't use

00:27:13,909 --> 00:27:20,059
that complex so if you want speed forget

00:27:15,860 --> 00:27:23,240
it so this is like not not use a bit GCC

00:27:20,059 --> 00:27:24,950
if you have GCC use fast math there's a

00:27:23,240 --> 00:27:26,510
compiler flag then you get pretty much

00:27:24,950 --> 00:27:29,029
really the best performance you can get

00:27:26,510 --> 00:27:30,919
of course you can always do this the

00:27:29,029 --> 00:27:32,360
next step what we doing simplifying the

00:27:30,919 --> 00:27:33,919
whole thing but I mean I didn't want to

00:27:32,360 --> 00:27:37,309
look into that just makes everything

00:27:33,919 --> 00:27:40,700
gets more complicated and complex form

00:27:37,309 --> 00:27:42,049
dependent and so in general also GCC

00:27:40,700 --> 00:27:43,789
state produces the best code especially

00:27:42,049 --> 00:27:45,679
if you enable that compiler flag and

00:27:43,789 --> 00:27:48,559
yeah for cross-platform basically do

00:27:45,679 --> 00:27:50,480
Burke your own so because and you and

00:27:48,559 --> 00:27:51,860
probably even using expression templates

00:27:50,480 --> 00:27:54,169
because if we have see as we have seen

00:27:51,860 --> 00:27:56,990
and Microsoft comparable still benefits

00:27:54,169 --> 00:27:58,340
from expression templates in general I

00:27:56,990 --> 00:28:00,620
would say the standard should be

00:27:58,340 --> 00:28:02,720
extended the i did with so the you don't

00:28:00,620 --> 00:28:04,580
pay for what you don't use so state

00:28:02,720 --> 00:28:06,780
complex should get like a little policy

00:28:04,580 --> 00:28:09,930
that you can specify you

00:28:06,780 --> 00:28:11,010
I tricky compliance or not and then you

00:28:09,930 --> 00:28:14,070
enable it and it should be this

00:28:11,010 --> 00:28:16,350
everybody for them just my point for

00:28:14,070 --> 00:28:31,110
that and yeah that's very good so thank

00:28:16,350 --> 00:28:35,430
you more questions I didn't show that

00:28:31,110 --> 00:28:37,650
it's so the question was um you didn't

00:28:35,430 --> 00:28:39,270
see where we're I took the advantage of

00:28:37,650 --> 00:28:41,070
the power expression template i mean

00:28:39,270 --> 00:28:42,090
what i thought was just a snippet of how

00:28:41,070 --> 00:28:43,560
you would implement it and my

00:28:42,090 --> 00:28:46,230
implementations like many many pages

00:28:43,560 --> 00:28:47,820
long so i also i had a boost proto

00:28:46,230 --> 00:28:50,160
version and then I had a handcrafted

00:28:47,820 --> 00:28:52,290
were in order just to see how that so my

00:28:50,160 --> 00:28:54,330
hand crafted expression time this way

00:28:52,290 --> 00:28:56,370
slightly faster than the proto version

00:28:54,330 --> 00:28:58,680
but basically both we're kind of

00:28:56,370 --> 00:29:01,680
performing the same but I didn't show

00:28:58,680 --> 00:29:02,850
that so this is really just if you are

00:29:01,680 --> 00:29:07,680
interested and can give you the code

00:29:02,850 --> 00:29:16,260
foot summary of what operations you

00:29:07,680 --> 00:29:17,700
combine yeah I mean I what I did is more

00:29:16,260 --> 00:29:19,700
or less a naive implementation of the

00:29:17,700 --> 00:29:23,310
expression temperature I didn't do any

00:29:19,700 --> 00:29:26,460
common just really come computing the

00:29:23,310 --> 00:29:28,560
real at once so if in the end I call

00:29:26,460 --> 00:29:31,320
real and then it computes the real part

00:29:28,560 --> 00:29:33,540
of the whole full expression in one step

00:29:31,320 --> 00:29:35,820
and then imaginary in one step instead

00:29:33,540 --> 00:29:37,590
of having all those intermediate real

00:29:35,820 --> 00:29:42,360
and imaginary parts in between so that's

00:29:37,590 --> 00:29:47,660
main difference there yeah another

00:29:42,360 --> 00:29:47,660
question okay then

00:30:01,119 --> 00:30:05,179
yeah yeah that's right so and the

00:30:03,590 --> 00:30:06,350
question of the remark was that it

00:30:05,179 --> 00:30:08,659
actually doesn't bring much in that

00:30:06,350 --> 00:30:11,480
example for that example actually the

00:30:08,659 --> 00:30:16,779
difference was wasn't that great but I

00:30:11,480 --> 00:30:21,889
didn't put it up maybe find that some

00:30:16,779 --> 00:30:23,029
number of summary so they actually had

00:30:21,889 --> 00:30:25,490
another test we had a much more

00:30:23,029 --> 00:30:31,850
complicated expression and so this is

00:30:25,490 --> 00:30:34,129
like the second row this is likely

00:30:31,850 --> 00:30:36,169
expression template column and there you

00:30:34,129 --> 00:30:37,909
see like four depending on the compiler

00:30:36,169 --> 00:30:39,799
you see actually a lot of benefit also

00:30:37,909 --> 00:30:43,070
for expression templates so twice the

00:30:39,799 --> 00:30:46,399
speed or seven times the speed or two

00:30:43,070 --> 00:30:48,110
terms so the if the expression gets even

00:30:46,399 --> 00:30:49,639
really more complicated so this was a

00:30:48,110 --> 00:30:52,549
really complicated expression there

00:30:49,639 --> 00:30:56,529
which I was testing and that then you

00:30:52,549 --> 00:30:56,529
get more benefit from the expression I

00:31:04,179 --> 00:31:08,869
so the question was around for what what

00:31:07,070 --> 00:31:10,879
did I try to be better and handcrafted

00:31:08,869 --> 00:31:13,700
handcrafted was just really as a

00:31:10,879 --> 00:31:16,759
benchmark was just a comparison so i

00:31:13,700 --> 00:31:21,379
hope the compiler should be as efficient

00:31:16,759 --> 00:31:26,809
as a handcrafted so there I didn't try

00:31:21,379 --> 00:31:28,100
to improve anything no no I didn't use

00:31:26,809 --> 00:31:30,139
any assembly at both the handcrafted

00:31:28,100 --> 00:31:31,999
basically is the C version kind of so

00:31:30,139 --> 00:31:33,710
how if you will castrate if you don't

00:31:31,999 --> 00:31:36,619
have here if you don't have if you don't

00:31:33,710 --> 00:31:37,850
have any kind of abstraction mechanisms

00:31:36,619 --> 00:31:41,360
in the language you would write it that

00:31:37,850 --> 00:31:44,769
way basically yeah so yeah okay learn

00:31:41,360 --> 00:31:44,769
one the one last question

00:31:49,110 --> 00:31:54,940
yeah I know I mean I didn't measure the

00:31:53,080 --> 00:31:57,790
very ends and odd compared all that kind

00:31:54,940 --> 00:32:00,070
of stuff I just did a lot of I but at

00:31:57,790 --> 00:32:01,690
least I bootstrap the the test so I was

00:32:00,070 --> 00:32:03,130
just running for the first and the

00:32:01,690 --> 00:32:05,350
second and the fourth I was like

00:32:03,130 --> 00:32:06,760
building a collection of all the tests

00:32:05,350 --> 00:32:07,960
and I was bootstrapping them and then I

00:32:06,760 --> 00:32:09,730
run them in different order and

00:32:07,960 --> 00:32:12,550
collecting the results and then I

00:32:09,730 --> 00:32:18,750
computed to the median and the mean from

00:32:12,550 --> 00:32:21,580
that so no no I really i changed the

00:32:18,750 --> 00:32:25,270
change of randomly choose at least get a

00:32:21,580 --> 00:32:27,010
little bit better statistics it so i

00:32:25,270 --> 00:32:31,350
would say then making space for the

00:32:27,010 --> 00:32:31,350

YouTube URL: https://www.youtube.com/watch?v=he-XVt1xIE0


