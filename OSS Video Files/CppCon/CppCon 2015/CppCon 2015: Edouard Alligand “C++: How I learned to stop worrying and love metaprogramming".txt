Title: CppCon 2015: Edouard Alligand “C++: How I learned to stop worrying and love metaprogramming"
Publication date: 2015-10-12
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Horrible software engineering technique conceived in the forge of Hell or the Only True Way of doing C++ in 2015, template metaprogramming and its cohort of companion techniques are sure to create animation in a group of programmers. 

What if we were to tell you that an actual software product, actually sold to real customers and in production for now several years has been built on it? What if we were to tell you that a lot of advanced template techniques helped us to build a better software faster? 

This talk is all about real life examples of template metaprogramming, why they are useful and when and how you could use them in your own projects.
— 
Edouard has more than thirteen years of professional experience in software engineering. After years hacking the kernel of various operating systems, Edouard founded Bureau 14, the home of the hyperscalable database quasardb. Combining an excellent knowledge of low level programming with a perverse love for template meta-programming, Edouard likes to come up with uncompromising solutions to seemingly impossible problems. He lives in Paris, France.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:03,810
welcome and thank you very much for

00:00:01,829 --> 00:00:07,080
coming here if you have the wrong room

00:00:03,810 --> 00:00:10,290
now is the time to flee this talk is

00:00:07,080 --> 00:00:14,099
going to be about meta programming it's

00:00:10,290 --> 00:00:17,609
a practical talk and the main concept of

00:00:14,099 --> 00:00:20,630
this talk is to tell you how I got into

00:00:17,609 --> 00:00:24,529
it because I'm a C++ programmer like you

00:00:20,630 --> 00:00:28,590
not a researcher and not a professor I

00:00:24,529 --> 00:00:31,109
was a bad student to be honest and the

00:00:28,590 --> 00:00:34,950
reason why I did programming meta

00:00:31,109 --> 00:00:37,559
programming they are practical and of

00:00:34,950 --> 00:00:40,399
course there's also the taste of maybe

00:00:37,559 --> 00:00:46,710
some time trying to do some puzzles but

00:00:40,399 --> 00:00:48,870
if I do my job bad I get fired or the

00:00:46,710 --> 00:00:50,520
company goes under or I don't know so

00:00:48,870 --> 00:00:54,390
there are very practical reason behind

00:00:50,520 --> 00:00:57,239
it if you think about meta programming

00:00:54,390 --> 00:01:02,370
you can think about people in a big room

00:00:57,239 --> 00:01:03,780
doing serious stuff like because

00:01:02,370 --> 00:01:10,170
programming is hard so meta programming

00:01:03,780 --> 00:01:16,590
must be meta hard right as you're going

00:01:10,170 --> 00:01:18,540
to up a technical guess with the French

00:01:16,590 --> 00:01:22,439
that technique doesn't always work as

00:01:18,540 --> 00:01:26,460
you expect it to work so how I got into

00:01:22,439 --> 00:01:30,060
it my background is I'm actually a

00:01:26,460 --> 00:01:32,700
kernel developer system programmer so my

00:01:30,060 --> 00:01:35,280
main tool was C for a while then I

00:01:32,700 --> 00:01:38,850
switched to C++ just to get this from

00:01:35,280 --> 00:01:44,130
typing and also because I like the

00:01:38,850 --> 00:01:46,590
generic approach of programming it was I

00:01:44,130 --> 00:01:50,040
think 10 years ago or something that in

00:01:46,590 --> 00:01:52,320
2006 some day I was working in Germany I

00:01:50,040 --> 00:01:55,320
was doing file system drivers for

00:01:52,320 --> 00:01:58,259
Windows NT and also files file system

00:01:55,320 --> 00:02:01,820
driver for FreeBSD and things related to

00:01:58,259 --> 00:02:03,600
a virtual memory management the

00:02:01,820 --> 00:02:05,040
constraint when you're working on this

00:02:03,600 --> 00:02:07,560
project is your software has to be

00:02:05,040 --> 00:02:08,970
correct obviously because every program

00:02:07,560 --> 00:02:13,030
on the operating system is relying on

00:02:08,970 --> 00:02:17,080
you and it has to be fast because

00:02:13,030 --> 00:02:19,240
so you have the two generally opposite

00:02:17,080 --> 00:02:25,000
constituents of having a correct and

00:02:19,240 --> 00:02:28,180
fast program and the point of the first

00:02:25,000 --> 00:02:29,890
contact I had with general and not

00:02:28,180 --> 00:02:31,959
generic programming metaprogramming is

00:02:29,890 --> 00:02:36,010
had a colleague told me about boost

00:02:31,959 --> 00:02:38,320
static assert you I was like because in

00:02:36,010 --> 00:02:42,250
system programming you have like tons of

00:02:38,320 --> 00:02:45,430
asserts in your code because you can't

00:02:42,250 --> 00:02:46,959
sometimes debug your progress so to test

00:02:45,430 --> 00:02:48,910
your hypothesis you put asserts

00:02:46,959 --> 00:02:51,130
everywhere like I think I should have

00:02:48,910 --> 00:02:55,000
memory actually think I should have

00:02:51,130 --> 00:02:56,590
stuff so he told me about booster you

00:02:55,000 --> 00:02:59,530
cathode and I said what's a booster you

00:02:56,590 --> 00:03:02,950
can cert it said it's an assertion at

00:02:59,530 --> 00:03:04,630
compile time and I said what the point I

00:03:02,950 --> 00:03:07,239
don't care about assertion a compile

00:03:04,630 --> 00:03:08,709
time he says yes you care imagine that

00:03:07,239 --> 00:03:12,400
you could check for the size of an

00:03:08,709 --> 00:03:15,070
integer and then I said whoa this

00:03:12,400 --> 00:03:17,799
awesome why it's awesome because very

00:03:15,070 --> 00:03:20,890
often with drivers you have like oh I

00:03:17,799 --> 00:03:22,810
think this device is little endian and I

00:03:20,890 --> 00:03:25,239
think my appendix system is began yet

00:03:22,810 --> 00:03:26,920
and actually I'm wrong and so we can

00:03:25,239 --> 00:03:29,049
start to check at compile time like

00:03:26,920 --> 00:03:31,180
macros and that kind of stuff and you

00:03:29,049 --> 00:03:34,239
have the feedback about your hypothesis

00:03:31,180 --> 00:03:36,220
when you compile which is immediate it's

00:03:34,239 --> 00:03:37,930
not even it's not before you run a test

00:03:36,220 --> 00:03:39,489
or you write a test it's when you

00:03:37,930 --> 00:03:42,280
program that you have a feedback and

00:03:39,489 --> 00:03:44,410
that's actually probably the first thing

00:03:42,280 --> 00:03:47,920
I did is to go back to my programs and

00:03:44,410 --> 00:03:50,590
do that kind of things and that's how I

00:03:47,920 --> 00:03:54,880
got started it's actually the first the

00:03:50,590 --> 00:03:58,150
easiest thing can do and ok so you get

00:03:54,880 --> 00:04:02,340
into you meet a program what do you do

00:03:58,150 --> 00:04:06,790
next so it was 10 years ago

00:04:02,340 --> 00:04:09,670
imagine that yeah boost Atticus all work

00:04:06,790 --> 00:04:11,920
very great and it's impressive because

00:04:09,670 --> 00:04:14,410
they even managed to have some sort of

00:04:11,920 --> 00:04:16,480
meaningful error message within template

00:04:14,410 --> 00:04:18,640
metaprogramming is like wow yeah they

00:04:16,480 --> 00:04:22,690
managed to have a feedback as you can

00:04:18,640 --> 00:04:24,880
see in C++ 11 you can even specify an

00:04:22,690 --> 00:04:26,770
arbitrary string we're going to see

00:04:24,880 --> 00:04:28,360
examples about checks you can do in your

00:04:26,770 --> 00:04:31,870
program and you are going to build from

00:04:28,360 --> 00:04:33,700
it we start from the checks then we will

00:04:31,870 --> 00:04:36,790
go to something more advanced like

00:04:33,700 --> 00:04:39,100
computing stuff at compile time and then

00:04:36,790 --> 00:04:41,680
we will write programs that generate

00:04:39,100 --> 00:04:43,600
programs that general programs that

00:04:41,680 --> 00:04:46,270
generate programs that at some point end

00:04:43,600 --> 00:04:53,170
up being a program that is run by the

00:04:46,270 --> 00:04:56,680
user what I do since 2008 I work on a

00:04:53,170 --> 00:04:59,350
database and again the constraint is to

00:04:56,680 --> 00:05:01,620
have something that works fast and it's

00:04:59,350 --> 00:05:04,630
reliable and it's very painful to debug

00:05:01,620 --> 00:05:07,000
like you have I don't know about report

00:05:04,630 --> 00:05:10,710
about it oh when we had 100 terabyte of

00:05:07,000 --> 00:05:15,730
data and we do this we have a bug okay

00:05:10,710 --> 00:05:16,870
try to reproduce that if I'm not going

00:05:15,730 --> 00:05:18,580
to talk really about the product you

00:05:16,870 --> 00:05:20,169
have a question about it you prefer to

00:05:18,580 --> 00:05:22,390
ask but this talk is not really about it

00:05:20,169 --> 00:05:25,390
but the contest is everything I'm going

00:05:22,390 --> 00:05:27,640
to talk about in stock is actually from

00:05:25,390 --> 00:05:31,180
this software project something that we

00:05:27,640 --> 00:05:32,919
did decided to do and we decided to do

00:05:31,180 --> 00:05:36,010
it because it was useful called project

00:05:32,919 --> 00:05:39,820
it reduced it reduced maintenance cost

00:05:36,010 --> 00:05:45,970
greatly we had less bugs we had very

00:05:39,820 --> 00:05:48,160
fast code and at no cost and we're going

00:05:45,970 --> 00:05:51,669
to see what no cost meaning one-time

00:05:48,160 --> 00:05:54,460
cost not the cost for required some

00:05:51,669 --> 00:05:57,130
dangers obviously so what do we do with

00:05:54,460 --> 00:05:58,990
this and what can you do with it so

00:05:57,130 --> 00:06:02,700
first thing as you can see checks went

00:05:58,990 --> 00:06:06,700
compile time checks and you it's

00:06:02,700 --> 00:06:08,350
concepts are coming ok concepts are even

00:06:06,700 --> 00:06:11,560
more advanced way of doing it

00:06:08,350 --> 00:06:12,940
but right now today you can do compile

00:06:11,560 --> 00:06:13,630
time checks with a tablet

00:06:12,940 --> 00:06:15,610
metaprogramming

00:06:13,630 --> 00:06:18,870
and something more advanced than just

00:06:15,610 --> 00:06:21,610
the size of an integer

00:06:18,870 --> 00:06:26,830
you can't generate constant at compile

00:06:21,610 --> 00:06:28,780
time like you can have something you

00:06:26,830 --> 00:06:32,740
know we will see a concrete example of

00:06:28,780 --> 00:06:34,690
this later you can have generate parser

00:06:32,740 --> 00:06:36,970
it's I should have been to your file

00:06:34,690 --> 00:06:39,400
Cousteau he talked about doing

00:06:36,970 --> 00:06:42,120
domain-specific languages there is the

00:06:39,400 --> 00:06:46,690
famous boost spirit library will use it

00:06:42,120 --> 00:06:51,420
and it's compiled time protocol change

00:06:46,690 --> 00:06:55,660
up I think might be moot is broken

00:06:51,420 --> 00:06:57,880
protocol generation and we have even our

00:06:55,660 --> 00:07:00,700
own serializer which is done on compile

00:06:57,880 --> 00:07:03,340
time that is we write the goal is to

00:07:00,700 --> 00:07:05,350
write a very small amount of code I have

00:07:03,340 --> 00:07:07,120
the compiler work for you because anyway

00:07:05,350 --> 00:07:15,340
in front we welcome the five days four

00:07:07,120 --> 00:07:17,920
years so the poem is just forget about

00:07:15,340 --> 00:07:22,390
what you think you know about meta

00:07:17,920 --> 00:07:24,310
programming today with I mean I'm

00:07:22,390 --> 00:07:27,160
working and we're working with visuals

00:07:24,310 --> 00:07:29,530
to do 2030 we're working with clang

00:07:27,160 --> 00:07:34,840
we're working with GCC we compile on

00:07:29,530 --> 00:07:38,350
freebsd linux mac OS windows 32-bit

00:07:34,840 --> 00:07:39,850
64-bit even our platform I mean we're

00:07:38,350 --> 00:07:41,590
talking about concrete whiskers it

00:07:39,850 --> 00:07:44,290
compiles everywhere it works everywhere

00:07:41,590 --> 00:07:49,450
and we have very very very small amount

00:07:44,290 --> 00:07:50,950
of default we see that we C++ 11 a lot

00:07:49,450 --> 00:07:54,490
happen in the language that makes it

00:07:50,950 --> 00:07:57,760
very easy and it's not longer about

00:07:54,490 --> 00:08:01,090
having tons of tons of an understandable

00:07:57,760 --> 00:08:03,850
error messages and it's doable and if

00:08:01,090 --> 00:08:05,830
there's only one thing I would like you

00:08:03,850 --> 00:08:07,210
to give today is that you go back and

00:08:05,830 --> 00:08:09,990
you say ok I'm going to try something

00:08:07,210 --> 00:08:13,020
today on my code with those techniques

00:08:09,990 --> 00:08:16,000
because it's possible it's easy and it's

00:08:13,020 --> 00:08:18,790
there's no the entry cost has been

00:08:16,000 --> 00:08:22,230
lowered and you're doing C++ already so

00:08:18,790 --> 00:08:28,770
you already used to do crazy stuff

00:08:22,230 --> 00:08:30,810
so yeah the compile-time no longer - no

00:08:28,770 --> 00:08:32,940
longer - we'll see about that

00:08:30,810 --> 00:08:35,460
going to also to talk about labor we

00:08:32,940 --> 00:08:37,650
that we've done with joel falco template

00:08:35,460 --> 00:08:40,950
metaprogramming library instant compiled

00:08:37,650 --> 00:08:43,830
time so it doesn't exist anymore yes if

00:08:40,950 --> 00:08:46,260
you use C++ oh three metaprogramming

00:08:43,830 --> 00:08:49,860
library yes it takes about two days to

00:08:46,260 --> 00:08:51,930
compile your code but now it's instant

00:08:49,860 --> 00:08:54,180
compiled time you go to spirit actually

00:08:51,930 --> 00:08:55,830
you go to every recent version it's

00:08:54,180 --> 00:08:58,250
instant compile time so this is no

00:08:55,830 --> 00:09:01,290
longer a problem and even if it were

00:08:58,250 --> 00:09:04,470
compile time is cheap compared to

00:09:01,290 --> 00:09:07,470
development time so just not a good

00:09:04,470 --> 00:09:10,920
argument cut code complexity the yes

00:09:07,470 --> 00:09:14,880
this was a good point no longer the case

00:09:10,920 --> 00:09:17,010
I think Oh kids advanced C++ right I'm

00:09:14,880 --> 00:09:19,110
not going to say that yeah you it's the

00:09:17,010 --> 00:09:23,130
you should start with C++ with template

00:09:19,110 --> 00:09:25,710
metaprogramming no but it's manageable

00:09:23,130 --> 00:09:28,860
compiler support today I think it's fine

00:09:25,710 --> 00:09:30,360
even if you can switch to if you can

00:09:28,860 --> 00:09:33,450
have even if you're working on windows

00:09:30,360 --> 00:09:35,700
piece of studio you can do even 2013

00:09:33,450 --> 00:09:38,520
works fine and 2015 works even better

00:09:35,700 --> 00:09:40,920
and clang it's a table and the only

00:09:38,520 --> 00:09:44,310
thing that happened I can think if

00:09:40,920 --> 00:09:45,810
you're working like an embedded projects

00:09:44,310 --> 00:09:47,880
and your stick with the very old

00:09:45,810 --> 00:09:50,570
compiler then in that case okay I if you

00:09:47,880 --> 00:09:54,090
paint for you and you can't do it skills

00:09:50,570 --> 00:09:58,050
just go to my talk and you have the

00:09:54,090 --> 00:10:00,450
skills just invest time if you can on it

00:09:58,050 --> 00:10:02,130
but it's really manageable and then

00:10:00,450 --> 00:10:03,720
there was this known rational reasons

00:10:02,130 --> 00:10:05,850
about her have to go out of my comfort

00:10:03,720 --> 00:10:08,790
zone I it's not what I like blah blah

00:10:05,850 --> 00:10:10,970
blah doesn't matter just just do it it's

00:10:08,790 --> 00:10:10,970
cool

00:10:11,520 --> 00:10:19,080
what is it okay very quickly if

00:10:16,710 --> 00:10:21,810
programming is about writing code and by

00:10:19,080 --> 00:10:23,570
compiler I mean all the set of tools

00:10:21,810 --> 00:10:26,310
that are going to generate a program

00:10:23,570 --> 00:10:29,060
okay this is we could say this is

00:10:26,310 --> 00:10:29,060
programming

00:10:31,720 --> 00:10:35,689
metaprogramming then would be good

00:10:34,389 --> 00:10:39,740
compiler

00:10:35,689 --> 00:10:41,509
maybe could maybe not if you like it's a

00:10:39,740 --> 00:10:44,029
static assert that fails there is no

00:10:41,509 --> 00:10:47,449
college that the nation' instruction you

00:10:44,029 --> 00:10:53,749
sent to the compiler compiler again and

00:10:47,449 --> 00:10:58,339
then maybe binary nothing special and

00:10:53,749 --> 00:11:02,059
the question is why do it because then

00:10:58,339 --> 00:11:06,680
you could say that if this is better

00:11:02,059 --> 00:11:11,029
than this right why why make things

00:11:06,680 --> 00:11:17,209
harder and there are actually real

00:11:11,029 --> 00:11:18,079
reasons because the compiler is more

00:11:17,209 --> 00:11:20,329
clever than you are

00:11:18,079 --> 00:11:23,720
I'm not trying to insult you in any way

00:11:20,329 --> 00:11:25,040
but it knows everything it that it's not

00:11:23,720 --> 00:11:31,540
possible you know everything that it

00:11:25,040 --> 00:11:34,939
knows it optimizes better it's not lazy

00:11:31,540 --> 00:11:37,579
that is if you have to generate the code

00:11:34,939 --> 00:11:39,410
that takes 100 of remember structure of

00:11:37,579 --> 00:11:42,170
100 members are you're going to say I'm

00:11:39,410 --> 00:11:45,079
not going to type all of this and it

00:11:42,170 --> 00:11:47,779
does it for you it will not do mistakes

00:11:45,079 --> 00:11:48,410
like typos there is no typos in meta

00:11:47,779 --> 00:11:50,420
programming

00:11:48,410 --> 00:11:52,879
well there is typos in your meta program

00:11:50,420 --> 00:11:54,889
but and once it's right it will not do

00:11:52,879 --> 00:11:58,480
typos because Oh at some point I'm was

00:11:54,889 --> 00:12:01,069
wrong and I did it's not the way that my

00:11:58,480 --> 00:12:08,240
function is called or anything doesn't

00:12:01,069 --> 00:12:10,430
happen and the question is actually

00:12:08,240 --> 00:12:14,059
makes you more efficient that is if you

00:12:10,430 --> 00:12:16,250
sum the time do you spend learning meta

00:12:14,059 --> 00:12:18,769
programming and then the time you go

00:12:16,250 --> 00:12:21,110
faster we after is it worth it like if

00:12:18,769 --> 00:12:23,809
it takes ten years to go ten percent

00:12:21,110 --> 00:12:26,089
faster of course not worth it but it's

00:12:23,809 --> 00:12:27,949
not a lot of at the end of the talk you

00:12:26,089 --> 00:12:31,040
will be able to write a small metal

00:12:27,949 --> 00:12:33,529
programs I assure you you go out of

00:12:31,040 --> 00:12:36,230
there and you'll be able to do it so

00:12:33,529 --> 00:12:38,809
it's one hour and okay well maybe a

00:12:36,230 --> 00:12:42,679
little bit more because then it doesn't

00:12:38,809 --> 00:12:44,030
work like in the talk what happened what

00:12:42,679 --> 00:12:46,820
what's it

00:12:44,030 --> 00:12:49,040
nads magic trick check you know you

00:12:46,820 --> 00:12:50,690
watch tutorial video and the guy says

00:12:49,040 --> 00:12:51,200
yeah so you want to learn to play the

00:12:50,690 --> 00:12:54,620
guitar

00:12:51,200 --> 00:12:58,300
and he does this this and you try to so

00:12:54,620 --> 00:13:03,410
it doesn't work so you see it's easy and

00:12:58,300 --> 00:13:05,840
actually my ID is concept the philosophy

00:13:03,410 --> 00:13:08,450
behind is is everything a computer is

00:13:05,840 --> 00:13:10,490
able to do you should not do because

00:13:08,450 --> 00:13:12,560
your job is to instruct the compiler the

00:13:10,490 --> 00:13:15,650
computer to do work it's not to do the

00:13:12,560 --> 00:13:18,260
work compiler can do and everything the

00:13:15,650 --> 00:13:21,170
compiler kill the computer can do Jerry

00:13:18,260 --> 00:13:23,470
does it faster and better than you to go

00:13:21,170 --> 00:13:26,090
back about in other things you don't

00:13:23,470 --> 00:13:28,000
with meta programming there are a lot of

00:13:26,090 --> 00:13:32,420
hints you're giving to the compiler that

00:13:28,000 --> 00:13:35,870
enables him to enables it yes I don't

00:13:32,420 --> 00:13:38,690
know to do very aggressive optimizations

00:13:35,870 --> 00:13:40,790
and each showed up in our code at the

00:13:38,690 --> 00:13:43,820
end of the talk as see about the most

00:13:40,790 --> 00:13:46,010
advanced stuff that we did it's a shame

00:13:43,820 --> 00:13:48,350
I realize now should have burnt marks in

00:13:46,010 --> 00:13:51,380
it about what we managed to do we have

00:13:48,350 --> 00:13:54,470
actually a serialization code that takes

00:13:51,380 --> 00:13:56,060
a structure it analyzed it and it

00:13:54,470 --> 00:13:57,950
generated the serialization could for it

00:13:56,060 --> 00:13:59,960
and if it detects that it doesn't have

00:13:57,950 --> 00:14:02,990
to do dynamic memory location it will

00:13:59,960 --> 00:14:05,600
only use a stack which is if you want to

00:14:02,990 --> 00:14:07,220
do it by hand it's not possible you

00:14:05,600 --> 00:14:09,050
would have a lot of ifs at one time like

00:14:07,220 --> 00:14:11,060
Oh in that kind of structure then I can

00:14:09,050 --> 00:14:14,660
do it generate the code at compile time

00:14:11,060 --> 00:14:18,260
and so it's super fast okay you want

00:14:14,660 --> 00:14:19,760
code I feel it okay so all my examples

00:14:18,260 --> 00:14:20,750
are based on the library we've done

00:14:19,760 --> 00:14:24,560
withdrawal

00:14:20,750 --> 00:14:28,310
it's called Grigor so what's a polygon

00:14:24,560 --> 00:14:31,250
it's a thief poor whatever you want to

00:14:28,310 --> 00:14:31,880
call it we have a lightning talk

00:14:31,250 --> 00:14:34,340
tomorrow

00:14:31,880 --> 00:14:39,320
and the library is available on github

00:14:34,340 --> 00:14:41,420
boost software license feel free to do

00:14:39,320 --> 00:14:43,430
whatever you want

00:14:41,420 --> 00:14:46,460
I used this library because it makes

00:14:43,430 --> 00:14:51,740
everything easier it's not really about

00:14:46,460 --> 00:14:55,430
to show off especially although maybe

00:14:51,740 --> 00:14:59,900
and it's very lightweight template

00:14:55,430 --> 00:15:02,960
metaprogramming library okay so the

00:14:59,900 --> 00:15:05,830
first thing we're going to talk example

00:15:02,960 --> 00:15:07,820
between a list it's not really a list

00:15:05,830 --> 00:15:11,720
mathematically speaking it's a list that

00:15:07,820 --> 00:15:16,040
if you want to be pedantic it exists so

00:15:11,720 --> 00:15:17,660
you write this in C++ what happens the

00:15:16,040 --> 00:15:19,790
compiler would say okay I'm going to

00:15:17,660 --> 00:15:21,320
generate the instruction to move the

00:15:19,790 --> 00:15:23,000
stack pointer make sure that you have

00:15:21,320 --> 00:15:25,220
some room and then I will going to feel

00:15:23,000 --> 00:15:28,430
the memory are we are with the values

00:15:25,220 --> 00:15:31,220
you gave me and that's when you run your

00:15:28,430 --> 00:15:34,810
program you have this in your memory so

00:15:31,220 --> 00:15:37,030
this is one time this is C++ what about

00:15:34,810 --> 00:15:39,500
metaprogramming template metaprogramming

00:15:37,030 --> 00:15:42,950
what is a list in terms of

00:15:39,500 --> 00:15:45,830
metaprogramming it's not a topo let's be

00:15:42,950 --> 00:15:48,320
clear about that it's a list of types

00:15:45,830 --> 00:15:52,970
what's the list of types it's just a

00:15:48,320 --> 00:15:55,850
type hope I'm not losing you it's just

00:15:52,970 --> 00:15:58,430
and the reason in memory is zero there

00:15:55,850 --> 00:16:01,220
is no instruction in your final code

00:15:58,430 --> 00:16:03,080
there is nothing only thing where it's

00:16:01,220 --> 00:16:05,270
going to happen is that the compiler is

00:16:03,080 --> 00:16:07,640
going when it compares your code to

00:16:05,270 --> 00:16:09,710
allocate a list of types and said okay

00:16:07,640 --> 00:16:11,360
you you declared this type okay I

00:16:09,710 --> 00:16:13,010
understand but then when it's going to

00:16:11,360 --> 00:16:16,400
generate your code what it's actually

00:16:13,010 --> 00:16:18,830
doing is nothing and the question you

00:16:16,400 --> 00:16:20,480
might be asking so what the point of why

00:16:18,830 --> 00:16:22,340
she what are you saying you think that

00:16:20,480 --> 00:16:24,770
you're going to write code that is

00:16:22,340 --> 00:16:28,640
useless and doesn't generate anything so

00:16:24,770 --> 00:16:34,040
how is it going to help me concrete

00:16:28,640 --> 00:16:36,590
example why you would want to have a

00:16:34,040 --> 00:16:39,320
collection of types so in this case it's

00:16:36,590 --> 00:16:42,170
a set not a list it's a set it's exactly

00:16:39,320 --> 00:16:47,300
like a list with the same difference

00:16:42,170 --> 00:16:51,700
between us to list and to least

00:16:47,300 --> 00:16:54,780
understood the set and what happens is

00:16:51,700 --> 00:16:58,200
where is it universal

00:16:54,780 --> 00:17:01,590
oh yeah you have to learn Russian to do

00:16:58,200 --> 00:17:03,330
the template metaprogramming so yeah

00:17:01,590 --> 00:17:04,800
that so you have to spend five years to

00:17:03,330 --> 00:17:06,810
learn Russian and that's why all these

00:17:04,800 --> 00:17:11,160
guys or these people are Russian or

00:17:06,810 --> 00:17:15,080
maybe sometimes French yeah you're

00:17:11,160 --> 00:17:17,250
afraid ah so you have a set of types and

00:17:15,080 --> 00:17:19,350
what you want to do you have a function

00:17:17,250 --> 00:17:20,940
and you want to say okay this is a

00:17:19,350 --> 00:17:24,270
generic function but I want to have a

00:17:20,940 --> 00:17:25,560
very specific explicit message so in

00:17:24,270 --> 00:17:28,190
this case what do you think you're do

00:17:25,560 --> 00:17:32,760
this is not correct what you're doing no

00:17:28,190 --> 00:17:34,920
it says and you don't want to have two

00:17:32,760 --> 00:17:37,290
hundred lines of arrows you want your

00:17:34,920 --> 00:17:40,200
program to stop immediately because you

00:17:37,290 --> 00:17:42,540
want it to say no I only want my

00:17:40,200 --> 00:17:45,990
function to work with the type I have

00:17:42,540 --> 00:17:50,910
set here and although it might be a

00:17:45,990 --> 00:17:53,220
little bit convoluted just see that as

00:17:50,910 --> 00:17:54,840
tool you have now in your toolbox keep

00:17:53,220 --> 00:17:56,850
that in memory and see then later how

00:17:54,840 --> 00:17:58,710
are we going to use it so you have a set

00:17:56,850 --> 00:18:00,630
of types and you want to function to

00:17:58,710 --> 00:18:04,620
make an error when it got something out

00:18:00,630 --> 00:18:06,930
of the list and believe me this kind of

00:18:04,620 --> 00:18:10,710
trick had to last because then you have

00:18:06,930 --> 00:18:12,750
you can do whatever message like oh of

00:18:10,710 --> 00:18:14,730
course I added a little joke here but

00:18:12,750 --> 00:18:16,320
you can have a message oh if you have

00:18:14,730 --> 00:18:18,150
this error it probably means that you

00:18:16,320 --> 00:18:21,180
forgot to declare the function somewhere

00:18:18,150 --> 00:18:25,500
else and it's 100 billion times better

00:18:21,180 --> 00:18:27,810
than a comment because nobody reads

00:18:25,500 --> 00:18:30,630
comments give you example of after about

00:18:27,810 --> 00:18:33,840
comments and the compiler doesn't

00:18:30,630 --> 00:18:35,520
understand comments so if you're not

00:18:33,840 --> 00:18:38,750
rigorous after commanding someone and

00:18:35,520 --> 00:18:43,590
you team some at some point is going to

00:18:38,750 --> 00:18:48,620
not update the comment you see is not

00:18:43,590 --> 00:18:52,050
dislike so again in the C++ 11 you have

00:18:48,620 --> 00:18:54,750
better tool kit for our types trades a

00:18:52,050 --> 00:18:56,970
tickly in the standard so YouTube asked

00:18:54,750 --> 00:18:59,100
toolkit that is if you just open your

00:18:56,970 --> 00:19:01,290
text editor you have your C++ 11

00:18:59,100 --> 00:19:02,790
compiler you don't need to include boost

00:19:01,290 --> 00:19:04,650
you don't need to include anything and

00:19:02,790 --> 00:19:06,600
you already have type traits which

00:19:04,650 --> 00:19:07,550
provides you with many many useful

00:19:06,600 --> 00:19:10,610
functions like

00:19:07,550 --> 00:19:15,920
I want to know if my type isn't ago in

00:19:10,610 --> 00:19:19,340
the circle and so like like we have is

00:19:15,920 --> 00:19:21,920
it need to go yes I know I need an

00:19:19,340 --> 00:19:24,050
integral type and you have integral

00:19:21,920 --> 00:19:27,890
constant to say oh okay you could do

00:19:24,050 --> 00:19:31,280
static constant int something to do the

00:19:27,890 --> 00:19:33,170
same thing just to show you the ticket

00:19:31,280 --> 00:19:35,960
and so you have your factory function

00:19:33,170 --> 00:19:37,520
with okay the factory function is to be

00:19:35,960 --> 00:19:40,490
useless in that case but just to show

00:19:37,520 --> 00:19:44,180
you what you could do so Han comments

00:19:40,490 --> 00:19:48,500
and template metaprogramming no that's a

00:19:44,180 --> 00:19:52,130
bit fast but we've seen what we can do

00:19:48,500 --> 00:19:54,200
with types so I guess all of you in your

00:19:52,130 --> 00:19:57,230
programs at some point you have magic

00:19:54,200 --> 00:19:59,540
values especially if you do audio or

00:19:57,230 --> 00:20:03,860
images at some point you have constants

00:19:59,540 --> 00:20:05,450
or whatever and in that case I wanted to

00:20:03,860 --> 00:20:07,340
do something simple is like factor in

00:20:05,450 --> 00:20:09,530
five say at some point you start your

00:20:07,340 --> 00:20:12,440
project and you say okay the magic value

00:20:09,530 --> 00:20:14,990
is factor of five I will make 120 factor

00:20:12,440 --> 00:20:17,360
five and you put a comment because

00:20:14,990 --> 00:20:20,270
you're good programmer and you want to

00:20:17,360 --> 00:20:22,010
the people working with you to to know

00:20:20,270 --> 00:20:23,720
that and then somewhere later you

00:20:22,010 --> 00:20:26,330
realize oh no it's not the correct value

00:20:23,720 --> 00:20:29,570
the current value is factor of six but

00:20:26,330 --> 00:20:32,090
you forgot to update the current and so

00:20:29,570 --> 00:20:36,290
two years later there's burg someone

00:20:32,090 --> 00:20:38,120
wizard says but what no seven but what's

00:20:36,290 --> 00:20:40,490
the good value so someone is going to

00:20:38,120 --> 00:20:42,380
spend maybe lose a couple of hours just

00:20:40,490 --> 00:20:45,650
to understand waste but maybe it's not

00:20:42,380 --> 00:20:52,250
there but wouldn't be better if you

00:20:45,650 --> 00:20:54,890
could just write this because if you do

00:20:52,250 --> 00:20:57,590
this assuming that your factorial

00:20:54,890 --> 00:21:00,160
function is correct then there is no

00:20:57,590 --> 00:21:02,360
error you don't even need a comment and

00:21:00,160 --> 00:21:03,020
I'm not saying that you should not come

00:21:02,360 --> 00:21:05,570
at your code

00:21:03,020 --> 00:21:06,890
I mean comments are good but it's even

00:21:05,570 --> 00:21:08,690
better when you don't have to because

00:21:06,890 --> 00:21:11,420
it's absolutely obvious what it does in

00:21:08,690 --> 00:21:12,620
that case it's okay my value

00:21:11,420 --> 00:21:15,020
I read the code let's say I'm Lea

00:21:12,620 --> 00:21:17,180
bugging the code I have no idea what's

00:21:15,020 --> 00:21:20,250
about okay so the magic is factor of six

00:21:17,180 --> 00:21:23,130
okay fine and when you want to change

00:21:20,250 --> 00:21:26,370
you don't even have to either be math

00:21:23,130 --> 00:21:29,720
genius or use pocket calculators

00:21:26,370 --> 00:21:32,340
okay now the good value is factor seven

00:21:29,720 --> 00:21:35,540
just change one value in its correct

00:21:32,340 --> 00:21:38,010
no possibility for error and it's again

00:21:35,540 --> 00:21:39,810
the whole idea of template

00:21:38,010 --> 00:21:43,070
metaprogramming is just to have a seed

00:21:39,810 --> 00:21:47,370
and let the compiler grow the tree

00:21:43,070 --> 00:21:49,680
that's why I had tree image further it's

00:21:47,370 --> 00:21:52,530
you what you do is just design the cedar

00:21:49,680 --> 00:21:54,990
say okay I want you to do this and this

00:21:52,530 --> 00:21:57,000
but I don't care about how you do it

00:21:54,990 --> 00:21:59,460
its job of the compiler it's my IDE just

00:21:57,000 --> 00:22:02,400
do it so how to program a factory

00:21:59,460 --> 00:22:04,830
function to do template metaprogramming

00:22:02,400 --> 00:22:06,690
is i think you have to understand two

00:22:04,830 --> 00:22:09,510
concepts the first is different between

00:22:06,690 --> 00:22:11,490
compile-time and run-time so we saw that

00:22:09,510 --> 00:22:14,070
with the lists so what's the difference

00:22:11,490 --> 00:22:17,070
between a list of values and a list of

00:22:14,070 --> 00:22:19,260
types and then it's an to understand

00:22:17,070 --> 00:22:20,940
recursion but since you're programmers

00:22:19,260 --> 00:22:24,630
you should somehow understand recursion

00:22:20,940 --> 00:22:27,800
you have this you could you have all the

00:22:24,630 --> 00:22:32,730
intellectual tricky to do it

00:22:27,800 --> 00:22:36,180
so in that case recursion is okay factor

00:22:32,730 --> 00:22:41,430
we all agree that it's a way to define

00:22:36,180 --> 00:22:43,530
it so it's template and it's I'm going

00:22:41,430 --> 00:22:47,670
to multiply with the value means the

00:22:43,530 --> 00:22:51,360
values 1 and at some point I have to say

00:22:47,670 --> 00:22:53,990
when do I end my recursion and to end

00:22:51,360 --> 00:23:01,110
the recursion what you have you use

00:22:53,990 --> 00:23:02,730
template oh yes so you just say ok for 0

00:23:01,110 --> 00:23:07,080
I want you to do something different

00:23:02,730 --> 00:23:10,290
for you I want you to reach n1 and just

00:23:07,080 --> 00:23:14,210
to show you that I said a lot of things

00:23:10,290 --> 00:23:16,530
earlier about o it compile instant leads

00:23:14,210 --> 00:23:22,460
do you see a cut you don't see anything

00:23:16,530 --> 00:23:25,700
ok it's going to be dessert studio 2013

00:23:22,460 --> 00:23:33,320
suggest a crappy laptop

00:23:25,700 --> 00:23:35,630
going to be five a thing okay so it's

00:23:33,320 --> 00:23:39,230
absolutely not what I want to do I don't

00:23:35,630 --> 00:23:45,559
know what it's doing what did I do

00:23:39,230 --> 00:23:48,139
it says we compile yes so just loading

00:23:45,559 --> 00:23:50,360
and you see it's very fast it's not like

00:23:48,139 --> 00:23:52,190
oh I'm going to include a lot of stuff

00:23:50,360 --> 00:23:55,220
and I probably think it's going to be up

00:23:52,190 --> 00:24:01,630
see it's just so it's a very simple

00:23:55,220 --> 00:24:01,630
program and I just funning not and also

00:24:03,010 --> 00:24:17,630
so you see it's very fast it's easy to

00:24:06,139 --> 00:24:25,909
read no include except toys I think yes

00:24:17,630 --> 00:24:28,059
so very very simple and so if you work

00:24:25,909 --> 00:24:32,720
with version earlier than visuals to

00:24:28,059 --> 00:24:35,990
2013 you might want to a couple of rough

00:24:32,720 --> 00:24:37,600
edges if you have used GCC and clang you

00:24:35,990 --> 00:24:40,730
will have absolutely no problem at all

00:24:37,600 --> 00:24:41,919
this is a very simple template

00:24:40,730 --> 00:24:44,510
metaprogramming

00:24:41,919 --> 00:24:46,220
let's do let's see something a bit more

00:24:44,510 --> 00:24:48,440
advanced

00:24:46,220 --> 00:24:51,500
this is a typical interview question at

00:24:48,440 --> 00:24:54,500
a quasi db4 by by the way like can you

00:24:51,500 --> 00:24:57,980
do some general

00:24:54,500 --> 00:25:01,490
let's do type manipulation list

00:24:57,980 --> 00:25:05,110
manipulation at compile time so you saw

00:25:01,490 --> 00:25:08,870
that we have type of list a list of time

00:25:05,110 --> 00:25:13,490
but the type of list is actually list of

00:25:08,870 --> 00:25:15,320
time what about I want to write the code

00:25:13,490 --> 00:25:20,740
that say I want the last element in my

00:25:15,320 --> 00:25:20,740
list of types is it difficult to do so

00:25:21,610 --> 00:25:27,740
you have what you can do is actually if

00:25:25,220 --> 00:25:29,480
you've done a little bit of functional

00:25:27,740 --> 00:25:32,899
programming it's like popping the head

00:25:29,480 --> 00:25:36,409
at every precaution until you which list

00:25:32,899 --> 00:25:37,730
which has only one element in Bregan

00:25:36,409 --> 00:25:39,870
that's how it's implemented we have a

00:25:37,730 --> 00:25:42,480
trick I'm not going to show you

00:25:39,870 --> 00:25:44,160
darkus thing because as you can see this

00:25:42,480 --> 00:25:45,480
if you have a very large list then

00:25:44,160 --> 00:25:48,360
you're going to ask the compiler to

00:25:45,480 --> 00:25:51,750
create a type for every mean is going to

00:25:48,360 --> 00:25:54,000
recurse we have a trick and we're going

00:25:51,750 --> 00:25:59,250
to make it faster but even that is very

00:25:54,000 --> 00:26:03,330
fast and to go back at just a site side

00:25:59,250 --> 00:26:05,100
set aside why is it faster now to do

00:26:03,330 --> 00:26:08,250
template metaprogramming why it compiles

00:26:05,100 --> 00:26:14,429
faster a new opinion why why do you

00:26:08,250 --> 00:26:18,000
think sundar leads faster I think it's

00:26:14,429 --> 00:26:21,660
because it's not I think I changed the

00:26:18,000 --> 00:26:24,929
reason it's because of variadic because

00:26:21,660 --> 00:26:27,000
it's not macro tweak anymore you

00:26:24,929 --> 00:26:28,470
actually it's actually the compiler

00:26:27,000 --> 00:26:30,330
reading you could and understand exactly

00:26:28,470 --> 00:26:33,990
what you're doing it's no longer

00:26:30,330 --> 00:26:36,690
generating like hundreds and hundreds of

00:26:33,990 --> 00:26:39,630
line of C++ and then compiling it it's

00:26:36,690 --> 00:26:41,490
reading the C++ you're doing oh okay

00:26:39,630 --> 00:26:43,590
you're doing variadic okay understand oh

00:26:41,490 --> 00:26:45,870
I'm good it's very fast now that's why

00:26:43,590 --> 00:26:49,950
it's so fast if you do the same example

00:26:45,870 --> 00:26:51,960
that we did with boost NPR it's just

00:26:49,950 --> 00:26:54,179
slower not because boost MPL is poorly

00:26:51,960 --> 00:26:56,880
written it's just because it's macros

00:26:54,179 --> 00:27:00,480
generation and so we has to go through

00:26:56,880 --> 00:27:04,170
all the time so this is how you get the

00:27:00,480 --> 00:27:07,679
last element in the list just pop the

00:27:04,170 --> 00:27:12,860
head at every recursion like this so you

00:27:07,679 --> 00:27:17,550
see you have a type and then it has a

00:27:12,860 --> 00:27:20,670
see it's not before from here and then

00:27:17,550 --> 00:27:25,890
it says okay I get to the next point

00:27:20,670 --> 00:27:28,830
just remove the head until I which list

00:27:25,890 --> 00:27:31,110
with only one element then the list with

00:27:28,830 --> 00:27:36,450
only one element the last element is my

00:27:31,110 --> 00:27:39,390
element nothing like how many lines six

00:27:36,450 --> 00:27:42,720
lines and you basically we implemented

00:27:39,390 --> 00:27:45,210
back the equivalent of back and front is

00:27:42,720 --> 00:27:48,210
obviously trivial because font is just

00:27:45,210 --> 00:27:51,809
like here you do if I have this kind of

00:27:48,210 --> 00:27:56,470
stuff then I return the head

00:27:51,809 --> 00:27:58,769
you just have your basic function for a

00:27:56,470 --> 00:28:04,419
list in meta programming language and

00:27:58,769 --> 00:28:06,850
very small amount of C++ so what

00:28:04,419 --> 00:28:10,659
happened is yes to go back to the

00:28:06,850 --> 00:28:12,899
conversations product templates now if

00:28:10,659 --> 00:28:16,000
you want to do a type which accepts

00:28:12,899 --> 00:28:19,830
verdict number of elements it's built in

00:28:16,000 --> 00:28:22,029
in the language no more dog tricks

00:28:19,830 --> 00:28:26,679
according to the well it's something

00:28:22,029 --> 00:28:30,970
about dick type yes clearly because when

00:28:26,679 --> 00:28:34,019
you can get values it changes a lot

00:28:30,970 --> 00:28:46,470
alias templates better traps rates and

00:28:34,019 --> 00:28:49,929
improve compilers what we did so far is

00:28:46,470 --> 00:28:56,009
interesting I think but is it really

00:28:49,929 --> 00:28:59,710
useful like you say okay it's nice sure

00:28:56,009 --> 00:29:01,240
sure it's nice can show that to my

00:28:59,710 --> 00:29:01,600
colleague and then be clever for five

00:29:01,240 --> 00:29:05,320
minutes

00:29:01,600 --> 00:29:07,870
but is it going to make your program

00:29:05,320 --> 00:29:11,649
better is it going to really give value

00:29:07,870 --> 00:29:13,690
to to you customers because that's what

00:29:11,649 --> 00:29:17,980
matters and customers use or whatever

00:29:13,690 --> 00:29:21,759
and let's take a typical pattern which

00:29:17,980 --> 00:29:24,669
is the current pattern which is a

00:29:21,759 --> 00:29:26,559
pattern I like personally actually no I

00:29:24,669 --> 00:29:29,049
don't like it that's why we're going to

00:29:26,559 --> 00:29:32,950
improve it so it's basically when you

00:29:29,049 --> 00:29:36,700
want to in our case we have the shell so

00:29:32,950 --> 00:29:38,379
you user types come in and you get you

00:29:36,700 --> 00:29:40,509
want to learn the comments that the user

00:29:38,379 --> 00:29:42,850
sends which can be anything you don't

00:29:40,509 --> 00:29:44,500
know so imagine if your server then you

00:29:42,850 --> 00:29:49,779
receive comments and you want to run it

00:29:44,500 --> 00:29:54,250
and every common is an object first

00:29:49,779 --> 00:29:56,710
problem is it's easy to forget things as

00:29:54,250 --> 00:29:59,889
you add comments it's the typical

00:29:56,710 --> 00:30:01,389
pattern when you start with let's say

00:29:59,889 --> 00:30:03,159
you have your program you have five

00:30:01,389 --> 00:30:04,180
comments but of course with the last

00:30:03,159 --> 00:30:07,390
program you're going to

00:30:04,180 --> 00:30:09,310
more and more comment so it's typical

00:30:07,390 --> 00:30:11,290
button when you when you add comments

00:30:09,310 --> 00:30:13,630
you waste your time because oh yeah I

00:30:11,290 --> 00:30:15,490
forgot to change this line and yeah I

00:30:13,630 --> 00:30:18,010
have to inherit from this interface oh

00:30:15,490 --> 00:30:20,200
yeah okay fine

00:30:18,010 --> 00:30:23,190
and then what I don't like with this

00:30:20,200 --> 00:30:27,100
pattern is that it forces you to relate

00:30:23,190 --> 00:30:29,770
comments together which have maybe

00:30:27,100 --> 00:30:34,930
nothing to do except that they have to

00:30:29,770 --> 00:30:37,030
be run at some point which sucks and

00:30:34,930 --> 00:30:39,160
then if you want to make a list of the

00:30:37,030 --> 00:30:42,280
comments you have because let's say you

00:30:39,160 --> 00:30:44,820
want to say help and I want to have the

00:30:42,280 --> 00:30:47,710
list of all comments and type all the

00:30:44,820 --> 00:30:53,680
comments I have and print help and you

00:30:47,710 --> 00:30:54,100
have to do some work and this which I

00:30:53,680 --> 00:30:56,110
hate

00:30:54,100 --> 00:31:02,950
either way virtual the virtual keyword

00:30:56,110 --> 00:31:04,900
is forbidden no code base it's I think

00:31:02,950 --> 00:31:06,790
it's a bit weak and we can do much

00:31:04,900 --> 00:31:09,000
better than that and we're going to see

00:31:06,790 --> 00:31:14,530
with how with meta programming we can

00:31:09,000 --> 00:31:16,390
remove all this form so you come and

00:31:14,530 --> 00:31:18,370
don't have to inherit from anything that

00:31:16,390 --> 00:31:20,410
just have to have the same aspect they

00:31:18,370 --> 00:31:23,080
just have to provide you the user with

00:31:20,410 --> 00:31:25,180
it's a generic programming approach so

00:31:23,080 --> 00:31:27,160
you come in let's say in our case they

00:31:25,180 --> 00:31:29,910
just have to have one function execute

00:31:27,160 --> 00:31:32,860
and one can help with return the string

00:31:29,910 --> 00:31:36,610
for the help of the common and execute

00:31:32,860 --> 00:31:39,280
thus the actual work you group you

00:31:36,610 --> 00:31:43,710
commands in your list so every type is

00:31:39,280 --> 00:31:45,090
the list and then because you need some

00:31:43,710 --> 00:31:47,530
runtime

00:31:45,090 --> 00:31:50,500
polymorphism at some point let's say you

00:31:47,530 --> 00:31:52,930
use a variant and that's another

00:31:50,500 --> 00:31:58,180
powerful feature of meta programming is

00:31:52,930 --> 00:32:00,310
you do things only once like you have

00:31:58,180 --> 00:32:02,740
you command you write the comment you

00:32:00,310 --> 00:32:04,270
have your list yet there is only one

00:32:02,740 --> 00:32:06,580
place where you make the list of your

00:32:04,270 --> 00:32:08,410
comments and you transform that list

00:32:06,580 --> 00:32:11,890
into something else so here it's a

00:32:08,410 --> 00:32:16,480
variant could be anything you want and

00:32:11,890 --> 00:32:17,580
you need only once and we're going to

00:32:16,480 --> 00:32:20,430
see so you can

00:32:17,580 --> 00:32:23,150
say okay fine but if I make a new common

00:32:20,430 --> 00:32:28,140
the only thing you have to do is you

00:32:23,150 --> 00:32:29,910
right you come in like do it we write

00:32:28,140 --> 00:32:33,270
the common and then you just add it to

00:32:29,910 --> 00:32:35,580
the list and you can even do that in a

00:32:33,270 --> 00:32:37,830
way that if you forget to add it in the

00:32:35,580 --> 00:32:39,870
list it's not going to compile because

00:32:37,830 --> 00:32:42,150
the function executes that is going to

00:32:39,870 --> 00:32:44,160
take the comment that is run you have a

00:32:42,150 --> 00:32:48,870
static assertion that checks it's in the

00:32:44,160 --> 00:32:52,560
list so you you protect yourself from

00:32:48,870 --> 00:32:53,760
your own mistakes at compile time so

00:32:52,560 --> 00:32:56,520
which means you don't have to write

00:32:53,760 --> 00:33:01,320
tests right now you have to write a test

00:32:56,520 --> 00:33:04,310
and follow me so it selects lots lots of

00:33:01,320 --> 00:33:11,090
mistakes suppressed and you need to

00:33:04,310 --> 00:33:14,070
print all comments just do this and

00:33:11,090 --> 00:33:15,480
nothing has to do and I think what is

00:33:14,070 --> 00:33:17,670
very important is to have only one

00:33:15,480 --> 00:33:30,900
location to do things and do things only

00:33:17,670 --> 00:33:34,020
once okay that's good so let's do

00:33:30,900 --> 00:33:35,820
something more advanced like to maximum

00:33:34,020 --> 00:33:39,000
there's a talk just after mind about

00:33:35,820 --> 00:33:41,370
reflection I think it's good transition

00:33:39,000 --> 00:33:43,140
to the talk because we're also going to

00:33:41,370 --> 00:33:48,000
talk about transition reflection

00:33:43,140 --> 00:33:52,410
transition would it be nice if you just

00:33:48,000 --> 00:33:53,850
write a structure and it generates Jason

00:33:52,410 --> 00:33:55,530
and you don't have to write a single

00:33:53,850 --> 00:33:59,070
line of code in your structure you don't

00:33:55,530 --> 00:34:01,380
have to hear it you don't have to write

00:33:59,070 --> 00:34:04,220
anything just write the function and you

00:34:01,380 --> 00:34:06,870
have somewhere a function which says

00:34:04,220 --> 00:34:10,890
which jason could be anything else just

00:34:06,870 --> 00:34:12,900
for example could be binary data and it

00:34:10,890 --> 00:34:15,840
would just have somewhere function

00:34:12,900 --> 00:34:19,200
cogent json generate and it would take

00:34:15,840 --> 00:34:23,130
from transform you function and then

00:34:19,200 --> 00:34:28,920
generate the jason we have it

00:34:23,130 --> 00:34:30,630
Jew and the primary series Asian because

00:34:28,920 --> 00:34:33,060
some kind of serialization is it's

00:34:30,630 --> 00:34:35,430
always either intrusive that is you have

00:34:33,060 --> 00:34:37,320
to add inside your structure a function

00:34:35,430 --> 00:34:39,810
that says okay transform into something

00:34:37,320 --> 00:34:41,940
or you have to eat white a generic

00:34:39,810 --> 00:34:44,640
function like outside of your structure

00:34:41,940 --> 00:34:46,380
and it's always back to the same problem

00:34:44,640 --> 00:34:48,360
we have with the common patterns you

00:34:46,380 --> 00:34:50,550
forget to do something you have to we do

00:34:48,360 --> 00:34:53,000
the same thing over and over again you

00:34:50,550 --> 00:34:56,370
can fall easily forget for example you

00:34:53,000 --> 00:34:58,890
create a new structure and you forget to

00:34:56,370 --> 00:35:02,580
write the serialization comment or you

00:34:58,890 --> 00:35:04,080
wrote it wrong and if you don't because

00:35:02,580 --> 00:35:05,940
if you think about it it's really just

00:35:04,080 --> 00:35:07,980
about listing the members and

00:35:05,940 --> 00:35:12,390
recursively passing them and just

00:35:07,980 --> 00:35:15,060
generating the code so today what you

00:35:12,390 --> 00:35:18,330
can do to do that is to have a user

00:35:15,060 --> 00:35:23,160
library like booze fission booze fission

00:35:18,330 --> 00:35:25,230
ads compile time introspection because

00:35:23,160 --> 00:35:27,530
introspection the problem is if you have

00:35:25,230 --> 00:35:31,230
run time introspection then it's costly

00:35:27,530 --> 00:35:32,520
because if you're doing C++ it's very

00:35:31,230 --> 00:35:35,340
likely that you care a lot about

00:35:32,520 --> 00:35:38,910
performance and you care maybe a lot so

00:35:35,340 --> 00:35:40,740
about memory footprint so with the boost

00:35:38,910 --> 00:35:43,110
version what you do is it's going to

00:35:40,740 --> 00:35:45,810
generate all the boilerplate required

00:35:43,110 --> 00:35:49,800
and then you can iterate on the member

00:35:45,810 --> 00:35:51,840
of the structure so when you think that

00:35:49,800 --> 00:35:53,580
you can iterate on the members of the

00:35:51,840 --> 00:35:55,140
structure then you realize that you're

00:35:53,580 --> 00:35:59,210
very close to your goal of writing

00:35:55,140 --> 00:36:03,470
generic serialization functions and

00:35:59,210 --> 00:36:10,320
perfect civilization would be that it's

00:36:03,470 --> 00:36:15,120
extremely fast that the code generated

00:36:10,320 --> 00:36:16,830
is extremely optimized because with

00:36:15,120 --> 00:36:19,770
template metaprogramming what you can do

00:36:16,830 --> 00:36:21,240
is you remove a lot of if because at

00:36:19,770 --> 00:36:24,030
compile time you know exactly what you

00:36:21,240 --> 00:36:25,080
have so if you know what you have you

00:36:24,030 --> 00:36:27,090
don't have to check it at runtime

00:36:25,080 --> 00:36:30,510
everything you do at compile time you'll

00:36:27,090 --> 00:36:31,890
have to do it at runtime provided that

00:36:30,510 --> 00:36:34,070
the compiler doesn't have a bug don't

00:36:31,890 --> 00:36:34,070
worry

00:36:35,060 --> 00:36:42,180
should be fine it will not allocate

00:36:38,880 --> 00:36:46,140
memory if not needed for example when

00:36:42,180 --> 00:36:48,860
you see realize an integer you know

00:36:46,140 --> 00:36:52,950
exactly how much memory you need because

00:36:48,860 --> 00:36:55,860
again you know if you integer is like

00:36:52,950 --> 00:36:57,660
four bytes large so you know exactly at

00:36:55,860 --> 00:36:59,910
the maximum how much memory you're going

00:36:57,660 --> 00:37:02,010
to need so you don't have to do a

00:36:59,910 --> 00:37:04,530
defensive programming like oh I'm going

00:37:02,010 --> 00:37:06,240
to allocate something read my object and

00:37:04,530 --> 00:37:07,800
know you know at compile time which

00:37:06,240 --> 00:37:09,300
memory you need so you can just read the

00:37:07,800 --> 00:37:13,320
first uh glue your stuff and you're done

00:37:09,300 --> 00:37:16,200
and the code is correct because you're

00:37:13,320 --> 00:37:19,020
going to spend some time to write the

00:37:16,200 --> 00:37:20,490
boilerplate to read your code but you're

00:37:19,020 --> 00:37:21,120
going to do it only once and when it's

00:37:20,490 --> 00:37:22,470
correct

00:37:21,120 --> 00:37:24,540
you're going to add earlier of the

00:37:22,470 --> 00:37:27,570
structure and going to be fine no error

00:37:24,540 --> 00:37:30,360
possible and then it's convenient

00:37:27,570 --> 00:37:32,880
because once you've done this the other

00:37:30,360 --> 00:37:34,580
people in your team they they don't

00:37:32,880 --> 00:37:37,740
really have to catch it must be magic

00:37:34,580 --> 00:37:39,090
you know I think the the best way to say

00:37:37,740 --> 00:37:41,010
that you've done something good about

00:37:39,090 --> 00:37:42,750
your library on your software is like

00:37:41,010 --> 00:37:45,480
when people use it it's magic they don't

00:37:42,750 --> 00:37:46,950
care they they just write the structure

00:37:45,480 --> 00:37:49,530
and they know it's going to be perfectly

00:37:46,950 --> 00:37:51,450
cellulite but oh yeah every two years

00:37:49,530 --> 00:37:53,790
someone's going to come to you with very

00:37:51,450 --> 00:37:56,430
obscure bags takes a lot of time to fix

00:37:53,790 --> 00:37:59,400
but it's concentrated in one location

00:37:56,430 --> 00:38:02,210
and the jokes is of course I have the

00:37:59,400 --> 00:38:07,050
time to show you how to do it today but

00:38:02,210 --> 00:38:08,880
you have all the blocks to see it's

00:38:07,050 --> 00:38:11,880
actually good exercise you can do try

00:38:08,880 --> 00:38:13,260
something very simple if I have some

00:38:11,880 --> 00:38:15,180
time at the end I have actually the

00:38:13,260 --> 00:38:17,310
source coding here I can show you but so

00:38:15,180 --> 00:38:25,160
these are the third you say stay until

00:38:17,310 --> 00:38:25,160
the end and a bit fast so conclusion

00:38:26,579 --> 00:38:36,309
so what would be the reason to do it or

00:38:29,980 --> 00:38:38,289
not do it I'm assuming that you can

00:38:36,309 --> 00:38:39,789
invest assuming that you start from zero

00:38:38,289 --> 00:38:40,269
that you know absolutely nothing about

00:38:39,789 --> 00:38:42,519
it

00:38:40,269 --> 00:38:44,380
that you really start funds you so of

00:38:42,519 --> 00:38:46,299
course there is some time investment

00:38:44,380 --> 00:38:50,589
that you have to do to learn a bit of

00:38:46,299 --> 00:38:52,720
the techniques and you have to you

00:38:50,589 --> 00:38:55,660
require modern compilers okay I'm

00:38:52,720 --> 00:38:57,670
assuming you have that there's a trap

00:38:55,660 --> 00:38:59,890
which is the complexity trap which is

00:38:57,670 --> 00:39:02,319
like when you try to do it in more

00:38:59,890 --> 00:39:03,130
clever than you are London's new thing

00:39:02,319 --> 00:39:05,680
is anything but

00:39:03,130 --> 00:39:08,230
oh it's fine and then you build things

00:39:05,680 --> 00:39:09,630
which are very complex especially when

00:39:08,230 --> 00:39:13,029
you start with template metaprogramming

00:39:09,630 --> 00:39:15,490
in the next slide I give you some tips I

00:39:13,029 --> 00:39:17,260
mean I've done spend wasted a lot of

00:39:15,490 --> 00:39:19,299
days doing oh yeah I could do it like

00:39:17,260 --> 00:39:21,670
this and tree there's always a simple

00:39:19,299 --> 00:39:23,769
way like you want when you discover a

00:39:21,670 --> 00:39:26,349
new tool you want to a new toy like this

00:39:23,769 --> 00:39:27,400
you want to do it everywhere which is

00:39:26,349 --> 00:39:29,680
not something you should do obviously

00:39:27,400 --> 00:39:34,150
because sometimes there is an obvious

00:39:29,680 --> 00:39:36,720
straightforward approach but I think if

00:39:34,150 --> 00:39:40,359
I go back I mean the project is now like

00:39:36,720 --> 00:39:43,119
six years old what did what did we gain

00:39:40,359 --> 00:39:46,359
by doing this by choosing this approach

00:39:43,119 --> 00:39:50,470
we started in 2008 using experimental

00:39:46,359 --> 00:39:52,539
C++ 11 compilers and back then I mean we

00:39:50,470 --> 00:39:53,079
had a lot of compiler crush so what did

00:39:52,539 --> 00:39:56,589
we get

00:39:53,079 --> 00:39:59,529
I think we gain the most is scalability

00:39:56,589 --> 00:40:01,299
like now we don't have the problem that

00:39:59,529 --> 00:40:01,869
the more you add code the more expensive

00:40:01,299 --> 00:40:06,750
it gets

00:40:01,869 --> 00:40:06,750
of course the code base grew of course

00:40:07,289 --> 00:40:12,940
it's it's it's a large software so it's

00:40:10,809 --> 00:40:17,380
difficult but like the serialization

00:40:12,940 --> 00:40:20,849
that kind of thinks yeah it's fine will

00:40:17,380 --> 00:40:24,700
you do it only once the performance

00:40:20,849 --> 00:40:26,410
performance yeah some aspects it give

00:40:24,700 --> 00:40:29,170
especially everything related to

00:40:26,410 --> 00:40:30,730
serialization all the checks everything

00:40:29,170 --> 00:40:33,190
you do at compile time you don't have to

00:40:30,730 --> 00:40:35,740
do runtime yeah I think it shows up

00:40:33,190 --> 00:40:37,299
there is a good library inside boost

00:40:35,740 --> 00:40:40,090
which is a boost

00:40:37,299 --> 00:40:43,720
meta state machine library it managed

00:40:40,090 --> 00:40:45,460
to generate extremely fast state

00:40:43,720 --> 00:40:47,740
machines because it relies on all the

00:40:45,460 --> 00:40:49,450
twigs and many others because it does

00:40:47,740 --> 00:40:52,330
everything at compile time it says ok so

00:40:49,450 --> 00:40:54,100
this is the state transition and ok I'm

00:40:52,330 --> 00:40:57,360
going to optimize everything and right

00:40:54,100 --> 00:41:00,250
immediately what you want and

00:40:57,360 --> 00:41:03,280
reliability with all those checks we

00:41:00,250 --> 00:41:04,930
have and the fact that less code you

00:41:03,280 --> 00:41:11,950
write the less likely you're going to

00:41:04,930 --> 00:41:16,180
make mistakes it's as simple as that so

00:41:11,950 --> 00:41:19,060
some tips to get started if you want to

00:41:16,180 --> 00:41:21,730
do get started into template

00:41:19,060 --> 00:41:25,030
metaprogramming just go for C++ 11 just

00:41:21,730 --> 00:41:27,820
make sure you do that because it

00:41:25,030 --> 00:41:29,560
comprised faster because you have you

00:41:27,820 --> 00:41:33,400
start to have a good set of libraries to

00:41:29,560 --> 00:41:38,070
do it it's more flexible with usings you

00:41:33,400 --> 00:41:40,060
can its the code is more compact and

00:41:38,070 --> 00:41:43,360
it's not because it's metaprogramming

00:41:40,060 --> 00:41:47,530
that it's difficult or hard just forget

00:41:43,360 --> 00:41:50,860
about that it's not a good way to to get

00:41:47,530 --> 00:41:54,840
into it if you just start with your

00:41:50,860 --> 00:41:59,580
program and you do simple checks like

00:41:54,840 --> 00:41:59,580
like we did at the beginning of the talk

00:42:00,390 --> 00:42:05,410
then it's safe because if your check is

00:42:03,280 --> 00:42:07,780
wrong then okay if you're going to have

00:42:05,410 --> 00:42:09,190
an assertion at compile time but it's

00:42:07,780 --> 00:42:12,340
not going to be dangerous for your code

00:42:09,190 --> 00:42:15,400
base and gives you the time to build up

00:42:12,340 --> 00:42:17,230
the scale like you start to do least

00:42:15,400 --> 00:42:19,480
check that my type is in the list and

00:42:17,230 --> 00:42:21,880
then I'm going to merge lists and then

00:42:19,480 --> 00:42:23,950
at some point you start to be good and

00:42:21,880 --> 00:42:25,750
you say ok now I'm ready to maybe do

00:42:23,950 --> 00:42:29,920
compile-time constant computations and

00:42:25,750 --> 00:42:31,690
then at some point you are being put in

00:42:29,920 --> 00:42:35,830
a room apart from the rest of the team

00:42:31,690 --> 00:42:37,150
and because he deemed special and people

00:42:35,830 --> 00:42:38,110
don't talk to you anymore and then

00:42:37,150 --> 00:42:40,260
you're ready to do template

00:42:38,110 --> 00:42:40,260
metaprogramming

00:42:42,900 --> 00:42:50,609
and remember that your meta program are

00:42:47,130 --> 00:42:52,949
just no more program bad habit to have

00:42:50,609 --> 00:42:55,859
is to say oh but it's obscure and I

00:42:52,949 --> 00:42:58,170
actually you know what's rewarding with

00:42:55,859 --> 00:43:01,049
template metaprogramming is when it

00:42:58,170 --> 00:43:03,359
compiles it means correct awesome right

00:43:01,049 --> 00:43:05,579
I mean all template metaprogramming I

00:43:03,359 --> 00:43:07,829
think is maybe one of the only library

00:43:05,579 --> 00:43:08,940
which when it compiles means correct

00:43:07,829 --> 00:43:11,130
because all the tests are done at

00:43:08,940 --> 00:43:13,199
compile time so it's extremely rewarding

00:43:11,130 --> 00:43:15,089
it's a bit of a fantasy of a C++

00:43:13,199 --> 00:43:16,170
programmer that the only thing you would

00:43:15,089 --> 00:43:18,239
have to do is to compile your program

00:43:16,170 --> 00:43:19,559
and with compile it means correct and

00:43:18,239 --> 00:43:22,410
you have nothing else to do correct

00:43:19,559 --> 00:43:24,539
assuming that you model your IDE etc and

00:43:22,410 --> 00:43:27,749
the specs are correct but it's what you

00:43:24,539 --> 00:43:30,119
want to do and I think in 20 years this

00:43:27,749 --> 00:43:32,400
is how we're going to program that most

00:43:30,119 --> 00:43:33,959
of our job is going to be make the

00:43:32,400 --> 00:43:39,239
program compiler and when it comprised

00:43:33,959 --> 00:43:43,739
it's done but you have to maintain that

00:43:39,239 --> 00:43:45,539
so don't just write obscure stuff that

00:43:43,739 --> 00:43:48,420
assuming that no one else is going to

00:43:45,539 --> 00:43:50,549
read them and make sure that it's

00:43:48,420 --> 00:43:55,289
actually usable and readable and

00:43:50,549 --> 00:43:59,279
maintainable whatever you want so the

00:43:55,289 --> 00:44:03,719
toolkit you know I don't know why I said

00:43:59,279 --> 00:44:07,019
clang personally I think it's maybe not

00:44:03,719 --> 00:44:09,269
the best compiler but it has it's maybe

00:44:07,019 --> 00:44:12,239
the one with the remember messages are

00:44:09,269 --> 00:44:14,119
the most obvious which is very useful

00:44:12,239 --> 00:44:18,739
when you do template metaprogramming

00:44:14,119 --> 00:44:21,119
also it has a lot of tools like you have

00:44:18,739 --> 00:44:24,930
compiled time debuggers the kind of

00:44:21,119 --> 00:44:27,779
things then inside the standards you

00:44:24,930 --> 00:44:30,420
have things like twits tuples I don't

00:44:27,779 --> 00:44:30,959
know what I put to this and at least did

00:44:30,420 --> 00:44:36,119
the slicer

00:44:30,959 --> 00:44:38,069
well boost NPL if you are stuck with all

00:44:36,119 --> 00:44:41,309
compilers sure you can use it's very

00:44:38,069 --> 00:44:42,840
powerful library boosts Hana it's not

00:44:41,309 --> 00:44:47,120
yet

00:44:42,840 --> 00:44:50,430
boost I think it's going to be in 161

00:44:47,120 --> 00:44:52,850
boost vision if you want to do like we

00:44:50,430 --> 00:44:55,440
did inspection and more powerful things

00:44:52,850 --> 00:44:58,350
this vision can be seen as the bridge

00:44:55,440 --> 00:45:01,110
between runtime and compile time like

00:44:58,350 --> 00:45:04,980
you have hybrid objects that a mixture

00:45:01,110 --> 00:45:09,180
of compile time in like you have can

00:45:04,980 --> 00:45:12,750
have topples you can have you can have

00:45:09,180 --> 00:45:15,750
map which takes us a key type which is

00:45:12,750 --> 00:45:18,390
interesting like you have a structure

00:45:15,750 --> 00:45:21,600
and you say give me the object the

00:45:18,390 --> 00:45:24,090
runtime object which match my type we

00:45:21,600 --> 00:45:27,150
can do the kind of things might sound a

00:45:24,090 --> 00:45:28,440
bit strange but just know that somewhere

00:45:27,150 --> 00:45:31,590
in your brain and the day you need it

00:45:28,440 --> 00:45:33,930
you said oh yeah awesome and sure feel

00:45:31,590 --> 00:45:36,510
free to have a look at the library we

00:45:33,930 --> 00:45:40,470
wrote do you have a lightning talk

00:45:36,510 --> 00:45:43,710
tomorrow night I think that's 8h

00:45:40,470 --> 00:45:50,430
something I don't know just knew I have

00:45:43,710 --> 00:45:52,590
to be somewhere tomorrow so yeah so next

00:45:50,430 --> 00:45:54,510
time that someone tells you yeah

00:45:52,590 --> 00:45:56,970
metaprogramming some of your things that

00:45:54,510 --> 00:46:01,140
today useless and I'm never going to use

00:45:56,970 --> 00:46:07,650
it my program because it's arcane and I

00:46:01,140 --> 00:46:08,820
think no not not anymore okay um maybe

00:46:07,650 --> 00:46:13,320
done no in denial

00:46:08,820 --> 00:46:16,020
it's also possible but my experience is

00:46:13,320 --> 00:46:21,390
that it's extremely useful and for the

00:46:16,020 --> 00:46:22,860
reasons I give so so if you have

00:46:21,390 --> 00:46:24,870
questions an answer by the way do you

00:46:22,860 --> 00:46:25,290
know where the reference to the title of

00:46:24,870 --> 00:46:30,690
my talk

00:46:25,290 --> 00:46:34,170
does anyone has any ID yes exactly dr.

00:46:30,690 --> 00:46:37,430
strangelove so do you guys have any

00:46:34,170 --> 00:46:37,430
question yes

00:46:47,089 --> 00:46:50,849
okay so the question is my experience is

00:46:49,770 --> 00:46:54,300
with metaprogramming

00:46:50,849 --> 00:46:57,780
the problem is to debug my code to make

00:46:54,300 --> 00:46:59,070
sure that I that I spend a lot of time

00:46:57,780 --> 00:47:00,900
because I don't understand what the

00:46:59,070 --> 00:47:03,030
compiler is telling me basically and

00:47:00,900 --> 00:47:04,950
because I have a lot of indirection and

00:47:03,030 --> 00:47:08,190
then I don't understand what's going on

00:47:04,950 --> 00:47:11,390
so in clang you have a lot of compile

00:47:08,190 --> 00:47:16,080
time debugger I have one tweak which is

00:47:11,390 --> 00:47:17,970
actually might sound silly is when you

00:47:16,080 --> 00:47:19,710
don't know what the type is by very

00:47:17,970 --> 00:47:21,060
often you're doing your program and at

00:47:19,710 --> 00:47:24,270
some point says no bla bla bla bla

00:47:21,060 --> 00:47:26,430
expected bla bla bla bla so what what

00:47:24,270 --> 00:47:29,430
you do is you take the object you have

00:47:26,430 --> 00:47:31,200
and you try to assign it to a car or an

00:47:29,430 --> 00:47:33,180
INT and then you're going to get an

00:47:31,200 --> 00:47:38,970
error message cannot assign exactly my

00:47:33,180 --> 00:47:41,180
type to int and then I okay I understand

00:47:38,970 --> 00:47:44,160
it helps you to go back to your problem

00:47:41,180 --> 00:47:46,140
I know there are a lot of playing

00:47:44,160 --> 00:47:49,290
debuggers compile-time get the burgers

00:47:46,140 --> 00:47:50,820
that allows you to somehow dump what is

00:47:49,290 --> 00:47:55,200
inside the compiler but I never used

00:47:50,820 --> 00:47:59,130
them what I do also is I do a heavy use

00:47:55,200 --> 00:48:01,650
of static a source especially on the

00:47:59,130 --> 00:48:03,119
bottom of your program helps you to have

00:48:01,650 --> 00:48:04,230
better error message because you can

00:48:03,119 --> 00:48:07,140
write anything you want in your

00:48:04,230 --> 00:48:13,339
associate however it's an answer your

00:48:07,140 --> 00:48:13,339
question yes

00:48:13,990 --> 00:48:29,560
so the question so there's a question is

00:48:26,890 --> 00:48:36,540
why not construct caustics per MSS

00:48:29,560 --> 00:48:39,660
because we just do 2030 yes you right

00:48:36,540 --> 00:48:43,890
this is the compiler we use in software

00:48:39,660 --> 00:48:46,510
I think most of our customer banks and

00:48:43,890 --> 00:48:48,040
although the service most of the time is

00:48:46,510 --> 00:48:51,040
server version of software is running on

00:48:48,040 --> 00:48:52,750
Linux or FreeBSD the client version is

00:48:51,040 --> 00:48:55,390
running on Windows so we cannot give up

00:48:52,750 --> 00:48:57,400
the visual studio so sorry yes but

00:48:55,390 --> 00:49:18,000
you're right context simplifies

00:48:57,400 --> 00:49:21,250
everything yes okay so the question is

00:49:18,000 --> 00:49:24,010
so the question is side-effects like the

00:49:21,250 --> 00:49:26,350
fine print magically what happens with

00:49:24,010 --> 00:49:29,080
my object size so like I said the object

00:49:26,350 --> 00:49:32,230
size doesn't change because you're not

00:49:29,080 --> 00:49:34,930
creating you're not creating values

00:49:32,230 --> 00:49:37,420
you're only creating types but however

00:49:34,930 --> 00:49:38,590
what happens is memory consumption of

00:49:37,420 --> 00:49:41,620
the compiler is going to greatly

00:49:38,590 --> 00:49:43,210
increase so what you may have is despite

00:49:41,620 --> 00:49:45,340
what everything I say because I spend my

00:49:43,210 --> 00:49:47,980
time lying is that actually your

00:49:45,340 --> 00:49:52,870
compilation time can grow or because

00:49:47,980 --> 00:49:55,870
you're going to squat use 64-bit version

00:49:52,870 --> 00:49:58,240
of the compilers it's just a must

00:49:55,870 --> 00:50:00,160
because you're going to hit the 2

00:49:58,240 --> 00:50:03,490
gigabytes limit of the compiler very

00:50:00,160 --> 00:50:08,380
equally at runtime

00:50:03,490 --> 00:50:12,850
you should have zero cost support side

00:50:08,380 --> 00:50:16,450
effects a side effects is if you do it

00:50:12,850 --> 00:50:18,970
wrong you can exponentially increase the

00:50:16,450 --> 00:50:22,840
complexity of your code so that's why

00:50:18,970 --> 00:50:25,120
you should start simple yeah so what

00:50:22,840 --> 00:50:26,490
side effect really carries suddenly your

00:50:25,120 --> 00:50:29,460
software doesn't compile anymore

00:50:26,490 --> 00:50:31,440
because you using 32-bit compilers and

00:50:29,460 --> 00:50:34,110
then it used to give us a forum and then

00:50:31,440 --> 00:50:40,770
it doesn't go on anymore that's the most

00:50:34,110 --> 00:50:45,360
obvious side effect I can take other

00:50:40,770 --> 00:50:47,690
questions no the question so thank you

00:50:45,360 --> 00:50:47,690

YouTube URL: https://www.youtube.com/watch?v=u_8MMuVFz_k


