Title: CppCon 2015: Timur Doumler “C++ in the Audio Industry”
Publication date: 2015-10-09
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Sound is an essential medium for human-computer interaction and vital for applications such as games and music production software. In the audio industry, C++ is the dominating programming language. This talk provides an insight into the patterns and tools that C++ developers in the audio industry rely on. There are interesting lessons to be learned from this domain that can be useful to every C++ developer.

Handling audio in real time presents interesting technical challenges. Techniques also used in other C++ domains have to be combined: real-time multithreading, lock-free programming, efficient DSP, SIMD, and low-latency hardware communication. C++ is the language of choice to tie all these requirements together. Clever leveraging of advanced C++ techniques, template metaprogramming, and the new C++11/14 standard makes these tasks more exciting than ever.
— 
Timur Doumler is Senior Software Developer at London-based technology company ROLI. He is working with Julian Storer to further develop JUCE, the leading cross-platform framework for creating audio applications that is used by hundreds of companies in the audio industry.

After five years of writing high-performance code in Fortran, C, and C++ for numerical simulations of the cosmic structure formation, Timur became committed to audio and music production software. Before joining ROLI, he worked on various projects at market-leading company Native Instruments, such as KONTAKT, the industry standard sampling platform used by the majority of music producers and composers for film score, games, and contemporary popular music.

Timur holds a PhD in astrophysics and is passionate about well-written code, modern C++ techniques, science-fiction, learning languages, and progressive rock music.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,339
all right everybody my name is Timur I'm

00:00:02,610 --> 00:00:10,380
work at london-based music tech company

00:00:05,339 --> 00:00:11,790
Rowley and yeah I had the idea to come

00:00:10,380 --> 00:00:14,849
here to talk a little bit about audio

00:00:11,790 --> 00:00:17,640
and music software and how we use C++ as

00:00:14,849 --> 00:00:20,490
a language so this talk is called

00:00:17,640 --> 00:00:25,109
superstars in the audio industry can

00:00:20,490 --> 00:00:30,179
everybody hear me so right yeah okay so

00:00:25,109 --> 00:00:31,679
I had this idea and then I was about to

00:00:30,179 --> 00:00:34,140
prepare some slides for the talk then I

00:00:31,679 --> 00:00:38,430
thought okay what could I talk about and

00:00:34,140 --> 00:00:41,160
I had like several things I could talk

00:00:38,430 --> 00:00:44,309
about so there's the real time aspect of

00:00:41,160 --> 00:00:46,469
audio when it comes to programming then

00:00:44,309 --> 00:00:49,020
there is if you generate audio you are

00:00:46,469 --> 00:00:50,579
typically doing math and DSP so you want

00:00:49,020 --> 00:00:54,050
that to be really fast and efficient

00:00:50,579 --> 00:00:56,340
then for example a trolli we do this

00:00:54,050 --> 00:00:59,520
seaboard it's essentially a keyboard

00:00:56,340 --> 00:01:00,930
with a 3d touch surface and there is an

00:00:59,520 --> 00:01:03,420
audio engine running on an embedded

00:01:00,930 --> 00:01:05,309
system in there so there's also very

00:01:03,420 --> 00:01:09,299
very interesting things that you could

00:01:05,309 --> 00:01:11,400
talk about that in this context also you

00:01:09,299 --> 00:01:13,860
want to do audio on different platforms

00:01:11,400 --> 00:01:15,330
on desktops on mobile phones and they're

00:01:13,860 --> 00:01:18,119
interesting cross-platform challenges

00:01:15,330 --> 00:01:20,250
there and also another thing if you want

00:01:18,119 --> 00:01:22,259
your audio to be fast there is the whole

00:01:20,250 --> 00:01:24,750
topic of zim D and vectorization and

00:01:22,259 --> 00:01:27,049
memory alignment and there's a few

00:01:24,750 --> 00:01:29,460
interesting things in the audio world

00:01:27,049 --> 00:01:31,110
about that and then I had all these

00:01:29,460 --> 00:01:32,400
things and then I figured out that okay

00:01:31,110 --> 00:01:33,990
if I'm going to talk about all of this

00:01:32,400 --> 00:01:37,560
I'm going to be to be talking for 10

00:01:33,990 --> 00:01:39,119
hours so I had to limit this talk to

00:01:37,560 --> 00:01:43,560
something and I thought okay what's the

00:01:39,119 --> 00:01:45,090
defining thing about audio which is

00:01:43,560 --> 00:01:46,820
different from most other use cases of

00:01:45,090 --> 00:01:49,860
C++ and I think that's really the

00:01:46,820 --> 00:01:51,329
real-time aspect of it so I'm going to

00:01:49,860 --> 00:01:53,670
talk about real-time programming and why

00:01:51,329 --> 00:01:56,820
that's different probably from other

00:01:53,670 --> 00:01:58,140
users of the language and if you want to

00:01:56,820 --> 00:01:59,520
do real-time programming you want to do

00:01:58,140 --> 00:02:01,469
lock-free programming as well so I'm

00:01:59,520 --> 00:02:05,640
going to talk about that and I'm going

00:02:01,469 --> 00:02:08,399
to show a few code examples so I'm going

00:02:05,640 --> 00:02:11,580
to start with introduction to what I

00:02:08,399 --> 00:02:13,379
mean by the audio industry and how

00:02:11,580 --> 00:02:13,860
actually audio is ripple sound is

00:02:13,379 --> 00:02:16,490
represent

00:02:13,860 --> 00:02:19,140
than C++ or in a c-plus application and

00:02:16,490 --> 00:02:20,670
then I'm going to talk about what why

00:02:19,140 --> 00:02:24,900
audio is real-time programming what it

00:02:20,670 --> 00:02:28,710
actually means and how you write code so

00:02:24,900 --> 00:02:30,390
that it's real time safe and so if you

00:02:28,710 --> 00:02:32,160
code examples about lock-free

00:02:30,390 --> 00:02:35,690
programming how you synchronize your

00:02:32,160 --> 00:02:37,980
threads lock-free in context for audio

00:02:35,690 --> 00:02:39,900
which will involve how do you share

00:02:37,980 --> 00:02:41,820
objects between different threads how do

00:02:39,900 --> 00:02:43,380
you exchange data between different

00:02:41,820 --> 00:02:45,690
threads if one of them is a real-time

00:02:43,380 --> 00:02:48,240
thread and a little bit about how to

00:02:45,690 --> 00:02:51,900
manage memory how to manage object

00:02:48,240 --> 00:02:54,840
lifetime and these kind of things so

00:02:51,900 --> 00:02:56,190
what's the audio industry probably

00:02:54,840 --> 00:03:01,920
different people have different

00:02:56,190 --> 00:03:04,140
definitions but so I think it's about

00:03:01,920 --> 00:03:07,650
people who use computers and computer

00:03:04,140 --> 00:03:10,880
software to produce music to record

00:03:07,650 --> 00:03:13,950
music to make sounds to compose music

00:03:10,880 --> 00:03:15,900
then there is this aspect of people who

00:03:13,950 --> 00:03:19,320
use computers like this guy here with

00:03:15,900 --> 00:03:22,260
the laptop to perform music life deejays

00:03:19,320 --> 00:03:25,260
performers musicians then there is this

00:03:22,260 --> 00:03:26,910
whole world of games and audio apps on

00:03:25,260 --> 00:03:30,299
desktop and mobile platforms for

00:03:26,910 --> 00:03:33,030
consumers multimedia apps then there is

00:03:30,299 --> 00:03:36,180
also science and art and creative coding

00:03:33,030 --> 00:03:38,580
where audio plays a big role and then

00:03:36,180 --> 00:03:42,269
also there are people who actually

00:03:38,580 --> 00:03:44,430
develop all the software for people who

00:03:42,269 --> 00:03:46,530
create musical instruments synthesizers

00:03:44,430 --> 00:03:49,470
and music software and hardware and this

00:03:46,530 --> 00:03:51,959
is the small as my domain I work on the

00:03:49,470 --> 00:03:54,450
juice framework which is a framework and

00:03:51,959 --> 00:03:56,940
application framework but also features

00:03:54,450 --> 00:03:59,730
a lot of audio for people who want to

00:03:56,940 --> 00:04:02,100
build applications with audio in them on

00:03:59,730 --> 00:04:05,489
different platforms so I'm a little bit

00:04:02,100 --> 00:04:07,799
biased towards providing tools for

00:04:05,489 --> 00:04:11,850
developers and also this whole audio

00:04:07,799 --> 00:04:13,739
production music world like having

00:04:11,850 --> 00:04:16,470
musical instruments this is the Seaboard

00:04:13,739 --> 00:04:19,079
here having synthesizers and audio

00:04:16,470 --> 00:04:21,570
software running so this is sort of a

00:04:19,079 --> 00:04:23,640
little bit my bias but I'm going to try

00:04:21,570 --> 00:04:24,960
to keep it a bit more generic nor too

00:04:23,640 --> 00:04:29,160
specific

00:04:24,960 --> 00:04:32,699
so um question who has ever here used

00:04:29,160 --> 00:04:37,740
actually audio a programmed actively C++

00:04:32,699 --> 00:04:40,919
for audio and sound things alright about

00:04:37,740 --> 00:04:42,330
half alright so maybe it's worth to do

00:04:40,919 --> 00:04:43,919
like a really quick introduction about

00:04:42,330 --> 00:04:47,370
for all the people who didn't raise

00:04:43,919 --> 00:04:51,900
their hands how audio actually works in

00:04:47,370 --> 00:04:53,610
C++ or in typical C++ program so audio

00:04:51,900 --> 00:04:56,210
essentially separate representation of

00:04:53,610 --> 00:04:58,020
sound waves so here's the sound wave and

00:04:56,210 --> 00:04:59,520
obviously we can represent this

00:04:58,020 --> 00:05:02,820
digitally we can manipulate sound

00:04:59,520 --> 00:05:04,259
digitally but the C + s language itself

00:05:02,820 --> 00:05:07,410
has no concept for it there is no

00:05:04,259 --> 00:05:09,360
concept of audio in the language so we

00:05:07,410 --> 00:05:12,090
have to use third-party libraries you

00:05:09,360 --> 00:05:12,860
have to use API s and we have to use the

00:05:12,090 --> 00:05:15,949
conventions

00:05:12,860 --> 00:05:19,169
offered by these API and libraries and

00:05:15,949 --> 00:05:23,430
sort of the the universe we are sort of

00:05:19,169 --> 00:05:25,289
in its defined by like a big stack of

00:05:23,430 --> 00:05:27,150
different components so essentially we

00:05:25,289 --> 00:05:29,909
have the sound waves that we can hear

00:05:27,150 --> 00:05:31,860
and then we have a microphone that can

00:05:29,909 --> 00:05:33,479
record them and then we have an audio

00:05:31,860 --> 00:05:35,820
digital converter and then it goes into

00:05:33,479 --> 00:05:38,039
a sound card and then we have some sort

00:05:35,820 --> 00:05:40,380
of driver for the sound card and some

00:05:38,039 --> 00:05:42,750
sort of API by which this driver talks

00:05:40,380 --> 00:05:44,220
to the operating system we have lots of

00:05:42,750 --> 00:05:46,320
different operating systems we have

00:05:44,220 --> 00:05:47,310
Windows Mac Linux we have on mobile we

00:05:46,320 --> 00:05:49,860
have iOS and Android

00:05:47,310 --> 00:05:52,830
you also have maybe implanted platforms

00:05:49,860 --> 00:05:54,270
and then all of these operating system

00:05:52,830 --> 00:06:00,110
the systems they also have their own

00:05:54,270 --> 00:06:02,639
stack of audio layers of Audio API s and

00:06:00,110 --> 00:06:05,550
at the end of it there's some API that's

00:06:02,639 --> 00:06:07,710
offered to to the user which you can use

00:06:05,550 --> 00:06:09,539
them to program your own audio app so

00:06:07,710 --> 00:06:11,039
and there are many different ones so

00:06:09,539 --> 00:06:12,539
apple offers Core Audio and Windows

00:06:11,039 --> 00:06:15,270
there are several ones so it's like a

00:06:12,539 --> 00:06:19,259
whole set of different in different

00:06:15,270 --> 00:06:21,300
api's and this is what your audio

00:06:19,259 --> 00:06:23,159
application is talking to to exchange

00:06:21,300 --> 00:06:24,840
audio data and also the other way around

00:06:23,159 --> 00:06:25,949
if you want to output audio it goes all

00:06:24,840 --> 00:06:27,900
the way the other direction through all

00:06:25,949 --> 00:06:29,720
this chain through some kind of speaker

00:06:27,900 --> 00:06:32,789
which actually transforms that to a

00:06:29,720 --> 00:06:34,349
audible audio signal and in the world of

00:06:32,789 --> 00:06:36,960
music production software we have

00:06:34,349 --> 00:06:37,979
actually an additional layer where

00:06:36,960 --> 00:06:40,430
we have something that's called a

00:06:37,979 --> 00:06:43,199
digital audio workstation or a door and

00:06:40,430 --> 00:06:45,300
there are several computing doors which

00:06:43,199 --> 00:06:49,849
people use to produce and record and mix

00:06:45,300 --> 00:06:51,990
software and then these doors offer you

00:06:49,849 --> 00:06:54,479
plugins so you can like a plugin

00:06:51,990 --> 00:06:57,030
interface so you can create synthesizers

00:06:54,479 --> 00:06:58,800
or audio effects and then these will be

00:06:57,030 --> 00:07:01,410
a plug-in essentially a dynamic library

00:06:58,800 --> 00:07:04,169
a dll that is loaded into that host and

00:07:01,410 --> 00:07:06,770
then to have these it's like you can

00:07:04,169 --> 00:07:08,880
imagine like Photoshop has plugins

00:07:06,770 --> 00:07:10,680
something like that except that there

00:07:08,880 --> 00:07:12,870
are different computing hosts and also

00:07:10,680 --> 00:07:15,360
actually different formats and SDKs for

00:07:12,870 --> 00:07:17,880
these plugins so you will be coding

00:07:15,360 --> 00:07:19,410
against one of these SDKs and then your

00:07:17,880 --> 00:07:21,539
audio plugin that actually produces

00:07:19,410 --> 00:07:24,900
sound or manipulate sound will talk

00:07:21,539 --> 00:07:26,490
through that API to some host and then

00:07:24,900 --> 00:07:30,060
it goes all the way to through all this

00:07:26,490 --> 00:07:31,710
chain so one of the things that we are

00:07:30,060 --> 00:07:33,930
doing with the juice framework as we try

00:07:31,710 --> 00:07:35,849
to offer solution where you don't

00:07:33,930 --> 00:07:37,560
actually have to worry about this stack

00:07:35,849 --> 00:07:39,810
because you can also imagine that on

00:07:37,560 --> 00:07:41,099
every operating system this all will

00:07:39,810 --> 00:07:43,889
just stack is different and all the

00:07:41,099 --> 00:07:45,449
conventions are different and so what

00:07:43,889 --> 00:07:47,039
you want to do is basically abstract all

00:07:45,449 --> 00:07:49,710
that away so that you can have a means

00:07:47,039 --> 00:07:52,349
of writing your app which is maybe a

00:07:49,710 --> 00:07:54,000
plug-in or a standalone app and do sound

00:07:52,349 --> 00:07:55,409
and do a graphical user interface and

00:07:54,000 --> 00:07:57,810
all the other things that you need for

00:07:55,409 --> 00:08:00,000
an application and then you have a

00:07:57,810 --> 00:08:03,900
framework underneath that hides all this

00:08:00,000 --> 00:08:05,370
complexity but here we are going to talk

00:08:03,900 --> 00:08:07,500
about the audio part so let's talk a

00:08:05,370 --> 00:08:11,430
little bit about all your data how its

00:08:07,500 --> 00:08:12,960
represented so essentially if you have

00:08:11,430 --> 00:08:15,389
like a waveform like this which is a

00:08:12,960 --> 00:08:18,150
little snippet of sound then to

00:08:15,389 --> 00:08:20,340
represent digitally you would sample it

00:08:18,150 --> 00:08:21,930
which means that you would at regular

00:08:20,340 --> 00:08:26,130
intervals would represent the value of

00:08:21,930 --> 00:08:27,479
that waveform with a number which is

00:08:26,130 --> 00:08:31,259
which are the little blobs here which

00:08:27,479 --> 00:08:33,300
are the audio samples and then you have

00:08:31,259 --> 00:08:35,159
a certain amount of samples per second

00:08:33,300 --> 00:08:38,760
that's the sample rate like typical one

00:08:35,159 --> 00:08:40,709
is four to 4,100 Hertz or samples per

00:08:38,760 --> 00:08:43,709
second this for example the sample rate

00:08:40,709 --> 00:08:45,650
used for pay and a CD and you can use

00:08:43,709 --> 00:08:48,000
also higher sample rate depending on

00:08:45,650 --> 00:08:50,490
depending on your use case I'm sure you

00:08:48,000 --> 00:08:51,960
all have seen this setting this

00:08:50,490 --> 00:08:54,180
sample rate setting somewhere in your

00:08:51,960 --> 00:08:57,210
software so this is how many samples per

00:08:54,180 --> 00:08:58,500
second you have and also this way of

00:08:57,210 --> 00:09:01,160
sampling sound has lots of implications

00:08:58,500 --> 00:09:03,240
as a snake with sampling theorem and

00:09:01,160 --> 00:09:07,140
aliasing and all these things which I'm

00:09:03,240 --> 00:09:08,520
not going to go into here but so you

00:09:07,140 --> 00:09:10,110
have samples you have a given amount of

00:09:08,520 --> 00:09:12,990
samples per second and then the other

00:09:10,110 --> 00:09:16,110
convention is usually in this kind of

00:09:12,990 --> 00:09:17,940
super fast software you would use floats

00:09:16,110 --> 00:09:20,040
in the range of minus one to one to

00:09:17,940 --> 00:09:21,990
represent that I mean there are many

00:09:20,040 --> 00:09:25,320
many other ways to do this but in this

00:09:21,990 --> 00:09:26,490
context of audio running on desktop more

00:09:25,320 --> 00:09:28,860
platforms typically you would have

00:09:26,490 --> 00:09:32,550
floats between minus one and one which

00:09:28,860 --> 00:09:35,820
gives you about 24 usable bits of

00:09:32,550 --> 00:09:39,000
information per sample and some people

00:09:35,820 --> 00:09:40,470
say double is better but I can't hear

00:09:39,000 --> 00:09:41,760
the difference personally I don't know

00:09:40,470 --> 00:09:46,290
I'm not sure if double is actually

00:09:41,760 --> 00:09:49,950
better so you have enough enough bits to

00:09:46,290 --> 00:09:51,630
represent sound and also you need to

00:09:49,950 --> 00:09:53,670
stay between minus 1 and 1 because

00:09:51,630 --> 00:09:55,110
otherwise if you go above you will have

00:09:53,670 --> 00:09:57,720
some very harsh clipping distortion

00:09:55,110 --> 00:09:58,860
which you would hear so this is sort of

00:09:57,720 --> 00:10:00,660
the conventions that you're working with

00:09:58,860 --> 00:10:03,510
and the other thing is that you might

00:10:00,660 --> 00:10:04,830
have several channels of audio so

00:10:03,510 --> 00:10:06,270
typically you will have at least like a

00:10:04,830 --> 00:10:09,720
left and a right channel or if your

00:10:06,270 --> 00:10:11,400
surround you may have 6 or and then we

00:10:09,720 --> 00:10:13,470
would have an audio frame which is

00:10:11,400 --> 00:10:15,660
basically one sample per per channel

00:10:13,470 --> 00:10:17,310
which will be an array of floats in this

00:10:15,660 --> 00:10:19,590
case it would be two floats representing

00:10:17,310 --> 00:10:21,480
one little snippet of audio which is

00:10:19,590 --> 00:10:25,140
just a tiny fraction of a mic over

00:10:21,480 --> 00:10:28,530
millisecond now if you want to output

00:10:25,140 --> 00:10:29,940
sound or you want to get sound input you

00:10:28,530 --> 00:10:31,290
have to talk to your audio card

00:10:29,940 --> 00:10:33,570
eventually through this whole stack that

00:10:31,290 --> 00:10:35,790
we saw earlier so you would your

00:10:33,570 --> 00:10:38,190
jacquard which ask you give me give me

00:10:35,790 --> 00:10:41,790
the next sample and you would receive

00:10:38,190 --> 00:10:43,860
some sort of callback now it's very very

00:10:41,790 --> 00:10:46,950
inefficient if you would for every

00:10:43,860 --> 00:10:49,530
sample 44,000 times per second you would

00:10:46,950 --> 00:10:51,660
get this number from your program you

00:10:49,530 --> 00:10:53,010
would receive 44,000 callbacks per

00:10:51,660 --> 00:10:55,880
second that will be very inefficient so

00:10:53,010 --> 00:10:57,780
typically what is done is that you

00:10:55,880 --> 00:11:00,600
transmit audio between

00:10:57,780 --> 00:11:02,250
this whole stack in so-called audio

00:11:00,600 --> 00:11:03,690
buffers where you take a chunk of

00:11:02,250 --> 00:11:08,040
samples

00:11:03,690 --> 00:11:11,160
somewhere typically between 32 and 1024

00:11:08,040 --> 00:11:13,320
samples it's one audio buffer and this

00:11:11,160 --> 00:11:14,970
is the size of audio data that's

00:11:13,320 --> 00:11:16,110
transmitted back and forth between the

00:11:14,970 --> 00:11:18,750
different applications and

00:11:16,110 --> 00:11:22,620
api's so one buffer will essentially be

00:11:18,750 --> 00:11:24,390
a array of areas of floats so the first

00:11:22,620 --> 00:11:26,160
dimension would be the channels and the

00:11:24,390 --> 00:11:31,800
second dimension would be the individual

00:11:26,160 --> 00:11:32,700
samples in one buffer so and basically

00:11:31,800 --> 00:11:34,320
what you want to do is you want to

00:11:32,700 --> 00:11:37,650
exchange these buffers with the with

00:11:34,320 --> 00:11:39,300
your audio card so typically the means

00:11:37,650 --> 00:11:44,580
of doing that is a callback function

00:11:39,300 --> 00:11:47,340
which simplest possible one is here so

00:11:44,580 --> 00:11:50,010
you have a callback which gets the data

00:11:47,340 --> 00:11:52,470
the actual channel data that's one

00:11:50,010 --> 00:11:53,820
buffer if you saw earlier then you need

00:11:52,470 --> 00:11:56,130
to know how many channels you have and

00:11:53,820 --> 00:11:57,870
how many samples you have and then

00:11:56,130 --> 00:11:58,830
basically loop through the channels and

00:11:57,870 --> 00:12:00,720
you loop through the samples and then

00:11:58,830 --> 00:12:02,850
you do some calculations ticks you

00:12:00,720 --> 00:12:05,400
generate sound or maybe you get the

00:12:02,850 --> 00:12:07,530
sound and in this very simple example

00:12:05,400 --> 00:12:09,780
what you do is you get you're just

00:12:07,530 --> 00:12:11,760
writing zeros which is always like the

00:12:09,780 --> 00:12:13,560
least thing you want to do because if

00:12:11,760 --> 00:12:15,270
you're not writing zeros then your audio

00:12:13,560 --> 00:12:16,710
card will receive garbage or

00:12:15,270 --> 00:12:20,880
uninitialized memory and you will have

00:12:16,710 --> 00:12:22,260
some ugly noise so but of course in real

00:12:20,880 --> 00:12:23,460
world you would not buy zeros but you

00:12:22,260 --> 00:12:27,120
would actually have some math that

00:12:23,460 --> 00:12:29,370
generates your audio and in the more

00:12:27,120 --> 00:12:33,050
general case you have inputs and outputs

00:12:29,370 --> 00:12:35,280
so you would have one pointer to the

00:12:33,050 --> 00:12:37,680
audio data that's coming from the sound

00:12:35,280 --> 00:12:40,110
card and another array that going to the

00:12:37,680 --> 00:12:42,120
sound card and for example you can take

00:12:40,110 --> 00:12:45,720
the input transform it somehow and then

00:12:42,120 --> 00:12:47,400
send it back out so that's like that

00:12:45,720 --> 00:12:51,660
would happen in here so this is this is

00:12:47,400 --> 00:12:53,570
this kind of audio callback which is the

00:12:51,660 --> 00:13:00,240
means by which you exchange audio data

00:12:53,570 --> 00:13:05,190
so to give you just a example so this is

00:13:00,240 --> 00:13:08,040
the producer this is a live coding C++

00:13:05,190 --> 00:13:10,680
IDE which we are presenting here this

00:13:08,040 --> 00:13:13,440
week which you want we are about to

00:13:10,680 --> 00:13:15,480
release so if you want to know more

00:13:13,440 --> 00:13:17,340
about this I recommend you to go on

00:13:15,480 --> 00:13:19,560
Wednesday to the talk by Julian Store

00:13:17,340 --> 00:13:21,000
sitting right here who is the original

00:13:19,560 --> 00:13:23,520
author of juice and he's going to talk

00:13:21,000 --> 00:13:26,900
about the producer but here I'm just

00:13:23,520 --> 00:13:29,810
going to use it for my little demo so

00:13:26,900 --> 00:13:34,350
this is essentially a little app and

00:13:29,810 --> 00:13:37,050
here you see that audio cool back so now

00:13:34,350 --> 00:13:38,790
we have here just some just outputting

00:13:37,050 --> 00:13:41,900
some sounds we're just using one channel

00:13:38,790 --> 00:13:45,600
and basically what I'm doing here is I

00:13:41,900 --> 00:13:47,339
just have a sine wave and practice you

00:13:45,600 --> 00:13:48,540
would not probably not use to design to

00:13:47,339 --> 00:13:49,410
generate it there are more efficient

00:13:48,540 --> 00:13:51,240
ways of doing this

00:13:49,410 --> 00:13:53,490
so you're just generating a sine wave

00:13:51,240 --> 00:13:54,870
with the phase that's just counting up

00:13:53,490 --> 00:13:58,500
and we are sending that to the audio

00:13:54,870 --> 00:14:03,029
card and that's all we're doing and if I

00:13:58,500 --> 00:14:04,240
run this we get a sine wave which sounds

00:14:03,029 --> 00:14:06,520
like this

00:14:04,240 --> 00:14:08,290
also this is a little class that I wrote

00:14:06,520 --> 00:14:09,430
was just like an oscilloscope shows you

00:14:08,290 --> 00:14:11,200
the waveform so that's the actual

00:14:09,430 --> 00:14:13,769
waveform it's playing

00:14:11,200 --> 00:14:13,769
now

00:14:13,970 --> 00:14:19,369
by changing the the math that generates

00:14:17,689 --> 00:14:21,199
the audio you can continue a different

00:14:19,369 --> 00:14:24,499
sound so for example in the next line we

00:14:21,199 --> 00:14:27,810
just comment this out we compile again

00:14:24,499 --> 00:14:31,350
yes that's a swelling

00:14:27,810 --> 00:14:33,300
so basically instead of generating a

00:14:31,350 --> 00:14:36,269
smooth sine wave I'm saying still copy

00:14:33,300 --> 00:14:38,699
sine which makes it just minus 1 1 minus

00:14:36,269 --> 00:14:42,230
1 minus 1 so it looks like this so it's

00:14:38,699 --> 00:14:42,230
a bit bit sharper

00:14:42,399 --> 00:14:49,869
or I can just the next line here I can

00:14:47,139 --> 00:14:51,790
just also some random numbers here but I

00:14:49,869 --> 00:14:53,319
know Stu Brandt is not the proper way to

00:14:51,790 --> 00:14:55,899
generate random numbers but for this

00:14:53,319 --> 00:15:00,759
purpose a sorcerer so it's just random

00:14:55,899 --> 00:15:06,519
numbers between minus 1 and 1 and so for

00:15:00,759 --> 00:15:13,299
example yeah I couldn't change the level

00:15:06,519 --> 00:15:17,439
here oh you can introduce the syntax

00:15:13,299 --> 00:15:22,509
error somewhere alright so basically I'm

00:15:17,439 --> 00:15:24,399
just going to quit that so basically the

00:15:22,509 --> 00:15:26,049
whole way of synthesizing sounds is to

00:15:24,399 --> 00:15:28,869
go into that audio callback and

00:15:26,049 --> 00:15:31,569
eventually you have complicated formula

00:15:28,869 --> 00:15:33,910
to generate all the sound that you want

00:15:31,569 --> 00:15:35,769
there's many ways of synthesizing cell

00:15:33,910 --> 00:15:37,600
and sampling sound so I'm not going to

00:15:35,769 --> 00:15:43,350
go into this it's going to talk a bit

00:15:37,600 --> 00:15:45,339
more about the c++ aspects of it so um

00:15:43,350 --> 00:15:48,879
because it's you have this audio

00:15:45,339 --> 00:15:50,709
callback audio is so-called hard

00:15:48,879 --> 00:15:51,939
real-time programming I'm going to talk

00:15:50,709 --> 00:15:53,819
about what that actually means and I

00:15:51,939 --> 00:15:56,559
think this is the big difference between

00:15:53,819 --> 00:15:59,410
the audio world and most other

00:15:56,559 --> 00:16:02,139
applications of C++ so what I mean by

00:15:59,410 --> 00:16:06,519
hard real-time so we have here this

00:16:02,139 --> 00:16:08,589
waveform and we split it an audio

00:16:06,519 --> 00:16:12,779
buffers and you want to send these

00:16:08,589 --> 00:16:12,779
buffers to the 2d sound card right now

00:16:13,290 --> 00:16:21,100
the sound card has a little quad crystal

00:16:18,220 --> 00:16:22,959
here which gives you depending on your

00:16:21,100 --> 00:16:27,669
sample rate gives you a record regular

00:16:22,959 --> 00:16:30,249
pulse and every for example 44,000 times

00:16:27,669 --> 00:16:33,220
per second it will actually less because

00:16:30,249 --> 00:16:35,379
an audio buffer is for example 32

00:16:33,220 --> 00:16:37,539
samples but every let's say every

00:16:35,379 --> 00:16:39,189
millisecond it will ask you give me the

00:16:37,539 --> 00:16:40,959
next audio buffer give me the next audio

00:16:39,189 --> 00:16:43,419
buffer give me the next audio buffer and

00:16:40,959 --> 00:16:44,799
then it will call the callback then you

00:16:43,419 --> 00:16:46,480
have a little bit of time to write all

00:16:44,799 --> 00:16:47,949
your audio data into that buffer and

00:16:46,480 --> 00:16:49,119
then it's going to send going to be sent

00:16:47,949 --> 00:16:50,679
to the audio card and then one

00:16:49,119 --> 00:16:52,780
millisecond later with the next callback

00:16:50,679 --> 00:16:57,700
give me the next buffer

00:16:52,780 --> 00:16:59,680
and the problem is that um this audio

00:16:57,700 --> 00:17:01,180
callback doesn't wait for anything no

00:16:59,680 --> 00:17:03,820
matter what happens on your computer

00:17:01,180 --> 00:17:05,050
after one millisecond or however your

00:17:03,820 --> 00:17:07,240
setting is there will be the next

00:17:05,050 --> 00:17:08,590
callback and you will need to react to

00:17:07,240 --> 00:17:12,280
it and you will need to have written

00:17:08,590 --> 00:17:16,930
your previous buffer into your previous

00:17:12,280 --> 00:17:20,680
data into that buffer so um that's what

00:17:16,930 --> 00:17:22,720
I mean by real-time and if you look at

00:17:20,680 --> 00:17:25,060
the like the time scales that are

00:17:22,720 --> 00:17:26,500
involved so if you have an interactive

00:17:25,060 --> 00:17:27,820
performance like if for example you have

00:17:26,500 --> 00:17:30,030
a keyboard you're playing it and you

00:17:27,820 --> 00:17:33,400
want to hear the sound as you play it

00:17:30,030 --> 00:17:35,950
you have like a window of about like ten

00:17:33,400 --> 00:17:39,220
milliseconds of overall latency where it

00:17:35,950 --> 00:17:42,430
feels really like it's life you don't

00:17:39,220 --> 00:17:44,740
feel any delay if it's somewhere around

00:17:42,430 --> 00:17:46,660
between 10 and 30 milliseconds like a

00:17:44,740 --> 00:17:49,750
pro professional performer will already

00:17:46,660 --> 00:17:51,190
feel okay that there's like some paper

00:17:49,750 --> 00:17:53,200
or something between my fingers and the

00:17:51,190 --> 00:17:54,580
keyboard it doesn't really feel life and

00:17:53,200 --> 00:17:57,130
then if it goes above about 30

00:17:54,580 --> 00:17:59,260
milliseconds then most people hear like

00:17:57,130 --> 00:18:01,480
a delay like latency between if you

00:17:59,260 --> 00:18:02,710
strike the key and you hear the sound so

00:18:01,480 --> 00:18:04,570
it's alright if you have like a

00:18:02,710 --> 00:18:06,910
multimedia player that plays something

00:18:04,570 --> 00:18:08,200
or if you have you just offline like

00:18:06,910 --> 00:18:10,660
mixing some sound but if you want to

00:18:08,200 --> 00:18:14,260
actually perform you really want to be

00:18:10,660 --> 00:18:16,180
more like somewhere here and that's the

00:18:14,260 --> 00:18:18,280
overall latency of your whole system so

00:18:16,180 --> 00:18:20,920
it means that if you have this audio

00:18:18,280 --> 00:18:22,750
callback and you're in your program then

00:18:20,920 --> 00:18:24,490
definitely you will you will you want to

00:18:22,750 --> 00:18:28,600
use a second compromise between a small

00:18:24,490 --> 00:18:30,550
buffer size and like sis tech system

00:18:28,600 --> 00:18:32,710
load like how much your processor can

00:18:30,550 --> 00:18:36,040
handle so if you work with with a small

00:18:32,710 --> 00:18:39,060
buffer size of 32 samples and you work

00:18:36,040 --> 00:18:41,890
with the 44,000 Hertz sample rate then a

00:18:39,060 --> 00:18:44,980
buffer is just under one milliseconds so

00:18:41,890 --> 00:18:46,630
if you add the whole the whole rest of

00:18:44,980 --> 00:18:49,180
your system to the latency then you can

00:18:46,630 --> 00:18:52,480
stay below 10 milliseconds but then you

00:18:49,180 --> 00:18:53,800
have more than one callback per

00:18:52,480 --> 00:18:57,250
millisecond and you have to generate

00:18:53,800 --> 00:18:58,690
your data in that time and depending on

00:18:57,250 --> 00:19:00,670
how much you run on your system or how

00:18:58,690 --> 00:19:03,190
much algorithms you run this may over

00:19:00,670 --> 00:19:05,770
this may be a lot of stress on your CPU

00:19:03,190 --> 00:19:06,520
so if it goes too much you can increase

00:19:05,770 --> 00:19:07,660
the buffer size

00:19:06,520 --> 00:19:10,600
and you have a little bit more time to

00:19:07,660 --> 00:19:12,790
compute your audio or to process your

00:19:10,600 --> 00:19:14,860
audio and then you will have less system

00:19:12,790 --> 00:19:17,200
load but then you will have more latency

00:19:14,860 --> 00:19:23,560
so it's always this kind of compromise

00:19:17,200 --> 00:19:25,630
and so we are working with these times

00:19:23,560 --> 00:19:28,480
of in the range of about one millisecond

00:19:25,630 --> 00:19:30,160
and if you imagine you have this

00:19:28,480 --> 00:19:31,750
callback here and then you generate your

00:19:30,160 --> 00:19:33,460
audio and in practice you will not have

00:19:31,750 --> 00:19:35,620
like stood sign in there but you will

00:19:33,460 --> 00:19:38,350
have an arbitrarily complicated amount

00:19:35,620 --> 00:19:41,470
of a chain of complex algorithms which

00:19:38,350 --> 00:19:43,630
compute maybe reverbs or take like a

00:19:41,470 --> 00:19:44,950
file from want to play a file file

00:19:43,630 --> 00:19:48,310
sample from the disk and apply some

00:19:44,950 --> 00:19:49,420
complex DSP effects on it but what do

00:19:48,310 --> 00:19:52,390
you want what we need to do is you won't

00:19:49,420 --> 00:19:54,610
need to guarantee that after this 0.7

00:19:52,390 --> 00:19:57,430
milliseconds for example this function

00:19:54,610 --> 00:20:00,370
will have computed everything this

00:19:57,430 --> 00:20:02,530
function will return in time and the

00:20:00,370 --> 00:20:06,340
Aquabot will contain valid audio data

00:20:02,530 --> 00:20:07,780
afterwards and there will be no error or

00:20:06,340 --> 00:20:09,700
exception and this function will always

00:20:07,780 --> 00:20:13,090
return in time and will always be done

00:20:09,700 --> 00:20:16,630
with its calculations and if you fail to

00:20:13,090 --> 00:20:18,040
do this so yeah and you you really want

00:20:16,630 --> 00:20:21,640
this to be no except because it should

00:20:18,040 --> 00:20:25,650
not throw an exception and if you fail

00:20:21,640 --> 00:20:27,820
to complete that function in time or

00:20:25,650 --> 00:20:29,620
otherwise you could generate an error in

00:20:27,820 --> 00:20:31,150
this in this callback then you will get

00:20:29,620 --> 00:20:33,910
what we call an audio dropout or a

00:20:31,150 --> 00:20:36,160
glitch which is basically you can hear

00:20:33,910 --> 00:20:38,800
like as a crackle or like a like a

00:20:36,160 --> 00:20:40,780
silent and it's immediately audible even

00:20:38,800 --> 00:20:46,690
if you have a if you drop just one

00:20:40,780 --> 00:20:48,160
buffer you can hear that so um and the

00:20:46,690 --> 00:20:51,340
most important number one rule of audio

00:20:48,160 --> 00:20:53,950
code is you you never want to cause

00:20:51,340 --> 00:20:56,830
audio callbacks audio dropout never and

00:20:53,950 --> 00:20:58,510
the reason why you never want to cause

00:20:56,830 --> 00:21:01,540
audio dropouts is imagine you're in a

00:20:58,510 --> 00:21:03,340
situation of this guy so you're you have

00:21:01,540 --> 00:21:05,650
a laptop here which runs some software

00:21:03,340 --> 00:21:07,330
which calculates some audio buffers and

00:21:05,650 --> 00:21:08,620
you're playing in front of all these

00:21:07,330 --> 00:21:11,140
people and then you have all your

00:21:08,620 --> 00:21:15,070
dropouts and then maybe you have like a

00:21:11,140 --> 00:21:17,170
15 kilowatts PA running there and then

00:21:15,070 --> 00:21:18,940
if you have an audio dropout then in

00:21:17,170 --> 00:21:20,020
worst case you will first blow the

00:21:18,940 --> 00:21:21,929
speakers and second

00:21:20,020 --> 00:21:24,130
everybody in the audience will go deaf

00:21:21,929 --> 00:21:27,910
so you definitely don't want this to

00:21:24,130 --> 00:21:30,040
happen like ever and the other way

00:21:27,910 --> 00:21:31,570
around if you are getting all your data

00:21:30,040 --> 00:21:33,220
from the audio card it's actually really

00:21:31,570 --> 00:21:35,530
the same story imagine here like you

00:21:33,220 --> 00:21:38,800
have an orchestra playing something and

00:21:35,530 --> 00:21:41,890
then you have a massive studio where you

00:21:38,800 --> 00:21:43,929
run some ear under you record them and

00:21:41,890 --> 00:21:45,700
you run like a big mixing rig but in the

00:21:43,929 --> 00:21:47,080
end you have also like an audio callback

00:21:45,700 --> 00:21:49,300
which gets some buffers and writes them

00:21:47,080 --> 00:21:52,030
into the disk so that's essentially what

00:21:49,300 --> 00:21:53,980
happens and if you just drop one buffer

00:21:52,030 --> 00:21:56,350
and fail to write this on to the disk

00:21:53,980 --> 00:21:58,480
and time

00:21:56,350 --> 00:22:00,130
then yeah you can do the whole recording

00:21:58,480 --> 00:22:02,830
again and you can ask all these people

00:22:00,130 --> 00:22:05,470
please could you just repeat the whole

00:22:02,830 --> 00:22:09,700
performance because I fail to write an

00:22:05,470 --> 00:22:10,720
audio buffer in time so you never want

00:22:09,700 --> 00:22:12,190
to cause audio dropouts

00:22:10,720 --> 00:22:14,320
and I think that's like the defining

00:22:12,190 --> 00:22:17,230
characteristic of like real-time audio

00:22:14,320 --> 00:22:20,110
programming and the other thing is that

00:22:17,230 --> 00:22:21,880
not only you want to be done with your

00:22:20,110 --> 00:22:24,390
writing or reading your audio buffer in

00:22:21,880 --> 00:22:26,470
time but also this time should be

00:22:24,390 --> 00:22:28,450
significantly shorter than the time that

00:22:26,470 --> 00:22:29,920
you physically have if you're talking

00:22:28,450 --> 00:22:31,780
about a millisecond between the

00:22:29,920 --> 00:22:34,270
different buffers and the reason for

00:22:31,780 --> 00:22:38,520
this is if you have something like this

00:22:34,270 --> 00:22:40,510
this is traction this is a door like a

00:22:38,520 --> 00:22:42,790
production music production software

00:22:40,510 --> 00:22:45,040
written with juice and here you have

00:22:42,790 --> 00:22:46,929
maybe like a hundred different tracks of

00:22:45,040 --> 00:22:50,500
audio make all the different instruments

00:22:46,929 --> 00:22:51,790
and you want to record that and you have

00:22:50,500 --> 00:22:54,309
like on every track you have like

00:22:51,790 --> 00:22:56,650
several effects plugged in so maybe have

00:22:54,309 --> 00:22:58,990
a reverb or delay or distortion factor

00:22:56,650 --> 00:23:00,250
and all of these plugins and all of

00:22:58,990 --> 00:23:01,809
these tracks they will have their their

00:23:00,250 --> 00:23:03,370
audio callbacks running so you don't

00:23:01,809 --> 00:23:05,679
have one of them but maybe you can have

00:23:03,370 --> 00:23:09,070
several hundred of them and still you

00:23:05,679 --> 00:23:14,770
want to compute every every single

00:23:09,070 --> 00:23:16,660
buffer in time and I think that's that's

00:23:14,770 --> 00:23:18,970
the big difference between audio and

00:23:16,660 --> 00:23:20,380
almost everything else because obviously

00:23:18,970 --> 00:23:22,360
we all care about performance that's why

00:23:20,380 --> 00:23:25,360
we use C++ that's that's why we all here

00:23:22,360 --> 00:23:27,010
but if you have for example I don't know

00:23:25,360 --> 00:23:30,610
you run a server and you want the server

00:23:27,010 --> 00:23:32,350
to process 1 million requests per minute

00:23:30,610 --> 00:23:33,490
or I know you what you writing like a

00:23:32,350 --> 00:23:35,770
video game you want

00:23:33,490 --> 00:23:39,909
to have like a really high frame rate on

00:23:35,770 --> 00:23:41,980
average or and in all these cases you

00:23:39,909 --> 00:23:43,149
want to have like a high throughput or

00:23:41,980 --> 00:23:44,470
maybe I don't know you're mining

00:23:43,149 --> 00:23:46,539
bitcoins and you want this whole

00:23:44,470 --> 00:23:48,370
calculation to be finished in a

00:23:46,539 --> 00:23:49,779
reasonable amount of time so it's about

00:23:48,370 --> 00:23:51,610
the average performance the average

00:23:49,779 --> 00:23:54,520
throughput that you care about but an

00:23:51,610 --> 00:23:56,830
audio you really care about every single

00:23:54,520 --> 00:23:58,539
time if you call a function you have to

00:23:56,830 --> 00:24:02,409
guarantee this this function will stay

00:23:58,539 --> 00:24:05,049
below like an absolute a balance of how

00:24:02,409 --> 00:24:07,270
long it can take and you must always

00:24:05,049 --> 00:24:09,130
it's like a contract you must always be

00:24:07,270 --> 00:24:12,279
finished with that function call in time

00:24:09,130 --> 00:24:14,350
and I think this this is like a very

00:24:12,279 --> 00:24:19,090
specific thing that changes that changes

00:24:14,350 --> 00:24:22,390
a lot of things and if you do this new

00:24:19,090 --> 00:24:24,520
plus pass then C plus itself in itself

00:24:22,390 --> 00:24:27,159
is not a real time safe language which

00:24:24,520 --> 00:24:29,799
means that it with us you can't declare

00:24:27,159 --> 00:24:31,059
that a function must be finished in one

00:24:29,799 --> 00:24:32,860
millisecond there's no way in the

00:24:31,059 --> 00:24:34,419
language to do that there are languages

00:24:32,860 --> 00:24:34,860
you can do that but C++ is not one of

00:24:34,419 --> 00:24:37,450
them

00:24:34,860 --> 00:24:39,760
so in order to fulfill this real time

00:24:37,450 --> 00:24:41,289
guarantee that we need an audio you need

00:24:39,760 --> 00:24:45,820
to do this by the way how you write code

00:24:41,289 --> 00:24:48,039
and yeah there are certain good

00:24:45,820 --> 00:24:49,559
practices or bad practices or things

00:24:48,039 --> 00:24:53,190
that you should and should not do in

00:24:49,559 --> 00:24:55,480
order to fulfill that guarantee and

00:24:53,190 --> 00:24:57,490
actually the next rule of audio code is

00:24:55,480 --> 00:25:00,010
if you want to do this if you want to

00:24:57,490 --> 00:25:01,600
succeed you should never do anything

00:25:00,010 --> 00:25:03,250
where you can't predict how much time it

00:25:01,600 --> 00:25:05,679
will it will take because you always

00:25:03,250 --> 00:25:07,870
have this hard real time guarantee so if

00:25:05,679 --> 00:25:10,630
you don't know if you function you're

00:25:07,870 --> 00:25:13,830
calling in there will be done in 0.01

00:25:10,630 --> 00:25:17,140
millisecond don't call it which means

00:25:13,830 --> 00:25:19,480
you never want to block you never want

00:25:17,140 --> 00:25:23,020
to wait for anything because you don't

00:25:19,480 --> 00:25:26,010
know how much time it will take so you

00:25:23,020 --> 00:25:29,409
should not you cannot lock a mutex or

00:25:26,010 --> 00:25:30,909
maybe try to lock a mutex and spin on

00:25:29,409 --> 00:25:32,309
that it's even worse because actually

00:25:30,909 --> 00:25:35,110
busy waiting

00:25:32,309 --> 00:25:36,520
you should not join a thread because you

00:25:35,110 --> 00:25:39,100
have no idea like when will the thread

00:25:36,520 --> 00:25:40,750
actually be done and actually you can't

00:25:39,100 --> 00:25:42,909
really call anything that blocks or

00:25:40,750 --> 00:25:44,649
waits in anyway and especially you can't

00:25:42,909 --> 00:25:46,809
call anything that box or waits for

00:25:44,649 --> 00:25:47,470
anything internally which is much harder

00:25:46,809 --> 00:25:50,350
because

00:25:47,470 --> 00:25:53,050
you don't know what's happened inside

00:25:50,350 --> 00:25:55,960
and they're surprisingly many things

00:25:53,050 --> 00:25:57,070
that block or wait internally and what

00:25:55,960 --> 00:26:02,920
you really want to do is you want to do

00:25:57,070 --> 00:26:05,170
block free program so um and why you

00:26:02,920 --> 00:26:07,540
shouldn't block I think by now with

00:26:05,170 --> 00:26:09,280
modern computers like the time that it

00:26:07,540 --> 00:26:14,860
actually takes to lock or unlock a mutex

00:26:09,280 --> 00:26:16,690
is not a problem the problem is that if

00:26:14,860 --> 00:26:19,030
you're waiting for something you have no

00:26:16,690 --> 00:26:22,120
idea if you don't know how long the code

00:26:19,030 --> 00:26:23,680
you're waiting for will take so in most

00:26:22,120 --> 00:26:25,960
cases you're waiting for code another

00:26:23,680 --> 00:26:28,180
thread which is since itself is not real

00:26:25,960 --> 00:26:31,000
time safe it does not fulfill this real

00:26:28,180 --> 00:26:33,400
time guarantee so if you do that you get

00:26:31,000 --> 00:26:34,600
an order dropout and the second reason

00:26:33,400 --> 00:26:37,990
you don't want to block in the audio

00:26:34,600 --> 00:26:41,470
thread is the thing called um priority

00:26:37,990 --> 00:26:43,630
inversion which is that this audio

00:26:41,470 --> 00:26:46,510
callback typically runs on a very high

00:26:43,630 --> 00:26:47,980
priority system thread but if it blocks

00:26:46,510 --> 00:26:49,630
and waits for another thread then that

00:26:47,980 --> 00:26:52,180
threat will be a lower priority threat

00:26:49,630 --> 00:26:53,920
and that means that if you have like an

00:26:52,180 --> 00:26:55,480
operating system and thread scheduler

00:26:53,920 --> 00:26:58,210
then that lower priority thread might

00:26:55,480 --> 00:26:59,800
self be interrupted by other threads so

00:26:58,210 --> 00:27:02,200
you might not only wait for the other

00:26:59,800 --> 00:27:04,000
code to finish but also you might wait

00:27:02,200 --> 00:27:05,260
for completely unrelated different

00:27:04,000 --> 00:27:06,940
threads because you're waiting for a low

00:27:05,260 --> 00:27:09,880
priority thread so that's priority

00:27:06,940 --> 00:27:13,630
inversion and really the only way to get

00:27:09,880 --> 00:27:17,400
away with this is if it comes to audio

00:27:13,630 --> 00:27:21,610
callbacks just only run lock free code

00:27:17,400 --> 00:27:24,250
which means you should not call new and

00:27:21,610 --> 00:27:25,660
delete because that's not lock free it

00:27:24,250 --> 00:27:27,520
will internally have a lock that may

00:27:25,660 --> 00:27:29,380
wait for another thread so you don't

00:27:27,520 --> 00:27:31,480
want to allocate a deallocate memory and

00:27:29,380 --> 00:27:34,150
you should not probably not call new or

00:27:31,480 --> 00:27:36,850
delete yourself anyway but also you

00:27:34,150 --> 00:27:38,590
should not use any error eye objects

00:27:36,850 --> 00:27:41,170
like share Porter for example that do

00:27:38,590 --> 00:27:43,420
that internally and there are many many

00:27:41,170 --> 00:27:45,190
many functions which are not lock free

00:27:43,420 --> 00:27:49,600
inside like if you do a step back to

00:27:45,190 --> 00:27:55,870
push back then if the capacity of your

00:27:49,600 --> 00:27:57,970
vectors is is over then to push back

00:27:55,870 --> 00:28:00,080
another element you the vector may

00:27:57,970 --> 00:28:01,280
reallocate all its content

00:28:00,080 --> 00:28:04,160
which is definitely not lock free

00:28:01,280 --> 00:28:06,260
because it allocates memory so you can't

00:28:04,160 --> 00:28:08,560
call vector pushback in the audio

00:28:06,260 --> 00:28:12,140
callback what you need to do is you

00:28:08,560 --> 00:28:14,600
probably the best way is to work with

00:28:12,140 --> 00:28:16,610
data on the stack or if you need data on

00:28:14,600 --> 00:28:18,170
the heap you should pre-allocate it you

00:28:16,610 --> 00:28:21,200
should be careful when this data is

00:28:18,170 --> 00:28:22,970
deleted you can use containers from

00:28:21,200 --> 00:28:25,280
boost intrusive for example which are

00:28:22,970 --> 00:28:27,680
similar to STL containers but they don't

00:28:25,280 --> 00:28:29,810
own the object so you have to handle all

00:28:27,680 --> 00:28:33,170
the pointers yourself or you can use

00:28:29,810 --> 00:28:36,620
boost lock free which offers several

00:28:33,170 --> 00:28:39,080
containers that are lock free itself and

00:28:36,620 --> 00:28:41,180
also you can use a custom real time safe

00:28:39,080 --> 00:28:42,680
containers like lock free cue stacks

00:28:41,180 --> 00:28:45,110
list there's a lot of literature and

00:28:42,680 --> 00:28:49,220
they're also in juice you offer several

00:28:45,110 --> 00:28:50,900
data containers for this purpose and for

00:28:49,220 --> 00:28:54,050
larger systems you really want probably

00:28:50,900 --> 00:28:56,030
to manage your own heap where we have

00:28:54,050 --> 00:29:00,070
some pre-allocated chunk of memory and

00:28:56,030 --> 00:29:04,220
you have a lock free way of accessing it

00:29:00,070 --> 00:29:05,780
you also don't want to call any kind of

00:29:04,220 --> 00:29:07,940
input/output functions like see out

00:29:05,780 --> 00:29:09,530
printf in the indie live coding demo I

00:29:07,940 --> 00:29:11,630
did earlier if you if you do like a

00:29:09,530 --> 00:29:16,280
printf in there you immediately hear

00:29:11,630 --> 00:29:18,260
like the crackles you don't really want

00:29:16,280 --> 00:29:19,700
to communicate any other processes

00:29:18,260 --> 00:29:21,080
definitely you don't want to access any

00:29:19,700 --> 00:29:23,630
files on the disks because this will

00:29:21,080 --> 00:29:25,700
most likely take more than 0.1

00:29:23,630 --> 00:29:27,530
millisecond that you have you don't want

00:29:25,700 --> 00:29:29,120
to talk to the network so and you don't

00:29:27,530 --> 00:29:31,340
want to do any graphics rendering either

00:29:29,120 --> 00:29:33,080
so all of these things you have to do on

00:29:31,340 --> 00:29:34,700
other threads and you have to

00:29:33,080 --> 00:29:37,360
synchronize them with your audio thread

00:29:34,700 --> 00:29:37,360
in a lockrey way

00:29:39,350 --> 00:29:43,820
you should also probably in the audio

00:29:42,140 --> 00:29:46,850
callback not call any third-party code

00:29:43,820 --> 00:29:47,780
because usually Microsoft or Apple or

00:29:46,850 --> 00:29:49,910
other vendors they don't document

00:29:47,780 --> 00:29:50,600
whether the functions are real real time

00:29:49,910 --> 00:29:53,360
safe or not

00:29:50,600 --> 00:29:55,340
no no documentation says this function

00:29:53,360 --> 00:29:56,930
is guaranteed to take less than one

00:29:55,340 --> 00:30:02,210
millisecond time I never seen that in

00:29:56,930 --> 00:30:05,360
the documentation and also you have to

00:30:02,210 --> 00:30:06,770
watch out for worst case behavior

00:30:05,360 --> 00:30:09,170
because here you don't worry about

00:30:06,770 --> 00:30:11,810
average behavior you really were worried

00:30:09,170 --> 00:30:13,760
about the worst case for example if you

00:30:11,810 --> 00:30:16,990
have a hash hash table I can I know

00:30:13,760 --> 00:30:19,100
set inserting or looking up something is

00:30:16,990 --> 00:30:20,720
constant time except it's not it's

00:30:19,100 --> 00:30:22,250
amortized constant time which means that

00:30:20,720 --> 00:30:24,200
once in a while the whole container

00:30:22,250 --> 00:30:26,210
might say oh I'm gonna have to rehash

00:30:24,200 --> 00:30:27,080
all my content now and you have no idea

00:30:26,210 --> 00:30:30,680
how long this will take

00:30:27,080 --> 00:30:33,290
so you cannot use that and the other

00:30:30,680 --> 00:30:35,390
thing is what you can't do is you should

00:30:33,290 --> 00:30:36,590
not run into page faults and this is an

00:30:35,390 --> 00:30:38,120
interesting one because I think for most

00:30:36,590 --> 00:30:40,940
people this is something that was

00:30:38,120 --> 00:30:42,320
probably an interesting problem maybe 20

00:30:40,940 --> 00:30:45,050
years ago when computers didn't have

00:30:42,320 --> 00:30:48,050
enough memory and since long forgotten

00:30:45,050 --> 00:30:49,880
and you should not care about this but

00:30:48,050 --> 00:30:51,980
in audio there is a specific use case

00:30:49,880 --> 00:30:53,390
where this is actually still still a

00:30:51,980 --> 00:30:56,510
problem that you should think about and

00:30:53,390 --> 00:30:58,880
this use case is so-called sampler

00:30:56,510 --> 00:31:03,080
instruments how this works is you have

00:30:58,880 --> 00:31:05,030
that loads of them on the market if you

00:31:03,080 --> 00:31:07,700
have also one one of one sampler in our

00:31:05,030 --> 00:31:09,560
equator centered Roley and how it works

00:31:07,700 --> 00:31:10,820
is you sample a musical instrument like

00:31:09,560 --> 00:31:12,470
a drum kit for example and you have

00:31:10,820 --> 00:31:13,820
little sound snippets for every single

00:31:12,470 --> 00:31:15,890
drum or every single note that this

00:31:13,820 --> 00:31:18,110
instrument instrument can hit maybe in

00:31:15,890 --> 00:31:19,880
different articulations and you have a

00:31:18,110 --> 00:31:21,470
keyboard and if you if you basically

00:31:19,880 --> 00:31:23,150
press a button on that keyboard you want

00:31:21,470 --> 00:31:25,580
that little audio snippet to play and

00:31:23,150 --> 00:31:27,770
then you can easily have like a one or

00:31:25,580 --> 00:31:32,810
two gigabytes a geeks or a gigabyte of

00:31:27,770 --> 00:31:34,880
these samples and you don't know which

00:31:32,810 --> 00:31:36,920
which are key the user will hit next

00:31:34,880 --> 00:31:39,050
time but if the user presses the key you

00:31:36,920 --> 00:31:41,000
want to hear the sound and if you have

00:31:39,050 --> 00:31:42,410
two gigabytes of memory which your

00:31:41,000 --> 00:31:43,760
application users there's a high chance

00:31:42,410 --> 00:31:46,820
that some of this memory if it's not

00:31:43,760 --> 00:31:48,320
used it's going to be paged out it's

00:31:46,820 --> 00:31:49,730
going to be maybe swapped onto disk

00:31:48,320 --> 00:31:51,890
something and then when you actually

00:31:49,730 --> 00:31:53,840
access it it had you generate a page

00:31:51,890 --> 00:31:55,550
fault it needs to be paged in and this

00:31:53,840 --> 00:32:00,530
whole process will probably take longer

00:31:55,550 --> 00:32:03,380
than the time that you have and so for

00:32:00,530 --> 00:32:05,650
these kind of music software arm it's

00:32:03,380 --> 00:32:07,850
actually a problem in practice and

00:32:05,650 --> 00:32:09,050
there's two solution specific this

00:32:07,850 --> 00:32:12,110
either you can have like a low priority

00:32:09,050 --> 00:32:13,820
thread which regularly says okay I'm

00:32:12,110 --> 00:32:15,560
going to use this memory so you can

00:32:13,820 --> 00:32:20,240
access this memory so it stays hot it

00:32:15,560 --> 00:32:23,270
stays into or actually the more the

00:32:20,240 --> 00:32:26,030
better solution is that modern operating

00:32:23,270 --> 00:32:27,040
systems they all offer some API slack em

00:32:26,030 --> 00:32:29,140
lock and man lock on

00:32:27,040 --> 00:32:32,890
Mac and Linux or virtual lock unlock on

00:32:29,140 --> 00:32:34,330
Windows which lets you lock lock memory

00:32:32,890 --> 00:32:39,280
into the virtual memory so it's not

00:32:34,330 --> 00:32:41,440
going to be paged out and unfortunately

00:32:39,280 --> 00:32:43,120
there's nothing in the CBS 2 standard or

00:32:41,440 --> 00:32:46,360
and boost for that so you have to rely

00:32:43,120 --> 00:32:47,470
on platform specific things and also

00:32:46,360 --> 00:32:48,880
probably you don't want to call that

00:32:47,470 --> 00:32:50,560
yourself but you want to wrap that into

00:32:48,880 --> 00:32:52,090
some kind of smart pointer or you want

00:32:50,560 --> 00:32:54,010
to write your own STL compatible a

00:32:52,090 --> 00:32:56,920
locator for that and it's really tricky

00:32:54,010 --> 00:32:57,970
to do so probably are what's better is

00:32:56,920 --> 00:33:00,550
actually to have some kind of pre

00:32:57,970 --> 00:33:02,740
located memory for your application

00:33:00,550 --> 00:33:04,390
which is locked into memory and then you

00:33:02,740 --> 00:33:08,440
need some kind of custom heap management

00:33:04,390 --> 00:33:11,620
to do that so yeah I'm not going to show

00:33:08,440 --> 00:33:13,180
any code that does that because quite

00:33:11,620 --> 00:33:16,330
complicated in practice and could take a

00:33:13,180 --> 00:33:19,300
long time so I'm just going to summarize

00:33:16,330 --> 00:33:22,210
why do we why do we use C++ for audio so

00:33:19,300 --> 00:33:24,640
obviously most of the audio api s are

00:33:22,210 --> 00:33:26,980
actually c or c++ so it's very

00:33:24,640 --> 00:33:29,620
convenient then as we all know c++ as

00:33:26,980 --> 00:33:31,030
fast as close to the metal but then also

00:33:29,620 --> 00:33:33,370
it allows you to use custom memory

00:33:31,030 --> 00:33:35,850
management and it supports concurrency

00:33:33,370 --> 00:33:39,310
at the c plus 11 and 14 standards have

00:33:35,850 --> 00:33:41,500
atomic in them so the hepa Tomic types

00:33:39,310 --> 00:33:44,530
they allow you to have lock free access

00:33:41,500 --> 00:33:47,740
and they allow you to program lock free

00:33:44,530 --> 00:33:49,300
and in the end for audio this this whole

00:33:47,740 --> 00:33:51,670
thing allows you to write real-time safe

00:33:49,300 --> 00:33:55,770
code which is what we want to do yeah

00:33:51,670 --> 00:33:58,030
look how much time we have alright so um

00:33:55,770 --> 00:34:01,030
so here's basically the situation you

00:33:58,030 --> 00:34:03,070
have you have one audio thread which

00:34:01,030 --> 00:34:04,300
always gets these audio callbacks give

00:34:03,070 --> 00:34:06,100
me the next buffer give me the next

00:34:04,300 --> 00:34:08,140
buffer give me things buffer and then

00:34:06,100 --> 00:34:10,060
maybe you have another threat with a GUI

00:34:08,140 --> 00:34:14,350
with a graphical user interface where

00:34:10,060 --> 00:34:16,270
the user can turn some knobs and these

00:34:14,350 --> 00:34:18,820
will have an effect on on the audio and

00:34:16,270 --> 00:34:20,740
this may be runs on some kind of message

00:34:18,820 --> 00:34:22,150
loop then maybe you have some some

00:34:20,740 --> 00:34:23,770
hardware connected where somebody plays

00:34:22,150 --> 00:34:25,179
on a keyboard and the keyboard send

00:34:23,770 --> 00:34:27,310
messages through your application we

00:34:25,179 --> 00:34:29,890
have protocols for that like MIDI and

00:34:27,310 --> 00:34:31,630
OSC and you have a threat which receives

00:34:29,890 --> 00:34:33,100
these messages and then maybe you have

00:34:31,630 --> 00:34:35,080
another threat that reads or writes data

00:34:33,100 --> 00:34:38,380
from end to the disk and somewhere you

00:34:35,080 --> 00:34:39,669
have to synchronize all these things but

00:34:38,380 --> 00:34:40,700
you have to guarantee that your audio

00:34:39,669 --> 00:34:42,800
callback will always be

00:34:40,700 --> 00:34:44,089
time safe and that's like the I

00:34:42,800 --> 00:34:47,480
would say the big challenge in audio

00:34:44,089 --> 00:34:52,220
software basically this threat should

00:34:47,480 --> 00:34:55,040
never block so let's look at a very

00:34:52,220 --> 00:34:57,230
simple example you have a knob which

00:34:55,040 --> 00:34:58,880
changes the level of your audio and the

00:34:57,230 --> 00:35:02,510
user can turn that with the mouse and

00:34:58,880 --> 00:35:05,000
this should affect the audio thread now

00:35:02,510 --> 00:35:06,770
the easiest way to write this and

00:35:05,000 --> 00:35:09,320
actually I've seen many people writing

00:35:06,770 --> 00:35:11,930
code like this is that you have that's

00:35:09,320 --> 00:35:14,030
your level that's just a float and then

00:35:11,930 --> 00:35:15,589
you have in the GUI thread you get some

00:35:14,030 --> 00:35:17,900
callback from the mouse event and then

00:35:15,589 --> 00:35:21,290
the level is changed and then you have

00:35:17,900 --> 00:35:22,730
in the audio callback you have that's

00:35:21,290 --> 00:35:24,290
your would you cool back and then you

00:35:22,730 --> 00:35:25,940
just multiply that level with some

00:35:24,290 --> 00:35:29,630
buffers and you sent it to the audio

00:35:25,940 --> 00:35:32,829
card now on that's a race condition

00:35:29,630 --> 00:35:34,910
right and even though it's just a float

00:35:32,829 --> 00:35:37,760
since he vs. 11 this is actually

00:35:34,910 --> 00:35:40,579
undefined behavior so even though a

00:35:37,760 --> 00:35:42,349
float is actually almost architecture's

00:35:40,579 --> 00:35:44,660
this will be atomic like reading or

00:35:42,349 --> 00:35:47,329
writing a float c plus 11 standard says

00:35:44,660 --> 00:35:49,310
that concurrent access through the same

00:35:47,329 --> 00:35:50,869
memory is a data race it's actually

00:35:49,310 --> 00:35:54,920
defined in the standard and data race is

00:35:50,869 --> 00:35:56,300
always undefined behavior so you don't

00:35:54,920 --> 00:35:57,950
want to do that even though this code

00:35:56,300 --> 00:36:00,230
this specific code with the one float

00:35:57,950 --> 00:36:02,450
will run you will not have problems with

00:36:00,230 --> 00:36:03,829
this code but as soon as it gets a bit

00:36:02,450 --> 00:36:05,210
more complicated than that you can get

00:36:03,829 --> 00:36:07,760
loads of problems so you definitely

00:36:05,210 --> 00:36:10,339
don't want to write code like this so

00:36:07,760 --> 00:36:12,380
you can get undefined behavior the

00:36:10,339 --> 00:36:14,720
access to your data can be not atomic

00:36:12,380 --> 00:36:16,730
which means that the thread may see a

00:36:14,720 --> 00:36:18,560
value that's like in between the old and

00:36:16,730 --> 00:36:20,960
the new value it's called the tone read

00:36:18,560 --> 00:36:22,730
or tone right also you have the problem

00:36:20,960 --> 00:36:24,170
that if you write code like this where

00:36:22,730 --> 00:36:27,319
you don't use any locks and it's not

00:36:24,170 --> 00:36:29,210
atomic you are you can have compiler

00:36:27,319 --> 00:36:30,560
optimizations that break your logic

00:36:29,210 --> 00:36:32,210
because the compiler thinks are you're

00:36:30,560 --> 00:36:33,260
not you're not modifying that code and

00:36:32,210 --> 00:36:36,290
there's no lock or no synchronization

00:36:33,260 --> 00:36:38,420
anywhere and then also if you just use

00:36:36,290 --> 00:36:42,470
plain float the concurrency is not

00:36:38,420 --> 00:36:44,780
expressed in any way in your code so and

00:36:42,470 --> 00:36:46,760
the fact that X is not atomic is

00:36:44,780 --> 00:36:48,950
actually even for fundamental types it's

00:36:46,760 --> 00:36:50,599
more surprising than then some people

00:36:48,950 --> 00:36:53,829
think like for example if you have not a

00:36:50,599 --> 00:36:57,539
float but of 64-bit integer

00:36:53,829 --> 00:37:00,700
which is fundamental type and you just

00:36:57,539 --> 00:37:03,519
set this to to some value in one thread

00:37:00,700 --> 00:37:06,190
and read it from another thread and you

00:37:03,519 --> 00:37:07,660
compile that with GCC for 32-bit which

00:37:06,190 --> 00:37:09,369
is an actual use case because if you do

00:37:07,660 --> 00:37:11,799
audio plugins you want to compile them a

00:37:09,369 --> 00:37:13,719
32-bit because many hosts they just

00:37:11,799 --> 00:37:15,130
understand 32-bit plugins and if you

00:37:13,719 --> 00:37:19,390
compile that then that's the assembler

00:37:15,130 --> 00:37:22,509
output you get so actually GCC even on a

00:37:19,390 --> 00:37:25,959
64-bit even if the system is 64-bit if

00:37:22,509 --> 00:37:29,410
you compile for a 32-bit if you compile

00:37:25,959 --> 00:37:31,599
a 32-bit plug in a program then this

00:37:29,410 --> 00:37:34,239
will be two reads and this this will be

00:37:31,599 --> 00:37:35,440
sorry this will be 2 reads for the least

00:37:34,239 --> 00:37:36,640
significant bit and for the most

00:37:35,440 --> 00:37:39,999
significant bit and this would be 2

00:37:36,640 --> 00:37:41,680
writes so if you if you write the value

00:37:39,999 --> 00:37:44,200
here then here you will actually see

00:37:41,680 --> 00:37:46,479
maybe like a 2 where you see this

00:37:44,200 --> 00:37:47,950
despite you will see this part of number

00:37:46,479 --> 00:37:49,269
but not that part so you will see like

00:37:47,950 --> 00:37:52,390
an in-between value and that can even

00:37:49,269 --> 00:37:54,069
happen with fundamental types so the

00:37:52,390 --> 00:37:56,259
other thing that can happen is that if

00:37:54,069 --> 00:37:59,469
you have for example like bool or any

00:37:56,259 --> 00:38:01,059
other fundamental type and you set it to

00:37:59,469 --> 00:38:03,369
false for example and then you wait

00:38:01,059 --> 00:38:07,599
until another thread maybe sets it to

00:38:03,369 --> 00:38:09,309
true the compiler sees all right but

00:38:07,599 --> 00:38:10,869
yeah you're not modifying that that

00:38:09,309 --> 00:38:14,079
value in here right so I can actually

00:38:10,869 --> 00:38:15,789
optimize that away so you will end up

00:38:14,079 --> 00:38:17,049
with an infinite loop which is just not

00:38:15,789 --> 00:38:18,699
what you wrote down it's not the

00:38:17,049 --> 00:38:22,749
behavior you want and the compiler can

00:38:18,699 --> 00:38:24,279
do this so a generation of audio program

00:38:22,749 --> 00:38:29,499
has fixed this particular problem

00:38:24,279 --> 00:38:31,989
problem with using volatile so may many

00:38:29,499 --> 00:38:33,999
people would do it this way and actually

00:38:31,989 --> 00:38:35,949
this fixes this particular problem using

00:38:33,999 --> 00:38:37,869
volatile fixes that particular problem

00:38:35,949 --> 00:38:40,779
because it tells the compiler this value

00:38:37,869 --> 00:38:42,130
can change don't optimize on that

00:38:40,779 --> 00:38:43,869
assumption that it will not change so

00:38:42,130 --> 00:38:45,459
this fixes this particular problem but

00:38:43,869 --> 00:38:48,640
volatile does not fix any of the other

00:38:45,459 --> 00:38:50,440
problems and also it prevents all

00:38:48,640 --> 00:38:51,940
compiler optimizations some of them are

00:38:50,440 --> 00:38:53,890
actually may be good for your code so

00:38:51,940 --> 00:38:57,519
volatile is definitely the wrong the

00:38:53,890 --> 00:39:00,430
wrong way to go here and the classical

00:38:57,519 --> 00:39:03,039
approach would be to insert like very

00:39:00,430 --> 00:39:04,839
simple just have a mutex where you

00:39:03,039 --> 00:39:07,119
synchronize that concurrent access and

00:39:04,839 --> 00:39:07,640
also in this specific case it would not

00:39:07,119 --> 00:39:09,200
be a problem

00:39:07,640 --> 00:39:12,230
because you would just wait for like one

00:39:09,200 --> 00:39:13,850
right of a float but as soon as like in

00:39:12,230 --> 00:39:15,770
real world your audio program will be

00:39:13,850 --> 00:39:18,380
more complex and then you you don't you

00:39:15,770 --> 00:39:19,820
you won't know anymore what you're

00:39:18,380 --> 00:39:20,900
waiting for and you don't want to block

00:39:19,820 --> 00:39:22,130
you don't want to wait for something

00:39:20,900 --> 00:39:25,100
where you don't know how long it rotate

00:39:22,130 --> 00:39:27,710
so what you really should do is you

00:39:25,100 --> 00:39:30,020
should we should use the atomic and this

00:39:27,710 --> 00:39:31,730
guarantees that you will not have any

00:39:30,020 --> 00:39:34,040
torn reads or writes because the excess

00:39:31,730 --> 00:39:35,360
will always be atomic it's going to use

00:39:34,040 --> 00:39:36,770
that you lock free because not locking

00:39:35,360 --> 00:39:38,210
anything anywhere and this going to use

00:39:36,770 --> 00:39:41,540
defined behavior and it also expresses

00:39:38,210 --> 00:39:44,930
what you actually want to do so that's

00:39:41,540 --> 00:39:46,490
that's the solution here if you have the

00:39:44,930 --> 00:39:48,380
other way around maybe your audio codec

00:39:46,490 --> 00:39:51,140
generates some numbers and when specific

00:39:48,380 --> 00:39:53,090
number changes then maybe you want some

00:39:51,140 --> 00:39:55,840
element of your graphical user interface

00:39:53,090 --> 00:39:57,920
to wiggle that's the other way around so

00:39:55,840 --> 00:39:59,630
what you don't want to do like if you

00:39:57,920 --> 00:40:02,960
have an audio callback and here you have

00:39:59,630 --> 00:40:04,790
an atomic float and you you change its

00:40:02,960 --> 00:40:07,520
value what you don't want to do is you

00:40:04,790 --> 00:40:09,050
want to just from here call your gray

00:40:07,520 --> 00:40:10,130
code because this will do some graphical

00:40:09,050 --> 00:40:13,940
rendering this is definitely not

00:40:10,130 --> 00:40:15,650
real-time safe what you can do instead

00:40:13,940 --> 00:40:17,720
which is a little bit better as you can

00:40:15,650 --> 00:40:20,390
say okay I will not render anything in

00:40:17,720 --> 00:40:22,010
the audio thread but I can maybe post a

00:40:20,390 --> 00:40:23,750
message on some kind of message loop and

00:40:22,010 --> 00:40:26,870
then later the GUI thread will pick that

00:40:23,750 --> 00:40:29,420
up and re-render that knob but again if

00:40:26,870 --> 00:40:31,130
you if you post something like if you do

00:40:29,420 --> 00:40:32,360
like a notification something changed

00:40:31,130 --> 00:40:34,400
and post it to the message thread

00:40:32,360 --> 00:40:35,720
probably this procedure is not lock free

00:40:34,400 --> 00:40:37,130
it will probably allocate something

00:40:35,720 --> 00:40:38,780
somewhere and the other on there and the

00:40:37,130 --> 00:40:40,820
other thing is that the audio callback

00:40:38,780 --> 00:40:42,560
is running a thousand times per second

00:40:40,820 --> 00:40:44,840
so you will be congesting your message

00:40:42,560 --> 00:40:47,270
to put thousands of messages because the

00:40:44,840 --> 00:40:49,580
GUI thread typically runs much slower so

00:40:47,270 --> 00:40:51,470
one solution to this which actually

00:40:49,580 --> 00:40:54,350
works very well in practice for with

00:40:51,470 --> 00:40:57,680
your code is that you have some kind of

00:40:54,350 --> 00:40:59,390
flag which is also atomic which says the

00:40:57,680 --> 00:41:01,280
GUI is up to date or the GUI has changed

00:40:59,390 --> 00:41:03,380
and then the only thing that you do in

00:41:01,280 --> 00:41:06,970
the audio set is you set that flag like

00:41:03,380 --> 00:41:09,320
oh I changed something and then you have

00:41:06,970 --> 00:41:12,440
on another thread you have like a timer

00:41:09,320 --> 00:41:15,890
which maybe 30 or 50 times a second just

00:41:12,440 --> 00:41:17,210
checks this flag and this is not such so

00:41:15,890 --> 00:41:18,770
much of an overhead on a modern machine

00:41:17,210 --> 00:41:21,260
this is not a problem to have this and

00:41:18,770 --> 00:41:23,720
then if the flag

00:41:21,260 --> 00:41:27,380
changed you update your GUI and because

00:41:23,720 --> 00:41:30,800
it's atomic you should not you should

00:41:27,380 --> 00:41:32,450
not do like a normal if and also the

00:41:30,800 --> 00:41:34,910
double check locking is it's not

00:41:32,450 --> 00:41:36,980
appropriate because then you have blocks

00:41:34,910 --> 00:41:38,480
but actually you should use the member

00:41:36,980 --> 00:41:40,460
function sets to the atomic provides

00:41:38,480 --> 00:41:43,940
which is this one compare chain strong

00:41:40,460 --> 00:41:44,360
if the values for if is false set it to

00:41:43,940 --> 00:41:46,190
two

00:41:44,360 --> 00:41:52,100
and return and that whole thing is

00:41:46,190 --> 00:41:53,690
atomic so with the float that's easy

00:41:52,100 --> 00:41:55,520
right but how do you do this if you have

00:41:53,690 --> 00:41:57,380
an object maybe you have something more

00:41:55,520 --> 00:42:00,170
complicated like a like a curve that the

00:41:57,380 --> 00:42:03,740
user can draw or maybe like a snippet of

00:42:00,170 --> 00:42:05,390
audio on the disk and you want just you

00:42:03,740 --> 00:42:08,300
want to change this from the GUI thread

00:42:05,390 --> 00:42:09,920
and the old if I should see this now you

00:42:08,300 --> 00:42:12,650
can actually instantiate something like

00:42:09,920 --> 00:42:15,610
an atomic widget and it will actually

00:42:12,650 --> 00:42:17,990
compile if widget is trivially copyable

00:42:15,610 --> 00:42:19,730
it will actually compile and it will

00:42:17,990 --> 00:42:21,740
actually semantically do what you want

00:42:19,730 --> 00:42:24,890
in the sense that it will be proper sync

00:42:21,740 --> 00:42:26,300
properly synchronized but if you have a

00:42:24,890 --> 00:42:27,920
widget by the way it's not a GUI widget

00:42:26,300 --> 00:42:29,180
it's just like any any kind of class

00:42:27,920 --> 00:42:30,860
which is more complicated than a

00:42:29,180 --> 00:42:33,350
fundamental type we have a right widget

00:42:30,860 --> 00:42:36,230
that means some class some user-defined

00:42:33,350 --> 00:42:37,490
class but probably setting that class or

00:42:36,230 --> 00:42:40,400
reading that class is not an atomic

00:42:37,490 --> 00:42:41,690
instruction on your CPU so actually what

00:42:40,400 --> 00:42:43,070
the compiler will do if you try to

00:42:41,690 --> 00:42:46,190
instantiate this it will insert some

00:42:43,070 --> 00:42:47,480
blocks internally you don't even see

00:42:46,190 --> 00:42:49,450
this and this is definitely not what you

00:42:47,480 --> 00:42:51,500
want if you want to be locked free

00:42:49,450 --> 00:42:54,880
actually you can check this there's this

00:42:51,500 --> 00:42:57,920
member functions this lock free which

00:42:54,880 --> 00:42:59,480
you can you can query whether this

00:42:57,920 --> 00:43:01,250
atomic type is actually locked for you

00:42:59,480 --> 00:43:02,750
inside or not but what you can do is you

00:43:01,250 --> 00:43:06,770
can do you can have atomic pointers

00:43:02,750 --> 00:43:11,390
that's fine so what you end up doing is

00:43:06,770 --> 00:43:14,320
you end up juggling around pointers like

00:43:11,390 --> 00:43:18,830
swapping around pointers atomically and

00:43:14,320 --> 00:43:21,530
this is sort of the way to do this but

00:43:18,830 --> 00:43:24,050
if you go down this road you find out

00:43:21,530 --> 00:43:25,940
that it's very very painful road because

00:43:24,050 --> 00:43:27,770
for example here in the audio set you

00:43:25,940 --> 00:43:29,870
want to do something with that object so

00:43:27,770 --> 00:43:31,370
you load you load the pointer value

00:43:29,870 --> 00:43:32,840
maybe into a variable because you don't

00:43:31,370 --> 00:43:33,730
want the pointer value to change while

00:43:32,840 --> 00:43:36,310
you're accessing that

00:43:33,730 --> 00:43:40,420
Jake but then in the glacier you want to

00:43:36,310 --> 00:43:41,950
change that object right so what you

00:43:40,420 --> 00:43:43,510
have to do because the extra pointer

00:43:41,950 --> 00:43:45,550
swap has to be atomic you have to create

00:43:43,510 --> 00:43:48,040
a new copy of that object which is here

00:43:45,550 --> 00:43:50,920
and then you have to do a compare

00:43:48,040 --> 00:43:53,220
exchange okay is that still the value

00:43:50,920 --> 00:43:55,660
that I know it should be and then okay

00:43:53,220 --> 00:43:58,420
publish the new value of that point like

00:43:55,660 --> 00:44:00,430
published a new object and also you want

00:43:58,420 --> 00:44:02,170
to you want that not to happen while the

00:44:00,430 --> 00:44:03,850
audio sweat is using that right so you

00:44:02,170 --> 00:44:06,310
need some some kind of way to do that

00:44:03,850 --> 00:44:09,100
maybe set a flag here or something and

00:44:06,310 --> 00:44:10,780
then also you have here Anu and you swap

00:44:09,100 --> 00:44:12,670
the pointers here and then you have the

00:44:10,780 --> 00:44:14,470
old object and you need to get rid of it

00:44:12,670 --> 00:44:16,480
so you need to call delete and whenever

00:44:14,470 --> 00:44:18,280
you're calling you and delete explicitly

00:44:16,480 --> 00:44:20,230
there's like loads of things that can go

00:44:18,280 --> 00:44:22,840
wrong so so so really you don't want to

00:44:20,230 --> 00:44:26,530
write code like this because this it's

00:44:22,840 --> 00:44:28,030
so easy to get this wrong and what you

00:44:26,530 --> 00:44:30,040
really want is there is a class in the

00:44:28,030 --> 00:44:32,109
standard library shared footer which

00:44:30,040 --> 00:44:34,210
which lets you automatically handle a

00:44:32,109 --> 00:44:35,800
lifetime of an object and what you

00:44:34,210 --> 00:44:38,890
really want is you want an atomic shared

00:44:35,800 --> 00:44:40,840
putter and unfortunately in the current

00:44:38,890 --> 00:44:43,780
standard there's no such thing as an

00:44:40,840 --> 00:44:48,010
atomic shed put er like this but there

00:44:43,780 --> 00:44:49,480
is one it's interesting because the

00:44:48,010 --> 00:44:51,700
interface for it looks like this you

00:44:49,480 --> 00:44:54,000
have like stood atomic underscore

00:44:51,700 --> 00:44:56,380
something functions and then they get

00:44:54,000 --> 00:44:58,480
pointer to share share pointer as an

00:44:56,380 --> 00:44:59,859
argument and I don't know why the

00:44:58,480 --> 00:45:01,780
standard Committee did this maybe

00:44:59,859 --> 00:45:03,730
somebody here knows and can tell me it

00:45:01,780 --> 00:45:06,760
would be really interested why they have

00:45:03,730 --> 00:45:08,440
this interface for shared pictures but

00:45:06,760 --> 00:45:16,180
in the end it lets you do what you want

00:45:08,440 --> 00:45:17,859
so that's the code here so here we are

00:45:16,180 --> 00:45:19,330
updating a widget so we're getting maybe

00:45:17,859 --> 00:45:21,359
some arguments from the user interface

00:45:19,330 --> 00:45:23,560
we don't really care about this year so

00:45:21,359 --> 00:45:25,660
we create a new widget

00:45:23,560 --> 00:45:28,930
we create a new chat pointer to that

00:45:25,660 --> 00:45:30,940
widget and that we can do is we can

00:45:28,930 --> 00:45:34,330
atomically by calling the still atomic

00:45:30,940 --> 00:45:36,010
store we can atomically swap this new

00:45:34,330 --> 00:45:39,130
share putter with the with the old

00:45:36,010 --> 00:45:40,750
shared footer so that's like the current

00:45:39,130 --> 00:45:43,150
one and we swap the new one with the

00:45:40,750 --> 00:45:44,920
current one atomically and this actually

00:45:43,150 --> 00:45:46,240
works and then you don't have to because

00:45:44,920 --> 00:45:47,500
it's a shared putter than the old one

00:45:46,240 --> 00:45:49,089
will be just disposed of

00:45:47,500 --> 00:45:50,529
because the shared per trip will just

00:45:49,089 --> 00:45:51,460
run out of scope and if we delete it you

00:45:50,529 --> 00:45:54,190
don't have to worry about the lifetime

00:45:51,460 --> 00:45:55,630
so that that's very nice and in the

00:45:54,190 --> 00:45:58,420
audio callback we want to use that

00:45:55,630 --> 00:46:00,250
object you you do an atomic load of the

00:45:58,420 --> 00:46:02,799
shared putter and you end up with with

00:46:00,250 --> 00:46:04,569
another shared putter which points the

00:46:02,799 --> 00:46:06,039
same object but because it's you made a

00:46:04,569 --> 00:46:09,069
copy of the share button out of the

00:46:06,039 --> 00:46:12,759
object just of the shared putter using

00:46:09,069 --> 00:46:15,549
an atomic load this share put a will

00:46:12,759 --> 00:46:17,079
point to the same object so it will not

00:46:15,549 --> 00:46:18,880
like the pointer value will not change

00:46:17,079 --> 00:46:20,740
even though if you if this happens in

00:46:18,880 --> 00:46:22,269
the meantime see you can happily use

00:46:20,740 --> 00:46:24,549
this this object for your audio

00:46:22,269 --> 00:46:25,720
computations and everything will be fine

00:46:24,549 --> 00:46:28,890
and you don't have to worry about new

00:46:25,720 --> 00:46:28,890
and delete yes

00:46:33,299 --> 00:46:41,980
yep that's the only problem with this

00:46:38,799 --> 00:46:44,529
code if it happened that during this

00:46:41,980 --> 00:46:46,000
this execution here this one swapped

00:46:44,529 --> 00:46:47,579
around the pointers then this will go

00:46:46,000 --> 00:46:49,750
out of scope and you will have a delete

00:46:47,579 --> 00:46:51,519
that there is implicitly called in the

00:46:49,750 --> 00:46:53,710
audio callback which is not what you

00:46:51,519 --> 00:46:56,829
want to happen and there so there's a

00:46:53,710 --> 00:47:00,910
very nice solution for this so what you

00:46:56,829 --> 00:47:03,700
can do is you can have a little release

00:47:00,910 --> 00:47:05,170
pool like a garbage collector just nice

00:47:03,700 --> 00:47:06,460
because we're using C++ because it

00:47:05,170 --> 00:47:08,309
doesn't have garbage collectors but then

00:47:06,460 --> 00:47:13,150
we introduce our own garbage collector

00:47:08,309 --> 00:47:16,180
so basically this guy here is something

00:47:13,150 --> 00:47:19,029
that just has shared put us two objects

00:47:16,180 --> 00:47:22,390
and you can add objects to this pool and

00:47:19,029 --> 00:47:24,700
then it has like a every every now and

00:47:22,390 --> 00:47:26,680
then it checks oh is there some other

00:47:24,700 --> 00:47:27,339
some objects that are not referenced by

00:47:26,680 --> 00:47:30,670
anyone else

00:47:27,339 --> 00:47:32,049
and if yes it cleans them up and so what

00:47:30,670 --> 00:47:33,579
you want to do is you want to create a

00:47:32,049 --> 00:47:35,920
new object you want to add that to this

00:47:33,579 --> 00:47:37,869
pool and then you're fine and then if it

00:47:35,920 --> 00:47:40,089
goes out of scope here the pool will

00:47:37,869 --> 00:47:47,609
handle it and here's the code for the

00:47:40,089 --> 00:47:47,609
pool for the release pool so um you add

00:47:48,390 --> 00:47:54,310
so you add something to the pool and the

00:47:52,480 --> 00:47:57,430
pool has a stood vector of shared photos

00:47:54,310 --> 00:47:58,810
to avoid and share photos to avoid is

00:47:57,430 --> 00:48:01,840
really one of my favorite features in

00:47:58,810 --> 00:48:03,280
the standard library because it's recall

00:48:01,840 --> 00:48:07,060
so what it can do it's like a shared put

00:48:03,280 --> 00:48:09,370
er to a widget except that you can give

00:48:07,060 --> 00:48:11,530
it any object you can give it a pointer

00:48:09,370 --> 00:48:13,600
to an int or to a string or to a widget

00:48:11,530 --> 00:48:15,880
or whatever and we'll swallow it and it

00:48:13,600 --> 00:48:17,350
will share this like ownership reference

00:48:15,880 --> 00:48:18,730
count with all the other shared pointers

00:48:17,350 --> 00:48:23,650
through these objects so this part will

00:48:18,730 --> 00:48:25,330
work but and you can use it for any type

00:48:23,650 --> 00:48:27,280
and the best thing is that this thing

00:48:25,330 --> 00:48:28,900
will also remember it will have like

00:48:27,280 --> 00:48:31,600
some it has some trickery inside where

00:48:28,900 --> 00:48:33,040
it remembers the actual deleter for that

00:48:31,600 --> 00:48:34,750
object so if this thing goes out of

00:48:33,040 --> 00:48:37,500
scope it will actually call the right

00:48:34,750 --> 00:48:40,840
destructor for the right polymorphic

00:48:37,500 --> 00:48:42,580
type that the object actually has and it

00:48:40,840 --> 00:48:44,290
knows this because when you edit this to

00:48:42,580 --> 00:48:46,060
uni constructor to share put it avoid it

00:48:44,290 --> 00:48:48,220
has some type of razor thing and it

00:48:46,060 --> 00:48:49,720
remembers the corrected litre so it does

00:48:48,220 --> 00:48:53,260
what you expect it to do and this is

00:48:49,720 --> 00:48:55,360
this is really nice so you actually can

00:48:53,260 --> 00:48:57,370
have one pool so the original version of

00:48:55,360 --> 00:48:58,420
this was templated for widget but you

00:48:57,370 --> 00:49:00,070
can have actually one pool per

00:48:58,420 --> 00:49:03,670
application it will swallow happily

00:49:00,070 --> 00:49:06,060
swallow all your objects so you add you

00:49:03,670 --> 00:49:08,650
add an object to the pool this will just

00:49:06,060 --> 00:49:10,180
in place back a new shared putter to

00:49:08,650 --> 00:49:12,850
void for that object so the reference

00:49:10,180 --> 00:49:15,190
count will go one up and then you have a

00:49:12,850 --> 00:49:17,410
timer callback which is called I don't

00:49:15,190 --> 00:49:19,030
know third maybe once per second or

00:49:17,410 --> 00:49:21,520
something on a very low priority thread

00:49:19,030 --> 00:49:23,110
and what it does it just goes through

00:49:21,520 --> 00:49:26,590
this pool which is this vector of shared

00:49:23,110 --> 00:49:28,390
photos and whenever the use count is

00:49:26,590 --> 00:49:30,010
smaller or equal one which means that

00:49:28,390 --> 00:49:33,100
this pool is the only class which is

00:49:30,010 --> 00:49:39,280
referencing that object it just deletes

00:49:33,100 --> 00:49:41,650
it and yeah this way you get rid you get

00:49:39,280 --> 00:49:45,820
rid of that problem here what not sorry

00:49:41,650 --> 00:49:47,230
where was it here so yeah that's a very

00:49:45,820 --> 00:49:48,310
nice trick you can you can do to avoid

00:49:47,230 --> 00:49:50,490
deletes and yodefat

00:49:48,310 --> 00:49:50,490
yes

00:49:53,150 --> 00:50:01,819
memory for the pool so that you don't

00:49:54,980 --> 00:50:04,299
have a gate around me bad yeah yeah so

00:50:01,819 --> 00:50:06,829
so the way this thing is written that

00:50:04,299 --> 00:50:08,180
the ads you would not call this on the

00:50:06,829 --> 00:50:09,829
real time thread so you see there's also

00:50:08,180 --> 00:50:12,980
a normal mutex in here

00:50:09,829 --> 00:50:14,720
so the adding adding to the pool will

00:50:12,980 --> 00:50:16,759
not happen in the real time threat like

00:50:14,720 --> 00:50:20,680
here this happens in the in the GUI

00:50:16,759 --> 00:50:23,240
thread and then you don't have a problem

00:50:20,680 --> 00:50:24,650
you can have it's like the minimal code

00:50:23,240 --> 00:50:26,029
you need for this implementation you can

00:50:24,650 --> 00:51:08,299
have a more sophisticated version of

00:50:26,029 --> 00:51:10,220
this yes sounds like it could work we

00:51:08,299 --> 00:51:17,359
can we can maybe talk about this in more

00:51:10,220 --> 00:51:18,559
detail aft after talk I I mean you need

00:51:17,359 --> 00:51:52,069
to make sure that it's locked free and

00:51:18,559 --> 00:51:53,630
synchronize on everything all right yeah

00:51:52,069 --> 00:51:55,700
you can do that so you can like

00:51:53,630 --> 00:51:58,249
precompute like a big buffer and then

00:51:55,700 --> 00:52:00,289
have chunks of that that actually the

00:51:58,249 --> 00:52:02,480
audio spread seized with a with a

00:52:00,289 --> 00:52:04,309
smaller yeah you can do this but then

00:52:02,480 --> 00:52:07,040
the overall latency will still be the

00:52:04,309 --> 00:52:29,810
big buffer right so you

00:52:07,040 --> 00:52:31,460
we don't want to do this if you are yeah

00:52:29,810 --> 00:52:33,350
I mean if you have a luxury way of

00:52:31,460 --> 00:52:35,480
picking which one is the next that you

00:52:33,350 --> 00:52:38,840
audio buffer should take then yeah I

00:52:35,480 --> 00:52:40,460
guess this would work we can we can talk

00:52:38,840 --> 00:52:41,840
about this in more detail after after

00:52:40,460 --> 00:52:44,720
the talk because I think we are sort of

00:52:41,840 --> 00:52:46,670
running out of time a little bit I have

00:52:44,720 --> 00:52:51,620
like six minutes left

00:52:46,670 --> 00:52:54,320
okay so sorry all right all right so I'm

00:52:51,620 --> 00:52:57,560
almost done so let me just quickly go

00:52:54,320 --> 00:52:59,270
through one more important thing is so

00:52:57,560 --> 00:53:00,920
that was if you want to share like a

00:52:59,270 --> 00:53:02,600
particular object between the oldest FET

00:53:00,920 --> 00:53:05,690
and other threads so what if you want to

00:53:02,600 --> 00:53:07,820
exchange data like for example here you

00:53:05,690 --> 00:53:09,230
have maybe user pressing keys and you

00:53:07,820 --> 00:53:11,210
have messages about the key presses

00:53:09,230 --> 00:53:12,950
coming in or maybe some data from the

00:53:11,210 --> 00:53:14,960
network or from the disk coming in and

00:53:12,950 --> 00:53:17,690
you want in the audio callback you want

00:53:14,960 --> 00:53:19,520
to process these messages and then the

00:53:17,690 --> 00:53:23,570
audio that you generate depends on that

00:53:19,520 --> 00:53:28,520
and you want to do this in a lock free

00:53:23,570 --> 00:53:30,170
way so um the traditional or the best

00:53:28,520 --> 00:53:33,350
way to do this in audio context is to

00:53:30,170 --> 00:53:35,300
use a lock free cue and I think the lock

00:53:33,350 --> 00:53:38,600
free cue is or the block B file it's

00:53:35,300 --> 00:53:42,740
really the most important data structure

00:53:38,600 --> 00:53:44,660
in an audio code and if it has a fixed

00:53:42,740 --> 00:53:45,980
maximum size and it's actually a lock

00:53:44,660 --> 00:53:47,330
free ring buffer and I think this is

00:53:45,980 --> 00:53:49,010
like it was like the data structure that

00:53:47,330 --> 00:53:52,160
solves many many problems in all your

00:53:49,010 --> 00:53:55,280
code and there are implementations of

00:53:52,160 --> 00:53:56,900
lock free queues there's one in juice we

00:53:55,280 --> 00:53:58,670
have one there's one in boost and boost

00:53:56,900 --> 00:54:00,380
lock free and there many people here who

00:53:58,670 --> 00:54:02,330
know how to properly write lock free

00:54:00,380 --> 00:54:03,860
queues so I probably should not show

00:54:02,330 --> 00:54:05,570
this code here those would also take a

00:54:03,860 --> 00:54:08,840
long time you could do a whole talk just

00:54:05,570 --> 00:54:10,490
about that so let me just quickly

00:54:08,840 --> 00:54:12,620
mention like how you would use it in a

00:54:10,490 --> 00:54:14,240
more abstract abstract way and if

00:54:12,620 --> 00:54:15,770
possible you want to have like a single

00:54:14,240 --> 00:54:16,910
thread that writes to it and a single

00:54:15,770 --> 00:54:19,820
thread that reads through it because you

00:54:16,910 --> 00:54:20,520
have you can have multiple producers but

00:54:19,820 --> 00:54:21,900
then

00:54:20,520 --> 00:54:23,790
the code gets more complicated so

00:54:21,900 --> 00:54:25,530
instead of coming up with these data

00:54:23,790 --> 00:54:27,120
structures and audio code it's typically

00:54:25,530 --> 00:54:28,980
easier to actually restructure your code

00:54:27,120 --> 00:54:31,380
to have one reading and more item thread

00:54:28,980 --> 00:54:34,650
and if you have a lock free block free

00:54:31,380 --> 00:54:36,510
ring buffer like this then typically if

00:54:34,650 --> 00:54:38,370
it's this way around you have another

00:54:36,510 --> 00:54:39,960
thread which maybe gets these messages

00:54:38,370 --> 00:54:43,590
from the keyboard or read something from

00:54:39,960 --> 00:54:46,950
the disk and writes them writes them

00:54:43,590 --> 00:54:48,570
into into the the buffer and lockrey

00:54:46,950 --> 00:54:50,100
means that you have a push and a pop

00:54:48,570 --> 00:54:51,960
method and they are implemented block

00:54:50,100 --> 00:54:53,070
free with these atomic swaps atomic

00:54:51,960 --> 00:54:57,960
compare exchanges that you saw earlier

00:54:53,070 --> 00:54:59,940
and it's possible to implement that so

00:54:57,960 --> 00:55:01,980
you will have a thread that's pushing

00:54:59,940 --> 00:55:06,240
items here and you will have the audio

00:55:01,980 --> 00:55:09,620
thread that goes around steadily as the

00:55:06,240 --> 00:55:12,060
audio callbacks tick and pops items and

00:55:09,620 --> 00:55:14,070
in this covers loads of different use

00:55:12,060 --> 00:55:16,530
cases wherever you you reading audio

00:55:14,070 --> 00:55:19,110
from a disk or you getting live messages

00:55:16,530 --> 00:55:23,400
from some hardware device this this data

00:55:19,110 --> 00:55:25,170
structure is really almost like a Swiss

00:55:23,400 --> 00:55:26,880
Army knife that solves most of these

00:55:25,170 --> 00:55:29,220
problems the only thing that you really

00:55:26,880 --> 00:55:30,630
have to take care of is what happens if

00:55:29,220 --> 00:55:35,970
one of these pointers overtakes the

00:55:30,630 --> 00:55:39,570
other so if you have for example a new

00:55:35,970 --> 00:55:41,730
note comes in and the this one overtakes

00:55:39,570 --> 00:55:43,980
the audio thread then it means that the

00:55:41,730 --> 00:55:45,930
audience read hasn't yet written that so

00:55:43,980 --> 00:55:48,330
but the old effect needs to continue

00:55:45,930 --> 00:55:50,010
somehow so either you display you

00:55:48,330 --> 00:55:52,560
display an error like oh I'm too slow

00:55:50,010 --> 00:55:54,900
like I'm too slow to to process audio or

00:55:52,560 --> 00:55:57,600
maybe you can fade out into silence so

00:55:54,900 --> 00:55:59,190
this is one one case that you have to

00:55:57,600 --> 00:56:01,140
explicitly handle and this heavily

00:55:59,190 --> 00:56:03,720
depends on on your actual use case for

00:56:01,140 --> 00:56:06,330
this and the other use case that you

00:56:03,720 --> 00:56:09,300
have to handle is if the audio thread

00:56:06,330 --> 00:56:11,430
over takes the reader over takes the

00:56:09,300 --> 00:56:13,890
writer then it means that here it will

00:56:11,430 --> 00:56:15,270
get like the this is the oldest all this

00:56:13,890 --> 00:56:18,030
data it's like the newest one and this

00:56:15,270 --> 00:56:20,070
is the oldest one so we go this way

00:56:18,030 --> 00:56:21,780
around this this just means that there's

00:56:20,070 --> 00:56:23,610
no data which means that if there are

00:56:21,780 --> 00:56:25,560
notes then there's just no notes played

00:56:23,610 --> 00:56:27,330
so you don't have to do anything or if

00:56:25,560 --> 00:56:29,160
they're supposed to be like live audio

00:56:27,330 --> 00:56:30,600
stream coming from somewhere and it's

00:56:29,160 --> 00:56:33,180
not there then also you have to somehow

00:56:30,600 --> 00:56:34,200
shut down in a reasonable way so so

00:56:33,180 --> 00:56:36,720
these two cases

00:56:34,200 --> 00:56:37,829
where one overtakes the other is really

00:56:36,720 --> 00:56:40,010
the only thing that you have to care

00:56:37,829 --> 00:56:42,630
about which depends on your use case

00:56:40,010 --> 00:56:44,820
otherwise this data structure solves

00:56:42,630 --> 00:56:46,950
most of your problems also the other way

00:56:44,820 --> 00:56:49,650
around if you have the audio codec going

00:56:46,950 --> 00:56:51,329
to generates data maybe you want to you

00:56:49,650 --> 00:56:53,310
know visualize the audio like you have

00:56:51,329 --> 00:56:56,280
like a audio generator and you want to

00:56:53,310 --> 00:56:57,720
have some visualization of that audio

00:56:56,280 --> 00:57:00,030
for the user or you want to write this

00:56:57,720 --> 00:57:03,530
to the disk the difference here is that

00:57:00,030 --> 00:57:05,940
then the data is written in a continuous

00:57:03,530 --> 00:57:09,000
rhythm because the audio callback is

00:57:05,940 --> 00:57:10,349
like a regular regular tick so it's the

00:57:09,000 --> 00:57:13,410
same thing the other way around the

00:57:10,349 --> 00:57:15,869
audio thread just pushes its data

00:57:13,410 --> 00:57:17,700
regularly and just goes round and round

00:57:15,869 --> 00:57:22,770
and round and then you have some thread

00:57:17,700 --> 00:57:24,660
that pops up pops these chunks of data

00:57:22,770 --> 00:57:27,089
that can be really anything it depends

00:57:24,660 --> 00:57:31,890
on your use case and does something with

00:57:27,089 --> 00:57:34,859
them and here are really the only thing

00:57:31,890 --> 00:57:36,240
that you want to make sure is that this

00:57:34,859 --> 00:57:38,099
one doesn't overtake the audio thread

00:57:36,240 --> 00:57:39,660
but this way around is actually much

00:57:38,099 --> 00:57:41,490
easier because for example if you want

00:57:39,660 --> 00:57:43,020
to render you want to render your audio

00:57:41,490 --> 00:57:44,369
on the screen like this for example you

00:57:43,020 --> 00:57:47,010
want to have something that represents

00:57:44,369 --> 00:57:50,280
your audio visually then you don't care

00:57:47,010 --> 00:57:52,140
you don't have this real time problem

00:57:50,280 --> 00:57:53,970
that if you drop like a visual frame

00:57:52,140 --> 00:57:55,440
nobody will even notice that's like the

00:57:53,970 --> 00:57:56,819
big difference between audio and video

00:57:55,440 --> 00:57:58,890
for example no one will notice if you

00:57:56,819 --> 00:58:01,109
drop like one of the I don't know 60

00:57:58,890 --> 00:58:02,670
frames per second visually it's just the

00:58:01,109 --> 00:58:04,829
audio where you can immediately hear it

00:58:02,670 --> 00:58:07,950
so what you can here do is you can

00:58:04,829 --> 00:58:09,480
actually work with much larger buffers

00:58:07,950 --> 00:58:11,280
and you can say okay if the audio

00:58:09,480 --> 00:58:13,650
where's the audio thread where's the

00:58:11,280 --> 00:58:15,420
audio is we currently are writing to and

00:58:13,650 --> 00:58:18,119
just take like a chunk of memory just

00:58:15,420 --> 00:58:20,220
just before that and just render that

00:58:18,119 --> 00:58:21,720
and then you will be fine and the only

00:58:20,220 --> 00:58:23,819
thing you have to make sure is that as

00:58:21,720 --> 00:58:25,829
this goes round and round it will never

00:58:23,819 --> 00:58:27,030
actually reach that area and you can

00:58:25,829 --> 00:58:29,040
actually do this by just making your

00:58:27,030 --> 00:58:30,480
buffer large enough and then you don't

00:58:29,040 --> 00:58:33,359
even have any of these synchronization

00:58:30,480 --> 00:58:35,609
issues anymore so so this is also common

00:58:33,359 --> 00:58:37,849
I think common pattern in an audio code

00:58:35,609 --> 00:58:41,640
that solves a lots of problems

00:58:37,849 --> 00:58:44,369
alright so that's all I have I really

00:58:41,640 --> 00:58:45,930
would like to continue at the next

00:58:44,369 --> 00:58:47,550
occasion talking about more of the

00:58:45,930 --> 00:58:49,940
aspects of audio code

00:58:47,550 --> 00:59:03,530
this is everything I have for now so

00:58:49,940 --> 00:59:03,530
thanks for listening any questions yes

00:59:08,360 --> 00:59:12,270
well typically you would have like if

00:59:10,770 --> 00:59:13,560
you have like a software we can add like

00:59:12,270 --> 00:59:17,280
a hundred plugins you will have like a

00:59:13,560 --> 00:59:18,870
CPU meter and then as the user adds the

00:59:17,280 --> 00:59:20,940
effects you will see that this goes up

00:59:18,870 --> 00:59:22,950
and then you can just display like a

00:59:20,940 --> 00:59:26,190
message to the user oh like there was an

00:59:22,950 --> 00:59:28,080
audio drop out like I can't handle this

00:59:26,190 --> 00:59:51,300
so this is what what many productions

00:59:28,080 --> 00:59:55,370
software programs do yes yeah I think

00:59:51,300 --> 00:59:57,570
actually if a float is atomic on your

00:59:55,370 --> 01:00:01,970
hardware then actually the compiler

00:59:57,570 --> 01:00:01,970
would generate the same code I think oh

01:00:04,550 --> 01:00:10,050
yeah and yeah actually you're right so

01:00:08,130 --> 01:00:13,260
this this code will be more efficient if

01:00:10,050 --> 01:00:21,410
you if you would put this up here yeah

01:00:13,260 --> 01:00:21,410
sure yeah so that's a typo yeah yeah yes

01:00:28,420 --> 01:00:42,140
yeah um condition you like waiting the

01:00:40,940 --> 01:00:45,490
audio start waiting on a condition

01:00:42,140 --> 01:00:45,490
variable but then you're waiting again

01:00:49,690 --> 01:00:56,180
would that be lock-free I don't know if

01:00:54,680 --> 01:01:02,569
I don't know that's luxury I'm not going

01:00:56,180 --> 01:01:04,849
to use it an audio card like like notify

01:01:02,569 --> 01:01:06,230
one notify all these things I don't know

01:01:04,849 --> 01:01:07,990
if they're luxury maybe somebody can

01:01:06,230 --> 01:01:13,819
tell me I don't think so

01:01:07,990 --> 01:01:42,950
so no please note don't use them yeah

01:01:13,819 --> 01:01:44,660
yes yes so the thing with all these

01:01:42,950 --> 01:01:47,420
these are just examples like it so much

01:01:44,660 --> 01:01:48,920
depends on your use case which solution

01:01:47,420 --> 01:01:52,730
you actually want to do let me just find

01:01:48,920 --> 01:01:55,520
this the slide here so yeah probably I

01:01:52,730 --> 01:01:56,990
mean what you can do here is if you have

01:01:55,520 --> 01:01:58,910
this pointer in the audio spread for

01:01:56,990 --> 01:02:00,430
example you can do like a atomic swap

01:01:58,910 --> 01:02:02,900
where you can set this to now put er

01:02:00,430 --> 01:02:04,940
like it's a flag I'm using this in the

01:02:02,900 --> 01:02:06,710
audio right now and then you can spin

01:02:04,940 --> 01:02:08,089
wait in the gwee sweat on that thing not

01:02:06,710 --> 01:02:11,710
being an output or anymore something

01:02:08,089 --> 01:02:11,710
like this so they're definitely used

01:02:11,980 --> 01:02:17,380
yeah so so that's also a way to do this

01:02:20,340 --> 01:02:24,400
yeah so so it really depends on your use

01:02:22,960 --> 01:02:25,780
case if the weather were just like a

01:02:24,400 --> 01:02:28,240
small one maybe it's like an envelope

01:02:25,780 --> 01:02:29,980
with I don't know three parameters or

01:02:28,240 --> 01:02:58,270
maybe it's like a one megabyte sound

01:02:29,980 --> 01:02:59,560
file so that hmm yeah well what well in

01:02:58,270 --> 01:03:01,060
this case for example even if you have a

01:02:59,560 --> 01:03:02,920
big object like that imagine you have

01:03:01,060 --> 01:03:05,080
like a sound file that's your object

01:03:02,920 --> 01:03:06,250
it's huge it's like one megabyte but

01:03:05,080 --> 01:03:07,900
then if you're reading this from this

01:03:06,250 --> 01:03:10,090
could definitely in the end you have to

01:03:07,900 --> 01:03:11,770
create a new object right because it's

01:03:10,090 --> 01:03:18,130
actually new data so you have to create

01:03:11,770 --> 01:03:23,950
a new object for it yeah and if it's

01:03:18,130 --> 01:03:26,530
something else maybe you can just so if

01:03:23,950 --> 01:03:28,660
you can boil it down to some like floats

01:03:26,530 --> 01:03:30,160
or ins that you are changing then you

01:03:28,660 --> 01:03:33,220
don't need this then you can work with

01:03:30,160 --> 01:03:37,530
atomic atomic fundamental types that's

01:03:33,220 --> 01:03:41,250
always better of course yeah all right

01:03:37,530 --> 01:03:41,250

YouTube URL: https://www.youtube.com/watch?v=boPEO2auJj4


