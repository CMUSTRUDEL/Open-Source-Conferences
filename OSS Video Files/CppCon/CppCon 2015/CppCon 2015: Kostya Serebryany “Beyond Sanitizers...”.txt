Title: CppCon 2015: Kostya Serebryany “Beyond Sanitizers...”
Publication date: 2015-10-09
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
CppCon 2015: Kostya Serebryany “Beyond Sanitizers: Fuzzing and Hardening your C++ apps for Security & Reliability”

Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
At CppCon’2014 we presented the Sanitizers, a family of dynamic testing tools for C++. These tools allow you to find many stability and security bugs in C++ code, but they are only as good as your tests are. In this talk we will show how to improve your tests with guided fuzzing and how to protect your applications in production even if some bugs were not found. Fuzzing, or fuzz testing, is a surprisingly effective technique that allows you to discover new interesting test inputs. Coverage-guided fuzzing uses coverage-like code instrumentation to make fuzzing orders of magnitude more efficient. Taint-guided fuzzing goes even further by using taint tracking techniques. The next line of defense may be incorporated directly into production: the Control Flow Integrity instrumentation allows you to protect your program from corrupted function pointers (including pointers to virtual tables) and separating stack variables from the call stack protects from corrupted return addresses -- both with near-zero overhead. We will concentrate on particular tools implemented in the opensource LLVM toolchain (libFuzzer, DataFlowSanitizer, -fsanitize=cfi,safe_stack), but will also discuss several alternatives.
— 
Konstantin (Kostya) Serebryany is a Software Engineer at Google. His team develops and deploys dynamic testing tools, such as AddressSanitizer and ThreadSanitizer. Prior to joining Google in 2007, Konstantin spent 4 years at Elbrus/MCST working for Sun compiler lab and then 3 years at Intel Compiler Lab. Konstantin holds a PhD from mesi.ru and a Master from msu.ru.Twitter handle: @kayseesee
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,830
my talk today is titled beyond

00:00:01,650 --> 00:00:07,649
sanitizers but if you want to talk about

00:00:04,830 --> 00:00:10,019
something that is beyond sanitizers I

00:00:07,649 --> 00:00:12,059
want to first make sure that the

00:00:10,019 --> 00:00:14,519
audience knows what the sanitizer saw

00:00:12,059 --> 00:00:18,210
please raise your hands who knows what

00:00:14,519 --> 00:00:20,760
these tools are good please raise your

00:00:18,210 --> 00:00:23,730
hands who knows who actually tried these

00:00:20,760 --> 00:00:27,720
tools at least one perfect perfect

00:00:23,730 --> 00:00:30,449
you're my audience so I would still

00:00:27,720 --> 00:00:32,840
remind you some of the details about the

00:00:30,449 --> 00:00:36,719
sanitizer hopefully I will be quick

00:00:32,840 --> 00:00:40,590
today and the other two topics I want to

00:00:36,719 --> 00:00:45,289
to talk to today is fast testing and

00:00:40,590 --> 00:00:48,719
code hardening let's start from the

00:00:45,289 --> 00:00:51,149
recap of my talk at CP takan last year

00:00:48,719 --> 00:00:52,829
so the same time you said dynamic

00:00:51,149 --> 00:00:56,309
testing tools based primarily on

00:00:52,829 --> 00:00:57,870
compile-time instrumentation and dynamic

00:00:56,309 --> 00:01:03,750
testing means that you actually have to

00:00:57,870 --> 00:01:06,290
run the application to test it first the

00:01:03,750 --> 00:01:08,610
tool that appears in first and chronic

00:01:06,290 --> 00:01:11,210
chronological order is called a sin or

00:01:08,610 --> 00:01:17,430
address sanitizer and it find bugs

00:01:11,210 --> 00:01:20,250
related to address in memory and I won't

00:01:17,430 --> 00:01:24,299
go into details of how the Tool Works I

00:01:20,250 --> 00:01:27,509
will just show what it does suppose you

00:01:24,299 --> 00:01:30,810
have a program and this light has a very

00:01:27,509 --> 00:01:35,390
simple C or C++ program that has an

00:01:30,810 --> 00:01:38,400
obvious bug you overflow a global buffer

00:01:35,390 --> 00:01:40,770
all you need is to compile this

00:01:38,400 --> 00:01:43,320
application with a single switch in this

00:01:40,770 --> 00:01:45,840
case it's f sanitize address and then

00:01:43,320 --> 00:01:50,700
you run the application if the bug

00:01:45,840 --> 00:01:54,360
happens at runtime the tool will report

00:01:50,700 --> 00:01:56,189
an error with all the details like the

00:01:54,360 --> 00:01:58,920
current stack trace the type of the bug

00:01:56,189 --> 00:02:01,409
the dresses and some information about

00:01:58,920 --> 00:02:03,570
memory that has been accessed

00:02:01,409 --> 00:02:08,160
incorrectly and the tool will abort

00:02:03,570 --> 00:02:12,239
after reporting in are a little bit more

00:02:08,160 --> 00:02:13,770
fancy example is used after three done

00:02:12,239 --> 00:02:15,210
the same thing you compile

00:02:13,770 --> 00:02:19,110
the program with the special switch

00:02:15,210 --> 00:02:22,350
around it if the dangling pointer was

00:02:19,110 --> 00:02:26,730
used the tool will report and the board

00:02:22,350 --> 00:02:30,780
a more forensic kind of dangling pointer

00:02:26,730 --> 00:02:33,240
we call it stack use of tur turn it's

00:02:30,780 --> 00:02:35,730
when you take an address of a local

00:02:33,240 --> 00:02:39,570
variable on the stack you leak it

00:02:35,730 --> 00:02:41,850
somewhere into a global state you exit

00:02:39,570 --> 00:02:44,220
the function and then you continue using

00:02:41,850 --> 00:02:50,550
this pointer how many of you have

00:02:44,220 --> 00:02:54,900
debugged such bugs in the wild we share

00:02:50,550 --> 00:02:57,750
the same pain the tool can find this

00:02:54,900 --> 00:03:01,410
bugs relatively simple relatively easily

00:02:57,750 --> 00:03:04,020
and it will also show you which local

00:03:01,410 --> 00:03:09,090
variable of an egg of a function that

00:03:04,020 --> 00:03:11,580
has already exited was used second tool

00:03:09,090 --> 00:03:14,520
called TC and thread sanitizer is about

00:03:11,580 --> 00:03:18,480
concurrency bugs and concurrency bug the

00:03:14,520 --> 00:03:22,650
primarily data races this example using

00:03:18,480 --> 00:03:24,930
C++ 11 has an obvious data race we're

00:03:22,650 --> 00:03:27,270
accessing the same memory location from

00:03:24,930 --> 00:03:29,970
did from two different threads at least

00:03:27,270 --> 00:03:33,000
one of these excesses is a right

00:03:29,970 --> 00:03:34,320
actually two on this example again you

00:03:33,000 --> 00:03:35,490
compile the application with a

00:03:34,320 --> 00:03:38,970
difference which you have Sinnott

00:03:35,490 --> 00:03:42,300
icicles thread you run it and if a data

00:03:38,970 --> 00:03:45,959
race could have potentially appeared in

00:03:42,300 --> 00:03:47,670
this execution the tool will flag it it

00:03:45,959 --> 00:03:49,709
doesn't necessarily mean that the

00:03:47,670 --> 00:03:52,380
particular data race happened during

00:03:49,709 --> 00:03:55,340
this execution I mean that the memory

00:03:52,380 --> 00:04:00,690
accesses happened in the same cpu cycles

00:03:55,340 --> 00:04:03,750
in the same cpu cycle in two threads a

00:04:00,690 --> 00:04:06,270
third tool memory sanitizer it finds

00:04:03,750 --> 00:04:10,010
bugs related to to the contents of

00:04:06,270 --> 00:04:14,489
memory and more specifically it finds

00:04:10,010 --> 00:04:16,650
users of uninitialized memory if you

00:04:14,489 --> 00:04:20,100
have some memory block either and stack

00:04:16,650 --> 00:04:23,729
of heap and if you forgot to initialize

00:04:20,100 --> 00:04:26,160
it completely and then if the code is

00:04:23,729 --> 00:04:26,880
using this memory block in a way that it

00:04:26,160 --> 00:04:30,420
will

00:04:26,880 --> 00:04:33,180
the program execution the tool at

00:04:30,420 --> 00:04:38,250
runtime will report this fact to you and

00:04:33,180 --> 00:04:40,590
it will also show you some details about

00:04:38,250 --> 00:04:42,240
the memory location in question if this

00:04:40,590 --> 00:04:44,610
is a stack variable it will show you the

00:04:42,240 --> 00:04:47,160
function name and the name of the

00:04:44,610 --> 00:04:48,690
variable and on the call stack if it's

00:04:47,160 --> 00:04:53,130
hiep it will show you the heap

00:04:48,690 --> 00:04:55,140
allocation stack trace finally last but

00:04:53,130 --> 00:04:58,710
not least you'll be son which stands for

00:04:55,140 --> 00:05:01,470
undefined behavior sanitizer it finds

00:04:58,710 --> 00:05:03,600
many many many other kinds of undefined

00:05:01,470 --> 00:05:05,970
behavior in fact you besides isn't is

00:05:03,600 --> 00:05:08,820
not a single tool it's an umbrella for a

00:05:05,970 --> 00:05:10,740
couple of dozens of checkers that do

00:05:08,820 --> 00:05:14,100
different things and i will show you

00:05:10,740 --> 00:05:16,140
just one of them the most obviously the

00:05:14,100 --> 00:05:19,740
most well-known kind of bug integer

00:05:16,140 --> 00:05:21,570
overflow signed integer overflow if you

00:05:19,740 --> 00:05:24,570
have that in your program if it happens

00:05:21,570 --> 00:05:27,990
during the execution of a test the tool

00:05:24,570 --> 00:05:29,820
will report to you the place in the

00:05:27,990 --> 00:05:33,420
program that happens and the actual

00:05:29,820 --> 00:05:37,560
values that data part of the integer

00:05:33,420 --> 00:05:39,900
overflow the next slide is prepared by

00:05:37,560 --> 00:05:44,310
the marketing team of the sanitizers

00:05:39,900 --> 00:05:47,360
group and it says what itself sanitizers

00:05:44,310 --> 00:05:49,890
has found thousands of bugs everywhere

00:05:47,360 --> 00:05:52,440
everyone we try it everywhere our users

00:05:49,890 --> 00:05:55,650
try it etcetera and there are some proof

00:05:52,440 --> 00:05:59,130
links if you want to go for later

00:05:55,650 --> 00:06:01,200
offline but the sanitizers are not

00:05:59,130 --> 00:06:05,790
enough and we've learned it in a hard

00:06:01,200 --> 00:06:09,090
way we've been applying the sanitizers

00:06:05,790 --> 00:06:11,490
too many of our applications finding

00:06:09,090 --> 00:06:13,140
tons of bugs releasing the applications

00:06:11,490 --> 00:06:17,010
into production and catching more bugs

00:06:13,140 --> 00:06:19,350
in production in the hard way this is

00:06:17,010 --> 00:06:23,670
because of the two fundamental problems

00:06:19,350 --> 00:06:27,030
first the sanitizers are only as good as

00:06:23,670 --> 00:06:31,500
your tests and the tests actually tend

00:06:27,030 --> 00:06:33,000
to be bad unfortunately and and second

00:06:31,500 --> 00:06:36,270
fundamental problem is that the

00:06:33,000 --> 00:06:38,330
sanitizers being dynamic tools they're

00:06:36,270 --> 00:06:40,220
not any kind of proof of correctness

00:06:38,330 --> 00:06:42,650
they're just best of

00:06:40,220 --> 00:06:45,770
tools if you find a bug you know you

00:06:42,650 --> 00:06:47,330
found a bug and if you fix the bug and

00:06:45,770 --> 00:06:49,790
the report disappears you most likely

00:06:47,330 --> 00:06:52,250
fix the bug but if you don't find any

00:06:49,790 --> 00:07:07,880
bug it doesn't give you any information

00:06:52,250 --> 00:07:10,820
you may still have a couple so we needed

00:07:07,880 --> 00:07:13,460
to do something else to extend the way

00:07:10,820 --> 00:07:15,980
we use the sanitizer so maybe two to

00:07:13,460 --> 00:07:18,350
implement something different to protect

00:07:15,980 --> 00:07:21,350
ourselves route from the bugs and and

00:07:18,350 --> 00:07:24,770
there are many many ways to do this I

00:07:21,350 --> 00:07:27,020
will just talk about two things first we

00:07:24,770 --> 00:07:30,170
need to somehow improve the test quality

00:07:27,020 --> 00:07:34,010
or in other words test coverage and one

00:07:30,170 --> 00:07:36,010
of the ways to do it is called fuzzy the

00:07:34,010 --> 00:07:39,680
second thing I'm going to discuss today

00:07:36,010 --> 00:07:42,770
is called code hardening and it is a way

00:07:39,680 --> 00:07:44,690
to protect your code and production in

00:07:42,770 --> 00:07:47,960
the assumption that you still have bugs

00:07:44,690 --> 00:07:50,120
you you don't know what these bugs are

00:07:47,960 --> 00:07:53,210
but you know that there are some out

00:07:50,120 --> 00:07:59,600
there and you need to protect your

00:07:53,210 --> 00:08:03,380
security from these unknown bugs okay

00:07:59,600 --> 00:08:09,050
the first part is fuzzing who knows the

00:08:03,380 --> 00:08:12,260
term good and this is what wikipedia has

00:08:09,050 --> 00:08:15,169
to say about fuzzing essentially it is

00:08:12,260 --> 00:08:18,020
feeding random garbage into your

00:08:15,169 --> 00:08:19,880
application and trying to observe what

00:08:18,020 --> 00:08:22,250
was going on whether it will crash

00:08:19,880 --> 00:08:24,640
whether it will hand well whether it

00:08:22,250 --> 00:08:29,120
will consume enormous resources or so on

00:08:24,640 --> 00:08:31,190
and the dephasing methodology has been

00:08:29,120 --> 00:08:36,320
known for many years now and there are

00:08:31,190 --> 00:08:39,310
subclasses of fuzzing in fact one of the

00:08:36,320 --> 00:08:43,130
very popular ways of fuzzing is called

00:08:39,310 --> 00:08:47,240
generation based it is when you generate

00:08:43,130 --> 00:08:52,030
random tests or partially random tests

00:08:47,240 --> 00:08:54,750
based on based on some rule of course

00:08:52,030 --> 00:08:57,790
fathers can intrude in fact be used

00:08:54,750 --> 00:09:00,970
together with the sanitizers so that you

00:08:57,790 --> 00:09:03,670
when you run a random test you actually

00:09:00,970 --> 00:09:10,270
check for all kinds of undefined

00:09:03,670 --> 00:09:12,550
behavior when you generate inputs

00:09:10,270 --> 00:09:16,830
sometimes the good strategies just to

00:09:12,550 --> 00:09:20,380
generate sequences of sequences of bites

00:09:16,830 --> 00:09:23,260
and most of them will be illegal for the

00:09:20,380 --> 00:09:25,660
particular target application which is

00:09:23,260 --> 00:09:27,420
file you will stress the ability of the

00:09:25,660 --> 00:09:30,550
application to handle illegal data

00:09:27,420 --> 00:09:33,550
sometimes however you want to generate

00:09:30,550 --> 00:09:35,200
only legal data and this is much more

00:09:33,550 --> 00:09:37,630
challenging because then you need to

00:09:35,200 --> 00:09:43,090
build some kind of specialized logic

00:09:37,630 --> 00:09:47,410
into your generator it is often very

00:09:43,090 --> 00:09:50,170
very convenient to generate to generate

00:09:47,410 --> 00:09:52,480
valid data in the phaser and as an

00:09:50,170 --> 00:09:55,420
example one of my favorite fathers of

00:09:52,480 --> 00:09:57,420
this kind is called C Smith it's a

00:09:55,420 --> 00:10:01,150
father for C compilers it generates

00:09:57,420 --> 00:10:03,250
valid but very very random si si

00:10:01,150 --> 00:10:05,500
programs you can compile them you can

00:10:03,250 --> 00:10:09,070
run them and there is no single compiler

00:10:05,500 --> 00:10:12,550
in the world that could stand a good

00:10:09,070 --> 00:10:14,800
week of fuzzing with ce smith at least

00:10:12,550 --> 00:10:18,760
this was a year ago most of the obvious

00:10:14,800 --> 00:10:22,090
bugs were fixed since then the same the

00:10:18,760 --> 00:10:25,510
approach of generation based phazon is

00:10:22,090 --> 00:10:29,050
very heavily used in industry including

00:10:25,510 --> 00:10:32,620
the chrome security team and this

00:10:29,050 --> 00:10:35,430
particular way was was used to find many

00:10:32,620 --> 00:10:37,930
thousands of bugs in the Chrome browser

00:10:35,430 --> 00:10:40,570
so it's extremely effective and

00:10:37,930 --> 00:10:44,160
efficient yet it often barely scratches

00:10:40,570 --> 00:10:46,630
the surface of of your application

00:10:44,160 --> 00:10:49,870
another completely different approach to

00:10:46,630 --> 00:10:52,180
fuzziness called mutation based the idea

00:10:49,870 --> 00:10:54,820
is that you somehow acquire a test

00:10:52,180 --> 00:10:57,670
corpus a set of valid or almost valid

00:10:54,820 --> 00:11:00,250
inputs for your application you often

00:10:57,670 --> 00:11:05,160
just crawl the web to get the inputs of

00:11:00,250 --> 00:11:07,019
your particular type then you want

00:11:05,160 --> 00:11:08,910
to minimize this corpus because if you

00:11:07,019 --> 00:11:12,149
crawl the web you'll probably get too

00:11:08,910 --> 00:11:15,870
many duplicates too many inputs that are

00:11:12,149 --> 00:11:17,759
not different from each other you want

00:11:15,870 --> 00:11:20,509
to minimize the test corpus according to

00:11:17,759 --> 00:11:23,759
symmetric and the most obvious metric is

00:11:20,509 --> 00:11:26,490
code coverage / execution time so you

00:11:23,759 --> 00:11:29,009
want the tests to be small and very

00:11:26,490 --> 00:11:31,589
quick but also you want the tests to

00:11:29,009 --> 00:11:36,079
cover as much functionality of your

00:11:31,589 --> 00:11:39,420
program as as you can the next step of

00:11:36,079 --> 00:11:41,579
mutations based phasing is that you

00:11:39,420 --> 00:11:45,660
start mutating the tests and the corpus

00:11:41,579 --> 00:11:48,000
and run them of course again it's it's

00:11:45,660 --> 00:11:49,860
best to run them with some kind of run

00:11:48,000 --> 00:11:55,319
time checking sanitizers or something

00:11:49,860 --> 00:11:58,199
else and now experience this kind of

00:11:55,319 --> 00:12:01,439
fuzzing very often gives much better

00:11:58,199 --> 00:12:03,930
coverage much better results than just

00:12:01,439 --> 00:12:06,899
generated fuzzy of course it it actually

00:12:03,930 --> 00:12:09,079
depends on on the on the target

00:12:06,899 --> 00:12:11,939
application what exactly are you fuzzy a

00:12:09,079 --> 00:12:14,670
if for example you want to fast a c++

00:12:11,939 --> 00:12:17,519
compiler pure imitation based fashion

00:12:14,670 --> 00:12:20,339
may be less efficient because it will

00:12:17,519 --> 00:12:22,769
most likely produce lots of invalid C++

00:12:20,339 --> 00:12:26,209
programs and all you will be testing is

00:12:22,769 --> 00:12:31,860
like lecture or at best parser not the

00:12:26,209 --> 00:12:36,630
the interesting layers the next step for

00:12:31,860 --> 00:12:38,819
mutation based fuzzing is what we call

00:12:36,630 --> 00:12:42,000
control flow or guided fashion or

00:12:38,819 --> 00:12:45,060
sometimes coverage guided fuzzy it is a

00:12:42,000 --> 00:12:48,750
say same thing as a mutation bait based

00:12:45,060 --> 00:12:52,110
fuzzy but with some additional steps so

00:12:48,750 --> 00:12:55,399
first first key thing is that you need

00:12:52,110 --> 00:12:59,910
to run all the tests with some kind of

00:12:55,399 --> 00:13:02,120
instrumentation that provides you the

00:12:59,910 --> 00:13:06,269
coverage feedback that tells you where

00:13:02,120 --> 00:13:10,350
the application has been running while

00:13:06,269 --> 00:13:12,509
executing this particular input and you

00:13:10,350 --> 00:13:16,589
need to know when you've hit something

00:13:12,509 --> 00:13:19,050
you you need to be able to say okay this

00:13:16,589 --> 00:13:20,820
input triggered some new code path

00:13:19,050 --> 00:13:23,070
that we have not seen before or maybe

00:13:20,820 --> 00:13:28,980
that we have seen before but very few

00:13:23,070 --> 00:13:31,860
times and then if this is true if if you

00:13:28,980 --> 00:13:34,290
found a test input that is significantly

00:13:31,860 --> 00:13:37,050
new we have to take this test input and

00:13:34,290 --> 00:13:39,320
edit back to the initial corpus so that

00:13:37,050 --> 00:13:43,470
the further mutations will take that

00:13:39,320 --> 00:13:45,899
interesting case and mutate it again now

00:13:43,470 --> 00:13:48,060
experience this approach is often

00:13:45,899 --> 00:13:53,010
several orders of magnitude faster than

00:13:48,060 --> 00:13:55,230
plain mutation based facile any talk

00:13:53,010 --> 00:13:57,930
about fuzzing nowadays or especially

00:13:55,230 --> 00:14:00,329
about mutation based fising is

00:13:57,930 --> 00:14:04,950
impossible without mentioning AF alphas

00:14:00,329 --> 00:14:07,890
who have tried this tool boy I've heard

00:14:04,950 --> 00:14:10,050
about this tool now raise your hands

00:14:07,890 --> 00:14:18,690
you've all heard this about this till

00:14:10,050 --> 00:14:22,649
now so f alphas it's a control flow

00:14:18,690 --> 00:14:24,570
guided puzzle it instruments the the

00:14:22,649 --> 00:14:28,980
target binary at compile time so you

00:14:24,570 --> 00:14:31,680
have to have the sources the regular

00:14:28,980 --> 00:14:33,839
mode instruments on assembly level and

00:14:31,680 --> 00:14:38,220
there is a recent addition that does it

00:14:33,839 --> 00:14:42,750
with lvm compiler the instrumentation

00:14:38,220 --> 00:14:45,839
provides a fix it array of counters 65k

00:14:42,750 --> 00:14:50,270
counters and the counters represent all

00:14:45,839 --> 00:14:50,270
control flow edges in your application

00:14:51,140 --> 00:14:56,850
these are not this is not exact mapping

00:14:54,120 --> 00:15:00,209
between counters and the adjacent

00:14:56,850 --> 00:15:03,120
application so there could be some

00:15:00,209 --> 00:15:04,800
collisions the the counters are in

00:15:03,120 --> 00:15:10,500
precise but they're still good enough

00:15:04,800 --> 00:15:14,730
and they provide quite quite good

00:15:10,500 --> 00:15:17,430
information to to work with the counters

00:15:14,730 --> 00:15:20,130
are 8-bit and they represent eight

00:15:17,430 --> 00:15:23,310
different states like this path was

00:15:20,130 --> 00:15:26,490
executed once twice three times from

00:15:23,310 --> 00:15:31,190
four to seven times and so on it eight

00:15:26,490 --> 00:15:32,690
different states and if a given input

00:15:31,190 --> 00:15:35,750
unit

00:15:32,690 --> 00:15:37,610
produced in you beat in this array it

00:15:35,750 --> 00:15:41,330
means that this this unit is interesting

00:15:37,610 --> 00:15:43,280
we raiding it back to the corpus the

00:15:41,330 --> 00:15:46,400
father itself f of us is a driver

00:15:43,280 --> 00:15:49,130
process and the target application runs

00:15:46,400 --> 00:15:51,830
as a separate process or as a separate

00:15:49,130 --> 00:15:56,690
set of processes depending on the on the

00:15:51,830 --> 00:16:00,170
set up I will not go into further

00:15:56,690 --> 00:16:02,390
details of the FF us but what I want you

00:16:00,170 --> 00:16:05,300
to know about it is that it is not a toy

00:16:02,390 --> 00:16:08,960
so if you have an application that is

00:16:05,300 --> 00:16:12,290
even slightly applicable we're facing is

00:16:08,960 --> 00:16:15,680
even slightly applicable try F alphas

00:16:12,290 --> 00:16:17,480
this is the list of things that f alphas

00:16:15,680 --> 00:16:19,730
of course this is not a complete list

00:16:17,480 --> 00:16:25,300
it's just what wasn't there a website

00:16:19,730 --> 00:16:29,270
two months ago I want to talk more about

00:16:25,300 --> 00:16:32,180
our own baby the little way my team at

00:16:29,270 --> 00:16:36,050
Google developed it is called lvm bleep

00:16:32,180 --> 00:16:38,570
buzzer and lib here stands for two

00:16:36,050 --> 00:16:42,140
things first this is a library and

00:16:38,570 --> 00:16:45,980
second lip father is actually targeted

00:16:42,140 --> 00:16:50,060
at fuzzing it was in other libraries so

00:16:45,980 --> 00:16:52,520
this is lib twice but first I want to

00:16:50,060 --> 00:16:54,350
tell you briefly about coverage

00:16:52,520 --> 00:16:59,060
instrumentation that we have implemented

00:16:54,350 --> 00:17:01,820
an lvm compiler it is under the umbrella

00:16:59,060 --> 00:17:04,280
of F sanitized s cash coverage flag but

00:17:01,820 --> 00:17:08,050
in fact that implements several

00:17:04,280 --> 00:17:10,910
different coverage strategies that

00:17:08,050 --> 00:17:14,720
complement each other first the obvious

00:17:10,910 --> 00:17:18,350
thing is a function of basic block o H

00:17:14,720 --> 00:17:21,260
level coverage one of these three so

00:17:18,350 --> 00:17:22,850
with this kind of coverage you get the

00:17:21,260 --> 00:17:26,270
information where the given function was

00:17:22,850 --> 00:17:29,600
executed at least once during basic

00:17:26,270 --> 00:17:33,350
vocal given age the second kind of

00:17:29,600 --> 00:17:37,060
coverage is in direct calls it gives you

00:17:33,350 --> 00:17:41,440
all the indirect call color clip airs

00:17:37,060 --> 00:17:45,250
during the execution and the third

00:17:41,440 --> 00:17:50,380
flavor is 8-bit counters just like in FL

00:17:45,250 --> 00:17:51,960
which I described earlier this coverage

00:17:50,380 --> 00:17:55,390
instrumentation can provide you feedback

00:17:51,960 --> 00:17:59,410
both after the process has exited in the

00:17:55,390 --> 00:18:01,930
form of file on disk and as in process

00:17:59,410 --> 00:18:05,470
API call so that you can query the

00:18:01,930 --> 00:18:09,160
current state of the coverage inside the

00:18:05,470 --> 00:18:10,990
process itself and the way it is

00:18:09,160 --> 00:18:12,700
implemented now the this coverage

00:18:10,990 --> 00:18:15,760
instrumentation should be combined with

00:18:12,700 --> 00:18:18,330
one of the sanitizers the typical

00:18:15,760 --> 00:18:21,940
slowdown of this coverage is very small

00:18:18,330 --> 00:18:23,920
usually within ten percent although the

00:18:21,940 --> 00:18:26,470
8-bit counters may stand on the way of

00:18:23,920 --> 00:18:29,020
multi-threaded applications because the

00:18:26,470 --> 00:18:33,430
counters are Global's and there is

00:18:29,020 --> 00:18:36,850
contention on them so back back to lib

00:18:33,430 --> 00:18:41,010
father it's a lightweight in process

00:18:36,850 --> 00:18:45,100
control flow guide advisor this is the

00:18:41,010 --> 00:18:49,420
the very short description all you need

00:18:45,100 --> 00:18:51,070
to use this phaser is shown on this

00:18:49,420 --> 00:18:52,660
slide you first of all you need to

00:18:51,070 --> 00:18:56,020
implement your own target application

00:18:52,660 --> 00:18:58,020
your target function in other words a

00:18:56,020 --> 00:19:02,790
function that does something interesting

00:18:58,020 --> 00:19:06,100
using the API is you are trying to test

00:19:02,790 --> 00:19:10,360
the function takes as a player as a

00:19:06,100 --> 00:19:15,460
parameter and array of bytes second you

00:19:10,360 --> 00:19:19,270
need to compile your library with with

00:19:15,460 --> 00:19:20,410
the current coverage instrumentation if

00:19:19,270 --> 00:19:24,090
you don't know which coverage

00:19:20,410 --> 00:19:26,920
instrumentation need you use all of them

00:19:24,090 --> 00:19:30,040
in you need to throw one of the

00:19:26,920 --> 00:19:33,630
sanitizers into the mix and finally you

00:19:30,040 --> 00:19:36,310
just linked with the lib fuzzer library

00:19:33,630 --> 00:19:39,700
lib father is much younger than f of us

00:19:36,310 --> 00:19:42,430
and it is still not as algorithmically

00:19:39,700 --> 00:19:46,870
sophisticated yet it is quite capable as

00:19:42,430 --> 00:19:49,360
I will try to show you again it is not

00:19:46,870 --> 00:19:52,150
tired it is not targeted advising large

00:19:49,360 --> 00:19:55,270
applications it is not good at it it is

00:19:52,150 --> 00:19:59,070
targeted at fuzzing small well small

00:19:55,270 --> 00:19:59,070
medium sized libraries and api's

00:20:00,770 --> 00:20:05,370
suppose you've built a buzzer how do you

00:20:03,000 --> 00:20:08,520
use it first of all you want to acquire

00:20:05,370 --> 00:20:10,500
test corpus somewhere in many cases an

00:20:08,520 --> 00:20:13,710
empty test corpus to start with is

00:20:10,500 --> 00:20:18,840
absolutely fine but if you are facing

00:20:13,710 --> 00:20:21,450
some kind of data format parser or some

00:20:18,840 --> 00:20:24,570
kind of application that that consumes

00:20:21,450 --> 00:20:27,330
very complex data input very highly

00:20:24,570 --> 00:20:32,280
structural input you want an initial

00:20:27,330 --> 00:20:35,190
test corpus you put the corpus in into

00:20:32,280 --> 00:20:37,590
the directory one file per input and

00:20:35,190 --> 00:20:41,250
then you simply run the feather like

00:20:37,590 --> 00:20:44,570
this buzzer and corpus this is all you

00:20:41,250 --> 00:20:46,830
need for the for the basic functionality

00:20:44,570 --> 00:20:50,250
there are lots of knobs in the father

00:20:46,830 --> 00:20:51,990
and the goal of my team in the in the

00:20:50,250 --> 00:20:54,660
coming year is to eliminate all of the

00:20:51,990 --> 00:20:58,710
all of the knobs and just leave the the

00:20:54,660 --> 00:21:01,590
basic the basic way of writing father

00:20:58,710 --> 00:21:04,230
corpus but now there are still knobs

00:21:01,590 --> 00:21:06,720
that you may want to use first of all

00:21:04,230 --> 00:21:09,960
the parallelism how many course you want

00:21:06,720 --> 00:21:15,090
to consume and second the the limit of

00:21:09,960 --> 00:21:20,250
the size of the input tests how big I do

00:21:15,090 --> 00:21:22,380
want the unit the input test to be there

00:21:20,250 --> 00:21:26,640
are lots more knobs you can get them

00:21:22,380 --> 00:21:29,850
from help if flip buzzer discovers some

00:21:26,640 --> 00:21:32,220
you interesting test input it has been

00:21:29,850 --> 00:21:36,210
instantly added to the corpus directory

00:21:32,220 --> 00:21:38,520
and if there are other fuzzer processes

00:21:36,210 --> 00:21:42,810
running on the same machine they will

00:21:38,520 --> 00:21:47,010
pick up the new test inputs if a bug is

00:21:42,810 --> 00:21:48,990
caught or timeout is detected lip buzzer

00:21:47,010 --> 00:21:52,370
will stop the process and dump the

00:21:48,990 --> 00:21:56,340
reproducer on disk so that you will have

00:21:52,370 --> 00:22:02,420
the error message and the reproducer in

00:21:56,340 --> 00:22:05,790
your log file all of it and of course

00:22:02,420 --> 00:22:10,140
one father is always much weaker than

00:22:05,790 --> 00:22:12,360
two fathers if you if you have some some

00:22:10,140 --> 00:22:13,830
interesting application to test

00:22:12,360 --> 00:22:17,010
you want to use all the tools you have

00:22:13,830 --> 00:22:19,020
so you can take the corpus generated by

00:22:17,010 --> 00:22:22,620
one fuzzy lip buzzer for example and

00:22:19,020 --> 00:22:28,559
give it to some other father for example

00:22:22,620 --> 00:22:32,670
fo it works vice versa as well and let's

00:22:28,559 --> 00:22:36,210
go to some examples this is the thing I

00:22:32,670 --> 00:22:39,600
was playing with last week in

00:22:36,210 --> 00:22:41,760
preparation to this presentation leap

00:22:39,600 --> 00:22:45,720
freetype is an open source library for

00:22:41,760 --> 00:22:47,700
parsing and handling truetype fonts and

00:22:45,720 --> 00:22:52,919
actually all kinds of phones as far as I

00:22:47,700 --> 00:22:55,620
understand in the very simple father

00:22:52,919 --> 00:22:59,730
feeds not just into one slide but into a

00:22:55,620 --> 00:23:04,500
half slide all you need is basically to

00:22:59,730 --> 00:23:07,950
pass the array of bytes into the API

00:23:04,500 --> 00:23:10,400
function this is all of course if the if

00:23:07,950 --> 00:23:13,230
the API function has created some object

00:23:10,400 --> 00:23:14,880
you want to destroy this object because

00:23:13,230 --> 00:23:20,299
otherwise the father will run out of

00:23:14,880 --> 00:23:20,299
memory very soon very very soon second

00:23:21,049 --> 00:23:28,770
and here are the results of running this

00:23:24,809 --> 00:23:31,350
father for like three days on a single

00:23:28,770 --> 00:23:36,809
machine well that machine had quite a

00:23:31,350 --> 00:23:40,110
few CPUs but still a single machine you

00:23:36,809 --> 00:23:43,110
can see it has all flavors of most of

00:23:40,110 --> 00:23:47,370
the flavors of the bugs read a buffer

00:23:43,110 --> 00:23:49,770
overflows the most scary from security

00:23:47,370 --> 00:23:51,960
standpoint but there are also all kinds

00:23:49,770 --> 00:23:55,620
of other things for example some test

00:23:51,960 --> 00:23:59,130
inputs consume 17 gigabytes of RAM and I

00:23:55,620 --> 00:24:02,419
was running with with limit of one case

00:23:59,130 --> 00:24:07,530
0 1 K input triggers 17 gigabytes of

00:24:02,419 --> 00:24:09,000
usage and all other weird things by the

00:24:07,530 --> 00:24:11,340
way I should say that everything is

00:24:09,000 --> 00:24:13,950
fixed by now the the developers were

00:24:11,340 --> 00:24:18,540
very happy to see this bug reports

00:24:13,950 --> 00:24:22,490
coming now maybe something more

00:24:18,540 --> 00:24:22,490
interesting openssl

00:24:24,920 --> 00:24:30,420
so the code actually doesn't doesn't fit

00:24:28,320 --> 00:24:32,730
on the same slide there is an init

00:24:30,420 --> 00:24:35,310
function which I have admitted but so

00:24:32,730 --> 00:24:38,010
this is like 20 lines of code and most

00:24:35,310 --> 00:24:40,020
of it is boilerplate I have no

00:24:38,010 --> 00:24:42,600
experience with openssl I I have no clue

00:24:40,020 --> 00:24:45,960
what that's doing inside I barely know

00:24:42,600 --> 00:24:47,460
what it should be doing outside and and

00:24:45,960 --> 00:24:50,850
I've took these snippets from someone

00:24:47,460 --> 00:24:52,980
else the key point here is that all this

00:24:50,850 --> 00:24:54,840
all this code is boilerplate you don't

00:24:52,980 --> 00:24:56,730
need to worry about it all you need to

00:24:54,840 --> 00:24:58,170
worry about is that you actually pass

00:24:56,730 --> 00:25:03,750
the data and the size of the data

00:24:58,170 --> 00:25:09,930
somewhere how many of you have heard

00:25:03,750 --> 00:25:12,960
about heartbleed good how many of you

00:25:09,930 --> 00:25:14,850
believe me that lip phaser can find

00:25:12,960 --> 00:25:17,160
heartbleed before the end of this

00:25:14,850 --> 00:25:22,740
presentation on this laptop raising

00:25:17,160 --> 00:25:24,570
hands okay and the presentation is 35

00:25:22,740 --> 00:25:33,060
mins from that how about five minutes

00:25:24,570 --> 00:25:35,430
raise a hand yeah let us see so I won't

00:25:33,060 --> 00:25:38,340
be compiling it it's precompiled here

00:25:35,430 --> 00:25:41,460
and I will not be using any test corpus

00:25:38,340 --> 00:25:43,950
so the father will be generating the

00:25:41,460 --> 00:25:46,200
inputs from outer space it doesn't know

00:25:43,950 --> 00:25:49,650
anything about about what it is testing

00:25:46,200 --> 00:25:50,850
just throws random data and receives the

00:25:49,650 --> 00:25:54,330
feedback from the coverage

00:25:50,850 --> 00:26:04,760
instrumentation so what I suggest at

00:25:54,330 --> 00:26:04,760
five minutes so just wait done

00:26:11,490 --> 00:26:17,070
so this this particular fuzzer was

00:26:14,140 --> 00:26:19,660
compiled with address sanitizer and

00:26:17,070 --> 00:26:23,950
address sanitizer reports he buffer

00:26:19,660 --> 00:26:27,490
overflow it says that the reed was 58 k

00:26:23,950 --> 00:26:33,190
ridiculous the reed was done in mem copy

00:26:27,490 --> 00:26:37,360
and the second the second frame suggest

00:26:33,190 --> 00:26:43,000
something about heart heart beat I

00:26:37,360 --> 00:26:45,790
wonder why anyway and this this slope

00:26:43,000 --> 00:26:48,220
laptop is is pretty weak on a decent

00:26:45,790 --> 00:26:53,200
machine the father finds it in one

00:26:48,220 --> 00:26:55,059
second on a single CPU control-flow

00:26:53,200 --> 00:26:57,670
guided fasten is not the end it's it's

00:26:55,059 --> 00:27:01,120
it's an intermediate state of of these

00:26:57,670 --> 00:27:04,360
signs and there are many many more new

00:27:01,120 --> 00:27:07,240
things that we want to explore and that

00:27:04,360 --> 00:27:09,070
other teams are already working on first

00:27:07,240 --> 00:27:11,830
of all I first of all I want to mention

00:27:09,070 --> 00:27:13,510
con colic execution and from my my

00:27:11,830 --> 00:27:16,780
standpoint of view this is kind of

00:27:13,510 --> 00:27:19,570
rocket science very complex very very

00:27:16,780 --> 00:27:24,970
scientific and very efficient so what

00:27:19,570 --> 00:27:27,220
that is we take the application we

00:27:24,970 --> 00:27:30,640
instrumented with some kind of tracing

00:27:27,220 --> 00:27:36,640
in it executes on a particular test

00:27:30,640 --> 00:27:38,230
input and record the trace then we need

00:27:36,640 --> 00:27:39,940
to figure out which branches in the

00:27:38,230 --> 00:27:43,030
application which paths in the

00:27:39,940 --> 00:27:46,570
applications were never taken and we

00:27:43,030 --> 00:27:49,390
want to actually execute those paths by

00:27:46,570 --> 00:27:52,110
providing you test inputs so we feed

00:27:49,390 --> 00:27:54,970
this data we collected into the

00:27:52,110 --> 00:27:57,309
constraint solvers and this is the

00:27:54,970 --> 00:27:59,860
rocket science part of the process and

00:27:57,309 --> 00:28:02,980
the constraints always give us back they

00:27:59,860 --> 00:28:05,200
modify test inputs that have a good

00:28:02,980 --> 00:28:08,410
chance to trigger new paths in the

00:28:05,200 --> 00:28:13,059
program this is a great thing in theory

00:28:08,410 --> 00:28:15,460
and in fact we now see great results in

00:28:13,059 --> 00:28:17,800
practice it works this is not just a

00:28:15,460 --> 00:28:19,779
theory but still it's it's quite heavy

00:28:17,800 --> 00:28:22,239
weight like if you are

00:28:19,779 --> 00:28:25,389
a medium-sized co-developer you you may

00:28:22,239 --> 00:28:27,669
not have resources of time or anything

00:28:25,389 --> 00:28:30,639
else to invest into this kind of heavy

00:28:27,669 --> 00:28:32,379
weight testing I wish in 10 years there

00:28:30,639 --> 00:28:35,409
would be like common frameworks or

00:28:32,379 --> 00:28:39,249
software as a service for forking colic

00:28:35,409 --> 00:28:41,440
execution but not today we're trying to

00:28:39,249 --> 00:28:45,549
find some kind of middle ground between

00:28:41,440 --> 00:28:49,989
this rocket science fuzzy and simple

00:28:45,549 --> 00:28:53,409
mutation guided fuzzing one of the

00:28:49,989 --> 00:28:56,619
approaches we call a data flow guided

00:28:53,409 --> 00:28:58,450
fuzzy so the idea is that you somehow

00:28:56,619 --> 00:29:00,609
intercept the data flow in the

00:28:58,450 --> 00:29:05,229
application you analyze what is

00:29:00,609 --> 00:29:08,169
happening in the comparison instructions

00:29:05,229 --> 00:29:11,229
in switch statements in function calls

00:29:08,169 --> 00:29:16,149
like string compare and then you try to

00:29:11,229 --> 00:29:18,339
modify the test inputs in hope to

00:29:16,149 --> 00:29:21,070
trigger a particular comparison to go

00:29:18,339 --> 00:29:23,859
into the different direction and then

00:29:21,070 --> 00:29:26,259
you observe what actually happened we

00:29:23,859 --> 00:29:29,049
have a prototype of this particular idea

00:29:26,259 --> 00:29:31,869
in lib phaser and also there is a very

00:29:29,049 --> 00:29:35,109
nice buzzer for the goal and which but

00:29:31,869 --> 00:29:38,499
it's outside of this conference we

00:29:35,109 --> 00:29:43,229
already have some trophies but way a

00:29:38,499 --> 00:29:45,989
long way to go to really useful thing

00:29:43,229 --> 00:29:49,089
some of the improvements may come from

00:29:45,989 --> 00:29:50,950
using paint analysis tools like if you

00:29:49,089 --> 00:29:53,619
know where the data is coming from

00:29:50,950 --> 00:29:56,739
exactly from the input you may guide the

00:29:53,619 --> 00:30:00,820
diffuser more precisely and I think I

00:29:56,739 --> 00:30:03,570
have time for a little more demo so I

00:30:00,820 --> 00:30:10,479
will not find anybody this demo just

00:30:03,570 --> 00:30:14,349
something to show so this is a JPEG

00:30:10,479 --> 00:30:16,479
father it it starts from from an empty

00:30:14,349 --> 00:30:19,809
image it doesn't have any knowledge

00:30:16,479 --> 00:30:22,929
about the JPEG file format and it tries

00:30:19,809 --> 00:30:26,139
to discover it well it managed to find

00:30:22,929 --> 00:30:28,359
something it's unusual often it just

00:30:26,139 --> 00:30:30,909
works like this it tries and tries and

00:30:28,359 --> 00:30:33,090
tries eventually it will find the

00:30:30,909 --> 00:30:36,870
village jpg JPEG

00:30:33,090 --> 00:30:42,240
while and we'll start fussing it but as

00:30:36,870 --> 00:30:43,950
you can see this father made a 100,000

00:30:42,240 --> 00:30:54,290
iterations and didn't find anything

00:30:43,950 --> 00:30:58,350
interesting now this flag enables the

00:30:54,290 --> 00:31:00,210
data data flow guided fuzzy and this as

00:30:58,350 --> 00:31:03,150
you can see it instantly finds some some

00:31:00,210 --> 00:31:08,460
interesting stuff this is because the

00:31:03,150 --> 00:31:11,910
JPEG library jpg file format has some

00:31:08,460 --> 00:31:14,820
magic bytes in the headers that are

00:31:11,910 --> 00:31:16,830
being compared against what what is

00:31:14,820 --> 00:31:20,160
actually in the file right and if we

00:31:16,830 --> 00:31:22,560
intercept the this comparison

00:31:20,160 --> 00:31:24,630
instruction if we look inside it if you

00:31:22,560 --> 00:31:26,550
know what is being compared to the what

00:31:24,630 --> 00:31:34,620
we can guide the files are much more

00:31:26,550 --> 00:31:36,450
efficiently this is the second part of

00:31:34,620 --> 00:31:42,020
my talk and by the way do I have any

00:31:36,450 --> 00:31:42,020
questions about fuzzy for now yes please

00:31:56,570 --> 00:32:04,730
okay I wonder if anyone is shaping

00:32:01,010 --> 00:32:09,800
executables with fasting enabled or

00:32:04,730 --> 00:32:13,410
sanitizers nothing but sanitizers enable

00:32:09,800 --> 00:32:15,420
so shipping by nurses fuzzing enabled

00:32:13,410 --> 00:32:19,350
haven't heard about it now sorry that

00:32:15,420 --> 00:32:23,010
was wrong yeah shipping binaries with

00:32:19,350 --> 00:32:25,830
the sanitizers enabled it's possible we

00:32:23,010 --> 00:32:28,880
do experiments with it it is not it is

00:32:25,830 --> 00:32:31,890
not a trend it is not a very widespread

00:32:28,880 --> 00:32:34,920
thing to do because the sanitizers they

00:32:31,890 --> 00:32:37,950
have a cost first of all the biggest

00:32:34,920 --> 00:32:42,500
cost is memory and then there is also

00:32:37,950 --> 00:32:45,120
CPU cost would do experiments we we have

00:32:42,500 --> 00:32:45,730
binaries working with a sign and

00:32:45,120 --> 00:33:07,030
production

00:32:45,730 --> 00:33:08,980
and the kitchen bugs please so are there

00:33:07,030 --> 00:33:11,200
ways to make fuzzing harder especially

00:33:08,980 --> 00:33:16,360
make sure that your binary binaries are

00:33:11,200 --> 00:33:20,230
not easily fossil Jenna please repeat

00:33:16,360 --> 00:33:23,950
the first part I first my own question

00:33:20,230 --> 00:33:25,480
okay here we go can we make it so

00:33:23,950 --> 00:33:27,040
typically the things like at the input

00:33:25,480 --> 00:33:28,660
stage of your parsing or something you

00:33:27,040 --> 00:33:30,130
add like a lot of debt go to make sure

00:33:28,660 --> 00:33:32,920
that people have a really hard time fuzz

00:33:30,130 --> 00:33:36,460
in your application to find problems the

00:33:32,920 --> 00:33:40,620
first place so is there are there known

00:33:36,460 --> 00:33:45,820
weaknesses in floating algorithms ah

00:33:40,620 --> 00:33:48,570
thanks so other other ways to to make

00:33:45,820 --> 00:33:52,660
your application fuzzing resistant right

00:33:48,570 --> 00:33:55,060
I think that the the fewer control flow

00:33:52,660 --> 00:33:58,990
you have in the application the harder

00:33:55,060 --> 00:34:00,910
it is to fuzz it like if you replace if

00:33:58,990 --> 00:34:04,420
statements and switch statements and

00:34:00,910 --> 00:34:06,190
function calls with some straight line

00:34:04,420 --> 00:34:09,220
arithmetic in a single expression

00:34:06,190 --> 00:34:14,260
without without control flow eat well it

00:34:09,220 --> 00:34:16,300
will make fuzzing much harder for for

00:34:14,260 --> 00:34:22,180
more sophisticated ways of fighting no

00:34:16,300 --> 00:34:26,650
you have no chance one more question

00:34:22,180 --> 00:34:28,780
here yes yes please are you working with

00:34:26,650 --> 00:34:30,430
any of the efforts to harden some of the

00:34:28,780 --> 00:34:31,510
infrastructure one examples linux

00:34:30,430 --> 00:34:36,100
foundation's core infrastructure

00:34:31,510 --> 00:34:37,840
initiative or are they aware of these if

00:34:36,100 --> 00:34:39,640
not i will make them aware of them but

00:34:37,840 --> 00:34:42,570
if you're working with them no point in

00:34:39,640 --> 00:34:45,130
bothering them again I working with the

00:34:42,570 --> 00:34:47,650
was linux foundation yeah core

00:34:45,130 --> 00:34:50,980
infrastructure initiative does ah CIA

00:34:47,650 --> 00:34:53,470
weren't here so I yes yes I'm trying to

00:34:50,980 --> 00:34:55,680
work with core instruction ishit of the

00:34:53,470 --> 00:34:58,410
the idea is that we want to encourage

00:34:55,680 --> 00:35:01,079
software developers

00:34:58,410 --> 00:35:03,119
to use the tools i described here on a

00:35:01,079 --> 00:35:06,119
regular basis and the key here is

00:35:03,119 --> 00:35:08,640
regular basis because we not just want

00:35:06,119 --> 00:35:11,430
them to run the tools once find bugs

00:35:08,640 --> 00:35:14,520
fixed bugs want them to set up build

00:35:11,430 --> 00:35:17,640
bots was quite a few cpus to run all the

00:35:14,520 --> 00:35:19,880
sanitizers was all the father's make

00:35:17,640 --> 00:35:22,140
sure the coverage is hundred percent or

00:35:19,880 --> 00:35:24,480
getting close to one hundred percent and

00:35:22,140 --> 00:35:28,020
that is time consuming and money

00:35:24,480 --> 00:35:31,339
consuming business so yes I'm trying to

00:35:28,020 --> 00:35:38,750
convince CII to to do to make it work

00:35:31,339 --> 00:35:38,750
good a last question before i continue

00:35:44,599 --> 00:35:49,410
questions a bit more practical when you

00:35:48,030 --> 00:35:51,210
showed a list of bugs that you found in

00:35:49,410 --> 00:35:54,750
that one case there was like a lot of

00:35:51,210 --> 00:35:56,190
memory access memory usage we're seeing

00:35:54,750 --> 00:35:58,349
that a lot as well when we're doing fuzz

00:35:56,190 --> 00:36:00,569
testing because we deal with science

00:35:58,349 --> 00:36:03,420
software our stuff is designed to use

00:36:00,569 --> 00:36:04,799
gigabytes of memory perhaps and the

00:36:03,420 --> 00:36:07,770
problem we're running into is quite

00:36:04,799 --> 00:36:09,869
practical the the address sanitizer

00:36:07,770 --> 00:36:12,450
doesn't allow you to throw STD bad a log

00:36:09,869 --> 00:36:14,640
so I'm partly curious why that is why

00:36:12,450 --> 00:36:16,410
don't you allow the address sanitizer to

00:36:14,640 --> 00:36:18,420
throw as deep a Dalek and are there

00:36:16,410 --> 00:36:21,569
plans to work around that every

00:36:18,420 --> 00:36:24,480
sanitizer doesn't allow us to throw STD

00:36:21,569 --> 00:36:28,400
elek every sanitizer doesn't know

00:36:24,480 --> 00:36:31,920
anything about STD elak it knows that if

00:36:28,400 --> 00:36:35,630
Malik is not able to allocate the memory

00:36:31,920 --> 00:36:39,059
it should do something by default it

00:36:35,630 --> 00:36:42,210
aboard but there is a flag that makes it

00:36:39,059 --> 00:36:44,250
return no it's not the default flag

00:36:42,210 --> 00:36:47,549
because the security well it's a long

00:36:44,250 --> 00:36:50,819
story but every sanitizer does support

00:36:47,549 --> 00:36:52,559
you use case with a separate flag it

00:36:50,819 --> 00:36:54,230
doesn't throw a sweep at a lock it just

00:36:52,559 --> 00:36:58,109
returns now on nothing right there

00:36:54,230 --> 00:37:01,230
advertiser doesn't know about leap C++

00:36:58,109 --> 00:37:04,529
or limo steady C++ it works on the level

00:37:01,230 --> 00:37:08,940
of malik if malloc returns now then the

00:37:04,529 --> 00:37:12,380
operator you will throw something if it

00:37:08,940 --> 00:37:12,380
doesn't work we'll fix it

00:37:12,530 --> 00:37:20,490
so let's let's go back to my second part

00:37:15,920 --> 00:37:24,660
which is called hardening so as I've

00:37:20,490 --> 00:37:26,820
explained previously no currently known

00:37:24,660 --> 00:37:30,360
methods of testing your software

00:37:26,820 --> 00:37:32,820
including sanitizers and fuzzy are proof

00:37:30,360 --> 00:37:35,370
of correctness so there is always a

00:37:32,820 --> 00:37:38,030
chance that you have a bargain software

00:37:35,370 --> 00:37:40,230
that you don't know which is worse

00:37:38,030 --> 00:37:44,460
sometimes you don't know about the bug

00:37:40,230 --> 00:37:46,770
but the bad guys do and you want to

00:37:44,460 --> 00:37:49,130
protect the application from those bugs

00:37:46,770 --> 00:37:52,380
unknown to you but known to the bad guys

00:37:49,130 --> 00:37:55,530
I will I will talk about two threads

00:37:52,380 --> 00:37:58,170
threat number one is buffer overflow or

00:37:55,530 --> 00:38:01,400
use of the free that would overwrite a

00:37:58,170 --> 00:38:04,710
vp t our virtual pointer table or a

00:38:01,400 --> 00:38:06,690
function pointer in your object by

00:38:04,710 --> 00:38:10,260
something that the the bad guys control

00:38:06,690 --> 00:38:12,870
and this is not theoretical thread the

00:38:10,260 --> 00:38:16,920
Chrome browser was was completely owned

00:38:12,870 --> 00:38:19,200
in this particular way in 2013 good news

00:38:16,920 --> 00:38:23,160
is that it was done by white hat hackers

00:38:19,200 --> 00:38:26,130
that showed the exploit to google to the

00:38:23,160 --> 00:38:28,320
chrome developers but how many bad guys

00:38:26,130 --> 00:38:31,860
are using similar techniques out there

00:38:28,320 --> 00:38:34,050
not just for Chrome our solution is

00:38:31,860 --> 00:38:36,750
called control flow and integrity or cfi

00:38:34,050 --> 00:38:39,150
for short it is implemented in the fresh

00:38:36,750 --> 00:38:42,570
version of clan and it requires two

00:38:39,150 --> 00:38:45,360
flags f signet eyes cfi we call and it

00:38:42,570 --> 00:38:53,070
also relies on link time optimization

00:38:45,360 --> 00:38:55,470
fot oh how does it work first of all at

00:38:53,070 --> 00:38:57,900
compile time we treat every disjoint

00:38:55,470 --> 00:39:02,670
class hierarchy in the c++ application

00:38:57,900 --> 00:39:04,620
as a separate thing we don't do any any

00:39:02,670 --> 00:39:08,220
analysis between this joint class

00:39:04,620 --> 00:39:10,440
hierarchies of course since we're also

00:39:08,220 --> 00:39:13,470
using LTI which means whole program mode

00:39:10,440 --> 00:39:16,020
for c++ it assumes that class hierarchy

00:39:13,470 --> 00:39:20,850
is a closed system in other words that

00:39:16,020 --> 00:39:23,370
you don't inherit from one class in the

00:39:20,850 --> 00:39:24,330
main binary to another class in a shared

00:39:23,370 --> 00:39:27,390
library that

00:39:24,330 --> 00:39:30,510
separate from from the main binder this

00:39:27,390 --> 00:39:33,300
is a restriction it makes C++ a little

00:39:30,510 --> 00:39:35,580
bit smaller but it works perfectly for

00:39:33,300 --> 00:39:40,500
chrome and I'm sure it will work for

00:39:35,580 --> 00:39:43,620
many other applications we take V tables

00:39:40,500 --> 00:39:47,100
for every disjoint class hierarchy and

00:39:43,620 --> 00:39:49,050
we lay out the V tables as a continuous

00:39:47,100 --> 00:39:51,110
as a contiguous array so all the V

00:39:49,050 --> 00:39:55,830
tables for a particular class hierarchy

00:39:51,110 --> 00:39:59,520
allocated in a one contiguous chunk of

00:39:55,830 --> 00:40:03,800
memory and also align every table in

00:39:59,520 --> 00:40:08,660
that chunk by by the same power of two

00:40:03,800 --> 00:40:12,690
so that when when a virtual call happens

00:40:08,660 --> 00:40:16,440
we can we can do a very simple check at

00:40:12,690 --> 00:40:19,650
compile-time we figure out what what are

00:40:16,440 --> 00:40:21,990
the exact functions that are allowed to

00:40:19,650 --> 00:40:24,270
be called in this particular call side

00:40:21,990 --> 00:40:25,860
and this is just from reading the

00:40:24,270 --> 00:40:29,520
standard right you you can call

00:40:25,860 --> 00:40:31,680
functions of the same class and you can

00:40:29,520 --> 00:40:33,990
call the functions of classes inherited

00:40:31,680 --> 00:40:36,720
from this class but you cannot call

00:40:33,990 --> 00:40:39,180
functions from from a sibling in in the

00:40:36,720 --> 00:40:43,860
hierarchy or some random function out

00:40:39,180 --> 00:40:46,080
there and at runtime we perform three

00:40:43,860 --> 00:40:49,500
checks range check that we are within

00:40:46,080 --> 00:40:52,470
this contiguous re-alignment check that

00:40:49,500 --> 00:40:55,020
the virtual pointer is actually aligned

00:40:52,470 --> 00:40:58,410
by the power of two we we wanted to be

00:40:55,020 --> 00:41:01,560
aligned and then a bit sad look up and

00:40:58,410 --> 00:41:03,960
the bit set is is based statically at

00:41:01,560 --> 00:41:06,900
compile time based on what functions are

00:41:03,960 --> 00:41:08,460
allowed and not allowed it may sound a

00:41:06,900 --> 00:41:16,200
little bit complicated like three checks

00:41:08,460 --> 00:41:18,870
oh my god hmm but in fact they're not

00:41:16,200 --> 00:41:22,080
that they're not that complex first of

00:41:18,870 --> 00:41:24,150
all because bit set is one of the best

00:41:22,080 --> 00:41:26,520
probably the best and this simplest data

00:41:24,150 --> 00:41:28,650
structure out there in the world it is

00:41:26,520 --> 00:41:31,080
very cheap right it has constant time

00:41:28,650 --> 00:41:33,660
access it requires one memory load per

00:41:31,080 --> 00:41:35,430
access it requires very very little

00:41:33,660 --> 00:41:37,470
memory / axis ii

00:41:35,430 --> 00:41:40,319
then even that simple data structure can

00:41:37,470 --> 00:41:42,420
be optimized further first of all if you

00:41:40,319 --> 00:41:46,170
bid set is small for example less than

00:41:42,420 --> 00:41:47,819
64 bits you don't need to load this data

00:41:46,170 --> 00:41:53,490
structure from memory it could be as

00:41:47,819 --> 00:41:56,190
part of immediate instruction then if if

00:41:53,490 --> 00:41:58,980
a bit bit set contains all ones and in

00:41:56,190 --> 00:42:01,650
our case it will be the dissertation

00:41:58,980 --> 00:42:03,930
when we work all through the head of the

00:42:01,650 --> 00:42:08,040
class hierarchy there is no point in

00:42:03,930 --> 00:42:10,470
checking the bit set finally the finally

00:42:08,040 --> 00:42:14,609
would do some some optimizations to

00:42:10,470 --> 00:42:17,730
reduce the bit cell sizes ever we will

00:42:14,609 --> 00:42:20,849
get this thing this slide shows three

00:42:17,730 --> 00:42:24,510
three examples of the assembly code in

00:42:20,849 --> 00:42:27,569
x86 64 that are generated by by the

00:42:24,510 --> 00:42:32,609
compiler to check the validity of

00:42:27,569 --> 00:42:35,369
virtual virtual virtual call the blue

00:42:32,609 --> 00:42:36,990
part is the rain check it is present no

00:42:35,369 --> 00:42:39,809
three parts and it is more or less the

00:42:36,990 --> 00:42:42,480
same and the red part is the bits at

00:42:39,809 --> 00:42:46,109
look up so if the bit set contains all

00:42:42,480 --> 00:42:49,260
ones there is no bit settle cup if the

00:42:46,109 --> 00:42:53,160
bit set is less than 64 bit less or

00:42:49,260 --> 00:42:56,309
equal up there is a bit sad look up but

00:42:53,160 --> 00:42:58,410
as you can see this bit set look up is

00:42:56,309 --> 00:43:00,000
just arithmetic instructions it doesn't

00:42:58,410 --> 00:43:01,859
load anything from memory because the

00:43:00,000 --> 00:43:06,359
bits at is small and you can load it

00:43:01,859 --> 00:43:09,030
from the register finally if the bits at

00:43:06,359 --> 00:43:12,180
is big and not all once we we do need to

00:43:09,030 --> 00:43:17,309
to do this memory load but it's just a

00:43:12,180 --> 00:43:19,440
single memory load it's cheap control

00:43:17,309 --> 00:43:21,540
flow integrity doesn't stop at virtual

00:43:19,440 --> 00:43:25,380
calls we can apply the same technique

00:43:21,540 --> 00:43:28,440
the same method to other scary things

00:43:25,380 --> 00:43:30,559
first of all to other scary calls any

00:43:28,440 --> 00:43:34,140
other non-virtual member calls of

00:43:30,559 --> 00:43:37,710
polymorphic types are easy to deal with

00:43:34,140 --> 00:43:42,119
the same methodology we just check that

00:43:37,710 --> 00:43:44,280
the virtual pointer is still correct we

00:43:42,119 --> 00:43:46,740
can apply slightly modified make

00:43:44,280 --> 00:43:49,110
mechanism to see style in direct calls

00:43:46,740 --> 00:43:52,040
so no C++ classes

00:43:49,110 --> 00:43:55,260
maybe not even C++ just plain see with

00:43:52,040 --> 00:43:59,010
indirect costs we we can apply the same

00:43:55,260 --> 00:44:02,610
mag mechanism we can also apply the same

00:43:59,010 --> 00:44:06,870
mechanism for checking for bad casts for

00:44:02,610 --> 00:44:09,360
example when a base class is casted to a

00:44:06,870 --> 00:44:12,810
derived class we want to check that the

00:44:09,360 --> 00:44:17,850
the cost is correct and also from void

00:44:12,810 --> 00:44:22,350
star to some kind of pointer class we

00:44:17,850 --> 00:44:25,290
can check it as well we have implemented

00:44:22,350 --> 00:44:29,640
this teeny inclined llvm and you need

00:44:25,290 --> 00:44:32,580
the most fresh version and we were able

00:44:29,640 --> 00:44:35,700
to build the full chromium browser with

00:44:32,580 --> 00:44:38,070
this kind of hardening a subset of what

00:44:35,700 --> 00:44:40,680
I've described virtual calls and all

00:44:38,070 --> 00:44:43,320
kinds of costs for today it runs fine on

00:44:40,680 --> 00:44:47,340
linux and android and versions for other

00:44:43,320 --> 00:44:49,980
prating systems I in flight the CPU

00:44:47,340 --> 00:44:53,340
overhead is so tiny we couldn't measure

00:44:49,980 --> 00:44:57,660
it we tried hard to measure it we don't

00:44:53,340 --> 00:44:59,820
see it of course if you run spec for

00:44:57,660 --> 00:45:02,340
many many thousand times with and

00:44:59,820 --> 00:45:04,770
without hiding you will see this one

00:45:02,340 --> 00:45:07,170
percent somewhere but on Chrome which is

00:45:04,770 --> 00:45:10,140
multi-threaded which does some time in

00:45:07,170 --> 00:45:11,850
related things you just don't see it the

00:45:10,140 --> 00:45:14,820
code size increase is quite possible

00:45:11,850 --> 00:45:18,390
noticeable it is easy to measure and we

00:45:14,820 --> 00:45:21,420
see seven to eight percent what was

00:45:18,390 --> 00:45:24,690
interesting is that making this work on

00:45:21,420 --> 00:45:28,470
chromium required huge clean up in the

00:45:24,690 --> 00:45:30,060
chromium codebase see if I is not bug

00:45:28,470 --> 00:45:32,940
detection mechanism it's hardening

00:45:30,060 --> 00:45:35,670
mechanism but it also finds bugs as a

00:45:32,940 --> 00:45:41,510
by-product and we found quite a few

00:45:35,670 --> 00:45:41,510
while trying to start chrome with harden

00:45:43,790 --> 00:45:51,960
there are better or different ways to

00:45:45,990 --> 00:45:54,180
make control flow controls or integrity

00:45:51,960 --> 00:45:56,370
harden first of all maybe we don't need

00:45:54,180 --> 00:45:59,610
a link time optimization the whole

00:45:56,370 --> 00:46:01,630
program on the other hand requiring ltos

00:45:59,610 --> 00:46:03,789
is actually a good thing in

00:46:01,630 --> 00:46:05,769
the cases because el tio brings many

00:46:03,789 --> 00:46:09,220
other benefits so I'm not sure we have

00:46:05,769 --> 00:46:11,220
to drop this requirement another thing

00:46:09,220 --> 00:46:14,529
that we can change you improve or maybe

00:46:11,220 --> 00:46:16,769
not improve install our class

00:46:14,529 --> 00:46:20,019
hierarchies to cross the boundaries of

00:46:16,769 --> 00:46:24,849
shared libraries as far as I understand

00:46:20,019 --> 00:46:27,480
the the visual studio 2 2015 has

00:46:24,849 --> 00:46:31,450
something similar to what i described

00:46:27,480 --> 00:46:34,180
but it doesn't require a whole program

00:46:31,450 --> 00:46:36,940
mode I frankly I'm not sure I I have

00:46:34,180 --> 00:46:39,789
read the documentation which says how to

00:46:36,940 --> 00:46:44,289
use it but it doesn't say how it works

00:46:39,789 --> 00:46:47,380
inside but on the other hand maybe it's

00:46:44,289 --> 00:46:49,920
not a great idea to allow inheritance to

00:46:47,380 --> 00:46:52,839
cross the boundaries of shared libraries

00:46:49,920 --> 00:46:57,640
at least if if your application is very

00:46:52,839 --> 00:46:59,589
security sensitive the last thing the

00:46:57,640 --> 00:47:02,619
last thing I'm going to discuss is is

00:46:59,589 --> 00:47:05,380
another threat to security it is one

00:47:02,619 --> 00:47:07,779
stack buffer overflows overwrite return

00:47:05,380 --> 00:47:10,539
addresses on your stack by something

00:47:07,779 --> 00:47:13,809
that bad guys control you don't want

00:47:10,539 --> 00:47:15,789
this to happen we have solution for this

00:47:13,809 --> 00:47:18,700
for this problem as well it is called

00:47:15,789 --> 00:47:23,230
safe stack and again it is implemented

00:47:18,700 --> 00:47:26,109
in fresh Clank ready for you to use it

00:47:23,230 --> 00:47:28,180
is a very simple tool all it does is

00:47:26,109 --> 00:47:31,299
that it places local variables on a

00:47:28,180 --> 00:47:34,900
separate layer mapped region and not on

00:47:31,299 --> 00:47:38,710
the same function stack that is used for

00:47:34,900 --> 00:47:40,480
function calls and return addresses it

00:47:38,710 --> 00:47:42,609
means that even if you have a stack

00:47:40,480 --> 00:47:45,039
buffer overflow in your application even

00:47:42,609 --> 00:47:49,509
if an attacker can fully control what to

00:47:45,039 --> 00:47:51,640
write in the in that random section the

00:47:49,509 --> 00:47:53,950
return addresses are safe there is no

00:47:51,640 --> 00:47:56,799
way an attacker could affect your

00:47:53,950 --> 00:47:59,230
attorney addresses of course and the

00:47:56,799 --> 00:48:01,599
tactic would still be able to overwrite

00:47:59,230 --> 00:48:05,230
your function pointers or v-tail vtable

00:48:01,599 --> 00:48:07,269
pointers or etc so these protection by

00:48:05,230 --> 00:48:10,420
itself is rather weak but if you combine

00:48:07,269 --> 00:48:14,030
it with CF I which I just explained you

00:48:10,420 --> 00:48:18,110
get much better protection and again

00:48:14,030 --> 00:48:20,540
we don't see any any performance loss

00:48:18,110 --> 00:48:22,970
from from this protection so there is

00:48:20,540 --> 00:48:31,070
almost no good reason to not use it in

00:48:22,970 --> 00:48:34,160
production and for those who like x86

00:48:31,070 --> 00:48:36,140
assembly here is an example of what what

00:48:34,160 --> 00:48:39,440
saves tag does so in this example we

00:48:36,140 --> 00:48:40,790
have a single stack variable and the

00:48:39,440 --> 00:48:43,000
single function call that takes an

00:48:40,790 --> 00:48:45,980
address of this variable so we cannot

00:48:43,000 --> 00:48:48,380
assure that there is no buffer overflow

00:48:45,980 --> 00:48:52,070
on the stack variable or use after

00:48:48,380 --> 00:48:54,830
return so we have to protect it all the

00:48:52,070 --> 00:48:59,630
do is we will get a pointer to the

00:48:54,830 --> 00:49:04,160
unsafe stack that separate region we

00:48:59,630 --> 00:49:07,820
update it to so that it can be used the

00:49:04,160 --> 00:49:12,080
next time we store it back this is this

00:49:07,820 --> 00:49:16,130
is all in TLS we do our stuff and we

00:49:12,080 --> 00:49:19,550
restore the the unsafe stack back this

00:49:16,130 --> 00:49:21,800
this sounds horrible so you you have

00:49:19,550 --> 00:49:24,350
only two useful instructions here in the

00:49:21,800 --> 00:49:27,530
application in the function and lots of

00:49:24,350 --> 00:49:29,810
lots of redundancy but in reality this

00:49:27,530 --> 00:49:32,540
is not that bad because in reality the

00:49:29,810 --> 00:49:36,350
functions get bigger and the overhead is

00:49:32,540 --> 00:49:41,120
fixed / function not / / variable or

00:49:36,350 --> 00:49:43,490
something so again there is no no real

00:49:41,120 --> 00:49:50,720
reason not to use this protection and

00:49:43,490 --> 00:49:53,330
security sensitive applications okay let

00:49:50,720 --> 00:49:56,870
me summarize the talk first of all you

00:49:53,330 --> 00:49:59,330
do not want to rely on regular testing

00:49:56,870 --> 00:50:00,910
traditional testing because this will

00:49:59,330 --> 00:50:03,980
just give you false sense of security

00:50:00,910 --> 00:50:06,320
the bad guys all have these tools I've

00:50:03,980 --> 00:50:08,690
mentioned that the tools open source but

00:50:06,320 --> 00:50:12,440
actually suspect that the bad guys had

00:50:08,690 --> 00:50:17,720
similar tools for ages based on how

00:50:12,440 --> 00:50:21,590
successful the bad guys are so you want

00:50:17,720 --> 00:50:24,910
33 things for for your application first

00:50:21,590 --> 00:50:27,559
of course I encourage everyone to

00:50:24,910 --> 00:50:30,499
continue using the sanitizers

00:50:27,559 --> 00:50:34,309
and these tools will give you basic

00:50:30,499 --> 00:50:37,459
sanity meaning that on on regular inputs

00:50:34,309 --> 00:50:41,089
you will you you will not see undefined

00:50:37,459 --> 00:50:44,229
behavior in the applications however for

00:50:41,089 --> 00:50:46,670
strong the security and just reliability

00:50:44,229 --> 00:50:51,219
you want to use something like guided

00:50:46,670 --> 00:50:55,400
fuzzing guided fasten was not simple in

00:50:51,219 --> 00:50:57,259
in the past but nowadays with the at

00:50:55,400 --> 00:51:01,309
least two fathers I've mentioned it

00:50:57,259 --> 00:51:04,609
became really super easy you may spend

00:51:01,309 --> 00:51:08,359
half an hour setting up then you start

00:51:04,609 --> 00:51:10,519
the process go to Hawaii for for a

00:51:08,359 --> 00:51:15,049
couple of weeks you return you get

00:51:10,519 --> 00:51:17,390
twenty bucks profit and finally if your

00:51:15,049 --> 00:51:20,479
application is security sensitive you do

00:51:17,390 --> 00:51:23,479
not want to trust these trust words the

00:51:20,479 --> 00:51:25,999
things like sanitizers and fuzzy you

00:51:23,479 --> 00:51:29,900
want to harden your code assuming that

00:51:25,999 --> 00:51:32,739
the code still has bugs and two of the

00:51:29,900 --> 00:51:35,719
hardened methodologies are presented

00:51:32,739 --> 00:51:38,420
here a control flow for virtual calls

00:51:35,719 --> 00:51:42,140
non-virtual calls costs in direct calls

00:51:38,420 --> 00:51:44,959
and save stag foreign addresses this is

00:51:42,140 --> 00:51:47,769
not a complete protection and the the

00:51:44,959 --> 00:51:50,299
battle continues I hope we will win

00:51:47,769 --> 00:51:52,719
thank you and I'm ready to take

00:51:50,299 --> 00:51:52,719
questions

00:52:02,360 --> 00:52:09,900
the first problem um yeah I was just

00:52:07,260 --> 00:52:11,460
wondering when you're using a corpus I

00:52:09,900 --> 00:52:13,410
mean some of the examples you showed

00:52:11,460 --> 00:52:16,170
we're just you know libraries that

00:52:13,410 --> 00:52:17,940
simply took in a buffer bytes and a

00:52:16,170 --> 00:52:19,590
length and so the format of the corpus

00:52:17,940 --> 00:52:22,260
is pretty straightforward but i'm just

00:52:19,590 --> 00:52:24,810
wondering with real usage is it frequent

00:52:22,260 --> 00:52:27,390
that you need to kind of develop a more

00:52:24,810 --> 00:52:32,430
complex format for what you would store

00:52:27,390 --> 00:52:34,410
in that corpus so the question what what

00:52:32,430 --> 00:52:37,070
do we store in corpus and what do we do

00:52:34,410 --> 00:52:39,570
if the format is complicated yeah

00:52:37,070 --> 00:52:42,000
sometimes we just don't do anything and

00:52:39,570 --> 00:52:44,610
the father will still find out useful

00:52:42,000 --> 00:52:48,260
things the the more the initial corpus

00:52:44,610 --> 00:52:52,710
the easier the the job for the buzzer

00:52:48,260 --> 00:52:56,970
sometimes however if the data format is

00:52:52,710 --> 00:52:58,710
very very structured it is hard for a

00:52:56,970 --> 00:53:02,640
father without any any specific

00:52:58,710 --> 00:53:05,610
knowledge to penetrate the the upper

00:53:02,640 --> 00:53:08,460
layer for example things like xml

00:53:05,610 --> 00:53:12,360
operator buffers or some some structured

00:53:08,460 --> 00:53:15,960
data format you may fast the parser to

00:53:12,360 --> 00:53:18,480
death but you will not easily go into

00:53:15,960 --> 00:53:22,530
the logic of the application that that

00:53:18,480 --> 00:53:24,630
consumes xml a proto buffs this is why

00:53:22,530 --> 00:53:28,080
we have implemented support for for

00:53:24,630 --> 00:53:30,840
custom mutators the idea is that okay we

00:53:28,080 --> 00:53:33,810
don't care about the parcel of the file

00:53:30,840 --> 00:53:39,090
format we want to go on the next level

00:53:33,810 --> 00:53:41,610
immediately so what we do is we is lip

00:53:39,090 --> 00:53:44,540
buzzer allows you to redefine it's a

00:53:41,610 --> 00:53:49,860
virtual function to redefine the way you

00:53:44,540 --> 00:53:52,770
mutate your input data and instead of

00:53:49,860 --> 00:53:54,750
just flipping bit you parse it using the

00:53:52,770 --> 00:53:57,780
regular parser if it doesn't parse you

00:53:54,750 --> 00:54:00,750
throw it away it's not interesting then

00:53:57,780 --> 00:54:03,240
using either lip father utilities or

00:54:00,750 --> 00:54:05,430
your own utilities you can mutate the

00:54:03,240 --> 00:54:08,570
fields in your applique in your in your

00:54:05,430 --> 00:54:10,640
parsed data like if you have

00:54:08,570 --> 00:54:12,500
tree structure that that was parsed you

00:54:10,640 --> 00:54:14,720
can now mutate individual fields you can

00:54:12,500 --> 00:54:19,270
add fields you can remove fields you can

00:54:14,720 --> 00:54:22,880
cross over field then you feed this

00:54:19,270 --> 00:54:24,860
modified object to your targeted

00:54:22,880 --> 00:54:30,650
function and if you like it you

00:54:24,860 --> 00:54:46,130
serialize it back and right disc other

00:54:30,650 --> 00:54:55,370
questions is safe stack related to stack

00:54:46,130 --> 00:54:56,660
annotations so operating system threads

00:54:55,370 --> 00:54:58,490
have a fixed size they can grow to and

00:54:56,660 --> 00:55:01,730
then they die the operating basically

00:54:58,490 --> 00:55:03,650
the page fault does the safe stack

00:55:01,730 --> 00:55:09,260
functionality adhere to those same

00:55:03,650 --> 00:55:12,710
limits does the safe stack unsafe stay

00:55:09,260 --> 00:55:18,350
safe stack honor the limits of the stack

00:55:12,710 --> 00:55:22,640
size yes so suppose we do know the limit

00:55:18,350 --> 00:55:25,070
of the current stack what we do is we we

00:55:22,640 --> 00:55:29,480
allocate a memory chunk of the same size

00:55:25,070 --> 00:55:31,310
as the regular stack which may sound

00:55:29,480 --> 00:55:33,560
like would double the memory usage but

00:55:31,310 --> 00:55:36,830
in fact why not because the call stack

00:55:33,560 --> 00:55:39,980
will use a smaller amount of stack and

00:55:36,830 --> 00:55:41,570
the stack for the variables will use

00:55:39,980 --> 00:55:44,330
smaller amount of memory for the

00:55:41,570 --> 00:55:46,370
variables and the rest of the memory the

00:55:44,330 --> 00:55:48,770
virtual memory will be consumed the

00:55:46,370 --> 00:55:50,960
physical memory will not so the the

00:55:48,770 --> 00:55:54,100
actual memory consumption in addition to

00:55:50,960 --> 00:55:54,100
the regular one is very small

00:56:01,860 --> 00:56:07,450
duced or spill temporaries on the same

00:56:04,900 --> 00:56:08,710
stack no spill temporaries are not even

00:56:07,450 --> 00:56:11,740
visible at the time we do

00:56:08,710 --> 00:56:14,110
instrumentation and so spill temporaries

00:56:11,740 --> 00:56:21,640
are generated by compiler and stored on

00:56:14,110 --> 00:56:24,400
the regular stack when do we do the

00:56:21,640 --> 00:56:27,280
instrumentation for the safe stack we

00:56:24,400 --> 00:56:29,860
make it very late at the lvm

00:56:27,280 --> 00:56:33,100
optimization stage before the low-level

00:56:29,860 --> 00:56:35,310
code generation so all optimizations

00:56:33,100 --> 00:56:39,580
have been done like lining everything

00:56:35,310 --> 00:56:52,090
but things like register locations has

00:56:39,580 --> 00:56:54,430
not been even started for the for this

00:56:52,090 --> 00:57:00,040
new stag do you need a register as a

00:56:54,430 --> 00:57:02,110
stack pointer maybe certain young if you

00:57:00,040 --> 00:57:04,270
have a new stack you need a stack

00:57:02,110 --> 00:57:06,340
pointer as a register for that new stat

00:57:04,270 --> 00:57:11,140
so do you have another dedicated

00:57:06,340 --> 00:57:14,700
register to that so does safe stack

00:57:11,140 --> 00:57:18,370
require next to register yes it does and

00:57:14,700 --> 00:57:20,320
we don't give any special register to

00:57:18,370 --> 00:57:24,940
save stack it's just what the compiler

00:57:20,320 --> 00:57:26,890
decides to use for for this variable yes

00:57:24,940 --> 00:57:39,580
it's can it consumes extra register

00:57:26,890 --> 00:57:42,790
basically python is it on its time T I

00:57:39,580 --> 00:57:44,830
guess I can just touch so basically I'm

00:57:42,790 --> 00:57:48,040
wondering can we use some of these tools

00:57:44,830 --> 00:57:50,230
to deal with hardware related issues the

00:57:48,040 --> 00:57:53,650
context i'm finna cough in particular is

00:57:50,230 --> 00:57:56,500
dhiren and things like roll hammer sufi

00:57:53,650 --> 00:57:58,960
are familiar with that one but it's

00:57:56,500 --> 00:58:01,480
essentially when we have a memory cells

00:57:58,960 --> 00:58:03,070
and we repeatedly written all rights as

00:58:01,480 --> 00:58:05,320
those memory cells and we disturb the

00:58:03,070 --> 00:58:07,600
between the adjacent roles in the deer

00:58:05,320 --> 00:58:08,230
on bank and I've can lead to privilege

00:58:07,600 --> 00:58:10,990
escalation

00:58:08,230 --> 00:58:13,600
issues like if you're disturbed entries

00:58:10,990 --> 00:58:15,550
that happen to be page table entries for

00:58:13,600 --> 00:58:17,619
example so I'm wondering can we either

00:58:15,550 --> 00:58:19,600
use fastened to identify issues like

00:58:17,619 --> 00:58:22,530
that or some of it like safe start to

00:58:19,600 --> 00:58:25,119
protect us against these kinds of

00:58:22,530 --> 00:58:27,670
restoration issues can we use any of

00:58:25,119 --> 00:58:31,180
these techniques to find problems in

00:58:27,670 --> 00:58:36,369
hardware I have no experience with it I

00:58:31,180 --> 00:58:39,160
guess that that fising may just by pure

00:58:36,369 --> 00:58:41,320
luck find some of these right but this

00:58:39,160 --> 00:58:44,500
is not a tool that is specifically

00:58:41,320 --> 00:58:51,430
targeted to find hardware problems sorry

00:58:44,500 --> 00:58:56,109
to mmm no I'm not an expert in hardware

00:58:51,430 --> 00:58:59,050
testing thank you so I guess we're out

00:58:56,109 --> 00:59:02,619
of the out of time but I'm still here

00:58:59,050 --> 00:59:06,880
and then i'm free to dance has many

00:59:02,619 --> 00:59:09,720
questions as as you have a less why

00:59:06,880 --> 00:59:09,720
kicked out of the room

00:59:12,869 --> 00:59:14,930

YouTube URL: https://www.youtube.com/watch?v=qTkYDA0En6U


