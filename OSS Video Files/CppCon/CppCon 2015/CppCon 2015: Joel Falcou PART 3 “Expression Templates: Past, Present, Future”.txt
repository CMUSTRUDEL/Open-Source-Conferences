Title: CppCon 2015: Joel Falcou PART 3 “Expression Templates: Past, Present, Future”
Publication date: 2015-10-10
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Expression Templates is one of this C++ idiom people learn to either love or hate. The main issues with ET is that everubody has its own conception about what they are, when they should be used, what benefits they give and what are their trade off. For a long time, Expression Tempaltes has been seen has a way to improve temporary heavy code. If the seminal implementation of ET by Todd Veldhuizen was actually about this, the landscape has changed since C++11 and C++14.

This workshop will go over : - what are exactly Expression Templates and what kind of use case they can solve elegantly and efficiently - what are the benefits that one may reap by using expression tempalte in its library - what are the real cost of expressont empaltes both at runtime and compile-time - which tools to use to not reinvent the tempalte wheel everytime including an introduction to Boost.PROTO an Boost.HANA.

The main objective is to clarify why, even in C++1*, this idiom has a meaningful set of applciations and how to navigate around its pitfalls.
— 
Joel Falcou is an assistant professor at the University Paris-Sud and researcher at the Laboratoire de Recherche d’Informatique in Orsay, France. His research focuses on studying generative programming idioms and techniques to design tools for parallel software development. The two main parts of those works are: exploration of Embedded Domain Specific Language design for parallel computing on various architectures and the definition of a formal framework for reasoning about meta-programs and prove their compile-time correctness. Applications range from real-time image processing on embedded architectures to High Performance Computing on multi-core clusters. He is a NumScale SAS scientific advisor. NumScale mission is to assist businesses in the exploration and subsequently the mastery of high-performance computing systems.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,460
ok so it's boost ionization every time I

00:00:03,240 --> 00:00:08,309
use as a cold I mean also egg is it

00:00:05,460 --> 00:00:09,570
working you know and and some corners of

00:00:08,309 --> 00:00:13,710
booze photo he does it is the same it

00:00:09,570 --> 00:00:16,139
what the heck I'm looking at okay let's

00:00:13,710 --> 00:00:20,369
put some batteries inside this okay

00:00:16,139 --> 00:00:24,600
great so I think everybody see there so

00:00:20,369 --> 00:00:29,340
arm onto the last vertices of these

00:00:24,600 --> 00:00:31,769
sessions so we speak about that so okay

00:00:29,340 --> 00:00:37,440
so the question is I got all these nice

00:00:31,769 --> 00:00:41,040
cooking stuff just after work if you

00:00:37,440 --> 00:00:46,910
just scream too so you can see 10 and I

00:00:41,040 --> 00:00:49,559
probably need to put my microphone on so

00:00:46,910 --> 00:00:53,879
last session of this stuff so as I said

00:00:49,559 --> 00:00:56,190
so we have all those nice tools okay we

00:00:53,879 --> 00:00:58,800
just paid it very very few bit with I

00:00:56,190 --> 00:01:00,840
would go over an example just after that

00:00:58,800 --> 00:01:05,430
so we can see what kind of really kooky

00:01:00,840 --> 00:01:09,600
stuff we can do with it so those traps

00:01:05,430 --> 00:01:12,299
okay and those traps for some are

00:01:09,600 --> 00:01:14,820
actually okay and for some are actually

00:01:12,299 --> 00:01:17,850
real traps you don't see coming so

00:01:14,820 --> 00:01:22,950
basically you are combination of

00:01:17,850 --> 00:01:25,439
expression templates and auto function

00:01:22,950 --> 00:01:28,820
returning some expression that may or

00:01:25,439 --> 00:01:31,860
may not contains temporary terminals and

00:01:28,820 --> 00:01:36,450
of course completion times okay because

00:01:31,860 --> 00:01:39,119
well it's it's rather as you could have

00:01:36,450 --> 00:01:42,270
so it's it's a bit easy so once the

00:01:39,119 --> 00:01:44,250
risotto and by auto I mean actually all

00:01:42,270 --> 00:01:47,130
the automatic type deduction into the

00:01:44,250 --> 00:01:48,630
language including templates okay so

00:01:47,130 --> 00:01:50,460
look at the code I've wrote there you

00:01:48,630 --> 00:01:52,799
are let's say you have an array classes

00:01:50,460 --> 00:01:55,890
which is actually a expression temperate

00:01:52,799 --> 00:02:00,000
seminole okay so you have some stuff and

00:01:55,890 --> 00:02:03,600
you say Z auto z equal X plus y times

00:02:00,000 --> 00:02:07,049
three question is once the type of Z we

00:02:03,600 --> 00:02:09,179
saw it it's not an array it's whatever

00:02:07,049 --> 00:02:11,129
the underlying expression template

00:02:09,179 --> 00:02:14,050
systems give you as a tie for this kind

00:02:11,129 --> 00:02:15,730
of expression ok so this

00:02:14,050 --> 00:02:18,490
a certain is safe should have been a

00:02:15,730 --> 00:02:21,520
static assert will fail because it's not

00:02:18,490 --> 00:02:23,920
an array well actually logically it is

00:02:21,520 --> 00:02:26,950
it's like an array except it's not

00:02:23,920 --> 00:02:29,620
physically okay and Otto doesn't carry

00:02:26,950 --> 00:02:31,390
this information so that's something you

00:02:29,620 --> 00:02:34,930
can actually live with it's not very

00:02:31,390 --> 00:02:39,610
very you know leave dating where it

00:02:34,930 --> 00:02:41,560
falls more issues is there so let's

00:02:39,610 --> 00:02:47,400
let's have a look at the function bad

00:02:41,560 --> 00:02:50,410
double question is why is it bad it's

00:02:47,400 --> 00:02:52,330
bad with respect to use it with

00:02:50,410 --> 00:02:57,420
expression templates of course what

00:02:52,330 --> 00:02:57,420
happened if X is some expression types

00:02:57,750 --> 00:03:02,680
so x is for example a section for

00:03:00,550 --> 00:03:06,430
example let's say it's our binary expert

00:03:02,680 --> 00:03:09,250
we saw a bit before and we return X plus

00:03:06,430 --> 00:03:11,620
X which will be a binary expert of +

00:03:09,250 --> 00:03:17,290
between the type of X and the type of X

00:03:11,620 --> 00:03:18,940
which is clearly not T it's not tit

00:03:17,290 --> 00:03:21,190
something else and you don't really want

00:03:18,940 --> 00:03:24,430
to care about that it bad double works

00:03:21,190 --> 00:03:28,030
if you pass into regular types okay well

00:03:24,430 --> 00:03:29,830
a regular types that which is the output

00:03:28,030 --> 00:03:31,630
types is the same as an input eyes when

00:03:29,830 --> 00:03:33,910
you call plasma you see what I mean and

00:03:31,630 --> 00:03:38,500
what you should be doing is what God

00:03:33,910 --> 00:03:42,340
ball does you just return 0 2 and then

00:03:38,500 --> 00:03:43,810
you get the correct types I don't say

00:03:42,340 --> 00:03:47,980
you get the correct results you get the

00:03:43,810 --> 00:03:50,080
correct types more on that and the other

00:03:47,980 --> 00:03:53,980
issues is a sometimes you do something

00:03:50,080 --> 00:03:57,120
which is completely you know logical but

00:03:53,980 --> 00:03:59,470
you will lead to crappy performances so

00:03:57,120 --> 00:04:02,440
let's let's look at through so you run

00:03:59,470 --> 00:04:04,810
your listen in your return auto okay but

00:04:02,440 --> 00:04:07,360
something is still wrong there what if

00:04:04,810 --> 00:04:11,080
you pass a regular types you compute X

00:04:07,360 --> 00:04:17,169
plus X once put it in 2d and compute Z

00:04:11,080 --> 00:04:19,090
times D ok so now imagine that plus for

00:04:17,169 --> 00:04:21,430
your touch is very costly ok for

00:04:19,090 --> 00:04:25,990
whatever reason and you pass an

00:04:21,430 --> 00:04:27,639
expression templates expression as X ok

00:04:25,990 --> 00:04:31,449
so you will be the expression

00:04:27,639 --> 00:04:34,419
X plus X and you store it in 2d as a sub

00:04:31,449 --> 00:04:36,310
expression and you put it two times and

00:04:34,419 --> 00:04:40,270
you end up with the expression which is

00:04:36,310 --> 00:04:44,319
X plus X times X plus X and you do twice

00:04:40,270 --> 00:04:48,460
a computation of X plus X because you

00:04:44,319 --> 00:04:50,319
store it into auto so you have to be

00:04:48,460 --> 00:04:52,150
careful with automatic tax deduction and

00:04:50,319 --> 00:04:54,219
expression templates because the

00:04:52,150 --> 00:04:55,599
language does what it should be doing I

00:04:54,219 --> 00:04:57,580
give use the titles of stuff you asked

00:04:55,599 --> 00:05:01,120
at all what do you want me to do anyway

00:04:57,580 --> 00:05:04,300
okay so a lot to be careful with that so

00:05:01,120 --> 00:05:06,039
I don't know different solution exists

00:05:04,300 --> 00:05:07,810
actually so is there you know what

00:05:06,039 --> 00:05:09,909
you're doing which probably means you

00:05:07,810 --> 00:05:12,610
are not into a very January context and

00:05:09,909 --> 00:05:14,409
so you just put them actual terminal

00:05:12,610 --> 00:05:16,900
type where they should we do it be done

00:05:14,409 --> 00:05:18,520
okay except that means that you cannot

00:05:16,900 --> 00:05:21,789
write functions that just take whatever

00:05:18,520 --> 00:05:24,099
and do whatever so we ended up with this

00:05:21,789 --> 00:05:27,189
viral contamination application or photo

00:05:24,099 --> 00:05:29,499
everywhere which solves the outgoing

00:05:27,189 --> 00:05:32,110
issues but doesn't solve the issues

00:05:29,499 --> 00:05:33,759
inside so some libraries based on

00:05:32,110 --> 00:05:36,430
expression templates provide the

00:05:33,759 --> 00:05:39,099
function or meta function that is rough

00:05:36,430 --> 00:05:40,870
record value of our terminal from

00:05:39,099 --> 00:05:43,419
something like this second expression

00:05:40,870 --> 00:05:46,000
and give you the type of the terminal

00:05:43,419 --> 00:05:48,310
that should be able to contain it and so

00:05:46,000 --> 00:05:51,009
you can locally decide but you are still

00:05:48,310 --> 00:05:52,810
into a generic context and the other

00:05:51,009 --> 00:05:56,080
stuff will be speaking about later is

00:05:52,810 --> 00:05:58,659
there is a proposal absent are pretty

00:05:56,080 --> 00:06:01,539
Gaussian and myself wrote which is

00:05:58,659 --> 00:06:04,389
basically provide a way to overload auto

00:06:01,539 --> 00:06:06,189
forgiven times more on this later so

00:06:04,389 --> 00:06:07,870
it's not trivial you have to be careful

00:06:06,189 --> 00:06:10,000
as soon as you have automatic type

00:06:07,870 --> 00:06:13,529
deduction and expression template in the

00:06:10,000 --> 00:06:15,969
same box okay so that's the most

00:06:13,529 --> 00:06:18,339
communicated stuff you have to be

00:06:15,969 --> 00:06:21,099
careful with this it's bad somehow

00:06:18,339 --> 00:06:25,779
because we really all really really love

00:06:21,099 --> 00:06:28,149
auto but not in this case okay other

00:06:25,779 --> 00:06:32,620
issues is just what I call what I call

00:06:28,149 --> 00:06:34,449
the sub expression issue I spent quite a

00:06:32,620 --> 00:06:37,389
lot of time on this trying to fix it

00:06:34,449 --> 00:06:40,289
properly okay we speak about Morgan's

00:06:37,389 --> 00:06:41,440
that later but one trivial stuff is

00:06:40,289 --> 00:06:44,260
usually

00:06:41,440 --> 00:06:46,270
as soon as your terminal is more is

00:06:44,260 --> 00:06:47,860
bigger than the simple values that is a

00:06:46,270 --> 00:06:50,380
table or something that allocates memory

00:06:47,860 --> 00:06:52,840
you want to store your sub expression by

00:06:50,380 --> 00:06:57,070
reference because you don't want to copy

00:06:52,840 --> 00:07:01,690
your terminals okay wait okay fine but

00:06:57,070 --> 00:07:04,960
what if I do this so I take something as

00:07:01,690 --> 00:07:06,670
as X could be an expression and for

00:07:04,960 --> 00:07:09,280
whatever reason I know that I need to

00:07:06,670 --> 00:07:12,730
evaluate right now because I read the

00:07:09,280 --> 00:07:15,220
slide just before I will evaluate the

00:07:12,730 --> 00:07:19,510
sum of two times X plus 3 into a my

00:07:15,220 --> 00:07:22,050
terminal which is array so this allocate

00:07:19,510 --> 00:07:24,610
some memory and do the operation inside

00:07:22,050 --> 00:07:28,060
okay and what I return is the

00:07:24,610 --> 00:07:29,890
expressions two times t minus 1 over T

00:07:28,060 --> 00:07:31,480
which is the reason I evaluated

00:07:29,890 --> 00:07:34,750
everything in the narrow because T was

00:07:31,480 --> 00:07:38,470
twice into the sub expression okay so T

00:07:34,750 --> 00:07:41,350
got some memory allocated what should i

00:07:38,470 --> 00:07:44,410
do for this code to work when I returned

00:07:41,350 --> 00:07:46,750
two times t minus 1 over T what happens

00:07:44,410 --> 00:07:48,610
if I store everything by copy inside my

00:07:46,750 --> 00:07:52,270
expression i would probably duplicate

00:07:48,610 --> 00:07:54,850
the memory of the far too much probably

00:07:52,270 --> 00:07:57,300
three times okay because you will copy

00:07:54,850 --> 00:08:00,070
it into the divisions copy it into the

00:07:57,300 --> 00:08:03,190
multiplications or four times and copy

00:08:00,070 --> 00:08:05,919
both again into the minus so if array is

00:08:03,190 --> 00:08:09,130
like one gigabyte you is not gonna fly

00:08:05,919 --> 00:08:13,030
okay okay so just take everything by

00:08:09,130 --> 00:08:15,730
reference right so what happens well bad

00:08:13,030 --> 00:08:19,750
story for you I will have a reference to

00:08:15,730 --> 00:08:22,450
tea in my 1 over T same for two times T

00:08:19,750 --> 00:08:24,880
and I'll go out of the function and t

00:08:22,450 --> 00:08:26,710
get dis allocated and I got nice tending

00:08:24,880 --> 00:08:33,630
references to memory that not there

00:08:26,710 --> 00:08:37,870
anymore crap so what should we do there

00:08:33,630 --> 00:08:40,479
but goodies solution boosts proto is

00:08:37,870 --> 00:08:42,580
very adamant on this by default

00:08:40,479 --> 00:08:45,580
everything in booze photo is taken by

00:08:42,580 --> 00:08:48,880
reference because most of the time what

00:08:45,580 --> 00:08:51,100
I disagree with that sorry Eric that's

00:08:48,880 --> 00:08:52,839
the correct thing to do and if you want

00:08:51,100 --> 00:08:54,820
to do this you have to call a function

00:08:52,839 --> 00:08:58,630
called boost jeep

00:08:54,820 --> 00:09:00,640
copy with as name implies perform a

00:08:58,630 --> 00:09:03,400
reclusive copy of everything in the tree

00:09:00,640 --> 00:09:06,700
into another one so it sure that

00:09:03,400 --> 00:09:09,580
everything outside is still there but of

00:09:06,700 --> 00:09:12,250
course it's very costly and as again

00:09:09,580 --> 00:09:15,130
that was pre night it's simple since 98

00:09:12,250 --> 00:09:17,350
so we didn't have move semantics so one

00:09:15,130 --> 00:09:19,510
way to do this is if I could find a way

00:09:17,350 --> 00:09:22,600
to use move semantics into the situation

00:09:19,510 --> 00:09:25,480
so I can decide if the steps that coming

00:09:22,600 --> 00:09:27,700
in as to be copied or not and so I

00:09:25,480 --> 00:09:29,410
decide which kind of storage I need to

00:09:27,700 --> 00:09:33,190
have could be ending but it's not that

00:09:29,410 --> 00:09:35,380
trivial so this kind of stuff for just

00:09:33,190 --> 00:09:38,230
for the gigs okay this exact same kind

00:09:35,380 --> 00:09:41,080
of bird took us something like two

00:09:38,230 --> 00:09:44,200
months and a half three people okay to

00:09:41,080 --> 00:09:46,060
find it when you saw it it's obviously

00:09:44,200 --> 00:09:47,620
obvious that you did something wrong but

00:09:46,060 --> 00:09:49,690
I can tell you that when you are writing

00:09:47,620 --> 00:09:52,000
your code and everything worked because

00:09:49,690 --> 00:09:55,060
of course of tests pass and why does a

00:09:52,000 --> 00:09:56,860
test pass because well you get for you

00:09:55,060 --> 00:09:58,060
you get flushed by Z in line in your the

00:09:56,860 --> 00:09:59,890
compiler when you're joining you in

00:09:58,060 --> 00:10:01,720
release mode and everything get in line

00:09:59,890 --> 00:10:04,120
and the reference never exist actually

00:10:01,720 --> 00:10:05,800
and as soon as you go somewhere else and

00:10:04,120 --> 00:10:08,770
the guys actually using your code in the

00:10:05,800 --> 00:10:10,870
client and comprising the low level of

00:10:08,770 --> 00:10:13,150
optimization everything blows up because

00:10:10,870 --> 00:10:15,970
the reference are there and not in lying

00:10:13,150 --> 00:10:20,350
anymore so that's a very crooked bird

00:10:15,970 --> 00:10:23,740
okay don't do that oh do it correctly

00:10:20,350 --> 00:10:27,220
and the other problem is combination

00:10:23,740 --> 00:10:29,770
time so if you do a small scary dsl eyes

00:10:27,220 --> 00:10:31,750
the first part probably fast enough for

00:10:29,770 --> 00:10:34,030
what you want to do and the problem is

00:10:31,750 --> 00:10:35,740
that you remember this symbol names that

00:10:34,030 --> 00:10:39,730
grows up exponentially oh not

00:10:35,740 --> 00:10:43,000
exponentially I mean probably oh well

00:10:39,730 --> 00:10:47,790
far too fast okay and though several

00:10:43,000 --> 00:10:50,440
names that something I suspected and

00:10:47,790 --> 00:10:53,260
Jordi Guzman actually suspected to and

00:10:50,440 --> 00:10:54,880
actually I mean demonstrated that it was

00:10:53,260 --> 00:10:58,110
the case first sources of compile-time

00:10:54,880 --> 00:11:00,490
issues with the slc symbol names because

00:10:58,110 --> 00:11:03,220
contrary to rig record said it just

00:11:00,490 --> 00:11:06,550
takes a human goose amount of space

00:11:03,220 --> 00:11:07,820
compared to what they encode and the

00:11:06,550 --> 00:11:10,250
other problem usable

00:11:07,820 --> 00:11:11,690
and other seminar systems is the

00:11:10,250 --> 00:11:15,170
complexity of the transform your pride

00:11:11,690 --> 00:11:16,730
in the tree not to come out the

00:11:15,170 --> 00:11:18,110
complexity of what you write in the

00:11:16,730 --> 00:11:21,980
booth photo transfer what is actually

00:11:18,110 --> 00:11:23,840
does and are you have to actually

00:11:21,980 --> 00:11:26,720
explain what you should be doing in

00:11:23,840 --> 00:11:29,870
terms of tax computation so the solution

00:11:26,720 --> 00:11:31,730
is simple as do the simplest version of

00:11:29,870 --> 00:11:34,370
extra interpret you need who doesn't

00:11:31,730 --> 00:11:37,730
need to put proto full-fledged stuff

00:11:34,370 --> 00:11:39,320
don't use it take it like like a

00:11:37,730 --> 00:11:41,150
grown-up and write your small-scale

00:11:39,320 --> 00:11:42,830
stuff but if you need something more

00:11:41,150 --> 00:11:49,040
complex you probably need booze brother

00:11:42,830 --> 00:11:52,700
well good luck back in the day first

00:11:49,040 --> 00:11:57,110
time I used booth Prado was in 2003 oh

00:11:52,700 --> 00:12:01,190
no six no 3306 I don't remember

00:11:57,110 --> 00:12:04,820
somewhere 2005 ah i was working in a

00:12:01,190 --> 00:12:08,600
very very very small system with like

00:12:04,820 --> 00:12:11,960
1gb bite of ram and mostly 1gb Earth's

00:12:08,600 --> 00:12:13,730
of CPU power and I was trying to write

00:12:11,960 --> 00:12:15,740
booth photo transforms that transform

00:12:13,730 --> 00:12:20,210
you know change of matrix multiplication

00:12:15,740 --> 00:12:22,130
into the optimal forms okay and the joke

00:12:20,210 --> 00:12:24,470
was as soon as I had more than five

00:12:22,130 --> 00:12:26,690
matrixes into my expressions I could

00:12:24,470 --> 00:12:29,840
launch a compilation at eleven go to

00:12:26,690 --> 00:12:33,650
lunch go back at one and then I get the

00:12:29,840 --> 00:12:36,380
result so well so actually the real

00:12:33,650 --> 00:12:38,960
problem is that we do the compiler we

00:12:36,380 --> 00:12:42,200
further compiler to do is damn job at

00:12:38,960 --> 00:12:44,450
least three times so what it could be

00:12:42,200 --> 00:12:46,640
cool is if we double a language support

00:12:44,450 --> 00:12:48,290
to say okay you take this expression and

00:12:46,640 --> 00:12:49,760
please give me these three and I need it

00:12:48,290 --> 00:12:51,950
for doing something else and the

00:12:49,760 --> 00:12:54,680
compiler just okay this is a 3 I just

00:12:51,950 --> 00:12:57,500
passed so a bit could be far far far

00:12:54,680 --> 00:13:01,490
more efficient ah well that's the

00:12:57,500 --> 00:13:05,990
complicated and one thing we cross

00:13:01,490 --> 00:13:07,970
discovered so me Jorge Guzman Lewis for

00:13:05,990 --> 00:13:11,000
computers of stuff is that you can

00:13:07,970 --> 00:13:13,520
actually use see precipice 14 lambda in

00:13:11,000 --> 00:13:16,250
the perverse way to write something that

00:13:13,520 --> 00:13:17,660
looks like expression templates i will

00:13:16,250 --> 00:13:20,490
show you that a betrayal

00:13:17,660 --> 00:13:23,520
so combination time is fully currently

00:13:20,490 --> 00:13:26,310
the most biggest problem and it's very

00:13:23,520 --> 00:13:29,520
complicated to get something that come

00:13:26,310 --> 00:13:31,590
by fast all the time that's such a big

00:13:29,520 --> 00:13:33,630
problem so before going to the next

00:13:31,590 --> 00:13:35,400
level stuff let's have a look at what

00:13:33,630 --> 00:13:39,810
kind of cookie finger we can actually do

00:13:35,400 --> 00:13:41,700
with with Prado I won't go into the

00:13:39,810 --> 00:13:44,130
details just so you can scheme and you

00:13:41,700 --> 00:13:46,980
can actually look at the complete code

00:13:44,130 --> 00:13:49,170
into the github was that something I was

00:13:46,980 --> 00:13:54,270
doing when I was making a five hours

00:13:49,170 --> 00:13:56,640
tutorial on Prado and you actually have

00:13:54,270 --> 00:14:00,540
to write it by hand from scratch so this

00:13:56,640 --> 00:14:05,070
is what I want to be doing okay I have a

00:14:00,540 --> 00:14:08,400
bunch of terminals called XYZ and so on

00:14:05,070 --> 00:14:11,400
that represent arbitrary abstract

00:14:08,400 --> 00:14:16,890
variables and you can use them to

00:14:11,400 --> 00:14:20,250
actually build arbitrary analytical

00:14:16,890 --> 00:14:23,490
functions with Rita / viable okay so you

00:14:20,250 --> 00:14:26,570
can actually do stuff exists okay so i

00:14:23,490 --> 00:14:29,580
will do it so you can write that and

00:14:26,570 --> 00:14:31,740
pass it through variables and we come to

00:14:29,580 --> 00:14:34,410
the function on the two points for x and

00:14:31,740 --> 00:14:36,720
y and what we wanted to be doing is I

00:14:34,410 --> 00:14:40,050
want it to be able to say oh I am each

00:14:36,720 --> 00:14:43,320
time why compute the derivative of this

00:14:40,050 --> 00:14:47,250
function with respect to X and give me a

00:14:43,320 --> 00:14:48,900
function I can call with some values so

00:14:47,250 --> 00:14:53,130
i can ever range the derivative of this

00:14:48,900 --> 00:14:55,140
function at this point and also do this

00:14:53,130 --> 00:14:56,820
what you want to do is what about having

00:14:55,140 --> 00:14:58,440
the nth derivative which is basically

00:14:56,820 --> 00:15:02,610
the recursive application of the

00:14:58,440 --> 00:15:04,680
derivation function n times ok so you

00:15:02,610 --> 00:15:06,300
can actually write code like this so you

00:15:04,680 --> 00:15:11,580
can also have support for course and

00:15:06,300 --> 00:15:13,080
sign ok and you just walks and others it

00:15:11,580 --> 00:15:15,000
works well when you compute the

00:15:13,080 --> 00:15:20,340
derivative of function what do you get

00:15:15,000 --> 00:15:22,260
as a result a function so what we do is

00:15:20,340 --> 00:15:24,660
we take a proto tree representing your

00:15:22,260 --> 00:15:27,630
initial functions and the transformed

00:15:24,660 --> 00:15:29,550
with right just take the function and

00:15:27,630 --> 00:15:31,020
say oh I have a plus note i need to

00:15:29,550 --> 00:15:33,780
derivate it and

00:15:31,020 --> 00:15:36,900
deviation of plus a plus B is derivative

00:15:33,780 --> 00:15:39,240
of a preservative of be so I computer to

00:15:36,900 --> 00:15:42,090
derivative of my children and I bid a

00:15:39,240 --> 00:15:44,490
new tree with this and you just

00:15:42,090 --> 00:15:47,430
enumerate all the derivation rules for

00:15:44,490 --> 00:15:51,450
plus/minus divisions and so on and so on

00:15:47,430 --> 00:15:54,510
and as the output you get is a tree in

00:15:51,450 --> 00:15:57,450
the same domains and the one before you

00:15:54,510 --> 00:16:01,380
can just pass values for your Bible and

00:15:57,450 --> 00:16:03,180
you just compute and all those the

00:16:01,380 --> 00:16:04,800
matrix computations are done at compile

00:16:03,180 --> 00:16:07,470
time actually so you get a new

00:16:04,800 --> 00:16:12,990
analytical three and large functions

00:16:07,470 --> 00:16:15,540
directly at compile time okay so you can

00:16:12,990 --> 00:16:18,360
have a look I mean really when we want

00:16:15,540 --> 00:16:21,930
but this is the main idea so so we have

00:16:18,360 --> 00:16:23,580
a grammar so to something I didn't speak

00:16:21,930 --> 00:16:26,820
about it so what we call a switch

00:16:23,580 --> 00:16:28,650
grammar so issue is or is that it's

00:16:26,820 --> 00:16:30,480
linnea of time to find the rules you

00:16:28,650 --> 00:16:31,860
want to match there's the first one and

00:16:30,480 --> 00:16:34,340
then the second one and so on and so on

00:16:31,860 --> 00:16:37,500
when you have more like I don't know

00:16:34,340 --> 00:16:41,490
between eight and ten rules it start to

00:16:37,500 --> 00:16:42,990
be very very slow to impart and then we

00:16:41,490 --> 00:16:45,900
switch with something which is called a

00:16:42,990 --> 00:16:48,570
pro to switch it says I'm taking a

00:16:45,900 --> 00:16:51,060
structure which contains all the cases I

00:16:48,570 --> 00:16:55,490
care about and these cases can be

00:16:51,060 --> 00:16:57,840
declared externally to the grammar so

00:16:55,490 --> 00:17:01,620
because the first case is if it's a

00:16:57,840 --> 00:17:04,920
terminal okay so it's a bit more complex

00:17:01,620 --> 00:17:08,160
at what we saw for terminal ok this is a

00:17:04,920 --> 00:17:13,200
terminal if it's a terminal of something

00:17:08,160 --> 00:17:16,740
and only if the value of the terminal is

00:17:13,200 --> 00:17:19,140
convertible to boo me between bull and

00:17:16,740 --> 00:17:21,240
floats basically okay so we can write

00:17:19,140 --> 00:17:26,190
that we have a proto if you can use for

00:17:21,240 --> 00:17:28,800
taking decisions and I will say yeah I

00:17:26,190 --> 00:17:34,740
can negate I can do plus I can do my

00:17:28,800 --> 00:17:37,430
nurse okay and so on it's all enjoy so

00:17:34,740 --> 00:17:41,280
it's like or except it's done externally

00:17:37,430 --> 00:17:42,780
and as I say you can do function so

00:17:41,280 --> 00:17:44,400
although you do functions you need a

00:17:42,780 --> 00:17:46,770
type which would be

00:17:44,400 --> 00:17:50,370
bag and say oh I am crossing this note

00:17:46,770 --> 00:17:55,230
ok so that's the name of that's a reason

00:17:50,370 --> 00:17:57,630
to have this kind of straw stack and we

00:17:55,230 --> 00:17:59,790
say i can compute caused by taking some

00:17:57,630 --> 00:18:04,610
value in that and calling STD calls for

00:17:59,790 --> 00:18:07,710
example sense same stuff for sale and

00:18:04,610 --> 00:18:10,110
what you write is something like this

00:18:07,710 --> 00:18:13,160
edgy stuff you say i have a function

00:18:10,110 --> 00:18:16,890
called cost taking something out 0 and

00:18:13,160 --> 00:18:21,720
what I return is an expression of course

00:18:16,890 --> 00:18:24,870
tagged as a tag that contains arc 0 by

00:18:21,720 --> 00:18:26,730
constant by reference to a constant and

00:18:24,870 --> 00:18:29,550
we just call this see ref stuff to store

00:18:26,730 --> 00:18:31,380
it ok so we have this Mac expert

00:18:29,550 --> 00:18:33,780
function in produce it just build an

00:18:31,380 --> 00:18:37,740
arbitrary tree with an arbitrary tag and

00:18:33,780 --> 00:18:41,040
stirring every child I will travel as a

00:18:37,740 --> 00:18:43,980
value or as a reference or reference to

00:18:41,040 --> 00:18:46,260
prompt ok so when you the only color

00:18:43,980 --> 00:18:50,340
function you just say ok I'm just giving

00:18:46,260 --> 00:18:52,290
you Z so node with colic tag and

00:18:50,340 --> 00:18:54,150
whatever childhood ok that's basically

00:18:52,290 --> 00:18:58,950
was the operator does except it's hidden

00:18:54,150 --> 00:19:01,500
ok and same for sinners and then we do

00:18:58,950 --> 00:19:03,180
the grammar for for cause when I have a

00:19:01,500 --> 00:19:06,240
course I mean that I am a new nary

00:19:03,180 --> 00:19:09,600
expression of cos tag applied to

00:19:06,240 --> 00:19:15,630
something and when I match that I have a

00:19:09,600 --> 00:19:17,520
cross oh and we may want to know what

00:19:15,630 --> 00:19:18,900
what I do to evaluate them because all

00:19:17,520 --> 00:19:21,810
zeros operator we know that we have

00:19:18,900 --> 00:19:23,550
these otherwise default mode and for

00:19:21,810 --> 00:19:26,430
customers and sinus what I do is

00:19:23,550 --> 00:19:30,750
whenever I have an expression of cos tag

00:19:26,430 --> 00:19:37,470
I evaluate my child and I pass it to

00:19:30,750 --> 00:19:41,070
compute costs so it's so part of my

00:19:37,470 --> 00:19:42,720
French as they say but it's not complex

00:19:41,070 --> 00:19:45,150
is complicated because you have a lot of

00:19:42,720 --> 00:19:46,800
bookkeeping to do but every of this book

00:19:45,150 --> 00:19:48,810
keeping our rather simple just that you

00:19:46,800 --> 00:19:50,550
have to go through all those rules so

00:19:48,810 --> 00:19:53,970
when you write it once I mean it starts

00:19:50,550 --> 00:19:55,740
becoming you know some kind of reflects

00:19:53,970 --> 00:19:57,539
ok but you have to go through this once

00:19:55,740 --> 00:20:00,119
actually ok

00:19:57,539 --> 00:20:01,679
I so this is enough for building oh no

00:20:00,119 --> 00:20:03,509
it's not in the factory but this will

00:20:01,679 --> 00:20:05,309
add plus building the regular expression

00:20:03,509 --> 00:20:07,259
so what we do is that we have an

00:20:05,309 --> 00:20:09,869
expression types like we saw with the

00:20:07,259 --> 00:20:12,359
domain and so on such as do whatever

00:20:09,869 --> 00:20:14,720
except we can call this up to three

00:20:12,359 --> 00:20:17,249
variables so we have three operators

00:20:14,720 --> 00:20:18,899
function call with one two three values

00:20:17,249 --> 00:20:20,940
and what we do is that we store

00:20:18,899 --> 00:20:22,529
everything into an array and we pass

00:20:20,940 --> 00:20:24,960
this area as a second parameter to the

00:20:22,529 --> 00:20:27,389
variation and we will have access to

00:20:24,960 --> 00:20:30,359
this array through the up proto

00:20:27,389 --> 00:20:34,950
transform as a state we can read and

00:20:30,359 --> 00:20:41,190
write from into that is it an ever wait

00:20:34,950 --> 00:20:42,779
where is it ever I just say okay it's

00:20:41,190 --> 00:20:47,190
the same stuff you use cases it's a

00:20:42,779 --> 00:20:48,869
switch over each cases I will go on that

00:20:47,190 --> 00:20:50,669
I mean if I'm returning all of the

00:20:48,869 --> 00:20:57,479
proper type I'm just giving you my value

00:20:50,669 --> 00:20:59,489
classical okay and if not the default

00:20:57,479 --> 00:21:02,070
case is just the fourth case we saw

00:20:59,489 --> 00:21:05,820
before another question is all these

00:21:02,070 --> 00:21:09,090
derivate stuff works well that's a bit

00:21:05,820 --> 00:21:12,840
more complicated but not much still

00:21:09,090 --> 00:21:16,049
again we have a switch base grammar but

00:21:12,840 --> 00:21:18,509
we don't have any default so what

00:21:16,049 --> 00:21:23,700
happens when I will keep that one for

00:21:18,509 --> 00:21:27,539
later yeah what happens if i want to

00:21:23,700 --> 00:21:32,460
dairy rate minus x whenever i have minus

00:21:27,539 --> 00:21:35,149
x i build a node which is Magnus

00:21:32,460 --> 00:21:39,029
something with derivation of my children

00:21:35,149 --> 00:21:42,899
okay functional make negate of the rate

00:21:39,029 --> 00:21:44,580
of my child and I pass that to another

00:21:42,899 --> 00:21:46,889
function which is called simplified I

00:21:44,580 --> 00:21:49,679
will go on there to be later but what

00:21:46,889 --> 00:21:53,940
would simplify does well let's say you

00:21:49,679 --> 00:21:55,739
have x times X times X and you want to

00:21:53,940 --> 00:21:57,989
compute the second derivative of that

00:21:55,739 --> 00:22:02,039
you will end up with something like X

00:21:57,989 --> 00:22:04,409
plus X times X plus X plus X plus X we

00:22:02,039 --> 00:22:06,450
have a very complex 3 because everything

00:22:04,409 --> 00:22:08,730
get to know and backed when you do the

00:22:06,450 --> 00:22:11,220
derivation and you want to simplify that

00:22:08,730 --> 00:22:14,159
to be X plus X

00:22:11,220 --> 00:22:16,679
plus 2 times X and so on and so on so

00:22:14,159 --> 00:22:20,400
simplify just limit the size of the tree

00:22:16,679 --> 00:22:23,010
and we just enumerate all the cases of

00:22:20,400 --> 00:22:25,440
the derivatives plus is a plus between

00:22:23,010 --> 00:22:29,610
two derivatives same for my nurse a

00:22:25,440 --> 00:22:31,289
bitter price is a bit more a bit more

00:22:29,610 --> 00:22:35,820
complex but because the rules is more

00:22:31,289 --> 00:22:40,289
complex and so on well sorry devices

00:22:35,820 --> 00:22:42,270
Awards actually I think it took me 5 to

00:22:40,289 --> 00:22:45,299
15 minutes to get it right but whatever

00:22:42,270 --> 00:22:48,360
and course is basically Magnuson and

00:22:45,299 --> 00:22:50,400
scene is basically minus cost and what

00:22:48,360 --> 00:22:53,429
does n for the innovative does it just

00:22:50,400 --> 00:22:57,000
called derivative on itself n times ok

00:22:53,429 --> 00:22:59,760
and what happens when I want to derivate

00:22:57,000 --> 00:23:05,070
a terminal how much cases do I have if

00:22:59,760 --> 00:23:09,630
it's a constant i get 0 oh wait now if I

00:23:05,070 --> 00:23:12,299
derive against X and it's not x it's 0

00:23:09,630 --> 00:23:18,200
including the constant so what we do is

00:23:12,299 --> 00:23:21,419
if I have a constant I just return 0 ok

00:23:18,200 --> 00:23:25,650
if I have a constant like constant 0 I

00:23:21,419 --> 00:23:29,870
just returned constant 0 ok and if I

00:23:25,650 --> 00:23:33,750
have viable XYZ each viable as an index

00:23:29,870 --> 00:23:37,559
0 1 2 and you derivate against another

00:23:33,750 --> 00:23:40,320
one so if the value of the terminal I am

00:23:37,559 --> 00:23:42,840
looking at is the same that the 1 i'm

00:23:40,320 --> 00:23:45,210
derry writing against so I have an ex

00:23:42,840 --> 00:23:51,690
and I derived against X then I returned

00:23:45,210 --> 00:23:53,940
one if not i will turn 0 well why didn't

00:23:51,690 --> 00:23:59,039
return is to you with writing it is

00:23:53,940 --> 00:24:02,659
another issues and so that's what that's

00:23:59,039 --> 00:24:05,700
probably what this one is a bit big but

00:24:02,659 --> 00:24:09,210
it's less than let's say it's about I

00:24:05,700 --> 00:24:12,360
would say a bit less than a thousand

00:24:09,210 --> 00:24:16,049
lines ok probably around 600 or

00:24:12,360 --> 00:24:18,750
something nothing exactly complicated

00:24:16,049 --> 00:24:20,820
it's more like syntax issues and getting

00:24:18,750 --> 00:24:24,450
the algorithm right and you get this

00:24:20,820 --> 00:24:25,020
derivative stuff walking not just that

00:24:24,450 --> 00:24:26,370
was what

00:24:25,020 --> 00:24:28,770
and when you look at the genetic code

00:24:26,370 --> 00:24:30,450
you just get whatever you need and I

00:24:28,770 --> 00:24:32,910
don't think you can get better interface

00:24:30,450 --> 00:24:36,720
and that the more clarity of what you

00:24:32,910 --> 00:24:38,580
want to be doing well we can't we can do

00:24:36,720 --> 00:24:40,380
stuff like this you can actually do far

00:24:38,580 --> 00:24:42,960
more so boost MSM is actually something

00:24:40,380 --> 00:24:44,700
that builds state machine from from

00:24:42,960 --> 00:24:47,400
operator overloading and generate the

00:24:44,700 --> 00:24:51,930
perfect autumn a ton for doing it it's

00:24:47,400 --> 00:24:54,600
quite a bit impressive there is a bunch

00:24:51,930 --> 00:24:57,780
of magic linear algebra matrixes basic

00:24:54,600 --> 00:24:59,880
question templates they are all get very

00:24:57,780 --> 00:25:02,850
nice features I mean you can basically

00:24:59,880 --> 00:25:04,800
do whatever the question is I mean it's

00:25:02,850 --> 00:25:06,060
like in spider-man you know right with

00:25:04,800 --> 00:25:09,650
red power comes great responsibility

00:25:06,060 --> 00:25:11,880
that what do you want to do with it okay

00:25:09,650 --> 00:25:14,070
sometimes you should be just not doing

00:25:11,880 --> 00:25:17,070
it because you may find them far simpler

00:25:14,070 --> 00:25:19,800
design without any lazy stuff inside if

00:25:17,070 --> 00:25:22,860
you can't do it okay but sometimes you

00:25:19,800 --> 00:25:25,650
really want to access okay so what does

00:25:22,860 --> 00:25:29,010
it imitation and we so and there is some

00:25:25,650 --> 00:25:35,850
work being done try to into to finds us

00:25:29,010 --> 00:25:37,770
um so the other one okay so first

00:25:35,850 --> 00:25:39,930
question is should i still doing this as

00:25:37,770 --> 00:25:41,700
i said we have mu cementing web copy

00:25:39,930 --> 00:25:44,100
additions we have a far more better

00:25:41,700 --> 00:25:45,390
compiler than before and yes most of the

00:25:44,100 --> 00:25:46,920
time if you are only looking at

00:25:45,390 --> 00:25:49,320
performances is probably not what you

00:25:46,920 --> 00:25:51,420
really want to do because the benefits

00:25:49,320 --> 00:25:54,060
risk analysis is not in favor of this

00:25:51,420 --> 00:25:55,950
kind of stuff but what you really want

00:25:54,060 --> 00:25:59,010
to do is write intentional code and that

00:25:55,950 --> 00:26:01,230
you cannot do using the compiler so you

00:25:59,010 --> 00:26:03,270
want to make your library as intentional

00:26:01,230 --> 00:26:06,180
as possible and efficient Empress is

00:26:03,270 --> 00:26:08,370
just writing for that you can extract

00:26:06,180 --> 00:26:10,260
information the comparator can't even

00:26:08,370 --> 00:26:12,990
see and you can use them at compile time

00:26:10,260 --> 00:26:15,240
to decide outright your gold and out

00:26:12,990 --> 00:26:19,350
generate the stuff and you can actually

00:26:15,240 --> 00:26:22,260
rise and we benefit from a lot of very

00:26:19,350 --> 00:26:24,840
very abstract I level optimization

00:26:22,260 --> 00:26:27,060
opportunities I was speaking in the

00:26:24,840 --> 00:26:29,640
break about facts are to collectively we

00:26:27,060 --> 00:26:31,830
can actually wrote a signal processing

00:26:29,640 --> 00:26:33,960
library when you have signal and you

00:26:31,830 --> 00:26:35,490
have nose classes and you know that if

00:26:33,960 --> 00:26:37,680
you want to come you ate the signal with

00:26:35,490 --> 00:26:38,330
a noise which is white you don't have to

00:26:37,680 --> 00:26:40,700
do to your

00:26:38,330 --> 00:26:43,340
food combination for rehab of simple

00:26:40,700 --> 00:26:45,049
algorithms okay and so you can detects

00:26:43,340 --> 00:26:47,450
act and generate the proper algorithm

00:26:45,049 --> 00:26:49,940
but the compiler can't with that i mean

00:26:47,450 --> 00:26:53,799
it's it's human level information okay

00:26:49,940 --> 00:26:56,809
so you want to perform domain-specific

00:26:53,799 --> 00:26:58,850
optimization because if you just want to

00:26:56,809 --> 00:27:00,799
generate the perfect for loop with

00:26:58,850 --> 00:27:02,539
vectorization and whatnot is probably

00:27:00,799 --> 00:27:04,490
overkill because most of the conveyor I

00:27:02,539 --> 00:27:05,929
probably do it right right now except

00:27:04,490 --> 00:27:08,570
for some kind of cases when you need

00:27:05,929 --> 00:27:10,460
this but as soon as you want to read

00:27:08,570 --> 00:27:12,019
benefit from higher level optimizations

00:27:10,460 --> 00:27:16,039
that what you will be seeking with a

00:27:12,019 --> 00:27:19,549
fusion ten things so I'm going back to

00:27:16,039 --> 00:27:22,570
auto so I was speaking about n 4235 so

00:27:19,549 --> 00:27:25,610
the idea is to be able to write that

00:27:22,570 --> 00:27:27,350
soul of a product expert which is some

00:27:25,610 --> 00:27:29,899
kind of you know lazy nodes that we

00:27:27,350 --> 00:27:33,080
wrote that captures matrix project okay

00:27:29,899 --> 00:27:35,980
and what we want to say that oh wait if

00:27:33,080 --> 00:27:39,500
you use auto on that I don't want you to

00:27:35,980 --> 00:27:42,080
give me product expert giving mattress

00:27:39,500 --> 00:27:44,120
insane instead so this this notation

00:27:42,080 --> 00:27:46,940
just say whenever you use auto on that

00:27:44,120 --> 00:27:49,490
give me this instant that means that you

00:27:46,940 --> 00:27:53,360
can actually wrote code exists so this

00:27:49,490 --> 00:27:56,090
Auto Z or a times B uses using auto

00:27:53,360 --> 00:27:58,279
record notation and that's basically

00:27:56,090 --> 00:28:01,419
matrix Z equal a times V which is

00:27:58,279 --> 00:28:04,220
exactly what you may intuitively want

00:28:01,419 --> 00:28:06,470
but if you really really want the lazy

00:28:04,220 --> 00:28:10,370
expression you can just write x fish it

00:28:06,470 --> 00:28:13,130
auto w equal a times B and you get the

00:28:10,370 --> 00:28:16,159
real auto behaviors okay so that's

00:28:13,130 --> 00:28:18,289
something we're still working on it yet

00:28:16,159 --> 00:28:21,190
somehow we're received so we are still

00:28:18,289 --> 00:28:25,549
up to get true but that's some

00:28:21,190 --> 00:28:27,380
interesting texts and one thing is that

00:28:25,549 --> 00:28:30,799
ok it's useful five different templates

00:28:27,380 --> 00:28:33,380
but not only it's actually useful for

00:28:30,799 --> 00:28:35,090
any kind of proxy times where you don't

00:28:33,380 --> 00:28:37,580
really want to store the proxy type in

00:28:35,090 --> 00:28:39,590
October the real actual type speed so

00:28:37,580 --> 00:28:41,450
that's something we can actually walk

00:28:39,590 --> 00:28:45,260
with its mo generals and expression

00:28:41,450 --> 00:28:47,809
templates and my actually my secret

00:28:45,260 --> 00:28:50,720
agenda is trying to find the most the

00:28:47,809 --> 00:28:51,630
biggest amount of generically applicable

00:28:50,720 --> 00:28:54,720
such as

00:28:51,630 --> 00:28:56,670
languages so some was a problem are

00:28:54,720 --> 00:28:58,590
solved and I can use it into expression

00:28:56,670 --> 00:29:00,690
templates related problems okay just

00:28:58,590 --> 00:29:05,220
don't just kids answer to video please

00:29:00,690 --> 00:29:09,750
but so unless the stuff i try to do

00:29:05,220 --> 00:29:12,240
recently is so for for the people that

00:29:09,750 --> 00:29:15,360
doesn't know so I mentored with the odd

00:29:12,240 --> 00:29:19,440
for his work on booster for two years

00:29:15,360 --> 00:29:21,810
now and looking at what we did in Anna

00:29:19,440 --> 00:29:24,690
will say okay we have all these cool c

00:29:21,810 --> 00:29:26,850
plus was 14 days tricks that give us a

00:29:24,690 --> 00:29:29,070
very lightweight and very interesting

00:29:26,850 --> 00:29:32,250
way to write the flag topple in sin and

00:29:29,070 --> 00:29:34,140
phoenixes and shouldn't we be using this

00:29:32,250 --> 00:29:36,540
kind of tricks to rewrite something

00:29:34,140 --> 00:29:39,000
which is new plugs booth prado except

00:29:36,540 --> 00:29:41,880
probably come by faster and with less

00:29:39,000 --> 00:29:46,530
code okay so i started working on that

00:29:41,880 --> 00:29:49,080
and the idea was to do what I know Cole

00:29:46,530 --> 00:29:51,240
well it was not there Matt with it well

00:29:49,080 --> 00:29:53,580
again we we have sister with calling

00:29:51,240 --> 00:29:56,550
recently which is a we want to have a

00:29:53,580 --> 00:29:57,840
sustainable library sustainable library

00:29:56,550 --> 00:30:00,420
means that it's easy to use for the

00:29:57,840 --> 00:30:03,860
users if not you kind of faded doing it

00:30:00,420 --> 00:30:06,600
okay but the inside of the library is

00:30:03,860 --> 00:30:08,640
also simple to look at and understand

00:30:06,600 --> 00:30:10,530
because you don't really want to have a

00:30:08,640 --> 00:30:13,160
lot of language lawyers like Beyonce to

00:30:10,530 --> 00:30:15,540
2x venue was going on in to the library

00:30:13,160 --> 00:30:16,770
this need actually raised from the fact

00:30:15,540 --> 00:30:18,240
that when you work with people with

00:30:16,770 --> 00:30:20,730
different level of C professed knowledge

00:30:18,240 --> 00:30:23,130
and you and your job is actually like me

00:30:20,730 --> 00:30:24,900
writing libraries is very complex to to

00:30:23,130 --> 00:30:26,940
get everybody on the same you know level

00:30:24,900 --> 00:30:28,260
stuff so the simplest called advises the

00:30:26,940 --> 00:30:30,330
library level as the whopper of

00:30:28,260 --> 00:30:32,940
libraries but it is as soon as we keep

00:30:30,330 --> 00:30:35,070
the same level of usability so we want

00:30:32,940 --> 00:30:37,410
it to be sustainable so the trick is to

00:30:35,070 --> 00:30:40,650
say are we use what I call similar in

00:30:37,410 --> 00:30:43,530
compression too fast and too many times

00:30:40,650 --> 00:30:45,270
by reducing the amount of text into the

00:30:43,530 --> 00:30:47,430
same own name of the expression and this

00:30:45,270 --> 00:30:50,790
is done by actually using C++

00:30:47,430 --> 00:30:53,550
polymorphic lenders to generate the

00:30:50,790 --> 00:30:56,550
expression note so I will just show you

00:30:53,550 --> 00:31:00,000
that and so it still not complete I

00:30:56,550 --> 00:31:03,150
still have to write to work on the how

00:31:00,000 --> 00:31:04,890
to actually add semantic to the stuff

00:31:03,150 --> 00:31:12,600
but the idea is this one

00:31:04,890 --> 00:31:14,310
okay where is it so just a blue cat but

00:31:12,600 --> 00:31:17,640
going on so we have we have an

00:31:14,310 --> 00:31:19,560
expression class okay so it's a bit

00:31:17,640 --> 00:31:23,160
rough the idea is that we have an

00:31:19,560 --> 00:31:26,640
expression class that contains a tree as

00:31:23,160 --> 00:31:29,390
a type like night before but this tree

00:31:26,640 --> 00:31:32,520
is actually not another expression

00:31:29,390 --> 00:31:37,470
another classes which is recursive

00:31:32,520 --> 00:31:41,520
Oliver it's actually and I think we saw

00:31:37,470 --> 00:31:45,900
it there the tree is actually a lambda

00:31:41,520 --> 00:31:49,260
and what does Islam the dots well it

00:31:45,900 --> 00:31:51,240
takes a visitor as a parameter and the

00:31:49,260 --> 00:31:57,750
visitor will be applied on what the

00:31:51,240 --> 00:32:00,470
resin lambda contain okay and all it is

00:31:57,750 --> 00:32:02,910
this lambda build so this is a bit off

00:32:00,470 --> 00:32:08,610
okay this is basically what happened

00:32:02,910 --> 00:32:10,320
there so I have a bunch of types values

00:32:08,610 --> 00:32:14,160
i want to put as the children of my

00:32:10,320 --> 00:32:18,810
expression and what I do is I built this

00:32:14,160 --> 00:32:21,990
lambda their tree which is taking a

00:32:18,810 --> 00:32:23,910
visitor v and what does it do when

00:32:21,990 --> 00:32:28,350
whenever you passively talk to my lambda

00:32:23,910 --> 00:32:32,370
i called my visitor function cooperator

00:32:28,350 --> 00:32:35,280
on what on a value which is a tag of the

00:32:32,370 --> 00:32:38,070
expression i'm currently building plus

00:32:35,280 --> 00:32:41,520
minus extra and all the children of this

00:32:38,070 --> 00:32:45,180
that get captures x value automatically

00:32:41,520 --> 00:32:50,490
okay and I just build an expert of type

00:32:45,180 --> 00:32:53,940
of these three these three okay so what

00:32:50,490 --> 00:32:56,280
I say that sub tree is no more than a

00:32:53,940 --> 00:32:58,350
closure that will accept the visitor

00:32:56,280 --> 00:33:01,110
which is coming from the transform when

00:32:58,350 --> 00:33:03,690
I go down to three and at every level of

00:33:01,110 --> 00:33:06,660
this I know where I'm I am because I

00:33:03,690 --> 00:33:10,830
cause visitor with my tag so the visitor

00:33:06,660 --> 00:33:13,950
knows what's going on okay it may it may

00:33:10,830 --> 00:33:17,870
not care about my time but if it does in

00:33:13,950 --> 00:33:17,870
know where where and I can match on them

00:33:17,920 --> 00:33:25,900
and surprisingly it was by surprisingly

00:33:21,760 --> 00:33:28,060
i mean really surprisingly and one

00:33:25,900 --> 00:33:31,810
interesting point is this is a kind of

00:33:28,060 --> 00:33:36,280
type you get I know if it is it but why

00:33:31,810 --> 00:33:39,130
I don't have anymore ok so do them I is

00:33:36,280 --> 00:33:43,450
a zoom okay for the text or not maybe I

00:33:39,130 --> 00:33:55,210
can actually probably get better five

00:33:43,450 --> 00:33:57,970
seconds okay oh well where is it look at

00:33:55,210 --> 00:34:00,940
that that that's the output I just build

00:33:57,970 --> 00:34:03,760
an expression and I print the type name

00:34:00,940 --> 00:34:07,300
okay using Domingo okay and that's

00:34:03,760 --> 00:34:09,669
compiled with visual studio 2050 which

00:34:07,300 --> 00:34:12,850
suppresses 14 supports so exactly

00:34:09,669 --> 00:34:14,980
comprised on reserves to you so I have

00:34:12,850 --> 00:34:18,220
an expert look at that I'm an expert

00:34:14,980 --> 00:34:20,770
that contain what a lambda of this type

00:34:18,220 --> 00:34:24,910
lambda and the scroll aaf 19 rubber blog

00:34:20,770 --> 00:34:28,960
which is probably a ash or something can

00:34:24,910 --> 00:34:33,130
I actually get everything just in case

00:34:28,960 --> 00:34:36,669
we may need agree so this lambda and the

00:34:33,130 --> 00:34:39,460
score 42 characters which probably Sasha

00:34:36,669 --> 00:34:41,050
one or or some other ash that's

00:34:39,460 --> 00:34:42,790
basically the type automatically

00:34:41,050 --> 00:34:46,419
generated by the compiler for the lambda

00:34:42,790 --> 00:34:49,900
and good news everyone on user studio is

00:34:46,419 --> 00:34:53,230
a fixed size idea of identifiers the

00:34:49,900 --> 00:34:56,310
first one is a plus B the second one

00:34:53,230 --> 00:34:59,830
same time is a plus B plus a plus B and

00:34:56,310 --> 00:35:03,490
so on and the third one is a + b + a + b

00:34:59,830 --> 00:35:05,890
+ a + b + h + b and the last one is that

00:35:03,490 --> 00:35:09,150
again which itself so it's like about 16

00:35:05,890 --> 00:35:14,070
symbols and it stays the same size

00:35:09,150 --> 00:35:14,070
roughly 40 characters or something okay

00:35:14,220 --> 00:35:20,020
well it's not dimmable I mean well

00:35:17,380 --> 00:35:22,240
that's very beginning when I am a bug

00:35:20,020 --> 00:35:24,370
somewhere inside the lambda you got

00:35:22,240 --> 00:35:28,230
message like okay I cannot find this

00:35:24,370 --> 00:35:32,140
angie's in lambda 1 2 3 4 5 6 okay great

00:35:28,230 --> 00:35:34,690
so don't do birds looking hot choking so

00:35:32,140 --> 00:35:37,390
I think that Georgie Guzman newest I

00:35:34,690 --> 00:35:39,910
think at the exact same idea for spirit

00:35:37,390 --> 00:35:42,970
tree and discarded it because of the

00:35:39,910 --> 00:35:45,190
difficulty of debugging I'm still

00:35:42,970 --> 00:35:48,370
thinking that the benefits outweigh the

00:35:45,190 --> 00:35:51,420
risk because we basically get constant

00:35:48,370 --> 00:35:58,720
time computation time with effective the

00:35:51,420 --> 00:36:00,460
complexity of the three yes I want to

00:35:58,720 --> 00:36:05,470
drink in that so that's sucked through

00:36:00,460 --> 00:36:07,810
on msvc on the other compilers you still

00:36:05,470 --> 00:36:11,140
carries is the name of the function the

00:36:07,810 --> 00:36:15,400
lambda was built into into the name so

00:36:11,140 --> 00:36:19,390
it's a bit longer and if you do the

00:36:15,400 --> 00:36:23,290
tricks on Jesus your can you see that

00:36:19,390 --> 00:36:25,330
the symbol names grow linearly but by

00:36:23,290 --> 00:36:28,120
probably eight or ten characters at the

00:36:25,330 --> 00:36:31,090
time instead of the huge mess you get

00:36:28,120 --> 00:36:33,820
with the regular one so I still think

00:36:31,090 --> 00:36:36,130
that as GCC and claim combined fascist

00:36:33,820 --> 00:36:37,930
and wizards to do one in the others is

00:36:36,130 --> 00:36:39,880
basically as fast as if on both sides

00:36:37,930 --> 00:36:42,370
now I don't know if there is anybody

00:36:39,880 --> 00:36:45,580
from GCC are playing there or we watched

00:36:42,370 --> 00:36:47,890
video please to whatever msec does when

00:36:45,580 --> 00:36:52,330
they named their lambdas please thank

00:36:47,890 --> 00:36:54,070
you so that probably the best idea the

00:36:52,330 --> 00:36:56,410
visual studio implementers add on this

00:36:54,070 --> 00:36:59,260
point it's a very very interesting

00:36:56,410 --> 00:37:02,410
techniques and the other funky stuff is

00:36:59,260 --> 00:37:04,870
that we also find a way to say okay now

00:37:02,410 --> 00:37:08,110
I know if I need to copy or not so by

00:37:04,870 --> 00:37:12,100
default this library take everything x

00:37:08,110 --> 00:37:14,740
value my reference sorry except when is

00:37:12,100 --> 00:37:17,920
he knows he's dangerous and so what we

00:37:14,740 --> 00:37:20,920
did is a natural that I I actually have

00:37:17,920 --> 00:37:23,800
to st. Louis for that because I was

00:37:20,920 --> 00:37:29,500
swamp it by a lot of time in this so

00:37:23,800 --> 00:37:33,280
what we do is this kind of thing so when

00:37:29,500 --> 00:37:37,600
should i store a sub expression as value

00:37:33,280 --> 00:37:39,760
or not well if the stuff you give me is

00:37:37,600 --> 00:37:41,890
a value that probably means that is

00:37:39,760 --> 00:37:43,600
lifetime is bigger than the lifetime of

00:37:41,890 --> 00:37:46,090
the expression so i will just take a

00:37:43,600 --> 00:37:48,820
reference to it and if not

00:37:46,090 --> 00:37:51,730
if it's ever you i will save it into a

00:37:48,820 --> 00:37:54,970
value by doing a copy oh well sorry by

00:37:51,730 --> 00:37:57,250
doing a move assignment or something so

00:37:54,970 --> 00:37:59,500
that was the storage type t does i mean

00:37:57,250 --> 00:38:03,760
if i were you i just decay everything if

00:37:59,500 --> 00:38:06,460
not i'm keeping it as a reference except

00:38:03,760 --> 00:38:09,040
there is a problem you have no way when

00:38:06,460 --> 00:38:11,440
you define a lambda to select for each

00:38:09,040 --> 00:38:14,260
captures which one will be stored in

00:38:11,440 --> 00:38:16,330
your world another I think that's fix it

00:38:14,260 --> 00:38:19,900
in 17 or something but it's still

00:38:16,330 --> 00:38:21,820
limited so what we do is it's like pool

00:38:19,900 --> 00:38:24,160
win over you you cannot go to the or

00:38:21,820 --> 00:38:26,050
directly so you do a band you know so

00:38:24,160 --> 00:38:28,720
what we do is we build a lender that

00:38:26,050 --> 00:38:31,750
captures everything by reference this a

00:38:28,720 --> 00:38:36,130
right stop stop and inside you build a

00:38:31,750 --> 00:38:38,080
regular structure that uses storage

00:38:36,130 --> 00:38:42,430
types on the types of whatever its

00:38:38,080 --> 00:38:44,820
capture okay to decide all to store it

00:38:42,430 --> 00:38:48,690
and you just forward the value to it and

00:38:44,820 --> 00:38:50,950
this lambda just returned a new node and

00:38:48,690 --> 00:38:53,740
much you return is an expression

00:38:50,950 --> 00:38:56,230
containing this node so you have a land

00:38:53,740 --> 00:38:59,290
are building the small scale structures

00:38:56,230 --> 00:39:02,050
from either inside that as access to

00:38:59,290 --> 00:39:04,420
everything from outside by the capture

00:39:02,050 --> 00:39:07,330
which means that if not in his own type

00:39:04,420 --> 00:39:10,690
there is no template site something

00:39:07,330 --> 00:39:12,550
there that's where the magic is there is

00:39:10,690 --> 00:39:15,280
no relationship between the node name

00:39:12,550 --> 00:39:19,540
and the whatever contents of the time

00:39:15,280 --> 00:39:20,890
and what I learned is this evening that

00:39:19,540 --> 00:39:23,740
you can actually put the strap them

00:39:20,890 --> 00:39:26,230
inside and other locally inside the

00:39:23,740 --> 00:39:28,720
function I didn't know the answer so you

00:39:26,230 --> 00:39:30,580
do this and you can actually change

00:39:28,720 --> 00:39:34,270
whatever you do this so you can do for

00:39:30,580 --> 00:39:36,460
one you can do it for two or you can do

00:39:34,270 --> 00:39:38,290
it for three and so on and you can when

00:39:36,460 --> 00:39:39,910
you have too much you can just put

00:39:38,290 --> 00:39:43,780
everything into a top pole and sleep on

00:39:39,910 --> 00:39:46,320
it okay and you can forward precisely

00:39:43,780 --> 00:39:49,810
everything the way you want into each

00:39:46,320 --> 00:39:52,930
sub element of three and so how does

00:39:49,810 --> 00:39:54,640
this I will screw myself by computing

00:39:52,930 --> 00:39:57,160
something in the temporary in the

00:39:54,640 --> 00:39:59,400
function and i will get dining reference

00:39:57,160 --> 00:40:03,420
get solved it yet solved

00:39:59,400 --> 00:40:06,839
where we call which is natural where is

00:40:03,420 --> 00:40:08,849
a function okay that's that's a very

00:40:06,839 --> 00:40:11,460
rough example but this is what we were

00:40:08,849 --> 00:40:14,670
doing there is a let's say that track is

00:40:11,460 --> 00:40:17,760
something that is costly to do okay

00:40:14,670 --> 00:40:21,390
that's our local value that may contain

00:40:17,760 --> 00:40:24,210
you pointed something well if you want

00:40:21,390 --> 00:40:28,770
it to be copied into your tree you just

00:40:24,210 --> 00:40:30,869
move it inside which is something which

00:40:28,770 --> 00:40:33,539
is looked like something makes sense in

00:40:30,869 --> 00:40:35,789
the language itself even if R is not if

00:40:33,539 --> 00:40:37,319
it was not expression template okay have

00:40:35,789 --> 00:40:39,180
something there I want to move it into

00:40:37,319 --> 00:40:42,359
the outside I don't want to copy because

00:40:39,180 --> 00:40:45,240
I knew it we die okay so just use move

00:40:42,359 --> 00:40:47,700
whenever you make sense so it doesn't

00:40:45,240 --> 00:40:49,829
have to rely on the knowledge of what is

00:40:47,700 --> 00:40:51,990
going on into the expression template

00:40:49,829 --> 00:40:54,299
system if I put this there but I just

00:40:51,990 --> 00:40:57,299
move it and if we do what you want to do

00:40:54,299 --> 00:41:00,329
okay and you don't move it who blows up

00:40:57,299 --> 00:41:02,039
so just move it so the only limitation

00:41:00,329 --> 00:41:05,329
of that is that you have X and you want

00:41:02,039 --> 00:41:08,430
to put it twice into the same

00:41:05,329 --> 00:41:09,720
expressions you cannot move it twice so

00:41:08,430 --> 00:41:11,460
you probably want to make a copy first

00:41:09,720 --> 00:41:14,190
and copy the other one or something like

00:41:11,460 --> 00:41:15,809
this but that's the only I mean weak

00:41:14,190 --> 00:41:19,349
points we found of these techniques and

00:41:15,809 --> 00:41:21,210
the rest just walks perfectly just copy

00:41:19,349 --> 00:41:24,059
if you want to copy and move you want to

00:41:21,210 --> 00:41:27,210
move and everything is logical as if it

00:41:24,059 --> 00:41:29,549
was regular cool and so the example

00:41:27,210 --> 00:41:32,819
actually do this Lucy so i have f of

00:41:29,549 --> 00:41:34,680
copy F of F F of F of F and so on and we

00:41:32,819 --> 00:41:37,799
take care about almost move and copy

00:41:34,680 --> 00:41:40,319
with us and actually we do the exact

00:41:37,799 --> 00:41:42,990
amount of movie and no copies each time

00:41:40,319 --> 00:41:45,299
so we know that we did the correct so

00:41:42,990 --> 00:41:47,430
we're still working on that all right

00:41:45,299 --> 00:41:49,829
somewhere on github on my on my account

00:41:47,430 --> 00:41:53,180
it's not complete yet but trying to get

00:41:49,829 --> 00:41:56,510
something done with this I got rough

00:41:53,180 --> 00:41:59,640
computation time numbers it's far better

00:41:56,510 --> 00:42:01,799
up to two to three times faster there

00:41:59,640 --> 00:42:05,010
are still some kruky cases where it just

00:42:01,799 --> 00:42:08,970
blow ups but it looks nice so probably

00:42:05,010 --> 00:42:11,460
more than later sober let's go radical

00:42:08,970 --> 00:42:13,230
what if you can actually change your

00:42:11,460 --> 00:42:15,000
language is so

00:42:13,230 --> 00:42:19,140
to make sense to write excellent embrace

00:42:15,000 --> 00:42:20,730
us as a first-class citizens so if you

00:42:19,140 --> 00:42:23,340
look at other languages like template

00:42:20,730 --> 00:42:25,859
ask you know me talk mo there are two

00:42:23,340 --> 00:42:30,720
functional language with sort of support

00:42:25,859 --> 00:42:33,390
for introspection the average concept of

00:42:30,720 --> 00:42:37,680
code fragment a code fragment is a piece

00:42:33,390 --> 00:42:40,560
of code enviable okay and you can create

00:42:37,680 --> 00:42:42,750
some you can build the bigger one by

00:42:40,560 --> 00:42:44,790
concatenating those code fragment and

00:42:42,750 --> 00:42:47,820
when you are p with it you can just bang

00:42:44,790 --> 00:42:50,160
it and you get the value okay so that's

00:42:47,820 --> 00:42:52,770
the example I got there with the that's

00:42:50,160 --> 00:42:55,230
metal chemo so I just beat the code

00:42:52,770 --> 00:42:58,380
containing one plus two and the type of

00:42:55,230 --> 00:43:00,480
this is a code returning in the end so

00:42:58,380 --> 00:43:04,320
that's this dot bracket stuff that do

00:43:00,480 --> 00:43:06,420
this you have a dot T let's say that

00:43:04,320 --> 00:43:08,910
could piece of code and expanded inside

00:43:06,420 --> 00:43:11,460
another one okay so you can combine

00:43:08,910 --> 00:43:13,859
piece of code and when you don't Doug

00:43:11,460 --> 00:43:16,410
bang it takes a fragment of the code and

00:43:13,859 --> 00:43:19,200
just compile it and get you the result

00:43:16,410 --> 00:43:21,060
at one time okay so the idea is can I

00:43:19,200 --> 00:43:24,530
actually do something like this in C++

00:43:21,060 --> 00:43:26,970
and does it make sense okay actually and

00:43:24,530 --> 00:43:28,980
how can we do that properly that's

00:43:26,970 --> 00:43:33,510
that's not problem I don't know how to

00:43:28,980 --> 00:43:35,340
do this volunteers were calmed the other

00:43:33,510 --> 00:43:37,440
idea is that we have size of we have

00:43:35,340 --> 00:43:40,080
data type what about adding an iced tea

00:43:37,440 --> 00:43:42,450
off taking a bitoni expression and give

00:43:40,080 --> 00:43:43,950
you three and do something with it but

00:43:42,450 --> 00:43:46,560
the problem is all do you want to use

00:43:43,950 --> 00:43:48,150
that to pass the lazy version of an

00:43:46,560 --> 00:43:51,690
expression to a function without having

00:43:48,150 --> 00:43:54,090
to write f of iced tea off and that

00:43:51,690 --> 00:43:57,030
quickly escalate into all that means

00:43:54,090 --> 00:43:58,800
that I need to write f of lazy tea or

00:43:57,030 --> 00:44:01,170
some stuff exists and you start to be

00:43:58,800 --> 00:44:05,880
ugly okay so that's that's not that

00:44:01,170 --> 00:44:10,020
trivial matter so let's conclude that so

00:44:05,880 --> 00:44:13,109
what is a deposit okay so why did we not

00:44:10,020 --> 00:44:15,420
actually so expedient templates we can

00:44:13,109 --> 00:44:17,400
actually write the main so main stuff we

00:44:15,420 --> 00:44:19,290
have to remember is that we are not only

00:44:17,400 --> 00:44:21,390
there for performances that's a side

00:44:19,290 --> 00:44:24,090
effect we use expression templates to

00:44:21,390 --> 00:44:26,070
build intentional code with cold clarity

00:44:24,090 --> 00:44:29,470
as as a first goal okay

00:44:26,070 --> 00:44:31,630
we saw that if you really want it you

00:44:29,470 --> 00:44:34,600
can actually write a very small scale

00:44:31,630 --> 00:44:36,940
and made extra 10 / 10 join for very

00:44:34,600 --> 00:44:39,130
very limited scope and if not you have

00:44:36,940 --> 00:44:42,940
tools like booth Prado that actually

00:44:39,130 --> 00:44:46,750
simplify such needham by providing all

00:44:42,940 --> 00:44:48,370
the boiler plates already there and we

00:44:46,750 --> 00:44:50,800
have some gotchas especially with

00:44:48,370 --> 00:44:52,540
automatic deductions and move semantics

00:44:50,800 --> 00:44:54,400
you have to be careful which probably

00:44:52,540 --> 00:44:58,270
means that the tools us to be updated

00:44:54,400 --> 00:45:00,780
like what we said so what to do so you

00:44:58,270 --> 00:45:05,830
are designing a library that's the main

00:45:00,780 --> 00:45:07,450
first point and see if your design of

00:45:05,830 --> 00:45:08,800
your library can actually be turning to

00:45:07,450 --> 00:45:10,750
the designer for language more than the

00:45:08,800 --> 00:45:12,490
library and if yes then you can actually

00:45:10,750 --> 00:45:14,800
play with education template as a way to

00:45:12,490 --> 00:45:16,810
increase so-called intentionality that's

00:45:14,800 --> 00:45:18,700
very important the library should be as

00:45:16,810 --> 00:45:21,760
intuitive as possible and expression

00:45:18,700 --> 00:45:24,310
templates LP you doing this and then

00:45:21,760 --> 00:45:26,440
actually you can rely on to like go

00:45:24,310 --> 00:45:28,840
stroller or staff can actually see you

00:45:26,440 --> 00:45:30,730
can actually I mean proto is called

00:45:28,840 --> 00:45:33,520
further because it f you do prototypes

00:45:30,730 --> 00:45:34,990
okay so prototypes is in provo see what

00:45:33,520 --> 00:45:37,510
kind of feelings you want to give to

00:45:34,990 --> 00:45:39,400
your library and then fine tune it and

00:45:37,510 --> 00:45:43,240
it doesn't work just complain to your

00:45:39,400 --> 00:45:46,950
fabric compiler vandals okay so that's

00:45:43,240 --> 00:45:49,750
what we want to do we want to be I mean

00:45:46,950 --> 00:45:51,340
we have to actually template that as a

00:45:49,750 --> 00:45:53,230
technique as to move from oyin that

00:45:51,340 --> 00:45:55,150
these tough people does when they end or

00:45:53,230 --> 00:45:56,800
bigger race okay know that not just that

00:45:55,150 --> 00:45:58,450
it's the only way we have to be

00:45:56,800 --> 00:46:00,760
libraries with an eye level of

00:45:58,450 --> 00:46:04,060
intentionality that Steve give us the

00:46:00,760 --> 00:46:06,520
opportunity to get cross function or

00:46:04,060 --> 00:46:08,410
cross expression optimization at a very

00:46:06,520 --> 00:46:09,850
high level because we have everything

00:46:08,410 --> 00:46:12,280
under the eyes and we can take the

00:46:09,850 --> 00:46:15,730
decision about what is important at this

00:46:12,280 --> 00:46:18,160
level of optimization so that's what we

00:46:15,730 --> 00:46:20,140
really want to do so as a crossing point

00:46:18,160 --> 00:46:21,820
I want to sense a lot of people so join

00:46:20,140 --> 00:46:24,250
the Guzman which is probably the one guy

00:46:21,820 --> 00:46:25,900
that brought this lambda DSN stuff first

00:46:24,250 --> 00:46:27,760
before me I don't remember but I

00:46:25,900 --> 00:46:30,280
remember discussing it with it at some

00:46:27,760 --> 00:46:33,550
point Louis for fixing my crappy

00:46:30,280 --> 00:46:36,220
implementation of the same concept every

00:46:33,550 --> 00:46:37,690
KIBRA for booze Prado which is actually

00:46:36,220 --> 00:46:41,080
a great piece of code

00:46:37,690 --> 00:46:44,170
a and urban pr4 for the kanji what we

00:46:41,080 --> 00:46:46,600
work on 40 35 so thank you for attention

00:46:44,170 --> 00:46:49,990
I I offer i didn't eat too much people

00:46:46,600 --> 00:46:52,350
okay but don't say I can't eat ten

00:46:49,990 --> 00:46:55,210
percent of the audience or probably okay

00:46:52,350 --> 00:47:08,700
if you have any question gladdie answers

00:46:55,210 --> 00:47:08,700
and thanks again for your attention yes

00:47:18,540 --> 00:47:23,500
okay so the question is I also chose

00:47:21,880 --> 00:47:26,830
between using boots Prado and doing the

00:47:23,500 --> 00:47:30,360
old fashioned way by doing it by n what

00:47:26,830 --> 00:47:34,420
should be the choice when should I chose

00:47:30,360 --> 00:47:39,720
from experience I would say as soon as

00:47:34,420 --> 00:47:41,860
you have let's say a decent set of

00:47:39,720 --> 00:47:43,780
functional operators like more than

00:47:41,860 --> 00:47:46,210
three or four I don't know very very

00:47:43,780 --> 00:47:47,950
small numbers you really don't want to

00:47:46,210 --> 00:47:50,080
get all the boiler placed on that very

00:47:47,950 --> 00:47:52,570
time consuming and you will get it wrong

00:47:50,080 --> 00:47:55,570
so as soon as you need a large selection

00:47:52,570 --> 00:47:58,060
of operators functions with Frodo it

00:47:55,570 --> 00:48:00,250
just it just everything just they're so

00:47:58,060 --> 00:48:02,110
cool stuff with boot photos that you can

00:48:00,250 --> 00:48:04,510
also prototype quickly something that

00:48:02,110 --> 00:48:06,850
getting any of the grammar of random

00:48:04,510 --> 00:48:08,800
stuff just play with the syntax look

00:48:06,850 --> 00:48:10,750
watch this expression tree looks like so

00:48:08,800 --> 00:48:13,540
you can see if you can actually manage

00:48:10,750 --> 00:48:17,050
to process it easily and when you are

00:48:13,540 --> 00:48:18,550
set on your sin tax and grammar where I

00:48:17,050 --> 00:48:20,410
so you finish the work with booze Prado

00:48:18,550 --> 00:48:22,960
then you know what you should be putting

00:48:20,410 --> 00:48:25,600
into your end fashion stuff we had a

00:48:22,960 --> 00:48:27,730
situation with recursive not recursively

00:48:25,600 --> 00:48:29,620
we're currently sorry with eric is that

00:48:27,730 --> 00:48:31,690
okay I deserve that I could have been

00:48:29,620 --> 00:48:33,280
doing the other way around yeah but you

00:48:31,690 --> 00:48:35,470
know that you could do it now because

00:48:33,280 --> 00:48:37,720
you played with the stuff so sometimes

00:48:35,470 --> 00:48:39,700
you just pray with Frodo and you know in

00:48:37,720 --> 00:48:41,800
what I call the immediate mode just

00:48:39,700 --> 00:48:43,960
right stuff with operators and see

00:48:41,800 --> 00:48:45,460
what's going on and when you know

00:48:43,960 --> 00:48:48,280
exactly what your language should look

00:48:45,460 --> 00:48:50,270
like and what these logical for

00:48:48,280 --> 00:48:52,250
transformation is just write it by

00:48:50,270 --> 00:48:54,340
but sometimes is so much easier than say

00:48:52,250 --> 00:48:57,050
okay I would just keep proto because I

00:48:54,340 --> 00:48:58,700
need a special semantics I need to have

00:48:57,050 --> 00:49:01,190
mutiple transforms that do this and that

00:48:58,700 --> 00:49:03,230
I need to regenerate 23 from a tree from

00:49:01,190 --> 00:49:05,420
a tree and so on and don't really want

00:49:03,230 --> 00:49:07,250
to do this by n so is there you have a

00:49:05,420 --> 00:49:09,560
very small amount of stuff or the

00:49:07,250 --> 00:49:12,080
transform is very trivial and then you

00:49:09,560 --> 00:49:14,300
do it by N or and if not I will just say

00:49:12,080 --> 00:49:17,750
go with this problem or whatever similar

00:49:14,300 --> 00:49:20,510
tools but you you need to be able to say

00:49:17,750 --> 00:49:22,340
something like well now I know what to

00:49:20,510 --> 00:49:25,130
do and and playing with loose Prado is

00:49:22,340 --> 00:49:27,080
often enough because just right with the

00:49:25,130 --> 00:49:29,030
stuff and you see okay I should be doing

00:49:27,080 --> 00:49:31,940
this disease because like the trees this

00:49:29,030 --> 00:49:34,190
way this way and I can't process it but

00:49:31,940 --> 00:49:36,890
I mean we we are living with booze Prado

00:49:34,190 --> 00:49:40,180
in alpha dozen of rivalry and we are

00:49:36,890 --> 00:49:42,290
just now slowly moving to you know

00:49:40,180 --> 00:49:44,840
removing proto and doing it by hand

00:49:42,290 --> 00:49:46,430
because we know where the spot out now

00:49:44,840 --> 00:49:48,830
but it took us years to do this because

00:49:46,430 --> 00:49:52,850
you're just there walking come by ten

00:49:48,830 --> 00:50:01,850
was ok so just let it there was a

00:49:52,850 --> 00:50:05,710
question ok so these are free to go I

00:50:01,850 --> 00:50:05,710

YouTube URL: https://www.youtube.com/watch?v=A9trwnv6k-w


