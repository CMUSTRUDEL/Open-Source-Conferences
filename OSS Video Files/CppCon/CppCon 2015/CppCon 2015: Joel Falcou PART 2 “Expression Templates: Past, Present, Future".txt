Title: CppCon 2015: Joel Falcou PART 2 “Expression Templates: Past, Present, Future"
Publication date: 2015-10-09
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Expression Templates is one of this C++ idiom people learn to either love or hate. The main issues with ET is that everubody has its own conception about what they are, when they should be used, what benefits they give and what are their trade off. For a long time, Expression Tempaltes has been seen has a way to improve temporary heavy code. If the seminal implementation of ET by Todd Veldhuizen was actually about this, the landscape has changed since C++11 and C++14.

This workshop will go over : - what are exactly Expression Templates and what kind of use case they can solve elegantly and efficiently - what are the benefits that one may reap by using expression tempalte in its library - what are the real cost of expressont empaltes both at runtime and compile-time - which tools to use to not reinvent the tempalte wheel everytime including an introduction to Boost.PROTO an Boost.HANA.

The main objective is to clarify why, even in C++1*, this idiom has a meaningful set of applications and how to navigate around its pitfalls.
— 
Joel Falcou is an assistant professor at the University Paris-Sud and researcher at the Laboratoire de Recherche d’Informatique in Orsay, France. His research focuses on studying generative programming idioms and techniques to design tools for parallel software development. The two main parts of those works are: exploration of Embedded Domain Specific Language design for parallel computing on various architectures and the definition of a formal framework for reasoning about meta-programs and prove their compile-time correctness. Applications range from real-time image processing on embedded architectures to High Performance Computing on multi-core clusters. He is a NumScale SAS scientific advisor. NumScale mission is to assist businesses in the exploration and subsequently the mastery of high-performance computing systems.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:07,980
but then I enter into Phase two of these

00:00:03,510 --> 00:00:10,500
three phases talk okay someone where is

00:00:07,980 --> 00:00:13,740
he over there someone mentioned

00:00:10,500 --> 00:00:15,630
something I forgot to show you so I will

00:00:13,740 --> 00:00:19,020
just show you now that I will use it to

00:00:15,630 --> 00:00:23,000
bit more afterwards as I would just take

00:00:19,020 --> 00:00:25,140
that okay and I will go somewhere else

00:00:23,000 --> 00:00:30,510
maybe some one of you knows these

00:00:25,140 --> 00:00:33,590
websites so a GCC dot God board dot org

00:00:30,510 --> 00:00:37,920
something just zoom a bit is it readable

00:00:33,590 --> 00:00:40,530
yep okay and that's very funny that

00:00:37,920 --> 00:00:42,930
stuff you can actually shortcode there

00:00:40,530 --> 00:00:45,690
is get compiled and you can have a look

00:00:42,930 --> 00:00:47,340
at the assembly on the other side and if

00:00:45,690 --> 00:00:49,110
you really really really doesn't want to

00:00:47,340 --> 00:00:51,539
want to do you can actually see all

00:00:49,110 --> 00:00:54,960
other compilers on other architectures

00:00:51,539 --> 00:00:57,480
behave okay that's very very interesting

00:00:54,960 --> 00:01:00,320
things to do it's very useful when you

00:00:57,480 --> 00:01:02,039
try oh so I got as you see now wonderful

00:01:00,320 --> 00:01:04,080
that's really interesting because

00:01:02,039 --> 00:01:06,810
sometimes you have you have performance

00:01:04,080 --> 00:01:08,430
issues which I especially template or

00:01:06,810 --> 00:01:10,710
not and you doesn't up in your friggin

00:01:08,430 --> 00:01:14,159
clue what's going on and this stuff is

00:01:10,710 --> 00:01:17,159
actually very useful yeah it's ohms but

00:01:14,159 --> 00:01:19,740
it's not really ok so just zoom okay

00:01:17,159 --> 00:01:23,130
okay so it's either i zoom or I just

00:01:19,740 --> 00:01:24,960
assume everything ok so if you look at

00:01:23,130 --> 00:01:28,320
their basically what the stuff is doing

00:01:24,960 --> 00:01:31,560
is a I don't even know what I print what

00:01:28,320 --> 00:01:34,950
do i print already yeah so he is

00:01:31,560 --> 00:01:36,840
probably eight and so yeah so if you

00:01:34,950 --> 00:01:39,119
look at this yet I just put eight into a

00:01:36,840 --> 00:01:41,490
register out into the others and I

00:01:39,119 --> 00:01:46,049
just call the injection operator doesn't

00:01:41,490 --> 00:01:52,320
have any function calls and if I lessen

00:01:46,049 --> 00:01:54,540
the optimization level same there same

00:01:52,320 --> 00:01:58,259
there so you really really want to do

00:01:54,540 --> 00:02:00,049
low and then now you start the OC

00:01:58,259 --> 00:02:04,829
function starting to appear into Z

00:02:00,049 --> 00:02:07,729
enthusiasm in emojis so if any oh one we

00:02:04,829 --> 00:02:10,500
still get well with what we want okay

00:02:07,729 --> 00:02:13,200
but the fair assumption on this is that

00:02:10,500 --> 00:02:13,650
you have to rely oh wait no sorry hear

00:02:13,200 --> 00:02:16,860
you

00:02:13,650 --> 00:02:19,709
you have to put your face faith sorry

00:02:16,860 --> 00:02:24,420
into the ability of your compiler to

00:02:19,709 --> 00:02:26,790
perform a lot a lot of in lining ok if

00:02:24,420 --> 00:02:29,900
you're comparison lining capabilities is

00:02:26,790 --> 00:02:34,470
bad you will have probably bad surprises

00:02:29,900 --> 00:02:38,220
ok so now so we went through all of this

00:02:34,470 --> 00:02:41,040
and we we saw that we have a way to

00:02:38,220 --> 00:02:43,260
build arbitrary tree at compile time

00:02:41,040 --> 00:02:45,739
containing information about the

00:02:43,260 --> 00:02:48,150
structure of an arbitrary expression oh

00:02:45,739 --> 00:02:51,319
there is plenty of tricks you can do

00:02:48,150 --> 00:02:54,629
with this one trick is that for example

00:02:51,319 --> 00:02:57,150
these assignment operators I showed a

00:02:54,629 --> 00:02:58,829
bit before there is cases where it

00:02:57,150 --> 00:03:02,430
should be good if we have the assignment

00:02:58,829 --> 00:03:04,650
operator inside 3 for example let's say

00:03:02,430 --> 00:03:09,840
you want to optimize matrix operation of

00:03:04,650 --> 00:03:12,689
the form see x equal a time Percy called

00:03:09,840 --> 00:03:14,700
a times B and you really really want to

00:03:12,689 --> 00:03:17,220
capture that and send it to a proper

00:03:14,700 --> 00:03:19,199
blast level three operations but for

00:03:17,220 --> 00:03:21,989
doing this you need to cap to see a and

00:03:19,199 --> 00:03:25,079
B so by making the plastic whole

00:03:21,989 --> 00:03:28,079
operation say something like ok I will

00:03:25,079 --> 00:03:30,540
evaluate something into what I need

00:03:28,079 --> 00:03:33,000
instead of everything eight times B and

00:03:30,540 --> 00:03:35,730
putting in somehow in to see you will

00:03:33,000 --> 00:03:37,889
say I will build a tree of plastic or

00:03:35,730 --> 00:03:40,530
assignment between C a and B and

00:03:37,889 --> 00:03:43,889
evaluate that so sometimes you want to

00:03:40,530 --> 00:03:45,419
build an arbitrary bigger tree into some

00:03:43,889 --> 00:03:48,859
other operators before calling the

00:03:45,419 --> 00:03:51,629
compression point so arbitrary functions

00:03:48,859 --> 00:03:54,949
called arbitrary operator scores get

00:03:51,629 --> 00:03:57,900
translated into statically represented

00:03:54,949 --> 00:03:59,790
three of the expressions that you can

00:03:57,900 --> 00:04:03,479
evaluate by doing some three terminals

00:03:59,790 --> 00:04:06,810
at the basics but such basics and we had

00:04:03,479 --> 00:04:09,120
a lot of stuff to do and one way to do

00:04:06,810 --> 00:04:12,060
this is to use tool for that don't

00:04:09,120 --> 00:04:15,389
really want to run your own tent

00:04:12,060 --> 00:04:18,359
expression templates in giant by n well

00:04:15,389 --> 00:04:21,750
you may want to a strongly advise

00:04:18,359 --> 00:04:24,599
against it ok for I try to do this

00:04:21,750 --> 00:04:27,490
during my PhD and I almost died ok so

00:04:24,599 --> 00:04:30,699
and yeah

00:04:27,490 --> 00:04:33,520
from the first time but it's fun the

00:04:30,699 --> 00:04:34,840
first time ok and it's definitely not

00:04:33,520 --> 00:04:36,789
the second time and all the time

00:04:34,840 --> 00:04:39,370
afterwards so it's better to rely on

00:04:36,789 --> 00:04:41,860
tues ok and one of the two that happens

00:04:39,370 --> 00:04:44,620
to exist for this is booth prado there

00:04:41,860 --> 00:04:46,479
wasn't a bit much of another tools

00:04:44,620 --> 00:04:48,910
that's called feet and Pumbaa maybe

00:04:46,479 --> 00:04:50,889
somebody someone of you know about those

00:04:48,910 --> 00:04:53,530
names which is basically the great

00:04:50,889 --> 00:04:57,220
ancestor of that so what's what's we had

00:04:53,530 --> 00:04:59,229
booze Prado as I say writing manual

00:04:57,220 --> 00:05:01,449
extraction template game Giants are

00:04:59,229 --> 00:05:03,970
quite limited so is far too much

00:05:01,449 --> 00:05:05,169
boilerplate if you only want to have

00:05:03,970 --> 00:05:07,990
something that has more than two

00:05:05,169 --> 00:05:11,530
operators on one terminal types okay

00:05:07,990 --> 00:05:13,330
forgot about your weekend and we have

00:05:11,530 --> 00:05:15,190
the problems at the data and the travels

00:05:13,330 --> 00:05:18,069
of the data are tried together and not

00:05:15,190 --> 00:05:22,530
try to mush coupled and it's not easy to

00:05:18,069 --> 00:05:25,960
work with other similar but a different

00:05:22,530 --> 00:05:27,639
expression template based code because

00:05:25,960 --> 00:05:29,349
we have no way to know which expression

00:05:27,639 --> 00:05:31,750
is coming from where and you basically

00:05:29,349 --> 00:05:33,270
up to special k is everything but

00:05:31,750 --> 00:05:36,449
sometimes you really want to have this

00:05:33,270 --> 00:05:38,710
cleaned expression coming from library a

00:05:36,449 --> 00:05:41,979
interlibrary be which happens to be the

00:05:38,710 --> 00:05:43,810
nozzle expressions but that means that B

00:05:41,979 --> 00:05:45,490
and a merger information about the

00:05:43,810 --> 00:05:48,219
representation of the tree not very

00:05:45,490 --> 00:05:49,419
practical so the solution is to find the

00:05:48,219 --> 00:05:52,030
generate interface for estrogen

00:05:49,419 --> 00:05:54,130
templates I was about to write concepts

00:05:52,030 --> 00:05:57,940
when I wrote that but then I forgot

00:05:54,130 --> 00:06:00,430
about on cookie could be and this during

00:05:57,940 --> 00:06:02,190
interphase asked to be genuine up so you

00:06:00,430 --> 00:06:04,500
can actually be arbitrary number of

00:06:02,190 --> 00:06:07,030
library based on different templates

00:06:04,500 --> 00:06:09,099
while knowing that they are all in terms

00:06:07,030 --> 00:06:13,330
of a rebel but yet you can actually

00:06:09,099 --> 00:06:14,919
steal you know difference again and what

00:06:13,330 --> 00:06:17,740
we need to do is to have a way to

00:06:14,919 --> 00:06:21,490
represent transformation of the tree in

00:06:17,740 --> 00:06:23,740
more let's say friendly way and one way

00:06:21,490 --> 00:06:26,430
to do this is to not reinvent the wheel

00:06:23,740 --> 00:06:28,690
and take pages from compilers and try to

00:06:26,430 --> 00:06:30,280
orchestrate your transformation into

00:06:28,690 --> 00:06:33,280
something like look let's compile your

00:06:30,280 --> 00:06:35,680
phases and finally we need to find

00:06:33,280 --> 00:06:41,080
solves the extension issues which is

00:06:35,680 --> 00:06:43,539
what if I want to take one tree

00:06:41,080 --> 00:06:45,729
and turn it into something and take the

00:06:43,539 --> 00:06:47,800
exact same tree and process it into a

00:06:45,729 --> 00:06:50,349
completely different way without having

00:06:47,800 --> 00:06:54,729
to revise your wall each time okay and

00:06:50,349 --> 00:06:57,819
that's what this photo try to do and do

00:06:54,729 --> 00:07:01,539
this we have to sit down a bit and look

00:06:57,819 --> 00:07:05,229
as a bigger picture when I say like one

00:07:01,539 --> 00:07:07,020
hour ago that's premier the primary use

00:07:05,229 --> 00:07:09,699
of external templates was to limit

00:07:07,020 --> 00:07:14,620
temporary generation and improve

00:07:09,699 --> 00:07:17,020
performance I lied that's a very very

00:07:14,620 --> 00:07:20,319
very very limited view of what we can

00:07:17,020 --> 00:07:24,699
use as a problem is it take us basically

00:07:20,319 --> 00:07:27,729
12 years to understand that okay so many

00:07:24,699 --> 00:07:29,800
issues uploading main objectives is find

00:07:27,729 --> 00:07:32,400
a way to implement something called

00:07:29,800 --> 00:07:35,500
domain-specific and the dead languages

00:07:32,400 --> 00:07:38,139
so first things first what is a

00:07:35,500 --> 00:07:40,960
domain-specific language or DSL it's

00:07:38,139 --> 00:07:43,120
usually a declarative language which may

00:07:40,960 --> 00:07:45,520
or may not be too incomplete that do

00:07:43,120 --> 00:07:49,180
only one phase it's very good at solving

00:07:45,520 --> 00:07:55,779
one single family of problem okay we'll

00:07:49,180 --> 00:07:57,669
use make sorry for you so make it is

00:07:55,779 --> 00:08:01,560
it's a dsl it's a small languages that

00:07:57,669 --> 00:08:04,449
lets you build bit system we use SQL

00:08:01,560 --> 00:08:07,060
yeah same thing you you access that

00:08:04,449 --> 00:08:10,120
basis schema with that but you probably

00:08:07,060 --> 00:08:13,620
can't write a bit system using up using

00:08:10,120 --> 00:08:17,789
SQL okay nobody contacted me move and

00:08:13,620 --> 00:08:20,979
we'll use matlab okay same same stuff

00:08:17,789 --> 00:08:23,349
dsl's for solving issues of numerical

00:08:20,979 --> 00:08:25,690
computation math lab is with more

00:08:23,349 --> 00:08:28,300
turing-complete than sqm a look at the

00:08:25,690 --> 00:08:30,639
same idea when you write with matlab you

00:08:28,300 --> 00:08:32,349
doesn't write your frigging triple loop

00:08:30,639 --> 00:08:34,570
whenever you want to make a matrix

00:08:32,349 --> 00:08:36,909
multiplication you just right I want the

00:08:34,570 --> 00:08:39,969
matrix multiplication and the system do

00:08:36,909 --> 00:08:43,479
it for you the proper way or awesome

00:08:39,969 --> 00:08:45,310
what matt webb says so it's all only one

00:08:43,479 --> 00:08:47,230
family of problem but it solve it the

00:08:45,310 --> 00:08:49,620
correct way because it only have one

00:08:47,230 --> 00:08:52,170
kind of problem to care about and

00:08:49,620 --> 00:08:54,520
usually those kind of languages are

00:08:52,170 --> 00:08:56,780
interpreted or

00:08:54,520 --> 00:09:01,220
compared into something else with an

00:08:56,780 --> 00:09:04,100
external tools so what our dses norman

00:09:01,220 --> 00:09:06,410
specific same stuff but invaded language

00:09:04,100 --> 00:09:08,170
so and bidding is a bit tricky doesn't

00:09:06,410 --> 00:09:12,110
make embedded like in embedded systems

00:09:08,170 --> 00:09:15,980
it's anything like in it's hidden it's

00:09:12,110 --> 00:09:19,840
basically a library that took on his

00:09:15,980 --> 00:09:22,220
head ok see the mentor of a language

00:09:19,840 --> 00:09:24,020
it's a library which is designed with

00:09:22,220 --> 00:09:26,480
the same basic principle of a

00:09:24,020 --> 00:09:29,630
domain-specific languages so instead of

00:09:26,480 --> 00:09:33,050
relying on providing an API based on

00:09:29,630 --> 00:09:35,480
object and functions that do stuff the

00:09:33,050 --> 00:09:38,660
basic design is driven by the fact that

00:09:35,480 --> 00:09:42,080
you want to build a library where the

00:09:38,660 --> 00:09:44,000
core element could be seen as a

00:09:42,080 --> 00:09:46,010
condiment or for special languages and

00:09:44,000 --> 00:09:48,770
the operators in the function your prey

00:09:46,010 --> 00:09:51,170
on them is made so that so call you

00:09:48,770 --> 00:09:53,960
right with it it looks like an external

00:09:51,170 --> 00:09:55,490
languages embedded into your C++ that's

00:09:53,960 --> 00:09:58,570
what's basically boo spirit does it

00:09:55,490 --> 00:10:03,290
looks like a Backes norm form inside C++

00:09:58,570 --> 00:10:05,510
accept it just a library and what we do

00:10:03,290 --> 00:10:07,150
is that we force our google holds the

00:10:05,510 --> 00:10:10,880
process compiler to be turned into

00:10:07,150 --> 00:10:13,550
luckily a compiler for this dsl that

00:10:10,880 --> 00:10:16,250
happens to generate c++ and then do

00:10:13,550 --> 00:10:18,410
whatever and expression 10 pranks are

00:10:16,250 --> 00:10:21,560
actually the only solution we are right

00:10:18,410 --> 00:10:24,860
now to write something close to dsl's

00:10:21,560 --> 00:10:27,500
inside see prosperous and that far more

00:10:24,860 --> 00:10:29,420
powerful than let's let's optimize a

00:10:27,500 --> 00:10:31,250
bunch of temporaries that means that we

00:10:29,420 --> 00:10:34,580
can actually take a bunch of expressions

00:10:31,250 --> 00:10:38,660
and take decisions about regeneration

00:10:34,580 --> 00:10:41,270
based on so your successions of

00:10:38,660 --> 00:10:43,370
operation into these expressions you can

00:10:41,270 --> 00:10:46,730
take it slice it we build it in

00:10:43,370 --> 00:10:48,650
different way before we do anything we

00:10:46,730 --> 00:10:51,320
will be able to pattern match inside it

00:10:48,650 --> 00:10:53,360
and so on and so on and that's the real

00:10:51,320 --> 00:10:56,300
usage of a different templates what I

00:10:53,360 --> 00:10:59,570
say during the break is that if I have

00:10:56,300 --> 00:11:02,240
five minutes which I don't I could

00:10:59,570 --> 00:11:03,950
actually write a small dsm expression

00:11:02,240 --> 00:11:06,740
template-based mattress libraries are

00:11:03,950 --> 00:11:09,080
preventable is to advance and I could

00:11:06,740 --> 00:11:11,480
probably write a similar code that far

00:11:09,080 --> 00:11:13,190
less complex using regular functions

00:11:11,480 --> 00:11:16,310
regular operators regular mattress types

00:11:13,190 --> 00:11:18,770
let's use move semantics aveo and clever

00:11:16,310 --> 00:11:20,180
users of all of this and I'm pretty much

00:11:18,770 --> 00:11:22,940
sure that the performance will be quite

00:11:20,180 --> 00:11:27,200
close that's an experiment that set up

00:11:22,940 --> 00:11:29,630
to do but that's my my gambit and sad so

00:11:27,200 --> 00:11:32,380
even if the performance is not the main

00:11:29,630 --> 00:11:35,750
focus why are we still doing this that's

00:11:32,380 --> 00:11:37,490
so we need it because we need to build

00:11:35,750 --> 00:11:39,020
arbitrary expression of laboratory

00:11:37,490 --> 00:11:40,880
language and turn it into something else

00:11:39,020 --> 00:11:43,550
and the best way to do this is to

00:11:40,880 --> 00:11:46,550
capture your iced tea and take decision

00:11:43,550 --> 00:11:48,620
about it except you don't really want to

00:11:46,550 --> 00:11:51,320
do that all day long by yourself and

00:11:48,620 --> 00:11:53,270
that where boost provo kicks in booth

00:11:51,320 --> 00:11:55,910
brother it's an expression temperature

00:11:53,270 --> 00:11:58,760
get it gives you all the freaking

00:11:55,910 --> 00:12:01,089
boilerplate to get all the operators all

00:11:58,760 --> 00:12:04,310
the functions decorating the tree

00:12:01,089 --> 00:12:06,320
knowing all you want to Travis three in

00:12:04,310 --> 00:12:09,500
one way or another and it's all ready to

00:12:06,320 --> 00:12:12,320
use don't have to write any other of the

00:12:09,500 --> 00:12:14,330
craft we said 24 you just generalize a

00:12:12,320 --> 00:12:16,820
way of implementing in an efficient

00:12:14,330 --> 00:12:20,030
template in giant and it's May so it's

00:12:16,820 --> 00:12:22,250
customizable and it's also compiler took

00:12:20,030 --> 00:12:24,560
it because contrary to what we've wrote

00:12:22,250 --> 00:12:29,360
very crudely in the first part of this

00:12:24,560 --> 00:12:32,630
talk we use concepts to fake faces into

00:12:29,360 --> 00:12:34,610
the systems we see that also we build an

00:12:32,630 --> 00:12:37,550
expression we can match it against

00:12:34,610 --> 00:12:38,930
something that validate so far as the

00:12:37,550 --> 00:12:42,560
expression is correct within our

00:12:38,930 --> 00:12:45,830
languages that's what's the rest of the

00:12:42,560 --> 00:12:49,670
world called a grammar okay and then we

00:12:45,830 --> 00:12:51,920
could actually do something when we go

00:12:49,670 --> 00:12:53,450
down our tree and find some kind of

00:12:51,920 --> 00:12:55,130
patterns at what we called semantic

00:12:53,450 --> 00:12:57,410
action in the rest of the world and

00:12:55,130 --> 00:13:00,020
that's terms that will come back into

00:12:57,410 --> 00:13:02,030
booze Prado and help us build those kind

00:13:00,020 --> 00:13:04,040
of let's visit grammar some chases

00:13:02,030 --> 00:13:05,750
expression and if it's correct I would

00:13:04,040 --> 00:13:08,360
select which kind of semantic actions I

00:13:05,750 --> 00:13:12,079
want to provide and apply on this and

00:13:08,360 --> 00:13:14,230
get the resulting code and if you build

00:13:12,079 --> 00:13:17,209
different library based on booze Prado

00:13:14,230 --> 00:13:19,279
the other way to say oh this is this

00:13:17,209 --> 00:13:22,100
library and this is a library I know

00:13:19,279 --> 00:13:23,899
to do when they get mixed they have to

00:13:22,100 --> 00:13:26,810
go into an expression of this author

00:13:23,899 --> 00:13:28,459
library and so on so we doubt we r be

00:13:26,810 --> 00:13:31,790
able to bear interoperability between

00:13:28,459 --> 00:13:33,350
DSS she's very important so because you

00:13:31,790 --> 00:13:35,360
really really want your let's say your

00:13:33,350 --> 00:13:37,639
your eigen reputation to be put down

00:13:35,360 --> 00:13:42,100
inside the Freddy's functions best to do

00:13:37,639 --> 00:13:46,970
spirit okay stuff rises so does it works

00:13:42,100 --> 00:13:48,829
well first that we need to do is as we

00:13:46,970 --> 00:13:52,519
said before we need to generate this

00:13:48,829 --> 00:13:54,559
damn tree from a bunch of code that's

00:13:52,519 --> 00:13:58,100
basically all you need to write that

00:13:54,559 --> 00:14:00,860
replace these 80-something lines of code

00:13:58,100 --> 00:14:06,110
i brought before you include this

00:14:00,860 --> 00:14:10,089
brother you make a terminal god and you

00:14:06,110 --> 00:14:12,439
instantly have all the operators and and

00:14:10,089 --> 00:14:16,399
all the operators you want on your

00:14:12,439 --> 00:14:19,129
terminal every one of them including the

00:14:16,399 --> 00:14:21,920
kruky comma operator including is a very

00:14:19,129 --> 00:14:23,990
strange function member access through a

00:14:21,920 --> 00:14:26,240
row operator whatever whatever whatever

00:14:23,990 --> 00:14:28,009
everything is already there i can write

00:14:26,240 --> 00:14:32,180
this code like this it doesn't make any

00:14:28,009 --> 00:14:34,600
sense okay if we compiled okay just as

00:14:32,180 --> 00:14:41,110
everything and everything is instantly

00:14:34,600 --> 00:14:44,120
turn into an 83 as soon as at least one

00:14:41,110 --> 00:14:48,100
terminal defined as a boost proto

00:14:44,120 --> 00:14:51,290
terminal is anywhere in the expression

00:14:48,100 --> 00:14:53,540
so you just need one proto thema node to

00:14:51,290 --> 00:14:57,879
contamination your expression and get a

00:14:53,540 --> 00:14:57,879
lazy version of it yes

00:15:04,970 --> 00:15:09,060
that's what's terminal is it has to be

00:15:07,170 --> 00:15:18,900
into a new position somewhere that's a

00:15:09,060 --> 00:15:21,330
terminal by definition oh oh yeah yeah

00:15:18,900 --> 00:15:23,760
so the question is oh is it really that

00:15:21,330 --> 00:15:25,860
much contaminating yeah but it's a

00:15:23,760 --> 00:15:28,110
regular the regular rules of language up

00:15:25,860 --> 00:15:31,490
and so the example was what if you write

00:15:28,110 --> 00:15:33,390
x plus power ends three plus five

00:15:31,490 --> 00:15:35,220
welcome Barry will probably come to

00:15:33,390 --> 00:15:36,660
three plus five and replace it by eight

00:15:35,220 --> 00:15:38,820
and you will end up with the tree which

00:15:36,660 --> 00:15:41,370
is X plus eight but you end up with the

00:15:38,820 --> 00:15:43,410
tree which is X plus something okay as a

00:15:41,370 --> 00:15:45,120
regular rules still apply yeah the same

00:15:43,410 --> 00:15:46,860
way you could not change the precedence

00:15:45,120 --> 00:15:50,670
of the operators because the language

00:15:46,860 --> 00:15:52,530
doesn't let you to do so okay so you can

00:15:50,670 --> 00:15:55,860
write this code and we obviously is very

00:15:52,530 --> 00:15:58,080
deadly of display export function that

00:15:55,860 --> 00:16:00,540
do what it's just written in the can it

00:15:58,080 --> 00:16:02,340
just displays of expression so if you

00:16:00,540 --> 00:16:06,660
confine that and run it you end up with

00:16:02,340 --> 00:16:10,250
something like this which is basically

00:16:06,660 --> 00:16:14,100
laid out view of the tree you just built

00:16:10,250 --> 00:16:16,590
and boost brother just print to the name

00:16:14,100 --> 00:16:19,440
of the function tag every time they find

00:16:16,590 --> 00:16:21,540
one and the terminal you get the value

00:16:19,440 --> 00:16:24,180
printed as soon as a type reporting to

00:16:21,540 --> 00:16:26,700
the terminal as a stream insertion

00:16:24,180 --> 00:16:29,220
operator okay if not just bring the type

00:16:26,700 --> 00:16:30,840
of the terminal so you just do this and

00:16:29,220 --> 00:16:32,730
you have basically eighty percent of

00:16:30,840 --> 00:16:36,000
what you need you can visit tree and

00:16:32,730 --> 00:16:41,250
inspect it this free expert is very

00:16:36,000 --> 00:16:43,560
interesting because you can actually

00:16:41,250 --> 00:16:45,630
play with your with your operators and

00:16:43,560 --> 00:16:47,910
see what makes sense in terms of your

00:16:45,630 --> 00:16:49,590
language design and when you are okay

00:16:47,910 --> 00:16:52,890
with what should you should be writing

00:16:49,590 --> 00:16:55,800
and matching you can actually do what so

00:16:52,890 --> 00:16:58,530
you have a terminal of int in the boost

00:16:55,800 --> 00:17:00,180
prada terminal every time everybody put

00:16:58,530 --> 00:17:06,270
it you just contaminate everything and

00:17:00,180 --> 00:17:07,680
you get a tree okay so okay nice but

00:17:06,270 --> 00:17:09,570
what if I really want to do something

00:17:07,680 --> 00:17:12,570
with this tree it wasn't like you know

00:17:09,570 --> 00:17:14,250
I'm not there to just display it so

00:17:12,570 --> 00:17:16,650
that's a bit more complex so I would

00:17:14,250 --> 00:17:17,340
switch to a real code because these font

00:17:16,650 --> 00:17:19,980
is really

00:17:17,340 --> 00:17:25,020
very very too small so which one is it

00:17:19,980 --> 00:17:27,240
of information so just just so you will

00:17:25,020 --> 00:17:32,070
see it there ok I can actually take it

00:17:27,240 --> 00:17:35,490
and put it there ok so that's like 10

00:17:32,070 --> 00:17:39,660
lines instead of 70 something not that

00:17:35,490 --> 00:17:42,060
that so a booth brother is currently

00:17:39,660 --> 00:17:45,720
something which run on on regular c++

00:17:42,060 --> 00:17:47,940
don't need ever know 14 just an easy guy

00:17:45,720 --> 00:17:50,820
so yeah you got that and you can do

00:17:47,940 --> 00:17:53,430
kruky thingy like this example I think

00:17:50,820 --> 00:17:56,790
that's this way you do it I never know

00:17:53,430 --> 00:18:01,890
how you should be writing that yeah that

00:17:56,790 --> 00:18:09,330
should be doing yeah I did something

00:18:01,890 --> 00:18:16,650
wrong come on oh no yeah okay oh yeah

00:18:09,330 --> 00:18:25,410
yeah of course yeah just died okay what

00:18:16,650 --> 00:18:27,780
about that that should be doing it yeah

00:18:25,410 --> 00:18:29,460
comecomecome a plasma displays multiply

00:18:27,780 --> 00:18:31,800
blah blah blah and so on and so on and

00:18:29,460 --> 00:18:35,130
what's the name of this funky a road

00:18:31,800 --> 00:18:37,800
star it's called the mem PT on okay

00:18:35,130 --> 00:18:39,870
that's that's what we want ok so you can

00:18:37,800 --> 00:18:43,290
just write that and just get captured on

00:18:39,870 --> 00:18:49,170
itself ok and I think you can also have

00:18:43,290 --> 00:18:50,790
stuff like this and that and so on and

00:18:49,170 --> 00:18:56,670
so on you basically have everything oh

00:18:50,790 --> 00:19:03,510
yeah introduces in the middle for

00:18:56,670 --> 00:19:05,310
combiner oh oh yeah of course yeah so

00:19:03,510 --> 00:19:07,140
rule number one with exertion template

00:19:05,310 --> 00:19:09,390
is text time to compile it's probably

00:19:07,140 --> 00:19:16,050
correct it returns directly you made an

00:19:09,390 --> 00:19:18,690
error and now the issue is that i'm not

00:19:16,050 --> 00:19:22,970
joking actually ok comma comma pressman

00:19:18,690 --> 00:19:26,910
is blah blah blah where are the new guys

00:19:22,970 --> 00:19:29,370
man PT are subscribed it's the brackets

00:19:26,910 --> 00:19:31,140
and function is this so we got

00:19:29,370 --> 00:19:34,800
everything ok

00:19:31,140 --> 00:19:36,120
and function is a bit strange I put a

00:19:34,800 --> 00:19:38,370
function of where that we switched off

00:19:36,120 --> 00:19:40,680
and obviously the node is a fun element

00:19:38,370 --> 00:19:42,600
node so first one being the one who

00:19:40,680 --> 00:19:47,220
calls a function of their attorney okay

00:19:42,600 --> 00:19:51,660
but you have everything okay and it just

00:19:47,220 --> 00:19:54,210
was so back to this so what I really

00:19:51,660 --> 00:19:57,150
want to do is I want to write piece of

00:19:54,210 --> 00:19:58,380
gold with some operators I don't want to

00:19:57,150 --> 00:20:01,800
write piece of code with whatever

00:19:58,380 --> 00:20:06,180
because I want to limit the scope of my

00:20:01,800 --> 00:20:08,550
language okay so the first thing we need

00:20:06,180 --> 00:20:12,000
to do is find a way to say i build an

00:20:08,550 --> 00:20:14,220
expression and what I want to know is is

00:20:12,000 --> 00:20:20,130
this expression correct with respect to

00:20:14,220 --> 00:20:22,440
my language design so you already worked

00:20:20,130 --> 00:20:26,340
with designing a language there from

00:20:22,440 --> 00:20:28,290
scratch yeah okay so what you need is

00:20:26,340 --> 00:20:31,290
what we call a grammar a brother we say

00:20:28,290 --> 00:20:33,570
this is what is authorized in my

00:20:31,290 --> 00:20:36,300
languages and if you don't do what I say

00:20:33,570 --> 00:20:38,670
your expression or your statement your

00:20:36,300 --> 00:20:41,340
program is invalid so what we need to

00:20:38,670 --> 00:20:44,070
add is a way to take a lavatory

00:20:41,340 --> 00:20:47,610
expression and check if it's much

00:20:44,070 --> 00:20:51,030
grammar okay and the way to do this is

00:20:47,610 --> 00:20:54,810
to use these funky operators look at

00:20:51,030 --> 00:20:58,940
flying Elvin and following so we make us

00:20:54,810 --> 00:21:03,290
we make a structure let's say my

00:20:58,940 --> 00:21:07,830
expressions my EBA what can it be it's

00:21:03,290 --> 00:21:10,830
either a terminal of underscore which

00:21:07,830 --> 00:21:16,140
means a terminal of whatever model types

00:21:10,830 --> 00:21:18,090
or its plus applied to two sub

00:21:16,140 --> 00:21:23,790
expressions very dating the same grammar

00:21:18,090 --> 00:21:26,490
or multiplies between tournaments of the

00:21:23,790 --> 00:21:30,120
validating the same grammar again okay

00:21:26,490 --> 00:21:32,550
if I wrote that using a more classical

00:21:30,120 --> 00:21:34,980
way I will probably have written

00:21:32,550 --> 00:21:40,780
something like this which is that my EPA

00:21:34,980 --> 00:21:46,660
is it's either a terminal okay

00:21:40,780 --> 00:21:49,960
or it's an EPA plus EPA or its EPA times

00:21:46,660 --> 00:21:52,390
EPA my BNF is a bit rusty but that

00:21:49,960 --> 00:21:54,630
should look like this if i'm not

00:21:52,390 --> 00:21:57,730
mistaken and taking some shortcuts and

00:21:54,630 --> 00:21:59,830
that's exactly what i just wrote okay

00:21:57,730 --> 00:22:02,200
except i have to explain it with

00:21:59,830 --> 00:22:04,540
whatever syntax the C++ language let me

00:22:02,200 --> 00:22:09,490
so the idea is to say we have this or

00:22:04,540 --> 00:22:12,520
make sure we also have an end okay let's

00:22:09,490 --> 00:22:16,120
say this is what I accept us as a valid

00:22:12,520 --> 00:22:18,160
language from from you okay and if you

00:22:16,120 --> 00:22:20,620
look at wades done you can actually

00:22:18,160 --> 00:22:24,460
refer to yourself inside so you can have

00:22:20,620 --> 00:22:26,970
this EPA is an epa of an epa okay i

00:22:24,460 --> 00:22:31,150
could have brought something like this

00:22:26,970 --> 00:22:33,400
which have meant i want an epa on the

00:22:31,150 --> 00:22:37,320
left and whatever on the right and so on

00:22:33,400 --> 00:22:40,570
and so on okay so we have a bunch of

00:22:37,320 --> 00:22:44,380
constrictor exists that address build a

00:22:40,570 --> 00:22:47,800
matching pattern of what is correct okay

00:22:44,380 --> 00:22:50,520
so that's a very crude example we get

00:22:47,800 --> 00:22:53,890
through a very more complex one little

00:22:50,520 --> 00:22:57,010
but yet it's it's actually bit more than

00:22:53,890 --> 00:22:59,860
that so obviously i use plus and

00:22:57,010 --> 00:23:01,420
multiply but you have everything else ok

00:22:59,860 --> 00:23:04,630
you are but you have a constructor for

00:23:01,420 --> 00:23:07,570
every operators you want you also have a

00:23:04,630 --> 00:23:10,240
generic match sure like binary xfer

00:23:07,570 --> 00:23:12,580
unary experts say whatever the tag

00:23:10,240 --> 00:23:16,750
whatever the operation if it's binary or

00:23:12,580 --> 00:23:18,610
it's okay okay and so on and so on so

00:23:16,750 --> 00:23:22,540
what do we do is this which is structure

00:23:18,610 --> 00:23:30,610
okay well we we make a terminal of NZ

00:23:22,540 --> 00:23:35,910
and I'm asking if does X plus X the type

00:23:30,610 --> 00:23:42,540
of X with X match the EPA grammar and

00:23:35,910 --> 00:23:45,580
does the type of x / not X match it ok

00:23:42,540 --> 00:23:47,230
so i just use data types there ok but

00:23:45,580 --> 00:23:48,700
could I put it into a function and

00:23:47,230 --> 00:23:51,190
taking the type of your expression in

00:23:48,700 --> 00:23:53,650
another way ok just fall for the fuzzy

00:23:51,190 --> 00:23:54,580
example and obviously the first match we

00:23:53,650 --> 00:23:57,909
return true

00:23:54,580 --> 00:24:02,890
cos x plus x is basically terminal plus

00:23:57,909 --> 00:24:05,950
terminal terminal match epa so a PA plus

00:24:02,890 --> 00:24:07,600
ppl is matched recursively okay and the

00:24:05,950 --> 00:24:09,250
other one is not because I don't have

00:24:07,600 --> 00:24:12,070
any device and I don't have any

00:24:09,250 --> 00:24:17,019
compliments into the grammar okay so if

00:24:12,070 --> 00:24:20,529
i take these things and i go there again

00:24:17,019 --> 00:24:26,919
I should have forced a true and false

00:24:20,529 --> 00:24:32,470
printing whenever you want Troy and

00:24:26,919 --> 00:24:39,460
forth and okay i can actually oh sorry I

00:24:32,470 --> 00:24:41,740
forgot about that yeah tap tap I should

00:24:39,460 --> 00:24:48,909
have made an item a deep side STD small

00:24:41,740 --> 00:24:57,220
screen just add tap tap everywhere yeah

00:24:48,909 --> 00:25:03,100
true false so what if I i do this I do

00:24:57,220 --> 00:25:07,029
that that it works should it and and

00:25:03,100 --> 00:25:10,049
with it yeah inclusively tree has to be

00:25:07,029 --> 00:25:12,789
converted somehow into a terminal of end

00:25:10,049 --> 00:25:14,289
that was floated us as soon as you have

00:25:12,789 --> 00:25:17,769
something which is contaminating

00:25:14,289 --> 00:25:21,130
everything else is buggered up into the

00:25:17,769 --> 00:25:23,169
proper proto expression that match it so

00:25:21,130 --> 00:25:25,539
tree is a literal okay so it's a

00:25:23,169 --> 00:25:27,820
terminal so it should match terminal of

00:25:25,539 --> 00:25:34,539
whatever rules that should be saying

00:25:27,820 --> 00:25:38,649
true let's see whatever anyway want okay

00:25:34,539 --> 00:25:42,210
true okay ah and I can actually add

00:25:38,649 --> 00:25:47,620
stuff there so let's put divide backs

00:25:42,210 --> 00:25:49,240
divides okay so i can write that such

00:25:47,620 --> 00:25:53,320
just as simple as that just are you

00:25:49,240 --> 00:25:57,250
rules and dot and exact it's not device

00:25:53,320 --> 00:25:59,799
wasn't even that so oh yeah sorry oh oh

00:25:57,250 --> 00:26:04,260
yeah yeah yeah I make to make full of my

00:25:59,799 --> 00:26:04,260
using I should have put them

00:26:06,830 --> 00:26:11,280
cause multiplies you can sometimes it

00:26:09,600 --> 00:26:13,050
doesn't know if it applies all times but

00:26:11,280 --> 00:26:16,050
devices device I don't know how you can

00:26:13,050 --> 00:26:18,150
call it actually and so now look at look

00:26:16,050 --> 00:26:22,860
at if I do this okay let's let's make

00:26:18,150 --> 00:26:27,630
something more complex all right now I

00:26:22,860 --> 00:26:31,470
have a terminal floats Steen walks

00:26:27,630 --> 00:26:34,380
because we don't put any constraint on

00:26:31,470 --> 00:26:36,660
the terminal okay and now let's let's

00:26:34,380 --> 00:26:38,370
what happens if I do this you can

00:26:36,660 --> 00:26:46,740
actually write that I want Daniel

00:26:38,370 --> 00:26:48,780
off-road and nothing else and the last

00:26:46,740 --> 00:26:52,710
one become photos treason in it's not a

00:26:48,780 --> 00:26:55,200
float ok let's go back there yeah this

00:26:52,710 --> 00:26:59,100
is a terminal thing let's let's see if

00:26:55,200 --> 00:27:06,240
it's true let's see if our intuition is

00:26:59,100 --> 00:27:08,630
right also is right let's see if it is

00:27:06,240 --> 00:27:08,630
comprised

00:27:13,880 --> 00:27:22,320
yeah complies wait what the heck I wrote

00:27:20,340 --> 00:27:25,860
I wrote a grammar saying I don't want

00:27:22,320 --> 00:27:28,920
that to come by if I match it it

00:27:25,860 --> 00:27:31,020
completes a it doesn't match it but when

00:27:28,920 --> 00:27:32,670
I printed it just printed like there is

00:27:31,020 --> 00:27:34,710
no tomorrow and doesn't care about the

00:27:32,670 --> 00:27:38,370
fact it's not a correct expression what

00:27:34,710 --> 00:27:42,750
the heck is going on well the fact is

00:27:38,370 --> 00:27:44,070
that prota matches is one kind of Travis

00:27:42,750 --> 00:27:46,650
all the trees that just happened to

00:27:44,070 --> 00:27:49,020
match it but when you build it and you

00:27:46,650 --> 00:27:52,350
pass it to this way expert you just

00:27:49,020 --> 00:27:59,690
display whatever you give it okay it

00:27:52,350 --> 00:28:07,110
doesn't magically do anything more okay

00:27:59,690 --> 00:28:08,850
so beware so what we will be needing is

00:28:07,110 --> 00:28:11,640
we will see that later is which say

00:28:08,850 --> 00:28:13,980
actually I just don't want to match it I

00:28:11,640 --> 00:28:16,020
just really want you to prevent the

00:28:13,980 --> 00:28:18,210
construction of these three if it

00:28:16,020 --> 00:28:21,270
doesn't match anything okay it goes out

00:28:18,210 --> 00:28:23,870
to be there but yeah we can actually

00:28:21,270 --> 00:28:26,010
take a tree and do whatever we want and

00:28:23,870 --> 00:28:27,930
matching the three against the grammar

00:28:26,010 --> 00:28:29,880
is basically a recursive descent of the

00:28:27,930 --> 00:28:31,140
tree and match with the recursive

00:28:29,880 --> 00:28:32,910
definition of the grammar until

00:28:31,140 --> 00:28:35,880
something blue apps it just a tree

00:28:32,910 --> 00:28:38,010
traversal same for display just three

00:28:35,880 --> 00:28:40,290
traversal and three traversal doesn't

00:28:38,010 --> 00:28:43,380
care about the fact your expression is

00:28:40,290 --> 00:28:49,140
valid for a given grammar to just travel

00:28:43,380 --> 00:28:52,080
the damn tree okay first rules okay so i

00:28:49,140 --> 00:28:55,020
can actually say okay is it correct that

00:28:52,080 --> 00:29:01,230
CeCe's in the shape of a grammar I think

00:28:55,020 --> 00:29:03,240
it is so what we do we do next so next

00:29:01,230 --> 00:29:06,960
we may want to do something with the

00:29:03,240 --> 00:29:11,550
tree like evaluating it okay so we have

00:29:06,960 --> 00:29:13,740
a very very similar way of describing a

00:29:11,550 --> 00:29:17,580
trend earn a transformation of three

00:29:13,740 --> 00:29:20,280
it's called transform so what what do

00:29:17,580 --> 00:29:24,090
you want to do whenever you find the

00:29:20,280 --> 00:29:26,909
terminal you want to value and whatever

00:29:24,090 --> 00:29:29,909
operation get you actually want

00:29:26,909 --> 00:29:31,919
natural semantics of the sea professor

00:29:29,909 --> 00:29:34,409
murder on it if I do press I want to

00:29:31,919 --> 00:29:36,330
glue the price between my values and if

00:29:34,409 --> 00:29:38,429
I do times I want the ties between my

00:29:36,330 --> 00:29:41,460
values and so on and so on and so on and

00:29:38,429 --> 00:29:49,349
that's exactly what we wrote there it's

00:29:41,460 --> 00:29:52,259
a balut in a more decent font so it uses

00:29:49,349 --> 00:29:54,599
exact same system that for the grammar

00:29:52,259 --> 00:29:56,519
for a simple reason that a grammar is

00:29:54,599 --> 00:29:58,789
also transforms that happens to say yes

00:29:56,519 --> 00:30:01,229
or no is valid it's the same thing but

00:29:58,789 --> 00:30:04,349
what we will be doing is we will

00:30:01,229 --> 00:30:10,679
associate with each tear each pattern of

00:30:04,349 --> 00:30:14,460
sub expression an action so when I match

00:30:10,679 --> 00:30:16,289
terminal of something please give me the

00:30:14,460 --> 00:30:18,690
value of the terminal that was this

00:30:16,289 --> 00:30:21,119
endoscope value means him is value

00:30:18,690 --> 00:30:24,960
inside the terminal whenever you find

00:30:21,119 --> 00:30:29,009
one and that's one of the shortcut that

00:30:24,960 --> 00:30:33,799
actually is built by proto is otherwise

00:30:29,009 --> 00:30:38,309
for everything else just cause default

00:30:33,799 --> 00:30:41,909
behavior but before calling the default

00:30:38,309 --> 00:30:45,629
behavior please call myself on whatever

00:30:41,909 --> 00:30:48,179
sub expression you found so that once

00:30:45,629 --> 00:30:50,309
this default evening's evaluate every

00:30:48,179 --> 00:30:54,029
sub expression with evolved and then

00:30:50,309 --> 00:30:57,090
apply the logical basic semantics of the

00:30:54,029 --> 00:31:01,289
operator you found plus 2 plus x 2 x and

00:30:57,090 --> 00:31:03,869
so on and so on so two lines there is

00:31:01,289 --> 00:31:05,999
basically all those operator function

00:31:03,869 --> 00:31:10,499
code we wrote in to all our expressions

00:31:05,999 --> 00:31:13,289
in the pub before just say that and so

00:31:10,499 --> 00:31:15,269
what does it bring us okay see

00:31:13,289 --> 00:31:18,269
instructor but what I really want to

00:31:15,269 --> 00:31:21,289
function well actually you good Bob evil

00:31:18,269 --> 00:31:24,659
is basically a callable function object

00:31:21,289 --> 00:31:27,599
so just make an instance of a van and

00:31:24,659 --> 00:31:30,359
you call it on an expression just like

00:31:27,599 --> 00:31:33,809
this okay make the e you call it on your

00:31:30,359 --> 00:31:35,580
expression and this will recursively

00:31:33,809 --> 00:31:39,720
applies a pattern-matching and do

00:31:35,580 --> 00:31:40,750
whatever you asking him to do okay what

00:31:39,720 --> 00:31:48,760
do you think will happen

00:31:40,750 --> 00:31:51,220
if our if I add two different rules 14

00:31:48,760 --> 00:31:53,200
terminal of anything and one for stamina

00:31:51,220 --> 00:31:57,180
of fruit for example that for whatever

00:31:53,200 --> 00:31:57,180
reason returns ten times of value okay

00:31:57,360 --> 00:32:03,010
one trick is that the orders of the

00:32:00,490 --> 00:32:04,660
rules in size or is important they

00:32:03,010 --> 00:32:06,160
basically our match from the top to the

00:32:04,660 --> 00:32:09,040
bottom so you have to be careful with

00:32:06,160 --> 00:32:11,290
that okay so you probably want the most

00:32:09,040 --> 00:32:14,350
specialized one under on the top and

00:32:11,290 --> 00:32:16,390
going down the street exist so this

00:32:14,350 --> 00:32:18,940
build forest cease your recursive

00:32:16,390 --> 00:32:21,310
function code systems that will apply

00:32:18,940 --> 00:32:24,280
whatever transform you want on yew tree

00:32:21,310 --> 00:32:26,650
and again doesn't care about the fact

00:32:24,280 --> 00:32:30,580
that you tree may be wrong just takes a

00:32:26,650 --> 00:32:34,210
three right whatever be careful without

00:32:30,580 --> 00:32:36,070
you so usually what you do is armed and

00:32:34,210 --> 00:32:38,020
so you get an expression that come from

00:32:36,070 --> 00:32:40,660
you don't know where and you try to see

00:32:38,020 --> 00:32:43,000
with the static acid if it matches what

00:32:40,660 --> 00:32:45,430
you think it should be and if it matches

00:32:43,000 --> 00:32:49,180
then you apply to transform okay that's

00:32:45,430 --> 00:32:52,750
one simple way to do so the magic behind

00:32:49,180 --> 00:32:55,180
or and when is basically just you know

00:32:52,750 --> 00:32:59,530
any reads from every elements providing

00:32:55,180 --> 00:33:02,020
a jersey as a function carburettors that

00:32:59,530 --> 00:33:04,060
do the operation or doing the types

00:33:02,020 --> 00:33:06,790
checking for the grammar and so on and

00:33:04,060 --> 00:33:09,100
tall but the interesting point is that a

00:33:06,790 --> 00:33:13,360
grammar and the transform is basically

00:33:09,100 --> 00:33:18,480
the same a transforming a grammar where

00:33:13,360 --> 00:33:20,950
you basically add on each rose as

00:33:18,480 --> 00:33:22,990
semantic actions whenever I match this

00:33:20,950 --> 00:33:25,810
this is what I want to do in a very

00:33:22,990 --> 00:33:27,790
straightforward way and I could actually

00:33:25,810 --> 00:33:30,220
write the second evaluation scheme

00:33:27,790 --> 00:33:32,140
matching different stuff and passing

00:33:30,220 --> 00:33:33,730
them on to the same tree that's

00:33:32,140 --> 00:33:36,040
basically what we wanted with the simple

00:33:33,730 --> 00:33:38,680
systems I have a tree that is built by

00:33:36,040 --> 00:33:40,930
Prado and I have a bunch of function

00:33:38,680 --> 00:33:45,850
objects that we present arbitrary

00:33:40,930 --> 00:33:48,520
operation on arbitrary trees and I can

00:33:45,850 --> 00:33:50,260
take whichever I want into Z transforms

00:33:48,520 --> 00:33:53,290
and the right to whichever three are one

00:33:50,260 --> 00:33:54,520
it's completely correlated ok just

00:33:53,290 --> 00:33:56,380
immediately kind of a grammar

00:33:54,520 --> 00:33:58,150
that match something a single one gets

00:33:56,380 --> 00:33:59,920
matched something else at the bunch of

00:33:58,150 --> 00:34:02,320
transforms and you can call them all

00:33:59,920 --> 00:34:05,650
together on the same tree one not a

00:34:02,320 --> 00:34:09,130
problem ok so let's see if these things

00:34:05,650 --> 00:34:11,590
worse those two sides how is doing

00:34:09,130 --> 00:34:18,310
nothing but probably do something anyway

00:34:11,590 --> 00:34:20,790
oh don't forget to tap tap it's probably

00:34:18,310 --> 00:34:28,500
doing like I don't know which is that

00:34:20,790 --> 00:34:28,500
for 699 ok and actually I could do this

00:34:30,419 --> 00:34:37,090
well we'll be putting floats because if

00:34:33,280 --> 00:34:41,740
not doesn't make any sense so it's

00:34:37,090 --> 00:34:44,909
probably some amount yeah probably ok I

00:34:41,740 --> 00:34:51,880
don't have to write anything else I know

00:34:44,909 --> 00:34:54,460
so yeah we can do this ok oh yeah yeah

00:34:51,880 --> 00:35:00,910
and and as I said every operation is

00:34:54,460 --> 00:35:09,490
there right ok any operation so let's

00:35:00,910 --> 00:35:12,760
say we are that ok and let's make a

00:35:09,490 --> 00:35:16,060
terminal of STD array of I don't know

00:35:12,760 --> 00:35:18,910
three floats something like this ok it

00:35:16,060 --> 00:35:22,360
comes a funny parts let's play a game of

00:35:18,910 --> 00:35:29,440
all many braces so I think that such

00:35:22,360 --> 00:35:32,950
enough I 5890 ok I don't really want to

00:35:29,440 --> 00:35:41,140
be narrowing anything so so that should

00:35:32,950 --> 00:35:43,600
be that should be it what so what yeah I

00:35:41,140 --> 00:35:45,700
mean aim at why I just saw it and so

00:35:43,600 --> 00:35:50,590
that means that i could probably do this

00:35:45,700 --> 00:35:55,140
because every operators as the default c

00:35:50,590 --> 00:35:55,140
plus for semantic so i guess this was

00:35:56,990 --> 00:36:05,270
I we end up with bracket 0 providers a

00:36:01,460 --> 00:36:06,740
tree with subscribe between y & 0 and I

00:36:05,270 --> 00:36:08,570
asked him to be a barricade with a

00:36:06,740 --> 00:36:10,790
classical semantics which we've already

00:36:08,570 --> 00:36:13,160
cooked what we call bracket on the other

00:36:10,790 --> 00:36:16,280
line array and giving me I don't know

00:36:13,160 --> 00:36:18,530
mini five and I needed to to something

00:36:16,280 --> 00:36:21,830
that says should be walking okay so

00:36:18,530 --> 00:36:26,170
that's live demo bear with me okay i

00:36:21,830 --> 00:36:34,310
clicked thank you that should be walking

00:36:26,170 --> 00:36:40,490
seven and and just so we will sure what

00:36:34,310 --> 00:36:42,890
we are speaking about of course what

00:36:40,490 --> 00:36:47,750
what is there but what was the type of

00:36:42,890 --> 00:36:49,910
that we know it's for obviously an

00:36:47,750 --> 00:36:52,460
expression cannot be anything yet if not

00:36:49,910 --> 00:36:57,350
even without blow up already but just to

00:36:52,460 --> 00:37:00,350
be sure and so I can win five minutes of

00:36:57,350 --> 00:37:03,140
computation time so yeah and look okay i

00:37:00,350 --> 00:37:06,619
will probably be make some kind of

00:37:03,140 --> 00:37:10,040
effort because that's important do you

00:37:06,619 --> 00:37:12,170
see this everybody yeah okay so it's

00:37:10,040 --> 00:37:16,070
plus between the terminals that contains

00:37:12,170 --> 00:37:21,550
two and the subscribed operator between

00:37:16,070 --> 00:37:25,070
0 and this wonderful terminal of st5

00:37:21,550 --> 00:37:26,990
raif and mmm te e which is basically is

00:37:25,070 --> 00:37:34,150
a mangled name of STD array of three

00:37:26,990 --> 00:37:38,510
floats okay ah yeah so so i did not

00:37:34,150 --> 00:37:42,350
evaluate why of bracket 0 it be the tree

00:37:38,510 --> 00:37:45,220
that say i would do a letter okay sounds

00:37:42,350 --> 00:37:50,030
very important everything is lazy

00:37:45,220 --> 00:37:52,359
everything from top to bottom yes a

00:37:50,030 --> 00:37:52,359
question

00:38:14,480 --> 00:38:19,980
yeah it would probably cause the basic

00:38:17,970 --> 00:38:21,660
operator to come on your classes and if

00:38:19,980 --> 00:38:24,450
it doesn't argue just call to come out

00:38:21,660 --> 00:38:26,520
very top of the language and if you're

00:38:24,450 --> 00:38:28,410
cool classes are also k sorry the

00:38:26,520 --> 00:38:31,500
question was what if I make the terminal

00:38:28,410 --> 00:38:34,470
of my crew glass okay what happens that

00:38:31,500 --> 00:38:37,670
if he or Michael class class as over 80

00:38:34,470 --> 00:38:41,070
plus x whatever if you just call it done

00:38:37,670 --> 00:38:43,290
okay so let's see what let's see what

00:38:41,070 --> 00:38:45,240
happen if i do y plus y for example

00:38:43,290 --> 00:38:48,210
because we obviously doesn't have a

00:38:45,240 --> 00:38:51,000
presser arrow on Acra and then we don't

00:38:48,210 --> 00:38:53,400
tell you i just have to lose so i think

00:38:51,000 --> 00:38:57,150
that would probably blow up if not i

00:38:53,400 --> 00:39:07,680
will be disappointed so this probably

00:38:57,150 --> 00:39:09,390
should not walk I oh yeah okay so when

00:39:07,680 --> 00:39:13,860
it bro ops ii blow ups such as cool

00:39:09,390 --> 00:39:17,070
things okay so yeah oh no I was I was I

00:39:13,860 --> 00:39:19,650
was me no match for appeared to plus

00:39:17,070 --> 00:39:23,340
between STD array of something and is

00:39:19,650 --> 00:39:25,800
Thierry also so defaults the default are

00:39:23,340 --> 00:39:27,270
transformed just say do whatever you

00:39:25,800 --> 00:39:30,270
should be doing with your burritos I

00:39:27,270 --> 00:39:32,370
don't care okay but that's that's a

00:39:30,270 --> 00:39:34,230
shortcut okay we will go over and see

00:39:32,370 --> 00:39:36,390
that actually you can do far more but

00:39:34,230 --> 00:39:38,310
does it leave nothing more to that you

00:39:36,390 --> 00:39:51,000
just okay due to whatever you need to do

00:39:38,310 --> 00:39:53,310
okay there was another question oh so

00:39:51,000 --> 00:39:58,530
the question is in the terminal

00:39:53,310 --> 00:40:01,800
definition like line 19 you should i

00:39:58,530 --> 00:40:03,510
could i use the underscore stuff and so

00:40:01,800 --> 00:40:05,970
I can shove whatever I want inside no

00:40:03,510 --> 00:40:07,589
you have to have a concrete types what's

00:40:05,970 --> 00:40:09,960
a good wake up can be boost

00:40:07,589 --> 00:40:12,900
one that's not an issue but now you

00:40:09,960 --> 00:40:14,700
cannot just wave anyways whatever but

00:40:12,900 --> 00:40:17,219
but look at the things that you have

00:40:14,700 --> 00:40:19,890
this terminal or float thing from which

00:40:17,219 --> 00:40:25,229
we extract these controlling type nine

00:40:19,890 --> 00:40:28,440
nineteen ninety and obviously also watch

00:40:25,229 --> 00:40:31,499
dr. and if you see that the same type

00:40:28,440 --> 00:40:33,210
son's ear okay that's the same type

00:40:31,499 --> 00:40:36,660
cannot be anything else I just did one

00:40:33,210 --> 00:40:40,109
using boost terminal but that means what

00:40:36,660 --> 00:40:43,710
it means that at a meter of something or

00:40:40,109 --> 00:40:47,460
a plus of something something it's three

00:40:43,710 --> 00:40:52,109
things it's it's a match pattern in the

00:40:47,460 --> 00:40:55,079
grammar is the object representing the

00:40:52,109 --> 00:40:58,380
expression as soon as I did current

00:40:55,079 --> 00:41:02,969
current IB I did and it's all those its

00:40:58,380 --> 00:41:05,849
own default transform plus of something

00:41:02,969 --> 00:41:08,729
something put on the other side of a

00:41:05,849 --> 00:41:11,039
when just to a plus on whatever it found

00:41:08,729 --> 00:41:14,009
so it's three things so transform the

00:41:11,039 --> 00:41:16,369
grammar the expression types okay and

00:41:14,009 --> 00:41:18,779
everything is starting to a single rock

00:41:16,369 --> 00:41:20,400
that and that's the kruky things with

00:41:18,779 --> 00:41:21,839
booze Prado because sometimes you look

00:41:20,400 --> 00:41:23,670
at the code and you are like what is an

00:41:21,839 --> 00:41:24,989
egg is going on I just write three times

00:41:23,670 --> 00:41:27,210
the same things with three-time

00:41:24,989 --> 00:41:29,759
different meanings that's so one thing

00:41:27,210 --> 00:41:32,640
you have to go over because if you think

00:41:29,759 --> 00:41:35,249
about it is it's right it's normal so

00:41:32,640 --> 00:41:37,680
trillion ition is a way to represent the

00:41:35,249 --> 00:41:39,359
grammar I should match and it contains

00:41:37,680 --> 00:41:41,400
your operation you should be doing when

00:41:39,359 --> 00:41:43,200
you Travis it so I mean as a threesome

00:41:41,400 --> 00:41:48,719
antics into the same block different

00:41:43,200 --> 00:41:53,099
places makes some sense keyword is so so

00:41:48,719 --> 00:41:54,329
what we should be doing next well I want

00:41:53,099 --> 00:41:55,890
really want to do something else and

00:41:54,329 --> 00:41:57,719
just calling the blue me over 80 from

00:41:55,890 --> 00:42:01,619
the language so you can actually write a

00:41:57,719 --> 00:42:04,920
custom transform ok so we are just

00:42:01,619 --> 00:42:08,819
pushing everything to 11 now so let's

00:42:04,920 --> 00:42:12,509
have a look at this one so same things

00:42:08,819 --> 00:42:17,130
as beginning okay except I just change a

00:42:12,509 --> 00:42:19,979
bit what ever is doing and I say that

00:42:17,130 --> 00:42:21,420
when I match a terminal off whatever I

00:42:19,979 --> 00:42:25,380
want to value

00:42:21,420 --> 00:42:27,299
like before at the end if I didn't match

00:42:25,380 --> 00:42:30,000
anything else just do whatever is an

00:42:27,299 --> 00:42:32,790
angle should be doing no problem and you

00:42:30,000 --> 00:42:36,740
got this monster in the middle which

00:42:32,790 --> 00:42:40,890
says when I match plus between two

00:42:36,740 --> 00:42:44,190
something okay what I want you to do is

00:42:40,890 --> 00:42:52,170
doing this okay probably need to go back

00:42:44,190 --> 00:42:54,690
there and what the heck is this thing it

00:42:52,170 --> 00:42:57,150
actually reads like it should be doing I

00:42:54,690 --> 00:43:01,440
want you to call the custom function on

00:42:57,150 --> 00:43:07,170
the evolution of the left child enter a

00:43:01,440 --> 00:43:08,700
variation of the right child and we okay

00:43:07,170 --> 00:43:10,980
what does it look like it looks like a

00:43:08,700 --> 00:43:15,089
function call right it's with round

00:43:10,980 --> 00:43:17,369
stuff except cannot be a function call

00:43:15,089 --> 00:43:19,349
there okay so buddy is basically a

00:43:17,369 --> 00:43:23,280
function types who lower function types

00:43:19,349 --> 00:43:25,980
so we use that to you know mimics the

00:43:23,280 --> 00:43:29,160
fact that we want to call a function I

00:43:25,980 --> 00:43:31,319
think I don't remember if it's we call

00:43:29,160 --> 00:43:33,990
that round lambda you remember i have to

00:43:31,319 --> 00:43:36,990
to the example so i want to call the

00:43:33,990 --> 00:43:40,500
custom function of Z a variation of my

00:43:36,990 --> 00:43:45,000
two sub expression okay so left and

00:43:40,500 --> 00:43:47,579
right are actually chop cuts to the left

00:43:45,000 --> 00:43:49,880
child the right child it's the same kind

00:43:47,579 --> 00:43:53,849
of shorter than value of seminars and

00:43:49,880 --> 00:43:55,710
you also have a charge 0 1 2 3 4 5 if

00:43:53,849 --> 00:43:58,680
you want to get to the end child

00:43:55,710 --> 00:44:00,599
directly okay so others it works boost

00:43:58,680 --> 00:44:04,250
proto is trying to recognize this kind

00:44:00,599 --> 00:44:07,290
of types function types inside

00:44:04,250 --> 00:44:09,119
deconstruct it and check what's going on

00:44:07,290 --> 00:44:12,180
and that's where are the things get

00:44:09,119 --> 00:44:13,619
interesting it would take the written

00:44:12,180 --> 00:44:17,400
types of the function time which is

00:44:13,619 --> 00:44:21,049
custom there okay and it will look at it

00:44:17,400 --> 00:44:24,359
and say is it a colorable object or not

00:44:21,049 --> 00:44:26,490
if it's not what I we do is take this

00:44:24,359 --> 00:44:28,020
type and call this constructor on it and

00:44:26,490 --> 00:44:31,230
I will just be the new type a new value

00:44:28,020 --> 00:44:33,660
sir but if the type is credible I will

00:44:31,230 --> 00:44:35,820
just call its functional Mariners with

00:44:33,660 --> 00:44:38,670
whatever is the evaluation of

00:44:35,820 --> 00:44:42,240
what's inside so that's a massive

00:44:38,670 --> 00:44:44,550
shortcut to say I want you to be the

00:44:42,240 --> 00:44:47,220
function object i just happen to X

00:44:44,550 --> 00:44:49,650
wanted two children from the my +

00:44:47,220 --> 00:44:54,090
expression a very examines and feed it

00:44:49,650 --> 00:44:58,290
to the custom function just a shortcut

00:44:54,090 --> 00:44:59,940
for saying this so if Eric was there

00:44:58,290 --> 00:45:02,700
probably tell you that if anything is

00:44:59,940 --> 00:45:05,130
that booth photo is actually a dsl for

00:45:02,700 --> 00:45:07,380
building dsl's don't like the kind of

00:45:05,130 --> 00:45:10,890
you know syntactic sugar you want to put

00:45:07,380 --> 00:45:14,490
into a dsl so it looks cool okay or I'll

00:45:10,890 --> 00:45:16,080
give EDX depends so let's call customs

00:45:14,490 --> 00:45:21,320
on the evaluation of my two sub

00:45:16,080 --> 00:45:26,040
expression and always custom define well

00:45:21,320 --> 00:45:30,810
I've look there so custom is a function

00:45:26,040 --> 00:45:33,630
object so it's pretty surprised force 11

00:45:30,810 --> 00:45:38,610
okay so beer with the good old result of

00:45:33,630 --> 00:45:40,950
kind of time deductions okay ah we have

00:45:38,610 --> 00:45:43,310
to flag it as callable by Prado that's

00:45:40,950 --> 00:45:46,170
was the inheritance dozen in 14 and

00:45:43,310 --> 00:45:48,090
that's double you could have

00:45:46,170 --> 00:45:50,070
returned something more complex okay and

00:45:48,090 --> 00:45:52,850
you have these 40 more feet operators

00:45:50,070 --> 00:45:55,770
function calls that secretary you and

00:45:52,850 --> 00:45:58,530
returns something which is T plus two

00:45:55,770 --> 00:46:00,090
times one in red because our three what

00:45:58,530 --> 00:46:02,880
you want to do with your language when

00:46:00,090 --> 00:46:06,000
you do plus it really really mean d + u

00:46:02,880 --> 00:46:08,760
times android okay whatever and whenever

00:46:06,000 --> 00:46:13,340
I mash a plus i will call that now and

00:46:08,760 --> 00:46:16,980
what will be TN you TN you will be well

00:46:13,340 --> 00:46:19,710
it will be whatever this part of the

00:46:16,980 --> 00:46:22,080
definition of the transform is the

00:46:19,710 --> 00:46:23,640
evaluation of the left side 40 and they

00:46:22,080 --> 00:46:28,830
were action of the right side for you

00:46:23,640 --> 00:46:31,650
and I could actually you know change all

00:46:28,830 --> 00:46:35,310
of this as much as I own I could have

00:46:31,650 --> 00:46:37,950
another custom operator for a functional

00:46:35,310 --> 00:46:39,390
object that we put on top of custom and

00:46:37,950 --> 00:46:41,840
so on and so on and so on you can act

00:46:39,390 --> 00:46:44,790
with arbitrary large and complex

00:46:41,840 --> 00:46:48,750
seemingly function call into this when

00:46:44,790 --> 00:46:54,090
construct and proto just reconstruct it

00:46:48,750 --> 00:46:57,720
upto zr2 the beginning so let's see how

00:46:54,090 --> 00:47:07,320
much is X plus 3 plus x times 3 and does

00:46:57,720 --> 00:47:13,290
this rose so it looks kruky it's

00:47:07,320 --> 00:47:20,870
probably his okay ah but it gets the job

00:47:13,290 --> 00:47:26,880
done yeah probably 550,000 600 something

00:47:20,870 --> 00:47:32,100
so 2 times 3 63 plus two is five so 5

00:47:26,880 --> 00:47:34,500
plus 6 is whatever we saw upstairs Oh X

00:47:32,100 --> 00:47:38,670
plus 3 is not that it's probably two

00:47:34,500 --> 00:47:44,850
plus three x 102 lat 600 and 600 plus

00:47:38,670 --> 00:47:47,550
something and so on so but well we did

00:47:44,850 --> 00:47:51,200
that we did this a variation of the sub

00:47:47,550 --> 00:47:55,170
expression before passing them to our

00:47:51,200 --> 00:47:57,960
custom but you are not obliged what

00:47:55,170 --> 00:48:00,750
happened if i remove the evil before

00:47:57,960 --> 00:48:03,840
left and right i would just pass the sub

00:48:00,750 --> 00:48:06,170
expression to another function because

00:48:03,840 --> 00:48:08,570
what i want to do is problem is maybe

00:48:06,170 --> 00:48:10,710
taking those two sub expression and

00:48:08,570 --> 00:48:12,360
generate the nozzle tree where they are

00:48:10,710 --> 00:48:14,670
put somewhere else so we can actually

00:48:12,360 --> 00:48:16,950
write transform is pro pro that say I'm

00:48:14,670 --> 00:48:19,290
taking the arbitrary parts of you and

00:48:16,950 --> 00:48:22,080
putting it into another place another

00:48:19,290 --> 00:48:26,280
shape and I just send you back another

00:48:22,080 --> 00:48:27,870
tree because that's what you need you so

00:48:26,280 --> 00:48:29,970
we can use this to arbitrary the

00:48:27,870 --> 00:48:32,700
constructor tree and we built it in

00:48:29,970 --> 00:48:37,050
another way before passing into another

00:48:32,700 --> 00:48:38,220
custom transform point them okay so you

00:48:37,050 --> 00:48:40,020
can do whatever you want you're not

00:48:38,220 --> 00:48:42,510
you're not forced to get the evaluation

00:48:40,020 --> 00:48:44,820
of whatever can just take the parts to

00:48:42,510 --> 00:48:48,680
construct them we shave them in another

00:48:44,820 --> 00:48:52,020
way and so on and so on you have another

00:48:48,680 --> 00:48:53,900
versions of every of those plus minus

00:48:52,020 --> 00:48:56,310
and so on which leaving the nozzle

00:48:53,900 --> 00:48:58,370
namespace which is proto functional and

00:48:56,310 --> 00:49:01,329
you can use this if you want to say oh

00:48:58,370 --> 00:49:03,489
whenever you match a plus B

00:49:01,329 --> 00:49:06,269
you want you to generate the 3a minus B

00:49:03,489 --> 00:49:08,890
and you just say when when plus a be

00:49:06,269 --> 00:49:10,900
returned functional plus a function of

00:49:08,890 --> 00:49:13,299
my newest a be you can just am so

00:49:10,900 --> 00:49:16,650
shortcut to say I'm just putting up you

00:49:13,299 --> 00:49:19,239
know the the sub three against one Jones

00:49:16,650 --> 00:49:21,130
okay so we can match the grammar we can

00:49:19,239 --> 00:49:23,559
do transform of this we have a pretty

00:49:21,130 --> 00:49:27,219
much set of default we can write our own

00:49:23,559 --> 00:49:29,469
function to transforming whatever but

00:49:27,219 --> 00:49:33,339
the problem is what we endorsed here are

00:49:29,469 --> 00:49:35,170
still what we call negatory the tree the

00:49:33,339 --> 00:49:37,630
expression to you manipulate there is as

00:49:35,170 --> 00:49:39,609
no frigging semantics it's just a tree

00:49:37,630 --> 00:49:41,200
that happens to have audio burrito you

00:49:39,609 --> 00:49:44,109
want and you can turn it into whatever

00:49:41,200 --> 00:49:46,479
you want but for example if you wanted

00:49:44,109 --> 00:49:49,059
to build one of those metrics based here

00:49:46,479 --> 00:49:51,249
so where is my operative parents to get

00:49:49,059 --> 00:49:54,640
to the IJ element of my matrixes or

00:49:51,249 --> 00:49:57,910
where is my dot size where is the actual

00:49:54,640 --> 00:50:03,489
semantics of the object I represent they

00:49:57,910 --> 00:50:05,019
are not there so we have to add it so if

00:50:03,489 --> 00:50:06,549
you don't do anything else what you have

00:50:05,019 --> 00:50:08,559
is a very nice terms that build

00:50:06,549 --> 00:50:10,359
arbitrary lazy tree and let you

00:50:08,559 --> 00:50:12,099
manipulate the way you want but you

00:50:10,359 --> 00:50:15,430
don't have any point where to put the

00:50:12,099 --> 00:50:17,769
semantics in well except you up but not

00:50:15,430 --> 00:50:21,670
yet so others it works when you want to

00:50:17,769 --> 00:50:23,650
add semantic onza so we work basically

00:50:21,670 --> 00:50:28,209
up to 11 I think we will be basically

00:50:23,650 --> 00:50:31,150
apt to go to 12 okay so there is another

00:50:28,209 --> 00:50:33,459
more complete example so I bring back

00:50:31,150 --> 00:50:36,519
the evil stuff that it just evaluate the

00:50:33,459 --> 00:50:39,509
expression the regular way I bring back

00:50:36,519 --> 00:50:44,469
all those maps the grammar that match if

00:50:39,509 --> 00:50:46,239
your type is correct the concepts that

00:50:44,469 --> 00:50:49,119
product puts forward is to say the

00:50:46,239 --> 00:50:51,759
following one we need a way to say i

00:50:49,119 --> 00:50:55,809
have a naked tree that is been using

00:50:51,759 --> 00:50:58,599
those set of rules and i want to give it

00:50:55,809 --> 00:51:01,589
this kind of semantics by adding new

00:50:58,599 --> 00:51:06,519
members to string member function and

00:51:01,589 --> 00:51:08,829
the association of a root set for

00:51:06,519 --> 00:51:13,779
building a tree and that says a rap

00:51:08,829 --> 00:51:14,770
industry is what protocol a domain the

00:51:13,779 --> 00:51:18,010
domain is something

00:51:14,770 --> 00:51:21,190
say whenever you build an expression

00:51:18,010 --> 00:51:24,160
this way I want it to be rapid with this

00:51:21,190 --> 00:51:27,580
kind of semantics and whenever you call

00:51:24,160 --> 00:51:29,110
an operator on this decorated tree what

00:51:27,580 --> 00:51:31,360
the operator does is remove the

00:51:29,110 --> 00:51:33,640
decorations builds a nikka tree and put

00:51:31,360 --> 00:51:37,300
it back into the same rapper so you

00:51:33,640 --> 00:51:39,220
carry on the fact that if you are for

00:51:37,300 --> 00:51:41,290
example 2 matrix is coming from the

00:51:39,220 --> 00:51:43,030
matrix domain and you add them you end

00:51:41,290 --> 00:51:47,290
up with a tree of an addition between

00:51:43,030 --> 00:51:48,790
two matrix of the matrix domain and you

00:51:47,290 --> 00:51:51,790
could also have another domain code for

00:51:48,790 --> 00:51:53,140
example the vector domain and the vector

00:51:51,790 --> 00:51:55,450
domain has a slightly different

00:51:53,140 --> 00:51:57,490
semantics and you know that when you do

00:51:55,450 --> 00:52:00,340
a multiplication with an expression from

00:51:57,490 --> 00:52:04,600
the matrix domain and the vector domain

00:52:00,340 --> 00:52:06,610
the resulting expression well where

00:52:04,600 --> 00:52:08,320
should it live in the vector domain

00:52:06,610 --> 00:52:12,790
because matrix time vectors give you a

00:52:08,320 --> 00:52:15,640
vector so we can have different domain

00:52:12,790 --> 00:52:18,250
and we can actually order them with some

00:52:15,640 --> 00:52:21,820
kind of relationships and we can decide

00:52:18,250 --> 00:52:23,620
/ operators if I have a domain domain be

00:52:21,820 --> 00:52:26,500
that comments what the domains that go

00:52:23,620 --> 00:52:29,080
outside this is a way we can actually

00:52:26,500 --> 00:52:32,020
sorry for that we can actually control

00:52:29,080 --> 00:52:34,330
the composite semantics of stuff okay

00:52:32,020 --> 00:52:36,040
because yeah logically this matrix times

00:52:34,330 --> 00:52:38,890
vector doesn't have to live in the

00:52:36,040 --> 00:52:43,870
matrix domain into it's a vector okay so

00:52:38,890 --> 00:52:45,820
we have this strange notation so let's

00:52:43,870 --> 00:52:48,610
make this forward information of expert

00:52:45,820 --> 00:52:51,070
that we be our types with all the actual

00:52:48,610 --> 00:52:53,320
semantics and we have this domain class

00:52:51,070 --> 00:52:56,650
which is inheriting from boost proto

00:52:53,320 --> 00:53:00,730
domain of boost proto generator of

00:52:56,650 --> 00:53:02,500
expert EPA that's been what that means

00:53:00,730 --> 00:53:05,410
that whenever you build an expression

00:53:02,500 --> 00:53:09,280
from this domain I want you to generate

00:53:05,410 --> 00:53:11,560
it by wrapping it into expert so you

00:53:09,280 --> 00:53:18,400
will take the type of my tree and

00:53:11,560 --> 00:53:23,320
put it there okay but I want you to do

00:53:18,400 --> 00:53:28,120
this if and only if the tree you pass me

00:53:23,320 --> 00:53:31,390
is validated by this grammar

00:53:28,120 --> 00:53:35,110
second parameters domain so if you write

00:53:31,390 --> 00:53:38,650
trap okay using expert you'd want to buy

00:53:35,110 --> 00:53:40,540
contrary to before and what do we do now

00:53:38,650 --> 00:53:44,350
so we have this link between the world

00:53:40,540 --> 00:53:46,570
set and wrapping okay you have the right

00:53:44,350 --> 00:53:49,090
to go into this box only if you match

00:53:46,570 --> 00:53:52,230
this kind of grammar so what do we do

00:53:49,090 --> 00:53:56,770
just have to write the code for the box

00:53:52,230 --> 00:54:01,270
so we write a code for expert is it okay

00:53:56,770 --> 00:54:02,830
for the zoo yeah correct and what does

00:54:01,270 --> 00:54:06,360
he do it either it's from boost phone

00:54:02,830 --> 00:54:10,090
extends let's say I want you to extend

00:54:06,360 --> 00:54:13,930
this kind of three types whenever its

00:54:10,090 --> 00:54:18,520
rapid inside myself and I want you to

00:54:13,930 --> 00:54:22,380
enforce the rule of domain okay and so

00:54:18,520 --> 00:54:25,060
this give you a lot of boilerplate okay

00:54:22,380 --> 00:54:26,530
so I'm just making a typedef because I

00:54:25,060 --> 00:54:28,810
don't really want to write all this crap

00:54:26,530 --> 00:54:30,100
everywhere so you basically need one

00:54:28,810 --> 00:54:32,620
thing you need a constructor that takes

00:54:30,100 --> 00:54:35,650
the naked tree and put it into your boss

00:54:32,620 --> 00:54:37,470
it doesn't have to do much just pass it

00:54:35,650 --> 00:54:41,470
to your show to your parent okay to

00:54:37,470 --> 00:54:43,660
proto extent there is a bunch of macros

00:54:41,470 --> 00:54:46,450
that control the fact that if you want

00:54:43,660 --> 00:54:48,580
to have some special members ended by

00:54:46,450 --> 00:54:53,290
proto so we want to use a sign with

00:54:48,580 --> 00:54:55,750
proto so use this macro and I simplifies

00:54:53,290 --> 00:54:58,900
your return type issues so I said we

00:54:55,750 --> 00:55:01,120
always return to the ball and I have my

00:54:58,900 --> 00:55:03,460
small operator parents same things like

00:55:01,120 --> 00:55:06,640
before and what I do inside this is very

00:55:03,460 --> 00:55:10,180
trivial I built I better never rate or

00:55:06,640 --> 00:55:14,080
instance by using able and I just call

00:55:10,180 --> 00:55:16,660
it on myself whenever you have an

00:55:14,080 --> 00:55:19,780
expression of something in Prato its

00:55:16,660 --> 00:55:23,200
behave as to something so you can pass

00:55:19,780 --> 00:55:25,630
an exper of iced tea to a numerator and

00:55:23,200 --> 00:55:27,970
the iterator will just rip the boxing

00:55:25,630 --> 00:55:32,230
and the wrapping and just walk on the

00:55:27,970 --> 00:55:33,910
naked tree sorry old transparent okay

00:55:32,230 --> 00:55:37,620
doesn't have to right into the grammar

00:55:33,910 --> 00:55:37,620
that you are rapid into something

00:55:38,950 --> 00:55:44,740
then I met another type which is a bit

00:55:42,160 --> 00:55:47,380
different I am tired of having to write

00:55:44,740 --> 00:55:49,060
terminal of something dot type so I make

00:55:47,380 --> 00:55:50,740
another class which I called viable and

00:55:49,060 --> 00:55:53,200
I says that the variable is an

00:55:50,740 --> 00:55:56,859
expression of a terminal of something

00:55:53,200 --> 00:55:58,540
and whenever you pass me a value I would

00:55:56,859 --> 00:56:00,310
just stir it into the value of the

00:55:58,540 --> 00:56:07,119
terminal using this product of a dual

00:56:00,310 --> 00:56:09,460
function there 48 and i will add my own

00:56:07,119 --> 00:56:11,260
compression points which was the

00:56:09,460 --> 00:56:13,690
operator the accident operator I'm

00:56:11,260 --> 00:56:17,680
taking what I'm taking the next pair of

00:56:13,690 --> 00:56:19,960
X and what do i do I evaluated using the

00:56:17,680 --> 00:56:24,730
function carburetor and I saw the result

00:56:19,960 --> 00:56:26,800
into my value dot and I written this now

00:56:24,730 --> 00:56:29,440
what can I do i can write this kind of

00:56:26,800 --> 00:56:33,040
thing i have a viable of em it's x is

00:56:29,440 --> 00:56:37,060
equal to 2 and y and y is equal to X

00:56:33,040 --> 00:56:42,660
plus X I'm X plus 3 let me print why

00:56:37,060 --> 00:56:47,079
using the information of a writer okay

00:56:42,660 --> 00:56:51,160
that's that's a bit okay ah three more

00:56:47,079 --> 00:56:54,460
coming any okay so prototypes you build

00:56:51,160 --> 00:56:56,380
neck three source negatory has to be put

00:56:54,460 --> 00:56:58,810
into a box that give you your actual

00:56:56,380 --> 00:57:02,619
language semantics your match which has

00:56:58,810 --> 00:57:06,810
a size your your lazy string as as an

00:57:02,619 --> 00:57:10,270
empty net or whatever but its its

00:57:06,810 --> 00:57:11,950
revenge reverentially transparent proto

00:57:10,270 --> 00:57:14,200
doesn't care whenever you pass the buck

00:57:11,950 --> 00:57:17,230
surd expression sorry about it about

00:57:14,200 --> 00:57:19,450
three to a match or to a transform it

00:57:17,230 --> 00:57:22,780
will see through it and apply whatever

00:57:19,450 --> 00:57:24,940
you need ok so we can't separate

00:57:22,780 --> 00:57:27,060
everything we separate the three

00:57:24,940 --> 00:57:30,099
construction with completely independent

00:57:27,060 --> 00:57:32,890
we also treat reversals and we

00:57:30,099 --> 00:57:37,960
absolutely semantics and everything is

00:57:32,890 --> 00:57:42,369
independent and get tied together by

00:57:37,960 --> 00:57:44,109
this notion of domain ok so that's a bit

00:57:42,369 --> 00:57:45,880
more complicated than what we saw in the

00:57:44,109 --> 00:57:47,680
first session where we just being

00:57:45,880 --> 00:57:50,410
pulling function there and they're so

00:57:47,680 --> 00:57:51,030
everything walked there we have this

00:57:50,410 --> 00:57:52,260
level of

00:57:51,030 --> 00:57:54,270
abstraction that we have to think about

00:57:52,260 --> 00:57:56,430
this is my grammar II of my language

00:57:54,270 --> 00:57:58,050
this is a men tip of my language

00:57:56,430 --> 00:58:00,660
elements and this is the rules of

00:57:58,050 --> 00:58:03,690
transformation that bring me something

00:58:00,660 --> 00:58:05,970
from my expression in my languages to

00:58:03,690 --> 00:58:10,740
some value in the c++ world or subtypes

00:58:05,970 --> 00:58:14,580
okay so session is over I saw so after

00:58:10,740 --> 00:58:16,140
the break I will dip into a more intense

00:58:14,580 --> 00:58:19,590
example of further which is already

00:58:16,140 --> 00:58:24,030
complete okay just to show you what kind

00:58:19,590 --> 00:58:27,120
of cookie things we can do and we will

00:58:24,030 --> 00:58:29,340
speak about all we can actually do that

00:58:27,120 --> 00:58:31,920
be probably a better way and what's as a

00:58:29,340 --> 00:58:34,050
limitation of steel having induce Prado

00:58:31,920 --> 00:58:36,240
okay or we can probably find a way to

00:58:34,050 --> 00:58:40,340
web them okay so see you after the break

00:58:36,240 --> 00:58:40,340

YouTube URL: https://www.youtube.com/watch?v=imU_WfonVr8


