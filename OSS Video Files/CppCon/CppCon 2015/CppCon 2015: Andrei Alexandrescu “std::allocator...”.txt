Title: CppCon 2015: Andrei Alexandrescu “std::allocator...”
Publication date: 2015-10-13
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
std::allocator Is to Allocation what std::vector Is to Vexation
--
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
std::allocator has an inglorious past, murky present, and cheerless future. STL introduced allocators as a stop gap for the now antiquated segmented memory models of the 1990s. Their design was limited and in many ways wasn't even aiming at helping allocation that much. Because allocators were there, they simply continued being there, up to the point they became impossible to either uproot or make work, in spite of valiant effort spent by the community.

But this talk aims at spending less time on poking criticism at std::allocator and more on actually defining allocator APIs that work. 

Scalable, high-performance memory allocation is a topic of increasing importance in today's demanding applications. For such, std::allocator simply doesn't work. This talk discusses the full design of a memory allocator created from first principles. It is generic, componentized, and composable for supporting application-specific allocation patterns.
— 
Andrei Alexandrescu is a researcher, software engineer, and author. He wrote three best-selling books on programming (Modern C++ Design, C++ Coding Standards, and The D Programming Language) and numerous articles and papers on wide-ranging topics from programming to language design to Machine Learning to Natural Language Processing. Andrei holds a PhD in Computer Science from the University of Washington and a BSc in Electrical Engineering from University "Politehnica" Bucharest. He works as a Research Scientist for Facebook.Website: http://erdani.comTwitter handle: @incomputable
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,410
let's start so we're start early because

00:00:01,709 --> 00:00:05,870
we're going to finish late so that's the

00:00:04,410 --> 00:00:09,480
right thing to do

00:00:05,870 --> 00:00:11,849
well I send this working title to a

00:00:09,480 --> 00:00:14,429
number of folks and that's not what what

00:00:11,849 --> 00:00:17,699
do I mean by this title and it was kind

00:00:14,429 --> 00:00:22,529
of difficult to so I had to explain my

00:00:17,699 --> 00:00:24,500
title so my title means okay here's my

00:00:22,529 --> 00:00:30,720
working title I had this working title

00:00:24,500 --> 00:00:32,690
which was too dark AC okay and then I

00:00:30,720 --> 00:00:34,950
thought it's not a very good title

00:00:32,690 --> 00:00:38,700
because you could make an allegation

00:00:34,950 --> 00:00:45,020
about an alligator Frankie this

00:00:38,700 --> 00:00:48,660
alligator caught my foot it ate my Crocs

00:00:45,020 --> 00:00:51,719
okay so there is a possibility of a

00:00:48,660 --> 00:00:53,629
connection there what I'm saying there

00:00:51,719 --> 00:00:57,500
is not a lot of connection between

00:00:53,629 --> 00:01:01,500
steadily cater and memory allocation

00:00:57,500 --> 00:01:03,210
this is my point and to wit my another

00:01:01,500 --> 00:01:08,010
working title of mine was design

00:01:03,210 --> 00:01:09,600
alligators that don't not work so you

00:01:08,010 --> 00:01:12,869
know being a program so this is not

00:01:09,600 --> 00:01:15,119
English it's not correct but it's sort

00:01:12,869 --> 00:01:16,439
of logic logically correct because you

00:01:15,119 --> 00:01:19,320
can imagine the programming put a

00:01:16,439 --> 00:01:24,570
parentheses around not work and that's

00:01:19,320 --> 00:01:26,009
like a verb not work like not work is a

00:01:24,570 --> 00:01:27,930
verb in you put the parentheses and it

00:01:26,009 --> 00:01:30,329
makes sense so it's made its I love

00:01:27,930 --> 00:01:31,820
grammatical malice that way in any

00:01:30,329 --> 00:01:38,670
language as it were

00:01:31,820 --> 00:01:40,890
anywho I hope it's okay so does it

00:01:38,670 --> 00:01:46,890
doesn't make clear that I'm not hearing

00:01:40,890 --> 00:01:50,970
peace okay is this clear to everybody

00:01:46,890 --> 00:01:55,020
I'm not here I'm here to destroy okay

00:01:50,970 --> 00:01:57,750
I'm on a warpath right now okay so just

00:01:55,020 --> 00:02:01,170
to make sure that my yes which oh okay

00:01:57,750 --> 00:02:03,210
um I was like oh my what question could

00:02:01,170 --> 00:02:05,440
be at this point

00:02:03,210 --> 00:02:06,940
so there's been something very

00:02:05,440 --> 00:02:09,759
interesting about memory allocation so

00:02:06,940 --> 00:02:12,880
this talk is not about making fun of the

00:02:09,759 --> 00:02:15,100
delicated because just too easy it's

00:02:12,880 --> 00:02:18,400
more about how to write good memory

00:02:15,100 --> 00:02:21,610
allocators doll do you have an interest

00:02:18,400 --> 00:02:24,190
in that kind of stuff you know I mean in

00:02:21,610 --> 00:02:25,870
the immortal words of Diana this is C++

00:02:24,190 --> 00:02:29,170
and this is like the ultimate argument

00:02:25,870 --> 00:02:32,800
of kings we care so this is kind of

00:02:29,170 --> 00:02:37,000
stuff that we care about so let's see I

00:02:32,800 --> 00:02:39,970
have a pointer here it doesn't work but

00:02:37,000 --> 00:02:43,450
it's the if I if I look like works I can

00:02:39,970 --> 00:02:48,970
see but now I'm gonna use my left eye

00:02:43,450 --> 00:02:50,320
for the rest of my life okay so it's

00:02:48,970 --> 00:02:53,050
very interesting that memory allocation

00:02:50,320 --> 00:02:54,790
has been a cyclic of business it's very

00:02:53,050 --> 00:02:57,010
just like if you if you're a vendor of

00:02:54,790 --> 00:02:59,380
malloc if you made your living if you

00:02:57,010 --> 00:03:02,650
paid bills by implanting malloc that's

00:02:59,380 --> 00:03:03,580
that was kind of a wild ride because in

00:03:02,650 --> 00:03:05,709
00:03:03,580 --> 00:03:07,570
so when malloc when when sort of the

00:03:05,709 --> 00:03:09,280
Kernighan and Ritchie book came out it

00:03:07,570 --> 00:03:11,350
had a mini memory allocator which is

00:03:09,280 --> 00:03:15,970
what by today's standards rather naive

00:03:11,350 --> 00:03:18,070
and simple but other point was kind of a

00:03:15,970 --> 00:03:19,870
huge thing there's a huge deal

00:03:18,070 --> 00:03:23,350
first of all it was that you could write

00:03:19,870 --> 00:03:25,860
it without assembler oh my god they

00:03:23,350 --> 00:03:29,530
could do this she's awesome

00:03:25,860 --> 00:03:31,330
look at that void star in the cast and

00:03:29,530 --> 00:03:33,010
all of you know it doesn't it was like

00:03:31,330 --> 00:03:35,709
wonderful that you could do like layout

00:03:33,010 --> 00:03:37,630
control and that kind of stuff in with

00:03:35,709 --> 00:03:40,630
memory the way you wanted really put

00:03:37,630 --> 00:03:43,600
your God for the first time could put

00:03:40,630 --> 00:03:45,310
bits where you want it and this was

00:03:43,600 --> 00:03:48,640
amazing because like by those times like

00:03:45,310 --> 00:03:50,230
Pascal was there it was kind of weird to

00:03:48,640 --> 00:03:53,320
do that kind of stuff in Pascal it's not

00:03:50,230 --> 00:03:55,810
impossible right those like lists which

00:03:53,320 --> 00:03:57,790
is way high level and there's Fortran

00:03:55,810 --> 00:03:59,670
which is like again like it couldn't do

00:03:57,790 --> 00:04:03,040
that kind of stuff right

00:03:59,670 --> 00:04:05,320
so when malloc came about and would you

00:04:03,040 --> 00:04:07,330
know when seeing that kind of low-level

00:04:05,320 --> 00:04:10,180
coding it was some sort of an eye opener

00:04:07,330 --> 00:04:12,250
and everybody went on a bandwagon and

00:04:10,180 --> 00:04:13,930
said oh all of my everything I'll do

00:04:12,250 --> 00:04:16,180
from now on is going to use dynamic

00:04:13,930 --> 00:04:16,570
memory allocation I'm not sure if you

00:04:16,180 --> 00:04:19,300
remember

00:04:16,570 --> 00:04:22,270
but before that it was that memory

00:04:19,300 --> 00:04:23,890
allocation was kind of was the word it

00:04:22,270 --> 00:04:27,340
was an exotic thing to do

00:04:23,890 --> 00:04:29,650
Oh in my Pascal program I used like you

00:04:27,340 --> 00:04:33,820
know that carrot and knew and I forgot

00:04:29,650 --> 00:04:34,930
the operators they had right so it was

00:04:33,820 --> 00:04:36,460
kind of an interesting thing to that

00:04:34,930 --> 00:04:39,490
system level to use dynamic allocation

00:04:36,460 --> 00:04:43,030
so 1983 and you know fast forward 10

00:04:39,490 --> 00:04:45,460
years - like malloc was done enough to

00:04:43,030 --> 00:04:49,600
be so bad that you know any code you

00:04:45,460 --> 00:04:52,480
wrote was better than it so another ten

00:04:49,600 --> 00:04:54,610
years later again malloc caught up sewed

00:04:52,480 --> 00:04:56,470
you know new horde alligators and G

00:04:54,610 --> 00:04:58,390
malloc and you know a lot of good new

00:04:56,470 --> 00:05:01,930
alligators came about DC malloc and

00:04:58,390 --> 00:05:03,670
whatnot and today you know it's kind of

00:05:01,930 --> 00:05:06,130
in the middle so today's like meal of

00:05:03,670 --> 00:05:07,360
the road you know so you should know

00:05:06,130 --> 00:05:08,950
about malloc and you should know how

00:05:07,360 --> 00:05:11,110
it's done and you should know that

00:05:08,950 --> 00:05:12,150
sometimes you can do better and here's

00:05:11,110 --> 00:05:14,680
where we are today

00:05:12,150 --> 00:05:20,200
okay look two years later but that's

00:05:14,680 --> 00:05:25,780
okay so I'm going to start with a bit of

00:05:20,200 --> 00:05:28,600
history this silence doesn't bode well I

00:05:25,780 --> 00:05:31,840
was expecting some murmurs like know

00:05:28,600 --> 00:05:33,940
what's going on here yeah yeah that kind

00:05:31,840 --> 00:05:38,230
of stuff yes thank you thank you for the

00:05:33,940 --> 00:05:41,020
sound effects here so by means of a bit

00:05:38,230 --> 00:05:44,190
of history so it started we see when we

00:05:41,020 --> 00:05:47,020
had where we had malloc and free and

00:05:44,190 --> 00:05:48,790
there's an asymmetry here because when I

00:05:47,020 --> 00:05:50,890
malloc member I passed the allocated

00:05:48,790 --> 00:05:57,720
size but when I free memory I don't pass

00:05:50,890 --> 00:05:59,170
the size back right is this good or bad

00:05:57,720 --> 00:06:03,760
bad

00:05:59,170 --> 00:06:06,910
why is it bad performance so essentially

00:06:03,760 --> 00:06:09,070
by committing to this API you already

00:06:06,910 --> 00:06:11,070
stated that I'm going to have to mine

00:06:09,070 --> 00:06:13,780
that size somewhere or another and

00:06:11,070 --> 00:06:16,240
eternity the first malloc that was sort

00:06:13,780 --> 00:06:17,920
of par for the course because they

00:06:16,240 --> 00:06:19,720
stored the size anyway because they need

00:06:17,920 --> 00:06:22,090
it for the size of the block that held a

00:06:19,720 --> 00:06:25,720
memory allocated and so on and so forth

00:06:22,090 --> 00:06:27,890
turns out this has been sort of a bad

00:06:25,720 --> 00:06:30,270
decision and it was kind of a

00:06:27,890 --> 00:06:31,860
we've been living with it ever since I

00:06:30,270 --> 00:06:35,730
was just talking with to Howard Hin

00:06:31,860 --> 00:06:37,050
Howard they are here there he is okay so

00:06:35,730 --> 00:06:40,160
I was talking to this fine gentleman

00:06:37,050 --> 00:06:42,900
Howard Hinnant and he said sound like

00:06:40,160 --> 00:06:45,570
been there done that and I would hate

00:06:42,900 --> 00:06:47,460
trying to do it again the doing anything

00:06:45,570 --> 00:06:49,710
any change exacting any change about

00:06:47,460 --> 00:06:52,620
memory allocation in in the respective

00:06:49,710 --> 00:06:55,020
standards so this is kind of an

00:06:52,620 --> 00:06:56,550
unpleasant thing so the color nose the

00:06:55,020 --> 00:06:58,530
size the current node knows the size but

00:06:56,550 --> 00:07:00,300
it doesn't pass it along and the

00:06:58,530 --> 00:07:02,850
allocator must manage the size that was

00:07:00,300 --> 00:07:05,610
out this is kind of a big deal size

00:07:02,850 --> 00:07:08,310
management is a kind of a complete pain

00:07:05,610 --> 00:07:11,730
in the proverbial we hate it it's a bad

00:07:08,310 --> 00:07:14,490
thing to wait give me a second here

00:07:11,730 --> 00:07:15,780
where are we I'm going to accelerate a

00:07:14,490 --> 00:07:18,350
few slides ahead they're not going to

00:07:15,780 --> 00:07:22,140
turn back just to make a point here

00:07:18,350 --> 00:07:24,810
Google for that number and you're going

00:07:22,140 --> 00:07:27,180
to find the you know the probably a part

00:07:24,810 --> 00:07:29,400
name at Sears it's a nail that you can

00:07:27,180 --> 00:07:31,440
put in the ground or whatever but it's

00:07:29,400 --> 00:07:34,860
also a proposal for the civil standard

00:07:31,440 --> 00:07:39,120
and omission of size information global

00:07:34,860 --> 00:07:41,520
operator delete aka free has unfortunate

00:07:39,120 --> 00:07:42,780
performance consequences and there's a

00:07:41,520 --> 00:07:47,090
lot of discussion about how to improve

00:07:42,780 --> 00:07:51,540
that what's the state of that Howard is

00:07:47,090 --> 00:07:52,800
it yeah all right

00:07:51,540 --> 00:07:55,950
why don't you google for it thank you

00:07:52,800 --> 00:07:57,990
very much hi delegation it's you know

00:07:55,950 --> 00:08:01,919
getting the management now so I gotta

00:07:57,990 --> 00:08:06,150
okay let me turn back here so this kind

00:08:01,919 --> 00:08:07,710
of a bummer okay and to if we could turn

00:08:06,150 --> 00:08:09,510
the time back and do it all over again

00:08:07,710 --> 00:08:11,040
we would do something like this we would

00:08:09,510 --> 00:08:14,220
say well let's define a structure that's

00:08:11,040 --> 00:08:16,260
block and it has the pointer and the

00:08:14,220 --> 00:08:18,060
length thank you very much and whenever

00:08:16,260 --> 00:08:20,040
I'm going to malloc I'm going to get

00:08:18,060 --> 00:08:21,560
back the block and I'm going to pass the

00:08:20,040 --> 00:08:26,010
block again when I release the memory

00:08:21,560 --> 00:08:29,460
the block has a size boom big deal right

00:08:26,010 --> 00:08:31,890
who cares essentially we do care right

00:08:29,460 --> 00:08:35,219
so there is importance attached to this

00:08:31,890 --> 00:08:38,610
so let's kind of say we if we want to

00:08:35,219 --> 00:08:41,040
design a new a locator let's start with

00:08:38,610 --> 00:08:44,280
this block simple structure

00:08:41,040 --> 00:08:46,620
all right it could hold two pointers etc

00:08:44,280 --> 00:08:49,290
it's a try and you know this it's pretty

00:08:46,620 --> 00:08:51,770
much equivalent and as the history goes

00:08:49,290 --> 00:08:56,010
the next generation was operator knew

00:08:51,770 --> 00:09:01,710
what's wrong about operator knew okay

00:08:56,010 --> 00:09:03,480
what's good about operator knew it

00:09:01,710 --> 00:09:06,030
Terry's the type information into the

00:09:03,480 --> 00:09:07,440
type right and it does all it can to

00:09:06,030 --> 00:09:09,510
throw it away as soon as possible

00:09:07,440 --> 00:09:11,280
because it forwards to malloc so the

00:09:09,510 --> 00:09:13,530
good and bad about new is it works with

00:09:11,280 --> 00:09:17,190
malloc it must work with Matt because

00:09:13,530 --> 00:09:18,420
historically it you know there's so much

00:09:17,190 --> 00:09:21,660
so many things you could at the same

00:09:18,420 --> 00:09:24,030
time so new was not like the highest

00:09:21,660 --> 00:09:26,610
priority there so so the new must work

00:09:24,030 --> 00:09:28,680
with malloc and then there's this whole

00:09:26,610 --> 00:09:31,440
side discussion about realloc because

00:09:28,680 --> 00:09:34,890
there's no renew right

00:09:31,440 --> 00:09:39,930
there's realloc which is awesome and is

00:09:34,890 --> 00:09:42,450
you never easy correctly right only

00:09:39,930 --> 00:09:47,100
Marshall and I were the two guys who

00:09:42,450 --> 00:09:49,050
know how to use it okay we're talking

00:09:47,100 --> 00:09:51,000
about this it's kind of funny but

00:09:49,050 --> 00:09:53,250
essentially operator knew was designed

00:09:51,000 --> 00:09:57,840
to work with malloc but you know I

00:09:53,250 --> 00:10:03,150
didn't I have you know like in that

00:09:57,840 --> 00:10:04,320
movie alert like I protest this is not a

00:10:03,150 --> 00:10:06,090
good thing

00:10:04,320 --> 00:10:10,050
operator knew what happened and I'll

00:10:06,090 --> 00:10:11,730
tell you what I think but it's okay that

00:10:10,050 --> 00:10:15,410
it's ads type information is great I

00:10:11,730 --> 00:10:19,620
love it there are few syntactic oddities

00:10:15,410 --> 00:10:21,270
the most interesting of which is I was

00:10:19,620 --> 00:10:24,870
just talking about this like int is a

00:10:21,270 --> 00:10:27,450
type right int is a type do we agree so

00:10:24,870 --> 00:10:31,380
far I have have your approval okay

00:10:27,450 --> 00:10:35,010
thanks beam on then in open square

00:10:31,380 --> 00:10:38,220
bracket 100 close square bracket is a

00:10:35,010 --> 00:10:41,370
type is it Z not it's a it's a fixed

00:10:38,220 --> 00:10:45,200
size array of 100 integers alright

00:10:41,370 --> 00:10:50,030
were you with me nothing up my sleeves

00:10:45,200 --> 00:10:52,920
okay new int I get a pointer to an int I

00:10:50,030 --> 00:10:54,320
get I allocate a new integer one integer

00:10:52,920 --> 00:10:59,510
and I get it a point

00:10:54,320 --> 00:11:02,980
back new int open square bracket 100

00:10:59,510 --> 00:11:02,980
close square bracket what'd I get

00:11:03,710 --> 00:11:09,980
there's something wrong here ladies and

00:11:05,390 --> 00:11:12,620
gentlemen there's a syntactic weirdness

00:11:09,980 --> 00:11:16,010
because even though int of 100 is a type

00:11:12,620 --> 00:11:19,190
in and of itself when you put it at the

00:11:16,010 --> 00:11:20,930
tail of new it's good you know that the

00:11:19,190 --> 00:11:22,430
syntax of the operator new is going to

00:11:20,930 --> 00:11:24,740
interpret a completely different way

00:11:22,430 --> 00:11:27,890
it's going to say oh this guy wanted not

00:11:24,740 --> 00:11:30,200
a fixed size array of 100 integers give

00:11:27,890 --> 00:11:32,540
me a pointer to that guy but you want to

00:11:30,200 --> 00:11:34,550
dynamically size the array of integers

00:11:32,540 --> 00:11:38,500
and I'm gonna give him a pointer to it

00:11:34,550 --> 00:11:41,930
because what I care about that guy right

00:11:38,500 --> 00:11:45,920
so that's the syntactic oddities that is

00:11:41,930 --> 00:11:47,780
kind of weird there's no communication

00:11:45,920 --> 00:11:49,700
between you and the constructor which

00:11:47,780 --> 00:11:52,460
everybody who's done try to do anything

00:11:49,700 --> 00:11:54,710
with regard to like class level operator

00:11:52,460 --> 00:11:56,270
new and constructors and stuff know

00:11:54,710 --> 00:11:58,610
Spain fully well like people do all

00:11:56,270 --> 00:12:00,560
these kind of crazy tricks I think the

00:11:58,610 --> 00:12:04,160
best trick you can do is class level

00:12:00,560 --> 00:12:08,030
operator new is to forget all about it

00:12:04,160 --> 00:12:09,560
and never use it and like really pretend

00:12:08,030 --> 00:12:12,680
it doesn't exist in a language and then

00:12:09,560 --> 00:12:17,900
you'll be happy you lead a better life

00:12:12,680 --> 00:12:22,250
right there's you know there's ona you

00:12:17,900 --> 00:12:25,910
know when I operate a new anonymous you

00:12:22,250 --> 00:12:27,830
should join the meetings okay so the

00:12:25,910 --> 00:12:29,840
greater a distraction okay so we have

00:12:27,830 --> 00:12:32,000
the greater a distraction TGA I love

00:12:29,840 --> 00:12:33,230
vehicle names right so the greater rate

00:12:32,000 --> 00:12:36,140
distraction goes like this

00:12:33,230 --> 00:12:40,850
well operator new is kind of weird and

00:12:36,140 --> 00:12:42,290
but you know it had to be there well how

00:12:40,850 --> 00:12:43,790
about the race we'll gotta have an

00:12:42,290 --> 00:12:45,500
operator new with brackets at the end

00:12:43,790 --> 00:12:47,750
and that's gonna allocate erase and

00:12:45,500 --> 00:12:49,400
erase only and by the way you should be

00:12:47,750 --> 00:12:52,310
sure you should make sure that whenever

00:12:49,400 --> 00:12:54,560
you call new the normal new called

00:12:52,310 --> 00:12:57,590
delete the normal delete but over a call

00:12:54,560 --> 00:13:01,430
new the array new you should remember to

00:12:57,590 --> 00:13:05,270
call the delete already leave you know

00:13:01,430 --> 00:13:08,200
the rule this is old you know why you

00:13:05,270 --> 00:13:08,200
need to know the rule

00:13:14,440 --> 00:13:19,600
okay I wanted like a coherent so you

00:13:17,270 --> 00:13:28,730
guys talk you guys talk and guys talk

00:13:19,600 --> 00:13:30,320
three votes here what yes yeah so

00:13:28,730 --> 00:13:32,030
there's there's a thing with the race

00:13:30,320 --> 00:13:33,590
and you know you deal with the nunnery

00:13:32,030 --> 00:13:35,780
syntaxes just going to call the first

00:13:33,590 --> 00:13:38,480
destructor it finds on the way and that

00:13:35,780 --> 00:13:41,360
kind of stuff but in fairness there's no

00:13:38,480 --> 00:13:42,980
there's no reason for it to be honest

00:13:41,360 --> 00:13:45,770
there's absolutely no reason and it

00:13:42,980 --> 00:13:47,840
should have been not existent at all you

00:13:45,770 --> 00:13:49,940
should not have existed it's just to

00:13:47,840 --> 00:13:52,100
make life difficult for everybody I are

00:13:49,940 --> 00:13:55,040
recommend operator new for any serious

00:13:52,100 --> 00:13:56,450
use of memory allocation you can quote

00:13:55,040 --> 00:13:58,970
me on that the guy with the camera you

00:13:56,450 --> 00:14:01,460
should have me there right okay so

00:13:58,970 --> 00:14:03,590
follow me at I'd like if this were jail

00:14:01,460 --> 00:14:05,810
and I want to escape this would be awful

00:14:03,590 --> 00:14:11,690
because he's following me I couldn't

00:14:05,810 --> 00:14:14,240
okay so and then you know the history

00:14:11,690 --> 00:14:15,560
goes along came a CD a locator and you

00:14:14,240 --> 00:14:17,090
know the funniest thing about a CD a

00:14:15,560 --> 00:14:20,570
locator is it's not for memory

00:14:17,090 --> 00:14:26,480
allocation and I'm not kidding what is a

00:14:20,570 --> 00:14:27,680
CD allocator for construction no pointer

00:14:26,480 --> 00:14:32,530
types Pablo

00:14:27,680 --> 00:14:38,000
okay yes he's the guy so it was for oh

00:14:32,530 --> 00:14:41,450
where are we near and far pointers who's

00:14:38,000 --> 00:14:46,040
old enough to remember near and far

00:14:41,450 --> 00:14:47,540
pointers okay great so you turn to your

00:14:46,040 --> 00:14:52,060
left and explain to the younger

00:14:47,540 --> 00:14:54,080
generation what we've been going through

00:14:52,060 --> 00:14:57,170
you're better off not knowing

00:14:54,080 --> 00:14:59,560
yes that's right every knowledge about

00:14:57,170 --> 00:15:03,220
near and far ends up on your face okay

00:14:59,560 --> 00:15:07,460
so not good I recommend it

00:15:03,220 --> 00:15:10,130
so well one question is like is a sea

00:15:07,460 --> 00:15:11,720
alligator bad or not and this is a

00:15:10,130 --> 00:15:13,730
legitimate question to ask because I've

00:15:11,720 --> 00:15:16,760
talked to people who claim it's a

00:15:13,730 --> 00:15:18,590
non-problem if the alligator works to

00:15:16,760 --> 00:15:22,140
wait we've been carrying it in standards

00:15:18,590 --> 00:15:24,870
like through C+ 17 still there it didn't

00:15:22,140 --> 00:15:29,400
I it's like that you know the square

00:15:24,870 --> 00:15:31,050
wheel on the car so this it's a truck

00:15:29,400 --> 00:15:32,580
has many wheels and everything one of

00:15:31,050 --> 00:15:37,080
them is square and that's the delegator

00:15:32,580 --> 00:15:39,600
we've been carrying it and one great

00:15:37,080 --> 00:15:41,340
thing that I should bring to your

00:15:39,600 --> 00:15:44,130
attention is the alleys they're made

00:15:41,340 --> 00:15:47,310
this talk of last year here at this

00:15:44,130 --> 00:15:52,050
conference and it's entitled making

00:15:47,310 --> 00:15:58,770
alligators work and there's two issues

00:15:52,050 --> 00:16:00,240
with that talk number one the title what

00:15:58,770 --> 00:16:03,840
I mean you know let's do a bit of

00:16:00,240 --> 00:16:04,910
thought you know linguistic analysis on

00:16:03,840 --> 00:16:08,160
the title

00:16:04,910 --> 00:16:11,190
did you ever see like it's 2014 so it

00:16:08,160 --> 00:16:15,090
was like last year and steady alligator

00:16:11,190 --> 00:16:17,850
has been finished before 1994 so done

00:16:15,090 --> 00:16:23,430
like 20 years later like in the book

00:16:17,850 --> 00:16:25,620
right 20 years later and 20 years later

00:16:23,430 --> 00:16:28,440
we have and it was a double whammy it

00:16:25,620 --> 00:16:30,450
was like 180 minutes talked it was like

00:16:28,440 --> 00:16:34,790
two talks back-to-back 90 minutes plus

00:16:30,450 --> 00:16:34,790
90 minutes and I set for most of it and

00:16:35,810 --> 00:16:43,110
it was 20 years after the fact and it

00:16:39,330 --> 00:16:46,760
was making alligators work there's no

00:16:43,110 --> 00:16:46,760
talk like making sort work

00:16:47,840 --> 00:16:54,710
I didn't go to a towline making making a

00:16:51,530 --> 00:16:59,120
CD vector work let's let's get that

00:16:54,710 --> 00:17:01,310
sucker working okay so the title already

00:16:59,120 --> 00:17:03,860
kind of is the smoking gun here ladies

00:17:01,310 --> 00:17:07,040
and gentlemen we have a problem here

00:17:03,860 --> 00:17:09,350
that right and the second matter I have

00:17:07,040 --> 00:17:11,390
with that talk so you know I sat through

00:17:09,350 --> 00:17:14,540
it and it's like okay so let me see

00:17:11,390 --> 00:17:17,360
where's the allocation happening there's

00:17:14,540 --> 00:17:20,750
not one slide on it that's dedicated to

00:17:17,360 --> 00:17:22,990
memory allocation which is very funny

00:17:20,750 --> 00:17:26,300
because allocators is in the title and

00:17:22,990 --> 00:17:27,950
linguistic analysis making alligators

00:17:26,300 --> 00:17:30,170
work I would expect there be very good

00:17:27,950 --> 00:17:34,240
at allocations because there are

00:17:30,170 --> 00:17:38,270
alligators right that kind of stuff so

00:17:34,240 --> 00:17:42,560
I'm an immigrant but you can't fool me

00:17:38,270 --> 00:17:46,310
with that stuff okay it's still I can

00:17:42,560 --> 00:17:47,600
figure out the basics all right so then

00:17:46,310 --> 00:17:48,830
I emailed Alice then I said you know

00:17:47,600 --> 00:17:50,450
could you please email me the slides

00:17:48,830 --> 00:17:52,400
because I want to call them and kind of

00:17:50,450 --> 00:17:57,140
use them as a reference and guess what

00:17:52,400 --> 00:18:01,550
he said nothing he didn't reply because

00:17:57,140 --> 00:18:03,350
he knew I'm gonna make fun of him so all

00:18:01,550 --> 00:18:08,330
right what's good and what could be done

00:18:03,350 --> 00:18:11,060
be better instead alligator I told you I

00:18:08,330 --> 00:18:11,990
did not come in peace friends did not

00:18:11,060 --> 00:18:18,980
come in peace

00:18:11,990 --> 00:18:21,230
so okay the short story here is that

00:18:18,980 --> 00:18:23,000
stood a locator is not a great alligator

00:18:21,230 --> 00:18:24,890
because it was not designed for that

00:18:23,000 --> 00:18:28,280
purpose it was designed for near and far

00:18:24,890 --> 00:18:31,160
pointers nyan 5 for pointers had to do

00:18:28,280 --> 00:18:34,100
with 16-bit systems and he had like

00:18:31,160 --> 00:18:35,990
pointers that were 20 bits with segment

00:18:34,100 --> 00:18:37,370
and offset again you don't want to know

00:18:35,990 --> 00:18:39,410
that stuff because it ends up on your

00:18:37,370 --> 00:18:41,930
face right so it was kind of a weird

00:18:39,410 --> 00:18:45,110
kind of thing that was essentially

00:18:41,930 --> 00:18:47,630
historically it was a bleep wonder in

00:18:45,110 --> 00:18:50,090
the history of computer science that has

00:18:47,630 --> 00:18:51,110
since long subsided it nobody cares

00:18:50,090 --> 00:18:55,340
about that stuff anymore

00:18:51,110 --> 00:18:57,740
and to wit does the committee the super

00:18:55,340 --> 00:18:59,360
committee actually removed everything

00:18:57,740 --> 00:19:01,600
related to near and far pointers from

00:18:59,360 --> 00:19:04,410
stood a locator essentially

00:19:01,600 --> 00:19:06,840
moving willfully its initial purpose

00:19:04,410 --> 00:19:10,030
which is very interesting and very

00:19:06,840 --> 00:19:11,950
telling so okay so there are few obvious

00:19:10,030 --> 00:19:13,120
mistakes that I noticed one is that you

00:19:11,950 --> 00:19:16,600
know that the first thing is like the

00:19:13,120 --> 00:19:22,270
type is a parameter in the allocator and

00:19:16,600 --> 00:19:24,549
that's a weird thing because type you

00:19:22,270 --> 00:19:26,429
know allocation should not have to do

00:19:24,549 --> 00:19:29,320
much with type at all

00:19:26,429 --> 00:19:32,740
it cares about two things one is the

00:19:29,320 --> 00:19:34,390
size and the other is the alignment do

00:19:32,740 --> 00:19:37,270
you care if you allocate for example

00:19:34,390 --> 00:19:40,720
they'll indulge me for a moment

00:19:37,270 --> 00:19:45,730
do you care to allocate an INT and an

00:19:40,720 --> 00:19:47,169
unsigned int in different ways probably

00:19:45,730 --> 00:19:51,280
not it's like what do I care

00:19:47,169 --> 00:19:53,440
they're both same size same layout even

00:19:51,280 --> 00:19:55,360
what do I care right taking this one

00:19:53,440 --> 00:19:58,240
step further reallocate about do you

00:19:55,360 --> 00:20:02,610
care about allocating an object of 128

00:19:58,240 --> 00:20:05,799
bytes of type 1 t1 and another object of

00:20:02,610 --> 00:20:08,940
128 bytes of type t2 do you care to

00:20:05,799 --> 00:20:08,940
allocate them in very different ways

00:20:09,150 --> 00:20:13,330
possibly well okay so alignment is kind

00:20:12,010 --> 00:20:14,740
of a different topic but you know I do

00:20:13,330 --> 00:20:16,600
care about the alignment but the type

00:20:14,740 --> 00:20:19,240
them set the styles and cells is like I

00:20:16,600 --> 00:20:21,250
have much less concern for and more

00:20:19,240 --> 00:20:24,970
often if I use a specialized very good a

00:20:21,250 --> 00:20:28,480
locator for t1 it's going to actually be

00:20:24,970 --> 00:20:29,679
a good a locator for 128 bytes it's

00:20:28,480 --> 00:20:31,990
going to be a very good allocate for

00:20:29,679 --> 00:20:34,270
that specific size and alignment not for

00:20:31,990 --> 00:20:36,130
that specific type alone so you care

00:20:34,270 --> 00:20:37,510
about size but not about the type so

00:20:36,130 --> 00:20:39,429
this whole thing putting the type in the

00:20:37,510 --> 00:20:41,350
allocator is weird it's not weird it is

00:20:39,429 --> 00:20:45,159
great with near and far pointers but

00:20:41,350 --> 00:20:47,830
it's not good for allocation so you know

00:20:45,159 --> 00:20:49,090
it's an allocate or not a data factory

00:20:47,830 --> 00:20:50,890
because the algorithm knows how to

00:20:49,090 --> 00:20:53,890
deallocate things and you know it's kind

00:20:50,890 --> 00:20:55,480
of odd it's not a it doesn't produce it

00:20:53,890 --> 00:20:57,130
construct objects it shouldn't be

00:20:55,480 --> 00:21:00,039
constructing objects it's just allocate

00:20:57,130 --> 00:21:02,470
memory even though it's a factor because

00:21:00,039 --> 00:21:03,940
it has construct and destroy it does

00:21:02,470 --> 00:21:08,110
have constructing destroy steal Howard

00:21:03,940 --> 00:21:09,560
doesn't it they didn't remove them those

00:21:08,110 --> 00:21:14,000
bastards man

00:21:09,560 --> 00:21:17,000
so it's in even though it claims to have

00:21:14,000 --> 00:21:20,180
factory powers it's still try fixing

00:21:17,000 --> 00:21:22,730
void star you know so that mean mine

00:21:20,180 --> 00:21:24,470
bubbles here so what I'm saying here is

00:21:22,730 --> 00:21:26,540
allocated should trade in memory blocks

00:21:24,470 --> 00:21:30,170
void star in size T that's it

00:21:26,540 --> 00:21:32,450
and just to mention like awful crotch

00:21:30,170 --> 00:21:36,770
remind you other all that good stuff

00:21:32,450 --> 00:21:40,520
that I'm sure is intimate knowledge to

00:21:36,770 --> 00:21:43,880
also if you don't need though that you

00:21:40,520 --> 00:21:46,820
don't get it Donna okay great

00:21:43,880 --> 00:21:49,040
another batch of obvious mistakes

00:21:46,820 --> 00:21:54,140
there's an assumption that alligators

00:21:49,040 --> 00:21:58,400
are stateless which is I'm picture them

00:21:54,140 --> 00:22:03,010
the oxymoron here a memory allocator

00:21:58,400 --> 00:22:03,010
that's giving me memory has no state

00:22:03,160 --> 00:22:07,220
right this is very interesting it's like

00:22:05,360 --> 00:22:10,940
the the empty bottle that you keep on

00:22:07,220 --> 00:22:14,180
drinking water from it's just you know

00:22:10,940 --> 00:22:17,360
it's like Sinbad you know the story it's

00:22:14,180 --> 00:22:19,750
like a magic you know this is empty but

00:22:17,360 --> 00:22:22,130
I'm pouring from it you know it's

00:22:19,750 --> 00:22:24,410
mysticism something is really

00:22:22,130 --> 00:22:27,590
interesting here except it's of course

00:22:24,410 --> 00:22:30,290
not it's like completely crappy right so

00:22:27,590 --> 00:22:32,480
allocate all alligators have steak some

00:22:30,290 --> 00:22:34,610
may have shared state it may be a global

00:22:32,480 --> 00:22:37,210
there because malloc that's how it works

00:22:34,610 --> 00:22:40,070
it has like global state dealing with

00:22:37,210 --> 00:22:41,960
some you know some is mana state you

00:22:40,070 --> 00:22:44,750
know I love like these complicated words

00:22:41,960 --> 00:22:47,290
you know the mana state pattern is like

00:22:44,750 --> 00:22:52,430
a global except it has a great name

00:22:47,290 --> 00:22:54,860
right mana state so well they have

00:22:52,430 --> 00:22:58,430
statement got a deal with it and by the

00:22:54,860 --> 00:23:01,340
way see process 14 does allow alligators

00:22:58,430 --> 00:23:03,650
to help state and you got it you got two

00:23:01,340 --> 00:23:06,050
gentlemen the front to here to thank for

00:23:03,650 --> 00:23:08,480
or pick their faces as you you know

00:23:06,050 --> 00:23:10,970
depending on your preference John linka

00:23:08,480 --> 00:23:12,370
San Pablo Halpern raise a hand please

00:23:10,970 --> 00:23:16,460
thanks very much

00:23:12,370 --> 00:23:19,610
there they are so you can talk with them

00:23:16,460 --> 00:23:22,350
yeah don't throw the tomatoes right now

00:23:19,610 --> 00:23:24,450
great so we have some state so

00:23:22,350 --> 00:23:27,510
definitely we want to support alligators

00:23:24,450 --> 00:23:31,650
with state and but there's something

00:23:27,510 --> 00:23:33,270
that public John did not do they did not

00:23:31,650 --> 00:23:35,010
do the composition thing which I think

00:23:33,270 --> 00:23:37,380
is the first thing you need to do with

00:23:35,010 --> 00:23:38,700
memory allocation if you want to write

00:23:37,380 --> 00:23:42,890
an alligator you gotta make it

00:23:38,700 --> 00:23:44,850
composable if you look at any allocated

00:23:42,890 --> 00:23:47,510
documentation you're going to see that

00:23:44,850 --> 00:23:49,500
it is a composition of several

00:23:47,510 --> 00:23:55,200
completely different allocation

00:23:49,500 --> 00:23:57,060
strategies look goo --gel Ford ugly

00:23:55,200 --> 00:23:59,190
alligator I'm going to say Doug the

00:23:57,060 --> 00:24:02,280
first sentence of like one of the first

00:23:59,190 --> 00:24:05,070
is like if the memory is low less than

00:24:02,280 --> 00:24:06,480
once at one kilobyte or whatever if the

00:24:05,070 --> 00:24:09,660
memory is less than one kilobyte

00:24:06,480 --> 00:24:12,060
then I'm going to do this stuff if it's

00:24:09,660 --> 00:24:13,230
between one kilobyte and 64 kilobytes

00:24:12,060 --> 00:24:15,960
I'm going to do some completely

00:24:13,230 --> 00:24:17,430
different strategy and if it's beyond

00:24:15,960 --> 00:24:20,160
that I'm just going to use their map or

00:24:17,430 --> 00:24:23,400
whatever help right so it's a

00:24:20,160 --> 00:24:25,710
composition of strategies depending on

00:24:23,400 --> 00:24:27,150
the size for example in this case if you

00:24:25,710 --> 00:24:28,950
turn to the windows a locator you're

00:24:27,150 --> 00:24:30,270
going to see the same thing oh for small

00:24:28,950 --> 00:24:31,920
objects is going to do this stuff and

00:24:30,270 --> 00:24:33,840
for medium objects this is completely

00:24:31,920 --> 00:24:36,270
different stuff and for a large judge is

00:24:33,840 --> 00:24:38,330
going to say out of memory and you know

00:24:36,270 --> 00:24:44,040
that kind of stuff

00:24:38,330 --> 00:24:45,750
my point is it's different right so and

00:24:44,040 --> 00:24:47,910
you're gonna see that even like four

00:24:45,750 --> 00:24:50,700
four one okay that small size allocated

00:24:47,910 --> 00:24:53,460
like up to 64 kilobytes for example that

00:24:50,700 --> 00:24:58,050
guy is inside its belly its you're gonna

00:24:53,460 --> 00:25:00,000
find an array of littler alligators each

00:24:58,050 --> 00:25:02,790
of whom is specialized for a specific

00:25:00,000 --> 00:25:06,150
size range in these buckets and all

00:25:02,790 --> 00:25:08,360
these good things so if you want to

00:25:06,150 --> 00:25:11,250
design an alligator you got to make

00:25:08,360 --> 00:25:15,390
composition the first thing in your

00:25:11,250 --> 00:25:16,800
design the first concern gating

00:25:15,390 --> 00:25:19,260
composition right is getting the

00:25:16,800 --> 00:25:21,720
alligators right so the rest of this

00:25:19,260 --> 00:25:29,910
talk is going to do composable

00:25:21,720 --> 00:25:31,530
alligators great close your eyes for a

00:25:29,910 --> 00:25:33,960
second because I want to go one slide

00:25:31,530 --> 00:25:35,690
ahead and back then I want to ask you a

00:25:33,960 --> 00:25:40,020
question okay close your eyes

00:25:35,690 --> 00:25:42,810
okay you design this so question for you

00:25:40,020 --> 00:25:46,740
what is the simplest composable

00:25:42,810 --> 00:25:49,650
alligator that you can imagine the null

00:25:46,740 --> 00:25:51,030
alligator excellent is the simplest

00:25:49,650 --> 00:25:53,100
allocation it's actually a useful

00:25:51,030 --> 00:25:57,390
alligator than all alligator what does

00:25:53,100 --> 00:25:58,080
it do nothing it is a show about nothing

00:25:57,390 --> 00:26:01,520
okay

00:25:58,080 --> 00:26:04,110
it does nothing but it does it in style

00:26:01,520 --> 00:26:06,570
it's always returning all whenever it

00:26:04,110 --> 00:26:08,460
try to allocate from it it's gonna you

00:26:06,570 --> 00:26:11,220
know when you try to free things what is

00:26:08,460 --> 00:26:14,160
going to do it's going to assert that

00:26:11,220 --> 00:26:16,320
the input is not what you pass to the

00:26:14,160 --> 00:26:18,120
null a locator for freeing it's gotta be

00:26:16,320 --> 00:26:20,940
now because you're not supposed to pass

00:26:18,120 --> 00:26:22,800
anything else because now you pass to

00:26:20,940 --> 00:26:26,070
the alligator what it passed you before

00:26:22,800 --> 00:26:28,440
right so the argument to free must be a

00:26:26,070 --> 00:26:32,790
previous return of knew of allocate

00:26:28,440 --> 00:26:35,790
right so interesting does it how much

00:26:32,790 --> 00:26:38,580
memory does he have was it infinite you

00:26:35,790 --> 00:26:40,860
know the word zero I mean it chews but

00:26:38,580 --> 00:26:42,390
my point you know this freedom here but

00:26:40,860 --> 00:26:46,320
what I'm saying here is Molly's are

00:26:42,390 --> 00:26:48,450
great what you'd call you know

00:26:46,320 --> 00:26:50,310
waveguides like in electrical

00:26:48,450 --> 00:26:51,180
engineering it's a great stopper for the

00:26:50,310 --> 00:26:52,950
wave the wave

00:26:51,180 --> 00:26:55,710
Gide I think all that stopper is it has

00:26:52,950 --> 00:26:58,830
a word for it terminator it's a great

00:26:55,710 --> 00:27:00,510
terminator so you can put that null a

00:26:58,830 --> 00:27:02,550
locator at the end of a chain of

00:27:00,510 --> 00:27:04,110
attempts of allocating memory at the end

00:27:02,550 --> 00:27:06,270
you say the hell with it I don't want to

00:27:04,110 --> 00:27:09,570
do I'm gonna use them a locator here and

00:27:06,270 --> 00:27:11,640
it's a great composition device but you

00:27:09,570 --> 00:27:13,890
know what that wasn't my next slide so

00:27:11,640 --> 00:27:17,190
can somebody tell me why next slide was

00:27:13,890 --> 00:27:21,390
the C the next simplest composable

00:27:17,190 --> 00:27:26,840
allocate that you can imagine huh slam

00:27:21,390 --> 00:27:32,220
that's very advanced so simpler I have a

00:27:26,840 --> 00:27:34,320
pass through what does he do it passes

00:27:32,220 --> 00:27:37,110
okay so let's let's kind of get a bit

00:27:34,320 --> 00:27:39,750
just a bit more sophisticated so this is

00:27:37,110 --> 00:27:44,550
a let's say it's a bit too simple now so

00:27:39,750 --> 00:27:49,350
a stack yeah but here's what I think we

00:27:44,550 --> 00:27:51,900
can do for back for back is this guy has

00:27:49,350 --> 00:27:54,540
to allocators anything any allocate is

00:27:51,900 --> 00:27:55,740
including an ally locator and that the

00:27:54,540 --> 00:27:59,220
knowledge is going to give you the pass

00:27:55,740 --> 00:28:01,020
through John so the for back alec is

00:27:59,220 --> 00:28:02,550
going to try the alligator number one

00:28:01,020 --> 00:28:06,270
and if that doesn't work it's going to

00:28:02,550 --> 00:28:09,000
try a locator number two the simplest

00:28:06,270 --> 00:28:12,180
composable alligator it knows how to try

00:28:09,000 --> 00:28:14,820
one and then try the next great let's

00:28:12,180 --> 00:28:16,890
design this guy and see what happens it

00:28:14,820 --> 00:28:19,650
and you'll see that once we start with

00:28:16,890 --> 00:28:22,170
composability the rest of the primitives

00:28:19,650 --> 00:28:24,150
are going to write themselves they're

00:28:22,170 --> 00:28:26,790
going to define them said that we will

00:28:24,150 --> 00:28:30,620
have no choice we will not have to be

00:28:26,790 --> 00:28:33,570
intelligent and that's a good sign right

00:28:30,620 --> 00:28:35,760
now I'm not kidding actually to not have

00:28:33,570 --> 00:28:37,710
to be smart is a great thing in software

00:28:35,760 --> 00:28:39,570
engineering right because it means

00:28:37,710 --> 00:28:41,490
you're you have the right frame of

00:28:39,570 --> 00:28:43,920
thinking at the right frame of reference

00:28:41,490 --> 00:28:46,230
and there's only one way to follow the

00:28:43,920 --> 00:28:48,090
tunnel right when I have too many

00:28:46,230 --> 00:28:49,650
choices like oh I could use this I could

00:28:48,090 --> 00:28:54,150
do that I could do that let me be smart

00:28:49,650 --> 00:28:55,260
about it right so let's pull this start

00:28:54,150 --> 00:28:58,830
putting on that string and see what our

00:28:55,260 --> 00:29:00,570
revels okay so I have an alligator as

00:28:58,830 --> 00:29:02,480
primary and fallback and they know how

00:29:00,570 --> 00:29:04,630
to allocate and deallocate memory and

00:29:02,480 --> 00:29:07,180
I'm going to use private

00:29:04,630 --> 00:29:08,680
it is because kind of it's got a fin on

00:29:07,180 --> 00:29:10,660
the slides I'm just going to kind of use

00:29:08,680 --> 00:29:12,580
private inheritance here although I

00:29:10,660 --> 00:29:14,380
could use membership and stuff but

00:29:12,580 --> 00:29:16,450
actually inheritance is nice because it

00:29:14,380 --> 00:29:21,280
gives me that empty based optimization

00:29:16,450 --> 00:29:22,810
thing so I shall use it and I have two

00:29:21,280 --> 00:29:26,050
primitives allocating the allocate this

00:29:22,810 --> 00:29:30,220
is all I know how to do who can

00:29:26,050 --> 00:29:34,930
implement allocate for me it's easy

00:29:30,220 --> 00:29:37,450
right so let me try float back allocator

00:29:34,930 --> 00:29:40,300
allocate you give me the size I'll give

00:29:37,450 --> 00:29:43,720
you a block back I'm trying

00:29:40,300 --> 00:29:45,190
the first allocator primary and if I

00:29:43,720 --> 00:29:50,050
didn't get a pointer I'm going to try

00:29:45,190 --> 00:29:56,380
the fallback okay I'm going to return

00:29:50,050 --> 00:30:04,780
the block so three liner do we know how

00:29:56,380 --> 00:30:07,150
to delegate this is like you know do

00:30:04,780 --> 00:30:09,700
these pants with my butt big right it's

00:30:07,150 --> 00:30:13,870
a trick questions friend it's a trick

00:30:09,700 --> 00:30:16,180
question friends it's it's tricky how

00:30:13,870 --> 00:30:26,770
can i implement the allocation with this

00:30:16,180 --> 00:30:28,660
setup huh dress trick you can't you

00:30:26,770 --> 00:30:30,370
can't you can't you gotta pass what you

00:30:28,660 --> 00:30:34,890
got from allocate you can't pass

00:30:30,370 --> 00:30:34,890
something wrong into the allocator right

00:30:45,750 --> 00:30:49,810
awesome I'll repeat yeah I see what

00:30:48,610 --> 00:30:51,970
you're saying so essentially you can

00:30:49,810 --> 00:30:54,160
queried with the primary allocator has a

00:30:51,970 --> 00:31:11,140
range of addresses that it can possibly

00:30:54,160 --> 00:31:14,540
return that kind of stuff yes

00:31:11,140 --> 00:31:16,550
extra crap so I got a essentially like

00:31:14,540 --> 00:31:18,500
my conclusion is where we found to

00:31:16,550 --> 00:31:20,870
deallocate this is API with allocate and

00:31:18,500 --> 00:31:23,090
deallocate is not enough do you agree

00:31:20,870 --> 00:31:25,370
with me again this is consequence the

00:31:23,090 --> 00:31:27,290
decision have been made when we wanted

00:31:25,370 --> 00:31:29,720
to have a composable fallback a locator

00:31:27,290 --> 00:31:31,610
and now we're dealing with what came out

00:31:29,720 --> 00:31:34,100
of you know we threw the Dominus on the

00:31:31,610 --> 00:31:36,020
floor let's you what so we gotta have a

00:31:34,100 --> 00:31:38,480
new primitive here which is called owns

00:31:36,020 --> 00:31:41,750
and also could the range check to do

00:31:38,480 --> 00:31:43,610
whatever ownership test but at the end

00:31:41,750 --> 00:31:45,830
of the day the primary locator must be

00:31:43,610 --> 00:31:50,780
able to tell whether a block came from

00:31:45,830 --> 00:31:52,700
it or not and only with that knowledge

00:31:50,780 --> 00:31:55,850
I'm able to implement the allocating it

00:31:52,700 --> 00:31:58,550
goes like this if P owns the block then

00:31:55,850 --> 00:32:00,470
PD allocate the block otherwise the

00:31:58,550 --> 00:32:02,270
backup the fallback allocate is going to

00:32:00,470 --> 00:32:04,540
deallocate again a four-line are very

00:32:02,270 --> 00:32:07,760
simple function but we added a new API

00:32:04,540 --> 00:32:09,470
primitive right so you know the primary

00:32:07,760 --> 00:32:12,830
key does must know how if whether it

00:32:09,470 --> 00:32:20,240
owns memory now question does the four

00:32:12,830 --> 00:32:24,470
back have to implement owns or not not

00:32:20,240 --> 00:32:27,950
necessarily but this you know it's kind

00:32:24,470 --> 00:32:30,320
of interesting like okay and another

00:32:27,950 --> 00:32:32,420
question is can this fallback allocate

00:32:30,320 --> 00:32:36,830
to this composite allocate of - can it

00:32:32,420 --> 00:32:40,240
implement on itself or not only if both

00:32:36,830 --> 00:32:44,650
so okay so you're doing my slides guys

00:32:40,240 --> 00:32:47,450
because this is part of good citizenry

00:32:44,650 --> 00:32:50,120
the fallback allocator is going to

00:32:47,450 --> 00:32:52,340
implement owns if both implement owns

00:32:50,120 --> 00:32:54,230
and it's going to do this Junction bit

00:32:52,340 --> 00:32:55,460
energy the primer owns it or the

00:32:54,230 --> 00:32:59,240
secondary owns it and there's no other

00:32:55,460 --> 00:32:59,900
way okay and you know that I love

00:32:59,240 --> 00:33:02,800
acronyms

00:32:59,900 --> 00:33:07,010
it is no there's never too many right

00:33:02,800 --> 00:33:09,890
you know what MD fina is it's a Latin

00:33:07,010 --> 00:33:17,330
word for let me let me see if I remember

00:33:09,890 --> 00:33:19,920
it even method ah method definition

00:33:17,330 --> 00:33:23,950
failure is not an error

00:33:19,920 --> 00:33:27,600
I'm not kidding so method if it means

00:33:23,950 --> 00:33:30,600
this in C++ if you write a method and if

00:33:27,600 --> 00:33:33,360
you never call it in a template class

00:33:30,600 --> 00:33:35,730
the tree is not going to be audible

00:33:33,360 --> 00:33:38,380
right it's not nothing's gonna happen

00:33:35,730 --> 00:33:40,480
you write the wrong method you don't

00:33:38,380 --> 00:33:45,250
call it and it's all good between

00:33:40,480 --> 00:34:01,990
friends right you get is the friend

00:33:45,250 --> 00:34:05,110
keyword somewhere so yes so the question

00:34:01,990 --> 00:34:07,770
was instead instead of implementing all

00:34:05,110 --> 00:34:10,810
sorts or as an implementation of owns

00:34:07,770 --> 00:34:34,860
right could a fallback allocator

00:34:10,810 --> 00:34:39,010
allocate a bit more memory and put right

00:34:34,860 --> 00:34:42,940
let me see that could even work what if

00:34:39,010 --> 00:34:44,350
the primary also always say both in the

00:34:42,940 --> 00:34:47,850
primary and the secondary allocate the

00:34:44,350 --> 00:34:51,730
boolean yeah we could do that but that's

00:34:47,850 --> 00:34:53,919
essentially that's time and space it's

00:34:51,730 --> 00:34:55,480
time and wasting on this implementation

00:34:53,919 --> 00:34:58,690
in space time wasting in the in the

00:34:55,480 --> 00:35:01,480
thing whereas in some alligator owns is

00:34:58,690 --> 00:35:03,820
a trivial one liner and I'm going to get

00:35:01,480 --> 00:35:06,130
there so the answer is time and space I

00:35:03,820 --> 00:35:09,100
it would be wasteful to do so for many

00:35:06,130 --> 00:35:11,110
alligators and also let me kind of

00:35:09,100 --> 00:35:13,060
specify here that very often was the

00:35:11,110 --> 00:35:17,110
fallback alligator it's going to be

00:35:13,060 --> 00:35:18,820
malloc like the last response of Kings

00:35:17,110 --> 00:35:20,650
is going to be like ah the hell with it

00:35:18,820 --> 00:35:22,540
let's use malloc and call it a day right

00:35:20,650 --> 00:35:23,980
and trying these strategies and stuff

00:35:22,540 --> 00:35:26,170
and any of the day English malloc

00:35:23,980 --> 00:35:27,250
ordinal allocate or whatever have have

00:35:26,170 --> 00:35:29,200
you but essentially is going to be

00:35:27,250 --> 00:35:31,900
unallocated as very dumb and doesn't

00:35:29,200 --> 00:35:33,490
know much about ownership so it's nice

00:35:31,900 --> 00:35:36,070
that the primary knows

00:35:33,490 --> 00:35:38,349
needs to know but the the Citiz the

00:35:36,070 --> 00:35:47,140
fallback doesn't need no buttons so

00:35:38,349 --> 00:35:49,060
alright um so suddenly I have a working

00:35:47,140 --> 00:35:51,099
system because I you know it's funny I

00:35:49,060 --> 00:35:52,780
wrote only two liners three liners for

00:35:51,099 --> 00:35:54,820
liners and something we have something

00:35:52,780 --> 00:35:56,500
that's working because it's trivial to

00:35:54,820 --> 00:36:01,420
write a stack a locator with what we

00:35:56,500 --> 00:36:04,869
have has a constant you know has a pool

00:36:01,420 --> 00:36:06,520
of data it just sits on the stack and it

00:36:04,869 --> 00:36:07,960
moves the pointer along when every

00:36:06,520 --> 00:36:10,240
allocated bounds the pointer whenever

00:36:07,960 --> 00:36:13,180
the allocated does nothing or bound the

00:36:10,240 --> 00:36:14,800
pointer back will get that and something

00:36:13,180 --> 00:36:17,170
we have something upwards because we

00:36:14,800 --> 00:36:20,619
have a fallback a locator that takes a

00:36:17,170 --> 00:36:25,589
stack allocate of 16 kilobytes and if

00:36:20,619 --> 00:36:25,589
that fills up when I use them a locator

00:36:26,010 --> 00:36:40,720
question can I do the allocation in the

00:36:30,520 --> 00:36:43,980
stack a locator who's with yes was

00:36:40,720 --> 00:36:46,000
qualified yes because we qualify yes

00:36:43,980 --> 00:36:48,160
everybody should be qualified yes

00:36:46,000 --> 00:36:51,930
because because depends on value the

00:36:48,160 --> 00:36:58,210
qualifier could be negative always right

00:36:51,930 --> 00:37:00,730
John your with yes or with no yes so it

00:36:58,210 --> 00:37:05,859
all depends on the qualifier excellent

00:37:00,730 --> 00:37:10,000
cancer volatile with qualifier so here's

00:37:05,859 --> 00:37:11,080
what I'm getting with this yeah here's

00:37:10,000 --> 00:37:13,119
what I'm going with this

00:37:11,080 --> 00:37:15,609
the allocate I'm gonna come back no

00:37:13,119 --> 00:37:19,839
worries so the allocate goes like this

00:37:15,609 --> 00:37:23,230
if the the pointer pointing to the

00:37:19,839 --> 00:37:25,480
beginning of the block plus the size of

00:37:23,230 --> 00:37:28,060
the block rounded up to the line month

00:37:25,480 --> 00:37:32,080
I'm gonna explain that in a second if

00:37:28,060 --> 00:37:34,960
that guy is exactly what my stack

00:37:32,080 --> 00:37:37,510
allocation my stack of locators pull

00:37:34,960 --> 00:37:40,960
ends then I can do the allocation in

00:37:37,510 --> 00:37:43,240
other words in plain language that means

00:37:40,960 --> 00:37:44,920
if this the allocation is that the

00:37:43,240 --> 00:37:46,839
allocation of the last allocation that

00:37:44,920 --> 00:37:47,290
happened then I came the allocate

00:37:46,839 --> 00:37:49,540
because I

00:37:47,290 --> 00:37:55,840
roll back the pointer but if it's

00:37:49,540 --> 00:37:57,490
somewhere in the middle I can't okay so

00:37:55,840 --> 00:37:59,340
with a stack a locator so whenever I

00:37:57,490 --> 00:38:01,960
allocate you move the pointer forward so

00:37:59,340 --> 00:38:05,620
behind this allocated space in front of

00:38:01,960 --> 00:38:07,630
is the available free space right so if

00:38:05,620 --> 00:38:09,880
there's it just so happens that some guy

00:38:07,630 --> 00:38:12,580
like way behind you once to deallocate

00:38:09,880 --> 00:38:14,200
memory it can't be done but if this is

00:38:12,580 --> 00:38:16,840
the last allocation that happened I can

00:38:14,200 --> 00:38:20,020
make a step back right so that pointer

00:38:16,840 --> 00:38:25,420
can move back no problem without without

00:38:20,020 --> 00:38:28,810
harm okay so we have a conditional the

00:38:25,420 --> 00:38:30,670
allocation which is interesting as as we

00:38:28,810 --> 00:38:33,610
talk like owns is trivial because it's

00:38:30,670 --> 00:38:37,600
like a very simple range test it's very

00:38:33,610 --> 00:38:40,210
cheap so we also have a new primitive

00:38:37,600 --> 00:38:42,940
which again comes from just looking at

00:38:40,210 --> 00:38:44,740
the definition there and we have a

00:38:42,940 --> 00:38:47,050
deallocate all that's very cheap and

00:38:44,740 --> 00:38:50,440
very risky as it were because it just

00:38:47,050 --> 00:38:51,960
goes resets everything and makes the

00:38:50,440 --> 00:39:18,400
memory usable again

00:38:51,960 --> 00:39:19,600
yes qualified question right yeah yeah

00:39:18,400 --> 00:39:21,160
so you don't need to you don't need to

00:39:19,600 --> 00:39:23,530
qualify but essentially here here's the

00:39:21,160 --> 00:39:30,250
deal at this level I'm only worrying

00:39:23,530 --> 00:39:34,170
about void star and size that's it no

00:39:30,250 --> 00:39:36,869
rats bodies involved that's true

00:39:34,170 --> 00:39:39,029
so at this level and it's kind of

00:39:36,869 --> 00:39:40,140
interesting so there's some there's

00:39:39,029 --> 00:39:42,269
something deep to this because many

00:39:40,140 --> 00:39:45,539
people approach allocation has a kind of

00:39:42,269 --> 00:39:47,460
object and everything matter but

00:39:45,539 --> 00:39:49,769
actually can isolate the two quite

00:39:47,460 --> 00:39:51,900
cleanly it turns out and then you can

00:39:49,769 --> 00:39:53,910
build a typed a locators on top of the

00:39:51,900 --> 00:39:56,010
on type allocators so let me give a few

00:39:53,910 --> 00:39:57,329
more explanations about the stack a

00:39:56,010 --> 00:40:04,200
locator because I think it's interesting

00:39:57,329 --> 00:40:07,670
um well that's okay gotta be really good

00:40:04,200 --> 00:40:10,109
with this you gotta have a degree so um

00:40:07,670 --> 00:40:12,450
it's very easy to use it because you

00:40:10,109 --> 00:40:16,109
just allocate stuff and you use copics

00:40:12,450 --> 00:40:18,390
it from my previous talk that um and you

00:40:16,109 --> 00:40:21,150
deallocate stuff and you kind of use it

00:40:18,390 --> 00:40:22,619
and all is good and it's this is

00:40:21,150 --> 00:40:24,569
actually a very powerful pattern this

00:40:22,619 --> 00:40:27,000
whole stack a locator bag by malloc

00:40:24,569 --> 00:40:29,700
because it turns out you can accelerate

00:40:27,000 --> 00:40:32,039
your application like 95% of all cases

00:40:29,700 --> 00:40:35,160
by doing stack allocation which is like

00:40:32,039 --> 00:40:37,079
super hot super great super awesome and

00:40:35,160 --> 00:40:39,539
it you know most of the time like you

00:40:37,079 --> 00:40:41,160
know web server whatnot your requests

00:40:39,539 --> 00:40:43,559
are going to be small enough to fit on

00:40:41,160 --> 00:40:46,190
the stack and you're still going to be

00:40:43,559 --> 00:40:48,869
have correct code because whatever

00:40:46,190 --> 00:40:51,150
larger allocation requests come about

00:40:48,869 --> 00:40:53,339
you're going to delegate to malloc and

00:40:51,150 --> 00:40:55,440
it's like a very powerful patent if you

00:40:53,339 --> 00:40:55,950
can actually make that generic this is

00:40:55,440 --> 00:41:00,180
awesome

00:40:55,950 --> 00:41:01,980
right let's look at the allocate

00:41:00,180 --> 00:41:03,359
function because I promised you a few

00:41:01,980 --> 00:41:05,549
details about this whole round to

00:41:03,359 --> 00:41:08,480
aligned who can tell me what run to a

00:41:05,549 --> 00:41:10,710
line does and what's the purpose of it

00:41:08,480 --> 00:41:13,380
stack a locator is going to move the

00:41:10,710 --> 00:41:18,660
pointer back a force in the in the

00:41:13,380 --> 00:41:21,569
buffer and it can't move like it let's

00:41:18,660 --> 00:41:23,250
say one to allocate one byte and I start

00:41:21,569 --> 00:41:25,079
with a stack like 16 kilobytes and let's

00:41:23,250 --> 00:41:27,359
say it's a line nicely to like word

00:41:25,079 --> 00:41:29,279
sighs now get one byte so I'm going to

00:41:27,359 --> 00:41:31,410
move the point the point I'm going to

00:41:29,279 --> 00:41:36,440
move from an aligned address to a line

00:41:31,410 --> 00:41:40,440
Andres plus one byte do you see the

00:41:36,440 --> 00:41:41,990
tsunami that's being initiated here what

00:41:40,440 --> 00:41:44,609
is it please

00:41:41,990 --> 00:41:47,870
the next allocation is going to be

00:41:44,609 --> 00:41:53,400
unaligned right how do you fix that

00:41:47,870 --> 00:41:55,080
yes you can run you know so there's a

00:41:53,400 --> 00:41:57,000
number of solutions and the simplest one

00:41:55,080 --> 00:42:00,120
is to whenever you get a request you run

00:41:57,000 --> 00:42:01,800
the top first thing and then you kind of

00:42:00,120 --> 00:42:05,360
allocate and if you start with rounded

00:42:01,800 --> 00:42:10,340
you add the round numbered math says

00:42:05,360 --> 00:42:10,340
it's going to work out right yes right

00:42:19,100 --> 00:42:23,690
so the question was why not being lazy

00:42:21,630 --> 00:42:25,620
about it and instead of aligning

00:42:23,690 --> 00:42:27,630
compulsively at the beginning of the

00:42:25,620 --> 00:42:29,940
allocation you kind of say well I'm

00:42:27,630 --> 00:42:32,550
going to align kind of fun of need basis

00:42:29,940 --> 00:42:35,130
right that's a valid solution I gotta

00:42:32,550 --> 00:42:37,650
say this that I don't see a big downside

00:42:35,130 --> 00:42:39,420
to it right so it's a good solution yeah

00:42:37,650 --> 00:42:42,690
I gotta have the type information I

00:42:39,420 --> 00:42:43,080
would say can't make it work so good

00:42:42,690 --> 00:42:47,940
point

00:42:43,080 --> 00:42:50,460
great so in this solution particularly I

00:42:47,940 --> 00:42:53,130
round up compulsively and I have a test

00:42:50,460 --> 00:42:56,370
for did I reach the end do I have room

00:42:53,130 --> 00:43:00,870
for this guy and etc so that kind of

00:42:56,370 --> 00:43:04,200
stuff great notice that my code is like

00:43:00,870 --> 00:43:06,870
not PTR compliant I will use null PTR

00:43:04,200 --> 00:43:09,600
and actually I'm using also like the

00:43:06,870 --> 00:43:11,550
brace initializers and everything but I

00:43:09,600 --> 00:43:14,310
do see a bug in this slide which is not

00:43:11,550 --> 00:43:15,470
Peter is not blue which bothers me to no

00:43:14,310 --> 00:43:20,730
end

00:43:15,470 --> 00:43:24,750
ok that's a bit of a bummer ok the

00:43:20,730 --> 00:43:28,140
second sort of I would say it's yeah

00:43:24,750 --> 00:43:30,000
maybe this maybe it's not the second way

00:43:28,140 --> 00:43:33,690
it's a very important pattern in memory

00:43:30,000 --> 00:43:35,610
allocation is a free list before we can

00:43:33,690 --> 00:43:38,220
the implementation who who could explain

00:43:35,610 --> 00:43:41,210
what the free list is and does yeah

00:43:38,220 --> 00:43:46,970
except from Fedor whom I know

00:43:41,210 --> 00:43:49,250
he's gonna yes it's not a fixed sized

00:43:46,970 --> 00:43:57,950
alligator oh it is but I mean I

00:43:49,250 --> 00:44:01,160
misunderstood sigh go ahead so you make

00:43:57,950 --> 00:44:03,440
a list of fixed size chunks and you

00:44:01,160 --> 00:44:05,089
whenever people ask for it if it just so

00:44:03,440 --> 00:44:07,700
happens is the right size you just give

00:44:05,089 --> 00:44:10,730
it from the list that's a list but not a

00:44:07,700 --> 00:44:12,380
free list the free aspect is interesting

00:44:10,730 --> 00:44:15,230
because the phrase has almost no

00:44:12,380 --> 00:44:19,359
overhead in in memory because it uses

00:44:15,230 --> 00:44:19,359
freed memory to hold its information

00:44:20,710 --> 00:44:26,660
freely who can intrusive it's a sort of

00:44:24,980 --> 00:44:35,180
an intrusive list how does it work

00:44:26,660 --> 00:44:37,549
yes yes the the free list enters in

00:44:35,180 --> 00:44:40,099
action when you deallocate that's why

00:44:37,549 --> 00:44:41,569
it's free list it's right so the funny

00:44:40,099 --> 00:44:42,710
thing about the free list is it starts

00:44:41,569 --> 00:44:44,930
empty it starts with nothing I know

00:44:42,710 --> 00:44:47,119
nothing but it has a backup a locator

00:44:44,930 --> 00:44:49,279
and the first allocations are going to

00:44:47,119 --> 00:44:51,470
go use the backup a locator but whenever

00:44:49,279 --> 00:44:55,309
deallocate the freelee's wakes up and

00:44:51,470 --> 00:44:57,109
comes and says ah is this the allocation

00:44:55,309 --> 00:45:00,049
of a very specific size that I care

00:44:57,109 --> 00:45:02,119
about and if so I'm going to thread it

00:45:00,049 --> 00:45:03,890
through a linked list to which I only

00:45:02,119 --> 00:45:07,309
have one pointer which is the head of

00:45:03,890 --> 00:45:11,900
the list and whatever an allocation

00:45:07,309 --> 00:45:14,329
comes about later the freeness goes huh

00:45:11,900 --> 00:45:18,619
is this allocation for this exact size

00:45:14,329 --> 00:45:21,529
and is my point or not now has have

00:45:18,619 --> 00:45:23,450
people freed object of the size before

00:45:21,529 --> 00:45:26,210
and if so is going to give you that

00:45:23,450 --> 00:45:29,599
object in all of one it's a very

00:45:26,210 --> 00:45:31,329
powerful pattern what are the downsides

00:45:29,599 --> 00:45:34,039
of a free list

00:45:31,329 --> 00:45:41,049
it never ends never all advantages you

00:45:34,039 --> 00:45:43,279
know you never give memory back to the

00:45:41,049 --> 00:45:46,609
backing story the free list could go

00:45:43,279 --> 00:45:49,520
forever so if you happen to allocate at

00:45:46,609 --> 00:45:51,200
some point a million objects of size 64

00:45:49,520 --> 00:45:53,599
whatever you have for the free list and

00:45:51,200 --> 00:45:54,540
then you freedom the fries are going to

00:45:53,599 --> 00:45:56,400
keep them and it's going

00:45:54,540 --> 00:46:01,580
fragment your memory up to was ooh right

00:45:56,400 --> 00:46:01,580
another disadvantage Fedor

00:46:09,170 --> 00:46:18,350
so to summarize free list have better

00:46:13,950 --> 00:46:20,700
put it nicely have poor thread affinity

00:46:18,350 --> 00:46:22,830
awesome have poor thread affinity

00:46:20,700 --> 00:46:24,510
meaning thread allocates puts it on the

00:46:22,830 --> 00:46:26,250
global free list and other thread

00:46:24,510 --> 00:46:28,380
allocates and that the memory that was

00:46:26,250 --> 00:46:30,810
owned by a thread just a second ago you

00:46:28,380 --> 00:46:32,040
know nano second ago is going to go to a

00:46:30,810 --> 00:46:33,780
different thread and that's kind of

00:46:32,040 --> 00:46:42,510
weird that's going to have a cold cash

00:46:33,780 --> 00:46:51,060
and everything John what difference does

00:46:42,510 --> 00:46:53,900
it make if it's a different thread well

00:46:51,060 --> 00:46:53,900
what a chance of that

00:47:13,100 --> 00:47:17,220
that's why do you have to okay so you're

00:47:15,720 --> 00:47:18,900
kind of you guys are getting to

00:47:17,220 --> 00:47:21,930
something I was getting to anyway

00:47:18,900 --> 00:47:24,480
although there's no slice for it so I

00:47:21,930 --> 00:47:27,030
have no proof here but let me tell you

00:47:24,480 --> 00:47:28,860
this anybody who defines are free least

00:47:27,030 --> 00:47:31,590
a locator the first thing they do they

00:47:28,860 --> 00:47:35,220
make a thread local free list and that's

00:47:31,590 --> 00:47:36,630
the first line of defense there so you

00:47:35,220 --> 00:47:38,310
have like our thread you know and

00:47:36,630 --> 00:47:41,400
threads and each is going to have a mini

00:47:38,310 --> 00:47:43,620
free list and if those kind of don't

00:47:41,400 --> 00:47:46,890
work you may have a global free list or

00:47:43,620 --> 00:47:48,570
not as it's your choice so I'm giving

00:47:46,890 --> 00:47:51,480
you the engine to do that I'm not

00:47:48,570 --> 00:47:53,600
telling you how to do it right but this

00:47:51,480 --> 00:47:56,640
is an important point freely start

00:47:53,600 --> 00:47:58,380
contention intensive when you want to

00:47:56,640 --> 00:48:01,410
share them what's another disadvantage

00:47:58,380 --> 00:48:05,010
was really subtle free list another

00:48:01,410 --> 00:48:07,370
disadvantage yes memory fragmentation we

00:48:05,010 --> 00:48:25,490
talked about that yes

00:48:07,370 --> 00:48:27,710
oh yeah

00:48:25,490 --> 00:48:29,840
so it's intrusive and therefore if you

00:48:27,710 --> 00:48:32,000
mess with the already freed memory

00:48:29,840 --> 00:49:05,690
you're gonna miss your free list yes

00:48:32,000 --> 00:49:07,820
agreed okay right so it right so okay

00:49:05,690 --> 00:49:10,330
let me summarize you you guys got a

00:49:07,820 --> 00:49:14,830
slight with you know give like shorter

00:49:10,330 --> 00:49:17,840
so that in short it's complicated right

00:49:14,830 --> 00:49:19,550
I'm not kidding I'm not kidding so

00:49:17,840 --> 00:49:22,250
essentially free least have like really

00:49:19,550 --> 00:49:24,470
weird behavior depending on what's going

00:49:22,250 --> 00:49:28,010
on your system and sort of work what I

00:49:24,470 --> 00:49:29,420
wanted to to to say here the very solid

00:49:28,010 --> 00:49:34,670
disadvantage of free list which is

00:49:29,420 --> 00:49:39,020
non-intuitive is they are very cash

00:49:34,670 --> 00:49:40,460
adverse and people at when you first

00:49:39,020 --> 00:49:42,170
look at them they look great because

00:49:40,460 --> 00:49:43,550
like three days it's hot memory because

00:49:42,170 --> 00:49:45,440
I'm kind of getting from the free lease

00:49:43,550 --> 00:49:47,030
I'm releasing memory and getting back

00:49:45,440 --> 00:49:51,170
and it's kind of a great thing and

00:49:47,030 --> 00:49:53,630
actually that's not the case often very

00:49:51,170 --> 00:49:56,500
often free least are actually adverse to

00:49:53,630 --> 00:49:59,420
cash there I'm friendly to the cash and

00:49:56,500 --> 00:50:00,920
one one subtle aspect that happens is

00:49:59,420 --> 00:50:03,350
because of all those pointers that you

00:50:00,920 --> 00:50:05,870
have to write is your writing cold

00:50:03,350 --> 00:50:07,910
memory very often when you're free

00:50:05,870 --> 00:50:10,430
memory so it's it's not it's not the

00:50:07,910 --> 00:50:13,490
best thing because many applications

00:50:10,430 --> 00:50:17,060
free memory that's already cold and a

00:50:13,490 --> 00:50:19,430
good allocator tries to not write to

00:50:17,060 --> 00:50:21,260
called memory it turns out memory that's

00:50:19,430 --> 00:50:24,770
being freed is very often cold

00:50:21,260 --> 00:50:27,920
right okay nevertheless

00:50:24,770 --> 00:50:29,780
freelee's do have kind of they're great

00:50:27,920 --> 00:50:31,940
for small objects they do have great

00:50:29,780 --> 00:50:33,350
advantages so I kind of feel bummed a

00:50:31,940 --> 00:50:35,540
bit that we kind of dwelled on the

00:50:33,350 --> 00:50:41,240
disadvantage so much they're actually

00:50:35,540 --> 00:50:41,740
very fast if you stand right so let's do

00:50:41,240 --> 00:50:45,710
it

00:50:41,740 --> 00:50:48,970
so I'm going to template on our what's

00:50:45,710 --> 00:50:51,740
class a the first template parameter

00:50:48,970 --> 00:50:54,280
it's my parent allocator dialog the

00:50:51,740 --> 00:50:57,590
allocated time I'm sitting on top of

00:50:54,280 --> 00:50:58,760
with my free list right and this is

00:50:57,590 --> 00:51:00,740
generic so it could be any other

00:50:58,760 --> 00:51:04,010
allocator including malloc including a

00:51:00,740 --> 00:51:05,450
stack allocate or whatever right and we

00:51:04,010 --> 00:51:08,000
have a specific size that the list is

00:51:05,450 --> 00:51:09,230
interested in and the allocate function

00:51:08,000 --> 00:51:11,180
actually you can see that cursor if you

00:51:09,230 --> 00:51:13,250
squint really hard it's next to public

00:51:11,180 --> 00:51:15,290
right now you see who's got good eyes

00:51:13,250 --> 00:51:16,520
right so it's next to public right now

00:51:15,290 --> 00:51:19,550
so I'm going to move it slowly and I'm

00:51:16,520 --> 00:51:22,550
going to show you this is allocate um so

00:51:19,550 --> 00:51:24,320
if it just so happens that the size is

00:51:22,550 --> 00:51:26,780
the size I'm interested in and if the

00:51:24,320 --> 00:51:29,420
root is not null then I'm going to be

00:51:26,780 --> 00:51:32,119
able to return the next item in the list

00:51:29,420 --> 00:51:34,490
and this is a really quick operation

00:51:32,119 --> 00:51:36,050
it's all one and slice otherwise I'm

00:51:34,490 --> 00:51:37,840
going to allocate from the parent so

00:51:36,050 --> 00:51:44,690
this is my a location function

00:51:37,840 --> 00:51:47,060
the allocation function is um if well if

00:51:44,690 --> 00:51:48,859
if the length of the block is not my

00:51:47,060 --> 00:51:50,180
interesting size then I'm going to

00:51:48,859 --> 00:51:52,780
delegate from the parent because there's

00:51:50,180 --> 00:51:55,280
nothing to do but otherwise I'm going to

00:51:52,780 --> 00:51:58,070
essentially like do that trigger with

00:51:55,280 --> 00:51:59,210
writing at the in the first word of the

00:51:58,070 --> 00:52:01,160
memory that's being the allocate I'm

00:51:59,210 --> 00:52:02,780
going to write my next node and I'm

00:52:01,160 --> 00:52:05,420
going to maintain the single list are

00:52:02,780 --> 00:52:08,680
singly linked list that way which is

00:52:05,420 --> 00:52:11,480
great again it's a quick operation

00:52:08,680 --> 00:52:13,250
alright so there are few obvious

00:52:11,480 --> 00:52:16,430
improvements to the free list a locator

00:52:13,250 --> 00:52:19,400
such as I want a tolerance between Mir

00:52:16,430 --> 00:52:22,160
maximum for example if my free list is

00:52:19,400 --> 00:52:24,560
very good at allocating one kilobyte one

00:52:22,160 --> 00:52:27,070
kilobyte chunks right and you're asking

00:52:24,560 --> 00:52:31,240
for 900 bytes

00:52:27,070 --> 00:52:33,000
should I give you a little leeway there

00:52:31,240 --> 00:52:34,859
maybe I should write

00:52:33,000 --> 00:52:38,130
so I should have a tolerance I'd you

00:52:34,859 --> 00:52:40,440
know anything between 512 and one

00:52:38,130 --> 00:52:41,880
kilobyte is going to go in the free list

00:52:40,440 --> 00:52:44,940
of one kilobyte and people do that

00:52:41,880 --> 00:52:47,820
actually right so this is great it's

00:52:44,940 --> 00:52:56,690
very easy to add to allocating batches

00:52:47,820 --> 00:52:56,690
what's that idea allocating batches yes

00:53:04,400 --> 00:53:09,960
right so instead of allocating one

00:53:07,580 --> 00:53:11,700
object at a time I allocate a bunch of

00:53:09,960 --> 00:53:14,760
them and I'm threading the frillies

00:53:11,700 --> 00:53:16,050
through them even though it's contiguous

00:53:14,760 --> 00:53:18,119
and then I'm going to have a bunch of

00:53:16,050 --> 00:53:21,030
objects and it's going to cost me a lot

00:53:18,119 --> 00:53:22,590
less what's the problem there it's hard

00:53:21,030 --> 00:53:24,720
to detect when you can be allocated that

00:53:22,590 --> 00:53:27,630
big block right so that's it's kind of

00:53:24,720 --> 00:53:30,030
more difficult and a very interesting

00:53:27,630 --> 00:53:33,119
optimization is at an upper bound no

00:53:30,030 --> 00:53:34,080
more than top elements to the free list

00:53:33,119 --> 00:53:36,780
because you don't want need to grow

00:53:34,080 --> 00:53:38,550
infinitely so this is kind of a very

00:53:36,780 --> 00:53:41,190
good line of defense against that kind

00:53:38,550 --> 00:53:42,420
of free leads that go awry so you can

00:53:41,190 --> 00:53:44,040
say you know what I'm going to fix my

00:53:42,420 --> 00:53:47,040
free list to one thousand elements no

00:53:44,040 --> 00:53:48,780
more 1,024 whatever and then if you go

00:53:47,040 --> 00:53:52,500
beyond that you saturate the free list

00:53:48,780 --> 00:53:55,230
and you're kind of done accumulating in

00:53:52,500 --> 00:54:01,589
it and that works great and it's simple

00:53:55,230 --> 00:54:03,240
to implement okay so with all you know

00:54:01,589 --> 00:54:04,980
with everything that that's being said

00:54:03,240 --> 00:54:07,710
here's what the realistic free list

00:54:04,980 --> 00:54:10,830
looks looks like it has a parent a

00:54:07,710 --> 00:54:13,890
locator it has a minimum size in this

00:54:10,830 --> 00:54:16,080
case 17 it has a maximum size 32 so

00:54:13,890 --> 00:54:18,540
that's my tolerance between 70 and 32

00:54:16,080 --> 00:54:20,460
are going to keep the objects in the

00:54:18,540 --> 00:54:22,260
free list and I'm going to allocate

00:54:20,460 --> 00:54:24,450
eight objects at a time because I saw I

00:54:22,260 --> 00:54:27,300
so can and I'm not going to remember

00:54:24,450 --> 00:54:29,940
more than 1024 one kilobyte element a 1

00:54:27,300 --> 00:54:37,200
kilo element as it were and that's my

00:54:29,940 --> 00:54:40,940
locator ah how do you free the

00:54:37,200 --> 00:54:40,940
individual element in the list

00:54:42,690 --> 00:54:58,630
when you allocate yes oh you put it back

00:54:52,420 --> 00:55:01,540
in the list you're never free it means

00:54:58,630 --> 00:55:06,550
for any requests between 17 and 32 I'm

00:55:01,540 --> 00:55:08,260
going to allocate 32 bytes and okay the

00:55:06,550 --> 00:55:10,750
other upper bound you may be referring

00:55:08,260 --> 00:55:13,320
to is the 1,024 which is the top the

00:55:10,750 --> 00:55:16,510
maximal length of the free list right

00:55:13,320 --> 00:55:18,610
okay so this sort of more realistic free

00:55:16,510 --> 00:55:20,020
list and it's not difficult to import

00:55:18,610 --> 00:55:22,150
it's it's a good chunk of work

00:55:20,020 --> 00:55:24,160
especially this whole allocate at a time

00:55:22,150 --> 00:55:26,380
it's kind of a it's difficult it's not

00:55:24,160 --> 00:55:28,090
easy it's not trivial but it's feasible

00:55:26,380 --> 00:55:30,280
and the nice thing is now you have a

00:55:28,090 --> 00:55:31,600
free list in your hands that you can use

00:55:30,280 --> 00:55:35,410
with any other allocator

00:55:31,600 --> 00:55:39,340
question can i layer a free list on top

00:55:35,410 --> 00:55:41,260
of a stack allocator yes and it's going

00:55:39,340 --> 00:55:43,180
to kind of be in an interesting device

00:55:41,260 --> 00:55:45,940
because it's going to give me the

00:55:43,180 --> 00:55:48,370
ability to free things in the middle of

00:55:45,940 --> 00:55:52,150
the allocator if they are the right size

00:55:48,370 --> 00:55:54,970
so there's the there's compound

00:55:52,150 --> 00:56:00,210
interesting here right I'm gaining

00:55:54,970 --> 00:56:07,480
composition strength here right great

00:56:00,210 --> 00:56:09,010
how about an affix allocator this is an

00:56:07,480 --> 00:56:11,200
absolute classic memory allocation

00:56:09,010 --> 00:56:14,370
whenever you whenever people do a kind

00:56:11,200 --> 00:56:16,690
of advanced allocators they they kind of

00:56:14,370 --> 00:56:19,090
parasite another allocated I kind of add

00:56:16,690 --> 00:56:20,950
a bit of a few bits of data before and

00:56:19,090 --> 00:56:25,060
after the block what's a good use of

00:56:20,950 --> 00:56:27,070
that electric fence like you put like

00:56:25,060 --> 00:56:28,900
you put a signature here put a signature

00:56:27,070 --> 00:56:30,850
here and when I D allocated the

00:56:28,900 --> 00:56:33,100
signatures are not correct

00:56:30,850 --> 00:56:35,740
you kind of say oh there's a corruption

00:56:33,100 --> 00:56:38,140
there right so you can check you can

00:56:35,740 --> 00:56:40,210
instead of like safeguards you can put

00:56:38,140 --> 00:56:43,390
one kilobyte before and one kilobyte

00:56:40,210 --> 00:56:44,650
after large chunks and verify that when

00:56:43,390 --> 00:56:48,640
did the allocate they didn't write to

00:56:44,650 --> 00:56:51,660
those chunks right so people do that so

00:56:48,640 --> 00:56:53,760
you have an alligator that knows how to

00:56:51,660 --> 00:56:55,609
parasite a

00:56:53,760 --> 00:56:59,550
so they're going to sit on top of a and

00:56:55,609 --> 00:57:01,170
they're going to allocate before every

00:56:59,550 --> 00:57:03,720
allocation they're going to put a prefix

00:57:01,170 --> 00:57:05,130
object and at the end of the every

00:57:03,720 --> 00:57:07,200
allocation they're going to put a suffix

00:57:05,130 --> 00:57:10,140
object which by default is void meaning

00:57:07,200 --> 00:57:15,510
nothing and that's a great allocator to

00:57:10,140 --> 00:57:17,670
have as a composition device so you can

00:57:15,510 --> 00:57:19,350
use it for debug stats info actually

00:57:17,670 --> 00:57:25,050
what I've seen people use this for very

00:57:19,350 --> 00:57:27,480
nice is when every allocate memory you

00:57:25,050 --> 00:57:31,010
store in the prefix of the block the

00:57:27,480 --> 00:57:33,240
file and the line that requested memory

00:57:31,010 --> 00:57:35,850
the awesome did you see like Chandler's

00:57:33,240 --> 00:57:38,070
talk this morning right the plenary talk

00:57:35,850 --> 00:57:40,160
that's awesome because it showed all

00:57:38,070 --> 00:57:42,810
these great things with perfect and ooh

00:57:40,160 --> 00:57:44,940
even though people who use OSX they

00:57:42,810 --> 00:57:47,070
don't have it they kind of kind of write

00:57:44,940 --> 00:57:51,480
on Windows I'm sure they have like good

00:57:47,070 --> 00:57:55,380
tools for that yes we work for Microsoft

00:57:51,480 --> 00:57:56,940
oh yes that was an affirmative so

00:57:55,380 --> 00:57:59,100
Michaels are great tools and probably

00:57:56,940 --> 00:58:01,980
they're more visual as well UNIX has

00:57:59,100 --> 00:58:04,950
this perf tool OSX has nothing which is

00:58:01,980 --> 00:58:06,690
a bummer but anyhow do you know all of

00:58:04,950 --> 00:58:09,510
these great things you can see with perf

00:58:06,690 --> 00:58:12,540
you can't see who's asking for memory in

00:58:09,510 --> 00:58:15,869
Perth you can't it's dark matter you

00:58:12,540 --> 00:58:17,460
can't see with this kind of stuff you

00:58:15,869 --> 00:58:19,380
can so you can actually insert you can

00:58:17,460 --> 00:58:21,150
plop the file and line the requested

00:58:19,380 --> 00:58:23,460
memory and then when you free tick oh so

00:58:21,150 --> 00:58:25,880
this guy would this line in the this

00:58:23,460 --> 00:58:28,680
line in my 1 million lines program is

00:58:25,880 --> 00:58:31,020
the top contender for memory allocation

00:58:28,680 --> 00:58:37,950
this is awesome it's great information a

00:58:31,020 --> 00:58:40,260
fix a locator and to wit a very simple

00:58:37,950 --> 00:58:43,440
use of I fix a locator is an alligator

00:58:40,260 --> 00:58:45,060
that collects statistics like pass it

00:58:43,440 --> 00:58:46,680
flat was that this is I'm interested in

00:58:45,060 --> 00:58:48,780
and it's going to collect statistics for

00:58:46,680 --> 00:58:50,310
me so it's going to be how many calls

00:58:48,780 --> 00:58:52,760
that I have to allocate how many calls

00:58:50,310 --> 00:58:56,910
to deallocate and all of these nice

00:58:52,760 --> 00:58:58,500
pieces of information I can have per

00:58:56,910 --> 00:59:00,359
allocation data as we just talked

00:58:58,500 --> 00:59:02,130
I could have global information and I

00:59:00,359 --> 00:59:05,450
can slice and dice it after the program

00:59:02,130 --> 00:59:05,450
has ended any way I want it

00:59:08,360 --> 00:59:14,100
okay how long do we have

00:59:11,240 --> 00:59:16,490
well what happened to the five never

00:59:14,100 --> 00:59:21,660
telling me where were the 15 minutes

00:59:16,490 --> 00:59:24,030
five minutes deal okay the most

00:59:21,660 --> 00:59:26,600
interesting part of this talk you're not

00:59:24,030 --> 00:59:26,600
gonna hear it

00:59:27,410 --> 00:59:32,010
okay thanks five minutes so after this a

00:59:31,500 --> 00:59:35,840
break

00:59:32,010 --> 00:59:38,280
can I eat five minutes into your break

00:59:35,840 --> 00:59:41,070
okay I'm seeing like a couple of folks

00:59:38,280 --> 00:59:43,140
are literally sleeping so I don't you

00:59:41,070 --> 00:59:49,140
know I don't have an opinion you know

00:59:43,140 --> 00:59:51,990
I'm gonna sleep anyway so okay so very

00:59:49,140 --> 00:59:53,010
nice trick and I can't I can't not even

00:59:51,990 --> 00:59:54,960
though I'm not gonna go through the

00:59:53,010 --> 00:59:56,640
slides don't mess up my review because

00:59:54,960 --> 00:59:58,890
this is nice thing even though it's not

00:59:56,640 --> 01:00:01,080
in the slides here's how you can greatly

00:59:58,890 --> 01:00:04,410
collect information about memory

01:00:01,080 --> 01:00:05,970
allocation you write a macro you know

01:00:04,410 --> 01:00:08,160
that's gonna you know allocate with all

01:00:05,970 --> 01:00:11,520
capitals or whatever and inside the

01:00:08,160 --> 01:00:13,530
macro you put static-charge a con star

01:00:11,520 --> 01:00:19,430
star this file

01:00:13,530 --> 01:00:21,930
static unsigned int sorry int long line

01:00:19,430 --> 01:00:24,420
okay I'm trying to be politically

01:00:21,930 --> 01:00:31,620
correct here and then you put a pointer

01:00:24,420 --> 01:00:33,390
next static data okay and then whenever

01:00:31,620 --> 01:00:35,550
you are allocate and stuff you're going

01:00:33,390 --> 01:00:37,050
to update some statistics all of which

01:00:35,550 --> 01:00:39,870
you keep in a static structure this is

01:00:37,050 --> 01:00:43,470
my point is so static but and you have a

01:00:39,870 --> 01:00:46,380
pointer to sort of the next static piece

01:00:43,470 --> 01:00:50,790
of information and here's the thing you

01:00:46,380 --> 01:00:52,860
build up you compile the program and at

01:00:50,790 --> 01:00:55,140
the end of the program essentially have

01:00:52,860 --> 01:00:57,990
file and line information and a singly

01:00:55,140 --> 01:01:00,530
linked list that spans all of these

01:00:57,990 --> 01:01:03,210
places where information has been stored

01:01:00,530 --> 01:01:05,850
which is static data in your program and

01:01:03,210 --> 01:01:10,950
you can iterate it and get information

01:01:05,850 --> 01:01:13,440
with no dynamic allocation at all so

01:01:10,950 --> 01:01:15,360
again just to clarify so actually don't

01:01:13,440 --> 01:01:18,240
say static you define a little struct

01:01:15,360 --> 01:01:20,430
and you make a static instantiation of

01:01:18,240 --> 01:01:21,000
that whenever allocate memory and you

01:01:20,430 --> 01:01:23,580
collect in

01:01:21,000 --> 01:01:26,040
in there and these guys are going to

01:01:23,580 --> 01:01:27,660
assemble in a singly linked list and the

01:01:26,040 --> 01:01:30,570
whole thing pointers and everything they

01:01:27,660 --> 01:01:33,090
all point in static storage and without

01:01:30,570 --> 01:01:35,220
allocating one byte of memory of memory

01:01:33,090 --> 01:01:36,870
dynamically you collect at the end of

01:01:35,220 --> 01:01:39,330
the run we have a pointer to the being

01:01:36,870 --> 01:01:41,070
of the list and you thread you have all

01:01:39,330 --> 01:01:42,590
of your data right me male if you want

01:01:41,070 --> 01:01:49,890
details about this because it's awesome

01:01:42,590 --> 01:01:50,310
okay so now how many minutes 10 okay all

01:01:49,890 --> 01:01:52,770
right

01:01:50,310 --> 01:01:54,810
bitmap block this is a very good

01:01:52,770 --> 01:01:57,030
allocator because it stores one byte per

01:01:54,810 --> 01:02:00,090
block the one bit per block of

01:01:57,030 --> 01:02:02,250
information so have a hunk of memory and

01:02:00,090 --> 01:02:05,670
you say I'm going to organizing this guy

01:02:02,250 --> 01:02:07,170
in blocks of 64 bytes for every 64 bytes

01:02:05,670 --> 01:02:10,500
you're going to have at the beginning of

01:02:07,170 --> 01:02:12,630
the block one bit which tells you

01:02:10,500 --> 01:02:15,720
whether the block is occupied or not

01:02:12,630 --> 01:02:17,400
they have metadata one bit per block and

01:02:15,720 --> 01:02:20,640
then you have the blocks contiguous

01:02:17,400 --> 01:02:26,220
right what's the great advantage of the

01:02:20,640 --> 01:02:28,200
scheme yes get rid of all the

01:02:26,220 --> 01:02:29,610
disadvantage of free lists you can you

01:02:28,200 --> 01:02:32,610
know it can allocate any size because

01:02:29,610 --> 01:02:34,710
the arcade several blocks you store the

01:02:32,610 --> 01:02:37,800
metadata in a separate place which is

01:02:34,710 --> 01:02:39,960
always going to be hot this is a recipe

01:02:37,800 --> 01:02:44,090
for great things in memory allocation

01:02:39,960 --> 01:02:46,590
store metadata elsewhere than the data

01:02:44,090 --> 01:02:49,500
so you have the bits and there's bit

01:02:46,590 --> 01:02:51,600
operate like CPU constructors have been

01:02:49,500 --> 01:02:53,610
working hard on bit operations that are

01:02:51,600 --> 01:02:56,520
fast and you can do like sim D and all

01:02:53,610 --> 01:02:59,580
these good things on the bits there so

01:02:56,520 --> 01:03:00,810
it's pretty awesome so this I highly

01:02:59,580 --> 01:03:02,490
recommend this what are the

01:03:00,810 --> 01:03:07,370
disadvantages because there's never like

01:03:02,490 --> 01:03:10,290
only advantages these advantages huh

01:03:07,370 --> 01:03:12,570
yeah so you the block size is going to

01:03:10,290 --> 01:03:13,860
be like a sort of a he's gonna have

01:03:12,570 --> 01:03:15,450
internal fragmentation right it's going

01:03:13,860 --> 01:03:18,090
to allocate more than needed right

01:03:15,450 --> 01:03:21,290
because of that so um there's never a

01:03:18,090 --> 01:03:24,600
thing with only advantages right and

01:03:21,290 --> 01:03:26,070
also like multi-threading is weird you

01:03:24,600 --> 01:03:27,690
can't really add those bits are kind of

01:03:26,070 --> 01:03:29,280
messed up if you try to share like

01:03:27,690 --> 01:03:34,220
there's all the staring and stuff going

01:03:29,280 --> 01:03:34,220
on so anyhow I highly recommend this

01:03:34,819 --> 01:03:41,449
and there are a few more exotic

01:03:36,650 --> 01:03:46,900
alligators which I think I think you

01:03:41,449 --> 01:03:46,900
know like so cascading allocator

01:03:47,469 --> 01:03:52,009
consider I have a bitmap block but the

01:03:50,029 --> 01:03:54,979
big mailboxes sits on top of like one

01:03:52,009 --> 01:03:56,630
megabyte block so I allocate one

01:03:54,979 --> 01:03:58,849
megabyte and I'm sitting I'm I'm

01:03:56,630 --> 01:04:00,319
plopping a bit one of these guys on it

01:03:58,849 --> 01:04:03,229
and it knows how to organize that that

01:04:00,319 --> 01:04:05,299
megabyte but then I'm running out of

01:04:03,229 --> 01:04:08,019
them I'm done I'm allocating more than

01:04:05,299 --> 01:04:10,489
one megabyte what should I do next

01:04:08,019 --> 01:04:12,619
allocate another megabyte and organize

01:04:10,489 --> 01:04:15,349
that guy as a bitmap block and continue

01:04:12,619 --> 01:04:17,599
this is the cascading allocator it's

01:04:15,349 --> 01:04:21,559
going to allocate lazily as many as you

01:04:17,599 --> 01:04:23,509
need right and it's going to cleverly

01:04:21,559 --> 01:04:25,459
deallocate when you no longer use them

01:04:23,509 --> 01:04:28,599
and there's a fair amount of logical in

01:04:25,459 --> 01:04:34,669
there but it's very it's very coherent

01:04:28,599 --> 01:04:40,459
not difficult to do another very useful

01:04:34,669 --> 01:04:44,769
allocator is the segregate err what does

01:04:40,459 --> 01:04:44,769
he do quick without with zero minutes

01:04:48,579 --> 01:04:57,319
what Purdue said that thanks Marshall

01:04:54,289 --> 01:04:59,059
Marshall so we should you guys can't

01:04:57,319 --> 01:05:02,809
have Marshall answer every question here

01:04:59,059 --> 01:05:04,309
so everything less than or equal to the

01:05:02,809 --> 01:05:05,809
threshold goes to a small alligator

01:05:04,309 --> 01:05:08,929
everything greater than the threshold

01:05:05,809 --> 01:05:12,859
goes to large alligator period done any

01:05:08,929 --> 01:05:15,289
Jolla Gators will work awesome this is

01:05:12,859 --> 01:05:17,269
composition for you and these are each

01:05:15,289 --> 01:05:19,729
they take like 50 lines each maximum

01:05:17,269 --> 01:05:21,619
except for a heap data that bit block

01:05:19,729 --> 01:05:24,259
thing is like much bigger but these are

01:05:21,619 --> 01:05:27,650
simple and then you compose them in ways

01:05:24,259 --> 01:05:29,209
that you couldn't imagine so with this

01:05:27,650 --> 01:05:30,589
guy this is like an absolute classic

01:05:29,209 --> 01:05:32,539
memory allocation I have a small I'll

01:05:30,589 --> 01:05:34,249
just go for this this alligator blood

01:05:32,539 --> 01:05:38,900
jobs go to this guy and this is how the

01:05:34,249 --> 01:05:41,029
history writes itself right so these are

01:05:38,900 --> 01:05:44,269
very good do I need bones for

01:05:41,029 --> 01:05:46,849
implementing this guy no because the

01:05:44,269 --> 01:05:48,140
size tell me everything size tells me

01:05:46,849 --> 01:05:50,830
what I need to do

01:05:48,140 --> 01:05:53,120
it goes right so no problem there

01:05:50,830 --> 01:05:55,610
segregated is self composable you can

01:05:53,120 --> 01:05:58,940
compose with itself with another

01:05:55,610 --> 01:06:01,010
segregate ur and here's how it goes I

01:05:58,940 --> 01:06:03,140
have a segregate everything smaller than

01:06:01,010 --> 01:06:06,230
four kilobytes goes to another segregate

01:06:03,140 --> 01:06:08,200
err which in turn uses a free list for

01:06:06,230 --> 01:06:11,000
everything's more than 128 bytes and

01:06:08,200 --> 01:06:13,370
some medium allocator that I so define

01:06:11,000 --> 01:06:16,340
or everything bigger than four kilobytes

01:06:13,370 --> 01:06:18,140
goes to the Mallo cater in fact if you

01:06:16,340 --> 01:06:21,470
compose actually a good allocate is

01:06:18,140 --> 01:06:23,120
maybe 16 of these aggregators and you

01:06:21,470 --> 01:06:25,130
know how you organize them you're gonna

01:06:23,120 --> 01:06:27,230
is like in a binary tree binary search

01:06:25,130 --> 01:06:29,330
kind of thing you don't surface linearly

01:06:27,230 --> 01:06:32,390
for size you're clever about it you put

01:06:29,330 --> 01:06:36,140
that you know you layout the code by the

01:06:32,390 --> 01:06:37,880
binary search so you look at the code

01:06:36,140 --> 01:06:40,790
then you see oh this is this is

01:06:37,880 --> 01:06:43,310
optimized for these sizes right and

01:06:40,790 --> 01:06:45,080
actually that so there's more philosophy

01:06:43,310 --> 01:06:47,060
to this sometimes you do want the linear

01:06:45,080 --> 01:06:49,820
search because the smaller sizes are

01:06:47,060 --> 01:06:51,800
both more frequent and they're also like

01:06:49,820 --> 01:06:53,030
it's you know if you allocate a big

01:06:51,800 --> 01:06:55,700
chunk of memory you're going to do a lot

01:06:53,030 --> 01:06:57,920
of work with it so you can afford to be

01:06:55,700 --> 01:06:59,630
slower so there's a lot of philosophy

01:06:57,920 --> 01:07:01,550
that goes in there but it's up to you

01:06:59,630 --> 01:07:06,380
that's what I'm giving you the tools you

01:07:01,550 --> 01:07:07,460
use them bucket Iser and probably this

01:07:06,380 --> 01:07:10,940
is the last one that we're going to talk

01:07:07,460 --> 01:07:14,920
about what's the bucket Iser do just by

01:07:10,940 --> 01:07:17,780
looking at the definition bucket Iser

01:07:14,920 --> 01:07:22,040
I'm organizing yeah I use the buckets

01:07:17,780 --> 01:07:25,610
yes thank you very much all right

01:07:22,040 --> 01:07:28,580
so between sizes minimum maximum known

01:07:25,610 --> 01:07:31,340
at camp during compilation I with a

01:07:28,580 --> 01:07:33,380
specific step I'm going to for each

01:07:31,340 --> 01:07:36,560
category of size I'm going to have a

01:07:33,380 --> 01:07:38,930
separate elevator right so I'm bucket

01:07:36,560 --> 01:07:44,590
izing the space the size spectrum

01:07:38,930 --> 01:07:48,320
they're very useful this is actually a

01:07:44,590 --> 01:07:50,150
very simple optimization a very simple

01:07:48,320 --> 01:07:53,350
version of the bucket eyes is one that

01:07:50,150 --> 01:07:55,400
does logarithmic growth this linear

01:07:53,350 --> 01:07:56,780
logarithmic everything like the first

01:07:55,400 --> 01:07:57,910
power of two second power of two and so

01:07:56,780 --> 01:08:00,800
on right

01:07:57,910 --> 01:08:02,240
all right with this we're done friends

01:08:00,800 --> 01:08:04,490
because

01:08:02,240 --> 01:08:06,200
most everything you see about memory

01:08:04,490 --> 01:08:11,480
allocation is covered by these simple

01:08:06,200 --> 01:08:13,280
patterns almost everything I'm not

01:08:11,480 --> 01:08:16,219
kidding so this kind of we're done with

01:08:13,280 --> 01:08:18,920
the subject which is very cheesy because

01:08:16,219 --> 01:08:21,200
we didn't do a lot of work and you know

01:08:18,920 --> 01:08:22,969
we like being lazy like you know filler

01:08:21,200 --> 01:08:26,299
said why don't you do it lazily yes

01:08:22,969 --> 01:08:28,400
let's be lazy all the way right so we're

01:08:26,299 --> 01:08:31,730
kind of done here with the domain of

01:08:28,400 --> 01:08:34,759
memory allocation with remarkably little

01:08:31,730 --> 01:08:36,710
code and remarkably little smarts we

01:08:34,759 --> 01:08:42,049
just wanted to do composition and we

01:08:36,710 --> 01:08:45,770
followed the thread so let me tell you a

01:08:42,049 --> 01:08:47,690
bit more about the entire this is a

01:08:45,770 --> 01:08:49,580
realistic example by the way so as I

01:08:47,690 --> 01:08:50,839
said you know this realistic alga is

01:08:49,580 --> 01:08:55,130
going to have a bunch of these

01:08:50,839 --> 01:08:57,969
strategies composed together but let me

01:08:55,130 --> 01:09:00,950
give you the complete API just a minute

01:08:57,969 --> 01:09:02,839
so this type here that I found works for

01:09:00,950 --> 01:09:05,870
everything we talked about and more

01:09:02,839 --> 01:09:08,150
actually so we have a steady cost expert

01:09:05,870 --> 01:09:12,680
this is a my alignment via alignment of

01:09:08,150 --> 01:09:15,680
the allocator we have a primitive called

01:09:12,680 --> 01:09:17,810
good size which I give you a number and

01:09:15,680 --> 01:09:19,759
you give me the size that you are going

01:09:17,810 --> 01:09:22,089
to allocate anyway usually the number

01:09:19,759 --> 01:09:24,799
rounded up to the next allocation size

01:09:22,089 --> 01:09:27,170
very useful because I can actually when

01:09:24,799 --> 01:09:28,670
you do vector stuff you can say oh let

01:09:27,170 --> 01:09:30,799
me allocate the good size for this guy

01:09:28,670 --> 01:09:33,950
anyway so I can maximize my use of

01:09:30,799 --> 01:09:36,529
memory right so I have good size very

01:09:33,950 --> 01:09:38,930
useful primitive we have the allocate

01:09:36,529 --> 01:09:40,940
and we have the allocate primitive we

01:09:38,930 --> 01:09:44,000
have an new primitive called allocate

01:09:40,940 --> 01:09:47,770
all which is great for stack allocated

01:09:44,000 --> 01:09:47,770
yeah you don't use that with malloc

01:09:48,480 --> 01:09:51,930
actually the malachite that doesn't soup

01:09:50,430 --> 01:09:55,020
doesn't implement it doesn't define it

01:09:51,930 --> 01:09:56,580
right it's not there but with a stack

01:09:55,020 --> 01:09:58,110
earlier you can say allocate all and

01:09:56,580 --> 01:10:01,560
then organize the free list or whatever

01:09:58,110 --> 01:10:03,960
on top of it expand I want to expand the

01:10:01,560 --> 01:10:06,960
block in place reallocate I want to do

01:10:03,960 --> 01:10:09,120
what we Alec does on so we talked about

01:10:06,960 --> 01:10:12,450
it the allocate obvious the allocate all

01:10:09,120 --> 01:10:17,760
which is like allocate everything in all

01:10:12,450 --> 01:10:20,700
one we that's the line one thing you got

01:10:17,760 --> 01:10:23,550
to do it people do that it you need it

01:10:20,700 --> 01:10:27,030
for games who doesn't play games right

01:10:23,550 --> 01:10:29,400
yes so you gotta have aligned allocate

01:10:27,030 --> 01:10:33,330
so therefore it's in the API it's a

01:10:29,400 --> 01:10:35,640
necessary evil people need that you have

01:10:33,330 --> 01:10:37,020
Alan you have primitives on posts and

01:10:35,640 --> 01:10:43,920
windows you just wrap them and you're

01:10:37,020 --> 01:10:46,860
done finally getting their reward okay

01:10:43,920 --> 01:10:49,170
doesn't want to go forward all right so

01:10:46,860 --> 01:10:50,840
what we talked about here so first of

01:10:49,170 --> 01:10:53,940
all we destroy it's the delegator

01:10:50,840 --> 01:10:56,190
because it doesn't composition whatever

01:10:53,940 --> 01:11:00,410
you do it has it knows nothing about

01:10:56,190 --> 01:11:02,430
composition right and as I argued

01:11:00,410 --> 01:11:04,950
composition is everything you should

01:11:02,430 --> 01:11:06,989
care about in memory allocation writing

01:11:04,950 --> 01:11:11,310
good allocators is all about good

01:11:06,989 --> 01:11:13,110
composition okay so fresh approach from

01:11:11,310 --> 01:11:16,110
first principle would be to design an

01:11:13,110 --> 01:11:19,739
API for composable allocators that are

01:11:16,110 --> 01:11:22,830
simple and work together well in any way

01:11:19,739 --> 01:11:24,750
you want with what you saw you can

01:11:22,830 --> 01:11:27,540
implement pretty much any we can you can

01:11:24,750 --> 01:11:29,580
do anything with regard to memory

01:11:27,540 --> 01:11:31,920
allocation you can fly right so don't

01:11:29,580 --> 01:11:34,350
try at home right you know there's a

01:11:31,920 --> 01:11:37,050
professional driver close core said in

01:11:34,350 --> 01:11:39,960
commercials right you can't do anything

01:11:37,050 --> 01:11:41,670
really so understanding history is great

01:11:39,960 --> 01:11:45,420
because I couldn't figure out why a

01:11:41,670 --> 01:11:49,710
locator was a fail until I understood

01:11:45,420 --> 01:11:51,120
its history because you look at it has a

01:11:49,710 --> 01:11:55,080
low key has the allocate has constructed

01:11:51,120 --> 01:11:57,510
destroy it has everything and it was

01:11:55,080 --> 01:12:00,270
difficult for me to get away from the

01:11:57,510 --> 01:12:01,910
frame of mind in which it exists

01:12:00,270 --> 01:12:04,170
therefore it must be good

01:12:01,910 --> 01:12:07,170
to the point where you know this may be

01:12:04,170 --> 01:12:09,390
a mistake and let me see if I kind of

01:12:07,170 --> 01:12:10,500
clean my mind off of everything let me

01:12:09,390 --> 01:12:15,530
see if I can do better

01:12:10,500 --> 01:12:17,520
right and better me is composable okay

01:12:15,530 --> 01:12:18,900
with this I'm seeing people are like

01:12:17,520 --> 01:12:20,250
okay the hell with it I'm going so

01:12:18,900 --> 01:12:23,150
thanks very much

01:12:20,250 --> 01:12:23,150

YouTube URL: https://www.youtube.com/watch?v=LIb3L4vKZ7U


