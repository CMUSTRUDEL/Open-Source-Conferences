Title: CppCon 2015: David Sankel “Functional Design Explained”
Publication date: 2015-10-12
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
An oft-cited benefit of learning a functional language is that it changes one's approach to solving problems for the better. The functional approach has such a strict emphasis on simplistic and highly composable solutions that an otherwise varied landscape of solution possibilities narrows down to only a few novel options.

This talk introduces functional design and showcases its application to several real-world problems. It will briefly cover denotational semantics and several math-based programming abstractions. Finally, the talk will conclude with a comparison of functional solutions to the results more traditional design methodologies.

No prior knowledge of functional programming or functional programming languages is required for this talk. All the examples make use of the C++ programming language.
— 
David Sankel is a professional software developer/architect based in the USA. His prolific software developments have included CAD/CAM, computer graphics, visual programming languages, web applications, computer vision, and cryptography. He is a frequent speaker at the C++Now! conferences and is especially well known for his advanced functional programming in C++ talks.

David's current research interests include dependently typed languages, semantic domains, EDSLs, and functional reactive programming. He currently works for the software firm, Stellar Science.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,279
all right so my name is David's ankle

00:00:03,000 --> 00:00:08,220
I'm a software developer Software

00:00:05,279 --> 00:00:10,380
Architect at stellar science and we're

00:00:08,220 --> 00:00:12,300
gonna talk about functional design so

00:00:10,380 --> 00:00:14,250
before we get into like what that is I

00:00:12,300 --> 00:00:16,170
just want a show of hands for those of

00:00:14,250 --> 00:00:19,260
you who've ever worked on a code base

00:00:16,170 --> 00:00:20,369
and you've had this you know hairy code

00:00:19,260 --> 00:00:23,490
that you're working with and you have

00:00:20,369 --> 00:00:25,590
this AHA insight and you simplify your

00:00:23,490 --> 00:00:27,869
code by figuring out like one particular

00:00:25,590 --> 00:00:30,689
function or one for two particular piece

00:00:27,869 --> 00:00:32,969
and you take these huge swaths of code

00:00:30,689 --> 00:00:34,440
and they become tiny little pieces just

00:00:32,969 --> 00:00:35,460
composing this little piece that you've

00:00:34,440 --> 00:00:38,309
created so how many of you guys have

00:00:35,460 --> 00:00:41,670
come across that scenario right okay

00:00:38,309 --> 00:00:43,980
almost everybody and this is really the

00:00:41,670 --> 00:00:46,050
idea behind functional design as we're

00:00:43,980 --> 00:00:47,960
going after these aha moments we're

00:00:46,050 --> 00:00:50,850
trying to find these extremely small

00:00:47,960 --> 00:00:52,199
composable powerful pieces that we can

00:00:50,850 --> 00:00:55,289
put together to make our software

00:00:52,199 --> 00:00:57,539
components and usually when you do this

00:00:55,289 --> 00:00:58,859
you know a normal programmer who is not

00:00:57,539 --> 00:01:00,210
familiar with functional design you just

00:00:58,859 --> 00:01:01,530
kind of like discover these things in

00:01:00,210 --> 00:01:02,940
practice but when you're doing

00:01:01,530 --> 00:01:09,320
functional design you're actually trying

00:01:02,940 --> 00:01:12,060
to find them directly so let's see here

00:01:09,320 --> 00:01:13,470
so just to kind of like put where this

00:01:12,060 --> 00:01:15,180
is in context of things I love putting

00:01:13,470 --> 00:01:16,259
up these two circles so we have one

00:01:15,180 --> 00:01:18,330
circle over here which is the

00:01:16,259 --> 00:01:20,070
engineering circle people who are

00:01:18,330 --> 00:01:22,619
engineers they are trying to solve real

00:01:20,070 --> 00:01:23,159
world problems right they have a problem

00:01:22,619 --> 00:01:24,810
to solve

00:01:23,159 --> 00:01:26,820
where's in the mathematical more

00:01:24,810 --> 00:01:28,979
theoretical circle you find people that

00:01:26,820 --> 00:01:31,250
are just trying to do interesting things

00:01:28,979 --> 00:01:34,259
trying to push the limits of knowledge

00:01:31,250 --> 00:01:36,540
but these two branches kind of intersect

00:01:34,259 --> 00:01:39,560
in the middle and for example an example

00:01:36,540 --> 00:01:42,000
this intersection here would be

00:01:39,560 --> 00:01:43,740
asymptotics you know run time that's a

00:01:42,000 --> 00:01:45,750
real pure math you type thing you know

00:01:43,740 --> 00:01:47,520
Big O notation and such but it's

00:01:45,750 --> 00:01:49,560
extremely practical practical when

00:01:47,520 --> 00:01:50,880
you're trying to solve a problem but

00:01:49,560 --> 00:01:51,840
there are other things and that are out

00:01:50,880 --> 00:01:53,759
there and math and they just don't

00:01:51,840 --> 00:01:56,369
really have a use for it yet so what I

00:01:53,759 --> 00:01:58,320
try to do is I'm trying to explore put

00:01:56,369 --> 00:02:01,259
more math into the practical engineering

00:01:58,320 --> 00:02:02,729
or engineering to subsume or math so

00:02:01,259 --> 00:02:04,740
that we can you know take advantage of

00:02:02,729 --> 00:02:05,880
some of these theoretical concepts and

00:02:04,740 --> 00:02:07,259
we're gonna really build up to

00:02:05,880 --> 00:02:09,030
functional design so it's not going to

00:02:07,259 --> 00:02:10,619
be I'm not going to give you the formula

00:02:09,030 --> 00:02:12,450
from the get-go will kind of build an

00:02:10,619 --> 00:02:13,560
intuition as we get there so here's a

00:02:12,450 --> 00:02:15,030
quiz and just

00:02:13,560 --> 00:02:16,590
shout out the answer you know do you

00:02:15,030 --> 00:02:21,930
think that the following two C++

00:02:16,590 --> 00:02:25,410
programs are the same okay there was

00:02:21,930 --> 00:02:26,520
some know some yeses now now look these

00:02:25,410 --> 00:02:28,500
two things could be in completely

00:02:26,520 --> 00:02:30,030
separate files right you know there is a

00:02:28,500 --> 00:02:32,300
difference between them well they're in

00:02:30,030 --> 00:02:34,170
two different squares here but

00:02:32,300 --> 00:02:35,489
fundamentally there's nothing in these

00:02:34,170 --> 00:02:37,349
programs we can say that they're the

00:02:35,489 --> 00:02:39,480
same if I write these out to disk and I

00:02:37,349 --> 00:02:42,239
use the diff program it's going to say

00:02:39,480 --> 00:02:44,220
hey these two things are the same right

00:02:42,239 --> 00:02:45,300
assuming that there's not spaces and one

00:02:44,220 --> 00:02:47,430
and not in the other or something along

00:02:45,300 --> 00:02:48,660
that line but anyway so we're trying to

00:02:47,430 --> 00:02:49,980
build this idea of sameness so we'd

00:02:48,660 --> 00:02:53,340
agree that this is the same for the most

00:02:49,980 --> 00:02:54,840
part what about these two programs what

00:02:53,340 --> 00:02:59,459
do you think are these the same program

00:02:54,840 --> 00:03:03,569
I heard a yes anybody think they're not

00:02:59,459 --> 00:03:05,519
the same program it depends and it does

00:03:03,569 --> 00:03:08,130
the pen it depends on what the meaning

00:03:05,519 --> 00:03:09,720
is of the sameness right and we're

00:03:08,130 --> 00:03:11,069
trying to build an intuition here so

00:03:09,720 --> 00:03:12,420
these things are not that if use the

00:03:11,069 --> 00:03:14,220
diff program they're gonna say these are

00:03:12,420 --> 00:03:17,130
not the same right there's extra spaces

00:03:14,220 --> 00:03:19,200
in one but syntax wise if you build a

00:03:17,130 --> 00:03:19,799
syntax tree for these two things they're

00:03:19,200 --> 00:03:23,880
identical

00:03:19,799 --> 00:03:27,209
there's syntactically equivalent so what

00:03:23,880 --> 00:03:29,100
about these two programs here we got a

00:03:27,209 --> 00:03:30,120
program written in Python and for those

00:03:29,100 --> 00:03:34,019
of you who aren't familiar with Python

00:03:30,120 --> 00:03:35,519
all three of you in here that if when

00:03:34,019 --> 00:03:37,650
you print something it automatically

00:03:35,519 --> 00:03:39,709
appends the new line so are these two

00:03:37,650 --> 00:03:42,150
programs the same what do you think

00:03:39,709 --> 00:03:43,260
okay good great so we had somebody say

00:03:42,150 --> 00:03:45,540
that this is this they have the same

00:03:43,260 --> 00:03:45,959
output sort of the same okay and that's

00:03:45,540 --> 00:03:47,579
good

00:03:45,959 --> 00:03:48,870
so these guys so we're building this

00:03:47,579 --> 00:03:51,630
idea we can even talk about the

00:03:48,870 --> 00:03:52,859
equivalence of programs if they're

00:03:51,630 --> 00:03:54,540
written in different languages and one

00:03:52,859 --> 00:03:56,040
criteria could be that that they have

00:03:54,540 --> 00:03:58,290
the same output but is that good enough

00:03:56,040 --> 00:04:01,470
for us what about these two programs

00:03:58,290 --> 00:04:07,739
there's no output are these two programs

00:04:01,470 --> 00:04:10,230
the same the shout it out real loud yes

00:04:07,739 --> 00:04:12,420
yes they are the same there is there is

00:04:10,230 --> 00:04:14,819
an idea of these being the same because

00:04:12,420 --> 00:04:18,570
you know for every input they're gonna

00:04:14,819 --> 00:04:21,090
have the same output okay so how can we

00:04:18,570 --> 00:04:21,930
formalize this because you know we can

00:04:21,090 --> 00:04:23,250
come up with a bunch of different

00:04:21,930 --> 00:04:26,400
situations they have the same output

00:04:23,250 --> 00:04:27,210
they have the same functions but we

00:04:26,400 --> 00:04:29,639
would like to get

00:04:27,210 --> 00:04:31,710
idea of you know what is the essence of

00:04:29,639 --> 00:04:33,569
a program and how can we talk about

00:04:31,710 --> 00:04:35,430
programs being the same as each other so

00:04:33,569 --> 00:04:38,580
here are some properties we'd like to

00:04:35,430 --> 00:04:41,370
have we would like whatever our essence

00:04:38,580 --> 00:04:43,259
is to have strong equivalence properties

00:04:41,370 --> 00:04:44,759
so we can say this is the same as this

00:04:43,259 --> 00:04:47,460
or this is different than this because

00:04:44,759 --> 00:04:49,590
without this we're not really talking

00:04:47,460 --> 00:04:50,910
about same loop sameness so we need

00:04:49,590 --> 00:04:52,919
strong equivalence properties we want

00:04:50,910 --> 00:04:54,960
something that we can write down when we

00:04:52,919 --> 00:04:56,729
talk about the essence of a program so

00:04:54,960 --> 00:04:58,770
if I'm talking to a programmer and they

00:04:56,729 --> 00:05:00,509
say well in my head they're the same and

00:04:58,770 --> 00:05:01,650
I say in my head they're different if we

00:05:00,509 --> 00:05:03,509
don't have a way to resolve our

00:05:01,650 --> 00:05:04,440
difficulties then we're kind of stuck so

00:05:03,509 --> 00:05:06,419
we'd like to have something we can

00:05:04,440 --> 00:05:09,690
communicate with each other about the

00:05:06,419 --> 00:05:10,620
essence of a program and finally we

00:05:09,690 --> 00:05:13,620
would like to be able to take any

00:05:10,620 --> 00:05:16,610
program apply a set of rules and reach

00:05:13,620 --> 00:05:19,169
the essence of what the program is so

00:05:16,610 --> 00:05:22,320
just go ahead and think about what what

00:05:19,169 --> 00:05:24,840
kind of language we could use to get the

00:05:22,320 --> 00:05:38,669
essence of a program anybody have an

00:05:24,840 --> 00:05:40,139
idea so the comment is we can use

00:05:38,669 --> 00:05:41,460
functions and yeah and that's part of

00:05:40,139 --> 00:05:44,570
that's only going to get us a subset of

00:05:41,460 --> 00:05:47,849
the way but like going even more basic

00:05:44,570 --> 00:05:49,110
mathematics exactly so here we have

00:05:47,849 --> 00:05:50,460
strong equivalence properties in

00:05:49,110 --> 00:05:53,310
mathematics you learn in grade school

00:05:50,460 --> 00:05:56,130
three plus two is equal to five right

00:05:53,310 --> 00:05:58,229
they're the same thing it's just another

00:05:56,130 --> 00:06:04,139
way of writing five and five equals

00:05:58,229 --> 00:06:09,270
three plus two so this idea is a very

00:06:04,139 --> 00:06:11,639
old idea is to take mathematics and map

00:06:09,270 --> 00:06:13,490
your syntax to mathematics and this is

00:06:11,639 --> 00:06:16,259
from Dana Scott and Christopher Stracci

00:06:13,490 --> 00:06:20,610
and here's an example of how they do

00:06:16,259 --> 00:06:22,530
this you have this function mu which new

00:06:20,610 --> 00:06:23,969
stands for meaning so the meaning of

00:06:22,530 --> 00:06:26,130
this syntax so when you see the double

00:06:23,969 --> 00:06:28,050
brackets we're talking about syntax is

00:06:26,130 --> 00:06:30,060
equal to now on the right hand side

00:06:28,050 --> 00:06:31,949
we're talking math the meaning of this

00:06:30,060 --> 00:06:34,020
expression plus the meaning of that

00:06:31,949 --> 00:06:36,510
expression so the plus on the left is a

00:06:34,020 --> 00:06:38,849
syntax plus the plus on the right is a

00:06:36,510 --> 00:06:40,740
pure math plus and then the meaning of I

00:06:38,849 --> 00:06:43,770
where I is some integer like

00:06:40,740 --> 00:06:46,530
one-zero in syntax the meaning of that

00:06:43,770 --> 00:06:48,120
is 10 in mathematics so we can start

00:06:46,530 --> 00:06:51,930
building these strong mathematics but

00:06:48,120 --> 00:06:53,190
then we have you know a function and

00:06:51,930 --> 00:06:55,110
what are we gonna say is the meaning of

00:06:53,190 --> 00:06:57,660
a function in mathematics how are we

00:06:55,110 --> 00:07:00,360
going to have a strong equivalence for

00:06:57,660 --> 00:07:02,099
something like this well it's actually

00:07:00,360 --> 00:07:03,720
not really a problem because we can have

00:07:02,099 --> 00:07:08,069
infinite sets so we can say a function

00:07:03,720 --> 00:07:10,440
is just a set of pairs mapping the input

00:07:08,069 --> 00:07:11,699
value to the output value so if we have

00:07:10,440 --> 00:07:13,020
two different functions we can talk

00:07:11,699 --> 00:07:14,490
about their sameness by looking at the

00:07:13,020 --> 00:07:15,930
set of values and you can represent this

00:07:14,490 --> 00:07:18,180
in a few different ways

00:07:15,930 --> 00:07:19,560
there's the lambda know K notation and

00:07:18,180 --> 00:07:21,630
for those of you who are unfamiliar with

00:07:19,560 --> 00:07:24,060
lambdas that lambda see that's kind of

00:07:21,630 --> 00:07:26,069
like a C++ anonymous function with C as

00:07:24,060 --> 00:07:28,590
the input type and mapping that to C

00:07:26,069 --> 00:07:31,050
plus 5 or you know something else like F

00:07:28,590 --> 00:07:32,310
of C equals C plus 5 you know that's

00:07:31,050 --> 00:07:34,319
something you'd see in grade school that

00:07:32,310 --> 00:07:35,849
kind of notation but we do have a way to

00:07:34,319 --> 00:07:40,860
talk about the equivalence of functions

00:07:35,849 --> 00:07:44,639
mathematically but what about this how

00:07:40,860 --> 00:07:47,909
are we going to map this into math well

00:07:44,639 --> 00:07:49,349
it turns out there's a problem there

00:07:47,909 --> 00:07:51,630
isn't a straightforward way to map this

00:07:49,349 --> 00:07:53,610
into math so this is the kind of

00:07:51,630 --> 00:07:54,840
problems that they ran into when they

00:07:53,610 --> 00:07:57,270
were trying to make a mapping from

00:07:54,840 --> 00:07:58,380
programs to their essence in math and

00:07:57,270 --> 00:08:00,389
what they said is well we're going to

00:07:58,380 --> 00:08:05,729
make a new symbol we're gonna call this

00:08:00,389 --> 00:08:09,210
bottom and if it doesn't return we're

00:08:05,729 --> 00:08:10,860
gonna say it returns bottom and just

00:08:09,210 --> 00:08:12,389
like when you work with math and you

00:08:10,860 --> 00:08:13,650
have they first started discovering you

00:08:12,389 --> 00:08:15,270
know Oh what are we gonna do about

00:08:13,650 --> 00:08:17,370
square root of negative one and then we

00:08:15,270 --> 00:08:19,169
get I then you can build a whole algebra

00:08:17,370 --> 00:08:21,389
out of that well the same kind of thing

00:08:19,169 --> 00:08:22,349
with bottom here and you know I'm not

00:08:21,389 --> 00:08:23,940
going to go through all the different

00:08:22,349 --> 00:08:25,979
examples of things that we need to add

00:08:23,940 --> 00:08:28,770
to base mathematics in order to be able

00:08:25,979 --> 00:08:30,840
to grab the essence out of a program but

00:08:28,770 --> 00:08:33,630
just get to give you an idea so that you

00:08:30,840 --> 00:08:34,979
can do this you can extend your math to

00:08:33,630 --> 00:08:39,209
be able to represent the essence of a

00:08:34,979 --> 00:08:43,440
program now here's another idea

00:08:39,209 --> 00:08:46,290
so Landon in 1966 I wrote this

00:08:43,440 --> 00:08:47,579
programming language if you see what I

00:08:46,290 --> 00:08:49,440
mean is what it was called and it was

00:08:47,579 --> 00:08:51,089
just a purely theoretical language it

00:08:49,440 --> 00:08:52,920
was just for the context of the paper

00:08:51,089 --> 00:08:54,210
nobody implemented this and here's an

00:08:52,920 --> 00:08:57,180
example of

00:08:54,210 --> 00:08:58,680
from his paper his big idea wasn't let's

00:08:57,180 --> 00:09:00,720
try to extract the essence out of

00:08:58,680 --> 00:09:02,310
programs into math he just likes math a

00:09:00,720 --> 00:09:04,980
lot and he'd prefer a program in math

00:09:02,310 --> 00:09:07,830
than the program in a language like

00:09:04,980 --> 00:09:09,360
Fortran so does anybody recognize this

00:09:07,830 --> 00:09:10,620
code does this look similar to any kind

00:09:09,360 --> 00:09:13,110
of modern language that you guys know

00:09:10,620 --> 00:09:16,230
about Haskell yes

00:09:13,110 --> 00:09:18,450
so all of the modern functional

00:09:16,230 --> 00:09:20,820
programming languages derived from this

00:09:18,450 --> 00:09:23,610
idea the essence of functional

00:09:20,820 --> 00:09:25,770
programming languages is to program in

00:09:23,610 --> 00:09:29,580
math because math has a lot of neat

00:09:25,770 --> 00:09:31,050
properties so you see this and then ml

00:09:29,580 --> 00:09:32,820
got derive from this and eventually

00:09:31,050 --> 00:09:34,080
Haskell but all modern languages look

00:09:32,820 --> 00:09:40,380
like this because they're trying to copy

00:09:34,080 --> 00:09:41,510
math so great we can program in math why

00:09:40,380 --> 00:09:44,580
are we here

00:09:41,510 --> 00:09:49,440
because if we can just go Haskell then I

00:09:44,580 --> 00:09:52,440
can just stop talking now so here's one

00:09:49,440 --> 00:09:54,000
reason let's say we're doing a quicksort

00:09:52,440 --> 00:09:55,709
on its and if you've looked at Haskell

00:09:54,000 --> 00:09:57,000
at all on the internet you'd see this

00:09:55,709 --> 00:09:59,820
really beautiful quicksort

00:09:57,000 --> 00:10:02,400
implementation it just turns out to be

00:09:59,820 --> 00:10:04,560
four times slower with optimizations

00:10:02,400 --> 00:10:07,830
than the first implementation I can find

00:10:04,560 --> 00:10:10,260
in C++ without optimizations this is a

00:10:07,830 --> 00:10:11,730
problem now you know some people who are

00:10:10,260 --> 00:10:13,230
really good at Haskell to be able to say

00:10:11,730 --> 00:10:15,690
you know you can tweak that you can make

00:10:13,230 --> 00:10:18,209
it on par with C++ and I'd agree you

00:10:15,690 --> 00:10:20,730
probably can but what it ends up looking

00:10:18,209 --> 00:10:22,890
like is your program starts to look more

00:10:20,730 --> 00:10:24,600
and more like an imperative programming

00:10:22,890 --> 00:10:26,040
language and you're defeating the

00:10:24,600 --> 00:10:27,900
purpose of Haskell in the first place

00:10:26,040 --> 00:10:30,470
right if you want a program in math

00:10:27,900 --> 00:10:32,850
programming math if you want to program

00:10:30,470 --> 00:10:34,050
something efficiently you're going to

00:10:32,850 --> 00:10:35,510
have to know a little bit about the

00:10:34,050 --> 00:10:41,190
machine that you're working on and

00:10:35,510 --> 00:10:44,160
program that way so this this graph is a

00:10:41,190 --> 00:10:46,170
graph of abstraction so on the far left

00:10:44,160 --> 00:10:48,779
of the graph you've got that guy over

00:10:46,170 --> 00:10:51,089
there and very low level abstraction so

00:10:48,779 --> 00:10:52,890
he represents assembly language you know

00:10:51,089 --> 00:10:56,730
you can get some stuff done in assembly

00:10:52,890 --> 00:10:58,890
right that guy can you know put a roof

00:10:56,730 --> 00:10:59,760
over his head and hunt and eat but

00:10:58,890 --> 00:11:02,130
you're not gonna expect anything

00:10:59,760 --> 00:11:05,370
extremely interesting about him then on

00:11:02,130 --> 00:11:07,079
the far right side you've got you know

00:11:05,370 --> 00:11:08,179
one of these amazing new programming

00:11:07,079 --> 00:11:11,970
languages

00:11:08,179 --> 00:11:14,339
you know it's esoteric even among the

00:11:11,970 --> 00:11:18,119
Haskell users it's just a crazy language

00:11:14,339 --> 00:11:21,980
that's so intense and neat that nobody

00:11:18,119 --> 00:11:25,170
actually writes real programs in it and

00:11:21,980 --> 00:11:27,119
then to the and then to the left of him

00:11:25,170 --> 00:11:29,100
you've got Haskell right so very high

00:11:27,119 --> 00:11:30,799
levels of abstraction and then who's

00:11:29,100 --> 00:11:35,999
that big guy

00:11:30,799 --> 00:11:38,459
C++ right that guy is able to span the

00:11:35,999 --> 00:11:40,410
low levels of abstraction all the way to

00:11:38,459 --> 00:11:43,019
the extremely high levels of abstraction

00:11:40,410 --> 00:11:45,809
no other language that I know of does

00:11:43,019 --> 00:11:48,149
that so we have on the low level you can

00:11:45,809 --> 00:11:50,369
twiddle bits you can do device drivers

00:11:48,149 --> 00:11:52,230
on the high level you've got template

00:11:50,369 --> 00:11:53,730
metaprogramming which makes extremely

00:11:52,230 --> 00:11:55,889
interesting generic programming and then

00:11:53,730 --> 00:11:57,449
with concepts we get even further but

00:11:55,889 --> 00:11:59,939
basically any kind of abstraction that

00:11:57,449 --> 00:12:02,009
you can do in Haskell without any

00:11:59,939 --> 00:12:04,499
special extensions C++ can do too

00:12:02,009 --> 00:12:05,939
although more verbose that's that's what

00:12:04,499 --> 00:12:08,429
we pay for that functionality that

00:12:05,939 --> 00:12:10,980
feature and then finally we have the

00:12:08,429 --> 00:12:12,540
idea of semantics discovery so this is

00:12:10,980 --> 00:12:14,610
Connell Elliott who you see on the

00:12:12,540 --> 00:12:17,249
screen here and he's a very he's a

00:12:14,610 --> 00:12:19,769
modern proponent of this methodology but

00:12:17,249 --> 00:12:21,839
basically you have a problem and you're

00:12:19,769 --> 00:12:24,660
trying to find out what the problem is

00:12:21,839 --> 00:12:26,459
mathematically so Newton he did this

00:12:24,660 --> 00:12:28,079
right he's trying to figure out gravity

00:12:26,459 --> 00:12:29,699
how do we model gravity what's this

00:12:28,079 --> 00:12:31,980
problem and he had to come up with

00:12:29,699 --> 00:12:34,709
derivatives and integrals in calculus

00:12:31,980 --> 00:12:35,699
all to figure out how to model gravity

00:12:34,709 --> 00:12:39,089
and the different kind of problems that

00:12:35,699 --> 00:12:41,040
he was solving so the idea of of Connell

00:12:39,089 --> 00:12:42,509
here is you take me you try to figure

00:12:41,040 --> 00:12:44,459
out what the essences of your problem

00:12:42,509 --> 00:12:46,319
mathematically and then derive an

00:12:44,459 --> 00:12:48,959
implementation so for him he would write

00:12:46,319 --> 00:12:51,480
his essence into like Haskell based math

00:12:48,959 --> 00:12:54,899
and then try to derive a more efficient

00:12:51,480 --> 00:12:57,089
implementation in Haskell so now we have

00:12:54,899 --> 00:12:59,689
some ingredients here so the idea of

00:12:57,089 --> 00:13:02,669
math augmented with some extra

00:12:59,689 --> 00:13:05,249
constructs can represent the essence of

00:13:02,669 --> 00:13:08,249
code we have the idea of writing

00:13:05,249 --> 00:13:10,319
programs in math we have the idea of C++

00:13:08,249 --> 00:13:11,999
how it straddles all these different

00:13:10,319 --> 00:13:13,949
levels of abstraction and finally we

00:13:11,999 --> 00:13:16,410
have the idea of trying to discover the

00:13:13,949 --> 00:13:19,410
essence of a problem using math and then

00:13:16,410 --> 00:13:21,240
deriving the implementation and that

00:13:19,410 --> 00:13:23,580
leads us to what functional design is

00:13:21,240 --> 00:13:26,370
so the first part of functional design

00:13:23,580 --> 00:13:28,760
is you want to discover the mathematical

00:13:26,370 --> 00:13:31,440
essence of a problem and write it out

00:13:28,760 --> 00:13:33,660
the second part is you derive and

00:13:31,440 --> 00:13:36,630
implement an efficient implementation in

00:13:33,660 --> 00:13:38,279
C++ with the same interface that you

00:13:36,630 --> 00:13:41,450
describe that you discovered in step one

00:13:38,279 --> 00:13:44,190
and if you nail it it works really well

00:13:41,450 --> 00:13:45,240
so we're gonna look at some examples but

00:13:44,190 --> 00:13:48,000
first we need to improve our

00:13:45,240 --> 00:13:50,610
mathematical vocabulary with some new

00:13:48,000 --> 00:13:52,649
things so the first thing we're going to

00:13:50,610 --> 00:13:53,550
talk about is algebraic data types how

00:13:52,649 --> 00:13:56,970
many of you guys are familiar with

00:13:53,550 --> 00:14:00,390
algebraic data types okay so maybe 10%

00:13:56,970 --> 00:14:01,500
of you so I'll go kind of quick actually

00:14:00,390 --> 00:14:06,510
maybe I shouldn't go so quick for the

00:14:01,500 --> 00:14:08,670
90% of you so here's the zero type so

00:14:06,510 --> 00:14:12,390
we're talking about a type it has no

00:14:08,670 --> 00:14:15,180
values here's how you implement that in

00:14:12,390 --> 00:14:16,440
C++ now there's a more theoretical thing

00:14:15,180 --> 00:14:18,149
this doesn't come up very often in

00:14:16,440 --> 00:14:21,990
practice but it's good to know about so

00:14:18,149 --> 00:14:27,209
you cannot make an instance of zero so

00:14:21,990 --> 00:14:28,890
that type has zero instances so can you

00:14:27,209 --> 00:14:34,290
guess how many instances the one type

00:14:28,890 --> 00:14:37,980
has one and here's how you implement the

00:14:34,290 --> 00:14:41,279
one type and C++ you just make any class

00:14:37,980 --> 00:14:42,899
or struct with no members you can make

00:14:41,279 --> 00:14:46,589
an instance of this how many different

00:14:42,899 --> 00:14:48,810
instances are there of this one right so

00:14:46,589 --> 00:14:50,610
that's the one type those are our base

00:14:48,810 --> 00:14:53,990
two things there now we have operations

00:14:50,610 --> 00:14:53,990
to put our different types together

00:15:02,630 --> 00:15:07,410
so the comment was the fact that you can

00:15:05,550 --> 00:15:09,029
only have one instance of it doesn't

00:15:07,410 --> 00:15:10,740
mean that you can only instantiate at

00:15:09,029 --> 00:15:12,209
one time and yeah I think we all

00:15:10,740 --> 00:15:17,360
understand that right we're just saying

00:15:12,209 --> 00:15:17,360
there's one unique value of type one

00:15:17,410 --> 00:15:21,470
and the key there is unique yeah when

00:15:20,390 --> 00:15:22,820
we're talking about sameness when it

00:15:21,470 --> 00:15:24,440
comes to that that's that's what we mean

00:15:22,820 --> 00:15:25,580
look how many different integer bellies

00:15:24,440 --> 00:15:26,750
do you have you know and you can make

00:15:25,580 --> 00:15:28,970
lots of different instances but you're

00:15:26,750 --> 00:15:31,550
gonna have a set range of intz you can

00:15:28,970 --> 00:15:35,120
make on a computer all right so now we

00:15:31,550 --> 00:15:39,440
have the idea of a product so given a

00:15:35,120 --> 00:15:42,170
value types a and B the product of a and

00:15:39,440 --> 00:15:46,340
B is the type who types whose values

00:15:42,170 --> 00:15:48,170
have n a and a B and if you didn't like

00:15:46,340 --> 00:15:50,840
that explanation you'll really like the

00:15:48,170 --> 00:15:55,340
next one because it's simple just a pair

00:15:50,840 --> 00:15:56,990
right a pair has a value of type a and

00:15:55,340 --> 00:15:58,430
the value of type B an instance of a

00:15:56,990 --> 00:16:00,560
pair has a value of type A and a value

00:15:58,430 --> 00:16:02,000
of type B but that's not the only way

00:16:00,560 --> 00:16:05,090
you can represent the product type in

00:16:02,000 --> 00:16:08,810
C++ you know you can use a stood tuple

00:16:05,090 --> 00:16:12,440
it's essentially in essence the same

00:16:08,810 --> 00:16:15,260
thing or you can use a struct now here

00:16:12,440 --> 00:16:17,180
we're naming them but that doesn't make

00:16:15,260 --> 00:16:18,980
any difference to you know to the

00:16:17,180 --> 00:16:22,040
essence of what it is it's still in a

00:16:18,980 --> 00:16:22,940
and a B and when you do your semantics

00:16:22,040 --> 00:16:24,830
like this and you drive your

00:16:22,940 --> 00:16:26,630
implementations you're gonna have lots

00:16:24,830 --> 00:16:28,220
of different options and that's where

00:16:26,630 --> 00:16:30,310
the engineering part of this comes into

00:16:28,220 --> 00:16:30,310
play

00:16:30,580 --> 00:16:37,670
so what about this would this be a

00:16:34,210 --> 00:16:43,450
correct implementation of a product B

00:16:37,670 --> 00:16:43,450
what you guys think no I hear no why not

00:16:51,970 --> 00:17:00,140
okay so there's the got it so the

00:16:57,020 --> 00:17:01,700
comment was that the difference is

00:17:00,140 --> 00:17:03,500
because these have different memory

00:17:01,700 --> 00:17:05,360
locations right one is pointing to a

00:17:03,500 --> 00:17:05,840
piece of memory memory where the other

00:17:05,360 --> 00:17:08,180
one isn't

00:17:05,840 --> 00:17:10,070
but in semantics world memory doesn't

00:17:08,180 --> 00:17:16,910
matter right that's that's an

00:17:10,070 --> 00:17:18,110
implementation detail so okay and then

00:17:16,910 --> 00:17:20,780
there was a comment that it is a product

00:17:18,110 --> 00:17:22,950
type and I think it isn't but for a

00:17:20,780 --> 00:17:25,140
different reason

00:17:22,950 --> 00:17:27,690
because it can be null exactly we're

00:17:25,140 --> 00:17:30,510
introducing an extra state and you got

00:17:27,690 --> 00:17:31,830
to deal with that so the way you can

00:17:30,510 --> 00:17:33,480
deal with that is you can just write a

00:17:31,830 --> 00:17:35,070
little comment next to it saying that

00:17:33,480 --> 00:17:37,650
it's an invariant of this struct that

00:17:35,070 --> 00:17:40,860
these things are not ever null and then

00:17:37,650 --> 00:17:46,200
it models it properly but generally

00:17:40,860 --> 00:17:50,490
that's how it is the comment was a

00:17:46,200 --> 00:17:54,050
pointer to an a is not an a well the

00:17:50,490 --> 00:17:56,700
thing is semantically speaking it is a

00:17:54,050 --> 00:17:59,640
unique pointer in particular right so

00:17:56,700 --> 00:18:01,620
it's only there it's only identified by

00:17:59,640 --> 00:18:03,780
that construct when we map it to a

00:18:01,620 --> 00:18:06,050
mathematical thing the only problem is

00:18:03,780 --> 00:18:10,080
null not the fact that it's a pointer

00:18:06,050 --> 00:18:12,800
all right so the some type this one

00:18:10,080 --> 00:18:15,840
isn't really supported in C++ very well

00:18:12,800 --> 00:18:18,390
but basically you have a discriminated

00:18:15,840 --> 00:18:20,370
Union a some type where's a product type

00:18:18,390 --> 00:18:23,220
you have a value of type a and a value

00:18:20,370 --> 00:18:25,980
of type B with sums you have either a

00:18:23,220 --> 00:18:28,530
value of type a or a value of type B

00:18:25,980 --> 00:18:30,900
it's one or the other and you can

00:18:28,530 --> 00:18:34,050
implement this using something like this

00:18:30,900 --> 00:18:36,240
so we have a little tag here and it

00:18:34,050 --> 00:18:39,830
tells us whether the Union has an A or

00:18:36,240 --> 00:18:42,540
has a B and and you put this little

00:18:39,830 --> 00:18:44,730
invariant saying you know it's a one has

00:18:42,540 --> 00:18:47,250
a equals two otherwise B so that's one

00:18:44,730 --> 00:18:50,310
way to implement that and that's fine

00:18:47,250 --> 00:18:52,980
and dandy is kind of nasty or you can

00:18:50,310 --> 00:18:54,870
use boost variance so a boost variant is

00:18:52,980 --> 00:18:56,520
going to have a value of type a or a

00:18:54,870 --> 00:18:59,190
value of type B and give you a nice

00:18:56,520 --> 00:19:02,930
interface and how many of you guys are

00:18:59,190 --> 00:19:08,220
not using boost shame on you

00:19:02,930 --> 00:19:12,540
use boost just kidding

00:19:08,220 --> 00:19:14,910
no not really all right so we're working

00:19:12,540 --> 00:19:16,530
on having a standard variant and I put

00:19:14,910 --> 00:19:17,880
hopefully that I'll represent because

00:19:16,530 --> 00:19:20,010
there's some discussion as to whether

00:19:17,880 --> 00:19:22,680
they want standard variance to also have

00:19:20,010 --> 00:19:25,920
an automatic empty state and that's a

00:19:22,680 --> 00:19:27,900
very contentious topic right now and I'm

00:19:25,920 --> 00:19:30,710
hoping that it won't have an empty state

00:19:27,900 --> 00:19:33,780
and it'll correctly model the sum type

00:19:30,710 --> 00:19:35,190
okay and so that's our basic algebraic

00:19:33,780 --> 00:19:39,420
data types and now we also have a

00:19:35,190 --> 00:19:41,940
function type and this is pretty easy a

00:19:39,420 --> 00:19:43,920
arrow B that represents a function that

00:19:41,940 --> 00:19:45,660
has an input of type a and an output of

00:19:43,920 --> 00:19:48,720
type B this kind of maps to our

00:19:45,660 --> 00:19:51,330
intuition except for the little point

00:19:48,720 --> 00:19:52,980
here that these are pure functions so

00:19:51,330 --> 00:19:54,810
remember when we looked at a function

00:19:52,980 --> 00:19:56,700
and we try to map it to a set you know a

00:19:54,810 --> 00:19:58,560
pair of different values if your

00:19:56,700 --> 00:20:00,780
function does something strange like

00:19:58,560 --> 00:20:02,940
output or change a global variable or

00:20:00,780 --> 00:20:04,140
the same input can have different

00:20:02,940 --> 00:20:06,240
outputs depending on the state of your

00:20:04,140 --> 00:20:08,220
program it's not pure it's not gonna be

00:20:06,240 --> 00:20:11,460
able to map to that nice mathematical

00:20:08,220 --> 00:20:13,080
representation so we have to be clear

00:20:11,460 --> 00:20:15,240
that when we're talking about a Tero be

00:20:13,080 --> 00:20:19,770
in the mathematical sense that it has to

00:20:15,240 --> 00:20:22,110
be a pure function in the c++ sense all

00:20:19,770 --> 00:20:24,450
right so moving on now we want to talk a

00:20:22,110 --> 00:20:25,980
little bit about meaning so here we have

00:20:24,450 --> 00:20:29,940
that syntax we've got introduced to it

00:20:25,980 --> 00:20:31,890
before so we have mu of this syntax is

00:20:29,940 --> 00:20:35,550
equal to some mathematical expression

00:20:31,890 --> 00:20:36,780
all right the meaning of that syntax is

00:20:35,550 --> 00:20:40,560
equal to this mathematical expression

00:20:36,780 --> 00:20:43,260
and then we have down here when you have

00:20:40,560 --> 00:20:44,910
an expression in C++ there's really two

00:20:43,260 --> 00:20:46,740
things you can say about it right you

00:20:44,910 --> 00:20:48,750
can say what it's type is and you can

00:20:46,740 --> 00:20:50,070
say what its value is so we have to

00:20:48,750 --> 00:20:51,600
distinguish when we write out our

00:20:50,070 --> 00:20:53,400
mathematical expression here so we use

00:20:51,600 --> 00:20:55,290
this colon here to say we're talking

00:20:53,400 --> 00:20:59,010
about what the type of this

00:20:55,290 --> 00:21:00,210
C++ expression is and we use the equal

00:20:59,010 --> 00:21:03,060
sign when we want us to talk about its

00:21:00,210 --> 00:21:06,870
value so in the case of int this isn't a

00:21:03,060 --> 00:21:08,730
C++ expression right this is a type that

00:21:06,870 --> 00:21:11,370
so we use the equal sign to say that

00:21:08,730 --> 00:21:12,900
this is equal to Z so Z is the

00:21:11,370 --> 00:21:14,670
mathematical representation of the

00:21:12,900 --> 00:21:17,310
integers okay so we're saying the

00:21:14,670 --> 00:21:19,170
meaning of int is the integers and then

00:21:17,310 --> 00:21:22,710
the meaning the type of the meaning of

00:21:19,170 --> 00:21:24,330
three is the integers but the value of

00:21:22,710 --> 00:21:27,320
the meaning of three is

00:21:24,330 --> 00:21:31,049
three in the mathematical sense of three

00:21:27,320 --> 00:21:33,840
so looking at some examples here we have

00:21:31,049 --> 00:21:36,149
boost optional of verse e sub one is

00:21:33,840 --> 00:21:39,169
some kind of type expression the meaning

00:21:36,149 --> 00:21:41,850
of the boost optional is the meaning of

00:21:39,169 --> 00:21:47,750
that type so if it's ant it'll be the

00:21:41,850 --> 00:21:50,480
meaning event it'll be Z or the one type

00:21:47,750 --> 00:21:53,730
so an optional is either going to be

00:21:50,480 --> 00:21:55,370
none you know how many different values

00:21:53,730 --> 00:21:57,809
have none are there there's just one

00:21:55,370 --> 00:22:02,399
confusingly enough so it can either be

00:21:57,809 --> 00:22:05,130
the none type or it can be a int so that

00:22:02,399 --> 00:22:06,720
gives us the meaning and mathematical

00:22:05,130 --> 00:22:08,370
form boost optional and you'll see that

00:22:06,720 --> 00:22:10,470
when you take these really useful things

00:22:08,370 --> 00:22:12,000
that are in the C++ language and you try

00:22:10,470 --> 00:22:14,880
to figure out their meaning you end up

00:22:12,000 --> 00:22:16,289
with very simple things and that's what

00:22:14,880 --> 00:22:17,760
we're trying to go for remember getting

00:22:16,289 --> 00:22:19,830
that simple essence of something and

00:22:17,760 --> 00:22:22,679
then if you look at a pair the meaning

00:22:19,830 --> 00:22:25,710
of a pair is the meaning of the first

00:22:22,679 --> 00:22:27,870
type expression product the meaning of

00:22:25,710 --> 00:22:29,190
the second type expression you know this

00:22:27,870 --> 00:22:30,600
is just the reverse of saying that

00:22:29,190 --> 00:22:33,510
products are pairs we're saying pairs or

00:22:30,600 --> 00:22:37,019
products and double can be real numbers

00:22:33,510 --> 00:22:39,000
or maybe you really want to say that the

00:22:37,019 --> 00:22:41,700
meaning of double can be the real number

00:22:39,000 --> 00:22:43,110
is plus these three other states and

00:22:41,700 --> 00:22:45,360
these three other states would be

00:22:43,110 --> 00:22:47,700
negative infinity positive Infineon not

00:22:45,360 --> 00:22:52,049
a number right because those otherwise

00:22:47,700 --> 00:22:53,700
don't belong in the real numbers all

00:22:52,049 --> 00:22:56,000
right so let's do some denotational

00:22:53,700 --> 00:22:56,000
design

00:23:03,390 --> 00:23:09,010
okay so so the question was do you have

00:23:06,880 --> 00:23:10,660
to express the limits of the numbers and

00:23:09,010 --> 00:23:12,340
your types so usually when you're doing

00:23:10,660 --> 00:23:14,050
design work you can live with an

00:23:12,340 --> 00:23:16,480
approximation you don't have to have

00:23:14,050 --> 00:23:17,710
like the extreme rigor but sometimes you

00:23:16,480 --> 00:23:19,450
do depending on what you're working on

00:23:17,710 --> 00:23:22,480
yeah

00:23:19,450 --> 00:23:24,160
so let's do an exercise what what do you

00:23:22,480 --> 00:23:28,630
think is the mathematical essence of a

00:23:24,160 --> 00:23:31,900
movie okay

00:23:28,630 --> 00:23:33,970
one comment was a set of frames there we

00:23:31,900 --> 00:23:38,260
agree with that and we have a different

00:23:33,970 --> 00:23:43,710
idea what's that moving in a particular

00:23:38,260 --> 00:23:49,690
speed was another comment very good ah a

00:23:43,710 --> 00:24:01,870
function from time to frame yeah but but

00:23:49,690 --> 00:24:03,400
what is a frame a picture a function

00:24:01,870 --> 00:24:04,630
from X Y to a color can be a friend

00:24:03,400 --> 00:24:06,850
that's like that's a great one

00:24:04,630 --> 00:24:10,690
but we can go even more abstract than

00:24:06,850 --> 00:24:15,010
that we can say a movie is a function

00:24:10,690 --> 00:24:18,430
from our you know the reals time to some

00:24:15,010 --> 00:24:23,050
other type it doesn't have to be a frame

00:24:18,430 --> 00:24:24,460
we can make an int movie why would you

00:24:23,050 --> 00:24:27,760
want to do something like that well

00:24:24,460 --> 00:24:30,640
we'll see but we can come up with some

00:24:27,760 --> 00:24:34,720
basic operations here so the meaning of

00:24:30,640 --> 00:24:37,120
always is so this is the lambda notation

00:24:34,720 --> 00:24:39,220
for this we're just saying that always a

00:24:37,120 --> 00:24:41,080
creates a movie that for all time is

00:24:39,220 --> 00:24:42,450
going to have that value a so if you

00:24:41,080 --> 00:24:44,920
want everything to be blue all the time

00:24:42,450 --> 00:24:47,230
it's gonna be a very boring movie you

00:24:44,920 --> 00:24:49,930
can say always blue boom you got a movie

00:24:47,230 --> 00:24:51,970
of blue we can take a snapshot of a

00:24:49,930 --> 00:24:54,520
movie you know given a movie at a time

00:24:51,970 --> 00:24:55,900
you know we can take the movie the

00:24:54,520 --> 00:24:59,230
meaning of movie which we know is a

00:24:55,900 --> 00:25:01,890
function and apply the time to it so in

00:24:59,230 --> 00:25:03,880
our mathematical world we can say that

00:25:01,890 --> 00:25:05,560
taking the snapshot of a movie to

00:25:03,880 --> 00:25:09,750
particular time gives you the value with

00:25:05,560 --> 00:25:14,920
that that time level we can say

00:25:09,750 --> 00:25:16,860
transform things so this one's kind of

00:25:14,920 --> 00:25:19,340
fun so transform takes in

00:25:16,860 --> 00:25:22,470
something which converts an a to a B

00:25:19,340 --> 00:25:25,590
takes in a movie of type A and returns a

00:25:22,470 --> 00:25:29,100
movie of type B that's kind of fun so

00:25:25,590 --> 00:25:30,960
let's say you have a a black and white

00:25:29,100 --> 00:25:32,820
movie and you want to give it a little

00:25:30,960 --> 00:25:33,750
purple hue or something like that but

00:25:32,820 --> 00:25:35,640
now it's not a black-and-white movie

00:25:33,750 --> 00:25:37,169
anymore now it's the color movie so you

00:25:35,640 --> 00:25:40,289
can transform one movie type to a

00:25:37,169 --> 00:25:43,260
different movie type and time movie this

00:25:40,289 --> 00:25:45,240
is this is interesting so we talked

00:25:43,260 --> 00:25:48,529
about you can have an INT movie well

00:25:45,240 --> 00:25:52,649
here's a double movie that represents

00:25:48,529 --> 00:25:57,080
the time at every point so this movie at

00:25:52,649 --> 00:25:57,080
time 4 is going to have value 4

00:25:57,440 --> 00:26:03,299
all right this is kind of strange but

00:26:01,409 --> 00:26:04,500
let's let's try to take these semantics

00:26:03,299 --> 00:26:06,960
and now assume we have an implementation

00:26:04,500 --> 00:26:09,450
of these things and how would we make a

00:26:06,960 --> 00:26:12,179
gray flux movie so a grey flux movie

00:26:09,450 --> 00:26:14,130
this is where it starts out as white and

00:26:12,179 --> 00:26:16,679
then in one second it goes to black and

00:26:14,130 --> 00:26:20,279
then white again and then black just a

00:26:16,679 --> 00:26:22,559
gray flux movement so we start out with

00:26:20,279 --> 00:26:26,010
our time movie and then we call

00:26:22,559 --> 00:26:27,630
transform with our our function which

00:26:26,010 --> 00:26:30,029
transforms a value of one type to

00:26:27,630 --> 00:26:32,370
another type so so time and seconds is

00:26:30,029 --> 00:26:34,860
going to be the input to that and then

00:26:32,370 --> 00:26:37,289
we use this stood mod F to basically get

00:26:34,860 --> 00:26:39,360
the part after the decimal point for the

00:26:37,289 --> 00:26:41,070
time in seconds and then return a gray

00:26:39,360 --> 00:26:43,830
image with that kind of grayness and

00:26:41,070 --> 00:26:47,760
that's it and we've made a fluctuating

00:26:43,830 --> 00:26:49,409
movie so you can see that we were come

00:26:47,760 --> 00:26:51,049
up with these tiny little pieces but you

00:26:49,409 --> 00:26:53,580
put them together and you get an

00:26:51,049 --> 00:26:55,649
extremely powerful language for defining

00:26:53,580 --> 00:26:57,120
movies and if we had to find it in

00:26:55,649 --> 00:26:58,860
frames and all this other kind of stuff

00:26:57,120 --> 00:27:00,330
we wouldn't get this kind of power so

00:26:58,860 --> 00:27:01,740
again we're trying to get to the essence

00:27:00,330 --> 00:27:06,559
of the problem that we're trying to

00:27:01,740 --> 00:27:09,929
solve let's look at another example

00:27:06,559 --> 00:27:13,440
what's a stream I'm not talking about

00:27:09,929 --> 00:27:16,429
one in a river anybody have an idea what

00:27:13,440 --> 00:27:16,429
the essence of a stream could be

00:27:30,200 --> 00:27:36,900
so I heard the idea of taking the next

00:27:34,410 --> 00:27:40,290
one yeah so we're getting kind of a

00:27:36,900 --> 00:27:42,240
sense maybe not extremely concrete I'm

00:27:40,290 --> 00:27:43,560
sure you guys would figure it out if we

00:27:42,240 --> 00:27:48,480
you know have more time to brainstorm

00:27:43,560 --> 00:27:51,170
this but here's one way to do it start

00:27:48,480 --> 00:27:53,520
out with the idea of a sink so a sink

00:27:51,170 --> 00:27:55,020
we're introducing this term action it

00:27:53,520 --> 00:27:57,810
just means it like does some kind of

00:27:55,020 --> 00:27:59,460
computation or stateful thing in C++

00:27:57,810 --> 00:28:04,620
world and we can do that we can send our

00:27:59,460 --> 00:28:07,500
math with that it takes in some value

00:28:04,620 --> 00:28:09,390
like let's say it's a a double sink and

00:28:07,500 --> 00:28:11,730
it will produce some kind of action

00:28:09,390 --> 00:28:13,500
it'll do something okay

00:28:11,730 --> 00:28:16,020
and then we have the idea of a source

00:28:13,500 --> 00:28:19,890
now what that does is a function that

00:28:16,020 --> 00:28:21,690
takes in a sink basically and does

00:28:19,890 --> 00:28:23,520
something so the only thing can really

00:28:21,690 --> 00:28:26,130
do is just call that sink over and over

00:28:23,520 --> 00:28:28,230
and over and over again you know if you

00:28:26,130 --> 00:28:30,690
want to have a source that you know

00:28:28,230 --> 00:28:32,970
consists of five 5s then it would just

00:28:30,690 --> 00:28:45,000
call the sink five times with five as

00:28:32,970 --> 00:28:46,620
its argument the comment was in the

00:28:45,000 --> 00:28:48,660
notation why not use sink of E as

00:28:46,620 --> 00:28:50,580
opposed to the expanded form well you

00:28:48,660 --> 00:28:58,620
could use mu of syncope and that would

00:28:50,580 --> 00:29:00,750
be equivalent so that that's fine so we

00:28:58,620 --> 00:29:02,910
could directly map these things into C++

00:29:00,750 --> 00:29:04,650
there's no problem with that this isn't

00:29:02,910 --> 00:29:07,020
the only way to do it though you could

00:29:04,650 --> 00:29:08,700
do it with concepts as opposed to using

00:29:07,020 --> 00:29:10,350
stood function here and that would work

00:29:08,700 --> 00:29:15,060
just the same except be a lot more

00:29:10,350 --> 00:29:17,160
efficient actually so now we're going to

00:29:15,060 --> 00:29:19,410
implement some sources and some sinks so

00:29:17,160 --> 00:29:21,390
we have our source which is now our

00:29:19,410 --> 00:29:23,670
console input and it takes in the sink

00:29:21,390 --> 00:29:27,660
that's what sources do and it's just

00:29:23,670 --> 00:29:28,800
going to use C and get and call the sink

00:29:27,660 --> 00:29:32,660
with it into

00:29:28,800 --> 00:29:36,050
there's nothing left simple enough and

00:29:32,660 --> 00:29:38,550
then our console output is a sync and

00:29:36,050 --> 00:29:40,800
this just is a function which takes in a

00:29:38,550 --> 00:29:44,940
character and outputs as a standard

00:29:40,800 --> 00:29:47,010
output of course sources and sinks are

00:29:44,940 --> 00:29:48,180
not very interesting on their own be

00:29:47,010 --> 00:29:50,190
nice if we have some way to connect them

00:29:48,180 --> 00:29:52,110
together so we can do that we'll

00:29:50,190 --> 00:29:55,410
introduce this idea of connecting a

00:29:52,110 --> 00:29:58,320
source in a sink so the connect function

00:29:55,410 --> 00:29:59,910
the meaning of that it'll be a function

00:29:58,320 --> 00:30:03,240
which takes in a source and it'll take

00:29:59,910 --> 00:30:06,120
in a sink and it will do something so in

00:30:03,240 --> 00:30:08,640
this case concretely if the source is s

00:30:06,120 --> 00:30:10,080
O and the sink is si we take the meaning

00:30:08,640 --> 00:30:12,960
of source now remember that a source

00:30:10,080 --> 00:30:15,690
takes in a sink as an argument and we

00:30:12,960 --> 00:30:18,560
pass in the sink and that's it so we can

00:30:15,690 --> 00:30:20,730
directly implement this in C++ and

00:30:18,560 --> 00:30:22,350
that's what it looks like and now we can

00:30:20,730 --> 00:30:34,460
connect our console input in our console

00:30:22,350 --> 00:30:37,170
output and it just connects them a

00:30:34,460 --> 00:30:40,110
comment is is the source a special kind

00:30:37,170 --> 00:30:45,420
of sink because they both do an action

00:30:40,110 --> 00:30:46,740
and I'd have to think about that so

00:30:45,420 --> 00:30:50,100
anyway we have this this connect

00:30:46,740 --> 00:30:53,700
function this is this works what other

00:30:50,100 --> 00:30:55,110
kind of things can we do well we have

00:30:53,700 --> 00:30:56,580
you know here for reference that a

00:30:55,110 --> 00:30:59,940
meaning of a sink is something that

00:30:56,580 --> 00:31:02,760
takes in a value and does an action what

00:30:59,940 --> 00:31:05,730
about the idea of transforming so a

00:31:02,760 --> 00:31:08,330
transform from A to B takes in a sink of

00:31:05,730 --> 00:31:11,820
B and converts it into a sink of a and

00:31:08,330 --> 00:31:15,090
you'll see why I reversed a - B - B - a

00:31:11,820 --> 00:31:17,720
in a second here which is the same thing

00:31:15,090 --> 00:31:21,480
as saying the meaning of a sink to a

00:31:17,720 --> 00:31:22,560
sink here that's like one function but

00:31:21,480 --> 00:31:25,320
we can just say this is a single

00:31:22,560 --> 00:31:27,810
function which takes in a sink and the

00:31:25,320 --> 00:31:30,570
value of a and just does some kind of

00:31:27,810 --> 00:31:37,230
action we're just moving things around a

00:31:30,570 --> 00:31:37,850
little bit so a transform here we can

00:31:37,230 --> 00:31:39,380
say that

00:31:37,850 --> 00:31:41,630
it's just a function which takes in a

00:31:39,380 --> 00:31:48,980
sink of B and an A and that's all a

00:31:41,630 --> 00:31:50,900
transform is so transforms by on their

00:31:48,980 --> 00:31:53,570
own art very interesting we we can apply

00:31:50,900 --> 00:31:55,640
it to a sink and that's what it was

00:31:53,570 --> 00:31:57,289
intended for and I'm not giving you the

00:31:55,640 --> 00:31:59,059
implementation this is an exercise and I

00:31:57,289 --> 00:32:00,470
encourage you guys to you know just do

00:31:59,059 --> 00:32:02,450
it it won't take very long but it'll be

00:32:00,470 --> 00:32:04,640
very rewarding so we're just applying

00:32:02,450 --> 00:32:06,830
this transform to a sink and it produces

00:32:04,640 --> 00:32:08,390
a new sink but we can also take our

00:32:06,830 --> 00:32:11,570
transform and apply it to a source

00:32:08,390 --> 00:32:12,770
that's not a problem and it's actually

00:32:11,570 --> 00:32:15,350
really fun and try to figure out how to

00:32:12,770 --> 00:32:17,539
do this so we can apply this transform

00:32:15,350 --> 00:32:19,789
to a source now we're introducing some

00:32:17,539 --> 00:32:21,980
extra syntax here just because we like

00:32:19,789 --> 00:32:23,600
to do operator overloading in C++ and

00:32:21,980 --> 00:32:27,440
we're saying that if you have a source

00:32:23,600 --> 00:32:30,710
and a transform this syntax source arrow

00:32:27,440 --> 00:32:32,090
or source right shift transform the

00:32:30,710 --> 00:32:33,799
meaning of that is the same thing as the

00:32:32,090 --> 00:32:37,490
meaning of applying that transform to

00:32:33,799 --> 00:32:40,250
that source and taking the transform and

00:32:37,490 --> 00:32:42,400
right shift to the sink that's just

00:32:40,250 --> 00:32:45,799
applying the transform to the sink and

00:32:42,400 --> 00:32:47,480
if we have a source and a sink and we're

00:32:45,799 --> 00:32:51,460
using the right shift operator we're

00:32:47,480 --> 00:32:51,460
just connecting the source to the sink

00:32:52,659 --> 00:32:58,789
so let's look at an example let's say we

00:32:56,120 --> 00:33:01,460
have this get lines transform and these

00:32:58,789 --> 00:33:03,919
are also exercises for you guys and what

00:33:01,460 --> 00:33:09,169
this does is it'll transform a source of

00:33:03,919 --> 00:33:12,230
char into a source of that should be

00:33:09,169 --> 00:33:13,880
string sorry yeah transform a source of

00:33:12,230 --> 00:33:16,640
charts with source of string and it'll

00:33:13,880 --> 00:33:18,409
just basically take that char source and

00:33:16,640 --> 00:33:20,299
convert it into a bunch of strings

00:33:18,409 --> 00:33:23,840
representing the different lines that

00:33:20,299 --> 00:33:27,020
got read from whatever then we have

00:33:23,840 --> 00:33:29,570
unworried Sissel take a source of

00:33:27,020 --> 00:33:31,490
strings and convert it into a source of

00:33:29,570 --> 00:33:33,950
chars and it'll just take each of those

00:33:31,490 --> 00:33:34,610
strings and then make you know that

00:33:33,950 --> 00:33:37,070
source

00:33:34,610 --> 00:33:38,600
you know output the string and then a

00:33:37,070 --> 00:33:41,960
space and the next string and then a

00:33:38,600 --> 00:33:43,580
space and the next string and so on and

00:33:41,960 --> 00:33:47,330
now we can use some of our neat little

00:33:43,580 --> 00:33:49,520
syntax we can say okay input lines we

00:33:47,330 --> 00:33:51,620
just take the console input and we apply

00:33:49,520 --> 00:33:53,780
this get lines transform to it

00:33:51,620 --> 00:33:57,050
and boom we got the lines or we can have

00:33:53,780 --> 00:33:58,730
this word outputs Inc now we're taking a

00:33:57,050 --> 00:34:00,680
transform and applying it to a sink and

00:33:58,730 --> 00:34:03,500
then we got a string sink and then we

00:34:00,680 --> 00:34:07,760
can take input lines and put that to

00:34:03,500 --> 00:34:12,590
word output and it does what it needs to

00:34:07,760 --> 00:34:14,179
do so another thing that would be

00:34:12,590 --> 00:34:16,690
interesting is we can take a transform

00:34:14,179 --> 00:34:18,710
and apply it to a transform as well

00:34:16,690 --> 00:34:20,360
there's nothing stopping us from doing

00:34:18,710 --> 00:34:24,770
that in mathematics and again that's an

00:34:20,360 --> 00:34:26,090
exercise so here we just make a new

00:34:24,770 --> 00:34:28,429
Transformer out of these two

00:34:26,090 --> 00:34:30,110
transformers where it just uses the get

00:34:28,429 --> 00:34:31,610
lines transformer and it binds it to the

00:34:30,110 --> 00:34:36,230
Unwerth strands former and boom you get

00:34:31,610 --> 00:34:37,820
a new transformer so my hope is that

00:34:36,230 --> 00:34:40,159
you're getting the sense that we get

00:34:37,820 --> 00:34:41,480
these pieces that we can put together in

00:34:40,159 --> 00:34:43,669
all these different ways and we get a

00:34:41,480 --> 00:34:45,409
very powerful domain-specific embedded

00:34:43,669 --> 00:34:46,820
language essentially so that's what

00:34:45,409 --> 00:34:48,260
happens when you start with the

00:34:46,820 --> 00:34:52,790
mathematics and you try to build your

00:34:48,260 --> 00:34:56,690
way down to the implementation so I got

00:34:52,790 --> 00:35:00,080
one more example what is command line

00:34:56,690 --> 00:35:01,730
processing so I'm sure all of you guys

00:35:00,080 --> 00:35:03,890
have used some kind of a command line

00:35:01,730 --> 00:35:06,890
processing library like whether it's get

00:35:03,890 --> 00:35:09,020
opt boost program options something or

00:35:06,890 --> 00:35:10,790
other and I'm always very disappointed

00:35:09,020 --> 00:35:11,990
with them because it just asked the

00:35:10,790 --> 00:35:13,370
question you know well let's say I don't

00:35:11,990 --> 00:35:15,710
want to use double dash I want to use

00:35:13,370 --> 00:35:18,890
single - well then you got to make a

00:35:15,710 --> 00:35:21,290
modification to the library and you know

00:35:18,890 --> 00:35:25,250
add new features to it well let's say

00:35:21,290 --> 00:35:27,440
you want to you know only have these

00:35:25,250 --> 00:35:29,270
options enabled if this prior option is

00:35:27,440 --> 00:35:32,300
enabled well then you might have to add

00:35:29,270 --> 00:35:33,590
a feature and then your library just

00:35:32,300 --> 00:35:35,870
grows and grows and grows and grows

00:35:33,590 --> 00:35:37,100
that's a good indicator that whoever

00:35:35,870 --> 00:35:39,530
wrote the library didn't nail the

00:35:37,100 --> 00:35:41,960
semantics in the first place if you nail

00:35:39,530 --> 00:35:44,150
the semantics you can take these you

00:35:41,960 --> 00:35:48,290
know strange cases and it can do it it's

00:35:44,150 --> 00:35:49,610
perfectly capable of it so command line

00:35:48,290 --> 00:35:51,440
processing when you think about it

00:35:49,610 --> 00:35:55,100
you're really just taking a list of

00:35:51,440 --> 00:35:57,470
strings and converting it into some kind

00:35:55,100 --> 00:36:00,640
of value that makes sense for that

00:35:57,470 --> 00:36:02,930
program and then you're saying oh well

00:36:00,640 --> 00:36:05,730
that looks kind of similar because I

00:36:02,930 --> 00:36:10,020
know that the semantics of a parser

00:36:05,730 --> 00:36:12,450
like an a parser here where a is like a

00:36:10,020 --> 00:36:14,580
char or something like that it just

00:36:12,450 --> 00:36:20,370
converts a list of some type into

00:36:14,580 --> 00:36:23,310
another type so maybe a command line

00:36:20,370 --> 00:36:27,150
processor is really just a parser of a

00:36:23,310 --> 00:36:28,830
list of strings so a string part so

00:36:27,150 --> 00:36:32,390
instead of char here like you'd normally

00:36:28,830 --> 00:36:32,390
have with a parser now you have a string

00:36:33,230 --> 00:36:37,890
and so an example of how you'd use

00:36:36,360 --> 00:36:39,840
something like this is let's say you

00:36:37,890 --> 00:36:41,850
have your help flag in your user flag

00:36:39,840 --> 00:36:43,620
and the user flag you know needs to

00:36:41,850 --> 00:36:46,500
specify the username or something like

00:36:43,620 --> 00:36:49,740
that you can use what you already know

00:36:46,500 --> 00:36:51,360
about parsers and make a little parser

00:36:49,740 --> 00:36:53,160
Combinator library that works for

00:36:51,360 --> 00:36:56,880
command-line arguments so here we have

00:36:53,160 --> 00:36:59,160
mix args here so if you have - - help

00:36:56,880 --> 00:37:01,230
it'll have the help flag object if you

00:36:59,160 --> 00:37:03,960
use - - user followed by a string and

00:37:01,230 --> 00:37:06,510
then convert that string into the user

00:37:03,960 --> 00:37:08,460
flag now you just have a simple parser

00:37:06,510 --> 00:37:12,030
fully capable of doing anything you can

00:37:08,460 --> 00:37:14,940
possibly imagine expanding on this a

00:37:12,030 --> 00:37:17,070
little bit let's say you have your list

00:37:14,940 --> 00:37:20,040
accounts mode so git is a good example

00:37:17,070 --> 00:37:22,320
of a command-line program that has

00:37:20,040 --> 00:37:25,320
different modes so only if you have a

00:37:22,320 --> 00:37:26,640
certain mode open like get sub module

00:37:25,320 --> 00:37:31,560
will you get certain options available

00:37:26,640 --> 00:37:33,150
for you we have our total command-line

00:37:31,560 --> 00:37:35,550
parse this is the result of all the

00:37:33,150 --> 00:37:37,230
command-line parsing first you have your

00:37:35,550 --> 00:37:39,210
global flags we already had a previous

00:37:37,230 --> 00:37:41,040
parser which handled that and then you

00:37:39,210 --> 00:37:43,140
have a variant which is either you know

00:37:41,040 --> 00:37:45,960
the list accounts mode or the list job

00:37:43,140 --> 00:37:47,850
mode and we take the parser we defined

00:37:45,960 --> 00:37:50,970
on the previous slide and that should be

00:37:47,850 --> 00:37:53,220
followed by one of these two so we use

00:37:50,970 --> 00:37:56,120
the or here to say either this argument

00:37:53,220 --> 00:37:59,220
or this argument and it just works

00:37:56,120 --> 00:38:02,340
extremely powerful there's not much you

00:37:59,220 --> 00:38:07,770
can't do with it that's what we're going

00:38:02,340 --> 00:38:11,130
for so some of the benefits of this

00:38:07,770 --> 00:38:15,000
design methodology you get highly

00:38:11,130 --> 00:38:17,430
flexible systems it's hard to find cases

00:38:15,000 --> 00:38:18,870
that you can't use whatever you know

00:38:17,430 --> 00:38:19,230
programming came up with is hard to find

00:38:18,870 --> 00:38:20,970
case

00:38:19,230 --> 00:38:22,530
where you need to add a feature in order

00:38:20,970 --> 00:38:24,810
for it to actually work for a problem

00:38:22,530 --> 00:38:27,240
domain and the pieces are highly

00:38:24,810 --> 00:38:29,280
composable because mathematics is highly

00:38:27,240 --> 00:38:31,770
composable so you're going to come up

00:38:29,280 --> 00:38:33,510
with these little pieces that can be

00:38:31,770 --> 00:38:36,090
used in all these different ways to put

00:38:33,510 --> 00:38:38,640
together complex programs but the

00:38:36,090 --> 00:38:40,800
underlying pieces are very small all

00:38:38,640 --> 00:38:43,859
this stuff is really typesafe if you do

00:38:40,800 --> 00:38:46,109
it well and the underlying pieces are

00:38:43,859 --> 00:38:51,450
simple when you put them together you

00:38:46,109 --> 00:38:53,970
get more sophisticated things so this

00:38:51,450 --> 00:38:56,220
concludes the talk and I wanted to give

00:38:53,970 --> 00:38:57,780
some time for questions but the idea is

00:38:56,220 --> 00:38:59,400
you're discovering the essence and

00:38:57,780 --> 00:39:01,380
you're deriving the implementation and

00:38:59,400 --> 00:39:04,590
there's so much more to this like the

00:39:01,380 --> 00:39:07,800
mathematics behind it are just things

00:39:04,590 --> 00:39:11,570
that are extremely interesting so with

00:39:07,800 --> 00:39:11,570
that we'll ask s answer some questions

00:39:16,130 --> 00:39:23,520
so the question was is there a sample of

00:39:19,230 --> 00:39:25,710
this code online there isn't and that's

00:39:23,520 --> 00:39:51,960
because I want you guys to implement

00:39:25,710 --> 00:39:55,350
this stuff so okay so the comment was

00:39:51,960 --> 00:39:57,660
that why isn't that unique pointer

00:39:55,350 --> 00:40:00,660
example just why isn't that a valid

00:39:57,660 --> 00:40:03,240
product type and the reason is because

00:40:00,660 --> 00:40:05,700
of the null case because if I try to map

00:40:03,240 --> 00:40:07,590
a value which one has null and the other

00:40:05,700 --> 00:40:09,570
one has null I can't figure out the

00:40:07,590 --> 00:40:11,700
mathematical equivalent of that in the

00:40:09,570 --> 00:40:16,080
product type and the map doesn't work

00:40:11,700 --> 00:40:18,470
both ways so that's the problem other

00:40:16,080 --> 00:40:18,470
questions

00:40:25,740 --> 00:40:29,350
okay so the comment was you know what

00:40:28,090 --> 00:40:32,140
are some good sources if you want to

00:40:29,350 --> 00:40:33,130
read more about this there's a book that

00:40:32,140 --> 00:40:35,590
I really like

00:40:33,130 --> 00:40:38,350
it's called denotational semantics I

00:40:35,590 --> 00:40:40,510
believe it's written by Schmidt it's an

00:40:38,350 --> 00:40:42,700
old book you can find the source you can

00:40:40,510 --> 00:40:46,440
find the PDF online is out of print and

00:40:42,700 --> 00:40:46,440
if you can get a hold an old copy then

00:40:49,290 --> 00:40:52,660
the question is is this a standard

00:40:51,250 --> 00:40:59,260
denotational semantics it's been around

00:40:52,660 --> 00:41:29,140
for decades and the answer is yes any

00:40:59,260 --> 00:41:32,430
other questions so the question was how

00:41:29,140 --> 00:41:34,300
does C++ relate to value or how does

00:41:32,430 --> 00:41:36,550
functional design relate to value

00:41:34,300 --> 00:41:39,820
semantics you know and I think the

00:41:36,550 --> 00:41:42,760
answer to this is that it Maps very very

00:41:39,820 --> 00:41:44,170
well I think it makes C++ very

00:41:42,760 --> 00:41:46,570
well-suited because it has value

00:41:44,170 --> 00:41:48,490
semantics to doing this kind of design

00:41:46,570 --> 00:41:50,110
whereas if you only have reference

00:41:48,490 --> 00:42:02,140
semantics it's a lot harder to get those

00:41:50,110 --> 00:42:05,200
mappings yeah can I point to programs or

00:42:02,140 --> 00:42:07,390
libraries that have using this kind of a

00:42:05,200 --> 00:42:10,360
designing I think are well done well

00:42:07,390 --> 00:42:13,090
there's another talk on boost spirit

00:42:10,360 --> 00:42:15,250
that's going on exactly at this time so

00:42:13,090 --> 00:42:18,160
I'd recommend you watch oh I just can't

00:42:15,250 --> 00:42:20,530
do that but there's there's quite a few

00:42:18,160 --> 00:42:23,500
things out there so generally like boost

00:42:20,530 --> 00:42:25,750
optional you know it nails the semantics

00:42:23,500 --> 00:42:28,360
but generally speaking this is something

00:42:25,750 --> 00:42:31,000
new in the C++ world in particular

00:42:28,360 --> 00:42:33,700
you'll see a lot of this in Haskell but

00:42:31,000 --> 00:42:35,740
not so much in C++ and I can tell some

00:42:33,700 --> 00:42:37,630
of my own libraries like

00:42:35,740 --> 00:42:39,070
SF RP if you look that one up on the

00:42:37,630 --> 00:43:06,040
internet you'll find a good example of

00:42:39,070 --> 00:43:07,210
that so the comment was what about an

00:43:06,040 --> 00:43:09,070
embedded world you know when you just

00:43:07,210 --> 00:43:10,990
have to move things you know for things

00:43:09,070 --> 00:43:14,140
that are more difficult to express in

00:43:10,990 --> 00:43:16,810
pure math and that is the that is

00:43:14,140 --> 00:43:18,430
functional design right so you have to

00:43:16,810 --> 00:43:20,190
take a look at your problem and see if

00:43:18,430 --> 00:43:22,390
you can find the mathematics behind it

00:43:20,190 --> 00:43:24,099
there are some problems that might be

00:43:22,390 --> 00:43:25,570
too complex to be able to find the

00:43:24,099 --> 00:43:26,920
mathematical essence of it or they're

00:43:25,570 --> 00:43:28,300
just too difficult you know people are

00:43:26,920 --> 00:43:30,130
discovering these things all the time so

00:43:28,300 --> 00:43:33,430
it really depends on the particular

00:43:30,130 --> 00:43:35,140
instance of the problem to see you know

00:43:33,430 --> 00:43:53,619
can we find out the a good mathematical

00:43:35,140 --> 00:43:56,200
essence for it so the comment was have I

00:43:53,619 --> 00:43:58,690
played with syntax that's even more

00:43:56,200 --> 00:44:00,670
mathy so that someone would see someone

00:43:58,690 --> 00:44:02,740
who's not a C++ person can work on it

00:44:00,670 --> 00:44:04,210
and I think the essence of the

00:44:02,740 --> 00:44:07,720
mathematical language is pure

00:44:04,210 --> 00:44:09,400
mathematics the only time when C++ is

00:44:07,720 --> 00:44:12,930
getting introduces on the left side of

00:44:09,400 --> 00:44:15,490
that meaning function over there so and

00:44:12,930 --> 00:44:17,619
I'm using a very simple mathematical

00:44:15,490 --> 00:44:20,650
language here so most of what I do in

00:44:17,619 --> 00:44:22,900
practice I use the language Agda for

00:44:20,650 --> 00:44:25,830
defining my for as my mathematical

00:44:22,900 --> 00:44:25,830
language for semantics

00:44:39,020 --> 00:44:43,410
also a comment it was you know for the

00:44:41,730 --> 00:44:45,150
mathematical language that was used can

00:44:43,410 --> 00:44:46,940
we get slides or something and I think

00:44:45,150 --> 00:44:48,990
that all the slides are published online

00:44:46,940 --> 00:44:51,180
for this conference I could be wrong

00:44:48,990 --> 00:45:06,600
about that but if not I will make them

00:44:51,180 --> 00:45:08,150
available yeah so the comment was it

00:45:06,600 --> 00:45:11,570
seems like functional programming

00:45:08,150 --> 00:45:13,500
requires a garbage collector and

00:45:11,570 --> 00:45:16,620
functional design doesn't require

00:45:13,500 --> 00:45:18,000
garbage collector there's a lot of

00:45:16,620 --> 00:45:19,380
functional programming that doesn't

00:45:18,000 --> 00:45:21,750
require a garbage collector so that's

00:45:19,380 --> 00:45:25,620
more in the functional languages kind of

00:45:21,750 --> 00:45:27,480
area and you can do reference counting

00:45:25,620 --> 00:45:28,350
and you know there's there's lots of

00:45:27,480 --> 00:45:29,340
different ways you can handle that

00:45:28,350 --> 00:45:30,840
problem if you're trying to implement a

00:45:29,340 --> 00:45:43,860
functional language but you don't need

00:45:30,840 --> 00:45:45,210
it when you're mapping stuff to C++ I'm

00:45:43,860 --> 00:45:47,550
glad you asked that question the

00:45:45,210 --> 00:45:50,690
question was is functional design

00:45:47,550 --> 00:45:53,520
incompatible with object-oriented design

00:45:50,690 --> 00:45:57,080
my answers to that is it makes

00:45:53,520 --> 00:45:59,160
object-oriented design look very bad so

00:45:57,080 --> 00:46:00,840
generally if you can come up with a

00:45:59,160 --> 00:46:02,820
functional design it'll be very hard to

00:46:00,840 --> 00:46:05,100
argue that an object-oriented approach

00:46:02,820 --> 00:46:06,570
would be better but it's certainly not

00:46:05,100 --> 00:46:08,280
compatible you can mix the libraries

00:46:06,570 --> 00:46:10,470
together you know just because we're

00:46:08,280 --> 00:46:12,030
using plain C++ functions so there's

00:46:10,470 --> 00:46:13,860
nothing inherently incompatible but I

00:46:12,030 --> 00:46:16,110
think it does supersede things like

00:46:13,860 --> 00:46:18,680
those design patterns and other design

00:46:16,110 --> 00:46:18,680
methodologies

00:46:31,550 --> 00:46:35,120
okay so uh the question was you know is

00:46:33,680 --> 00:46:37,850
there an example of how I use this in my

00:46:35,120 --> 00:46:41,210
company where I work so one example was

00:46:37,850 --> 00:46:44,920
I looked at this one class it was called

00:46:41,210 --> 00:46:47,900
calculation and it was a terrible

00:46:44,920 --> 00:46:52,340
terrible class boy is this being

00:46:47,900 --> 00:46:54,680
recorded um but anyway we were trying to

00:46:52,340 --> 00:46:56,060
figure out how to refactor it so what I

00:46:54,680 --> 00:46:58,610
did is I tried to figure out what is the

00:46:56,060 --> 00:47:00,230
essence of this calculation class and it

00:46:58,610 --> 00:47:02,450
had like ID and all this other kind of

00:47:00,230 --> 00:47:04,580
stuff and we had the aha moment that oh

00:47:02,450 --> 00:47:07,310
this is really simple this is just a

00:47:04,580 --> 00:47:09,050
function of some kind and then we

00:47:07,310 --> 00:47:10,310
reworked everything and we realize that

00:47:09,050 --> 00:47:12,170
we didn't need an ID because we're just

00:47:10,310 --> 00:47:13,790
doing function equality which is fine in

00:47:12,170 --> 00:47:16,430
math so we overloaded the equal operator

00:47:13,790 --> 00:47:18,980
and everything just got a lot simpler so

00:47:16,430 --> 00:47:21,110
doing the design process is something

00:47:18,980 --> 00:47:22,430
that requires someone with a little bit

00:47:21,110 --> 00:47:25,850
of mathematical knowledge and discipline

00:47:22,430 --> 00:47:28,130
can do but the resulting library is

00:47:25,850 --> 00:48:08,300
something that anybody can use highly

00:47:28,130 --> 00:48:09,680
consumable so the comment was in a lot

00:48:08,300 --> 00:48:11,930
of these higher level functional

00:48:09,680 --> 00:48:15,320
programming languages like Agda you have

00:48:11,930 --> 00:48:18,170
a way to type check soundness is there a

00:48:15,320 --> 00:48:20,120
way to have an automated proof that

00:48:18,170 --> 00:48:22,940
proves that your c++ which is derived

00:48:20,120 --> 00:48:25,250
from it correctly models what you're

00:48:22,940 --> 00:48:27,170
trying to model and there's nothing that

00:48:25,250 --> 00:48:29,540
I'm aware of yet for that so all the

00:48:27,170 --> 00:48:32,090
proofs would have to be manually for as

00:48:29,540 --> 00:48:34,540
far as I know well they're not hard

00:48:32,090 --> 00:48:34,540
proofs to do

00:48:35,990 --> 00:48:39,420
all right well if there's no further

00:48:37,890 --> 00:48:40,800
questions you'll find me afterwards if

00:48:39,420 --> 00:48:43,010
you have a question but that's the end

00:48:40,800 --> 00:48:43,010

YouTube URL: https://www.youtube.com/watch?v=x9mIAT-CAwA


