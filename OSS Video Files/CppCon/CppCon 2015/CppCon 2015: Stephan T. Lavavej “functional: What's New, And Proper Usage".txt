Title: CppCon 2015: Stephan T. Lavavej “functional: What's New, And Proper Usage"
Publication date: 2015-10-11
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
functional gained lots of machinery in C++11, with further changes in C++14 and C++17. This talk will cover what's new in 11/14/17, focusing on how to use it properly. For example, you've probably used std::function, but do you know the criteria for activating the Small Functor Optimization? (It's not just being small!) We'll also look at bind(), mem_fn(), C++17's invoke(), and more.
— 
Stephan T. Lavavej is a Senior Developer at Microsoft. Since 2007, he's worked with Dinkumware to maintain Visual C++'s implementation of the C++ Standard Library. He also designed a couple of C++14 features: make_unique and the transparent operator functors. He likes his initials (which people can actually spell) and cats (although he doesn't own any).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,160
ok let's get started so hi I'm Stefan T

00:00:03,300 --> 00:00:08,250
la Wade and for the past eight almost

00:00:05,160 --> 00:00:10,080
nine years I've been working on VC's STL

00:00:08,250 --> 00:00:12,360
implementation and I'm here to talk to

00:00:10,080 --> 00:00:13,920
you today about functional which is a

00:00:12,360 --> 00:00:16,609
header that existed all the way back in

00:00:13,920 --> 00:00:19,439
CS plus 98 but has expanded dramatically

00:00:16,609 --> 00:00:22,310
possibly more so than any other header

00:00:19,439 --> 00:00:26,279
in the standard library through CS plus

00:00:22,310 --> 00:00:28,230
1114 and the upcoming CS plus 17 some

00:00:26,279 --> 00:00:30,359
people who are pessimists refer to it as

00:00:28,230 --> 00:00:33,719
cos plus 1 z I'm an optimist I think it

00:00:30,359 --> 00:00:35,309
actually will be 17 so a couple things

00:00:33,719 --> 00:00:38,280
to get started please hold your

00:00:35,309 --> 00:00:40,079
questions until the end if you have a

00:00:38,280 --> 00:00:41,700
question about a slide I have slide

00:00:40,079 --> 00:00:42,960
numbers so write them down you'll put

00:00:41,700 --> 00:00:45,120
them on your phone and then at the end

00:00:42,960 --> 00:00:47,280
you can ask about that slide and I can

00:00:45,120 --> 00:00:49,050
go back and we can talk about it also

00:00:47,280 --> 00:00:51,629
everything I'm going to talk about today

00:00:49,050 --> 00:00:53,070
is standard so it'll work regardless of

00:00:51,629 --> 00:00:55,800
what implementation you use as long as

00:00:53,070 --> 00:00:57,420
it conforms to the standard there's only

00:00:55,800 --> 00:00:59,129
a couple of implementation specific

00:00:57,420 --> 00:01:01,039
things that I'll be mentioning and I'll

00:00:59,129 --> 00:01:04,920
point those out as they come along and

00:01:01,039 --> 00:01:07,080
in es2015 i over hauled functional

00:01:04,920 --> 00:01:09,330
support machinery so everything talked

00:01:07,080 --> 00:01:11,670
about today is available right now in vs

00:01:09,330 --> 00:01:13,229
2015 RT M with only a couple exceptions

00:01:11,670 --> 00:01:14,820
and I'll mention those at the ends you

00:01:13,229 --> 00:01:16,710
know exactly what's available and what

00:01:14,820 --> 00:01:18,479
isn't also every feature I'm going to

00:01:16,710 --> 00:01:20,430
talk about I've cabbed with the standard

00:01:18,479 --> 00:01:22,799
revision so for some reason you only

00:01:20,430 --> 00:01:25,200
have access to CS plus 11 or CS plus 14

00:01:22,799 --> 00:01:27,420
rather than the full everything that's

00:01:25,200 --> 00:01:30,150
coming in CS + 17 you'll know what will

00:01:27,420 --> 00:01:32,130
be available so although this talk is

00:01:30,150 --> 00:01:34,079
about the standard libraries functional

00:01:32,130 --> 00:01:36,829
header I want to start by talking about

00:01:34,079 --> 00:01:38,700
lambdas this is sort of prerequisite for

00:01:36,829 --> 00:01:40,829
understanding everything I'll talk about

00:01:38,700 --> 00:01:43,560
later on so they were added in CS + 11 +

00:01:40,829 --> 00:01:46,530
CS + 14 they became more powerful within

00:01:43,560 --> 00:01:48,509
a captures and generic lambdas so this

00:01:46,530 --> 00:01:51,840
is what a lambda looks like shouldn't be

00:01:48,509 --> 00:01:54,780
too surprising unless you have not used

00:01:51,840 --> 00:01:56,579
generic lambdas before here I've got a

00:01:54,780 --> 00:01:58,320
vector strings and I've initialized it

00:01:56,579 --> 00:02:00,810
with some stuff and I want I want to

00:01:58,320 --> 00:02:02,040
sort them but not lexicographically and

00:02:00,810 --> 00:02:03,810
still don't want to sort them by their

00:02:02,040 --> 00:02:05,490
lengths and I'd like to sort them stay

00:02:03,810 --> 00:02:07,590
bleed so preserve the original order

00:02:05,490 --> 00:02:09,239
when the links to the same so I could

00:02:07,590 --> 00:02:10,649
write this even in CSS 98 with a

00:02:09,239 --> 00:02:12,500
handwritten function object but with a

00:02:10,649 --> 00:02:13,860
lambda I can do it all in a single line

00:02:12,500 --> 00:02:15,600
wrapping

00:02:13,860 --> 00:02:17,640
for the slide and here it's very simple

00:02:15,600 --> 00:02:20,250
I simply say here's a lambda and I take

00:02:17,640 --> 00:02:21,930
Ln R and I return whether L size is less

00:02:20,250 --> 00:02:24,120
than R size and this distorts them by

00:02:21,930 --> 00:02:26,760
their sizing I can go print them out all

00:02:24,120 --> 00:02:28,560
of my code examples here are real code

00:02:26,760 --> 00:02:29,820
that will actually compile if you

00:02:28,560 --> 00:02:32,820
include the necessary header is pretty

00:02:29,820 --> 00:02:34,260
using directive and in me the generic

00:02:32,820 --> 00:02:36,780
part of this is that I say Const auto

00:02:34,260 --> 00:02:38,910
ref there's no reason for me to repeat

00:02:36,780 --> 00:02:40,500
string and this would the lambda would

00:02:38,910 --> 00:02:43,740
continue working if for some reason I

00:02:40,500 --> 00:02:45,420
needed to change the type to u16 string

00:02:43,740 --> 00:02:46,740
you throw to string or W string any of

00:02:45,420 --> 00:02:49,350
those there's no reason for me to repeat

00:02:46,740 --> 00:02:51,270
the type there so that's a lambda but

00:02:49,350 --> 00:02:52,680
I've noticed that many programmers when

00:02:51,270 --> 00:02:54,360
they they start using lambdas they get

00:02:52,680 --> 00:02:56,280
some very strange ideas into their head

00:02:54,360 --> 00:02:58,470
they think that lambdas are some sort of

00:02:56,280 --> 00:03:00,120
magical thing and the way that I think

00:02:58,470 --> 00:03:02,790
about it lambdas do something very

00:03:00,120 --> 00:03:04,530
simple a lambda expression which is what

00:03:02,790 --> 00:03:07,320
you type in your source code does

00:03:04,530 --> 00:03:10,230
exactly two things it defines an unnamed

00:03:07,320 --> 00:03:13,350
class and then it constructs an object

00:03:10,230 --> 00:03:15,600
of that type possibly initializing some

00:03:13,350 --> 00:03:17,640
data members which are there captures so

00:03:15,600 --> 00:03:19,530
the lambda syntax is very convenient as

00:03:17,640 --> 00:03:21,600
I saw in the previous slide I could cram

00:03:19,530 --> 00:03:24,150
the functionality of oh just compared

00:03:21,600 --> 00:03:26,400
these strings by their size into

00:03:24,150 --> 00:03:28,650
essentially a single line but it doesn't

00:03:26,400 --> 00:03:30,870
grant you physically new powers you

00:03:28,650 --> 00:03:33,239
could always have done this by writing a

00:03:30,870 --> 00:03:34,769
function object by hand the problem is

00:03:33,239 --> 00:03:36,050
that it would just be more verbose and

00:03:34,769 --> 00:03:39,239
you would have to put the definition

00:03:36,050 --> 00:03:40,830
outside of the local context of wherever

00:03:39,239 --> 00:03:42,209
you're invoking the algorithm so the

00:03:40,830 --> 00:03:44,519
lambdas are convenient but they're not

00:03:42,209 --> 00:03:47,459
magical in any way also I've noticed a

00:03:44,519 --> 00:03:48,720
lot of confusion lambdas they're a core

00:03:47,459 --> 00:03:50,190
language feature the part of the

00:03:48,720 --> 00:03:52,050
compiler and they're available without

00:03:50,190 --> 00:03:54,570
including any standard library machine

00:03:52,050 --> 00:03:56,850
machinery they're not stood functions

00:03:54,570 --> 00:03:58,080
they can be stored instead functions and

00:03:56,850 --> 00:04:00,060
we'll go over that at the end of the

00:03:58,080 --> 00:04:01,440
talk but they are not stood function so

00:04:00,060 --> 00:04:03,330
if anybody says oh the lambdas the stood

00:04:01,440 --> 00:04:05,190
function you need to correct them no

00:04:03,330 --> 00:04:08,220
they're not stood functions they're

00:04:05,190 --> 00:04:10,350
completely different lambdas do have a

00:04:08,220 --> 00:04:13,410
couple tricks if you have a stateless

00:04:10,350 --> 00:04:15,989
lambda it can be converted to ordinary

00:04:13,410 --> 00:04:18,390
function pointer but that's not super

00:04:15,989 --> 00:04:20,700
magical you could write conversion

00:04:18,390 --> 00:04:22,470
operator by hand if you know this in tax

00:04:20,700 --> 00:04:24,240
and you have a type def for the function

00:04:22,470 --> 00:04:26,490
pointer so remember a lambda it just

00:04:24,240 --> 00:04:27,150
defines a class constructs an object of

00:04:26,490 --> 00:04:29,100
that class

00:04:27,150 --> 00:04:31,080
it's a class type it's not a built-in

00:04:29,100 --> 00:04:33,600
function it's not a function pointer

00:04:31,080 --> 00:04:36,000
there are some people even people who

00:04:33,600 --> 00:04:39,680
refer to lambdas as anonymous functions

00:04:36,000 --> 00:04:41,220
do not do that or I will make this space

00:04:39,680 --> 00:04:44,220
seriously they're not anonymous

00:04:41,220 --> 00:04:45,780
functions they're classes ok so that's

00:04:44,220 --> 00:04:46,710
the core language feature that's the

00:04:45,780 --> 00:04:49,800
talk I'm going to talk about the

00:04:46,710 --> 00:04:51,870
standard library so instead of doing it

00:04:49,800 --> 00:04:54,139
in chronological order talking about 11

00:04:51,870 --> 00:04:57,690
and 14 and 17 I want to present it in

00:04:54,139 --> 00:04:59,910
logical order and the story begins with

00:04:57,690 --> 00:05:02,520
invoke and now invoke is a function in

00:04:59,910 --> 00:05:04,110
CS plus 17 but you'd still need to

00:05:02,520 --> 00:05:07,020
understand even if you're only using CS

00:05:04,110 --> 00:05:08,220
plus 11 and cos plus 14 and I need to

00:05:07,020 --> 00:05:10,949
introduce a couple of bits of

00:05:08,220 --> 00:05:12,630
terminology terminology and books and

00:05:10,949 --> 00:05:16,289
articles is all over the app people talk

00:05:12,630 --> 00:05:17,669
about function objects functors the

00:05:16,289 --> 00:05:20,430
standard though has very specific

00:05:17,669 --> 00:05:23,190
terminology so the standard a function

00:05:20,430 --> 00:05:25,500
object is an object type that is usable

00:05:23,190 --> 00:05:28,349
like a function and there's three things

00:05:25,500 --> 00:05:30,389
that fall under this banner one is

00:05:28,349 --> 00:05:32,849
function pointers now even going all the

00:05:30,389 --> 00:05:35,400
way back to C 89 thanks to the wisdom of

00:05:32,849 --> 00:05:37,320
Denis M Ritchie you can invoke a

00:05:35,400 --> 00:05:39,660
built-in you know a plain function

00:05:37,320 --> 00:05:41,250
pointer just with parentheses DMR

00:05:39,660 --> 00:05:43,260
basically looks at that and says okay

00:05:41,250 --> 00:05:45,510
and C generally I map everything

00:05:43,260 --> 00:05:47,610
directly to what I'm going to compile

00:05:45,510 --> 00:05:49,409
what the machines gonna execute but if

00:05:47,610 --> 00:05:51,030
you apply parentheses to a function

00:05:49,409 --> 00:05:53,460
pointer what else could you possibly

00:05:51,030 --> 00:05:55,050
mean but B reference this thing and call

00:05:53,460 --> 00:05:56,669
it so I can just do that for you this is

00:05:55,050 --> 00:06:01,020
one of the very few times that C just

00:05:56,669 --> 00:06:02,699
does something helpfully for you and in

00:06:01,020 --> 00:06:04,229
CS plus we now have the ability to

00:06:02,699 --> 00:06:05,639
overload operators so if you have a

00:06:04,229 --> 00:06:08,400
function cooperator on a class it's

00:06:05,639 --> 00:06:11,150
called the like a function c s+ 98 used

00:06:08,400 --> 00:06:14,370
this extensively and lambdas count as

00:06:11,150 --> 00:06:15,419
function objects of class type also if

00:06:14,370 --> 00:06:16,919
you have a class that doesn't have a

00:06:15,419 --> 00:06:18,449
function cooperator but is convertible

00:06:16,919 --> 00:06:20,099
to a function pointer the core language

00:06:18,449 --> 00:06:22,229
is sneaky and says oh i can call that

00:06:20,099 --> 00:06:24,330
too that counts as a function object as

00:06:22,229 --> 00:06:26,370
well now the standard doesn't consider

00:06:24,330 --> 00:06:27,990
references to be object types but if you

00:06:26,370 --> 00:06:30,360
have a reference to a function you can

00:06:27,990 --> 00:06:32,010
form that you can also call that like a

00:06:30,360 --> 00:06:33,900
function and there's one place reference

00:06:32,010 --> 00:06:35,370
wrapper for this matter so I think of

00:06:33,900 --> 00:06:38,550
them as function objects but they're not

00:06:35,370 --> 00:06:40,420
technically objects then the standard

00:06:38,550 --> 00:06:42,370
introduces the terminology of call

00:06:40,420 --> 00:06:43,870
objects so Calma object is something

00:06:42,370 --> 00:06:46,360
that's called will in a generalized

00:06:43,870 --> 00:06:48,610
sense so not just function object that's

00:06:46,360 --> 00:06:50,920
call but with parentheses but also a

00:06:48,610 --> 00:06:52,690
pointer to member function or a pointer

00:06:50,920 --> 00:06:54,160
to member data now you may never seen

00:06:52,690 --> 00:06:55,930
these before in your life but they exist

00:06:54,160 --> 00:06:58,150
all the way back and see us plus 98 and

00:06:55,930 --> 00:07:01,000
they allow you to select a member

00:06:58,150 --> 00:07:02,830
function or a data member of an object

00:07:01,000 --> 00:07:04,930
without knowing that the object is ahead

00:07:02,830 --> 00:07:06,640
of time but the syntax for doing so is

00:07:04,930 --> 00:07:08,560
very strange and also has the long

00:07:06,640 --> 00:07:10,690
precedence in some sense because you

00:07:08,560 --> 00:07:13,510
have to wrap the PMF in parentheses

00:07:10,690 --> 00:07:14,920
before you invoke it it's awful now the

00:07:13,510 --> 00:07:16,690
the reason the standard library

00:07:14,920 --> 00:07:18,280
introduces this terminology is because

00:07:16,690 --> 00:07:19,740
the core language is different syntax

00:07:18,280 --> 00:07:22,270
for these pointers to members and

00:07:19,740 --> 00:07:23,980
function objects now in theory there's

00:07:22,270 --> 00:07:25,600
no reason why the core language couldn't

00:07:23,980 --> 00:07:28,120
do a DMR did and say oh if you try to

00:07:25,600 --> 00:07:29,800
call a PMF with parentheses and give it

00:07:28,120 --> 00:07:32,050
an object as the first argument what

00:07:29,800 --> 00:07:33,910
else could you possibly mean but say God

00:07:32,050 --> 00:07:34,900
star but the core language is not

00:07:33,910 --> 00:07:36,940
helpful

00:07:34,900 --> 00:07:39,640
they make you use different syntax for

00:07:36,940 --> 00:07:41,080
this and that's really awful so the

00:07:39,640 --> 00:07:42,730
standard library says okay I'm going to

00:07:41,080 --> 00:07:44,620
compensate for the deficiencies of the

00:07:42,730 --> 00:07:47,020
core language and I can just invent my

00:07:44,620 --> 00:07:48,910
own awesome world and this awesome world

00:07:47,020 --> 00:07:51,640
is called invoke now this was an

00:07:48,910 --> 00:07:53,500
imaginary function that didn't exist

00:07:51,640 --> 00:07:56,500
wasn't available for users all the way

00:07:53,500 --> 00:07:58,270
back in tier 1 in 2005 and cs+ 11 and 14

00:07:56,500 --> 00:08:00,910
but there was a proposal that was

00:07:58,270 --> 00:08:03,240
recently accepted in CS + 17 to make it

00:08:00,910 --> 00:08:06,730
an actual function that's call by users

00:08:03,240 --> 00:08:08,890
so what does it vogue do you call invoke

00:08:06,730 --> 00:08:10,300
and you give it a callable object as the

00:08:08,890 --> 00:08:13,500
first argument and then a bunch of

00:08:10,300 --> 00:08:15,940
arguments for the call object if the

00:08:13,500 --> 00:08:17,650
callable object is a function object

00:08:15,940 --> 00:08:19,330
then it's just called with parentheses

00:08:17,650 --> 00:08:20,710
very simple but if it's a pointer to

00:08:19,330 --> 00:08:22,630
member function or pointer to member

00:08:20,710 --> 00:08:24,730
data invoke uses template

00:08:22,630 --> 00:08:26,800
metaprogramming and it detects what it

00:08:24,730 --> 00:08:28,960
needs to do and it's very intelligent

00:08:26,800 --> 00:08:31,390
not only can it distinguish between PMS

00:08:28,960 --> 00:08:34,750
and PM DS but if you give it a reference

00:08:31,390 --> 00:08:36,790
to an object versus a raw pointer to an

00:08:34,750 --> 00:08:38,770
object versus a smart pointer to an

00:08:36,790 --> 00:08:41,500
object invoke will just do the right

00:08:38,770 --> 00:08:43,660
thing it has five different expressions

00:08:41,500 --> 00:08:46,150
that it can compile it also is aware of

00:08:43,660 --> 00:08:47,320
base and derived pointers to member data

00:08:46,150 --> 00:08:50,260
if you think about this it's really

00:08:47,320 --> 00:08:52,660
nasty but invoked as does it all and

00:08:50,260 --> 00:08:53,769
it's extendable in the sense that it

00:08:52,660 --> 00:08:57,100
knows nothing actually about

00:08:53,769 --> 00:08:58,899
out smart pointers so you can call it

00:08:57,100 --> 00:09:00,429
with a unique putter a shared put or if

00:08:58,899 --> 00:09:02,499
you have your own user-defined smart

00:09:00,429 --> 00:09:04,629
pointer as long as its D referenceable

00:09:02,499 --> 00:09:06,699
invoke will work with it so if you have

00:09:04,629 --> 00:09:08,199
a C computer or some QT smart point or

00:09:06,699 --> 00:09:10,420
something invoke will totally work with

00:09:08,199 --> 00:09:13,179
that basically if it's not an object it

00:09:10,420 --> 00:09:15,069
assumes it's a raw pointer so here's an

00:09:13,179 --> 00:09:17,379
example of usage where you might

00:09:15,069 --> 00:09:19,929
actually want to use it in your code now

00:09:17,379 --> 00:09:21,819
this is not a super helpful function but

00:09:19,929 --> 00:09:24,249
at least does something I'm here I'm

00:09:21,819 --> 00:09:25,360
writing a range based algorithm and what

00:09:24,249 --> 00:09:28,480
I want to do is I want to iterate over

00:09:25,360 --> 00:09:30,220
every element and I want to transform it

00:09:28,480 --> 00:09:31,059
according to some callable object and

00:09:30,220 --> 00:09:32,410
then just print it out

00:09:31,059 --> 00:09:33,699
I could also insert it into some

00:09:32,410 --> 00:09:36,819
sequence or something by figure I just

00:09:33,699 --> 00:09:38,470
printed out so here I write transferred

00:09:36,819 --> 00:09:40,449
friend to pick sconce range ref it takes

00:09:38,470 --> 00:09:41,949
a call Bowl traditionally an STL we took

00:09:40,449 --> 00:09:44,319
all of objects by value I could do it

00:09:41,949 --> 00:09:45,879
differently and then for every element I

00:09:44,319 --> 00:09:48,189
just call invoke and I give it the call

00:09:45,879 --> 00:09:50,619
about object and then the element and by

00:09:48,189 --> 00:09:52,420
doing this I can now call my transform

00:09:50,619 --> 00:09:54,459
print function with either a function

00:09:52,420 --> 00:09:56,739
object like a lambda here IVA lambda

00:09:54,459 --> 00:09:59,110
that takes a pair and squares its first

00:09:56,739 --> 00:10:00,879
element or I could pass anything else

00:09:59,110 --> 00:10:02,829
that fits the definition of a call but

00:10:00,879 --> 00:10:05,589
object like a partner to member function

00:10:02,829 --> 00:10:07,029
or pointer to member data technically in

00:10:05,589 --> 00:10:08,799
the standard library you can't take the

00:10:07,029 --> 00:10:09,970
address of a standard library member

00:10:08,799 --> 00:10:13,329
function but you can't take the address

00:10:09,970 --> 00:10:15,970
of payers data members so I can print

00:10:13,329 --> 00:10:18,249
out the second element of each pair just

00:10:15,970 --> 00:10:19,899
by passing a PMD and invoke just does

00:10:18,249 --> 00:10:22,059
the right thing whereas if I tried to

00:10:19,899 --> 00:10:24,839
call C with parentheses then the lambda

00:10:22,059 --> 00:10:28,149
would work but the PMD would fail to

00:10:24,839 --> 00:10:29,889
compile so the reason why I invoke is

00:10:28,149 --> 00:10:31,990
necessary is going all the way back to

00:10:29,889 --> 00:10:33,519
cos plus 11 many things in the standard

00:10:31,990 --> 00:10:35,259
library use invoke and here's an

00:10:33,519 --> 00:10:36,459
exhaustive list of everything in the STL

00:10:35,259 --> 00:10:38,740
that uses invoke it's a bunch of stuff

00:10:36,459 --> 00:10:41,379
I'll be talking about all the stuff on

00:10:38,740 --> 00:10:42,639
the Left column today the things on the

00:10:41,379 --> 00:10:46,059
right and the multi-threading headers

00:10:42,639 --> 00:10:47,860
also use invoke so once you know oh I

00:10:46,059 --> 00:10:49,569
can use you on pmf's and PMT's like this

00:10:47,860 --> 00:10:51,489
you can give them to things like call

00:10:49,569 --> 00:10:54,339
once or stood thread and because they

00:10:51,489 --> 00:10:57,220
follow the invoke protocol it'll just

00:10:54,339 --> 00:10:58,629
work okay so some recommendations I

00:10:57,220 --> 00:11:00,339
promised I'd be talking about proper

00:10:58,629 --> 00:11:02,769
usage in addition just what the stuff

00:11:00,339 --> 00:11:05,139
does now if you don't write generic code

00:11:02,769 --> 00:11:06,339
then invoke is not super useful because

00:11:05,139 --> 00:11:08,230
if you know

00:11:06,339 --> 00:11:10,810
the type of your callable object you

00:11:08,230 --> 00:11:13,629
also know the syntax needed to invoke it

00:11:10,810 --> 00:11:15,970
but if you really really hate pmf syntax

00:11:13,629 --> 00:11:19,839
like you just cannot type paren object's

00:11:15,970 --> 00:11:21,100
star PM f / n / in args and yeah I have

00:11:19,839 --> 00:11:22,360
some sympathy for that then you can use

00:11:21,100 --> 00:11:24,970
a vote you know it will just do the

00:11:22,360 --> 00:11:28,240
right thing but invoke really shines in

00:11:24,970 --> 00:11:30,220
generic code where you can just take and

00:11:28,240 --> 00:11:32,589
potentially store arbitrary call BA

00:11:30,220 --> 00:11:34,480
objects and arguments that you need to

00:11:32,589 --> 00:11:36,939
give to it you give it to invoke and you

00:11:34,480 --> 00:11:39,160
let it decide what to do this is very

00:11:36,939 --> 00:11:41,170
simple to do and we use it now in the

00:11:39,160 --> 00:11:44,199
standard libraries implementation don't

00:11:41,170 --> 00:11:46,389
try to write helper code to detect PMS

00:11:44,199 --> 00:11:48,730
PM DS and dispatch on them it is an

00:11:46,389 --> 00:11:50,920
absolute nightmare PMF types are the

00:11:48,730 --> 00:11:52,389
worst types by far in the core language

00:11:50,920 --> 00:11:54,100
because they can be sieved qualify they

00:11:52,389 --> 00:11:56,499
can ruff qualified they can have

00:11:54,100 --> 00:11:59,439
ellipses you've got base and derived it

00:11:56,499 --> 00:12:01,059
is nasty so just give them to invoke let

00:11:59,439 --> 00:12:01,800
your standard library implementer deal

00:12:01,059 --> 00:12:05,170
with the headaches

00:12:01,800 --> 00:12:06,730
so that's invoke and even if you aren't

00:12:05,170 --> 00:12:09,189
using sis + 17 you still need to know

00:12:06,730 --> 00:12:11,589
how it works because everything else in

00:12:09,189 --> 00:12:14,769
functional almost everything else uses

00:12:11,589 --> 00:12:16,269
it okay so result of is actually not

00:12:14,769 --> 00:12:17,920
technically and functional but we need

00:12:16,269 --> 00:12:20,139
to talk about it because it's strongly

00:12:17,920 --> 00:12:21,730
associated with VOC and things that

00:12:20,139 --> 00:12:25,269
speak invoke and it gained a couple

00:12:21,730 --> 00:12:27,670
powers in CS plus 14 so result of is the

00:12:25,269 --> 00:12:29,379
type trait that corresponds to invoke it

00:12:27,670 --> 00:12:30,879
actually didn't live in the functional

00:12:29,379 --> 00:12:32,439
header err back into your one but it got

00:12:30,879 --> 00:12:34,870
moved to type traits which is probably

00:12:32,439 --> 00:12:36,759
where it does belong in CS + 11 n has

00:12:34,870 --> 00:12:37,839
remained there since then so the first

00:12:36,759 --> 00:12:39,399
thing that everybody tries with the

00:12:37,839 --> 00:12:41,170
result of is they try to ask okay what's

00:12:39,399 --> 00:12:43,089
the result of this function object you

00:12:41,170 --> 00:12:45,069
cannot ask this question it is a

00:12:43,089 --> 00:12:47,860
compiler error and the reason why is

00:12:45,069 --> 00:12:50,410
because the result of invoking Alba

00:12:47,860 --> 00:12:52,029
object depends in general on the

00:12:50,410 --> 00:12:54,309
arguments that you give it for example a

00:12:52,029 --> 00:12:56,019
function object could have a templated

00:12:54,309 --> 00:12:57,850
flush call operator especially like a

00:12:56,019 --> 00:13:00,069
generic lambda it could have an

00:12:57,850 --> 00:13:01,540
overloaded function call operator so you

00:13:00,069 --> 00:13:03,519
need to ask what is the result of

00:13:01,540 --> 00:13:05,889
invoking this call by object with

00:13:03,519 --> 00:13:08,290
so-and-so arguments and once you provide

00:13:05,889 --> 00:13:10,449
the arguments then result of is defined

00:13:08,290 --> 00:13:12,399
as the deckle type of an invoke

00:13:10,449 --> 00:13:14,230
expression and the standard says it's

00:13:12,399 --> 00:13:16,809
invoke called with deco Val callable

00:13:14,230 --> 00:13:18,459
deco val is this imaginary function that

00:13:16,809 --> 00:13:19,990
lives in the STL it's actually declared

00:13:18,459 --> 00:13:21,250
and provided to users

00:13:19,990 --> 00:13:23,500
but it's never defined it doesn't

00:13:21,250 --> 00:13:25,209
physically exist it exists only for the

00:13:23,500 --> 00:13:28,270
purposes of deco type to say what if I

00:13:25,209 --> 00:13:30,100
had an object of this type I've actually

00:13:28,270 --> 00:13:32,860
had users complain I can't call stood

00:13:30,100 --> 00:13:33,670
echo van yeah the crisp eyes it's not

00:13:32,860 --> 00:13:35,770
implemented

00:13:33,670 --> 00:13:41,470
I love users they keep me employed and

00:13:35,770 --> 00:13:44,050
entertained and in sales +14 result to

00:13:41,470 --> 00:13:46,540
have gained a power that if you say call

00:13:44,050 --> 00:13:49,180
bowl with arms but it's not actually

00:13:46,540 --> 00:13:51,610
callable the double cone type will spin

00:13:49,180 --> 00:13:54,100
a away and you can essentially ask is

00:13:51,610 --> 00:13:55,570
this thing call belit all in CS plus 11

00:13:54,100 --> 00:13:57,880
it was a hard requirement that the thing

00:13:55,570 --> 00:14:00,850
be callable and then you could get its

00:13:57,880 --> 00:14:03,220
type so here's an example I think really

00:14:00,850 --> 00:14:05,500
hard to show an example that was

00:14:03,220 --> 00:14:09,760
somewhat natural and not simply

00:14:05,500 --> 00:14:11,709
superseded by Otto and deco type Otto so

00:14:09,760 --> 00:14:13,990
here I've got another sort of transfer

00:14:11,709 --> 00:14:16,660
function here coding it to work only

00:14:13,990 --> 00:14:19,240
with vector of T and I'm going to take

00:14:16,660 --> 00:14:21,100
another arbitrary callable object what I

00:14:19,240 --> 00:14:25,720
want to do is I want to transform each

00:14:21,100 --> 00:14:27,579
TLM tht element of my vector through

00:14:25,720 --> 00:14:29,950
this callable object and I'd like to

00:14:27,579 --> 00:14:31,899
push it back into another vector then I

00:14:29,950 --> 00:14:35,140
would like to sort the transformed

00:14:31,899 --> 00:14:38,230
elements and return that so I need to be

00:14:35,140 --> 00:14:40,930
able to ask what is the type of calling

00:14:38,230 --> 00:14:43,060
the kaabah object on my t's so I can

00:14:40,930 --> 00:14:45,310
make a vector of that type sort it and

00:14:43,060 --> 00:14:46,930
then return it and just to avoid

00:14:45,310 --> 00:14:49,149
repeating code I'm going to use cs plus

00:14:46,930 --> 00:14:52,990
14 auto return but I could span out the

00:14:49,149 --> 00:14:54,640
vector to KT blah blah blah so the way

00:14:52,990 --> 00:14:56,230
that I call it is I have a vector string

00:14:54,640 --> 00:14:58,060
I have a lambda that's just going to

00:14:56,230 --> 00:15:00,160
take a string and return it sighs I'm

00:14:58,060 --> 00:15:01,870
here to sort of avoids just plus 14

00:15:00,160 --> 00:15:03,700
overload I've made it

00:15:01,870 --> 00:15:05,529
just take a hard-coded constant graph

00:15:03,700 --> 00:15:07,750
but I could say Auto that Constanta ref

00:15:05,529 --> 00:15:11,290
and then I get arrayed through the

00:15:07,750 --> 00:15:12,970
transform vector and print it out so the

00:15:11,290 --> 00:15:16,000
crucial bit I've highlighted here what

00:15:12,970 --> 00:15:18,339
is the element type of ret I need to ask

00:15:16,000 --> 00:15:22,149
what's the result of invoking callable

00:15:18,339 --> 00:15:24,880
ref on consti ref but that Calma object

00:15:22,149 --> 00:15:27,130
might return say a Const int ref I can't

00:15:24,880 --> 00:15:29,770
have a vector of references and I can't

00:15:27,130 --> 00:15:32,140
have a vector of constants either so I

00:15:29,770 --> 00:15:32,950
need to use stood decay T which is a

00:15:32,140 --> 00:15:34,990
type trait

00:15:32,950 --> 00:15:36,700
that will strip off references and

00:15:34,990 --> 00:15:39,880
top-level CD qualifier so I can get a

00:15:36,700 --> 00:15:42,070
vector of the non-reference II the

00:15:39,880 --> 00:15:44,190
unqualified type of whatever returns so

00:15:42,070 --> 00:15:46,690
this works and it's perfectly generic

00:15:44,190 --> 00:15:49,990
but you'll notice I had to say call Bowl

00:15:46,690 --> 00:15:52,060
ref and consti ref there result-type is

00:15:49,990 --> 00:15:53,770
actually surprisingly tricky because it

00:15:52,060 --> 00:15:55,960
answers you what's the type of this

00:15:53,770 --> 00:15:58,270
invoke expression but it uses radically

00:15:55,960 --> 00:16:00,160
different syntax from the actual call if

00:15:58,270 --> 00:16:03,190
you look back at the example here I said

00:16:00,160 --> 00:16:05,140
invoke lowercase C comma T but the

00:16:03,190 --> 00:16:07,300
syntax for result of was totally

00:16:05,140 --> 00:16:08,440
different and you have to verify that

00:16:07,300 --> 00:16:10,690
they correspond and that's actually

00:16:08,440 --> 00:16:12,940
surprisingly tricky because the Seebeck

00:16:10,690 --> 00:16:14,410
qualifiers and the value categories that

00:16:12,940 --> 00:16:15,910
you give to invoke expression value

00:16:14,410 --> 00:16:18,040
categories as l value Nisour are

00:16:15,910 --> 00:16:19,810
valueless they matter functions could be

00:16:18,040 --> 00:16:22,780
overloaded to do different things based

00:16:19,810 --> 00:16:24,760
on the constants or the value category

00:16:22,780 --> 00:16:26,470
and in CS plus 11 you can have ref

00:16:24,760 --> 00:16:28,810
qualified member functions so functors

00:16:26,470 --> 00:16:31,060
function objects can be sensitive to

00:16:28,810 --> 00:16:32,470
whether their l values are values and if

00:16:31,060 --> 00:16:34,600
you get it wrong it may appear to work

00:16:32,470 --> 00:16:36,220
except if somebody calls you with a

00:16:34,600 --> 00:16:39,910
sufficiently weird argument it would

00:16:36,220 --> 00:16:41,470
fail to compile and also if you are not

00:16:39,910 --> 00:16:43,780
just using invoke directly but something

00:16:41,470 --> 00:16:45,640
like bind then bind manipulates its

00:16:43,780 --> 00:16:48,100
arguments before calling invoke stat

00:16:45,640 --> 00:16:49,960
acing does decay result of will not do

00:16:48,100 --> 00:16:51,790
any of that so you would need to do such

00:16:49,960 --> 00:16:53,470
transformations by hand I've seen people

00:16:51,790 --> 00:16:54,910
try to use a result of when they're

00:16:53,470 --> 00:16:57,010
actually giving something to bind and

00:16:54,910 --> 00:16:59,350
that in general is incorrect I can give

00:16:57,010 --> 00:17:02,590
you a placeholder and now your result of

00:16:59,350 --> 00:17:04,720
is incorrect result of it dates all the

00:17:02,590 --> 00:17:06,579
way back to TR 1 which was a library

00:17:04,720 --> 00:17:08,709
only addition to CS plus 98 or 3 it was

00:17:06,579 --> 00:17:12,150
extremely useful then before we had deco

00:17:08,709 --> 00:17:15,430
type and all this L value R value stuff

00:17:12,150 --> 00:17:18,910
but it really has not kept up with the

00:17:15,430 --> 00:17:21,610
times so what I recommend is avoid using

00:17:18,910 --> 00:17:23,350
result of if you can use deco type

00:17:21,610 --> 00:17:25,990
directly there are some cases where you

00:17:23,350 --> 00:17:27,010
do you don't never need to use result of

00:17:25,990 --> 00:17:28,930
because you could always write the deco

00:17:27,010 --> 00:17:31,480
type behan sometimes results of could be

00:17:28,930 --> 00:17:33,220
convenient but just be careful if you

00:17:31,480 --> 00:17:35,200
use it and if you have existing usage in

00:17:33,220 --> 00:17:37,120
your code base go back home go look it

00:17:35,200 --> 00:17:39,490
up in your source control and I bet you

00:17:37,120 --> 00:17:41,680
you're gonna find bugs look carefully at

00:17:39,490 --> 00:17:44,080
the value categories that you're giving

00:17:41,680 --> 00:17:45,870
for example in this code if I simply

00:17:44,080 --> 00:17:48,240
said result of call

00:17:45,870 --> 00:17:50,580
Parenti that would be incorrect because

00:17:48,240 --> 00:17:53,070
it would be asking what is the result of

00:17:50,580 --> 00:17:55,470
invoking an r-value callable on an

00:17:53,070 --> 00:17:57,450
r-value t and that could be different

00:17:55,470 --> 00:18:01,020
from the actual invocation which is

00:17:57,450 --> 00:18:03,240
invoking L values so you may find bugs

00:18:01,020 --> 00:18:05,370
in your code I've seen too many to count

00:18:03,240 --> 00:18:07,590
I recommend just using deco type

00:18:05,370 --> 00:18:08,880
directly or auto and if you're a generic

00:18:07,590 --> 00:18:11,280
programmer you already need to know that

00:18:08,880 --> 00:18:13,620
stuff so it's not an extra burden of

00:18:11,280 --> 00:18:14,940
understanding the general principle here

00:18:13,620 --> 00:18:17,040
is if you need to compute information

00:18:14,940 --> 00:18:19,200
don't do it through different mechanisms

00:18:17,040 --> 00:18:21,750
and if you need to repeatedly compute it

00:18:19,200 --> 00:18:23,730
and sometimes that's necessary try to

00:18:21,750 --> 00:18:25,559
just exactly repeat text because at

00:18:23,730 --> 00:18:27,090
least you can verify that by looking at

00:18:25,559 --> 00:18:29,580
the source code if you need to do some

00:18:27,090 --> 00:18:31,230
sort of mental transformation to verify

00:18:29,580 --> 00:18:33,870
this one thing corresponds to this other

00:18:31,230 --> 00:18:35,460
thing you're very likely to get wrong

00:18:33,870 --> 00:18:38,580
and even if you get a right it's going

00:18:35,460 --> 00:18:41,280
to be more work than necessary okay so

00:18:38,580 --> 00:18:44,600
that's result of now let's talk about

00:18:41,280 --> 00:18:46,679
mem Finn which was added in CSS 11

00:18:44,600 --> 00:18:49,770
replacing some older stuff that I'll

00:18:46,679 --> 00:18:50,970
talk about later in CS plus 98 so here

00:18:49,770 --> 00:18:52,350
is usage I didn't even bother to

00:18:50,970 --> 00:18:55,230
actually vote count medals it's pretty

00:18:52,350 --> 00:18:56,790
simple I have a structure class it's got

00:18:55,230 --> 00:19:00,090
a member function that returns a bool

00:18:56,790 --> 00:19:02,070
and then I want to use an sto algorithm

00:19:00,090 --> 00:19:03,900
and have it call that member function so

00:19:02,070 --> 00:19:06,330
I'd like to call count if on every

00:19:03,900 --> 00:19:08,520
element of a vector and ask hey are you

00:19:06,330 --> 00:19:10,410
metallic now if I just tried to pass a

00:19:08,520 --> 00:19:12,270
pointer to member function or PMF we

00:19:10,410 --> 00:19:13,770
would fail to compile and the compiler

00:19:12,270 --> 00:19:16,320
error would say something like I can't

00:19:13,770 --> 00:19:19,440
call this pmf with parentheses because

00:19:16,320 --> 00:19:22,620
the core language hates you okay the

00:19:19,440 --> 00:19:24,150
answer is you can just cast it to infant

00:19:22,620 --> 00:19:25,800
and Men fun is a function in the

00:19:24,150 --> 00:19:28,140
standard library it takes a PMF and

00:19:25,800 --> 00:19:30,540
wraps it in a function object because

00:19:28,140 --> 00:19:33,690
stl algorithms expect function objects

00:19:30,540 --> 00:19:35,220
not arbitrary callable objects and then

00:19:33,690 --> 00:19:36,540
this allows it to be invoked with

00:19:35,220 --> 00:19:40,170
parentheses so this is actually very

00:19:36,540 --> 00:19:42,090
convenient but it actually breaks down

00:19:40,170 --> 00:19:44,040
if you look at it real closely so the

00:19:42,090 --> 00:19:48,420
good thing about Memphis is that it's

00:19:44,040 --> 00:19:50,250
very terse it's usually not possible to

00:19:48,420 --> 00:19:53,460
write less code than just Memphis

00:19:50,250 --> 00:19:55,590
address class double call block but it

00:19:53,460 --> 00:19:57,540
has some downsides a hidden downside is

00:19:55,590 --> 00:19:58,980
that it's actually going to make your

00:19:57,540 --> 00:20:01,110
code slower

00:19:58,980 --> 00:20:02,610
the time because it needs to store that

00:20:01,110 --> 00:20:05,040
pointer de member function as a data

00:20:02,610 --> 00:20:06,660
member and optimizers have difficulty

00:20:05,040 --> 00:20:08,460
seeing that a date a member of our class

00:20:06,660 --> 00:20:10,860
was initialized to some constant and

00:20:08,460 --> 00:20:12,690
then used later at least I talked to

00:20:10,860 --> 00:20:14,460
VC's back and dads and they said wow

00:20:12,690 --> 00:20:16,950
that's a really pretty fundamental

00:20:14,460 --> 00:20:18,450
limitation in our optimizer we might fix

00:20:16,950 --> 00:20:20,910
that but don't expect it you know

00:20:18,450 --> 00:20:23,549
anytime soon I don't know what the other

00:20:20,910 --> 00:20:25,500
compilers do but certainly if you write

00:20:23,549 --> 00:20:27,390
such code it won't be portably optimized

00:20:25,500 --> 00:20:28,620
and in any event you're gonna make the

00:20:27,390 --> 00:20:31,799
optimizer work harder than it has to

00:20:28,620 --> 00:20:33,419
also in general this will not compile if

00:20:31,799 --> 00:20:35,610
the code is weird enough if the member

00:20:33,419 --> 00:20:38,220
function becomes overloaded then simply

00:20:35,610 --> 00:20:39,960
saying address of the name of the member

00:20:38,220 --> 00:20:41,850
function is now ambiguous and you need

00:20:39,960 --> 00:20:43,470
to static cast to disambiguate which one

00:20:41,850 --> 00:20:45,270
you want same thing if the member

00:20:43,470 --> 00:20:46,380
function is templated I talked in an

00:20:45,270 --> 00:20:48,120
earlier talk you don't want to use

00:20:46,380 --> 00:20:50,460
explicitly arguments there you need to

00:20:48,120 --> 00:20:52,440
use that static cast to be really

00:20:50,460 --> 00:20:54,360
general and it's just awful to type that

00:20:52,440 --> 00:20:55,679
thing and if you have default arguments

00:20:54,360 --> 00:20:57,540
the signature of the thing isn't

00:20:55,679 --> 00:21:01,200
actually corresponding to what's going

00:20:57,540 --> 00:21:04,049
to be invoked so it breaks down as soon

00:21:01,200 --> 00:21:05,549
as the code is extended and I've also

00:21:04,049 --> 00:21:07,440
observed people doing things like

00:21:05,549 --> 00:21:10,500
calling mem Fionn only to give it to

00:21:07,440 --> 00:21:13,080
bind but behind already speaks invoke so

00:21:10,500 --> 00:21:15,660
you don't need to ramp pmf's when you

00:21:13,080 --> 00:21:18,179
give things to bind or stood function so

00:21:15,660 --> 00:21:19,590
something is in this CS plus 11

00:21:18,179 --> 00:21:21,840
functional stuff you don't need mem fin

00:21:19,590 --> 00:21:22,980
at all you only need it or something

00:21:21,840 --> 00:21:25,140
equivalent when you're talking to

00:21:22,980 --> 00:21:27,630
something like SPL algorithms from 98

00:21:25,140 --> 00:21:29,850
that expect function objects with

00:21:27,630 --> 00:21:32,400
parentheses so my recommendation is to

00:21:29,850 --> 00:21:33,929
avoid Memphis now it's not super

00:21:32,400 --> 00:21:35,460
horrible you can use it with a pretty

00:21:33,929 --> 00:21:37,440
clear conscience

00:21:35,460 --> 00:21:39,660
but the thing is if you're giving a

00:21:37,440 --> 00:21:41,070
member function to an s2 algorithm you

00:21:39,660 --> 00:21:42,390
probably care about the performance

00:21:41,070 --> 00:21:44,760
because it's going to call that for

00:21:42,390 --> 00:21:46,200
every element of your sequence and it's

00:21:44,760 --> 00:21:48,630
going to be maybe a million elements or

00:21:46,200 --> 00:21:50,790
knows that performance may matter and

00:21:48,630 --> 00:21:52,080
the fact that it just breaks down when

00:21:50,790 --> 00:21:54,840
code evolves that's pretty inconvenient

00:21:52,080 --> 00:21:57,330
so now that we have CSS 11 lambdas and

00:21:54,840 --> 00:21:59,580
14 generic lambdas and so forth what I

00:21:57,330 --> 00:22:02,640
recommend is writing a lambda to call

00:21:59,580 --> 00:22:04,830
that member function for you yeah it'll

00:22:02,640 --> 00:22:06,240
be a little bit more typing but it's

00:22:04,830 --> 00:22:08,600
going to optimize away because the body

00:22:06,240 --> 00:22:11,580
of the lambda is just an ordinary

00:22:08,600 --> 00:22:13,230
function call operator and the optimizer

00:22:11,580 --> 00:22:15,600
can hopefully see through that in inline

00:22:13,230 --> 00:22:16,950
that without having to figure out that

00:22:15,600 --> 00:22:18,840
some data member is always some

00:22:16,950 --> 00:22:19,950
particular pmf and it continues to

00:22:18,840 --> 00:22:23,580
compile because it's just an ordinary

00:22:19,950 --> 00:22:25,950
function call okay so another feature

00:22:23,580 --> 00:22:28,740
those add Macias plus 14 are is the

00:22:25,950 --> 00:22:29,760
transparent operator func groups they're

00:22:28,740 --> 00:22:31,890
not actually named so in the standard

00:22:29,760 --> 00:22:33,720
that's just how I think of them here's a

00:22:31,890 --> 00:22:35,909
quick example imagine I had a vector in

00:22:33,720 --> 00:22:37,980
filled with stuff a vector string and if

00:22:35,909 --> 00:22:40,380
I want to sort them in reverse order

00:22:37,980 --> 00:22:43,049
stood sort has always defaulted to stood

00:22:40,380 --> 00:22:45,929
less that sorts things in ascending

00:22:43,049 --> 00:22:48,570
order where every element is less than

00:22:45,929 --> 00:22:50,010
the next element if it's different if I

00:22:48,570 --> 00:22:52,200
want a reversal I need to pass greater

00:22:50,010 --> 00:22:53,909
so in suza plus 98 and 11 I would have

00:22:52,200 --> 00:22:56,220
had to say greater int and greater

00:22:53,909 --> 00:22:58,799
string it's just plus 14 I can simply

00:22:56,220 --> 00:23:00,809
omit the type and just say greater empty

00:22:58,799 --> 00:23:02,880
diamonds I need to say the diamonds

00:23:00,809 --> 00:23:05,460
because it's a template and I can't

00:23:02,880 --> 00:23:06,990
admit it I really wish I could but you

00:23:05,460 --> 00:23:08,340
can just omit the type and you can just

00:23:06,990 --> 00:23:09,600
say sort by great earnest there's no

00:23:08,340 --> 00:23:11,250
reason to repeat the type because the

00:23:09,600 --> 00:23:13,559
compiler already knows hey this is an

00:23:11,250 --> 00:23:15,480
iterator into a vector in its and then I

00:23:13,559 --> 00:23:18,630
can just print them out so I've talked

00:23:15,480 --> 00:23:20,250
about this at CP Con 2014 and growing

00:23:18,630 --> 00:23:23,159
native 2013 so you can look at those

00:23:20,250 --> 00:23:24,840
talks they and slides they go into

00:23:23,159 --> 00:23:27,120
extensive detail about the transport

00:23:24,840 --> 00:23:29,940
operator functors and they enable a cool

00:23:27,120 --> 00:23:31,500
trick in the containers call in the map

00:23:29,940 --> 00:23:33,419
and set family called heterogeneous

00:23:31,500 --> 00:23:35,909
associative lookup so I won't spend more

00:23:33,419 --> 00:23:38,280
time on that my recommendation is to use

00:23:35,909 --> 00:23:40,950
the transparent diamond operator

00:23:38,280 --> 00:23:42,570
functors by default there's no reason to

00:23:40,950 --> 00:23:44,460
repeat that type the only case you would

00:23:42,570 --> 00:23:47,070
ever want to use the old style grader T

00:23:44,460 --> 00:23:50,010
and so forth is if you want implicit

00:23:47,070 --> 00:23:51,480
conversions to that particular T before

00:23:50,010 --> 00:23:53,929
calling the operator and that's

00:23:51,480 --> 00:23:56,580
extremely rare it's usually undesirable

00:23:53,929 --> 00:23:57,540
because if you don't perform those

00:23:56,580 --> 00:24:00,000
conversions you're going to make

00:23:57,540 --> 00:24:02,190
yourself immune which is good to things

00:24:00,000 --> 00:24:05,580
like truncation bugs my usual example is

00:24:02,190 --> 00:24:08,909
what if I'm sorting a vector of you in

00:24:05,580 --> 00:24:11,400
30 toons and I pass greater u and 32 and

00:24:08,909 --> 00:24:14,100
then later the vector is changed to bu

00:24:11,400 --> 00:24:16,559
and 64 if you don't change your

00:24:14,100 --> 00:24:18,090
comparator then every time you invoke it

00:24:16,559 --> 00:24:20,909
you're going to get a conversion which

00:24:18,090 --> 00:24:23,040
truncates from 64-bit to 32-bit it will

00:24:20,909 --> 00:24:24,390
happily compile in a limited truncation

00:24:23,040 --> 00:24:26,429
warning maybe

00:24:24,390 --> 00:24:28,410
but that's bad shouldn't compile in the

00:24:26,429 --> 00:24:29,910
first place or it should do the right

00:24:28,410 --> 00:24:31,860
thing and the greater diamond does the

00:24:29,910 --> 00:24:33,990
right thing it also avoids efficiency

00:24:31,860 --> 00:24:35,700
problems like temporaries and copies now

00:24:33,990 --> 00:24:37,020
you might be asking okay what's the

00:24:35,700 --> 00:24:38,820
difference between mem phone which I'm

00:24:37,020 --> 00:24:40,289
saying is not so cool and the

00:24:38,820 --> 00:24:42,210
transparent operator functors which I'm

00:24:40,289 --> 00:24:44,520
saying are cool the difference is that

00:24:42,210 --> 00:24:46,289
operators in some sense are all known in

00:24:44,520 --> 00:24:48,210
advance there's a finite list you know

00:24:46,289 --> 00:24:50,789
less than greater than plus multiplies

00:24:48,210 --> 00:24:52,919
and the library can provide perfect

00:24:50,789 --> 00:24:54,660
definitions that are templated to accept

00:24:52,919 --> 00:24:56,640
arbitrary stuff they return arbitrary

00:24:54,660 --> 00:24:57,750
stuff they don't store any data members

00:24:56,640 --> 00:24:59,549
they're not vulnerable to all the

00:24:57,750 --> 00:25:01,169
problems of Memphis which has to work

00:24:59,549 --> 00:25:03,330
with a pointer to member function or

00:25:01,169 --> 00:25:05,669
data that's not known in advance that's

00:25:03,330 --> 00:25:08,360
why these operator functors are good to

00:25:05,669 --> 00:25:11,850
use and mem phone is not so good to use

00:25:08,360 --> 00:25:13,770
so now let's talk about bind bind was

00:25:11,850 --> 00:25:15,210
added into your Juan and soos Plus 11

00:25:13,770 --> 00:25:18,240
and it's remained it has not really

00:25:15,210 --> 00:25:19,860
enhanced in power since then there have

00:25:18,240 --> 00:25:21,860
been some proposals to extend by and

00:25:19,860 --> 00:25:25,230
I'll go on about what I think about that

00:25:21,860 --> 00:25:26,760
here's an example of using bind and bind

00:25:25,230 --> 00:25:28,919
is actually pretty terse when you look

00:25:26,760 --> 00:25:31,260
at it but you got to learn what it does

00:25:28,919 --> 00:25:33,500
so here I've got a bunch of intz and I

00:25:31,260 --> 00:25:36,600
want to count how many are less than 50

00:25:33,500 --> 00:25:37,830
so I can say bind less in here I can

00:25:36,600 --> 00:25:40,130
just say less diamond but I could also

00:25:37,830 --> 00:25:43,830
say less end and I need to say is

00:25:40,130 --> 00:25:46,710
underscore 1 less than 50 and underscore

00:25:43,830 --> 00:25:49,350
1 is a placeholder and what this mind

00:25:46,710 --> 00:25:52,890
expression does is it makes a function

00:25:49,350 --> 00:25:55,110
object that binds less and leaves the

00:25:52,890 --> 00:25:56,909
first parameter unbound and that will

00:25:55,110 --> 00:25:58,860
actually be provided by each element to

00:25:56,909 --> 00:26:01,020
the sequence but it binds the second one

00:25:58,860 --> 00:26:03,450
to always be 50 so this function object

00:26:01,020 --> 00:26:06,120
is going to ask is 1 less than 50 is 4

00:26:03,450 --> 00:26:08,549
less than 50 is 9 less than 50 and so

00:26:06,120 --> 00:26:10,890
forth if I reverse the order of the

00:26:08,549 --> 00:26:13,140
parameters I'm going to ask is 50 less

00:26:10,890 --> 00:26:14,549
than the first element is 50 less than

00:26:13,140 --> 00:26:16,020
the second element and so forth and I'll

00:26:14,549 --> 00:26:17,640
get different answers because there's

00:26:16,020 --> 00:26:20,549
different numbers that are less than 50

00:26:17,640 --> 00:26:23,400
or essentially greater than 50 here so

00:26:20,549 --> 00:26:26,039
that's what bind us so I tried to fit

00:26:23,400 --> 00:26:28,169
and I succeeded all of what bind does

00:26:26,039 --> 00:26:29,760
onto a single slide but it's a pretty

00:26:28,169 --> 00:26:32,970
dense slide because binding does a ton

00:26:29,760 --> 00:26:34,409
of stuff and if you've not implemented

00:26:32,970 --> 00:26:35,640
bind it can be sort of overwhelming

00:26:34,409 --> 00:26:37,670
especially look if you look at the

00:26:35,640 --> 00:26:39,440
standard eaves so

00:26:37,670 --> 00:26:41,480
for completeness I did want to mention

00:26:39,440 --> 00:26:43,700
what bind does you give bind a callable

00:26:41,480 --> 00:26:46,700
object and then you immediately give it

00:26:43,700 --> 00:26:48,920
arguments that will be bound to it like

00:26:46,700 --> 00:26:50,510
here I'm gonna bind underscore one and

00:26:48,920 --> 00:26:53,930
50 but I could also fully bind you I

00:26:50,510 --> 00:26:55,100
could say buying 49 comma 50 now we get

00:26:53,930 --> 00:26:57,860
a function object that takes no

00:26:55,100 --> 00:26:59,990
arguments and always calls less with 49

00:26:57,860 --> 00:27:01,520
50 not super useful there but elsewhere

00:26:59,990 --> 00:27:03,980
it could be useful to bind all arguments

00:27:01,520 --> 00:27:05,750
at a time later you call B with any

00:27:03,980 --> 00:27:09,080
additional arguments those are called

00:27:05,750 --> 00:27:10,910
the unbound arguments so binder needs to

00:27:09,080 --> 00:27:12,980
store this stuff somewhere and the way

00:27:10,910 --> 00:27:15,350
it's specified to work in CS plus 11 and

00:27:12,980 --> 00:27:16,940
Beyond is that a copy removes them

00:27:15,350 --> 00:27:19,820
depending on their value category and

00:27:16,940 --> 00:27:21,920
stores them as data members then when it

00:27:19,820 --> 00:27:25,010
calls invoke either conceptually in CS

00:27:21,920 --> 00:27:26,990
plus 1114 or physically in Sisco 17 they

00:27:25,010 --> 00:27:28,490
need to be passed as L values and this

00:27:26,990 --> 00:27:30,830
is surprising so I've put it in bold

00:27:28,490 --> 00:27:33,680
there passed as L values because once

00:27:30,830 --> 00:27:35,690
you have a function object like B you

00:27:33,680 --> 00:27:37,580
can call it multiple times and if they

00:27:35,690 --> 00:27:39,200
were passed as our values then they

00:27:37,580 --> 00:27:41,360
would be moved from after the first call

00:27:39,200 --> 00:27:43,160
and then you'd be all why is my screen

00:27:41,360 --> 00:27:44,330
getting emptied out why is my pointer

00:27:43,160 --> 00:27:45,860
you know a smart pointer getting rolled

00:27:44,330 --> 00:27:48,590
out that would be bad so they're passed

00:27:45,860 --> 00:27:49,370
as L values also with these constants

00:27:48,590 --> 00:27:52,730
that implies that the function

00:27:49,370 --> 00:27:53,870
co-operators overloaded so some bound

00:27:52,730 --> 00:27:55,820
arguments are special like I've

00:27:53,870 --> 00:27:58,820
mentioned underscore one means fill me

00:27:55,820 --> 00:28:00,710
in with an unbound argument those unlike

00:27:58,820 --> 00:28:03,230
the bound arguments which are copied or

00:28:00,710 --> 00:28:04,700
moved and then passed as L values the

00:28:03,230 --> 00:28:07,940
unbound arguments are perfectly

00:28:04,700 --> 00:28:09,350
forwarded at the point of each call if

00:28:07,940 --> 00:28:11,120
you pass a reference wrapper it got some

00:28:09,350 --> 00:28:13,310
rap we'll talk about that later and if

00:28:11,120 --> 00:28:15,770
you have a nested binding which is I

00:28:13,310 --> 00:28:17,570
would say by far the most insanity

00:28:15,770 --> 00:28:20,060
inducing thing in all of the functional

00:28:17,570 --> 00:28:22,220
header those are called with perfectly

00:28:20,060 --> 00:28:24,200
forged and bound arguments and bind also

00:28:22,220 --> 00:28:24,770
has this weird little thing that's kind

00:28:24,200 --> 00:28:27,200
of unusual

00:28:24,770 --> 00:28:29,300
you can pass more unbound arguments that

00:28:27,200 --> 00:28:30,410
are then are necessary any ones that

00:28:29,300 --> 00:28:32,090
aren't used whether they're at the

00:28:30,410 --> 00:28:33,890
beginning middle or the end they're just

00:28:32,090 --> 00:28:35,510
dropped on the floor and completely

00:28:33,890 --> 00:28:36,830
ignored and there are some arguments for

00:28:35,510 --> 00:28:38,180
why that's good it's kind of weird

00:28:36,830 --> 00:28:40,400
though that the STL is just willing to

00:28:38,180 --> 00:28:43,940
ignore unbound arguments but that's how

00:28:40,400 --> 00:28:46,070
bind works so bian has many many issues

00:28:43,940 --> 00:28:48,200
I've seen lots of people use bind

00:28:46,070 --> 00:28:50,930
because it seems to be terse and it was

00:28:48,200 --> 00:28:53,720
good back in like 2005 but it

00:28:50,930 --> 00:28:55,750
has surprising gotchas so first it's got

00:28:53,720 --> 00:28:58,250
all the performance issues that lymph

00:28:55,750 --> 00:28:59,630
Indust ORS the call by object isn't it

00:28:58,250 --> 00:29:01,070
as a data member so if you have a

00:28:59,630 --> 00:29:03,650
pointer to member function order to

00:29:01,070 --> 00:29:05,510
member data or a function pointer which

00:29:03,650 --> 00:29:06,560
bind works with it needs to store that

00:29:05,510 --> 00:29:08,690
as a data member it suits can be

00:29:06,560 --> 00:29:10,490
resistant to optimization it's going to

00:29:08,690 --> 00:29:12,200
be fragile if the thing is templated or

00:29:10,490 --> 00:29:13,100
overloaded you'll need a disambiguate

00:29:12,200 --> 00:29:16,370
which is awful

00:29:13,100 --> 00:29:19,400
so same issues but then also if you

00:29:16,370 --> 00:29:22,070
misuse bind either by giving it the

00:29:19,400 --> 00:29:24,230
wrong stuff or by making invalid invoke

00:29:22,070 --> 00:29:26,390
call it will emit an awful compiler

00:29:24,230 --> 00:29:27,920
error now many people they're like oh I

00:29:26,390 --> 00:29:29,300
use the SQL and I get off a compiler

00:29:27,920 --> 00:29:31,010
errors and they're basically wimps I'm

00:29:29,300 --> 00:29:33,350
gonna say they're not really that bad

00:29:31,010 --> 00:29:35,180
you know yeah Pyrus can be confusing but

00:29:33,350 --> 00:29:37,310
you learn how to deal with them you know

00:29:35,180 --> 00:29:38,690
get over it yeah yeah concepts will make

00:29:37,310 --> 00:29:42,230
things better but they're not that awful

00:29:38,690 --> 00:29:44,180
but with bind bind errors are awful I'm

00:29:42,230 --> 00:29:46,850
a standard library maintainer and I just

00:29:44,180 --> 00:29:49,400
cannot bear to look at a bind error even

00:29:46,850 --> 00:29:51,440
if I wrote bind it's like Oh awful

00:29:49,400 --> 00:29:53,030
you'll just throw up your hands and give

00:29:51,440 --> 00:29:55,840
up and that's because it has so much

00:29:53,030 --> 00:29:57,920
library machinery to mess with the

00:29:55,840 --> 00:30:01,580
placeholders and the reference wrapper

00:29:57,920 --> 00:30:04,460
and the unbound arguments and okay so

00:30:01,580 --> 00:30:06,290
also when you call bind the syntax that

00:30:04,460 --> 00:30:07,760
you give to it is not ordinary cs+ you

00:30:06,290 --> 00:30:10,280
need to learn this sort of bind mini

00:30:07,760 --> 00:30:11,840
language you need to learn it how to

00:30:10,280 --> 00:30:12,940
write it how to read it and that's

00:30:11,840 --> 00:30:15,410
bizarre

00:30:12,940 --> 00:30:17,090
especially with nested bind you're

00:30:15,410 --> 00:30:19,460
basically delaying invitations whereas

00:30:17,090 --> 00:30:22,250
if you write a lambda function its body

00:30:19,460 --> 00:30:24,290
once you get past the introducer you

00:30:22,250 --> 00:30:25,580
know the square brackets it's just

00:30:24,290 --> 00:30:27,560
ordinary sickest but you just call

00:30:25,580 --> 00:30:29,690
ordinary member functions and you know

00:30:27,560 --> 00:30:31,610
how that stuff works well so that whole

00:30:29,690 --> 00:30:33,650
bit about bind passing things as L

00:30:31,610 --> 00:30:37,160
values is deeply surprising I've seen

00:30:33,650 --> 00:30:38,750
multiple people confused by the fact

00:30:37,160 --> 00:30:40,160
that they're passed as L values this

00:30:38,750 --> 00:30:41,690
means that for example if you bind a

00:30:40,160 --> 00:30:43,220
unique put ur stuff won't compile

00:30:41,690 --> 00:30:46,850
because it's being passed as an L value

00:30:43,220 --> 00:30:48,500
and unique footer is not copyable I've

00:30:46,850 --> 00:30:50,030
seen I guess I can mention some names

00:30:48,500 --> 00:30:52,400
just to reinforce here I've seen both

00:30:50,030 --> 00:30:54,170
herb Sutter and Scott Myers confused by

00:30:52,400 --> 00:30:56,840
bind and these are very very smart

00:30:54,170 --> 00:30:59,450
people but bind is even more evil than

00:30:56,840 --> 00:31:02,000
they're able to handle I was confused by

00:30:59,450 --> 00:31:03,260
bind while maintaining bind I thought oh

00:31:02,000 --> 00:31:04,670
I can just pass them as

00:31:03,260 --> 00:31:07,250
values and that will make it efficient

00:31:04,670 --> 00:31:09,040
and no stuff get stolen from that broke

00:31:07,250 --> 00:31:11,720
windows and I had to revert the change

00:31:09,040 --> 00:31:14,150
that is a very bad I have a test case

00:31:11,720 --> 00:31:15,830
for that it's called grand theft bind

00:31:14,150 --> 00:31:19,190
because buying Bastille entrants bad

00:31:15,830 --> 00:31:20,450
arguments very very surprising the only

00:31:19,190 --> 00:31:22,400
reason I knew about this issue is

00:31:20,450 --> 00:31:24,710
because I ran into it myself

00:31:22,400 --> 00:31:26,420
there bind is not obvious on when it

00:31:24,710 --> 00:31:29,270
calls things immediately versus when

00:31:26,420 --> 00:31:30,770
things are called later this has impact

00:31:29,270 --> 00:31:32,180
if you're calling something like a time

00:31:30,770 --> 00:31:33,800
function that's sensitive when it's

00:31:32,180 --> 00:31:36,260
called or if it's looking at some sort

00:31:33,800 --> 00:31:37,910
of global State that's changing whereas

00:31:36,260 --> 00:31:39,350
with a lambda function it's very clear

00:31:37,910 --> 00:31:41,000
what happens when the lambda is

00:31:39,350 --> 00:31:43,040
constructed that's all the stuff in the

00:31:41,000 --> 00:31:44,210
init captures and when the lambdas call

00:31:43,040 --> 00:31:45,680
because everything in the function body

00:31:44,210 --> 00:31:47,540
doesn't happen until you actually call

00:31:45,680 --> 00:31:49,460
the thing and then actually I've never

00:31:47,540 --> 00:31:53,240
seen anybody run into this but it

00:31:49,460 --> 00:31:55,880
certainly nags at me if you right mind

00:31:53,240 --> 00:31:57,350
expression and it's sufficiently bizarre

00:31:55,880 --> 00:31:59,840
you can actually move from arguments

00:31:57,350 --> 00:32:02,330
twice if you repeat placeholders or if

00:31:59,840 --> 00:32:04,070
you have enough nested bindings I find

00:32:02,330 --> 00:32:06,560
that extremely dangerous in theory

00:32:04,070 --> 00:32:08,570
because the STL generally is not willing

00:32:06,560 --> 00:32:10,310
to move through things twice unless you

00:32:08,570 --> 00:32:11,720
go out of your way to do something so

00:32:10,310 --> 00:32:13,820
dangerous the bind will happily do it

00:32:11,720 --> 00:32:15,980
because it was invented before our value

00:32:13,820 --> 00:32:18,800
references and then it was our very

00:32:15,980 --> 00:32:21,320
offenses were added on later hmm

00:32:18,800 --> 00:32:23,390
so very dangerous so what I recommend is

00:32:21,320 --> 00:32:25,940
and this is stronger than them fun avoid

00:32:23,390 --> 00:32:28,010
using bind it's just not worth it use

00:32:25,940 --> 00:32:30,110
the lambdas it may be tempting to use

00:32:28,010 --> 00:32:32,360
behind you because viable sometimes be

00:32:30,110 --> 00:32:35,810
shorter than a lambda but the verbosity

00:32:32,360 --> 00:32:38,120
lambda is worth the price it's the

00:32:35,810 --> 00:32:41,450
terseness of bind is not worth the price

00:32:38,120 --> 00:32:42,710
of it usually in the STL we like library

00:32:41,450 --> 00:32:44,510
solutions because they can provide a

00:32:42,710 --> 00:32:46,520
more abstract solution in the core

00:32:44,510 --> 00:32:48,290
language but bind is essentially a

00:32:46,520 --> 00:32:50,660
counter example we tried to make

00:32:48,290 --> 00:32:52,250
building up function objects in the

00:32:50,660 --> 00:32:55,190
standard library all the way back in

00:32:52,250 --> 00:32:57,560
boost and tr1 and it just doesn't work

00:32:55,190 --> 00:32:59,150
well and that's why lambdas were

00:32:57,560 --> 00:33:01,160
proposed and added to the core language

00:32:59,150 --> 00:33:03,410
and they vic they've been extended since

00:33:01,160 --> 00:33:06,320
then so don't use the STL in this case

00:33:03,410 --> 00:33:08,870
use the core language okay so I

00:33:06,320 --> 00:33:10,520
mentioned reference wrapper this

00:33:08,870 --> 00:33:11,960
actually lives in the functional header

00:33:10,520 --> 00:33:15,260
it doesn't always need to walk to the

00:33:11,960 --> 00:33:16,970
functions though but it has one useful

00:33:15,260 --> 00:33:19,549
power which is why it lives in

00:33:16,970 --> 00:33:21,020
functional so here it's such a small

00:33:19,549 --> 00:33:24,289
class I've actually put the entire class

00:33:21,020 --> 00:33:27,530
definition up on the slide reference

00:33:24,289 --> 00:33:29,450
wrapper Tootie is in some sense it

00:33:27,530 --> 00:33:32,210
behaves like a reference to tea except

00:33:29,450 --> 00:33:33,590
it's assignable so you can reseed it the

00:33:32,210 --> 00:33:36,470
other way you can think about it is it's

00:33:33,590 --> 00:33:38,330
an auto dereferencing pointer so it's

00:33:36,470 --> 00:33:39,740
got an operator T breath so it can

00:33:38,330 --> 00:33:41,780
convert itself to a reference or you can

00:33:39,740 --> 00:33:43,370
explicitly ask for get an reference

00:33:41,780 --> 00:33:45,530
wrapper also has this extra little bit

00:33:43,370 --> 00:33:48,350
it has a function call operator that

00:33:45,530 --> 00:33:53,030
takes arbitrary stuff and then invokes

00:33:48,350 --> 00:33:55,400
it invokes the T on whatever is given to

00:33:53,030 --> 00:33:57,409
it so a reference wrapper to a function

00:33:55,400 --> 00:33:58,789
object is callable like that function

00:33:57,409 --> 00:34:00,980
object you can also have a reference

00:33:58,789 --> 00:34:03,049
wrapper to a PMF of PMD but that's very

00:34:00,980 --> 00:34:06,200
obscure so here I've got an example of

00:34:03,049 --> 00:34:08,570
usage man I've got vector int and I

00:34:06,200 --> 00:34:10,639
would like to fill it in with randomly

00:34:08,570 --> 00:34:13,099
generated numbers from 1 to 20 so I can

00:34:10,639 --> 00:34:15,349
define D 20 which is a function object

00:34:13,099 --> 00:34:16,940
that every time you call it it will

00:34:15,349 --> 00:34:20,270
generate a random number and it contains

00:34:16,940 --> 00:34:22,490
a random number engine a uniform random

00:34:20,270 --> 00:34:24,379
number generator and a distribution so

00:34:22,490 --> 00:34:25,460
the function object is stateful and

00:34:24,379 --> 00:34:27,200
every time you call it it's going to

00:34:25,460 --> 00:34:29,270
modify its state and then return a

00:34:27,200 --> 00:34:31,790
random number from 1 through 20 so if I

00:34:29,270 --> 00:34:34,429
use the CS plus 98 algorithm generate

00:34:31,790 --> 00:34:36,290
and I call it with D 20 it'll seem to

00:34:34,429 --> 00:34:37,520
work but then if I call again I'm going

00:34:36,290 --> 00:34:39,710
to get the exact same sequence of

00:34:37,520 --> 00:34:41,510
numbers generated and that's because to

00:34:39,710 --> 00:34:44,540
generate takes its function object by

00:34:41,510 --> 00:34:48,790
value and you get a copy so when I copy

00:34:44,540 --> 00:34:51,290
D 20 the new object the the copy is

00:34:48,790 --> 00:34:53,060
invoked and modified and then it's

00:34:51,290 --> 00:34:54,560
discarded and then if I make a fresh

00:34:53,060 --> 00:34:55,760
copy I'm using the original state that's

00:34:54,560 --> 00:34:59,330
why I get the same sequence of numbers

00:34:55,760 --> 00:35:00,770
if I use stood ref which is a helper

00:34:59,330 --> 00:35:03,560
function that makes reference wrappers

00:35:00,770 --> 00:35:05,900
then I will directly invoke the original

00:35:03,560 --> 00:35:07,250
object D 20 that I've got here and I'll

00:35:05,900 --> 00:35:08,720
get a different sequence of numbers

00:35:07,250 --> 00:35:11,599
every time I call it because I'm you

00:35:08,720 --> 00:35:12,950
only using that original object State so

00:35:11,599 --> 00:35:16,210
it's more efficient and I actually does

00:35:12,950 --> 00:35:19,160
what I want which is usually good so

00:35:16,210 --> 00:35:21,050
because CS plus 98 oh three algorithms

00:35:19,160 --> 00:35:23,119
almost all of them the only exception is

00:35:21,050 --> 00:35:24,890
student shuffle that I can think of

00:35:23,119 --> 00:35:26,839
take function objects by value and are

00:35:24,890 --> 00:35:29,810
allowed to copy them and for each is

00:35:26,839 --> 00:35:32,330
also special but most of them can copy

00:35:29,810 --> 00:35:34,490
objects if you don't want to copy you

00:35:32,330 --> 00:35:36,770
can and should you stood ref to ask the

00:35:34,490 --> 00:35:38,300
STL Oh that's the sing by reference just

00:35:36,770 --> 00:35:40,400
put it in a reference wrapper and then

00:35:38,300 --> 00:35:41,840
invoke it later some people and I get

00:35:40,400 --> 00:35:44,090
bug reports they try to use explicit

00:35:41,840 --> 00:35:46,400
template arguments to make an SQL

00:35:44,090 --> 00:35:48,320
algorithm take a function object by

00:35:46,400 --> 00:35:50,000
reference and that'll work on some

00:35:48,320 --> 00:35:50,900
implementations but not others and it's

00:35:50,000 --> 00:35:52,670
not portable

00:35:50,900 --> 00:35:54,230
ESCA algorithms really are allowed to

00:35:52,670 --> 00:35:56,420
copy function objects so you should use

00:35:54,230 --> 00:35:58,510
reference wrapper in this case the

00:35:56,420 --> 00:36:00,890
standard even has a note saying use it

00:35:58,510 --> 00:36:02,150
it's also useful elsewhere even if

00:36:00,890 --> 00:36:05,240
you're not working function objects like

00:36:02,150 --> 00:36:07,520
stood thread but you should be aware of

00:36:05,240 --> 00:36:09,370
why stood thread wants to copy things

00:36:07,520 --> 00:36:14,060
before telling it no don't copy things

00:36:09,370 --> 00:36:16,100
also reference wrapper is unwrapped by a

00:36:14,060 --> 00:36:19,190
few functions in the STL I make pair and

00:36:16,100 --> 00:36:20,570
make tuple notably are aware of

00:36:19,190 --> 00:36:21,950
reference wrappers so if I say make a

00:36:20,570 --> 00:36:24,500
pair of make tuple and if I give it

00:36:21,950 --> 00:36:27,320
reference wrappers it will return a pair

00:36:24,500 --> 00:36:29,030
tuple with built-in references and I've

00:36:27,320 --> 00:36:30,620
got an example here so if you've ever

00:36:29,030 --> 00:36:32,150
wanted a pair of truthful references you

00:36:30,620 --> 00:36:34,850
can now get that easily

00:36:32,150 --> 00:36:36,860
with reference wrap okay so I'd

00:36:34,850 --> 00:36:40,040
mentioned earlier that medicine had

00:36:36,860 --> 00:36:42,110
superseded something this was stuff that

00:36:40,040 --> 00:36:44,630
was available in sis plus ninety 803 and

00:36:42,110 --> 00:36:46,640
in CS plus seventeen they have been

00:36:44,630 --> 00:36:49,820
removed outright this was at a very

00:36:46,640 --> 00:36:51,320
recent meeting they were deprecated all

00:36:49,820 --> 00:36:52,670
the way back in CS plus eleven so

00:36:51,320 --> 00:36:55,400
compilers could have been warning hater

00:36:52,670 --> 00:36:57,800
deprecated and in the standards u-17

00:36:55,400 --> 00:36:59,600
they have been removed outright so the

00:36:57,800 --> 00:37:01,760
things that were removed and functional

00:36:59,600 --> 00:37:03,350
were the classes unary function binary

00:37:01,760 --> 00:37:05,450
function these were just helpers that

00:37:03,350 --> 00:37:07,130
would provide type deaths result type

00:37:05,450 --> 00:37:09,320
argument type first the second argument

00:37:07,130 --> 00:37:11,000
type there is a function put her phone

00:37:09,320 --> 00:37:11,900
that would wrap a function pointer and

00:37:11,000 --> 00:37:14,540
provide the type desc

00:37:11,900 --> 00:37:17,870
then the more things mem fun with you

00:37:14,540 --> 00:37:19,100
mem fun ref don't ask buying first

00:37:17,870 --> 00:37:22,910
buying a second and these have been

00:37:19,100 --> 00:37:25,730
superseded completely by the TR one STS

00:37:22,910 --> 00:37:27,170
plus eleven mem phone and bind so

00:37:25,730 --> 00:37:29,390
because these things have been

00:37:27,170 --> 00:37:31,460
officially removed from the standard and

00:37:29,390 --> 00:37:34,040
at least my implementation they're going

00:37:31,460 --> 00:37:35,960
to be removed at some point you should

00:37:34,040 --> 00:37:37,370
never ever use this stuff your existing

00:37:35,960 --> 00:37:38,990
usage you should start transitioning

00:37:37,370 --> 00:37:40,790
away from it they have been deprecated

00:37:38,990 --> 00:37:42,920
and removed for a reason they're not

00:37:40,790 --> 00:37:44,720
general they're

00:37:42,920 --> 00:37:46,220
hard to use they've been superseded

00:37:44,720 --> 00:37:48,109
things like that

00:37:46,220 --> 00:37:49,250
in fact I've seen lots of people using

00:37:48,109 --> 00:37:52,160
them when they weren't actually

00:37:49,250 --> 00:37:53,569
necessary they were needed these type

00:37:52,160 --> 00:37:55,280
deaths like result type argument type

00:37:53,569 --> 00:37:57,680
they were needed for adaptors like

00:37:55,280 --> 00:37:59,839
buying first and not one things like

00:37:57,680 --> 00:38:02,240
that but if you're just giving function

00:37:59,839 --> 00:38:03,589
objects to sto algorithms or STL

00:38:02,240 --> 00:38:05,690
containers like stood map they have

00:38:03,589 --> 00:38:07,430
never needed any of this unary function

00:38:05,690 --> 00:38:09,020
binary function stuff so if you had

00:38:07,430 --> 00:38:10,790
function objects deriving from unary

00:38:09,020 --> 00:38:13,130
function or if you were calling things

00:38:10,790 --> 00:38:14,809
with put her fun you probably didn't

00:38:13,130 --> 00:38:16,940
need to do so and you could eliminate it

00:38:14,809 --> 00:38:19,069
and make your compile times faster and

00:38:16,940 --> 00:38:21,140
your code simpler and all that now I

00:38:19,069 --> 00:38:23,780
wanted to break the world but I couldn't

00:38:21,140 --> 00:38:24,920
quite do it in one release so in vs 2015

00:38:23,780 --> 00:38:27,049
we still provide all this stuff by

00:38:24,920 --> 00:38:28,880
default but you can define a macro

00:38:27,049 --> 00:38:30,710
project-wide and this will simply

00:38:28,880 --> 00:38:32,780
pre-process away all the stuff that has

00:38:30,710 --> 00:38:34,490
been removed so if you would like to

00:38:32,780 --> 00:38:37,549
join the New World Order of not having

00:38:34,490 --> 00:38:39,710
all this removed stuff you just define

00:38:37,549 --> 00:38:41,720
has Auto put or etc to zero this will

00:38:39,710 --> 00:38:43,730
also turn off the definitions of auto

00:38:41,720 --> 00:38:45,140
put ER and a random shuffle which were

00:38:43,730 --> 00:38:47,750
removed at the same time Otto Porter is

00:38:45,140 --> 00:38:50,180
extremely dangerous don't use it and but

00:38:47,750 --> 00:38:51,589
this talk is not about how to put it ok

00:38:50,180 --> 00:38:53,450
so finally let's talk about stirred

00:38:51,589 --> 00:38:55,670
function save the best for last this was

00:38:53,450 --> 00:38:59,210
a danseuse 11 and if has gained extra

00:38:55,670 --> 00:39:01,490
powers in CS + 14 + CS + 17 so here's an

00:38:59,210 --> 00:39:03,079
example using stood function stirred

00:39:01,490 --> 00:39:05,450
function can do lots of things here in

00:39:03,079 --> 00:39:08,119
the example is recording a sequence of

00:39:05,450 --> 00:39:10,460
actions in a vector and then playing

00:39:08,119 --> 00:39:12,859
them back later so here I have a vector

00:39:10,460 --> 00:39:14,569
of functions and these are going to be

00:39:12,859 --> 00:39:16,549
cobbled with two intz and then they're

00:39:14,569 --> 00:39:18,559
going to return another int so here I

00:39:16,549 --> 00:39:21,079
can store things like a plus function

00:39:18,559 --> 00:39:22,819
object a multiplies function object a

00:39:21,079 --> 00:39:24,200
pointer to function here I've said

00:39:22,819 --> 00:39:26,390
address some squares I could have just

00:39:24,200 --> 00:39:28,220
admitted the ampersand in word worked as

00:39:26,390 --> 00:39:30,109
well I can also store things like

00:39:28,220 --> 00:39:33,260
lambdas here I've got stateful lambdas

00:39:30,109 --> 00:39:35,569
that capture the integer I and then go

00:39:33,260 --> 00:39:37,099
use it later and then once I've built up

00:39:35,569 --> 00:39:39,230
this vector functions I can iterate

00:39:37,099 --> 00:39:40,520
through it and call it with arguments in

00:39:39,230 --> 00:39:42,500
this case I'm always going to call them

00:39:40,520 --> 00:39:44,299
with 4 and 5 but I could call it I could

00:39:42,500 --> 00:39:46,280
iterate over repeatedly or do whatever I

00:39:44,299 --> 00:39:48,319
want I can also do things like store

00:39:46,280 --> 00:39:50,930
astute function has a data member and

00:39:48,319 --> 00:39:53,690
then use it later ok so stem function

00:39:50,930 --> 00:39:55,670
you should think of it as a wrapper it

00:39:53,690 --> 00:39:56,360
doesn't do anything by itself what it

00:39:55,670 --> 00:39:58,250
does is

00:39:56,360 --> 00:40:00,620
stores a callable object of some

00:39:58,250 --> 00:40:02,750
arbitrary type now the type of the call

00:40:00,620 --> 00:40:04,850
object it could be a lambda or it could

00:40:02,750 --> 00:40:06,650
be a function object that you've written

00:40:04,850 --> 00:40:09,230
by hand or from the STL it could be a

00:40:06,650 --> 00:40:11,810
PMF PMD the type of it doesn't matter

00:40:09,230 --> 00:40:13,550
only the signature matters the stir

00:40:11,810 --> 00:40:16,070
function is templated on the call

00:40:13,550 --> 00:40:19,160
signature I take arms and I return ret

00:40:16,070 --> 00:40:21,410
and it erases the actual types the call

00:40:19,160 --> 00:40:23,720
object that's why I can have a vector of

00:40:21,410 --> 00:40:26,510
such things here in the example stood

00:40:23,720 --> 00:40:28,010
plus and a pointer to function and a

00:40:26,510 --> 00:40:30,290
lambda they're all different types I

00:40:28,010 --> 00:40:32,360
cannot have a vector of different types

00:40:30,290 --> 00:40:34,250
a B and C they all need to be the same

00:40:32,360 --> 00:40:36,260
type and that's what stood function does

00:40:34,250 --> 00:40:38,300
it erases the type of the Kalb object

00:40:36,260 --> 00:40:40,910
and like a Cheshire cat it preserves

00:40:38,300 --> 00:40:43,850
only the smile only the call signature

00:40:40,910 --> 00:40:45,680
so this is useful when you can't have

00:40:43,850 --> 00:40:47,840
code that's templated on the type of a

00:40:45,680 --> 00:40:49,460
callable object lots of different

00:40:47,840 --> 00:40:50,960
contexts it could be code that needs to

00:40:49,460 --> 00:40:52,880
be separately compiled because templates

00:40:50,960 --> 00:40:54,110
going headers in general if you need to

00:40:52,880 --> 00:40:56,270
separately compile something stood

00:40:54,110 --> 00:40:58,520
function can be put in that signature if

00:40:56,270 --> 00:41:00,470
something needs to be a virtual function

00:40:58,520 --> 00:41:03,260
for technical reasons you can I have a

00:41:00,470 --> 00:41:04,940
virtual template so if you have a

00:41:03,260 --> 00:41:07,550
virtual function you can make it take a

00:41:04,940 --> 00:41:09,020
study function of a specific signature

00:41:07,550 --> 00:41:11,180
and then it can be called with any

00:41:09,020 --> 00:41:12,890
callable object of whatever type and

00:41:11,180 --> 00:41:15,560
like I showed you container owns all

00:41:12,890 --> 00:41:17,540
need to be the same type stood function

00:41:15,560 --> 00:41:21,920
can help you have containers twisted

00:41:17,540 --> 00:41:24,200
functions so very surprising gotcha

00:41:21,920 --> 00:41:26,690
I would say that stood function requires

00:41:24,200 --> 00:41:28,250
copy constructible function objects and

00:41:26,690 --> 00:41:31,790
this is kind of unusual in the STL

00:41:28,250 --> 00:41:34,670
usually the STL is lazy in the sense

00:41:31,790 --> 00:41:35,960
that it doesn't need things upfront if I

00:41:34,670 --> 00:41:37,340
have something like a list and the way I

00:41:35,960 --> 00:41:39,050
think about it this is powered by a core

00:41:37,340 --> 00:41:42,050
language rule find something like a list

00:41:39,050 --> 00:41:44,870
of T T does not need to be less than

00:41:42,050 --> 00:41:46,250
comparable it can be that's fine but in

00:41:44,870 --> 00:41:48,260
general it does not need to be less than

00:41:46,250 --> 00:41:51,380
comparable only if you call the member

00:41:48,260 --> 00:41:53,270
function list T sort then it actually

00:41:51,380 --> 00:41:55,340
does need to be less than comparable if

00:41:53,270 --> 00:41:57,050
you call by default and the core

00:41:55,340 --> 00:42:00,740
language rule that powers this is that

00:41:57,050 --> 00:42:03,470
the definitions of member functions of a

00:42:00,740 --> 00:42:05,250
class template are not instantiated

00:42:03,470 --> 00:42:07,950
until they're actually need

00:42:05,250 --> 00:42:09,119
and the bodies don't exist in some sense

00:42:07,950 --> 00:42:11,880
until you actually call it and this is

00:42:09,119 --> 00:42:14,130
usually cool this means you only pay for

00:42:11,880 --> 00:42:15,829
what you need but state function is

00:42:14,130 --> 00:42:17,970
special because this type of raishin

00:42:15,829 --> 00:42:20,700
because when you construct a stood

00:42:17,970 --> 00:42:23,099
functions from some colville object f it

00:42:20,700 --> 00:42:25,290
needs to generate everything could ever

00:42:23,099 --> 00:42:26,490
need from that object F because it's

00:42:25,290 --> 00:42:29,400
going to erase its type

00:42:26,490 --> 00:42:31,079
it requires all the operations that it

00:42:29,400 --> 00:42:33,150
could possibly ever need regardless of

00:42:31,079 --> 00:42:35,099
if they're used so if you construct a

00:42:33,150 --> 00:42:38,099
stood function from some call by object

00:42:35,099 --> 00:42:40,530
F F is absolutely required at compile

00:42:38,099 --> 00:42:43,050
time to be copy constructible this is

00:42:40,530 --> 00:42:44,670
true even though F will be moved into

00:42:43,050 --> 00:42:47,040
the student function so even if you give

00:42:44,670 --> 00:42:48,630
it an R value and even if you never copy

00:42:47,040 --> 00:42:50,579
stirr'd functions anymore in your

00:42:48,630 --> 00:42:52,470
program F is still required to be copy

00:42:50,579 --> 00:42:54,720
constructible you'll get a compile error

00:42:52,470 --> 00:42:56,760
saying so maybe horrible maybe nice

00:42:54,720 --> 00:42:58,260
depending where you get it just cannot

00:42:56,760 --> 00:43:00,930
store moveable only function objects

00:42:58,260 --> 00:43:02,250
this is a design limitation caused in

00:43:00,930 --> 00:43:04,109
part by the fact that stood function

00:43:02,250 --> 00:43:06,900
dates back to boost MTR one before our

00:43:04,109 --> 00:43:08,750
very references and in some sense it can

00:43:06,900 --> 00:43:11,490
never be fixed with good functions

00:43:08,750 --> 00:43:12,569
interface as it stands alternatives are

00:43:11,490 --> 00:43:13,920
being investigated

00:43:12,569 --> 00:43:15,089
maybe we can cram something else in the

00:43:13,920 --> 00:43:17,849
pipe or have a different moveable

00:43:15,089 --> 00:43:20,190
function so we will probably get some

00:43:17,849 --> 00:43:22,050
sort of type erased wrapper that can

00:43:20,190 --> 00:43:24,210
store movable only function in the

00:43:22,050 --> 00:43:26,460
future but stood function as it stands

00:43:24,210 --> 00:43:29,280
at cos plus 17 right now cannot do that

00:43:26,460 --> 00:43:30,839
so just be aware steady function has got

00:43:29,280 --> 00:43:32,280
this trick called the small functor

00:43:30,839 --> 00:43:34,950
optimization so think about what it does

00:43:32,280 --> 00:43:37,410
to the function of a given signature has

00:43:34,950 --> 00:43:40,170
to be some specific size let's say it's

00:43:37,410 --> 00:43:41,670
you know 50 bytes or whatever but the

00:43:40,170 --> 00:43:43,380
Calma object that i give to it could be

00:43:41,670 --> 00:43:45,150
arbitrarily enlarged I could store

00:43:43,380 --> 00:43:47,910
gigantic Sturt array and my column

00:43:45,150 --> 00:43:49,950
object or whatever resilient pointers so

00:43:47,910 --> 00:43:52,619
how are we going to cram that into the

00:43:49,950 --> 00:43:53,700
stood function well the answer is

00:43:52,619 --> 00:43:55,109
eventually we're going to use dynamic

00:43:53,700 --> 00:43:56,910
memory allocation at some point we got

00:43:55,109 --> 00:43:58,680
to say operator new allocates a memory

00:43:56,910 --> 00:44:01,050
and then have a pointer at that memory

00:43:58,680 --> 00:44:04,079
but allocating memory is in general

00:44:01,050 --> 00:44:06,540
somewhat expensive so student has a

00:44:04,079 --> 00:44:08,040
trick and this trick is permitted by the

00:44:06,540 --> 00:44:10,619
standard actually we hired in one case

00:44:08,040 --> 00:44:12,750
if you're call my object is small enough

00:44:10,619 --> 00:44:14,880
it can be stored within the stood

00:44:12,750 --> 00:44:17,630
function object itself without a dynamic

00:44:14,880 --> 00:44:20,119
memory allocation it can simply be

00:44:17,630 --> 00:44:23,029
placement nude constructed within a

00:44:20,119 --> 00:44:25,220
properly aligned buffer and we store a

00:44:23,029 --> 00:44:26,990
pointer to it and we don't allocate

00:44:25,220 --> 00:44:29,839
memory in any circumstances that's good

00:44:26,990 --> 00:44:31,339
the standard guarantees sort indirectly

00:44:29,839 --> 00:44:33,740
by saying shall not throw exceptions

00:44:31,339 --> 00:44:35,869
that this happens if a stood function

00:44:33,740 --> 00:44:37,910
store is a built-in function pointer or

00:44:35,869 --> 00:44:39,890
if it stores a reference wrapper if you

00:44:37,910 --> 00:44:41,420
have a call the object of any other type

00:44:39,890 --> 00:44:43,670
even a pointer in a number function

00:44:41,420 --> 00:44:45,589
you're not guaranteed to get the small

00:44:43,670 --> 00:44:47,390
functor optimization it's up to the

00:44:45,589 --> 00:44:49,190
implementers judgment as to whether they

00:44:47,390 --> 00:44:51,410
activate it and as we'll see on the next

00:44:49,190 --> 00:44:53,930
slide implementations do vary in what

00:44:51,410 --> 00:44:55,970
they accept there's also one additional

00:44:53,930 --> 00:44:57,109
bit that is not outright specified by

00:44:55,970 --> 00:44:59,269
the standard but implied by its

00:44:57,109 --> 00:45:01,009
requirements and that's if you want to

00:44:59,269 --> 00:45:03,859
activate the small functor optimization

00:45:01,009 --> 00:45:05,930
your call by object must be no throw

00:45:03,859 --> 00:45:08,750
move constructible and the reason why

00:45:05,930 --> 00:45:11,000
this is implied is that swapping stood

00:45:08,750 --> 00:45:13,220
functions is required to be no except

00:45:11,000 --> 00:45:15,349
think about what this implies if you

00:45:13,220 --> 00:45:20,089
have locally stored function objects I

00:45:15,349 --> 00:45:21,950
need to move the first stood functions

00:45:20,089 --> 00:45:24,079
call by object into some buffer

00:45:21,950 --> 00:45:26,630
somewhere move the other one and then

00:45:24,079 --> 00:45:28,640
move the first one in and if those can

00:45:26,630 --> 00:45:30,380
throw then the swap would be able to

00:45:28,640 --> 00:45:32,690
throw exceptions that would be bad so

00:45:30,380 --> 00:45:34,039
your callable object must be no throw

00:45:32,690 --> 00:45:35,930
move constructible to activate the small

00:45:34,039 --> 00:45:38,059
functor optimization here I've got a

00:45:35,930 --> 00:45:39,920
slide I can observe through a test case

00:45:38,059 --> 00:45:43,250
what activates the small functor

00:45:39,920 --> 00:45:45,799
optimization so V is 2015 on x86 dude

00:45:43,250 --> 00:45:47,720
function is 40 bytes big and it can

00:45:45,799 --> 00:45:49,339
store a call by object that's no throw

00:45:47,720 --> 00:45:52,880
move constructible up to and including

00:45:49,339 --> 00:45:55,670
32 bytes anything bigger will cause

00:45:52,880 --> 00:45:57,589
dynamic memory allocation and on x64 the

00:45:55,670 --> 00:46:00,049
step function is bigger at 64 bytes and

00:45:57,589 --> 00:46:04,250
it can store up to 48 now we chose these

00:46:00,049 --> 00:46:06,920
numbers in vs 2015 using the heuristic I

00:46:04,250 --> 00:46:09,799
should be able to store a call by object

00:46:06,920 --> 00:46:11,930
like a lambda that's bound one stood

00:46:09,799 --> 00:46:13,849
string that seems reasonable so I'm

00:46:11,930 --> 00:46:15,589
going to make the small func proposition

00:46:13,849 --> 00:46:17,480
at least as big as Astrid strength and

00:46:15,589 --> 00:46:19,670
I've put stood string size of Thera for

00:46:17,480 --> 00:46:22,279
comparison I've also put lip seus pluses

00:46:19,670 --> 00:46:24,380
and lips tootsies busses values there I

00:46:22,279 --> 00:46:26,390
observe that lips use plus also can

00:46:24,380 --> 00:46:28,609
store stood strings in its small functor

00:46:26,390 --> 00:46:29,420
optimization but lib stood cos plus

00:46:28,609 --> 00:46:30,980
cannot and

00:46:29,420 --> 00:46:33,170
just due to the constants that they've

00:46:30,980 --> 00:46:35,299
chosen that heuristic was suggested to

00:46:33,170 --> 00:46:36,619
me by James McNellis our CRT maintainer

00:46:35,299 --> 00:46:37,970
I asked hey you know how big should the

00:46:36,619 --> 00:46:39,530
small functor optimization be and he

00:46:37,970 --> 00:46:41,780
said a astute strength I was like that

00:46:39,530 --> 00:46:43,910
sounds good I'll do that in 2013 it was

00:46:41,780 --> 00:46:45,710
very small yeah where we chose it

00:46:43,910 --> 00:46:47,660
through a highly rational you know data

00:46:45,710 --> 00:46:51,559
science we get lots of no no we just

00:46:47,660 --> 00:46:53,329
make up an idea and go okay so stem

00:46:51,559 --> 00:46:56,150
function I mentioned it learned a couple

00:46:53,329 --> 00:46:58,700
tricks in CS plus 14 you know or one

00:46:56,150 --> 00:47:00,700
trick ensues plus 14 it's 11 this code

00:46:58,700 --> 00:47:03,920
was ambiguous if I overload me out

00:47:00,700 --> 00:47:05,990
taking a stood function taking one end

00:47:03,920 --> 00:47:08,329
and returning an end versus taking two

00:47:05,990 --> 00:47:10,160
ends if I call it with lambdas with

00:47:08,329 --> 00:47:12,470
different signatures in CS plus 11 this

00:47:10,160 --> 00:47:14,270
was ambiguous and were failed compile C

00:47:12,470 --> 00:47:16,609
is 14 can disambiguate and that's

00:47:14,270 --> 00:47:18,859
because did functions constructor is now

00:47:16,609 --> 00:47:22,420
constrained to exist only if the call

00:47:18,859 --> 00:47:24,619
object is callable with that signature

00:47:22,420 --> 00:47:25,819
there's a bid in the standard that says

00:47:24,619 --> 00:47:27,500
that but basically it means that this

00:47:25,819 --> 00:47:29,599
code compiles which is kind of what you

00:47:27,500 --> 00:47:33,200
would expect but in Lebanon did not and

00:47:29,599 --> 00:47:34,250
see just the 17 just voted in it also

00:47:33,200 --> 00:47:36,349
learned another trick if I have a

00:47:34,250 --> 00:47:39,500
student function that returns voyage

00:47:36,349 --> 00:47:40,760
specifically I can now store a function

00:47:39,500 --> 00:47:43,339
object here I've got a lambda that

00:47:40,760 --> 00:47:45,619
returns an int I can now store function

00:47:43,339 --> 00:47:48,680
object that returns something and that

00:47:45,619 --> 00:47:50,180
will be discarded essentially if I can

00:47:48,680 --> 00:47:51,680
always call a function to ignore its

00:47:50,180 --> 00:47:54,440
return value stirred function is now

00:47:51,680 --> 00:47:56,450
capable of this great the reason why

00:47:54,440 --> 00:47:59,990
this didn't work consists was 14 is it

00:47:56,450 --> 00:48:02,089
said stood function took the return type

00:47:59,990 --> 00:48:04,099
of the stored call object and implicitly

00:48:02,089 --> 00:48:06,260
converted it to the specified return

00:48:04,099 --> 00:48:07,430
type of the stood function turns out

00:48:06,260 --> 00:48:09,200
according to the core language you

00:48:07,430 --> 00:48:11,750
cannot implicitly convert something to

00:48:09,200 --> 00:48:13,220
void that's just how it works but like I

00:48:11,750 --> 00:48:13,940
mentioned the standard library can make

00:48:13,220 --> 00:48:15,859
up its own world

00:48:13,940 --> 00:48:17,869
so they voted in a rule say hey we can

00:48:15,859 --> 00:48:20,210
convert this thing to void why not

00:48:17,869 --> 00:48:23,270
package tasks also learn this trick and

00:48:20,210 --> 00:48:24,559
bind arms I won't going to now stem

00:48:23,270 --> 00:48:25,670
function is complicated enough that

00:48:24,559 --> 00:48:28,069
there was actually a couple issues with

00:48:25,670 --> 00:48:29,630
it that are issues in the standard that

00:48:28,069 --> 00:48:31,309
have not yet been resolved and I want to

00:48:29,630 --> 00:48:33,230
mention them for completeness first as

00:48:31,309 --> 00:48:33,589
the committee has discovered to its

00:48:33,230 --> 00:48:36,020
horror

00:48:33,589 --> 00:48:37,099
Stud function is not super awesome when

00:48:36,020 --> 00:48:38,720
it comes to multi-threading in a

00:48:37,099 --> 00:48:40,849
specific sense stood function this

00:48:38,720 --> 00:48:44,180
function call operator is Const because

00:48:40,849 --> 00:48:47,210
if you call us today to don't stay

00:48:44,180 --> 00:48:49,370
it can just call the function objects

00:48:47,210 --> 00:48:51,290
function cooperator the problem is the

00:48:49,370 --> 00:48:53,810
way it's specified sted functions

00:48:51,290 --> 00:48:55,700
constant function cooperator call a non

00:48:53,810 --> 00:48:57,470
constructs Co operator on the store

00:48:55,700 --> 00:48:58,610
called object even though it usually

00:48:57,470 --> 00:49:00,590
behaves like the value type and the

00:48:58,610 --> 00:49:02,090
reason this compiles is because it

00:49:00,590 --> 00:49:04,160
really stores a pointer to the call of

00:49:02,090 --> 00:49:06,830
object even if it lives within itself

00:49:04,160 --> 00:49:08,540
turns out this violates in some

00:49:06,830 --> 00:49:09,920
philosophical sense the STL's

00:49:08,540 --> 00:49:12,590
multi-threading guarantees when it comes

00:49:09,920 --> 00:49:15,500
to const usually the stl says if the

00:49:12,590 --> 00:49:17,240
user obeys these principles I will obey

00:49:15,500 --> 00:49:19,970
them too and constant means thread-safe

00:49:17,240 --> 00:49:21,320
stood function subverts that that's kind

00:49:19,970 --> 00:49:24,860
of bad the committee is looking into

00:49:21,320 --> 00:49:26,900
ways to fix that another thing that we

00:49:24,860 --> 00:49:28,700
have discovered is that because stood

00:49:26,900 --> 00:49:30,380
function wraps call by object it

00:49:28,700 --> 00:49:32,240
essentially exposes the deficiency in

00:49:30,380 --> 00:49:33,860
the core language if I have a called

00:49:32,240 --> 00:49:36,320
object that returns something by value

00:49:33,860 --> 00:49:38,720
like now returns a stood string I can

00:49:36,320 --> 00:49:40,880
wrap that instant function whose

00:49:38,720 --> 00:49:42,800
signature returns constrain graph that

00:49:40,880 --> 00:49:45,110
constrain ref that the stood function

00:49:42,800 --> 00:49:48,740
returns will be bound to the stood

00:49:45,110 --> 00:49:51,140
string that now returns by value but

00:49:48,740 --> 00:49:53,750
that evaporates as soon as the stood

00:49:51,140 --> 00:49:55,880
functions function operator returns so

00:49:53,750 --> 00:49:57,920
you immediately get a reference to a

00:49:55,880 --> 00:50:00,620
dangling temporary at least compilers

00:49:57,920 --> 00:50:02,300
will often warn but this code which is

00:50:00,620 --> 00:50:04,670
required to compile by the standard

00:50:02,300 --> 00:50:06,170
should not compile I think I can fix

00:50:04,670 --> 00:50:08,150
this in the standard I need a ripe a

00:50:06,170 --> 00:50:09,470
library issue but it's not trivial in

00:50:08,150 --> 00:50:11,390
this case is trivial because the type is

00:50:09,470 --> 00:50:14,270
the same but in general reference

00:50:11,390 --> 00:50:15,950
binding is really wacky I need to figure

00:50:14,270 --> 00:50:18,770
out exactly the core language standard

00:50:15,950 --> 00:50:20,690
needs to hook into so my recommendations

00:50:18,770 --> 00:50:22,280
for students it is super awesome the

00:50:20,690 --> 00:50:24,500
type of ratio trip that it does and that

00:50:22,280 --> 00:50:25,970
small functor optimization and all the

00:50:24,500 --> 00:50:27,560
other stuff it does it's really really

00:50:25,970 --> 00:50:30,620
great and super nasty to write by hand

00:50:27,560 --> 00:50:33,020
so definitely used to function but only

00:50:30,620 --> 00:50:34,970
use it when you need it I've seen people

00:50:33,020 --> 00:50:36,800
go crazy with good function when they

00:50:34,970 --> 00:50:39,080
don't if you're writing something like

00:50:36,800 --> 00:50:41,330
an algorithm that accepts some arbitrary

00:50:39,080 --> 00:50:44,030
thing it should probably be a template

00:50:41,330 --> 00:50:46,190
and with invoke now you can write such a

00:50:44,030 --> 00:50:49,310
template that accepts arbitrary callable

00:50:46,190 --> 00:50:51,260
objects your you'll be templated on the

00:50:49,310 --> 00:50:52,850
call by object type you won't be storing

00:50:51,260 --> 00:50:55,610
it anywhere you'll just directly invoke

00:50:52,850 --> 00:50:56,240
it things will be great or if at local

00:50:55,610 --> 00:50:58,880
scope your

00:50:56,240 --> 00:51:02,330
storing something like a lambda or maybe

00:50:58,880 --> 00:51:05,840
a call to bind you should use Otto to

00:51:02,330 --> 00:51:07,250
make the type of the function object the

00:51:05,840 --> 00:51:08,510
same as the type of what it's

00:51:07,250 --> 00:51:10,400
initializing you don't need stood

00:51:08,510 --> 00:51:12,380
function from that you only need it when

00:51:10,400 --> 00:51:13,730
you need that type of race your trip or

00:51:12,380 --> 00:51:15,590
something like I need to store stood

00:51:13,730 --> 00:51:16,940
function and then maybe later assign it

00:51:15,590 --> 00:51:19,340
to be something else that's a different

00:51:16,940 --> 00:51:21,680
type stood function is useful there

00:51:19,340 --> 00:51:24,590
it has nonzero costs and people often

00:51:21,680 --> 00:51:25,970
don't appreciate this usually the stl is

00:51:24,590 --> 00:51:27,920
like zero overhead essentially we're

00:51:25,970 --> 00:51:30,170
negative overhead Stern function though

00:51:27,920 --> 00:51:32,510
because of the fact that it needs to do

00:51:30,170 --> 00:51:34,130
type erasure it prevents inlining

00:51:32,510 --> 00:51:37,310
because it's going through the moral

00:51:34,130 --> 00:51:39,050
equivalent of a virtual function call it

00:51:37,310 --> 00:51:40,880
also has space costs we're going to have

00:51:39,050 --> 00:51:43,010
that small functor optimization buffer

00:51:40,880 --> 00:51:44,900
regardless of whether your function

00:51:43,010 --> 00:51:46,550
object is smaller than it or if it's too

00:51:44,900 --> 00:51:48,410
big it needs to be dynamically allocated

00:51:46,550 --> 00:51:50,030
you pay that space cost regardless of

00:51:48,410 --> 00:51:51,260
whether you use all of it and also the

00:51:50,030 --> 00:51:54,100
type of racial trick needs a couple

00:51:51,260 --> 00:51:56,960
pointers and you're paying that also

00:51:54,100 --> 00:51:58,550
template code blows template code bloat

00:51:56,960 --> 00:52:00,020
I'm going to say it's a myth I have

00:51:58,550 --> 00:52:02,270
almost never seen it matter

00:52:00,020 --> 00:52:04,220
in practice templates instantiate just

00:52:02,270 --> 00:52:06,650
what you have written by hand the one

00:52:04,220 --> 00:52:08,300
time I've seen template code bloat be an

00:52:06,650 --> 00:52:10,430
issue in practice is when somebody went

00:52:08,300 --> 00:52:12,380
crazy with stood function and used it

00:52:10,430 --> 00:52:14,300
all over the place one of the reasons

00:52:12,380 --> 00:52:16,670
why this is an issues could stood

00:52:14,300 --> 00:52:18,800
function emits code like stuff needed to

00:52:16,670 --> 00:52:20,990
copy and move the and swap the

00:52:18,800 --> 00:52:23,060
underlying function object regardless of

00:52:20,990 --> 00:52:25,880
whether you actually call it so that's a

00:52:23,060 --> 00:52:29,210
cost it makes your binder is bigger so

00:52:25,880 --> 00:52:30,890
if you do your stood function take into

00:52:29,210 --> 00:52:34,010
account all that I've said you should

00:52:30,890 --> 00:52:35,360
still use it efficiently it's a somewhat

00:52:34,010 --> 00:52:37,250
heavyweight objects you don't want to

00:52:35,360 --> 00:52:38,750
copy it unnecessarily you also don't

00:52:37,250 --> 00:52:40,190
want to move it unnecessarily and you

00:52:38,750 --> 00:52:42,230
don't want to make temporaries for no

00:52:40,190 --> 00:52:43,550
reason only construct things when you

00:52:42,230 --> 00:52:45,140
really need them it's kind of like a

00:52:43,550 --> 00:52:48,040
stood string but a little more expensive

00:52:45,140 --> 00:52:51,170
so more info I promised at the beginning

00:52:48,040 --> 00:52:53,510
all this stuff has been implement with

00:52:51,170 --> 00:52:55,430
couple exceptions first because of

00:52:53,510 --> 00:52:57,170
es2015 does not support expressions

00:52:55,430 --> 00:52:59,330
feigning in the compiler we have not

00:52:57,170 --> 00:53:01,640
implemented the result of and functions

00:52:59,330 --> 00:53:03,110
Fein a and I have refused to use library

00:53:01,640 --> 00:53:04,790
only tricks to do it in the absence of

00:53:03,110 --> 00:53:06,890
compiler support at some point in the

00:53:04,790 --> 00:53:08,660
future we will get that in library but

00:53:06,890 --> 00:53:08,960
currently we're following the 11 rules

00:53:08,660 --> 00:53:10,280
that

00:53:08,960 --> 00:53:12,200
say that result of his double chrome

00:53:10,280 --> 00:53:13,550
type does not Sweeney away and stood

00:53:12,200 --> 00:53:15,920
function does not have the

00:53:13,550 --> 00:53:18,440
disambiguation trick also while I

00:53:15,920 --> 00:53:20,359
rewrote functional to purge all the bugs

00:53:18,440 --> 00:53:22,070
in there the multi-threading headers use

00:53:20,359 --> 00:53:24,230
the stuff slightly incorrectly async

00:53:22,070 --> 00:53:25,849
uses bind it really shouldn't package

00:53:24,230 --> 00:53:27,619
tasks uses to function and hence

00:53:25,849 --> 00:53:30,710
requires copy constructibility it really

00:53:27,619 --> 00:53:32,300
shouldn't and also i tried to be sneaky

00:53:30,710 --> 00:53:33,740
and mem fun to handle the non-standard

00:53:32,300 --> 00:53:36,050
calling conventions I thought surely

00:53:33,740 --> 00:53:37,550
nobody will notice that my template

00:53:36,050 --> 00:53:39,470
arguments don't exactly match what's in

00:53:37,550 --> 00:53:41,839
the standard inevitably somebody notice

00:53:39,470 --> 00:53:43,369
to file the bug I fixed that already for

00:53:41,839 --> 00:53:45,320
update one and that will ship so I'll

00:53:43,369 --> 00:53:47,480
follow the standard strictly and I've

00:53:45,320 --> 00:53:50,000
included a link there to the c sp70

00:53:47,480 --> 00:53:51,890
merkel paper so okay looks like we've

00:53:50,000 --> 00:53:52,700
got some minutes left let's take some

00:53:51,890 --> 00:53:57,170
questions

00:53:52,700 --> 00:53:59,390
I do we've microphone setup no

00:53:57,170 --> 00:54:09,980
microphones okay so I will just go left

00:53:59,390 --> 00:54:11,630
to right question there okay yes I would

00:54:09,980 --> 00:54:14,599
say there are there may be minor

00:54:11,630 --> 00:54:15,980
differences between a boost in the

00:54:14,599 --> 00:54:17,300
standard library but in general the

00:54:15,980 --> 00:54:19,220
booster interface especially if you're

00:54:17,300 --> 00:54:21,680
compiling it in CS plus 11 mode with a

00:54:19,220 --> 00:54:22,940
new compiler should behave very much

00:54:21,680 --> 00:54:26,420
like this I believe in a couple cases

00:54:22,940 --> 00:54:27,980
boost is added extensions that the

00:54:26,420 --> 00:54:30,740
standard library does not have I need to

00:54:27,980 --> 00:54:31,970
go look it up but the vast majority of

00:54:30,740 --> 00:54:33,290
stuff will port over now boost is

00:54:31,970 --> 00:54:35,869
probably not learned the very recent

00:54:33,290 --> 00:54:38,300
tricks like the conversion to actually

00:54:35,869 --> 00:54:41,240
I'd have had the conversion avoid bit I

00:54:38,300 --> 00:54:43,580
would have to go look that up but like

00:54:41,240 --> 00:54:44,960
the result of speen a I'm sure Eric me

00:54:43,580 --> 00:54:47,230
blurr has checked that into booze so

00:54:44,960 --> 00:54:57,050
almost everything should work with boost

00:54:47,230 --> 00:54:59,770
other questions yeah there okay yep

00:54:57,050 --> 00:54:59,770
slide 18

00:55:09,760 --> 00:55:24,710
right okay there to detect uh

00:55:19,490 --> 00:55:27,020
something's called yeah yeah the

00:55:24,710 --> 00:55:29,690
question is with the library

00:55:27,020 --> 00:55:31,310
fundamentals void the detection idiom

00:55:29,690 --> 00:55:35,570
void T sort of thing I should forty was

00:55:31,310 --> 00:55:36,710
a danseuse 217 is a result of more

00:55:35,570 --> 00:55:38,839
useful that you can detect whether

00:55:36,710 --> 00:55:40,760
something is cobble and I would say

00:55:38,839 --> 00:55:43,099
maybe you could still write the Deco

00:55:40,760 --> 00:55:46,040
type by hand I mean that ultimately it

00:55:43,099 --> 00:55:49,339
is just a syntactic convenience for this

00:55:46,040 --> 00:55:51,020
deco type and VOC deck Laval thing but

00:55:49,339 --> 00:55:53,150
if you know the protocol that it uses

00:55:51,020 --> 00:55:56,150
then feel free to use result of just be

00:55:53,150 --> 00:55:57,710
aware that the value category like the L

00:55:56,150 --> 00:55:59,150
value reference or r-value reference

00:55:57,710 --> 00:56:01,220
that you put in there and the CD

00:55:59,150 --> 00:56:03,589
qualifiers manner but if you're at that

00:56:01,220 --> 00:56:06,260
level of a generic code then result of

00:56:03,589 --> 00:56:07,760
is not evil it's just requires skill to

00:56:06,260 --> 00:56:10,069
use properly like a very dangerous

00:56:07,760 --> 00:56:14,270
chainsaw and you said you had another

00:56:10,069 --> 00:56:15,500
question okay let's take other question

00:56:14,270 --> 00:56:18,520
I'll come back to you any other

00:56:15,500 --> 00:56:18,520
questions yeah over there

00:56:38,630 --> 00:56:53,859
right changing the behavior yeah right

00:56:56,470 --> 00:57:01,249
yes it's just it's does the question is

00:56:59,239 --> 00:57:03,229
what about movable only function objects

00:57:01,249 --> 00:57:05,779
the answer is it's a design limitation

00:57:03,229 --> 00:57:08,690
the standard library has no type erased

00:57:05,779 --> 00:57:10,430
wrapper for a move only function objects

00:57:08,690 --> 00:57:12,499
you can write your own you can write

00:57:10,430 --> 00:57:14,180
wrappers that sort of high jacket in the

00:57:12,499 --> 00:57:16,700
students like you could write something

00:57:14,180 --> 00:57:18,710
that is copyable but if you try to copy

00:57:16,700 --> 00:57:20,809
constructor it throws stood function

00:57:18,710 --> 00:57:22,700
will happily throw that happily store

00:57:20,809 --> 00:57:25,519
that and don't throw if you don't copy

00:57:22,700 --> 00:57:28,160
it but it's subverting the type system a

00:57:25,519 --> 00:57:29,869
little like I said something we'll

00:57:28,160 --> 00:57:31,700
probably propose from stare in the

00:57:29,869 --> 00:57:33,380
future but it has no support for that

00:57:31,700 --> 00:57:41,239
right now just like it has no support

00:57:33,380 --> 00:57:42,589
for say parsing XML or something it may

00:57:41,239 --> 00:57:44,749
show up in a library fundamentals chess

00:57:42,589 --> 00:57:46,400
first I don't think it would make

00:57:44,749 --> 00:57:48,109
seventeen at this point there's still a

00:57:46,400 --> 00:57:49,549
couple years out but there's no concrete

00:57:48,109 --> 00:57:51,229
proposal yet as does the committee has

00:57:49,549 --> 00:57:53,809
been talking about what would it look

00:57:51,229 --> 00:57:57,589
like to have you move baloney function

00:57:53,809 --> 00:58:08,839
wrapper other questions before I come

00:57:57,589 --> 00:58:10,759
back yes ask away yes we're still using

00:58:08,839 --> 00:58:14,359
dink more standard library I just take

00:58:10,759 --> 00:58:16,160
in PG up harbors functional header which

00:58:14,359 --> 00:58:18,410
I had been maintaining over the years

00:58:16,160 --> 00:58:19,940
and I ripped out almost everything

00:58:18,410 --> 00:58:21,650
except for the skeleton stood function

00:58:19,940 --> 00:58:23,719
and rewrote it all the process about

00:58:21,650 --> 00:58:26,119
four months and then shipped the changes

00:58:23,719 --> 00:58:27,799
back and at the old implementation it

00:58:26,119 --> 00:58:29,779
was extremely good back in the chair one

00:58:27,799 --> 00:58:32,180
ERA I could not have written it before

00:58:29,779 --> 00:58:35,019
be a depth type before forwarding and

00:58:32,180 --> 00:58:37,130
before very attic templates but as

00:58:35,019 --> 00:58:39,410
things evolved in CS plus eleven and

00:58:37,130 --> 00:58:43,069
fourteen the code was extremely

00:58:39,410 --> 00:58:44,359
difficult to maintain and extend as new

00:58:43,069 --> 00:58:47,420
features were voted in so that's why I

00:58:44,359 --> 00:58:48,920
rewrote it from scratch using an action

00:58:47,420 --> 00:58:50,180
a student vote that had perfect

00:58:48,920 --> 00:58:52,809
forwarding deco type and all that and

00:58:50,180 --> 00:58:52,809
purged all the bugs

00:58:55,150 --> 00:59:04,130
right yes

00:59:00,680 --> 00:59:06,440
please submit a bug yes absolutely

00:59:04,130 --> 00:59:07,970
you can also file bugs through Kinect or

00:59:06,440 --> 00:59:13,510
send a smile but talking to me is fine

00:59:07,970 --> 00:59:13,510
too yeah another question there yep

00:59:22,250 --> 00:59:26,810
the question is how to write things that

00:59:24,470 --> 00:59:27,470
take lambdas if you're writing the

00:59:26,810 --> 00:59:29,750
algorithm

00:59:27,470 --> 00:59:31,790
you could follow the stos convention of

00:59:29,750 --> 00:59:33,230
taking function objects by value the

00:59:31,790 --> 00:59:34,760
reason why did that 98 is so you could

00:59:33,230 --> 00:59:37,220
accept things that had either Const rely

00:59:34,760 --> 00:59:39,410
on cosmic sha function co-operators but

00:59:37,220 --> 00:59:41,510
you could also write it to take callable

00:59:39,410 --> 00:59:43,460
ref ref this would be like stood shuffle

00:59:41,510 --> 00:59:45,170
and that takes the thing in place and

00:59:43,460 --> 00:59:47,360
then invokes it and if you want to be

00:59:45,170 --> 00:59:49,070
real cool you would say forward callable

00:59:47,360 --> 00:59:50,960
to respect the original value category

00:59:49,070 --> 00:59:52,730
I'm going for it I'd say that's probably

00:59:50,960 --> 00:59:58,100
the right thing to do if you don't need

00:59:52,730 --> 00:59:59,360
to copy the thing game in it yeah if you

00:59:58,100 --> 01:00:01,870
call it then you would obviously not say

00:59:59,360 --> 01:00:03,920
stood forward but then if you took

01:00:01,870 --> 01:00:05,630
callable ref ref you'd be saying I

01:00:03,920 --> 01:00:07,160
accept an arbitrary thing and then I'm

01:00:05,630 --> 01:00:09,170
going to call it multiple times that

01:00:07,160 --> 01:00:10,730
would be acceptable I would say that

01:00:09,170 --> 01:00:12,110
maybe the new convention going forward

01:00:10,730 --> 01:00:13,820
it's usually not a good idea to just

01:00:12,110 --> 01:00:15,110
randomly violate standard library

01:00:13,820 --> 01:00:17,930
conventions but in this case it was due

01:00:15,110 --> 01:00:20,240
to CS + O 3 limitation it looks like our

01:00:17,930 --> 01:00:22,010
time is up for a 10 so I'll be around

01:00:20,240 --> 01:00:23,510
all week please come to me and ask any

01:00:22,010 --> 01:00:25,750
other questions you have thanks for

01:00:23,510 --> 01:00:25,750

YouTube URL: https://www.youtube.com/watch?v=zt7ThwVfap0


