Title: CppCon 2015: Arthur O'Dwyer “Lambdas from First Principles: A Whirlwind Tour of C++"”
Publication date: 2015-10-08
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Lambdas (even those mysterious generic lambdas) are just syntactic sugar atop constructs that are perfectly understandable when approached from the right direction.

We'll start with the implementation of C-style functions, then move to overloading, function templates, non-static member functions, C++11 lambdas, and then demystify C++14 generic ("auto") lambdas. Finally, we'll detour into the implementations of std::function and std::bind to show how they're different from lambdas.
— 
Arthur O'Dwyer worked for many years at Green Hills Software, making the world's most optimizing C and C++ compilers. Now he works at Mixpanel in San Francisco, where he organizes a monthly C++ meetup.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,670
All right, welcome again everybody. I'm Arthur O'Dwyer, and this talk is on "Lambdas from First Principles."

00:00:06,840 --> 00:00:11,640
This is designed to teach you all about lambdas, and what they are, and how to use them,

00:00:11,640 --> 00:00:17,060
and that they are not in fact big, scary, Lispy, functional-programmy things.

00:00:17,060 --> 00:00:22,540
They actually interoperate really well with C++. And here's how you use them.

00:00:23,460 --> 00:00:28,120
I like to be a little bit interactive, but also not super interactive, with questions,

00:00:28,120 --> 00:00:34,120
because we do have — ah, 68 slides, I think — to get through in an hour...

00:00:34,620 --> 00:00:38,820
But basically, for questions, if I'm going along and you have a question about something,

00:00:38,820 --> 00:00:44,580
and it's a question like, "I don't get what you just said," or "Doesn't that contradict what you just said?",

00:00:44,580 --> 00:00:48,120
Please do raise your hand and I'll try to clarify.

00:00:48,120 --> 00:00:55,880
If you have a question like, "Okay, I see how that works in that case, but what about the case where it's a variadic template?",

00:00:55,880 --> 00:01:01,760
Please don't ask those questions until the end. Because we probably will get to that answer in about five slides.

00:01:01,840 --> 00:01:06,900
So. No questions that complexify things. Yes questions if you're confused about a concept.

00:01:06,900 --> 00:01:10,520
Because the point of this is really to explain the concepts.

00:01:11,140 --> 00:01:15,080
Okay, so, whirlwind tour of C++. Let's start really simple.

00:01:15,160 --> 00:01:17,160
Plain old functions.

00:01:17,320 --> 00:01:20,620
Because lambdas are kind of like functions, right?

00:01:21,720 --> 00:01:27,620
So, ah... yes? [CAMERAMAN] You're good. All right.

00:01:27,880 --> 00:01:33,380
Plain old functions. Here's a function. I named it `plus1`. What it does, it takes its argument and adds 1 to it.

00:01:33,380 --> 00:01:39,200
Over on the right I'm showing the disassembly. I'm going to be showing some disassembly as we go along.

00:01:39,200 --> 00:01:50,460
This is what you would get if you compile it with Clang on — I believe this is OS X, just because that's my platform of choice.

00:01:50,460 --> 00:01:55,360
So, x86-64, with the Clang mangling scheme.

00:01:56,940 --> 00:02:02,160
How many people are familiar...ish... with name mangling in C++?

00:02:02,160 --> 00:02:06,500
Bunches. Okay, good. So you all know what that means.

00:02:06,700 --> 00:02:14,100
So that's easy right? It's a function. It's a named chunk of code. The name is some mangled form of the function name.

00:02:15,300 --> 00:02:19,500
C++ lets us overload functions! So I can have a function named `plus1` that takes an int;

00:02:19,500 --> 00:02:23,300
I can have another function — also named `plus1` — that takes a double.

00:02:23,300 --> 00:02:30,280
And then if I call `plus1` with an int, I get one version; if I call `plus1` with a double I get a different version.

00:02:30,280 --> 00:02:37,680
And this is indicated at the assembly level by a difference in the name mangling of the function name.

00:02:37,680 --> 00:02:43,000
So, two blocks of code, both callable as `plus1` in your C++ code,

00:02:43,000 --> 00:02:45,160
but of course they have different name-manglings.

00:02:45,160 --> 00:02:47,640
So far, so simple. We all know this.

00:02:47,640 --> 00:02:50,600
Function templates!

00:02:50,620 --> 00:02:54,380
So C++ also lets us write templates.

00:02:54,380 --> 00:03:00,720
So when we want to stamp out copies of a function that all have the same behavior —

00:03:00,720 --> 00:03:04,660
— in the previous slide I have these two functions,

00:03:04,660 --> 00:03:11,880
one adds 1 to ints, one adds 1 to doubles. If I want one to add 1 to complex numbers, or long doubles, or whatever...

00:03:11,880 --> 00:03:15,200
I would just keep adding overloads and overloads and overloads.

00:03:15,400 --> 00:03:21,980
But we have the function template which allows us to stamp out copies for any type that we want.

00:03:22,940 --> 00:03:28,880
And again, those are instantiated on demand.

00:03:28,880 --> 00:03:32,400
They get name-mangled slightly differently yet again.

00:03:32,920 --> 00:03:41,940
Notice that the template `plus1` instantiated with `int` is a different entity, indicated by a different name-mangling,

00:03:41,940 --> 00:03:46,440
than, in the previous slide, the `plus1` overload that took an `int` parameter.

00:03:48,300 --> 00:03:51,700
Things about templates — I'm going to go a little bit into templates and then we're going to drop templates for a bit.

00:03:51,720 --> 00:03:53,920
And then we're going to come back to them later.

00:03:53,920 --> 00:03:56,700
Let's go a little deeper into templates.

00:03:57,580 --> 00:04:02,200
So when I call `plus1(42)`, where `42` is an int,

00:04:02,200 --> 00:04:11,340
The compiler can use type deduction to know that, okay, you want the `plus1` that takes an int.

00:04:11,960 --> 00:04:17,860
And, well, one doesn't really seem to exist yet, so I'm going to stamp one out for you, by instantiating this template.

00:04:17,860 --> 00:04:22,520
When we call `plus1(3.14)`... well, that's a double, so you must want a `plus1` that takes a double.

00:04:22,520 --> 00:04:26,120
I'll stamp one out for you — I'll instantiate it.

00:04:28,780 --> 00:04:32,320
We can also tell the compiler explicitly,

00:04:32,320 --> 00:04:35,840
"Even though I'm passing `42`, which looks like an int..."

00:04:35,840 --> 00:04:41,300
"...I do really want the version that takes it as a double; and please convert 42 to a double."

00:04:41,300 --> 00:04:48,680
I can explicitly say I want `plus1<double>`, with `double` in angle brackets providing the `T` explicitly.

00:04:49,520 --> 00:04:54,420
And, vice versa, there are a couple of contexts which are not function calls

00:04:54,420 --> 00:04:58,880
where the compiler will do type deduction for us. Which is actually really handy.

00:04:58,880 --> 00:05:05,080
For example, I can take `plus1` here — just the name `plus1`, without saying `plus1<int>` or `plus1<double>` —

00:05:05,080 --> 00:05:12,020
And as long as I'm storing it into, let's say, a function pointer that takes an int and returns an int,

00:05:12,020 --> 00:05:16,260
the compiler can say, oh, well, you must want `plus1<int>`!

00:05:16,260 --> 00:05:19,240
It is smart enough to do that.

00:05:19,980 --> 00:05:27,960
You might say, well, what if I took this `plus1` and assigned it into, like, `auto`?

00:05:28,380 --> 00:05:32,160
Then how does it deduce what the type of `T` is,

00:05:32,160 --> 00:05:34,120
and how does it deduce which `plus1` to use?

00:05:34,120 --> 00:05:35,740
And the answer is, it doesn't.

00:05:35,740 --> 00:05:39,800
A function TEMPLATE is not the same thing as a FUNCTION, right?

00:05:39,800 --> 00:05:47,040
The function TEMPLATE is a source-level construct, and...

00:05:47,040 --> 00:05:52,120
if you use it in a context where it's ambiguous, the compiler will give you a diagnostic of some sort.

00:05:52,120 --> 00:05:59,620
In this case, Clang complains about "incompatible initializer of type..." and then in brackets it just says "<overloaded function type>".

00:05:59,620 --> 00:06:02,900
Because the type doesn't have a name. It's a template.

00:06:04,260 --> 00:06:10,060
All right, one more little thing — the first puzzle. There are three puzzles in this talk.

00:06:11,200 --> 00:06:14,580
One more thing about templates before we move on.

00:06:15,120 --> 00:06:19,780
Here I have a function template named `kitten`.

00:06:19,780 --> 00:06:26,380
It has a static local variable of type `int`, initialized to zero...

00:06:26,380 --> 00:06:31,040
...and every time we call `kitten` we're going to `++` that variable. Right?

00:06:31,040 --> 00:06:39,900
I call `kitten(1)`, where `T` gets deduced as `int`, and that's going to print...?

00:06:39,900 --> 00:06:46,200
..."2". Yeah. Okay. And then I call `kitten` again with `3.14`...

00:06:46,200 --> 00:06:51,240
(This is even harder math. I know.) But it's gonna print...?

00:06:51,900 --> 00:06:56,140
..."4.14". Yes. Not "5.14"!

00:06:58,420 --> 00:07:02,840
Yes! Even though the int was static. Because it is a DIFFERENT static int.

00:07:02,840 --> 00:07:11,120
Here's the codegen. We have two instantiations here, with different name manglings and different code.

00:07:11,120 --> 00:07:17,000
You notice that the one for `int`, you know, it's involving lots of sort of "inty" operations.

00:07:17,000 --> 00:07:22,140
And here's the one for `double`, and it — well, it does some stuff with the XMM registers, the `double` registers.

00:07:22,980 --> 00:07:29,960
So they have different codegen. And, going along with that, each of them gets its own set of static local variables and so on.

00:07:29,960 --> 00:07:36,640
Here we have the `x` for the `double` version, and this is the `x` for the `int` version.

00:07:36,640 --> 00:07:39,500
They don't share memory.

00:07:39,500 --> 00:07:45,300
They're two completely separate variables because we have two completely separate instantiations of this template.

00:07:45,300 --> 00:07:50,340
This is made a little bit clearer by — like, you might say, "Well, that just seems dumb."

00:07:50,340 --> 00:07:56,620
Like "Why did the standards committee make that decision? Why DON'T we have one variable `x`?" That's what I want, right?

00:07:56,620 --> 00:08:02,980
Well, not really. Because what if, instead of `int x` right here...

00:08:02,980 --> 00:08:07,360
We made it `T x`. What if we made it something template-dependent?

00:08:07,360 --> 00:08:11,600
You can do that, right? You can have a local variable of template-dependent type.

00:08:12,980 --> 00:08:20,320
For example, in this case, when I have `kitten<int>`, `T` is `int` and `x` is of type int.

00:08:20,320 --> 00:08:26,800
When I have `kitten<double>`, well, my `T` now — my `x` now — for this function need to be of type double.

00:08:26,800 --> 00:08:31,380
So it's kind of obvious at this point that we're going to NEED two different variables.

00:08:31,380 --> 00:08:35,540
The int variable for the int version, the double variable for the double version.

00:08:35,540 --> 00:08:40,380
So. Templates and statics. Little pitfall. Little sneaky there.

00:08:40,700 --> 00:08:48,500
All right, we'll come back to templates later. Let's go back to what other crazy things can we do with functions in C++.

00:08:48,500 --> 00:08:51,920
Well, you can make member functions! I can have a class. I'm going to call this class `Plus`.

00:08:51,920 --> 00:08:56,960
It's going to have a data member named `value`.

00:08:56,960 --> 00:09:01,520
You can instantiate it — or, uh, you know, you can get an instance of this class —

00:09:01,520 --> 00:09:03,660
by calling its constructor...

00:09:04,780 --> 00:09:09,480
And it's going to have a member function which I'm just going to call `plusme`.

00:09:09,480 --> 00:09:14,920
If I have a `Plus` object, I can call, like, `myPlusObject`, dot, `plusme`, give it an int...

00:09:14,920 --> 00:09:20,840
...and it gives me back the sum of the int I gave it and the int that was given in its constructor.

00:09:24,160 --> 00:09:27,260
Another little digression. I love digressions.

00:09:28,500 --> 00:09:32,660
When I call `plus.plusme` of, let's say, `42`...

00:09:32,660 --> 00:09:39,220
How does the `plus` object know to go call this code?

00:09:39,220 --> 00:09:47,740
Like, this object has to KNOW, "oh yeah, when you call `plusme` on me, that means this code here."

00:09:48,300 --> 00:09:52,760
Is there some sort of pointer to that code somewhere?

00:09:52,760 --> 00:09:57,520
No! C++ is not Java. Thank God.

00:09:57,520 --> 00:10:00,020
In the Java approach, there would be that pointer.

00:10:00,020 --> 00:10:08,880
There, every object is allocated on the heap, and has a vptr that points to a table of "here are all the behaviors for this object."

00:10:09,180 --> 00:10:14,820
That's nice in that we can now pass a pointer to this object around and the object knows its own behaviors.

00:10:15,860 --> 00:10:22,400
It is NOT so nice in that now we've got, like, 1, 2, 3 pointers here...

00:10:22,400 --> 00:10:26,000
...that you have to follow whenever you want to do something with this object.

00:10:26,580 --> 00:10:31,960
C++ lets you do this via virtual member functions, which we're actually not going to talk about...

00:10:33,180 --> 00:10:34,220
surprisingly...

00:10:35,420 --> 00:10:37,780
But of course in C++ it just looks like this.

00:10:38,360 --> 00:10:46,180
On the stack we have our `Plus` object just sitting right there. It doesn't need to be on the heap.

00:10:46,180 --> 00:10:49,800
We don't want to use the heap. We don't want to use dynamic memory management.

00:10:51,360 --> 00:10:59,680
And the function, the implementation of the function, is just sitting there in the static code. And there is no linkage between them at all.

00:10:59,680 --> 00:11:07,680
There's just sort of an implicit — like, the compiler just knows that when I'm doing something on a `Plus` object,

00:11:07,680 --> 00:11:11,640
of course I'm going to use `Plus`'s member function.

00:11:14,320 --> 00:11:21,520
So yeah, C++ lets us get rid of all this dynamic memory management and whatnot that you have in Java, and so on.

00:11:21,520 --> 00:11:24,340
But you knew that, because you're here!

00:11:26,440 --> 00:11:28,900
All right, so, class member functions.

00:11:30,600 --> 00:11:34,260
Now this member function, I just named it `plusme`.

00:11:34,260 --> 00:11:38,440
But let's say this was the ONLY thing that I could do with a `Plus` object...

00:11:38,440 --> 00:11:42,780
C++ also gives us the ability to do operator overloading.

00:11:42,780 --> 00:11:49,300
So I could actually overload the function-call operator on my `Plus` object, right?

00:11:49,780 --> 00:11:55,420
Exact same codegen as before. The only difference is that the name-mangling has changed a little bit...

00:11:55,420 --> 00:12:06,140
This name mangling right here has changed from being the name of the class and the member function, to being just `cl`, which stands for "call."

00:12:08,320 --> 00:12:10,320
So let's see.

00:12:12,360 --> 00:12:19,300
So I can overload an operator. And then when I call it — you'll notice that the call changed...

00:12:19,300 --> 00:12:25,180
From `plus.plusme(42)`... now I can just say `plus(42)`...

00:12:25,180 --> 00:12:28,700
And the compiler will know, oh, okay, you mean to call `operator()` here.

00:12:28,700 --> 00:12:34,060
And of course then it puts the call to `operator()` in there statically, because: static typing.

00:12:35,140 --> 00:12:39,200
Now we can do something kind of nifty!

00:12:39,200 --> 00:12:41,260
We take this code I just wrote...

00:12:41,260 --> 00:12:50,920
where we have this class, and the call operator, and the constructor, and where we create objects of this type using the constructor...

00:12:52,960 --> 00:13:00,340
The syntax highlighting that I've used here is, in red, in bold, I've put the irreducible complexity.

00:13:00,340 --> 00:13:07,560
The stuff that — well, this is just what it does, right? I can't get around the fact that there is a member named `value`...

00:13:07,560 --> 00:13:15,280
or that my `operator()` takes another int, or that what it does is add them together. Right?

00:13:15,280 --> 00:13:17,720
That's the fundamental semantics of my class.

00:13:17,720 --> 00:13:25,760
But everything in the in the light green there is just boilerplate. I don't want to have to write that. That's a lot of boilerplate.

00:13:25,760 --> 00:13:28,800
So let's just get rid of all the green!

00:13:30,160 --> 00:13:34,120
Okay, all the green is now gone, except for a lot of brackets.

00:13:34,120 --> 00:13:37,780
Actually, one of each kind of bracket.

00:13:37,780 --> 00:13:39,860
It's a very fair language.

00:13:42,700 --> 00:13:44,960
And a little `=` sign there.

00:13:45,540 --> 00:13:51,700
So now we're saying very succinctly what we want to say about this entity in our code.

00:13:51,700 --> 00:13:55,320
We've thrown away all of that reducible complexity

00:13:55,320 --> 00:14:00,900
about what is the name of the class and the fact that you have to write out its constructor,

00:14:00,900 --> 00:14:03,940
and now we're just saying it's got a member named `value`

00:14:03,940 --> 00:14:08,100
Here's the initial value for `value`, by the way. We're going to pass in `1`.

00:14:08,100 --> 00:14:11,200
But we could pass in any expression that we wanted, of course.

00:14:11,940 --> 00:14:15,420
And it has an argument, and we have to give the argument's type...

00:14:15,420 --> 00:14:20,080
and we have to give the argument a name, because we're going to refer to it later, right? So we give it a name, `x`...

00:14:20,080 --> 00:14:22,840
and then we say here's the behavior.

00:14:22,840 --> 00:14:26,800
And that's it! And we wrap that all up, and that is a lambda expression!

00:14:27,980 --> 00:14:29,600
And we use it exactly the same way.

00:14:30,040 --> 00:14:35,060
You'll notice that the `assert` down at the bottom, that's checking the behavior of our object `plus`,

00:14:35,060 --> 00:14:38,560
where before it was constructed explicitly as a `Plus` object...

00:14:38,560 --> 00:14:46,900
Now it's just constructed as a lambda expression, which produces one of these anonymous class objects,

00:14:46,900 --> 00:14:49,120
and it behaves exactly the same way.

00:14:50,280 --> 00:14:54,560
And the codegen is exactly the same! Same implementation.

00:14:54,560 --> 00:14:59,860
Except that now of course we don't have a capital-P `Plus` object anymore.

00:14:59,860 --> 00:15:04,060
Because we just removed that name from our code. There's no more names in our code.

00:15:04,060 --> 00:15:07,320
So the compiler makes up a name for this class.

00:15:07,320 --> 00:15:12,460
And, at least in Clang's mangling scheme, it just says `$_0`.

00:15:12,460 --> 00:15:20,480
"Dollar sign, underscore, integer" is the the naming scheme for these anonymous objects.

00:15:22,140 --> 00:15:29,760
Let's see... so now, on the stack, instead of having `plus`, a `Plus` object, I have `plus`, a `$_0` object.

00:15:29,760 --> 00:15:34,760
And instead of calling `Plus::operator()`, it's calling `$_0::operator()`,

00:15:34,760 --> 00:15:38,720
indicated by the mangling down there in the fine print that I don't know if you can read in the back

00:15:39,760 --> 00:15:42,300
And the codegen is exactly the same.

00:15:44,060 --> 00:15:45,620
Awesome.

00:15:45,620 --> 00:15:50,120
Oh, by the way, I do want to point out that this `value=1` syntax...

00:15:50,120 --> 00:15:56,440
This is C++14 "generalized lambda capture", also known as "init-capture."

00:15:56,900 --> 00:16:03,560
I like it, for reasons you're about to see. But be aware that if you're on C++11, you don't actually have this syntax.

00:16:05,720 --> 00:16:09,160
[INAUDIBLE FROM AUDIENCE]

00:16:09,160 --> 00:16:15,840
You just assumed you knew everything about lambdas... well, haha! you don't! —anymore. Yes.

00:16:15,840 --> 00:16:20,200
For almost two years now, you don't know everything about lambdas.

00:16:20,200 --> 00:16:21,880
Before that you did though

00:16:22,940 --> 00:16:30,260
And so this gives us the ability to have sort of Lisp-style, functional-programming-style closures...

00:16:31,100 --> 00:16:35,380
without heap allocation and without garbage collection.

00:16:35,380 --> 00:16:39,580
Because you saw we just built that out of the building blocks that already exist in C++, right?

00:16:39,580 --> 00:16:47,260
I mean, we can all write code that uses classes and so on — allocating them on the stack, RAII.

00:16:47,260 --> 00:16:54,720
We know how to write that kind of code without invoking the heap, and garbage collection,

00:16:54,720 --> 00:16:58,660
and dynamic typing, and so on and so forth

00:16:59,420 --> 00:17:04,920
So, since I can take that code — that we had — and remove all the boilerplate and get a lambda,

00:17:04,920 --> 00:17:11,060
obviously we can also implement lambdas without garbage collection and dynamic typing and so on and so forth.

00:17:11,060 --> 00:17:19,720
So those two things do not go hand-in-hand as you might think if you look at, you know, C++03 versus, like, Scheme,

00:17:19,720 --> 00:17:23,400
and said, "oh, I wish I had lambdas, but I can't get them without this other baggage."

00:17:23,400 --> 00:17:25,180
Well, yes, you can!

00:17:25,180 --> 00:17:28,300
Here's an example of how to use them...

00:17:28,300 --> 00:17:35,480
Let's say that I want to `std::sort` this vector of objects by some property...

00:17:35,480 --> 00:17:40,640
I can make myself up a little closure object here as a lambda expression.

00:17:40,640 --> 00:17:45,000
I'm going to take this `prop` that was passed in by the user —

00:17:45,000 --> 00:17:48,140
— and yeah, I'm passing things around by value. Meh.

00:17:48,140 --> 00:17:50,460
That's probably okay. Move semantics, right?

00:17:50,460 --> 00:17:56,120
I'm going to capture that property: I'm going to make a copy of it inside my closure.

00:17:57,480 --> 00:18:03,840
And now that I've captured that thing — which I'm naming `p` here for convenience. It's `prop` outside but it's `p` inside —

00:18:04,160 --> 00:18:06,920
just to make sure we know what we're talking about —

00:18:07,780 --> 00:18:14,360
inside the lambda I can say, you know, I'm given two objects and I compare that field of them.

00:18:14,360 --> 00:18:17,180
And then I can take this `pless` object and I can pass it to `std::sort`,

00:18:17,180 --> 00:18:20,500
and `std::sort` will sort things based on this predicate.

00:18:22,160 --> 00:18:24,140
Does that all make sense?

00:18:24,140 --> 00:18:26,800
I think we're about to see an example of that. ...We are! Okay.

00:18:28,300 --> 00:18:29,800
So here's what we might have coming into the function.

00:18:29,800 --> 00:18:37,100
I have my `prop`, which is a `std::string`, and so it controls some "hello" out there on the heap...

00:18:37,100 --> 00:18:40,900
which is the name of the key I'm sorting by. So maybe "hello" wasn't the best example.

00:18:42,380 --> 00:18:50,520
And then I make my closure object — so that's going to be a `$_1` object —

00:18:50,520 --> 00:18:57,680
And it is going to have inside it — captured — it's going to have a member variable which I've named `p`...

00:18:57,680 --> 00:18:59,480
that's that `p` right there [in pink]...

00:18:59,480 --> 00:19:07,380
and it's going to be initialized to a copy of `prop`, so it's going to copy out the "hello" right there.

00:19:07,380 --> 00:19:09,760
And that that's what it's going to look like.

00:19:09,760 --> 00:19:12,940
So, again, the lambda itself is not living out on the heap anywhere.

00:19:12,940 --> 00:19:17,480
There's the heap involved in this case because we're controlling std::strings.

00:19:17,480 --> 00:19:24,480
And again, there's this sort of magical compiler static-typing linkage between these things,

00:19:24,480 --> 00:19:28,960
that is not represented in the runtime, at runtime.

00:19:31,240 --> 00:19:35,760
Okay, so let's see some other alternative syntaxes for this!

00:19:35,760 --> 00:19:42,800
So I said this was the C++14 generalized capture. In C++11 you have a more restrictive version.

00:19:42,800 --> 00:19:46,060
You can't give things different names, but...

00:19:46,060 --> 00:19:52,260
you CAN say, "I want to capture the local variable in my outer scope named `prop`..."

00:19:52,260 --> 00:19:55,360
"I will capture it with that SAME name `prop` inside."

00:19:55,360 --> 00:20:01,840
But notice that `prop` inside refers to that pink `prop` that I captured. Not to the `prop` in the outer scope.

00:20:03,280 --> 00:20:06,020
So you can write that in C++11.

00:20:06,020 --> 00:20:12,100
Also C++11 — and of course also in C++14 you can continue to do that, but I don't really think you should —

00:20:12,100 --> 00:20:14,680
I don't know. I like explicit names.

00:20:14,680 --> 00:20:21,800
So we can also just say, "I'm going to capture everything. Everything I use inside, that you don't know what it is —"

00:20:21,800 --> 00:20:24,540
"Go look for it outside, and make a copy of it, please."

00:20:24,960 --> 00:20:28,760
So you can give a "default" capture semantics, a "capture-default."

00:20:30,540 --> 00:20:34,840
This, ah, many people consider to be a bad idea in general.

00:20:34,840 --> 00:20:42,740
It's certainly good that it's in the language! There are things you can do with it — you can put it inside macros and so on — that makes it very nice to have it in the language.

00:20:42,740 --> 00:20:45,960
But probably not something you should do a lot.

00:20:47,320 --> 00:20:48,660
Okay.

00:20:48,660 --> 00:20:55,280
Oh, and the other thing going on here, by the way — we were talking about doing all of this without garbage collection —

00:20:55,280 --> 00:21:01,120
you can see that once I've made this copy, the original `prop` can even go away

00:21:01,120 --> 00:21:03,480
and I just pass my lambda around.

00:21:04,660 --> 00:21:09,960
There's no dangling references, or even reference-counting going on.

00:21:09,960 --> 00:21:13,060
It's just "well, I made a copy. Now it's mine."

00:21:13,060 --> 00:21:15,880
So I can get rid of the original, if I want.

00:21:17,760 --> 00:21:22,560
But what if I WANT to capture a reference?

00:21:22,560 --> 00:21:29,440
Because this `prop` that I'm making the copy of — this is a really big box.

00:21:29,440 --> 00:21:35,840
I'm making this big copy. I don't want something this heavyweight. I want a nice lightweight pointer.

00:21:36,780 --> 00:21:40,020
So I want to be able to capture a reference. So what do I put

00:21:40,020 --> 00:21:43,660
in my capture-list here

00:21:43,660 --> 00:21:46,300
if I want to capture a reference?

00:21:48,120 --> 00:21:50,940
Well, I COULD do that [i.e., capture a std::reference_wrapper instead].

00:21:50,940 --> 00:21:52,880
[INAUDIBLE FROM AUDIENCE]

00:21:52,880 --> 00:21:56,900
Yes. Yes. You COULD do this, but you SHOULDN'T do this.

00:21:58,040 --> 00:22:03,080
What you really should do — the built-in syntax for it —

00:22:03,100 --> 00:22:08,840
is, you put an ampersand `&` in front of the name of the thing you're capturing,

00:22:08,840 --> 00:22:17,820
and that magically — well, okay, it's not magic, but it's a special case — where the compiler will say, "Oh, okay, now you want a reference to it."

00:22:17,820 --> 00:22:20,880
"Okay, I'll give you a reference."

00:22:21,360 --> 00:22:28,120
[AUDIENCE] Hopefully, this is a [fine?] question, uh, I don't know what is the `std::ref` type?

00:22:28,240 --> 00:22:35,720
What is `std::ref`? `std::ref` is a function that gives you back a `std::reference_wrapper`.

00:22:35,720 --> 00:22:41,700
[AUDIENCE] So is that syntax in C++14 then therefore using `auto`, so that it knows it's a reference type?...

00:22:41,700 --> 00:22:46,040
[AUDIENCE] ...I thought `auto` drops reference types.

00:22:46,460 --> 00:22:57,140
Ah, a `reference_wrapper`... Yes, it is not an actual native reference. It's not an actual `T&` variable.

00:22:57,140 --> 00:23:03,920
A `reference_wrapper<T>` is an actual value type that you can copy, and assign, and whatnot.

00:23:03,920 --> 00:23:11,180
But it behaves like a reference. So that when you use it — it basically just has an implicit conversion to `T&`, I think.

00:23:12,500 --> 00:23:15,800
[INAUDIBLE FROM AUDIENCE]

00:23:15,800 --> 00:23:20,400
"There is an implied `auto` in front of the `p=`." Yes. Basically yes.

00:23:22,900 --> 00:23:32,400
However, if you think of it that way, then you'll start thinking, oh, well I should be able to put `&&p=prop`, and that should capture an rvalue reference

00:23:32,420 --> 00:23:34,440
No! That DOESN'T work!

00:23:34,440 --> 00:23:37,700
"I should be able to put `*p = prop`, and that should capture an auto pointer."

00:23:37,700 --> 00:23:39,740
No! THAT doesn't work!

00:23:39,740 --> 00:23:42,840
It's a very special syntax.

00:23:42,840 --> 00:23:49,280
If you don't put anything it captures by value; if you do put a single ampersand it captures by reference; and that's it.

00:23:49,280 --> 00:23:51,620
Those are the two kinds of things.

00:23:51,620 --> 00:24:03,440
And similarly... We saw that you can capture everything by value by putting the `=`. You can also capture everything by reference by putting just the `&`.

00:24:03,440 --> 00:24:08,560
And that means, "Anything that I use in my inner scope that I haven't defined in my inner scope..."

00:24:08,560 --> 00:24:13,620
"...go look for it in the outer scope, and if you find it there, capture it by reference."

00:24:14,900 --> 00:24:25,580
And I also skipped over the slide where in C++11 you can capture named local variables, with the same name, inside, by reference as well as by value.

00:24:27,000 --> 00:24:33,360
But beware of dangling references! Right! If you capture everything by reference,

00:24:33,360 --> 00:24:35,720
and then you get rid of the referred-to stuff,

00:24:35,720 --> 00:24:38,680
then you have dangling references, dangling pointers.

00:24:38,720 --> 00:24:44,260
Which we all know from this morning's keynote are terrible.

00:24:44,260 --> 00:24:46,600
So be very careful when you do this.

00:24:46,600 --> 00:24:52,280
Yeah, the dangling pointer problem is solved [by shared_ptr]. Yes. So don't worry about it! [LAUGHTER]

00:24:54,380 --> 00:24:59,540
Basically capturing everything by reference is really really great and convenient

00:24:59,540 --> 00:25:06,720
for lambdas that you know are only going to go "down" your call chain and never escape upward into your caller.

00:25:06,720 --> 00:25:12,080
Then capturing everything by reference is just the simplest thing to do.

00:25:12,080 --> 00:25:20,140
And if you're not doing that, you probably shouldn't be using a capture-default at all. You should just spell out explicitly "I want to capture this and this and this."

00:25:20,580 --> 00:25:24,020
By the way! If you literally capture `this` —

00:25:24,020 --> 00:25:29,300
let's say, by copy — What are you capturing?

00:25:29,300 --> 00:25:36,860
Capturing a pointer by copy. Yeah, so it will look as if you're capturing it by reference, basically.

00:25:36,860 --> 00:25:42,060
And it will do this even if you're not writing `this` in your code...

00:25:42,060 --> 00:25:51,880
But you just say "I want to capture everything by copy" and then I refer to a member variable — `mymember` or whatever —

00:25:51,880 --> 00:25:57,040
The compiler will say, "How do I get `mymember`? Well, that's really `this->mymember`, so I'll capture `this` by copy."

00:25:57,040 --> 00:26:03,440
And you'll think you're getting a copy of `mymember`, but in fact you're not — you're getting a copy of the `this` pointer.

00:26:03,440 --> 00:26:05,420
I wish I had a slide on that.

00:26:06,460 --> 00:26:10,040
Okay, so just to sum up default capture modes...

00:26:10,040 --> 00:26:15,640
Here I have a couple of factories called `increment_by`.

00:26:15,640 --> 00:26:21,760
You pass in one integer — this is basically a factory for our `Plus` lambda, right?

00:26:21,760 --> 00:26:25,540
You pass in the number you want to add to things...

00:26:25,540 --> 00:26:31,300
So for example I can call `increment_by(5)`. That gives me back a lambda, which I'm naming `plus5`.

00:26:31,300 --> 00:26:36,000
And then if I call `plus5` on 2, I get 7.

00:26:36,000 --> 00:26:41,360
The `GOOD_increment_by` captures the `y` by copy, and it all works great.

00:26:41,360 --> 00:26:45,040
`BAD_increment_by` captures that `y` by reference,

00:26:45,040 --> 00:26:52,240
so that the lambda that I'm returning back out of my scope has a reference to a local parameter (local variable).

00:26:52,560 --> 00:26:56,840
Returning a reference to a local variable obviously doesn't work.

00:26:57,460 --> 00:27:00,840
All right, another couple of grab-bag features of lambdas.

00:27:00,840 --> 00:27:07,960
They are convertible to raw function pointers as long as you don't capture anything. That's super useful.

00:27:08,820 --> 00:27:15,540
If you DO capture something, then of course you can't. Because you can't turn an arbitrary— going back to our original capital-P `Plus` object,

00:27:15,540 --> 00:27:21,960
I can't turn a capital-P `Plus` object into a function pointer, because, where do I put the data?

00:27:22,440 --> 00:27:25,980
But, if I don't have any captures,

00:27:25,980 --> 00:27:32,160
then my `Plus` object is basically just a handle to its `operator()`,

00:27:32,160 --> 00:27:37,520
which takes a `this` pointer, but it doesn't DO anything with it because the `this` doesn't control any data.

00:27:37,520 --> 00:27:41,520
So really it's just a pure behavior. It's just a pure function.

00:27:41,520 --> 00:27:45,900
And so in that case the language actually allows us to convert it to a function pointer.

00:27:47,500 --> 00:27:51,580
Variables with global scope are not captured.

00:27:51,580 --> 00:27:56,040
There's a puzzle about this later. This is the spoiler.

00:27:56,040 --> 00:28:00,320
And lambdas may have local state — but not in the way you think.

00:28:00,480 --> 00:28:05,820
Here's a puzzle. Puzzle number two.

00:28:05,820 --> 00:28:10,860
What have we got here? We've got a global variable `g` which I initialize to 10.

00:28:10,860 --> 00:28:15,620
And then inside `main`, I'm going to set `g` to 20.

00:28:15,620 --> 00:28:22,300
And then I'm going to call my two lambdas here, which, in the traditional style, I'm naming after cats.

00:28:22,300 --> 00:28:31,300
We have `kitten`, that captures EVERYTHING by value; and we have `cat`, which captures only `g` by value.

00:28:31,300 --> 00:28:33,940
What do we think this is going to print?

00:28:39,460 --> 00:28:42,160
I heard "11, 11"; I heard "1, 11."

00:28:43,260 --> 00:28:45,260
I heard "21, 11."

00:28:46,880 --> 00:28:53,580
I also heard "21, 21." Is that all the combinations? I think we've completed the square.

00:28:57,340 --> 00:29:01,640
The answer is "21, 11." Here I've color-coded what's going on.

00:29:01,640 --> 00:29:05,720
So, if you can read my mind with the color coding...

00:29:05,720 --> 00:29:11,640
So the global `g`, which is purple here... Globals are not captured!

00:29:11,640 --> 00:29:16,440
Right? Because why would you need to capture a global? It's global! Everyone can see it!

00:29:16,440 --> 00:29:18,020
[AUDIENCE] Because you told it to!

00:29:18,020 --> 00:29:19,720
"Because he told it to."

00:29:19,720 --> 00:29:27,880
Well, no, I just told it, "By default, if there's something in my scope that you don't see inside, just assume that it's in the outer scope."

00:29:27,880 --> 00:29:33,120
But `g` — of course I know what `g` is. `g` is the global variable `g`.

00:29:33,120 --> 00:29:40,580
So `kitten` doesn't need to capture anything. It uses `g` but doesn't need to capture it. It's global. It knows `g`'s address.

00:29:40,580 --> 00:29:43,940
Its address is never going to change.

00:29:43,940 --> 00:29:48,900
So `kitten` is actually going to basically track updates to our `g` as we make them.

00:29:48,900 --> 00:29:55,440
So that's why it gives us "21." By the time it actually tries to use `g`, `g` has already changed to 20.

00:29:55,440 --> 00:30:04,420
Now, `cat`, on the other hand — we explicitly told it, "I want you to have a non-static data member..."

00:30:04,420 --> 00:30:11,200
"...in this `$_1` class — I want it to have a non-static data member whose name is `g`..."

00:30:11,200 --> 00:30:15,780
"...and I want its initial value to be the result of the expression `g`."

00:30:15,780 --> 00:30:20,460
The result of the expression `g` is 10, right now, when I create `cat`.

00:30:20,460 --> 00:30:27,300
So it gets a local `g`, controlled by the `cat` object, with value 10;

00:30:27,300 --> 00:30:29,620
and 10 plus 1 is 11.

00:30:29,620 --> 00:30:38,440
[INAUDIBLE FROM AUDIENCE]

00:30:38,440 --> 00:30:48,420
Yep. C++11 either doesn't have this problem or has it worse, depending on which compiler you use.

00:30:48,420 --> 00:30:57,140
In C++11, if I use the the format where I don't have the `=` sign and I just say, please capture `g`,

00:30:57,140 --> 00:31:01,280
that is a constraint violation and should be diagnosed.

00:31:01,280 --> 00:31:04,980
As of this writing, Clang diagnoses it with an error;

00:31:04,980 --> 00:31:10,700
GCC diagnoses it with a warning and keeps going!

00:31:10,700 --> 00:31:13,900
And... I do not remember what it does.

00:31:16,380 --> 00:31:25,820
So be aware that even if you name the global, if you use C++11 style, (A), that is a constraint violation and requires a diagnostic,

00:31:25,820 --> 00:31:28,720
and (B), you may not get a diagnostic.

00:31:29,600 --> 00:31:32,360
[INAUDIBLE FROM AUDIENCE]

00:31:32,800 --> 00:31:36,660
Is it the same thing if you capture by reference?

00:31:36,660 --> 00:31:42,600
Well in that case it definitely wouldn't matter, right? I mean if you're capturing it by reference then you'd know you're not getting a copy...

00:31:44,840 --> 00:31:49,460
So yes, it would still be a constraint violation,

00:31:49,460 --> 00:31:55,960
but I can't imagine anyone thinking that they were going to get any behavior different from what they got. So.

00:31:58,860 --> 00:32:03,400
All right. Time to revisit statics!

00:32:04,400 --> 00:32:06,400
Here I have a kitten factory.

00:32:07,360 --> 00:32:13,380
You pass it in a value that you would like to add...

00:32:13,380 --> 00:32:18,240
The actual behavior of this lambda, this is going to add up a bunch of stuff, right?

00:32:18,240 --> 00:32:25,760
Two of the things that it's going to add up are the value you pass to the factory (`c`) and value you pass to the constructed lambda (`d`).

00:32:25,760 --> 00:32:32,720
Also to that we're going to add the values of two statics, which we're going to be `++`ing every time you call the lambda:

00:32:32,720 --> 00:32:37,440
one that's static in the factory (`a`), and one that's static inside the lambda itself (`b`).

00:32:39,080 --> 00:32:44,420
And now we're going to make two kittens one with value 1, one with value 2, and we're going to call them...

00:32:44,420 --> 00:32:49,340
We're going to call the first one twice and then we're going to call the second one twice. And the question is, what does this print?

00:32:49,340 --> 00:32:54,740
And I don't even want to think about this, but if someone out there does, just shout out the answer and I'll tell you if you're right.

00:32:55,700 --> 00:32:57,760
Here's the answer. All right.

00:32:59,900 --> 00:33:02,140
So what's actually happening here?

00:33:03,880 --> 00:33:09,580
Well, we're making a `kitten` of `1`. So we're going to come in here,

00:33:09,580 --> 00:33:14,160
and the `a` inside `make_kitten` is going to start with value 0.

00:33:14,160 --> 00:33:20,880
And it's going to return a new closure constructed from this lambda-expression.

00:33:20,880 --> 00:33:28,920
So it's going to be an instance of a `$_0` class, for some value of `$_0`.

00:33:28,920 --> 00:33:35,520
And the `operator()` of this class is going to have the following behavior.

00:33:35,520 --> 00:33:42,500
It's going to have a copy of `c`. Because we're capturing everything by copy.

00:33:43,580 --> 00:33:49,860
We're going to increment the `a`, which is just global — like, there's just one of it, inside `make_kitten`, right?

00:33:49,860 --> 00:33:55,620
We're going to increment the `b`, which is static local inside this scope.

00:33:55,620 --> 00:33:58,040
And then we're going to add the `c` and the `d` to them.

00:34:01,500 --> 00:34:08,440
(This is already confusing me. Too many variables.)

00:34:08,440 --> 00:34:13,080
(Also, post-increment. Why did I choose post-increment?)

00:34:13,080 --> 00:34:18,640
But the gist of this is that of course there's only one static `a`, right?

00:34:18,640 --> 00:34:24,400
Because it is in the scope of `make_kitten`, and there's only one `make_kitten`.

00:34:24,400 --> 00:34:27,380
But how many `b`s are there? Do we have one `b` or two `b`s?

00:34:27,380 --> 00:34:41,080
The answer is, we have one `b`. Because `b` is static in the scope of this anonymous class's `operator()` function!

00:34:41,080 --> 00:34:44,620
That `operator()` function has a static local variable `b`.

00:34:44,620 --> 00:34:53,480
So it's going to look kind of like this. (Oh, this doesn't show up the way it showed up before. Just pretend this is all on one line.)

00:34:57,020 --> 00:34:59,400
So we have a single static `a`...

00:34:59,980 --> 00:35:02,740
...and we have a single static `b`...

00:35:02,980 --> 00:35:09,560
whose name-mangling indicates that it's the `b` that belongs to the `operator()` of class `$_0`.

00:35:10,020 --> 00:35:14,440
(Let me try to resize the font to make that name-mangled thing clearer.)

00:35:16,480 --> 00:35:22,780
We have our kittens `k1` and `k2`. They each captured a `c`.

00:35:22,800 --> 00:35:28,020
And they're statically — through the magic of static typing —

00:35:28,020 --> 00:35:35,040
they use this code which refers to the `a` inside `make_kitten` and the `b` inside the call operator.

00:35:35,040 --> 00:35:41,540
But there's only one `b`, and that's why they see each other's updates to `b`.

00:35:41,760 --> 00:35:54,220
Because there is only one call operator. Yes, the `$_0` class has a single call operator. Which has a static local `b` that it refers to.

00:35:54,220 --> 00:35:56,300
But only one of them.

00:35:56,300 --> 00:36:03,980
So, statics inside member functions, uh, behave the way that you might already know they behave.

00:36:03,980 --> 00:36:10,080
[AUDIENCE] Is it appropriate in this case to solve the conundrum by saying, this is created at compile time...

00:36:10,080 --> 00:36:17,140
[AUDIENCE] It's not gonna create a different "stamp," as you called it, just because you called it again a little bit later.

00:36:17,460 --> 00:36:18,540
[ARTHUR] Right.

00:36:18,540 --> 00:36:27,780
[AUDIENCE] So it's the same one because it was stamped once at compile time and its linkage — I mean those calls are static calls, they're not dynamic.

00:36:27,780 --> 00:36:34,660
[AUDIENCE] We figured that out in some detail previously. so there's just one of those methods... [INAUDIBLE]

00:36:35,100 --> 00:36:38,760
[ARTHUR] Yes. I mean, I would go with that.

00:36:38,760 --> 00:36:43,980
But I want to say that it's not super obvious that that's what should happen, because...

00:36:43,980 --> 00:36:55,300
This lambda-expression here — we do say very explicitly, "I want there to be a static int named `b` inside this scope."

00:36:55,300 --> 00:37:05,100
The committee COULD have decided to make it so that when you declare a static locally inside this lambda thing, that that really means that we get one PER closure.

00:37:05,100 --> 00:37:10,840
Like, each one gets their own. And it's initialized to 0. "Why didn't they do that?" you might ask...

00:37:10,840 --> 00:37:14,340
Because we already have a way to do that!

00:37:16,540 --> 00:37:22,320
So here's the situation we have now, right, where each of them gets their own `c`, because they captured it,

00:37:22,320 --> 00:37:27,180
but they share a reference to `b` because there's only one `b`.

00:37:27,180 --> 00:37:31,600
And then if one of them modifies `b`, the other one sees the update.

00:37:31,600 --> 00:37:36,100
And that that's not what we really wanted in this case. Let's suppose that's not what we want in this case.

00:37:36,100 --> 00:37:47,040
What we wanted — what we thought we were getting and it turned out we weren't — is that we thought we were getting a `b` in each of these closure objects.

00:37:47,460 --> 00:37:50,160
So how do we actually achieve that?

00:37:50,160 --> 00:37:52,800
What is the syntax provided for that?

00:37:54,560 --> 00:38:01,740
Well, it should be pretty obvious that what we're doing with `b` here, putting one in each closure object,

00:38:01,740 --> 00:38:05,720
is exactly the same thing that we had done with `c`, right?

00:38:05,720 --> 00:38:11,780
So we should be able to use the same syntax that we used to get the `c`, to also get a `b`.

00:38:16,260 --> 00:38:24,160
So all we need to do is just capture something, and we'll name it `b` — because why not? — and we'll initialize it to 0,

00:38:24,160 --> 00:38:31,820
and because we're going to modify it, we'll have to add the `mutable` keyword, to make sure our lambda can modify its captures.

00:38:31,820 --> 00:38:39,800
But there you go. If you want some extra state per closure object, you just...

00:38:40,840 --> 00:38:47,560
stick it in the capture-list, because the capture-list is where your member variables of this anonymous class go.

00:38:48,640 --> 00:38:52,800
[AUDIENCE] Could you also have declared it inside the braces but without the `static` keyword?

00:38:53,400 --> 00:38:57,360
Could you also have declared it inside the braces without the `static` keyword?

00:38:57,360 --> 00:39:00,420
Yes, but then it would be a stack variable. It wouldn't hold its state.

00:39:00,420 --> 00:39:09,460
[INAUDIBLE FOLLOWUP FROM AUDIENCE]

00:39:09,460 --> 00:39:15,740
This `b` is not on the stack! This — well, I mean, okay, it says "stack" right here, but —

00:39:16,340 --> 00:39:22,720
They're inside other things that can then be copied and put somewhere else, or passed as return values, or — passed up or down.

00:39:26,180 --> 00:39:30,340
But you can't do this with C++11 syntax as written.

00:39:30,340 --> 00:39:38,260
What you would have to do is create a local variable named `b`, initialize that to 0, and capture it by name. Yes, it's ugly.

00:39:38,260 --> 00:39:43,020
But that's why I love the generalized capture syntax!

00:39:43,020 --> 00:39:55,200
[INAUDIBLE FROM AUDIENCE]

00:39:55,200 --> 00:40:02,340
Could `b` be something other than an int? Sure. It could be, you know, it could be a `std::string`, it could be an arbitrarily complicated class.

00:40:02,340 --> 00:40:10,200
[INAUDIBLE]

00:40:10,200 --> 00:40:14,260
Do you need to say the type of `b`? No. In fact, you can't.

00:40:15,600 --> 00:40:21,420
The only thing you could do there is say `b=`... and then spell out the type.

00:40:21,420 --> 00:40:26,940
Like, I'd say, `[b = int(0)]` or `[b = std::string("hello world")]`.

00:40:26,960 --> 00:40:36,180
This is similar to... I know Herb Sutter has this idea of "Almost Always Auto," which is catching on to a certain degree,

00:40:36,180 --> 00:40:41,680
and this is one place where it is "Always Auto." You don't get a choice.

00:40:42,300 --> 00:40:46,820
There's no way to specify the type on the left-hand side of the `=` sign.

00:40:46,820 --> 00:40:52,060
If you want a specific type, you must either write an expression that gives you that type, or...

00:40:52,060 --> 00:40:57,000
...or write an expression that gives you that type. By means of a cast.

00:40:57,980 --> 00:41:00,840
Okay, so there we go. Per-lambda mutable state!

00:41:00,840 --> 00:41:04,340
So I just snuck this `mutable` keyword in here.

00:41:04,340 --> 00:41:11,140
If we're going to `++b`, we need to say `mutable`. What is that actually doing?

00:41:11,140 --> 00:41:16,480
Notice that `mutable` is not going on `b` itself, and there's no way to do that.

00:41:16,480 --> 00:41:22,300
It's going in the same position that you would expect to find...

00:41:22,300 --> 00:41:29,400
...the `const` qualifier in a member function. I say, `operator()() const`.

00:41:29,400 --> 00:41:35,900
And then in a lambda I say `[something]() mutable`.

00:41:35,900 --> 00:41:42,420
The reason for this is that lambdas, by default, their `operator()` is always const.

00:41:42,420 --> 00:41:48,380
It was decided that, generally speaking, you don't want to modify your captures.

00:41:48,380 --> 00:41:54,120
If you are modifying your captures, that's probably a bug. You would really like us to warn about that.

00:41:54,120 --> 00:42:01,500
So your `operator()` on your anonymous class, `$_0` or whatever, is always `const`...

00:42:01,500 --> 00:42:08,400
unless you say `mutable`, which makes it non-const.

00:42:10,000 --> 00:42:16,160
So everything has shifted one level down, "const-ward," from what you would expect.

00:42:16,160 --> 00:42:22,520
Saying `mutable` gives you an `operator()` on this anonymous class object which is not `const`...

00:42:22,520 --> 00:42:27,960
and therefore it CAN modify the captured member variables.

00:42:28,100 --> 00:42:31,540
[INAUDIBLE FROM AUDIENCE]

00:42:31,740 --> 00:42:35,680
"How come `a` wasn't captured by copy?"

00:42:36,900 --> 00:42:42,360
Right. And we said, "capture everything by copy,..."

00:42:42,360 --> 00:42:50,540
"...IF you can't already see it." Right? We had to capture `c` by copy because there's no `c` in the scope...

00:42:50,540 --> 00:42:54,280
but there is (again) only one `a`.

00:42:54,280 --> 00:43:02,580
Globals and statics in general are not captured by copy, because we already know their address.

00:43:02,600 --> 00:43:09,540
When you say `a`, we know you're talking about this `a`. We know we don't need a copy of it. It's right here. Its name is `a`.

00:43:10,080 --> 00:43:13,080
And so that's why it wasn't captured.

00:43:19,300 --> 00:43:25,780
All right, so, generic lambdas! Generic lambdas from scratch! That was the whole point of the talk, right? Okay.

00:43:26,040 --> 00:43:28,040
Let's go back to the beginning.

00:43:28,180 --> 00:43:31,920
Class member functions! Class member function templates!

00:43:31,920 --> 00:43:35,840
Let's go back to our `class Plus` with a `plusme` member function.

00:43:35,840 --> 00:43:43,160
Let's now make that a template. Now instead of taking `int x`, we're going to take `T x` for any type `T`.

00:43:43,160 --> 00:43:45,940
And we're going to return a `T`.

00:43:45,940 --> 00:43:53,120
Really I guess we should be returning `auto` and just let type deduction sort of figure out what the type is. Well, `T` plus `int` gives you `T`, right?

00:43:54,840 --> 00:43:58,260
Okay, so now we have a template, and we can instantiate this template.

00:43:58,260 --> 00:44:05,300
We can say — once I have a `Plus` object, like `Plus(1)`, I can say `plus.plusme(42)`...

00:44:05,300 --> 00:44:08,600
That will instantiate `plusme` with `T=int`...

00:44:08,600 --> 00:44:13,440
And we'll get something that name-mangles to something like this, and those integer operations.

00:44:13,440 --> 00:44:19,960
I can say `plus.plusme(3.14)`; type deduction will say "aha, `T` wants to be `double` here..."

00:44:19,960 --> 00:44:24,020
I will instantiate — stamp out an instantiation of — `plusme` for a `double`.

00:44:24,020 --> 00:44:27,400
And we'll get some `double` codegen.

00:44:27,960 --> 00:44:31,660
Okay, looks great, right? Good. Okay.

00:44:33,360 --> 00:44:36,660
Okay, what did we do next?

00:44:36,660 --> 00:44:42,300
Call operator! Boom. All right. Replace `plusme` with `operator()`.

00:44:42,300 --> 00:44:47,600
Now the name mangling has changed a little bit. We have `cl` there, where before we had `plusme`.

00:44:47,600 --> 00:44:50,100
The way we call it has changed a little bit.

00:44:51,060 --> 00:44:53,040
Okay...

00:44:53,040 --> 00:44:55,840
Now we make something kind of nifty...

00:44:57,400 --> 00:45:01,000
Here's the reducible complexity and the irreducible complexity.

00:45:01,000 --> 00:45:06,400
Irreducible in red. The reducible complexity in green.

00:45:07,900 --> 00:45:13,220
And we're going to say "Make me a `Plus` where the value is 1"...

00:45:13,220 --> 00:45:17,760
And then I can do the same thing I did before...

00:45:17,760 --> 00:45:21,940
Let's take all that boilerplate in the green and let's get rid of it

00:45:23,040 --> 00:45:25,960
It all goes away.

00:45:25,960 --> 00:45:28,160
And now I have the same thing I had before.

00:45:28,160 --> 00:45:32,940
Before, I had an instance of a `Plus` class where its `operator()` was a template.

00:45:32,940 --> 00:45:38,880
Now I have an instance of an ANONYMOUS class where its `operator()` is a template.

00:45:40,360 --> 00:45:43,500
This is C++14 at this point, yes.

00:45:44,620 --> 00:45:51,340
If you want it in C++11, you write this. [LAUGHTER]

00:45:51,880 --> 00:45:57,280
And I learned at lunch today that there are places in Boost that really expect something that behaves like this.

00:45:57,280 --> 00:46:03,720
And so C++14 is great, because now you can pass them nice simple lambdas instead of having to write your own templates.

00:46:05,740 --> 00:46:08,080
So here we go — all the same stuff as before.

00:46:08,080 --> 00:46:13,440
You say, I want every instance of this closure object to have a value...

00:46:13,440 --> 00:46:17,220
I will initialize it to — in this case — `1`.

00:46:17,220 --> 00:46:23,880
And I have an `operator()` that has one argument. I call it `x`. But what is its type?

00:46:23,880 --> 00:46:27,220
Its type is... `auto`.

00:46:27,220 --> 00:46:33,340
Which is the new magic catch-all keyword that we use, every time we don't know what other keyword to use.

00:46:33,340 --> 00:46:37,520
It's replaced `static` in that respect. [LAUGHTER]

00:46:37,520 --> 00:46:44,160
So you say `auto x`, and that means,

00:46:44,160 --> 00:46:46,880
"This is a template; figure it out."

00:46:47,640 --> 00:46:58,500
You could also say `auto *x`, or `auto &x`, and that would mean "This is a `T*`, this is a `T&`; figure it out."

00:46:58,760 --> 00:47:01,340
But in general we would write just `auto`,

00:47:01,340 --> 00:47:09,580
or we would write `auto&&`, which would turn into a `T&&`, which is a forwarding reference.

00:47:09,580 --> 00:47:12,640
for "perfect forwarding."

00:47:13,460 --> 00:47:16,260
All right, so. Generic lambdas.

00:47:17,100 --> 00:47:21,260
All right. Here we have another puzzle!

00:47:21,260 --> 00:47:26,700
I have a `kitten`. It's a generic lambda, so it takes `auto t`.

00:47:28,380 --> 00:47:34,140
And it has a static local named `x`, initialized to 0, and I return `(++x)` plus the value you give it.

00:47:34,140 --> 00:47:40,420
So `kitten(1)` is...? "2", right. `kitten(3.14)` is...?

00:47:40,760 --> 00:47:47,500
"4.14", right. For exactly the same reason as in puzzle number 1.

00:47:48,260 --> 00:47:51,540
(Did I forget to change that slide? I did. "Puzzle #1 redux.")

00:47:52,400 --> 00:47:57,060
Right. So now we're circling back to templates, if you didn't notice already.

00:47:59,040 --> 00:48:04,000
So yeah. We have ONE ENTITY here. Its name is `kitten`.

00:48:04,000 --> 00:48:14,080
It is no longer a template itself. It's not an overload set. `kitten is a real thing, of type `$_0`.

00:48:14,080 --> 00:48:17,620
It's an object. I can pass it around. We know its type.

00:48:17,620 --> 00:48:25,560
But because its `operator()` is a template, whenever we're using `operator()` we're actually instantiating a template,

00:48:25,560 --> 00:48:32,420
and every instantiation gets its own set of function-local statics, for example.

00:48:32,420 --> 00:48:35,020
So that's why we get this behavior.

00:48:35,480 --> 00:48:45,660
[AUDIENCE] Maybe you're going to answer this, but, can you specify, then, on the left call, which one you want, without just doing a cast on the parameter? Can it have angle-bracket syntax on it?

00:48:45,660 --> 00:48:50,120
"Can I use angle bracket syntax to say `kitten<int>` or `kitten<double>`?

00:48:50,120 --> 00:48:56,380
I believe not, but I am not sure. I don't actually know. [NOTE: No. You can say `kitten.operator()<int>(42)` but please don't.]

00:48:56,380 --> 00:49:00,140
And if you can't, it might be coming, I'm not sure?

00:49:00,880 --> 00:49:05,320
It seems reasonable... ish... but probably not.

00:49:05,320 --> 00:49:11,420
Because remember, `kitten` itself is not a template, right? So `kitten<int>` is definitely not a thing.

00:49:11,420 --> 00:49:14,680
[AUDIENCE] Maybe you could cast it.

00:49:14,680 --> 00:49:25,260
Right. I mean, I believe that I could say, like, I'm going to get the address of `kitten.operator()<int>`... I don't know.

00:49:25,260 --> 00:49:30,360
There's probably some syntax to make that work. But it's completely ugly, I'm sure.

00:49:30,360 --> 00:49:33,080
So, in general, no.

00:49:33,080 --> 00:49:41,580
[INAUDIBLE FROM AUDIENCE]

00:49:41,580 --> 00:49:44,840
"Can `auto` be used anywhere?" ...No.

00:49:44,840 --> 00:49:48,920
Like, can you have, like, a `vector<auto>`? ...No.

00:49:48,960 --> 00:49:54,960
You can say `vector<T>` and have it deduce the `T` for you,

00:49:54,960 --> 00:50:00,200
and you can say sort of similar things, like `auto*` and `auto&&`,

00:50:00,200 --> 00:50:03,400
But I don't think you can say `vector<auto>`.

00:50:03,400 --> 00:50:12,420
And I know there's been a proposal for C++17 to let you say that, but I don't know what happened to it — where it is.

00:50:14,140 --> 00:50:18,100
[INAUDIBLE] "vector of decltype..." meh. Whatever.

00:50:20,260 --> 00:50:21,440
All right, so, generic lambdas!

00:50:21,440 --> 00:50:31,040
Generic lambdas behave in this confusing way, just like templates, because they are templates! Templates under the hood.

00:50:31,040 --> 00:50:33,840
All right, uh, we have ten minutes left...

00:50:33,840 --> 00:50:36,920
I think we can get through all of the slides... and maybe not the bonus material,

00:50:36,920 --> 00:50:40,040
but, hey, that's why we have lightning talks, right?

00:50:40,040 --> 00:50:43,120
Let's do variadic function templates, just to prove that we can.

00:50:44,000 --> 00:50:47,000
Variadic templates, right? Yeah? Okay.

00:50:47,800 --> 00:50:53,140
We have a `class Plus`. It has an `int value`. It has a constructor. It has an `operator()`...

00:50:53,140 --> 00:50:57,760
Which is a template which takes an arbitrary number of parameters...

00:50:57,760 --> 00:51:03,340
...of types `P`, where `P` represents a parameter pack of types.

00:51:03,340 --> 00:51:07,120
And it's going to return the sum of all of those and also the `value`.

00:51:07,920 --> 00:51:11,180
So, let's see... right.

00:51:11,180 --> 00:51:20,560
So I can say `plus(42, 3.14, 1)`, and that should give me... [COUNTING] ...it should give me 47.14.

00:51:20,560 --> 00:51:29,280
Or I could say `plus("foobar", 2)` and that should give me...?

00:51:29,280 --> 00:51:32,700
"bar". Right.

00:51:32,700 --> 00:51:37,000
Because `char*`. All right.

00:51:37,000 --> 00:51:39,640
[SCATTERED LAUGHTER]

00:51:40,640 --> 00:51:43,760
All right, so we take the code that we wrote before...

00:51:43,760 --> 00:51:48,500
They have the reducible complexity in green; we have the irreducible complexity in red...

00:51:48,500 --> 00:51:54,360
We replace all the green with one pair of brackets each...

00:51:54,360 --> 00:52:01,520
And you'll notice that we took the `P`, which was a parameter pack — capital `P`, I mean — that disappeared.

00:52:01,520 --> 00:52:05,960
Instead we just say `auto`, and that means "I am a template. Figure it out."

00:52:05,960 --> 00:52:11,680
And `auto...` is a parameter pack of "I don't know. Figure it out."

00:52:13,100 --> 00:52:22,000
So here I have a generic variadic lambda, which takes any number of parameters,

00:52:22,000 --> 00:52:25,380
and it's going to take them by value, or by copy,

00:52:25,380 --> 00:52:29,940
because I said `auto...` and not `auto&&...`.

00:52:30,780 --> 00:52:35,060
And it's going to add them all up.

00:52:36,780 --> 00:52:44,540
Also, in C++11 syntax, I can capture a parameter pack. So— we talked about— so this is going to be confusing because I'm doing them right after each other, but—

00:52:44,740 --> 00:52:52,020
Here's how I make a variadic template lambda, where the argument list is a parameter pack.

00:52:52,720 --> 00:52:58,440
But, flip side of that, I might want the parameter pack in the other set of brackets, right?

00:52:58,440 --> 00:53:09,600
I might actually want a non-variadic lambda that captures a whole parameter pack that was passed to the creator of this lambda.

00:53:10,380 --> 00:53:17,000
I might actually want both. That's also fine. But in this example — this is going back to our `sort_by_properties`.

00:53:17,000 --> 00:53:23,680
So I have a vector of objects, and I want to sort them now not just by one property, but by a bunch of properties.

00:53:23,680 --> 00:53:28,020
Possibly empty, actually; but we're going to pretend that the empty case doesn't exist.

00:53:28,020 --> 00:53:33,000
and I'm just gonna pass in a whole bunch of strings. I'm going to say `sort_by_properties(v, key1, key2, key3)`.

00:53:34,280 --> 00:53:42,480
So there my typenames deduced by `P` are going to be, like, <std::string, std::string, std::string>.

00:53:42,480 --> 00:53:47,620
`props` is a parameter pack representing those three strings.

00:53:47,620 --> 00:53:54,020
And I can capture that whole pack, by copy, in my lambda `pless`,

00:53:54,020 --> 00:53:59,180
and then I can expand it back out again, when I need it, inside the lambda.

00:53:59,180 --> 00:54:03,720
And look at that. Lexicographic sorting, in like one line of code.

00:54:03,720 --> 00:54:06,200
So that's nice.

00:54:08,280 --> 00:54:10,980
Now, you might say... uh...

00:54:13,460 --> 00:54:15,620
Oh. We're gonna get to that in a moment.

00:54:15,620 --> 00:54:18,520
Slight digression: "Capturing by move."

00:54:18,520 --> 00:54:23,680
Here is our original example, where I'm capturing the string by copy,

00:54:23,680 --> 00:54:29,580
but copies do take a lot of memory, so maybe I just want to do a `std::move`.

00:54:29,580 --> 00:54:38,660
I can do that in the generalized capture, init-capture, syntax in C++14.

00:54:38,660 --> 00:54:42,780
Can I capture a whole parameter pack by move? Can I say this?

00:54:43,660 --> 00:54:45,300
Big ol' nope.

00:54:46,860 --> 00:54:50,340
Can you do `std::forward`? Big ol' nope.

00:54:50,340 --> 00:54:59,860
And there are good technical reasons for this. If you google it, there's a Google Groups post by — I think Richard Smith? Someone who knows —

00:55:00,240 --> 00:55:09,180
that explains, well, this is really tricky, because you can't have a non-static data member that is a parameter pack. That doesn't make sense.

00:55:12,200 --> 00:55:17,640
Yeah, so you can't do this yet, but maybe it's coming? someday? I wish? Because that would be nice.

00:55:17,640 --> 00:55:26,140
What you can do instead is, make a `tuple` out of your whole parameter pack... move things into the tuple... and then `std::move` the tuple into your lambda...

00:55:26,140 --> 00:55:31,240
...and then in your lambda you can unpack it. Which I didn't even write, because — like —

00:55:31,240 --> 00:55:35,720
because I don't think that that's possible in less than about ten lines of code and a helper function.

00:55:37,020 --> 00:55:40,520
So. Can't do that.

00:55:40,520 --> 00:55:44,760
And I don't think we're going to talk about `std::bind`. So you might as well ask your questions.

00:55:45,840 --> 00:55:47,440
In the back.

00:55:47,440 --> 00:55:51,980
[INAUDIBLE FROM AUDIENCE]

00:55:52,300 --> 00:55:59,000
"Can't you do that with `std::apply`, from the experimental extensions TS?"

00:56:00,100 --> 00:56:09,180
If I were only calling a function on the parameter pack, yes. But you'll notice that I wasn't just calling a function on it

00:56:09,180 --> 00:56:17,800
I was taking the parameter pack and doing `a[p]` for every `p` in the parameter pack, and `b[p]` for every `p` in the parameter pack.

00:56:17,840 --> 00:56:19,620
[INAUDIBLE]

00:56:20,180 --> 00:56:28,860
So, I could almost— I could use `std::apply` with this, actually. All I need to do is call the "std::square-bracket" functor.

00:56:28,860 --> 00:56:37,860
You know, like `std::less`, and `std::plus`... there's one of those for every operator. So all I need to do is call "std::index"...

00:56:37,860 --> 00:56:40,180
which doesn't exist.

00:56:40,180 --> 00:56:44,400
They just got around to adding `std::bit_not` in C++14.

00:56:44,400 --> 00:56:50,160
Eventually they will work their way through all of the operators. But they haven't gotten to square brackets yet

00:56:50,160 --> 00:56:54,140
[AUDIENCE] Sorry about the basic question. This is going way way back, but I didn't want to interrupt your flow.

00:56:54,140 --> 00:57:01,740
[AUDIENCE] When you do something like `a[p]`, where `p` is part of the captured `props`, what does that evaluate to?

00:57:01,740 --> 00:57:08,320
[AUDIENCE] In the earlier example, it was the string "hello". How do you know what `a["hello"]` would be?

00:57:10,500 --> 00:57:13,260
"How do I know what `a["hello"]` would be?"

00:57:13,260 --> 00:57:19,360
[AUDIENCE] So it's some address of an object `a`, and then you're taking the address of that and "hello"?

00:57:19,360 --> 00:57:23,940
Oh. `a` here is a reference to an `object`, which is a `std::map`.

00:57:23,940 --> 00:57:29,340
So it's using the map index operator to say "give me the value associated with the key 'hello'."

00:57:29,340 --> 00:57:32,040
[AUDIENCE] Oh, I see. Okay.

00:57:32,040 --> 00:57:40,080
And I heard someone ask, what is `std::tie`? `std::tie` is like `std::make_tuple`, but it takes references instead of making copies.

00:57:40,080 --> 00:57:46,340
So what `tie` is doing here — `std::tie`, but there wasn't room on the slide to write it —

00:57:46,360 --> 00:57:52,560
is basically expanding `a[x]` for all `x` in `props`...

00:57:52,560 --> 00:57:59,200
so that gives us `a["hello"], a["world"], a[`... for all of the `P`s that you passed in...

00:57:59,320 --> 00:58:02,280
...taking references to all of those, and wrapping them up in a tuple.

00:58:02,280 --> 00:58:11,320
On the right-hand side, we do the same thing for the `b`s. And then we use tuple's `operator<` to do a lexicographic comparison of those two tuples.

00:58:12,000 --> 00:58:18,400
I think we're probably out of time. ...Well, all right. One more.

00:58:18,400 --> 00:58:20,100
What's that?

00:58:21,500 --> 00:58:36,660
`std::experimental::apply` takes a function and a tuple, and calls that function on the elements of the tuple all together.

00:58:36,660 --> 00:58:43,380
So it takes the tuple that's captured the parameter pack, and allows you to use it as the parameter pack to any other function again.

00:58:43,380 --> 00:58:45,720
Sort of the inverse of `std::make_tuple`.

00:58:47,640 --> 00:58:48,840
Right. Thank you!

00:58:48,840 --> 00:58:52,940

YouTube URL: https://www.youtube.com/watch?v=WXeu4fj3zOs


