Title: CppCon 2015: Scott Wardle “Memory and C++ debugging at Electronic Arts”
Publication date: 2015-10-07
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Scott Wardle a senior software engineer Electronic Arts will talk about the current memory and C++ debugging setup and tools used in games. 

PS4 and Xbox One have virtual memory and 64 bit address spaces, GPU and CPU are getting closer in the ability to work virtual memory. So our tools are getting better and better and closer to PCs. Most of a games memory goes towards art and level data like bitmap textures and polygon meshes. So artist and designer need to understand how much their data takes up. Giving them call stacks of memory allocations does not help. They want to know how big is a group of building is. Why is this group of building bigger than this one? Maybe this one has some animation data or one of the textures is too big. But there are 10,000s of objects built by 100s of people all around the world.
— 
Hey Everyone, I am Scott Wardle, I have been in games over 20 years. Much of that in EA Canada Vancouver (though I started my career in EA Japan.). I like to solve hard problems. I love good data visualization and metric systems and using them to fix hard bugs. Also, I like to find good interfaces that use both tech and people together to flip throw hard problems such that they become easy and solve them selves.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:07,560
I'm gonna talk to you about memory and

00:00:03,470 --> 00:00:09,540
C++ debugging at Electronic Arts I'm

00:00:07,560 --> 00:00:14,580
gonna talk to you about it in a bunch of

00:00:09,540 --> 00:00:16,770
eras basically I'm gonna talk about you

00:00:14,580 --> 00:00:19,920
know what we used to do back when game

00:00:16,770 --> 00:00:23,340
programming was more like embedded

00:00:19,920 --> 00:00:25,980
programming back in 2000 on ps2 then

00:00:23,340 --> 00:00:28,050
I'll start talking about you know how

00:00:25,980 --> 00:00:29,849
things were back on 360 when we got

00:00:28,050 --> 00:00:36,809
virtual memory for the first time and

00:00:29,849 --> 00:00:41,640
est l came about finally I'm gonna talk

00:00:36,809 --> 00:00:44,789
about you know things now with ps4 and

00:00:41,640 --> 00:00:46,860
Xbox one and I'm gonna show you a sneak

00:00:44,789 --> 00:00:47,520
peek of what our current sort of

00:00:46,860 --> 00:00:51,809
state-of-the-art

00:00:47,520 --> 00:00:54,989
debugging tools this is me I've been in

00:00:51,809 --> 00:00:57,719
games forever I like to try and solve

00:00:54,989 --> 00:01:00,149
problems visually and draw pictures and

00:00:57,719 --> 00:01:05,119
do animations and stuff that probably

00:01:00,149 --> 00:01:07,260
got me into games and I'm badly dyslexic

00:01:05,119 --> 00:01:09,720
so if you see any spelling mistakes

00:01:07,260 --> 00:01:13,470
please let me know I won't have noticed

00:01:09,720 --> 00:01:19,950
them so on that note let's start with

00:01:13,470 --> 00:01:22,799
vocabulary one of my favorite topics in

00:01:19,950 --> 00:01:24,420
memory debugging systems and things I've

00:01:22,799 --> 00:01:26,430
always noticed that there seems to be a

00:01:24,420 --> 00:01:28,710
lot of different vocabularies around

00:01:26,430 --> 00:01:30,600
like heaps and arenas and alligators and

00:01:28,710 --> 00:01:34,200
pools and so this is the what I'm gonna

00:01:30,600 --> 00:01:39,030
use I'm gonna talk about alligators and

00:01:34,200 --> 00:01:41,400
they will be a class that can free or

00:01:39,030 --> 00:01:44,040
allocate memory usually it's a pure

00:01:41,400 --> 00:01:46,920
virtual interface and then I'm gonna

00:01:44,040 --> 00:01:49,259
talk about arenas and marinas are like a

00:01:46,920 --> 00:01:52,170
set of address ranges where you can find

00:01:49,259 --> 00:01:54,720
an alligator from it and so you can go

00:01:52,170 --> 00:01:57,450
back and forth from an alligator to

00:01:54,720 --> 00:01:59,070
finding what address ranges is in or you

00:01:57,450 --> 00:02:01,920
can take any particular pointer in

00:01:59,070 --> 00:02:03,689
memory and and find out what arena

00:02:01,920 --> 00:02:07,200
that's in and therefore you know what

00:02:03,689 --> 00:02:08,759
alligator it's from and heap sometimes

00:02:07,200 --> 00:02:13,210
I'll say quite a bit and that's kind of

00:02:08,759 --> 00:02:17,580
the combination of it to the two so

00:02:13,210 --> 00:02:20,230
back in 2000 you know we just started

00:02:17,580 --> 00:02:21,850
converting from C I mean most people

00:02:20,230 --> 00:02:25,360
turn on their c4 plus compilers by this

00:02:21,850 --> 00:02:29,890
point we didn't have any virtual memory

00:02:25,360 --> 00:02:32,640
there was no OS you know very similar to

00:02:29,890 --> 00:02:36,750
embedded programming systems and very

00:02:32,640 --> 00:02:40,840
simple system only 32 Meg's of RAM so

00:02:36,750 --> 00:02:42,460
what I started seeing about you know how

00:02:40,840 --> 00:02:44,980
to get debugging information into the

00:02:42,460 --> 00:02:48,520
game in how to debug all of the

00:02:44,980 --> 00:02:51,760
allocations was like techniques like

00:02:48,520 --> 00:02:55,210
this one where people would add news and

00:02:51,760 --> 00:02:56,770
deletes to all of their classes and you

00:02:55,210 --> 00:02:58,240
know this is actually a good idea for

00:02:56,770 --> 00:03:00,580
the performance sake I mean people use

00:02:58,240 --> 00:03:02,590
like fixed size pools and slabs of

00:03:00,580 --> 00:03:05,890
allocators where they they bump pointers

00:03:02,590 --> 00:03:08,080
and things like that but if you're

00:03:05,890 --> 00:03:11,320
trying to use this as a debug technique

00:03:08,080 --> 00:03:13,780
you know it falls down because you're

00:03:11,320 --> 00:03:15,340
having to you know if you don't do it

00:03:13,780 --> 00:03:17,740
this somewhere you won't really notice

00:03:15,340 --> 00:03:20,500
if you don't override your new and

00:03:17,740 --> 00:03:22,660
delete in a location then you just miss

00:03:20,500 --> 00:03:25,930
having the extra tracking information we

00:03:22,660 --> 00:03:28,090
still have code like this around in yay

00:03:25,930 --> 00:03:30,400
but it's something that I would suggest

00:03:28,090 --> 00:03:32,740
not to do but I understand why library

00:03:30,400 --> 00:03:35,980
teams do it because this is sometimes

00:03:32,740 --> 00:03:40,330
hard on a very large project you want to

00:03:35,980 --> 00:03:43,270
use global new and global delete but

00:03:40,330 --> 00:03:45,880
what interface do you use what kind of

00:03:43,270 --> 00:03:47,560
debugging parameters do you use in a

00:03:45,880 --> 00:03:48,970
very large company like EA it was

00:03:47,560 --> 00:03:51,790
actually kind of tricky to get the

00:03:48,970 --> 00:03:54,640
politics of this right eventually we

00:03:51,790 --> 00:03:56,620
settled on something like this where we

00:03:54,640 --> 00:03:58,120
had some flags which said whether we

00:03:56,620 --> 00:04:01,600
were in the top of RAM or the bottom of

00:03:58,120 --> 00:04:02,740
RAM and we had a debug name that would

00:04:01,600 --> 00:04:05,830
be associated with every single

00:04:02,740 --> 00:04:07,420
allocation to understand how we use that

00:04:05,830 --> 00:04:10,480
debug name you kind of have to

00:04:07,420 --> 00:04:13,750
understand what a heap looks like for us

00:04:10,480 --> 00:04:15,460
anyways and usually it's got a header

00:04:13,750 --> 00:04:19,480
you know unallocated block in a footer

00:04:15,460 --> 00:04:22,990
and this is pretty simple but we would

00:04:19,480 --> 00:04:24,910
store in the footer this debug name and

00:04:22,990 --> 00:04:26,949
we would put it there and be you know

00:04:24,910 --> 00:04:28,659
fresh for being corrupted

00:04:26,949 --> 00:04:30,939
because that's usually what the memory

00:04:28,659 --> 00:04:32,560
you would corrupt maybe not the best of

00:04:30,939 --> 00:04:34,210
places to put it

00:04:32,560 --> 00:04:37,270
and it would look like this it would be

00:04:34,210 --> 00:04:39,009
like category : : allocator so we would

00:04:37,270 --> 00:04:41,889
have things like you know rendering : :

00:04:39,009 --> 00:04:43,419
player or gameplay : : physic math sure

00:04:41,889 --> 00:04:45,849
those kind of things in we would sort

00:04:43,419 --> 00:04:50,759
there and this was pretty good tech we

00:04:45,849 --> 00:04:52,659
thought it was good you know it was

00:04:50,759 --> 00:04:54,039
simple back then because we didn't

00:04:52,659 --> 00:04:55,990
really have very many pools or anything

00:04:54,039 --> 00:05:00,550
because there wasn't that much RAM only

00:04:55,990 --> 00:05:03,219
tens of thousands of objects I guess we

00:05:00,550 --> 00:05:05,620
did have a small block allocator and

00:05:03,219 --> 00:05:08,610
this wasn't quite used everywhere but

00:05:05,620 --> 00:05:13,449
pretty close and we had to work really

00:05:08,610 --> 00:05:14,860
hard at fragmentation and we thought

00:05:13,449 --> 00:05:17,680
this was the height of technology at the

00:05:14,860 --> 00:05:20,050
time you would load compressed blocks in

00:05:17,680 --> 00:05:21,639
the bottom of RAM and then decompress

00:05:20,050 --> 00:05:22,990
them and put them in the top of RAM and

00:05:21,639 --> 00:05:24,939
that's what we would use those those

00:05:22,990 --> 00:05:27,479
flags for is for doing things like this

00:05:24,939 --> 00:05:30,099
and you ping-pong things back and forth

00:05:27,479 --> 00:05:31,479
to get rid of all of the fragmentation

00:05:30,099 --> 00:05:34,930
and this worked pretty well as long as

00:05:31,479 --> 00:05:40,900
you only had one CPU once of course we

00:05:34,930 --> 00:05:43,990
went to xbox360 and ps3 our world had to

00:05:40,900 --> 00:05:45,219
change though we had virtual memory now

00:05:43,990 --> 00:05:47,319
though and this was a real good

00:05:45,219 --> 00:05:49,029
advantage you didn't have a hard drive

00:05:47,319 --> 00:05:51,669
though so we couldn't really use it the

00:05:49,029 --> 00:05:53,860
same way everybody else could and the

00:05:51,669 --> 00:05:55,659
GPUs couldn't support it and that's

00:05:53,860 --> 00:05:57,759
where a lot of our memory actually went

00:05:55,659 --> 00:06:00,400
so it wasn't perfect but it was

00:05:57,759 --> 00:06:05,379
definitely an improvement having all

00:06:00,400 --> 00:06:07,870
those CPUs meant that we wanted to have

00:06:05,379 --> 00:06:09,909
more allocation systems and divide

00:06:07,870 --> 00:06:11,710
memory up a little bit more so we didn't

00:06:09,909 --> 00:06:14,409
have contention on it and and

00:06:11,710 --> 00:06:20,500
fragmentation will become sort of a

00:06:14,409 --> 00:06:24,580
higher-level problem we needed better

00:06:20,500 --> 00:06:25,900
tracking and logging systems and we

00:06:24,580 --> 00:06:29,589
invented something we call the stomp

00:06:25,900 --> 00:06:32,580
allocator and that was a huge advance in

00:06:29,589 --> 00:06:37,810
how we debugged memory corruption

00:06:32,580 --> 00:06:39,430
finally STL came into existence and this

00:06:37,810 --> 00:06:40,390
really algorithmically changed the way

00:06:39,430 --> 00:06:45,550
we work

00:06:40,390 --> 00:06:47,670
and that was really powerful but how did

00:06:45,550 --> 00:06:50,560
we deal with having multiple alligators

00:06:47,670 --> 00:06:53,080
for the most part it's pretty simple I

00:06:50,560 --> 00:06:55,930
mean you just pass an extra parameter to

00:06:53,080 --> 00:06:58,570
your new operator and it can kind of

00:06:55,930 --> 00:07:01,870
work and that's what we did

00:06:58,570 --> 00:07:03,550
delete however is a pain and so

00:07:01,870 --> 00:07:06,340
therefore we had to wrap it in a macro

00:07:03,550 --> 00:07:08,260
and a crazy amount of technology to pass

00:07:06,340 --> 00:07:11,560
in an extra parameter in order to call

00:07:08,260 --> 00:07:13,300
the appropriate destructor we still use

00:07:11,560 --> 00:07:15,790
that code today and occasionally we

00:07:13,300 --> 00:07:17,410
think mm why don't we have it so we can

00:07:15,790 --> 00:07:22,930
pass in and you know an extra parameter

00:07:17,410 --> 00:07:25,840
delete might be nice we also had to

00:07:22,930 --> 00:07:29,620
think about you know how are we going to

00:07:25,840 --> 00:07:31,660
divide up memory you know how do we

00:07:29,620 --> 00:07:34,420
decrease fragmentation if we can't sort

00:07:31,660 --> 00:07:36,430
of ping pong back and forth as much so

00:07:34,420 --> 00:07:38,950
what we did was we kind of divided it

00:07:36,430 --> 00:07:43,120
based on time is sort of the most

00:07:38,950 --> 00:07:45,220
important and size and by time I mean

00:07:43,120 --> 00:07:47,080
like static allocations they allocate

00:07:45,220 --> 00:07:49,420
once and they never get freed global

00:07:47,080 --> 00:07:51,640
allocations they you know have a

00:07:49,420 --> 00:07:53,080
lifetime longer than a level anyways and

00:07:51,640 --> 00:07:54,970
so they're passing information between

00:07:53,080 --> 00:07:55,860
levels like your front end system or

00:07:54,970 --> 00:07:59,560
something like that

00:07:55,860 --> 00:08:02,350
and you'd have sub level information

00:07:59,560 --> 00:08:04,840
that you know maybe a cutscene that

00:08:02,350 --> 00:08:06,880
happens during a level and the level

00:08:04,840 --> 00:08:08,110
pool could just disappear after a level

00:08:06,880 --> 00:08:10,350
was done and so you can figure out that

00:08:08,110 --> 00:08:12,370
your whole system was in a steady state

00:08:10,350 --> 00:08:13,960
you'd also have various types of

00:08:12,370 --> 00:08:16,450
temporary allocations for things like

00:08:13,960 --> 00:08:19,930
okay bullets are flying around you know

00:08:16,450 --> 00:08:26,680
they only last for a few frames we'd

00:08:19,930 --> 00:08:27,850
also do things by size to where you you

00:08:26,680 --> 00:08:29,230
know just like your cupboards or

00:08:27,850 --> 00:08:30,970
something like that you take all your

00:08:29,230 --> 00:08:32,800
big pots and pans and you put them into

00:08:30,970 --> 00:08:34,300
one location and you take all of your

00:08:32,800 --> 00:08:37,090
smaller ones and put them somewhere else

00:08:34,300 --> 00:08:38,590
we had the small block allocator like I

00:08:37,090 --> 00:08:41,110
was talking about and that's actually a

00:08:38,590 --> 00:08:42,910
completely a custom system but we

00:08:41,110 --> 00:08:45,130
actually would even just use general

00:08:42,910 --> 00:08:47,530
allocators and put different size things

00:08:45,130 --> 00:08:51,670
in different directions and this

00:08:47,530 --> 00:08:53,779
actually reduced fragmentation one thing

00:08:51,670 --> 00:08:55,999
that it's sort of dependent on this

00:08:53,779 --> 00:08:57,920
of team that we had whether we did this

00:08:55,999 --> 00:09:00,199
or not but we'd also break it up kind of

00:08:57,920 --> 00:09:03,170
on the boundaries the political

00:09:00,199 --> 00:09:05,389
boundaries if you will of the team and

00:09:03,170 --> 00:09:08,449
you would then have like generic heaps

00:09:05,389 --> 00:09:11,300
and small block allocator heaps for for

00:09:08,449 --> 00:09:13,490
each team this is actually a performance

00:09:11,300 --> 00:09:15,680
disadvantage really and smaller teams

00:09:13,490 --> 00:09:18,920
wouldn't want it but but big teams did

00:09:15,680 --> 00:09:23,240
because you know it was very easy to set

00:09:18,920 --> 00:09:24,620
blame for things you know if you run a

00:09:23,240 --> 00:09:27,850
smaller team you'd probably do something

00:09:24,620 --> 00:09:31,610
like this and just tag the allocations

00:09:27,850 --> 00:09:33,319
based on categories and you can see that

00:09:31,610 --> 00:09:35,180
there's you know you can just count up

00:09:33,319 --> 00:09:37,939
the orange blocks and count up the red

00:09:35,180 --> 00:09:42,050
blocks and you could see how much memory

00:09:37,939 --> 00:09:44,180
was was being taken up and set budgets

00:09:42,050 --> 00:09:46,850
based on that and and that's a really

00:09:44,180 --> 00:09:49,449
good thing to do but you know you're

00:09:46,850 --> 00:09:52,279
gonna have things like fragmentation and

00:09:49,449 --> 00:09:56,569
fragmentation you know it's hard like

00:09:52,279 --> 00:09:59,029
who's at fault who did it and when you

00:09:56,569 --> 00:10:01,970
have things like memory corruption

00:09:59,029 --> 00:10:03,740
between teams it's quite interesting to

00:10:01,970 --> 00:10:05,569
you know your shadows are suddenly being

00:10:03,740 --> 00:10:06,980
corrupted of course you're gonna blame

00:10:05,569 --> 00:10:08,629
the rendering team they wrote the shadow

00:10:06,980 --> 00:10:10,129
system it must be their fault but

00:10:08,629 --> 00:10:12,079
they're gonna be pretty upset at you

00:10:10,129 --> 00:10:13,279
when you told them to fix their bugs and

00:10:12,079 --> 00:10:15,920
then they figure out that it's actually

00:10:13,279 --> 00:10:18,410
you know people writing the sim code and

00:10:15,920 --> 00:10:22,629
they went in and corrupted one of their

00:10:18,410 --> 00:10:27,170
buffers and so that's really too bad

00:10:22,629 --> 00:10:29,120
along the same line we started to notice

00:10:27,170 --> 00:10:31,129
that it was important to keep our

00:10:29,120 --> 00:10:33,459
debugging information safe from the rest

00:10:31,129 --> 00:10:37,279
of our system there were some really

00:10:33,459 --> 00:10:39,709
important information there and we could

00:10:37,279 --> 00:10:42,589
use it to determine what was actually

00:10:39,709 --> 00:10:44,660
going on around the corruption you could

00:10:42,589 --> 00:10:47,240
you know memory effectively looked like

00:10:44,660 --> 00:10:49,999
this and you had you know the

00:10:47,240 --> 00:10:52,670
traditional header allocated block

00:10:49,999 --> 00:10:55,519
footer normal heap there and you would

00:10:52,670 --> 00:10:59,660
have a separate heap that was a debug

00:10:55,519 --> 00:11:01,579
heap that you would track by address and

00:10:59,660 --> 00:11:04,129
that address would be a hash key so it

00:11:01,579 --> 00:11:07,550
was kind of like a hash table that would

00:11:04,129 --> 00:11:11,660
be implemented and he would use that

00:11:07,550 --> 00:11:15,830
hache in order to figure out how to free

00:11:11,660 --> 00:11:17,390
it so it wasn't completely free what we

00:11:15,830 --> 00:11:19,519
were able to do there but this this

00:11:17,390 --> 00:11:21,380
concept of tracking all of our live

00:11:19,519 --> 00:11:25,190
allocations somewhere else

00:11:21,380 --> 00:11:29,060
safe meant that when you saw corruption

00:11:25,190 --> 00:11:32,360
in a rendering block or something like

00:11:29,060 --> 00:11:35,180
that you could take it dump it out after

00:11:32,360 --> 00:11:37,910
you crashed look at the previous block

00:11:35,180 --> 00:11:40,220
and find out oh it's a gameplay block

00:11:37,910 --> 00:11:41,750
and it's this size and you'd know a

00:11:40,220 --> 00:11:45,110
bunch of properties about it and then

00:11:41,750 --> 00:11:47,120
you could write code to test for bugs

00:11:45,110 --> 00:11:49,459
and things based on it and that was

00:11:47,120 --> 00:11:51,019
really good you'll notice there was of

00:11:49,459 --> 00:11:53,589
something else going on here there's

00:11:51,019 --> 00:11:58,100
this whole memory logging system as well

00:11:53,589 --> 00:11:59,839
we would take maybe we wouldn't be able

00:11:58,100 --> 00:12:02,930
to run the whole game this way but but

00:11:59,839 --> 00:12:04,880
sections of the game anyways maybe one

00:12:02,930 --> 00:12:07,279
pool at a time or one teams worth of

00:12:04,880 --> 00:12:09,860
memory at a time and streaming up to

00:12:07,279 --> 00:12:11,360
disk change by change every single

00:12:09,860 --> 00:12:13,339
transaction we did with the memory

00:12:11,360 --> 00:12:16,370
system and write it out so we'd know

00:12:13,339 --> 00:12:18,500
where every ellic and free was and we

00:12:16,370 --> 00:12:22,070
would do this so that we could write a

00:12:18,500 --> 00:12:25,040
tool like this one where you can see the

00:12:22,070 --> 00:12:27,079
you know the start of time to end of

00:12:25,040 --> 00:12:31,100
time and you can see that memory is

00:12:27,079 --> 00:12:35,089
slowly going up here right this is our

00:12:31,100 --> 00:12:37,490
game going through boot flow as we go

00:12:35,089 --> 00:12:40,130
through a bunch of changes and we'd load

00:12:37,490 --> 00:12:44,899
various files you can sort of see what's

00:12:40,130 --> 00:12:46,520
going on you can here you could pick any

00:12:44,899 --> 00:12:48,800
particular point in time and you could

00:12:46,520 --> 00:12:51,170
see a snapshot of what was going on and

00:12:48,800 --> 00:12:52,430
see it down in the spreadsheet below but

00:12:51,170 --> 00:12:55,250
the other thing you could do is you

00:12:52,430 --> 00:12:58,600
could select regions and you could see

00:12:55,250 --> 00:13:01,250
the Delta changes that happened there

00:12:58,600 --> 00:13:03,649
besides just seeing a whole snapshot and

00:13:01,250 --> 00:13:06,260
you would have you know information like

00:13:03,649 --> 00:13:08,690
you would expect to be able to debug the

00:13:06,260 --> 00:13:11,480
system you would have you know the heap

00:13:08,690 --> 00:13:14,480
it was from the category it was in

00:13:11,480 --> 00:13:17,630
allocation names the number of count of

00:13:14,480 --> 00:13:20,180
items and allocation sizes you could

00:13:17,630 --> 00:13:24,740
also get a call stack as well

00:13:20,180 --> 00:13:28,310
but that isn't in this diagram you could

00:13:24,740 --> 00:13:29,839
also see like a block of diagram of it

00:13:28,310 --> 00:13:31,399
and you could see the thing I was

00:13:29,839 --> 00:13:33,800
talking about before with with

00:13:31,399 --> 00:13:35,839
categories you could see that the the

00:13:33,800 --> 00:13:38,410
systems guys are all allocated over

00:13:35,839 --> 00:13:41,779
there and the presentation information

00:13:38,410 --> 00:13:43,279
is down in purple there you can see that

00:13:41,779 --> 00:13:45,410
we have some fragmentation in this heat

00:13:43,279 --> 00:13:47,300
because gray is free and you can see

00:13:45,410 --> 00:13:50,630
there's more than one section of grey

00:13:47,300 --> 00:13:53,870
and you could highlight blocks and find

00:13:50,630 --> 00:13:55,490
out you know it tributes about it you

00:13:53,870 --> 00:13:57,860
know what the size of this block was

00:13:55,490 --> 00:14:00,110
where it was in memory and you could see

00:13:57,860 --> 00:14:01,399
things that were going on around it and

00:14:00,110 --> 00:14:02,959
if you add memory corruption or

00:14:01,399 --> 00:14:04,910
something like that this this was very

00:14:02,959 --> 00:14:08,510
useful to to sort of reason about what

00:14:04,910 --> 00:14:11,000
was going on the other thing that we

00:14:08,510 --> 00:14:13,820
added was something called stomp

00:14:11,000 --> 00:14:16,490
allocator of course we're working on

00:14:13,820 --> 00:14:18,860
consoles so we can't use the same teams

00:14:16,490 --> 00:14:20,720
the same tools that everybody else would

00:14:18,860 --> 00:14:23,510
like Val Val grind and things like this

00:14:20,720 --> 00:14:26,480
so we end up invite in inventing some of

00:14:23,510 --> 00:14:31,010
our own I think this one is similar to

00:14:26,480 --> 00:14:33,830
electric fence where we would use the

00:14:31,010 --> 00:14:36,380
virtual memory system to allocate a

00:14:33,830 --> 00:14:39,020
readwrite page and then a read-only page

00:14:36,380 --> 00:14:41,630
right afterwards and we would stuff our

00:14:39,020 --> 00:14:44,570
allocation right at the bottom and if we

00:14:41,630 --> 00:14:46,630
you know had an array inside there and

00:14:44,570 --> 00:14:49,580
you walked off you would immediately

00:14:46,630 --> 00:14:52,310
crash and stop and you would get a call

00:14:49,580 --> 00:14:54,800
stack you would know exactly where your

00:14:52,310 --> 00:14:57,080
bug was and we could find tons of memory

00:14:54,800 --> 00:15:01,100
corruption with this this tool now

00:14:57,080 --> 00:15:03,410
because we over allocate using the

00:15:01,100 --> 00:15:06,230
system we couldn't use it everywhere I

00:15:03,410 --> 00:15:08,120
mean we have no memory left I mean when

00:15:06,230 --> 00:15:10,220
you're working on an Xbox 360 especially

00:15:08,120 --> 00:15:11,930
near the end of its life cycle we were

00:15:10,220 --> 00:15:13,550
scraping back memory by you know

00:15:11,930 --> 00:15:16,970
reducing code space and all sorts of

00:15:13,550 --> 00:15:19,510
craziness so how we use these tools is

00:15:16,970 --> 00:15:21,920
we would have all the attributes of

00:15:19,510 --> 00:15:24,860
allocations and we would only apply them

00:15:21,920 --> 00:15:26,149
to a small set at a time so as we saw a

00:15:24,860 --> 00:15:28,100
memory corruption happening in

00:15:26,149 --> 00:15:30,800
particular regions we could turn this on

00:15:28,100 --> 00:15:34,010
to you know all gameplay allocations

00:15:30,800 --> 00:15:38,390
that are between 256 bytes

00:15:34,010 --> 00:15:40,040
- you know maybe 300 bytes or something

00:15:38,390 --> 00:15:44,330
like that a very small range of memory

00:15:40,040 --> 00:15:47,420
and we could test it one other thing I

00:15:44,330 --> 00:15:50,990
learned around this time was the panes

00:15:47,420 --> 00:15:53,300
of ref pointers I first saw them and I

00:15:50,990 --> 00:15:56,300
was thought oh great I should use these

00:15:53,300 --> 00:15:57,590
everywhere and I started to and as

00:15:56,300 --> 00:15:59,690
quickly as I started to use them

00:15:57,590 --> 00:16:03,740
everywhere I ran into this problem and

00:15:59,690 --> 00:16:05,210
oh boy I started ripping them out as

00:16:03,740 --> 00:16:07,160
fast as I could and I never wanted to

00:16:05,210 --> 00:16:10,010
use them again but I've learned my

00:16:07,160 --> 00:16:11,950
lesson now really they are very useful

00:16:10,010 --> 00:16:14,870
especially in multi-threaded situations

00:16:11,950 --> 00:16:17,420
things like that I think I would start

00:16:14,870 --> 00:16:20,000
with unique pointer or bear pointers to

00:16:17,420 --> 00:16:22,340
start because I've got these great

00:16:20,000 --> 00:16:24,320
debugging systems to track all these

00:16:22,340 --> 00:16:26,060
allocations you know fighting memory

00:16:24,320 --> 00:16:29,480
leaks really isn't that hard for me

00:16:26,060 --> 00:16:31,880
what's hard is tracking down circular

00:16:29,480 --> 00:16:35,000
dependencies because I'm not really set

00:16:31,880 --> 00:16:36,440
up for it I might be able to solve this

00:16:35,000 --> 00:16:39,800
problem I think it's called garbage

00:16:36,440 --> 00:16:41,300
collection I'm pretty sure I would start

00:16:39,800 --> 00:16:45,850
from there because I think they've sold

00:16:41,300 --> 00:16:49,100
it solved it quite well I could

00:16:45,850 --> 00:16:52,130
implement a locking system to I mean I

00:16:49,100 --> 00:16:54,710
could log every single you know add ref

00:16:52,130 --> 00:16:58,700
and Dec ref in my entire system but

00:16:54,710 --> 00:17:00,230
that's gonna be a lot of memory way more

00:16:58,700 --> 00:17:02,150
than the number of blocks of memory I

00:17:00,230 --> 00:17:04,310
have because the number of blocks of

00:17:02,150 --> 00:17:06,860
memory I have so many more pointers and

00:17:04,310 --> 00:17:09,500
and how many times I use those pointers

00:17:06,860 --> 00:17:16,430
is how many times I might end up in

00:17:09,500 --> 00:17:20,050
crafting and decorating so the other

00:17:16,430 --> 00:17:24,650
thing that happened at this time was STL

00:17:20,050 --> 00:17:31,400
there's a lot of reasons why we decided

00:17:24,650 --> 00:17:32,960
to use STL and not use standard the

00:17:31,400 --> 00:17:36,770
standard library we ended up inventing

00:17:32,960 --> 00:17:40,340
your own STL but basically it came down

00:17:36,770 --> 00:17:44,150
to speed for our particular case this is

00:17:40,340 --> 00:17:45,950
on Visual Studio 2015 but it's kind of

00:17:44,150 --> 00:17:46,980
been the same for quite a while I tried

00:17:45,950 --> 00:17:49,230
it on

00:17:46,980 --> 00:17:53,310
2012 as well and the results are a

00:17:49,230 --> 00:17:54,810
little similar this is a bunch of tests

00:17:53,310 --> 00:17:56,550
this is a benchmark and so I don't know

00:17:54,810 --> 00:18:01,250
maybe the benchmark isn't that good but

00:17:56,550 --> 00:18:05,640
out of the 188 tests that that I had 71

00:18:01,250 --> 00:18:06,810
cases we are 30% faster there's 10 which

00:18:05,640 --> 00:18:10,380
we were slower and we know what they are

00:18:06,810 --> 00:18:12,330
we you know they're not cases that we

00:18:10,380 --> 00:18:15,600
normally use or we want it to go for

00:18:12,330 --> 00:18:18,600
memory or something instead with the the

00:18:15,600 --> 00:18:23,190
debug case it's really interesting

00:18:18,600 --> 00:18:24,570
actually we're way faster we're way

00:18:23,190 --> 00:18:26,820
faster because we've cut and paste more

00:18:24,570 --> 00:18:28,320
code the inliner doesn't really work

00:18:26,820 --> 00:18:29,670
when you have functions that call it or

00:18:28,320 --> 00:18:31,950
functions that call it or functions and

00:18:29,670 --> 00:18:33,260
so it isn't really that good so we just

00:18:31,950 --> 00:18:35,550
kind of flatten the whole thing

00:18:33,260 --> 00:18:36,660
hopefully we got it right and didn't

00:18:35,550 --> 00:18:39,060
write that many bugs because I'm

00:18:36,660 --> 00:18:44,820
guessing that's why you know STL when

00:18:39,060 --> 00:18:48,960
things don't do that one thing is really

00:18:44,820 --> 00:18:50,450
cool is we're gonna open source STL like

00:18:48,960 --> 00:18:56,310
for real

00:18:50,450 --> 00:18:58,320
okay so Rob over here is gonna take pull

00:18:56,310 --> 00:19:02,010
requests and things once we get all set

00:18:58,320 --> 00:19:05,370
up keep an eye on this place here on

00:19:02,010 --> 00:19:07,650
github and you'll see it soon we'll talk

00:19:05,370 --> 00:19:11,040
about the details to the SG 14 group and

00:19:07,650 --> 00:19:14,010
I don't know him we just barely decided

00:19:11,040 --> 00:19:20,610
all this stuff so hopefully I'm not

00:19:14,010 --> 00:19:22,770
causing any trouble with this so but

00:19:20,610 --> 00:19:27,870
even though we invented our own version

00:19:22,770 --> 00:19:30,390
of STL we didn't all think of the same

00:19:27,870 --> 00:19:32,820
thing in the same vision I guess you

00:19:30,390 --> 00:19:37,110
know allocators for example do you want

00:19:32,820 --> 00:19:39,210
them to be polymorphic or do you not we

00:19:37,110 --> 00:19:41,160
couldn't decide on that ours had state

00:19:39,210 --> 00:19:43,110
and things in them so we had more

00:19:41,160 --> 00:19:48,090
something towards the allocators that

00:19:43,110 --> 00:19:49,800
are in 20 in 2011 so we could use them

00:19:48,090 --> 00:19:52,500
sort of like this where we would be able

00:19:49,800 --> 00:19:54,210
to override and use our I core

00:19:52,500 --> 00:19:56,040
allocators

00:19:54,210 --> 00:19:58,020
which is our allocation interface and we

00:19:56,040 --> 00:19:59,330
could use them everywhere and this

00:19:58,020 --> 00:20:03,070
worked okay

00:19:59,330 --> 00:20:05,840
it was not bad but you had this problem

00:20:03,070 --> 00:20:07,310
you have a lot of default parameters and

00:20:05,840 --> 00:20:09,200
if you keep things exactly the same

00:20:07,310 --> 00:20:11,960
interfaces STL which is what we wanted

00:20:09,200 --> 00:20:14,840
to do you had to pass in all of this

00:20:11,960 --> 00:20:18,170
stuff that you didn't want to pass in

00:20:14,840 --> 00:20:21,200
and so it was a pain to use you know

00:20:18,170 --> 00:20:23,720
this is okay but it's not great another

00:20:21,200 --> 00:20:25,280
way to solve the problem was this you

00:20:23,720 --> 00:20:26,810
could have your vector and you could

00:20:25,280 --> 00:20:28,250
call get allocator and then set a

00:20:26,810 --> 00:20:30,800
locator on it and change it each time

00:20:28,250 --> 00:20:32,570
and the STL the way it works is you

00:20:30,800 --> 00:20:35,000
guaranteed that it will not allocate

00:20:32,570 --> 00:20:36,620
memory right away it will only allocate

00:20:35,000 --> 00:20:40,280
memory once you push something into it

00:20:36,620 --> 00:20:41,630
and so that that worked okay and our

00:20:40,280 --> 00:20:43,010
team is a pretty big team and so

00:20:41,630 --> 00:20:45,650
sometimes we think we can get away with

00:20:43,010 --> 00:20:47,180
just changing the interface and we

00:20:45,650 --> 00:20:51,440
shouldn't at least try to do these bad

00:20:47,180 --> 00:20:53,330
ones so this was me I added it our

00:20:51,440 --> 00:20:56,060
system allows us to look up allocators

00:20:53,330 --> 00:20:57,920
by name and so I decided that was a good

00:20:56,060 --> 00:21:00,950
idea and that was not a good idea and

00:20:57,920 --> 00:21:02,480
fortunately nobody took it and it should

00:21:00,950 --> 00:21:06,350
die one of these days but there's a lot

00:21:02,480 --> 00:21:10,760
of code that looks like that the other

00:21:06,350 --> 00:21:12,380
thing that happens with you know

00:21:10,760 --> 00:21:15,770
allocators and things is this kind of

00:21:12,380 --> 00:21:17,210
problem I'm guessing many people would

00:21:15,770 --> 00:21:20,930
know the problem here is people know

00:21:17,210 --> 00:21:24,320
what the problem here is good this

00:21:20,930 --> 00:21:25,520
compiler doesn't work there are

00:21:24,320 --> 00:21:27,910
different types right they're both

00:21:25,520 --> 00:21:29,990
vectors of type int but because there

00:21:27,910 --> 00:21:34,640
alligators are different it doesn't know

00:21:29,990 --> 00:21:37,400
what to do and so it explodes so we

00:21:34,640 --> 00:21:40,340
invented another thing this is only

00:21:37,400 --> 00:21:41,990
internally and and so I don't know if

00:21:40,340 --> 00:21:43,640
we're gonna make this public but I think

00:21:41,990 --> 00:21:49,430
we should because it's it's not a bad

00:21:43,640 --> 00:21:51,140
idea we took and wrapped all of STL I

00:21:49,430 --> 00:21:52,910
wouldn't suggest that that everybody

00:21:51,140 --> 00:21:55,000
does this but if you've got a large

00:21:52,910 --> 00:21:59,090
enough system maybe this is an idea and

00:21:55,000 --> 00:22:02,150
we changed the order of parameters for

00:21:59,090 --> 00:22:03,650
ourselves so that we could pass in the

00:22:02,150 --> 00:22:06,320
information and we made sure that the

00:22:03,650 --> 00:22:07,790
allocator was always first because i was

00:22:06,320 --> 00:22:10,550
telling all the engineers you have to

00:22:07,790 --> 00:22:12,200
pass in an alligator of course they

00:22:10,550 --> 00:22:12,690
would tell me that you know if i have to

00:22:12,200 --> 00:22:14,910
pass it

00:22:12,690 --> 00:22:19,290
allocator everywhere it's really hard to

00:22:14,910 --> 00:22:21,360
write my map of list of strings and then

00:22:19,290 --> 00:22:23,100
I would say please do not write a map of

00:22:21,360 --> 00:22:28,760
list of strings at least use a hash

00:22:23,100 --> 00:22:33,240
table of you know vectors of strings but

00:22:28,760 --> 00:22:35,340
you know that sort of thing worked well

00:22:33,240 --> 00:22:37,290
enough it was it was sort of good and

00:22:35,340 --> 00:22:38,460
you know what got people like if I give

00:22:37,290 --> 00:22:41,700
it to a junior engineer they could

00:22:38,460 --> 00:22:45,660
figure it out we continued it for a bit

00:22:41,700 --> 00:22:48,000
more so that we could for a large system

00:22:45,660 --> 00:22:49,140
if you were writing like 70 files or

00:22:48,000 --> 00:22:51,360
something like this

00:22:49,140 --> 00:22:54,630
C files or something the things on this

00:22:51,360 --> 00:22:56,550
scale starts making stents or so where

00:22:54,630 --> 00:22:58,920
you could make your own string type for

00:22:56,550 --> 00:23:01,860
that large system so in our career mode

00:22:58,920 --> 00:23:04,170
case we would make you know a new string

00:23:01,860 --> 00:23:05,700
type for it and and we would we would

00:23:04,170 --> 00:23:08,430
know that we just wanted to use the same

00:23:05,700 --> 00:23:10,470
allocator each time and it was fine it

00:23:08,430 --> 00:23:12,210
was it was close enough and because of

00:23:10,470 --> 00:23:15,330
the way we did the inheritance here you

00:23:12,210 --> 00:23:17,490
can see it's inheriting from STL a

00:23:15,330 --> 00:23:23,520
vector in this case although it probably

00:23:17,490 --> 00:23:25,500
should be string I guess we could the

00:23:23,520 --> 00:23:27,270
inheritance because this would work out

00:23:25,500 --> 00:23:30,330
the alligators are the same the types

00:23:27,270 --> 00:23:33,060
the same and I don't get a compiler

00:23:30,330 --> 00:23:35,900
error anymore and so now I can transfer

00:23:33,060 --> 00:23:40,260
the types between them this will copy

00:23:35,900 --> 00:23:42,120
the the data so from the localization

00:23:40,260 --> 00:23:43,410
string and it would copy it into the

00:23:42,120 --> 00:23:45,590
career mode string and that's what we

00:23:43,410 --> 00:23:47,460
wanted to achieve because you know

00:23:45,590 --> 00:23:49,770
localization is supposed to be sort of

00:23:47,460 --> 00:23:51,180
like a factory and so therefore it

00:23:49,770 --> 00:23:53,550
supposed to be producing strings for the

00:23:51,180 --> 00:23:55,230
other system and career mode should be

00:23:53,550 --> 00:23:57,240
owning it because it has a duration of

00:23:55,230 --> 00:23:59,010
time career career mode starts and it

00:23:57,240 --> 00:24:00,810
ends and so therefore I can tell if all

00:23:59,010 --> 00:24:02,850
the strings got freed at some point and

00:24:00,810 --> 00:24:05,850
and I can write systems that prove

00:24:02,850 --> 00:24:14,310
that's the case and so this fixes my

00:24:05,850 --> 00:24:21,060
ownership issue which is quite useful so

00:24:14,310 --> 00:24:22,980
now we're off to today so today we

00:24:21,060 --> 00:24:24,780
obviously have even more memory we have

00:24:22,980 --> 00:24:26,550
64-bit addresses so that's really good

00:24:24,780 --> 00:24:28,530
we have hard drives

00:24:26,550 --> 00:24:29,520
on all of the consoles so we're allowed

00:24:28,530 --> 00:24:34,290
to use them now

00:24:29,520 --> 00:24:36,600
the GPUs are not quite virtual memory

00:24:34,290 --> 00:24:38,610
but they're getting close and we're even

00:24:36,600 --> 00:24:40,530
allowed to not have linear textures for

00:24:38,610 --> 00:24:42,330
them and so that's really good so that

00:24:40,530 --> 00:24:45,780
means our debugging system should change

00:24:42,330 --> 00:24:48,960
again and est-elle tracking we took

00:24:45,780 --> 00:24:50,400
another crack at it and finally I'm

00:24:48,960 --> 00:24:53,820
going to talk about our new debugging

00:24:50,400 --> 00:24:56,910
tools that we've been developing

00:24:53,820 --> 00:24:59,550
in-house so one thing that started

00:24:56,910 --> 00:25:02,940
happening around this time is you know

00:24:59,550 --> 00:25:05,940
that people started throwing out the

00:25:02,940 --> 00:25:07,110
debug name it started not necessarily

00:25:05,940 --> 00:25:11,010
being the way we wanted to solve

00:25:07,110 --> 00:25:12,720
problems we still passed in an IKE or

00:25:11,010 --> 00:25:14,010
alligator pointer everywhere so we had

00:25:12,720 --> 00:25:17,910
still had our polymorphic alligator

00:25:14,010 --> 00:25:20,400
everywhere but we wanted to do things

00:25:17,910 --> 00:25:23,520
like this where we wanted to associate a

00:25:20,400 --> 00:25:25,860
lot more data with our allocations not

00:25:23,520 --> 00:25:27,390
just associated debug name because

00:25:25,860 --> 00:25:28,860
before we would you know associated

00:25:27,390 --> 00:25:31,050
debug name and say if we loaded a file

00:25:28,860 --> 00:25:32,640
we might make the debug name equal to

00:25:31,050 --> 00:25:34,740
the file but we couldn't tell that it

00:25:32,640 --> 00:25:37,140
was a resource or something like that so

00:25:34,740 --> 00:25:41,640
this came from this resource and with

00:25:37,140 --> 00:25:43,050
scopes we could sow scopes is maybe the

00:25:41,640 --> 00:25:45,750
way we should go I mean we have to use

00:25:43,050 --> 00:25:46,980
more thread local storage and things and

00:25:45,750 --> 00:25:49,470
so there's some performance related

00:25:46,980 --> 00:25:51,360
problems there but we started using

00:25:49,470 --> 00:25:52,860
scopes quite a bit and most of the debug

00:25:51,360 --> 00:25:55,740
information that we're trying to push in

00:25:52,860 --> 00:25:58,380
now is going this way we still have the

00:25:55,740 --> 00:26:02,640
old interfaces of course nothing ever

00:25:58,380 --> 00:26:04,680
dies but it it's it's working pretty

00:26:02,640 --> 00:26:05,700
well so so our code kind of looks like

00:26:04,680 --> 00:26:08,580
this

00:26:05,700 --> 00:26:12,450
we knew we passed in an alligator we

00:26:08,580 --> 00:26:14,700
knew a team you know est-il sort of

00:26:12,450 --> 00:26:17,340
still a problem it's not quite fitting I

00:26:14,700 --> 00:26:20,400
mean we invented this EA

00:26:17,340 --> 00:26:21,960
tilaka I guess I didn't say yes Teleca

00:26:20,400 --> 00:26:28,470
by the way is supposed to be pronounced

00:26:21,960 --> 00:26:31,020
like Metallica and it's EST l ike or

00:26:28,470 --> 00:26:35,600
allocator sorry I didn't explain that

00:26:31,020 --> 00:26:39,270
before but it's brutal is pronounced

00:26:35,600 --> 00:26:41,670
so what we started to do with the STL

00:26:39,270 --> 00:26:44,400
like because we wanted to solve it in a

00:26:41,670 --> 00:26:46,260
cleaner way you can have an arena like a

00:26:44,400 --> 00:26:48,270
gameplay arena or a level arena it

00:26:46,260 --> 00:26:50,880
doesn't really matter which and you

00:26:48,270 --> 00:26:54,030
could allocate you know your team your

00:26:50,880 --> 00:26:56,370
home team or whatever and maybe it has a

00:26:54,030 --> 00:26:57,750
team ID and a vector of players and of

00:26:56,370 --> 00:26:58,860
course everyone knows what a vector is

00:26:57,750 --> 00:27:00,690
gonna have in it it's gonna have an

00:26:58,860 --> 00:27:05,790
alligator which might have be zero bytes

00:27:00,690 --> 00:27:09,570
you know first last end pointer but what

00:27:05,790 --> 00:27:12,600
you could do is you could check what

00:27:09,570 --> 00:27:17,220
arena that alligator would have been in

00:27:12,600 --> 00:27:19,230
and you can do this really fast and

00:27:17,220 --> 00:27:22,020
probably everybody can do it this day

00:27:19,230 --> 00:27:25,050
really fast is because if you've got

00:27:22,020 --> 00:27:25,920
delete to work and it's going really

00:27:25,050 --> 00:27:28,230
fast

00:27:25,920 --> 00:27:30,360
you must have global delete you must

00:27:28,230 --> 00:27:32,970
have some way to implement global delete

00:27:30,360 --> 00:27:35,810
and look up your pointer and figure out

00:27:32,970 --> 00:27:40,260
how you should free this global pointer

00:27:35,810 --> 00:27:43,410
and so because every team could

00:27:40,260 --> 00:27:45,600
implement this this means we could use

00:27:43,410 --> 00:27:50,760
that information as a parameter to

00:27:45,600 --> 00:27:53,640
decide where the players should go it

00:27:50,760 --> 00:27:54,780
didn't have to be exactly the same pool

00:27:53,640 --> 00:27:57,360
I mean we could do slightly different

00:27:54,780 --> 00:27:59,070
things we could decide that players

00:27:57,360 --> 00:28:01,470
should go in a small block allocator for

00:27:59,070 --> 00:28:04,680
example but if you think about this you

00:28:01,470 --> 00:28:06,510
know who owns what team owns this

00:28:04,680 --> 00:28:09,420
information well probably it's the same

00:28:06,510 --> 00:28:11,610
people that created it what lifetime is

00:28:09,420 --> 00:28:13,230
it gonna have well the team's created it

00:28:11,610 --> 00:28:15,780
players probably lived as long as the

00:28:13,230 --> 00:28:18,260
team may be you know that's that's you

00:28:15,780 --> 00:28:21,000
know probably making a pretty good guess

00:28:18,260 --> 00:28:23,310
at least it's better than what we were

00:28:21,000 --> 00:28:25,080
doing before what would we do before I

00:28:23,310 --> 00:28:26,940
mean we would just allocate these things

00:28:25,080 --> 00:28:30,270
in global and be done with it I guess

00:28:26,940 --> 00:28:31,950
and that's really wrong there's lots of

00:28:30,270 --> 00:28:34,560
interesting little problems with this I

00:28:31,950 --> 00:28:36,240
mean it's not free you have to spend

00:28:34,560 --> 00:28:39,390
some time to look up what arena this

00:28:36,240 --> 00:28:41,220
thing is in is that a great thing to do

00:28:39,390 --> 00:28:43,860
I don't know

00:28:41,220 --> 00:28:45,990
move operators obviously if you want to

00:28:43,860 --> 00:28:48,270
change ownerships between systems it's

00:28:45,990 --> 00:28:49,740
not gonna work it's going to move

00:28:48,270 --> 00:28:51,420
the vector but it's not going to move

00:28:49,740 --> 00:28:54,420
the underlying allocation of all of the

00:28:51,420 --> 00:28:57,210
players but it works 80% of the time and

00:28:54,420 --> 00:29:01,590
maybe that's good enough you made it you

00:28:57,210 --> 00:29:03,870
own it not a bad rule for other cases

00:29:01,590 --> 00:29:07,860
maybe you could use a yeast ellika like

00:29:03,870 --> 00:29:10,020
pattern that's a good idea you know for

00:29:07,860 --> 00:29:11,550
a factory like localization or something

00:29:10,020 --> 00:29:14,130
like that where you you didn't want to

00:29:11,550 --> 00:29:19,650
keep ownership of everything you created

00:29:14,130 --> 00:29:23,820
maybe that's a good idea so finally I'm

00:29:19,650 --> 00:29:25,830
gonna talk about Delta Delta viewer

00:29:23,820 --> 00:29:29,700
which is a tool we've been working on

00:29:25,830 --> 00:29:32,070
internally to show how we've combined

00:29:29,700 --> 00:29:37,770
together all of our debugging tools and

00:29:32,070 --> 00:29:39,960
tried to be able to see them in in one

00:29:37,770 --> 00:29:44,280
environment and try and show you why we

00:29:39,960 --> 00:29:46,470
need that what we do is we we debug

00:29:44,280 --> 00:29:48,450
sessions of data in a session what I

00:29:46,470 --> 00:29:51,330
mean by that is when you play a game you

00:29:48,450 --> 00:29:53,309
keep playing it until you crash or quit

00:29:51,330 --> 00:29:57,570
and crashing is actually fairly common

00:29:53,309 --> 00:30:00,540
when it you're working on it so and all

00:29:57,570 --> 00:30:02,880
of this data you stream it out to the

00:30:00,540 --> 00:30:04,950
ESI's machine and there's a server that

00:30:02,880 --> 00:30:07,020
runs on each ESI's machine to collect up

00:30:04,950 --> 00:30:11,100
all of this data or on the QAS machine

00:30:07,020 --> 00:30:13,830
if it's you know being run by keyway all

00:30:11,100 --> 00:30:15,480
this data is stored in tables and these

00:30:13,830 --> 00:30:17,010
tables are then in view so it's

00:30:15,480 --> 00:30:20,040
basically a database on everybody's

00:30:17,010 --> 00:30:23,429
machine but that's actually really

00:30:20,040 --> 00:30:26,850
useful because we can build these views

00:30:23,429 --> 00:30:33,090
around it and and and have all of these

00:30:26,850 --> 00:30:35,220
views work with each other so some of

00:30:33,090 --> 00:30:38,760
our popular views are sort of like a

00:30:35,220 --> 00:30:41,280
printf TTY channel kind of like thing we

00:30:38,760 --> 00:30:44,460
have I owe profiling so the load

00:30:41,280 --> 00:30:47,940
profiling frame rates jobs profiling

00:30:44,460 --> 00:30:50,340
threads those kind of information we

00:30:47,940 --> 00:30:52,380
also have you know a memory investigator

00:30:50,340 --> 00:30:54,600
tool which helps us see changes in

00:30:52,380 --> 00:30:57,120
memory over time and we have another

00:30:54,600 --> 00:30:59,790
sort of categorization system and the

00:30:57,120 --> 00:31:02,130
categorization system sort of groups

00:30:59,790 --> 00:31:06,630
together allocations and allows us to

00:31:02,130 --> 00:31:11,700
to see things at a high scale so with

00:31:06,630 --> 00:31:13,520
tty even just tty systems you get kind

00:31:11,700 --> 00:31:16,440
of an interesting thing going on here

00:31:13,520 --> 00:31:18,120
you can see channels and in this case

00:31:16,440 --> 00:31:22,230
I'm looking at only one channel and this

00:31:18,120 --> 00:31:25,260
is LTC which is load time channel and so

00:31:22,230 --> 00:31:28,860
I can see when load time started and

00:31:25,260 --> 00:31:31,350
ended in this game and I can see when

00:31:28,860 --> 00:31:32,610
level two happen I know the data very

00:31:31,350 --> 00:31:34,680
well and that's why I'm having to

00:31:32,610 --> 00:31:36,840
highlight it and so I've got a primitive

00:31:34,680 --> 00:31:39,180
little you know profiler right here and

00:31:36,840 --> 00:31:40,860
so that's kind of cool that's that's a

00:31:39,180 --> 00:31:42,060
neat idea all on its own it's nice to

00:31:40,860 --> 00:31:45,510
get the print halves off of the machine

00:31:42,060 --> 00:31:48,720
because printf sir actually on some

00:31:45,510 --> 00:31:50,250
consoles are very very expensive but of

00:31:48,720 --> 00:31:52,650
course you know that's a pretty

00:31:50,250 --> 00:31:55,140
primitive thing and you know maybe you'd

00:31:52,650 --> 00:31:57,840
want a more better version of a load

00:31:55,140 --> 00:32:00,680
profiler this is what we have and it's

00:31:57,840 --> 00:32:03,180
actually maybe overly complicated but

00:32:00,680 --> 00:32:06,210
I'll give you the highlights anyways

00:32:03,180 --> 00:32:08,670
which is there's this load profiler and

00:32:06,210 --> 00:32:11,640
it has a timeline there and time goes

00:32:08,670 --> 00:32:13,770
from one side to the other and we have

00:32:11,640 --> 00:32:15,930
this concept called bundles and we

00:32:13,770 --> 00:32:18,000
grouped together files that we're gonna

00:32:15,930 --> 00:32:20,460
load together and then we load them all

00:32:18,000 --> 00:32:22,800
at once and this is better for seeks and

00:32:20,460 --> 00:32:25,500
things we also have things like chunks

00:32:22,800 --> 00:32:28,530
which you know like parts of movies and

00:32:25,500 --> 00:32:30,510
parts of video and terrain and

00:32:28,530 --> 00:32:35,120
open-world games and that sort of thing

00:32:30,510 --> 00:32:37,050
like sort of sub parts of files and

00:32:35,120 --> 00:32:39,360
bundles really tell me when I'm gonna

00:32:37,050 --> 00:32:43,080
get in my next level or sub level and so

00:32:39,360 --> 00:32:44,700
usually they're kind of you know when

00:32:43,080 --> 00:32:49,830
they're done then you're finished

00:32:44,700 --> 00:32:53,010
loading and what you can do with these

00:32:49,830 --> 00:32:54,570
two views the tty channels and the load

00:32:53,010 --> 00:32:59,910
time profilers you can combine them

00:32:54,570 --> 00:33:01,530
together you can see the printf in the

00:32:59,910 --> 00:33:04,470
load time view you can see when they

00:33:01,530 --> 00:33:06,720
happen and you know this is like adding

00:33:04,470 --> 00:33:10,650
events to it and that's really cool you

00:33:06,720 --> 00:33:13,730
can see when you were loading level one

00:33:10,650 --> 00:33:15,570
you can see when you're playing the game

00:33:13,730 --> 00:33:17,910
you can see

00:33:15,570 --> 00:33:20,670
you're playing level two you can see

00:33:17,910 --> 00:33:22,260
when you're you know actually loading

00:33:20,670 --> 00:33:25,110
level two when you're playing level two

00:33:22,260 --> 00:33:27,750
and you can see that I haven't actually

00:33:25,110 --> 00:33:29,430
finished loading when I'm playing which

00:33:27,750 --> 00:33:32,550
is kind of odd and I probably should

00:33:29,430 --> 00:33:33,750
have done if you actually played the

00:33:32,550 --> 00:33:35,100
game unfortunately I don't have a video

00:33:33,750 --> 00:33:37,800
to go with it it's a feature we were

00:33:35,100 --> 00:33:40,560
going to add but we haven't done yet if

00:33:37,800 --> 00:33:42,510
you hover over top of that file you can

00:33:40,560 --> 00:33:44,490
find out that that crowds aren't loaded

00:33:42,510 --> 00:33:45,870
yet and if you're playing the game you

00:33:44,490 --> 00:33:47,910
could actually see that the crowd sort

00:33:45,870 --> 00:33:50,970
of pop in as the game was playing in

00:33:47,910 --> 00:33:55,530
that isn't very good we fix that bug and

00:33:50,970 --> 00:33:57,390
that was good next thing is as a load

00:33:55,530 --> 00:33:59,040
profiler and if you know anything about

00:33:57,390 --> 00:34:03,090
games of course games are broken up into

00:33:59,040 --> 00:34:06,720
frames and the the the height of each

00:34:03,090 --> 00:34:09,720
one of these things is is a frame and so

00:34:06,720 --> 00:34:12,000
higher it is worse it is and so in this

00:34:09,720 --> 00:34:14,640
case that is a very expensive frame and

00:34:12,000 --> 00:34:18,870
that is not allowed you got a hammer

00:34:14,640 --> 00:34:20,430
that guy down somehow or another you can

00:34:18,870 --> 00:34:21,900
highlight what's going on there and

00:34:20,430 --> 00:34:24,330
that's what's going on there in blue is

00:34:21,900 --> 00:34:27,030
I actually highlighted this one and all

00:34:24,330 --> 00:34:30,270
of that information shows up down there

00:34:27,030 --> 00:34:32,490
at the bottom and you can see this

00:34:30,270 --> 00:34:34,410
expensive frame you can see when it

00:34:32,490 --> 00:34:35,520
started and when it ended and you can

00:34:34,410 --> 00:34:38,940
see it's slightly bigger than all the

00:34:35,520 --> 00:34:41,340
rest all of that noise there is a thing

00:34:38,940 --> 00:34:42,960
called jobs and jobs let's just call

00:34:41,340 --> 00:34:45,030
them callbacks that happen on another

00:34:42,960 --> 00:34:47,910
thread and then you can see their

00:34:45,030 --> 00:34:50,490
function call stacks as you you you know

00:34:47,910 --> 00:34:52,470
pop back and forth happening over and

00:34:50,490 --> 00:34:57,150
over they're not complete call stacks

00:34:52,470 --> 00:34:59,190
but you know most of it is there one

00:34:57,150 --> 00:35:02,370
thing I noticed because I know this game

00:34:59,190 --> 00:35:05,340
really well and in some games this is

00:35:02,370 --> 00:35:07,320
not the case but we shouldn't be waiting

00:35:05,340 --> 00:35:09,450
for render a lot of games are highly

00:35:07,320 --> 00:35:12,090
coupled our game can slide back and

00:35:09,450 --> 00:35:15,480
forth three or four frames between our

00:35:12,090 --> 00:35:17,190
rendering inner and our sim and so I

00:35:15,480 --> 00:35:18,750
shouldn't have this all of these yellow

00:35:17,190 --> 00:35:20,370
things should be gone in this particular

00:35:18,750 --> 00:35:21,990
yellow happen to be really expensive

00:35:20,370 --> 00:35:23,700
because the GPU is a little slow and

00:35:21,990 --> 00:35:28,960
ones once I removed all of the yellow

00:35:23,700 --> 00:35:31,390
everything ran a whole lot better but

00:35:28,960 --> 00:35:37,720
you can still combine together more of

00:35:31,390 --> 00:35:39,940
these views and you need to do this

00:35:37,720 --> 00:35:40,990
because during load time the whole

00:35:39,940 --> 00:35:42,880
machine is running

00:35:40,990 --> 00:35:44,619
you're not just spinning the you know

00:35:42,880 --> 00:35:46,810
the disk in trying to load things up you

00:35:44,619 --> 00:35:49,990
have to you know load things and then

00:35:46,810 --> 00:35:51,820
you'll have to decompress them because

00:35:49,990 --> 00:35:54,520
loading compress things are faster and

00:35:51,820 --> 00:35:56,140
then you'll have the texture or whatever

00:35:54,520 --> 00:35:59,050
and you'll start stomping names or

00:35:56,140 --> 00:36:02,260
something on it with a font and then

00:35:59,050 --> 00:36:04,390
from there you know because then writing

00:36:02,260 --> 00:36:06,520
the names is easy in 32 bits or whatever

00:36:04,390 --> 00:36:08,740
you you want to compress it down and

00:36:06,520 --> 00:36:10,810
make it a smaller type of texture

00:36:08,740 --> 00:36:12,490
because the GPU would be happier to run

00:36:10,810 --> 00:36:13,900
on that smaller type and you know the

00:36:12,490 --> 00:36:15,970
color reduction and stuff this is going

00:36:13,900 --> 00:36:19,660
to work sometimes that is done in the

00:36:15,970 --> 00:36:23,380
GPU but a lot of these things are CPU

00:36:19,660 --> 00:36:26,500
limited so you can see here in 4k glory

00:36:23,380 --> 00:36:30,369
which is really hard to you read for

00:36:26,500 --> 00:36:32,880
everybody but you get the idea that I've

00:36:30,369 --> 00:36:37,510
got turbo tuner up at the top I've got

00:36:32,880 --> 00:36:38,920
my frame rate meter there and I can view

00:36:37,510 --> 00:36:43,030
all of what's going on in all of the

00:36:38,920 --> 00:36:46,180
CPUs I can highlight what's going on on

00:36:43,030 --> 00:36:48,130
the turbo tuner to see what's going on

00:36:46,180 --> 00:36:52,000
and what file IO is going on in a

00:36:48,130 --> 00:36:54,430
particular location and what I'll see is

00:36:52,000 --> 00:36:57,099
I'll see you know these frames are bad

00:36:54,430 --> 00:37:00,430
and I can see what file IO is going on

00:36:57,099 --> 00:37:03,280
there or I can see around this file IO

00:37:00,430 --> 00:37:04,960
is my framerate good you know what kind

00:37:03,280 --> 00:37:06,760
of processing is happening right after

00:37:04,960 --> 00:37:08,859
these files and I can do it either way

00:37:06,760 --> 00:37:11,380
so no matter which one I select the

00:37:08,859 --> 00:37:13,720
other one gets selected at the same time

00:37:11,380 --> 00:37:16,540
and all of that ends up showing up on

00:37:13,720 --> 00:37:20,140
the bottom and I can see what's going on

00:37:16,540 --> 00:37:22,450
and see my one big frame and what's

00:37:20,140 --> 00:37:26,980
going on in every single CPU and the GPU

00:37:22,450 --> 00:37:28,270
as well in this case I you actually

00:37:26,980 --> 00:37:29,980
don't know what the bug is yet I haven't

00:37:28,270 --> 00:37:36,609
figured that it so I'll have to spend

00:37:29,980 --> 00:37:37,839
some more time on it but soon now memory

00:37:36,609 --> 00:37:39,490
is kind of an interesting thing

00:37:37,839 --> 00:37:42,370
especially memory leaks it's funny if I

00:37:39,490 --> 00:37:44,410
ever if I you just google memory leaks

00:37:42,370 --> 00:37:46,780
you get some strange advice and they say

00:37:44,410 --> 00:37:48,190
hey make sure that you free all of your

00:37:46,780 --> 00:37:50,140
memory when you shut it down and I'm

00:37:48,190 --> 00:37:53,200
always like really I don't know I just

00:37:50,140 --> 00:37:57,070
delete my process the OS is better at it

00:37:53,200 --> 00:37:58,870
than me maybe thought that doing that in

00:37:57,070 --> 00:38:02,080
debug mode or something isn't useful I

00:37:58,870 --> 00:38:03,730
guess but really what you want is to put

00:38:02,080 --> 00:38:04,930
the Machine in some steady state and

00:38:03,730 --> 00:38:06,730
make sure that you never go above

00:38:04,930 --> 00:38:08,110
certain high-water marks and stuff

00:38:06,730 --> 00:38:09,550
because you know if you were here in

00:38:08,110 --> 00:38:11,710
constables you only have so much memory

00:38:09,550 --> 00:38:13,360
and you don't want all these performance

00:38:11,710 --> 00:38:17,500
and swap things out to disk or something

00:38:13,360 --> 00:38:19,470
like that so the way I look at memory

00:38:17,500 --> 00:38:22,720
leaks what I would call a memory leak is

00:38:19,470 --> 00:38:25,240
I capture allocations between a

00:38:22,720 --> 00:38:27,670
particular period of time like okay

00:38:25,240 --> 00:38:29,050
loading level one from the beginning of

00:38:27,670 --> 00:38:30,970
the load to the end of the load I've

00:38:29,050 --> 00:38:33,550
probably loaded most of my big assets

00:38:30,970 --> 00:38:35,680
there for the level and then I can make

00:38:33,550 --> 00:38:39,970
sure that those are unloaded by the time

00:38:35,680 --> 00:38:44,080
I'm getting to level two because I don't

00:38:39,970 --> 00:38:46,650
want that high-water mark so for example

00:38:44,080 --> 00:38:49,900
if I've got this allocation at time t1 I

00:38:46,650 --> 00:38:53,470
want to make sure that it's freed before

00:38:49,900 --> 00:38:56,050
C in this case it's freed after C it is

00:38:53,470 --> 00:38:58,090
freed but it's still Ali because it's

00:38:56,050 --> 00:39:00,190
adding to my high-water mark I said it

00:38:58,090 --> 00:39:02,740
was going to be free and it is not and

00:39:00,190 --> 00:39:08,200
so I need to go dig into this and find

00:39:02,740 --> 00:39:10,690
out what that problem is so what you can

00:39:08,200 --> 00:39:13,990
do is you can look at turbo tuner and

00:39:10,690 --> 00:39:16,270
you can determine where a B and C are

00:39:13,990 --> 00:39:19,870
you can go find out that you know okay

00:39:16,270 --> 00:39:21,970
my level one loading is here and by see

00:39:19,870 --> 00:39:24,640
all of those allocations better be gone

00:39:21,970 --> 00:39:27,160
and then you can see that I've got a big

00:39:24,640 --> 00:39:31,150
leap big list of memory leaks here which

00:39:27,160 --> 00:39:32,800
kind of sucks but fortunately I have

00:39:31,150 --> 00:39:36,220
good information I know what scope

00:39:32,800 --> 00:39:38,800
they're from I know what their pointer

00:39:36,220 --> 00:39:41,980
their size I know their call stack IDs I

00:39:38,800 --> 00:39:44,440
know a highlighted item which you know

00:39:41,980 --> 00:39:47,440
what a full call stack they're I don't

00:39:44,440 --> 00:39:49,870
know what assets were associated with

00:39:47,440 --> 00:39:51,460
that location so I have lots of all of

00:39:49,870 --> 00:39:53,980
this sort of metadata with each

00:39:51,460 --> 00:39:56,350
allocation and so that's really powerful

00:39:53,980 --> 00:39:58,960
I can see other things but

00:39:56,350 --> 00:40:01,000
it's just this sort of ABC member link

00:39:58,960 --> 00:40:02,650
thing there's other modes and can do

00:40:01,000 --> 00:40:04,330
similar things to the previous tool

00:40:02,650 --> 00:40:06,010
where I can you know just highlight two

00:40:04,330 --> 00:40:09,340
points and see what growth I had or

00:40:06,010 --> 00:40:15,070
something like that but I think this is

00:40:09,340 --> 00:40:18,430
is pretty useful you can also do memory

00:40:15,070 --> 00:40:20,860
categorization with this tool and this

00:40:18,430 --> 00:40:24,760
is data driven and you can sort of scrub

00:40:20,860 --> 00:40:26,710
between two times you can you know start

00:40:24,760 --> 00:40:28,810
before the levels loaded and after the

00:40:26,710 --> 00:40:31,540
level loaded and you can see how much

00:40:28,810 --> 00:40:37,600
memory goes up in this case you know it

00:40:31,540 --> 00:40:39,460
goes from 2.6 gigs to 3.3 or so I think

00:40:37,600 --> 00:40:42,610
this is kind of interesting because you

00:40:39,460 --> 00:40:43,900
know everybody kind of wonders what goes

00:40:42,610 --> 00:40:45,430
on in games and really I think they're

00:40:43,900 --> 00:40:47,620
very similar to a lot of programs and

00:40:45,430 --> 00:40:50,050
you know I have two point two million

00:40:47,620 --> 00:40:54,340
allocations to point one are smaller

00:40:50,050 --> 00:40:56,950
than 512 bytes so this means my

00:40:54,340 --> 00:40:59,770
debugging systems really I'm focused on

00:40:56,950 --> 00:41:01,630
this number here I have to figure out

00:40:59,770 --> 00:41:03,910
how I'm going to debug this large number

00:41:01,630 --> 00:41:06,550
of small block allocations and deal with

00:41:03,910 --> 00:41:08,410
that scale on the other hand my memory

00:41:06,550 --> 00:41:09,700
leak system when I'm trying to figure

00:41:08,410 --> 00:41:10,930
out you know am I gonna run out of RAM

00:41:09,700 --> 00:41:12,970
or something I really should pay

00:41:10,930 --> 00:41:15,910
attention to the higher numbers where

00:41:12,970 --> 00:41:17,980
I've only got 208 allocations and

00:41:15,910 --> 00:41:20,800
somehow or another that adds up to two

00:41:17,980 --> 00:41:22,330
gigs that was surprising for me but

00:41:20,800 --> 00:41:24,610
these are allocations that are larger

00:41:22,330 --> 00:41:27,280
than than two Meg's so you know they're

00:41:24,610 --> 00:41:29,560
big and I think that happens with with

00:41:27,280 --> 00:41:34,420
many programs there's sort of this

00:41:29,560 --> 00:41:36,250
exponential curve that goes on the other

00:41:34,420 --> 00:41:38,410
thing is is like I was saying this is

00:41:36,250 --> 00:41:40,510
data-driven so by loading another Yama

00:41:38,410 --> 00:41:42,970
file I can look at it in a different way

00:41:40,510 --> 00:41:44,710
I can see how many cars and how much

00:41:42,970 --> 00:41:47,920
cars took up I can see how much trees

00:41:44,710 --> 00:41:50,050
take up I could see you know how much

00:41:47,920 --> 00:41:52,060
any particular element that I wanted to

00:41:50,050 --> 00:41:56,520
in my game bullets weapons

00:41:52,060 --> 00:42:02,020
you know towns I don't know car parks I

00:41:56,520 --> 00:42:03,550
can also see and show to you what you

00:42:02,020 --> 00:42:06,010
know most games are sort of made out of

00:42:03,550 --> 00:42:08,520
most of their memory is really about

00:42:06,010 --> 00:42:11,940
rendering and about asked

00:42:08,520 --> 00:42:15,450
and weigh assets I mean meshes and

00:42:11,940 --> 00:42:16,770
textures for the most part one thing for

00:42:15,450 --> 00:42:20,310
me that when I did this experiment

00:42:16,770 --> 00:42:22,230
surprised me quite a bit is how many

00:42:20,310 --> 00:42:24,750
other allocations I had I mean I've got

00:42:22,230 --> 00:42:26,610
you know 1.2 million allocations and

00:42:24,750 --> 00:42:29,460
assets and if they're supposed to be big

00:42:26,610 --> 00:42:30,810
things what's going on there there's

00:42:29,460 --> 00:42:32,760
actually a whole bunch of entities that

00:42:30,810 --> 00:42:34,560
glue all of these things together in our

00:42:32,760 --> 00:42:35,940
engine and a lot of them are very small

00:42:34,560 --> 00:42:37,860
and there's obviously quite a few of

00:42:35,940 --> 00:42:41,550
them and that's what's going on in this

00:42:37,860 --> 00:42:44,450
case rendering assets are quite similar

00:42:41,550 --> 00:42:47,310
to content in the fact that they're

00:42:44,450 --> 00:42:49,920
nearly like textures and and buffers

00:42:47,310 --> 00:42:51,240
used to draw the scene and those buffers

00:42:49,920 --> 00:42:56,250
sometimes we're a lot like meshes

00:42:51,240 --> 00:43:01,170
actually ah another thing that people

00:42:56,250 --> 00:43:04,170
should know is that code is small

00:43:01,170 --> 00:43:06,150
compared to all of this and so data is

00:43:04,170 --> 00:43:08,820
usually the problem if you can reformat

00:43:06,150 --> 00:43:10,860
your data and and make data faster or

00:43:08,820 --> 00:43:12,630
data better then this is a good idea

00:43:10,860 --> 00:43:15,090
trying to figure out how you can

00:43:12,630 --> 00:43:16,970
compress and make data smaller is

00:43:15,090 --> 00:43:20,160
usually what you should be focused on

00:43:16,970 --> 00:43:23,250
don't get me wrong I mean I don't know

00:43:20,160 --> 00:43:26,609
three months ago I was scraping code out

00:43:23,250 --> 00:43:31,820
of of est-elle and trying to shrink our

00:43:26,609 --> 00:43:36,540
executable size back on PowerPC on on

00:43:31,820 --> 00:43:39,240
gen 3 so a PlayStation 3 and Xbox 360 I

00:43:36,540 --> 00:43:40,590
mean so it does happen and sometimes

00:43:39,240 --> 00:43:44,760
that is the best way to get back memory

00:43:40,590 --> 00:43:50,280
but usually you should look at data

00:43:44,760 --> 00:43:51,930
first so I've introduced a Delta viewer

00:43:50,280 --> 00:43:55,859
and I've shown you all of the different

00:43:51,930 --> 00:43:57,570
views that we've got I've also shown you

00:43:55,859 --> 00:43:59,700
that I've got lots of work left to do

00:43:57,570 --> 00:44:04,350
fortunately I have it your left so I'm

00:43:59,700 --> 00:44:06,900
ok I've taught a little about the the

00:44:04,350 --> 00:44:08,609
differences that we've had between STL

00:44:06,900 --> 00:44:10,859
and STL and how we're trying to track

00:44:08,609 --> 00:44:14,100
all of that memory and how we're trying

00:44:10,859 --> 00:44:16,800
to figure out how to debug it and maybe

00:44:14,100 --> 00:44:20,960
using something like you made it you own

00:44:16,800 --> 00:44:20,960
it kind of style might be a good idea

00:44:21,880 --> 00:44:25,630
silica might be another way to solve

00:44:24,130 --> 00:44:28,720
this problem

00:44:25,630 --> 00:44:31,000
it's an idea I'm not sure if it's

00:44:28,720 --> 00:44:33,040
entirely fully baked but it does seem to

00:44:31,000 --> 00:44:34,840
work pretty well and I can give it to a

00:44:33,040 --> 00:44:37,120
junior engineer I think we'll solve it

00:44:34,840 --> 00:44:41,260
and figure it out right away and so

00:44:37,120 --> 00:44:42,310
that's that's quite good ah finally I

00:44:41,260 --> 00:44:45,190
hope you learned a little bit about

00:44:42,310 --> 00:44:48,790
games in general you know what they're

00:44:45,190 --> 00:44:50,700
made out of how much memory we have and

00:44:48,790 --> 00:44:52,750
they're pretty much similar to most

00:44:50,700 --> 00:44:55,540
styles of things lots of small

00:44:52,750 --> 00:45:00,340
allocations not so many big ones most of

00:44:55,540 --> 00:45:01,930
its rendering in assets you might also

00:45:00,340 --> 00:45:03,460
have seen that you know if you don't

00:45:01,930 --> 00:45:06,310
have things like stomp allocators you

00:45:03,460 --> 00:45:08,710
really should be using them but I guess

00:45:06,310 --> 00:45:11,470
if you're on you know things like Macs

00:45:08,710 --> 00:45:16,120
and PCs then you probably haven have

00:45:11,470 --> 00:45:17,980
better tools than I do there's a lot of

00:45:16,120 --> 00:45:19,840
different ways of having large amounts

00:45:17,980 --> 00:45:21,430
of allocation schemes and really do pay

00:45:19,840 --> 00:45:23,680
attention to it and divide up memory in

00:45:21,430 --> 00:45:29,260
all sorts of ways based on team or size

00:45:23,680 --> 00:45:30,850
or you know time of life besides just

00:45:29,260 --> 00:45:33,100
the ones that everybody talks about here

00:45:30,850 --> 00:45:36,790
where you know it's about performance

00:45:33,100 --> 00:45:38,740
you know fixed size pools and you know

00:45:36,790 --> 00:45:42,940
bump pointer allocators and these kind

00:45:38,740 --> 00:45:45,060
of things what I think that's it for for

00:45:42,940 --> 00:45:45,060
me

00:45:51,280 --> 00:46:06,460
anybody have any questions or anything

00:45:54,130 --> 00:46:06,460
what am i I don't know yeah

00:46:07,150 --> 00:46:26,060
is that on okay cool

00:46:12,320 --> 00:46:29,260
all right yeah yes I the profiler will

00:46:26,060 --> 00:46:31,670
not be open sourced not yet anyways

00:46:29,260 --> 00:46:34,670
don't know if that will change that's

00:46:31,670 --> 00:46:38,390
really cool oh yeah thanks it is pretty

00:46:34,670 --> 00:46:41,600
neat I wanted to show people what we do

00:46:38,390 --> 00:46:43,190
internally I wish maybe Stella cut or

00:46:41,600 --> 00:46:44,900
something like that can be I don't know

00:46:43,190 --> 00:46:46,670
where I'll work on it

00:46:44,900 --> 00:46:49,180
behind the scenes and we'll see I know

00:46:46,670 --> 00:46:53,030
I've just just gotten the ability to do

00:46:49,180 --> 00:46:54,350
STL but I think there is a Simo mentum

00:46:53,030 --> 00:46:55,520
there and so maybe there'll be other

00:46:54,350 --> 00:47:00,650
things that we'll be able to do I don't

00:46:55,520 --> 00:47:02,810
know thank you sad to hear that you're

00:47:00,650 --> 00:47:05,810
not going to open sources but the next

00:47:02,810 --> 00:47:08,240
best thing is there any chance to see

00:47:05,810 --> 00:47:09,290
the features you showed here in the

00:47:08,240 --> 00:47:13,760
screenshots or something like that

00:47:09,290 --> 00:47:20,210
videos so we can copy that to other

00:47:13,760 --> 00:47:21,470
tools like which I'm working on I wish I

00:47:20,210 --> 00:47:22,760
wish I could have done a live demo I

00:47:21,470 --> 00:47:23,900
probably could have got away with a live

00:47:22,760 --> 00:47:26,240
demo except for the fact that I'm

00:47:23,900 --> 00:47:28,730
working on a very tiny Mac and as you

00:47:26,240 --> 00:47:31,700
saw it was like screen space um it's

00:47:28,730 --> 00:47:34,820
like 4k is is pretty good I mean I can

00:47:31,700 --> 00:47:36,530
do it in HD but ya know I'm sorry I

00:47:34,820 --> 00:47:38,450
didn't make any videos or anything of it

00:47:36,530 --> 00:47:42,200
it's pretty new actually we just got it

00:47:38,450 --> 00:47:44,570
internally I would think like the memory

00:47:42,200 --> 00:47:47,210
stuff we just got in July ah

00:47:44,570 --> 00:47:50,030
so I mean it is really our cutting edge

00:47:47,210 --> 00:47:56,390
so as of yet I don't know what we'll do

00:47:50,030 --> 00:47:59,310
with it does espl also work with like

00:47:56,390 --> 00:48:01,890
the standard memory

00:47:59,310 --> 00:48:11,130
smart pointers like unique pointer and

00:48:01,890 --> 00:48:13,110
should pointer or are they completely we

00:48:11,130 --> 00:48:14,940
would have our own implementations of

00:48:13,110 --> 00:48:18,240
those features as well and will usually

00:48:14,940 --> 00:48:21,480
put things in STL to try and make it

00:48:18,240 --> 00:48:25,920
like the the standard you would know

00:48:21,480 --> 00:48:27,390
better than me but okay yeah come talk

00:48:25,920 --> 00:48:31,140
to him and you can tell you more details

00:48:27,390 --> 00:48:56,730
about it I'm a power user more than I'm

00:48:31,140 --> 00:49:02,310
an implementer oh yeah most of the pains

00:48:56,730 --> 00:49:04,920
that we've been through as well the

00:49:02,310 --> 00:49:07,610
particular question I have was this you

00:49:04,920 --> 00:49:10,970
were describing how Tinkham wears debug

00:49:07,610 --> 00:49:14,010
performance was substantially worse

00:49:10,970 --> 00:49:21,540
that's true which we've also discovered

00:49:14,010 --> 00:49:23,700
with our own CIA STL ah there you go but

00:49:21,540 --> 00:49:25,170
we discovered really quickly that this

00:49:23,700 --> 00:49:26,910
was down to the astray to debug level I

00:49:25,170 --> 00:49:28,080
wondered if you to taken account of that

00:49:26,910 --> 00:49:32,730
what is it

00:49:28,080 --> 00:49:34,590
it's a debug level no in our case it's

00:49:32,730 --> 00:49:37,580
not I've shut off all like the

00:49:34,590 --> 00:49:42,720
parameters and everything are fairly

00:49:37,580 --> 00:49:46,020
optimal you know it's a I am trying to

00:49:42,720 --> 00:49:47,340
give it a fair fight you know I wasn't

00:49:46,020 --> 00:49:49,650
trying to disable all the things

00:49:47,340 --> 00:49:50,940
although I don't know if I left the

00:49:49,650 --> 00:49:53,310
debug one and the default I'm pretty

00:49:50,940 --> 00:49:55,560
sure though that that even in the debug

00:49:53,310 --> 00:49:58,590
case that I've turned off all the the

00:49:55,560 --> 00:50:00,120
default debug attributes and things like

00:49:58,590 --> 00:50:02,370
that and I'm not doing you know checking

00:50:00,120 --> 00:50:03,570
to see if I'm off the end or all of

00:50:02,370 --> 00:50:06,650
those kind of things that you could do

00:50:03,570 --> 00:50:06,650
an STL by default

00:50:12,170 --> 00:50:25,920
there's one up there too oh oh sorry um

00:50:18,229 --> 00:50:40,170
yeah what one in sir yeah back back

00:50:25,920 --> 00:50:44,339
right no top hey thanks

00:50:40,170 --> 00:50:46,289
so do you have sort of similar empirical

00:50:44,339 --> 00:50:57,749
data for how the adoption of these tools

00:50:46,289 --> 00:51:01,109
actually reduce I'm not sure actually I

00:50:57,749 --> 00:51:05,670
know like stomp allocator was like a

00:51:01,109 --> 00:51:08,099
revolution in the fact that like I could

00:51:05,670 --> 00:51:10,259
just i started ignoring QA and i would

00:51:08,099 --> 00:51:12,719
just go and try and test with this thing

00:51:10,259 --> 00:51:15,930
and only once i got rid of all the bugs

00:51:12,719 --> 00:51:19,349
that way that i would start you know

00:51:15,930 --> 00:51:21,359
paying attention to - you know QA x' bug

00:51:19,349 --> 00:51:25,039
reports because i would know more about

00:51:21,359 --> 00:51:29,089
the status of the game than they do but

00:51:25,039 --> 00:51:34,219
besides that sort of non empirical data

00:51:29,089 --> 00:51:34,219
i don't have very much

00:51:42,140 --> 00:51:48,779
for a EAS feel were there any you know

00:51:46,410 --> 00:51:50,700
intrinsic decisions that allowed you to

00:51:48,779 --> 00:51:53,009
increase the performance as much as you

00:51:50,700 --> 00:51:55,349
did for certain cases or how were you

00:51:53,009 --> 00:51:57,539
able to get you know such big speed ups

00:51:55,349 --> 00:51:59,880
in certain cases I probably would have

00:51:57,539 --> 00:52:02,099
to go look at pulp Adrianna's paper I

00:51:59,880 --> 00:52:06,660
know we were talking about it on the way

00:52:02,099 --> 00:52:10,680
in I think one has to do with the memory

00:52:06,660 --> 00:52:13,259
model of STL versus EST l i think we're

00:52:10,680 --> 00:52:19,200
allowed to have pointers as being our

00:52:13,259 --> 00:52:21,299
iterators in strings and in vectors so

00:52:19,200 --> 00:52:24,089
that's one place and the other place is

00:52:21,299 --> 00:52:26,700
is we don't rely on inlining as much we

00:52:24,089 --> 00:52:29,519
do more of cutting and pasting and I

00:52:26,700 --> 00:52:33,509
think those two count for much of the

00:52:29,519 --> 00:52:36,720
performance difference off the top of my

00:52:33,509 --> 00:52:39,509
head but I didn't have time to go dig

00:52:36,720 --> 00:52:43,230
into the numbers because that I knew

00:52:39,509 --> 00:52:46,819
everybody wanted to know but I haven't

00:52:43,230 --> 00:52:46,819
had time to to go into the numbers okay

00:52:47,779 --> 00:52:59,670
yes yeah we only have some subset we

00:52:56,880 --> 00:53:01,529
don't have all of them you know which

00:52:59,670 --> 00:53:17,299
ones we have I think we have I know I

00:53:01,529 --> 00:53:23,309
can only think of list yeah yeah okay

00:53:17,299 --> 00:53:26,339
interesting no not yet but that would be

00:53:23,309 --> 00:53:28,079
interesting we do have many other things

00:53:26,339 --> 00:53:29,369
but that or don't get India steel like

00:53:28,079 --> 00:53:37,140
people still write their own custom hash

00:53:29,369 --> 00:53:38,519
tables and things now we're definitely

00:53:37,140 --> 00:53:41,099
interested in adding intrusive

00:53:38,519 --> 00:53:45,000
containers as the next move last g14 so

00:53:41,099 --> 00:53:47,400
people interested contact me yeah if you

00:53:45,000 --> 00:53:50,160
guys do if you guys get them into the

00:53:47,400 --> 00:53:53,150
you know SG 14 we'll pull them probably

00:53:50,160 --> 00:53:53,150
into yes do

00:53:53,930 --> 00:54:02,489
there's sorry I just wanted to say that

00:53:59,489 --> 00:54:05,279
profile you've W profiler you showed us

00:54:02,489 --> 00:54:06,569
is very impressive it's has a lot of

00:54:05,279 --> 00:54:10,940
similarities to Windows performance

00:54:06,569 --> 00:54:13,380
analyzer bad it does and I suspect that

00:54:10,940 --> 00:54:16,019
the logs that you generate could be

00:54:13,380 --> 00:54:18,690
turned into ETL files it opened and much

00:54:16,019 --> 00:54:30,299
of the functionality or I could use D

00:54:18,690 --> 00:54:31,650
trace - of course yes I know it's a and

00:54:30,299 --> 00:54:34,229
there is actually an internal library

00:54:31,650 --> 00:54:36,539
and probably like there's two forces

00:54:34,229 --> 00:54:41,099
going on actually I bet you this might

00:54:36,539 --> 00:54:42,690
become a GUI for another thing I can see

00:54:41,099 --> 00:54:44,130
it happening as I as I wrote this I

00:54:42,690 --> 00:54:46,440
posted this and like one of my

00:54:44,130 --> 00:54:48,359
co-workers is like I want to work on

00:54:46,440 --> 00:54:59,940
that I want to do this cool thing with

00:54:48,359 --> 00:55:08,329
dtrace and we're like ha ha ha I can't

00:54:59,940 --> 00:55:11,549
turn it all in at once I I'm actually

00:55:08,329 --> 00:55:16,019
surprised at how fast it is actually

00:55:11,549 --> 00:55:18,989
like for example when we first converted

00:55:16,019 --> 00:55:21,630
over to the you know every single a lock

00:55:18,989 --> 00:55:25,499
and free sort of model that that is in

00:55:21,630 --> 00:55:26,819
that tool why it was like well in our

00:55:25,499 --> 00:55:28,799
previous system we were only able to

00:55:26,819 --> 00:55:31,999
turn it on just like certain zones at a

00:55:28,799 --> 00:55:34,559
time now I can turn it on everywhere and

00:55:31,999 --> 00:55:37,769
you know what is it you know maybe 10%

00:55:34,559 --> 00:55:40,529
or something it's actually really

00:55:37,769 --> 00:55:42,479
impressive how fast that that pedido on

00:55:40,529 --> 00:55:46,079
the profiling one could use it maybe a

00:55:42,479 --> 00:55:47,160
bit more work mainly because like like

00:55:46,079 --> 00:55:50,339
the things we're talking about but

00:55:47,160 --> 00:55:51,809
DTrace and and other tools like that we

00:55:50,339 --> 00:55:55,499
could probably get better information

00:55:51,809 --> 00:55:56,989
that and then we currently have and

00:55:55,499 --> 00:56:00,660
maybe we could implement that was better

00:55:56,989 --> 00:56:03,400
but you know they're they're usable in

00:56:00,660 --> 00:56:05,559
you know you're gonna lose

00:56:03,400 --> 00:56:09,210
three or four milliseconds of frame or

00:56:05,559 --> 00:56:13,359
something to them that's not too bad I

00:56:09,210 --> 00:56:15,430
can still play my game in real time ish

00:56:13,359 --> 00:56:26,200
as long as you can afford to drop some

00:56:15,430 --> 00:56:31,480
frames what portion is timeless it's

00:56:26,200 --> 00:56:33,150
it's very small and very big teams could

00:56:31,480 --> 00:56:36,250
afford to write some of their own tools

00:56:33,150 --> 00:56:39,220
but in this case this is one of the good

00:56:36,250 --> 00:56:40,869
reasons to start using you know engines

00:56:39,220 --> 00:56:43,660
and you can see why what's going on in

00:56:40,869 --> 00:56:45,339
the gaming community is there's becoming

00:56:43,660 --> 00:56:47,079
less and less engines because just

00:56:45,339 --> 00:57:08,940
tooling up for these things is very

00:56:47,079 --> 00:57:12,099
expensive store logs over time see yeah

00:57:08,940 --> 00:57:13,869
yeah there's a whole other sort of thing

00:57:12,099 --> 00:57:15,369
that goes on here that I'm not showing I

00:57:13,869 --> 00:57:16,809
mean there's a project we call

00:57:15,369 --> 00:57:21,430
biometrics because it came from Bioware

00:57:16,809 --> 00:57:24,099
where we you know we can see all of this

00:57:21,430 --> 00:57:30,099
data over time over many many sessions

00:57:24,099 --> 00:57:31,329
as well so but it's yeah it seems like

00:57:30,099 --> 00:57:33,400
it's per team at the moment because

00:57:31,329 --> 00:57:35,099
teams need different types of data they

00:57:33,400 --> 00:57:37,569
look at the problem differently still

00:57:35,099 --> 00:57:43,890
maybe eventually we'll be able to make

00:57:37,569 --> 00:57:43,890
it more central ok

00:57:48,539 --> 00:57:50,599

YouTube URL: https://www.youtube.com/watch?v=8KIvWJUYbDA


