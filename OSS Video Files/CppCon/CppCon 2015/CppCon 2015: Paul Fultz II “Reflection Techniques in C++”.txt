Title: CppCon 2015: Paul Fultz II “Reflection Techniques in C++”
Publication date: 2015-10-13
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Reflection is a very powerful and useful feature used in many languages to achieve things like serialization, object-relationship mapping, and general data-driven development. C++ doesn't support reflection natively in the language yet. There are proposals to add compile-time reflection to the language, but C++ has survived all this time without direct support for reflection.

This talk will discuss the various techniques the can be used to achieve reflection including boost fusion, the visitor patter, and do-it-yourself with some macros and metaprogramming. This talk will discuss how these techniques can be used to implement serialization or object-relational mapping.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:06,029
my name is Paul I'm going to be talking

00:00:02,669 --> 00:00:11,040
about reflection and techniques and C++

00:00:06,029 --> 00:00:14,670
so guess starting off kind of the

00:00:11,040 --> 00:00:17,010
question is what is for reflection

00:00:14,670 --> 00:00:19,439
perhaps for people who are not fully

00:00:17,010 --> 00:00:22,080
aware of what reflection does reflection

00:00:19,439 --> 00:00:24,660
essentially is basically introspection

00:00:22,080 --> 00:00:26,400
on types or even you could go even as

00:00:24,660 --> 00:00:30,840
far as introspection on not just the

00:00:26,400 --> 00:00:33,090
types of the the they even est you know

00:00:30,840 --> 00:00:36,090
you could go over classes and functions

00:00:33,090 --> 00:00:37,620
and namespaces but in general most

00:00:36,090 --> 00:00:38,730
people talk about reflection and they're

00:00:37,620 --> 00:00:41,399
usually talking about some kind of

00:00:38,730 --> 00:00:43,410
reflection on the class types finding

00:00:41,399 --> 00:00:46,289
out what kind of members are available

00:00:43,410 --> 00:00:49,730
usually generally it involves you know

00:00:46,289 --> 00:00:53,010
you know numerating over class members

00:00:49,730 --> 00:00:57,840
so like you know iterating over each of

00:00:53,010 --> 00:00:59,399
the class members it is not really most

00:00:57,840 --> 00:01:00,570
people when they refer to reflection

00:00:59,399 --> 00:01:03,270
they're not really referring to a

00:01:00,570 --> 00:01:05,610
predicate based introspection since of

00:01:03,270 --> 00:01:09,150
deciding all whether this class has this

00:01:05,610 --> 00:01:11,010
function foo or not that's already kind

00:01:09,150 --> 00:01:13,860
of pretty much kind of a soft problem in

00:01:11,010 --> 00:01:16,229
C++ for most cases to figure out how to

00:01:13,860 --> 00:01:17,670
do so generally most people when they

00:01:16,229 --> 00:01:19,950
refer to reflection that were flowing to

00:01:17,670 --> 00:01:20,729
more being able to enumerate over each

00:01:19,950 --> 00:01:24,840
of the members

00:01:20,729 --> 00:01:27,869
so essentially what and by being able to

00:01:24,840 --> 00:01:30,540
actually introspect over on the types it

00:01:27,869 --> 00:01:33,360
gives us a way to actually treat our

00:01:30,540 --> 00:01:35,189
data as pure right in as pure C++

00:01:33,360 --> 00:01:36,869
classes which gives an extra level of

00:01:35,189 --> 00:01:40,159
type safety when we're dealing with

00:01:36,869 --> 00:01:43,950
certain data-driven type of applications

00:01:40,159 --> 00:01:45,689
in in C++ were actually in this talk

00:01:43,950 --> 00:01:47,939
here we're gonna actually focus mainly

00:01:45,689 --> 00:01:50,250
on on the reflection Veda at compile

00:01:47,939 --> 00:01:52,799
time meaning we're gonna basically use

00:01:50,250 --> 00:01:55,250
data that's taking the only available at

00:01:52,799 --> 00:01:57,990
compile time we're not gonna worry about

00:01:55,250 --> 00:01:59,899
injecting reflection data into the

00:01:57,990 --> 00:02:02,600
runtime

00:01:59,899 --> 00:02:05,030
and sequels clauses languages designers

00:02:02,600 --> 00:02:07,369
like you pay for what you don't use so a

00:02:05,030 --> 00:02:13,390
general compile time reflection can kind

00:02:07,369 --> 00:02:15,440
of give you that that kind of guarantee

00:02:13,390 --> 00:02:17,450
once you have compiled and right

00:02:15,440 --> 00:02:20,750
reflection you could if you needed the

00:02:17,450 --> 00:02:22,400
one time capability you couldn't go turn

00:02:20,750 --> 00:02:25,190
around and then generate run type of

00:02:22,400 --> 00:02:27,530
data structures at runtime using the

00:02:25,190 --> 00:02:29,870
compile time data but for this talk

00:02:27,530 --> 00:02:32,329
we're just mainly going to focus on the

00:02:29,870 --> 00:02:34,010
compile time data also right now we're

00:02:32,329 --> 00:02:35,390
actually going to use we are going to

00:02:34,010 --> 00:02:38,500
use currents people's clothes features

00:02:35,390 --> 00:02:41,299
but right now currently there's no

00:02:38,500 --> 00:02:43,280
native language feature for reflection

00:02:41,299 --> 00:02:45,230
for C++ so in general and we were gonna

00:02:43,280 --> 00:02:47,750
rely on it we're gonna we're gonna

00:02:45,230 --> 00:02:50,390
actually mostly try to annotate our

00:02:47,750 --> 00:02:53,480
classes with the metadata that we need

00:02:50,390 --> 00:02:55,040
in a way there is a study group that's

00:02:53,480 --> 00:02:56,870
working on a proposal for adding

00:02:55,040 --> 00:02:58,940
reflection of your C++ which will

00:02:56,870 --> 00:03:01,489
actually help in the future to simplify

00:02:58,940 --> 00:03:04,720
a lot of these examples of what we're

00:03:01,489 --> 00:03:08,930
doing so the next thing is to look at is

00:03:04,720 --> 00:03:12,290
uses what are some uses for reflection

00:03:08,930 --> 00:03:14,769
so the first one is serialization like

00:03:12,290 --> 00:03:17,959
say to JSON or XML or some little cat

00:03:14,769 --> 00:03:19,549
kind of format when we do this with a

00:03:17,959 --> 00:03:21,410
reflection in general are going to treat

00:03:19,549 --> 00:03:24,590
like a lot of times you can just treat

00:03:21,410 --> 00:03:27,170
the name of the fields either as like

00:03:24,590 --> 00:03:30,410
object keys for your JSON object or as

00:03:27,170 --> 00:03:34,220
tag names for the XML but that kind of

00:03:30,410 --> 00:03:34,959
can generally helps a lot with us

00:03:34,220 --> 00:03:37,790
Trippier

00:03:34,959 --> 00:03:38,500
your class directly as like almost a

00:03:37,790 --> 00:03:43,240
jinx

00:03:38,500 --> 00:03:45,250
object so and why should look here in

00:03:43,240 --> 00:03:47,440
this talk as a simple example of how we

00:03:45,250 --> 00:03:51,310
can like sterilize it out to an XML

00:03:47,440 --> 00:03:56,709
actually so then as we go even further

00:03:51,310 --> 00:03:59,860
with doing reflection we can also look

00:03:56,709 --> 00:04:01,300
at object relationship mapping to say we

00:03:59,860 --> 00:04:03,490
want to actually represent not just the

00:04:01,300 --> 00:04:05,340
class sterilising out to some kind of

00:04:03,490 --> 00:04:08,350
data format but we can actually look at

00:04:05,340 --> 00:04:11,560
relating it to a table but this actually

00:04:08,350 --> 00:04:13,410
introduces some new things that most

00:04:11,560 --> 00:04:15,940
people don't think about as far as like

00:04:13,410 --> 00:04:17,829
yeah you could treat each you know field

00:04:15,940 --> 00:04:18,640
name is the column in the database but

00:04:17,829 --> 00:04:20,470
there's all these other little

00:04:18,640 --> 00:04:22,930
attributes that you need to know about

00:04:20,470 --> 00:04:25,419
the columns and database like cause this

00:04:22,930 --> 00:04:28,690
a primary key perhaps this only can for

00:04:25,419 --> 00:04:30,340
250 you know string character length

00:04:28,690 --> 00:04:33,370
there's all this or maybe this is a

00:04:30,340 --> 00:04:34,919
foreign key related to the civil class

00:04:33,370 --> 00:04:36,820
so there's all these a little type of

00:04:34,919 --> 00:04:40,210
annotations that you want to be able to

00:04:36,820 --> 00:04:42,550
add about the fields and why don't you

00:04:40,210 --> 00:04:44,530
take a look at an example of possibly

00:04:42,550 --> 00:04:45,940
doing that on a smaller we won't we

00:04:44,530 --> 00:04:47,979
don't implement a full object

00:04:45,940 --> 00:04:50,050
relationship mapping because we don't

00:04:47,979 --> 00:04:52,990
have a full time to do that but we will

00:04:50,050 --> 00:04:54,640
look at on a smart smaller scale smaller

00:04:52,990 --> 00:04:56,800
examples how we can annotate the class

00:04:54,640 --> 00:05:01,120
and even create database tables and

00:04:56,800 --> 00:05:02,680
things like that so even further this

00:05:01,120 --> 00:05:04,540
could actually apply it to any kind of

00:05:02,680 --> 00:05:06,700
general data driven development

00:05:04,540 --> 00:05:09,010
so those are two like well known

00:05:06,700 --> 00:05:10,630
examples of serialization but actually

00:05:09,010 --> 00:05:13,150
can apply to you know you can actually

00:05:10,630 --> 00:05:15,610
create a command line parsing library

00:05:13,150 --> 00:05:18,610
and all of your command line arms are

00:05:15,610 --> 00:05:20,890
fields and a struct or whatever so you

00:05:18,610 --> 00:05:22,570
can kind of even kind of expand out if

00:05:20,890 --> 00:05:25,510
you think of if you think if you

00:05:22,570 --> 00:05:26,700
actually can describe your problem in a

00:05:25,510 --> 00:05:28,770
data-driven way

00:05:26,700 --> 00:05:32,310
and date away that you can now treat

00:05:28,770 --> 00:05:35,760
your your code as data you get extra

00:05:32,310 --> 00:05:38,760
type safety from that so some of the

00:05:35,760 --> 00:05:40,170
techniques we're going to look at we're

00:05:38,760 --> 00:05:43,380
gonna get three different techniques the

00:05:40,170 --> 00:05:45,300
first one is using boost fusion second

00:05:43,380 --> 00:05:47,910
one visitor pattern and then kind of at

00:05:45,300 --> 00:05:49,920
the very end do like a do-it-yourself I

00:05:47,910 --> 00:05:53,400
call it credits you just we're just

00:05:49,920 --> 00:05:55,200
gonna use some some made macros and a

00:05:53,400 --> 00:05:59,930
little bit of meta programming to kind

00:05:55,200 --> 00:06:02,480
of generate the metadata that we want so

00:05:59,930 --> 00:06:04,860
starting off here with boost fusion

00:06:02,480 --> 00:06:07,560
boost fusion is essentially a

00:06:04,860 --> 00:06:09,620
heterogeneous sequence library it's kind

00:06:07,560 --> 00:06:12,510
of way of describing it better is

00:06:09,620 --> 00:06:14,940
generic algorithms for tuples but the

00:06:12,510 --> 00:06:17,280
tuples aren't just stood tuples these

00:06:14,940 --> 00:06:20,400
tuples could it apply to many different

00:06:17,280 --> 00:06:21,990
types of tuples so starting off as a

00:06:20,400 --> 00:06:24,090
simple example of understanding how the

00:06:21,990 --> 00:06:28,580
library works this is kind of an example

00:06:24,090 --> 00:06:30,990
right off of boost boost fusions

00:06:28,580 --> 00:06:32,970
documentation right off their QuickStart

00:06:30,990 --> 00:06:35,490
guide so we you know we can create a

00:06:32,970 --> 00:06:37,290
make tupple and a boost fusion instead

00:06:35,490 --> 00:06:41,490
of calling you still get you actually

00:06:37,290 --> 00:06:44,360
use this at c 0 at C 1 at C to to kind

00:06:41,490 --> 00:06:47,070
of get the index for each of the

00:06:44,360 --> 00:06:48,990
elements in the tupple so that's kind of

00:06:47,070 --> 00:06:51,630
how it works in there but even further

00:06:48,990 --> 00:06:53,610
it's it goes much further than what the

00:06:51,630 --> 00:06:56,250
standard library can do because you have

00:06:53,610 --> 00:06:58,320
algorithms for example like for each so

00:06:56,250 --> 00:07:00,240
say once you wonder your print XML you

00:06:58,320 --> 00:07:03,720
could actually take your original double

00:07:00,240 --> 00:07:06,000
print XML now in this example we're just

00:07:03,720 --> 00:07:08,040
using type ID name like they do in the

00:07:06,000 --> 00:07:11,370
QuickStart guide this is not really a

00:07:08,040 --> 00:07:13,320
portable a fully portable way of doing

00:07:11,370 --> 00:07:14,780
that but it's just for kind of a simple

00:07:13,320 --> 00:07:18,020
illustration purposes

00:07:14,780 --> 00:07:21,230
take a tumble and and iterate over it we

00:07:18,020 --> 00:07:22,940
use the lambda Otto because the auto it

00:07:21,230 --> 00:07:25,790
could be a different type it could be it

00:07:22,940 --> 00:07:31,100
could be a strain so we use the auto

00:07:25,790 --> 00:07:32,600
there for that but we can like boost

00:07:31,100 --> 00:07:35,060
fusion algorithms don't just apply to

00:07:32,600 --> 00:07:38,150
still tuples like I said you can

00:07:35,060 --> 00:07:39,800
actually extend it to many ethyl classes

00:07:38,150 --> 00:07:43,040
and one of the things that are very much

00:07:39,800 --> 00:07:45,470
tough alike of course are strokes so as

00:07:43,040 --> 00:07:47,450
an example boost fusion action provides

00:07:45,470 --> 00:07:48,760
right there it adapts trunk so you can

00:07:47,450 --> 00:07:52,490
actually define your struct and then

00:07:48,760 --> 00:07:54,080
adapt it so then something you can

00:07:52,490 --> 00:07:57,530
actually get this treated and basically

00:07:54,080 --> 00:07:58,880
in inside of boost fusion algorithms but

00:07:57,530 --> 00:08:00,919
even it going further if you don't like

00:07:58,880 --> 00:08:03,050
repeating code boost fusion actually

00:08:00,919 --> 00:08:06,890
provides like a defined stroke so you

00:08:03,050 --> 00:08:08,660
can actually go in and it will actually

00:08:06,890 --> 00:08:12,380
define the struct and adaptive both at

00:08:08,660 --> 00:08:14,800
the same time so so once we actually

00:08:12,380 --> 00:08:17,000
have an adaptive just as a quick example

00:08:14,800 --> 00:08:18,650
we can actually turn around create a

00:08:17,000 --> 00:08:21,950
struct and now we can actually access

00:08:18,650 --> 00:08:23,300
the elements using the @c function so we

00:08:21,950 --> 00:08:25,550
can actually access the first element

00:08:23,300 --> 00:08:26,810
using that seed zero kind of thing and

00:08:25,550 --> 00:08:30,590
then we can even turn around and call

00:08:26,810 --> 00:08:32,750
the print XML function but ideally like

00:08:30,590 --> 00:08:36,469
you saw the problem with reading XML we

00:08:32,750 --> 00:08:38,900
actually want to be able to instead of

00:08:36,469 --> 00:08:41,870
printing out type ID names which is

00:08:38,900 --> 00:08:43,729
which ideally usually the type is done

00:08:41,870 --> 00:08:46,220
what we want to use and also type of

00:08:43,729 --> 00:08:47,960
even that names not portable but ideally

00:08:46,220 --> 00:08:50,810
what we want to use the name so once we

00:08:47,960 --> 00:08:53,360
start adapting it adapting a struct we

00:08:50,810 --> 00:08:56,390
boost Fusion extra grow vines a function

00:08:53,360 --> 00:08:58,040
called struck member name that we can

00:08:56,390 --> 00:08:59,450
actually get the name of each of the

00:08:58,040 --> 00:09:01,430
element so we can call struck number

00:08:59,450 --> 00:09:03,440
name passing the name of the struct and

00:09:01,430 --> 00:09:05,180
then index to it and we can actually

00:09:03,440 --> 00:09:11,110
call the call and it will actually give

00:09:05,180 --> 00:09:11,110
us the member name so yes

00:09:12,850 --> 00:09:19,970
it's not an implementation detail but he

00:09:18,470 --> 00:09:22,149
was asking if it was part of the public

00:09:19,970 --> 00:09:27,790
API are those an implementation detail

00:09:22,149 --> 00:09:27,790
but it's not an implementation detail no

00:09:28,690 --> 00:09:36,410
so now when we're actually giving the

00:09:31,070 --> 00:09:37,519
names we actually besides just getting

00:09:36,410 --> 00:09:39,709
the name information we want to

00:09:37,519 --> 00:09:41,510
basically when we're doing the for each

00:09:39,709 --> 00:09:43,000
we want to basically iterate over it to

00:09:41,510 --> 00:09:44,990
have both the name and the value

00:09:43,000 --> 00:09:47,890
corresponding so what we want to do is

00:09:44,990 --> 00:09:50,690
actually zip those names together with

00:09:47,890 --> 00:09:53,329
their values so essentially kind of what

00:09:50,690 --> 00:09:55,399
we want to do conceptually down at the

00:09:53,329 --> 00:09:58,399
bottom there to show like a student make

00:09:55,399 --> 00:10:01,010
tupple kind of idea of how it would kind

00:09:58,399 --> 00:10:02,089
of look it's not actually gonna be a

00:10:01,010 --> 00:10:03,829
tough old but it's kind of to

00:10:02,089 --> 00:10:05,450
conceptualize kind of how when you zip

00:10:03,829 --> 00:10:06,769
them together how it would look so

00:10:05,450 --> 00:10:08,480
basically you're gonna have a double and

00:10:06,769 --> 00:10:11,089
inside inside of the temple will be

00:10:08,480 --> 00:10:14,110
another tupple that will first port the

00:10:11,089 --> 00:10:16,579
name and then also the strength of the

00:10:14,110 --> 00:10:19,490
I'm sorry the first one of the value and

00:10:16,579 --> 00:10:22,880
then it will harden the name of it so

00:10:19,490 --> 00:10:24,860
you do this we can create a wind names

00:10:22,880 --> 00:10:26,510
function that will actually return us

00:10:24,860 --> 00:10:28,730
back that was if these both things

00:10:26,510 --> 00:10:30,529
together so first to start off we

00:10:28,730 --> 00:10:34,070
actually use first we need to get a

00:10:30,529 --> 00:10:36,260
range of indexes so to do that we can

00:10:34,070 --> 00:10:38,890
actually just use boosted PL range see

00:10:36,260 --> 00:10:41,420
it actually will build us a sequence of

00:10:38,890 --> 00:10:44,329
indexes so we just create index

00:10:41,420 --> 00:10:45,800
sequences from int from zero and then we

00:10:44,329 --> 00:10:48,529
we can actually get the size of the

00:10:45,800 --> 00:10:50,839
struct by calling result of colon colon

00:10:48,529 --> 00:10:53,890
size truck it has to be a result of

00:10:50,839 --> 00:10:56,990
calling colon is kind of a relic of the

00:10:53,890 --> 00:10:58,760
legacy boost fusion but that's what you

00:10:56,990 --> 00:11:00,860
have to do so we call result of colons

00:10:58,760 --> 00:11:04,070
all inside struck and we can get the

00:11:00,860 --> 00:11:05,779
based on the indexes up and call in next

00:11:04,070 --> 00:11:07,850
once we have those will actually

00:11:05,779 --> 00:11:10,550
transform each of those indexes into the

00:11:07,850 --> 00:11:12,440
name so we call transform we pass the

00:11:10,550 --> 00:11:14,400
range into there and then we take our

00:11:12,440 --> 00:11:17,430
index with the

00:11:14,400 --> 00:11:19,310
uses the auto I there and we just call

00:11:17,430 --> 00:11:22,500
that into the struck member name there

00:11:19,310 --> 00:11:24,330
and then that just gives us our names

00:11:22,500 --> 00:11:27,360
and then we zip those two together so

00:11:24,330 --> 00:11:29,279
when we when we have those when we want

00:11:27,360 --> 00:11:32,430
to actually get the value or get the

00:11:29,279 --> 00:11:35,970
name we could use directly that c0 and

00:11:32,430 --> 00:11:39,960
c1 but using magic numbers everywhere in

00:11:35,970 --> 00:11:41,520
general don't usually look quite as

00:11:39,960 --> 00:11:43,380
clear so we can I should make these set

00:11:41,520 --> 00:11:45,089
of functions tax that we can actually

00:11:43,380 --> 00:11:47,910
call instead so once we have one of the

00:11:45,089 --> 00:11:50,820
elements we can call at c0 and that Y

00:11:47,910 --> 00:11:53,940
should return us back the value and that

00:11:50,820 --> 00:11:56,250
c1 which will give us the name so now

00:11:53,940 --> 00:11:57,720
once we have all that in place we can

00:11:56,250 --> 00:11:59,460
actually go back to our print X amount

00:11:57,720 --> 00:12:01,350
function and we can actually start

00:11:59,460 --> 00:12:04,190
implementing it such where we actually

00:12:01,350 --> 00:12:06,930
use the name of the member of fields for

00:12:04,190 --> 00:12:09,060
printing out the XML so in this example

00:12:06,930 --> 00:12:11,490
here we just call for each with the

00:12:09,060 --> 00:12:13,770
names and we can now use get name get

00:12:11,490 --> 00:12:15,570
value or actually get name mainly for

00:12:13,770 --> 00:12:17,339
the tag and so if we run the print x

00:12:15,570 --> 00:12:19,650
amount and we use it with the person

00:12:17,339 --> 00:12:26,120
class we can actually get an output like

00:12:19,650 --> 00:12:29,370
what is shown there at the bottom so now

00:12:26,120 --> 00:12:31,950
going even further with more of what

00:12:29,370 --> 00:12:33,440
boost Fusion is capable of doing boost

00:12:31,950 --> 00:12:35,760
Fusion has this idea of associative

00:12:33,440 --> 00:12:37,860
sequences they're essentially like

00:12:35,760 --> 00:12:41,490
tupple associated tuples in a way

00:12:37,860 --> 00:12:44,220
they're they're pretty much like like in

00:12:41,490 --> 00:12:47,850
some ways like stood mac you know but

00:12:44,220 --> 00:12:49,470
rather than having the keys being some

00:12:47,850 --> 00:12:52,230
kind of value in general the keys are

00:12:49,470 --> 00:12:53,820
actually just the type so by giving it

00:12:52,230 --> 00:12:57,150
that title you can actually look up the

00:12:53,820 --> 00:12:59,310
corresponding value in in the map so we

00:12:57,150 --> 00:13:01,350
can build the fields you know name and a

00:12:59,310 --> 00:13:03,240
in just two different strokes two

00:13:01,350 --> 00:13:04,700
different types for each of those and we

00:13:03,240 --> 00:13:07,350
can actually build them back together

00:13:04,700 --> 00:13:09,210
with using the pair yet

00:13:07,350 --> 00:13:11,660
a future pair to do this and then

00:13:09,210 --> 00:13:15,480
instead of us accessing the fields using

00:13:11,660 --> 00:13:17,790
like at C zero for each one or at C one

00:13:15,480 --> 00:13:20,160
we can actually use actual names for

00:13:17,790 --> 00:13:22,980
them so we can do like at key fields

00:13:20,160 --> 00:13:24,630
name and actually get the name so it is

00:13:22,980 --> 00:13:26,790
a little bit more readable but in

00:13:24,630 --> 00:13:29,010
general you can even just take a stroke

00:13:26,790 --> 00:13:30,960
and you can actually turn around and

00:13:29,010 --> 00:13:33,090
actually still adapt that to an

00:13:30,960 --> 00:13:35,010
associative sequence as well so it has a

00:13:33,090 --> 00:13:36,480
actually has a defined associative

00:13:35,010 --> 00:13:38,970
sequence solar actually defined the

00:13:36,480 --> 00:13:41,220
struct and then we can actually pass in

00:13:38,970 --> 00:13:43,110
what we want the keys to each of those

00:13:41,220 --> 00:13:44,940
structures and this is kind of important

00:13:43,110 --> 00:13:49,130
when we're wanting to actually add

00:13:44,940 --> 00:13:53,970
attributes and at the same time we can

00:13:49,130 --> 00:13:55,260
when we extend the when with what we did

00:13:53,970 --> 00:13:57,180
with the with mains we can actually

00:13:55,260 --> 00:13:58,950
extend it even further and give it the

00:13:57,180 --> 00:14:01,350
key the corresponding key so when we

00:13:58,950 --> 00:14:03,030
adapt it with keeds boost fusion

00:14:01,350 --> 00:14:05,370
actually provides a struct associative

00:14:03,030 --> 00:14:07,170
key that we can go out and query and

00:14:05,370 --> 00:14:10,020
find out what the corresponding key is

00:14:07,170 --> 00:14:11,970
for the struct and so we can basically

00:14:10,020 --> 00:14:14,250
does the same process it takes that

00:14:11,970 --> 00:14:16,830
range transforms it to the keys and then

00:14:14,250 --> 00:14:18,890
it zips those two together or three

00:14:16,830 --> 00:14:22,380
together actually and then we can add

00:14:18,890 --> 00:14:24,420
get key as an extra function for what we

00:14:22,380 --> 00:14:27,750
do and kind of what this is gearing

00:14:24,420 --> 00:14:29,790
towards is being able to have a way that

00:14:27,750 --> 00:14:31,890
we can store attributes so like when

00:14:29,790 --> 00:14:33,630
we're doing like say object relationship

00:14:31,890 --> 00:14:36,540
mapping like I said we want to be able

00:14:33,630 --> 00:14:38,730
to annotate the fields to be able to

00:14:36,540 --> 00:14:40,170
recognize this is a primary key this is

00:14:38,730 --> 00:14:42,090
this has a set of attributes so as a

00:14:40,170 --> 00:14:44,130
simple example here we can actually

00:14:42,090 --> 00:14:47,010
build types that represent certain

00:14:44,130 --> 00:14:50,870
attributes like primary key also max

00:14:47,010 --> 00:14:50,870
length which we actually store as a

00:14:51,860 --> 00:14:57,390
template parameter here and we use the

00:14:54,450 --> 00:14:58,940
max length base base we inherit from

00:14:57,390 --> 00:15:01,200
there so that we can actually have one

00:14:58,940 --> 00:15:02,230
concrete type that we can use the

00:15:01,200 --> 00:15:05,540
recognize the

00:15:02,230 --> 00:15:07,460
so once we have that to actually

00:15:05,540 --> 00:15:09,740
incorporate it into the keys we can just

00:15:07,460 --> 00:15:12,470
inherent so once we have the keys like

00:15:09,740 --> 00:15:14,150
name we want to make name a primary key

00:15:12,470 --> 00:15:16,310
we just inherit from primary key and

00:15:14,150 --> 00:15:18,620
then we also inherit from max linked to

00:15:16,310 --> 00:15:20,840
15th or saying we want a maximum length

00:15:18,620 --> 00:15:22,760
of 250 and then we turn around and we

00:15:20,840 --> 00:15:25,010
can define our associative struck and it

00:15:22,760 --> 00:15:32,810
will actually have the annotations that

00:15:25,010 --> 00:15:35,270
we want all with it so so now we can we

00:15:32,810 --> 00:15:36,650
can annotate our our keys but the next

00:15:35,270 --> 00:15:40,040
thing we need to be able to do is

00:15:36,650 --> 00:15:43,070
actually start checking for attributes

00:15:40,040 --> 00:15:46,070
that we've added in there so because we

00:15:43,070 --> 00:15:47,570
want like a check or has attribute that

00:15:46,070 --> 00:15:49,730
actually check to see if one of the keys

00:15:47,570 --> 00:15:51,800
has attribute we can actually a standard

00:15:49,730 --> 00:15:55,490
library provides his base of that can

00:15:51,800 --> 00:15:57,410
actually tell us ok this this attribute

00:15:55,490 --> 00:15:59,120
or I'm sorry this key inherits from this

00:15:57,410 --> 00:16:01,070
attribute so that's what the has

00:15:59,120 --> 00:16:02,510
attribute function does there and then

00:16:01,070 --> 00:16:04,520
you can see the example at the bottom

00:16:02,510 --> 00:16:06,290
where you can do with primary key

00:16:04,520 --> 00:16:12,590
without and we're trying to true or

00:16:06,290 --> 00:16:14,720
false there now when we start wanting to

00:16:12,590 --> 00:16:18,320
retrieve certain values from the keys

00:16:14,720 --> 00:16:20,330
like say for example we want to be able

00:16:18,320 --> 00:16:22,850
to get what part of the possible max

00:16:20,330 --> 00:16:24,740
length is so if there is a max length

00:16:22,850 --> 00:16:27,080
ideally what we want to do is actually

00:16:24,740 --> 00:16:29,450
return back what max when value is

00:16:27,080 --> 00:16:31,850
specified otherwise maybe where you turn

00:16:29,450 --> 00:16:34,910
back to minus 1 and we just use that as

00:16:31,850 --> 00:16:37,310
kind of a sensible value to know that a

00:16:34,910 --> 00:16:40,580
max length value wasn't set so to be

00:16:37,310 --> 00:16:42,980
able to do that we can't obviously C++

00:16:40,580 --> 00:16:44,720
than have seen it static if to be able

00:16:42,980 --> 00:16:46,700
to easily do that so instead we have to

00:16:44,720 --> 00:16:49,100
be do function overloading so we create

00:16:46,700 --> 00:16:51,350
function overloading for okay when it

00:16:49,100 --> 00:16:53,030
has attribute max length and then we

00:16:51,350 --> 00:16:57,650
make another overload for when it

00:16:53,030 --> 00:17:01,010
doesn't have max length as well and then

00:16:57,650 --> 00:17:04,310
here in the example code I use I use a

00:17:01,010 --> 00:17:06,530
little macro usually to kind of abstract

00:17:04,310 --> 00:17:08,330
out that all been able of craziness

00:17:06,530 --> 00:17:12,680
usually so it makes a little bit neater

00:17:08,330 --> 00:17:14,480
and easier to read I think so now that

00:17:12,680 --> 00:17:16,910
we have all that we can actually start

00:17:14,480 --> 00:17:19,400
looking at maybe creating a database

00:17:16,910 --> 00:17:20,780
table so if we want to create so we can

00:17:19,400 --> 00:17:24,020
create this function that basically will

00:17:20,780 --> 00:17:26,210
spit out what the create table table

00:17:24,020 --> 00:17:28,160
function would be that we could send off

00:17:26,210 --> 00:17:30,710
to a database to actually create the

00:17:28,160 --> 00:17:34,670
corresponding table for a person so in

00:17:30,710 --> 00:17:36,920
this case here it takes the the TX or

00:17:34,670 --> 00:17:38,960
whatever will be the person class in

00:17:36,920 --> 00:17:41,120
this example and then we actually pass

00:17:38,960 --> 00:17:43,190
in a corresponding table name and so

00:17:41,120 --> 00:17:47,390
that we just would iterate over each of

00:17:43,190 --> 00:17:49,340
the each of the elements with the names

00:17:47,390 --> 00:17:51,440
and keys with the fields and then it

00:17:49,340 --> 00:17:54,220
calls the create column field and this

00:17:51,440 --> 00:17:56,990
is kind of where most of the main

00:17:54,220 --> 00:18:00,590
functionality is act so in this example

00:17:56,990 --> 00:18:03,020
here I just take and checked first I

00:18:00,590 --> 00:18:05,480
check to see on is the value convertible

00:18:03,020 --> 00:18:07,940
to a string they say ideally it's just

00:18:05,480 --> 00:18:10,190
like a string type and essentially if it

00:18:07,940 --> 00:18:12,380
is and we want to be able to get a max

00:18:10,190 --> 00:18:14,660
length attribute with it so that we can

00:18:12,380 --> 00:18:15,560
actually print out as an example you

00:18:14,660 --> 00:18:17,690
know char

00:18:15,560 --> 00:18:20,270
whatever amount that you usually do on

00:18:17,690 --> 00:18:23,000
databases or if it doesn't have a max

00:18:20,270 --> 00:18:25,520
like we check max less than 0 then we

00:18:23,000 --> 00:18:28,610
just specify it as text which means it's

00:18:25,520 --> 00:18:30,110
unlimited in them so basically you can

00:18:28,610 --> 00:18:33,760
use that attribute to do that and then

00:18:30,110 --> 00:18:36,710
at the end to right now I use type ID

00:18:33,760 --> 00:18:39,740
for for all the other ones to print out

00:18:36,710 --> 00:18:41,480
the type name ideally if you're doing

00:18:39,740 --> 00:18:43,580
actual object relationship mapping you

00:18:41,480 --> 00:18:46,550
only - should create like a relationship

00:18:43,580 --> 00:18:48,650
between like integers and strings to

00:18:46,550 --> 00:18:51,580
what they're called in the database

00:18:48,650 --> 00:18:53,420
right now I just do type ID name but

00:18:51,580 --> 00:19:16,730
yeah

00:18:53,420 --> 00:19:19,940
Oh Oh this boost you should have a thing

00:19:16,730 --> 00:19:21,740
to do the type IV no boost fusion does

00:19:19,940 --> 00:19:26,510
not have a capability for converting

00:19:21,740 --> 00:19:28,250
like a like a type to a straight so you

00:19:26,510 --> 00:19:31,250
would have to essentially write your own

00:19:28,250 --> 00:19:32,930
kind of mechanism or you could if you're

00:19:31,250 --> 00:19:35,660
using these macros you could build a

00:19:32,930 --> 00:19:45,290
macro on top of it that adds like a you

00:19:35,660 --> 00:19:47,210
know static cops name okay if you use a

00:19:45,290 --> 00:19:48,860
third tuple element well in general

00:19:47,210 --> 00:19:50,740
because it's only the name is actually

00:19:48,860 --> 00:19:53,210
only essentially associated with the

00:19:50,740 --> 00:19:55,010
type and not each of the fields you

00:19:53,210 --> 00:19:57,170
wouldn't associate it with each of the

00:19:55,010 --> 00:19:59,900
fields so rather than we need to find or

00:19:57,170 --> 00:20:03,050
instruct what you can do is just if you

00:19:59,900 --> 00:20:06,080
want to put a name for for that type you

00:20:03,050 --> 00:20:08,120
could do that now I guess you could say

00:20:06,080 --> 00:20:09,620
when you eat for each of the fields for

00:20:08,120 --> 00:20:11,570
the type you have the name of the field

00:20:09,620 --> 00:20:13,430
and then the type of a name but

00:20:11,570 --> 00:20:14,750
essentially because you know the type

00:20:13,430 --> 00:20:16,160
instead it would just be better to

00:20:14,750 --> 00:20:19,700
create a function that would take that

00:20:16,160 --> 00:20:21,170
type and then map it over to yeah some

00:20:19,700 --> 00:20:23,000
kind of type trait that would map that

00:20:21,170 --> 00:20:25,270
over so you could be like okay if it's

00:20:23,000 --> 00:20:28,010
an interval type go ahead and return

00:20:25,270 --> 00:20:31,940
string int you know if it's convertible

00:20:28,010 --> 00:20:37,220
to string return like a string as well

00:20:31,940 --> 00:20:40,100
so that's that's what you should do and

00:20:37,220 --> 00:20:42,440
then we also check for a primary key

00:20:40,100 --> 00:20:44,420
here we get the key check to see if it's

00:20:42,440 --> 00:20:47,030
a primary key and we spit out a primary

00:20:44,420 --> 00:20:49,340
key and this all prints out the like

00:20:47,030 --> 00:20:52,220
sequel statement so here in this example

00:20:49,340 --> 00:20:54,620
here I say I create the person here and

00:20:52,220 --> 00:20:56,900
then I create I call create table here

00:20:54,620 --> 00:20:58,730
and then it from outputs here what's at

00:20:56,900 --> 00:21:01,420
the bottom so who actually call create

00:20:58,730 --> 00:21:04,300
table person

00:21:01,420 --> 00:21:06,730
main charge to 50 now I actually pass in

00:21:04,300 --> 00:21:09,040
the person named in this example here

00:21:06,730 --> 00:21:13,210
like ideally if you wanted to you could

00:21:09,040 --> 00:21:14,980
also add like a static constable that

00:21:13,210 --> 00:21:16,600
stores the name of the table as well if

00:21:14,980 --> 00:21:23,040
you wanted to but in this example I just

00:21:16,600 --> 00:21:25,360
I just passing it so now some

00:21:23,040 --> 00:21:29,170
third-party libraries to actually go

00:21:25,360 --> 00:21:31,720
along with boost fusion the first thing

00:21:29,170 --> 00:21:33,370
there is a library called CPP in that

00:21:31,720 --> 00:21:37,270
actually builds on top of boost fusion

00:21:33,370 --> 00:21:39,220
it uses it actually builds a whole

00:21:37,270 --> 00:21:41,440
entire annotation stuff so like we're

00:21:39,220 --> 00:21:43,810
kind of manually doing the annotations

00:21:41,440 --> 00:21:46,600
ourselves in a lot of ways but CPP n is

00:21:43,810 --> 00:21:48,840
a library that actually does that built

00:21:46,600 --> 00:21:52,930
on boots few can do does the annotation

00:21:48,840 --> 00:21:54,850
another library is boosts Hana that is

00:21:52,930 --> 00:21:56,200
like a modern replacement for a boost

00:21:54,850 --> 00:22:00,010
fusion so if you're using like the

00:21:56,200 --> 00:22:02,770
latest version of claim or GCC you can

00:22:00,010 --> 00:22:04,960
use boost Hana possibly instead you

00:22:02,770 --> 00:22:07,510
might get a little bit of a cleaner

00:22:04,960 --> 00:22:09,730
interfaces in some places and also much

00:22:07,510 --> 00:22:11,020
faster compilation and there's also a

00:22:09,730 --> 00:22:13,480
library I've actually started working on

00:22:11,020 --> 00:22:15,130
hero that was trying to work on for

00:22:13,480 --> 00:22:16,750
portability reasons that would be

00:22:15,130 --> 00:22:24,850
somewhat of a modern replacement for

00:22:16,750 --> 00:22:27,580
poor for boost fusion so so now moving

00:22:24,850 --> 00:22:29,110
on to the visitor pattern this is a

00:22:27,580 --> 00:22:31,960
metal technique that you can use to try

00:22:29,110 --> 00:22:34,660
to annotate your classes with reflection

00:22:31,960 --> 00:22:36,010
data essentially the visitor pattern a

00:22:34,660 --> 00:22:37,950
lot of times it's traditionally

00:22:36,010 --> 00:22:39,970
associated with like using some kind of

00:22:37,950 --> 00:22:41,890
variant type but in this case we're

00:22:39,970 --> 00:22:44,380
actually going to use it to actually be

00:22:41,890 --> 00:22:46,810
able to reflectively go over our data

00:22:44,380 --> 00:22:48,790
structures so essentially we just

00:22:46,810 --> 00:22:50,380
provide like it's essentially a visit

00:22:48,790 --> 00:22:51,850
function that's going to take the

00:22:50,380 --> 00:22:55,120
visitor and it's going to call it for

00:22:51,850 --> 00:22:56,560
each of the member functions usually

00:22:55,120 --> 00:22:57,280
it's a little bit easier to see and

00:22:56,560 --> 00:22:59,710
implement it

00:22:57,280 --> 00:23:01,870
so in general I yeah what good way to

00:22:59,710 --> 00:23:02,830
implement is this I create a strong

00:23:01,870 --> 00:23:06,130
visit

00:23:02,830 --> 00:23:08,230
I actually take in myself and that's a

00:23:06,130 --> 00:23:10,000
first parameter in a function and for

00:23:08,230 --> 00:23:13,929
each of those function I call you know

00:23:10,000 --> 00:23:16,059
named self name age self page now for

00:23:13,929 --> 00:23:18,399
this case I actually use use this as a

00:23:16,059 --> 00:23:20,679
separate function rather than a member

00:23:18,399 --> 00:23:22,779
function because ideally when you do

00:23:20,679 --> 00:23:25,840
visits you want to do visits for cost

00:23:22,779 --> 00:23:27,039
and non-confidence and so essentially if

00:23:25,840 --> 00:23:29,049
you made it a member function you have

00:23:27,039 --> 00:23:30,279
to create two overloads for this instead

00:23:29,049 --> 00:23:36,159
what we're doing is we're just

00:23:30,279 --> 00:23:37,870
templating ourself there and that way we

00:23:36,159 --> 00:23:39,940
can actually use it for both Const and

00:23:37,870 --> 00:23:42,039
non-pilots versions of course by doing

00:23:39,940 --> 00:23:43,899
that that requires a little bit extra

00:23:42,039 --> 00:23:45,940
work by the user to start calling the

00:23:43,899 --> 00:23:48,429
visit so in general it's much easier to

00:23:45,940 --> 00:23:49,659
actually use a visit each function that

00:23:48,429 --> 00:23:51,490
we can actually just call that why

00:23:49,659 --> 00:23:54,279
should go ahead and find the visit

00:23:51,490 --> 00:23:58,120
object that we have and call that now

00:23:54,279 --> 00:24:00,100
unfortunately in C++ we can't just call

00:23:58,120 --> 00:24:03,010
a Cohen because in this example here I

00:24:00,100 --> 00:24:05,350
take the T referent which that T could

00:24:03,010 --> 00:24:08,320
not be a like a regular L value

00:24:05,350 --> 00:24:10,299
reference so because of that if it's a

00:24:08,320 --> 00:24:12,010
referent if T's a reference and they're

00:24:10,299 --> 00:24:14,649
trying to call colon colon on it see

00:24:12,010 --> 00:24:17,320
those posters I'm allowing it there's a

00:24:14,649 --> 00:24:18,970
fit so what you have to do first is you

00:24:17,320 --> 00:24:21,039
have to basically remove all over the

00:24:18,970 --> 00:24:22,779
references or if you it has a constant

00:24:21,039 --> 00:24:23,950
on it remove the comments off of it so

00:24:22,779 --> 00:24:29,860
that's what the first line basically

00:24:23,950 --> 00:24:32,380
essentially does yes oh could I just use

00:24:29,860 --> 00:24:35,289
the K not necessarily because the K can

00:24:32,380 --> 00:24:37,389
actually decay to pointers well I guess

00:24:35,289 --> 00:24:38,830
in this case it wouldn't matter but but

00:24:37,389 --> 00:24:41,880
decay does a bunch of other stuff too

00:24:38,830 --> 00:24:44,559
besides just removing references so

00:24:41,880 --> 00:24:46,899
that's why I just used that this instead

00:24:44,559 --> 00:24:48,850
so that's what I am using care remove

00:24:46,899 --> 00:24:51,130
the references it removes any console a

00:24:48,850 --> 00:24:53,470
little keywords so that that way I can

00:24:51,130 --> 00:24:55,210
actually do a colon colon visit and get

00:24:53,470 --> 00:24:57,909
the visit object I call the visit object

00:24:55,210 --> 00:25:00,610
then I pass myself back basically into

00:24:57,909 --> 00:25:03,789
it and I can pass the function into it

00:25:00,610 --> 00:25:06,639
as well so once we do this we can

00:25:03,789 --> 00:25:07,700
actually go back and revisit our print

00:25:06,639 --> 00:25:11,240
XML

00:25:07,700 --> 00:25:13,100
so basically in this case here what

00:25:11,240 --> 00:25:15,110
instead of just taking one element in

00:25:13,100 --> 00:25:17,149
here we'll actually take a name in a

00:25:15,110 --> 00:25:20,720
variable and the variable is auto

00:25:17,149 --> 00:25:22,639
because it can represent various types

00:25:20,720 --> 00:25:24,889
of training integer whatever and so

00:25:22,639 --> 00:25:29,590
there now we just we can serialize it

00:25:24,889 --> 00:25:33,379
out using name bar pretty simple right

00:25:29,590 --> 00:25:35,179
so next what we would like to be able to

00:25:33,379 --> 00:25:37,279
do is have attributes like we did before

00:25:35,179 --> 00:25:38,600
in this case when we define our

00:25:37,279 --> 00:25:40,700
attribute is in the visitor pattern

00:25:38,600 --> 00:25:42,980
we're not actually going to attach it to

00:25:40,700 --> 00:25:51,379
type so we actually have something a

00:25:42,980 --> 00:25:54,940
little bit simpler to do yeah so

00:25:51,379 --> 00:25:59,809
basically what we do here is we

00:25:54,940 --> 00:26:01,100
basically call the so basically we

00:25:59,809 --> 00:26:02,929
stored the link from can just store it

00:26:01,100 --> 00:26:10,399
as a regular member variable here we

00:26:02,929 --> 00:26:11,720
have the primary key so now when we want

00:26:10,399 --> 00:26:13,820
to be able to use those attributes we

00:26:11,720 --> 00:26:16,999
can just add them as extra parameters

00:26:13,820 --> 00:26:20,659
onto the function so max aleene's

00:26:16,999 --> 00:26:23,389
primary key there but by doing that we

00:26:20,659 --> 00:26:25,220
actually need to update our xml - we

00:26:23,389 --> 00:26:28,940
might have possibly extra parameters

00:26:25,220 --> 00:26:31,999
there so we can add an attribute that

00:26:28,940 --> 00:26:41,749
takes in a possible number of extra

00:26:31,999 --> 00:26:43,190
attributes so yeah so yeah so so like I

00:26:41,749 --> 00:26:46,879
skipped a bunch of slides for some

00:26:43,190 --> 00:26:49,159
reason oh no I did okay okay so yeah so

00:26:46,879 --> 00:26:52,970
that da-da-da is very number of

00:26:49,159 --> 00:26:54,320
parameters we which for the case when

00:26:52,970 --> 00:26:56,029
you don't have any attributes it just

00:26:54,320 --> 00:26:57,640
gets ignored this case we're not using

00:26:56,029 --> 00:27:00,240
attributes but it still needs to be

00:26:57,640 --> 00:27:03,520
because the user might action estimate

00:27:00,240 --> 00:27:05,950
now if they do pass in a bunch of

00:27:03,520 --> 00:27:07,120
attributes you could rely on okay each

00:27:05,950 --> 00:27:08,920
of these attributes have to go in

00:27:07,120 --> 00:27:10,900
certain order when you're using primary

00:27:08,920 --> 00:27:12,640
key you're not using primary key you

00:27:10,900 --> 00:27:14,020
might need to put in order but rather it

00:27:12,640 --> 00:27:16,630
would be much better to search through

00:27:14,020 --> 00:27:18,790
all of those attributes and find out

00:27:16,630 --> 00:27:20,200
which ones the primary key so to do that

00:27:18,790 --> 00:27:22,030
you can use these three different

00:27:20,200 --> 00:27:24,520
overloads it's actually search for a

00:27:22,030 --> 00:27:26,740
primary key so in this case we say all

00:27:24,520 --> 00:27:28,480
this primary key we find the first one

00:27:26,740 --> 00:27:30,070
it's a primary key so we're just going

00:27:28,480 --> 00:27:32,140
to return true all right we don't care

00:27:30,070 --> 00:27:34,030
what the rest of the T's are right for

00:27:32,140 --> 00:27:36,309
the second case which is completely

00:27:34,030 --> 00:27:38,350
empty and in find a primary key at all

00:27:36,309 --> 00:27:40,660
so we return false and then for another

00:27:38,350 --> 00:27:42,850
for the the last case is for when it's

00:27:40,660 --> 00:27:44,740
not it the first type is not obviously

00:27:42,850 --> 00:27:46,840
the primary key but the rest of the T's

00:27:44,740 --> 00:27:48,190
could be a primary key we go ahead and

00:27:46,840 --> 00:27:50,110
call it recursively so it kind of does

00:27:48,190 --> 00:27:51,610
this laying head tell type of recursion

00:27:50,110 --> 00:27:54,400
that's kind of familiar with like

00:27:51,610 --> 00:27:55,840
functional programming so and you can

00:27:54,400 --> 00:27:58,179
use that to search for the primary key

00:27:55,840 --> 00:27:59,860
the same process can happen with the get

00:27:58,179 --> 00:28:01,720
max length in this case we're not just

00:27:59,860 --> 00:28:03,460
returning turn false but in this case

00:28:01,720 --> 00:28:05,049
we're actually returning back the xpac

00:28:03,460 --> 00:28:07,660
link that you stored in the object and

00:28:05,049 --> 00:28:11,140
if it's not found we return basically

00:28:07,660 --> 00:28:13,809
minus one so then we can actually go

00:28:11,140 --> 00:28:17,020
back and look at our create table

00:28:13,809 --> 00:28:19,120
function basically in the create table

00:28:17,020 --> 00:28:21,520
we basically take that number of

00:28:19,120 --> 00:28:23,410
attributes and basically the mean of the

00:28:21,520 --> 00:28:25,780
operation actually is going to be

00:28:23,410 --> 00:28:28,270
created column right so in the create

00:28:25,780 --> 00:28:29,440
column we actually do do the same kind

00:28:28,270 --> 00:28:31,690
of process check to see if it's

00:28:29,440 --> 00:28:33,970
convertible to string we call get max

00:28:31,690 --> 00:28:36,340
length but we do attributes dot dot

00:28:33,970 --> 00:28:38,710
because they're there many number of

00:28:36,340 --> 00:28:40,240
attributes so we pass in all those

00:28:38,710 --> 00:28:41,710
attributes in there and it will

00:28:40,240 --> 00:28:43,180
basically search over it find a max

00:28:41,710 --> 00:28:45,820
length and give us what that nice like

00:28:43,180 --> 00:28:47,500
this if it is found otherwise minus one

00:28:45,820 --> 00:28:50,140
and something we vets it's the same

00:28:47,500 --> 00:28:51,940
process print out text or chart and at

00:28:50,140 --> 00:28:54,400
the same time for we do the same thing

00:28:51,940 --> 00:29:00,460
for the is primary key attributes dot

00:28:54,400 --> 00:29:03,370
dot dot dot so now moving onto something

00:29:00,460 --> 00:29:05,170
else you can do with visitors is there's

00:29:03,370 --> 00:29:07,330
many times when you you have visitors

00:29:05,170 --> 00:29:09,330
and you have all these attributes you

00:29:07,330 --> 00:29:11,320
may sometimes want to only visit certain

00:29:09,330 --> 00:29:13,810
certain overloads that have certain

00:29:11,320 --> 00:29:16,180
attributes as an example like I have in

00:29:13,810 --> 00:29:18,340
the slides as visiting just the ones

00:29:16,180 --> 00:29:20,290
that have the primary key attribute so

00:29:18,340 --> 00:29:23,260
this could be very possible when you're

00:29:20,290 --> 00:29:26,320
running and or and that you want to do

00:29:23,260 --> 00:29:28,420
something like you get you you call out

00:29:26,320 --> 00:29:30,700
you create you insert the new data into

00:29:28,420 --> 00:29:32,740
the the database and then you actually

00:29:30,700 --> 00:29:34,840
get a response back what that primary

00:29:32,740 --> 00:29:35,950
key is supposed to be what it is

00:29:34,840 --> 00:29:38,230
especially if the primary keys are

00:29:35,950 --> 00:29:42,970
harder and generated by the database so

00:29:38,230 --> 00:29:45,790
what this does is it a basic just a

00:29:42,970 --> 00:29:48,160
basis selects only the elements that

00:29:45,790 --> 00:29:51,580
have the primary key attribute and then

00:29:48,160 --> 00:29:53,560
it gives you the name the value and then

00:29:51,580 --> 00:29:55,390
also the attribute that you asked for

00:29:53,560 --> 00:29:56,920
so like you can also use it for other

00:29:55,390 --> 00:29:58,090
cases besides just the primary key the

00:29:56,920 --> 00:29:59,920
primary key doesn't actually store any

00:29:58,090 --> 00:30:01,450
data but if you had other cases where

00:29:59,920 --> 00:30:06,940
you wanted to select certain visits and

00:30:01,450 --> 00:30:08,680
they had like and they had like data

00:30:06,940 --> 00:30:10,840
stored in those attributes you could

00:30:08,680 --> 00:30:12,970
actually visit those especially if you

00:30:10,840 --> 00:30:15,280
in a more large or very driven

00:30:12,970 --> 00:30:17,140
environment you may actually use that to

00:30:15,280 --> 00:30:19,120
be like okay only these attributes I

00:30:17,140 --> 00:30:20,580
have this I'm going to serialize out to

00:30:19,120 --> 00:30:23,490
here the other ones I'm mister

00:30:20,580 --> 00:30:24,929
to someplace else so that's kind of what

00:30:23,490 --> 00:30:27,899
the visit selects so we'll actually look

00:30:24,929 --> 00:30:30,000
at how you go about doing this visit

00:30:27,899 --> 00:30:31,860
select so in this example here yeah we

00:30:30,000 --> 00:30:34,590
basically only print out at the bottom

00:30:31,860 --> 00:30:38,760
their name Tom because the name is the

00:30:34,590 --> 00:30:40,529
primary key so basically we can actually

00:30:38,760 --> 00:30:42,210
take what we were doing before a little

00:30:40,529 --> 00:30:45,330
researching for an attribute and try to

00:30:42,210 --> 00:30:49,169
do it in a more generic way so we start

00:30:45,330 --> 00:30:51,269
off we declare a not found struck that

00:30:49,169 --> 00:30:53,490
basis it's gonna signify that we didn't

00:30:51,269 --> 00:30:56,220
find an attribute and then inside the

00:30:53,490 --> 00:30:58,350
attribute finder class it takes an

00:30:56,220 --> 00:30:59,730
attribute as a template parameter and

00:30:58,350 --> 00:31:01,830
that's the attribute we're going to be

00:30:59,730 --> 00:31:03,600
searching for and so basically we do the

00:31:01,830 --> 00:31:06,440
three call overloads like we're doing

00:31:03,600 --> 00:31:09,750
before and we actually search through

00:31:06,440 --> 00:31:11,820
all of them and try to find that same

00:31:09,750 --> 00:31:13,350
attribute if the attributes found they I

00:31:11,820 --> 00:31:15,059
should return the entropy if the

00:31:13,350 --> 00:31:19,230
attribute is not found make sure we turn

00:31:15,059 --> 00:31:23,279
back our special not found struck that

00:31:19,230 --> 00:31:24,840
we created now now C++ because it

00:31:23,279 --> 00:31:27,360
doesn't have static if we can't just be

00:31:24,840 --> 00:31:29,220
like okay now if it's if it's not found

00:31:27,360 --> 00:31:31,110
that should be do this otherwise do what

00:31:29,220 --> 00:31:33,480
we wanted to do so we can't we can't

00:31:31,110 --> 00:31:35,700
really do that directly in C++ so we

00:31:33,480 --> 00:31:38,039
have to use functionality so one way we

00:31:35,700 --> 00:31:40,740
can do this is just overload based upon

00:31:38,039 --> 00:31:43,169
the time so if the attributes found and

00:31:40,740 --> 00:31:45,179
we take an attribute and we take a

00:31:43,169 --> 00:31:46,200
function so basically if the attributes

00:31:45,179 --> 00:31:49,320
found we go ahead and return the

00:31:46,200 --> 00:31:51,570
function right if on the overload and

00:31:49,320 --> 00:31:53,190
it's actually not found we actually

00:31:51,570 --> 00:31:55,260
don't return the function instead we

00:31:53,190 --> 00:31:58,260
just return a special function that does

00:31:55,260 --> 00:32:04,880
nothing so basically ends up basically

00:31:58,260 --> 00:32:07,740
turning that into dead code right so so

00:32:04,880 --> 00:32:09,570
putting it together for like if we want

00:32:07,740 --> 00:32:15,360
to implement visit select we can

00:32:09,570 --> 00:32:17,549
actually take in the attributes we call

00:32:15,360 --> 00:32:19,649
our actually be finder that then

00:32:17,549 --> 00:32:21,450
searches and finds the attribute and

00:32:19,649 --> 00:32:24,330
then we say if found on that attribute

00:32:21,450 --> 00:32:25,740
passing the user-provided function that

00:32:24,330 --> 00:32:27,450
they want to be called for that

00:32:25,740 --> 00:32:29,760
attribute and then we pass on the name

00:32:27,450 --> 00:32:31,559
bar and that single attribute now if

00:32:29,760 --> 00:32:33,960
it's a not found that function won't be

00:32:31,559 --> 00:32:36,149
called at all if it is found it oh I

00:32:33,960 --> 00:32:38,190
should call a function with the name the

00:32:36,149 --> 00:32:39,600
variable in that attribute so then that

00:32:38,190 --> 00:32:42,690
way you can actually select only certain

00:32:39,600 --> 00:32:47,600
visits that you want to do and that's

00:32:42,690 --> 00:32:47,600
kind of how the visitor pattern works so

00:32:47,630 --> 00:32:56,010
now finally the last thing here is the

00:32:53,490 --> 00:32:57,590
do it I call it the do-it-yourself what

00:32:56,010 --> 00:32:59,520
was really the best name for it but

00:32:57,590 --> 00:33:01,409
essentially what we're going to do is

00:32:59,520 --> 00:33:03,450
we're actually going to create our own

00:33:01,409 --> 00:33:07,820
macro called reflectable

00:33:03,450 --> 00:33:07,820
yes oh yeah

00:33:22,640 --> 00:33:31,210
it's just red light so why was it figure

00:33:27,920 --> 00:33:31,210
out why but why

00:33:32,000 --> 00:33:37,250
that's just a 14 rep he's asking the

00:33:35,240 --> 00:33:39,710
question why they only have to use the

00:33:37,250 --> 00:33:41,059
auto ref ref it's just kind of a habit

00:33:39,710 --> 00:33:43,370
because I just want to take something

00:33:41,059 --> 00:33:45,530
when use the auto ref ref that's usually

00:33:43,370 --> 00:33:47,360
usually uses that use that to signify

00:33:45,530 --> 00:33:50,030
that you want to take anything that's a

00:33:47,360 --> 00:33:51,950
reference right is when generally when

00:33:50,030 --> 00:33:53,510
you want to use an auto ref ref so you

00:33:51,950 --> 00:33:55,610
use auto when you always want to take by

00:33:53,510 --> 00:33:57,530
value use auto ref ref when you want to

00:33:55,610 --> 00:33:59,120
take my reference and so I don't really

00:33:57,530 --> 00:34:01,130
care what the reference is because I'm

00:33:59,120 --> 00:34:02,840
not gonna do anything with it I mean yes

00:34:01,130 --> 00:34:05,030
later on and the code actually I'm just

00:34:02,840 --> 00:34:07,190
passing a car's reference so that is

00:34:05,030 --> 00:34:09,710
possible to do is a cantata ref as well

00:34:07,190 --> 00:34:11,540
but in general I just use a home

00:34:09,710 --> 00:34:18,350
reference meaning take a reference to

00:34:11,540 --> 00:34:24,620
anything so good question so now the do

00:34:18,350 --> 00:34:26,300
it yourself with the reflectable macro

00:34:24,620 --> 00:34:29,590
here what we're gonna do is create a

00:34:26,300 --> 00:34:31,970
little macro to do this now I don't know

00:34:29,590 --> 00:34:33,350
basically this is going to take the

00:34:31,970 --> 00:34:35,389
basically you just list out your types

00:34:33,350 --> 00:34:37,879
here and where I should put the types in

00:34:35,389 --> 00:34:41,210
parentheses so I should look at kind of

00:34:37,879 --> 00:34:43,100
a way of doing it and the way when you

00:34:41,210 --> 00:34:47,139
put your type in round parenthesis I

00:34:43,100 --> 00:34:50,030
actually call that a tight expression so

00:34:47,139 --> 00:34:52,310
essentially what we want some utilities

00:34:50,030 --> 00:34:54,260
to kind of handle the type expression so

00:34:52,310 --> 00:34:56,510
these are some basic macros called a

00:34:54,260 --> 00:35:00,200
strip and pair basically what strip does

00:34:56,510 --> 00:35:02,270
is it basically will strip off that that

00:35:00,200 --> 00:35:04,220
like at the bottom there you see the

00:35:02,270 --> 00:35:05,810
parentheses int it would strip off the

00:35:04,220 --> 00:35:08,270
parentheses int and it leaves you with

00:35:05,810 --> 00:35:10,040
just acts right and in the case of and

00:35:08,270 --> 00:35:12,530
so you use that like when you need to

00:35:10,040 --> 00:35:13,820
you you need another variable type but

00:35:12,530 --> 00:35:16,970
there's other times like we want to be

00:35:13,820 --> 00:35:18,890
able to actually declare the the field

00:35:16,970 --> 00:35:21,620
itself so we don't we can't declare it

00:35:18,890 --> 00:35:23,750
as in you know parentheses and X so we

00:35:21,620 --> 00:35:26,150
need to declare it as an X so for that

00:35:23,750 --> 00:35:28,130
case we use pair and what pair does is

00:35:26,150 --> 00:35:29,720
basically remove off those parentheses

00:35:28,130 --> 00:35:32,840
off the in and we just left with the

00:35:29,720 --> 00:35:37,180
index so that's basically how that works

00:35:32,840 --> 00:35:37,180
of course we still need a few more macro

00:35:37,850 --> 00:35:44,360
here so we start off here with a in nrx

00:35:42,800 --> 00:35:46,460
macro the basement just kind of counts

00:35:44,360 --> 00:35:48,410
out the number of arguments there this

00:35:46,460 --> 00:35:50,720
actually counts it up to eight and then

00:35:48,410 --> 00:35:53,060
we use it kind of like a simple pattern

00:35:50,720 --> 00:35:55,610
matching for each of those up to eight

00:35:53,060 --> 00:35:58,610
so we basically say okay we take each

00:35:55,610 --> 00:36:00,620
takes a macro and it takes a very deep a

00:35:58,610 --> 00:36:02,390
demons and if it's you know if it has

00:36:00,620 --> 00:36:04,130
one it calls it for the first argument

00:36:02,390 --> 00:36:05,600
if it has two it calls it for each

00:36:04,130 --> 00:36:07,670
argument for each both of those

00:36:05,600 --> 00:36:08,690
arguments all the way up to eight so

00:36:07,670 --> 00:36:11,090
it's just kind of like a repetitive

00:36:08,690 --> 00:36:12,590
thing and you can use to call up two to

00:36:11,090 --> 00:36:17,360
apply a macro to go to those arguments

00:36:12,590 --> 00:36:20,420
so that's how that works also we need a

00:36:17,360 --> 00:36:21,890
way to actually enumerate them so and

00:36:20,420 --> 00:36:23,840
what I mean by enumerate is we want to

00:36:21,890 --> 00:36:25,100
be able to when we call each of those we

00:36:23,840 --> 00:36:27,080
can actually stick a comma in between

00:36:25,100 --> 00:36:28,850
them so when we want to pass them on to

00:36:27,080 --> 00:36:30,050
like in that little function are you

00:36:28,850 --> 00:36:32,420
giving it we want to actually put a

00:36:30,050 --> 00:36:34,040
comma in there so the first thing we

00:36:32,420 --> 00:36:36,950
have is we have this common thing that

00:36:34,040 --> 00:36:39,290
why should prepend a comma on to the

00:36:36,950 --> 00:36:42,920
front of the macro then if you look at

00:36:39,290 --> 00:36:44,300
the email macro it calls each right but

00:36:42,920 --> 00:36:45,980
it actually changed it calls up with

00:36:44,300 --> 00:36:48,350
that comma macro so it pretends that

00:36:45,980 --> 00:36:50,510
macro into the front of what we're doing

00:36:48,350 --> 00:36:52,400
but when we do that obviously because

00:36:50,510 --> 00:36:56,720
we're prepend in a macro to each single

00:36:52,400 --> 00:36:59,420
element it ends up adding an extra

00:36:56,720 --> 00:37:01,370
argument on to the first of the this in

00:36:59,420 --> 00:37:02,390
the front of the list right so we kind

00:37:01,370 --> 00:37:05,120
of want to get rid of that first

00:37:02,390 --> 00:37:07,490
argument so that's why where the tail

00:37:05,120 --> 00:37:08,930
comes in and tail basically just ignores

00:37:07,490 --> 00:37:11,570
off the first of the argument and then

00:37:08,930 --> 00:37:15,550
gives us Socktober also we need a way to

00:37:11,570 --> 00:37:17,930
actually string the size the arguments

00:37:15,550 --> 00:37:19,520
regular you can use the power like pound

00:37:17,930 --> 00:37:21,440
x right there like you see in the

00:37:19,520 --> 00:37:23,180
strings on the feminist string size that

00:37:21,440 --> 00:37:26,270
will actually turn in that token into a

00:37:23,180 --> 00:37:28,970
string right but because we're actually

00:37:26,270 --> 00:37:30,410
calling it from another macro blankie it

00:37:28,970 --> 00:37:30,940
won't it will actually string a size of

00:37:30,410 --> 00:37:32,559
the Mac

00:37:30,940 --> 00:37:34,059
we're passing in so instead we just

00:37:32,559 --> 00:37:35,530
spilled through a separate in direction

00:37:34,059 --> 00:37:36,849
of this what the string size does goes

00:37:35,530 --> 00:37:40,660
their separate direction and then

00:37:36,849 --> 00:37:42,970
converts in its history so here's how we

00:37:40,660 --> 00:37:44,859
can start writing with these utilities

00:37:42,970 --> 00:37:50,049
here's how we can start writing the

00:37:44,859 --> 00:37:52,270
reflectable macro essentially so we

00:37:50,049 --> 00:37:53,530
first call each with a memory child show

00:37:52,270 --> 00:37:55,180
on the next slide what the memory each

00:37:53,530 --> 00:37:56,770
does but basically that line is

00:37:55,180 --> 00:38:01,270
basically they declare each of the

00:37:56,770 --> 00:38:04,059
members in the into the struck the the

00:38:01,270 --> 00:38:06,609
next part is we actually declare a

00:38:04,059 --> 00:38:08,170
struct called unpacked and inside there

00:38:06,609 --> 00:38:10,930
we have an apply function that will take

00:38:08,170 --> 00:38:13,270
itself and it will take a function and

00:38:10,930 --> 00:38:15,160
for each of those function for that

00:38:13,270 --> 00:38:17,230
function basically essentially will

00:38:15,160 --> 00:38:19,390
actually call each of the elements there

00:38:17,230 --> 00:38:20,829
but we actually want to not just call

00:38:19,390 --> 00:38:24,220
each of the elements there we actually

00:38:20,829 --> 00:38:26,500
want to actually have them name itself

00:38:24,220 --> 00:38:29,170
and we'll show in that unpacked each how

00:38:26,500 --> 00:38:30,940
we actually store it into a pair so the

00:38:29,170 --> 00:38:34,359
next one you can see here when I do

00:38:30,940 --> 00:38:36,490
remember each we call pair X semicolon

00:38:34,359 --> 00:38:38,559
so it basically declares it as a member

00:38:36,490 --> 00:38:41,650
variable and then for the other one for

00:38:38,559 --> 00:38:44,109
the unpackage it basically calls a good

00:38:41,650 --> 00:38:45,730
pair and stuff so that first the first

00:38:44,109 --> 00:38:48,010
part was going to be the name so we

00:38:45,730 --> 00:38:49,539
string the size of the name the strip X

00:38:48,010 --> 00:38:51,520
which will give us the name of that

00:38:49,539 --> 00:38:53,980
field and then the second part will just

00:38:51,520 --> 00:38:57,309
be self dot strip X that will give us

00:38:53,980 --> 00:39:01,660
the that will actually access the field

00:38:57,309 --> 00:39:03,670
in the class so finally putting it

00:39:01,660 --> 00:39:07,240
finally together we can actually call we

00:39:03,670 --> 00:39:11,470
carry our own for each function that we

00:39:07,240 --> 00:39:13,210
can actually use to basically iterate

00:39:11,470 --> 00:39:15,520
over all the elements that we've

00:39:13,210 --> 00:39:17,230
actually set up so basically that works

00:39:15,520 --> 00:39:19,420
we use the similar case like we did

00:39:17,230 --> 00:39:22,240
before where we had to use the remove

00:39:19,420 --> 00:39:24,000
cons because we because we can't call

00:39:22,240 --> 00:39:26,340
the scope operator on something

00:39:24,000 --> 00:39:28,950
the reference so we do that we call

00:39:26,340 --> 00:39:31,470
apply and then we pass in our lamda that

00:39:28,950 --> 00:39:33,570
takes all the different elements that

00:39:31,470 --> 00:39:35,400
are in that struct all together and

00:39:33,570 --> 00:39:38,040
wants but we want to actually apply that

00:39:35,400 --> 00:39:41,250
function to each of those arguments so

00:39:38,040 --> 00:39:43,050
this actually uses a thing from actually

00:39:41,250 --> 00:39:44,880
I think Shawn parent you tweeted

00:39:43,050 --> 00:39:48,630
something very similar to this where we

00:39:44,880 --> 00:39:51,630
actually okay okay here's a tough on

00:39:48,630 --> 00:39:55,410
that on Thursday but it basically

00:39:51,630 --> 00:39:57,270
basically we expand we expand when you

00:39:55,410 --> 00:40:00,410
call the dot dot dot we're gonna expand

00:39:57,270 --> 00:40:03,540
each of those that that function call

00:40:00,410 --> 00:40:05,790
for each of those XS so it would

00:40:03,540 --> 00:40:09,570
actually call that function for each of

00:40:05,790 --> 00:40:11,490
those and then we actually put it in the

00:40:09,570 --> 00:40:14,430
initializer list and the reason for this

00:40:11,490 --> 00:40:16,920
is because when we by default

00:40:14,430 --> 00:40:18,540
you can't insure the ordering for each

00:40:16,920 --> 00:40:19,860
of these functions by default if you try

00:40:18,540 --> 00:40:22,860
to pass it on to like a regular function

00:40:19,860 --> 00:40:24,780
but inside of initializer list you're

00:40:22,860 --> 00:40:27,720
actually guaranteed that it's going to

00:40:24,780 --> 00:40:29,670
be from left to right so that's why it

00:40:27,720 --> 00:40:31,530
goes into the initializer list and since

00:40:29,670 --> 00:40:33,900
the initializer list only takes integers

00:40:31,530 --> 00:40:36,210
that's why at the end that you come at

00:40:33,900 --> 00:40:38,220
the zero there so it basically converts

00:40:36,210 --> 00:40:40,110
it to basically energy the result of

00:40:38,220 --> 00:40:42,270
that function to an integer and it only

00:40:40,110 --> 00:40:43,590
puts a bunch of zeros in there but it

00:40:42,270 --> 00:40:45,620
has the side effect of calling you to

00:40:43,590 --> 00:40:47,550
the functions from left to right so

00:40:45,620 --> 00:40:49,380
essentially by doing that we can

00:40:47,550 --> 00:40:50,790
actually now have a for each function

00:40:49,380 --> 00:40:53,400
that we can I should call for each of

00:40:50,790 --> 00:40:55,800
our elements and we can actually then

00:40:53,400 --> 00:40:58,050
actually implement print X amount like

00:40:55,800 --> 00:40:59,640
we did or the other example so we we

00:40:58,050 --> 00:41:02,580
call print X and now we call our for

00:40:59,640 --> 00:41:04,170
each on it and we can basically do data

00:41:02,580 --> 00:41:06,360
dot first will actually give us the name

00:41:04,170 --> 00:41:09,780
and then data that second Y should give

00:41:06,360 --> 00:41:14,030
us the value that's associated with it

00:41:09,780 --> 00:41:14,030
so that's

00:41:22,970 --> 00:41:27,290
we have time for about one question

00:41:40,790 --> 00:41:47,360
so which of these solutions and where

00:41:43,580 --> 00:41:49,460
have you being used before the last

00:41:47,360 --> 00:41:53,150
solution I've never really used that

00:41:49,460 --> 00:41:55,250
much but I use the variant of that at

00:41:53,150 --> 00:41:57,170
one point to be actually develop it

00:41:55,250 --> 00:41:58,970
using so that actually supported like

00:41:57,170 --> 00:42:01,640
Gators and setters and things like that

00:41:58,970 --> 00:42:03,680
using kind of a similar ease of similar

00:42:01,640 --> 00:42:07,790
kind of thing that how cute properties

00:42:03,680 --> 00:42:10,160
worked but in general I kind of tend

00:42:07,790 --> 00:42:12,530
towards using like boost fusion in the

00:42:10,160 --> 00:42:14,660
visitor pattern so if you're able to use

00:42:12,530 --> 00:42:16,670
boost or how the library is kind of like

00:42:14,660 --> 00:42:17,960
boost Hanan or boost hannah if you're

00:42:16,670 --> 00:42:19,850
able to use those library it's better to

00:42:17,960 --> 00:42:21,710
kind of tend towards using a library

00:42:19,850 --> 00:42:23,990
based solution but if you're in a place

00:42:21,710 --> 00:42:25,700
it's like okay we can't we don't have

00:42:23,990 --> 00:42:27,680
those we don't want to we don't need a

00:42:25,700 --> 00:42:29,000
dependency on boost and then sometimes

00:42:27,680 --> 00:42:30,290
it's actually better to lean towards

00:42:29,000 --> 00:42:32,090
using the desert pattern it's actually

00:42:30,290 --> 00:42:34,820
fairly simple to write it just uses

00:42:32,090 --> 00:42:39,260
basic C++ doesn't have any make a major

00:42:34,820 --> 00:42:42,230
library dependencies just a simple

00:42:39,260 --> 00:42:44,150
question I've used QT and the mock birth

00:42:42,230 --> 00:42:45,590
reflection capabilities in the past you

00:42:44,150 --> 00:42:47,360
haven't really mentioned on that I was

00:42:45,590 --> 00:42:48,770
just curious if how that compares in

00:42:47,360 --> 00:42:52,610
your mind to what you discussed this

00:42:48,770 --> 00:42:54,710
today oh yeah yeah there's QT that does

00:42:52,610 --> 00:42:57,440
that it's actually what we're I was kind

00:42:54,710 --> 00:43:00,710
of focusing on more of is compile time

00:42:57,440 --> 00:43:02,810
base reflection cuties Mach is actually

00:43:00,710 --> 00:43:04,910
more of a runtime reflection and it's

00:43:02,810 --> 00:43:07,130
not even entirely C++ because it

00:43:04,910 --> 00:43:08,930
requires an extra step in the process

00:43:07,130 --> 00:43:10,280
what I was trying to focus on this talk

00:43:08,930 --> 00:43:12,110
is actually doing stuff that I should

00:43:10,280 --> 00:43:13,850
only that basically essentially just

00:43:12,110 --> 00:43:15,350
runs basically in C++ and you don't need

00:43:13,850 --> 00:43:17,030
a separate build step because there's a

00:43:15,350 --> 00:43:18,650
there's some other solutions to that

00:43:17,030 --> 00:43:20,720
actually you can read the metadata using

00:43:18,650 --> 00:43:22,460
like Lib playing and then oh I should go

00:43:20,720 --> 00:43:24,110
out and generate some extra files for

00:43:22,460 --> 00:43:25,730
you so that you can do reflection as

00:43:24,110 --> 00:43:31,910
well there's there's there's several

00:43:25,730 --> 00:43:34,470
tools that do that so well but the QT

00:43:31,910 --> 00:43:38,130
the QT is actually

00:43:34,470 --> 00:43:39,930
as just since you mentioned it it it

00:43:38,130 --> 00:43:42,090
relies on getters and setters when you

00:43:39,930 --> 00:43:43,650
do it besides running the mock so like

00:43:42,090 --> 00:43:45,780
in this example I was able to just take

00:43:43,650 --> 00:43:49,160
a plain struct and actually basically

00:43:45,780 --> 00:43:52,170
essentially make it work with the

00:43:49,160 --> 00:43:56,280
reflection framework if at all means

00:43:52,170 --> 00:43:58,109
like if you need to like actually like

00:43:56,280 --> 00:43:58,980
if you don't have the need for having

00:43:58,109 --> 00:44:00,990
the getters and setters

00:43:58,980 --> 00:44:02,849
but maybe you have certain requirements

00:44:00,990 --> 00:44:04,500
you need these actually to be playing on

00:44:02,849 --> 00:44:06,390
data types for whatever reason like

00:44:04,500 --> 00:44:08,130
since you're interfacing with like hdf5

00:44:06,390 --> 00:44:09,810
or some kind of little type of format

00:44:08,130 --> 00:44:11,430
that kind of RC API that kind of

00:44:09,810 --> 00:44:13,290
requires that then you can't really

00:44:11,430 --> 00:44:16,050
instrument it with getters and setters

00:44:13,290 --> 00:44:17,550
you can't you you also can't use the

00:44:16,050 --> 00:44:20,280
Mach with it because if the choir is

00:44:17,550 --> 00:44:22,800
inherited from cue object so these

00:44:20,280 --> 00:44:24,510
techniques like like specially the first

00:44:22,800 --> 00:44:26,220
two techniques you can still meet the

00:44:24,510 --> 00:44:28,710
requirements of having a plano data type

00:44:26,220 --> 00:44:30,150
to interface with c+ on on the other

00:44:28,710 --> 00:44:32,570
side of the you can get reflection data

00:44:30,150 --> 00:44:32,570
about it

00:44:37,590 --> 00:44:43,380
Chinn at the beginning that the compile

00:44:40,800 --> 00:44:48,540
time data could be used to serialize

00:44:43,380 --> 00:44:50,940
serialize out for produce data the

00:44:48,540 --> 00:44:53,130
runtime data right yeah so essentially

00:44:50,940 --> 00:44:54,750
what you could do like instead of like I

00:44:53,130 --> 00:44:56,730
have the example where I print the XML

00:44:54,750 --> 00:44:59,550
instead you could just create like a

00:44:56,730 --> 00:45:01,140
static map or whatever in your in your

00:44:59,550 --> 00:45:02,730
data structure and then you get

00:45:01,140 --> 00:45:04,680
essentially instead of doing the for

00:45:02,730 --> 00:45:06,600
each and printing out the XML you just

00:45:04,680 --> 00:45:08,700
fill up that map that's static map

00:45:06,600 --> 00:45:10,590
that's associated with that type and by

00:45:08,700 --> 00:45:12,270
doing that you can essentially have the

00:45:10,590 --> 00:45:14,880
runtime data and then you just need a

00:45:12,270 --> 00:45:17,580
mechanism to query based on that type to

00:45:14,880 --> 00:45:21,210
query for that map so that's how you can

00:45:17,580 --> 00:45:24,320
generate your one-time data good quick

00:45:21,210 --> 00:45:28,470
question will your code be up on github

00:45:24,320 --> 00:45:30,120
this code it will be up on get lab for

00:45:28,470 --> 00:45:32,880
the presentation all the code in the

00:45:30,120 --> 00:45:34,620
presentation will be on get lab which I

00:45:32,880 --> 00:45:36,300
should be posting here in the next I

00:45:34,620 --> 00:45:38,880
don't know when they're going to release

00:45:36,300 --> 00:45:40,380
it for the conference but yeah it will

00:45:38,880 --> 00:45:41,520
be out on get lab so you can make sure

00:45:40,380 --> 00:45:48,540
you take a look at it and it all

00:45:41,520 --> 00:45:50,670
compiles and runs you mentioned at the

00:45:48,540 --> 00:45:52,740
beginning that there is a study group

00:45:50,670 --> 00:45:54,450
that was looking into runtime reflection

00:45:52,740 --> 00:45:57,000
for seeketh plus what's the name of that

00:45:54,450 --> 00:45:59,850
group Burt you follow them or anything

00:45:57,000 --> 00:46:06,090
yeah I don't remember the number for it

00:45:59,850 --> 00:46:07,880
if it's it's like SG its SG it's not s

00:46:06,090 --> 00:46:10,530
to eight I think that's the concepts one

00:46:07,880 --> 00:46:12,000
lady's su for I don't I don't remember

00:46:10,530 --> 00:46:17,100
which one it is

00:46:12,000 --> 00:46:20,390
I'd have to go look it up sorry yeah

00:46:17,100 --> 00:46:20,390
it's one of those two groups yeah

00:46:21,880 --> 00:46:41,490
you're aware that tup you pronounced

00:46:24,940 --> 00:46:41,490

YouTube URL: https://www.youtube.com/watch?v=9QGsEkB4Rfs


