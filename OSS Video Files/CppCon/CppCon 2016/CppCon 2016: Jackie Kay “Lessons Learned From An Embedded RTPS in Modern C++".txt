Title: CppCon 2016: Jackie Kay “Lessons Learned From An Embedded RTPS in Modern C++"
Publication date: 2016-10-01
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Software for embedded systems means writing code for a microprocessor with specs straight out of the 80s. But that doesn’t mean that embedded developers should be afraid of using the best tools that modern languages have to offer. This talk will explore embedded development through the source code of a modern C++ implementation of the RTPS (Real-Time Publish/Subscribe) wire protocol. Our targeting ARM STM32 microcontrollers (but generalizable to many platforms). We will put zero-cost abstractions to the test as we attempt to fit a system conforming to a 200-page OMG specification document onto an MCU with 384 KB of RAM and 2048 KB of flash. At a higher level, we will discuss the philosophy of using high-level abstractions in a low-level environment, and seek to settle the score with old-school C microcontroller hackers.
— 
Jackie Kay
Software Engineer, Marble Robotics
I write FOSS tools for the robotics community.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,050 --> 00:00:04,950
hi everyone my name is Jackie Kate for

00:00:03,240 --> 00:00:07,259
those of you who don't know me I'm a

00:00:04,950 --> 00:00:09,570
software engineer at a small stealth

00:00:07,259 --> 00:00:11,580
robotics start-up called Marble for the

00:00:09,570 --> 00:00:13,139
past two years though I work at a

00:00:11,580 --> 00:00:15,839
company called the open-source robotics

00:00:13,139 --> 00:00:18,990
foundation it's a very descriptive name

00:00:15,839 --> 00:00:21,000
we make or I used to make open-source

00:00:18,990 --> 00:00:24,660
software tools for robotics including

00:00:21,000 --> 00:00:28,170
Ross which is an open-source networking

00:00:24,660 --> 00:00:30,420
framework and gazebo which is a physics

00:00:28,170 --> 00:00:31,769
simulator for testing robotics

00:00:30,420 --> 00:00:32,489
algorithms before deploying them on a

00:00:31,769 --> 00:00:35,730
real robot

00:00:32,489 --> 00:00:40,170
so one goal of that organization is

00:00:35,730 --> 00:00:42,210
making tools that are accessible and

00:00:40,170 --> 00:00:44,820
accessibility also involves

00:00:42,210 --> 00:00:46,140
cross-platform compatibility which is

00:00:44,820 --> 00:00:48,360
not something that those tools

00:00:46,140 --> 00:00:50,700
previously really succeeded at so what

00:00:48,360 --> 00:00:53,910
I'm going to talk about today is some

00:00:50,700 --> 00:00:57,120
some lessons I learned from looking at

00:00:53,910 --> 00:01:00,600
implementing a a cross-platform version

00:00:57,120 --> 00:01:03,059
of the RTP S wire protocol with a

00:01:00,600 --> 00:01:05,189
partial implementation of DDS I'm gonna

00:01:03,059 --> 00:01:07,860
get into what exactly those are and

00:01:05,189 --> 00:01:09,869
because you know this industry is full

00:01:07,860 --> 00:01:12,570
of acronyms that don't really sound like

00:01:09,869 --> 00:01:14,250
anything and a little bit but again

00:01:12,570 --> 00:01:17,100
we're gonna kind of do some high-level

00:01:14,250 --> 00:01:18,540
stuff here and talk about one of the

00:01:17,100 --> 00:01:20,490
many problems in robotics which is

00:01:18,540 --> 00:01:23,549
communication communication is really

00:01:20,490 --> 00:01:25,740
hard and you may not know this but in

00:01:23,549 --> 00:01:27,750
when dealing with robotics there is a

00:01:25,740 --> 00:01:29,189
lot of computers involved and not just

00:01:27,750 --> 00:01:30,750
the computers that are onboard the robot

00:01:29,189 --> 00:01:33,090
and yes there are multiple computers on

00:01:30,750 --> 00:01:35,490
board the robot so you're gonna start

00:01:33,090 --> 00:01:38,090
out writing your code on your developer

00:01:35,490 --> 00:01:41,460
environment your laptop might be a

00:01:38,090 --> 00:01:43,829
MacBook Pro whatever might be think pad

00:01:41,460 --> 00:01:46,140
running Linux like me you're gonna

00:01:43,829 --> 00:01:48,930
compile it you might cross compile it

00:01:46,140 --> 00:01:51,329
for a target for an embedded target or

00:01:48,930 --> 00:01:54,090
you might compile it for an API

00:01:51,329 --> 00:01:55,110
compatible Linux machine depending on

00:01:54,090 --> 00:01:58,380
what you're gonna run on the robot

00:01:55,110 --> 00:02:00,780
you might also talk to a cloud server on

00:01:58,380 --> 00:02:04,439
stores offline data and the cloud server

00:02:00,780 --> 00:02:07,740
might also talk to the robot taking data

00:02:04,439 --> 00:02:10,860
or sending commands via a tell operation

00:02:07,740 --> 00:02:12,660
interface so so this is kind of

00:02:10,860 --> 00:02:13,510
important it's three node communication

00:02:12,660 --> 00:02:14,439
three or more

00:02:13,510 --> 00:02:17,829
really because you might have more

00:02:14,439 --> 00:02:19,510
robots talking to each other and you as

00:02:17,829 --> 00:02:20,950
I hate to do before you're gonna have a

00:02:19,510 --> 00:02:24,370
lot of computers on the robot of

00:02:20,950 --> 00:02:25,870
different classes those those computers

00:02:24,370 --> 00:02:28,709
have a lot of different roles really

00:02:25,870 --> 00:02:33,220
what a robot is is a intelligent

00:02:28,709 --> 00:02:35,769
interface to sensors and actuators it's

00:02:33,220 --> 00:02:39,340
any way how I conceptualize it and a

00:02:35,769 --> 00:02:41,109
sensor is taking in analog data from

00:02:39,340 --> 00:02:42,400
from an analog circuit and then

00:02:41,109 --> 00:02:45,760
translating that into some digital

00:02:42,400 --> 00:02:48,790
representation and a microcontroller is

00:02:45,760 --> 00:02:51,940
is doing the reverse operation of

00:02:48,790 --> 00:02:54,760
translating from information from a

00:02:51,940 --> 00:02:57,760
digital interface to an analog

00:02:54,760 --> 00:02:59,139
representation so so why am I getting it

00:02:57,760 --> 00:03:01,030
why is this important how this is

00:02:59,139 --> 00:03:03,400
relevant to what we you came here to

00:03:01,030 --> 00:03:06,010
talk about well there's a lot of

00:03:03,400 --> 00:03:08,799
embedded systems and and a robot is

00:03:06,010 --> 00:03:11,709
gonna include you know maybe a couple of

00:03:08,799 --> 00:03:13,510
these and what these are are are

00:03:11,709 --> 00:03:14,920
different classes of embedded systems

00:03:13,510 --> 00:03:16,389
and I wanted to just you don't have to

00:03:14,920 --> 00:03:17,530
get into all the details but I wanted to

00:03:16,389 --> 00:03:20,230
throw up some numbers to give you an

00:03:17,530 --> 00:03:22,930
idea of the the diversity in the

00:03:20,230 --> 00:03:27,250
spectrum of computational power that we

00:03:22,930 --> 00:03:28,449
see these days so so when you think of

00:03:27,250 --> 00:03:30,699
an embedded system you might just think

00:03:28,449 --> 00:03:34,540
of a computer without a screen

00:03:30,699 --> 00:03:36,870
I find this not a very useful definition

00:03:34,540 --> 00:03:40,389
because there are computers without

00:03:36,870 --> 00:03:42,489
screens that are as powerful or more

00:03:40,389 --> 00:03:43,919
powerful in the laptop year you might be

00:03:42,489 --> 00:03:47,500
using right now during my presentation

00:03:43,919 --> 00:03:48,160
for example the Intel nook is a small

00:03:47,500 --> 00:03:51,940
form-factor

00:03:48,160 --> 00:03:54,160
intel x86 risk whatever device with 16

00:03:51,940 --> 00:03:56,169
gigs of ram and when you compare that to

00:03:54,160 --> 00:03:58,989
the bottom cloth on this table the

00:03:56,169 --> 00:04:01,359
msp430 which I actually changed this

00:03:58,989 --> 00:04:03,400
slide after Jason's talk I want to call

00:04:01,359 --> 00:04:04,599
it the msp430 because he gave it as an

00:04:03,400 --> 00:04:05,859
example of something that's roughly

00:04:04,599 --> 00:04:08,019
computationally equivalent to the

00:04:05,859 --> 00:04:09,729
commodore 64 and that's the kind of

00:04:08,019 --> 00:04:12,180
device that we'd use in a wireless

00:04:09,729 --> 00:04:14,379
sensor network when you need a really

00:04:12,180 --> 00:04:16,750
low power device that might spend most

00:04:14,379 --> 00:04:18,400
of its time sleeping and then collecting

00:04:16,750 --> 00:04:21,579
data and then reporting that data back

00:04:18,400 --> 00:04:23,020
to a central server so anyway we're

00:04:21,579 --> 00:04:26,200
going to focus on one of these classes

00:04:23,020 --> 00:04:29,320
today and it'll be this one so that's

00:04:26,200 --> 00:04:32,590
this I think if this is maybe you you

00:04:29,320 --> 00:04:35,260
have an MCU that has to talk to a camera

00:04:32,590 --> 00:04:38,110
or some like non-trivial sensor and then

00:04:35,260 --> 00:04:39,760
there's a driver that that then relays

00:04:38,110 --> 00:04:43,180
that information to a central core

00:04:39,760 --> 00:04:44,980
processing unit on a robot so this is

00:04:43,180 --> 00:04:47,680
just kind of filling out some some

00:04:44,980 --> 00:04:49,210
details you have operating systems you

00:04:47,680 --> 00:04:51,490
have your you have text and you have the

00:04:49,210 --> 00:04:53,650
Apple whatever I you know I preferred

00:04:51,490 --> 00:04:56,050
the penguin over here too but each each

00:04:53,650 --> 00:04:57,760
to their own and we're gonna focus on as

00:04:56,050 --> 00:04:59,170
I said before the the classes that will

00:04:57,760 --> 00:05:04,750
be associated with sensors and motor

00:04:59,170 --> 00:05:06,760
controllers so I think this this outline

00:05:04,750 --> 00:05:09,400
slide is like really common at cpp con

00:05:06,760 --> 00:05:11,500
again this was in Jason's talk but just

00:05:09,400 --> 00:05:14,680
with fewer details and I swear I made

00:05:11,500 --> 00:05:17,530
this before I saw his talk the this is

00:05:14,680 --> 00:05:20,700
roughly you know the layout of of your

00:05:17,530 --> 00:05:23,500
computer there's the the CPU there's a

00:05:20,700 --> 00:05:25,510
memory and that's connected to the bus

00:05:23,500 --> 00:05:28,870
and the bus is connected to peripherals

00:05:25,510 --> 00:05:32,050
and and your operating system serves

00:05:28,870 --> 00:05:34,480
between the CPU the bus and the

00:05:32,050 --> 00:05:36,880
peripherals and it provides really nice

00:05:34,480 --> 00:05:39,670
things things that make coding a lot

00:05:36,880 --> 00:05:41,920
easier it's gonna manage your processes

00:05:39,670 --> 00:05:44,290
and threads your control flow it's gonna

00:05:41,920 --> 00:05:47,590
allocate memory from the heap to

00:05:44,290 --> 00:05:49,780
different processes and it'll provide a

00:05:47,590 --> 00:05:52,120
unified interface for things like your

00:05:49,780 --> 00:05:55,770
monitor and your keyboard your Ethernet

00:05:52,120 --> 00:05:57,790
whatever things you interact with a lot

00:05:55,770 --> 00:06:00,880
and when people are afraid of bare metal

00:05:57,790 --> 00:06:03,610
development they're talking about not

00:06:00,880 --> 00:06:06,310
not having any of that they really it's

00:06:03,610 --> 00:06:11,440
it's what we saw in Jason's plenary you

00:06:06,310 --> 00:06:13,090
know it's technically plenary it's when

00:06:11,440 --> 00:06:16,210
you want to access these peripherals

00:06:13,090 --> 00:06:16,960
you're just directly setting values and

00:06:16,210 --> 00:06:21,610
registers

00:06:16,960 --> 00:06:23,920
there's no abstraction so um I know I

00:06:21,610 --> 00:06:25,810
think in the abstract I mentioned bare

00:06:23,920 --> 00:06:28,030
metal development the abstract of this

00:06:25,810 --> 00:06:29,740
talk did drift a little we are gonna

00:06:28,030 --> 00:06:32,500
talk about working with an artist today

00:06:29,740 --> 00:06:34,390
our real-time operating system I look

00:06:32,500 --> 00:06:37,990
for to seye artists rtos is like way too

00:06:34,390 --> 00:06:41,010
much of a mouthful so a real-time

00:06:37,990 --> 00:06:41,010
operating system is

00:06:41,140 --> 00:06:45,400
I like to think of it as a small

00:06:42,970 --> 00:06:47,920
operating system with components that

00:06:45,400 --> 00:06:49,900
you can can grab and put into your

00:06:47,920 --> 00:06:52,390
embedded binary as you pick and choose

00:06:49,900 --> 00:06:55,000
it is I'm graphically representing it as

00:06:52,390 --> 00:06:58,360
a thin layer of operating system that

00:06:55,000 --> 00:06:59,890
you can you can put on your device and

00:06:58,360 --> 00:07:01,060
and what's cool about embedded

00:06:59,890 --> 00:07:05,920
development is because your cross

00:07:01,060 --> 00:07:07,420
compiling for a small target unlike when

00:07:05,920 --> 00:07:10,390
you're doing desktop development when

00:07:07,420 --> 00:07:12,070
you compile a binary and then you when

00:07:10,390 --> 00:07:16,360
you execute the binary that gets loaded

00:07:12,070 --> 00:07:18,040
into memory when you when you compile

00:07:16,360 --> 00:07:22,300
for embedded you're actually flashing

00:07:18,040 --> 00:07:24,070
the the device the computer with the

00:07:22,300 --> 00:07:25,330
startup code and that kind of the sole

00:07:24,070 --> 00:07:26,530
program that's going to run so you're

00:07:25,330 --> 00:07:27,730
it's kind of like you're compiling your

00:07:26,530 --> 00:07:31,510
own operating system but like everything

00:07:27,730 --> 00:07:34,480
- so so most real-time operating systems

00:07:31,510 --> 00:07:35,980
you can select some kind of sub

00:07:34,480 --> 00:07:38,080
component of operating system

00:07:35,980 --> 00:07:41,680
functionality that you need for your

00:07:38,080 --> 00:07:43,720
specific application and I'm explaining

00:07:41,680 --> 00:07:46,660
that because I'm gonna show you just a

00:07:43,720 --> 00:07:49,510
really quick size comparison to show how

00:07:46,660 --> 00:07:50,890
how thin a layer of real-time operating

00:07:49,510 --> 00:07:53,740
system we're going to use rather than

00:07:50,890 --> 00:07:56,350
using Linux so we're going to use the

00:07:53,740 --> 00:07:58,180
size command size of the UNIX command

00:07:56,350 --> 00:08:01,150
that gives you the size of a binary and

00:07:58,180 --> 00:08:04,150
it gives you three outputs the text is

00:08:01,150 --> 00:08:05,410
the instruction tape essentially of

00:08:04,150 --> 00:08:09,040
assembly instructions that you're going

00:08:05,410 --> 00:08:11,620
to use data is the see if I get this

00:08:09,040 --> 00:08:18,100
right be initialized before runtime

00:08:11,620 --> 00:08:20,530
variables in your program and BSF is the

00:08:18,100 --> 00:08:23,320
the area of memory dedicated to

00:08:20,530 --> 00:08:29,350
uninitialized variable stack allocated

00:08:23,320 --> 00:08:30,490
variables so I'm gonna compare yeah

00:08:29,350 --> 00:08:36,700
we're comparing here the size of the

00:08:30,490 --> 00:08:39,790
Linux kernel to a test binary so the the

00:08:36,700 --> 00:08:42,460
test binary is essentially using most of

00:08:39,790 --> 00:08:43,780
the threading capabilities of free our

00:08:42,460 --> 00:08:45,100
toss which is a particular real-time

00:08:43,780 --> 00:08:47,590
operating system we're gonna use today

00:08:45,100 --> 00:08:49,870
and we'll just the takeaway here is that

00:08:47,590 --> 00:08:53,350
it's it's literally an order of

00:08:49,870 --> 00:08:54,850
magnitude lower than the Linux kernel

00:08:53,350 --> 00:08:59,220
and that's important because of the tiny

00:08:54,850 --> 00:09:01,600
sizes of things on this previous slide

00:08:59,220 --> 00:09:04,750
yeah okay so and just to keep things

00:09:01,600 --> 00:09:06,700
really kind of specific when it's

00:09:04,750 --> 00:09:08,830
relevant to talk about specific hardware

00:09:06,700 --> 00:09:12,270
and a specific artist today we're going

00:09:08,830 --> 00:09:14,560
to talk about you know CMS is or CMS's

00:09:12,270 --> 00:09:17,140
wrapping free our toss on the arm

00:09:14,560 --> 00:09:19,480
cortex-m seven and just like to expand

00:09:17,140 --> 00:09:21,580
that out that's this like in this

00:09:19,480 --> 00:09:23,380
wrapper around different real-time

00:09:21,580 --> 00:09:26,230
operating systems that that are made up

00:09:23,380 --> 00:09:27,460
for the cortex and family and as I said

00:09:26,230 --> 00:09:32,340
we're going to focus on that class

00:09:27,460 --> 00:09:34,570
because it's useful for robotics so um

00:09:32,340 --> 00:09:38,350
now we're gonna actually talk about how

00:09:34,570 --> 00:09:41,440
we're going to design a library using

00:09:38,350 --> 00:09:45,970
modern C++ to implement this particular

00:09:41,440 --> 00:09:48,160
networking protocol but I mean I'm gonna

00:09:45,970 --> 00:09:51,340
kind of shy away from talking about the

00:09:48,160 --> 00:09:52,420
specifics of our DPS and DDS today in

00:09:51,340 --> 00:09:54,970
case you're really curious about

00:09:52,420 --> 00:09:56,230
learning more about that I can just find

00:09:54,970 --> 00:09:57,640
me afterwards and I'll tell you more

00:09:56,230 --> 00:09:59,230
about it and give you some resources but

00:09:57,640 --> 00:10:01,660
I think it's more interesting for this

00:09:59,230 --> 00:10:05,800
audience to talk about C++ specific

00:10:01,660 --> 00:10:08,800
problems so this is you know an overview

00:10:05,800 --> 00:10:10,150
of what you know what you might get and

00:10:08,800 --> 00:10:12,700
then complete set of what you might get

00:10:10,150 --> 00:10:15,910
if you use C++ rather than C and you do

00:10:12,700 --> 00:10:18,400
embedded development and and the reason

00:10:15,910 --> 00:10:21,190
you know I I sort of vaguely ordered

00:10:18,400 --> 00:10:24,910
this so that things that are considered

00:10:21,190 --> 00:10:26,170
somewhat harmful or on the right and and

00:10:24,910 --> 00:10:29,040
you've probably heard a lot of reasons

00:10:26,170 --> 00:10:33,400
why these things are considered harmful

00:10:29,040 --> 00:10:35,650
because they they incur a cost that that

00:10:33,400 --> 00:10:37,150
you might not have asked for right and

00:10:35,650 --> 00:10:39,400
that's what what we're really concerned

00:10:37,150 --> 00:10:42,480
about is incurring a cost of something

00:10:39,400 --> 00:10:45,070
that's not in our control STL containers

00:10:42,480 --> 00:10:46,210
you can choose not to use those and the

00:10:45,070 --> 00:10:48,090
reason they might be considered harmful

00:10:46,210 --> 00:10:50,110
is because of dynamic memory allocation

00:10:48,090 --> 00:10:51,640
but exceptions in our TTI

00:10:50,110 --> 00:10:53,080
if you don't turn our TDI off you're

00:10:51,640 --> 00:10:56,680
gonna get a cost for it whenever you

00:10:53,080 --> 00:10:58,690
have classes or types in your program so

00:10:56,680 --> 00:11:01,150
so you know we have some tricks we have

00:10:58,690 --> 00:11:02,440
some compiler tricks for for reducing

00:11:01,150 --> 00:11:04,540
code size so that the size of your

00:11:02,440 --> 00:11:07,050
compiled binary can fit on this

00:11:04,540 --> 00:11:07,890
relatively small space

00:11:07,050 --> 00:11:11,130
the first two I think are

00:11:07,890 --> 00:11:13,950
self-explanatory then they're kind of

00:11:11,130 --> 00:11:15,959
some maybe one that I had no idea about

00:11:13,950 --> 00:11:19,170
until I started putting together slides

00:11:15,959 --> 00:11:22,470
actually is short younam's which chooses

00:11:19,170 --> 00:11:24,600
the four freedoms that where you don't

00:11:22,470 --> 00:11:28,860
specify the underlying type it chooses

00:11:24,600 --> 00:11:31,649
the smallest underlying integer type for

00:11:28,860 --> 00:11:34,079
enum storage and then there's this kind

00:11:31,649 --> 00:11:36,810
of catch-all compiler flag you can pass

00:11:34,079 --> 00:11:41,339
I think these are will work with both

00:11:36,810 --> 00:11:44,700
GCC and clang yeah I only need

00:11:41,339 --> 00:11:46,589
I only need one of those so oh s is a

00:11:44,700 --> 00:11:48,690
maybe maybe you didn't know about this

00:11:46,589 --> 00:11:52,589
it's rather than then optimized for

00:11:48,690 --> 00:11:58,019
speed optimized for space because that

00:11:52,589 --> 00:12:00,810
trade-off can actually be that that can

00:11:58,019 --> 00:12:02,610
be a trade-off between those two so so

00:12:00,810 --> 00:12:06,089
you know unlike maybe game development

00:12:02,610 --> 00:12:11,459
we're not going to be optimizing for for

00:12:06,089 --> 00:12:12,839
speed keep in mind and another so I

00:12:11,459 --> 00:12:14,519
mentioned dynamic memory allocation and

00:12:12,839 --> 00:12:17,070
I just want to say we're not gonna go

00:12:14,519 --> 00:12:18,750
over all the the details of how you set

00:12:17,070 --> 00:12:20,519
up your embedded tool chain today

00:12:18,750 --> 00:12:22,470
because there's a lot of you know much

00:12:20,519 --> 00:12:24,630
better resources online that you can you

00:12:22,470 --> 00:12:26,880
read about and and sit down with and

00:12:24,630 --> 00:12:29,100
like kind of tear your hair out over but

00:12:26,880 --> 00:12:32,070
I wanted to give you as a taste of of

00:12:29,100 --> 00:12:34,290
the fun that's involved in doing things

00:12:32,070 --> 00:12:36,870
like modifying your own linker script

00:12:34,290 --> 00:12:40,470
and and modifying vector interrupt

00:12:36,870 --> 00:12:43,980
tables so so one thing is that that's

00:12:40,470 --> 00:12:48,899
cool is if okay so whenever you interact

00:12:43,980 --> 00:12:50,670
with a C++ program or when you when you

00:12:48,899 --> 00:12:52,769
compile one and you you interact with

00:12:50,670 --> 00:12:55,860
the linker you probably aren't writing

00:12:52,769 --> 00:12:57,899
your own linker script but if you want

00:12:55,860 --> 00:13:00,660
to limit if you want to set a specific

00:12:57,899 --> 00:13:02,640
heap size and stack size then you may

00:13:00,660 --> 00:13:06,170
want to probably modify an existing

00:13:02,640 --> 00:13:08,970
linker script that's suitable for your

00:13:06,170 --> 00:13:11,760
instruction format so this is an example

00:13:08,970 --> 00:13:14,250
of how you would use the linker script

00:13:11,760 --> 00:13:15,630
syntax to do that these are variables

00:13:14,250 --> 00:13:19,779
that are set somewhere higher up in the

00:13:15,630 --> 00:13:22,720
linker script and you also

00:13:19,779 --> 00:13:24,720
probably very rare that you on desktop

00:13:22,720 --> 00:13:27,670
computing that you're going to modify

00:13:24,720 --> 00:13:30,339
vector interrupt tables but in case you

00:13:27,670 --> 00:13:32,949
wanted to do that here's an example of

00:13:30,339 --> 00:13:36,959
some assembly you can write to load

00:13:32,949 --> 00:13:39,189
registers and memory to again limit the

00:13:36,959 --> 00:13:43,089
heat memory and stack memory used by

00:13:39,189 --> 00:13:46,779
your binary so now that we have some

00:13:43,089 --> 00:13:51,850
tooling out of the way let's let's talk

00:13:46,779 --> 00:13:55,389
about actually some some sepals put C++

00:13:51,850 --> 00:13:58,990
code you can write and patterns employed

00:13:55,389 --> 00:14:01,360
in this particular domain that I'm I was

00:13:58,990 --> 00:14:04,800
interested in covering in this project

00:14:01,360 --> 00:14:10,899
that I over take over oh I overtook yes

00:14:04,800 --> 00:14:14,610
so at the very core of it the design of

00:14:10,899 --> 00:14:18,639
a networking library I think is

00:14:14,610 --> 00:14:22,540
serialization dealing with concurrency

00:14:18,639 --> 00:14:24,069
and sockets and this is a very

00:14:22,540 --> 00:14:25,839
simplified view of what might happen you

00:14:24,069 --> 00:14:27,339
have an in-memory representation of a

00:14:25,839 --> 00:14:29,529
struct of a message that you want to

00:14:27,339 --> 00:14:32,410
send and then you serialize it to some

00:14:29,529 --> 00:14:35,319
byte format that is agreed upon by the

00:14:32,410 --> 00:14:38,189
two endpoints of communication and then

00:14:35,319 --> 00:14:41,139
you have some function that stuffs that

00:14:38,189 --> 00:14:45,370
serialized byte stream into a socket and

00:14:41,139 --> 00:14:47,259
then that socket does some magic over

00:14:45,370 --> 00:14:49,569
the internet or whatever networking

00:14:47,259 --> 00:14:51,670
protocol you're using it sends it to

00:14:49,569 --> 00:14:55,240
another socket which was previously

00:14:51,670 --> 00:14:59,100
configured to discover the sending

00:14:55,240 --> 00:15:02,079
socket and in this thread of execution

00:14:59,100 --> 00:15:06,220
this this process represented by this

00:15:02,079 --> 00:15:08,019
block has been sleeping or whatever it's

00:15:06,220 --> 00:15:10,509
been doing it's been waiting for a

00:15:08,019 --> 00:15:12,220
packet to receive a serialize with the

00:15:10,509 --> 00:15:15,579
the byte stream contained in that packet

00:15:12,220 --> 00:15:16,120
and then it gives the the process on the

00:15:15,579 --> 00:15:17,620
other end

00:15:16,120 --> 00:15:22,410
some nice in memory struct

00:15:17,620 --> 00:15:25,540
representation of that message so DDS

00:15:22,410 --> 00:15:27,730
stands for data distribution service it

00:15:25,540 --> 00:15:30,189
is a distributed networking protocol

00:15:27,730 --> 00:15:33,070
which means that there is some some

00:15:30,189 --> 00:15:34,630
extra stuff on top of this to enable

00:15:33,070 --> 00:15:37,660
those two discover each other on the

00:15:34,630 --> 00:15:40,590
network rather than something like MQTT

00:15:37,660 --> 00:15:42,880
where you'd have a central broker that

00:15:40,590 --> 00:15:45,700
basically all nodes are configured to

00:15:42,880 --> 00:15:47,530
listen to for internet for network

00:15:45,700 --> 00:15:49,600
information so rather than having a

00:15:47,530 --> 00:15:50,920
central broker all the nodes talk to

00:15:49,600 --> 00:15:52,240
each other and it's kind of messy and

00:15:50,920 --> 00:15:54,940
you get this weird mustache pattern I

00:15:52,240 --> 00:15:57,190
don't know how that happened so we're

00:15:54,940 --> 00:15:58,270
going to ignore those details in today's

00:15:57,190 --> 00:16:02,080
talk because they're kind of out of

00:15:58,270 --> 00:16:04,090
scope and talk about really common

00:16:02,080 --> 00:16:06,250
patterns that might be more useful to

00:16:04,090 --> 00:16:10,630
anyone who's implementing not just an

00:16:06,250 --> 00:16:12,610
elaborate never eating library but you

00:16:10,630 --> 00:16:14,280
know serialization happens all over the

00:16:12,610 --> 00:16:16,860
place what I'm trying to say here so uh

00:16:14,280 --> 00:16:20,830
here's kind of an old-school way of

00:16:16,860 --> 00:16:22,780
doing this you you have classes and

00:16:20,830 --> 00:16:25,270
naturally classes have a serialize and

00:16:22,780 --> 00:16:27,040
deserialize message and maybe these

00:16:25,270 --> 00:16:30,340
serialize and deserialize messages look

00:16:27,040 --> 00:16:31,390
really similar so so what a lot of

00:16:30,340 --> 00:16:34,200
people like to do is have a code

00:16:31,390 --> 00:16:37,930
generator and this code generator takes

00:16:34,200 --> 00:16:39,340
takes some agreed-upon IDL format IDL

00:16:37,930 --> 00:16:42,280
standing for interface definition

00:16:39,340 --> 00:16:47,350
language and maybe it uses some other

00:16:42,280 --> 00:16:52,480
language or you to generate C++ sources

00:16:47,350 --> 00:16:54,130
that have an agreed-upon API design and

00:16:52,480 --> 00:16:58,120
maybe they inherit from some generated

00:16:54,130 --> 00:17:03,130
message superclass that provides some

00:16:58,120 --> 00:17:04,240
functionality so okay I really like

00:17:03,130 --> 00:17:05,740
audience participation I should've

00:17:04,240 --> 00:17:07,209
started doing this earlier who has

00:17:05,740 --> 00:17:10,720
worked in the code base with code

00:17:07,209 --> 00:17:12,820
generation okay so who has worked in a

00:17:10,720 --> 00:17:16,930
code base with code generation that's

00:17:12,820 --> 00:17:19,780
not you can see how someone would twist

00:17:16,930 --> 00:17:23,680
this that's not like you know generated

00:17:19,780 --> 00:17:26,140
by the compiler okay okay cool just to

00:17:23,680 --> 00:17:28,540
get that out of the way so um so I

00:17:26,140 --> 00:17:29,980
skipped ahead a little bit there there

00:17:28,540 --> 00:17:34,810
there's a way of doing code generation

00:17:29,980 --> 00:17:36,340
in C++ and it's I'm gonna try to show

00:17:34,810 --> 00:17:38,260
that it's pretty simple and can be done

00:17:36,340 --> 00:17:42,160
really really easily with existing

00:17:38,260 --> 00:17:46,630
libraries and the idea here is that you

00:17:42,160 --> 00:17:49,919
use define a serializable concept

00:17:46,630 --> 00:17:54,100
and you provide template functions that

00:17:49,919 --> 00:17:57,730
that describe how to serialize kind of

00:17:54,100 --> 00:18:00,789
the the primitive types of your

00:17:57,730 --> 00:18:03,760
serialization strategy and then you

00:18:00,789 --> 00:18:07,000
basically use metaprogramming to iterate

00:18:03,760 --> 00:18:10,510
over the fields of a struct and and

00:18:07,000 --> 00:18:13,059
syria serialized those subfields of your

00:18:10,510 --> 00:18:15,669
serializable message and then you do the

00:18:13,059 --> 00:18:18,190
same operation on the other end with

00:18:15,669 --> 00:18:23,110
deserialize as you read bytes up from

00:18:18,190 --> 00:18:24,490
the byte stream so this this you know I

00:18:23,110 --> 00:18:27,520
don't have syntax highlighting on these

00:18:24,490 --> 00:18:28,690
slides and this is also complete

00:18:27,520 --> 00:18:30,850
pseudocode this is like not

00:18:28,690 --> 00:18:33,880
syntactically correct at all this get

00:18:30,850 --> 00:18:36,520
fields of thing you're it's it yeah it

00:18:33,880 --> 00:18:40,000
looks weird so I'm gonna show some real

00:18:36,520 --> 00:18:43,000
code here and it might be too small so

00:18:40,000 --> 00:18:44,620
to give you a point I am gonna present

00:18:43,000 --> 00:18:48,100
some benchmarks and I'm gonna use an

00:18:44,620 --> 00:18:50,169
existing well-established serialization

00:18:48,100 --> 00:18:52,809
library which is the Google protobuf

00:18:50,169 --> 00:18:53,860
library which was I I don't know much

00:18:52,809 --> 00:18:57,549
about its history but I think it was

00:18:53,860 --> 00:18:59,289
designed pre 11 so Jeff is nodding he

00:18:57,549 --> 00:19:03,100
used to work there so maybe I can I

00:18:59,289 --> 00:19:06,909
trust you I don't know so so this is an

00:19:03,100 --> 00:19:09,580
example of some of the header that that

00:19:06,909 --> 00:19:14,230
Google protobuf will generate and

00:19:09,580 --> 00:19:20,559
actually realized I should show didn't

00:19:14,230 --> 00:19:25,690
have this ready in my okay so I'll show

00:19:20,559 --> 00:19:28,240
the IDL that you provide to generate

00:19:25,690 --> 00:19:31,419
this it has the you know it has this

00:19:28,240 --> 00:19:33,730
external format I've defined some fields

00:19:31,419 --> 00:19:36,669
that are very creatively named and then

00:19:33,730 --> 00:19:42,000
it generates like four hundred lines of

00:19:36,669 --> 00:19:44,530
code to do some operations on it and

00:19:42,000 --> 00:19:46,059
this is I'm scrolling through it very

00:19:44,530 --> 00:19:47,980
fast I'm sorry but I just kind of want

00:19:46,059 --> 00:19:53,260
to give a point that it's it's it has

00:19:47,980 --> 00:19:54,520
generated a lot of code so this is the

00:19:53,260 --> 00:19:55,000
first approach that I mention of code

00:19:54,520 --> 00:19:58,720
generation

00:19:55,000 --> 00:20:00,250
the second approach this is kind of one

00:19:58,720 --> 00:20:05,410
way you could implement it using

00:20:00,250 --> 00:20:09,880
to existing libraries basically we're

00:20:05,410 --> 00:20:11,470
going to use boost Hana for limited

00:20:09,880 --> 00:20:13,750
interest spec type introspection and

00:20:11,470 --> 00:20:15,370
providing what we're gonna kind of

00:20:13,750 --> 00:20:17,440
co-opted is the serializable struct

00:20:15,370 --> 00:20:19,930
which is not going to be represented

00:20:17,440 --> 00:20:23,170
using proper concepts sorry guys

00:20:19,930 --> 00:20:27,070
and we're going to use a library called

00:20:23,170 --> 00:20:29,680
serial which is a C++ 11 successor to

00:20:27,070 --> 00:20:30,730
boost serialization which kind of has

00:20:29,680 --> 00:20:35,350
its own problems that we'll get into

00:20:30,730 --> 00:20:37,000
more later in the talk so this what I

00:20:35,350 --> 00:20:40,750
like about this class is that it's both

00:20:37,000 --> 00:20:44,380
it's kind of like its own IDL and its

00:20:40,750 --> 00:20:46,870
own in memory representation or a C++

00:20:44,380 --> 00:20:49,240
native representation of the type so you

00:20:46,870 --> 00:20:51,190
don't have to have this type definition

00:20:49,240 --> 00:20:55,770
redundancy that exists in this other

00:20:51,190 --> 00:21:01,840
style what I also like about this is

00:20:55,770 --> 00:21:06,160
that it's because it's c plus was native

00:21:01,840 --> 00:21:09,520
you can do things you can you can define

00:21:06,160 --> 00:21:12,610
your own kind of interface to this

00:21:09,520 --> 00:21:15,270
Strutt while still conforming to the

00:21:12,610 --> 00:21:17,220
serializable concept that we mentioned

00:21:15,270 --> 00:21:20,620
it might be a little bit out there but

00:21:17,220 --> 00:21:22,090
what I'm trying to say is if you make a

00:21:20,620 --> 00:21:24,100
more complicated message type and you

00:21:22,090 --> 00:21:26,140
have template parameters to it then you

00:21:24,100 --> 00:21:28,150
can understand things about the message

00:21:26,140 --> 00:21:30,840
through its template parameters that a

00:21:28,150 --> 00:21:33,490
googol protobuf type will not have

00:21:30,840 --> 00:21:35,550
because it was constrained by this code

00:21:33,490 --> 00:21:38,650
generator that someone else designed

00:21:35,550 --> 00:21:40,360
again we're using externally defined

00:21:38,650 --> 00:21:43,780
libraries that we didn't make here but

00:21:40,360 --> 00:21:45,940
we have a little bit more freedom okay

00:21:43,780 --> 00:21:47,230
so for anyone who's confused about this

00:21:45,940 --> 00:21:49,450
syntax

00:21:47,230 --> 00:21:51,910
I'm using a macro that's defined in this

00:21:49,450 --> 00:21:55,450
other library Hana that essentially

00:21:51,910 --> 00:21:57,460
makes this message or this this struct

00:21:55,450 --> 00:21:59,710
iterable if this too small can people

00:21:57,460 --> 00:22:03,370
see it okay

00:21:59,710 --> 00:22:05,710
it makes this struct iterable over the

00:22:03,370 --> 00:22:08,080
its fields and and you can actually

00:22:05,710 --> 00:22:11,590
define it externally so you can call a

00:22:08,080 --> 00:22:12,930
different macro on the struct unlike a

00:22:11,590 --> 00:22:15,990
normal looking struck

00:22:12,930 --> 00:22:19,050
you don't so which which i think is cool

00:22:15,990 --> 00:22:22,290
because that means you can you could

00:22:19,050 --> 00:22:25,020
then externally make a class someone

00:22:22,290 --> 00:22:30,360
else defined conform to my serializable

00:22:25,020 --> 00:22:35,760
concept okay so so that's how you define

00:22:30,360 --> 00:22:40,110
the IDL for this scheme and this is how

00:22:35,760 --> 00:22:43,140
you implement serialization over types

00:22:40,110 --> 00:22:45,660
that conform to what we're calling our

00:22:43,140 --> 00:22:50,750
serializable concept really here again

00:22:45,660 --> 00:22:55,530
I'm stealing the Hana struct concept and

00:22:50,750 --> 00:23:00,350
that is this thing here basically I'm

00:22:55,530 --> 00:23:04,140
saying only enable this function for

00:23:00,350 --> 00:23:06,990
this this template specialization for my

00:23:04,140 --> 00:23:10,580
serializable structs what we're doing

00:23:06,990 --> 00:23:14,130
here is we're providing load and save

00:23:10,580 --> 00:23:18,030
functions to serial our serialization

00:23:14,130 --> 00:23:22,220
library to guide it to know how to

00:23:18,030 --> 00:23:27,210
archive our structs into a serializable

00:23:22,220 --> 00:23:33,300
byte serialized format we're invoking

00:23:27,210 --> 00:23:37,430
this kind of like static port each over

00:23:33,300 --> 00:23:41,000
the over the fields of our struct and

00:23:37,430 --> 00:23:44,340
it's kind of silly because there's

00:23:41,000 --> 00:23:49,020
serial actually already understands how

00:23:44,340 --> 00:23:52,370
to serialize pod types or plain old data

00:23:49,020 --> 00:23:55,830
structures so it doesn't know how to

00:23:52,370 --> 00:23:58,350
serialize what's essentially a tuple

00:23:55,830 --> 00:24:01,080
which is like a list of types which is

00:23:58,350 --> 00:24:03,480
what we've turned our struct definition

00:24:01,080 --> 00:24:05,820
into so what we need to do is tell it

00:24:03,480 --> 00:24:08,070
how to iterate over those fields and

00:24:05,820 --> 00:24:12,270
then it actually then knows how to

00:24:08,070 --> 00:24:17,340
serialize the rest of our message and we

00:24:12,270 --> 00:24:19,980
do a for the inverse operation of load

00:24:17,340 --> 00:24:24,540
which is essentially deserialize our

00:24:19,980 --> 00:24:26,140
message from a a byte stream and you'll

00:24:24,540 --> 00:24:28,720
notice here that the

00:24:26,140 --> 00:24:30,640
the type of the archive which is what

00:24:28,720 --> 00:24:32,890
you can think of as the object that's

00:24:30,640 --> 00:24:36,030
saving our serialized byte stream or

00:24:32,890 --> 00:24:45,010
actually realized bytes about the stream

00:24:36,030 --> 00:24:49,210
so load is basically taking its doing

00:24:45,010 --> 00:24:52,690
the inverse operation of accessing into

00:24:49,210 --> 00:24:58,000
the the kind of map like structure of

00:24:52,690 --> 00:25:01,150
our Hana struct and I want to point out

00:24:58,000 --> 00:25:03,130
that this is a really small file

00:25:01,150 --> 00:25:05,860
I really didn't need to write a lot of

00:25:03,130 --> 00:25:08,830
code and and this my serialization

00:25:05,860 --> 00:25:13,450
system can now serialize and deserialize

00:25:08,830 --> 00:25:27,640
any struct that is that conforms to this

00:25:13,450 --> 00:25:29,559
concept let's see okay yeah so I think

00:25:27,640 --> 00:25:32,080
that was like a lot of meta programming

00:25:29,559 --> 00:25:35,500
and I glossed over a lot of the details

00:25:32,080 --> 00:25:37,540
so for anyone who is not familiar with

00:25:35,500 --> 00:25:42,160
these kinds of libraries you should

00:25:37,540 --> 00:25:46,299
definitely check out Hana or MPL is the

00:25:42,160 --> 00:25:51,540
kind of pre 11 where we did this I I

00:25:46,299 --> 00:25:53,710
wanted to show you a benchmark over some

00:25:51,540 --> 00:25:58,150
various file types using these two

00:25:53,710 --> 00:25:59,950
different styles because I guess I think

00:25:58,150 --> 00:26:02,919
it's common that people don't use this

00:25:59,950 --> 00:26:06,280
kind of meta programming on embedded so

00:26:02,919 --> 00:26:09,880
and and I wanted to just show that it it

00:26:06,280 --> 00:26:12,220
can indeed fit in this limited space we

00:26:09,880 --> 00:26:15,690
have for code size and it actually does

00:26:12,220 --> 00:26:18,910
like a lot better for these particular

00:26:15,690 --> 00:26:23,620
message types than the code generation

00:26:18,910 --> 00:26:27,520
example yeah so yes it's always going to

00:26:23,620 --> 00:26:29,490
be in bytes so the you know this is

00:26:27,520 --> 00:26:31,990
order of kilobytes for all of these

00:26:29,490 --> 00:26:36,100
these benchmarks and the benchmarks are

00:26:31,990 --> 00:26:38,890
really just at this point saying you

00:26:36,100 --> 00:26:39,490
know instantiate my my type stuff some

00:26:38,890 --> 00:26:42,790
fake day

00:26:39,490 --> 00:26:45,190
into it and deserialize that with some

00:26:42,790 --> 00:26:46,750
extra stuff to make sure that the result

00:26:45,190 --> 00:26:48,070
of D serialization doesn't get optimized

00:26:46,750 --> 00:26:53,290
out by the compiler because that would

00:26:48,070 --> 00:26:55,950
make for a really lame benchmark so so

00:26:53,290 --> 00:27:01,840
that that's the actual process of

00:26:55,950 --> 00:27:03,309
stuffing your user-defined when I say

00:27:01,840 --> 00:27:08,410
user I mean user the library user

00:27:03,309 --> 00:27:10,420
defined types there there's another kind

00:27:08,410 --> 00:27:14,550
of tricky thing here which is that when

00:27:10,420 --> 00:27:17,860
you are getting a packet off of a socket

00:27:14,550 --> 00:27:22,510
you don't know what type you're gonna

00:27:17,860 --> 00:27:26,860
get you do know but you it's it's in the

00:27:22,510 --> 00:27:28,510
header of the packet usually and it it's

00:27:26,860 --> 00:27:29,860
you know there's some clear mapping but

00:27:28,510 --> 00:27:31,770
the point is that you don't know what

00:27:29,860 --> 00:27:34,510
type you're going to get at compile time

00:27:31,770 --> 00:27:39,940
you you have to do something to get the

00:27:34,510 --> 00:27:42,190
right type at runtime and the reason

00:27:39,940 --> 00:27:47,950
this is like might be like for some

00:27:42,190 --> 00:27:49,150
people is that it it I think people will

00:27:47,950 --> 00:27:52,150
probably immediately think you have to

00:27:49,150 --> 00:27:54,690
dynamically allocate something in order

00:27:52,150 --> 00:27:54,690
to make this happen

00:28:02,820 --> 00:28:11,220
sorry so this is like again some

00:28:07,690 --> 00:28:13,690
pseudocode saying what we need to do is

00:28:11,220 --> 00:28:16,809
mean to fill in this magic comment

00:28:13,690 --> 00:28:19,809
because i want to stack allocate my

00:28:16,809 --> 00:28:23,679
message that is coming out of my socket

00:28:19,809 --> 00:28:27,420
that produced some binary blob from a

00:28:23,679 --> 00:28:30,910
socket and I want to deserialize it and

00:28:27,420 --> 00:28:32,860
you know stuff from the stack allocated

00:28:30,910 --> 00:28:35,950
message the data that was gone from the

00:28:32,860 --> 00:28:37,870
socket now when I execute a callback

00:28:35,950 --> 00:28:40,390
I don't execute some behavior that

00:28:37,870 --> 00:28:45,640
operates on that message that we got on

00:28:40,390 --> 00:28:46,290
the other end so this is one way of

00:28:45,640 --> 00:28:50,610
doing it

00:28:46,290 --> 00:28:52,230
basically you it's very straightforward

00:28:50,610 --> 00:28:54,520
you

00:28:52,230 --> 00:28:58,060
kind of there's some stuff missing here

00:28:54,520 --> 00:29:00,160
but you know take the the star quotes

00:28:58,060 --> 00:29:04,720
the start the commented outline here

00:29:00,160 --> 00:29:07,720
place it with this you switch on the the

00:29:04,720 --> 00:29:11,230
header you know you translate whatever

00:29:07,720 --> 00:29:16,120
you got in the packet to an enum type or

00:29:11,230 --> 00:29:19,180
some identifier you deserialize it and

00:29:16,120 --> 00:29:23,830
then you know call back and and this

00:29:19,180 --> 00:29:25,990
will work pretty well if there's no no

00:29:23,830 --> 00:29:27,760
arguments that you have to return out or

00:29:25,990 --> 00:29:30,790
no result that you have return out of

00:29:27,760 --> 00:29:32,620
the callback and this is like really

00:29:30,790 --> 00:29:34,780
straightforward because you know you

00:29:32,620 --> 00:29:36,430
have a function the the type is known

00:29:34,780 --> 00:29:38,770
the result of your DC realization is

00:29:36,430 --> 00:29:42,490
known whatever but this isn't very

00:29:38,770 --> 00:29:45,850
scalable and the reason that this isn't

00:29:42,490 --> 00:29:47,500
you know generic is and the reason I'm

00:29:45,850 --> 00:29:49,840
concerned about that is because I used

00:29:47,500 --> 00:29:51,790
to work on a middleware where you would

00:29:49,840 --> 00:29:53,470
provide user with this library and then

00:29:51,790 --> 00:29:55,090
they would plug in their own types and

00:29:53,470 --> 00:29:56,680
they can't just you know modify this

00:29:55,090 --> 00:30:01,150
critical section in the library with

00:29:56,680 --> 00:30:02,410
their own switch statement obviously so

00:30:01,150 --> 00:30:04,450
so we need some kind of callback

00:30:02,410 --> 00:30:06,520
registration and here's another you know

00:30:04,450 --> 00:30:10,660
pretty naive way of doing it is you have

00:30:06,520 --> 00:30:12,610
some callback map type and and it stored

00:30:10,660 --> 00:30:17,200
somewhere maybe it's global or maybe

00:30:12,610 --> 00:30:20,080
it's passed around to the the like

00:30:17,200 --> 00:30:23,770
socket deserialization thread and then

00:30:20,080 --> 00:30:26,410
the the user has a function pointer or

00:30:23,770 --> 00:30:28,900
the user provides a function pointer to

00:30:26,410 --> 00:30:30,460
the map based on some identifier and

00:30:28,900 --> 00:30:33,270
we've switched from using enums to

00:30:30,460 --> 00:30:38,680
strings here because I was kind of lazy

00:30:33,270 --> 00:30:40,480
so you then when you you reach you have

00:30:38,680 --> 00:30:42,460
to identify in the package structure

00:30:40,480 --> 00:30:43,630
that you have a user defined to type and

00:30:42,460 --> 00:30:44,830
then when you're in your switch

00:30:43,630 --> 00:30:47,530
statement you have to say alright I'm

00:30:44,830 --> 00:30:50,230
gonna look up my in my callback map what

00:30:47,530 --> 00:30:51,700
what the function was and call it and

00:30:50,230 --> 00:30:54,670
I'm huge disadvantage of this approach

00:30:51,700 --> 00:30:58,360
is that the user has to basically

00:30:54,670 --> 00:31:01,030
provide a some deserialization mechanism

00:30:58,360 --> 00:31:03,750
if they're in the using this pattern and

00:31:01,030 --> 00:31:06,289
they have to call deserialize themselves

00:31:03,750 --> 00:31:08,700
they're they're providing the type of

00:31:06,289 --> 00:31:11,159
the thing they're deserializing here

00:31:08,700 --> 00:31:16,649
which is kind of nice because we can

00:31:11,159 --> 00:31:19,769
still stack allocate the message but

00:31:16,649 --> 00:31:22,860
there's a lot of room for error it's not

00:31:19,769 --> 00:31:24,960
very it's not Ted constrained and and

00:31:22,860 --> 00:31:26,610
that kind of bothers me so so I was like

00:31:24,960 --> 00:31:27,149
I really like metaprogramming this is

00:31:26,610 --> 00:31:29,850
fun

00:31:27,149 --> 00:31:33,000
so can we make something that's that's

00:31:29,850 --> 00:31:35,750
more generic and that works kind of well

00:31:33,000 --> 00:31:41,070
so I thought a little bit about it

00:31:35,750 --> 00:31:44,070
another really cool tool that that

00:31:41,070 --> 00:31:46,830
everyone should use is a compile time

00:31:44,070 --> 00:31:49,379
map so I thought oh we can you know we

00:31:46,830 --> 00:31:51,299
can like match the the types of these

00:31:49,379 --> 00:31:52,320
messages to a call back and then call

00:31:51,299 --> 00:31:55,799
the call back

00:31:52,320 --> 00:31:59,759
whatever it's gonna be great there's a

00:31:55,799 --> 00:32:00,990
disadvantage of this that and we'll get

00:31:59,759 --> 00:32:02,940
more into the code there's a

00:32:00,990 --> 00:32:05,250
disadvantage of this approach that you

00:32:02,940 --> 00:32:08,370
can't define the call back map that

00:32:05,250 --> 00:32:12,090
registers are callbacks in a separate

00:32:08,370 --> 00:32:15,149
translation unit from where the user

00:32:12,090 --> 00:32:16,649
will register the callbacks and the user

00:32:15,149 --> 00:32:20,669
will probably register the callbacks in

00:32:16,649 --> 00:32:23,629
the main function well or in their own

00:32:20,669 --> 00:32:26,460
user provided like library but I

00:32:23,629 --> 00:32:28,740
actually decided this was like totally

00:32:26,460 --> 00:32:31,409
fine because when you do develop

00:32:28,740 --> 00:32:32,789
embedded development you basically you

00:32:31,409 --> 00:32:35,820
need to statically compiled everything

00:32:32,789 --> 00:32:38,639
into one binary so maybe it's okay if we

00:32:35,820 --> 00:32:43,110
provide the user with tools that are all

00:32:38,639 --> 00:32:45,750
like our header only so this is probably

00:32:43,110 --> 00:32:48,179
not very clear so we'll do another code

00:32:45,750 --> 00:32:54,000
example am i doing on time oh my gosh

00:32:48,179 --> 00:33:00,450
okay so let's see this is one

00:32:54,000 --> 00:33:06,350
implementation of the non non generic

00:33:00,450 --> 00:33:09,120
approach I described where let's see

00:33:06,350 --> 00:33:11,179
yeah it's you know very straightforward

00:33:09,120 --> 00:33:16,870
it's almost literally what I wrote on

00:33:11,179 --> 00:33:20,830
the slide this is

00:33:16,870 --> 00:33:23,710
some attempt to implement the compile

00:33:20,830 --> 00:33:32,320
time or the metaprogramming approach of

00:33:23,710 --> 00:33:34,870
what I described so we have a we have

00:33:32,320 --> 00:33:43,570
some some map structure that we can

00:33:34,870 --> 00:33:47,200
iterate through and we okay so we store

00:33:43,570 --> 00:33:50,050
the types of the messages we're going to

00:33:47,200 --> 00:33:53,200
deserialize and map them to functions

00:33:50,050 --> 00:33:56,470
that the user can register and then we

00:33:53,200 --> 00:34:02,230
search through that map we haven't we

00:33:56,470 --> 00:34:06,790
have to match the the type keys of that

00:34:02,230 --> 00:34:10,780
map to runtime values which are the the

00:34:06,790 --> 00:34:13,409
string identifiers or the but encoded

00:34:10,780 --> 00:34:16,590
identifier for the message type that we

00:34:13,409 --> 00:34:20,919
decode so the the user has to provide

00:34:16,590 --> 00:34:23,470
the type that's the thing they're

00:34:20,919 --> 00:34:24,730
deserializing the identifier to match it

00:34:23,470 --> 00:34:29,520
to which is probably going to be defined

00:34:24,730 --> 00:34:33,879
by our protocol and the callback and so

00:34:29,520 --> 00:34:36,750
what we do is we store those in a

00:34:33,879 --> 00:34:42,070
compiled time map and we also store a

00:34:36,750 --> 00:34:45,730
sequence which matches a run time string

00:34:42,070 --> 00:34:48,250
identifier to a type and that type is

00:34:45,730 --> 00:34:52,000
actually a type value as defined by our

00:34:48,250 --> 00:34:54,639
meta programming library and we do

00:34:52,000 --> 00:34:57,690
something that is like you know kind of

00:34:54,639 --> 00:35:02,220
questionable which is a linear search

00:34:57,690 --> 00:35:06,970
through the map when we receive the

00:35:02,220 --> 00:35:10,270
packet on D serialization and that's in

00:35:06,970 --> 00:35:14,130
orbit so that we can then match the

00:35:10,270 --> 00:35:17,830
header of our packet to the correct type

00:35:14,130 --> 00:35:20,890
so this is like it's like fun to write

00:35:17,830 --> 00:35:25,870
this is some syntactic sugar to build up

00:35:20,890 --> 00:35:28,840
the the callback map and what it looks

00:35:25,870 --> 00:35:30,280
like in the wild is like a really nice

00:35:28,840 --> 00:35:34,570
API

00:35:30,280 --> 00:35:36,670
you this is imagine the user is

00:35:34,570 --> 00:35:40,420
registering their various callbacks and

00:35:36,670 --> 00:35:41,950
they can basically pass in a lambda and

00:35:40,420 --> 00:35:44,170
then they can find anything they want to

00:35:41,950 --> 00:35:47,260
the lambda this is a benchmark so I'm

00:35:44,170 --> 00:35:52,030
doing like some naive thing to make sure

00:35:47,260 --> 00:35:53,560
that that the the inputs to the are

00:35:52,030 --> 00:36:00,190
deserialization callback doesn't get

00:35:53,560 --> 00:36:01,750
optimized out so and then because I want

00:36:00,190 --> 00:36:04,990
to write fewer lines of code I decided

00:36:01,750 --> 00:36:07,930
and I happen to have a latest and

00:36:04,990 --> 00:36:10,960
greatest clang compiled on my computer

00:36:07,930 --> 00:36:13,480
we're using destructuring I suppose with

00:36:10,960 --> 00:36:14,950
17 in structured bindings here if

00:36:13,480 --> 00:36:19,230
anyone's not familiar with that syntax

00:36:14,950 --> 00:36:22,830
yet so so this looks really nice and

00:36:19,230 --> 00:36:26,770
this is like maybe preferable to this

00:36:22,830 --> 00:36:31,380
other approach I came up with which is

00:36:26,770 --> 00:36:35,590
probably you know very low overhead but

00:36:31,380 --> 00:36:37,960
has more room for for error on the part

00:36:35,590 --> 00:36:42,120
of the user who writes these callbacks

00:36:37,960 --> 00:36:44,410
that are provided to a map unfortunately

00:36:42,120 --> 00:36:47,320
things didn't go so well when I actually

00:36:44,410 --> 00:36:52,300
benchmarked it so I think thank god i

00:36:47,320 --> 00:36:54,940
bench marked it and again this is a like

00:36:52,300 --> 00:36:56,890
back of the envelope calculation the

00:36:54,940 --> 00:36:58,210
number I wanted to see how it scaled in

00:36:56,890 --> 00:37:00,880
the number of callbacks I didn't go up

00:36:58,210 --> 00:37:02,410
to like 100 callbacks realistically I

00:37:00,880 --> 00:37:06,900
think in a library like this you would

00:37:02,410 --> 00:37:10,660
expect like around 20 callbacks but the

00:37:06,900 --> 00:37:13,180
generic approach that I that involves a

00:37:10,660 --> 00:37:17,080
compile time map it actually ends up not

00:37:13,180 --> 00:37:23,250
scaling as well as this like all static

00:37:17,080 --> 00:37:27,370
callback approach so that's like a a

00:37:23,250 --> 00:37:29,700
valuable lesson at the very least I

00:37:27,370 --> 00:37:32,680
think the lesson to be learned here is

00:37:29,700 --> 00:37:37,590
you should just just benchmark things

00:37:32,680 --> 00:37:42,160
and it's it's really obvious but I think

00:37:37,590 --> 00:37:43,650
there's a there can be a culture of I am

00:37:42,160 --> 00:37:46,620
going to write something that

00:37:43,650 --> 00:37:48,600
I think will be that will work really

00:37:46,620 --> 00:37:50,430
well and like pushing a lot of logic to

00:37:48,600 --> 00:37:55,800
compile time obviously means things will

00:37:50,430 --> 00:37:57,510
run faster but that's what I run or

00:37:55,800 --> 00:38:00,510
compile down to a smaller code binary

00:37:57,510 --> 00:38:05,040
size which is our goal here and the

00:38:00,510 --> 00:38:08,760
other the other caveat here is that I

00:38:05,040 --> 00:38:11,250
was using this library serial to

00:38:08,760 --> 00:38:13,770
implement serialization that works

00:38:11,250 --> 00:38:15,960
really well and it can actually be

00:38:13,770 --> 00:38:18,450
extended to other serialization types so

00:38:15,960 --> 00:38:20,970
it by default it uses its own binary

00:38:18,450 --> 00:38:25,170
encoding but you can write your own

00:38:20,970 --> 00:38:28,440
stuff to serialize to XML and JSON or

00:38:25,170 --> 00:38:31,130
your own encoding which is what I do if

00:38:28,440 --> 00:38:34,980
I'm implementing at a networking library

00:38:31,130 --> 00:38:38,580
what I actually ended up doing is right

00:38:34,980 --> 00:38:41,280
basically writing my own CDR which is

00:38:38,580 --> 00:38:46,470
the art EPS spec serialization format

00:38:41,280 --> 00:38:49,860
another acronym I wrote my own CD Rd

00:38:46,470 --> 00:38:53,700
serialization format for this because

00:38:49,860 --> 00:38:55,590
serial uses both are ttin exceptions it

00:38:53,700 --> 00:38:57,420
uses exceptions it just as an error

00:38:55,590 --> 00:39:01,260
handling mechanism and it uses our TTI

00:38:57,420 --> 00:39:05,910
to as a part of its I believe it's as a

00:39:01,260 --> 00:39:07,320
part of its encoding function so as kind

00:39:05,910 --> 00:39:10,590
of like it as as a type identifier

00:39:07,320 --> 00:39:12,420
because that's what our TJ's and so so

00:39:10,590 --> 00:39:14,910
it's it's really not it's not gonna

00:39:12,420 --> 00:39:17,640
scale well to small embedded devices but

00:39:14,910 --> 00:39:19,230
it's a really nice interface and a nice

00:39:17,640 --> 00:39:22,440
paradigm because of what I showed you

00:39:19,230 --> 00:39:26,010
with you you can externally define

00:39:22,440 --> 00:39:28,740
serialization mechanisms for structs and

00:39:26,010 --> 00:39:31,470
I think that is a it's either there's a

00:39:28,740 --> 00:39:34,770
library that is open source and nice

00:39:31,470 --> 00:39:36,810
like that that is is it might exist but

00:39:34,770 --> 00:39:39,390
I'm not aware of it if anyone is then

00:39:36,810 --> 00:39:47,100
please raise your hand and mention it

00:39:39,390 --> 00:39:49,470
now okay so that kind of covers part one

00:39:47,100 --> 00:39:51,540
of what I mentioned are it's it's a

00:39:49,470 --> 00:39:53,240
taste of what I mentioned goes into

00:39:51,540 --> 00:39:56,820
implementing a networking library

00:39:53,240 --> 00:39:58,980
sockets and threads is is

00:39:56,820 --> 00:40:02,850
kind of a lot of stuff a lot more

00:39:58,980 --> 00:40:04,860
acronyms so this is comparing how

00:40:02,850 --> 00:40:09,720
different operating systems are gonna

00:40:04,860 --> 00:40:12,330
manage threading standards and sockets

00:40:09,720 --> 00:40:15,330
because actually all POSIX generally

00:40:12,330 --> 00:40:18,090
refers to P threads and and Linux you

00:40:15,330 --> 00:40:20,190
might have Berkeley sockets whatever and

00:40:18,090 --> 00:40:21,570
and and the interfaces to sockets and

00:40:20,190 --> 00:40:25,340
threads are gonna be different on

00:40:21,570 --> 00:40:28,100
different operating systems in the arm

00:40:25,340 --> 00:40:30,240
world which is what and in the arm know

00:40:28,100 --> 00:40:32,370
OS world which is what we're talking

00:40:30,240 --> 00:40:34,470
about today there is as I mentioned

00:40:32,370 --> 00:40:37,140
before this abstraction layer between

00:40:34,470 --> 00:40:38,670
different real-time operating systems

00:40:37,140 --> 00:40:42,030
and those different real-time operating

00:40:38,670 --> 00:40:44,340
systems provide thread threading

00:40:42,030 --> 00:40:48,740
abstractions and there's also an

00:40:44,340 --> 00:40:51,840
interface to this library called

00:40:48,740 --> 00:40:53,940
lightweight IP which I've pronounced in

00:40:51,840 --> 00:40:58,830
my head I'll whip every time sounds kind

00:40:53,940 --> 00:41:01,500
of weird and you know this is like kind

00:40:58,830 --> 00:41:03,750
of another abstraction layer for for

00:41:01,500 --> 00:41:09,630
nice operating systems things that we

00:41:03,750 --> 00:41:10,710
want but unfortunately there's not all

00:41:09,630 --> 00:41:14,130
of the things that we want are

00:41:10,710 --> 00:41:17,190
accessible and and that's why embedded

00:41:14,130 --> 00:41:18,870
programming is hard right so we we have

00:41:17,190 --> 00:41:22,710
some nice ways of dealing with

00:41:18,870 --> 00:41:25,530
concurrency and threading in the desktop

00:41:22,710 --> 00:41:28,050
computing world which includes standard

00:41:25,530 --> 00:41:30,060
thread which we all probably really

00:41:28,050 --> 00:41:33,620
appreciated when xi came out and then

00:41:30,060 --> 00:41:36,840
this library called SEO which is the

00:41:33,620 --> 00:41:39,480
kind of the de facto standard or that

00:41:36,840 --> 00:41:44,250
the proposed standard for that the for

00:41:39,480 --> 00:41:48,450
c++ and the the design of of SEO is

00:41:44,250 --> 00:41:51,870
going into the networking ts so

00:41:48,450 --> 00:41:56,520
unfortunately the the C++ standard

00:41:51,870 --> 00:41:58,470
library provided by arm does not include

00:41:56,520 --> 00:42:03,500
thread in fact this is a direct quote

00:41:58,470 --> 00:42:06,930
from their user manual which is great so

00:42:03,500 --> 00:42:10,230
and and this makes sense if you think

00:42:06,930 --> 00:42:13,470
about it they don't want to impose a

00:42:10,230 --> 00:42:16,530
an artists implementation on users of

00:42:13,470 --> 00:42:22,350
the arm C++ standard library for

00:42:16,530 --> 00:42:24,600
embedded no OS systems because the the

00:42:22,350 --> 00:42:25,980
operating systems abstractions are like

00:42:24,600 --> 00:42:34,020
a choice that you compile into your

00:42:25,980 --> 00:42:36,090
binary but and also as a point threading

00:42:34,020 --> 00:42:42,480
and concurrency is built into the

00:42:36,090 --> 00:42:47,460
architecture of Ezio it basically I am

00:42:42,480 --> 00:42:48,750
yeah I'm not a developer on as you but

00:42:47,460 --> 00:42:51,750
I've looked a little at the source code

00:42:48,750 --> 00:42:54,600
and there were basically wrappers for

00:42:51,750 --> 00:42:58,650
different platforms for Windows and for

00:42:54,600 --> 00:43:00,750
POSIX and before 11 they had you know

00:42:58,650 --> 00:43:02,790
their own threading abstraction and and

00:43:00,750 --> 00:43:04,109
the only requirement which seems like a

00:43:02,790 --> 00:43:06,480
very permissive requirement is that you

00:43:04,109 --> 00:43:08,100
need to implement thread join when

00:43:06,480 --> 00:43:12,180
you're blocking on another thread for it

00:43:08,100 --> 00:43:15,710
to finish execution so I thought you

00:43:12,180 --> 00:43:18,720
know okay a fun example to show people

00:43:15,710 --> 00:43:22,080
yeah so so wrapping sockets

00:43:18,720 --> 00:43:26,060
is like yeah that's probably just mostly

00:43:22,080 --> 00:43:28,170
API wrapping not so interesting but how

00:43:26,060 --> 00:43:32,119
how hard is it to compare the

00:43:28,170 --> 00:43:36,119
concurrency primitives provided to us in

00:43:32,119 --> 00:43:38,510
you know this abstraction layer with

00:43:36,119 --> 00:43:41,310
that abstraction layer which is

00:43:38,510 --> 00:43:45,900
dependency of this abstraction layer so

00:43:41,310 --> 00:43:47,640
that we can just like throw in Osseo and

00:43:45,900 --> 00:43:53,550
standard thread and have super

00:43:47,640 --> 00:43:54,090
cross-platform clean C++ code yeah so

00:43:53,550 --> 00:43:56,970
that's the point

00:43:54,090 --> 00:44:01,730
I just made and this is gonna be another

00:43:56,970 --> 00:44:01,730
code except water

00:44:08,150 --> 00:44:16,880
has this font size give me better okay

00:44:15,200 --> 00:44:25,440
there we go

00:44:16,880 --> 00:44:29,910
so the the CSS interface to concurrency

00:44:25,440 --> 00:44:34,890
primitives gives us signals threads new

00:44:29,910 --> 00:44:39,240
Texas event queues some kind of nice

00:44:34,890 --> 00:44:41,790
stuff and and the way the API works is

00:44:39,240 --> 00:44:44,849
through these things that look like

00:44:41,790 --> 00:44:48,450
functions but are actually macros this

00:44:44,849 --> 00:44:50,490
OS thread def thing yeah so it's

00:44:48,450 --> 00:44:51,720
actually a macro and I was confused by

00:44:50,490 --> 00:44:53,280
that initially because it's not in all

00:44:51,720 --> 00:44:58,740
uppercase as some people like to do it

00:44:53,280 --> 00:45:00,900
but it defines a another function using

00:44:58,740 --> 00:45:04,650
the name of the function pointer that

00:45:00,900 --> 00:45:07,049
you cut up you have passed to it which

00:45:04,650 --> 00:45:13,700
was like not the most intuitive API at

00:45:07,049 --> 00:45:15,990
first so I decided to wrap that in

00:45:13,700 --> 00:45:24,450
something that looked a bit nicer which

00:45:15,990 --> 00:45:32,309
is a thread that uses our III to take a

00:45:24,450 --> 00:45:34,980
function and run run and then manage

00:45:32,309 --> 00:45:38,970
signal handling so that any threads that

00:45:34,980 --> 00:45:43,319
are blocking on it can can block

00:45:38,970 --> 00:45:46,230
accordingly and then clean up

00:45:43,319 --> 00:45:49,470
accordingly based on the necessary calls

00:45:46,230 --> 00:45:53,280
that are needed by the artist to signal

00:45:49,470 --> 00:45:58,920
to the kernel that it's done so this is

00:45:53,280 --> 00:46:03,799
um this is a pretty standard and you

00:45:58,920 --> 00:46:07,400
know short way of doing this there's

00:46:03,799 --> 00:46:09,299
let's see you kind of step through

00:46:07,400 --> 00:46:12,150
initialization I didn't make this

00:46:09,299 --> 00:46:15,390
default constructible you what you could

00:46:12,150 --> 00:46:16,950
do is have another state where you Divac

00:46:15,390 --> 00:46:19,320
instruct a thread and

00:46:16,950 --> 00:46:21,630
and once you pass it a function you

00:46:19,320 --> 00:46:25,920
start running the function here what I

00:46:21,630 --> 00:46:29,220
do is I use a lambda to wrap the given

00:46:25,920 --> 00:46:35,060
function and type erase it to a

00:46:29,220 --> 00:46:38,250
different signature basically the

00:46:35,060 --> 00:46:41,760
threading library we're dealing with the

00:46:38,250 --> 00:46:44,760
CM suspending abstraction it requires

00:46:41,760 --> 00:46:48,900
you to start threads with a function

00:46:44,760 --> 00:46:50,160
signature of boycotts are or contoured

00:46:48,900 --> 00:46:54,150
star depending on where you like to put

00:46:50,160 --> 00:46:56,040
the const which means you you can't you

00:46:54,150 --> 00:47:00,900
can't modify the arguments which is

00:46:56,040 --> 00:47:03,570
pretty important here and i kind of a

00:47:00,900 --> 00:47:06,270
type of razor makes me sad but this is

00:47:03,570 --> 00:47:09,480
just a it you know a requisite for

00:47:06,270 --> 00:47:13,079
working with this library so you pretty

00:47:09,480 --> 00:47:17,070
straightforward you you know recast your

00:47:13,079 --> 00:47:19,470
thread argument you if it was null you

00:47:17,070 --> 00:47:21,390
do something which might be thrown

00:47:19,470 --> 00:47:25,890
exception but also right now it's just

00:47:21,390 --> 00:47:28,560
terminate you call a function and then

00:47:25,890 --> 00:47:34,170
you signal to any argue threads that

00:47:28,560 --> 00:47:38,940
were waiting on you to stop and so

00:47:34,170 --> 00:47:40,680
unlike POSIX where you can repeat

00:47:38,940 --> 00:47:42,839
threads where you can interrupt threads

00:47:40,680 --> 00:47:45,990
using like a particularly predefined

00:47:42,839 --> 00:47:55,560
signal I actually define the custom

00:47:45,990 --> 00:47:59,250
signal up here so so when when when you

00:47:55,560 --> 00:48:01,440
call join on a thread object what you're

00:47:59,250 --> 00:48:03,390
doing is you're you have a handle to

00:48:01,440 --> 00:48:06,900
another thread and you're you block

00:48:03,390 --> 00:48:10,800
until the thread represented by that

00:48:06,900 --> 00:48:12,810
handle is done so the you the thread

00:48:10,800 --> 00:48:14,579
handle that you have has a storage for

00:48:12,810 --> 00:48:18,660
the IDs of all the other threads that

00:48:14,579 --> 00:48:22,920
you're waiting on so to implement join

00:48:18,660 --> 00:48:24,869
we want to check first that we were an

00:48:22,920 --> 00:48:28,170
action weren't already signaled to

00:48:24,869 --> 00:48:29,920
terminate because if you're if you block

00:48:28,170 --> 00:48:33,609
after a signal has been sent

00:48:29,920 --> 00:48:36,630
then you will probably just block

00:48:33,609 --> 00:48:42,880
forever because you've missed the signal

00:48:36,630 --> 00:48:47,170
you notify the thread handle that you

00:48:42,880 --> 00:48:52,140
are blocking and then you wait forever

00:48:47,170 --> 00:48:54,460
on that thread ID to the the other

00:48:52,140 --> 00:49:01,260
basically the other threat of control to

00:48:54,460 --> 00:49:03,609
send a signal to you and in in a more

00:49:01,260 --> 00:49:05,410
complex situation and something that's

00:49:03,609 --> 00:49:07,750
not just like a canned example I would

00:49:05,410 --> 00:49:10,240
probably have more logic to handle time

00:49:07,750 --> 00:49:11,470
outs so rather than actually waiting

00:49:10,240 --> 00:49:14,829
forever I would wait for a fixed amount

00:49:11,470 --> 00:49:18,190
of time and then do something after a

00:49:14,829 --> 00:49:20,589
timeout but this is a minimal example

00:49:18,190 --> 00:49:24,730
you might also want to handle other

00:49:20,589 --> 00:49:28,410
signals but this is that's a I think

00:49:24,730 --> 00:49:33,970
that's yeah it's an application oriented

00:49:28,410 --> 00:49:36,700
thing and that's you know that's it I

00:49:33,970 --> 00:49:38,349
think again this is a naive

00:49:36,700 --> 00:49:44,770
implementation but I think joined is not

00:49:38,349 --> 00:49:47,920
that hard to implement and our

00:49:44,770 --> 00:49:52,540
implementation did introduce some

00:49:47,920 --> 00:49:56,609
overhead so I basically compared you can

00:49:52,540 --> 00:49:56,609
pull up another thing that I forgot to

00:50:08,450 --> 00:50:13,950
this is gonna be great you can see all

00:50:12,360 --> 00:50:19,560
about the monolithic directory

00:50:13,950 --> 00:50:27,720
structures I went into this yeah okay

00:50:19,560 --> 00:50:35,730
great so this is a can see example that

00:50:27,720 --> 00:50:40,380
was again this is like showing the ship

00:50:35,730 --> 00:50:49,820
an example of the the c style c emphasis

00:50:40,380 --> 00:50:49,820
api yeah okay

00:50:51,870 --> 00:50:56,640
and then the kind of you know cleaner

00:50:53,430 --> 00:51:08,270
see postmodern c++ style implementation

00:50:56,640 --> 00:51:11,610
of it so as you can see here the

00:51:08,270 --> 00:51:17,100
callbacks or the the thread functions

00:51:11,610 --> 00:51:20,550
are provided basically without the in

00:51:17,100 --> 00:51:25,070
order to bind arguments to this you

00:51:20,550 --> 00:51:29,130
would have to define global variables oh

00:51:25,070 --> 00:51:35,030
no you you you would pass arguments when

00:51:29,130 --> 00:51:35,030
you call the OS third created macro but

00:51:35,630 --> 00:51:42,420
again there's a more kind of tie barrier

00:51:40,380 --> 00:51:45,390
and casting involved to pass arguments

00:51:42,420 --> 00:51:47,700
around so that's what i'm benchmarking

00:51:45,390 --> 00:51:50,850
and and there is overhead in the Super

00:51:47,700 --> 00:51:53,070
Plus wrapper but that overhead is kind

00:51:50,850 --> 00:51:54,990
of expected because we've added run

00:51:53,070 --> 00:51:59,100
obviously we've added runtime logic to

00:51:54,990 --> 00:52:00,780
handle the threat signaling at the point

00:51:59,100 --> 00:52:06,390
I'm trying to make here is that join is

00:52:00,780 --> 00:52:11,060
is not hard to implement but I still see

00:52:06,390 --> 00:52:13,010
why the thread abstraction was left out

00:52:11,060 --> 00:52:16,980
obviously because the compiler

00:52:13,010 --> 00:52:20,369
implementing lib C++ doesn't want to

00:52:16,980 --> 00:52:23,579
impose a threading paradigm or or an

00:52:20,369 --> 00:52:26,180
artists library on the users who don't

00:52:23,579 --> 00:52:29,099
want an OS so then the artists

00:52:26,180 --> 00:52:32,009
implementers would have to provide an

00:52:29,099 --> 00:52:36,329
implementation of thread mutex condition

00:52:32,009 --> 00:52:39,059
variable etc but they usually don't

00:52:36,329 --> 00:52:44,999
in fact they usually don't have much C++

00:52:39,059 --> 00:52:47,789
support and that's kind of rough because

00:52:44,999 --> 00:52:49,349
these are nice abstractions that we'd

00:52:47,789 --> 00:52:52,160
like to be made available to everyone

00:52:49,349 --> 00:52:56,420
and I'm seeing into the future here

00:52:52,160 --> 00:53:00,509
seeing that the networking TS depends on

00:52:56,420 --> 00:53:04,049
threading abstractions and I so because

00:53:00,509 --> 00:53:06,150
I've I know that I already feel as if or

00:53:04,049 --> 00:53:11,099
have a feeling that the networking TS

00:53:06,150 --> 00:53:14,640
will not be provided by the maintainer

00:53:11,099 --> 00:53:16,799
zuv arm no ABI

00:53:14,640 --> 00:53:24,529
live super flows and and that makes me

00:53:16,799 --> 00:53:26,880
sad because really the what makes

00:53:24,529 --> 00:53:30,269
innovation and and technology move

00:53:26,880 --> 00:53:33,299
forward faster is if people have nice to

00:53:30,269 --> 00:53:38,489
use abstractions in their hands that

00:53:33,299 --> 00:53:40,230
that are fun to use and powerful and and

00:53:38,489 --> 00:53:43,619
there's a bit more overhead that goes

00:53:40,230 --> 00:53:46,470
into wrapping all this really huge

00:53:43,619 --> 00:53:50,099
variety of libraries that are available

00:53:46,470 --> 00:53:52,109
to us but but the point of finding the

00:53:50,099 --> 00:53:57,480
abstractions in the right place is that

00:53:52,109 --> 00:54:02,279
we eventually get rid of more overhead

00:53:57,480 --> 00:54:04,890
that the users have to do and as I kind

00:54:02,279 --> 00:54:08,009
of wrote here the text on this slide I

00:54:04,890 --> 00:54:09,450
find really important that and I think

00:54:08,009 --> 00:54:12,539
this is a really important distinction

00:54:09,450 --> 00:54:20,039
between desktop and embedded development

00:54:12,539 --> 00:54:23,069
is that the the the compiler is kind of

00:54:20,039 --> 00:54:24,950
like tightly coupled to system calls in

00:54:23,069 --> 00:54:27,660
a lot of places in the CFO flow standard

00:54:24,950 --> 00:54:29,380
and system calls I mean operating system

00:54:27,660 --> 00:54:31,360
API and

00:54:29,380 --> 00:54:34,570
on embedded that's intentionally a

00:54:31,360 --> 00:54:38,230
really loose connection or no connection

00:54:34,570 --> 00:54:40,390
at all and I think kind of the language

00:54:38,230 --> 00:54:42,900
designers are standards designers have

00:54:40,390 --> 00:54:47,260
to think carefully about that

00:54:42,900 --> 00:54:49,900
relationship and to me as a user I'm not

00:54:47,260 --> 00:54:53,200
really sure that was kind of fun all the

00:54:49,900 --> 00:54:57,360
way through but again I'm a user and not

00:54:53,200 --> 00:55:00,520
a maker of these standards so who knows

00:54:57,360 --> 00:55:03,610
so another point I kind of wanted to

00:55:00,520 --> 00:55:07,600
make about my adventures writing this

00:55:03,610 --> 00:55:11,050
library is that one one one thing about

00:55:07,600 --> 00:55:15,610
this the specification for this protocol

00:55:11,050 --> 00:55:20,760
is that it's very object oriented and by

00:55:15,610 --> 00:55:20,760
that I mean the the language describes

00:55:21,390 --> 00:55:27,820
objects hierarchies are kind of UML

00:55:25,180 --> 00:55:30,660
diagrams between objects and it provides

00:55:27,820 --> 00:55:34,270
this API that kind of looks like Java

00:55:30,660 --> 00:55:36,520
and says you know you have let's say you

00:55:34,270 --> 00:55:39,070
have a custom publisher that that

00:55:36,520 --> 00:55:41,320
publishes type foo well you're obviously

00:55:39,070 --> 00:55:45,250
going to call it food publisher rather

00:55:41,320 --> 00:55:48,550
than saying you have a concept or you

00:55:45,250 --> 00:55:52,300
have a you have a template you have some

00:55:48,550 --> 00:55:56,170
generic thing that has that acts on data

00:55:52,300 --> 00:55:59,160
in this particular way and and I kind of

00:55:56,170 --> 00:56:03,580
think that in order to make these

00:55:59,160 --> 00:56:05,410
standards and protocols easier to write

00:56:03,580 --> 00:56:07,840
then people have to take a different

00:56:05,410 --> 00:56:13,090
design paradigm what I find interesting

00:56:07,840 --> 00:56:16,750
about DDS is that it there's there's

00:56:13,090 --> 00:56:18,580
some places in the spec with like C++

00:56:16,750 --> 00:56:20,710
specific language in some places with

00:56:18,580 --> 00:56:22,330
Java specific language and then it's

00:56:20,710 --> 00:56:23,620
kind of like well if you're gonna give

00:56:22,330 --> 00:56:26,110
me a code example why don't give me a

00:56:23,620 --> 00:56:28,480
full code example then actually give me

00:56:26,110 --> 00:56:29,800
pseudo code but again this is kind of

00:56:28,480 --> 00:56:33,220
all out of scope and if you have

00:56:29,800 --> 00:56:36,100
thoughts on this then totally hit me up

00:56:33,220 --> 00:56:40,180
after this I kind of already made this

00:56:36,100 --> 00:56:42,560
point but this was a this is really fun

00:56:40,180 --> 00:56:44,000
undertaking for me I'm

00:56:42,560 --> 00:56:49,490
actually a hobbyist on this project

00:56:44,000 --> 00:56:51,290
right now it's not my day job but I I

00:56:49,490 --> 00:56:53,480
really strongly believe that if we're

00:56:51,290 --> 00:56:56,270
going to make c++ on embedded happen

00:56:53,480 --> 00:56:58,370
because this is like the year of CL also

00:56:56,270 --> 00:57:03,520
embedded kind of like you know desktop

00:56:58,370 --> 00:57:05,810
on Linux on we're gonna make that happen

00:57:03,520 --> 00:57:08,030
then we need better libraries and we

00:57:05,810 --> 00:57:10,250
need good libraries to keep in mind the

00:57:08,030 --> 00:57:12,940
limitations that embedded system

00:57:10,250 --> 00:57:14,780
developers have I want to be able to use

00:57:12,940 --> 00:57:16,520
cereal for civilization without

00:57:14,780 --> 00:57:19,460
exceptions in our TTI I want to be able

00:57:16,520 --> 00:57:21,770
to use a lot of boosts libraries without

00:57:19,460 --> 00:57:24,580
the kind of weird design gaps that

00:57:21,770 --> 00:57:44,300
taking out those parts of the language

00:57:24,580 --> 00:58:03,230
introduces but yeah questions yeah I've

00:57:44,300 --> 00:58:14,690
never heard of but whether it's useful

00:58:03,230 --> 00:58:16,760
or not is the separate question right

00:58:14,690 --> 00:58:30,100
it's just should this new future be

00:58:16,760 --> 00:58:30,100
freestanding of limitations and then so

00:58:30,610 --> 00:58:35,180
to to repeat that it wasn't really a

00:58:33,230 --> 00:58:38,090
question it was more of a point of

00:58:35,180 --> 00:58:39,200
information some some people in the

00:58:38,090 --> 00:58:41,060
committee and the audience have pointed

00:58:39,200 --> 00:58:44,120
out there's language and the standard

00:58:41,060 --> 00:58:47,210
for free standing start free-standing

00:58:44,120 --> 00:58:49,550
implementations okay which I was gonna

00:58:47,210 --> 00:58:53,140
ask is the the difference between a

00:58:49,550 --> 00:58:53,140
free-standing implementation and a TS

00:58:53,920 --> 00:58:57,559
hosted version okay

00:58:56,180 --> 00:59:01,930
we should talk later but that's an

00:58:57,559 --> 00:59:03,140
interesting point okay I can't read them

00:59:01,930 --> 00:59:12,680
okay

00:59:03,140 --> 00:59:14,750
more questions yeah I could I could sort

00:59:12,680 --> 00:59:23,770
them lexicographically and then do a

00:59:14,750 --> 01:00:10,880
binary search can they can the keys be

00:59:23,770 --> 01:00:12,650
runtime determines yeah so when you say

01:00:10,880 --> 01:00:18,970
extra luggage you mean

01:00:12,650 --> 01:00:18,970
code size or just general resources or

01:00:33,870 --> 01:00:45,210
oh this is most uh yes why did I say

01:00:43,350 --> 01:00:49,500
this is the year people's well embedded

01:00:45,210 --> 01:00:54,360
I also wanted to make the Linux on

01:00:49,500 --> 01:00:57,390
desktop joke but seriously the this I

01:00:54,360 --> 01:00:59,240
think this is like set by the CPG on

01:00:57,390 --> 01:01:02,070
organizers one of whom is in the room

01:00:59,240 --> 01:01:08,340
decided to have a keynote from Dan sacks

01:01:02,070 --> 01:01:13,680
who's also in this room and a plenary

01:01:08,340 --> 01:01:15,630
session by Jason who was writing code

01:01:13,680 --> 01:01:17,360
for the Commodore 64 which is

01:01:15,630 --> 01:01:20,190
essentially you know in the class of the

01:01:17,360 --> 01:01:23,760
some of the tinier embedded devices you

01:01:20,190 --> 01:01:25,530
can have so yeah I'm just observing that

01:01:23,760 --> 01:01:26,760
there's like this agenda that the

01:01:25,530 --> 01:02:00,960
conference organizers are pushing I

01:01:26,760 --> 01:02:05,690
don't know if yes let's take more

01:02:00,960 --> 01:02:05,690
questions thanks

01:02:14,740 --> 01:02:21,200
yeah I would have to bench um he asked

01:02:18,920 --> 01:02:25,390
have I considered using brigand which is

01:02:21,200 --> 01:02:30,020
another TMP library yeah I would have to

01:02:25,390 --> 01:02:33,110
do some batch more comparisons the so

01:02:30,020 --> 01:02:36,440
like Louie put out those comparisons of

01:02:33,110 --> 01:02:38,780
different TMP libraries first of all

01:02:36,440 --> 01:02:40,190
have I would have to check that which

01:02:38,780 --> 01:02:42,350
ones provide the functionality that I

01:02:40,190 --> 01:02:45,230
need for patterns that I actually want

01:02:42,350 --> 01:02:46,610
to keep because we showed it that at

01:02:45,230 --> 01:02:52,940
least one pattern I was interested in

01:02:46,610 --> 01:02:56,360
was not as good as yeah and and then I

01:02:52,940 --> 01:02:59,450
would actually have to do like code size

01:02:56,360 --> 01:03:03,230
analysis because I think his benchmarks

01:02:59,450 --> 01:03:08,600
are just compiled time analysis so other

01:03:03,230 --> 01:03:11,710
questions yeah okay

01:03:08,600 --> 01:03:11,710

YouTube URL: https://www.youtube.com/watch?v=mresWGsVHj0


