Title: CppCon 2016: Edouard Alligand & Joel Falcou “Two practical applications of the Brigand TMP library"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Metaprogramming isn’t always easy to apprehend and the purpose of this talk is to show through the resolution of two real life problems where it can be applied to increase productivity and reliability. The first case study will exhibit how we can use TMP to allocate at compile time the required memory for serializing simple structures such as a pair of integers. The second case study will be about generating a memory layout for array of structures perfectly fit for the targeted platform. The examples are based on the Brigand TMP library and will be an opportunity to see how MP constructs such as collection of types and compile time algorithms are made and when they should be used. The talk might contain obscure jokes related to pastries naming.
— 
Edouard Alligand
quasardb
CEO
Paris, France
Edouard has more than thirteen years of professional experience in software engineering. After years hacking the kernel of various operating systems, Edouard founded Bureau 14, the home of the hyperscalable database quasardb. Combining an excellent knowledge of low level programming with a perverse love for template meta-programming, Edouard likes to come up with uncompromising solutions to seemingly impossible problems. He lives in Paris, France.

Joel Falcou
CTO, NUMSCALE
Joel Falcou is NumScale CTO. NumScale mission is to assist businesses in the exploration and subsequently the mastery of high-performance computing systems. | | He is also an assistant professor at the University Paris-Sud and researcher at the Laboratoire de Recherche d’Informatique in Orsay, France.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:03,500
good morning good evening for those who

00:00:02,370 --> 00:00:07,589
are still jet-lagged

00:00:03,500 --> 00:00:11,219
I'm Eduardo and this is aku we are the

00:00:07,589 --> 00:00:12,480
author of the polygon library today we

00:00:11,219 --> 00:00:15,540
are going to spend one hour to explain

00:00:12,480 --> 00:00:19,100
to you what you can do with your library

00:00:15,540 --> 00:00:21,840
and why we design it where it comes from

00:00:19,100 --> 00:00:23,730
there's going to be two practical

00:00:21,840 --> 00:00:27,210
examples of what you can do with it and

00:00:23,730 --> 00:00:30,330
this is examples taking from thank you

00:00:27,210 --> 00:00:37,110
very much coming from actually both of

00:00:30,330 --> 00:00:40,879
our production code so we started to

00:00:37,110 --> 00:00:45,000
work like something like one year ago

00:00:40,879 --> 00:00:47,579
the reason why I started working on this

00:00:45,000 --> 00:00:51,090
is because on the production card we had

00:00:47,579 --> 00:00:54,840
we were massive use of boost MPL which

00:00:51,090 --> 00:00:57,800
is boost metaprogramming library and we

00:00:54,840 --> 00:01:00,660
were getting more and more annoyed with

00:00:57,800 --> 00:01:03,510
the computation time a boost ampere and

00:01:00,660 --> 00:01:06,630
the fact that he's been done in c++ all

00:01:03,510 --> 00:01:09,659
three if you leverage the novelties of

00:01:06,630 --> 00:01:11,939
the C++ 11 language there is a

00:01:09,659 --> 00:01:14,700
possibility to write much more efficient

00:01:11,939 --> 00:01:16,799
meta programming code and I have been

00:01:14,700 --> 00:01:20,520
reading an article written by Peter

00:01:16,799 --> 00:01:24,390
DeMuth which we was I think inspired

00:01:20,520 --> 00:01:27,840
from something done by Eric niba and I

00:01:24,390 --> 00:01:30,630
realize that would be very easy to easy

00:01:27,840 --> 00:01:33,900
relatively easy to write a meta

00:01:30,630 --> 00:01:35,280
programming library and Gerald joined me

00:01:33,900 --> 00:01:38,159
right after because he was working

00:01:35,280 --> 00:01:42,150
almost exactly the same thing on his own

00:01:38,159 --> 00:01:43,860
and the source code is available on

00:01:42,150 --> 00:01:46,079
github and it's the boost software

00:01:43,860 --> 00:01:51,869
license so there is really no constraint

00:01:46,079 --> 00:01:55,619
on how you can use it the question that

00:01:51,869 --> 00:01:58,200
comes very often is why should I care

00:01:55,619 --> 00:01:59,600
about meta programming library what

00:01:58,200 --> 00:02:02,729
should I care about meta programming

00:01:59,600 --> 00:02:05,820
isn't meta programming something which

00:02:02,729 --> 00:02:08,099
is extremely advanced C++ do I really

00:02:05,820 --> 00:02:10,470
need it and we hope that at the end of

00:02:08,099 --> 00:02:12,220
the hour you will think that it's

00:02:10,470 --> 00:02:15,790
actually useful

00:02:12,220 --> 00:02:17,920
even if it were 100% useless it's a very

00:02:15,790 --> 00:02:20,220
very very good mental exercise and it

00:02:17,920 --> 00:02:26,260
will make you a better programmer I

00:02:20,220 --> 00:02:27,970
believe so this talk we start then we're

00:02:26,260 --> 00:02:30,430
going to explain the principle of

00:02:27,970 --> 00:02:33,520
polygons what you have inside the

00:02:30,430 --> 00:02:37,180
library how it works then we're going to

00:02:33,520 --> 00:02:43,480
show you two use cases and then it will

00:02:37,180 --> 00:02:45,790
be time for questions thank you so let's

00:02:43,480 --> 00:02:48,100
see what's what's inside brilliant so as

00:02:45,790 --> 00:02:52,900
hello says Regan is actually based on

00:02:48,100 --> 00:02:55,090
the general principle of boost MPL which

00:02:52,900 --> 00:02:58,960
means that we reuse a bunch of their

00:02:55,090 --> 00:03:02,650
contexts or concepts so as MPL what we

00:02:58,960 --> 00:03:05,020
do is you don't want to end all mr.

00:03:02,650 --> 00:03:06,970
programming components in divide by

00:03:05,020 --> 00:03:09,400
writing random template functions and

00:03:06,970 --> 00:03:11,890
random temper classes you need to have

00:03:09,400 --> 00:03:15,640
some kind of structure and the structure

00:03:11,890 --> 00:03:18,190
we took is pacifist boost ampere one

00:03:15,640 --> 00:03:21,370
which we which rely on this separation

00:03:18,190 --> 00:03:25,090
between compile time algorithms working

00:03:21,370 --> 00:03:29,200
on compile time sequence using compact

00:03:25,090 --> 00:03:31,120
and functions so we we have this subset

00:03:29,200 --> 00:03:35,820
of algorithmic functions that is

00:03:31,120 --> 00:03:40,720
respected there where you we are very

00:03:35,820 --> 00:03:43,720
well limited but useful list of sequence

00:03:40,720 --> 00:03:46,060
so post MPA is known to have stuff like

00:03:43,720 --> 00:03:49,690
compile time vector compile time list

00:03:46,060 --> 00:03:52,570
compiled time ash Maps compile time set

00:03:49,690 --> 00:03:54,550
and so on and in fact the only ones that

00:03:52,570 --> 00:03:57,340
actually make sense those three which is

00:03:54,550 --> 00:03:59,400
a list the settings of map difference

00:03:57,340 --> 00:04:03,310
between this and vector are completely

00:03:59,400 --> 00:04:06,820
well i'm confidential so we will get rid

00:04:03,310 --> 00:04:09,070
of that so you you end all by which you

00:04:06,820 --> 00:04:11,500
usually started writing code by fitting

00:04:09,070 --> 00:04:14,739
something in the sequence on which you

00:04:11,500 --> 00:04:16,209
can apply some algorithms like finding

00:04:14,739 --> 00:04:18,100
touch in the sequence counting how many

00:04:16,209 --> 00:04:21,789
times something is acting in the

00:04:18,100 --> 00:04:23,560
sequence transforming it sort merge

00:04:21,789 --> 00:04:24,610
enacted so on and so on and so on and

00:04:23,560 --> 00:04:26,889
you can use

00:04:24,610 --> 00:04:29,590
pre-built function

00:04:26,889 --> 00:04:34,749
to build your your computation on the

00:04:29,590 --> 00:04:37,840
types and one of the most fancy stuff in

00:04:34,749 --> 00:04:39,759
Bregan is the as something functions

00:04:37,840 --> 00:04:42,009
that connected you actually help you

00:04:39,759 --> 00:04:44,560
turn a sequence of something into

00:04:42,009 --> 00:04:46,060
another kind of sequence or ending up

00:04:44,560 --> 00:04:47,800
with is okay I finished compiling

00:04:46,060 --> 00:04:49,539
something in the sequence of times and

00:04:47,800 --> 00:04:51,669
now I want a total of that or I want to

00:04:49,539 --> 00:04:54,400
apply into that and so on and so on so

00:04:51,669 --> 00:04:57,939
we have easy way to go back into let's

00:04:54,400 --> 00:04:59,770
say a non compiled time code so the

00:04:57,939 --> 00:05:05,979
question is what is actually a sequence

00:04:59,770 --> 00:05:09,189
in terms of methylamine and what is what

00:05:05,979 --> 00:05:12,129
is a core element of that so in Busan PL

00:05:09,189 --> 00:05:15,129
a sequence was something that has a

00:05:12,129 --> 00:05:17,020
definite tag that was fitting some

00:05:15,129 --> 00:05:20,439
interface that's a boost template

00:05:17,020 --> 00:05:23,520
function we're able to recognize what we

00:05:20,439 --> 00:05:26,949
do is thrown that everywhere away and

00:05:23,520 --> 00:05:30,210
type list in brigant is any type which

00:05:26,949 --> 00:05:33,009
has Viaduct parameters of types so

00:05:30,210 --> 00:05:34,509
brigand list is a list because it's

00:05:33,009 --> 00:05:38,110
something which is also form breaking

00:05:34,509 --> 00:05:43,449
list T dot dot and so is STD table also

00:05:38,110 --> 00:05:45,460
is STD variant and whatnot so is this TD

00:05:43,449 --> 00:05:47,110
vector or example XI fronting two types

00:05:45,460 --> 00:05:49,419
of types and the allocator type so as

00:05:47,110 --> 00:05:51,729
long as your type is a template type

00:05:49,419 --> 00:05:53,949
with a list of something it's it's valid

00:05:51,729 --> 00:05:56,800
compile-time list and this actually

00:05:53,949 --> 00:05:58,569
makes a lot of things very simpler to

00:05:56,800 --> 00:06:01,449
manipulate so we don't need anymore to

00:05:58,569 --> 00:06:03,189
have a special MPL adapter that takes

00:06:01,449 --> 00:06:04,899
some types and turn it into a sequence

00:06:03,189 --> 00:06:08,319
everything that looks like this is a

00:06:04,899 --> 00:06:10,389
sequence and a small detail we also have

00:06:08,319 --> 00:06:15,219
way to properly end all strange types

00:06:10,389 --> 00:06:16,839
like void or cysteine array and we don't

00:06:15,219 --> 00:06:19,089
care about what's inside these of type

00:06:16,839 --> 00:06:21,219
list so as long as you have a temperate

00:06:19,089 --> 00:06:22,990
class with varrick template list you're

00:06:21,219 --> 00:06:25,719
set you want to compile time brigand

00:06:22,990 --> 00:06:28,870
list so what do we do on that well you

00:06:25,719 --> 00:06:30,819
can do the usual operation in this like

00:06:28,870 --> 00:06:31,659
adding a type popping your type finding

00:06:30,819 --> 00:06:34,990
something

00:06:31,659 --> 00:06:37,240
concatenating two lists see also

00:06:34,990 --> 00:06:38,850
simplification with respect when PR is

00:06:37,240 --> 00:06:40,770
as a fact everything is

00:06:38,850 --> 00:06:43,350
so you don't need to do type name

00:06:40,770 --> 00:06:45,180
something something that doctype you

00:06:43,350 --> 00:06:48,480
just fly to meter function on the list

00:06:45,180 --> 00:06:49,350
and you get the nose of this directly so

00:06:48,480 --> 00:06:51,180
everything works

00:06:49,350 --> 00:06:53,160
I collected two written on the can so

00:06:51,180 --> 00:06:54,360
you either found this one you can pop

00:06:53,160 --> 00:06:59,520
the front of his to you and you can

00:06:54,360 --> 00:07:03,900
append those lists and done and the very

00:06:59,520 --> 00:07:05,070
interesting for parts of most compile

00:07:03,900 --> 00:07:07,820
time libraries is the fact you can

00:07:05,070 --> 00:07:10,230
actually run an algorithm like transform

00:07:07,820 --> 00:07:13,380
on the list of types applying an

00:07:10,230 --> 00:07:15,600
arbitrary so called meta function or

00:07:13,380 --> 00:07:16,980
meter function class which is some

00:07:15,600 --> 00:07:18,180
things that say I'm taking your type as

00:07:16,980 --> 00:07:20,820
a parameters and I'm written in your

00:07:18,180 --> 00:07:22,500
type with some transformation so for

00:07:20,820 --> 00:07:24,330
example if you want to go from this list

00:07:22,500 --> 00:07:25,740
of trouble and into something which is

00:07:24,330 --> 00:07:27,420
be the same list but with pointer

00:07:25,740 --> 00:07:30,120
everywhere you can just say okay

00:07:27,420 --> 00:07:32,130
transform this list and it for every

00:07:30,120 --> 00:07:34,290
type in the lace just add a pointer to

00:07:32,130 --> 00:07:36,480
the current type so this is also

00:07:34,290 --> 00:07:37,980
something we take a page from NPR by

00:07:36,480 --> 00:07:42,660
using this kind of pre soldiers that

00:07:37,980 --> 00:07:45,330
looks like lambda placeholders can also

00:07:42,660 --> 00:07:47,280
add stuff like to find and another set

00:07:45,330 --> 00:07:51,510
of functions that Walker exists so fine

00:07:47,280 --> 00:07:55,550
we give you a way to look for typing in

00:07:51,510 --> 00:07:59,070
sequence or for the types that actually

00:07:55,550 --> 00:08:00,840
fulfill a given condition the way boost

00:07:59,070 --> 00:08:03,920
a Pierre was in in this was having a

00:08:00,840 --> 00:08:07,190
concept of meter compile time iterator

00:08:03,920 --> 00:08:10,350
which was rather complex so what we do

00:08:07,190 --> 00:08:12,360
is actually use a range based approach

00:08:10,350 --> 00:08:15,180
so when you find something in the list

00:08:12,360 --> 00:08:16,890
what it does it consumes the Taipings at

00:08:15,180 --> 00:08:19,290
least until you find something and it

00:08:16,890 --> 00:08:21,300
will return you that this which is so

00:08:19,290 --> 00:08:23,430
that the first element in the list is

00:08:21,300 --> 00:08:24,750
one type we are looking for and you have

00:08:23,430 --> 00:08:26,820
the rest of the list at your disposal

00:08:24,750 --> 00:08:29,340
which means that if you want to well

00:08:26,820 --> 00:08:31,560
look for the second one you can pop from

00:08:29,340 --> 00:08:33,349
this this energy star type and find

00:08:31,560 --> 00:08:35,789
again on the remaining of the list and

00:08:33,349 --> 00:08:37,950
sometimes what you want to do is not to

00:08:35,789 --> 00:08:40,080
find something you don't care if you

00:08:37,950 --> 00:08:42,990
where is it what you want to know if is

00:08:40,080 --> 00:08:45,930
it inside so we have a found function

00:08:42,990 --> 00:08:50,130
that say basically can I did I find

00:08:45,930 --> 00:08:52,380
something in my in my list that was

00:08:50,130 --> 00:08:52,709
fulfilling some some value and you get

00:08:52,380 --> 00:08:57,779
to

00:08:52,709 --> 00:08:59,910
I'll tell you yes or no and finally same

00:08:57,779 --> 00:09:01,769
way that Empire was doing this we need a

00:08:59,910 --> 00:09:03,689
bunch of bridges to go back on the

00:09:01,769 --> 00:09:04,980
compile time to the run time word so we

00:09:03,689 --> 00:09:08,129
have a for each functions that take

00:09:04,980 --> 00:09:11,689
parameters which is a compile time type

00:09:08,129 --> 00:09:15,119
list and you can pass an arbitrary

00:09:11,689 --> 00:09:18,209
lambda function or rentals that takes a

00:09:15,119 --> 00:09:20,699
brilliant type of T as a parameters and

00:09:18,209 --> 00:09:22,829
you can do whatever you want with this T

00:09:20,699 --> 00:09:24,749
inside like printing its name

00:09:22,829 --> 00:09:27,029
instantiating the year calling a

00:09:24,749 --> 00:09:29,360
function and it and so on the reason we

00:09:27,029 --> 00:09:31,679
do this with this type wrapper

00:09:29,360 --> 00:09:35,089
especially because we want to be able to

00:09:31,679 --> 00:09:38,220
a place that contain avoid or other

00:09:35,089 --> 00:09:39,749
non-intentional types so this is a small

00:09:38,220 --> 00:09:42,569
price to pay to get something which is

00:09:39,749 --> 00:09:46,709
more homogeneous in terms of where we we

00:09:42,569 --> 00:09:49,679
actually end those types so now it's

00:09:46,709 --> 00:09:52,379
time for our first use case it were okay

00:09:49,679 --> 00:09:54,629
thank you I'm going to give you some

00:09:52,379 --> 00:09:58,110
context about the use case so in my

00:09:54,629 --> 00:10:00,920
company we sell a database it's a client

00:09:58,110 --> 00:10:04,829
server and so the client and the server

00:10:00,920 --> 00:10:08,399
exchanges exchange messages and what we

00:10:04,829 --> 00:10:10,110
want to do is to see what are we going

00:10:08,399 --> 00:10:12,749
to break the protocol in the new version

00:10:10,110 --> 00:10:16,139
what happens if we add a new message and

00:10:12,749 --> 00:10:18,870
we would like to do that with the

00:10:16,139 --> 00:10:21,629
minimum amount of effort possible every

00:10:18,870 --> 00:10:25,889
time we do something and the idea is to

00:10:21,629 --> 00:10:27,540
use template metaprogramming to do

00:10:25,889 --> 00:10:31,019
compile time introspection and

00:10:27,540 --> 00:10:34,620
generation and see if the sequence of

00:10:31,019 --> 00:10:36,749
bytes matches the structure we have and

00:10:34,620 --> 00:10:41,279
if the structure we have matches the

00:10:36,749 --> 00:10:43,290
sequence of bytes and if we look at the

00:10:41,279 --> 00:10:45,720
whole work that we have to do of course

00:10:43,290 --> 00:10:47,600
not everything can be solved with Legon

00:10:45,720 --> 00:10:52,559
because you can imagine there is a

00:10:47,600 --> 00:10:55,589
sterilization there is a type inspection

00:10:52,559 --> 00:10:58,339
we use a booth fusion for that but Vega

00:10:55,589 --> 00:11:01,889
is going to help us in those two stages

00:10:58,339 --> 00:11:05,100
and we're going to see that it actually

00:11:01,889 --> 00:11:09,300
is absolutely not stratospheric code it

00:11:05,100 --> 00:11:12,360
very very very easy and I hope you will

00:11:09,300 --> 00:11:15,210
agree with me so the first thing you do

00:11:12,360 --> 00:11:17,190
is you have your messages and every

00:11:15,210 --> 00:11:20,130
message is a structure this is the way

00:11:17,190 --> 00:11:22,950
the code is organized and what's very

00:11:20,130 --> 00:11:25,680
interesting is that the messages don't

00:11:22,950 --> 00:11:27,870
have to have any relation between each

00:11:25,680 --> 00:11:30,840
other meaning that you don't need to

00:11:27,870 --> 00:11:32,790
have any returns you don't have to do

00:11:30,840 --> 00:11:35,880
any kind of polymorphism you can have

00:11:32,790 --> 00:11:39,140
two structures that share absolutely

00:11:35,880 --> 00:11:41,160
nothing and still use this technique so

00:11:39,140 --> 00:11:43,980
personally from an algebraic point of

00:11:41,160 --> 00:11:45,990
view I think it's very powerful but the

00:11:43,980 --> 00:11:47,790
only thing you have to do is to somehow

00:11:45,990 --> 00:11:51,900
have a list of all these messages

00:11:47,790 --> 00:11:54,540
somewhere and this list is a list of

00:11:51,900 --> 00:11:57,540
types so what we're going to use is

00:11:54,540 --> 00:11:59,880
going to use a polygon list but we could

00:11:57,540 --> 00:12:02,190
imagine imagine a program where you

00:11:59,880 --> 00:12:04,110
would have let's say a variant because

00:12:02,190 --> 00:12:05,790
let's say your message is a variant and

00:12:04,110 --> 00:12:09,300
then you would not even have to do this

00:12:05,790 --> 00:12:12,660
step which is we put all the command in

00:12:09,300 --> 00:12:15,060
the list in the card we have we put in

00:12:12,660 --> 00:12:18,030
different lists for the kind of message

00:12:15,060 --> 00:12:20,250
we have and then we can contain all the

00:12:18,030 --> 00:12:23,850
lists into one big list that we're going

00:12:20,250 --> 00:12:25,620
to use to do the processing you have a

00:12:23,850 --> 00:12:28,170
lot of flexibility in the way you can do

00:12:25,620 --> 00:12:31,560
this you can also use the push back push

00:12:28,170 --> 00:12:33,900
for whatever function you want the next

00:12:31,560 --> 00:12:37,080
step is that you may want to clean up

00:12:33,900 --> 00:12:40,080
the list imagine you have some messages

00:12:37,080 --> 00:12:41,970
that you are going to duplicate and that

00:12:40,080 --> 00:12:43,710
you go know that you don't really want

00:12:41,970 --> 00:12:46,770
to test for with backward or forward

00:12:43,710 --> 00:12:50,330
compatibility anymore the technique we

00:12:46,770 --> 00:12:53,460
use is to have a type which is

00:12:50,330 --> 00:12:56,010
deprecated and which is going to signal

00:12:53,460 --> 00:12:58,620
that this message is going to be

00:12:56,010 --> 00:13:01,230
duplicated very soon and we're going to

00:12:58,620 --> 00:13:04,260
use that in an algorithm to remove them

00:13:01,230 --> 00:13:06,960
from the list just after them we also

00:13:04,260 --> 00:13:10,110
use an ID to have a unique message

00:13:06,960 --> 00:13:11,930
identifier this is something you do we

00:13:10,110 --> 00:13:14,089
do in our case

00:13:11,930 --> 00:13:15,800
a very efficient technique in

00:13:14,089 --> 00:13:17,240
metaprogramming to have a unique idea

00:13:15,800 --> 00:13:20,870
for every message and we're going to see

00:13:17,240 --> 00:13:23,980
at the end what you can do with this so

00:13:20,870 --> 00:13:26,690
how do we remove a duplicate in message

00:13:23,980 --> 00:13:29,570
again the goal is to write us little

00:13:26,690 --> 00:13:32,060
code as possible in boost now you have

00:13:29,570 --> 00:13:35,660
something code type

00:13:32,060 --> 00:13:37,850
I think it's TTI's for boost type

00:13:35,660 --> 00:13:40,430
introspection library I think so you

00:13:37,850 --> 00:13:44,209
don't have to write anymore the old s in

00:13:40,430 --> 00:13:46,220
a code or any trick you just do please

00:13:44,209 --> 00:13:48,380
generate for me a meta function which is

00:13:46,220 --> 00:13:52,610
going to be named as type duplicated for

00:13:48,380 --> 00:13:56,450
me and what we do is we use the remove

00:13:52,610 --> 00:13:59,810
if algorithm on our list use the

00:13:56,450 --> 00:14:02,810
function provided and not unlike stood

00:13:59,810 --> 00:14:05,500
bind we say will be used the Riggin

00:14:02,810 --> 00:14:08,240
placeholder and we get the list without

00:14:05,500 --> 00:14:11,839
the deprecated flag and it would work

00:14:08,240 --> 00:14:13,700
for any flag let's say you have message

00:14:11,839 --> 00:14:17,089
that works on a specific platform and

00:14:13,700 --> 00:14:21,440
you just want to test every platform one

00:14:17,089 --> 00:14:23,600
by one you could use this technique then

00:14:21,440 --> 00:14:25,120
let's say you want to sort the messages

00:14:23,600 --> 00:14:29,770
by ID

00:14:25,120 --> 00:14:32,150
you could also want to sort them by size

00:14:29,770 --> 00:14:35,270
again we're going to use the breaker

00:14:32,150 --> 00:14:37,459
algorithm which is sort and the only

00:14:35,270 --> 00:14:40,700
trick we're going to do is to write this

00:14:37,459 --> 00:14:43,310
little function to say by the way we

00:14:40,700 --> 00:14:46,160
want to look at the ID member of every

00:14:43,310 --> 00:14:50,390
message and we want to use that as a

00:14:46,160 --> 00:14:54,320
criteria to do the sorting and then we

00:14:50,390 --> 00:14:57,020
used quote to basically say to sort a by

00:14:54,320 --> 00:15:01,130
the way this is the functor you're going

00:14:57,020 --> 00:15:03,320
to use for sorting this is extremely

00:15:01,130 --> 00:15:04,970
straightforward of course here you can

00:15:03,320 --> 00:15:06,660
imagine that you have the whole list of

00:15:04,970 --> 00:15:15,720
messages

00:15:06,660 --> 00:15:17,910
and once once we what superward and once

00:15:15,720 --> 00:15:19,770
we have that then we got in the meat of

00:15:17,910 --> 00:15:23,130
the thing it's when we bridge

00:15:19,770 --> 00:15:25,860
compile-time code with runtime code so

00:15:23,130 --> 00:15:28,710
the polygon library helped us to do all

00:15:25,860 --> 00:15:30,510
the compile time code to inspect every

00:15:28,710 --> 00:15:34,620
time make sure we don't forget any type

00:15:30,510 --> 00:15:37,140
there is no room for typos or I forget a

00:15:34,620 --> 00:15:38,280
message you are 100% certain that every

00:15:37,140 --> 00:15:41,850
message you're going to get in your

00:15:38,280 --> 00:15:44,460
functor is going to be the message you

00:15:41,850 --> 00:15:47,070
want to test and here all you have to do

00:15:44,460 --> 00:15:49,770
is to once you have your type you want

00:15:47,070 --> 00:15:52,560
then you just can create institution the

00:15:49,770 --> 00:15:54,870
type you can call your seller ization

00:15:52,560 --> 00:15:56,910
code or let's imagine you all you want

00:15:54,870 --> 00:15:59,400
to do is to generate the documentation

00:15:56,910 --> 00:16:02,130
you could also here just print the list

00:15:59,400 --> 00:16:05,670
if that's what you want this is just an

00:16:02,130 --> 00:16:07,230
ID that we I want to give you then you

00:16:05,670 --> 00:16:10,620
imagination can find many other

00:16:07,230 --> 00:16:15,780
applications I'm sure it goes too far so

00:16:10,620 --> 00:16:19,500
as a homework you can say let's detect

00:16:15,780 --> 00:16:24,150
at compile time that I don't have

00:16:19,500 --> 00:16:26,730
duplicate IDs this is something you can

00:16:24,150 --> 00:16:29,460
try I can give you a hint you just need

00:16:26,730 --> 00:16:31,170
to use the proper structure it's

00:16:29,460 --> 00:16:34,680
something like two lines of we go I

00:16:31,170 --> 00:16:37,050
think and this means that when you code

00:16:34,680 --> 00:16:40,230
compiles you know you not have duplicate

00:16:37,050 --> 00:16:42,450
IDs and if you've worked one time in

00:16:40,230 --> 00:16:44,460
your life client-server application you

00:16:42,450 --> 00:16:47,700
know that duplicate IDs in messages can

00:16:44,460 --> 00:16:50,700
be very nicely but this way at compile

00:16:47,700 --> 00:16:53,970
Pipkin correlation time you know that at

00:16:50,700 --> 00:16:58,790
least this is correct and the earlier

00:16:53,970 --> 00:16:58,790
you find a bug the less expensive it is

00:17:00,450 --> 00:17:12,010
question so the question is do we have

00:17:09,459 --> 00:17:17,130
something to count the IDS at some pie

00:17:12,010 --> 00:17:20,740
time to increment no we don't have it in

00:17:17,130 --> 00:17:22,390
Riga to do it it's it's funny because

00:17:20,740 --> 00:17:26,470
I've been asked exactly the same

00:17:22,390 --> 00:17:28,329
question by someone else I think it

00:17:26,470 --> 00:17:31,810
would be not very hard to do it within a

00:17:28,329 --> 00:17:33,730
single CPP file the problem is if you

00:17:31,810 --> 00:17:37,870
wanted to do it across different CPP

00:17:33,730 --> 00:17:39,790
files this is much harder but in our

00:17:37,870 --> 00:17:44,980
case all the messages are in the headers

00:17:39,790 --> 00:17:47,460
so you could imagine that you have CPP

00:17:44,980 --> 00:17:50,050
file which is reference and that creates

00:17:47,460 --> 00:17:52,980
the new idea every time it's in

00:17:50,050 --> 00:17:56,200
distinction you could create a list of

00:17:52,980 --> 00:17:58,870
integers for example and you would add a

00:17:56,200 --> 00:18:01,270
new version every time you can actually

00:17:58,870 --> 00:18:03,160
use a set maybe yeah so you can actually

00:18:01,270 --> 00:18:14,620
count and detect duplicates at the same

00:18:03,160 --> 00:18:17,350
time Bing Maps and sets so I think with

00:18:14,620 --> 00:18:20,650
a set it's not too difficult to solve

00:18:17,350 --> 00:18:24,850
this problem and actually we could even

00:18:20,650 --> 00:18:31,140
add something but I going to do it for

00:18:24,850 --> 00:18:31,140
you what do you think you Roger clay

00:18:40,640 --> 00:18:44,850
the question is does the Zeta generator

00:18:43,290 --> 00:18:46,920
phase at compile time all right time

00:18:44,850 --> 00:18:49,470
it's a very good question and I fail to

00:18:46,920 --> 00:18:52,200
explain that at the beginning the

00:18:49,470 --> 00:18:54,200
generator creates a program which then

00:18:52,200 --> 00:18:57,810
you run and going to generate the code

00:18:54,200 --> 00:19:01,410
with the test and in our case it's boost

00:18:57,810 --> 00:19:04,890
test code but at compile time you don't

00:19:01,410 --> 00:19:06,750
do everything because in our case we

00:19:04,890 --> 00:19:09,420
have combined time serialization code

00:19:06,750 --> 00:19:11,970
etc but taking a structure with the

00:19:09,420 --> 00:19:13,890
membrane utilized see realize that in

00:19:11,970 --> 00:19:19,140
the bytes are away you can only do it a

00:19:13,890 --> 00:19:21,390
run time sir exactly

00:19:19,140 --> 00:19:24,300
so the the remark was you use we use

00:19:21,390 --> 00:19:26,370
template metaprogramming to generate the

00:19:24,300 --> 00:19:27,990
test code which is then going to be

00:19:26,370 --> 00:19:29,730
incorporated in the continuous

00:19:27,990 --> 00:19:35,940
integration and this is exactly what we

00:19:29,730 --> 00:19:37,620
do no other question okay so let's go on

00:19:35,940 --> 00:19:40,290
to the second use case which come from a

00:19:37,620 --> 00:19:42,540
completely different type of application

00:19:40,290 --> 00:19:44,850
so I've known scale we deal with high

00:19:42,540 --> 00:19:46,230
performance computing tools and one of

00:19:44,850 --> 00:19:48,360
the stuff you read quickly when you do

00:19:46,230 --> 00:19:50,820
this is that your your data processing

00:19:48,360 --> 00:19:52,460
code is only as fast as its cache

00:19:50,820 --> 00:19:55,500
friendly because basically right now

00:19:52,460 --> 00:19:56,880
what came it's a computer for processing

00:19:55,500 --> 00:19:58,590
speed is more than memory speeds and

00:19:56,880 --> 00:20:00,690
anything else so if you want to take

00:19:58,590 --> 00:20:04,110
care of actually using the most of your

00:20:00,690 --> 00:20:05,910
hardware you need to be currently you

00:20:04,110 --> 00:20:08,190
can find fabrication in the wire that's

00:20:05,910 --> 00:20:10,350
a path of if you don't take care of your

00:20:08,190 --> 00:20:12,450
cache you're basically wasting 90% of

00:20:10,350 --> 00:20:16,050
your CPU power so you don't want to do

00:20:12,450 --> 00:20:18,570
that and one way to actually be able to

00:20:16,050 --> 00:20:21,930
manage to to get out services of these

00:20:18,570 --> 00:20:24,330
bugs kind of things is to manage the

00:20:21,930 --> 00:20:27,060
data layout of your computation so you

00:20:24,330 --> 00:20:29,720
know that whatever you do you're okay

00:20:27,060 --> 00:20:34,500
with your cache one way to do this is

00:20:29,720 --> 00:20:36,960
stemming from techniques to end or erase

00:20:34,500 --> 00:20:38,550
off structure the traditional

00:20:36,960 --> 00:20:41,100
object-oriented way want us to have

00:20:38,550 --> 00:20:43,470
stuff like vector of some objects that

00:20:41,100 --> 00:20:45,390
represent your your your data or your

00:20:43,470 --> 00:20:46,830
state and whenever you want to do

00:20:45,390 --> 00:20:49,830
computation on that you just ran over

00:20:46,830 --> 00:20:53,220
your vector or structure and do some

00:20:49,830 --> 00:20:55,139
and some kids years it's it's okay but

00:20:53,220 --> 00:20:58,379
sometimes that's not what you want to do

00:20:55,139 --> 00:21:00,450
because you may want to process data for

00:20:58,379 --> 00:21:02,999
example we have this array of structures

00:21:00,450 --> 00:21:05,279
or arrays square brackets the structure

00:21:02,999 --> 00:21:07,110
is as query 1 let's say you want to do

00:21:05,279 --> 00:21:11,610
something like I want to do the sum of

00:21:07,110 --> 00:21:14,549
all the member m1 and divide every m2 by

00:21:11,610 --> 00:21:15,899
this sum if you do the sum of every m1

00:21:14,549 --> 00:21:19,799
who is this layout you will end up

00:21:15,899 --> 00:21:22,769
wasting out of your cash story m2 you

00:21:19,799 --> 00:21:24,509
don't care about so you may want to have

00:21:22,769 --> 00:21:26,399
a data layout which is more like the

00:21:24,509 --> 00:21:28,289
structure of array where you end up with

00:21:26,399 --> 00:21:31,139
structures that contain an array for

00:21:28,289 --> 00:21:33,629
each members so you end up with value of

00:21:31,139 --> 00:21:36,960
all the member 1 and then value of all

00:21:33,629 --> 00:21:39,509
the member to and in fact the correct

00:21:36,960 --> 00:21:42,590
way to do this is a third way which is

00:21:39,509 --> 00:21:46,019
called the array or structure of array

00:21:42,590 --> 00:21:47,960
which is basically this use as a

00:21:46,019 --> 00:21:50,789
structure into that where you will

00:21:47,960 --> 00:21:53,730
statically limit the size and repeated

00:21:50,789 --> 00:21:55,529
by blocks block size having the good

00:21:53,730 --> 00:21:56,279
idea to be a multiple of the cache size

00:21:55,529 --> 00:21:59,700
and so on

00:21:56,279 --> 00:22:01,499
so you may want to test one of the other

00:21:59,700 --> 00:22:03,720
because sometimes the application you

00:22:01,499 --> 00:22:05,730
write one this and sometimes you want

00:22:03,720 --> 00:22:07,710
that sometimes was the third one and you

00:22:05,730 --> 00:22:09,659
doesn't know so we wanted to have a way

00:22:07,710 --> 00:22:14,669
to say this is a structure she saw was a

00:22:09,659 --> 00:22:17,669
data is layout at the I mean abstraction

00:22:14,669 --> 00:22:21,149
level and give me this kind of data

00:22:17,669 --> 00:22:23,309
layout piece so what we did was taking a

00:22:21,149 --> 00:22:26,279
structure or tuple we build the proper

00:22:23,309 --> 00:22:28,259
presentation and after that what we did

00:22:26,279 --> 00:22:30,929
was building alligators in trailers

00:22:28,259 --> 00:22:32,940
range that can iterate over the

00:22:30,929 --> 00:22:36,119
structure we just build whatever the

00:22:32,940 --> 00:22:37,919
actual layout and so what we did was

00:22:36,119 --> 00:22:39,389
actually using bryggen with boost vision

00:22:37,919 --> 00:22:41,700
to automate the first part which is

00:22:39,389 --> 00:22:44,580
actually rebuilding the data structure

00:22:41,700 --> 00:22:47,190
we use inside so let's say we have a

00:22:44,580 --> 00:22:50,580
small structure which is a float and and

00:22:47,190 --> 00:22:53,129
three integers for example so we use

00:22:50,580 --> 00:22:55,169
booze vision that abstract to say okay

00:22:53,129 --> 00:22:58,409
this this structure that contains these

00:22:55,169 --> 00:23:01,350
four members with XYZ is actually a

00:22:58,409 --> 00:23:02,650
frozen sequence so Fusion sequence are

00:23:01,350 --> 00:23:05,260
made so you can actually a

00:23:02,650 --> 00:23:07,390
by time access an element of a structure

00:23:05,260 --> 00:23:09,880
the same way you access an element of

00:23:07,390 --> 00:23:12,070
the tuple by playing with the fact that

00:23:09,880 --> 00:23:14,380
this tuple and structure are basically

00:23:12,070 --> 00:23:16,930
the same except one as member whose name

00:23:14,380 --> 00:23:18,790
and the other does not so on so we have

00:23:16,930 --> 00:23:22,330
that you could actually use booze fusion

00:23:18,790 --> 00:23:24,700
at on any instance of my data to extract

00:23:22,330 --> 00:23:27,250
the first second third or fourth element

00:23:24,700 --> 00:23:29,770
of the data structure okay so that was

00:23:27,250 --> 00:23:33,640
quite easy now what do we win with that

00:23:29,770 --> 00:23:34,840
well booze fusion give us a fun emitter

00:23:33,640 --> 00:23:38,320
function and the function which is

00:23:34,840 --> 00:23:41,560
called as vector that takes an arbitrary

00:23:38,320 --> 00:23:44,380
fusion sequence and flatten it into a

00:23:41,560 --> 00:23:45,970
boost region vector which happens to be

00:23:44,380 --> 00:23:48,070
interesting when you you end up having

00:23:45,970 --> 00:23:49,900
computing complex tied with fusions and

00:23:48,070 --> 00:23:52,950
you want to go to simple something more

00:23:49,900 --> 00:23:56,020
simple and you know in case if you pass

00:23:52,950 --> 00:23:59,830
even faster fusion adapted struct to as

00:23:56,020 --> 00:24:02,020
vector well you end up with that so what

00:23:59,830 --> 00:24:05,920
it is well it's a type it's a template

00:24:02,020 --> 00:24:09,400
type with a via the number of type

00:24:05,920 --> 00:24:11,020
parameters so this means is directly a

00:24:09,400 --> 00:24:14,560
written list so it doesn't have to do

00:24:11,020 --> 00:24:16,510
anything so we turn our arbitrary fusion

00:24:14,560 --> 00:24:18,790
sequence into a vector which happens to

00:24:16,510 --> 00:24:20,590
be compatible with brigant and now what

00:24:18,790 --> 00:24:23,110
we do is that we can actually virtual it

00:24:20,590 --> 00:24:27,310
the way we want so let's say we have

00:24:23,110 --> 00:24:30,460
this ace away structure something of the

00:24:27,310 --> 00:24:34,270
form container of some things and some

00:24:30,460 --> 00:24:36,490
options so you can walk with list vector

00:24:34,270 --> 00:24:38,140
whatever and take care of all the other

00:24:36,490 --> 00:24:40,450
stuff so what we do is we take the type

00:24:38,140 --> 00:24:43,260
T we turn it into a brigant

00:24:40,450 --> 00:24:45,460
list by calling as breaking so either

00:24:43,260 --> 00:24:47,920
you have something like the tuple

00:24:45,460 --> 00:24:50,230
already or something yes and then you

00:24:47,920 --> 00:24:52,930
get flattened and we extract the vector

00:24:50,230 --> 00:24:55,510
from the inside and what we just do is

00:24:52,930 --> 00:24:58,930
what we want to do is going from the

00:24:55,510 --> 00:25:00,970
container of T to a list of container of

00:24:58,930 --> 00:25:03,370
each member of T which happens to be

00:25:00,970 --> 00:25:06,190
what we do is transform that ran over

00:25:03,370 --> 00:25:10,270
the list of members base and put it

00:25:06,190 --> 00:25:13,390
inside this template template parameters

00:25:10,270 --> 00:25:15,460
container and put all the other option

00:25:13,390 --> 00:25:16,300
afterwards okay

00:25:15,460 --> 00:25:18,040
you could have so

00:25:16,300 --> 00:25:20,950
more complicated that look what's inside

00:25:18,040 --> 00:25:23,880
there and replace whatever t found with

00:25:20,950 --> 00:25:26,350
a very staff and so on for most standard

00:25:23,880 --> 00:25:26,950
container doesn't matter because if it's

00:25:26,350 --> 00:25:29,170
an alligator

00:25:26,950 --> 00:25:32,890
you get rebind inside and so on and so

00:25:29,170 --> 00:25:35,800
on and on so we have that so if we pass

00:25:32,890 --> 00:25:37,840
for example Mike data we end up with the

00:25:35,800 --> 00:25:41,280
list which is a vector or float int int

00:25:37,840 --> 00:25:43,720
int it get turned into a brigand list of

00:25:41,280 --> 00:25:46,870
vector of float vector of in vector of

00:25:43,720 --> 00:25:48,880
in vector of wind but we can do nothing

00:25:46,870 --> 00:25:51,340
with that because I cannot instantiate a

00:25:48,880 --> 00:25:56,350
break in list so what we do is we turn

00:25:51,340 --> 00:25:58,780
it into a topple and SOA to SOA aliases

00:25:56,350 --> 00:26:00,820
just give you the top ball of vector or

00:25:58,780 --> 00:26:04,180
container of whatever you were looking

00:26:00,820 --> 00:26:06,070
at so you pass a vector of structure and

00:26:04,180 --> 00:26:08,380
you end up with the top pole of vector

00:26:06,070 --> 00:26:10,390
or each members of the structure and

00:26:08,380 --> 00:26:12,310
then you can actually instantiate that

00:26:10,390 --> 00:26:17,410
and you get your data layout already

00:26:12,310 --> 00:26:20,530
done in the correct way so having the

00:26:17,410 --> 00:26:24,010
having the data layout done is out of

00:26:20,530 --> 00:26:26,140
the jokes and the question is would you

00:26:24,010 --> 00:26:28,090
write that which is something that say I

00:26:26,140 --> 00:26:30,580
have a container of something and I want

00:26:28,090 --> 00:26:34,330
something which is an iterator so I can

00:26:30,580 --> 00:26:37,420
iterate in a you know structure with way

00:26:34,330 --> 00:26:39,460
on every sub part of the data layout so

00:26:37,420 --> 00:26:41,830
the idea is to do the exact same thing

00:26:39,460 --> 00:26:44,110
and trying to find a way to fit that

00:26:41,830 --> 00:26:48,250
into a zip iterator such with zip over

00:26:44,110 --> 00:26:51,090
every part of the data layout so as in

00:26:48,250 --> 00:26:54,460
terms of performances we show that

00:26:51,090 --> 00:26:56,950
whenever the SOA representation is the

00:26:54,460 --> 00:26:58,690
correct one you can have data feed speed

00:26:56,950 --> 00:27:01,270
up or form two or three depending on the

00:26:58,690 --> 00:27:05,950
complexity of the members you have cases

00:27:01,270 --> 00:27:07,450
where just not loading data from the

00:27:05,950 --> 00:27:10,750
third and fourth member because you

00:27:07,450 --> 00:27:12,850
don't care of it we knew as much space

00:27:10,750 --> 00:27:15,040
in the cache and you can tremendously

00:27:12,850 --> 00:27:16,660
improve the performances so that's a

00:27:15,040 --> 00:27:18,820
small tool we have that's actually very

00:27:16,660 --> 00:27:20,860
useful and the fact that you just have

00:27:18,820 --> 00:27:23,170
to turn it on and off by calling it or

00:27:20,860 --> 00:27:25,180
not on the vector of your structures you

00:27:23,170 --> 00:27:27,970
can quickly test if it's makes sense to

00:27:25,180 --> 00:27:29,660
go to this kind of data layout law you

00:27:27,970 --> 00:27:32,660
can stack stack with the

00:27:29,660 --> 00:27:35,000
a simple one so there's a lot of stuff

00:27:32,660 --> 00:27:37,940
you can do with that that's a beginning

00:27:35,000 --> 00:27:40,040
of the of the idea people are walking on

00:27:37,940 --> 00:27:41,750
having what we call I've ride

00:27:40,040 --> 00:27:44,060
Natalie out we're part of the data

00:27:41,750 --> 00:27:46,160
structure is in an area of structure and

00:27:44,060 --> 00:27:48,830
part of it is Steven structure of array

00:27:46,160 --> 00:27:50,480
so you can actually choose which members

00:27:48,830 --> 00:27:54,470
of the structure you can group by into

00:27:50,480 --> 00:27:56,630
casual not so it was actually probably

00:27:54,470 --> 00:27:58,820
just missing a probably a couple of line

00:27:56,630 --> 00:28:01,670
but everything was brilliant was turning

00:27:58,820 --> 00:28:04,610
to this the the old equivalent MP and

00:28:01,670 --> 00:28:09,940
position code was three times as big so

00:28:04,610 --> 00:28:09,940
it was a win-win so let's conclude now

00:28:10,330 --> 00:28:17,900
thank you so we have time then to have a

00:28:14,840 --> 00:28:20,780
look at how the code looks because the

00:28:17,900 --> 00:28:25,520
example they are very short the

00:28:20,780 --> 00:28:28,520
conclusion we have is that since plus

00:28:25,520 --> 00:28:31,130
plus eleven and even more with C++ 14

00:28:28,520 --> 00:28:34,250
writing template metaprogramming is much

00:28:31,130 --> 00:28:36,860
easier it's much easier for two reasons

00:28:34,250 --> 00:28:40,060
first in the language we have features

00:28:36,860 --> 00:28:43,100
that makes especially variadic templates

00:28:40,060 --> 00:28:45,380
everything more straightforward you

00:28:43,100 --> 00:28:48,140
don't have to use macros to generate a

00:28:45,380 --> 00:28:51,320
lot of classes just to have a list of

00:28:48,140 --> 00:28:54,500
types you even have built in in the

00:28:51,320 --> 00:28:56,120
language now the top which is very very

00:28:54,500 --> 00:28:58,430
powerful tool in template

00:28:56,120 --> 00:29:02,540
metaprogramming because it's a it's a

00:28:58,430 --> 00:29:07,180
candidate for type of list of types the

00:29:02,540 --> 00:29:09,140
other thing is with plus + 11 + c + + 14

00:29:07,180 --> 00:29:13,040
compilation time for template

00:29:09,140 --> 00:29:16,310
metaprogramming is much shorter the most

00:29:13,040 --> 00:29:18,920
freaking comment i heard about template

00:29:16,310 --> 00:29:22,220
metaprogramming is okay sure it's useful

00:29:18,920 --> 00:29:24,500
but before my code took like a couple of

00:29:22,220 --> 00:29:30,290
seconds to compile and now it takes like

00:29:24,500 --> 00:29:32,300
2 days and with Vega we we have instant

00:29:30,290 --> 00:29:35,000
compile time and if it takes a lot of

00:29:32,300 --> 00:29:36,680
time it's your fault it's not awful and

00:29:35,000 --> 00:29:38,480
if I want it to actually be more mean

00:29:36,680 --> 00:29:41,930
than that it's actually instant on file

00:29:38,480 --> 00:29:46,130
time including on that compiler

00:29:41,930 --> 00:29:49,340
we just did oh yes and the code we wrote

00:29:46,130 --> 00:29:52,550
why works on Visual Studio 2013 you need

00:29:49,340 --> 00:29:57,500
the latest update but it works and it's

00:29:52,550 --> 00:30:00,290
in the test and last but not least I

00:29:57,500 --> 00:30:03,290
think it's actually useful it's not just

00:30:00,290 --> 00:30:05,900
something like you could say okay it's I

00:30:03,290 --> 00:30:08,360
did some clever tricks and look at how

00:30:05,900 --> 00:30:10,220
how much a good programmer I am and no

00:30:08,360 --> 00:30:13,490
one understood my code you know it's

00:30:10,220 --> 00:30:16,490
very useful in my case and in the case

00:30:13,490 --> 00:30:19,220
of soil the results is that it took less

00:30:16,490 --> 00:30:21,980
time to achieve the results the code is

00:30:19,220 --> 00:30:24,200
more reliable and you have the feedback

00:30:21,980 --> 00:30:27,320
about the correctness of your actions at

00:30:24,200 --> 00:30:29,360
compile time which is as soon as it's

00:30:27,320 --> 00:30:30,710
humanly possible because sooner than

00:30:29,360 --> 00:30:36,620
that would be in your head but that

00:30:30,710 --> 00:30:39,290
never happens then yes I think the goal

00:30:36,620 --> 00:30:42,980
is to make your job easier we are very

00:30:39,290 --> 00:30:46,460
open to comments and and suggestion as

00:30:42,980 --> 00:30:50,690
always we already about to release

00:30:46,460 --> 00:30:53,480
version 1.3 in our case the library has

00:30:50,690 --> 00:30:56,990
been in production for six months nine

00:30:53,480 --> 00:31:00,260
months and in your case be six to eight

00:30:56,990 --> 00:31:05,750
months - and we know that other peoples

00:31:00,260 --> 00:31:08,510
also use them in their code now we have

00:31:05,750 --> 00:31:11,990
time for questions and we're going to

00:31:08,510 --> 00:31:23,300
look at the layout yes just so I think

00:31:11,990 --> 00:31:27,890
it's a good idea so we we have our D

00:31:23,300 --> 00:31:29,600
subs there you want to get to the to the

00:31:27,890 --> 00:31:37,010
website see other stuff I wanted to

00:31:29,600 --> 00:31:39,070
speak about is the fact that someone is

00:31:37,010 --> 00:31:42,559
actually playing around is you know

00:31:39,070 --> 00:31:45,230
trying to find a rule is actually having

00:31:42,559 --> 00:31:47,300
the fastest MIT programming library so

00:31:45,230 --> 00:31:49,640
with John is maintaining this bench web

00:31:47,300 --> 00:31:51,830
page as a comparable burns of which

00:31:49,640 --> 00:31:54,030
programming libraries on different types

00:31:51,830 --> 00:31:55,740
of algorithms and stuff

00:31:54,030 --> 00:31:58,130
so now which one is the one we should

00:31:55,740 --> 00:32:00,810
show and not the other one do remember

00:31:58,130 --> 00:32:04,620
I'm just I'm just actually just picking

00:32:00,810 --> 00:32:09,660
one at random so yeah so meter is

00:32:04,620 --> 00:32:12,620
another methylamine library from I don't

00:32:09,660 --> 00:32:16,110
remember his name from someone's a guy

00:32:12,620 --> 00:32:19,110
so yeah so the funny thing is to look at

00:32:16,110 --> 00:32:22,560
the x-axis in fact which is a number of

00:32:19,110 --> 00:32:25,530
types in the in the type list okay so

00:32:22,560 --> 00:32:28,920
all it's okay but I wanted to find one

00:32:25,530 --> 00:32:31,950
with MPL actually yeah

00:32:28,920 --> 00:32:36,180
so ampere blows up at 50 or 100

00:32:31,950 --> 00:32:38,190
something and also all the moderns men

00:32:36,180 --> 00:32:40,950
women library can go up to I don't know

00:32:38,190 --> 00:32:43,170
how many times I think ordinance as a

00:32:40,950 --> 00:32:44,010
whip I use use case with 2,000 types or

00:32:43,170 --> 00:32:48,030
something like that

00:32:44,010 --> 00:32:49,680
yeah at some point it works anyone

00:32:48,030 --> 00:32:51,810
there's something interesting to say

00:32:49,680 --> 00:32:54,150
about boost ampere is that you have to

00:32:51,810 --> 00:32:55,680
define specific macros if you want to

00:32:54,150 --> 00:32:58,860
have something like more than 20 types

00:32:55,680 --> 00:33:01,110
in a list so 20 types in a list of types

00:32:58,860 --> 00:33:03,690
can sound like a lot but actually it's

00:33:01,110 --> 00:33:06,300
not that much it's very easy if you do

00:33:03,690 --> 00:33:10,080
tricks like we shown like I want to have

00:33:06,300 --> 00:33:13,710
all my messages in the list 20 messages

00:33:10,080 --> 00:33:16,290
and nothing not in the counties in the

00:33:13,710 --> 00:33:19,440
old version of Busia me we were using

00:33:16,290 --> 00:33:21,990
NPL at some point we need to have we

00:33:19,440 --> 00:33:25,470
have to have these three of types that

00:33:21,990 --> 00:33:27,570
describe suffering over vectors and it

00:33:25,470 --> 00:33:30,870
was blowing up after 20 except for some

00:33:27,570 --> 00:33:33,270
cases you have like 300,000 so doesn't

00:33:30,870 --> 00:33:35,370
work well so that's for examples timing

00:33:33,270 --> 00:33:37,470
for transforms where we still gains at

00:33:35,370 --> 00:33:40,500
well MPF just blow up at some point and

00:33:37,470 --> 00:33:42,480
the modern take on writings is

00:33:40,500 --> 00:33:46,800
methylamine a breeze can you can you

00:33:42,480 --> 00:33:48,630
actually go far far better we also

00:33:46,800 --> 00:33:52,680
happen to the fastest on this one just

00:33:48,630 --> 00:33:57,800
saying that that's not okay so this is

00:33:52,680 --> 00:33:57,800
also a very good there's a question

00:34:01,049 --> 00:34:06,510
it's like when are we ever going to

00:34:14,099 --> 00:34:20,109
question is is benchmarking stuff up to

00:34:17,290 --> 00:34:23,710
500 500 something types is realistic

00:34:20,109 --> 00:34:26,050
well the fact is we actually have people

00:34:23,710 --> 00:34:29,500
with exactly this exact use cases where

00:34:26,050 --> 00:34:31,780
he wanted to build a thousand types list

00:34:29,500 --> 00:34:33,879
and soft it and find the first one that

00:34:31,780 --> 00:34:36,550
fits something before generating a piece

00:34:33,879 --> 00:34:39,070
of code I don't remember the exact

00:34:36,550 --> 00:34:41,260
domain that it was to electronics device

00:34:39,070 --> 00:34:42,879
or whatever where you wanted to

00:34:41,260 --> 00:34:44,740
everything to be computed at compile

00:34:42,879 --> 00:34:46,599
time as much as he can so he can you

00:34:44,740 --> 00:34:48,220
know have the tightest buying be

00:34:46,599 --> 00:34:52,659
possible so we we actually had people

00:34:48,220 --> 00:34:55,060
that play with 32:5 okay now the one

00:34:52,659 --> 00:34:58,480
criticism that Eric did on that which

00:34:55,060 --> 00:35:01,210
was actually natural something question

00:34:58,480 --> 00:35:03,339
which was should we benchmark stuff like

00:35:01,210 --> 00:35:05,380
I have a list of five thousand types all

00:35:03,339 --> 00:35:07,210
the same or five thousand types all

00:35:05,380 --> 00:35:09,700
different because depending on the

00:35:07,210 --> 00:35:11,680
algorithms memoization such a compiler

00:35:09,700 --> 00:35:16,720
can kick in or not and so on and so on

00:35:11,680 --> 00:35:19,570
that's an open problem no no great what

00:35:16,720 --> 00:35:20,920
yeah well yeah if you have the same type

00:35:19,570 --> 00:35:22,570
over and over actually what happens that

00:35:20,920 --> 00:35:24,460
the compilers remembers that he sees a

00:35:22,570 --> 00:35:26,349
type so it doesn't have to mangle it

00:35:24,460 --> 00:35:30,010
again or whatever it does for fetching

00:35:26,349 --> 00:35:32,290
it inside the compile time section now

00:35:30,010 --> 00:35:35,619
well I think that testing over different

00:35:32,290 --> 00:35:37,300
types is what happens regularly so maybe

00:35:35,619 --> 00:35:40,900
the correct way to enter that could be

00:35:37,300 --> 00:35:43,270
you have to say you know you you fix the

00:35:40,900 --> 00:35:47,140
size of your template list like I don't

00:35:43,270 --> 00:35:50,050
know like to 200 and you play with let's

00:35:47,140 --> 00:35:53,109
say the density of types so you can go

00:35:50,050 --> 00:35:55,900
from 0% every type has the same up to

00:35:53,109 --> 00:35:57,910
50% every time every type are repeated

00:35:55,900 --> 00:36:00,670
up to twice and so on and so on so you

00:35:57,910 --> 00:36:03,040
can actually have a decent look at

00:36:00,670 --> 00:36:05,080
what's going on benchmarking compiled

00:36:03,040 --> 00:36:06,550
time algorithm I think is I think the

00:36:05,080 --> 00:36:09,180
meta bench is the first kind of before

00:36:06,550 --> 00:36:11,619
exists which is actually you know

00:36:09,180 --> 00:36:13,220
standardized and formalized so maybe

00:36:11,619 --> 00:36:16,040
there is you know cranking

00:36:13,220 --> 00:36:27,109
to cook around but it's the first one

00:36:16,040 --> 00:36:28,670
anticipation so is there any difference

00:36:27,109 --> 00:36:30,080
between playing and the other one I

00:36:28,670 --> 00:36:35,390
don't know what we can actually check

00:36:30,080 --> 00:36:40,849
what happens on other one well yeah a

00:36:35,390 --> 00:36:49,640
bit okay you can do your own work it

00:36:40,849 --> 00:36:52,040
work yeah you see but yeah we are

00:36:49,640 --> 00:36:54,710
speaking like tenth of a second anyway

00:36:52,040 --> 00:36:57,470
of combined time so but if you look at

00:36:54,710 --> 00:36:59,150
em here you see that it was quite yeah

00:36:57,470 --> 00:37:01,040
it changed me because I think the

00:36:59,150 --> 00:37:02,840
algorithm inside the compilers to end

00:37:01,040 --> 00:37:04,940
other types may be different

00:37:02,840 --> 00:37:06,530
I don't know how clean and also Valley

00:37:04,940 --> 00:37:08,840
dicks but I know it's different from GCC

00:37:06,530 --> 00:37:11,630
so probably that's the reason yeah it

00:37:08,840 --> 00:37:15,140
changed but I mean the worst case we

00:37:11,630 --> 00:37:17,540
endured was this 50-something type list

00:37:15,140 --> 00:37:20,660
on visual studio and it just compiled

00:37:17,540 --> 00:37:22,460
like like a normal coat so job stop but

00:37:20,660 --> 00:37:26,570
yeah compilers version actually yeah is

00:37:22,460 --> 00:37:29,420
important yeah I think are important the

00:37:26,570 --> 00:37:31,369
question is 500 types are useless is not

00:37:29,420 --> 00:37:33,710
up to us to decide we just provide the

00:37:31,369 --> 00:37:35,780
facilities and there is no reason to

00:37:33,710 --> 00:37:37,369
decide in advance that people should not

00:37:35,780 --> 00:37:38,839
do it if someone comes up with the

00:37:37,369 --> 00:37:40,910
varied use case you just give the

00:37:38,839 --> 00:37:42,109
possibility to people to use as many

00:37:40,910 --> 00:37:44,720
times as they want

00:37:42,109 --> 00:37:46,640
also one minute of this benchmark is

00:37:44,720 --> 00:37:48,680
that all library is improved by

00:37:46,640 --> 00:37:51,260
realizing that they had for example

00:37:48,680 --> 00:37:54,020
erratic behavior and some algorithms and

00:37:51,260 --> 00:37:55,609
at the beginning they in polygon we have

00:37:54,020 --> 00:37:57,349
a technique we called the fast lane and

00:37:55,609 --> 00:37:59,720
everybody in the beginning would say

00:37:57,349 --> 00:38:01,730
yeah it's uses technique we won't do it

00:37:59,720 --> 00:38:05,180
and we went much faster than anyone else

00:38:01,730 --> 00:38:07,490
and with time they just everyone

00:38:05,180 --> 00:38:09,650
everybody does it now so it's good it's

00:38:07,490 --> 00:38:12,020
the purpose of course the benchmark will

00:38:09,650 --> 00:38:15,349
only tell that you're good at the

00:38:12,020 --> 00:38:17,180
benchmark it will not see that we yes

00:38:15,349 --> 00:38:18,950
the other funny stuff is that at some

00:38:17,180 --> 00:38:21,080
point we decided to change the way we

00:38:18,950 --> 00:38:23,000
will present lambda function

00:38:21,080 --> 00:38:26,240
because it was clear that that was

00:38:23,000 --> 00:38:29,270
something that was pulling us up upward

00:38:26,240 --> 00:38:31,310
some other other techniques so we I mean

00:38:29,270 --> 00:38:34,250
I think it's a st. emulation between all

00:38:31,310 --> 00:38:36,740
of those between mid meter by Eric

00:38:34,250 --> 00:38:41,830
ampere and the in the metal guys well

00:38:36,740 --> 00:38:44,119
and also so yes the the goal is that

00:38:41,830 --> 00:38:48,080
ideally the cost for the library should

00:38:44,119 --> 00:38:49,490
be zero that it's not because you want

00:38:48,080 --> 00:38:51,830
to use technique that is going to have a

00:38:49,490 --> 00:38:54,080
huge impact on your code and when it

00:38:51,830 --> 00:38:55,790
becomes you then people are going to use

00:38:54,080 --> 00:38:58,610
it more and more and I think it will

00:38:55,790 --> 00:38:59,660
result in better code in the end maybe

00:38:58,610 --> 00:39:21,680
we can have a look at different

00:38:59,660 --> 00:39:24,080
benchmarks yeah so the question is okay

00:39:21,680 --> 00:39:25,910
so you have modern template

00:39:24,080 --> 00:39:29,150
metaprogramming libraries they are

00:39:25,910 --> 00:39:29,510
better in a way than boost NPL just to

00:39:29,150 --> 00:39:31,340
be sure

00:39:29,510 --> 00:39:34,070
boost MPL it was the huge source of

00:39:31,340 --> 00:39:37,730
inspiration and it's a very very good

00:39:34,070 --> 00:39:39,980
foundation we just take the logic and

00:39:37,730 --> 00:39:42,590
put it into a new language in a way and

00:39:39,980 --> 00:39:44,750
the question is fine I have my boost NPL

00:39:42,590 --> 00:39:48,369
program and I want to put it to another

00:39:44,750 --> 00:39:51,710
library how long it's going to take I

00:39:48,369 --> 00:39:54,260
think it's very quick because especially

00:39:51,710 --> 00:39:57,650
in Rigo you have almost a one-to-one

00:39:54,260 --> 00:39:59,270
match up on the name so fine works

00:39:57,650 --> 00:40:02,180
differently you don't you say goodbye to

00:39:59,270 --> 00:40:05,230
Ritter at us but this is something you

00:40:02,180 --> 00:40:08,840
should you will thank us for you for it

00:40:05,230 --> 00:40:11,000
because it's much more convenient you

00:40:08,840 --> 00:40:14,480
also change the fact that we are all

00:40:11,000 --> 00:40:18,770
eager yes have any more lazy we have

00:40:14,480 --> 00:40:20,300
lazy but but its explicit and you don't

00:40:18,770 --> 00:40:22,280
have to switch everything at the same

00:40:20,300 --> 00:40:24,460
time you can have the two to cohabit for

00:40:22,280 --> 00:40:24,460
what

00:40:33,610 --> 00:40:38,210
haha because subscription is where it's

00:40:36,110 --> 00:40:40,970
an Angie's List that's because we are

00:40:38,210 --> 00:40:44,750
dealing with pure type operation so I

00:40:40,970 --> 00:40:46,610
think if you go to this may be so yeah

00:40:44,750 --> 00:40:49,610
then you get okay

00:40:46,610 --> 00:40:51,320
Thank You Louis to just blow my stuff

00:40:49,610 --> 00:40:57,470
and I think you were okay

00:40:51,320 --> 00:41:00,140
I need that yeah I need a proper

00:40:57,470 --> 00:41:02,960
compiler to get another compiled so yeah

00:41:00,140 --> 00:41:06,320
so you find an a benchmark in to see if

00:41:02,960 --> 00:41:08,450
you're watching news tabs so he

00:41:06,320 --> 00:41:10,730
separated the one that you which types

00:41:08,450 --> 00:41:12,860
only in the one that is a taraji news

00:41:10,730 --> 00:41:14,750
operation to you you get a comparison

00:41:12,860 --> 00:41:16,910
against effusion and stuff like this and

00:41:14,750 --> 00:41:19,280
topple their watch the other one is

00:41:16,910 --> 00:41:21,800
basically all compiled time type

00:41:19,280 --> 00:41:24,500
manipulation because it's completely

00:41:21,800 --> 00:41:26,660
different piece to two benchmarks and

00:41:24,500 --> 00:41:29,360
actually Anna and we got a very

00:41:26,660 --> 00:41:30,770
complimentary from well they don't

00:41:29,360 --> 00:41:32,810
really saw exactly the same problem

00:41:30,770 --> 00:41:35,030
which from the outside sounds a bit

00:41:32,810 --> 00:41:37,370
crazy like what I need to template

00:41:35,030 --> 00:41:40,520
metaprogramming libraries and the answer

00:41:37,370 --> 00:41:46,280
is no doing is not enough you need all

00:41:40,520 --> 00:41:49,450
of them yes okay thank you again so we

00:41:46,280 --> 00:41:53,570
can have a look at the code organization

00:41:49,450 --> 00:42:00,040
to answer the question of okay fine so

00:41:53,570 --> 00:42:02,990
you showed us examples have my wizard of

00:42:00,040 --> 00:42:04,250
people not keep on master because the

00:42:02,990 --> 00:42:07,640
keyboard is actually too big for my

00:42:04,250 --> 00:42:13,970
hands so I called press two keys at the

00:42:07,640 --> 00:42:16,190
same time so if we look at this you will

00:42:13,970 --> 00:42:19,910
if you are boosting pure guy which is

00:42:16,190 --> 00:42:22,730
for me which what I've spent most of my

00:42:19,910 --> 00:42:25,130
time with you will find yourself in the

00:42:22,730 --> 00:42:27,950
place where the organization looks a

00:42:25,130 --> 00:42:31,090
little bit the same and to give credits

00:42:27,950 --> 00:42:34,070
word use for the documentation we just

00:42:31,090 --> 00:42:35,430
imitated whatever was the post MPL

00:42:34,070 --> 00:42:38,790
documentation

00:42:35,430 --> 00:42:41,609
copied the sin structure you will find

00:42:38,790 --> 00:42:44,520
the algorithms here the names are very

00:42:41,609 --> 00:42:46,920
explicit and we have actually

00:42:44,520 --> 00:42:51,000
documentation and tutorials that we

00:42:46,920 --> 00:42:55,200
wrote to to get you started like to

00:42:51,000 --> 00:42:58,530
answer the very simple question of how

00:42:55,200 --> 00:43:01,079
do I create tab lists how do I use

00:42:58,530 --> 00:43:04,559
algorithms and you will find it on the

00:43:01,079 --> 00:43:07,770
homepage and that's for the

00:43:04,559 --> 00:43:13,230
documentation organization you will find

00:43:07,770 --> 00:43:40,319
again everything on the home page so I'm

00:43:13,230 --> 00:43:45,540
ready for more question so the question

00:43:40,319 --> 00:43:48,630
is did Microsoft lemon so the question

00:43:45,540 --> 00:43:51,420
is what what kind of black magic will do

00:43:48,630 --> 00:43:53,130
stuff did we need to to compile on

00:43:51,420 --> 00:43:55,890
Visual Studio that's all right

00:43:53,130 --> 00:43:58,170
you know actually the expression Judah

00:43:55,890 --> 00:43:59,880
is not that was a big deal we had a

00:43:58,170 --> 00:44:02,670
fight against because we don't use much

00:43:59,880 --> 00:44:04,619
no we don't use it at all we tried at

00:44:02,670 --> 00:44:07,260
some point but we found that it's not

00:44:04,619 --> 00:44:08,069
that useful for what oh no way we use it

00:44:07,260 --> 00:44:11,309
at some point

00:44:08,069 --> 00:44:14,099
and I'm saying I'm stupid stuff used for

00:44:11,309 --> 00:44:15,720
said say I said you spin i but it's the

00:44:14,099 --> 00:44:18,000
small corner of expressions you know is

00:44:15,720 --> 00:44:20,609
that research to do is a pee-wee's so

00:44:18,000 --> 00:44:22,559
that was quite lucky now so the main

00:44:20,609 --> 00:44:24,660
issue with last year was sometimes she

00:44:22,559 --> 00:44:26,790
doesn't know why you you're writing your

00:44:24,660 --> 00:44:28,710
temper Italia series because you want

00:44:26,790 --> 00:44:31,260
you need them and at some point you end

00:44:28,710 --> 00:44:33,480
up with having something like using type

00:44:31,260 --> 00:44:35,069
equal and he has one of our esq of

00:44:33,480 --> 00:44:37,619
something something something of a yes

00:44:35,069 --> 00:44:40,049
tree and the compiler get confused for

00:44:37,619 --> 00:44:42,450
whatever reasons and then if you do okay

00:44:40,049 --> 00:44:45,329
using result one is alias one of this

00:44:42,450 --> 00:44:47,180
and result 2 is alias to of result one

00:44:45,329 --> 00:44:49,080
and so on so you just you know piecewise

00:44:47,180 --> 00:44:53,700
enumeration steps then

00:44:49,080 --> 00:44:55,650
- and sometimes for completely different

00:44:53,700 --> 00:44:57,420
areas of different complexity you don't

00:44:55,650 --> 00:45:02,600
really know why so whenever we eat that

00:44:57,420 --> 00:45:05,070
we just slice the mmm the computation I

00:45:02,600 --> 00:45:08,610
think you should disable something yeah

00:45:05,070 --> 00:45:10,950
I think I should out yeah whatever the

00:45:08,610 --> 00:45:13,740
trick is we need to compose some of the

00:45:10,950 --> 00:45:16,320
computation of times because just you'll

00:45:13,740 --> 00:45:18,120
get cranky some points but it was many

00:45:16,320 --> 00:45:20,670
SATs I don't think we had any other big

00:45:18,120 --> 00:45:23,010
problem we crashed every comparator yes

00:45:20,670 --> 00:45:27,360
yeah sure that's part of my job

00:45:23,010 --> 00:45:29,070
description anyway but I see the most

00:45:27,360 --> 00:45:31,950
frequent it's because of the tokenizer

00:45:29,070 --> 00:45:36,510
which is like ring buffer of three

00:45:31,950 --> 00:45:38,370
elements I think do they know no most of

00:45:36,510 --> 00:45:40,200
the time when you get a crash in visual

00:45:38,370 --> 00:45:42,990
studio you create an intermediate type

00:45:40,200 --> 00:45:44,880
and then you get around the crash so you

00:45:42,990 --> 00:45:46,200
just have sometimes if you look at the

00:45:44,880 --> 00:45:47,990
source code of I go you're going to say

00:45:46,200 --> 00:45:50,400
why do they have an intermediate type

00:45:47,990 --> 00:45:52,440
then you have the explanation and we

00:45:50,400 --> 00:45:56,550
have actually very very few if that's

00:45:52,440 --> 00:45:59,850
for the compilers so just just for going

00:45:56,550 --> 00:46:02,520
back on this unit stuff so that's part

00:45:59,850 --> 00:46:04,470
of the set implementation so what set is

00:46:02,520 --> 00:46:07,110
is you have a set of types that must be

00:46:04,470 --> 00:46:10,440
unique so what we do is we take every

00:46:07,110 --> 00:46:13,470
types put it into a box and we inner it

00:46:10,440 --> 00:46:17,580
for every box of every type in the set

00:46:13,470 --> 00:46:23,490
list of types and the box contains a

00:46:17,580 --> 00:46:25,440
small interface smart advice for

00:46:23,490 --> 00:46:28,290
answering question like contains gate

00:46:25,440 --> 00:46:34,380
key and whatever which is just okay for

00:46:28,290 --> 00:46:37,710
given types T and K U contains K or if

00:46:34,380 --> 00:46:39,780
only if you are actually about to if you

00:46:37,710 --> 00:46:41,580
are interacting from the next set of

00:46:39,780 --> 00:46:43,620
everything if you does not inherit from

00:46:41,580 --> 00:46:46,560
that that means not contained in the set

00:46:43,620 --> 00:46:49,380
and same for I ski and same for erase

00:46:46,560 --> 00:46:54,270
that just removes the type if and only

00:46:49,380 --> 00:46:57,420
if it's found into the list of object

00:46:54,270 --> 00:47:02,130
inheritance and this Decker type usage

00:46:57,420 --> 00:47:02,370
it is OK for for visual studio and so

00:47:02,130 --> 00:47:04,170
you

00:47:02,370 --> 00:47:08,010
you ended up with yeah basically

00:47:04,170 --> 00:47:10,350
building this type over and over again

00:47:08,010 --> 00:47:13,800
until you you consume all the type into

00:47:10,350 --> 00:47:18,510
the set we can also maybe show what the

00:47:13,800 --> 00:47:21,060
fast lane technical question is yeah

00:47:18,510 --> 00:47:24,210
what's a fastening technique so let's

00:47:21,060 --> 00:47:25,920
say you have transform for example it's

00:47:24,210 --> 00:47:27,990
transformed fast mean actually I think

00:47:25,920 --> 00:47:31,500
everything is yeah okay so I think I've

00:47:27,990 --> 00:47:34,050
transformed so you have transform of T

00:47:31,500 --> 00:47:37,650
dot dot and you say just build up yet

00:47:34,050 --> 00:47:39,810
fine define we mean why yeah you do the

00:47:37,650 --> 00:47:42,000
stuff with dot dot but not that has a

00:47:39,810 --> 00:47:43,680
cost so what we say that if it's empty

00:47:42,000 --> 00:47:47,100
you return the empty list if you have

00:47:43,680 --> 00:47:49,350
one single type you apply the meter

00:47:47,100 --> 00:47:51,870
function to the single type once you

00:47:49,350 --> 00:47:54,420
have two times you do it twice and so on

00:47:51,870 --> 00:47:56,370
up to let's say sixteen and when you

00:47:54,420 --> 00:48:00,270
have more than sixteen types what you do

00:47:56,370 --> 00:48:02,670
is you compute the sixteen first with

00:48:00,270 --> 00:48:04,440
the fast and one and you pass the rest

00:48:02,670 --> 00:48:06,510
to the transform which means that

00:48:04,440 --> 00:48:08,520
basically if you have n times in your

00:48:06,510 --> 00:48:10,440
type list you only need at most n

00:48:08,520 --> 00:48:17,520
divided by sixteen templates

00:48:10,440 --> 00:48:19,230
instantiation because more than sixteen

00:48:17,520 --> 00:48:21,270
I was bored actually copy pasting the

00:48:19,230 --> 00:48:22,890
code so I said yes it seems enough or

00:48:21,270 --> 00:48:24,480
maybe even eight is enough or something

00:48:22,890 --> 00:48:27,600
yeah which one is that

00:48:24,480 --> 00:48:31,740
it's transform there's been some other

00:48:27,600 --> 00:48:34,080
has his name oh yeah what name is okay

00:48:31,740 --> 00:48:42,390
there there is some other black magic

00:48:34,080 --> 00:48:49,760
but the goal is satisfied we transform I

00:48:42,390 --> 00:48:54,990
transferred yes

00:48:49,760 --> 00:48:57,420
and is one root of this actually so the

00:48:54,990 --> 00:49:02,340
first version of Vega we had very simple

00:48:57,420 --> 00:49:04,500
enrolling and technically yeah someplace

00:49:02,340 --> 00:49:06,810
I don't even recognize the code anyway

00:49:04,500 --> 00:49:08,280
but yeah Odin has been walking with us

00:49:06,810 --> 00:49:10,050
for quite a long time now

00:49:08,280 --> 00:49:12,390
it's quite a very interesting

00:49:10,050 --> 00:49:14,569
contributors to have around so yeah yeah

00:49:12,390 --> 00:49:16,699
Odin's technique is basically what we

00:49:14,569 --> 00:49:18,739
let's say audience technique has been

00:49:16,699 --> 00:49:20,209
probably polished on friggin before he

00:49:18,739 --> 00:49:25,099
make his blog post or whatever but yeah

00:49:20,209 --> 00:49:27,529
it's better than what he's doing I think

00:49:25,099 --> 00:49:34,849
at at artisan role also with the freaky

00:49:27,529 --> 00:49:38,029
stuff yes actually it's the map which

00:49:34,849 --> 00:49:40,039
most us to do this when we had a

00:49:38,029 --> 00:49:42,559
discussion because basically polygon was

00:49:40,039 --> 00:49:44,869
designed on the phone we had a

00:49:42,559 --> 00:49:47,089
conversation and we were like okay so we

00:49:44,869 --> 00:49:48,890
have the list it's easy now then we

00:49:47,089 --> 00:49:50,779
reach the map that you really want to

00:49:48,890 --> 00:49:53,420
have logarithmic complexity for the

00:49:50,779 --> 00:49:56,089
lookup of the map and we wanted to run

00:49:53,420 --> 00:49:58,039
on visual studio which alighted all the

00:49:56,089 --> 00:50:01,789
advanced techniques we could use of

00:49:58,039 --> 00:50:06,439
clang so I don't remember who said but

00:50:01,789 --> 00:50:09,519
then probably me actually I think it's

00:50:06,439 --> 00:50:09,519
me but I wanted to be polite

00:50:09,729 --> 00:50:15,910
it's you just the different people to

00:50:12,140 --> 00:50:18,439
disagree I'm not sure about that yes

00:50:15,910 --> 00:50:21,140
even even when I'm alone I think I can i

00:50:18,439 --> 00:50:27,049
disagree with myself I think it's the

00:50:21,140 --> 00:50:29,299
sequences freaking GT yes yes it's

00:50:27,049 --> 00:50:32,390
actually the basic is to say and you

00:50:29,299 --> 00:50:38,749
have a specific technique it's a ski

00:50:32,390 --> 00:50:41,170
awesome yes that key it's going to be in

00:50:38,749 --> 00:50:41,170
metal

00:50:45,089 --> 00:50:52,749
so yes so for the map you really want to

00:50:48,099 --> 00:50:55,630
have the lookup to be very fast and some

00:50:52,749 --> 00:51:00,239
of this is some intermediate type is

00:50:55,630 --> 00:51:02,859
because of and so the idea is here I

00:51:00,239 --> 00:51:10,630
don't know anymore because T I said you

00:51:02,859 --> 00:51:17,619
seen a ski ask you where yes sorry okay

00:51:10,630 --> 00:51:19,599
if not they're always somewhere that we

00:51:17,619 --> 00:51:28,299
tend to say something interesting in our

00:51:19,599 --> 00:51:30,099
head so yes I think it's Jonathan will

00:51:28,299 --> 00:51:31,539
came up with a different idea from fast

00:51:30,099 --> 00:51:33,609
lane but if you go back in the history

00:51:31,539 --> 00:51:42,390
you will see that you can use this

00:51:33,609 --> 00:51:42,390
technique any other question no question

00:51:42,960 --> 00:51:51,479
so we wait for as well to find the code

00:51:46,739 --> 00:51:51,479

YouTube URL: https://www.youtube.com/watch?v=ky0JdPh_LgE


