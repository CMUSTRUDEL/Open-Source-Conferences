Title: CppCon 2016: David Sankel “Variants: Past, Present, and Future"
Publication date: 2016-10-01
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
What are variants, why are they important, and how I use them? Once available to a developer, variants become one of the most commonly used tools in everyday programming. This talk will explore the venerable Boost.Variant library, discuss the improvements made by C++17’s std::variant＜＞, and close with a discussion of the exciting new language-based variant and pattern matching papers (proposed for C++20). This talk aims to be of practical utility in variant library usage and informative as to where things are heading.
— 
David Sankel
Bloomberg
New York, New York
David Sankel is a professional software developer/architect based in the USA and an active member of the C++ Standardization Committee. His prolific software developments have included CAD/CAM, computer graphics, visual programming languages, web applications, computer vision, and cryptography. He is a frequent speaker at the C++Now conferences and is especially well known for his advanced functional programming in C++ talks. David’s interests include large-scale development, dependently typed languages, semantic domains, EDSLs, and functional reactive programming. David's current research interests include dependently typed languages, semantic domains, EDSLs, and functional reactive programming. He currently works for Bloomberg.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,540
hello okay thanks

00:00:04,259 --> 00:00:10,170
so I'm from a little town called New

00:00:06,540 --> 00:00:11,429
York City and I work at Bloomberg and

00:00:10,170 --> 00:00:14,940
we're gonna talk about variance today so

00:00:11,429 --> 00:00:20,570
before we get started just a get an idea

00:00:14,940 --> 00:00:23,609
how many of you guys use variance about

00:00:20,570 --> 00:00:25,439
half maybe three-quarters of you how

00:00:23,609 --> 00:00:29,460
many of you guys don't know if you use

00:00:25,439 --> 00:00:30,929
variance or not okay a few all right

00:00:29,460 --> 00:00:33,149
well we're at least gonna clear that up

00:00:30,929 --> 00:00:37,890
and the answer is probably that you

00:00:33,149 --> 00:00:39,750
don't use variance so this is about the

00:00:37,890 --> 00:00:44,399
past present and future about this nice

00:00:39,750 --> 00:00:47,640
data structure here so in 2004 boost

00:00:44,399 --> 00:00:50,730
variant was released in boost 1.30 1.0

00:00:47,640 --> 00:00:52,940
and that should tell you that we've had

00:00:50,730 --> 00:00:54,809
a lot of experience with this thing in

00:00:52,940 --> 00:00:57,600
00:00:54,809 --> 00:00:59,010
variant was voted in the c++ 17 2016

00:00:57,600 --> 00:01:01,230
being this year for those of you who

00:00:59,010 --> 00:01:03,420
don't realize that that just happened

00:01:01,230 --> 00:01:04,559
recently and it was a very awesome thing

00:01:03,420 --> 00:01:06,200
to get into the standard and it took a

00:01:04,559 --> 00:01:08,340
lot of work to get get it there and

00:01:06,200 --> 00:01:11,430
sometime in the future maybe there's

00:01:08,340 --> 00:01:13,500
going to be a language based variant

00:01:11,430 --> 00:01:15,630
support in the next some next revision

00:01:13,500 --> 00:01:17,090
and I'll just touch on that at the end

00:01:15,630 --> 00:01:19,950
of what we're going to talk about so

00:01:17,090 --> 00:01:23,280
first off motivating examples who cares

00:01:19,950 --> 00:01:24,540
about very why do we need it you're

00:01:23,280 --> 00:01:27,659
gonna see you've seen code like this

00:01:24,540 --> 00:01:30,869
before so basically what you have is you

00:01:27,659 --> 00:01:33,540
have a person ID a person ID can either

00:01:30,869 --> 00:01:36,810
be a name of the person or maybe a John

00:01:33,540 --> 00:01:38,250
Doe number and it's never both you

00:01:36,810 --> 00:01:40,320
either have a name for the person or

00:01:38,250 --> 00:01:42,659
he's got a John Doe ID and it's done

00:01:40,320 --> 00:01:46,350
like this so you have your getters up

00:01:42,659 --> 00:01:48,570
there you have some boolean which says

00:01:46,350 --> 00:01:50,220
which of these things is actually active

00:01:48,570 --> 00:01:51,750
at the right point and then you have

00:01:50,220 --> 00:01:53,640
your string for the name and your int

00:01:51,750 --> 00:01:56,579
for the John Doe ID so far so good

00:01:53,640 --> 00:01:59,130
right you need to document your

00:01:56,579 --> 00:02:03,630
undefined behavior though because if

00:01:59,130 --> 00:02:05,520
this person ID happens to be a John Doe

00:02:03,630 --> 00:02:07,649
then you shouldn't be calling the get

00:02:05,520 --> 00:02:09,330
name function so you might document your

00:02:07,649 --> 00:02:11,310
undefined behavior with something like

00:02:09,330 --> 00:02:13,020
behaviors undefined and less has name

00:02:11,310 --> 00:02:13,740
equals true so I got to add that to your

00:02:13,020 --> 00:02:16,110
interface

00:02:13,740 --> 00:02:17,910
okay this happens a lot it's in a lot of

00:02:16,110 --> 00:02:19,290
different kinds of code and it should be

00:02:17,910 --> 00:02:21,720
completely replaced by a variant and

00:02:19,290 --> 00:02:23,700
we'll see how later the problems with

00:02:21,720 --> 00:02:25,650
this approach we don't get any compiler

00:02:23,700 --> 00:02:27,120
help for checking those preconditions

00:02:25,650 --> 00:02:29,490
like there are no guarantees that our

00:02:27,120 --> 00:02:31,590
users using this code are actually going

00:02:29,490 --> 00:02:32,730
to make sure that the preconditions are

00:02:31,590 --> 00:02:35,520
met

00:02:32,730 --> 00:02:37,380
not at compile time anyway there's waste

00:02:35,520 --> 00:02:39,420
of space because you have the string and

00:02:37,380 --> 00:02:41,010
you have the int where you really only

00:02:39,420 --> 00:02:44,070
need one of those at a time so you just

00:02:41,010 --> 00:02:45,900
got this waste of space and there's just

00:02:44,070 --> 00:02:48,690
a bunch of boilerplate which is error

00:02:45,900 --> 00:02:51,830
prone so these are drawbacks with this

00:02:48,690 --> 00:02:53,610
approach here's another example

00:02:51,830 --> 00:02:55,530
sometimes you'll see this kind of things

00:02:53,610 --> 00:02:57,480
what you have is an abstract base class

00:02:55,530 --> 00:02:59,070
so this we have like a commands like

00:02:57,480 --> 00:03:01,860
maybe some kind of commands in a game or

00:02:59,070 --> 00:03:03,900
something like that you have some kind

00:03:01,860 --> 00:03:06,620
of virtual function this in this case

00:03:03,900 --> 00:03:09,540
called put which is just outputting a

00:03:06,620 --> 00:03:11,250
something useful to the stream that's

00:03:09,540 --> 00:03:13,200
put in there and a virtual destructor

00:03:11,250 --> 00:03:15,180
and then each of your commands are going

00:03:13,200 --> 00:03:19,440
to inherit from this abstract base class

00:03:15,180 --> 00:03:21,090
and specialize the put function and you

00:03:19,440 --> 00:03:23,370
know this has a double the set score

00:03:21,090 --> 00:03:25,700
function in this example so that's what

00:03:23,370 --> 00:03:25,700
that's all about

00:03:25,790 --> 00:03:30,450
the problems with this is if you're

00:03:28,200 --> 00:03:33,420
using an abstract base class to model

00:03:30,450 --> 00:03:35,850
this you're going to have allocation

00:03:33,420 --> 00:03:37,740
memory management to worry about so it

00:03:35,850 --> 00:03:40,530
just adds another level of complexity to

00:03:37,740 --> 00:03:43,110
your API or you're gonna have to use

00:03:40,530 --> 00:03:44,190
shared pointer unique pointer what kind

00:03:43,110 --> 00:03:46,860
of questions those kinds of questions

00:03:44,190 --> 00:03:49,380
you have to answer every single

00:03:46,860 --> 00:03:51,240
operation that you want that works on

00:03:49,380 --> 00:03:54,530
all of the different things which are

00:03:51,240 --> 00:03:59,250
commands needs to have a virtual

00:03:54,530 --> 00:04:00,840
function in the base class so that can

00:03:59,250 --> 00:04:02,340
kind of be annoying so I say functions

00:04:00,840 --> 00:04:05,730
are split here and what I mean by that

00:04:02,340 --> 00:04:10,800
is you really think of this put function

00:04:05,730 --> 00:04:12,450
as one function but it split between a

00:04:10,800 --> 00:04:17,040
whole bunch of different files usually

00:04:12,450 --> 00:04:18,930
translation units because of it needs to

00:04:17,040 --> 00:04:21,870
be implemented in each particular thing

00:04:18,930 --> 00:04:24,120
that inherits from it and there's just

00:04:21,870 --> 00:04:26,850
lots of boilerplate here

00:04:24,120 --> 00:04:28,860
and finally this is open instead of

00:04:26,850 --> 00:04:31,470
closed because if I could give an

00:04:28,860 --> 00:04:33,900
interface if I provide an API which has

00:04:31,470 --> 00:04:35,460
this command abstract base class then my

00:04:33,900 --> 00:04:37,979
clients can inherit from it and add

00:04:35,460 --> 00:04:40,380
Colet commands sometimes you want this

00:04:37,979 --> 00:04:41,550
sometimes you don't like in this kind of

00:04:40,380 --> 00:04:43,380
case I don't want them to add their own

00:04:41,550 --> 00:04:46,290
commands my I don't know that doesn't

00:04:43,380 --> 00:04:49,889
make any sense for my game so that can

00:04:46,290 --> 00:04:51,990
be under silent desireable so people get

00:04:49,889 --> 00:04:52,919
around some of these issues you've

00:04:51,990 --> 00:04:55,410
probably seen this kind of pattern

00:04:52,919 --> 00:04:59,310
before so yeah so you have your abstract

00:04:55,410 --> 00:05:01,260
base class and it has a type inu and

00:04:59,310 --> 00:05:03,510
this thing just basically enumerates

00:05:01,260 --> 00:05:06,840
every single possible thing which

00:05:03,510 --> 00:05:08,550
inherits from the space class you have a

00:05:06,840 --> 00:05:11,910
get type function which will tell you

00:05:08,550 --> 00:05:14,130
which when you have an instance of it

00:05:11,910 --> 00:05:16,470
you can tell you which thing which

00:05:14,130 --> 00:05:19,979
inherits from it is currently in your

00:05:16,470 --> 00:05:21,479
objects and and then each of the things

00:05:19,979 --> 00:05:24,360
which inherit from this abstract base

00:05:21,479 --> 00:05:26,580
class get type you return the

00:05:24,360 --> 00:05:28,380
corresponding enum for this so if you

00:05:26,580 --> 00:05:30,210
want to use one of these things you call

00:05:28,380 --> 00:05:32,700
get type in figure out which type it is

00:05:30,210 --> 00:05:35,000
you downcast to the right thing and then

00:05:32,700 --> 00:05:37,229
you can write your functions that way so

00:05:35,000 --> 00:05:40,050
we still have allocation and memory

00:05:37,229 --> 00:05:41,669
management required for this functions

00:05:40,050 --> 00:05:43,200
are no longer split like if I want to

00:05:41,669 --> 00:05:45,450
write a put function I could write that

00:05:43,200 --> 00:05:48,840
in one spot I don't need to add anything

00:05:45,450 --> 00:05:50,940
to the abstract base class there's even

00:05:48,840 --> 00:05:52,860
a more boilerplate now and this time

00:05:50,940 --> 00:05:55,650
it's error-prone if you return the wrong

00:05:52,860 --> 00:05:57,539
thing from set from this get type

00:05:55,650 --> 00:06:01,650
function you're going to get some kind

00:05:57,539 --> 00:06:03,449
of error at runtime and it's still open

00:06:01,650 --> 00:06:07,710
instead of closed not exactly what we

00:06:03,449 --> 00:06:10,680
want and the third example here is just

00:06:07,710 --> 00:06:14,010
a simple binary tree this one is

00:06:10,680 --> 00:06:15,780
recursive because if you have a branch

00:06:14,010 --> 00:06:17,430
right and you have the branch and the

00:06:15,780 --> 00:06:20,250
leaf both inherit from that from the

00:06:17,430 --> 00:06:21,780
base class the branch refers to the tree

00:06:20,250 --> 00:06:23,460
node at the top there so it's a

00:06:21,780 --> 00:06:25,860
recursive thing I'm not going to go into

00:06:23,460 --> 00:06:27,750
a lot of this particular example right

00:06:25,860 --> 00:06:29,789
now we're going to get to it later but

00:06:27,750 --> 00:06:31,949
just keep it in mind as this is another

00:06:29,789 --> 00:06:36,030
thing that you should be using bearing

00:06:31,949 --> 00:06:38,100
for him so what is variant

00:06:36,030 --> 00:06:41,310
the way I like to think about this is an

00:06:38,100 --> 00:06:44,760
vs. org if you got a struct and it has

00:06:41,310 --> 00:06:49,320
two members in there an ex-member and a

00:06:44,760 --> 00:06:52,590
y member it has an X member and a Y

00:06:49,320 --> 00:06:56,910
member key word there is ant if you have

00:06:52,590 --> 00:07:03,240
a variance with an x and a y it has an X

00:06:56,910 --> 00:07:05,130
or a Y so it's either going to have an X

00:07:03,240 --> 00:07:10,500
or it's going to have a Y it will never

00:07:05,130 --> 00:07:12,419
have both so it's and versus or so going

00:07:10,500 --> 00:07:16,080
back to our person ID which is either a

00:07:12,419 --> 00:07:17,700
name or a John Doe ID the way that you

00:07:16,080 --> 00:07:19,590
put that into a very easy saying okay

00:07:17,700 --> 00:07:21,419
using person IDs is really fancy

00:07:19,590 --> 00:07:24,230
sleepless 11:00 stuff here you could

00:07:21,419 --> 00:07:29,190
also use a type def using person ID is

00:07:24,230 --> 00:07:31,050
equal to variance string int so a person

00:07:29,190 --> 00:07:35,340
ID is either going to be a string or an

00:07:31,050 --> 00:07:38,370
int as as simple as that so let's look

00:07:35,340 --> 00:07:42,750
at our command example so we had again

00:07:38,370 --> 00:07:44,940
our abstract base class and our set

00:07:42,750 --> 00:07:46,800
score thing which inherits from it the

00:07:44,940 --> 00:07:49,800
way you do this now is you figure out

00:07:46,800 --> 00:07:51,900
all the things that are commands like

00:07:49,800 --> 00:07:54,060
set score give it the data member that

00:07:51,900 --> 00:07:56,370
it needs in this case the double value

00:07:54,060 --> 00:07:59,520
and then say using command equals

00:07:56,370 --> 00:08:01,530
variant set score fire missile all the

00:07:59,520 --> 00:08:04,410
other kinds of things so a command is

00:08:01,530 --> 00:08:06,840
either a set score or if say fire

00:08:04,410 --> 00:08:12,570
missile or it's a fire laser or it's a

00:08:06,840 --> 00:08:14,850
rotate right simple enough and here's

00:08:12,570 --> 00:08:16,140
just a slide that talks about the

00:08:14,850 --> 00:08:17,820
different names of Berrien cuz you'll

00:08:16,140 --> 00:08:18,990
hear it come up under other names and

00:08:17,820 --> 00:08:20,400
different conversations I'm not gonna go

00:08:18,990 --> 00:08:23,310
into detail on this but just so you know

00:08:20,400 --> 00:08:24,780
some people call it the or type some

00:08:23,310 --> 00:08:26,490
people call it the some type of here

00:08:24,780 --> 00:08:29,310
conversations about some types we're

00:08:26,490 --> 00:08:31,650
talking about variants discriminated

00:08:29,310 --> 00:08:34,140
union okay this is like a mathematical

00:08:31,650 --> 00:08:35,669
term for it and it has like the Union

00:08:34,140 --> 00:08:39,599
sign with a little plus in the middle

00:08:35,669 --> 00:08:43,440
there they took all this the algebraic

00:08:39,599 --> 00:08:45,420
data type pipe operator or a one-of type

00:08:43,440 --> 00:08:47,010
these are just different names for the

00:08:45,420 --> 00:08:49,899
same thing that'll come up every now and

00:08:47,010 --> 00:08:52,240
then so we have

00:08:49,899 --> 00:08:56,079
we have inheritance when would you use

00:08:52,240 --> 00:08:57,810
one one would use the other well just to

00:08:56,079 --> 00:09:00,880
look at some of the differences a

00:08:57,810 --> 00:09:03,639
variant are if you're using inheritance

00:09:00,880 --> 00:09:04,990
it's open to new alternatives all right

00:09:03,639 --> 00:09:06,970
someone can come along look at your

00:09:04,990 --> 00:09:10,089
abstract base class and add more things

00:09:06,970 --> 00:09:12,040
to it a variant is closed once you have

00:09:10,089 --> 00:09:14,019
that using whatever equals variant

00:09:12,040 --> 00:09:15,220
you can't expect some client to come in

00:09:14,019 --> 00:09:16,870
there and shove another type in there

00:09:15,220 --> 00:09:18,399
right it's set when you provide it to

00:09:16,870 --> 00:09:20,829
them

00:09:18,399 --> 00:09:22,810
inheritance is close to new operations

00:09:20,829 --> 00:09:25,060
generally speaking you only have that

00:09:22,810 --> 00:09:26,529
set list of virtual functions where a

00:09:25,060 --> 00:09:28,930
variant doesn't have any of these

00:09:26,529 --> 00:09:30,339
functions defined when you declare your

00:09:28,930 --> 00:09:32,139
variant you can always add new

00:09:30,339 --> 00:09:33,959
operations to a variant over all the

00:09:32,139 --> 00:09:35,889
different alternatives it has

00:09:33,959 --> 00:09:38,079
inheritance you have this multi-level

00:09:35,889 --> 00:09:39,940
thing variants are only single level you

00:09:38,079 --> 00:09:43,149
just have that list of types inheritance

00:09:39,940 --> 00:09:45,310
is an object-oriented construct whereas

00:09:43,149 --> 00:09:48,040
variants are more a functional

00:09:45,310 --> 00:09:50,380
programming type thing and you can take

00:09:48,040 --> 00:09:52,529
that as based on mathematical analysis

00:09:50,380 --> 00:09:55,120
they come up with these ideas

00:09:52,529 --> 00:09:57,610
inheritance is very complex you think

00:09:55,120 --> 00:09:58,959
about public private protected all this

00:09:57,610 --> 00:10:01,120
kind of stuff

00:09:58,959 --> 00:10:03,870
variants are very simple at their core

00:10:01,120 --> 00:10:07,540
it's just this or this or this or this

00:10:03,870 --> 00:10:08,050
so boost variant has been around for a

00:10:07,540 --> 00:10:11,220
long time

00:10:08,050 --> 00:10:14,430
let's review their implementation of it

00:10:11,220 --> 00:10:24,790
so we know we can create a variant and

00:10:14,430 --> 00:10:26,410
when you make a variant the default the

00:10:24,790 --> 00:10:28,990
default constructor

00:10:26,410 --> 00:10:30,760
just initializes to the first

00:10:28,990 --> 00:10:32,199
alternative so if the first alternative

00:10:30,760 --> 00:10:34,329
like string has a default constructor

00:10:32,199 --> 00:10:36,639
which it does then the variant is going

00:10:34,329 --> 00:10:39,029
to initialize to a string which is empty

00:10:36,639 --> 00:10:41,829
all right that's just the rule

00:10:39,029 --> 00:10:43,750
assignment so I can say V equals 3 it

00:10:41,829 --> 00:10:44,949
says okay I'm assigning to an int that

00:10:43,750 --> 00:10:48,370
means I need to switch to now I'm

00:10:44,949 --> 00:10:50,079
holding an int or V equals hello world

00:10:48,370 --> 00:10:51,670
in a string that it'll realize that that

00:10:50,079 --> 00:10:53,139
needs to be a string and it'll do the

00:10:51,670 --> 00:10:55,510
right thing that's how you change the

00:10:53,139 --> 00:10:58,569
value of a variance extracting a value

00:10:55,510 --> 00:10:59,890
is a little bit more complicated in this

00:10:58,569 --> 00:11:03,080
case we're going to write our output

00:10:59,890 --> 00:11:08,450
here and you use this boost get

00:11:03,080 --> 00:11:11,540
thing boost get takes a single template

00:11:08,450 --> 00:11:13,370
parameter which is which type you want

00:11:11,540 --> 00:11:16,250
to pull out of it

00:11:13,370 --> 00:11:18,740
and it can take in a pointer to a

00:11:16,250 --> 00:11:20,060
variant it will return null if it

00:11:18,740 --> 00:11:23,120
doesn't have that particular alternative

00:11:20,060 --> 00:11:25,430
active or it will return a pointer to

00:11:23,120 --> 00:11:30,310
the active thing and then you can do

00:11:25,430 --> 00:11:33,860
stuff with it boosts yet also takes in a

00:11:30,310 --> 00:11:36,050
if you pass in a reference as opposed to

00:11:33,860 --> 00:11:38,150
a pointer to it now you're going to get

00:11:36,050 --> 00:11:40,670
an exception thrown if the type you

00:11:38,150 --> 00:11:41,900
requested happens to be the wrong type

00:11:40,670 --> 00:11:47,810
it doesn't actually have that one on the

00:11:41,900 --> 00:11:49,370
inside so that's how that works there's

00:11:47,810 --> 00:11:52,490
another way to do it and that's where

00:11:49,370 --> 00:11:56,690
the visitor so what you do is you make a

00:11:52,490 --> 00:11:58,340
struct and you define a call operator

00:11:56,690 --> 00:12:01,820
for it and you overload it

00:11:58,340 --> 00:12:04,040
one overload per type per alternative

00:12:01,820 --> 00:12:08,060
type which is in your variant so in this

00:12:04,040 --> 00:12:09,890
case we have two here we have one which

00:12:08,060 --> 00:12:12,830
takes in a string the other one which

00:12:09,890 --> 00:12:14,870
takes in an int and you have the special

00:12:12,830 --> 00:12:16,250
using result type equals void because

00:12:14,870 --> 00:12:18,500
these operators here can return

00:12:16,250 --> 00:12:21,050
something so it needs to be figured that

00:12:18,500 --> 00:12:23,270
out and then you call boost apply

00:12:21,050 --> 00:12:26,900
visitor you pass in an instance to your

00:12:23,270 --> 00:12:28,730
visitor and the variant and it it does

00:12:26,900 --> 00:12:32,870
the right thing is which selects it for

00:12:28,730 --> 00:12:34,490
you so would you use get or visitor and

00:12:32,870 --> 00:12:36,140
so the benefits of visitor is that you

00:12:34,490 --> 00:12:38,780
get a compile time guarantee that all of

00:12:36,140 --> 00:12:42,770
your cases are handled which is really

00:12:38,780 --> 00:12:44,270
really nice because if you happen to

00:12:42,770 --> 00:12:46,300
miss one and you don't have an overload

00:12:44,270 --> 00:12:50,030
for something you'll just get a compiler

00:12:46,300 --> 00:12:51,770
the benefits of using get are the code

00:12:50,030 --> 00:12:53,000
is right next to the usage right you can

00:12:51,770 --> 00:12:54,500
have it in the function you don't have

00:12:53,000 --> 00:12:56,960
to make this separate struct somewhere

00:12:54,500 --> 00:13:00,320
else this far away and you get this

00:12:56,960 --> 00:13:03,530
really nice succinct syntax my

00:13:00,320 --> 00:13:06,650
recommendation is to always use the

00:13:03,530 --> 00:13:07,820
visitor just because it gives you a lot

00:13:06,650 --> 00:13:09,380
more confidence when you have to

00:13:07,820 --> 00:13:11,030
refactor your code if you if you always

00:13:09,380 --> 00:13:13,970
use visitor for example if you add

00:13:11,030 --> 00:13:15,410
another alternative to your variant type

00:13:13,970 --> 00:13:16,490
let's say you add a new command or

00:13:15,410 --> 00:13:18,290
something like that

00:13:16,490 --> 00:13:21,080
a compile error in every single place

00:13:18,290 --> 00:13:23,839
where that wasn't handled properly

00:13:21,080 --> 00:13:27,890
whereas if you're using get runtime

00:13:23,839 --> 00:13:30,950
errors so we got 12 years of experience

00:13:27,890 --> 00:13:35,180
with variant since it came out what what

00:13:30,950 --> 00:13:37,070
kind of stuff did we learn so the

00:13:35,180 --> 00:13:39,140
examples that I gave this using whatever

00:13:37,070 --> 00:13:41,089
equals some kind of variant there these

00:13:39,140 --> 00:13:44,200
are problematic type tests in general

00:13:41,089 --> 00:13:47,260
are problematic but this in particular

00:13:44,200 --> 00:13:51,020
we don't have a forward declaration of a

00:13:47,260 --> 00:13:52,880
of a type def so if you have headers and

00:13:51,020 --> 00:13:54,800
you want to just say I'm gonna use this

00:13:52,880 --> 00:13:56,750
variant type or whatever you have to

00:13:54,800 --> 00:13:59,209
include the other header that defines

00:13:56,750 --> 00:14:00,800
the variant you can't just forward

00:13:59,209 --> 00:14:02,390
declare it and then get your improved

00:14:00,800 --> 00:14:04,339
compilation speeds so that's really

00:14:02,390 --> 00:14:05,600
annoying the error messages are

00:14:04,339 --> 00:14:07,550
completely unreadable because

00:14:05,600 --> 00:14:09,140
everything's gonna refer to this variant

00:14:07,550 --> 00:14:10,310
template of all this kind of stuff where

00:14:09,140 --> 00:14:15,920
I really want the error message to

00:14:10,310 --> 00:14:18,740
mention command and if we're really if

00:14:15,920 --> 00:14:19,790
we have a unique type that corresponds

00:14:18,740 --> 00:14:21,680
to the data structure we're trying to

00:14:19,790 --> 00:14:24,440
define that really matches that are

00:14:21,680 --> 00:14:27,230
intended semantics right we want to have

00:14:24,440 --> 00:14:28,610
it a command be a thing it's not just a

00:14:27,230 --> 00:14:31,940
variant of these things no it's a

00:14:28,610 --> 00:14:34,190
command so we'd like to have to be able

00:14:31,940 --> 00:14:37,910
to define a name for our variant that's

00:14:34,190 --> 00:14:41,029
like a real name so one way to do this

00:14:37,910 --> 00:14:44,959
is to use inheritance this works okay so

00:14:41,029 --> 00:14:46,399
you make your struct give it a name so

00:14:44,959 --> 00:14:48,709
this case commands you inherit from

00:14:46,399 --> 00:14:52,130
variant and then you define your three

00:14:48,709 --> 00:14:54,560
constructors with some boilerplate code

00:14:52,130 --> 00:14:55,970
and you just pass on the different

00:14:54,560 --> 00:14:59,930
constructors to the varying constructor

00:14:55,970 --> 00:15:01,220
underneath this works you can do your

00:14:59,930 --> 00:15:02,990
forward declarations you get better

00:15:01,220 --> 00:15:05,510
error messages but there's a lot of

00:15:02,990 --> 00:15:06,860
boilerplate involved especially when

00:15:05,510 --> 00:15:08,630
working with older compilers this

00:15:06,860 --> 00:15:12,110
boilerplate I showed here works with

00:15:08,630 --> 00:15:14,980
newer compilers another way to do it is

00:15:12,110 --> 00:15:17,750
to wrap it so I just make a struct

00:15:14,980 --> 00:15:19,790
struct this case called command and I

00:15:17,750 --> 00:15:23,209
just have a single member which is the

00:15:19,790 --> 00:15:25,970
variant on the inside this is a lot

00:15:23,209 --> 00:15:28,250
simpler but users need to unwrap it by

00:15:25,970 --> 00:15:29,329
using the value field so if I happen to

00:15:28,250 --> 00:15:31,699
take into command as

00:15:29,329 --> 00:15:33,860
argument and I need to do some kind of

00:15:31,699 --> 00:15:36,920
get the variant on the inside I have to

00:15:33,860 --> 00:15:41,809
call valya okay not that big of a deal

00:15:36,920 --> 00:15:47,899
but it's something so back to that

00:15:41,809 --> 00:15:50,059
example the recursive example how do we

00:15:47,899 --> 00:15:52,339
make a variant for this well you can't

00:15:50,059 --> 00:15:54,259
if you're using the type def thing you

00:15:52,339 --> 00:15:56,509
can't refer to the type def that you're

00:15:54,259 --> 00:15:58,970
assigning to or that you're defining on

00:15:56,509 --> 00:16:00,739
the right hand side of the type def so

00:15:58,970 --> 00:16:01,360
just using direct recursion is gonna

00:16:00,739 --> 00:16:04,579
work

00:16:01,360 --> 00:16:07,420
what boost variant did is they provided

00:16:04,579 --> 00:16:10,129
this special make recursive variant

00:16:07,420 --> 00:16:11,569
function so what you do is you define

00:16:10,129 --> 00:16:13,639
your alternatives with a template

00:16:11,569 --> 00:16:16,489
argument which refers to the overall

00:16:13,639 --> 00:16:19,720
variant that you're defining you call

00:16:16,489 --> 00:16:24,439
that magic make recursive variant

00:16:19,720 --> 00:16:26,720
template and when you refer to your

00:16:24,439 --> 00:16:28,819
recursive alternatives on the inside you

00:16:26,720 --> 00:16:32,360
have this boost recursive variant thing

00:16:28,819 --> 00:16:34,509
that you just call it so you get a

00:16:32,360 --> 00:16:37,040
really tight syntax when you do this

00:16:34,509 --> 00:16:39,110
there are hidden allocations on the

00:16:37,040 --> 00:16:40,549
inside when you do a recursive variant

00:16:39,110 --> 00:16:42,679
which makes sense right if you're

00:16:40,549 --> 00:16:43,730
defining a tree there's no way you're

00:16:42,679 --> 00:16:46,970
gonna be able to make a tree without

00:16:43,730 --> 00:16:49,100
some kind of allocation there so it

00:16:46,970 --> 00:16:51,410
hides all that for you

00:16:49,100 --> 00:16:56,480
the other alternative to this is doing a

00:16:51,410 --> 00:16:58,369
direct recursion in this case we're

00:16:56,480 --> 00:17:00,829
making our binary tree our template

00:16:58,369 --> 00:17:02,449
argument is the leaf data so I forward

00:17:00,829 --> 00:17:03,919
declare the binary tree which is going

00:17:02,449 --> 00:17:08,209
to be our thing which we define overall

00:17:03,919 --> 00:17:09,529
and we define our branch here and here

00:17:08,209 --> 00:17:13,069
we have a shared pointer to the binary

00:17:09,529 --> 00:17:14,510
tree of leaf data which which is why we

00:17:13,069 --> 00:17:16,880
needed to have this for declared and

00:17:14,510 --> 00:17:18,549
then I just do that similar pattern

00:17:16,880 --> 00:17:20,779
which you saw before on the other slide

00:17:18,549 --> 00:17:25,459
when I want to get a new type out of the

00:17:20,779 --> 00:17:27,079
thing so this works pretty well we've

00:17:25,459 --> 00:17:29,000
got complete control over allocation in

00:17:27,079 --> 00:17:31,279
this case see we got to decide that we

00:17:29,000 --> 00:17:32,480
want her to use a shared pointer or you

00:17:31,279 --> 00:17:35,240
can use whatever kind of pointer you

00:17:32,480 --> 00:17:37,820
want the boost thing doesn't give you

00:17:35,240 --> 00:17:41,360
any power over that we can do our

00:17:37,820 --> 00:17:43,000
forward Eckler ations to boot and it's

00:17:41,360 --> 00:17:44,980
more straightforward to

00:17:43,000 --> 00:17:47,260
so if you're going to do a recursive

00:17:44,980 --> 00:17:50,530
variant this is the technique that I

00:17:47,260 --> 00:17:52,270
would recommend to use it is really not

00:17:50,530 --> 00:17:57,340
that much longer than the make recursive

00:17:52,270 --> 00:18:01,059
air anything so the assignment problem

00:17:57,340 --> 00:18:03,299
if you have a variant of a and B and you

00:18:01,059 --> 00:18:07,120
initialize it to an a value of type a

00:18:03,299 --> 00:18:09,970
what happens when you assign it to be so

00:18:07,120 --> 00:18:13,210
conceptually the variance a is

00:18:09,970 --> 00:18:14,530
destructed we have an index instead of

00:18:13,210 --> 00:18:15,820
two because every barrier needs to keep

00:18:14,530 --> 00:18:17,820
track of which kind of thing is

00:18:15,820 --> 00:18:20,890
referring to so the index is updated and

00:18:17,820 --> 00:18:24,640
then the B is now initialized to the

00:18:20,890 --> 00:18:29,500
right hand side value this can be

00:18:24,640 --> 00:18:30,880
problematic if when I try to take that B

00:18:29,500 --> 00:18:33,150
and initialize it from the right hand

00:18:30,880 --> 00:18:36,640
side value I get an exception thrown

00:18:33,150 --> 00:18:38,559
okay now I'm in trouble because I can't

00:18:36,640 --> 00:18:42,580
go back to the a that I just had before

00:18:38,559 --> 00:18:47,039
because I destroyed it right because I'm

00:18:42,580 --> 00:18:50,020
using one space piece there I can't

00:18:47,039 --> 00:18:52,120
initialize a B or an A because that

00:18:50,020 --> 00:18:54,059
might also throw an exception so what

00:18:52,120 --> 00:18:57,130
the heck do I do

00:18:54,059 --> 00:19:00,039
so boost variant made a decision on this

00:18:57,130 --> 00:19:02,020
and I'm not gonna go into detail to how

00:19:00,039 --> 00:19:05,110
it works but essentially what they do is

00:19:02,020 --> 00:19:08,080
they allocate on the heap extra space

00:19:05,110 --> 00:19:09,820
every time you do an assignment and they

00:19:08,080 --> 00:19:12,700
move the current contents up there in

00:19:09,820 --> 00:19:13,960
the heap then you initialize the B and

00:19:12,700 --> 00:19:16,710
if that throws and I still have the old

00:19:13,960 --> 00:19:19,299
thing and I can put it back in there so

00:19:16,710 --> 00:19:22,330
this can be problematic and we'll talk

00:19:19,299 --> 00:19:23,830
about that later so the way that people

00:19:22,330 --> 00:19:25,150
work around this because people hate

00:19:23,830 --> 00:19:27,929
allocations especially when we're

00:19:25,150 --> 00:19:30,370
talking low-level stuff like a variant

00:19:27,929 --> 00:19:32,980
you can ensure that all the types are no

00:19:30,370 --> 00:19:34,059
throw copy constructible right because

00:19:32,980 --> 00:19:35,559
then you just know that it's not gonna

00:19:34,059 --> 00:19:39,309
throw on copy so you don't have to have

00:19:35,559 --> 00:19:41,590
to do the the heap allocation you can

00:19:39,309 --> 00:19:43,780
ensure that one type is no throw default

00:19:41,590 --> 00:19:45,340
constructible if you happen to have an

00:19:43,780 --> 00:19:46,720
INT in there then you just say okay well

00:19:45,340 --> 00:19:48,400
if this special thing happens that I'm

00:19:46,720 --> 00:19:49,780
just going to initialize the int to zero

00:19:48,400 --> 00:19:51,340
I know that's not gonna throw an

00:19:49,780 --> 00:19:53,799
exception so that way you can work

00:19:51,340 --> 00:19:56,500
around the issue or you can always use

00:19:53,799 --> 00:19:58,420
this type called boost blank

00:19:56,500 --> 00:20:00,850
the first alternative for the Burien

00:19:58,420 --> 00:20:06,790
type that's essentially like an empty

00:20:00,850 --> 00:20:09,400
state so that's boost variant now let's

00:20:06,790 --> 00:20:11,850
talk about stood variant so axial Newman

00:20:09,400 --> 00:20:14,050
is the one who's been working on this

00:20:11,850 --> 00:20:16,450
that's the paper number if you want to

00:20:14,050 --> 00:20:17,860
look it up and there are two fully

00:20:16,450 --> 00:20:21,340
conforming implementations that are

00:20:17,860 --> 00:20:23,230
available I use Anthony Williams one and

00:20:21,340 --> 00:20:24,670
he's run this conference so if he's

00:20:23,230 --> 00:20:26,680
there if you see him thank him for that

00:20:24,670 --> 00:20:29,140
cuz it's awesome so you just take this

00:20:26,680 --> 00:20:31,060
variant header from his github site and

00:20:29,140 --> 00:20:32,350
you just plop it into your project maybe

00:20:31,060 --> 00:20:36,700
change the namespace and start using it

00:20:32,350 --> 00:20:38,380
works awesome so so what's the

00:20:36,700 --> 00:20:41,830
difference what do they do overboost

00:20:38,380 --> 00:20:44,850
variant so number one they the apply

00:20:41,830 --> 00:20:47,080
visitor function was renamed to visit

00:20:44,850 --> 00:20:48,820
okay and there's one little subtlety

00:20:47,080 --> 00:20:51,460
here note that you don't need to do that

00:20:48,820 --> 00:20:53,650
special type def in our output visitor

00:20:51,460 --> 00:20:56,460
thing anymore because we can figure out

00:20:53,650 --> 00:20:58,660
the right return value these days so

00:20:56,460 --> 00:21:00,280
that's nice just a little bit shorter

00:20:58,660 --> 00:21:06,010
it'll make the code a little bit cleaner

00:21:00,280 --> 00:21:09,640
maybe cool the second change is that get

00:21:06,010 --> 00:21:11,830
was reworked so you know how if you took

00:21:09,640 --> 00:21:12,940
get any pass that a pointer would do one

00:21:11,830 --> 00:21:14,590
thing and if you pass it a reference

00:21:12,940 --> 00:21:16,180
that would do another thing well they

00:21:14,590 --> 00:21:20,020
decided to split that into two different

00:21:16,180 --> 00:21:23,110
functions so we have get if and get so

00:21:20,020 --> 00:21:25,120
if you want to see if it if it might

00:21:23,110 --> 00:21:26,890
have a string in this case then you use

00:21:25,120 --> 00:21:28,210
get underscore if and it will return a

00:21:26,890 --> 00:21:35,470
pointer you can query whether or not a

00:21:28,210 --> 00:21:38,800
small change three is you can use get

00:21:35,470 --> 00:21:41,230
using an index now so instead of having

00:21:38,800 --> 00:21:43,390
to specify the type and get you can

00:21:41,230 --> 00:21:44,680
specify oh the zero with alternative or

00:21:43,390 --> 00:21:46,630
the first alternative or the second

00:21:44,680 --> 00:21:48,730
alternative this is something you would

00:21:46,630 --> 00:21:50,380
normally want to use in encode but if

00:21:48,730 --> 00:21:53,170
you're doing generic programming it can

00:21:50,380 --> 00:21:54,460
be quite useful and along those same

00:21:53,170 --> 00:21:55,810
lines

00:21:54,460 --> 00:21:58,600
this fourth changes you can have

00:21:55,810 --> 00:21:59,890
duplicated entries in a variant which

00:21:58,600 --> 00:22:01,660
can kind of be confusing you've pretty

00:21:59,890 --> 00:22:03,640
much got to use the index based access

00:22:01,660 --> 00:22:05,530
when you when this comes up and you

00:22:03,640 --> 00:22:07,690
normally wouldn't want to do this and

00:22:05,530 --> 00:22:08,920
user code but again if you're doing some

00:22:07,690 --> 00:22:10,720
kind of

00:22:08,920 --> 00:22:12,400
generic programming it's nice to be able

00:22:10,720 --> 00:22:14,560
to have a variant which can handle

00:22:12,400 --> 00:22:18,790
multiple had handle repeats of the same

00:22:14,560 --> 00:22:21,580
type there's no more special recursion

00:22:18,790 --> 00:22:24,550
support as there wasn't boost but that's

00:22:21,580 --> 00:22:26,350
okay because we didn't like the special

00:22:24,550 --> 00:22:29,920
recursion support the boost had anyway

00:22:26,350 --> 00:22:32,670
so just do what I was suggesting earlier

00:22:29,920 --> 00:22:35,770
when you need to have a recursive berry

00:22:32,670 --> 00:22:38,440
change six we're not calling it boosts

00:22:35,770 --> 00:22:43,780
blank anymore we're calling it stood

00:22:38,440 --> 00:22:46,750
mono States okay so this is a cosmetic

00:22:43,780 --> 00:22:49,060
thing stood mono state can be used in

00:22:46,750 --> 00:22:50,860
other ways besides just in variant it's

00:22:49,060 --> 00:22:53,950
just basically a type which has exactly

00:22:50,860 --> 00:22:55,390
one value has less than and all these

00:22:53,950 --> 00:22:58,540
operators defined for it which do the

00:22:55,390 --> 00:23:03,790
thing that you would expect it to so you

00:22:58,540 --> 00:23:07,030
have that so the allocation and

00:23:03,790 --> 00:23:09,130
assignment that was removed so just to

00:23:07,030 --> 00:23:11,650
give you some background on this stood

00:23:09,130 --> 00:23:13,660
variant was a very contentious thing on

00:23:11,650 --> 00:23:18,160
the standardization committee there were

00:23:13,660 --> 00:23:20,260
literally over a thousand emails spent

00:23:18,160 --> 00:23:23,370
discussing the design of this thing and

00:23:20,260 --> 00:23:27,040
most of them were unchanged severn

00:23:23,370 --> 00:23:30,610
everybody wanted this allocation and

00:23:27,040 --> 00:23:31,960
assignment to go away everybody but not

00:23:30,610 --> 00:23:36,130
everybody wanted to go away in the same

00:23:31,960 --> 00:23:39,850
way so that is where there were some big

00:23:36,130 --> 00:23:43,870
discussions so there were two main camps

00:23:39,850 --> 00:23:46,660
one is to have an explicit empty these

00:23:43,870 --> 00:23:48,280
people said that you know if there's an

00:23:46,660 --> 00:23:51,190
exception thrown on assignment the

00:23:48,280 --> 00:23:52,990
variant goes into some empty state so

00:23:51,190 --> 00:23:54,790
any variant with alternatives you have

00:23:52,990 --> 00:23:56,890
this empty state you can to make it

00:23:54,790 --> 00:23:59,890
empty you can make it not empty or

00:23:56,890 --> 00:24:01,270
whatever prose about this predictable

00:23:59,890 --> 00:24:02,920
space usage right there's not any kind

00:24:01,270 --> 00:24:04,780
of double buffering or anything that got

00:24:02,920 --> 00:24:06,340
going on it always goes to the empty

00:24:04,780 --> 00:24:08,800
state if it needs to

00:24:06,340 --> 00:24:11,440
and it's teachable and that it's easy to

00:24:08,800 --> 00:24:12,730
explain a variant can be empty the cons

00:24:11,440 --> 00:24:16,510
here is that this is Error poro

00:24:12,730 --> 00:24:19,420
error-prone so imagine you're you have

00:24:16,510 --> 00:24:22,429
your tree structure and every single

00:24:19,420 --> 00:24:23,629
node in that could be empty so

00:24:22,429 --> 00:24:25,820
how many different empty states does

00:24:23,629 --> 00:24:27,639
your tree have like a whole ton of all

00:24:25,820 --> 00:24:30,049
different kinds of empty states that's

00:24:27,639 --> 00:24:32,629
really not what the programmer intended

00:24:30,049 --> 00:24:35,149
so that's you really want it to not be

00:24:32,629 --> 00:24:37,190
empty for that kind of case and the

00:24:35,149 --> 00:24:38,450
semantics become complex as a result so

00:24:37,190 --> 00:24:39,740
every single function that you're right

00:24:38,450 --> 00:24:40,999
which takes in one of your variants you

00:24:39,740 --> 00:24:42,190
have to have a precondition which says

00:24:40,999 --> 00:24:44,090
the thing isn't empty

00:24:42,190 --> 00:24:47,240
those were the drawbacks with this

00:24:44,090 --> 00:24:48,950
alternative the second alternative this

00:24:47,240 --> 00:24:50,809
is the alternative that I was pushing

00:24:48,950 --> 00:24:53,749
for but nobody on the committee ever

00:24:50,809 --> 00:24:55,279
guess what they really want so this one

00:24:53,749 --> 00:24:58,879
has the never empty guarantee and you

00:24:55,279 --> 00:25:02,029
just make it double buffered if it has

00:24:58,879 --> 00:25:03,830
to be double buffered if it's a friendly

00:25:02,029 --> 00:25:06,139
type you know if all the alternatives

00:25:03,830 --> 00:25:07,399
happen to be no throw a sign or no throw

00:25:06,139 --> 00:25:09,200
constructible all that kind of stuff

00:25:07,399 --> 00:25:11,559
then you don't double buffer so only

00:25:09,200 --> 00:25:14,090
double buffer exactly when you have to

00:25:11,559 --> 00:25:17,450
you get these really simple semantics

00:25:14,090 --> 00:25:18,740
never empty is what most people need the

00:25:17,450 --> 00:25:20,840
cons here is that it's difficult to

00:25:18,740 --> 00:25:22,669
predict and control your space

00:25:20,840 --> 00:25:23,749
requirements because what defines a

00:25:22,669 --> 00:25:26,240
friendly type I put that in quotes

00:25:23,749 --> 00:25:29,269
friendly because it's so hard to explain

00:25:26,240 --> 00:25:31,610
so it's just really hard to look at a

00:25:29,269 --> 00:25:34,580
variant like this and decide oh is this

00:25:31,610 --> 00:25:37,369
using double buffering or not and you're

00:25:34,580 --> 00:25:40,009
paying a high price how often does an

00:25:37,369 --> 00:25:43,070
exception get thrown on assignment like

00:25:40,009 --> 00:25:44,360
hardly ever and when it does get thrown

00:25:43,070 --> 00:25:46,820
it's usually because you're out of

00:25:44,360 --> 00:25:48,679
memory in which case you're gonna just

00:25:46,820 --> 00:25:50,539
blow up your program anyway this you

00:25:48,679 --> 00:25:51,830
don't really recover from that there may

00:25:50,539 --> 00:25:57,110
be three people in the universe who care

00:25:51,830 --> 00:26:01,340
about that scenario so what we got is a

00:25:57,110 --> 00:26:06,860
compromise which is a variant which is

00:26:01,340 --> 00:26:10,220
rarely empty so the empty state is

00:26:06,860 --> 00:26:12,320
called valueless by exception that long

00:26:10,220 --> 00:26:15,799
name was specifically engineered to

00:26:12,320 --> 00:26:18,980
scare you away from it don't think about

00:26:15,799 --> 00:26:20,960
it if an exception is thrown on

00:26:18,980 --> 00:26:24,610
assignment you put the variant into the

00:26:20,960 --> 00:26:27,230
valueless by exception state and

00:26:24,610 --> 00:26:28,669
friendly types cannot get into the

00:26:27,230 --> 00:26:31,100
valueless by exception state it's just

00:26:28,669 --> 00:26:32,450
impossible for friendly types but the

00:26:31,100 --> 00:26:34,789
pros here is you get the predictable

00:26:32,450 --> 00:26:36,830
space usage is not double buffering it's

00:26:34,789 --> 00:26:38,690
teachable

00:26:36,830 --> 00:26:40,820
there are simple semantics in normal

00:26:38,690 --> 00:26:43,970
normal usage if you're doing abnormal

00:26:40,820 --> 00:26:47,119
things first stop like you shouldn't be

00:26:43,970 --> 00:26:48,499
doing that second okay we're giving you

00:26:47,119 --> 00:26:51,009
this flag so that you can do your

00:26:48,499 --> 00:26:53,090
abnormal things and the biggest concern

00:26:51,009 --> 00:26:56,239
about this approach is that we got

00:26:53,090 --> 00:26:58,669
consensus and very is in the standard in

00:26:56,239 --> 00:27:00,980
my opinion many many many years late

00:26:58,669 --> 00:27:03,590
so the cons here is that in the

00:27:00,980 --> 00:27:05,960
exceptional case when your assignment

00:27:03,590 --> 00:27:08,419
does throw you have to make sure that

00:27:05,960 --> 00:27:13,369
you think about your variant being in

00:27:08,419 --> 00:27:14,779
this value list by exception state so

00:27:13,369 --> 00:27:18,859
when do you what does this actually come

00:27:14,779 --> 00:27:21,109
up so it turns out you don't really need

00:27:18,859 --> 00:27:23,119
to know if it's invaluable exception

00:27:21,109 --> 00:27:24,619
state because you already had an

00:27:23,119 --> 00:27:27,080
exception thrown which said something

00:27:24,619 --> 00:27:29,869
along the lines of variant had an

00:27:27,080 --> 00:27:31,489
exception being thrown so you don't even

00:27:29,869 --> 00:27:33,139
really need something to query it if

00:27:31,489 --> 00:27:35,690
you're querying it you're trying to

00:27:33,139 --> 00:27:39,350
reconstruct your data type that's been

00:27:35,690 --> 00:27:43,190
corrupted in a certain way which you

00:27:39,350 --> 00:27:44,480
shouldn't be doing so in the end you

00:27:43,190 --> 00:27:46,879
don't really ever have to deal with

00:27:44,480 --> 00:27:49,129
bayless by exception variance in normal

00:27:46,879 --> 00:27:50,419
code if you write a function you don't

00:27:49,129 --> 00:27:52,789
need a write precondition that it you

00:27:50,419 --> 00:27:54,799
know what the special usage is for

00:27:52,789 --> 00:27:56,389
bayless by exception just all of them

00:27:54,799 --> 00:27:58,220
are not in this state

00:27:56,389 --> 00:28:02,989
and they only get into this state in

00:27:58,220 --> 00:28:06,679
your exception handling code so that was

00:28:02,989 --> 00:28:08,269
the decision they're in to somewhat up

00:28:06,679 --> 00:28:09,919
stood variant these are mostly

00:28:08,269 --> 00:28:13,039
incremental improvements overboost

00:28:09,919 --> 00:28:15,409
variants nothing really spectacular out

00:28:13,039 --> 00:28:18,259
there the handling of exceptions on

00:28:15,409 --> 00:28:20,869
assignment was the big change from boost

00:28:18,259 --> 00:28:23,149
variant and this is in the c++ 17

00:28:20,869 --> 00:28:29,059
working paper coming to a compiler near

00:28:23,149 --> 00:28:31,460
you so before I go on let me just take a

00:28:29,059 --> 00:28:32,600
quick like maybe two questions if you

00:28:31,460 --> 00:28:38,080
have any questions on this come and talk

00:28:32,600 --> 00:28:38,080
about something else real quick question

00:28:46,370 --> 00:28:52,670
the question was did I have to use

00:28:49,250 --> 00:28:55,160
shared pointer in the example usage with

00:28:52,670 --> 00:28:59,830
the recursive variant because it had an

00:28:55,160 --> 00:28:59,830
incomplete type and the answer is yes

00:29:03,160 --> 00:29:09,740
what happens if you don't use exceptions

00:29:05,240 --> 00:29:11,980
I don't know if you don't use exceptions

00:29:09,740 --> 00:29:14,150
and nothing ever throws an exception

00:29:11,980 --> 00:29:26,210
then you never go into the venue list by

00:29:14,150 --> 00:29:28,040
exception state it's a non-issue if you

00:29:26,210 --> 00:29:30,050
visit a variant in the vein this

00:29:28,040 --> 00:29:32,390
exception state bailiffs by exception

00:29:30,050 --> 00:29:36,260
state first off you shouldn't be doing

00:29:32,390 --> 00:29:38,440
that second off you're going to get an

00:29:36,260 --> 00:29:38,440
exception

00:29:41,210 --> 00:29:49,920
okay I'm gonna move on so language

00:29:47,760 --> 00:29:54,000
support for variant this is this is my

00:29:49,920 --> 00:29:56,280
pet project here I think that variants

00:29:54,000 --> 00:29:59,640
come up often enough in code that having

00:29:56,280 --> 00:30:02,880
language level support for them would be

00:29:59,640 --> 00:30:04,560
very beneficial and I'll explain why so

00:30:02,880 --> 00:30:08,430
first let's just look at what it looks

00:30:04,560 --> 00:30:10,320
like so it looks a lot like a struct so

00:30:08,430 --> 00:30:12,960
in this case we have a variant that is

00:30:10,320 --> 00:30:17,240
used for a JSON object I assume you're

00:30:12,960 --> 00:30:20,400
all familiar with those and each field

00:30:17,240 --> 00:30:22,560
works exactly like a struct except

00:30:20,400 --> 00:30:24,420
instead of putting and in between all

00:30:22,560 --> 00:30:26,790
those lines we're putting or in between

00:30:24,420 --> 00:30:29,820
all those lines so the command either

00:30:26,790 --> 00:30:33,030
has a set score size T or it has a fire

00:30:29,820 --> 00:30:41,160
missile mono state or a fire laser or a

00:30:33,030 --> 00:30:44,730
rotate if you want to create a value of

00:30:41,160 --> 00:30:47,430
this command type you just call the

00:30:44,730 --> 00:30:49,200
field after : : now all the syntax is

00:30:47,430 --> 00:30:51,240
you know subject to change is just very

00:30:49,200 --> 00:30:54,120
early design stage the committee's only

00:30:51,240 --> 00:30:56,730
seen there's a couple times so far we

00:30:54,120 --> 00:30:58,290
have basic pattern matching so instead

00:30:56,730 --> 00:31:00,090
of having to put your struct

00:30:58,290 --> 00:31:02,730
some crazy place you can put it right

00:31:00,090 --> 00:31:06,270
there in line with an inspect statement

00:31:02,730 --> 00:31:09,420
so in this case we have a commands you

00:31:06,270 --> 00:31:14,010
inspect it if it's set score then you

00:31:09,420 --> 00:31:15,930
bind value to that size T I'll put it if

00:31:14,010 --> 00:31:18,840
it's fire missile you do something and

00:31:15,930 --> 00:31:23,670
and so on and so forth pretty

00:31:18,840 --> 00:31:25,770
straightforward one thing that came up

00:31:23,670 --> 00:31:27,630
is you know why do we need a language

00:31:25,770 --> 00:31:32,700
based variant is a light library

00:31:27,630 --> 00:31:35,520
solution sufficient let's see so here we

00:31:32,700 --> 00:31:40,110
have a variant exactly like what we were

00:31:35,520 --> 00:31:42,590
doing with the L variant there so we

00:31:40,110 --> 00:31:45,120
have to visit options we have type based

00:31:42,590 --> 00:31:46,740
we can get you know which alternative

00:31:45,120 --> 00:31:49,730
based on the type or we can do it based

00:31:46,740 --> 00:31:52,799
on the index

00:31:49,730 --> 00:31:54,690
so indexed based visit is kind of nasty

00:31:52,799 --> 00:31:56,760
right because you got to remember the

00:31:54,690 --> 00:31:58,559
names of the indices so maybe you're

00:31:56,760 --> 00:32:01,080
gonna want to like make these constants

00:31:58,559 --> 00:32:03,419
to say which thing in there corresponds

00:32:01,080 --> 00:32:06,000
to the index mr the requires more

00:32:03,419 --> 00:32:09,860
boilerplate it's error-prone if you if

00:32:06,000 --> 00:32:14,000
your indices wrong not really too nice

00:32:09,860 --> 00:32:17,820
type based visit is also kind of nasty

00:32:14,000 --> 00:32:21,510
so if I write stood get of unsigned what

00:32:17,820 --> 00:32:26,850
happens because size t could be a type

00:32:21,510 --> 00:32:29,850
def to unsigned will it compile does it

00:32:26,850 --> 00:32:32,610
give me the set score alternative is it

00:32:29,850 --> 00:32:37,950
platform dependent all the answers are

00:32:32,610 --> 00:32:39,929
bad right this is no good so what people

00:32:37,950 --> 00:32:43,679
do to work around this problem is they

00:32:39,929 --> 00:32:45,299
make these special tag structs so you

00:32:43,679 --> 00:32:46,919
have the different types in there so you

00:32:45,299 --> 00:32:48,540
have a struct for your set score or

00:32:46,919 --> 00:32:50,850
struct for your fire missile and so on

00:32:48,540 --> 00:32:54,120
and so forth this requires more

00:32:50,850 --> 00:32:56,490
boilerplate and it introduces these

00:32:54,120 --> 00:32:59,580
types which really don't make sense in

00:32:56,490 --> 00:33:02,669
isolation they really only make sense in

00:32:59,580 --> 00:33:05,940
when they're all put together so that's

00:33:02,669 --> 00:33:09,150
not too nice either so another way to

00:33:05,940 --> 00:33:10,559
think about it is the struct tuple

00:33:09,150 --> 00:33:14,360
connection because we have stood tuple

00:33:10,559 --> 00:33:19,530
and we have struct here's a point type

00:33:14,360 --> 00:33:21,270
with the x y&z field and using point

00:33:19,530 --> 00:33:23,070
equals stood tuple double double double

00:33:21,270 --> 00:33:24,240
so these are two different ways to make

00:33:23,070 --> 00:33:26,790
a point class you can make it with a

00:33:24,240 --> 00:33:28,590
struct you can make it with a tuple the

00:33:26,790 --> 00:33:32,549
tuple version has all the same problems

00:33:28,590 --> 00:33:34,890
as the indexed variant though you know

00:33:32,549 --> 00:33:36,990
do you get by it you get by index which

00:33:34,890 --> 00:33:38,820
index corresponds to x y&z maybe you can

00:33:36,990 --> 00:33:42,870
remember maybe you can't for a more

00:33:38,820 --> 00:33:46,940
complex case so then use type based

00:33:42,870 --> 00:33:50,370
dispatch and make these special struct x

00:33:46,940 --> 00:33:52,679
y&z and then you have using point equals

00:33:50,370 --> 00:33:54,450
a tuple of that so then what you have

00:33:52,679 --> 00:33:56,490
the strange field X like what are you

00:33:54,450 --> 00:33:57,900
gonna do with that that's doesn't have

00:33:56,490 --> 00:34:00,150
any meaning and isolation I don't think

00:33:57,900 --> 00:34:02,700
so now would anybody recommend doing

00:34:00,150 --> 00:34:03,330
this with a tuple instead of just using

00:34:02,700 --> 00:34:08,430
a struct

00:34:03,330 --> 00:34:11,700
no I don't think so so that's not saying

00:34:08,430 --> 00:34:13,290
that tuples don't have their use but I'm

00:34:11,700 --> 00:34:14,910
saying that Struck's have a use and

00:34:13,290 --> 00:34:18,810
tuples have a use it's nice to have them

00:34:14,910 --> 00:34:22,770
both l variants relate very closely to

00:34:18,810 --> 00:34:25,560
structs so you have an L variant and you

00:34:22,770 --> 00:34:28,800
have the corresponding stud variant of

00:34:25,560 --> 00:34:30,720
it and this is a Co point this is like a

00:34:28,800 --> 00:34:32,670
mathematical thing which says you know a

00:34:30,720 --> 00:34:37,380
certain amount of direction along X or Y

00:34:32,670 --> 00:34:40,980
or Z you get the exact same problems so

00:34:37,380 --> 00:34:42,480
same reasoning what's an X would anybody

00:34:40,980 --> 00:34:44,100
recommend using this instead of an L

00:34:42,480 --> 00:34:48,570
variant I don't think so

00:34:44,100 --> 00:34:51,240
so stud variants have their use but so

00:34:48,570 --> 00:34:52,410
do L variants and we're working on

00:34:51,240 --> 00:34:57,420
bringing these kinds of things another

00:34:52,410 --> 00:34:59,490
language so just a sampling of the stood

00:34:57,420 --> 00:35:01,800
variant problems if you use them a lot

00:34:59,490 --> 00:35:03,120
you get unhelpful error messages a lot

00:35:01,800 --> 00:35:06,630
of times because this is template

00:35:03,120 --> 00:35:09,060
programming the code for visitation is

00:35:06,630 --> 00:35:11,040
kind of ugly and there are portability

00:35:09,060 --> 00:35:13,710
of issues so like if you have this

00:35:11,040 --> 00:35:17,700
database handle thing there is this code

00:35:13,710 --> 00:35:19,410
future-proof mmm not likely because what

00:35:17,700 --> 00:35:21,390
if Oracle handle and Berkeley handle end

00:35:19,410 --> 00:35:23,040
up having the same underlying type at

00:35:21,390 --> 00:35:23,510
some point in the future that would be

00:35:23,040 --> 00:35:26,610
better

00:35:23,510 --> 00:35:28,740
so variants are simple and a common need

00:35:26,610 --> 00:35:31,710
but a library only solution is too

00:35:28,740 --> 00:35:33,420
complex but if that's all you got use it

00:35:31,710 --> 00:35:36,120
it's gonna make your code a lot better

00:35:33,420 --> 00:35:39,750
so our proposal is to make the basic

00:35:36,120 --> 00:35:45,510
language based variant pattern matching

00:35:39,750 --> 00:35:46,950
is closely tied to L variants so if you

00:35:45,510 --> 00:35:49,320
have an L variant here you do your

00:35:46,950 --> 00:35:53,100
pattern matching and you'll note that in

00:35:49,320 --> 00:35:54,630
the second one here set position I'm

00:35:53,100 --> 00:35:57,090
doing a pattern on the thing on the

00:35:54,630 --> 00:35:59,730
inside so if the position is like a pair

00:35:57,090 --> 00:36:01,410
of doubles then I can go ahead and match

00:35:59,730 --> 00:36:04,520
on the doubles and say that matches

00:36:01,410 --> 00:36:07,170
those and so on and so forth

00:36:04,520 --> 00:36:10,200
so the idea with the pattern matching

00:36:07,170 --> 00:36:11,340
proposals is that I can match on

00:36:10,200 --> 00:36:14,610
integrals and enums

00:36:11,340 --> 00:36:15,610
so if I have an in second do pattern

00:36:14,610 --> 00:36:19,660
matching on that

00:36:15,610 --> 00:36:22,270
I can do it on structs so if struct here

00:36:19,660 --> 00:36:24,550
I'm inspecting this one which has a name

00:36:22,270 --> 00:36:27,730
hit points and coins and my inspection

00:36:24,550 --> 00:36:32,170
statement I'm finding n2 the name h2 the

00:36:27,730 --> 00:36:35,080
hip points see the coins which is kind

00:36:32,170 --> 00:36:37,870
of ugly so we should really be able to

00:36:35,080 --> 00:36:38,740
match on the fields and and we do

00:36:37,870 --> 00:36:40,060
propose to do that

00:36:38,740 --> 00:36:44,920
so that way the code gets a little bit

00:36:40,060 --> 00:36:47,950
more clear however we don't want to just

00:36:44,920 --> 00:36:49,360
have pattern matching on structs and L

00:36:47,950 --> 00:36:52,870
variants because what if I have my own

00:36:49,360 --> 00:36:55,360
custom type which has private data and I

00:36:52,870 --> 00:36:58,390
want to provide a way for my consumers

00:36:55,360 --> 00:37:00,070
to match on that thing so the idea is to

00:36:58,390 --> 00:37:04,870
also provide an opt-in if you have your

00:37:00,070 --> 00:37:06,850
special type like in this case a a pair

00:37:04,870 --> 00:37:10,240
where the first and second members are

00:37:06,850 --> 00:37:12,790
private I should be able to make an

00:37:10,240 --> 00:37:14,710
operator extract that provides the

00:37:12,790 --> 00:37:16,510
compiler this information to say that

00:37:14,710 --> 00:37:18,640
when someone matches on this this is how

00:37:16,510 --> 00:37:22,540
I want it to behave I'm not gonna go

00:37:18,640 --> 00:37:25,690
into more detail than that because it's

00:37:22,540 --> 00:37:26,650
still ongoing work in terms of pattern

00:37:25,690 --> 00:37:28,630
matching what we're gonna do with that

00:37:26,650 --> 00:37:30,250
but this kind of gives you a hint in

00:37:28,630 --> 00:37:34,870
terms of the direction that we're trying

00:37:30,250 --> 00:37:38,800
to head into so let's see how much more

00:37:34,870 --> 00:37:43,440
time do we have 20 minutes okay

00:37:38,800 --> 00:37:43,440
good thing I brought some extra slides

00:37:46,560 --> 00:37:50,530
so there are a couple of other proposals

00:37:48,910 --> 00:37:53,320
that are out there related to variance

00:37:50,530 --> 00:37:57,280
that I think are interesting so this one

00:37:53,320 --> 00:38:00,040
by Vincente the idea is to make a

00:37:57,280 --> 00:38:01,450
function called stood overload what this

00:38:00,040 --> 00:38:04,060
will do is it will take a bunch of

00:38:01,450 --> 00:38:06,280
lambda functions which each have a

00:38:04,060 --> 00:38:08,530
different kind of argument and combine

00:38:06,280 --> 00:38:09,970
them into one function object which acts

00:38:08,530 --> 00:38:13,600
like the kind of thing that you would

00:38:09,970 --> 00:38:15,280
use the stud visit on what this buys you

00:38:13,600 --> 00:38:17,200
is instead of having to make this struct

00:38:15,280 --> 00:38:20,110
in some other area of the code you can

00:38:17,200 --> 00:38:22,930
do your visit in line like this so this

00:38:20,110 --> 00:38:24,550
is not in C++ 17 didn't make it in time

00:38:22,930 --> 00:38:26,260
but the libraries available this is

00:38:24,550 --> 00:38:29,290
something that you can use and play

00:38:26,260 --> 00:38:32,880
around with and it makes the code

00:38:29,290 --> 00:38:36,460
a little bit nicer to work with and

00:38:32,880 --> 00:38:41,290
second bonus slide visitors with extra

00:38:36,460 --> 00:38:44,890
arguments so a lot of times you need to

00:38:41,290 --> 00:38:47,440
do a visitor but you you want to have

00:38:44,890 --> 00:38:50,350
other data available to you when you're

00:38:47,440 --> 00:38:52,120
going through your different alternative

00:38:50,350 --> 00:38:53,530
types you want to have like extra

00:38:52,120 --> 00:38:57,070
parameters that apply to all the

00:38:53,530 --> 00:38:59,230
different alternative cases so there's a

00:38:57,070 --> 00:39:01,480
nifty way that you can do that the first

00:38:59,230 --> 00:39:07,960
thing you do is so this is just a design

00:39:01,480 --> 00:39:13,980
pattern you you forward to Claire your

00:39:07,960 --> 00:39:18,150
function in this case put and in your

00:39:13,980 --> 00:39:20,170
your struct which is your visitor here

00:39:18,150 --> 00:39:33,270
are you guys seeing me scroll down

00:39:20,170 --> 00:39:33,270
is that working hierarchies don't work

00:39:34,440 --> 00:39:42,520
there okay so you forward declare your

00:39:38,020 --> 00:39:44,080
thing your your visitor and then each of

00:39:42,520 --> 00:39:47,110
your operations you add the extra

00:39:44,080 --> 00:39:48,550
argument that you care about in this

00:39:47,110 --> 00:39:50,050
case the Oh stream is the thing that we

00:39:48,550 --> 00:39:56,320
want to make sure is there in our case

00:39:50,050 --> 00:39:57,730
statement and then finally when you

00:39:56,320 --> 00:40:00,880
implement your function you can use

00:39:57,730 --> 00:40:02,770
stood binds to take your visitor and

00:40:00,880 --> 00:40:04,660
bind this to the second argument of it

00:40:02,770 --> 00:40:08,760
or the first argument of it in this case

00:40:04,660 --> 00:40:11,410
and use that with your visit function so

00:40:08,760 --> 00:40:17,800
it comes up every now and then it's a

00:40:11,410 --> 00:40:21,010
good thing too now so this this is a

00:40:17,800 --> 00:40:22,360
very contentious subject on variant so

00:40:21,010 --> 00:40:26,560
I'm sure lots of you guys have questions

00:40:22,360 --> 00:40:30,360
comments and insults so let's let's

00:40:26,560 --> 00:40:30,360
let's get that let's do that right now

00:40:47,599 --> 00:40:52,349
so the question is are you going to be

00:40:50,339 --> 00:41:02,039
able to define like member functions

00:40:52,349 --> 00:41:03,869
into an L variant so or a default

00:41:02,039 --> 00:41:07,289
constructor so this is all stuff that's

00:41:03,869 --> 00:41:19,200
being investigated right now so probably

00:41:07,289 --> 00:41:20,519
yes so the question is how would the

00:41:19,200 --> 00:41:23,220
compiler underneath do this kind of

00:41:20,519 --> 00:41:24,779
pattern matching and the model that I

00:41:23,220 --> 00:41:26,730
have in my mind is you can take that

00:41:24,779 --> 00:41:29,039
pattern matching code and break it up

00:41:26,730 --> 00:41:32,039
into switch statements and nested switch

00:41:29,039 --> 00:41:33,630
statements so if that helps understand

00:41:32,039 --> 00:41:55,259
it but I'm further compiler does more

00:41:33,630 --> 00:41:57,539
crazy things was that this seems like a

00:41:55,259 --> 00:42:01,670
huge change in the language for justice

00:41:57,539 --> 00:42:01,670
variant feature okay

00:42:18,819 --> 00:42:23,410
so the question is what are the

00:42:19,809 --> 00:42:26,160
performance implications of using visit

00:42:23,410 --> 00:42:30,999
compared to other ways of doing this and

00:42:26,160 --> 00:42:33,539
the answer is when you look at the code

00:42:30,999 --> 00:42:36,099
which is generated based on using visit

00:42:33,539 --> 00:42:39,160
it's basically in lining all that stuff

00:42:36,099 --> 00:43:05,829
so what you get is the optimal code at

00:42:39,160 --> 00:43:09,339
the end it's wicked fast oh sorry so the

00:43:05,829 --> 00:43:12,099
comment was in the database example I'm

00:43:09,339 --> 00:43:15,789
assuming that the visitor is not

00:43:12,099 --> 00:43:19,449
visiting based on index and the question

00:43:15,789 --> 00:43:22,390
is is there a way to make one as far as

00:43:19,449 --> 00:43:25,089
I know there isn't a way to do that just

00:43:22,390 --> 00:43:38,829
yet to do a visit

00:43:25,089 --> 00:43:41,979
based on index only is there a way to

00:43:38,829 --> 00:44:08,880
use em place as opposed to copying yes

00:43:41,979 --> 00:44:13,779
you can you can do that the question is

00:44:08,880 --> 00:44:15,459
well you have to will it be smart enough

00:44:13,779 --> 00:44:19,239
to realize that my variance in my ell

00:44:15,459 --> 00:44:23,019
variance in enum and that's like way

00:44:19,239 --> 00:44:25,169
future like I have no idea my guess is

00:44:23,019 --> 00:44:25,169
yes

00:44:27,500 --> 00:44:49,160
ah the comment was that maybe you can

00:44:46,850 --> 00:44:54,250
use concepts for IFTA to do something

00:44:49,160 --> 00:45:16,760
like this he believes that we can so I

00:44:54,250 --> 00:45:19,010
will I'm encouraged so the comment was

00:45:16,760 --> 00:45:21,230
that it looks strikingly like structured

00:45:19,010 --> 00:45:23,720
bindings shouldn't we like share some

00:45:21,230 --> 00:45:26,480
kind of syntax and the answer is yeah

00:45:23,720 --> 00:45:27,440
definitely so we want to make sure that

00:45:26,480 --> 00:45:36,950
it's they're the same

00:45:27,440 --> 00:45:38,840
at the end of the day the question is if

00:45:36,950 --> 00:45:41,450
element were accepted with library based

00:45:38,840 --> 00:45:44,210
variant go away and the answer is no

00:45:41,450 --> 00:45:57,830
just like having struts doesn't mean

00:45:44,210 --> 00:45:59,390
that you don't need a tuple anymore so

00:45:57,830 --> 00:46:01,130
the question is are there any plans to

00:45:59,390 --> 00:46:05,270
have the pattern matching be exhaustive

00:46:01,130 --> 00:46:06,950
and to have a complaint if it's not that

00:46:05,270 --> 00:46:09,650
hasn't really been investigated too much

00:46:06,950 --> 00:46:12,680
yet but if it's not exhaustive and you

00:46:09,650 --> 00:46:13,400
use it in an expression then that's a

00:46:12,680 --> 00:46:15,770
big problem

00:46:13,400 --> 00:46:18,880
it's like undefined behavior or throw an

00:46:15,770 --> 00:46:18,880
exception or something I don't know

00:46:27,800 --> 00:46:33,630
we'll panet pattern-matching work

00:46:30,150 --> 00:46:36,270
withstood any there are some folks who

00:46:33,630 --> 00:46:40,340
would like it to work with stood any I'm

00:46:36,270 --> 00:46:40,340
not sure if I'm one of them or not yet

00:46:41,270 --> 00:46:46,740
what the committee has definitely said

00:46:43,470 --> 00:46:49,800
they want to be able to switch on a base

00:46:46,740 --> 00:46:50,820
class match on a base class and have

00:46:49,800 --> 00:46:53,100
different cases for the different

00:46:50,820 --> 00:46:55,560
derived classes personally I find that

00:46:53,100 --> 00:46:57,870
to be an abomination but if we need to

00:46:55,560 --> 00:47:16,980
do that to get it in then you know

00:46:57,870 --> 00:47:22,560
compromise so the question is are there

00:47:16,980 --> 00:47:24,930
anything used inside of I I assume

00:47:22,560 --> 00:47:27,390
you're talking about of student that we

00:47:24,930 --> 00:47:28,860
have available or in the interface

00:47:27,390 --> 00:47:31,400
itself that require you know special

00:47:28,860 --> 00:47:34,440
compilers or newer language support and

00:47:31,400 --> 00:47:37,550
the answer is no you you can implement a

00:47:34,440 --> 00:47:40,470
version of stood variant with C++ 11

00:47:37,550 --> 00:47:42,480
stuff or you can implement it without

00:47:40,470 --> 00:47:45,450
like the Special Move semantic stuff

00:47:42,480 --> 00:47:47,310
with C++ 98 there's nothing really

00:47:45,450 --> 00:47:49,500
special that it needs in terms of those

00:47:47,310 --> 00:47:50,130
implementations of what they use I'm not

00:47:49,500 --> 00:47:52,170
really sure

00:47:50,130 --> 00:48:04,350
I think they need at least C++ 11 cuz I

00:47:52,170 --> 00:48:06,420
know these very addicts questions are

00:48:04,350 --> 00:48:09,990
one of the leat the minimal changes

00:48:06,420 --> 00:48:16,320
required to implement L variants o plain

00:48:09,990 --> 00:48:18,540
variants I don't think that we need any

00:48:16,320 --> 00:48:20,640
changes to implement stood variant so

00:48:18,540 --> 00:48:23,280
still variant could have conceptually I

00:48:20,640 --> 00:48:24,990
mean it's going into C++ 17 right but it

00:48:23,280 --> 00:48:29,400
could have conceptually gone into C++ 11

00:48:24,990 --> 00:48:31,130
there's nothing it doesn't require any

00:48:29,400 --> 00:48:34,800
special new features to implement

00:48:31,130 --> 00:48:34,960
although the new features are convenient

00:48:34,800 --> 00:48:46,450
when

00:48:34,960 --> 00:48:50,290
want to implement it so are we talking

00:48:46,450 --> 00:48:53,940
about L variants like just stood

00:48:50,290 --> 00:48:56,320
variance yeah I don't think we need any

00:48:53,940 --> 00:48:58,270
language special sugar or anything to

00:48:56,320 --> 00:49:15,160
use it it's it's available you can use

00:48:58,270 --> 00:49:17,980
it now so the question is what do I see

00:49:15,160 --> 00:49:19,390
is the biggest obstacle of getting this

00:49:17,980 --> 00:49:24,430
kind of open pattern matching into the

00:49:19,390 --> 00:49:27,339
language you know it all kind of boils

00:49:24,430 --> 00:49:28,570
down to getting consensus like the way

00:49:27,339 --> 00:49:31,060
the committee works you have to have

00:49:28,570 --> 00:49:33,820
like 80% of the people agree that this

00:49:31,060 --> 00:49:35,530
is the way to go forward and you know if

00:49:33,820 --> 00:49:36,700
you have just thirty percent of the

00:49:35,530 --> 00:49:38,560
people who say I don't like it

00:49:36,700 --> 00:49:41,310
I'd rather just not have it then it's

00:49:38,560 --> 00:49:43,869
very difficult to to move past that so

00:49:41,310 --> 00:49:46,450
it's really coming up with a compelling

00:49:43,869 --> 00:49:53,940
argument which everybody agrees with or

00:49:46,450 --> 00:49:53,940
at least 80% questions

00:49:58,589 --> 00:50:02,250
I'm sorry Nikesh day

00:50:13,830 --> 00:50:21,550
that anybody understand that and maybe

00:50:19,830 --> 00:50:25,030
Nessa pattern-matching

00:50:21,550 --> 00:50:27,130
oh yes

00:50:25,030 --> 00:50:29,680
so nested pattern matching is definitely

00:50:27,130 --> 00:50:31,180
part of the plan to be able to have

00:50:29,680 --> 00:50:56,020
nested patterns in there yeah that's

00:50:31,180 --> 00:50:58,210
really important so the question is how

00:50:56,020 --> 00:51:01,210
does the language based matching stuff

00:50:58,210 --> 00:51:04,690
handle multiple visitation things and

00:51:01,210 --> 00:51:06,430
the idea is is that in your match call

00:51:04,690 --> 00:51:07,780
instead of just putting one thing in the

00:51:06,430 --> 00:51:10,750
parenthesis you can put multiple things

00:51:07,780 --> 00:51:14,560
with commas and then you know match

00:51:10,750 --> 00:51:24,760
based on that so just the exact same way

00:51:14,560 --> 00:51:26,800
that stood visit works the question is

00:51:24,760 --> 00:51:31,560
our new keywords required for the

00:51:26,800 --> 00:51:34,150
language based various stuff maybe so I

00:51:31,560 --> 00:51:37,330
started out with a proposal calling it

00:51:34,150 --> 00:51:42,180
an enum Union like in the enumerated

00:51:37,330 --> 00:51:47,470
Union and that was not very well liked

00:51:42,180 --> 00:51:51,270
so we'll see what we come up with there

00:51:47,470 --> 00:51:51,270
might be a new keyword or two

00:51:53,230 --> 00:51:57,860
coming as register is available now

00:51:56,410 --> 00:52:05,470
there you go

00:51:57,860 --> 00:52:05,470
will calm registers any other questions

00:52:22,090 --> 00:52:31,340
okay so the comment was right now the

00:52:28,790 --> 00:52:33,250
ordering matters what if we made the

00:52:31,340 --> 00:52:35,360
ordering not matter and you know a

00:52:33,250 --> 00:52:37,490
variant in two comma string is the same

00:52:35,360 --> 00:52:38,660
thing as a variant string comma int so

00:52:37,490 --> 00:52:42,590
this is something that we discussed on

00:52:38,660 --> 00:52:45,410
the committee and it turns out there are

00:52:42,590 --> 00:52:46,880
a lot of problems when you're trying to

00:52:45,410 --> 00:52:48,560
do template logic for that because we

00:52:46,880 --> 00:52:51,250
don't really have an ordering of types

00:52:48,560 --> 00:52:54,350
so we can't come up with a unique

00:52:51,250 --> 00:52:56,960
sequence given any kind of type that we

00:52:54,350 --> 00:52:59,110
can compare against another sequence so

00:52:56,960 --> 00:53:03,050
the implementation of that's really hard

00:52:59,110 --> 00:53:05,360
but also along those lines there was a

00:53:03,050 --> 00:53:07,580
desire to model a discriminated union

00:53:05,360 --> 00:53:09,200
where you really the ordering does

00:53:07,580 --> 00:53:10,580
matter with the discriminated Union it

00:53:09,200 --> 00:53:14,840
and what you're talking about is

00:53:10,580 --> 00:53:16,070
modeling a union so we just decided in

00:53:14,840 --> 00:53:17,660
the committee that we're going to go for

00:53:16,070 --> 00:53:20,090
modeling discriminated union and that's

00:53:17,660 --> 00:53:31,550
that affected all the rest of the pieces

00:53:20,090 --> 00:53:33,320
of the interface question is am i

00:53:31,550 --> 00:53:35,740
proposing underscores a match all or is

00:53:33,320 --> 00:53:38,930
that just a regular variable name so

00:53:35,740 --> 00:53:40,250
like the exact concrete syntax isn't

00:53:38,930 --> 00:53:43,910
really been something that I've been

00:53:40,250 --> 00:53:45,650
proposing yet maybe question mark would

00:53:43,910 --> 00:53:48,320
work better there there are some

00:53:45,650 --> 00:53:49,610
comments that underscore is used in

00:53:48,320 --> 00:53:52,820
other libraries so there would be a

00:53:49,610 --> 00:53:54,980
conflict so we'll figure out something

00:53:52,820 --> 00:53:57,170
that works with existing code and

00:53:54,980 --> 00:53:59,380
doesn't break anything that's the goal

00:53:57,170 --> 00:53:59,380
anyway

00:54:12,270 --> 00:54:18,520
have I considered what an implementation

00:54:16,450 --> 00:54:23,350
of optional would look like with a l

00:54:18,520 --> 00:54:25,180
variant yeah so it would be that it

00:54:23,350 --> 00:54:27,280
would have two fields one would be of

00:54:25,180 --> 00:54:29,610
type stood mono state and the other one

00:54:27,280 --> 00:54:36,970
be of the thing that you want to the

00:54:29,610 --> 00:54:39,810
value of the optional okay I think we're

00:54:36,970 --> 00:54:39,810

YouTube URL: https://www.youtube.com/watch?v=k3O4EKX4z1c


