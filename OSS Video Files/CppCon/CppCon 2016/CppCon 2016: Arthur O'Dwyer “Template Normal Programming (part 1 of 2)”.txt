Title: CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 1 of 2)”
Publication date: 2016-09-29
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
What is "template normal programming"? It's template metaprogramming without so much of the "meta" part! During this talk, I promise not to mention SFINAE, or recursion, or standard type traits. We'll focus on the common scenarios "I think this code could benefit from templates, but I don't understand how to organize it;" "I can't get anything to compile without errors;" and "My coworker wrote some template code and I don't understand any of it." 

In Part I of the talk, we'll start with function templates and class templates, then explain variable templates (new in C++14) and template aliases (new in C++11). We'll do a deep dive into template type deduction; then talk about full and partial specialization; and finish up with an example that motivates the final feature of C++11 template syntax, explicit instantiation.

In Part II of the talk, we'll begin by demystifying tag dispatch and traits classes; discuss situations in which you have to add disambiguating "template" or "typename" keywords (and why); and do a deep dive into the rules of what gets instantiated when and where. We'll revisit template type deduction just long enough to explain how it works for variadic templates; and explain two common template idioms — the Curiously Recurring Template Pattern and the Mixin Pattern.
Time permitting, we'll finish by exploring the big new features of templates according to the C++17 Draft Standard:
- template
- type deduction for class template constructors
- explicit deduction guides
--
Arthur O'Dwyer worked for many years at Green Hills Software, making the world's most optimizing C and C++ compilers. Now he works at Mixpanel in San Francisco, where he organizes a monthly C++ meetup.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,120 --> 00:00:02,220
Welcome, everyone,

00:00:02,220 --> 00:00:06,000
to Part 1 of "Template Normal Programming."

00:00:06,180 --> 00:00:10,420
This is template metaprogramming without the "meta" part.

00:00:10,420 --> 00:00:16,740
I will be your guide for the next 2 hours and 15 minutes — and I say that because we might go into the break. Who knows.

00:00:18,369 --> 00:00:25,199
But yeah, so, what are we actually talking about here? What should you expect to get out of this particular talk?

00:00:25,860 --> 00:00:32,800
So, I looked up the definition of "metaprogramming" and the definition of "programming," respectively...

00:00:33,300 --> 00:00:41,160
Wikipedia says "programming" is "the craft of writing useful, maintainable, extensible source code which can be interpreted or compiled by a computing system to perform a meaningful task."

00:00:42,720 --> 00:00:44,720
I looked up "metaprogramming"...

00:00:45,160 --> 00:00:51,040
that according to the designer of— someone in the audience knows which language this guy designed? I forget—

00:00:51,300 --> 00:00:57,420
"The writing of computer programs that manipulate other programs (or themselves) as if they were data."

00:00:57,480 --> 00:01:04,340
And I got the impression, going to a lot of talks at conferences like this, that were about templates in general...

00:01:04,340 --> 00:01:07,100
they ended up being about template metaprogramming, which is to say,

00:01:07,200 --> 00:01:13,520
programs that spend a lot of time manipulating themselves and not a lot of time performing meaningful tasks.

00:01:13,560 --> 00:01:24,640
So I thought I would try to give the beginner's overview of: What are templates? How do we use them? How can we use them effectively?

00:01:24,640 --> 00:01:32,260
And do it without mentioning SFINAE, and do it without mentioning <type_traits>, but still give you some interesting stuff.

00:01:32,260 --> 00:01:37,640
I hope this will be interesting. This is stuff that was interesting to me writing it, so I hope it'll be interesting to you hearing it.

00:01:37,640 --> 00:01:41,760
So, our motivation. What are templates? Why are they in C++ to begin with?

00:01:41,800 --> 00:01:46,140
Presumably everyone has seen a slide something like this before.

00:01:46,140 --> 00:01:54,040
In C++ — well, in C — we have a function like `abs`. It takes an int and returns an int.

00:01:54,040 --> 00:02:00,100
And in C99 — well, you know, later on — they realized that they also need a version of this for `long`, and they need one for `long long`...

00:02:00,120 --> 00:02:08,300
and by the time you get to C99 you have about a dozen absolute-value functions in the language, and they all have different names! This is fun.

00:02:08,680 --> 00:02:15,640
But, we can spend more time doing meaningful tasks and less time manipulating our programs,

00:02:15,640 --> 00:02:19,220
if we allow function overloading, so...

00:02:19,220 --> 00:02:22,040
C++ from the very beginning allowed function overloading.

00:02:22,040 --> 00:02:27,320
You can have functions that take different types and return different values and maybe even do different things.

00:02:29,460 --> 00:02:36,100
We would like to— well, even writing this is too much code for us, right? We'd like to collapse it into some sort of "template."

00:02:36,100 --> 00:02:41,880
A function template is not a FUNCTION. It is a TEMPLATE. It is a template for making a function.

00:02:42,960 --> 00:02:49,060
It looks something like this, and it gives us a recipe for stamping out copies of the `abs` function with different `T`s.

00:02:49,060 --> 00:02:55,420
You can get `abs(int)` from this. You can get `abs(double)` from this. And so on. And we don't pay for what we don't use, right?

00:02:55,420 --> 00:03:03,880
With the overloaded version we have two functions. We compile, we codegen, two functions. We pay for two functions all the time.

00:03:03,880 --> 00:03:08,220
In this version we can — through the magic of implicit instantiation, which we'll see in a minute —

00:03:08,220 --> 00:03:10,220
— and by a minute I mean two hours —

00:03:10,320 --> 00:03:14,360
— you know, you won't instantiate the code at all.

00:03:15,460 --> 00:03:19,980
Using a function template looks something like this again.

00:03:20,340 --> 00:03:29,480
Down here, where we make the call to it, we have to tell it how to instantiate this template: what is the type `T` that we're instantiating it for.

00:03:29,480 --> 00:03:32,320
And this is the simplest possible way to do that.

00:03:32,320 --> 00:03:42,700
You just say the template name — the name of the function template — `abs` — and you give it a template argument `T` in angle brackets. Makes sense, right?

00:03:42,700 --> 00:03:50,280
It will not be instantiated with any particular type `Foo` until you, the programmer, explicitly mention that you would like it instantiated for "absolute value of `Foo`".

00:03:50,280 --> 00:03:58,400
As soon as you mention that, the compiler has to go instantiate it in order to figure out, you know, what is its return type, what are its argument types, and so on.

00:03:58,400 --> 00:04:03,340
Now, sometimes the compiler can deduce that you mean "absolute value of `Foo`."

00:04:03,340 --> 00:04:09,800
For example, in this case, I can actually deduce both of those... but we'll talk about deduction later. "Hold that thought until slide 21," it says.

00:04:09,800 --> 00:04:14,760
...But then I rearranged all the slides, so I don't know when that slide is coming.

00:04:15,040 --> 00:04:20,200
We have the same concept for generic types. Generic functions, generic types.

00:04:20,200 --> 00:04:28,720
We've also all seen this sort of thing, if you've done any C; you know, you manipulate a lot of `void*`s, and you have no type-safety.

00:04:28,720 --> 00:04:35,180
Type-punning. Error-prone. Ugly.

00:04:35,180 --> 00:04:40,620
Or you could have something like this, where maybe you generate this using some macros of some sort...

00:04:40,620 --> 00:04:44,480
We have `my_list_of_int`, `my_list_of_double`... obviously, we'd like to have a `my_list_of<T>`.

00:04:44,480 --> 00:04:48,000
And you probably make up a `my_list_of(T)` macro if you're programming in C;

00:04:48,000 --> 00:04:55,760
And in C++, we formalize that by making class templates. Again, a class template is not a CLASS. It is a template for MAKING a class.

00:04:55,760 --> 00:04:59,900
Making many classes that follow the same basic outline of stuff.

00:04:59,900 --> 00:05:05,100
And you don't pay for what you don't use. If nobody uses `my_list_of<int>`, it won't be instantiated by the compiler at all.

00:05:05,460 --> 00:05:13,620
Template classes are still classes. Wait — well, I just said the opposite, didn't I? Well, we have some terms of art here.

00:05:13,620 --> 00:05:18,860
Sometimes when people say "template class" they mean "class template." Which is not a class, it's a template.

00:05:18,860 --> 00:05:25,340
However, some people — like, I think, Scott Meyers, and possibly even the standard — when you reverse the words,

00:05:25,340 --> 00:05:33,320
a "template class" is a class generated FROM a template. A "template function" is a function generated FROM a template.

00:05:33,320 --> 00:05:39,140
So if I have a class template, and I use it to generate a particular class, such as in this case...

00:05:39,140 --> 00:05:43,680
Well in this case I don't have a template yet, but I will. So, like, `S<int>`.

00:05:43,680 --> 00:05:47,300
That itself is still a class, and it follows all the general rules for making classes.

00:05:47,300 --> 00:05:51,580
Such as your static data members have to be defined somewhere if you want to use them.

00:05:51,600 --> 00:05:59,840
So here I have a class that is not a template class; it's just a regular class, `struct S`, and it has a static data member, and I try to use it in `main`.

00:05:59,840 --> 00:06:03,900
And it tells me, well, I get an undefined reference in the linker, right?

00:06:03,900 --> 00:06:09,420
How many people have seen a linker error that looks like that, from trying to use static data members?

00:06:09,420 --> 00:06:11,640
All right, yeah.

00:06:11,640 --> 00:06:15,320
And then you do this and it works, and that's awesome;

00:06:15,320 --> 00:06:20,400
and then you do this, and it breaks again. How many people have seen this?

00:06:20,440 --> 00:06:22,740
Yeah, templates suck, right?

00:06:22,740 --> 00:06:25,540
But they follow all the same rules as regular classes. right?

00:06:25,540 --> 00:06:32,440
Just like in this case, where I didn't define `sdm`. Well, if I HAD a definition...

00:06:32,440 --> 00:06:40,040
Now, of course, my definition needs to be templated, right? because I don't know which `sdm` to use, yet.

00:06:40,040 --> 00:06:46,720
But if I make a template for stamping out that definition, then it ends up working just fine.

00:06:47,500 --> 00:07:02,020
Now the interesting thing about this particular example is that I can actually put the definition of that static data member in the header file, for a template.

00:07:02,020 --> 00:07:06,320
I couldn't put that definition in the header file for the regular old `s`, where it wasn't a template.

00:07:06,320 --> 00:07:11,100
But when it's a template, I can just sort of shove everything in a header file, and it basically works.

00:07:11,100 --> 00:07:13,940
That's actually kind of interesting, because you can't do that with normal things.

00:07:13,940 --> 00:07:21,200
But you can do it with inline things, right? — inline functions, and as of C++17 we have inline variables, which Bjarne talked about this morning.

00:07:21,200 --> 00:07:26,700
He hates them, but I love them. Because why can't you just put `inline` on everything? It makes sense.

00:07:26,700 --> 00:07:30,460
Just throw it all in a header file and it all works.

00:07:30,460 --> 00:07:40,900
Well, so the same rules, basically — if you think about how inline functions work — the same rules govern how templates work. Basically. More or less.

00:07:40,900 --> 00:07:45,320
If you can make something work with `inline` you can probably make the exact same thing work with `template`,

00:07:45,380 --> 00:07:54,380
and we'll see that more later when we get into instantiation rules. Which was the slide formerly known as slide 21, I think.

00:07:56,420 --> 00:08:02,720
Right. Cool. Oh, I forgot to mention entirely — let's go all the way back to the beginning, by the way.

00:08:02,720 --> 00:08:09,660
I have three links at the bottom here. The first link is a link to the current draft standard, which is freely available —

00:08:09,660 --> 00:08:13,520
the draft standard for the C++ programming language, N4606.

00:08:13,520 --> 00:08:20,440
And whenever in the lower right-hand corner of these slides you see a little thing in purple, like a section number...

00:08:20,440 --> 00:08:25,080
you can actually go look up in the standard — for those of you in the audience who like looking at the standard —

00:08:25,080 --> 00:08:32,480
Don't go to Netflix [on the conference wifi network], but, you know, do read the standard, I guess. It's not multi-gigabyte yet.

00:08:32,480 --> 00:08:34,680
And the two other links here...

00:08:34,680 --> 00:08:40,760
Wandbox is a free way of compiling code online.

00:08:40,760 --> 00:08:45,360
As long as it fits in a single translation unit, you can use GCC or Clang and find out what their output is for a particular thing.

00:08:45,360 --> 00:08:50,320
You can test that that code works in current, like, top-of-tree Clang and GCC.

00:08:50,320 --> 00:08:56,640
And webcompiler.cloudapp.net is a Microsoft thing that does the same thing for some version of MSVC, I'm not sure which.

00:08:56,640 --> 00:09:01,160
But if you want to test things on MSVC, that's another way you can do that.

00:09:01,160 --> 00:09:05,780
As long as the Internet works, which apparently it doesn't quite at the moment.

00:09:05,780 --> 00:09:07,330
All right.

00:09:07,330 --> 00:09:12,780
So down here, when you see the little reference to N4606 section 3... that's what that's referring to.

00:09:12,780 --> 00:09:19,620
That's where you can go for more information if you want it about the wording that governs inline functions... and also templates.

00:09:21,500 --> 00:09:23,740
So there are two relatively new kinds of templates.

00:09:23,740 --> 00:09:29,020
Now, the kinds we've covered already — function templates and class templates — those have existed basically forever. They were in C++98.

00:09:29,020 --> 00:09:35,620
In C++11, we got alias templates, and in C++14 we got variable templates.

00:09:35,620 --> 00:09:40,480
I'm going to talk about variable templates first because they're a lot like class templates.

00:09:40,480 --> 00:09:48,000
In fact, they're basically syntactic sugar for static data members of class templates.

00:09:48,000 --> 00:09:54,020
So here we have an example of a class template with a static data member named `value`.

00:09:54,020 --> 00:10:01,200
And it's `static`. (And it happens to be `const`... and `bool`... those bits don't matter.) But it's `static`.

00:10:01,200 --> 00:10:05,320
And we can print out its value, and so on...

00:10:05,320 --> 00:10:07,780
(Forget the `some expression` part for now.)

00:10:07,780 --> 00:10:09,940
Here's the variable template version of this.

00:10:09,940 --> 00:10:14,940
It's very similar, except we took out all the class bits, because it turned out we didn't really want them. They were just sort of extraneous.

00:10:14,940 --> 00:10:22,060
We needed them in C++98, to get this functionality, but now we have variable templates; and they just look like this.

00:10:22,060 --> 00:10:24,820
It's still a template — and then it looks like a variable declaration.

00:10:24,820 --> 00:10:32,560
Notice the word `static` is gone because it's no longer a static data member now. It's just a regular old data variable. Global variable.

00:10:32,560 --> 00:10:42,740
And we can initialize it the same way, and we can stick this in a header, and it will magically work, by the same rules that make inline variables work.

00:10:43,980 --> 00:10:49,120
For things in the STL, by the way, we get the best of both worlds;

00:10:49,180 --> 00:10:57,400
in that stuff that's been around for a long time will tend to be implemented as these structs, like `is_void`...

00:10:57,400 --> 00:11:01,320
— this is a type trait, which I'm not going to talk about much —

00:11:01,320 --> 00:11:05,620
But you have `is_void` here, with a `static constexpr bool` data member,

00:11:05,620 --> 00:11:17,320
and then outside of the class we have this free-floating global variable called `is_void_v` that's just defined as the `value` of the class.

00:11:17,320 --> 00:11:21,640
So when you see all these `_v`s and `_t`s they tend to be aliases for things that already exist.

00:11:21,640 --> 00:11:25,980
This is a nice pattern to follow in your own code, if you're writing things like type-traits —

00:11:26,020 --> 00:11:30,240
which I'm not going to cover much because I'm not going to talk about metaprogramming!

00:11:30,240 --> 00:11:31,640
Question.

00:11:32,040 --> 00:11:34,040
Previous slide...

00:11:42,100 --> 00:11:48,180
"Why would I write something like this, given that the fact that it's a template is not really being used?"

00:11:48,180 --> 00:11:53,880
Well, that depends on what "some expression" is. "Some expression" could be something that depends on `T`.

00:11:53,880 --> 00:12:00,100
In fact in this case it SHOULD be something that depends on `T`, because if `T` is `void` we want it to come out to `true`, and if `T` isn't `void` we want it to come out to `false`.

00:12:00,100 --> 00:12:04,880
But that's metaprogramming. I'll show that later.

00:12:06,980 --> 00:12:13,360
Any other questions, by the way? We've gone through a bunch of slides already. Cool.

00:12:16,200 --> 00:12:19,040
So let's talk about alias templates.

00:12:19,040 --> 00:12:29,180
This is a different kind of beast, for reasons that we'll see. But you can think about the basic idea the same way.

00:12:29,200 --> 00:12:33,080
In C++03, and of course in C, we have typedefs.

00:12:33,080 --> 00:12:40,140
And right around C++11 they decided that the name for these things was not really "typedefs"; they were really "aliases." Let's call them "aliases."

00:12:40,140 --> 00:12:45,520
But it means the same thing. It's one type being an alias, a synonym, for another type.

00:12:45,520 --> 00:12:50,820
And so you can take — as in this example — I have the old typedef syntax to make `myvec_int`.

00:12:50,820 --> 00:12:56,560
I then make a very similar thing called `myvec_double` using the C++11 alias syntax.

00:12:56,560 --> 00:13:02,880
It doesn't actually use the word `alias`; it uses the word `using`. So maybe they should have called them "usings."

00:13:02,880 --> 00:13:11,500
And then also in C++11 we got the ability to take this new syntax — not the old `typedef` syntax! forget that the old `typedef` syntax ever existed! —

00:13:11,500 --> 00:13:19,000
But we can take the NEW syntax for making aliases, and we can make TEMPLATES for stamping out aliases.

00:13:19,000 --> 00:13:22,100
This is an alias template.

00:13:22,100 --> 00:13:29,800
And so by itself it does nothing. But when I instantiate it, as with the the last line here, and I say `myvec<float>`...

00:13:29,800 --> 00:13:33,500
It'll go and it'll say, "okay, well, how do I make a `myvec<float>`?"

00:13:33,500 --> 00:13:39,760
"I would use the alias template and instantiate it for `float`. And it becomes... oh, it's a `std::vector<float>`. I get it."

00:13:39,760 --> 00:13:45,420
And in fact those become the exact same type.

00:13:45,420 --> 00:13:52,740
They are literally — I kind of already made this point, but just to hammer this in — they're literally the same type.

00:13:52,740 --> 00:13:59,660
So if I have this function `f` that takes a `myint`, which happens to be an alias for `int`, I can pass an `int` to it.

00:13:59,660 --> 00:14:05,140
All right, I have an `int`; I pass it to a function expecting `myint`; and it Just Works, because they're the same type.

00:14:05,140 --> 00:14:11,280
Likewise, I can have a `std::vector<int>` and I can pass it to a function expecting a reference to `myvec<int>`.

00:14:11,280 --> 00:14:14,460
And it will Just Work. Because they're exactly the same type.

00:14:14,460 --> 00:14:22,340
You know, one is not derived from the other; it doesn't have a member... a member typedef that comes out the same as... no.

00:14:22,340 --> 00:14:29,780
They're literally just exactly the same type, as if you had used a regular alias to make them synonyms.

00:14:29,780 --> 00:14:33,480
All right, so now we've actually covered— We've hit a milestone here. This is meaningful.

00:14:33,480 --> 00:14:40,300
We now know all the different kinds of templates in C++11 — er, in C++14, rather —

00:14:40,300 --> 00:14:45,880
And they're exactly the same as they are in C++17. We didn't get any new kinds in C++17.

00:14:45,880 --> 00:14:52,000
So now you're completely up to date with C++17.

00:14:52,000 --> 00:14:57,340
So let's talk about type deduction. Hey, look at that. It's still slide 21. Awesome.

00:14:57,340 --> 00:15:07,280
So, type deduction. So we're back in this state where we're trying to use `abs`, which is a function template...

00:15:07,280 --> 00:15:17,340
and we're trying to instantiate it for a particular type `T`, and we just we just want to use it without all of this extra angle-bracket syntax.

00:15:17,340 --> 00:15:20,520
So here's how it works. (Did I skip anything? No? Good.)

00:15:20,560 --> 00:15:29,060
This is how you might experiment and find out for yourself what type `T` is deduced for various kinds of call expressions.

00:15:29,120 --> 00:15:34,960
I should explain, let's see... At the very top here where it says `puts(__PRETTY_FUNCTION__)`...

00:15:34,960 --> 00:15:39,020
How many people in the room have seen `__PRETTY_FUNCTION__`?

00:15:39,020 --> 00:15:43,600
How many people in the room haven't seen `__PRETTY_FUNCTION__`?

00:15:43,600 --> 00:15:50,900
Nice. It's like 40-60... maybe 50-50. So what is `__PRETTY_FUNCTION__`?...

00:15:50,900 --> 00:15:56,500
How many people have seen `__FUNCTION__`?

00:15:56,500 --> 00:16:08,040
Okay, so all of these are magic macros, basically. They're expanded by the preprocessor. ...Sort of.

00:16:08,040 --> 00:16:19,160
For example, `__FUNCTION__` expands to the name of the function. So if I'm in a function called `main`, then `__FUNCTION__` expands to the string "main", and I can use that just like it were a string literal.

00:16:19,160 --> 00:16:26,780
It's just like `__FILE__`, `__LINE__`. Right? They just expand to these constants that I can use as if they were macro-substituted in.

00:16:26,780 --> 00:16:29,840
So `__FUNCTION__` expands to the name of the function.

00:16:29,840 --> 00:16:33,586
`__PRETTY_FUNCTION__`, in GCC and Clang, expands to a pretty-printed name of the function

00:16:33,586 --> 00:16:45,660
that just happens to include "is it a template?" and "what are its template parameters?" and "what were they deduced as?"

00:16:45,660 --> 00:16:54,920
So when I `puts(__PRETTY_FUNCTION__)`, I actually get something out... you see those comments there? That is literally what this code prints.

00:16:54,920 --> 00:17:03,000
I run this code and it will actually print "void foo(T) [T=int]". And a newline.

00:17:03,000 --> 00:17:12,980
So this is super useful, if you're ever trying to get into the the nitty-gritty of type deduction, or which of my templates is getting called, or why is `T` deducing as something I didn't expect it to.

00:17:12,980 --> 00:17:15,080
Using `__PRETTY_FUNCTION__` is definitely the way to do that.

00:17:15,080 --> 00:17:22,800
MSVC has something — the closest thing they have to it is something called `__FUNCSIG__` — with double underscores on both sides again —

00:17:22,800 --> 00:17:28,860
It's not quite as pretty as `__PRETTY_FUNCTION__`; but then, it doesn't claim to be.

00:17:28,860 --> 00:17:35,580
Okay, so in this case we're just passing in a bunch of these values and, as we expect, `foo(4)` comes out to call `foo(int)`,

00:17:35,580 --> 00:17:37,820
and `foo(4.2)` calls `foo(double)`,

00:17:37,820 --> 00:17:42,700
`foo("hello")` calls `foo(const char *)`.

00:17:42,720 --> 00:17:49,780
Which is actually a little bit weird, if you recall that string literals actually have array-of-char type.

00:17:49,780 --> 00:17:56,100
But that's just because we're taking it by value, and so it happens to decay to a pointer, and there's rules for that.

00:17:56,100 --> 00:17:59,280
But mostly I'm going to ignore the whole array case because that's a little scary.

00:17:59,280 --> 00:18:05,460
But let's talk about type deduction. Let's go deep. Here's the deal with type deduction.

00:18:05,460 --> 00:18:17,880
This was a particularly trivial case because we had one template parameter, named `T`, and a single function parameter called `x` that just happened to have type `T`. So this is the most trivial case you can get.

00:18:17,880 --> 00:18:22,980
But in general, when I have multiple template parameters, or multiple function parameters, here's what happens.

00:18:22,980 --> 00:18:32,080
First of all, each function parameter by itself — each function parameter — can contribute to the deduction of each of the template parameters.

00:18:32,080 --> 00:18:35,020
Or it might not. It might not have anything to say about that template parameter.

00:18:35,020 --> 00:18:41,200
In our case `x` is of type `T`, so it definitely contributes to the deduction of type `T`.

00:18:41,200 --> 00:18:49,620
And then if I add a second parameter, `y`, it would contribute to the deduction of whatever template parameters it was in.

00:18:49,620 --> 00:18:55,460
All of these deductions — the deductions for `x`, deductions for `y`, deductions for `z`, et cetera — are carried out in parallel.

00:18:55,460 --> 00:18:58,580
They don't really cross-talk with each other.

00:18:58,580 --> 00:19:04,460
So we deduce: "what does `x` tell us? what does `y` tell us? what does `z` tell us?" And then we compare notes.

00:19:04,460 --> 00:19:12,180
And we say, "Well, `x` told us that `T` was `int`... `y` told us that `U` was `double`... Okay, so I guess `T` is `int` and `U` is `double`."

00:19:12,180 --> 00:19:17,120
And we need to make sure that we deduce all the template parameters we can, and that all the deductions agree with each other.

00:19:17,120 --> 00:19:26,320
If `x` is saying that `T` is `int` and `y` is saying that `T` is `double`... well, they can't both be right. There's a disagreement there. And we get a compiler error.

00:19:26,320 --> 00:19:29,940
It says, "deduced conflicting types for parameter `T`."

00:19:29,940 --> 00:19:32,100
And then there's one last rule, which is going to trip us up later.

00:19:32,100 --> 00:19:43,580
Which is that any function parameter that DOES contribute to deduction has to match the function argument type — the "argument" being the thing you actually called it with — has to match the type of that argument exactly.

00:19:43,580 --> 00:19:48,960
With no implicit conversions, no integer promotions, nothing like that.

00:19:49,000 --> 00:20:01,780
And the reason is basically to keep things from getting out of hand. If you also allowed implicit conversions there, that would just be an extra level of, like, maybe accidentally calling the wrong template.

00:20:01,780 --> 00:20:07,520
So at the very end, we lock that down and say the argument types need to match exactly.

00:20:07,520 --> 00:20:11,440
So let's look at an example. Let's look at three examples.

00:20:11,440 --> 00:20:15,000
Here we have a function `f`. This is the second most trivial case.

00:20:15,000 --> 00:20:21,240
It has two template parameters and two function parameters `x` and `y` that each contribute to exactly one of the template parameters.

00:20:21,240 --> 00:20:29,000
And if I call `f(1,2)` — well, `1` is an `int`; so `x` is an `int`; so `T` must be `int`.

00:20:29,080 --> 00:20:36,860
And completely separately from that, `y` is `2` is an `int`; `y` is of type `U`; therefore `U` must be `int`.

00:20:36,860 --> 00:20:45,320
And so we deduce that `T` is `int` and `U` is `int`, and we compare notes and find out there are no conflicts, and we have deduced `T` and `U`, and we're all set. Okay.

00:20:45,320 --> 00:20:47,080
Now with `g`...

00:20:47,080 --> 00:20:51,980
`g` has two function parameters, but only one template parameter `T`.

00:20:51,980 --> 00:21:01,440
Fortunately, `x` says, well, `T` is `int`. `y` says, `T` is `int`. They compare notes. They agree.

00:21:01,440 --> 00:21:08,420
"Yes. `T` is `int`. We are in agreement." And it works.

00:21:08,420 --> 00:21:15,000
Now, in the second `g` case, `x` says `T` is `int`. (Right? Type of `1`.)

00:21:15,000 --> 00:21:20,460
`y` says, "Well, I got an unsigned value. `T` is `unsigned int`."

00:21:20,460 --> 00:21:26,500
And they do this separately. And then they compare notes, and they say, "`T` is `int` and `unsigned int`."

00:21:26,500 --> 00:21:30,760
"Nope. Nope. Nope. That's not a thing. We disagree."

00:21:30,760 --> 00:21:35,260
And so you get an error: "No matching function for call to `g(int, unsigned int)`."

00:21:35,260 --> 00:21:40,580
The wording of the error message may vary a little bit; that doesn't really matter. The important thing is that that's why it happened.

00:21:40,580 --> 00:21:49,860
The function parameters deduced that `T` was different things — and that's the end as far as template type deduction is concerned.

00:21:49,860 --> 00:21:54,630
You might say, well, why doesn't it just, like, promote them both to `unsigned int`? Like, that normally happens...

00:21:54,630 --> 00:21:59,680
But nope. Doesn't happen in this case. Very simple rules for template type deduction.

00:21:59,680 --> 00:22:05,980
And we should be thankful for that, because if they were complicated... who would ever understand them?

00:22:06,160 --> 00:22:09,660
Certainly not this entire room, in two hours! (Can you believe it?)

00:22:10,420 --> 00:22:12,140
Question. Yes.

00:22:12,200 --> 00:22:21,760
[INAUDIBLE FROM AUDIENCE]

00:22:21,760 --> 00:22:26,880
That is correct. How many people have seen this?

00:22:28,400 --> 00:22:40,800
Using `std::max`? Yeah. So here we have a function `f` that happens to return a `short`, or it could return `unsigned int`, or whatever.

00:22:40,800 --> 00:22:45,100
And we just want to `max` that with 42, right?

00:22:45,100 --> 00:22:52,220
I mean I didn't even need to make up `int x` in this case; I could have just said `std::max(f,0)`, right?

00:22:52,220 --> 00:22:56,440
And again I get "error: no matching function for blah blah blah."

00:22:56,440 --> 00:23:05,920
And the reason is the same thing. `std::max` only has one template parameter: `T`. And it takes two arguments: `T x` and `T y`.

00:23:05,920 --> 00:23:18,180
And in this case the first, `x`, says "`T` is `short`," and the other one says "`T` is `int`," and they disagree, and you get a hard compiler error.

00:23:18,180 --> 00:23:21,420
This is one of the downsides of this rule.

00:23:21,420 --> 00:23:28,800
There's a slide that follows that, but first let's go back to do these puzzles in order.

00:23:28,800 --> 00:23:38,680
Which of these two calls to `foo()` ought to compile, and which not?

00:23:38,680 --> 00:23:41,780
I'll let everyone sort of digest this for a little while.

00:23:41,780 --> 00:23:45,460
But then I'm going to answer it anyway, because the answer is half on the screen.

00:23:45,460 --> 00:23:56,040
So the first one takes the three function parameters — there's `x`, `y`, and `z`, okay?

00:23:56,040 --> 00:24:03,220
And we're calling it with a `std::array<int,8>`, a `std::array<double,4>, and `0.0`.

00:24:03,240 --> 00:24:11,320
`0.0` is actually part of the puzzle here, right? Because that's a `double` and `z` is an `int`.

00:24:11,400 --> 00:24:19,360
But `z` doesn't depend on any of the template parameters `T` and `U`. It does not contribute to deduction in any way.

00:24:19,360 --> 00:24:24,840
Because there's nothing we could possibly put in for `z` that would tell us anything about `T` or `U`. It's always supposed to be an `int`.

00:24:24,840 --> 00:24:29,020
So `z` does not participate in type deduction.

00:24:29,020 --> 00:24:34,420
`x`, on the other hand, does. What can `x` tell us about `T` and `U`?

00:24:34,420 --> 00:24:37,440
Well, it can tell us exactly what `T` is.

00:24:37,440 --> 00:24:45,520
Right? Because if I pass a `std::array` of, in this case, `int` comma something... well, `T` HAS to be `int`. There's no way it can be anything but `int`.

00:24:45,520 --> 00:24:48,300
So `x` contributes to the deduction of `T`.

00:24:48,300 --> 00:24:55,000
Does it contribute to the deduction of `U`? It tells us the size of `U`. Does that count?

00:24:55,000 --> 00:24:56,520
Turns out not really.

00:24:56,520 --> 00:25:07,320
Because that's not something that the compiler can really figure out. I mean, even if it did TRY to figure it out, and said, "Okay, well, I see that `sizeof(U)` must be 8..."

00:25:07,320 --> 00:25:17,000
Like, how's it going to record that? Where in its table of information about `U` is it going to say — "well, I don't know what it is, but I know its size. Maybe that'll help"?

00:25:17,000 --> 00:25:26,400
But that won't help. So it just forgets that. `x` does NOT contribute to deduction about `U`, because it it doesn't tell us anything DIRECTLY relevant.

00:25:26,400 --> 00:25:31,980
Now, `T`, it tells us exactly what `T` has to be. `U`, it doesn't tell us anything but the size, so we don't care.

00:25:31,980 --> 00:25:39,280
So from the first parameter, in the first example, with `std::array<int, 8>`, `x` tells us that `T` is `int`.

00:25:39,280 --> 00:25:43,560
`y`, for the exact same reason, tells us that `U` is `double`.

00:25:43,560 --> 00:25:44,900
And `z` doesn't matter.

00:25:44,900 --> 00:25:46,580
We compare notes.

00:25:46,580 --> 00:25:51,920
None of our notes disagree, and we know what `T` is; it's `int`; and we know what `U` is; it's `double`;

00:25:51,920 --> 00:25:57,260
So now we do that last step, and we check and we say, okay, well,

00:25:57,260 --> 00:26:05,820
So that means `x` has to be of type `std::array<int, sizeof(double)>`... sizeof(double) is 8... I'm getting a `std::array<int, 8>`... yep, that all checks out!

00:26:05,820 --> 00:26:08,820
And it does the same thing for `y`, and yeah, that all checks out.

00:26:08,820 --> 00:26:16,800
And then `z` gets an `int`. But it didn't participate in type deduction, so... it got a `double`? That's fine. We'll just convert it to `int`. That's fine.

00:26:16,800 --> 00:26:18,560
And so the first line compiles.

00:26:18,560 --> 00:26:23,000
On the second line, we go through all the same type deduction — we figure out that `T` is `int` and `U` is `double` —

00:26:23,000 --> 00:26:29,100
and then we look at that first argument, `x`, which DID contribute to the deduction,

00:26:29,100 --> 00:26:36,720
and it's a `std::array<int, 9>`. That's not `std::array<int, 8>`. That's a different type. They needed to match exactly.

00:26:36,720 --> 00:26:43,960
Doesn't even matter if there IS an implicit conversion there. They needed to match exactly, and they don't. So that's a hard error.

00:26:43,960 --> 00:26:48,540
Is everyone following that?... All right.

00:26:50,060 --> 00:26:54,620
Here's a similar thing — and this is again inspired by real stories.

00:26:54,620 --> 00:26:58,620
Let's say I have a function `foo`, and it takes a function pointer of some sort.

00:26:58,620 --> 00:27:04,000
And the function pointer, you know, takes one argument of type `A` and returns something of type `R`.

00:27:04,000 --> 00:27:07,200
And luckily I can deduce those when I pass in a function pointer. All right?

00:27:07,200 --> 00:27:14,840
I can say, well, if this is `double (*fptr)(int)`, well, then I guess `R` must be `double` and `A` must be `int`.

00:27:14,840 --> 00:27:18,440
And so deduction will work for `R` and `A`.

00:27:18,440 --> 00:27:20,620
The problem is if I pass it a lambda.

00:27:20,620 --> 00:27:24,620
A lambda — a captureless lambda — is always implicitly convertible to a function pointer type.

00:27:24,620 --> 00:27:29,960
By the way if you didn't know that, now you know that. Lambdas are awesome.

00:27:29,960 --> 00:27:35,500
But being implicitly convertible to a function pointer type doesn't help you call `foo` with it.

00:27:35,500 --> 00:27:45,300
Because again the type needs to match exactly, and the captureless lambda type itself, while being implicitly convertible TO a function pointer type, is not ITSELF a function pointer type.

00:27:45,300 --> 00:27:49,320
And so you'll run afoul of that very last step.

00:27:49,320 --> 00:27:58,380
Protip here is if you absolutely need a function pointer out of a lambda, just stick a unary `+` on the front.

00:27:58,380 --> 00:28:04,760
There is no unary `+` for lambda types, but there is a unary `+` for pointer types — function pointer types —

00:28:04,760 --> 00:28:11,480
and so it will do the implicit conversion before it applies unary `+`, and the thing you get out of the unary `+` is in fact the function pointer itself.

00:28:11,480 --> 00:28:16,720
Unless you're on MSVC, and then you get a confusing error message.

00:28:16,720 --> 00:28:23,040
Because they have four different calling conventions; they don't know which one you mean.

00:28:23,040 --> 00:28:27,380
All right, so now we get back to the slide with `std::max`. How many people have seen this?

00:28:27,380 --> 00:28:29,660
Everyone's hand should be up! We just did this!

00:28:29,660 --> 00:28:31,640
[LAUGHTER]

00:28:32,520 --> 00:28:40,580
All right. So there are two ways to solve this problem; the problem being that this `std::max` call does not compile.

00:28:40,580 --> 00:28:43,960
One of the ways to solve it is,

00:28:43,960 --> 00:28:47,240
So, "every parameter that contributes to deduction must match its argument type exactly..."

00:28:47,240 --> 00:28:53,900
so our two ways of solving that are either to make the argument types match exactly... or, make the parameter stop contributing to deduction.

00:28:53,900 --> 00:29:03,000
So the first way — make the arguments match exactly — looks like approach #1 there, where you just take and `static_cast` it to `int`, right?

00:29:03,000 --> 00:29:08,040
How many people have done something like approach #1 at some point in their code?

00:29:08,040 --> 00:29:10,680
All right.

00:29:10,680 --> 00:29:16,940
I advise doing approach #2 instead, just because I feel it's more readable.

00:29:16,940 --> 00:29:22,660
So, return `std::max<int>(...)`.

00:29:22,660 --> 00:29:28,480
In approach #2, the thing we're trying to do there is to make the parameter stop contributing to deduction.

00:29:28,480 --> 00:29:31,060
All right, so let's go back to "type deduction in a nutshell."

00:29:31,060 --> 00:29:34,440
How to call a specialization explicitly.

00:29:34,440 --> 00:29:39,920
Basically, I'm just putting the type of `T` right there in angle brackets. How do I do that?

00:29:39,920 --> 00:29:46,040
Oops, I thought I was going to have another slide about type deduction in a nutshell here.

00:29:46,040 --> 00:29:52,080
Well, the stuff in angle brackets — after I name the template and I tell you which template I'm using; in this case, `add` —

00:29:52,080 --> 00:29:57,360
I can start giving you the template parameters explicitly.

00:29:57,360 --> 00:30:02,820
I can say — going through the template parameter argument list, starting with `T` in this example,

00:30:02,820 --> 00:30:08,860
I can say, "`T` is `int`. `U` is `int`." And now I have given you, exactly, the template parameters.

00:30:08,860 --> 00:30:14,220
Template parameters go in the angle brackets. Function parameters go in the round brackets.

00:30:14,220 --> 00:30:21,140
I've given you exactly what `T` and `U` are, and that means that `x` and `y` no longer really have anything to say here.

00:30:21,140 --> 00:30:25,560
`x` would have told us about `T`. But we already know what `T` is. We told you, it's `int`.

00:30:25,560 --> 00:30:29,260
`y` would have told us what `U` is, but we already told you, it's `int`.

00:30:29,260 --> 00:30:32,700
Therefore, `x` and `y` no longer participate in type deduction.

00:30:32,700 --> 00:30:42,060
Therefore, they don't need to match exactly anymore, and I will actually call `add<int, int>` with the char value `'x'` — normally that would be a `char`, and it wouldn't work —

00:30:42,120 --> 00:30:46,060
but now that I've told you to just make it an `int`, it no longer participates in type deduction.

00:30:46,060 --> 00:30:49,600
And so the implicit conversion kicks in, and it converts it right to `int`.

00:30:49,600 --> 00:30:59,000
And similarly the `3.1` is a `double`, but it gets converted to `int` because I told you that's an `int` — it doesn't participate in type deduction anymore.

00:30:59,000 --> 00:31:07,080
Now all of these template parameters — `T` and `U` and so on — I can specify them but I don't have to.

00:31:07,080 --> 00:31:14,040
I can specify only a prefix of the whole list. So I can say, `add` of just `<int>`, and that tells you, well, `T` is `int`.

00:31:14,040 --> 00:31:16,420
But I didn't say anything about `U`.

00:31:16,420 --> 00:31:22,100
So now `x` no longer participates in deduction, but `y` does. And it tells us what `U` is.

00:31:22,100 --> 00:31:24,760
In this case, it says `U` is `double`, and we say "okay."

00:31:24,760 --> 00:31:30,180
I can even put nothing in the angle brackets; and that means, "I'm not telling you about `T` or `U`."

00:31:30,180 --> 00:31:36,340
Or in the case of function templates, I can actually omit the angle brackets altogether, and that's what you see most commonly in practice.

00:31:36,340 --> 00:31:45,380
So type deduction in a nutshell: Any template parameters that were explicitly specified by the caller are fixed — they don't participate any further in deduction — and then all the stuff we saw before.

00:31:45,380 --> 00:31:48,240
Let's talk about this little red underlined bit.

00:31:48,240 --> 00:31:54,000
Remember, when we compare notes, we need to make sure that each template parameter has been deduced at least once.

00:31:54,000 --> 00:31:55,440
So if we have a case like this...

00:31:55,440 --> 00:31:59,340
Here this takes no arguments at all, so `T` cannot be deduced.

00:31:59,340 --> 00:32:06,040
Fortunately I can tell it explicitly that `T` is `int` in the angle brackets. And then it's perfectly happy, and it works, because it knows what `T` is.

00:32:06,040 --> 00:32:12,260
If I don't put anything in the angle brackets — or if I remove the angle brackets altogether, which is what you usually see in practice —

00:32:12,260 --> 00:32:20,480
then it doesn't know what `T` is. It can't deduce it. It says "couldn't infer template argument `T`," and that's a hard error again. What do we do about this?

00:32:20,480 --> 00:32:23,800
Well, we can default the template parameter.

00:32:23,800 --> 00:32:25,400
Question.

00:32:26,000 --> 00:32:34,380
[INAUDIBLE FROM AUDIENCE]

00:32:34,380 --> 00:32:40,940
Is there a way to specify only the second template argument `U`? No, there is not.

00:32:41,060 --> 00:32:46,600
[INAUDIBLE]

00:32:46,600 --> 00:32:53,440
Is it written in the Standard that deduction will happen from left to right in the order I described? Yes.

00:32:53,440 --> 00:33:00,560
And left-to-right order is also kind of magic when you think about, like, can I write function parameters that have default values...

00:33:00,560 --> 00:33:07,280
Like, once you start writing the default values you have to keep going. You can't say there's a default for the second parameter and not the third.

00:33:07,280 --> 00:33:12,420
So we like left-to-right. It's a left-to-right language.

00:33:12,420 --> 00:33:21,940
Okay, so in these cases, we can't infer it. We add the `= char *`, suddenly we can infer it. So even if it's not provided it works fine.

00:33:21,940 --> 00:33:30,020
So let's add that to our "template deduction in a nutshell" here... If any template parameter that wasn't specified by the caller couldn't be deduced, BUT it has a default value,

00:33:30,020 --> 00:33:33,300
that's still okay. We'll fix it as its default value.

00:33:33,300 --> 00:33:38,260
And then we compare notes. And then we look to make sure that things match the function argument types.

00:33:38,260 --> 00:33:43,880
Cool. Now you actually know everything there is to know about template type deduction!

00:33:43,880 --> 00:33:46,240
Like, "Wow, that's all the rules. That's cool."

00:33:46,240 --> 00:33:51,200
Oh, yeah, okay, fine. If there's no ampersands we're okay.

00:33:51,200 --> 00:33:59,680
All right, so let's talk about ampersands! Remember this? This is the trivial case. We have just the plain old `T`; we pass it an `int`; it comes out as `int`; no surprises.

00:33:59,680 --> 00:34:01,360
Let's talk about this. Now we have a `T*`.

00:34:01,360 --> 00:34:09,020
Now, I kind of alluded to this earlier when I did the `std::array` example, and you saw how I can pull a `T` right out of the middle of an expression and deduce that.

00:34:09,020 --> 00:34:15,280
Out of the `std::array<int>` I can deduce what `T` is. Because I said `std::array<T>`; that matches `std::array<int>`... so `T` must be `int`.

00:34:15,280 --> 00:34:22,660
In the same way, if I'm expecting a `T*` and I get an `int*`, I can deduce that `T` must be `int`.

00:34:22,660 --> 00:34:24,780
All right.

00:34:24,780 --> 00:34:29,160
I'm going to assume some knowledge here of lvalues and rvalues.

00:34:29,160 --> 00:34:33,100
Because it's been five years, people.

00:34:34,280 --> 00:34:40,460
So here, this is an lvalue reference. Single ampersand. And I'm taking an lvalue reference to a `T`.

00:34:40,460 --> 00:34:46,860
And the thing I'm passing to it is a named variable, named `i`, which happens to be of type `int`.

00:34:46,860 --> 00:34:52,500
And that means that the expression `i` is an lvalue. Does that make sense to people, mostly?

00:34:52,500 --> 00:35:00,940
In brief, lvalues are objects that would be missed by someone. Such as `i`, because it's got a name — and probably family and friends who would miss it.

00:35:01,020 --> 00:35:09,700
Rvalues are expendable objects. They are survived by nobody. Nobody will mourn them.

00:35:09,700 --> 00:35:13,500
And so it's okay to stomp on the rvalues.

00:35:13,500 --> 00:35:21,940
But here, `i` is not an rvalue. There's no rvalues in this at all. We have that `i` is an lvalue; we're expecting an lvalue; and so we can deduce...

00:35:21,940 --> 00:35:29,180
that, okay, I'm expecting this reference to a thing; and I'm getting a reference to a thing that's an `int`, so okay. It's an `int`.

00:35:29,180 --> 00:35:34,940
Just like the pointer example, kind of. Makes sense, right?

00:35:34,940 --> 00:35:44,140
All right, let's do rvalue reference. Here I have an `f` that's expecting `T&&`; that is to say, an rvalue reference to a `T`.

00:35:44,140 --> 00:35:47,800
Some of you are preparing to raise your hands, but, don't.

00:35:47,800 --> 00:35:51,920
An rvalue reference to a `T`. And so I pass it an rvalue, like `42`.

00:35:51,920 --> 00:35:56,940
That's an rvalue of type `int`, and so `T` is `int`. Works fine.

00:35:56,940 --> 00:36:10,500
I pass it `std::move(i)` — `std::move` being the magic thing that turns things into rvalues. And it works fine. It deduces `int`.

00:36:10,500 --> 00:36:16,020
Now let's try passing it just `i`, without the `std::move`. We pass it an lvalue reference to an `int`. What happens?

00:36:16,020 --> 00:36:23,540
It still works! But it deduces that `T` must be `int&`. An lvalue reference.

00:36:23,540 --> 00:36:28,980
This is interesting. Something interesting is going on here. What's going on here is something called "reference collapsing."

00:36:28,980 --> 00:36:33,740
Scott Meyers calls this a — well he calls it a "universal reference," but, "forwarding reference."

00:36:33,740 --> 00:36:38,360
But you can also just think of it as an rvalue reference to a `T`, and as long as you know about reference collapsing, you'll be all right.

00:36:38,360 --> 00:36:48,240
The rule to remember when dealing with references is that when you combine two reference types — when I take a reference to a reference — it basically "mins" the number of ampersands between them.

00:36:48,240 --> 00:36:54,660
So if they both have one ampersand — they're both lvalue references — an lvalue reference TO an lvalue reference is an lvalue reference.

00:36:54,660 --> 00:36:58,180
An lvalue reference to an rvalue reference is an lvalue reference.

00:36:58,180 --> 00:37:01,980
An rvalue reference to an lvalue reference is still an lvalue reference.

00:37:01,980 --> 00:37:06,380
If anyone would miss it at all, then someone will miss it.

00:37:06,380 --> 00:37:10,040
If ANYONE'S got an lvalue reference to the thing, it's an lvalue reference.

00:37:10,040 --> 00:37:16,600
But if everything involved is rvalue references, then it's okay; we've still got an rvalue reference.

00:37:16,600 --> 00:37:24,260
So what's going on here? Well, we have `f(i)`. `i` is an lvalue `int`, which is kind of like an `int&`. Let's say it's an `int&`.

00:37:24,260 --> 00:37:35,420
So we need to deduce `T` — up there, we have `T&&` — we need to deduce `T` such that "rvalue reference to `T`" is "lvalue reference to `int`."

00:37:35,420 --> 00:37:43,660
So obviously `T` can't be just plain old `int`, because then `T&&` would be `int&&`, which is not `int&`.

00:37:43,660 --> 00:38:00,560
It can't be `int&&` either — that wouldn't work. But if we make it `int&` — an lvalue reference — then an "int-ref, ref-ref" is still an `int&`; we gave it an `int&`; and it all works!

00:38:00,560 --> 00:38:02,820
Does that make sense?

00:38:02,820 --> 00:38:03,960
(ref ref ref ref ref ref ref)

00:38:05,960 --> 00:38:11,560
All right, so if we give it an rvalue reference — here we have an rvalue reference to an `int` —

00:38:11,560 --> 00:38:16,740
we're passing it to a function that expects an rvalue reference to a `T` — I think we already saw this — of course it deduces `T=int`.

00:38:16,740 --> 00:38:24,080
Now you might say, "why doesn't it deduce `int&&`?" Because that just as well WOULD work. And the answer is, "That's too many letters."

00:38:24,080 --> 00:38:30,700
Too many characters. Like, why bother sticking the ampersands on there if you don't need them? So it will prefer to deduce `int`.

00:38:30,700 --> 00:38:34,180
Does this mean that `int&&` is NEVER deduced? No...

00:38:34,180 --> 00:38:39,780
Like, here's a case where obviously `T` has to be `int&&` or it wouldn't work.

00:38:39,780 --> 00:38:47,060
But basically if you've got any ampersands at all involved, then yeah, you're never going to see it deduce an rvalue reference.

00:38:47,060 --> 00:38:50,040
Questions about this one?

00:38:50,900 --> 00:38:52,820
What's that?

00:38:53,260 --> 00:38:58,640
[INAUDIBLE]

00:38:58,640 --> 00:39:04,140
If I pass in a temporary to the function — that it just expected a `T`?

00:39:04,140 --> 00:39:05,160
You expected a `T&&`?

00:39:05,160 --> 00:39:16,800
No, that's exactly this case, isn't it? Where I'm passing in... basically a temporary — I mean it could be `2+2` just as well — and the thing that `T` deduces as, is just `int`.

00:39:16,800 --> 00:39:21,380
The function parameter type is `int&&`, but... all right.

00:39:21,380 --> 00:39:26,320
So reference collapsing is a very important thing to know when you're dealing with templates in C++11 and later.

00:39:26,320 --> 00:39:31,400
It is less important, but it was still present, even back in C++03 with lvalue references.

00:39:31,400 --> 00:39:39,580
Suppose I have a function `f` that takes `R` of some type; and then it tries to construct an `R&`.

00:39:39,580 --> 00:39:49,220
And I instantiate it with R equal to `int&`, as I'm doing down here, right?

00:39:49,220 --> 00:39:51,820
So, a ref to a ref collapses to a ref.

00:39:51,820 --> 00:39:58,580
This was not standardized — this was a extension, pretty much — but every compiler vendor had to deal with this if they were going to do templates.

00:39:58,580 --> 00:40:03,780
So everyone pretty much kind of knew that, yeah, this is how it should work.

00:40:03,780 --> 00:40:10,060
But it was not standardized until C++11. And by C++11 we had to deal with this exact same issue with rvalues.

00:40:10,060 --> 00:40:12,940
Question?

00:40:12,940 --> 00:40:46,160
[INAUDIBLE FROM AUDIENCE]

00:40:46,160 --> 00:41:00,140
Once you're inside a template that takes an rvalue reference or an lvalue reference, are you then using— ah, that parameter, when you use it to call some other function, does that come out as an lvalue?

00:41:00,140 --> 00:41:06,100
And the answer is yes, always, for ANY template parameter; because template parameters have to be named.

00:41:06,100 --> 00:41:09,680
You have to name your template parameters. Well, you can leave it blank, but then you can't use it.

00:41:09,680 --> 00:41:20,560
So if you're using it, it must have a name, and if it has a name, someone would miss it if it disappeared. So anything with a name is always an lvalue, regardless.

00:41:20,560 --> 00:41:29,680
So even in this case where `T` deduces as `int`, and the parameter, lowercase `t`, is of type `int&&`, if I were to actually pass `t` to some other function in here—

00:41:29,680 --> 00:41:37,300
`t` has a name; I would care if it disappeared on me; so it would be an lvalue at that point.

00:41:37,300 --> 00:41:42,300
And I would have to `std::move` it again if I wanted to to turn it back into an rvalue.

00:41:42,300 --> 00:41:50,500
Okay, let's talk about more reference collapsing, but this time let's throw `const volatile` in there. Let's talk about cv-qualifiers.

00:41:50,500 --> 00:41:56,560
So in this case I have a `const int`. I'm passing an lvalue reference to a `const int` into a function expecting a forwarding reference here.

00:41:56,560 --> 00:42:05,500
Let's do some reference collapsing. `i` is `const int&`. We want to deduce `T` such that an rvalue reference to `T` is still a `const int&`.

00:42:05,500 --> 00:42:14,420
Well, `const int` by itself does NOT work; but I add a single ampersand to that and it does; so that's what the answer is. `T` is `const int&`.

00:42:14,420 --> 00:42:26,880
Do the same thing with the `std::move(i)` there. That's a `const int` rvalue reference. We should deduce `T` such that `T&&` is `const int&&`.

00:42:26,880 --> 00:42:35,180
And `const int` works fine, so that's we have we have: `f<const int>(const int&&)` is the answer for that one.

00:42:35,180 --> 00:42:41,000
Okay, now let's stop talking about these forwarding references, because they're too easy. Everything just works with them, right?

00:42:41,000 --> 00:42:49,220
Let's go back to lvalue references. So I have `f(T&)` here.

00:42:49,220 --> 00:42:59,060
And I try— in this case I'm just using the static_casts to explicitly specify what are the types of these things that I'm trying to show.

00:42:59,060 --> 00:43:03,260
So if I pass in an `int&` obviously I get `int` because `T&` is `int&`.

00:43:03,260 --> 00:43:16,600
If I pass in `int&&`... There is nothing I could possibly do to make `T`-lvalue-reference come out as `int`-rvalue-reference.

00:43:16,600 --> 00:43:19,240
Because I'm "minning" the things...

00:43:19,240 --> 00:43:23,440
This might be confusing until you realize you're probably thinking about it backwards.

00:43:23,440 --> 00:43:31,080
So `int&&` turning into an lvalue reference, there's nothing I can possibly deduce `T` as to make that work, so that's an error.

00:43:31,080 --> 00:43:38,680
And if I stick some qualifiers on there, like `volatile int` — well, things deduce pretty much as you would expect.

00:43:38,680 --> 00:43:43,920
And then I go to `const`. And the interesting thing about `const` is it all works exactly as you would expect...

00:43:43,920 --> 00:43:52,460
except for that last line where I cast it to a `const int` rvalue reference, and somehow, that works!

00:43:52,460 --> 00:43:58,580
That will call `f` with `T` equal to `const int`, and it will take a `const int&` parameter. That's interesting.

00:43:58,580 --> 00:44:05,540
That's an rvalue reference quietly working with a function that takes an lvalue reference!

00:44:05,540 --> 00:44:12,300
It didn't work with just plain `int`, or `volatile int`, but putting `const int` in there, as `T` — well, that worked. What's going on here?

00:44:12,300 --> 00:44:19,140
Well, so the compiler tries to deduce `T` by stripping off all the ampersands — but not the cv-qualifiers — off the argument type.

00:44:19,140 --> 00:44:25,960
And then, if it helps make a match by reference collapsing, will reintroduce a single ampersand. But never two.

00:44:25,960 --> 00:44:28,320
And in this case that actually does help make a match.

00:44:28,320 --> 00:44:35,840
You can't pass in an unqualified `int&&` to a function expecting `int&`, because that would break all sorts of things.

00:44:35,840 --> 00:44:39,100
It's nice to be able to overload on the "rvalue-ness" of a thing.

00:44:39,100 --> 00:44:45,900
But you can pass `const int&&` to a function expecting an lvalue reference to a `const`. Why is this?

00:44:45,900 --> 00:44:49,000
And the answer— What's that? [INAUDIBLE FROM AUDIENCE]

00:44:49,290 --> 00:44:51,290
"const is const"?

00:44:54,080 --> 00:44:57,820
Rvalues are kind of like const lvalues,

00:44:57,820 --> 00:45:02,220
in that, in C++03, we didn't really have rvalues. All we had was const lvalues.

00:45:02,240 --> 00:45:12,660
And so if you wanted to implement operator overloading, for example, you probably made an `operator+` that took a const lvalue reference and a const lvalue reference, and gave you back a value.

00:45:12,660 --> 00:45:20,500
And if we suddenly broke that for rvalues — and suddenly, you know, these things that used to basically be const lvalues turned into rvalues,

00:45:20,500 --> 00:45:27,580
and if suddenly your operator overload of `operator+` or whatever didn't work anymore — well, that would suck.

00:45:27,580 --> 00:45:38,200
So very quietly there's a little bit in the standard that says, if I have an rvalue, and I have a function expecting a const lvalue... yeah... we'll just let that work.

00:45:38,200 --> 00:45:43,160
So that's why that last case works in the specific case of `const`. Doesn't work for non-const, doesn't work for volatile,

00:45:43,160 --> 00:45:47,900
but `const` is a little bit magic in the standard and this is one way that it is.

00:45:47,900 --> 00:45:50,620
Now you know everything there is to know about template type deduction!

00:45:50,620 --> 00:45:54,240
As long as there's no variadics... and luckily that's still reserved for Part 2.

00:45:54,240 --> 00:45:56,640
Only function templates do this deduction thing.

00:45:56,640 --> 00:46:08,760
We talked a lot about... you know, "type deduction in a nutshell" involved the function parameters contributing to the template parameters, so it only works for things with function parameters. And that's function templates.

00:46:08,760 --> 00:46:14,300
Does type deduction happen for class templates? alias templates? variable templates? No, it does not.

00:46:14,300 --> 00:46:19,040
Because they don't have parameters. What would we deduce things from?

00:46:19,040 --> 00:46:24,320
In fact they don't even have a special case for — ah, well, as of C++17 I think they do —

00:46:24,320 --> 00:46:31,520
But there's a special case in the syntax for functions, right? where I can say just `abs(4)`, and I don't need to put the angle brackets.

00:46:31,520 --> 00:46:36,240
I don't need to tell it that's a template; it'll just figure that out. For classes I do.

00:46:36,240 --> 00:46:42,980
But I can make the brackets empty, as long as it knows what all the defaults are.

00:46:42,980 --> 00:46:49,380
So, let's talk about the "some expression." Which gets back to your question from way earlier, of what kind of thing can we put in the "some expression."

00:46:49,380 --> 00:46:59,380
Well, we need a way to specialize the template — this primary template — for a particular `T`. Here's how you define a template specialization.

00:46:59,380 --> 00:47:07,300
So we've got the primary template up there at the top. That's a cookie cutter to stamp out `is_void<Foo>` for any `Foo`.

00:47:07,300 --> 00:47:13,900
But suppose we want it to be different for one of the cookies. We have one special cookie that's `void`.

00:47:13,900 --> 00:47:25,320
So we say `template`... and we put an empty pair of angle brackets... and then we write it as if we were going to use the thing. `is_void<void>`.

00:47:25,320 --> 00:47:29,040
So you stick "template, angle-bracket, angle-bracket" — those angle brackets are very important —

00:47:29,040 --> 00:47:36,760
and then you write the function definition as if you were using the specialization that you want to write. (Function, or class, or whatever it is.)

00:47:36,760 --> 00:47:41,480
For function templates, because of their type deduction rules, this usually means you don't need to write any more angle brackets at all.

00:47:41,480 --> 00:47:45,780
But when a type can't be deduced, then you do have to write these brackets, as in that example down there.

00:47:45,790 --> 00:47:50,499
I have `T`, but I can't deduce it from the parameter list, so I have to put my little `void` in there.

00:47:50,500 --> 00:47:54,480
But if it's defaulted, I can do that... right...

00:47:54,480 --> 00:48:00,920
So here's my template specialization. I'm specializing `abs<int>`, just because I happen to know about `INT_MIN`...

00:48:00,920 --> 00:48:05,860
I could do something like this. `template<>`: this is a specialization.

00:48:05,860 --> 00:48:11,980
And then I write it out as if I were calling it. Or in this case template type deduction works fine.

00:48:11,980 --> 00:48:17,160
It knows that `x` is an `int` and therefore `T` must be `int`. And it can deduce what `T` is: `T` is `int`.

00:48:17,160 --> 00:48:24,720
I can even write that. This is what you see most often in practice. But remember, this is just syntactic sugar for the long form.

00:48:24,720 --> 00:48:27,240
That's full specialization. Yes?

00:48:27,240 --> 00:48:42,260
[INAUDIBLE FROM AUDIENCE]

00:48:42,260 --> 00:48:47,560
There is no difference between— having the angle brackets after the word `abs`? or after the word `template`?

00:48:47,560 --> 00:48:51,200
[INAUDIBLE]

00:48:51,200 --> 00:48:58,760
Getting rid of `template<>`?... At that point you've just got overloading. Yeah. Function overloading. Yes.

00:48:58,760 --> 00:49:05,720
Yes, this has nothing to do with function overloading, because this is not a function. This is a template for MAKING functions.

00:49:05,720 --> 00:49:09,680
[INAUDIBLE FROM AUDIENCE]

00:49:09,680 --> 00:49:14,840
Real functions will be looked for before templates. Yes.

00:49:14,840 --> 00:49:19,180
All right, that's full specialization. I'm going a little bit fast now because I have like five minutes left.

00:49:19,180 --> 00:49:24,320
Luckily we have a 15-minute break coming up, so we're just gonna stick around.

00:49:24,320 --> 00:49:30,120
Alias templates cannot be specialized! This is important.

00:49:30,120 --> 00:49:38,740
And the reason this is important is that... In this example here, I've got a function `foo` that takes a `myvec<T>&`.

00:49:38,740 --> 00:49:50,120
Now, if I were allowed to specialize `myvec<T>` for some `T` — like, if `myvec<void>` turned out to be `int`, instead of `std::vector`,

00:49:50,120 --> 00:49:56,480
then I would have a real hard time with overload resolution.

00:49:56,480 --> 00:49:59,040
With figuring out which `foo` I'm supposed to call.

00:49:59,040 --> 00:50:05,440
But in this case, because `myvec<T>` is ALWAYS an alias for `std::vector<T>` — because it cannot possibly be specialized —

00:50:05,440 --> 00:50:08,460
the compiler can just go ahead and substitute that right in.

00:50:08,460 --> 00:50:13,060
It can say "Oh, foo... and then the first argument is `myvec<T>`, which is really `std::vector<T>`..."

00:50:13,060 --> 00:50:16,040
"Okay, so you've got a function that takes a `std::vector<T>&` ."

00:50:16,040 --> 00:50:26,720
And it can just remember that and forget all about the fact that it was originally declared with an alias template.

00:50:26,720 --> 00:50:28,960
Does that make sense? We may also come back to that later.

00:50:28,960 --> 00:50:41,260
But that's the idea of alias templates. They are actually aliases — they are just synonyms that can get propagated all the way through, and so it's very important that they not be able to be specialized.

00:50:41,260 --> 00:50:56,480
Class templates CAN be specialized. Here's a very similar example using a pre-C++11 way of... well, we use the `using` syntax, but we have a member typedef here...

00:50:56,480 --> 00:50:59,840
I have `myvec<T>::type`...

00:50:59,840 --> 00:51:09,420
And that, I can specialize if I want to. I could make a full specialization of `myvec`, for `int`, let's say; and I could say `using type = double;`.

00:51:09,420 --> 00:51:12,520
And what that means is that when I call `foo(v)` down here,

00:51:12,520 --> 00:51:22,500
And I say, well, `v` is a `std::vector<int>`; and I'm trying to match that up with this function `foo` that takes `myvec<T>::type`...

00:51:22,500 --> 00:51:28,740
and, well, I can't know what the type of `mv` is before I know what `T` is.

00:51:28,740 --> 00:51:33,920
So this parameter `mv` does not contribute to type deduction. So it doesn't have anything to say about `T`.

00:51:33,920 --> 00:51:38,080
So I don't know what `T` is, so I can't infer template argument `T`, and so I get the error.

00:51:38,080 --> 00:51:43,240
How many people have seen errors like this? All right, well, now you know why.

00:51:43,240 --> 00:51:48,200
So class templates can't do deduction because we don't know... ah, we'll cover that... later.

00:51:48,200 --> 00:51:51,120
Now you know everything there is to know about full specialization.

00:51:51,120 --> 00:51:57,320
Partial specialization. A partial specialization is any specialization that still requires further customization by the user before it can be used.

00:51:57,320 --> 00:52:04,400
So here I can specialize my `is_array` "type trait" which I'm making here.

00:52:04,400 --> 00:52:19,120
And I can say, well, this specialization works for anything that fits the general pattern of `T[]`. So, arrays of some bound. Unspecified bound.

00:52:19,120 --> 00:52:32,680
And then if I use it with `int[]` I can say, "Aha. This does match my partial specialization. `Tp` must be `int`;" and okay, cool, I can use that.

00:52:32,680 --> 00:52:35,000
So we have a primary template first.

00:52:35,000 --> 00:52:39,080
That uses the regular old template declaration syntax.

00:52:39,080 --> 00:52:49,260
We have partial specializations, where they still use "template<typename such-and-such>"... and they can have multiple parameters, even...

00:52:49,260 --> 00:52:58,140
And then they have — in the angle brackets after the name of the template — after the name `is_array` — they have more stuff, using those template parameters.

00:52:58,140 --> 00:53:02,540
That's a new pattern that you can match when you instantiate the thing.

00:53:02,540 --> 00:53:11,600
Or you have a full specialization, which is `template<>` — and again, the empty angle brackets are important; they're what tells you it's a full specialization.

00:53:11,600 --> 00:53:18,200
And then it also has something in angle brackets after there, that of course doesn't depend on ANY template parameters, because there ARE none.

00:53:18,200 --> 00:53:25,040
Notice that the number of template parameters on the partial specializations we have here is completely unrelated to the number of template parameters on the original template.

00:53:25,040 --> 00:53:30,540
The original template, primary template, had one. Here I have a partial specialization which also has one.

00:53:30,540 --> 00:53:37,140
And a partial specialization with two template parameters. And I have a full specialization which of course has zero.

00:53:37,140 --> 00:53:49,000
Now, these — the `Tp`, and the `N`, and so on — I can deduce them from whatever you pass me, but there's no way to specify them.

00:53:49,000 --> 00:53:57,180
We still have like 20 slides left. And 2 minutes.

00:53:57,180 --> 00:54:01,940
So for which specialization is called: first you deduce all of the template type parameters.

00:54:01,940 --> 00:54:10,100
So in this case with `A<int*>`... we have deduced, in the primary template, `T` is `int*`. That's super obvious.

00:54:10,100 --> 00:54:14,120
But then which partial specialization do we instantiate?

00:54:14,120 --> 00:54:21,800
We try to match `int*` against, in order... well, `void`? — Nope, `int*` is not `void`. So we don't use the full specialization...

00:54:21,800 --> 00:54:27,400
And then we look at the other two, and we say, well, `int*` does match `Tp*`. `Tp` would be `int`. That makes sense.

00:54:27,400 --> 00:54:35,620
And it doesn't match `Tp**`. Okay. So we'll use that first partial specialization there. The third line.

00:54:35,620 --> 00:54:45,900
With `int***`, well, that would match either `Tp*` or `Tp**`, depending on what we call `Tp`.

00:54:45,900 --> 00:54:56,180
But the second specialization there, with the two stars, that's more specialized. Because anything of this form [Tp**], I could just as well plug into this [Tp*].

00:54:56,180 --> 00:55:00,500
Like, the things that match this [Tp**] are a strict subset of the things that match this [Tp*]; it's very obvious.

00:55:00,500 --> 00:55:09,940
And so the compiler will say, "okay, I will use the more specialized partial specialization" in the `A<int***>` case.

00:55:09,940 --> 00:55:11,640
That's partial specialization.

00:55:11,680 --> 00:55:19,600
Partial specialization is allowed for class templates and variable templates because variable templates are pretty much just syntactic sugar for static data members of class templates.

00:55:19,600 --> 00:55:29,040
It is not allowed for alias templates because alias templates do not allow specialization at all. It's just "no no no no no" across the board there; they're very simple, just like typedefs.

00:55:29,040 --> 00:55:34,880
But partial specialization is also not allowed for functions. Function templates cannot be partially specialized.

00:55:34,880 --> 00:55:41,640
If I have something like this you might think that that's a partial specialization. It is not! Wrong! Bzzt!

00:55:41,640 --> 00:55:46,960
This creates a pair of function templates in the same overload set.

00:55:46,960 --> 00:55:52,460
It is not a primary template and a partial specialization thereof.

00:55:52,460 --> 00:56:02,700
The partial specialization syntax always contains angle brackets after the template name. Always always always. And in this case it does not; and if you try to put them there you will get a syntax error.

00:56:02,700 --> 00:56:08,400
And if you don't put them there you will get this weird behavior where it kinda sorta seems to work,

00:56:08,400 --> 00:56:18,380
until you get into a complicated case like this where I've put little snippets of code in different orders — or rather, not in a particular order — because if you put them in different orders, you get different behavior.

00:56:18,380 --> 00:56:25,280
Here I have a primary template, called `is_pointer`, which takes a `T`.

00:56:25,280 --> 00:56:34,220
And I have a full specialization — which is totally fine. Function templates can be fully specialized – for `void*`.

00:56:34,220 --> 00:56:43,860
We also have this other thing which looks like a partial specialization, but it's not. It's a new primary template.

00:56:43,860 --> 00:56:54,580
And if this one happens to come before this full specialization, this will be a full specialization of this template. Can you all see my mouse, by the way?

00:56:54,580 --> 00:57:00,180
But if it doesn't, then this is a full specialization of this other primary template.

00:57:00,180 --> 00:57:09,020
And so when I call `is_pointer<void*>`, we definitely deduce that... well...

00:57:09,020 --> 00:57:17,740
Either `T` is `void*` or `Tp` is `void*`. Well, which of these functions — which of these primary things in my overload set — is a better match?

00:57:17,740 --> 00:57:20,280
Well, this one is actually a better match.

00:57:20,280 --> 00:57:27,400
(Here we have a hard error here. Hard stop.)

00:57:27,400 --> 00:57:31,320
(Should I actually stop?)

00:57:31,320 --> 00:57:37,460
All right. In that case, we didn't get to the end of Part 1, but stick around...

00:57:37,460 --> 00:57:41,000
because there'll be more later, but right now it's a 15-minute break.

00:57:41,000 --> 00:57:44,180

YouTube URL: https://www.youtube.com/watch?v=vwrXHznaYLA


