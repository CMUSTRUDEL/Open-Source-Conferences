Title: CppCon 2016: Walter E. Brown “What C++ Programmers Need to Know about Header ＜random＞"
Publication date: 2016-09-30
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
The generation of pseudo-random numbers has been an important computing application ever since the pioneering work of John von Neumann and others during the World War II era. It remains an important application for gaming, statistical sampling, and simulation, to name but a few areas of its continuing utility. 

Obtaining a random number (technically, a variate) is widely believed to be a simple task. Alas, it usually isn't, and programmers often have little or no training to help them make important decisions that can have subtle effects on the correctness and reliability of their programs' results. 

In this talk by the principal author of the C++ -random- facility, we will describe the header's conceptual underpinnings, demonstrate its most common correct usage pattern, exhibit and explain what's wrong with its most common usage anti-pattern, and discuss the merits of a number of possible toolkits based on the header's facilities. 
— 
Walter E. Brown
With broad experience in industry, academia, consulting, and research, Dr. Walter E. Brown has been a C++ programmer for over thirty-five years, joining the C++ standards effort in 2000. Among numerous other contributions, he is responsible for introducing such now-standard C++ library features as cbegin/cend, common_type, gcd, and void_t, as well as headers ＜ random ＞ and ＜ ratio ＞. He has also significantly impacted such core language features as alias templates, contextual conversions, variable templates, and static_assert. He conceived and served as project editor for the International Standard on Special Mathematical Functions in C++, now part of the forthcoming C++17.

When not playing with his grandchildren, Dr. Brown is an Emeritus participant in the C++ standards process, with several more core and library proposals under consideration.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,199 --> 00:00:04,970
afternoon everybody thanks for coming

00:00:06,140 --> 00:00:11,070
we're gonna talk today about the random

00:00:08,940 --> 00:00:15,059
header in the secret clear standard

00:00:11,070 --> 00:00:17,119
library it came in with C++ 2011 it's

00:00:15,059 --> 00:00:19,140
essentially been unchanged since then

00:00:17,119 --> 00:00:20,910
there are some things on the horizon

00:00:19,140 --> 00:00:23,850
that I would tell you about toward the

00:00:20,910 --> 00:00:26,730
end of the talk before I actually get

00:00:23,850 --> 00:00:28,740
into the technical details although it's

00:00:26,730 --> 00:00:31,250
customary to give thanks at the end of a

00:00:28,740 --> 00:00:34,640
talk I would like to ask your help in

00:00:31,250 --> 00:00:38,100
thanking somebody very important to me

00:00:34,640 --> 00:00:39,210
someone who hardly ever gets thanked and

00:00:38,100 --> 00:00:43,079
that would be my wife

00:00:39,210 --> 00:00:45,420
who actually fabricated my tie that I am

00:00:43,079 --> 00:00:51,420
wearing today so please help me thank

00:00:45,420 --> 00:00:56,010
her I appreciate that

00:00:51,420 --> 00:01:00,750
thanks very much so we're going to talk

00:00:56,010 --> 00:01:03,799
today as advertised about the ideas that

00:01:00,750 --> 00:01:07,350
went into what became the random header

00:01:03,799 --> 00:01:10,680
they'll demonstrate the most common

00:01:07,350 --> 00:01:14,610
correct usage pattern I will show you

00:01:10,680 --> 00:01:17,159
the most common incorrect anti-pattern

00:01:14,610 --> 00:01:18,630
and I'll explain what's wrong with it

00:01:17,159 --> 00:01:20,909
what's really wrong with it is

00:01:18,630 --> 00:01:24,180
sociological it's just too simple it's

00:01:20,909 --> 00:01:28,020
too attractive but thou shalt not do

00:01:24,180 --> 00:01:33,810
this we will explore some toolkit

00:01:28,020 --> 00:01:35,610
designs and you can extend that if you

00:01:33,810 --> 00:01:39,329
wish we're gonna have a little random

00:01:35,610 --> 00:01:41,520
fun some of this material is taken from

00:01:39,329 --> 00:01:43,530
some paper I wrote a few years ago those

00:01:41,520 --> 00:01:44,840
are the there are the paper numbers are

00:01:43,530 --> 00:01:48,240
there in case you want to look them up

00:01:44,840 --> 00:01:50,610
and there are going to be some extra

00:01:48,240 --> 00:01:53,460
slides that I've had to hide because

00:01:50,610 --> 00:01:56,969
otherwise I'm I would go over time but

00:01:53,460 --> 00:01:58,979
the files that I will upload will have

00:01:56,969 --> 00:02:00,840
all of the slides so if you happen to

00:01:58,979 --> 00:02:03,060
notice that there are some gaps in slide

00:02:00,840 --> 00:02:05,070
numbering there's some hidden slides

00:02:03,060 --> 00:02:07,290
there so if you're interested in just a

00:02:05,070 --> 00:02:09,330
few more little details please do

00:02:07,290 --> 00:02:12,750
download the slides or at least look at

00:02:09,330 --> 00:02:13,800
them at your convenience so first a

00:02:12,750 --> 00:02:15,780
little bit of background

00:02:13,800 --> 00:02:20,190
information on the general topic of

00:02:15,780 --> 00:02:21,840
randomness yeah they're a pain in the

00:02:20,190 --> 00:02:27,090
butt I said it was background

00:02:21,840 --> 00:02:28,740
information good night okay and of

00:02:27,090 --> 00:02:34,560
course there's the famous statement by

00:02:28,740 --> 00:02:38,670
Don Knuth this has been known for a very

00:02:34,560 --> 00:02:41,120
long time and yet the temptation is

00:02:38,670 --> 00:02:43,490
almost irresistible to roll your own

00:02:41,120 --> 00:02:46,290
please don't do it

00:02:43,490 --> 00:02:51,180
please don't roll your own unless you're

00:02:46,290 --> 00:02:54,780
an expert it is interesting that the

00:02:51,180 --> 00:02:56,880
first known algorithm for generating or

00:02:54,780 --> 00:03:02,550
pseudo generating pseudo-random numbers

00:02:56,880 --> 00:03:06,420
dates back to around 12:45 a Franciscan

00:03:02,550 --> 00:03:08,550
brother Edvin wrote about it it was then

00:03:06,420 --> 00:03:10,680
I believe independently rediscovered by

00:03:08,550 --> 00:03:14,910
John von Neumann around the middle of

00:03:10,680 --> 00:03:17,520
the last century it is considered a a

00:03:14,910 --> 00:03:19,530
crude but very fast algorithm they had

00:03:17,520 --> 00:03:22,020
ideas you start with you know a big

00:03:19,530 --> 00:03:23,550
number you square it you chop off a

00:03:22,020 --> 00:03:24,989
quarter of the digits at the end the

00:03:23,550 --> 00:03:27,209
quarter of the digits at the beginning

00:03:24,989 --> 00:03:29,630
and what you're left is the middle of

00:03:27,209 --> 00:03:32,820
the square and that's your next number

00:03:29,630 --> 00:03:34,739
that's very fast very crude but it's

00:03:32,820 --> 00:03:36,540
very fast and the failure modes are

00:03:34,739 --> 00:03:41,280
obvious if you ever happen to get a zero

00:03:36,540 --> 00:03:44,570
you're done right okay but nonetheless

00:03:41,280 --> 00:03:48,720
this algorithm was in use at some point

00:03:44,570 --> 00:03:51,810
back then in particular it was used back

00:03:48,720 --> 00:03:55,380
then in support of what has come to be

00:03:51,810 --> 00:03:57,209
called the Monte Carlo method it's an

00:03:55,380 --> 00:04:01,260
unusual name it turns out it was a

00:03:57,209 --> 00:04:02,670
codename during the post-war years all

00:04:01,260 --> 00:04:05,130
right they were still actively involved

00:04:02,670 --> 00:04:09,120
in the Manhattan Project back then was

00:04:05,130 --> 00:04:12,870
developed by you Lamy and actually coded

00:04:09,120 --> 00:04:16,470
on the e me app by John von Neumann the

00:04:12,870 --> 00:04:20,340
process however known as Monte Carlo is

00:04:16,470 --> 00:04:24,840
still in heavy heavy heavy use today and

00:04:20,340 --> 00:04:26,970
it relies intimately on the generation

00:04:24,840 --> 00:04:30,630
of random numbers the idea of course is

00:04:26,970 --> 00:04:32,880
you simulate a process and then do

00:04:30,630 --> 00:04:35,700
statistical analysis on the measurements

00:04:32,880 --> 00:04:37,650
you take as a result but nowadays there

00:04:35,700 --> 00:04:39,360
are many more uses of random numbers

00:04:37,650 --> 00:04:41,460
I'll just give you some highlights

00:04:39,360 --> 00:04:43,410
there are Monte Carlo and other

00:04:41,460 --> 00:04:45,710
simulations and yes it's called Monte

00:04:43,410 --> 00:04:48,810
Carlo because of where the casino is

00:04:45,710 --> 00:04:51,840
there are genetic algorithms randomized

00:04:48,810 --> 00:04:53,370
algorithms hashing algorithms not too

00:04:51,840 --> 00:04:55,050
many people have discovered know about

00:04:53,370 --> 00:04:56,700
something called Zobrist hashing it's

00:04:55,050 --> 00:05:02,040
interesting that it applies to board

00:04:56,700 --> 00:05:04,590
games for example rearranging which most

00:05:02,040 --> 00:05:08,610
of us know better as shuffling is a very

00:05:04,590 --> 00:05:10,560
common application of randomness for

00:05:08,610 --> 00:05:14,070
most of us or many of us at least we use

00:05:10,560 --> 00:05:17,040
it to test sort algorithms but it is

00:05:14,070 --> 00:05:19,680
used in so-called randomized

00:05:17,040 --> 00:05:23,190
tournaments which covers everything from

00:05:19,680 --> 00:05:25,260
sporting events to the military draft if

00:05:23,190 --> 00:05:28,230
you want to see some fascinating history

00:05:25,260 --> 00:05:33,090
look at the first random draft of the US

00:05:28,230 --> 00:05:35,550
military it's a horror story there are

00:05:33,090 --> 00:05:40,410
jurisdictions in which the preparation

00:05:35,550 --> 00:05:42,240
of a voter ballot is randomized so that

00:05:40,410 --> 00:05:45,419
no candidate is obviously favored by

00:05:42,240 --> 00:05:47,130
being first for example random numbers

00:05:45,419 --> 00:05:50,460
are used for selection purposes

00:05:47,130 --> 00:05:52,260
obviously in gaming there are teachers

00:05:50,460 --> 00:05:55,919
who use it to make sure that they call

00:05:52,260 --> 00:05:57,900
on students fairly eliminating personal

00:05:55,919 --> 00:06:00,479
bias don't just call on the most event

00:05:57,900 --> 00:06:03,390
on the best-looking student choosing

00:06:00,479 --> 00:06:05,910
performers on open mic night for us

00:06:03,390 --> 00:06:09,390
choosing a pivot and quicksort is often

00:06:05,910 --> 00:06:12,150
done randomly a lot of applications and

00:06:09,390 --> 00:06:14,850
statistical sampling in manufacturing

00:06:12,150 --> 00:06:19,440
quality control and drug screening drug

00:06:14,850 --> 00:06:21,000
screening drug screening auditing trials

00:06:19,440 --> 00:06:24,150
for new medical treatments etcetra

00:06:21,000 --> 00:06:26,280
etcetra it's a very long list and one

00:06:24,150 --> 00:06:28,320
item I want to call out specifically of

00:06:26,280 --> 00:06:31,050
course random numbers have a role to

00:06:28,320 --> 00:06:33,120
play in cryptography but I want to let

00:06:31,050 --> 00:06:36,840
you know at the outset that this is not

00:06:33,120 --> 00:06:39,419
a goal of the in the design of the

00:06:36,840 --> 00:06:40,440
random header cryptography has

00:06:39,419 --> 00:06:43,800
additional

00:06:40,440 --> 00:06:46,050
requirements that were not considered

00:06:43,800 --> 00:06:49,080
when this header was designed design

00:06:46,050 --> 00:06:52,170
goes back almost 15 years we did not

00:06:49,080 --> 00:06:54,690
consider cryptography so please if you

00:06:52,170 --> 00:06:57,420
have the cryptographic application this

00:06:54,690 --> 00:06:59,730
is not a good place to start to look you

00:06:57,420 --> 00:07:01,260
can look at it for inspiration but these

00:06:59,730 --> 00:07:03,480
are not the facilities you should be

00:07:01,260 --> 00:07:06,420
using at least not without some extra

00:07:03,480 --> 00:07:09,330
work on your part so let me start with a

00:07:06,420 --> 00:07:11,340
with a with a leading question suppose

00:07:09,330 --> 00:07:13,560
you have an Oracle of some sort I don't

00:07:11,340 --> 00:07:15,930
care if it's a crystal ball and if you

00:07:13,560 --> 00:07:17,820
if you you know look at some entrails or

00:07:15,930 --> 00:07:20,130
whatever you do you have an Oracle and

00:07:17,820 --> 00:07:22,650
you ask it for some some random numbers

00:07:20,130 --> 00:07:28,110
and ten times in a row it delivers to

00:07:22,650 --> 00:07:33,950
you zero did you consider that random I

00:07:28,110 --> 00:07:33,950
suspect most of us would say no and yet

00:07:34,190 --> 00:07:39,210
there's not enough information to answer

00:07:36,420 --> 00:07:42,300
the question you don't have a big enough

00:07:39,210 --> 00:07:45,390
sample to know whether that's random you

00:07:42,300 --> 00:07:48,150
just don't Pete back Pete Becker was a

00:07:45,390 --> 00:07:49,410
was a well-respected member of the C++

00:07:48,150 --> 00:07:52,950
standards committee he was the project

00:07:49,410 --> 00:07:53,820
editor for C++ 11 and he's now enjoying

00:07:52,950 --> 00:07:57,570
his retirement

00:07:53,820 --> 00:08:00,000
SMI there's another way of expressing

00:07:57,570 --> 00:08:02,070
the same notion this is perhaps a very

00:08:00,000 --> 00:08:07,290
well-known cartoon but I felt it

00:08:02,070 --> 00:08:13,350
appropriate at this point as always

00:08:07,290 --> 00:08:16,560
scott adams cuts to the heart and it

00:08:13,350 --> 00:08:19,770
turns out that getting a computer to do

00:08:16,560 --> 00:08:23,940
anything randomly is not just difficult

00:08:19,770 --> 00:08:25,470
but astonishingly difficult far more

00:08:23,940 --> 00:08:29,360
difficult than most of us would like to

00:08:25,470 --> 00:08:36,300
think it's not just hard for computers

00:08:29,360 --> 00:08:38,690
it's also interesting the problem is if

00:08:36,300 --> 00:08:42,810
you look at the literature of the past

00:08:38,690 --> 00:08:44,190
6070 years as I have done I don't claim

00:08:42,810 --> 00:08:47,370
to have read all of it but I've read a

00:08:44,190 --> 00:08:52,050
fair amount of it I am not exaggerating

00:08:47,370 --> 00:08:53,010
it is littered with algorithms that were

00:08:52,050 --> 00:08:56,250
just plain

00:08:53,010 --> 00:08:59,070
wrong but that people have been relying

00:08:56,250 --> 00:09:00,870
on and because it was it has been

00:08:59,070 --> 00:09:02,670
published you know people think

00:09:00,870 --> 00:09:04,340
therefore it must be good and some of

00:09:02,670 --> 00:09:08,130
these things are still in use today

00:09:04,340 --> 00:09:10,640
please don't don't rely on anything

00:09:08,130 --> 00:09:17,130
until it's been exhaustively tested

00:09:10,640 --> 00:09:21,030
there are so many pitfalls this is a

00:09:17,130 --> 00:09:24,420
very nice statement of the facts as

00:09:21,030 --> 00:09:27,620
proven by history you don't want to

00:09:24,420 --> 00:09:36,270
write code that's embarassingly bad I

00:09:27,620 --> 00:09:39,750
sure don't here's a nice summary of the

00:09:36,270 --> 00:09:42,150
return message and this is really at the

00:09:39,750 --> 00:09:44,970
heart of why we designed and ultimately

00:09:42,150 --> 00:09:47,670
specified the random number library in

00:09:44,970 --> 00:09:51,450
the random header I'm the center of the

00:09:47,670 --> 00:09:54,120
principle author of the papers if you do

00:09:51,450 --> 00:09:58,650
arbitrary stuff on random numbers you

00:09:54,120 --> 00:10:03,630
don't get random output you might but

00:09:58,650 --> 00:10:11,070
you'd be lucky and then of course xkcd

00:10:03,630 --> 00:10:16,320
comes along so what you asked for not

00:10:11,070 --> 00:10:18,710
what you wanted I am often asked what

00:10:16,320 --> 00:10:21,810
was wrong with the ran function in

00:10:18,710 --> 00:10:26,610
instead of Lib dot H and of course which

00:10:21,810 --> 00:10:29,070
we absorbed as C stood Live Well if you

00:10:26,610 --> 00:10:31,860
haven't I encourage you to go read what

00:10:29,070 --> 00:10:35,010
the C standard says about it in C 11

00:10:31,860 --> 00:10:37,200
here's the quote it's a footnote there

00:10:35,010 --> 00:10:41,760
are no guarantees about the quality of

00:10:37,200 --> 00:10:45,680
what you get and it is known that some

00:10:41,760 --> 00:10:53,310
implementations give you not just bad

00:10:45,680 --> 00:10:56,100
distressingly non-random bits that's

00:10:53,310 --> 00:11:01,290
what it says I'm quoting the standard I

00:10:56,100 --> 00:11:05,340
did not make this up C++ standard C++ 17

00:11:01,290 --> 00:11:06,769
at least says it I think a little bit

00:11:05,340 --> 00:11:09,839
more genteel

00:11:06,769 --> 00:11:13,319
the algorithm is unspecified which of

00:11:09,839 --> 00:11:15,239
course means unported unpredictable

00:11:13,319 --> 00:11:18,779
quality and performance and oft

00:11:15,239 --> 00:11:22,199
questionable right I think that's a

00:11:18,779 --> 00:11:23,779
little gentler but hey it's a C function

00:11:22,199 --> 00:11:28,139
they get to say whatever they want about

00:11:23,779 --> 00:11:30,509
anyway here is one man's opinion I wish

00:11:28,139 --> 00:11:34,049
I knew who this was this is what he

00:11:30,509 --> 00:11:36,360
calls himself on his blog in me which I

00:11:34,049 --> 00:11:37,999
thought it was kind of flattering so

00:11:36,360 --> 00:11:41,399
whoever you are thank you

00:11:37,999 --> 00:11:45,420
so let's actually have a big picture

00:11:41,399 --> 00:11:47,429
look at what's in the head of it this is

00:11:45,420 --> 00:11:48,600
what we are in a comments but he's

00:11:47,429 --> 00:11:51,899
quoting somebody else

00:11:48,600 --> 00:11:54,779
I believe he's quoting Andrei Alexander

00:11:51,899 --> 00:11:57,660
s Q not a hundred percent sure but this

00:11:54,779 --> 00:12:02,429
is from B Arnaz or was on B Ana's

00:11:57,660 --> 00:12:04,110
homepage or one of his home pages but

00:12:02,429 --> 00:12:07,559
every random number library wants to be

00:12:04,110 --> 00:12:09,989
when it grows up I love that phrase so

00:12:07,559 --> 00:12:12,269
at least in my opinion there's something

00:12:09,989 --> 00:12:14,549
there for everybody whether you're a

00:12:12,269 --> 00:12:16,350
novice a casual user all the way up

00:12:14,549 --> 00:12:19,799
through expert there's something there

00:12:16,350 --> 00:12:21,959
for everybody so for those of us who are

00:12:19,799 --> 00:12:25,169
casual users which you're probably most

00:12:21,959 --> 00:12:27,029
interested in is the one pre-configured

00:12:25,169 --> 00:12:29,639
engine type and I'll make sure we all

00:12:27,029 --> 00:12:32,879
know what if that means all the words in

00:12:29,639 --> 00:12:35,850
green we will discuss and then there are

00:12:32,879 --> 00:12:38,129
two uniform distribution

00:12:35,850 --> 00:12:40,230
class templates they are configurable

00:12:38,129 --> 00:12:42,029
can't pre configure them because we

00:12:40,230 --> 00:12:45,329
don't know your application so you have

00:12:42,029 --> 00:12:47,459
to configure them but for intermediate

00:12:45,329 --> 00:12:50,249
and advanced users we have nine more

00:12:47,459 --> 00:12:55,019
engine types 18 more distribution

00:12:50,249 --> 00:12:57,149
templates there's a class in case you

00:12:55,019 --> 00:12:59,179
have access to some environmental source

00:12:57,149 --> 00:13:01,410
of randomness we'll discuss that briefly

00:12:59,179 --> 00:13:04,889
there's a class that was supposed to

00:13:01,410 --> 00:13:07,499
help you with engine seeding and for

00:13:04,889 --> 00:13:09,929
true experts we have some class

00:13:07,499 --> 00:13:12,660
templates if you want to play with the

00:13:09,929 --> 00:13:14,939
template parameters and there's actually

00:13:12,660 --> 00:13:17,850
even a function template to help authors

00:13:14,939 --> 00:13:18,480
of new distributions if in case that's

00:13:17,850 --> 00:13:19,980
your thing

00:13:18,480 --> 00:13:22,890
so there's something

00:13:19,980 --> 00:13:26,880
for just about everybody on the on the

00:13:22,890 --> 00:13:30,260
programming spectrum this perhaps the

00:13:26,880 --> 00:13:34,170
single most important takeaway for now

00:13:30,260 --> 00:13:36,660
are the next few lines the nomenclature

00:13:34,170 --> 00:13:40,230
that we use it is generally not

00:13:36,660 --> 00:13:43,760
particularly well known that the

00:13:40,230 --> 00:13:48,600
traditional term random number generator

00:13:43,760 --> 00:13:53,040
actually encapsulates two very different

00:13:48,600 --> 00:13:54,810
kinds of algorithms it's almost like an

00:13:53,040 --> 00:13:56,790
old-fashioned computer terminal that had

00:13:54,810 --> 00:13:59,010
a keyboard that had a monitor but they

00:13:56,790 --> 00:14:01,200
were all under one dust cover we just

00:13:59,010 --> 00:14:03,390
said it's a terminal but you've got two

00:14:01,200 --> 00:14:06,000
very different pieces of equipment there

00:14:03,390 --> 00:14:07,440
under one cover same idea here if you

00:14:06,000 --> 00:14:11,820
talk about a random number generation

00:14:07,440 --> 00:14:13,890
there are two algorithms and we need to

00:14:11,820 --> 00:14:15,960
talk about them separately so we use

00:14:13,890 --> 00:14:18,360
nomenclature that's a little bit more

00:14:15,960 --> 00:14:20,510
precise and if you're going to work with

00:14:18,360 --> 00:14:23,310
this this is what you should know best

00:14:20,510 --> 00:14:28,200
the first piece of nomenclature is the

00:14:23,310 --> 00:14:33,210
is the term engine engine is what we

00:14:28,200 --> 00:14:36,960
mean by an algorithm or something else

00:14:33,210 --> 00:14:40,070
perhaps that lets you obtain a sequence

00:14:36,960 --> 00:14:46,470
of unpredictable at least ideally

00:14:40,070 --> 00:14:50,520
unpredictable bits in particular uniform

00:14:46,470 --> 00:14:51,720
is the important property and what do we

00:14:50,520 --> 00:14:53,460
mean by uniform

00:14:51,720 --> 00:14:55,320
it's the statisticians way of saying

00:14:53,460 --> 00:14:58,050
that probability of a 0 is the same as

00:14:55,320 --> 00:15:01,230
the probability of a 1 every single time

00:14:58,050 --> 00:15:05,190
that's the uniformity property at the

00:15:01,230 --> 00:15:07,050
bit level okay and the second piece of

00:15:05,190 --> 00:15:10,050
nomenclature is the idea of a

00:15:07,050 --> 00:15:12,420
distribution which is well known to

00:15:10,050 --> 00:15:15,330
statisticians but not necessarily to

00:15:12,420 --> 00:15:18,260
computer scientists and programmers the

00:15:15,330 --> 00:15:21,600
distribution is a means of obtaining a

00:15:18,260 --> 00:15:24,810
variant we think of them as random

00:15:21,600 --> 00:15:29,160
numbers the technical term is a variant

00:15:24,810 --> 00:15:32,400
and it's not just any variant we want

00:15:29,160 --> 00:15:33,780
variants for our applications such that

00:15:32,400 --> 00:15:36,540
if you aggregate

00:15:33,780 --> 00:15:40,260
and you plot them you get a particular

00:15:36,540 --> 00:15:42,450
shape but what shape do you want I can't

00:15:40,260 --> 00:15:44,610
answer that you have to answer that for

00:15:42,450 --> 00:15:47,250
your application here are some

00:15:44,610 --> 00:15:49,860
possibilities there are lots lots more

00:15:47,250 --> 00:15:52,500
it's not important that you see what

00:15:49,860 --> 00:15:54,510
these are but just the you know a little

00:15:52,500 --> 00:15:57,900
bit of the possible variety of what I

00:15:54,510 --> 00:15:59,580
mean by aggregated shape the the first

00:15:57,900 --> 00:16:01,770
one at the bottom left is called the

00:15:59,580 --> 00:16:05,340
normal distribution a lot of us know it

00:16:01,770 --> 00:16:07,770
as the bell-shaped curve but that's

00:16:05,340 --> 00:16:11,570
parameterised how wide is it how high is

00:16:07,770 --> 00:16:13,890
it where is it left-right etc etc okay

00:16:11,570 --> 00:16:16,680
so these are things you will have to

00:16:13,890 --> 00:16:18,840
supply you have to know your application

00:16:16,680 --> 00:16:22,890
well enough to decide what kind of a

00:16:18,840 --> 00:16:26,190
distribution you want for people who are

00:16:22,890 --> 00:16:28,650
casual users almost always what they

00:16:26,190 --> 00:16:30,600
want is a uniform distribution if you're

00:16:28,650 --> 00:16:32,340
you know playing cards or you're trying

00:16:30,600 --> 00:16:33,060
to simulate rolling a fair die or

00:16:32,340 --> 00:16:35,570
something like that

00:16:33,060 --> 00:16:38,540
what you want is a uniform distribution

00:16:35,570 --> 00:16:41,900
if you want to roll two dice

00:16:38,540 --> 00:16:46,080
you don't want a uniform distribution

00:16:41,900 --> 00:16:48,150
unless you roll them one at a time okay

00:16:46,080 --> 00:16:48,630
so you have to know what you're talking

00:16:48,150 --> 00:16:50,760
about

00:16:48,630 --> 00:16:57,770
this is a classic example where two

00:16:50,760 --> 00:17:01,560
times X does not equal X plus X okay so

00:16:57,770 --> 00:17:05,010
beware of even simple refactorings that

00:17:01,560 --> 00:17:06,900
seem obvious they don't necessarily work

00:17:05,010 --> 00:17:09,180
you have to know what you're doing so

00:17:06,900 --> 00:17:11,189
let's talk a little bit about engines we

00:17:09,180 --> 00:17:14,550
use the term engine both to refer to

00:17:11,189 --> 00:17:18,390
certain kinds of types and then to

00:17:14,550 --> 00:17:20,250
objects of those types all right so

00:17:18,390 --> 00:17:22,860
let's postulate that we have an engine

00:17:20,250 --> 00:17:25,920
object lowercase e whose type is capital

00:17:22,860 --> 00:17:29,990
e and it's a function object it's

00:17:25,920 --> 00:17:29,990
callable it has an operator parents

00:17:30,050 --> 00:17:36,270
every time you call it you're going to

00:17:32,790 --> 00:17:43,380
get some number of bits uniformly

00:17:36,270 --> 00:17:45,420
distributed ideally random bits okay by

00:17:43,380 --> 00:17:47,720
the way don't assume that n has to be an

00:17:45,420 --> 00:17:47,720
integer

00:17:48,590 --> 00:17:54,450
don't assume it usually is it typically

00:17:51,990 --> 00:18:00,270
is nothing in the definition says it has

00:17:54,450 --> 00:18:02,310
to be once initialized this object has

00:18:00,270 --> 00:18:04,410
typically deterministic output and

00:18:02,310 --> 00:18:07,370
therefore we if you want to be precise

00:18:04,410 --> 00:18:14,160
you're actually getting pseudo-random

00:18:07,370 --> 00:18:15,690
numbers okay but not every engine gives

00:18:14,160 --> 00:18:18,360
you deterministic output we have

00:18:15,690 --> 00:18:21,600
interfaces for environmental sources of

00:18:18,360 --> 00:18:23,310
randomness so don't assume it's going to

00:18:21,600 --> 00:18:29,240
be pseudo-random depends on your choice

00:18:23,310 --> 00:18:31,110
of engine the ideal is unpredictability

00:18:29,240 --> 00:18:33,450
but when you have a computer you

00:18:31,110 --> 00:18:35,660
typically have to settle for very very

00:18:33,450 --> 00:18:39,560
very very very very hard to predict

00:18:35,660 --> 00:18:42,960
that's the key an inability to predict

00:18:39,560 --> 00:18:45,690
that's the key now there are some

00:18:42,960 --> 00:18:48,510
details right when you call an engine

00:18:45,690 --> 00:18:50,760
what you get is often called a bit

00:18:48,510 --> 00:18:54,800
string in other contexts it has a

00:18:50,760 --> 00:19:00,890
nonzero length it's encoded as some

00:18:54,800 --> 00:19:03,720
unsigned type there's a reason for that

00:19:00,890 --> 00:19:05,190
long long ago when we were designing and

00:19:03,720 --> 00:19:07,920
experimenting with this stuff our

00:19:05,190 --> 00:19:10,710
initial idea for an engine was you make

00:19:07,920 --> 00:19:12,780
a call you get a bit one another bit you

00:19:10,710 --> 00:19:15,570
make a second call the performance was

00:19:12,780 --> 00:19:19,590
horrible as you can well imagine so we

00:19:15,570 --> 00:19:21,600
said okay you know let's allow engines

00:19:19,590 --> 00:19:24,330
to give you up to 32 bits at a time or

00:19:21,600 --> 00:19:29,340
you know back then that was that was the

00:19:24,330 --> 00:19:32,460
obvious result okay but we don't require

00:19:29,340 --> 00:19:36,300
anything other than there be some men

00:19:32,460 --> 00:19:38,310
and some max value both unsigned of

00:19:36,300 --> 00:19:41,070
course and you can ask what those are

00:19:38,310 --> 00:19:47,930
min is almost always zero but it's not

00:19:41,070 --> 00:19:52,380
required to be most importantly for

00:19:47,930 --> 00:19:58,260
users you probably don't need to know

00:19:52,380 --> 00:20:03,030
any of that really don't do

00:19:58,260 --> 00:20:04,919
intent of an engine is that you get to

00:20:03,030 --> 00:20:07,140
pick which one you want your choice of

00:20:04,919 --> 00:20:09,809
algorithm you get to initialize it

00:20:07,140 --> 00:20:11,970
however you want your choice you may

00:20:09,809 --> 00:20:15,330
want to reproducibility you may want no

00:20:11,970 --> 00:20:17,429
reproducibility it's up to you but once

00:20:15,330 --> 00:20:22,500
you've done that all you do is pass it

00:20:17,429 --> 00:20:25,080
around literally that's almost all you

00:20:22,500 --> 00:20:26,429
ever do with it I mean an engine can do

00:20:25,080 --> 00:20:29,760
other things I'll tell you about some of

00:20:26,429 --> 00:20:31,260
them later but the single most important

00:20:29,760 --> 00:20:36,090
thing you want to do with an engine is

00:20:31,260 --> 00:20:39,020
hand it off to something else so let's

00:20:36,090 --> 00:20:42,059
talk a little bit about distributions

00:20:39,020 --> 00:20:45,419
the purpose of a distribution object is

00:20:42,059 --> 00:20:47,610
again you call it and it gives you a

00:20:45,419 --> 00:20:50,940
result and this is what you want you

00:20:47,610 --> 00:20:56,100
want a very random number you do it by

00:20:50,940 --> 00:20:57,630
calling a distribution okay so you have

00:20:56,100 --> 00:20:59,660
to create a distribution which

00:20:57,630 --> 00:21:03,750
distribution depends on your application

00:20:59,660 --> 00:21:08,400
how do you create one depends on your

00:21:03,750 --> 00:21:10,970
choice of distribution typically these

00:21:08,400 --> 00:21:14,429
are templates so you have to tell it

00:21:10,970 --> 00:21:16,110
what's the type that you want to get

00:21:14,429 --> 00:21:17,340
back if you want integers and you want

00:21:16,110 --> 00:21:19,620
to float if you want to double what do

00:21:17,340 --> 00:21:21,530
you want their distributions that give

00:21:19,620 --> 00:21:25,140
you bools

00:21:21,530 --> 00:21:28,380
okay and huh and then what are the

00:21:25,140 --> 00:21:30,570
constructor arguments well it depends on

00:21:28,380 --> 00:21:33,210
your choice of distribution here are two

00:21:30,570 --> 00:21:35,970
examples the uniform into distribution

00:21:33,210 --> 00:21:37,740
is one of the ones that that beginners

00:21:35,970 --> 00:21:41,160
typically need if you want to roll a die

00:21:37,740 --> 00:21:43,799
or shuffle cards or something so this

00:21:41,160 --> 00:21:46,590
example says I want variants of type

00:21:43,799 --> 00:21:52,250
long and I want them in the range load

00:21:46,590 --> 00:21:55,470
to high inclusive low through high okay

00:21:52,250 --> 00:21:59,549
so if you're rolling a die that'd be one

00:21:55,470 --> 00:22:02,370
and six if you want the normal

00:21:59,549 --> 00:22:04,380
distribution the bell-shaped curve again

00:22:02,370 --> 00:22:07,799
you tell it what type you want as a

00:22:04,380 --> 00:22:10,260
result but it's parameterised according

00:22:07,799 --> 00:22:13,260
to a mean and standard deviation from

00:22:10,260 --> 00:22:15,950
hi so how you instantiate this depends

00:22:13,260 --> 00:22:18,530
on what you choose okay

00:22:15,950 --> 00:22:21,150
so here's sort of the canonical example

00:22:18,530 --> 00:22:24,870
it's very simple and once you've seen

00:22:21,150 --> 00:22:27,420
this and understand it you know at least

00:22:24,870 --> 00:22:30,930
90% of what you need to know to make use

00:22:27,420 --> 00:22:31,800
of this header so the idea is you roll a

00:22:30,930 --> 00:22:33,150
fair die

00:22:31,800 --> 00:22:34,830
of course you include the header I'm not

00:22:33,150 --> 00:22:37,800
going to bother doing that ever again

00:22:34,830 --> 00:22:42,060
you need to instantiate an engine and a

00:22:37,800 --> 00:22:43,920
distribution and there's something

00:22:42,060 --> 00:22:46,590
called a default random engine I'll say

00:22:43,920 --> 00:22:48,390
more about that shortly and then the

00:22:46,590 --> 00:22:51,540
uniform int distribution as I showed you

00:22:48,390 --> 00:22:53,430
above I made them static for simplicity

00:22:51,540 --> 00:22:56,970
here of course you get to control their

00:22:53,430 --> 00:22:58,680
lifetimes however you want if you want

00:22:56,970 --> 00:23:00,900
you can do shared pointers and you can

00:22:58,680 --> 00:23:03,570
pass around shared pointers if you want

00:23:00,900 --> 00:23:05,340
that's it that's entirely up to you I'll

00:23:03,570 --> 00:23:07,620
give you some tips about management in a

00:23:05,340 --> 00:23:11,040
little bit and then what you do is you

00:23:07,620 --> 00:23:12,930
call div and again as I said all you're

00:23:11,040 --> 00:23:14,580
doing what the engine is handing it over

00:23:12,930 --> 00:23:18,840
to somebody else in this case the

00:23:14,580 --> 00:23:21,120
distribution and for 90% of the use

00:23:18,840 --> 00:23:23,780
cases that I've seen in the last 15 or

00:23:21,120 --> 00:23:27,030
20 years this is what you want to do

00:23:23,780 --> 00:23:31,650
this is necessary and typically it's

00:23:27,030 --> 00:23:34,680
sufficient now one of the nice things is

00:23:31,650 --> 00:23:38,940
that once you package a distribution and

00:23:34,680 --> 00:23:41,100
an engine perhaps like this you get to

00:23:38,940 --> 00:23:46,050
do other kind of neat things and just to

00:23:41,100 --> 00:23:50,160
give you a hint suppose I make you know

00:23:46,050 --> 00:23:51,990
a native array of size 1,000 I'd like to

00:23:50,160 --> 00:23:54,690
fill it with a thousand rolls of the

00:23:51,990 --> 00:24:00,780
fair die okay so generate will do that

00:23:54,690 --> 00:24:05,390
for you fill the array a from 0 up to n

00:24:00,780 --> 00:24:08,490
and each time it calls roll a fair die

00:24:05,390 --> 00:24:10,950
which is a kind of function object

00:24:08,490 --> 00:24:13,680
that's a function but that the function

00:24:10,950 --> 00:24:15,780
is a function object and it takes no

00:24:13,680 --> 00:24:19,800
arguments so you can pass it off to

00:24:15,780 --> 00:24:23,520
generate and now you have a thousand

00:24:19,800 --> 00:24:24,990
grant rolls of at that fair die ok

00:24:23,520 --> 00:24:29,790
the little taste of some things that you

00:24:24,990 --> 00:24:33,750
can do now let's explore a little bit in

00:24:29,790 --> 00:24:35,490
more depth there are ten pre-configured

00:24:33,750 --> 00:24:38,490
engine types that you can choose from

00:24:35,490 --> 00:24:42,420
I'm going to pick first on the default

00:24:38,490 --> 00:24:45,870
random engine it is special in a couple

00:24:42,420 --> 00:24:48,240
of ways it is intended and then you can

00:24:45,870 --> 00:24:53,910
read the quote yourself casual in expert

00:24:48,240 --> 00:24:57,180
or like waste use you don't know what

00:24:53,910 --> 00:24:59,970
algorithm it uses it's deliberately

00:24:57,180 --> 00:25:05,640
specify that way your vendor gets to

00:24:59,970 --> 00:25:09,030
choose the algorithm as a result the

00:25:05,640 --> 00:25:12,090
output of an engine of this type is not

00:25:09,030 --> 00:25:13,470
portable across platforms because

00:25:12,090 --> 00:25:16,260
different vendors can make different

00:25:13,470 --> 00:25:18,690
choices I know there are vendors who say

00:25:16,260 --> 00:25:23,660
I want this to be fast other vendors say

00:25:18,690 --> 00:25:29,070
I want this to be high quality etc okay

00:25:23,660 --> 00:25:34,310
but for the other nine they are nailed

00:25:29,070 --> 00:25:38,400
down and you are guaranteed bit for bit

00:25:34,310 --> 00:25:40,860
portability across platforms it's a

00:25:38,400 --> 00:25:44,870
requirement your vendor has to do this

00:25:40,860 --> 00:25:44,870
if he's going to conform to the standard

00:25:45,440 --> 00:25:49,740
now I've named them for you here you

00:25:48,360 --> 00:25:52,560
know don't feel you have to memorize

00:25:49,740 --> 00:25:54,420
them I'm also not you know going to give

00:25:52,560 --> 00:25:55,920
you a tutorial and you know what are the

00:25:54,420 --> 00:25:58,320
algorithms because there are lots of

00:25:55,920 --> 00:26:00,090
places where you can look that up if

00:25:58,320 --> 00:26:03,330
you're if you're curious about the names

00:26:00,090 --> 00:26:05,640
we did not invent these names they come

00:26:03,330 --> 00:26:08,010
from the standard literature except

00:26:05,640 --> 00:26:09,450
Boothby which I had to invent because I

00:26:08,010 --> 00:26:13,530
didn't know how else to say this is

00:26:09,450 --> 00:26:15,960
coops algorithm beam from his book okay

00:26:13,530 --> 00:26:18,360
I mean I think that's kind of an obvious

00:26:15,960 --> 00:26:22,410
thing but all the rest come from various

00:26:18,360 --> 00:26:25,400
places in the literature okay and some

00:26:22,410 --> 00:26:30,470
are 64-bit some are 32-bit etc etc so

00:26:25,400 --> 00:26:33,390
why did we pick those nine algorithms

00:26:30,470 --> 00:26:37,290
because we didn't want to innovate and

00:26:33,390 --> 00:26:39,870
those nine algorithms are

00:26:37,290 --> 00:26:42,350
really well known they have reasonable

00:26:39,870 --> 00:26:45,620
quality they have widely different

00:26:42,350 --> 00:26:48,690
characteristics linear congressional

00:26:45,620 --> 00:26:51,720
algorithms for example are typically

00:26:48,690 --> 00:26:53,160
very small and very fast but they don't

00:26:51,720 --> 00:26:56,730
give you the greatest quality of

00:26:53,160 --> 00:26:59,490
randomness on the other hand if you want

00:26:56,730 --> 00:27:03,680
quality Mersenne twister is what you

00:26:59,490 --> 00:27:07,950
want it comes in both 32 and 64-bit

00:27:03,680 --> 00:27:10,020
variations but the price you pay is it's

00:27:07,950 --> 00:27:12,480
not nearly as fast and perhaps in some

00:27:10,020 --> 00:27:15,960
applications more importantly it's 600

00:27:12,480 --> 00:27:18,210
times bigger okay it has a lot of state

00:27:15,960 --> 00:27:21,210
that's how it gets the quality so there

00:27:18,210 --> 00:27:23,310
are trade-offs to be made novices

00:27:21,210 --> 00:27:26,340
generally don't care so they just used

00:27:23,310 --> 00:27:27,810
the the default random engine but once

00:27:26,340 --> 00:27:29,880
you get into more sophisticated

00:27:27,810 --> 00:27:32,970
applications you may very well care a

00:27:29,880 --> 00:27:34,620
great deal I'm gonna collect questions

00:27:32,970 --> 00:27:35,880
at the end if you don't mind because

00:27:34,620 --> 00:27:39,840
otherwise I'm gonna run out of time I

00:27:35,880 --> 00:27:43,830
was right now you should know that these

00:27:39,840 --> 00:27:48,080
engines are actually aliases for

00:27:43,830 --> 00:27:50,760
templates that are also in the header

00:27:48,080 --> 00:27:54,870
hardly anybody should muck around with

00:27:50,760 --> 00:27:58,560
those templates unless you're an expert

00:27:54,870 --> 00:28:01,230
because it turns out I mean you can tune

00:27:58,560 --> 00:28:03,450
these templates as much as you like they

00:28:01,230 --> 00:28:07,880
all have knobs typically template

00:28:03,450 --> 00:28:10,500
parameters but very few combinations

00:28:07,880 --> 00:28:12,810
comparatively give you anything

00:28:10,500 --> 00:28:15,600
approaching decent quality by we have

00:28:12,810 --> 00:28:20,220
output coming up with a new engine is

00:28:15,600 --> 00:28:22,440
hard work and computer scientists are

00:28:20,220 --> 00:28:25,440
typically not the best people to do that

00:28:22,440 --> 00:28:28,320
but you want our mathematicians and

00:28:25,440 --> 00:28:30,510
statisticians and so forth okay

00:28:28,320 --> 00:28:34,650
we did you know this different training

00:28:30,510 --> 00:28:36,690
that goes into that so it's okay to know

00:28:34,650 --> 00:28:38,580
that these are there but I doubt that

00:28:36,690 --> 00:28:41,280
many of us in the room or listening to

00:28:38,580 --> 00:28:42,720
this on video later really are

00:28:41,280 --> 00:28:45,960
interested in those templates but you

00:28:42,720 --> 00:28:47,910
should know that they're there I told

00:28:45,960 --> 00:28:49,380
you that engines can actually do more

00:28:47,910 --> 00:28:50,530
here are some of the additional things

00:28:49,380 --> 00:28:52,960
that an engine

00:28:50,530 --> 00:28:54,180
do some of these are more useful than

00:28:52,960 --> 00:28:57,010
others

00:28:54,180 --> 00:28:58,570
engines are streamable in case you want

00:28:57,010 --> 00:29:00,010
to interrupt the calculation and then

00:28:58,570 --> 00:29:01,060
restore and come back and pick it up

00:29:00,010 --> 00:29:04,570
where you left off

00:29:01,060 --> 00:29:06,220
that's useful reproducibility as I said

00:29:04,570 --> 00:29:08,550
earlier is very important in certain

00:29:06,220 --> 00:29:11,380
applications let's do it again

00:29:08,550 --> 00:29:16,000
so you may need to store and then you

00:29:11,380 --> 00:29:18,910
know restart engines can be compared if

00:29:16,000 --> 00:29:20,440
they're of the same type two engines

00:29:18,910 --> 00:29:22,360
compare equal if they're gonna give you

00:29:20,440 --> 00:29:24,940
the same outputs from that point forward

00:29:22,360 --> 00:29:28,720
and of course you can therefore compare

00:29:24,940 --> 00:29:31,210
for in equality as well engines can be

00:29:28,720 --> 00:29:34,180
initialized and the the correct term is

00:29:31,210 --> 00:29:37,090
ceded in more ways that I'm going to

00:29:34,180 --> 00:29:39,850
show you during this talk some are

00:29:37,090 --> 00:29:42,760
better than others engines have member

00:29:39,850 --> 00:29:46,960
functions named this card because some

00:29:42,760 --> 00:29:48,370
people really want to well the most

00:29:46,960 --> 00:29:51,460
common thing people want to do is I've

00:29:48,370 --> 00:29:53,410
initialized this but I really wanted to

00:29:51,460 --> 00:29:54,910
to run through the first thousand our

00:29:53,410 --> 00:29:57,820
first million before I would start to

00:29:54,910 --> 00:30:00,220
use the results so just throw away the

00:29:57,820 --> 00:30:02,350
first thousand that you generate you do

00:30:00,220 --> 00:30:04,120
that I call them discard some engines

00:30:02,350 --> 00:30:06,760
can do this far more efficiently than

00:30:04,120 --> 00:30:08,950
others that's why the member function is

00:30:06,760 --> 00:30:13,240
there it does it in the manner best

00:30:08,950 --> 00:30:16,030
suited to the engine it turns out that

00:30:13,240 --> 00:30:22,150
distributions don't need any of those

00:30:16,030 --> 00:30:25,720
extras and so we actually in the

00:30:22,150 --> 00:30:27,430
standard have a two-tier approach I've

00:30:25,720 --> 00:30:31,330
only told you about engines that's

00:30:27,430 --> 00:30:34,470
actually the second tier if you bundle

00:30:31,330 --> 00:30:37,690
up the requirements that a distribution

00:30:34,470 --> 00:30:40,390
imposes what you have is something that

00:30:37,690 --> 00:30:42,190
we now refer to as a you are BG we

00:30:40,390 --> 00:30:46,990
change the nomenclature very slightly

00:30:42,190 --> 00:30:51,730
for c++ 17 a uniform random bits

00:30:46,990 --> 00:30:54,460
generator it's the only thing you should

00:30:51,730 --> 00:30:57,250
ever use one of these things for is as a

00:30:54,460 --> 00:31:01,480
source of uniformly distributed random

00:30:57,250 --> 00:31:03,700
bits and as I say

00:31:01,480 --> 00:31:06,160
take it pass it around to some consumer

00:31:03,700 --> 00:31:10,660
of those bits and then you use the

00:31:06,160 --> 00:31:14,260
result of what that entity gives you now

00:31:10,660 --> 00:31:16,929
if you have it you are BG that also has

00:31:14,260 --> 00:31:18,630
all these other extra capabilities such

00:31:16,929 --> 00:31:22,179
as streaming and so forth

00:31:18,630 --> 00:31:27,240
the nomenclature now is engine so engine

00:31:22,179 --> 00:31:29,710
is a strict superset of you are BG okay

00:31:27,240 --> 00:31:31,390
it's important to know the distinction

00:31:29,710 --> 00:31:34,150
because there is something in the

00:31:31,390 --> 00:31:40,360
standard that is a you are VG and not

00:31:34,150 --> 00:31:45,400
also an engine okay it's called random

00:31:40,360 --> 00:31:49,720
device and what it is designed to be is

00:31:45,400 --> 00:31:54,010
a standard interface to something that

00:31:49,720 --> 00:31:55,809
is not standard if you have access to an

00:31:54,010 --> 00:31:58,780
environmental sometimes called a

00:31:55,809 --> 00:32:02,049
physical source of randomness for

00:31:58,780 --> 00:32:03,490
example dev random or dev you random

00:32:02,049 --> 00:32:06,100
depending on whether you care about

00:32:03,490 --> 00:32:07,990
blocking or if you have access to a

00:32:06,100 --> 00:32:11,049
device for example the samples

00:32:07,990 --> 00:32:13,679
atmospheric noise I can transform that

00:32:11,049 --> 00:32:16,450
into zeros and ones for you

00:32:13,679 --> 00:32:19,179
this is a standard interface to such

00:32:16,450 --> 00:32:22,320
things now by its nature

00:32:19,179 --> 00:32:26,530
we can't supply much of the body of this

00:32:22,320 --> 00:32:31,690
it's an interface in particular and the

00:32:26,530 --> 00:32:36,340
way you use it is implementation defined

00:32:31,690 --> 00:32:38,169
your implementation has to specify how

00:32:36,340 --> 00:32:40,210
you gain access to it and what we've

00:32:38,169 --> 00:32:43,270
said is there's a constructor that takes

00:32:40,210 --> 00:32:48,270
a string I mean you may have multiple

00:32:43,270 --> 00:32:50,860
sources of randomness right so

00:32:48,270 --> 00:32:52,990
user-defined string SR implementation to

00:32:50,860 --> 00:32:55,120
find string lets you choose among them

00:32:52,990 --> 00:32:57,580
for example dev random versus dev you

00:32:55,120 --> 00:33:00,030
random you may have access to both etc

00:32:57,580 --> 00:33:00,030
etc okay

00:33:01,080 --> 00:33:06,480
interestingly there is also member

00:33:02,880 --> 00:33:08,760
function here named entropy designed to

00:33:06,480 --> 00:33:13,110
give you an estimate of well guess what

00:33:08,760 --> 00:33:14,220
the entropy of your device so if you

00:33:13,110 --> 00:33:16,020
haven't seen it before that's the

00:33:14,220 --> 00:33:18,600
definition of entropy there's actually

00:33:16,020 --> 00:33:20,340
somebody in Europe whose headstone on

00:33:18,600 --> 00:33:23,730
his grave

00:33:20,340 --> 00:33:25,890
has a version of this formula you can

00:33:23,730 --> 00:33:29,790
find it in the slides if you download

00:33:25,890 --> 00:33:31,230
them but please understand if you call

00:33:29,790 --> 00:33:34,230
on this function you're getting an

00:33:31,230 --> 00:33:36,510
estimate because sometimes getting it

00:33:34,230 --> 00:33:39,810
exactly right is incredibly hard to do

00:33:36,510 --> 00:33:44,310
depending on your source of entropy okay

00:33:39,810 --> 00:33:45,720
which means effectively it is possible

00:33:44,310 --> 00:33:48,990
that when you call this function you're

00:33:45,720 --> 00:33:50,910
being lied to so don't rely on it too

00:33:48,990 --> 00:33:52,710
heavily there are some vendors who

00:33:50,910 --> 00:33:55,680
supply this and you call entropy and

00:33:52,710 --> 00:33:58,740
you're always going to get zero okay so

00:33:55,680 --> 00:34:02,550
don't take it too seriously but you know

00:33:58,740 --> 00:34:04,730
you can ask your vendor to do better um

00:34:02,550 --> 00:34:08,460
it is interesting as a historical note

00:34:04,730 --> 00:34:11,010
that way back in 1951 according to Don

00:34:08,460 --> 00:34:13,380
Knuth there was a machine called the

00:34:11,010 --> 00:34:16,440
Ferranti mark one that had a built-in

00:34:13,380 --> 00:34:19,350
instruction that gave you twenty random

00:34:16,440 --> 00:34:21,300
bits into its accumulator using a

00:34:19,350 --> 00:34:23,640
circuit called a resistance noise

00:34:21,300 --> 00:34:27,150
generator and that that feature had been

00:34:23,640 --> 00:34:27,690
requested by Alan Turing himself I just

00:34:27,150 --> 00:34:30,960
thought that was an interesting

00:34:27,690 --> 00:34:32,970
historical note in case you haven't

00:34:30,960 --> 00:34:34,980
looked into this I'm just letting you

00:34:32,970 --> 00:34:38,280
know I'm not chilling for anybody here

00:34:34,980 --> 00:34:40,560
but there are commercial sources of such

00:34:38,280 --> 00:34:43,260
devices and they're relatively

00:34:40,560 --> 00:34:46,320
inexpensive these days they come with

00:34:43,260 --> 00:34:47,700
various kinds of interfaces USB

00:34:46,320 --> 00:34:50,880
interfaces or you know it looks like a

00:34:47,700 --> 00:34:53,520
stick PCI boards etcetera etcetera and

00:34:50,880 --> 00:34:57,420
recent CPUs support hardware

00:34:53,520 --> 00:34:59,000
instructions to do to do random related

00:34:57,420 --> 00:35:02,310
things

00:34:59,000 --> 00:35:05,880
there are also some online services that

00:35:02,310 --> 00:35:07,920
are free I haven't done this but based

00:35:05,880 --> 00:35:10,530
on what I've looked at which was a just

00:35:07,920 --> 00:35:14,170
a couple months ago it should be fairly

00:35:10,530 --> 00:35:17,340
straightforward to put together a

00:35:14,170 --> 00:35:20,770
an interface that that will grab numbers

00:35:17,340 --> 00:35:24,460
online and if that's good enough for

00:35:20,770 --> 00:35:26,890
what you need please feel free but one

00:35:24,460 --> 00:35:31,240
word of caution be careful about your

00:35:26,890 --> 00:35:34,620
online service okay III wouldn't rely on

00:35:31,240 --> 00:35:38,010
psychic services for random numbers okay

00:35:34,620 --> 00:35:40,360
but they'll happily give you numbers

00:35:38,010 --> 00:35:43,540
okay

00:35:40,360 --> 00:35:46,060
I've told you all about all the engines

00:35:43,540 --> 00:35:47,440
in the standard library let me tell you

00:35:46,060 --> 00:35:50,500
a little bit about the distributions

00:35:47,440 --> 00:35:52,660
there are 20 of them that we categorize

00:35:50,500 --> 00:35:55,390
them in five families two of them or the

00:35:52,660 --> 00:35:58,630
uniform distributions one for int one

00:35:55,390 --> 00:36:00,280
for floating-point no one is real four

00:35:58,630 --> 00:36:02,560
of them are classified as Bernoulli

00:36:00,280 --> 00:36:05,020
distributions five of them of croissant

00:36:02,560 --> 00:36:08,110
distributions six of them are normal

00:36:05,020 --> 00:36:10,720
distributions three of them we classify

00:36:08,110 --> 00:36:12,400
as sampling distributions again this is

00:36:10,720 --> 00:36:14,230
not a tutorial and what the differences

00:36:12,400 --> 00:36:16,180
are among them this is something you

00:36:14,230 --> 00:36:21,310
need to know for your application you

00:36:16,180 --> 00:36:24,220
don't go find a statistician okay it's a

00:36:21,310 --> 00:36:27,550
fair question to ask why these and not

00:36:24,220 --> 00:36:30,370
others and by others I mean there are

00:36:27,550 --> 00:36:31,540
hundreds of others maybe thousands I

00:36:30,370 --> 00:36:34,300
haven't done count

00:36:31,540 --> 00:36:36,460
they really are so we wrote a paper I

00:36:34,300 --> 00:36:38,650
think the author was actually one of my

00:36:36,460 --> 00:36:41,860
then colleagues but I contributed

00:36:38,650 --> 00:36:43,690
heavily to it way back in 2004 things

00:36:41,860 --> 00:36:47,740
have changed a little bit since then

00:36:43,690 --> 00:36:49,690
this was long before C++ 11 but the

00:36:47,740 --> 00:36:51,340
fundamental rationale is in that paper

00:36:49,690 --> 00:36:56,140
if you're interested please do feel free

00:36:51,340 --> 00:36:58,000
to have a look at that now I've already

00:36:56,140 --> 00:37:00,310
told you that the standard distribution

00:36:58,000 --> 00:37:02,920
is by and large with one exception or

00:37:00,310 --> 00:37:06,460
class templates and the template

00:37:02,920 --> 00:37:11,130
parameter is the type that you want when

00:37:06,460 --> 00:37:14,940
you call upon the distribution some

00:37:11,130 --> 00:37:17,290
distributions are integer types only

00:37:14,940 --> 00:37:21,040
most of the rest are floating-point

00:37:17,290 --> 00:37:24,250
types only and one the Bernoulli

00:37:21,040 --> 00:37:26,140
distribution is bool only and it's not a

00:37:24,250 --> 00:37:26,870
template therefore there's no choice

00:37:26,140 --> 00:37:32,330
you're going to get

00:37:26,870 --> 00:37:35,390
Buhl okay I told you a little bit ago

00:37:32,330 --> 00:37:38,600
that the standard engines are bit 4-bit

00:37:35,390 --> 00:37:45,860
portable with the one exception that is

00:37:38,600 --> 00:37:49,130
not true for distributions we do not

00:37:45,860 --> 00:37:53,030
specify the algorithm by which a

00:37:49,130 --> 00:37:56,870
distribution gives you a variate your

00:37:53,030 --> 00:37:59,180
vendor gets to choose and there are lots

00:37:56,870 --> 00:38:01,970
of choices that can be made there are

00:37:59,180 --> 00:38:05,240
literally not just dozens but hundreds

00:38:01,970 --> 00:38:06,770
of algorithms for almost any possible

00:38:05,240 --> 00:38:10,250
distributions of course the better-known

00:38:06,770 --> 00:38:13,820
distributions have more options and if

00:38:10,250 --> 00:38:17,390
you look into this don't just look up a

00:38:13,820 --> 00:38:20,270
particular algorithm go to that journal

00:38:17,390 --> 00:38:28,430
and make sure there aren't Corrections

00:38:20,270 --> 00:38:30,050
in later issues please do that if you're

00:38:28,430 --> 00:38:32,600
gonna implement your own distribution

00:38:30,050 --> 00:38:35,890
based on our article make sure it hasn't

00:38:32,600 --> 00:38:39,590
been corrected it would be astonished

00:38:35,890 --> 00:38:42,440
astonished at how many times corrections

00:38:39,590 --> 00:38:45,590
to ostensibly correct algorithms have

00:38:42,440 --> 00:38:48,320
been published in the literature okay

00:38:45,590 --> 00:38:50,480
but the reason we didn't nail it down is

00:38:48,320 --> 00:38:52,150
we wanted to give implementers the

00:38:50,480 --> 00:38:54,620
freedom to make these kinds of choices

00:38:52,150 --> 00:39:00,980
based on what they know of their target

00:38:54,620 --> 00:39:04,760
platforms okay I would like to stress in

00:39:00,980 --> 00:39:08,510
particular that one of the very very

00:39:04,760 --> 00:39:12,650
strong features of the facilities in

00:39:08,510 --> 00:39:17,360
this header is interoperability and

00:39:12,650 --> 00:39:21,560
extensibility just within the header any

00:39:17,360 --> 00:39:25,160
engine type that you choose to use will

00:39:21,560 --> 00:39:30,950
work with any distribution type you

00:39:25,160 --> 00:39:34,970
choose to use and if you or a colleague

00:39:30,950 --> 00:39:37,520
or some other source provides more

00:39:34,970 --> 00:39:40,000
whether it's engines or distributions if

00:39:37,520 --> 00:39:42,369
you adhere to the published interface

00:39:40,000 --> 00:39:46,510
in the standard the requirements so to

00:39:42,369 --> 00:39:50,800
speak it's going to work and we have

00:39:46,510 --> 00:39:52,900
evidence that this in fact happens you

00:39:50,800 --> 00:39:54,880
are allowed to provide your own you

00:39:52,900 --> 00:39:57,190
RBG's or engines if you want to go to

00:39:54,880 --> 00:40:00,940
the extra trouble your own distributions

00:39:57,190 --> 00:40:02,740
and it will seamlessly interoperate if

00:40:00,940 --> 00:40:04,450
you write your own engine you can use it

00:40:02,740 --> 00:40:05,890
with a standard distribution you write

00:40:04,450 --> 00:40:07,720
your own distribution you can use it

00:40:05,890 --> 00:40:13,950
with a standard engine of your choice or

00:40:07,720 --> 00:40:16,869
if you write both it should just work

00:40:13,950 --> 00:40:17,260
and we have as I say we have evidence of

00:40:16,869 --> 00:40:20,470
this

00:40:17,260 --> 00:40:23,200
in particular pointed to moderately

00:40:20,470 --> 00:40:27,130
recent developments there's a new engine

00:40:23,200 --> 00:40:29,680
called PC G by Melissa O'Neil fairly

00:40:27,130 --> 00:40:32,290
recent there's another one that's just a

00:40:29,680 --> 00:40:34,869
little bit older a random 1-2-3 bhaijaan

00:40:32,290 --> 00:40:37,540
Salman and his colleagues you're welcome

00:40:34,869 --> 00:40:40,450
to look those up we're thinking about

00:40:37,540 --> 00:40:43,680
putting them in the standard someday but

00:40:40,450 --> 00:40:49,510
they haven't been around long enough to

00:40:43,680 --> 00:40:51,099
build up a body of trust so to speak so

00:40:49,510 --> 00:40:53,410
if it goes on the standard in some sense

00:40:51,099 --> 00:40:55,390
we're recommending it we're just not

00:40:53,410 --> 00:40:57,160
ready to do that yet we have reason to

00:40:55,390 --> 00:40:59,859
believe that these are good quality but

00:40:57,160 --> 00:41:02,020
we're just not sure just haven't had

00:40:59,859 --> 00:41:05,440
enough experience with them and then if

00:41:02,020 --> 00:41:08,020
you're a DCC user as I am you may

00:41:05,440 --> 00:41:11,109
already know the DCC ships with about a

00:41:08,020 --> 00:41:12,700
dozen additional distributions that you

00:41:11,109 --> 00:41:15,160
know one or more people have contributed

00:41:12,700 --> 00:41:16,720
last time I look this is what I found

00:41:15,160 --> 00:41:21,359
there might be more by now for all I

00:41:16,720 --> 00:41:23,800
know and they just Interop it just works

00:41:21,359 --> 00:41:26,109
ok so if you have a need for one of

00:41:23,800 --> 00:41:29,560
these GCC who let you have it

00:41:26,109 --> 00:41:35,200
I can't speak for any other vendor but

00:41:29,560 --> 00:41:36,580
you know it should work if you are one

00:41:35,200 --> 00:41:38,080
of the few people in the world who

00:41:36,580 --> 00:41:42,190
actually is interested in writing your

00:41:38,080 --> 00:41:44,830
own distribution as I say there's one

00:41:42,190 --> 00:41:49,359
tool in the header that you might want

00:41:44,830 --> 00:41:53,560
to use it's named generate canonical it

00:41:49,359 --> 00:41:56,590
takes aur BG and calls that

00:41:53,560 --> 00:41:59,560
as often as necessary to get as many

00:41:56,590 --> 00:42:03,670
bits right it's a source of randomness

00:41:59,560 --> 00:42:06,880
so get as many bits as it needs and then

00:42:03,670 --> 00:42:10,410
maps those bits as uniformly as possible

00:42:06,880 --> 00:42:11,620
to the real type range of your choice

00:42:10,410 --> 00:42:14,830
all right

00:42:11,620 --> 00:42:17,530
and of course here it's half open the

00:42:14,830 --> 00:42:19,330
zero is included one is excluded and

00:42:17,530 --> 00:42:21,070
there are very good reasons for that I

00:42:19,330 --> 00:42:24,730
keep getting asked for those for that

00:42:21,070 --> 00:42:27,220
you know why are integers inclusive and

00:42:24,730 --> 00:42:29,530
reals or or half open there are very

00:42:27,220 --> 00:42:31,060
good reasons for those decisions we can

00:42:29,530 --> 00:42:35,560
talk about that some other time if you

00:42:31,060 --> 00:42:39,160
would like it is described in the

00:42:35,560 --> 00:42:41,830
standard as it is often a useful step in

00:42:39,160 --> 00:42:44,980
the process of transforming a value from

00:42:41,830 --> 00:42:47,170
a u RBG into a value that a distribution

00:42:44,980 --> 00:42:52,540
can deliver to the client and was

00:42:47,170 --> 00:42:54,670
getting a variate okay all right so I

00:42:52,540 --> 00:42:58,930
promised to share with you the

00:42:54,670 --> 00:43:03,220
anti-pattern right code from hell as we

00:42:58,930 --> 00:43:05,650
informally refer to it please don't do

00:43:03,220 --> 00:43:09,100
what I'm going to show you what's

00:43:05,650 --> 00:43:11,340
important is not the fact that it's bad

00:43:09,100 --> 00:43:15,070
code even though it looks innocuous

00:43:11,340 --> 00:43:16,840
what's important is that I mean as

00:43:15,070 --> 00:43:18,160
professionals you know this but I'm

00:43:16,840 --> 00:43:21,550
gonna give you sort of an extreme

00:43:18,160 --> 00:43:24,820
example you don't know where your code

00:43:21,550 --> 00:43:27,640
is going to end up in a 1 year 5 years

00:43:24,820 --> 00:43:30,900
10 years 20 years you may write code

00:43:27,640 --> 00:43:34,960
today and in 15 years it may end up as

00:43:30,900 --> 00:43:37,120
part of a code base that runs an x-ray

00:43:34,960 --> 00:43:40,830
machine delivering treatment to a

00:43:37,120 --> 00:43:43,570
patient get it right

00:43:40,830 --> 00:43:45,730
you don't know where copy and paste will

00:43:43,570 --> 00:43:50,400
end up with your codes we'll send your

00:43:45,730 --> 00:43:53,380
code I wrote a library in 1998-1999

00:43:50,400 --> 00:43:55,540
two years later I got an email from a

00:43:53,380 --> 00:43:57,160
national laboratory saying we found your

00:43:55,540 --> 00:43:59,050
library we really liked it we're gonna

00:43:57,160 --> 00:44:03,070
put it on the on the on the rocket to

00:43:59,050 --> 00:44:06,489
Mars I should not write my library to

00:44:03,070 --> 00:44:09,349
run on Mars but I'm told it is

00:44:06,489 --> 00:44:15,069
trust me you never know when your code

00:44:09,349 --> 00:44:15,069
is going to end up okay I'm sorry

00:44:15,640 --> 00:44:38,269
I got it right okay I'm serious get it

00:44:34,309 --> 00:44:42,289
right the key here is we deal with

00:44:38,269 --> 00:44:47,239
random numbers you have to avoid bias

00:44:42,289 --> 00:44:49,039
and that's not a vocabulary term in the

00:44:47,239 --> 00:44:50,019
usual undergraduate computing

00:44:49,039 --> 00:44:56,380
curriculums

00:44:50,019 --> 00:45:10,729
okay as usual xkcd gets the last word an

00:44:56,380 --> 00:45:13,719
an random generator there's no such

00:45:10,729 --> 00:45:16,549
thing as getting the software almost

00:45:13,719 --> 00:45:19,549
right okay

00:45:16,549 --> 00:45:22,400
so let's look at the bad code don't do

00:45:19,549 --> 00:45:24,849
this I'm just going to do it very simply

00:45:22,400 --> 00:45:28,099
we're gonna mimic the role of a fair die

00:45:24,849 --> 00:45:30,589
call your engine whatever number it

00:45:28,099 --> 00:45:33,380
gives you take the remainder after

00:45:30,589 --> 00:45:36,349
dividing by 6 that's going to be in the

00:45:33,380 --> 00:45:39,559
range 0 through 5 so add 1 now you get 1

00:45:36,349 --> 00:45:45,949
through 6 wonderful way to roll a die

00:45:39,559 --> 00:45:46,909
right no this is wrong good this is

00:45:45,949 --> 00:45:49,249
wrong

00:45:46,909 --> 00:45:54,380
it is so innocuous how could it possibly

00:45:49,249 --> 00:45:55,849
be wrong and yet it's horrible you don't

00:45:54,380 --> 00:46:00,799
have to believe me I'm gonna give you

00:45:55,849 --> 00:46:02,449
other quotations I'm you know so it

00:46:00,799 --> 00:46:03,909
turns out there are actually two things

00:46:02,449 --> 00:46:07,849
wrong with it

00:46:03,909 --> 00:46:11,179
I'll classify the first as a relatively

00:46:07,849 --> 00:46:14,419
minor potentially serious but typically

00:46:11,179 --> 00:46:16,729
not and the second one is major okay so

00:46:14,419 --> 00:46:18,380
what's the minor issue the minor issue

00:46:16,729 --> 00:46:19,940
is that there's an assumption in this

00:46:18,380 --> 00:46:24,260
code and you don't know

00:46:19,940 --> 00:46:26,360
it's true or not what's the assumption

00:46:24,260 --> 00:46:33,200
the assumption is that your engine gives

00:46:26,360 --> 00:46:37,540
you at least enough bits if your engine

00:46:33,200 --> 00:46:41,030
gives you one bit per call

00:46:37,540 --> 00:46:44,930
you're never gonna roll other than one

00:46:41,030 --> 00:46:47,000
or two are you you think that's fair if

00:46:44,930 --> 00:46:50,540
your engine gives you two bits

00:46:47,000 --> 00:46:52,520
you'll never roll a five or a six now I

00:46:50,540 --> 00:46:55,090
grant you that's unlikely

00:46:52,520 --> 00:46:58,340
that's why I call this a minor problem

00:46:55,090 --> 00:47:00,830
but you know you may not control the

00:46:58,340 --> 00:47:02,660
engine somebody may be handing you an

00:47:00,830 --> 00:47:05,140
engine so you know you're making an

00:47:02,660 --> 00:47:11,540
assumption so it looks documented okay

00:47:05,140 --> 00:47:15,200
here's the major issue typically n is an

00:47:11,540 --> 00:47:18,890
integer and therefore when you call the

00:47:15,200 --> 00:47:23,120
engine you can get any one of two to the

00:47:18,890 --> 00:47:25,010
nth different results there is no value

00:47:23,120 --> 00:47:27,970
of two of the ends that's evenly

00:47:25,010 --> 00:47:27,970
divisible by six

00:47:28,750 --> 00:47:37,580
I'm sorry three is not a factor of two

00:47:31,880 --> 00:47:40,430
to the nth right I mean I think you've

00:47:37,580 --> 00:47:42,670
known this for a long time right I sure

00:47:40,430 --> 00:47:42,670
hope so

00:47:43,570 --> 00:47:48,230
now one of our good friends and

00:47:45,800 --> 00:47:51,610
colleagues has said it's somewhat more

00:47:48,230 --> 00:47:54,520
strongly than I have so I'm gonna quote

00:47:51,610 --> 00:47:59,780
first thing he says this is really awful

00:47:54,520 --> 00:48:02,660
and then he went ahead and found a

00:47:59,780 --> 00:48:06,410
similar piece of code that I don't want

00:48:02,660 --> 00:48:09,590
to reproduce today but obviously someone

00:48:06,410 --> 00:48:12,410
had recognized the issue and said oh but

00:48:09,590 --> 00:48:18,290
I can program around this let me use

00:48:12,410 --> 00:48:20,320
floating-point heaven help us which our

00:48:18,290 --> 00:48:23,810
colleague says is hilariously

00:48:20,320 --> 00:48:26,450
non-uniform love that phrase hilariously

00:48:23,810 --> 00:48:28,610
non-uniform and then he goes ahead and

00:48:26,450 --> 00:48:30,830
he explains it in his inimitable style

00:48:28,610 --> 00:48:32,770
it's the pigeonhole principle if you've

00:48:30,830 --> 00:48:33,890
got two to the thirty second pigeons you

00:48:32,770 --> 00:48:36,230
can

00:48:33,890 --> 00:48:38,750
distribute them into six pigeonholes

00:48:36,230 --> 00:48:42,140
without putting some more pigeons in one

00:48:38,750 --> 00:48:43,700
hole than others and of course this is

00:48:42,140 --> 00:48:44,620
our friend SPL who's here at this

00:48:43,700 --> 00:48:51,610
conference

00:48:44,620 --> 00:48:54,680
Stefan wobbly so you know don't do this

00:48:51,610 --> 00:48:58,130
one of the problems though is that it

00:48:54,680 --> 00:49:01,610
seems to work remember one of the early

00:48:58,130 --> 00:49:05,530
things I said it's hard to recognize

00:49:01,610 --> 00:49:12,380
when you do or don't have randomness

00:49:05,530 --> 00:49:14,810
right if somebody does this and it's

00:49:12,380 --> 00:49:18,860
been done thousands of times in the last

00:49:14,810 --> 00:49:20,780
50 years they're going to be rewarded

00:49:18,860 --> 00:49:23,210
with something that looks random and

00:49:20,780 --> 00:49:25,700
they're going to be incredibly excited

00:49:23,210 --> 00:49:29,480
that they're clever solution really

00:49:25,700 --> 00:49:31,940
worked but it doesn't work when you

00:49:29,480 --> 00:49:35,180
force the range it eliminates any chance

00:49:31,940 --> 00:49:38,420
of having a uniform distribution this is

00:49:35,180 --> 00:49:42,170
unfair and the technical word for that

00:49:38,420 --> 00:49:46,940
is biased if you have a bias of any sort

00:49:42,170 --> 00:49:49,070
you are being unfair right and to be

00:49:46,940 --> 00:49:54,410
correct you have to work with the

00:49:49,070 --> 00:49:56,000
distribution and not destroy it which

00:49:54,410 --> 00:50:02,120
means you have to understand what

00:49:56,000 --> 00:50:04,430
uniformity means and respect it now are

00:50:02,120 --> 00:50:08,480
we going to get a concept that describes

00:50:04,430 --> 00:50:11,990
that I don't know we'll find out

00:50:08,480 --> 00:50:14,360
so my plea to you who are listening

00:50:11,990 --> 00:50:18,980
today and in the future let's avoid

00:50:14,360 --> 00:50:22,270
bigotry and programming please okay so

00:50:18,980 --> 00:50:22,270
how do you do it right

00:50:28,069 --> 00:50:35,119
that's be virtuous so let me just sneak

00:50:31,710 --> 00:50:37,710
up on this by example suppose I want a

00:50:35,119 --> 00:50:41,880
variant an integer very attuned the

00:50:37,710 --> 00:50:45,359
range one through five at home what

00:50:41,880 --> 00:50:48,119
would I do I grab a fair guy and I'd

00:50:45,359 --> 00:50:49,740
roll it and take whatever he gives me

00:50:48,119 --> 00:50:52,530
unless it happens to give me a six in

00:50:49,740 --> 00:50:55,440
which case I roll again all right until

00:50:52,530 --> 00:51:00,240
I don't get a six but and that's you

00:50:55,440 --> 00:51:04,290
know there's the code now I'm not aware

00:51:00,240 --> 00:51:06,300
of many curricula that teach categories

00:51:04,290 --> 00:51:09,510
of algorithms called rejection

00:51:06,300 --> 00:51:12,300
algorithms but it is a classification

00:51:09,510 --> 00:51:13,069
for algorithms right where you do the

00:51:12,300 --> 00:51:15,720
work

00:51:13,069 --> 00:51:21,240
see if you like the answer and if not

00:51:15,720 --> 00:51:23,930
reject it and do it again okay so let's

00:51:21,240 --> 00:51:26,190
take this and just slightly tweak it

00:51:23,930 --> 00:51:28,020
suppose I don't know it it's gonna be

00:51:26,190 --> 00:51:31,640
one to five let's say I've got some

00:51:28,020 --> 00:51:35,430
lower and some upper bound low and high

00:51:31,640 --> 00:51:38,359
then here's sort of the obvious I've

00:51:35,430 --> 00:51:40,980
labeled it naive way to do rejection

00:51:38,359 --> 00:51:42,660
call the engine which you already know

00:51:40,980 --> 00:51:45,300
is the wrong thing to do good call the

00:51:42,660 --> 00:51:48,089
engine and if what you get isn't within

00:51:45,300 --> 00:51:51,390
the range you wanted reject and go back

00:51:48,089 --> 00:51:53,910
and do it again right oh there's so many

00:51:51,390 --> 00:51:56,550
things wrong with this I'm just gonna

00:51:53,910 --> 00:51:57,869
give you a small tiny sample of the

00:51:56,550 --> 00:52:00,619
things you haven't thought about that we

00:51:57,869 --> 00:52:03,240
haven't thought about yet you may have

00:52:00,619 --> 00:52:08,250
what if your engine doesn't give you all

00:52:03,240 --> 00:52:10,589
the numbers and lo through high what if

00:52:08,250 --> 00:52:12,089
gives you some of them but not all but

00:52:10,589 --> 00:52:14,490
it gives you number of none of them we

00:52:12,089 --> 00:52:15,810
have an infinite loop you're going to

00:52:14,490 --> 00:52:18,869
reject forever you're never getting it's

00:52:15,810 --> 00:52:21,780
something you like and what about the

00:52:18,869 --> 00:52:25,109
performance all right what if he gives

00:52:21,780 --> 00:52:27,150
you numbers from a very very large range

00:52:25,109 --> 00:52:28,980
much larger than the one you care about

00:52:27,150 --> 00:52:35,880
you're going to spend most of your time

00:52:28,980 --> 00:52:39,000
rejecting okay etc etc etc I deal and in

00:52:35,880 --> 00:52:40,510
the final analysis when you go through

00:52:39,000 --> 00:52:42,700
this exercise you're

00:52:40,510 --> 00:52:45,880
inventing by the time you're gone if you

00:52:42,700 --> 00:52:48,550
do it right you're reinventing standard

00:52:45,880 --> 00:52:50,650
the standards uniform into distribution

00:52:48,550 --> 00:52:53,920
which of course is already part of the

00:52:50,650 --> 00:52:56,140
header so there's no need to do this

00:52:53,920 --> 00:52:59,560
exercise except for academic reasons

00:52:56,140 --> 00:53:04,030
perhaps I mean if you're interested in

00:52:59,560 --> 00:53:06,970
the algorithms fine okay but not for

00:53:04,030 --> 00:53:13,180
production purposes okay

00:53:06,970 --> 00:53:15,070
I mean there's a certain there's a

00:53:13,180 --> 00:53:18,610
certain level of arrogance in our

00:53:15,070 --> 00:53:20,410
profession you know you find the same

00:53:18,610 --> 00:53:22,960
sort of thing and lots of professions

00:53:20,410 --> 00:53:24,730
like surgeons for example you have to be

00:53:22,960 --> 00:53:29,470
sort of ultimately confident in your

00:53:24,730 --> 00:53:34,750
abilities to get the job done but a good

00:53:29,470 --> 00:53:39,660
surgeon knows when not to cut a good

00:53:34,750 --> 00:53:43,210
programmer should know when not to code

00:53:39,660 --> 00:53:47,890
if you don't have the expertise either

00:53:43,210 --> 00:53:55,480
get it or say no it's the professional

00:53:47,890 --> 00:53:58,510
thing to do okay so if you want a random

00:53:55,480 --> 00:54:00,850
variate typically what you're going to

00:53:58,510 --> 00:54:05,350
do is instantiate an engine and a

00:54:00,850 --> 00:54:06,910
distribution you get to choose which you

00:54:05,350 --> 00:54:09,280
get to pick the parameters of the

00:54:06,910 --> 00:54:13,630
distribution both the template argument

00:54:09,280 --> 00:54:15,130
and the constructor argument and then

00:54:13,630 --> 00:54:16,960
for each variate that you want you call

00:54:15,130 --> 00:54:19,180
the distribution object and you pass it

00:54:16,960 --> 00:54:20,800
the engine object so that the

00:54:19,180 --> 00:54:24,010
distribution can use that engine as a

00:54:20,800 --> 00:54:27,220
source of randomness and the canonical

00:54:24,010 --> 00:54:32,710
example is you know declare auto variate

00:54:27,220 --> 00:54:36,730
equals duv okay and it's really that

00:54:32,710 --> 00:54:38,740
simple and for an incredibly large

00:54:36,730 --> 00:54:42,870
number of applications it suffice us to

00:54:38,740 --> 00:54:46,390
have one engine and one distribution

00:54:42,870 --> 00:54:49,720
okay why do you need the distribution

00:54:46,390 --> 00:54:51,790
for the last time because it makes no

00:54:49,720 --> 00:54:54,330
sense to ask for a random number without

00:54:51,790 --> 00:54:56,970
context you

00:54:54,330 --> 00:55:02,580
to specify random according to what

00:54:56,970 --> 00:55:05,400
distribution people who don't know

00:55:02,580 --> 00:55:09,960
better think that all distributions are

00:55:05,400 --> 00:55:12,360
uniform and it just isn't so uniform

00:55:09,960 --> 00:55:15,810
distributions are incredibly useful but

00:55:12,360 --> 00:55:19,230
there are lots and lots of others so my

00:55:15,810 --> 00:55:22,410
suggestion if you should get any any

00:55:19,230 --> 00:55:25,640
kind of complexity at all start thinking

00:55:22,410 --> 00:55:29,370
about engines and distributions as

00:55:25,640 --> 00:55:32,250
resources we know how to do resource

00:55:29,370 --> 00:55:34,530
management we do memory management we do

00:55:32,250 --> 00:55:38,430
file management we do new tax management

00:55:34,530 --> 00:55:40,500
we treat them all as resources our AII

00:55:38,430 --> 00:55:44,880
for example is the way to go

00:55:40,500 --> 00:55:47,730
in many cases right if you get into

00:55:44,880 --> 00:55:50,370
anything that is all sophisticated treat

00:55:47,730 --> 00:55:53,580
these objects as resources and do it the

00:55:50,370 --> 00:55:58,530
same way you may need to take explicit

00:55:53,580 --> 00:56:00,510
control over lifetime ok but if your

00:55:58,530 --> 00:56:02,580
application is fairly straightforward

00:56:00,510 --> 00:56:04,650
you can often combine the engine with

00:56:02,580 --> 00:56:07,530
the distribution and you've got lots of

00:56:04,650 --> 00:56:11,760
tools that your disposal to do that here

00:56:07,530 --> 00:56:13,110
are some of your choices pair couple you

00:56:11,760 --> 00:56:16,650
can write your own class you can write

00:56:13,110 --> 00:56:18,890
your own class template you can write

00:56:16,650 --> 00:56:21,060
you can use bind you can write a lambda

00:56:18,890 --> 00:56:22,440
you can write your own function you can

00:56:21,060 --> 00:56:25,800
write your own function template there

00:56:22,440 --> 00:56:27,330
are lots and lots of ways to do this we

00:56:25,800 --> 00:56:29,220
didn't put any of them the library

00:56:27,330 --> 00:56:32,990
because we can't make that choice

00:56:29,220 --> 00:56:32,990
for you there is no one-size-fits-all

00:56:33,230 --> 00:56:41,340
there isn't even a one size fits many

00:56:36,920 --> 00:56:43,800
that we were able to converge on you do

00:56:41,340 --> 00:56:50,280
need to keep in mind that engine objects

00:56:43,800 --> 00:56:52,560
are stateful and mutable so if you're

00:56:50,280 --> 00:56:56,880
going to pass them around to other code

00:56:52,560 --> 00:56:58,230
do not pass by cost reference because

00:56:56,880 --> 00:57:02,520
they will be impotent when they get

00:56:58,230 --> 00:57:05,130
there ok they're not cost if you're

00:57:02,520 --> 00:57:08,130
using concurrent code you need to

00:57:05,130 --> 00:57:09,870
serialize or

00:57:08,130 --> 00:57:14,130
you can consider multiple engines one

00:57:09,870 --> 00:57:15,300
per thread for example it is less well

00:57:14,130 --> 00:57:17,130
known but the same is true for

00:57:15,300 --> 00:57:19,560
distributions distributions can be

00:57:17,130 --> 00:57:22,440
stateful they don't have to be a many

00:57:19,560 --> 00:57:24,000
aren't but they may be as one example

00:57:22,440 --> 00:57:25,800
there's a fairly well known algorithm

00:57:24,000 --> 00:57:29,670
called box Mueller named for the people

00:57:25,800 --> 00:57:32,190
who came up with it it gives you

00:57:29,670 --> 00:57:34,140
normally distributed variants except it

00:57:32,190 --> 00:57:35,610
generates them two at a time gives you

00:57:34,140 --> 00:57:37,260
one cache as the other one

00:57:35,610 --> 00:57:41,610
call it the second time it gives you the

00:57:37,260 --> 00:57:42,810
one cached so it's stateful okay and you

00:57:41,610 --> 00:57:46,290
don't know whether your distribution

00:57:42,810 --> 00:57:50,460
uses it I mean I don't know so you don't

00:57:46,290 --> 00:57:52,140
know you need to know that an engine

00:57:50,460 --> 00:57:53,610
state is influenced by providing a

00:57:52,140 --> 00:57:57,270
starting value that we've referred to as

00:57:53,610 --> 00:58:03,600
a seed if you put in a fixed seed you're

00:57:57,270 --> 00:58:05,880
guaranteeing reproducibility the engine

00:58:03,600 --> 00:58:08,310
size is a factor it is really hard to

00:58:05,880 --> 00:58:12,450
initialize excuse me Mersenne twister

00:58:08,310 --> 00:58:15,120
with a single integer there's something

00:58:12,450 --> 00:58:17,250
in the library called seed sequence seed

00:58:15,120 --> 00:58:20,610
seek that takes an integer and tries to

00:58:17,250 --> 00:58:23,400
make more entropy out of it it's doesn't

00:58:20,610 --> 00:58:25,770
do it particularly well it's probably

00:58:23,400 --> 00:58:27,720
best avoided feel free to experiment

00:58:25,770 --> 00:58:31,560
with it there are better things on the

00:58:27,720 --> 00:58:33,330
horizon you have to know whether your

00:58:31,560 --> 00:58:36,360
application does or does not care about

00:58:33,330 --> 00:58:38,340
reproducibility for some applications

00:58:36,360 --> 00:58:40,770
it's critically important it's faithful

00:58:38,340 --> 00:58:42,360
for others if you have a game I think

00:58:40,770 --> 00:58:44,190
your players will be disappointed if it

00:58:42,360 --> 00:58:50,340
plays the same game again and again and

00:58:44,190 --> 00:58:54,300
again right it is common to take the

00:58:50,340 --> 00:58:58,140
current time or the process ID these are

00:58:54,300 --> 00:59:00,240
considered low quality seed data one of

00:58:58,140 --> 00:59:01,770
the problems with time is if you need to

00:59:00,240 --> 00:59:03,270
seed a lot of things you don't know the

00:59:01,770 --> 00:59:06,300
resolution of your clock in all cases

00:59:03,270 --> 00:59:08,010
you may think you're getting nanosecond

00:59:06,300 --> 00:59:13,710
resolution and you're getting one second

00:59:08,010 --> 00:59:15,240
resolution this is bad okay let me tell

00:59:13,710 --> 00:59:17,940
you quickly some of the other things you

00:59:15,240 --> 00:59:22,470
can do with random we have a new

00:59:17,940 --> 00:59:25,170
algorithm and C++ 17 known as sample

00:59:22,470 --> 00:59:27,270
the declaration it is actually under the

00:59:25,170 --> 00:59:29,490
cover it's two different algorithms and

00:59:27,270 --> 00:59:33,780
it picks the right one based on what

00:59:29,490 --> 00:59:34,710
kind of iterators you give it okay so if

00:59:33,780 --> 00:59:36,599
you have up what's what the

00:59:34,710 --> 00:59:38,220
statisticians call a population you can

00:59:36,599 --> 00:59:42,000
just think of it as a range begin and

00:59:38,220 --> 00:59:43,740
end you give it that range that's gonna

00:59:42,000 --> 00:59:45,930
draw from that population you tell it

00:59:43,740 --> 00:59:48,089
where to put the copy of what you sample

00:59:45,930 --> 00:59:51,329
is how big the sample size you want and

00:59:48,089 --> 00:59:55,250
it just does it okay and we're in the

00:59:51,329 --> 00:59:57,690
process of proposing an in-place sample

00:59:55,250 --> 01:00:00,300
which will do partitioning rather than

00:59:57,690 --> 01:00:02,310
copying I want to sample these things

01:00:00,300 --> 01:00:03,869
just partition it put the sample at the

01:00:02,310 --> 01:00:06,960
beginning and the stuff I have not using

01:00:03,869 --> 01:00:11,849
at the end okay so that's sort of in

01:00:06,960 --> 01:00:13,980
process we can shuffle now I don't have

01:00:11,849 --> 01:00:16,980
time to go through all of this code but

01:00:13,980 --> 01:00:21,230
when you look at it later what you'll

01:00:16,980 --> 01:00:24,359
notice is that I'm I am mimicking

01:00:21,230 --> 01:00:27,599
creating a deck of cards shuffling it

01:00:24,359 --> 01:00:31,140
then displaying it all with standard

01:00:27,599 --> 01:00:34,349
facilities you should know that the

01:00:31,140 --> 01:00:37,079
original stepping offs STL has an

01:00:34,349 --> 01:00:41,640
algorithm called random shuffle that was

01:00:37,079 --> 01:00:45,869
deprecated in C++ 14 it is gone in C++

01:00:41,640 --> 01:00:48,109
17 so best avoided in favor of shuffle

01:00:45,869 --> 01:00:52,400
shuffle was designed to ensure operator

01:00:48,109 --> 01:00:56,069
random header random shuffle predated it

01:00:52,400 --> 01:00:59,270
it is not well known but the parameters

01:00:56,069 --> 01:01:02,790
to a distribution can vary per call

01:00:59,270 --> 01:01:05,310
here's an example of how to do it and in

01:01:02,790 --> 01:01:06,780
fact this is an implementation of the

01:01:05,310 --> 01:01:08,310
shuffle algorithm in the standard

01:01:06,780 --> 01:01:11,280
library again I'm not going to go

01:01:08,310 --> 01:01:13,319
through it in detail but it's

01:01:11,280 --> 01:01:15,810
interesting to note that in the call to

01:01:13,319 --> 01:01:17,970
the distribution which is near the

01:01:15,810 --> 01:01:23,490
bottom for the screen where it says D of

01:01:17,970 --> 01:01:25,500
G comma stuff you don't have to

01:01:23,490 --> 01:01:27,240
instantiate a new distribution just

01:01:25,500 --> 01:01:28,890
because you want to change the

01:01:27,240 --> 01:01:31,800
parameters of the distribution for this

01:01:28,890 --> 01:01:33,450
one call shuffle it turns out needs to

01:01:31,800 --> 01:01:35,950
change the parameters every time it

01:01:33,450 --> 01:01:40,060
calls and we do it all with one two

01:01:35,950 --> 01:01:44,050
tribution and just some things to think

01:01:40,060 --> 01:01:47,079
about for the future you could write an

01:01:44,050 --> 01:01:50,170
insert an iterator interface to the

01:01:47,079 --> 01:01:51,849
facilities in the random header suppose

01:01:50,170 --> 01:01:55,240
you had one for a second what could you

01:01:51,849 --> 01:01:57,970
do with it okay here's something

01:01:55,240 --> 01:02:00,460
tentatively known as a variate iterator

01:01:57,970 --> 01:02:03,310
and you hand at the generator of your

01:02:00,460 --> 01:02:08,730
choice and the distribution of your

01:02:03,310 --> 01:02:13,119
choice and if I had that then I can

01:02:08,730 --> 01:02:19,540
populate a vector by calling a copy or

01:02:13,119 --> 01:02:25,180
copy n a whole bunch of variants in one

01:02:19,540 --> 01:02:27,220
call or I had I have a friend who's an

01:02:25,180 --> 01:02:31,540
engineer and he said you know I really

01:02:27,220 --> 01:02:34,030
need to to do a dot product and I need

01:02:31,540 --> 01:02:39,400
to do a dot product with a random vector

01:02:34,030 --> 01:02:44,650
okay there it is you're done if you have

01:02:39,400 --> 01:02:46,510
an iterator interface or an engineer

01:02:44,650 --> 01:02:50,500
friend of mine he says well you know I

01:02:46,510 --> 01:02:52,690
want to simulate noise so I want to you

01:02:50,500 --> 01:03:00,190
know adjust my values with some random

01:02:52,690 --> 01:03:01,960
values okay done one line of code okay

01:03:00,190 --> 01:03:03,609
if you're interested I encourage you

01:03:01,960 --> 01:03:05,589
again download the slides and look at

01:03:03,609 --> 01:03:07,750
this more carefully and this is what

01:03:05,589 --> 01:03:11,020
such an iterator interface could look

01:03:07,750 --> 01:03:13,420
like so this is the first page of two

01:03:11,020 --> 01:03:15,579
it's this is basically declarations

01:03:13,420 --> 01:03:17,740
there's some design issues you have to

01:03:15,579 --> 01:03:22,300
figure out I've just said you know non

01:03:17,740 --> 01:03:25,690
owning distribution and you RBG but you

01:03:22,300 --> 01:03:27,250
can put in shared put ER or something

01:03:25,690 --> 01:03:30,579
like that if you want to take ownership

01:03:27,250 --> 01:03:34,750
in part and that's it this is all you

01:03:30,579 --> 01:03:36,460
have to produce all right and I know

01:03:34,750 --> 01:03:38,349
somebody's going to ask you know why I'm

01:03:36,460 --> 01:03:40,300
a inheriting from iterator which is now

01:03:38,349 --> 01:03:45,579
deprecated that's because I wrote this a

01:03:40,300 --> 01:03:48,600
year or two ago okay so a couple of very

01:03:45,579 --> 01:03:51,840
fast closing thoughts please

01:03:48,600 --> 01:03:55,170
be wary of resources that you find in

01:03:51,840 --> 01:03:57,720
random places okay

01:03:55,170 --> 01:04:00,390
the original spec of random was part of

01:03:57,720 --> 01:04:04,050
technical report one net which was the

01:04:00,390 --> 01:04:06,150
year 2007 why did we do that because we

01:04:04,050 --> 01:04:09,420
wanted feedback from a wider community

01:04:06,150 --> 01:04:12,480
of users and boy did we get it and what

01:04:09,420 --> 01:04:15,900
we ended up with in C++ 11 is much

01:04:12,480 --> 01:04:19,800
improved over the original sometimes in

01:04:15,900 --> 01:04:21,660
subtle ways okay a couple of things just

01:04:19,800 --> 01:04:24,600
vanished outright and a couple of new

01:04:21,660 --> 01:04:26,970
things appeared so forget about the

01:04:24,600 --> 01:04:31,140
original interface don't even go there

01:04:26,970 --> 01:04:35,220
the problem is the early adopters

01:04:31,140 --> 01:04:36,270
started offering advice so before you

01:04:35,220 --> 01:04:39,810
rely on it

01:04:36,270 --> 01:04:42,720
please check the source I have seen

01:04:39,810 --> 01:04:47,460
published accounts of the history of

01:04:42,720 --> 01:04:50,550
random flat-out wrong just flat-out

01:04:47,460 --> 01:04:53,670
wrong people think that this originated

01:04:50,550 --> 01:04:56,520
with Boost wrong it originated with me

01:04:53,670 --> 01:04:58,800
and my colleagues and boost random

01:04:56,520 --> 01:05:01,020
header which was written by yen's Maurer

01:04:58,800 --> 01:05:04,130
he hardly ever gets credit for it did a

01:05:01,020 --> 01:05:06,240
beautiful job he actually came to our

01:05:04,130 --> 01:05:08,820
institution and spent a week with us

01:05:06,240 --> 01:05:11,210
learning our design before he went off

01:05:08,820 --> 01:05:13,230
and it produced the boost random header

01:05:11,210 --> 01:05:17,550
so that's what's really the proof of

01:05:13,230 --> 01:05:19,800
concept okay I found all kinds of

01:05:17,550 --> 01:05:21,360
programming advice but you know written

01:05:19,800 --> 01:05:24,840
by people who understand neither

01:05:21,360 --> 01:05:28,440
randomness nor the header but don't know

01:05:24,840 --> 01:05:30,960
what they don't know be careful

01:05:28,440 --> 01:05:33,420
so I urge you look at the sources

01:05:30,960 --> 01:05:36,480
carefully look at the dates carefully

01:05:33,420 --> 01:05:38,760
before you rely on what you read there's

01:05:36,480 --> 01:05:41,430
good stuff there's also a ton of bad

01:05:38,760 --> 01:05:44,280
stuff out there here are some places

01:05:41,430 --> 01:05:47,280
that you may want to look that play

01:05:44,280 --> 01:05:50,690
random.org I've mentioned before there's

01:05:47,280 --> 01:05:54,150
a recent proposal by Moritz Clem ler

01:05:50,690 --> 01:05:56,940
that we are looking at in committee to

01:05:54,150 --> 01:06:00,360
enhance and simplify the seating over of

01:05:56,940 --> 01:06:02,500
random engines it's in process Melissa

01:06:00,360 --> 01:06:04,480
O'Neill has a website

01:06:02,500 --> 01:06:06,690
and has co-authored a proposal based on

01:06:04,480 --> 01:06:08,740
what she did there she's a mathematician

01:06:06,690 --> 01:06:11,890
statistician seems to know her stuff

01:06:08,740 --> 01:06:15,220
really well I've been in touch with all

01:06:11,890 --> 01:06:18,190
these people the news is that there is a

01:06:15,220 --> 01:06:20,800
very good chance that in the reasonably

01:06:18,190 --> 01:06:23,500
near future once we're done with C++ 17

01:06:20,800 --> 01:06:26,530
we will start working on a new technical

01:06:23,500 --> 01:06:30,300
specification for an improved random

01:06:26,530 --> 01:06:36,120
facility for a future standard library

01:06:30,300 --> 01:06:36,120
so in closing again quoting our friends

01:06:36,420 --> 01:06:41,680
explicitly quoting Andre if I were a

01:06:39,580 --> 01:06:47,100
random number I think I died and went to

01:06:41,680 --> 01:06:47,100
heaven all right thank you all very much

01:06:59,740 --> 01:07:08,950
I'm do we have time for questions I we

01:07:06,370 --> 01:07:12,280
have five more minutes I'm willing if

01:07:08,950 --> 01:07:13,780
you're willing I'm sorry I don't I

01:07:12,280 --> 01:07:22,180
didn't see who was first let me just go

01:07:13,780 --> 01:07:27,640
around the room sir process ID yeah

01:07:22,180 --> 01:07:31,030
right yeah I'm not the position to make

01:07:27,640 --> 01:07:33,640
a recommendation for you go to Melissa

01:07:31,030 --> 01:07:35,740
O'Neill's website she has written

01:07:33,640 --> 01:07:38,050
extensively about this so she has some

01:07:35,740 --> 01:07:42,490
code there take a look at that as a

01:07:38,050 --> 01:07:43,930
source of inspiration okay I'll take one

01:07:42,490 --> 01:07:45,640
more question that I'm told there

01:07:43,930 --> 01:08:06,160
session is officially over sorry about

01:07:45,640 --> 01:08:07,660
that sir oh that that would take much

01:08:06,160 --> 01:08:10,270
longer than we have time for here I'm

01:08:07,660 --> 01:08:12,760
sorry okay let's talk privately some

01:08:10,270 --> 01:08:13,980
other time okay all right thanks thanks

01:08:12,760 --> 01:08:16,040
again people

01:08:13,980 --> 01:08:16,040

YouTube URL: https://www.youtube.com/watch?v=6DPkyvkMkk8


