Title: CppCon 2016: Michał Dominiak “Variadic expansion in examples"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Templates - and variadic templates - are an important aspect of writing a successful library in C++; libraries that can deal with custom types the user creates greatly eases their use. Variadic templates specifically are still a new, relatively unknown and at the same time quite a buggy (in the sense of bugs in their implementations) tool, but nevertheless, they offer much easier ways of creating truly generic types and functions. 

This talk will focus slightly less on variadic templates in general; the common pitfalls will be discussed, but more attention will be given to the tool of parameter pack expansion and all the contexts where it can be used, especially as a code generation tool. 

The talk will start mostly from scratch, assuming the audience's general knowledge about templates. It'll introduce the idea of variadic templates and general syntax and typical techniques for their use. Next, it will head into the (mostly) unknown and buggy lands of the interesting uses of variadic packs, like unpacking a tuple into a function call using `std::integer_sequence`, the use of empty packs for a slightly easier way to work with `enable_if`. The final examples will explain the way of invoking an expression per every argument in a pack, and dispatch to appropriate version of code for each of the argument types based on runtime values, which will be used to more easily create variant visitors. 
— 
Michał Dominiak
Software Engineer, Nokia Networks
Bachelor of Engineering in Computer Science, studied at Faculty of Electronics at Wrocław University of Technology. Loves metaprogramming and doing as much as possible during compile time, instead of wasting precious cycles at runtime.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,020 --> 00:00:08,490
hi everyone my name is maja Dominic

00:00:04,589 --> 00:00:10,800
I work at Nokia networks in Ottawa and

00:00:08,490 --> 00:00:13,610
today I'd like to talk to you about

00:00:10,800 --> 00:00:17,850
variadic templates but more from the

00:00:13,610 --> 00:00:24,060
code generation site rather than type

00:00:17,850 --> 00:00:26,490
generation so I'm going to assume that

00:00:24,060 --> 00:00:31,949
most of you are familiar with templates

00:00:26,490 --> 00:00:33,840
a they are knives right they allow us to

00:00:31,949 --> 00:00:37,920
write code once use it with multiple

00:00:33,840 --> 00:00:41,969
times multiple types they also allow us

00:00:37,920 --> 00:00:45,719
to do some slightly less nice for the

00:00:41,969 --> 00:00:48,570
users things like this which breaks the

00:00:45,719 --> 00:00:54,780
expectation but let's not talk about

00:00:48,570 --> 00:00:57,899
that anymore so we can for example write

00:00:54,780 --> 00:01:03,000
this function this is in fact the

00:00:57,899 --> 00:01:05,070
standard main function and it returns

00:01:03,000 --> 00:01:09,150
the reference to the smaller value

00:01:05,070 --> 00:01:13,350
passed inside so frankly I'd prefer this

00:01:09,150 --> 00:01:16,049
function to look like this because it's

00:01:13,350 --> 00:01:20,689
nicer doesn't give me potentially

00:01:16,049 --> 00:01:23,640
dangling references and so on and and to

00:01:20,689 --> 00:01:26,100
avoid having enormous amounts of code on

00:01:23,640 --> 00:01:30,119
my slides I'm going to write this as

00:01:26,100 --> 00:01:32,340
this and let's just assume that all the

00:01:30,119 --> 00:01:33,990
boilerplate from this slide is also

00:01:32,340 --> 00:01:38,070
present whenever I write something like

00:01:33,990 --> 00:01:42,869
this just to be clear so that's nice and

00:01:38,070 --> 00:01:46,490
all right that like we want to have the

00:01:42,869 --> 00:01:48,869
minimum value of multiple values and

00:01:46,490 --> 00:01:53,420
ideally we wouldn't call something like

00:01:48,869 --> 00:01:53,420
accumulates to fold on all the values a

00:01:54,680 --> 00:01:59,610
partial application is also a use case

00:01:58,049 --> 00:02:03,960
where we need something far more

00:01:59,610 --> 00:02:07,049
flexible than just C++ 98 templates and

00:02:03,960 --> 00:02:10,789
let's not talk about some mistakes that

00:02:07,049 --> 00:02:10,789
were made in the library in the past

00:02:11,220 --> 00:02:16,170
and what about types that are

00:02:13,860 --> 00:02:21,150
parameterizing an arbitrary number of

00:02:16,170 --> 00:02:23,700
things the primary example we will be

00:02:21,150 --> 00:02:27,390
using today is variance because they are

00:02:23,700 --> 00:02:30,540
nice there are useful okay

00:02:27,390 --> 00:02:33,810
so about variance there is this type

00:02:30,540 --> 00:02:37,290
called boost variant and some people

00:02:33,810 --> 00:02:41,580
don't really like it for several several

00:02:37,290 --> 00:02:47,610
several reasons and one of the reasons

00:02:41,580 --> 00:02:55,050
is that its signature is declaration

00:02:47,610 --> 00:03:01,710
looks like this how many of you can read

00:02:55,050 --> 00:03:04,470
that all right and all this all these

00:03:01,710 --> 00:03:08,730
boost purposes or machinery expands to

00:03:04,470 --> 00:03:10,710
something like this I consciously didn't

00:03:08,730 --> 00:03:14,580
make make an effort to fit into this

00:03:10,710 --> 00:03:17,040
slide so okay you can configure how many

00:03:14,580 --> 00:03:22,050
types you can hold in a variant fire I

00:03:17,040 --> 00:03:25,530
am a macro it works kind of but whenever

00:03:22,050 --> 00:03:28,320
you get an error at compile time it

00:03:25,530 --> 00:03:31,680
spews something that's that makes the

00:03:28,320 --> 00:03:33,600
output completely unreadable especially

00:03:31,680 --> 00:03:36,900
so if you have a variant of something

00:03:33,600 --> 00:03:39,989
that has a variant inside and one of you

00:03:36,900 --> 00:03:44,010
worked with types like that and how many

00:03:39,989 --> 00:03:47,880
of you liked the error messages yes I

00:03:44,010 --> 00:03:53,430
thought so okay so there is another

00:03:47,880 --> 00:03:55,980
approach that was used for variable

00:03:53,430 --> 00:03:59,640
number of template arguments for types

00:03:55,980 --> 00:04:02,160
or functions before C++ 11 it was

00:03:59,640 --> 00:04:05,370
something like this it's very nice it's

00:04:02,160 --> 00:04:08,670
very functional so we have a list the

00:04:05,370 --> 00:04:12,450
list is either nothing that's the tail

00:04:08,670 --> 00:04:15,930
up after or an element in this case type

00:04:12,450 --> 00:04:16,980
followed by a list and it looks

00:04:15,930 --> 00:04:22,080
something like this

00:04:16,980 --> 00:04:25,290
so this was useful right how many of you

00:04:22,080 --> 00:04:28,990
used something like this

00:04:25,290 --> 00:04:31,330
okay I see some hands all right how many

00:04:28,990 --> 00:04:37,150
of you had to die back a piece of code

00:04:31,330 --> 00:04:45,100
that used this and had 30 arguments in

00:04:37,150 --> 00:04:47,680
the list I had that clever and it's not

00:04:45,100 --> 00:04:50,350
very nice to look through back traces of

00:04:47,680 --> 00:04:52,900
all this and notice that there is a

00:04:50,350 --> 00:04:55,690
space between the closing brackets for

00:04:52,900 --> 00:05:00,790
the template arguments because this is

00:04:55,690 --> 00:05:04,120
pre C++ 11 and I will imagine 30 of

00:05:00,790 --> 00:05:06,940
those printed one after another it's not

00:05:04,120 --> 00:05:08,770
very nice so there's a there's a nice

00:05:06,940 --> 00:05:12,550
feature in C++ 11

00:05:08,770 --> 00:05:13,750
it's called Vedic templates so you can

00:05:12,550 --> 00:05:16,030
write something like this it's a

00:05:13,750 --> 00:05:19,920
function that takes any number of

00:05:16,030 --> 00:05:23,650
arguments of any types you can call it

00:05:19,920 --> 00:05:26,640
in whatever way you want to you can

00:05:23,650 --> 00:05:29,830
declare a type that's parameterize by

00:05:26,640 --> 00:05:33,540
any number of types you can use that

00:05:29,830 --> 00:05:36,910
with any number of types that's nice

00:05:33,540 --> 00:05:40,270
here's how we could implement the main

00:05:36,910 --> 00:05:42,970
function and once again I'm ignoring all

00:05:40,270 --> 00:05:47,560
the perfect forwarding boiler prior to

00:05:42,970 --> 00:05:49,510
you and this is recursion we recurs and

00:05:47,560 --> 00:05:52,360
of course we need the termination

00:05:49,510 --> 00:05:56,440
conditions so I chose this one because

00:05:52,360 --> 00:05:59,440
one argument is nicely generic for the

00:05:56,440 --> 00:06:02,770
interface and what happens when we

00:05:59,440 --> 00:06:04,810
actually call this function so this is a

00:06:02,770 --> 00:06:08,890
rough approximation of what happens not

00:06:04,810 --> 00:06:12,340
not an exact exact one so the compiler

00:06:08,890 --> 00:06:15,220
sees that definition and substitutes all

00:06:12,340 --> 00:06:18,850
the arguments and what happens with the

00:06:15,220 --> 00:06:21,250
variadic factor the tail dot dot dot

00:06:18,850 --> 00:06:23,560
that was in the definition is that it

00:06:21,250 --> 00:06:28,660
gets expanded into a comma-separated

00:06:23,560 --> 00:06:31,570
list of elements in that pack so this is

00:06:28,660 --> 00:06:34,180
the overload for for inch this is the

00:06:31,570 --> 00:06:37,960
overload for free ins that's requested

00:06:34,180 --> 00:06:42,370
in the previous one and finally

00:06:37,960 --> 00:06:47,039
the overload for two arguments where the

00:06:42,370 --> 00:06:50,800
puck is empty that's also a valid valid

00:06:47,039 --> 00:06:56,169
situation okay that's easy that's nice

00:06:50,800 --> 00:06:58,389
right so there is multiple things that

00:06:56,169 --> 00:07:00,340
can be done with faradic templates and

00:06:58,389 --> 00:07:04,240
recursive techniques are not

00:07:00,340 --> 00:07:07,449
particularly interesting so let's move

00:07:04,240 --> 00:07:09,190
to something else top one packing how

00:07:07,449 --> 00:07:13,479
many of you have been to a steals talk

00:07:09,190 --> 00:07:15,460
about tuples all right you will be

00:07:13,479 --> 00:07:17,070
slightly bored in this part yes I see

00:07:15,460 --> 00:07:20,500
you Stephen

00:07:17,070 --> 00:07:23,979
okay so at Apple is a generic data

00:07:20,500 --> 00:07:28,270
structure containing some values of some

00:07:23,979 --> 00:07:30,099
types this is a tuple which was the

00:07:28,270 --> 00:07:33,970
following interface you can create it

00:07:30,099 --> 00:07:37,889
there is a hopper coral to make to pool

00:07:33,970 --> 00:07:41,729
in the standard library it creates a

00:07:37,889 --> 00:07:44,860
type that uses all the arguments and

00:07:41,729 --> 00:07:48,400
there is a function called standard get

00:07:44,860 --> 00:07:59,590
that allows you to extract a value from

00:07:48,400 --> 00:08:05,470
multiple so I'm not going to say

00:07:59,590 --> 00:08:07,949
anything for a moment still is sitting

00:08:05,470 --> 00:08:07,949
over there

00:08:25,610 --> 00:08:30,390
right let's do something useful with

00:08:28,080 --> 00:08:34,440
this type that's not very nice for some

00:08:30,390 --> 00:08:37,110
people we will use it that's like the

00:08:34,440 --> 00:08:40,380
problem that I'm going to solve in a way

00:08:37,110 --> 00:08:43,130
is to use topless generic storage and we

00:08:40,380 --> 00:08:46,710
have a function called past later or

00:08:43,130 --> 00:08:48,420
there's a many variants of this problem

00:08:46,710 --> 00:08:52,940
when you have all the arguments for

00:08:48,420 --> 00:08:56,130
function call stored in this thing so

00:08:52,940 --> 00:08:58,950
it's easy to do when there is no

00:08:56,130 --> 00:09:01,320
generousity you can just standard to get

00:08:58,950 --> 00:09:04,140
every argument by hand but we can do

00:09:01,320 --> 00:09:07,910
better but to do that we need to

00:09:04,140 --> 00:09:12,540
generate all the integers from zero to

00:09:07,910 --> 00:09:15,360
number of arguments minus one there used

00:09:12,540 --> 00:09:18,390
to be a time where this slide would be

00:09:15,360 --> 00:09:22,950
like five of them or it went a minute

00:09:18,390 --> 00:09:25,500
talk at the conference a there is nice

00:09:22,950 --> 00:09:28,380
tool for exactly this purpose it's

00:09:25,500 --> 00:09:32,220
called an integer sequence there is a

00:09:28,380 --> 00:09:34,800
alias for integer sequence for standard

00:09:32,220 --> 00:09:36,900
size T called index sequence there is a

00:09:34,800 --> 00:09:39,750
function called make in this sequence

00:09:36,900 --> 00:09:41,570
that that's exactly what we need for

00:09:39,750 --> 00:09:50,160
this purpose

00:09:41,570 --> 00:09:52,050
hey so this is how we do this and if at

00:09:50,160 --> 00:09:54,390
any point you have any questions or

00:09:52,050 --> 00:09:58,260
anything is unclear please ask

00:09:54,390 --> 00:10:02,160
immediately so we can follow everything

00:09:58,260 --> 00:10:04,560
so there's one caveat with this

00:10:02,160 --> 00:10:07,680
technique it's that we have to have a

00:10:04,560 --> 00:10:14,040
wrapper for the call because we somehow

00:10:07,680 --> 00:10:17,970
have to deduce the the index sequences

00:10:14,040 --> 00:10:20,610
arguments but it takes some boilerplate

00:10:17,970 --> 00:10:21,900
it's not very nice in some situations

00:10:20,610 --> 00:10:23,520
where you would like to contain

00:10:21,900 --> 00:10:28,220
everything within a function and you

00:10:23,520 --> 00:10:31,470
slammed us but it's it's doable and

00:10:28,220 --> 00:10:33,059
there is a standard library function in

00:10:31,470 --> 00:10:38,339
C++ seventeen

00:10:33,059 --> 00:10:41,159
hold apply is it apply its called apply

00:10:38,339 --> 00:10:46,559
that does exactly all this that we are

00:10:41,159 --> 00:10:51,929
doing here all right that's one of the

00:10:46,559 --> 00:10:55,799
uses the next years is kind of simple

00:10:51,929 --> 00:10:59,519
but touches here a problem with using

00:10:55,799 --> 00:11:08,099
variadic templates in suppose was so who

00:10:59,519 --> 00:11:12,899
here does not know what spin a is okay

00:11:08,099 --> 00:11:16,379
it's a it's not really obscure but it's

00:11:12,899 --> 00:11:18,899
like a weird language feature that

00:11:16,379 --> 00:11:22,919
allows you to have a an error that is

00:11:18,899 --> 00:11:26,639
not an error so there is this type that

00:11:22,919 --> 00:11:29,759
contains a member type alias called

00:11:26,639 --> 00:11:36,689
type only if the boolean argument is

00:11:29,759 --> 00:11:39,329
true so any access into the member a yes

00:11:36,689 --> 00:11:43,669
for enable if when the first argument is

00:11:39,329 --> 00:11:47,639
false results in a compiler error or not

00:11:43,669 --> 00:11:50,909
so this function does not participate in

00:11:47,639 --> 00:11:53,129
overload resolution if interesting trade

00:11:50,909 --> 00:12:00,299
is false because we are trying to use a

00:11:53,129 --> 00:12:04,079
type that is not there so this is a way

00:12:00,299 --> 00:12:07,229
to write fine spin - for functions it's

00:12:04,079 --> 00:12:10,619
not particularly useful for non-void

00:12:07,229 --> 00:12:12,389
functions or for functions well for

00:12:10,619 --> 00:12:14,459
non-void functions where we know the

00:12:12,389 --> 00:12:16,709
type you can just pass that as a second

00:12:14,459 --> 00:12:18,719
argument to enable if and everything

00:12:16,709 --> 00:12:24,349
works if you want to use type detection

00:12:18,719 --> 00:12:27,779
though not so nice so you can write this

00:12:24,349 --> 00:12:32,639
it does basically the same thing yeah

00:12:27,779 --> 00:12:35,129
there's many variations of this form

00:12:32,639 --> 00:12:38,009
like some people write type name equals

00:12:35,129 --> 00:12:44,089
type name STD and I believe instead of

00:12:38,009 --> 00:12:46,559
this but whatever it's all the same so

00:12:44,089 --> 00:12:50,009
there's something else we can do because

00:12:46,559 --> 00:12:53,279
this last forum has one little weird

00:12:50,009 --> 00:12:57,629
problem that you may or may not care

00:12:53,279 --> 00:13:00,720
about it's that the zero ends up in the

00:12:57,629 --> 00:13:03,480
type name so every time you print the

00:13:00,720 --> 00:13:07,589
type you know whenever in whatever ways

00:13:03,480 --> 00:13:14,749
you get this zero that does nothing as a

00:13:07,589 --> 00:13:14,749
template argument so we can write this

00:13:20,720 --> 00:13:26,279
this pack will always be empty because

00:13:23,489 --> 00:13:28,679
there is no way to deduce the values for

00:13:26,279 --> 00:13:30,540
it well unless you explicitly provide

00:13:28,679 --> 00:13:35,309
the template arguments for the function

00:13:30,540 --> 00:13:39,749
but that's that's silly so this is nice

00:13:35,309 --> 00:13:42,420
and all you can also do better shorter

00:13:39,749 --> 00:13:45,059
and do something like oh I'm missing

00:13:42,420 --> 00:13:48,869
colon colon type on this slide sorry

00:13:45,059 --> 00:14:02,910
and so basically create a pack of void

00:13:48,869 --> 00:14:07,459
pointers instead of integers but yeah it

00:14:02,910 --> 00:14:13,129
was a compiler barking clang yeah

00:14:07,459 --> 00:14:16,529
it was there for four years before a

00:14:13,129 --> 00:14:21,720
person fixed it was straight before

00:14:16,529 --> 00:14:26,999
February so slightly later that a

00:14:21,720 --> 00:14:29,309
comment appeared under that bark report

00:14:26,999 --> 00:14:33,410
that this actual has been fixed for five

00:14:29,309 --> 00:14:35,970
months already so I lied in my previous

00:14:33,410 --> 00:14:37,799
the previous time I gave the gave this

00:14:35,970 --> 00:14:41,939
talk because it has already been fixed

00:14:37,799 --> 00:14:46,319
only not realized and the person who

00:14:41,939 --> 00:14:51,029
fixes it was Richard Smith just kind of

00:14:46,319 --> 00:14:53,569
appropriate I think all right so great

00:14:51,029 --> 00:14:57,500
we can use this in any compiler we can

00:14:53,569 --> 00:15:00,470
great there's people who

00:14:57,500 --> 00:15:02,890
used to make their their libraries

00:15:00,470 --> 00:15:07,390
compatible with Clank by doing the

00:15:02,890 --> 00:15:10,390
equals value version of this of this

00:15:07,390 --> 00:15:13,340
phonetic forum so I'm very happy that I

00:15:10,390 --> 00:15:21,920
can just use those libraries on Clank

00:15:13,340 --> 00:15:28,040
now all right there's another thing that

00:15:21,920 --> 00:15:34,070
we can do we can expand more complex

00:15:28,040 --> 00:15:36,830
expressions and we kind of have seen

00:15:34,070 --> 00:15:40,610
that already but let's see what's going

00:15:36,830 --> 00:15:43,670
on here so there is a few contexts where

00:15:40,610 --> 00:15:45,680
you can do for Attic package expansion

00:15:43,670 --> 00:15:48,200
and in it's a consequence of the fact

00:15:45,680 --> 00:15:51,860
that very attic pack expansion is really

00:15:48,200 --> 00:15:54,020
just expanding all the expanding the

00:15:51,860 --> 00:15:59,570
pack into a comma separated list of

00:15:54,020 --> 00:16:03,950
things of types of expressions of

00:15:59,570 --> 00:16:07,630
whatever and there's a few places where

00:16:03,950 --> 00:16:12,020
it would be nice to be able to use those

00:16:07,630 --> 00:16:14,390
with declarations particularly with

00:16:12,020 --> 00:16:17,720
using declarations when for example

00:16:14,390 --> 00:16:19,850
trying to pull an overload from all the

00:16:17,720 --> 00:16:22,790
base classes we have there was actually

00:16:19,850 --> 00:16:28,190
a paper that went through ewg for

00:16:22,790 --> 00:16:34,180
allowing this but it got stuck in cwg so

00:16:28,190 --> 00:16:38,240
I hope we will get this in C++ next and

00:16:34,180 --> 00:16:40,750
we cannot just create a statement out of

00:16:38,240 --> 00:16:43,760
a pack of expression like not even

00:16:40,750 --> 00:16:45,740
parenthesize in the pack expansion helps

00:16:43,760 --> 00:16:47,630
because what if the package empty you

00:16:45,740 --> 00:16:51,020
cannot have just the parent parent

00:16:47,630 --> 00:16:54,080
semicolon that makes some sense so not

00:16:51,020 --> 00:16:58,250
everything is not everything is easy

00:16:54,080 --> 00:16:59,540
with variadic packs of expressions so we

00:16:58,250 --> 00:17:01,220
want to call a function parameter

00:16:59,540 --> 00:17:02,870
argument ideally we would write

00:17:01,220 --> 00:17:06,260
something like this and it would compile

00:17:02,870 --> 00:17:07,760
but it does it and for somebody who

00:17:06,260 --> 00:17:11,100
doesn't know what's going on the error

00:17:07,760 --> 00:17:14,669
messages are very confusing

00:17:11,100 --> 00:17:17,160
to expect this expression there's an

00:17:14,669 --> 00:17:19,410
expression they're expected semicolon

00:17:17,160 --> 00:17:25,049
before they ellipsis but the park isn't

00:17:19,410 --> 00:17:26,669
expanded Lee I'm expanding the packs of

00:17:25,049 --> 00:17:28,439
the package expand it and I have

00:17:26,669 --> 00:17:31,710
semicolon after them no it doesn't work

00:17:28,439 --> 00:17:34,110
and the compiler doesn't help explaining

00:17:31,710 --> 00:17:37,880
why it doesn't work and how to make it

00:17:34,110 --> 00:17:41,490
work all right let's make an attempt to

00:17:37,880 --> 00:17:43,500
actually do this let's write a function

00:17:41,490 --> 00:17:45,720
that basically swirls any value that's

00:17:43,500 --> 00:17:48,120
passed into it there's nothing with it

00:17:45,720 --> 00:17:52,770
it just captures a reference it does

00:17:48,120 --> 00:17:58,860
literally nothing and so we could try to

00:17:52,770 --> 00:18:00,590
write something like this let the

00:17:58,860 --> 00:18:04,320
 called

00:18:00,590 --> 00:18:08,809
grab all the return values of bark holes

00:18:04,320 --> 00:18:11,789
and everything should work right Wow

00:18:08,809 --> 00:18:13,860
there's one caveat if borrow returns

00:18:11,789 --> 00:18:17,700
void for any of the arguments that

00:18:13,860 --> 00:18:21,090
doesn't work so we would write something

00:18:17,700 --> 00:18:26,039
like this which doesn't look so nice

00:18:21,090 --> 00:18:28,530
anymore yeah I'm using a comma

00:18:26,039 --> 00:18:32,789
expression there to make all the

00:18:28,530 --> 00:18:36,990
expressions have the values 0 so there

00:18:32,789 --> 00:18:41,669
is no void among the arguments to

00:18:36,990 --> 00:18:45,870
swallow all right so that should work

00:18:41,669 --> 00:18:50,150
right how many of you know why this

00:18:45,870 --> 00:18:53,340
doesn't work okay

00:18:50,150 --> 00:18:55,500
alright so let's try try concrete

00:18:53,340 --> 00:18:57,960
example we will print every argument

00:18:55,500 --> 00:19:01,409
actually in this case this zero is not

00:18:57,960 --> 00:19:04,220
necessary because there's a value

00:19:01,409 --> 00:19:08,909
returned by the previous expression but

00:19:04,220 --> 00:19:12,030
just to show the general case and we

00:19:08,909 --> 00:19:16,820
call the function with one - ABC and it

00:19:12,030 --> 00:19:24,110
should print 1 space 2 space ABC right

00:19:16,820 --> 00:19:24,110
yay mission accomplished not

00:19:31,789 --> 00:19:37,289
all right let's try something better and

00:19:34,590 --> 00:19:40,289
something that actually works the

00:19:37,289 --> 00:19:43,619
problem here is that the order of

00:19:40,289 --> 00:19:47,700
evaluation of function arguments is not

00:19:43,619 --> 00:19:52,590
defined to be from left to right or from

00:19:47,700 --> 00:19:56,190
right to left or it used not to be

00:19:52,590 --> 00:19:58,649
defined to even not interleave as of

00:19:56,190 --> 00:20:02,399
simple as 4:17 it's defined that every

00:19:58,649 --> 00:20:05,039
argument is fully evaluated separately

00:20:02,399 --> 00:20:06,989
they don't there is no interleaving

00:20:05,039 --> 00:20:10,499
between the execution of the expressions

00:20:06,989 --> 00:20:13,679
initializing the arguments that's nicer

00:20:10,499 --> 00:20:19,799
than before but it still doesn't get us

00:20:13,679 --> 00:20:23,249
there so let's try something that this

00:20:19,799 --> 00:20:27,210
isn't strictly necessary I like this

00:20:23,249 --> 00:20:28,499
because it shows that we don't really

00:20:27,210 --> 00:20:32,039
return a value

00:20:28,499 --> 00:20:34,259
just something to fool the type system

00:20:32,039 --> 00:20:40,139
into thinking and we are returning a

00:20:34,259 --> 00:20:41,609
value idea Voigt would work but and we

00:20:40,139 --> 00:20:43,859
slightly change the definition of

00:20:41,609 --> 00:20:45,779
swallow we may get a structure with a

00:20:43,859 --> 00:20:50,519
constructor that looks exactly the same

00:20:45,779 --> 00:20:53,669
like the function previously and I think

00:20:50,519 --> 00:20:55,649
we need to do is just construct the an

00:20:53,669 --> 00:20:59,759
object of the type instead of calling a

00:20:55,649 --> 00:21:03,230
function the trick is that C++ 11

00:20:59,759 --> 00:21:08,460
specifies that for braced initialized

00:21:03,230 --> 00:21:11,519
brace the initializer list the order of

00:21:08,460 --> 00:21:21,359
evaluation of the arguments is from left

00:21:11,519 --> 00:21:24,379
to right always so this finally works so

00:21:21,359 --> 00:21:27,450
some people some people use dressed as a

00:21:24,379 --> 00:21:32,269
array of integers instead of separate

00:21:27,450 --> 00:21:35,129
type and Wright comma zero everywhere

00:21:32,269 --> 00:21:36,160
it's a matter of taste how exactly you

00:21:35,129 --> 00:21:40,890
do this

00:21:36,160 --> 00:21:45,220
I prefer writing it the way I showed you

00:21:40,890 --> 00:21:47,380
because I think it conveys the intent

00:21:45,220 --> 00:21:50,140
better and most of the function I write

00:21:47,380 --> 00:21:53,260
that I suspect will be used this way

00:21:50,140 --> 00:21:58,410
return something so it's not a problem

00:21:53,260 --> 00:22:08,290
for me but whatever works for you really

00:21:58,410 --> 00:22:12,640
all right so there's a use case of

00:22:08,290 --> 00:22:15,340
something that tries not to use visitors

00:22:12,640 --> 00:22:18,010
that implement it outside of the

00:22:15,340 --> 00:22:20,740
function so you're twelve functions have

00:22:18,010 --> 00:22:23,050
pretty much the same problem only the

00:22:20,740 --> 00:22:26,260
code tends to be in the right place

00:22:23,050 --> 00:22:28,060
instead of some random place in the file

00:22:26,260 --> 00:22:31,690
before the function that actually does

00:22:28,060 --> 00:22:33,640
the visiting of a thing and the four

00:22:31,690 --> 00:22:36,150
functions are not nice or not

00:22:33,640 --> 00:22:40,420
particularly first we can do better

00:22:36,150 --> 00:22:44,290
provided that we have constructs or

00:22:40,420 --> 00:22:46,960
lambdas and this time around for those

00:22:44,290 --> 00:22:48,310
who somehow solve the previous iteration

00:22:46,960 --> 00:22:50,950
of the talk I actually have some

00:22:48,310 --> 00:22:54,850
assembly in the slides show the

00:22:50,950 --> 00:22:58,120
difference okay so the basic observation

00:22:54,850 --> 00:23:00,610
is that lambdas are expressions so since

00:22:58,120 --> 00:23:02,170
we can expand the pack of expressions we

00:23:00,610 --> 00:23:06,340
should be able to expand the pack of

00:23:02,170 --> 00:23:08,140
lump that's right so we should be able

00:23:06,340 --> 00:23:11,350
to write something like this okay so

00:23:08,140 --> 00:23:15,010
variant is something like ish the

00:23:11,350 --> 00:23:18,880
standard variant it has a function

00:23:15,010 --> 00:23:21,190
called index that returns the index of

00:23:18,880 --> 00:23:24,400
the currently active member the of the

00:23:21,190 --> 00:23:28,690
variant it has an Associated function

00:23:24,400 --> 00:23:32,020
called get that allows you to get the

00:23:28,690 --> 00:23:36,760
member of the variant provided it's

00:23:32,020 --> 00:23:39,670
active a and index off is really just a

00:23:36,760 --> 00:23:47,590
matter fact that takes the index of T in

00:23:39,670 --> 00:23:49,750
the park so the confusing the probably

00:23:47,590 --> 00:23:54,250
confusing for some people line is the

00:23:49,750 --> 00:23:56,470
using T equals TS it looks weird there's

00:23:54,250 --> 00:23:58,900
an expanded packet error but it's

00:23:56,470 --> 00:24:03,220
expanded outside of the lambda function

00:23:58,900 --> 00:24:05,380
of the lambda body so it's the only

00:24:03,220 --> 00:24:07,840
place in the entire thing where there is

00:24:05,380 --> 00:24:10,810
an expanded pack so this should expand

00:24:07,840 --> 00:24:15,520
to a pack of lambda expressions for

00:24:10,810 --> 00:24:19,720
every type in a variant that extracts

00:24:15,520 --> 00:24:24,610
the value from the variant and prints it

00:24:19,720 --> 00:24:27,580
out and then we create a an array of

00:24:24,610 --> 00:24:30,510
function pointers to those lambdas since

00:24:27,580 --> 00:24:34,200
we don't capture anything those lambdas

00:24:30,510 --> 00:24:38,830
implicitly decay to function pointers

00:24:34,200 --> 00:24:40,660
and using that call table we just call

00:24:38,830 --> 00:24:46,080
the appropriate function post passing

00:24:40,660 --> 00:24:54,000
the variant in this is great this works

00:24:46,080 --> 00:24:56,680
almost if you look back at the slides

00:24:54,000 --> 00:25:00,790
and look at the name of the guy who

00:24:56,680 --> 00:25:03,250
reported the previous year you will

00:25:00,790 --> 00:25:06,790
notice it's the same guy and I know that

00:25:03,250 --> 00:25:13,960
still probably knows the name I expect

00:25:06,790 --> 00:25:17,080
so so this time there is no happy ending

00:25:13,960 --> 00:25:19,720
because as far as I am aware and I think

00:25:17,080 --> 00:25:25,900
I checked yesterday the back the back

00:25:19,720 --> 00:25:29,710
isn't fixed in GCC and the errormsgs GCC

00:25:25,900 --> 00:25:32,320
gives are really confusing because they

00:25:29,710 --> 00:25:36,910
basically say the same thing as for the

00:25:32,320 --> 00:25:39,460
attempt of expanding a pack of function

00:25:36,910 --> 00:25:45,370
calls just as a statement it says oh

00:25:39,460 --> 00:25:47,230
here you have an expanded pack and at

00:25:45,370 --> 00:25:54,940
the end of the lambda word ellipsis is

00:25:47,230 --> 00:25:58,360
it says there is no pack to expand so

00:25:54,940 --> 00:26:01,430
it's very confusing and but thankfully

00:25:58,360 --> 00:26:04,040
we can make a workaround for this and

00:26:01,430 --> 00:26:07,940
having read some implementations of

00:26:04,040 --> 00:26:11,800
variant that use out of line visitors

00:26:07,940 --> 00:26:14,570
and having read my now my own

00:26:11,800 --> 00:26:16,760
implementation of variant that uses in

00:26:14,570 --> 00:26:19,100
line visitors even with all the

00:26:16,760 --> 00:26:22,280
boilerplate that the workaround to make

00:26:19,100 --> 00:26:24,500
this work in GCC requires I still think

00:26:22,280 --> 00:26:27,830
this is worth it because you don't have

00:26:24,500 --> 00:26:30,440
to jump across multiple places to see

00:26:27,830 --> 00:26:34,000
what is actually going on and it's kind

00:26:30,440 --> 00:26:39,650
of easier to pull up the code I think

00:26:34,000 --> 00:26:42,950
all right so we'll use this guy it's an

00:26:39,650 --> 00:26:45,760
identity meta function it just it's

00:26:42,950 --> 00:26:51,140
supposed to be used as a value that

00:26:45,760 --> 00:26:54,080
passes the type together with it so the

00:26:51,140 --> 00:26:56,420
previous function when turned into a

00:26:54,080 --> 00:26:59,410
version that compiles with GCC looks

00:26:56,420 --> 00:26:59,410
something like this

00:27:01,420 --> 00:27:08,450
the general idea is the same only now

00:27:05,450 --> 00:27:11,600
the line that creates the type audience

00:27:08,450 --> 00:27:15,530
is slightly uglier like type name deckle

00:27:11,600 --> 00:27:19,340
type type type there appears to be

00:27:15,530 --> 00:27:22,790
slightly too many instances of the word

00:27:19,340 --> 00:27:25,730
type on that line but you write this

00:27:22,790 --> 00:27:31,250
once then you copy paste it everywhere

00:27:25,730 --> 00:27:33,740
it's not that bad I'm serious okay so

00:27:31,250 --> 00:27:36,320
generator is a generic lambda that takes

00:27:33,740 --> 00:27:40,250
the that takes an argument the argument

00:27:36,320 --> 00:27:43,960
will be an instance of the meta function

00:27:40,250 --> 00:27:46,670
that we saw on the previous slide and

00:27:43,960 --> 00:27:49,309
then we return a lamp that does

00:27:46,670 --> 00:27:52,150
basically the same thing so the generic

00:27:49,309 --> 00:27:56,780
lamp that just provides a context to

00:27:52,150 --> 00:27:59,620
allow an easier extraction of the single

00:27:56,780 --> 00:28:05,170
type from the type rack and then we call

00:27:59,620 --> 00:28:12,550
generator for every type in the variant

00:28:05,170 --> 00:28:16,060
with an object of type ID of T's is this

00:28:12,550 --> 00:28:24,260
comprehensible to everyone

00:28:16,060 --> 00:28:26,510
all right so at some point I was given a

00:28:24,260 --> 00:28:32,060
question whether those two are

00:28:26,510 --> 00:28:36,500
equivalent like whether to work around

00:28:32,060 --> 00:28:41,000
for GCC introduces any costs no it

00:28:36,500 --> 00:28:43,730
doesn't just function pointers and the

00:28:41,000 --> 00:28:48,070
return value of generator is an empty

00:28:43,730 --> 00:28:52,580
type and if you were at a one of the

00:28:48,070 --> 00:28:56,840
optimizers talks it was I think two days

00:28:52,580 --> 00:28:59,480
ago there was an example of a lobby MRI

00:28:56,840 --> 00:29:02,900
were returning a lambda basically

00:28:59,480 --> 00:29:04,820
returns void it just conveys type

00:29:02,900 --> 00:29:07,780
information and since that's all that's

00:29:04,820 --> 00:29:11,780
required to get the function pointer

00:29:07,780 --> 00:29:16,010
there's no work overhead although there

00:29:11,780 --> 00:29:17,750
is one interesting thing so as I said

00:29:16,010 --> 00:29:26,330
there's going to be some assembly in the

00:29:17,750 --> 00:29:29,780
slides let's take this program it does

00:29:26,330 --> 00:29:31,580
basically the same thing like it's not

00:29:29,780 --> 00:29:33,920
important how exactly it's implemented

00:29:31,580 --> 00:29:42,560
it uses the same technique to print the

00:29:33,920 --> 00:29:44,920
size of if or I'd rather element of the

00:29:42,560 --> 00:29:49,340
park of the arguments of fool where I

00:29:44,920 --> 00:29:51,770
passed at one time and I in main is

00:29:49,340 --> 00:29:54,530
volatile because otherwise in some in

00:29:51,770 --> 00:30:01,160
some situations the compiler got way too

00:29:54,530 --> 00:30:03,170
smart okay so I mentioned context

00:30:01,160 --> 00:30:05,300
problem that's before so context for

00:30:03,170 --> 00:30:11,860
lambdas have been implemented in GCC

00:30:05,300 --> 00:30:16,160
seven and the output from rhesus is six

00:30:11,860 --> 00:30:18,920
is something like this so for those of

00:30:16,160 --> 00:30:24,050
you who don't read assembly the first

00:30:18,920 --> 00:30:27,810
three repeating blocks are the lambdas

00:30:24,050 --> 00:30:31,050
for every type so the first one prints

00:30:27,810 --> 00:30:33,390
because that's the size of event the

00:30:31,050 --> 00:30:36,240
second one prints four because that's

00:30:33,390 --> 00:30:38,340
the size of float and the last one

00:30:36,240 --> 00:30:42,930
prints eight because that's the size of

00:30:38,340 --> 00:30:45,420
of double next we have main we have code

00:30:42,930 --> 00:30:49,470
for main so first we set up the stack

00:30:45,420 --> 00:30:51,180
then we set up the volatile variable we

00:30:49,470 --> 00:30:54,570
are using and the next one we are doing

00:30:51,180 --> 00:30:58,910
is the next one the compiler is doing

00:30:54,570 --> 00:31:01,970
their it's fetching the guard variable

00:30:58,910 --> 00:31:04,860
for the static array inside the function

00:31:01,970 --> 00:31:09,600
because function local static variables

00:31:04,860 --> 00:31:13,710
in C++ are fret safe with regards to

00:31:09,600 --> 00:31:17,330
initialization so there is a guarantee

00:31:13,710 --> 00:31:20,370
that no two threads will initialize the

00:31:17,330 --> 00:31:22,410
variable at the same time so it's

00:31:20,370 --> 00:31:25,350
checking whether the write has been

00:31:22,410 --> 00:31:27,360
initialized if it has not been

00:31:25,350 --> 00:31:31,020
initialized it makes a jump and

00:31:27,360 --> 00:31:35,010
otherwise it follows we've just a call

00:31:31,020 --> 00:31:41,310
to the appropriate function and returns

00:31:35,010 --> 00:31:47,610
from main next it first acquires a mutex

00:31:41,310 --> 00:31:51,300
basically checks whether the variable

00:31:47,610 --> 00:31:56,870
was initialized in the meantime if it

00:31:51,300 --> 00:31:59,250
has been and it just turns over to the

00:31:56,870 --> 00:32:05,120
code that actually does something

00:31:59,250 --> 00:32:05,120
otherwise it initializes the array and

00:32:05,450 --> 00:32:09,740
drums to the code that actually does

00:32:07,710 --> 00:32:12,780
something all right

00:32:09,740 --> 00:32:16,500
that's not very bad after the first

00:32:12,780 --> 00:32:19,920
school like it's not nice but we can

00:32:16,500 --> 00:32:22,920
live with this only there is a better

00:32:19,920 --> 00:32:25,740
code that's generated for this one note

00:32:22,920 --> 00:32:29,910
is that clunk generates basically the

00:32:25,740 --> 00:32:34,140
same code only it uses sim D for

00:32:29,910 --> 00:32:37,070
initialization of the table this is the

00:32:34,140 --> 00:32:40,530
output from GCC seven

00:32:37,070 --> 00:32:44,010
this time into almost fits on the slide

00:32:40,530 --> 00:32:52,190
so it generates the functions and then

00:32:44,010 --> 00:32:58,410
it calls the functions it can statically

00:32:52,190 --> 00:33:00,720
initialize an array and I think this is

00:32:58,410 --> 00:33:06,030
directly related to the fact that

00:33:00,720 --> 00:33:10,410
lambdas in C++ 17 are implicitly

00:33:06,030 --> 00:33:12,660
contacts per whenever possible but do

00:33:10,410 --> 00:33:15,600
note that I did not have to change the

00:33:12,660 --> 00:33:19,350
code to say con sex per on the array of

00:33:15,600 --> 00:33:25,520
function pointers so this is very nice I

00:33:19,350 --> 00:33:25,520
hope it comes to clang soon like soon I

00:33:25,820 --> 00:33:36,390
like this all right we have some

00:33:33,300 --> 00:33:40,020
techniques that we can use and we are

00:33:36,390 --> 00:33:47,400
going to use mostly the last one to

00:33:40,020 --> 00:33:53,220
implement a variant type there is this

00:33:47,400 --> 00:33:56,640
guy in the standard library and it's

00:33:53,220 --> 00:33:58,770
useful for providing storage for a value

00:33:56,640 --> 00:34:04,320
of a type without actually declaring

00:33:58,770 --> 00:34:07,680
about a variable of the type so the

00:34:04,320 --> 00:34:11,640
number one source of bugs related to a

00:34:07,680 --> 00:34:18,410
line storage is the fact that you have

00:34:11,640 --> 00:34:24,030
to write colon colon type I did this on

00:34:18,410 --> 00:34:27,390
numerous occasions it's easy to forget

00:34:24,030 --> 00:34:30,470
so thankfully there is an alias in

00:34:27,390 --> 00:34:30,470
surplus was 14 I think

00:34:35,830 --> 00:34:41,610
yes I can hear you

00:34:44,890 --> 00:34:52,710
what is the failure mode if I forget to

00:34:48,940 --> 00:34:55,990
write tyfa okay there is no compiler no

00:34:52,710 --> 00:34:58,330
this structure is a structure it's an

00:34:55,990 --> 00:35:01,660
empty structure so it has a size of 1

00:34:58,330 --> 00:35:04,390
and then you try to construct an object

00:35:01,660 --> 00:35:07,570
into the storage of the structure of

00:35:04,390 --> 00:35:12,190
size of 1 and your variable is probably

00:35:07,570 --> 00:35:18,870
larger than one so you write outside of

00:35:12,190 --> 00:35:24,990
your class which is not very nice and

00:35:18,870 --> 00:35:27,970
not trivially to debug your roli right

00:35:24,990 --> 00:35:32,920
so this is the basic idea we have a line

00:35:27,970 --> 00:35:36,550
storage for for all the types so we need

00:35:32,920 --> 00:35:40,270
the max we need a line storage with the

00:35:36,550 --> 00:35:43,540
maximum size among all the types and one

00:35:40,270 --> 00:35:45,820
that fits all the alignment requirements

00:35:43,540 --> 00:35:48,310
of all the types that we can store and

00:35:45,820 --> 00:35:51,160
then we have a member that contains the

00:35:48,310 --> 00:36:01,240
index of the currently active member of

00:35:51,160 --> 00:36:04,840
the variant this is the simplest

00:36:01,240 --> 00:36:10,750
constructor that can possibly exist for

00:36:04,840 --> 00:36:14,230
this type we get some value and if that

00:36:10,750 --> 00:36:17,950
value is somewhere amongst the possible

00:36:14,230 --> 00:36:20,650
types we can store inside the variant we

00:36:17,950 --> 00:36:25,810
just construct the type we move

00:36:20,650 --> 00:36:28,330
constructed at the storage we have how

00:36:25,810 --> 00:36:35,980
many of you don't know the new syntax I

00:36:28,330 --> 00:36:40,420
used here everybody knows it good you

00:36:35,980 --> 00:36:43,090
raise your hands for we don't notice all

00:36:40,420 --> 00:36:48,670
right so this basically takes a pointer

00:36:43,090 --> 00:36:50,109
and constructs the object in the storage

00:36:48,670 --> 00:36:53,039
that's pointed to

00:36:50,109 --> 00:36:55,509
that pointer it's implemented as a

00:36:53,039 --> 00:37:03,180
overload of the operator new that just

00:36:55,509 --> 00:37:03,180
returns the argument all right

00:37:03,989 --> 00:37:10,359
the copy constructor there's of course

00:37:07,079 --> 00:37:14,410
I'm going to ignore such weird things

00:37:10,359 --> 00:37:18,730
like exception safety for the purpose of

00:37:14,410 --> 00:37:22,420
the slides and I'm going to ignore such

00:37:18,730 --> 00:37:25,539
things like move operations so this is

00:37:22,420 --> 00:37:29,970
all in the beautiful world where

00:37:25,539 --> 00:37:32,739
everything succeeds and copies are cheap

00:37:29,970 --> 00:37:36,569
all right so this is basically the same

00:37:32,739 --> 00:37:43,470
trick with lambdas that will be before

00:37:36,569 --> 00:37:43,470
together with the workaround for for GCC

00:37:46,499 --> 00:37:54,640
we drop the object from inside the other

00:37:49,599 --> 00:38:12,819
variant we construct a copy at our own

00:37:54,640 --> 00:38:14,739
storage is this understood yes I can't

00:38:12,819 --> 00:38:18,880
hear you can you use the microphones for

00:38:14,739 --> 00:38:21,700
any questions because to avoid shouting

00:38:18,880 --> 00:38:26,440
why are you repeating this code and not

00:38:21,700 --> 00:38:29,019
simply calling visit function but the

00:38:26,440 --> 00:38:33,480
generic lambda the visit function says

00:38:29,019 --> 00:38:36,730
you will write the next slide I guess a

00:38:33,480 --> 00:38:40,779
visit function that I call F map and I

00:38:36,730 --> 00:38:43,509
will have in two slides you can instead

00:38:40,779 --> 00:38:46,180
of writing oh this is the implementation

00:38:43,509 --> 00:38:49,769
of something that is pretty much almost

00:38:46,180 --> 00:38:52,299
the same as standard variant and

00:38:49,769 --> 00:38:57,039
everything that that's around the

00:38:52,299 --> 00:38:59,970
standard variant so you could also ask a

00:38:57,039 --> 00:39:02,470
question why am i reimplemented variant

00:38:59,970 --> 00:39:03,589
the answer to that is because I don't

00:39:02,470 --> 00:39:07,160
like the empties

00:39:03,589 --> 00:39:08,959
inside the variant and some the lack of

00:39:07,160 --> 00:39:12,469
the requirements in the standard variant

00:39:08,959 --> 00:39:14,599
but that's not that's not important okay

00:39:12,469 --> 00:39:19,640
this is coffee construction so copy

00:39:14,599 --> 00:39:21,529
assignment is slightly longer and we

00:39:19,640 --> 00:39:23,989
have to do double dispatch because we

00:39:21,529 --> 00:39:29,239
have two variants then okay then K can

00:39:23,989 --> 00:39:31,969
have two different active members this

00:39:29,239 --> 00:39:38,329
is the only point where the workaround

00:39:31,969 --> 00:39:46,959
for GCC gets really not nice because it

00:39:38,329 --> 00:39:50,180
adds like six lines of code but whatever

00:39:46,959 --> 00:39:56,140
and again this is completely ignoring

00:39:50,180 --> 00:39:58,729
exception safety because once you try to

00:39:56,140 --> 00:40:03,529
remember about the exceptions it's it

00:39:58,729 --> 00:40:06,439
gets way more complex so third this is

00:40:03,529 --> 00:40:08,269
copy assignments we first distract the

00:40:06,439 --> 00:40:14,569
element we are holding and then we

00:40:08,269 --> 00:40:19,400
construct a new n we cannot really copy

00:40:14,569 --> 00:40:21,920
assign the objects we could do that only

00:40:19,400 --> 00:40:25,459
the types held by both variants were the

00:40:21,920 --> 00:40:28,299
same but that's weird special cases that

00:40:25,459 --> 00:40:28,299
we don't need

00:40:33,819 --> 00:40:43,089
distraction pretty much the same it just

00:40:35,949 --> 00:40:46,150
called instructor and there's two more

00:40:43,089 --> 00:40:52,660
functions that are useful the first one

00:40:46,150 --> 00:40:55,569
is get cooled get there's many different

00:40:52,660 --> 00:40:59,199
things you can do when they when they

00:40:55,569 --> 00:41:02,709
get is invalid I chose to I chose to

00:40:59,199 --> 00:41:07,079
throw an exception I guess sometimes you

00:41:02,709 --> 00:41:09,579
might want to terminate instead like I

00:41:07,079 --> 00:41:16,359
have no idea what the standard variant

00:41:09,579 --> 00:41:23,109
is doing when this happens I don't know

00:41:16,359 --> 00:41:30,789
I would have to check and the last

00:41:23,109 --> 00:41:33,880
function where I do this last time there

00:41:30,789 --> 00:41:36,459
was a lengthy discussion whether the

00:41:33,880 --> 00:41:39,759
name of the function is correct or not I

00:41:36,459 --> 00:41:45,029
would appreciate if we could not repeat

00:41:39,759 --> 00:41:45,029
that discussion here thank you

00:41:45,719 --> 00:41:51,910
lies he had the proper the the result of

00:41:50,440 --> 00:41:54,910
the discussion was that the proper name

00:41:51,910 --> 00:41:59,410
for the function would be any map but

00:41:54,910 --> 00:42:03,400
that's a command-line utility so no so

00:41:59,410 --> 00:42:05,650
result-type i have to compute beforehand

00:42:03,400 --> 00:42:09,339
it's going to be a variant that's able

00:42:05,650 --> 00:42:12,160
to hold a value of any of the types that

00:42:09,339 --> 00:42:15,670
can possibly arise from calling the

00:42:12,160 --> 00:42:17,619
function on a type inside the variant if

00:42:15,670 --> 00:42:23,559
we are interested in how this actually

00:42:17,619 --> 00:42:26,380
looks I can show you so when we have the

00:42:23,559 --> 00:42:31,989
result type we just do basically the

00:42:26,380 --> 00:42:34,539
same thing only this time only this time

00:42:31,989 --> 00:42:39,430
the functions that we are using will

00:42:34,539 --> 00:42:44,229
actually return a value that we have to

00:42:39,430 --> 00:42:46,720
return from this function and for the

00:42:44,229 --> 00:42:51,910
full implementation of all that I have

00:42:46,720 --> 00:42:54,280
my variant you can go there or if you

00:42:51,910 --> 00:42:57,220
are interested in it I can show it to

00:42:54,280 --> 00:43:00,359
you and that's all the slides I have

00:42:57,220 --> 00:43:00,359

YouTube URL: https://www.youtube.com/watch?v=Os5YLB5D2BU


