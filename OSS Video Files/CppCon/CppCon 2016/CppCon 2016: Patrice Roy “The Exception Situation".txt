Title: CppCon 2016: Patrice Roy “The Exception Situation"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Exceptions have been a part of C++ for a long time now, and they are not going away. They allow programmers to concentrate on the meaningful parts of their code and treat the things that happen infrequently as… well, exceptional situations, to be dealt with when and where the context makes it reasonable or useful.

On the other hand, some significant parts of the C++ programming community either dislike this mechanism or outright reject it, for a number of reasons. Work in SG14 has raised performance issues in some cases; there are those who dislike the additional execution paths introduced in programs that rely on exceptions; some programmers raised issues with respect to exceptions and tooling, integration with older codebases, writing robust generic code, etc.

This talk will be neither for not against exceptions. It will present a perspective on cases where they make sense, cases where they are less appropriate, alternative disappointment handling techniques presented along with client code in order to show how the various approaches influence the way code is written. Performance measurements will be given along the way. Some creative uses of exceptions will also be presented in order to spark ideas and discussions in the room.
— 
Patrice Roy
Université de Sherbrooke
Professor
Sherbrooke (Québec), Canada
Patrice Roy has been playing with C++, either professionally, for pleasure or (most of the time) both for over 20 years. After a few years doing R&D and working on military flight simulators, he moved on to academics and has been teaching computer science since 1998. Since 2005, he’s been involved more specifically in helping graduate students and professionals from the fields of real-time systems and game programming develop the skills they need to face today’s challenges. The rapid evolution of C++ in recent years has made his job even more enjoyable. He’s been a participating member in the ISO C++ Standards Committee since late 2014 and has been involved with the ISO Programming Language Vulnerabilities since late 2015. He has five kids, and his wife ensures their house is home to a continuously changing number of cats, dogs and other animals.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,009
so welcome welcome to this big and/or

00:00:03,120 --> 00:00:07,440
easy room with me I might be making

00:00:05,009 --> 00:00:09,840
noise with my my voice from time to time

00:00:07,440 --> 00:00:12,150
that's out of habit my name is Betty

00:00:09,840 --> 00:00:12,480
Suarez not my first name that's my last

00:00:12,150 --> 00:00:15,150
name

00:00:12,480 --> 00:00:17,520
and I work at ginger such a book and at

00:00:15,150 --> 00:00:19,410
Kadesh in Yahoo a college where I come

00:00:17,520 --> 00:00:22,500
from around Montreal around the Montreal

00:00:19,410 --> 00:00:24,750
area Who am I now some of you might know

00:00:22,500 --> 00:00:28,590
me already those who don't I have a few

00:00:24,750 --> 00:00:30,599
kills and a few animals I used to do

00:00:28,590 --> 00:00:32,640
flights a fight simulator software

00:00:30,599 --> 00:00:34,140
before I started teaching but that was a

00:00:32,640 --> 00:00:37,649
while ago because I've been teaching for

00:00:34,140 --> 00:00:39,899
about 18 years now and what else yeah I

00:00:37,649 --> 00:00:41,670
work a lot with the games people which

00:00:39,899 --> 00:00:43,530
led me to this talk to be honest because

00:00:41,670 --> 00:00:46,070
the games depaul they hear it exceptions

00:00:43,530 --> 00:00:49,559
with a passion some of them at least and

00:00:46,070 --> 00:00:51,629
some of them and they're not alone

00:00:49,559 --> 00:00:53,430
some of you IRA gets in the room to do

00:00:51,629 --> 00:00:54,930
that too I don't hate exceptions as

00:00:53,430 --> 00:00:57,719
you'll see but I can understand the

00:00:54,930 --> 00:00:59,850
concerns so we have a strange situation

00:00:57,719 --> 00:01:02,609
C++ where we kind of depend on this

00:00:59,850 --> 00:01:06,090
mechanism that is both very useful and

00:01:02,609 --> 00:01:08,670
lacks love it needs more love these days

00:01:06,090 --> 00:01:11,850
so what am i planning to do today with

00:01:08,670 --> 00:01:13,470
you well since I'm involved with LG 14

00:01:11,850 --> 00:01:14,909
where we're studying alternatives to

00:01:13,470 --> 00:01:18,659
exceptions for those who don't like them

00:01:14,909 --> 00:01:20,970
and since I'm working also at the ISO

00:01:18,659 --> 00:01:22,710
C++ standards committee where we we care

00:01:20,970 --> 00:01:26,670
about that thing and since I'm also

00:01:22,710 --> 00:01:31,650
working at the WG 23 ISO group which is

00:01:26,670 --> 00:01:35,460
interested in security and robust

00:01:31,650 --> 00:01:38,430
software well I'm concerned by all this

00:01:35,460 --> 00:01:40,979
so the cost of exceptions the reasons

00:01:38,430 --> 00:01:43,829
why we use them don't the reasons what

00:01:40,979 --> 00:01:46,409
we understand or not about it so this is

00:01:43,829 --> 00:01:49,590
not a pro or con exception talk I'm

00:01:46,409 --> 00:01:51,329
going to try to see how it works what it

00:01:49,590 --> 00:01:54,420
does what it doesn't and what are the

00:01:51,329 --> 00:01:56,369
alternatives what are the costs in terms

00:01:54,420 --> 00:01:57,930
of speed but also in terms of because I

00:01:56,369 --> 00:02:00,149
have numbers but I really felt have the

00:01:57,930 --> 00:02:04,049
time to show them I make them available

00:02:00,149 --> 00:02:08,039
to you guys I in terms of programming

00:02:04,049 --> 00:02:09,390
effort also and maybe if I have the time

00:02:08,039 --> 00:02:11,220
a few a few dirty tricks because

00:02:09,390 --> 00:02:13,440
exceptions are funny sometimes if you're

00:02:11,220 --> 00:02:15,360
a creative person and

00:02:13,440 --> 00:02:16,950
and there might be things I show you

00:02:15,360 --> 00:02:18,390
that you won't want to bring back to

00:02:16,950 --> 00:02:22,830
your office which is okay you'll keep

00:02:18,390 --> 00:02:25,950
them with you as in here so when I wrote

00:02:22,830 --> 00:02:27,600
this proposal for a talk this is

00:02:25,950 --> 00:02:29,970
essentially what I wrote so if you read

00:02:27,600 --> 00:02:32,040
that that's why you're here right now so

00:02:29,970 --> 00:02:33,810
this says exceptions are part of C++

00:02:32,040 --> 00:02:35,760
right now I don't think they're going

00:02:33,810 --> 00:02:38,460
away I really doubt it they might change

00:02:35,760 --> 00:02:39,960
they might change we might have quality

00:02:38,460 --> 00:02:41,520
of implementation issues right now they

00:02:39,960 --> 00:02:44,460
might not be fast enough for some

00:02:41,520 --> 00:02:46,050
purposes there are segments of the

00:02:44,460 --> 00:02:47,580
community that don't long why I want it

00:02:46,050 --> 00:02:49,290
but this is that going away we have to

00:02:47,580 --> 00:02:51,540
find ways to make it work better for

00:02:49,290 --> 00:02:53,910
these we have to work on the interface

00:02:51,540 --> 00:02:56,340
between the exception aware exception

00:02:53,910 --> 00:02:58,170
blind code so there's words go we're

00:02:56,340 --> 00:03:04,230
going on and it's g14 is part of the

00:02:58,170 --> 00:03:08,730
effort then exceptions lets you focus on

00:03:04,230 --> 00:03:12,630
the meaningful they take the effort

00:03:08,730 --> 00:03:14,040
involved with error handling away from

00:03:12,630 --> 00:03:15,750
the core of your code we're

00:03:14,040 --> 00:03:18,060
concentrating on the real stuff and

00:03:15,750 --> 00:03:19,320
bring it to a location where you can

00:03:18,060 --> 00:03:21,959
actually manage it and think about it

00:03:19,320 --> 00:03:24,540
separately arise they tend to pollute

00:03:21,959 --> 00:03:26,459
the code so that's in itself something

00:03:24,540 --> 00:03:29,640
interesting it helps you program reason

00:03:26,459 --> 00:03:30,930
and debug and they're not meant to occur

00:03:29,640 --> 00:03:32,190
very often in they're meant to be

00:03:30,930 --> 00:03:33,959
exceptional that's the reason for their

00:03:32,190 --> 00:03:36,600
name if they occur often you're not

00:03:33,959 --> 00:03:39,750
using the right and running mechanism

00:03:36,600 --> 00:03:41,370
there are others okay so the ID we die

00:03:39,750 --> 00:03:43,140
behind that thing is that when you go to

00:03:41,370 --> 00:03:46,680
the tribe lock it's expected to be

00:03:43,140 --> 00:03:48,720
relatively fast it might be faster it

00:03:46,680 --> 00:03:50,459
may be it should and when you link to

00:03:48,720 --> 00:03:51,630
the cache block you kind of assume it's

00:03:50,459 --> 00:03:54,030
going to be slow but you don't mind

00:03:51,630 --> 00:03:55,680
because it's not supposed to happen and

00:03:54,030 --> 00:03:57,840
where it happens well you have things to

00:03:55,680 --> 00:03:59,459
do and some people think when you're

00:03:57,840 --> 00:04:02,450
using exceptions you should try and

00:03:59,459 --> 00:04:04,410
catch in fact you rarely do you should

00:04:02,450 --> 00:04:05,730
that's the whole point you shouldn't

00:04:04,410 --> 00:04:07,590
care about it unless you really have

00:04:05,730 --> 00:04:09,600
something to do I'll try to another

00:04:07,590 --> 00:04:13,590
examples of that later on today that's

00:04:09,600 --> 00:04:15,600
my my goal at least so what you could

00:04:13,590 --> 00:04:17,040
see wiki what you can see here is

00:04:15,600 --> 00:04:19,470
essentially essentially what I just said

00:04:17,040 --> 00:04:20,790
there are there are concerns there

00:04:19,470 --> 00:04:22,080
people don't like their people look like

00:04:20,790 --> 00:04:24,300
exceptions because they bring an

00:04:22,080 --> 00:04:26,610
alternative control path to your code

00:04:24,300 --> 00:04:27,360
and they think it makes the code more

00:04:26,610 --> 00:04:29,610
difficult

00:04:27,360 --> 00:04:31,620
to reason about I wouldn't go that far I

00:04:29,610 --> 00:04:33,210
don't think that's true but I think that

00:04:31,620 --> 00:04:34,800
there's some education to be done about

00:04:33,210 --> 00:04:37,020
that and it's not being done so there's

00:04:34,800 --> 00:04:39,719
an effort in terms of the explaining to

00:04:37,020 --> 00:04:41,729
people how to handle that thing that has

00:04:39,719 --> 00:04:44,430
to be done that it's done the books but

00:04:41,729 --> 00:04:46,289
some people do not read them so it's not

00:04:44,430 --> 00:04:48,840
for exceptions today it's not against

00:04:46,289 --> 00:04:50,479
exceptions III use them I'm honest I

00:04:48,840 --> 00:04:53,449
understand the needs of those who don't

00:04:50,479 --> 00:04:55,830
it's the matter of person of perspective

00:04:53,449 --> 00:04:59,789
knowing what the alternatives are and

00:04:55,830 --> 00:05:02,129
what it means for you so here's where we

00:04:59,789 --> 00:05:03,840
go this is the basic example I use when

00:05:02,129 --> 00:05:06,120
I teach exceptions myself to those who

00:05:03,840 --> 00:05:08,610
have not programmed much so it's a very

00:05:06,120 --> 00:05:10,500
naive example but I think it shows well

00:05:08,610 --> 00:05:13,139
what you have to do if you don't use

00:05:10,500 --> 00:05:15,120
them and what you what are the options

00:05:13,139 --> 00:05:17,039
the example is naive but the problem

00:05:15,120 --> 00:05:19,169
isn't so it's a matter of integral

00:05:17,039 --> 00:05:20,550
division where if you divide by 0 of

00:05:19,169 --> 00:05:22,259
course the world is going to collapse

00:05:20,550 --> 00:05:25,819
into a black hole and you will disappear

00:05:22,259 --> 00:05:28,080
along with your family as already knows

00:05:25,819 --> 00:05:29,340
the basic signature is what you have

00:05:28,080 --> 00:05:31,560
there's at the basic interface which is

00:05:29,340 --> 00:05:33,360
much more deep because least I at least

00:05:31,560 --> 00:05:36,180
I gave a tremendous talk about that

00:05:33,360 --> 00:05:38,159
yesterday very very insightful this is

00:05:36,180 --> 00:05:41,580
very nice and you expect to pass a

00:05:38,159 --> 00:05:45,289
numerator and a denominator and get the

00:05:41,580 --> 00:05:47,550
quotient as output ok it's that simple

00:05:45,289 --> 00:05:49,560
so I am calling that the natural

00:05:47,550 --> 00:05:51,449
interface but it's like a pun I know

00:05:49,560 --> 00:05:55,289
that the basic interface something much

00:05:51,449 --> 00:05:57,330
more complex and and you you you of

00:05:55,289 --> 00:05:58,830
course you have to wonder if you pass

00:05:57,330 --> 00:06:00,270
something wrong to that function what

00:05:58,830 --> 00:06:02,520
will happen as I said the black hole

00:06:00,270 --> 00:06:04,020
will occur and you will die but past

00:06:02,520 --> 00:06:06,930
that when you expect to have something

00:06:04,020 --> 00:06:08,219
more insightful to do such cases because

00:06:06,930 --> 00:06:12,060
dying well might not be your first

00:06:08,219 --> 00:06:15,000
option you could say so precognition

00:06:12,060 --> 00:06:16,169
I think it's unbreak Kaminsky and

00:06:15,000 --> 00:06:18,689
although if a browser's name properly

00:06:16,169 --> 00:06:21,599
had a few texts on the internet a few

00:06:18,689 --> 00:06:22,949
years ago stating that we when you write

00:06:21,599 --> 00:06:25,770
the precondition if people break it it's

00:06:22,949 --> 00:06:27,650
their damn fault they should have

00:06:25,770 --> 00:06:30,029
checked before it's their effort

00:06:27,650 --> 00:06:31,050
contracts you could help there's a

00:06:30,029 --> 00:06:33,240
number of things you can tell from the

00:06:31,050 --> 00:06:34,650
outside but if you're saying it's a

00:06:33,240 --> 00:06:38,370
precondition and somebody passes 0

00:06:34,650 --> 00:06:40,110
anyway well get with the deserve now for

00:06:38,370 --> 00:06:40,889
some people that's not satisfying but

00:06:40,110 --> 00:06:43,770
it's

00:06:40,889 --> 00:06:47,370
a reasonable approach somebody who takes

00:06:43,770 --> 00:06:50,039
that stance we have to say that it's a

00:06:47,370 --> 00:06:53,849
valid way of dealing with a thing for

00:06:50,039 --> 00:06:56,340
some domains at least this is the wrong

00:06:53,849 --> 00:06:58,169
way to do things but but it's the one

00:06:56,340 --> 00:06:59,610
you see a lot especially in other

00:06:58,169 --> 00:07:01,289
programming languages where they are

00:06:59,610 --> 00:07:03,449
taught that when you catch an exception

00:07:01,289 --> 00:07:06,270
which you show is you print the stack

00:07:03,449 --> 00:07:08,090
trace and then you leave and you let the

00:07:06,270 --> 00:07:11,729
program in an incorrect state and

00:07:08,090 --> 00:07:13,319
continues running with from values so

00:07:11,729 --> 00:07:15,629
hiding exceptions is not good and

00:07:13,319 --> 00:07:17,069
letting the problem continue it's not

00:07:15,629 --> 00:07:18,810
good either because in this case you're

00:07:17,069 --> 00:07:21,719
screening are something Bad's going on

00:07:18,810 --> 00:07:24,629
you know and then you still die because

00:07:21,719 --> 00:07:27,990
you haven't reactor which is pointless

00:07:24,629 --> 00:07:29,789
three but but to be honest I work with

00:07:27,990 --> 00:07:33,240
many companies I do I teach with

00:07:29,789 --> 00:07:35,699
professionals students undergrads grads

00:07:33,240 --> 00:07:40,289
and this is what I see most which are if

00:07:35,699 --> 00:07:43,740
I seem to be honest but but I do

00:07:40,289 --> 00:07:46,379
recognize that teaching hair and Link

00:07:43,740 --> 00:07:49,259
practices is not being done and if it is

00:07:46,379 --> 00:07:51,629
it's not being done right and I haven't

00:07:49,259 --> 00:07:53,370
seen in my life a real solid course on

00:07:51,629 --> 00:07:57,060
that topic which I should probably put

00:07:53,370 --> 00:07:59,279
them yeah there's other solutions you

00:07:57,060 --> 00:08:01,379
could actually crash voluntarily and

00:07:59,279 --> 00:08:02,550
some people do that the games of all

00:08:01,379 --> 00:08:04,740
that's probably what they would like to

00:08:02,550 --> 00:08:09,689
do they prefer if something bad happens

00:08:04,740 --> 00:08:10,620
to crash recover and go ahead because

00:08:09,689 --> 00:08:12,149
they don't really care that they're

00:08:10,620 --> 00:08:13,439
going to kill anybody if something fails

00:08:12,149 --> 00:08:16,289
they're going to lose customers

00:08:13,439 --> 00:08:18,259
something goes bad so what they want is

00:08:16,289 --> 00:08:21,509
a quick crash say I'm sorry and we start

00:08:18,259 --> 00:08:22,770
so terminates fare assert is probably

00:08:21,509 --> 00:08:24,389
fair especially when you're debugging

00:08:22,770 --> 00:08:25,800
your code because otherwise the you

00:08:24,389 --> 00:08:27,960
might be in trouble

00:08:25,800 --> 00:08:29,250
abort terminate exists whatever so

00:08:27,960 --> 00:08:31,229
something that says something went

00:08:29,250 --> 00:08:34,620
really wrong and let's quit it let's

00:08:31,229 --> 00:08:37,140
hope it doesn't ship as such but

00:08:34,620 --> 00:08:41,219
somebody's whose application domain

00:08:37,140 --> 00:08:44,039
allows this could make this into a valid

00:08:41,219 --> 00:08:45,329
way of treating the problem it's not

00:08:44,039 --> 00:08:46,949
treating a problem but at least the

00:08:45,329 --> 00:08:50,730
program is not continuing with wrong

00:08:46,949 --> 00:08:53,100
data this is another one it's a bit

00:08:50,730 --> 00:08:53,940
radical you die there's an a certain you

00:08:53,100 --> 00:08:56,850
die when up

00:08:53,940 --> 00:08:59,880
mmm and at least you have a message

00:08:56,850 --> 00:09:02,730
outputting I guess so it's a right way

00:08:59,880 --> 00:09:04,350
to do things and from the outside well

00:09:02,730 --> 00:09:05,940
the interface is respected and you're

00:09:04,350 --> 00:09:08,370
cutting the function you have nothing

00:09:05,940 --> 00:09:09,720
special to do and normally it works and

00:09:08,370 --> 00:09:12,990
if it doesn't work while you're dead

00:09:09,720 --> 00:09:15,240
would you accept that but that's ok as

00:09:12,990 --> 00:09:16,950
long as it's something you accept it's

00:09:15,240 --> 00:09:20,520
part of your mental contract it's ok

00:09:16,950 --> 00:09:22,530
sir so people do that III can't find

00:09:20,520 --> 00:09:28,140
fault with it as long as their domain is

00:09:22,530 --> 00:09:31,200
not subdomain cars or airplanes this is

00:09:28,140 --> 00:09:33,150
another way to do it it's very C ish but

00:09:31,200 --> 00:09:36,180
it's not invalid we need lots of API is

00:09:33,150 --> 00:09:38,100
do that or things to that effect meaning

00:09:36,180 --> 00:09:40,880
that if you have an API that users see

00:09:38,100 --> 00:09:43,770
like stuff come for example or others

00:09:40,880 --> 00:09:46,230
you you can throw exceptions so you're

00:09:43,770 --> 00:09:48,870
going to add arguments either as return

00:09:46,230 --> 00:09:50,940
value simulated because you're going to

00:09:48,870 --> 00:09:53,670
return status codes or you're going to

00:09:50,940 --> 00:09:56,820
put a status code as an argument it's

00:09:53,670 --> 00:09:59,040
equivalent so this is that it you see

00:09:56,820 --> 00:10:00,780
that it works I mean you do your test

00:09:59,040 --> 00:10:01,770
you return some arbitrary value in this

00:10:00,780 --> 00:10:03,390
case because you don't really care

00:10:01,770 --> 00:10:05,970
because people should be checking the

00:10:03,390 --> 00:10:08,820
status before doing anything meaningful

00:10:05,970 --> 00:10:10,550
fair ok as long as you check because the

00:10:08,820 --> 00:10:13,680
problem in this case is they might not

00:10:10,550 --> 00:10:16,530
but no-go works for like this it returns

00:10:13,680 --> 00:10:18,510
stuff that you can ignore it works see

00:10:16,530 --> 00:10:23,130
works like this it's been working for a

00:10:18,510 --> 00:10:25,110
long while so it's not bad it's ugly in

00:10:23,130 --> 00:10:26,460
terms of style the problem is you have

00:10:25,110 --> 00:10:27,810
to change your interface and make it

00:10:26,460 --> 00:10:31,230
look like something else than what it is

00:10:27,810 --> 00:10:33,420
now you're adding an argument that has

00:10:31,230 --> 00:10:35,640
no bearing on the semantics what you're

00:10:33,420 --> 00:10:38,190
trying to convey so you're stuck with

00:10:35,640 --> 00:10:41,760
something that is awkward it's not wrong

00:10:38,190 --> 00:10:42,900
it works but you feel the really when

00:10:41,760 --> 00:10:48,240
you do that then you need to go take a

00:10:42,900 --> 00:10:50,520
shower it's true it's true but it does

00:10:48,240 --> 00:10:52,230
work it has been proven like to work in

00:10:50,520 --> 00:10:54,120
many cases I mean we have operating

00:10:52,230 --> 00:10:57,089
systems that rely on those techniques

00:10:54,120 --> 00:11:00,600
and that work that's ok and the other

00:10:57,089 --> 00:11:02,490
way to do this is to return the the

00:11:00,600 --> 00:11:04,020
status code I use the bull in this case

00:11:02,490 --> 00:11:06,660
but to release more complex and decimal

00:11:04,020 --> 00:11:07,769
new or whatever and you get your return

00:11:06,660 --> 00:11:10,619
value as an argument

00:11:07,769 --> 00:11:12,989
what come does it uses a pointer because

00:11:10,619 --> 00:11:13,679
it's see what is the same thing so if

00:11:12,989 --> 00:11:17,759
you look at this

00:11:13,679 --> 00:11:20,009
well you again as a valid program where

00:11:17,759 --> 00:11:23,100
you check the result from your function

00:11:20,009 --> 00:11:24,899
and should the result be okay and then

00:11:23,100 --> 00:11:26,699
you take the argument otherwise you know

00:11:24,899 --> 00:11:28,259
the argument not to be making sense

00:11:26,699 --> 00:11:29,970
anyway you're still supposed to do that

00:11:28,259 --> 00:11:32,549
so this programmer discipline gives ugly

00:11:29,970 --> 00:11:34,319
code but you can say it doesn't work

00:11:32,549 --> 00:11:35,549
it's a valid approach and people who

00:11:34,319 --> 00:11:39,029
don't like exceptions you can do that

00:11:35,549 --> 00:11:40,860
and they're gonna write more client code

00:11:39,029 --> 00:11:42,389
sorry that's what's going on with these

00:11:40,860 --> 00:11:43,589
you're going to write bar code you're

00:11:42,389 --> 00:11:45,629
going to do validation all over the

00:11:43,589 --> 00:11:50,249
place but doesn't mean you're off work

00:11:45,629 --> 00:11:52,429
and is that it this is cool - I mean

00:11:50,249 --> 00:11:55,439
this is essentially wet weather go does

00:11:52,429 --> 00:11:57,239
not its language supported but it's okay

00:11:55,439 --> 00:11:59,369
I mean the returning to values could

00:11:57,239 --> 00:12:02,160
return there one of them is the fact

00:11:59,369 --> 00:12:05,129
that network or not and the other one is

00:12:02,160 --> 00:12:06,480
the result it's clean the interface is

00:12:05,129 --> 00:12:08,549
OK by the way you look at the interface

00:12:06,480 --> 00:12:10,139
you pass the arguments you expect and

00:12:08,549 --> 00:12:13,019
you get the result with some additional

00:12:10,139 --> 00:12:15,240
information it doesn't cost much really

00:12:13,019 --> 00:12:16,499
the reason it doesn't cost much with

00:12:15,240 --> 00:12:19,980
respect what you would do normally and

00:12:16,499 --> 00:12:21,839
there cause actually quite cute I mean

00:12:19,980 --> 00:12:23,790
you take it like this you check the

00:12:21,839 --> 00:12:25,769
first part which is your result say and

00:12:23,790 --> 00:12:28,319
if it's okay then you take your the the

00:12:25,769 --> 00:12:30,649
second one it's actually more beautiful

00:12:28,319 --> 00:12:33,089
I think more pretty than the latter two

00:12:30,649 --> 00:12:33,420
don't know what you think but it seems

00:12:33,089 --> 00:12:35,970
better

00:12:33,420 --> 00:12:37,889
it looks better to me at least more

00:12:35,970 --> 00:12:40,679
functional maybe it preserves the

00:12:37,889 --> 00:12:43,160
arguments to their natural state natural

00:12:40,679 --> 00:12:45,869
being what we expect for them to be and

00:12:43,160 --> 00:12:47,429
this is c plus plus seventeen code which

00:12:45,869 --> 00:12:49,889
is actually pretty cool too I mean you

00:12:47,429 --> 00:12:51,990
can D structure your return statement

00:12:49,889 --> 00:12:53,610
into two variables that are actually

00:12:51,990 --> 00:12:56,429
located within your if statement this is

00:12:53,610 --> 00:12:59,519
where they live did I after that so you

00:12:56,429 --> 00:13:01,829
get both the ok state and the result

00:12:59,519 --> 00:13:03,689
state from a single return they are

00:13:01,829 --> 00:13:05,220
decomposing two variables and then you

00:13:03,689 --> 00:13:08,999
can check one of them because right now

00:13:05,220 --> 00:13:10,559
you can do that with c++ 17 that looks

00:13:08,999 --> 00:13:13,290
like go so those would like go

00:13:10,559 --> 00:13:14,519
i-i'll do it file fault with this it

00:13:13,290 --> 00:13:17,490
really looks like what they're used to

00:13:14,519 --> 00:13:19,049
and they find that to be nice so why not

00:13:17,490 --> 00:13:21,320
you can do that

00:13:19,049 --> 00:13:24,020
get yours nothing wrong with that so

00:13:21,320 --> 00:13:25,190
okay so far and if you say I want that

00:13:24,020 --> 00:13:27,260
this is a good teacher you're right

00:13:25,190 --> 00:13:28,640
schoolteachers or C++ 17 we have

00:13:27,260 --> 00:13:30,020
compiler writers in the room we love

00:13:28,640 --> 00:13:33,980
them when we hope for them to do a good

00:13:30,020 --> 00:13:35,420
job I see them this is an eruption you

00:13:33,980 --> 00:13:36,910
can return an optional we're going to

00:13:35,420 --> 00:13:40,190
have an STD optional in the language

00:13:36,910 --> 00:13:41,780
like any time now maybe I'm guessing

00:13:40,190 --> 00:13:44,600
some compiler some libraries already app

00:13:41,780 --> 00:13:46,580
that so optional is in a variable that's

00:13:44,600 --> 00:13:50,030
either either has something or doesn't

00:13:46,580 --> 00:13:51,440
it's testable as such I think I use the

00:13:50,030 --> 00:13:53,510
right syntax because my compare isn't

00:13:51,440 --> 00:13:55,940
supported yet but it essentially works

00:13:53,510 --> 00:13:57,290
like this if you're if you cannot do a

00:13:55,940 --> 00:14:00,350
job you return something it is

00:13:57,290 --> 00:14:02,270
recognizably false in this case it's the

00:14:00,350 --> 00:14:03,650
default optional it's wrong otherwise

00:14:02,270 --> 00:14:07,160
return an optional that contains

00:14:03,650 --> 00:14:08,780
something why not and then if you look

00:14:07,160 --> 00:14:11,050
at the result it actually looks good and

00:14:08,780 --> 00:14:14,350
you take your variable you test it and

00:14:11,050 --> 00:14:17,540
if the test succeeds you check the value

00:14:14,350 --> 00:14:19,880
it's a dual interface within a single

00:14:17,540 --> 00:14:21,020
object it's pretty cute it works yeah

00:14:19,880 --> 00:14:22,700
there's many ways to do things without

00:14:21,020 --> 00:14:24,710
exceptions you don't care about them and

00:14:22,700 --> 00:14:30,140
they're all essentially equivalent in

00:14:24,710 --> 00:14:32,060
terms of costs you could do this suite

00:14:30,140 --> 00:14:34,520
to with is equal to 17 because you can

00:14:32,060 --> 00:14:36,410
make sure that your optional variable

00:14:34,520 --> 00:14:38,360
only lives in the scope of the if as

00:14:36,410 --> 00:14:41,810
long as if you want to keep the result

00:14:38,360 --> 00:14:43,250
afterwards you let it out somehow but if

00:14:41,810 --> 00:14:47,420
you want to encapsulate your tests in

00:14:43,250 --> 00:14:49,850
your if statement can do that now cool

00:14:47,420 --> 00:14:52,520
okay so this is the persuasive and Tina

00:14:49,850 --> 00:14:54,860
actually I actually hope for that these

00:14:52,520 --> 00:14:56,420
features are very nice you can do it

00:14:54,860 --> 00:14:58,640
with an expected expected it's kind of

00:14:56,420 --> 00:15:01,070
an optional extended but that there's no

00:14:58,640 --> 00:15:02,480
standard accepted in sequence or 17

00:15:01,070 --> 00:15:05,540
there's a proposal on table on the table

00:15:02,480 --> 00:15:09,200
the idea is the value or something else

00:15:05,540 --> 00:15:10,460
I've got I'd that the color chose so you

00:15:09,200 --> 00:15:12,470
can have an error code you can have many

00:15:10,460 --> 00:15:14,270
things so the color is essentially this

00:15:12,470 --> 00:15:15,770
is like an optional where you can have

00:15:14,270 --> 00:15:17,660
something else on a boo it's called that

00:15:15,770 --> 00:15:19,670
way so it's a generalizations pretty

00:15:17,660 --> 00:15:21,890
cute so in this case and using a an

00:15:19,670 --> 00:15:22,760
empty class as return type should a

00:15:21,890 --> 00:15:25,040
problem occur

00:15:22,760 --> 00:15:26,990
it's a divided by 0 kind of thing and

00:15:25,040 --> 00:15:28,460
otherwise I have the result and you can

00:15:26,990 --> 00:15:29,930
do something like that too if you want

00:15:28,460 --> 00:15:31,250
yeah it's assuming that the result is

00:15:29,930 --> 00:15:35,560
testable which is not the case in this

00:15:31,250 --> 00:15:39,830
case but it looks like optional code and

00:15:35,560 --> 00:15:42,020
something like this suppose there's a

00:15:39,830 --> 00:15:46,490
tweak missing for the beaudion state not

00:15:42,020 --> 00:15:49,370
much and you can throw it's crazy you

00:15:46,490 --> 00:15:51,920
can actually use this exception and if

00:15:49,370 --> 00:15:55,040
there's a problem you use no problem and

00:15:51,920 --> 00:15:56,120
now what do you throw is because you

00:15:55,040 --> 00:15:57,110
can't manage a problem you don't know

00:15:56,120 --> 00:15:58,850
what the context is

00:15:57,110 --> 00:16:01,100
you can display something where you

00:15:58,850 --> 00:16:03,950
display it the graphical display is that

00:16:01,100 --> 00:16:05,000
something made with text it is the word

00:16:03,950 --> 00:16:08,210
falling apart

00:16:05,000 --> 00:16:10,160
is it a spaceship falling down so you

00:16:08,210 --> 00:16:11,270
don't know so because of that you need

00:16:10,160 --> 00:16:12,800
to take some action and your action is

00:16:11,270 --> 00:16:15,680
to signal the problem you can't process

00:16:12,800 --> 00:16:18,260
it you can't go forward you don't have

00:16:15,680 --> 00:16:19,700
the information to do a correct job and

00:16:18,260 --> 00:16:22,160
you don't have the information to

00:16:19,700 --> 00:16:24,940
actually do something about it

00:16:22,160 --> 00:16:27,440
the other thing you can do is say yeah

00:16:24,940 --> 00:16:29,480
so you don't cover up your code you keep

00:16:27,440 --> 00:16:31,490
it safe you keep it okay and you throw

00:16:29,480 --> 00:16:33,400
it when I'm giving a class or actually

00:16:31,490 --> 00:16:35,690
throwing things at people that works and

00:16:33,400 --> 00:16:37,370
then they take it and they throw it back

00:16:35,690 --> 00:16:38,840
you know as a school because the ping

00:16:37,370 --> 00:16:41,660
pong thing is essentially what's going

00:16:38,840 --> 00:16:43,760
on for real at some point it ends up in

00:16:41,660 --> 00:16:46,460
somebody's ends but it doesn't have to

00:16:43,760 --> 00:16:48,170
you don't process it I know what happens

00:16:46,460 --> 00:16:52,070
if you throw something and nobody

00:16:48,170 --> 00:16:53,840
catches you die but that's right that's

00:16:52,070 --> 00:16:58,400
what you some people want to do anyway

00:16:53,840 --> 00:16:59,690
if you don't care this is perfect if you

00:16:58,400 --> 00:17:01,040
don't care about managing the problem

00:16:59,690 --> 00:17:03,620
well you have nothing to do what you

00:17:01,040 --> 00:17:05,510
want to do is crash loudly and you want

00:17:03,620 --> 00:17:08,600
to debug your code fix it and ship it

00:17:05,510 --> 00:17:11,000
without bugs so that's actually good

00:17:08,600 --> 00:17:12,290
behavior you're not supposed to swallow

00:17:11,000 --> 00:17:14,060
the exceptions you're supposed to either

00:17:12,290 --> 00:17:15,970
do something about them or crash and fix

00:17:14,060 --> 00:17:18,980
the bug so that it doesn't happen again

00:17:15,970 --> 00:17:21,140
so that's the correct thing to do if you

00:17:18,980 --> 00:17:22,339
don't catch an exception anywhere that's

00:17:21,140 --> 00:17:24,230
been thrown somewhere in your program

00:17:22,339 --> 00:17:26,690
and your compiler notices it the

00:17:24,230 --> 00:17:31,240
compiler can tell Terminix but that's

00:17:26,690 --> 00:17:34,970
okay we expect that so far so good ok so

00:17:31,240 --> 00:17:38,660
this is actually cute we have the normal

00:17:34,970 --> 00:17:40,730
code we do nothing special it's the

00:17:38,660 --> 00:17:42,920
original interface it's the correct

00:17:40,730 --> 00:17:45,740
behavior it's efficiently it's

00:17:42,920 --> 00:17:48,680
essentially as if someone was broking

00:17:45,740 --> 00:17:51,460
the precondition condition and I

00:17:48,680 --> 00:17:53,530
in some cases which is expected and

00:17:51,460 --> 00:17:56,330
there's no try and there's no catch

00:17:53,530 --> 00:17:58,160
which which is one of the point here so

00:17:56,330 --> 00:18:00,200
many people hate that because say I'm

00:17:58,160 --> 00:18:02,810
going to clutter my code the tries and

00:18:00,200 --> 00:18:04,220
catches know you won't know you won't

00:18:02,810 --> 00:18:05,210
you won't do that you're going to do

00:18:04,220 --> 00:18:07,820
that if you have something to do about

00:18:05,210 --> 00:18:11,990
it what would I do here apart from

00:18:07,820 --> 00:18:13,340
saying oh them okay - I might try some

00:18:11,990 --> 00:18:14,540
user input again and again and again

00:18:13,340 --> 00:18:20,180
maybe that's what I really want to do

00:18:14,540 --> 00:18:21,260
otherwise you know okay so first people

00:18:20,180 --> 00:18:23,390
festive and think of the cute there

00:18:21,260 --> 00:18:25,120
because you can actually make sure that

00:18:23,390 --> 00:18:27,470
your variables live inside your AF scope

00:18:25,120 --> 00:18:29,890
that's cute it's just because I I'm

00:18:27,470 --> 00:18:33,530
really looking forward to suppose 470

00:18:29,890 --> 00:18:35,140
okay so far so in in most cases there's

00:18:33,530 --> 00:18:37,820
no point catching

00:18:35,140 --> 00:18:38,960
try blacks are fast catch blocks are

00:18:37,820 --> 00:18:40,730
slow but you have to do something about

00:18:38,960 --> 00:18:44,300
it if you have nothing to you don't do

00:18:40,730 --> 00:18:45,230
it and and if you catch you not

00:18:44,300 --> 00:18:47,930
necessary you have to handle the

00:18:45,230 --> 00:18:50,450
exception but sometimes what's going on

00:18:47,930 --> 00:18:51,770
is you cut the problem not because you

00:18:50,450 --> 00:18:53,270
want to manage it because you're

00:18:51,770 --> 00:18:53,720
responsible for something you have to

00:18:53,270 --> 00:18:56,000
clean up

00:18:53,720 --> 00:18:57,800
you are gated some resources that will

00:18:56,000 --> 00:18:59,540
not be destroyed that we wrote the code

00:18:57,800 --> 00:19:01,160
because you're in a constructor

00:18:59,540 --> 00:19:03,310
somewhere and Co secure hasn't completed

00:19:01,160 --> 00:19:05,180
so the destructor will pass or something

00:19:03,310 --> 00:19:08,690
so you have to do something you have to

00:19:05,180 --> 00:19:10,550
close a file you have to whatever rei

00:19:08,690 --> 00:19:12,500
helps of course in these cases but

00:19:10,550 --> 00:19:14,300
should you be doing some ramen and

00:19:12,500 --> 00:19:16,340
memory management sometimes well you

00:19:14,300 --> 00:19:18,530
want to catch just just for a little

00:19:16,340 --> 00:19:20,630
amount of time because you want to do

00:19:18,530 --> 00:19:22,790
some cleaning up repairing the things

00:19:20,630 --> 00:19:27,470
you've broken and then you're there to

00:19:22,790 --> 00:19:29,480
go go as is you don't hide it say I

00:19:27,470 --> 00:19:31,730
catch something and I throw a whatever

00:19:29,480 --> 00:19:34,550
nano you you let it get out the way you

00:19:31,730 --> 00:19:37,340
got it because you haven't finished it

00:19:34,550 --> 00:19:38,750
so you want the ones will actually be

00:19:37,340 --> 00:19:40,940
able to do something about it do you

00:19:38,750 --> 00:19:42,560
know what occurred if it's an SQL

00:19:40,940 --> 00:19:44,300
exception of some kind let it be

00:19:42,560 --> 00:19:47,560
it's rather memory you better know about

00:19:44,300 --> 00:19:47,560
this question

00:19:59,789 --> 00:20:06,009
well if you do that you're going to I'd

00:20:02,649 --> 00:20:07,809
what occurred so yeah well if this is

00:20:06,009 --> 00:20:09,579
your use case there's always the use

00:20:07,809 --> 00:20:12,159
case for everything we're in C++ there's

00:20:09,579 --> 00:20:14,200
no feature that has no use be honest but

00:20:12,159 --> 00:20:16,659
it would mean my my default reaction

00:20:14,200 --> 00:20:18,820
because if you if there's been a

00:20:16,659 --> 00:20:19,899
security problem somewhere and you're

00:20:18,820 --> 00:20:21,399
returning something of a higher level

00:20:19,899 --> 00:20:22,929
and there's no way to know the details

00:20:21,399 --> 00:20:31,119
of the security problem you're going to

00:20:22,929 --> 00:20:32,709
have trouble managing it okay in that

00:20:31,119 --> 00:20:34,690
sense but that would be an interesting

00:20:32,709 --> 00:20:37,659
case in these so the my friend here was

00:20:34,690 --> 00:20:39,309
saying if the lower level thing hides

00:20:37,659 --> 00:20:41,559
the details because you got to divide by

00:20:39,309 --> 00:20:43,359
zero but you don't know why and at some

00:20:41,559 --> 00:20:45,219
higher level in your management of the

00:20:43,359 --> 00:20:46,239
problem you're catching that the reason

00:20:45,219 --> 00:20:48,159
why you're do you have a divide by zero

00:20:46,239 --> 00:20:49,899
is that there's an overall security

00:20:48,159 --> 00:20:51,639
problem should you raise a security

00:20:49,899 --> 00:20:53,079
problem yeah you should now in general

00:20:51,639 --> 00:20:55,269
you want it you want to let it filter

00:20:53,079 --> 00:20:56,889
but to be honest there is always a

00:20:55,269 --> 00:20:59,559
reason for everything in C++ so you

00:20:56,889 --> 00:21:03,129
always use your mind a guideline is not

00:20:59,559 --> 00:21:05,559
a replacement for thinking thank you any

00:21:03,129 --> 00:21:06,969
other comment Michael Casey would say

00:21:05,559 --> 00:21:08,769
the same thing if you've been to this

00:21:06,969 --> 00:21:10,809
class would tell you well it's cool to

00:21:08,769 --> 00:21:12,369
do to be told do this or do that

00:21:10,809 --> 00:21:17,589
but the one thing you should not stop

00:21:12,369 --> 00:21:19,149
doing its thing so thank you okay and if

00:21:17,589 --> 00:21:20,769
you got something and you couldn't do

00:21:19,149 --> 00:21:23,529
anything about it you just add something

00:21:20,769 --> 00:21:25,539
to to to clean well it's near ends you

00:21:23,529 --> 00:21:28,419
you just throw it back somebody will

00:21:25,539 --> 00:21:30,070
catch a different well there's an

00:21:28,419 --> 00:21:31,450
example there that's taken from one of

00:21:30,070 --> 00:21:33,789
the classes I gave last weekend it's

00:21:31,450 --> 00:21:36,519
it's tightened a bit it's it's a

00:21:33,789 --> 00:21:38,049
generator ring I won't show the whole

00:21:36,519 --> 00:21:39,369
code just just some piece of it it's a

00:21:38,049 --> 00:21:41,529
very very simple thing where I'm doing

00:21:39,369 --> 00:21:44,799
manual memory management I have a t-star

00:21:41,529 --> 00:21:46,799
you see that and if you look at I have a

00:21:44,799 --> 00:21:49,119
pointer to the first element number of

00:21:46,799 --> 00:21:50,649
an integer for a number of elements and

00:21:49,119 --> 00:21:52,719
integer for the capacity is very simple

00:21:50,649 --> 00:21:55,149
stuff so there's from the beginning to

00:21:52,719 --> 00:21:58,329
some place you have data and from that

00:21:55,149 --> 00:22:00,519
place arm you have let's say empty

00:21:58,329 --> 00:22:03,010
objects it's a naive thing good better

00:22:00,519 --> 00:22:04,810
and there's a number of my

00:22:03,010 --> 00:22:06,700
functions like size and capacity adjust

00:22:04,810 --> 00:22:10,260
work and do what you expect and you can

00:22:06,700 --> 00:22:13,600
see there the no accept thing that says

00:22:10,260 --> 00:22:16,540
that if either won't throw or if it

00:22:13,600 --> 00:22:18,190
throws you're dead because you just

00:22:16,540 --> 00:22:24,840
broke the contract there was a noise

00:22:18,190 --> 00:22:27,010
there yeah damn why they make me fit

00:22:24,840 --> 00:22:28,450
because it's a mistake in my part so I'm

00:22:27,010 --> 00:22:29,590
going to fix the slide thank you I did

00:22:28,450 --> 00:22:31,150
that this morning because I wanted to

00:22:29,590 --> 00:22:32,680
have an example so there's the cap the

00:22:31,150 --> 00:22:35,110
suppose we turn there Thank You dick man

00:22:32,680 --> 00:22:37,450
so that but that's just a typo from a

00:22:35,110 --> 00:22:39,040
copy copy paste thing so everyone

00:22:37,450 --> 00:22:41,860
understands that it's cap okay thank you

00:22:39,040 --> 00:22:44,620
Becky I'm gonna fix up the slides aren't

00:22:41,860 --> 00:22:46,390
yet in the folder so it's all going to

00:22:44,620 --> 00:22:56,170
stay between us and nobody will know

00:22:46,390 --> 00:22:57,610
ever so so you can have some simple

00:22:56,170 --> 00:22:59,530
iterators in this case adjust pointers

00:22:57,610 --> 00:23:01,630
just to make the code simple fair enough

00:22:59,530 --> 00:23:04,060
all those operations are know except by

00:23:01,630 --> 00:23:06,520
the way because they're if you're using

00:23:04,060 --> 00:23:08,500
your thing and somebody's calling

00:23:06,520 --> 00:23:09,370
returning a null pointer and doing

00:23:08,500 --> 00:23:11,740
something wrong with it

00:23:09,370 --> 00:23:13,750
it's not your problem and you don't have

00:23:11,740 --> 00:23:17,320
to throw something they should be using

00:23:13,750 --> 00:23:21,010
a low pointer it's their problem and I

00:23:17,320 --> 00:23:22,870
put this push back there in both fix the

00:23:21,010 --> 00:23:24,850
reason being that it becomes interesting

00:23:22,870 --> 00:23:26,590
at this stage it's a naive thing okay

00:23:24,850 --> 00:23:27,970
because all the extras in the room will

00:23:26,590 --> 00:23:32,140
notice that memory management is very

00:23:27,970 --> 00:23:34,330
basic the the if they're seeing if the

00:23:32,140 --> 00:23:36,700
container is full because if it's full

00:23:34,330 --> 00:23:40,480
we need more space the capacity is taken

00:23:36,700 --> 00:23:42,850
and growing my micro because we're going

00:23:40,480 --> 00:23:44,470
to allocate memory we're going to copy

00:23:42,850 --> 00:23:47,890
objects around in this case because it's

00:23:44,470 --> 00:23:49,720
naive and we're cutting T's and copying

00:23:47,890 --> 00:23:53,140
it T well it might do anything you don't

00:23:49,720 --> 00:23:55,630
know where it is and I locating memory

00:23:53,140 --> 00:23:57,850
could throw possibly it makes sense and

00:23:55,630 --> 00:24:01,590
you make notice that there's two lines

00:23:57,850 --> 00:24:04,180
after that there's the copying of arg2 a

00:24:01,590 --> 00:24:06,850
position in the array that is now big

00:24:04,180 --> 00:24:09,520
enough to contain it I know that I know

00:24:06,850 --> 00:24:11,560
that because if grow failed I'm not

00:24:09,520 --> 00:24:13,390
going to the next step so by definition

00:24:11,560 --> 00:24:14,920
by construction if I go to that

00:24:13,390 --> 00:24:16,960
assignment line I have enough memory to

00:24:14,920 --> 00:24:18,280
put the art yeah

00:24:16,960 --> 00:24:20,170
and then I'm incrementing the variable

00:24:18,280 --> 00:24:22,810
and you can see that I did these two

00:24:20,170 --> 00:24:24,850
things in two steps I didn't do size for

00:24:22,810 --> 00:24:27,370
an amps plus plus within the brackets in

00:24:24,850 --> 00:24:31,360
the third line to make sure that the

00:24:27,370 --> 00:24:33,190
assignment which could throw if it

00:24:31,360 --> 00:24:36,370
throws I'm not incrementing the number

00:24:33,190 --> 00:24:39,670
of events otherwise I will get an

00:24:36,370 --> 00:24:44,680
incoherent container which is not seem

00:24:39,670 --> 00:24:47,470
to be a good thing in most circles there

00:24:44,680 --> 00:24:50,140
was noise in the audience so that the

00:24:47,470 --> 00:24:51,730
way it's done there and I did that naive

00:24:50,140 --> 00:24:53,350
grow in this case it's very naive

00:24:51,730 --> 00:24:56,350
because it doesn't work it's broken and

00:24:53,350 --> 00:24:57,880
I solve both bikes so it's not saying

00:24:56,350 --> 00:24:59,110
where it's wrong but this is the

00:24:57,880 --> 00:25:02,560
function I'm going to look at right now

00:24:59,110 --> 00:25:07,420
and and there's so many ways this could

00:25:02,560 --> 00:25:09,760
go wrong you did it the first thing it

00:25:07,420 --> 00:25:12,520
could go wrong is the new array of T

00:25:09,760 --> 00:25:16,360
there so on that line beautiful

00:25:12,520 --> 00:25:19,300
I could I could have a allocation

00:25:16,360 --> 00:25:21,040
failure because it's too big of an array

00:25:19,300 --> 00:25:23,100
we have a block of memory to allocate

00:25:21,040 --> 00:25:26,260
given the resources I have at that point

00:25:23,100 --> 00:25:27,880
and not only that but I could have a

00:25:26,260 --> 00:25:30,580
number of exceptions because I'm

00:25:27,880 --> 00:25:34,510
constructing naively many T's in that

00:25:30,580 --> 00:25:37,750
array at least new cap and exactly new

00:25:34,510 --> 00:25:38,620
cap and each of these constructors could

00:25:37,750 --> 00:25:41,230
throw because I don't know what it's

00:25:38,620 --> 00:25:42,850
doing it's a tune so it might be a

00:25:41,230 --> 00:25:46,360
string a vector of three objects or

00:25:42,850 --> 00:25:48,640
whatever music database components

00:25:46,360 --> 00:25:51,580
whatever so so that but is that sailed

00:25:48,640 --> 00:25:54,340
around here it's not my problem

00:25:51,580 --> 00:25:57,640
yeah if that fails my container still

00:25:54,340 --> 00:26:00,310
okay my science isn't changed my my

00:25:57,640 --> 00:26:02,260
capacity hasn't changed my point to the

00:26:00,310 --> 00:26:03,180
first element is still the same it's not

00:26:02,260 --> 00:26:06,280
my problem

00:26:03,180 --> 00:26:09,520
so if it fails you know what the error

00:26:06,280 --> 00:26:12,910
will get out and go to whomever might

00:26:09,520 --> 00:26:14,470
want to manage it should be that's the

00:26:12,910 --> 00:26:17,590
beauty of exceptions it's not my problem

00:26:14,470 --> 00:26:19,600
it becomes my problem after new because

00:26:17,590 --> 00:26:22,860
at that point if something happens so

00:26:19,600 --> 00:26:25,150
it's in my ants I requested it I got it

00:26:22,860 --> 00:26:28,360
but but you might be saying well nothing

00:26:25,150 --> 00:26:29,250
bad will happen well the things happen

00:26:28,360 --> 00:26:30,870
well

00:26:29,250 --> 00:26:34,140
this is a this is not a problem because

00:26:30,870 --> 00:26:34,680
failure I don't care it this is not a

00:26:34,140 --> 00:26:37,380
problem

00:26:34,680 --> 00:26:39,570
this is this one sale okay destructors

00:26:37,380 --> 00:26:41,070
with that throw your program is already

00:26:39,570 --> 00:26:43,770
dead so you have other problems

00:26:41,070 --> 00:26:45,750
you won't recover from that so that's

00:26:43,770 --> 00:26:49,980
pretty much okay can't do anything about

00:26:45,750 --> 00:26:51,990
it don't worry this is a problem though

00:26:49,980 --> 00:26:55,170
because copy is making assignments of

00:26:51,990 --> 00:26:56,310
T's to T's which is an operation I don't

00:26:55,170 --> 00:26:58,200
know the thing about because I don't

00:26:56,310 --> 00:27:00,450
know what T is so each of these

00:26:58,200 --> 00:27:01,860
assignments could throw so this is where

00:27:00,450 --> 00:27:03,510
I have to protect myself because should

00:27:01,860 --> 00:27:06,840
that thing should death think from

00:27:03,510 --> 00:27:09,240
something then I'm stuck I'm going to

00:27:06,840 --> 00:27:10,980
leak and it's not the memory I'm going

00:27:09,240 --> 00:27:14,220
to leak that's bothering me in this case

00:27:10,980 --> 00:27:16,770
it's the fact that each of the T objects

00:27:14,220 --> 00:27:20,310
could be ending some resources that are

00:27:16,770 --> 00:27:23,040
very precious like credit cards but made

00:27:20,310 --> 00:27:28,500
suspicious to you but in my life plays a

00:27:23,040 --> 00:27:31,230
role so this is what I don't want to let

00:27:28,500 --> 00:27:32,670
as is should something fail because it's

00:27:31,230 --> 00:27:36,990
something fails there then I have a

00:27:32,670 --> 00:27:38,520
problem okay so so so now but now I

00:27:36,990 --> 00:27:40,140
decide to try a block it's becoming

00:27:38,520 --> 00:27:42,180
bigger but that's the thing you have to

00:27:40,140 --> 00:27:44,010
think about you know it's just very very

00:27:42,180 --> 00:27:46,710
case where there's a problem with this

00:27:44,010 --> 00:27:48,600
one I'm putting my gloves there and

00:27:46,710 --> 00:27:50,970
being careful because if something fails

00:27:48,600 --> 00:27:52,290
what I have to at least clean up the

00:27:50,970 --> 00:27:54,630
memory allocator than the objects are

00:27:52,290 --> 00:27:57,180
created and that's pretty much we can do

00:27:54,630 --> 00:27:58,410
I can do more than that and I don't know

00:27:57,180 --> 00:28:01,410
what being thrown that's why I use the

00:27:58,410 --> 00:28:03,960
cache nothing I use that because it's it

00:28:01,410 --> 00:28:05,700
could be anything but it doesn't matter

00:28:03,960 --> 00:28:07,460
I'm not ending the problem I'm just

00:28:05,700 --> 00:28:10,380
catching it along the way like this

00:28:07,460 --> 00:28:11,640
doing things as it screaming and moving

00:28:10,380 --> 00:28:14,390
like that that's a point long how did it

00:28:11,640 --> 00:28:17,250
go that's perfect

00:28:14,390 --> 00:28:22,650
alright do what I've done night job and

00:28:17,250 --> 00:28:23,940
somebody else will do it's all my job is

00:28:22,650 --> 00:28:27,930
done my container is intact

00:28:23,940 --> 00:28:30,260
I haven't clicked anything I'm okay so

00:28:27,930 --> 00:28:30,260
far so good

00:28:30,440 --> 00:28:34,220
of course I can do better because I they

00:28:32,630 --> 00:28:39,530
are REI I that's so cool

00:28:34,220 --> 00:28:42,230
so should I put my newly constructed

00:28:39,530 --> 00:28:45,110
array in a unique pointer which becomes

00:28:42,230 --> 00:28:48,730
then responsible for your resource well

00:28:45,110 --> 00:28:51,860
when I do my copy thereafter if it fails

00:28:48,730 --> 00:28:53,270
my container is still intact and my

00:28:51,860 --> 00:28:56,990
resources won't leak because unique

00:28:53,270 --> 00:28:59,620
pointer will die variable bath there

00:28:56,990 --> 00:29:02,060
will be blood and fire and like legs but

00:28:59,620 --> 00:29:02,660
the right thing is I'm not losing

00:29:02,060 --> 00:29:05,810
anything

00:29:02,660 --> 00:29:10,130
and once the copies been performed the

00:29:05,810 --> 00:29:12,320
rest of it is at no risk so I'm doing my

00:29:10,130 --> 00:29:13,400
small things taking the pointy roadway

00:29:12,320 --> 00:29:15,910
from the unique pointer because it's

00:29:13,400 --> 00:29:19,160
done its job it's held it nicely for me

00:29:15,910 --> 00:29:22,690
to let me write clean code that goes a

00:29:19,160 --> 00:29:26,470
very short it's actually very clean it's

00:29:22,690 --> 00:29:29,900
actually very fast and I'm that doing

00:29:26,470 --> 00:29:31,970
try-catch or other kind of exception

00:29:29,900 --> 00:29:35,570
ending is just being done on its own

00:29:31,970 --> 00:29:38,600
there's no leak so exception and link

00:29:35,570 --> 00:29:45,170
doesn't have to be complicated making

00:29:38,600 --> 00:29:47,720
incense okay good so Aria I really saves

00:29:45,170 --> 00:29:49,250
you REI is so cool but you have to be

00:29:47,720 --> 00:29:51,110
careful okay because I wasn't ending

00:29:49,250 --> 00:29:52,820
anything in this case and should no one

00:29:51,110 --> 00:29:56,510
be ending anything well the standard

00:29:52,820 --> 00:29:58,700
says things standards do that they say

00:29:56,510 --> 00:30:01,280
weird things the more you read that

00:29:58,700 --> 00:30:02,530
thing the more you feel strange thank

00:30:01,280 --> 00:30:05,240
you

00:30:02,530 --> 00:30:08,150
so if you read this it says in some

00:30:05,240 --> 00:30:10,160
situations the ending must be abandoned

00:30:08,150 --> 00:30:12,430
for less subtle errors and then there

00:30:10,160 --> 00:30:14,960
are situations and you're saying well

00:30:12,430 --> 00:30:16,310
after company completing the

00:30:14,960 --> 00:30:17,720
initialization of the exception object

00:30:16,310 --> 00:30:20,270
well there's many things it could occur

00:30:17,720 --> 00:30:22,430
but there's the case where the exception

00:30:20,270 --> 00:30:23,840
and link mechanism cannot find a handler

00:30:22,430 --> 00:30:26,900
so there is no one catching anything

00:30:23,840 --> 00:30:29,960
ever ever ever again when the compiler

00:30:26,900 --> 00:30:31,430
finds that terminate is called so if

00:30:29,960 --> 00:30:35,420
this is not good for you you can have to

00:30:31,430 --> 00:30:36,710
put a try-catch somewhere and there's

00:30:35,420 --> 00:30:40,610
other things there that give you the

00:30:36,710 --> 00:30:43,340
rules the if you had no except and

00:30:40,610 --> 00:30:43,690
someone through or if someone through a

00:30:43,340 --> 00:30:47,289
No

00:30:43,690 --> 00:30:49,659
one cut ever the implementation is

00:30:47,289 --> 00:30:50,460
allowed not to clean up anything can

00:30:49,659 --> 00:30:54,250
just go away

00:30:50,460 --> 00:30:55,419
so if it matters to you you might want

00:30:54,250 --> 00:30:57,940
to put at least a try-catch somewhere in

00:30:55,419 --> 00:30:59,169
your main just just to make sure because

00:30:57,940 --> 00:31:01,090
otherwise you're going to have a quick

00:30:59,169 --> 00:31:02,980
exit which is probably what you wanted

00:31:01,090 --> 00:31:04,090
but should it should want the global

00:31:02,980 --> 00:31:06,549
variable don't think we can end up

00:31:04,090 --> 00:31:09,690
properly you might want to be a bit

00:31:06,549 --> 00:31:12,720
careful but that's about it yeah

00:31:09,690 --> 00:31:16,320
I cut up pieces because it's a big part

00:31:12,720 --> 00:31:19,779
so if we surprised that part at least

00:31:16,320 --> 00:31:22,480
well just been taking message is evil

00:31:19,779 --> 00:31:25,480
and you should be shot no it should be

00:31:22,480 --> 00:31:26,860
shot you should be scolded terminating

00:31:25,480 --> 00:31:29,169
or a certain makes sense in some cases

00:31:26,860 --> 00:31:33,639
you might want to just make a quick log

00:31:29,169 --> 00:31:34,840
die restart that's okay and those

00:31:33,639 --> 00:31:37,000
situations probably shouldn't happen

00:31:34,840 --> 00:31:39,070
just fix your code even in other

00:31:37,000 --> 00:31:41,259
languages I had a talk with a guy a

00:31:39,070 --> 00:31:44,049
c-sharp guy last year told me I never

00:31:41,259 --> 00:31:45,669
let people away in my code with

00:31:44,049 --> 00:31:47,919
exceptions here and there I mean when we

00:31:45,669 --> 00:31:51,309
get exceptions and debugging Moeller we

00:31:47,919 --> 00:31:53,379
fix them and we only keep them for the

00:31:51,309 --> 00:31:54,610
really exceptional cases but it doesn't

00:31:53,379 --> 00:31:57,159
matter that the language support then

00:31:54,610 --> 00:32:03,399
allah-allah it's a bit slower we fix the

00:31:57,159 --> 00:32:05,740
code before we ship and you can alter

00:32:03,399 --> 00:32:07,929
the signature the the piece there comes

00:32:05,740 --> 00:32:10,509
from a tweet then I saw past a few

00:32:07,929 --> 00:32:12,070
months ago where you can use macros

00:32:10,509 --> 00:32:14,820
simplify your code if you change the

00:32:12,070 --> 00:32:19,720
signature it's not necessarily clean or

00:32:14,820 --> 00:32:22,990
Pleasant you need discipline you do not

00:32:19,720 --> 00:32:24,490
miss any it's painful you could return

00:32:22,990 --> 00:32:26,820
rich types like pair up channels

00:32:24,490 --> 00:32:30,610
expected and you can throw an exception

00:32:26,820 --> 00:32:32,470
that's it there's a performance issue

00:32:30,610 --> 00:32:34,690
then there are things you can context

00:32:32,470 --> 00:32:37,600
for away or consider you can use with

00:32:34,690 --> 00:32:39,220
cast express pretty cool terminate exit

00:32:37,600 --> 00:32:44,009
apart for some reason are not comes

00:32:39,220 --> 00:32:47,500
expert okay so those options are round

00:32:44,009 --> 00:32:49,090
you can a the natural version with an

00:32:47,500 --> 00:32:51,909
assert you can actually context for a

00:32:49,090 --> 00:32:54,460
way that's possible it's so in those

00:32:51,909 --> 00:32:56,289
cases you could have the resolution of

00:32:54,460 --> 00:32:57,210
your division at compile time when it's

00:32:56,289 --> 00:33:00,070
reasonable why not

00:32:57,210 --> 00:33:01,450
so you could do that thing where the

00:33:00,070 --> 00:33:05,200
assert will crash if you're doing at run

00:33:01,450 --> 00:33:06,700
time you think like this you cannot

00:33:05,200 --> 00:33:09,059
consider wait because they're wrecking

00:33:06,700 --> 00:33:11,679
into a pass by reference

00:33:09,059 --> 00:33:14,859
so those strategies are out if you want

00:33:11,679 --> 00:33:18,509
context / functions that have error

00:33:14,859 --> 00:33:18,509
management this is our lab show

00:33:19,830 --> 00:33:23,979
something it returns a pair is an option

00:33:22,179 --> 00:33:26,739
as long as the types that you're

00:33:23,979 --> 00:33:27,849
returning in your pair fit in with the

00:33:26,739 --> 00:33:29,889
context with paradigm

00:33:27,849 --> 00:33:32,320
yoky did this well actually compiled if

00:33:29,889 --> 00:33:35,769
you use it it works because it's instant

00:33:32,320 --> 00:33:39,639
bulls is very complex parole so that's

00:33:35,769 --> 00:33:41,379
an option and of course this is an

00:33:39,639 --> 00:33:43,690
option but this might surprise people a

00:33:41,379 --> 00:33:46,809
throw is dynamic we're eating now whoa

00:33:43,690 --> 00:33:48,159
calm down cuz expiries not always done

00:33:46,809 --> 00:33:50,679
at compile time it's at compile time

00:33:48,159 --> 00:33:52,989
which makes sense when the really the

00:33:50,679 --> 00:33:55,899
context asks for it in this case well

00:33:52,989 --> 00:33:59,080
it's going to if you pass it arguments

00:33:55,899 --> 00:34:01,840
known at compile time and the

00:33:59,080 --> 00:34:04,149
denominator in this case is not no it's

00:34:01,840 --> 00:34:06,220
not zero while you're going to get your

00:34:04,149 --> 00:34:07,599
computation compile time and if you

00:34:06,220 --> 00:34:09,700
visit zero you're going to getting away

00:34:07,599 --> 00:34:11,639
the computation at runtime or just one

00:34:09,700 --> 00:34:14,079
for depending on your preference but

00:34:11,639 --> 00:34:16,899
they depends on the context but you can

00:34:14,079 --> 00:34:20,799
actually do that that's working you can

00:34:16,899 --> 00:34:24,069
try it of course this is not a play by

00:34:20,799 --> 00:34:24,520
ear plea for for small this loss

00:34:24,069 --> 00:34:29,230
function

00:34:24,520 --> 00:34:30,879
it's pointless just an example so the

00:34:29,230 --> 00:34:33,940
point is you take your problem in a

00:34:30,879 --> 00:34:35,200
place where you don't know know where

00:34:33,940 --> 00:34:38,200
you don't know if you can actually

00:34:35,200 --> 00:34:41,169
manage it in this case the context is

00:34:38,200 --> 00:34:42,700
not loaned to the called function and

00:34:41,169 --> 00:34:45,609
you want to push it away

00:34:42,700 --> 00:34:48,669
how much do exceptions or doubt do

00:34:45,609 --> 00:34:51,069
errors pollute your normal path

00:34:48,669 --> 00:34:54,250
well the when there was the site between

00:34:51,069 --> 00:34:58,450
nukes and and Dijkstra way back when I

00:34:54,250 --> 00:35:00,970
wasn't born about go to or no-go tools

00:34:58,450 --> 00:35:02,799
Knuth was suggesting it we kept keep go

00:35:00,970 --> 00:35:04,930
twos at least to push the are ending

00:35:02,799 --> 00:35:06,910
away from the normal control flow so

00:35:04,930 --> 00:35:10,000
this type of thinking has been around

00:35:06,910 --> 00:35:11,170
for a long while now the exceptions

00:35:10,000 --> 00:35:14,559
we're using today are business fair

00:35:11,170 --> 00:35:16,660
by that is so if we look at the

00:35:14,559 --> 00:35:19,630
Excelsior and Ling when you're putting

00:35:16,660 --> 00:35:22,150
it in your neural code well this this

00:35:19,630 --> 00:35:24,880
small thing it's unreadable its sexual

00:35:22,150 --> 00:35:27,599
code that computes two plus three using

00:35:24,880 --> 00:35:31,359
calm on a different machine

00:35:27,599 --> 00:35:32,109
I believe networks have been doing that

00:35:31,359 --> 00:35:35,170
for like 20 years

00:35:32,109 --> 00:35:37,089
the thing is there's so much error and

00:35:35,170 --> 00:35:38,349
Ling it's very very I just exiting when

00:35:37,089 --> 00:35:40,299
there's a problem if there's nothing

00:35:38,349 --> 00:35:41,410
being done essentially there's so much

00:35:40,299 --> 00:35:43,569
error and link that you don't see the

00:35:41,410 --> 00:35:45,730
code anymore and it's not doing much

00:35:43,569 --> 00:35:47,049
it's creating an object I think it argue

00:35:45,730 --> 00:35:50,849
about getting interface testing it

00:35:47,049 --> 00:35:54,089
arguments and showing the result pane

00:35:50,849 --> 00:35:57,250
when I do this the students cry blood

00:35:54,089 --> 00:35:59,740
and all the green stuff that you see

00:35:57,250 --> 00:36:02,530
there it's out all the stuff that's

00:35:59,740 --> 00:36:04,540
pointless well it's not pointless

00:36:02,530 --> 00:36:06,130
because you don't you can't let yours

00:36:04,540 --> 00:36:08,740
break your code but it's all the thing

00:36:06,130 --> 00:36:12,520
that you're doing away from the test

00:36:08,740 --> 00:36:15,369
you're trying to do if you remove it

00:36:12,520 --> 00:36:17,829
well it's it's that more sane not that

00:36:15,369 --> 00:36:18,940
much but it's a bit more sane at least

00:36:17,829 --> 00:36:21,599
you can actually read the characters

00:36:18,940 --> 00:36:24,040
from the room if you make an effort but

00:36:21,599 --> 00:36:26,079
there's a number of hrs there all the

00:36:24,040 --> 00:36:28,059
red things there are the cases where

00:36:26,079 --> 00:36:31,170
we're getting a result that we should

00:36:28,059 --> 00:36:33,700
really be checking all those cases

00:36:31,170 --> 00:36:34,960
change the signature of our code because

00:36:33,700 --> 00:36:36,400
we're not getting the result from the

00:36:34,960 --> 00:36:38,799
function we're getting an error code so

00:36:36,400 --> 00:36:40,089
we have to work around that and there

00:36:38,799 --> 00:36:42,309
are cases where we should be doing more

00:36:40,089 --> 00:36:46,390
because right now if we're not checking

00:36:42,309 --> 00:36:48,099
we might fail and crash so so if we

00:36:46,390 --> 00:36:49,809
clutter everything together yeah you had

00:36:48,099 --> 00:36:54,130
the words so that we had two or three

00:36:49,809 --> 00:36:56,380
slides ago it works what is it the

00:36:54,130 --> 00:37:02,049
easiest way to make your code debuggable

00:36:56,380 --> 00:37:06,010
and usable and not sure the sort of

00:37:02,049 --> 00:37:08,680
sites that thing did you do that here

00:37:06,010 --> 00:37:10,720
interface apart from no except because

00:37:08,680 --> 00:37:13,599
now no except this part of the functions

00:37:10,720 --> 00:37:15,339
interfaces since it has the 17 take a

00:37:13,599 --> 00:37:20,140
function pointer except it's part of

00:37:15,339 --> 00:37:22,119
that the D create alternative code paths

00:37:20,140 --> 00:37:24,640
for the unusual stuff so you can focus

00:37:22,119 --> 00:37:26,640
on real stuff so they don't pollute your

00:37:24,640 --> 00:37:28,599
mago path and this separate

00:37:26,640 --> 00:37:30,390
disappointment the word disappointment

00:37:28,599 --> 00:37:33,400
is one I love it's from Lauren scroll

00:37:30,390 --> 00:37:35,470
who s this who went to DEA's dream of 14

00:37:33,400 --> 00:37:38,380
Martin meaningly thing last year I think

00:37:35,470 --> 00:37:41,559
and I've said well there's so many ways

00:37:38,380 --> 00:37:43,809
exceptions are not errors for so we need

00:37:41,559 --> 00:37:46,740
a word for all those ways to express

00:37:43,809 --> 00:37:48,869
what went wrong in fun disappointments

00:37:46,740 --> 00:37:51,940
right yeah out of it

00:37:48,869 --> 00:37:53,440
it's very pretty so dissipate the

00:37:51,940 --> 00:37:55,750
disappointment handling from

00:37:53,440 --> 00:37:57,789
disappointment this detection and and

00:37:55,750 --> 00:37:59,260
and I haven't stated it so far but they

00:37:57,789 --> 00:38:00,940
can actually be used to signal problems

00:37:59,260 --> 00:38:02,740
from from structure instructors for

00:38:00,940 --> 00:38:06,660
which none of the other things we've

00:38:02,740 --> 00:38:08,859
checked apart room terminate can help us

00:38:06,660 --> 00:38:10,480
that's already something I mean it

00:38:08,859 --> 00:38:12,819
because think about it if you let your

00:38:10,480 --> 00:38:14,140
constructors fail silently you're gonna

00:38:12,819 --> 00:38:15,519
have to check your code all over the

00:38:14,140 --> 00:38:17,109
place because you have no encapsulation

00:38:15,519 --> 00:38:19,990
anymore because you have no object in

00:38:17,109 --> 00:38:23,710
your system we can enforce invariance so

00:38:19,990 --> 00:38:28,440
your code becomes cluttered with some

00:38:23,710 --> 00:38:31,809
people like if statements I don't well

00:38:28,440 --> 00:38:33,279
son so some people don't like it because

00:38:31,809 --> 00:38:34,960
the alternative code path which is a

00:38:33,279 --> 00:38:36,940
good thing for some things people say it

00:38:34,960 --> 00:38:41,440
makes my call hard to reason about where

00:38:36,940 --> 00:38:43,720
there are things going like go to ZAR

00:38:41,440 --> 00:38:46,059
they have none sir none zero cost

00:38:43,720 --> 00:38:48,250
I was trying this morning to put slides

00:38:46,059 --> 00:38:49,869
with numbers on them and I didn't get

00:38:48,250 --> 00:38:51,970
around to it for a time but I do have

00:38:49,869 --> 00:38:54,190
the numbers okay what I did last year

00:38:51,970 --> 00:38:58,150
for those who were with me I I got

00:38:54,190 --> 00:38:59,799
numbers up from small tests on I think I

00:38:58,150 --> 00:39:02,859
used two compilers or maybe three I'm

00:38:59,799 --> 00:39:05,259
not sure where I checked the cost of a

00:39:02,859 --> 00:39:07,690
code that in those problems with returns

00:39:05,259 --> 00:39:09,700
and code that handles problems with

00:39:07,690 --> 00:39:11,980
exceptions in a number of small

00:39:09,700 --> 00:39:13,960
situations including stack unwinding

00:39:11,980 --> 00:39:15,579
where you you have a number of recursive

00:39:13,960 --> 00:39:20,619
calls and objects are being destroyed

00:39:15,579 --> 00:39:22,240
coming back up small strings big strings

00:39:20,619 --> 00:39:25,930
vectors of in terms of things and

00:39:22,240 --> 00:39:28,359
everything and the numbers worse telling

00:39:25,930 --> 00:39:30,130
us the micro benchmarks that we were

00:39:28,359 --> 00:39:31,930
selecting mode with the exception and

00:39:30,130 --> 00:39:34,480
Link cases except in a weird case with

00:39:31,930 --> 00:39:36,789
big strings on Microsoft's

00:39:34,480 --> 00:39:37,839
implementation a very specific one and I

00:39:36,789 --> 00:39:41,739
wouldn't

00:39:37,839 --> 00:39:43,299
bet my life on that special case because

00:39:41,739 --> 00:39:45,579
I've been spending a part of my week

00:39:43,299 --> 00:39:46,900
with the Microsoft people talking about

00:39:45,579 --> 00:39:48,099
the string cases and they're fixing them

00:39:46,900 --> 00:39:49,359
right now so there was something very

00:39:48,099 --> 00:39:50,920
weird in the implementation that is

00:39:49,359 --> 00:39:53,949
going to be okay probably in the next

00:39:50,920 --> 00:39:55,630
release there were some very strange

00:39:53,949 --> 00:39:56,650
things that they are discovering because

00:39:55,630 --> 00:39:58,089
they're playing with string view right

00:39:56,650 --> 00:40:01,479
now and they're reviewing their string

00:39:58,089 --> 00:40:02,859
sing Oh or we did that so so it's going

00:40:01,479 --> 00:40:05,140
to work better I think is going to be

00:40:02,859 --> 00:40:09,430
more stable but the numbers exist so

00:40:05,140 --> 00:40:11,109
I'll publish them and the the as far as

00:40:09,430 --> 00:40:12,549
this morning because I was doing the

00:40:11,109 --> 00:40:15,459
numbers this morning before I came in

00:40:12,549 --> 00:40:18,039
the we're still exceptions are still

00:40:15,459 --> 00:40:21,640
being outperformed by rewritten code in

00:40:18,039 --> 00:40:24,910
almost all cases I checked clang clang

00:40:21,640 --> 00:40:27,069
on Windows em SVC and GCC but to be

00:40:24,910 --> 00:40:28,989
honest some of them are remote things so

00:40:27,069 --> 00:40:31,119
I looked at the Machine specs there's

00:40:28,989 --> 00:40:33,279
variation in the quality of the results

00:40:31,119 --> 00:40:36,069
but internally for each compiler it's

00:40:33,279 --> 00:40:37,209
coherent that's the thing so there's

00:40:36,069 --> 00:40:41,049
still work to do it doesn't mean that

00:40:37,209 --> 00:40:44,589
means we might be doing things better in

00:40:41,049 --> 00:40:45,969
Oulu this summer in June I had a chat

00:40:44,589 --> 00:40:47,979
with the GCP people and they were

00:40:45,969 --> 00:40:49,509
telling me that one of the reasons that

00:40:47,979 --> 00:40:51,579
their implementation of efficient is

00:40:49,509 --> 00:40:54,069
slow that it was written for machines

00:40:51,579 --> 00:40:56,009
that do not exist anymore they were

00:40:54,069 --> 00:40:58,119
written for the machines of

00:40:56,009 --> 00:41:01,029
architectures from maybe 10 or something

00:40:58,119 --> 00:41:03,640
years ago so it probably needs more left

00:41:01,029 --> 00:41:04,539
today to be more in tune with the

00:41:03,640 --> 00:41:06,160
machines we have today

00:41:04,539 --> 00:41:08,130
you don't not applying strategies they

00:41:06,160 --> 00:41:10,479
would apply if they were redoing it

00:41:08,130 --> 00:41:13,329
actually so we might see a change in a

00:41:10,479 --> 00:41:14,189
year or two let's hope that that would

00:41:13,329 --> 00:41:18,759
be better

00:41:14,189 --> 00:41:22,029
so there you when you're at the

00:41:18,759 --> 00:41:24,339
boundaries of code that end those

00:41:22,029 --> 00:41:25,869
exceptions and doesn't result in cutters

00:41:24,339 --> 00:41:27,099
in the room right now as a nice

00:41:25,869 --> 00:41:29,859
technique

00:41:27,099 --> 00:41:31,539
where you can make your code with errors

00:41:29,859 --> 00:41:32,799
converge on one side and exceptions

00:41:31,539 --> 00:41:35,469
converge on the other side you can

00:41:32,799 --> 00:41:37,689
bridge between the two Stephanus Dutoit

00:41:35,469 --> 00:41:39,369
you did the same thing a few years ago

00:41:37,689 --> 00:41:41,289
two years I called them hard life

00:41:39,369 --> 00:41:42,969
functions so are ways to handle those

00:41:41,289 --> 00:41:45,279
situations where you're at the corner

00:41:42,969 --> 00:41:48,069
cases between one world and the other

00:41:45,279 --> 00:41:49,569
it's well-documented because what that's

00:41:48,069 --> 00:41:50,890
one of the problems some people don't

00:41:49,569 --> 00:41:51,640
like exceptions because they're the code

00:41:50,890 --> 00:41:53,710
base

00:41:51,640 --> 00:41:56,020
that has no exception ending and it's

00:41:53,710 --> 00:41:57,160
saying what happens if we throw there's

00:41:56,020 --> 00:41:58,510
so much code out there

00:41:57,160 --> 00:42:03,490
we won't name them but there's big

00:41:58,510 --> 00:42:04,960
companies you can understand that so the

00:42:03,490 --> 00:42:07,090
micro benchmarks of next year they were

00:42:04,960 --> 00:42:09,400
done with which you can see they're a

00:42:07,090 --> 00:42:11,620
number of you the tests that I ran were

00:42:09,400 --> 00:42:16,930
these so generating a number of integers

00:42:11,620 --> 00:42:19,300
from minus 100 to -100 to this five

00:42:16,930 --> 00:42:21,310
billion or something I should tell them

00:42:19,300 --> 00:42:23,830
and then I I played around went through

00:42:21,310 --> 00:42:25,600
all of them and every time I detected a

00:42:23,830 --> 00:42:26,830
negative number that were hundred over

00:42:25,600 --> 00:42:30,190
the the bunch

00:42:26,830 --> 00:42:33,460
i I either returned an error in one case

00:42:30,190 --> 00:42:36,060
or threw something in the other keys so

00:42:33,460 --> 00:42:40,090
the thing is it happens not frequently

00:42:36,060 --> 00:42:43,980
not as a bunch it's spread out so you

00:42:40,090 --> 00:42:46,960
can count it I tried that I tried a

00:42:43,980 --> 00:42:49,300
function that we called recursively many

00:42:46,960 --> 00:42:51,370
many many times at various deaths one

00:42:49,300 --> 00:42:53,080
two three four five up to ten there is

00:42:51,370 --> 00:42:54,520
next up to ten I used to go to three two

00:42:53,080 --> 00:42:57,760
is that the online compilers they only

00:42:54,520 --> 00:42:59,200
give you small time slices and the tests

00:42:57,760 --> 00:43:00,640
were too long so they crashed after ten

00:42:59,200 --> 00:43:01,750
so i reduced it to ten that doesn't

00:43:00,640 --> 00:43:04,060
really matter to be honest because these

00:43:01,750 --> 00:43:06,820
numbers were it stable I was getting

00:43:04,060 --> 00:43:09,010
like very straight curves in all cases

00:43:06,820 --> 00:43:12,790
so it would have just made more numbers

00:43:09,010 --> 00:43:15,130
but not better curves so the thing is I

00:43:12,790 --> 00:43:18,160
am going down and then at some point is

00:43:15,130 --> 00:43:19,870
I don't know it's going wrong so I'm

00:43:18,160 --> 00:43:21,550
returning returning returning returning

00:43:19,870 --> 00:43:24,270
returning so there's a lot of SOA

00:43:21,550 --> 00:43:28,510
returns in one case I'm just throwing

00:43:24,270 --> 00:43:30,940
way back up on your side I was hoping

00:43:28,510 --> 00:43:32,920
doing that that they just throw there

00:43:30,940 --> 00:43:35,500
and catch it every a variant would do a

00:43:32,920 --> 00:43:37,960
good job because stack unwinding is what

00:43:35,500 --> 00:43:39,850
it's built for that sadly enough that's

00:43:37,960 --> 00:43:41,050
not the results that I'm getting so but

00:43:39,850 --> 00:43:43,270
you'll be able to play with the coded

00:43:41,050 --> 00:43:45,940
numbers if you want I'll add the URL in

00:43:43,270 --> 00:43:47,680
the slides today when I have the chance

00:43:45,940 --> 00:43:49,300
and you can pick the PDF and play with

00:43:47,680 --> 00:43:53,160
it there will be a folder with the

00:43:49,300 --> 00:43:53,160
numbers I got and the code that used

00:43:54,420 --> 00:43:57,900
I sense the strings are a special case

00:43:56,700 --> 00:44:00,750
and I could see that the numbers were

00:43:57,900 --> 00:44:02,220
weird on the one compiler at the same

00:44:00,750 --> 00:44:04,890
thing with a vector of chars or a vector

00:44:02,220 --> 00:44:07,320
maker of chars I think and I got similar

00:44:04,890 --> 00:44:09,540
curves okay so the compilers within

00:44:07,320 --> 00:44:11,990
themselves were behaving in a coherent

00:44:09,540 --> 00:44:14,250
manner they could be faster slower but

00:44:11,990 --> 00:44:18,440
there was no case where the exceptions

00:44:14,250 --> 00:44:20,730
were outperforming the return codes said

00:44:18,440 --> 00:44:23,070
last year I also had a suggestion by

00:44:20,730 --> 00:44:25,650
Shanta who said the guy from Adobe was

00:44:23,070 --> 00:44:28,910
very very very bright who told me you

00:44:25,650 --> 00:44:31,230
should try cases where nothing happens

00:44:28,910 --> 00:44:32,820
because maybe Lacan Paris will be smart

00:44:31,230 --> 00:44:34,050
enough to realize because that's one

00:44:32,820 --> 00:44:36,390
thing you know if you're if you never

00:44:34,050 --> 00:44:38,340
throw and if the compiler sees that

00:44:36,390 --> 00:44:40,320
maybe it can optimize everything away if

00:44:38,340 --> 00:44:42,750
you're putting the ifs you're still

00:44:40,320 --> 00:44:44,330
going to do the years but the fact that

00:44:42,750 --> 00:44:46,650
you're throwing and know once that

00:44:44,330 --> 00:44:48,530
you're making try block button the ones

00:44:46,650 --> 00:44:51,150
that were throwing maybe it's detectable

00:44:48,530 --> 00:44:52,740
so I tried it I tried to I tried one

00:44:51,150 --> 00:44:54,840
with redundant checks which means that

00:44:52,740 --> 00:44:56,460
I'm still trying and I'm still doing the

00:44:54,840 --> 00:44:58,680
ifs and everything but I'm never

00:44:56,460 --> 00:45:02,880
throwing or returning in ever ever ever

00:44:58,680 --> 00:45:07,080
ever again cool and another one where

00:45:02,880 --> 00:45:09,150
I'm never and not checking no ifs on one

00:45:07,080 --> 00:45:11,820
side no try on their side nothing and

00:45:09,150 --> 00:45:13,410
there was very stable again and I was

00:45:11,820 --> 00:45:15,869
hoping for better numbers they're not

00:45:13,410 --> 00:45:16,080
miraculous steady so there's work to be

00:45:15,869 --> 00:45:19,740
done

00:45:16,080 --> 00:45:21,990
ok the the issue of performance is is

00:45:19,740 --> 00:45:23,400
real it's not major but it's real

00:45:21,990 --> 00:45:25,380
so it can be annoying for embedded

00:45:23,400 --> 00:45:27,630
systems people are very very tight in

00:45:25,380 --> 00:45:29,460
memory or on speed or something the size

00:45:27,630 --> 00:45:31,470
issue I hadn't measured this morning for

00:45:29,460 --> 00:45:34,140
lack of time the numbers I got last year

00:45:31,470 --> 00:45:37,890
were about a 3% difference when I added

00:45:34,140 --> 00:45:38,910
exceptions or removed it from number

00:45:37,890 --> 00:45:41,550
I'll just I'm going to go to the

00:45:38,910 --> 00:45:44,730
questions a few seconds so the size

00:45:41,550 --> 00:45:46,290
increase was slight but existed a few

00:45:44,730 --> 00:45:48,390
percent is that big or not it depends on

00:45:46,290 --> 00:45:50,070
your application domain we had a

00:45:48,390 --> 00:45:52,380
discussion in June again for other

00:45:50,070 --> 00:45:54,330
features where one of the compiler

00:45:52,380 --> 00:45:57,270
writers stated that he had measured a

00:45:54,330 --> 00:45:59,640
3-person cost for for doing with the

00:45:57,270 --> 00:46:01,380
proposal suggested and some people said

00:45:59,640 --> 00:46:03,170
well 3% is nothing into no it's big

00:46:01,380 --> 00:46:06,150
because that depends on your perspective

00:46:03,170 --> 00:46:07,109
so the games people the admitted systems

00:46:06,150 --> 00:46:09,359
people

00:46:07,109 --> 00:46:11,730
high-frequency trading people 3% it

00:46:09,359 --> 00:46:14,880
might annoy you okay so instead because

00:46:11,730 --> 00:46:16,650
it's not in your domain that 3% happens

00:46:14,880 --> 00:46:19,829
to be important that it's in everybody's

00:46:16,650 --> 00:46:21,299
domain in C++ is a big world so that's

00:46:19,829 --> 00:46:23,940
the reason why even though it's a very

00:46:21,299 --> 00:46:25,410
good mechanism does a job we one have to

00:46:23,940 --> 00:46:28,950
work on it a bit because it lacks love

00:46:25,410 --> 00:46:31,499
and and and to the there's legitimate

00:46:28,950 --> 00:46:34,829
reasons for people to be uncomfortable

00:46:31,499 --> 00:46:40,680
with it I'm technical from technical

00:46:34,829 --> 00:46:41,849
standpoint at least solo there and let's

00:46:40,680 --> 00:46:45,299
zero test I would say for talking about

00:46:41,849 --> 00:46:47,609
that's pretty much it I were to make a

00:46:45,299 --> 00:46:48,930
reason me about this but I didn't get

00:46:47,609 --> 00:46:51,989
around so I just made this question with

00:46:48,930 --> 00:46:53,970
you guys so a few things before I take

00:46:51,989 --> 00:46:55,799
the questions I've heard a few times

00:46:53,970 --> 00:46:57,989
even this week cuz I've been here since

00:46:55,799 --> 00:47:02,279
Saturday well the standard library

00:46:57,989 --> 00:47:05,789
throws role very rarely it throws in

00:47:02,279 --> 00:47:08,309
vector at it froze when your code throws

00:47:05,789 --> 00:47:10,859
gets it cleans up and we throws it

00:47:08,309 --> 00:47:13,170
doesn't show much by itself so standard

00:47:10,859 --> 00:47:14,730
libraries not a big exception user it's

00:47:13,170 --> 00:47:16,140
just making sure it's not being

00:47:14,730 --> 00:47:18,450
corrupted we envy new exception

00:47:16,140 --> 00:47:19,650
guarantees when someone is through

00:47:18,450 --> 00:47:25,019
something and throws exceptions for you

00:47:19,650 --> 00:47:27,989
let's do that mostly the exceptions come

00:47:25,019 --> 00:47:31,200
from new and super were are saying that

00:47:27,989 --> 00:47:33,660
maybe you should just die battle-ax is

00:47:31,200 --> 00:47:36,059
being thrown just died but there's a

00:47:33,660 --> 00:47:37,349
talk this afternoon by a guy named

00:47:36,059 --> 00:47:39,210
zubkov I would like to go there I

00:47:37,349 --> 00:47:42,420
wouldn't be able who says that he has

00:47:39,210 --> 00:47:45,319
ways of ending verella so memory is

00:47:42,420 --> 00:47:47,579
interesting things to do with that and

00:47:45,319 --> 00:47:50,249
there's a few things but I won't have

00:47:47,579 --> 00:47:52,380
time but are cute I'll put the code in

00:47:50,249 --> 00:47:54,420
the folder if you're interested I know

00:47:52,380 --> 00:47:57,630
that boost graph throws when it finds

00:47:54,420 --> 00:48:01,309
something instead of failing because

00:47:57,630 --> 00:48:04,730
graphs searches are so complex that

00:48:01,309 --> 00:48:07,559
finding something is exceptional

00:48:04,730 --> 00:48:10,319
and I really like that because it's not

00:48:07,559 --> 00:48:12,599
an error it's an exception so it's the

00:48:10,319 --> 00:48:15,509
death the normal case is not finding

00:48:12,599 --> 00:48:17,369
something so I agree with everyone says

00:48:15,509 --> 00:48:20,280
you should keep exceptions for errors

00:48:17,369 --> 00:48:24,030
well yeah in most cases but again c-plus

00:48:20,280 --> 00:48:25,560
the big world the canzone dealer is an

00:48:24,030 --> 00:48:28,350
from what I know because I had never met

00:48:25,560 --> 00:48:30,210
him he's an accountant my said but he

00:48:28,350 --> 00:48:32,700
had a problem he wanted to do type

00:48:30,210 --> 00:48:35,370
iteration a pointer and make sure that

00:48:32,700 --> 00:48:37,770
it could get the pointer out but that

00:48:35,370 --> 00:48:39,840
are one of its parents classes well to

00:48:37,770 --> 00:48:41,910
do some polymorphic things with it and

00:48:39,840 --> 00:48:44,550
the typewriter techniques that we had

00:48:41,910 --> 00:48:46,950
get went for the exact exact type and

00:48:44,550 --> 00:48:49,110
you found a trick with exceptions to be

00:48:46,950 --> 00:48:51,120
able to get either the type is stored in

00:48:49,110 --> 00:48:53,010
a pointer or any one of its base classes

00:48:51,120 --> 00:48:54,180
it's a nice trick so I'll put the link

00:48:53,010 --> 00:48:55,830
in the slide before I put them on you

00:48:54,180 --> 00:48:59,310
can go check with the very very nice

00:48:55,830 --> 00:49:02,520
trick and and you can cure very very

00:48:59,310 --> 00:49:03,870
dirty you can throw a lambda that gets

00:49:02,520 --> 00:49:05,790
to a function pointer and that tells you

00:49:03,870 --> 00:49:07,860
how to end all the errors but don't do

00:49:05,790 --> 00:49:08,970
that but there's many interesting things

00:49:07,860 --> 00:49:12,030
you can do it exceptions if you're

00:49:08,970 --> 00:49:13,380
creative it's a whole world now if you

00:49:12,030 --> 00:49:18,780
to create typical moves do you lose your

00:49:13,380 --> 00:49:20,850
job no but it's pretty much a tree so

00:49:18,780 --> 00:49:22,530
the the under slides after that there's

00:49:20,850 --> 00:49:23,610
a trick but since the time is running

00:49:22,530 --> 00:49:24,870
and there are questions I'll take the

00:49:23,610 --> 00:49:27,780
questions and put the slides on three

00:49:24,870 --> 00:49:29,900
okay guys thank you so you had a

00:49:27,780 --> 00:49:29,900
question

00:49:41,790 --> 00:49:46,030
it's a good point I don't remember the

00:49:44,560 --> 00:49:47,500
code by heart because I was with shaking

00:49:46,030 --> 00:50:21,700
it fast this morning but it's a good

00:49:47,500 --> 00:50:23,770
point should I have thank you you're

00:50:21,700 --> 00:50:25,420
right the reason I was mentioning this

00:50:23,770 --> 00:50:30,490
is because it's one of the criticisms we

00:50:25,420 --> 00:50:33,010
hear so we and unless g14 at first the

00:50:30,490 --> 00:50:35,170
discussions were not based on numbers

00:50:33,010 --> 00:50:36,960
internally that's first the real reason

00:50:35,170 --> 00:50:38,770
why I started doing this was that

00:50:36,960 --> 00:50:41,440
discussing performance without numbers

00:50:38,770 --> 00:50:42,760
is very annoying so the bell sharks in

00:50:41,440 --> 00:50:44,470
terms of size were very simple I just

00:50:42,760 --> 00:50:44,980
compel the same code with very different

00:50:44,470 --> 00:50:46,510
Bell

00:50:44,980 --> 00:50:48,520
essentially the same settings and I just

00:50:46,510 --> 00:50:49,960
check the difference there's a guy whose

00:50:48,520 --> 00:50:52,750
name escapes me I think his name is

00:50:49,960 --> 00:50:55,090
David who was compiled clang with and

00:50:52,750 --> 00:50:58,720
without exceptions just to check and and

00:50:55,090 --> 00:51:00,430
who's done I stuff in found that

00:50:58,720 --> 00:51:01,960
depending on the context if you do a lot

00:51:00,430 --> 00:51:04,780
of i/o sometimes the exceptions perform

00:51:01,960 --> 00:51:07,390
much better so so there's it's not the

00:51:04,780 --> 00:51:16,810
end all of the generally speaking native

00:51:07,390 --> 00:51:19,800
code we have some work to do ah I can

00:51:16,810 --> 00:51:19,800
understand that yeah

00:51:21,420 --> 00:51:35,430
I use it and and I work with people

00:51:32,910 --> 00:51:38,700
really need speed so I personally use it

00:51:35,430 --> 00:51:41,609
I don't use it everywhere okay I use it

00:51:38,700 --> 00:51:42,390
in constructors since I read generic

00:51:41,609 --> 00:51:44,430
code I'm careful

00:51:42,390 --> 00:51:45,809
so I try not to beat resources but REI

00:51:44,430 --> 00:51:48,119
does mostly job for you

00:51:45,809 --> 00:51:50,010
so I use that I I wouldn't use it in

00:51:48,119 --> 00:51:51,690
tight look ever unless I have a really

00:51:50,010 --> 00:51:53,940
really good reason for that because it

00:51:51,690 --> 00:51:54,930
shows too much and on those places but

00:51:53,940 --> 00:51:58,490
there's a number of places where it's

00:51:54,930 --> 00:52:02,790
fine I wouldn't use it for IO in C++ we

00:51:58,490 --> 00:52:04,140
errors in IO are to come and to be

00:52:02,790 --> 00:52:05,640
called exceptional I think if they

00:52:04,140 --> 00:52:07,020
happened too often so I know that

00:52:05,640 --> 00:52:10,859
something will just do that that's where

00:52:07,020 --> 00:52:13,410
I would put it but as far as keeping a

00:52:10,859 --> 00:52:15,720
code quieren safe for those places

00:52:13,410 --> 00:52:17,579
constructors and other places that are

00:52:15,720 --> 00:52:19,049
not tight loops I would anticipate no

00:52:17,579 --> 00:52:20,190
you don't have to optimize everything in

00:52:19,049 --> 00:52:24,630
your code you have to devise the hot

00:52:20,190 --> 00:52:26,609
stuff so I would localize them and if I

00:52:24,630 --> 00:52:28,589
have pieces of code that really need it

00:52:26,609 --> 00:52:30,150
and rest doesn't well you can write to

00:52:28,589 --> 00:52:31,740
DLR and Iceland localize them together

00:52:30,150 --> 00:52:33,380
and make sure it's on the boundaries

00:52:31,740 --> 00:52:35,130
should be escape we have things to do

00:52:33,380 --> 00:52:36,690
there are some people who I've been

00:52:35,130 --> 00:52:39,210
asking us recently on the mailing lists

00:52:36,690 --> 00:52:42,829
if we should catch exceptions from other

00:52:39,210 --> 00:52:45,240
languages I think it's just pure evil

00:52:42,829 --> 00:52:52,290
there's I would use the pickup's options

00:52:45,240 --> 00:52:55,559
for that and our glasses yeah I would

00:52:52,290 --> 00:52:57,940
imagine you for trying numbers using

00:52:55,559 --> 00:53:00,099
your statements

00:52:57,940 --> 00:53:02,859
or even just Co times would be a

00:53:00,099 --> 00:53:05,260
generally hard problem because like if

00:53:02,859 --> 00:53:06,849
you look at the legs kernel they because

00:53:05,260 --> 00:53:08,890
you see they're stuck with this angles

00:53:06,849 --> 00:53:16,569
but they wrap everything in Frankfort

00:53:08,890 --> 00:53:18,010
so for you to try to measure what would

00:53:16,569 --> 00:53:20,230
the impact be with it a bunch of this

00:53:18,010 --> 00:53:22,030
students versus an exception would be

00:53:20,230 --> 00:53:23,349
incredibly difficult because generally

00:53:22,030 --> 00:53:24,309
speaking brain conditions you just make

00:53:23,349 --> 00:53:26,500
the problem go away

00:53:24,309 --> 00:53:29,200
well it doesn't but does it theory and

00:53:26,500 --> 00:53:30,789
then the code size effective if you've

00:53:29,200 --> 00:53:32,650
got rid of all new statements right

00:53:30,789 --> 00:53:34,900
would be removing seemingly a lot of

00:53:32,650 --> 00:53:38,460
code by using exceptions but then the

00:53:34,900 --> 00:53:40,809
exceptions add all of the basically

00:53:38,460 --> 00:53:42,250
exception logic that's needed to do all

00:53:40,809 --> 00:53:44,170
the lookups for how to do to snack on

00:53:42,250 --> 00:53:46,210
line mmm so yeah you might be reducing

00:53:44,170 --> 00:53:49,450
code size in your in the actual

00:53:46,210 --> 00:53:51,730
co-teacher that you're writing but what

00:53:49,450 --> 00:53:55,059
gets compiled ends up being relatively

00:53:51,730 --> 00:53:56,859
large do the lookup data well it can be

00:53:55,059 --> 00:53:59,980
the question is are we doing the right

00:53:56,859 --> 00:54:02,920
thing but so far my feeling is we have a

00:53:59,980 --> 00:54:04,510
qi thing I think we can I think I'm not

00:54:02,920 --> 00:54:07,480
sure we'll be able to reduce the KO size

00:54:04,510 --> 00:54:09,430
below the statement level but we can get

00:54:07,480 --> 00:54:10,990
close and we're not close enough that's

00:54:09,430 --> 00:54:13,420
more the thing that's annoying right now

00:54:10,990 --> 00:54:15,880
we don't have a strong statement to say

00:54:13,420 --> 00:54:17,970
we're close enough you should really try

00:54:15,880 --> 00:54:17,970
it

00:54:27,070 --> 00:54:31,010
yeah when we when we wrote that code it

00:54:29,750 --> 00:54:32,360
was very obvious that there's definitely

00:54:31,010 --> 00:54:33,800
these weird problems you're going to

00:54:32,360 --> 00:54:35,060
have so that I would agree with your

00:54:33,800 --> 00:54:37,460
statement that it's good in some

00:54:35,060 --> 00:54:40,700
scenarios and not good in others you

00:54:37,460 --> 00:54:43,070
have to G have to use your damn brakes

00:54:40,700 --> 00:54:45,380
that the second thing with the mask is

00:54:43,070 --> 00:54:46,940
just have you looked at this go guard

00:54:45,380 --> 00:54:51,260
work which presented a couple years ago

00:54:46,940 --> 00:54:53,030
with respect to do you state well this

00:54:51,260 --> 00:55:07,220
is specifically disco guard no but there

00:54:53,030 --> 00:55:09,980
re I have been using now is it there's

00:55:07,220 --> 00:55:12,320
an interesting concept there where GSL

00:55:09,980 --> 00:55:13,820
finally to be used except for the fact

00:55:12,320 --> 00:55:17,230
that it's always execute in the case

00:55:13,820 --> 00:55:17,230
where you have exceptions what do you do

00:55:17,740 --> 00:55:27,560
building something similar to scope are

00:55:21,680 --> 00:55:29,030
built with and if that becomes standard

00:55:27,560 --> 00:55:30,440
is going to change a waiver program so

00:55:29,030 --> 00:55:34,390
is going to need some more thought

00:55:30,440 --> 00:55:34,390
indeed by the US

00:55:40,210 --> 00:55:44,950
I'm surprised there's not more

00:55:42,380 --> 00:55:47,869
discussions exceptions of dealing with

00:55:44,950 --> 00:55:49,670
transactions how do you you know you

00:55:47,869 --> 00:55:53,599
brought up the issue of I give that copy

00:55:49,670 --> 00:55:56,510
but what it really yeah

00:55:53,599 --> 00:55:58,250
maybe you'd like be aware enough stuff

00:55:56,510 --> 00:56:00,980
because I'm getting messages from the

00:55:58,250 --> 00:56:02,540
back end maybe you'd like to check what

00:56:00,980 --> 00:56:04,819
the transactional memory group is doing

00:56:02,540 --> 00:56:06,770
to because it's a real problem for them

00:56:04,819 --> 00:56:09,920
of course and there I have a number of

00:56:06,770 --> 00:56:12,470
techniques and ways to mark the code

00:56:09,920 --> 00:56:13,880
know what you do should something fails

00:56:12,470 --> 00:56:15,619
in the middle of the transaction and if

00:56:13,880 --> 00:56:17,540
the transaction and everything you

00:56:15,619 --> 00:56:20,299
commit do you rollback you failed you

00:56:17,540 --> 00:56:23,030
all and given it a lot of props

00:56:20,299 --> 00:56:25,010
Brett Hall very often in who has a

00:56:23,030 --> 00:56:26,290
traditional memory commercial product

00:56:25,010 --> 00:56:35,420
probably s thought about that too

00:56:26,290 --> 00:56:38,089
interesting yep yeah is the manager the

00:56:35,420 --> 00:56:39,530
the chairman of the company but there's

00:56:38,089 --> 00:56:41,450
a number of people involved in there

00:56:39,530 --> 00:56:42,579
that are here in the room but nothing

00:56:41,450 --> 00:56:43,940
room but in the building right now

00:56:42,579 --> 00:57:06,559
anything else

00:56:43,940 --> 00:57:08,599
yep it's a good question the SG 14 group

00:57:06,559 --> 00:57:12,200
right now is working on something with

00:57:08,599 --> 00:57:14,630
that respect the Jasmine was talking

00:57:12,200 --> 00:57:18,170
about link time optimization today the

00:57:14,630 --> 00:57:21,319
the relation of your code to what's hot

00:57:18,170 --> 00:57:23,210
and what's not sometimes is not the same

00:57:21,319 --> 00:57:25,280
from the perspective of the compiler and

00:57:23,210 --> 00:57:27,319
from the perspective the programmer I've

00:57:25,280 --> 00:57:29,299
heard people saying well I want the hot

00:57:27,319 --> 00:57:32,180
path sometimes to be seen as the catch

00:57:29,299 --> 00:57:34,250
because I even though it's not going to

00:57:32,180 --> 00:57:35,960
occur often it's what it occurs that I'm

00:57:34,250 --> 00:57:38,839
really in a hurry level to do something

00:57:35,960 --> 00:57:41,390
so there's it's not an either/or thing

00:57:38,839 --> 00:57:43,069
it's tricky a bit so these guys are

00:57:41,390 --> 00:57:45,079
working on they're trying to find ways

00:57:43,069 --> 00:57:46,339
to use standard attributes because right

00:57:45,079 --> 00:57:48,710
now we have a number of non-standard

00:57:46,339 --> 00:57:51,770
ways of doing this there's GCC we

00:57:48,710 --> 00:57:54,080
decline way or so we're looking for ways

00:57:51,770 --> 00:57:55,940
to say Express the Intel

00:57:54,080 --> 00:57:58,460
for a compared to the right thing and

00:57:55,940 --> 00:58:00,260
it's it's a exceedingly difficult a

00:57:58,460 --> 00:58:02,180
number of bright people who have real

00:58:00,260 --> 00:58:04,340
problems are trying to find the right

00:58:02,180 --> 00:58:06,590
words and right semantics right now for

00:58:04,340 --> 00:58:09,560
an actual proposal eventually so it is

00:58:06,590 --> 00:58:11,570
an interesting case it's not an

00:58:09,560 --> 00:58:13,640
automatic thing it's something that

00:58:11,570 --> 00:58:15,400
requires thought so I'm hoping that

00:58:13,640 --> 00:58:19,460
these works will give us guidance as to

00:58:15,400 --> 00:58:21,200
what we should let the programmer do and

00:58:19,460 --> 00:58:23,359
what kind of leeway we should leave the

00:58:21,200 --> 00:58:26,450
compilers because the needs of

00:58:23,359 --> 00:58:28,760
performance critical code are not always

00:58:26,450 --> 00:58:30,410
as evident that we would think it's a

00:58:28,760 --> 00:58:31,790
very interesting thing I'm not in that

00:58:30,410 --> 00:58:36,099
conversation much I'm reading it and I'm

00:58:31,790 --> 00:58:36,099
having a lot of fun there were hands

00:58:36,160 --> 00:58:39,520

YouTube URL: https://www.youtube.com/watch?v=Fno6suiXLPs


