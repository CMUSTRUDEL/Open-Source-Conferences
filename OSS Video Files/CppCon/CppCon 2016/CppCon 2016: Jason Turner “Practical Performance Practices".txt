Title: CppCon 2016: Jason Turner “Practical Performance Practices"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
In the past 6 years ChaiScript's performance has been improved by nearly 100x. This was not accomplished by adding a virtual machine or performing dynamic recompilation. Instead, these increases have been accomplished by moving to more simple, cleaner, idiomatic C++ and by following some simple rules. We will outline these concepts with examples for how they both simplified code while improving performance. 
— 
Jason Turner
Developer, Trainer, Speaker
Host of C++Weekly https://www.youtube.com/c/JasonTurner-lefticus, Co-host of CppCast http://cppcast.com, Co-creator and maintainer of the embedded scripting language for C++, ChaiScript http://chaiscript.com, and author and curator of the forkable coding standards document http://cppbestpractices.com. I'm available for contracting and onsite training.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:06,690
all right as this main slide says here

00:00:04,470 --> 00:00:08,639
the session only works if you guys

00:00:06,690 --> 00:00:11,280
interact with me otherwise I'm just

00:00:08,639 --> 00:00:12,599
going to be talking to myself and that's

00:00:11,280 --> 00:00:13,710
not as much fun so make sure you're

00:00:12,599 --> 00:00:15,660
close enough that I can interact with

00:00:13,710 --> 00:00:18,210
you actually ask them to dim the lights

00:00:15,660 --> 00:00:21,960
a little bit so I can see you guys so

00:00:18,210 --> 00:00:26,070
hopefully it'll work so I guess we're

00:00:21,960 --> 00:00:32,610
going to get started if my clicker is

00:00:26,070 --> 00:00:34,620
working so my name is Jason Turner all

00:00:32,610 --> 00:00:37,170
of the presentations that I have ever

00:00:34,620 --> 00:00:39,899
given are up on my github page so feel

00:00:37,170 --> 00:00:42,469
free to check those out may have heard

00:00:39,899 --> 00:00:45,480
about CV PCAST at the conference

00:00:42,469 --> 00:00:49,590
co-hosts and chai Script is a toy

00:00:45,480 --> 00:00:51,390
project of mine that I will be talking a

00:00:49,590 --> 00:00:52,770
lot about today not directly but the

00:00:51,390 --> 00:00:56,399
lessons that I learned while working on

00:00:52,770 --> 00:00:58,350
it and I really prefer interactive

00:00:56,399 --> 00:01:00,270
sessions please stop me please ask

00:00:58,350 --> 00:01:07,590
questions yell out from the audience

00:01:00,270 --> 00:01:08,850
whatever you need to do optimizing

00:01:07,590 --> 00:01:11,970
compilers are amazing

00:01:08,850 --> 00:01:15,590
so what would you guys expect this to

00:01:11,970 --> 00:01:17,610
compile to what do you think is the the

00:01:15,590 --> 00:01:23,700
the code would look like from the

00:01:17,610 --> 00:01:27,320
compiler here you returns one compiler

00:01:23,700 --> 00:01:31,340
optimizes it away that's pretty cool

00:01:27,320 --> 00:01:31,340
what do you expect this code to do

00:01:31,850 --> 00:01:44,520
return to no it doesn't just return to

00:01:40,170 --> 00:01:47,250
in fact it has to do all kinds of things

00:01:44,520 --> 00:01:51,299
with creating both of the strings

00:01:47,250 --> 00:01:53,670
creating compiling the code for actually

00:01:51,299 --> 00:01:55,860
creating their buffers and deleting them

00:01:53,670 --> 00:01:58,530
and everything else to the point that

00:01:55,860 --> 00:02:00,149
actually suspect that that the very

00:01:58,530 --> 00:02:03,299
first slide that I showed you is a

00:02:00,149 --> 00:02:04,500
special optimization that the GCC people

00:02:03,299 --> 00:02:06,810
put in somewhere to look for this

00:02:04,500 --> 00:02:11,670
because it really only works in a few

00:02:06,810 --> 00:02:13,650
select cases so optimizing compilers are

00:02:11,670 --> 00:02:13,830
amazing but trying to predict what they

00:02:13,650 --> 00:02:15,870
can

00:02:13,830 --> 00:02:18,390
Pilar is going to do is a bit of a risky

00:02:15,870 --> 00:02:20,600
game so as I said this comes from my

00:02:18,390 --> 00:02:22,950
experience with Thai script

00:02:20,600 --> 00:02:26,700
measuring Thai scripts performance is

00:02:22,950 --> 00:02:29,880
difficult I have a lot of templates in

00:02:26,700 --> 00:02:32,220
it and the nature of scripting means

00:02:29,880 --> 00:02:34,200
that the execution is spread over a

00:02:32,220 --> 00:02:36,480
bunch of similarly named functions and

00:02:34,200 --> 00:02:38,100
I'll show you what I mean this is a

00:02:36,480 --> 00:02:41,030
simple script

00:02:38,100 --> 00:02:44,580
I am initializing X to 0 and I am

00:02:41,030 --> 00:02:46,740
looping from 0 to 100 and basically I'm

00:02:44,580 --> 00:02:49,560
summing the values 0 to 100 in this loop

00:02:46,740 --> 00:02:51,990
so this gets parsed by choice script as

00:02:49,560 --> 00:02:55,170
a file node that has an equation that

00:02:51,990 --> 00:02:57,390
sets X to the constant 0 and then a for

00:02:55,170 --> 00:03:00,709
loop with an equation that initializes I

00:02:57,390 --> 00:03:04,410
to 0 and then less than comparison

00:03:00,709 --> 00:03:10,459
incrementing of I and then the block

00:03:04,410 --> 00:03:13,620
where I'm actually adding I into X and

00:03:10,459 --> 00:03:17,220
these are all implemented with

00:03:13,620 --> 00:03:18,660
polymorphism in C++ so basically I have

00:03:17,220 --> 00:03:21,510
a bunch of functions called eval

00:03:18,660 --> 00:03:23,489
internal that are being called so my

00:03:21,510 --> 00:03:26,910
profiling data looks like this

00:03:23,489 --> 00:03:29,720
I have eval internal 100% of the time

00:03:26,910 --> 00:03:34,830
calling a function called eval internal

00:03:29,720 --> 00:03:36,480
it's not helpful so as I worked on

00:03:34,830 --> 00:03:38,310
optimizing Chive script I came up with a

00:03:36,480 --> 00:03:40,560
bunch of rules for myself for how I kind

00:03:38,310 --> 00:03:45,720
of make better performing code by

00:03:40,560 --> 00:03:47,760
default so which is better for the

00:03:45,720 --> 00:03:55,980
normal case standard vector or standard

00:03:47,760 --> 00:04:00,660
list I'm saying the the question was

00:03:55,980 --> 00:04:02,940
defined normal if you which one you're

00:04:00,660 --> 00:04:05,280
going to default to unless you have a

00:04:02,940 --> 00:04:07,230
reason to choose another and in fact

00:04:05,280 --> 00:04:09,209
actually uh I'll just say I just

00:04:07,230 --> 00:04:11,519
disagree list should almost never be

00:04:09,209 --> 00:04:17,070
used but maybe we can talk about that

00:04:11,519 --> 00:04:19,700
more later so ok why why is vector

00:04:17,070 --> 00:04:19,700
better than list

00:04:21,640 --> 00:04:30,340
what this is a big room okay what was

00:04:27,140 --> 00:04:32,830
that cache locality someone said

00:04:30,340 --> 00:04:35,950
locality of reference same thing okay

00:04:32,830 --> 00:04:44,920
all right what was that

00:04:35,950 --> 00:04:50,060
less overhead and what way right so

00:04:44,920 --> 00:04:52,280
standard list we what do we have to do

00:04:50,060 --> 00:04:53,840
here we're creating a list of one what

00:04:52,280 --> 00:04:57,380
does the compiler need to generate what

00:04:53,840 --> 00:05:02,750
are we going to do at runtime we are

00:04:57,380 --> 00:05:04,970
going to create a list node we are going

00:05:02,750 --> 00:05:09,100
to set up its delete to be able to

00:05:04,970 --> 00:05:11,540
destroy the list node we are going to I

00:05:09,100 --> 00:05:13,220
don't know what that next deletes for we

00:05:11,540 --> 00:05:15,260
have unwind resume because we have to

00:05:13,220 --> 00:05:17,660
handle the case that perhaps when

00:05:15,260 --> 00:05:18,980
creating the list node an exception was

00:05:17,660 --> 00:05:21,830
thrown for out of memory or something so

00:05:18,980 --> 00:05:23,300
the exception handling in here so we

00:05:21,830 --> 00:05:25,820
have to allocate the node we have to

00:05:23,300 --> 00:05:28,340
handle a potential exception and we have

00:05:25,820 --> 00:05:31,910
to assign the value hook up the pointers

00:05:28,340 --> 00:05:35,930
as you're referring to for the from the

00:05:31,910 --> 00:05:39,410
head and then delete the node and other

00:05:35,930 --> 00:05:41,930
stuff that maybe we don't quite get what

00:05:39,410 --> 00:05:49,640
has to happen and vector to do the same

00:05:41,930 --> 00:05:52,160
thing allocate the internal buffer and

00:05:49,640 --> 00:05:56,750
set the first value to 1 that is what

00:05:52,160 --> 00:06:00,860
vector does allocates a buffer sets the

00:05:56,750 --> 00:06:02,570
value deletes the buffer so for better

00:06:00,860 --> 00:06:05,290
performing code don't do more work than

00:06:02,570 --> 00:06:05,290
you have to

00:06:05,350 --> 00:06:18,350
what about standard array anyone what's

00:06:14,210 --> 00:06:20,390
that one instruction not pretty much X

00:06:18,350 --> 00:06:22,070
ORS the return value and returns it

00:06:20,390 --> 00:06:24,260
completely optimizes away the array

00:06:22,070 --> 00:06:25,700
altogether because we're not using it

00:06:24,260 --> 00:06:31,600
that's something that was created on the

00:06:25,700 --> 00:06:31,600
stack all p OD data it just goes away

00:06:31,919 --> 00:06:39,300
so don't do more work than you have to

00:06:37,169 --> 00:06:42,029
for containers I say always prefer

00:06:39,300 --> 00:06:44,699
standard array first then standard

00:06:42,029 --> 00:06:47,819
vector and then only differ if you need

00:06:44,699 --> 00:06:51,210
some tool that are some container that

00:06:47,819 --> 00:06:52,620
gives you specific behavior and make

00:06:51,210 --> 00:06:55,169
sure you understand what your standard

00:06:52,620 --> 00:06:59,520
library has to do when you ask it to use

00:06:55,169 --> 00:07:02,039
one of these containers and I've I've

00:06:59,520 --> 00:07:04,439
never found a place in my own code where

00:07:02,039 --> 00:07:06,870
list was actually faster I had places

00:07:04,439 --> 00:07:09,300
where I thought list was faster and so I

00:07:06,870 --> 00:07:10,529
used it and then I profiled and now I

00:07:09,300 --> 00:07:16,889
don't have lists anywhere in my code

00:07:10,529 --> 00:07:26,279
anymore all right what is wrong with

00:07:16,889 --> 00:07:29,310
this code and not using ra íí- I would

00:07:26,279 --> 00:07:32,819
say that's that's not necessarily true

00:07:29,310 --> 00:07:36,330
as the S is created on the stack it does

00:07:32,819 --> 00:07:40,169
its thing manages its memory I should

00:07:36,330 --> 00:07:42,210
set the value with the constructor or so

00:07:40,169 --> 00:07:44,639
so so the problem here is that we're

00:07:42,210 --> 00:07:51,120
first constructing the string object and

00:07:44,639 --> 00:07:55,439
then we are reassigning it so if we use

00:07:51,120 --> 00:08:00,509
this rule of always constant at smile

00:07:55,439 --> 00:08:02,819
Extro by the way always Const then you

00:08:00,509 --> 00:08:07,520
get this con standard string s equals

00:08:02,819 --> 00:08:09,930
whatever and we are using assignment

00:08:07,520 --> 00:08:12,389
initialization it's equivalent to

00:08:09,930 --> 00:08:14,669
calling the constructor so we construct

00:08:12,389 --> 00:08:16,080
and initialize in one step that's 32

00:08:14,669 --> 00:08:21,060
percent more efficient than the previous

00:08:16,080 --> 00:08:23,039
version well what do we do in a case

00:08:21,060 --> 00:08:24,719
like this where we have potentially a

00:08:23,039 --> 00:08:26,759
bunch of different switch statements

00:08:24,719 --> 00:08:28,529
that we want to take we have some sort

00:08:26,759 --> 00:08:33,599
of complex initialization we're working

00:08:28,529 --> 00:08:37,260
with use a lambda that's exactly what I

00:08:33,599 --> 00:08:38,789
wanted to hear so you can do this and

00:08:37,260 --> 00:08:40,260
you get the exact same savings that you

00:08:38,789 --> 00:08:41,789
get on the previous version as long as

00:08:40,260 --> 00:08:44,430
we're always applying a rule of always

00:08:41,789 --> 00:08:45,260
Const so with complex initialization

00:08:44,430 --> 00:08:49,280
we're going to use

00:08:45,260 --> 00:08:52,820
IIF e people don't say that in the c++

00:08:49,280 --> 00:08:54,920
world I like to that's from JavaScript

00:08:52,820 --> 00:08:57,500
that's the immediately invoked function

00:08:54,920 --> 00:08:59,150
expression if we really want to we can

00:08:57,500 --> 00:09:01,940
call it something different and see

00:08:59,150 --> 00:09:03,380
what's plus like Ely or something

00:09:01,940 --> 00:09:11,150
the immediately invoked lambda

00:09:03,380 --> 00:09:13,430
expression I don't know so what's the

00:09:11,150 --> 00:09:22,330
problem we're looking at now with this

00:09:13,430 --> 00:09:24,740
code efficiency problem what's that

00:09:22,330 --> 00:09:26,990
right I'm default initializing my string

00:09:24,740 --> 00:09:29,410
and then assigning to it I found in

00:09:26,990 --> 00:09:32,840
practice that not enough people really

00:09:29,410 --> 00:09:35,590
take advantage of the initializer lists

00:09:32,840 --> 00:09:38,210
and hopefully that's not this group but

00:09:35,590 --> 00:09:39,830
we have the same issues as the previous

00:09:38,210 --> 00:09:43,450
examples we're talking about so we use

00:09:39,830 --> 00:09:47,810
our class initializers excuse me um

00:09:43,450 --> 00:09:51,110
object initializers and we've got this

00:09:47,810 --> 00:09:52,730
where we're using the move idiom thing

00:09:51,110 --> 00:09:54,860
we're assuming since we're going to take

00:09:52,730 --> 00:09:58,700
our own copy of it that we're going to

00:09:54,860 --> 00:10:03,920
do a copy and move same games is using

00:09:58,700 --> 00:10:05,870
the constant ish eliezer but now can

00:10:03,920 --> 00:10:12,260
anyone find any efficiency problems with

00:10:05,870 --> 00:10:16,340
this code yes be depending on my usage I

00:10:12,260 --> 00:10:16,940
could benefit from caching Val that's

00:10:16,340 --> 00:10:21,560
correct

00:10:16,940 --> 00:10:24,890
Val parses string on every call so let's

00:10:21,560 --> 00:10:27,260
write a caching function this looks good

00:10:24,890 --> 00:10:29,770
right so now when we call Val we check

00:10:27,260 --> 00:10:32,030
to see if it's calculated then we

00:10:29,770 --> 00:10:35,440
calculated if it hasn't been then we

00:10:32,030 --> 00:10:39,410
return it good

00:10:35,440 --> 00:10:41,740
what's that don't store the string we're

00:10:39,410 --> 00:10:41,740
not there yet

00:10:46,000 --> 00:10:52,579
all right well I'm not hearing this from

00:10:48,470 --> 00:10:54,410
this side of the room very much yeah yes

00:10:52,579 --> 00:10:58,069
I'm not I'm not actually setting this

00:10:54,410 --> 00:11:02,870
calculated flag oh we also have another

00:10:58,069 --> 00:11:04,310
problem that I forgot Cibolo score

00:11:02,870 --> 00:11:06,680
guidelines state that Const method

00:11:04,310 --> 00:11:10,630
should be thread-safe right that's one

00:11:06,680 --> 00:11:14,209
of our best practice kind of rules and

00:11:10,630 --> 00:11:17,690
we're not setting is calculated so we're

00:11:14,209 --> 00:11:22,670
going to fix both of those things by

00:11:17,690 --> 00:11:25,000
using mutable atomic values and now all

00:11:22,670 --> 00:11:29,810
the code is good

00:11:25,000 --> 00:11:33,459
right now we're thread-safe and we're

00:11:29,810 --> 00:11:33,459
not calculating things more than once

00:11:38,380 --> 00:11:43,430
not is the question was shouldn't I pass

00:11:41,389 --> 00:11:46,850
the constructor argument is a constant

00:11:43,430 --> 00:11:51,709
reference you can find much debate on

00:11:46,850 --> 00:11:53,810
this the world seems to agree at the

00:11:51,709 --> 00:11:57,649
moment that if you know you are taking a

00:11:53,810 --> 00:11:59,630
copy of it as I know I am then passing

00:11:57,649 --> 00:12:02,029
it by value and using standard move

00:11:59,630 --> 00:12:05,449
works because if something is passed to

00:12:02,029 --> 00:12:08,420
you on the stack then you will move it

00:12:05,449 --> 00:12:09,740
and you'll then you'll save the copy but

00:12:08,420 --> 00:12:26,839
if you do a Const reference and you have

00:12:09,740 --> 00:12:29,000
to make a copy of it yes right so based

00:12:26,839 --> 00:12:34,519
on my usage it might be more beneficial

00:12:29,000 --> 00:12:36,319
to not ever actually take the string so

00:12:34,519 --> 00:12:37,850
we've got the problem we're doing a

00:12:36,319 --> 00:12:40,490
branching and every single time that was

00:12:37,850 --> 00:12:43,100
called we have our tommix which are slow

00:12:40,490 --> 00:12:44,990
and really this is this is the result we

00:12:43,100 --> 00:12:47,750
wanted to get to we had no reason to

00:12:44,990 --> 00:12:50,510
store the string necessarily in this

00:12:47,750 --> 00:12:54,490
code and this is directly representative

00:12:50,510 --> 00:12:56,620
of code that I had in choice script

00:12:54,490 --> 00:12:59,050
where every time an integer was

00:12:56,620 --> 00:13:02,410
evaluated I was literally reap arcing

00:12:59,050 --> 00:13:04,750
the integer so at this version we've got

00:13:02,410 --> 00:13:08,980
no branching no Atomics I and a smaller

00:13:04,750 --> 00:13:12,760
runtime because some of the string code

00:13:08,980 --> 00:13:14,290
didn't have to be brought in and the

00:13:12,760 --> 00:13:16,330
context of chai Script this took me

00:13:14,290 --> 00:13:18,610
about two years to realize I was doing

00:13:16,330 --> 00:13:21,070
this on a recall and it resulted in a

00:13:18,610 --> 00:13:25,570
10% performance improvement across my

00:13:21,070 --> 00:13:28,029
entire system so this is my next rule if

00:13:25,570 --> 00:13:30,390
it looks simpler it's almost always

00:13:28,029 --> 00:13:30,390
better

00:13:31,500 --> 00:13:37,120
so don't Const

00:13:33,790 --> 00:13:39,520
always initialize using I Fe can help

00:13:37,120 --> 00:13:41,920
you initialize and don't recalculate

00:13:39,520 --> 00:13:49,089
values that you should only calculate

00:13:41,920 --> 00:13:50,860
once all right what's wrong with this

00:13:49,089 --> 00:13:52,779
code I'm going to now stand on this side

00:13:50,860 --> 00:13:55,420
of the stage and make the cameraman work

00:13:52,779 --> 00:14:04,450
harder so that I can hear from these

00:13:55,420 --> 00:14:10,209
guys I give you a minute it's too small

00:14:04,450 --> 00:14:11,970
to read oh the red I'm sorry I don't

00:14:10,209 --> 00:14:17,920
know if I can do anything about that

00:14:11,970 --> 00:14:22,540
um let's see if I can see if I can break

00:14:17,920 --> 00:14:30,880
my whole presentation it's only zooming

00:14:22,540 --> 00:14:35,890
the what is this this doesn't do any

00:14:30,880 --> 00:14:37,990
good I'm sorry uh I can't do a whole lot

00:14:35,890 --> 00:14:40,089
about the font colors at the moment

00:14:37,990 --> 00:14:42,040
unfortunately but this is one reason why

00:14:40,089 --> 00:14:48,100
my title slide I said everyone needs to

00:14:42,040 --> 00:14:52,930
be close so can anyone read it well

00:14:48,100 --> 00:14:54,520
enough to have an idea what's wrong okay

00:14:52,930 --> 00:14:56,470
alright so what I have is I have a

00:14:54,520 --> 00:14:58,450
struct called base and it's true that

00:14:56,470 --> 00:15:01,270
red color is very bad I'm gonna

00:14:58,450 --> 00:15:05,620
apologize I have a struct called base it

00:15:01,270 --> 00:15:07,449
has a virtual destructor and then I have

00:15:05,620 --> 00:15:08,740
a structure called derived that derives

00:15:07,449 --> 00:15:11,260
from base and it

00:15:08,740 --> 00:15:14,200
so has a virtual destructor and I am

00:15:11,260 --> 00:15:16,600
doing this because presumably if I have

00:15:14,200 --> 00:15:20,200
you know virtual methods I have virtual

00:15:16,600 --> 00:15:21,520
do a thing in the base class then I am

00:15:20,200 --> 00:15:23,740
going to want to have a virtual

00:15:21,520 --> 00:15:25,510
destructor most compilers will give you

00:15:23,740 --> 00:15:27,459
a warning if you have virtual methods

00:15:25,510 --> 00:15:28,660
without a virtual destructor so that you

00:15:27,459 --> 00:15:30,690
know that you're cleaning up your

00:15:28,660 --> 00:15:33,190
objects correctly and that kind of thing

00:15:30,690 --> 00:15:40,870
so with that explanation does anyone

00:15:33,190 --> 00:15:42,820
have any input yes

00:15:40,870 --> 00:15:44,680
so part of the problem is that and

00:15:42,820 --> 00:15:49,570
derived I don't need the virtual

00:15:44,680 --> 00:15:52,470
destructor because the inherited

00:15:49,570 --> 00:15:57,550
destructor is going to be virtual yes

00:15:52,470 --> 00:15:59,170
the other problem is that by providing a

00:15:57,550 --> 00:16:01,089
virtual destructor at all

00:15:59,170 --> 00:16:03,130
move construction and move assignment

00:16:01,089 --> 00:16:05,980
have been implicitly disabled by the

00:16:03,130 --> 00:16:07,990
compiler by providing our own destructor

00:16:05,980 --> 00:16:09,490
we have told the compiler that we are

00:16:07,990 --> 00:16:12,100
doing something special with the

00:16:09,490 --> 00:16:14,440
lifetime of our object and therefore it

00:16:12,100 --> 00:16:17,079
will not create move assignment and move

00:16:14,440 --> 00:16:19,180
destruction for us and also as was

00:16:17,079 --> 00:16:22,560
already pointed out the virtual derived

00:16:19,180 --> 00:16:26,200
destructor is completely unnecessary so

00:16:22,560 --> 00:16:29,020
this is my next rule don't accidentally

00:16:26,200 --> 00:16:32,610
disable move operations or more

00:16:29,020 --> 00:16:35,589
succinctly use the rule of 0 so I have

00:16:32,610 --> 00:16:38,440
defaulted the copy constructor copy

00:16:35,589 --> 00:16:43,180
assignment operator move constructor and

00:16:38,440 --> 00:16:51,820
move assignment operator and that really

00:16:43,180 --> 00:16:56,070
is really bad colors up there hopefully

00:16:51,820 --> 00:16:58,570
it doesn't continue to be a problem so

00:16:56,070 --> 00:17:00,550
fixing this and one of my commonly used

00:16:58,570 --> 00:17:05,679
classes in chai Script resulted in 10%

00:17:00,550 --> 00:17:07,510
import improvement and I have Scott

00:17:05,679 --> 00:17:10,030
Myers specifically to thank for this

00:17:07,510 --> 00:17:11,980
because of effective modern C++ I was

00:17:10,030 --> 00:17:15,520
reading at one of the pre-release

00:17:11,980 --> 00:17:18,550
versions that I bought online from

00:17:15,520 --> 00:17:18,819
O'Reilly and I said oh no what have I

00:17:18,550 --> 00:17:21,779
done

00:17:18,819 --> 00:17:29,340
and I went through and fixed my code

00:17:21,779 --> 00:17:30,929
is right I'm sorry

00:17:29,340 --> 00:17:36,479
what you might not need to use the

00:17:30,929 --> 00:17:39,210
microphone yeah the question is why do

00:17:36,479 --> 00:17:44,489
we strive to make the base class copy

00:17:39,210 --> 00:17:50,219
able and movable why derived its class

00:17:44,489 --> 00:17:51,629
yeah to slice it I'm sorry I'm still not

00:17:50,219 --> 00:17:54,359
catching the question basically you just

00:17:51,629 --> 00:17:56,279
provide the DD of assignment and copy

00:17:54,359 --> 00:17:57,779
operations to the base class and then

00:17:56,279 --> 00:18:02,940
you drive it through it this pretty more

00:17:57,779 --> 00:18:04,529
think usage or a class okay so I if I

00:18:02,940 --> 00:18:07,139
understand why didn't I also provide

00:18:04,529 --> 00:18:10,019
these operations to the dried grass why

00:18:07,139 --> 00:18:12,619
it's not known opium it should be

00:18:10,019 --> 00:18:15,779
copyable those are all set to default

00:18:12,619 --> 00:18:19,559
yeah but why footprint multi crosses oh

00:18:15,779 --> 00:18:22,139
why did I remain it copyable if it's a

00:18:19,559 --> 00:18:25,469
polymorphic class because this is an

00:18:22,139 --> 00:18:37,950
example on a slide that I maybe didn't

00:18:25,469 --> 00:18:40,349
fully think out the the point really

00:18:37,950 --> 00:18:45,179
though is about disabling your move

00:18:40,349 --> 00:18:47,489
operations and and also about not

00:18:45,179 --> 00:18:49,200
providing the virtual destructor in the

00:18:47,489 --> 00:18:52,229
derived class or if it needed to be so

00:18:49,200 --> 00:18:54,450
maybe that point itself wasn't as clear

00:18:52,229 --> 00:18:56,309
as I could have made it but in the

00:18:54,450 --> 00:18:57,989
derived if I had kept that virtual

00:18:56,309 --> 00:18:59,909
destructor which is something that I

00:18:57,989 --> 00:19:01,710
have personally made the mistake of

00:18:59,909 --> 00:19:03,839
doing hundreds and hundreds of times

00:19:01,710 --> 00:19:05,219
because I think hey I'm in a virtual

00:19:03,839 --> 00:19:07,019
thing and I don't think about the fact

00:19:05,219 --> 00:19:10,820
that I'm inheriting my virtual

00:19:07,019 --> 00:19:14,639
destructor from my base class then

00:19:10,820 --> 00:19:18,299
you're disabling your move operations at

00:19:14,639 --> 00:19:20,429
multiple levels because now if I had a

00:19:18,299 --> 00:19:23,159
virtual destructor in the derived class

00:19:20,429 --> 00:19:26,779
then I would have again disabled the

00:19:23,159 --> 00:19:26,779
derived ability to move

00:19:30,430 --> 00:19:47,380
okay is this legible so the words you

00:19:33,790 --> 00:19:53,490
can't read our struct for and int so we

00:19:47,380 --> 00:19:56,200
have a problem we're copying s into our

00:19:53,490 --> 00:19:58,980
struct called s does that it can

00:19:56,200 --> 00:20:03,130
everyone see that at least well enough

00:19:58,980 --> 00:20:08,650
so we know it copies bad so we're going

00:20:03,130 --> 00:20:12,130
to use move right now we are moving our

00:20:08,650 --> 00:20:13,900
string into our struct and so we get

00:20:12,130 --> 00:20:16,630
this like kind of double layer of move

00:20:13,900 --> 00:20:20,320
removing our temporary s into the

00:20:16,630 --> 00:20:23,320
constructor for capital S poorly named

00:20:20,320 --> 00:20:31,630
structure and and everything's good

00:20:23,320 --> 00:20:34,510
right yes the string s is in Const that

00:20:31,630 --> 00:20:40,000
is true I'm not following my own rule

00:20:34,510 --> 00:20:45,270
there but that's not where I'm

00:20:40,000 --> 00:20:45,270
necessarily going with this point this

00:20:46,860 --> 00:20:52,030
so by using move this is 29% more

00:20:50,410 --> 00:20:54,430
efficient by the way we're talking the

00:20:52,030 --> 00:21:00,310
same kind of like 30% efficiency gains

00:20:54,430 --> 00:21:02,500
by not thank men I copy and we've got a

00:21:00,310 --> 00:21:04,590
32 percent smaller binary in this case

00:21:02,500 --> 00:21:08,680
because less of string is instantiated

00:21:04,590 --> 00:21:17,620
but good but what's better than moving

00:21:08,680 --> 00:21:26,170
the value but wait I see actually a hand

00:21:17,620 --> 00:21:28,510
up you're supposed to yell yeah why not

00:21:26,170 --> 00:21:32,190
just do the string plus expression in

00:21:28,510 --> 00:21:34,630
the constructor so if we do it this way

00:21:32,190 --> 00:21:36,070
we have a not very sort string and by

00:21:34,630 --> 00:21:37,480
the way this is to get around short

00:21:36,070 --> 00:21:38,410
string optimizations if you seen

00:21:37,480 --> 00:21:39,700
anything about about that of the

00:21:38,410 --> 00:21:43,000
conference because that really will

00:21:39,700 --> 00:21:43,840
throw off your your numbers when you're

00:21:43,000 --> 00:21:48,130
trying to do this kind

00:21:43,840 --> 00:21:51,190
of thing so I get another 2% efficiency

00:21:48,130 --> 00:21:54,669
gain by not creating that extra string

00:21:51,190 --> 00:21:58,779
on the stack unfortunately is sometimes

00:21:54,669 --> 00:22:00,880
leads to less readable code but in my

00:21:58,779 --> 00:22:02,799
opinion it's much more maintainable than

00:22:00,880 --> 00:22:04,720
having move operations sprinkled

00:22:02,799 --> 00:22:07,779
everywhere moves are easy to use wrong

00:22:04,720 --> 00:22:09,309
and overuse and then to accidentally use

00:22:07,779 --> 00:22:12,270
the thing that you moved from when you

00:22:09,309 --> 00:22:18,940
didn't realize you had this is better

00:22:12,270 --> 00:22:20,830
usually why don't I use string literal

00:22:18,940 --> 00:22:22,600
because I wasn't aware of it when I made

00:22:20,830 --> 00:22:25,659
these slides I have since been made

00:22:22,600 --> 00:22:28,210
aware of it and I didn't um I didn't put

00:22:25,659 --> 00:22:35,279
the code I didn't update them was this

00:22:28,210 --> 00:22:40,360
questioned why is this way faster in

00:22:35,279 --> 00:22:42,940
this code the string s has a lifetime it

00:22:40,360 --> 00:22:45,789
must be created on the stack and then it

00:22:42,940 --> 00:22:48,399
must be destroyed even after it's been

00:22:45,789 --> 00:22:50,500
moved from there is still something left

00:22:48,399 --> 00:22:53,440
that its destructor needs to be called

00:22:50,500 --> 00:22:55,390
and it needs to be cleaned up to some

00:22:53,440 --> 00:23:01,210
extent which is pretty much Anala but it

00:22:55,390 --> 00:23:03,669
is something I have had comments before

00:23:01,210 --> 00:23:07,000
saying well what we really need is to

00:23:03,669 --> 00:23:16,270
add destructive move to C++ but we don't

00:23:07,000 --> 00:23:18,220
have that today so we're taking the the

00:23:16,270 --> 00:23:19,570
concept of don't declare variable until

00:23:18,220 --> 00:23:21,940
you need it which is something that C

00:23:19,570 --> 00:23:24,760
must plus is very good at and you can

00:23:21,940 --> 00:23:26,529
really you know tell C programmers from

00:23:24,760 --> 00:23:28,059
C++ programmers because they'd like to

00:23:26,529 --> 00:23:31,149
declare all the variables at the top of

00:23:28,059 --> 00:23:32,770
the function because they have to but we

00:23:31,149 --> 00:23:35,110
don't do that in C++ so declare

00:23:32,770 --> 00:23:36,880
variables late as possible or don't even

00:23:35,110 --> 00:23:43,809
declare it at all if you can get away

00:23:36,880 --> 00:23:48,270
with it okay it the word you can't read

00:23:43,809 --> 00:23:48,270
is Auto um

00:23:49,470 --> 00:23:54,640
so can anyone see any problems with with

00:23:52,870 --> 00:23:57,400
what we're doing here this is one of my

00:23:54,640 --> 00:24:05,740
favorite examples actually well you're

00:23:57,400 --> 00:24:09,190
raising your hand too much what when I'm

00:24:05,740 --> 00:24:11,080
passing it to a function I am I am

00:24:09,190 --> 00:24:14,770
incrementing a reference count or I am

00:24:11,080 --> 00:24:16,780
not I am right inferencing the reference

00:24:14,770 --> 00:24:20,200
count why why am i recommending the

00:24:16,780 --> 00:24:31,169
orphans count because I'm passing it by

00:24:20,200 --> 00:24:33,669
value is that what I hear so we have

00:24:31,169 --> 00:24:36,580
copies being made of shared pointer

00:24:33,669 --> 00:24:38,140
because I'm passing it by value so we

00:24:36,580 --> 00:24:40,150
fix it by Const

00:24:38,140 --> 00:24:43,830
reference so we're no longer passing by

00:24:40,150 --> 00:24:43,830
value except what was that you just said

00:24:44,760 --> 00:24:50,740
yes I am creating a shared pointer of

00:24:48,640 --> 00:24:52,659
type derived but passing it to a

00:24:50,740 --> 00:24:55,809
function that expects a shared pointer

00:24:52,659 --> 00:25:01,750
of type base so does anyone understand

00:24:55,809 --> 00:25:04,409
what's actually happening here just a

00:25:01,750 --> 00:25:06,940
minute if no one else raises their hand

00:25:04,409 --> 00:25:13,780
yeah yeah you do understand what's

00:25:06,940 --> 00:25:16,840
happening or you want to say or right

00:25:13,780 --> 00:25:20,470
that has to create a temporary of type

00:25:16,840 --> 00:25:23,799
shared pointer base calling a conversion

00:25:20,470 --> 00:25:30,460
constructor if you will from from shared

00:25:23,799 --> 00:25:36,490
pointer of derived wrong so we get here

00:25:30,460 --> 00:25:39,760
so don't pass shared pointers in general

00:25:36,490 --> 00:25:42,280
is a good rule by going this route and

00:25:39,760 --> 00:25:44,289
not passing shared pointers around we

00:25:42,280 --> 00:25:49,360
get a two and a half times faster than

00:25:44,289 --> 00:25:54,490
the last version I'm sorry what was that

00:25:49,360 --> 00:25:57,820
oh yes yes I forgot to fix that bug I

00:25:54,490 --> 00:25:59,649
knew it was there I am asking for a

00:25:57,820 --> 00:26:01,120
pointer and I'm passing that to a

00:25:59,649 --> 00:26:02,320
function that expects a reference I

00:26:01,120 --> 00:26:14,980
should have D referenced it

00:26:02,320 --> 00:26:17,620
sorry yes as okay it's two layers of

00:26:14,980 --> 00:26:19,000
errors so I could I could fix it one way

00:26:17,620 --> 00:26:20,620
or the other I could fix two lines of

00:26:19,000 --> 00:26:23,409
code or I could fix one line of code by

00:26:20,620 --> 00:26:24,639
taking the constant base star but I

00:26:23,409 --> 00:26:25,929
wouldn't want to do that because you

00:26:24,639 --> 00:26:28,000
don't want to pass around bare pointers

00:26:25,929 --> 00:26:31,149
if you got that anyway to do it so that

00:26:28,000 --> 00:26:38,409
should take a reference and two bugs on

00:26:31,149 --> 00:26:45,629
this slide at least does everyone know

00:26:38,409 --> 00:26:48,279
what standard land line does it flushes

00:26:45,629 --> 00:26:53,740
why am I using i/o streams at all is

00:26:48,279 --> 00:26:55,620
that what I heard let's assume that we

00:26:53,740 --> 00:26:59,080
have a good reason to be using Oh stream

00:26:55,620 --> 00:27:02,100
so standard line is is the equivalent of

00:26:59,080 --> 00:27:04,600
a new line and a flush standard end line

00:27:02,100 --> 00:27:07,120
expect that flush to cost you at least

00:27:04,600 --> 00:27:08,889
nine times overhead on your i/o if you

00:27:07,120 --> 00:27:13,269
don't need it depending on your platform

00:27:08,889 --> 00:27:16,659
Windows is much higher than that in my

00:27:13,269 --> 00:27:20,169
experience so this is my real-world

00:27:16,659 --> 00:27:26,830
anecdote that I like to show and there's

00:27:20,169 --> 00:27:29,980
no red on this slide so we had this

00:27:26,830 --> 00:27:32,919
function called write file that took a

00:27:29,980 --> 00:27:34,210
no stream so we would output all of the

00:27:32,919 --> 00:27:37,509
data that wanted to go to the output

00:27:34,210 --> 00:27:42,850
file to this o stream and then we had

00:27:37,509 --> 00:27:45,490
our get file as string so the the two

00:27:42,850 --> 00:27:49,690
things that I want you to focus on are

00:27:45,490 --> 00:27:56,080
the two bottom functions mostly so this

00:27:49,690 --> 00:27:58,509
is exposed to a to Ruby via swig and the

00:27:56,080 --> 00:28:01,539
users of our Ruby library we're saying

00:27:58,509 --> 00:28:04,659
hey if I call your write file function

00:28:01,539 --> 00:28:07,480
it's an order of a magnitude slower than

00:28:04,659 --> 00:28:10,419
if I call get file as string and write

00:28:07,480 --> 00:28:13,659
it out myself and Ruby and I said no no

00:28:10,419 --> 00:28:15,880
no that's impossible and then like two

00:28:13,659 --> 00:28:18,370
years later I realized why

00:28:15,880 --> 00:28:23,950
so unless you have a really good reason

00:28:18,370 --> 00:28:26,650
to do a flush avoid end line that's

00:28:23,950 --> 00:28:30,610
where we're going to go there so just

00:28:26,650 --> 00:28:32,230
use a new line and actually I saw this

00:28:30,610 --> 00:28:33,789
for some reason I had never really

00:28:32,230 --> 00:28:35,650
thought about it before but when I was

00:28:33,789 --> 00:28:39,460
reading some examples from strew stroke

00:28:35,650 --> 00:28:41,350
I noticed like it's the newline

00:28:39,460 --> 00:28:43,840
character is a single character may as

00:28:41,350 --> 00:28:45,880
well pass it as a single character

00:28:43,840 --> 00:28:49,299
instead of using double quotes and you

00:28:45,880 --> 00:28:50,980
know really I actually looked at the the

00:28:49,299 --> 00:28:52,480
difference in compiling and it really

00:28:50,980 --> 00:28:53,980
doesn't make that big of a difference

00:28:52,480 --> 00:28:58,960
but you know let's treat single

00:28:53,980 --> 00:29:01,299
characters with single characters so in

00:28:58,960 --> 00:29:03,039
summary for our don't do more work than

00:29:01,299 --> 00:29:06,010
we have to section here of hidden work

00:29:03,039 --> 00:29:08,860
calculate your values only once at

00:29:06,010 --> 00:29:11,049
initialize time obey or rule 0 if it

00:29:08,860 --> 00:29:15,039
looks simpler it's probably faster this

00:29:11,049 --> 00:29:17,409
almost always holds true avoid object

00:29:15,039 --> 00:29:19,659
copying avoid automatic conversions

00:29:17,409 --> 00:29:23,200
never pass smart pointers unless you

00:29:19,659 --> 00:29:24,850
have a really good reason to make your

00:29:23,200 --> 00:29:28,780
conversion operations explicit avoid

00:29:24,850 --> 00:29:34,690
standard inline so on the topic of

00:29:28,780 --> 00:29:41,169
shared pointer what what happens on this

00:29:34,690 --> 00:29:43,539
line of code what's the red thing third

00:29:41,169 --> 00:29:45,760
thing is an int I'm sorry I'm making a

00:29:43,539 --> 00:29:50,350
shared pointer of int and I'm creating

00:29:45,760 --> 00:29:54,059
with the value 1 creating a shared

00:29:50,350 --> 00:29:57,070
pointer int is bad but you might have a

00:29:54,059 --> 00:29:59,409
legitimate reason to there is a better

00:29:57,070 --> 00:30:00,669
way but it's a it just want to get on to

00:29:59,409 --> 00:30:06,940
the question of what does the computer

00:30:00,669 --> 00:30:12,750
actually have to do so well uh-oh

00:30:06,940 --> 00:30:12,750
oops yes

00:30:15,480 --> 00:30:25,750
yes right so it has to create the memory

00:30:22,330 --> 00:30:28,060
for the thing it has to create the

00:30:25,750 --> 00:30:30,160
memory for the the control block and it

00:30:28,060 --> 00:30:31,810
has to increment the reference count and

00:30:30,160 --> 00:30:36,340
then it has to do all those things in

00:30:31,810 --> 00:30:40,300
reverse order okay which is totally

00:30:36,340 --> 00:30:43,900
correct so we've got all of this

00:30:40,300 --> 00:30:47,440
assembly that's generated by the

00:30:43,900 --> 00:30:57,580
compiler for making a shared pointer

00:30:47,440 --> 00:31:01,390
instantiation what do we do now now we

00:30:57,580 --> 00:31:04,330
allocate a buffer and then we delete it

00:31:01,390 --> 00:31:07,780
right and okay let's see what can't you

00:31:04,330 --> 00:31:12,360
read in red you cannot read the assembly

00:31:07,780 --> 00:31:15,340
instructions but as I said yesterday

00:31:12,360 --> 00:31:21,730
with the rule of thumb with assembly is

00:31:15,340 --> 00:31:24,910
less is better than more so we are

00:31:21,730 --> 00:31:26,200
creating a buffer for our integer we're

00:31:24,910 --> 00:31:26,940
assigning the value and then we're do

00:31:26,200 --> 00:31:29,320
eating it

00:31:26,940 --> 00:31:32,890
everyone good on this it's pretty

00:31:29,320 --> 00:31:36,730
straightforward and this is how it

00:31:32,890 --> 00:31:41,080
compares to manual memory management oh

00:31:36,730 --> 00:31:45,340
man my clickers jumping around on me so

00:31:41,080 --> 00:31:51,070
make unique verses by hand they are

00:31:45,340 --> 00:31:52,840
exactly the same all right we're

00:31:51,070 --> 00:31:54,640
wrapping up our part 1 this is a

00:31:52,840 --> 00:31:57,940
two-part talk and I guess we're about on

00:31:54,640 --> 00:32:00,430
schedule so avoid shared pointer avoid

00:31:57,940 --> 00:32:02,470
standard in line always Const always

00:32:00,430 --> 00:32:04,030
initialize with meaningful values don't

00:32:02,470 --> 00:32:06,460
recalculate things that you know are

00:32:04,030 --> 00:32:12,210
mutable do we have any questions before

00:32:06,460 --> 00:32:12,210
we move on yes

00:32:16,390 --> 00:32:21,800
with make unique the operator knew could

00:32:20,090 --> 00:32:29,420
possibly throw why was there no

00:32:21,800 --> 00:32:31,640
exception handling I don't know it

00:32:29,420 --> 00:32:33,470
doesn't do it in either case so I know

00:32:31,640 --> 00:32:38,260
that make unique isn't adding or

00:32:33,470 --> 00:32:38,260
removing anything from it someone knows

00:32:38,890 --> 00:32:46,010
you might have to go to the megaphone

00:32:40,760 --> 00:32:50,560
I'm sorry I just wanted to ask another

00:32:46,010 --> 00:32:54,290
question out in at the beginning you

00:32:50,560 --> 00:32:57,950
talked about not doing virtual

00:32:54,290 --> 00:32:59,930
distractor yes and maybe in that case

00:32:57,950 --> 00:33:02,420
you should have used stood function

00:32:59,930 --> 00:33:05,360
instead of for driving from a base class

00:33:02,420 --> 00:33:08,450
it's sometimes faster yes

00:33:05,360 --> 00:33:09,590
I just wanted to illustrate the point of

00:33:08,450 --> 00:33:12,860
things that have mistakes that I

00:33:09,590 --> 00:33:15,410
personally made in my code of when you

00:33:12,860 --> 00:33:17,240
do have a reason to be using inheritance

00:33:15,410 --> 00:33:20,140
and you have a higher class hierarchy

00:33:17,240 --> 00:33:22,850
and you've got virtual function calls

00:33:20,140 --> 00:33:32,420
just to be careful to not accidentally

00:33:22,850 --> 00:33:35,000
throw away your move operations so the

00:33:32,420 --> 00:33:39,790
next part smaller code is faster code

00:33:35,000 --> 00:33:39,790
and this has got a lot of red on it I

00:33:39,970 --> 00:33:45,580
wonder does anyone know if chrome has

00:33:42,770 --> 00:33:48,050
like a keyboard shortcut for put me in

00:33:45,580 --> 00:33:55,990
high contrast mode or something like

00:33:48,050 --> 00:33:55,990
that windows plus Oh

00:33:57,410 --> 00:34:01,810
oh my goodness

00:34:03,880 --> 00:34:15,440
yeah how do I get it back oh so that

00:34:12,020 --> 00:34:18,620
well that's my code sample um and all

00:34:15,440 --> 00:34:22,180
seriousness how do I get it undone when

00:34:18,620 --> 00:34:22,180
does well I can't guessed that I guess

00:34:25,060 --> 00:34:31,970
I'm sorry what I tried that actually and

00:34:30,230 --> 00:34:35,330
it doesn't seem to like the dual monitor

00:34:31,970 --> 00:34:36,470
setup of moving the mouse so I just want

00:34:35,330 --> 00:34:42,440
to make sure I can get back and forth

00:34:36,470 --> 00:34:46,670
okay that's good so um I should probably

00:34:42,440 --> 00:34:50,710
know what the point of the slide is now

00:34:46,670 --> 00:34:50,710
that I've gotten distracted by zooming

00:34:50,800 --> 00:34:59,150
so um we have this kind of contrived

00:34:56,410 --> 00:35:02,180
hierarchy of templates we've got our

00:34:59,150 --> 00:35:05,290
derived type it's sort of contrived but

00:35:02,180 --> 00:35:12,410
it's related to real code that I've I've

00:35:05,290 --> 00:35:16,490
used so I'm gonna see if I can get in

00:35:12,410 --> 00:35:18,230
the mail sinner Hey okay so this is is

00:35:16,490 --> 00:35:23,600
this actually readable now even with the

00:35:18,230 --> 00:35:28,480
red alright cool so we've got our struct

00:35:23,600 --> 00:35:31,730
D which is our derived type and it has

00:35:28,480 --> 00:35:34,820
an overridden virtual method from the

00:35:31,730 --> 00:35:37,310
base class called get vector and it's a

00:35:34,820 --> 00:35:41,450
vector of nth so the derived has its own

00:35:37,310 --> 00:35:44,240
vector of nth so what are we doing

00:35:41,450 --> 00:35:49,430
poorly in this code this again as

00:35:44,240 --> 00:35:54,410
mistakes I've totally made what's that

00:35:49,430 --> 00:35:56,390
Oh returning my value on let's assume

00:35:54,410 --> 00:36:00,130
there's a good reason to return by value

00:35:56,390 --> 00:36:00,130
this is constants a code

00:36:03,480 --> 00:36:09,190
why do I have the template because it's

00:36:06,820 --> 00:36:11,440
a contrived example but again it is

00:36:09,190 --> 00:36:14,760
actually a stripped-down example from

00:36:11,440 --> 00:36:17,980
let's let's say you are implementing

00:36:14,760 --> 00:36:20,350
your own version of standard function so

00:36:17,980 --> 00:36:22,210
you probably have a base class that has

00:36:20,350 --> 00:36:23,860
some base things in it and then each

00:36:22,210 --> 00:36:26,080
version of standard function with the

00:36:23,860 --> 00:36:34,690
template is going to be doing similar

00:36:26,080 --> 00:36:37,330
things I'm going to zoom back out so

00:36:34,690 --> 00:36:40,740
with many template instantiations this

00:36:37,330 --> 00:36:40,740
code really starts to blow up

00:36:41,730 --> 00:36:50,110
what we had was there's no reason for

00:36:46,560 --> 00:36:52,330
the the vector of int in the drive class

00:36:50,110 --> 00:36:55,420
to be there at all it should be in your

00:36:52,330 --> 00:36:59,920
base class and if you're doing anything

00:36:55,420 --> 00:37:01,870
with templating and an inheritance

00:36:59,920 --> 00:37:06,010
you're potentially you're going to run

00:37:01,870 --> 00:37:08,830
into this kind of thing so I joined this

00:37:06,010 --> 00:37:10,930
to myself I said don't repeat yourself

00:37:08,830 --> 00:37:13,180
in your template code I've heard of

00:37:10,930 --> 00:37:15,880
other people calling it D template izing

00:37:13,180 --> 00:37:18,250
code like move everything out of the

00:37:15,880 --> 00:37:24,580
template that you can because that adds

00:37:18,250 --> 00:37:34,800
a lot of overhead for the compiler so

00:37:24,580 --> 00:37:34,800
taking a factory example is that

00:37:37,660 --> 00:37:45,589
yeah that's the whole example so we have

00:37:40,969 --> 00:37:49,249
this factory of integers essentially for

00:37:45,589 --> 00:37:52,430
what I'm doing and I've got my factory

00:37:49,249 --> 00:37:56,299
function that is returning a make shared

00:37:52,430 --> 00:37:58,839
and I've got my main that is creating a

00:37:56,299 --> 00:38:01,670
vector of these shared pointers now

00:37:58,839 --> 00:38:03,259
let's all ignore the fact that having

00:38:01,670 --> 00:38:06,140
this vector of shared pointers is

00:38:03,259 --> 00:38:08,239
probably a bad idea for now but I want

00:38:06,140 --> 00:38:10,609
to get to a point let's we're assuming

00:38:08,239 --> 00:38:21,049
there's a good reason to have a vector

00:38:10,609 --> 00:38:23,779
of shared pointers so herb Sutter and

00:38:21,049 --> 00:38:27,920
back to the basics which I think was

00:38:23,779 --> 00:38:30,499
from going native at 19 minutes in says

00:38:27,920 --> 00:38:33,849
you should prefer returning unique

00:38:30,499 --> 00:38:37,130
pointer from your factory functions and

00:38:33,849 --> 00:38:39,680
we already saw that shared pointer is

00:38:37,130 --> 00:38:42,170
much bigger than unique pointer so let's

00:38:39,680 --> 00:38:45,339
simply not instantiate more shared

00:38:42,170 --> 00:38:45,339
pointers than we need to

00:38:52,750 --> 00:39:01,369
so in this version our factory function

00:38:57,200 --> 00:39:02,990
now calls make unique and returns unique

00:39:01,369 --> 00:39:21,140
pointer and it's creating a shared

00:39:02,990 --> 00:39:22,820
pointer from it yes yes now we have two

00:39:21,140 --> 00:39:24,410
memory allocations instead of one

00:39:22,820 --> 00:39:28,280
because we're not benefiting from make

00:39:24,410 --> 00:39:30,349
share its memory coalescing I will

00:39:28,280 --> 00:39:32,480
attempt to prove to you that that is not

00:39:30,349 --> 00:39:36,290
as beneficial as it seems that it should

00:39:32,480 --> 00:39:38,270
be so with this version where we're

00:39:36,290 --> 00:39:42,680
returning makey we're using make unique

00:39:38,270 --> 00:39:47,810
and returning unique pointer we are

00:39:42,680 --> 00:39:50,630
creating how many okay let's put it this

00:39:47,810 --> 00:39:52,430
way how many different shared pointer

00:39:50,630 --> 00:39:56,470
instantiations of the shared pointer

00:39:52,430 --> 00:40:08,089
template are actually being created here

00:39:56,470 --> 00:40:10,520
what's that for no no one yes one we're

00:40:08,089 --> 00:40:14,770
creating one because our factors

00:40:10,520 --> 00:40:14,770
returning unique pointer of type base

00:40:15,490 --> 00:40:22,369
our unique pointer is returning a excuse

00:40:21,079 --> 00:40:26,510
me our factor is returning unique

00:40:22,369 --> 00:40:28,910
pointer of B so then there's exactly one

00:40:26,510 --> 00:40:32,000
type of shared pointer created which is

00:40:28,910 --> 00:40:38,000
of type B from that unique pointer and I

00:40:32,000 --> 00:40:42,829
really apologize for the colors so

00:40:38,000 --> 00:40:44,480
taking the three possible scenarios the

00:40:42,829 --> 00:40:46,940
red that you can't read says template

00:40:44,480 --> 00:40:48,380
int but hopefully the rest of it is good

00:40:46,940 --> 00:40:50,960
because I kind of need this to all be on

00:40:48,380 --> 00:40:53,060
one screen at once here are three

00:40:50,960 --> 00:40:55,819
possible scenarios of returning and make

00:40:53,060 --> 00:40:59,270
unique returning a unique pointer and

00:40:55,819 --> 00:41:02,000
using make you to do it takes one point

00:40:59,270 --> 00:41:06,470
three seconds to compile results in a

00:41:02,000 --> 00:41:09,530
30k executable and uses 150

00:41:06,470 --> 00:41:14,320
eggs of RAM because I guess that's what

00:41:09,530 --> 00:41:16,820
sealless plus compilers do but if we

00:41:14,320 --> 00:41:18,380
return a shared pointer and use make

00:41:16,820 --> 00:41:19,820
shared which was our initial example

00:41:18,380 --> 00:41:21,320
we're now up to two point two four

00:41:19,820 --> 00:41:23,180
seconds to compile that example we're

00:41:21,320 --> 00:41:25,640
only talking thirty different

00:41:23,180 --> 00:41:28,820
instantiations of make shared that's all

00:41:25,640 --> 00:41:31,700
that program was doing and now we're up

00:41:28,820 --> 00:41:33,710
to two point two seconds to compile 70k

00:41:31,700 --> 00:41:39,040
executable it's more than two and a two

00:41:33,710 --> 00:41:41,570
times the size and it is now using 100

00:41:39,040 --> 00:41:44,180
165 Meg's of RAM at compile time and

00:41:41,570 --> 00:41:46,070
then the worst case scenario is we're

00:41:44,180 --> 00:41:48,170
returning a shared pointer and using

00:41:46,070 --> 00:41:50,720
make unique to create that shared

00:41:48,170 --> 00:41:53,450
pointer of type base we're now two two

00:41:50,720 --> 00:41:55,099
point four three seconds to compile 91k

00:41:53,450 --> 00:41:57,590
executable now are three times bigger

00:41:55,099 --> 00:41:59,570
than previously and we're at a hundred

00:41:57,590 --> 00:42:02,599
and ninety Meg's of RAM used at compile

00:41:59,570 --> 00:42:15,800
time everyone clear on what we're

00:42:02,599 --> 00:42:17,660
looking at I'm compelling yes so I'm

00:42:15,800 --> 00:42:20,680
comparing apples and oranges but no I'm

00:42:17,660 --> 00:42:23,420
not because in both of these cases on

00:42:20,680 --> 00:42:26,270
the code I'm referring to is still going

00:42:23,420 --> 00:42:30,050
into this vector of shared pointers I'm

00:42:26,270 --> 00:42:32,720
saying I need a shared pointer and these

00:42:30,050 --> 00:42:35,510
are my three possible ways of creating a

00:42:32,720 --> 00:42:40,339
factory that will eventually result in a

00:42:35,510 --> 00:42:43,760
shared pointer so with all three of

00:42:40,339 --> 00:42:45,170
these cases the one that compiles the

00:42:43,760 --> 00:42:47,750
fastest results in the smaller

00:42:45,170 --> 00:42:50,000
executable is the one where I return a

00:42:47,750 --> 00:42:52,460
unique pointer use make unique to do it

00:42:50,000 --> 00:42:54,410
and then shove that into a vector of

00:42:52,460 --> 00:42:56,180
shared pointers and this is because like

00:42:54,410 --> 00:42:58,820
I said it's 30 different template

00:42:56,180 --> 00:43:01,940
instantiations we're doing that somewhat

00:42:58,820 --> 00:43:05,960
contrived example of taking an integer

00:43:01,940 --> 00:43:09,140
so these are real numbers from choice

00:43:05,960 --> 00:43:12,190
script these are the size of chai

00:43:09,140 --> 00:43:18,320
scripts executables because I have

00:43:12,190 --> 00:43:20,090
shared function objects if I use the

00:43:18,320 --> 00:43:21,710
best-case example of returning

00:43:20,090 --> 00:43:24,530
unique pointer and using make unique to

00:43:21,710 --> 00:43:26,420
get there I had a 5 mega executable if I

00:43:24,530 --> 00:43:28,940
returned shared pointer and use make

00:43:26,420 --> 00:43:32,570
sure to get there which is what we said

00:43:28,940 --> 00:43:35,240
we needed then it's actually six percent

00:43:32,570 --> 00:43:38,540
slower runtime system and it's a seven

00:43:35,240 --> 00:43:41,330
Meg executable now and if I did the

00:43:38,540 --> 00:43:43,370
worst case scenario I'm ten times ten

00:43:41,330 --> 00:43:52,130
percent slower than the the best case

00:43:43,370 --> 00:43:55,340
scenario does see you so I'll get to

00:43:52,130 --> 00:43:57,140
this in just a second but does the point

00:43:55,340 --> 00:43:59,120
here that I'm trying to get to a smaller

00:43:57,140 --> 00:44:02,060
code is faster code so anything that you

00:43:59,120 --> 00:44:04,850
can do anything within reason to make

00:44:02,060 --> 00:44:06,920
your binary smaller is almost certainly

00:44:04,850 --> 00:44:16,100
going to make your program run faster

00:44:06,920 --> 00:44:18,320
and that is why any one cache the

00:44:16,100 --> 00:44:24,920
smaller the program is the more likely

00:44:18,320 --> 00:44:28,820
it is to fit in the cache so to get back

00:44:24,920 --> 00:44:30,680
to the point of using make shared when

00:44:28,820 --> 00:44:32,300
we actually want shared and we know

00:44:30,680 --> 00:44:35,300
that's what we want and coalescing the

00:44:32,300 --> 00:44:38,480
construction of our of our two

00:44:35,300 --> 00:44:40,730
allocations that is make shared is

00:44:38,480 --> 00:44:43,600
faster if we're talking raw performance

00:44:40,730 --> 00:44:46,280
so if you're creating very very many

00:44:43,600 --> 00:44:47,930
short-lived objects than the make shared

00:44:46,280 --> 00:44:52,640
version is faster it does get that

00:44:47,930 --> 00:44:57,920
advantage of doing only one memory

00:44:52,640 --> 00:45:00,080
allocation instead of two and it has

00:44:57,920 --> 00:45:01,280
fewer conversions at runtime because it

00:45:00,080 --> 00:45:03,400
doesn't have to convert the unique

00:45:01,280 --> 00:45:07,810
pointer to a shared pointer at runtime

00:45:03,400 --> 00:45:11,330
but if you're creating very many

00:45:07,810 --> 00:45:14,090
short-lived shared objects in your

00:45:11,330 --> 00:45:17,300
system you probably have a design flaw

00:45:14,090 --> 00:45:21,350
but that's a discussion for maybe

00:45:17,300 --> 00:45:23,120
another time if however you're creating

00:45:21,350 --> 00:45:24,790
long lived shared objects which in my

00:45:23,120 --> 00:45:28,580
experience is the most likely scenario

00:45:24,790 --> 00:45:30,410
then you're going to want to do follow

00:45:28,580 --> 00:45:32,210
herbs advice I'm just repeating herb

00:45:30,410 --> 00:45:33,870
here so you can blame them to return

00:45:32,210 --> 00:45:39,270
make unique from your

00:45:33,870 --> 00:45:40,890
factory functions so continuing down the

00:45:39,270 --> 00:45:44,820
road of small echoes faster code

00:45:40,890 --> 00:45:55,320
I am losing I'm not running out of time

00:45:44,820 --> 00:45:58,440
actually this oh that worked okay so I

00:45:55,320 --> 00:46:00,870
am creating a function object and I'm

00:45:58,440 --> 00:46:04,890
using bind to get there so if I call F

00:46:00,870 --> 00:46:14,630
of world then it's going to return hello

00:46:04,890 --> 00:46:17,430
world from that function call this is

00:46:14,630 --> 00:46:22,470
2.9 times slower than just calling the

00:46:17,430 --> 00:46:24,840
function add with hello world in it and

00:46:22,470 --> 00:46:27,900
it adds a 30 percent compile time

00:46:24,840 --> 00:46:31,140
overhead and a 10 percent compile size

00:46:27,900 --> 00:46:32,490
overhead so instead we're going to get

00:46:31,140 --> 00:46:38,700
rid of the function we're just going to

00:46:32,490 --> 00:46:42,540
use bind this is still two times slower

00:46:38,700 --> 00:46:47,040
than a bear function call and has a 15

00:46:42,540 --> 00:46:49,020
percent compile time overhead and Scott

00:46:47,040 --> 00:46:51,570
Myers an effective modern cos plus

00:46:49,020 --> 00:46:58,290
number 34 says don't use bind

00:46:51,570 --> 00:47:00,150
essentially and STL also says don't use

00:46:58,290 --> 00:47:03,600
bind if you've listened to any of his

00:47:00,150 --> 00:47:06,840
talks about standard function so instead

00:47:03,600 --> 00:47:09,390
we use lambdas I have at this point

00:47:06,840 --> 00:47:11,190
almost I have completely removed all

00:47:09,390 --> 00:47:13,710
uses of standard bind for my code and

00:47:11,190 --> 00:47:16,650
almost all uses of standard function and

00:47:13,710 --> 00:47:18,300
preference for lambdas when I can this

00:47:16,650 --> 00:47:21,770
lambda version has zero overhead

00:47:18,300 --> 00:47:25,050
compared to a direct function call and

00:47:21,770 --> 00:47:28,260
zero compile time overhead compared to

00:47:25,050 --> 00:47:30,180
the direct function call everyone good

00:47:28,260 --> 00:47:32,130
on that sorry I'm having to speed up a

00:47:30,180 --> 00:47:34,230
little bit here so don't repeat yourself

00:47:32,130 --> 00:47:37,560
in templates avoid use of shared pointer

00:47:34,230 --> 00:47:40,230
avoid function none never use standard

00:47:37,560 --> 00:47:42,650
bind all right do we have any questions

00:47:40,230 --> 00:47:42,650
on part two

00:47:44,440 --> 00:47:54,430
okay doke my bonus slide avoid non-local

00:47:51,850 --> 00:47:56,380
data it's been my experience that

00:47:54,430 --> 00:47:58,870
non-local data that is data that's not

00:47:56,380 --> 00:48:02,950
local to your current function tends to

00:47:58,870 --> 00:48:06,100
be data that is static potentially which

00:48:02,950 --> 00:48:08,740
because of C++ 11 rules that statics

00:48:06,100 --> 00:48:11,320
must be thread safe initialized there's

00:48:08,740 --> 00:48:13,090
actually an added cost and accessing a

00:48:11,320 --> 00:48:15,370
static because every time you go to

00:48:13,090 --> 00:48:16,390
access it that you have to run code that

00:48:15,370 --> 00:48:18,010
checks to see if it's already been

00:48:16,390 --> 00:48:26,440
initialized before you get to access it

00:48:18,010 --> 00:48:28,600
so or maybe they are data that is part

00:48:26,440 --> 00:48:30,430
of your object and we need some sort of

00:48:28,600 --> 00:48:32,170
mutex protection so you try to access

00:48:30,430 --> 00:48:35,980
that data now you have to hit a mutex

00:48:32,170 --> 00:48:39,100
lock or perhaps it's you know maybe in

00:48:35,980 --> 00:48:41,560
something that's like a map that doesn't

00:48:39,100 --> 00:48:43,030
have a trivial lookup cost so it's just

00:48:41,560 --> 00:48:44,890
kind of a rule of thumb that if I'm

00:48:43,030 --> 00:48:47,320
doing in my function that's performance

00:48:44,890 --> 00:48:49,690
sensitive a lot of access to data that's

00:48:47,320 --> 00:48:53,760
not local to the function I need to know

00:48:49,690 --> 00:48:53,760
why and if it really needs to be there

00:48:57,510 --> 00:49:05,470
so again this is my summary of what

00:49:03,010 --> 00:49:08,620
we've just got so far yes I just about

00:49:05,470 --> 00:49:10,840
someone said something ask yourself what

00:49:08,620 --> 00:49:13,900
am I asking the compiler to do here matt

00:49:10,840 --> 00:49:15,940
god bolts compiler Explorer which I'm

00:49:13,900 --> 00:49:18,760
guessing you all have seen now is an

00:49:15,940 --> 00:49:21,810
excellent tool for that always Const

00:49:18,760 --> 00:49:25,710
always initialize obey the rule of zero

00:49:21,810 --> 00:49:28,300
don't do more work than you have to

00:49:25,710 --> 00:49:29,860
always prefer standard array then vector

00:49:28,300 --> 00:49:31,900
then only these other containers if you

00:49:29,860 --> 00:49:35,170
if you have a really really good reason

00:49:31,900 --> 00:49:37,570
to that you can prove avoid use of

00:49:35,170 --> 00:49:39,400
shared pointer outright use standard

00:49:37,570 --> 00:49:46,900
function and when do you use standard

00:49:39,400 --> 00:49:48,730
bind yay so the result is this is the

00:49:46,900 --> 00:49:53,950
performance graph of chie script over

00:49:48,730 --> 00:49:57,400
time it's nearly a hundred times faster

00:49:53,950 --> 00:50:00,040
than it was a six years ago when an

00:49:57,400 --> 00:50:03,010
when I started working on it and as you

00:50:00,040 --> 00:50:04,750
can see it's clear by the performance

00:50:03,010 --> 00:50:12,280
graph here that eventually I'll be able

00:50:04,750 --> 00:50:13,930
to run any script in zero time this is I

00:50:12,280 --> 00:50:16,450
have automated performance monitoring

00:50:13,930 --> 00:50:18,460
setup so with every commit it runs some

00:50:16,450 --> 00:50:20,530
performance tests and it gives me

00:50:18,460 --> 00:50:25,030
another little pip to let me know that I

00:50:20,530 --> 00:50:27,400
am NOT that I am not making things worse

00:50:25,030 --> 00:50:29,440
so one thing that I've noticed that

00:50:27,400 --> 00:50:31,210
personally that I find interesting is as

00:50:29,440 --> 00:50:34,180
I'm simplifying the code making it

00:50:31,210 --> 00:50:38,080
smaller and making it faster these these

00:50:34,180 --> 00:50:41,320
dots represent the lines represent

00:50:38,080 --> 00:50:43,420
different compilers the performance of

00:50:41,320 --> 00:50:46,150
the different compilers is starting to

00:50:43,420 --> 00:50:47,950
converge so I some finding less

00:50:46,150 --> 00:50:49,690
difference between the compilers as I

00:50:47,950 --> 00:50:53,650
make my code simpler and follow these

00:50:49,690 --> 00:50:58,650
rules so is everyone wondering way why

00:50:53,650 --> 00:51:02,430
didn't you mention context / no one ok

00:50:58,650 --> 00:51:07,420
can we read this code those are

00:51:02,430 --> 00:51:13,980
templates and while let's see if I can

00:51:07,420 --> 00:51:17,620
zoom in on a reasonable way not really

00:51:13,980 --> 00:51:20,260
ok so this code is a Const exper is

00:51:17,620 --> 00:51:24,520
sorted routine and it just returns

00:51:20,260 --> 00:51:27,730
whether or not this initializer list of

00:51:24,520 --> 00:51:33,310
values 1 2 3 4 5 is sorted and we do

00:51:27,730 --> 00:51:34,750
that calculation at compile time so we

00:51:33,310 --> 00:51:36,760
expect to the staff in a compile time

00:51:34,750 --> 00:51:39,250
like I said because it's constant for so

00:51:36,760 --> 00:51:41,710
that's what we get we get the value 1

00:51:39,250 --> 00:51:44,170
returned that entire program says yes in

00:51:41,710 --> 00:51:48,250
fact that list of integers is sorted I'm

00:51:44,170 --> 00:51:53,740
going to return them what happens if we

00:51:48,250 --> 00:51:55,770
don't use context / we get the same

00:51:53,740 --> 00:51:55,770
thing

00:51:57,150 --> 00:52:01,360
assuming optimizations are enabled with

00:51:59,590 --> 00:52:03,040
context where you don't have to turn on

00:52:01,360 --> 00:52:04,210
optimizations with this you have to have

00:52:03,040 --> 00:52:12,030
at least bo1

00:52:04,210 --> 00:52:14,920
on GCC clang so I say for a Const expert

00:52:12,030 --> 00:52:16,840
that if you do full enabling of context

00:52:14,920 --> 00:52:19,030
worth throughout your code I've noticed

00:52:16,840 --> 00:52:22,450
that it can make the code larger because

00:52:19,030 --> 00:52:27,130
it can create some things like data

00:52:22,450 --> 00:52:29,470
structures that exist in your data

00:52:27,130 --> 00:52:31,770
segment of your code right like it

00:52:29,470 --> 00:52:36,730
because it can it can make the code

00:52:31,770 --> 00:52:40,270
compiled size bigger and as we have

00:52:36,730 --> 00:52:46,030
hopefully proven today larger code is

00:52:40,270 --> 00:52:48,640
often slower so I am a relatively

00:52:46,030 --> 00:52:50,320
conservative with my concepts per use

00:52:48,640 --> 00:52:51,820
but my advice would be if you're going

00:52:50,320 --> 00:52:53,140
to do it if you can say hey this data

00:52:51,820 --> 00:52:55,300
structure needs to be constant for

00:52:53,140 --> 00:52:57,310
enabled go all the way with it make sure

00:52:55,300 --> 00:52:58,540
you've got all the constructors all the

00:52:57,310 --> 00:53:01,180
excesses everything that you possibly

00:52:58,540 --> 00:53:02,770
can Const exper so then the compiler can

00:53:01,180 --> 00:53:04,900
use it as much as possible to actually

00:53:02,770 --> 00:53:08,880
remove that data structure from your

00:53:04,900 --> 00:53:14,640
code entirely in the best-case scenario

00:53:08,880 --> 00:53:14,640
then one quick bonus note on final

00:53:14,820 --> 00:53:21,640
proper use of finals everyone use final

00:53:17,800 --> 00:53:25,810
now that it exists yeah ok good getting

00:53:21,640 --> 00:53:28,120
hands raised if you um if you tell the

00:53:25,810 --> 00:53:30,520
compiler that a method is final or a

00:53:28,120 --> 00:53:33,610
class's final and then you know you have

00:53:30,520 --> 00:53:35,740
virtual functions it can inline those

00:53:33,610 --> 00:53:38,110
virtual functions that are final if it's

00:53:35,740 --> 00:53:39,370
able to deduce that that's in fact that

00:53:38,110 --> 00:53:41,170
you're using it from a context where

00:53:39,370 --> 00:53:45,580
that's the final version can have a

00:53:41,170 --> 00:53:47,940
pretty significant performance impact so

00:53:45,580 --> 00:53:51,070
to sum up why this works

00:53:47,940 --> 00:53:54,670
we're basically helping the branch and

00:53:51,070 --> 00:53:56,170
prediction branch predictions and code

00:53:54,670 --> 00:54:01,240
branches and such than the compiled in

00:53:56,170 --> 00:54:05,080
the CPU do the best job sorry simpler

00:54:01,240 --> 00:54:08,530
code has fewer branches so the CPU is

00:54:05,080 --> 00:54:10,510
less likely to take the wrong branch so

00:54:08,530 --> 00:54:12,940
according to Oh Pro file the latest

00:54:10,510 --> 00:54:16,360
version of Kai script has one point

00:54:12,940 --> 00:54:18,790
eight six times fewer branches then five

00:54:16,360 --> 00:54:22,030
point one did so it's not even that far

00:54:18,790 --> 00:54:23,200
back in my history and the CPU is able

00:54:22,030 --> 00:54:24,850
to have three times the branch

00:54:23,200 --> 00:54:31,000
prediction success rate

00:54:24,850 --> 00:54:33,520
and CPU caches hundreds thousands of

00:54:31,000 --> 00:54:36,250
times faster than main memory smaller

00:54:33,520 --> 00:54:40,270
code is faster code because it's more

00:54:36,250 --> 00:54:42,730
likely to fit in the CPU cache and again

00:54:40,270 --> 00:54:45,280
according to Oh profile I am now hitting

00:54:42,730 --> 00:54:48,970
the last level cache 35 times less often

00:54:45,280 --> 00:54:51,580
than I was and I have a 1% better cache

00:54:48,970 --> 00:54:56,140
hit right when I do have to hit the last

00:54:51,580 --> 00:54:58,930
level cache and finally we're doing what

00:54:56,140 --> 00:55:01,680
our compiler authors expect us to do if

00:54:58,930 --> 00:55:04,690
we're sticking with simple idiomatic C++

00:55:01,680 --> 00:55:06,520
falls into certain particular patterns

00:55:04,690 --> 00:55:12,340
that compilers like to look for and

00:55:06,520 --> 00:55:15,760
optimize for so then what is next from

00:55:12,340 --> 00:55:17,200
the in my opinion optimization

00:55:15,760 --> 00:55:18,760
standpoint here this is the slide we

00:55:17,200 --> 00:55:22,570
started with the beginning this is what

00:55:18,760 --> 00:55:27,310
I parsed tree of try script code looks

00:55:22,570 --> 00:55:30,190
like that says for and var at the top

00:55:27,310 --> 00:55:35,590
but that's our for loop 1 to 100 0 to

00:55:30,190 --> 00:55:38,050
100 and now I am running optimization

00:55:35,590 --> 00:55:40,240
passes on the choice parts to try script

00:55:38,050 --> 00:55:44,110
before ever try to execute it so now I

00:55:40,240 --> 00:55:46,540
say oh look that's a for loop from 0 to

00:55:44,110 --> 00:55:47,680
some number with a normal increment I

00:55:46,540 --> 00:55:50,650
know what this is

00:55:47,680 --> 00:55:55,780
and I just optimize it away from the try

00:55:50,650 --> 00:55:57,400
script now I think nearly every project

00:55:55,780 --> 00:56:00,700
of any significant size that's written

00:55:57,400 --> 00:56:05,460
in C++ probably gets user input is that

00:56:00,700 --> 00:56:10,480
a safe assumption yeah mostly somewhat

00:56:05,460 --> 00:56:13,300
so are there ways that you can take your

00:56:10,480 --> 00:56:15,400
users input and somehow simplify it

00:56:13,300 --> 00:56:17,140
optimize that put some sort of pass in

00:56:15,400 --> 00:56:20,110
front of it before you actually try to

00:56:17,140 --> 00:56:21,460
execute it and get that next extra level

00:56:20,110 --> 00:56:23,920
of performance that you need from your

00:56:21,460 --> 00:56:27,490
code so that's me

00:56:23,920 --> 00:56:30,580
again and if there's questions and if

00:56:27,490 --> 00:56:32,530
anyone wants I have coupons for O'Reilly

00:56:30,580 --> 00:56:37,440
videos that I've done up here if anyone

00:56:32,530 --> 00:56:37,440
wants 140 percent off so any questions

00:56:39,099 --> 00:56:56,270
nope yes it can

00:56:47,630 --> 00:56:58,730
Const exper can make the code bigger no

00:56:56,270 --> 00:57:00,230
I believe what it is is you know what I

00:56:58,730 --> 00:57:03,410
need to spend more time on it honestly

00:57:00,230 --> 00:57:07,160
but my impression is that using Const

00:57:03,410 --> 00:57:11,329
exper just causes more data structures

00:57:07,160 --> 00:57:14,660
to be compiled in to the code therefore

00:57:11,329 --> 00:57:16,760
you have you know more data like

00:57:14,660 --> 00:57:17,900
actually in your program code instead of

00:57:16,760 --> 00:57:19,790
something that be calculated at runtime

00:57:17,900 --> 00:57:21,710
I need to spend more time with it

00:57:19,790 --> 00:57:23,359
honestly I've only tested at a large

00:57:21,710 --> 00:57:24,890
scale and I haven't tried to narrow it

00:57:23,359 --> 00:57:28,490
down to the specific thing that was

00:57:24,890 --> 00:57:40,280
causing my problems yes you got a

00:57:28,490 --> 00:57:41,690
question right is there anything that we

00:57:40,280 --> 00:57:51,710
can do in our code to automatically

00:57:41,690 --> 00:57:52,940
detect some of these things yeah it's

00:57:51,710 --> 00:57:55,220
like making sure that you're not

00:57:52,940 --> 00:58:00,680
accidentally disabling your moves and

00:57:55,220 --> 00:58:03,500
that kind of thing I am not currently

00:58:00,680 --> 00:58:07,790
aware of any static analyzers that will

00:58:03,500 --> 00:58:11,089
report on most of these issues if anyone

00:58:07,790 --> 00:58:11,990
is feel free to chime in uh you had a

00:58:11,089 --> 00:58:13,700
question first

00:58:11,990 --> 00:58:15,559
yeah I just want to point out earlier

00:58:13,700 --> 00:58:17,089
somebody had a question on the shared

00:58:15,559 --> 00:58:18,740
pointer example why I didn't have

00:58:17,089 --> 00:58:20,390
exception handling yes and it's just the

00:58:18,740 --> 00:58:23,240
implementation detail the implementation

00:58:20,390 --> 00:58:25,849
gets to decide when new throws right so

00:58:23,240 --> 00:58:27,170
it doesn't have to throw right so it

00:58:25,849 --> 00:58:29,059
doesn't have to necessarily always have

00:58:27,170 --> 00:58:30,410
exception handling well there might be a

00:58:29,059 --> 00:58:32,720
question of why there wasn't a stack

00:58:30,410 --> 00:58:37,609
unwind injected into the main though I'm

00:58:32,720 --> 00:58:39,290
not sure there was nothing to unwind so

00:58:37,609 --> 00:58:41,780
the compiler optimized it away in other

00:58:39,290 --> 00:58:44,299
words or like if there had been more

00:58:41,780 --> 00:58:45,650
data in main you know more things going

00:58:44,299 --> 00:58:49,040
on in main then maybe it would have had

00:58:45,650 --> 00:58:53,960
it in there you're saying okay yes

00:58:49,040 --> 00:58:57,260
uh-oh sorry don't go ahead okay on the

00:58:53,960 --> 00:59:00,460
the question of can you detect the loss

00:58:57,260 --> 00:59:04,610
of your copy and move constructors

00:59:00,460 --> 00:59:06,170
there's there is there is a brute force

00:59:04,610 --> 00:59:09,290
way to do that which is to do a static

00:59:06,170 --> 00:59:12,830
assert after you've declared your your

00:59:09,290 --> 00:59:14,840
your class so do static asserts of the

00:59:12,830 --> 00:59:18,050
you know is this movable is this

00:59:14,840 --> 00:59:21,740
whatever using the using the type traits

00:59:18,050 --> 00:59:24,410
and if you do that religiously then you

00:59:21,740 --> 00:59:26,330
will know and your your compiler will

00:59:24,410 --> 00:59:26,750
enforce that that that's exactly what

00:59:26,330 --> 00:59:31,640
you're getting

00:59:26,750 --> 00:59:35,360
okay yeah well you you said that you

00:59:31,640 --> 00:59:38,450
have almost 100 X improvement in time

00:59:35,360 --> 00:59:43,700
yes and I wonder what was the main cause

00:59:38,450 --> 00:59:47,570
of it the not doing the unnecessary work

00:59:43,700 --> 00:59:50,210
or by optimizing memory layouts

00:59:47,570 --> 00:59:52,700
it was chipping away at it like 10% at a

00:59:50,210 --> 00:59:55,520
time it's just I looked back through my

00:59:52,700 --> 00:59:57,890
entire code history and the couple of

00:59:55,520 --> 01:00:00,470
big wins are things that I did call out

00:59:57,890 --> 01:00:02,330
here like not reap arcing my integers

01:00:00,470 --> 01:00:04,940
every time so not repeating myself and

01:00:02,330 --> 01:00:07,870
my work and making sure that I didn't

01:00:04,940 --> 01:00:12,230
accidentally disable my move operations

01:00:07,870 --> 01:00:13,640
but it's yeah it's the the really big

01:00:12,230 --> 01:00:16,310
gains right at the beginning of that

01:00:13,640 --> 01:00:19,390
history or like really like dumb things

01:00:16,310 --> 01:00:23,120
I don't even remember what they were

01:00:19,390 --> 01:00:25,660
okay anything else all right thank you

01:00:23,120 --> 01:00:25,660

YouTube URL: https://www.youtube.com/watch?v=uzF4u9KgUWI


