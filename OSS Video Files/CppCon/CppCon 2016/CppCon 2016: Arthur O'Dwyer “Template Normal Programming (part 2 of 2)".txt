Title: CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 2 of 2)"
Publication date: 2016-09-29
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
What is "template normal programming"? It's template metaprogramming without so much of the "meta" part!  During this talk, I promise not to mention SFINAE, or recursion, or standard type traits. We'll focus on the common scenarios "I think this code could benefit from templates, but I don't understand how to organize it;" "I can't get anything to compile without errors;" and "My coworker wrote some template code and I don't understand any of it." 

In Part I of the talk, we'll start with function templates and class templates, then explain variable templates (new in C++14) and template aliases (new in C++11). We'll do a deep dive into template type deduction; then talk about full and partial specialization; and finish up with an example that motivates the final feature of C++11 template syntax, explicit instantiation.

In Part II of the talk, we'll begin by demystifying tag dispatch and traits classes; discuss situations in which you have to add disambiguating "template" or "typename" keywords (and why); and do a deep dive into the rules of what gets instantiated when and where. We'll revisit template type deduction just long enough to explain how it works for variadic templates; and explain two common template idioms — the Curiously Recurring Template Pattern and the Mixin Pattern.
Time permitting, we'll finish by exploring the big new features of templates according to the C++17 Draft Standard:
- template
- type deduction for class template constructors
- explicit deduction guides
— 
Arthur O'Dwyer
Software Engineer, Mixpanel
Arthur O'Dwyer worked for many years at Green Hills Software, making the world's most optimizing C and C++ compilers. Now he works at Mixpanel in San Francisco, where he organizes a monthly C++ meetup.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,020 --> 00:00:03,500
Hello folks. We're going to start again.

00:00:03,900 --> 00:00:07,700
We've got quite a bit more to get through, hopefully.

00:00:07,700 --> 00:00:12,720
So let's pick up where we left off: with how to partially specialize a function the right way.

00:00:12,720 --> 00:00:19,580
Remember from last time: Function templates cannot be partially specialized. You can't do it.

00:00:19,700 --> 00:00:23,340
So if we have something that we want to behave like a function,

00:00:23,340 --> 00:00:26,459
which is to say it's a procedure for doing a thing from some inputs and getting some outputs,

00:00:26,460 --> 00:00:30,800
and we need it to be partially specialized on the type of those inputs,

00:00:30,800 --> 00:00:35,820
the right way to do it is to delegate the partial-specialization work off to some thing that CAN be partially specialized...

00:00:35,880 --> 00:00:37,980
...such as a class template.

00:00:37,980 --> 00:00:43,980
Use the right tool for the job. If you need partial specialization, use something that can be partially specialized, and don't use something that can't.

00:00:43,980 --> 00:00:55,660
So, in this case, I have a single function template called `is_pointer`; and all it does is instantiate one of these two class templates.

00:00:55,660 --> 00:00:59,500
I have a primary template up top, and I have a partial specialization of this class...

00:00:59,500 --> 00:01:03,560
...it's a partial specialization, because it's got angle brackets after the name `is_pointer_impl`...

00:01:03,560 --> 00:01:08,880
It's got angle brackets. That means it's a partial specialization.

00:01:08,880 --> 00:01:14,760
And I just dispatch to one or the other of them, and it works.

00:01:14,760 --> 00:01:20,920
And this is also how I could implement the `is_void` trait earlier, using a full specialization.

00:01:20,920 --> 00:01:25,740
Now you know everything there is to know about all these kinds of things. Which is nice.

00:01:25,740 --> 00:01:31,140
But there's still one more thing that I want to explain. Let's talk about translation units.

00:01:31,140 --> 00:01:33,840
So here's a puzzle — which we're not actually going to puzzle over — but...

00:01:33,840 --> 00:01:38,020
Suppose we had to write a function to reverse the characters of a possibly multibyte string, in place.

00:01:38,020 --> 00:01:46,260
Only POSSIBLY multibyte. We also want versions that work for ASCII, UTF-8, you know, different character sets. Latin-1.

00:01:46,260 --> 00:01:54,560
But we don't want to do it using the old terrible, you know, `mblen`, `mbtowc`, all these different functions with locales, which is how C did it.

00:01:54,560 --> 00:02:02,580
We would like it to be compile-time and be able to parameterize it on the character set itself. And we're going to do that as a template parameter.

00:02:02,580 --> 00:02:06,180
So how I would use it might look something like this:

00:02:06,260 --> 00:02:14,120
I've got this function called `reverse`, and it takes as a template parameter — Oops, so it's a function TEMPLATE. I keep calling these things "functions" —

00:02:14,120 --> 00:02:21,980
It takes a template parameter called `Charset`, and that could be one of these little tag-structs up here: `struct ascii` or `struct utf8`...

00:02:21,980 --> 00:02:32,200
And depending on the value — or, depending on the type — that's passed in, I get one behavior or the other.

00:02:32,200 --> 00:02:36,240
Now, `reverse` can be implemented basically like this...

00:02:36,240 --> 00:02:44,140
This is, you know, reverse each individual character and then reverse the entire string.

00:02:44,140 --> 00:02:48,640
That's a good interview question, by the way. Remember those for your whiteboards.

00:02:48,640 --> 00:02:58,860
And it relies on `mblen<Charset>`, which is a function that's going to return, you know, given where I am in the string, tell me how many bytes are in this next character.

00:02:58,860 --> 00:03:04,940
For ASCII, that's always going to be 1. For UTF-8, it could be anywhere from 1 to 4, or maybe 5.

00:03:04,940 --> 00:03:09,460
So we're going to need to define some full specializations of `mblen` here.

00:03:09,460 --> 00:03:12,460
`mblen<ascii>` always returns 1.

00:03:12,460 --> 00:03:22,500
`mblen<utf8>` returns something complicated that — oh, well... hmm. I don't want to define all this in my header file. This makes me sad.

00:03:22,500 --> 00:03:33,940
I would like to move the definition of this template function — this full specialization — out into a .cpp file. Another "translation unit." That's a term of art there.

00:03:33,940 --> 00:03:39,040
So I can do that. This is a definition just like any other function definition,

00:03:39,040 --> 00:03:44,180
and I can make it a function declaration just like any other function declaration by just putting a semicolon there.

00:03:44,180 --> 00:03:50,140
And then off in my .cpp file I can write out the actual implementation of it, as we see here.

00:03:50,240 --> 00:03:56,920
So here I have my .cpp file, at the bottom, which has the definitions of my full specializations.

00:03:56,920 --> 00:04:02,320
And then in my header file, I have the declarations of those two specializations.

00:04:02,320 --> 00:04:08,600
And I have the definition of the primary template for `reverse`. Does that make sense?

00:04:08,600 --> 00:04:12,180
This works fine. However, that's still a lot of code.

00:04:12,180 --> 00:04:16,480
I don't want all THAT code. It wasn't too much, it was like that much — but still I don't want it in my header file.

00:04:16,480 --> 00:04:23,100
I want to put my implementation code in my .cpp file if I can.

00:04:23,100 --> 00:04:29,760
So how do I get rid of that? Well that brings us to this next little bit of syntax here.

00:04:31,270 --> 00:04:35,460
So I can— oops, not quite yet. First I can say, "okay, well, I'll just specialize it."

00:04:35,460 --> 00:04:40,040
"I'll specialize it fully for `reverse<ascii>` and `reverse<utf8>`..."

00:04:40,300 --> 00:04:44,040
I'll tell it that I have full specializations of these, and I'll put the full specializations down in the .cpp file.

00:04:44,040 --> 00:04:48,700
But now I've repeated the implementation twice. And I don't want to do that either.

00:04:48,700 --> 00:04:51,540
So what do I do now?

00:04:51,540 --> 00:04:54,560
Okay, well, now we get to a new piece of syntax here. "Explicit instantiation definition."

00:04:54,570 --> 00:04:59,370
This is a special syntax that means "Please instantiate this template with the given template parameters, as if it were being used right here."

00:05:00,940 --> 00:05:06,740
It doesn't tell you how to define it; it just says, "I would like this defined, please."

00:05:06,740 --> 00:05:12,360
So it looks just like a full specialization, except that after the word `template`, where a full specialization has empty angle brackets,

00:05:12,360 --> 00:05:14,360
(I told you those were important, because now they go away!)

00:05:15,040 --> 00:05:23,500
`template` WITHOUT the empty angle brackets is a completely different thing which has no relation to an explicit specialization.

00:05:23,500 --> 00:05:29,560
And so it has a completely different name that could not possibly be confused with it </sarcasm> called "explicit instantiation."

00:05:29,760 --> 00:05:34,780
And it looks like this. The word `template` with no angle brackets, and then you declare the thing —

00:05:34,780 --> 00:05:40,120
— again, basically as if you were going to use it. Like, `class vector<int>`, for example; `bool is_void_v<void>`;

00:05:40,120 --> 00:05:44,800
and that just means "instantiate the thing right here, please."

00:05:44,800 --> 00:05:53,480
Now, if I don't want to instantiate it right here, and I would just like to instantiate its DECLARATION, and say, well, it's defined somewhere else, I can just stick the word `extern` in front of it.

00:05:53,480 --> 00:05:59,420
That's what `extern` does, right? It sort of says, like, "Here's the declaration. The definition is somewhere else."

00:05:59,420 --> 00:06:02,780
And then you'd better define it somewhere else.

00:06:02,780 --> 00:06:09,180
All right, so that's explicit instantiation definition and explicit instantiation declaration.

00:06:09,180 --> 00:06:13,980
So there's one interesting thing about explicit instantiation for class templates which is different from anything else.

00:06:13,980 --> 00:06:20,720
Because the weird thing about classes in C++ — the neat thing about them in particular — is they can have members.

00:06:20,720 --> 00:06:25,800
A function cannot have members. A variable cannot have members. But a class can have members.

00:06:25,800 --> 00:06:38,420
And so when I explicitly instantiate the definition of a class, that counts as an explicit instantiation of all of that class's members as well.

00:06:38,420 --> 00:06:40,860
So when I say I'm instantiating a class `Foo<int>`,

00:06:40,860 --> 00:06:47,140
I also get `Foo<int>::f` and `Foo<int>::g` in this translation unit as well.

00:06:47,140 --> 00:06:55,660
So this is a way, if you have a whole bunch of very similar templates and you would like to explicitly instantiate them all in one go,

00:06:55,660 --> 00:07:01,260
maybe stick them all as static members of some class, and then just instantiate that class. Boom.

00:07:02,780 --> 00:07:06,480
If that's a case you ever run into yourself, y'know.

00:07:07,560 --> 00:07:10,720
So we can explicitly instantiate without specializing. It looks like this.

00:07:10,720 --> 00:07:14,260
So here we have a primary template — still in the .h file —

00:07:14,260 --> 00:07:18,540
and we're saying `extern template`, no angle brackets; so that's an explicit instantiation declaration

00:07:18,540 --> 00:07:22,240
that says I have explicitly instantiated this somewhere in my code.

00:07:22,240 --> 00:07:26,620
Not here. Don't worry about it, you know, just use it. Don't try to define it yourself.

00:07:26,620 --> 00:07:31,080
And in the .cpp file, that's where I say `template` — no angle brackets —

00:07:31,080 --> 00:07:38,580
and that's an explicit instantiation definition that causes `reverse<ascii>` and `reverse<utf8>` to get instantiated there.

00:07:40,960 --> 00:07:43,960
Don't mix and match though. These angle brackets are important.

00:07:43,960 --> 00:07:59,860
If I stick the angle brackets on up here, that says I have somewhere — not here because I don't have a body here, but somewhere — I have an explicit specialization, a full specialization, of `reverse<ascii>`.

00:07:59,860 --> 00:08:12,760
But I don't actually make one in my .cpp file. In my .cpp file, I don't specialize it. I just instantiate the primary template, because I forgot the angle brackets there. And so this is not guaranteed to work.

00:08:12,760 --> 00:08:18,460
Although it does work, in practice, for reasons of name-mangling. Here's the deal with name-mangling.

00:08:18,460 --> 00:08:22,300
This is exactly the case we just looked at, right? Right.

00:08:22,300 --> 00:08:30,880
So on the left— ah, these are two translation units — the two little papery things — two different modules, two different .cpp files that I'm compiling.

00:08:30,880 --> 00:08:44,180
And in the one .cpp file I've said `template<> int a(int)` — and that is saying, somewhere in my code I have a full specialization of `a`.

00:08:44,180 --> 00:08:49,840
Not here, but somewhere. And I try to call it.

00:08:50,880 --> 00:08:58,660
Across in the right-hand one, I instantiate the primary template.

00:08:58,660 --> 00:09:07,080
Now it happens that instantiating the primary template generates some code, and the code's mangled function name—

00:09:07,080 --> 00:09:12,260
People, is name-mangling, like, vaguely familiar? Yeah, okay.

00:09:12,340 --> 00:09:20,760
So it happens that the name of the thing that gets instantiated there just happens to mangle to the exact same thing as the thing that I'm calling. And so it will work.

00:09:20,760 --> 00:09:24,020
But try not to do that.

00:09:24,080 --> 00:09:34,280
And if you reverse it, and I put over here — this is an explicit instantiation declaration, on the left, without the angle brackets.

00:09:34,280 --> 00:09:42,240
And on the right, I've got a full specialization that says, "well, here's the full specialization."

00:09:42,240 --> 00:09:45,240
We now have two competing definitions.

00:09:45,240 --> 00:09:50,980
Oops, I'm sorry, the thing on the left is not a declaration; it's a definition, because I didn't say the word `extern`.

00:09:50,980 --> 00:09:53,080
So we actually have two competing definitions.

00:09:53,080 --> 00:09:59,680
And they're probably not the same, because the one on the left is an instantiation of the `{ ... }` in the primary template on the left,

00:09:59,680 --> 00:10:03,340
and the one on the right has its own little `{ ... }` that might have something completely different in it.

00:10:03,340 --> 00:10:14,460
And so the answer that I get from my `main` here is going to depend on whether it was inlined from MY translation unit, or if it generated an out-of-line function call to the other one...

00:10:14,460 --> 00:10:16,440
And it could depend on optimization level...

00:10:17,480 --> 00:10:24,920
Or what order they happen to get linked in... which order the linker decided to throw away the duplicate definition.

00:10:24,920 --> 00:10:30,900
So this is fragile even in practice and may change depending on things. So don't mix and match.

00:10:30,900 --> 00:10:33,060
Now you know everything there is to know about explicit instantiation!

00:10:33,060 --> 00:10:40,400
That actually concludes Part 1. Awesome. Do we have any questions from the audience while I go to Part 2?

00:10:40,400 --> 00:10:44,280
If you're lucky, you'll get an answer from the speaker while I go to Part 2, which is the bigger... Yeah.

00:10:44,280 --> 00:10:48,940
[INAUDIBLE FROM AUDIENCE]

00:10:48,940 --> 00:10:52,200
Can I do explicit instantiation of classes and extern them as well?

00:10:52,200 --> 00:11:00,320
I believe that you can. Not 100% sure about that, but I think so, and I think that would do the obvious thing,

00:11:00,320 --> 00:11:11,400
which is to say, "I have definitely explicitly instantiated this somewhere, but it's not here" — and it would say that about all of the members of the class.

00:11:11,400 --> 00:11:17,600
[INAUDIBLE FROM AUDIENCE]

00:11:17,600 --> 00:11:27,760
How do you explicitly instantiate a static member function of a class template where the static member function is actually a static member function template?

00:11:27,760 --> 00:11:32,520
And it depends whether that class template—

00:11:32,520 --> 00:11:40,340
Are you making a template that can stamp out instantiations of the static—

00:11:40,340 --> 00:11:44,940
Well, you've got two level of cookie-cutter there, right? and you can do each one individually – and this is what you will see sometimes —

00:11:44,940 --> 00:11:49,600
where you have, like, `template<class T> template<class U>`, some stuff.

00:11:49,600 --> 00:11:54,560
That's the syntax for if I have a class template which has a member which is a template,

00:11:54,600 --> 00:12:05,120
And here I am making a cookie cutter to stamp out cookie cutters to stamp out the actual definition of the thing. Because I have a template for a template of a thing.

00:12:05,120 --> 00:12:10,180
And I'm not actually going to cover that, which is too bad!

00:12:10,180 --> 00:12:13,960
All right. Does anyone need a refresher on Part 1? All right.

00:12:16,860 --> 00:12:21,340
So let's talk about some idioms that we can use with templates.

00:12:21,340 --> 00:12:28,720
Let's say I wanted to specialize on some condition that was more complicated than that "just make a full specialization for void" example that I gave earlier.

00:12:28,720 --> 00:12:37,620
So here I have an example inspired from real life, where I have a tree container and a vector container, and they both have iterators.

00:12:37,620 --> 00:12:48,140
I have a `tree_iterator` that, when I'm going through a tree, I can only `++` it. I can't hop `n` nodes ahead in the tree without following the `next` pointers.

00:12:48,140 --> 00:12:52,800
But with a vector, I can just do a random access iterator.

00:12:52,800 --> 00:12:56,780
And I have a `vector` and `set` down at the bottom using them.

00:12:56,780 --> 00:13:03,000
Actually, okay, hang on. What is this? I said `tree_iterator&`.

00:13:03,000 --> 00:13:09,740
I thought that whenever I referred to a class template I always needed to put the angle brackets because otherwise it wouldn't be able to deduce what I meant!

00:13:09,740 --> 00:13:12,960
Well. There's a special case.

00:13:12,960 --> 00:13:25,240
The special case is if I'm actually inside the definition of that class template itself, then I can kind of deduce which `T` I mean. And the `T` I mean is `T`.

00:13:25,240 --> 00:13:34,120
I'm inside the class definition, where I've got my template parameters, like `Element`, so `tree_iterator` implicitly means `tree_iterator<Element>`.

00:13:34,120 --> 00:13:37,750
Because I happen to be inside the definition itself of `tree_iterator<Element>`.

00:13:37,750 --> 00:13:43,320
This is known as the — I'm going to say it's an "injected class-name," and I'm probably pretty close to right.

00:13:44,880 --> 00:13:51,480
So yes, the bare template-name can be used as a typename. In which case it's basically as if you put all the template parameters after in angle brackets.

00:13:51,480 --> 00:13:58,900
This is fine. It helps cut down on repetition, especially in declaring things like the copy assignment operator and things like that. I recommend that you use it.

00:14:01,100 --> 00:14:04,540
And especially that you know what it means when you see it.

00:14:04,540 --> 00:14:05,900
All right. So where were we?

00:14:05,900 --> 00:14:11,400
So we have a standard algorithm called `advance` that takes an iterator of some type and advances it by N positions.

00:14:11,400 --> 00:14:15,620
And here's the implementation of it. It just calls `++` N times.

00:14:15,620 --> 00:14:20,300
For random access iterators, we can actually do better. We could write something like this.

00:14:20,300 --> 00:14:24,260
This is `advance` specialized for `vector_iterator`s.

00:14:24,260 --> 00:14:31,520
It takes a `vector_iterator` of some element type, and in that case it's going to return `begin + n`.

00:14:31,520 --> 00:14:33,760
However! No! Wrong!

00:14:33,760 --> 00:14:38,660
That would be — that looks like it's trying to be a partial specialization, right?

00:14:38,660 --> 00:14:45,380
It's got the same name as this primary template, but it's sort of more specialized? But it's not fully specialized.

00:14:45,380 --> 00:14:51,260
Function templates can be fully specialized, but they can't be partially specialized. No no no. Don't.

00:14:51,260 --> 00:14:54,140
Therefore, we shouldn't do it this way.

00:14:54,140 --> 00:14:58,540
We could do it the other way, by implementing it as a class template.

00:15:00,540 --> 00:15:03,220
But let's just do something like this.

00:15:03,220 --> 00:15:10,260
Let's say for `tree_iterator`... I'm going to generalize a little bit. I'm going to say we're not going to specialize JUST for `vector_iterator`.

00:15:10,260 --> 00:15:14,060
Because I might add some new kind of random access iterator later.

00:15:14,060 --> 00:15:19,420
So I've got my `tree_iterator`, and I'm going to add a member to it — because I control all these different iterator types —

00:15:19,420 --> 00:15:25,980
And I can just add a member that says `supports_plus`: False. And `supports_plus`: True.

00:15:25,980 --> 00:15:37,200
And then I can overload. I can make a pair of function templates, which are not— they don't look anything like partial specializations, because, again, they can't be —

00:15:37,200 --> 00:15:40,300
Because they take a different parameter type as the third parameter.

00:15:40,300 --> 00:15:45,940
One of them takes, particularly, `false_type`; and the other one takes, particularly, `true_type`.

00:15:45,940 --> 00:15:52,500
And I'm going to pass `Iter::supports_plus` to those...

00:15:52,500 --> 00:15:55,880
Let me go back one slide.

00:15:55,880 --> 00:16:04,500
Let me point out, for those of you who are already familiar with tag dispatch, that in this case for the sake of pedagogy `supports_plus` is not a member typedef!

00:16:04,500 --> 00:16:10,500
It is actually a static member variable of type `false_type`.

00:16:10,500 --> 00:16:15,020
Have people seen `true_type` and `false_type`? This is one bit of `<type_traits>` that's actually useful to know.

00:16:15,020 --> 00:16:24,460
You might say, "well, isn't that just `bool`?" No, it's not bool. These are actually two different types, as different as `int` and `double`. They're very different types.

00:16:24,460 --> 00:16:31,940
And they happen to be, for some reason, associated with the semantic values of True and False.

00:16:31,940 --> 00:16:41,020
It's as if we pretended that `int` were True and `double` were False. They're just two completely different types that happen to be associated with the concepts of "True" and "False."

00:16:41,020 --> 00:16:47,760
And they're useful for things like this, where we're trying to overload on these concepts — these compile-time concepts of "True" and "False."

00:16:47,760 --> 00:16:50,280
And that's NOT using "Concepts" in the Bjarne sense.

00:16:50,280 --> 00:16:55,460
Yeah. [INAUDIBLE FROM AUDIENCE]

00:16:55,460 --> 00:16:59,480
Yes, I could, but that would make this slide a little bit more complicated.

00:16:59,480 --> 00:17:03,080
Does everyone see how this slide works, before we go to the next one?

00:17:05,620 --> 00:17:07,620
All right, in practice, yes, it will look more like this.

00:17:07,620 --> 00:17:18,560
So up here, instead of declaring a static data member called `supports_plus`, I will instead make a member alias, a member typedef, named `supports_plus`.

00:17:18,560 --> 00:17:31,940
`tree_iterator<E>::supports_plus` is now an alias for `false_type`. And `vector_iterator<E>::supports_plus` is now an alias for `true_type`.

00:17:31,940 --> 00:17:35,580
And I do the same thing with `advance_impl` here.

00:17:35,580 --> 00:17:43,780
And my `advance` calls this function `advance_impl` with `begin` and `n` — and then this little expression here.

00:17:43,780 --> 00:17:46,520
`typename Iter::supports_plus{}`.

00:17:46,520 --> 00:17:58,880
So the curly braces are there because we're trying now to create an object of that type, right? Those are the curly braces that you would... it could also be parens... that would also work.

00:17:58,880 --> 00:18:06,460
But why the word `typename`? How many people have been writing template code and you've had to stick the word `typename` somewhere?

00:18:06,460 --> 00:18:08,600
All right.

00:18:08,600 --> 00:18:17,100
How many people got confused by that? All right. Good. Well, so what's going on with this `typename`?

00:18:17,100 --> 00:18:19,860
So C++'s grammar is not context-free.

00:18:20,280 --> 00:18:26,720
Normally, "context-free grammar" is one of these CS-something terms that you don't really need to know.

00:18:26,720 --> 00:18:32,520
But in order to parse a function definition you actually need to know something about the context in which that function is being defined.

00:18:32,520 --> 00:18:37,860
Namely, you need to know things like, in this example, is `A` a function or a type?

00:18:37,860 --> 00:18:42,000
If `A` is a function, then `A(x)` is a function call.

00:18:42,000 --> 00:18:49,720
If it's a type then this is like `int x`, all right? If `A` is a type, I'm just declaring `x` to be of type `A`.

00:18:49,720 --> 00:18:58,340
So I need to know something about the context: "What is `A`?" And so if the context ends up being dependent on a template parameter,

00:18:58,340 --> 00:19:02,740
where I don't know what that parameter is yet — `T::A`, I don't know what that is.

00:19:02,740 --> 00:19:06,840
That might be a function; it might be a type; it might be something else, right?

00:19:06,840 --> 00:19:09,340
So, how can this possibly work?

00:19:09,340 --> 00:19:21,560
How can I have this function here — a function template — and I instantiate it with `S1`, where `S1::A` is a function, then this should be a function call to `S1::A`.

00:19:21,560 --> 00:19:29,700
And in this case, `foo<S2>`... Well, this should be a declaration of an `int`. How can we possibly make this work?

00:19:29,700 --> 00:19:33,760
The answer is we can't. That's too much work.

00:19:33,760 --> 00:19:42,660
So we're just going to assume that any name that depends on a template parameter refers to a non-type, non-template, plain old entity.

00:19:42,660 --> 00:19:47,420
It's going to be, you know, a variable or a function, or, you know... but it's a noun.

00:19:47,420 --> 00:19:50,160
Well, okay, a type is a noun too. But it's not going to be a type.

00:19:50,160 --> 00:19:54,880
It's not going to be a type or a template or any weird thing. It's going to be a regular old — just the normalest thing you can imagine.

00:19:56,100 --> 00:20:13,340
So in this example, `foo<S2>`, if we try to compile that, it's going to go instantiate it and it's going to say, "`S2::A` is some plain old thing that I'm going to call with `x`... Oh, but it's not a plain old thing. It's `int`. Well, that doesn't make sense."

00:20:13,340 --> 00:20:23,780
It's going to give you an error. It's going to say, "That was parsed as a non-type. I assumed it was a non-type originally, but instantiation of `foo<S2>` yields a type." So, hard error.

00:20:25,080 --> 00:20:31,440
And this is how we fix it. We stick the word typename in front; to let the compiler know when it parses that template,

00:20:31,440 --> 00:20:39,620
"Hey, this thing coming up? It might look like a regular old plain thing. You're going to assume it's a plain old thing because it's dependent on a template parameter, but it's not."

00:20:39,620 --> 00:20:46,340
"I'm telling you it's a typename. So please treat it as a typename." That means this is a definition. A variable definition.

00:20:46,340 --> 00:20:58,560
And now if I try to compile THIS one with `S1`, it will say, "Hey! You told me `T::A` was a typename, and it's not!" So it'll be an error.

00:20:58,600 --> 00:21:05,720
Similarly we have things to refer to a template. Let's say I had these three types, `S1`, `S2`, `S3`...

00:21:07,080 --> 00:21:11,120
...and I try to do this. Does this work?

00:21:11,120 --> 00:21:14,280
I'll give you a moment to digest this a little bit.

00:21:14,280 --> 00:21:18,080
`S1::A` is an `int` with value 0.

00:21:18,080 --> 00:21:28,860
0 less than 0, greater than `x`, discard the result. Okay. Sure. That works great.

00:21:30,220 --> 00:21:32,980
`foo<S2>`.

00:21:32,980 --> 00:21:42,860
`T::` — so, that's `S2::` — now, at this point, `A` is not a plain old thing. `A` is a template. So we have to tell it, `template A`.

00:21:42,860 --> 00:21:45,260
`template A`, okay, this is an angle bracket!

00:21:45,260 --> 00:21:53,360
And the `0` is substituting in for `N`, so `N` equals `0` in that instantiation; and then we're going to call it with `x`.

00:21:53,360 --> 00:21:56,200
Okay, so that works.

00:21:56,200 --> 00:22:09,720
And then in `S3`, we actually have a variable declaration. We're declaring variable `x` to be of type `S3::A`, with `N` equal to 0.

00:22:09,720 --> 00:22:14,520
So that's where these `typename` and `template` keywords come into play.

00:22:14,520 --> 00:22:19,740
So hopefully from that you can figure out where to use them in the future.

00:22:19,740 --> 00:22:26,620
Questions about `template`, `typename`, dependent contexts?

00:22:26,620 --> 00:22:37,720
So let's go back to our type dispatch example. We see now why we have the `typename` down there. Because if we didn't, it would assume, because `Iter` is a template parameter, `Iter::supports_plus` is probably a variable.

00:22:37,720 --> 00:22:41,300
And that's why my original example, where it WAS a variable, worked out great.

00:22:41,300 --> 00:22:48,520
As soon as I make it a typename instead, well, now I need to tell it explicitly when it parses this template, "Hey, this is a typename coming up."

00:22:48,520 --> 00:22:51,160
Otherwise I get a syntax error.

00:22:51,740 --> 00:22:56,800
Okay, so now you know everything there is to know about tag dispatch... except... what if we don't control `Iter`?

00:22:56,800 --> 00:23:09,860
Because this entire thing up here depended on my being able to insert this `supports_plus` member into `tree_iterator` and `vector_iterator`. What if I wanted to work with plain old pointers?

00:23:09,860 --> 00:23:16,400
Okay, we have no class off of which to hang our `supports_plus` member typedef. What do we do? We make one up!

00:23:16,940 --> 00:23:23,820
So I'm going to make up a new class. I'm going to call it `iter_traits`, and it's going to be a class template.

00:23:23,820 --> 00:23:30,040
The primary template is going to say that by default `supports_plus` is an alias for `false_type`,

00:23:30,040 --> 00:23:34,160
and for `vector_iterator`, `supports_plus` is going to be an alias for `true_type`.

00:23:34,180 --> 00:23:39,640
This is a partial specialization, which is totally fine because class templates are allowed to do partial specialization.

00:23:39,640 --> 00:23:45,300
And I'm going to make another partial specialization for `T*`, where `supports_plus` is also `true_type`.

00:23:45,300 --> 00:23:51,960
And then I can just use `typename iter_traits<Iter>::supports_plus`.

00:23:51,960 --> 00:23:59,540
If `Iter` happens to be one of those types for which we've partially specialized the `iter_traits` class template, `supports_plus` will be `true_type`.

00:23:59,540 --> 00:24:09,520
I will make a new instance of type `true_type`. I will pass that as the third argument to `advance_impl`. Overload resolution will say, "Ah! You must want the one that takes the third argument of type `true_type`."

00:24:09,520 --> 00:24:15,240
And it will do the fast random-access implementation.

00:24:15,240 --> 00:24:24,080
If it's not one of those, it will instantiate the primary template; create an instance of type `false_type`; pass that to the one whose third argument is `false_type`... yeah.

00:24:26,320 --> 00:24:36,600
STL best practices: You can also, if you want — you take this `iter_traits<Iter>::supports_plus`, and the fact that we had to write `typename` in front of it — you can again get rid of that...

00:24:36,600 --> 00:24:43,140
by creating an alias template, and stick the `typename` up in the alias template.

00:24:43,140 --> 00:24:50,140
And then your code gets cleaner, because an alias template always refers to a type, so we don't have to stick `typename` in front of it anymore.

00:24:50,140 --> 00:25:03,520
[INAUDIBLE FROM AUDIENCE]

00:25:03,520 --> 00:25:09,020
Yes. So in tag dispatch, we have one more nested function call in here. Is the assumption that we can just inline it away?

00:25:09,020 --> 00:25:15,140
Yep, it sure is. Compilers are great at inlining.

00:25:15,140 --> 00:25:17,860
Now you know everything there is to know about traits classes!

00:25:17,860 --> 00:25:22,120
Let's talk about declarations and definitions.

00:25:22,120 --> 00:25:25,460
We have three cases here. One is normal entities like functions and variables.

00:25:25,460 --> 00:25:30,340
This is the case that we should all be real familiar with. It's the case that exists in C.

00:25:30,340 --> 00:25:34,760
So I have here a function declaration; a variable declaration;...

00:25:34,760 --> 00:25:41,200
In the other translation unit — right? two different translation units here, two different .cpp files — I have the definitions.

00:25:41,200 --> 00:25:45,120
And when I try to use them from the left-hand translation unit,

00:25:45,120 --> 00:25:54,360
Well, they're declared; so it compiles fine, and then the linker finds the definitions over in the right-hand side, and it links, and we're happy.

00:25:54,360 --> 00:25:59,920
`inline` functions and variables work a little bit differently. You can define them in two places and it will work just fine.

00:25:59,940 --> 00:26:09,800
And the way that works is that the linker will find out that, "Oh! you have two definitions of this," and where normally that would be a multiple definition error, the linker will instead just throw away all but one of them.

00:26:09,800 --> 00:26:16,360
It'll just quietly throw them away, and take whichever one happened to come in first or whatever heuristic it wants to use.

00:26:16,360 --> 00:26:21,320
So in this case, I've actually defined `a` in two places. And this works just fine.

00:26:21,320 --> 00:26:24,160
And I'm actually using it in two places as well.

00:26:25,500 --> 00:26:27,500
Yes.

00:26:27,900 --> 00:26:35,800
"What if they're different definitions?" Then you have undefined behavior. So don't do that. Yeah.

00:26:37,260 --> 00:26:48,840
Now suppose I do something like this, where I have a declaration of the inline function over here, but I haven't told the compiler how to define it.

00:26:48,840 --> 00:26:54,320
But I'm still trying to use it. And then over on the right-hand side I have something that does create a definition of it.

00:26:54,320 --> 00:27:01,940
So if I manage to get this all the way through the compiler to the linker, — which I believe you can in all major implementations with at most, like, a warning —

00:27:01,940 --> 00:27:11,240
it will actually work, because the linker is totally happy. It says, "Oh! you're using `a`? I've got a definition for `a`!" And it links. But this is officially ill-formed.

00:27:11,240 --> 00:27:13,720
So avoid this.

00:27:13,720 --> 00:27:16,560
However, the linker will kind of do the right thing.

00:27:18,760 --> 00:27:26,520
However, this is ill-formed because "an inline function or variable shall be defined in every translation unit in which it is ODR-used outside of a discarded statement."

00:27:26,520 --> 00:27:35,380
And in the left-hand translation unit we have an inline function or variable which is ODR-used in `main`, but it is not defined.

00:27:35,380 --> 00:27:44,940
It's defined in a different translation unit in the same program, which is why the linker is totally happy and it probably works in practice, but, yeah, officially, don't do this.

00:27:44,940 --> 00:27:48,500
And especially — I mean a good reason not to do this in practice, either — is,

00:27:48,500 --> 00:27:54,180
Let's say that someone does some refactoring on the right-hand side and they remove `foobar()`,

00:27:54,180 --> 00:27:59,940
or let's say they turn on optimizations on the right-hand side and `a` gets inlined. So there's no longer a definition.

00:28:00,960 --> 00:28:07,740
So at this point, there is no definition of `a` on the right-hand side because we didn't need it. So, you know, we got rid of it at compile time.

00:28:07,740 --> 00:28:11,300
And we go to link, and suddenly there is no more `a`. And now we have an error.

00:28:11,300 --> 00:28:15,740
So it's always good to make sure when you use an inline function make sure that you also provide the definition of it.

00:28:15,740 --> 00:28:25,200
Because, I mean, that's the whole point of `inline`, right? We want to inline the definition into the call site, so... it'd be nice to tell it what the definition is.

00:28:25,200 --> 00:28:33,460
So templates work under very very similar rules. Here I'm using a particular specialization of `a`,

00:28:33,460 --> 00:28:36,660
and let's see —

00:28:36,660 --> 00:28:44,820
By the way, I've been color-coding these in a little way. I've been underlining where the the thing is needed and "bluing" where the thing is actually defined.

00:28:44,840 --> 00:28:51,960
So here it's needed and defined in the same place. And over in `foobar` it's needed and defined in the same place. And it all works great.

00:28:51,960 --> 00:28:59,040
Again, we have two definitions; and again, the linker does its magic thing that it does for `inline`, which is to throw away all but one of them.

00:28:59,040 --> 00:29:16,880
By the way, the buzzwords to remember there are "linkonce section", if you're on GCC or Clang or a Unixy-type operating system; or for Windows, "COMDAT sections" is how it's actually implemented. "Throw away all but one of them."

00:29:16,880 --> 00:29:19,120
Or we could do something like this.

00:29:19,120 --> 00:29:30,380
On the left-hand side I'm trying to use `a<int>`, but I haven't told you how to define it. So it's not going to get defined over there.

00:29:30,380 --> 00:29:35,620
But it will get defined on the right-hand side, because I have explicitly instantiated it.

00:29:35,620 --> 00:29:41,280
And so I'm using the explicit instantiation [on the left]... I'm defining the explicit instantiation [on the right]... This should work.

00:29:44,100 --> 00:29:47,340
In this case...

00:29:47,340 --> 00:29:58,080
I am using an implicit instantiation `a<int>` on the right-hand side, so it will get defined over there. It's needed on the left-hand side. The linker will probably link them together, and it will just work.

00:29:58,080 --> 00:30:05,700
However, we have the same issues here as we had with the `inline` case. What if someone refactors away `foobar`? Then my code breaks.

00:30:05,700 --> 00:30:13,440
What if `a<int>` actually got inlined, and then the compiler decided that it didn't need to generate an out-of-line definition of it? Then my code breaks.

00:30:13,440 --> 00:30:25,580
So while this will work at `-O0`, if you start turning up the optimization level and suddenly it breaks, it may be because you were using a template instantiation in a place where you have a declaration for it but you haven't defined it.

00:30:25,580 --> 00:30:29,880
And so the compiler just generates the call, and then eventually it breaks in the linker.

00:30:30,640 --> 00:30:36,180
Here's the example here; `a<int>` is unused, and then of course we have a linker error.

00:30:37,360 --> 00:30:42,220
There are at least four ways template stuff can go wrong. We're going to talk about some of them now.

00:30:42,220 --> 00:30:45,480
When is instantiation needed?

00:30:45,480 --> 00:30:49,020
So a decent rule of thumb is, "Never instantiate anything you don't 100% have to."

00:30:49,020 --> 00:30:53,260
This is a decent rule of thumb for understanding the compiler's point of view.

00:30:53,260 --> 00:31:01,780
When the compiler sees something like this — I have a template here and it has a `static_assert` inside it that says `sizeof(T)==2`.

00:31:01,780 --> 00:31:05,580
And I'm trying to instantiate this class with `int`.

00:31:05,580 --> 00:31:12,460
Now, `sizeof(int)` is not 2. `sizeof(int)` is 4 for most people. I'm going to assume that it is, for these slides.

00:31:12,460 --> 00:31:22,180
So I try to instantiate it — and it works! I can actually create a pointer to a `C<int>` just fine. The static assert does not fire.

00:31:22,180 --> 00:31:27,140
And the reason the static assert doesn't fire is that it doesn't need to be instantiated.

00:31:27,140 --> 00:31:35,200
That's in the body of the class – that's in the definition of the class — and in order to get a pointer to it, I don't need to have a definition of the class.

00:31:35,220 --> 00:31:38,280
I don't need to know its members. I don't need to know how big it is.

00:31:38,280 --> 00:31:43,420
All I need to know is, how big is a pointer to it. And the answer is "how big is a pointer on your system."

00:31:43,420 --> 00:31:47,240
And I just need to know that it is a class; which it is. So this is totally fine.

00:31:47,240 --> 00:31:57,340
Now if I actually were to create something without the `*` there, now suddenly I need to know "how big is the class," and that means I need to know what are its members.

00:31:57,340 --> 00:32:00,480
Well, first, a quick sidebar on `static_assert`...

00:32:00,480 --> 00:32:03,260
`static_assert(false)`.

00:32:03,260 --> 00:32:07,720
How many people know `static_assert`, like, pretty well — inside and out? Cool. All right.

00:32:07,720 --> 00:32:12,740
`static_assert` is a compile-time way of making your program ill-formed and requiring a diagnostic.

00:32:13,440 --> 00:32:27,440
This is nice if you are a library writer, and your user is doing something stupid that you want to stop them from doing, you can just stick a `static_assert` in there to say "Hey, you're probably doing it wrong."

00:32:29,300 --> 00:32:33,020
Or, it's a sort of unit-test at compile time.

00:32:33,020 --> 00:32:38,380
So if you are particularly relying on some invariant, and you really want to check it — like, `sizeof(int)==4` —

00:32:38,380 --> 00:32:43,280
Like, "I know my code's going to break if we go to a platform with two-byte ints. I'm just going to `static_assert` it right here..."

00:32:43,280 --> 00:32:52,480
"...and that way my code will fail to compile because the program will be ill-formed, if that ever breaks."

00:32:52,480 --> 00:33:02,680
`static_assert(false)` always makes the program ill-formed. If it's some constant expression evaluating to `false`, and it doesn't depend on any template parameter,

00:33:02,680 --> 00:33:08,880
you'll have a real hard time getting that past the compiler because the compiler will just be going along — even parsing through a template, even if you don't instantiate it —

00:33:08,880 --> 00:33:18,180
and it'll say, "You know what?—" uh, you know, in this example, `f` won't even compile. Doesn't matter if I instantiate it or not.

00:33:18,180 --> 00:33:24,980
I'm static_asserting inside it that `sizeof(int)` is zero. Well, that can't possibly be true.

00:33:24,980 --> 00:33:35,400
And so the compiler will actually reject that out of hand, and just say, "No. `f` will never compile. This is dumb. You should just delete all of this code."

00:33:35,400 --> 00:33:38,720
And that may sometimes not be what you want.

00:33:38,720 --> 00:33:46,080
If you run into this situation where you're trying to `static_assert(false)` somewhere and it's not letting you, because it knows that `false` is always false,

00:33:46,080 --> 00:33:50,040
the protip there is, make it depend on a template parameter.

00:33:50,040 --> 00:33:55,060
Something like this, where I say `static_assert(sizeof(T)` for this template parameter `==0)` —

00:33:55,060 --> 00:34:01,740
well, that's still never really true (barring compiler extensions) because no type has size zero;

00:34:01,740 --> 00:34:10,140
but, because it's dependent on `T`, the compiler will actually wait until it knows what `T` is, to substitute it in and find out.

00:34:10,140 --> 00:34:16,620
So what I have here is a function `g` that, if you use it, it will static_assert; and if you don't use it, it won't.

00:34:16,620 --> 00:34:21,880
And again by "use" I mean something that actually requires the definition to get instantiated.

00:34:21,880 --> 00:34:27,080
Does that make sense, on `static_assert`? Because this is useful.

00:34:28,700 --> 00:34:35,300
So here's an example where I'm instantiating the definition of the class,

00:34:35,320 --> 00:34:43,040
and if you look closely you'll see that each of the lines here — `sdm`, `smf`, and `f` —

00:34:43,040 --> 00:34:47,440
— has a definition that also shouldn't compile! Right?

00:34:47,440 --> 00:34:55,820
In two of the cases, I'm static_asserting that `sizeof(int)` is 2, but of course it's template-dependent, so it's okay.

00:34:55,820 --> 00:35:03,380
And in the other case, I'm trying to take `nullptr` and cast it to `T`, which is `int`, and that shouldn't compile either. You can't cast `nullptr` to `int`.

00:35:04,960 --> 00:35:14,760
But I can still create an object of type `C`. Because here, I don't need to know the definitions of `sdm`, `smf`, and `f`. All I need to know is their declarations.

00:35:14,760 --> 00:35:20,140
I need to know the definition of the class, and therefore I need to know the declarations of all its members, to find out which ones take up space and so on;

00:35:20,140 --> 00:35:23,600
but I don't need to know what they're initialized to.

00:35:23,600 --> 00:35:31,660
So again the compiler is applying its rule of thumb. Which is, "Never instantiate anything you don't absolutely 100% have to instantiate."

00:35:32,720 --> 00:35:34,660
(I'm going to skip a few of these slides.)

00:35:35,600 --> 00:35:42,680
Remember that template definitions behave basically like they have the `inline` keyword attached to them.

00:35:42,680 --> 00:35:44,280
So in this case —

00:35:44,280 --> 00:35:51,780
We covered this actually a little bit earlier? with the two sides, and which things you could get away with in practice and which things you can't?

00:35:51,780 --> 00:35:58,500
In this case you can get away with `ff1` in practice — even though you shouldn't do it —

00:35:58,500 --> 00:36:04,480
because `ff1` might be defined somewhere else. The compiler will often let you off with a warning, and as long as the linker is happy, you're happy.

00:36:04,480 --> 00:36:15,800
In case `ff2`, we will actually try to instantiate the body of `ff2` — of this inline function — and we will find out that the `static_assert` fails.

00:36:15,800 --> 00:36:17,800
In fact, we'll find that out very quickly.

00:36:17,800 --> 00:36:22,520
So, when I try to do `ff2` — when I try to even define `ff2` — it won't work.

00:36:22,520 --> 00:36:26,300
When I templatize these...

00:36:26,300 --> 00:36:30,100
With `ff1`, that's totally fine, but it better be defined elsewhere.

00:36:30,100 --> 00:36:34,860
With `ff2`, now I'm trying to call the thing so I better try to define its body...

00:36:34,860 --> 00:36:42,680
...and I find out that the definition of its body contains `static_assert` of something which is false; and therefore "static_assert failed."

00:36:42,680 --> 00:36:46,960
If I add an explicit instantiation definition... Remember explicit instantiation definitions?

00:36:46,960 --> 00:36:53,640
We have `extern template` — that says, "I promise that someone somewhere else has explicitly instantiated this, so you don't have to."

00:36:53,640 --> 00:37:00,440
The compiler will say, "Oh, I don't 100% have to instantiate this? Cool. I won't." And it will completely ignore the `static_assert` and it won't fire.

00:37:00,440 --> 00:37:05,180
It probably fires in the other translation unit, if you did it right, but it doesn't fire in yours.

00:37:06,340 --> 00:37:16,760
Or if I fully specialize `ff3` and I say, "Somewhere else — not here, but somewhere else — I have made an explicit full specialization of `ff3<int>`..."

00:37:16,760 --> 00:37:24,260
"So you don't have to instantiate the primary template. In fact PLEASE don't instantiate the primary template. I WANT the full specialization from elsewhere."

00:37:24,260 --> 00:37:32,060
And it says, "Okay, I won't. I don't care what's in the primary template anymore." So this is also fine.

00:37:32,060 --> 00:37:35,620
Variable templates work very similarly to function templates and class templates.

00:37:35,620 --> 00:37:42,860
But watch out; I have found that Clang and GCC currently disagree as to what constitutes a definition of a variable template.

00:37:42,860 --> 00:37:52,240
So in GCC and MSVC, when I say `template<typename T> int vt;`, they say, "Oh. Yeah. That's just as if I wrote `int vt;`."

00:37:52,240 --> 00:37:57,720
It's a definition; it's a global variable definition. It reserves space, and so on.

00:37:57,720 --> 00:38:04,400
For Clang, for some reason, this is just a declaration. I don't really understand it. It's as if you put the `extern` keyword in front of it.

00:38:04,400 --> 00:38:16,340
If you wanted it to be a definition, you would need to actually initialize it. You could say `=0`, or empty curly braces, or something. And then Clang would say, "Okay, this is now a definition for sure."

00:38:16,340 --> 00:38:20,820
I feel like this is a bug in Clang, but I don't really know.

00:38:20,820 --> 00:38:23,220
All right, now you know everything there is to know about implicit instantiation!

00:38:23,240 --> 00:38:31,240
I know that went, like, super fast and was probably confusing, but we're going to have less confusing stuff coming. So let's all forget that THAT section happened.

00:38:31,240 --> 00:38:35,920
So hopefully by now everyone's seen variadic templates, so I'm going to skip over the motivation...

00:38:35,920 --> 00:38:41,500
...and let's talk about variadic template parameter deduction! Yeah! All right!

00:38:41,500 --> 00:38:49,520
So template parameter deduction in a nutshell. We already covered all of it except for variadic templates, which I said we'd get to in Part 2. So here it is.

00:38:49,520 --> 00:38:57,080
What happens in this case? Here I have a template. It's called `f`, and it has a certain number of parameters.

00:38:57,080 --> 00:39:02,860
One of them is named `T`. And the others are named `Us...`.

00:39:02,860 --> 00:39:09,800
And it has some parameters, collectively named (lowercase) `us...`, which are of type (capital) `Us...`.

00:39:09,800 --> 00:39:18,340
And so they all contribute to deduction — right? The parameters `us...` contribute to the deduction of template parameters `Us...`.

00:39:18,340 --> 00:39:19,240
So what am I telling it?

00:39:19,240 --> 00:39:25,600
Well, I'm telling it explicitly, through the angle brackets, that the first template parameter — which would be `T` — is `char`.

00:39:25,600 --> 00:39:32,340
Okay, I know that `T` is fixed as `char`. Then I'm going to deduce what `Us...` are.

00:39:32,340 --> 00:39:37,040
So it looks like the first one of `Us...` is `int`, and the second one is `int`, and the third one is `int`, and then we're done.

00:39:37,040 --> 00:39:40,200
Okay. Cool. That's the simple case.

00:39:41,180 --> 00:39:47,900
Let's try this. Now I'm telling it: well, the first template parameter, `T`, that's `char`. `T` is fixed as `char`.

00:39:47,900 --> 00:39:54,220
And now the SECOND template parameter... Now this is interesting. The second template parameter is the first of the `Us...`.

00:39:54,220 --> 00:39:59,640
That's also char. But I'm not saying anything about the other `Us...`. Okay?

00:39:59,640 --> 00:40:07,500
So then we go and we look at the arguments. Well, the first argument — that's the first one of the lowercase `us...` — that doesn't contribute to deduction because we know that that the type of that is `char`.

00:40:07,500 --> 00:40:10,480
And then the next one, that's an `int`, so we deduce the second one of `Us...` is `int`.

00:40:10,480 --> 00:40:16,260
And the third one is `int`, and then we're done. Okay. And we get that result. Does that make sense?

00:40:19,180 --> 00:40:20,800
Okay, two hands. Yeah.

00:40:20,800 --> 00:40:26,600
[AUDIENCE] So, on the first line, if `0` were in single quotes... [INAUDIBLE]

00:40:26,600 --> 00:40:31,680
[ARTHUR] If the `0` was in single quotes... on which line?

00:40:31,680 --> 00:40:36,940
[INAUDIBLE]

00:40:38,140 --> 00:40:41,940
If the `0` were in single quotes, my `Us...` would be `char, int, int`.

00:40:43,160 --> 00:40:46,460
[AUDIENCE] But `T` is `char`. Yeah. `T` is `char`.

00:40:46,460 --> 00:40:53,860
But the three arguments all contribute to `Us...`. `T` is actually not deducible here. If I don't specify `T`, it won't compile at all.

00:40:53,860 --> 00:40:55,940
Also question? No? Okay.

00:40:58,920 --> 00:41:07,520
The `Us...` do not all have to be the same type. Just as when I pass multiple ints to a function as function parameters, the ints don't all have to have the same value...

00:41:07,520 --> 00:41:14,020
...Here when I have multiple types as template parameters, they don't all have to be the same type.

00:41:15,020 --> 00:41:24,620
[INAUDIBLE]

00:41:24,620 --> 00:41:32,060
Yes, you can just keep going as long as you want there, in the angle brackets. Or outside them, for that matter.

00:41:32,060 --> 00:41:35,260
So as far as explicitly specified template parameters are concerned,

00:41:35,260 --> 00:41:42,420
the first pack expansion encountered in the template parameter list basically just soaks up all of the remaining explicitly specified template parameters

00:41:42,420 --> 00:41:44,760
(which are the things in the angle brackets).

00:41:44,760 --> 00:41:51,580
The type deduction step might wind up lengthening that first pack. But it will never shorten it.

00:41:51,580 --> 00:41:59,760
Right, where the programmer said, like, "I know that the first element of `Us...` is `char`, and the second element is `int`, and the third element is `double`, but I don't care what happens after that—"

00:41:59,760 --> 00:42:05,420
Well, the compiler might go on and say, "Oh, well, I can DEDUCE that the fourth one is `int` and the fifth one is... whatever." Yeah.

00:42:06,300 --> 00:42:08,760
So let's look at some of these cases.

00:42:08,760 --> 00:42:19,180
In this case we are specifying explicitly that `T` is `int` and `Us...` begins with `char, int,` something something something. And `V` — we don't know anything about `V`.

00:42:19,180 --> 00:42:25,540
Now you might say, well, I can look at this and I can predict that `V` would be `int`, and then `Us` must just be the single element `char`.

00:42:25,540 --> 00:42:30,740
But that's working right to left, and that's not what the compiler does, and that's not what the standard says the compiler should do.

00:42:30,740 --> 00:42:33,420
The compiler is doing its job in this case.

00:42:33,420 --> 00:42:38,400
It's saying, okay, `T` is `int`, `Us...` is `char`, `int`, maybe-some-other-stuff, and `V` can't be deduced at all.

00:42:38,400 --> 00:42:44,180
And because `V` can't be deduced at all, this will refuse to compile. Because it doesn't know what `V` is.

00:42:44,180 --> 00:42:50,620
In the second case, `Ts...` starts out with `int` and `char`,

00:42:50,620 --> 00:42:56,760
and then, well, that's all we know about that from the template parameter list in the angle brackets.

00:42:56,760 --> 00:43:04,320
So then we go and we look, and we say, "Ah, we have one function parameter, and it's a `double` — so `U` must be `double`."

00:43:04,320 --> 00:43:09,960
And then we're done. We have completely deduced everything there is to say about this function, and so it works.

00:43:12,220 --> 00:43:18,680
In this case, let's see, we start off with `int, char`... so `Ts...` starts off as `int, char`...

00:43:18,680 --> 00:43:21,620
so the first two parameters don't contribute to type deduction at all.

00:43:21,620 --> 00:43:29,560
So it's okay that the second one isn't a `char`. It's an `int`, but it will get converted. And then there's a `double`, so we add that onto the pack.

00:43:29,560 --> 00:43:33,020
So `Ts...` is just `int, char, double`; and that also works.

00:43:33,020 --> 00:43:41,460
This is actually a little bit interesting, right? because you might say, well, I said `h<int, char>`, but I'm giving it three arguments. Why doesn't it tell me I just have too many arguments?

00:43:41,460 --> 00:43:46,060
The answer is: well, that's just not how variadic type deduction works.

00:43:46,060 --> 00:43:50,200
Questions about this slide?

00:43:50,200 --> 00:43:56,220
[INAUDIBLE]

00:43:56,220 --> 00:43:59,760
Yeah, you would think so, but no.

00:43:59,760 --> 00:44:07,040
"Why can't `V` be deduced?" Well, because the `Us...` is the first pack expansion that we encountered, and it soaks up all the rest.

00:44:07,040 --> 00:44:16,060
So `Us...` is `char` and `int` and maybe some other stuff; and then there's nothing left for `V`, and it can't be deduced from the parameter list.

00:44:16,060 --> 00:44:19,180
"Why does the second one work, given that the first one failed?"

00:44:19,180 --> 00:44:29,260
Because in that case we CAN deduce `U` from the parameter list. The parameter list tells us that `U` must be `double`.

00:44:29,260 --> 00:44:42,640
[INAUDIBLE]

00:44:44,440 --> 00:44:47,180
I'm not sure what you mean by "expanded out the types."

00:44:47,180 --> 00:44:51,120
[INAUDIBLE]

00:44:51,120 --> 00:44:56,040
Then `Ts...` would be `<int, char, double>`, and `U` would be derived.

00:44:56,040 --> 00:45:01,680
And it would probably complain about the number of parameters that you passed — well, in that case it'd be fine.

00:45:01,680 --> 00:45:08,840
But yeah, there's no way to specify— In the second case, in `g`, there's no way to tell it explicitly what `U` is.

00:45:08,840 --> 00:45:17,120
`U` can only EVER be deduced from the parameter list. Because anything I throw inside those angle brackets is just going to keep getting added to `Ts`.

00:45:17,120 --> 00:45:23,240
There's no way to specify `U` in the angle brackets. Anything I throw in there is going to get soaked up.

00:45:23,240 --> 00:45:26,120
Does that answer the question?

00:45:26,120 --> 00:45:38,300
[INAUDIBLE]

00:45:38,300 --> 00:45:40,940
I believe yes, but I'm going to move on to the next bit.

00:45:42,260 --> 00:45:49,620
So as far as deduction is concerned... So we talked about explicitly specified template parameters. Now let's talk about the parameter deduction.

00:45:50,180 --> 00:45:55,320
A parameter pack contributes to deduction only if it comes at the very end of the parameter list.

00:45:55,320 --> 00:45:58,480
Otherwise, it does not contribute to deduction.

00:45:58,480 --> 00:46:11,660
So in this case I have an `f`, and I'm not going to specify anything about the angle brackets. I'm just going to rely on deduction.

00:46:11,660 --> 00:46:17,500
I'm going to deduce that the first parameter is `U`, so that's a `char`? `U` is a `char`.

00:46:17,500 --> 00:46:22,620
And then the rest of the parameters — `int`, `int` — those must be the `Ts...`. So it deduces just fine.

00:46:22,620 --> 00:46:30,700
In the second case, the `us...` — all of these parameters — don't contribute to deduction.

00:46:32,080 --> 00:46:40,040
So... I have a `T` at the end, but that doesn't work either. Like, there's just nothing I can say at this point.

00:46:40,060 --> 00:46:53,060
I'm like, well, some of these `('x', 1, 2)` things are probably some of the `us...`, but the `us...` aren't contributing to deduction. So I can't say anything about capital `Us` from this.

00:46:53,060 --> 00:46:57,100
And so, yeah, I just don't know where to start with this one.

00:46:57,100 --> 00:46:59,040
And with case `h`...

00:46:59,040 --> 00:47:05,140
Here I am explicitly stating that `T` is `int` and that `Us...` starts with `int, int`.

00:47:05,140 --> 00:47:10,700
Now here the `us...` don't contribute to deduction, but we know they start with `int, int`, so let's see, okay...

00:47:10,700 --> 00:47:15,200
This one — well, it's a `char`, but we said it was `int`, so, it's `int`. And this one is `int`.

00:47:15,200 --> 00:47:23,720
And then we've run out of the `Us...` that were explicitly specified. So this next thing must be a `T`.

00:47:23,720 --> 00:47:27,060
So `T` must be `int`.

00:47:27,060 --> 00:47:35,900
We have in fact explicitly... Oops, sorry, actually the `T` doesn't contribute to deduction either. We already explicitly specified that one too. So this just happens to work.

00:47:35,900 --> 00:47:40,040
It's not a very satisfying answer when I say it like that.

00:47:41,280 --> 00:47:45,920
So the trick here is that the parameter pack contributes to deduction only if it comes at the very end of the parameter list.

00:47:45,940 --> 00:47:51,700
So only in `f` do we deduce anything about `Ts...`. In the other cases, we're not deducing anything about `Us...`.

00:47:51,700 --> 00:47:55,220
Yeah.

00:47:56,180 --> 00:47:59,960
"Can I have two parameter packs as template arguments?"... like this?

00:47:59,960 --> 00:48:02,820
[LAUGHTER]

00:48:02,820 --> 00:48:10,920
So the trick is, what does it mean to contribute to deduction? Again, GCC and Clang differ on this, and MSVC tends to agree with GCC.

00:48:10,920 --> 00:48:20,320
In this case I'm saying explicitly that the first one of `Ts...` must be `int`, the second one must be `int`, and I'm not saying anything about the others.

00:48:20,320 --> 00:48:24,300
However, `Ts...` do not contribute to deduction.

00:48:24,300 --> 00:48:33,320
So Clang says, well, you said `Ts...` couldn't contribute to deduction. That's the very first thing in here. I don't know where to start." You get a compiler error. Hard error.

00:48:33,320 --> 00:48:39,640
MSVC and GCC both say, "Oh, well, you TOLD me it was `<int, int>`; and I'm not sure what comes later, but okay."

00:48:39,640 --> 00:48:43,160
So this is an `int`, that's an `int`, and then this next thing must be `Us...`.

00:48:43,160 --> 00:48:46,660
And so the first of `Us...` must be an `int`. And then I run out of parameters.

00:48:46,660 --> 00:48:51,640
so okay, so `Us...` is `<int>` — oops, that's a typo there for `<int>`.

00:48:51,640 --> 00:48:55,280
I think these were originally— that was a `3.0`. If that was a `3.0`, this would be `<double>`.

00:48:57,380 --> 00:49:04,280
So yeah. So, again, there's some confusion in the compiler world about what "contribute to deduction" really means.

00:49:04,280 --> 00:49:09,720
Now you know everything there is to know about template type deduction — even for variadics! And I think that's the LAST "everything" you need to know about template type deduction.

00:49:09,720 --> 00:49:11,080
Yeah.

00:49:11,080 --> 00:49:18,580
[INAUDIBLE]

00:49:19,700 --> 00:49:23,260
"What would happen if we just said `f(1,2,3)`?"

00:49:23,260 --> 00:49:37,980
In that case I believe that Clang gives you a compiler error, and MSVC and GCC say, "Well, you didn't tell me anything about `Ts...`. So I'm going to assume it's empty, and `Us...` is `int, int, int`."

00:49:37,980 --> 00:49:42,600
And that doesn't make a whole lot of sense; but this code doesn't make a whole lot of sense. Don't do this.

00:49:42,600 --> 00:49:44,760
[LAUGHTER]

00:49:46,660 --> 00:49:52,260
All right, let's take a quick break with some patterns. How many minutes do I have left, by the way?

00:49:52,260 --> 00:49:54,780
All right. Well, let's try to real quick do this.

00:49:54,780 --> 00:49:58,300
So the CRTP is a useful pattern to know.

00:49:58,300 --> 00:50:05,560
And in fact it's so useful that you can come to see me afterward because I want to talk more about C++17 than I want to talk about these things.

00:50:05,560 --> 00:50:10,060
So I hope you all do too. I hope you're all excited for C++17.

00:50:10,060 --> 00:50:13,640
Because here's some things that are going to be new in it.

00:50:13,640 --> 00:50:16,780
One of them I already mentioned — inline variables.

00:50:16,780 --> 00:50:21,960
In fact, Bjarne mentioned it. He said don't use them because they're global variables and they're terrible.

00:50:21,960 --> 00:50:26,340
I think, if you're GOING to use global variables, make sure they're `inline`.

00:50:26,340 --> 00:50:29,040
Yeah.

00:50:29,040 --> 00:50:34,720
"Can you make `static inline` variables?" I believe that you can.

00:50:36,460 --> 00:50:44,080
Static data members that are `inline`. Yes, definitely yes to that one.

00:50:44,080 --> 00:50:50,060
And that's pretty much all I have to say about inline variables. Let's talk about `template<auto>`. This is a neat thing.

00:50:50,060 --> 00:50:51,640
But it's not really that neat.

00:50:51,640 --> 00:50:54,120
I haven't talked much about template non-type parameters.

00:50:54,120 --> 00:50:59,860
But by now when you see in all of the ways that you can kind of match up and deduce things...

00:50:59,860 --> 00:51:05,660
You can figure out how a non-type parameter would work, if such a thing existed. Which it does.

00:51:05,660 --> 00:51:09,000
For example, here there's a very common one...

00:51:09,000 --> 00:51:20,600
Whenever you use a `std::array`, right, you say `std::array<int, 10>`. That `10` — still in the angle brackets — is a non-type parameter.

00:51:20,600 --> 00:51:29,220
So in that case `T` is explicitly specified as `int` and the `N` parameter is explicitly specified as 10.

00:51:29,220 --> 00:51:33,100
You can also deduce template non-type parameters.

00:51:33,100 --> 00:51:40,120
And you can see deduction when you take— there's a function called `template<class T, size_t N> size(T (&arr)[N])` that takes a reference to an array of `N` elements,

00:51:40,120 --> 00:51:43,360
and then you can actually deduce what the `N` is in those cases.

00:51:44,360 --> 00:51:50,320
However, mostly when you have these template non-type parameters, you will see them mostly in metaprogramming contexts.

00:51:50,320 --> 00:51:55,780
Like, you can create these index-sequences of integers, like that.

00:51:58,420 --> 00:52:02,360
And you also very frequently end up with things like `integral_constant`.

00:52:02,360 --> 00:52:07,760
Actually, `true_type` and `false_type` are special cases of `integral_constant` that happen to be associated with `true` and `false`.

00:52:07,760 --> 00:52:09,300
So I can do things like this.

00:52:09,340 --> 00:52:20,180
And `template<auto>` — when that starts coming and you start getting scared by that — know that that is basically just collapsing something like the above...

00:52:20,820 --> 00:52:22,760
...into that.

00:52:22,760 --> 00:52:24,540
So instead of now having two parameters,

00:52:24,540 --> 00:52:29,820
one to say "what is the type of the thing that's coming next" and the other one to say "what is the thing",

00:52:29,820 --> 00:52:33,200
we can now just have one parameter.

00:52:33,200 --> 00:52:37,860
And we no longer really care about what its type is. We can get it with `decltype` if we want it.

00:52:39,160 --> 00:52:48,220
But, as with generic lambdas, we just say `auto` and we just get the thing.

00:52:50,680 --> 00:52:53,780
Also, remember when I said in Part 1 that class templates can't do deduction?

00:52:53,780 --> 00:52:59,660
There's a thing coming in C++17 that Bjarne alluded to.

00:52:59,660 --> 00:53:03,820
This is the slide from before. Remember, I said that we can't do deduction on class templates?

00:53:03,820 --> 00:53:09,860
Coming in C++17: a way to do deduction on class templates!

00:53:09,860 --> 00:53:12,620
At least for the constructors thereof.

00:53:12,620 --> 00:53:24,220
And the way this is going to work is, basically, whenever we see something like this, where there's a bare template-name for a class template, and it's not followed by any angle brackets,

00:53:24,940 --> 00:53:34,860
when we're constructing an object of this type, we're going to pretend that we have a "make" helper function. Like `make_pair` or `make_tuple`.

00:53:34,860 --> 00:53:41,760
We're going to pretend that that exists, and that it has the exact same signature as the constructor of the primary template.

00:53:41,760 --> 00:53:45,120
So in this case we have a `make_myvec` that takes a `T`.

00:53:45,120 --> 00:53:51,440
And we're going to pretend that instead of calling the constructor of `myvec<something>` (which we don't know yet, which we're trying to deduce),

00:53:51,440 --> 00:53:56,560
we're going to pretend that we called `make_myvec` of those exact same arguments.

00:53:57,200 --> 00:54:02,280
And then we're going to do overload resolution on that, and we're going to do template type deduction, and so on.

00:54:02,280 --> 00:54:12,940
And we're going to deduce that — aha, if I called `make_myvec(1)`, then `T` there would be `int`. So I'm going to say `T` here is `int`.

00:54:12,940 --> 00:54:15,280
And I'm just going to assume that you want a `myvec<int>`.

00:54:15,280 --> 00:54:19,860
And this happens to work really great for `pair` and `tuple`.

00:54:21,360 --> 00:54:29,440
Or here's a more complicated example. If I have two different constructors for `myvec`, it still works!

00:54:29,440 --> 00:54:36,680
I'm making a `myvec`. I resolve `make_myvec(1)`. In this case, overload resolution looks at these —

00:54:36,680 --> 00:54:42,840
Now these are not partial. This is not a partial specialization. Functions can't be partially specialized.

00:54:42,840 --> 00:54:47,860
We have two different functions in the overload set, but this one is more specialized than the other.

00:54:47,860 --> 00:54:57,660
So this is a better match... Oops, sorry, nope, in this case `1` is not a pointer. So we do this one.

00:54:57,660 --> 00:55:02,080
`make_myvec` with `T=int`. And we get a `myvec<int>`. So it does work right.

00:55:03,520 --> 00:55:07,140
Now, in this case, we have an address of an `int`.

00:55:07,140 --> 00:55:11,140
So in this case, this one is more specialized, so we take this one with `T=int`

00:55:11,140 --> 00:55:17,400
and we get `myvec<int>`, using the pointer parameter.

00:55:17,400 --> 00:55:23,220
So this is a case where we have deduced something for `T` that is not the type of the thing we passed to it.

00:55:23,220 --> 00:55:30,520
We passed it `int*`. But because there's this extra constructor that takes a `T*`, we can deduce `T=int`.

00:55:31,360 --> 00:55:37,740
Does this make sense? This is the first non-totally-obvious example of how this might work.

00:55:37,740 --> 00:55:44,540
[INAUDIBLE]

00:55:44,540 --> 00:55:51,320
Um, the naming of this `make_myvec`? This is a completely fictitious function. It does not exist in your code.

00:55:51,320 --> 00:55:58,540
The compiler is kind of pretending that this "make" function exists based on the fact these constructors exist,

00:55:58,540 --> 00:56:01,660
and then it's also pretending that you called it. You don't actually call it.

00:56:01,660 --> 00:56:10,920
`make_pair` and `make_tuple` — well, they will still exist, for backward compatibility, but you will not continue to make "make" helpers.

00:56:10,920 --> 00:56:16,580
[INAUDIBLE]

00:56:16,580 --> 00:56:22,460
Yes, it does. It does interact with with "Almost Always `auto`" syntax, as well.

00:56:22,460 --> 00:56:26,900
`auto x = myvec(1)` or `auto x = myvec(&i)` will also work.

00:56:28,020 --> 00:56:29,450
Here's another example.

00:56:29,450 --> 00:56:37,020
We now have a class template `myvec` where it has one overload that takes a `T` and one overload that takes a `double`.

00:56:37,020 --> 00:56:45,040
So let's pretend that we had these two function templates, and we're calling it with a `double`.

00:56:45,040 --> 00:56:49,880
Well, it turns out that we're trying to call `make_myvec(1.0)`.

00:56:49,880 --> 00:57:00,700
But the second overload — this one, which takes a `double` — we'd love to call this, but we don't know what `T` is. `T` can't be deduced. So it doesn't participate.

00:57:00,700 --> 00:57:08,380
So we go to this one, and we say, "Ah, now `T` is `double`. Okay, I know about that." And we make a `myvec<double>`.

00:57:10,920 --> 00:57:19,040
Or in this case where I have a partial specialization of a class template — in this case it's super unclear.

00:57:19,040 --> 00:57:27,480
I think not only will compilers disagree once this is implemented, but I think the standard needs a little bit of love in this instance.

00:57:27,480 --> 00:57:33,860
But in this case it sure looks like we would get a compiler error, because we're going to deduce that `T` is `int*`.

00:57:33,860 --> 00:57:40,460
And we're going to see that there's a partial specialization for `int*`; and we're going to try to call that constructor; and it doesn't exist. And we're going to have issues.

00:57:42,060 --> 00:57:45,620
So there's a little bit of work to be done on the specification yet.

00:57:46,960 --> 00:57:53,120
This will also mean that there will be a difference between these two classes, where right now there is not.

00:57:53,120 --> 00:57:58,320
The difference here is that in the first case I have a `myvec` that takes a `T`;

00:57:58,320 --> 00:58:06,140
and in the second case I have a `myvec` that takes some typedef for `T` — some member typedef for `T`.

00:58:08,160 --> 00:58:18,040
And if I were to actually construct the overload resolution here, and I would try to call the red one, it would work great: `T` would be `int`.

00:58:18,040 --> 00:58:28,340
In this [second] case, I know that `myvec<T>::iter::type` is `int`. What does that say about `T`? Well, I don't know!

00:58:28,340 --> 00:58:39,620
Because I'm back in the same problem I had in C++14. Of, "Well, I know that some crazy member—" I know SOMETHING about `T`. I know maybe its size,

00:58:39,620 --> 00:58:45,540
or I know that some member of this particular template is `int`... That doesn't tell me what `T` is specifically.

00:58:45,540 --> 00:58:52,520
So in the blue case I wouldn't be able to use the new feature. In the red case I am able to use the new feature.

00:58:53,960 --> 00:59:00,760
And if you want to guide deduction, to get it to do the right thing, there's a syntax for that.

00:59:00,760 --> 00:59:08,180
It looks a little odd. It doesn't really look like a declaration, but that's also because it's NOT really a declaration.

00:59:08,180 --> 00:59:12,400
Because these constructors exist already. You don't need to re-declare them.

00:59:12,400 --> 00:59:21,280
But you need to, in some way, guide; to say, "when someone does something that looks like a `myvec(double)`, and they don't say anything about which `myvec` they want, they probably want `myvec<int>`."

00:59:21,280 --> 00:59:24,880
And you do that with this exact syntax — with the little arrow.

00:59:24,880 --> 00:59:27,040
That's a "deduction guide."

00:59:27,040 --> 00:59:31,840
And they participate, and the third one is clearly the best one, and so on, and so on.

00:59:32,880 --> 00:59:36,100
You know all the crazy stuff coming in C++17.

00:59:36,100 --> 00:59:40,520
And now we're actually done ahead of time with two minutes remaining or something.

00:59:40,520 --> 00:59:45,080
If anyone has any questions...? I can also go back and talk about mixins.

00:59:45,080 --> 00:59:46,880
Question.

00:59:46,880 --> 01:00:08,040
[INAUDIBLE]

01:00:08,040 --> 01:00:16,360
"Why, when I have `foo(1,2,3)`, does it deduce `<int, int, int>` rather than `<int&&, int&&, int&&>`?

01:00:16,360 --> 01:00:22,860
Because `<int, int, int>` works, and we don't like adding multiple ampersands unless we need to.

01:00:22,860 --> 01:00:29,400
In fact, we never like adding MULTIPLE ampersands. And we only add ONE if we really, really need to.

01:00:30,500 --> 01:00:42,300
That was from Part 1. I don't know, were you here for the first part? Okay. Well, the same rule applies as in Part 1.

01:00:42,860 --> 01:00:46,720
All right, well, that's it. Thank you all for coming!

01:00:46,720 --> 01:00:49,300

YouTube URL: https://www.youtube.com/watch?v=VIz6xBvwYd8


