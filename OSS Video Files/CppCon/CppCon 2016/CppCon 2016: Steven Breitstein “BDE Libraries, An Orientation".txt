Title: CppCon 2016: Steven Breitstein “BDE Libraries, An Orientation"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
The BDE libraries, https://github.com/bloomberg/bde, provide a wide range of 
useful functionality and also showcase the design and testing principles long 
advocated by John Lakos (see Lakos '96, CppCpon 201[456]): 
Fine-grained, hierarchical reusable (physical) components 
Focused component purposes based on well-defined class categories. 
Use of library facilities to implement effective Defensive Programming. 
Ubiquitous support for a user-supplied memory--allocation mechanisms. 
Design by (appropriately narrow) contracts. 
After an outline of the functionality provided (e.g., date/time classes, 
logging), this talk recaps the above Lakosian ideas, and shows, through BDE 
documentation and code examples, how the ideas above influence the use of BDE libraries in applications.
— 
Steven Breitstein
Engineer, Bloomberg LP
Professional Experience | Bloomberg, 10 years | Bell Labs, 20 years | Education | Graduate: M.I.T. | Undergraduate: City College of New York
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,620
well welcome and thank you for

00:00:01,860 --> 00:00:07,980
interested in the BD libraries who here

00:00:04,620 --> 00:00:11,910
has already seen them at all maybe on

00:00:07,980 --> 00:00:15,350
github a little bit some who is familiar

00:00:11,910 --> 00:00:21,869
with the works of John Lykos

00:00:15,350 --> 00:00:23,220
very good so just get started in case

00:00:21,869 --> 00:00:23,670
you haven't heard of Chris well what is

00:00:23,220 --> 00:00:26,640
BT

00:00:23,670 --> 00:00:29,789
my name is Steve Steve bright Stein I've

00:00:26,640 --> 00:00:32,070
been working for John for ten years now

00:00:29,789 --> 00:00:37,290
and before that I did other stuff that I

00:00:32,070 --> 00:00:46,230
can't remember anymore going on 12

00:00:37,290 --> 00:00:49,710
actually so drawing the bde team eleven

00:00:46,230 --> 00:00:52,980
and a half years ago this first matter

00:00:49,710 --> 00:00:57,239
what is bde or does it stand for and the

00:00:52,980 --> 00:00:59,129
answer is we don't really know you will

00:00:57,239 --> 00:01:01,050
see written some places Bloomberg

00:00:59,129 --> 00:01:03,270
development environments sometimes

00:01:01,050 --> 00:01:07,530
you'll see the basic development

00:01:03,270 --> 00:01:09,360
environment and some wise guys suggested

00:01:07,530 --> 00:01:13,710
that it is the bde development

00:01:09,360 --> 00:01:15,210
environment yes if I disregard it means

00:01:13,710 --> 00:01:19,640
what it means the term can be applied to

00:01:15,210 --> 00:01:25,110
the libraries that we're about to take

00:01:19,640 --> 00:01:28,710
examine to the team about 10 to 12

00:01:25,110 --> 00:01:30,770
people about average over the last 10

00:01:28,710 --> 00:01:37,229
years many many of whom are here today

00:01:30,770 --> 00:01:41,340
and and the methodology which was

00:01:37,229 --> 00:01:46,979
inspired by John Blake us based on his

00:01:41,340 --> 00:01:48,270
book who's read this raise your hand

00:01:46,979 --> 00:01:58,969
John

00:01:48,270 --> 00:02:01,229
I and and subsequent work talks such as

00:01:58,969 --> 00:02:04,350
one that's available through Pearson

00:02:01,229 --> 00:02:06,750
called life lessons and several talks

00:02:04,350 --> 00:02:10,549
here at CPP caught in the last three

00:02:06,750 --> 00:02:13,489
years including one yesterday okay and

00:02:10,549 --> 00:02:19,410
further work going into his new book

00:02:13,489 --> 00:02:25,940
coming out in current year plus one for

00:02:19,410 --> 00:02:25,940
many years now okay

00:02:25,970 --> 00:02:32,519
we call these the classes provided by BT

00:02:30,510 --> 00:02:35,519
or sometimes call foundation classes

00:02:32,519 --> 00:02:41,220
because they are generally not customer

00:02:35,519 --> 00:02:42,690
facing code this is code is for building

00:02:41,220 --> 00:02:44,519
infrastructure for building

00:02:42,690 --> 00:02:46,769
infrastructure several layers up you

00:02:44,519 --> 00:02:51,209
finally get to the level where uber

00:02:46,769 --> 00:02:54,920
customers are interacting with with the

00:02:51,209 --> 00:02:58,829
software you can find it at that github

00:02:54,920 --> 00:03:03,410
github link it is currently about nine

00:02:58,829 --> 00:03:06,450
hundred documented and tested components

00:03:03,410 --> 00:03:08,459
organized into forty seven packages and

00:03:06,450 --> 00:03:13,410
five package groups where a package

00:03:08,459 --> 00:03:15,989
group its released as a library that we

00:03:13,410 --> 00:03:22,049
something we call a unit of release you

00:03:15,989 --> 00:03:24,660
are the kind of problem solved by these

00:03:22,049 --> 00:03:27,450
libraries tend to be those that are dest

00:03:24,660 --> 00:03:30,090
on once for the enterprise such as the

00:03:27,450 --> 00:03:33,419
definition of date and time classes

00:03:30,090 --> 00:03:36,120
calendar types and utilities operating

00:03:33,419 --> 00:03:40,319
on those logging systems I don't know

00:03:36,120 --> 00:03:44,609
how many logging systems one typically

00:03:40,319 --> 00:03:46,169
has an an enterprise I found many over

00:03:44,609 --> 00:03:48,930
lifetimes and different projects I'll

00:03:46,169 --> 00:03:50,910
find different you know people are using

00:03:48,930 --> 00:03:53,239
three times or four types of loggers

00:03:50,910 --> 00:03:55,340
through the same code body

00:03:53,239 --> 00:03:58,760
we're trying to resolve that problem we

00:03:55,340 --> 00:04:01,159
have one very good lager subject to an

00:03:58,760 --> 00:04:03,079
hour talk at least by itself I don't

00:04:01,159 --> 00:04:07,519
think other things such as command-line

00:04:03,079 --> 00:04:12,109
parsing a great tokenizer almost called

00:04:07,519 --> 00:04:14,000
the toka nadir threaten that management

00:04:12,109 --> 00:04:16,039
data marshalling networking more things

00:04:14,000 --> 00:04:17,780
it was just the highlights that I got

00:04:16,039 --> 00:04:20,750
you know I shot it down as I was

00:04:17,780 --> 00:04:22,940
perusing the libraries so as you can see

00:04:20,750 --> 00:04:26,090
there are many areas of applications

00:04:22,940 --> 00:04:29,090
addressed by these libraries they are

00:04:26,090 --> 00:04:32,539
all component based that means they are

00:04:29,090 --> 00:04:34,310
all levelized welcome there are no

00:04:32,539 --> 00:04:36,259
cycles of dependency between these

00:04:34,310 --> 00:04:37,910
components

00:04:36,259 --> 00:04:43,099
moreover the classes that are

00:04:37,910 --> 00:04:45,680
implemented fall into a a system of

00:04:43,099 --> 00:04:48,789
classes of class taxonomy which we'll

00:04:45,680 --> 00:04:52,990
look at more in the moment they are

00:04:48,789 --> 00:04:55,990
abundantly in detailed and consistently

00:04:52,990 --> 00:04:55,990
documented

00:04:56,030 --> 00:05:00,849
they feature narrow contracts and to

00:04:59,210 --> 00:05:04,250
help with the narrow contracts we have

00:05:00,849 --> 00:05:06,949
defensive programming features all of

00:05:04,250 --> 00:05:11,419
the types that allocate memory are

00:05:06,949 --> 00:05:14,840
equipped to accept runtime polymorphic

00:05:11,419 --> 00:05:18,289
allocate memory allocators including our

00:05:14,840 --> 00:05:21,860
surgeon of the standard library so you

00:05:18,289 --> 00:05:25,479
know our vectors our classes our hash

00:05:21,860 --> 00:05:29,659
our maps and lists and Springs all our

00:05:25,479 --> 00:05:32,680
allocator enabled lastly you'll find

00:05:29,659 --> 00:05:37,430
that everything is thoroughly tested

00:05:32,680 --> 00:05:40,159
each component has a test driver that

00:05:37,430 --> 00:05:42,440
whose responsibility is to prove beyond

00:05:40,159 --> 00:05:48,050
all reasonable doubt the component meets

00:05:42,440 --> 00:05:50,479
its contracts plus more and these are

00:05:48,050 --> 00:05:52,840
published and we invite you to peruse

00:05:50,479 --> 00:05:52,840
them

00:05:53,680 --> 00:06:00,400
okay so just in case somebody hasn't

00:05:57,790 --> 00:06:04,720
been through this before what is a

00:06:00,400 --> 00:06:07,479
component it is an example would be be

00:06:04,720 --> 00:06:12,550
TLT date that is components whose major

00:06:07,479 --> 00:06:19,630
class is date that is implemented in the

00:06:12,550 --> 00:06:22,870
BB LT names space and furthermore all

00:06:19,630 --> 00:06:24,729
the classes are also uh their further

00:06:22,870 --> 00:06:27,820
rap by the bloomberg namespace so that

00:06:24,729 --> 00:06:31,990
we can mix with third party code without

00:06:27,820 --> 00:06:34,060
fear of collision okay the component

00:06:31,990 --> 00:06:38,590
consists of two files an implementation

00:06:34,060 --> 00:06:41,110
file the CPP and a header file which the

00:06:38,590 --> 00:06:43,060
interfaces and inline implementations

00:06:41,110 --> 00:06:45,370
are defined okay

00:06:43,060 --> 00:06:48,669
they're always too we have no standalone

00:06:45,370 --> 00:06:49,330
dot H files that's it's just simpler

00:06:48,669 --> 00:06:51,639
that way

00:06:49,330 --> 00:06:55,259
as I said earlier there is a test driver

00:06:51,639 --> 00:06:55,259
for this and for every component

00:06:55,289 --> 00:07:03,580
components are more than a pair of files

00:06:59,650 --> 00:07:08,410
a HC PP there are rules for writing

00:07:03,580 --> 00:07:13,080
components specifically one the CPP has

00:07:08,410 --> 00:07:19,360
to include the dot H first why is that

00:07:13,080 --> 00:07:22,720
anybody yes sure that there are no there

00:07:19,360 --> 00:07:26,080
away we do that the H file is

00:07:22,720 --> 00:07:30,849
self-sufficient you know that you don't

00:07:26,080 --> 00:07:34,120
have any you need no other includes and

00:07:30,849 --> 00:07:35,889
basically two and three are saying that

00:07:34,120 --> 00:07:38,919
everything related to this class can be

00:07:35,889 --> 00:07:41,650
found in the component okay if it's

00:07:38,919 --> 00:07:43,780
implemented you'll find it you'll find

00:07:41,650 --> 00:07:45,760
the interface for it in the header file

00:07:43,780 --> 00:07:47,050
if it's in the header file if it's

00:07:45,760 --> 00:07:49,060
defined in the header file it's

00:07:47,050 --> 00:07:52,300
implemented here that's not you don't

00:07:49,060 --> 00:07:54,310
have to go look anyplace else this this

00:07:52,300 --> 00:07:57,490
component handles everything having to

00:07:54,310 --> 00:08:03,070
do with the classes furthermore that's

00:07:57,490 --> 00:08:05,409
any components it uses are are access

00:08:03,070 --> 00:08:07,210
through their header files and

00:08:05,409 --> 00:08:09,310
everything

00:08:07,210 --> 00:08:11,080
and our clients so this will include

00:08:09,310 --> 00:08:15,460
header file so we can examine the header

00:08:11,080 --> 00:08:19,800
files and exam adventure manely physical

00:08:15,460 --> 00:08:25,860
you know the the physical dependencies

00:08:19,800 --> 00:08:28,690
there are no and externus disallowed

00:08:25,860 --> 00:08:31,060
yeah because that would be it that would

00:08:28,690 --> 00:08:33,909
be a way of accessing accessing

00:08:31,060 --> 00:08:35,919
something without having specified a dot

00:08:33,909 --> 00:08:37,690
you know said it loudly without it

00:08:35,919 --> 00:08:41,500
saying it very loudly and explicitly

00:08:37,690 --> 00:08:43,300
through a dot h include there are two

00:08:41,500 --> 00:08:45,940
major design roles that there should be

00:08:43,300 --> 00:08:49,959
no cyclic dependencies between

00:08:45,940 --> 00:08:54,600
components any logical dependencies

00:08:49,959 --> 00:08:56,740
between classes have to be within the

00:08:54,600 --> 00:09:01,149
component and even then those are

00:08:56,740 --> 00:09:03,970
frowned upon having cyclic dependencies

00:09:01,149 --> 00:09:06,730
complicates testing and any friendship

00:09:03,970 --> 00:09:15,339
between classes has to be contained

00:09:06,730 --> 00:09:18,730
within the component questions yes by

00:09:15,339 --> 00:09:21,100
review by some tools the physical the

00:09:18,730 --> 00:09:25,050
cyclic dependencies are enforced by

00:09:21,100 --> 00:09:28,810
tools according to that every you know I

00:09:25,050 --> 00:09:32,250
mean every once in a while will find a

00:09:28,810 --> 00:09:34,480
problem you know but it's a very rare

00:09:32,250 --> 00:09:37,060
it's like you see one of those for a

00:09:34,480 --> 00:09:41,500
while so we're usually pretty good about

00:09:37,060 --> 00:09:50,040
avoiding them but yes BD verified does

00:09:41,500 --> 00:09:53,320
that hmm I encountered otherwise oh and

00:09:50,040 --> 00:09:57,750
the question was are there tools to

00:09:53,320 --> 00:09:57,750
enforce that thank you for that reminder

00:09:58,130 --> 00:10:08,580
yes so now we know what component

00:10:06,360 --> 00:10:12,660
components are organized into packages

00:10:08,580 --> 00:10:16,140
packages are related components they

00:10:12,660 --> 00:10:20,130
have the same of physical they have the

00:10:16,140 --> 00:10:24,660
same envelope of dependencies they have

00:10:20,130 --> 00:10:26,670
related functionality so that in

00:10:24,660 --> 00:10:29,880
addition to dates we will also have a

00:10:26,670 --> 00:10:34,410
date/time a date/time date you tell

00:10:29,880 --> 00:10:36,630
utilities being operations on dates that

00:10:34,410 --> 00:10:39,750
don't really require access to the

00:10:36,630 --> 00:10:42,390
innards of dates so if in order to do

00:10:39,750 --> 00:10:44,970
something the date if you have if you

00:10:42,390 --> 00:10:50,600
can do through the public interface put

00:10:44,970 --> 00:10:54,600
in the utility keep dates somewhere and

00:10:50,600 --> 00:10:56,820
time and others and as you can see that

00:10:54,600 --> 00:10:58,740
they all have a common prefix they all

00:10:56,820 --> 00:11:03,060
clear the symbols in the same namespace

00:10:58,740 --> 00:11:08,310
and surprise you'll find them all in a

00:11:03,060 --> 00:11:11,870
sunder a directory called VD LT and that

00:11:08,310 --> 00:11:11,870
says pretty much what I just said

00:11:14,180 --> 00:11:22,920
packages are further organized into

00:11:17,970 --> 00:11:27,330
package groups so the BDL package group

00:11:22,920 --> 00:11:29,580
contains VD LT and others and what

00:11:27,330 --> 00:11:32,240
distinguishes a package group is the

00:11:29,580 --> 00:11:37,500
first three letters of the package name

00:11:32,240 --> 00:11:41,310
so and one consequence of that is that

00:11:37,500 --> 00:11:43,350
when you design a package you have to

00:11:41,310 --> 00:11:45,450
know where it's going you have to study

00:11:43,350 --> 00:11:46,980
you have to know what its dependencies

00:11:45,450 --> 00:11:50,089
will be you'll have to know where it's

00:11:46,980 --> 00:11:54,900
going to fit into into the overall

00:11:50,089 --> 00:11:58,589
software hierarchy so that so that you

00:11:54,900 --> 00:12:01,040
know how to name it again those cyclic

00:11:58,589 --> 00:12:04,890
dependencies among any of the packages

00:12:01,040 --> 00:12:06,120
these define a library so this is

00:12:04,890 --> 00:12:10,530
something you'll see on your on your

00:12:06,120 --> 00:12:11,200
link line and you have case you were

00:12:10,530 --> 00:12:16,990
wondering that's

00:12:11,200 --> 00:12:18,340
these suffixes stand for mmm thank you

00:12:16,990 --> 00:12:23,530
sir

00:12:18,340 --> 00:12:25,510
and this is all that said and lastly now

00:12:23,530 --> 00:12:28,110
that we have our libraries what are the

00:12:25,510 --> 00:12:35,530
libraries available to you there are

00:12:28,110 --> 00:12:37,780
there are these six five rather bowel

00:12:35,530 --> 00:12:40,120
which has fairly high level libraries

00:12:37,780 --> 00:12:42,310
this is where our we have our logging

00:12:40,120 --> 00:12:54,340
system our metric system stack utilities

00:12:42,310 --> 00:12:57,070
our time zone systems okay yes we have a

00:12:54,340 --> 00:13:01,000
set of utilities that will analyze

00:12:57,070 --> 00:13:07,210
stacks the process stacks process facts

00:13:01,000 --> 00:13:10,660
sorry I that was a good question and it

00:13:07,210 --> 00:13:17,410
is a and it's very useful sometime we'll

00:13:10,660 --> 00:13:19,150
see later on we have this is a fairly

00:13:17,410 --> 00:13:23,950
small package group it has some business

00:13:19,150 --> 00:13:26,500
logic in it it has day counting

00:13:23,950 --> 00:13:29,560
conventions something you can imagine

00:13:26,500 --> 00:13:31,210
being useful at Bloomberg BDL is a

00:13:29,560 --> 00:13:34,360
fairly large package it includes

00:13:31,210 --> 00:13:37,060
specialized containers other packages

00:13:34,360 --> 00:13:39,190
for encoding and hashing various

00:13:37,060 --> 00:13:43,510
utilities on the fundamental types

00:13:39,190 --> 00:13:48,070
memory allocators and date and time PDL

00:13:43,510 --> 00:13:53,440
t for example the SL Bloomberg standard

00:13:48,070 --> 00:13:58,360
library contains our allocator enabled

00:13:53,440 --> 00:14:01,660
containers and allocators and whole

00:13:58,360 --> 00:14:04,810
suite of utilities and components that

00:14:01,660 --> 00:14:11,530
go into building a library which are

00:14:04,810 --> 00:14:15,160
available for everyone to use and VT LT

00:14:11,530 --> 00:14:17,290
is a package group that is its label not

00:14:15,160 --> 00:14:20,110
recommended for use it's something

00:14:17,290 --> 00:14:22,780
therefore it's there you'll see it it is

00:14:20,110 --> 00:14:24,820
there is a requirement by some other

00:14:22,780 --> 00:14:27,010
library nevertheless I've

00:14:24,820 --> 00:14:29,620
I've heard that it does have some very

00:14:27,010 --> 00:14:31,240
useful components in there for managing

00:14:29,620 --> 00:14:34,390
bandwidth so you might want to take a

00:14:31,240 --> 00:14:36,340
look at those as I said there are no

00:14:34,390 --> 00:14:39,760
cycles between the higher between the

00:14:36,340 --> 00:14:43,480
components between the packages or the

00:14:39,760 --> 00:14:45,520
package groups this is what the

00:14:43,480 --> 00:14:48,040
hierarchy is at the very bottom we have

00:14:45,520 --> 00:14:55,090
compilers of linkers then our standard

00:14:48,040 --> 00:14:57,310
libraries that more heavier fundamental

00:14:55,090 --> 00:15:01,810
libraries and then you could think

00:14:57,310 --> 00:15:03,760
consider relatively speaking application

00:15:01,810 --> 00:15:06,640
libraries things closer to applications

00:15:03,760 --> 00:15:13,120
that's you know and then we it's spread

00:15:06,640 --> 00:15:16,110
out now our goal for today is to is to

00:15:13,120 --> 00:15:18,640
help you find your way through BDE

00:15:16,110 --> 00:15:20,500
the documentation reefs and other

00:15:18,640 --> 00:15:25,720
resources that are available to you so

00:15:20,500 --> 00:15:27,250
that you can get started to give you a

00:15:25,720 --> 00:15:29,830
feel for programming within narrow

00:15:27,250 --> 00:15:32,140
contracts and how to engage our

00:15:29,830 --> 00:15:34,660
defensive programming techniques and

00:15:32,140 --> 00:15:36,910
generally to get you to try to convey to

00:15:34,660 --> 00:15:43,330
you the BTE mindset so if you are going

00:15:36,910 --> 00:15:46,690
to work with this we want to get you

00:15:43,330 --> 00:15:50,110
thinking set your expectations so that

00:15:46,690 --> 00:15:55,030
your barriers are barriers to getting

00:15:50,110 --> 00:15:57,420
involved in our reduced I should say

00:15:55,030 --> 00:16:00,820
that now that this material derives from

00:15:57,420 --> 00:16:03,930
training materials that's work that are

00:16:00,820 --> 00:16:06,190
used for senior hires at Bloomberg

00:16:03,930 --> 00:16:11,830
senior hires of people with several

00:16:06,190 --> 00:16:14,470
years of experience have extensive

00:16:11,830 --> 00:16:16,720
training on technologies of which they

00:16:14,470 --> 00:16:19,600
really can't possibly be familiar prior

00:16:16,720 --> 00:16:21,640
to arriving at Bloomberg and one of one

00:16:19,600 --> 00:16:25,810
of the things is that they get like 10%

00:16:21,640 --> 00:16:28,330
of their time as goes into bde with they

00:16:25,810 --> 00:16:31,840
spend time listening to John's lectures

00:16:28,330 --> 00:16:35,260
and they go through a you know some

00:16:31,840 --> 00:16:38,500
material lab based course this material

00:16:35,260 --> 00:16:40,360
has been adapted from that so this is

00:16:38,500 --> 00:16:45,400
proven successful for getting people on

00:16:40,360 --> 00:16:49,690
board to be a documentation you could

00:16:45,400 --> 00:16:52,750
find it at github where you'll find

00:16:49,690 --> 00:16:57,390
links to tutorials our coding standard

00:16:52,750 --> 00:16:59,710
50-ish pages and not enough detail

00:16:57,390 --> 00:17:02,410
there's so many rules that are not there

00:16:59,710 --> 00:17:06,820
that are not written down how to

00:17:02,410 --> 00:17:09,520
contribute hope you do build

00:17:06,820 --> 00:17:12,100
instructions and link to our online

00:17:09,520 --> 00:17:16,170
documentation the doxygen pages is

00:17:12,100 --> 00:17:18,820
everyone familiar with oxygen okay so

00:17:16,170 --> 00:17:21,580
another thing that you'll find there is

00:17:18,820 --> 00:17:24,750
a taxonomy of classes because classes

00:17:21,580 --> 00:17:26,740
are not just you know or just not

00:17:24,750 --> 00:17:29,920
invented on the fly

00:17:26,740 --> 00:17:33,210
there are various categories of classes

00:17:29,920 --> 00:17:36,100
each having a well defined organization

00:17:33,210 --> 00:17:39,040
certain expectations of methods certain

00:17:36,100 --> 00:17:42,420
common naming conventions so that when

00:17:39,040 --> 00:17:45,340
people design classes they will try to

00:17:42,420 --> 00:17:50,620
they'll they will find the appropriate

00:17:45,340 --> 00:17:53,080
place for this for example there is a

00:17:50,620 --> 00:17:54,430
value semantic class can't even tell me

00:17:53,080 --> 00:18:00,640
what that means anybody's been through

00:17:54,430 --> 00:18:04,000
John's yeah so class that defines a

00:18:00,640 --> 00:18:07,030
value value being a concept that sorry

00:18:04,000 --> 00:18:10,600
that's a reserved word an idea that can

00:18:07,030 --> 00:18:14,160
be that have can preserve its meaning

00:18:10,600 --> 00:18:18,400
across processes and different machines

00:18:14,160 --> 00:18:22,060
you know conceptually if you serialize

00:18:18,400 --> 00:18:24,040
it and recreate it someplace else and

00:18:22,060 --> 00:18:27,720
the meaning has not changed that's

00:18:24,040 --> 00:18:32,140
you're probably working with a value

00:18:27,720 --> 00:18:34,480
other classes create objects that have

00:18:32,140 --> 00:18:40,240
state but no value those are termed

00:18:34,480 --> 00:18:41,850
mechanisms okay of a mechanism example

00:18:40,240 --> 00:18:45,160
of a mechanism would be something like

00:18:41,850 --> 00:18:47,980
memory allocator something that manages

00:18:45,160 --> 00:18:50,020
memory in this process something that

00:18:47,980 --> 00:18:51,840
manages database connections socket

00:18:50,020 --> 00:18:56,070
connections a

00:18:51,840 --> 00:18:58,309
a guard that's standing by to destroy an

00:18:56,070 --> 00:19:04,400
object on destruction

00:18:58,309 --> 00:19:07,950
you know thread pools thank you John

00:19:04,400 --> 00:19:11,330
okay utilities are the of the name we

00:19:07,950 --> 00:19:14,059
use for components that provide

00:19:11,330 --> 00:19:17,309
stateless functions

00:19:14,059 --> 00:19:26,130
you know because not everything in C++

00:19:17,309 --> 00:19:30,950
is an object and those are actually they

00:19:26,130 --> 00:19:36,240
are implemented as the strokes for

00:19:30,950 --> 00:19:38,880
pardon with static methods yes the

00:19:36,240 --> 00:19:40,649
advantage of that being that there's

00:19:38,880 --> 00:19:42,779
only one place where you can define them

00:19:40,649 --> 00:19:45,539
name spaces can be open for many and

00:19:42,779 --> 00:19:47,520
many places in the code whereas a struct

00:19:45,539 --> 00:20:02,610
is only defined in one place and that's

00:19:47,520 --> 00:20:05,210
what we want all right and which is the

00:20:02,610 --> 00:20:05,210
most important

00:20:41,059 --> 00:20:49,679
moving on is also there are also classes

00:20:47,279 --> 00:20:54,659
that define protocols which is a term

00:20:49,679 --> 00:20:57,360
that basically pure virtual a class that

00:20:54,659 --> 00:20:59,429
has pure virtual methods pure no

00:20:57,360 --> 00:21:03,630
implementation so something that can't

00:20:59,429 --> 00:21:05,490
be instantiated so these are bits of dde

00:21:03,630 --> 00:21:08,940
terminology and these

00:21:05,490 --> 00:21:10,650
used throughout the documentation and so

00:21:08,940 --> 00:21:11,970
the expectation is that when you read

00:21:10,650 --> 00:21:13,860
you know that when you're reading them

00:21:11,970 --> 00:21:16,140
you know you have expectations about

00:21:13,860 --> 00:21:17,850
what each one of these are and we'll

00:21:16,140 --> 00:21:19,850
look at some of these in more detail

00:21:17,850 --> 00:21:22,679
later here are some examples though

00:21:19,850 --> 00:21:25,050
value semantics classes our date day of

00:21:22,679 --> 00:21:26,640
week date/time calendar by the way

00:21:25,050 --> 00:21:28,620
calendar here means something different

00:21:26,640 --> 00:21:36,210
than what you've heard it thrown out

00:21:28,620 --> 00:21:40,050
like Renault talked allocators are

00:21:36,210 --> 00:21:42,870
mechanisms utilities are utilities by

00:21:40,050 --> 00:21:44,700
the way and often they're named util but

00:21:42,870 --> 00:21:46,460
not always as you can see there is

00:21:44,700 --> 00:21:52,160
something called current time which is

00:21:46,460 --> 00:21:55,110
utility that is not named that way okay

00:21:52,160 --> 00:22:00,900
if you get to our documentation you'll

00:21:55,110 --> 00:22:03,800
find you'll get to a page it looks more

00:22:00,900 --> 00:22:08,610
or less like this is that readable

00:22:03,800 --> 00:22:10,860
barely all right what people often do is

00:22:08,610 --> 00:22:12,840
they will expand you know hit the button

00:22:10,860 --> 00:22:14,910
we say expand all and that you search

00:22:12,840 --> 00:22:18,300
for things that are of interest to them

00:22:14,910 --> 00:22:21,080
here we are do the search for date and

00:22:18,300 --> 00:22:24,360
we can see the date is part of the vdl T

00:22:21,080 --> 00:22:28,290
group a package and part of the BDL

00:22:24,360 --> 00:22:31,620
group the thing thing circled on the

00:22:28,290 --> 00:22:35,340
left are all links so for example if you

00:22:31,620 --> 00:22:37,830
click on BD L T you'll get a view of

00:22:35,340 --> 00:22:43,980
that entire package will list all the

00:22:37,830 --> 00:22:47,309
components in it will show the hierarchy

00:22:43,980 --> 00:22:49,170
of the components so you have like you

00:22:47,309 --> 00:22:50,970
can see over here that this says 24

00:22:49,170 --> 00:22:54,660
components having several levels of

00:22:50,970 --> 00:22:56,250
physical dependency and so if you wish

00:22:54,660 --> 00:22:58,110
to study this package you might want to

00:22:56,250 --> 00:23:01,110
start from the bottom on things that

00:22:58,110 --> 00:23:02,610
have no dependencies in this package and

00:23:01,110 --> 00:23:04,650
then those are building blocks for the

00:23:02,610 --> 00:23:08,720
next level on the next level and so

00:23:04,650 --> 00:23:13,110
forth okay there's also usage examples

00:23:08,720 --> 00:23:14,940
if you click on the link to the

00:23:13,110 --> 00:23:17,220
component dock you'll get the component

00:23:14,940 --> 00:23:18,550
dock where it will see that there is a

00:23:17,220 --> 00:23:22,840
purpose

00:23:18,550 --> 00:23:29,830
always a sentence almost always starting

00:23:22,840 --> 00:23:33,160
with the word provide we'll have a list

00:23:29,830 --> 00:23:35,950
of classes in this case there is one if

00:23:33,160 --> 00:23:38,560
there's if there are multiple classes

00:23:35,950 --> 00:23:41,110
defined in the component little bit

00:23:38,560 --> 00:23:50,650
others will be listed here there might

00:23:41,110 --> 00:23:52,210
be there might be other classes the in

00:23:50,650 --> 00:23:54,010
the component there might be classes

00:23:52,210 --> 00:23:57,880
there might be classes and solely for

00:23:54,010 --> 00:24:00,010
implementation okay and there's a

00:23:57,880 --> 00:24:02,290
certain naming convention so that people

00:24:00,010 --> 00:24:04,330
know not to use those directly but the

00:24:02,290 --> 00:24:06,310
simple rule is if you see the class

00:24:04,330 --> 00:24:08,530
listed under classes and you're allowed

00:24:06,310 --> 00:24:10,720
to use it if you find some other class

00:24:08,530 --> 00:24:14,980
in there that you're trying to use and

00:24:10,720 --> 00:24:19,570
it changes so you know you don't have

00:24:14,980 --> 00:24:26,020
much of a defense if that changes we

00:24:19,570 --> 00:24:30,000
have lengthy descriptions that's a link

00:24:26,020 --> 00:24:32,710
to get down to class level documentation

00:24:30,000 --> 00:24:34,210
this is getting rather rough this is

00:24:32,710 --> 00:24:35,980
about as far as we're gonna go here

00:24:34,210 --> 00:24:38,680
because it's we find it really hard to

00:24:35,980 --> 00:24:40,810
read this as you can see I had to you

00:24:38,680 --> 00:24:42,730
know the actual pages are way too big to

00:24:40,810 --> 00:24:45,130
pick fit on the screen it's all I had to

00:24:42,730 --> 00:24:47,310
this sort of tear up tear it up into

00:24:45,130 --> 00:24:49,630
pieces just so that you have enough

00:24:47,310 --> 00:24:53,890
there so you can recognize them when you

00:24:49,630 --> 00:24:55,330
get to it I find it actually slow it's

00:24:53,890 --> 00:24:57,430
hard to look at source code on the

00:24:55,330 --> 00:24:59,440
screen it's actually better in this case

00:24:57,430 --> 00:25:01,900
and try and look at those generated

00:24:59,440 --> 00:25:03,640
pages this is this is where all the doc

00:25:01,900 --> 00:25:10,060
comes from it's all embedded in the

00:25:03,640 --> 00:25:13,260
header files divided into sections

00:25:10,060 --> 00:25:17,260
there's our person first purpose line

00:25:13,260 --> 00:25:21,360
again one line and the line can be more

00:25:17,260 --> 00:25:21,360
than 79 columns

00:25:21,679 --> 00:25:36,149
really yes including the slash slash no

00:25:30,929 --> 00:25:38,399
no line of code is more than 79 so it

00:25:36,149 --> 00:25:40,590
makes it makes us it's can be

00:25:38,399 --> 00:25:46,919
challenging to be expressive in that

00:25:40,590 --> 00:25:54,359
small space okay again there's our date

00:25:46,919 --> 00:25:56,549
the class that we're allowed to use see

00:25:54,359 --> 00:25:59,789
also and the description is self-evident

00:25:56,549 --> 00:26:02,159
was also a usage example that typically

00:25:59,789 --> 00:26:03,869
have pedagogical asserts that's to say

00:26:02,159 --> 00:26:05,999
we don't actually somewhat expect

00:26:03,869 --> 00:26:07,590
somebody to be default constructing a

00:26:05,999 --> 00:26:09,149
date and then discerning to see that it

00:26:07,590 --> 00:26:14,159
was done correctly that's that's just

00:26:09,149 --> 00:26:16,679
there to just as a comment this is all

00:26:14,159 --> 00:26:18,419
the usage examples are tested one of the

00:26:16,679 --> 00:26:22,289
responsibilities of the test driver is

00:26:18,419 --> 00:26:25,940
to mechanically reproduce the usage

00:26:22,289 --> 00:26:25,940
example and show that it works correctly

00:26:26,029 --> 00:26:32,659
okay for each so all that information is

00:26:30,539 --> 00:26:36,299
describing the component as a whole

00:26:32,659 --> 00:26:38,700
describing if there are several classes

00:26:36,299 --> 00:26:41,549
in a component describing the

00:26:38,700 --> 00:26:43,830
relationship between those classes per

00:26:41,549 --> 00:26:50,999
each class you'll find some additional

00:26:43,830 --> 00:26:53,220
documentation typically it reproduces

00:26:50,999 --> 00:26:55,379
some of the things said earlier in the

00:26:53,220 --> 00:26:58,950
component level but what you'll find

00:26:55,379 --> 00:27:00,749
here are you know any invariance for a

00:26:58,950 --> 00:27:05,970
class that you should know you know are

00:27:00,749 --> 00:27:09,179
are expressed over here some things are

00:27:05,970 --> 00:27:10,619
there's are tacitly guaranteed for the

00:27:09,179 --> 00:27:13,619
class even though they were not

00:27:10,619 --> 00:27:15,960
mentioned in that description so unless

00:27:13,619 --> 00:27:17,789
you hear otherwise you can assume that

00:27:15,960 --> 00:27:22,909
the methods of the class are cons

00:27:17,789 --> 00:27:27,139
threats safety and by that we mean that

00:27:22,909 --> 00:27:30,179
if you have multiple threads accessing a

00:27:27,139 --> 00:27:32,639
object of the class that is perfectly

00:27:30,179 --> 00:27:37,100
safe as long as they restrict their

00:27:32,639 --> 00:27:37,100
activities to the cons qualified methods

00:27:37,480 --> 00:27:45,920
okay that the methods are exception

00:27:42,320 --> 00:27:48,350
agnostic let me define shortly that

00:27:45,920 --> 00:27:52,600
things are alias safe if that's

00:27:48,350 --> 00:27:55,670
pertinent and this is all true for

00:27:52,600 --> 00:27:59,240
backing up for this class even though we

00:27:55,670 --> 00:28:01,870
did not say it okay so this is one

00:27:59,240 --> 00:28:03,620
example of despite our heavyweight

00:28:01,870 --> 00:28:07,340
documentation there are certain things

00:28:03,620 --> 00:28:09,470
that are tacitly assumes have to be

00:28:07,340 --> 00:28:10,880
known by the root reader these

00:28:09,470 --> 00:28:13,309
particular terms are defined by the

00:28:10,880 --> 00:28:15,320
glossary and if there are stronger or

00:28:13,309 --> 00:28:17,450
weaker guarantees for a particular class

00:28:15,320 --> 00:28:25,850
or a particular method those will be

00:28:17,450 --> 00:28:29,360
called out fairly emphatically regarding

00:28:25,850 --> 00:28:32,330
exceptions exception agnostic is a term

00:28:29,360 --> 00:28:35,030
that means several encompasses several

00:28:32,330 --> 00:28:37,990
things one thing you get out except

00:28:35,030 --> 00:28:40,700
exception agnosticism is the basic

00:28:37,990 --> 00:28:45,200
exception safety guarantee that is in

00:28:40,700 --> 00:28:49,100
case an exception is thrown it is the

00:28:45,200 --> 00:28:57,309
object will be left in a valid state you

00:28:49,100 --> 00:28:57,309
have exception neutrality in that if if

00:28:57,820 --> 00:29:07,340
exceptions will pass through all methods

00:29:01,970 --> 00:29:08,990
without without interference so if one

00:29:07,340 --> 00:29:10,130
of our components call something which

00:29:08,990 --> 00:29:11,960
calls something is called something

00:29:10,130 --> 00:29:14,600
which throws an exception that exception

00:29:11,960 --> 00:29:16,910
will not be caught and stopped it will

00:29:14,600 --> 00:29:18,440
not be modified it just it just flows

00:29:16,910 --> 00:29:21,340
through so you can count on that

00:29:18,440 --> 00:29:24,260
and lastly is in sort of an inflammation

00:29:21,340 --> 00:29:31,520
implementation detail BBE implements

00:29:24,260 --> 00:29:37,309
these this exception safety by using an

00:29:31,520 --> 00:29:39,740
RA I like technique we avoid trying

00:29:37,309 --> 00:29:40,970
catch blocks we use Proctor's which are

00:29:39,740 --> 00:29:44,240
which are guards that have a release

00:29:40,970 --> 00:29:46,190
methods and so that this this code works

00:29:44,240 --> 00:29:47,929
very well it would depend you can build

00:29:46,190 --> 00:29:50,320
it with exceptions or not exceptions it

00:29:47,929 --> 00:29:50,320
just works

00:29:53,470 --> 00:30:01,060
bedico does not throw exceptions it's

00:29:58,430 --> 00:30:04,520
just it's not in our programming model

00:30:01,060 --> 00:30:07,010
except where it's required by the

00:30:04,520 --> 00:30:08,780
standard so we have implementations of

00:30:07,010 --> 00:30:11,180
containers and containers are required

00:30:08,780 --> 00:30:17,150
to throw exceptions at certain times and

00:30:11,180 --> 00:30:21,550
that is a and so they do such as bad

00:30:17,150 --> 00:30:24,470
alec from a memory allocator exceptions

00:30:21,550 --> 00:30:27,710
we throw many exceptions in our test

00:30:24,470 --> 00:30:30,410
drivers because when we say things our

00:30:27,710 --> 00:30:31,880
exception safe it's not because we

00:30:30,410 --> 00:30:34,550
looked at it and said hey that looks

00:30:31,880 --> 00:30:37,880
safe but we we run tests on that so to

00:30:34,550 --> 00:30:39,650
confirm that they are safe and if we

00:30:37,880 --> 00:30:41,540
don't throw exceptions where where do

00:30:39,650 --> 00:30:44,540
they come from well they could come from

00:30:41,540 --> 00:30:46,460
legacy code which other code at

00:30:44,540 --> 00:30:49,280
Bloomberg sometimes we have there be de

00:30:46,460 --> 00:30:51,440
classes that wrap VD

00:30:49,280 --> 00:30:54,650
other Bloomberg methods that could throw

00:30:51,440 --> 00:30:58,430
exceptions so anybody depending on them

00:30:54,650 --> 00:31:00,890
will get them and also we are some

00:30:58,430 --> 00:31:02,510
interfaces where we take user level you

00:31:00,890 --> 00:31:06,820
know callbacks that might throw

00:31:02,510 --> 00:31:06,820
exception so that's where they come from

00:31:08,260 --> 00:31:14,450
lastly we have next next level of

00:31:10,880 --> 00:31:17,750
documentation are the function level dot

00:31:14,450 --> 00:31:21,830
the documentation for each of the

00:31:17,750 --> 00:31:23,570
methods of the class the methods of the

00:31:21,830 --> 00:31:26,180
class are usually organized or the

00:31:23,570 --> 00:31:28,160
banners you see here we have you know

00:31:26,180 --> 00:31:30,800
class methods firsts and static

00:31:28,160 --> 00:31:33,370
functions then creators which include

00:31:30,800 --> 00:31:36,500
all the constructors and the destructor

00:31:33,370 --> 00:31:39,610
manipulators are methods that can change

00:31:36,500 --> 00:31:42,800
that will change the may change these

00:31:39,610 --> 00:31:45,410
static state of the object accessor is

00:31:42,800 --> 00:31:47,920
archives qualified they are guaranteed

00:31:45,410 --> 00:31:50,690
not to change the state of the object

00:31:47,920 --> 00:31:52,340
always in that order and if you're

00:31:50,690 --> 00:31:55,390
navigating our code it's worth

00:31:52,340 --> 00:31:55,390
remembering because that's

00:31:55,779 --> 00:32:05,259
helps you find your way around there is

00:31:59,739 --> 00:32:09,759
a legalistic tone to the documentation

00:32:05,259 --> 00:32:13,059
that you find here you know they're very

00:32:09,759 --> 00:32:16,029
tert its first nose as it comes after

00:32:13,059 --> 00:32:18,309
these methods signature you know ii

00:32:16,029 --> 00:32:19,779
assume you read the method you know what

00:32:18,309 --> 00:32:21,369
the arguments are you know with the

00:32:19,779 --> 00:32:26,009
return type is so we don't have to

00:32:21,369 --> 00:32:29,139
repeat that information okay

00:32:26,009 --> 00:32:33,609
and there's a certain pattern return

00:32:29,139 --> 00:32:44,460
true created date create a date assigned

00:32:33,609 --> 00:32:44,460
to lobe into okay so these are always

00:32:45,269 --> 00:32:57,879
mm-hmm gentlemen so we have a dead

00:32:54,789 --> 00:33:00,759
regular form for writing these writing

00:32:57,879 --> 00:33:02,469
this documentation it's always what

00:33:00,759 --> 00:33:06,249
first thing we say is what the function

00:33:02,469 --> 00:33:09,669
does it's always a verb it's it's done

00:33:06,249 --> 00:33:12,070
in the imperative mood as if you the

00:33:09,669 --> 00:33:13,719
reader are commanding you know you who

00:33:12,070 --> 00:33:16,509
are invoking the method or commanding

00:33:13,719 --> 00:33:18,609
the object to do something you will set

00:33:16,509 --> 00:33:23,109
or you will load or you will create or

00:33:18,609 --> 00:33:25,149
destroy or so forth and the next part

00:33:23,109 --> 00:33:28,239
the next thing you will find what the

00:33:25,149 --> 00:33:30,519
function returns and in some cases the

00:33:28,239 --> 00:33:32,109
two convolve if all the function if all

00:33:30,519 --> 00:33:34,989
the method does is return something well

00:33:32,109 --> 00:33:37,089
that's what it that's what it does any

00:33:34,989 --> 00:33:40,479
other argument optional arguments or any

00:33:37,089 --> 00:33:45,070
of your discuss next all other essential

00:33:40,479 --> 00:33:46,869
behavior is listed after that and there

00:33:45,070 --> 00:33:49,769
we have I urge you to be careful and

00:33:46,869 --> 00:33:53,619
Siri what is the actual describes

00:33:49,769 --> 00:33:56,169
essential behavior okay it may be

00:33:53,619 --> 00:33:59,559
different you know do not rely on

00:33:56,169 --> 00:34:02,320
observe behavior sometimes you will say

00:33:59,559 --> 00:34:03,429
oh I you know the method the method

00:34:02,320 --> 00:34:05,589
didn't say what it does in these

00:34:03,429 --> 00:34:09,400
circumstances but I ran some tests and I

00:34:05,589 --> 00:34:12,340
found it does X Y or Z so I'll depend on

00:34:09,400 --> 00:34:14,860
that okay in that case you will be in

00:34:12,340 --> 00:34:17,410
trouble if that changes only the you

00:34:14,860 --> 00:34:23,110
know the explicitly listed behaviors is

00:34:17,410 --> 00:34:25,120
something you can rely upon next

00:34:23,110 --> 00:34:28,590
conditions leading to undefined behavior

00:34:25,120 --> 00:34:33,610
so the preconditions for the method and

00:34:28,590 --> 00:34:39,940
lastly clarifications note that now the

00:34:33,610 --> 00:34:43,540
general note that means that note that

00:34:39,940 --> 00:34:46,950
is something that will tell you what is

00:34:43,540 --> 00:34:53,320
something pay extra attention to this

00:34:46,950 --> 00:34:56,140
here it means the to clarify might be

00:34:53,320 --> 00:34:57,430
the better way to say it except we have

00:34:56,140 --> 00:34:59,590
you know we have a lot of thought that

00:34:57,430 --> 00:35:01,390
says note that so note deaths are not

00:34:59,590 --> 00:35:03,490
normative you will not learn anything

00:35:01,390 --> 00:35:07,360
new about the contract in the note that

00:35:03,490 --> 00:35:09,610
just but it's its opportunity for the

00:35:07,360 --> 00:35:13,690
author to try to explain something that

00:35:09,610 --> 00:35:15,460
might not have been obvious lastly we

00:35:13,690 --> 00:35:17,890
have a convention that the first time a

00:35:15,460 --> 00:35:20,770
parameter name is mentioned we introduce

00:35:17,890 --> 00:35:22,230
the expression the specified so just

00:35:20,770 --> 00:35:24,910
going back for a moment

00:35:22,230 --> 00:35:29,200
return true we have the specified year

00:35:24,910 --> 00:35:34,780
month and day and and so forth the

00:35:29,200 --> 00:35:37,110
specified right hand side date I just so

00:35:34,780 --> 00:35:38,590
I take that as a clue to go back and

00:35:37,110 --> 00:35:40,750
check you know

00:35:38,590 --> 00:35:56,440
shift my eyes up and see what type that

00:35:40,750 --> 00:36:05,430
that parameter is questions here you do

00:35:56,440 --> 00:36:07,080
not say the specified correct okay

00:36:05,430 --> 00:36:10,740
let's go back to look at our

00:36:07,080 --> 00:36:15,090
component-level dock again provide a

00:36:10,740 --> 00:36:17,460
value semantics type to date the class

00:36:15,090 --> 00:36:19,230
is a value semantics date type for this

00:36:17,460 --> 00:36:22,970
component defines a value semantics

00:36:19,230 --> 00:36:30,360
class does the author of this page

00:36:22,970 --> 00:36:35,180
dawn lake owes by the way expect you to

00:36:30,360 --> 00:36:38,490
know what a value semantics class is yes

00:36:35,180 --> 00:36:41,160
which is why I spend time to discuss

00:36:38,490 --> 00:36:43,260
what goes into that briefly

00:36:41,160 --> 00:36:48,150
now your semantic types are ones that

00:36:43,260 --> 00:36:52,070
represent a value that have regular type

00:36:48,150 --> 00:36:54,570
syntax I love Alex Stephan Offutt have a

00:36:52,070 --> 00:36:57,600
reasonable operator II have a have a

00:36:54,570 --> 00:36:59,520
operator equal equal that compares those

00:36:57,600 --> 00:37:04,920
things so those are the characteristics

00:36:59,520 --> 00:37:07,640
of value semantics class typically you

00:37:04,920 --> 00:37:10,350
will find methods default constructor

00:37:07,640 --> 00:37:12,450
value constructor where you can specify

00:37:10,350 --> 00:37:14,370
the attributes of the class to bring it

00:37:12,450 --> 00:37:17,310
into the state that you want copy

00:37:14,370 --> 00:37:21,330
constructors okay no surprises

00:37:17,310 --> 00:37:24,660
assignment equal equal equal of course

00:37:21,330 --> 00:37:26,670
not equal and getter so setters of

00:37:24,660 --> 00:37:31,740
difference though we don't use that

00:37:26,670 --> 00:37:40,200
terminology okay you'll also find a

00:37:31,740 --> 00:37:42,210
print method for these classes so that

00:37:40,200 --> 00:37:48,330
this is there so for debugging purposes

00:37:42,210 --> 00:37:50,150
and for testing purposes there has been

00:37:48,330 --> 00:37:55,260
that it is it has a rather lengthy

00:37:50,150 --> 00:37:58,230
contract which very few people read but

00:37:55,260 --> 00:38:00,600
the key key points are that it's going

00:37:58,230 --> 00:38:05,550
to print the value in some unspecified

00:38:00,600 --> 00:38:07,710
human readable form and it is subject to

00:38:05,550 --> 00:38:10,530
change and do not write do not write

00:38:07,710 --> 00:38:13,140
parsers for this because it's subject to

00:38:10,530 --> 00:38:18,000
change if you want something in a

00:38:13,140 --> 00:38:18,860
different format you do that yourself

00:38:18,000 --> 00:38:21,560
this is this

00:38:18,860 --> 00:38:24,440
prick methods are really not part of the

00:38:21,560 --> 00:38:27,200
value class okay there are a million

00:38:24,440 --> 00:38:29,360
ways to print a date and the more we

00:38:27,200 --> 00:38:30,830
thought of every every everyday we're

00:38:29,360 --> 00:38:33,290
not going to encumber the date class

00:38:30,830 --> 00:38:37,970
with that mmm top of the day classes to

00:38:33,290 --> 00:38:39,260
do to represent a date value and of

00:38:37,970 --> 00:38:40,790
course since one of these things

00:38:39,260 --> 00:38:43,670
happened to change in the last release

00:38:40,790 --> 00:38:47,180
of course there was a true haha about it

00:38:43,670 --> 00:38:50,060
and the fact that we you know we pointed

00:38:47,180 --> 00:38:55,280
out the contract really didn't didn't

00:38:50,060 --> 00:38:57,260
protect us very much all right

00:38:55,280 --> 00:38:59,720
so having discussed some of the things

00:38:57,260 --> 00:39:02,270
about date as a values of Mantic type

00:38:59,720 --> 00:39:04,400
date operator date itself you can

00:39:02,270 --> 00:39:05,690
increment the date you can do fancier

00:39:04,400 --> 00:39:08,750
with mythic on the date you can compare

00:39:05,690 --> 00:39:11,420
dates you can set take values these are

00:39:08,750 --> 00:39:13,070
things that are specific to dates there

00:39:11,420 --> 00:39:16,280
are other value semantic classes that

00:39:13,070 --> 00:39:19,730
are not so complicated they just hold

00:39:16,280 --> 00:39:22,370
you know they just hold values and don't

00:39:19,730 --> 00:39:24,230
don't provide any operators and if you

00:39:22,370 --> 00:39:25,970
go back to the taxonomy you'll find that

00:39:24,230 --> 00:39:29,570
they're under values event types their

00:39:25,970 --> 00:39:33,910
various sub categories of value of value

00:39:29,570 --> 00:39:37,280
semantic values though semantic types

00:39:33,910 --> 00:39:40,190
and sometimes those that terminology

00:39:37,280 --> 00:39:44,720
will creep into the documentation the

00:39:40,190 --> 00:39:50,030
date value itself represents dates in

00:39:44,720 --> 00:39:52,220
the range 1 from of year one month one

00:39:50,030 --> 00:39:56,060
day one to New Year's Eve of the year

00:39:52,220 --> 00:39:58,930
ten thousand except for some days in

00:39:56,060 --> 00:40:02,000
1752 when the english-speaking world

00:39:58,930 --> 00:40:09,050
switched from the Julian calendar to the

00:40:02,000 --> 00:40:13,480
Gregorian calendar which is kind of odd

00:40:09,050 --> 00:40:16,220
but that is a POSIX standard there are

00:40:13,480 --> 00:40:19,430
there is code there to support proleptic

00:40:16,220 --> 00:40:23,180
Gregorian dates you are allowed to use

00:40:19,430 --> 00:40:26,890
them we at Bloomberg or not having

00:40:23,180 --> 00:40:26,890
having started using the other kind

00:40:27,680 --> 00:40:34,610
methods are provided so basically a date

00:40:30,260 --> 00:40:36,950
a date is represented by integers you

00:40:34,610 --> 00:40:38,110
know year month and day or year day and

00:40:36,950 --> 00:40:42,050
year

00:40:38,110 --> 00:40:43,970
how do you know which which combinations

00:40:42,050 --> 00:40:46,370
of integers you can't put into a class

00:40:43,970 --> 00:40:49,390
there are static methods provided to

00:40:46,370 --> 00:40:54,410
tell you whether they are valid or not

00:40:49,390 --> 00:40:56,030
so just using it The Fault construct a

00:40:54,410 --> 00:40:58,400
date what is what years

00:40:56,030 --> 00:41:06,250
what is it as folks the full value of a

00:40:58,400 --> 00:41:08,870
date somebody pardon a pop no read it

00:41:06,250 --> 00:41:13,090
fall construct the date is one one one

00:41:08,870 --> 00:41:17,120
year one month one day one okay

00:41:13,090 --> 00:41:21,230
okay having a date we can set the year

00:41:17,120 --> 00:41:24,100
month and date okay three integers here

00:41:21,230 --> 00:41:29,210
month and date be careful of the order

00:41:24,100 --> 00:41:33,380
what happens if you do this Americans

00:41:29,210 --> 00:41:36,740
like to put the month first 15 minutes

00:41:33,380 --> 00:41:39,070
let's go and 20 slides should be good

00:41:36,740 --> 00:41:43,670
thank you

00:41:39,070 --> 00:41:52,760
so be careful of the order what happens

00:41:43,670 --> 00:41:58,460
in this case there is no status it's a

00:41:52,760 --> 00:41:59,780
it's a method it's it returns void if I

00:41:58,460 --> 00:42:06,340
what's what's the undefined behavior

00:41:59,780 --> 00:42:13,060
again you're out of contract thank you

00:42:06,340 --> 00:42:18,050
okay though we've yes that'll be really

00:42:13,060 --> 00:42:21,860
unexpected okay undefined behavior is

00:42:18,050 --> 00:42:26,270
one of the features of bde code okay

00:42:21,860 --> 00:42:28,790
there is a there is a class of library

00:42:26,270 --> 00:42:30,320
that the library design that's saying

00:42:28,790 --> 00:42:36,880
that the user should not be allowed to

00:42:30,320 --> 00:42:36,880
make any errors this is not that

00:42:37,420 --> 00:42:45,440
if you know that if you're if you know

00:42:43,820 --> 00:42:48,890
you're putting a good date there are no

00:42:45,440 --> 00:42:51,770
checks if you're if you're not certain

00:42:48,890 --> 00:42:56,540
if you want validation which is not

00:42:51,770 --> 00:42:59,930
trivial then you use the if valid method

00:42:56,540 --> 00:43:02,990
or you can just take the invoke the

00:42:59,930 --> 00:43:06,310
static method directly and hopefully you

00:43:02,990 --> 00:43:10,610
copy the values back correctly down to

00:43:06,310 --> 00:43:14,300
and create your date object date

00:43:10,610 --> 00:43:16,760
arithmetic is you can increment you can

00:43:14,300 --> 00:43:19,220
change things by you know you can

00:43:16,760 --> 00:43:21,830
advance the date bike one day advance it

00:43:19,220 --> 00:43:25,220
by three days you can the difference of

00:43:21,830 --> 00:43:28,430
dates is an integer value and just FYI

00:43:25,220 --> 00:43:30,400
the first lab for this course when you

00:43:28,430 --> 00:43:34,550
have a lab is to have everybody you just

00:43:30,400 --> 00:43:36,050
calculate how old they are in days it

00:43:34,550 --> 00:43:39,380
seems they seem to get a kick out of

00:43:36,050 --> 00:43:42,520
that of course they are a lot younger

00:43:39,380 --> 00:43:42,520
than I am okay

00:43:44,120 --> 00:43:48,440
Borel narrow contracts now narrow

00:43:46,070 --> 00:43:53,060
contracts are placed preconditions on

00:43:48,440 --> 00:43:58,280
the input parameters our object state we

00:43:53,060 --> 00:44:00,410
state those very clearly okay and it's a

00:43:58,280 --> 00:44:02,300
very common feature of BDD code if you

00:44:00,410 --> 00:44:04,040
don't find any such preconditions that

00:44:02,300 --> 00:44:05,780
it's a wide contract you can put in any

00:44:04,040 --> 00:44:10,780
values that the parameters

00:44:05,780 --> 00:44:16,190
Kanaka can can hold here's an example

00:44:10,780 --> 00:44:19,250
highlighted in red created dates you can

00:44:16,190 --> 00:44:21,740
use any year month and day behavior is

00:44:19,250 --> 00:44:24,260
undefined unless those things we've

00:44:21,740 --> 00:44:26,450
returned true by is valid year month and

00:44:24,260 --> 00:44:30,320
day oh by the way note that the

00:44:26,450 --> 00:44:33,440
convent's strong convention that methods

00:44:30,320 --> 00:44:38,000
that return a boolean start with is or

00:44:33,440 --> 00:44:43,160
has something like that reads reasonably

00:44:38,000 --> 00:44:45,020
well operator plus plus is almost

00:44:43,160 --> 00:44:46,640
completely wide calendar you can always

00:44:45,020 --> 00:44:49,490
increment the date unless you're on the

00:44:46,640 --> 00:44:51,680
last date then is support it so do

00:44:49,490 --> 00:44:54,950
try to go past New Year's Eve of the

00:44:51,680 --> 00:44:57,020
year 10,000 and of course setting year

00:44:54,950 --> 00:45:08,930
month and date will always be bad if

00:44:57,020 --> 00:45:10,940
year of day is more than 366 more on

00:45:08,930 --> 00:45:13,130
that the moment okay I don't know if you

00:45:10,940 --> 00:45:18,050
we have some we have things to help

00:45:13,130 --> 00:45:20,510
people but whether or not that is it

00:45:18,050 --> 00:45:26,030
might be what he calls a sanitizer there

00:45:20,510 --> 00:45:28,430
intensive program might be yes okay all

00:45:26,030 --> 00:45:31,220
right anyway key concept preconditions

00:45:28,430 --> 00:45:34,340
are met everything at work by contract

00:45:31,220 --> 00:45:37,490
we rarely get eight bug reports saying

00:45:34,340 --> 00:45:41,780
you do not meet your contract maybe once

00:45:37,490 --> 00:45:47,540
a year and that's on like a thousand

00:45:41,780 --> 00:45:49,790
components otherwise anything could

00:45:47,540 --> 00:45:53,119
happen has been discussed at other

00:45:49,790 --> 00:45:58,430
places and other times other talks over

00:45:53,119 --> 00:46:01,400
here anything of course you know except

00:45:58,430 --> 00:46:06,170
except for the absurd it can change over

00:46:01,400 --> 00:46:08,780
the time in our view if you've entered

00:46:06,170 --> 00:46:09,619
on undefined behavior entire process is

00:46:08,780 --> 00:46:14,450
corrupt

00:46:09,619 --> 00:46:15,890
I mean a process a path of execution

00:46:14,450 --> 00:46:18,020
that got you into undefined behavior

00:46:15,890 --> 00:46:20,600
meant that your program went bad

00:46:18,020 --> 00:46:23,030
upstream so this is not something you

00:46:20,600 --> 00:46:24,530
try to cover recover from by the way

00:46:23,030 --> 00:46:27,530
when anything you say anything can

00:46:24,530 --> 00:46:32,600
happen there's a subtle one sometimes it

00:46:27,530 --> 00:46:35,540
works as you expected it to work that's

00:46:32,600 --> 00:46:37,580
within that's that's that could happen

00:46:35,540 --> 00:46:44,380
and that might change someday and people

00:46:37,580 --> 00:46:46,760
get very upset okay over here we have a

00:46:44,380 --> 00:46:48,380
contract load into the specified year

00:46:46,760 --> 00:46:51,500
and day of year the respective year and

00:46:48,380 --> 00:46:56,060
day of year attributes of this date does

00:46:51,500 --> 00:46:57,859
the contract say year either those

00:46:56,060 --> 00:47:00,940
pointers have to be nonzero

00:46:57,859 --> 00:47:00,940
could they be 0

00:47:03,079 --> 00:47:10,109
okay contract doesn't say anything but

00:47:08,069 --> 00:47:12,779
the tacit assumption is that those are

00:47:10,109 --> 00:47:15,510
valid pointers they are not zero they're

00:47:12,779 --> 00:47:17,190
also not one to twelve you know other

00:47:15,510 --> 00:47:19,109
values that are probably not good

00:47:17,190 --> 00:47:20,520
addresses they have to be good addresses

00:47:19,109 --> 00:47:23,039
in this case they have to be writable

00:47:20,520 --> 00:47:28,440
they have to be aligned they have to if

00:47:23,039 --> 00:47:30,270
they're pointing to two non fundamental

00:47:28,440 --> 00:47:32,490
types you know if they're pointing to an

00:47:30,270 --> 00:47:33,599
object there we assume that there if you

00:47:32,490 --> 00:47:35,299
give me the address of the string with

00:47:33,599 --> 00:47:36,539
your and as soon there's a string there

00:47:35,299 --> 00:47:40,549
okay

00:47:36,539 --> 00:47:40,549
checking for that is hard yes sir

00:47:44,270 --> 00:48:07,079
references are not as safe as people

00:47:47,069 --> 00:48:08,670
think they okay can we I'm a little

00:48:07,079 --> 00:48:15,960
under a little time pressure can we take

00:48:08,670 --> 00:48:19,400
that up off I know what to say I just

00:48:15,960 --> 00:48:26,940
don't have time to say it though okay

00:48:19,400 --> 00:48:28,980
okay that so so there are tacit

00:48:26,940 --> 00:48:30,960
assumptions about pointers and it's too

00:48:28,980 --> 00:48:35,039
much to say that every single time so

00:48:30,960 --> 00:48:36,920
yeah okay it's easy to slip into

00:48:35,039 --> 00:48:42,619
undefined behavior

00:48:36,920 --> 00:48:45,480
what's wrong with line one pardon

00:48:42,619 --> 00:48:47,670
invalid date but easy to think I mean

00:48:45,480 --> 00:48:48,930
three in values and those tend to be

00:48:47,670 --> 00:48:54,440
default to zero

00:48:48,930 --> 00:48:54,440
yep what's wrong with the second line

00:48:54,829 --> 00:48:58,859
under flow yes default construct the

00:48:57,240 --> 00:49:00,210
date decremented you didn't see the

00:48:58,859 --> 00:49:02,309
method for that but you know

00:49:00,210 --> 00:49:04,920
extrapolating from what your so about

00:49:02,309 --> 00:49:09,390
plus plus what is wrong with number

00:49:04,920 --> 00:49:12,120
three okay

00:49:09,390 --> 00:49:16,680
not that many years in the in the entire

00:49:12,120 --> 00:49:18,600
calendar not that many days it's not

00:49:16,680 --> 00:49:20,400
that large a number if you're if you

00:49:18,600 --> 00:49:21,720
have a function that is returning an INT

00:49:20,400 --> 00:49:28,980
and that you're gonna be adding it to a

00:49:21,720 --> 00:49:31,700
date yeah so it's uh you know you want

00:49:28,980 --> 00:49:35,370
to be careful about that and of course

00:49:31,700 --> 00:49:38,160
367 is always bad okay what's wrong with

00:49:35,370 --> 00:49:40,470
this guy a little book more subtle load

00:49:38,160 --> 00:49:43,080
to the specified result the earliest

00:49:40,470 --> 00:49:45,540
date of interest between specified first

00:49:43,080 --> 00:49:47,610
and last dates inclusive returns zero on

00:49:45,540 --> 00:49:50,040
a success and nonzero value otherwise

00:49:47,610 --> 00:49:56,430
the behavior is undefined unless first

00:49:50,040 --> 00:50:19,590
is less than or equal to last why is the

00:49:56,430 --> 00:50:24,930
test wrong vs. equals first it doesn't

00:50:19,590 --> 00:50:27,030
work well you write that is bug the bug

00:50:24,930 --> 00:50:29,520
I was thinking about was that last could

00:50:27,030 --> 00:50:35,090
be it if you were depending upon date

00:50:29,520 --> 00:50:38,540
exceeding last for the loop to end

00:50:35,090 --> 00:50:41,700
you're going to be in trouble if last is

00:50:38,540 --> 00:50:45,770
you know nine nine nine nine one zero

00:50:41,700 --> 00:50:49,380
something they will rarely come up but

00:50:45,770 --> 00:50:50,730
but they could so you don't want it you

00:50:49,380 --> 00:50:52,950
don't want to have to count on the ton

00:50:50,730 --> 00:50:56,060
date achieving a value past nine nine

00:50:52,950 --> 00:50:56,060
nine twelve thirty one

00:51:10,370 --> 00:51:22,020
okay new that day yes okay this is

00:51:15,840 --> 00:51:25,470
buggier than I thought in the and the

00:51:22,020 --> 00:51:27,780
band the point is is that the that this

00:51:25,470 --> 00:51:30,360
is an idiom that is you know people

00:51:27,780 --> 00:51:32,520
typically you know we write from this so

00:51:30,360 --> 00:51:35,040
you go past your limit and that's what

00:51:32,520 --> 00:51:37,410
people reflexively do but it's it could

00:51:35,040 --> 00:51:39,960
be bad this you know in this cases also

00:51:37,410 --> 00:51:41,700
if you don't meet the prerequisite here

00:51:39,960 --> 00:51:45,480
you could possibly get into it think you

00:51:41,700 --> 00:51:46,170
get into bad things happen so let's just

00:51:45,480 --> 00:51:51,030
go on there

00:51:46,170 --> 00:51:54,710
so just commentary on language people

00:51:51,030 --> 00:51:57,630
will say that will say things like

00:51:54,710 --> 00:51:59,430
validate object and invalidate object

00:51:57,630 --> 00:52:00,900
that's really is you know the first one

00:51:59,430 --> 00:52:02,160
is redundant the second one is

00:52:00,900 --> 00:52:05,070
contradictory

00:52:02,160 --> 00:52:07,890
you know if you have a date object you

00:52:05,070 --> 00:52:10,460
see what's valid we don't check when we

00:52:07,890 --> 00:52:15,240
copy we don't check when we assign them

00:52:10,460 --> 00:52:17,760
okay it turns out that's a rather hard

00:52:15,240 --> 00:52:20,430
concept for many people to get the

00:52:17,760 --> 00:52:22,650
students I have will often seem to think

00:52:20,430 --> 00:52:25,590
you can have that object in an invalid

00:52:22,650 --> 00:52:27,630
you know you can that we construct an

00:52:25,590 --> 00:52:30,690
object and somehow look at it and fix it

00:52:27,630 --> 00:52:35,220
up like everything's gonna still gonna

00:52:30,690 --> 00:52:37,290
work okay anyway since defensive

00:52:35,220 --> 00:52:39,060
programming within these contracts can

00:52:37,290 --> 00:52:41,790
be challenging though one can argue

00:52:39,060 --> 00:52:43,230
whether that's more so than dealing with

00:52:41,790 --> 00:52:45,600
pointers or dealing with integer

00:52:43,230 --> 00:52:48,480
overflow and other things that we trust

00:52:45,600 --> 00:52:51,410
people to do so BBE code has compiled

00:52:48,480 --> 00:52:54,270
time conditional assertion checks

00:52:51,410 --> 00:52:56,730
built-in when it is possible or

00:52:54,270 --> 00:53:00,600
practical these are not part of the

00:52:56,730 --> 00:53:05,600
contract so this is as part of what we

00:53:00,600 --> 00:53:10,980
call quality of implementation bill

00:53:05,600 --> 00:53:13,650
details okay so we're not promising this

00:53:10,980 --> 00:53:16,080
but because we want to be you know we

00:53:13,650 --> 00:53:17,970
want to help you

00:53:16,080 --> 00:53:20,730
where possible we'll put these things

00:53:17,970 --> 00:53:24,700
and they will be they're done using a

00:53:20,730 --> 00:53:30,140
system of macros invented by

00:53:24,700 --> 00:53:32,560
just be like OHS here excuse me doctor

00:53:30,140 --> 00:53:36,670
likens okay

00:53:32,560 --> 00:53:40,869
doctor doctor Legos okay

00:53:36,670 --> 00:53:44,480
all right here's an example of where of

00:53:40,869 --> 00:53:46,880
how they might be used behavior

00:53:44,480 --> 00:53:48,650
blah blah blah long contract behaviour

00:53:46,880 --> 00:53:52,570
undefined list target date is in the

00:53:48,650 --> 00:53:54,859
range of calendar where calendar here is

00:53:52,570 --> 00:53:57,320
something that we have a class that we

00:53:54,859 --> 00:54:01,760
have that maintains a day a range of

00:53:57,320 --> 00:54:03,710
dates and has that can be adorned with

00:54:01,760 --> 00:54:05,720
information about which days are

00:54:03,710 --> 00:54:09,770
holidays in which days are weekend days

00:54:05,720 --> 00:54:11,359
and so forth okay so that you'll find is

00:54:09,770 --> 00:54:14,810
that we will do a limited check on the

00:54:11,359 --> 00:54:19,609
validity of free date will check to see

00:54:14,810 --> 00:54:22,760
whether it is 0 or not and it happens to

00:54:19,609 --> 00:54:25,550
be invalid to ask about to invoke is in

00:54:22,760 --> 00:54:27,890
range on the calendar object unless the

00:54:25,550 --> 00:54:30,380
range is greater than 0 so we first

00:54:27,890 --> 00:54:32,750
check to see it's okay to run the method

00:54:30,380 --> 00:54:36,910
and then we run and then we check to see

00:54:32,750 --> 00:54:36,910
whether the target date is in range now

00:54:39,820 --> 00:54:45,880
now what why didn't we just use assert

00:54:43,700 --> 00:54:50,540
somebody wants that asked me recently

00:54:45,880 --> 00:54:53,300
well these are better in two ways one we

00:54:50,540 --> 00:54:55,849
have finer control over which of these

00:54:53,300 --> 00:54:58,550
assertion living with asserts they're

00:54:55,849 --> 00:55:02,710
either on or off here we have different

00:54:58,550 --> 00:55:05,330
categories of checks that are key to the

00:55:02,710 --> 00:55:08,660
the computational weight of the check

00:55:05,330 --> 00:55:11,630
and we have freedom as to what happens

00:55:08,660 --> 00:55:16,160
when an assertion fails so normally for

00:55:11,630 --> 00:55:18,740
an assert will use the assert macro the

00:55:16,160 --> 00:55:20,930
unadorned cert macro when the overhead

00:55:18,740 --> 00:55:25,310
is roughly five to ten percent of the

00:55:20,930 --> 00:55:28,369
method call if something is heavier than

00:55:25,310 --> 00:55:31,130
that we'll call an assert safe differ a

00:55:28,369 --> 00:55:35,359
different macro that can be turned on or

00:55:31,130 --> 00:55:37,430
off separately and and these are you'll

00:55:35,359 --> 00:55:37,819
see these very uh these commonly appear

00:55:37,430 --> 00:55:39,799
in

00:55:37,819 --> 00:55:41,809
methods because their sole inline

00:55:39,799 --> 00:55:44,900
methods are so short and so fast that

00:55:41,809 --> 00:55:47,959
any check is going to is going to double

00:55:44,900 --> 00:55:49,910
the costs of a method call so they thing

00:55:47,959 --> 00:55:52,579
a categorized as safe and lastly they

00:55:49,910 --> 00:55:54,589
have another category for method for

00:55:52,579 --> 00:55:59,499
checks that you want to do even in

00:55:54,589 --> 00:56:02,209
optimized mode now the library developer

00:55:59,499 --> 00:56:03,949
person who writes the code will

00:56:02,209 --> 00:56:05,809
categorize put in the checks and

00:56:03,949 --> 00:56:10,690
categorize them according to their

00:56:05,809 --> 00:56:12,769
weight the application builder decides

00:56:10,690 --> 00:56:17,630
what is the appropriate level of

00:56:12,769 --> 00:56:26,599
defensive checking so to separate

00:56:17,630 --> 00:56:30,140
independent responsibilities this table

00:56:26,599 --> 00:56:32,900
is give you some idea of how to turn

00:56:30,140 --> 00:56:36,079
them on as essentially if you type in if

00:56:32,900 --> 00:56:37,819
you set the flag DSL asserts on your

00:56:36,079 --> 00:56:40,609
score level underscore starts safe

00:56:37,819 --> 00:56:44,180
you'll get them all turned on the

00:56:40,609 --> 00:56:46,640
default is the second column the second

00:56:44,180 --> 00:56:49,519
row where the safes are often the others

00:56:46,640 --> 00:56:52,309
are wrong and optimized build modes

00:56:49,519 --> 00:56:53,479
you'll have all the ops and you can turn

00:56:52,309 --> 00:56:56,719
them all off and there are other

00:56:53,479 --> 00:56:59,799
combinations if you want to these are

00:56:56,719 --> 00:56:59,799
the ones that are commonly used

00:57:00,190 --> 00:57:08,410
personally I always develop with asserts

00:57:02,690 --> 00:57:14,049
a flaw why not okay and if you're doing

00:57:08,410 --> 00:57:19,039
waffles as instructed the as instructed

00:57:14,049 --> 00:57:22,699
at our github site you use the safe

00:57:19,039 --> 00:57:27,319
option to off configure and more details

00:57:22,699 --> 00:57:30,440
at that link you see there lastly the

00:57:27,319 --> 00:57:35,690
last level of freedom is what happens

00:57:30,440 --> 00:57:39,469
when assertion fails well that happens

00:57:35,690 --> 00:57:43,430
at runtime that whoever is starting up

00:57:39,469 --> 00:57:45,170
the program is going to determine what

00:57:43,430 --> 00:57:46,130
happened what happens when assertion

00:57:45,170 --> 00:57:48,480
fails this is something you can

00:57:46,130 --> 00:57:52,140
programmatically change over the course

00:57:48,480 --> 00:57:55,170
of a process lifetime the default

00:57:52,140 --> 00:57:57,329
handler does it aborts so we have our

00:57:55,170 --> 00:58:00,660
same behavior that we have the one that

00:57:57,329 --> 00:58:04,770
we know from the classic assert second

00:58:00,660 --> 00:58:06,599
method will use will sleep so that you

00:58:04,770 --> 00:58:09,599
can then go over and examine the live

00:58:06,599 --> 00:58:12,390
process with a debugger you know just

00:58:09,599 --> 00:58:14,970
while it's still in memory there's also

00:58:12,390 --> 00:58:19,440
a method called fail throw which shows

00:58:14,970 --> 00:58:22,740
that particular exception which will

00:58:19,440 --> 00:58:25,490
give you if you an opportunity to do a

00:58:22,740 --> 00:58:28,140
safe shutdown remember this is something

00:58:25,490 --> 00:58:30,300
you don't if you have gotten into the

00:58:28,140 --> 00:58:33,000
situation where you've entered undefined

00:58:30,300 --> 00:58:36,810
behavior you've got a process then a

00:58:33,000 --> 00:58:38,849
suspect you know it why did it get why

00:58:36,810 --> 00:58:45,480
is it trying to do something so bad

00:58:38,849 --> 00:58:48,420
so best policy is to just is to just try

00:58:45,480 --> 00:58:49,710
to shut it down safely rather than

00:58:48,420 --> 00:58:51,780
continue and try to make mistakes

00:58:49,710 --> 00:58:53,760
especially you know if you're an

00:58:51,780 --> 00:58:58,680
important application course who's an

00:58:53,760 --> 00:59:02,700
application is not important now there

00:58:58,680 --> 00:59:07,079
is a an option to log the exception and

00:59:02,700 --> 00:59:09,140
then continue into the undefined

00:59:07,079 --> 00:59:13,140
behavior and this is something we use

00:59:09,140 --> 00:59:18,829
when we have working code that's making

00:59:13,140 --> 00:59:20,609
money but we want to encourage people to

00:59:18,829 --> 00:59:23,700
instrument their code with these

00:59:20,609 --> 00:59:26,069
assertions so this is a way we can

00:59:23,700 --> 00:59:29,819
discover problems in existing code

00:59:26,069 --> 00:59:37,010
without causing interrupts to clients

00:59:29,819 --> 00:59:39,960
and one more slide please just a summary

00:59:37,010 --> 00:59:41,250
so the libraries I assert and hopefully

00:59:39,960 --> 00:59:44,010
I've convinced you that these provide

00:59:41,250 --> 00:59:48,869
wide utility the documentation is clear

00:59:44,010 --> 00:59:50,670
complete very regular having a tax up

00:59:48,869 --> 00:59:55,640
well-defined taxonomy aids and

00:59:50,670 --> 00:59:58,680
comprehension and using narrow contracts

00:59:55,640 --> 01:00:00,620
without forcing checks when they're not

00:59:58,680 --> 01:00:05,060
necessary leads to efficient

01:00:00,620 --> 01:00:08,320
programs if you if you use them

01:00:05,060 --> 01:00:14,270
correctly and use them responsibly and

01:00:08,320 --> 01:00:17,180
and and can be handled by seasoned

01:00:14,270 --> 01:00:47,420
developers with appropriate training any

01:00:17,180 --> 01:00:50,650
questions okay you were first we have

01:00:47,420 --> 01:00:53,540
little control over people outside of

01:00:50,650 --> 01:00:55,880
out of PDE that by the way the question

01:00:53,540 --> 01:01:00,230
is do we enforce our rules on everybody

01:00:55,880 --> 01:01:03,760
else in Bloomberg if only we could but

01:01:00,230 --> 01:01:08,300
it's a matter we lead by moral authority

01:01:03,760 --> 01:01:12,020
answering questions giving classes many

01:01:08,300 --> 01:01:17,150
people who are many of the managers at

01:01:12,020 --> 01:01:19,970
Bloomberg are protégées of John who have

01:01:17,150 --> 01:01:21,650
learned under him and agree with many of

01:01:19,970 --> 01:01:24,770
his methods and so they have it has

01:01:21,650 --> 01:01:27,020
proliferated different degrees of

01:01:24,770 --> 01:01:28,610
strictness are applied in different

01:01:27,020 --> 01:01:31,300
levels the BDE

01:01:28,610 --> 01:01:34,010
methodology is very time intensive and

01:01:31,300 --> 01:01:37,040
it is justified by the fact that we are

01:01:34,010 --> 01:01:39,320
writing code at the bottom of the of the

01:01:37,040 --> 01:01:43,910
software stack that's going to be reused

01:01:39,320 --> 01:01:46,730
very heavily so you know not people that

01:01:43,910 --> 01:01:49,070
are higher up that the stack can't make

01:01:46,730 --> 01:01:51,350
that same justice you know you know they

01:01:49,070 --> 01:02:04,400
have to cut corners we understand that

01:01:51,350 --> 01:02:07,090
oh all right I'm sorry I didn't get to

01:02:04,400 --> 01:02:07,090
your question

01:02:12,590 --> 01:02:20,250
which we spend about half our time on

01:02:16,230 --> 01:02:24,750
Doc have fun testing half on development

01:02:20,250 --> 01:02:30,650
half on design yeah yeah yeah you get

01:02:24,750 --> 01:02:30,650

YouTube URL: https://www.youtube.com/watch?v=Iess36CZnPI


