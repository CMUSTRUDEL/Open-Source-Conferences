Title: CppCon 2016: James McNellis “Introduction to C++ Coroutines"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
One of the most interesting new features being proposed for C++ standardization is coroutines, formerly known as “resumable functions”. C++ coroutines are designed to be highly scalable, highly efficient (no overhead), and highly extensible, while still interacting seamlessly with the rest of the C++ language.

This session will consist of an in-depth introduction to C++ coroutines. We will begin by looking at the rationale for adding coroutines to the C++ language. We will then demonstrate and explain a sequence of coroutines that gradually introduce the features of C++ coroutines. This part of the talk will show both how to write various forms of coroutines and also how the coroutines extensibility model enables existing libraries to be non-invasively adapted to work with C++ coroutines.
— 
James McNellis
Senior Software Engineer, Microsoft Visual C++
James McNellis is a senior engineer on the Visual C++ team at Microsoft, where he works on C++ library design and is responsible for the Microsoft C Runtime (CRT) and C Standard Library implementation. He can be found on Twitter at @JamesMcNellis and can be found elsewhere online via http://www.jamesmcnellis.com.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,319
so good morning everyone can everyone

00:00:01,890 --> 00:00:08,250
hear me I hope excellent can everyone

00:00:04,319 --> 00:00:10,920
see the slides okay so my name is James

00:00:08,250 --> 00:00:12,780
McNellis I'm a member of the visual C++

00:00:10,920 --> 00:00:14,880
team at Microsoft and I'm going to give

00:00:12,780 --> 00:00:17,250
an introduction to the C++ Cortines

00:00:14,880 --> 00:00:19,050
feature today just a few notes before we

00:00:17,250 --> 00:00:21,390
begin so this feature is still in

00:00:19,050 --> 00:00:24,390
development it's not yet standardized I

00:00:21,390 --> 00:00:25,560
will not be part of C++ 17 but it is

00:00:24,390 --> 00:00:29,269
going to be part of a technical

00:00:25,560 --> 00:00:32,460
specification that should be done soon

00:00:29,269 --> 00:00:35,430
I'm here to describe the current

00:00:32,460 --> 00:00:37,649
proposal not to argue about you know one

00:00:35,430 --> 00:00:39,930
particular design versus another though

00:00:37,649 --> 00:00:42,870
I'd be happy to do that outside you know

00:00:39,930 --> 00:00:46,649
after the talk so with that out of the

00:00:42,870 --> 00:00:48,600
way just one brief thing so our team the

00:00:46,649 --> 00:00:50,640
visual C++ team is very interested in

00:00:48,600 --> 00:00:53,850
your feedback in you know learning a bit

00:00:50,640 --> 00:00:55,350
about how you use C++ and so if you

00:00:53,850 --> 00:00:58,170
would like an opportunity to win an Xbox

00:00:55,350 --> 00:01:00,210
1s we've got a survey here and I'll have

00:00:58,170 --> 00:01:01,949
the link at the end of the talk as well

00:01:00,210 --> 00:01:04,049
I've been told that I am not allowed to

00:01:01,949 --> 00:01:08,100
win it so I want all of you to try and

00:01:04,049 --> 00:01:10,700
you know have that opportunity so to

00:01:08,100 --> 00:01:10,700
start off here

00:01:10,920 --> 00:01:15,390
what's the motivation for this feature

00:01:12,479 --> 00:01:17,250
so why add co-routines at all you know a

00:01:15,390 --> 00:01:19,380
lot of effort has gone into adding this

00:01:17,250 --> 00:01:21,240
to the language a lot of design work I

00:01:19,380 --> 00:01:25,290
don't know if it's quite as much design

00:01:21,240 --> 00:01:27,960
work as went into the digit separators

00:01:25,290 --> 00:01:29,640
but it has been it has been a

00:01:27,960 --> 00:01:31,950
substantial lot of work so what do we

00:01:29,640 --> 00:01:33,869
gain from adding co-routines to the C++

00:01:31,950 --> 00:01:36,150
language and to demonstrate that I'm

00:01:33,869 --> 00:01:38,070
going to use an example that I've lifted

00:01:36,150 --> 00:01:42,439
from a presentation gore gave here last

00:01:38,070 --> 00:01:45,450
year from his talk so here we have a

00:01:42,439 --> 00:01:47,670
little synchronous function in this

00:01:45,450 --> 00:01:49,890
function we have let's say a TCP library

00:01:47,670 --> 00:01:52,350
and it establishes a connection to a TCP

00:01:49,890 --> 00:01:53,880
server and then in a loop it reads for K

00:01:52,350 --> 00:01:55,170
chunks from that connection until either

00:01:53,880 --> 00:01:57,719
it's read the number of bytes that were

00:01:55,170 --> 00:01:59,340
requested or it reaches the end of the

00:01:57,719 --> 00:02:00,600
stream and then it returns how many

00:01:59,340 --> 00:02:03,689
bytes were remaining that it did not

00:02:00,600 --> 00:02:06,060
read so this is a synchronous program

00:02:03,689 --> 00:02:07,829
the call to TCP Connect is going to

00:02:06,060 --> 00:02:09,569
block until it establishes the

00:02:07,829 --> 00:02:11,310
connection and then each of those calls

00:02:09,569 --> 00:02:13,410
to read inside the loop is going to

00:02:11,310 --> 00:02:15,180
block until the read completes

00:02:13,410 --> 00:02:16,380
and note that in reality within that

00:02:15,180 --> 00:02:19,110
loop we would actually be doing some

00:02:16,380 --> 00:02:22,110
data processing which we've just emitted

00:02:19,110 --> 00:02:23,790
here for brevity so since these

00:02:22,110 --> 00:02:25,170
operations may take a long time we don't

00:02:23,790 --> 00:02:27,240
really want to block write we want to

00:02:25,170 --> 00:02:29,250
take we want to tell the Machine hey go

00:02:27,240 --> 00:02:31,080
establish a TCP connection for us and

00:02:29,250 --> 00:02:33,210
when it's ready let us know so that we

00:02:31,080 --> 00:02:35,610
can continue with the program and then

00:02:33,210 --> 00:02:38,010
hey go read four kilobytes of data from

00:02:35,610 --> 00:02:39,450
that stream and when you have them let

00:02:38,010 --> 00:02:42,150
us know so that we can use them and

00:02:39,450 --> 00:02:43,290
continue on in order to do that we're

00:02:42,150 --> 00:02:45,300
going to have to turn this into an

00:02:43,290 --> 00:02:46,080
asynchronous program and to do that

00:02:45,300 --> 00:02:49,320
we're going to have to make a few

00:02:46,080 --> 00:02:50,970
changes so the first change is to the

00:02:49,320 --> 00:02:52,320
signature of the function instead of

00:02:50,970 --> 00:02:54,300
returning an integer we're going to have

00:02:52,320 --> 00:02:55,800
to return a future of the integer

00:02:54,300 --> 00:02:59,640
because we're not going to have the

00:02:55,800 --> 00:03:00,900
value when our function returns next

00:02:59,640 --> 00:03:02,850
we're going to have to wrap up all of

00:03:00,900 --> 00:03:04,650
our state into a little structure so

00:03:02,850 --> 00:03:06,720
that we can pass it around between the

00:03:04,650 --> 00:03:08,910
parts of the asynchronous operation and

00:03:06,720 --> 00:03:10,380
because that that state is going to

00:03:08,910 --> 00:03:11,730
outlive the frame of the function we're

00:03:10,380 --> 00:03:14,850
going to have to dynamically allocate

00:03:11,730 --> 00:03:16,140
that on the heat then we're going to

00:03:14,850 --> 00:03:17,790
establish the connection and we'll

00:03:16,140 --> 00:03:19,800
assume that our off the author of our

00:03:17,790 --> 00:03:21,780
TCP library is very helpfully giving us

00:03:19,800 --> 00:03:23,690
a nice asynchronous API to replace the

00:03:21,780 --> 00:03:25,770
synchronous one we were using before and

00:03:23,690 --> 00:03:27,600
when the connection is established we'll

00:03:25,770 --> 00:03:30,930
say okay call this continuation and

00:03:27,600 --> 00:03:33,300
we'll use it so then inside of that

00:03:30,930 --> 00:03:36,350
continuation we're going to enter a loop

00:03:33,300 --> 00:03:38,820
the same read loop that we had before

00:03:36,350 --> 00:03:41,010
within there we're going to actually go

00:03:38,820 --> 00:03:42,570
and do the reads

00:03:41,010 --> 00:03:44,660
so each iteration in the loop we're

00:03:42,570 --> 00:03:49,260
going to read from the connection and

00:03:44,660 --> 00:03:50,970
then each time the the TCP library has

00:03:49,260 --> 00:03:54,709
data for us it's going to call us back

00:03:50,970 --> 00:03:56,640
and let us know the state that we have

00:03:54,709 --> 00:03:58,350
there's still a little bit of magic here

00:03:56,640 --> 00:04:00,660
this do-while function is not part of

00:03:58,350 --> 00:04:03,239
the standard library but we can

00:04:00,660 --> 00:04:04,830
implement it rather simply so how many

00:04:03,239 --> 00:04:08,640
people think this is just as simple and

00:04:04,830 --> 00:04:09,810
good as the synchronous program how many

00:04:08,640 --> 00:04:12,840
people would like to write code like

00:04:09,810 --> 00:04:15,239
this how many people are stuck having to

00:04:12,840 --> 00:04:18,480
write code like this today yeah okay

00:04:15,239 --> 00:04:22,750
there we go so there's actually a bug in

00:04:18,480 --> 00:04:27,460
this slide can anyone

00:04:22,750 --> 00:04:30,490
can anyone see it yeah Gore can see it

00:04:27,460 --> 00:04:32,020
see I can't call on Gore last year when

00:04:30,490 --> 00:04:35,980
he gave this talk I raised my hand

00:04:32,020 --> 00:04:38,380
because I'm an idiot so if we look again

00:04:35,980 --> 00:04:42,010
at our synchronous program we've

00:04:38,380 --> 00:04:43,600
forgotten to return the result so we

00:04:42,010 --> 00:04:46,060
just need to add one little line of code

00:04:43,600 --> 00:04:51,130
here to return the result anybody like

00:04:46,060 --> 00:04:52,570
to guess we're not you've gar well we

00:04:51,130 --> 00:04:54,340
just need one more continuation and when

00:04:52,570 --> 00:04:57,580
we're done with this entire loop we will

00:04:54,340 --> 00:05:00,340
return the results in a ready future so

00:04:57,580 --> 00:05:04,870
simple yeah this is great why are we

00:05:00,340 --> 00:05:05,740
doing this co-routines thing not really

00:05:04,870 --> 00:05:08,140
that's pretty horrible

00:05:05,740 --> 00:05:10,180
so our asynchronous code ended up being

00:05:08,140 --> 00:05:12,010
a lot like regular expressions you may

00:05:10,180 --> 00:05:13,720
be able to write the code that does the

00:05:12,010 --> 00:05:16,300
right thing though not entirely sure

00:05:13,720 --> 00:05:18,010
about that and even if you do it's going

00:05:16,300 --> 00:05:23,920
to be hard to maintain and modify and

00:05:18,010 --> 00:05:25,300
even worse to debug so what if this is

00:05:23,920 --> 00:05:26,140
our synchronous program again with a

00:05:25,300 --> 00:05:28,900
little bit of whitespace

00:05:26,140 --> 00:05:30,970
added to it what if we could write code

00:05:28,900 --> 00:05:33,640
that looks just like this but actually

00:05:30,970 --> 00:05:36,520
has the behavior or similar behavior to

00:05:33,640 --> 00:05:37,570
that asynchronous program and the answer

00:05:36,520 --> 00:05:40,600
is with co-routines

00:05:37,570 --> 00:05:43,570
we can and so what do we need to do to

00:05:40,600 --> 00:05:48,580
make this program asynchronous here we

00:05:43,570 --> 00:05:50,770
go three changes if you didn't see them

00:05:48,580 --> 00:05:52,300
here they are in red so we've had to

00:05:50,770 --> 00:05:54,370
change the return type of a function to

00:05:52,300 --> 00:05:55,690
a stood future of integer because again

00:05:54,370 --> 00:05:58,000
we're not going to have the result when

00:05:55,690 --> 00:05:59,919
we return immediately then we've had to

00:05:58,000 --> 00:06:01,180
add this code weight keyword and we're

00:05:59,919 --> 00:06:02,770
going to spend most of the rest of this

00:06:01,180 --> 00:06:06,180
talk explaining what that keyword does

00:06:02,770 --> 00:06:08,950
and how it works so this program now has

00:06:06,180 --> 00:06:11,169
effectively the same behavior with

00:06:08,950 --> 00:06:12,669
respect to the asynchronous API that we

00:06:11,169 --> 00:06:15,250
had in the other asynchronous program

00:06:12,669 --> 00:06:16,300
it's just an awful lot simpler so how

00:06:15,250 --> 00:06:18,940
many people think this is a little

00:06:16,300 --> 00:06:20,320
better than the than the other example

00:06:18,940 --> 00:06:23,850
yeah okay

00:06:20,320 --> 00:06:28,270
that's basically everybody in the room

00:06:23,850 --> 00:06:32,590
so let's start with some basics what is

00:06:28,270 --> 00:06:35,800
a KO routine so a KO routine is a

00:06:32,590 --> 00:06:38,400
generalization of a subroutine well

00:06:35,800 --> 00:06:40,780
okay so what is a subroutine a

00:06:38,400 --> 00:06:42,550
subroutine has two properties so it's a

00:06:40,780 --> 00:06:44,860
thing that can be invoked by its caller

00:06:42,550 --> 00:06:46,810
and it can return control back to its

00:06:44,860 --> 00:06:49,449
caller so hopefully everyone is familiar

00:06:46,810 --> 00:06:52,210
with a particular type of subroutine in

00:06:49,449 --> 00:06:53,650
C++ it's called a function so you can

00:06:52,210 --> 00:06:55,090
call a function and then when the

00:06:53,650 --> 00:06:56,770
function is done doing whatever it was

00:06:55,090 --> 00:06:58,479
doing it's able to return control back

00:06:56,770 --> 00:07:01,389
to you so that you can continue doing

00:06:58,479 --> 00:07:03,220
other work a cur routine also has these

00:07:01,389 --> 00:07:06,069
properties but also has two other

00:07:03,220 --> 00:07:08,530
properties it can suspend execution and

00:07:06,069 --> 00:07:10,840
return control back to you and then your

00:07:08,530 --> 00:07:15,580
caller can resume you and you will pick

00:07:10,840 --> 00:07:17,169
up where you left off so with the C++

00:07:15,580 --> 00:07:18,879
code routine specification both

00:07:17,169 --> 00:07:21,159
subroutines and Co routines are

00:07:18,879 --> 00:07:25,000
functions and the function can be either

00:07:21,159 --> 00:07:27,340
a subroutine or a Co routine so I put

00:07:25,000 --> 00:07:29,590
this little helpful table here and

00:07:27,340 --> 00:07:31,300
you'll see we have the four different

00:07:29,590 --> 00:07:33,340
operations and four subroutines we only

00:07:31,300 --> 00:07:34,900
have two of those we have in order to

00:07:33,340 --> 00:07:37,259
invoke a subroutine we make the function

00:07:34,900 --> 00:07:39,190
call in order to return from the

00:07:37,259 --> 00:07:40,810
subroutine we either use a return

00:07:39,190 --> 00:07:43,810
statement or we just fall off the end of

00:07:40,810 --> 00:07:45,699
us of this function for a KO routine we

00:07:43,810 --> 00:07:48,069
invoke it exactly the same way we just

00:07:45,699 --> 00:07:49,960
make the function call we return using

00:07:48,069 --> 00:07:52,210
this special ko return statement which

00:07:49,960 --> 00:07:54,699
we'll look at and then we suspend

00:07:52,210 --> 00:07:56,380
execution using KO await and we'll look

00:07:54,699 --> 00:08:01,150
a little bit later at how we how we

00:07:56,380 --> 00:08:03,009
resume what makes a function occur

00:08:01,150 --> 00:08:05,050
routine so here we have a function

00:08:03,009 --> 00:08:06,550
declaration how many people here thinks

00:08:05,050 --> 00:08:10,060
that think that this function is a KO

00:08:06,550 --> 00:08:16,690
routine okay how many think this is not

00:08:10,060 --> 00:08:18,909
a KO routine okay so it may be or it may

00:08:16,690 --> 00:08:20,590
not be whether a function is a KO

00:08:18,909 --> 00:08:22,210
routine is an implementation detail of

00:08:20,590 --> 00:08:23,770
the function so if you have a function

00:08:22,210 --> 00:08:25,449
today and you want to turn it into a KO

00:08:23,770 --> 00:08:27,909
routine you can do so without breaking

00:08:25,449 --> 00:08:29,770
any of your callers it has no effect on

00:08:27,909 --> 00:08:31,719
the function declaration at all there

00:08:29,770 --> 00:08:33,250
may be some return types that only make

00:08:31,719 --> 00:08:35,529
sense to use with co-routines

00:08:33,250 --> 00:08:37,240
but stood future is not one of those so

00:08:35,529 --> 00:08:38,740
for for example you can implement a

00:08:37,240 --> 00:08:40,599
function that returns to the future

00:08:38,740 --> 00:08:44,199
either as a KO routine or as a

00:08:40,599 --> 00:08:45,970
subroutine so what makes a function of

00:08:44,199 --> 00:08:48,970
Co routine well a cur routine function a

00:08:45,970 --> 00:08:49,630
function is a Co routine if it contains

00:08:48,970 --> 00:08:51,490
a

00:08:49,630 --> 00:08:54,160
return statement a code weight

00:08:51,490 --> 00:08:56,710
expression a KO yield expression or a

00:08:54,160 --> 00:08:59,860
range based for you loop that uses KO

00:08:56,710 --> 00:09:01,240
await or in short a curve a function is

00:08:59,860 --> 00:09:03,220
occur routine if it does care routine

00:09:01,240 --> 00:09:07,270
things or if it if it's capable of

00:09:03,220 --> 00:09:08,890
suspending so here is that compute value

00:09:07,270 --> 00:09:10,990
function I have two different

00:09:08,890 --> 00:09:12,700
definitions of it the one on the left is

00:09:10,990 --> 00:09:15,550
just a normal function you can write

00:09:12,700 --> 00:09:17,650
this today in C++ 11 you can see that it

00:09:15,550 --> 00:09:19,990
calls stood async to go and run you know

00:09:17,650 --> 00:09:21,940
this very expensive task on a background

00:09:19,990 --> 00:09:24,070
thread and then return you a future that

00:09:21,940 --> 00:09:27,760
refers to it and on the right we have

00:09:24,070 --> 00:09:29,530
the same function implemented as a as a

00:09:27,760 --> 00:09:31,660
KO routine and it uses this KO await

00:09:29,530 --> 00:09:37,300
which to get the result and then ko

00:09:31,660 --> 00:09:40,480
return to return the result so what does

00:09:37,300 --> 00:09:42,160
this code weight actually do well the

00:09:40,480 --> 00:09:44,260
compiler takes the KO weight expression

00:09:42,160 --> 00:09:46,930
and it transforms it into a slightly

00:09:44,260 --> 00:09:48,910
different code and this is the code that

00:09:46,930 --> 00:09:50,920
it ends up generating so first it take

00:09:48,910 --> 00:09:53,350
that expression and it stashes it in a

00:09:50,920 --> 00:09:56,260
you know a fake little variable said it

00:09:53,350 --> 00:09:58,270
can refer to it and then it asks the

00:09:56,260 --> 00:09:59,710
thing well are you already ready and it

00:09:58,270 --> 00:10:02,560
does this by calling the await ready

00:09:59,710 --> 00:10:04,030
function and if the if the thing is

00:10:02,560 --> 00:10:05,320
already ready if it already has the

00:10:04,030 --> 00:10:08,640
result that it needs then it's not going

00:10:05,320 --> 00:10:11,380
to go through the expense of suspending

00:10:08,640 --> 00:10:13,000
if it's not yet ready then it's going to

00:10:11,380 --> 00:10:14,560
call this await suspend function which

00:10:13,000 --> 00:10:16,360
allows you to customize the but whatever

00:10:14,560 --> 00:10:18,790
happens right before you suspend and

00:10:16,360 --> 00:10:21,370
then when that returns you're going to

00:10:18,790 --> 00:10:23,140
reach a suspend point and it's going to

00:10:21,370 --> 00:10:25,870
suspend execution of function and return

00:10:23,140 --> 00:10:27,880
controller back to the caller later if

00:10:25,870 --> 00:10:29,590
and when the caller decides to resume

00:10:27,880 --> 00:10:31,420
you you will pick up right where you

00:10:29,590 --> 00:10:32,980
left off right there and you'll continue

00:10:31,420 --> 00:10:35,260
on with the program and get to the next

00:10:32,980 --> 00:10:36,910
line it's going to call them this a

00:10:35,260 --> 00:10:38,830
weight resume function which allows you

00:10:36,910 --> 00:10:41,050
to do two things first it allows you to

00:10:38,830 --> 00:10:43,690
custom custom action when you've resumed

00:10:41,050 --> 00:10:45,670
and second it actually returns the value

00:10:43,690 --> 00:10:47,230
that is the result of that expression so

00:10:45,670 --> 00:10:51,040
the result here is going to be the

00:10:47,230 --> 00:10:53,290
result of that call to await resume so

00:10:51,040 --> 00:10:55,660
from this we can see that in order to

00:10:53,290 --> 00:10:58,210
await on something it has to provide

00:10:55,660 --> 00:11:00,910
three different functions basically it

00:10:58,210 --> 00:11:03,300
has to provide await ready await suspend

00:11:00,910 --> 00:11:06,519
and await resume

00:11:03,300 --> 00:11:09,459
so let's look at a really complex type

00:11:06,519 --> 00:11:10,990
that implements these so this one is

00:11:09,459 --> 00:11:13,990
called suspend always and it's part of

00:11:10,990 --> 00:11:15,910
the library support for co-routines it's

00:11:13,990 --> 00:11:18,149
very simple all it does is when you

00:11:15,910 --> 00:11:20,709
await this it will suspend the function

00:11:18,149 --> 00:11:22,569
so you can see here the await ready

00:11:20,709 --> 00:11:24,670
returns false saying I don't have the

00:11:22,569 --> 00:11:26,110
value so you need to suspend and then we

00:11:24,670 --> 00:11:30,490
don't have to do anything on the await

00:11:26,110 --> 00:11:32,410
suspend and a wait resume and here is a

00:11:30,490 --> 00:11:34,690
KO routine that uses this so if you call

00:11:32,410 --> 00:11:36,970
my Co routine it will print out my ko

00:11:34,690 --> 00:11:39,550
routine is about to suspend it will then

00:11:36,970 --> 00:11:40,930
co await on this suspend always and this

00:11:39,550 --> 00:11:44,769
will suspend the Co routine it will

00:11:40,930 --> 00:11:46,120
return control back to the caller if and

00:11:44,769 --> 00:11:48,160
when the caller decides it wants to

00:11:46,120 --> 00:11:49,720
resume the KO routine then the ko

00:11:48,160 --> 00:11:51,819
routine will pick off where it left off

00:11:49,720 --> 00:11:55,870
and it will then print my cover team was

00:11:51,819 --> 00:11:58,240
resumed there's another simple away

00:11:55,870 --> 00:12:00,490
table type called suspend never and this

00:11:58,240 --> 00:12:01,899
one just does not suspend so you can see

00:12:00,490 --> 00:12:05,470
instead of returning false from wait

00:12:01,899 --> 00:12:07,930
ready we return true and we can look at

00:12:05,470 --> 00:12:09,819
a program that uses this one too so here

00:12:07,930 --> 00:12:11,410
my ko routine if you call it it will

00:12:09,819 --> 00:12:13,540
print out my Co routine before the no

00:12:11,410 --> 00:12:16,269
Appa wait it will then await on the

00:12:13,540 --> 00:12:17,260
suspend never which will not suspend and

00:12:16,269 --> 00:12:19,930
the KO routine will just continue

00:12:17,260 --> 00:12:22,300
execution and then it will print out my

00:12:19,930 --> 00:12:24,160
ko routine after the no Appa wait so

00:12:22,300 --> 00:12:25,600
here the caller does not get the

00:12:24,160 --> 00:12:30,069
opportunity to resume the KO routine

00:12:25,600 --> 00:12:31,930
because it never actually suspends so

00:12:30,069 --> 00:12:33,610
that's the first half when a KO routine

00:12:31,930 --> 00:12:36,160
is executing it uses this KO await

00:12:33,610 --> 00:12:39,610
expression to suspend itself potentially

00:12:36,160 --> 00:12:41,410
and return control to the caller so the

00:12:39,610 --> 00:12:43,839
other half is how does the caller resume

00:12:41,410 --> 00:12:46,420
a cover teen and the answer that we have

00:12:43,839 --> 00:12:50,170
to look at how co-routines actually work

00:12:46,420 --> 00:12:51,519
under the covers so what happens when

00:12:50,170 --> 00:12:53,050
you invoke a function well when you

00:12:51,519 --> 00:12:55,779
invoke a function the compiler has to

00:12:53,050 --> 00:12:57,040
construct a stack frame on the stack and

00:12:55,779 --> 00:12:58,839
this includes space for all the

00:12:57,040 --> 00:13:00,370
arguments local variables the return

00:12:58,839 --> 00:13:02,380
value temporary storage for any

00:13:00,370 --> 00:13:05,800
registers if it needs to spill registers

00:13:02,380 --> 00:13:06,939
onto the stack but all of this happens

00:13:05,800 --> 00:13:09,639
behind the scenes you don't need to

00:13:06,939 --> 00:13:12,130
worry about this similarly when you

00:13:09,639 --> 00:13:13,689
invoke a KO routine the compiler has to

00:13:12,130 --> 00:13:15,160
construct a KO routine frame that

00:13:13,689 --> 00:13:16,870
contains space for all the formal

00:13:15,160 --> 00:13:19,540
parameters the local variables

00:13:16,870 --> 00:13:21,730
selected temporaries it also needs to

00:13:19,540 --> 00:13:23,470
have space though for the execution

00:13:21,730 --> 00:13:25,089
state for when it suspends when you

00:13:23,470 --> 00:13:26,589
suspend a Co routine it has to store any

00:13:25,089 --> 00:13:29,560
state that it's going to need to restore

00:13:26,589 --> 00:13:31,210
when you resume the Co routine and it's

00:13:29,560 --> 00:13:33,160
also going to have to store the promise

00:13:31,210 --> 00:13:35,920
which is the object that is used to

00:13:33,160 --> 00:13:40,750
basically communicate between the Co

00:13:35,920 --> 00:13:42,190
routine and the caller in general the Co

00:13:40,750 --> 00:13:44,500
routine frame must be dynamically

00:13:42,190 --> 00:13:46,660
allocated so the co routine loses

00:13:44,500 --> 00:13:48,400
control of the stack when it is

00:13:46,660 --> 00:13:49,810
suspended so it returns to its caller

00:13:48,400 --> 00:13:51,790
and the caller could call some other

00:13:49,810 --> 00:13:53,940
function and use any stack space that

00:13:51,790 --> 00:13:57,040
the cover team might have wanted to use

00:13:53,940 --> 00:13:58,960
operator new is used by default but this

00:13:57,040 --> 00:14:01,350
can be overloaded for specific

00:13:58,960 --> 00:14:04,600
co-routines to allow customization

00:14:01,350 --> 00:14:06,520
additionally the compiler may be able to

00:14:04,600 --> 00:14:08,500
eliminate the dynamic allocation if it's

00:14:06,520 --> 00:14:09,850
able to determine well the Co routine is

00:14:08,500 --> 00:14:11,290
not going to escape from the callers

00:14:09,850 --> 00:14:13,150
frame and so I can allocate it on the

00:14:11,290 --> 00:14:14,770
stack so the compiler is free to

00:14:13,150 --> 00:14:16,240
optimize there and it will do that and

00:14:14,770 --> 00:14:17,950
if you go to Gore's talk this afternoon

00:14:16,240 --> 00:14:21,970
you will learn that it will do that

00:14:17,950 --> 00:14:23,980
aggressively finally creation of this

00:14:21,970 --> 00:14:25,540
curve routine frame occurs before the

00:14:23,980 --> 00:14:27,070
co-routine starts running so it's just

00:14:25,540 --> 00:14:28,180
like creation of a stack frame not

00:14:27,070 --> 00:14:32,589
something you have to worry about it

00:14:28,180 --> 00:14:33,820
just happens there in the background and

00:14:32,589 --> 00:14:35,620
what the compiler will do is it will

00:14:33,820 --> 00:14:37,150
return and I put in quotes because it

00:14:35,620 --> 00:14:39,040
doesn't actually return it in the sense

00:14:37,150 --> 00:14:40,959
of using a return statement it will

00:14:39,040 --> 00:14:44,650
return a handle to this co-routine frame

00:14:40,959 --> 00:14:46,990
to the caller of the co routine so what

00:14:44,650 --> 00:14:48,730
does this handle look like well there's

00:14:46,990 --> 00:14:52,180
two types or it's one type that's

00:14:48,730 --> 00:14:54,670
specialized so the first is a cur

00:14:52,180 --> 00:14:56,830
routine handle of void and this has all

00:14:54,670 --> 00:14:58,930
of the basic curtain handle

00:14:56,830 --> 00:15:00,490
functionality and it's used for Co

00:14:58,930 --> 00:15:01,930
routines that do not pass objects back

00:15:00,490 --> 00:15:04,660
to their collars so kind of like a

00:15:01,930 --> 00:15:06,310
function that returns void and then

00:15:04,660 --> 00:15:07,600
there's the Co routine handle for all of

00:15:06,310 --> 00:15:10,300
the other types of things that you might

00:15:07,600 --> 00:15:11,920
need to return and this is derived from

00:15:10,300 --> 00:15:13,480
the curtain handle of void this is to

00:15:11,920 --> 00:15:14,950
provide simple Interop but it's also

00:15:13,480 --> 00:15:19,209
because it needs all of those operations

00:15:14,950 --> 00:15:20,560
and it'll provide a few more things so

00:15:19,209 --> 00:15:23,350
here's what the curtain handle of void

00:15:20,560 --> 00:15:25,270
looks like first it's possible to have

00:15:23,350 --> 00:15:27,610
an empty co-routine handle that refers

00:15:25,270 --> 00:15:28,870
to no ko routine and so the default

00:15:27,610 --> 00:15:30,170
constructor will give you one of those

00:15:28,870 --> 00:15:32,240
you can construct it from an

00:15:30,170 --> 00:15:34,670
put er you can assign and I'll put our

00:15:32,240 --> 00:15:36,709
to a co-routine handle and you know then

00:15:34,670 --> 00:15:38,720
it has an empty state and there's an a

00:15:36,709 --> 00:15:40,519
conversion to pool that lets you test

00:15:38,720 --> 00:15:42,190
whether or not the co-routine handle is

00:15:40,519 --> 00:15:44,510
empty

00:15:42,190 --> 00:15:47,029
second you can convert a care routine

00:15:44,510 --> 00:15:48,680
handle to of white star and then convert

00:15:47,029 --> 00:15:50,600
a void star back into a care routine

00:15:48,680 --> 00:15:52,880
handle so this is to enable interrupt

00:15:50,600 --> 00:15:56,029
with for example capi so there are many

00:15:52,880 --> 00:15:57,769
thread api's that allow you to pass in a

00:15:56,029 --> 00:15:59,690
function pointer that will be called and

00:15:57,769 --> 00:16:01,190
then a context pointer and so this

00:15:59,690 --> 00:16:02,630
allows you to convert to a void star

00:16:01,190 --> 00:16:04,490
that you can pass as that context

00:16:02,630 --> 00:16:06,199
pointer and then on the other side take

00:16:04,490 --> 00:16:08,329
that context pointer convert it back to

00:16:06,199 --> 00:16:10,389
a a KO routine handle so you can invoke

00:16:08,329 --> 00:16:10,389
it

00:16:10,720 --> 00:16:15,290
third the co routine handle provides the

00:16:13,100 --> 00:16:17,000
ability to resume execution of the of

00:16:15,290 --> 00:16:19,130
the cut routine and so you can do this

00:16:17,000 --> 00:16:21,529
either by calling resume or by invoking

00:16:19,130 --> 00:16:25,850
this function call operator they do the

00:16:21,529 --> 00:16:27,440
same thing fourth the care routine

00:16:25,850 --> 00:16:29,389
handle provides the ability to destroy

00:16:27,440 --> 00:16:31,699
the co routine explicitly before

00:16:29,389 --> 00:16:33,290
finishes executing so this will call

00:16:31,699 --> 00:16:35,269
this will cause all of its local

00:16:33,290 --> 00:16:37,010
variables to be destroyed as if a return

00:16:35,269 --> 00:16:39,170
statement was evaluated in the

00:16:37,010 --> 00:16:40,760
co-routine and this happens at the point

00:16:39,170 --> 00:16:41,750
that the cover team was last suspended

00:16:40,760 --> 00:16:43,130
and we'll see some more detailed

00:16:41,750 --> 00:16:47,029
examples of that a little bit later

00:16:43,130 --> 00:16:48,620
and finally the curtain handle provides

00:16:47,029 --> 00:16:50,870
the ability to test whether the co

00:16:48,620 --> 00:16:55,940
routine has completed execution it's

00:16:50,870 --> 00:16:58,040
just called done so in the other so then

00:16:55,940 --> 00:16:59,329
the other the specialization of care

00:16:58,040 --> 00:17:02,029
routine handle for all the other types

00:16:59,329 --> 00:17:04,010
just adds two extra pieces of

00:17:02,029 --> 00:17:05,600
functionality first it gives you the

00:17:04,010 --> 00:17:06,919
ability to get the promise back and

00:17:05,600 --> 00:17:08,480
again the promise is the thing that

00:17:06,919 --> 00:17:11,959
allows you to communicate between the co

00:17:08,480 --> 00:17:14,360
routine and the caller and second given

00:17:11,959 --> 00:17:16,490
the promise it allows you to get the co

00:17:14,360 --> 00:17:19,160
routine handle for the co routine from

00:17:16,490 --> 00:17:19,760
which that promise to which that promise

00:17:19,160 --> 00:17:21,919
belongs

00:17:19,760 --> 00:17:23,750
since the promise is part of the co

00:17:21,919 --> 00:17:25,459
routine frame that was allocated the

00:17:23,750 --> 00:17:26,990
compiler knows how to generate this such

00:17:25,459 --> 00:17:31,520
that it gives you the correct co-routine

00:17:26,990 --> 00:17:33,320
handle address okay that's enough of

00:17:31,520 --> 00:17:37,910
that so let's build a really simple chi

00:17:33,320 --> 00:17:40,429
routine so here is a co routine and it's

00:17:37,910 --> 00:17:43,390
got this resumable thing return type and

00:17:40,429 --> 00:17:45,100
we're going to implement that and they

00:17:43,390 --> 00:17:47,620
tickley what this function does is it'll

00:17:45,100 --> 00:17:49,690
let you know hello I was called and then

00:17:47,620 --> 00:17:51,190
within a loop it's going to suspend each

00:17:49,690 --> 00:17:52,570
time through the loop and each time it's

00:17:51,190 --> 00:17:54,040
resumed it's just going to print out to

00:17:52,570 --> 00:17:57,640
tell you how many times the care routine

00:17:54,040 --> 00:18:01,120
has been resumed and here's a main

00:17:57,640 --> 00:18:03,310
function that uses it so we can see here

00:18:01,120 --> 00:18:04,570
if we run this program first the main

00:18:03,310 --> 00:18:07,120
function will print while I'm going to

00:18:04,570 --> 00:18:08,380
call this counter function and then we

00:18:07,120 --> 00:18:11,710
call it and the counter will let you

00:18:08,380 --> 00:18:13,330
know okay I was called and the main will

00:18:11,710 --> 00:18:17,370
let you know okay I'm about to resume

00:18:13,330 --> 00:18:20,620
the co routine it resumes it once and

00:18:17,370 --> 00:18:21,580
then twice and then the main function

00:18:20,620 --> 00:18:25,780
will print out and just let you know

00:18:21,580 --> 00:18:26,860
okay I've reached the end I'm done so

00:18:25,780 --> 00:18:31,990
what do we have to do to implement this

00:18:26,860 --> 00:18:32,920
resumable thing so the first thing we're

00:18:31,990 --> 00:18:34,570
going to need is we're going to need to

00:18:32,920 --> 00:18:36,340
define a promise type for it and this is

00:18:34,570 --> 00:18:38,830
going to be that type that is used under

00:18:36,340 --> 00:18:42,190
the covers to communicate between the

00:18:38,830 --> 00:18:43,360
co-routine and the caller within the

00:18:42,190 --> 00:18:45,160
resumable thing we're going to need to

00:18:43,360 --> 00:18:48,850
store the handle to the co-routine so

00:18:45,160 --> 00:18:50,080
that we can resume it its constructor is

00:18:48,850 --> 00:18:52,090
actually just going to take that and

00:18:50,080 --> 00:18:54,010
we'll see how we construct that in a

00:18:52,090 --> 00:18:55,360
moment and then in the destructor we're

00:18:54,010 --> 00:18:56,920
going to we're going to call destroy

00:18:55,360 --> 00:18:58,360
because again in that function we will

00:18:56,920 --> 00:19:01,510
never actually reach the end so we're

00:18:58,360 --> 00:19:02,710
going to need to destroy it somewhere we

00:19:01,510 --> 00:19:04,420
have a bit of boilerplate that we need

00:19:02,710 --> 00:19:06,640
to do so here you see we have the

00:19:04,420 --> 00:19:08,530
default default constructor and then we

00:19:06,640 --> 00:19:10,900
do not allow copying but we do allow

00:19:08,530 --> 00:19:12,220
moving from one instance to another the

00:19:10,900 --> 00:19:13,690
co-routine handle type doesn't provide

00:19:12,220 --> 00:19:15,940
any sort of lifetime management it's

00:19:13,690 --> 00:19:17,320
just like a raw pointer that's exactly

00:19:15,940 --> 00:19:19,690
what you want so that you can build

00:19:17,320 --> 00:19:23,500
bigger abstractions on top of that like

00:19:19,690 --> 00:19:26,320
this type here so then we need to

00:19:23,500 --> 00:19:28,750
implement the promise type and for this

00:19:26,320 --> 00:19:30,580
we need to implement a few functions the

00:19:28,750 --> 00:19:32,470
first function is get returned object

00:19:30,580 --> 00:19:35,290
and the compiler is going to generate

00:19:32,470 --> 00:19:37,180
code that calls this in order to convert

00:19:35,290 --> 00:19:38,350
the promise type into the resumable

00:19:37,180 --> 00:19:40,690
thing that we're actually going to

00:19:38,350 --> 00:19:42,910
return to our callers and so here you

00:19:40,690 --> 00:19:45,190
can see we construct a resumable thing

00:19:42,910 --> 00:19:47,200
and we just call that co-routine handle

00:19:45,190 --> 00:19:49,090
from promise we know I'm the promise for

00:19:47,200 --> 00:19:51,160
the co-routine so get the handle that's

00:19:49,090 --> 00:19:52,720
equivalent to that and we use that to

00:19:51,160 --> 00:19:55,450
construct the resumable thing and then

00:19:52,720 --> 00:19:57,280
we return that second we need to

00:19:55,450 --> 00:19:59,710
implement these initial suspend and

00:19:57,280 --> 00:20:01,450
final suspend functions so these and

00:19:59,710 --> 00:20:03,070
we'll see in a more detailed example in

00:20:01,450 --> 00:20:04,630
a moment these allow you to determine

00:20:03,070 --> 00:20:07,570
whether or not the care routine suspends

00:20:04,630 --> 00:20:09,250
before it starts executing and at the

00:20:07,570 --> 00:20:11,650
very end of the Coe routine when it's

00:20:09,250 --> 00:20:14,620
ready to destroy itself after returning

00:20:11,650 --> 00:20:16,420
and finally we don't actually return

00:20:14,620 --> 00:20:17,860
anything from this curve routine we

00:20:16,420 --> 00:20:19,360
don't need to return a value back to our

00:20:17,860 --> 00:20:22,090
callers so we have to implement this

00:20:19,360 --> 00:20:27,730
return void function that just does

00:20:22,090 --> 00:20:31,270
nothing so back to this example so this

00:20:27,730 --> 00:20:34,930
is the Co routine the compiler is going

00:20:31,270 --> 00:20:37,210
to go and generate a contact structure

00:20:34,930 --> 00:20:40,030
for this cow routine and so here you can

00:20:37,210 --> 00:20:42,070
see it has it contains the promise it

00:20:40,030 --> 00:20:44,260
also contains our local variable I and

00:20:42,070 --> 00:20:46,180
it's going to contain an instruction

00:20:44,260 --> 00:20:48,430
pointer or something that it that it can

00:20:46,180 --> 00:20:50,530
use to when the Coe routine is resumed

00:20:48,430 --> 00:20:52,540
go and start resume execution where it

00:20:50,530 --> 00:20:54,010
left off additionally it may need to

00:20:52,540 --> 00:20:55,600
have stored four particular registers

00:20:54,010 --> 00:20:57,130
depending on how the compiler optimize

00:20:55,600 --> 00:21:02,230
the function it may have other temporary

00:20:57,130 --> 00:21:03,730
variables that's introduced and then the

00:21:02,230 --> 00:21:08,410
compiler is going to inject some code

00:21:03,730 --> 00:21:09,820
into our counter ko routine so at the

00:21:08,410 --> 00:21:12,010
beginning of the function or the ko

00:21:09,820 --> 00:21:13,540
routine it's going to construct a new

00:21:12,010 --> 00:21:16,480
instance of that Co routine context

00:21:13,540 --> 00:21:18,670
using operator new it's then going to

00:21:16,480 --> 00:21:20,890
get the return object the resumable

00:21:18,670 --> 00:21:22,300
thing and it's going to do that by call

00:21:20,890 --> 00:21:23,920
and get return object and it's going to

00:21:22,300 --> 00:21:27,070
store it wherever the caller expects it

00:21:23,920 --> 00:21:28,690
to be and then it's going to call that

00:21:27,070 --> 00:21:31,150
initial suspend function and it's going

00:21:28,690 --> 00:21:34,060
to Co await on that so if you told it

00:21:31,150 --> 00:21:35,590
for example if we used suspend always

00:21:34,060 --> 00:21:37,960
that would cause us to suspend

00:21:35,590 --> 00:21:39,520
immediately if we use suspend never then

00:21:37,960 --> 00:21:41,710
that means we'll just continue execution

00:21:39,520 --> 00:21:43,330
at that point then we'll enter the body

00:21:41,710 --> 00:21:46,120
of the KO routine and we'll execute as

00:21:43,330 --> 00:21:47,740
normal and then at the end of the

00:21:46,120 --> 00:21:50,230
function it's going to inject this

00:21:47,740 --> 00:21:51,700
additional code so here it has a final

00:21:50,230 --> 00:21:54,580
suspend label and we'll see where that's

00:21:51,700 --> 00:21:56,530
used in a little bit it's then going to

00:21:54,580 --> 00:21:57,550
Co await on that final suspend so again

00:21:56,530 --> 00:21:59,200
this gives you the opportunity to

00:21:57,550 --> 00:22:01,660
suspend execution of the co-routine

00:21:59,200 --> 00:22:03,250
before it destroys itself and then it's

00:22:01,660 --> 00:22:07,630
going to delete the context to clean up

00:22:03,250 --> 00:22:08,980
the resources so this is not the only

00:22:07,630 --> 00:22:10,450
thing that we can use this resumable

00:22:08,980 --> 00:22:12,580
thinkoh routine for

00:22:10,450 --> 00:22:14,710
we could also create another co-routine

00:22:12,580 --> 00:22:17,580
that uses that very same type that

00:22:14,710 --> 00:22:21,159
prints out a name along with the counter

00:22:17,580 --> 00:22:23,619
so here for example we construct two of

00:22:21,159 --> 00:22:26,710
these counters named a and B and then we

00:22:23,619 --> 00:22:28,179
resume them in an interleaved fashion in

00:22:26,710 --> 00:22:31,570
the output of this function you can see

00:22:28,179 --> 00:22:33,159
it's going to construct the Eiko routine

00:22:31,570 --> 00:22:34,899
it's then going to construct the B color

00:22:33,159 --> 00:22:36,159
team and then it's going to resume each

00:22:34,899 --> 00:22:37,869
of them and you can see that these are

00:22:36,159 --> 00:22:39,759
totally in parallel there's no

00:22:37,869 --> 00:22:42,519
interaction between the two of them

00:22:39,759 --> 00:22:43,989
they're independent we can resume or

00:22:42,519 --> 00:22:49,659
destroy one of them without affecting

00:22:43,989 --> 00:22:51,639
the other one so now we can fill in that

00:22:49,659 --> 00:22:53,409
last row of this table and we can say

00:22:51,639 --> 00:22:54,940
that in order to resume a KO routine we

00:22:53,409 --> 00:23:01,590
call the resume function on the care

00:22:54,940 --> 00:23:01,590
routine handle there are any questions

00:23:03,869 --> 00:23:12,669
excellent yes so the question is can you

00:23:10,899 --> 00:23:13,989
pass the resume to a different threat or

00:23:12,669 --> 00:23:17,470
could you resume on a different thread

00:23:13,989 --> 00:23:18,759
yes absolutely and if you come kenny

00:23:17,470 --> 00:23:20,289
kerr and i are giving a talk this

00:23:18,759 --> 00:23:23,019
afternoon and we're going to have a lot

00:23:20,289 --> 00:23:24,909
of examples that show how how we do that

00:23:23,019 --> 00:23:27,039
and a lot of the examples even fit on a

00:23:24,909 --> 00:23:28,419
single slide so for example if you

00:23:27,039 --> 00:23:51,730
wanted to resume a KO routine on a

00:23:28,419 --> 00:23:54,100
totally different thread yes yep so the

00:23:51,730 --> 00:23:55,600
question is inside of the co-routine

00:23:54,100 --> 00:23:59,559
frame the compiler captures a lot of

00:23:55,600 --> 00:24:00,940
things that basically you don't you

00:23:59,559 --> 00:24:03,039
don't explicitly specify like with a

00:24:00,940 --> 00:24:04,570
lambda what you wanted to capture so

00:24:03,039 --> 00:24:06,879
it's going to capture basically all of

00:24:04,570 --> 00:24:08,109
the function state and it's actually not

00:24:06,879 --> 00:24:09,460
going to need to move any of that

00:24:08,109 --> 00:24:11,109
because it's just going to construct it

00:24:09,460 --> 00:24:14,619
inside of the co-routine frame to begin

00:24:11,109 --> 00:24:16,320
with if there's any parameters they will

00:24:14,619 --> 00:24:19,840
need they may need to be moved into the

00:24:16,320 --> 00:24:21,700
co-routine frame yes but like all of the

00:24:19,840 --> 00:24:22,989
local variables it's not going to first

00:24:21,700 --> 00:24:24,190
construct them on the stack and then

00:24:22,989 --> 00:24:25,930
construct the Carine

00:24:24,190 --> 00:24:27,310
from those local variables it's actually

00:24:25,930 --> 00:24:29,020
just going to put the local variables in

00:24:27,310 --> 00:24:30,310
the carotene frame to begin with so for

00:24:29,020 --> 00:24:32,230
example you could have a non copyable

00:24:30,310 --> 00:24:39,850
non movable local variable and that

00:24:32,230 --> 00:24:43,750
would just work yes can a class member

00:24:39,850 --> 00:24:46,090
function via co-routine yes yes it would

00:24:43,750 --> 00:24:47,830
capture this and you would be incumbent

00:24:46,090 --> 00:24:59,740
upon you to then manage the lifetime of

00:24:47,830 --> 00:25:00,970
the class instance also yes I don't

00:24:59,740 --> 00:25:03,550
actually know if lambdas can be

00:25:00,970 --> 00:25:06,940
co-routines yes absolutely that can be

00:25:03,550 --> 00:25:12,150
cover teens I just hadn't written one

00:25:06,940 --> 00:25:12,150
like that okay one more

00:25:30,240 --> 00:25:35,970
yep yes so the question is given that

00:25:34,120 --> 00:25:38,980
you can destroy a co-routine at any time

00:25:35,970 --> 00:25:40,210
once it is at any suspension point does

00:25:38,980 --> 00:25:41,500
that mean that every KOA weight means

00:25:40,210 --> 00:25:42,790
you could have the stack online at that

00:25:41,500 --> 00:25:47,410
point and the answer is yes and we'll

00:25:42,790 --> 00:25:48,460
see an example of that so that's a KO

00:25:47,410 --> 00:25:49,930
routine that doesn't actually return

00:25:48,460 --> 00:25:52,750
anything but really we'd like to be able

00:25:49,930 --> 00:25:54,430
to return things from our KO routine so

00:25:52,750 --> 00:25:57,429
here is our compute value from earlier

00:25:54,430 --> 00:25:58,780
and this actually needs to return a

00:25:57,429 --> 00:26:01,480
value it needs to return an integer

00:25:58,780 --> 00:26:03,220
through the future so there's two

00:26:01,480 --> 00:26:06,160
interesting things about this this

00:26:03,220 --> 00:26:08,710
example the first is why is it ko return

00:26:06,160 --> 00:26:10,780
instead of return and the second and

00:26:08,710 --> 00:26:13,059
this kind of explains it is well we're

00:26:10,780 --> 00:26:14,860
returning an INT and the return type is

00:26:13,059 --> 00:26:16,770
future event so you can't actually

00:26:14,860 --> 00:26:21,179
construct a future of int from an INT

00:26:16,770 --> 00:26:23,170
and we're going to see how this works so

00:26:21,179 --> 00:26:24,730
we've already seen that our promised

00:26:23,170 --> 00:26:26,980
type has to have a few things it has to

00:26:24,730 --> 00:26:28,720
have this get return object it has to

00:26:26,980 --> 00:26:32,350
provide an initial suspend and final

00:26:28,720 --> 00:26:33,820
suspend functions and has to have a 4/4

00:26:32,350 --> 00:26:35,110
co-routines that do not return values to

00:26:33,820 --> 00:26:38,230
their callers it has to have a return

00:26:35,110 --> 00:26:40,179
void for co-routines that do return

00:26:38,230 --> 00:26:41,679
values to their callers you have to

00:26:40,179 --> 00:26:45,700
implement instead of return void a

00:26:41,679 --> 00:26:46,929
return value so instead of looking at

00:26:45,700 --> 00:26:47,830
our compute value we're actually just

00:26:46,929 --> 00:26:50,679
going to look at something a little

00:26:47,830 --> 00:26:53,350
simpler so here is a care routine called

00:26:50,679 --> 00:26:55,510
get value it's going to print something

00:26:53,350 --> 00:26:56,620
out it's not going to suspend and then

00:26:55,510 --> 00:27:00,880
when you resume it it's just going to

00:26:56,620 --> 00:27:05,980
return the value 30 and here is a main

00:27:00,880 --> 00:27:07,630
function that calls that and then inside

00:27:05,980 --> 00:27:09,160
of get value of course the compiler is

00:27:07,630 --> 00:27:10,300
going to generate that same boilerplate

00:27:09,160 --> 00:27:13,660
at the beginning and end that it did

00:27:10,300 --> 00:27:16,080
before what so what we really want to

00:27:13,660 --> 00:27:18,070
look at is what does this KO return do

00:27:16,080 --> 00:27:21,700
well given that we've implemented that

00:27:18,070 --> 00:27:23,170
return value function on the promise the

00:27:21,700 --> 00:27:25,960
compiler is going to transform that into

00:27:23,170 --> 00:27:28,179
a call to return value to set the return

00:27:25,960 --> 00:27:29,830
value that you've given and then it's

00:27:28,179 --> 00:27:32,770
going to go to the final suspend label

00:27:29,830 --> 00:27:34,570
which will ask is it should i suspend or

00:27:32,770 --> 00:27:35,800
not and then if you are going to if

00:27:34,570 --> 00:27:38,000
you're not going to suspend it'll delete

00:27:35,800 --> 00:27:38,960
the context

00:27:38,000 --> 00:27:40,790
so we're going to make a few small

00:27:38,960 --> 00:27:43,910
changes to our resumable thing in order

00:27:40,790 --> 00:27:46,240
to support returning of the value so

00:27:43,910 --> 00:27:48,170
this is our resumable thing from before

00:27:46,240 --> 00:27:49,190
the first thing we're going to do is

00:27:48,170 --> 00:27:52,520
we're going to actually have to store

00:27:49,190 --> 00:27:53,840
the value inside of the promise we're

00:27:52,520 --> 00:27:55,400
going to have to implement that return

00:27:53,840 --> 00:27:59,210
value function which is actually just

00:27:55,400 --> 00:28:00,410
going to set the value and then since we

00:27:59,210 --> 00:28:01,670
want to be able to call get from that

00:28:00,410 --> 00:28:04,400
main function in order to get the value

00:28:01,670 --> 00:28:06,110
back we're going to actually you know

00:28:04,400 --> 00:28:08,270
from the co-routine handle that we have

00:28:06,110 --> 00:28:12,350
get the promise and then return the

00:28:08,270 --> 00:28:14,180
value prop member of it so I do want to

00:28:12,350 --> 00:28:15,530
note these co-routines are all very low

00:28:14,180 --> 00:28:17,990
level because I'm trying to show the

00:28:15,530 --> 00:28:19,370
examples obviously in like real library

00:28:17,990 --> 00:28:21,230
code we want much higher level

00:28:19,370 --> 00:28:22,520
abstractions and we'll see we'll

00:28:21,230 --> 00:28:23,780
actually implement the care routine

00:28:22,520 --> 00:28:27,380
support for future at the end of this

00:28:23,780 --> 00:28:29,150
talk so those are the modifications that

00:28:27,380 --> 00:28:32,770
we need to make in order to support this

00:28:29,150 --> 00:28:34,940
and so here if we execute our program

00:28:32,770 --> 00:28:37,250
we're in the main foot program and we

00:28:34,940 --> 00:28:38,990
say we're going to call get value get

00:28:37,250 --> 00:28:41,930
value is called it says I've been called

00:28:38,990 --> 00:28:45,590
and then it suspends the main function

00:28:41,930 --> 00:28:47,510
will then resume get value get value

00:28:45,590 --> 00:28:50,780
will then say I've been resumed it will

00:28:47,510 --> 00:28:52,520
Co return the 30 and the main will print

00:28:50,780 --> 00:28:55,250
that the value was seven million fifty

00:28:52,520 --> 00:28:56,390
nine thousand five hundred and sixty so

00:28:55,250 --> 00:29:02,030
there we go

00:28:56,390 --> 00:29:03,830
any questions okay so what happened here

00:29:02,030 --> 00:29:05,810
well we have to look at the co-routine

00:29:03,830 --> 00:29:07,340
lifetime so a KO routine comes into

00:29:05,810 --> 00:29:08,840
existence when it's called this is when

00:29:07,340 --> 00:29:10,940
the compiler creates the care routine

00:29:08,840 --> 00:29:13,040
context as we've seen and then it's

00:29:10,940 --> 00:29:15,560
destroyed when either the final suspend

00:29:13,040 --> 00:29:17,150
is resumed or when you call destroy on

00:29:15,560 --> 00:29:21,170
the care routine handle whichever

00:29:17,150 --> 00:29:23,810
happens first so if we look at our get

00:29:21,170 --> 00:29:26,450
value KO routine you can see that in the

00:29:23,810 --> 00:29:28,160
final suspend label we call final

00:29:26,450 --> 00:29:30,890
suspend and then when that resumes we're

00:29:28,160 --> 00:29:32,690
just going to delete the context well

00:29:30,890 --> 00:29:34,670
the final suspend of our routine type

00:29:32,690 --> 00:29:36,110
returns to spend never so it's not going

00:29:34,670 --> 00:29:38,120
to suspend it's just going to continue

00:29:36,110 --> 00:29:40,040
on the context is going to be deleted

00:29:38,120 --> 00:29:41,780
and now we're accessing freed memory and

00:29:40,040 --> 00:29:45,740
so we don't get that 30 that we so

00:29:41,780 --> 00:29:47,570
nicely stored in our promise so we have

00:29:45,740 --> 00:29:50,330
to make one small change here in order

00:29:47,570 --> 00:29:53,560
to make this work does anybody want to

00:29:50,330 --> 00:29:53,560
take a guess at what we have to do

00:29:54,640 --> 00:30:01,970
yes so we just have to change the final

00:29:57,830 --> 00:30:03,620
suspend to say suspend always and by

00:30:01,970 --> 00:30:05,120
doing that when we're actually executing

00:30:03,620 --> 00:30:07,370
through the gate value co-routine will

00:30:05,120 --> 00:30:09,260
reach the final suspend label Wilco

00:30:07,370 --> 00:30:11,000
await on this final suspend it will say

00:30:09,260 --> 00:30:12,590
suspend always return control of the

00:30:11,000 --> 00:30:15,920
caller and we will not delete the

00:30:12,590 --> 00:30:18,590
context and so when we do that it will

00:30:15,920 --> 00:30:19,790
print out the correct result unless you

00:30:18,590 --> 00:30:23,990
like the other result better in which

00:30:19,790 --> 00:30:26,120
case well you can do that so when does

00:30:23,990 --> 00:30:27,230
the the resumable thing actually or when

00:30:26,120 --> 00:30:28,730
does the co-routine actually get

00:30:27,230 --> 00:30:30,980
destroyed then have we just leaked it

00:30:28,730 --> 00:30:32,990
and the answer is no because in the

00:30:30,980 --> 00:30:34,429
destructor that we wrote a while ago we

00:30:32,990 --> 00:30:36,020
actually check and say if the care

00:30:34,429 --> 00:30:39,040
routine was valid then we're going to

00:30:36,020 --> 00:30:42,200
call destroy on it explicitly

00:30:39,040 --> 00:30:44,169
and how does co-routine destruction work

00:30:42,200 --> 00:30:47,360
someone already alluded to this before

00:30:44,169 --> 00:30:49,010
so when you destroy a KO routine it's

00:30:47,360 --> 00:30:52,010
basically as if you had returned from

00:30:49,010 --> 00:30:53,330
the last suspension point so here for

00:30:52,010 --> 00:30:54,980
example if we imagine that we have a

00:30:53,330 --> 00:30:57,740
type that just prints out a message and

00:30:54,980 --> 00:31:00,530
it's destructor inside of this resumable

00:30:57,740 --> 00:31:02,650
thing we construct two of them and we

00:31:00,530 --> 00:31:05,809
have a suspension point between them and

00:31:02,650 --> 00:31:07,640
them in the main function we construct

00:31:05,809 --> 00:31:10,190
this resumable thing we resume it and

00:31:07,640 --> 00:31:11,419
then we end up destroying the co-routine

00:31:10,190 --> 00:31:13,490
frame when the resumable thing is

00:31:11,419 --> 00:31:15,350
destroyed and you can see here that

00:31:13,490 --> 00:31:16,790
first b gets destroyed and then a gets

00:31:15,350 --> 00:31:19,520
destroyed just as it would be if you

00:31:16,790 --> 00:31:20,720
were returning from the function now

00:31:19,520 --> 00:31:22,340
what happens if we don't get to the end

00:31:20,720 --> 00:31:26,360
of the curtain or we don't co return

00:31:22,340 --> 00:31:28,820
from it well if we just resign that if

00:31:26,360 --> 00:31:31,340
we eliminate the code that resumes the

00:31:28,820 --> 00:31:33,830
cover teen then we also no longer

00:31:31,340 --> 00:31:36,400
construct B so we never have to we never

00:31:33,830 --> 00:31:38,840
actually destroy it

00:31:36,400 --> 00:31:40,280
so just to recap the KO routine is

00:31:38,840 --> 00:31:42,799
destroyed when the final suspend is

00:31:40,280 --> 00:31:45,460
resumed or when you explicitly destroy

00:31:42,799 --> 00:31:47,720
it via destroy whichever happens first

00:31:45,460 --> 00:31:49,280
and when the KO routine is destroyed it

00:31:47,720 --> 00:31:50,929
cleans up its local variables but only

00:31:49,280 --> 00:31:53,360
those that were initialized prior to the

00:31:50,929 --> 00:31:57,280
last suspension point so with any

00:31:53,360 --> 00:31:57,280
questions on that yes

00:32:04,120 --> 00:32:08,240
yes so the question is how do you handle

00:32:06,890 --> 00:32:09,700
the case where the co routine is like

00:32:08,240 --> 00:32:13,130
sitting in the kernel waiting on

00:32:09,700 --> 00:32:16,970
something some kind of event and you try

00:32:13,130 --> 00:32:18,320
to destroy it so then I would have to

00:32:16,970 --> 00:32:19,970
say that you've got of a poorly designed

00:32:18,320 --> 00:32:21,770
care routine type right you haven't

00:32:19,970 --> 00:32:23,840
properly encapsulated it if you've given

00:32:21,770 --> 00:32:25,700
your caller the ability to explicitly

00:32:23,840 --> 00:32:27,650
resume or destroy you while you're

00:32:25,700 --> 00:32:29,210
actually you know doing work perhaps on

00:32:27,650 --> 00:32:30,710
another thread then you just don't have

00:32:29,210 --> 00:32:32,420
a high enough level of abstraction and

00:32:30,710 --> 00:32:33,830
so you wouldn't want to like you can

00:32:32,420 --> 00:32:36,440
certainly write live a library that

00:32:33,830 --> 00:32:38,000
would get you into that state but you

00:32:36,440 --> 00:32:39,500
wouldn't want to do that so again these

00:32:38,000 --> 00:32:42,350
Co routines that I'm showing they're

00:32:39,500 --> 00:32:43,970
just they're just very basic in order to

00:32:42,350 --> 00:32:45,830
show that like how things work under the

00:32:43,970 --> 00:32:47,660
hood if you want to see some real

00:32:45,830 --> 00:32:49,430
examples are talk

00:32:47,660 --> 00:32:50,920
Kenny Kurtz talked my talk this

00:32:49,430 --> 00:32:57,170
afternoon will show a lot of examples

00:32:50,920 --> 00:33:05,780
gourmet go into some details yes one

00:32:57,170 --> 00:33:07,160
more yes the question is how do function

00:33:05,780 --> 00:33:09,830
arguments get stored in the co-routine

00:33:07,160 --> 00:33:12,020
frame they're stored basically like

00:33:09,830 --> 00:33:14,960
member variables and I believe they are

00:33:12,020 --> 00:33:16,220
moved into the yes so if you pass a an

00:33:14,960 --> 00:33:18,200
argument into a function it will be

00:33:16,220 --> 00:33:25,330
moved into the end of the argument or

00:33:18,200 --> 00:33:25,330
copied if it's not moveable one more yep

00:33:26,080 --> 00:33:31,190
what happens if a co-routine throws an

00:33:28,340 --> 00:33:33,020
exception I'll actually save that for

00:33:31,190 --> 00:33:34,430
when we implement the co-routines for

00:33:33,020 --> 00:33:39,230
for stood future because we actually

00:33:34,430 --> 00:33:40,880
show what happens there all right so

00:33:39,230 --> 00:33:45,260
just a recap this is the same slide we

00:33:40,880 --> 00:33:46,610
saw before so let's implement something

00:33:45,260 --> 00:33:47,720
that's actually useful these care

00:33:46,610 --> 00:33:50,840
routine types are not particularly

00:33:47,720 --> 00:33:53,330
useful again they're just for exposition

00:33:50,840 --> 00:33:56,090
purposes so let's look at that stood

00:33:53,330 --> 00:33:57,740
future compute value again and let's

00:33:56,090 --> 00:33:59,060
actually make this work so let's pretend

00:33:57,740 --> 00:34:00,590
we've got a standard library that

00:33:59,060 --> 00:34:03,290
doesn't have care routine support and we

00:34:00,590 --> 00:34:04,060
want to implement this so we have to do

00:34:03,290 --> 00:34:06,170
two things

00:34:04,060 --> 00:34:08,330
first we have to make future occur

00:34:06,170 --> 00:34:10,720
routine types that we can actually have

00:34:08,330 --> 00:34:12,680
a Co routine that returns a future event

00:34:10,720 --> 00:34:14,060
the second thing we have to do is we

00:34:12,680 --> 00:34:15,770
have to make future a way

00:34:14,060 --> 00:34:17,929
because that async is going to return a

00:34:15,770 --> 00:34:20,119
future and we need to await on it and be

00:34:17,929 --> 00:34:23,629
able to unwrap the value to get the the

00:34:20,119 --> 00:34:25,669
integer result so let's look at that

00:34:23,629 --> 00:34:29,179
first part making future a KO routine

00:34:25,669 --> 00:34:32,480
type so we'll have to open up stood

00:34:29,179 --> 00:34:34,909
future and add a promise type to it or

00:34:32,480 --> 00:34:36,290
if we don't want to do that because

00:34:34,909 --> 00:34:39,710
perhaps we don't want to modify our

00:34:36,290 --> 00:34:41,330
standard library headers there is a

00:34:39,710 --> 00:34:43,220
class template called Co routine traits

00:34:41,330 --> 00:34:44,990
that allows you to specialize types

00:34:43,220 --> 00:34:48,020
without you know invasively modifying

00:34:44,990 --> 00:34:49,639
them it's the primary template it

00:34:48,020 --> 00:34:51,560
basically just gets that promise type

00:34:49,639 --> 00:34:53,750
from the type but you can specialize it

00:34:51,560 --> 00:34:54,919
for your own types if you want to so

00:34:53,750 --> 00:34:57,230
here for example we're going to write a

00:34:54,919 --> 00:35:00,130
specialization of this for future of T

00:34:57,230 --> 00:35:02,180
and define the promise type in here

00:35:00,130 --> 00:35:04,100
inside of this promise type we're going

00:35:02,180 --> 00:35:06,920
to store the actual promise which is the

00:35:04,100 --> 00:35:10,670
the sender side of the stead future if

00:35:06,920 --> 00:35:12,410
you will our get returned object

00:35:10,670 --> 00:35:13,910
function is just going to call get

00:35:12,410 --> 00:35:15,140
future on that which gets the future

00:35:13,910 --> 00:35:18,650
associated with that promise

00:35:15,140 --> 00:35:21,560
our initial suspend and final suspend

00:35:18,650 --> 00:35:23,000
are both going to be suspend never we

00:35:21,560 --> 00:35:24,920
don't actually need to keep the the

00:35:23,000 --> 00:35:26,750
co-routine alive in this case because

00:35:24,920 --> 00:35:28,340
the stead future instead promise share

00:35:26,750 --> 00:35:29,570
state that's not part of the care

00:35:28,340 --> 00:35:33,619
routine frame it's going to be some

00:35:29,570 --> 00:35:36,380
third object in memory we have to

00:35:33,619 --> 00:35:37,970
implement return value and so for this

00:35:36,380 --> 00:35:42,290
we actually just set the value on the

00:35:37,970 --> 00:35:44,600
promise and then finally if an exception

00:35:42,290 --> 00:35:45,980
happens in the care routine we want to

00:35:44,600 --> 00:35:47,420
actually capture that exception into an

00:35:45,980 --> 00:35:49,430
exception footer and set it on the

00:35:47,420 --> 00:35:51,350
promise and so in order to do that we

00:35:49,430 --> 00:35:53,869
implement this set exception function on

00:35:51,350 --> 00:35:55,400
the promise and when the when the

00:35:53,869 --> 00:35:56,869
compiler sees that you have one of these

00:35:55,400 --> 00:35:58,580
it's basically going to wrap the

00:35:56,869 --> 00:36:00,530
co-routine inside of a try/catch and

00:35:58,580 --> 00:36:02,330
it's going to store the exception put ER

00:36:00,530 --> 00:36:04,550
and pass it to this set exception

00:36:02,330 --> 00:36:06,380
function so this allows you to marshal

00:36:04,550 --> 00:36:08,690
exceptions you know to the appropriate

00:36:06,380 --> 00:36:10,880
context so hopefully that answers the

00:36:08,690 --> 00:36:15,200
question that somebody had a few minutes

00:36:10,880 --> 00:36:16,820
ago so that gives us everything we need

00:36:15,200 --> 00:36:19,280
in order to have a function that returns

00:36:16,820 --> 00:36:21,710
a KO routine that returns a future of

00:36:19,280 --> 00:36:25,070
int now we need to actually make the

00:36:21,710 --> 00:36:26,150
future a way to bolt so in order to do

00:36:25,070 --> 00:36:27,589
that we're going to have to open up

00:36:26,150 --> 00:36:29,420
future again and

00:36:27,589 --> 00:36:32,719
add those three await ready await

00:36:29,420 --> 00:36:34,579
suspend and await resume functions or if

00:36:32,719 --> 00:36:37,880
we don't want to you know intrusive ly

00:36:34,579 --> 00:36:39,589
modify future we can implement a

00:36:37,880 --> 00:36:42,109
separate type that will provide that

00:36:39,589 --> 00:36:45,589
functionality and we can over overload

00:36:42,109 --> 00:36:47,869
operator Co await to take in the future

00:36:45,589 --> 00:36:50,989
of T and instead convert it into a

00:36:47,869 --> 00:36:52,309
future a waiter of tea and the compiler

00:36:50,989 --> 00:36:54,650
will await on that instead so you can

00:36:52,309 --> 00:36:56,390
see here we just store a reference to

00:36:54,650 --> 00:36:59,569
the future of tea inside of our waiter

00:36:56,390 --> 00:37:02,749
and then our operator Co wait just wraps

00:36:59,569 --> 00:37:05,599
up or stores constructs a an instance of

00:37:02,749 --> 00:37:07,009
the future or waiter from that to

00:37:05,599 --> 00:37:12,289
implement a wait ready all we have to do

00:37:07,009 --> 00:37:13,700
is call F dot is ready when we suspend

00:37:12,289 --> 00:37:15,769
what we're going to do is we're kinda

00:37:13,700 --> 00:37:17,539
going to call then dot then on the

00:37:15,769 --> 00:37:19,519
future in order to schedule the

00:37:17,539 --> 00:37:22,249
continuation so when the future is ready

00:37:19,519 --> 00:37:23,479
this continuation will be run and it's

00:37:22,249 --> 00:37:26,239
at that point that we're actually going

00:37:23,479 --> 00:37:28,579
to run the coding resume the KO routine

00:37:26,239 --> 00:37:31,130
in that context so what this will do is

00:37:28,579 --> 00:37:33,200
when the future is actually ready it

00:37:31,130 --> 00:37:34,789
will call the result it will resume the

00:37:33,200 --> 00:37:36,319
KO routine at that point this may be on

00:37:34,789 --> 00:37:40,640
a different thread it may be on the same

00:37:36,319 --> 00:37:41,989
thread and then finally we need to

00:37:40,640 --> 00:37:43,640
implement a wait resume that gives you

00:37:41,989 --> 00:37:47,479
the actual value back and here we just

00:37:43,640 --> 00:37:49,249
call dot get on the future there's a

00:37:47,479 --> 00:37:51,019
couple problems with this slide the

00:37:49,249 --> 00:37:53,960
first is that stood future doesn't have

00:37:51,019 --> 00:37:56,539
a dot is ready and the second is it also

00:37:53,960 --> 00:37:57,829
doesn't have a dot then so this is an

00:37:56,539 --> 00:37:59,539
actually stood feature this is stood

00:37:57,829 --> 00:38:03,739
experimental future which has these two

00:37:59,539 --> 00:38:05,329
functions on them so stood future is not

00:38:03,739 --> 00:38:07,099
particularly good in its current form to

00:38:05,329 --> 00:38:08,660
use with co-routines stead experimental

00:38:07,099 --> 00:38:10,369
future is also not particularly good to

00:38:08,660 --> 00:38:11,390
use with care routines and if you want

00:38:10,369 --> 00:38:12,769
to know more about that though you'll

00:38:11,390 --> 00:38:14,089
have to come to Kenny's in my talk this

00:38:12,769 --> 00:38:16,400
afternoon where we implement a

00:38:14,089 --> 00:38:20,690
replacement and show why stead future

00:38:16,400 --> 00:38:23,869
isn't so great so that's all we need in

00:38:20,690 --> 00:38:25,759
order to implement stood in order to

00:38:23,869 --> 00:38:32,710
support co-routines withstood future are

00:38:25,759 --> 00:38:32,710
there any questions about that yes yep

00:38:43,890 --> 00:38:48,370
right so the co-routine handle is the

00:38:46,900 --> 00:38:50,590
the handle that represents the

00:38:48,370 --> 00:38:52,900
co-routine so it you know if actually

00:38:50,590 --> 00:38:55,660
refers to that carotene frame and so

00:38:52,900 --> 00:38:57,190
when you call when you call resume on it

00:38:55,660 --> 00:38:58,420
it's just like using the function call

00:38:57,190 --> 00:39:00,820
operator and what it does is it just

00:38:58,420 --> 00:39:02,620
resumes execution of the carotene at the

00:39:00,820 --> 00:39:04,810
last point that it was suspended so

00:39:02,620 --> 00:39:12,000
wherever the last Co weight was it'll

00:39:04,810 --> 00:39:12,000
resume on the next line yep

00:39:13,110 --> 00:39:18,190
yes so the operator Co weight here

00:39:15,370 --> 00:39:19,810
basically so stood future does not have

00:39:18,190 --> 00:39:21,880
this await ready await suspend in a wait

00:39:19,810 --> 00:39:23,710
resume so the operator Co weight

00:39:21,880 --> 00:39:25,270
basically just lets you transform stood

00:39:23,710 --> 00:39:26,800
future into something that does have

00:39:25,270 --> 00:39:30,580
those and provides the functionality

00:39:26,800 --> 00:39:33,100
that you need so in this case we didn't

00:39:30,580 --> 00:39:34,570
want to modify stood future we wanted to

00:39:33,100 --> 00:39:37,450
provide this separate type future a

00:39:34,570 --> 00:39:39,190
waiter instead and so the operator Co

00:39:37,450 --> 00:39:40,960
way basically just provides basically

00:39:39,190 --> 00:39:42,970
just transforms the future into

00:39:40,960 --> 00:39:54,670
something that does that can be Co

00:39:42,970 --> 00:39:55,900
awaited on anymore all right so I'm

00:39:54,670 --> 00:39:56,740
going to show one more feature of

00:39:55,900 --> 00:40:00,310
co-routines

00:39:56,740 --> 00:40:02,590
and that's yielding so what if we have a

00:40:00,310 --> 00:40:05,230
Co routine and we want to be able to

00:40:02,590 --> 00:40:07,270
return values to our caller so we don't

00:40:05,230 --> 00:40:09,160
want to return just one value we want to

00:40:07,270 --> 00:40:11,920
be able to return a value and then allow

00:40:09,160 --> 00:40:14,500
the caller to resume you and you can

00:40:11,920 --> 00:40:18,190
return another value so why might this

00:40:14,500 --> 00:40:21,010
be useful so here is a little generator

00:40:18,190 --> 00:40:22,810
function called integers and it takes in

00:40:21,010 --> 00:40:25,060
a first and a last integer and it's

00:40:22,810 --> 00:40:27,220
going to return all of the integers in

00:40:25,060 --> 00:40:31,210
that range one at a time each time it's

00:40:27,220 --> 00:40:33,280
resumed so here's a function that might

00:40:31,210 --> 00:40:35,850
use it here we have a function with a

00:40:33,280 --> 00:40:39,250
range based for loop and it just has int

00:40:35,850 --> 00:40:40,780
you know the variable X and we run this

00:40:39,250 --> 00:40:44,620
program it's going to print out one two

00:40:40,780 --> 00:40:45,750
three four five now there's no there's

00:40:44,620 --> 00:40:48,970
no magic here

00:40:45,750 --> 00:40:51,340
we could actually write this just as

00:40:48,970 --> 00:40:52,990
easily with an on range for loop so we

00:40:51,340 --> 00:40:55,210
create we can start the generator of int

00:40:52,990 --> 00:40:57,220
and then we're just getting in a

00:40:55,210 --> 00:40:59,080
iterator from it which will show some of

00:40:57,220 --> 00:41:00,520
the implementation of and we just call

00:40:59,080 --> 00:41:08,320
begin and end on it and we iterate over

00:41:00,520 --> 00:41:11,260
it so what that cold does is it takes

00:41:08,320 --> 00:41:12,490
the promise and it calls yield value on

00:41:11,260 --> 00:41:14,790
it and then awaits on whatever it

00:41:12,490 --> 00:41:16,990
returns

00:41:14,790 --> 00:41:18,490
so in our promise type we're going to

00:41:16,990 --> 00:41:19,780
store a pointer to whatever the current

00:41:18,490 --> 00:41:20,890
element is we could also store the

00:41:19,780 --> 00:41:22,900
current element but we could imagine

00:41:20,890 --> 00:41:24,730
building generators of you know some

00:41:22,900 --> 00:41:28,030
type other than int where we not want to

00:41:24,730 --> 00:41:29,530
make a copy of it or move it our get

00:41:28,030 --> 00:41:32,290
returned object is implemented the exact

00:41:29,530 --> 00:41:33,849
same way it's been in the past our

00:41:32,290 --> 00:41:35,380
initial and final suspend are going to

00:41:33,849 --> 00:41:37,599
suspend always and the reason for this

00:41:35,380 --> 00:41:39,550
is is we actually want to be explicitly

00:41:37,599 --> 00:41:43,060
resumed each time we want to get a value

00:41:39,550 --> 00:41:45,099
out of the generator and then our yield

00:41:43,060 --> 00:41:47,440
value is implemented like so we just

00:41:45,099 --> 00:41:50,109
take the integer in we store it a

00:41:47,440 --> 00:41:51,970
pointer to it in our current local our

00:41:50,109 --> 00:41:53,920
current member variable and then we

00:41:51,970 --> 00:41:56,380
return suspend always so that each time

00:41:53,920 --> 00:42:00,240
that we yield value we suspend execution

00:41:56,380 --> 00:42:00,240
and we return control back to the caller

00:42:01,230 --> 00:42:05,950
so then we're going to have to have an

00:42:03,099 --> 00:42:07,420
iterator type for this generator we're

00:42:05,950 --> 00:42:09,820
gonna have to implement begin and end

00:42:07,420 --> 00:42:11,020
functions so in the begin we're going to

00:42:09,820 --> 00:42:13,420
check and see do we have a valid

00:42:11,020 --> 00:42:16,560
co-routine and if we do then we're going

00:42:13,420 --> 00:42:19,510
to resume it to get the first value and

00:42:16,560 --> 00:42:21,400
then if we're done if we've reached the

00:42:19,510 --> 00:42:25,930
end of the KO routine at that point then

00:42:21,400 --> 00:42:27,700
we'll return the end iterator the actual

00:42:25,930 --> 00:42:29,800
iterator itself just has to be a studied

00:42:27,700 --> 00:42:31,660
or a an input iterator because obviously

00:42:29,800 --> 00:42:33,190
we can't iterate multiple times with

00:42:31,660 --> 00:42:35,140
this single ko routine because once

00:42:33,190 --> 00:42:36,250
we've moved on to the next value there's

00:42:35,140 --> 00:42:39,460
no way for us to get back to that

00:42:36,250 --> 00:42:40,960
previous state inside of the increment

00:42:39,460 --> 00:42:42,609
operator we're just going to resume the

00:42:40,960 --> 00:42:44,980
KO routine and then again check if we're

00:42:42,609 --> 00:42:46,750
finished and then when we dereference

00:42:44,980 --> 00:42:48,070
the iterator we're actually just going

00:42:46,750 --> 00:42:58,570
to get that current value from the

00:42:48,070 --> 00:43:01,010
promise and so that is that so too

00:42:58,570 --> 00:43:02,960
just look at this table again so we've

00:43:01,010 --> 00:43:05,329
looked at the co return statement the co

00:43:02,960 --> 00:43:06,770
await and Co yield expressions we've

00:43:05,329 --> 00:43:11,240
looked at how we resume Co routines

00:43:06,770 --> 00:43:12,829
using the care routine handle we've

00:43:11,240 --> 00:43:14,450
looked at the co-routine control flow

00:43:12,829 --> 00:43:17,450
and how the compiler basically just

00:43:14,450 --> 00:43:19,280
transforms these Co statements and

00:43:17,450 --> 00:43:23,599
expressions into something slightly

00:43:19,280 --> 00:43:27,500
different and the boilerplate that we

00:43:23,599 --> 00:43:29,210
generate these are some of the design

00:43:27,500 --> 00:43:33,320
principles that were laid out in one of

00:43:29,210 --> 00:43:35,000
the original care routine papers that I

00:43:33,320 --> 00:43:37,339
believe Gore worked on I'm sure Gore

00:43:35,000 --> 00:43:39,349
worked on so the first was that we

00:43:37,339 --> 00:43:40,790
wanted these to be scalable to billions

00:43:39,349 --> 00:43:44,150
of concurrent care routines so one of

00:43:40,790 --> 00:43:45,619
the if you can imagine there's two

00:43:44,150 --> 00:43:47,119
different classes of care routines this

00:43:45,619 --> 00:43:49,099
these are called stack Lascaux routines

00:43:47,119 --> 00:43:51,050
so you always have to suspend from

00:43:49,099 --> 00:43:52,609
within the care routine itself you can't

00:43:51,050 --> 00:43:56,420
call a function and then suspend from

00:43:52,609 --> 00:43:57,950
within that that Colie the other time

00:43:56,420 --> 00:43:59,630
would be stack full co-routines where

00:43:57,950 --> 00:44:02,270
you can actually suspend from within

00:43:59,630 --> 00:44:03,380
Akali so the advantage of stack Lesko

00:44:02,270 --> 00:44:04,790
routines is that you don't have to

00:44:03,380 --> 00:44:06,050
actually allocate a whole stack or

00:44:04,790 --> 00:44:07,339
allocate a lot of memory for each of

00:44:06,050 --> 00:44:09,230
these you really only need to allocate

00:44:07,339 --> 00:44:11,150
just whatever you need for that one

00:44:09,230 --> 00:44:12,770
co-routine frame this means that you can

00:44:11,150 --> 00:44:14,690
allocate a whole lot of these so if you

00:44:12,770 --> 00:44:16,250
wanted to create you know a million Co

00:44:14,690 --> 00:44:18,440
routines and submit them all to a thread

00:44:16,250 --> 00:44:21,099
pool for execution you could do that and

00:44:18,440 --> 00:44:23,210
you're not going to run out of memory

00:44:21,099 --> 00:44:24,980
that doesn't mean that there aren't you

00:44:23,210 --> 00:44:27,589
know valid and great use cases for

00:44:24,980 --> 00:44:28,790
sackful co-routines that's just this is

00:44:27,589 --> 00:44:31,010
one of the benefits of this design

00:44:28,790 --> 00:44:32,750
they're all so efficient so suspend and

00:44:31,010 --> 00:44:35,260
resume operations are comparable in cost

00:44:32,750 --> 00:44:37,579
to function call overhead so

00:44:35,260 --> 00:44:38,990
additionally because the compiler is

00:44:37,579 --> 00:44:41,030
generating all of the boilerplate for

00:44:38,990 --> 00:44:44,930
you it actually has much more visibility

00:44:41,030 --> 00:44:47,300
into for example what is exactly going

00:44:44,930 --> 00:44:49,099
on so that it can make better inlining

00:44:47,300 --> 00:44:50,780
decisions potentially inline co-routines

00:44:49,099 --> 00:44:53,359
potentially elide the heap allocation

00:44:50,780 --> 00:44:55,220
for the co-routine frame they're

00:44:53,359 --> 00:44:58,099
open-ended so we've shown here how we

00:44:55,220 --> 00:45:00,109
were able to pretty easily bind stood

00:44:58,099 --> 00:45:02,150
future to the co-routine functionality

00:45:00,109 --> 00:45:04,490
and then we'll show later this afternoon

00:45:02,150 --> 00:45:06,170
some other types some other library

00:45:04,490 --> 00:45:08,859
types that we've been able to implement

00:45:06,170 --> 00:45:10,910
very easily with co-routines

00:45:08,859 --> 00:45:11,660
so there's seamless interaction with

00:45:10,910 --> 00:45:15,320
existing

00:45:11,660 --> 00:45:16,430
and finally it's also usable in

00:45:15,320 --> 00:45:18,020
environments where exceptions are

00:45:16,430 --> 00:45:19,400
forbidden or not available so for

00:45:18,020 --> 00:45:21,170
example if you're a kernel developer and

00:45:19,400 --> 00:45:22,910
you want to use co-routines that's also

00:45:21,170 --> 00:45:24,680
possible we didn't look into how that

00:45:22,910 --> 00:45:25,910
works but there's some other

00:45:24,680 --> 00:45:29,980
functionality that you can take

00:45:25,910 --> 00:45:29,980
advantage of to enable that to work

00:45:30,160 --> 00:45:34,580
there's just a couple references you

00:45:32,420 --> 00:45:37,120
might want to look at the first is a

00:45:34,580 --> 00:45:39,770
paper just describing the plan and then

00:45:37,120 --> 00:45:41,450
the second is the wording for

00:45:39,770 --> 00:45:44,270
co-routines the current specification

00:45:41,450 --> 00:45:46,490
document so there are three talks on

00:45:44,270 --> 00:45:48,110
co-routines today the first one you are

00:45:46,490 --> 00:45:49,820
sitting in right now so thank you for

00:45:48,110 --> 00:45:51,200
coming then we're going to have a

00:45:49,820 --> 00:45:53,870
suspension point we're all going to go

00:45:51,200 --> 00:45:56,300
and watch the keynote and then hopefully

00:45:53,870 --> 00:45:57,800
we'll all resume and you'll go to Gore's

00:45:56,300 --> 00:45:59,120
talk this afternoon which is also I

00:45:57,800 --> 00:46:01,340
believe in this room

00:45:59,120 --> 00:46:03,080
C++ care routines under the covers and

00:46:01,340 --> 00:46:04,880
then after that Kenny Kerr and I are

00:46:03,080 --> 00:46:06,890
going to talk about how we have put the

00:46:04,880 --> 00:46:09,650
kuru teens feature to work with the

00:46:06,890 --> 00:46:11,300
Windows runtime and while our examples

00:46:09,650 --> 00:46:13,370
are going to be window specific our goal

00:46:11,300 --> 00:46:17,270
is to show you know largely how flexible

00:46:13,370 --> 00:46:19,610
the co-routine feature is and how we've

00:46:17,270 --> 00:46:22,340
been able to use it in order to make our

00:46:19,610 --> 00:46:25,940
library both more beautiful easier to

00:46:22,340 --> 00:46:27,470
use and also more efficient and then

00:46:25,940 --> 00:46:30,650
finally anyone who wanted that link to

00:46:27,470 --> 00:46:31,940
the survey it's there with that I've

00:46:30,650 --> 00:46:36,940
reached the end I can't advance any

00:46:31,940 --> 00:46:36,940
further so are there any questions yes

00:46:41,500 --> 00:46:54,440
how how granular should you put a weight

00:46:46,190 --> 00:46:56,120
in your code it yeah so you certainly

00:46:54,440 --> 00:47:00,380
like if we're talking about asynchronous

00:46:56,120 --> 00:47:02,630
code you don't ever want to you want to

00:47:00,380 --> 00:47:05,870
avoid blocking wherever you can and so

00:47:02,630 --> 00:47:07,010
instead you want to await on on those

00:47:05,870 --> 00:47:08,540
things that would block and then

00:47:07,010 --> 00:47:10,520
schedule a continuation so that you're

00:47:08,540 --> 00:47:11,570
you know when it's ready instead of

00:47:10,520 --> 00:47:13,810
blocking when it's ready you'll be

00:47:11,570 --> 00:47:13,810
called

00:47:23,690 --> 00:47:30,060
yeah so the question is there is a cost

00:47:26,130 --> 00:47:31,440
to the await so it it depends and so it

00:47:30,060 --> 00:47:32,670
would depend on the relative cost of

00:47:31,440 --> 00:47:34,260
well how long do I think I'm going to

00:47:32,670 --> 00:47:35,250
block for right like if I if I think I'm

00:47:34,260 --> 00:47:36,840
only going to block for a few

00:47:35,250 --> 00:47:39,030
nanoseconds and maybe it's not worth you

00:47:36,840 --> 00:47:42,690
know going through the whole process of

00:47:39,030 --> 00:47:44,940
scheduling a continuation but in general

00:47:42,690 --> 00:47:47,570
you would just want to you know I guess

00:47:44,940 --> 00:47:49,980
you know in most like application-level

00:47:47,570 --> 00:47:51,300
asynchronous code you'd probably want to

00:47:49,980 --> 00:47:57,390
just a wait on every asynchronous

00:47:51,300 --> 00:47:58,860
operation to avoid the blocking and

00:47:57,390 --> 00:48:00,900
again the it like so the overhead if

00:47:58,860 --> 00:48:02,400
you're not you know if you're not doing

00:48:00,900 --> 00:48:03,900
a context switch right you're not

00:48:02,400 --> 00:48:06,720
scheduling something to run on another

00:48:03,900 --> 00:48:08,880
thread on the thread pool the overhead

00:48:06,720 --> 00:48:10,680
is equivalent to a function call so for

00:48:08,880 --> 00:48:12,420
example if you need to wait on a mutex

00:48:10,680 --> 00:48:15,630
and the mutex you can just acquire it

00:48:12,420 --> 00:48:17,340
you don't need to mutex is a bad example

00:48:15,630 --> 00:48:18,690
if you need to wait on an event for

00:48:17,340 --> 00:48:22,020
example and the event is already in the

00:48:18,690 --> 00:48:23,550
signal State then you may not even need

00:48:22,020 --> 00:48:25,230
to switch to another context it may just

00:48:23,550 --> 00:48:35,040
continue executing in which case it may

00:48:25,230 --> 00:48:36,600
be more efficient yes what happens if

00:48:35,040 --> 00:48:37,980
you issue an ordinary return statement

00:48:36,600 --> 00:48:40,350
from within a KO routine I believe you

00:48:37,980 --> 00:48:44,280
get a compiler error I don't think

00:48:40,350 --> 00:48:46,380
that's valid like you either have to

00:48:44,280 --> 00:48:48,240
have a subroutine like functionality or

00:48:46,380 --> 00:48:57,390
you have to have ko routine things in

00:48:48,240 --> 00:48:58,980
the KO routine yeah yes so couldn't we

00:48:57,390 --> 00:49:01,140
have made an ordinary return statement

00:48:58,980 --> 00:49:02,940
behave like a KO return I actually don't

00:49:01,140 --> 00:49:05,490
know the reason for that I know that in

00:49:02,940 --> 00:49:07,380
the original implementation that I used

00:49:05,490 --> 00:49:09,870
like a year and a half ago now it was

00:49:07,380 --> 00:49:11,880
that way and then the community decided

00:49:09,870 --> 00:49:14,340
to make it you know instead of just a

00:49:11,880 --> 00:49:16,410
wait and return ko await and ko return I

00:49:14,340 --> 00:49:20,160
thought it was because they just like

00:49:16,410 --> 00:49:24,360
you know funny phrasing but gourmet have

00:49:20,160 --> 00:49:26,840
more details nope he's nope he's got no

00:49:24,360 --> 00:49:26,840
more details

00:49:32,300 --> 00:49:37,440
there we go so the answer was that they

00:49:35,400 --> 00:49:39,990
thought that just saying plane return

00:49:37,440 --> 00:49:58,859
would be confusing and so they thought

00:49:39,990 --> 00:50:00,390
the co would help yes uh we will not

00:49:58,859 --> 00:50:02,640
actually cover that in our later talk it

00:50:00,390 --> 00:50:05,339
is described in the spec and it's not

00:50:02,640 --> 00:50:07,080
particularly a difficult read it's

00:50:05,339 --> 00:50:09,180
actually quite short yes so the question

00:50:07,080 --> 00:50:11,190
was are we going to discuss how you

00:50:09,180 --> 00:50:12,180
would overload operator new and the

00:50:11,190 --> 00:50:13,740
answer is we're not going to talk about

00:50:12,180 --> 00:50:15,420
in the next session it is described in

00:50:13,740 --> 00:50:17,720
the spec and I would be happy to provide

00:50:15,420 --> 00:50:27,510
an example if you're interested in one

00:50:17,720 --> 00:50:29,070
it's not particularly difficult yeah how

00:50:27,510 --> 00:50:32,070
would return type deduction work with

00:50:29,070 --> 00:50:33,390
co-routines I expect it does not just

00:50:32,070 --> 00:50:36,599
because you actually have to tell it

00:50:33,390 --> 00:50:38,099
what type you know so that it knows what

00:50:36,599 --> 00:50:51,119
type of promise to construct on the in

00:50:38,099 --> 00:50:54,599
the frame yep yes is there any support

00:50:51,119 --> 00:50:56,130
for a kind of placement new no because

00:50:54,599 --> 00:50:58,290
again you don't actually construct it

00:50:56,130 --> 00:51:00,180
yourself it's always the compiler it's

00:50:58,290 --> 00:51:02,160
converts generating code that's going to

00:51:00,180 --> 00:51:10,130
construct the frame so all you ever do

00:51:02,160 --> 00:51:12,119
is call a function NIT yes so you can

00:51:10,130 --> 00:51:14,190
one of the things I didn't go in here

00:51:12,119 --> 00:51:16,380
into here is when you specialized the

00:51:14,190 --> 00:51:17,970
co-routine traits you specialize it with

00:51:16,380 --> 00:51:20,190
a set of arguments and so you could for

00:51:17,970 --> 00:51:23,119
example use a custom allocator that

00:51:20,190 --> 00:51:23,119
would allocate it in a particular way

00:51:28,730 --> 00:51:34,109
yes we will we will be discussing this

00:51:32,340 --> 00:51:36,270
is Kenny Kerr who I'm giving the next

00:51:34,109 --> 00:51:38,520
talk with this afternoon we will be

00:51:36,270 --> 00:51:40,050
discussing how we optimize allocations

00:51:38,520 --> 00:51:43,470
and specifically in the stead future

00:51:40,050 --> 00:51:44,730
case with the state future example we

00:51:43,470 --> 00:51:47,070
showed you actually end up with two

00:51:44,730 --> 00:51:48,750
different allocations first because the

00:51:47,070 --> 00:51:50,730
co-routine frame has to be allocated on

00:51:48,750 --> 00:51:52,470
the heap and then because the shared

00:51:50,730 --> 00:51:53,730
state between the promise and the future

00:51:52,470 --> 00:51:56,100
has to be allocated on the heap

00:51:53,730 --> 00:51:57,630
separately and so we have several

00:51:56,100 --> 00:52:00,180
examples that show how we actually can

00:51:57,630 --> 00:52:02,280
allocate those together to eliminate

00:52:00,180 --> 00:52:06,260
some allocations in that case the Coe

00:52:02,280 --> 00:52:06,260
routine is actually more efficient yes

00:52:17,180 --> 00:52:22,500
yeah so the question is because these

00:52:19,800 --> 00:52:24,119
co-routines are stackless is it a this

00:52:22,500 --> 00:52:26,160
is a compiler error to make a function

00:52:24,119 --> 00:52:28,380
call from the KO routine and the answer

00:52:26,160 --> 00:52:30,390
that is no and so the co-routines we

00:52:28,380 --> 00:52:33,840
actually use to see out and you know

00:52:30,390 --> 00:52:35,940
with the the stream operators and so

00:52:33,840 --> 00:52:37,650
those would be function calls so what

00:52:35,940 --> 00:52:39,600
happens is is when you resume a KO

00:52:37,650 --> 00:52:41,640
routine all of its state is still in the

00:52:39,600 --> 00:52:43,770
care routine frame but once it's resumed

00:52:41,640 --> 00:52:45,270
it regains control of the stack and so

00:52:43,770 --> 00:52:47,160
it can call whatever functions it likes

00:52:45,270 --> 00:52:50,730
and it you know can use the stack for

00:52:47,160 --> 00:52:52,619
doing that you just can't what what it

00:52:50,730 --> 00:52:54,210
means by them being stackless is it

00:52:52,619 --> 00:52:56,310
means you can't resume from within one

00:52:54,210 --> 00:52:57,900
of those collies so for example if

00:52:56,310 --> 00:53:00,330
you've got a cover team named F and it

00:52:57,900 --> 00:53:02,730
calls a function G you can't suspend

00:53:00,330 --> 00:53:05,400
from within G G has to return and then F

00:53:02,730 --> 00:53:06,780
can suspend so a stack full co-routine

00:53:05,400 --> 00:53:11,480
would let you potentially suspend from

00:53:06,780 --> 00:53:11,480
within G yes

00:53:31,519 --> 00:53:35,969
yeah so the question is how common is

00:53:34,650 --> 00:53:37,650
the optimization going to be where the

00:53:35,969 --> 00:53:40,140
compiler is able to elide the

00:53:37,650 --> 00:53:41,789
construction of the co-routine frame so

00:53:40,140 --> 00:53:43,890
there are certain cases where it can't

00:53:41,789 --> 00:53:46,259
do that and so for example asynchronous

00:53:43,890 --> 00:53:47,789
code where it has no idea what the

00:53:46,259 --> 00:53:50,369
lifetime of the frame needs to be is

00:53:47,789 --> 00:53:52,680
always going to require allocation on

00:53:50,369 --> 00:53:54,239
the heap but other cases so for example

00:53:52,680 --> 00:53:57,180
this generator type that we have here

00:53:54,239 --> 00:53:59,369
the compiler should be able to see well

00:53:57,180 --> 00:54:01,319
the the co-routine never escapes from

00:53:59,369 --> 00:54:02,849
its callers scope right like it knows

00:54:01,319 --> 00:54:04,319
that that main function uses the cover

00:54:02,849 --> 00:54:05,609
teen and the co-routine is always

00:54:04,319 --> 00:54:07,559
destroyed before the main function

00:54:05,609 --> 00:54:10,140
returns so I could just allocate it on

00:54:07,559 --> 00:54:11,910
the stack there as for how common one

00:54:10,140 --> 00:54:13,049
design pattern is versus the other I

00:54:11,910 --> 00:54:16,289
mean it would just depend on the

00:54:13,049 --> 00:54:18,689
patterns used but Gore will be going

00:54:16,289 --> 00:54:51,569
into a lot of details on that or some

00:54:18,689 --> 00:54:52,920
details on that yes yep yeah so Gore's

00:54:51,569 --> 00:54:55,289
answer was if the co-routine type

00:54:52,920 --> 00:54:56,819
implements R III and I suspect if the

00:54:55,289 --> 00:54:59,999
object does not escape out of the caller

00:54:56,819 --> 00:55:01,859
scope then in that case the compiler

00:54:59,999 --> 00:55:06,239
should be able to perform the

00:55:01,859 --> 00:55:08,130
optimization additionally I forgot what

00:55:06,239 --> 00:55:22,890
the second point was but anyway yes that

00:55:08,130 --> 00:55:24,749
was the key so yes yes yes so a KO

00:55:22,890 --> 00:55:25,799
routine can call another ko routine and

00:55:24,749 --> 00:55:29,459
we'll have some examples of this

00:55:25,799 --> 00:55:31,199
afternoon in that case so when I said

00:55:29,459 --> 00:55:35,099
that their stack list so each Co routine

00:55:31,199 --> 00:55:37,019
can always suspend itself what you can't

00:55:35,099 --> 00:55:39,269
do is if you have a KO routine F that

00:55:37,019 --> 00:55:39,840
calls a care routine G like G cannot

00:55:39,269 --> 00:55:42,630
suspend

00:55:39,840 --> 00:55:46,140
f-g can suspend itself it can't suspend

00:55:42,630 --> 00:55:47,940
its collar yes yeah and again that goes

00:55:46,140 --> 00:55:49,170
back to when you see it when you look at

00:55:47,940 --> 00:55:50,850
a function declaration there's nothing

00:55:49,170 --> 00:56:10,020
that says it's a KO routine it's fully

00:55:50,850 --> 00:56:12,570
in implementation detail yep yeah so the

00:56:10,020 --> 00:56:15,540
question is when we ship this will we

00:56:12,570 --> 00:56:17,700
have tools that enable developers to you

00:56:15,540 --> 00:56:20,280
know not make common errors so for

00:56:17,700 --> 00:56:22,680
example resuming a KO routine twice you

00:56:20,280 --> 00:56:24,630
know from different scopes so I guess to

00:56:22,680 --> 00:56:27,090
answer both of those questions the first

00:56:24,630 --> 00:56:29,580
is this is already shipping so if you

00:56:27,090 --> 00:56:31,440
have Visual Studio 2015 the latest

00:56:29,580 --> 00:56:33,600
update is fully usable all of the

00:56:31,440 --> 00:56:36,000
examples from here barring any you know

00:56:33,600 --> 00:56:38,250
errors I introduced in PowerPoint should

00:56:36,000 --> 00:56:41,610
compile also we're working on

00:56:38,250 --> 00:56:43,920
implementing it in clang with respect to

00:56:41,610 --> 00:56:45,990
like helping programmers like maintain

00:56:43,920 --> 00:56:47,520
best practices our expectation is that

00:56:45,990 --> 00:56:49,590
most programmers should not need to

00:56:47,520 --> 00:56:51,510
write these Co routine types and that

00:56:49,590 --> 00:56:53,130
you know a few library developers

00:56:51,510 --> 00:56:55,800
effectively are going to build these

00:56:53,130 --> 00:56:57,960
these Co routine adaptors for the

00:56:55,800 --> 00:57:00,180
libraries and will do so in a way that

00:56:57,960 --> 00:57:02,130
you know with proper and caps proper

00:57:00,180 --> 00:57:04,260
abstractions such that it's safe to use

00:57:02,130 --> 00:57:08,820
so for example the stood future stood

00:57:04,260 --> 00:57:10,320
promise example here you know the the

00:57:08,820 --> 00:57:12,510
way that those are designed is it's it's

00:57:10,320 --> 00:57:13,620
hard to use it incorrectly in a way

00:57:12,510 --> 00:57:23,690
where you would end up with a corrupt

00:57:13,620 --> 00:57:27,410
state like you described mm-hmm yeah I

00:57:23,690 --> 00:57:27,410
think we have time for one more

00:57:34,019 --> 00:57:52,210
pardon when will decline implementation

00:57:41,619 --> 00:57:56,559
be ready that I don't know you might

00:57:52,210 --> 00:57:58,539
want to ask Richard Smith that all right

00:57:56,559 --> 00:58:01,589
thank you all for coming please do come

00:57:58,539 --> 00:58:01,589

YouTube URL: https://www.youtube.com/watch?v=ZTqHjjm86Bw


