Title: CppCon 2016: Marcelo Juchem “The Power of Reflection with Facebook's Thrift"
Publication date: 2016-10-01
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
At Facebook we use C++ extensively in our backend and core infrastructure. We've recently added static reflection support for C++ to Thrift, in expectation of a first class standardized solution. 

This talk demonstrates the power of reflection as a productivity enhancer, an enabler for features and an aid in managing complexity. It shows some useful functionalities that can be easily achieved through reflection in a portable and elegant way, which weren't possible before without code repetition, complex DSLs or non-portable pre-processors. 

We'll cover things like pretty printers, data converters, migration to typed APIs, serialization and compilation times.

REQUIREMENTS: intermediate to advanced knowledge of template meta-programming. This talk is not aimed at people who want to learn meta-programming.
— 
Marcelo Juchem
Software Engineer, Facebook
Marcelo is a Software Engineer working with core infrastructure at Facebook.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,990
welcome to everybody my name is Marcelo

00:00:02,100 --> 00:00:06,150
I work for Facebook I'm a software

00:00:03,990 --> 00:00:11,370
engineer and I'm here today to talk

00:00:06,150 --> 00:00:14,190
about reflection using Facebook drift so

00:00:11,370 --> 00:00:17,070
basically let me just talk about the

00:00:14,190 --> 00:00:19,619
goals of this presentation today I want

00:00:17,070 --> 00:00:22,710
to showcase a few examples of what can

00:00:19,619 --> 00:00:25,170
be done with reflection those are some

00:00:22,710 --> 00:00:29,670
real-world problems that we hear so

00:00:25,170 --> 00:00:31,410
viens Facebook this is useful should be

00:00:29,670 --> 00:00:33,480
useful for users like to see what's

00:00:31,410 --> 00:00:36,300
possible to follow some examples and

00:00:33,480 --> 00:00:38,790
also for library white writers to see

00:00:36,300 --> 00:00:40,890
the to look at the problem from the

00:00:38,790 --> 00:00:42,270
perspective of Facebook so the more use

00:00:40,890 --> 00:00:47,730
cases they can't they have at hand a

00:00:42,270 --> 00:00:49,260
better and also I'm here present also to

00:00:47,730 --> 00:00:50,940
present a freight working framework that

00:00:49,260 --> 00:00:52,440
can be used today so it's not something

00:00:50,940 --> 00:00:54,989
that would have to wait for a compiler

00:00:52,440 --> 00:00:57,390
support for a new proposal to be

00:00:54,989 --> 00:00:58,530
accepted and and of course we're tripped

00:00:57,390 --> 00:01:00,899
applies because you need tripped

00:00:58,530 --> 00:01:02,789
foreigner for this work for those who

00:01:00,899 --> 00:01:04,229
are not familiar with drift is basically

00:01:02,789 --> 00:01:07,770
the RPC framework that we have a

00:01:04,229 --> 00:01:09,930
Facebook so we write a so we write some

00:01:07,770 --> 00:01:12,270
definition in using a interface

00:01:09,930 --> 00:01:14,220
definition language based the saying

00:01:12,270 --> 00:01:16,259
those are the types that I have and we

00:01:14,220 --> 00:01:20,159
generate some code for you based on that

00:01:16,259 --> 00:01:22,170
and we won't look at how the reflection

00:01:20,159 --> 00:01:23,549
framework is implemented I know some of

00:01:22,170 --> 00:01:25,710
you might be interested in that but

00:01:23,549 --> 00:01:27,210
that's not the point of this talk you

00:01:25,710 --> 00:01:29,460
can take a look at the source code later

00:01:27,210 --> 00:01:31,619
or come find me and I'll be happy to

00:01:29,460 --> 00:01:33,420
talk about it but the focus here is to

00:01:31,619 --> 00:01:39,240
look at how to use it and what is

00:01:33,420 --> 00:01:41,400
possible so channel here so just initial

00:01:39,240 --> 00:01:44,640
words first and we're going to take a

00:01:41,400 --> 00:01:47,399
look at a few examples basically code

00:01:44,640 --> 00:01:50,100
and how to use it then how to enable

00:01:47,399 --> 00:01:52,320
reflection support in tricked few

00:01:50,100 --> 00:01:55,490
closing words and before I go we can

00:01:52,320 --> 00:01:57,810
have some questions so before I start I

00:01:55,490 --> 00:02:00,450
assume you're familiar with reflection

00:01:57,810 --> 00:02:03,570
the concept of reflection and

00:02:00,450 --> 00:02:05,100
introspection high level familiarity

00:02:03,570 --> 00:02:07,129
with civilization just because one of

00:02:05,100 --> 00:02:09,810
our examples is basically civilizer

00:02:07,129 --> 00:02:12,959
search algorithms like binary search or

00:02:09,810 --> 00:02:15,329
the dictionary lookup

00:02:12,959 --> 00:02:17,430
and of course familiarity with

00:02:15,329 --> 00:02:19,019
metaprogramming so if you're not

00:02:17,430 --> 00:02:20,400
familiar with meta programming you never

00:02:19,019 --> 00:02:23,489
you never done some meta programming

00:02:20,400 --> 00:02:26,430
before this talk will definitely not be

00:02:23,489 --> 00:02:29,159
useful for you things like meta

00:02:26,430 --> 00:02:32,010
functions specializations traits classes

00:02:29,159 --> 00:02:33,840
type lists this is basically what a tie

00:02:32,010 --> 00:02:36,420
place will look like in this this lights

00:02:33,840 --> 00:02:38,549
list transforms basically how to apply

00:02:36,420 --> 00:02:41,099
it to a meta function to every single

00:02:38,549 --> 00:02:42,420
element of a list and we also have

00:02:41,099 --> 00:02:44,760
compiled time strings which is basically

00:02:42,420 --> 00:02:46,290
a pipe that will represent a string this

00:02:44,760 --> 00:02:49,579
is not a runtime string that is

00:02:46,290 --> 00:02:51,900
allocated somewhere it's just a type

00:02:49,579 --> 00:02:54,419
usually a very attic type that's what we

00:02:51,900 --> 00:02:56,760
have in our implementation so I'm gonna

00:02:54,419 --> 00:02:58,379
abbreviate a few things just to make the

00:02:56,760 --> 00:03:00,780
code more readable so whenever you have

00:02:58,379 --> 00:03:02,609
a list of integrals instead of writing

00:03:00,780 --> 00:03:04,859
an integral cost all the time I'll just

00:03:02,609 --> 00:03:06,870
do it like this just because it's easier

00:03:04,859 --> 00:03:08,669
to read and also whenever you have a

00:03:06,870 --> 00:03:08,939
list of strings I will write it like

00:03:08,669 --> 00:03:13,260
this

00:03:08,939 --> 00:03:14,669
also too to make readability better so

00:03:13,260 --> 00:03:17,669
let's start with a first example with

00:03:14,669 --> 00:03:19,049
jason ugly printer I could write a

00:03:17,669 --> 00:03:21,840
pretty printer with proper indentation

00:03:19,049 --> 00:03:24,389
but that's besides the point like you

00:03:21,840 --> 00:03:26,280
can you like you don't need to know

00:03:24,389 --> 00:03:28,650
reflection in order to write a proper

00:03:26,280 --> 00:03:30,359
indenter so we'll take that out of the

00:03:28,650 --> 00:03:34,560
equation and focus only on the

00:03:30,359 --> 00:03:36,180
reflection usage this is the interface

00:03:34,560 --> 00:03:38,220
that we're aiming for so if you've real

00:03:36,180 --> 00:03:41,069
simple just a function print where you

00:03:38,220 --> 00:03:43,290
passed will you pass an instance of your

00:03:41,069 --> 00:03:45,599
object and we should figure things out

00:03:43,290 --> 00:03:47,849
and create it for you like this is very

00:03:45,599 --> 00:03:49,620
useful for debugging and given that it's

00:03:47,849 --> 00:03:52,560
Jason you can actually use for our

00:03:49,620 --> 00:03:55,979
things as well for simplicity I'll just

00:03:52,560 --> 00:03:59,669
write to sender see out but you could

00:03:55,979 --> 00:04:01,739
just send a an output string here or

00:03:59,669 --> 00:04:04,560
whatever that you want and just write to

00:04:01,739 --> 00:04:05,939
it instead so let's take a look at the

00:04:04,560 --> 00:04:07,590
implementation and what what would this

00:04:05,939 --> 00:04:09,449
function look like

00:04:07,590 --> 00:04:11,459
we start by reflection that they're

00:04:09,449 --> 00:04:13,829
reflecting the type class of this type

00:04:11,459 --> 00:04:16,289
so basically what does that mean is is

00:04:13,829 --> 00:04:18,930
it a integral is it a floating point

00:04:16,289 --> 00:04:22,469
enumeration is it a struct is it a list

00:04:18,930 --> 00:04:24,330
a map or what is it the reason we need

00:04:22,469 --> 00:04:26,159
this is basically because we will

00:04:24,330 --> 00:04:26,670
implement this the the pretty printer in

00:04:26,159 --> 00:04:28,200
one way

00:04:26,670 --> 00:04:30,300
for lists and in a different way for

00:04:28,200 --> 00:04:31,920
structs list don't have members that you

00:04:30,300 --> 00:04:34,410
have to wider eight over just elements

00:04:31,920 --> 00:04:36,390
there are no genius whereas the

00:04:34,410 --> 00:04:37,980
structure have like may have several

00:04:36,390 --> 00:04:40,890
different members with different types

00:04:37,980 --> 00:04:44,880
in an integral Tony doesn't even have

00:04:40,890 --> 00:04:46,710
members is just number and the way we're

00:04:44,880 --> 00:04:48,600
gonna do it is by delegating the

00:04:46,710 --> 00:04:52,740
implementation to some other template

00:04:48,600 --> 00:04:55,380
much very similar to what type traits do

00:04:52,740 --> 00:04:57,630
in C++ so basically say give me the

00:04:55,380 --> 00:04:59,010
specialization of greater for this

00:04:57,630 --> 00:05:00,930
particular type class so I want a

00:04:59,010 --> 00:05:03,270
printer for structs I want a printer for

00:05:00,930 --> 00:05:05,280
integers something like that and then we

00:05:03,270 --> 00:05:08,370
just call the method print passing the

00:05:05,280 --> 00:05:11,130
object that we want to print so let's

00:05:08,370 --> 00:05:14,400
take a look at the general case for the

00:05:11,130 --> 00:05:17,340
printer so ideally we would just do this

00:05:14,400 --> 00:05:18,840
sim simply pass it to sender see out it

00:05:17,340 --> 00:05:19,320
will just print whatever we want and

00:05:18,840 --> 00:05:21,930
we're done

00:05:19,320 --> 00:05:25,170
this works really well for integers for

00:05:21,930 --> 00:05:28,640
doubles but it doesn't work really well

00:05:25,170 --> 00:05:34,290
for lists or for maps or structures

00:05:28,640 --> 00:05:39,720
unless we have written an overload for

00:05:34,290 --> 00:05:41,760
the shift operator but for integers it

00:05:39,720 --> 00:05:44,190
works pretty well so let's leave it at

00:05:41,760 --> 00:05:46,470
that for now for billions we want a

00:05:44,190 --> 00:05:48,330
slightly different format we want to

00:05:46,470 --> 00:05:50,970
write through enforce instead of one

00:05:48,330 --> 00:05:53,040
zero we could use blue alpha but we're

00:05:50,970 --> 00:05:55,380
just not going to do it because just for

00:05:53,040 --> 00:05:57,810
the sake of an example so we just write

00:05:55,380 --> 00:06:01,140
an overload football and there we have

00:05:57,810 --> 00:06:04,020
it so the next thing is strings how do

00:06:01,140 --> 00:06:06,690
we write strings ideal we have to devote

00:06:04,020 --> 00:06:09,840
to quote them because that's the format

00:06:06,690 --> 00:06:11,850
the Jason accepts so we write a

00:06:09,840 --> 00:06:13,020
specialization for Strings that's just a

00:06:11,850 --> 00:06:15,450
template specializations for a

00:06:13,020 --> 00:06:17,040
specialization for printer so whenever

00:06:15,450 --> 00:06:21,080
the type class is a string this is

00:06:17,040 --> 00:06:23,670
what's going to be called and we just

00:06:21,080 --> 00:06:26,010
write the print function and what it

00:06:23,670 --> 00:06:30,240
does is price the quotes right the value

00:06:26,010 --> 00:06:31,710
right the the ending quote proper

00:06:30,240 --> 00:06:33,660
implementation of this would escape the

00:06:31,710 --> 00:06:36,300
string because we might have double

00:06:33,660 --> 00:06:37,980
quotes in the string itself but a for

00:06:36,300 --> 00:06:39,800
the sake of simplicity we're just not

00:06:37,980 --> 00:06:41,570
going to do it in assume it's

00:06:39,800 --> 00:06:43,490
like there would be no invalidating

00:06:41,570 --> 00:06:45,500
strings you could simply write it an

00:06:43,490 --> 00:06:48,500
escape function here and say escape what

00:06:45,500 --> 00:06:50,020
and we just work but let's leave it at

00:06:48,500 --> 00:06:53,270
that

00:06:50,020 --> 00:06:55,520
so let's look at lists now basically

00:06:53,270 --> 00:06:57,320
this is the form of all live lifts when

00:06:55,520 --> 00:07:00,230
it comes to Jason you start with a

00:06:57,320 --> 00:07:04,130
square bracket and you write every

00:07:00,230 --> 00:07:05,600
single element separated by a coma it

00:07:04,130 --> 00:07:06,980
doesn't have to be strings it can be any

00:07:05,600 --> 00:07:08,990
single optional there could be

00:07:06,980 --> 00:07:10,880
structures could be other lists but this

00:07:08,990 --> 00:07:12,350
is just an example so what we're gonna

00:07:10,880 --> 00:07:15,020
do is we're gonna specialize the

00:07:12,350 --> 00:07:19,460
template for lists for the list type

00:07:15,020 --> 00:07:22,490
class and you please note that the list

00:07:19,460 --> 00:07:25,940
itself receives the type class of the

00:07:22,490 --> 00:07:28,040
object it contains so it may not makes a

00:07:25,940 --> 00:07:30,500
lot of sense now but it's very handy

00:07:28,040 --> 00:07:32,450
when it comes to printing the object

00:07:30,500 --> 00:07:36,320
that is containing the list we're gonna

00:07:32,450 --> 00:07:40,130
make use of this shortly next step is to

00:07:36,320 --> 00:07:41,960
basically print the braces and then we

00:07:40,130 --> 00:07:45,740
want to iterate over a list just like we

00:07:41,960 --> 00:07:48,620
normally do we're gonna handle the

00:07:45,740 --> 00:07:50,350
limiters just make sure we're gonna fill

00:07:48,620 --> 00:07:55,040
in every single element with commas

00:07:50,350 --> 00:07:57,020
that's nothing new like and right after

00:07:55,040 --> 00:07:58,940
we call the proper specialization of

00:07:57,020 --> 00:08:01,580
printer for the type class of the

00:07:58,940 --> 00:08:03,919
containing element so basically we write

00:08:01,580 --> 00:08:05,960
we are on the list list specialization

00:08:03,919 --> 00:08:08,479
and whatever we have inside the list

00:08:05,960 --> 00:08:13,340
we're gonna delegate to that to properly

00:08:08,479 --> 00:08:15,979
print this object so the next next thing

00:08:13,340 --> 00:08:17,360
is sets like how do we print sets the

00:08:15,979 --> 00:08:20,150
format that I chose is basically the

00:08:17,360 --> 00:08:22,910
same as lists so let's see how we do

00:08:20,150 --> 00:08:25,460
that it's pretty much the same thing you

00:08:22,910 --> 00:08:27,740
specialize per sets you have a type

00:08:25,460 --> 00:08:29,270
class of the contained element and then

00:08:27,740 --> 00:08:30,530
you can simply delegate to the list I

00:08:29,270 --> 00:08:32,510
mean it's pretty much the same thing

00:08:30,530 --> 00:08:35,270
same thing so why we implement that

00:08:32,510 --> 00:08:38,960
right it will make a difference

00:08:35,270 --> 00:08:41,990
later because the interface of the

00:08:38,960 --> 00:08:44,060
awfulest and a set is not the same well

00:08:41,990 --> 00:08:47,780
a vector for instance has in place back

00:08:44,060 --> 00:08:50,330
a set has in place so we will specialize

00:08:47,780 --> 00:08:53,210
properly later but for now it's this

00:08:50,330 --> 00:08:55,610
should be fine the next example is maps

00:08:53,210 --> 00:08:57,860
basically there's a format of a map you

00:08:55,610 --> 00:08:59,899
have a curly braces and then you have

00:08:57,860 --> 00:09:02,750
the keys separated from the u values

00:08:59,899 --> 00:09:04,990
like : and then the elements are

00:09:02,750 --> 00:09:07,730
separated by a coma

00:09:04,990 --> 00:09:10,339
what we do now is we specialized for map

00:09:07,730 --> 00:09:12,410
and just like we did for lists we

00:09:10,339 --> 00:09:16,130
receive the type class of the key and

00:09:12,410 --> 00:09:17,990
the value contained in a map the rest is

00:09:16,130 --> 00:09:21,589
pretty much the same you write the curly

00:09:17,990 --> 00:09:24,649
braces you write the for loop you write

00:09:21,589 --> 00:09:26,330
the coma separators you write the colon

00:09:24,649 --> 00:09:29,899
separators for our key and value and

00:09:26,330 --> 00:09:33,500
then you delegate to print off whatever

00:09:29,899 --> 00:09:35,899
the key and the value type is please

00:09:33,500 --> 00:09:39,410
note that by using the specialization

00:09:35,899 --> 00:09:41,149
here for printer you can write the the

00:09:39,410 --> 00:09:43,550
specialization for each type class

00:09:41,149 --> 00:09:45,380
independent of each other you don't need

00:09:43,550 --> 00:09:47,000
to change the implementation of ant to

00:09:45,380 --> 00:09:49,010
support a new type you just add a new

00:09:47,000 --> 00:09:50,360
specialisation you're done so the

00:09:49,010 --> 00:09:53,810
advantage of that is that you can even

00:09:50,360 --> 00:09:56,720
specialize in different headers but it's

00:09:53,810 --> 00:09:59,450
just one reason but you can use any

00:09:56,720 --> 00:10:01,459
other implementation design you you want

00:09:59,450 --> 00:10:04,580
to go with but this is what we choose

00:10:01,459 --> 00:10:06,529
for what we chose for this example the

00:10:04,580 --> 00:10:08,510
next thing is how to clean an enum like

00:10:06,529 --> 00:10:10,580
there are several solutions out there

00:10:08,510 --> 00:10:12,350
too like how do we figure out what's

00:10:10,580 --> 00:10:15,170
this thing string representation of an

00:10:12,350 --> 00:10:19,070
enum right so that's why most people

00:10:15,170 --> 00:10:20,959
just use the integer representation we

00:10:19,070 --> 00:10:23,270
created that what I chose instead to use

00:10:20,959 --> 00:10:25,910
the string just to show you how we can

00:10:23,270 --> 00:10:28,400
do that how you can convert an enum to

00:10:25,910 --> 00:10:30,040
do strong representation in itself it's

00:10:28,400 --> 00:10:32,959
much the same thing we have a

00:10:30,040 --> 00:10:35,060
specialization for enumeration and then

00:10:32,959 --> 00:10:37,310
we want to see out with the quotes and

00:10:35,060 --> 00:10:40,160
we call this function called enum to

00:10:37,310 --> 00:10:43,459
string what this function does is just

00:10:40,160 --> 00:10:46,940
imagine a giant switch case from the

00:10:43,459 --> 00:10:48,230
enum itself to string there is a

00:10:46,940 --> 00:10:50,240
guarantee that this train will be

00:10:48,230 --> 00:10:53,300
statically allocated so you don't have

00:10:50,240 --> 00:10:54,829
to manage lifetime of it it's you can

00:10:53,300 --> 00:10:57,380
simply rely that it is stored somewhere

00:10:54,829 --> 00:10:59,959
and it's the lifetime is valid for the

00:10:57,380 --> 00:11:02,150
duration of the program this is also

00:10:59,959 --> 00:11:04,910
useful due to the aesthetic

00:11:02,150 --> 00:11:06,619
initialization order Fiasco we had a lot

00:11:04,910 --> 00:11:09,049
of problems at Facebook with that

00:11:06,619 --> 00:11:13,009
but you can rest assure that at least

00:11:09,049 --> 00:11:15,289
this part is safe and the next thing is

00:11:13,009 --> 00:11:17,509
the structure like how do you how do you

00:11:15,289 --> 00:11:21,229
infer what the members of the structure

00:11:17,509 --> 00:11:23,539
are how to why trait over them and how

00:11:21,229 --> 00:11:25,459
do we properly print because stroke is

00:11:23,539 --> 00:11:28,009
basically it's represented just like a

00:11:25,459 --> 00:11:30,919
map in Jason with a different difference

00:11:28,009 --> 00:11:32,779
that it is heterogeneous so the members

00:11:30,919 --> 00:11:37,309
don't have to necessarily have the same

00:11:32,779 --> 00:11:38,569
type basically the same thing you will

00:11:37,309 --> 00:11:43,159
see that there's a recurring pattern

00:11:38,569 --> 00:11:44,209
here that's after a while the the part

00:11:43,159 --> 00:11:45,649
of the examples will become really

00:11:44,209 --> 00:11:47,749
boring because it's just a team the same

00:11:45,649 --> 00:11:49,849
thing if you feel like it's boring I've

00:11:47,749 --> 00:11:52,359
accomplished my goal because that

00:11:49,849 --> 00:11:55,279
basically means you don't have a lot of

00:11:52,359 --> 00:11:56,419
cognitive load you can simply just say

00:11:55,279 --> 00:11:58,189
well I know how to solve this problem

00:11:56,419 --> 00:11:59,869
let's just go ahead and do it let's

00:11:58,189 --> 00:12:01,729
focus on what really matters which is

00:11:59,869 --> 00:12:03,949
not figuring out how to iterate over

00:12:01,729 --> 00:12:07,699
types and what not it is to serve water

00:12:03,949 --> 00:12:10,970
problems so same thing you write the

00:12:07,699 --> 00:12:13,189
braces you reflect the struct so that's

00:12:10,970 --> 00:12:14,689
basically saying give me the information

00:12:13,189 --> 00:12:16,519
that you have for this particular struct

00:12:14,689 --> 00:12:19,519
I want to know what's this jackfruit

00:12:16,519 --> 00:12:21,229
actually structure that he has let's

00:12:19,519 --> 00:12:23,179
take a look at what that means

00:12:21,229 --> 00:12:25,159
so basically gives you things like

00:12:23,179 --> 00:12:27,529
what's the name of a struct as a

00:12:25,159 --> 00:12:30,019
compile-time string what are the members

00:12:27,529 --> 00:12:31,970
of the struct what are the annotations

00:12:30,019 --> 00:12:36,889
because trif allows you to annotate

00:12:31,970 --> 00:12:40,609
types members and whatnot and you could

00:12:36,889 --> 00:12:43,159
sorry and the member descriptors looked

00:12:40,609 --> 00:12:44,720
like this it's almost the same thing it

00:12:43,159 --> 00:12:47,539
tells you the name of the member not the

00:12:44,720 --> 00:12:48,979
type but the member itself it gives you

00:12:47,539 --> 00:12:50,269
the type of the member it gives you a

00:12:48,979 --> 00:12:53,059
getter function so that you don't have

00:12:50,269 --> 00:12:54,679
to say X dot foo you can simply say give

00:12:53,059 --> 00:12:55,939
me this getter and I'm just gonna use it

00:12:54,679 --> 00:12:57,829
I don't care what the name is I don't

00:12:55,939 --> 00:12:59,569
care what the identifier is I'm gonna

00:12:57,829 --> 00:13:02,449
strike that and write your generic code

00:12:59,569 --> 00:13:04,129
and also annotations just because thrift

00:13:02,449 --> 00:13:06,499
allows you to do that we're gonna arrest

00:13:04,129 --> 00:13:09,379
through some examples later that use

00:13:06,499 --> 00:13:12,499
annotations to perform some data mapping

00:13:09,379 --> 00:13:14,959
so that the goal is basically to say I

00:13:12,499 --> 00:13:17,899
want to change only the IDL and not the

00:13:14,959 --> 00:13:19,070
code that I write in C++ and the

00:13:17,899 --> 00:13:23,720
reflection framework we just

00:13:19,070 --> 00:13:25,640
your things all for you and then we now

00:13:23,720 --> 00:13:28,310
that we we know what it gives us we can

00:13:25,640 --> 00:13:30,110
simply say well I have to I to rate over

00:13:28,310 --> 00:13:32,450
the members but they have to know how to

00:13:30,110 --> 00:13:33,800
get the members first so give me the

00:13:32,450 --> 00:13:36,080
information you have four members and

00:13:33,800 --> 00:13:39,200
then I'm going to iterate over this type

00:13:36,080 --> 00:13:41,630
lists so the way you I trade over type

00:13:39,200 --> 00:13:43,040
list is very similar to the way you

00:13:41,630 --> 00:13:46,130
iterate over types

00:13:43,040 --> 00:13:47,510
oh sorry over values just not quite

00:13:46,130 --> 00:13:50,750
because we're dealing with types here

00:13:47,510 --> 00:13:53,690
not really values right but there is a

00:13:50,750 --> 00:13:57,410
helper function call for each to which

00:13:53,690 --> 00:13:59,450
you just pass a visitor and you say I

00:13:57,410 --> 00:14:02,660
trade over that and call the visitor

00:13:59,450 --> 00:14:05,720
passing the type every time you find a

00:14:02,660 --> 00:14:07,610
new type so for the first and the index

00:14:05,720 --> 00:14:10,880
at which this type appears so if you

00:14:07,610 --> 00:14:12,890
have asteroid compose of integer member

00:14:10,880 --> 00:14:15,560
a boolean member double member and float

00:14:12,890 --> 00:14:17,570
member energy will be the first member

00:14:15,560 --> 00:14:20,570
of the structure the boolean would be

00:14:17,570 --> 00:14:22,880
the sorry the boolean will be the second

00:14:20,570 --> 00:14:25,040
double will be the third and fourth will

00:14:22,880 --> 00:14:26,540
be the fourth and as you can see you can

00:14:25,040 --> 00:14:28,670
also pass additional arguments that

00:14:26,540 --> 00:14:30,950
would be forwarded to the visitor later

00:14:28,670 --> 00:14:32,570
so we don't have to manage you don't

00:14:30,950 --> 00:14:34,730
have to create stateful visitors you can

00:14:32,570 --> 00:14:36,980
simply say this is a visitor here like

00:14:34,730 --> 00:14:40,820
give me whatever arguments I has to for

00:14:36,980 --> 00:14:42,980
each and with that in mind we can simply

00:14:40,820 --> 00:14:46,250
say well I trait over that using for

00:14:42,980 --> 00:14:48,500
each and whenever you find a member call

00:14:46,250 --> 00:14:51,140
this visitor here and pass the member

00:14:48,500 --> 00:14:53,300
information to it and also of course the

00:14:51,140 --> 00:14:54,920
structure itself so let's take a look at

00:14:53,300 --> 00:14:56,690
how this visitor is implemented because

00:14:54,920 --> 00:14:58,850
every time it's called we want to figure

00:14:56,690 --> 00:15:02,660
out for this specific member what is the

00:14:58,850 --> 00:15:04,490
type and how do i how do i print it it

00:15:02,660 --> 00:15:06,470
received a member and the index like we

00:15:04,490 --> 00:15:08,570
saw before this is just boilerplate and

00:15:06,470 --> 00:15:11,660
we will also repeat for every single

00:15:08,570 --> 00:15:13,280
visitor you see but simply you receive

00:15:11,660 --> 00:15:16,070
the type information first as a tag

00:15:13,280 --> 00:15:18,850
either indexed or not and whatever

00:15:16,070 --> 00:15:21,950
arguments you you've passed to for each

00:15:18,850 --> 00:15:25,460
and then you can simply say if it's not

00:15:21,950 --> 00:15:28,730
the first element printed coma and also

00:15:25,460 --> 00:15:30,530
i want to print the name but the thing

00:15:28,730 --> 00:15:32,850
is that this name is a compile-time

00:15:30,530 --> 00:15:34,500
string but I need a runtime serine are

00:15:32,850 --> 00:15:36,899
right you needed to be somewhere your

00:15:34,500 --> 00:15:39,480
memory so what we do is we have this

00:15:36,899 --> 00:15:41,009
function called Z data and what it does

00:15:39,480 --> 00:15:43,259
is whenever you have a compile-time

00:15:41,009 --> 00:15:45,480
string it will give you a null

00:15:43,259 --> 00:15:47,730
terminated statically allocated string

00:15:45,480 --> 00:15:48,750
so it's pretty handy you just say for

00:15:47,730 --> 00:15:51,060
this compile time string give me

00:15:48,750 --> 00:15:52,829
something that I can use its runtime and

00:15:51,060 --> 00:15:55,620
that's how you convert compile time to

00:15:52,829 --> 00:15:57,089
Rend time strings and then you call

00:15:55,620 --> 00:15:59,040
together on the member that you can get

00:15:57,089 --> 00:16:03,029
from the metadata that you received from

00:15:59,040 --> 00:16:04,829
the from the for each and you can also

00:16:03,029 --> 00:16:06,569
get a type class for that member from

00:16:04,829 --> 00:16:09,300
this information and you simply delegate

00:16:06,569 --> 00:16:10,620
to the correct printer implementation

00:16:09,300 --> 00:16:13,350
and that's pretty much it

00:16:10,620 --> 00:16:16,470
you're just iterating over the members

00:16:13,350 --> 00:16:18,810
of structure and print and based on the

00:16:16,470 --> 00:16:20,420
correct type and type class word we're

00:16:18,810 --> 00:16:24,180
just calling the correct printer for it

00:16:20,420 --> 00:16:27,029
and the last thing is how do we create a

00:16:24,180 --> 00:16:29,130
variant so I expect you guys are also

00:16:27,029 --> 00:16:32,459
familiar with parents but basically it's

00:16:29,130 --> 00:16:38,790
a way to store at most one of different

00:16:32,459 --> 00:16:40,500
types in a specific container so there's

00:16:38,790 --> 00:16:43,560
which which is the name of what's stored

00:16:40,500 --> 00:16:46,889
there so say I want to store I have a

00:16:43,560 --> 00:16:49,589
variant of foo and bar who is int and

00:16:46,889 --> 00:16:51,630
bar is double and but at this specific

00:16:49,589 --> 00:16:54,839
time I want to store food in it which is

00:16:51,630 --> 00:16:56,399
an int so we're gonna print the the name

00:16:54,839 --> 00:16:59,100
of what store in there the name of the

00:16:56,399 --> 00:17:03,149
member and the value that's contained

00:16:59,100 --> 00:17:06,179
remember the way we reflect variants it

00:17:03,149 --> 00:17:08,309
is through a variant rates basically we

00:17:06,179 --> 00:17:11,579
can say instantiate the variant race for

00:17:08,309 --> 00:17:15,120
this participant and I can give it the

00:17:11,579 --> 00:17:17,370
name of the parent and also the ite

00:17:15,120 --> 00:17:20,819
which is basically the num dat tells you

00:17:17,370 --> 00:17:22,319
which type is stored there and you could

00:17:20,819 --> 00:17:26,220
say for instance print the name of this

00:17:22,319 --> 00:17:28,470
thing using Z data that we just saw it

00:17:26,220 --> 00:17:29,820
also gives you the scripters for each of

00:17:28,470 --> 00:17:31,919
the members that can be store in the

00:17:29,820 --> 00:17:35,340
variant this pretty similar to what the

00:17:31,919 --> 00:17:37,289
member descriptors are four struts only

00:17:35,340 --> 00:17:40,260
that variants only store one thing at at

00:17:37,289 --> 00:17:43,409
a time and while struts like have all

00:17:40,260 --> 00:17:45,900
the members at the same time and the

00:17:43,409 --> 00:17:46,680
scripture is a way to for you to

00:17:45,900 --> 00:17:48,840
abstract

00:17:46,680 --> 00:17:50,940
to the members themselves so just like

00:17:48,840 --> 00:17:52,830
strict members it gives you the type of

00:17:50,940 --> 00:17:56,130
the member the idea of that specific

00:17:52,830 --> 00:17:58,650
member so enum value acts is going to

00:17:56,130 --> 00:18:00,420
represent the specific member and also a

00:17:58,650 --> 00:18:01,590
getter so that you pass the parent to it

00:18:00,420 --> 00:18:03,810
and it returns a reference to that

00:18:01,590 --> 00:18:06,120
specific member and a setter so you can

00:18:03,810 --> 00:18:08,670
actually set values in it so this pretty

00:18:06,120 --> 00:18:10,140
much abstracts access to the variants so

00:18:08,670 --> 00:18:14,130
you can simply write generic code in

00:18:10,140 --> 00:18:16,290
order to use it and an example of it is

00:18:14,130 --> 00:18:18,570
say you have some instance of a variant

00:18:16,290 --> 00:18:20,250
and you have you've obtained the

00:18:18,570 --> 00:18:22,440
descriptor somehow to a specific member

00:18:20,250 --> 00:18:24,660
you want to get the value of that member

00:18:22,440 --> 00:18:26,580
from the parent that's what you do and

00:18:24,660 --> 00:18:27,960
if you want to be sure we can check if

00:18:26,580 --> 00:18:30,360
the value that's stored in the variant

00:18:27,960 --> 00:18:35,580
is the same represented by this

00:18:30,360 --> 00:18:36,990
descriptor so let's see let's take a

00:18:35,580 --> 00:18:38,550
look at how we implement a printer for a

00:18:36,990 --> 00:18:43,710
variant then with that information in

00:18:38,550 --> 00:18:45,420
mind we we write the braces and from the

00:18:43,710 --> 00:18:48,210
type that's stored there this is an enum

00:18:45,420 --> 00:18:50,220
value this is a runtime value we want to

00:18:48,210 --> 00:18:52,770
figure out what what's the descriptor

00:18:50,220 --> 00:18:55,410
for this particular member

00:18:52,770 --> 00:18:57,690
that's store in the UNAM and this is a

00:18:55,410 --> 00:18:59,760
type so we have to go from a runtime

00:18:57,690 --> 00:19:01,320
value to a type but the problem is that

00:18:59,760 --> 00:19:04,200
a runtime we don't have type information

00:19:01,320 --> 00:19:06,690
right so how do you how do you figure

00:19:04,200 --> 00:19:08,250
that out and it's pretty much what we

00:19:06,690 --> 00:19:11,520
did before it's basically with visitors

00:19:08,250 --> 00:19:13,800
but we need a way to to do that

00:19:11,520 --> 00:19:16,410
efficiently so we imagine you have some

00:19:13,800 --> 00:19:19,020
type we have members foo and bar and you

00:19:16,410 --> 00:19:21,360
have a list of those types with proper

00:19:19,020 --> 00:19:25,110
values and you basically you have a

00:19:21,360 --> 00:19:28,050
needle which is a runtime value and you

00:19:25,110 --> 00:19:31,680
want to get the mem the the element in

00:19:28,050 --> 00:19:34,110
this type list hos value of foo is the

00:19:31,680 --> 00:19:35,580
same as the needle so use the matter

00:19:34,110 --> 00:19:39,000
function get type foo to basically

00:19:35,580 --> 00:19:42,060
filter the the element by by that

00:19:39,000 --> 00:19:44,490
specific member there's a thing called

00:19:42,060 --> 00:19:45,870
sort of search which is binary search

00:19:44,490 --> 00:19:49,650
that's basically it so we're gonna

00:19:45,870 --> 00:19:52,350
binary search the type list hope hoping

00:19:49,650 --> 00:19:55,230
to find a needle in there you pass the

00:19:52,350 --> 00:19:57,210
needle you pass a visitor the visitor

00:19:55,230 --> 00:19:59,220
will receive the type itself that's type

00:19:57,210 --> 00:20:00,269
information and you can also pass

00:19:59,220 --> 00:20:01,799
additional arguments

00:20:00,269 --> 00:20:08,369
pretty much the same pattern we've seen

00:20:01,799 --> 00:20:09,839
so far just for a different use case so

00:20:08,369 --> 00:20:12,029
we just do that we want to sort search

00:20:09,839 --> 00:20:14,669
based on the ID of what store in the

00:20:12,029 --> 00:20:17,159
variant but the problem is what if the

00:20:14,669 --> 00:20:18,269
list is not sorted but you cannot really

00:20:17,159 --> 00:20:19,379
bind you're searching something that's

00:20:18,269 --> 00:20:21,299
not certain so we need you need

00:20:19,379 --> 00:20:24,149
something to sort the list let's take a

00:20:21,299 --> 00:20:26,999
look at how we do that you imagine have

00:20:24,149 --> 00:20:30,659
the same list and again we want to sort

00:20:26,999 --> 00:20:33,149
by foo you just call the sort method

00:20:30,659 --> 00:20:35,839
function and it's gonna you pass a

00:20:33,149 --> 00:20:38,190
compare because we want a sending order

00:20:35,839 --> 00:20:41,279
and it's gonna return the list or it for

00:20:38,190 --> 00:20:43,169
you pretty much the same you know like

00:20:41,279 --> 00:20:45,929
very similar interface to well you you

00:20:43,169 --> 00:20:48,570
have in in the standard sort just now

00:20:45,929 --> 00:20:52,739
four types with that in mind we sort the

00:20:48,570 --> 00:20:55,649
list by ID and we pass this thing around

00:20:52,739 --> 00:20:57,389
to to sort of search and there you go

00:20:55,649 --> 00:20:59,489
and you pass the visitor that you want

00:20:57,389 --> 00:21:03,899
to be called if there's a match along

00:20:59,489 --> 00:21:05,849
with the variant itself and let's now

00:21:03,899 --> 00:21:07,859
see what's implementation for the

00:21:05,849 --> 00:21:10,859
visitor for a parent so basically have

00:21:07,859 --> 00:21:13,109
the member descriptor for whatever

00:21:10,859 --> 00:21:15,509
member is stored in the in a variant

00:21:13,109 --> 00:21:18,450
like and we don't really care about the

00:21:15,509 --> 00:21:21,539
index at this point so we basically

00:21:18,450 --> 00:21:22,979
write the string representation of what

00:21:21,539 --> 00:21:26,339
store there because it's basically the

00:21:22,979 --> 00:21:28,200
format with which shows we get a

00:21:26,339 --> 00:21:30,119
reference to what store in the parent

00:21:28,200 --> 00:21:33,839
because we need to be able to print

00:21:30,119 --> 00:21:36,089
whatever is store in there and we we

00:21:33,839 --> 00:21:38,549
delegate that to printer with the

00:21:36,089 --> 00:21:40,529
correct type class in a mine so whatever

00:21:38,549 --> 00:21:42,839
is stored there we're gonna forward it

00:21:40,529 --> 00:21:44,399
to the correct implementation and that's

00:21:42,839 --> 00:21:47,729
pretty much it that's how we implement

00:21:44,399 --> 00:21:50,639
us a Jason pretty printer using static

00:21:47,729 --> 00:21:53,219
reflection and no matter what types you

00:21:50,639 --> 00:21:55,969
come up with encrypt this we'll figure

00:21:53,219 --> 00:21:58,409
it out and we'll print it for you so

00:21:55,969 --> 00:21:59,969
compare that to some of the approaches

00:21:58,409 --> 00:22:02,190
people usually do which is like every

00:21:59,969 --> 00:22:05,339
time you write a new type and you say a

00:22:02,190 --> 00:22:08,309
new container or a new structure you

00:22:05,339 --> 00:22:10,409
have to somehow implement support for

00:22:08,309 --> 00:22:11,460
that in your pre printer with this at

00:22:10,409 --> 00:22:13,799
hand you don't really need to because

00:22:11,460 --> 00:22:15,570
trip will give that for free to you

00:22:13,799 --> 00:22:16,769
so we don't we don't we pretty much

00:22:15,570 --> 00:22:19,409
don't have to change the code for a

00:22:16,769 --> 00:22:23,179
printer ever again don't quote me on

00:22:19,409 --> 00:22:26,580
that so let's look at serialization now

00:22:23,179 --> 00:22:29,369
how could we write a serializer a

00:22:26,580 --> 00:22:31,379
serialize ER it's sort of the same

00:22:29,369 --> 00:22:34,139
structure as a pretty printer only now

00:22:31,379 --> 00:22:37,259
we have to deal with encoding and we

00:22:34,139 --> 00:22:39,090
have to also support a serialization so

00:22:37,259 --> 00:22:41,100
the way we're gonna do that I also want

00:22:39,090 --> 00:22:43,379
a pretty simple interface where you pass

00:22:41,100 --> 00:22:45,509
the the object that you want to

00:22:43,379 --> 00:22:47,220
serialize or deserialize and a data

00:22:45,509 --> 00:22:49,950
reader or do a writer that's gonna

00:22:47,220 --> 00:22:52,679
abstract transport or the buffer or

00:22:49,950 --> 00:22:56,340
whatever is the media that you decide to

00:22:52,679 --> 00:22:57,929
write this this data to so the data

00:22:56,340 --> 00:23:00,539
writer is gonna be dead like I'm not

00:22:57,929 --> 00:23:02,220
gonna go into the implementation for a

00:23:00,539 --> 00:23:04,320
better writer we're just gonna assume it

00:23:02,220 --> 00:23:06,480
works but basically you write raw will

00:23:04,320 --> 00:23:08,460
write the by the byte representation of

00:23:06,480 --> 00:23:11,700
the integer so if you have to deal with

00:23:08,460 --> 00:23:14,669
engine s or are encoding this should be

00:23:11,700 --> 00:23:16,529
the place and right string will we write

00:23:14,669 --> 00:23:17,850
strings for you of the specific type so

00:23:16,529 --> 00:23:21,119
as you can imagine you would write the

00:23:17,850 --> 00:23:22,379
size of a string and you would write the

00:23:21,119 --> 00:23:24,600
data of the underlined date of the

00:23:22,379 --> 00:23:26,429
string that could be its rightful raw so

00:23:24,600 --> 00:23:29,039
I was talking to to some guys about

00:23:26,429 --> 00:23:31,850
Prada both before this talk we could

00:23:29,039 --> 00:23:38,009
extend this data rider to say emit

00:23:31,850 --> 00:23:39,600
protobuf the probe of layout format when

00:23:38,009 --> 00:23:41,759
i need a little chaff you change this

00:23:39,600 --> 00:23:43,710
but we can do it and we also have a data

00:23:41,759 --> 00:23:46,259
reader too so we can read the things we

00:23:43,710 --> 00:23:48,389
wrote with a theater writer this is not

00:23:46,259 --> 00:23:50,340
very interesting for reflection itself

00:23:48,389 --> 00:23:53,190
but is going to be what we're gonna use

00:23:50,340 --> 00:23:55,080
for our serializer so let's see how we

00:23:53,190 --> 00:23:58,440
implement a serialize ER pretty much the

00:23:55,080 --> 00:24:00,359
same thing as the Chasen player we

00:23:58,440 --> 00:24:03,570
figure out the type class of whatever we

00:24:00,359 --> 00:24:07,100
have and we afford it to the sterilizer

00:24:03,570 --> 00:24:09,570
the proper sterilizer specialization

00:24:07,100 --> 00:24:13,559
calling either serialize or DC relies

00:24:09,570 --> 00:24:15,299
passing along their writer or reader so

00:24:13,559 --> 00:24:17,070
then general the general case is pretty

00:24:15,299 --> 00:24:20,100
much like integers and doubles what do

00:24:17,070 --> 00:24:23,999
we do we write it wrong and we really

00:24:20,100 --> 00:24:27,730
wrong and that's it first rains we write

00:24:23,999 --> 00:24:30,340
a string read the string no big deal

00:24:27,730 --> 00:24:32,559
for enumeration we write the string

00:24:30,340 --> 00:24:35,770
representation of Tina just because we

00:24:32,559 --> 00:24:38,140
show we chose to and you read the string

00:24:35,770 --> 00:24:42,309
representation of enum any want to parse

00:24:38,140 --> 00:24:45,700
it so this feature here like enum traits

00:24:42,309 --> 00:24:49,270
: parse it's basically a way to convert

00:24:45,700 --> 00:24:52,230
from a string to an enum value it is

00:24:49,270 --> 00:24:55,750
pretty efficient internally it builds a

00:24:52,230 --> 00:24:57,870
try at compile time which is very

00:24:55,750 --> 00:25:00,100
efficient for a strange lookup and

00:24:57,870 --> 00:25:01,570
whenever there's a match returns the

00:25:00,100 --> 00:25:03,970
value associated with each of the

00:25:01,570 --> 00:25:07,059
compile time strings and there you go

00:25:03,970 --> 00:25:15,160
you will sign that enum value to the

00:25:07,059 --> 00:25:17,770
output of the serialize Oh in this case

00:25:15,160 --> 00:25:19,419
parse we'll just throw we have order

00:25:17,770 --> 00:25:21,330
we have other very versions that don't

00:25:19,419 --> 00:25:25,270
throw we will return you an error code

00:25:21,330 --> 00:25:31,000
for this specific example it's this this

00:25:25,270 --> 00:25:32,620
efficient so for lists it's it's not

00:25:31,000 --> 00:25:32,980
that difficult you write the size of the

00:25:32,620 --> 00:25:35,169
list

00:25:32,980 --> 00:25:38,500
I trait on the list and write every

00:25:35,169 --> 00:25:40,660
single element delegating a proper

00:25:38,500 --> 00:25:42,340
serialize ur and this realize you

00:25:40,660 --> 00:25:45,580
basically you read the size I'd read

00:25:42,340 --> 00:25:48,640
that many times create an element at the

00:25:45,580 --> 00:25:51,340
end of the list this realized to that

00:25:48,640 --> 00:25:55,390
element you just created and it's pretty

00:25:51,340 --> 00:25:58,690
much it this is not a very good API for

00:25:55,390 --> 00:26:00,490
lists other than instant vector so if

00:25:58,690 --> 00:26:02,130
you use a stud string for instance it's

00:26:00,490 --> 00:26:04,540
not gonna work because not the same API

00:26:02,130 --> 00:26:06,460
we have we have something we call

00:26:04,540 --> 00:26:08,440
container traits in the reflection API

00:26:06,460 --> 00:26:10,690
that will abstract for you that for us

00:26:08,440 --> 00:26:13,630
as well but just for readability

00:26:10,690 --> 00:26:15,880
purposes I didn't use it here I will

00:26:13,630 --> 00:26:16,929
upload more demos later to the code base

00:26:15,880 --> 00:26:19,809
so you can take a look if you're

00:26:16,929 --> 00:26:22,270
interested but it's container traces is

00:26:19,809 --> 00:26:23,830
basically a way to say abstract the

00:26:22,270 --> 00:26:25,630
containers as well so I don't have to

00:26:23,830 --> 00:26:29,309
know what's the underlying plantation

00:26:25,630 --> 00:26:32,140
and you are able to to register your own

00:26:29,309 --> 00:26:33,940
user-defined container and say this is

00:26:32,140 --> 00:26:36,309
my container this is the trades class

00:26:33,940 --> 00:26:41,309
for it so the reflection subsystem can

00:26:36,309 --> 00:26:42,330
can use that and for sets its

00:26:41,309 --> 00:26:46,610
pretty much the same thing right the

00:26:42,330 --> 00:26:50,820
size I trade serialized breed the size

00:26:46,610 --> 00:26:55,169
I'd rate is realizing to a local element

00:26:50,820 --> 00:26:57,509
and then you place that into the set for

00:26:55,169 --> 00:27:01,249
maps also the same thing right the size

00:26:57,509 --> 00:27:05,100
either eight right the key right a value

00:27:01,249 --> 00:27:08,039
read the size hydrate this utilize the

00:27:05,100 --> 00:27:10,379
key into a lock of that object create

00:27:08,039 --> 00:27:14,509
the element in a map moving the key

00:27:10,379 --> 00:27:17,340
either and just this year lies into it

00:27:14,509 --> 00:27:20,009
so the next thing is searchers how do we

00:27:17,340 --> 00:27:21,840
serialize the structures we know we have

00:27:20,009 --> 00:27:23,720
the information for the members so we

00:27:21,840 --> 00:27:26,970
can simply say for each on that thing

00:27:23,720 --> 00:27:30,499
passes a visitor that will utilize that

00:27:26,970 --> 00:27:34,259
for you the members of a specific struck

00:27:30,499 --> 00:27:36,690
so we can rely on that for prediction

00:27:34,259 --> 00:27:38,909
really cool you actually you might

00:27:36,690 --> 00:27:41,999
actually change that so we we could

00:27:38,909 --> 00:27:45,450
decide to write a specific identifier

00:27:41,999 --> 00:27:47,009
for for the that member and say and

00:27:45,450 --> 00:27:49,499
later we can say whenever you're the

00:27:47,009 --> 00:27:52,309
serializing check if this identifier

00:27:49,499 --> 00:27:54,749
matches something in the strand destruct

00:27:52,309 --> 00:27:57,149
we have this information available in

00:27:54,749 --> 00:27:58,860
the annotation you can take a look at

00:27:57,149 --> 00:28:00,210
this utilization civilization code that

00:27:58,860 --> 00:28:02,220
we have for drift if you were

00:28:00,210 --> 00:28:04,049
interesting that but again for the sake

00:28:02,220 --> 00:28:06,600
of simplicity and for time constraint so

00:28:04,049 --> 00:28:08,509
you haven't done it here and now let's

00:28:06,600 --> 00:28:11,070
take a look at the serial Iser visitor

00:28:08,509 --> 00:28:12,509
take the member with the member

00:28:11,070 --> 00:28:16,169
information you get a reference to the

00:28:12,509 --> 00:28:17,249
value you see realize that value and you

00:28:16,169 --> 00:28:20,279
need to figure out the type class as

00:28:17,249 --> 00:28:21,749
well and there you go so most of it is

00:28:20,279 --> 00:28:23,279
just figuring out the type class getting

00:28:21,749 --> 00:28:24,059
a reference and passing it around that's

00:28:23,279 --> 00:28:27,450
pretty much it

00:28:24,059 --> 00:28:31,289
like I said it should be boring this

00:28:27,450 --> 00:28:33,090
realized same thing you you get the

00:28:31,289 --> 00:28:35,399
members you for you write a foreach loop

00:28:33,090 --> 00:28:36,570
you pass around to a visitor and that's

00:28:35,399 --> 00:28:38,999
it

00:28:36,570 --> 00:28:42,350
get the reference the serializing to it

00:28:38,999 --> 00:28:48,529
and figure out the correct

00:28:42,350 --> 00:28:48,529
specialization for variant serialization

00:28:48,830 --> 00:28:53,039
first we have the type itself pretty

00:28:51,779 --> 00:28:54,910
pretty soon this is going to be pretty

00:28:53,039 --> 00:28:57,550
similar to what we did for

00:28:54,910 --> 00:28:58,750
for a pretty printer you have to type

00:28:57,550 --> 00:29:01,030
you have to figure out of the street

00:28:58,750 --> 00:29:03,070
descriptor do whatever we've done before

00:29:01,030 --> 00:29:08,260
which is sort this thing find research

00:29:03,070 --> 00:29:10,860
into it call a koala a visitor but a

00:29:08,260 --> 00:29:13,630
thing is what if the variant is empty or

00:29:10,860 --> 00:29:15,220
like yeah that's pretty much the case if

00:29:13,630 --> 00:29:16,840
the variance ape is empty then sort of

00:29:15,220 --> 00:29:19,090
search will return it or true if it

00:29:16,840 --> 00:29:20,800
finds a match or false if you didn't

00:29:19,090 --> 00:29:23,080
find any match inside the type list of

00:29:20,800 --> 00:29:25,090
members in this case let's say we're

00:29:23,080 --> 00:29:26,530
gonna write an empty string to say hey

00:29:25,090 --> 00:29:28,690
there's nothing written there's nothing

00:29:26,530 --> 00:29:32,050
there assume this is gonna be an empty

00:29:28,690 --> 00:29:35,530
parent and this is the serialize er

00:29:32,050 --> 00:29:38,440
visitor for the parent we have the name

00:29:35,530 --> 00:29:40,390
here that we get from the member

00:29:38,440 --> 00:29:45,070
metadata and we have to write that as a

00:29:40,390 --> 00:29:46,810
string so z data the rescue the data

00:29:45,070 --> 00:29:49,120
gives us gives us the contents but we

00:29:46,810 --> 00:29:51,640
also need the size of the string right

00:29:49,120 --> 00:29:53,680
so size is basically what like you pass

00:29:51,640 --> 00:29:55,570
any compile-time container be a type

00:29:53,680 --> 00:29:58,630
list or a compile-time string returns

00:29:55,570 --> 00:30:02,530
you in interval constant with the size

00:29:58,630 --> 00:30:05,220
of that container and there we go you

00:30:02,530 --> 00:30:08,140
can write the contents of that string

00:30:05,220 --> 00:30:10,450
and then you have to get a reference to

00:30:08,140 --> 00:30:13,380
the to the variant remember serialize

00:30:10,450 --> 00:30:16,420
pass around there we go

00:30:13,380 --> 00:30:21,970
this realization you read the string

00:30:16,420 --> 00:30:25,510
representing what's in there you okay so

00:30:21,970 --> 00:30:27,970
here's the thing from the string you

00:30:25,510 --> 00:30:32,020
have to figure out what's the what's the

00:30:27,970 --> 00:30:34,060
in a member of what's stored in there we

00:30:32,020 --> 00:30:37,300
could for instance parse this string

00:30:34,060 --> 00:30:40,270
into an enum and then you sort of search

00:30:37,300 --> 00:30:42,490
like we did before but that will not be

00:30:40,270 --> 00:30:45,640
ideal it would be much better if we

00:30:42,490 --> 00:30:49,000
could just perform the lookup from the

00:30:45,640 --> 00:30:51,130
string itself right so we want to look

00:30:49,000 --> 00:30:52,810
up in the names of the members of the

00:30:51,130 --> 00:30:55,180
variant we don't want to have to convert

00:30:52,810 --> 00:30:57,550
that to a now to an enum and then do it

00:30:55,180 --> 00:31:00,100
there so how do we go from a

00:30:57,550 --> 00:31:01,180
compile-time straining to the sorry from

00:31:00,100 --> 00:31:03,550
our runtime string to a compile-time

00:31:01,180 --> 00:31:05,110
string it is somewhat similar to what we

00:31:03,550 --> 00:31:07,640
did with sort a search but instead of

00:31:05,110 --> 00:31:09,650
when you search we're going to build

00:31:07,640 --> 00:31:11,750
searcher so say you have a list with a

00:31:09,650 --> 00:31:14,000
few of compile-time strings and a needle

00:31:11,750 --> 00:31:15,920
which is a run-time string and you want

00:31:14,000 --> 00:31:19,070
to look it up

00:31:15,920 --> 00:31:21,170
so basically call it try find and what

00:31:19,070 --> 00:31:23,750
it does like a mission before it compile

00:31:21,170 --> 00:31:27,800
it creates a try data structure based on

00:31:23,750 --> 00:31:29,660
those strings at compile time and it

00:31:27,800 --> 00:31:31,550
basically looks at the needle up this

00:31:29,660 --> 00:31:33,110
should be pretty efficient I have some

00:31:31,550 --> 00:31:36,680
benchmarks showing that is much faster

00:31:33,110 --> 00:31:41,210
than say looking up in a map or NASA IFS

00:31:36,680 --> 00:31:44,330
or whatever or even building a runtime

00:31:41,210 --> 00:31:45,950
try and looking it up pass to the

00:31:44,330 --> 00:31:49,040
visitor the visitor will be called with

00:31:45,950 --> 00:31:50,630
this string if there's a match and will

00:31:49,040 --> 00:31:53,000
pass along any of the show arguments you

00:31:50,630 --> 00:31:55,070
have same thing we said before and we're

00:31:53,000 --> 00:31:56,510
also returning a boolean if they were

00:31:55,070 --> 00:32:00,110
telling you whether there was a match or

00:31:56,510 --> 00:32:03,170
not and then with that in mind we can

00:32:00,110 --> 00:32:05,090
call try fine so we come we pass the

00:32:03,170 --> 00:32:08,750
string to it so we will perform the

00:32:05,090 --> 00:32:11,450
correct lookup and we pass the visitor

00:32:08,750 --> 00:32:15,610
to it and if it's not found it means

00:32:11,450 --> 00:32:18,080
whatever was whatever was in the blob

00:32:15,610 --> 00:32:20,090
doesn't represent a valid member of this

00:32:18,080 --> 00:32:23,350
variant so this will happen if we have

00:32:20,090 --> 00:32:26,180
an empty if we serialize an empty event

00:32:23,350 --> 00:32:28,610
or it could also happen with we have an

00:32:26,180 --> 00:32:30,170
invalid value there like whatever but we

00:32:28,610 --> 00:32:32,000
don't really care about that right now

00:32:30,170 --> 00:32:34,520
in this example and in this case just

00:32:32,000 --> 00:32:40,160
clear this the variant like just make it

00:32:34,520 --> 00:32:41,840
empty so this here eliezer we don't note

00:32:40,160 --> 00:32:44,600
that we don't receive the member

00:32:41,840 --> 00:32:47,630
descriptor here we receive a name of the

00:32:44,600 --> 00:32:50,660
member so we have to go from this name

00:32:47,630 --> 00:32:52,520
to the member itself so it would be good

00:32:50,660 --> 00:32:55,820
if we could perform some lookup by name

00:32:52,520 --> 00:32:57,440
in the variant descriptor and say give

00:32:55,820 --> 00:32:59,840
me whatever member information you have

00:32:57,440 --> 00:33:02,060
for this specific name here that's what

00:32:59,840 --> 00:33:03,410
we do here so we use reflect parent to

00:33:02,060 --> 00:33:06,140
get the information for the parent and

00:33:03,410 --> 00:33:08,500
it provides us by name helper that we

00:33:06,140 --> 00:33:10,850
can use for for that purpose and then

00:33:08,500 --> 00:33:14,090
you initialize that member inside a

00:33:10,850 --> 00:33:16,250
parent like the foe constructed just so

00:33:14,090 --> 00:33:18,650
we have the correct the correct type

00:33:16,250 --> 00:33:20,420
setting there we do serialize into that

00:33:18,650 --> 00:33:20,880
into that thing but we need a reference

00:33:20,420 --> 00:33:22,800
to

00:33:20,880 --> 00:33:26,850
so we use get to get a reference to it

00:33:22,800 --> 00:33:28,710
that's it along there we go now we have

00:33:26,850 --> 00:33:31,260
this deserialization for parent members

00:33:28,710 --> 00:33:32,490
and there you have it like you have a

00:33:31,260 --> 00:33:37,530
full serializer

00:33:32,490 --> 00:33:40,080
and working condition so the next and

00:33:37,530 --> 00:33:43,080
final example is about like untyped data

00:33:40,080 --> 00:33:47,370
translation say you have a map string to

00:33:43,080 --> 00:33:49,680
string like very like very common data

00:33:47,370 --> 00:33:52,290
and this happens a lot in cold actually

00:33:49,680 --> 00:33:56,760
and assume there's a structure to it

00:33:52,290 --> 00:33:59,070
this is just like a fantasy example but

00:33:56,760 --> 00:34:02,910
uh assume you have information like host

00:33:59,070 --> 00:34:04,920
name host port and whatnot since you

00:34:02,910 --> 00:34:07,110
have a map and a map is a mad genius in

00:34:04,920 --> 00:34:09,030
a types it represents you you have to

00:34:07,110 --> 00:34:12,000
represent everything as a string the

00:34:09,030 --> 00:34:13,260
thing is for one if I set something in

00:34:12,000 --> 00:34:16,110
the map I'm not sure I'm using the

00:34:13,260 --> 00:34:19,140
correct key like M did I spell host port

00:34:16,110 --> 00:34:22,380
correctly or did I make a typo like how

00:34:19,140 --> 00:34:24,300
do I catch this error and also is my

00:34:22,380 --> 00:34:26,490
number well-formed like am i passing

00:34:24,300 --> 00:34:28,710
some weird strain there that does that

00:34:26,490 --> 00:34:30,750
so it would be nice if we could convert

00:34:28,710 --> 00:34:33,000
that to a typed representation of this

00:34:30,750 --> 00:34:34,920
thing so say you're migrating some API

00:34:33,000 --> 00:34:37,760
from the old map of string string to

00:34:34,920 --> 00:34:41,580
some to some new API that takes a

00:34:37,760 --> 00:34:43,560
structure instead like with actual type

00:34:41,580 --> 00:34:47,040
information how do you perform this

00:34:43,560 --> 00:34:50,310
mapping there should be a way for us to

00:34:47,040 --> 00:34:53,400
say well the member on the left is

00:34:50,310 --> 00:34:55,110
associated with the key on the right so

00:34:53,400 --> 00:34:58,370
whenever you find this member here

00:34:55,110 --> 00:35:00,930
that's the corresponding key in the map

00:34:58,370 --> 00:35:03,270
we can use annotations for that and

00:35:00,930 --> 00:35:06,030
tripped and say in the IDL this is the

00:35:03,270 --> 00:35:07,680
mapping so whenever you have to update

00:35:06,030 --> 00:35:11,160
the mapping itself either delete a

00:35:07,680 --> 00:35:13,140
member update a member room at a member

00:35:11,160 --> 00:35:15,060
you do everything in the IDL and the

00:35:13,140 --> 00:35:17,010
code should figure that out for you you

00:35:15,060 --> 00:35:18,510
don't have to change any code in order

00:35:17,010 --> 00:35:21,690
to do that so it's pretty scalable

00:35:18,510 --> 00:35:23,070
because you change in a single place you

00:35:21,690 --> 00:35:24,750
don't have to repeat yourself over and

00:35:23,070 --> 00:35:28,290
over and for the reason is not error

00:35:24,750 --> 00:35:29,970
prone and if there's a if there's a

00:35:28,290 --> 00:35:31,380
problem with this mapping here it

00:35:29,970 --> 00:35:34,390
doesn't represent a valid member or

00:35:31,380 --> 00:35:37,390
whatnot you will tell your compile time

00:35:34,390 --> 00:35:39,339
and we want the the public interface to

00:35:37,390 --> 00:35:41,289
also be simple it should be as easy as

00:35:39,339 --> 00:35:43,839
translate this is what I have this is

00:35:41,289 --> 00:35:44,950
what I want right so let's try to get

00:35:43,839 --> 00:35:47,950
that

00:35:44,950 --> 00:35:53,380
what's implementation for converting

00:35:47,950 --> 00:35:56,890
from an untyped data say a map of

00:35:53,380 --> 00:35:58,930
strangers training to the typed version

00:35:56,890 --> 00:36:02,049
well basically you I to rate on what you

00:35:58,930 --> 00:36:05,049
have which is just a map and use the try

00:36:02,049 --> 00:36:08,140
fine technique to say well let me know

00:36:05,049 --> 00:36:11,470
what's the corresponding member matching

00:36:08,140 --> 00:36:13,569
this particular key here but the trick

00:36:11,470 --> 00:36:15,549
here is that it doesn't map directly to

00:36:13,569 --> 00:36:19,119
the member name it maps to an annotation

00:36:15,549 --> 00:36:20,859
for that specific number so we we need a

00:36:19,119 --> 00:36:24,430
way to look that up based on the

00:36:20,859 --> 00:36:25,930
annotation not on a member name so this

00:36:24,430 --> 00:36:28,390
is all additions work in instead of

00:36:25,930 --> 00:36:30,519
reflection like you have the inefficient

00:36:28,390 --> 00:36:32,349
name which is property and you have the

00:36:30,519 --> 00:36:34,420
annotation value which is like hostname

00:36:32,349 --> 00:36:36,430
post forward flight and so on so forth

00:36:34,420 --> 00:36:39,430
so the thing on the right is the value

00:36:36,430 --> 00:36:41,650
associated to that annotation we want

00:36:39,430 --> 00:36:43,240
the property annotation this is the

00:36:41,650 --> 00:36:45,220
member of the and the name of the

00:36:43,240 --> 00:36:47,799
annotation we want we want to get the

00:36:45,220 --> 00:36:49,240
value associated to that right we want

00:36:47,799 --> 00:36:52,839
to get that from the membrane formation

00:36:49,240 --> 00:36:55,690
itself because that's what the that's

00:36:52,839 --> 00:36:57,599
what the steroid profession gives us in

00:36:55,690 --> 00:37:01,029
order to do that we write a function

00:36:57,599 --> 00:37:02,470
that says given a member return me the

00:37:01,029 --> 00:37:05,019
property associated with that member

00:37:02,470 --> 00:37:06,640
right it's going to look up this this

00:37:05,019 --> 00:37:10,619
mapping that you just wrote here in the

00:37:06,640 --> 00:37:13,390
ideal and return you the correct thing

00:37:10,619 --> 00:37:15,819
so we have to transform this list

00:37:13,390 --> 00:37:18,549
somehow to convert the members to the

00:37:15,819 --> 00:37:20,650
property values themselves so that we

00:37:18,549 --> 00:37:23,079
get the correct mapping this gives us a

00:37:20,650 --> 00:37:26,049
type list of properties containing host

00:37:23,079 --> 00:37:29,799
name host port and all those things that

00:37:26,049 --> 00:37:32,529
we saw on the right here and then we can

00:37:29,799 --> 00:37:35,980
try fine on it based on the key that we

00:37:32,529 --> 00:37:38,470
got from them from the map collab is ER

00:37:35,980 --> 00:37:40,559
past the the value that you have for

00:37:38,470 --> 00:37:43,390
that specific entry in the map and

00:37:40,559 --> 00:37:44,890
district where you want to set it and

00:37:43,390 --> 00:37:47,770
from there on you receive the property

00:37:44,890 --> 00:37:50,830
here again this is not this property

00:37:47,770 --> 00:37:52,840
not the member the member meditator

00:37:50,830 --> 00:37:55,180
right it's just as compile-time string

00:37:52,840 --> 00:37:58,300
representing the value of the annotation

00:37:55,180 --> 00:38:02,260
so we want to convert that property into

00:37:58,300 --> 00:38:04,420
the member descriptor so we can do that

00:38:02,260 --> 00:38:04,780
by just performing a lookup in the type

00:38:04,420 --> 00:38:06,730
list

00:38:04,780 --> 00:38:08,950
fado got here is basically the same as

00:38:06,730 --> 00:38:12,580
stat fine giving a list I want to look

00:38:08,950 --> 00:38:15,460
look an element in this list and we

00:38:12,580 --> 00:38:17,290
basically have say properties the member

00:38:15,460 --> 00:38:19,750
we want to look up and the predicate is

00:38:17,290 --> 00:38:21,790
get property so basically run grab grab

00:38:19,750 --> 00:38:23,200
get property on every element of the

00:38:21,790 --> 00:38:25,320
list and match that against property

00:38:23,200 --> 00:38:28,480
this will give you the member of

00:38:25,320 --> 00:38:32,140
metadata you can use that to get there

00:38:28,480 --> 00:38:33,940
together and pass the structure to it

00:38:32,140 --> 00:38:36,700
and you'll have a reference to the

00:38:33,940 --> 00:38:39,370
element in the struct where you want to

00:38:36,700 --> 00:38:41,290
set the value into next thing is you

00:38:39,370 --> 00:38:43,780
need to convert the string that you got

00:38:41,290 --> 00:38:44,980
from the map from the legacy map you

00:38:43,780 --> 00:38:47,920
need to convert that string into

00:38:44,980 --> 00:38:51,000
whatever type you have in the structure

00:38:47,920 --> 00:38:53,500
right so Foley is an open source library

00:38:51,000 --> 00:38:56,140
created by Facebook as well it it

00:38:53,500 --> 00:38:57,730
provides this handy converter here so

00:38:56,140 --> 00:39:00,930
that you can convert pretty much any

00:38:57,730 --> 00:39:04,750
like regular data type say strings

00:39:00,930 --> 00:39:07,090
integers doubles you can convert one to

00:39:04,750 --> 00:39:09,220
another so from is actually string

00:39:07,090 --> 00:39:11,110
member type is whatever the memory type

00:39:09,220 --> 00:39:13,390
is going to be it's going to perform a

00:39:11,110 --> 00:39:17,220
conversion for you and then you simply

00:39:13,390 --> 00:39:17,220
assign one to the other and that's it

00:39:17,790 --> 00:39:26,170
sure sure yeah it's just values like

00:39:23,860 --> 00:39:29,590
you're looking into a map of string to

00:39:26,170 --> 00:39:32,650
string and you sorry the question is

00:39:29,590 --> 00:39:34,210
would boost lexical casts work so they

00:39:32,650 --> 00:39:37,000
pretty much serve the same purpose

00:39:34,210 --> 00:39:38,770
you're just getting us a string and

00:39:37,000 --> 00:39:44,800
convert it into an integer that will or

00:39:38,770 --> 00:39:47,920
whatever so translate we want to convert

00:39:44,800 --> 00:39:51,760
back from the from the flat config which

00:39:47,920 --> 00:39:53,230
is a structure to the legacy config how

00:39:51,760 --> 00:39:55,900
do we do that there's actually much

00:39:53,230 --> 00:39:58,090
simpler because now you have the memory

00:39:55,900 --> 00:40:00,250
formation itself you want to get the

00:39:58,090 --> 00:40:01,950
members and you know which members you

00:40:00,250 --> 00:40:03,360
want to get for

00:40:01,950 --> 00:40:05,280
basically everything that's in this

00:40:03,360 --> 00:40:06,660
truck right so we don't need to look

00:40:05,280 --> 00:40:08,730
something up it's just either eight of

00:40:06,660 --> 00:40:10,200
them over the members of this truck so

00:40:08,730 --> 00:40:10,590
you passed this memory formation to four

00:40:10,200 --> 00:40:13,850
each

00:40:10,590 --> 00:40:15,960
all visitor again the same boring thing

00:40:13,850 --> 00:40:17,910
in the visitor you receive the memory

00:40:15,960 --> 00:40:22,140
information use that to get a reference

00:40:17,910 --> 00:40:24,630
to it to the member of the struct and

00:40:22,140 --> 00:40:26,220
you wanna you want to also get the

00:40:24,630 --> 00:40:29,520
property name associated with that

00:40:26,220 --> 00:40:30,960
member and use that as the key but first

00:40:29,520 --> 00:40:33,720
you have to convert it to a string right

00:40:30,960 --> 00:40:36,440
so we do that now we have the value and

00:40:33,720 --> 00:40:39,240
the key itself next thing we do is

00:40:36,440 --> 00:40:42,120
convert the value to a string because we

00:40:39,240 --> 00:40:44,220
have a typed value from the struck right

00:40:42,120 --> 00:40:46,500
it could be an integer convert that to a

00:40:44,220 --> 00:40:50,700
string and set it in the map to the

00:40:46,500 --> 00:40:53,880
appropriate key that's it and we're

00:40:50,700 --> 00:40:57,780
pretty much done so with this code it's

00:40:53,880 --> 00:41:00,120
actually two visitors and two entry

00:40:57,780 --> 00:41:03,540
point functions we can convert back and

00:41:00,120 --> 00:41:07,400
forth from a flat config to from untyped

00:41:03,540 --> 00:41:10,560
config to a flat structure what if we

00:41:07,400 --> 00:41:12,780
wanted to convert it to not to a flat

00:41:10,560 --> 00:41:15,510
structure but instead to a nested

00:41:12,780 --> 00:41:18,500
structure saying like I want the config

00:41:15,510 --> 00:41:21,660
to contain another struct called address

00:41:18,500 --> 00:41:23,370
which by itself contains host import so

00:41:21,660 --> 00:41:24,930
on so forth like it could be deeply

00:41:23,370 --> 00:41:27,600
nested because it's much easier to

00:41:24,930 --> 00:41:29,850
organize information this way we could

00:41:27,600 --> 00:41:32,880
simply recurse like we did for a pretty

00:41:29,850 --> 00:41:34,410
printer for a serializer and perform

00:41:32,880 --> 00:41:38,220
perform the correct conversions

00:41:34,410 --> 00:41:39,810
I had another example that I that makes

00:41:38,220 --> 00:41:42,510
it much simpler by flattening all the

00:41:39,810 --> 00:41:44,700
getters of a specific structure necess

00:41:42,510 --> 00:41:47,430
structure so get a simple single list

00:41:44,700 --> 00:41:49,590
with every single leaf in the structure

00:41:47,430 --> 00:41:51,540
what I had to cut it off of the

00:41:49,590 --> 00:41:53,940
presentation for time constraints the

00:41:51,540 --> 00:41:57,060
demo will be uploaded though to the

00:41:53,940 --> 00:41:59,190
trifa code base so very very shortly you

00:41:57,060 --> 00:42:02,580
have access to it I'm gonna provide the

00:41:59,190 --> 00:42:06,390
slides with that example as well in the

00:42:02,580 --> 00:42:09,060
repo so how do we how do we enable this

00:42:06,390 --> 00:42:11,730
like because so far it seems like it's

00:42:09,060 --> 00:42:13,690
in a magic like there's a lot we can do

00:42:11,730 --> 00:42:16,819
manipulate those types

00:42:13,690 --> 00:42:18,980
introspect into into the structure of

00:42:16,819 --> 00:42:20,779
the program but how do I get this like

00:42:18,980 --> 00:42:22,519
do I have to write a bunch of macros and

00:42:20,779 --> 00:42:25,759
manually you fill in the blanks

00:42:22,519 --> 00:42:27,079
actually no say you have the module that

00:42:25,759 --> 00:42:28,970
rift which is basically the ideal

00:42:27,079 --> 00:42:32,150
containing all the types nearer in your

00:42:28,970 --> 00:42:34,190
and that you care about and say you want

00:42:32,150 --> 00:42:37,549
to call trip just like you usually do to

00:42:34,190 --> 00:42:39,980
generate C++ stubs or PC information and

00:42:37,549 --> 00:42:43,249
whatnot the only thing you have to do is

00:42:39,980 --> 00:42:46,880
add a flag called fatal there's not a

00:42:43,249 --> 00:42:48,349
very good name but uh because it would

00:42:46,880 --> 00:42:49,519
be much better if we had reflection in

00:42:48,349 --> 00:42:52,009
there say generate reflect information

00:42:49,519 --> 00:42:54,619
this for historical purposes I'm

00:42:52,009 --> 00:42:57,440
changing that and and I'll land soon I

00:42:54,619 --> 00:42:59,359
hope to change soon to change that to

00:42:57,440 --> 00:43:02,480
reflection but for now that's how we do

00:42:59,359 --> 00:43:05,150
it but watch out for this change it will

00:43:02,480 --> 00:43:09,019
be reflection in the future and then

00:43:05,150 --> 00:43:10,789
it's gonna inside a directory where our

00:43:09,019 --> 00:43:12,710
truth usually puts all the files and

00:43:10,789 --> 00:43:15,589
generates there will be on a few other

00:43:12,710 --> 00:43:18,380
files there as well that it can then

00:43:15,589 --> 00:43:20,660
include to have this this type

00:43:18,380 --> 00:43:22,549
information and that's all you have to

00:43:20,660 --> 00:43:26,150
do you just include the correct module

00:43:22,549 --> 00:43:29,569
and you you you set you you use the flag

00:43:26,150 --> 00:43:31,249
interest in the trick compiler how do

00:43:29,569 --> 00:43:33,559
you import this metadata you just

00:43:31,249 --> 00:43:35,989
include a file so first return from it

00:43:33,559 --> 00:43:38,299
first struts it's in separate file you

00:43:35,989 --> 00:43:39,650
know is yet another file you know is

00:43:38,299 --> 00:43:41,839
this basically variants it's just the

00:43:39,650 --> 00:43:44,809
way a trip names those things it's in

00:43:41,839 --> 00:43:46,759
yet another file the reason we separate

00:43:44,809 --> 00:43:48,920
that is because you might maybe you're

00:43:46,759 --> 00:43:51,680
not interested in all this metadata just

00:43:48,920 --> 00:43:53,480
in a few in a few of them and you don't

00:43:51,680 --> 00:43:55,759
want to pay the price for the build time

00:43:53,480 --> 00:43:57,859
price for including all of it but if you

00:43:55,759 --> 00:43:59,930
do there's a handy header cold

00:43:57,859 --> 00:44:02,539
underscore types that you can include if

00:43:59,930 --> 00:44:04,999
you have all this there's more

00:44:02,539 --> 00:44:07,460
information in the source code there's a

00:44:04,999 --> 00:44:10,009
header the main header for reflection

00:44:07,460 --> 00:44:11,390
it's called reflections of H by the way

00:44:10,009 --> 00:44:13,880
the path is also going to change from

00:44:11,390 --> 00:44:16,190
fatal to reflection but reflection that

00:44:13,880 --> 00:44:18,440
H contains like a lot of documentation

00:44:16,190 --> 00:44:20,839
in line that you can simply take a look

00:44:18,440 --> 00:44:22,519
at it explains the to how to how to

00:44:20,839 --> 00:44:24,440
generate this metadata how to include

00:44:22,519 --> 00:44:26,519
this metadata how to troubleshoot in

00:44:24,440 --> 00:44:29,650
case there are problems

00:44:26,519 --> 00:44:33,400
information is all there and so if your

00:44:29,650 --> 00:44:35,170
closing words some places where we want

00:44:33,400 --> 00:44:37,630
to use this we've been experimenting

00:44:35,170 --> 00:44:41,049
with I had an intern recently thanks

00:44:37,630 --> 00:44:43,089
Dylan who reimplemented all the all the

00:44:41,049 --> 00:44:44,529
serialization framework that we have to

00:44:43,089 --> 00:44:46,900
instead of generate the civilization

00:44:44,529 --> 00:44:49,599
code in the trifa compiler to use

00:44:46,900 --> 00:44:53,079
Telegraph lection is tad - to generate

00:44:49,599 --> 00:44:54,969
that for you right so impressively

00:44:53,079 --> 00:44:57,219
enough we've seen gains in build times

00:44:54,969 --> 00:45:01,599
because of that we're still not sure

00:44:57,219 --> 00:45:04,869
exactly why but so far we we think it's

00:45:01,599 --> 00:45:07,869
because parsing and token validation and

00:45:04,869 --> 00:45:09,999
how that that stuff it's very costly so

00:45:07,869 --> 00:45:11,709
instead of including the code everywhere

00:45:09,999 --> 00:45:14,319
you just instantiate in the templates

00:45:11,709 --> 00:45:16,749
where you need so for a specific file

00:45:14,319 --> 00:45:18,640
that's compiled by trips you might not

00:45:16,749 --> 00:45:20,319
make a difference but for big projects

00:45:18,640 --> 00:45:21,880
you make makes a lot of difference like

00:45:20,319 --> 00:45:25,539
I don't have numbers because I finished

00:45:21,880 --> 00:45:27,729
those lies like 30 minutes ago but but

00:45:25,539 --> 00:45:29,049
uh we're still experimenting with that

00:45:27,729 --> 00:45:32,709
there are still some improvements we can

00:45:29,049 --> 00:45:34,599
get let's see let's hope for the best

00:45:32,709 --> 00:45:38,199
there's also runtime performance just

00:45:34,599 --> 00:45:39,670
because we we think it's because the

00:45:38,199 --> 00:45:42,009
compilers do a good job at optimizing

00:45:39,670 --> 00:45:44,369
templates I'm sure there are a lot more

00:45:42,009 --> 00:45:46,749
we can do but uh things like the

00:45:44,369 --> 00:45:48,699
building to try a compile time or

00:45:46,749 --> 00:45:50,709
building a sort of list at compile time

00:45:48,699 --> 00:45:51,609
it's work that you don't have to do it

00:45:50,709 --> 00:45:54,519
at runtime

00:45:51,609 --> 00:45:56,109
right and also some other things like

00:45:54,519 --> 00:45:58,299
there are a lot of transformations that

00:45:56,109 --> 00:45:59,739
we're doing the types themselves that

00:45:58,299 --> 00:46:00,939
are done at compile time and don't have

00:45:59,739 --> 00:46:05,469
to we don't have to pay the price for

00:46:00,939 --> 00:46:07,719
them at at runtime so that may also be a

00:46:05,469 --> 00:46:11,469
contributor to that and civil size

00:46:07,719 --> 00:46:12,969
reduction just because we have we have

00:46:11,469 --> 00:46:14,829
come full control over the

00:46:12,969 --> 00:46:16,749
implementation of serialization we will

00:46:14,829 --> 00:46:22,209
also have that with regards to the tree

00:46:16,749 --> 00:46:23,439
from file right but uh the thing is if

00:46:22,209 --> 00:46:26,410
you write a sterilization for a specific

00:46:23,439 --> 00:46:28,059
structure you have to either put that in

00:46:26,410 --> 00:46:31,920
the structure itself and say read write

00:46:28,059 --> 00:46:33,910
forever or you can write a separate

00:46:31,920 --> 00:46:35,140
specialization but the name of the

00:46:33,910 --> 00:46:36,880
structure has to be there the name of

00:46:35,140 --> 00:46:37,220
the members have to has to be there so

00:46:36,880 --> 00:46:38,840
you don't

00:46:37,220 --> 00:46:41,210
much a lot of control over the naming of

00:46:38,840 --> 00:46:42,590
things with this there's there are lots

00:46:41,210 --> 00:46:43,760
and lots of templates that we can

00:46:42,590 --> 00:46:45,619
actually just change the names and

00:46:43,760 --> 00:46:47,990
shorten them so that the symbols

00:46:45,619 --> 00:46:49,640
themselves can can reduce your size and

00:46:47,990 --> 00:46:51,950
also because a lot of the transforms are

00:46:49,640 --> 00:46:53,630
done at compile time every every time

00:46:51,950 --> 00:46:55,609
you see a using statement

00:46:53,630 --> 00:46:57,890
that's computation that's not being

00:46:55,609 --> 00:46:59,869
generated as run time so it's a function

00:46:57,890 --> 00:47:02,540
that's not being emitted so that's less

00:46:59,869 --> 00:47:07,250
code to compile and less symbols to to

00:47:02,540 --> 00:47:10,580
include in your binary nearly across

00:47:07,250 --> 00:47:13,130
language extensions we just we just

00:47:10,580 --> 00:47:15,380
talked to some some guys that work with

00:47:13,130 --> 00:47:16,910
Python in Facebook we don't have a lot

00:47:15,380 --> 00:47:20,330
of we don't have any products yet in

00:47:16,910 --> 00:47:22,670
this but we're we're interested in for

00:47:20,330 --> 00:47:24,349
instance using this to generate the

00:47:22,670 --> 00:47:27,619
Python bindings instead of generating

00:47:24,349 --> 00:47:29,300
Python code so it's a lot less code that

00:47:27,619 --> 00:47:31,160
you have to generate in Python a lot

00:47:29,300 --> 00:47:33,170
less code interpreter has bars and

00:47:31,160 --> 00:47:35,390
basically you can have the reflection

00:47:33,170 --> 00:47:36,740
subsystem take care of generating

00:47:35,390 --> 00:47:39,200
everything for you all you need is a

00:47:36,740 --> 00:47:40,790
call to one function that will generate

00:47:39,200 --> 00:47:45,859
all the types you need and register it

00:47:40,790 --> 00:47:47,150
in the Python interpreter and I think

00:47:45,859 --> 00:47:50,300
the biggest gain from this is cheaper

00:47:47,150 --> 00:47:52,940
experimentation should you have a need

00:47:50,300 --> 00:47:56,390
for a different sterilizer or you need a

00:47:52,940 --> 00:47:58,609
compare for destruct the specific struck

00:47:56,390 --> 00:48:01,220
here or you need say a specific

00:47:58,609 --> 00:48:03,530
transform like merge or whatnot or

00:48:01,220 --> 00:48:05,540
pretty printer you don't have to change

00:48:03,530 --> 00:48:07,130
the trip compiler in order to implement

00:48:05,540 --> 00:48:08,780
that you can write that as a separate

00:48:07,130 --> 00:48:10,790
library that's not intrusive because it

00:48:08,780 --> 00:48:12,530
doesn't change any other code it was a

00:48:10,790 --> 00:48:14,780
separate file that you don't have to

00:48:12,530 --> 00:48:16,849
include if you don't want so it's much

00:48:14,780 --> 00:48:20,599
cheaper for it to experiment with

00:48:16,849 --> 00:48:24,140
you need to to be able to to to write

00:48:20,599 --> 00:48:26,300
metaprogramming what is too much cheaper

00:48:24,140 --> 00:48:28,280
do then understanding how the trip

00:48:26,300 --> 00:48:32,270
compiler works and changing that and

00:48:28,280 --> 00:48:34,400
believe me it's pretty messy and run

00:48:32,270 --> 00:48:36,080
time reflection all of this that I

00:48:34,400 --> 00:48:38,390
presented is based the compile time

00:48:36,080 --> 00:48:40,490
reflection right but a metadata is all

00:48:38,390 --> 00:48:42,020
there and you we've seen that there are

00:48:40,490 --> 00:48:46,310
ways to convert this compile time

00:48:42,020 --> 00:48:48,320
metadata into runtime information so I'm

00:48:46,310 --> 00:48:50,030
playing to to investigate a little bit

00:48:48,320 --> 00:48:51,020
and how to convert that to runtime right

00:48:50,030 --> 00:48:52,790
now

00:48:51,020 --> 00:48:55,430
there there's some benefits to it for

00:48:52,790 --> 00:48:56,690
instance buuuut times you don't have to

00:48:55,430 --> 00:48:59,600
instantiate a lot of templates you can

00:48:56,690 --> 00:49:01,220
simply use like Ida read over data you

00:48:59,600 --> 00:49:02,990
pay the price for rent time performance

00:49:01,220 --> 00:49:05,720
but in some some occasions you just

00:49:02,990 --> 00:49:08,090
don't care right and also although

00:49:05,720 --> 00:49:09,500
runtime reflection is a bit a little bit

00:49:08,090 --> 00:49:12,620
limited because you don't have access to

00:49:09,500 --> 00:49:14,870
the types themselves there is a lot more

00:49:12,620 --> 00:49:18,020
people that can use the runtime

00:49:14,870 --> 00:49:20,480
reflection then there is people that can

00:49:18,020 --> 00:49:22,280
use competin reflection so you wouldn't

00:49:20,480 --> 00:49:24,170
need matter programming skills in for

00:49:22,280 --> 00:49:25,370
instance to use rent and reflection so

00:49:24,170 --> 00:49:30,620
it's something that are also planning on

00:49:25,370 --> 00:49:34,640
adding soon C++ time support this is not

00:49:30,620 --> 00:49:37,240
at all a take into suggesting something

00:49:34,640 --> 00:49:40,520
to be included in the in the standard

00:49:37,240 --> 00:49:43,910
basically people I'm sorry basically

00:49:40,520 --> 00:49:48,920
because this is not generic enough to be

00:49:43,910 --> 00:49:51,410
used by C++ it only fits tricked use

00:49:48,920 --> 00:49:54,380
cases which for us does the job most of

00:49:51,410 --> 00:49:56,450
the time but I think the the best thing

00:49:54,380 --> 00:49:58,790
that this can provide to whoever is

00:49:56,450 --> 00:50:02,210
writing a proposal for first hander for

00:49:58,790 --> 00:50:04,130
reflection is basically this this is

00:50:02,210 --> 00:50:05,630
those already used cases we've seen so

00:50:04,130 --> 00:50:08,120
far where reflection can be applied

00:50:05,630 --> 00:50:11,480
those are way that the ways that we

00:50:08,120 --> 00:50:13,580
modeled compiled reflection for this

00:50:11,480 --> 00:50:16,880
problems so they are good some of them

00:50:13,580 --> 00:50:18,110
are not so much so it's it's a way for

00:50:16,880 --> 00:50:20,390
you to see it's a different perspective

00:50:18,110 --> 00:50:22,010
where you can see what can improve can

00:50:20,390 --> 00:50:25,130
be improved here what is the good things

00:50:22,010 --> 00:50:27,770
that we can reuse and what not and what

00:50:25,130 --> 00:50:29,690
use cases should it be focused on and

00:50:27,770 --> 00:50:33,620
and that might my proposal should

00:50:29,690 --> 00:50:36,550
actually address and the last question

00:50:33,620 --> 00:50:40,730
is why not write then a compiler branch

00:50:36,550 --> 00:50:42,980
C++ like say for a clang or GCC well

00:50:40,730 --> 00:50:45,220
several reasons one is this is not

00:50:42,980 --> 00:50:47,600
generic enough and will take a lot more

00:50:45,220 --> 00:50:49,520
it will be a lot more costly to

00:50:47,600 --> 00:50:52,130
implement something that's simplest plus

00:50:49,520 --> 00:50:54,890
worthy as opposed to something that

00:50:52,130 --> 00:50:57,440
suffice is the subset of strict that we

00:50:54,890 --> 00:50:59,270
care about there is also another reason

00:50:57,440 --> 00:51:01,670
inte R if there's a single

00:50:59,270 --> 00:51:02,900
implementation of this if we were to

00:51:01,670 --> 00:51:03,559
change the compiler we would have to

00:51:02,900 --> 00:51:05,900
support

00:51:03,559 --> 00:51:07,549
clang and JCC and probably Visual Studio

00:51:05,900 --> 00:51:10,489
I don't have access to the sources of

00:51:07,549 --> 00:51:12,829
users to do and whatever other compilers

00:51:10,489 --> 00:51:15,589
that people decide to use by having this

00:51:12,829 --> 00:51:18,219
encrypt this is pretty much C++ 11 so

00:51:15,589 --> 00:51:20,959
any compliant compiler can can use this

00:51:18,219 --> 00:51:23,959
by doing that in truth it's just it's

00:51:20,959 --> 00:51:25,579
just cheaper for us to do it the only

00:51:23,959 --> 00:51:27,229
downside is there is that now you have

00:51:25,579 --> 00:51:29,239
to include a few files to have access to

00:51:27,229 --> 00:51:32,420
this but you might be fine with it

00:51:29,239 --> 00:51:34,670
hopefully I will delete most of this

00:51:32,420 --> 00:51:38,269
code whenever reflection gets in the

00:51:34,670 --> 00:51:40,459
language I very much want to do it but I

00:51:38,269 --> 00:51:42,529
think for a while now I won't be able to

00:51:40,459 --> 00:51:45,319
so let's use what we have as an

00:51:42,529 --> 00:51:48,019
experiment with it while we can so that

00:51:45,319 --> 00:51:49,759
when we get something we have a much

00:51:48,019 --> 00:51:53,329
better idea of what we want in how we

00:51:49,759 --> 00:51:55,069
can accomplish that and before I go I

00:51:53,329 --> 00:51:57,109
just would like to use the remaining

00:51:55,069 --> 00:52:18,049
time for any questions that you guys may

00:51:57,109 --> 00:52:21,380
have like I said before yeah sorry the

00:52:18,049 --> 00:52:22,609
question is what is uh what is the what

00:52:21,380 --> 00:52:24,499
is the reason for having a static

00:52:22,609 --> 00:52:27,049
reflection as opposed to rent the

00:52:24,499 --> 00:52:28,910
reflection if I got it correctly well

00:52:27,049 --> 00:52:30,709
for one I can generate runtime

00:52:28,910 --> 00:52:33,559
reflection from static reflection I

00:52:30,709 --> 00:52:35,390
cannot do the opposite like I said is

00:52:33,559 --> 00:52:37,670
there a runtime reflection is supported

00:52:35,390 --> 00:52:40,189
I want to add and it can use very

00:52:37,670 --> 00:52:42,380
similar techniques to get that the other

00:52:40,189 --> 00:52:43,459
thing is that return reflection is

00:52:42,380 --> 00:52:45,229
pretty limited because they don't have

00:52:43,459 --> 00:52:47,779
access to the types like I said before I

00:52:45,229 --> 00:52:49,999
would not be able like it wouldn't how

00:52:47,779 --> 00:52:52,400
would you I create over a structure

00:52:49,999 --> 00:52:54,410
using runtime reflection there's a lot

00:52:52,400 --> 00:52:56,749
of interaction type erasure that you

00:52:54,410 --> 00:53:00,199
have to get in place and that that has a

00:52:56,749 --> 00:53:02,900
cost at runtime right and also runtime

00:53:00,199 --> 00:53:04,969
is also in our reason like we we work in

00:53:02,900 --> 00:53:06,679
a you know in a very large scale of

00:53:04,969 --> 00:53:09,140
Facebook and we care a lot about

00:53:06,679 --> 00:53:11,410
performance by having a lot of the

00:53:09,140 --> 00:53:14,089
computation happen at compile time

00:53:11,410 --> 00:53:14,730
sometimes it bothers developers and I

00:53:14,089 --> 00:53:15,990
completely under

00:53:14,730 --> 00:53:18,900
and that because you have to wait longer

00:53:15,990 --> 00:53:21,510
for it to compile on the other hand it's

00:53:18,900 --> 00:53:24,300
it's like when you put that to thousands

00:53:21,510 --> 00:53:25,619
of servers out there there's a lot of

00:53:24,300 --> 00:53:28,230
benefit that it can get out of it right

00:53:25,619 --> 00:53:32,640
is less time that you're processing all

00:53:28,230 --> 00:53:38,339
those services all the server's so yeah

00:53:32,640 --> 00:53:42,140
that's pretty much it all right so there

00:53:38,339 --> 00:53:42,140

YouTube URL: https://www.youtube.com/watch?v=tq0YfWFlVZA


