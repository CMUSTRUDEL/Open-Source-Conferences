Title: CppCon 2016: Michael Spencer “My Little Optimizer: Undefined Behavior is Magic"
Publication date: 2016-10-01
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Compiler exploitation of undefined behavior has been a topic of recent discussion in the programming community. This talk will explore the magic of Undefined Behavior, Covering how and why modern optimizers exploit undefined behavior in C++ programs.
— 
Michael Spencer
Compiler Engineer, Sony Playstation
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:03,480
we're about to get started thanks for

00:00:02,730 --> 00:00:06,720
coming right Huck

00:00:03,480 --> 00:00:08,940
I am Michael Spencer I'm a compiler

00:00:06,720 --> 00:00:11,730
engineer at Sony Playstation working on

00:00:08,940 --> 00:00:15,599
clang and LLVM as a single closed

00:00:11,730 --> 00:00:16,800
front-end for our game teams and so I

00:00:15,599 --> 00:00:19,380
was talk

00:00:16,800 --> 00:00:21,689
my little optimizer undefined behavior

00:00:19,380 --> 00:00:22,890
is magic an alternative title would be

00:00:21,689 --> 00:00:24,539
vile awesome Iser

00:00:22,890 --> 00:00:28,710
any sufficiently advanced optimization

00:00:24,539 --> 00:00:30,300
is indistinguishable from magic it's not

00:00:28,710 --> 00:00:35,370
really magic going on here but sometimes

00:00:30,300 --> 00:00:38,910
it does feel like it so getting into

00:00:35,370 --> 00:00:41,700
this first we gotta go some definitions

00:00:38,910 --> 00:00:44,129
in C++ because the compiler doesn't just

00:00:41,700 --> 00:00:45,090
like implement the hard or just isn't

00:00:44,129 --> 00:00:47,879
just hardening the hardware it's

00:00:45,090 --> 00:00:49,469
targeting the abstract machine or trying

00:00:47,879 --> 00:00:51,809
to lower the abstract machine into down

00:00:49,469 --> 00:00:54,000
to the hardware so well afford program

00:00:51,809 --> 00:00:55,530
it's basically a program that compiles

00:00:54,000 --> 00:00:59,160
successfully and doesn't violate the one

00:00:55,530 --> 00:01:01,260
definition rule then there's

00:00:59,160 --> 00:01:02,969
implementation to find behavior and so

00:01:01,260 --> 00:01:04,080
that's basically there's lots of things

00:01:02,969 --> 00:01:05,729
that just says our implementation to

00:01:04,080 --> 00:01:10,010
find and that doesn't always necessarily

00:01:05,729 --> 00:01:13,080
mean that it's gonna do something nice

00:01:10,010 --> 00:01:15,060
it can like launch nethack if it feels

00:01:13,080 --> 00:01:17,280
like that is generally a valid

00:01:15,060 --> 00:01:18,509
implication fire behavior but standards

00:01:17,280 --> 00:01:22,049
not designed to protect against

00:01:18,509 --> 00:01:22,770
malicious implementations so so we're

00:01:22,049 --> 00:01:26,100
generally ok with that

00:01:22,770 --> 00:01:27,810
we've got unspecified behavior this is

00:01:26,100 --> 00:01:29,400
like it's not always numerated wind is

00:01:27,810 --> 00:01:31,470
like there's a note here generally it is

00:01:29,400 --> 00:01:34,530
but not always and these are four things

00:01:31,470 --> 00:01:35,880
that I mean it like a reasonable

00:01:34,530 --> 00:01:39,689
implementation may not be able to

00:01:35,880 --> 00:01:43,320
guarantee any specific behavior and so

00:01:39,689 --> 00:01:44,880
it's not required to be documented and

00:01:43,320 --> 00:01:49,680
then we have our favorite undefined

00:01:44,880 --> 00:01:51,840
behavior so no requirements at all now

00:01:49,680 --> 00:01:56,310
what are your flippin tations allowed to

00:01:51,840 --> 00:01:58,350
do with undefined behavior no

00:01:56,310 --> 00:02:00,540
requirements for the entire execution of

00:01:58,350 --> 00:02:03,689
the program so if you find behavior

00:02:00,540 --> 00:02:07,350
anywhere your whole program is is like

00:02:03,689 --> 00:02:11,910
can do whatever it wants so what do

00:02:07,350 --> 00:02:13,560
implementations actually do a lot now

00:02:11,910 --> 00:02:14,790
the most common thing

00:02:13,560 --> 00:02:17,010
that's gonna happen you're seeing

00:02:14,790 --> 00:02:18,630
examples here is that the compilers

00:02:17,010 --> 00:02:21,500
going to say undefined behavior can't

00:02:18,630 --> 00:02:24,209
happen and since it can't happen then

00:02:21,500 --> 00:02:27,920
I'm going to optimize assuming that it

00:02:24,209 --> 00:02:30,510
can't so here's a really simple example

00:02:27,920 --> 00:02:33,150
this might be there this is quite

00:02:30,510 --> 00:02:36,930
similar to the Linux kernel bug which

00:02:33,150 --> 00:02:39,690
was recently in the past few years we've

00:02:36,930 --> 00:02:42,060
got this variable okay it's a bool we're

00:02:39,690 --> 00:02:43,350
gonna we're going to check and see if we

00:02:42,060 --> 00:02:46,050
actually have a value and then call blah

00:02:43,350 --> 00:02:47,760
but first we'd be referenced it you had

00:02:46,050 --> 00:02:49,680
a refactoring whatever it got moved up

00:02:47,760 --> 00:02:52,800
there the compiler is gonna look at this

00:02:49,680 --> 00:02:56,360
and say if okay we're null we would have

00:02:52,800 --> 00:03:00,269
undefined behavior okay can't be not

00:02:56,360 --> 00:03:04,080
this must be false remove it just call

00:03:00,269 --> 00:03:06,510
blah and at runtime whatever could

00:03:04,080 --> 00:03:09,180
happen you might get a seg fault but it

00:03:06,510 --> 00:03:10,980
might just go go into blah and okay is

00:03:09,180 --> 00:03:12,660
not it might be like some positive or

00:03:10,980 --> 00:03:15,900
like it might have a one in the low bit

00:03:12,660 --> 00:03:17,430
and it thinks everything's okay so how

00:03:15,900 --> 00:03:19,769
does the compiler actually raise the

00:03:17,430 --> 00:03:23,579
bottom to find behavior that's what I'm

00:03:19,769 --> 00:03:27,570
really here to talk about so yeah a

00:03:23,579 --> 00:03:29,010
couple ways to represent it and let's

00:03:27,570 --> 00:03:31,140
backtrack for a second I'm gonna be

00:03:29,010 --> 00:03:32,070
mainly explaining how LVM does things

00:03:31,140 --> 00:03:35,280
cuz that's what I work on

00:03:32,070 --> 00:03:39,420
but GCC and other compilers use very

00:03:35,280 --> 00:03:42,150
similar reasoning so we have a way to

00:03:39,420 --> 00:03:44,100
express unreachable meaning that this

00:03:42,150 --> 00:03:46,739
this part of the code can never be

00:03:44,100 --> 00:03:49,950
reached and we also have undef to

00:03:46,739 --> 00:03:53,100
represent things that we don't know what

00:03:49,950 --> 00:03:55,769
this value is and then there's also

00:03:53,100 --> 00:03:59,820
implicit things which is things that the

00:03:55,769 --> 00:04:02,100
optimizer knows can't have so we're

00:03:59,820 --> 00:04:05,040
gonna take a brief detour into I'll be

00:04:02,100 --> 00:04:06,989
my R so for those of you that know LVM

00:04:05,040 --> 00:04:10,530
some of this I have omitted some parts

00:04:06,989 --> 00:04:13,320
of the IR just to clarify or that it's a

00:04:10,530 --> 00:04:15,540
simplified explanation so we've got

00:04:13,320 --> 00:04:17,489
matching between you got your definition

00:04:15,540 --> 00:04:20,820
of your function got definition over

00:04:17,489 --> 00:04:22,140
there we have a load that be reference

00:04:20,820 --> 00:04:26,130
to the load so it turns into a load in

00:04:22,140 --> 00:04:26,730
the IR grammar conditional turns into an

00:04:26,130 --> 00:04:31,010
Enter

00:04:26,730 --> 00:04:34,950
compared not equal against no our branch

00:04:31,010 --> 00:04:37,200
the return and the call so generally it

00:04:34,950 --> 00:04:41,010
should be pretty obvious what it maps to

00:04:37,200 --> 00:04:43,260
if at any point like it I don't clearly

00:04:41,010 --> 00:04:46,460
explain what the IRF is unser it's

00:04:43,260 --> 00:04:46,460
confusing you can interrupt and ask

00:04:47,780 --> 00:04:53,370
let's explain unreasonable here so it's

00:04:51,690 --> 00:04:55,140
an instruction can't be reached right

00:04:53,370 --> 00:04:56,820
here we've had we have this this awesome

00:04:55,140 --> 00:04:59,580
program we want to write out this value

00:04:56,820 --> 00:05:01,350
and then we want to like let's say I

00:04:59,580 --> 00:05:02,670
want to break up the debugger here so

00:05:01,350 --> 00:05:08,370
I'm just gonna dereference 0 then I'll

00:05:02,670 --> 00:05:11,640
give me a seg fault right well yeah so

00:05:08,370 --> 00:05:14,550
this is what the the the optimizer sees

00:05:11,640 --> 00:05:20,490
we've got a store and then a load from

00:05:14,550 --> 00:05:21,780
Nome now the the it comes through here

00:05:20,490 --> 00:05:23,310
looked at the store that's okay it looks

00:05:21,780 --> 00:05:25,200
at the load sees load from null well

00:05:23,310 --> 00:05:27,330
that that can't happen it's undefined

00:05:25,200 --> 00:05:30,180
behavior that can't be reached replacing

00:05:27,330 --> 00:05:32,310
with unreachable we also have an GCC and

00:05:30,180 --> 00:05:34,680
all VM are claying support this built-in

00:05:32,310 --> 00:05:37,200
unreachable that you can use generally

00:05:34,680 --> 00:05:39,780
used for some optimization stuff but

00:05:37,200 --> 00:05:41,850
let's her whenever up sit here and so

00:05:39,780 --> 00:05:44,490
that means is that everything after it

00:05:41,850 --> 00:05:46,740
can't be reached and everything before

00:05:44,490 --> 00:05:48,600
it can't be reached either so we just

00:05:46,740 --> 00:05:50,490
deleted that that store we don't know

00:05:48,600 --> 00:05:55,200
what that was storing too but we clearly

00:05:50,490 --> 00:05:58,260
can't get here so we'll remove it then

00:05:55,200 --> 00:06:00,450
we have undef so here we have all right

00:05:58,260 --> 00:06:02,370
we have a and initialized you know let's

00:06:00,450 --> 00:06:04,830
use that to like get some extra random

00:06:02,370 --> 00:06:07,920
seed for our random number generator

00:06:04,830 --> 00:06:12,090
well a lot sizes not go like that

00:06:07,920 --> 00:06:14,250
so a few cents for presented I did pull

00:06:12,090 --> 00:06:15,690
too tough away so essentially it's gonna

00:06:14,250 --> 00:06:16,590
be a equals on def because it's not

00:06:15,690 --> 00:06:20,420
initialized we don't have a definition

00:06:16,590 --> 00:06:23,540
for it we're gonna load from key and

00:06:20,420 --> 00:06:28,500
then we're gonna return we're gonna add

00:06:23,540 --> 00:06:30,360
pide and return it so the first thing

00:06:28,500 --> 00:06:32,570
that the optimizer does is it looks at

00:06:30,360 --> 00:06:35,820
that ad and it just turns it to undef

00:06:32,570 --> 00:06:39,000
because undeath is is basically

00:06:35,820 --> 00:06:40,740
represented as it can be any sequence of

00:06:39,000 --> 00:06:44,639
bits we want at any point in the program

00:06:40,740 --> 00:06:46,410
so here any fixed value plus an

00:06:44,639 --> 00:06:47,789
unspecified value is going to be an

00:06:46,410 --> 00:06:51,030
unspecified value so we can just fold

00:06:47,789 --> 00:06:53,970
that away then star P is no longer used

00:06:51,030 --> 00:06:55,380
a is no longer used in the return to

00:06:53,970 --> 00:06:58,340
calculate the return value so we just we

00:06:55,380 --> 00:07:01,889
all that that code and turn it on to

00:06:58,340 --> 00:07:03,419
some subtleties about undef is it's not

00:07:01,889 --> 00:07:07,080
always gonna fold unto us so here we

00:07:03,419 --> 00:07:11,580
have a equals or X and undef and an and

00:07:07,080 --> 00:07:14,099
so you could get this value if for or

00:07:11,580 --> 00:07:15,960
you chose all one bits and for and you

00:07:14,099 --> 00:07:17,419
chose all zero bits for undef that's a

00:07:15,960 --> 00:07:19,919
perfectly reasonable thing to fold it to

00:07:17,419 --> 00:07:23,130
you can also pull it to this if you

00:07:19,919 --> 00:07:27,150
chose all zero bits for or and all one

00:07:23,130 --> 00:07:30,449
bits for and what about this I can't do

00:07:27,150 --> 00:07:32,310
that because now you've gotten rid of

00:07:30,449 --> 00:07:36,810
the information about X is not possible

00:07:32,310 --> 00:07:38,370
for for that to happen as long as an

00:07:36,810 --> 00:07:40,830
interesting one is you know you want to

00:07:38,370 --> 00:07:41,910
like clear register your X or the X 1

00:07:40,830 --> 00:07:44,340
register with itself doesn't matter

00:07:41,910 --> 00:07:48,330
what's there you'll get 0 all in all of

00:07:44,340 --> 00:07:51,060
you our representation of it when you

00:07:48,330 --> 00:07:53,099
XOR could be any value at any every time

00:07:51,060 --> 00:07:58,199
it's looked at so that folds on death

00:07:53,099 --> 00:08:02,630
not to 0 and then you divide by n def

00:07:58,199 --> 00:08:06,349
things n so implicit undefined behavior

00:08:02,630 --> 00:08:09,270
signed math can't overflow or underflow

00:08:06,349 --> 00:08:11,639
so a minus B is greater than negative 1

00:08:09,270 --> 00:08:14,430
so this looks like this and I are now

00:08:11,639 --> 00:08:19,470
we've got a new little thing here NSW no

00:08:14,430 --> 00:08:21,470
sign wrap if I under Florida would what

00:08:19,470 --> 00:08:26,400
happened this would have a boy's value

00:08:21,470 --> 00:08:31,470
and so the compiler looks at this and

00:08:26,400 --> 00:08:33,870
says that since a minus B cannot

00:08:31,470 --> 00:08:35,579
underflow a minus B will be greater than

00:08:33,870 --> 00:08:38,430
negative 1 if a is greater than equal to

00:08:35,579 --> 00:08:44,130
B so we removed the subtracting just

00:08:38,430 --> 00:08:45,990
folded it into the cop so the kind of

00:08:44,130 --> 00:08:49,440
undefined behavior is technically single

00:08:45,990 --> 00:08:52,829
so here we've got an 8 and alone we're

00:08:49,440 --> 00:08:54,450
gonna store two x5 started sorry so 5h

00:08:52,829 --> 00:08:57,990
36 DK and

00:08:54,450 --> 00:09:01,410
value of age and but we were sneaky and

00:08:57,990 --> 00:09:03,990
main and cast our value to two different

00:09:01,410 --> 00:09:05,310
things so and this is what's this

00:09:03,990 --> 00:09:07,380
optimization is going to be known as

00:09:05,310 --> 00:09:09,810
like s strict aliasing graph no strict

00:09:07,380 --> 00:09:11,460
aliasing is what's going to hit this so

00:09:09,810 --> 00:09:14,720
this was it looks like an IR this is a

00:09:11,460 --> 00:09:17,100
simplified representation of how we do

00:09:14,720 --> 00:09:19,680
tech based alias analysis what we're

00:09:17,100 --> 00:09:24,030
gonna say for this that that string

00:09:19,680 --> 00:09:27,540
after the TPA a is loads and stores only

00:09:24,030 --> 00:09:32,430
a only alias if that string is the same

00:09:27,540 --> 00:09:36,210
so the store to H in the loop and the

00:09:32,430 --> 00:09:38,940
store decay by asserting that like int

00:09:36,210 --> 00:09:40,500
long at the same thing then they can't

00:09:38,940 --> 00:09:42,450
possibly be storing to the same value

00:09:40,500 --> 00:09:45,570
because we just said that so we can

00:09:42,450 --> 00:09:47,640
actually store to do sort of load

00:09:45,570 --> 00:09:55,740
forwarding and just put five right there

00:09:47,640 --> 00:09:56,580
directly don't need to load I got

00:09:55,740 --> 00:10:01,410
another example here

00:09:56,580 --> 00:10:03,660
termination so this is actually a fun

00:10:01,410 --> 00:10:06,090
one from John Rhaegar's blog he actually

00:10:03,660 --> 00:10:08,010
has an awesome blog embedded academia

00:10:06,090 --> 00:10:10,380
and he's super serious not undefined

00:10:08,010 --> 00:10:11,640
behavior so you wanted more read read

00:10:10,380 --> 00:10:14,180
his blog

00:10:11,640 --> 00:10:16,770
I guess example so we're gonna calculate

00:10:14,180 --> 00:10:19,170
their wants serum well we're gonna

00:10:16,770 --> 00:10:22,230
evaluate it and if we ever had a case

00:10:19,170 --> 00:10:24,060
where it's true then we're gonna return

00:10:22,230 --> 00:10:29,220
1 otherwise we're just gonna keep moving

00:10:24,060 --> 00:10:31,470
over yeah what does this print prints

00:10:29,220 --> 00:10:34,400
disproved how'd they optimize you do

00:10:31,470 --> 00:10:36,630
that so it's actually pretty simple but

00:10:34,400 --> 00:10:38,550
this is the what the IR looks like

00:10:36,630 --> 00:10:40,230
ignoring so this is just the control

00:10:38,550 --> 00:10:42,900
flow wasn't enough real on the slide for

00:10:40,230 --> 00:10:44,790
the whole thing but the point thing that

00:10:42,900 --> 00:10:47,220
note app note here is so this is raw

00:10:44,790 --> 00:10:49,920
from clang without authorization is that

00:10:47,220 --> 00:10:51,360
this is the only return it like didn't

00:10:49,920 --> 00:10:53,550
even code didn't return 0 because it's

00:10:51,360 --> 00:10:55,500
trivially trivially dead because it was

00:10:53,550 --> 00:10:57,300
a wild one loop can't can't ever read

00:10:55,500 --> 00:11:01,800
can't ever break out of that well it was

00:10:57,300 --> 00:11:03,690
a break so since we know that and yeah

00:11:01,800 --> 00:11:05,610
this little pass their procedural sparse

00:11:03,690 --> 00:11:07,500
constant additional constant propagation

00:11:05,610 --> 00:11:08,850
anyway basically just looked in the

00:11:07,500 --> 00:11:10,500
Fermont saw the only thing you can

00:11:08,850 --> 00:11:14,460
return is one so we can just clearly

00:11:10,500 --> 00:11:17,490
forward that through and do control flow

00:11:14,460 --> 00:11:21,150
graph simplification and just print out

00:11:17,490 --> 00:11:22,680
disproved now this still hasn't actually

00:11:21,150 --> 00:11:25,020
changed the behavior of the program yeah

00:11:22,680 --> 00:11:26,970
we're still gonna run for month if it

00:11:25,020 --> 00:11:28,830
ever returns we're gonna put true we're

00:11:26,970 --> 00:11:31,800
gonna fit disproved like that's already

00:11:28,830 --> 00:11:36,060
what we're doing what happens next is

00:11:31,800 --> 00:11:40,680
that the optimizer also looks at Vermont

00:11:36,060 --> 00:11:43,080
and it says you know what you did not

00:11:40,680 --> 00:11:44,520
read or write mystique machine State

00:11:43,080 --> 00:11:48,720
visible to the caller so we're gonna

00:11:44,520 --> 00:11:52,280
stick read none on there then we take a

00:11:48,720 --> 00:11:54,090
step over to the standard and

00:11:52,280 --> 00:11:55,440
implementations may assume that this

00:11:54,090 --> 00:11:55,770
thread will eventually do one of these

00:11:55,440 --> 00:11:59,720
things

00:11:55,770 --> 00:12:02,700
terminate io volatile access or tom cops

00:11:59,720 --> 00:12:03,930
this does none of those and all it

00:12:02,700 --> 00:12:07,020
doesn't do any of the bottom three and

00:12:03,930 --> 00:12:15,350
it must terminate so we can just delete

00:12:07,020 --> 00:12:16,710
it they just proved it now and see

00:12:15,350 --> 00:12:18,300
explicitly

00:12:16,710 --> 00:12:20,040
while one is one of these protected

00:12:18,300 --> 00:12:22,080
classes so we actually have to add an

00:12:20,040 --> 00:12:23,460
additional attribute and saying oh wait

00:12:22,080 --> 00:12:36,900
you can't remove this in this case but

00:12:23,460 --> 00:12:38,850
not for C++ is is infinite looping a

00:12:36,900 --> 00:12:41,100
useful thing when you're not when you're

00:12:38,850 --> 00:12:44,280
like when the Kyle compiler can prove

00:12:41,100 --> 00:12:49,170
that you you have no externally visible

00:12:44,280 --> 00:12:52,470
state if it is well then we need to

00:12:49,170 --> 00:12:57,590
provide a way to express that not

00:12:52,470 --> 00:13:00,450
necessarily always doing it because it

00:12:57,590 --> 00:13:03,300
yes do that do there's lots of things

00:13:00,450 --> 00:13:09,150
you can do the wild one though may be

00:13:03,300 --> 00:13:13,290
reasonable mmm not sure but I think

00:13:09,150 --> 00:13:15,330
people can decide that so I got an

00:13:13,290 --> 00:13:16,620
example an octave lifetime some more

00:13:15,330 --> 00:13:18,360
awesome code you'll notice all the code

00:13:16,620 --> 00:13:20,110
in these examples there on these slides

00:13:18,360 --> 00:13:22,780
is just beautiful

00:13:20,110 --> 00:13:24,930
great things you want to write so about

00:13:22,780 --> 00:13:28,420
this pointer let's open up a new block

00:13:24,930 --> 00:13:30,730
making it let's sort the address and

00:13:28,420 --> 00:13:34,630
then dereference up a perfectly

00:13:30,730 --> 00:13:39,580
reasonable thing to do this is what I'll

00:13:34,630 --> 00:13:41,860
be MCS we've got our so this Alaka is

00:13:39,580 --> 00:13:44,110
basically just a laka and see it just

00:13:41,860 --> 00:13:46,930
allocates it on the stack and we get

00:13:44,110 --> 00:13:49,000
these lifetime markers so lifetime start

00:13:46,930 --> 00:13:51,580
loads and stores to a before this are

00:13:49,000 --> 00:13:55,000
dead because it wasn't alive before then

00:13:51,580 --> 00:13:56,620
so clearly why'd you touch it and buy

00:13:55,000 --> 00:14:00,190
time in flows the stories of this after

00:13:56,620 --> 00:14:03,910
the search and so we look at these loads

00:14:00,190 --> 00:14:06,280
and stores and that load loaded from a

00:14:03,910 --> 00:14:08,710
well that was dead let's remove it and

00:14:06,280 --> 00:14:10,690
now that store well nothing is loading

00:14:08,710 --> 00:14:13,920
from it and we're about to end its

00:14:10,690 --> 00:14:16,870
lifetime so we can move the store and

00:14:13,920 --> 00:14:17,740
clean up everything else yeah you didn't

00:14:16,870 --> 00:14:31,500
actually want to do anything in that

00:14:17,740 --> 00:14:33,820
budget so references does this look good

00:14:31,500 --> 00:14:37,900
yeah references can't be it

00:14:33,820 --> 00:14:40,150
you can't find it all and so here's the

00:14:37,900 --> 00:14:43,960
iris ease we've got a new little thing

00:14:40,150 --> 00:14:47,110
here deep referenceable this means that

00:14:43,960 --> 00:14:51,180
you can if you read from a you you are

00:14:47,110 --> 00:14:54,070
it's valid to read up to four bytes so

00:14:51,180 --> 00:14:57,460
the optimizer looks at this integer

00:14:54,070 --> 00:15:00,190
compare against null says a can never be

00:14:57,460 --> 00:15:03,310
known that would violate this let's fold

00:15:00,190 --> 00:15:06,690
that to pulse then let's do some

00:15:03,310 --> 00:15:06,690
inlining holdout to false

00:15:11,400 --> 00:15:17,170
now this example was was actually a jf

00:15:15,520 --> 00:15:20,650
told me about this example this is from

00:15:17,170 --> 00:15:23,320
a recent bug from v8 they decided that

00:15:20,650 --> 00:15:25,570
instead of taking up an extra field to

00:15:23,320 --> 00:15:27,160
represent the these different types of

00:15:25,570 --> 00:15:29,290
things they were just gonna use special

00:15:27,160 --> 00:15:33,310
pointer values and they chose that 0 was

00:15:29,290 --> 00:15:34,420
a great pointer value for none then do

00:15:33,310 --> 00:15:36,250
you want it like so I want to check if

00:15:34,420 --> 00:15:40,150
this thing is none well it's just this

00:15:36,250 --> 00:15:43,170
equals equals done now this always has

00:15:40,150 --> 00:15:46,780
to point to a valid object can't me know

00:15:43,170 --> 00:15:50,110
so if it looks like an IR we add the

00:15:46,780 --> 00:15:52,870
none non null tack now we actually had

00:15:50,110 --> 00:16:02,830
to back this out because it broke a ton

00:15:52,870 --> 00:16:07,390
of code but yeah but hopefully you can

00:16:02,830 --> 00:16:08,410
eventually go back in once we get

00:16:07,390 --> 00:16:10,720
everyone to use undefined behavior

00:16:08,410 --> 00:16:13,450
sanitizer it'll like it we'll get rid of

00:16:10,720 --> 00:16:15,370
em but yeah so in later I'm sorry

00:16:13,450 --> 00:16:19,060
optimizer well yeah so we'll in line

00:16:15,370 --> 00:16:21,010
first in line the none it's just no now

00:16:19,060 --> 00:16:25,750
we have an icon gets null oh look can't

00:16:21,010 --> 00:16:28,210
be no hold that you know oh look it's

00:16:25,750 --> 00:16:31,920
false and hold it again

00:16:28,210 --> 00:16:35,950
pulse oh look we could never be none

00:16:31,920 --> 00:16:40,120
yeah took quite a while for the the

00:16:35,950 --> 00:16:41,170
nodejs guys to get through that bug now

00:16:40,120 --> 00:16:47,470
this was actually like just in the past

00:16:41,170 --> 00:16:49,150
month so now signed under overflow this

00:16:47,470 --> 00:16:51,690
is actually like a really hotly debated

00:16:49,150 --> 00:16:53,500
thing is how it does this actually help

00:16:51,690 --> 00:16:55,480
I'm not gonna be able to answer that

00:16:53,500 --> 00:16:58,360
question today but here are some of the

00:16:55,480 --> 00:17:00,550
optimizations it actually does so we've

00:16:58,360 --> 00:17:01,180
got we're gonna multiply by 20 and then

00:17:00,550 --> 00:17:05,890
divide by 2

00:17:01,180 --> 00:17:08,560
well since if if that overflow if that

00:17:05,890 --> 00:17:10,930
could overflow then we can't just change

00:17:08,560 --> 00:17:12,370
that to 10 but since all right just

00:17:10,930 --> 00:17:14,620
changed it to multiply by 10 but since

00:17:12,370 --> 00:17:19,240
we know can't multiply by 10 got rid of

00:17:14,620 --> 00:17:22,030
that expensive disk multiply by a

00:17:19,240 --> 00:17:24,020
constant and then compare like it's zero

00:17:22,030 --> 00:17:25,610
specifically

00:17:24,020 --> 00:17:28,790
well we don't even need the multiply

00:17:25,610 --> 00:17:35,330
because the scale doesn't matter all we

00:17:28,790 --> 00:17:37,190
care paying it's a zero now this is may

00:17:35,330 --> 00:17:38,630
look weird we don't have into gate Mel

00:17:37,190 --> 00:17:41,060
VM because it's really simple to just do

00:17:38,630 --> 00:17:42,980
subtract from zero to the gate so you're

00:17:41,060 --> 00:17:46,010
dating two things and then comparing

00:17:42,980 --> 00:17:49,130
them sign greater than and then we're

00:17:46,010 --> 00:17:52,700
four is x + 5 is therefore is negative x

00:17:49,130 --> 00:17:54,950
+ 5 is 8 y you can just do that and just

00:17:52,700 --> 00:17:58,070
swap them no need to actually fully do

00:17:54,950 --> 00:18:03,650
that and none of these optimizations

00:17:58,070 --> 00:18:07,340
could be done on on on unsigned or if

00:18:03,650 --> 00:18:12,710
you you have your mat if we made sine

00:18:07,340 --> 00:18:15,620
overflow be defined behavior now what

00:18:12,710 --> 00:18:17,210
this actually can hit is promotion so

00:18:15,620 --> 00:18:22,390
here's our element access function we're

00:18:17,210 --> 00:18:25,900
just gonna add x + y + access into a so

00:18:22,390 --> 00:18:30,200
here's what the code looks like for

00:18:25,900 --> 00:18:35,360
signs types and so we've got the no sign

00:18:30,200 --> 00:18:37,280
wrap and the sign extent the get element

00:18:35,360 --> 00:18:43,160
pointer is basically just the index

00:18:37,280 --> 00:18:45,980
operation into a let me load so let's

00:18:43,160 --> 00:18:48,410
make that you int and look at the code

00:18:45,980 --> 00:18:50,870
here that's basically the same only

00:18:48,410 --> 00:18:53,630
difference is that we now no longer have

00:18:50,870 --> 00:18:57,950
the no side wrap and now it's a 0 sent

00:18:53,630 --> 00:19:00,020
so when you lower this to x86 lovely may

00:18:57,950 --> 00:19:05,030
be the difference the difference here is

00:19:00,020 --> 00:19:08,060
that we do a we do that ad but it could

00:19:05,030 --> 00:19:11,180
have overflowed and so in the unsigned

00:19:08,060 --> 00:19:16,670
case we have to make sure that we only

00:19:11,180 --> 00:19:18,620
take the low part in the sign case we

00:19:16,670 --> 00:19:20,420
must use the 64-bit value directly and

00:19:18,620 --> 00:19:26,900
you have to use 64-bit values for this

00:19:20,420 --> 00:19:29,170
addressing mode which was better the

00:19:26,900 --> 00:19:34,550
shorter one short is always been

00:19:29,170 --> 00:19:35,630
not necessarily true but and so in this

00:19:34,550 --> 00:19:37,820
example it's like I was just a single

00:19:35,630 --> 00:19:39,680
exit instruction well like that can add

00:19:37,820 --> 00:19:42,170
up like with all of your all of your

00:19:39,680 --> 00:19:46,450
accessing functions you got to do that

00:19:42,170 --> 00:19:46,450
and on each step you could have two and

00:19:47,950 --> 00:19:52,720
then when you actually out into a loop

00:19:50,230 --> 00:19:54,560
so here's our a pretty simple loop

00:19:52,720 --> 00:20:01,070
we're in template it we're gonna do it

00:19:54,560 --> 00:20:02,240
on signed and unsigned and yr so this is

00:20:01,070 --> 00:20:04,610
actually what the messy IRA looks like

00:20:02,240 --> 00:20:11,540
this is actually not completely raw I

00:20:04,610 --> 00:20:13,100
ran today it has one pass or something

00:20:11,540 --> 00:20:14,600
add a little bit right over it but if

00:20:13,100 --> 00:20:18,170
you actually want to see the raw I are

00:20:14,600 --> 00:20:20,150
out of playing run all that use of uo3

00:20:18,170 --> 00:20:22,040
and disabled passes because if you don't

00:20:20,150 --> 00:20:24,620
do oh three we actually omit some

00:20:22,040 --> 00:20:26,180
information because later passes we'll

00:20:24,620 --> 00:20:31,790
all like unconditionally use that for

00:20:26,180 --> 00:20:34,070
optimization but after a little bit of

00:20:31,790 --> 00:20:38,840
cleanup we've got a printable loop on

00:20:34,070 --> 00:20:43,370
the right on the left side is the signed

00:20:38,840 --> 00:20:44,330
and right side is on time so explaining

00:20:43,370 --> 00:20:45,380
this so this is the first time we

00:20:44,330 --> 00:20:47,510
actually could deal with this where

00:20:45,380 --> 00:20:51,380
since we're the loop I can change each

00:20:47,510 --> 00:20:53,420
each iteration and LV Mir is a single

00:20:51,380 --> 00:20:54,980
static assignment form and that means

00:20:53,420 --> 00:20:58,100
that you can only assign to something

00:20:54,980 --> 00:21:00,800
once so a way to represent that is just

00:20:58,100 --> 00:21:02,540
basic block arguments where when we come

00:21:00,800 --> 00:21:05,570
into body when we come from the entry

00:21:02,540 --> 00:21:08,180
block we just say that's 0 and that's

00:21:05,570 --> 00:21:11,150
right there and then when we're coming

00:21:08,180 --> 00:21:12,980
from the loop package we say that it's

00:21:11,150 --> 00:21:18,830
the new value of I which we added to to

00:21:12,980 --> 00:21:20,480
it this is new value and first we do a

00:21:18,830 --> 00:21:22,340
little bit of clean up we got a clean up

00:21:20,480 --> 00:21:25,610
the loop so that this we can do some

00:21:22,340 --> 00:21:27,950
magic to it up here remove the add up it

00:21:25,610 --> 00:21:31,580
the add didn't actually change anything

00:21:27,950 --> 00:21:37,640
it didn't change the value of I if we if

00:21:31,580 --> 00:21:38,920
we have to exit and then we simplify the

00:21:37,640 --> 00:21:41,440
induction variable

00:21:38,920 --> 00:21:42,610
and we just add a bunch in you code it

00:21:41,440 --> 00:21:46,630
there why do we have a list Nico

00:21:42,610 --> 00:21:49,600
well you'll note that we return ret gret

00:21:46,630 --> 00:21:53,560
seer takes four four is up there this

00:21:49,600 --> 00:21:56,170
whole loop body is dead now we're able

00:21:53,560 --> 00:21:58,540
to completely fold away that way and why

00:21:56,170 --> 00:22:00,400
were able to do that well because if we

00:21:58,540 --> 00:22:04,480
go back to our original sequence what's

00:22:00,400 --> 00:22:12,820
good all we're doing here is getting in

00:22:04,480 --> 00:22:16,810
and getting the the even value less than

00:22:12,820 --> 00:22:20,020
or equal to it so if if n is odd then it

00:22:16,810 --> 00:22:25,330
gets n minus one and if it's even it

00:22:20,020 --> 00:22:26,880
just returns it and so if we look over

00:22:25,330 --> 00:22:30,850
here that's exactly what this is doing

00:22:26,880 --> 00:22:33,120
we compare getting at zero because if it

00:22:30,850 --> 00:22:35,440
is negative

00:22:33,120 --> 00:22:40,870
something weird happens I think you get

00:22:35,440 --> 00:22:43,030
untie behavior here or yeah witches

00:22:40,870 --> 00:22:46,210
can't have na interpreting loop so under

00:22:43,030 --> 00:22:52,690
I mater and then we so we just do a max

00:22:46,210 --> 00:22:55,240
operation then we add one and then

00:22:52,690 --> 00:22:57,400
actually remove that one that that just

00:22:55,240 --> 00:23:01,270
folds to an and of the removes a little

00:22:57,400 --> 00:23:07,320
bit while our unsigned case actually

00:23:01,270 --> 00:23:10,750
still has the full code of a full loop

00:23:07,320 --> 00:23:13,540
because when induction variable

00:23:10,750 --> 00:23:14,950
simplification came in and it does like

00:23:13,540 --> 00:23:17,530
that's actually part of the optimizer I

00:23:14,950 --> 00:23:22,810
don't fully understand but basically

00:23:17,530 --> 00:23:24,100
what it does is it looks over so I as

00:23:22,810 --> 00:23:27,280
the inductive variable it looks at that

00:23:24,100 --> 00:23:29,290
and it actually forms some crazy

00:23:27,280 --> 00:23:32,230
mathematical expression about how it's

00:23:29,290 --> 00:23:34,000
changing every every time and then looks

00:23:32,230 --> 00:23:37,590
at what the beginning and end conditions

00:23:34,000 --> 00:23:39,970
are and uses that to try and either

00:23:37,590 --> 00:23:45,420
simplify it or completely remove the

00:23:39,970 --> 00:23:51,820
loop and it failed on unsigned because

00:23:45,420 --> 00:23:56,100
with plus 2 if n is unsigned

00:23:51,820 --> 00:23:59,170
max this actually becomes an infinitely

00:23:56,100 --> 00:24:01,960
now infinite loops where all I'd have

00:23:59,170 --> 00:24:05,710
those technically they could have hold

00:24:01,960 --> 00:24:07,510
folded this thing - I don't know if -

00:24:05,710 --> 00:24:10,420
lab the folds - undef I think it might

00:24:07,510 --> 00:24:16,300
have been but it cuz I got rid of it it

00:24:10,420 --> 00:24:20,080
doesn't actually do that but that's

00:24:16,300 --> 00:24:23,520
basically one of the but the sign course

00:24:20,080 --> 00:24:26,020
unsigned is it doesn't heavily limit the

00:24:23,520 --> 00:24:44,530
reasoning that these optimizations can

00:24:26,020 --> 00:24:45,610
do no well it could it could have

00:24:44,530 --> 00:24:49,780
reduced the same code that's perfectly

00:24:45,610 --> 00:24:51,130
valid because I believe that this can

00:24:49,780 --> 00:24:55,080
just be it becomes undefined behavior

00:24:51,130 --> 00:24:58,900
and then it can become whatever it was

00:24:55,080 --> 00:25:11,110
but it didn't all of iam doesn't was not

00:24:58,900 --> 00:25:14,050
able to reason that far for for indexing

00:25:11,110 --> 00:25:17,920
and for your loop bounce anything that

00:25:14,050 --> 00:25:23,680
has bounced or influences of loop bounds

00:25:17,920 --> 00:25:30,400
yes and you sanitizers so that you don't

00:25:23,680 --> 00:25:32,350
and and good fuzzing so that you can

00:25:30,400 --> 00:25:36,670
actually figure out if you do have ever

00:25:32,350 --> 00:25:39,040
accidentally overflow what in some loops

00:25:36,670 --> 00:25:40,690
it like it doesn't matter but there

00:25:39,040 --> 00:25:41,830
there there are loops where's the

00:25:40,690 --> 00:25:44,200
difference between signed and unsigned

00:25:41,830 --> 00:25:47,800
is like 25% because it's able to get a

00:25:44,200 --> 00:25:49,540
get rid of a lot of weird sign extending

00:25:47,800 --> 00:25:55,260
stuff it has to do or it's just able to

00:25:49,540 --> 00:25:55,260
much better calculate loop bounds

00:25:57,090 --> 00:26:03,820
so our next example here realloc this

00:26:02,139 --> 00:26:06,609
was actually another one from John

00:26:03,820 --> 00:26:08,049
records blog which was actually us soon

00:26:06,609 --> 00:26:09,279
yet he held a contest for like what's

00:26:08,049 --> 00:26:10,659
the craziest time to find behavior you

00:26:09,279 --> 00:26:13,210
can find there are the most surprising

00:26:10,659 --> 00:26:18,669
and Nick knew lucky who used to work on

00:26:13,210 --> 00:26:24,369
all of you submitted this one so what do

00:26:18,669 --> 00:26:32,559
we think this Prince can you want to

00:26:24,369 --> 00:26:35,469
guess - - yes - - is a reasonable guess

00:26:32,559 --> 00:26:37,690
like you would think so if being Q are

00:26:35,469 --> 00:26:39,999
equal there they have the same address

00:26:37,690 --> 00:26:42,249
how can they put different inks yeah one

00:26:39,999 --> 00:26:44,049
- how does how does all of you do this

00:26:42,249 --> 00:26:45,460
so like I thought this was gonna be

00:26:44,049 --> 00:26:48,359
actually a little bit complicated but it

00:26:45,460 --> 00:26:51,909
turned out to be pretty simple

00:26:48,359 --> 00:26:53,559
seriously I are I did omit the branch so

00:26:51,909 --> 00:26:55,119
the only thing missing here is this if T

00:26:53,559 --> 00:26:56,619
equals equals Q because it actually has

00:26:55,119 --> 00:27:00,609
nothing to do with the analysis stuff

00:26:56,619 --> 00:27:05,080
the optimizer does you know another new

00:27:00,609 --> 00:27:06,039
keyword here no alias so malloc and all

00:27:05,080 --> 00:27:09,849
the allocation functions have this

00:27:06,039 --> 00:27:13,719
property that the return value aliases

00:27:09,849 --> 00:27:16,299
nothing else in the program and it's

00:27:13,719 --> 00:27:18,009
included Rioch relock may choose not to

00:27:16,299 --> 00:27:21,519
move anything but it still invalidates

00:27:18,009 --> 00:27:22,989
the old pointer and we model this so we

00:27:21,519 --> 00:27:25,570
put no way on this so we've got the

00:27:22,989 --> 00:27:27,969
store to P start of Q load P load Q use

00:27:25,570 --> 00:27:31,919
the values start a load forwarding what

00:27:27,969 --> 00:27:36,940
comes in here it goes look at P are the

00:27:31,919 --> 00:27:40,089
load of P it goes backwards finds the

00:27:36,940 --> 00:27:42,639
store the P of 1 then it looks to see if

00:27:40,089 --> 00:27:44,320
anything could have invalidated that and

00:27:42,639 --> 00:27:46,330
it's used to sort of cute it goes and

00:27:44,320 --> 00:27:47,799
does some alias analysis and says well

00:27:46,330 --> 00:27:49,869
beam Q can't be the same value because

00:27:47,799 --> 00:27:51,820
we've got this new alias attribute so

00:27:49,869 --> 00:27:57,669
you know what we're just gonna afford

00:27:51,820 --> 00:28:00,519
that so well 1 2 or print 1 2 and that

00:27:57,669 --> 00:28:04,379
if doesn't even matter at runtime they

00:28:00,519 --> 00:28:04,379
happen to be equal so prints 1 2

00:28:11,710 --> 00:28:36,200
um it could have done that

00:28:14,149 --> 00:28:39,289
does that sorry all right so the

00:28:36,200 --> 00:28:42,619
question was why didn't it proved that

00:28:39,289 --> 00:28:47,539
they were false and Richard over here

00:28:42,619 --> 00:29:00,950
they pointer quality and and memory

00:28:47,539 --> 00:29:02,899
quality is orthogonal I don't I don't

00:29:00,950 --> 00:29:04,340
actually know I don't remember what I'll

00:29:02,899 --> 00:29:05,989
gain guarantees there because there's

00:29:04,340 --> 00:29:12,019
like there when you're at this level

00:29:05,989 --> 00:29:13,759
there's the LLVM like lane graph

00:29:12,019 --> 00:29:16,220
what are we guarantee about rir and

00:29:13,759 --> 00:29:19,210
there's actually c++ and it's clangs job

00:29:16,220 --> 00:29:23,509
to map c++ semantics to LLVM semantics

00:29:19,210 --> 00:29:25,249
but so I don't actually know I don't

00:29:23,509 --> 00:29:27,259
even know if do you Richard you actually

00:29:25,249 --> 00:29:31,960
know if by language rules if you'd be

00:29:27,259 --> 00:29:31,960
able to assume that that was false

00:29:38,169 --> 00:29:49,489
maybe it's an interesting one this one I

00:29:45,139 --> 00:29:50,600
actually I really like this example how

00:29:49,489 --> 00:29:52,669
much do people think that we can

00:29:50,600 --> 00:29:56,299
optimize this we've got sequentially

00:29:52,669 --> 00:29:58,639
consistent stars and loads so what's the

00:29:56,299 --> 00:30:00,200
consistent means that there's a total

00:29:58,639 --> 00:30:01,549
ordering across all threads this is the

00:30:00,200 --> 00:30:03,440
only thread we're looking at the only

00:30:01,549 --> 00:30:06,320
function we're looking at out at then

00:30:03,440 --> 00:30:07,609
that the optimizer now Fraser might not

00:30:06,320 --> 00:30:08,899
know about anything else in the program

00:30:07,609 --> 00:30:12,950
you can just see this and it knows that

00:30:08,899 --> 00:30:16,210
we've got x and y so any any guesses

00:30:12,950 --> 00:30:16,210
about what we can optimize this to

00:30:32,500 --> 00:30:45,640
which do I still have to store zero oh

00:30:53,800 --> 00:30:57,560
they have been in it may have been

00:30:55,640 --> 00:31:02,720
written to something else it does that

00:30:57,560 --> 00:31:09,800
part doesn't matter here so this is what

00:31:02,720 --> 00:31:12,110
we've got NIR our store and then OPM

00:31:09,800 --> 00:31:13,550
explicitly models Atomics as it turns

00:31:12,110 --> 00:31:17,270
out there out are optimizations you can

00:31:13,550 --> 00:31:20,420
do on them so we've got our sequentially

00:31:17,270 --> 00:31:23,960
consistent store and a sequentially

00:31:20,420 --> 00:31:27,860
consistent load comparison and then some

00:31:23,960 --> 00:31:34,070
branches and store if it was here so the

00:31:27,860 --> 00:31:37,730
first thing we do is what you said which

00:31:34,070 --> 00:31:39,890
is you can forward that and why can we

00:31:37,730 --> 00:31:44,300
do that well because while there is a

00:31:39,890 --> 00:31:45,890
total order we can assume that but not

00:31:44,300 --> 00:31:48,350
just assume we can just say that o our

00:31:45,890 --> 00:31:51,470
total order was this and nothing can

00:31:48,350 --> 00:31:56,330
observe could have observed can observe

00:31:51,470 --> 00:31:59,780
the difference so we foldable that away

00:31:56,330 --> 00:32:02,540
yeah we've got this now can we remove

00:31:59,780 --> 00:32:05,000
that x equals zero well let's take a

00:32:02,540 --> 00:32:07,280
look at what the standard says bunch of

00:32:05,000 --> 00:32:10,640
words but basically what this is saying

00:32:07,280 --> 00:32:13,190
is sequentially we have a total of a

00:32:10,640 --> 00:32:20,180
total order of all loads of sorts the

00:32:13,190 --> 00:32:24,320
program if data race-free and we look

00:32:20,180 --> 00:32:28,610
here can another pro like if another

00:32:24,320 --> 00:32:29,430
thing reads X so so another thing is

00:32:28,610 --> 00:32:34,320
waiting on zere

00:32:29,430 --> 00:32:37,200
on on why to be set to zero and then and

00:32:34,320 --> 00:32:43,770
then it reads X right after that is that

00:32:37,200 --> 00:32:46,530
a data race yep so that's a day race and

00:32:43,770 --> 00:32:53,250
so we can't have beta races so remove

00:32:46,530 --> 00:32:55,170
that a store to the store so this was

00:32:53,250 --> 00:32:58,260
this is surprising to a lot of people as

00:32:55,170 --> 00:32:59,220
a bit surprising to me but after we

00:32:58,260 --> 00:33:01,410
think about it for a while it's like

00:32:59,220 --> 00:33:15,150
yeah you can do that elohim doesn't do

00:33:01,410 --> 00:33:19,620
those GCC doesn't do this yes and i will

00:33:15,150 --> 00:33:22,050
plug a talk about this later but we do

00:33:19,620 --> 00:33:25,230
it we do LVM does do a few things it's

00:33:22,050 --> 00:33:26,880
just not aggressive we did at one point

00:33:25,230 --> 00:33:28,740
we were a little bit aggressive but it

00:33:26,880 --> 00:33:30,690
was either wrong or we weren't sure with

00:33:28,740 --> 00:33:34,800
a model or something and that got backed

00:33:30,690 --> 00:33:38,040
out and so we're pretty conservative

00:33:34,800 --> 00:33:41,820
right now but but we can be more and i'm

00:33:38,040 --> 00:33:45,090
not i DC doesn't do this i don't know if

00:33:41,820 --> 00:33:49,140
it does other things but they're

00:33:45,090 --> 00:33:52,140
definitely allowed to so we've got all

00:33:49,140 --> 00:33:56,910
this undefined behavior what can you do

00:33:52,140 --> 00:33:59,100
about it because you're like things go

00:33:56,910 --> 00:34:02,160
wrong your program doesn't work in an

00:33:59,100 --> 00:34:04,080
optimized build works fine and debug and

00:34:02,160 --> 00:34:05,970
you have no idea why and because the

00:34:04,080 --> 00:34:08,190
compilers are now so aggressive about in

00:34:05,970 --> 00:34:10,110
fly behavior like the result this makes

00:34:08,190 --> 00:34:11,760
no sense there's like paradoxes this

00:34:10,110 --> 00:34:14,220
value was both true and false at the

00:34:11,760 --> 00:34:18,360
same time like everything's everything's

00:34:14,220 --> 00:34:22,620
going crazy well first thing warnings

00:34:18,360 --> 00:34:24,080
have you all to be actually w this like

00:34:22,620 --> 00:34:29,159
these warnings will actually catch

00:34:24,080 --> 00:34:31,649
almost all of the examples here but no

00:34:29,159 --> 00:34:33,980
one writes like code like this generally

00:34:31,649 --> 00:34:36,570
these under five behaviors will come in

00:34:33,980 --> 00:34:39,990
through inlining or through more

00:34:36,570 --> 00:34:42,839
complicated things so

00:34:39,990 --> 00:34:45,869
sanitize and fuzz you've got dressing

00:34:42,839 --> 00:34:48,089
tiser undefined behavior sanitizing

00:34:45,869 --> 00:34:51,179
thread memory and now efficiency and

00:34:48,089 --> 00:34:54,480
data flow and a few others but but like

00:34:51,179 --> 00:34:56,669
so for my testing I like I always run

00:34:54,480 --> 00:34:58,380
undefined the dress because you can run

00:34:56,669 --> 00:35:01,230
them together and that catches so much

00:34:58,380 --> 00:35:03,359
and it points you exactly to where it is

00:35:01,230 --> 00:35:05,310
I'm I've been talking with lots of talks

00:35:03,359 --> 00:35:07,320
about it about these sanitizers so if

00:35:05,310 --> 00:35:10,740
you haven't used them yet you definitely

00:35:07,320 --> 00:35:12,030
should and but if you're doing this it's

00:35:10,740 --> 00:35:15,420
run time so you have to have good

00:35:12,030 --> 00:35:19,320
fuzzing and good coverage and that ik

00:35:15,420 --> 00:35:22,230
analysis we've got clang primary to keep

00:35:19,320 --> 00:35:27,690
us to view among the others that will

00:35:22,230 --> 00:35:28,560
all help you find these bugs so what

00:35:27,690 --> 00:35:34,230
does the committee doing about this

00:35:28,560 --> 00:35:36,119
problem well about is it is it a problem

00:35:34,230 --> 00:35:39,839
but what's happening in the committee

00:35:36,119 --> 00:35:41,700
about this so su 12 undefined behavior

00:35:39,839 --> 00:35:44,609
I got a steady group for it what have

00:35:41,700 --> 00:35:46,560
they done well in sea level 17 we have

00:35:44,609 --> 00:35:50,730
strengthened the order of argument

00:35:46,560 --> 00:35:54,570
evaluation it is not not totally ordered

00:35:50,730 --> 00:35:57,990
but does not have a guaranteed order but

00:35:54,570 --> 00:35:59,430
you are no longer allowed to slice like

00:35:57,990 --> 00:36:00,810
it's no longer like you can't have like

00:35:59,430 --> 00:36:02,910
inner leave all the operations at the

00:36:00,810 --> 00:36:08,430
same time it's like it happens in some

00:36:02,910 --> 00:36:10,740
order we also got rid of undefined

00:36:08,430 --> 00:36:12,060
behavior oh no we are getting rid of

00:36:10,740 --> 00:36:14,940
undefined behavior the free processor

00:36:12,060 --> 00:36:18,660
that one's like like not actually going

00:36:14,940 --> 00:36:19,800
to hit you at runtime but it's like

00:36:18,660 --> 00:36:22,070
there's no reason to have it in a

00:36:19,800 --> 00:36:22,070
preprocessor

00:36:22,940 --> 00:36:30,569
like I I don't know the examples there's

00:36:28,260 --> 00:36:32,430
some weird like if you paste tokens in

00:36:30,569 --> 00:36:34,230
the wrong way and form something it's

00:36:32,430 --> 00:36:38,789
like I know my behavior or there's weird

00:36:34,230 --> 00:36:41,460
things like compilers are good they

00:36:38,789 --> 00:36:43,910
don't they don't like erase your hard

00:36:41,460 --> 00:36:48,960
drive when they hit that case but again

00:36:43,910 --> 00:36:51,299
malicious compilers making them Thompson

00:36:48,960 --> 00:36:52,619
copy saver there's something so you

00:36:51,299 --> 00:36:54,000
currently can't deal with them copy that

00:36:52,619 --> 00:36:57,650
program was expected to be able to do

00:36:54,000 --> 00:37:03,809
and so we're trying to make those things

00:36:57,650 --> 00:37:05,519
well define behavior and they're all

00:37:03,809 --> 00:37:08,220
getting rid of unneeded undefined

00:37:05,519 --> 00:37:10,019
behavior and that can be really

00:37:08,220 --> 00:37:11,970
controversial like oh do you need this

00:37:10,019 --> 00:37:12,890
do we need this but there are some that

00:37:11,970 --> 00:37:14,460
are pretty honest rippers

00:37:12,890 --> 00:37:15,869
uncontroversial where it's things that

00:37:14,460 --> 00:37:20,460
like this is something that every

00:37:15,869 --> 00:37:22,559
programmer does and like compilers don't

00:37:20,460 --> 00:37:24,269
want like they don't even really want

00:37:22,559 --> 00:37:29,099
optimize it it's not useful to optimize

00:37:24,269 --> 00:37:31,500
but it currently undefined and those

00:37:29,099 --> 00:37:35,089
kind of things are good to get defined

00:37:31,500 --> 00:37:38,880
our light are pretty unconventional

00:37:35,089 --> 00:37:41,359
so if you're interested in more oncoming

00:37:38,880 --> 00:37:45,079
behavior there are some more talks here

00:37:41,359 --> 00:37:47,910
Chandler will be giving a talk which is

00:37:45,079 --> 00:37:51,660
much less about the like why is the

00:37:47,910 --> 00:37:53,059
compiler giving this and more ways of

00:37:51,660 --> 00:37:56,490
thinking about undefined behavior and

00:37:53,059 --> 00:38:00,420
Jeff as is no same compiler with

00:37:56,490 --> 00:38:03,329
optimize talks not not entirely about on

00:38:00,420 --> 00:38:06,539
to my behavior but much more in detail

00:38:03,329 --> 00:38:08,930
about atomic optimization so any

00:38:06,539 --> 00:38:08,930
questions

00:38:11,740 --> 00:38:21,049
so so I actually had a friend who's an

00:38:18,769 --> 00:38:25,130
artist and I'm sorry what's up with the

00:38:21,049 --> 00:38:28,579
pony I I had a friend or sorry I have a

00:38:25,130 --> 00:38:30,380
friend who's noticed that I was like she

00:38:28,579 --> 00:38:31,700
was like oh I might be the opening

00:38:30,380 --> 00:38:33,200
Commission's up I was like do I actually

00:38:31,700 --> 00:38:36,170
want anything drawn I was like you know

00:38:33,200 --> 00:38:38,990
what I want an LVM Tony so made that

00:38:36,170 --> 00:38:41,299
then I show that some people in the

00:38:38,990 --> 00:38:43,009
Elven community and Jay s on he's like

00:38:41,299 --> 00:38:47,089
you know what we should do an April 1st

00:38:43,009 --> 00:38:52,460
post so we actually planned that and jf

00:38:47,089 --> 00:38:54,819
wrote up a a blog post about where it

00:38:52,460 --> 00:38:59,359
was like changing the motto to say yeah

00:38:54,819 --> 00:39:00,829
LLVM on defined behaviors magic we're

00:38:59,359 --> 00:39:02,269
gonna like there's been all this

00:39:00,829 --> 00:39:03,650
discussion about on the fire behavior

00:39:02,269 --> 00:39:07,309
now we're gonna we're gonna be all nice

00:39:03,650 --> 00:39:10,150
about it or or something like that but

00:39:07,309 --> 00:39:10,150
that was pretty fun

00:39:21,760 --> 00:39:27,380
so why is unsigned sry his sign to

00:39:25,730 --> 00:39:30,170
overflow into find behavior but unsigned

00:39:27,380 --> 00:39:34,880
not so the reason I originally heard for

00:39:30,170 --> 00:39:36,440
this was that back in the day there was

00:39:34,880 --> 00:39:40,550
one of the implementation or one of the

00:39:36,440 --> 00:39:43,580
processors would trap on signed overflow

00:39:40,550 --> 00:40:05,930
and so it's just like at sunup my

00:39:43,580 --> 00:40:06,860
behavior yes yes ask IBM and yeah so why

00:40:05,930 --> 00:40:10,910
I like they could have chosen

00:40:06,860 --> 00:40:13,400
implementation defined behavior or like

00:40:10,910 --> 00:40:15,580
delineate the set of behaviors but so I

00:40:13,400 --> 00:40:19,090
don't know exactly why it was originally

00:40:15,580 --> 00:40:21,560
now though it has remained so because

00:40:19,090 --> 00:40:46,550
compilers make heavy use of this

00:40:21,560 --> 00:40:50,090
information while optimizing I did try

00:40:46,550 --> 00:40:52,190
an example with that I don't I wasn't

00:40:50,090 --> 00:40:56,090
able to get sorry you get a repeating

00:40:52,190 --> 00:40:58,070
question so comparison of pointers to

00:40:56,090 --> 00:41:01,880
different objects is undefined behavior

00:40:58,070 --> 00:41:03,890
and but stood less can compare any

00:41:01,880 --> 00:41:06,880
pointer and it's well defined are any

00:41:03,890 --> 00:41:06,880
two pointers in its well-defined

00:41:07,340 --> 00:41:12,310
I forgot actually the last part of it

00:41:18,320 --> 00:41:24,990
is that something that the optimizers

00:41:21,600 --> 00:41:27,900
can use or should it be cut

00:41:24,990 --> 00:41:29,130
Elvia doesn't currently use it I heard

00:41:27,900 --> 00:41:33,930
that I'm aware of

00:41:29,130 --> 00:41:35,760
I think GCC does there was a that might

00:41:33,930 --> 00:41:39,750
have been pointer overflow I'm actually

00:41:35,760 --> 00:41:43,440
not sure if DC's he does so I'm not sure

00:41:39,750 --> 00:41:47,010
I could actually answer that if nobody's

00:41:43,440 --> 00:41:49,530
using it it could be considered but it

00:41:47,010 --> 00:41:52,550
also doesn't really make sense to

00:41:49,530 --> 00:41:58,470
compare pointers to different objects

00:41:52,550 --> 00:42:00,840
yeah it does so and the reason why so

00:41:58,470 --> 00:42:03,060
you can convert to entirety and do the

00:42:00,840 --> 00:42:05,400
comparison which is an implementation to

00:42:03,060 --> 00:42:06,990
find mapping but it like isn't going to

00:42:05,400 --> 00:42:10,340
map to pointers that are different to

00:42:06,990 --> 00:42:30,320
the same value it's not a lot to do that

00:42:10,340 --> 00:42:30,320
so either way I'm not not really sure so

00:42:30,950 --> 00:42:37,260
currently the accessing the yeah

00:42:35,100 --> 00:42:39,960
accessing the is right so the question

00:42:37,260 --> 00:42:41,490
was I was explaining the question

00:42:39,960 --> 00:42:44,960
without first saying that yeah so the

00:42:41,490 --> 00:42:48,180
question was accessing the non active

00:42:44,960 --> 00:42:52,410
member of a union is currently undefined

00:42:48,180 --> 00:42:59,990
behavior and and one of my thoughts on

00:42:52,410 --> 00:43:05,840
that or opinion of that well there are

00:42:59,990 --> 00:43:14,510
things that the that employees can do

00:43:05,840 --> 00:43:14,510
that trying to give a good example here

00:43:15,410 --> 00:43:21,150
so it's not just that like that

00:43:19,320 --> 00:43:22,830
compilers can take advantage of this

00:43:21,150 --> 00:43:25,620
like LVN explicitly does it take

00:43:22,830 --> 00:43:28,250
advantage of this and I think GCC

00:43:25,620 --> 00:43:28,250
doesn't either

00:43:28,619 --> 00:43:33,969
yeah yeah yeah yeah

00:43:32,439 --> 00:43:37,089
and so olivine does the same thing

00:43:33,969 --> 00:43:39,160
probably because of GCC now the problem

00:43:37,089 --> 00:43:45,609
is like making it well defined behavior

00:43:39,160 --> 00:43:48,579
is like you an example here might be

00:43:45,609 --> 00:43:52,150
like a float in an INT like you might

00:43:48,579 --> 00:43:56,109
try to access it as a float but it was

00:43:52,150 --> 00:43:59,069
actually a trap value and now you got a

00:43:56,109 --> 00:44:03,640
trap on you and well whatever can happen

00:43:59,069 --> 00:44:05,380
and that sense you don't know what the

00:44:03,640 --> 00:44:07,089
active memory is you might not actually

00:44:05,380 --> 00:44:09,670
be able to like guarantee a certain

00:44:07,089 --> 00:44:15,579
behaviour that we could say I'm

00:44:09,670 --> 00:44:16,829
specified behavior but I don't know how

00:44:15,579 --> 00:44:19,829
hard it would be to make that

00:44:16,829 --> 00:44:19,829
well-defined

00:44:47,319 --> 00:44:53,990
so if I can if I'm able to summarize

00:44:50,329 --> 00:44:55,579
that there's a problem with with you

00:44:53,990 --> 00:45:00,250
with actually was a union of an int and

00:44:55,579 --> 00:45:05,869
float and if you even only accessing the

00:45:00,250 --> 00:45:09,609
integer part it would I actually missed

00:45:05,869 --> 00:45:09,609
like it would write a different value or

00:45:10,390 --> 00:45:14,990
while using it as an integer it would it

00:45:13,339 --> 00:45:18,500
would use the FPU to do loads and stores

00:45:14,990 --> 00:45:51,140
and if that became a bad value then you

00:45:18,500 --> 00:45:53,119
got this weird yeah so if we were to

00:45:51,140 --> 00:45:57,950
give like full well specified to that we

00:45:53,119 --> 00:46:00,410
would also have to like specify unsigned

00:45:57,950 --> 00:46:02,059
the sign conversion and an alignment all

00:46:00,410 --> 00:46:03,680
these things but in more generally yeah

00:46:02,059 --> 00:46:05,540
you'd have to say like when you take

00:46:03,680 --> 00:46:08,359
this bit value and putting this bit

00:46:05,540 --> 00:46:11,900
value or in this other tight like what

00:46:08,359 --> 00:46:19,210
does that mean for basically every

00:46:11,900 --> 00:46:19,210
conversion any other questions

00:46:21,110 --> 00:46:24,800

YouTube URL: https://www.youtube.com/watch?v=g7entxbQOCc


