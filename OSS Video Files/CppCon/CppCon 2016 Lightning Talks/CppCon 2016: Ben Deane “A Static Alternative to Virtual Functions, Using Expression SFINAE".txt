Title: CppCon 2016: Ben Deane “A Static Alternative to Virtual Functions, Using Expression SFINAE"
Publication date: 2016-10-08
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,710
all right so I was playing with this

00:00:02,700 --> 00:00:06,020
recipe the other day and I thought it

00:00:04,710 --> 00:00:11,010
might be interesting to share with you

00:00:06,020 --> 00:00:11,969
so we're all familiar with yeah this is

00:00:11,010 --> 00:00:13,380
an application of the expressions for

00:00:11,969 --> 00:00:15,900
possibly the fastest talk you'll see

00:00:13,380 --> 00:00:19,020
with expressions meaning so we're all

00:00:15,900 --> 00:00:20,460
familiar with the familiar interface my

00:00:19,020 --> 00:00:23,400
dear so whether you call it whether you

00:00:20,460 --> 00:00:24,810
use a pimple idiom Hazar or an is a the

00:00:23,400 --> 00:00:26,130
idea is you have your interface with the

00:00:24,810 --> 00:00:27,840
virtual functions and then your

00:00:26,130 --> 00:00:29,310
implementation which is encapsulated and

00:00:27,840 --> 00:00:32,700
as the details of you know what you

00:00:29,310 --> 00:00:34,620
actually do now this is normal in kind

00:00:32,700 --> 00:00:37,739
of object-oriented code so I had this

00:00:34,620 --> 00:00:39,000
idea of doing it with all static so the

00:00:37,739 --> 00:00:41,219
idea is basically that we're going to

00:00:39,000 --> 00:00:44,610
have the interface be a class template

00:00:41,219 --> 00:00:46,590
and the implementation will be its

00:00:44,610 --> 00:00:50,579
template argument this applies the

00:00:46,590 --> 00:00:52,170
functionality and then we have in our

00:00:50,579 --> 00:00:54,780
interface a set of basis functions

00:00:52,170 --> 00:00:56,489
without which you know which provide our

00:00:54,780 --> 00:00:58,949
complete and expressive interface and

00:00:56,489 --> 00:01:01,350
then we have a further set of extended

00:00:58,949 --> 00:01:03,510
functions to provide a richer API for

00:01:01,350 --> 00:01:07,290
the sake of X versatility or performance

00:01:03,510 --> 00:01:08,640
it's fairly common so then the

00:01:07,290 --> 00:01:10,229
implementation the idea is that the

00:01:08,640 --> 00:01:12,119
interface can supply fallback

00:01:10,229 --> 00:01:13,860
implementations of the Richer interface

00:01:12,119 --> 00:01:15,299
which can be imprinted in terms of the

00:01:13,860 --> 00:01:17,580
basis set because the basis set is

00:01:15,299 --> 00:01:18,990
complete but the implementation can

00:01:17,580 --> 00:01:20,700
supply richer functions add its own

00:01:18,990 --> 00:01:23,850
option for the sake of typically

00:01:20,700 --> 00:01:25,590
performance so let's see an example of

00:01:23,850 --> 00:01:27,630
this right so here's an auto completion

00:01:25,590 --> 00:01:29,310
engine and the basis functions for an

00:01:27,630 --> 00:01:32,130
auto completion engine would be add a

00:01:29,310 --> 00:01:35,310
word to your corpus and find the list of

00:01:32,130 --> 00:01:36,689
candidates for a given prefix and then

00:01:35,310 --> 00:01:38,369
in the extended set we might want to

00:01:36,689 --> 00:01:39,659
also provide functions to say add a

00:01:38,369 --> 00:01:41,490
bunch of words because it might be a

00:01:39,659 --> 00:01:44,579
faster to add a bunch of words at one

00:01:41,490 --> 00:01:45,450
time and complete as far as is

00:01:44,579 --> 00:01:47,520
unambiguous

00:01:45,450 --> 00:01:49,380
so if if all the words for all my

00:01:47,520 --> 00:01:51,780
candidate completions start with the

00:01:49,380 --> 00:01:55,229
same prefix I can complete as far as

00:01:51,780 --> 00:01:57,329
that prefix goes and you can imagine

00:01:55,229 --> 00:01:59,159
that we can implement the engine of this

00:01:57,329 --> 00:02:01,619
in a few ways we could just have a

00:01:59,159 --> 00:02:03,149
sorted vector of strings type engine or

00:02:01,619 --> 00:02:04,200
we could have a more complex tree-based

00:02:03,149 --> 00:02:06,060
thing if we had a lot of other

00:02:04,200 --> 00:02:09,450
completions is that these are common

00:02:06,060 --> 00:02:12,030
scenarios and so the vector

00:02:09,450 --> 00:02:13,830
implementation probably wouldn't would

00:02:12,030 --> 00:02:16,470
just use the fallback

00:02:13,830 --> 00:02:18,290
for the complete function but it would

00:02:16,470 --> 00:02:20,550
you know have would override AdWords

00:02:18,290 --> 00:02:22,560
because it's it would only have to sort

00:02:20,550 --> 00:02:23,850
once whereas the tree based

00:02:22,560 --> 00:02:26,310
implementation could well provide a

00:02:23,850 --> 00:02:28,830
complete function just resulting from

00:02:26,310 --> 00:02:31,410
walking a few nodes of the tree anyway

00:02:28,830 --> 00:02:35,010
so that's our that's our interface and

00:02:31,410 --> 00:02:35,790
that's the that's the template then

00:02:35,010 --> 00:02:37,620
we're going to use this little

00:02:35,790 --> 00:02:41,610
expressions via a pattern so this is the

00:02:37,620 --> 00:02:42,420
void T detection idiom as popularized in

00:02:41,610 --> 00:02:45,810
a couple of talks

00:02:42,420 --> 00:02:47,970
so if basically you can see we're doing

00:02:45,810 --> 00:02:49,830
spin a detect and we're giving it a name

00:02:47,970 --> 00:02:51,210
so and then we're giving it the

00:02:49,830 --> 00:02:53,670
expression which gets put into the

00:02:51,210 --> 00:02:57,240
deckle type on line three of the toe of

00:02:53,670 --> 00:03:01,170
the macro there and the upshot is that

00:02:57,240 --> 00:03:03,060
if our engine provides the if this is a

00:03:01,170 --> 00:03:04,920
valid expression to call on our engine

00:03:03,060 --> 00:03:06,270
then we end up deriving a thing from

00:03:04,920 --> 00:03:08,700
true type otherwise you end up deriving

00:03:06,270 --> 00:03:11,130
from false type well now that we have

00:03:08,700 --> 00:03:13,040
this all that we need to do in our

00:03:11,130 --> 00:03:15,540
function bodies in our interface is

00:03:13,040 --> 00:03:20,220
overload for true type and false type

00:03:15,540 --> 00:03:21,390
and pass it the the macro or the the the

00:03:20,220 --> 00:03:24,390
thing that was derived from either true

00:03:21,390 --> 00:03:28,890
type of false type by the macro so our

00:03:24,390 --> 00:03:30,780
engine is our engine is the argument

00:03:28,890 --> 00:03:32,760
that was passed in we say does it have

00:03:30,780 --> 00:03:34,050
complete if it does we call the true

00:03:32,760 --> 00:03:35,820
type and that just calls through to the

00:03:34,050 --> 00:03:38,250
engines version otherwise we have our

00:03:35,820 --> 00:03:43,410
full back code and this this all in

00:03:38,250 --> 00:03:45,269
lines as you'd expect and that's really

00:03:43,410 --> 00:03:48,870
the whole thing that's that's a very

00:03:45,269 --> 00:03:49,980
easy pattern to apply so you allows you

00:03:48,870 --> 00:03:51,840
to decouple your interface and

00:03:49,980 --> 00:03:54,269
implementation everything is defined

00:03:51,840 --> 00:03:55,830
statically you don't get a V table but

00:03:54,269 --> 00:03:57,450
you get the same kind of separation of

00:03:55,830 --> 00:03:59,370
concerns that you get with with

00:03:57,450 --> 00:04:01,410
interface and implementation pattern and

00:03:59,370 --> 00:04:02,730
everything in lies as you can see when

00:04:01,410 --> 00:04:05,690
it provided by the engine it's just a

00:04:02,730 --> 00:04:07,950
one-line function so it just works and

00:04:05,690 --> 00:04:09,690
because the interface is a template you

00:04:07,950 --> 00:04:14,190
don't even get things that you don't use

00:04:09,690 --> 00:04:18,330
instantiated so no wastage you can find

00:04:14,190 --> 00:04:21,829
the my kind of proof of concept online

00:04:18,330 --> 00:04:23,889
at my github thanks very much

00:04:21,829 --> 00:04:23,889

YouTube URL: https://www.youtube.com/watch?v=8jbt-5Qub9E


