Title: CppCon 2016: Roland Bock “Variants of variadic AND"
Publication date: 2016-10-07
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:02,179 --> 00:00:08,849
should turn out right all right um so

00:00:06,029 --> 00:00:12,179
this is the task I want to have a

00:00:08,849 --> 00:00:15,120
template struct that takes any number of

00:00:12,179 --> 00:00:17,609
bool arguments and should have a value

00:00:15,120 --> 00:00:20,460
and the value should be true if all the

00:00:17,609 --> 00:00:22,740
arguments are true so and i'm going to

00:00:20,460 --> 00:00:25,800
show several variants of trying to do

00:00:22,740 --> 00:00:28,470
that right so if you have an

00:00:25,800 --> 00:00:30,330
introduction to two very diff templates

00:00:28,470 --> 00:00:32,700
the first thing you hear is okay use

00:00:30,330 --> 00:00:34,500
recursion and that's what we met too so

00:00:32,700 --> 00:00:35,760
we start with no arguments if there is

00:00:34,500 --> 00:00:38,460
no arguments then it should be true

00:00:35,760 --> 00:00:40,620
otherwise we do recursion and if that is

00:00:38,460 --> 00:00:42,570
too fast for you oh forget it recursion

00:00:40,620 --> 00:00:44,969
is something that you something that you

00:00:42,570 --> 00:00:47,460
shouldn't do okay just for completeness

00:00:44,969 --> 00:00:50,070
there's another constant there's another

00:00:47,460 --> 00:00:52,710
recursive version context or functions

00:00:50,070 --> 00:00:54,989
also starts with no arguments returns

00:00:52,710 --> 00:00:57,239
true if you have at least one argument

00:00:54,989 --> 00:01:00,120
then you compare the first argument with

00:00:57,239 --> 00:01:02,789
a wrist and put everything into go

00:01:00,120 --> 00:01:04,559
constant um then you're done okay so now

00:01:02,789 --> 00:01:08,640
we guarantee chemist to something

00:01:04,559 --> 00:01:10,439
interesting using know except Lloyd

00:01:08,640 --> 00:01:12,659
stepped is a nice keyword or you can use

00:01:10,439 --> 00:01:14,460
it to declare something to be no

00:01:12,659 --> 00:01:18,090
accepting you can also use it to query

00:01:14,460 --> 00:01:21,619
if something is no except we start with

00:01:18,090 --> 00:01:24,090
a helper annex helper um that is

00:01:21,619 --> 00:01:25,409
declared to be no except when it comes

00:01:24,090 --> 00:01:28,799
right to strictly have to be no except

00:01:25,409 --> 00:01:32,460
if the full argument is true then we use

00:01:28,799 --> 00:01:35,820
a function annex join that is always

00:01:32,460 --> 00:01:38,220
know except and takes any number of

00:01:35,820 --> 00:01:42,030
arguments and then we say okay dear

00:01:38,220 --> 00:01:44,549
compiler um if we take all our arguments

00:01:42,030 --> 00:01:48,000
and construct no except helpers from

00:01:44,549 --> 00:01:50,579
those and put everything as arguments to

00:01:48,000 --> 00:01:52,619
annex join it's the whole thing notice

00:01:50,579 --> 00:01:54,780
no except yes or no and the compiler

00:01:52,619 --> 00:01:56,610
will say well if everything is true then

00:01:54,780 --> 00:01:58,079
all the annex help of constructors are

00:01:56,610 --> 00:02:01,150
now except and then the whole thing is

00:01:58,079 --> 00:02:04,270
no except otherwise is false okay

00:02:01,150 --> 00:02:09,190
right don't do that you will scare other

00:02:04,270 --> 00:02:11,950
people okay enough for something real

00:02:09,190 --> 00:02:16,210
you can use stood the same for this we

00:02:11,950 --> 00:02:17,980
are again can declare a helper the

00:02:16,210 --> 00:02:19,570
health takes any number of goals and the

00:02:17,980 --> 00:02:22,720
implementation doesn't matter you don't

00:02:19,570 --> 00:02:26,290
even need it and then you take your list

00:02:22,720 --> 00:02:29,200
of arguments and you first prepend but

00:02:26,290 --> 00:02:32,590
true put it in as arguments to all

00:02:29,200 --> 00:02:34,980
helper and then you append true to our

00:02:32,590 --> 00:02:37,360
your arguments and if those two

00:02:34,980 --> 00:02:41,230
specializations of our helper are the

00:02:37,360 --> 00:02:43,540
same that means that all the arguments

00:02:41,230 --> 00:02:48,250
are true needs a few seconds to sink in

00:02:43,540 --> 00:02:51,750
but yes that's right okay there are very

00:02:48,250 --> 00:02:54,010
ends of this um well in C++ 17

00:02:51,750 --> 00:02:56,230
everything gets nicer and easier because

00:02:54,010 --> 00:02:58,990
we will have fold expressions with fold

00:02:56,230 --> 00:03:01,090
expressions you can just express exactly

00:02:58,990 --> 00:03:04,180
what we want we want to combine all our

00:03:01,090 --> 00:03:06,519
arguments with end and if the result is

00:03:04,180 --> 00:03:08,560
true then that's the result that we want

00:03:06,519 --> 00:03:13,300
to have okay so that's very expressive

00:03:08,560 --> 00:03:17,290
now I've shown five variants of very big

00:03:13,300 --> 00:03:19,780
and um what's the point that I mean yes

00:03:17,290 --> 00:03:23,709
all these versions on a stupid and there

00:03:19,780 --> 00:03:27,370
are even more the point is well

00:03:23,709 --> 00:03:29,350
readability and performance right there

00:03:27,370 --> 00:03:30,670
readability is something that you have

00:03:29,350 --> 00:03:32,080
to make up on your own mind on

00:03:30,670 --> 00:03:33,670
performance is something that you should

00:03:32,080 --> 00:03:36,400
measure you should not make assumptions

00:03:33,670 --> 00:03:38,760
but if you measure it and I measured it

00:03:36,400 --> 00:03:38,760
this way

00:03:40,060 --> 00:03:46,520
within within the limits of my of my

00:03:44,090 --> 00:03:48,590
measurement techniques basically for no

00:03:46,520 --> 00:03:53,110
effort for one argument they all are

00:03:48,590 --> 00:03:55,940
instant or if you go to higher numbers

00:03:53,110 --> 00:03:57,620
then you will see that Oh recursion that

00:03:55,940 --> 00:04:00,920
is actually pretty slow compared to

00:03:57,620 --> 00:04:03,020
everything else if you go it to really

00:04:00,920 --> 00:04:07,520
high numbers then you will see the XX x

00:04:03,020 --> 00:04:11,180
marks crashes and the compiler so the

00:04:07,520 --> 00:04:14,000
first approach already crashes the

00:04:11,180 --> 00:04:17,630
compiler then you go to and you see

00:04:14,000 --> 00:04:20,840
which version is really slow then even

00:04:17,630 --> 00:04:23,510
higher more precious yet higher okay and

00:04:20,840 --> 00:04:26,120
I didn't go beyond that so no except

00:04:23,510 --> 00:04:29,360
also crashes and you see that by now on

00:04:26,120 --> 00:04:32,270
the the fold expressions are about a

00:04:29,360 --> 00:04:39,200
factor of two thousand slower than the

00:04:32,270 --> 00:04:41,570
is same um that is a surprise and I

00:04:39,200 --> 00:04:44,870
didn't I didn't realize that or I didn't

00:04:41,570 --> 00:04:47,720
expect that but it's a new feature so

00:04:44,870 --> 00:04:54,500
maybe compiler vendors will will catch

00:04:47,720 --> 00:04:57,010
up with that now the morel is first with

00:04:54,500 --> 00:05:00,470
Mary any templates avoid recursion is

00:04:57,010 --> 00:05:02,780
evil the other thing is strive for

00:05:00,470 --> 00:05:05,419
readability and performance if you have

00:05:02,780 --> 00:05:06,740
to choose I'm always going with

00:05:05,419 --> 00:05:10,190
readability because I have to maintain

00:05:06,740 --> 00:05:12,460
the code on but that's my choice thank

00:05:10,190 --> 00:05:12,460

YouTube URL: https://www.youtube.com/watch?v=VNrShPCgVjw


