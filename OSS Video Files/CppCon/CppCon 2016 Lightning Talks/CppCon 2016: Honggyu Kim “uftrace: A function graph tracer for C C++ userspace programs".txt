Title: CppCon 2016: Honggyu Kim “uftrace: A function graph tracer for C C++ userspace programs"
Publication date: 2016-10-08
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,340 --> 00:00:03,060
Hi, I'm Honggyu Kim from LG Electronics.

00:00:03,060 --> 00:00:10,220
I'm going to introduce about a new function tracing tool which is called uftrace.

00:00:11,600 --> 00:00:16,080
uftrace is newly open-sourced and you can download it from github.

00:00:17,280 --> 00:00:20,320
Let's see. There is a function main.

00:00:20,320 --> 00:00:22,760
And main function calls foo.

00:00:22,760 --> 00:00:24,800
And foo calls bar.

00:00:24,800 --> 00:00:28,220
If you compile it, we get this kind of binary.

00:00:29,620 --> 00:00:32,680
If you recompile this program with -pg option.

00:00:32,680 --> 00:00:37,080
It inserts all the mcount function calls at the entry of each function.

00:00:38,820 --> 00:00:44,340
If we execute it with uftrace record, we can record all the trace.

00:00:44,340 --> 00:00:46,580
And then we can replay it.

00:00:46,740 --> 00:00:48,300
And you can see the result.

00:00:48,300 --> 00:00:50,640
And also you don't have to record it.

00:00:50,640 --> 00:00:52,940
You can just use the live command.

00:00:53,100 --> 00:00:54,940
You can just omit it.

00:00:57,640 --> 00:01:01,720
The right block explains about the call chain.

00:01:01,960 --> 00:01:06,420
main function calls foo, foo function calls bar and bar just returns.

00:01:07,500 --> 00:01:08,940
And this is thread ID.

00:01:09,320 --> 00:01:11,400
And this is function duration.

00:01:11,660 --> 00:01:15,420
For example, foo function executed this amount of time.

00:01:15,420 --> 00:01:17,820
This is timestamp based, not sampling based.

00:01:17,820 --> 00:01:25,800
So it provides various filters, but the most important thing is time filter.

00:01:25,800 --> 00:01:36,500
Let's say if I put -t 200 nano seconds, it removes all the function calls that are under the 200 nano seconds.

00:01:37,120 --> 00:01:41,000
It's very good when you watch the big picture only.

00:01:41,120 --> 00:01:44,080
Because there are too many small functions.

00:01:44,740 --> 00:01:46,420
So it is removed.

00:01:49,940 --> 00:01:53,820
Once the trace is recorded, you can see the report.

00:01:54,180 --> 00:01:55,520
This is the summary.

00:01:55,520 --> 00:01:58,760
It shows the total time, self time, and the number of calls.

00:02:01,000 --> 00:02:04,280
Let's say there is a fibonacci example, which is written in a recursive way.

00:02:05,400 --> 00:02:09,000
If we execute it, then it shows the result.

00:02:09,360 --> 00:02:12,300
uftrace shows this output.

00:02:12,300 --> 00:02:16,380
The main function calls fibonacci functions recursively.

00:02:16,800 --> 00:02:20,480
If you want to see the arguments, you can put this option.

00:02:21,060 --> 00:02:23,700
It shows fibonacci 5 calls fibonacci 4.

00:02:23,980 --> 00:02:26,020
And it goes on and on and on.

00:02:26,140 --> 00:02:28,860
You can also see the return value as well.

00:02:30,080 --> 00:02:34,500
It means fibonacci 2 returns 1, and fibonacci 1 returns 1.

00:02:34,720 --> 00:02:37,920
As a result, fibonacci 5 returns 5.

00:02:42,060 --> 00:02:44,960
Once you record it, you can also dump it.

00:02:44,960 --> 00:02:50,640
But if you put --chrome option, you can dump it as json format.

00:02:51,680 --> 00:02:55,040
This json format can be dumped into a file.

00:02:55,040 --> 00:02:59,960
This file can be opened in a chrome browser without any other installation.

00:03:01,100 --> 00:03:03,580
You can just go to chrome://tracing.

00:03:04,160 --> 00:03:07,200
And then you can open it, then it shows the result.

00:03:08,020 --> 00:03:12,080
This is timeline and it goes to the call-depth.

00:03:14,180 --> 00:03:17,480
You can also trace STL as well.

00:03:17,760 --> 00:03:19,960
There is an example shared_ptr.

00:03:20,020 --> 00:03:22,580
It allocates only one single integer.

00:03:22,780 --> 00:03:30,040
In the block, the allocated integer is shared with another shared_ptr.

00:03:31,020 --> 00:03:33,900
We can recompile it and then we execute it.

00:03:34,980 --> 00:03:37,460
And then we can provide more filters.

00:03:37,460 --> 00:03:39,340
You can see this kind of result.

00:03:39,900 --> 00:03:41,740
This is the internal of STL.

00:03:41,740 --> 00:03:44,040
The first block just allocates it.

00:03:44,080 --> 00:03:47,520
The second block just add a reference counter only.

00:03:47,660 --> 00:03:51,420
The third block just decrements the reference counter.

00:03:51,420 --> 00:03:53,780
And then the last block just deallocates it.

00:03:55,420 --> 00:03:59,180
You can also analyze clang compiler itself internally.

00:03:59,600 --> 00:04:01,680
Those are all clang functions.

00:04:04,400 --> 00:04:06,080
You can see the parse AST.

00:04:06,080 --> 00:04:08,840
Backend code generation and this kind of things.

00:04:10,520 --> 00:04:12,280
I put the time filter here.

00:04:12,280 --> 00:04:16,220
If you decrease the time filter, you will see more result.

00:04:18,100 --> 00:04:19,860
There is another example.

00:04:19,860 --> 00:04:23,600
Fibonacci example can be written in a template meta-programming way.

00:04:24,080 --> 00:04:25,680
You can just compile it.

00:04:27,180 --> 00:04:29,740
There is a lot of recursive expansion.

00:04:33,240 --> 00:04:34,840
I can show you demo here.

00:04:38,000 --> 00:04:40,240
This is opened in chrome browser.

00:04:40,780 --> 00:04:42,560
You can see here.

00:04:43,260 --> 00:04:45,420
It shows a lot of function calls.

00:04:45,700 --> 00:04:48,020
If you go here, then you can search.

00:04:49,660 --> 00:04:51,500
If you find something here.

00:04:52,760 --> 00:04:56,880
There is a really really deep call depth here actually.

00:04:56,980 --> 00:05:01,580
If you just zoom in, you can find a log of repeated patterns.

00:05:01,900 --> 00:05:04,260
If you search "special"

00:05:17,340 --> 00:05:21,500
You can see the repeated pattern here. It shows template specialization.

00:05:21,820 --> 00:05:24,180
Another example is V8 JavaScript engine.

00:05:24,540 --> 00:05:26,600
You can see the shape of JavaScript engine.

00:05:27,960 --> 00:05:29,380
You can magnify it.

00:05:29,380 --> 00:05:35,520
You can see a lot of background threads are executed to optimize some JavaScript function calls.

00:05:36,400 --> 00:05:39,760
The console output looks just like that.

00:05:40,360 --> 00:05:44,760
You can just run uftrace -t 100ms.

00:05:45,000 --> 00:05:48,120
This is the entire execution function calls of clang.

00:05:48,880 --> 00:05:53,640
If you see the entire, this is too much actually.

00:05:54,400 --> 00:05:56,640
You don't want to see everything.

00:05:58,620 --> 00:06:00,540

YouTube URL: https://www.youtube.com/watch?v=LNav5qvyK7I


