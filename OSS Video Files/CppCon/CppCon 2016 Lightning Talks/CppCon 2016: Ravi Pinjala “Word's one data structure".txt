Title: CppCon 2016: Ravi Pinjala “Word's one data structure"
Publication date: 2016-10-08
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:03,899
hi I'm Ravi pan jela I manager on the

00:00:02,310 --> 00:00:10,740
word team and today I'm going to tell

00:00:03,899 --> 00:00:16,800
you about words only data structure may

00:00:10,740 --> 00:00:17,640
be there we go okay so let's talk about

00:00:16,800 --> 00:00:20,760
the poem that we're trying to solve

00:00:17,640 --> 00:00:22,859
right here we want to take arbitrary

00:00:20,760 --> 00:00:24,779
objects we want them to attack we want

00:00:22,859 --> 00:00:27,810
to attach them to a stream of texts and

00:00:24,779 --> 00:00:29,730
objects could be images pictures

00:00:27,810 --> 00:00:31,349
comments basically anything you could

00:00:29,730 --> 00:00:34,170
think of that you might want to attach

00:00:31,349 --> 00:00:35,880
to a document it turns out that you can

00:00:34,170 --> 00:00:37,710
implement just about any feature in a

00:00:35,880 --> 00:00:40,649
word processor by sticking objects to

00:00:37,710 --> 00:00:42,030
text and having them stay there and we

00:00:40,649 --> 00:00:44,100
want the objects to move around with

00:00:42,030 --> 00:00:45,480
text so like if I'm typing that I want

00:00:44,100 --> 00:00:47,850
everything else later in the document to

00:00:45,480 --> 00:00:52,440
actually move along with me and not

00:00:47,850 --> 00:00:55,100
shift around and so let's try to build a

00:00:52,440 --> 00:00:57,120
data structure that actually does this

00:00:55,100 --> 00:01:01,680
so we'll start with something that looks

00:00:57,120 --> 00:01:04,530
like this warning for the faint of heart

00:01:01,680 --> 00:01:06,420
this is going to have a lot of C code in

00:01:04,530 --> 00:01:08,970
it it turns out the use of this data

00:01:06,420 --> 00:01:12,049
structure actually predates C++ by quite

00:01:08,970 --> 00:01:15,479
a bit so I'm showing this as it exists

00:01:12,049 --> 00:01:18,900
so we have basically a mapping of

00:01:15,479 --> 00:01:20,400
positions to arbitrary objects in the

00:01:18,900 --> 00:01:22,860
way you would do it and see there's a

00:01:20,400 --> 00:01:24,119
size there's capacity there's an element

00:01:22,860 --> 00:01:27,200
size then it's just raw pointers

00:01:24,119 --> 00:01:29,549
everywhere don't worry about that if

00:01:27,200 --> 00:01:33,030
you'd like you can just think of this as

00:01:29,549 --> 00:01:35,610
sort of a flat map positions is going to

00:01:33,030 --> 00:01:38,340
be a sorted array of character positions

00:01:35,610 --> 00:01:41,670
in the document data is going to be an

00:01:38,340 --> 00:01:43,439
array of objects that align with those

00:01:41,670 --> 00:01:45,060
positions so like the first element in

00:01:43,439 --> 00:01:46,950
the positions ray matches the first

00:01:45,060 --> 00:01:49,350
element of the data array and then

00:01:46,950 --> 00:01:51,299
element size is just the number of bytes

00:01:49,350 --> 00:01:58,619
to copy instead of using a template here

00:01:51,299 --> 00:02:00,930
like I said C so let's so how do we

00:01:58,619 --> 00:02:04,020
update this when we actually add text

00:02:00,930 --> 00:02:06,119
the document we could go through the

00:02:04,020 --> 00:02:08,280
array of positions and just increment

00:02:06,119 --> 00:02:12,870
all of those that's order n that's lame

00:02:08,280 --> 00:02:13,860
we don't want to do that boo so instead

00:02:12,870 --> 00:02:17,070
let's just keep trying

00:02:13,860 --> 00:02:18,540
of where the last update was and how big

00:02:17,070 --> 00:02:21,330
that update was and just sort of work

00:02:18,540 --> 00:02:23,490
around it so here we just keep track of

00:02:21,330 --> 00:02:25,620
the index of the last adjustment that we

00:02:23,490 --> 00:02:27,360
made and the distance that we adjusted

00:02:25,620 --> 00:02:33,150
things or that we would have adjusted

00:02:27,360 --> 00:02:35,430
things basically we're treating every

00:02:33,150 --> 00:02:37,470
position after a just pause as though it

00:02:35,430 --> 00:02:38,730
had a just sighs added to it even though

00:02:37,470 --> 00:02:41,820
we're not actually going to rewriting

00:02:38,730 --> 00:02:43,200
the data structure let's also add this

00:02:41,820 --> 00:02:47,400
search ain't here don't worry about what

00:02:43,200 --> 00:02:48,840
that does I'll explain it later so when

00:02:47,400 --> 00:02:52,200
the document is changed we record the

00:02:48,840 --> 00:02:53,520
adjustment let's say that we had a table

00:02:52,200 --> 00:02:56,220
that looked like this with these

00:02:53,520 --> 00:02:58,230
arbitrary objects attached to them and

00:02:56,220 --> 00:03:01,530
we make this adjustment here so that

00:02:58,230 --> 00:03:04,080
we're adding eight characters after the

00:03:01,530 --> 00:03:06,270
second position in this array and you'll

00:03:04,080 --> 00:03:08,400
notice that the real positions recorded

00:03:06,270 --> 00:03:15,780
changed but the virtual ones that were

00:03:08,400 --> 00:03:18,420
hanging on to are actually updated so

00:03:15,780 --> 00:03:20,299
wait a second this works but what

00:03:18,420 --> 00:03:22,400
happens we want to make a second change

00:03:20,299 --> 00:03:24,090
do we have to go through and actually

00:03:22,400 --> 00:03:26,190
update all the things for the last

00:03:24,090 --> 00:03:28,760
judgment before we can record it no we

00:03:26,190 --> 00:03:30,720
do not so this is kind of the clever bit

00:03:28,760 --> 00:03:33,150
you start out with something that looks

00:03:30,720 --> 00:03:34,440
like this and you want to make another

00:03:33,150 --> 00:03:36,420
change to the document let's say that

00:03:34,440 --> 00:03:39,780
you're adding four characters at

00:03:36,420 --> 00:03:42,810
position 15 in the document so what we

00:03:39,780 --> 00:03:45,540
can do is we can actually just move the

00:03:42,810 --> 00:03:46,850
adjustment point around and sort of

00:03:45,540 --> 00:03:48,810
fiddle with all the positions between

00:03:46,850 --> 00:03:50,640
where we were before and where we are

00:03:48,810 --> 00:03:52,950
now rather than having to actually touch

00:03:50,640 --> 00:03:55,170
every item in the array so you'll see

00:03:52,950 --> 00:03:58,400
that in this case we only needed to

00:03:55,170 --> 00:04:03,660
actually update the value of one element

00:03:58,400 --> 00:04:04,980
and now in the new one the position of

00:04:03,660 --> 00:04:06,630
the adjustment is one the size the

00:04:04,980 --> 00:04:08,910
position the size of the adjustment is

00:04:06,630 --> 00:04:13,019
increased and the whole thing's still

00:04:08,910 --> 00:04:16,500
consistent so in general with a scheme

00:04:13,019 --> 00:04:18,419
like this adjustment is order of the

00:04:16,500 --> 00:04:21,049
distance from the last edit inefficiency

00:04:18,419 --> 00:04:23,700
and lookups our order log n because it's

00:04:21,049 --> 00:04:25,110
a sorted array or technically it's two

00:04:23,700 --> 00:04:26,770
sorted arrays stuck together so you can

00:04:25,110 --> 00:04:29,500
find a research both of them

00:04:26,770 --> 00:04:31,389
but it turns out that in a word

00:04:29,500 --> 00:04:33,970
processor most edits actually happen

00:04:31,389 --> 00:04:35,349
pretty close together and especially

00:04:33,970 --> 00:04:36,430
while you're typing and it's happened

00:04:35,349 --> 00:04:38,319
really close together and it turns out

00:04:36,430 --> 00:04:42,370
that people really care about the

00:04:38,319 --> 00:04:44,830
performance of typing so while you're

00:04:42,370 --> 00:04:47,530
typing adjustment doesn't change any

00:04:44,830 --> 00:04:49,090
positions it only bumps the size and we

00:04:47,530 --> 00:04:50,050
cash the result of the last binary

00:04:49,090 --> 00:04:52,509
search in that search hint that i

00:04:50,050 --> 00:04:53,860
mentioned earlier and so we check that

00:04:52,509 --> 00:04:55,889
first when researching that's always

00:04:53,860 --> 00:04:57,580
up-to-date while you're typing and so

00:04:55,889 --> 00:04:59,530
everything that happens while you're

00:04:57,580 --> 00:05:04,210
typing with this data structure it

00:04:59,530 --> 00:05:05,590
happens in constant time so in word it's

00:05:04,210 --> 00:05:06,880
actually not called that I think I'm

00:05:05,590 --> 00:05:09,550
getting kicked off the stage so I'll

00:05:06,880 --> 00:05:12,009
just breeze right through this slide and

00:05:09,550 --> 00:05:13,419
say that you can actually implement just

00:05:12,009 --> 00:05:14,830
about everything in word of this which

00:05:13,419 --> 00:05:16,150
is why we sometimes say that it's words

00:05:14,830 --> 00:05:18,159
only data structure because just about

00:05:16,150 --> 00:05:19,690
everything's based on it so in

00:05:18,159 --> 00:05:21,669
conclusion standards data structures are

00:05:19,690 --> 00:05:22,930
pretty cool but sometimes with the

00:05:21,669 --> 00:05:26,400
domain specific data structure you can

00:05:22,930 --> 00:05:26,400

YouTube URL: https://www.youtube.com/watch?v=8OjSDaaySDA


