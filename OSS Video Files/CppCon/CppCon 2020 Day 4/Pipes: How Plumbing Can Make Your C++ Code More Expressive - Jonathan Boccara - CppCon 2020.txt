Title: Pipes: How Plumbing Can Make Your C++ Code More Expressive - Jonathan Boccara - CppCon 2020
Publication date: 2020-10-03
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/pipes_how_plumbing_can_make_your_cpp_code_more_expressive/pipes_how_plumbing_can_make_your_cpp_code_more_expressive__jonathan_boccara__cppcon_2020.pdf
---
In code we work with collections of objects all the time, yet it's not always easy to operate on them with concise and expressive code.

Traversing collections with for loops gets ugly and brittle as soon as they have more than a few lines.
STL algorithms are a big step further, but they don't compose well (ever had the need for a "transform_if" algorithm?)
Ranges are another big step further, but like every library they don't cover all cases (Did you know about the transform-filter performance problem? Or that you're not allowed to use rvalues as inputs? Or that you have to use tuples when working on several collections?)

In this talk you will discover pipes, another way to write expressive code to operate with collections: write your code as plumbing through which your data flows.

Like every library pipes also have their limitations, which we will present, but using them as a complement of ranges and STL algorithms will bring you the following benefits:
- An efficient transform-filter
- zip two collections without using tuples
- send data to several outputs
- use rvalues as inputs and as intermediate results
- pick up the data coming out of STL algorithms
- integrate results in destination containers
- pipes are very easy to implement, so you can add new ones

Come see how pipes can improve your code!

---
Jonathan Boccara is a Principal Engineering Lead at Murex where he works on large codebases in C++.
His primary focus is searching how to make code more expressive. He has dedicated his blog, Fluent C++, to writing expressive code in C++.
He also gives internal trainings on C++ every day, in the short format called "Dailies".

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,719 --> 00:00:14,639
hello

00:00:12,719 --> 00:00:16,960
today we're going to talk about working

00:00:14,639 --> 00:00:19,760
with collections in c plus plus

00:00:16,960 --> 00:00:22,800
in particular with plumbing and the

00:00:19,760 --> 00:00:25,760
pipes library

00:00:22,800 --> 00:00:26,800
so understand the big picture of working

00:00:25,760 --> 00:00:30,960
with collections in c

00:00:26,800 --> 00:00:34,399
plus plus um about how that whole world

00:00:30,960 --> 00:00:36,079
works um let's let's go back let's go

00:00:34,399 --> 00:00:38,640
back a long way

00:00:36,079 --> 00:00:41,440
to the beginning of time at the

00:00:38,640 --> 00:00:45,840
beginning of time

00:00:41,440 --> 00:00:45,840
there was nothing

00:00:48,559 --> 00:00:54,160
and then there was four

00:00:51,680 --> 00:00:55,120
that helped us programmers work with

00:00:54,160 --> 00:00:58,719
collections

00:00:55,120 --> 00:01:01,840
in in various languages including c plus

00:00:58,719 --> 00:01:04,879
and c and other languages as well

00:01:01,840 --> 00:01:07,200
and that was an error that was before

00:01:04,879 --> 00:01:08,159
we realized that sdl algorithms were

00:01:07,200 --> 00:01:12,000
around

00:01:08,159 --> 00:01:13,200
and were quite useful things to use so

00:01:12,000 --> 00:01:16,799
then we moved

00:01:13,200 --> 00:01:18,000
i mean as a like community um to the sd

00:01:16,799 --> 00:01:20,640
algorithms

00:01:18,000 --> 00:01:21,759
and that was a an improvement over the

00:01:20,640 --> 00:01:25,200
four loops

00:01:21,759 --> 00:01:28,479
as most people are aware of now

00:01:25,200 --> 00:01:30,159
um and and then yeah we come to that

00:01:28,479 --> 00:01:33,360
realization

00:01:30,159 --> 00:01:35,920
and then now we

00:01:33,360 --> 00:01:36,479
are collectively collectively moving

00:01:35,920 --> 00:01:39,840
into

00:01:36,479 --> 00:01:40,640
modern c gospels and the logical next

00:01:39,840 --> 00:01:43,759
step

00:01:40,640 --> 00:01:46,720
in c plus plus after s algorithms

00:01:43,759 --> 00:01:48,000
is fringes right the popular ranges that

00:01:46,720 --> 00:01:50,240
we

00:01:48,000 --> 00:01:51,759
hear a lot about and that is a great

00:01:50,240 --> 00:01:55,040
great addition to

00:01:51,759 --> 00:01:55,759
the standard c glass bus let's zoom in a

00:01:55,040 --> 00:01:58,960
little

00:01:55,759 --> 00:02:03,439
on the transition between st algorithms

00:01:58,960 --> 00:02:05,520
and ranges to

00:02:03,439 --> 00:02:07,040
let's let's take a very simple use case

00:02:05,520 --> 00:02:09,840
for sd algorithms

00:02:07,040 --> 00:02:11,599
which consists in applying a function in

00:02:09,840 --> 00:02:13,840
every element in the collection

00:02:11,599 --> 00:02:14,720
so we've got a collection of numbers 1

00:02:13,840 --> 00:02:17,840
to 10

00:02:14,720 --> 00:02:18,640
and we'd like to apply a lambda function

00:02:17,840 --> 00:02:20,800
here that

00:02:18,640 --> 00:02:22,800
multiplies the number by 2. we can do

00:02:20,800 --> 00:02:25,120
that with the transform

00:02:22,800 --> 00:02:26,959
now another basic use case of s

00:02:25,120 --> 00:02:30,239
algorithm is to filter

00:02:26,959 --> 00:02:33,680
based on a predicate and then we'd use

00:02:30,239 --> 00:02:35,360
copy f with a predicate like the one

00:02:33,680 --> 00:02:39,760
here

00:02:35,360 --> 00:02:42,239
now if we want to do both as in

00:02:39,760 --> 00:02:43,120
apply a function only on the element

00:02:42,239 --> 00:02:46,400
that satisfies

00:02:43,120 --> 00:02:47,440
predicate um then we need another

00:02:46,400 --> 00:02:48,800
algorithm

00:02:47,440 --> 00:02:50,879
something that would be called like

00:02:48,800 --> 00:02:53,599
transform if for example

00:02:50,879 --> 00:02:55,680
but the seo doesn't have any transform

00:02:53,599 --> 00:02:58,800
if algorithm

00:02:55,680 --> 00:03:01,200
so if we if we want to do the equivalent

00:02:58,800 --> 00:03:04,080
of transform f then we have to

00:03:01,200 --> 00:03:05,680
copy if and then transform which is a

00:03:04,080 --> 00:03:08,480
bit of a problem because uh

00:03:05,680 --> 00:03:10,560
it's a lot of code right and a lot of

00:03:08,480 --> 00:03:15,120
memories allocate and it's just

00:03:10,560 --> 00:03:17,360
not convenient with wrenches though

00:03:15,120 --> 00:03:18,560
um this is extremely convenient this is

00:03:17,360 --> 00:03:21,920
a great great

00:03:18,560 --> 00:03:25,760
illustration of using ranges i think um

00:03:21,920 --> 00:03:28,879
we've got inputs and we pipe them in

00:03:25,760 --> 00:03:32,080
into a a range adapter

00:03:28,879 --> 00:03:33,519
called filter and we pipe that in a

00:03:32,080 --> 00:03:34,159
transform adapter that applies a

00:03:33,519 --> 00:03:36,879
function

00:03:34,159 --> 00:03:37,440
right and this this does just what we

00:03:36,879 --> 00:03:39,440
expect

00:03:37,440 --> 00:03:40,959
as in apply the function only on the

00:03:39,440 --> 00:03:44,000
element that satisfies pretty good

00:03:40,959 --> 00:03:48,319
that looks great we can

00:03:44,000 --> 00:03:51,440
um put the adapters in any way we'd like

00:03:48,319 --> 00:03:53,280
and they would be applied in order which

00:03:51,440 --> 00:03:56,080
is great

00:03:53,280 --> 00:03:58,000
now um if we take a closer look at this

00:03:56,080 --> 00:04:00,159
expression

00:03:58,000 --> 00:04:01,120
if we take a closer look at what's

00:04:00,159 --> 00:04:04,480
happening

00:04:01,120 --> 00:04:07,840
inside of of this pipeline

00:04:04,480 --> 00:04:08,959
um for example by logging what's going

00:04:07,840 --> 00:04:12,560
through the transform

00:04:08,959 --> 00:04:12,560
pi the transform adapter

00:04:12,640 --> 00:04:15,760
we would expect all the numbers to be

00:04:15,200 --> 00:04:17,600
printed

00:04:15,760 --> 00:04:19,759
one two three four five six because we

00:04:17,600 --> 00:04:20,320
before the filter so everything's from

00:04:19,759 --> 00:04:23,360
inputs

00:04:20,320 --> 00:04:25,440
goes through transform

00:04:23,360 --> 00:04:27,680
so we're going to run this this little

00:04:25,440 --> 00:04:28,400
piece of code and see what gets printed

00:04:27,680 --> 00:04:31,120
out

00:04:28,400 --> 00:04:32,080
and we get this we do get one two three

00:04:31,120 --> 00:04:35,360
four five six

00:04:32,080 --> 00:04:39,040
which is expected except that we

00:04:35,360 --> 00:04:41,919
get three two times and six

00:04:39,040 --> 00:04:42,240
twice as well which is a bit surprising

00:04:41,919 --> 00:04:46,320
i

00:04:42,240 --> 00:04:49,199
think and um to be honest i don't think

00:04:46,320 --> 00:04:50,400
we it's it's we can guess what's

00:04:49,199 --> 00:04:52,000
happening i don't think we can guess

00:04:50,400 --> 00:04:52,960
what's happening just by looking at this

00:04:52,000 --> 00:04:54,880
code

00:04:52,960 --> 00:04:56,880
so it's it's been expected i think i

00:04:54,880 --> 00:04:58,720
mean i um certainly stumbled upon that

00:04:56,880 --> 00:05:01,919
while using ranges on a

00:04:58,720 --> 00:05:03,919
production use case um so to understand

00:05:01,919 --> 00:05:04,479
what that why that why that this is

00:05:03,919 --> 00:05:05,919
happening

00:05:04,479 --> 00:05:07,680
let's let's see what's happening under

00:05:05,919 --> 00:05:09,360
the cover

00:05:07,680 --> 00:05:11,199
under the covers so we've got inputs

00:05:09,360 --> 00:05:13,759
that go through transform which goes

00:05:11,199 --> 00:05:16,240
through full time

00:05:13,759 --> 00:05:18,479
when we write this when this statement

00:05:16,240 --> 00:05:22,880
gets executed

00:05:18,479 --> 00:05:26,000
filter gets constructed and to do that

00:05:22,880 --> 00:05:29,199
it rates all the way to the first

00:05:26,000 --> 00:05:32,479
element of the range on the range

00:05:29,199 --> 00:05:35,199
it adapts so input pipe transform

00:05:32,479 --> 00:05:36,560
in order to be ready to provide the

00:05:35,199 --> 00:05:37,440
first element that satisfies the

00:05:36,560 --> 00:05:39,199
predicate

00:05:37,440 --> 00:05:40,639
so to do that full-time calls the

00:05:39,199 --> 00:05:42,560
predicate

00:05:40,639 --> 00:05:44,000
on the element coming from transform

00:05:42,560 --> 00:05:47,840
which calls the function on

00:05:44,000 --> 00:05:51,199
one and in our case uh this

00:05:47,840 --> 00:05:52,160
um the outcome is false so it moves or

00:05:51,199 --> 00:05:55,199
it moves on

00:05:52,160 --> 00:05:56,240
one element and calls up the function on

00:05:55,199 --> 00:05:59,120
two

00:05:56,240 --> 00:06:00,639
and still still not um not pretty good

00:05:59,120 --> 00:06:02,880
the breaker is not satisfied

00:06:00,639 --> 00:06:04,160
and then moves on one more time and the

00:06:02,880 --> 00:06:06,880
predicate in

00:06:04,160 --> 00:06:07,919
the three it's satisfied so filter

00:06:06,880 --> 00:06:12,240
stuff's here

00:06:07,919 --> 00:06:15,680
and is ready to be iterated on

00:06:12,240 --> 00:06:18,880
now we start the actual iteration

00:06:15,680 --> 00:06:21,440
so we start by reading filter which

00:06:18,880 --> 00:06:22,960
calls transform which calls the function

00:06:21,440 --> 00:06:26,240
a second time which is why

00:06:22,960 --> 00:06:28,319
we see three twice and then

00:06:26,240 --> 00:06:30,319
filter goes to the next element that

00:06:28,319 --> 00:06:33,759
says predicate so it iterates

00:06:30,319 --> 00:06:36,800
over whatever comes out of transform

00:06:33,759 --> 00:06:37,680
and finally finds one which is six and

00:06:36,800 --> 00:06:40,000
then

00:06:37,680 --> 00:06:42,080
it gives access to this value with the

00:06:40,000 --> 00:06:45,360
second call to f

00:06:42,080 --> 00:06:49,039
so this is this is what we see in the um

00:06:45,360 --> 00:06:52,160
in the outputs

00:06:49,039 --> 00:06:53,520
now um this

00:06:52,160 --> 00:06:55,759
i mean most of the time i don't think

00:06:53,520 --> 00:06:59,120
it's it's a problem you can

00:06:55,759 --> 00:06:59,759
uh observe uh from the action point of

00:06:59,120 --> 00:07:02,400
view

00:06:59,759 --> 00:07:03,759
i've i've just observed it a few times

00:07:02,400 --> 00:07:05,840
um

00:07:03,759 --> 00:07:06,960
in in so in some cases it can be a

00:07:05,840 --> 00:07:09,039
problem if f

00:07:06,960 --> 00:07:10,639
takes a long time to execute or if it

00:07:09,039 --> 00:07:13,360
has side effects then

00:07:10,639 --> 00:07:13,680
uh maybe you don't want to have to you

00:07:13,360 --> 00:07:15,840
may

00:07:13,680 --> 00:07:18,080
be maybe you don't want it to be called

00:07:15,840 --> 00:07:21,199
several times

00:07:18,080 --> 00:07:25,280
now um why is this happening

00:07:21,199 --> 00:07:26,160
it's because um every element in the

00:07:25,280 --> 00:07:29,199
pipeline

00:07:26,160 --> 00:07:31,440
pulls data from the one before it

00:07:29,199 --> 00:07:33,840
right this is this is why we've got this

00:07:31,440 --> 00:07:36,639
behavior

00:07:33,840 --> 00:07:36,639
now um

00:07:37,440 --> 00:07:40,479
this is the design of ranges i mean

00:07:39,520 --> 00:07:42,840
ranges are

00:07:40,479 --> 00:07:44,160
great i think this is a fantastic

00:07:42,840 --> 00:07:46,560
library

00:07:44,160 --> 00:07:47,840
but it has a design i mean it's not a

00:07:46,560 --> 00:07:48,720
problem to have a design but it has a

00:07:47,840 --> 00:07:51,280
design

00:07:48,720 --> 00:07:52,800
like everything which means that it has

00:07:51,280 --> 00:07:56,160
trade-offs which means that

00:07:52,800 --> 00:07:56,639
it it does um something in a great way

00:07:56,160 --> 00:07:59,440
and some

00:07:56,639 --> 00:07:59,840
other things and maybe not as great away

00:07:59,440 --> 00:08:03,840
as

00:07:59,840 --> 00:08:07,599
as uh as the other as the other things

00:08:03,840 --> 00:08:11,360
um and um the purpose of this talk

00:08:07,599 --> 00:08:14,160
is to explore another design right

00:08:11,360 --> 00:08:15,360
and this other design is to try and do

00:08:14,160 --> 00:08:18,400
the revise as in

00:08:15,360 --> 00:08:18,960
a push model right instead of instead of

00:08:18,400 --> 00:08:21,680
having

00:08:18,960 --> 00:08:22,160
one uh element of the pipeline pulling

00:08:21,680 --> 00:08:24,479
data

00:08:22,160 --> 00:08:26,560
from the one before let's try it and

00:08:24,479 --> 00:08:29,440
have every element in pipeline

00:08:26,560 --> 00:08:30,960
push something to the one further down

00:08:29,440 --> 00:08:33,360
in the pipeline

00:08:30,960 --> 00:08:34,080
right let's let's try and do that and

00:08:33,360 --> 00:08:37,360
see

00:08:34,080 --> 00:08:39,839
um the other trade-offs

00:08:37,360 --> 00:08:40,719
that we get and the other good things

00:08:39,839 --> 00:08:44,320
that that

00:08:40,719 --> 00:08:44,640
this brings and the whole purpose is to

00:08:44,320 --> 00:08:47,760
use

00:08:44,640 --> 00:08:52,560
ranges and this push model

00:08:47,760 --> 00:08:52,560
together to get the best of both worlds

00:08:52,880 --> 00:08:59,519
now um if we

00:08:55,920 --> 00:09:01,839
um take a a

00:08:59,519 --> 00:09:02,800
like a picture to represent what it

00:09:01,839 --> 00:09:05,279
looks like push

00:09:02,800 --> 00:09:06,560
things further down the line um i think

00:09:05,279 --> 00:09:08,959
it looks like plumbing

00:09:06,560 --> 00:09:10,560
as in really the plumbing that's in the

00:09:08,959 --> 00:09:14,399
room uh where are you

00:09:10,560 --> 00:09:17,440
sitting in um with pipes with the

00:09:14,399 --> 00:09:19,920
water flowing down the pipes for example

00:09:17,440 --> 00:09:21,519
it's a good example i think because you

00:09:19,920 --> 00:09:25,279
can imagine

00:09:21,519 --> 00:09:28,560
sending liquids to a pipe and the pipe

00:09:25,279 --> 00:09:32,160
pushes that liquid through and over

00:09:28,560 --> 00:09:35,519
the next pipe down the pipeline

00:09:32,160 --> 00:09:38,080
right so um we can think of it as

00:09:35,519 --> 00:09:39,680
just pipes so if we think of it that way

00:09:38,080 --> 00:09:41,760
then what's happening is that one

00:09:39,680 --> 00:09:43,120
goes through the first pipe comes out

00:09:41,760 --> 00:09:45,360
with the function applied

00:09:43,120 --> 00:09:46,240
and then goes through the filter to make

00:09:45,360 --> 00:09:49,279
sure that

00:09:46,240 --> 00:09:50,160
um the application of function satisfies

00:09:49,279 --> 00:09:52,240
a pretty good

00:09:50,160 --> 00:09:53,680
and whenever one satisfy the predicate

00:09:52,240 --> 00:09:56,800
then you get it get put

00:09:53,680 --> 00:09:57,920
pushed over to another place so it has

00:09:56,800 --> 00:10:00,080
to

00:09:57,920 --> 00:10:01,519
it has to come out somewhere it doesn't

00:10:00,080 --> 00:10:04,480
go into the void

00:10:01,519 --> 00:10:04,800
um so let's create a new pipe and like

00:10:04,480 --> 00:10:07,760
an

00:10:04,800 --> 00:10:10,240
ending pipe that we call pushback and we

00:10:07,760 --> 00:10:12,079
sort of attach to container like results

00:10:10,240 --> 00:10:13,920
which something which is something like

00:10:12,079 --> 00:10:18,240
effector where we could

00:10:13,920 --> 00:10:22,000
well we can push back on

00:10:18,240 --> 00:10:25,360
so um we send every element in turn

00:10:22,000 --> 00:10:27,920
um to the pipeline and every pipe pushes

00:10:25,360 --> 00:10:32,480
um whatever comes out the next pipe down

00:10:27,920 --> 00:10:35,680
the line

00:10:32,480 --> 00:10:38,959
so this is a pipeline so far

00:10:35,680 --> 00:10:42,560
this is just a picture and a uh

00:10:38,959 --> 00:10:46,160
a vision of the mind now can we write

00:10:42,560 --> 00:10:49,200
code actual code to do that um we can

00:10:46,160 --> 00:10:49,600
and we can use one library which is

00:10:49,200 --> 00:10:53,360
called

00:10:49,600 --> 00:10:56,959
pipes that does just that

00:10:53,360 --> 00:11:00,079
and the purpose of this pipes library

00:10:56,959 --> 00:11:02,240
is to allow you to write code that looks

00:11:00,079 --> 00:11:04,880
like the drawing like the pipelines that

00:11:02,240 --> 00:11:04,880
we see in the picture

00:11:06,160 --> 00:11:10,720
this is this code actually compiles and

00:11:08,640 --> 00:11:11,519
runs and you can find it for example in

00:11:10,720 --> 00:11:15,600
this library

00:11:11,519 --> 00:11:17,760
on this github hives

00:11:15,600 --> 00:11:19,680
now if we make the same test as before

00:11:17,760 --> 00:11:21,600
to make sure of what's going through

00:11:19,680 --> 00:11:22,399
transform then we get one two three four

00:11:21,600 --> 00:11:25,200
five six

00:11:22,399 --> 00:11:27,600
which is what we expect what we expected

00:11:25,200 --> 00:11:30,560
in the beginning

00:11:27,600 --> 00:11:31,360
now uh you know that in this pipes

00:11:30,560 --> 00:11:34,800
library

00:11:31,360 --> 00:11:37,519
with the pipes um metaphor

00:11:34,800 --> 00:11:38,560
there is no pipe operator that's this

00:11:37,519 --> 00:11:41,200
greater greater

00:11:38,560 --> 00:11:44,079
equal operator which may sound a bit

00:11:41,200 --> 00:11:47,120
surprising so why

00:11:44,079 --> 00:11:49,760
well when when you think about things

00:11:47,120 --> 00:11:50,720
coming through a pipe you can you can

00:11:49,760 --> 00:11:53,360
think of those

00:11:50,720 --> 00:11:55,360
things coming with a direction and then

00:11:53,360 --> 00:11:56,000
you can think of the equal sign as the

00:11:55,360 --> 00:11:58,639
pipes which

00:11:56,000 --> 00:12:00,800
form the greater greater equal which is

00:11:58,639 --> 00:12:02,160
that which could be a good explanation

00:12:00,800 --> 00:12:04,720
but there's another one which is more

00:12:02,160 --> 00:12:07,120
technical it's because this operator is

00:12:04,720 --> 00:12:09,600
right associative

00:12:07,120 --> 00:12:10,800
what does that mean and what does that

00:12:09,600 --> 00:12:13,120
imply

00:12:10,800 --> 00:12:14,800
well if something is right associative

00:12:13,120 --> 00:12:16,560
if you've got several of them in the

00:12:14,800 --> 00:12:20,079
same expression they get passed

00:12:16,560 --> 00:12:23,200
from the right and then to the left

00:12:20,079 --> 00:12:23,760
so um when the compiler passes this

00:12:23,200 --> 00:12:27,200
expression

00:12:23,760 --> 00:12:28,000
would start by associating the ones on

00:12:27,200 --> 00:12:30,160
the right

00:12:28,000 --> 00:12:32,160
to create a new object which let's call

00:12:30,160 --> 00:12:33,680
it pipeline one

00:12:32,160 --> 00:12:35,519
then we associate pipeline one which

00:12:33,680 --> 00:12:37,680
transform and then

00:12:35,519 --> 00:12:39,680
we have another pipeline and when we

00:12:37,680 --> 00:12:42,560
associate the inputs with this

00:12:39,680 --> 00:12:44,320
new aggregated pipeline and then we can

00:12:42,560 --> 00:12:46,639
just iterate

00:12:44,320 --> 00:12:49,279
over the inputs and send them one by one

00:12:46,639 --> 00:12:49,279
in the pipeline

00:12:49,920 --> 00:12:53,440
this in this particular example is an

00:12:52,240 --> 00:12:55,600
value

00:12:53,440 --> 00:12:57,040
but this could just as well be an r

00:12:55,600 --> 00:13:00,079
value and this is

00:12:57,040 --> 00:13:03,440
the exact same principle now

00:13:00,079 --> 00:13:05,680
if you um have right associativity

00:13:03,440 --> 00:13:07,200
it means that we can use r values as

00:13:05,680 --> 00:13:11,279
inputs just as easily as

00:13:07,200 --> 00:13:11,839
l values now if we use the pipe operator

00:13:11,279 --> 00:13:15,519
which is

00:13:11,839 --> 00:13:17,519
um left associative we start by

00:13:15,519 --> 00:13:19,600
combining the elements on the left right

00:13:17,519 --> 00:13:23,120
which outputs something

00:13:19,600 --> 00:13:25,440
right and um this something has to be

00:13:23,120 --> 00:13:26,399
um associated with the rest of the

00:13:25,440 --> 00:13:29,600
pipeline

00:13:26,399 --> 00:13:32,880
right so this something somehow

00:13:29,600 --> 00:13:34,880
has to keep track of the inputs right

00:13:32,880 --> 00:13:36,639
a simple way to keep track of the inputs

00:13:34,880 --> 00:13:40,720
is to have a reference

00:13:36,639 --> 00:13:42,880
pointing towards the input um now

00:13:40,720 --> 00:13:45,440
um having an a reference to an l value

00:13:42,880 --> 00:13:47,440
is is okay but when it's in r value it's

00:13:45,440 --> 00:13:48,560
it's more complicated it's really more

00:13:47,440 --> 00:13:52,079
complicated

00:13:48,560 --> 00:13:55,680
now ranges have this pipe operator so

00:13:52,079 --> 00:13:58,720
how do ranges manage to do that

00:13:55,680 --> 00:14:00,320
um the thing is um um

00:13:58,720 --> 00:14:02,079
when you try to do that with ranges get

00:14:00,320 --> 00:14:04,639
as static as that which is a very

00:14:02,079 --> 00:14:06,480
expressive error message by the way um

00:14:04,639 --> 00:14:09,199
that tells you that you should not

00:14:06,480 --> 00:14:09,920
use an r value so this is just a

00:14:09,199 --> 00:14:13,360
trade-off

00:14:09,920 --> 00:14:15,120
um the pipe operator makes using our

00:14:13,360 --> 00:14:18,320
value more complicated than the greater

00:14:15,120 --> 00:14:21,199
great than a great radar equal upright

00:14:18,320 --> 00:14:21,920
great after this introduction of pipes

00:14:21,199 --> 00:14:24,720
um

00:14:21,920 --> 00:14:26,240
let's uh let's see what pipes can do for

00:14:24,720 --> 00:14:29,600
us

00:14:26,240 --> 00:14:31,519
with that push um design so um

00:14:29,600 --> 00:14:33,199
we're going to start with um having a

00:14:31,519 --> 00:14:36,639
look at what the pipe

00:14:33,199 --> 00:14:39,120
exactly is and what's inside of the pipe

00:14:36,639 --> 00:14:40,240
and then we'll see what what can get

00:14:39,120 --> 00:14:42,959
into a pipeline

00:14:40,240 --> 00:14:44,399
and what can get out of the pipeline and

00:14:42,959 --> 00:14:47,839
to benefit from the push

00:14:44,399 --> 00:14:48,800
the push model so we've seen transforms

00:14:47,839 --> 00:14:51,839
in the filter

00:14:48,800 --> 00:14:53,920
and uh quite a few others

00:14:51,839 --> 00:14:55,519
um now if we zoom in on one of them

00:14:53,920 --> 00:14:57,360
let's say transform because it's

00:14:55,519 --> 00:14:58,000
probably one of the most um i'm the

00:14:57,360 --> 00:15:01,120
easiest one

00:14:58,000 --> 00:15:02,639
to um to think about

00:15:01,120 --> 00:15:05,040
i'm going to show you what's inside of

00:15:02,639 --> 00:15:08,880
transform

00:15:05,040 --> 00:15:11,839
by just um coding transform um

00:15:08,880 --> 00:15:12,480
from the ground up so we've got here a

00:15:11,839 --> 00:15:14,639
um

00:15:12,480 --> 00:15:16,079
a piece of code that has nothing and we

00:15:14,639 --> 00:15:19,279
are going to implement transform

00:15:16,079 --> 00:15:21,279
in it to make sure we implement it

00:15:19,279 --> 00:15:23,839
correctly we've got unit tests

00:15:21,279 --> 00:15:27,519
that um does what we would expect with

00:15:23,839 --> 00:15:30,560
transform we have a an input collection

00:15:27,519 --> 00:15:31,920
and we'd like to pipe the input into

00:15:30,560 --> 00:15:33,600
transform

00:15:31,920 --> 00:15:36,240
with a function that does something like

00:15:33,600 --> 00:15:38,480
times two and we would expect

00:15:36,240 --> 00:15:40,720
all all of the elements to be multiplied

00:15:38,480 --> 00:15:41,759
by two right and we compare the result

00:15:40,720 --> 00:15:44,880
would be

00:15:41,759 --> 00:15:48,000
expected i'm using catch two as a

00:15:44,880 --> 00:15:48,000
testing framework here

00:15:48,160 --> 00:15:54,320
right so um we've got to um

00:15:51,199 --> 00:15:57,279
have this transform so now so let's do a

00:15:54,320 --> 00:15:57,279
transform class

00:15:59,279 --> 00:16:05,839
and um it has to be um

00:16:02,320 --> 00:16:08,639
constructed with um function

00:16:05,839 --> 00:16:09,360
so it can be one element so let's uh

00:16:08,639 --> 00:16:12,320
have an

00:16:09,360 --> 00:16:13,839
instructor but we have a function which

00:16:12,320 --> 00:16:23,839
can be about anything so let's use a

00:16:13,839 --> 00:16:23,839
template type

00:16:24,959 --> 00:16:29,199
and we'll just um keep the function in

00:16:30,639 --> 00:16:37,839
with a parameter that will call function

00:16:42,079 --> 00:16:46,240
all right so now we can construct that

00:16:43,680 --> 00:16:49,120
construct it

00:16:46,240 --> 00:16:51,040
as we will see during the talk um when

00:16:49,120 --> 00:16:51,600
you have a pipe you can do a lot of

00:16:51,040 --> 00:16:54,000
things

00:16:51,600 --> 00:16:55,279
with it and it integrates with a lot of

00:16:54,000 --> 00:16:58,800
things including

00:16:55,279 --> 00:17:00,800
existing um existing things from the sel

00:16:58,800 --> 00:17:02,480
so we just kind of tell the library that

00:17:00,800 --> 00:17:07,120
this is a pipe

00:17:02,480 --> 00:17:10,400
by inheriting from a specific

00:17:07,120 --> 00:17:12,079
uh base class now i'm going through the

00:17:10,400 --> 00:17:15,039
code of that base class it's not

00:17:12,079 --> 00:17:18,400
tremendously complicated

00:17:15,039 --> 00:17:22,160
this is just that it's more a tag there

00:17:18,400 --> 00:17:25,760
than anything but um it's implemented as

00:17:22,160 --> 00:17:27,760
a base class just for the

00:17:25,760 --> 00:17:31,200
um sake of extension purposes

00:17:27,760 --> 00:17:33,520
potentially but it's just a tag really

00:17:31,200 --> 00:17:35,280
now the library knows that this is a

00:17:33,520 --> 00:17:36,480
pipe so we don't have to do

00:17:35,280 --> 00:17:38,400
a lot of things we don't have to

00:17:36,480 --> 00:17:39,440
implement the operator greater greater

00:17:38,400 --> 00:17:41,120
equal we don't have to

00:17:39,440 --> 00:17:42,960
implement an integration with anything

00:17:41,120 --> 00:17:44,880
we just have to implement

00:17:42,960 --> 00:17:47,200
what's specific to transform which is

00:17:44,880 --> 00:17:49,679
applying a function

00:17:47,200 --> 00:17:51,520
so we've got a um we have to implement a

00:17:49,679 --> 00:17:53,520
function that's called unreceive

00:17:51,520 --> 00:17:54,960
that says what to do when transform

00:17:53,520 --> 00:17:58,400
receives something from the pi

00:17:54,960 --> 00:17:58,960
that's before it so we receive something

00:17:58,400 --> 00:18:02,000
let's say

00:17:58,960 --> 00:18:05,520
a value here anything that

00:18:02,000 --> 00:18:05,520
let's use a template as well

00:18:07,280 --> 00:18:13,039
and um there's the the rest of the

00:18:10,640 --> 00:18:16,000
pipeline you can transform has to send

00:18:13,039 --> 00:18:18,080
whatever uh something its results to the

00:18:16,000 --> 00:18:21,679
rest of the pipeline so let's call that

00:18:18,080 --> 00:18:24,000
tame for example take pipeline

00:18:21,679 --> 00:18:25,280
let's not worry about the type of a

00:18:24,000 --> 00:18:29,840
pipeline is to say

00:18:25,280 --> 00:18:29,840
it's a type

00:18:33,280 --> 00:18:37,039
and we can what we want to do is to

00:18:35,120 --> 00:18:37,840
apply the function and send the results

00:18:37,039 --> 00:18:40,960
to the next

00:18:37,840 --> 00:18:40,960
to the 3.5

00:18:41,120 --> 00:18:47,120
and to do that um the library provides

00:18:44,400 --> 00:18:48,880
a send function so it's a free function

00:18:47,120 --> 00:18:50,080
that's in the namespace files which is

00:18:48,880 --> 00:18:53,520
in this includes

00:18:50,080 --> 00:18:56,080
so we're going to send the result of

00:18:53,520 --> 00:18:56,080
applying

00:19:08,840 --> 00:19:15,039
white

00:19:11,600 --> 00:19:18,160
okay now the library

00:19:15,039 --> 00:19:20,400
is um it's compatible with c plus

00:19:18,160 --> 00:19:21,360
14 because i think it's um currently

00:19:20,400 --> 00:19:23,760
it's

00:19:21,360 --> 00:19:24,400
a reasonable trade-off between power the

00:19:23,760 --> 00:19:27,679
language

00:19:24,400 --> 00:19:30,480
and what people have in in existing

00:19:27,679 --> 00:19:33,679
potentially legacy code bases

00:19:30,480 --> 00:19:36,880
so if we go back to the calling sites

00:19:33,679 --> 00:19:38,960
we have to pass a for example londa

00:19:36,880 --> 00:19:40,880
without specifying a type

00:19:38,960 --> 00:19:42,720
in c plus plus 17 we're gonna have uh

00:19:40,880 --> 00:19:44,480
automatic deduction but in c plus plus

00:19:42,720 --> 00:19:47,760
four didn't have to go back to the

00:19:44,480 --> 00:19:53,840
good old um helper function uh um

00:19:47,760 --> 00:19:53,840
we'll reduce the temperature for us

00:19:59,760 --> 00:20:04,720
transform of a function

00:20:04,840 --> 00:20:10,960
function and

00:20:08,559 --> 00:20:10,960
return

00:20:16,559 --> 00:20:20,480
right now they can't both have the same

00:20:18,640 --> 00:20:24,559
names that we're going to change

00:20:20,480 --> 00:20:24,559
this name for example to transform pi

00:20:25,200 --> 00:20:30,720
right let's compile

00:20:28,400 --> 00:20:34,320
and run i'm expecting it to fail because

00:20:30,720 --> 00:20:37,360
it's a live demo

00:20:34,320 --> 00:20:38,559
surprisingly not failing let's see let's

00:20:37,360 --> 00:20:48,080
wait

00:20:38,559 --> 00:20:50,640
that's what we're gonna find

00:20:48,080 --> 00:20:50,640
succeeded

00:20:51,200 --> 00:20:58,000
and what's the result of the tests

00:20:54,240 --> 00:20:58,000
let's comment let's see that

00:20:58,400 --> 00:21:04,799
what has passed well the live

00:21:01,440 --> 00:21:07,520
demo uh was successful

00:21:04,799 --> 00:21:08,880
that's that's great okay so well anyway

00:21:07,520 --> 00:21:12,559
the purpose of this demo

00:21:08,880 --> 00:21:16,159
was to show you that it's very easy

00:21:12,559 --> 00:21:16,640
to implement a pipe this is nearly the

00:21:16,159 --> 00:21:18,320
implement

00:21:16,640 --> 00:21:20,400
the actual implementation of the

00:21:18,320 --> 00:21:22,000
transform time that just a few details

00:21:20,400 --> 00:21:24,159
work out like for example with not

00:21:22,000 --> 00:21:25,520
having function but like

00:21:24,159 --> 00:21:26,720
not a free function but a member

00:21:25,520 --> 00:21:27,440
function or something like that maybe

00:21:26,720 --> 00:21:30,080
you want to

00:21:27,440 --> 00:21:31,679
stood in vogue instead of just calling

00:21:30,080 --> 00:21:32,240
that that way but this is not just

00:21:31,679 --> 00:21:34,559
details

00:21:32,240 --> 00:21:37,280
um essentially it's it's it's really

00:21:34,559 --> 00:21:41,039
easy to implement a pipe

00:21:37,280 --> 00:21:42,720
right um so um now let's um

00:21:41,039 --> 00:21:44,320
let's see one thing that i think is

00:21:42,720 --> 00:21:47,360
specific to the push model

00:21:44,320 --> 00:21:49,360
and to pipes i don't i haven't seen that

00:21:47,360 --> 00:21:50,799
anywhere else it's the concept of

00:21:49,360 --> 00:21:53,760
branching out

00:21:50,799 --> 00:21:56,400
because if you think of a pipeline as in

00:21:53,760 --> 00:21:58,880
in real life with plumbing

00:21:56,400 --> 00:22:00,320
you can you can imagine a pipeline

00:21:58,880 --> 00:22:03,360
branching out

00:22:00,320 --> 00:22:04,799
into several directions right

00:22:03,360 --> 00:22:06,640
something that we can imagine quite

00:22:04,799 --> 00:22:10,320
easily

00:22:06,640 --> 00:22:11,840
now um let's let's um

00:22:10,320 --> 00:22:13,760
think about this simple use case of

00:22:11,840 --> 00:22:15,840
having a t pipe

00:22:13,760 --> 00:22:16,880
uh that would do a bit like in uh in

00:22:15,840 --> 00:22:20,640
unix

00:22:16,880 --> 00:22:23,679
uh in the t program that would um

00:22:20,640 --> 00:22:26,960
um um done somewhere the

00:22:23,679 --> 00:22:29,280
um whatever come this way and send it

00:22:26,960 --> 00:22:30,159
on to the next pipe right so we could

00:22:29,280 --> 00:22:33,360
dump

00:22:30,159 --> 00:22:36,480
uh what comes out of transform to this

00:22:33,360 --> 00:22:38,840
push back uh to intermediary results

00:22:36,480 --> 00:22:40,720
and still send the results onto the full

00:22:38,840 --> 00:22:43,679
time

00:22:40,720 --> 00:22:44,640
if we write this with code this is what

00:22:43,679 --> 00:22:47,280
it looks like

00:22:44,640 --> 00:22:48,799
we have inputs that goes into transform

00:22:47,280 --> 00:22:52,080
that goes into t

00:22:48,799 --> 00:22:55,039
that has both an output to push back

00:22:52,080 --> 00:22:56,240
and one filter and an output to push

00:22:55,039 --> 00:22:59,120
back

00:22:56,240 --> 00:22:59,919
and what's happening then is that

00:22:59,120 --> 00:23:02,960
everything

00:22:59,919 --> 00:23:06,720
that comes out of transform goes down

00:23:02,960 --> 00:23:10,159
to the intermediary results and only

00:23:06,720 --> 00:23:13,120
what satisfy the predicate a filter goes

00:23:10,159 --> 00:23:13,120
through filter

00:23:14,880 --> 00:23:18,799
this is a load by the push model right

00:23:17,679 --> 00:23:22,480
because

00:23:18,799 --> 00:23:24,400
since a hype is sending to another one

00:23:22,480 --> 00:23:26,000
further down the line it might just as

00:23:24,400 --> 00:23:29,440
well send it to

00:23:26,000 --> 00:23:30,240
any number of pipe and t is just an

00:23:29,440 --> 00:23:33,200
example of

00:23:30,240 --> 00:23:34,000
true direction but we can think of of

00:23:33,200 --> 00:23:36,080
ascending

00:23:34,000 --> 00:23:37,200
any number of pipes with for example the

00:23:36,080 --> 00:23:40,640
fork

00:23:37,200 --> 00:23:42,240
um pipe right that would duplicate or

00:23:40,640 --> 00:23:45,679
triplicate or

00:23:42,240 --> 00:23:48,240
amplicate i guess your data

00:23:45,679 --> 00:23:50,720
and send them to um other pipelines

00:23:48,240 --> 00:23:53,360
which could be any any sort of pipeline

00:23:50,720 --> 00:23:53,360
down the line

00:23:54,480 --> 00:23:58,320
i think this is very unique to the bush

00:23:56,000 --> 00:23:58,320
model

00:23:58,720 --> 00:24:03,120
the the point of that is that once

00:24:01,360 --> 00:24:05,200
you've transformed your data with

00:24:03,120 --> 00:24:07,440
f you don't have to store it to three

00:24:05,200 --> 00:24:10,320
different places

00:24:07,440 --> 00:24:10,960
with um with a memory allocated to that

00:24:10,320 --> 00:24:14,320
you can just

00:24:10,960 --> 00:24:17,200
pick it up with the fork pipe

00:24:14,320 --> 00:24:19,840
and send that to three different

00:24:17,200 --> 00:24:19,840
pipelines

00:24:20,400 --> 00:24:23,520
and if we transform that into code um

00:24:22,960 --> 00:24:25,840
the

00:24:23,520 --> 00:24:28,080
purpose is still to have code that looks

00:24:25,840 --> 00:24:29,520
um as much as possible as possible as

00:24:28,080 --> 00:24:31,760
the drawing

00:24:29,520 --> 00:24:33,520
which is the point of the code below

00:24:31,760 --> 00:24:37,360
that mimics the drawing

00:24:33,520 --> 00:24:40,480
above another way to

00:24:37,360 --> 00:24:45,200
branch out is to separate out

00:24:40,480 --> 00:24:49,360
the elements of a tool or a pair right

00:24:45,200 --> 00:24:52,559
um the unzip pipe does just that

00:24:49,360 --> 00:24:55,520
if we um see that on in on an example

00:24:52,559 --> 00:24:56,720
um if you consider a map which is

00:24:55,520 --> 00:25:01,440
represented as a

00:24:56,720 --> 00:25:05,120
collection of pairs we can unzip

00:25:01,440 --> 00:25:07,520
those pairs into a separate collection

00:25:05,120 --> 00:25:15,840
of keys and a separate collection of

00:25:07,520 --> 00:25:15,840
values with just this line of code

00:25:16,720 --> 00:25:22,559
this was inside of a

00:25:19,760 --> 00:25:23,120
pipe which are specific to pipes which

00:25:22,559 --> 00:25:26,000
um

00:25:23,120 --> 00:25:26,400
which are so an easy way to implement

00:25:26,000 --> 00:25:30,480
them

00:25:26,400 --> 00:25:32,880
and the potential uh

00:25:30,480 --> 00:25:35,279
yeah we can potentially branch out now

00:25:32,880 --> 00:25:38,799
if we if we think about what gets in

00:25:35,279 --> 00:25:39,679
a pipeline um um how can we benefit from

00:25:38,799 --> 00:25:44,159
the fact that we're

00:25:39,679 --> 00:25:49,520
pushing to the pipe how can that benefit

00:25:44,159 --> 00:25:49,520
to capturing inputs

00:25:49,600 --> 00:25:52,880
well so far we've been working with

00:25:51,760 --> 00:25:56,240
vectors

00:25:52,880 --> 00:25:58,720
in all the examples that we've seen

00:25:56,240 --> 00:26:00,799
now um there's nothing specific to

00:25:58,720 --> 00:26:02,720
factor really we're just iterating over

00:26:00,799 --> 00:26:05,840
inputs so anything that has a begin

00:26:02,720 --> 00:26:08,320
and an end can be iterated on and

00:26:05,840 --> 00:26:09,279
work with this pipes library so that can

00:26:08,320 --> 00:26:12,400
be any range

00:26:09,279 --> 00:26:15,760
really and this is this is where

00:26:12,400 --> 00:26:19,360
rangers meet pipes we can

00:26:15,760 --> 00:26:21,520
we can create a range by using

00:26:19,360 --> 00:26:22,880
range adapters very powerful range

00:26:21,520 --> 00:26:26,720
adapters

00:26:22,880 --> 00:26:28,880
and um pipe the result of that

00:26:26,720 --> 00:26:30,799
to a pipeline that would potentially

00:26:28,880 --> 00:26:33,279
branch out for example which ranges

00:26:30,799 --> 00:26:33,279
condo

00:26:34,320 --> 00:26:37,440
now there's um another thing that we can

00:26:36,720 --> 00:26:39,520
do

00:26:37,440 --> 00:26:41,039
to benefit from the push model is to

00:26:39,520 --> 00:26:44,799
pick up the results

00:26:41,039 --> 00:26:48,400
of estee algorithms without storing them

00:26:44,799 --> 00:26:50,960
to a container imagine this

00:26:48,400 --> 00:26:52,400
this algorithm set difference that takes

00:26:50,960 --> 00:26:54,320
two collection

00:26:52,400 --> 00:26:55,600
two collections two sorts of collections

00:26:54,320 --> 00:26:58,720
and outputs

00:26:55,600 --> 00:26:59,919
to an output tracer uh the elements that

00:26:58,720 --> 00:27:01,600
are in the first collection

00:26:59,919 --> 00:27:03,520
and that are not in the second

00:27:01,600 --> 00:27:05,120
collection

00:27:03,520 --> 00:27:07,039
if we'd like to do something with those

00:27:05,120 --> 00:27:09,279
results for example

00:27:07,039 --> 00:27:10,640
applying a function or filtering on them

00:27:09,279 --> 00:27:12,559
or whatever

00:27:10,640 --> 00:27:13,760
normally would we would have to store

00:27:12,559 --> 00:27:16,159
them into a

00:27:13,760 --> 00:27:17,520
for example a vector and work on the

00:27:16,159 --> 00:27:20,960
vector

00:27:17,520 --> 00:27:23,840
now what if we could somehow

00:27:20,960 --> 00:27:25,520
send make set different sentence results

00:27:23,840 --> 00:27:27,440
to a pipeline that would avoid us

00:27:25,520 --> 00:27:28,640
that would prevent that would avoid the

00:27:27,440 --> 00:27:34,159
need

00:27:28,640 --> 00:27:37,279
from having um a full container for that

00:27:34,159 --> 00:27:39,440
well it turns out that we can by taking

00:27:37,279 --> 00:27:40,240
advantage of the interface of the output

00:27:39,440 --> 00:27:42,399
iterator

00:27:40,240 --> 00:27:44,480
because set difference is sending data

00:27:42,399 --> 00:27:48,399
to the output iterator

00:27:44,480 --> 00:27:49,520
and pipes turn that to have the same

00:27:48,399 --> 00:27:51,600
interface or they

00:27:49,520 --> 00:27:52,640
are comfortable compatible with the

00:27:51,600 --> 00:27:55,760
interface

00:27:52,640 --> 00:27:57,200
of output iterators this is one of the

00:27:55,760 --> 00:27:59,360
thing that you get for free

00:27:57,200 --> 00:28:01,279
by using the pi base that we've seen in

00:27:59,360 --> 00:28:03,840
the demo

00:28:01,279 --> 00:28:04,640
so you can just stick a pipeline in the

00:28:03,840 --> 00:28:07,279
position where

00:28:04,640 --> 00:28:08,240
you would normally put an output

00:28:07,279 --> 00:28:10,559
iterator

00:28:08,240 --> 00:28:11,840
and um and this pipeline will pick up

00:28:10,559 --> 00:28:17,760
the results coming out

00:28:11,840 --> 00:28:20,799
of the algorithm

00:28:17,760 --> 00:28:21,840
it gets perhaps even more interesting if

00:28:20,799 --> 00:28:24,559
an algorithm has

00:28:21,840 --> 00:28:25,760
several outputs in the standard library

00:28:24,559 --> 00:28:28,159
there are not many

00:28:25,760 --> 00:28:29,279
algorithms that have several outputs

00:28:28,159 --> 00:28:32,080
there's just a

00:28:29,279 --> 00:28:33,520
politician coffee uh but if we think a

00:28:32,080 --> 00:28:36,159
bit further than

00:28:33,520 --> 00:28:37,760
the sd algorithms the official library

00:28:36,159 --> 00:28:39,919
standard library

00:28:37,760 --> 00:28:41,279
we can easily imagine algorithms that

00:28:39,919 --> 00:28:44,640
have several outputs

00:28:41,279 --> 00:28:46,480
for example um imagine an

00:28:44,640 --> 00:28:48,320
algorithm that takes two collections a

00:28:46,480 --> 00:28:51,200
bit like set difference

00:28:48,320 --> 00:28:52,799
but that would send separately the

00:28:51,200 --> 00:28:54,399
elements that are in the first one and

00:28:52,799 --> 00:28:56,399
not in the second one

00:28:54,399 --> 00:28:58,799
and the elements are in the second one

00:28:56,399 --> 00:29:01,120
but not in in the first one

00:28:58,799 --> 00:29:01,840
and in the third output the element are

00:29:01,120 --> 00:29:04,240
in both

00:29:01,840 --> 00:29:07,039
a bit like a mix of set difference and

00:29:04,240 --> 00:29:09,039
set you in setting section

00:29:07,039 --> 00:29:10,159
let's call that set segregated it's not

00:29:09,039 --> 00:29:12,480
the purpose of

00:29:10,159 --> 00:29:13,360
today to implement certificates so let's

00:29:12,480 --> 00:29:16,480
imagine that

00:29:13,360 --> 00:29:17,360
we have it it exists um not in the

00:29:16,480 --> 00:29:21,200
standard but this

00:29:17,360 --> 00:29:24,559
exists in open source projects

00:29:21,200 --> 00:29:28,320
um and um so segregated we have three

00:29:24,559 --> 00:29:31,520
output iterator that we can branch to

00:29:28,320 --> 00:29:31,520
three pipelines

00:29:31,760 --> 00:29:38,559
any any shape and form

00:29:34,960 --> 00:29:41,440
and we can build a quite elaborate

00:29:38,559 --> 00:29:41,919
pipeline with just a few lines of code

00:29:41,440 --> 00:29:45,760
that

00:29:41,919 --> 00:29:45,760
again mimic the drawing

00:29:46,080 --> 00:29:49,919
so i think this is a great advantage of

00:29:47,679 --> 00:29:53,200
the push model

00:29:49,919 --> 00:29:55,360
now if we have several ranges today

00:29:53,200 --> 00:29:56,559
if you want to work with several ranges

00:29:55,360 --> 00:29:59,919
um i think that

00:29:56,559 --> 00:30:02,000
the best way is to use ranges with flip

00:29:59,919 --> 00:30:02,960
zip and the purpose of the zip is to

00:30:02,000 --> 00:30:05,600
bring together

00:30:02,960 --> 00:30:07,120
two collections right and it does that

00:30:05,600 --> 00:30:10,480
by um

00:30:07,120 --> 00:30:13,120
putting the corresponding element into a

00:30:10,480 --> 00:30:15,120
into a topple right or a total of two

00:30:13,120 --> 00:30:18,000
elements in this case

00:30:15,120 --> 00:30:18,559
so if we want to zip the the collections

00:30:18,000 --> 00:30:21,919
together

00:30:18,559 --> 00:30:22,559
and work on this association for example

00:30:21,919 --> 00:30:24,399
by

00:30:22,559 --> 00:30:26,399
filtering some tuples or applying a

00:30:24,399 --> 00:30:30,799
function to some tuples

00:30:26,399 --> 00:30:34,640
we could do something like that

00:30:30,799 --> 00:30:38,320
now this is perhaps unnecessary verbose

00:30:34,640 --> 00:30:41,279
we could use c plus 14 auto in lambda

00:30:38,320 --> 00:30:42,399
just to hide the long name of the tuple

00:30:41,279 --> 00:30:45,679
and we can use um

00:30:42,399 --> 00:30:48,000
c plus 7 to instruct bindings to hide

00:30:45,679 --> 00:30:49,520
listed gets which looks much more

00:30:48,000 --> 00:30:52,960
concise

00:30:49,520 --> 00:30:56,080
now so um this is using topple and

00:30:52,960 --> 00:30:59,519
the the consequence

00:30:56,080 --> 00:31:02,159
is that we we don't see the arguments

00:30:59,519 --> 00:31:03,200
separately in the interface and we still

00:31:02,159 --> 00:31:05,760
have to

00:31:03,200 --> 00:31:07,600
extract them from the toolball with even

00:31:05,760 --> 00:31:11,919
if we're using structure bindings

00:31:07,600 --> 00:31:14,880
right now if we think of the push model

00:31:11,919 --> 00:31:16,960
um the push model is just um like we saw

00:31:14,880 --> 00:31:17,760
it's it's calling send so it's like

00:31:16,960 --> 00:31:19,760
applying

00:31:17,760 --> 00:31:21,519
functions and when you're applying

00:31:19,760 --> 00:31:23,600
functions you can have as many

00:31:21,519 --> 00:31:25,279
arguments as you'd like without having

00:31:23,600 --> 00:31:27,440
to use a tool

00:31:25,279 --> 00:31:28,880
as opposed to pulling data you can you

00:31:27,440 --> 00:31:30,960
can just pull one piece of data at a

00:31:28,880 --> 00:31:34,320
time so you have to group that you know

00:31:30,960 --> 00:31:37,679
october i think right so let's

00:31:34,320 --> 00:31:39,440
imagine this uh max point that would

00:31:37,679 --> 00:31:42,640
accept two collections

00:31:39,440 --> 00:31:46,559
um and it would um somehow absorb them

00:31:42,640 --> 00:31:48,159
and send them to the pipeline

00:31:46,559 --> 00:31:50,720
in code that would look like that so we

00:31:48,159 --> 00:31:54,399
have marks that associates

00:31:50,720 --> 00:31:58,840
so or any number that matter collections

00:31:54,399 --> 00:32:01,679
and would um send those collections

00:31:58,840 --> 00:32:05,039
simultaneously to the pipeline right

00:32:01,679 --> 00:32:08,080
and the advantage is that the prototype

00:32:05,039 --> 00:32:09,279
of the function inside a filter has int

00:32:08,080 --> 00:32:13,200
a in b

00:32:09,279 --> 00:32:16,399
um explicitly it's not a topple

00:32:13,200 --> 00:32:17,760
can we do that let's see that let's go

00:32:16,399 --> 00:32:21,440
back to the code let's try and

00:32:17,760 --> 00:32:24,559
implement uh mox with transform

00:32:21,440 --> 00:32:25,120
well in fact mox is um we're going to

00:32:24,559 --> 00:32:27,279
make

00:32:25,120 --> 00:32:28,799
transform compatible with max let's not

00:32:27,279 --> 00:32:31,279
implement max smokes a bit

00:32:28,799 --> 00:32:31,840
um more chords we're not going to get

00:32:31,279 --> 00:32:34,640
into that

00:32:31,840 --> 00:32:35,679
now but let's make transform compatible

00:32:34,640 --> 00:32:39,279
with mark so

00:32:35,679 --> 00:32:42,559
we've got this second unit test that

00:32:39,279 --> 00:32:45,679
has two collection this one and this one

00:32:42,559 --> 00:32:48,159
and would uh mux them together and

00:32:45,679 --> 00:32:49,039
apply a function on every pair of

00:32:48,159 --> 00:32:51,039
elements

00:32:49,039 --> 00:32:52,480
right and collect the results in

00:32:51,039 --> 00:32:54,399
inflection right

00:32:52,480 --> 00:32:56,240
so we would expect the sum of all

00:32:54,399 --> 00:32:58,559
corresponding elements so one percent

00:32:56,240 --> 00:33:01,440
two plus twenty et cetera

00:32:58,559 --> 00:33:02,000
if i run the program i've got a build

00:33:01,440 --> 00:33:05,919
failure

00:33:02,000 --> 00:33:09,440
because um our transform

00:33:05,919 --> 00:33:10,480
only accepts one value right and mux is

00:33:09,440 --> 00:33:13,200
trying to send

00:33:10,480 --> 00:33:14,720
several values to transform so we have

00:33:13,200 --> 00:33:17,919
to change transform to make it

00:33:14,720 --> 00:33:21,279
accept several values let's just do that

00:33:17,919 --> 00:33:25,840
we're going to add um the dots and some

00:33:21,279 --> 00:33:25,840
trolls and on the names

00:33:28,320 --> 00:33:33,200
so we have to have a function that takes

00:33:30,399 --> 00:33:33,200
several arguments

00:33:33,600 --> 00:33:40,559
and i think that's about it

00:33:37,279 --> 00:33:42,080
let's um oh yeah there's a missing s

00:33:40,559 --> 00:33:46,799
here

00:33:42,080 --> 00:33:46,799
let's uh compile and run the program

00:33:51,360 --> 00:33:55,440
it's building the full um test suite of

00:33:53,519 --> 00:33:57,600
the project yeah it's it's past

00:33:55,440 --> 00:34:00,960
so we've just with just that we've made

00:33:57,600 --> 00:34:03,840
transform compatible with mux

00:34:00,960 --> 00:34:04,559
and we've made this example compile and

00:34:03,840 --> 00:34:07,840
uh

00:34:04,559 --> 00:34:07,840
and work

00:34:12,720 --> 00:34:16,000
so there's no toggle here now let's see

00:34:15,599 --> 00:34:20,320
a

00:34:16,000 --> 00:34:20,960
concrete example with a domain which i

00:34:20,320 --> 00:34:23,200
find

00:34:20,960 --> 00:34:24,079
uh fascinating even though i don't know

00:34:23,200 --> 00:34:26,320
anything about

00:34:24,079 --> 00:34:28,159
it it's biology right so we're going to

00:34:26,320 --> 00:34:31,200
see a a small example

00:34:28,159 --> 00:34:32,879
in biology um i'm going to walk you

00:34:31,200 --> 00:34:34,960
through it but it's uh

00:34:32,879 --> 00:34:36,879
you don't need to have any knowledge i

00:34:34,960 --> 00:34:39,760
don't have any

00:34:36,879 --> 00:34:41,679
right so it's about dna um so this is

00:34:39,760 --> 00:34:43,679
the dna of somebody let's call that

00:34:41,679 --> 00:34:47,280
person drawn

00:34:43,679 --> 00:34:49,760
the way that works um those are

00:34:47,280 --> 00:34:50,480
john's chromosomes so they're present in

00:34:49,760 --> 00:34:53,359
every

00:34:50,480 --> 00:34:54,560
uh one of john's cells uh there's one

00:34:53,359 --> 00:34:56,480
that's coming from

00:34:54,560 --> 00:34:58,800
john's dad and one that's coming from

00:34:56,480 --> 00:35:03,359
john's mom from every for every pair

00:34:58,800 --> 00:35:07,119
of those of those chromosomes

00:35:03,359 --> 00:35:10,320
now when um to to create

00:35:07,119 --> 00:35:13,040
new chromosomes uh for john's kids

00:35:10,320 --> 00:35:14,000
there are new individuals that don't

00:35:13,040 --> 00:35:16,800
look like

00:35:14,000 --> 00:35:17,200
john or dad or john's dad or john's mom

00:35:16,800 --> 00:35:20,160
not

00:35:17,200 --> 00:35:21,280
like clones it's like a new a new set of

00:35:20,160 --> 00:35:24,480
dna

00:35:21,280 --> 00:35:26,240
there's this absolutely jaw-dropping

00:35:24,480 --> 00:35:26,640
mind-blowing phenomenon that's called

00:35:26,240 --> 00:35:29,760
the

00:35:26,640 --> 00:35:32,800
crossing over um that

00:35:29,760 --> 00:35:34,320
consists in bending chromosomes around

00:35:32,800 --> 00:35:37,920
one another

00:35:34,320 --> 00:35:41,040
and sort of break them in order

00:35:37,920 --> 00:35:44,480
to uh to pick either

00:35:41,040 --> 00:35:45,119
a gene from john's dad or from john's

00:35:44,480 --> 00:35:47,440
mom

00:35:45,119 --> 00:35:48,880
or either gene or like a set of

00:35:47,440 --> 00:35:52,000
nucleotides or like a

00:35:48,880 --> 00:35:55,040
bit of dna so what it does

00:35:52,000 --> 00:35:58,400
is that for every corresponding pair

00:35:55,040 --> 00:36:01,359
from the two chromosomes it either

00:35:58,400 --> 00:36:03,040
keeps them in the same order or swap

00:36:01,359 --> 00:36:04,880
them around

00:36:03,040 --> 00:36:06,960
right and it does that repeatedly for

00:36:04,880 --> 00:36:09,760
every pair of

00:36:06,960 --> 00:36:09,760
dna junk

00:36:10,400 --> 00:36:17,280
now let's try and and code that

00:36:15,200 --> 00:36:19,680
right let's say and represent that with

00:36:17,280 --> 00:36:21,599
code let's say that we're working in bio

00:36:19,680 --> 00:36:24,640
thematics or something like that

00:36:21,599 --> 00:36:26,800
informatics um

00:36:24,640 --> 00:36:30,160
how would we do that or if we if we do

00:36:26,800 --> 00:36:31,760
that with pipes how would we do that

00:36:30,160 --> 00:36:34,000
well we need to associate two

00:36:31,760 --> 00:36:37,200
chromosomes so we can

00:36:34,000 --> 00:36:40,000
we think of mux and then we've got

00:36:37,200 --> 00:36:41,680
so marx is going to provide every pair

00:36:40,000 --> 00:36:44,800
of chromosomes and we said that we

00:36:41,680 --> 00:36:45,520
would i we either want to leave them the

00:36:44,800 --> 00:36:49,119
way they are

00:36:45,520 --> 00:36:50,960
or to swap them around so we're going to

00:36:49,119 --> 00:36:52,320
point them to this transform function i

00:36:50,960 --> 00:36:54,960
would either

00:36:52,320 --> 00:36:55,920
um leave them the way they are all sort

00:36:54,960 --> 00:36:58,160
of around

00:36:55,920 --> 00:36:59,119
and then we can pipe the results unzip

00:36:58,160 --> 00:37:00,880
in order to

00:36:59,119 --> 00:37:03,520
break them apart and have two

00:37:00,880 --> 00:37:07,119
chromosomes to two for two potential

00:37:03,520 --> 00:37:10,320
uh kids the function

00:37:07,119 --> 00:37:11,920
to uh do that would be either to dig

00:37:10,320 --> 00:37:12,480
them the way they are or sort them

00:37:11,920 --> 00:37:15,359
around

00:37:12,480 --> 00:37:18,079
randomly let's assume we've got a random

00:37:15,359 --> 00:37:21,440
number generator

00:37:18,079 --> 00:37:22,240
and that's about it and if we test that

00:37:21,440 --> 00:37:24,960
program

00:37:22,240 --> 00:37:25,440
if we represent chromosome with strings

00:37:24,960 --> 00:37:28,640
and

00:37:25,440 --> 00:37:32,400
genes with um characters with t

00:37:28,640 --> 00:37:35,119
coming from dad and m coming from mom

00:37:32,400 --> 00:37:36,079
and we are producing two set of chrome

00:37:35,119 --> 00:37:38,560
two chromosomes

00:37:36,079 --> 00:37:40,000
so two set of genes uh we can just mix

00:37:38,560 --> 00:37:42,320
and transform them unzip

00:37:40,000 --> 00:37:44,880
and um and that's it and we can print

00:37:42,320 --> 00:37:48,240
them out if we test that program on one

00:37:44,880 --> 00:37:51,599
run it it gave fats

00:37:48,240 --> 00:37:55,200
right so this is a sort of simulation

00:37:51,599 --> 00:37:56,160
of a crossing over um in a declarative

00:37:55,200 --> 00:37:59,040
way

00:37:56,160 --> 00:37:59,040
current way yeah

00:38:01,599 --> 00:38:09,359
mux is one way to associate

00:38:05,440 --> 00:38:11,119
collections together um if we um

00:38:09,359 --> 00:38:12,640
just for the sake of the example we

00:38:11,119 --> 00:38:16,000
directly print out

00:38:12,640 --> 00:38:18,079
the results through the see out stream

00:38:16,000 --> 00:38:20,720
for example with those pipes

00:38:18,079 --> 00:38:23,280
it lets us experiment with other pipes

00:38:20,720 --> 00:38:26,160
so other than mux we can

00:38:23,280 --> 00:38:27,680
combine the two collections to create

00:38:26,160 --> 00:38:29,440
all possible combinations between the

00:38:27,680 --> 00:38:31,520
two collections

00:38:29,440 --> 00:38:33,440
right with cartesian products and still

00:38:31,520 --> 00:38:36,560
using note of all

00:38:33,440 --> 00:38:38,800
or we can create all the

00:38:36,560 --> 00:38:40,160
combination between two elements of the

00:38:38,800 --> 00:38:43,440
same collections

00:38:40,160 --> 00:38:47,359
same collection or

00:38:43,440 --> 00:38:50,240
we could um iterates

00:38:47,359 --> 00:38:51,839
over a collection uh by taking the

00:38:50,240 --> 00:38:55,280
elements two by two

00:38:51,839 --> 00:38:57,200
like one two then three four then uh

00:38:55,280 --> 00:39:00,960
sorry one two then two three then three

00:38:57,200 --> 00:39:03,839
four uh with this adjacent pipe

00:39:00,960 --> 00:39:07,119
which is horrible to write for the ford

00:39:03,839 --> 00:39:07,119
and still noticeable

00:39:07,520 --> 00:39:13,359
so this is what can come in a pipeline

00:39:11,119 --> 00:39:15,200
and the main point i think is that uh i

00:39:13,359 --> 00:39:17,200
mean the two main points i think is that

00:39:15,200 --> 00:39:19,599
we can pick up results from st

00:39:17,200 --> 00:39:23,040
algorithms such as

00:39:19,599 --> 00:39:25,040
set difference and also that we

00:39:23,040 --> 00:39:26,240
don't have to use tuples to manipulate

00:39:25,040 --> 00:39:29,839
several uh

00:39:26,240 --> 00:39:29,839
several input ranges

00:39:30,320 --> 00:39:33,440
now let's see what can come out of the

00:39:32,720 --> 00:39:37,200
pipeline

00:39:33,440 --> 00:39:40,720
because as as we've seen so far

00:39:37,200 --> 00:39:42,880
we have a sort of ending pipe

00:39:40,720 --> 00:39:44,160
right like push back for example push

00:39:42,880 --> 00:39:46,240
back is extremely simple

00:39:44,160 --> 00:39:48,079
it's just called push back on the

00:39:46,240 --> 00:39:51,599
container it's attached to

00:39:48,079 --> 00:39:52,960
and and and pass passes anything that

00:39:51,599 --> 00:39:56,079
comes its way now

00:39:52,960 --> 00:39:58,800
the thing is push back is at a

00:39:56,079 --> 00:40:00,640
location where we can write codes so

00:39:58,800 --> 00:40:02,880
pushback is simple but what if we could

00:40:00,640 --> 00:40:04,160
write something more elaborate right to

00:40:02,880 --> 00:40:07,520
for example

00:40:04,160 --> 00:40:09,520
handle um complex integrations into

00:40:07,520 --> 00:40:12,560
containers

00:40:09,520 --> 00:40:15,200
so we've got pushback um which is the

00:40:12,560 --> 00:40:18,000
equivalent of backing sata

00:40:15,200 --> 00:40:19,680
but we also have insert which is sort of

00:40:18,000 --> 00:40:22,839
the equivalent of inserter

00:40:19,680 --> 00:40:25,040
and override which is the equivalent of

00:40:22,839 --> 00:40:28,560
again

00:40:25,040 --> 00:40:31,040
now um if you consider insane um

00:40:28,560 --> 00:40:32,400
it's sort of the equivalent of studying

00:40:31,040 --> 00:40:34,480
certain

00:40:32,400 --> 00:40:35,520
because still in turtles it's a bit

00:40:34,480 --> 00:40:38,160
weird

00:40:35,520 --> 00:40:39,119
because it forces you to pass the

00:40:38,160 --> 00:40:41,680
position where

00:40:39,119 --> 00:40:43,520
you'd like to insert data in so if you'd

00:40:41,680 --> 00:40:45,040
like to insert in a vector for example

00:40:43,520 --> 00:40:46,560
that makes sense

00:40:45,040 --> 00:40:48,240
but if you'd like to insert into a

00:40:46,560 --> 00:40:51,680
sorted collection for example

00:40:48,240 --> 00:40:54,560
sets then it doesn't make sense to

00:40:51,680 --> 00:40:55,119
told the set where you want to insert

00:40:54,560 --> 00:40:57,200
because

00:40:55,119 --> 00:40:58,400
it's the set that will choose it that

00:40:57,200 --> 00:41:00,720
that is job

00:40:58,400 --> 00:41:02,160
to make sure that it didn't set at the

00:41:00,720 --> 00:41:04,640
right position i mean you could

00:41:02,160 --> 00:41:05,520
give it a hint but if you don't have a

00:41:04,640 --> 00:41:07,839
hint and

00:41:05,520 --> 00:41:10,000
typically when using an output educator

00:41:07,839 --> 00:41:11,760
we don't have hens

00:41:10,000 --> 00:41:13,359
it doesn't really make sense to write

00:41:11,760 --> 00:41:15,920
something so we we write

00:41:13,359 --> 00:41:17,119
end and perhaps it's a customization

00:41:15,920 --> 00:41:19,520
perhaps it

00:41:17,119 --> 00:41:21,359
doesn't have any impact but it certainly

00:41:19,520 --> 00:41:22,160
has an impact on the code that we write

00:41:21,359 --> 00:41:23,920
because we have to

00:41:22,160 --> 00:41:25,599
write that and read that and that just

00:41:23,920 --> 00:41:28,640
doesn't make sense

00:41:25,599 --> 00:41:29,760
so we can just use pipes inserts that

00:41:28,640 --> 00:41:32,240
just got the right

00:41:29,760 --> 00:41:33,920
does the right thing it accepts the

00:41:32,240 --> 00:41:35,920
hints but it does the right thing if you

00:41:33,920 --> 00:41:39,119
don't pass around the hands

00:41:35,920 --> 00:41:41,440
now if you some reason want to ignore um

00:41:39,119 --> 00:41:43,440
what comes to a pipe you can use devinal

00:41:41,440 --> 00:41:46,240
so imagine we'd like to

00:41:43,440 --> 00:41:47,359
truncate the pipeline and some reason

00:41:46,240 --> 00:41:49,200
ignore

00:41:47,359 --> 00:41:50,720
the second output i've set segregate but

00:41:49,200 --> 00:41:53,440
still benefit from the

00:41:50,720 --> 00:41:55,280
the first two ones we could just use

00:41:53,440 --> 00:41:57,680
devno as in the code

00:41:55,280 --> 00:41:57,680
below

00:41:59,200 --> 00:42:04,640
and so we've seen pushback to insert an

00:42:02,640 --> 00:42:06,240
effector but imagine that you don't have

00:42:04,640 --> 00:42:07,119
a vector but you have a legacy

00:42:06,240 --> 00:42:10,160
collection

00:42:07,119 --> 00:42:13,520
um it would be it would be a shame

00:42:10,160 --> 00:42:16,480
not to use the scl

00:42:13,520 --> 00:42:18,319
or ranges or pipes or any modern

00:42:16,480 --> 00:42:21,440
alternative to work and collection

00:42:18,319 --> 00:42:23,119
just because your destination is some

00:42:21,440 --> 00:42:25,440
legacy code that doesn't have a nice

00:42:23,119 --> 00:42:28,000
interface of pushback for example

00:42:25,440 --> 00:42:29,440
well to work around that you can you can

00:42:28,000 --> 00:42:31,599
just do anything

00:42:29,440 --> 00:42:33,440
uh at the end of the pipeline with the

00:42:31,599 --> 00:42:34,400
for each so far reach for each text

00:42:33,440 --> 00:42:37,359
function

00:42:34,400 --> 00:42:38,079
and applies that and passes what comes

00:42:37,359 --> 00:42:42,079
its way

00:42:38,079 --> 00:42:45,040
to that function so perhaps

00:42:42,079 --> 00:42:46,560
do my custom treatment consists in

00:42:45,040 --> 00:42:48,720
inserting

00:42:46,560 --> 00:42:50,079
data to for example the legacy

00:42:48,720 --> 00:42:52,880
collection which lets you

00:42:50,079 --> 00:42:53,760
have a some part of your code that's

00:42:52,880 --> 00:42:59,760
modern

00:42:53,760 --> 00:43:04,400
even though some of it is still legacy

00:42:59,760 --> 00:43:06,000
now if you consider a map now

00:43:04,400 --> 00:43:07,680
let's take this example of this map

00:43:06,000 --> 00:43:11,280
which has three entries

00:43:07,680 --> 00:43:14,720
and let's let's consider a second map

00:43:11,280 --> 00:43:17,760
which has some entries that have a key

00:43:14,720 --> 00:43:20,400
that's already present in the first map

00:43:17,760 --> 00:43:21,119
um but also keys that are not present in

00:43:20,400 --> 00:43:23,760
the first map

00:43:21,119 --> 00:43:25,040
and the other around and let's say that

00:43:23,760 --> 00:43:30,079
we would like to

00:43:25,040 --> 00:43:32,960
insert the the new entries into my map

00:43:30,079 --> 00:43:34,319
with the stl you it's it's like all

00:43:32,960 --> 00:43:36,800
nothing

00:43:34,319 --> 00:43:38,640
for the keys that are already in my map

00:43:36,800 --> 00:43:42,560
for example if you like to insert

00:43:38,640 --> 00:43:45,760
2 and b2 if there is already 2 and b1

00:43:42,560 --> 00:43:49,520
you can either ignore b2 and

00:43:45,760 --> 00:43:52,160
and keep with b1 or you can replace b1

00:43:49,520 --> 00:43:52,880
with b2 but there's no way there's no

00:43:52,160 --> 00:43:55,359
middle ground

00:43:52,880 --> 00:43:56,720
you can't aggregate b1 and b2 even

00:43:55,359 --> 00:43:59,599
though that's

00:43:56,720 --> 00:44:00,880
often uh what we'd like to do so in this

00:43:59,599 --> 00:44:02,720
case for example let's say we'd like to

00:44:00,880 --> 00:44:04,480
aggregate the strings to concatenate the

00:44:02,720 --> 00:44:06,880
strings

00:44:04,480 --> 00:44:08,960
and we'd like to have 2 and b1 b2 for

00:44:06,880 --> 00:44:12,480
example

00:44:08,960 --> 00:44:16,000
we can use this um

00:44:12,480 --> 00:44:18,560
ending pipe which is map aggregator

00:44:16,000 --> 00:44:19,680
that does just that so you pass it

00:44:18,560 --> 00:44:22,880
destination

00:44:19,680 --> 00:44:26,160
in a way to aggregate values if

00:44:22,880 --> 00:44:28,640
keys match in in our example the values

00:44:26,160 --> 00:44:31,599
to aggregate are just strings

00:44:28,640 --> 00:44:36,880
so it consists in adding them so we can

00:44:31,599 --> 00:44:39,760
just use stud plus for example

00:44:36,880 --> 00:44:40,880
if you compare that with raising that

00:44:39,760 --> 00:44:44,000
manually with

00:44:40,880 --> 00:44:46,720
the for loop for example um this is much

00:44:44,000 --> 00:44:47,359
shorter and arguably more expressive if

00:44:46,720 --> 00:44:49,599
you know

00:44:47,359 --> 00:44:52,319
what map aggregator is obviously because

00:44:49,599 --> 00:44:55,920
it's not standard

00:44:52,319 --> 00:44:56,560
um i think this also comes from the push

00:44:55,920 --> 00:44:59,760
model

00:44:56,560 --> 00:45:02,480
um because there's a

00:44:59,760 --> 00:45:03,280
position in the pipeline to pick up the

00:45:02,480 --> 00:45:05,440
result that

00:45:03,280 --> 00:45:07,839
come from the rest of the pipeline and

00:45:05,440 --> 00:45:11,040
to do something with them

00:45:07,839 --> 00:45:19,839
before before inserting them into a

00:45:11,040 --> 00:45:19,839
their final destination like a map

00:45:20,640 --> 00:45:27,280
we've seen quite a few strengths

00:45:24,079 --> 00:45:29,680
of the push model and um

00:45:27,280 --> 00:45:30,960
the pipes library in particular but that

00:45:29,680 --> 00:45:33,920
wouldn't be fair

00:45:30,960 --> 00:45:34,720
if we didn't see some of its limitations

00:45:33,920 --> 00:45:37,839
because

00:45:34,720 --> 00:45:40,800
uh pipes and the push model

00:45:37,839 --> 00:45:42,319
have a design just like everything else

00:45:40,800 --> 00:45:43,680
which means that they have trade-offs

00:45:42,319 --> 00:45:44,640
which mean that there are things that

00:45:43,680 --> 00:45:48,640
they do well

00:45:44,640 --> 00:45:48,640
and things they don't do as well

00:45:48,960 --> 00:45:52,160
for one thing pipes don't know what's

00:45:50,800 --> 00:45:54,160
coming next

00:45:52,160 --> 00:45:55,200
in our codes if you remember go back to

00:45:54,160 --> 00:45:58,319
the code

00:45:55,200 --> 00:45:58,960
in our implementation of transform we've

00:45:58,319 --> 00:46:02,480
got

00:45:58,960 --> 00:46:05,040
this value coming in to on receive

00:46:02,480 --> 00:46:05,920
uh but you just know what's going in

00:46:05,040 --> 00:46:08,000
right now

00:46:05,920 --> 00:46:09,760
and you don't know what's coming next or

00:46:08,000 --> 00:46:13,040
if anything is going to come

00:46:09,760 --> 00:46:14,800
after that so

00:46:13,040 --> 00:46:17,280
um this makes it more difficult to

00:46:14,800 --> 00:46:18,560
implement um reverse for example because

00:46:17,280 --> 00:46:18,880
if you want to reverse you don't know

00:46:18,560 --> 00:46:22,240
where

00:46:18,880 --> 00:46:25,520
when you're finished in order to reverse

00:46:22,240 --> 00:46:28,960
or drop blast which consists in

00:46:25,520 --> 00:46:29,920
uh not pushing the last element because

00:46:28,960 --> 00:46:31,920
you don't know

00:46:29,920 --> 00:46:33,359
when this is the last i mean i don't

00:46:31,920 --> 00:46:34,480
know how to implement those two

00:46:33,359 --> 00:46:36,000
functions with pipes

00:46:34,480 --> 00:46:38,640
perhaps it's possible but i haven't

00:46:36,000 --> 00:46:42,160
found how

00:46:38,640 --> 00:46:44,640
because of the push model and

00:46:42,160 --> 00:46:46,160
pipes don't cache input data i'm not

00:46:44,640 --> 00:46:47,760
sure this is the limitation of the

00:46:46,160 --> 00:46:49,520
push model it's certainly a limited

00:46:47,760 --> 00:46:52,640
enough pipe of

00:46:49,520 --> 00:46:56,079
of the pipes library um because um

00:46:52,640 --> 00:46:58,720
since anything can come into a pipe

00:46:56,079 --> 00:47:01,200
it's a template we can't store it

00:46:58,720 --> 00:47:04,800
because we don't know what type it is

00:47:01,200 --> 00:47:07,680
right so

00:47:04,800 --> 00:47:09,760
how can we implement split as in like if

00:47:07,680 --> 00:47:11,839
you have a string and you like to split

00:47:09,760 --> 00:47:13,760
it

00:47:11,839 --> 00:47:15,680
according to the comments for example

00:47:13,760 --> 00:47:16,480
spaces i don't know how to do that with

00:47:15,680 --> 00:47:18,240
pipes

00:47:16,480 --> 00:47:20,400
even though we can do that which ranges

00:47:18,240 --> 00:47:23,200
and we can also do reverse and droplets

00:47:20,400 --> 00:47:26,720
last with ranges

00:47:23,200 --> 00:47:29,760
um when we build

00:47:26,720 --> 00:47:32,480
a pipeline we can build it bit by bit

00:47:29,760 --> 00:47:34,319
right we can build uh a chunk of the

00:47:32,480 --> 00:47:36,800
pipeline and then associate it with

00:47:34,319 --> 00:47:40,000
another chunk and then

00:47:36,800 --> 00:47:42,240
tap in tack in the tank on the

00:47:40,000 --> 00:47:43,280
the end of the pipeline and and keep

00:47:42,240 --> 00:47:46,800
that for a while

00:47:43,280 --> 00:47:49,440
and then later send the inputs but

00:47:46,800 --> 00:47:50,880
when we send the inputs it has to be a

00:47:49,440 --> 00:47:52,800
whole pipeline

00:47:50,880 --> 00:47:54,960
because when you send the inputs they're

00:47:52,800 --> 00:47:56,000
not going to be cached into the pipes

00:47:54,960 --> 00:48:00,160
they're just going to flow

00:47:56,000 --> 00:48:02,240
through so it the pipeline has to end

00:48:00,160 --> 00:48:04,000
right the inputs are not going to end in

00:48:02,240 --> 00:48:05,599
the void i mean it can end with devenor

00:48:04,000 --> 00:48:08,319
but it has to end

00:48:05,599 --> 00:48:11,119
with something so you can't have a

00:48:08,319 --> 00:48:15,839
partial expression with just the inputs

00:48:11,119 --> 00:48:18,079
and a part a sub part of a pipeline

00:48:15,839 --> 00:48:19,119
and as you saw in the in all the

00:48:18,079 --> 00:48:21,920
examples

00:48:19,119 --> 00:48:22,640
we have to create the results beforehand

00:48:21,920 --> 00:48:25,520
unless

00:48:22,640 --> 00:48:26,559
you pipe into a stream like cr for

00:48:25,520 --> 00:48:29,280
example but

00:48:26,559 --> 00:48:31,200
if you're piping to a push back then it

00:48:29,280 --> 00:48:33,760
has to push back to something

00:48:31,200 --> 00:48:34,960
right i mean it could be an r value but

00:48:33,760 --> 00:48:35,760
i don't think that there's a lot of

00:48:34,960 --> 00:48:38,319
purpose to

00:48:35,760 --> 00:48:40,400
um send data to a temporary value that's

00:48:38,319 --> 00:48:42,720
going to be destroyed just after that so

00:48:40,400 --> 00:48:44,160
it makes more sense i think to have an n

00:48:42,720 --> 00:48:46,880
value which is created

00:48:44,160 --> 00:48:48,559
beforehand right so as those ranges that

00:48:46,880 --> 00:48:51,920
can

00:48:48,559 --> 00:48:55,359
create the outputs and

00:48:51,920 --> 00:48:57,920
in the pipeline in the same expression

00:48:55,359 --> 00:48:59,119
with pipes you have to have two

00:48:57,920 --> 00:49:00,240
expressions

00:48:59,119 --> 00:49:02,559
i mean you have to have all the

00:49:00,240 --> 00:49:06,480
containers created beforehand

00:49:02,559 --> 00:49:09,280
or the results now the trade-off

00:49:06,480 --> 00:49:09,839
those trade-offs um i know to have the

00:49:09,280 --> 00:49:12,559
strength

00:49:09,839 --> 00:49:13,599
we've seen um and we start with we

00:49:12,559 --> 00:49:16,720
started with um

00:49:13,599 --> 00:49:19,280
seeing that transform calls only

00:49:16,720 --> 00:49:20,400
one i mean it's called only ones the

00:49:19,280 --> 00:49:21,920
function call

00:49:20,400 --> 00:49:23,520
the function inside the transform is

00:49:21,920 --> 00:49:27,119
called only ones for elements

00:49:23,520 --> 00:49:27,839
which is what we expect we can use r

00:49:27,119 --> 00:49:31,040
values as

00:49:27,839 --> 00:49:34,319
inputs we can branch out uh

00:49:31,040 --> 00:49:35,200
in two direction with t or in um any

00:49:34,319 --> 00:49:38,000
direction with

00:49:35,200 --> 00:49:38,400
fork there's a typo here a fork used to

00:49:38,000 --> 00:49:41,680
be

00:49:38,400 --> 00:49:42,640
called d-max so this is you should read

00:49:41,680 --> 00:49:45,920
fork here

00:49:42,640 --> 00:49:48,559
or you can you can break down a table

00:49:45,920 --> 00:49:48,559
with unzip

00:49:48,880 --> 00:49:54,240
uh we can pick up whatever comes out of

00:49:52,240 --> 00:49:56,880
a nested algorithm such as with the

00:49:54,240 --> 00:49:59,599
example with said difference

00:49:56,880 --> 00:50:00,640
we can have multiple input values uh

00:49:59,599 --> 00:50:05,359
without using

00:50:00,640 --> 00:50:08,880
tuples uh we have a an entry point

00:50:05,359 --> 00:50:10,079
um um towers the end of the pipeline

00:50:08,880 --> 00:50:13,359
where we integrate

00:50:10,079 --> 00:50:13,760
with the destination which allows us to

00:50:13,359 --> 00:50:15,920
do

00:50:13,760 --> 00:50:17,680
elaborate treatments such as map

00:50:15,920 --> 00:50:22,000
aggregator

00:50:17,680 --> 00:50:22,000
and are very easy to implement

00:50:22,319 --> 00:50:27,440
now if you like to implement one because

00:50:25,760 --> 00:50:29,119
yeah they should um the is the term

00:50:27,440 --> 00:50:31,280
difference and quite a few people

00:50:29,119 --> 00:50:32,319
um have already implemented some by some

00:50:31,280 --> 00:50:35,680
pipes and i'm

00:50:32,319 --> 00:50:37,760
very grateful for that you're welcome to

00:50:35,680 --> 00:50:39,680
contribute to the library by sending a

00:50:37,760 --> 00:50:42,720
pr or opening an issue

00:50:39,680 --> 00:50:45,599
in this github repo

00:50:42,720 --> 00:50:46,079
and um actually you can contribute right

00:50:45,599 --> 00:50:49,599
now

00:50:46,079 --> 00:50:52,400
by and so answering a question

00:50:49,599 --> 00:50:53,440
uh imagine we've got this sort of

00:50:52,400 --> 00:50:56,800
pipeline

00:50:53,440 --> 00:50:58,960
right input goes to transform which

00:50:56,800 --> 00:51:00,079
which goes to something like pushback

00:50:58,960 --> 00:51:02,559
for example

00:51:00,079 --> 00:51:04,400
uh an r the result would be a vector

00:51:02,559 --> 00:51:06,960
that has a pushback method or

00:51:04,400 --> 00:51:07,520
r could be a set for example that has an

00:51:06,960 --> 00:51:10,960
insert

00:51:07,520 --> 00:51:13,760
method what do you think of allowing

00:51:10,960 --> 00:51:15,680
this kind of expression right without

00:51:13,760 --> 00:51:16,880
specifying pushback of insert just do

00:51:15,680 --> 00:51:19,040
the right thing if

00:51:16,880 --> 00:51:21,599
it has pushback pushback if it doesn't

00:51:19,040 --> 00:51:22,880
have pushback but it has inserts to

00:51:21,599 --> 00:51:24,480
even though that wouldn't replace the

00:51:22,880 --> 00:51:25,920
first expression the first set of

00:51:24,480 --> 00:51:28,000
expression but

00:51:25,920 --> 00:51:29,680
both would be a load uh what do you

00:51:28,000 --> 00:51:32,720
think is that a good idea or not

00:51:29,680 --> 00:51:36,160
i mean i was like i can't i can't

00:51:32,720 --> 00:51:37,920
ask you i can't see your hands rising um

00:51:36,160 --> 00:51:39,280
in front of your computer but perhaps

00:51:37,920 --> 00:51:42,800
you can um

00:51:39,280 --> 00:51:47,280
just answer in the q and a session

00:51:42,800 --> 00:51:50,000
and all votes avoid a question that

00:51:47,280 --> 00:51:50,640
in a yeah a card in a q a that has an

00:51:50,000 --> 00:51:53,920
answer that

00:51:50,640 --> 00:51:56,880
you would agree with

00:51:53,920 --> 00:51:57,760
and the final question uh it's uh how

00:51:56,880 --> 00:52:01,440
should we call

00:51:57,760 --> 00:52:03,680
this greater risa equal operator because

00:52:01,440 --> 00:52:04,880
greater greater equal is not such a cool

00:52:03,680 --> 00:52:07,599
name so

00:52:04,880 --> 00:52:08,960
what would you like to call it in there

00:52:07,599 --> 00:52:12,559
in the context of

00:52:08,960 --> 00:52:12,559
of a pipeline

00:52:13,280 --> 00:52:19,440
that's it for the presentation

00:52:16,319 --> 00:52:21,839
of pipes and the push model

00:52:19,440 --> 00:52:22,640
i will be happy now to take your

00:52:21,839 --> 00:52:25,839
questions

00:52:22,640 --> 00:52:25,839
uh with a q a

00:52:30,240 --> 00:52:36,400
we've got a question here

00:52:33,280 --> 00:52:37,760
is the pipes library robust and ready

00:52:36,400 --> 00:52:40,880
for use in production

00:52:37,760 --> 00:52:44,160
codes um

00:52:40,880 --> 00:52:47,440
well to the best of my knowledge it is

00:52:44,160 --> 00:52:50,880
i know some people do use it already

00:52:47,440 --> 00:52:53,280
um it has a fairly strong set of

00:52:50,880 --> 00:52:55,680
tests as you can see in the in the

00:52:53,280 --> 00:52:59,119
github repo

00:52:55,680 --> 00:53:02,400
and um i've used part of it in

00:52:59,119 --> 00:53:05,520
my own production code as well so i said

00:53:02,400 --> 00:53:05,520
you can have go ahead yeah

00:53:06,000 --> 00:53:13,200
now that that's a um it's still

00:53:09,520 --> 00:53:16,559
i mean it can still evolve right um it

00:53:13,200 --> 00:53:18,720
i think it's a fairly new

00:53:16,559 --> 00:53:21,040
concept i mean at least for me it's

00:53:18,720 --> 00:53:22,480
fairly new it's just been a few years

00:53:21,040 --> 00:53:25,680
uh a couple of years i've been working

00:53:22,480 --> 00:53:28,160
on that so um i'm still welcoming

00:53:25,680 --> 00:53:30,880
um suggestions and make it evolve so it

00:53:28,160 --> 00:53:30,880
can change

00:53:30,960 --> 00:53:38,240
um is pipes allowed to be lazy

00:53:34,240 --> 00:53:42,240
also um

00:53:38,240 --> 00:53:46,000
let me think would you mind lazy because

00:53:42,240 --> 00:53:46,960
um i mean pipes don't cache data they

00:53:46,000 --> 00:53:50,400
would process

00:53:46,960 --> 00:53:52,640
everything that come that way so um

00:53:50,400 --> 00:53:53,680
i'm not sure that would make sense in

00:53:52,640 --> 00:53:57,839
that particular model

00:53:53,680 --> 00:53:57,839
unless i'm missing anything

00:54:01,040 --> 00:54:07,040
how efficient is the pipes library

00:54:04,160 --> 00:54:09,280
does it make copies of inputs if my

00:54:07,040 --> 00:54:10,079
input is a vector of a complicated class

00:54:09,280 --> 00:54:12,800
and my function

00:54:10,079 --> 00:54:15,359
is cpu intensive how does the

00:54:12,800 --> 00:54:18,480
performance compare

00:54:15,359 --> 00:54:21,280
well i um to compare

00:54:18,480 --> 00:54:22,400
i think it's fair to compare with st

00:54:21,280 --> 00:54:26,319
algorithms

00:54:22,400 --> 00:54:29,200
and ranges uh for them

00:54:26,319 --> 00:54:30,240
the the features they have in common for

00:54:29,200 --> 00:54:33,920
example transform

00:54:30,240 --> 00:54:36,640
and filter um i um i hadn't had such

00:54:33,920 --> 00:54:39,760
comparison comparisons in the past

00:54:36,640 --> 00:54:43,599
and um they were in the same ballpark

00:54:39,760 --> 00:54:45,599
depending on the use cases um

00:54:43,599 --> 00:54:47,200
but sometimes there would be ranges that

00:54:45,599 --> 00:54:48,480
would be faster sometimes five that

00:54:47,200 --> 00:54:49,839
would be faster

00:54:48,480 --> 00:54:51,760
sometimes yes they're algorithms to be

00:54:49,839 --> 00:54:55,040
faster but um

00:54:51,760 --> 00:54:56,880
the fact that uh pipe is never

00:54:55,040 --> 00:54:58,480
calling the transform function several

00:54:56,880 --> 00:55:00,880
times certainly helps

00:54:58,480 --> 00:55:02,400
and also the fact that um it doesn't

00:55:00,880 --> 00:55:06,319
have to allocate

00:55:02,400 --> 00:55:08,640
um intermediary collections to work on

00:55:06,319 --> 00:55:10,960
on the intermediary results also house

00:55:08,640 --> 00:55:10,960
as well

00:55:12,319 --> 00:55:16,000
what are some advantages of the pool

00:55:14,559 --> 00:55:21,839
model in ranges

00:55:16,000 --> 00:55:21,839
version versus the push model in pipes

00:55:22,400 --> 00:55:27,920
um let me think of that

00:55:29,440 --> 00:55:35,680
yeah well some advantages

00:55:32,559 --> 00:55:37,920
of the pool model corresponds to

00:55:35,680 --> 00:55:39,280
the limitation of mention of the push

00:55:37,920 --> 00:55:42,160
model for example

00:55:39,280 --> 00:55:43,760
um with a range you know when it's end

00:55:42,160 --> 00:55:45,760
when it ends so you have more control

00:55:43,760 --> 00:55:48,240
and you can do more things like reverse

00:55:45,760 --> 00:55:51,599
droplets for example

00:55:48,240 --> 00:55:53,599
also one thing i haven't mentioned um

00:55:51,599 --> 00:55:55,440
now now that you make me think of it is

00:55:53,599 --> 00:55:58,240
that if you want to implement

00:55:55,440 --> 00:55:58,880
the equivalent of uh algorithm that

00:55:58,240 --> 00:56:01,599
takes

00:55:58,880 --> 00:56:02,079
that takes several inputs let's take an

00:56:01,599 --> 00:56:04,240
example

00:56:02,079 --> 00:56:05,520
imagine set difference i always come

00:56:04,240 --> 00:56:06,720
back to said difference because it's my

00:56:05,520 --> 00:56:09,200
favorite algorithm

00:56:06,720 --> 00:56:10,319
but imagine set difference right if

00:56:09,200 --> 00:56:13,440
you'd like to

00:56:10,319 --> 00:56:15,839
um to model

00:56:13,440 --> 00:56:17,440
set difference as a component in a

00:56:15,839 --> 00:56:19,680
pipeline

00:56:17,440 --> 00:56:20,559
well if you do that with ranges you can

00:56:19,680 --> 00:56:22,640
have

00:56:20,559 --> 00:56:24,160
some sort of like range adapter that

00:56:22,640 --> 00:56:27,440
takes two

00:56:24,160 --> 00:56:30,799
input ranges and when you

00:56:27,440 --> 00:56:32,640
read that adapter it would um give you

00:56:30,799 --> 00:56:33,920
the next element that would come out of

00:56:32,640 --> 00:56:36,559
set difference

00:56:33,920 --> 00:56:38,079
right and this is something that

00:56:36,559 --> 00:56:41,440
actually exists

00:56:38,079 --> 00:56:43,359
in the ranges in the range of e3 library

00:56:41,440 --> 00:56:44,880
now if you think about how to implement

00:56:43,359 --> 00:56:48,799
that with pipes

00:56:44,880 --> 00:56:52,079
um this is way more difficult because

00:56:48,799 --> 00:56:55,280
it would mean that you'd have

00:56:52,079 --> 00:56:58,400
two pipes um joining

00:56:55,280 --> 00:56:59,359
somehow right and this is not specific

00:56:58,400 --> 00:57:01,280
to set difference

00:56:59,359 --> 00:57:02,960
in the general case or where you'd like

00:57:01,280 --> 00:57:06,319
to have uh two

00:57:02,960 --> 00:57:09,520
pipes or two pipelines um somehow

00:57:06,319 --> 00:57:11,520
joining and then um

00:57:09,520 --> 00:57:13,119
potentially breaking out again or

00:57:11,520 --> 00:57:17,359
joining back again

00:57:13,119 --> 00:57:18,400
um then um i don't know how to do that i

00:57:17,359 --> 00:57:20,319
mean in a simple way

00:57:18,400 --> 00:57:22,240
i mean i wouldn't i i think i thought

00:57:20,319 --> 00:57:25,520
about that because um

00:57:22,240 --> 00:57:26,000
uh this question has already um i've

00:57:25,520 --> 00:57:29,359
been brought

00:57:26,000 --> 00:57:32,400
up with pipes but um

00:57:29,359 --> 00:57:35,280
uh i wouldn't know how to write it

00:57:32,400 --> 00:57:36,079
in terms of syntax in terms of um of

00:57:35,280 --> 00:57:38,240
client code

00:57:36,079 --> 00:57:39,599
using the pipes library how would you

00:57:38,240 --> 00:57:42,799
write pipes

00:57:39,599 --> 00:57:45,920
that join together i don't know

00:57:42,799 --> 00:57:48,799
and i consider that a limitation

00:57:45,920 --> 00:57:50,079
even though i haven't come across any

00:57:48,799 --> 00:57:55,599
production use case

00:57:50,079 --> 00:57:58,880
um that would mean that

00:57:55,599 --> 00:58:02,559
does it support parallel execution well

00:57:58,880 --> 00:58:05,119
um it depends on what sort of

00:58:02,559 --> 00:58:07,200
use case i think one great use case that

00:58:05,119 --> 00:58:10,880
the library does not support

00:58:07,200 --> 00:58:15,359
now is um with the fork pipe

00:58:10,880 --> 00:58:18,880
um i would love to see the fork pipe

00:58:15,359 --> 00:58:22,960
um um spin up perhaps

00:58:18,880 --> 00:58:26,400
a new thread uh for each of its uh

00:58:22,960 --> 00:58:30,000
outputs so that um

00:58:26,400 --> 00:58:30,480
uh every every branch coming out of the

00:58:30,000 --> 00:58:33,520
fork

00:58:30,480 --> 00:58:34,319
pipe would run in parallel uh with for

00:58:33,520 --> 00:58:38,799
example

00:58:34,319 --> 00:58:40,559
a task um but i haven't implemented it

00:58:38,799 --> 00:58:42,720
i'm not sure how to implement it to be

00:58:40,559 --> 00:58:51,839
honest and i would welcome

00:58:42,720 --> 00:58:51,839
contributions in that direction

00:58:52,240 --> 00:58:58,000
how does pipe push model compare

00:58:55,520 --> 00:58:58,720
to other libraries that implement this

00:58:58,000 --> 00:59:02,960
style

00:58:58,720 --> 00:59:07,920
like rx cpp the reactive extensions to c

00:59:02,960 --> 00:59:10,559
plus well i'm not an expert in rx cpp i

00:59:07,920 --> 00:59:12,400
certainly looked it up to so to see how

00:59:10,559 --> 00:59:15,839
it compared these vibes

00:59:12,400 --> 00:59:18,480
my understanding is that

00:59:15,839 --> 00:59:20,400
one thing that they have in common is

00:59:18,480 --> 00:59:23,040
that they use a push model like you

00:59:20,400 --> 00:59:23,839
suggesting but one thing that's

00:59:23,040 --> 00:59:27,119
different

00:59:23,839 --> 00:59:28,480
is that a pipe break out into several

00:59:27,119 --> 00:59:31,839
directions

00:59:28,480 --> 00:59:33,119
um the pipes project started as an

00:59:31,839 --> 00:59:35,280
experiment

00:59:33,119 --> 00:59:37,119
for the push model and everything you've

00:59:35,280 --> 00:59:41,359
seen that talk

00:59:37,119 --> 00:59:43,280
so it's a i mean some of the things you

00:59:41,359 --> 00:59:45,680
saw in that talk are not

00:59:43,280 --> 00:59:47,359
present in rx cpp to the best of my

00:59:45,680 --> 00:59:48,720
knowledge

00:59:47,359 --> 00:59:51,200
and the other way around i mean i'm not

00:59:48,720 --> 00:59:52,240
experts in rx cpp but i'm sure that our

00:59:51,200 --> 00:59:54,799
xp does a lot

00:59:52,240 --> 00:59:55,680
a lot more things than pipes i mean rx

00:59:54,799 --> 00:59:58,640
cpp

00:59:55,680 --> 01:00:00,079
um as far as i understand is um is more

00:59:58,640 --> 01:00:03,599
oriented

01:00:00,079 --> 01:00:06,319
around handling events as opposed to

01:00:03,599 --> 01:00:08,640
values in a collection i think that the

01:00:06,319 --> 01:00:12,720
purpose is not the same

01:00:08,640 --> 01:00:14,799
i think that's more like a

01:00:12,720 --> 01:00:16,079
theoretical difference but in a concrete

01:00:14,799 --> 01:00:18,559
difference you've got different use

01:00:16,079 --> 01:00:18,559
cases

01:00:19,760 --> 01:00:23,839
okay that was our last question thank

01:00:22,640 --> 01:00:29,839
you so much for

01:00:23,839 --> 01:00:29,839
being here bye-bye

01:00:45,839 --> 01:00:47,920

YouTube URL: https://www.youtube.com/watch?v=oYEpf5A2qrE


