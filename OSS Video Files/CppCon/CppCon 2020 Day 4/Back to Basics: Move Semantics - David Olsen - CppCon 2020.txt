Title: Back to Basics: Move Semantics - David Olsen - CppCon 2020
Publication date: 2020-09-30
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_move_semantics/back_to_basics_move_semantics__david_olsen__cppcon_2020.pdf
---
Move semantics was one of the many powerful additions to C++11, solving several classes of programming problems that had vexed C++ developers for years. But move semantics can be easily misused, and the details are sometimes tricky to get right. This back-to-basics session will give you a solid foundation in move semantics, covering rvalue references, std::move, move constructors, and move assignment operators. More importantly, it will present a set of clear guidelines for when and how to use these tools, and describe some situations where move semantics are most useful. This session will be helpful both for those who are still learning how to write solid, robust C++ code, and for those who already know everything about move semantics and would like a refresher. Attendees will leave this session having learned, among other things, how to read code sprinkled with calls to std::move and how to write classes that behave correctly and efficiently when moved.

---

David Olsen has more than two decades of software development experience in a variety of programming languages and development environments. For the last three years he has been the lead engineer for the PGI C++ compiler at NVIDIA. He is a member of the ISO C++ committee.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,880 --> 00:00:12,559
good afternoon

00:00:09,920 --> 00:00:14,000
i am david olson the team lead for the

00:00:12,559 --> 00:00:16,480
nvidia hpc c

00:00:14,000 --> 00:00:19,760
plus compiler thank you for coming to my

00:00:16,480 --> 00:00:21,760
introduction to move semantics

00:00:19,760 --> 00:00:23,119
let's go back a bunch of years to the

00:00:21,760 --> 00:00:25,760
early aughts

00:00:23,119 --> 00:00:27,920
you are writing an application in c plus

00:00:25,760 --> 00:00:29,840
and you need to do a lot of lookups

00:00:27,920 --> 00:00:31,119
where both the key and the value are

00:00:29,840 --> 00:00:32,880
strings

00:00:31,119 --> 00:00:34,399
you notice that this map class in the

00:00:32,880 --> 00:00:37,440
standard library does

00:00:34,399 --> 00:00:40,160
exactly what you want

00:00:37,440 --> 00:00:41,280
so you start by creating a typedef for

00:00:40,160 --> 00:00:43,520
the exact

00:00:41,280 --> 00:00:45,280
the exact map type that you want which

00:00:43,520 --> 00:00:48,719
is a map from string to string

00:00:45,280 --> 00:00:50,640
named dictionary t then you write a

00:00:48,719 --> 00:00:52,320
function that fills in the dictionary

00:00:50,640 --> 00:00:53,920
using information you extract from a

00:00:52,320 --> 00:00:55,840
database

00:00:53,920 --> 00:00:57,360
because stud map is a value type that

00:00:55,840 --> 00:00:59,440
can be safely copied

00:00:57,360 --> 00:01:00,879
your function returns the dictionary by

00:00:59,440 --> 00:01:02,559
value

00:01:00,879 --> 00:01:04,320
next you write the code that uses the

00:01:02,559 --> 00:01:06,479
dictionary

00:01:04,320 --> 00:01:07,600
you need a couple different dictionaries

00:01:06,479 --> 00:01:09,200
but you don't need them

00:01:07,600 --> 00:01:11,200
at the same time so you have one

00:01:09,200 --> 00:01:12,000
dictionary variable that gets assigned

00:01:11,200 --> 00:01:14,159
different values

00:01:12,000 --> 00:01:16,000
in various places in the business logic

00:01:14,159 --> 00:01:18,000
function

00:01:16,000 --> 00:01:20,479
your program works great this c plus

00:01:18,000 --> 00:01:22,560
plus standard library is really useful

00:01:20,479 --> 00:01:23,600
but then an important user with lots of

00:01:22,560 --> 00:01:25,520
data complains

00:01:23,600 --> 00:01:28,000
that it is too slow and you need to

00:01:25,520 --> 00:01:30,000
figure out why

00:01:28,000 --> 00:01:32,000
the slowness comes from the two lines of

00:01:30,000 --> 00:01:36,000
code where a dictionary is returned from

00:01:32,000 --> 00:01:38,079
a function and assigned to a variable

00:01:36,000 --> 00:01:40,640
a copy of the dictionary is made while

00:01:38,079 --> 00:01:42,560
returning it from the function

00:01:40,640 --> 00:01:44,159
and then a whole nother copy is made

00:01:42,560 --> 00:01:46,479
while assigning it to the dictionary

00:01:44,159 --> 00:01:48,079
variable that's two copies of this map

00:01:46,479 --> 00:01:50,159
with thousands of entries

00:01:48,079 --> 00:01:52,159
which slows things down and doesn't seem

00:01:50,159 --> 00:01:53,360
necessary

00:01:52,159 --> 00:01:54,960
let's take a look at the assignment

00:01:53,360 --> 00:01:56,560
operator we're ignoring the copy that

00:01:54,960 --> 00:01:57,200
happens during the function return for

00:01:56,560 --> 00:01:58,880
now

00:01:57,200 --> 00:02:01,119
and focusing on just the assignment

00:01:58,880 --> 00:02:02,880
operator this is what things look like

00:02:01,119 --> 00:02:04,479
after the function returns before the

00:02:02,880 --> 00:02:06,159
assignment operator starts

00:02:04,479 --> 00:02:08,000
stood map is usually implemented as a

00:02:06,159 --> 00:02:10,160
binary tree so i am representing

00:02:08,000 --> 00:02:11,120
maps here as small trees with key value

00:02:10,160 --> 00:02:12,879
pairs

00:02:11,120 --> 00:02:14,800
the arrows represent pointers the

00:02:12,879 --> 00:02:15,360
dictionary variable has an existing

00:02:14,800 --> 00:02:17,520
value

00:02:15,360 --> 00:02:19,120
represented by the tree on the left the

00:02:17,520 --> 00:02:21,040
return value from the function

00:02:19,120 --> 00:02:23,760
the tree on the right holds the new map

00:02:21,040 --> 00:02:25,360
value

00:02:23,760 --> 00:02:27,360
the first thing the assignment operator

00:02:25,360 --> 00:02:31,599
does is destroy the old value

00:02:27,360 --> 00:02:31,599
which involves freeing a lot of memory

00:02:32,080 --> 00:02:35,440
then the map needs to be copied into the

00:02:34,000 --> 00:02:37,280
dictionary variable

00:02:35,440 --> 00:02:41,440
which means allocating a bunch of memory

00:02:37,280 --> 00:02:41,440
and duplicating the entire tree

00:02:41,599 --> 00:02:45,760
once the map has been copied the return

00:02:43,840 --> 00:02:48,080
value temporary can be destroyed which

00:02:45,760 --> 00:02:49,360
frees all the memory for its tree

00:02:48,080 --> 00:02:50,640
this does not happen as part of the

00:02:49,360 --> 00:02:52,879
assignment operator but happens

00:02:50,640 --> 00:02:55,120
immediately after

00:02:52,879 --> 00:02:56,400
we are left with the dictionary variable

00:02:55,120 --> 00:02:58,879
holding the new value

00:02:56,400 --> 00:02:59,760
which is exactly what we want but you

00:02:58,879 --> 00:03:03,040
may have noticed

00:02:59,760 --> 00:03:05,360
some inefficiencies here in particular

00:03:03,040 --> 00:03:06,720
this copy step looks like wasted effort

00:03:05,360 --> 00:03:08,319
since the old tree is about to be

00:03:06,720 --> 00:03:10,480
destroyed

00:03:08,319 --> 00:03:12,959
let's look now at what we would like the

00:03:10,480 --> 00:03:15,120
assignment operator to do

00:03:12,959 --> 00:03:16,319
go back go back again to before the

00:03:15,120 --> 00:03:18,239
assignment starts

00:03:16,319 --> 00:03:21,680
dictionary has its own value the return

00:03:18,239 --> 00:03:24,080
value temporary object has the new value

00:03:21,680 --> 00:03:26,799
we start by destroying the old value

00:03:24,080 --> 00:03:29,680
there is no way to avoid doing that

00:03:26,799 --> 00:03:31,360
but then rather than copy the tree what

00:03:29,680 --> 00:03:33,440
we really want to happen

00:03:31,360 --> 00:03:34,480
is to move the tree from the return

00:03:33,440 --> 00:03:36,879
value object

00:03:34,480 --> 00:03:39,120
to the dictionary variable have the

00:03:36,879 --> 00:03:41,040
dictionary point to the existing tree

00:03:39,120 --> 00:03:42,879
and change the return value object so it

00:03:41,040 --> 00:03:45,280
doesn't point to anything

00:03:42,879 --> 00:03:46,480
no allocating or freeing memory no

00:03:45,280 --> 00:03:50,319
copying data

00:03:46,480 --> 00:03:50,319
just adjusting a couple pointers

00:03:50,640 --> 00:03:54,959
when that's done we destroy the return

00:03:52,799 --> 00:03:56,480
value temporary object

00:03:54,959 --> 00:03:59,760
but because it doesn't own a tree

00:03:56,480 --> 00:04:02,879
anymore that's essentially a no op

00:03:59,760 --> 00:04:05,040
and we're done the result is the same as

00:04:02,879 --> 00:04:07,599
when the tree was copied

00:04:05,040 --> 00:04:08,720
dictionary correctly holds the new value

00:04:07,599 --> 00:04:11,920
but no copying

00:04:08,720 --> 00:04:13,360
involved the problem is there is no

00:04:11,920 --> 00:04:17,280
practical way to do this

00:04:13,360 --> 00:04:19,519
in c plus 98. the original c

00:04:17,280 --> 00:04:20,959
plus had copy constructors which are

00:04:19,519 --> 00:04:23,040
great and really useful

00:04:20,959 --> 00:04:25,440
but when those copies were expensive

00:04:23,040 --> 00:04:27,520
there was no practical way to optimize

00:04:25,440 --> 00:04:30,320
them

00:04:27,520 --> 00:04:31,040
to solve this problem c plus 11

00:04:30,320 --> 00:04:33,840
introduced

00:04:31,040 --> 00:04:35,440
move semantics where a move constructor

00:04:33,840 --> 00:04:37,520
and move assignment operator

00:04:35,440 --> 00:04:38,880
can transfer ownership of an object's

00:04:37,520 --> 00:04:41,280
resources or

00:04:38,880 --> 00:04:42,880
move from rather than copying the

00:04:41,280 --> 00:04:44,960
resources

00:04:42,880 --> 00:04:46,240
the move constructor and move assignment

00:04:44,960 --> 00:04:49,199
operator are used

00:04:46,240 --> 00:04:49,840
when the source object is an r value not

00:04:49,199 --> 00:04:51,919
only do they

00:04:49,840 --> 00:04:53,120
do they enable much more efficient code

00:04:51,919 --> 00:04:54,960
for some classes

00:04:53,120 --> 00:04:56,400
they enable new functionality that

00:04:54,960 --> 00:05:00,639
wasn't possible in c

00:04:56,400 --> 00:05:02,560
plus plus 98 here's a very quick summary

00:05:00,639 --> 00:05:05,120
of how move semantics work which is also

00:05:02,560 --> 00:05:08,639
the outline for the rest of the talk

00:05:05,120 --> 00:05:11,039
r value references only bind to r values

00:05:08,639 --> 00:05:11,919
stood move turns any expression into an

00:05:11,039 --> 00:05:13,759
r value

00:05:11,919 --> 00:05:16,240
and is used to indicate that you want

00:05:13,759 --> 00:05:17,759
something to be moved from

00:05:16,240 --> 00:05:19,440
move constructors and move assignment

00:05:17,759 --> 00:05:20,800
operators which have an r-value

00:05:19,440 --> 00:05:23,600
reference parameter

00:05:20,800 --> 00:05:24,240
transfer ownership of resources from one

00:05:23,600 --> 00:05:26,800
object

00:05:24,240 --> 00:05:26,800
to another

00:05:30,560 --> 00:05:35,280
the first piece of understanding move

00:05:32,560 --> 00:05:37,120
semantics is r value references

00:05:35,280 --> 00:05:39,360
but before we can talk about r value

00:05:37,120 --> 00:05:42,639
references we need a refresher on

00:05:39,360 --> 00:05:44,720
l values versus r values i could spend a

00:05:42,639 --> 00:05:46,400
whole hour talking about l values and r

00:05:44,720 --> 00:05:46,720
values and value categories and how they

00:05:46,400 --> 00:05:48,800
work

00:05:46,720 --> 00:05:50,479
that would be a different talk for the

00:05:48,800 --> 00:05:52,479
purposes of understanding move semantics

00:05:50,479 --> 00:05:55,520
there's only time for a quick overview

00:05:52,479 --> 00:05:56,080
so to greatly oversimplify things an l

00:05:55,520 --> 00:05:58,000
value

00:05:56,080 --> 00:05:59,840
is something that that can appear on the

00:05:58,000 --> 00:06:03,440
left side of an assignment operator

00:05:59,840 --> 00:06:05,199
that's what the l and l value comes from

00:06:03,440 --> 00:06:06,479
something with a name is usually an l

00:06:05,199 --> 00:06:08,000
value

00:06:06,479 --> 00:06:10,160
and it is something that you can take

00:06:08,000 --> 00:06:10,960
the address of of the three bullets the

00:06:10,160 --> 00:06:13,440
last one about

00:06:10,960 --> 00:06:14,800
addresses is the most reliable if you

00:06:13,440 --> 00:06:17,120
can apply the built-in

00:06:14,800 --> 00:06:19,120
address of operator to something it is

00:06:17,120 --> 00:06:21,280
an l value

00:06:19,120 --> 00:06:22,319
here are four examples of bell values in

00:06:21,280 --> 00:06:24,560
the first one

00:06:22,319 --> 00:06:26,639
the use of the variable var is obviously

00:06:24,560 --> 00:06:27,440
an l value it's on the left hand side of

00:06:26,639 --> 00:06:30,720
an assignment

00:06:27,440 --> 00:06:32,560
it has a name we can take its address

00:06:30,720 --> 00:06:34,800
the const variable hello can't be

00:06:32,560 --> 00:06:36,000
assigned to but it still has a name and

00:06:34,800 --> 00:06:39,520
we can take its address

00:06:36,000 --> 00:06:40,639
so it is still an l value l values don't

00:06:39,520 --> 00:06:44,880
always have names

00:06:40,639 --> 00:06:44,880
the final two l values are expressions

00:06:46,000 --> 00:06:49,360
again to greatly oversimplify things an

00:06:48,400 --> 00:06:52,000
r value

00:06:49,360 --> 00:06:54,000
is anything that is not an l value

00:06:52,000 --> 00:06:56,560
temporary objects and literal constants

00:06:54,000 --> 00:06:57,280
are r values function return values are

00:06:56,560 --> 00:06:58,880
our values

00:06:57,280 --> 00:07:01,039
unless the function return type is now

00:06:58,880 --> 00:07:03,120
value reference

00:07:01,039 --> 00:07:05,199
the results of most built-in operators

00:07:03,120 --> 00:07:06,880
are r values the most common exceptions

00:07:05,199 --> 00:07:07,759
are the d reference operator the array

00:07:06,880 --> 00:07:09,520
sub

00:07:07,759 --> 00:07:11,280
subscript operator and the assignment

00:07:09,520 --> 00:07:14,560
operators whose results are all

00:07:11,280 --> 00:07:15,280
l values r values usually have a short

00:07:14,560 --> 00:07:17,440
lifetime

00:07:15,280 --> 00:07:20,000
they rarely outlive the expression where

00:07:17,440 --> 00:07:21,440
they were created

00:07:20,000 --> 00:07:23,280
l value references are the ones that

00:07:21,440 --> 00:07:25,039
have been in c plus from the beginning

00:07:23,280 --> 00:07:26,400
a non-constant l value reference can

00:07:25,039 --> 00:07:28,319
only bind to an l value

00:07:26,400 --> 00:07:31,199
a constant value reference as shown on

00:07:28,319 --> 00:07:32,560
the bottom can bind to anything

00:07:31,199 --> 00:07:34,319
with all that background out of the way

00:07:32,560 --> 00:07:37,599
we can finally start talking about

00:07:34,319 --> 00:07:39,919
r-value references syntactically

00:07:37,599 --> 00:07:41,520
an r-value reference is indicated by a

00:07:39,919 --> 00:07:44,240
double ampersand

00:07:41,520 --> 00:07:45,599
an l-value reference uses one ampersand

00:07:44,240 --> 00:07:49,199
and r value reference

00:07:45,599 --> 00:07:50,160
uses two in the function declaration

00:07:49,199 --> 00:07:52,720
shown here

00:07:50,160 --> 00:07:53,759
funk has a single parameter named arc

00:07:52,720 --> 00:07:55,840
whose type is

00:07:53,759 --> 00:07:59,280
r value reference to foo often

00:07:55,840 --> 00:08:01,039
pronounced foo ref ref

00:07:59,280 --> 00:08:02,720
so how are the semantics of r-value

00:08:01,039 --> 00:08:04,080
references different from l-value

00:08:02,720 --> 00:08:06,160
references

00:08:04,080 --> 00:08:07,840
most important point is that r-value

00:08:06,160 --> 00:08:10,960
references can only bind

00:08:07,840 --> 00:08:12,160
to r-values if you try to initialize an

00:08:10,960 --> 00:08:15,360
r-value reference with

00:08:12,160 --> 00:08:17,599
l value you'll get a compiler error

00:08:15,360 --> 00:08:20,879
in this example funk's parameter has

00:08:17,599 --> 00:08:23,759
type r-value reference to int

00:08:20,879 --> 00:08:25,680
if we try to pass an l-value to func

00:08:23,759 --> 00:08:29,039
such as an integer variable

00:08:25,680 --> 00:08:31,199
the compiler will complain

00:08:29,039 --> 00:08:32,800
but if we pass our values to func such

00:08:31,199 --> 00:08:35,039
as the int literal 42

00:08:32,800 --> 00:08:36,640
or the return value from a function

00:08:35,039 --> 00:08:39,200
everything works fine

00:08:36,640 --> 00:08:39,680
remember r value references can only

00:08:39,200 --> 00:08:42,479
bind

00:08:39,680 --> 00:08:42,479
to r values

00:08:43,360 --> 00:08:46,480
we talked about how to initialize an r

00:08:45,120 --> 00:08:48,160
value reference

00:08:46,480 --> 00:08:50,240
but what happens when we use an

00:08:48,160 --> 00:08:51,440
identifier that was declared as an r

00:08:50,240 --> 00:08:52,959
value reference

00:08:51,440 --> 00:08:54,720
this is counter-intuitive for some

00:08:52,959 --> 00:08:56,080
people and it took me a while to get

00:08:54,720 --> 00:08:58,560
used to this

00:08:56,080 --> 00:08:59,440
the use of an r-value reference is an

00:08:58,560 --> 00:09:03,440
l-value

00:08:59,440 --> 00:09:03,440
not an r-value an l-value

00:09:03,519 --> 00:09:07,680
both f and g take an r-value reference

00:09:06,320 --> 00:09:10,240
to int parameter

00:09:07,680 --> 00:09:11,839
when we call g with an r value the

00:09:10,240 --> 00:09:15,360
literal 42

00:09:11,839 --> 00:09:18,240
all is good but when we pass g's

00:09:15,360 --> 00:09:20,000
r value reference parameter to f that's

00:09:18,240 --> 00:09:22,000
a compile error

00:09:20,000 --> 00:09:24,000
because the use of the parameter is an l

00:09:22,000 --> 00:09:25,360
value as shown in the error message from

00:09:24,000 --> 00:09:27,519
gcc

00:09:25,360 --> 00:09:28,480
cannot bind r-value reference of type

00:09:27,519 --> 00:09:31,839
int ref ref

00:09:28,480 --> 00:09:31,839
to value of type int

00:09:33,120 --> 00:09:36,720
a general note about guidelines in this

00:09:34,839 --> 00:09:38,640
presentation

00:09:36,720 --> 00:09:40,880
these are guidelines not unbreakable

00:09:38,640 --> 00:09:42,399
rules at some point in your career you

00:09:40,880 --> 00:09:43,839
will run into situations where these

00:09:42,399 --> 00:09:45,120
guidelines don't apply

00:09:43,839 --> 00:09:48,000
but i'm not going to tell you what they

00:09:45,120 --> 00:09:49,760
are if you find that you want to not

00:09:48,000 --> 00:09:53,360
follow one of these guidelines

00:09:49,760 --> 00:09:56,080
one understand what you are doing two

00:09:53,360 --> 00:09:56,399
take responsibility if things go wrong

00:09:56,080 --> 00:09:58,560
and

00:09:56,399 --> 00:10:00,640
three be able to explain to your

00:09:58,560 --> 00:10:02,079
colleagues such as the ones who want to

00:10:00,640 --> 00:10:03,920
reject your code review

00:10:02,079 --> 00:10:06,240
what you are doing and why it is the

00:10:03,920 --> 00:10:09,440
right way to do it

00:10:06,240 --> 00:10:10,160
so now the first guideline no r value

00:10:09,440 --> 00:10:13,600
references

00:10:10,160 --> 00:10:15,279
to constant type well l value references

00:10:13,600 --> 00:10:16,560
to const show up all over the place and

00:10:15,279 --> 00:10:18,720
are very useful

00:10:16,560 --> 00:10:20,480
r value references to const are almost

00:10:18,720 --> 00:10:21,839
completely useless and just get in the

00:10:20,480 --> 00:10:23,680
way

00:10:21,839 --> 00:10:24,880
if you want to define an r-value

00:10:23,680 --> 00:10:27,279
reference

00:10:24,880 --> 00:10:28,560
just leave out the const there are two

00:10:27,279 --> 00:10:30,959
reasons for this

00:10:28,560 --> 00:10:32,480
first most of the time when you define

00:10:30,959 --> 00:10:34,320
an r-value reference

00:10:32,480 --> 00:10:36,320
it's because you want to modify the

00:10:34,320 --> 00:10:38,959
object being referenced

00:10:36,320 --> 00:10:40,959
we'll see lots of examples of that later

00:10:38,959 --> 00:10:42,959
a const r-value reference would prevent

00:10:40,959 --> 00:10:45,200
you from doing that

00:10:42,959 --> 00:10:47,200
the second reason is that r-values

00:10:45,200 --> 00:10:49,200
themselves are almost never const so

00:10:47,200 --> 00:10:50,880
there's almost nothing that a constant r

00:10:49,200 --> 00:10:52,640
value reference can bind to

00:10:50,880 --> 00:10:54,880
that a non-constar value reference

00:10:52,640 --> 00:11:01,200
cannot

00:10:54,880 --> 00:11:03,519
so no const r value references

00:11:01,200 --> 00:11:07,040
the second guideline no r value

00:11:03,519 --> 00:11:09,120
references as function return type

00:11:07,040 --> 00:11:10,720
the c plus core guidelines is a set of

00:11:09,120 --> 00:11:12,560
very useful guidelines for c

00:11:10,720 --> 00:11:14,480
plus programming maintained by bjarna

00:11:12,560 --> 00:11:16,399
straw strip herb sutter

00:11:14,480 --> 00:11:18,399
many of the guidelines that i have here

00:11:16,399 --> 00:11:20,880
for move semantics have an identical or

00:11:18,399 --> 00:11:22,480
similar guideline in the core guidelines

00:11:20,880 --> 00:11:24,480
when that is the case the slides have a

00:11:22,480 --> 00:11:26,800
link to the corresponding core guideline

00:11:24,480 --> 00:11:28,640
i encourage people to follow those links

00:11:26,800 --> 00:11:30,320
because the core guidelines often have a

00:11:28,640 --> 00:11:31,120
more complete explanation of the

00:11:30,320 --> 00:11:33,680
guideline

00:11:31,120 --> 00:11:35,920
than i have time to offer here and there

00:11:33,680 --> 00:11:38,640
are many guidelines for other areas of c

00:11:35,920 --> 00:11:39,760
plus that are well worth following but

00:11:38,640 --> 00:11:42,640
back to our guideline

00:11:39,760 --> 00:11:43,200
back to our guidelines no r value

00:11:42,640 --> 00:11:45,120
reference

00:11:43,200 --> 00:11:47,040
as function return type or as the core

00:11:45,120 --> 00:11:49,920
guidelines put it don't return a t

00:11:47,040 --> 00:11:50,480
ref ref your functions should return by

00:11:49,920 --> 00:11:54,320
value

00:11:50,480 --> 00:11:56,399
instead r value references

00:11:54,320 --> 00:11:58,079
usually bind to temporaries or other

00:11:56,399 --> 00:11:59,680
short-lived objects

00:11:58,079 --> 00:12:02,000
and those temporaries are often

00:11:59,680 --> 00:12:05,519
destroyed before the function returns

00:12:02,000 --> 00:12:07,920
as shown in this example so before you

00:12:05,519 --> 00:12:10,079
can use the r-value reference in any way

00:12:07,920 --> 00:12:11,839
the object that it referred to is

00:12:10,079 --> 00:12:14,000
already gone

00:12:11,839 --> 00:12:16,399
this isn't a compiler error it's worse

00:12:14,000 --> 00:12:18,240
it's undefined behavior

00:12:16,399 --> 00:12:20,160
it might appear to work while you are

00:12:18,240 --> 00:12:22,240
testing your own code

00:12:20,160 --> 00:12:23,680
but then cause strange things to happen

00:12:22,240 --> 00:12:24,240
the first time your most important

00:12:23,680 --> 00:12:28,320
customer

00:12:24,240 --> 00:12:30,320
runs your app a decent compiler will

00:12:28,320 --> 00:12:32,000
warn you about the obvious cases

00:12:30,320 --> 00:12:34,160
but if you get in the habit of never

00:12:32,000 --> 00:12:36,160
returning an r-value reference

00:12:34,160 --> 00:12:39,839
you won't have to rely on the compiler

00:12:36,160 --> 00:12:39,839
to catch your mistakes

00:12:44,399 --> 00:12:48,000
the next area of move semantics that we

00:12:47,040 --> 00:12:50,880
need to talk about

00:12:48,000 --> 00:12:50,880
is stood move

00:12:51,680 --> 00:12:57,279
this is a complete standard conforming

00:12:53,760 --> 00:12:57,279
definition of stood move

00:12:58,399 --> 00:13:03,519
it is a const expert function taking one

00:13:00,560 --> 00:13:04,959
argument of any type or value category

00:13:03,519 --> 00:13:06,720
the type of the parameter looks like

00:13:04,959 --> 00:13:08,079
it's an r value reference but no

00:13:06,720 --> 00:13:09,839
it's a universal reference or a

00:13:08,079 --> 00:13:11,279
forwarding reference which i don't have

00:13:09,839 --> 00:13:13,040
time to explain

00:13:11,279 --> 00:13:14,800
the quick summary is that a universal

00:13:13,040 --> 00:13:17,360
reference can bind to either an

00:13:14,800 --> 00:13:19,440
l value or an r value and can preserve

00:13:17,360 --> 00:13:20,720
the l value-ness or r-value-ness of the

00:13:19,440 --> 00:13:23,200
original object

00:13:20,720 --> 00:13:27,279
so stood move can accept any expression

00:13:23,200 --> 00:13:27,279
of any type or value category

00:13:28,240 --> 00:13:32,399
it returns an r-value reference i know i

00:13:30,720 --> 00:13:33,200
said never to do that just a few slides

00:13:32,399 --> 00:13:35,200
back

00:13:33,200 --> 00:13:37,600
but it works here because stood move is

00:13:35,200 --> 00:13:39,760
returning a reference to its argument

00:13:37,600 --> 00:13:42,160
not to a temporary defined within the

00:13:39,760 --> 00:13:42,160
function

00:13:42,880 --> 00:13:47,440
all the function does is to static cast

00:13:45,199 --> 00:13:50,000
the argument to its corresponding r

00:13:47,440 --> 00:13:52,399
value reference type

00:13:50,000 --> 00:13:53,600
so stood move is just a more convenient

00:13:52,399 --> 00:13:57,199
syntax for doing

00:13:53,600 --> 00:13:57,199
a particular static cast

00:13:57,519 --> 00:14:01,600
that means stood move doesn't actually

00:14:00,160 --> 00:14:04,079
move anything

00:14:01,600 --> 00:14:04,959
it converts any expression into an r

00:14:04,079 --> 00:14:06,959
value

00:14:04,959 --> 00:14:09,360
so it can be bound to an r value

00:14:06,959 --> 00:14:09,360
reference

00:14:14,720 --> 00:14:18,399
so why would you want to convert

00:14:16,240 --> 00:14:20,320
something to an r value

00:14:18,399 --> 00:14:22,320
so that the move constructor or move

00:14:20,320 --> 00:14:22,800
assignment operator or other move aware

00:14:22,320 --> 00:14:24,560
function

00:14:22,800 --> 00:14:27,519
will be called instead of the copy

00:14:24,560 --> 00:14:29,760
constructor or copy assignment operator

00:14:27,519 --> 00:14:31,040
so your object will be moved from which

00:14:29,760 --> 00:14:33,279
can be very efficient

00:14:31,040 --> 00:14:35,839
rather than copied which can be quite

00:14:33,279 --> 00:14:35,839
expensive

00:14:36,480 --> 00:14:40,720
a guideline about when to use stood move

00:14:38,560 --> 00:14:42,720
or when not to use to move

00:14:40,720 --> 00:14:44,480
when an object is an argument to stood

00:14:42,720 --> 00:14:46,639
move the next operation

00:14:44,480 --> 00:14:48,480
on that object after stood move should

00:14:46,639 --> 00:14:51,839
be to destroy the object

00:14:48,480 --> 00:14:53,519
or to descen or to assign it a new value

00:14:51,839 --> 00:14:55,279
assigning a new value can be done with

00:14:53,519 --> 00:14:57,360
the assignment operator or with some

00:14:55,279 --> 00:14:58,800
other function that resets the object to

00:14:57,360 --> 00:15:00,720
a known value

00:14:58,800 --> 00:15:02,880
such as the clear method that standard

00:15:00,720 --> 00:15:05,040
containers have

00:15:02,880 --> 00:15:06,880
when an object has been moved from such

00:15:05,040 --> 00:15:09,279
as when you call stood move

00:15:06,880 --> 00:15:11,040
it has an unknown value don't try to

00:15:09,279 --> 00:15:12,800
access that value

00:15:11,040 --> 00:15:14,800
treat the object as if accessing its

00:15:12,800 --> 00:15:19,279
value or undefined behavior

00:15:14,800 --> 00:15:19,279
until you give it a new well-known value

00:15:20,959 --> 00:15:24,880
here's an example of a correct use of

00:15:22,560 --> 00:15:26,720
stood move the object possible

00:15:24,880 --> 00:15:28,480
will be destroyed at the closing brace

00:15:26,720 --> 00:15:32,720
so moving its resources

00:15:28,480 --> 00:15:32,720
to another object is safe and efficient

00:15:33,360 --> 00:15:37,519
here's an example of assigning to an

00:15:34,959 --> 00:15:40,079
object after it has been moved from

00:15:37,519 --> 00:15:41,600
it is safe to move str into the vector

00:15:40,079 --> 00:15:42,399
because its old value won't be used

00:15:41,600 --> 00:15:44,399
anymore

00:15:42,399 --> 00:15:47,759
the object will be given a new value

00:15:44,399 --> 00:15:47,759
immediately afterwards

00:15:48,639 --> 00:15:52,880
with just a one character change

00:15:50,880 --> 00:15:55,440
changing the simple assignment to a plus

00:15:52,880 --> 00:15:56,880
equals this example becomes a violation

00:15:55,440 --> 00:15:59,519
of the guideline

00:15:56,880 --> 00:16:01,600
the result of of appending to the string

00:15:59,519 --> 00:16:03,920
depends on the existing value of the

00:16:01,600 --> 00:16:03,920
string

00:16:04,480 --> 00:16:08,320
but we shouldn't depend on the value of

00:16:06,320 --> 00:16:11,839
a moved from object

00:16:08,320 --> 00:16:11,839
because the value is unknown

00:16:12,800 --> 00:16:16,480
in this example str is a reference so we

00:16:15,839 --> 00:16:18,959
don't know

00:16:16,480 --> 00:16:20,240
or control the lifetime of the object it

00:16:18,959 --> 00:16:22,079
refers to

00:16:20,240 --> 00:16:24,639
but because it is an r value reference

00:16:22,079 --> 00:16:25,839
we can assume that the object is safe to

00:16:24,639 --> 00:16:28,079
move from

00:16:25,839 --> 00:16:29,440
it is up to the caller of this overload

00:16:28,079 --> 00:16:31,600
of maybe insert

00:16:29,440 --> 00:16:33,600
to guarantee that the string argument is

00:16:31,600 --> 00:16:35,519
safe to be moved from

00:16:33,600 --> 00:16:37,120
if the argument is not safe to be moved

00:16:35,519 --> 00:16:39,440
from the caller

00:16:37,120 --> 00:16:42,160
shouldn't have let it be bound to an r

00:16:39,440 --> 00:16:42,160
value reference

00:16:43,600 --> 00:16:48,560
the other guideline that is specifically

00:16:46,880 --> 00:16:50,720
about stood move is

00:16:48,560 --> 00:16:52,240
don't stood move the return of a local

00:16:50,720 --> 00:16:54,480
variable

00:16:52,240 --> 00:16:56,000
the c plus standard has a special rule

00:16:54,480 --> 00:16:56,880
where certain expressions that would

00:16:56,000 --> 00:17:00,000
normally be l

00:16:56,880 --> 00:17:01,839
values are instead treated as r values

00:17:00,000 --> 00:17:03,519
if the expression of a return statement

00:17:01,839 --> 00:17:04,640
is a local variable or a function

00:17:03,519 --> 00:17:06,720
parameter

00:17:04,640 --> 00:17:08,559
it is treated as an r value when doing

00:17:06,720 --> 00:17:10,079
overload resolution to choose between

00:17:08,559 --> 00:17:11,679
the copy constructor or the move

00:17:10,079 --> 00:17:13,520
constructor

00:17:11,679 --> 00:17:15,280
here's an example to help demonstrate

00:17:13,520 --> 00:17:17,439
when this special rule applies

00:17:15,280 --> 00:17:19,120
so you can understand when not to use

00:17:17,439 --> 00:17:21,039
stood move

00:17:19,120 --> 00:17:22,240
the function func returns a string by

00:17:21,039 --> 00:17:24,079
value

00:17:22,240 --> 00:17:25,760
it has a parameter that takes a string

00:17:24,079 --> 00:17:28,160
by value

00:17:25,760 --> 00:17:30,559
and it defines a local variable of type

00:17:28,160 --> 00:17:30,559
string

00:17:30,640 --> 00:17:33,679
these two uses of the parameter and the

00:17:32,320 --> 00:17:36,080
local variable are l

00:17:33,679 --> 00:17:38,000
values because they are because these

00:17:36,080 --> 00:17:39,760
uses are not in a return statement the

00:17:38,000 --> 00:17:42,160
special rule to treat them as r values

00:17:39,760 --> 00:17:43,520
does not apply

00:17:42,160 --> 00:17:45,120
when the parameter and the local

00:17:43,520 --> 00:17:48,000
variable are used as the return

00:17:45,120 --> 00:17:50,880
expression they are treated as r values

00:17:48,000 --> 00:17:52,320
this is when the special rule kicks in

00:17:50,880 --> 00:17:53,120
and the two highlighted return

00:17:52,320 --> 00:17:54,960
statements

00:17:53,120 --> 00:17:56,160
the move constructor rather than the

00:17:54,960 --> 00:17:58,840
copy constructor

00:17:56,160 --> 00:18:01,520
will be used to initialize the return

00:17:58,840 --> 00:18:03,440
value

00:18:01,520 --> 00:18:05,600
a special rule only applies when the

00:18:03,440 --> 00:18:07,039
return expression is a simple name

00:18:05,600 --> 00:18:09,280
when the return expression is anything

00:18:07,039 --> 00:18:10,240
more complex such as dereferencing a

00:18:09,280 --> 00:18:12,640
pointer

00:18:10,240 --> 00:18:14,559
l values are not converted to r values

00:18:12,640 --> 00:18:16,799
so the return expression at the bottom

00:18:14,559 --> 00:18:18,400
of the example is an l value and the

00:18:16,799 --> 00:18:22,000
copy constructor will be used

00:18:18,400 --> 00:18:22,000
to initialize the return value

00:18:22,240 --> 00:18:26,080
the reason for this rule is that the

00:18:24,160 --> 00:18:27,760
compiler knows that the local variables

00:18:26,080 --> 00:18:29,440
and parameters will be destroyed

00:18:27,760 --> 00:18:30,400
immediately after the return statement

00:18:29,440 --> 00:18:32,240
is executed

00:18:30,400 --> 00:18:33,840
there is no way to use the object in

00:18:32,240 --> 00:18:36,480
between the return statement and

00:18:33,840 --> 00:18:37,360
it's being destroyed so it is safe to be

00:18:36,480 --> 00:18:43,840
moved from

00:18:37,360 --> 00:18:43,840
in this situation

00:18:46,640 --> 00:18:50,240
the last big piece of move semantics is

00:18:49,039 --> 00:18:52,880
move constructors

00:18:50,240 --> 00:18:54,559
and move assignment operators i will go

00:18:52,880 --> 00:18:56,000
over when and how the compiler

00:18:54,559 --> 00:18:57,760
implements these things

00:18:56,000 --> 00:18:59,520
and how you can write a move operation

00:18:57,760 --> 00:19:01,600
yourself followed by a bunch of

00:18:59,520 --> 00:19:04,480
guidelines for how to write well-behaved

00:19:01,600 --> 00:19:04,480
move operations

00:19:05,280 --> 00:19:08,799
to qualify as a move constructor or move

00:19:07,440 --> 00:19:10,720
assignment operator

00:19:08,799 --> 00:19:13,120
the function must be a constructor or

00:19:10,720 --> 00:19:15,120
assignment operator obviously

00:19:13,120 --> 00:19:16,320
and have a single parameter that is an

00:19:15,120 --> 00:19:19,600
r-value reference

00:19:16,320 --> 00:19:21,600
of the class type the example here

00:19:19,600 --> 00:19:23,520
shows valid declarations of a move

00:19:21,600 --> 00:19:25,840
constructor and a move assignment

00:19:23,520 --> 00:19:25,840
operator

00:19:26,400 --> 00:19:31,200
if you don't declare a move constructor

00:19:28,480 --> 00:19:31,520
the compiler will kindly declare one for

00:19:31,200 --> 00:19:33,440
you

00:19:31,520 --> 00:19:35,440
but only if you have not declared any of

00:19:33,440 --> 00:19:37,360
the following a destructor a copy

00:19:35,440 --> 00:19:39,840
constructor a copy assignment operator

00:19:37,360 --> 00:19:41,600
or a move assignment operator

00:19:39,840 --> 00:19:43,760
essentially the compiler will do the

00:19:41,600 --> 00:19:47,280
work of creating the move constructor

00:19:43,760 --> 00:19:49,760
only if it gets to create everything if

00:19:47,280 --> 00:19:51,520
it wants to do everything or nothing

00:19:49,760 --> 00:19:52,080
remember this because it will show up in

00:19:51,520 --> 00:19:56,240
a guideline

00:19:52,080 --> 00:19:58,160
later on even if the compiler

00:19:56,240 --> 00:19:59,919
doesn't declare a move constructor for

00:19:58,160 --> 00:20:01,520
you you can still request

00:19:59,919 --> 00:20:03,760
the default implementation of a move

00:20:01,520 --> 00:20:06,559
constructor using the equals default

00:20:03,760 --> 00:20:08,559
syntax just like for many other special

00:20:06,559 --> 00:20:10,240
member functions

00:20:08,559 --> 00:20:12,080
if the move constructor is implicitly

00:20:10,240 --> 00:20:14,000
declared or if you explicitly request

00:20:12,080 --> 00:20:16,000
the default implementation

00:20:14,000 --> 00:20:18,159
the compiler will generate a move

00:20:16,000 --> 00:20:20,400
constructor that move constructs

00:20:18,159 --> 00:20:22,799
all of the base classes and non-static

00:20:20,400 --> 00:20:24,720
data members of the object

00:20:22,799 --> 00:20:25,840
if any of those sub-objects can't be

00:20:24,720 --> 00:20:27,840
moved constructed

00:20:25,840 --> 00:20:28,960
such as if one of them has a private

00:20:27,840 --> 00:20:31,039
move constructor

00:20:28,960 --> 00:20:32,159
or a deleted copy constructor and move

00:20:31,039 --> 00:20:33,679
constructor

00:20:32,159 --> 00:20:37,200
then the move constructor will be

00:20:33,679 --> 00:20:37,200
defined as deleted

00:20:41,440 --> 00:20:46,000
the move assignment operator is similar

00:20:43,760 --> 00:20:47,679
to the move constructor

00:20:46,000 --> 00:20:49,360
if you don't declare a move assignment

00:20:47,679 --> 00:20:50,720
operator the compiler will declare one

00:20:49,360 --> 00:20:52,159
for you but only if you have not

00:20:50,720 --> 00:20:53,919
declared any of the following

00:20:52,159 --> 00:20:58,000
destructor copy constructor copy

00:20:53,919 --> 00:20:58,000
assignment operator or move constructor

00:20:58,720 --> 00:21:02,400
if the movement assignment operator is

00:21:00,480 --> 00:21:04,159
implicitly declared or for you

00:21:02,400 --> 00:21:05,440
explicitly requested the default

00:21:04,159 --> 00:21:06,799
implementation

00:21:05,440 --> 00:21:08,400
the compiler will generate a move

00:21:06,799 --> 00:21:10,159
assignment operator that move assigns

00:21:08,400 --> 00:21:11,440
all the base classes and non-static data

00:21:10,159 --> 00:21:12,960
members of the object

00:21:11,440 --> 00:21:15,520
if any of those sub-objects can't be

00:21:12,960 --> 00:21:17,360
moved assigned such as if a data member

00:21:15,520 --> 00:21:19,200
is a reference type or has a private

00:21:17,360 --> 00:21:21,280
move assignment operator then the move

00:21:19,200 --> 00:21:23,840
assignment operator will be defined as

00:21:21,280 --> 00:21:23,840
deleted

00:21:26,640 --> 00:21:30,880
i have one of the questions when should

00:21:29,200 --> 00:21:31,679
i apply the rule of zero and when the

00:21:30,880 --> 00:21:35,039
rule of

00:21:31,679 --> 00:21:36,080
six that will be covered a few slides

00:21:35,039 --> 00:21:39,840
down

00:21:36,080 --> 00:21:39,840
very specifically that is a guideline

00:21:41,600 --> 00:21:45,360
now for the most important section of

00:21:43,360 --> 00:21:47,200
this presentation

00:21:45,360 --> 00:21:50,960
how do you write a well-behaved move

00:21:47,200 --> 00:21:53,280
constructor or move assignment operator

00:21:50,960 --> 00:21:54,559
the task of a move constructor is to

00:21:53,280 --> 00:21:57,760
transfer ownership

00:21:54,559 --> 00:21:59,840
of that object's resources

00:21:57,760 --> 00:22:02,640
from the source object to the object

00:21:59,840 --> 00:22:04,880
being constructed

00:22:02,640 --> 00:22:07,200
any parts of the object that are just

00:22:04,880 --> 00:22:09,440
values that don't represent ownership

00:22:07,200 --> 00:22:10,880
such as an int or a double should just

00:22:09,440 --> 00:22:13,120
be copied

00:22:10,880 --> 00:22:14,559
but anything that is a handle to some

00:22:13,120 --> 00:22:16,320
external resource

00:22:14,559 --> 00:22:18,320
such as a pointer to memory that the

00:22:16,320 --> 00:22:19,280
object has the responsibility to free at

00:22:18,320 --> 00:22:21,840
some point

00:22:19,280 --> 00:22:23,039
or an open file descriptor or a stud

00:22:21,840 --> 00:22:25,120
thread object

00:22:23,039 --> 00:22:27,039
for those things the move constructor

00:22:25,120 --> 00:22:28,880
should transfer ownership

00:22:27,039 --> 00:22:31,120
so that the newly constructed object

00:22:28,880 --> 00:22:34,320
owns them and the moved from

00:22:31,120 --> 00:22:36,240
object no longer owns them if the

00:22:34,320 --> 00:22:37,840
sub-object has a move constructor that

00:22:36,240 --> 00:22:39,520
does the right thing

00:22:37,840 --> 00:22:41,760
take advantage of that and call the

00:22:39,520 --> 00:22:42,960
sub-object's move constructor

00:22:41,760 --> 00:22:45,200
if there isn't a correct move

00:22:42,960 --> 00:22:46,720
constructor available you will have to

00:22:45,200 --> 00:22:47,919
transfer ownership of the resource

00:22:46,720 --> 00:22:50,080
explicitly

00:22:47,919 --> 00:22:55,280
how to do that varies depending on what

00:22:50,080 --> 00:22:57,520
the resource is

00:22:55,280 --> 00:22:59,280
here's an example of a class where the

00:22:57,520 --> 00:23:02,480
only data members are an int

00:22:59,280 --> 00:23:03,760
and a string the move constructor can

00:23:02,480 --> 00:23:04,720
just call the data member's move

00:23:03,760 --> 00:23:06,320
constructors

00:23:04,720 --> 00:23:08,000
we force the use of the sub-object's

00:23:06,320 --> 00:23:11,280
move constructors by using stood

00:23:08,000 --> 00:23:12,960
move for the int the move constructor is

00:23:11,280 --> 00:23:14,480
identical to the copy constructor it

00:23:12,960 --> 00:23:16,480
just copies the bits

00:23:14,480 --> 00:23:18,000
so for the int we could get away without

00:23:16,480 --> 00:23:19,919
calling stud move

00:23:18,000 --> 00:23:21,200
but i encourage you to call stood move

00:23:19,919 --> 00:23:23,120
anyway

00:23:21,200 --> 00:23:25,600
it better expresses the intent of the

00:23:23,120 --> 00:23:27,039
code and doesn't cost anything at run

00:23:25,600 --> 00:23:29,200
time

00:23:27,039 --> 00:23:30,320
the use of stood move for the string is

00:23:29,200 --> 00:23:32,799
necessary

00:23:30,320 --> 00:23:34,320
without it the strings copy constructor

00:23:32,799 --> 00:23:37,840
would be called instead

00:23:34,320 --> 00:23:37,840
and that's not what we want here

00:23:38,400 --> 00:23:42,480
the constructor that we wrote just calls

00:23:40,559 --> 00:23:44,880
the move constructors of all the data

00:23:42,480 --> 00:23:44,880
members

00:23:45,279 --> 00:23:49,600
that's the same thing the compiler would

00:23:46,960 --> 00:23:50,320
generate so what we have here could be

00:23:49,600 --> 00:23:52,640
replaced

00:23:50,320 --> 00:23:55,760
with this where we ask the compiler to

00:23:52,640 --> 00:23:55,760
generate the constructor

00:23:56,720 --> 00:24:01,840
here's an example of a class with a

00:23:58,400 --> 00:24:03,919
pointer to memory that the class owns

00:24:01,840 --> 00:24:05,120
the class's destructor not shown here

00:24:03,919 --> 00:24:06,880
freeze the memory

00:24:05,120 --> 00:24:08,320
if this were real production code we

00:24:06,880 --> 00:24:10,080
would use unique pointer instead of a

00:24:08,320 --> 00:24:12,159
raw pointer but this is slideware

00:24:10,080 --> 00:24:14,159
the raw pointer is a stand in for any

00:24:12,159 --> 00:24:16,960
resource whose acquisition and release

00:24:14,159 --> 00:24:20,480
has to be done explicitly so how do we

00:24:16,960 --> 00:24:20,480
write this move constructor

00:24:22,559 --> 00:24:25,679
this is a start we call the pointer's

00:24:24,720 --> 00:24:27,600
move constructor

00:24:25,679 --> 00:24:28,960
so the pointer value is copied to the

00:24:27,600 --> 00:24:30,480
new object

00:24:28,960 --> 00:24:32,159
like the int we could leave out the call

00:24:30,480 --> 00:24:33,760
to stood move since the pointers copy

00:24:32,159 --> 00:24:34,559
constructor and move constructor are the

00:24:33,760 --> 00:24:36,240
same

00:24:34,559 --> 00:24:37,600
but we should keep the explicit call to

00:24:36,240 --> 00:24:39,760
stood move

00:24:37,600 --> 00:24:40,640
as written here the new object is

00:24:39,760 --> 00:24:41,919
correct

00:24:40,640 --> 00:24:44,320
it will free the memory in its

00:24:41,919 --> 00:24:46,720
destructor like it is supposed to

00:24:44,320 --> 00:24:47,440
the problem is the other object's data

00:24:46,720 --> 00:24:50,400
pointer

00:24:47,440 --> 00:24:52,400
is still pointing to the same memory so

00:24:50,400 --> 00:24:52,960
the other object will also free that

00:24:52,400 --> 00:24:54,799
memory

00:24:52,960 --> 00:24:58,159
that would be a double free which will

00:24:54,799 --> 00:24:58,159
likely crash your program

00:24:58,640 --> 00:25:02,960
to fix this others pointer needs to be

00:25:01,279 --> 00:25:04,640
set to null

00:25:02,960 --> 00:25:06,080
setting it to null in the body of the

00:25:04,640 --> 00:25:08,799
constructor works fine

00:25:06,080 --> 00:25:11,919
this is a correct move constructor but

00:25:08,799 --> 00:25:14,640
there is a better way to do this

00:25:11,919 --> 00:25:16,320
by using stood exchange we can copy the

00:25:14,640 --> 00:25:20,400
value of the pointer and set

00:25:16,320 --> 00:25:22,720
others pointer to null in one expression

00:25:20,400 --> 00:25:24,000
stood exchange is very useful when

00:25:22,720 --> 00:25:26,799
writing moves some in

00:25:24,000 --> 00:25:27,679
right when writing move operations the

00:25:26,799 --> 00:25:30,400
first argument

00:25:27,679 --> 00:25:31,600
must be an l value reference it's the

00:25:30,400 --> 00:25:34,159
object whose value

00:25:31,600 --> 00:25:34,880
whose value needs to change the second

00:25:34,159 --> 00:25:36,960
argument

00:25:34,880 --> 00:25:38,880
is the new value that the first

00:25:36,960 --> 00:25:41,360
parameter should have

00:25:38,880 --> 00:25:42,559
stood exchange returns the old value of

00:25:41,360 --> 00:25:44,159
the first parameter

00:25:42,559 --> 00:25:46,400
it returns it by value so the return

00:25:44,159 --> 00:25:48,000
value is an r value

00:25:46,400 --> 00:25:49,919
back to our example so you can see how

00:25:48,000 --> 00:25:51,919
stood exchange is used

00:25:49,919 --> 00:25:53,360
the first argument is the object to be

00:25:51,919 --> 00:25:56,080
changed which in this case

00:25:53,360 --> 00:25:58,720
is the data member of the object being

00:25:56,080 --> 00:25:58,720
moved from

00:25:58,799 --> 00:26:02,480
stood exchange will set others pointer

00:26:01,520 --> 00:26:04,400
to null

00:26:02,480 --> 00:26:06,559
and it returns the old value of other's

00:26:04,400 --> 00:26:08,480
pointer which is used to initialize the

00:26:06,559 --> 00:26:10,720
data member of the new object

00:26:08,480 --> 00:26:13,600
this one line transfers ownership of the

00:26:10,720 --> 00:26:15,279
memory from one object to the other

00:26:13,600 --> 00:26:17,039
when we are done the new object's

00:26:15,279 --> 00:26:19,120
destructor will free the memory

00:26:17,039 --> 00:26:25,760
and the old object's destructor won't do

00:26:19,120 --> 00:26:28,159
anything since its pointer is null

00:26:25,760 --> 00:26:29,760
but there is one caveat this move

00:26:28,159 --> 00:26:31,760
constructor assumes that the data

00:26:29,760 --> 00:26:34,400
pointer can be null

00:26:31,760 --> 00:26:36,559
if there is a class invariant where data

00:26:34,400 --> 00:26:38,080
can never be null

00:26:36,559 --> 00:26:40,640
then the class cannot have a move

00:26:38,080 --> 00:26:40,640
constructor

00:26:41,200 --> 00:26:45,679
in that case the move constructor needs

00:26:43,600 --> 00:26:48,480
to be declared as deleted

00:26:45,679 --> 00:26:49,200
if data is an owning pointer that can't

00:26:48,480 --> 00:26:50,880
be null

00:26:49,200 --> 00:26:52,480
then there is no way to transfer

00:26:50,880 --> 00:26:56,400
ownership of the memory

00:26:52,480 --> 00:26:56,400
from one object to another

00:27:03,039 --> 00:27:06,960
now let's look at the move assignment

00:27:04,840 --> 00:27:08,240
operator

00:27:06,960 --> 00:27:10,000
it's very similar to the move

00:27:08,240 --> 00:27:11,679
constructor but there are a couple

00:27:10,000 --> 00:27:13,600
important differences that need to be

00:27:11,679 --> 00:27:15,520
mentioned

00:27:13,600 --> 00:27:17,520
like the move constructor the task of a

00:27:15,520 --> 00:27:19,520
move assignment operator is to transfer

00:27:17,520 --> 00:27:21,360
ownership of the object's resources

00:27:19,520 --> 00:27:22,559
from the source object to the object

00:27:21,360 --> 00:27:24,000
being assigned to

00:27:22,559 --> 00:27:26,000
any parts of the object that are just

00:27:24,000 --> 00:27:27,600
values should be copied

00:27:26,000 --> 00:27:29,279
but for anything that is a handle to

00:27:27,600 --> 00:27:30,799
some external resource

00:27:29,279 --> 00:27:32,960
the move assignment operator should

00:27:30,799 --> 00:27:35,440
transfer ownership so that the assigned

00:27:32,960 --> 00:27:36,000
to object owns them and the moved from

00:27:35,440 --> 00:27:39,279
object

00:27:36,000 --> 00:27:41,120
no longer owns them that's all the same

00:27:39,279 --> 00:27:43,039
as the move constructor but there is one

00:27:41,120 --> 00:27:44,720
important additional task that the move

00:27:43,039 --> 00:27:46,960
assignment operator has

00:27:44,720 --> 00:27:48,000
has to free any resources that the

00:27:46,960 --> 00:27:50,480
assigned to object

00:27:48,000 --> 00:27:52,159
already owns this task is identical to

00:27:50,480 --> 00:27:53,760
what the copy assignment operator needs

00:27:52,159 --> 00:27:55,679
to do so this part of the operator

00:27:53,760 --> 00:27:58,000
should be familiar

00:27:55,679 --> 00:27:58,000
oops

00:27:59,520 --> 00:28:03,039
let's look at the same two example

00:28:01,039 --> 00:28:04,399
classes and write move assignment

00:28:03,039 --> 00:28:08,240
operators for them

00:28:04,399 --> 00:28:09,840
first the class with int and string

00:28:08,240 --> 00:28:11,360
the class doesn't own any external

00:28:09,840 --> 00:28:12,799
resources so nothing has to be

00:28:11,360 --> 00:28:15,440
explicitly freed

00:28:12,799 --> 00:28:17,919
the string might own some memory but

00:28:15,440 --> 00:28:21,440
that will be managed by the string class

00:28:17,919 --> 00:28:23,279
not by struct s all we have to do is

00:28:21,440 --> 00:28:24,399
call the move assignment operators for

00:28:23,279 --> 00:28:27,200
each of the data members

00:28:24,399 --> 00:28:29,120
which looks like a usual copy assignment

00:28:27,200 --> 00:28:31,200
operator

00:28:29,120 --> 00:28:32,960
except for the use of stood move again

00:28:31,200 --> 00:28:34,480
this is exactly what the compiler would

00:28:32,960 --> 00:28:36,720
generate automatically

00:28:34,480 --> 00:28:40,080
so we can just declare it as default and

00:28:36,720 --> 00:28:40,080
let the compiler do all the work

00:28:42,720 --> 00:28:47,039
now for the class that has an owning

00:28:44,399 --> 00:28:47,840
pointer where there is an external reset

00:28:47,039 --> 00:28:51,039
resource

00:28:47,840 --> 00:28:51,039
that needs to be transferred

00:28:52,159 --> 00:28:55,600
transferring the pointer value can be

00:28:53,760 --> 00:28:59,840
done with stood exchange

00:28:55,600 --> 00:28:59,840
similar to the move constructor

00:29:03,679 --> 00:29:06,880
that transfers ownership of the memory

00:29:05,600 --> 00:29:09,120
successfully

00:29:06,880 --> 00:29:11,039
but it leaves out freeing any resources

00:29:09,120 --> 00:29:13,840
that the assigned to object

00:29:11,039 --> 00:29:13,840
already owns

00:29:15,200 --> 00:29:19,039
to do that we need to free the memory at

00:29:17,600 --> 00:29:23,360
the beginning of the function

00:29:19,039 --> 00:29:23,360
before setting data to its new value

00:29:24,799 --> 00:29:28,399
this does everything that i said a move

00:29:26,559 --> 00:29:29,840
assignment operator needs to do

00:29:28,399 --> 00:29:32,159
but there's still one thing missing that

00:29:29,840 --> 00:29:33,919
i haven't mentioned yet but that i won't

00:29:32,159 --> 00:29:35,679
get to for several more slides so we

00:29:33,919 --> 00:29:41,840
will leave this example for now

00:29:35,679 --> 00:29:41,840
and come back to it a little later

00:29:46,240 --> 00:29:49,679
now that you know the basics of writing

00:29:47,840 --> 00:29:52,480
move operations

00:29:49,679 --> 00:29:55,279
some guidelines so you can get better at

00:29:52,480 --> 00:29:56,880
writing them the first guideline

00:29:55,279 --> 00:29:58,399
is that move constructors and move

00:29:56,880 --> 00:29:59,440
assignment operators should be

00:29:58,399 --> 00:30:02,720
explicitly no

00:29:59,440 --> 00:30:04,799
except the reason behind this is that

00:30:02,720 --> 00:30:06,559
move operations really should not throw

00:30:04,799 --> 00:30:09,039
exceptions

00:30:06,559 --> 00:30:11,600
move operations just transfer existing

00:30:09,039 --> 00:30:14,399
resources from one place to another

00:30:11,600 --> 00:30:16,720
transferring resources should not fail

00:30:14,399 --> 00:30:18,720
allocating new resources can fail

00:30:16,720 --> 00:30:20,159
but moving resources around or

00:30:18,720 --> 00:30:23,039
deallocating resources

00:30:20,159 --> 00:30:25,520
as the move assignment operator might do

00:30:23,039 --> 00:30:27,360
should always be successful

00:30:25,520 --> 00:30:28,799
if you write move operations that want

00:30:27,360 --> 00:30:31,039
to throw an exception

00:30:28,799 --> 00:30:33,039
i suggest stepping back and looking at

00:30:31,039 --> 00:30:36,399
your class design and whether or not

00:30:33,039 --> 00:30:38,399
it can properly support move operations

00:30:36,399 --> 00:30:40,000
you should always include an explicit no

00:30:38,399 --> 00:30:41,440
except in declarations of move

00:30:40,000 --> 00:30:42,320
constructors and move assignment

00:30:41,440 --> 00:30:43,840
operators

00:30:42,320 --> 00:30:45,360
even when asking the compiler to

00:30:43,840 --> 00:30:50,159
generate one for you

00:30:45,360 --> 00:30:51,679
via default

00:30:50,159 --> 00:30:53,279
and this slide answer is a question i

00:30:51,679 --> 00:30:57,039
got just a minute ago

00:30:53,279 --> 00:30:59,440
about it someone noticed that i marked

00:30:57,039 --> 00:31:05,840
all the move constructors no except

00:30:59,440 --> 00:31:05,840
and this is why

00:31:06,080 --> 00:31:10,480
the next guideline and this is an

00:31:07,840 --> 00:31:12,799
important one

00:31:10,480 --> 00:31:14,480
a moved from object must be left in a

00:31:12,799 --> 00:31:16,240
valid state

00:31:14,480 --> 00:31:18,720
the compiler will call the destructor of

00:31:16,240 --> 00:31:19,360
the moved from object so the move from

00:31:18,720 --> 00:31:21,440
object

00:31:19,360 --> 00:31:24,240
absolutely must be in a state where the

00:31:21,440 --> 00:31:26,399
destructor does the right thing

00:31:24,240 --> 00:31:27,360
if practical you should leave them moved

00:31:26,399 --> 00:31:28,799
from object

00:31:27,360 --> 00:31:30,960
in the same state that a default

00:31:28,799 --> 00:31:32,080
constructed object would be in

00:31:30,960 --> 00:31:34,000
but that's an optional part of the

00:31:32,080 --> 00:31:36,000
guideline

00:31:34,000 --> 00:31:37,279
you are welcome to document for your

00:31:36,000 --> 00:31:39,600
users what value

00:31:37,279 --> 00:31:40,880
a moved from object will have but you

00:31:39,600 --> 00:31:43,200
don't have to

00:31:40,880 --> 00:31:44,320
as long as the moved from object is in a

00:31:43,200 --> 00:31:47,840
valid state

00:31:44,320 --> 00:31:47,840
you have satisfied the guideline

00:31:49,840 --> 00:31:53,200
this guideline is important enough that

00:31:51,440 --> 00:31:55,039
it warrants an example

00:31:53,200 --> 00:31:56,960
we have a class with a string and we

00:31:55,039 --> 00:31:59,440
also cache the length of the string

00:31:56,960 --> 00:32:01,360
as its own data member so there is a

00:31:59,440 --> 00:32:01,840
class invariant that the length data

00:32:01,360 --> 00:32:03,519
member

00:32:01,840 --> 00:32:05,760
is always equal to the length of the

00:32:03,519 --> 00:32:07,279
string this is a silly design since

00:32:05,760 --> 00:32:09,120
calculating the length of the string is

00:32:07,279 --> 00:32:11,440
always trivial to do

00:32:09,120 --> 00:32:13,279
but consider this as a proxy for a class

00:32:11,440 --> 00:32:14,559
where we want to cache some information

00:32:13,279 --> 00:32:17,760
that is

00:32:14,559 --> 00:32:19,440
much more expensive to compute

00:32:17,760 --> 00:32:22,559
what should this classes move

00:32:19,440 --> 00:32:22,559
constructor look like

00:32:23,200 --> 00:32:27,039
here's the obvious implementation use

00:32:25,519 --> 00:32:29,360
the move constructor for each of the

00:32:27,039 --> 00:32:31,440
data members

00:32:29,360 --> 00:32:32,960
the class invariant holds for the newly

00:32:31,440 --> 00:32:35,200
constructed object

00:32:32,960 --> 00:32:38,640
since both the string and the length

00:32:35,200 --> 00:32:38,640
were moved to the new object

00:32:38,880 --> 00:32:43,120
but we might have broken the invariant

00:32:40,880 --> 00:32:45,600
for the moved from object

00:32:43,120 --> 00:32:46,320
we know that other dot string is a valid

00:32:45,600 --> 00:32:48,559
string

00:32:46,320 --> 00:32:50,480
because stood string's move constructor

00:32:48,559 --> 00:32:53,200
will leave the move from string

00:32:50,480 --> 00:32:53,840
in a valid state but we don't know what

00:32:53,200 --> 00:32:56,480
value

00:32:53,840 --> 00:32:58,240
other dot string has reasonable

00:32:56,480 --> 00:33:00,720
implementations of stood string

00:32:58,240 --> 00:33:03,120
might leave other dot string unchanged

00:33:00,720 --> 00:33:05,200
or might set it to the empty string

00:33:03,120 --> 00:33:07,279
but there's no guarantee that other dot

00:33:05,200 --> 00:33:08,559
length matches the length of other dot

00:33:07,279 --> 00:33:11,039
string

00:33:08,559 --> 00:33:12,399
so other might be in might be in an

00:33:11,039 --> 00:33:15,360
invalid state

00:33:12,399 --> 00:33:18,799
where its invariant doesn't hold we need

00:33:15,360 --> 00:33:18,799
to do something to fix this

00:33:19,440 --> 00:33:24,080
one possible fix is to explicitly set

00:33:22,080 --> 00:33:26,640
other dot length to whatever length

00:33:24,080 --> 00:33:28,399
other dot string happens to have after

00:33:26,640 --> 00:33:30,240
it has been moved from

00:33:28,399 --> 00:33:31,760
this is not the best fix because it

00:33:30,240 --> 00:33:33,200
accesses other dot string

00:33:31,760 --> 00:33:36,880
after it has been moved from which

00:33:33,200 --> 00:33:36,880
violates an earlier guideline

00:33:37,360 --> 00:33:41,600
we can avoid accessing a moved from

00:33:39,679 --> 00:33:44,640
object by explicitly clearing

00:33:41,600 --> 00:33:46,240
other dot string that resets it to a

00:33:44,640 --> 00:33:48,960
known value

00:33:46,240 --> 00:33:50,799
and then we set other.length to be the

00:33:48,960 --> 00:33:52,880
length of the empty string

00:33:50,799 --> 00:33:54,159
this is correct and now satisfies all

00:33:52,880 --> 00:33:56,720
our guidelines

00:33:54,159 --> 00:33:59,279
but we can on but we can improve on it

00:33:56,720 --> 00:34:01,679
some more by using stood exchange

00:33:59,279 --> 00:34:03,039
which allows us to move the values and

00:34:01,679 --> 00:34:06,320
reset the values in

00:34:03,039 --> 00:34:08,399
other to a known state in one shot

00:34:06,320 --> 00:34:09,760
this preserves the class invariant in

00:34:08,399 --> 00:34:12,320
both objects

00:34:09,760 --> 00:34:13,919
it has the bonus of setting other to the

00:34:12,320 --> 00:34:15,520
default constructed state

00:34:13,919 --> 00:34:17,839
which is not required but is a good

00:34:15,520 --> 00:34:20,800
thing to do

00:34:17,839 --> 00:34:22,560
the take away from this if your class

00:34:20,800 --> 00:34:24,560
has a class invariant

00:34:22,560 --> 00:34:25,760
you might have to do extra work in your

00:34:24,560 --> 00:34:28,000
move operations

00:34:25,760 --> 00:34:29,040
so that the invariant is maintained in

00:34:28,000 --> 00:34:32,480
both the source

00:34:29,040 --> 00:34:32,480
and destination objects

00:34:33,440 --> 00:34:38,560
the next guideline use equals default

00:34:36,960 --> 00:34:41,200
for your move operations

00:34:38,560 --> 00:34:43,359
when that will do the right thing let

00:34:41,200 --> 00:34:45,119
the compiler do the work for you

00:34:43,359 --> 00:34:47,200
lessening the chance that a typo will

00:34:45,119 --> 00:34:48,879
introduce a bug

00:34:47,200 --> 00:34:50,480
just be sure to put some thought into

00:34:48,879 --> 00:34:52,800
whether or not the compiler

00:34:50,480 --> 00:34:55,280
generated move operation will do the

00:34:52,800 --> 00:34:55,280
right thing

00:34:56,159 --> 00:35:00,640
earlier we had this example where the

00:34:58,560 --> 00:35:03,520
move constructor just calls the move

00:35:00,640 --> 00:35:05,839
constructors of all the sub-objects

00:35:03,520 --> 00:35:06,960
i said then that using equals default

00:35:05,839 --> 00:35:09,760
was equivalent

00:35:06,960 --> 00:35:12,000
now i am telling you that it is better

00:35:09,760 --> 00:35:14,480
use equals default when it will do the

00:35:12,000 --> 00:35:14,480
right thing

00:35:15,200 --> 00:35:18,560
this is the most controversial guideline

00:35:17,200 --> 00:35:21,839
some people don't like it

00:35:18,560 --> 00:35:22,320
but i stand by it make move assignment

00:35:21,839 --> 00:35:24,880
safe

00:35:22,320 --> 00:35:25,920
for self-assignment a move

00:35:24,880 --> 00:35:27,839
self-assignment

00:35:25,920 --> 00:35:29,280
should be very rare especially in

00:35:27,839 --> 00:35:32,560
well-designed code

00:35:29,280 --> 00:35:34,960
but it might happen and it is up to you

00:35:32,560 --> 00:35:36,160
as a class designer to make sure a move

00:35:34,960 --> 00:35:40,079
self-assignment

00:35:36,160 --> 00:35:41,520
of your class doesn't crash the program

00:35:40,079 --> 00:35:44,000
let's go back to the example from

00:35:41,520 --> 00:35:46,160
earlier where i left you hanging

00:35:44,000 --> 00:35:47,440
a class has a pointer to memory that it

00:35:46,160 --> 00:35:49,280
owns

00:35:47,440 --> 00:35:51,599
we wrote a move assignment operator that

00:35:49,280 --> 00:35:53,040
correctly frees existing resources

00:35:51,599 --> 00:35:59,839
and then transfers ownership of

00:35:53,040 --> 00:35:59,839
resources from one object to the other

00:36:01,520 --> 00:36:04,960
but what happens if a user writes a move

00:36:03,920 --> 00:36:08,640
self-assignment

00:36:04,960 --> 00:36:08,640
as shown in the code at the bottom

00:36:09,359 --> 00:36:14,320
keep in mind that star this and other

00:36:12,320 --> 00:36:16,640
are the same object

00:36:14,320 --> 00:36:18,400
so when we delete data that frees the

00:36:16,640 --> 00:36:21,760
memory owned by the object

00:36:18,400 --> 00:36:21,760
with no way to get it back

00:36:23,359 --> 00:36:28,240
despite all the work that stood exchange

00:36:25,599 --> 00:36:28,800
does this line ends up leaving data's

00:36:28,240 --> 00:36:31,839
value

00:36:28,800 --> 00:36:33,680
unchanged so at the end of the

00:36:31,839 --> 00:36:36,079
assignment operator

00:36:33,680 --> 00:36:37,760
data is left pointing to memory that has

00:36:36,079 --> 00:36:40,400
been deleted

00:36:37,760 --> 00:36:42,400
when the classes destructor is run that

00:36:40,400 --> 00:36:44,640
same memory will be deleted again

00:36:42,400 --> 00:36:47,040
probably resulting in a crash of the

00:36:44,640 --> 00:36:47,040
program

00:36:47,920 --> 00:36:51,680
to avoid this crash we should insert a

00:36:50,480 --> 00:36:52,960
self-assignment check

00:36:51,680 --> 00:36:55,359
at the beginning of the function as

00:36:52,960 --> 00:36:56,480
shown in blue this is the same

00:36:55,359 --> 00:37:00,640
self-assignment check

00:36:56,480 --> 00:37:00,640
that many copy assignment operators have

00:37:01,760 --> 00:37:04,400
some people worry that the

00:37:02,800 --> 00:37:05,280
self-assignment check will affect

00:37:04,400 --> 00:37:07,839
performance

00:37:05,280 --> 00:37:09,839
it won't don't worry about that herb

00:37:07,839 --> 00:37:12,720
sutter recently ran some experience

00:37:09,839 --> 00:37:14,880
some experiments to test this and found

00:37:12,720 --> 00:37:17,599
that the performance impact of the check

00:37:14,880 --> 00:37:19,280
is negligible just get into the habit of

00:37:17,599 --> 00:37:21,680
including the self-assignment check

00:37:19,280 --> 00:37:23,520
in both of your move assignments and

00:37:21,680 --> 00:37:26,800
copy assignment operators

00:37:23,520 --> 00:37:26,800
it will make your code better

00:37:32,079 --> 00:37:36,000
the final guideline in this presentation

00:37:34,960 --> 00:37:38,800
the rule of five

00:37:36,000 --> 00:37:40,640
or rule of zero to put it in english

00:37:38,800 --> 00:37:42,880
like the core guidelines does

00:37:40,640 --> 00:37:43,920
if you declare any one of the destructor

00:37:42,880 --> 00:37:45,520
copy constructor

00:37:43,920 --> 00:37:48,160
copy assignment operator move

00:37:45,520 --> 00:37:51,119
constructor or move assignment operator

00:37:48,160 --> 00:37:52,320
then you should declare all five of them

00:37:51,119 --> 00:37:54,400
declaring one of them

00:37:52,320 --> 00:37:58,720
means providing a definition declaring

00:37:54,400 --> 00:38:00,880
it as default or declaring it as deleted

00:37:58,720 --> 00:38:02,400
if the default behavior is correct for

00:38:00,880 --> 00:38:04,240
all five of these functions

00:38:02,400 --> 00:38:05,680
then save yourself some work let the

00:38:04,240 --> 00:38:07,920
compiler do everything

00:38:05,680 --> 00:38:10,240
and don't declare any of them this is

00:38:07,920 --> 00:38:12,960
the rule of zero

00:38:10,240 --> 00:38:14,560
if you have to declare any of the five

00:38:12,960 --> 00:38:15,520
then there is a good chance that you

00:38:14,560 --> 00:38:18,320
need to define

00:38:15,520 --> 00:38:18,960
all five of them you definitely need to

00:38:18,320 --> 00:38:21,119
think about

00:38:18,960 --> 00:38:22,400
all five of them even if you end up

00:38:21,119 --> 00:38:23,920
using equals default

00:38:22,400 --> 00:38:26,560
for one or two of them do that

00:38:23,920 --> 00:38:28,320
explicitly to document that you have

00:38:26,560 --> 00:38:32,079
given it thought

00:38:28,320 --> 00:38:33,920
this is the rule of five

00:38:32,079 --> 00:38:35,440
someone in the question asked about the

00:38:33,920 --> 00:38:37,920
rule of 6 i think

00:38:35,440 --> 00:38:40,400
the rule of 6 adds the default

00:38:37,920 --> 00:38:42,240
constructor to this list

00:38:40,400 --> 00:38:44,000
so you can follow the rule of 6 if you

00:38:42,240 --> 00:38:45,440
want to you also add a default

00:38:44,000 --> 00:38:47,760
constructor if that's appropriate for

00:38:45,440 --> 00:38:49,599
your class

00:38:47,760 --> 00:38:51,359
that's fine but the the main point here

00:38:49,599 --> 00:39:00,240
is define all of them

00:38:51,359 --> 00:39:02,000
or define none of them

00:39:00,240 --> 00:39:05,599
a quick look at some other ways that

00:39:02,000 --> 00:39:05,599
move semantics are useful

00:39:05,680 --> 00:39:11,599
vector pushback has two overloads

00:39:09,359 --> 00:39:15,200
one that takes a const ref and one that

00:39:11,599 --> 00:39:17,599
takes an r-value reference

00:39:15,200 --> 00:39:19,119
this is a common pattern which is useful

00:39:17,599 --> 00:39:21,200
when the function needs to copy the

00:39:19,119 --> 00:39:23,280
parameter somewhere else

00:39:21,200 --> 00:39:25,760
pushback needs to get the object into

00:39:23,280 --> 00:39:28,480
the vector and it wants to do it as if

00:39:25,760 --> 00:39:30,400
as efficiently as possible by having

00:39:28,480 --> 00:39:32,480
both overloads

00:39:30,400 --> 00:39:33,440
the function can move the value into its

00:39:32,480 --> 00:39:36,000
final location

00:39:33,440 --> 00:39:36,560
when the value is movable and copy the

00:39:36,000 --> 00:39:39,760
value

00:39:36,560 --> 00:39:42,720
into its final location otherwise

00:39:39,760 --> 00:39:44,000
given this example code when the

00:39:42,720 --> 00:39:47,119
argument to pushback

00:39:44,000 --> 00:39:47,680
is an l value the constraint overload is

00:39:47,119 --> 00:39:50,240
called

00:39:47,680 --> 00:39:52,800
and the string is copied into its place

00:39:50,240 --> 00:39:54,800
in the vector

00:39:52,800 --> 00:39:56,400
but when the argument to push back is an

00:39:54,800 --> 00:39:58,880
r value

00:39:56,400 --> 00:40:00,240
the r value reference overload is called

00:39:58,880 --> 00:40:03,440
and the string is moved

00:40:00,240 --> 00:40:03,440
into the vector instead

00:40:06,720 --> 00:40:09,680
there's a whole other part of move

00:40:08,079 --> 00:40:10,480
semantics that i don't have time to

00:40:09,680 --> 00:40:13,280
cover

00:40:10,480 --> 00:40:14,800
since this is only a one hour talk

00:40:13,280 --> 00:40:17,040
universal references

00:40:14,800 --> 00:40:18,480
also known as forwarding references and

00:40:17,040 --> 00:40:21,200
the stood forward function

00:40:18,480 --> 00:40:22,160
are used to implement perfect forwarding

00:40:21,200 --> 00:40:23,760
where parameters

00:40:22,160 --> 00:40:25,520
are forwarded from one function to

00:40:23,760 --> 00:40:27,839
another while preserving

00:40:25,520 --> 00:40:28,960
both the type and the value category of

00:40:27,839 --> 00:40:30,720
the parameter

00:40:28,960 --> 00:40:32,560
i wish i could explain to you how this

00:40:30,720 --> 00:40:34,160
works

00:40:32,560 --> 00:40:35,920
but i will have to settle for merely

00:40:34,160 --> 00:40:37,920
telling you that it exists

00:40:35,920 --> 00:40:40,960
so you know what term to search for if

00:40:37,920 --> 00:40:40,960
you want to learn more

00:40:44,000 --> 00:40:48,000
so how are move semantics useful why did

00:40:46,480 --> 00:40:49,760
howard hint and many other c

00:40:48,000 --> 00:40:52,720
plus language designers go through all

00:40:49,760 --> 00:40:56,160
this effort to get move semantics into c

00:40:52,720 --> 00:40:57,200
plus 11. let's go back to our opening

00:40:56,160 --> 00:40:59,200
example

00:40:57,200 --> 00:41:01,599
where performance was hurt by copies of

00:40:59,200 --> 00:41:03,599
stood map being expensive

00:41:01,599 --> 00:41:05,200
move semantics allows us to replace

00:41:03,599 --> 00:41:09,280
those expensive copies

00:41:05,200 --> 00:41:11,200
with cheap moves here's our code

00:41:09,280 --> 00:41:12,800
remember there was a copy at the return

00:41:11,200 --> 00:41:14,880
statement in build dictionary

00:41:12,800 --> 00:41:16,560
and a copy at each of the assignments in

00:41:14,880 --> 00:41:18,319
business logic

00:41:16,560 --> 00:41:19,599
let's see what happens to them when we

00:41:18,319 --> 00:41:22,000
upgrade to c

00:41:19,599 --> 00:41:22,720
11 where stood map now has a move

00:41:22,000 --> 00:41:26,000
constructor

00:41:22,720 --> 00:41:28,240
and a move assignment operator

00:41:26,000 --> 00:41:30,079
the copy at the return statement is

00:41:28,240 --> 00:41:32,000
turned into a move

00:41:30,079 --> 00:41:33,760
remember that a local variable that is

00:41:32,000 --> 00:41:36,240
the return value expression

00:41:33,760 --> 00:41:38,400
is treated like an r value so this

00:41:36,240 --> 00:41:40,160
return uses maps move constructor to

00:41:38,400 --> 00:41:42,240
create the return value

00:41:40,160 --> 00:41:44,880
and we didn't even need to add a call to

00:41:42,240 --> 00:41:44,880
stood move

00:41:45,680 --> 00:41:49,119
because the right hand side of each of

00:41:47,680 --> 00:41:51,520
the assignment operators

00:41:49,119 --> 00:41:52,560
is a function return value which is an r

00:41:51,520 --> 00:41:55,520
value

00:41:52,560 --> 00:41:56,480
these are now move assignments which

00:41:55,520 --> 00:42:00,480
transfer the map

00:41:56,480 --> 00:42:00,480
into the dictionary variable without

00:42:00,839 --> 00:42:03,839
copying

00:42:04,720 --> 00:42:09,359
we have managed to get rid of all the

00:42:06,800 --> 00:42:09,920
copies without having to change the user

00:42:09,359 --> 00:42:12,400
code

00:42:09,920 --> 00:42:12,400
at all

00:42:14,960 --> 00:42:19,040
the other big benefit of move semantics

00:42:17,280 --> 00:42:21,520
is that it makes it possible to have

00:42:19,040 --> 00:42:23,280
move only types

00:42:21,520 --> 00:42:24,720
those are the types that can be moved

00:42:23,280 --> 00:42:27,920
but not copied

00:42:24,720 --> 00:42:29,920
this could not be done in c 98.

00:42:27,920 --> 00:42:32,000
the standards committee tried to do that

00:42:29,920 --> 00:42:34,240
with autopointer in the original c

00:42:32,000 --> 00:42:36,240
plus standard but they failed

00:42:34,240 --> 00:42:37,440
autopointer worked correctly if you used

00:42:36,240 --> 00:42:39,440
it correctly

00:42:37,440 --> 00:42:41,599
but it was too easy to misuse it in a

00:42:39,440 --> 00:42:43,040
way that could result in a program crash

00:42:41,599 --> 00:42:44,800
or other bad behavior

00:42:43,040 --> 00:42:46,319
because the language could not correctly

00:42:44,800 --> 00:42:49,520
enforce the desired

00:42:46,319 --> 00:42:50,720
move only behavior auto pointer was

00:42:49,520 --> 00:42:53,119
deprecated in c

00:42:50,720 --> 00:42:54,000
plus 11 and completely removed from the

00:42:53,119 --> 00:42:57,200
language in c

00:42:54,000 --> 00:42:57,200
plus 17.

00:42:57,440 --> 00:43:00,480
it was replaced in c plus 11 with unique

00:42:59,920 --> 00:43:02,319
pointer

00:43:00,480 --> 00:43:04,560
which is the quintessential move only

00:43:02,319 --> 00:43:04,560
type

00:43:06,000 --> 00:43:09,680
here is some code that tries to copy

00:43:07,920 --> 00:43:11,760
unique pointers

00:43:09,680 --> 00:43:13,920
this results in three compiler errors

00:43:11,760 --> 00:43:17,760
about using a deleted copy constructor

00:43:13,920 --> 00:43:17,760
or a deleted assignment operator

00:43:17,920 --> 00:43:21,280
if we change all the copies to moves by

00:43:20,319 --> 00:43:24,079
inserting calls

00:43:21,280 --> 00:43:27,119
to stood move or using an r value such

00:43:24,079 --> 00:43:29,599
as the return value of g

00:43:27,119 --> 00:43:30,960
this code compiles without any errors or

00:43:29,599 --> 00:43:33,119
warnings

00:43:30,960 --> 00:43:34,640
this shows that move only types can be

00:43:33,119 --> 00:43:35,359
passed by value and returned from

00:43:34,640 --> 00:43:37,359
functions

00:43:35,359 --> 00:43:38,880
as long as the source object is an r

00:43:37,359 --> 00:43:40,640
value

00:43:38,880 --> 00:43:42,079
ignore the fact that this code uses a

00:43:40,640 --> 00:43:43,760
after it has been moved from that was

00:43:42,079 --> 00:43:44,240
necessary to fit all the code on one

00:43:43,760 --> 00:43:55,200
slide

00:43:44,240 --> 00:43:57,359
i wouldn't do that in production code

00:43:55,200 --> 00:43:59,520
some resources if you want to learn more

00:43:57,359 --> 00:44:02,000
about move semantics

00:43:59,520 --> 00:44:03,520
the most complete resource is nico's

00:44:02,000 --> 00:44:06,640
recently published book

00:44:03,520 --> 00:44:10,240
c plus plus move semantics

00:44:06,640 --> 00:44:11,760
the complete guide i encourage everyone

00:44:10,240 --> 00:44:13,760
to become familiar with the c

00:44:11,760 --> 00:44:15,680
plus core guidelines and not just the

00:44:13,760 --> 00:44:18,640
parts about move semantics there's a lot

00:44:15,680 --> 00:44:20,480
of good wisdom in there

00:44:18,640 --> 00:44:22,640
nico has given many talks about move

00:44:20,480 --> 00:44:24,400
semantics over the last few years as he

00:44:22,640 --> 00:44:26,560
was writing his book

00:44:24,400 --> 00:44:28,720
earlier in this conference he gave one

00:44:26,560 --> 00:44:31,920
that covered some more advanced topics

00:44:28,720 --> 00:44:33,520
it makes a good follow-up to this talk

00:44:31,920 --> 00:44:36,640
if you think you have figured out move

00:44:33,520 --> 00:44:38,079
semantics i recommend watching nico's

00:44:36,640 --> 00:44:40,800
talk from cppcon

00:44:38,079 --> 00:44:44,400
three years ago that will show you how

00:44:40,800 --> 00:44:44,400
much you still have left to learn

00:44:45,760 --> 00:44:50,000
so our summary one slide summary of move

00:44:48,839 --> 00:44:54,160
semantics

00:44:50,000 --> 00:44:57,040
r value references only bind to r values

00:44:54,160 --> 00:44:58,240
stood move turns any expression into an

00:44:57,040 --> 00:45:00,079
r value

00:44:58,240 --> 00:45:03,520
and is an indication that you want the

00:45:00,079 --> 00:45:03,520
object to be moved from

00:45:03,680 --> 00:45:07,040
move constructors and move assignment

00:45:05,520 --> 00:45:09,359
operators have one

00:45:07,040 --> 00:45:10,800
r-value reference parameter of the class

00:45:09,359 --> 00:45:12,800
type

00:45:10,800 --> 00:45:15,040
their primary responsibility is to

00:45:12,800 --> 00:45:17,599
transfer ownership of resources

00:45:15,040 --> 00:45:19,359
from one object to the other and they

00:45:17,599 --> 00:45:22,480
must leave the source object

00:45:19,359 --> 00:45:22,480
in a valid state

00:45:23,520 --> 00:45:28,000
the benefits of move semantics they

00:45:26,000 --> 00:45:30,480
result in more efficient code

00:45:28,000 --> 00:45:31,520
by turning expensive copies into cheap

00:45:30,480 --> 00:45:34,400
moves

00:45:31,520 --> 00:45:35,599
and they enable the possibility of move

00:45:34,400 --> 00:45:39,280
only types

00:45:35,599 --> 00:45:39,280
which have proven to be very useful

00:45:41,040 --> 00:45:47,839
and a review of all our guidelines

00:45:44,560 --> 00:45:52,240
no rvalue references to kant's type no

00:45:47,839 --> 00:45:54,960
rvalue reference as function return type

00:45:52,240 --> 00:45:55,680
the next operation after stood move is

00:45:54,960 --> 00:45:59,440
destruction

00:45:55,680 --> 00:46:00,000
or assignment don't stood move the

00:45:59,440 --> 00:46:03,040
return

00:46:00,000 --> 00:46:04,560
of a local variable

00:46:03,040 --> 00:46:06,160
your move constructors and move

00:46:04,560 --> 00:46:09,359
assignment operators should be

00:46:06,160 --> 00:46:11,920
explicitly no except

00:46:09,359 --> 00:46:14,240
a moved from object must be left in a

00:46:11,920 --> 00:46:16,400
valid state

00:46:14,240 --> 00:46:17,359
use equals default and let the compiler

00:46:16,400 --> 00:46:20,240
do your work

00:46:17,359 --> 00:46:20,240
whenever possible

00:46:20,640 --> 00:46:24,079
make move assignment safe for

00:46:22,560 --> 00:46:26,880
self-assignment

00:46:24,079 --> 00:46:28,720
and the rule of five a rule of zero

00:46:26,880 --> 00:46:31,440
which is that if you declare

00:46:28,720 --> 00:46:33,280
any of the destructor copy constructor

00:46:31,440 --> 00:46:34,880
copy assignment operator copy

00:46:33,280 --> 00:46:36,319
sorry move constructor or move

00:46:34,880 --> 00:46:37,520
assignment operator you should

00:46:36,319 --> 00:46:41,520
explicitly declare

00:46:37,520 --> 00:46:45,760
all five of them thank you

00:46:41,520 --> 00:46:45,760
so now i will turn to the questions

00:46:47,440 --> 00:46:51,520
starting at the highest rated ones

00:46:51,920 --> 00:46:57,839
what's the benefit of move over swap

00:46:57,920 --> 00:47:01,200
they do similar things and they transfer

00:47:00,160 --> 00:47:04,960
move and swap both

00:47:01,200 --> 00:47:06,480
transfer ownership uh the move

00:47:04,960 --> 00:47:08,079
could in theory be more efficient

00:47:06,480 --> 00:47:09,920
because it only has to go one way

00:47:08,079 --> 00:47:13,119
it doesn't have to transfer things back

00:47:09,920 --> 00:47:13,119
over to the other object

00:47:13,280 --> 00:47:19,280
move is also more convenient to do

00:47:16,319 --> 00:47:25,839
to do a swap you need to explicitly call

00:47:19,280 --> 00:47:25,839
a swap operator

00:47:26,640 --> 00:47:30,640
um so essentially move and swap are used

00:47:29,680 --> 00:47:33,200
in different content

00:47:30,640 --> 00:47:38,480
used in different contexts even though

00:47:33,200 --> 00:47:41,440
they do similar things

00:47:38,480 --> 00:47:42,880
uh slide 97 shouldn't we add a check

00:47:41,440 --> 00:47:43,839
that we aren't self-assigning in a move

00:47:42,880 --> 00:47:45,760
assignment operator

00:47:43,839 --> 00:47:47,200
yes we should that was mentioned the

00:47:45,760 --> 00:47:50,079
question was asked before i got to the

00:47:47,200 --> 00:47:50,079
guideline about that

00:47:50,720 --> 00:47:53,839
next question

00:47:53,920 --> 00:47:57,839
does it make sense using move semantics

00:47:56,400 --> 00:48:01,359
for small objects without

00:47:57,839 --> 00:48:03,359
pointers and just primitive data types

00:48:01,359 --> 00:48:05,280
if your class just has primitive data

00:48:03,359 --> 00:48:07,599
types and no pointers and

00:48:05,280 --> 00:48:09,680
doesn't own any external resources you

00:48:07,599 --> 00:48:11,520
will probably fit into the rule of zero

00:48:09,680 --> 00:48:13,119
you shouldn't have any need to declare a

00:48:11,520 --> 00:48:16,319
destructor or

00:48:13,119 --> 00:48:17,040
any of the copy or move operations and

00:48:16,319 --> 00:48:21,200
so you

00:48:17,040 --> 00:48:23,760
won't need to worry about move semantics

00:48:21,200 --> 00:48:25,040
but if for some reason you're you have

00:48:23,760 --> 00:48:26,319
to write you have to do something in

00:48:25,040 --> 00:48:27,920
your destructor so you write an

00:48:26,319 --> 00:48:30,240
instructor

00:48:27,920 --> 00:48:31,200
then you should it's my recommendation

00:48:30,240 --> 00:48:33,920
is that you

00:48:31,200 --> 00:48:35,520
should declare the move constructor and

00:48:33,920 --> 00:48:36,880
move assignment operator but you will

00:48:35,520 --> 00:48:38,720
almost

00:48:36,880 --> 00:48:41,200
you should be able to do them as equals

00:48:38,720 --> 00:48:41,200
default

00:48:46,319 --> 00:48:49,760
next question why should we explicitly

00:48:48,000 --> 00:48:53,200
specify no except

00:48:49,760 --> 00:48:55,119
in move operations uh because they

00:48:53,200 --> 00:48:55,839
should be no except there is other code

00:48:55,119 --> 00:49:00,720
out there

00:48:55,839 --> 00:49:00,720
that expects moves to be no except

00:49:01,119 --> 00:49:05,680
for example some vector operations some

00:49:03,599 --> 00:49:08,559
operations on vector like resize

00:49:05,680 --> 00:49:09,839
will be more efficient if your code if

00:49:08,559 --> 00:49:12,319
your move operations

00:49:09,839 --> 00:49:14,240
are no except the vector will check for

00:49:12,319 --> 00:49:16,720
that and it can do

00:49:14,240 --> 00:49:18,240
it can establish more efficient more

00:49:16,720 --> 00:49:19,520
efficient code if it knows that no

00:49:18,240 --> 00:49:22,640
exception will come out

00:49:19,520 --> 00:49:23,920
so um having you

00:49:22,640 --> 00:49:26,400
having your move operations be

00:49:23,920 --> 00:49:28,240
explicitly no except makes it easier for

00:49:26,400 --> 00:49:30,559
others to write

00:49:28,240 --> 00:49:31,520
exception-specific code sorry accept

00:49:30,559 --> 00:49:35,359
exception safe

00:49:31,520 --> 00:49:35,359
code and efficient

00:49:39,760 --> 00:49:45,359
uh the next question were universal

00:49:43,280 --> 00:49:48,319
references explicitly designed as

00:49:45,359 --> 00:49:50,079
such or they're just a consequence of

00:49:48,319 --> 00:49:51,119
our value references that happen to be

00:49:50,079 --> 00:49:54,559
useful

00:49:51,119 --> 00:49:56,800
i'm they were specifically designed as

00:49:54,559 --> 00:49:56,800
such

00:49:57,280 --> 00:50:02,480
uh it it yeah i

00:50:00,800 --> 00:50:04,160
really don't have time to go into enough

00:50:02,480 --> 00:50:06,000
detail

00:50:04,160 --> 00:50:07,119
they don't universal references don't

00:50:06,000 --> 00:50:10,400
actually exist in the language

00:50:07,119 --> 00:50:13,680
definition they're a consequence of how

00:50:10,400 --> 00:50:16,400
function or sorry function template

00:50:13,680 --> 00:50:17,280
argument deduction happens in the

00:50:16,400 --> 00:50:19,599
presence of

00:50:17,280 --> 00:50:20,720
references especially both l value and r

00:50:19,599 --> 00:50:22,559
value references

00:50:20,720 --> 00:50:23,920
but yes that feature was designed to be

00:50:22,559 --> 00:50:25,760
a universal reference

00:50:23,920 --> 00:50:29,280
but you'll have to go study that

00:50:25,760 --> 00:50:29,280
somewhere else if you want to know more

00:50:29,920 --> 00:50:33,599
okay uh next question in slide 101 why

00:50:32,880 --> 00:50:35,599
delete

00:50:33,599 --> 00:50:37,119
why the array delete instead of the

00:50:35,599 --> 00:50:39,440
non-array delete

00:50:37,119 --> 00:50:41,040
of data uh that's because i guess i

00:50:39,440 --> 00:50:44,000
didn't explicitly state it

00:50:41,040 --> 00:50:45,520
but it was assumed that that pointer was

00:50:44,000 --> 00:50:46,240
pointing to an array that would have

00:50:45,520 --> 00:50:50,000
been

00:50:46,240 --> 00:50:50,000
documented somewhere else in the class

00:50:50,880 --> 00:50:55,839
i just didn't mention it in the

00:50:52,839 --> 00:50:55,839
presentation

00:51:02,400 --> 00:51:06,160
okay uh let's say two related questions

00:51:05,280 --> 00:51:09,760
puts them together

00:51:06,160 --> 00:51:11,280
one stood vector is not in a valid state

00:51:09,760 --> 00:51:13,040
after a move though

00:51:11,280 --> 00:51:16,079
not until clear is called so what

00:51:13,040 --> 00:51:18,720
dictates valid states and the other one

00:51:16,079 --> 00:51:19,839
valid states can be it can be a vague

00:51:18,720 --> 00:51:21,280
definition though

00:51:19,839 --> 00:51:24,400
what does valid mean for some

00:51:21,280 --> 00:51:24,400
user-defined class

00:51:25,520 --> 00:51:30,000
think actually the second one first

00:51:27,440 --> 00:51:33,359
valid if you're designing your own class

00:51:30,000 --> 00:51:34,960
valid means whatever you say it means

00:51:33,359 --> 00:51:38,240
if you're writing a class you set the

00:51:34,960 --> 00:51:40,800
rules for that class how it can behave

00:51:38,240 --> 00:51:42,079
what its valid states are that's part of

00:51:40,800 --> 00:51:43,920
designing the class that's something you

00:51:42,079 --> 00:51:46,800
need to think about

00:51:43,920 --> 00:51:49,839
so keeping an object in a valid state

00:51:46,800 --> 00:51:52,480
whatever it means for that

00:51:49,839 --> 00:51:53,119
so that is specific to the situation as

00:51:52,480 --> 00:51:55,359
for

00:51:53,119 --> 00:51:56,480
vector um no actually all the standard

00:51:55,359 --> 00:51:58,960
classes

00:51:56,480 --> 00:51:59,520
guarantee all the classes in the

00:51:58,960 --> 00:52:02,000
standard

00:51:59,520 --> 00:52:03,520
c plus plus standard library guarantee

00:52:02,000 --> 00:52:05,280
that when they are moved from they will

00:52:03,520 --> 00:52:06,559
be left in a valid state the standard

00:52:05,280 --> 00:52:10,160
library

00:52:06,559 --> 00:52:10,160
follows this guideline

00:52:10,480 --> 00:52:13,520
so vector will be in a valid state after

00:52:13,040 --> 00:52:17,359
it's

00:52:13,520 --> 00:52:20,240
moved from you can actually

00:52:17,359 --> 00:52:22,480
for vector um you can actually reason

00:52:20,240 --> 00:52:25,119
that it will be in an empty state

00:52:22,480 --> 00:52:26,800
but you should still treat it following

00:52:25,119 --> 00:52:32,319
the guideline that you don't access it

00:52:26,800 --> 00:52:33,920
until you set it to a new value

00:52:32,319 --> 00:52:35,680
so you'll notice right these two

00:52:33,920 --> 00:52:36,720
guidelines are in conflict the one about

00:52:35,680 --> 00:52:38,319
don't using

00:52:36,720 --> 00:52:40,640
don't using something after you've moved

00:52:38,319 --> 00:52:44,240
from it and then always leaving a move

00:52:40,640 --> 00:52:45,760
object in a valid state um this is both

00:52:44,240 --> 00:52:48,800
ends you should assume

00:52:45,760 --> 00:52:50,480
the don't use something

00:52:48,800 --> 00:52:52,079
after you've moved after it's been moved

00:52:50,480 --> 00:52:54,079
from is

00:52:52,079 --> 00:52:57,359
you protecting yourself against other

00:52:54,079 --> 00:52:59,359
people writing bad code

00:52:57,359 --> 00:53:00,480
and then the guideline that you should

00:52:59,359 --> 00:53:02,240
always leave

00:53:00,480 --> 00:53:03,839
your objects move from objects in a

00:53:02,240 --> 00:53:07,200
valid state when you write the move

00:53:03,839 --> 00:53:14,240
move constructor is protecting against

00:53:07,200 --> 00:53:16,880
other people writing bad code

00:53:14,240 --> 00:53:17,599
uh question is move semantics unchanged

00:53:16,880 --> 00:53:21,760
since

00:53:17,599 --> 00:53:24,079
c plus plus 11 there have been

00:53:21,760 --> 00:53:25,280
i don't really know what they are there

00:53:24,079 --> 00:53:29,839
i know there have been some

00:53:25,280 --> 00:53:29,839
minor tweaks uh but nothing significant

00:53:30,640 --> 00:53:34,960
so um instructions on move semantics as

00:53:34,160 --> 00:53:40,160
they were in c

00:53:34,960 --> 00:53:40,160
plus plus 11 is good enough for most

00:53:40,839 --> 00:53:43,839
people

00:53:44,000 --> 00:53:49,680
a question about self uh

00:53:47,200 --> 00:53:51,119
self move assignment what are some cases

00:53:49,680 --> 00:53:53,599
where you would want to do s

00:53:51,119 --> 00:53:55,040
equals stood move s uh you don't ever

00:53:53,599 --> 00:53:58,240
want to do that

00:53:55,040 --> 00:54:00,880
that really should not ever happen in uh

00:53:58,240 --> 00:54:02,240
well-written code but again this is a

00:54:00,880 --> 00:54:04,960
protection against

00:54:02,240 --> 00:54:07,119
your users writing code that is not well

00:54:04,960 --> 00:54:09,280
written

00:54:07,119 --> 00:54:10,720
your program should not crash if a user

00:54:09,280 --> 00:54:13,040
does that even though they should never

00:54:10,720 --> 00:54:13,040
do it

00:54:15,599 --> 00:54:19,680
next question how can you tell that a

00:54:17,680 --> 00:54:21,680
type returned from a function

00:54:19,680 --> 00:54:23,200
will be moved instead of copied without

00:54:21,680 --> 00:54:25,839
looking at the source code of that

00:54:23,200 --> 00:54:25,839
function

00:54:28,000 --> 00:54:33,119
you can't but if if you are just calling

00:54:32,079 --> 00:54:34,640
the function

00:54:33,119 --> 00:54:36,319
you shouldn't care that's the

00:54:34,640 --> 00:54:38,000
responsibility of

00:54:36,319 --> 00:54:39,599
the person writing the function to do

00:54:38,000 --> 00:54:40,240
that correctly and if you are writing

00:54:39,599 --> 00:54:43,280
the function

00:54:40,240 --> 00:54:44,720
then you can see the um you can see the

00:54:43,280 --> 00:54:46,160
code and see whether it's moved

00:54:44,720 --> 00:54:48,720
where the return value is moved or

00:54:46,160 --> 00:54:48,720
copied out

00:54:49,440 --> 00:54:56,160
or in some cases um return value

00:54:52,559 --> 00:54:56,160
observation might eliminate it entirely

00:54:56,960 --> 00:55:00,400
but if a class is well written it

00:54:59,200 --> 00:55:02,640
shouldn't matter

00:55:00,400 --> 00:55:07,839
other than for performance whether it is

00:55:02,640 --> 00:55:07,839
moved or copied

00:55:11,200 --> 00:55:16,400
uh why is it called stood move if it

00:55:13,680 --> 00:55:16,400
doesn't move

00:55:16,559 --> 00:55:21,359
because it's an indication that you want

00:55:18,799 --> 00:55:24,000
this object to be moved

00:55:21,359 --> 00:55:24,480
the more proper name was please move

00:55:24,000 --> 00:55:26,880
might be

00:55:24,480 --> 00:55:28,319
please move from this object or right

00:55:26,880 --> 00:55:30,480
please move from

00:55:28,319 --> 00:55:31,440
or something along this or this is safe

00:55:30,480 --> 00:55:33,680
to move from

00:55:31,440 --> 00:55:34,960
those are too long stood move even

00:55:33,680 --> 00:55:37,119
though it doesn't move is a nice

00:55:34,960 --> 00:55:40,319
succinct name to say

00:55:37,119 --> 00:55:44,000
this is safe to be moved from or right i

00:55:40,319 --> 00:55:44,000
promise that this is safe to be moved

00:55:46,839 --> 00:55:49,839
from

00:55:54,640 --> 00:56:00,240
um next question if i implement

00:55:58,000 --> 00:56:02,160
all my move semantics correctly how can

00:56:00,240 --> 00:56:04,240
i know that it works

00:56:02,160 --> 00:56:07,839
is there some common way of profiling

00:56:04,240 --> 00:56:07,839
the use of move ops

00:56:09,599 --> 00:56:12,640
not that i know of i don't have a good

00:56:11,040 --> 00:56:13,280
answer for this the best way to know

00:56:12,640 --> 00:56:17,200
that it works

00:56:13,280 --> 00:56:18,240
is testing i don't have any other magic

00:56:17,200 --> 00:56:21,520
tricks to

00:56:18,240 --> 00:56:21,520
give you for that i'm sorry

00:56:26,559 --> 00:56:30,480
would unique pointer members be

00:56:28,240 --> 00:56:33,359
considered as trivial since they have

00:56:30,480 --> 00:56:33,359
move defined

00:56:33,760 --> 00:56:42,480
no unique pointer is not a trivial class

00:56:37,839 --> 00:56:45,839
because it has a user-defined destructor

00:56:42,480 --> 00:56:45,839
among other things

00:56:54,079 --> 00:56:57,920
next is there a good way to confirm or

00:56:55,920 --> 00:56:59,680
double check whether a line of code is

00:56:57,920 --> 00:57:02,720
using a copy or move

00:56:59,680 --> 00:57:05,040
constructor or assignment so is this

00:57:02,720 --> 00:57:07,280
code doing a copy or a move

00:57:05,040 --> 00:57:07,280
um

00:57:08,079 --> 00:57:12,400
run it into debugger or throw a printf

00:57:10,319 --> 00:57:14,480
in your

00:57:12,400 --> 00:57:17,280
copy or move assignment when you're

00:57:14,480 --> 00:57:20,160
running your test case

00:57:17,280 --> 00:57:21,599
there's not other than sort of looking

00:57:20,160 --> 00:57:22,960
at which function is called somehow

00:57:21,599 --> 00:57:23,520
looking at which function is actually

00:57:22,960 --> 00:57:26,160
called

00:57:23,520 --> 00:57:27,520
there's not an obvious way that you can

00:57:26,160 --> 00:57:29,680
be sure by

00:57:27,520 --> 00:57:32,000
just looking at the at the unannotated

00:57:29,680 --> 00:57:32,000
code

00:57:34,400 --> 00:57:38,880
uh finally i heard that you can overload

00:57:37,520 --> 00:57:42,240
member functions for

00:57:38,880 --> 00:57:42,240
our val objects

00:57:42,880 --> 00:57:46,960
not for our vowel input can you say

00:57:45,280 --> 00:57:47,680
something about that if we have enough

00:57:46,960 --> 00:57:51,440
time

00:57:47,680 --> 00:57:54,079
um just barely enough time for this to

00:57:51,440 --> 00:57:57,839
be the last question

00:57:54,079 --> 00:57:59,040
yes on the member function declaration

00:57:57,839 --> 00:58:00,480
you can put

00:57:59,040 --> 00:58:02,079
right if you declare a member function

00:58:00,480 --> 00:58:04,720
const you have const

00:58:02,079 --> 00:58:06,480
after the parameter list instead of

00:58:04,720 --> 00:58:06,880
const or in addition to cot you can also

00:58:06,480 --> 00:58:09,359
put

00:58:06,880 --> 00:58:10,400
a single ampersand or a double ampersand

00:58:09,359 --> 00:58:13,760
and that restricts

00:58:10,400 --> 00:58:15,280
what value class of object you can call

00:58:13,760 --> 00:58:18,720
that number function on

00:58:15,280 --> 00:58:20,160
so if you have a double ampersand

00:58:18,720 --> 00:58:22,000
there where you put the const for a

00:58:20,160 --> 00:58:23,920
member function

00:58:22,000 --> 00:58:25,200
that will restrict it to being called

00:58:23,920 --> 00:58:30,319
only on

00:58:25,200 --> 00:58:30,319
only if this object is an r value

00:58:30,400 --> 00:58:35,119
and so yes that can

00:58:33,440 --> 00:58:37,040
factor in that that's sort of

00:58:35,119 --> 00:58:37,520
tangentially related to move semantics

00:58:37,040 --> 00:58:40,559
and that

00:58:37,520 --> 00:58:42,640
is useful in some places

00:58:40,559 --> 00:58:45,040
but is more advanced than what i can

00:58:42,640 --> 00:58:51,839
really cover in this talk

00:58:45,040 --> 00:58:51,839
okay so thank you all for coming

00:59:06,880 --> 00:59:08,960

YouTube URL: https://www.youtube.com/watch?v=ZG59Bqo7qX4


