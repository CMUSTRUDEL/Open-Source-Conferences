Title: The Surprising Costs of void() (and Other Not-Quite-Innocuous Evils) - Patrice Roy - CppCon 2020
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/the_surprising_costs_of_void/the_surprising_costs_of_void__patrice_roy__cppcon_2020.pdf
---
There are some things that might pass us by without us noticing them as evil or, as they have come to be known, Bad Code Smells.

Many of these little things are acceptable in some cases, and thus pass unnoticed in some code reviews. They are respectful of language rules, and thus pass unnoticed through the compiler's virtual hands. They might even lead to working code... and if it works, it's fine, no?

The idea for this talk came about when discussing with colleagues about such suspicious code and coding patterns, and hearing such questions as "but why is that a problem?". It's about those little evils that creep in code and poison our practice in subtle ways (making memory consumption higher than it should be, making execution slower than it should be, making reuse harder than it should be, etc.).

---
Patrice Roy has been playing with C++, either professionally, for pleasure or (most of the time) both for over 25 years. After a few years doing R&D and working on military flight simulators, he moved on to academics and has been teaching computer science since 1998. Since 2005, he’s been involved more specifically in helping graduate students and professionals from the fields of real-time systems and game programming develop the skills they need to face today’s challenges. The rapid evolution of C++ in recent years has made his job even more enjoyable. He’s been a participating member in the ISO C++ Standards Committee since late 2014 and has been involved with the ISO Programming Language Vulnerabilities Committee since late 2015. He has five kids, and his wife ensures their house is home to a continuously changing number of cats, dogs and other animals.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,240 --> 00:00:13,280
hello

00:00:11,120 --> 00:00:14,880
hello i'm glad to well i actually i'm

00:00:13,280 --> 00:00:16,080
glad to see you but i don't see any one

00:00:14,880 --> 00:00:19,600
of you but i'm glad you're there

00:00:16,080 --> 00:00:21,359
whoever you are um welcome to this

00:00:19,600 --> 00:00:23,199
talk that's never been given before so

00:00:21,359 --> 00:00:25,840
it's not too bad it's called the

00:00:23,199 --> 00:00:28,800
surprising costs of void paramparan

00:00:25,840 --> 00:00:30,000
and other not so quite innocuous evils

00:00:28,800 --> 00:00:33,120
so you can see my name

00:00:30,000 --> 00:00:36,000
and email addresses there for my

00:00:33,120 --> 00:00:37,920
various jobs it's very intimidating to

00:00:36,000 --> 00:00:40,960
pass after mr brown this morning

00:00:37,920 --> 00:00:42,719
and at least around noon for me

00:00:40,960 --> 00:00:44,879
because they're such great speakers but

00:00:42,719 --> 00:00:46,800
let's do our best to do something nice

00:00:44,879 --> 00:00:48,480
i will suggest that since i have a

00:00:46,800 --> 00:00:50,320
single monitor set up

00:00:48,480 --> 00:00:51,600
at home i'm working from my laptop that

00:00:50,320 --> 00:00:54,320
you uh put your

00:00:51,600 --> 00:00:56,000
questions with some context on the q a

00:00:54,320 --> 00:00:58,160
section should you have any or comments

00:00:56,000 --> 00:01:00,800
or threats or whatever you want

00:00:58,160 --> 00:01:02,160
and my extraordinary volunteers will

00:01:00,800 --> 00:01:03,600
relay them to me at the end and

00:01:02,160 --> 00:01:04,559
hopefully we'll be able to answer a few

00:01:03,600 --> 00:01:06,320
of them because i

00:01:04,559 --> 00:01:08,880
haven't timed myself so i have no clue

00:01:06,320 --> 00:01:10,080
how much time this will take

00:01:08,880 --> 00:01:11,840
of course if there's anything you can

00:01:10,080 --> 00:01:12,320
still write me or you can always write

00:01:11,840 --> 00:01:13,840
to me

00:01:12,320 --> 00:01:16,400
afterwards i'll be glad to speak with

00:01:13,840 --> 00:01:19,600
you so

00:01:16,400 --> 00:01:22,080
um as you can see if you haven't seen

00:01:19,600 --> 00:01:24,000
in the past i'm a father of five there's

00:01:22,080 --> 00:01:25,360
two at home these days only one that's

00:01:24,000 --> 00:01:27,680
home currently because

00:01:25,360 --> 00:01:29,439
she has a cold there's a number of

00:01:27,680 --> 00:01:30,799
animals in my house and i happen to be

00:01:29,439 --> 00:01:33,439
in my house so if you hear

00:01:30,799 --> 00:01:34,000
dogs barking or birds chirping very

00:01:33,439 --> 00:01:36,960
loudly

00:01:34,000 --> 00:01:38,240
or animals like cats putting things on

00:01:36,960 --> 00:01:39,280
the ground it's because that's where i

00:01:38,240 --> 00:01:42,560
am right now i'm

00:01:39,280 --> 00:01:44,560
in a a setup that is

00:01:42,560 --> 00:01:46,079
more animated than i usually am when i

00:01:44,560 --> 00:01:49,119
get in the class

00:01:46,079 --> 00:01:51,280
um i'm in my past i worked flight

00:01:49,119 --> 00:01:52,960
simulator code for the military

00:01:51,280 --> 00:01:55,520
and i've been teaching for a long while

00:01:52,960 --> 00:01:57,439
which is what you see and i'm also a wg

00:01:55,520 --> 00:02:00,159
21 member but i haven't been in meetings

00:01:57,439 --> 00:02:03,759
last year because i'm too busy

00:02:00,159 --> 00:02:06,799
it's very sad because i love meetings so

00:02:03,759 --> 00:02:09,840
about this innocuous evil thing that i

00:02:06,799 --> 00:02:09,840
want to talk about today

00:02:11,120 --> 00:02:15,440
so there are things that we let pass by

00:02:13,520 --> 00:02:17,760
us without noticing because we're busy

00:02:15,440 --> 00:02:19,680
people and we do things and we

00:02:17,760 --> 00:02:21,599
have utmost confidence in our skills and

00:02:19,680 --> 00:02:23,840
the skills of others

00:02:21,599 --> 00:02:25,920
and yeah so there are things that are

00:02:23,840 --> 00:02:27,440
kind of bad cold smells that sometimes

00:02:25,920 --> 00:02:28,000
we don't pay enough attention to and

00:02:27,440 --> 00:02:30,800
that

00:02:28,000 --> 00:02:33,519
come back the car come by and bite us or

00:02:30,800 --> 00:02:35,040
play tricks on us

00:02:33,519 --> 00:02:36,959
some of them are even acceptable in some

00:02:35,040 --> 00:02:38,239
cases as you can see so they can have a

00:02:36,959 --> 00:02:39,680
cool review and they will just

00:02:38,239 --> 00:02:41,760
pass because you weren't paying

00:02:39,680 --> 00:02:44,480
attention to that detail that day

00:02:41,760 --> 00:02:44,800
do you respect the language they compile

00:02:44,480 --> 00:02:46,319
so

00:02:44,800 --> 00:02:48,560
some people think it compiles it works

00:02:46,319 --> 00:02:50,480
which is a very interesting concept

00:02:48,560 --> 00:02:52,080
and sometimes the code even works you

00:02:50,480 --> 00:02:56,000
can have broken code that works

00:02:52,080 --> 00:02:58,720
by chance and yeah why not

00:02:56,000 --> 00:03:00,239
when when i prepared this talk the ide

00:02:58,720 --> 00:03:02,000
came from

00:03:00,239 --> 00:03:03,519
students of mine last year coming back

00:03:02,000 --> 00:03:07,280
from internships

00:03:03,519 --> 00:03:09,519
and uh bringing back assignments with

00:03:07,280 --> 00:03:11,360
things that surprised me as being

00:03:09,519 --> 00:03:13,040
acceptable to them

00:03:11,360 --> 00:03:15,440
into their employers because sometimes

00:03:13,040 --> 00:03:18,080
it was inspired by what you did at work

00:03:15,440 --> 00:03:19,440
and and but what really inspired me to

00:03:18,080 --> 00:03:20,319
do this talk was that some of my

00:03:19,440 --> 00:03:22,239
colleagues

00:03:20,319 --> 00:03:23,680
whom i respect and who are very

00:03:22,239 --> 00:03:25,519
intelligent people

00:03:23,680 --> 00:03:27,280
didn't see the point of my reaction

00:03:25,519 --> 00:03:28,640
sometimes so i said okay so there's

00:03:27,280 --> 00:03:29,120
something there that even experienced

00:03:28,640 --> 00:03:32,159
people

00:03:29,120 --> 00:03:34,319
with skills um a number of

00:03:32,159 --> 00:03:35,840
interesting qualities technically

00:03:34,319 --> 00:03:39,040
speaking

00:03:35,840 --> 00:03:40,480
just accept as okay and and yeah we need

00:03:39,040 --> 00:03:41,840
sometimes we need to take a step back

00:03:40,480 --> 00:03:42,560
and think a bit more about the code we

00:03:41,840 --> 00:03:44,080
write

00:03:42,560 --> 00:03:45,519
so it's going there is not going to be

00:03:44,080 --> 00:03:48,000
anything spectacular in the code today

00:03:45,519 --> 00:03:51,599
but there's going to be a lot of code

00:03:48,000 --> 00:03:52,959
yeah so evil comes from context too

00:03:51,599 --> 00:03:54,799
goodness is contextual evil is

00:03:52,959 --> 00:03:56,560
contextual so it can

00:03:54,799 --> 00:03:59,120
sometimes we take an example that's too

00:03:56,560 --> 00:04:00,000
simple but yeah we take it as good

00:03:59,120 --> 00:04:03,280
because you know why not

00:04:00,000 --> 00:04:05,200
it works in the in the slides we don't

00:04:03,280 --> 00:04:08,400
always mean to be evil

00:04:05,200 --> 00:04:10,560
but sometimes we are um and sometimes we

00:04:08,400 --> 00:04:12,400
are trying to apply a practice that

00:04:10,560 --> 00:04:13,040
practices good in one context or one

00:04:12,400 --> 00:04:14,879
language

00:04:13,040 --> 00:04:17,680
that doesn't fit in the language we're

00:04:14,879 --> 00:04:19,840
using for example something like this

00:04:17,680 --> 00:04:21,519
which i see quite a lot from people uh

00:04:19,840 --> 00:04:23,759
coming from java r c sharp

00:04:21,519 --> 00:04:25,199
say and they're trying to write c plus

00:04:23,759 --> 00:04:25,680
plus code and these do something like

00:04:25,199 --> 00:04:29,120
this

00:04:25,680 --> 00:04:31,120
so of course this code compiles it leaks

00:04:29,120 --> 00:04:32,639
it's very very bad c plus plus code but

00:04:31,120 --> 00:04:34,320
because it's not idiomatic but it's

00:04:32,639 --> 00:04:35,280
idiomatic in other languages where

00:04:34,320 --> 00:04:37,120
someone is

00:04:35,280 --> 00:04:39,360
able to collect the garbage to produce

00:04:37,120 --> 00:04:39,360
yeah

00:04:39,440 --> 00:04:42,639
the one on top there is closer to what

00:04:41,040 --> 00:04:44,639
we expect from c plus plus of course you

00:04:42,639 --> 00:04:46,960
will prefer to throw objects instead of

00:04:44,639 --> 00:04:48,639
some things that you have allocated

00:04:46,960 --> 00:04:50,479
in a dynamical fashion in dynamic

00:04:48,639 --> 00:04:52,080
fashion or even better the one at the

00:04:50,479 --> 00:04:53,600
bottom where you actually have a class

00:04:52,080 --> 00:04:54,960
that expresses intent

00:04:53,600 --> 00:04:56,479
more clearly instead of something that's

00:04:54,960 --> 00:04:59,199
more general that's what we've gone for

00:04:56,479 --> 00:04:59,199
in c plus plus

00:05:00,400 --> 00:05:04,240
so that void paren parent thing that

00:05:03,360 --> 00:05:08,080
void parent

00:05:04,240 --> 00:05:10,639
thing there's nothing

00:05:08,080 --> 00:05:12,160
inherently wrong with them they are

00:05:10,639 --> 00:05:14,160
everywhere let's see examples of very

00:05:12,160 --> 00:05:16,560
good ones see this one is very good

00:05:14,160 --> 00:05:17,680
it's a greeting function that provides a

00:05:16,560 --> 00:05:19,360
very interesting message that's

00:05:17,680 --> 00:05:20,960
significant and meaningful

00:05:19,360 --> 00:05:23,520
and that's being called my mind there so

00:05:20,960 --> 00:05:25,120
it's an innocuous program for starters

00:05:23,520 --> 00:05:26,560
and it's fine so there's nothing bad

00:05:25,120 --> 00:05:28,080
about the fact of having a void star

00:05:26,560 --> 00:05:30,320
avoid parent parent function

00:05:28,080 --> 00:05:32,080
they exist they have a right to exist

00:05:30,320 --> 00:05:34,400
they creep up in examples all over the

00:05:32,080 --> 00:05:34,400
place

00:05:36,080 --> 00:05:39,919
they are of limited usefulness because

00:05:38,320 --> 00:05:42,560
they have no inputs no outputs except

00:05:39,919 --> 00:05:45,120
for a global state or io

00:05:42,560 --> 00:05:46,400
but still you know and void functions

00:05:45,120 --> 00:05:48,400
well in some languages

00:05:46,400 --> 00:05:50,240
your your main is avoid function so you

00:05:48,400 --> 00:05:52,000
can write a void parent parent function

00:05:50,240 --> 00:05:53,520
java c sharp and you'll end up with

00:05:52,000 --> 00:05:55,199
something completely correct

00:05:53,520 --> 00:05:57,680
even even the one we have in c plus

00:05:55,199 --> 00:05:59,120
isn't but we mostly treat it as a void

00:05:57,680 --> 00:06:00,400
function because we don't care about the

00:05:59,120 --> 00:06:04,160
return value

00:06:00,400 --> 00:06:06,160
all that often to be honest

00:06:04,160 --> 00:06:07,520
with number functions white parent

00:06:06,160 --> 00:06:09,600
parent is a bit

00:06:07,520 --> 00:06:12,000
creepier it doesn't mean it's always

00:06:09,600 --> 00:06:13,280
that you know there are reasons but

00:06:12,000 --> 00:06:15,520
something like this you know you have a

00:06:13,280 --> 00:06:17,360
new text you call lock

00:06:15,520 --> 00:06:18,800
it's void permanent print that's fine

00:06:17,360 --> 00:06:21,039
that's fine because your mutex is a

00:06:18,800 --> 00:06:23,039
state it's representing state and you're

00:06:21,039 --> 00:06:24,720
mutating that state along the way which

00:06:23,039 --> 00:06:27,919
is kind of the point

00:06:24,720 --> 00:06:29,360
that's okay so

00:06:27,919 --> 00:06:31,199
the examples that i'm going to be using

00:06:29,360 --> 00:06:34,319
now they actually come from

00:06:31,199 --> 00:06:35,120
anonymized code that came back from the

00:06:34,319 --> 00:06:37,039
internship

00:06:35,120 --> 00:06:38,560
students and from other sources that i

00:06:37,039 --> 00:06:40,960
saw in the last year

00:06:38,560 --> 00:06:42,560
ic plus classified them in a sense but

00:06:40,960 --> 00:06:46,400
some of them were javascript code c

00:06:42,560 --> 00:06:46,400
sharp java c plus plus two of course

00:06:46,960 --> 00:06:50,000
so yeah this is actually a little actual

00:06:48,800 --> 00:06:52,000
real life code

00:06:50,000 --> 00:06:53,039
okay i think it makes me react but that

00:06:52,000 --> 00:06:57,280
doesn't make everyone

00:06:53,039 --> 00:07:00,560
in my entourage react so this function c

00:06:57,280 --> 00:07:01,440
that fetches keywords i guess from a

00:07:00,560 --> 00:07:04,080
vector of string

00:07:01,440 --> 00:07:05,520
pass by a ref probably to avoid a copy i

00:07:04,080 --> 00:07:07,680
guess

00:07:05,520 --> 00:07:08,560
that's from where touch from where is

00:07:07,680 --> 00:07:11,520
that from the argument

00:07:08,560 --> 00:07:12,960
why is it mutable where are those

00:07:11,520 --> 00:07:15,120
keywords going to go

00:07:12,960 --> 00:07:17,039
maybe inside the state of the manager i

00:07:15,120 --> 00:07:19,520
guess in this case

00:07:17,039 --> 00:07:21,440
so yeah there's something strange about

00:07:19,520 --> 00:07:23,840
this the argument is not cons this is

00:07:21,440 --> 00:07:26,639
not cons so there's mutating things

00:07:23,840 --> 00:07:26,639
elsewhere i guess

00:07:27,199 --> 00:07:30,400
this actually came from real code too

00:07:28,960 --> 00:07:35,039
yet stats

00:07:30,400 --> 00:07:38,080
no args no return type well void

00:07:35,039 --> 00:07:40,720
so avoid function that starts with get

00:07:38,080 --> 00:07:42,160
that that gives me shivers it makes me

00:07:40,720 --> 00:07:44,240
feel bad

00:07:42,160 --> 00:07:46,000
and i'm looking at this where where do

00:07:44,240 --> 00:07:49,120
those stats come from

00:07:46,000 --> 00:07:53,039
from a file i guess where do they go

00:07:49,120 --> 00:07:54,800
in some global state it's a plural stats

00:07:53,039 --> 00:07:58,240
and a plural stats that kind of makes

00:07:54,800 --> 00:07:59,759
sense i guess but why yeah

00:07:58,240 --> 00:08:01,280
this at least tells us well they

00:07:59,759 --> 00:08:03,280
probably came from a file

00:08:01,280 --> 00:08:04,400
i guess there's an argument sorry to

00:08:03,280 --> 00:08:07,919
start it's a bit

00:08:04,400 --> 00:08:07,919
less less creepy but still

00:08:08,240 --> 00:08:13,039
yeah and they're not constantly so these

00:08:11,120 --> 00:08:15,520
functions are non-cons so we can

00:08:13,039 --> 00:08:16,639
kind of expect them to be mutating state

00:08:15,520 --> 00:08:19,360
presumably

00:08:16,639 --> 00:08:23,039
if the person who wrote them kind of

00:08:19,360 --> 00:08:23,039
gets c plus plus and counts correctness

00:08:23,360 --> 00:08:27,919
this is interesting too see find args so

00:08:26,080 --> 00:08:31,039
i'm looking at this and i see okay

00:08:27,919 --> 00:08:34,000
there's a none there's a pass by value v

00:08:31,039 --> 00:08:35,919
and there's a bypass by referrings so

00:08:34,000 --> 00:08:36,719
i'm guessing it's going to find args

00:08:35,919 --> 00:08:39,680
somewhere but

00:08:36,719 --> 00:08:40,000
not in args obviously because it's const

00:08:39,680 --> 00:08:43,599
since

00:08:40,000 --> 00:08:45,120
not consumable so you i'm looking at

00:08:43,599 --> 00:08:46,880
this i'm trying to guess what's going on

00:08:45,120 --> 00:08:47,440
well maybe it will look for arguments in

00:08:46,880 --> 00:08:51,040
g

00:08:47,440 --> 00:08:52,000
and put them in args so why is it not

00:08:51,040 --> 00:08:55,120
static

00:08:52,000 --> 00:08:56,000
what's wrong there so those void

00:08:55,120 --> 00:08:58,399
functions

00:08:56,000 --> 00:08:59,839
with weird signatures well sometimes

00:08:58,399 --> 00:09:00,560
best could read you because obviously

00:08:59,839 --> 00:09:02,880
this came from

00:09:00,560 --> 00:09:05,360
actual businesses that sell and ship

00:09:02,880 --> 00:09:05,360
software

00:09:07,519 --> 00:09:11,760
this is also real life code you can see

00:09:10,240 --> 00:09:13,040
that the return type is void again

00:09:11,760 --> 00:09:15,360
it's called edit word so it's

00:09:13,040 --> 00:09:16,959
initializing i guess

00:09:15,360 --> 00:09:19,040
the state of v in this case as we can

00:09:16,959 --> 00:09:21,920
see but you know

00:09:19,040 --> 00:09:22,560
it's being passed a vector as argument

00:09:21,920 --> 00:09:24,880
which it's

00:09:22,560 --> 00:09:26,000
filling which is one i guess to wonder

00:09:24,880 --> 00:09:27,680
why is it not

00:09:26,000 --> 00:09:29,760
using a local vector and returning it

00:09:27,680 --> 00:09:32,080
instead but

00:09:29,760 --> 00:09:34,560
sometimes this comes from people used to

00:09:32,080 --> 00:09:35,120
old style c plus plus 3 c plus plus 11

00:09:34,560 --> 00:09:37,120
that

00:09:35,120 --> 00:09:39,200
maybe might not get our video or

00:09:37,120 --> 00:09:40,560
something and are guessing that this is

00:09:39,200 --> 00:09:41,839
the right way to go don't get move

00:09:40,560 --> 00:09:43,600
semantics

00:09:41,839 --> 00:09:46,160
that comes from real code see avoid

00:09:43,600 --> 00:09:46,160
function again

00:09:46,560 --> 00:09:50,320
this is a void parent paren again as you

00:09:49,600 --> 00:09:52,800
can see

00:09:50,320 --> 00:09:53,519
so i'm guessing it's going to create

00:09:52,800 --> 00:09:55,360
inside

00:09:53,519 --> 00:09:57,120
the class some state but it's a

00:09:55,360 --> 00:09:58,399
suspicious name still you know i don't

00:09:57,120 --> 00:10:00,880
know about you maybe it's current

00:09:58,399 --> 00:10:03,920
practice in your in your business

00:10:00,880 --> 00:10:05,680
but create get make convert count

00:10:03,920 --> 00:10:07,279
there's verbs like that you don't expect

00:10:05,680 --> 00:10:09,519
to see i don't have these as they expect

00:10:07,279 --> 00:10:10,800
to see associated with void functions

00:10:09,519 --> 00:10:13,120
but i see them all over the place these

00:10:10,800 --> 00:10:15,600
days

00:10:13,120 --> 00:10:17,120
yeah so our different our interfaces

00:10:15,600 --> 00:10:18,800
they talk to us they whisper

00:10:17,120 --> 00:10:20,079
they say things in our ears they carry

00:10:18,800 --> 00:10:22,079
me thinking about this should carry

00:10:20,079 --> 00:10:24,160
meaning

00:10:22,079 --> 00:10:25,839
and void parent parent they kind of

00:10:24,160 --> 00:10:27,200
carry absence

00:10:25,839 --> 00:10:29,519
in their signature there's no input

00:10:27,200 --> 00:10:31,360
there's not but they have to rely on

00:10:29,519 --> 00:10:32,880
things unknown

00:10:31,360 --> 00:10:35,440
that's creepy a bit if you think about

00:10:32,880 --> 00:10:37,600
it doesn't mean they're always wrong but

00:10:35,440 --> 00:10:40,000
you know to me it's kind of a gold smell

00:10:37,600 --> 00:10:40,000
these days

00:10:41,839 --> 00:10:45,279
there there are some virtuals that are

00:10:43,839 --> 00:10:47,839
lying around out there that we don't

00:10:45,279 --> 00:10:47,839
necessarily want

00:10:49,839 --> 00:10:53,519
when i wrote this slide i i made a smile

00:10:52,160 --> 00:10:54,800
because it's written what's wrong with

00:10:53,519 --> 00:10:56,720
this picture if you look at it closely

00:10:54,800 --> 00:10:58,959
you'll see it's not c plus plus

00:10:56,720 --> 00:11:01,040
and for a number of reasons this dot

00:10:58,959 --> 00:11:03,279
string with a big s

00:11:01,040 --> 00:11:05,120
public all over the place so yeah it

00:11:03,279 --> 00:11:06,640
says it's just

00:11:05,120 --> 00:11:07,920
i'm not going to be bitching about java

00:11:06,640 --> 00:11:09,200
or c sharp today by the way because

00:11:07,920 --> 00:11:10,640
there's c sharp later on to the

00:11:09,200 --> 00:11:13,760
today but i'm not going to about

00:11:10,640 --> 00:11:16,480
it it's just java code

00:11:13,760 --> 00:11:18,240
yeah so i i wondered if i put this how

00:11:16,480 --> 00:11:19,920
people would react i know that jf two

00:11:18,240 --> 00:11:22,640
days ago we had a bit of

00:11:19,920 --> 00:11:24,800
comment about java and made it very very

00:11:22,640 --> 00:11:26,320
very low

00:11:24,800 --> 00:11:27,680
there's nothing really wrong with this

00:11:26,320 --> 00:11:28,560
class if you think about it this it

00:11:27,680 --> 00:11:30,880
respects

00:11:28,560 --> 00:11:32,320
the practices of the language it's the

00:11:30,880 --> 00:11:33,839
catechol that you will see in the

00:11:32,320 --> 00:11:35,920
examples of the

00:11:33,839 --> 00:11:37,519
the official documentation or in books

00:11:35,920 --> 00:11:39,920
yeah

00:11:37,519 --> 00:11:40,720
but but if you haven't done much java

00:11:39,920 --> 00:11:42,240
you might

00:11:40,720 --> 00:11:44,399
miss this one this function there is

00:11:42,240 --> 00:11:48,160
it's a virtual function

00:11:44,399 --> 00:11:50,639
java did virtual as a out instead of in

00:11:48,160 --> 00:11:52,399
it was actually seen as a good thing way

00:11:50,639 --> 00:11:53,600
back so this is an actual example of

00:11:52,399 --> 00:11:55,519
java code that

00:11:53,600 --> 00:11:57,040
makes a student a person that extends

00:11:55,519 --> 00:11:58,480
word there that you see

00:11:57,040 --> 00:12:00,959
it's for public inheritance because

00:11:58,480 --> 00:12:02,480
there's no other kind really in java

00:12:00,959 --> 00:12:04,320
and well there's there's interface and

00:12:02,480 --> 00:12:06,639
retains but it's still public

00:12:04,320 --> 00:12:07,920
and that get name there that you see in

00:12:06,639 --> 00:12:10,720
the student class

00:12:07,920 --> 00:12:12,160
well it's calling the parent with super

00:12:10,720 --> 00:12:13,120
yet name because there's only one parent

00:12:12,160 --> 00:12:16,160
it's a singular

00:12:13,120 --> 00:12:16,800
single inheritance model and yeah in the

00:12:16,160 --> 00:12:18,639
main

00:12:16,800 --> 00:12:20,800
at the bottom part you can see that the

00:12:18,639 --> 00:12:21,920
person is associated with the student

00:12:20,800 --> 00:12:22,399
and when you're calling get name we're

00:12:21,920 --> 00:12:25,040
calling the

00:12:22,399 --> 00:12:26,880
name of student it's a virtual comp

00:12:25,040 --> 00:12:28,399
there's no keyword for that

00:12:26,880 --> 00:12:29,440
when you talk to a java person about

00:12:28,399 --> 00:12:30,320
virtual functions they don't get what

00:12:29,440 --> 00:12:33,600
you're saying

00:12:30,320 --> 00:12:36,160
well some of them don't so

00:12:33,600 --> 00:12:37,120
the non-constructor non-static member

00:12:36,160 --> 00:12:39,200
functions

00:12:37,120 --> 00:12:40,160
are are virtual in java and you can use

00:12:39,200 --> 00:12:42,320
final to opt out

00:12:40,160 --> 00:12:43,760
kind of like regency plus plus to halt

00:12:42,320 --> 00:12:45,200
virtual

00:12:43,760 --> 00:12:47,920
and that was seen as a good idea i

00:12:45,200 --> 00:12:49,600
remember instructors of mine when i was

00:12:47,920 --> 00:12:51,519
a student tell me how good it was and

00:12:49,600 --> 00:12:53,040
how bad the other languages were not to

00:12:51,519 --> 00:12:54,880
follow suit

00:12:53,040 --> 00:12:56,639
so c sharpen c plus plus if you notice

00:12:54,880 --> 00:12:58,959
yeah they ask you to opt in

00:12:56,639 --> 00:13:00,639
to virtual instead of up out so it's a

00:12:58,959 --> 00:13:02,079
cool mechanism when you need it but they

00:13:00,639 --> 00:13:04,480
don't impose it on you because there's

00:13:02,079 --> 00:13:04,480
gusts

00:13:04,639 --> 00:13:08,560
and this this is a virtual this is a c

00:13:07,279 --> 00:13:09,680
plus plus class now

00:13:08,560 --> 00:13:12,000
and if you look at it closely you'll

00:13:09,680 --> 00:13:15,279
notice something wrong again

00:13:12,000 --> 00:13:17,680
i'll help you there's this thing there

00:13:15,279 --> 00:13:19,040
this i see in actual coding guidelines

00:13:17,680 --> 00:13:21,760
for some companies

00:13:19,040 --> 00:13:22,560
some companies impose you to put that

00:13:21,760 --> 00:13:26,320
why

00:13:22,560 --> 00:13:28,320
well i guess with um

00:13:26,320 --> 00:13:30,160
in books they used to say that this was

00:13:28,320 --> 00:13:32,320
the right thing to do

00:13:30,160 --> 00:13:34,000
if you do slice up this with one box

00:13:32,320 --> 00:13:36,320
which is a recent gcc

00:13:34,000 --> 00:13:37,519
you'll see it as 40 bytes 40 bytes even

00:13:36,320 --> 00:13:39,440
though the string is not that big

00:13:37,519 --> 00:13:40,800
because there's a vtbl in your class

00:13:39,440 --> 00:13:42,240
because you had at least one virtual

00:13:40,800 --> 00:13:43,680
function so it has to generate more and

00:13:42,240 --> 00:13:45,279
more stuff

00:13:43,680 --> 00:13:47,839
if you just remove virtual well you're

00:13:45,279 --> 00:13:49,519
going bound down to 32

00:13:47,839 --> 00:13:52,079
you just saved eight bytes per person so

00:13:49,519 --> 00:13:53,920
it's kind of nice

00:13:52,079 --> 00:13:55,680
it's well it's not for one person it's

00:13:53,920 --> 00:13:58,959
for a whole set of persons that

00:13:55,680 --> 00:14:01,279
it becomes interesting

00:13:58,959 --> 00:14:02,000
so why why do people recommend that or

00:14:01,279 --> 00:14:03,760
where do some

00:14:02,000 --> 00:14:05,440
people recommend that well they should

00:14:03,760 --> 00:14:07,600
maybe get on with the program of c

00:14:05,440 --> 00:14:09,760
plus because it's been a long while

00:14:07,600 --> 00:14:11,519
since we we've known that you shouldn't

00:14:09,760 --> 00:14:12,959
spread virtual over the place without

00:14:11,519 --> 00:14:15,600
reasons part of the design

00:14:12,959 --> 00:14:16,000
see but some some books say you should

00:14:15,600 --> 00:14:17,680
do that

00:14:16,000 --> 00:14:19,440
in some schools sadly still say you

00:14:17,680 --> 00:14:20,160
should do that because some instructors

00:14:19,440 --> 00:14:22,399
i guess

00:14:20,160 --> 00:14:23,680
should maybe get their their act in

00:14:22,399 --> 00:14:25,040
shape

00:14:23,680 --> 00:14:26,320
because people used to think about the

00:14:25,040 --> 00:14:28,240
objector and the programming as

00:14:26,320 --> 00:14:28,880
hierarchies of classes with virtual

00:14:28,240 --> 00:14:31,360
calls

00:14:28,880 --> 00:14:33,920
jared spoke about that earlier this week

00:14:31,360 --> 00:14:36,639
so this is very unidiomatic c plus plus

00:14:33,920 --> 00:14:38,000
and and if you play with that uh old

00:14:36,639 --> 00:14:39,279
school kind of object generator

00:14:38,000 --> 00:14:40,800
programming from a c plus plus

00:14:39,279 --> 00:14:42,880
perspective of course because in other

00:14:40,800 --> 00:14:44,639
languages it's fine

00:14:42,880 --> 00:14:46,079
well it it plays against you that's not

00:14:44,639 --> 00:14:48,480
what situation is good at

00:14:46,079 --> 00:14:49,600
well it's just it works you can make it

00:14:48,480 --> 00:14:51,360
work but it's

00:14:49,600 --> 00:14:53,440
not necessarily a recommended way to do

00:14:51,360 --> 00:14:55,600
things

00:14:53,440 --> 00:14:57,360
so yeah if you do something like this

00:14:55,600 --> 00:14:58,480
which you see in the slide right now

00:14:57,360 --> 00:15:00,160
which is probably what you would see in

00:14:58,480 --> 00:15:02,240
a book too they would tell you oh well

00:15:00,160 --> 00:15:03,040
your destructor here is very dangerous

00:15:02,240 --> 00:15:04,320
you know

00:15:03,040 --> 00:15:06,240
because you have a virtual function

00:15:04,320 --> 00:15:08,639
there of course and your destructor is

00:15:06,240 --> 00:15:10,240
not virtual so it's suspicious

00:15:08,639 --> 00:15:12,000
because if you do something like this

00:15:10,240 --> 00:15:14,079
and you have a derived class

00:15:12,000 --> 00:15:15,600
and you're expecting the derived classes

00:15:14,079 --> 00:15:17,920
the structure to be called

00:15:15,600 --> 00:15:19,839
if you go through a base pointer or base

00:15:17,920 --> 00:15:21,360
reference

00:15:19,839 --> 00:15:24,079
well you'll notice that it won't be

00:15:21,360 --> 00:15:26,720
called which is wrong just bad

00:15:24,079 --> 00:15:28,160
but of course if you have a virtual

00:15:26,720 --> 00:15:29,759
function can it make sense to have a

00:15:28,160 --> 00:15:33,120
virtual instructor if you go

00:15:29,759 --> 00:15:35,680
through a some base class pointer of

00:15:33,120 --> 00:15:36,720
some kind you you delete you have to

00:15:35,680 --> 00:15:40,639
delete the right thing

00:15:36,720 --> 00:15:42,399
you know so sometimes you don't need one

00:15:40,639 --> 00:15:43,920
you don't need one at least typically

00:15:42,399 --> 00:15:45,199
speaking when you have another virtual

00:15:43,920 --> 00:15:47,040
function but

00:15:45,199 --> 00:15:48,480
there are reasons to have just a virtual

00:15:47,040 --> 00:15:50,320
instructor sometimes

00:15:48,480 --> 00:15:52,000
and we use cases for that you can write

00:15:50,320 --> 00:15:53,600
to me you want to know about them

00:15:52,000 --> 00:15:55,120
but you don't always need them you don't

00:15:53,600 --> 00:15:56,880
want to put them all over the place

00:15:55,120 --> 00:15:58,720
since you think you're both bigger

00:15:56,880 --> 00:16:00,560
and there's nothing coming back at you

00:15:58,720 --> 00:16:03,440
there's no benefit

00:16:00,560 --> 00:16:05,279
well in most cases at least so it

00:16:03,440 --> 00:16:06,720
implies adding a vtbl

00:16:05,279 --> 00:16:08,000
you might want to use an enemy cast or

00:16:06,720 --> 00:16:09,360
something but again if you don't have

00:16:08,000 --> 00:16:11,600
any other virtual service

00:16:09,360 --> 00:16:13,440
why would you do that no so it's it's

00:16:11,600 --> 00:16:15,440
fine if you do that if you have benefits

00:16:13,440 --> 00:16:17,120
but if you do that mechanically without

00:16:15,440 --> 00:16:19,839
thinking

00:16:17,120 --> 00:16:19,839
that's hurtful

00:16:20,160 --> 00:16:23,839
yeah the problem is the mechanically the

00:16:22,880 --> 00:16:26,320
out of edit thing

00:16:23,839 --> 00:16:27,360
the not thinking before coding thing

00:16:26,320 --> 00:16:30,240
that's very very bad

00:16:27,360 --> 00:16:30,240
we'll get back to that

00:16:33,120 --> 00:16:36,560
i often have discussions with people

00:16:35,040 --> 00:16:38,399
about this issue

00:16:36,560 --> 00:16:40,160
like should we initialize everything to

00:16:38,399 --> 00:16:42,240
zero there are advocates for that uh

00:16:40,160 --> 00:16:45,440
or two to some value or initialize

00:16:42,240 --> 00:16:48,480
everything you know whatever

00:16:45,440 --> 00:16:51,279
um i have an interesting case there see

00:16:48,480 --> 00:16:52,880
i did this this main function is trying

00:16:51,279 --> 00:16:56,800
to read an integer

00:16:52,880 --> 00:16:56,800
and and and print something if it's odd

00:16:57,279 --> 00:17:01,279
but mandating in such a case

00:16:59,920 --> 00:17:04,079
initializing

00:17:01,279 --> 00:17:05,679
n to zero it's a bit counterproductive

00:17:04,079 --> 00:17:09,039
you're going to write to it in a second

00:17:05,679 --> 00:17:10,480
isn't it so it's just zero wait a second

00:17:09,039 --> 00:17:10,880
it's not just zero it's more complicated

00:17:10,480 --> 00:17:12,720
than that

00:17:10,880 --> 00:17:14,079
there might be other impacts to that

00:17:12,720 --> 00:17:17,120
initialization

00:17:14,079 --> 00:17:19,520
in the machine there's another one there

00:17:17,120 --> 00:17:20,720
there's no ratio okay mexi insights with

00:17:19,520 --> 00:17:22,559
zeros

00:17:20,720 --> 00:17:23,760
and then i'm putting values in them

00:17:22,559 --> 00:17:27,120
afterwards

00:17:23,760 --> 00:17:29,039
well the initial initialization to zero

00:17:27,120 --> 00:17:30,799
it's not necessarily a zero cost thing

00:17:29,039 --> 00:17:32,559
there there's

00:17:30,799 --> 00:17:34,240
you're not in the uh you don't pay for

00:17:32,559 --> 00:17:35,360
what you don't use kind of category in

00:17:34,240 --> 00:17:36,880
this case while you're using it of

00:17:35,360 --> 00:17:40,799
course who you are but still

00:17:36,880 --> 00:17:43,760
what's the point you know this again

00:17:40,799 --> 00:17:45,039
this one is more innocuous but i i'm

00:17:43,760 --> 00:17:46,799
still calling for the

00:17:45,039 --> 00:17:49,120
calling the default constructor of all

00:17:46,799 --> 00:17:50,799
my strings this is an untrivial array of

00:17:49,120 --> 00:17:52,799
creating there it's there's costs in

00:17:50,799 --> 00:17:56,400
there there's a number of function calls

00:17:52,799 --> 00:18:00,000
in that line in bold

00:17:56,400 --> 00:18:01,200
it's not trivial this is something so

00:18:00,000 --> 00:18:04,000
making a vector

00:18:01,200 --> 00:18:05,360
and then reserving instead of resizing

00:18:04,000 --> 00:18:08,080
in such a way that you allocate the

00:18:05,360 --> 00:18:09,919
space without initializing the things

00:18:08,080 --> 00:18:11,280
and then pushing back the strings or and

00:18:09,919 --> 00:18:13,840
placing backs

00:18:11,280 --> 00:18:14,640
we'll get very similar code in this case

00:18:13,840 --> 00:18:16,320
um

00:18:14,640 --> 00:18:17,520
surprisingly enough though i tested this

00:18:16,320 --> 00:18:19,039
because i was convinced it would be

00:18:17,520 --> 00:18:19,600
faster and it depends on the compilers

00:18:19,039 --> 00:18:21,360
for some

00:18:19,600 --> 00:18:23,039
weird reason that i don't know some

00:18:21,360 --> 00:18:24,640
competitors still do better with their

00:18:23,039 --> 00:18:25,200
in the vector even though they're paying

00:18:24,640 --> 00:18:26,960
for the

00:18:25,200 --> 00:18:28,559
initialization so there might be

00:18:26,960 --> 00:18:30,160
interesting optimizations that the

00:18:28,559 --> 00:18:31,840
compilers see

00:18:30,160 --> 00:18:33,679
that they can do because it's like

00:18:31,840 --> 00:18:36,080
trivial new or something

00:18:33,679 --> 00:18:37,200
but still conceptually speaking i have

00:18:36,080 --> 00:18:39,039
less

00:18:37,200 --> 00:18:40,960
wasted code in this case than in the

00:18:39,039 --> 00:18:42,640
previous one

00:18:40,960 --> 00:18:46,160
module optimizations that the compilers

00:18:42,640 --> 00:18:46,160
do because they're very very bright

00:18:46,400 --> 00:18:52,880
yeah anyway

00:18:49,760 --> 00:18:53,919
i i i i'll go back a slide this is

00:18:52,880 --> 00:18:57,200
annoying because

00:18:53,919 --> 00:19:00,000
it's it's difficult to write

00:18:57,200 --> 00:19:01,919
efficient code if the optimizer is so

00:19:00,000 --> 00:19:03,039
good that the things that look good look

00:19:01,919 --> 00:19:04,240
bad in the end so

00:19:03,039 --> 00:19:06,480
usually you should measure what you're

00:19:04,240 --> 00:19:06,480
doing

00:19:06,559 --> 00:19:09,760
this is another case i'm using a string

00:19:09,120 --> 00:19:11,840
view

00:19:09,760 --> 00:19:13,039
string q is good i like to knew myself

00:19:11,840 --> 00:19:14,400
and i'm storing the string

00:19:13,039 --> 00:19:16,640
but you know there's wasteful stuff

00:19:14,400 --> 00:19:17,679
there because i most of you will

00:19:16,640 --> 00:19:20,160
probably know why i

00:19:17,679 --> 00:19:21,200
wasted the default constructor of my

00:19:20,160 --> 00:19:23,600
string in person

00:19:21,200 --> 00:19:24,320
because i'm overwriting the default

00:19:23,600 --> 00:19:26,640
value

00:19:24,320 --> 00:19:28,000
with something else with an assignment

00:19:26,640 --> 00:19:29,520
you'd be surprised

00:19:28,000 --> 00:19:31,280
especially when you're mixing people

00:19:29,520 --> 00:19:33,200
from different language backgrounds

00:19:31,280 --> 00:19:34,320
and how many think this is a low cost

00:19:33,200 --> 00:19:36,000
operation because they're used to

00:19:34,320 --> 00:19:38,400
strings being references to some

00:19:36,000 --> 00:19:39,679
immutable thing outside

00:19:38,400 --> 00:19:42,240
because that's what it is in java

00:19:39,679 --> 00:19:43,760
javascript or c-sharp whatever

00:19:42,240 --> 00:19:45,440
and in this case well we have an actual

00:19:43,760 --> 00:19:46,720
object and assignment

00:19:45,440 --> 00:19:48,400
has different meaning you're not

00:19:46,720 --> 00:19:50,000
pointing to something you're replacing

00:19:48,400 --> 00:19:52,240
content with something else

00:19:50,000 --> 00:19:53,120
so there's a cost to default default

00:19:52,240 --> 00:19:56,400
object that you

00:19:53,120 --> 00:19:58,640
just created in this case for nothing

00:19:56,400 --> 00:20:01,280
of course as you probably know we can do

00:19:58,640 --> 00:20:01,280
better than this

00:20:01,360 --> 00:20:05,720
if you're if you have a guideline that's

00:20:03,200 --> 00:20:07,120
telling you do not leave any variable

00:20:05,720 --> 00:20:09,760
uninitialized

00:20:07,120 --> 00:20:11,440
well there can be really big costs for

00:20:09,760 --> 00:20:14,720
nothing if you look at these two

00:20:11,440 --> 00:20:16,159
f and g there the one in f which is

00:20:14,720 --> 00:20:19,120
generating values

00:20:16,159 --> 00:20:20,880
in an array as uh the array is

00:20:19,120 --> 00:20:21,919
essentially trivially initialized

00:20:20,880 --> 00:20:23,440
essentially uh

00:20:21,919 --> 00:20:25,360
at the beginning because the values

00:20:23,440 --> 00:20:28,240
there we do nothing with them

00:20:25,360 --> 00:20:29,600
and the bottom i'm zeroing them before

00:20:28,240 --> 00:20:32,080
generating the values

00:20:29,600 --> 00:20:34,000
well if you look at the generated code

00:20:32,080 --> 00:20:36,799
you see there's a totally wasted one set

00:20:34,000 --> 00:20:37,440
there so maybe maybe there's upsides to

00:20:36,799 --> 00:20:38,880
that

00:20:37,440 --> 00:20:42,320
you have to see on some specific

00:20:38,880 --> 00:20:44,159
hardware but it's wasted code mostly

00:20:42,320 --> 00:20:45,520
so some guidelines you have to wonder

00:20:44,159 --> 00:20:47,919
yeah is that

00:20:45,520 --> 00:20:50,880
do we take them too literally maybe or

00:20:47,919 --> 00:20:50,880
is it the right thing to do

00:20:51,039 --> 00:20:55,039
yeah so there are ways to reduce that

00:20:53,280 --> 00:20:56,880
problem though especially for those

00:20:55,039 --> 00:20:58,880
to be initialized variables so those

00:20:56,880 --> 00:20:59,679
that you you could put a default value

00:20:58,880 --> 00:21:01,440
in there but just

00:20:59,679 --> 00:21:03,280
you're going to overwrite them anyway in

00:21:01,440 --> 00:21:04,640
a second so you're kind of wondering if

00:21:03,280 --> 00:21:06,000
it's a good thing to do

00:21:04,640 --> 00:21:08,000
so the first thing you can do to help

00:21:06,000 --> 00:21:10,159
yourself is write shorter functions

00:21:08,000 --> 00:21:11,919
so sharp functions they tend to make

00:21:10,159 --> 00:21:14,240
that problem kind of go away

00:21:11,919 --> 00:21:16,000
be very very restricted to a very small

00:21:14,240 --> 00:21:17,919
space you know

00:21:16,000 --> 00:21:19,280
and the second one is declare variables

00:21:17,919 --> 00:21:21,840
when you're using them

00:21:19,280 --> 00:21:22,799
which we used not to tell people not to

00:21:21,840 --> 00:21:24,880
do like

00:21:22,799 --> 00:21:26,320
a few decades ago but with the languages

00:21:24,880 --> 00:21:28,400
that we have today well it's

00:21:26,320 --> 00:21:29,919
pretty much the best thing to do so you

00:21:28,400 --> 00:21:31,440
declare your variables when you're ready

00:21:29,919 --> 00:21:33,600
to use them

00:21:31,440 --> 00:21:35,520
and in this way user constructors

00:21:33,600 --> 00:21:37,840
instead of assignments and you have less

00:21:35,520 --> 00:21:39,520
junk laying around all over the place so

00:21:37,840 --> 00:21:41,440
if you take these two together you tend

00:21:39,520 --> 00:21:43,440
to get a lot of benefits especially

00:21:41,440 --> 00:21:46,240
uh sometimes you can from our video

00:21:43,440 --> 00:21:46,240
which is pretty nice

00:21:48,799 --> 00:21:54,240
i took this one from mr lavalay i hope

00:21:51,919 --> 00:21:55,120
i spoke his word right stephanie if i if

00:21:54,240 --> 00:21:58,400
i made a mistake

00:21:55,120 --> 00:21:59,840
i'm sorry it's it's a nice class to show

00:21:58,400 --> 00:22:01,760
how move semantics work

00:21:59,840 --> 00:22:02,960
to people because it's just a class that

00:22:01,760 --> 00:22:04,159
does nothing but

00:22:02,960 --> 00:22:06,159
tells you what it's doing when it's

00:22:04,159 --> 00:22:08,799
doing nothing so it's telling you if i'm

00:22:06,159 --> 00:22:11,039
doing an assignment or a destruction or

00:22:08,799 --> 00:22:12,159
a default constructor where did you

00:22:11,039 --> 00:22:13,679
so if you're trying to figure out what

00:22:12,159 --> 00:22:14,960
your code does sometimes and if you're

00:22:13,679 --> 00:22:16,799
doing the right thing

00:22:14,960 --> 00:22:19,520
well it leaves a trace to let you think

00:22:16,799 --> 00:22:19,520
about what you're doing

00:22:21,679 --> 00:22:24,799
so look at this code for a few seconds

00:22:24,080 --> 00:22:26,320
so you can see

00:22:24,799 --> 00:22:28,799
this code starts at the first light of

00:22:26,320 --> 00:22:31,600
main noisy n semicolon and then it's

00:22:28,799 --> 00:22:34,480
calling n equals f of n

00:22:31,600 --> 00:22:37,120
and then you have function f that takes

00:22:34,480 --> 00:22:38,880
n by value and does a few things

00:22:37,120 --> 00:22:41,200
so take a few seconds i'm going to take

00:22:38,880 --> 00:22:44,000
a

00:22:41,200 --> 00:22:45,200
slight bit of coffee look at it and

00:22:44,000 --> 00:22:47,520
think about what it's going to print on

00:22:45,200 --> 00:22:47,520
screen

00:22:48,880 --> 00:22:52,000
the rain most people are pretty much

00:22:50,559 --> 00:22:55,760
okay until the return and

00:22:52,000 --> 00:22:57,039
f then becomes a bit more hairy

00:22:55,760 --> 00:22:58,880
so you probably guessed that there's a

00:22:57,039 --> 00:22:59,919
default constructor in there and then

00:22:58,880 --> 00:23:02,960
there's a copy

00:22:59,919 --> 00:23:04,799
with the call of f of n and then there's

00:23:02,960 --> 00:23:07,600
another default constructor with an

00:23:04,799 --> 00:23:08,640
if for variable m and then there's an

00:23:07,600 --> 00:23:10,880
assignment

00:23:08,640 --> 00:23:12,480
and then it gets it becomes a bit more

00:23:10,880 --> 00:23:13,600
complicated to follow so this is pretty

00:23:12,480 --> 00:23:17,039
much what you're going to get

00:23:13,600 --> 00:23:19,520
see so the first line is the n in main

00:23:17,039 --> 00:23:20,240
the second one is the n in f the third

00:23:19,520 --> 00:23:23,679
one is the

00:23:20,240 --> 00:23:26,000
m and f then you have your assignment

00:23:23,679 --> 00:23:27,200
and interestingly enough after that you

00:23:26,000 --> 00:23:29,679
have the

00:23:27,200 --> 00:23:30,799
move assignment because there is no

00:23:29,679 --> 00:23:34,240
point for f

00:23:30,799 --> 00:23:36,559
to keep m intact because it's going to

00:23:34,240 --> 00:23:38,640
die anyway so it's moving out

00:23:36,559 --> 00:23:39,679
and then there's the destructor of your

00:23:38,640 --> 00:23:41,440
local m

00:23:39,679 --> 00:23:42,880
of your local m and in the end the

00:23:41,440 --> 00:23:44,240
destructor of n

00:23:42,880 --> 00:23:47,039
in main so that's pretty much what's

00:23:44,240 --> 00:23:49,279
going to happen in this case

00:23:47,039 --> 00:23:51,679
so so yeah there's a lot of noise there

00:23:49,279 --> 00:23:53,200
and this is not very good code

00:23:51,679 --> 00:23:54,799
so if we just make this little change so

00:23:53,200 --> 00:23:57,679
let's go back one see

00:23:54,799 --> 00:23:58,000
now i see m m equals n and f and then

00:23:57,679 --> 00:24:00,480
you

00:23:58,000 --> 00:24:02,320
look at this this should lead to the

00:24:00,480 --> 00:24:04,799
same kind of behavior

00:24:02,320 --> 00:24:05,919
but since we are leaving a trace what

00:24:04,799 --> 00:24:06,480
we're doing we'll see a difference in

00:24:05,919 --> 00:24:08,960
this case

00:24:06,480 --> 00:24:10,159
we're replacing a default constructor

00:24:08,960 --> 00:24:12,159
and an assignment

00:24:10,159 --> 00:24:14,960
with a copy constructor because this is

00:24:12,159 --> 00:24:16,320
a copy constructor

00:24:14,960 --> 00:24:18,080
and this is actually better code than

00:24:16,320 --> 00:24:20,320
the previous one

00:24:18,080 --> 00:24:22,159
because assignment requires to remove

00:24:20,320 --> 00:24:22,559
what was there before and put something

00:24:22,159 --> 00:24:24,880
else

00:24:22,559 --> 00:24:27,840
instead so it's most most of the time

00:24:24,880 --> 00:24:29,919
it's more costly in construction

00:24:27,840 --> 00:24:33,120
so fair enough now if you make it a bit

00:24:29,919 --> 00:24:34,400
simpler oops

00:24:33,120 --> 00:24:36,880
this is a bit nicer it becomes

00:24:34,400 --> 00:24:38,320
interesting slightly sometimes people

00:24:36,880 --> 00:24:42,000
overestimate this one

00:24:38,320 --> 00:24:44,640
so if we go back one we had this

00:24:42,000 --> 00:24:47,120
where we made a local copy of n in the m

00:24:44,640 --> 00:24:49,120
and then return that local copy

00:24:47,120 --> 00:24:51,360
to this we just returned which just

00:24:49,120 --> 00:24:53,520
returns m

00:24:51,360 --> 00:24:56,880
going back again so i have two

00:24:53,520 --> 00:24:58,640
constructors and a move assignment

00:24:56,880 --> 00:25:00,159
when i get there sometimes people hope

00:24:58,640 --> 00:25:03,200
for a lot of code to be removed

00:25:00,159 --> 00:25:06,400
but a bit see

00:25:03,200 --> 00:25:07,279
there's there's a a a move constructor

00:25:06,400 --> 00:25:10,720
being used there

00:25:07,279 --> 00:25:12,159
uh for the the return value because the

00:25:10,720 --> 00:25:12,720
the local will be destroyed at some

00:25:12,159 --> 00:25:14,080
point and

00:25:12,720 --> 00:25:15,279
you have to make temporary and stuff but

00:25:14,080 --> 00:25:16,559
this is pretty much what you end up with

00:25:15,279 --> 00:25:17,760
that's nice

00:25:16,559 --> 00:25:20,000
there's still your move assignment

00:25:17,760 --> 00:25:21,919
there's still three objects involved

00:25:20,000 --> 00:25:23,039
uh yeah because there's the thing we've

00:25:21,919 --> 00:25:24,799
been returned from f

00:25:23,039 --> 00:25:26,559
that has to generate some code at some

00:25:24,799 --> 00:25:29,600
point

00:25:26,559 --> 00:25:31,279
now look at main now that now is the n n

00:25:29,600 --> 00:25:33,600
equals f of n

00:25:31,279 --> 00:25:35,120
this is unpleasant because we're we're

00:25:33,600 --> 00:25:37,520
sub optimal in the way we write code in

00:25:35,120 --> 00:25:37,520
this case

00:25:38,880 --> 00:25:42,080
if you put it this way this is starting

00:25:41,360 --> 00:25:45,200
to get nice

00:25:42,080 --> 00:25:46,159
a bit see i was using if i go back one

00:25:45,200 --> 00:25:48,720
slide again

00:25:46,159 --> 00:25:49,600
i was using a default object that had a

00:25:48,720 --> 00:25:52,159
name

00:25:49,600 --> 00:25:53,039
to pass to f which will return something

00:25:52,159 --> 00:25:54,880
with it

00:25:53,039 --> 00:25:56,400
so if i just remove the name from the

00:25:54,880 --> 00:25:58,559
default object and just create it

00:25:56,400 --> 00:25:59,919
on on the call site without naming it so

00:25:58,559 --> 00:26:02,320
i am enabling

00:25:59,919 --> 00:26:03,520
interesting things more than more than

00:26:02,320 --> 00:26:05,440
you might think in this case i mean

00:26:03,520 --> 00:26:06,559
enabling the move initially instead of a

00:26:05,440 --> 00:26:09,279
copy because it's an

00:26:06,559 --> 00:26:10,559
unnamed object but real gain in this

00:26:09,279 --> 00:26:13,120
case is that i'm creating

00:26:10,559 --> 00:26:16,640
n from the return value of f which

00:26:13,120 --> 00:26:18,320
enables our view this is pretty neat

00:26:16,640 --> 00:26:22,320
so there's this is a significant upgrade

00:26:18,320 --> 00:26:22,320
in code quality if i go back to slides

00:26:22,559 --> 00:26:31,120
look at this then i move

00:26:25,679 --> 00:26:31,120
up two slides it's pretty significant

00:26:31,520 --> 00:26:36,159
pretty nice isn't it and this this is

00:26:33,760 --> 00:26:37,840
just kodai gene

00:26:36,159 --> 00:26:40,400
now you should look at this one whoops

00:26:37,840 --> 00:26:40,400
not this one

00:26:40,559 --> 00:26:45,919
this one is actually is actually funny

00:26:43,600 --> 00:26:47,440
think about it for a second this makes

00:26:45,919 --> 00:26:48,960
sense if there's only one

00:26:47,440 --> 00:26:50,720
f and this argument is default

00:26:48,960 --> 00:26:52,640
constructable

00:26:50,720 --> 00:26:53,919
but let's still no it doesn't generate

00:26:52,640 --> 00:26:55,360
any better code by the way

00:26:53,919 --> 00:26:57,200
it's just funny because you're going to

00:26:55,360 --> 00:26:59,200
bar have a beer with people or a glass

00:26:57,200 --> 00:27:00,960
of something interesting

00:26:59,200 --> 00:27:02,960
and you put that and they think it

00:27:00,960 --> 00:27:04,400
doesn't work but it works fine

00:27:02,960 --> 00:27:06,480
it's just it's not any better and you

00:27:04,400 --> 00:27:08,880
won't get a job with it but it's

00:27:06,480 --> 00:27:08,880
amusing

00:27:09,760 --> 00:27:14,559
yeah and of course this is even nicer

00:27:12,640 --> 00:27:16,400
because you see there's a

00:27:14,559 --> 00:27:18,559
only the minimal stuff that we need to

00:27:16,400 --> 00:27:20,559
do in our code

00:27:18,559 --> 00:27:22,000
and of course the benefits are very

00:27:20,559 --> 00:27:23,919
strong

00:27:22,000 --> 00:27:25,360
so unnecessarily unnecessary

00:27:23,919 --> 00:27:26,080
initialization if you compare from the

00:27:25,360 --> 00:27:29,120
beginning

00:27:26,080 --> 00:27:32,799
to the end just paying attention to what

00:27:29,120 --> 00:27:32,799
we do there's significant gains

00:27:33,440 --> 00:27:38,399
yeah so when you have a very small scope

00:27:37,520 --> 00:27:40,399
for a variable

00:27:38,399 --> 00:27:42,399
you can turn the code at the top with

00:27:40,399 --> 00:27:43,120
the variable and the character of the if

00:27:42,399 --> 00:27:45,279
the if

00:27:43,120 --> 00:27:47,120
into the bottom where it's local to the

00:27:45,279 --> 00:27:49,919
if that's actually pretty neat

00:27:47,120 --> 00:27:51,760
thomas copper did that so i i like that

00:27:49,919 --> 00:27:53,840
feature that some people don't but i

00:27:51,760 --> 00:27:56,000
like it of course this this supposes

00:27:53,840 --> 00:27:56,880
that the scope of your variable is local

00:27:56,000 --> 00:27:58,880
to your your

00:27:56,880 --> 00:28:00,480
if statement and the accompanying else

00:27:58,880 --> 00:28:03,919
if any

00:28:00,480 --> 00:28:05,679
but yeah the the uninitializedness of n

00:28:03,919 --> 00:28:07,360
is a lot less annoying if it's part

00:28:05,679 --> 00:28:09,039
kind of part of the same statement in a

00:28:07,360 --> 00:28:11,360
sense so this

00:28:09,039 --> 00:28:13,120
might meet the expectations of your

00:28:11,360 --> 00:28:15,200
company if they really want things to be

00:28:13,120 --> 00:28:18,320
initialized whenever you use them

00:28:15,200 --> 00:28:20,000
because it kind of looks like it and of

00:28:18,320 --> 00:28:20,720
course there's ways to go around it if n

00:28:20,000 --> 00:28:23,279
has to live

00:28:20,720 --> 00:28:25,039
longer you can use an optional of some

00:28:23,279 --> 00:28:26,559
sort so there's this consume

00:28:25,039 --> 00:28:28,640
function that i put there that returns

00:28:26,559 --> 00:28:30,399
an optional end that might or might not

00:28:28,640 --> 00:28:33,440
be initialized

00:28:30,399 --> 00:28:35,760
but yeah yeah it it it works but uh

00:28:33,440 --> 00:28:38,000
it's it's it's a bit there's some space

00:28:35,760 --> 00:28:39,600
it's a bit more involved

00:28:38,000 --> 00:28:41,039
i'm still wondering why we shouldn't shy

00:28:39,600 --> 00:28:43,840
these things if we're about to

00:28:41,039 --> 00:28:45,279
rewrite to them just after but that's me

00:28:43,840 --> 00:28:46,960
so

00:28:45,279 --> 00:28:48,720
if you write very long functions with

00:28:46,960 --> 00:28:51,360
uninsights variables at the top

00:28:48,720 --> 00:28:52,960
that you might use at the bottom just

00:28:51,360 --> 00:28:56,000
write short for shorter functions that's

00:28:52,960 --> 00:28:56,000
the best your best bet

00:28:56,840 --> 00:29:01,120
yeah sharp is a weird one

00:28:59,679 --> 00:29:02,640
it's interesting to talk about it i am

00:29:01,120 --> 00:29:04,080
not going to push for that i'm telling

00:29:02,640 --> 00:29:05,919
you right away but still

00:29:04,080 --> 00:29:07,360
they have art out arguments in c sharp

00:29:05,919 --> 00:29:10,159
so out are pure uh

00:29:07,360 --> 00:29:12,559
outputs so the caller doesn't have to

00:29:10,159 --> 00:29:14,000
initialize them the kali has to write to

00:29:12,559 --> 00:29:15,120
them regardless of what it does it has

00:29:14,000 --> 00:29:17,520
to write something

00:29:15,120 --> 00:29:18,480
even if it tried to do some io when it

00:29:17,520 --> 00:29:20,880
failed it still has

00:29:18,480 --> 00:29:22,240
to write to the the variable so when you

00:29:20,880 --> 00:29:26,159
have a call like the one on top

00:29:22,240 --> 00:29:28,399
and n f out n that means f has to write

00:29:26,159 --> 00:29:29,440
to n so you can pass an uninitial

00:29:28,399 --> 00:29:30,880
variable to the

00:29:29,440 --> 00:29:33,440
function that's perfectly fine it's

00:29:30,880 --> 00:29:34,240
written like this you can actually call

00:29:33,440 --> 00:29:37,039
it

00:29:34,240 --> 00:29:37,760
as you can see a bit below f of paren

00:29:37,039 --> 00:29:41,039
out and

00:29:37,760 --> 00:29:43,200
n so this looks like like a signature

00:29:41,039 --> 00:29:44,559
it's missing the return type but it's

00:29:43,200 --> 00:29:46,799
actually a valid call in c

00:29:44,559 --> 00:29:48,320
sharp and it's a declaration in the

00:29:46,799 --> 00:29:51,360
definition of course

00:29:48,320 --> 00:29:52,480
a variable n uh at the call site and it

00:29:51,360 --> 00:29:54,720
lives from that point on

00:29:52,480 --> 00:29:56,320
the scope in which it is but it's just

00:29:54,720 --> 00:29:57,600
too weird for its blood first plus plus

00:29:56,320 --> 00:30:00,320
and i don't really like it

00:29:57,600 --> 00:30:02,080
but the the advantage of this is if your

00:30:00,320 --> 00:30:04,240
company has a guideline that says you

00:30:02,080 --> 00:30:05,520
have to initialize your variables when

00:30:04,240 --> 00:30:07,440
you declare them

00:30:05,520 --> 00:30:09,279
well this this forces initialization

00:30:07,440 --> 00:30:10,720
you're sure that after the call to f it

00:30:09,279 --> 00:30:13,200
will be initialized

00:30:10,720 --> 00:30:15,600
but i still don't want that in c plus it

00:30:13,200 --> 00:30:15,600
exists

00:30:16,559 --> 00:30:21,120
so let's return to these things that we

00:30:18,080 --> 00:30:23,919
do without thinking because they're bad

00:30:21,120 --> 00:30:24,960
so this is personal pet peeve again it's

00:30:23,919 --> 00:30:26,240
it's java code

00:30:24,960 --> 00:30:28,399
it's not because it's job i don't mind

00:30:26,240 --> 00:30:31,039
java i don't like it

00:30:28,399 --> 00:30:31,440
but i don't mind it but what my what i

00:30:31,039 --> 00:30:33,039
mind

00:30:31,440 --> 00:30:34,799
is that getting set paired people right

00:30:33,039 --> 00:30:37,120
without thinking

00:30:34,799 --> 00:30:39,200
that sometimes it makes sense sometimes

00:30:37,120 --> 00:30:40,720
your tool forces you to do that because

00:30:39,200 --> 00:30:43,840
it's idiomatic in the language and

00:30:40,720 --> 00:30:46,799
people take a a habit of doing that but

00:30:43,840 --> 00:30:47,840
is that a proper interface why would in

00:30:46,799 --> 00:30:49,600
general

00:30:47,840 --> 00:30:51,440
you need something to get for everything

00:30:49,600 --> 00:30:52,399
in your class is that the proper

00:30:51,440 --> 00:30:55,039
interface is that

00:30:52,399 --> 00:30:56,559
appropriate to the domain model the

00:30:55,039 --> 00:30:57,840
middle domain

00:30:56,559 --> 00:30:59,360
c sharp is the same thing but a bit

00:30:57,840 --> 00:31:01,600
shorter because they have this property

00:30:59,360 --> 00:31:03,279
thing where you have both

00:31:01,600 --> 00:31:06,559
guests and set it should be public in

00:31:03,279 --> 00:31:10,000
this case i forgot to put public on it

00:31:06,559 --> 00:31:11,840
but why why would

00:31:10,000 --> 00:31:13,240
it should be public for my example but

00:31:11,840 --> 00:31:15,519
why why is why

00:31:13,240 --> 00:31:16,720
systematically put yet sunsets what's

00:31:15,519 --> 00:31:18,480
the point of that

00:31:16,720 --> 00:31:20,640
does it describe the right thing is it

00:31:18,480 --> 00:31:23,840
the proper interface what you're doing

00:31:20,640 --> 00:31:24,399
maybe it is but it's not mechanical it's

00:31:23,840 --> 00:31:27,600
not

00:31:24,399 --> 00:31:27,600
something that should be automatic

00:31:28,240 --> 00:31:31,360
so i'm surprised when i look at the code

00:31:30,000 --> 00:31:32,720
people write how much of it is

00:31:31,360 --> 00:31:34,640
mechanical

00:31:32,720 --> 00:31:36,399
it used to be a bit tight to wizards i

00:31:34,640 --> 00:31:37,120
noticed the old wizards that we have

00:31:36,399 --> 00:31:38,720
with some

00:31:37,120 --> 00:31:40,080
of the ideas that we use the usage

00:31:38,720 --> 00:31:42,000
generate code they're not necessarily

00:31:40,080 --> 00:31:43,679
very good code

00:31:42,000 --> 00:31:45,760
but people you would say like create

00:31:43,679 --> 00:31:46,559
class and have border plate class that

00:31:45,760 --> 00:31:48,240
would have been

00:31:46,559 --> 00:31:50,480
faster to type by hand but it was

00:31:48,240 --> 00:31:52,159
something like that was very bad before

00:31:50,480 --> 00:31:54,080
i tested it recently for the sliding

00:31:52,159 --> 00:31:56,320
slides and today is much better

00:31:54,080 --> 00:32:00,320
but still i'm not sure it's worth going

00:31:56,320 --> 00:32:02,000
through a menu to do that

00:32:00,320 --> 00:32:03,600
so so there's nothing bad with gets and

00:32:02,000 --> 00:32:06,880
sets of course you can write them

00:32:03,600 --> 00:32:08,720
if they make sense the point is

00:32:06,880 --> 00:32:10,799
should you write them without thinking

00:32:08,720 --> 00:32:12,799
in a mechanical manner that's a totally

00:32:10,799 --> 00:32:14,480
different thing

00:32:12,799 --> 00:32:16,000
again it's astonishing how much of that

00:32:14,480 --> 00:32:18,000
what i see in a week

00:32:16,000 --> 00:32:20,320
you have to know that being a professor

00:32:18,000 --> 00:32:22,640
i see code written by

00:32:20,320 --> 00:32:23,519
uh the thing of people who are beginning

00:32:22,640 --> 00:32:26,559
their career

00:32:23,519 --> 00:32:28,000
in humongous amounts every week so and

00:32:26,559 --> 00:32:30,640
the west surprises means that when they

00:32:28,000 --> 00:32:32,159
get a job they still do that

00:32:30,640 --> 00:32:33,919
so there's there's other things we

00:32:32,159 --> 00:32:36,640
should think about before like just

00:32:33,919 --> 00:32:37,120
writing them you know things like this

00:32:36,640 --> 00:32:40,840
now i

00:32:37,120 --> 00:32:42,080
have this uh this default constructor

00:32:40,840 --> 00:32:43,679
there

00:32:42,080 --> 00:32:45,760
i have master's degree students who do

00:32:43,679 --> 00:32:46,960
that they put default constructors

00:32:45,760 --> 00:32:49,519
everywhere

00:32:46,960 --> 00:32:50,880
and and ask them what it means and

00:32:49,519 --> 00:32:51,360
sometimes they haven't thought about it

00:32:50,880 --> 00:32:53,440
they just

00:32:51,360 --> 00:32:55,200
did it see in this case what's the

00:32:53,440 --> 00:32:55,600
default person well it's a person with

00:32:55,200 --> 00:32:57,679
the

00:32:55,600 --> 00:32:59,279
null name because when you're doing new

00:32:57,679 --> 00:33:01,679
in java something it will initialize

00:32:59,279 --> 00:33:04,240
your references to no insight

00:33:01,679 --> 00:33:05,120
so does that have meaning in your code

00:33:04,240 --> 00:33:08,399
maybe

00:33:05,120 --> 00:33:10,880
but i'm guessing not

00:33:08,399 --> 00:33:12,960
you could do that too but then you have

00:33:10,880 --> 00:33:14,799
an empty name for your default person

00:33:12,960 --> 00:33:16,480
does that have meaning in your code

00:33:14,799 --> 00:33:19,760
maybe it does

00:33:16,480 --> 00:33:20,320
maybe it doesn't but it it deserves to

00:33:19,760 --> 00:33:25,200
be

00:33:20,320 --> 00:33:27,200
questioned or or thought about

00:33:25,200 --> 00:33:28,240
it's a sharp same thing in this case i

00:33:27,200 --> 00:33:29,760
have the same principle

00:33:28,240 --> 00:33:32,159
the name can only be read it should be

00:33:29,760 --> 00:33:33,679
public again it's my mistake

00:33:32,159 --> 00:33:35,360
but the default constructor in this case

00:33:33,679 --> 00:33:37,919
will give me a no reference

00:33:35,360 --> 00:33:39,919
so i'm getting a null name for my person

00:33:37,919 --> 00:33:43,120
was that the intent

00:33:39,919 --> 00:33:44,399
i'm clear and even this

00:33:43,120 --> 00:33:46,080
you have this default feature but

00:33:44,399 --> 00:33:47,840
default for reference gives you a null

00:33:46,080 --> 00:33:49,279
it doesn't give you an empty stream

00:33:47,840 --> 00:33:51,360
so you still get a null reference in

00:33:49,279 --> 00:33:52,559
this case people sometimes write that

00:33:51,360 --> 00:33:55,679
thinking well

00:33:52,559 --> 00:33:59,360
mechanical code this is the things we do

00:33:55,679 --> 00:33:59,360
but we should think about these things

00:33:59,600 --> 00:34:05,039
and again is a person with an empty name

00:34:02,799 --> 00:34:06,399
a proper person given the domain that

00:34:05,039 --> 00:34:08,639
you're working on

00:34:06,399 --> 00:34:10,800
might be might not be but the question

00:34:08,639 --> 00:34:12,560
deserves to be asked

00:34:10,800 --> 00:34:14,000
it's close to necessarily better than c

00:34:12,560 --> 00:34:15,280
plus plus the code that i have here in

00:34:14,000 --> 00:34:17,119
this case

00:34:15,280 --> 00:34:19,040
i did the same thing i have a default

00:34:17,119 --> 00:34:20,079
person so i'm getting an empty string

00:34:19,040 --> 00:34:21,839
because my string is an

00:34:20,079 --> 00:34:23,280
object not a reference to an object but

00:34:21,839 --> 00:34:25,760
still

00:34:23,280 --> 00:34:28,159
should i have done this should i have

00:34:25,760 --> 00:34:28,159
done this

00:34:29,040 --> 00:34:32,480
so interfaces carry meaning this is the

00:34:30,800 --> 00:34:34,960
kind of thing that my friend tony

00:34:32,480 --> 00:34:35,839
would talk about to even hear it so if

00:34:34,960 --> 00:34:37,440
you have

00:34:35,839 --> 00:34:39,839
if you can make sense of a default

00:34:37,440 --> 00:34:41,440
object of some type well that's fine to

00:34:39,839 --> 00:34:44,240
have a default constructor

00:34:41,440 --> 00:34:45,280
but what would a default person be i

00:34:44,240 --> 00:34:47,520
don't know any

00:34:45,280 --> 00:34:48,800
i don't know myself maybe they are but

00:34:47,520 --> 00:34:50,159
there are reasons yeah to do that

00:34:48,800 --> 00:34:51,440
sometimes you have concepts that you

00:34:50,159 --> 00:34:53,040
want to make regular

00:34:51,440 --> 00:34:54,560
you want to make a raise of some type

00:34:53,040 --> 00:34:57,520
tea so so

00:34:54,560 --> 00:34:58,160
fair enough if it makes sense to you go

00:34:57,520 --> 00:35:00,880
for it

00:34:58,160 --> 00:35:02,000
but think about it and we have to be

00:35:00,880 --> 00:35:04,240
wary without

00:35:02,000 --> 00:35:06,480
interfaces without clear meaning objects

00:35:04,240 --> 00:35:08,000
with a clear meaning

00:35:06,480 --> 00:35:10,560
we have to be wary of them at least look

00:35:08,000 --> 00:35:10,560
out for them

00:35:11,680 --> 00:35:14,960
this is another weird pet peeve that i

00:35:13,359 --> 00:35:16,560
have that people sometimes do

00:35:14,960 --> 00:35:17,520
mechanically and it scares me to be

00:35:16,560 --> 00:35:19,680
honest

00:35:17,520 --> 00:35:20,560
so we have this integral division thing

00:35:19,680 --> 00:35:22,320
that

00:35:20,560 --> 00:35:23,599
throws if you're trying to divide by

00:35:22,320 --> 00:35:25,839
zero

00:35:23,599 --> 00:35:27,040
fair enough and there's some important

00:35:25,839 --> 00:35:29,920
computation going on

00:35:27,040 --> 00:35:30,400
at the bottom now if you look at this

00:35:29,920 --> 00:35:32,880
it's

00:35:30,400 --> 00:35:34,480
initializing some value to minus one and

00:35:32,880 --> 00:35:36,960
then it's trying to do the division

00:35:34,480 --> 00:35:37,920
and it does the try catch right away and

00:35:36,960 --> 00:35:41,359
then it

00:35:37,920 --> 00:35:42,960
does what some people think as

00:35:41,359 --> 00:35:44,720
error management which is outputting

00:35:42,960 --> 00:35:48,560
something on screen and

00:35:44,720 --> 00:35:50,320
going ahead and continuing

00:35:48,560 --> 00:35:53,119
that scares me if it doesn't scares you

00:35:50,320 --> 00:35:55,119
if it doesn't scare you probably should

00:35:53,119 --> 00:35:56,960
the the initialization at first is a

00:35:55,119 --> 00:35:58,400
sign that something is wrong

00:35:56,960 --> 00:36:00,720
and we have an exception there that

00:35:58,400 --> 00:36:02,320
doesn't want to be cut it's a small

00:36:00,720 --> 00:36:04,000
creepy crawly monster

00:36:02,320 --> 00:36:06,400
and michael didn't want to be cut in the

00:36:04,000 --> 00:36:08,160
first place because there was nothing in

00:36:06,400 --> 00:36:09,359
important computation that would let me

00:36:08,160 --> 00:36:11,040
do anything about it

00:36:09,359 --> 00:36:12,400
anyway i'm not doing anything with it

00:36:11,040 --> 00:36:14,880
i'm just not putting on screen

00:36:12,400 --> 00:36:16,160
there's no management to speak of why do

00:36:14,880 --> 00:36:17,520
i then why do i

00:36:16,160 --> 00:36:19,599
even put the trial block there doesn't

00:36:17,520 --> 00:36:20,960
make any sense

00:36:19,599 --> 00:36:22,400
but some companies will force you to do

00:36:20,960 --> 00:36:23,760
that they will say you need to try a

00:36:22,400 --> 00:36:25,359
block when you have something i can't

00:36:23,760 --> 00:36:28,960
throw

00:36:25,359 --> 00:36:29,520
no and and the just the fact that we

00:36:28,960 --> 00:36:31,599
have some

00:36:29,520 --> 00:36:33,680
unnecessary initialization is a sign

00:36:31,599 --> 00:36:35,920
that something is wrong in my code

00:36:33,680 --> 00:36:38,160
because i'm doing this in case the try

00:36:35,920 --> 00:36:43,359
block fails

00:36:38,160 --> 00:36:43,359
what's the point really what's the point

00:36:44,160 --> 00:36:49,040
so when i see companies that say all

00:36:46,560 --> 00:36:50,640
exceptions should be caught

00:36:49,040 --> 00:36:52,560
sometimes people think that as should be

00:36:50,640 --> 00:36:53,680
caught at every step that's that's a

00:36:52,560 --> 00:36:57,200
mistake

00:36:53,680 --> 00:36:58,320
that's a mistake you have to do you have

00:36:57,200 --> 00:37:00,079
to have something to do to catch an

00:36:58,320 --> 00:37:01,599
exception

00:37:00,079 --> 00:37:03,280
if my function in this case important

00:37:01,599 --> 00:37:04,960
computation cannot meet its both

00:37:03,280 --> 00:37:06,800
conditions maybe that would be the right

00:37:04,960 --> 00:37:08,800
place to stop

00:37:06,800 --> 00:37:11,680
why continue i don't have anything of

00:37:08,800 --> 00:37:11,680
meaning to work with

00:37:12,400 --> 00:37:17,119
yeah and if i have to catch the

00:37:15,599 --> 00:37:18,720
exception and michael because that's

00:37:17,119 --> 00:37:20,320
what's being asked of me maybe this is

00:37:18,720 --> 00:37:23,040
not the right place to do so

00:37:20,320 --> 00:37:23,359
maybe it just just go up and up and up

00:37:23,040 --> 00:37:25,359
and say

00:37:23,359 --> 00:37:27,680
it doesn't one has enough context to

00:37:25,359 --> 00:37:30,000
react

00:37:27,680 --> 00:37:31,920
so this this this follows the letter of

00:37:30,000 --> 00:37:32,880
the law i'm catching and then rethrowing

00:37:31,920 --> 00:37:34,880
again

00:37:32,880 --> 00:37:36,960
then what's the point why did i do that

00:37:34,880 --> 00:37:40,880
i have nothing to manage in my code

00:37:36,960 --> 00:37:43,280
anyway this makes sense

00:37:40,880 --> 00:37:43,920
see it's nice it's simpler and if it

00:37:43,280 --> 00:37:47,440
fails

00:37:43,920 --> 00:37:49,200
so be it let the exception go back up

00:37:47,440 --> 00:37:52,079
maybe something will know someone will

00:37:49,200 --> 00:37:52,079
know what to do about it

00:37:53,760 --> 00:37:57,359
and if you really really need to catch

00:37:55,760 --> 00:37:59,280
everything well

00:37:57,359 --> 00:38:00,720
well first of all you need some context

00:37:59,280 --> 00:38:02,480
to do something about it

00:38:00,720 --> 00:38:04,400
and then you can just do this you know

00:38:02,480 --> 00:38:06,640
just sketch everything and

00:38:04,400 --> 00:38:08,560
do some lesbian detection to complain

00:38:06,640 --> 00:38:10,240
that something went really wrong

00:38:08,560 --> 00:38:12,000
but at least you followed the letter of

00:38:10,240 --> 00:38:14,240
the law you have to

00:38:12,000 --> 00:38:17,119
it was asked for a view you can put your

00:38:14,240 --> 00:38:18,800
man in a try block and be done with it

00:38:17,119 --> 00:38:20,560
for those who are wondering yes this is

00:38:18,800 --> 00:38:21,760
totally fine c plus plus

00:38:20,560 --> 00:38:25,200
there's nothing much you can do in the

00:38:21,760 --> 00:38:25,200
catch block but it's there

00:38:27,680 --> 00:38:31,040
this this is important the more you do

00:38:30,480 --> 00:38:33,839
non c

00:38:31,040 --> 00:38:35,599
plus code the more you miss const we're

00:38:33,839 --> 00:38:37,359
lucky to have const

00:38:35,599 --> 00:38:39,440
because correctness is not for speeds

00:38:37,359 --> 00:38:40,400
for hygiene it's for the quality of the

00:38:39,440 --> 00:38:44,400
message we're sending

00:38:40,400 --> 00:38:46,800
so look at this class it's something

00:38:44,400 --> 00:38:48,560
made for some kind of very very small

00:38:46,800 --> 00:38:50,000
and hypothetical game

00:38:48,560 --> 00:38:51,680
but there's cons member functions

00:38:50,000 --> 00:38:54,720
there's cons arguments stuff

00:38:51,680 --> 00:38:57,760
makes sense let's remove all the names

00:38:54,720 --> 00:39:00,160
see so i took the same class

00:38:57,760 --> 00:39:02,160
abstracted the names away my interface

00:39:00,160 --> 00:39:05,040
still has meaning

00:39:02,160 --> 00:39:06,480
cons is telling me things so it's i'm

00:39:05,040 --> 00:39:07,200
semantically disconnected from the

00:39:06,480 --> 00:39:08,800
original

00:39:07,200 --> 00:39:10,880
but there's still information i can get

00:39:08,800 --> 00:39:12,560
from the types

00:39:10,880 --> 00:39:14,000
i can see that my arguments won't be

00:39:12,560 --> 00:39:17,040
modified i can see that

00:39:14,000 --> 00:39:18,240
there are non-mutating functions i can

00:39:17,040 --> 00:39:20,800
see that i have

00:39:18,240 --> 00:39:22,880
a potentially mutating function in this

00:39:20,800 --> 00:39:25,359
case too so i know things about my class

00:39:22,880 --> 00:39:27,760
because my interface is clearer

00:39:25,359 --> 00:39:29,680
in new parts because of the presence and

00:39:27,760 --> 00:39:32,160
absence of const because that sense

00:39:29,680 --> 00:39:34,640
tells us something as others i said

00:39:32,160 --> 00:39:34,640
before me

00:39:36,000 --> 00:39:39,200
if i remove all the const it becomes

00:39:38,560 --> 00:39:42,240
much

00:39:39,200 --> 00:39:43,920
more difficult to reason about the code

00:39:42,240 --> 00:39:45,440
there's nothing here telling me what's

00:39:43,920 --> 00:39:47,760
right and what's wrong to call

00:39:45,440 --> 00:39:49,119
given some circumstances i have to read

00:39:47,760 --> 00:39:50,480
the documentation i guess

00:39:49,119 --> 00:39:53,920
and hope for the test because the

00:39:50,480 --> 00:39:53,920
compiler is not helping me anymore

00:39:54,880 --> 00:39:59,280
yeah so why isn't all c plus plus cold

00:39:57,760 --> 00:40:01,119
calls correct because

00:39:59,280 --> 00:40:02,720
it should why not well there are reasons

00:40:01,119 --> 00:40:04,800
i understand myself

00:40:02,720 --> 00:40:06,400
some people lots of people i meet come

00:40:04,800 --> 00:40:08,160
from other languages the concept doesn't

00:40:06,400 --> 00:40:09,440
even exist so why would they think about

00:40:08,160 --> 00:40:10,640
it they've never seen it in their lives

00:40:09,440 --> 00:40:12,400
before they don't know what the cost

00:40:10,640 --> 00:40:14,480
member function means

00:40:12,400 --> 00:40:16,240
sometimes you're integrating code from

00:40:14,480 --> 00:40:16,800
some other third-party library that

00:40:16,240 --> 00:40:19,119
doesn't

00:40:16,800 --> 00:40:20,480
have any correctness built inside so it

00:40:19,119 --> 00:40:22,319
kind of makes sense that you have to

00:40:20,480 --> 00:40:24,000
bend the rules a bit

00:40:22,319 --> 00:40:25,359
sometimes you have work environments

00:40:24,000 --> 00:40:27,200
that don't believe in it for some weird

00:40:25,359 --> 00:40:28,480
reason and say well you put constant

00:40:27,200 --> 00:40:30,800
there you gotta get into trouble it's

00:40:28,480 --> 00:40:34,720
bad everyone knows it

00:40:30,800 --> 00:40:37,200
that's scary the quotes down there

00:40:34,720 --> 00:40:38,720
are reworked from actual quotes i got

00:40:37,200 --> 00:40:40,400
with actual people

00:40:38,720 --> 00:40:42,720
doing work in the field and selling

00:40:40,400 --> 00:40:43,280
software i'm telling you you put cons

00:40:42,720 --> 00:40:45,280
somewhere

00:40:43,280 --> 00:40:47,200
in spreads where like gangrene is going

00:40:45,280 --> 00:40:49,200
to be everywhere

00:40:47,200 --> 00:40:51,440
and someone else told me well i put cons

00:40:49,200 --> 00:40:52,079
somewhere and i ended up duplicating

00:40:51,440 --> 00:40:56,880
every function

00:40:52,079 --> 00:40:59,359
that's terrible that's funny

00:40:56,880 --> 00:41:00,319
so if you click this code this code is

00:40:59,359 --> 00:41:02,480
some kind of old c

00:41:00,319 --> 00:41:04,000
function see that's getting a char star

00:41:02,480 --> 00:41:05,200
as argument

00:41:04,000 --> 00:41:06,480
and i'm trying to call it with a

00:41:05,200 --> 00:41:08,000
construct star of course it's going to

00:41:06,480 --> 00:41:08,880
complain in main because i don't have

00:41:08,000 --> 00:41:10,880
the right

00:41:08,880 --> 00:41:12,800
types you know because i have a constant

00:41:10,880 --> 00:41:13,440
and i call it a pointer to constant i'm

00:41:12,800 --> 00:41:15,599
trying to

00:41:13,440 --> 00:41:17,040
send it to a function that doesn't

00:41:15,599 --> 00:41:20,480
predict it the same way

00:41:17,040 --> 00:41:23,359
consists transitive

00:41:20,480 --> 00:41:24,880
so yeah so you we could have people

00:41:23,359 --> 00:41:25,839
complaining well you put constant there

00:41:24,880 --> 00:41:28,480
you get what you deserve

00:41:25,839 --> 00:41:30,079
no well i'm not losing functionality but

00:41:28,480 --> 00:41:32,400
in const i'm being clearer about my

00:41:30,079 --> 00:41:34,720
intents

00:41:32,400 --> 00:41:35,680
the problem is there see it's there

00:41:34,720 --> 00:41:37,440
because the function

00:41:35,680 --> 00:41:39,280
might not want to modify what i'm giving

00:41:37,440 --> 00:41:41,599
it but it's not saying so

00:41:39,280 --> 00:41:42,560
so the compiler is helping me it's an

00:41:41,599 --> 00:41:45,040
interface problem

00:41:42,560 --> 00:41:49,040
interface is wrong interfaces tell us

00:41:45,040 --> 00:41:50,960
things they whisper to us

00:41:49,040 --> 00:41:52,800
this is there if you can of course

00:41:50,960 --> 00:41:54,880
control the code you call

00:41:52,800 --> 00:41:56,960
this is cool because you can give it the

00:41:54,880 --> 00:41:58,000
proper interface with respect to your

00:41:56,960 --> 00:41:58,960
needs

00:41:58,000 --> 00:42:01,040
there we could do better than

00:41:58,960 --> 00:42:02,560
constructor in this case i know stranger

00:42:01,040 --> 00:42:05,599
will be nicer in everything

00:42:02,560 --> 00:42:06,400
that's what i mean so using cons solves

00:42:05,599 --> 00:42:09,599
the problem

00:42:06,400 --> 00:42:11,280
the interface is better and yes

00:42:09,599 --> 00:42:12,720
sometimes you do not control the

00:42:11,280 --> 00:42:13,839
function you're calling because it comes

00:42:12,720 --> 00:42:15,599
from somewhere else

00:42:13,839 --> 00:42:17,040
and you don't have any control over it

00:42:15,599 --> 00:42:18,800
and yes you can con

00:42:17,040 --> 00:42:20,960
cast if you're convinced that what

00:42:18,800 --> 00:42:23,119
you're doing is fine

00:42:20,960 --> 00:42:24,160
but the good thing about cause cast is

00:42:23,119 --> 00:42:26,720
it's loud

00:42:24,160 --> 00:42:28,319
so you can see that you did that and at

00:42:26,720 --> 00:42:29,680
some point in the future maybe hopefully

00:42:28,319 --> 00:42:31,760
fix it

00:42:29,680 --> 00:42:33,280
so being loud about the lies you tell to

00:42:31,760 --> 00:42:36,400
the type system

00:42:33,280 --> 00:42:38,640
is a good thing it's still a lie

00:42:36,400 --> 00:42:40,000
but it's something you can find it's

00:42:38,640 --> 00:42:41,920
something that speaks to you

00:42:40,000 --> 00:42:45,440
it tells you there was something weird

00:42:41,920 --> 00:42:49,599
there and i went around i have a reason

00:42:45,440 --> 00:42:51,359
a bad one but and people saying well you

00:42:49,599 --> 00:42:53,760
put cons somewhere and you'll have two

00:42:51,359 --> 00:42:56,800
versions of everything const is bad

00:42:53,760 --> 00:42:57,040
it's preds well it's kind of true you

00:42:56,800 --> 00:42:58,880
know

00:42:57,040 --> 00:43:00,400
so at this small array class they're

00:42:58,880 --> 00:43:03,359
very very simple

00:43:00,400 --> 00:43:06,800
elements of type t initialized to the

00:43:03,359 --> 00:43:06,800
default value of t in this case

00:43:06,880 --> 00:43:10,400
and i have my iterator interface that's

00:43:09,680 --> 00:43:13,520
no except

00:43:10,400 --> 00:43:15,359
find why not begin an end non-const and

00:43:13,520 --> 00:43:18,319
a non-const operator bracket bracket

00:43:15,359 --> 00:43:19,760
because it's an array why not

00:43:18,319 --> 00:43:21,599
and that might be sufficient for some

00:43:19,760 --> 00:43:24,000
needs of course if you make it cost

00:43:21,599 --> 00:43:24,000
correct

00:43:24,079 --> 00:43:27,200
you're doubling effectively you're

00:43:25,520 --> 00:43:27,760
doubling the number of functions and the

00:43:27,200 --> 00:43:29,359
number of

00:43:27,760 --> 00:43:30,960
types in my case so i have a

00:43:29,359 --> 00:43:33,119
considerator instead of

00:43:30,960 --> 00:43:35,280
on top of the iterator and the cons

00:43:33,119 --> 00:43:37,680
begin the constant and it counts bracket

00:43:35,280 --> 00:43:37,680
bracket

00:43:37,760 --> 00:43:43,119
yeah it's more cool it's it's

00:43:41,280 --> 00:43:44,480
people could complain that the the

00:43:43,119 --> 00:43:46,480
blocks of code inside

00:43:44,480 --> 00:43:48,560
are the same well they're syntactically

00:43:46,480 --> 00:43:50,560
the same that's semantically the same

00:43:48,560 --> 00:43:52,319
i know there's a proposal to simplify

00:43:50,560 --> 00:43:52,880
this in the works right now i don't know

00:43:52,319 --> 00:43:54,720
where it's

00:43:52,880 --> 00:43:57,359
at but i've seen it pass by and i read

00:43:54,720 --> 00:43:57,359
it a few times

00:43:57,520 --> 00:44:02,319
so yeah i have more functions that's

00:44:00,079 --> 00:44:02,319
true

00:44:02,560 --> 00:44:06,800
but they don't mean the same thing it's

00:44:05,359 --> 00:44:08,079
not the same interface because it has a

00:44:06,800 --> 00:44:09,359
different meaning

00:44:08,079 --> 00:44:11,280
that's why it's there that's why it's

00:44:09,359 --> 00:44:14,720
different

00:44:11,280 --> 00:44:14,720
it looks pretty the same ideas at all

00:44:15,920 --> 00:44:19,440
so if we limit ourselves to this one

00:44:17,520 --> 00:44:21,359
which has which is not cause correct

00:44:19,440 --> 00:44:23,359
of course it will compile for most cases

00:44:21,359 --> 00:44:25,040
that i use i guess

00:44:23,359 --> 00:44:26,720
but if i'm trying to do some kind of

00:44:25,040 --> 00:44:27,200
print function for my type that does a

00:44:26,720 --> 00:44:29,440
loop

00:44:27,200 --> 00:44:30,319
or something i'm trying to write it this

00:44:29,440 --> 00:44:32,400
way while

00:44:30,319 --> 00:44:34,000
passing a constant rate to the function

00:44:32,400 --> 00:44:34,480
makes sense considering by reference

00:44:34,000 --> 00:44:36,240
because

00:44:34,480 --> 00:44:38,560
i'm not trying to modify the elements

00:44:36,240 --> 00:44:40,160
i'm trying to read from them

00:44:38,560 --> 00:44:42,079
but that both failed that will face

00:44:40,160 --> 00:44:43,920
array of i there it won't compile of

00:44:42,079 --> 00:44:46,079
course because it's non-const it doesn't

00:44:43,920 --> 00:44:47,599
offer the guarantees expected

00:44:46,079 --> 00:44:50,319
and the compiler is protecting me from

00:44:47,599 --> 00:44:53,599
my own idiocy

00:44:50,319 --> 00:44:56,079
yeah so it's good that i use concept my

00:44:53,599 --> 00:44:57,359
at the border of my interface it's sad

00:44:56,079 --> 00:45:00,240
that i don't have

00:44:57,359 --> 00:45:01,200
the guarantees transit transitively

00:45:00,240 --> 00:45:03,119
asked

00:45:01,200 --> 00:45:04,720
in my member functions to carry on that

00:45:03,119 --> 00:45:06,560
interface

00:45:04,720 --> 00:45:08,480
so it's a different meaning i'm getting

00:45:06,560 --> 00:45:10,720
something from it

00:45:08,480 --> 00:45:12,000
of course not everything will be doubled

00:45:10,720 --> 00:45:13,520
no you have functions that have only

00:45:12,000 --> 00:45:15,280
caused versions

00:45:13,520 --> 00:45:16,839
empty and size functions and a vector

00:45:15,280 --> 00:45:19,119
say there's no reason to make them

00:45:16,839 --> 00:45:21,520
mutating i hope at least

00:45:19,119 --> 00:45:23,920
and there are those that are immense

00:45:21,520 --> 00:45:27,280
imminently mutating so push back insert

00:45:23,920 --> 00:45:30,160
or such erase well they won't be const

00:45:27,280 --> 00:45:32,000
that makes sense too and those that have

00:45:30,160 --> 00:45:36,800
two versions well it's because they have

00:45:32,000 --> 00:45:36,800
two meanings that's fair

00:45:38,240 --> 00:45:43,280
there are shortcuts we take in code i

00:45:40,480 --> 00:45:45,119
know you know them

00:45:43,280 --> 00:45:47,359
i i wanted to call this one of union

00:45:45,119 --> 00:45:49,520
re-interpret guests and sister outcasts

00:45:47,359 --> 00:45:51,040
it's but i wanted something more general

00:45:49,520 --> 00:45:51,520
man we could have volatile to that you

00:45:51,040 --> 00:45:53,119
know

00:45:51,520 --> 00:45:55,920
about that is a bad name some people

00:45:53,119 --> 00:45:58,560
think things about volatile that are

00:45:55,920 --> 00:46:00,960
not true and and volatile is like a bad

00:45:58,560 --> 00:46:02,960
word jf is very courageous jeff best

00:46:00,960 --> 00:46:04,079
thing to have taken on volatile recently

00:46:02,960 --> 00:46:05,119
because it's the kind of word that

00:46:04,079 --> 00:46:07,119
nobody wants to get

00:46:05,119 --> 00:46:10,560
close to because it's severely

00:46:07,119 --> 00:46:11,920
underspecified in some senses

00:46:10,560 --> 00:46:13,839
so there are things we do to make things

00:46:11,920 --> 00:46:14,960
work do we fix this quick and dirty

00:46:13,839 --> 00:46:17,520
things

00:46:14,960 --> 00:46:19,119
compiled runs works yeah let's move on

00:46:17,520 --> 00:46:20,720
something else and then at some point it

00:46:19,119 --> 00:46:23,760
comes back to us

00:46:20,720 --> 00:46:26,880
no write once debug mini

00:46:23,760 --> 00:46:29,839
or something i tried to put examples

00:46:26,880 --> 00:46:30,400
up and the itch i felt bad writing them

00:46:29,839 --> 00:46:32,640
you know they

00:46:30,400 --> 00:46:33,680
creep like spiders on your skin

00:46:32,640 --> 00:46:35,520
sometimes

00:46:33,680 --> 00:46:37,599
so what i did instead was i took a real

00:46:35,520 --> 00:46:38,319
life example that i anonymized where it

00:46:37,599 --> 00:46:40,480
comes from

00:46:38,319 --> 00:46:41,520
it used to come because there anymore i

00:46:40,480 --> 00:46:43,520
checked

00:46:41,520 --> 00:46:45,200
if it is it's in an archive somewhere it

00:46:43,520 --> 00:46:46,960
comes from a well-known company

00:46:45,200 --> 00:46:48,560
that cell software it was in the

00:46:46,960 --> 00:46:51,839
official help section

00:46:48,560 --> 00:46:53,760
in its original form i had

00:46:51,839 --> 00:46:55,119
colleagues people i met in the industry

00:46:53,760 --> 00:46:57,760
that used that example

00:46:55,119 --> 00:46:58,560
in real code thinking it worked because

00:46:57,760 --> 00:47:01,680
it kind of worked

00:46:58,560 --> 00:47:03,359
in the context in which it was used so

00:47:01,680 --> 00:47:05,440
it's like this

00:47:03,359 --> 00:47:06,720
so i might be saying something about the

00:47:05,440 --> 00:47:08,880
interface there but

00:47:06,720 --> 00:47:10,000
there's um non-portable code but it's

00:47:08,880 --> 00:47:12,960
it's part of the

00:47:10,000 --> 00:47:14,560
meaning of the problem so i have this uh

00:47:12,960 --> 00:47:14,960
shortcut you long for unsigned on

00:47:14,560 --> 00:47:18,000
because

00:47:14,960 --> 00:47:20,720
otherwise slidewear doesn't fit well and

00:47:18,000 --> 00:47:21,760
launch launch that takes a function

00:47:20,720 --> 00:47:23,839
ethical means

00:47:21,760 --> 00:47:24,960
in that context a non-c calling

00:47:23,839 --> 00:47:26,720
convention so it

00:47:24,960 --> 00:47:29,040
tells you that the arguments are not

00:47:26,720 --> 00:47:30,559
going to be called the c way

00:47:29,040 --> 00:47:32,319
the order will be different and the way

00:47:30,559 --> 00:47:33,760
they're passed you know

00:47:32,319 --> 00:47:35,839
who's responsible for putting them on

00:47:33,760 --> 00:47:37,119
the stack who's responsible for removing

00:47:35,839 --> 00:47:38,480
them from the call stack

00:47:37,119 --> 00:47:40,319
it's not a c rule then applying

00:47:38,480 --> 00:47:43,200
something else

00:47:40,319 --> 00:47:45,280
so it's launch that takes a pointer to a

00:47:43,200 --> 00:47:46,480
standard call function that takes a void

00:47:45,280 --> 00:47:48,079
start returns a new loan

00:47:46,480 --> 00:47:49,839
and a void star so it's going to call

00:47:48,079 --> 00:47:53,200
the function passing in the argument

00:47:49,839 --> 00:47:55,839
or so we can guess or something

00:47:53,200 --> 00:47:56,480
so imagine that large f of r we'll call

00:47:55,839 --> 00:48:01,359
f of r

00:47:56,480 --> 00:48:01,359
at some point asynchronously whatever

00:48:02,160 --> 00:48:05,760
and that thing as i was saying it tells

00:48:03,920 --> 00:48:06,640
you that it's the non-c calling

00:48:05,760 --> 00:48:08,880
convention thing

00:48:06,640 --> 00:48:10,160
so the stack will be a little bit

00:48:08,880 --> 00:48:10,960
differently if you call it you have to

00:48:10,160 --> 00:48:12,400
be careful

00:48:10,960 --> 00:48:13,760
because if you're playing with the way

00:48:12,400 --> 00:48:14,960
the arguments are passed and removed

00:48:13,760 --> 00:48:16,720
from the stack

00:48:14,960 --> 00:48:19,200
and you're not being confirmed with

00:48:16,720 --> 00:48:21,520
yourself you might corrupt the stack

00:48:19,200 --> 00:48:23,920
which is not the best thing to do in

00:48:21,520 --> 00:48:23,920
your life

00:48:24,240 --> 00:48:28,160
so and i have this function that almost

00:48:26,640 --> 00:48:29,200
meets the requirements except that it's

00:48:28,160 --> 00:48:31,040
not a city call

00:48:29,200 --> 00:48:32,640
it's a c function a c c plus plus

00:48:31,040 --> 00:48:34,400
function because it doesn't have any

00:48:32,640 --> 00:48:37,040
qualifications to speak of so it's a c

00:48:34,400 --> 00:48:39,440
calling convention

00:48:37,040 --> 00:48:41,599
now if you do something like this launch

00:48:39,440 --> 00:48:44,240
of f of no pdr

00:48:41,599 --> 00:48:45,200
won't compile because you don't have the

00:48:44,240 --> 00:48:48,000
right

00:48:45,200 --> 00:48:49,280
pointer type because it's not it's

00:48:48,000 --> 00:48:52,240
taking into account the fact that you

00:48:49,280 --> 00:48:54,400
don't have the right calling convention

00:48:52,240 --> 00:48:58,000
and if it did pass in what state would

00:48:54,400 --> 00:48:58,000
be your stack after the call

00:48:59,280 --> 00:49:03,520
but i've seen that so that was actually

00:49:01,920 --> 00:49:06,640
an example in the documentation

00:49:03,520 --> 00:49:08,400
so fp is the type of the

00:49:06,640 --> 00:49:10,000
function that you are supposed to be

00:49:08,400 --> 00:49:12,720
passing to launch

00:49:10,000 --> 00:49:14,160
nsc style cast to say shut up let me do

00:49:12,720 --> 00:49:15,680
my thing

00:49:14,160 --> 00:49:17,280
now if you compile this thing you run it

00:49:15,680 --> 00:49:19,440
it can pass without errors

00:49:17,280 --> 00:49:20,640
you're given the proper compiler and you

00:49:19,440 --> 00:49:23,599
run the code and it tends

00:49:20,640 --> 00:49:25,440
and returns zero because in this

00:49:23,599 --> 00:49:26,720
specific circumstance there's nothing

00:49:25,440 --> 00:49:28,319
after the call and you're just passing

00:49:26,720 --> 00:49:29,839
an argument that's very simple it's a

00:49:28,319 --> 00:49:31,280
pointer to the whole there's no local

00:49:29,839 --> 00:49:36,079
variable anywhere

00:49:31,280 --> 00:49:39,359
it's a very very isolated test case

00:49:36,079 --> 00:49:42,960
it works but it's so bad

00:49:39,359 --> 00:49:45,520
it's so bad it's just short but yeah the

00:49:42,960 --> 00:49:48,400
best school review in companies i know

00:49:45,520 --> 00:49:50,079
people thought it was okay so we can lie

00:49:48,400 --> 00:49:51,200
to the compiler and we can cheat the

00:49:50,079 --> 00:49:52,559
type system

00:49:51,200 --> 00:49:54,160
there's always we're almost always an

00:49:52,559 --> 00:49:56,079
escape patch of the scare this game it's

00:49:54,160 --> 00:49:58,640
pragmatic

00:49:56,079 --> 00:49:59,680
you can do that with c style casts but

00:49:58,640 --> 00:50:02,400
it's it's

00:49:59,680 --> 00:50:03,920
it's hard to find afterwards you can

00:50:02,400 --> 00:50:04,559
play three switch unions or interpret

00:50:03,920 --> 00:50:08,000
cast but

00:50:04,559 --> 00:50:10,240
i i i don't get the long the loud lies

00:50:08,000 --> 00:50:13,839
because leave more traces yeah and this

00:50:10,240 --> 00:50:13,839
one was very dirty

00:50:15,119 --> 00:50:19,440
time flies i'm trying to go fast i love

00:50:18,400 --> 00:50:21,440
london's

00:50:19,440 --> 00:50:23,599
they're cool when i teach them people

00:50:21,440 --> 00:50:24,880
love them they take to london's and they

00:50:23,599 --> 00:50:26,319
play with them and it's one of the

00:50:24,880 --> 00:50:29,040
things that they appreciate the most

00:50:26,319 --> 00:50:29,040
after a few weeks

00:50:29,440 --> 00:50:34,480
this is a very simple sequential

00:50:32,559 --> 00:50:36,000
number generator whatever you call gen

00:50:34,480 --> 00:50:37,680
in this case it will increment the value

00:50:36,000 --> 00:50:39,200
of n return a new value so this code

00:50:37,680 --> 00:50:41,440
will print

00:50:39,200 --> 00:50:42,480
zero one two three four which which is

00:50:41,440 --> 00:50:44,319
fine

00:50:42,480 --> 00:50:46,559
if you look at n after the sequence of

00:50:44,319 --> 00:50:49,200
calls ln will be worth

00:50:46,559 --> 00:50:52,960
five because it's the local variable to

00:50:49,200 --> 00:50:52,960
n captured by reference by lambda

00:50:53,359 --> 00:50:57,440
you put it this way still compiles very

00:50:55,920 --> 00:51:00,480
fine

00:50:57,440 --> 00:51:01,040
if you run it well you get what you

00:51:00,480 --> 00:51:02,480
deserve

00:51:01,040 --> 00:51:04,000
might work might not you don't know

00:51:02,480 --> 00:51:05,440
depends on what happens in your your

00:51:04,000 --> 00:51:06,160
machine your optimizer or anything

00:51:05,440 --> 00:51:09,359
because

00:51:06,160 --> 00:51:11,760
you're capturing a loco by reference

00:51:09,359 --> 00:51:13,359
the local variable m to generator which

00:51:11,760 --> 00:51:14,960
at the end generator is not there

00:51:13,359 --> 00:51:17,040
anymore so

00:51:14,960 --> 00:51:19,280
what's going on your guess is as good as

00:51:17,040 --> 00:51:19,280
mine

00:51:19,359 --> 00:51:24,400
but it compiles without the noise so if

00:51:22,559 --> 00:51:27,200
you're thinking compiles means works

00:51:24,400 --> 00:51:27,200
you're gonna have fun

00:51:27,599 --> 00:51:31,599
yeah it's broken called then but it's

00:51:29,119 --> 00:51:34,000
very silent

00:51:31,599 --> 00:51:36,160
you can put it this way the parents are

00:51:34,000 --> 00:51:37,520
necessary with mutable so far i

00:51:36,160 --> 00:51:39,359
think it might have changed for cp's

00:51:37,520 --> 00:51:42,079
plus when you didn't check that was

00:51:39,359 --> 00:51:43,680
i think jf suggested that among others

00:51:42,079 --> 00:51:45,280
but

00:51:43,680 --> 00:51:46,720
this one works though this one is fine

00:51:45,280 --> 00:51:47,920
because it's a local variable that you

00:51:46,720 --> 00:51:49,599
can mutate

00:51:47,920 --> 00:51:51,839
and get the right results so you have to

00:51:49,599 --> 00:51:51,839
be careful

00:51:55,200 --> 00:51:58,800
now we're getting our tools are getting

00:51:57,680 --> 00:52:01,920
better with this too i

00:51:58,800 --> 00:52:05,119
saw uh good uh warning messages recently

00:52:01,920 --> 00:52:08,079
from something powders with this

00:52:05,119 --> 00:52:10,559
this is a factorial it's a tentative uh

00:52:08,079 --> 00:52:12,319
trying to write a recursive factorial

00:52:10,559 --> 00:52:14,400
as a lambda it won't compile though in

00:52:12,319 --> 00:52:15,839
this case it won't compile because

00:52:14,400 --> 00:52:17,760
the competitor doesn't know what facto

00:52:15,839 --> 00:52:19,440
is at this point it doesn't melt the

00:52:17,760 --> 00:52:21,280
semicolon at the end of the lambdas

00:52:19,440 --> 00:52:23,280
let's know what we're talking about

00:52:21,280 --> 00:52:24,960
and it's not captured on top of it so if

00:52:23,280 --> 00:52:26,559
you capture it by reference

00:52:24,960 --> 00:52:28,960
it becomes a naming thing or a typing

00:52:26,559 --> 00:52:30,640
thing if you do it this way

00:52:28,960 --> 00:52:32,880
saying well this lambda is a function

00:52:30,640 --> 00:52:34,240
double hint it's going to capture a

00:52:32,880 --> 00:52:35,839
function and work and it's going to

00:52:34,240 --> 00:52:38,240
output 120 because

00:52:35,839 --> 00:52:41,760
that's what it gives it's a complicated

00:52:38,240 --> 00:52:43,119
and costly way to compute the thing

00:52:41,760 --> 00:52:46,079
it's something to do a function that

00:52:43,119 --> 00:52:48,160
returns a factorial like this

00:52:46,079 --> 00:52:50,720
if you look at this it looks nice it

00:52:48,160 --> 00:52:53,040
does the same thing

00:52:50,720 --> 00:52:54,640
and the problem is that of course if you

00:52:53,040 --> 00:52:56,800
run this thing

00:52:54,640 --> 00:52:57,920
it might boom on you it might work

00:52:56,800 --> 00:52:59,599
because it's on different behavior it

00:52:57,920 --> 00:53:02,800
might not or something but you

00:52:59,599 --> 00:53:05,839
get a reference in facto

00:53:02,800 --> 00:53:08,640
in fact to itself

00:53:05,839 --> 00:53:10,480
but that facto in fact is a local when

00:53:08,640 --> 00:53:12,559
you're returning a copy to this

00:53:10,480 --> 00:53:14,160
well the local is still in the function

00:53:12,559 --> 00:53:15,359
technically speaking it's dead

00:53:14,160 --> 00:53:16,880
and you're referring to something that

00:53:15,359 --> 00:53:19,040
doesn't exist anymore and you're on your

00:53:16,880 --> 00:53:19,040
own

00:53:19,200 --> 00:53:23,440
yeah there's a fix that'll fix

00:53:23,839 --> 00:53:28,480
the fix is put in lambda that will call

00:53:27,200 --> 00:53:30,000
facto and then put it

00:53:28,480 --> 00:53:32,160
it's a very contrived way of doing

00:53:30,000 --> 00:53:35,119
things but if you want to make it work

00:53:32,160 --> 00:53:35,119
yeah it works like this

00:53:36,480 --> 00:53:40,240
so some of these examples are very

00:53:37,760 --> 00:53:43,200
tricky some are diagnosed by compellers

00:53:40,240 --> 00:53:44,400
some are not diagnosed at all some

00:53:43,200 --> 00:53:46,000
compilers will actually

00:53:44,400 --> 00:53:47,680
use undefined behavior and mass the bug

00:53:46,000 --> 00:53:48,400
and compute the right quote quote

00:53:47,680 --> 00:53:51,520
results

00:53:48,400 --> 00:53:53,119
maybe because of the lining or whatever

00:53:51,520 --> 00:53:55,760
some some will give you code that

00:53:53,119 --> 00:53:57,200
crashes the last one i showed you it was

00:53:55,760 --> 00:53:58,079
undiagnosed by all the competitors i

00:53:57,200 --> 00:53:59,599
checked

00:53:58,079 --> 00:54:02,240
they might even pass code review except

00:53:59,599 --> 00:54:05,119
that it's required seven people

00:54:02,240 --> 00:54:05,119
but still you know

00:54:06,079 --> 00:54:12,400
so we sometimes don't pay attention

00:54:10,640 --> 00:54:15,359
we cut corners short we take shortcuts

00:54:12,400 --> 00:54:17,280
we try to to deliver the stuff

00:54:15,359 --> 00:54:18,559
we let things pass good review that we

00:54:17,280 --> 00:54:19,280
sh that probably should not have

00:54:18,559 --> 00:54:22,480
survived the

00:54:19,280 --> 00:54:23,920
review step we should think more we

00:54:22,480 --> 00:54:25,440
should think more michael casey has

00:54:23,920 --> 00:54:27,200
talked sometimes about this

00:54:25,440 --> 00:54:29,040
think recipes are good to get you

00:54:27,200 --> 00:54:30,720
started but they're not enough you have

00:54:29,040 --> 00:54:34,000
to think about your code

00:54:30,720 --> 00:54:34,880
about what you do about about how you do

00:54:34,000 --> 00:54:39,040
it

00:54:34,880 --> 00:54:42,880
and question yourself see because

00:54:39,040 --> 00:54:42,880
we're not safe that's how it works

00:54:44,640 --> 00:54:53,839
are there any questions comments threats

00:54:49,119 --> 00:54:53,839
or anything else

00:54:54,000 --> 00:54:56,400
oops

00:55:00,880 --> 00:55:07,839
are we okay

00:55:08,960 --> 00:55:13,599
oops everything should be const by

00:55:12,799 --> 00:55:16,720
default

00:55:13,599 --> 00:55:18,960
and we should use mirrorball okay this

00:55:16,720 --> 00:55:21,020
is the rust point of view right

00:55:18,960 --> 00:55:22,240
i'll talk about that in my uh

00:55:21,020 --> 00:55:25,839
[Music]

00:55:22,240 --> 00:55:26,960
that thing uh in my uh cl in my talk

00:55:25,839 --> 00:55:29,839
tomorrow

00:55:26,960 --> 00:55:31,119
if you don't mind but yes uh comes by

00:55:29,839 --> 00:55:33,040
default would be nice

00:55:31,119 --> 00:55:35,440
but we have to remember that c plus plus

00:55:33,040 --> 00:55:38,559
was written 40 years ago

00:55:35,440 --> 00:55:40,480
and our view of coding has changed our

00:55:38,559 --> 00:55:41,359
view of this efficiency has changed over

00:55:40,480 --> 00:55:43,119
time

00:55:41,359 --> 00:55:45,040
so yes it would be nice we're doing that

00:55:43,119 --> 00:55:45,599
with new stuff if you look at it lambdas

00:55:45,040 --> 00:55:49,119
are cons

00:55:45,599 --> 00:55:52,240
by default now um and

00:55:49,119 --> 00:55:54,240
but but yeah that's that's

00:55:52,240 --> 00:55:56,000
not what we have in the language so

00:55:54,240 --> 00:55:57,280
changing that would be tricky you can

00:55:56,000 --> 00:55:58,799
write your own code to

00:55:57,280 --> 00:56:01,040
to take that into account because

00:55:58,799 --> 00:56:02,400
correct that's good

00:56:01,040 --> 00:56:04,319
what's the benefit of trivial setting

00:56:02,400 --> 00:56:06,640
yet over just making a public shield

00:56:04,319 --> 00:56:07,680
if you're not doing any processing or

00:56:06,640 --> 00:56:11,200
any validation

00:56:07,680 --> 00:56:13,839
there's no not much of a change

00:56:11,200 --> 00:56:15,040
but uh if you're planning to at some

00:56:13,839 --> 00:56:18,079
point validate things

00:56:15,040 --> 00:56:21,280
having a get or a set to

00:56:18,079 --> 00:56:22,799
check things uh is better i'd say that

00:56:21,280 --> 00:56:24,240
if you're using a reference-based

00:56:22,799 --> 00:56:27,200
language instead of a value-based

00:56:24,240 --> 00:56:28,720
language like java or c-sharp

00:56:27,200 --> 00:56:30,880
your best bet is probably to make sure

00:56:28,720 --> 00:56:32,960
that your objects are immutable for the

00:56:30,880 --> 00:56:34,559
most part because otherwise it gets very

00:56:32,960 --> 00:56:37,520
hairy anyway

00:56:34,559 --> 00:56:38,079
so a a good a good trick if you're

00:56:37,520 --> 00:56:42,839
wondering

00:56:38,079 --> 00:56:45,520
about public fields is if you

00:56:42,839 --> 00:56:46,960
your uh if your object has no invariance

00:56:45,520 --> 00:56:49,040
public fields are fine

00:56:46,960 --> 00:56:50,480
so if you have a point x y z where all

00:56:49,040 --> 00:56:52,079
values are okay

00:56:50,480 --> 00:56:54,400
and you don't want to track changes in

00:56:52,079 --> 00:56:56,319
them just use public fields that's fine

00:56:54,400 --> 00:56:57,680
so yeah if you want to do something else

00:56:56,319 --> 00:56:58,000
but think about the interface there's

00:56:57,680 --> 00:56:59,520
always

00:56:58,000 --> 00:57:01,599
a reason for what you're doing so if

00:56:59,520 --> 00:57:05,599
you're having gets and sets it does

00:57:01,599 --> 00:57:07,200
because it makes sense and

00:57:05,599 --> 00:57:08,720
additional answer to that would be i

00:57:07,200 --> 00:57:10,720
have a lot more gets than

00:57:08,720 --> 00:57:12,079
sets in my code sets this should be

00:57:10,720 --> 00:57:13,760
pretty rare in practice

00:57:12,079 --> 00:57:16,720
the best place to modify your object is

00:57:13,760 --> 00:57:18,559
the constructor and the assignment

00:57:16,720 --> 00:57:20,000
isn't the main problem the strange cases

00:57:18,559 --> 00:57:21,599
at the beginning the lack of

00:57:20,000 --> 00:57:23,760
documentation oh yeah

00:57:21,599 --> 00:57:25,200
but you see the question is are the

00:57:23,760 --> 00:57:26,960
strange cases at the beginning

00:57:25,200 --> 00:57:29,040
are already due to lack of the

00:57:26,960 --> 00:57:30,319
documentation if we had proper

00:57:29,040 --> 00:57:32,880
interfaces

00:57:30,319 --> 00:57:34,720
and correct signatures that are

00:57:32,880 --> 00:57:36,720
incorrect names no if we had paid

00:57:34,720 --> 00:57:39,680
attention to the interface

00:57:36,720 --> 00:57:41,520
we could document on top of it but we

00:57:39,680 --> 00:57:43,760
wouldn't need to document all that much

00:57:41,520 --> 00:57:45,359
when you have to write comments to

00:57:43,760 --> 00:57:46,640
explain what you're doing that's okay

00:57:45,359 --> 00:57:47,920
when you have to write comments to

00:57:46,640 --> 00:57:50,799
explain what your functions

00:57:47,920 --> 00:57:52,799
mean maybe more more work should be put

00:57:50,799 --> 00:57:55,599
in the interface in many cases

00:57:52,799 --> 00:57:56,160
i seen talks in let's begin this year

00:57:55,599 --> 00:57:58,400
that that

00:57:56,160 --> 00:58:00,720
functions that i couldn't fathom the

00:57:58,400 --> 00:58:04,160
role of just by looking at the interface

00:58:00,720 --> 00:58:07,680
so it touches every one of us

00:58:04,160 --> 00:58:10,000
and you tried sterilizer hey hey

00:58:07,680 --> 00:58:11,680
no i would need to establish this i like

00:58:10,000 --> 00:58:13,839
the stabilizer talk yesterday

00:58:11,680 --> 00:58:14,799
but i haven't tried it so yes it would

00:58:13,839 --> 00:58:17,280
be interesting

00:58:14,799 --> 00:58:18,079
but my my guess for the question the

00:58:17,280 --> 00:58:20,000
question is

00:58:18,079 --> 00:58:20,960
have you tried tools like stabilizer to

00:58:20,000 --> 00:58:22,000
ensure that your performance

00:58:20,960 --> 00:58:24,400
measurements with reserve

00:58:22,000 --> 00:58:25,599
and the array are independent of layout

00:58:24,400 --> 00:58:27,680
my guess to be honest

00:58:25,599 --> 00:58:29,520
is the optimizer is very good it's

00:58:27,680 --> 00:58:32,480
probably noticing that it can remove

00:58:29,520 --> 00:58:34,720
the useless initialization with arrays

00:58:32,480 --> 00:58:36,480
because it sees through my code so i

00:58:34,720 --> 00:58:38,640
wasn't clever enough to obfuscate that

00:58:36,480 --> 00:58:40,319
fact

00:58:38,640 --> 00:58:42,160
does that mean every state transition

00:58:40,319 --> 00:58:44,799
with a class should be represented as

00:58:42,160 --> 00:58:48,480
some type plus data

00:58:44,799 --> 00:58:50,880
the word every is scary in the question

00:58:48,480 --> 00:58:51,760
is that the correct answer the the the

00:58:50,880 --> 00:58:53,520
things that

00:58:51,760 --> 00:58:55,760
questions like everything should be like

00:58:53,520 --> 00:58:58,559
this or like that

00:58:55,760 --> 00:59:00,160
my point is think before coding so i you

00:58:58,559 --> 00:59:02,640
you can consider that

00:59:00,160 --> 00:59:04,400
if you want but i it would depend on the

00:59:02,640 --> 00:59:05,440
domain what you're trying to represent

00:59:04,400 --> 00:59:07,760
would be my answer

00:59:05,440 --> 00:59:09,680
think about it would you have a

00:59:07,760 --> 00:59:11,760
tacticalizer suggestion to catch

00:59:09,680 --> 00:59:12,799
some of these bad practices that's a

00:59:11,760 --> 00:59:14,000
good question i would have to think

00:59:12,799 --> 00:59:16,240
about it because you know

00:59:14,000 --> 00:59:17,760
as if i think the first one to avoid

00:59:16,240 --> 00:59:21,040
parent parent function

00:59:17,760 --> 00:59:23,440
it can be fine you know luck in a mutex

00:59:21,040 --> 00:59:24,880
it's perfectly fine the way it is

00:59:23,440 --> 00:59:29,440
because my class represents

00:59:24,880 --> 00:59:31,680
state so but if my class is using

00:59:29,440 --> 00:59:34,000
i'll take the words on someone else if

00:59:31,680 --> 00:59:35,200
your code looks like you're using global

00:59:34,000 --> 00:59:37,119
state all the time

00:59:35,200 --> 00:59:39,280
because you're storing everything in a

00:59:37,119 --> 00:59:41,440
global object of some kind

00:59:39,280 --> 00:59:43,520
you're in trouble so that's probably the

00:59:41,440 --> 00:59:44,640
the point there so your your if your

00:59:43,520 --> 00:59:47,680
interface

00:59:44,640 --> 00:59:48,480
represents state it can be okay to be

00:59:47,680 --> 00:59:50,960
avoid void

00:59:48,480 --> 00:59:52,720
so are they bad practices not all the

00:59:50,960 --> 00:59:55,200
time now it's tied to the semantics of

00:59:52,720 --> 00:59:57,119
the problem you're facing so i i'm not a

00:59:55,200 --> 00:59:58,160
sergeantizer expert

00:59:57,119 --> 01:00:00,640
but i would think about that before

00:59:58,160 --> 01:00:01,760
implementing a rule role for those who

01:00:00,640 --> 01:00:05,040
are interested the

01:00:01,760 --> 01:00:07,680
uh recent versions of visual studio have

01:00:05,040 --> 01:00:09,119
selling analysis built in and and for me

01:00:07,680 --> 01:00:11,599
at least sometimes they give

01:00:09,119 --> 01:00:12,400
false positives but that doesn't mean

01:00:11,599 --> 01:00:14,799
they're bad

01:00:12,400 --> 01:00:15,599
it just means that it's difficult is

01:00:14,799 --> 01:00:17,520
accidental

01:00:15,599 --> 01:00:19,359
avoidance of aggregate status a possible

01:00:17,520 --> 01:00:22,240
side effects of mechanical special

01:00:19,359 --> 01:00:23,440
functions interesting i would have

01:00:22,240 --> 01:00:26,240
that's a deep question

01:00:23,440 --> 01:00:27,920
uh the one who wrote that one to me uh i

01:00:26,240 --> 01:00:29,440
would like to have more context to

01:00:27,920 --> 01:00:31,359
understand what you have in mind

01:00:29,440 --> 01:00:32,880
because it's it's interesting but i

01:00:31,359 --> 01:00:33,359
would like to think about it more so if

01:00:32,880 --> 01:00:34,720
you get

01:00:33,359 --> 01:00:36,640
you could write to me by email i would

01:00:34,720 --> 01:00:38,079
appreciate it

01:00:36,640 --> 01:00:40,880
is there anything else because i think

01:00:38,079 --> 01:00:40,880
we're over time

01:00:41,119 --> 01:00:46,640
are we okay i'm getting a new question

01:00:44,319 --> 01:00:48,400
do you think lambda should be accessible

01:00:46,640 --> 01:00:49,440
access to its instance and be able to

01:00:48,400 --> 01:00:52,559
call

01:00:49,440 --> 01:00:55,280
parent parent or create its copy i think

01:00:52,559 --> 01:00:56,640
uh should it or should it not i would

01:00:55,280 --> 01:00:58,000
have to see the use cases

01:00:56,640 --> 01:01:00,160
but i can tell you that if you have to

01:00:58,000 --> 01:01:02,079
do more than what the lambda does

01:01:00,160 --> 01:01:03,520
yeah that's okay if you if you have to

01:01:02,079 --> 01:01:05,280
do more than what alam does you can

01:01:03,520 --> 01:01:07,520
always write a function object

01:01:05,280 --> 01:01:09,280
by the way just like that i don't mind

01:01:07,520 --> 01:01:10,720
myself the word functor it makes

01:01:09,280 --> 01:01:12,960
it makes sense in the computer science

01:01:10,720 --> 01:01:14,960
sense it's been like that for decades

01:01:12,960 --> 01:01:16,000
so yes it has another meaning in other

01:01:14,960 --> 01:01:17,440
domains

01:01:16,000 --> 01:01:18,880
but it's fine there's many words like

01:01:17,440 --> 01:01:20,720
that that have different meanings and

01:01:18,880 --> 01:01:23,119
different domains of science

01:01:20,720 --> 01:01:25,359
so yes if i have the use case for

01:01:23,119 --> 01:01:27,119
lambdas to inspect their own instance

01:01:25,359 --> 01:01:29,920
state and call their own operator parent

01:01:27,119 --> 01:01:29,920
burn or something

01:01:30,079 --> 01:01:33,040
show me the code but you can always

01:01:31,839 --> 01:01:34,400
write a function object if you need to

01:01:33,040 --> 01:01:36,240
do that

01:01:34,400 --> 01:01:38,000
thank you everyone i would have liked to

01:01:36,240 --> 01:01:41,839
see you i hope you weren't too bored

01:01:38,000 --> 01:01:41,839
i hope you had fun so thanks for coming

01:01:50,839 --> 01:01:53,839
bye

01:02:01,119 --> 01:02:03,200

YouTube URL: https://www.youtube.com/watch?v=Wg1f9Sufyic


