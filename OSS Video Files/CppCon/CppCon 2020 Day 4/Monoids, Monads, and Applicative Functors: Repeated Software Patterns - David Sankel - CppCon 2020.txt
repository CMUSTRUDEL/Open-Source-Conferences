Title: Monoids, Monads, and Applicative Functors: Repeated Software Patterns - David Sankel - CppCon 2020
Publication date: 2020-10-02
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Forget factories, singletons, and proxies; What are the real patterns in software development? This talk explores abstract mathematical structures that commonly recur in software development. Once a mind is trained to recognize these patterns, it becomes easy to identify the fundamental operations for domain specific classes and how to put the pieces together. This discussion is for those who enjoy math, abstract concepts, and expanding their minds. 

---
David Sankel is a Software Engineering Manager/TL at Bloomberg and an active member of the C++ Standardization Committee. His experience spans microservice architectures, CAD/CAM, computer graphics, visual programming languages, web applications, computer vision, and cryptography. He is a frequent speaker at C++ conferences and specializes in large-scale software engineering and advanced C++ topics. Davidâ€™s interests include dependently typed languages, semantic domains, EDSLs, and functional reactive programming. He is the project editor of the C++ Reflection TS, a member of the Boost steering committee, and an author of serveral C++ proposals including pattern matching and language variants. 

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,559 --> 00:00:15,280
monoids monads and applicative functors

00:00:12,000 --> 00:00:17,840
repeated software patterns now

00:00:15,280 --> 00:00:18,960
why would we want to do why would we

00:00:17,840 --> 00:00:22,000
want to talk about

00:00:18,960 --> 00:00:23,199
software patterns well in a nutshell

00:00:22,000 --> 00:00:25,519
it's this

00:00:23,199 --> 00:00:27,439
you have your interface to your class

00:00:25,519 --> 00:00:28,880
you have your implementation detail in

00:00:27,439 --> 00:00:31,199
the private section

00:00:28,880 --> 00:00:33,520
what are you going to expose as your

00:00:31,199 --> 00:00:35,680
public interface

00:00:33,520 --> 00:00:36,960
well in order to answer the question of

00:00:35,680 --> 00:00:37,840
what are we going to put in our public

00:00:36,960 --> 00:00:39,520
interface

00:00:37,840 --> 00:00:41,520
we need to figure out what are the

00:00:39,520 --> 00:00:43,600
fundamental operations

00:00:41,520 --> 00:00:45,520
now there you've probably seen classes

00:00:43,600 --> 00:00:46,160
god classes with hundreds of member

00:00:45,520 --> 00:00:47,600
functions

00:00:46,160 --> 00:00:48,960
but many of those member functions could

00:00:47,600 --> 00:00:50,239
have been implemented in terms of the

00:00:48,960 --> 00:00:52,480
other member functions

00:00:50,239 --> 00:00:53,760
so what are the fundamental axioms of

00:00:52,480 --> 00:00:56,079
your type

00:00:53,760 --> 00:00:58,320
and then what is the flexibility that

00:00:56,079 --> 00:01:01,680
you want to be able to provide your user

00:00:58,320 --> 00:01:03,920
given these fundamental axioms when you

00:01:01,680 --> 00:01:05,920
do things in a functional design way

00:01:03,920 --> 00:01:07,760
these are critical questions when you're

00:01:05,920 --> 00:01:09,439
designing your interface

00:01:07,760 --> 00:01:10,960
and finally when you apply some of these

00:01:09,439 --> 00:01:12,560
functional design patterns

00:01:10,960 --> 00:01:14,560
you're going to be able to see how they

00:01:12,560 --> 00:01:17,520
relate to other classes

00:01:14,560 --> 00:01:17,920
these are very powerful generic patterns

00:01:17,520 --> 00:01:19,920
and

00:01:17,920 --> 00:01:21,920
there's a lot of composability with

00:01:19,920 --> 00:01:23,680
other classes

00:01:21,920 --> 00:01:25,119
so one thing i want to get straight

00:01:23,680 --> 00:01:26,479
right from the beginning is that

00:01:25,119 --> 00:01:29,600
functional patterns are

00:01:26,479 --> 00:01:32,159
not for the users you don't

00:01:29,600 --> 00:01:32,880
expose something called the monadic bind

00:01:32,159 --> 00:01:34,400
operation

00:01:32,880 --> 00:01:36,320
why a user is going to look at that

00:01:34,400 --> 00:01:38,240
monadic bind operation and say

00:01:36,320 --> 00:01:39,759
what is this thing i have no idea what

00:01:38,240 --> 00:01:43,439
this does your interface

00:01:39,759 --> 00:01:44,720
sucks now when that's not saying we

00:01:43,439 --> 00:01:46,399
shouldn't expose a monarch bind

00:01:44,720 --> 00:01:48,000
operation but don't call it a monadic

00:01:46,399 --> 00:01:49,600
bind operation

00:01:48,000 --> 00:01:51,680
now it may be at some point in the

00:01:49,600 --> 00:01:53,040
future c plus plus users everywhere are

00:01:51,680 --> 00:01:54,159
going to be familiar with category

00:01:53,040 --> 00:01:55,520
theoretic concepts

00:01:54,159 --> 00:01:57,439
and you can call it monadic bind and

00:01:55,520 --> 00:01:59,280
they're going to understand what it does

00:01:57,439 --> 00:02:01,600
but until that point make sure you use

00:01:59,280 --> 00:02:02,880
good names you can use the power of

00:02:01,600 --> 00:02:05,840
category theory

00:02:02,880 --> 00:02:07,520
but you can also get an intuitive ui by

00:02:05,840 --> 00:02:08,800
making sure that you

00:02:07,520 --> 00:02:10,800
name your things in a way that your

00:02:08,800 --> 00:02:13,520
users expect

00:02:10,800 --> 00:02:14,560
and one final note writing generic code

00:02:13,520 --> 00:02:16,080
is a lot of fun

00:02:14,560 --> 00:02:18,319
it's super fun we're going to have some

00:02:16,080 --> 00:02:21,440
fun in this talk but

00:02:18,319 --> 00:02:22,800
readable code is even more fun well it's

00:02:21,440 --> 00:02:24,800
may not be more fun but is

00:02:22,800 --> 00:02:26,239
better for sure and certainly for you as

00:02:24,800 --> 00:02:28,480
software engineering profession know

00:02:26,239 --> 00:02:30,560
that this is really important for you

00:02:28,480 --> 00:02:32,080
so a little bit of history about what

00:02:30,560 --> 00:02:34,239
we're talking about

00:02:32,080 --> 00:02:35,519
you've all heard of the language haskell

00:02:34,239 --> 00:02:37,840
haskell started out

00:02:35,519 --> 00:02:39,840
as an academic programming language

00:02:37,840 --> 00:02:41,760
which is modeled after math

00:02:39,840 --> 00:02:44,239
the folks that made haskell got together

00:02:41,760 --> 00:02:45,519
and said hey we really love math

00:02:44,239 --> 00:02:47,440
wouldn't it be cool if we had a

00:02:45,519 --> 00:02:50,000
programming language that was basically

00:02:47,440 --> 00:02:51,200
math as a programming language and let's

00:02:50,000 --> 00:02:52,319
see if we can make that efficient

00:02:51,200 --> 00:02:55,040
somehow

00:02:52,319 --> 00:02:55,680
now purity is a really big deal in

00:02:55,040 --> 00:02:57,440
haskell

00:02:55,680 --> 00:02:58,959
this is what separates it from the other

00:02:57,440 --> 00:03:00,879
languages that were

00:02:58,959 --> 00:03:02,560
functional at the time is that they

00:03:00,879 --> 00:03:04,319
stuck with purity so what is purity

00:03:02,560 --> 00:03:06,879
we're not going to go into too deep

00:03:04,319 --> 00:03:07,599
detail about purity but basically a pure

00:03:06,879 --> 00:03:08,959
function

00:03:07,599 --> 00:03:10,560
it has the if you give it the same

00:03:08,959 --> 00:03:11,840
inputs you'll get the same output every

00:03:10,560 --> 00:03:14,239
time

00:03:11,840 --> 00:03:15,760
and there are no side effects so they

00:03:14,239 --> 00:03:17,280
basically excluded side effects from the

00:03:15,760 --> 00:03:18,720
language from the very beginning and

00:03:17,280 --> 00:03:20,560
tried to figure out how far they could

00:03:18,720 --> 00:03:23,440
take it as a programming language

00:03:20,560 --> 00:03:25,519
they used streams as the i o model but

00:03:23,440 --> 00:03:27,519
this was extremely cumbersome

00:03:25,519 --> 00:03:29,120
and you couldn't really do powerful

00:03:27,519 --> 00:03:29,599
things in haskell when it first came out

00:03:29,120 --> 00:03:32,319
at

00:03:29,599 --> 00:03:33,360
haskell 1.0 so haskell 1.0 was

00:03:32,319 --> 00:03:36,400
absolutely a

00:03:33,360 --> 00:03:38,000
toy language and that's okay these are

00:03:36,400 --> 00:03:38,879
researchers working on theoretical

00:03:38,000 --> 00:03:42,720
concepts

00:03:38,879 --> 00:03:45,840
practicality wasn't their goal however

00:03:42,720 --> 00:03:46,799
later on monads hit the stage and things

00:03:45,840 --> 00:03:49,680
started to change

00:03:46,799 --> 00:03:51,840
in 1989 eugene emoji was looking for

00:03:49,680 --> 00:03:53,439
ways to describe the meaning of programs

00:03:51,840 --> 00:03:55,840
in an abstract way

00:03:53,439 --> 00:03:57,439
and he discovered that category theory a

00:03:55,840 --> 00:03:59,200
branch of mathematics

00:03:57,439 --> 00:04:00,480
could be used to model state and

00:03:59,200 --> 00:04:02,720
exceptions

00:04:00,480 --> 00:04:05,519
and that was fine and a couple few years

00:04:02,720 --> 00:04:08,080
later 1992 wadler

00:04:05,519 --> 00:04:09,360
made the key discovery that monads from

00:04:08,080 --> 00:04:13,120
category theory

00:04:09,360 --> 00:04:14,879
could be used to express io and haskell

00:04:13,120 --> 00:04:17,040
and this was a game changer because this

00:04:14,879 --> 00:04:19,919
made haskell actually useful

00:04:17,040 --> 00:04:20,799
it was no longer a toy so category

00:04:19,919 --> 00:04:23,040
theory

00:04:20,799 --> 00:04:24,320
becomes popularized in functional

00:04:23,040 --> 00:04:25,759
programming sense

00:04:24,320 --> 00:04:27,440
so you'll hear a lot of category

00:04:25,759 --> 00:04:28,000
theoretic concepts and all this and it

00:04:27,440 --> 00:04:31,040
all came

00:04:28,000 --> 00:04:34,160
back to that 1992 discovery that monads

00:04:31,040 --> 00:04:36,400
can model io and haskell

00:04:34,160 --> 00:04:38,080
now category theory what is this thing

00:04:36,400 --> 00:04:38,960
as i mentioned it's much older than

00:04:38,080 --> 00:04:42,080
haskell

00:04:38,960 --> 00:04:43,919
the investigation started in 1942 by

00:04:42,080 --> 00:04:45,520
eilenberg and mack lane

00:04:43,919 --> 00:04:47,600
what they were attempting to do was to

00:04:45,520 --> 00:04:48,320
abstract over various mathematical

00:04:47,600 --> 00:04:50,720
models

00:04:48,320 --> 00:04:51,360
so back in your algebra class you may

00:04:50,720 --> 00:04:53,199
have

00:04:51,360 --> 00:04:54,880
started with a bunch of axioms for math

00:04:53,199 --> 00:04:56,479
and you tried to prove out all the other

00:04:54,880 --> 00:04:58,000
things that we know about mathematics

00:04:56,479 --> 00:04:59,520
this was very common at the time

00:04:58,000 --> 00:05:01,440
and there are different sets of axioms

00:04:59,520 --> 00:05:04,880
that you can use in different domains

00:05:01,440 --> 00:05:07,120
to to make varying mathematical models

00:05:04,880 --> 00:05:09,520
category theory was all about figuring

00:05:07,120 --> 00:05:10,479
out how you can abstract over all the

00:05:09,520 --> 00:05:13,520
different models

00:05:10,479 --> 00:05:14,960
so it's extremely extremely general

00:05:13,520 --> 00:05:17,520
and it made it applicable to many

00:05:14,960 --> 00:05:19,520
domains even outside of mathematics

00:05:17,520 --> 00:05:21,360
music theory for example is something

00:05:19,520 --> 00:05:23,280
that has made use of category theory

00:05:21,360 --> 00:05:26,000
because of its generality

00:05:23,280 --> 00:05:27,199
so when we talk about uh computing

00:05:26,000 --> 00:05:28,720
computer science

00:05:27,199 --> 00:05:30,880
patterns usually we're talking about

00:05:28,720 --> 00:05:32,160
things like factory and singleton

00:05:30,880 --> 00:05:34,000
and all these other things that are

00:05:32,160 --> 00:05:35,600
really based on utility

00:05:34,000 --> 00:05:37,440
it just seems like something in the

00:05:35,600 --> 00:05:40,000
toolbox that a lot of people go for

00:05:37,440 --> 00:05:41,360
frequently and that's totally cool but

00:05:40,000 --> 00:05:42,560
what we're talking about in terms of

00:05:41,360 --> 00:05:43,840
design patterns is something

00:05:42,560 --> 00:05:45,280
fundamentally different

00:05:43,840 --> 00:05:47,840
we're talking about patterns that are

00:05:45,280 --> 00:05:49,600
described that are discovered in nature

00:05:47,840 --> 00:05:51,600
these are not going away they are not

00:05:49,600 --> 00:05:52,080
transitory these are related to the

00:05:51,600 --> 00:05:54,320
physical

00:05:52,080 --> 00:05:56,240
laws of the universe and they can impact

00:05:54,320 --> 00:05:58,560
how you design your programs

00:05:56,240 --> 00:06:00,240
now when you hear words like category

00:05:58,560 --> 00:06:03,199
functor duality monod

00:06:00,240 --> 00:06:04,800
isomorphisms etc all these words are

00:06:03,199 --> 00:06:05,919
associated with category theory

00:06:04,800 --> 00:06:07,280
we're not going to cover all them we're

00:06:05,919 --> 00:06:08,960
only going to look at a few of them and

00:06:07,280 --> 00:06:10,560
then you can go on after this talk and

00:06:08,960 --> 00:06:11,919
do your own investigation and research

00:06:10,560 --> 00:06:14,160
and discover the wealth

00:06:11,919 --> 00:06:16,240
of interesting theoretic concepts that

00:06:14,160 --> 00:06:19,680
can apply to your functional

00:06:16,240 --> 00:06:21,759
to your designs now

00:06:19,680 --> 00:06:23,039
we're going to start taking a look at

00:06:21,759 --> 00:06:25,600
the first

00:06:23,039 --> 00:06:26,560
of our category theoretic concepts which

00:06:25,600 --> 00:06:30,400
is called

00:06:26,560 --> 00:06:33,680
amanoid so a monoid

00:06:30,400 --> 00:06:34,639
is a type in combination with a binary

00:06:33,680 --> 00:06:36,639
operation

00:06:34,639 --> 00:06:38,560
a type t some kind of binary operation

00:06:36,639 --> 00:06:39,120
which is like across a little circle in

00:06:38,560 --> 00:06:41,440
it

00:06:39,120 --> 00:06:42,400
now the binary operation combines the

00:06:41,440 --> 00:06:44,800
values

00:06:42,400 --> 00:06:46,800
now in order for a type combined with a

00:06:44,800 --> 00:06:47,680
binary operation to be considered a

00:06:46,800 --> 00:06:49,840
monoid

00:06:47,680 --> 00:06:51,120
all you have to do is have these two

00:06:49,840 --> 00:06:54,160
properties first

00:06:51,120 --> 00:06:57,280
that operation needs to be associative a

00:06:54,160 --> 00:07:00,000
op b op c is the same thing as doing b

00:06:57,280 --> 00:07:01,039
op c and then doing a op that at the end

00:07:00,000 --> 00:07:03,919
of it

00:07:01,039 --> 00:07:04,400
for every single value now also this

00:07:03,919 --> 00:07:06,560
type

00:07:04,400 --> 00:07:07,599
needs to have a special value e such

00:07:06,560 --> 00:07:10,400
that e

00:07:07,599 --> 00:07:10,800
op x is the same thing as x op e which

00:07:10,400 --> 00:07:13,759
is just

00:07:10,800 --> 00:07:15,520
x in other words it's the identity

00:07:13,759 --> 00:07:17,120
operation uh when you apply it to the

00:07:15,520 --> 00:07:19,039
to the operation you get this almost

00:07:17,120 --> 00:07:21,840
like an identity function does that all

00:07:19,039 --> 00:07:21,840
make sense to you

00:07:26,880 --> 00:07:30,160
okay uh well let's try to break it down

00:07:29,599 --> 00:07:33,280
into

00:07:30,160 --> 00:07:36,319
a simpler example here so

00:07:33,280 --> 00:07:37,280
numeric types like numbers

00:07:36,319 --> 00:07:38,479
all right we're not doing any

00:07:37,280 --> 00:07:40,240
programming yet we're just talking about

00:07:38,479 --> 00:07:43,599
numbers

00:07:40,240 --> 00:07:44,960
we have a plus b plus c if you do a plus

00:07:43,599 --> 00:07:46,960
the parenthesis around a plus b

00:07:44,960 --> 00:07:48,319
first a plus b plus c is the same thing

00:07:46,960 --> 00:07:50,639
as a plus b plus c

00:07:48,319 --> 00:07:53,919
if you put the parentheses around b plus

00:07:50,639 --> 00:07:53,919
c does that make sense

00:07:55,360 --> 00:07:59,840
okay good now what should be the special

00:07:59,120 --> 00:08:02,879
value

00:07:59,840 --> 00:08:05,599
what do you put plus any number to get

00:08:02,879 --> 00:08:09,440
that number back

00:08:05,599 --> 00:08:13,520
zero yes exactly

00:08:09,440 --> 00:08:16,560
zero so we have the numeric types

00:08:13,520 --> 00:08:19,039
and we have the special value zero and

00:08:16,560 --> 00:08:20,879
you put these together with plus and you

00:08:19,039 --> 00:08:24,000
get a monoid

00:08:20,879 --> 00:08:26,800
all right now let's see who can take a

00:08:24,000 --> 00:08:28,800
gander about what the monoid would look

00:08:26,800 --> 00:08:32,400
like if we had numeric types

00:08:28,800 --> 00:08:32,400
with multiplication

00:08:33,839 --> 00:08:37,839
well the first question would be what is

00:08:36,640 --> 00:08:39,839
the special value

00:08:37,839 --> 00:08:42,560
what do you multiply by any number and

00:08:39,839 --> 00:08:42,560
get that number back

00:08:44,720 --> 00:08:49,360
you multiply anything by one and you get

00:08:47,120 --> 00:08:53,360
the same thing back

00:08:49,360 --> 00:08:56,480
yes exactly you got it you got it

00:08:53,360 --> 00:08:58,720
that's exactly what it should be so uh

00:08:56,480 --> 00:08:59,760
the numeric types with multiplication

00:08:58,720 --> 00:09:02,240
are monoids

00:08:59,760 --> 00:09:02,880
if you look at one as the special value

00:09:02,240 --> 00:09:05,120
and

00:09:02,880 --> 00:09:06,080
you use just a multiplication operation

00:09:05,120 --> 00:09:08,800
which has the

00:09:06,080 --> 00:09:10,160
the property of a times b times c equals

00:09:08,800 --> 00:09:11,680
a times b times c no matter where you

00:09:10,160 --> 00:09:14,800
put the parents

00:09:11,680 --> 00:09:14,800
cool now

00:09:14,959 --> 00:09:23,839
what about an unsigned number

00:09:18,880 --> 00:09:23,839
with stood max as the operation

00:09:25,440 --> 00:09:30,560
well if you take a look at that property

00:09:28,240 --> 00:09:32,720
of you know max of max a b

00:09:30,560 --> 00:09:33,920
c is the same thing as max of a comma

00:09:32,720 --> 00:09:35,920
max of b of c

00:09:33,920 --> 00:09:37,360
okay that totally makes sense what would

00:09:35,920 --> 00:09:40,560
be the special value for

00:09:37,360 --> 00:09:41,279
max with an unsigned max of anything in

00:09:40,560 --> 00:09:44,240
this number

00:09:41,279 --> 00:09:44,240
gives you the other thing

00:09:45,839 --> 00:09:52,399
zero yes carmen

00:09:49,040 --> 00:09:54,240
yes exactly zero is the special value in

00:09:52,399 --> 00:09:56,320
that case

00:09:54,240 --> 00:09:58,080
absolutely great so now we're being able

00:09:56,320 --> 00:10:01,200
to discover more and more

00:09:58,080 --> 00:10:04,480
monoids and let me tell you

00:10:01,200 --> 00:10:06,720
mynoids are absolutely all over the

00:10:04,480 --> 00:10:08,800
place

00:10:06,720 --> 00:10:10,160
now one other question that you might

00:10:08,800 --> 00:10:10,880
ask is and i'll leave this for an

00:10:10,160 --> 00:10:12,399
exercise

00:10:10,880 --> 00:10:13,920
kids don't write don't don't give the

00:10:12,399 --> 00:10:15,200
answer away because i want i want the

00:10:13,920 --> 00:10:18,320
people on the screen to do it

00:10:15,200 --> 00:10:19,279
the question is what is the e value for

00:10:18,320 --> 00:10:21,680
the float

00:10:19,279 --> 00:10:22,720
comma stood min monoid all right you

00:10:21,680 --> 00:10:24,880
guys in the audience

00:10:22,720 --> 00:10:26,079
that aren't my kids please figure this

00:10:24,880 --> 00:10:28,480
out and think about it it's actually

00:10:26,079 --> 00:10:31,440
quite an interesting answer

00:10:28,480 --> 00:10:32,480
now here's another question does stood

00:10:31,440 --> 00:10:35,680
vector

00:10:32,480 --> 00:10:39,760
form amanoid with something

00:10:35,680 --> 00:10:41,440
think about it what would a uh amanoid

00:10:39,760 --> 00:10:46,360
if vector were a monoid what would the

00:10:41,440 --> 00:10:50,399
operation be

00:10:46,360 --> 00:10:52,800
concatenation yes that's exactly right

00:10:50,399 --> 00:10:54,959
basically with a stud vector if you have

00:10:52,800 --> 00:10:57,360
a vector and another vector and you just

00:10:54,959 --> 00:10:58,480
concatenate their contents that actually

00:10:57,360 --> 00:11:01,120
forms a monoid

00:10:58,480 --> 00:11:04,079
and what would be the the e element for

00:11:01,120 --> 00:11:04,079
the monod in that case

00:11:10,480 --> 00:11:19,040
the empty vector correct

00:11:15,839 --> 00:11:20,959
now what could you do if you had a

00:11:19,040 --> 00:11:22,959
list or some kind of collection of

00:11:20,959 --> 00:11:24,399
monoids what would be some kind of

00:11:22,959 --> 00:11:24,800
operation that you could do on such a

00:11:24,399 --> 00:11:29,839
thing

00:11:24,800 --> 00:11:29,839
knowing only that it's a monoid

00:11:30,480 --> 00:11:36,000
squash that's right you squash them

00:11:34,560 --> 00:11:37,440
that's the thing about monoids is that

00:11:36,000 --> 00:11:38,880
you can basically squash them together

00:11:37,440 --> 00:11:40,880
whether you have zero of them in which

00:11:38,880 --> 00:11:43,279
case you produce the e element or you

00:11:40,880 --> 00:11:46,079
have a bunch of them

00:11:43,279 --> 00:11:48,720
now we're going to talk about some fancy

00:11:46,079 --> 00:11:48,720
monoids

00:11:49,279 --> 00:11:53,040
now stood optional template a stud

00:11:51,839 --> 00:11:55,200
optional

00:11:53,040 --> 00:11:56,240
which you all know is either null or has

00:11:55,200 --> 00:12:00,480
a value of type

00:11:56,240 --> 00:12:03,200
t the question is is stood optional

00:12:00,480 --> 00:12:03,200
a monoid

00:12:06,160 --> 00:12:12,639
yes because you're asking

00:12:09,200 --> 00:12:15,920
yes it's a monoid so what would the

00:12:12,639 --> 00:12:18,639
uh the minoid operation be like if

00:12:15,920 --> 00:12:21,120
if it's an optional phenomonoid the

00:12:18,639 --> 00:12:23,519
optional monoid is a monod

00:12:21,120 --> 00:12:24,880
use the underlying operation on the

00:12:23,519 --> 00:12:28,000
optional contents

00:12:24,880 --> 00:12:31,680
assuming it has some yes exactly

00:12:28,000 --> 00:12:33,040
a stood optional manoid is amanoid so if

00:12:31,680 --> 00:12:34,079
you have a stood optional vamanoi that

00:12:33,040 --> 00:12:36,639
is also a monoid

00:12:34,079 --> 00:12:37,200
and the way that you do the operation is

00:12:36,639 --> 00:12:40,320
if

00:12:37,200 --> 00:12:42,240
the left-hand side is empty

00:12:40,320 --> 00:12:43,760
then you choose the right-hand side if

00:12:42,240 --> 00:12:47,279
the right-hand side

00:12:43,760 --> 00:12:48,880
is non-empty then you use the monoid

00:12:47,279 --> 00:12:49,600
operation of the left-hand side and the

00:12:48,880 --> 00:12:50,959
right-hand side

00:12:49,600 --> 00:12:53,040
otherwise you just use the left-hand

00:12:50,959 --> 00:12:54,160
side in other words if they both have

00:12:53,040 --> 00:12:56,800
something in it

00:12:54,160 --> 00:12:58,000
you squash the two things on the inside

00:12:56,800 --> 00:13:01,040
to get your optional

00:12:58,000 --> 00:13:04,079
monoid now another stood

00:13:01,040 --> 00:13:06,399
optional monoi would be for example this

00:13:04,079 --> 00:13:07,519
where you can take essentially just

00:13:06,399 --> 00:13:09,600
always prefer

00:13:07,519 --> 00:13:11,279
the right hand side that also would form

00:13:09,600 --> 00:13:13,440
a monoid there are a few different ways

00:13:11,279 --> 00:13:16,079
of of doing this really

00:13:13,440 --> 00:13:17,040
so here's a more complex question do

00:13:16,079 --> 00:13:20,639
functions

00:13:17,040 --> 00:13:23,360
returning some value form

00:13:20,639 --> 00:13:23,360
amanoid

00:13:26,639 --> 00:13:30,240
functions of the same type that return

00:13:28,480 --> 00:13:31,839
to monoid are also amanoid

00:13:30,240 --> 00:13:33,440
and here's what that function would look

00:13:31,839 --> 00:13:35,600
like you essentially

00:13:33,440 --> 00:13:36,880
have a function called append which

00:13:35,600 --> 00:13:40,000
takes in two functions

00:13:36,880 --> 00:13:41,360
and returns a new function based on

00:13:40,000 --> 00:13:44,079
the results of the two functions of the

00:13:41,360 --> 00:13:45,040
input so it builds a lambda function on

00:13:44,079 --> 00:13:48,560
the inside

00:13:45,040 --> 00:13:49,440
that takes in any value a and the result

00:13:48,560 --> 00:13:52,160
of that

00:13:49,440 --> 00:13:53,600
that lambda function takes the left-hand

00:13:52,160 --> 00:13:55,680
side operated to a

00:13:53,600 --> 00:13:57,440
minor operation of the right-hand side

00:13:55,680 --> 00:13:58,079
operated at a and squashes those two

00:13:57,440 --> 00:14:00,560
together

00:13:58,079 --> 00:14:02,079
and that's how you can have a function

00:14:00,560 --> 00:14:03,600
that returns a monoid

00:14:02,079 --> 00:14:06,240
that the set of functions which return

00:14:03,600 --> 00:14:08,800
amanoid actually form amonoid themselves

00:14:06,240 --> 00:14:10,240
with this kind of operation and the

00:14:08,800 --> 00:14:11,760
empty element of course

00:14:10,240 --> 00:14:14,000
is going to be the function which takes

00:14:11,760 --> 00:14:16,079
in any value and always returns the

00:14:14,000 --> 00:14:17,760
empty element of the monoid

00:14:16,079 --> 00:14:19,519
let's say you want to search for the n

00:14:17,760 --> 00:14:20,720
best occurrences of a word in a million

00:14:19,519 --> 00:14:22,880
documents

00:14:20,720 --> 00:14:24,000
the key insight here is that an n-heap

00:14:22,880 --> 00:14:26,720
data structure

00:14:24,000 --> 00:14:27,760
is amanoid and n-heap in case you aren't

00:14:26,720 --> 00:14:30,560
familiar with it

00:14:27,760 --> 00:14:32,079
is basically a list of the best elements

00:14:30,560 --> 00:14:35,199
you know for some definition

00:14:32,079 --> 00:14:36,880
definition of best and according to like

00:14:35,199 --> 00:14:38,480
their goodness criteria

00:14:36,880 --> 00:14:40,399
and you can take n heaps and combine

00:14:38,480 --> 00:14:42,880
them together to get other n heaps

00:14:40,399 --> 00:14:44,959
and this is a monoid you can split

00:14:42,880 --> 00:14:46,160
documents between your cluster nodes

00:14:44,959 --> 00:14:47,760
you send the word to each of your

00:14:46,160 --> 00:14:48,639
cluster nodes which has many many

00:14:47,760 --> 00:14:51,120
documents

00:14:48,639 --> 00:14:51,680
each cluster node generates its n heap

00:14:51,120 --> 00:14:53,839
using

00:14:51,680 --> 00:14:55,279
internal parallelization and then each

00:14:53,839 --> 00:14:56,320
cluster node sends its heap to a

00:14:55,279 --> 00:14:59,600
collection node

00:14:56,320 --> 00:15:02,959
the collection node just joins the heaps

00:14:59,600 --> 00:15:04,639
using the monadic operation key insights

00:15:02,959 --> 00:15:07,519
here that we're getting about monoids

00:15:04,639 --> 00:15:08,880
they scale very well they compose via

00:15:07,519 --> 00:15:10,480
functions and optional and other things

00:15:08,880 --> 00:15:12,880
so remember when we talked about

00:15:10,480 --> 00:15:15,600
how does the observation of something

00:15:12,880 --> 00:15:17,839
being a category theoretic concept

00:15:15,600 --> 00:15:18,639
apply to other classes when you compose

00:15:17,839 --> 00:15:22,880
it

00:15:18,639 --> 00:15:26,160
and monoids are very very common

00:15:22,880 --> 00:15:28,160
functors so unlike

00:15:26,160 --> 00:15:29,199
monois what we were looking at before

00:15:28,160 --> 00:15:31,120
functors are not

00:15:29,199 --> 00:15:33,279
individual values it's best to think

00:15:31,120 --> 00:15:36,399
about them as class templates

00:15:33,279 --> 00:15:37,040
so a functor is a class template with a

00:15:36,399 --> 00:15:39,279
single

00:15:37,040 --> 00:15:42,079
template parameter and in addition to

00:15:39,279 --> 00:15:45,199
this type you have a callable

00:15:42,079 --> 00:15:46,399
uh called map okay and map has the

00:15:45,199 --> 00:15:48,240
following properties

00:15:46,399 --> 00:15:50,320
map takes in a function as its first

00:15:48,240 --> 00:15:52,320
argument let's say from a to b

00:15:50,320 --> 00:15:53,440
and it takes in a functor as a second

00:15:52,320 --> 00:15:55,839
argument so

00:15:53,440 --> 00:15:56,880
let's say it's a functor of type a and

00:15:55,839 --> 00:16:00,240
what it returns

00:15:56,880 --> 00:16:00,959
is a functor of type b so there are

00:16:00,240 --> 00:16:04,240
different

00:16:00,959 --> 00:16:06,000
rules associated with this if you take

00:16:04,240 --> 00:16:07,680
in an identity function so a function

00:16:06,000 --> 00:16:08,079
that always returns this argument as the

00:16:07,680 --> 00:16:10,480
first

00:16:08,079 --> 00:16:11,759
argument of the function that you pass

00:16:10,480 --> 00:16:14,160
in the map

00:16:11,759 --> 00:16:15,600
that will not change the functor that

00:16:14,160 --> 00:16:18,000
you pass in as the second argument

00:16:15,600 --> 00:16:20,160
because it returns the new functor it

00:16:18,000 --> 00:16:21,199
also has some composition rules to make

00:16:20,160 --> 00:16:24,320
sure that

00:16:21,199 --> 00:16:26,160
applying a funct a function to a

00:16:24,320 --> 00:16:27,120
functory calling map two times with two

00:16:26,160 --> 00:16:29,120
different functions

00:16:27,120 --> 00:16:30,480
is the same thing as compose composing

00:16:29,120 --> 00:16:33,680
the functions first

00:16:30,480 --> 00:16:35,519
and then calling map of that but

00:16:33,680 --> 00:16:36,880
let's build up some kind of intuition

00:16:35,519 --> 00:16:40,079
for functors

00:16:36,880 --> 00:16:43,040
functors are a lot like containers

00:16:40,079 --> 00:16:44,000
map applies a function to the thing in

00:16:43,040 --> 00:16:46,639
the container

00:16:44,000 --> 00:16:48,160
resulting in a new container of the

00:16:46,639 --> 00:16:50,399
transformed values

00:16:48,160 --> 00:16:51,839
transform for example if you're familiar

00:16:50,399 --> 00:16:55,519
with that standard algorithm

00:16:51,839 --> 00:16:57,759
is like map but for containers

00:16:55,519 --> 00:16:59,519
and the laws provide these reasonable

00:16:57,759 --> 00:17:02,800
rules for map composition

00:16:59,519 --> 00:17:04,799
so stood vector is a functor

00:17:02,800 --> 00:17:06,000
what happens when you what is the map

00:17:04,799 --> 00:17:08,160
function defined

00:17:06,000 --> 00:17:09,600
for stood vector so map takes in a

00:17:08,160 --> 00:17:12,079
function let's say from

00:17:09,600 --> 00:17:13,839
t to u and we have a stood vector of u

00:17:12,079 --> 00:17:16,400
as the second argument of map

00:17:13,839 --> 00:17:18,559
what does it do it creates a new vector

00:17:16,400 --> 00:17:20,959
for the return value and

00:17:18,559 --> 00:17:23,280
that new return value just applies f to

00:17:20,959 --> 00:17:25,439
all the values in the input parameter

00:17:23,280 --> 00:17:27,520
okay so again we're just transforming

00:17:25,439 --> 00:17:29,280
the values inside of the vector

00:17:27,520 --> 00:17:30,960
that's one that's the intuition for

00:17:29,280 --> 00:17:33,440
vector as a function

00:17:30,960 --> 00:17:35,760
what about stood optional is stud

00:17:33,440 --> 00:17:39,120
optional a functor what do you think

00:17:35,760 --> 00:17:41,280
yes it is it is indeed

00:17:39,120 --> 00:17:42,240
and what would its map function look

00:17:41,280 --> 00:17:45,600
like

00:17:42,240 --> 00:17:48,400
if the optional is empty return empty

00:17:45,600 --> 00:17:49,280
but with the result type if it has a

00:17:48,400 --> 00:17:52,080
value

00:17:49,280 --> 00:17:54,000
then apply f to the value and wrap that

00:17:52,080 --> 00:17:57,440
as an optional

00:17:54,000 --> 00:18:00,080
yes exactly map takes in a function

00:17:57,440 --> 00:18:00,880
and an optional and if the optional is

00:18:00,080 --> 00:18:03,600
none

00:18:00,880 --> 00:18:05,440
then it returns a none optional of the

00:18:03,600 --> 00:18:07,120
transformed type

00:18:05,440 --> 00:18:08,960
but if it has a value inside the

00:18:07,120 --> 00:18:09,919
optional then it returns a new stood

00:18:08,960 --> 00:18:12,320
optional value

00:18:09,919 --> 00:18:14,000
with the by applying the function to the

00:18:12,320 --> 00:18:15,200
thing inside the optional that was part

00:18:14,000 --> 00:18:19,120
of the parameter

00:18:15,200 --> 00:18:22,320
exactly right what about stood pair

00:18:19,120 --> 00:18:24,960
is stood parafunctor it seems like it

00:18:22,320 --> 00:18:28,080
should be somehow

00:18:24,960 --> 00:18:29,200
yes it does indeed seem like stood pair

00:18:28,080 --> 00:18:31,120
should be a functor

00:18:29,200 --> 00:18:32,559
but remember that functors have one

00:18:31,120 --> 00:18:35,600
template argument which is

00:18:32,559 --> 00:18:37,280
changing so with the case of stood pair

00:18:35,600 --> 00:18:38,640
what we want to do is take that first

00:18:37,280 --> 00:18:40,320
template argument or the second

00:18:38,640 --> 00:18:43,679
depending on how you define your

00:18:40,320 --> 00:18:45,520
map function and fix it so

00:18:43,679 --> 00:18:47,360
the first parameter in a pair doesn't

00:18:45,520 --> 00:18:47,840
change or the first value in a pair

00:18:47,360 --> 00:18:50,480
doesn't

00:18:47,840 --> 00:18:52,080
change and the function is applied to

00:18:50,480 --> 00:18:56,480
the second

00:18:52,080 --> 00:18:57,840
part of the pair what about stood

00:18:56,480 --> 00:19:01,360
function

00:18:57,840 --> 00:19:03,760
is stood function a functor

00:19:01,360 --> 00:19:04,400
and it turns out stood function can be a

00:19:03,760 --> 00:19:06,160
functor

00:19:04,400 --> 00:19:08,160
if you fix all the parameters of your

00:19:06,160 --> 00:19:10,559
stood function so that every single

00:19:08,160 --> 00:19:13,360
function has a fixed set of parameters

00:19:10,559 --> 00:19:13,760
and the result of the stood function is

00:19:13,360 --> 00:19:16,080
that

00:19:13,760 --> 00:19:17,039
changing type so you build a new

00:19:16,080 --> 00:19:19,440
function which

00:19:17,039 --> 00:19:20,880
transforms the result of the old

00:19:19,440 --> 00:19:24,000
function

00:19:20,880 --> 00:19:24,880
and this is what a map function would

00:19:24,000 --> 00:19:28,160
look like for

00:19:24,880 --> 00:19:28,160
a stood function functor

00:19:30,559 --> 00:19:35,200
functors allow for transformations

00:19:33,120 --> 00:19:38,000
within the type

00:19:35,200 --> 00:19:38,960
each map strips away one layer of your

00:19:38,000 --> 00:19:40,640
data type

00:19:38,960 --> 00:19:42,000
if you're working with a stud vector you

00:19:40,640 --> 00:19:44,400
can strip away

00:19:42,000 --> 00:19:46,640
the vector part of it by using a map to

00:19:44,400 --> 00:19:48,799
get to the thing on the inside

00:19:46,640 --> 00:19:50,480
so say you have a vector of stood

00:19:48,799 --> 00:19:51,360
optional in and want to get strings for

00:19:50,480 --> 00:19:52,799
each end

00:19:51,360 --> 00:19:54,480
look at this function and how it's

00:19:52,799 --> 00:19:57,200
defined so f1

00:19:54,480 --> 00:19:58,080
all it does is it converts an int into a

00:19:57,200 --> 00:20:00,400
string

00:19:58,080 --> 00:20:01,280
f2 uses the map function to convert an

00:20:00,400 --> 00:20:04,240
optional int

00:20:01,280 --> 00:20:05,039
into an optional string and then f3

00:20:04,240 --> 00:20:08,080
converts

00:20:05,039 --> 00:20:09,919
and a vector of optional int to a vector

00:20:08,080 --> 00:20:10,240
of optional string so you see how we're

00:20:09,919 --> 00:20:12,159
just

00:20:10,240 --> 00:20:14,000
building these maps and each map

00:20:12,159 --> 00:20:14,880
subsequently gets you to the innermost

00:20:14,000 --> 00:20:17,520
thing

00:20:14,880 --> 00:20:19,360
that is how you can compose various

00:20:17,520 --> 00:20:21,600
functors of functors of functors

00:20:19,360 --> 00:20:25,280
and get to the thing on the inside is a

00:20:21,600 --> 00:20:27,520
very powerful composition

00:20:25,280 --> 00:20:30,000
now let's take a look at applicative

00:20:27,520 --> 00:20:30,000
functors

00:20:30,880 --> 00:20:34,559
an applicative functor is a functor with

00:20:33,919 --> 00:20:38,880
two

00:20:34,559 --> 00:20:42,000
extra operations pure and apply

00:20:38,880 --> 00:20:43,360
now pure and apply uh have have the

00:20:42,000 --> 00:20:45,360
following rules but basically

00:20:43,360 --> 00:20:46,720
pure the way you can think about it is a

00:20:45,360 --> 00:20:50,000
way for you to

00:20:46,720 --> 00:20:51,039
create a new applicative based on a

00:20:50,000 --> 00:20:52,880
plain value

00:20:51,039 --> 00:20:54,480
so let's say optional is an implicative

00:20:52,880 --> 00:20:55,600
functor which we'll find out it is in a

00:20:54,480 --> 00:20:58,240
minute

00:20:55,600 --> 00:21:00,840
if you call pure of three you're going

00:20:58,240 --> 00:21:03,520
to get an optional of

00:21:00,840 --> 00:21:06,480
int apply

00:21:03,520 --> 00:21:07,360
this is something that applies a

00:21:06,480 --> 00:21:10,240
applicative

00:21:07,360 --> 00:21:12,080
of a function to an applicative so

00:21:10,240 --> 00:21:13,600
remember how map you took just a plain

00:21:12,080 --> 00:21:17,360
old function from a to b

00:21:13,600 --> 00:21:17,760
and you applied it to the the functor of

00:21:17,360 --> 00:21:20,080
a

00:21:17,760 --> 00:21:22,240
to get the functor of b the difference

00:21:20,080 --> 00:21:25,840
with between that and apply

00:21:22,240 --> 00:21:26,880
is that apply takes an implicative of

00:21:25,840 --> 00:21:28,799
the functor

00:21:26,880 --> 00:21:30,000
and applies it to an applicative value

00:21:28,799 --> 00:21:32,240
to get a new applicative

00:21:30,000 --> 00:21:33,679
value now we'll look at some examples of

00:21:32,240 --> 00:21:36,080
this to make it more

00:21:33,679 --> 00:21:38,080
concrete in a second here now

00:21:36,080 --> 00:21:38,799
applicative functors have a bunch of

00:21:38,080 --> 00:21:42,080
laws

00:21:38,799 --> 00:21:43,919
and i'm just showing them here to you

00:21:42,080 --> 00:21:45,120
for your own interest i'm not going to

00:21:43,919 --> 00:21:48,240
go over these laws

00:21:45,120 --> 00:21:49,760
it does what you would expect it to do

00:21:48,240 --> 00:21:51,520
if you try to think about what would be

00:21:49,760 --> 00:21:53,039
the natural laws for an applicative

00:21:51,520 --> 00:21:56,240
functor

00:21:53,039 --> 00:21:57,120
now the intuition behind applicative

00:21:56,240 --> 00:21:59,600
functors

00:21:57,120 --> 00:22:00,320
as i mentioned pure wraps a value into a

00:21:59,600 --> 00:22:02,320
container

00:22:00,320 --> 00:22:04,000
apply applies the contained function to

00:22:02,320 --> 00:22:05,600
a contained value to get a contained

00:22:04,000 --> 00:22:08,640
result

00:22:05,600 --> 00:22:09,520
and if you think about it apply can be

00:22:08,640 --> 00:22:11,600
extended to n

00:22:09,520 --> 00:22:12,720
argument functions by doing some

00:22:11,600 --> 00:22:15,600
additional work

00:22:12,720 --> 00:22:16,960
um by you can base and end argument

00:22:15,600 --> 00:22:19,039
apply on a single

00:22:16,960 --> 00:22:21,200
single argument apply i'll let you think

00:22:19,039 --> 00:22:23,520
about that as an exercise

00:22:21,200 --> 00:22:24,240
so the up stood optional applicative

00:22:23,520 --> 00:22:28,080
functor

00:22:24,240 --> 00:22:30,480
so pure for optional looks like this

00:22:28,080 --> 00:22:31,760
which is of course no surprise you

00:22:30,480 --> 00:22:34,640
basically take the value

00:22:31,760 --> 00:22:35,520
you put it into an optional now what

00:22:34,640 --> 00:22:38,400
about

00:22:35,520 --> 00:22:40,000
the apply function so the apply function

00:22:38,400 --> 00:22:41,440
if you think about it you have the

00:22:40,000 --> 00:22:42,720
applicative of the function and you have

00:22:41,440 --> 00:22:44,400
the applicative of the value so you have

00:22:42,720 --> 00:22:45,440
an optional function and an optional

00:22:44,400 --> 00:22:48,159
value

00:22:45,440 --> 00:22:50,400
if they both happen to have a value you

00:22:48,159 --> 00:22:51,120
know the optionals is not none in either

00:22:50,400 --> 00:22:53,600
case

00:22:51,120 --> 00:22:54,240
then you apply the thing on the inside

00:22:53,600 --> 00:22:56,159
of the

00:22:54,240 --> 00:22:57,919
of the function argument to the thing on

00:22:56,159 --> 00:23:01,280
the inside of the value argument

00:22:57,919 --> 00:23:03,520
and then wrap that into an optional

00:23:01,280 --> 00:23:05,679
if either of them happen to be null then

00:23:03,520 --> 00:23:08,400
you just return null

00:23:05,679 --> 00:23:10,400
how could this be interesting consider

00:23:08,400 --> 00:23:13,039
this snippet of code

00:23:10,400 --> 00:23:14,080
here we have optional double of a equals

00:23:13,039 --> 00:23:15,919
some computation

00:23:14,080 --> 00:23:18,559
optional double of b equals some other

00:23:15,919 --> 00:23:20,880
computation optional value c

00:23:18,559 --> 00:23:21,600
you apply plus to the optional double of

00:23:20,880 --> 00:23:24,080
a and the

00:23:21,600 --> 00:23:24,720
optional double b and then d you apply

00:23:24,080 --> 00:23:27,440
negate

00:23:24,720 --> 00:23:28,400
to the optional value c what's going on

00:23:27,440 --> 00:23:31,600
here

00:23:28,400 --> 00:23:34,320
let's say a is null what is d

00:23:31,600 --> 00:23:35,200
going to be no let's say a isn't null

00:23:34,320 --> 00:23:37,679
but maybe

00:23:35,200 --> 00:23:38,400
b or c turns out to be null or actually

00:23:37,679 --> 00:23:40,720
let's say b

00:23:38,400 --> 00:23:42,320
turns out to be null well then the n

00:23:40,720 --> 00:23:44,480
answer would be null

00:23:42,320 --> 00:23:46,080
so here what we're seeing is that if you

00:23:44,480 --> 00:23:46,880
think of null as being an error

00:23:46,080 --> 00:23:48,880
condition

00:23:46,880 --> 00:23:50,799
is a way for us to propagate errors

00:23:48,880 --> 00:23:52,480
throughout a program

00:23:50,799 --> 00:23:54,159
and this isn't the first time this has

00:23:52,480 --> 00:23:54,799
been discovered it was discovered a long

00:23:54,159 --> 00:23:57,039
time ago

00:23:54,799 --> 00:23:59,200
that applicative applicative functors

00:23:57,039 --> 00:24:02,080
have this kind of

00:23:59,200 --> 00:24:03,840
error propagation behavior when you use

00:24:02,080 --> 00:24:05,840
them withstood optional

00:24:03,840 --> 00:24:06,880
interesting stuff what about stood

00:24:05,840 --> 00:24:09,919
vector

00:24:06,880 --> 00:24:12,240
is stood vector an applicative functor

00:24:09,919 --> 00:24:13,120
well is it a functor well we know that

00:24:12,240 --> 00:24:16,400
it's a functor

00:24:13,120 --> 00:24:19,760
we know what map is for a stud vector

00:24:16,400 --> 00:24:21,440
what about pure well pure first stood

00:24:19,760 --> 00:24:23,600
vector could very easily be

00:24:21,440 --> 00:24:24,799
just create a vector with one element in

00:24:23,600 --> 00:24:27,360
it of that value

00:24:24,799 --> 00:24:28,559
that makes complete sense what about

00:24:27,360 --> 00:24:31,760
apply though

00:24:28,559 --> 00:24:33,279
you've got a vector of functions and a

00:24:31,760 --> 00:24:37,200
vector of values

00:24:33,279 --> 00:24:38,480
what can you do apply every function to

00:24:37,200 --> 00:24:41,200
every value

00:24:38,480 --> 00:24:42,080
and you put the result in a vector

00:24:41,200 --> 00:24:44,400
exactly right

00:24:42,080 --> 00:24:45,520
you can apply each function to each

00:24:44,400 --> 00:24:47,679
different value

00:24:45,520 --> 00:24:49,200
for you know function one you apply it

00:24:47,679 --> 00:24:50,640
to all the different values for function

00:24:49,200 --> 00:24:52,320
two you apply it to all the different

00:24:50,640 --> 00:24:54,000
values and so on until you compute a

00:24:52,320 --> 00:24:56,720
vector of all the results of all the

00:24:54,000 --> 00:25:00,080
functions applied to all the values

00:24:56,720 --> 00:25:02,559
so what is this uh what is this model

00:25:00,080 --> 00:25:03,919
well think about it let's look at this

00:25:02,559 --> 00:25:06,640
code snippet here

00:25:03,919 --> 00:25:08,240
here we have a vector of doubles a and a

00:25:06,640 --> 00:25:11,679
vector of doubles b

00:25:08,240 --> 00:25:14,559
and what we do is we apply stood plus

00:25:11,679 --> 00:25:15,200
to a and b and of course we're we're

00:25:14,559 --> 00:25:17,840
doing

00:25:15,200 --> 00:25:18,799
the the n n argument version of apply

00:25:17,840 --> 00:25:20,799
here

00:25:18,799 --> 00:25:22,320
what you get are all the different

00:25:20,799 --> 00:25:25,720
possible ways to add

00:25:22,320 --> 00:25:28,799
vectors of a and vectors of b this is

00:25:25,720 --> 00:25:31,919
non-determinism the applicative functor

00:25:28,799 --> 00:25:33,600
for stood vector models non-determinism

00:25:31,919 --> 00:25:34,960
now there are a lot of different

00:25:33,600 --> 00:25:37,600
applicative functors

00:25:34,960 --> 00:25:39,360
stood future is one continuations

00:25:37,600 --> 00:25:40,960
exception style errors

00:25:39,360 --> 00:25:42,720
behaviors and functional reactive

00:25:40,960 --> 00:25:44,400
programming of which i'd love to speak

00:25:42,720 --> 00:25:47,679
more about that one time

00:25:44,400 --> 00:25:50,320
or parsers etc so

00:25:47,679 --> 00:25:51,039
functors apply all over the place and

00:25:50,320 --> 00:25:54,480
are a very

00:25:51,039 --> 00:25:54,960
key interesting example now let's take a

00:25:54,480 --> 00:25:58,000
look

00:25:54,960 --> 00:26:01,840
at parser applicative functors

00:25:58,000 --> 00:26:04,880
these are a very interesting use case

00:26:01,840 --> 00:26:07,840
of applicative functors the idea

00:26:04,880 --> 00:26:10,000
here is to be able to build an interface

00:26:07,840 --> 00:26:13,200
for our parser library

00:26:10,000 --> 00:26:15,120
and utilize category theoretic concepts

00:26:13,200 --> 00:26:16,320
as a means for us to build a very

00:26:15,120 --> 00:26:18,720
powerful processor

00:26:16,320 --> 00:26:20,480
and give us that minimal set of

00:26:18,720 --> 00:26:22,799
operations that we want to have of which

00:26:20,480 --> 00:26:25,679
you can build everything out of

00:26:22,799 --> 00:26:27,919
so what are the fundamental operations

00:26:25,679 --> 00:26:29,840
for a parser

00:26:27,919 --> 00:26:31,279
so we'll start by defining our type

00:26:29,840 --> 00:26:33,840
parser of t

00:26:31,279 --> 00:26:35,120
it's just a stood in parser that parses

00:26:33,840 --> 00:26:37,760
into type t

00:26:35,120 --> 00:26:39,200
let's say this is simplifying you in in

00:26:37,760 --> 00:26:41,039
reality you probably wouldn't want to

00:26:39,200 --> 00:26:44,159
hard code it to be stdn

00:26:41,039 --> 00:26:48,559
but for our purposes this is just fine

00:26:44,159 --> 00:26:51,360
so if p has a uh a type parser of t

00:26:48,559 --> 00:26:53,279
p dot read tries to parse stood in if it

00:26:51,360 --> 00:26:55,279
succeeds it returns type t

00:26:53,279 --> 00:26:56,799
otherwise it throws an exception you

00:26:55,279 --> 00:26:57,919
probably want to do something other than

00:26:56,799 --> 00:27:00,159
throw an exception for your error

00:26:57,919 --> 00:27:03,440
handling but again for simplification

00:27:00,159 --> 00:27:05,600
we're just going to do it like this

00:27:03,440 --> 00:27:07,360
now this particular parser is

00:27:05,600 --> 00:27:10,400
implemented by having

00:27:07,360 --> 00:27:13,440
a collection a vector of chars which

00:27:10,400 --> 00:27:15,200
this parser knows that it can uh

00:27:13,440 --> 00:27:16,880
parse based on these charts this will

00:27:15,200 --> 00:27:19,520
help us with composition later

00:27:16,880 --> 00:27:20,640
so if you say you know your parser can

00:27:19,520 --> 00:27:22,720
read

00:27:20,640 --> 00:27:23,679
is only valid you know if it begins with

00:27:22,720 --> 00:27:25,600
the letter a

00:27:23,679 --> 00:27:27,840
then this vector of chars will have the

00:27:25,600 --> 00:27:30,240
single value a in it

00:27:27,840 --> 00:27:31,760
and it also has a boolean which just

00:27:30,240 --> 00:27:33,760
tells you whether or not

00:27:31,760 --> 00:27:35,279
this parser consumes nothing if it

00:27:33,760 --> 00:27:40,080
consumes nothing at all

00:27:35,279 --> 00:27:40,080
then this boolean will be true

00:27:40,240 --> 00:27:43,440
and then of course you have this stood

00:27:42,399 --> 00:27:45,120
function in there

00:27:43,440 --> 00:27:47,600
the function which actually does the

00:27:45,120 --> 00:27:48,559
reading so in our case the function has

00:27:47,600 --> 00:27:51,520
no parameters

00:27:48,559 --> 00:27:51,919
and just returns the value of type t all

00:27:51,520 --> 00:27:53,679
right

00:27:51,919 --> 00:27:55,840
that's our type we're going to create

00:27:53,679 --> 00:27:59,440
some friend functions here

00:27:55,840 --> 00:28:02,080
one is a parser which reads a single

00:27:59,440 --> 00:28:04,000
character from stood in any character

00:28:02,080 --> 00:28:06,559
okay so we just call that char p

00:28:04,000 --> 00:28:07,200
and it returns a parser of char we also

00:28:06,559 --> 00:28:09,679
have

00:28:07,200 --> 00:28:10,640
hrp which takes a particular character

00:28:09,679 --> 00:28:12,720
as input

00:28:10,640 --> 00:28:15,200
and returns a parser so this is a parser

00:28:12,720 --> 00:28:16,880
that if it reads in that character

00:28:15,200 --> 00:28:18,799
then it's successful if it if that

00:28:16,880 --> 00:28:20,559
character is not found in the input

00:28:18,799 --> 00:28:22,320
then it will not actually parse it

00:28:20,559 --> 00:28:26,000
properly

00:28:22,320 --> 00:28:28,240
and then we have an ether function here

00:28:26,000 --> 00:28:29,840
so either what it does is it takes in a

00:28:28,240 --> 00:28:33,279
parser

00:28:29,840 --> 00:28:35,200
of type a and a parser of type a so two

00:28:33,279 --> 00:28:37,760
parser of type a's is parameters and

00:28:35,200 --> 00:28:40,720
produces a parser of type a as a result

00:28:37,760 --> 00:28:41,520
and what happens is if lhs that first

00:28:40,720 --> 00:28:44,320
parameter there

00:28:41,520 --> 00:28:46,480
fails to read for some reason then it

00:28:44,320 --> 00:28:47,679
will use rhs

00:28:46,480 --> 00:28:51,120
all right makes sense so it's using

00:28:47,679 --> 00:28:54,399
either lhs or rhs will be just fine

00:28:51,120 --> 00:28:57,679
and then finally we have zero or more

00:28:54,399 --> 00:29:01,760
so this is a primitive here that says

00:28:57,679 --> 00:29:02,559
it will read zero or more values of type

00:29:01,760 --> 00:29:04,799
a

00:29:02,559 --> 00:29:06,240
okay so that way if the zero or more it

00:29:04,799 --> 00:29:08,799
takes in a parser of type a

00:29:06,240 --> 00:29:13,120
and returns a parser of a vector of a's

00:29:08,799 --> 00:29:14,720
by just reading as many a's as possible

00:29:13,120 --> 00:29:16,960
let's see how either would be

00:29:14,720 --> 00:29:18,720
implemented either here

00:29:16,960 --> 00:29:20,320
it takes in as i mentioned before a

00:29:18,720 --> 00:29:23,600
parser of type a and

00:29:20,320 --> 00:29:24,240
another parser of type a consumes

00:29:23,600 --> 00:29:26,399
nothing

00:29:24,240 --> 00:29:27,919
is only true if lhs consumes nothing

00:29:26,399 --> 00:29:29,840
because if lhs consumes nothing then

00:29:27,919 --> 00:29:31,840
it's just trivial it's always lhs

00:29:29,840 --> 00:29:33,279
and and that's the end of it now the

00:29:31,840 --> 00:29:35,360
start character here

00:29:33,279 --> 00:29:36,720
it will append the start characters from

00:29:35,360 --> 00:29:38,480
the left hand side

00:29:36,720 --> 00:29:39,760
to the start characters of the right

00:29:38,480 --> 00:29:41,440
hand side and that'll be the

00:29:39,760 --> 00:29:43,039
start characters that are valid for the

00:29:41,440 --> 00:29:44,320
either of the of the two different

00:29:43,039 --> 00:29:46,080
parsers

00:29:44,320 --> 00:29:47,600
now what about reader what happens with

00:29:46,080 --> 00:29:50,159
reader it reads

00:29:47,600 --> 00:29:50,880
one character from stood in it tries to

00:29:50,159 --> 00:29:53,600
see if

00:29:50,880 --> 00:29:54,880
that left hand side parser can support

00:29:53,600 --> 00:29:57,520
that character

00:29:54,880 --> 00:29:58,320
if it does then it just returns lefthand

00:29:57,520 --> 00:30:00,880
side.read

00:29:58,320 --> 00:30:01,360
otherwise it returns righthandside.read

00:30:00,880 --> 00:30:03,600
and then

00:30:01,360 --> 00:30:06,000
overall then we take this combined

00:30:03,600 --> 00:30:08,720
function and we return the result

00:30:06,000 --> 00:30:10,720
what about pure so here we need to be

00:30:08,720 --> 00:30:14,640
able to create a parser t

00:30:10,720 --> 00:30:17,360
out of a value t pure in this case

00:30:14,640 --> 00:30:18,399
would be a way for us to just say it

00:30:17,360 --> 00:30:20,880
always succeeds

00:30:18,399 --> 00:30:21,600
so consumes nothing is true and produces

00:30:20,880 --> 00:30:23,360
a value

00:30:21,600 --> 00:30:24,799
this particular value that you pass into

00:30:23,360 --> 00:30:26,799
the success p function

00:30:24,799 --> 00:30:28,880
no we didn't call this pure we called it

00:30:26,799 --> 00:30:30,640
success p going back to the idea that

00:30:28,880 --> 00:30:32,799
you want to make sure that you provide

00:30:30,640 --> 00:30:33,679
a vocabulary naming that makes sense for

00:30:32,799 --> 00:30:35,679
your domain

00:30:33,679 --> 00:30:37,120
even though you happen to be pure under

00:30:35,679 --> 00:30:40,320
the hood

00:30:37,120 --> 00:30:42,720
using these category theoretic concepts

00:30:40,320 --> 00:30:44,640
what about apply we know that this is an

00:30:42,720 --> 00:30:47,039
applicative functor so

00:30:44,640 --> 00:30:48,159
basically because i told you but how

00:30:47,039 --> 00:30:51,279
does apply

00:30:48,159 --> 00:30:53,840
work ply takes in a parser

00:30:51,279 --> 00:30:55,279
of a function right and it takes in a

00:30:53,840 --> 00:30:57,760
parser of a value

00:30:55,279 --> 00:30:59,279
applies the parser of the function uh

00:30:57,760 --> 00:31:01,120
the inside of that parser

00:30:59,279 --> 00:31:02,640
parse function to the inside of the

00:31:01,120 --> 00:31:04,159
parse value even though nothing's

00:31:02,640 --> 00:31:05,039
actually been parsed yet we can still

00:31:04,159 --> 00:31:08,159
compose

00:31:05,039 --> 00:31:10,559
these things together consumes nothing

00:31:08,159 --> 00:31:12,240
would only happen if the function parser

00:31:10,559 --> 00:31:13,200
consumes nothing and the t parser

00:31:12,240 --> 00:31:15,760
consumes nothing

00:31:13,200 --> 00:31:17,039
now let's say the function parser

00:31:15,760 --> 00:31:18,880
consumes nothing

00:31:17,039 --> 00:31:21,039
so the start character is going to be

00:31:18,880 --> 00:31:24,159
equal to the value parser

00:31:21,039 --> 00:31:25,600
start characters right otherwise

00:31:24,159 --> 00:31:27,600
it's the start values is gonna be the

00:31:25,600 --> 00:31:29,519
function parser start characters

00:31:27,600 --> 00:31:32,000
what about the reader method so what

00:31:29,519 --> 00:31:33,679
happens is we call the the function

00:31:32,000 --> 00:31:35,200
parser read to get that function and we

00:31:33,679 --> 00:31:36,799
call the value parser.read to get the

00:31:35,200 --> 00:31:39,120
value and return f of t

00:31:36,799 --> 00:31:40,640
and then finally we return the result

00:31:39,120 --> 00:31:42,559
okay pretty straightforward

00:31:40,640 --> 00:31:44,320
you may not know how we would use apply

00:31:42,559 --> 00:31:47,440
you may not know how you use pure

00:31:44,320 --> 00:31:49,039
but considering um let's see where this

00:31:47,440 --> 00:31:51,360
takes us considering it matches this

00:31:49,039 --> 00:31:54,480
type theoretic concept

00:31:51,360 --> 00:31:56,320
so it turns out that we're done

00:31:54,480 --> 00:31:57,600
that everything else that you would need

00:31:56,320 --> 00:32:00,799
out of this parser

00:31:57,600 --> 00:32:02,159
can be built on these pieces let's take

00:32:00,799 --> 00:32:03,919
a look at digit p

00:32:02,159 --> 00:32:05,200
so here we want to have a parser which

00:32:03,919 --> 00:32:06,799
parses a digit

00:32:05,200 --> 00:32:08,799
so first we create a lambda function

00:32:06,799 --> 00:32:11,440
which converts a character into

00:32:08,799 --> 00:32:12,000
an actual number no problem there and

00:32:11,440 --> 00:32:14,080
then

00:32:12,000 --> 00:32:15,200
we want to be able to parse in the

00:32:14,080 --> 00:32:18,399
individual characters

00:32:15,200 --> 00:32:19,279
so we have char p0 char p1 and so on and

00:32:18,399 --> 00:32:23,120
so forth all the way

00:32:19,279 --> 00:32:24,960
to char p9 all right we use either

00:32:23,120 --> 00:32:27,039
to be able to say that any of these

00:32:24,960 --> 00:32:29,440
individual parsers work

00:32:27,039 --> 00:32:31,360
and then we use apply to convert that

00:32:29,440 --> 00:32:33,519
parser so that either parts remember is

00:32:31,360 --> 00:32:36,960
going to return a parser of char

00:32:33,519 --> 00:32:38,880
we change that into a parser of end

00:32:36,960 --> 00:32:40,159
so we're just taking these fundamental

00:32:38,880 --> 00:32:41,600
pieces and applying them together and

00:32:40,159 --> 00:32:44,399
we're able to build out

00:32:41,600 --> 00:32:44,880
a digit parser now what if we want to

00:32:44,399 --> 00:32:48,559
have

00:32:44,880 --> 00:32:51,679
an int parser we can use zero or more

00:32:48,559 --> 00:32:53,440
digit parsers and so on and so forth

00:32:51,679 --> 00:32:55,039
there's even ways for you to be able to

00:32:53,440 --> 00:32:57,360
take two parsers and say

00:32:55,039 --> 00:32:59,360
hey this is a parser of a pair from a to

00:32:57,360 --> 00:33:01,679
b by given a getting a parser of a

00:32:59,360 --> 00:33:03,120
and a parser of b you can use apply for

00:33:01,679 --> 00:33:04,640
that and

00:33:03,120 --> 00:33:07,279
putting all this together if you want to

00:33:04,640 --> 00:33:08,880
have two inch separated by a space

00:33:07,279 --> 00:33:10,640
you can take that function that we just

00:33:08,880 --> 00:33:13,120
used and just make

00:33:10,640 --> 00:33:14,159
person int parse a space parse another

00:33:13,120 --> 00:33:16,320
int

00:33:14,159 --> 00:33:17,200
so are you starting to see how you can

00:33:16,320 --> 00:33:19,279
build these

00:33:17,200 --> 00:33:22,159
powerful powerful libraries by using

00:33:19,279 --> 00:33:25,679
these fundamental operations

00:33:22,159 --> 00:33:28,880
that's the idea let's review this

00:33:25,679 --> 00:33:29,200
monoids what are monoids good for these

00:33:28,880 --> 00:33:32,399
are

00:33:29,200 --> 00:33:34,640
highly parallel patterns in fact

00:33:32,399 --> 00:33:35,600
it's a generalized version of map reduce

00:33:34,640 --> 00:33:37,440
if you find

00:33:35,600 --> 00:33:39,440
that the the main you're working on

00:33:37,440 --> 00:33:41,440
happens to model amanoid

00:33:39,440 --> 00:33:43,200
then you know you can apply a map reduce

00:33:41,440 --> 00:33:47,120
kind of like a system

00:33:43,200 --> 00:33:49,679
to work this in extremely parallel terms

00:33:47,120 --> 00:33:51,360
what about functors functors you do

00:33:49,679 --> 00:33:53,279
things to the stuff inside

00:33:51,360 --> 00:33:54,720
and you can thread functors of functors

00:33:53,279 --> 00:33:55,200
of functors to get to the thing on the

00:33:54,720 --> 00:33:57,440
inside

00:33:55,200 --> 00:33:58,720
a very powerful abstraction and

00:33:57,440 --> 00:34:00,559
applicative functors

00:33:58,720 --> 00:34:03,039
this is a way for you to put stuff

00:34:00,559 --> 00:34:05,120
inside and the stuff inside can do

00:34:03,039 --> 00:34:08,639
things to the stuff on the inside

00:34:05,120 --> 00:34:12,960
in other words the apply function

00:34:08,639 --> 00:34:16,000
now we look at monads now a monad

00:34:12,960 --> 00:34:17,040
is an applicative functor with one extra

00:34:16,000 --> 00:34:21,280
operation

00:34:17,040 --> 00:34:23,119
called join so join takes in a monad of

00:34:21,280 --> 00:34:26,159
a monad of t

00:34:23,119 --> 00:34:28,720
and produces a monad of t

00:34:26,159 --> 00:34:30,079
and that's it a monad is simply an

00:34:28,720 --> 00:34:31,679
applicative functor with a joint

00:34:30,079 --> 00:34:34,639
operation

00:34:31,679 --> 00:34:36,960
now there are monad laws and it's a bit

00:34:34,639 --> 00:34:38,720
more complex to express these in c

00:34:36,960 --> 00:34:41,040
plus so i'm not going to throw them on

00:34:38,720 --> 00:34:44,639
the screen here but i will say

00:34:41,040 --> 00:34:45,280
please go to this link the category

00:34:44,639 --> 00:34:46,639
theory

00:34:45,280 --> 00:34:48,320
webpage there and you'll be able to

00:34:46,639 --> 00:34:50,879
understand how this works for haskell

00:34:48,320 --> 00:34:52,320
and you could intuit how these monad

00:34:50,879 --> 00:34:55,599
laws would apply for c

00:34:52,320 --> 00:34:58,480
plus now

00:34:55,599 --> 00:34:59,839
what would join look like for stood

00:34:58,480 --> 00:35:01,920
optional

00:34:59,839 --> 00:35:03,440
join remember it takes in the monad of a

00:35:01,920 --> 00:35:03,680
monon of t so in this case it would be

00:35:03,440 --> 00:35:06,720
an

00:35:03,680 --> 00:35:07,359
optional of an optional of t join what

00:35:06,720 --> 00:35:09,520
it will do is

00:35:07,359 --> 00:35:11,040
take an optional of an optional of t and

00:35:09,520 --> 00:35:14,160
build an optional of a t

00:35:11,040 --> 00:35:16,320
out of it the implementation is probably

00:35:14,160 --> 00:35:18,960
exactly what you would expect it to do

00:35:16,320 --> 00:35:18,960
pretty simple

00:35:20,960 --> 00:35:24,000
what about other monads there's stood

00:35:23,119 --> 00:35:26,320
vector

00:35:24,000 --> 00:35:27,040
there's a parser monad now the the

00:35:26,320 --> 00:35:28,880
parser

00:35:27,040 --> 00:35:30,400
applicative functor that we made before

00:35:28,880 --> 00:35:32,880
is different than the parser

00:35:30,400 --> 00:35:34,000
monad our parser doesn't have the

00:35:32,880 --> 00:35:35,920
ability as a

00:35:34,000 --> 00:35:40,000
model as an applicative functor to be

00:35:35,920 --> 00:35:43,440
able to start with a parser

00:35:40,000 --> 00:35:44,000
parse a parser and then apply the parsed

00:35:43,440 --> 00:35:47,520
parser

00:35:44,000 --> 00:35:49,119
to the input right so imagine uh

00:35:47,520 --> 00:35:50,640
you know a parser where the first thing

00:35:49,119 --> 00:35:51,359
it does is it parses the language for

00:35:50,640 --> 00:35:53,760
the rest

00:35:51,359 --> 00:35:55,280
uh the parses the parser that's supposed

00:35:53,760 --> 00:35:56,160
to apply to the rest of the language of

00:35:55,280 --> 00:35:57,680
the input

00:35:56,160 --> 00:35:59,599
applicative functor parsers can't do

00:35:57,680 --> 00:36:01,920
that but monad parses are so that gives

00:35:59,599 --> 00:36:03,599
you that extra power

00:36:01,920 --> 00:36:06,079
functions with a single parameter of

00:36:03,599 --> 00:36:09,119
type a actually are also

00:36:06,079 --> 00:36:12,240
model a monad so

00:36:09,119 --> 00:36:14,320
what's the big deal who cares

00:36:12,240 --> 00:36:16,800
about monads it just seems like it adds

00:36:14,320 --> 00:36:19,520
one thing to applicative functors

00:36:16,800 --> 00:36:20,880
well this bind operation so i talked

00:36:19,520 --> 00:36:22,320
about it way back at the beginning don't

00:36:20,880 --> 00:36:22,960
expose your thing and call it monadic

00:36:22,320 --> 00:36:25,119
bind

00:36:22,960 --> 00:36:26,400
well the monadic bind operation is

00:36:25,119 --> 00:36:29,599
defined in terms

00:36:26,400 --> 00:36:30,560
of other operations so for a given monad

00:36:29,599 --> 00:36:33,119
of t

00:36:30,560 --> 00:36:33,839
in order to be able to construct a bind

00:36:33,119 --> 00:36:37,440
you use

00:36:33,839 --> 00:36:39,359
pure apply and join

00:36:37,440 --> 00:36:40,640
usually for bind you want it to be an

00:36:39,359 --> 00:36:44,079
operator overload

00:36:40,640 --> 00:36:46,880
let's use the right shift operator

00:36:44,079 --> 00:36:48,000
here we have an optional of int getint

00:36:46,880 --> 00:36:50,960
function

00:36:48,000 --> 00:36:52,160
and here we use the magnetic bind to be

00:36:50,960 --> 00:36:55,200
able to start with

00:36:52,160 --> 00:36:57,119
getint you have some kind of syntax

00:36:55,200 --> 00:36:58,720
gent you have some kind of other syntax

00:36:57,119 --> 00:37:00,320
get in you have another kind of syntax

00:36:58,720 --> 00:37:03,520
and you call pure of a plus b

00:37:00,320 --> 00:37:05,280
plus c if you indent this a little bit

00:37:03,520 --> 00:37:09,920
differently

00:37:05,280 --> 00:37:13,040
it looks like this now if you squint

00:37:09,920 --> 00:37:16,480
you might see something like this

00:37:13,040 --> 00:37:17,839
which if you cross your eyes looks like

00:37:16,480 --> 00:37:21,040
this

00:37:17,839 --> 00:37:24,160
in other words this looks a lot like

00:37:21,040 --> 00:37:26,160
imperative computation and that was the

00:37:24,160 --> 00:37:27,599
original reason why monads got so

00:37:26,160 --> 00:37:29,599
popular in the first place

00:37:27,599 --> 00:37:30,800
is because it looks like imperative

00:37:29,599 --> 00:37:33,839
computations

00:37:30,800 --> 00:37:37,200
and that was a really big deal

00:37:33,839 --> 00:37:40,240
for haskell but what about us

00:37:37,200 --> 00:37:42,079
does it do anything for us in c plus

00:37:40,240 --> 00:37:44,720
well what monads allow you to do is

00:37:42,079 --> 00:37:45,599
express different models of computation

00:37:44,720 --> 00:37:48,400
within c

00:37:45,599 --> 00:37:49,839
plus stood vector gives a language with

00:37:48,400 --> 00:37:52,400
non-determination

00:37:49,839 --> 00:37:53,440
non-determinism stood optional provides

00:37:52,400 --> 00:37:55,599
a language

00:37:53,440 --> 00:37:58,160
with error fall through there are

00:37:55,599 --> 00:37:59,920
continuation languages

00:37:58,160 --> 00:38:01,599
it also allows you to provide more

00:37:59,920 --> 00:38:03,280
control over computation

00:38:01,599 --> 00:38:05,200
you could take a computation which is

00:38:03,280 --> 00:38:07,359
expressed in monad form

00:38:05,200 --> 00:38:09,200
and serialize the composite computation

00:38:07,359 --> 00:38:10,160
itself and then deserialize it and use

00:38:09,200 --> 00:38:12,640
it

00:38:10,160 --> 00:38:14,160
you can have a command pattern embedded

00:38:12,640 --> 00:38:17,280
language

00:38:14,160 --> 00:38:21,119
it is also extremely interesting for

00:38:17,280 --> 00:38:24,640
imperative template meta programming

00:38:21,119 --> 00:38:25,280
so let's wrap this up the first thing to

00:38:24,640 --> 00:38:27,760
note as

00:38:25,280 --> 00:38:29,359
this is just the beginning there are

00:38:27,760 --> 00:38:33,520
more interesting patterns

00:38:29,359 --> 00:38:37,040
semi group category arrow common ad

00:38:33,520 --> 00:38:38,560
all of these can be used to enhance your

00:38:37,040 --> 00:38:41,920
design skills

00:38:38,560 --> 00:38:42,320
now um i will probably do a subsequent

00:38:41,920 --> 00:38:43,920
talk

00:38:42,320 --> 00:38:45,599
at one of these conferences at some

00:38:43,920 --> 00:38:47,920
point to talk about

00:38:45,599 --> 00:38:49,440
more examples of these things but here

00:38:47,920 --> 00:38:51,920
is your base knowledge

00:38:49,440 --> 00:38:53,599
your base knowledge of very common

00:38:51,920 --> 00:38:55,839
repeated software patterns

00:38:53,599 --> 00:38:56,880
in functional design now that we've

00:38:55,839 --> 00:39:01,440
finished

00:38:56,880 --> 00:39:04,720
let's go and take some questions

00:39:01,440 --> 00:39:06,720
cool thank you uh glad you guys liked it

00:39:04,720 --> 00:39:09,680
let me uh go to some of the these

00:39:06,720 --> 00:39:11,920
questions here in the qa section

00:39:09,680 --> 00:39:13,440
what did you bribe those kids with to

00:39:11,920 --> 00:39:15,599
put up with this

00:39:13,440 --> 00:39:16,720
um they were good sports you know they

00:39:15,599 --> 00:39:18,880
were they were happy to

00:39:16,720 --> 00:39:20,640
to join in the kids are a lot of fun you

00:39:18,880 --> 00:39:22,800
know if you if you search for

00:39:20,640 --> 00:39:24,079
cinco family band on youtube you'll be

00:39:22,800 --> 00:39:25,520
able to see the kids in action like

00:39:24,079 --> 00:39:27,119
actually playing music like we

00:39:25,520 --> 00:39:30,000
we've made some youtube videos before as

00:39:27,119 --> 00:39:31,680
a family and it was a lot of fun

00:39:30,000 --> 00:39:34,320
so yeah they were they were totally good

00:39:31,680 --> 00:39:34,320
supports with this

00:39:34,400 --> 00:39:40,160
uh next question is what is your

00:39:38,000 --> 00:39:42,320
presentation set up in brief

00:39:40,160 --> 00:39:43,440
okay so i basically had a cell phone on

00:39:42,320 --> 00:39:45,280
a tripod

00:39:43,440 --> 00:39:46,560
and i saw someone mention like oh it's a

00:39:45,280 --> 00:39:48,000
green screen i actually i wish i had a

00:39:46,560 --> 00:39:49,599
green screen it was just the

00:39:48,000 --> 00:39:51,200
the ugly color of my wall that was

00:39:49,599 --> 00:39:52,560
behind me um

00:39:51,200 --> 00:39:54,480
and then i recorded that and then i

00:39:52,560 --> 00:39:55,599
recorded with the kids uh in a different

00:39:54,480 --> 00:39:57,920
room actually

00:39:55,599 --> 00:39:59,280
uh and then we put it all together with

00:39:57,920 --> 00:40:00,640
adobe premiere and just

00:39:59,280 --> 00:40:02,960
you know added all the text effects and

00:40:00,640 --> 00:40:04,079
things like that um it was slow at the

00:40:02,960 --> 00:40:06,400
beginning but by the end

00:40:04,079 --> 00:40:08,800
i got pretty fast with it it was uh it

00:40:06,400 --> 00:40:12,240
was neat it was a good experience

00:40:08,800 --> 00:40:13,760
um next comment is uh from victor is we

00:40:12,240 --> 00:40:16,319
want to see the blooper reel

00:40:13,760 --> 00:40:18,000
um that that would be hilarious there

00:40:16,319 --> 00:40:18,640
there are some pretty funny things uh at

00:40:18,000 --> 00:40:20,240
some point

00:40:18,640 --> 00:40:22,079
maybe i'll put this together and throw

00:40:20,240 --> 00:40:22,720
on the youtube uh the blooper reel it

00:40:22,079 --> 00:40:24,240
was

00:40:22,720 --> 00:40:25,280
like interruptions so you saw all my

00:40:24,240 --> 00:40:26,480
kids there except there was like the

00:40:25,280 --> 00:40:28,560
smallest kid

00:40:26,480 --> 00:40:30,240
um we did not invite into that part of

00:40:28,560 --> 00:40:31,280
it but he invited himself a couple times

00:40:30,240 --> 00:40:34,720
so that would be

00:40:31,280 --> 00:40:38,160
pretty funny okay

00:40:34,720 --> 00:40:41,520
um what is the difference between oh

00:40:38,160 --> 00:40:44,560
that one disappeared is it possible

00:40:41,520 --> 00:40:45,520
to create c plus plus 20 concepts for

00:40:44,560 --> 00:40:49,440
monad

00:40:45,520 --> 00:40:52,640
mynoid etc um

00:40:49,440 --> 00:40:55,200
for sure you'd be able to uh

00:40:52,640 --> 00:40:55,839
to create one for monoid in terms of

00:40:55,200 --> 00:40:57,760
monad

00:40:55,839 --> 00:41:00,319
i'm not sure that concepts are powerful

00:40:57,760 --> 00:41:01,599
enough to express that they may be

00:41:00,319 --> 00:41:03,599
so i haven't thought deeply about it

00:41:01,599 --> 00:41:05,200
it's a good question but it kind of

00:41:03,599 --> 00:41:08,800
boils down to

00:41:05,200 --> 00:41:11,280
um you know what do you

00:41:08,800 --> 00:41:11,839
really want to expose these as as they

00:41:11,280 --> 00:41:14,560
are

00:41:11,839 --> 00:41:15,680
to your user so from like a software

00:41:14,560 --> 00:41:17,440
engineering standpoint if you have a

00:41:15,680 --> 00:41:18,880
bunch of users for your software you

00:41:17,440 --> 00:41:20,640
it's probably not going to be useful for

00:41:18,880 --> 00:41:22,560
them that they have a unified way to

00:41:20,640 --> 00:41:23,680
talk about monetic binds

00:41:22,560 --> 00:41:25,599
but if you're experimenting you're

00:41:23,680 --> 00:41:26,160
having fun and you're you know your

00:41:25,599 --> 00:41:28,000
folks

00:41:26,160 --> 00:41:29,119
that you're working with have a lot of

00:41:28,000 --> 00:41:30,400
experience with this these kinds of

00:41:29,119 --> 00:41:31,359
concepts and it might be useful then

00:41:30,400 --> 00:41:33,280
they can just say hey

00:41:31,359 --> 00:41:34,560
we'll use emmapenned if you want to like

00:41:33,280 --> 00:41:36,319
squash the

00:41:34,560 --> 00:41:38,880
the vector or any kind of container of

00:41:36,319 --> 00:41:38,880
monoids

00:41:38,960 --> 00:41:44,800
uh next question let's see

00:41:42,720 --> 00:41:46,880
how bad do the diagnostics and stack

00:41:44,800 --> 00:41:47,520
traces get when debugging these patterns

00:41:46,880 --> 00:41:52,000
expressed

00:41:47,520 --> 00:41:52,000
in c plus plus um

00:41:52,319 --> 00:41:56,240
so i i think that it's similar to any

00:41:55,359 --> 00:41:59,680
kind of

00:41:56,240 --> 00:42:01,040
uh meta programming uh like kind of

00:41:59,680 --> 00:42:03,839
design that you're gonna do

00:42:01,040 --> 00:42:05,200
if you if you just do a kind of default

00:42:03,839 --> 00:42:06,480
setup and you don't actually think about

00:42:05,200 --> 00:42:08,160
diagnostics then you're going to get

00:42:06,480 --> 00:42:08,880
like just incomprehensible error

00:42:08,160 --> 00:42:11,599
messages

00:42:08,880 --> 00:42:12,640
but you can go in and make sure that you

00:42:11,599 --> 00:42:16,079
get the kind of

00:42:12,640 --> 00:42:17,520
um like errors that you want to have

00:42:16,079 --> 00:42:18,880
you know like we'll give like little

00:42:17,520 --> 00:42:20,400
helpful hints to the user as to what

00:42:18,880 --> 00:42:22,240
could possibly be going wrong

00:42:20,400 --> 00:42:23,680
so that's just that's more of just

00:42:22,240 --> 00:42:24,240
template meta programming kind of kind

00:42:23,680 --> 00:42:25,520
of design

00:42:24,240 --> 00:42:27,280
as a way to kind of like improve error

00:42:25,520 --> 00:42:28,640
messages so it's not different than any

00:42:27,280 --> 00:42:32,640
other kind of complex

00:42:28,640 --> 00:42:32,640
uh template kind of shenanigans you do

00:42:33,280 --> 00:42:40,640
okay um let's see next question here

00:42:38,400 --> 00:42:41,839
many people bounce off of haskell

00:42:40,640 --> 00:42:43,520
category theory do you have a

00:42:41,839 --> 00:42:46,640
recommendation for people who want to

00:42:43,520 --> 00:42:49,680
learn it but bounce off

00:42:46,640 --> 00:42:52,720
hmm i'm not sure what is meant by

00:42:49,680 --> 00:42:52,720
bounce off

00:42:55,359 --> 00:42:59,119
so i'm not really sure how to answer

00:42:56,640 --> 00:43:01,359
that question

00:42:59,119 --> 00:43:02,240
maybe conor if you can state it in a

00:43:01,359 --> 00:43:03,599
different way or

00:43:02,240 --> 00:43:05,440
clarify what you mean by bounce off then

00:43:03,599 --> 00:43:07,760
we can i'll give that one another

00:43:05,440 --> 00:43:07,760
attempt

00:43:11,040 --> 00:43:17,599
let's see the next question is

00:43:15,280 --> 00:43:19,359
oh questions are kind of coming in and

00:43:17,599 --> 00:43:22,640
just missing up here

00:43:19,359 --> 00:43:23,440
do you think that the lack of custom

00:43:22,640 --> 00:43:25,520
syntax and c

00:43:23,440 --> 00:43:29,680
plus for building monadic expression can

00:43:25,520 --> 00:43:29,680
make the use of monads too impractical

00:43:29,760 --> 00:43:33,680
excuse me um i i think that

00:43:33,920 --> 00:43:38,160
it does hurt in a lot of respects

00:43:36,960 --> 00:43:40,000
if you want to be able to express

00:43:38,160 --> 00:43:41,520
something in monotonic form it'd be

00:43:40,000 --> 00:43:43,040
really nice to have do notation which is

00:43:41,520 --> 00:43:44,319
like in haskell you have a special

00:43:43,040 --> 00:43:47,119
notation that you can use

00:43:44,319 --> 00:43:48,720
for um what added computations in terms

00:43:47,119 --> 00:43:51,599
of whether or not

00:43:48,720 --> 00:43:52,720
there is a strong enough use case uh for

00:43:51,599 --> 00:43:54,319
monads in c

00:43:52,720 --> 00:43:56,079
plus so we'd want to add that to the

00:43:54,319 --> 00:44:00,000
language um

00:43:56,079 --> 00:44:01,760
i don't know just yet um

00:44:00,000 --> 00:44:03,119
you can get away with quite a bit with

00:44:01,760 --> 00:44:05,599
just function syntax

00:44:03,119 --> 00:44:07,200
uh like uh making an embed better domain

00:44:05,599 --> 00:44:07,599
specific language kind of like as we saw

00:44:07,200 --> 00:44:11,920
with

00:44:07,599 --> 00:44:11,920
the applicative functor parser library

00:44:18,960 --> 00:44:22,079
i see what is the difference between a

00:44:20,240 --> 00:44:23,920
monoid and a group and then

00:44:22,079 --> 00:44:26,319
a seems like an answer below it a group

00:44:23,920 --> 00:44:28,640
has an inverse for each element

00:44:26,319 --> 00:44:28,640
um

00:44:30,240 --> 00:44:33,920
the next question is i feel like i

00:44:32,319 --> 00:44:36,319
struggle with the terminology of

00:44:33,920 --> 00:44:38,160
monoids monads etc yet understand some

00:44:36,319 --> 00:44:39,680
of the concepts intuitively

00:44:38,160 --> 00:44:41,359
how would you recommend i go about

00:44:39,680 --> 00:44:45,440
deepening my understanding of these

00:44:41,359 --> 00:44:47,280
concepts uh i think that the

00:44:45,440 --> 00:44:49,200
what really helped me a lot was to

00:44:47,280 --> 00:44:51,200
actually try to implement stuff

00:44:49,200 --> 00:44:52,880
you know take stood optional or

00:44:51,200 --> 00:44:54,560
something along these lines and

00:44:52,880 --> 00:44:56,319
just try to implement all the different

00:44:54,560 --> 00:44:57,119
operations for it and then take like a

00:44:56,319 --> 00:44:58,400
stood function

00:44:57,119 --> 00:45:00,480
and implement all the different

00:44:58,400 --> 00:45:02,240
operations for that and if you just do

00:45:00,480 --> 00:45:04,400
this over and over and over again

00:45:02,240 --> 00:45:06,400
you start to build the intuition monads

00:45:04,400 --> 00:45:08,240
in particular are like a very difficult

00:45:06,400 --> 00:45:09,040
thing for folks to internalize in their

00:45:08,240 --> 00:45:13,040
heads

00:45:09,040 --> 00:45:14,960
and um and and like one of the

00:45:13,040 --> 00:45:17,119
common memes among haskell people is

00:45:14,960 --> 00:45:19,040
that you learn

00:45:17,119 --> 00:45:20,560
moan ads and then it just becomes simple

00:45:19,040 --> 00:45:21,920
and you just like understand it and then

00:45:20,560 --> 00:45:24,640
you want to tell everybody about it like

00:45:21,920 --> 00:45:25,760
monads are so simple and you explain it

00:45:24,640 --> 00:45:27,760
and you're it's like you're speaking

00:45:25,760 --> 00:45:29,680
martian to people because there seems to

00:45:27,760 --> 00:45:31,040
be no way to get to that end state to

00:45:29,680 --> 00:45:32,960
where you understand it without going

00:45:31,040 --> 00:45:34,319
through this journey of

00:45:32,960 --> 00:45:35,760
messing around with it and learning it

00:45:34,319 --> 00:45:36,079
and working it over and over in your

00:45:35,760 --> 00:45:41,680
head

00:45:36,079 --> 00:45:45,599
until it finally clicks a good question

00:45:41,680 --> 00:45:47,760
let's see oh the clarification on

00:45:45,599 --> 00:45:49,359
bounce off bounce off find it too

00:45:47,760 --> 00:45:50,800
difficult to learn or find it unfamiliar

00:45:49,359 --> 00:45:52,880
aka many people give up on learning

00:45:50,800 --> 00:45:55,520
haskell in their first few attempts

00:45:52,880 --> 00:45:56,400
yeah you know that that's just that's

00:45:55,520 --> 00:45:59,680
true about

00:45:56,400 --> 00:46:00,000
any endeavor that's worth doing right if

00:45:59,680 --> 00:46:01,280
it was

00:46:00,000 --> 00:46:03,200
easy everybody would have done it

00:46:01,280 --> 00:46:05,920
already um

00:46:03,200 --> 00:46:06,560
but it is something that you have to

00:46:05,920 --> 00:46:07,920
master

00:46:06,560 --> 00:46:10,880
in order to be able to work with it

00:46:07,920 --> 00:46:11,440
there's no um royal road to math as they

00:46:10,880 --> 00:46:12,800
say

00:46:11,440 --> 00:46:15,200
and the same is true for some of this

00:46:12,800 --> 00:46:18,720
category category theory is

00:46:15,200 --> 00:46:20,400
advanced math um but we do have a road

00:46:18,720 --> 00:46:21,680
may not be a royal road by

00:46:20,400 --> 00:46:23,040
trying to implement these things in c

00:46:21,680 --> 00:46:25,920
plus plus and be able to build our

00:46:23,040 --> 00:46:25,920
understanding about it

00:46:26,000 --> 00:46:29,839
um let's see

00:46:31,920 --> 00:46:34,960
if you could magically extend the c plus

00:46:33,760 --> 00:46:36,319
plus standard to better support

00:46:34,960 --> 00:46:39,520
functional programming

00:46:36,319 --> 00:46:41,040
what would i add well

00:46:39,520 --> 00:46:42,960
that would definitely have to be pattern

00:46:41,040 --> 00:46:44,960
matching right so

00:46:42,960 --> 00:46:46,240
pattern matching which is not related to

00:46:44,960 --> 00:46:48,880
category theoretic

00:46:46,240 --> 00:46:50,880
concepts is just a simple way for you to

00:46:48,880 --> 00:46:52,240
make use of algebraic data types like

00:46:50,880 --> 00:46:53,359
variant

00:46:52,240 --> 00:46:55,119
but variant right now is kind of

00:46:53,359 --> 00:46:56,400
cumbersome to use especially when you

00:46:55,119 --> 00:46:58,880
compare it to some of the functional

00:46:56,400 --> 00:47:00,720
programming languages um so having

00:46:58,880 --> 00:47:02,960
pattern matching ad in the language and

00:47:00,720 --> 00:47:04,640
also first class support for variants

00:47:02,960 --> 00:47:06,240
would definitely be high on my list and

00:47:04,640 --> 00:47:07,359
are high on my list and you can see my

00:47:06,240 --> 00:47:08,720
papers

00:47:07,359 --> 00:47:10,480
that i've submitted to iso on that

00:47:08,720 --> 00:47:12,400
behalf and the pattern matching

00:47:10,480 --> 00:47:14,079
one it it is something we are trying

00:47:12,400 --> 00:47:16,640
very very hard to target

00:47:14,079 --> 00:47:17,760
for uh c plus plus 23 and i'm just a

00:47:16,640 --> 00:47:19,040
co-author on that there are several

00:47:17,760 --> 00:47:22,720
authors on that paper

00:47:19,040 --> 00:47:24,800
um so uh yeah the pattern matching would

00:47:22,720 --> 00:47:25,599
be up there because that is useful right

00:47:24,800 --> 00:47:27,839
away

00:47:25,599 --> 00:47:31,839
by everyday programmers and it would be

00:47:27,839 --> 00:47:31,839
in every single cpp file if it were used

00:47:34,960 --> 00:47:39,839
what is an example that's not a functor

00:47:40,640 --> 00:47:45,920
so like an ants would not be a functor

00:47:44,720 --> 00:47:47,190
something that doesn't have a map

00:47:45,920 --> 00:47:48,480
operation

00:47:47,190 --> 00:47:51,119
[Music]

00:47:48,480 --> 00:47:52,319
anything that might you know the key

00:47:51,119 --> 00:47:54,559
thing about a functor is that if you

00:47:52,319 --> 00:47:57,599
pass in the identity function

00:47:54,559 --> 00:48:00,800
that you you can't mess up

00:47:57,599 --> 00:48:02,400
uh your object uh or change it so any

00:48:00,800 --> 00:48:02,960
kind of map operation which doesn't do

00:48:02,400 --> 00:48:06,319
that

00:48:02,960 --> 00:48:07,920
wouldn't wouldn't have that property

00:48:06,319 --> 00:48:09,839
it's hard to come up with with a juicy

00:48:07,920 --> 00:48:10,800
example where it's like oh you think

00:48:09,839 --> 00:48:12,160
this would be a functor but it's

00:48:10,800 --> 00:48:13,200
actually not you know functors are very

00:48:12,160 --> 00:48:14,960
very common

00:48:13,200 --> 00:48:16,319
um and it's and it's kind of hard to

00:48:14,960 --> 00:48:17,359
make something which you can apply a

00:48:16,319 --> 00:48:21,200
function to

00:48:17,359 --> 00:48:24,319
uh that wouldn't be a function functor

00:48:21,200 --> 00:48:24,319
but you can come up with something

00:48:26,240 --> 00:48:29,280
do you think that someone could use

00:48:27,920 --> 00:48:30,880
these tools using template meta

00:48:29,280 --> 00:48:32,839
programming implement map pure join

00:48:30,880 --> 00:48:34,640
apply in order to use it more

00:48:32,839 --> 00:48:36,960
efficiently

00:48:34,640 --> 00:48:38,480
someone could definitely use these tools

00:48:36,960 --> 00:48:41,040
with template meta programming as a

00:48:38,480 --> 00:48:41,040
means to

00:48:42,000 --> 00:48:47,200
make template meta programming feel less

00:48:45,040 --> 00:48:48,400
functional in nature right now a lot of

00:48:47,200 --> 00:48:49,200
the template meta programming tools

00:48:48,400 --> 00:48:51,359
they're not

00:48:49,200 --> 00:48:52,319
really imperative much it feels more

00:48:51,359 --> 00:48:53,359
like you're writing in a purely

00:48:52,319 --> 00:48:55,520
functional language

00:48:53,359 --> 00:48:56,880
so monads in particular would allow you

00:48:55,520 --> 00:48:58,640
to make a

00:48:56,880 --> 00:48:59,839
embedded domain specific language for

00:48:58,640 --> 00:49:01,359
template meta programming that feels

00:48:59,839 --> 00:49:02,559
more like comparative programming

00:49:01,359 --> 00:49:04,800
of course it's not going to feel as

00:49:02,559 --> 00:49:06,240
great as like first class

00:49:04,800 --> 00:49:08,079
imperative template meta programming

00:49:06,240 --> 00:49:08,960
which is something that we're

00:49:08,079 --> 00:49:10,880
we're trying to do in the

00:49:08,960 --> 00:49:12,640
standardization process to make template

00:49:10,880 --> 00:49:13,839
meta programming easier but but it can

00:49:12,640 --> 00:49:16,240
you know in the meantime

00:49:13,839 --> 00:49:17,680
provide a means to make it more

00:49:16,240 --> 00:49:20,079
imperative feel to your template model

00:49:17,680 --> 00:49:20,079
programs

00:49:22,079 --> 00:49:26,880
okay next question is how do you walk

00:49:24,640 --> 00:49:28,319
the line of exposing too many members

00:49:26,880 --> 00:49:30,079
that are in terms of the most essential

00:49:28,319 --> 00:49:32,319
ones and being too obscure

00:49:30,079 --> 00:49:34,240
in your interface locking inexperienced

00:49:32,319 --> 00:49:36,400
programmers out of using it

00:49:34,240 --> 00:49:37,440
so that uh that's a really good question

00:49:36,400 --> 00:49:40,160
and

00:49:37,440 --> 00:49:42,000
and that is uh an art form right there's

00:49:40,160 --> 00:49:42,720
no like mathematical answer to that so

00:49:42,000 --> 00:49:45,040
when

00:49:42,720 --> 00:49:46,559
when one way of designing interfaces is

00:49:45,040 --> 00:49:50,000
you put in your public interface

00:49:46,559 --> 00:49:51,599
only the minimal set of extremely

00:49:50,000 --> 00:49:53,040
powerful generic members

00:49:51,599 --> 00:49:55,040
and then put everything else as a free

00:49:53,040 --> 00:49:55,760
function or in a different file as a

00:49:55,040 --> 00:49:58,079
utility

00:49:55,760 --> 00:49:58,800
all right so that's one way of doing it

00:49:58,079 --> 00:50:00,400
um

00:49:58,800 --> 00:50:02,319
but it's not the most user-friendly way

00:50:00,400 --> 00:50:03,760
of doing it what the what a user wants

00:50:02,319 --> 00:50:06,720
to see right away

00:50:03,760 --> 00:50:08,400
is are the most common operations so

00:50:06,720 --> 00:50:10,000
whatever is going to be most common

00:50:08,400 --> 00:50:12,079
depending on how you expect your users

00:50:10,000 --> 00:50:14,800
to actually use your library

00:50:12,079 --> 00:50:16,319
uh in my opinion i i like interfaces

00:50:14,800 --> 00:50:17,839
that expose those like front and center

00:50:16,319 --> 00:50:19,680
so elevate it to the

00:50:17,839 --> 00:50:20,640
to the level of a member function just

00:50:19,680 --> 00:50:21,680
because that's where they're going to go

00:50:20,640 --> 00:50:24,960
looking for it

00:50:21,680 --> 00:50:26,880
um but yeah i i

00:50:24,960 --> 00:50:28,800
you have to look at each individual case

00:50:26,880 --> 00:50:30,400
and uh and get it

00:50:28,800 --> 00:50:31,920
looked at by many different people many

00:50:30,400 --> 00:50:33,359
different stakeholders especially people

00:50:31,920 --> 00:50:34,800
who are not the author

00:50:33,359 --> 00:50:36,240
and get that feedback and incorporate

00:50:34,800 --> 00:50:37,280
that into this design in order to come

00:50:36,240 --> 00:50:41,119
up with a design that's going to be

00:50:37,280 --> 00:50:44,720
palatable and extremely popular

00:50:41,119 --> 00:50:44,720
okay uh next question

00:50:45,359 --> 00:50:50,880
what would you say is a canonical first

00:50:47,520 --> 00:50:50,880
example for comon ads

00:50:52,839 --> 00:50:57,760
um

00:50:55,440 --> 00:50:58,880
i can't really think of what would be a

00:50:57,760 --> 00:51:01,119
good canonical

00:50:58,880 --> 00:51:02,079
first example of colemon ads off the top

00:51:01,119 --> 00:51:05,280
of my head

00:51:02,079 --> 00:51:06,800
um but you know for a future talk

00:51:05,280 --> 00:51:07,760
when i you know take a look at that

00:51:06,800 --> 00:51:09,040
crack it open and look at all the

00:51:07,760 --> 00:51:10,160
different examples for coal miners and

00:51:09,040 --> 00:51:11,200
try to think of one that would be a good

00:51:10,160 --> 00:51:14,640
introductory case

00:51:11,200 --> 00:51:17,680
um uh i can try doing that yeah the

00:51:14,640 --> 00:51:19,280
homeowner ads are a bit more obscure

00:51:17,680 --> 00:51:20,640
uh in their functionality than even

00:51:19,280 --> 00:51:21,440
monad so you have to build it up a

00:51:20,640 --> 00:51:23,280
little bit but

00:51:21,440 --> 00:51:25,040
it would be a challenge to find a good

00:51:23,280 --> 00:51:27,440
first example

00:51:25,040 --> 00:51:27,440
for sure

00:51:28,640 --> 00:51:33,119
i'm still a bit confused on how monads

00:51:31,040 --> 00:51:34,880
are still considered purity

00:51:33,119 --> 00:51:36,960
is it because the fact we're hiding the

00:51:34,880 --> 00:51:38,960
impure parts behind the monad type

00:51:36,960 --> 00:51:41,359
i'm specifically talking about monads

00:51:38,960 --> 00:51:45,440
like io or parser

00:51:41,359 --> 00:51:47,119
uh good question so

00:51:45,440 --> 00:51:50,319
the the reason that monads can be

00:51:47,119 --> 00:51:53,040
considered in a certain sense pure

00:51:50,319 --> 00:51:55,040
is that the way that you think about

00:51:53,040 --> 00:51:58,240
them like like in haskell for example

00:51:55,040 --> 00:52:00,400
is a an io monad

00:51:58,240 --> 00:52:02,480
is like a piece of com a computation

00:52:00,400 --> 00:52:04,880
that is a primitive thing

00:52:02,480 --> 00:52:06,800
and that we're just saying is like some

00:52:04,880 --> 00:52:08,240
other universe

00:52:06,800 --> 00:52:09,599
connecting these different pieces

00:52:08,240 --> 00:52:09,920
together you know like being able to say

00:52:09,599 --> 00:52:11,760
hey

00:52:09,920 --> 00:52:13,200
read an int and then read another and

00:52:11,760 --> 00:52:13,839
then put them together and read the

00:52:13,200 --> 00:52:15,520
result

00:52:13,839 --> 00:52:17,280
all the computation which combines

00:52:15,520 --> 00:52:18,319
monads which you can kind of think of it

00:52:17,280 --> 00:52:19,680
as kind of like overloading the

00:52:18,319 --> 00:52:22,880
semicolon operator

00:52:19,680 --> 00:52:25,119
um that part is pure functions right so

00:52:22,880 --> 00:52:28,400
you're composing these impure things

00:52:25,119 --> 00:52:30,839
in a pure way and uh and that's why

00:52:28,400 --> 00:52:33,839
monads are considered uh in that sense

00:52:30,839 --> 00:52:33,839
pure

00:52:34,400 --> 00:52:37,760
uh would it be difficult to get this

00:52:36,160 --> 00:52:39,280
sort of parser efficient enough to

00:52:37,760 --> 00:52:42,079
compete in runtime

00:52:39,280 --> 00:52:42,800
performance with procedural equivalence

00:52:42,079 --> 00:52:46,000
uh

00:52:42,800 --> 00:52:46,880
no it would not especially the uh

00:52:46,000 --> 00:52:50,000
applicative

00:52:46,880 --> 00:52:54,319
uh version of the parser to where you

00:52:50,000 --> 00:52:56,240
every parser is associated with the uh

00:52:54,319 --> 00:52:58,720
uh with the initial character that it

00:52:56,240 --> 00:53:00,240
can read that actually makes it very

00:52:58,720 --> 00:53:02,079
efficient that either operation for

00:53:00,240 --> 00:53:03,200
example when it gets to

00:53:02,079 --> 00:53:04,240
when you're actually parsing something

00:53:03,200 --> 00:53:05,520
and it gets to that it's just basically

00:53:04,240 --> 00:53:06,319
a switch over a bunch of different

00:53:05,520 --> 00:53:07,599
statements there

00:53:06,319 --> 00:53:10,319
now there are things that you can do to

00:53:07,599 --> 00:53:12,559
make it even more efficient and

00:53:10,319 --> 00:53:14,640
complicate the code a little bit more

00:53:12,559 --> 00:53:17,520
but there are definitely some

00:53:14,640 --> 00:53:18,720
high performance uh parsers uh that have

00:53:17,520 --> 00:53:20,880
been built in this way

00:53:18,720 --> 00:53:24,319
um that are competitive with uh things

00:53:20,880 --> 00:53:24,319
done in other ways for sure

00:53:26,240 --> 00:53:30,319
all right bartosz uh started down this

00:53:29,680 --> 00:53:32,559
path in c

00:53:30,319 --> 00:53:34,240
plus plus but soon ran out of steam and

00:53:32,559 --> 00:53:35,760
switched to haskell for good

00:53:34,240 --> 00:53:37,760
do you think these concepts are too

00:53:35,760 --> 00:53:40,640
unnatural for

00:53:37,760 --> 00:53:42,079
uh a language as c plus plus e g two for

00:53:40,640 --> 00:53:45,760
both of a syntax

00:53:42,079 --> 00:53:49,440
so i can't speak for bartosz

00:53:45,760 --> 00:53:51,839
but one of the things that's extremely

00:53:49,440 --> 00:53:53,200
attractive about these is when you get

00:53:51,839 --> 00:53:54,880
the sense of the purity

00:53:53,200 --> 00:53:56,559
and the beauty behind these mathematical

00:53:54,880 --> 00:53:58,880
structures um

00:53:56,559 --> 00:54:00,480
you tend to fall in love with it and

00:53:58,880 --> 00:54:00,960
make that your life and make that your

00:54:00,480 --> 00:54:03,040
dream

00:54:00,960 --> 00:54:04,960
and a lot of functional programmers are

00:54:03,040 --> 00:54:06,559
in exactly this boat you know they just

00:54:04,960 --> 00:54:08,400
they love messing with it they love the

00:54:06,559 --> 00:54:10,559
math they love the abstract theory

00:54:08,400 --> 00:54:11,680
and they love living in that world and

00:54:10,559 --> 00:54:15,040
that is

00:54:11,680 --> 00:54:18,079
totally legit uh personally

00:54:15,040 --> 00:54:19,680
i'm a software engineer which means all

00:54:18,079 --> 00:54:21,280
these things are useful to me

00:54:19,680 --> 00:54:23,599
i do appreciate the beauty but these are

00:54:21,280 --> 00:54:24,480
useful to me in the context of creating

00:54:23,599 --> 00:54:26,240
software

00:54:24,480 --> 00:54:27,839
that people are actually going to use

00:54:26,240 --> 00:54:28,559
and is going to actually impact the

00:54:27,839 --> 00:54:30,400
world

00:54:28,559 --> 00:54:31,920
um and most of the most of us who are

00:54:30,400 --> 00:54:33,599
writing c software

00:54:31,920 --> 00:54:35,440
our software is primarily to be used and

00:54:33,599 --> 00:54:39,040
to impact the world and so

00:54:35,440 --> 00:54:40,799
uh in order to do that

00:54:39,040 --> 00:54:42,160
we have to make sure that we we have

00:54:40,799 --> 00:54:43,599
public interfaces that work with the

00:54:42,160 --> 00:54:47,599
people around us

00:54:43,599 --> 00:54:49,760
um so yeah i i personally i'm i

00:54:47,599 --> 00:54:51,119
i can appreciate the beauty and of going

00:54:49,760 --> 00:54:53,280
off the deep end and for example

00:54:51,119 --> 00:54:54,720
programming in agda

00:54:53,280 --> 00:54:55,920
i love agda as like a programming

00:54:54,720 --> 00:54:58,000
language and it takes haskell to the

00:54:55,920 --> 00:55:00,319
absolute next level

00:54:58,000 --> 00:55:01,359
but it's just not practical and when

00:55:00,319 --> 00:55:03,920
you're trying to solve real

00:55:01,359 --> 00:55:07,839
world problems practicality is at the

00:55:03,920 --> 00:55:07,839
foremost of it

00:55:08,000 --> 00:55:13,280
could you name some naming examples for

00:55:10,720 --> 00:55:17,040
monadic binds

00:55:13,280 --> 00:55:20,240
um so one of the most common

00:55:17,040 --> 00:55:22,240
things to call monadic bind is then

00:55:20,240 --> 00:55:23,839
so if you look at uh many

00:55:22,240 --> 00:55:25,359
implementations of futures not the

00:55:23,839 --> 00:55:26,240
standard feature but like maybe boost

00:55:25,359 --> 00:55:28,079
future

00:55:26,240 --> 00:55:30,079
um their monadic bind operation is

00:55:28,079 --> 00:55:31,599
called.then so you have like a dot then

00:55:30,079 --> 00:55:34,160
and then you pass in a function of that

00:55:31,599 --> 00:55:35,599
then dot then so uh that's probably the

00:55:34,160 --> 00:55:38,640
most common naming

00:55:35,599 --> 00:55:39,280
uh the it's not like some symbols that

00:55:38,640 --> 00:55:44,000
i've seen for

00:55:39,280 --> 00:55:46,720
monadic bind in c plus good question

00:55:44,000 --> 00:55:48,559
scala has monads does c plus plus go in

00:55:46,720 --> 00:55:52,160
that direction

00:55:48,559 --> 00:55:53,440
so c plus plus is is an engineer's

00:55:52,160 --> 00:55:55,839
language right

00:55:53,440 --> 00:55:57,040
and so there are a lot of possibilities

00:55:55,839 --> 00:56:00,160
of things that we can add to c

00:55:57,040 --> 00:56:01,839
plus plus the question is not

00:56:00,160 --> 00:56:03,760
what are they and in what direction do

00:56:01,839 --> 00:56:05,440
we want to go in the question is

00:56:03,760 --> 00:56:07,040
what is the highest priority thing right

00:56:05,440 --> 00:56:10,000
now so

00:56:07,040 --> 00:56:10,480
for c plus plus like my priorities

00:56:10,000 --> 00:56:12,640
adding

00:56:10,480 --> 00:56:13,760
uh first class monadic modad support is

00:56:12,640 --> 00:56:14,880
certainly an interesting thing it would

00:56:13,760 --> 00:56:16,880
make the language better but it's

00:56:14,880 --> 00:56:18,640
definitely not at the

00:56:16,880 --> 00:56:20,160
at my highest priority list i'd rather

00:56:18,640 --> 00:56:20,880
see things like pattern matching and

00:56:20,160 --> 00:56:21,839
reflection and

00:56:20,880 --> 00:56:23,280
the kinds of things that we're actually

00:56:21,839 --> 00:56:24,079
working on right now to try to add into

00:56:23,280 --> 00:56:25,440
the language

00:56:24,079 --> 00:56:27,119
it's lower down there you know it's

00:56:25,440 --> 00:56:29,359
definitely on the list of things but i

00:56:27,119 --> 00:56:31,280
think we've got other fish to fry like

00:56:29,359 --> 00:56:32,559
having a networking library and c plus

00:56:31,280 --> 00:56:34,240
plus i mean it's kind of an

00:56:32,559 --> 00:56:36,960
embarrassment that we don't have one so

00:56:34,240 --> 00:56:37,599
um i would just kind of prioritize it uh

00:56:36,960 --> 00:56:38,640
lower

00:56:37,599 --> 00:56:42,480
than the other things that we could

00:56:38,640 --> 00:56:42,480
possibly do with c plus plus language

00:56:42,640 --> 00:56:45,839
uh next comment is many functional

00:56:44,960 --> 00:56:49,200
patterns in c

00:56:45,839 --> 00:56:50,480
plus plus are handicapped by the lack of

00:56:49,200 --> 00:56:53,680
lazy evaluation

00:56:50,480 --> 00:56:56,240
any thought on lazy eval um

00:56:53,680 --> 00:56:57,599
so lazy eval would be interesting uh and

00:56:56,240 --> 00:56:59,200
and definitely would help out with some

00:56:57,599 --> 00:57:00,559
of these functional patterns

00:56:59,200 --> 00:57:02,000
um and there's actually been some

00:57:00,559 --> 00:57:02,559
proposals along these lines to be able

00:57:02,000 --> 00:57:06,000
to add

00:57:02,559 --> 00:57:07,359
uh lazy evil uh i think that probably

00:57:06,000 --> 00:57:09,359
the

00:57:07,359 --> 00:57:11,119
the biggest impediment to getting lazy

00:57:09,359 --> 00:57:13,680
eval in c plus

00:57:11,119 --> 00:57:14,319
is compelling use cases that make people

00:57:13,680 --> 00:57:15,760
say

00:57:14,319 --> 00:57:17,520
this is more important than the other

00:57:15,760 --> 00:57:20,480
stuff that we're doing

00:57:17,520 --> 00:57:21,520
and when we see more of these things

00:57:20,480 --> 00:57:22,960
then i think that it could

00:57:21,520 --> 00:57:25,599
become a reality that we want to add

00:57:22,960 --> 00:57:26,960
lazy evaluation but if we do bite off

00:57:25,599 --> 00:57:29,520
lazy evaluation

00:57:26,960 --> 00:57:31,359
it adds a huge amount of complexity lazy

00:57:29,520 --> 00:57:33,280
evaluation in haskell is

00:57:31,359 --> 00:57:34,880
not so bad because it's a pure language

00:57:33,280 --> 00:57:36,640
but we don't have a pure language so we

00:57:34,880 --> 00:57:38,480
have the complexity of it being

00:57:36,640 --> 00:57:40,160
both pure with lazy evaluation and

00:57:38,480 --> 00:57:41,839
impure with non-lazy evaluation and

00:57:40,160 --> 00:57:43,119
that's another concept that

00:57:41,839 --> 00:57:45,440
our engineers are going to have to think

00:57:43,119 --> 00:57:46,400
about all the time so um we got to be

00:57:45,440 --> 00:57:48,400
aware of the

00:57:46,400 --> 00:57:49,520
cost of taxing our developers with more

00:57:48,400 --> 00:57:52,160
complexity in

00:57:49,520 --> 00:57:52,160
its language

00:57:52,640 --> 00:57:59,920
okay cool i think that all the

00:57:56,319 --> 00:58:01,440
questions are at this point answered um

00:57:59,920 --> 00:58:03,200
i'd be happy to hang around if anybody

00:58:01,440 --> 00:58:04,079
else has any other questions otherwise

00:58:03,200 --> 00:58:09,839
thank you

00:58:04,079 --> 00:58:09,839
appreciate it

00:58:24,720 --> 00:58:26,799

YouTube URL: https://www.youtube.com/watch?v=giWCdQ7fnQU


