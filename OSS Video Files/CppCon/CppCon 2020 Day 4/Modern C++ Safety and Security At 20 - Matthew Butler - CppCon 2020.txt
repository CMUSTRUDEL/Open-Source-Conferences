Title: Modern C++ Safety and Security At 20 - Matthew Butler - CppCon 2020
Publication date: 2020-09-30
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
The C++20 standard is now complete and the features and changes to the language promise to be more extensive than even C++11, which started the modern age. Engineers who work in safety critical applications, security or even applications that get abused by customers every day have special needs from the language. But what does the new standard give us as far as writing clean, safe, secure code?

In this talk, we'll look at the new features and changes to the standard and see how they affect outcomes for code written for safety critical and secure environments or even code that just needs survive the day with whatever your users throw at it.

Among the features we'll look at are: ranges, concepts, std::format, std::span, std::atomic＜std::shared_ptr＞＞, co-routines, designates initializers, spaceship operator, attributes, using enum.

As we'll see, some new features are huge wins for safety and security while others look like wins but come with their own problems.

Then we'll look ahead at what the standards committee is working on for C++23. C++20 has a lot of changes and new features. When this talk is over you'll know which features help your write clean, safe, secure code.

And which don't.

---
Matthew Butler has spent the last three decades as a systems architect and software engineer developing systems for network security, law enforcement and the military. He primarily works in signals intelligence using C, C++ and Modern C++ to build systems running on hardware platforms ranging from embedded micro-controllers to FPGAs to large-scale airborne platforms. Much of his experience has come in either building systems that defend against attackers or building highly sensitive systems that are targets. He is actively involved in the C++ community and is on various planning committees for C++Now and CppCon as well as being a speaker at both. He is also a member of the ISO C++ Standards Committee.

Over the past thirty years, he has learned the harsh lessons on how we often write systems that fail, not because they don't scale, but because they aren't designed to be secure.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,240 --> 00:00:11,040
hi everyone i hope you're all having a

00:00:09,679 --> 00:00:12,240
great conference

00:00:11,040 --> 00:00:14,559
today we're going to talk about safety

00:00:12,240 --> 00:00:15,839
and security in c plus 20.

00:00:14,559 --> 00:00:18,160
i do have a lot of material to get

00:00:15,839 --> 00:00:19,600
through so um if you hold your questions

00:00:18,160 --> 00:00:21,199
till the very end

00:00:19,600 --> 00:00:22,720
we'll get to them then if we run long

00:00:21,199 --> 00:00:24,640
then i'll stay in the session

00:00:22,720 --> 00:00:26,400
afterwards uh to answer whatever

00:00:24,640 --> 00:00:28,480
questions you have

00:00:26,400 --> 00:00:30,320
so before we begin uh with the material

00:00:28,480 --> 00:00:31,679
i want to do a little bit of a primer on

00:00:30,320 --> 00:00:33,120
real-time embedded

00:00:31,679 --> 00:00:34,559
systems for the people that are in the

00:00:33,120 --> 00:00:35,360
room and listening to the talk that are

00:00:34,559 --> 00:00:38,320
not

00:00:35,360 --> 00:00:40,000
um either real-time or embedded systems

00:00:38,320 --> 00:00:41,760
uh developers

00:00:40,000 --> 00:00:44,320
it'll help make a lot of the comments

00:00:41,760 --> 00:00:47,039
i'll make later on make more sense

00:00:44,320 --> 00:00:48,480
so the first thing we have to deal with

00:00:47,039 --> 00:00:52,800
in a real-time embedded sense

00:00:48,480 --> 00:00:54,000
is hard firm and soft real-time

00:00:52,800 --> 00:00:57,199
requirements

00:00:54,000 --> 00:00:58,559
so hard real-time requirements are where

00:00:57,199 --> 00:01:00,239
any missed deadline

00:00:58,559 --> 00:01:03,440
will cause a total system failure that'd

00:01:00,239 --> 00:01:06,320
be things like self-driving cars

00:01:03,440 --> 00:01:07,760
most aircraft today are fly-by-wire so

00:01:06,320 --> 00:01:09,040
they're going to wind up

00:01:07,760 --> 00:01:11,280
having a lot of hard real-time

00:01:09,040 --> 00:01:12,799
requirements i mean if if you

00:01:11,280 --> 00:01:14,159
in this case this is really sort of the

00:01:12,799 --> 00:01:15,040
crashing planes and killing people

00:01:14,159 --> 00:01:17,920
moments where you

00:01:15,040 --> 00:01:19,920
where you blow a a hard real time

00:01:17,920 --> 00:01:21,840
requirement and you've just simply

00:01:19,920 --> 00:01:23,520
um the system itself has failed so think

00:01:21,840 --> 00:01:24,080
about it in terms of you're driving down

00:01:23,520 --> 00:01:25,840
the road

00:01:24,080 --> 00:01:27,520
the ten a tenth of a second here or

00:01:25,840 --> 00:01:28,560
there may mean the difference between

00:01:27,520 --> 00:01:31,040
being in a crash

00:01:28,560 --> 00:01:33,040
and actually surviving the crash or your

00:01:31,040 --> 00:01:37,119
airbags deploying

00:01:33,040 --> 00:01:37,439
um a tenth of a second too late you wind

00:01:37,119 --> 00:01:39,600
up

00:01:37,439 --> 00:01:40,560
um having a serious injury instead of

00:01:39,600 --> 00:01:43,200
actually

00:01:40,560 --> 00:01:44,960
having a crash that's survivable

00:01:43,200 --> 00:01:46,320
communications when we talk about hard

00:01:44,960 --> 00:01:47,600
real-time requirements those are almost

00:01:46,320 --> 00:01:49,759
always done

00:01:47,600 --> 00:01:51,119
in hardware you may do them with an fpga

00:01:49,759 --> 00:01:52,799
or a custom designed chip

00:01:51,119 --> 00:01:54,960
but software is just too slow for them

00:01:52,799 --> 00:01:56,159
so when we talk about hard real-time

00:01:54,960 --> 00:01:57,840
requirements we're talking about

00:01:56,159 --> 00:01:59,520
requirements that absolutely positively

00:01:57,840 --> 00:02:02,880
have to be met

00:01:59,520 --> 00:02:04,640
firm requirements have a little bit of

00:02:02,880 --> 00:02:06,240
variability in them we can we can miss

00:02:04,640 --> 00:02:07,439
the deadline by a little bit and you can

00:02:06,240 --> 00:02:09,440
see the yellow line

00:02:07,439 --> 00:02:10,800
that as time goes on the usefulness of

00:02:09,440 --> 00:02:12,959
that data actually winds up

00:02:10,800 --> 00:02:14,160
getting worse the farther away from that

00:02:12,959 --> 00:02:14,480
deadline you've missed so that's things

00:02:14,160 --> 00:02:17,440
like

00:02:14,480 --> 00:02:18,640
audio and video and udv3p traffic tends

00:02:17,440 --> 00:02:20,080
to be that way

00:02:18,640 --> 00:02:22,239
if you're drinking water out of a fire

00:02:20,080 --> 00:02:23,520
hose then dropping a couple of packets

00:02:22,239 --> 00:02:24,959
here and there's really not going to be

00:02:23,520 --> 00:02:27,200
a problem

00:02:24,959 --> 00:02:28,560
but you still have a real-time

00:02:27,200 --> 00:02:30,400
requirement for it

00:02:28,560 --> 00:02:32,239
soft requirements are actually more of

00:02:30,400 --> 00:02:34,000
what we see if you're doing

00:02:32,239 --> 00:02:36,319
things on a pc or a workstation or

00:02:34,000 --> 00:02:38,879
you're doing a large scale

00:02:36,319 --> 00:02:40,319
the usefulness of it degrades over time

00:02:38,879 --> 00:02:42,640
but we're not talking about having

00:02:40,319 --> 00:02:44,239
serious ramifications of missing it so

00:02:42,640 --> 00:02:46,080
things like industrial mechanical

00:02:44,239 --> 00:02:46,959
systems and video games are examples of

00:02:46,080 --> 00:02:49,840
where we have

00:02:46,959 --> 00:02:51,599
a soft real-time requirement most of the

00:02:49,840 --> 00:02:52,080
people who have real-time requirements

00:02:51,599 --> 00:02:54,640
that we

00:02:52,080 --> 00:02:56,160
are concerned about or that have uh or

00:02:54,640 --> 00:02:57,840
work in the embedded world

00:02:56,160 --> 00:03:00,239
you're dealing mostly with hard work

00:02:57,840 --> 00:03:01,920
time requirements or firm

00:03:00,239 --> 00:03:03,200
so it is something that you definitely

00:03:01,920 --> 00:03:04,000
have to pay attention to and something

00:03:03,200 --> 00:03:05,920
that you have to live

00:03:04,000 --> 00:03:08,319
with is in the context of the work that

00:03:05,920 --> 00:03:09,440
you're doing

00:03:08,319 --> 00:03:10,959
so there are a couple of different

00:03:09,440 --> 00:03:12,400
platforms if you're talking about in the

00:03:10,959 --> 00:03:13,760
embedded world there are bare metal

00:03:12,400 --> 00:03:15,440
boards where you have no operating

00:03:13,760 --> 00:03:15,760
system and you're running right on top

00:03:15,440 --> 00:03:19,360
of

00:03:15,760 --> 00:03:20,800
hardware so an fpga would be an example

00:03:19,360 --> 00:03:23,519
of a bare metal board where

00:03:20,800 --> 00:03:25,200
you might have a single a soft processor

00:03:23,519 --> 00:03:26,959
with no operating system

00:03:25,200 --> 00:03:28,640
which means you are now single threaded

00:03:26,959 --> 00:03:30,239
so these are the ones where you have no

00:03:28,640 --> 00:03:33,280
operating system support and you're

00:03:30,239 --> 00:03:36,640
right on top of the the opera the

00:03:33,280 --> 00:03:37,840
the board itself real-time operating

00:03:36,640 --> 00:03:40,239
systems are custom

00:03:37,840 --> 00:03:41,360
purpose-built designed um operating

00:03:40,239 --> 00:03:43,280
systems that are

00:03:41,360 --> 00:03:45,120
designed specifically so that you can

00:03:43,280 --> 00:03:46,959
meet hard real-time requirements

00:03:45,120 --> 00:03:49,040
and still have some sort of functioning

00:03:46,959 --> 00:03:51,200
operating system you have a scheduler

00:03:49,040 --> 00:03:52,319
you've got one of the one of the biggest

00:03:51,200 --> 00:03:54,239
differences between that and a

00:03:52,319 --> 00:03:55,680
traditional generic operating system is

00:03:54,239 --> 00:03:58,080
the fact that it's highly focused on

00:03:55,680 --> 00:04:02,879
determinism

00:03:58,080 --> 00:04:05,439
so an example of of of an rtos would be

00:04:02,879 --> 00:04:06,879
one that runs pathfinder which is uh on

00:04:05,439 --> 00:04:08,239
the surface of mars running around

00:04:06,879 --> 00:04:10,000
collecting samples

00:04:08,239 --> 00:04:11,280
these are very small operating systems

00:04:10,000 --> 00:04:13,280
they're very specific for

00:04:11,280 --> 00:04:14,640
that particular purpose embedded

00:04:13,280 --> 00:04:17,199
operating systems

00:04:14,640 --> 00:04:18,720
uh like linux is a very popular one are

00:04:17,199 --> 00:04:19,759
ones that are sort of the generic

00:04:18,720 --> 00:04:20,799
operating system that you're

00:04:19,759 --> 00:04:23,360
traditionally using

00:04:20,799 --> 00:04:24,639
but it's stripped down uh to get rid of

00:04:23,360 --> 00:04:26,320
most of the stuff that

00:04:24,639 --> 00:04:28,479
an operating system will carry for

00:04:26,320 --> 00:04:29,440
usability and and people playing games

00:04:28,479 --> 00:04:31,600
and things like that

00:04:29,440 --> 00:04:33,280
and it's really designed there to have

00:04:31,600 --> 00:04:35,040
an operating system that gives you a

00:04:33,280 --> 00:04:36,720
full preemptive multitasking operating

00:04:35,040 --> 00:04:38,320
system but without all of the overhead

00:04:36,720 --> 00:04:40,320
you typically would have

00:04:38,320 --> 00:04:42,240
so i've i've done a lot of work on bare

00:04:40,320 --> 00:04:43,840
metal platforms

00:04:42,240 --> 00:04:45,040
one of the things i've done in in

00:04:43,840 --> 00:04:47,600
previous years was ground-based

00:04:45,040 --> 00:04:49,600
interferometry where you have to

00:04:47,600 --> 00:04:51,440
take measurements very quickly tens of

00:04:49,600 --> 00:04:54,240
thousands of measurements in a second

00:04:51,440 --> 00:04:55,919
so you don't have the ability to carry

00:04:54,240 --> 00:04:57,440
the overhead of an operating system

00:04:55,919 --> 00:04:59,199
sometimes you might

00:04:57,440 --> 00:05:00,400
do that with an embedded operating

00:04:59,199 --> 00:05:02,560
system where you have a custom

00:05:00,400 --> 00:05:04,880
purpose-built chip that does nothing but

00:05:02,560 --> 00:05:06,880
but carry the heavy load for the the

00:05:04,880 --> 00:05:08,479
hard real-time requirements

00:05:06,880 --> 00:05:10,960
while you use the operating system for

00:05:08,479 --> 00:05:12,320
more of a way of of usability

00:05:10,960 --> 00:05:13,919
i've also done work on the embedded

00:05:12,320 --> 00:05:14,639
operating systems where this would be

00:05:13,919 --> 00:05:18,479
things like

00:05:14,639 --> 00:05:19,199
um assisted doing uh police body-worn

00:05:18,479 --> 00:05:21,199
cameras or

00:05:19,199 --> 00:05:22,560
in-car video where you have a

00:05:21,199 --> 00:05:24,160
purpose-built chip that's actually

00:05:22,560 --> 00:05:26,160
processing the video but you need

00:05:24,160 --> 00:05:28,000
another generalized operating system

00:05:26,160 --> 00:05:29,520
that has to live within a constrained

00:05:28,000 --> 00:05:31,360
environment to be able to handle and run

00:05:29,520 --> 00:05:33,039
the system

00:05:31,360 --> 00:05:35,360
so the things that we really care about

00:05:33,039 --> 00:05:37,039
in terms of performance

00:05:35,360 --> 00:05:38,639
memory allocations and deallocations

00:05:37,039 --> 00:05:42,639
this is one of those places where

00:05:38,639 --> 00:05:44,400
you you we because these are ungenerally

00:05:42,639 --> 00:05:45,680
unbounded in time and because you're

00:05:44,400 --> 00:05:47,039
usually in contention with other

00:05:45,680 --> 00:05:48,720
processes on the system

00:05:47,039 --> 00:05:50,479
we don't want to do memory allocations

00:05:48,720 --> 00:05:52,720
or deallocation now as you go down that

00:05:50,479 --> 00:05:54,160
chart from where you have a lot of firm

00:05:52,720 --> 00:05:55,919
real-time requirements down to soft

00:05:54,160 --> 00:05:57,680
real-time requirements you might relax

00:05:55,919 --> 00:05:59,280
that but in general if you're talking

00:05:57,680 --> 00:06:00,720
about anything that is safety critical

00:05:59,280 --> 00:06:02,000
once the wheels have left the ground or

00:06:00,720 --> 00:06:03,440
so in the case of an airplane once

00:06:02,000 --> 00:06:05,680
you've started your takeoff roll you're

00:06:03,440 --> 00:06:07,120
not doing allocations and de-allocations

00:06:05,680 --> 00:06:08,720
you have all the memory you're going to

00:06:07,120 --> 00:06:09,360
get you've allocated everything ahead of

00:06:08,720 --> 00:06:11,039
time

00:06:09,360 --> 00:06:12,960
because there is the possibility that

00:06:11,039 --> 00:06:14,880
you have memory starvation

00:06:12,960 --> 00:06:16,240
and a problem at a critical time and you

00:06:14,880 --> 00:06:21,360
can't afford that so in

00:06:16,240 --> 00:06:22,720
in terms of safety critical systems we

00:06:21,360 --> 00:06:24,319
we don't want to do a lot of memory

00:06:22,720 --> 00:06:26,160
allocations and deallocations you want

00:06:24,319 --> 00:06:26,720
to set it up before you go exceptions is

00:06:26,160 --> 00:06:29,919
another

00:06:26,720 --> 00:06:30,960
issue where we on almost every embedded

00:06:29,919 --> 00:06:32,880
system i've ever worked

00:06:30,960 --> 00:06:34,240
nobody uses exceptions one because

00:06:32,880 --> 00:06:35,759
they're they they have memory

00:06:34,240 --> 00:06:36,800
allocations and de-allocations they're

00:06:35,759 --> 00:06:39,199
expensive

00:06:36,800 --> 00:06:40,560
you have stack unwinding with them um if

00:06:39,199 --> 00:06:41,440
you throw an unhandled exception it

00:06:40,560 --> 00:06:42,560
bottles the

00:06:41,440 --> 00:06:44,240
it goes all the way to the top of the

00:06:42,560 --> 00:06:44,720
call stack and then puts software into

00:06:44,240 --> 00:06:47,440
reset

00:06:44,720 --> 00:06:49,199
so exceptions are generally i've never

00:06:47,440 --> 00:06:50,960
seen anybody use them in safety critical

00:06:49,199 --> 00:06:54,080
and i rarely have ever seen them be used

00:06:50,960 --> 00:06:55,680
in any sort of embedded context

00:06:54,080 --> 00:06:57,120
memory access is one of the things you

00:06:55,680 --> 00:06:58,720
have to be very careful of

00:06:57,120 --> 00:07:00,560
in an embedded world in a real-time

00:06:58,720 --> 00:07:02,800
world is you have to avoid

00:07:00,560 --> 00:07:04,400
any kind of paging memory because once

00:07:02,800 --> 00:07:05,919
you go to get that memory you need it

00:07:04,400 --> 00:07:07,599
because you've got some sort of deadline

00:07:05,919 --> 00:07:08,960
and that you're trying to meet and what

00:07:07,599 --> 00:07:10,479
you don't want to do is find out that

00:07:08,960 --> 00:07:11,039
that memory was actually paged out

00:07:10,479 --> 00:07:13,199
somewhere

00:07:11,039 --> 00:07:14,160
and now you have to go back and find it

00:07:13,199 --> 00:07:15,599
system calls

00:07:14,160 --> 00:07:17,520
most those tend to be blocking and

00:07:15,599 --> 00:07:19,280
unbounded in time so you avoid those as

00:07:17,520 --> 00:07:21,919
much as possible

00:07:19,280 --> 00:07:23,440
priority inversions we run into because

00:07:21,919 --> 00:07:24,080
everything runs on a priority which is

00:07:23,440 --> 00:07:25,919
very

00:07:24,080 --> 00:07:28,319
very different in the way of a

00:07:25,919 --> 00:07:29,759
preemptive multitasking operating system

00:07:28,319 --> 00:07:32,319
you have a lot of problems where you

00:07:29,759 --> 00:07:35,919
potentially have a a low priority pro

00:07:32,319 --> 00:07:37,360
task that is actually

00:07:35,919 --> 00:07:39,360
holding on to a resource that a high

00:07:37,360 --> 00:07:41,199
priority task needs so the high priority

00:07:39,360 --> 00:07:43,599
task is now blocked from operating

00:07:41,199 --> 00:07:45,360
pathfinder had this problem one time

00:07:43,599 --> 00:07:46,879
early in its life on mars they didn't

00:07:45,360 --> 00:07:50,080
find it here in testing and

00:07:46,879 --> 00:07:51,360
they had some it was a low priority task

00:07:50,080 --> 00:07:54,560
having to do with the weather

00:07:51,360 --> 00:07:56,639
uh and you they wound up um blocking out

00:07:54,560 --> 00:08:00,319
a higher priority test and it

00:07:56,639 --> 00:08:02,000
a guard um some sort of guard process

00:08:00,319 --> 00:08:03,440
was watching it decided the system had a

00:08:02,000 --> 00:08:04,879
problem and put the entire system into

00:08:03,440 --> 00:08:06,000
reset and so i just kept doing that over

00:08:04,879 --> 00:08:07,440
and over again

00:08:06,000 --> 00:08:09,520
context switches those are very

00:08:07,440 --> 00:08:11,120
expensive you don't notice that if

00:08:09,520 --> 00:08:12,319
you're running it on a pc or workstation

00:08:11,120 --> 00:08:13,919
but you will definitely notice

00:08:12,319 --> 00:08:16,400
any kind of context switches in an

00:08:13,919 --> 00:08:18,479
embedded system pipeline stalls

00:08:16,400 --> 00:08:19,759
because time is precious and powers

00:08:18,479 --> 00:08:21,599
pressures you want to make sure that the

00:08:19,759 --> 00:08:23,440
cpu has always got work to do and it's

00:08:21,599 --> 00:08:25,039
not stalled out

00:08:23,440 --> 00:08:26,479
weight states anything that causes you

00:08:25,039 --> 00:08:28,400
to wait is going to violate your timing

00:08:26,479 --> 00:08:32,240
restrictions

00:08:28,400 --> 00:08:35,519
so what's in the box as far as um

00:08:32,240 --> 00:08:37,360
as c plus plus 20. so th

00:08:35,519 --> 00:08:39,360
this is a release that's sort of on

00:08:37,360 --> 00:08:41,279
level with c source 11 because there

00:08:39,360 --> 00:08:42,800
is an enormous amount here and a lot of

00:08:41,279 --> 00:08:44,560
it the top four on the left is really

00:08:42,800 --> 00:08:47,440
sort of the game-changing

00:08:44,560 --> 00:08:49,120
uh features that we've put into the the

00:08:47,440 --> 00:08:51,920
c plus 20 release

00:08:49,120 --> 00:08:53,040
specifically concepts and ranges modules

00:08:51,920 --> 00:08:54,880
if you're worried about your build

00:08:53,040 --> 00:08:55,279
systems is is a huge piece of two and

00:08:54,880 --> 00:08:57,440
then co

00:08:55,279 --> 00:09:00,720
routines is sort of a new way of doing

00:08:57,440 --> 00:09:03,360
um synchronization between threads

00:09:00,720 --> 00:09:05,200
a lot of the other things um have had uh

00:09:03,360 --> 00:09:07,200
are more tactical in nature but

00:09:05,200 --> 00:09:09,360
but when you time when you sum it all up

00:09:07,200 --> 00:09:10,080
c plus was 20 is really sort of the game

00:09:09,360 --> 00:09:11,920
changing

00:09:10,080 --> 00:09:13,600
um release that we had in c plus plus

00:09:11,920 --> 00:09:15,279
11. and by the way that

00:09:13,600 --> 00:09:17,519
c switch 20 is here that's actually an

00:09:15,279 --> 00:09:19,920
actual video of the last time we met

00:09:17,519 --> 00:09:20,880
in person uh earlier this year so go out

00:09:19,920 --> 00:09:23,120
and look at it it's actually a pretty

00:09:20,880 --> 00:09:24,880
fun video

00:09:23,120 --> 00:09:26,320
so what do i look for in new features

00:09:24,880 --> 00:09:28,320
the first thing i look for is memory

00:09:26,320 --> 00:09:30,800
safety does it create memory safety

00:09:28,320 --> 00:09:32,560
issues does it eliminate it hopefully

00:09:30,800 --> 00:09:34,160
sometimes we've created memory safety

00:09:32,560 --> 00:09:35,920
issues unintentionally

00:09:34,160 --> 00:09:37,519
does it rely on memory allocations and

00:09:35,920 --> 00:09:39,200
deallocations 70

00:09:37,519 --> 00:09:41,680
of all software vulnerabilities are

00:09:39,200 --> 00:09:43,680
based on memory access problems

00:09:41,680 --> 00:09:44,720
so if you have memory safety issues in a

00:09:43,680 --> 00:09:45,839
feature it's going to be something that

00:09:44,720 --> 00:09:46,959
you're not going to want to use in a

00:09:45,839 --> 00:09:50,080
safety critical

00:09:46,959 --> 00:09:52,160
uh or secure security context

00:09:50,080 --> 00:09:54,560
runtime determinism obviously if you've

00:09:52,160 --> 00:09:56,240
got an embedded system and you've got

00:09:54,560 --> 00:09:57,680
hard real-time requirements you have to

00:09:56,240 --> 00:09:58,959
have an operating system and you have to

00:09:57,680 --> 00:10:00,080
have features that are going to wind up

00:09:58,959 --> 00:10:01,440
being deterministic

00:10:00,080 --> 00:10:02,720
it's one of the reasons why we don't use

00:10:01,440 --> 00:10:04,320
exceptions is because they aren't

00:10:02,720 --> 00:10:06,880
deterministic no matter how

00:10:04,320 --> 00:10:08,399
hard we've tried with them so does it

00:10:06,880 --> 00:10:08,800
help give you opportunities does it

00:10:08,399 --> 00:10:10,720
create

00:10:08,800 --> 00:10:13,040
problems with meeting your constraints

00:10:10,720 --> 00:10:15,680
is it more a more deterministic solution

00:10:13,040 --> 00:10:16,959
than the one that i could program

00:10:15,680 --> 00:10:19,360
that is one of the in fact we'll talk

00:10:16,959 --> 00:10:21,040
about one later and that becomes a big

00:10:19,360 --> 00:10:23,279
issue when you're evaluating something

00:10:21,040 --> 00:10:25,519
for safety and security context

00:10:23,279 --> 00:10:27,040
concurrency does it ensure atomic

00:10:25,519 --> 00:10:29,040
operations does it strengthen the

00:10:27,040 --> 00:10:30,560
concurrency model

00:10:29,040 --> 00:10:32,399
sometimes we put things in there that

00:10:30,560 --> 00:10:34,079
have actually not helped the concurrency

00:10:32,399 --> 00:10:35,839
model and in this case we have

00:10:34,079 --> 00:10:38,000
one new feature that actually at least

00:10:35,839 --> 00:10:41,040
one new feature that actually does that

00:10:38,000 --> 00:10:42,720
a hundred percent uptime we

00:10:41,040 --> 00:10:44,399
as i said before the last thing you want

00:10:42,720 --> 00:10:46,399
is to hit undefined behavior

00:10:44,399 --> 00:10:47,519
or find an exception is being thrown

00:10:46,399 --> 00:10:48,160
when the wheels are lifting off the

00:10:47,519 --> 00:10:49,600
ground of a

00:10:48,160 --> 00:10:50,880
modern day jet because now all of a

00:10:49,600 --> 00:10:51,760
sudden you've got a system that may be

00:10:50,880 --> 00:10:53,680
in reset

00:10:51,760 --> 00:10:55,279
at a critical time or when it's just

00:10:53,680 --> 00:10:56,959
seconds away from the main gear touching

00:10:55,279 --> 00:10:58,959
down

00:10:56,959 --> 00:11:00,399
code clarity and correctness we often

00:10:58,959 --> 00:11:02,079
don't think about that but does

00:11:00,399 --> 00:11:04,560
what does does the new feature actually

00:11:02,079 --> 00:11:06,160
make it easier for us to understand the

00:11:04,560 --> 00:11:07,680
developer's intent

00:11:06,160 --> 00:11:09,360
so many times we find bugs that are in

00:11:07,680 --> 00:11:11,040
code that is simply there because of

00:11:09,360 --> 00:11:12,320
misunderstanding between the person who

00:11:11,040 --> 00:11:12,800
wrote the original code and the person

00:11:12,320 --> 00:11:14,880
who

00:11:12,800 --> 00:11:16,560
actually is trying to modify it later

00:11:14,880 --> 00:11:17,120
interfaces are especially vulnerable to

00:11:16,560 --> 00:11:20,160
that

00:11:17,120 --> 00:11:22,320
scott myers did a really great talk um

00:11:20,160 --> 00:11:24,560
about interfaces and his he coined the

00:11:22,320 --> 00:11:26,720
phrase making interfaces easier to use

00:11:24,560 --> 00:11:29,360
correctly and harder to use incorrectly

00:11:26,720 --> 00:11:31,040
so you'll hear that a lot today for code

00:11:29,360 --> 00:11:32,800
reuse does it uh promote the use of

00:11:31,040 --> 00:11:34,240
well-known design patterns sometimes we

00:11:32,800 --> 00:11:36,079
can get into design patterns that are

00:11:34,240 --> 00:11:38,079
really not healthy for software but does

00:11:36,079 --> 00:11:40,000
does the new feature promote us and push

00:11:38,079 --> 00:11:42,079
us into the correct direction

00:11:40,000 --> 00:11:43,920
does it promote code reuse and generic

00:11:42,079 --> 00:11:44,959
algorithms i know a lot of engineers

00:11:43,920 --> 00:11:47,440
will say that they don't

00:11:44,959 --> 00:11:49,120
uh they don't like to use generic

00:11:47,440 --> 00:11:50,560
algorithms or generic programming they

00:11:49,120 --> 00:11:52,399
won't do something as a template

00:11:50,560 --> 00:11:53,600
but what you wind up finding is you wind

00:11:52,399 --> 00:11:54,880
up doing a lot of

00:11:53,600 --> 00:11:57,440
you find out a lot of copy and paste

00:11:54,880 --> 00:11:59,680
replication errors when you don't

00:11:57,440 --> 00:12:00,880
program from a generic standpoint so

00:11:59,680 --> 00:12:02,079
these are the kinds of things i'm going

00:12:00,880 --> 00:12:04,399
to evaluate

00:12:02,079 --> 00:12:06,720
that i use to evaluate a new feature and

00:12:04,399 --> 00:12:09,120
what we'll talk about today

00:12:06,720 --> 00:12:10,959
so let's start with the on the syntactic

00:12:09,120 --> 00:12:14,079
sugar part

00:12:10,959 --> 00:12:15,440
so aggregates got a lot of attention

00:12:14,079 --> 00:12:16,160
this time because aggregates are

00:12:15,440 --> 00:12:18,800
basically

00:12:16,160 --> 00:12:20,079
a collection of members with um with no

00:12:18,800 --> 00:12:21,600
constructors

00:12:20,079 --> 00:12:23,200
but there were a number of

00:12:21,600 --> 00:12:24,959
inconsistencies in the

00:12:23,200 --> 00:12:26,639
in the standard that allowed you to

00:12:24,959 --> 00:12:29,920
actually do things

00:12:26,639 --> 00:12:31,839
like um use constru

00:12:29,920 --> 00:12:33,279
have declared constructors but not

00:12:31,839 --> 00:12:34,639
actually provide them so one of the

00:12:33,279 --> 00:12:36,399
things we've changed

00:12:34,639 --> 00:12:38,079
is from c plus plus 17 there was

00:12:36,399 --> 00:12:40,000
literally a two word change that goes

00:12:38,079 --> 00:12:43,120
from user provided explicit

00:12:40,000 --> 00:12:45,920
to no user declared or inherited

00:12:43,120 --> 00:12:48,240
constructors so here's what that means

00:12:45,920 --> 00:12:50,160
in this case we have an account

00:12:48,240 --> 00:12:52,639
uh constructor that we've created for

00:12:50,160 --> 00:12:54,320
our aggregate but we have deleted it so

00:12:52,639 --> 00:12:55,519
we have declared it but we have not

00:12:54,320 --> 00:12:58,240
provided it

00:12:55,519 --> 00:13:00,240
so that allows line 12 where you can now

00:12:58,240 --> 00:13:02,000
go ahead and act as if that construction

00:13:00,240 --> 00:13:04,240
you sort of bypass the constructor in

00:13:02,000 --> 00:13:06,560
order to be able to construct the object

00:13:04,240 --> 00:13:08,399
so that was okay in c plus plus 17

00:13:06,560 --> 00:13:10,880
that's now broken

00:13:08,399 --> 00:13:11,600
in c plus plus 20. so what this what

00:13:10,880 --> 00:13:13,120
that did

00:13:11,600 --> 00:13:14,399
what that change did was eliminated a

00:13:13,120 --> 00:13:15,680
lot of the special rules for

00:13:14,399 --> 00:13:17,200
constructors that created a lot of

00:13:15,680 --> 00:13:20,079
inconsistencies

00:13:17,200 --> 00:13:21,680
um and one of the things that we are

00:13:20,079 --> 00:13:23,040
trying to do is sort of go and clean up

00:13:21,680 --> 00:13:23,920
some of these things where people can

00:13:23,040 --> 00:13:27,040
use

00:13:23,920 --> 00:13:28,959
um sort of rules we never thought of and

00:13:27,040 --> 00:13:30,240
sort of bypass to do things that you

00:13:28,959 --> 00:13:32,120
aren't really things that you were

00:13:30,240 --> 00:13:34,000
wanting to do so we've this change

00:13:32,120 --> 00:13:36,000
eliminates a lot of the abuse

00:13:34,000 --> 00:13:37,519
that were uh that we were using with the

00:13:36,000 --> 00:13:38,560
aggregate so in this case what it really

00:13:37,519 --> 00:13:41,120
means in the end

00:13:38,560 --> 00:13:42,240
is um if it doesn't have a con

00:13:41,120 --> 00:13:44,800
constructor then it's

00:13:42,240 --> 00:13:46,560
um then it's an aggregate and if it has

00:13:44,800 --> 00:13:47,360
constructors it's not an aggregate at

00:13:46,560 --> 00:13:49,040
this point

00:13:47,360 --> 00:13:51,199
so a lot of this was a consistency

00:13:49,040 --> 00:13:52,000
change but we also got this part which

00:13:51,199 --> 00:13:54,959
is really nice

00:13:52,000 --> 00:13:56,720
add for the for this release and that's

00:13:54,959 --> 00:13:59,120
designated initializers

00:13:56,720 --> 00:14:00,399
so traditionally in c plus was 17 you

00:13:59,120 --> 00:14:01,839
could initialize

00:14:00,399 --> 00:14:03,600
the values in there but if you wanted to

00:14:01,839 --> 00:14:04,160
skip a value you had no way of doing

00:14:03,600 --> 00:14:06,480
that

00:14:04,160 --> 00:14:08,079
uh so in this case you could have you

00:14:06,480 --> 00:14:10,639
could you start from the top down

00:14:08,079 --> 00:14:12,240
when you're doing initialization uh on

00:14:10,639 --> 00:14:13,680
the bottom one

00:14:12,240 --> 00:14:15,600
what we have today designation

00:14:13,680 --> 00:14:16,000
initializers is this we stole this from

00:14:15,600 --> 00:14:18,959
c this

00:14:16,000 --> 00:14:20,079
is sort of um also known as c

00:14:18,959 --> 00:14:22,720
compatibility

00:14:20,079 --> 00:14:24,399
so you have uh now the ability of going

00:14:22,720 --> 00:14:26,000
in and designating which initializers

00:14:24,399 --> 00:14:27,440
that you're gonna

00:14:26,000 --> 00:14:28,880
you're going to initialize at the

00:14:27,440 --> 00:14:30,240
beginning and then the the rest get

00:14:28,880 --> 00:14:32,800
initialized to zero so

00:14:30,240 --> 00:14:34,800
it's a nice ad in terms of being able to

00:14:32,800 --> 00:14:37,199
for code clarity

00:14:34,800 --> 00:14:39,279
so of the six items that i mentioned

00:14:37,199 --> 00:14:42,800
before this one so this is

00:14:39,279 --> 00:14:44,720
this one um there is a in c you

00:14:42,800 --> 00:14:46,000
you can do things out of order in c plus

00:14:44,720 --> 00:14:47,760
because of the way memory is laid out

00:14:46,000 --> 00:14:50,000
you have to do them in order

00:14:47,760 --> 00:14:51,600
so the order will be enforced at compile

00:14:50,000 --> 00:14:52,240
time which is nice for memory safety you

00:14:51,600 --> 00:14:54,399
don't have

00:14:52,240 --> 00:14:55,760
any worries there as far as a p

00:14:54,399 --> 00:14:57,360
something that's going to cause problems

00:14:55,760 --> 00:14:58,560
by being out of order

00:14:57,360 --> 00:14:59,920
it helps with code clarity and

00:14:58,560 --> 00:15:01,519
eliminates inconsistencies from the

00:14:59,920 --> 00:15:02,639
standards so this was a nice win not a

00:15:01,519 --> 00:15:04,720
huge one

00:15:02,639 --> 00:15:06,079
it took a lot to get it in because it

00:15:04,720 --> 00:15:08,240
was a breaking change and

00:15:06,079 --> 00:15:09,839
breaking changes always wind up having

00:15:08,240 --> 00:15:11,920
um

00:15:09,839 --> 00:15:13,279
have us spend a lot more time trying to

00:15:11,920 --> 00:15:16,000
figure out what are the implications of

00:15:13,279 --> 00:15:16,000
actually breaking in

00:15:16,800 --> 00:15:22,160
so where we get um

00:15:20,480 --> 00:15:23,680
if you haven't been using scoped

00:15:22,160 --> 00:15:25,440
enumerations those have been in since c

00:15:23,680 --> 00:15:26,320
plus plus 11 and they're a fantastic

00:15:25,440 --> 00:15:28,639
safety

00:15:26,320 --> 00:15:30,320
capability within the language one of

00:15:28,639 --> 00:15:32,720
the things that people

00:15:30,320 --> 00:15:34,880
if you were to on a normal enumeration

00:15:32,720 --> 00:15:36,800
up until c plus plus 17 if you were to

00:15:34,880 --> 00:15:40,240
try and

00:15:36,800 --> 00:15:42,959
use go outside the enumeration range

00:15:40,240 --> 00:15:43,600
it was undefined value in c plus plus 17

00:15:42,959 --> 00:15:46,560
that became

00:15:43,600 --> 00:15:47,199
undefined behavior which that in itself

00:15:46,560 --> 00:15:50,480
is a

00:15:47,199 --> 00:15:52,480
security risk and a safety risk as far

00:15:50,480 --> 00:15:54,480
as using that so

00:15:52,480 --> 00:15:55,920
dan this is a quote from dan saks it's

00:15:54,480 --> 00:15:57,440
actually in the proposal and i have

00:15:55,920 --> 00:15:58,639
enormous respect for dan he was one of

00:15:57,440 --> 00:16:00,079
the people that i listened to a lot when

00:15:58,639 --> 00:16:00,880
i was first coming up in the embedded

00:16:00,079 --> 00:16:02,959
world

00:16:00,880 --> 00:16:04,000
in fact i found out last year i got to

00:16:02,959 --> 00:16:06,240
meet him for the first time

00:16:04,000 --> 00:16:07,600
last year and i found out that i had

00:16:06,240 --> 00:16:10,720
sent him an email

00:16:07,600 --> 00:16:11,600
13 years before and i had just casually

00:16:10,720 --> 00:16:13,600
mentioned it

00:16:11,600 --> 00:16:15,040
and then he wound up going back and

00:16:13,600 --> 00:16:16,160
actually finding my email and forwarding

00:16:15,040 --> 00:16:19,360
it to me it blew my mind that he

00:16:16,160 --> 00:16:21,920
actually still had that email

00:16:19,360 --> 00:16:23,360
this is a what we have have added here

00:16:21,920 --> 00:16:25,120
is something that's actually fairly

00:16:23,360 --> 00:16:27,759
simple

00:16:25,120 --> 00:16:28,959
in the case here you have a normal use

00:16:27,759 --> 00:16:32,240
of an

00:16:28,959 --> 00:16:34,160
of a scoped enumeration and you are

00:16:32,240 --> 00:16:35,519
having to put in all this cruft because

00:16:34,160 --> 00:16:38,320
you now have to

00:16:35,519 --> 00:16:40,000
in order to fully define it now you have

00:16:38,320 --> 00:16:40,639
all as you're doing this rgba color

00:16:40,000 --> 00:16:42,000
channel

00:16:40,639 --> 00:16:44,800
over and over and over again which

00:16:42,000 --> 00:16:47,040
creates a lot of uh cruft in the

00:16:44,800 --> 00:16:48,800
in the screen so all we've done is just

00:16:47,040 --> 00:16:51,519
overloaded using and so now you have

00:16:48,800 --> 00:16:53,199
using enum with the rgbt color channel

00:16:51,519 --> 00:16:54,320
and now you have a much simpler

00:16:53,199 --> 00:16:55,839
not only are you not having to write

00:16:54,320 --> 00:16:56,959
this over and over again or copying and

00:16:55,839 --> 00:16:58,639
pasting

00:16:56,959 --> 00:16:59,759
but you don't have all that junk sort of

00:16:58,639 --> 00:17:00,800
sitting in there and all the craft to

00:16:59,759 --> 00:17:03,199
get past so

00:17:00,800 --> 00:17:04,799
uh this was a nice ad it's it's not

00:17:03,199 --> 00:17:05,439
earth shattering but if it helps people

00:17:04,799 --> 00:17:08,400
using

00:17:05,439 --> 00:17:10,480
uh get people to using uh enumerations

00:17:08,400 --> 00:17:13,439
properly this is a a really good

00:17:10,480 --> 00:17:15,039
thing to add to the the release so this

00:17:13,439 --> 00:17:16,400
promotes the use of scoped enumerations

00:17:15,039 --> 00:17:17,600
there's no doubt about it i mean nobody

00:17:16,400 --> 00:17:18,079
likes writing all that stuff over and

00:17:17,600 --> 00:17:20,160
over again

00:17:18,079 --> 00:17:22,400
but getting rid of that hopefully will

00:17:20,160 --> 00:17:24,400
get people to begin using

00:17:22,400 --> 00:17:26,079
if you are not using scoped enumerations

00:17:24,400 --> 00:17:28,400
that really is the one you should be

00:17:26,079 --> 00:17:30,160
using rather than standard enumerations

00:17:28,400 --> 00:17:32,080
this also helps with code clarity by

00:17:30,160 --> 00:17:35,280
removing crops so we had two

00:17:32,080 --> 00:17:37,440
sort of small one to clean up some um

00:17:35,280 --> 00:17:38,400
some inconsistencies and then one that

00:17:37,440 --> 00:17:41,280
we could now

00:17:38,400 --> 00:17:42,640
uh that helps accentuate a brand a new

00:17:41,280 --> 00:17:46,160
feature

00:17:42,640 --> 00:17:48,160
so everybody's favorite um

00:17:46,160 --> 00:17:50,320
feature now is the tie fighter three-way

00:17:48,160 --> 00:17:52,000
comparison spaceship operator that's had

00:17:50,320 --> 00:17:54,320
all sorts of names

00:17:52,000 --> 00:17:55,600
and everybody hears that and wonders

00:17:54,320 --> 00:17:57,200
what exactly were we doing in the

00:17:55,600 --> 00:17:59,200
standards committee

00:17:57,200 --> 00:18:00,799
so the spaceship operator adds a new

00:17:59,200 --> 00:18:02,799
comparison library it's more than just a

00:18:00,799 --> 00:18:04,640
single operator but in this case what it

00:18:02,799 --> 00:18:05,280
does is the operator the spaceship

00:18:04,640 --> 00:18:07,840
operator

00:18:05,280 --> 00:18:09,679
automatically creates all of the

00:18:07,840 --> 00:18:11,280
operator the comparison operators that

00:18:09,679 --> 00:18:13,200
you would need

00:18:11,280 --> 00:18:14,960
in the in the ones that i have listed

00:18:13,200 --> 00:18:17,200
these are the default semantic ones

00:18:14,960 --> 00:18:19,039
um in for in order comparison so this is

00:18:17,200 --> 00:18:20,320
sort of the default ones

00:18:19,039 --> 00:18:21,679
this means that you really only have to

00:18:20,320 --> 00:18:23,039
write one line of code instead of

00:18:21,679 --> 00:18:25,120
writing all of those again again

00:18:23,039 --> 00:18:27,120
copy and paste replication errors create

00:18:25,120 --> 00:18:29,760
problems and now this eliminates

00:18:27,120 --> 00:18:31,520
a whole class of problems when it comes

00:18:29,760 --> 00:18:33,840
to operators

00:18:31,520 --> 00:18:35,600
for the non-default semantics you now

00:18:33,840 --> 00:18:37,360
have the capabilities that

00:18:35,600 --> 00:18:39,760
on the right of strong weak and partial

00:18:37,360 --> 00:18:40,400
ordering and then equality so this gives

00:18:39,760 --> 00:18:42,480
us

00:18:40,400 --> 00:18:44,320
a very powerful library for being able

00:18:42,480 --> 00:18:44,880
to write a lot of this code without

00:18:44,320 --> 00:18:47,120
having to

00:18:44,880 --> 00:18:49,039
write every single one of these uh

00:18:47,120 --> 00:18:50,720
operators

00:18:49,039 --> 00:18:52,880
so on the left you have how you would

00:18:50,720 --> 00:18:54,480
write this under c 17 and i

00:18:52,880 --> 00:18:56,000
was writing this piece up and then

00:18:54,480 --> 00:18:57,200
realized oh i made a mistake

00:18:56,000 --> 00:18:58,880
because i was copying and pasting

00:18:57,200 --> 00:19:00,559
everything and then i found out that i

00:18:58,880 --> 00:19:03,039
did i'd made a little mistake which was

00:19:00,559 --> 00:19:05,600
on line 14. it was very hard to find

00:19:03,039 --> 00:19:07,280
um but i left it in there because it is

00:19:05,600 --> 00:19:08,559
a copy and paste replication error that

00:19:07,280 --> 00:19:10,000
you because you're having to write these

00:19:08,559 --> 00:19:12,240
over and over again

00:19:10,000 --> 00:19:13,440
on c plus 20 it's all down to one line

00:19:12,240 --> 00:19:16,160
now so this is the

00:19:13,440 --> 00:19:17,120
this is the standard in order comparison

00:19:16,160 --> 00:19:18,880
so now you just

00:19:17,120 --> 00:19:20,320
simply have to write the operator equal

00:19:18,880 --> 00:19:22,480
sign and it will create

00:19:20,320 --> 00:19:24,000
all of these for you so that you don't

00:19:22,480 --> 00:19:25,760
have to worry about now you could have

00:19:24,000 --> 00:19:28,880
done that with crtp

00:19:25,760 --> 00:19:31,120
but crtp adds a lot of boilerplate code

00:19:28,880 --> 00:19:33,440
which also makes it possible to make

00:19:31,120 --> 00:19:35,120
mistakes and now you have just one line

00:19:33,440 --> 00:19:36,720
to do it the other nice thing that

00:19:35,120 --> 00:19:38,320
that got added as far as this is

00:19:36,720 --> 00:19:40,400
concerned is that now you have

00:19:38,320 --> 00:19:41,520
a you can actually use this as a direct

00:19:40,400 --> 00:19:44,320
comparison

00:19:41,520 --> 00:19:46,000
so you can use that in an if statement

00:19:44,320 --> 00:19:48,400
so if it's less than zero that means

00:19:46,000 --> 00:19:50,000
foo one is smaller than foo two if it's

00:19:48,400 --> 00:19:51,280
uh greater than zero then that's the

00:19:50,000 --> 00:19:54,160
reverse and then it also

00:19:51,280 --> 00:19:55,120
can test for equality and so this gives

00:19:54,160 --> 00:19:57,600
us a

00:19:55,120 --> 00:19:59,039
an ability to have a very simple this is

00:19:57,600 --> 00:19:59,760
a nice ad that it gives you a very

00:19:59,039 --> 00:20:01,840
simple

00:19:59,760 --> 00:20:03,360
uh way of actually getting rid of a lot

00:20:01,840 --> 00:20:06,159
of code that we have a tendency to do

00:20:03,360 --> 00:20:08,080
copy and paste replication with

00:20:06,159 --> 00:20:10,159
then there is this there is a so barry

00:20:08,080 --> 00:20:12,559
reskin came up

00:20:10,159 --> 00:20:14,960
with this where he wanted to be able to

00:20:12,559 --> 00:20:17,520
do a comparisons of optional

00:20:14,960 --> 00:20:18,480
so this piece of code 19 lines winds up

00:20:17,520 --> 00:20:21,760
replacing

00:20:18,480 --> 00:20:22,240
30 different operators that he would

00:20:21,760 --> 00:20:25,280
have

00:20:22,240 --> 00:20:27,440
had to have written by hand

00:20:25,280 --> 00:20:29,120
and that that's where this library is

00:20:27,440 --> 00:20:30,960
going is to be able to take away sort of

00:20:29,120 --> 00:20:33,919
the drudgery and be able to create

00:20:30,960 --> 00:20:34,880
a lot of this sort of out of the ether

00:20:33,919 --> 00:20:37,520
without having to

00:20:34,880 --> 00:20:39,280
uh without having to do all of this the

00:20:37,520 --> 00:20:41,440
writing yourself

00:20:39,280 --> 00:20:43,039
so this is a nice ad i wasn't really a

00:20:41,440 --> 00:20:44,240
huge fan of it but it's sort of grown on

00:20:43,039 --> 00:20:46,640
me as we've gone along

00:20:44,240 --> 00:20:48,000
um it doesn't have a lot of implications

00:20:46,640 --> 00:20:49,919
in terms of safety and security

00:20:48,000 --> 00:20:51,520
from the standpoint of how it operates

00:20:49,919 --> 00:20:54,080
in the code except the fact that

00:20:51,520 --> 00:20:55,919
you're not going to create a lot of copy

00:20:54,080 --> 00:20:57,840
and paste replication bugs that you've

00:20:55,919 --> 00:20:59,280
you now simplifies your interfaces so

00:20:57,840 --> 00:21:00,640
instead of having all of these things

00:20:59,280 --> 00:21:03,120
listed out now you've got

00:21:00,640 --> 00:21:04,640
a single line that allows you to just

00:21:03,120 --> 00:21:06,000
create these

00:21:04,640 --> 00:21:07,760
and then it eliminates the need for more

00:21:06,000 --> 00:21:09,679
complicated solutions like crtp which

00:21:07,760 --> 00:21:11,760
may be a little more error prone

00:21:09,679 --> 00:21:13,120
so it this is also a nice ad and if you

00:21:11,760 --> 00:21:14,400
want to know more about this jonathan

00:21:13,120 --> 00:21:17,360
mueller did using c

00:21:14,400 --> 00:21:19,039
plus 20's three-way comparison uh last

00:21:17,360 --> 00:21:22,320
year at cppcon so go take a look at that

00:21:19,039 --> 00:21:23,840
and he explains it more in detail

00:21:22,320 --> 00:21:25,120
so let's look at the standard library

00:21:23,840 --> 00:21:27,360
and i know we don't tend to use the

00:21:25,120 --> 00:21:29,039
standard library a lot

00:21:27,360 --> 00:21:31,120
in the embedded world simply because

00:21:29,039 --> 00:21:33,120
it's not tuned for embedded applications

00:21:31,120 --> 00:21:34,559
but i think this is for people who are

00:21:33,120 --> 00:21:36,320
who don't spend time in the embedded

00:21:34,559 --> 00:21:39,039
world this is a a really good

00:21:36,320 --> 00:21:40,320
um some of these i things that we have

00:21:39,039 --> 00:21:42,000
in here are really good for them to

00:21:40,320 --> 00:21:43,679
to know how it affects safety and

00:21:42,000 --> 00:21:45,840
security so

00:21:43,679 --> 00:21:47,600
this is of all the things that we have

00:21:45,840 --> 00:21:48,799
uh put into cpu specifically this is the

00:21:47,600 --> 00:21:50,559
one i've got that i

00:21:48,799 --> 00:21:52,159
love the most that i think actually is

00:21:50,559 --> 00:21:53,760
the biggest game changer that we have as

00:21:52,159 --> 00:21:56,320
far as safety and security

00:21:53,760 --> 00:21:56,960
uh for the embedded world specifically

00:21:56,320 --> 00:21:59,520
so

00:21:56,960 --> 00:22:01,039
here we have a function and we've got

00:21:59,520 --> 00:22:02,559
our function template and we want to

00:22:01,039 --> 00:22:04,559
pass in some sort of a container and

00:22:02,559 --> 00:22:05,760
we're going to sort it so we put up our

00:22:04,559 --> 00:22:07,840
warning which says

00:22:05,760 --> 00:22:09,039
um go ahead you know you need to have a

00:22:07,840 --> 00:22:10,400
container that is sortable

00:22:09,039 --> 00:22:12,559
which makes perfect sense given the name

00:22:10,400 --> 00:22:14,880
of the function

00:22:12,559 --> 00:22:15,600
so in order to protect things instead of

00:22:14,880 --> 00:22:17,120
trying to

00:22:15,600 --> 00:22:18,799
perhaps find out that there's going to

00:22:17,120 --> 00:22:20,480
be a runtime error because you didn't

00:22:18,799 --> 00:22:22,240
pass in something with sortable we'll go

00:22:20,480 --> 00:22:24,480
and constrain it so we want to constrain

00:22:22,240 --> 00:22:27,600
it using the requires

00:22:24,480 --> 00:22:30,400
and we want to be able to um sort of

00:22:27,600 --> 00:22:32,400
define what we mean by sortable

00:22:30,400 --> 00:22:34,080
and that creates and then we do a static

00:22:32,400 --> 00:22:35,760
assert so we're catching this at compile

00:22:34,080 --> 00:22:38,720
time so if you're passing something that

00:22:35,760 --> 00:22:40,640
is is non-sortable in and trying to

00:22:38,720 --> 00:22:43,200
instantiate this template then

00:22:40,640 --> 00:22:44,720
you now have a the ability to to catch

00:22:43,200 --> 00:22:46,400
this compilation which is what we want

00:22:44,720 --> 00:22:48,640
we want compile time safety we don't

00:22:46,400 --> 00:22:52,159
want to figure this out on the fly

00:22:48,640 --> 00:22:53,679
so we're good so the problem becomes is

00:22:52,159 --> 00:22:57,600
what if we get the definition

00:22:53,679 --> 00:22:59,120
is sortable wrong what what elem what

00:22:57,600 --> 00:23:00,559
what do you have to have what attributes

00:22:59,120 --> 00:23:01,440
does a container have to have in order

00:23:00,559 --> 00:23:03,840
to be

00:23:01,440 --> 00:23:04,960
sortable and if we get three out of four

00:23:03,840 --> 00:23:06,480
attributes

00:23:04,960 --> 00:23:08,799
now we have what we've done is we've

00:23:06,480 --> 00:23:09,600
turned an interface problem into a logic

00:23:08,799 --> 00:23:11,520
problem

00:23:09,600 --> 00:23:13,039
because now the problem is going to be

00:23:11,520 --> 00:23:15,360
buried in the logic and that is going to

00:23:13,039 --> 00:23:16,080
wind up being a runtime problem instead

00:23:15,360 --> 00:23:18,000
of

00:23:16,080 --> 00:23:19,280
a an interface problem that we had

00:23:18,000 --> 00:23:22,880
before

00:23:19,280 --> 00:23:24,320
so this is where concept comes in and

00:23:22,880 --> 00:23:27,840
this is the one that i think is

00:23:24,320 --> 00:23:29,679
is for me from a safety and security

00:23:27,840 --> 00:23:32,159
standpoint is the biggest feature we've

00:23:29,679 --> 00:23:33,679
put in so we add the new concepts

00:23:32,159 --> 00:23:35,520
library and it's been described as a

00:23:33,679 --> 00:23:37,200
type system for the type system and it's

00:23:35,520 --> 00:23:38,080
so it's based on the c plus those 14

00:23:37,200 --> 00:23:40,400
concepts

00:23:38,080 --> 00:23:41,919
ts so you've had access to this for a

00:23:40,400 --> 00:23:42,640
while but it's now actually in the

00:23:41,919 --> 00:23:44,640
language

00:23:42,640 --> 00:23:46,400
and what this does is helps you describe

00:23:44,640 --> 00:23:47,039
the constraints and generic code that

00:23:46,400 --> 00:23:49,840
will

00:23:47,039 --> 00:23:52,000
that are required for that template

00:23:49,840 --> 00:23:55,360
instantiation

00:23:52,000 --> 00:23:56,640
and what this does is it means now the

00:23:55,360 --> 00:23:59,200
interfaces

00:23:56,640 --> 00:24:00,799
are totally can be made totally clear as

00:23:59,200 --> 00:24:03,919
to what the expectations are

00:24:00,799 --> 00:24:06,080
for using them and the standard provides

00:24:03,919 --> 00:24:07,919
a ton of them this is not even a full

00:24:06,080 --> 00:24:09,360
uh list of them but you've got movable

00:24:07,919 --> 00:24:11,279
copyable you have

00:24:09,360 --> 00:24:12,960
move constructable copy constructables

00:24:11,279 --> 00:24:14,559
you have a lot of these that have

00:24:12,960 --> 00:24:15,919
already been defined which is really

00:24:14,559 --> 00:24:17,440
great for engineers because they don't

00:24:15,919 --> 00:24:19,440
have to go figure this out

00:24:17,440 --> 00:24:21,200
now all of a sudden they can just go

00:24:19,440 --> 00:24:23,039
start using these things unlike lego

00:24:21,200 --> 00:24:24,480
bricks they can cr they can create the

00:24:23,039 --> 00:24:25,919
correct interfaces to make sure that

00:24:24,480 --> 00:24:28,080
what you're passing in

00:24:25,919 --> 00:24:29,600
is actually what they need so those

00:24:28,080 --> 00:24:32,000
attributes are defined right there in

00:24:29,600 --> 00:24:33,520
the interface

00:24:32,000 --> 00:24:35,840
let's look at how this would work so

00:24:33,520 --> 00:24:37,440
here is the sortable

00:24:35,840 --> 00:24:38,880
concept that's defined right in the

00:24:37,440 --> 00:24:40,000
standard so you can go and look at it

00:24:38,880 --> 00:24:41,360
and this is

00:24:40,000 --> 00:24:43,120
this will tell you whether or not the

00:24:41,360 --> 00:24:46,880
container you're passing in is going to

00:24:43,120 --> 00:24:48,799
be sortable so now the interface comes

00:24:46,880 --> 00:24:49,840
down to just simply instead of type name

00:24:48,799 --> 00:24:53,279
or class you've got

00:24:49,840 --> 00:24:55,840
uh it just simply says tor uh sortable

00:24:53,279 --> 00:24:57,760
so now the interface is completely clear

00:24:55,840 --> 00:24:59,919
as to what they expect

00:24:57,760 --> 00:25:00,960
um instead of having to go drag through

00:24:59,919 --> 00:25:02,559
the code and look and see okay what

00:25:00,960 --> 00:25:04,000
exactly are you going to be doing to it

00:25:02,559 --> 00:25:06,159
now all of a sudden the interface has

00:25:04,000 --> 00:25:07,520
the clarity we need we also added the

00:25:06,159 --> 00:25:10,640
requires keyword so

00:25:07,520 --> 00:25:12,960
the top one and the bottom one um

00:25:10,640 --> 00:25:14,159
both they both resolve to the same thing

00:25:12,960 --> 00:25:15,840
you can either

00:25:14,159 --> 00:25:17,600
put it in the template its definition

00:25:15,840 --> 00:25:18,559
itself or you can use the require

00:25:17,600 --> 00:25:19,919
statement

00:25:18,559 --> 00:25:22,159
either one of these works they all

00:25:19,919 --> 00:25:23,360
resolve to the same thing i prefer the

00:25:22,159 --> 00:25:25,840
top one because now i'm

00:25:23,360 --> 00:25:27,360
looking at the at the interface as sort

00:25:25,840 --> 00:25:28,559
of at the top line interface and they

00:25:27,360 --> 00:25:32,000
know exactly what

00:25:28,559 --> 00:25:32,960
is expected of it but adding this

00:25:32,000 --> 00:25:36,400
requires

00:25:32,960 --> 00:25:38,159
keywords sort of created an interesting

00:25:36,400 --> 00:25:39,200
side effect that i'm not sure if anyone

00:25:38,159 --> 00:25:40,480
thought about or if it was just

00:25:39,200 --> 00:25:42,400
something that

00:25:40,480 --> 00:25:43,520
came out of it but the code you're

00:25:42,400 --> 00:25:46,320
looking at is not

00:25:43,520 --> 00:25:46,640
deceptive this does compile and you do

00:25:46,320 --> 00:25:49,360
see

00:25:46,640 --> 00:25:51,039
two destructors there and that's because

00:25:49,360 --> 00:25:53,440
now you have the requires keyword

00:25:51,039 --> 00:25:54,960
now allows you to go in and those the

00:25:53,440 --> 00:25:58,000
whichever one of those

00:25:54,960 --> 00:25:59,679
constructor destructors is

00:25:58,000 --> 00:26:01,039
makes sense for when you instantiate

00:25:59,679 --> 00:26:02,799
that template

00:26:01,039 --> 00:26:04,320
that's the one it's going to use so your

00:26:02,799 --> 00:26:05,600
code can now have

00:26:04,320 --> 00:26:07,120
multiple destructors and this was

00:26:05,600 --> 00:26:08,720
something that jason turner talked about

00:26:07,120 --> 00:26:11,840
a few weeks ago

00:26:08,720 --> 00:26:13,919
in uh his uh c plus weekly podcast

00:26:11,840 --> 00:26:14,960
so you now have the ability to cr to

00:26:13,919 --> 00:26:16,799
have

00:26:14,960 --> 00:26:18,159
multiple two structures which looks

00:26:16,799 --> 00:26:18,799
looks weird you look at the code and you

00:26:18,159 --> 00:26:20,080
think well

00:26:18,799 --> 00:26:21,440
you know this isn't c plus plus code

00:26:20,080 --> 00:26:22,720
there's got to be a different language

00:26:21,440 --> 00:26:24,320
but in this case

00:26:22,720 --> 00:26:26,159
you need to have a destructor to be able

00:26:24,320 --> 00:26:28,000
to handle where uh

00:26:26,159 --> 00:26:29,520
the object type that you're using is

00:26:28,000 --> 00:26:30,960
trivially destructible and you need to

00:26:29,520 --> 00:26:32,880
have one where it is not

00:26:30,960 --> 00:26:34,400
trivially destructible and this is how

00:26:32,880 --> 00:26:35,039
you would do it it's very simple very

00:26:34,400 --> 00:26:36,400
clean

00:26:35,039 --> 00:26:38,080
and it makes a lot of sense so there

00:26:36,400 --> 00:26:40,000
again this is why i think

00:26:38,080 --> 00:26:41,279
concepts even though it's it's got sort

00:26:40,000 --> 00:26:44,159
of this interesting

00:26:41,279 --> 00:26:45,440
side effect to it is one of the one of

00:26:44,159 --> 00:26:48,080
these great features we put in

00:26:45,440 --> 00:26:49,600
will help safety and security so this is

00:26:48,080 --> 00:26:51,120
a template scenario template library

00:26:49,600 --> 00:26:52,080
feature all these things are built in

00:26:51,120 --> 00:26:53,279
the

00:26:52,080 --> 00:26:55,120
standard template library has been

00:26:53,279 --> 00:26:56,559
changed a lot in order and they've

00:26:55,120 --> 00:26:58,240
put this all throughout the standard

00:26:56,559 --> 00:27:00,720
template library so you'll see this

00:26:58,240 --> 00:27:02,240
everywhere plus you can make use of it

00:27:00,720 --> 00:27:04,000
it makes the interfaces

00:27:02,240 --> 00:27:05,919
much more clear so you understand you

00:27:04,000 --> 00:27:07,840
can roll your own one of the things that

00:27:05,919 --> 00:27:09,840
i am finding though is that the

00:27:07,840 --> 00:27:11,200
complexity of this for for sort of the

00:27:09,840 --> 00:27:12,640
everyday developer may be

00:27:11,200 --> 00:27:14,320
a little more challenging this is going

00:27:12,640 --> 00:27:16,240
to i think wind up

00:27:14,320 --> 00:27:17,919
being something that library designers

00:27:16,240 --> 00:27:19,760
use much more

00:27:17,919 --> 00:27:20,960
where if you're the library designer on

00:27:19,760 --> 00:27:22,480
your team you're going to be the person

00:27:20,960 --> 00:27:24,559
who's going to use a lot of this

00:27:22,480 --> 00:27:26,240
and as you build your libraries and then

00:27:24,559 --> 00:27:26,720
other people will simply enjoy the fact

00:27:26,240 --> 00:27:28,559
that they

00:27:26,720 --> 00:27:30,159
now fully understand at an interface

00:27:28,559 --> 00:27:33,440
level what

00:27:30,159 --> 00:27:35,279
the expectations are so this is going to

00:27:33,440 --> 00:27:37,200
eliminate runtime errors and relies on

00:27:35,279 --> 00:27:39,120
because it now relies on compile-time

00:27:37,200 --> 00:27:40,960
checks which is exactly what we want

00:27:39,120 --> 00:27:42,640
uh it makes the interfaces easier to use

00:27:40,960 --> 00:27:44,240
correctly harder to use incorrectly just

00:27:42,640 --> 00:27:47,039
like scott myers

00:27:44,240 --> 00:27:48,880
has said so often it promotes generic

00:27:47,039 --> 00:27:50,720
programming and a lot of code reuse

00:27:48,880 --> 00:27:51,919
people i think will in doing this it

00:27:50,720 --> 00:27:53,679
makes a lot more sense to put things

00:27:51,919 --> 00:27:56,240
into libraries now instead of

00:27:53,679 --> 00:27:58,240
writing a single one-time use function

00:27:56,240 --> 00:27:59,679
the only thing that i see in it is got a

00:27:58,240 --> 00:28:01,279
high level complexity this is going to

00:27:59,679 --> 00:28:03,120
be something especially and the type

00:28:01,279 --> 00:28:04,399
system is never easy to deal with in c

00:28:03,120 --> 00:28:06,960
plus this is going to be one of those

00:28:04,399 --> 00:28:09,600
things where we're going to have to

00:28:06,960 --> 00:28:11,039
uh sort of understand that it's going to

00:28:09,600 --> 00:28:12,480
add a lot of complexity that people are

00:28:11,039 --> 00:28:13,760
going to have to work through and like

00:28:12,480 --> 00:28:15,440
so many things that we put in the

00:28:13,760 --> 00:28:16,080
standard we're going to figure out as we

00:28:15,440 --> 00:28:17,919
go along

00:28:16,080 --> 00:28:20,000
sort of simpler ways to do these things

00:28:17,919 --> 00:28:24,480
and go back and refine

00:28:20,000 --> 00:28:24,480
it as far as just

00:28:24,640 --> 00:28:28,320
large features that went in ranges has

00:28:26,799 --> 00:28:29,200
got to be the largest feature and the

00:28:28,320 --> 00:28:31,279
one that's probably

00:28:29,200 --> 00:28:32,640
had the greatest impact in the code base

00:28:31,279 --> 00:28:34,320
especially in the standard template

00:28:32,640 --> 00:28:36,480
libraries

00:28:34,320 --> 00:28:38,559
so what ranges does is you know we

00:28:36,480 --> 00:28:40,320
always had direct memory access where we

00:28:38,559 --> 00:28:42,080
were accessing things with

00:28:40,320 --> 00:28:43,679
indexes or pointers and then we got

00:28:42,080 --> 00:28:44,720
iterators and iterators were supposed to

00:28:43,679 --> 00:28:46,159
be so much more safe

00:28:44,720 --> 00:28:48,399
and then we found out that iterations

00:28:46,159 --> 00:28:49,679
weren't as safe as we thought they were

00:28:48,399 --> 00:28:51,200
and there were many times when we could

00:28:49,679 --> 00:28:53,039
do things with iterators

00:28:51,200 --> 00:28:55,120
that um were actually pretty dangerous

00:28:53,039 --> 00:28:56,240
now ranges actually sort of abstracts

00:28:55,120 --> 00:28:58,640
this away

00:28:56,240 --> 00:29:00,559
and this is the principle of zero uh

00:28:58,640 --> 00:29:04,399
overhead abstractions

00:29:00,559 --> 00:29:07,679
sort of in in the in the living where

00:29:04,399 --> 00:29:10,159
we've now abstracted this above

00:29:07,679 --> 00:29:12,159
what we had using the using the features

00:29:10,159 --> 00:29:15,360
and the functionalities we had before

00:29:12,159 --> 00:29:16,640
but now you have a much more safe method

00:29:15,360 --> 00:29:18,559
of doing this because you're not having

00:29:16,640 --> 00:29:20,000
to write all of the spoiler play code

00:29:18,559 --> 00:29:21,919
and having to deal with iterators

00:29:20,000 --> 00:29:23,360
you pass things off to the ranges

00:29:21,919 --> 00:29:25,440
library and the ranges

00:29:23,360 --> 00:29:26,559
library handles it and when we talk

00:29:25,440 --> 00:29:28,320
about if you've never had

00:29:26,559 --> 00:29:29,440
heard zero overhead abstractions what

00:29:28,320 --> 00:29:30,559
we're talking about is not that there's

00:29:29,440 --> 00:29:32,799
no cost

00:29:30,559 --> 00:29:34,399
it's that it is not going to create any

00:29:32,799 --> 00:29:36,159
more overhead than if you were to hand

00:29:34,399 --> 00:29:38,080
roll the code yourself

00:29:36,159 --> 00:29:40,880
so ranges is one of those libraries and

00:29:38,080 --> 00:29:43,120
it's been it's been in

00:29:40,880 --> 00:29:45,679
uh in development for five or six years

00:29:43,120 --> 00:29:47,200
and it has performed phenomenally well

00:29:45,679 --> 00:29:48,960
so let's look at it the way we would

00:29:47,200 --> 00:29:50,559
normally do this you have a vector you

00:29:48,960 --> 00:29:51,919
pass it to a sorting function you need

00:29:50,559 --> 00:29:53,520
to send the beginning and ending

00:29:51,919 --> 00:29:54,000
iterator so that you can iterate over

00:29:53,520 --> 00:29:56,960
the range

00:29:54,000 --> 00:29:56,960
and then do this sort

00:29:57,279 --> 00:30:00,320
with ranges all you do is just pass the

00:29:59,440 --> 00:30:01,919
vector in

00:30:00,320 --> 00:30:03,360
and it takes care of finding the

00:30:01,919 --> 00:30:04,799
iterators and iterating over the range

00:30:03,360 --> 00:30:06,240
so you don't have to worry about the

00:30:04,799 --> 00:30:07,679
iterator anymore

00:30:06,240 --> 00:30:09,600
but there's a lot more that it's added

00:30:07,679 --> 00:30:11,600
there are a lot of views that that this

00:30:09,600 --> 00:30:14,080
library now adds so here i have

00:30:11,600 --> 00:30:15,279
a map and i've thrown in some elements

00:30:14,080 --> 00:30:16,640
and then i'm going to go ahead and i

00:30:15,279 --> 00:30:18,559
just want to reverse the view i'm not

00:30:16,640 --> 00:30:22,480
reversing the map i just want to

00:30:18,559 --> 00:30:24,399
print them out in a reverse order

00:30:22,480 --> 00:30:26,480
so now you have a reverse view which

00:30:24,399 --> 00:30:27,520
takes some sort of a container and just

00:30:26,480 --> 00:30:30,559
prints them out

00:30:27,520 --> 00:30:32,320
in reverse there is also but one of the

00:30:30,559 --> 00:30:34,240
fundamental changes that's been made by

00:30:32,320 --> 00:30:35,600
ranges library is going towards more of

00:30:34,240 --> 00:30:38,720
a

00:30:35,600 --> 00:30:41,200
a functional composition

00:30:38,720 --> 00:30:42,159
style of programming so in the last

00:30:41,200 --> 00:30:44,880
example at the bottom

00:30:42,159 --> 00:30:46,960
i've got a series of numbers which i'm

00:30:44,880 --> 00:30:49,039
going to mask line 3's got my

00:30:46,960 --> 00:30:50,480
my masking logic and then line 4 is

00:30:49,039 --> 00:30:51,760
going to take those masks it's going to

00:30:50,480 --> 00:30:53,360
apply a filter

00:30:51,760 --> 00:30:55,039
based on the mask and then it's going to

00:30:53,360 --> 00:30:56,960
reverse it and then it's going to

00:30:55,039 --> 00:30:59,440
transform

00:30:56,960 --> 00:31:00,399
the data that's left and and cube

00:30:59,440 --> 00:31:02,559
everything

00:31:00,399 --> 00:31:03,760
so when i print this out my list that

00:31:02,559 --> 00:31:06,640
was in the vector

00:31:03,760 --> 00:31:08,559
now gets uh printed out with just three

00:31:06,640 --> 00:31:08,960
numbers because the filters eliminated a

00:31:08,559 --> 00:31:12,080
bunch

00:31:08,960 --> 00:31:14,480
plus it reverse them into the transform

00:31:12,080 --> 00:31:16,159
this is when you're writing software

00:31:14,480 --> 00:31:18,480
this is like

00:31:16,159 --> 00:31:20,000
writing really the the simplest software

00:31:18,480 --> 00:31:21,919
you can write it's a it's very

00:31:20,000 --> 00:31:22,880
expressive it's very easy to understand

00:31:21,919 --> 00:31:25,120
so it's a huge win

00:31:22,880 --> 00:31:26,159
in terms of the ability to understand

00:31:25,120 --> 00:31:27,919
code

00:31:26,159 --> 00:31:30,320
the problem is is that that pipe symbol

00:31:27,919 --> 00:31:32,240
is going to be deceptively expensive

00:31:30,320 --> 00:31:33,600
all those filters and transforms that

00:31:32,240 --> 00:31:35,840
you're doing on there are going to be

00:31:33,600 --> 00:31:37,840
computationally expensive

00:31:35,840 --> 00:31:39,039
so you're going to use that and you're

00:31:37,840 --> 00:31:40,880
looking at you think wonderful and then

00:31:39,039 --> 00:31:43,919
you go back and look at why is my

00:31:40,880 --> 00:31:46,320
application running like it's the 1990s

00:31:43,919 --> 00:31:48,000
and the reality is is that if you get

00:31:46,320 --> 00:31:49,440
into the habit of using this without

00:31:48,000 --> 00:31:51,679
understanding the implications

00:31:49,440 --> 00:31:52,880
from a performance standpoint of what

00:31:51,679 --> 00:31:55,600
each of these is doing

00:31:52,880 --> 00:31:56,559
you will wind up having code that looks

00:31:55,600 --> 00:31:59,120
wonderful but

00:31:56,559 --> 00:32:00,640
runs horribly slow and that's probably

00:31:59,120 --> 00:32:02,480
the biggest

00:32:00,640 --> 00:32:04,320
reservation i have about ranges is it

00:32:02,480 --> 00:32:06,640
allows people to write a lot of really

00:32:04,320 --> 00:32:08,880
inefficient code

00:32:06,640 --> 00:32:11,440
so here are this is not a complete list

00:32:08,880 --> 00:32:13,760
there's a huge number of

00:32:11,440 --> 00:32:15,200
of these if you so these are basically

00:32:13,760 --> 00:32:16,720
just range views so

00:32:15,200 --> 00:32:18,720
um if you've been listening to sean

00:32:16,720 --> 00:32:21,519
parent there's nth element you've got

00:32:18,720 --> 00:32:23,279
the ability to pull out the um the the

00:32:21,519 --> 00:32:24,000
keys under the key value pair you've got

00:32:23,279 --> 00:32:25,919
the ability to pull

00:32:24,000 --> 00:32:28,080
the values out of a value pair you've

00:32:25,919 --> 00:32:29,519
got the ability to transform or drop a

00:32:28,080 --> 00:32:31,120
certain number of elements so there's

00:32:29,519 --> 00:32:32,399
there's all of this code has now been

00:32:31,120 --> 00:32:33,760
written and tested it's part of the

00:32:32,399 --> 00:32:35,600
standard template libraries which makes

00:32:33,760 --> 00:32:37,279
things much easier to do

00:32:35,600 --> 00:32:38,880
again it's zero overhead from the

00:32:37,279 --> 00:32:41,120
perspective of

00:32:38,880 --> 00:32:42,320
you couldn't write this any more

00:32:41,120 --> 00:32:44,480
efficiently

00:32:42,320 --> 00:32:45,440
on your own but it is not zero over here

00:32:44,480 --> 00:32:46,880
from the perspective

00:32:45,440 --> 00:32:48,880
that that pipe simple is going to wind

00:32:46,880 --> 00:32:50,480
up being very expensive and people might

00:32:48,880 --> 00:32:51,679
not appreciate that given the simplicity

00:32:50,480 --> 00:32:53,519
of the code they're looking at

00:32:51,679 --> 00:32:55,440
we have a tendency to look at complexity

00:32:53,519 --> 00:32:56,240
of code or the number of lines of code

00:32:55,440 --> 00:32:58,000
you've written and

00:32:56,240 --> 00:32:59,279
sort of draw a conclusion about what the

00:32:58,000 --> 00:33:00,559
performance is going to be

00:32:59,279 --> 00:33:02,159
where that pipe symbol is going to be

00:33:00,559 --> 00:33:04,080
hiding an awful lot of that and so is

00:33:02,159 --> 00:33:06,240
really the ranges library

00:33:04,080 --> 00:33:07,600
so from a safety and security standpoint

00:33:06,240 --> 00:33:09,360
uh it's

00:33:07,600 --> 00:33:10,799
it's huge for safety because it

00:33:09,360 --> 00:33:12,640
eliminates um

00:33:10,799 --> 00:33:14,640
most or all of the direct memory access

00:33:12,640 --> 00:33:15,039
or rationales for direct memory access

00:33:14,640 --> 00:33:16,559
or

00:33:15,039 --> 00:33:17,760
using iterators there will be times when

00:33:16,559 --> 00:33:19,039
you'll find you have it because there's

00:33:17,760 --> 00:33:19,279
nothing in the ranges library that does

00:33:19,039 --> 00:33:20,880
it

00:33:19,279 --> 00:33:22,720
you could go and write something that

00:33:20,880 --> 00:33:25,279
follows the ranges paradigm and

00:33:22,720 --> 00:33:25,919
and get the same thing um this is not

00:33:25,279 --> 00:33:27,760
going to be

00:33:25,919 --> 00:33:29,519
arranged the live ranges library is not

00:33:27,760 --> 00:33:33,519
going to be something we use in

00:33:29,519 --> 00:33:35,600
real time embedded um it it's fine for

00:33:33,519 --> 00:33:37,039
for traditional development but it's not

00:33:35,600 --> 00:33:38,559
something for real-time embedded simply

00:33:37,039 --> 00:33:39,440
because it is does carry a lot of

00:33:38,559 --> 00:33:41,679
overhead

00:33:39,440 --> 00:33:42,960
um it is as thread safe as the

00:33:41,679 --> 00:33:45,039
underlying containers and algorithms

00:33:42,960 --> 00:33:48,000
which means if they throw it will throw

00:33:45,039 --> 00:33:49,039
uh it doesn't change any of that um the

00:33:48,000 --> 00:33:50,640
um

00:33:49,039 --> 00:33:52,240
so it does have exceptions in there so

00:33:50,640 --> 00:33:53,519
it's it it's something that from an

00:33:52,240 --> 00:33:55,519
embedded standpoint we probably are not

00:33:53,519 --> 00:33:58,320
going to spend a lot of time using

00:33:55,519 --> 00:34:00,080
it does create really elegant functional

00:33:58,320 --> 00:34:02,559
style code which is really nice to

00:34:00,080 --> 00:34:04,159
to read and look at it's wonderful it um

00:34:02,559 --> 00:34:05,600
it's going to create cause people to be

00:34:04,159 --> 00:34:07,200
it's kind of like when we first got

00:34:05,600 --> 00:34:08,960
inheritance and polymorphism and we

00:34:07,200 --> 00:34:11,040
built all these 17

00:34:08,960 --> 00:34:12,639
000 layers of inheritance and then you

00:34:11,040 --> 00:34:14,159
know year in we found out that that was

00:34:12,639 --> 00:34:14,560
just a horrible way to write software

00:34:14,159 --> 00:34:16,240
and so

00:34:14,560 --> 00:34:17,760
nobody builds deep hierarchies and

00:34:16,240 --> 00:34:18,800
inheritance now this will be one of

00:34:17,760 --> 00:34:20,000
those things we're going to have to

00:34:18,800 --> 00:34:22,960
be very careful of where that pipe

00:34:20,000 --> 00:34:22,960
symbol comes in

00:34:23,200 --> 00:34:27,040
so let's talk about concurrency for a

00:34:24,800 --> 00:34:27,040
minute

00:34:27,359 --> 00:34:31,040
i ask this question and every time i ask

00:34:29,280 --> 00:34:34,320
this question half the room

00:34:31,040 --> 00:34:35,119
looks up and says yeah the t is thread

00:34:34,320 --> 00:34:38,000
safe the other has

00:34:35,119 --> 00:34:39,119
isn't really sure um most of the time

00:34:38,000 --> 00:34:40,159
what it comes down to is what

00:34:39,119 --> 00:34:40,960
everybody's thinking about is the

00:34:40,159 --> 00:34:42,480
control block

00:34:40,960 --> 00:34:44,800
they're thinking well the control block

00:34:42,480 --> 00:34:45,280
you know has to be thread safe therefore

00:34:44,800 --> 00:34:47,119
the t

00:34:45,280 --> 00:34:49,440
is assumed to be safe too and that

00:34:47,119 --> 00:34:52,560
actually turns out not to be true

00:34:49,440 --> 00:34:53,440
so in this case the t in the shared

00:34:52,560 --> 00:34:55,359
pointer

00:34:53,440 --> 00:34:58,400
is not thread safe but the control block

00:34:55,359 --> 00:34:59,680
is and i'm sure there's an explanation i

00:34:58,400 --> 00:35:02,320
haven't gone and found out what it is

00:34:59,680 --> 00:35:04,640
why we didn't make the the t thread safe

00:35:02,320 --> 00:35:05,920
and be up until this point up until c

00:35:04,640 --> 00:35:09,040
plus plus 20 we

00:35:05,920 --> 00:35:09,760
we had some sort of sketchy ways of of

00:35:09,040 --> 00:35:11,440
doing

00:35:09,760 --> 00:35:12,960
you know making it atomic and they

00:35:11,440 --> 00:35:13,920
looked kind of weird and it didn't

00:35:12,960 --> 00:35:16,640
really

00:35:13,920 --> 00:35:18,480
uh didn't really work out correctly so

00:35:16,640 --> 00:35:20,160
now we've fixed that so

00:35:18,480 --> 00:35:21,599
uh atomic shared pointer is now a

00:35:20,160 --> 00:35:24,800
template specialization

00:35:21,599 --> 00:35:25,839
of atomic which means we have fixed the

00:35:24,800 --> 00:35:27,200
we've now given the

00:35:25,839 --> 00:35:29,119
people the ability to be able to make

00:35:27,200 --> 00:35:30,480
that shared pointer fully atomic instead

00:35:29,119 --> 00:35:32,480
of just having the control block be

00:35:30,480 --> 00:35:34,320
atomic

00:35:32,480 --> 00:35:36,560
bear in mind though that shared pointer

00:35:34,320 --> 00:35:37,920
t is not thread safe in and of itself

00:35:36,560 --> 00:35:40,160
the control block is the t

00:35:37,920 --> 00:35:41,359
is not standard atomic just allows you

00:35:40,160 --> 00:35:42,640
to do that now so this new

00:35:41,359 --> 00:35:44,800
specialization

00:35:42,640 --> 00:35:46,640
eliminates and eliminates the need for

00:35:44,800 --> 00:35:48,320
for manual locking like we're doing here

00:35:46,640 --> 00:35:50,000
so this is an example that actually

00:35:48,320 --> 00:35:51,760
comes from the proposal and here we have

00:35:50,000 --> 00:35:53,760
a class it's a concurrent stack

00:35:51,760 --> 00:35:55,520
we're having to do lock cards so lines

00:35:53,760 --> 00:35:57,359
13 20 27

00:35:55,520 --> 00:35:59,119
31 or now you're having to do manual

00:35:57,359 --> 00:36:01,280
locking if you forget

00:35:59,119 --> 00:36:02,720
or if you mess up the lock and maybe

00:36:01,280 --> 00:36:05,040
you're shadowing the mutex

00:36:02,720 --> 00:36:07,440
accidentally you have a much bigger

00:36:05,040 --> 00:36:10,400
problem and a much harder problem to go

00:36:07,440 --> 00:36:12,480
track down so now on line three you just

00:36:10,400 --> 00:36:14,400
simply declare it as atomic now all of a

00:36:12,480 --> 00:36:15,839
sudden we get rid of all those manual

00:36:14,400 --> 00:36:17,680
locks you've got

00:36:15,839 --> 00:36:19,119
some of the other code changes a bit but

00:36:17,680 --> 00:36:21,839
it actually makes it a

00:36:19,119 --> 00:36:23,200
much simpler code to look at so as far

00:36:21,839 --> 00:36:25,760
as safety and security

00:36:23,200 --> 00:36:28,079
giving because we do people do even in

00:36:25,760 --> 00:36:31,440
the better world use shared pointer

00:36:28,079 --> 00:36:31,440
this is a huge safety win

00:36:31,520 --> 00:36:36,000
so um it we you do potentially have

00:36:35,119 --> 00:36:37,920
memory if you're

00:36:36,000 --> 00:36:39,040
using sharepoint or incorrectly because

00:36:37,920 --> 00:36:42,240
you think it's uh

00:36:39,040 --> 00:36:43,359
atomic when it's not we do this resolves

00:36:42,240 --> 00:36:45,280
a lot of makes it

00:36:43,359 --> 00:36:47,839
easy to resolve a lot of memory safety

00:36:45,280 --> 00:36:49,599
issues it eliminates the manual locking

00:36:47,839 --> 00:36:51,119
so that you don't have a lot of the the

00:36:49,599 --> 00:36:52,240
cross that's now in your code it makes

00:36:51,119 --> 00:36:54,079
it much simpler

00:36:52,240 --> 00:36:55,520
um so it eliminates the noise so i

00:36:54,079 --> 00:36:57,119
really like this one this is a

00:36:55,520 --> 00:36:58,560
this this is a really nice win that

00:36:57,119 --> 00:37:02,400
we've that we've

00:36:58,560 --> 00:37:02,400
put into the standard this year

00:37:02,800 --> 00:37:09,200
so this is the co routines is the

00:37:07,200 --> 00:37:10,240
it's the one that i understand the least

00:37:09,200 --> 00:37:11,839
mainly because i've had the least

00:37:10,240 --> 00:37:13,200
experience with it but it's also the one

00:37:11,839 --> 00:37:14,560
that i think is

00:37:13,200 --> 00:37:16,640
going to be the hardest for people to

00:37:14,560 --> 00:37:18,320
get their arms around i uh i went and

00:37:16,640 --> 00:37:22,079
asked another standard committee's

00:37:18,320 --> 00:37:23,359
me uh member if did they you know what

00:37:22,079 --> 00:37:24,400
do they know about co-routines and they

00:37:23,359 --> 00:37:25,760
sort of shrug their shoulders and said

00:37:24,400 --> 00:37:28,880
no you need to go talk to

00:37:25,760 --> 00:37:30,240
this other person because it was a uh

00:37:28,880 --> 00:37:32,000
you know very few people really

00:37:30,240 --> 00:37:33,520
understand it and i and then looking the

00:37:32,000 --> 00:37:34,800
complexity of this i think that's going

00:37:33,520 --> 00:37:36,880
to wind up being

00:37:34,800 --> 00:37:38,320
um sort of the the hardest part to get

00:37:36,880 --> 00:37:40,320
past with co-routines

00:37:38,320 --> 00:37:42,079
so co-routines are a form of structured

00:37:40,320 --> 00:37:43,760
concurrency what they do is they

00:37:42,079 --> 00:37:45,520
it adds a new co-retunes library and

00:37:43,760 --> 00:37:46,720
it's a lot more than just what i'm going

00:37:45,520 --> 00:37:48,400
to describe today there's

00:37:46,720 --> 00:37:50,000
and you'll have to there are some really

00:37:48,400 --> 00:37:52,320
good talks out there that

00:37:50,000 --> 00:37:53,520
will help hopefully explain this but

00:37:52,320 --> 00:37:56,400
i've noticed that even

00:37:53,520 --> 00:37:57,839
even uh in those talks the the authors

00:37:56,400 --> 00:37:58,400
or the speakers in those talks can find

00:37:57,839 --> 00:38:00,320
it

00:37:58,400 --> 00:38:01,599
very hard to sort of explain this to

00:38:00,320 --> 00:38:02,880
sort of the general programming

00:38:01,599 --> 00:38:04,480
community at large and it's not that

00:38:02,880 --> 00:38:06,960
they don't understand it it's just it's

00:38:04,480 --> 00:38:08,960
not an easy explanation

00:38:06,960 --> 00:38:11,040
so this allows a function to yield its

00:38:08,960 --> 00:38:12,560
execution back to a caller

00:38:11,040 --> 00:38:15,599
so they've added three new keywords

00:38:12,560 --> 00:38:17,440
which is uh weight yield and return

00:38:15,599 --> 00:38:19,040
plus a bunch of new types so this is

00:38:17,440 --> 00:38:21,839
it's there's more

00:38:19,040 --> 00:38:22,320
uh to go through than i have time today

00:38:21,839 --> 00:38:24,880
and i

00:38:22,320 --> 00:38:26,400
tried to think of okay what would be an

00:38:24,880 --> 00:38:28,320
example of some place

00:38:26,400 --> 00:38:29,839
where we might use co-routines in place

00:38:28,320 --> 00:38:31,040
of something that i've already written

00:38:29,839 --> 00:38:33,200
so remember i said

00:38:31,040 --> 00:38:34,240
before is that one of the questions i

00:38:33,200 --> 00:38:35,839
have is

00:38:34,240 --> 00:38:37,680
does the feature make it easier for me

00:38:35,839 --> 00:38:39,280
to do something that i've done in the

00:38:37,680 --> 00:38:39,680
past is it more efficient does it create

00:38:39,280 --> 00:38:41,760
better

00:38:39,680 --> 00:38:44,320
determinism than what i could sort of

00:38:41,760 --> 00:38:46,000
roll on my own so

00:38:44,320 --> 00:38:47,680
for embedded developers we use a lot of

00:38:46,000 --> 00:38:49,359
state machines so here you have a very

00:38:47,680 --> 00:38:52,800
simple state machine that just

00:38:49,359 --> 00:38:54,240
um it's for a user interface and you go

00:38:52,800 --> 00:38:55,040
through all the different states and

00:38:54,240 --> 00:38:57,680
then you

00:38:55,040 --> 00:38:59,599
um it's just a sort of a typical state

00:38:57,680 --> 00:39:01,440
machine and on the right you've got the

00:38:59,599 --> 00:39:03,359
how you might run a single threaded if

00:39:01,440 --> 00:39:04,960
you've got a single threaded application

00:39:03,359 --> 00:39:06,880
like i've used a lot of times

00:39:04,960 --> 00:39:08,960
each of the the pieces that you need to

00:39:06,880 --> 00:39:10,240
deal with they each get a call they each

00:39:08,960 --> 00:39:10,800
get a little bit of time so this is sort

00:39:10,240 --> 00:39:14,079
of your time

00:39:10,800 --> 00:39:15,839
slicing so theoretically the way

00:39:14,079 --> 00:39:19,280
co-routines would work is this

00:39:15,839 --> 00:39:21,599
is that you now have um

00:39:19,280 --> 00:39:24,240
the while loop is now inside that user

00:39:21,599 --> 00:39:27,520
interface you still have a state machine

00:39:24,240 --> 00:39:29,440
but on lines 12 17 and 24

00:39:27,520 --> 00:39:30,880
what you're doing is you're yielding

00:39:29,440 --> 00:39:33,520
back

00:39:30,880 --> 00:39:35,440
to the caller and this has a lot of

00:39:33,520 --> 00:39:36,800
implications normally when you return

00:39:35,440 --> 00:39:38,240
out of a function you're going to take

00:39:36,800 --> 00:39:39,680
something off the stack and then you're

00:39:38,240 --> 00:39:40,960
going to go back to the caller and then

00:39:39,680 --> 00:39:42,240
they'll get called again which will add

00:39:40,960 --> 00:39:43,040
it back to the stacks there's a lot of

00:39:42,240 --> 00:39:46,240
stack

00:39:43,040 --> 00:39:46,560
uh behavior going on with uh code with

00:39:46,240 --> 00:39:48,880
uh

00:39:46,560 --> 00:39:50,480
state machines in this case what it's

00:39:48,880 --> 00:39:51,839
not doing that would and and that

00:39:50,480 --> 00:39:53,760
that i think is gonna be part of the

00:39:51,839 --> 00:39:56,320
problem for the embedded world so this

00:39:53,760 --> 00:39:58,000
yield will yield back to

00:39:56,320 --> 00:39:59,520
the calling function so in this case the

00:39:58,000 --> 00:40:01,280
main now looks a bit different where

00:39:59,520 --> 00:40:02,720
you're using co-weight which says

00:40:01,280 --> 00:40:05,040
it's going to call it and wait for it to

00:40:02,720 --> 00:40:08,480
return and it will keep doing that

00:40:05,040 --> 00:40:10,880
and returning back to the the function

00:40:08,480 --> 00:40:13,200
until it yields back so you get really

00:40:10,880 --> 00:40:14,560
this sort of the same behavior

00:40:13,200 --> 00:40:16,640
out of it and then you have a co-return

00:40:14,560 --> 00:40:18,319
at the end and what you're generally

00:40:16,640 --> 00:40:20,079
returning is a future from this

00:40:18,319 --> 00:40:21,359
um although i don't have a lot of that

00:40:20,079 --> 00:40:24,240
written into here

00:40:21,359 --> 00:40:26,480
this is a way of allowing it to yield

00:40:24,240 --> 00:40:28,160
back without having to constantly

00:40:26,480 --> 00:40:30,800
go into a function return into function

00:40:28,160 --> 00:40:32,720
return so for if you're not doing

00:40:30,800 --> 00:40:34,560
a weight if you're not doing something

00:40:32,720 --> 00:40:36,839
that is a state machine let's say you're

00:40:34,560 --> 00:40:38,160
you're trying to initialize a

00:40:36,839 --> 00:40:41,440
communications

00:40:38,160 --> 00:40:42,720
connection you can at certain points

00:40:41,440 --> 00:40:43,520
where you're waiting for someone to

00:40:42,720 --> 00:40:45,440
respond

00:40:43,520 --> 00:40:47,280
you can go ahead and yield back to the

00:40:45,440 --> 00:40:48,800
calling function and then when it gets

00:40:47,280 --> 00:40:51,200
called back again you pick up where you

00:40:48,800 --> 00:40:51,200
started

00:40:51,520 --> 00:40:54,960
this was just the sort of the example i

00:40:53,520 --> 00:40:57,280
could come up with that sort of

00:40:54,960 --> 00:40:59,200
means more to embedded developers than

00:40:57,280 --> 00:41:00,880
anyone else

00:40:59,200 --> 00:41:02,480
so the problem with co-routines or at

00:41:00,880 --> 00:41:03,920
least i think where the the complexity

00:41:02,480 --> 00:41:05,359
comes in is you actually don't get

00:41:03,920 --> 00:41:07,119
co-routines

00:41:05,359 --> 00:41:08,560
what you get is the tools to build your

00:41:07,119 --> 00:41:09,839
own co-routines which i think is where

00:41:08,560 --> 00:41:10,480
all the complexity is going to wind up

00:41:09,839 --> 00:41:12,079
coming in

00:41:10,480 --> 00:41:13,760
this is sort of a new way of thinking

00:41:12,079 --> 00:41:14,640
and so trying to build these for just

00:41:13,760 --> 00:41:16,800
sort of the

00:41:14,640 --> 00:41:17,680
the average ordinary developer in the

00:41:16,800 --> 00:41:19,040
industry

00:41:17,680 --> 00:41:21,839
this is going to be a challenge to get

00:41:19,040 --> 00:41:23,599
past again it doesn't rely on the stack

00:41:21,839 --> 00:41:25,040
but it does use heap allocations which

00:41:23,599 --> 00:41:26,400
is going to be problematic for the

00:41:25,040 --> 00:41:28,319
embedded world depending on

00:41:26,400 --> 00:41:29,599
whether you're running on a on bare

00:41:28,319 --> 00:41:30,400
metal or you're running on something

00:41:29,599 --> 00:41:33,440
that's got a

00:41:30,400 --> 00:41:34,000
an operating system there there is going

00:41:33,440 --> 00:41:35,599
to wind

00:41:34,000 --> 00:41:37,119
up being a significant learning curve

00:41:35,599 --> 00:41:39,040
and i think uh almost with

00:41:37,119 --> 00:41:40,400
uh with some of the other things we've

00:41:39,040 --> 00:41:40,880
talked about this is going to wind up

00:41:40,400 --> 00:41:42,480
being

00:41:40,880 --> 00:41:44,240
library authors are going to be the ones

00:41:42,480 --> 00:41:46,400
that use this a lot so that you're

00:41:44,240 --> 00:41:47,839
you're creating this rather than having

00:41:46,400 --> 00:41:49,440
individual developers sort of pick this

00:41:47,839 --> 00:41:50,720
up for a single purpose you're going to

00:41:49,440 --> 00:41:52,400
you're going to really want the person

00:41:50,720 --> 00:41:54,560
to be who's the expert in co-routines to

00:41:52,400 --> 00:41:56,960
write libraries that help the developers

00:41:54,560 --> 00:41:58,720
on their team the other thing is and

00:41:56,960 --> 00:42:00,720
this is sort of more the question i have

00:41:58,720 --> 00:42:02,720
is that we don't have a and this happens

00:42:00,720 --> 00:42:03,359
a lot with with things that we come out

00:42:02,720 --> 00:42:05,359
with

00:42:03,359 --> 00:42:06,560
in the standards is we will come out

00:42:05,359 --> 00:42:08,480
with something and

00:42:06,560 --> 00:42:09,920
we really don't understand how it's

00:42:08,480 --> 00:42:11,599
going to be used and we really don't

00:42:09,920 --> 00:42:13,280
understand all of the implications

00:42:11,599 --> 00:42:14,880
and what we're looking for is feedback

00:42:13,280 --> 00:42:16,319
coming from the

00:42:14,880 --> 00:42:18,079
the community and so this is i think is

00:42:16,319 --> 00:42:20,160
going to be one of those ones where we

00:42:18,079 --> 00:42:21,599
we have a real lack of industry

00:42:20,160 --> 00:42:23,119
experience with it it's something that's

00:42:21,599 --> 00:42:24,480
brand new a completely different way of

00:42:23,119 --> 00:42:25,599
thinking of things

00:42:24,480 --> 00:42:27,760
and we don't really have any good

00:42:25,599 --> 00:42:30,000
performance metrics in real term

00:42:27,760 --> 00:42:31,520
applications we've got

00:42:30,000 --> 00:42:33,359
sort of what people have done in-house

00:42:31,520 --> 00:42:34,480
but nothing that really comes back and

00:42:33,359 --> 00:42:36,000
says

00:42:34,480 --> 00:42:37,599
this is how we can expect this to work

00:42:36,000 --> 00:42:41,440
in the general industry so

00:42:37,599 --> 00:42:42,880
if you have anything like that you know

00:42:41,440 --> 00:42:44,720
absolutely share it with the community

00:42:42,880 --> 00:42:46,480
because i've not seen anything

00:42:44,720 --> 00:42:48,560
where we have this really deployed in a

00:42:46,480 --> 00:42:52,319
way that is sort of

00:42:48,560 --> 00:42:52,319
for the general development community

00:42:52,800 --> 00:42:56,880
so it's going to use the heap so as far

00:42:54,720 --> 00:42:58,400
as the the the six categories that we've

00:42:56,880 --> 00:43:00,160
been talking about for co-routines it

00:42:58,400 --> 00:43:02,240
does use the heap to store state

00:43:00,160 --> 00:43:04,400
that's a that's going to be a problem

00:43:02,240 --> 00:43:06,240
for some embedded developers

00:43:04,400 --> 00:43:07,760
it does allow you that at least the

00:43:06,240 --> 00:43:09,200
advertisement is allows you to write

00:43:07,760 --> 00:43:10,079
safer concurrency and i believe it

00:43:09,200 --> 00:43:11,920
completely

00:43:10,079 --> 00:43:13,440
the people that i have listened to

00:43:11,920 --> 00:43:14,800
who've talked about this are absolute

00:43:13,440 --> 00:43:15,280
experts when it comes to concurrency and

00:43:14,800 --> 00:43:17,040
i have

00:43:15,280 --> 00:43:18,640
absolutely no concerns whatsoever that

00:43:17,040 --> 00:43:20,079
it will not that it will

00:43:18,640 --> 00:43:22,160
not help you write safe returns

00:43:20,079 --> 00:43:24,079
concurrency it will um i think the

00:43:22,160 --> 00:43:25,680
complexity is really the problem

00:43:24,079 --> 00:43:27,520
uh which will make it a little more

00:43:25,680 --> 00:43:28,720
complicated for people to reason about

00:43:27,520 --> 00:43:30,800
code when they see this

00:43:28,720 --> 00:43:32,160
and trying to figure out is what are the

00:43:30,800 --> 00:43:33,920
edge cases and what is sort of the

00:43:32,160 --> 00:43:35,920
implications of doing that

00:43:33,920 --> 00:43:37,599
uh and then i think one of the things

00:43:35,920 --> 00:43:39,200
that i like about this is that if you

00:43:37,599 --> 00:43:41,440
if it gets people to tend to write more

00:43:39,200 --> 00:43:44,160
library code where you have these things

00:43:41,440 --> 00:43:46,400
built in and you're not having to

00:43:44,160 --> 00:43:47,920
uh write things from scratchy time and

00:43:46,400 --> 00:43:49,680
so that helps promote code reason i

00:43:47,920 --> 00:43:51,440
think it's a great thing so

00:43:49,680 --> 00:43:52,400
um i'm sort of reserving judgment it's

00:43:51,440 --> 00:43:53,839
one of those things that i think you

00:43:52,400 --> 00:43:54,720
should sort of step into this sort of

00:43:53,839 --> 00:43:56,319
cautiously

00:43:54,720 --> 00:43:58,960
until we really understand how this

00:43:56,319 --> 00:44:02,160
operates especially in a real-time

00:43:58,960 --> 00:44:03,760
embedded system so we had some safety

00:44:02,160 --> 00:44:06,880
upgrades too

00:44:03,760 --> 00:44:08,240
the printf family is a it's been around

00:44:06,880 --> 00:44:11,440
forever it's

00:44:08,240 --> 00:44:13,200
horribly insecure there's all sorts of

00:44:11,440 --> 00:44:14,880
mistakes you can make with it

00:44:13,200 --> 00:44:17,119
mainly because they're mainly based

00:44:14,880 --> 00:44:19,119
around variable argument functions

00:44:17,119 --> 00:44:20,480
instead of something safer like variatic

00:44:19,119 --> 00:44:21,839
templates they're

00:44:20,480 --> 00:44:23,599
all susceptible to things like

00:44:21,839 --> 00:44:25,040
information disclosure and

00:44:23,599 --> 00:44:27,040
you know if you get the parameters wrong

00:44:25,040 --> 00:44:29,040
things really can go haywire on you

00:44:27,040 --> 00:44:30,319
and um a lot of the functions that are

00:44:29,040 --> 00:44:31,680
in there are ones that we use to

00:44:30,319 --> 00:44:33,040
overflow buffers which is

00:44:31,680 --> 00:44:35,280
from a hacker's standpoint it's a

00:44:33,040 --> 00:44:39,119
wonderful opportunity from

00:44:35,280 --> 00:44:42,400
ours not quite so much so the new

00:44:39,119 --> 00:44:42,960
format library basically takes the

00:44:42,400 --> 00:44:45,200
printf

00:44:42,960 --> 00:44:46,400
library and it reconstitutes it into a

00:44:45,200 --> 00:44:48,160
more modern

00:44:46,400 --> 00:44:49,839
approach so these are going to be based

00:44:48,160 --> 00:44:51,359
on variatic templates which are much

00:44:49,839 --> 00:44:53,760
more safer so now you have

00:44:51,359 --> 00:44:55,440
guaranteed type safety this is something

00:44:53,760 --> 00:44:57,040
we were never going to get with printf

00:44:55,440 --> 00:44:58,560
since it you know it's going back to the

00:44:57,040 --> 00:45:00,960
days of c

00:44:58,560 --> 00:45:02,480
the one thing that as far as an embedded

00:45:00,960 --> 00:45:04,720
world is concerned the memory management

00:45:02,480 --> 00:45:06,480
is automatic which means that you're

00:45:04,720 --> 00:45:07,599
you're you know think of standard string

00:45:06,480 --> 00:45:09,359
you know you're going to be heap

00:45:07,599 --> 00:45:10,480
allocating things a lot so from an

00:45:09,359 --> 00:45:11,760
embedded standpoint

00:45:10,480 --> 00:45:14,079
we have to pay attention to the fact

00:45:11,760 --> 00:45:17,119
that it handles the memory management

00:45:14,079 --> 00:45:19,200
uh on its own uh so it can

00:45:17,119 --> 00:45:21,040
it it based but what it does is it

00:45:19,200 --> 00:45:22,640
basically takes this for for people who

00:45:21,040 --> 00:45:24,720
are non-embedded developers it will take

00:45:22,640 --> 00:45:28,240
us from using a lot of c functions

00:45:24,720 --> 00:45:30,240
to a lot of safer modern c plus plus uh

00:45:28,240 --> 00:45:32,319
functions and one of the things that

00:45:30,240 --> 00:45:33,359
people hated about streams was that they

00:45:32,319 --> 00:45:34,960
just

00:45:33,359 --> 00:45:37,280
it made things a little more complicated

00:45:34,960 --> 00:45:40,480
to use and it wasn't intuitive

00:45:37,280 --> 00:45:42,000
um because uh but this this uh

00:45:40,480 --> 00:45:43,680
this new format library actually solves

00:45:42,000 --> 00:45:44,720
a lot of those problems and again this

00:45:43,680 --> 00:45:47,119
is another zero

00:45:44,720 --> 00:45:48,000
overhead abstraction uh product where we

00:45:47,119 --> 00:45:50,640
have

00:45:48,000 --> 00:45:51,520
we have it's been written in such a way

00:45:50,640 --> 00:45:53,119
that it's

00:45:51,520 --> 00:45:54,560
we couldn't roll any better than this so

00:45:53,119 --> 00:45:55,119
it's going to perform sort of at the

00:45:54,560 --> 00:45:57,040
peak

00:45:55,119 --> 00:45:58,839
now if you've got hard real time or even

00:45:57,040 --> 00:46:02,800
firmware rhyme

00:45:58,839 --> 00:46:04,079
um and you have a determinism problem

00:46:02,800 --> 00:46:06,000
this is not going to be the library for

00:46:04,079 --> 00:46:09,040
you but let me show you what you get

00:46:06,000 --> 00:46:10,880
in the format so they've they've given

00:46:09,040 --> 00:46:12,480
you a much simpler format there

00:46:10,880 --> 00:46:13,839
the options are a lot simpler i don't

00:46:12,480 --> 00:46:15,839
know about the rest of you but i usually

00:46:13,839 --> 00:46:17,520
have to keep a printf

00:46:15,839 --> 00:46:18,960
options list handy because i always

00:46:17,520 --> 00:46:20,400
forget them and i get them wrong in the

00:46:18,960 --> 00:46:20,960
wrong order and it doesn't work out and

00:46:20,400 --> 00:46:24,000
so

00:46:20,960 --> 00:46:25,920
this is just a very simple way of

00:46:24,000 --> 00:46:27,440
creating a string that's got a very

00:46:25,920 --> 00:46:29,920
specific format and

00:46:27,440 --> 00:46:31,599
that was always very hard to do with uh

00:46:29,920 --> 00:46:33,760
being able to

00:46:31,599 --> 00:46:35,200
using streams so down the last example

00:46:33,760 --> 00:46:36,400
there is a streams example where you're

00:46:35,200 --> 00:46:38,560
actually creating

00:46:36,400 --> 00:46:39,599
a string it'll say hello world one of

00:46:38,560 --> 00:46:41,280
the things that

00:46:39,599 --> 00:46:42,800
you've got you've got an extra parameter

00:46:41,280 --> 00:46:46,000
which it throws away and ignores

00:46:42,800 --> 00:46:47,200
which is nice and so now you have a way

00:46:46,000 --> 00:46:51,119
to format

00:46:47,200 --> 00:46:52,640
strings that is type safe

00:46:51,119 --> 00:46:54,560
it's much safer because it's based on

00:46:52,640 --> 00:46:56,079
variatic templates and you don't have to

00:46:54,560 --> 00:46:57,040
worry about some of the problems with

00:46:56,079 --> 00:46:59,359
printf

00:46:57,040 --> 00:47:02,319
so this is a really nice win it's not

00:46:59,359 --> 00:47:03,920
earth shattering but if you use printf

00:47:02,319 --> 00:47:05,599
a lot this is definitely something you

00:47:03,920 --> 00:47:08,640
want to move to

00:47:05,599 --> 00:47:10,400
so even though it has all the safety so

00:47:08,640 --> 00:47:12,319
there is sort of the the site

00:47:10,400 --> 00:47:13,680
that says this is much more safe this is

00:47:12,319 --> 00:47:16,319
much more secure

00:47:13,680 --> 00:47:17,680
but the problem is is that uh there's a

00:47:16,319 --> 00:47:18,480
lot going on under the hood that's not

00:47:17,680 --> 00:47:20,640
going to be

00:47:18,480 --> 00:47:22,800
workable for the embedded systems mainly

00:47:20,640 --> 00:47:23,839
the memory allocations and exceptions

00:47:22,800 --> 00:47:24,640
are going to be things we're not going

00:47:23,839 --> 00:47:27,040
to want to

00:47:24,640 --> 00:47:30,000
to be able or not even at times to be

00:47:27,040 --> 00:47:30,000
able to put into our code

00:47:32,400 --> 00:47:36,160
so volatile everybody's favorite keyword

00:47:35,200 --> 00:47:37,760
the one that everybody

00:47:36,160 --> 00:47:39,040
doesn't understand everybody seems to

00:47:37,760 --> 00:47:40,240
hate for reasons usually people who

00:47:39,040 --> 00:47:42,640
don't even use it

00:47:40,240 --> 00:47:45,520
so it's being deprecated and replaced by

00:47:42,640 --> 00:47:47,119
new keyword token

00:47:45,520 --> 00:47:49,599
actually that's a lie it's not being

00:47:47,119 --> 00:47:51,359
replaced we we are deprecating a lot

00:47:49,599 --> 00:47:53,680
of sort of the bad behavior that people

00:47:51,359 --> 00:47:55,440
have used for it so

00:47:53,680 --> 00:47:56,880
volatile if you've never used it is

00:47:55,440 --> 00:47:57,920
generally and there's a little it's a

00:47:56,880 --> 00:47:59,200
little more complicated than this but

00:47:57,920 --> 00:48:02,000
it's generally designed

00:47:59,200 --> 00:48:03,920
to tell the compiler not to optimize

00:48:02,000 --> 00:48:05,280
reads on a register

00:48:03,920 --> 00:48:06,880
because it could be changed outside of

00:48:05,280 --> 00:48:08,079
the view of the compiler so the compiler

00:48:06,880 --> 00:48:09,200
has a tendency to look at things and

00:48:08,079 --> 00:48:09,920
we'll see one here in a minute where it

00:48:09,200 --> 00:48:11,359
says oh

00:48:09,920 --> 00:48:13,520
there's no side effects to this so i

00:48:11,359 --> 00:48:16,319
don't have to do this anymore um

00:48:13,520 --> 00:48:17,839
in this case there were we were it is a

00:48:16,319 --> 00:48:20,240
cv qualifier which

00:48:17,839 --> 00:48:21,599
you'll see it's actually in the standard

00:48:20,240 --> 00:48:23,680
and in the interfaces

00:48:21,599 --> 00:48:25,359
a lot of the standard template library

00:48:23,680 --> 00:48:26,640
features and it's all over the place

00:48:25,359 --> 00:48:28,319
there's hundreds of

00:48:26,640 --> 00:48:29,920
places where it shows up so there's no

00:48:28,319 --> 00:48:31,680
getting rid of volatile

00:48:29,920 --> 00:48:32,960
you'd break huge amounts of code so

00:48:31,680 --> 00:48:34,240
don't worry about that but what we've

00:48:32,960 --> 00:48:35,520
gotten rid of is

00:48:34,240 --> 00:48:37,680
people would try and use it as a

00:48:35,520 --> 00:48:40,319
replacement for atomic or they would

00:48:37,680 --> 00:48:41,760
try and do as a qualifying return types

00:48:40,319 --> 00:48:43,440
or function parameters and it just

00:48:41,760 --> 00:48:45,440
became one of those messes where

00:48:43,440 --> 00:48:46,720
people were really allowed to to do a

00:48:45,440 --> 00:48:48,880
lot of things they shouldn't

00:48:46,720 --> 00:48:49,839
and one of the things where uh that we

00:48:48,880 --> 00:48:51,839
eliminated

00:48:49,839 --> 00:48:53,040
with it is what will happen is if you're

00:48:51,839 --> 00:48:54,960
doing any of that

00:48:53,040 --> 00:48:56,559
uh it'll wind up giving you a warning

00:48:54,960 --> 00:48:58,480
that that's

00:48:56,559 --> 00:49:00,480
part of a partly a problem in that we

00:48:58,480 --> 00:49:01,200
tend to have a habit of ignoring a lot

00:49:00,480 --> 00:49:04,240
of warnings

00:49:01,200 --> 00:49:06,319
instead because you're

00:49:04,240 --> 00:49:07,599
you you will want to make sure that you

00:49:06,319 --> 00:49:09,280
either go through your warnings when you

00:49:07,599 --> 00:49:10,800
go to c plus 20 to make sure that you

00:49:09,280 --> 00:49:12,640
aren't doing this or somebody in your

00:49:10,800 --> 00:49:14,160
team isn't doing this or turn your

00:49:12,640 --> 00:49:17,200
warnings into errors and

00:49:14,160 --> 00:49:18,000
catch them there so it was sort of a

00:49:17,200 --> 00:49:21,040
simple

00:49:18,000 --> 00:49:23,520
change to the standard it's um from

00:49:21,040 --> 00:49:25,119
a safety and security standpoint it is a

00:49:23,520 --> 00:49:26,960
huge

00:49:25,119 --> 00:49:29,119
uh win for the use of volatile because

00:49:26,960 --> 00:49:32,240
it volatile actually had a very

00:49:29,119 --> 00:49:33,280
narrow application and we sort of have

00:49:32,240 --> 00:49:34,480
expanded it and

00:49:33,280 --> 00:49:36,400
he really was not doing what people

00:49:34,480 --> 00:49:39,119
thought it was it was doing so

00:49:36,400 --> 00:49:41,119
um jake bastian has a uh did a talk last

00:49:39,119 --> 00:49:42,400
year at cppcon called deprecating balto

00:49:41,119 --> 00:49:44,240
where he goes through a lot of this and

00:49:42,400 --> 00:49:47,280
it's it's a very good talk so i would

00:49:44,240 --> 00:49:47,280
i would go and see that

00:49:47,359 --> 00:49:50,720
so from safety and security outcomes

00:49:49,440 --> 00:49:51,280
from what we talked about and i didn't

00:49:50,720 --> 00:49:52,480
cover

00:49:51,280 --> 00:49:55,280
everything that was in the language

00:49:52,480 --> 00:49:56,640
simply because there is a huge amount

00:49:55,280 --> 00:49:57,920
that sort of left on the floor i tried

00:49:56,640 --> 00:49:59,200
to get the major things that i thought

00:49:57,920 --> 00:50:02,079
would be

00:49:59,200 --> 00:50:02,880
most interesting so the biggest win for

00:50:02,079 --> 00:50:05,520
sure for me

00:50:02,880 --> 00:50:06,240
is concepts but the the complexity i

00:50:05,520 --> 00:50:08,960
think is going to

00:50:06,240 --> 00:50:09,920
maybe problematic co-routines again you

00:50:08,960 --> 00:50:10,880
have

00:50:09,920 --> 00:50:12,960
you have some questions about

00:50:10,880 --> 00:50:14,319
performance and complexity

00:50:12,960 --> 00:50:15,599
because you're not really getting

00:50:14,319 --> 00:50:17,599
co-routines what you're getting is the

00:50:15,599 --> 00:50:20,079
ability to write code routines

00:50:17,599 --> 00:50:21,200
standard format if you're using printf

00:50:20,079 --> 00:50:22,640
in the embedded world i think you're

00:50:21,200 --> 00:50:24,240
still stuck with printf simply because

00:50:22,640 --> 00:50:24,800
of the things that format does under the

00:50:24,240 --> 00:50:27,359
hood

00:50:24,800 --> 00:50:28,319
but if you uh everywhere else if you're

00:50:27,359 --> 00:50:30,559
using printf

00:50:28,319 --> 00:50:31,520
uh switch to format it is far safer for

00:50:30,559 --> 00:50:34,319
what you're doing

00:50:31,520 --> 00:50:34,880
and atomic shared pointer now remember

00:50:34,319 --> 00:50:38,319
the t

00:50:34,880 --> 00:50:40,079
is still not thread safe by itself so um

00:50:38,319 --> 00:50:43,599
we've just simply made it easier to be

00:50:40,079 --> 00:50:46,079
able to have an atomic sharepoint

00:50:43,599 --> 00:50:46,720
ranges this will probably be the biggest

00:50:46,079 --> 00:50:48,240
win for

00:50:46,720 --> 00:50:50,079
traditional software development not so

00:50:48,240 --> 00:50:51,920
much for embedded if at all

00:50:50,079 --> 00:50:53,760
but it is a huge win for memory safety

00:50:51,920 --> 00:50:55,440
because it it takes a lot of that stuff

00:50:53,760 --> 00:50:56,480
it abstracts it away to where now you're

00:50:55,440 --> 00:50:59,200
not having to touch

00:50:56,480 --> 00:51:00,000
raw memory as much without paying a huge

00:50:59,200 --> 00:51:03,200
price

00:51:00,000 --> 00:51:05,520
uh using enum this promotes the use of

00:51:03,200 --> 00:51:06,640
scoped enumerations and that's a great

00:51:05,520 --> 00:51:08,559
thing because if you're

00:51:06,640 --> 00:51:10,480
using standard traditional enumerations

00:51:08,559 --> 00:51:13,599
you really should move on

00:51:10,480 --> 00:51:15,599
uh the spaceship operator

00:51:13,599 --> 00:51:16,960
you know the funny name but it actually

00:51:15,599 --> 00:51:18,480
gives us a lot of uh

00:51:16,960 --> 00:51:19,920
behavior when you're talking a lot of

00:51:18,480 --> 00:51:21,839
really good features when it comes to

00:51:19,920 --> 00:51:23,200
actually doing

00:51:21,839 --> 00:51:24,559
when you're doing comparisons

00:51:23,200 --> 00:51:26,079
deprecating a volatile if you weren't

00:51:24,559 --> 00:51:27,440
abusing volatile before this wrongly

00:51:26,079 --> 00:51:29,359
won't mean much to you

00:51:27,440 --> 00:51:31,040
but uh everybody else it will and then

00:51:29,359 --> 00:51:33,359
aggregates we eliminated a lot of the

00:51:31,040 --> 00:51:36,160
abuse cases and sort of the strangeness

00:51:33,359 --> 00:51:37,280
and the uh and the standard and we got

00:51:36,160 --> 00:51:40,960
uh seasile

00:51:37,280 --> 00:51:42,640
uh designated initializers so let's look

00:51:40,960 --> 00:51:44,160
at sequels plus 23 for

00:51:42,640 --> 00:51:45,760
a minute we've had about 10 minutes left

00:51:44,160 --> 00:51:48,240
let's let's have a look at c plus

00:51:45,760 --> 00:51:48,880
23. so some of the things that were

00:51:48,240 --> 00:51:50,480
coming

00:51:48,880 --> 00:51:52,720
are contracts that we're working on

00:51:50,480 --> 00:51:54,559
right now so

00:51:52,720 --> 00:51:55,920
contracts were pulled from c plus 20

00:51:54,559 --> 00:51:58,000
after they've been voted in it was sort

00:51:55,920 --> 00:51:58,960
of a late change and a lot of it was

00:51:58,000 --> 00:52:01,040
just there was

00:51:58,960 --> 00:52:02,640
i think uh two different sides that had

00:52:01,040 --> 00:52:05,200
different views of what seaplus

00:52:02,640 --> 00:52:06,720
what what contract should be so

00:52:05,200 --> 00:52:08,400
contracts if you haven't heard of them

00:52:06,720 --> 00:52:10,160
those are a way of specifying the pre

00:52:08,400 --> 00:52:11,359
and post conditions and any invariants

00:52:10,160 --> 00:52:13,440
that are in the function

00:52:11,359 --> 00:52:14,960
these these ensure that the function

00:52:13,440 --> 00:52:16,400
operates on the valid data

00:52:14,960 --> 00:52:17,440
they actually exist before you hit the

00:52:16,400 --> 00:52:18,720
opening brace and i'll show you that

00:52:17,440 --> 00:52:20,640
here in a minute

00:52:18,720 --> 00:52:22,319
they help the the three big things

00:52:20,640 --> 00:52:23,760
though is is that they help the compiler

00:52:22,319 --> 00:52:26,559
with optimizations they

00:52:23,760 --> 00:52:28,160
they give you um a lot of capabilities

00:52:26,559 --> 00:52:29,760
for static analysis tools to know

00:52:28,160 --> 00:52:30,880
exactly what the pre and post conditions

00:52:29,760 --> 00:52:33,520
and invariants are

00:52:30,880 --> 00:52:35,119
and then um they're more expressive than

00:52:33,520 --> 00:52:36,559
error checking you know a lot of times i

00:52:35,119 --> 00:52:38,480
see code where people's written a block

00:52:36,559 --> 00:52:40,240
of code and you know if you see it in a

00:52:38,480 --> 00:52:41,920
written up somewhere it'll say you know

00:52:40,240 --> 00:52:44,640
error checking removed in order

00:52:41,920 --> 00:52:45,760
uh for clarity well a lot of code i see

00:52:44,640 --> 00:52:47,040
you might as well have that label on

00:52:45,760 --> 00:52:48,559
there because there is no error

00:52:47,040 --> 00:52:50,720
there is no checking of the data coming

00:52:48,559 --> 00:52:52,319
in there's no validation of it

00:52:50,720 --> 00:52:54,000
the problem with contracts at least as

00:52:52,319 --> 00:52:56,240
they were and probably as they will be

00:52:54,000 --> 00:52:57,599
for as far as the embedded world is they

00:52:56,240 --> 00:52:58,800
they throw exceptions so they terminate

00:52:57,599 --> 00:53:00,800
when they're violated and i

00:52:58,800 --> 00:53:03,040
that that's going to be a problem for

00:53:00,800 --> 00:53:05,520
for safety critical systems for sure

00:53:03,040 --> 00:53:06,800
um it's going to create problems for

00:53:05,520 --> 00:53:08,079
embedded systems because

00:53:06,800 --> 00:53:10,960
now you have the potential of an

00:53:08,079 --> 00:53:12,480
exception being thrown and you don't uh

00:53:10,960 --> 00:53:14,480
you don't catch it so this is what it

00:53:12,480 --> 00:53:15,359
would look like you have an expects we

00:53:14,480 --> 00:53:18,480
know the name

00:53:15,359 --> 00:53:20,480
um we expect the named length to be uh

00:53:18,480 --> 00:53:22,079
valid we expect the queue not to be full

00:53:20,480 --> 00:53:24,480
we want to ensure that it's not empty so

00:53:22,079 --> 00:53:27,200
that's basically what they look like

00:53:24,480 --> 00:53:28,000
um before before we put pull them out of

00:53:27,200 --> 00:53:31,440
the

00:53:28,000 --> 00:53:33,040
out of the standard so from a

00:53:31,440 --> 00:53:34,480
from our standpoint especially from an

00:53:33,040 --> 00:53:37,359
embedded standpoint

00:53:34,480 --> 00:53:38,960
um this is going to wind up impacting

00:53:37,359 --> 00:53:40,319
runtime determinism i think you're still

00:53:38,960 --> 00:53:41,920
having to validate the data

00:53:40,319 --> 00:53:43,359
yourself and dealing with it gracefully

00:53:41,920 --> 00:53:46,720
because you don't want

00:53:43,359 --> 00:53:48,079
uh terminate or or an exception being

00:53:46,720 --> 00:53:49,520
thrown you won't have the access to

00:53:48,079 --> 00:53:50,559
exceptions to being thrown so this is

00:53:49,520 --> 00:53:52,400
probably not something that helps

00:53:50,559 --> 00:53:55,680
embedded very well

00:53:52,400 --> 00:53:57,200
secure clear this is a a small feature

00:53:55,680 --> 00:53:58,480
change but i think it's one that's very

00:53:57,200 --> 00:53:59,599
important because one of the problems

00:53:58,480 --> 00:54:00,960
you have when you're talking about side

00:53:59,599 --> 00:54:02,400
channel attacks is i've written

00:54:00,960 --> 00:54:03,839
something to memory

00:54:02,400 --> 00:54:06,240
i may delete the pointer to it but the

00:54:03,839 --> 00:54:07,920
memory is never scrubbed so what we did

00:54:06,240 --> 00:54:09,119
is we go into a mem set so we'd scrub it

00:54:07,920 --> 00:54:10,000
but we found out compilers were

00:54:09,119 --> 00:54:11,359
optimizing things

00:54:10,000 --> 00:54:13,359
in strange ways because really what you

00:54:11,359 --> 00:54:14,800
want to do when you have a password or

00:54:13,359 --> 00:54:16,160
something you want to you want to get it

00:54:14,800 --> 00:54:17,200
you want to use it you want to clear it

00:54:16,160 --> 00:54:18,720
you don't want to leave it hanging

00:54:17,200 --> 00:54:20,720
around in memory

00:54:18,720 --> 00:54:22,640
so in this case the problem is is that

00:54:20,720 --> 00:54:24,240
we have gotten our password we've used

00:54:22,640 --> 00:54:25,200
our password and then we mems that to

00:54:24,240 --> 00:54:26,559
clear it

00:54:25,200 --> 00:54:28,160
but the compiler looks at that and says

00:54:26,559 --> 00:54:29,680
there's no side effects to this so i can

00:54:28,160 --> 00:54:30,319
actually throw the mem set away which it

00:54:29,680 --> 00:54:33,440
does

00:54:30,319 --> 00:54:34,319
and it does it very well so secure clear

00:54:33,440 --> 00:54:36,160
would be

00:54:34,319 --> 00:54:38,640
a platform independent way of signaling

00:54:36,160 --> 00:54:38,960
to the compiler is you cannot get rid of

00:54:38,640 --> 00:54:40,720
this

00:54:38,960 --> 00:54:41,760
you must do this even if there's no side

00:54:40,720 --> 00:54:43,520
effects because again it's kind of like

00:54:41,760 --> 00:54:46,160
volatile the side effects are something

00:54:43,520 --> 00:54:47,359
that are outside of the of the purview

00:54:46,160 --> 00:54:51,680
of the

00:54:47,359 --> 00:54:54,799
um of the compiler to be able to see

00:54:51,680 --> 00:54:56,160
so this is a safeguard against uh

00:54:54,799 --> 00:54:57,839
memory side channel attacks and

00:54:56,160 --> 00:54:59,520
eliminate and and

00:54:57,839 --> 00:55:01,119
if you've ever tried to do this where

00:54:59,520 --> 00:55:02,799
you're doing both linux and windows they

00:55:01,119 --> 00:55:05,040
each do it differently so it can be

00:55:02,799 --> 00:55:06,720
somewhat painful to try and

00:55:05,040 --> 00:55:09,359
have a single piece of code that

00:55:06,720 --> 00:55:11,599
actually handles either one of them

00:55:09,359 --> 00:55:13,520
so this would wind up being a class a a

00:55:11,599 --> 00:55:16,319
cross-platform way of doing it

00:55:13,520 --> 00:55:17,920
uh zero overhead deterministic exception

00:55:16,319 --> 00:55:19,119
so the real reasons why we don't use

00:55:17,920 --> 00:55:20,799
exceptions are the minute you turn

00:55:19,119 --> 00:55:22,319
exceptions on even if you don't use them

00:55:20,799 --> 00:55:23,119
it bloats our code so in the embedded

00:55:22,319 --> 00:55:25,680
world we just

00:55:23,119 --> 00:55:27,440
don't deal with them the other problem

00:55:25,680 --> 00:55:28,480
is is that they're non-deterministic

00:55:27,440 --> 00:55:29,599
if you throw an exception you don't

00:55:28,480 --> 00:55:31,119
catch it it bubbles at the top of the

00:55:29,599 --> 00:55:31,520
call stack takes your application down

00:55:31,119 --> 00:55:34,240
so

00:55:31,520 --> 00:55:35,040
these are nothing we nobody that i know

00:55:34,240 --> 00:55:37,280
of uses

00:55:35,040 --> 00:55:39,839
um exceptions in the embedded world it's

00:55:37,280 --> 00:55:41,680
just it's too painful of a process

00:55:39,839 --> 00:55:44,000
so what herb sutter is going for for

00:55:41,680 --> 00:55:44,960
this is he's trying to take the expense

00:55:44,000 --> 00:55:46,960
out of them so

00:55:44,960 --> 00:55:48,960
instead of what you would be throwing a

00:55:46,960 --> 00:55:51,520
traditional

00:55:48,960 --> 00:55:55,040
exception you would be throwing an

00:55:51,520 --> 00:55:58,400
exception but without all the overhead

00:55:55,040 --> 00:56:00,160
so this is and this comes right from his

00:55:58,400 --> 00:56:03,200
his proposal what you would really be

00:56:00,160 --> 00:56:06,000
doing is you would throw a statically

00:56:03,200 --> 00:56:07,680
typed basically a static type by value

00:56:06,000 --> 00:56:10,559
instead of throwing

00:56:07,680 --> 00:56:12,799
the exceptions that we traditionally

00:56:10,559 --> 00:56:15,599
have you get something that's much

00:56:12,799 --> 00:56:16,000
simpler and is it doesn't have all the

00:56:15,599 --> 00:56:17,839
overhead

00:56:16,000 --> 00:56:19,760
so it's basically he's saying is it's

00:56:17,839 --> 00:56:22,559
exactly as efficient deterministic

00:56:19,760 --> 00:56:23,280
as a local return by value now this is a

00:56:22,559 --> 00:56:25,040
proposal

00:56:23,280 --> 00:56:26,400
it's not gone in it's something that

00:56:25,040 --> 00:56:28,000
we're um

00:56:26,400 --> 00:56:29,520
that we're looking at right now so it's

00:56:28,000 --> 00:56:31,200
not there's there's

00:56:29,520 --> 00:56:32,880
we're still you know still sort of being

00:56:31,200 --> 00:56:34,400
discussed and worked about and you

00:56:32,880 --> 00:56:35,760
and you you have a lot of people on both

00:56:34,400 --> 00:56:36,960
sides that either like this or don't

00:56:35,760 --> 00:56:39,119
like this

00:56:36,960 --> 00:56:40,160
one of the things that and you see these

00:56:39,119 --> 00:56:42,000
are mostly red

00:56:40,160 --> 00:56:43,839
uh you know i like that it eliminates

00:56:42,000 --> 00:56:45,359
the non-determinism because it does help

00:56:43,839 --> 00:56:47,760
with runtime determinism

00:56:45,359 --> 00:56:49,680
but all the red is still there you still

00:56:47,760 --> 00:56:52,960
have stack unwinding you

00:56:49,680 --> 00:56:55,119
you still have um all of the

00:56:52,960 --> 00:56:56,400
uh problems with code clarity and

00:56:55,119 --> 00:56:58,000
correctness and code reuse

00:56:56,400 --> 00:56:59,440
they come you know you've still got to

00:56:58,000 --> 00:57:00,799
have the try catch to make sure you

00:56:59,440 --> 00:57:01,440
catch it if you don't it unwinds the

00:57:00,799 --> 00:57:04,559
stack

00:57:01,440 --> 00:57:06,880
so he's basically trying to unify

00:57:04,559 --> 00:57:08,720
exceptions and return codes into into

00:57:06,880 --> 00:57:11,200
one thing that we could all use

00:57:08,720 --> 00:57:12,400
from his perspective he he sees it is

00:57:11,200 --> 00:57:14,079
that people who use

00:57:12,400 --> 00:57:15,680
return codes versus people who use

00:57:14,079 --> 00:57:17,280
exceptions are really practicing two

00:57:15,680 --> 00:57:21,119
totally different dialects

00:57:17,280 --> 00:57:22,720
of the um of the language which is

00:57:21,119 --> 00:57:24,480
is totally true i completely get that

00:57:22,720 --> 00:57:26,720
the the part i don't like about

00:57:24,480 --> 00:57:27,760
the exceptions is a lot of is one with

00:57:26,720 --> 00:57:29,680
the overhead but two

00:57:27,760 --> 00:57:31,520
i see a lot of exceptions being used for

00:57:29,680 --> 00:57:34,240
flow control and that's not what

00:57:31,520 --> 00:57:36,240
exceptions were designed for um so we'll

00:57:34,240 --> 00:57:38,160
see where this goes in the committee

00:57:36,240 --> 00:57:39,520
uh this is the of all the things that i

00:57:38,160 --> 00:57:40,000
work on the committee this is one of the

00:57:39,520 --> 00:57:41,599
things i'm

00:57:40,000 --> 00:57:44,799
most excited about that i think has the

00:57:41,599 --> 00:57:46,559
biggest uh safety security play for us

00:57:44,799 --> 00:57:48,480
if you were to go look at the stand the

00:57:46,559 --> 00:57:49,839
the document or go look at the standard

00:57:48,480 --> 00:57:51,280
you would find there's about 300

00:57:49,839 --> 00:57:52,799
mentions of undefined

00:57:51,280 --> 00:57:55,119
something in there and these are the

00:57:52,799 --> 00:57:57,520
little landmines that we step on

00:57:55,119 --> 00:57:58,799
so the goals of this are to expl take

00:57:57,520 --> 00:58:00,240
the explicit

00:57:58,799 --> 00:58:02,160
undefined behavior that's in the core

00:58:00,240 --> 00:58:03,040
language and the implicit places where

00:58:02,160 --> 00:58:04,720
we find it

00:58:03,040 --> 00:58:06,480
and actually define it in a way that's

00:58:04,720 --> 00:58:07,760
human readable for us because if you've

00:58:06,480 --> 00:58:09,599
ever tried to read the stan

00:58:07,760 --> 00:58:11,200
the standard itself it's like reading a

00:58:09,599 --> 00:58:12,799
legal brief and that's because it's

00:58:11,200 --> 00:58:14,000
mainly for standards library maintainers

00:58:12,799 --> 00:58:16,240
and compiler writers it's not

00:58:14,000 --> 00:58:17,520
really for engineers who work on it

00:58:16,240 --> 00:58:20,880
every day

00:58:17,520 --> 00:58:23,119
so here is sort of the explanation i

00:58:20,880 --> 00:58:24,480
we talked before is that if you uh are

00:58:23,119 --> 00:58:26,160
using an enumeration

00:58:24,480 --> 00:58:28,319
and you go outside the range that it

00:58:26,160 --> 00:58:29,920
becomes undefined behavior

00:58:28,319 --> 00:58:31,760
that's the relevant passage but you can

00:58:29,920 --> 00:58:36,160
see it's not easy to find given all of

00:58:31,760 --> 00:58:38,079
the text and the legalese that's in it

00:58:36,160 --> 00:58:39,920
so this is what you would get exactly

00:58:38,079 --> 00:58:41,760
what i said at the top of this so

00:58:39,920 --> 00:58:43,760
setting an enum to a value outside the

00:58:41,760 --> 00:58:45,440
range of enumeration of the enumerator

00:58:43,760 --> 00:58:48,160
is undefined behavior and it

00:58:45,440 --> 00:58:49,599
points you back to where it is um in the

00:58:48,160 --> 00:58:50,079
standard and then it shows you an

00:58:49,599 --> 00:58:51,920
example

00:58:50,079 --> 00:58:54,720
of how doing this actually winds up

00:58:51,920 --> 00:58:54,720
causing problems

00:58:55,359 --> 00:58:58,960
so why did i tell you all of this so the

00:58:57,040 --> 00:59:01,760
reason why i wanted to talk about c plus

00:58:58,960 --> 00:59:02,960
23 today is the fact that this is your

00:59:01,760 --> 00:59:05,200
opportunity

00:59:02,960 --> 00:59:06,400
to get involved with the standards

00:59:05,200 --> 00:59:07,760
committee and with a lot of the

00:59:06,400 --> 00:59:10,319
these the working groups that are

00:59:07,760 --> 00:59:11,520
working on these exact issues now

00:59:10,319 --> 00:59:12,960
typically you'd go to a standards

00:59:11,520 --> 00:59:15,040
committee meeting usually it's all

00:59:12,960 --> 00:59:16,400
around the world it's expensive but now

00:59:15,040 --> 00:59:17,839
given the state of the world this is

00:59:16,400 --> 00:59:19,520
something you can do today

00:59:17,839 --> 00:59:21,920
and you can do without leaving your home

00:59:19,520 --> 00:59:24,400
the same way you're listening to me

00:59:21,920 --> 00:59:26,079
and none of us have has left their home

00:59:24,400 --> 00:59:28,000
the standards committees are all meeting

00:59:26,079 --> 00:59:29,839
virtually now and that gives us an

00:59:28,000 --> 00:59:32,559
opportunity for us to go

00:59:29,839 --> 00:59:33,920
and for for people who are not part of

00:59:32,559 --> 00:59:37,040
the standards committee

00:59:33,920 --> 00:59:38,720
uh to go and get involved and these are

00:59:37,040 --> 00:59:40,480
some of the places you can if you

00:59:38,720 --> 00:59:42,240
uh you do not have to be a member of the

00:59:40,480 --> 00:59:44,319
standards committee to be involved in it

00:59:42,240 --> 00:59:46,000
um i am only because i've i've been

00:59:44,319 --> 00:59:48,079
doing it for a while and i

00:59:46,000 --> 00:59:49,599
um and i wanted to make that commitment

00:59:48,079 --> 00:59:50,400
but you can be involved in it without

00:59:49,599 --> 00:59:54,240
actually

00:59:50,400 --> 00:59:55,599
becoming a member so sg14 is low latency

00:59:54,240 --> 00:59:57,200
safety and security

00:59:55,599 --> 00:59:58,640
and and i'll give you my contact

00:59:57,200 --> 01:00:00,160
information if you need help getting

00:59:58,640 --> 01:00:02,559
put in touch with the people that who

01:00:00,160 --> 01:00:04,720
run these groups i'm happy to do it

01:00:02,559 --> 01:00:06,319
we have another committee which is sg12

01:00:04,720 --> 01:00:08,799
which is undefined behavior and

01:00:06,319 --> 01:00:10,640
language vulnerabilities so these are

01:00:08,799 --> 01:00:13,119
actually in the c plus plus

01:00:10,640 --> 01:00:15,599
iso committee there is also another

01:00:13,119 --> 01:00:17,520
committee called wg23 which is language

01:00:15,599 --> 01:00:19,920
safety and they do a lot i'm on that

01:00:17,520 --> 01:00:21,359
that committee as well we do a lot where

01:00:19,920 --> 01:00:22,799
we are looking at the language

01:00:21,359 --> 01:00:25,359
vulnerabilities for c

01:00:22,799 --> 01:00:26,880
plus and how we can teach engineers to

01:00:25,359 --> 01:00:29,119
be able to avoid that and undefined

01:00:26,880 --> 01:00:31,280
behavior is a huge part of that one too

01:00:29,119 --> 01:00:33,040
then depending on what industry in um

01:00:31,280 --> 01:00:33,760
there's autozar which is a safety

01:00:33,040 --> 01:00:36,799
critical c

01:00:33,760 --> 01:00:38,640
plus was standard for uh cars and

01:00:36,799 --> 01:00:40,319
um and airplanes so it's for safety

01:00:38,640 --> 01:00:42,079
critical systems in general

01:00:40,319 --> 01:00:43,520
then there is mizra which everybody says

01:00:42,079 --> 01:00:45,040
mizrah is miserable

01:00:43,520 --> 01:00:46,720
and part of that is simply because

01:00:45,040 --> 01:00:50,000
they're still currently stuck at c

01:00:46,720 --> 01:00:50,559
plus 98 and everybody has sort of moved

01:00:50,000 --> 01:00:53,839
on

01:00:50,559 --> 01:00:57,040
um from that so

01:00:53,839 --> 01:00:58,000
the last two are are industry standards

01:00:57,040 --> 01:00:59,520
that you can still

01:00:58,000 --> 01:01:01,040
you it'll be hard to participate but you

01:00:59,520 --> 01:01:04,079
can still keep an eye on them the top

01:01:01,040 --> 01:01:05,520
three um are ones you absolutely can be

01:01:04,079 --> 01:01:06,960
involved in today

01:01:05,520 --> 01:01:08,319
which will help you learn a lot more

01:01:06,960 --> 01:01:09,200
about safety and security when it comes

01:01:08,319 --> 01:01:11,680
to modern c

01:01:09,200 --> 01:01:13,119
plus so this is my contact information

01:01:11,680 --> 01:01:15,040
my blog is at the top my

01:01:13,119 --> 01:01:16,720
email address is in the middle down the

01:01:15,040 --> 01:01:19,040
bottom is my

01:01:16,720 --> 01:01:20,799
slack channel i'm on cpplang send me a

01:01:19,040 --> 01:01:21,680
slack send me an email i'll be happy to

01:01:20,799 --> 01:01:24,720
put you into

01:01:21,680 --> 01:01:26,160
into contact with people who run these

01:01:24,720 --> 01:01:26,799
groups so that you can get more involved

01:01:26,160 --> 01:01:28,240
and again

01:01:26,799 --> 01:01:30,079
as far as the standards committee you

01:01:28,240 --> 01:01:30,799
don't have to be a standards committee

01:01:30,079 --> 01:01:33,040
mini

01:01:30,799 --> 01:01:34,400
member to get involved and this is the

01:01:33,040 --> 01:01:36,880
time to do it now that everybody's

01:01:34,400 --> 01:01:38,880
working virtually

01:01:36,880 --> 01:01:40,559
so we're actually a little overtime so i

01:01:38,880 --> 01:01:42,880
will stick around on the channel and

01:01:40,559 --> 01:01:44,480
uh and answer questions if you have any

01:01:42,880 --> 01:01:45,839
um otherwise thanks for coming to the

01:01:44,480 --> 01:01:48,640
talk and i hope you have a great rest of

01:01:45,839 --> 01:01:48,640
your day and a great rest of the

01:01:50,839 --> 01:01:53,839
conference

01:02:07,119 --> 01:02:09,200

YouTube URL: https://www.youtube.com/watch?v=uccarZGpDhk


