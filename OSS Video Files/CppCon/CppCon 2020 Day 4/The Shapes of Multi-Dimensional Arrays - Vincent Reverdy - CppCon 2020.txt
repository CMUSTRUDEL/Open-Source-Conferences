Title: The Shapes of Multi-Dimensional Arrays - Vincent Reverdy - CppCon 2020
Publication date: 2020-10-03
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/the_shapes_of_multidimensional_arrays/the_shapes_of_multidimensional_arrays__vincent_reverdy__cppcon_2020.pdf
---
In 2020, linear algebra is still not a part of standard C++. Worse than that, beyond the good old C-style multidimensional arrays, the standard library still does not provide modern tools to handle such objects. In the era of machine learning and artificial intelligence, this is starting to get embarrassing. But why is that? Why does everything is always so much more complicated in C++ than in other higher level language?

In this talk we will focus on one of the many problems involved: how to handle the shapes and dimensions of high-performance multidimensional arrays? To prevent template metaprogramming wizards from providing a completely unusable answer, we will add one requirement: it has to be concise, expressive, and understandable by humans.

To answer this question, we will see how C++20's Non-Type Template Parameters can be leveraged to build a mini-embedded compile-time language to specify the size of matrices while combining expressiveness and conciseness. We will see how this technique can allow to mix static and dynamic dimensions while ensuring the highest level of performance. We will also discuss how it could be exploited to express parallelization and vectorization, as well as sparse storage patterns. At the big picture level, this talk will also explore why bringing generic Non-Type Template Parameters may have opened a very nice Pandora's box in C++.

---
Vincent has been working as a post-doctoral researcher at the University of Illinois at Urbana-Champaign (USA) since he obtained his PhD at the Paris observatory (France) in november 2014. His main scientific interests are related to cosmology and general relativity. He his particularly interested in the study of relativistic effects at cosmological scales using high performance simulations run on supercomputers. Because these simulations rely on tree data structures, he started investigating ways to optimize them. He now leads a research team working on tree data structures with main applications in simulations, machine learning, and data science. He also participates into the C++ standardization process and regularly submits proposals to improve the C++ language.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,480 --> 00:00:13,360
hello everyone

00:00:10,080 --> 00:00:16,400
um i'm jason roddy and

00:00:13,360 --> 00:00:19,199
i'm very happy to be able to talk about

00:00:16,400 --> 00:00:19,680
multi-dimensional race today and to talk

00:00:19,199 --> 00:00:23,439
about

00:00:19,680 --> 00:00:24,800
fantasy plus plus the project i will

00:00:23,439 --> 00:00:27,199
describe

00:00:24,800 --> 00:00:28,720
has been the result of many

00:00:27,199 --> 00:00:32,399
collaborations

00:00:28,720 --> 00:00:35,920
and uh i will try to give an overview of

00:00:32,399 --> 00:00:39,120
what we have done to simplify

00:00:35,920 --> 00:00:42,840
and to maybe give a direction on how

00:00:39,120 --> 00:00:44,239
we may implement uh linear algebra in in

00:00:42,840 --> 00:00:46,160
circumstances

00:00:44,239 --> 00:00:47,920
so this talk will be about linear

00:00:46,160 --> 00:00:51,039
algebra will be about

00:00:47,920 --> 00:00:54,800
templates will be about surface plus 20

00:00:51,039 --> 00:00:55,920
um about writing language within

00:00:54,800 --> 00:00:59,840
language

00:00:55,920 --> 00:00:59,840
um all fun stuff

00:01:00,239 --> 00:01:06,240
so uh i will first give a small

00:01:03,920 --> 00:01:09,200
introduction on the topic i will

00:01:06,240 --> 00:01:10,880
try to be brief uh then about i would

00:01:09,200 --> 00:01:12,960
speak about the current standardization

00:01:10,880 --> 00:01:15,920
effort and linear algebra that has been

00:01:12,960 --> 00:01:16,479
that is going on in surplus plus and

00:01:15,920 --> 00:01:21,119
then

00:01:16,479 --> 00:01:23,020
i will i will try to talk about

00:01:21,119 --> 00:01:24,240
that possible directions to

00:01:23,020 --> 00:01:28,159
[Music]

00:01:24,240 --> 00:01:31,840
for the work that is being done and how

00:01:28,159 --> 00:01:35,040
we could have both at the same time

00:01:31,840 --> 00:01:37,040
uh high performance and things that are

00:01:35,040 --> 00:01:39,439
very easy to write

00:01:37,040 --> 00:01:41,280
and then i will dig down with you into

00:01:39,439 --> 00:01:42,000
like very detailed problems and there

00:01:41,280 --> 00:01:44,799
will be

00:01:42,000 --> 00:01:46,000
quite a lot of code and quite a lot of

00:01:44,799 --> 00:01:50,640
technical code

00:01:46,000 --> 00:01:53,119
but i hope everything will go well

00:01:50,640 --> 00:01:55,520
so starting with the introduction i

00:01:53,119 --> 00:01:57,680
guess that if you are here

00:01:55,520 --> 00:02:00,399
you are interested by uh mutant

00:01:57,680 --> 00:02:04,000
emotional rays and in algebra

00:02:00,399 --> 00:02:06,719
in a broader sense and

00:02:04,000 --> 00:02:08,319
as in algebra is basically everywhere

00:02:06,719 --> 00:02:11,440
into

00:02:08,319 --> 00:02:12,720
computer programming um i think it's not

00:02:11,440 --> 00:02:16,239
surprising

00:02:12,720 --> 00:02:17,599
that we have we made it in code like 1d

00:02:16,239 --> 00:02:21,760
arrays

00:02:17,599 --> 00:02:24,480
two digits arrays and uh and 3d right

00:02:21,760 --> 00:02:26,400
once arrays are sometimes called vectors

00:02:24,480 --> 00:02:28,879
even though vectors in mathematics

00:02:26,400 --> 00:02:30,080
may be kind of a different object

00:02:28,879 --> 00:02:33,599
because

00:02:30,080 --> 00:02:36,800
a 1d thing when the array is

00:02:33,599 --> 00:02:39,840
can represent an array of coordinates

00:02:36,800 --> 00:02:40,640
while a vector in mathematics have to

00:02:39,840 --> 00:02:43,360
ensure

00:02:40,640 --> 00:02:45,519
that certain constraints are verified

00:02:43,360 --> 00:02:48,400
when you change for example the base

00:02:45,519 --> 00:02:50,080
and same thing for tensors sensors are

00:02:48,400 --> 00:02:53,280
used in programming to to

00:02:50,080 --> 00:02:55,280
talk about multi-dimensional arrays

00:02:53,280 --> 00:02:57,599
while mathematics they refer to very

00:02:55,280 --> 00:03:00,959
specific type of objects

00:02:57,599 --> 00:03:03,840
with a certain with certain properties

00:03:00,959 --> 00:03:05,120
so that being said in the rest of the

00:03:03,840 --> 00:03:07,599
talk i will talk about

00:03:05,120 --> 00:03:08,159
mutant venture arrays and then we will

00:03:07,599 --> 00:03:10,319
to not

00:03:08,159 --> 00:03:12,480
dig into the these problems of

00:03:10,319 --> 00:03:14,720
vocabulary

00:03:12,480 --> 00:03:15,680
so we have these objects and these

00:03:14,720 --> 00:03:18,480
objects

00:03:15,680 --> 00:03:19,840
are used in many many different areas

00:03:18,480 --> 00:03:23,040
one of them for example

00:03:19,840 --> 00:03:25,840
is video games when you want to

00:03:23,040 --> 00:03:26,480
when you want to implement anything that

00:03:25,840 --> 00:03:29,519
has to do with

00:03:26,480 --> 00:03:31,519
graphics and or anything that has to do

00:03:29,519 --> 00:03:34,000
with a physics engine

00:03:31,519 --> 00:03:35,040
that may be very useful to have vectors

00:03:34,000 --> 00:03:38,720
and matrices

00:03:35,040 --> 00:03:42,400
or at least multi-dimensional rays

00:03:38,720 --> 00:03:44,640
the other one another area

00:03:42,400 --> 00:03:46,080
where linear algebra can be very useful

00:03:44,640 --> 00:03:49,920
is science

00:03:46,080 --> 00:03:52,640
and on my on my side

00:03:49,920 --> 00:03:53,599
i am working in astrophysics and in

00:03:52,640 --> 00:03:57,280
mathematics

00:03:53,599 --> 00:03:58,400
and i'm trying to use a set of algorithm

00:03:57,280 --> 00:04:01,840
called

00:03:58,400 --> 00:04:05,040
optimal transport in order to

00:04:01,840 --> 00:04:06,400
see how we can guess the initial

00:04:05,040 --> 00:04:09,920
conditions

00:04:06,400 --> 00:04:12,560
uh to form like we take cosmical

00:04:09,920 --> 00:04:15,040
simulations of formation of galaxies

00:04:12,560 --> 00:04:16,000
galaxy formations and then we try to use

00:04:15,040 --> 00:04:19,280
computational relative

00:04:16,000 --> 00:04:22,400
transport to see where they were before

00:04:19,280 --> 00:04:23,280
the time and if that works then that

00:04:22,400 --> 00:04:26,560
gives us

00:04:23,280 --> 00:04:29,440
insights when we will apply them to

00:04:26,560 --> 00:04:29,919
real data to understand what has been

00:04:29,440 --> 00:04:33,280
going on

00:04:29,919 --> 00:04:36,080
in the past and to do that

00:04:33,280 --> 00:04:37,360
contrary to video games where the most

00:04:36,080 --> 00:04:40,320
needed are generally

00:04:37,360 --> 00:04:40,800
very small arrays and to have a lot of

00:04:40,320 --> 00:04:44,320
them

00:04:40,800 --> 00:04:44,720
and have them very fast in my case i may

00:04:44,320 --> 00:04:47,759
have

00:04:44,720 --> 00:04:49,280
up to six dimensional dynamic rays with

00:04:47,759 --> 00:04:51,600
billions of elements

00:04:49,280 --> 00:04:53,600
so even though the constraints are a

00:04:51,600 --> 00:04:57,440
little bit different

00:04:53,600 --> 00:04:58,639
than for video games all of that

00:04:57,440 --> 00:05:01,520
are kind of the same thing in

00:04:58,639 --> 00:05:05,520
mathematics basically

00:05:01,520 --> 00:05:10,080
vectors mattresses and how do we

00:05:05,520 --> 00:05:13,199
operate with them as fast as possible

00:05:10,080 --> 00:05:15,600
so linear algebra as you know is

00:05:13,199 --> 00:05:16,720
everywhere we could find many other

00:05:15,600 --> 00:05:19,280
examples

00:05:16,720 --> 00:05:20,560
and uh i will stop the introduction here

00:05:19,280 --> 00:05:24,000
because i don't think it's

00:05:20,560 --> 00:05:27,520
necessary to uh to highlight why

00:05:24,000 --> 00:05:31,039
it's useful to to do that

00:05:27,520 --> 00:05:34,800
so that being said in the surface 20

00:05:31,039 --> 00:05:38,800
we still don't have a standard

00:05:34,800 --> 00:05:42,080
way to invest our library to deal

00:05:38,800 --> 00:05:45,360
with mutual dimensional rate and

00:05:42,080 --> 00:05:48,240
start a stood matrix

00:05:45,360 --> 00:05:49,120
is a long-term goal that we may have but

00:05:48,240 --> 00:05:52,320
for now

00:05:49,120 --> 00:05:56,479
even though a lot of of other language

00:05:52,320 --> 00:05:58,560
have that we don't have it in services

00:05:56,479 --> 00:06:00,639
however there has been over the last few

00:05:58,560 --> 00:06:04,560
years quite a lot of efforts

00:06:00,639 --> 00:06:04,560
done in that direction

00:06:05,199 --> 00:06:11,759
one one item of this effort

00:06:08,479 --> 00:06:14,800
has been the work on md span and

00:06:11,759 --> 00:06:18,160
and related uh and holiday things

00:06:14,800 --> 00:06:21,120
so fd span is a non-only

00:06:18,160 --> 00:06:21,759
dimensional ray reference let's say you

00:06:21,120 --> 00:06:25,120
have

00:06:21,759 --> 00:06:26,880
a block of memory that's a linear block

00:06:25,120 --> 00:06:28,639
of memory and you

00:06:26,880 --> 00:06:30,560
are interested in seeing that block of

00:06:28,639 --> 00:06:32,960
memory as a

00:06:30,560 --> 00:06:34,080
multi-dimensional thing so that will

00:06:32,960 --> 00:06:37,680
that the function on t

00:06:34,080 --> 00:06:39,840
and hispanic is trying to provide and uh

00:06:37,680 --> 00:06:41,360
related to this proposal there has been

00:06:39,840 --> 00:06:44,160
a nd array

00:06:41,360 --> 00:06:44,880
proposed recently uh that kind of extend

00:06:44,160 --> 00:06:48,080
that

00:06:44,880 --> 00:06:51,199
to um to deal with

00:06:48,080 --> 00:06:52,479
memory education and everything so

00:06:51,199 --> 00:06:52,880
that's one thing and that's probably the

00:06:52,479 --> 00:06:54,639
most

00:06:52,880 --> 00:06:56,400
advanced proposal so far in that

00:06:54,639 --> 00:07:00,240
direction

00:06:56,400 --> 00:07:01,440
another another thing is our papers on

00:07:00,240 --> 00:07:04,000
linear algebra

00:07:01,440 --> 00:07:05,280
in general so the committee has been

00:07:04,000 --> 00:07:08,400
reviewing papers

00:07:05,280 --> 00:07:10,880
about what would be needed by the

00:07:08,400 --> 00:07:12,479
by the community what is needed by

00:07:10,880 --> 00:07:15,360
application

00:07:12,479 --> 00:07:15,759
and uh and there has been a proposal

00:07:15,360 --> 00:07:18,160
that

00:07:15,759 --> 00:07:19,680
try to focus on the higher level view of

00:07:18,160 --> 00:07:22,080
things

00:07:19,680 --> 00:07:22,720
the long-term goal being to be able to

00:07:22,080 --> 00:07:25,599
have

00:07:22,720 --> 00:07:26,880
a standard matrix in the in the same

00:07:25,599 --> 00:07:30,160
space standard

00:07:26,880 --> 00:07:33,039
as in the vast majority of other

00:07:30,160 --> 00:07:33,039
programming language

00:07:33,199 --> 00:07:40,560
another effort has been also

00:07:36,960 --> 00:07:43,360
quite recent and trying to bring

00:07:40,560 --> 00:07:45,520
the blas the basic linear algebra

00:07:43,360 --> 00:07:48,560
programs which are very efficient

00:07:45,520 --> 00:07:51,520
routines to do linear java operation

00:07:48,560 --> 00:07:52,879
to the surface plus these these routines

00:07:51,520 --> 00:07:55,280
have been tested have been

00:07:52,879 --> 00:07:57,039
tested and optimized for years and we

00:07:55,280 --> 00:07:59,120
still don't have ways to

00:07:57,039 --> 00:08:01,440
to deal with them in service so there

00:07:59,120 --> 00:08:01,440
has been

00:08:02,160 --> 00:08:08,160
investigation in that in that direction

00:08:05,440 --> 00:08:09,599
and finally there has been also some

00:08:08,160 --> 00:08:12,639
papers on

00:08:09,599 --> 00:08:15,840
different requirements or

00:08:12,639 --> 00:08:17,520
some trying to investigate the proper

00:08:15,840 --> 00:08:20,080
vocabulary to use for this

00:08:17,520 --> 00:08:20,960
for this object in order to standardize

00:08:20,080 --> 00:08:24,400
something

00:08:20,960 --> 00:08:28,960
that would be reliable and solid as

00:08:24,400 --> 00:08:28,960
we like to do in surplus

00:08:29,919 --> 00:08:35,839
mt span is for now the name that

00:08:33,360 --> 00:08:37,039
is that is used however several

00:08:35,839 --> 00:08:40,640
competing names

00:08:37,039 --> 00:08:43,839
were we are given

00:08:40,640 --> 00:08:46,880
uh like psy array numerica

00:08:43,839 --> 00:08:50,000
vla ray multi-dimensional array

00:08:46,880 --> 00:08:53,279
multi-tin array md array which is

00:08:50,000 --> 00:08:56,160
the the pattern md that has been uh

00:08:53,279 --> 00:08:58,320
kept for now and will die right the

00:08:56,160 --> 00:09:00,399
problem with multi array is that we have

00:08:58,320 --> 00:09:02,720
already multiset and multi-mapping in

00:09:00,399 --> 00:09:04,959
surplus plus and in that context multi

00:09:02,720 --> 00:09:06,720
means a different thing some

00:09:04,959 --> 00:09:09,760
alternatives to that

00:09:06,720 --> 00:09:12,880
uh about the how to name these

00:09:09,760 --> 00:09:16,080
these objects uh would be to use

00:09:12,880 --> 00:09:19,760
nd as it exists already in peter

00:09:16,080 --> 00:09:20,880
in python and this would make sense

00:09:19,760 --> 00:09:23,839
because

00:09:20,880 --> 00:09:25,519
these objects are in practice and

00:09:23,839 --> 00:09:28,720
dimensional objects

00:09:25,519 --> 00:09:31,040
and and in that case is finite

00:09:28,720 --> 00:09:32,959
and is known at compile time and this is

00:09:31,040 --> 00:09:33,519
this is how these objects are sometimes

00:09:32,959 --> 00:09:36,320
called

00:09:33,519 --> 00:09:38,880
in math the other approach would be to

00:09:36,320 --> 00:09:42,320
name the things high pair array or

00:09:38,880 --> 00:09:44,240
with an underscore note because when

00:09:42,320 --> 00:09:45,519
we generalize things in higher

00:09:44,240 --> 00:09:48,880
dimensional space

00:09:45,519 --> 00:09:52,320
in mathematics we sometimes

00:09:48,880 --> 00:09:54,399
use the hyper prefix to to

00:09:52,320 --> 00:09:56,399
call the the results like we have

00:09:54,399 --> 00:09:58,959
hypercube psychospheres

00:09:56,399 --> 00:10:01,680
and higher dimensional mattresses are

00:09:58,959 --> 00:10:04,720
sometimes called hypermetrics

00:10:01,680 --> 00:10:07,680
but for now the proposal uh

00:10:04,720 --> 00:10:09,120
focused on has taken empty array but

00:10:07,680 --> 00:10:10,959
this might change before

00:10:09,120 --> 00:10:12,640
standardization i personally would

00:10:10,959 --> 00:10:17,040
prefer that it would change

00:10:12,640 --> 00:10:20,160
but but so

00:10:17,040 --> 00:10:22,320
that being said handling

00:10:20,160 --> 00:10:23,200
linear algebra and supplements is a very

00:10:22,320 --> 00:10:26,320
long-term

00:10:23,200 --> 00:10:27,680
and very complicated task and but the

00:10:26,320 --> 00:10:30,240
committee has been

00:10:27,680 --> 00:10:31,839
the the approach that has been far but

00:10:30,240 --> 00:10:33,680
investigated by the committee is the

00:10:31,839 --> 00:10:37,440
standardization by layer

00:10:33,680 --> 00:10:38,079
by standardizing first the most simple

00:10:37,440 --> 00:10:41,440
pieces

00:10:38,079 --> 00:10:43,040
and then building stuff on top of it

00:10:41,440 --> 00:10:45,680
so we would start by not earning

00:10:43,040 --> 00:10:48,160
reference to arrays like in this pan

00:10:45,680 --> 00:10:50,000
then there will be a brick of the blas

00:10:48,160 --> 00:10:51,440
for example with basic algorithm and

00:10:50,000 --> 00:10:53,680
operation

00:10:51,440 --> 00:10:54,880
on top of that we could build online

00:10:53,680 --> 00:10:58,480
race dealing with

00:10:54,880 --> 00:11:00,399
all the problems of memory location

00:10:58,480 --> 00:11:02,399
then on top of that we could have a

00:11:00,399 --> 00:11:03,680
library of of an ordered operator so

00:11:02,399 --> 00:11:06,880
that one could write

00:11:03,680 --> 00:11:08,560
my matrix one times my matrix two and

00:11:06,880 --> 00:11:10,399
the approach of times we do the right

00:11:08,560 --> 00:11:13,760
thing uh

00:11:10,399 --> 00:11:14,560
the right type of project and on top of

00:11:13,760 --> 00:11:16,720
that

00:11:14,560 --> 00:11:19,200
in the long term we could even add

00:11:16,720 --> 00:11:22,640
geometric geometric aspects

00:11:19,200 --> 00:11:24,560
um to deal with vectors and and spaces

00:11:22,640 --> 00:11:28,160
and stuff

00:11:24,560 --> 00:11:31,279
but this talk we will focus on

00:11:28,160 --> 00:11:34,640
the first layer

00:11:31,279 --> 00:11:37,440
and uh and see how we can make that how

00:11:34,640 --> 00:11:38,240
can try to make that as as simple

00:11:37,440 --> 00:11:41,120
powerful

00:11:38,240 --> 00:11:43,680
and as as possible using surprise

00:11:41,120 --> 00:11:43,680
specimens

00:11:44,079 --> 00:11:47,600
but before going further we need to take

00:11:46,320 --> 00:11:50,320
a look at

00:11:47,600 --> 00:11:51,839
what is currently in the in this

00:11:50,320 --> 00:11:54,720
proposal to see

00:11:51,839 --> 00:11:56,560
what are the different types of objects

00:11:54,720 --> 00:11:58,880
how they interact between each other

00:11:56,560 --> 00:12:00,320
how the things are specified to

00:11:58,880 --> 00:12:04,079
understand what

00:12:00,320 --> 00:12:04,880
anti-spam is how do we look to a zone of

00:12:04,079 --> 00:12:08,839
memory and

00:12:04,880 --> 00:12:12,240
interpret that as a multinational

00:12:08,839 --> 00:12:13,279
thing so the first thing the proposal

00:12:12,240 --> 00:12:16,399
described

00:12:13,279 --> 00:12:19,519
is a class

00:12:16,399 --> 00:12:23,120
a template class called extent

00:12:19,519 --> 00:12:27,279
and it takes as um as

00:12:23,120 --> 00:12:30,240
a viadic list of template parameter

00:12:27,279 --> 00:12:30,240
list of integers

00:12:30,480 --> 00:12:36,880
then there are layouts to specify

00:12:33,839 --> 00:12:40,800
layout mapping policies to specify how

00:12:36,880 --> 00:12:44,399
the dimensions are

00:12:40,800 --> 00:12:47,200
when the user write code how the

00:12:44,399 --> 00:12:47,839
substrate subscript operator is mapped

00:12:47,200 --> 00:12:50,639
to the

00:12:47,839 --> 00:12:51,279
internal memory representation dealing

00:12:50,639 --> 00:12:53,680
with

00:12:51,279 --> 00:12:55,760
raw major or color major problems for

00:12:53,680 --> 00:12:59,040
example

00:12:55,760 --> 00:13:02,320
then there is accessors that describe

00:12:59,040 --> 00:13:02,959
how to access and practice an element of

00:13:02,320 --> 00:13:06,000
memory

00:13:02,959 --> 00:13:09,600
or a group of elements

00:13:06,000 --> 00:13:09,600
in in memory

00:13:10,079 --> 00:13:17,600
and and then the other thing

00:13:13,920 --> 00:13:20,880
the last thing is a basic nd span

00:13:17,600 --> 00:13:23,760
that groups all these elements together

00:13:20,880 --> 00:13:24,320
with an element type for example double

00:13:23,760 --> 00:13:27,200
int

00:13:24,320 --> 00:13:28,079
or whatever then the extent to specify

00:13:27,200 --> 00:13:31,360
the shape

00:13:28,079 --> 00:13:34,800
the layout policy and the access outputs

00:13:31,360 --> 00:13:38,000
and for simple use cases

00:13:34,800 --> 00:13:41,120
the basic nd span

00:13:38,000 --> 00:13:41,920
is renamed nd spam when the only thing

00:13:41,120 --> 00:13:44,959
that matters

00:13:41,920 --> 00:13:49,760
is the the type element

00:13:44,959 --> 00:13:52,560
and the shape the shape of the thing

00:13:49,760 --> 00:13:54,240
um as a remark you can ask questions

00:13:52,560 --> 00:13:56,800
during during the coup talk and

00:13:54,240 --> 00:13:58,639
at the end of each part i will i will

00:13:56,800 --> 00:14:00,079
answer them so then the hd2 has

00:13:58,639 --> 00:14:03,600
questions and i will process

00:14:00,079 --> 00:14:07,920
them at the end of each part

00:14:03,600 --> 00:14:11,199
so that being said if we look closer to

00:14:07,920 --> 00:14:15,040
what a next tense class is

00:14:11,199 --> 00:14:19,279
so as i said before it takes a list of

00:14:15,040 --> 00:14:22,720
integers as as a valid list of integers

00:14:19,279 --> 00:14:22,720
as a template parameter

00:14:22,959 --> 00:14:30,160
it defines different constructors

00:14:27,440 --> 00:14:32,800
some of them nothing very surprising

00:14:30,160 --> 00:14:36,079
here some of them may construct

00:14:32,800 --> 00:14:40,160
an extent from another extent

00:14:36,079 --> 00:14:42,399
with different parameters

00:14:40,160 --> 00:14:44,000
there is assignment an assignment

00:14:42,399 --> 00:14:46,959
operator but nothing nothing

00:14:44,000 --> 00:14:49,360
very surprising and then there are

00:14:46,959 --> 00:14:52,079
different types of observer

00:14:49,360 --> 00:14:52,880
there is an observer to to to get the

00:14:52,079 --> 00:14:54,959
rank

00:14:52,880 --> 00:14:56,079
the number of dimension the

00:14:54,959 --> 00:14:59,120
multi-venture

00:14:56,079 --> 00:15:02,320
array we have and

00:14:59,120 --> 00:15:04,720
because these ranks can be either static

00:15:02,320 --> 00:15:05,760
specified at compile time for example i

00:15:04,720 --> 00:15:08,639
want this dimension

00:15:05,760 --> 00:15:10,320
of my array to be fixed and to and it's

00:15:08,639 --> 00:15:14,000
valid to p5

00:15:10,320 --> 00:15:16,560
or they can be dynamic in that case the

00:15:14,000 --> 00:15:17,360
the diamond the dimension could be

00:15:16,560 --> 00:15:21,199
resized

00:15:17,360 --> 00:15:24,639
during drawing during the course of

00:15:21,199 --> 00:15:25,519
the program so there is a wrong dynamic

00:15:24,639 --> 00:15:29,279
function to

00:15:25,519 --> 00:15:32,560
get what the number of dynamic axes

00:15:29,279 --> 00:15:35,600
are and then there is an extent

00:15:32,560 --> 00:15:36,320
without an s function that takes an

00:15:35,600 --> 00:15:39,680
index

00:15:36,320 --> 00:15:42,240
to query the

00:15:39,680 --> 00:15:44,079
size along a particular axis along a

00:15:42,240 --> 00:15:46,959
particular dimension

00:15:44,079 --> 00:15:48,320
uh so for example if you have a an array

00:15:46,959 --> 00:15:51,600
a multi-dimensional array

00:15:48,320 --> 00:15:53,839
with three dimension extent zero will

00:15:51,600 --> 00:15:54,720
return the size along the first axis

00:15:53,839 --> 00:15:58,240
will

00:15:54,720 --> 00:16:00,320
extend one along the second axis extra

00:15:58,240 --> 00:16:04,079
extra

00:16:00,320 --> 00:16:04,079
and finally there are some

00:16:04,720 --> 00:16:11,839
some exposition only parts to store

00:16:08,160 --> 00:16:11,839
the dynamic dynamic extent

00:16:14,880 --> 00:16:20,240
then there are the layouts so

00:16:17,920 --> 00:16:21,519
layouts are way to specify the mapping

00:16:20,240 --> 00:16:25,199
between the dimensions

00:16:21,519 --> 00:16:28,800
and the and the way things

00:16:25,199 --> 00:16:33,759
are are stored in turn

00:16:28,800 --> 00:16:36,959
so lay so layer layout left

00:16:33,759 --> 00:16:40,000
is so we have a layout left left layer

00:16:36,959 --> 00:16:43,440
right extracts the layer left

00:16:40,000 --> 00:16:44,880
this declares an internal class called

00:16:43,440 --> 00:16:47,839
mapping

00:16:44,880 --> 00:16:49,360
with several constructors an assignment

00:16:47,839 --> 00:16:52,880
nothing surprising here

00:16:49,360 --> 00:16:56,639
it takes a neck stance as

00:16:52,880 --> 00:17:00,000
to be built and then

00:16:56,639 --> 00:17:03,360
there it defines

00:17:00,000 --> 00:17:06,880
ways to access the extent

00:17:03,360 --> 00:17:10,640
and to access uh specific things

00:17:06,880 --> 00:17:10,640
uh given a set of indices

00:17:11,120 --> 00:17:16,799
and then there are ways to query the

00:17:14,559 --> 00:17:18,640
the way things are represented in memory

00:17:16,799 --> 00:17:21,199
to ask whether

00:17:18,640 --> 00:17:23,679
things are unique contiguous or strided

00:17:21,199 --> 00:17:27,120
in memory to have a feeling of

00:17:23,679 --> 00:17:30,000
how things are are stored and how we may

00:17:27,120 --> 00:17:30,000
operate on them

00:17:30,799 --> 00:17:37,760
and the mapping stores the extents

00:17:34,240 --> 00:17:40,880
it has been given at construction

00:17:37,760 --> 00:17:44,559
and using that way of specifying things

00:17:40,880 --> 00:17:47,200
it's it's possible to uh to define

00:17:44,559 --> 00:17:48,240
all kinds of mapping between the between

00:17:47,200 --> 00:17:51,360
the

00:17:48,240 --> 00:17:54,799
the the api and the way things are

00:17:51,360 --> 00:17:57,840
are stored in mirror then

00:17:54,799 --> 00:18:01,120
there is the accessor so accessor is

00:17:57,840 --> 00:18:04,960
just it's a very simple class

00:18:01,120 --> 00:18:08,160
to access things um

00:18:04,960 --> 00:18:09,520
to access things in in memory uh and to

00:18:08,160 --> 00:18:12,400
access

00:18:09,520 --> 00:18:13,760
different elements and so either one

00:18:12,400 --> 00:18:17,360
element or different

00:18:13,760 --> 00:18:17,360
elements at the same time

00:18:17,919 --> 00:18:21,200
and finally the empty span that combines

00:18:20,320 --> 00:18:24,240
all these

00:18:21,200 --> 00:18:28,799
things together so

00:18:24,240 --> 00:18:32,240
it defines a few types

00:18:28,799 --> 00:18:36,799
then it has some constructors that takes

00:18:32,240 --> 00:18:40,480
a pointer and an input and

00:18:36,799 --> 00:18:43,280
dynamic extents or a mapping type

00:18:40,480 --> 00:18:44,400
or a pointer mapping type an accessor or

00:18:43,280 --> 00:18:46,559
extra extra

00:18:44,400 --> 00:18:47,679
yeah the only thing to remember here is

00:18:46,559 --> 00:18:52,160
that it combines

00:18:47,679 --> 00:18:55,440
all these all these elements um to

00:18:52,160 --> 00:18:57,760
in a view in a multi-dimensional view on

00:18:55,440 --> 00:18:59,600
things

00:18:57,760 --> 00:19:00,799
and there are some assignment

00:18:59,600 --> 00:19:03,840
preparatorials

00:19:00,799 --> 00:19:06,880
again nothing surprising here

00:19:03,840 --> 00:19:10,480
and operators

00:19:06,880 --> 00:19:14,160
to access the the elements

00:19:10,480 --> 00:19:16,480
so there is an operator here to

00:19:14,160 --> 00:19:17,600
to get a reference with that takes only

00:19:16,480 --> 00:19:19,360
one index

00:19:17,600 --> 00:19:21,520
and there are there is an operator that

00:19:19,360 --> 00:19:23,600
takes several diseases to access tracks

00:19:21,520 --> 00:19:25,760
of the elements

00:19:23,600 --> 00:19:27,840
and there is also a version that takes

00:19:25,760 --> 00:19:31,280
an array of indices

00:19:27,840 --> 00:19:32,320
to access the elements specified by the

00:19:31,280 --> 00:19:38,480
different indices

00:19:32,320 --> 00:19:41,600
in the end dimension of the md span

00:19:38,480 --> 00:19:42,720
and finally in always in the still in

00:19:41,600 --> 00:19:46,080
the same class

00:19:42,720 --> 00:19:47,600
there is a way to uh to access the

00:19:46,080 --> 00:19:51,440
accessor

00:19:47,600 --> 00:19:54,000
and to access the different properties

00:19:51,440 --> 00:19:54,720
different internal properties of the fm

00:19:54,000 --> 00:19:57,919
display

00:19:54,720 --> 00:20:01,760
basically copying information

00:19:57,919 --> 00:20:03,200
that are handled by either the external

00:20:01,760 --> 00:20:06,400
policy or

00:20:03,200 --> 00:20:09,919
access offers

00:20:06,400 --> 00:20:12,799
um and i think that's that's it for the

00:20:09,919 --> 00:20:12,799
for the most part

00:20:13,360 --> 00:20:19,200
so if we summarize what's interesting

00:20:16,640 --> 00:20:21,280
and the like the main contribution to

00:20:19,200 --> 00:20:25,919
the design proposal

00:20:21,280 --> 00:20:28,960
is has been to define an api

00:20:25,919 --> 00:20:32,000
to propose nd stand as the product

00:20:28,960 --> 00:20:34,080
of an element type an extent that

00:20:32,000 --> 00:20:34,960
describes the shape of the mention of

00:20:34,080 --> 00:20:36,720
the multi

00:20:34,960 --> 00:20:39,520
multi-dimensional things we are looking

00:20:36,720 --> 00:20:40,640
at but they have a policy to specify the

00:20:39,520 --> 00:20:43,120
mapping

00:20:40,640 --> 00:20:44,720
and an accessor spell policy to specify

00:20:43,120 --> 00:20:48,559
how individual and continuous

00:20:44,720 --> 00:20:52,159
elements can be accessed in male

00:20:48,559 --> 00:20:53,039
um and that is a huge effort but to be

00:20:52,159 --> 00:20:55,840
able to

00:20:53,039 --> 00:20:58,080
to divide the parameter space in these

00:20:55,840 --> 00:20:58,880
and to concentrate the parameter space

00:20:58,080 --> 00:21:00,960
with these

00:20:58,880 --> 00:21:04,480
four things it has been quite a lot of

00:21:00,960 --> 00:21:04,480
effort from from the authors

00:21:05,360 --> 00:21:08,480
and honestly i find they're they're

00:21:07,679 --> 00:21:10,880
working

00:21:08,480 --> 00:21:11,679
amazing so far and it's very i'm very

00:21:10,880 --> 00:21:15,039
excited by

00:21:11,679 --> 00:21:19,520
by what will follow however

00:21:15,039 --> 00:21:22,640
the as one of the

00:21:19,520 --> 00:21:25,600
lowest uh layer of thing

00:21:22,640 --> 00:21:28,000
uh this proposal uh has some

00:21:25,600 --> 00:21:30,320
simplification

00:21:28,000 --> 00:21:31,520
it is non-owning meaning that all the

00:21:30,320 --> 00:21:35,280
problems

00:21:31,520 --> 00:21:36,080
of uh declaring memory and to allocating

00:21:35,280 --> 00:21:39,600
memory

00:21:36,080 --> 00:21:41,520
are not handled by this and it's not a

00:21:39,600 --> 00:21:44,960
problem but it just means that

00:21:41,520 --> 00:21:48,480
for an md array it would be necessary to

00:21:44,960 --> 00:21:51,440
um to design and to see how

00:21:48,480 --> 00:21:54,240
um how allocators will interact with the

00:21:51,440 --> 00:21:56,240
already defined file parameters

00:21:54,240 --> 00:21:57,440
and it has been designed for continuous

00:21:56,240 --> 00:22:00,159
memory storage for now

00:21:57,440 --> 00:22:02,240
there is no there is no retaliation on

00:22:00,159 --> 00:22:06,240
iterators and then there is no way

00:22:02,240 --> 00:22:09,520
of basically iterating

00:22:06,240 --> 00:22:09,520
on on these things

00:22:11,280 --> 00:22:16,240
so given the current state of the

00:22:15,200 --> 00:22:19,360
proposal

00:22:16,240 --> 00:22:22,720
the way one medicare may declare

00:22:19,360 --> 00:22:24,840
an nd span is the

00:22:22,720 --> 00:22:27,360
what is shown on the second line of the

00:22:24,840 --> 00:22:29,919
proposal so

00:22:27,360 --> 00:22:30,640
should the md span of the element type

00:22:29,919 --> 00:22:34,159
like double

00:22:30,640 --> 00:22:36,559
and then the extents where

00:22:34,159 --> 00:22:38,400
every dimension can be either a number

00:22:36,559 --> 00:22:41,600
or stainless steel

00:22:38,400 --> 00:22:44,720
however dynamic extent is defined

00:22:41,600 --> 00:22:47,520
as um minus one

00:22:44,720 --> 00:22:50,000
and this may cause problem um because

00:22:47,520 --> 00:22:53,039
this is a very old-school thing

00:22:50,000 --> 00:22:57,600
old-school way of doing things

00:22:53,039 --> 00:23:00,799
and um and that's

00:22:57,600 --> 00:23:03,919
have some risks that yeah

00:23:00,799 --> 00:23:07,120
and this syntax

00:23:03,919 --> 00:23:08,640
is i must say pretty heavy

00:23:07,120 --> 00:23:10,240
like when you have three dimensions it's

00:23:08,640 --> 00:23:12,159
okay but when you start to have a lot of

00:23:10,240 --> 00:23:14,799
dimensions and when you have a code that

00:23:12,159 --> 00:23:16,559
deal with a lot of different types of

00:23:14,799 --> 00:23:19,760
arrays with different dimensions

00:23:16,559 --> 00:23:22,799
specifying things in that way is uh

00:23:19,760 --> 00:23:26,159
requires a lot of characters to detect

00:23:22,799 --> 00:23:29,679
and not very easy to to read

00:23:26,159 --> 00:23:34,159
and in the early age of the proposal

00:23:29,679 --> 00:23:34,159
the team behind the proposal wanted to

00:23:34,240 --> 00:23:37,280
allow a different a different a

00:23:36,720 --> 00:23:40,880
different

00:23:37,280 --> 00:23:45,679
way of specif specifying thing as

00:23:40,880 --> 00:23:47,919
proposed by p0332

00:23:45,679 --> 00:23:49,520
a proposal called relaxed incomplete

00:23:47,919 --> 00:23:52,960
multiplication or

00:23:49,520 --> 00:23:54,480
declaration and if we had that we could

00:23:52,960 --> 00:23:58,799
specify things in the

00:23:54,480 --> 00:24:00,559
most in the more elegant way

00:23:58,799 --> 00:24:02,080
to describe why dimensions are fixed and

00:24:00,559 --> 00:24:05,840
what dimensions are

00:24:02,080 --> 00:24:06,960
um are dynamic for now in surplus only

00:24:05,840 --> 00:24:09,760
the first

00:24:06,960 --> 00:24:12,240
one of the two is a load and but the

00:24:09,760 --> 00:24:14,880
second one cannot have alternating

00:24:12,240 --> 00:24:16,159
uh fixed and dynamic dimension the dying

00:24:14,880 --> 00:24:21,840
dimension has to be

00:24:16,159 --> 00:24:21,840
has to be the first uh the first one

00:24:21,919 --> 00:24:25,360
the library evolution working group in

00:24:23,520 --> 00:24:27,120
the committee was largely in favor of

00:24:25,360 --> 00:24:29,840
the syntax however

00:24:27,120 --> 00:24:31,760
the evolution working group was a guest

00:24:29,840 --> 00:24:35,679
against this language change

00:24:31,760 --> 00:24:38,720
because it had unintended side effects

00:24:35,679 --> 00:24:41,760
in different areas of the language

00:24:38,720 --> 00:24:43,679
and to just allow this functionality by

00:24:41,760 --> 00:24:46,480
a core long way change

00:24:43,679 --> 00:24:47,200
this could trigger suddenly a lot of

00:24:46,480 --> 00:24:50,880
complete

00:24:47,200 --> 00:24:53,760
unintended power another problem

00:24:50,880 --> 00:24:53,760
was that

00:24:54,080 --> 00:25:00,720
was the one of zero sized array because

00:24:58,400 --> 00:25:01,840
it's currently not allowed in in

00:25:00,720 --> 00:25:04,880
standard c and so

00:25:01,840 --> 00:25:08,400
on c plus to specify zero

00:25:04,880 --> 00:25:10,320
as as a dimension however

00:25:08,400 --> 00:25:12,000
stood array allows zero dimensional

00:25:10,320 --> 00:25:17,520
array by

00:25:12,000 --> 00:25:20,559
combining a special case and it could be

00:25:17,520 --> 00:25:22,880
uh for people who do mathematics um

00:25:20,559 --> 00:25:25,279
as a generalization it would be really

00:25:22,880 --> 00:25:28,240
nice to have a way to specify that

00:25:25,279 --> 00:25:28,880
uh that we are dealing with the arrow

00:25:28,240 --> 00:25:33,120
with a

00:25:28,880 --> 00:25:36,799
zero dimensional array along one axis

00:25:33,120 --> 00:25:42,640
and even if p052 was analyzed

00:25:36,799 --> 00:25:45,279
we still would have no way of doing that

00:25:42,640 --> 00:25:46,000
so that being said the point of this

00:25:45,279 --> 00:25:50,000
talk

00:25:46,000 --> 00:25:53,200
is to focus on how we can

00:25:50,000 --> 00:25:55,200
obtain um obtain

00:25:53,200 --> 00:25:56,480
specify the shape of my

00:25:55,200 --> 00:25:59,200
multi-dimensional arrays

00:25:56,480 --> 00:26:00,240
in in a nice way and the compact way and

00:25:59,200 --> 00:26:02,640
the way that would be

00:26:00,240 --> 00:26:05,120
readable and really and that would be

00:26:02,640 --> 00:26:06,960
easy to manipulate

00:26:05,120 --> 00:26:09,360
the goal is to obtain something that is

00:26:06,960 --> 00:26:11,200
generic so that we can cover as much as

00:26:09,360 --> 00:26:14,000
possible of the bar method space

00:26:11,200 --> 00:26:16,000
something that is high performance both

00:26:14,000 --> 00:26:17,840
in terms of counting time and memory and

00:26:16,000 --> 00:26:19,039
something that is very expressive that

00:26:17,840 --> 00:26:22,960
is easy to understand

00:26:19,039 --> 00:26:25,760
is to read and easy to write and concise

00:26:22,960 --> 00:26:27,760
so regarding the question uh i may take

00:26:25,760 --> 00:26:30,640
some of them at the end of the talk

00:26:27,760 --> 00:26:31,840
but some of the questions that has been

00:26:30,640 --> 00:26:33,760
asked are

00:26:31,840 --> 00:26:36,159
what are the discussion between metal

00:26:33,760 --> 00:26:40,400
emotion rays and tensors

00:26:36,159 --> 00:26:41,840
so that's a ton so has to ensure that

00:26:40,400 --> 00:26:44,320
some properties

00:26:41,840 --> 00:26:46,400
uh are concerned while a

00:26:44,320 --> 00:26:48,080
multi-dimensional arrays

00:26:46,400 --> 00:26:49,600
like it's also informationally a

00:26:48,080 --> 00:26:53,279
geometric object

00:26:49,600 --> 00:26:56,320
and we may look at this chord at

00:26:53,279 --> 00:26:57,840
the coordinates of the tensor uh the

00:26:56,320 --> 00:27:00,000
coordinate of the tensor in the

00:26:57,840 --> 00:27:01,919
particular base

00:27:00,000 --> 00:27:03,440
is a mutant controller same thing for

00:27:01,919 --> 00:27:05,760
vector a vector

00:27:03,440 --> 00:27:07,279
we may look at the coordinates but the

00:27:05,760 --> 00:27:09,919
coordinates of the vector is not the

00:27:07,279 --> 00:27:11,679
vector itself

00:27:09,919 --> 00:27:13,279
uh why are the completed extents

00:27:11,679 --> 00:27:16,000
parameter ptr of t

00:27:13,279 --> 00:27:17,440
instead of size t so that's a long

00:27:16,000 --> 00:27:20,720
debate

00:27:17,440 --> 00:27:21,440
if you if you don't agree write to the

00:27:20,720 --> 00:27:25,200
committee

00:27:21,440 --> 00:27:27,919
i that's a detailed implementation

00:27:25,200 --> 00:27:29,279
uh having just i t seemed not enough

00:27:27,919 --> 00:27:32,399
what if you want to specify

00:27:29,279 --> 00:27:34,880
alignment uh so i notice

00:27:32,399 --> 00:27:35,600
i didn't write the ambison proposal but

00:27:34,880 --> 00:27:38,799
i think

00:27:35,600 --> 00:27:42,159
this is handled by the layout policy

00:27:38,799 --> 00:27:45,279
um this must be checked because again

00:27:42,159 --> 00:27:48,080
i'm i'm a simple user of the event

00:27:45,279 --> 00:27:51,600
design i'm not a nuclear matter

00:27:48,080 --> 00:27:53,440
um ygb a special extent

00:27:51,600 --> 00:27:54,720
name for what is basically some kind of

00:27:53,440 --> 00:27:58,080
ray

00:27:54,720 --> 00:28:00,880
uh because of the thing i i

00:27:58,080 --> 00:28:01,279
explained before which is the fact that

00:28:00,880 --> 00:28:04,799
uh

00:28:01,279 --> 00:28:06,960
we may have to we may want to specify um

00:28:04,799 --> 00:28:09,440
to specify dynamic dimension or static

00:28:06,960 --> 00:28:11,360
dimension

00:28:09,440 --> 00:28:12,480
question 6 how do you create interactors

00:28:11,360 --> 00:28:16,000
of little rays

00:28:12,480 --> 00:28:18,640
for now there is no mutant emotional

00:28:16,000 --> 00:28:21,760
characters including the proposal

00:28:18,640 --> 00:28:23,520
um when troy has seen question eight

00:28:21,760 --> 00:28:24,799
when traversing multinational race can

00:28:23,520 --> 00:28:29,279
you preserve the concept of

00:28:24,799 --> 00:28:29,279
left right i think so

00:28:29,520 --> 00:28:33,360
then when you traverse the material

00:28:31,279 --> 00:28:34,960
already you foresee using spacing curves

00:28:33,360 --> 00:28:36,000
as a mechanism for if you're interested

00:28:34,960 --> 00:28:38,559
in the array

00:28:36,000 --> 00:28:40,000
that should be very interesting uh i

00:28:38,559 --> 00:28:42,559
don't know if that can be currently

00:28:40,000 --> 00:28:45,679
specified in terms of layout

00:28:42,559 --> 00:28:46,480
but once we have multi-dimensional

00:28:45,679 --> 00:28:49,760
iterators

00:28:46,480 --> 00:28:51,760
in the file in in the in the long future

00:28:49,760 --> 00:28:52,880
this would definitely be something that

00:28:51,760 --> 00:28:56,000
could be uh

00:28:52,880 --> 00:28:56,559
that could be very interesting for to

00:28:56,000 --> 00:29:01,279
operate

00:28:56,559 --> 00:29:01,279
on these arrays for now it's just

00:29:01,840 --> 00:29:08,559
any span are just views and contiguous

00:29:05,120 --> 00:29:11,520
memory spaces

00:29:08,559 --> 00:29:12,480
um and i think that's all the questions

00:29:11,520 --> 00:29:15,520
i will take for

00:29:12,480 --> 00:29:15,520
for now so

00:29:17,840 --> 00:29:22,080
again we are so we want a nice way to

00:29:21,440 --> 00:29:25,120
specify

00:29:22,080 --> 00:29:27,440
shapes of interdimensional weight um

00:29:25,120 --> 00:29:29,440
so we want something generic performance

00:29:27,440 --> 00:29:31,279
and expressive

00:29:29,440 --> 00:29:32,880
and the problem is that it's very hard

00:29:31,279 --> 00:29:36,159
to have the same

00:29:32,880 --> 00:29:38,399
the same uh have everything at the same

00:29:36,159 --> 00:29:40,320
time

00:29:38,399 --> 00:29:42,480
and in that complex identifying software

00:29:40,320 --> 00:29:43,760
architecture as the way of balancing and

00:29:42,480 --> 00:29:45,440
compromising between

00:29:43,760 --> 00:29:48,159
the generosity the performance and the

00:29:45,440 --> 00:29:48,159
expressivity

00:29:48,720 --> 00:29:55,360
so if in that regard

00:29:52,720 --> 00:29:56,799
it's interesting to i think this way of

00:29:55,360 --> 00:29:58,559
looking at things is interesting to

00:29:56,799 --> 00:30:01,520
understand why c plus plus

00:29:58,559 --> 00:30:03,760
still has the standard metrics in in

00:30:01,520 --> 00:30:07,120
2020.

00:30:03,760 --> 00:30:10,399
when people focus only on only one axis

00:30:07,120 --> 00:30:13,200
for example focusing on expressivity

00:30:10,399 --> 00:30:14,399
the problem collapses and it's far far

00:30:13,200 --> 00:30:17,039
far easier to

00:30:14,399 --> 00:30:17,679
solve and for his opinion high level

00:30:17,039 --> 00:30:19,120
language

00:30:17,679 --> 00:30:20,880
you don't care that much you may not

00:30:19,120 --> 00:30:23,919
care that much about performance

00:30:20,880 --> 00:30:26,880
or generosity

00:30:23,919 --> 00:30:29,440
and this may be hidden in lower layers

00:30:26,880 --> 00:30:32,720
of your language

00:30:29,440 --> 00:30:33,919
focusing on two axes of the optimization

00:30:32,720 --> 00:30:37,120
space

00:30:33,919 --> 00:30:37,919
still lead to a reasonable level of

00:30:37,120 --> 00:30:39,440
complexity

00:30:37,919 --> 00:30:41,039
for example if you only focus on

00:30:39,440 --> 00:30:43,440
performance and expressivity

00:30:41,039 --> 00:30:44,399
and leave the generosity alone by only

00:30:43,440 --> 00:30:48,080
providing

00:30:44,399 --> 00:30:51,440
one single type it's relativity

00:30:48,080 --> 00:30:55,120
it's relatively easy to do

00:30:51,440 --> 00:30:57,519
but when one wants to address the three

00:30:55,120 --> 00:30:59,440
axes at the same time

00:30:57,519 --> 00:31:01,120
this is what makes the design a real

00:30:59,440 --> 00:31:03,039
challenge and in simplest person in the

00:31:01,120 --> 00:31:06,399
stone library we are aiming for these

00:31:03,039 --> 00:31:06,399
three things at the same time

00:31:06,720 --> 00:31:10,559
this is one of the main reason i think

00:31:09,039 --> 00:31:14,399
that we still have no

00:31:10,559 --> 00:31:14,399
stumbling matrix in 2020.

00:31:14,640 --> 00:31:22,080
ideally if everything was possible

00:31:18,799 --> 00:31:24,480
what we would like for an

00:31:22,080 --> 00:31:26,720
n dimensional array and specifically

00:31:24,480 --> 00:31:30,880
what would we like to specify

00:31:26,720 --> 00:31:30,880
the dimension of the n dimension

00:31:31,200 --> 00:31:34,559
in terms of expressivity we would like

00:31:33,200 --> 00:31:37,200
something we

00:31:34,559 --> 00:31:38,399
would like something very concise uh

00:31:37,200 --> 00:31:41,840
where you could

00:31:38,399 --> 00:31:43,600
specify in a concise way the dimensions

00:31:41,840 --> 00:31:44,159
that are fixed the dimensions that are

00:31:43,600 --> 00:31:48,159
generated

00:31:44,159 --> 00:31:50,799
that are dynamic in arbitrary orders

00:31:48,159 --> 00:31:54,320
and everything would be easy to read

00:31:50,799 --> 00:31:56,480
easy to write and easy to understand

00:31:54,320 --> 00:31:58,880
in terms of performance we are looking

00:31:56,480 --> 00:32:02,240
for something that will have

00:31:58,880 --> 00:32:03,600
no overhead compared to home crafted

00:32:02,240 --> 00:32:06,159
solution

00:32:03,600 --> 00:32:09,120
that would be optimized and designed for

00:32:06,159 --> 00:32:09,120
specific scenarios

00:32:09,360 --> 00:32:16,799
it exists some libraries exist for um

00:32:13,200 --> 00:32:19,919
for multi-dimensional arrays of time

00:32:16,799 --> 00:32:21,200
of round two of rank one of round three

00:32:19,919 --> 00:32:23,519
here we want to maintain the highest

00:32:21,200 --> 00:32:26,799
possible level of performance regardless

00:32:23,519 --> 00:32:30,080
of the of the rank of the

00:32:26,799 --> 00:32:31,519
uh n-dimensional way and in terms of

00:32:30,080 --> 00:32:33,919
generosity

00:32:31,519 --> 00:32:35,760
we like to have arbitrary more layouts

00:32:33,919 --> 00:32:39,840
arbitrary indexing schemes

00:32:35,760 --> 00:32:42,960
arbitrary finite ranks from one to

00:32:39,840 --> 00:32:44,000
a lot combinations of static and dynamic

00:32:42,960 --> 00:32:47,200
dimensions

00:32:44,000 --> 00:32:50,320
and zero size case

00:32:47,200 --> 00:32:53,519
so the challenge

00:32:50,320 --> 00:32:55,360
is to find a way

00:32:53,519 --> 00:32:57,840
to have all these things at the same

00:32:55,360 --> 00:32:58,640
time explosivity performance and

00:32:57,840 --> 00:33:00,720
generosity

00:32:58,640 --> 00:33:03,360
and that is what the star library is

00:33:00,720 --> 00:33:03,360
looking for

00:33:04,159 --> 00:33:08,880
thankfully we now have surface 20

00:33:07,360 --> 00:33:11,840
and when people are doing a lot of

00:33:08,880 --> 00:33:11,840
template programming

00:33:12,159 --> 00:33:19,440
realized what surplus plus 20

00:33:16,320 --> 00:33:20,399
was giving to them they probably saw

00:33:19,440 --> 00:33:22,480
something like this

00:33:20,399 --> 00:33:23,440
i know people who saw something like

00:33:22,480 --> 00:33:27,120
this

00:33:23,440 --> 00:33:30,320
and in the meantime they were like

00:33:27,120 --> 00:33:33,679
hey did anyone notice

00:33:30,320 --> 00:33:34,480
the how this could go wrong and i must

00:33:33,679 --> 00:33:38,320
admit that

00:33:34,480 --> 00:33:41,039
i was one of these people because

00:33:38,320 --> 00:33:41,760
surface plus 20 is bringing something

00:33:41,039 --> 00:33:44,880
that

00:33:41,760 --> 00:33:48,720
is highly highly highly useful to

00:33:44,880 --> 00:33:52,159
do the kind of thing i described before

00:33:48,720 --> 00:33:55,679
it basically bring an atomic weapon

00:33:52,159 --> 00:33:59,600
to do that and this is the content

00:33:55,679 --> 00:34:02,159
of the proposal p0732

00:33:59,600 --> 00:34:03,279
which brings in class types in non-title

00:34:02,159 --> 00:34:06,480
parameters

00:34:03,279 --> 00:34:09,599
before surplus 20 it was only

00:34:06,480 --> 00:34:12,639
possible to provide um

00:34:09,599 --> 00:34:14,639
integers or pointers or arrays i think

00:34:12,639 --> 00:34:18,240
as template parameters

00:34:14,639 --> 00:34:19,200
um in seventh plus 20 minus some

00:34:18,240 --> 00:34:22,399
restrictions

00:34:19,200 --> 00:34:26,560
it will be possible to provide

00:34:22,399 --> 00:34:30,320
arbitrary objects as a template manager

00:34:26,560 --> 00:34:30,320
and this is extremely powerful

00:34:31,040 --> 00:34:34,720
i see no question for that part so i

00:34:34,159 --> 00:34:37,599
will just

00:34:34,720 --> 00:34:38,879
go to the to the next one where i

00:34:37,599 --> 00:34:41,679
describe how to

00:34:38,879 --> 00:34:42,879
how can i actually achieve a concise way

00:34:41,679 --> 00:34:46,560
to

00:34:42,879 --> 00:34:49,679
specify the dimensions of all race

00:34:46,560 --> 00:34:51,839
ets stands for embedded domain-specific

00:34:49,679 --> 00:34:53,520
language and this is basically the key

00:34:51,839 --> 00:34:56,720
we will define a language

00:34:53,520 --> 00:34:59,920
within surplus plus to

00:34:56,720 --> 00:35:03,119
a language specifically designed

00:34:59,920 --> 00:35:05,359
to specify dimensions of arrays and

00:35:03,119 --> 00:35:08,560
shapes of the right

00:35:05,359 --> 00:35:10,079
what if i told you that the following

00:35:08,560 --> 00:35:12,880
was perfectly possible in the surface

00:35:10,079 --> 00:35:15,040
personality so this is very close to

00:35:12,880 --> 00:35:18,079
some of the interface

00:35:15,040 --> 00:35:18,960
so the exclusivity example we we have

00:35:18,079 --> 00:35:21,839
seen before

00:35:18,960 --> 00:35:22,720
and he said this is actually possible

00:35:21,839 --> 00:35:26,079
thanks to separate

00:35:22,720 --> 00:35:29,119
20. so in the first one we specify

00:35:26,079 --> 00:35:30,960
a n-dimensional array of time double and

00:35:29,119 --> 00:35:34,240
then we specify the shape

00:35:30,960 --> 00:35:37,280
and it's compact it's easy to read

00:35:34,240 --> 00:35:38,880
we have fixed dimension and we have

00:35:37,280 --> 00:35:40,640
combination of fixed dimension and

00:35:38,880 --> 00:35:42,800
dynamic dimension

00:35:40,640 --> 00:35:44,480
or we could even think of different way

00:35:42,800 --> 00:35:48,000
of specifying things

00:35:44,480 --> 00:35:50,560
for example with this contents version

00:35:48,000 --> 00:35:52,880
where we have the template parameters

00:35:50,560 --> 00:35:58,480
the contents that is the element type

00:35:52,880 --> 00:36:00,960
and again the shape of the array

00:35:58,480 --> 00:36:02,720
and this is perfectly as i said before

00:36:00,960 --> 00:36:04,400
this is perfectly possible in terms of

00:36:02,720 --> 00:36:08,240
substance

00:36:04,400 --> 00:36:10,560
so if we want to achieve that um

00:36:08,240 --> 00:36:12,079
we one way of improving the problem is

00:36:10,560 --> 00:36:15,760
to reverse engineer

00:36:12,079 --> 00:36:17,200
what we want to achieve so when we see

00:36:15,760 --> 00:36:20,560
that

00:36:17,200 --> 00:36:22,400
shape cannot be a type because a type

00:36:20,560 --> 00:36:23,920
there is no way of calling the substrate

00:36:22,400 --> 00:36:27,680
operator type

00:36:23,920 --> 00:36:29,920
so shape has to be available therefore

00:36:27,680 --> 00:36:31,280
empty array should be a class template

00:36:29,920 --> 00:36:34,640
of the form class

00:36:31,280 --> 00:36:36,720
auto shape

00:36:34,640 --> 00:36:38,839
should be a viable of a type with

00:36:36,720 --> 00:36:40,400
aperture parenthesis and the operator

00:36:38,839 --> 00:36:42,480
subscript

00:36:40,400 --> 00:36:43,920
and these operators should return a

00:36:42,480 --> 00:36:47,040
value of the same time

00:36:43,920 --> 00:36:48,880
of the same type as shape so that it can

00:36:47,040 --> 00:36:52,640
be called again recursively

00:36:48,880 --> 00:36:56,320
until all dimensions are specified

00:36:52,640 --> 00:36:58,800
and for the contents version same thing

00:36:56,320 --> 00:37:01,040
except this time contents cannot be

00:36:58,800 --> 00:37:04,400
attacked it has to be a viable template

00:37:01,040 --> 00:37:06,800
not a variable but um but the valuable

00:37:04,400 --> 00:37:06,800
template

00:37:07,200 --> 00:37:11,920
in that form and the array should be of

00:37:09,359 --> 00:37:15,119
the form template auto

00:37:11,920 --> 00:37:17,119
contents should be a variable of type or

00:37:15,119 --> 00:37:19,680
with the two operators and same thing as

00:37:17,119 --> 00:37:22,880
before and if we have that

00:37:19,680 --> 00:37:27,040
then we have this the

00:37:22,880 --> 00:37:28,960
short syntax we are looking for

00:37:27,040 --> 00:37:30,079
and this is where we introduce

00:37:28,960 --> 00:37:34,160
expression template

00:37:30,079 --> 00:37:37,359
template expression template is

00:37:34,160 --> 00:37:41,839
the way templates

00:37:37,359 --> 00:37:44,640
wizards used to optimize um

00:37:41,839 --> 00:37:45,359
linear algebra operations but now that

00:37:44,640 --> 00:37:48,079
we can pass

00:37:45,359 --> 00:37:50,079
any kind of object into ice template

00:37:48,079 --> 00:37:53,680
parameters it's possible to inject

00:37:50,079 --> 00:37:56,400
templates to inject expression templates

00:37:53,680 --> 00:37:56,400
as templates

00:37:57,839 --> 00:38:03,599
for our for the case we are looking for

00:38:01,359 --> 00:38:04,960
shape will build an expression template

00:38:03,599 --> 00:38:06,960
and the result of the expression

00:38:04,960 --> 00:38:10,000
template will be then injected

00:38:06,960 --> 00:38:13,119
as a template parameter

00:38:10,000 --> 00:38:14,720
and it takes doing that takes embedded

00:38:13,119 --> 00:38:17,040
domain specific language to a whole new

00:38:14,720 --> 00:38:17,040
level

00:38:17,200 --> 00:38:21,280
so how to do that the first thing to do

00:38:20,079 --> 00:38:25,359
is to create

00:38:21,280 --> 00:38:27,440
two markers to tags to

00:38:25,359 --> 00:38:28,800
process the patterns that are being

00:38:27,440 --> 00:38:31,440
called and shape

00:38:28,800 --> 00:38:33,680
one for the function collaborator one

00:38:31,440 --> 00:38:36,560
for the subscripting operator

00:38:33,680 --> 00:38:38,400
nothing's reporting here the args will

00:38:36,560 --> 00:38:39,200
be used to specify how many of these

00:38:38,400 --> 00:38:41,119
operators

00:38:39,200 --> 00:38:43,440
how many arguments these objects are

00:38:41,119 --> 00:38:43,440
taking

00:38:44,240 --> 00:38:48,400
then we have the shaper class template

00:38:47,040 --> 00:38:52,240
the role of the shaper

00:38:48,400 --> 00:38:55,599
is to is to be the type of the shape

00:38:52,240 --> 00:38:58,240
since shape is available so it's a class

00:38:55,599 --> 00:39:00,960
it's a template it's a class template

00:38:58,240 --> 00:39:02,160
that will have all the preceding

00:39:00,960 --> 00:39:05,520
operations

00:39:02,160 --> 00:39:09,200
as the template parameter

00:39:05,520 --> 00:39:13,440
so it has a constructor that takes

00:39:09,200 --> 00:39:18,240
the preceding um that takes

00:39:13,440 --> 00:39:22,400
a shaper and a new possible

00:39:18,240 --> 00:39:25,599
index to be called to be built recursive

00:39:22,400 --> 00:39:29,280
and it has some data parameter

00:39:25,599 --> 00:39:31,440
nothing surprising so far however

00:39:29,280 --> 00:39:32,960
it has two pictures as we said before

00:39:31,440 --> 00:39:35,119
one operator to build

00:39:32,960 --> 00:39:36,800
dynamic dimension and one operator to

00:39:35,119 --> 00:39:40,720
build static dimension

00:39:36,800 --> 00:39:45,040
so the operator parenthesis will

00:39:40,720 --> 00:39:47,920
build a different shaper adding

00:39:45,040 --> 00:39:49,680
the tag function co-operator at the end

00:39:47,920 --> 00:39:51,200
of the

00:39:49,680 --> 00:39:53,599
operators that have been processed

00:39:51,200 --> 00:39:53,599
before

00:39:54,839 --> 00:40:00,160
um

00:39:57,760 --> 00:40:00,800
we also may want to provide a way to

00:40:00,160 --> 00:40:05,440
specify

00:40:00,800 --> 00:40:08,880
a default size for dynamic dimensions

00:40:05,440 --> 00:40:12,319
and so therefore the operator

00:40:08,880 --> 00:40:14,640
parenthesis may take a parameter

00:40:12,319 --> 00:40:16,400
to specify that and then the

00:40:14,640 --> 00:40:19,280
subscripting operator will do the same

00:40:16,400 --> 00:40:21,599
it would build another shaper from the

00:40:19,280 --> 00:40:23,760
existing shaper

00:40:21,599 --> 00:40:25,599
then we have a way to access the rank

00:40:23,760 --> 00:40:27,280
the number type of already existing

00:40:25,599 --> 00:40:30,480
dimension

00:40:27,280 --> 00:40:33,040
or where to query to create a parameter

00:40:30,480 --> 00:40:34,079
at a given position and the way to

00:40:33,040 --> 00:40:37,359
convert

00:40:34,079 --> 00:40:38,079
the parameters that have been already

00:40:37,359 --> 00:40:42,800
passed

00:40:38,079 --> 00:40:46,160
to an array and to build an array from

00:40:42,800 --> 00:40:48,560
another ray basically the most important

00:40:46,160 --> 00:40:51,839
part in that slide is the fact that

00:40:48,560 --> 00:40:52,640
we have two main operators parenthesis

00:40:51,839 --> 00:40:55,520
and subscript

00:40:52,640 --> 00:40:57,920
and they build a shaper adding the tag

00:40:55,520 --> 00:41:01,440
of the next operation to come

00:40:57,920 --> 00:41:07,280
and then we declare

00:41:01,440 --> 00:41:10,319
a shape instance of type shaper

00:41:07,280 --> 00:41:13,440
and we declare indexing helper to

00:41:10,319 --> 00:41:16,240
help with constantine indices so

00:41:13,440 --> 00:41:16,960
the type of the index is an index

00:41:16,240 --> 00:41:19,839
constant

00:41:16,960 --> 00:41:20,480
and then index is just a viable template

00:41:19,839 --> 00:41:24,079
of type

00:41:20,480 --> 00:41:24,079
index constant that's that's it

00:41:24,240 --> 00:41:29,040
then we want to have a dynamic way of

00:41:27,359 --> 00:41:31,599
specifying extent and a static way of

00:41:29,040 --> 00:41:34,480
specifying extent

00:41:31,599 --> 00:41:36,560
so the first thing to come is an indexed

00:41:34,480 --> 00:41:39,520
dynamic extent

00:41:36,560 --> 00:41:41,760
so we have two versions of it we have a

00:41:39,520 --> 00:41:43,440
version with no default dimension

00:41:41,760 --> 00:41:46,839
and we have a version that takes a

00:41:43,440 --> 00:41:52,319
default a defaulted dimension

00:41:46,839 --> 00:41:56,400
as the as a parameter

00:41:52,319 --> 00:41:59,520
and these um

00:41:56,400 --> 00:42:03,040
these extents are indexed

00:41:59,520 --> 00:42:06,880
by their rank and they have an operator

00:42:03,040 --> 00:42:10,319
subscript taking the rank as

00:42:06,880 --> 00:42:12,240
as a variable we have the same thing for

00:42:10,319 --> 00:42:14,640
static extent

00:42:12,240 --> 00:42:15,520
except the static extent always take a

00:42:14,640 --> 00:42:18,720
value

00:42:15,520 --> 00:42:18,720
the value at compile time

00:42:19,520 --> 00:42:26,160
and then we build a class a helper

00:42:23,119 --> 00:42:30,480
to to build the things from the

00:42:26,160 --> 00:42:34,079
indices so we

00:42:30,480 --> 00:42:37,280
specialize these indexes descent

00:42:34,079 --> 00:42:38,800
maker so that for

00:42:37,280 --> 00:42:40,800
a function called operator it

00:42:38,800 --> 00:42:44,160
corresponds to an indexed

00:42:40,800 --> 00:42:44,800
dynamic extent for function call

00:42:44,160 --> 00:42:46,880
operator

00:42:44,800 --> 00:42:49,359
with one parameter it corresponds to an

00:42:46,880 --> 00:42:53,440
indexed a dynamic extent with

00:42:49,359 --> 00:42:55,520
a default dimension and for

00:42:53,440 --> 00:42:58,800
a subtracting operator it corresponds to

00:42:55,520 --> 00:43:02,079
the indexed static extent

00:42:58,800 --> 00:43:05,200
and then we we have an alias

00:43:02,079 --> 00:43:08,400
to make that thing works

00:43:05,200 --> 00:43:12,400
better and works nicely called make

00:43:08,400 --> 00:43:15,040
indexed extent

00:43:12,400 --> 00:43:16,640
from that we built an extent policy that

00:43:15,040 --> 00:43:19,920
will specify

00:43:16,640 --> 00:43:22,480
um that we specify whether

00:43:19,920 --> 00:43:23,280
dimensions of a certain ranks of a

00:43:22,480 --> 00:43:27,040
certain rank

00:43:23,280 --> 00:43:29,280
are dynamic or static

00:43:27,040 --> 00:43:29,280
so

00:43:30,640 --> 00:43:34,480
the extent policy the thing to to see

00:43:32,800 --> 00:43:37,920
here is that the extent policy

00:43:34,480 --> 00:43:42,000
inherits from the extent the extent

00:43:37,920 --> 00:43:46,079
being the indexed extent

00:43:42,000 --> 00:43:49,280
that associates the

00:43:46,079 --> 00:43:54,480
dynamic or static status with the rank

00:43:49,280 --> 00:43:56,880
of the of the exam

00:43:54,480 --> 00:43:58,160
we create helper to help building these

00:43:56,880 --> 00:44:02,880
things

00:43:58,160 --> 00:44:07,599
uh and especially a make extent policy

00:44:02,880 --> 00:44:11,440
that takes um that basically converts

00:44:07,599 --> 00:44:15,760
will convert a shape into

00:44:11,440 --> 00:44:20,640
a sequence of classes that could be then

00:44:15,760 --> 00:44:20,640
injected and inherited from the examples

00:44:21,280 --> 00:44:24,319
then we have the notion of an extender

00:44:22,960 --> 00:44:27,599
to specify

00:44:24,319 --> 00:44:30,720
at one time how

00:44:27,599 --> 00:44:34,800
a dimension will be resized

00:44:30,720 --> 00:44:36,400
that's an extender um

00:44:34,800 --> 00:44:38,480
so we have this concept of index

00:44:36,400 --> 00:44:39,599
extender that will take an index as an

00:44:38,480 --> 00:44:42,800
input

00:44:39,599 --> 00:44:44,880
and that will uh as

00:44:42,800 --> 00:44:46,720
a template parameter and that will take

00:44:44,880 --> 00:44:49,839
a size

00:44:46,720 --> 00:44:53,440
so that the dimension

00:44:49,839 --> 00:44:56,960
along a particular

00:44:53,440 --> 00:45:00,560
rank will be resized with a given

00:44:56,960 --> 00:45:01,599
with a given number and then we have

00:45:00,560 --> 00:45:03,680
extenders

00:45:01,599 --> 00:45:04,800
so that we can resize several dimensions

00:45:03,680 --> 00:45:07,200
at the same time

00:45:04,800 --> 00:45:09,440
an extender is just a group of indexed

00:45:07,200 --> 00:45:12,960
extent

00:45:09,440 --> 00:45:13,520
nothing very fancy here the extenders in

00:45:12,960 --> 00:45:17,119
the same way

00:45:13,520 --> 00:45:22,000
extent inherits from individual extent

00:45:17,119 --> 00:45:22,000
extenders inherit from indexed extent

00:45:22,880 --> 00:45:31,359
and finally we have our basic nd array

00:45:27,680 --> 00:45:34,640
with our extend policy

00:45:31,359 --> 00:45:36,160
and because some dimensions have to be

00:45:34,640 --> 00:45:39,760
specified when the

00:45:36,160 --> 00:45:40,560
when the object is built then a basic nd

00:45:39,760 --> 00:45:45,359
array

00:45:40,560 --> 00:45:48,000
takes a list of extenders at one time

00:45:45,359 --> 00:45:49,359
and this is um of course this basic and

00:45:48,000 --> 00:45:51,359
direct could have

00:45:49,359 --> 00:45:52,560
a lot of different functions but here

00:45:51,359 --> 00:45:57,200
this is the most basic

00:45:52,560 --> 00:45:58,960
example and if we have all of that

00:45:57,200 --> 00:46:00,800
then by combining all these things

00:45:58,960 --> 00:46:03,920
together

00:46:00,800 --> 00:46:07,920
we may write something like this

00:46:03,920 --> 00:46:10,040
where we have an array of shape

00:46:07,920 --> 00:46:11,280
3 dynamic for

00:46:10,040 --> 00:46:14,880
[Music]

00:46:11,280 --> 00:46:18,400
dynamic with initialized at two

00:46:14,880 --> 00:46:21,200
and a static dimension of three

00:46:18,400 --> 00:46:22,560
constructed by specifying that the

00:46:21,200 --> 00:46:25,280
extent

00:46:22,560 --> 00:46:26,560
along the first the dimension of rank

00:46:25,280 --> 00:46:29,920
one

00:46:26,560 --> 00:46:31,200
is initialized at five so in total we

00:46:29,920 --> 00:46:33,119
have

00:46:31,200 --> 00:46:35,119
along dimension zero we have a static

00:46:33,119 --> 00:46:36,960
size of three along dimension while we

00:46:35,119 --> 00:46:38,480
have a dynamic size with the initial

00:46:36,960 --> 00:46:41,680
value is given in the constructor

00:46:38,480 --> 00:46:43,760
using the extend mechanism a static size

00:46:41,680 --> 00:46:45,440
of four a dynamic size

00:46:43,760 --> 00:46:47,119
dimension three is the dynamic size with

00:46:45,440 --> 00:46:49,280
the default initial value of two

00:46:47,119 --> 00:46:51,520
and dimension four is a static size of

00:46:49,280 --> 00:46:51,520
three

00:46:51,760 --> 00:46:56,000
so one of the question is what's a

00:46:53,680 --> 00:46:58,880
default size for dynamic extent

00:46:56,000 --> 00:46:59,920
we can just use minus one for dynamic

00:46:58,880 --> 00:47:04,079
extent

00:46:59,920 --> 00:47:06,560
so the dynamic extent

00:47:04,079 --> 00:47:07,839
uh currently dynamic action exists in

00:47:06,560 --> 00:47:12,400
the standard

00:47:07,839 --> 00:47:12,400
as of stable 20. and

00:47:12,480 --> 00:47:15,839
it's it's equal to -1 the problem with

00:47:15,520 --> 00:47:19,680
that

00:47:15,839 --> 00:47:19,680
is that it limits um

00:47:19,760 --> 00:47:26,880
it gives no way of specifying a dynamic

00:47:23,520 --> 00:47:30,079
default dimension and

00:47:26,880 --> 00:47:34,319
as we see after it it will be uh it's

00:47:30,079 --> 00:47:37,680
kind of limited um and

00:47:34,319 --> 00:47:40,960
from the type systems perspective

00:47:37,680 --> 00:47:44,559
a special number for default case in

00:47:40,960 --> 00:47:48,559
something that is really template heavy

00:47:44,559 --> 00:47:50,880
is a bad idea so given the time i will

00:47:48,559 --> 00:47:54,240
skip the next part

00:47:50,880 --> 00:47:55,920
and i will uh and i will directly

00:47:54,240 --> 00:47:58,319
i will summarize the next thought

00:47:55,920 --> 00:48:01,359
basically by saying that

00:47:58,319 --> 00:48:04,160
handling because extent

00:48:01,359 --> 00:48:04,800
uh the problem with the extent is that

00:48:04,160 --> 00:48:06,800
because

00:48:04,800 --> 00:48:08,800
all dimension when all dimensions are

00:48:06,800 --> 00:48:11,680
static exchanges can just be

00:48:08,800 --> 00:48:12,559
integer sequence and it works it works

00:48:11,680 --> 00:48:16,000
nicely

00:48:12,559 --> 00:48:17,599
when it's dynamic only then extends can

00:48:16,000 --> 00:48:20,480
just be a real-time array

00:48:17,599 --> 00:48:21,760
that stores the different uh different

00:48:20,480 --> 00:48:24,800
extent

00:48:21,760 --> 00:48:27,839
given that at runtime but

00:48:24,800 --> 00:48:30,800
when there isn't when both

00:48:27,839 --> 00:48:32,960
are mixed then it becomes complicated if

00:48:30,800 --> 00:48:34,640
you want to optimize it

00:48:32,960 --> 00:48:36,480
especially if you want to optimize the

00:48:34,640 --> 00:48:39,359
memory front point so that

00:48:36,480 --> 00:48:42,800
only the diamond dimensions are stored

00:48:39,359 --> 00:48:42,800
if you want to optimize

00:48:43,119 --> 00:48:46,160
runtime access along a particular

00:48:44,720 --> 00:48:48,079
dimension

00:48:46,160 --> 00:48:50,480
and if we want to optimize completion

00:48:48,079 --> 00:48:53,440
time and for people interested

00:48:50,480 --> 00:48:54,160
in all these aspects uh i will leave the

00:48:53,440 --> 00:48:58,079
slide

00:48:54,160 --> 00:49:02,079
um on the guitar of the conference

00:48:58,079 --> 00:49:04,400
this is this is quite technical

00:49:02,079 --> 00:49:06,079
uh but it's possible to achieve these

00:49:04,400 --> 00:49:09,119
goals so that

00:49:06,079 --> 00:49:12,319
the memory from pretty is really low the

00:49:09,119 --> 00:49:14,880
we have perfect runtime access

00:49:12,319 --> 00:49:15,520
uh even with alternative dimensions but

00:49:14,880 --> 00:49:19,119
doing it

00:49:15,520 --> 00:49:21,839
is may more tricky than than

00:49:19,119 --> 00:49:21,839
one may think

00:49:22,240 --> 00:49:29,760
so if the problem of extent is solved

00:49:26,240 --> 00:49:32,800
then what's interesting is

00:49:29,760 --> 00:49:35,599
how what has been proposed

00:49:32,800 --> 00:49:38,160
and that's in that talk could be

00:49:35,599 --> 00:49:38,160
extended

00:49:38,240 --> 00:49:43,680
so because it's an embedded domain

00:49:42,240 --> 00:49:45,920
specific language

00:49:43,680 --> 00:49:47,359
expression template could be used to

00:49:45,920 --> 00:49:49,520
pass

00:49:47,359 --> 00:49:51,119
additional parameters additionally at

00:49:49,520 --> 00:49:54,400
information

00:49:51,119 --> 00:49:58,400
for example operators could be used

00:49:54,400 --> 00:50:01,920
to specify some kind of layout

00:49:58,400 --> 00:50:03,839
information symmetries

00:50:01,920 --> 00:50:05,119
around one particular dimension could be

00:50:03,839 --> 00:50:09,119
expressed as

00:50:05,119 --> 00:50:12,720
a part of the domain specific language

00:50:09,119 --> 00:50:15,280
the parallelization information

00:50:12,720 --> 00:50:16,079
for example if we want to distribute the

00:50:15,280 --> 00:50:19,359
array

00:50:16,079 --> 00:50:21,920
uh over the along the uh

00:50:19,359 --> 00:50:22,720
the first dimension and if you want to

00:50:21,920 --> 00:50:24,559
vectorize it

00:50:22,720 --> 00:50:26,720
on the last one or if you want to

00:50:24,559 --> 00:50:29,280
vectorize it and send it on the gpu on

00:50:26,720 --> 00:50:29,280
the last one

00:50:30,000 --> 00:50:36,800
we could it would be possible to design

00:50:33,440 --> 00:50:38,720
a language using the same principle

00:50:36,800 --> 00:50:41,440
for an axis-based parallelization

00:50:38,720 --> 00:50:45,359
information and

00:50:41,440 --> 00:50:47,520
doing that would make a

00:50:45,359 --> 00:50:49,280
very would be a very powerful way and

00:50:47,520 --> 00:50:54,000
concise way of specifying

00:50:49,280 --> 00:50:57,040
of specifying a very complicated things

00:50:54,000 --> 00:50:59,119
and finally operational shapes could all

00:50:57,040 --> 00:51:02,240
see or could also be possible

00:50:59,119 --> 00:51:05,280
all of that are just

00:51:02,240 --> 00:51:08,880
thoughts but all of that

00:51:05,280 --> 00:51:11,599
is possible

00:51:08,880 --> 00:51:13,119
also there is a currently a proposal to

00:51:11,599 --> 00:51:16,319
specify the international

00:51:13,119 --> 00:51:20,240
subscript operator if we had that

00:51:16,319 --> 00:51:20,880
we could uh including a zero parameter

00:51:20,240 --> 00:51:23,760
operator

00:51:20,880 --> 00:51:24,480
a zero parameter substitute preparator

00:51:23,760 --> 00:51:26,079
it could bring

00:51:24,480 --> 00:51:28,240
other opportunities to enrich the

00:51:26,079 --> 00:51:30,960
language and to have

00:51:28,240 --> 00:51:32,480
uh the parties and the substring

00:51:30,960 --> 00:51:35,520
operator

00:51:32,480 --> 00:51:38,160
um useful for different purposes of

00:51:35,520 --> 00:51:38,160
different meanings

00:51:38,319 --> 00:51:45,839
also i talked

00:51:41,760 --> 00:51:48,960
about static extent and dynamic extent

00:51:45,839 --> 00:51:51,359
but and dynamic extent with a default

00:51:48,960 --> 00:51:54,640
dimension

00:51:51,359 --> 00:51:58,319
but i think it would be

00:51:54,640 --> 00:52:02,640
worth investigating what could be

00:51:58,319 --> 00:52:06,079
the more generic

00:52:02,640 --> 00:52:10,000
concept for an extent and i think

00:52:06,079 --> 00:52:11,839
a way to do that um could be to divide a

00:52:10,000 --> 00:52:13,359
suggestion would be to divide

00:52:11,839 --> 00:52:15,280
an extent between the following

00:52:13,359 --> 00:52:18,480
parameters so a component

00:52:15,280 --> 00:52:22,240
that would be a static size

00:52:18,480 --> 00:52:25,839
under which the the the

00:52:22,240 --> 00:52:26,960
the size couldn't shrink an initial size

00:52:25,839 --> 00:52:29,839
and construction

00:52:26,960 --> 00:52:30,839
basically bringing the when you beat an

00:52:29,839 --> 00:52:34,640
object

00:52:30,839 --> 00:52:37,119
um that size

00:52:34,640 --> 00:52:38,559
when you when you build an object

00:52:37,119 --> 00:52:42,000
without specifying

00:52:38,559 --> 00:52:45,040
the the size of a particular dimension

00:52:42,000 --> 00:52:46,000
then the initial size will be taken a

00:52:45,040 --> 00:52:50,240
threshold

00:52:46,000 --> 00:52:53,280
to specify when

00:52:50,240 --> 00:52:56,319
how many elements can be stored

00:52:53,280 --> 00:52:57,980
on the stack and when

00:52:56,319 --> 00:52:59,440
the allocator is

00:52:57,980 --> 00:53:02,000
[Music]

00:52:59,440 --> 00:53:02,960
and triggered maximum number of elements

00:53:02,000 --> 00:53:07,520
that could be

00:53:02,960 --> 00:53:10,319
um of specified at compile time

00:53:07,520 --> 00:53:14,400
that the thing can can grow to this

00:53:10,319 --> 00:53:16,800
could be infinite

00:53:14,400 --> 00:53:19,200
in terms of these four parameters for

00:53:16,800 --> 00:53:22,960
example a static extent is just

00:53:19,200 --> 00:53:24,640
an extent where the four parameters are

00:53:22,960 --> 00:53:28,400
equal

00:53:24,640 --> 00:53:30,319
the dynamic extent is uh is an extent

00:53:28,400 --> 00:53:32,240
where the minimum is set to zero the

00:53:30,319 --> 00:53:34,480
maximum is set to infinity

00:53:32,240 --> 00:53:35,520
the initial and threshold are set to

00:53:34,480 --> 00:53:38,800
zero so that

00:53:35,520 --> 00:53:39,599
as soon as one element is added all the

00:53:38,800 --> 00:53:41,359
thing is that okay

00:53:39,599 --> 00:53:42,960
the allocator is called and everything

00:53:41,359 --> 00:53:46,559
is on the heap

00:53:42,960 --> 00:53:49,359
and a fixed extent um where

00:53:46,559 --> 00:53:50,480
in that case the initial size would be

00:53:49,359 --> 00:53:53,520
zero

00:53:50,480 --> 00:53:57,280
max component max element would be n

00:53:53,520 --> 00:53:57,280
and this threshold would be yeah

00:53:58,720 --> 00:54:02,720
so that's that's another thing we could

00:54:01,040 --> 00:54:05,599
think of if you want to um

00:54:02,720 --> 00:54:08,559
to generalize the and to go beyond what

00:54:05,599 --> 00:54:11,680
what has been presented

00:54:08,559 --> 00:54:14,640
more generally the generic entities i

00:54:11,680 --> 00:54:17,359
think really open the condors box

00:54:14,640 --> 00:54:18,800
because being able to inject objects as

00:54:17,359 --> 00:54:21,280
template parameters in surplus

00:54:18,800 --> 00:54:22,160
20 is again challenging to design

00:54:21,280 --> 00:54:26,480
language

00:54:22,160 --> 00:54:29,200
and now template classes

00:54:26,480 --> 00:54:30,720
really are mini compilers it would be

00:54:29,200 --> 00:54:32,960
totally possible and that's

00:54:30,720 --> 00:54:34,079
what i showed in that in that

00:54:32,960 --> 00:54:37,680
presentation is that

00:54:34,079 --> 00:54:40,640
it's totally possible to use

00:54:37,680 --> 00:54:41,760
a template class and inject a media

00:54:40,640 --> 00:54:45,359
language

00:54:41,760 --> 00:54:48,000
with its own grammar inside it

00:54:45,359 --> 00:54:49,760
the next step to come i think to take it

00:54:48,000 --> 00:54:52,319
one level further

00:54:49,760 --> 00:54:55,000
is the generosity regarding kind because

00:54:52,319 --> 00:54:57,760
for now and that has been proposed by

00:54:55,000 --> 00:55:00,880
p1985

00:54:57,760 --> 00:55:04,240
because for now it's impossible to

00:55:00,880 --> 00:55:05,200
have something that could be a type of

00:55:04,240 --> 00:55:08,160
value

00:55:05,200 --> 00:55:09,280
the developer has to specify where the

00:55:08,160 --> 00:55:12,319
template parameter

00:55:09,280 --> 00:55:13,359
will be it can be a generic value thanks

00:55:12,319 --> 00:55:18,400
to auto

00:55:13,359 --> 00:55:18,400
but it cannot be a type of

00:55:18,440 --> 00:55:23,200
p1985 proposed to standardize

00:55:23,359 --> 00:55:28,240
a way to specify something that could

00:55:27,040 --> 00:55:31,760
basically be anything

00:55:28,240 --> 00:55:34,480
a value a type a template and if this is

00:55:31,760 --> 00:55:37,680
brought to the surplus plus

00:55:34,480 --> 00:55:42,000
this will really make

00:55:37,680 --> 00:55:48,480
the design of the dsl and mini language

00:55:42,000 --> 00:55:51,839
far easier for template developers

00:55:48,480 --> 00:55:54,640
so the conclusion for this talk is that

00:55:51,839 --> 00:55:56,720
um as i said in the introduction linear

00:55:54,640 --> 00:55:59,920
algebra everywhere

00:55:56,720 --> 00:56:01,599
it's very complex when

00:55:59,920 --> 00:56:03,520
we try to balance between generosity

00:56:01,599 --> 00:56:05,599
performance and expressivity and that is

00:56:03,520 --> 00:56:06,559
why it's very complex to do in surplus

00:56:05,599 --> 00:56:09,280
plus

00:56:06,559 --> 00:56:11,359
there is an existing effort being done

00:56:09,280 --> 00:56:15,200
with mdspan

00:56:11,359 --> 00:56:18,240
however currently the way to specify

00:56:15,200 --> 00:56:21,520
the shape of a raise is

00:56:18,240 --> 00:56:24,960
requires a lot of characters

00:56:21,520 --> 00:56:27,760
surplus plus 20 um with

00:56:24,960 --> 00:56:29,200
arbitrary non-titanfall parameters

00:56:27,760 --> 00:56:30,880
allows to design

00:56:29,200 --> 00:56:32,720
embedded domain specific language to

00:56:30,880 --> 00:56:37,920
specify multi-dimensional

00:56:32,720 --> 00:56:37,920
shapes in a much more concise manner

00:56:38,960 --> 00:56:45,119
with that it's possible to use what i

00:56:41,839 --> 00:56:49,280
call expression template template

00:56:45,119 --> 00:56:52,400
to inject the expression template inside

00:56:49,280 --> 00:56:52,400
as a template parameter

00:56:52,880 --> 00:56:58,559
and using that it's possible to create

00:56:56,640 --> 00:57:01,760
what i should before

00:56:58,559 --> 00:57:05,440
which is i think far more powerful than

00:57:01,760 --> 00:57:09,119
than just trying to relax in complete

00:57:05,440 --> 00:57:11,599
mutilation type declaration or trying to

00:57:09,119 --> 00:57:14,960
use -1 as a parameter

00:57:11,599 --> 00:57:18,240
because this could be used to specify

00:57:14,960 --> 00:57:20,559
as i showed where to uh parallel

00:57:18,240 --> 00:57:21,680
to paralyze like where to do things

00:57:20,559 --> 00:57:25,680
alongside

00:57:21,680 --> 00:57:28,079
certain dimensions mixing dynamic and

00:57:25,680 --> 00:57:31,200
static extents are particularly

00:57:28,079 --> 00:57:34,160
tricky to implement uh

00:57:31,200 --> 00:57:35,520
there is trick to do that which i call

00:57:34,160 --> 00:57:37,839
the log table trick

00:57:35,520 --> 00:57:39,280
and people interested in that which is a

00:57:37,839 --> 00:57:43,599
very useful pattern

00:57:39,280 --> 00:57:46,079
can can look at the at the presentation

00:57:43,599 --> 00:57:47,200
as i said extending the dsl can go in

00:57:46,079 --> 00:57:49,760
many directions

00:57:47,200 --> 00:57:50,799
bringing layout information symmetries

00:57:49,760 --> 00:57:53,599
parallelization

00:57:50,799 --> 00:57:54,079
shape operation all of that be brought

00:57:53,599 --> 00:57:58,480
into

00:57:54,079 --> 00:57:58,480
into the small language i described

00:57:58,640 --> 00:58:03,280
um if we want to go further i think that

00:58:01,839 --> 00:58:06,160
interesting direction

00:58:03,280 --> 00:58:07,520
could be to concertify the concept of

00:58:06,160 --> 00:58:10,799
the next stance

00:58:07,520 --> 00:58:11,760
and so that we have a unique way of

00:58:10,799 --> 00:58:13,280
specifying

00:58:11,760 --> 00:58:15,119
when things are static when things are

00:58:13,280 --> 00:58:16,720
dynamic when things are resizable

00:58:15,119 --> 00:58:19,920
up to a certain dimension when things

00:58:16,720 --> 00:58:22,319
are resizable regardless of the maximum

00:58:19,920 --> 00:58:25,599
when things are not resizable under a

00:58:22,319 --> 00:58:25,599
certain dimension extracts

00:58:27,520 --> 00:58:32,799
c plus 20 um

00:58:30,799 --> 00:58:34,400
really is bringing something very

00:58:32,799 --> 00:58:37,680
interesting to

00:58:34,400 --> 00:58:41,760
to egsl design

00:58:37,680 --> 00:58:43,440
and i think surplus 23 if a

00:58:41,760 --> 00:58:46,000
time generosity is allowed in

00:58:43,440 --> 00:58:49,440
separations 23 it will take it

00:58:46,000 --> 00:58:50,240
even further thank you for your

00:58:49,440 --> 00:58:52,000
attention

00:58:50,240 --> 00:58:54,400
uh i know there has been a lot of

00:58:52,000 --> 00:58:57,760
material but if you have questions

00:58:54,400 --> 00:58:59,440
um i'm i will i will read them

00:58:57,760 --> 00:59:01,839
and i want to thank especially joel

00:58:59,440 --> 00:59:03,280
falco because we are collaborating with

00:59:01,839 --> 00:59:06,319
the topic and i think something

00:59:03,280 --> 00:59:08,000
very nice will uh

00:59:06,319 --> 00:59:10,000
will write something very nice to you to

00:59:08,000 --> 00:59:12,480
handle the this kind of things

00:59:10,000 --> 00:59:14,400
so one question is what do you think

00:59:12,480 --> 00:59:16,000
could be an interface to compare shapes

00:59:14,400 --> 00:59:19,920
of different arrays for compelling

00:59:16,000 --> 00:59:23,839
for compatibility about your operation

00:59:19,920 --> 00:59:26,880
so that's

00:59:23,839 --> 00:59:30,319
that's a good question um

00:59:26,880 --> 00:59:33,520
i didn't investigate yet um

00:59:30,319 --> 00:59:36,720
that particular question because

00:59:33,520 --> 00:59:37,280
i wanted my my main purpose doing what i

00:59:36,720 --> 00:59:40,880
did

00:59:37,280 --> 00:59:44,079
was to show proof of concept

00:59:40,880 --> 00:59:46,079
to show that it was possible to do that

00:59:44,079 --> 00:59:48,319
and it is possible to do what i had in

00:59:46,079 --> 00:59:51,200
mind now

00:59:48,319 --> 00:59:52,240
now that we know it's possible there

00:59:51,200 --> 00:59:55,920
will be the question

00:59:52,240 --> 00:59:58,559
of how to do that in in

00:59:55,920 --> 01:00:00,559
in a nice way and for now and for now i

00:59:58,559 --> 01:00:02,799
i don't know

01:00:00,559 --> 01:00:05,119
do you think question two do you think

01:00:02,799 --> 01:00:07,440
that dynamic static extends mix

01:00:05,119 --> 01:00:08,480
can be separated into something more

01:00:07,440 --> 01:00:13,520
generally useful

01:00:08,480 --> 01:00:17,119
like partially static array um

01:00:13,520 --> 01:00:17,839
yes um yes and that's for people who are

01:00:17,119 --> 01:00:21,359
interested

01:00:17,839 --> 01:00:25,599
in in that

01:00:21,359 --> 01:00:25,599
uh that i would

01:00:26,400 --> 01:00:31,520
look at the at the part that i didn't

01:00:28,640 --> 01:00:35,280
have time to show about the extent

01:00:31,520 --> 01:00:37,200
um but

01:00:35,280 --> 01:00:39,119
yes that's a way of doing it but there

01:00:37,200 --> 01:00:42,559
are there are ways of doing that

01:00:39,119 --> 01:00:47,920
that that are nicer and that scale

01:00:42,559 --> 01:00:47,920
better than a partial static array

01:00:48,079 --> 01:00:57,280
and so if you have other questions

01:00:53,200 --> 01:01:01,920
i i can take a question offline

01:00:57,280 --> 01:01:03,839
in the track there is a question three

01:01:01,920 --> 01:01:05,359
which is what timeline do you envision

01:01:03,839 --> 01:01:06,960
for getting stuff like this into the

01:01:05,359 --> 01:01:10,880
standard no

01:01:06,960 --> 01:01:14,400
i would hope um the question being

01:01:10,880 --> 01:01:17,920
earlier than cetera 26 i think actually

01:01:14,400 --> 01:01:18,240
this could be included in the revision

01:01:17,920 --> 01:01:21,680
of

01:01:18,240 --> 01:01:24,720
md spam at least the most basic version

01:01:21,680 --> 01:01:28,799
because once andy time is shipped

01:01:24,720 --> 01:01:32,319
i think it will be because it will cause

01:01:28,799 --> 01:01:34,720
later um competitive and compatibility

01:01:32,319 --> 01:01:34,720
problems

01:01:35,119 --> 01:01:39,280
i think this is this is something that i

01:01:37,280 --> 01:01:40,240
want to look at with the author of the

01:01:39,280 --> 01:01:45,119
spam

01:01:40,240 --> 01:01:49,040
um and but i'm hoping that

01:01:45,119 --> 01:01:50,799
i'm hoping for reduced version of it

01:01:49,040 --> 01:01:52,880
just to specify static and dynamic

01:01:50,799 --> 01:01:55,599
version i think this could be shipped on

01:01:52,880 --> 01:01:58,079
supposed 23 i hope

01:01:55,599 --> 01:01:59,920
thank you for your attention and if you

01:01:58,079 --> 01:02:07,839
have questions i would say i will take

01:01:59,920 --> 01:02:07,839
them offline

01:02:21,520 --> 01:02:23,599

YouTube URL: https://www.youtube.com/watch?v=wHu6TGela6A


