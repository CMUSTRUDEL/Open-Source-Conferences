Title: Back to Basics: Design Patterns - Mike Shah - CppCon 2020
Publication date: 2020-09-30
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_design_patterns/back_to_basics_design_patterns__michael_shah__cppcon_2020.pdf
---
Design Patterns are reusable elements of design that may help aid in making software more maintainable, flexible, and extensible. The term 'design patterns' can be traced back to at least the 1970s, although the term has been largely popularized by the 'Gang of Four' book Design Patterns, in which common software design patterns were defined and categorized. In this talk, you will learn the fundamentals of the creational, structural, and behavior design patterns. This talk is aimed at beginners who have some C++ knowledge working on a software project, but are starting to think about larger software problems. This talk will also be useful for folks who have been working in C++ for a while, but have never had a chance to study design patterns and need some resources to help orient them.

Learning about design patterns and where to apply them can at the least give you a way to think about how you solve unknown problems, or otherwise organize your software--think about design patterns as another tool to add to your developer toolbox. We will start this talk by introducing the taxonomy of design patterns at a high level, how to read a UML diagram (as a quick refresher), a refresher on inheritance vs composition, and then spend the rest of the time on walking through the implementation of several design patterns. Attendees will leave this talk ready to implement and use design patterns in C++.

---
Michael D. Shah completed his Ph.D. at Tufts University in the Redline Research Group in 2017. His Ph.D. thesis advisor was Samuel Z. Guyer. Michael finished his Masters degree in Computer Science in 2013 at Tufts University and Bachelors in Computers Science Engineering at The Ohio State University in 2011. Currently Michael is a lecturer at Northeastern University.
Michael discovered computer science at the age of 13 when googling ”how do I make games”. From that google search, Mike has worked as a freelance game developer, worked in industry for Intel, Sony Playstation, Oblong Industries, and researched at The Ohio Supercomputer Center to name a few. Mike cares about building tools to help programmers monitor and improve the performance of realtime applications– especially games.
In Michael’s spare time he is a long distance runner, weight lifter, and amateur pizza maker.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,720 --> 00:00:12,480
and we are

00:00:10,719 --> 00:00:14,400
live and thank you again i know there's

00:00:12,480 --> 00:00:15,599
a lot of other great sessions to choose

00:00:14,400 --> 00:00:18,160
from so

00:00:15,599 --> 00:00:18,720
thank you for stopping in on this one

00:00:18,160 --> 00:00:22,080
okay

00:00:18,720 --> 00:00:24,160
so i'm going to proceed

00:00:22,080 --> 00:00:25,599
uh this talk is being delivered to a

00:00:24,160 --> 00:00:29,039
live audience um

00:00:25,599 --> 00:00:31,039
so i'll be taking questions at the end

00:00:29,039 --> 00:00:32,399
volunteers have been kind enough that

00:00:31,039 --> 00:00:33,920
they're going to collect the questions

00:00:32,399 --> 00:00:35,360
in the private chat so i'll address them

00:00:33,920 --> 00:00:37,920
if there's time at the end

00:00:35,360 --> 00:00:40,000
otherwise i'll be in the remo uh

00:00:37,920 --> 00:00:41,760
conference software at

00:00:40,000 --> 00:00:45,840
room one table one okay so i look

00:00:41,760 --> 00:00:45,840
forward to your discussion there

00:00:47,360 --> 00:00:53,920
okay so the abstract that you've seen

00:00:50,960 --> 00:00:55,840
and hopefully drew you into this talk is

00:00:53,920 --> 00:00:58,320
here so you've already read that

00:00:55,840 --> 00:00:59,440
just a little bit about me your speaker

00:00:58,320 --> 00:01:01,359
so you know me

00:00:59,440 --> 00:01:03,199
the highlights in orange here i'm an

00:01:01,359 --> 00:01:05,840
assistant teaching professor

00:01:03,199 --> 00:01:06,960
at northeastern university i do research

00:01:05,840 --> 00:01:10,080
primarily in

00:01:06,960 --> 00:01:13,040
performance i also do some consulting

00:01:10,080 --> 00:01:13,920
in computer graphics work various 3d

00:01:13,040 --> 00:01:15,200
projects

00:01:13,920 --> 00:01:17,600
and if you want to find out more about

00:01:15,200 --> 00:01:20,080
me you can read this later or visit my

00:01:17,600 --> 00:01:20,080
website

00:01:20,640 --> 00:01:24,000
okay so what are you going to learn

00:01:22,159 --> 00:01:25,119
today just so you know what to pay

00:01:24,000 --> 00:01:26,640
attention to

00:01:25,119 --> 00:01:28,960
today you're going to learn what design

00:01:26,640 --> 00:01:31,040
patterns are and why you should study

00:01:28,960 --> 00:01:32,720
them from a sort of pragmatic

00:01:31,040 --> 00:01:35,920
viewpoint i'm going to be walking us

00:01:32,720 --> 00:01:37,920
through a some live coding examples

00:01:35,920 --> 00:01:39,119
so you can see just how i think about

00:01:37,920 --> 00:01:41,360
design patterns

00:01:39,119 --> 00:01:42,640
and how you can apply them so we're

00:01:41,360 --> 00:01:45,040
going to use a

00:01:42,640 --> 00:01:46,159
creational pattern implementation and

00:01:45,040 --> 00:01:47,759
use of it

00:01:46,159 --> 00:01:50,320
do the implementation and use of a

00:01:47,759 --> 00:01:52,880
structural pattern called the adapter

00:01:50,320 --> 00:01:53,520
and then how to use a behavioral pattern

00:01:52,880 --> 00:01:55,520
these are

00:01:53,520 --> 00:01:57,759
we're going to look at iterators in c

00:01:55,520 --> 00:01:59,840
plus

00:01:57,759 --> 00:02:01,119
okay so my expectations are if you're

00:01:59,840 --> 00:02:02,159
watching this talk is that you have

00:02:01,119 --> 00:02:04,320
written some c

00:02:02,159 --> 00:02:05,520
plus you understand some of the basics

00:02:04,320 --> 00:02:08,879
about things like

00:02:05,520 --> 00:02:11,200
memory allocation object lifetime

00:02:08,879 --> 00:02:12,720
and so on i'm also expecting that you'll

00:02:11,200 --> 00:02:14,160
know a little bit about object-oriented

00:02:12,720 --> 00:02:16,640
constructs things like

00:02:14,160 --> 00:02:18,720
classes structs encapsulation

00:02:16,640 --> 00:02:20,080
polymorphism inheritance composition all

00:02:18,720 --> 00:02:23,440
these good things should be familiar

00:02:20,080 --> 00:02:26,480
terms for you

00:02:23,440 --> 00:02:27,200
okay so with that let's dive in let's

00:02:26,480 --> 00:02:30,160
just start

00:02:27,200 --> 00:02:30,160
building some software

00:02:30,480 --> 00:02:35,280
okay so i want to give us a running

00:02:33,519 --> 00:02:36,400
example to motivate design patterns

00:02:35,280 --> 00:02:38,800
today

00:02:36,400 --> 00:02:40,800
and the deal is you know you've been

00:02:38,800 --> 00:02:41,519
hired as a programmer to perform some

00:02:40,800 --> 00:02:43,440
maintenance

00:02:41,519 --> 00:02:45,519
okay so you're gonna join an existing

00:02:43,440 --> 00:02:47,440
company and you're gonna work

00:02:45,519 --> 00:02:49,519
on this exciting new screen saver

00:02:47,440 --> 00:02:50,319
software so some actual code that you're

00:02:49,519 --> 00:02:51,519
going to see

00:02:50,319 --> 00:02:52,800
and you're going to get lots of money if

00:02:51,519 --> 00:02:54,160
you do a good job so you want to be a

00:02:52,800 --> 00:02:56,560
good software developer and

00:02:54,160 --> 00:02:58,400
implement some of the best practices

00:02:56,560 --> 00:02:58,800
additionally this is a well-established

00:02:58,400 --> 00:03:00,800
team

00:02:58,800 --> 00:03:02,879
and you're going to be working with a

00:03:00,800 --> 00:03:04,560
large team many different colleagues of

00:03:02,879 --> 00:03:06,080
many different levels

00:03:04,560 --> 00:03:07,599
and if you do a good job you're going to

00:03:06,080 --> 00:03:09,599
get hired to do another contract

00:03:07,599 --> 00:03:10,720
and get to do some more work and keep

00:03:09,599 --> 00:03:13,040
producing some cool c

00:03:10,720 --> 00:03:14,720
plus plus so if that sounds good you

00:03:13,040 --> 00:03:17,040
know sign the dotted line and let's go

00:03:14,720 --> 00:03:20,480
ahead and proceed

00:03:17,040 --> 00:03:22,879
okay so your first day of work uh here

00:03:20,480 --> 00:03:24,159
uh so here's what you're given uh it's a

00:03:22,879 --> 00:03:27,040
screensaver

00:03:24,159 --> 00:03:29,599
so on the right of my screen here uh and

00:03:27,040 --> 00:03:31,680
you've got a bunch of circles that are

00:03:29,599 --> 00:03:33,200
bouncing around here to get that sort of

00:03:31,680 --> 00:03:35,920
classic screen saver

00:03:33,200 --> 00:03:36,560
effect now your job is going to be to

00:03:35,920 --> 00:03:40,080
maintain and

00:03:36,560 --> 00:03:40,720
improve this software and as i'm looking

00:03:40,080 --> 00:03:43,280
at this

00:03:40,720 --> 00:03:44,879
the initial effect looks nice we've got

00:03:43,280 --> 00:03:45,440
the visual sort of moving around in

00:03:44,879 --> 00:03:47,599
different

00:03:45,440 --> 00:03:49,599
directions it looks a little bit random

00:03:47,599 --> 00:03:50,080
but there is a subtle air if you watch

00:03:49,599 --> 00:03:53,200
it

00:03:50,080 --> 00:03:55,599
for long enough and

00:03:53,200 --> 00:03:56,239
the error is that all of the circles

00:03:55,599 --> 00:03:57,840
start out

00:03:56,239 --> 00:03:59,439
at a fixed portion of the screen which

00:03:57,840 --> 00:04:01,920
i've highlighted on the right here

00:03:59,439 --> 00:04:03,040
so you'll notice as this animation loops

00:04:01,920 --> 00:04:05,280
all these circles

00:04:03,040 --> 00:04:06,720
are grouped up here and once you notice

00:04:05,280 --> 00:04:09,840
it once it's hard to

00:04:06,720 --> 00:04:11,360
unsee so it's kind of a bug here on your

00:04:09,840 --> 00:04:14,159
screen saver software

00:04:11,360 --> 00:04:16,880
so good job you've spotted your bug in

00:04:14,159 --> 00:04:19,040
the software here

00:04:16,880 --> 00:04:21,280
so you go through start looking at the

00:04:19,040 --> 00:04:23,840
code and start doing some

00:04:21,280 --> 00:04:24,400
bug hunting here okay so here i have on

00:04:23,840 --> 00:04:26,400
the right

00:04:24,400 --> 00:04:27,680
a constructor for each of these circle

00:04:26,400 --> 00:04:29,600
objects

00:04:27,680 --> 00:04:30,880
and you notice that the starting

00:04:29,600 --> 00:04:32,639
position

00:04:30,880 --> 00:04:34,000
of each of these circles is randomly

00:04:32,639 --> 00:04:36,560
generated

00:04:34,000 --> 00:04:37,440
to create a more interesting effect but

00:04:36,560 --> 00:04:39,840
you notice the

00:04:37,440 --> 00:04:42,639
range is a little bit peculiar that your

00:04:39,840 --> 00:04:45,680
x and your y position of these circles

00:04:42,639 --> 00:04:46,800
is a range of one to three hundred okay

00:04:45,680 --> 00:04:48,720
and that's fixed

00:04:46,800 --> 00:04:51,280
um so we see this sort of fixed value

00:04:48,720 --> 00:04:53,600
here of 300 300 there's no documentation

00:04:51,280 --> 00:04:56,720
we don't know why it's set like that but

00:04:53,600 --> 00:04:58,960
here it is

00:04:56,720 --> 00:05:01,280
and then you do some more investigation

00:04:58,960 --> 00:05:03,360
and you observe that the actual window

00:05:01,280 --> 00:05:04,560
where you're drawing that screensaver

00:05:03,360 --> 00:05:07,360
has a window width

00:05:04,560 --> 00:05:09,280
of 640 and a window height of 480. so

00:05:07,360 --> 00:05:10,000
you discover these global variables that

00:05:09,280 --> 00:05:11,759
are sort of

00:05:10,000 --> 00:05:13,120
setting up bounds for how big our

00:05:11,759 --> 00:05:16,479
environment is

00:05:13,120 --> 00:05:18,080
okay so that's most likely the intended

00:05:16,479 --> 00:05:20,000
range of where you wanted to

00:05:18,080 --> 00:05:21,199
sort of randomly spawn all of those

00:05:20,000 --> 00:05:25,520
circles

00:05:21,199 --> 00:05:29,360
to get a more smooth screensaver effect

00:05:25,520 --> 00:05:30,960
okay so great we find uh the actual bug

00:05:29,360 --> 00:05:32,479
so let's try to fix it let's be good

00:05:30,960 --> 00:05:34,400
software engineers

00:05:32,479 --> 00:05:35,680
as we've been newly hired for this

00:05:34,400 --> 00:05:38,080
company

00:05:35,680 --> 00:05:39,600
and you know deadlines coming up so

00:05:38,080 --> 00:05:42,639
let's do a quick fix here

00:05:39,600 --> 00:05:46,320
let's just adjust the range so it's now

00:05:42,639 --> 00:05:47,440
640 by 480. problem solved it's going to

00:05:46,320 --> 00:05:48,960
look just as good

00:05:47,440 --> 00:05:51,280
and have the intended effect that you

00:05:48,960 --> 00:05:53,680
wanted

00:05:51,280 --> 00:05:54,479
okay but when we do these kind of quick

00:05:53,680 --> 00:05:58,240
fixes

00:05:54,479 --> 00:06:00,080
um you know we're merely masking the bug

00:05:58,240 --> 00:06:01,840
or making it temporarily go away

00:06:00,080 --> 00:06:03,680
because what if we change the window

00:06:01,840 --> 00:06:05,360
size again or have to

00:06:03,680 --> 00:06:07,440
uh get a bigger monitor with a different

00:06:05,360 --> 00:06:08,400
resolution okay so now we have to

00:06:07,440 --> 00:06:10,639
maintain

00:06:08,400 --> 00:06:12,639
uh this value in two different places

00:06:10,639 --> 00:06:14,960
and not only do you have to remember but

00:06:12,639 --> 00:06:16,960
other software engineers who are working

00:06:14,960 --> 00:06:19,600
on this project have to remember as well

00:06:16,960 --> 00:06:21,280
so in this first spot i have to remember

00:06:19,600 --> 00:06:22,720
640 by 480

00:06:21,280 --> 00:06:26,240
and then the second spot i have to

00:06:22,720 --> 00:06:28,960
remember 640 by 480.

00:06:26,240 --> 00:06:29,759
okay well you might say to yourself the

00:06:28,960 --> 00:06:31,759
point of

00:06:29,759 --> 00:06:33,600
having global variables after all which

00:06:31,759 --> 00:06:36,400
we've defined down here

00:06:33,600 --> 00:06:38,160
window width and window height is to

00:06:36,400 --> 00:06:39,440
take care of this problem and to try to

00:06:38,160 --> 00:06:41,120
solve

00:06:39,440 --> 00:06:43,840
having you know different values in

00:06:41,120 --> 00:06:46,080
different places remain consistent

00:06:43,840 --> 00:06:46,960
but you know things can get a little bit

00:06:46,080 --> 00:06:49,440
messy

00:06:46,960 --> 00:06:50,319
when we start using global variables in

00:06:49,440 --> 00:06:52,160
our files

00:06:50,319 --> 00:06:53,440
you know we have to maybe include them

00:06:52,160 --> 00:06:54,880
in a header

00:06:53,440 --> 00:06:56,479
and then if we bring somebody else's

00:06:54,880 --> 00:06:58,240
third-party code in

00:06:56,479 --> 00:07:00,479
and they name them the same values you

00:06:58,240 --> 00:07:02,000
know there's symbol resolution issues we

00:07:00,479 --> 00:07:04,880
have to deal with the linker

00:07:02,000 --> 00:07:06,160
so things kind of get a little bit messy

00:07:04,880 --> 00:07:08,639
when we start having these sort of

00:07:06,160 --> 00:07:10,880
freestanding globals together

00:07:08,639 --> 00:07:12,639
and even more so window width and window

00:07:10,880 --> 00:07:14,000
height are related so it would be nice

00:07:12,639 --> 00:07:15,520
if we could remember to group them

00:07:14,000 --> 00:07:17,360
together in some way

00:07:15,520 --> 00:07:19,440
so there has to be a better way to to do

00:07:17,360 --> 00:07:20,800
this and to solve our bug

00:07:19,440 --> 00:07:23,120
okay so this is where i want to

00:07:20,800 --> 00:07:24,560
introduce design patterns or at least a

00:07:23,120 --> 00:07:28,080
pattern that can help us

00:07:24,560 --> 00:07:31,599
with this problem so design

00:07:28,080 --> 00:07:33,360
patterns um are common

00:07:31,599 --> 00:07:35,360
repeatable solutions for solving

00:07:33,360 --> 00:07:36,400
problems you can think of them like

00:07:35,360 --> 00:07:38,240
templates or

00:07:36,400 --> 00:07:39,759
some sort of blueprint print for

00:07:38,240 --> 00:07:42,160
developing software

00:07:39,759 --> 00:07:44,160
they've been tested before someone else

00:07:42,160 --> 00:07:45,759
has implemented them and had a success

00:07:44,160 --> 00:07:47,759
story that they can share

00:07:45,759 --> 00:07:49,520
this is the idea of design patterns so

00:07:47,759 --> 00:07:51,440
design patterns can help

00:07:49,520 --> 00:07:52,720
us as software engineers write software

00:07:51,440 --> 00:07:56,080
that's more flexible

00:07:52,720 --> 00:07:57,440
maintainable and extensible okay and

00:07:56,080 --> 00:07:59,120
these are likely

00:07:57,440 --> 00:08:00,639
qualities that we want to have on a

00:07:59,120 --> 00:08:02,240
software engineering project

00:08:00,639 --> 00:08:05,039
over a long term especially if it's a

00:08:02,240 --> 00:08:07,039
big project if it's evolving

00:08:05,039 --> 00:08:09,199
and if it's collaborated with multiple

00:08:07,039 --> 00:08:11,039
parties we want to have all these

00:08:09,199 --> 00:08:12,479
characteristics for as many as we can

00:08:11,039 --> 00:08:14,800
design patterns are one way that can

00:08:12,479 --> 00:08:14,800
help us

00:08:15,280 --> 00:08:19,759
so the origin of design patterns goes

00:08:17,039 --> 00:08:22,080
back uh quite some time

00:08:19,759 --> 00:08:23,360
folks say at least the term goes back to

00:08:22,080 --> 00:08:26,639
the 70s

00:08:23,360 --> 00:08:28,960
the term design patterns from a

00:08:26,639 --> 00:08:30,160
reusable elements of design in an

00:08:28,960 --> 00:08:33,519
architecture book

00:08:30,160 --> 00:08:34,240
this book a pattern language that's

00:08:33,519 --> 00:08:37,360
where

00:08:34,240 --> 00:08:38,080
various patterns were founded for

00:08:37,360 --> 00:08:39,360
different

00:08:38,080 --> 00:08:40,959
architecture patterns so different

00:08:39,360 --> 00:08:43,200
industries that's where the term comes

00:08:40,959 --> 00:08:43,200
from

00:08:43,919 --> 00:08:47,920
where a lot of the popularity or at

00:08:46,560 --> 00:08:48,959
least where i've learned about design

00:08:47,920 --> 00:08:51,680
patterns comes from

00:08:48,959 --> 00:08:53,519
was from a book that came out in 1994

00:08:51,680 --> 00:08:55,040
known as the gang of four book for the

00:08:53,519 --> 00:08:57,200
four authors

00:08:55,040 --> 00:09:00,080
that sort of categorized and listed a

00:08:57,200 --> 00:09:01,279
lot of the most famous design patterns

00:09:00,080 --> 00:09:03,440
so it's popular enough there's a

00:09:01,279 --> 00:09:05,839
wikipedia page where you can learn more

00:09:03,440 --> 00:09:07,360
there are c-plus plus and small talk

00:09:05,839 --> 00:09:09,360
examples included

00:09:07,360 --> 00:09:11,120
but you can apply them to many languages

00:09:09,360 --> 00:09:13,360
and we've seen that

00:09:11,120 --> 00:09:14,959
over time has been true and this is

00:09:13,360 --> 00:09:18,000
really a good starting point for

00:09:14,959 --> 00:09:18,880
design patterns in object oriented

00:09:18,000 --> 00:09:20,399
programming

00:09:18,880 --> 00:09:22,480
so the book's a great resource where you

00:09:20,399 --> 00:09:25,519
can learn more or about the patterns

00:09:22,480 --> 00:09:25,519
that we're going to talk about today

00:09:26,000 --> 00:09:29,519
a brief aside a book that i've really

00:09:27,839 --> 00:09:30,800
enjoyed is

00:09:29,519 --> 00:09:32,640
there's another book called game

00:09:30,800 --> 00:09:34,000
programming patterns that also has a

00:09:32,640 --> 00:09:35,279
free web version if you want to get

00:09:34,000 --> 00:09:36,880
started right away

00:09:35,279 --> 00:09:39,760
i also have a physical copy because i've

00:09:36,880 --> 00:09:42,000
really enjoyed that book

00:09:39,760 --> 00:09:43,839
so both of these books whichever you

00:09:42,000 --> 00:09:45,920
decide to jump into have

00:09:43,839 --> 00:09:48,000
some reusable templates to help us solve

00:09:45,920 --> 00:09:49,279
problems that keep reoccurring in

00:09:48,000 --> 00:09:51,600
software

00:09:49,279 --> 00:09:53,440
and again what this design pattern book

00:09:51,600 --> 00:09:54,800
does a nice job doing is categorizing

00:09:53,440 --> 00:09:55,760
the design patterns into three

00:09:54,800 --> 00:09:58,240
categories

00:09:55,760 --> 00:10:01,200
creational patterns structural patterns

00:09:58,240 --> 00:10:01,200
and behavioral

00:10:01,600 --> 00:10:04,720
so there's three categories of design

00:10:03,440 --> 00:10:06,240
pattern we're going to look at one

00:10:04,720 --> 00:10:07,600
design pattern

00:10:06,240 --> 00:10:10,240
in each of these categories throughout

00:10:07,600 --> 00:10:12,959
this talk creational patterns

00:10:10,240 --> 00:10:14,959
the general idea is that you're

00:10:12,959 --> 00:10:15,680
providing your program more flexibility

00:10:14,959 --> 00:10:18,160
in how you

00:10:15,680 --> 00:10:19,120
create the objects that is that you're

00:10:18,160 --> 00:10:23,040
giving

00:10:19,120 --> 00:10:25,279
um you know more control for how some

00:10:23,040 --> 00:10:26,800
objects instantiated or created or just

00:10:25,279 --> 00:10:28,480
removing how you have to think about

00:10:26,800 --> 00:10:30,079
that problem

00:10:28,480 --> 00:10:32,160
structural design patterns have to do

00:10:30,079 --> 00:10:33,760
with using inheritance or maybe

00:10:32,160 --> 00:10:36,880
composition

00:10:33,760 --> 00:10:38,880
to get a new functionality and

00:10:36,880 --> 00:10:40,800
behavioral patterns focus on how

00:10:38,880 --> 00:10:42,320
communication is done between objects

00:10:40,800 --> 00:10:44,320
that's the high level idea of each of

00:10:42,320 --> 00:10:45,839
them

00:10:44,320 --> 00:10:47,360
okay so i'm going to help us pick the

00:10:45,839 --> 00:10:48,399
first pattern to solve our original

00:10:47,360 --> 00:10:50,480
problem

00:10:48,399 --> 00:10:53,440
with our screen saver for the job that

00:10:50,480 --> 00:10:53,440
we've been hired to do

00:10:54,640 --> 00:11:00,399
and this first one is a creational

00:10:56,800 --> 00:11:02,640
design pattern

00:11:00,399 --> 00:11:03,519
okay so creational design patterns again

00:11:02,640 --> 00:11:06,560
deal with how

00:11:03,519 --> 00:11:07,920
objects are instantiated uh often

00:11:06,560 --> 00:11:10,640
providing some sort of

00:11:07,920 --> 00:11:11,040
abstraction in the process meaning you

00:11:10,640 --> 00:11:13,279
can

00:11:11,040 --> 00:11:14,959
you know call a constructor or some

00:11:13,279 --> 00:11:16,640
member function and it'll just take care

00:11:14,959 --> 00:11:18,079
of how the objects created they'll

00:11:16,640 --> 00:11:20,079
figure out what the object is

00:11:18,079 --> 00:11:21,200
what the type is maybe some default

00:11:20,079 --> 00:11:23,120
values

00:11:21,200 --> 00:11:25,519
that's the idea to remove a lot of that

00:11:23,120 --> 00:11:26,399
thinking that goes on with the creation

00:11:25,519 --> 00:11:28,079
design pattern

00:11:26,399 --> 00:11:30,320
or rather than remove the thinking just

00:11:28,079 --> 00:11:33,200
make it so it does the right thing

00:11:30,320 --> 00:11:33,200
that you intended

00:11:34,240 --> 00:11:38,320
okay so let's look again at the problem

00:11:36,560 --> 00:11:40,800
that we're trying to solve

00:11:38,320 --> 00:11:42,000
we want to be able to reference this

00:11:40,800 --> 00:11:47,279
window height

00:11:42,000 --> 00:11:49,440
and window width here ideally globally

00:11:47,279 --> 00:11:50,720
but we only want one instance of these

00:11:49,440 --> 00:11:53,680
values to keep track of

00:11:50,720 --> 00:11:55,200
in case someone names something similar

00:11:53,680 --> 00:11:56,160
and we want them to sort of be grouped

00:11:55,200 --> 00:11:57,680
together window

00:11:56,160 --> 00:11:59,200
height and window width since they're

00:11:57,680 --> 00:12:01,200
related because maybe we'll want to

00:11:59,200 --> 00:12:03,839
write some behaviors that compute maybe

00:12:01,200 --> 00:12:06,800
a aspect ratio or things that will be

00:12:03,839 --> 00:12:09,519
uh useful for dealing with you know

00:12:06,800 --> 00:12:13,440
window size or general configuration

00:12:09,519 --> 00:12:14,560
settings okay so let's take a look at

00:12:13,440 --> 00:12:18,639
the singleton

00:12:14,560 --> 00:12:20,560
pattern so the singleton

00:12:18,639 --> 00:12:22,639
the main idea is that it's going to

00:12:20,560 --> 00:12:24,560
enforce the existence of only one

00:12:22,639 --> 00:12:26,240
instance of an object being created

00:12:24,560 --> 00:12:28,079
so this is like a global variable we

00:12:26,240 --> 00:12:30,959
only want one

00:12:28,079 --> 00:12:31,839
value in general but this is going to

00:12:30,959 --> 00:12:34,720
enforce that

00:12:31,839 --> 00:12:35,440
existence okay so again this means we

00:12:34,720 --> 00:12:36,959
can store

00:12:35,440 --> 00:12:39,200
all of our configuration values in

00:12:36,959 --> 00:12:40,399
exactly one place know exactly where to

00:12:39,200 --> 00:12:41,839
find them

00:12:40,399 --> 00:12:44,160
and make sure we don't have duplicates

00:12:41,839 --> 00:12:47,279
or different values

00:12:44,160 --> 00:12:49,279
okay so here's the pattern again

00:12:47,279 --> 00:12:51,279
common use cases for the singleton

00:12:49,279 --> 00:12:53,600
pattern where i've seen it in the wild

00:12:51,279 --> 00:12:55,680
or typical use cases you'll see

00:12:53,600 --> 00:12:57,040
when explaining the singleton pattern or

00:12:55,680 --> 00:13:00,000
managing files

00:12:57,040 --> 00:13:01,200
so file system ideally you just have uh

00:13:00,000 --> 00:13:02,959
one

00:13:01,200 --> 00:13:05,040
and sometimes this is thought of two

00:13:02,959 --> 00:13:06,959
with a sort of resource manager

00:13:05,040 --> 00:13:09,279
so maybe you're managing specific types

00:13:06,959 --> 00:13:11,120
of data like loading images or audio

00:13:09,279 --> 00:13:14,000
files i want to make sure you only

00:13:11,120 --> 00:13:15,360
load one copy of those files file

00:13:14,000 --> 00:13:17,920
loggers so if you're doing some

00:13:15,360 --> 00:13:20,399
debugging or just outputting text

00:13:17,920 --> 00:13:20,959
usually you only want or you might only

00:13:20,399 --> 00:13:23,040
want

00:13:20,959 --> 00:13:24,160
one instance of those loggers to put

00:13:23,040 --> 00:13:26,639
messages in a

00:13:24,160 --> 00:13:28,160
centralized database and also

00:13:26,639 --> 00:13:29,279
configuration manager which is what

00:13:28,160 --> 00:13:31,279
we're going to build

00:13:29,279 --> 00:13:32,880
just hold some global configuration

00:13:31,279 --> 00:13:34,399
value that you want the same

00:13:32,880 --> 00:13:37,440
so this is what we're interested in this

00:13:34,399 --> 00:13:37,440
is the option that we want

00:13:38,000 --> 00:13:41,360
okay so let's actually do some

00:13:40,240 --> 00:13:45,040
refactoring

00:13:41,360 --> 00:13:46,800
and solve the first task here

00:13:45,040 --> 00:13:48,160
so the first task or the first thing

00:13:46,800 --> 00:13:50,560
that i want to do is

00:13:48,160 --> 00:13:52,160
from our code actually remove this

00:13:50,560 --> 00:13:54,000
global variable

00:13:52,160 --> 00:13:56,160
we're going to remove it from where it

00:13:54,000 --> 00:13:58,800
was standing whatever

00:13:56,160 --> 00:14:00,399
c plus file doesn't matter but we want

00:13:58,800 --> 00:14:01,920
to move it to a standardized

00:14:00,399 --> 00:14:03,279
location and again i'm moving both of

00:14:01,920 --> 00:14:03,680
them together because now they're sort

00:14:03,279 --> 00:14:06,880
of

00:14:03,680 --> 00:14:09,040
grouped together which is nice

00:14:06,880 --> 00:14:10,079
so we're going to move our globals from

00:14:09,040 --> 00:14:12,880
one file

00:14:10,079 --> 00:14:14,399
and build a new class called the

00:14:12,880 --> 00:14:16,720
configuration manager

00:14:14,399 --> 00:14:17,920
i can name this whatever you want but

00:14:16,720 --> 00:14:21,279
something uh

00:14:17,920 --> 00:14:22,320
standard so the configuration manager is

00:14:21,279 --> 00:14:24,399
going to be our

00:14:22,320 --> 00:14:25,920
demonstrate our singleton pattern where

00:14:24,399 --> 00:14:30,160
we'll just access and share

00:14:25,920 --> 00:14:32,240
data in one place

00:14:30,160 --> 00:14:33,360
okay so let's take a little closer look

00:14:32,240 --> 00:14:37,839
at the c plus plus

00:14:33,360 --> 00:14:40,079
uh since we're here at c plus boscon uh

00:14:37,839 --> 00:14:40,880
starting from the bottom we have our

00:14:40,079 --> 00:14:42,720
window width

00:14:40,880 --> 00:14:44,480
and our window height so those are the

00:14:42,720 --> 00:14:46,800
two uh

00:14:44,480 --> 00:14:49,279
variables that store the window width

00:14:46,800 --> 00:14:51,360
and height that we want to keep track of

00:14:49,279 --> 00:14:53,279
i've prefixed them with m underscore

00:14:51,360 --> 00:14:56,839
because they're member variables now

00:14:53,279 --> 00:14:58,240
of a class that's just a hint for me

00:14:56,839 --> 00:15:00,560
stylistically

00:14:58,240 --> 00:15:02,160
in order to access our member variables

00:15:00,560 --> 00:15:04,880
then i've also written some

00:15:02,160 --> 00:15:06,880
getter functions and setter functions

00:15:04,880 --> 00:15:12,959
just to

00:15:06,880 --> 00:15:15,040
make sure we can access these as needed

00:15:12,959 --> 00:15:16,320
and the real interesting part of the

00:15:15,040 --> 00:15:19,760
singleton pattern

00:15:16,320 --> 00:15:22,880
uh comes here um you'll notice

00:15:19,760 --> 00:15:24,880
i don't really have um a constructor or

00:15:22,880 --> 00:15:26,639
i do have one but it's actually

00:15:24,880 --> 00:15:28,720
been marked private here so the

00:15:26,639 --> 00:15:30,000
constructor and the destructor in fact

00:15:28,720 --> 00:15:32,800
have been hidden

00:15:30,000 --> 00:15:34,320
but what i do have remaining is one

00:15:32,800 --> 00:15:37,600
public function here

00:15:34,320 --> 00:15:38,160
called instance an instance is going to

00:15:37,600 --> 00:15:41,360
be

00:15:38,160 --> 00:15:44,240
in charge of handling how an object is

00:15:41,360 --> 00:15:46,160
created or used in the singleton pattern

00:15:44,240 --> 00:15:48,240
so just going line by line here at the

00:15:46,160 --> 00:15:50,480
first line i have static configuration

00:15:48,240 --> 00:15:53,120
manager so this is going to create some

00:15:50,480 --> 00:15:54,000
static pointer here to configuration

00:15:53,120 --> 00:15:57,040
manager

00:15:54,000 --> 00:15:57,759
um and allocate a new one now in c plus

00:15:57,040 --> 00:15:59,519
plus

00:15:57,759 --> 00:16:02,000
11 and beyond we have this guarantee

00:15:59,519 --> 00:16:04,480
that we'll only have this initialized

00:16:02,000 --> 00:16:06,000
this static variable initialized once so

00:16:04,480 --> 00:16:07,920
i could rewrite this as

00:16:06,000 --> 00:16:10,160
if configuration you know if some

00:16:07,920 --> 00:16:12,560
instance is null or so on

00:16:10,160 --> 00:16:13,440
um and have a instance variable here but

00:16:12,560 --> 00:16:16,160
i've chosen to just

00:16:13,440 --> 00:16:17,680
sort of use a modern style here but this

00:16:16,160 --> 00:16:20,240
is going to

00:16:17,680 --> 00:16:20,880
allocate our new instance if it hasn't

00:16:20,240 --> 00:16:22,720
already

00:16:20,880 --> 00:16:24,240
and then any time that we use instance

00:16:22,720 --> 00:16:27,279
it's going to return

00:16:24,240 --> 00:16:30,480
that instance to us a reference to it

00:16:27,279 --> 00:16:33,120
okay so now if we work through

00:16:30,480 --> 00:16:34,880
this instance function we'll always be

00:16:33,120 --> 00:16:37,920
working with the same

00:16:34,880 --> 00:16:39,680
instance of this class which holds you

00:16:37,920 --> 00:16:40,000
know this piece of data here our window

00:16:39,680 --> 00:16:42,639
with

00:16:40,000 --> 00:16:42,639
our window height

00:16:43,920 --> 00:16:49,360
okay okay so now we've successfully

00:16:48,160 --> 00:16:51,839
encapsulated how

00:16:49,360 --> 00:16:53,279
objects created and we've restricted

00:16:51,839 --> 00:16:55,839
this access to just create

00:16:53,279 --> 00:16:57,519
exactly one instance of the singleton

00:16:55,839 --> 00:16:59,440
okay and that's what our configuration

00:16:57,519 --> 00:17:00,399
manager is doing it's now satisfied that

00:16:59,440 --> 00:17:04,880
singleton

00:17:00,399 --> 00:17:07,120
uh pattern okay so here's an actual uh

00:17:04,880 --> 00:17:08,559
example of using the singleton again

00:17:07,120 --> 00:17:11,439
because we're trying to

00:17:08,559 --> 00:17:12,480
solve our problem and just how to use

00:17:11,439 --> 00:17:16,880
our

00:17:12,480 --> 00:17:16,880
member functions uh through the instance

00:17:17,039 --> 00:17:22,240
member function uh and again

00:17:20,079 --> 00:17:23,360
because we're always going through that

00:17:22,240 --> 00:17:26,000
same instance

00:17:23,360 --> 00:17:26,640
uh here that's returned we get the same

00:17:26,000 --> 00:17:28,480
values

00:17:26,640 --> 00:17:30,080
so in my configuration manager i might

00:17:28,480 --> 00:17:30,720
do a little bit of setup somewhere in my

00:17:30,080 --> 00:17:32,480
program

00:17:30,720 --> 00:17:34,160
and set the window width and the window

00:17:32,480 --> 00:17:36,080
height as needed

00:17:34,160 --> 00:17:38,240
and then anytime i need to access the

00:17:36,080 --> 00:17:39,760
window with in the window height

00:17:38,240 --> 00:17:41,760
i can get the same vibe by doing the

00:17:39,760 --> 00:17:44,320
configuration manager

00:17:41,760 --> 00:17:45,760
calling the static member function

00:17:44,320 --> 00:17:48,640
instance and then returning

00:17:45,760 --> 00:17:48,640
its width

00:17:49,840 --> 00:17:53,280
okay so let's actually solve our problem

00:17:52,480 --> 00:17:55,840
so in

00:17:53,280 --> 00:17:56,799
our circle constructor where we had

00:17:55,840 --> 00:17:59,520
those uh

00:17:56,799 --> 00:18:00,000
hard-coded values previously we can now

00:17:59,520 --> 00:18:02,720
access

00:18:00,000 --> 00:18:04,640
through the configuration manager here

00:18:02,720 --> 00:18:06,799
so configuration manager instance

00:18:04,640 --> 00:18:08,799
get the window with in the window height

00:18:06,799 --> 00:18:09,600
from here and all i've had to do is

00:18:08,799 --> 00:18:12,840
include

00:18:09,600 --> 00:18:14,160
the configuration manager header file to

00:18:12,840 --> 00:18:16,480
juice

00:18:14,160 --> 00:18:18,000
okay so let's see for a moment if this

00:18:16,480 --> 00:18:19,760
solved our problem our fingers are

00:18:18,000 --> 00:18:22,080
crossed

00:18:19,760 --> 00:18:23,679
and if you watch this animation from the

00:18:22,080 --> 00:18:25,679
start you'll notice

00:18:23,679 --> 00:18:26,880
uh we have circles that spawn the whole

00:18:25,679 --> 00:18:29,039
range of a screen

00:18:26,880 --> 00:18:30,960
so i'll let it play uh one more time

00:18:29,039 --> 00:18:34,320
here just so you can see

00:18:30,960 --> 00:18:35,840
from the start i'll give a little uh

00:18:34,320 --> 00:18:37,360
you'll see a little countdown message

00:18:35,840 --> 00:18:39,520
here and you should see circles

00:18:37,360 --> 00:18:41,039
spawning all over the place and you're

00:18:39,520 --> 00:18:43,280
gonna find it's much more

00:18:41,039 --> 00:18:45,200
visually appearing so here we go and

00:18:43,280 --> 00:18:46,799
voila much better effect

00:18:45,200 --> 00:18:50,000
uh your boss and your colleagues are

00:18:46,799 --> 00:18:50,000
much more happy to see this

00:18:51,280 --> 00:18:57,840
okay so let me wrap up our first pattern

00:18:54,320 --> 00:18:57,840
on the singleton

00:18:58,160 --> 00:19:01,520
so some pros and cons with design

00:19:00,240 --> 00:19:02,160
patterns because something i want to

00:19:01,520 --> 00:19:05,440
talk about

00:19:02,160 --> 00:19:06,960
is i'm going to give you some recipes or

00:19:05,440 --> 00:19:07,679
some templates that you can use in your

00:19:06,960 --> 00:19:09,280
code

00:19:07,679 --> 00:19:11,039
but you have to apply them in the right

00:19:09,280 --> 00:19:12,480
place you have to understand as with

00:19:11,039 --> 00:19:13,840
everything in computer science there are

00:19:12,480 --> 00:19:16,080
some trade-offs

00:19:13,840 --> 00:19:17,760
for when to use something versus when

00:19:16,080 --> 00:19:20,080
not to use something

00:19:17,760 --> 00:19:22,480
so the pros for the singleton in general

00:19:20,080 --> 00:19:26,240
it's easy overall to implement

00:19:22,480 --> 00:19:29,520
you saw how i used that uh one instance

00:19:26,240 --> 00:19:32,160
uh member function to access the same

00:19:29,520 --> 00:19:33,520
object that had been instantiated and

00:19:32,160 --> 00:19:35,520
you also saw that i

00:19:33,520 --> 00:19:37,679
hid the constructors and did some work

00:19:35,520 --> 00:19:40,400
there overall pretty easy

00:19:37,679 --> 00:19:42,080
implementation and this can be effective

00:19:40,400 --> 00:19:42,960
when you know you only need one of

00:19:42,080 --> 00:19:44,720
something

00:19:42,960 --> 00:19:46,559
conventional wisdom says not to use

00:19:44,720 --> 00:19:48,240
global variables but sometimes you need

00:19:46,559 --> 00:19:49,840
to there's valid reasons too

00:19:48,240 --> 00:19:52,559
and when you know you only need one of

00:19:49,840 --> 00:19:55,600
something a singleton pattern can be

00:19:52,559 --> 00:19:57,679
uh good for this when you use the

00:19:55,600 --> 00:19:59,679
singleton you're also avoiding

00:19:57,679 --> 00:20:01,440
polluting the global namespace with lots

00:19:59,679 --> 00:20:02,240
of variables so instead of having lots

00:20:01,440 --> 00:20:04,720
of variables

00:20:02,240 --> 00:20:06,559
like window height and window width and

00:20:04,720 --> 00:20:09,600
they sort of you know

00:20:06,559 --> 00:20:12,400
freestanding uh variables of

00:20:09,600 --> 00:20:13,760
primitive data types you know the global

00:20:12,400 --> 00:20:15,600
namespace

00:20:13,760 --> 00:20:17,919
gets a lot less polluted so it's easier

00:20:15,600 --> 00:20:19,760
to debug in that way

00:20:17,919 --> 00:20:21,360
another advantage of the singleton is

00:20:19,760 --> 00:20:23,120
the memory is only allocated if you

00:20:21,360 --> 00:20:24,880
actually use the singleton

00:20:23,120 --> 00:20:26,559
so if you are just doing occasional

00:20:24,880 --> 00:20:29,360
logging or perhaps have a

00:20:26,559 --> 00:20:30,720
debug versus a release program we're

00:20:29,360 --> 00:20:31,280
taking advantage of some singleton

00:20:30,720 --> 00:20:32,840
classes

00:20:31,280 --> 00:20:34,960
you're not allocating all these

00:20:32,840 --> 00:20:38,320
variables um

00:20:34,960 --> 00:20:40,640
in the uh in the heap so that can be an

00:20:38,320 --> 00:20:42,799
advantage of the singleton

00:20:40,640 --> 00:20:43,840
uh some cons with the singleton is the

00:20:42,799 --> 00:20:47,039
wrong usage

00:20:43,840 --> 00:20:48,000
could take uh some refactoring meaning

00:20:47,039 --> 00:20:50,159
you know if you actually do

00:20:48,000 --> 00:20:51,600
decide hey i need two loggers because

00:20:50,159 --> 00:20:54,159
i'm gonna do something

00:20:51,600 --> 00:20:56,080
uh with threads or whatever then you do

00:20:54,159 --> 00:20:57,280
have to do some refactoring and think

00:20:56,080 --> 00:20:58,000
about how you're gonna structure your

00:20:57,280 --> 00:20:59,200
program

00:20:58,000 --> 00:21:01,360
uh so again you have to think about

00:20:59,200 --> 00:21:04,559
carefully do i need exactly

00:21:01,360 --> 00:21:07,600
one of these objects

00:21:04,559 --> 00:21:08,559
the singleton as i've written it is not

00:21:07,600 --> 00:21:11,039
necessarily

00:21:08,559 --> 00:21:12,559
thread safe you know it's thread safe in

00:21:11,039 --> 00:21:15,679
the stance that when i

00:21:12,559 --> 00:21:18,559
uh initialized

00:21:15,679 --> 00:21:20,080
the the object i'm only going to get one

00:21:18,559 --> 00:21:21,840
back and should get the

00:21:20,080 --> 00:21:23,600
same one back but if i'm doing other

00:21:21,840 --> 00:21:25,679
stuff within the singleton class like

00:21:23,600 --> 00:21:27,600
logging or changing data

00:21:25,679 --> 00:21:30,000
i'm likely going to have to add a lock

00:21:27,600 --> 00:21:32,480
or use some other atomic data structure

00:21:30,000 --> 00:21:33,360
just to make sure that i don't get race

00:21:32,480 --> 00:21:36,400
conditions

00:21:33,360 --> 00:21:38,000
um data races and so on so you have to

00:21:36,400 --> 00:21:41,120
be a little bit careful

00:21:38,000 --> 00:21:42,880
if thread safety is an issue

00:21:41,120 --> 00:21:44,320
and the other con is again you are still

00:21:42,880 --> 00:21:47,120
effectively using

00:21:44,320 --> 00:21:48,240
global variables so keep that in mind

00:21:47,120 --> 00:21:51,200
you do have

00:21:48,240 --> 00:21:53,440
objects um that are going to live you

00:21:51,200 --> 00:21:55,440
know the duration of your

00:21:53,440 --> 00:21:56,960
program so keep that in mind if you're

00:21:55,440 --> 00:21:59,679
going to have a really really big

00:21:56,960 --> 00:22:01,600
singleton class that's maybe just going

00:21:59,679 --> 00:22:04,080
to allocate a lot of stuff and not

00:22:01,600 --> 00:22:04,080
clean it up

00:22:04,960 --> 00:22:08,320
there's a few more missing details i

00:22:07,200 --> 00:22:11,200
want to provide

00:22:08,320 --> 00:22:12,159
because i've given a singleton design

00:22:11,200 --> 00:22:14,480
pattern solution

00:22:12,159 --> 00:22:16,559
that i think works well for this use

00:22:14,480 --> 00:22:18,960
case or at least for uh teaching it

00:22:16,559 --> 00:22:19,600
um but the gang of four book uh goes

00:22:18,960 --> 00:22:21,760
through some

00:22:19,600 --> 00:22:23,200
some more interesting details and design

00:22:21,760 --> 00:22:24,000
considerations that i just want to put

00:22:23,200 --> 00:22:27,200
on uh

00:22:24,000 --> 00:22:28,480
the table here um so in my code example

00:22:27,200 --> 00:22:30,159
for instance you might want to again

00:22:28,480 --> 00:22:33,039
think carefully about

00:22:30,159 --> 00:22:33,679
hiding the copy constructors um to make

00:22:33,039 --> 00:22:36,559
this

00:22:33,679 --> 00:22:38,240
uh object non-copyable because otherwise

00:22:36,559 --> 00:22:39,360
you can sort of get around having uh one

00:22:38,240 --> 00:22:41,679
instance

00:22:39,360 --> 00:22:43,919
um you'll also want to think about if a

00:22:41,679 --> 00:22:44,720
client can subclass from your singleton

00:22:43,919 --> 00:22:47,440
or not

00:22:44,720 --> 00:22:48,000
meaning can i inherit from the singleton

00:22:47,440 --> 00:22:51,440
class

00:22:48,000 --> 00:22:54,000
and build other types from it

00:22:51,440 --> 00:22:55,600
so that can be sort of a pro and a con

00:22:54,000 --> 00:22:59,200
and you can prevent that

00:22:55,600 --> 00:22:59,440
if you like again thread safety might be

00:22:59,200 --> 00:23:02,159
an

00:22:59,440 --> 00:23:03,600
issue so you know choose your data

00:23:02,159 --> 00:23:06,480
structures

00:23:03,600 --> 00:23:10,559
within the singleton class that you need

00:23:06,480 --> 00:23:13,200
such as locks or atomic data structures

00:23:10,559 --> 00:23:14,799
if you do find that you need multiple

00:23:13,200 --> 00:23:17,679
instances of a class

00:23:14,799 --> 00:23:18,640
but you are trying to have some common

00:23:17,679 --> 00:23:20,400
ground

00:23:18,640 --> 00:23:22,559
there's another similar pattern it's

00:23:20,400 --> 00:23:24,400
called the mono state pattern

00:23:22,559 --> 00:23:26,400
which makes use of static member

00:23:24,400 --> 00:23:27,440
variables again the idea being that you

00:23:26,400 --> 00:23:30,000
could have

00:23:27,440 --> 00:23:32,240
a lot of shared state amongst different

00:23:30,000 --> 00:23:34,159
instances of objects

00:23:32,240 --> 00:23:35,760
so in our example maybe if we have

00:23:34,159 --> 00:23:37,280
multiple windows and we know they're all

00:23:35,760 --> 00:23:39,520
going to be the same height

00:23:37,280 --> 00:23:41,760
but you know a different title bar for

00:23:39,520 --> 00:23:43,279
example we might consider the mono state

00:23:41,760 --> 00:23:47,200
pattern

00:23:43,279 --> 00:23:49,440
for instead of the single spin okay

00:23:47,200 --> 00:23:50,960
and be careful if you're returning a

00:23:49,440 --> 00:23:54,240
pointer versus a reference

00:23:50,960 --> 00:23:57,120
in your instance member function

00:23:54,240 --> 00:23:57,440
um it could be a gotcha it'll still work

00:23:57,120 --> 00:23:59,279
but

00:23:57,440 --> 00:24:01,600
you know a client might decide that it's

00:23:59,279 --> 00:24:05,039
a pointer so they want to delete it

00:24:01,600 --> 00:24:06,880
and reclaim some memory so maybe you do

00:24:05,039 --> 00:24:08,960
want that ability to delete it

00:24:06,880 --> 00:24:10,159
maybe you don't just be a little bit

00:24:08,960 --> 00:24:11,840
careful

00:24:10,159 --> 00:24:13,840
about that so you're going to have to

00:24:11,840 --> 00:24:15,200
design this pattern up to your

00:24:13,840 --> 00:24:18,159
specifications

00:24:15,200 --> 00:24:19,279
but you have the high level idea now

00:24:18,159 --> 00:24:21,279
okay so more on the

00:24:19,279 --> 00:24:22,559
the singleton pattern i think the game

00:24:21,279 --> 00:24:24,799
programming book

00:24:22,559 --> 00:24:25,919
uh game programming patterns book does a

00:24:24,799 --> 00:24:27,600
nice description

00:24:25,919 --> 00:24:29,840
as well as the gang of four books so

00:24:27,600 --> 00:24:33,760
read both of them see the use cases

00:24:29,840 --> 00:24:36,880
and apply as needed

00:24:33,760 --> 00:24:38,720
okay so with that in mind

00:24:36,880 --> 00:24:40,880
i see some questions coming in which

00:24:38,720 --> 00:24:44,840
i'll address at the end

00:24:40,880 --> 00:24:46,240
i want to move us on to our next

00:24:44,840 --> 00:24:48,000
challenge

00:24:46,240 --> 00:24:50,720
uh and the next challenge is you know

00:24:48,000 --> 00:24:52,880
your colleagues and and bosses and so on

00:24:50,720 --> 00:24:54,320
uh have been impressed with your your

00:24:52,880 --> 00:24:55,120
work and your implementation of the the

00:24:54,320 --> 00:24:57,520
singleton

00:24:55,120 --> 00:24:59,279
they're giving you some more work this

00:24:57,520 --> 00:25:00,000
time your boss wants to put the company

00:24:59,279 --> 00:25:02,960
logo on every

00:25:00,000 --> 00:25:04,559
screen saver okay so screen saver

00:25:02,960 --> 00:25:06,159
company here it is

00:25:04,559 --> 00:25:09,840
and it's going to be attached to every

00:25:06,159 --> 00:25:09,840
screen saver just at the top here

00:25:10,080 --> 00:25:14,880
and your colleague and you are working

00:25:12,480 --> 00:25:16,880
on this problem and

00:25:14,880 --> 00:25:18,080
your colleagues working on this text

00:25:16,880 --> 00:25:20,159
rendering system

00:25:18,080 --> 00:25:21,760
okay and it's a legacy text rendering

00:25:20,159 --> 00:25:23,360
system it's been around for a really

00:25:21,760 --> 00:25:25,200
really long time

00:25:23,360 --> 00:25:27,200
it involves a lot of work where you have

00:25:25,200 --> 00:25:29,919
to load font files

00:25:27,200 --> 00:25:31,200
you have a custom string class in the

00:25:29,919 --> 00:25:33,360
background

00:25:31,200 --> 00:25:34,400
some logic of sort of how you draw

00:25:33,360 --> 00:25:36,960
objects and draw

00:25:34,400 --> 00:25:39,440
text and another drawable object class

00:25:36,960 --> 00:25:42,960
and this hierarchy is very very deep

00:25:39,440 --> 00:25:45,440
of inheritance um in oak by the way

00:25:42,960 --> 00:25:46,000
the boss wants all of this text to

00:25:45,440 --> 00:25:48,320
always be

00:25:46,000 --> 00:25:50,960
green and uppercase letters because

00:25:48,320 --> 00:25:55,279
that's going to be consistent with your

00:25:50,960 --> 00:25:55,279
your company's logo and company colors

00:25:55,600 --> 00:25:59,760
okay so the problem that we're trying to

00:25:57,600 --> 00:26:02,880
solve here in our second task

00:25:59,760 --> 00:26:04,559
is uh we have some you know text that

00:26:02,880 --> 00:26:07,360
must always be uniform

00:26:04,559 --> 00:26:09,200
uh and this is the the current interface

00:26:07,360 --> 00:26:11,760
that we have the current uh data type

00:26:09,200 --> 00:26:13,279
this text class

00:26:11,760 --> 00:26:15,039
and this is based off of some

00:26:13,279 --> 00:26:17,279
third-party code in fact it's from

00:26:15,039 --> 00:26:20,799
another library called the simple fast

00:26:17,279 --> 00:26:22,840
media library which i'll link at the end

00:26:20,799 --> 00:26:25,039
but we don't own this so we can't

00:26:22,840 --> 00:26:26,000
necessarily uh change it or at least i

00:26:25,039 --> 00:26:29,600
as the programmer don't

00:26:26,000 --> 00:26:31,679
own it for for my task um so

00:26:29,600 --> 00:26:33,039
you know there's potentially a lot of

00:26:31,679 --> 00:26:34,799
steps to fit

00:26:33,039 --> 00:26:36,720
if we want to fit our specification

00:26:34,799 --> 00:26:39,279
meaning we had to set the

00:26:36,720 --> 00:26:40,640
uh particular font or the particular

00:26:39,279 --> 00:26:42,880
color

00:26:40,640 --> 00:26:44,559
in the uppercase the letters and so

00:26:42,880 --> 00:26:46,480
forth

00:26:44,559 --> 00:26:48,320
so one possible solution you might think

00:26:46,480 --> 00:26:50,159
of is you know hey let's just

00:26:48,320 --> 00:26:52,000
write a function that you know we can

00:26:50,159 --> 00:26:56,400
pass this text object to and

00:26:52,000 --> 00:26:58,799
it sets up all the proper values

00:26:56,400 --> 00:27:00,080
and this works fine right we can take

00:26:58,799 --> 00:27:02,400
our uh

00:27:00,080 --> 00:27:04,240
reference to this text object and you

00:27:02,400 --> 00:27:05,840
know set the fill color set the font

00:27:04,240 --> 00:27:07,120
size you know step one step two step

00:27:05,840 --> 00:27:08,960
three however many steps that we have to

00:27:07,120 --> 00:27:11,440
do to get things uniform

00:27:08,960 --> 00:27:13,679
um but if we have to start changing

00:27:11,440 --> 00:27:14,320
other behaviors that's hard to just do

00:27:13,679 --> 00:27:15,679
from

00:27:14,320 --> 00:27:18,320
the function especially if we need to

00:27:15,679 --> 00:27:21,840
invent new behaviors on top of this

00:27:18,320 --> 00:27:21,840
uh particular data type

00:27:23,279 --> 00:27:27,279
okay so with this idea i want to

00:27:25,440 --> 00:27:29,440
introduce the second type

00:27:27,279 --> 00:27:31,760
of design pattern this is the structural

00:27:29,440 --> 00:27:35,120
design pattern our second category

00:27:31,760 --> 00:27:37,520
from the gang of four books

00:27:35,120 --> 00:27:40,159
structural design patterns focus on

00:27:37,520 --> 00:27:41,760
using inheritance to compose interfaces

00:27:40,159 --> 00:27:43,840
and create new objects

00:27:41,760 --> 00:27:48,559
inheritance and in one case we're going

00:27:43,840 --> 00:27:50,960
to look at one that uses composition

00:27:48,559 --> 00:27:51,840
so structural design patterns again are

00:27:50,960 --> 00:27:54,640
usually

00:27:51,840 --> 00:27:56,480
focusing on using inheritance to compose

00:27:54,640 --> 00:27:58,159
different interfaces and create a new

00:27:56,480 --> 00:27:59,360
object so in our case we're trying to

00:27:58,159 --> 00:28:02,399
create a new

00:27:59,360 --> 00:28:04,640
text class that are um

00:28:02,399 --> 00:28:05,760
that satisfies our clients demands or

00:28:04,640 --> 00:28:08,960
our bosses demands

00:28:05,760 --> 00:28:10,799
uh in this case okay uh with inheritance

00:28:08,960 --> 00:28:11,679
if we're inheriting properties uh from

00:28:10,799 --> 00:28:14,720
another object

00:28:11,679 --> 00:28:18,559
and we get all that objects um you know

00:28:14,720 --> 00:28:21,919
public and protected um interface

00:28:18,559 --> 00:28:23,679
and all those properties for us

00:28:21,919 --> 00:28:24,960
so now i'm going to show a design

00:28:23,679 --> 00:28:26,080
pattern that works off that it's

00:28:24,960 --> 00:28:28,159
something called the

00:28:26,080 --> 00:28:29,679
adapter pattern and there's several

00:28:28,159 --> 00:28:31,520
different implementations of the adapter

00:28:29,679 --> 00:28:32,799
pattern just like the the singleton with

00:28:31,520 --> 00:28:35,120
different variant

00:28:32,799 --> 00:28:36,960
variations to it but i'm going to show

00:28:35,120 --> 00:28:38,880
you adapter pattern

00:28:36,960 --> 00:28:40,640
specifically it's known as the object

00:28:38,880 --> 00:28:43,279
adapter pattern

00:28:40,640 --> 00:28:45,360
and just like you'd visualize an adapter

00:28:43,279 --> 00:28:48,080
for all the adapters that are out there

00:28:45,360 --> 00:28:49,360
this converts the interface of one class

00:28:48,080 --> 00:28:52,799
into another interface

00:28:49,360 --> 00:28:52,799
that the client expects

00:28:52,960 --> 00:28:58,880
okay so the common use case of this is

00:28:56,399 --> 00:29:00,880
when you want to write a wrapper class

00:28:58,880 --> 00:29:02,640
to update or otherwise make some

00:29:00,880 --> 00:29:04,720
interface work

00:29:02,640 --> 00:29:06,799
i've seen this with sort of updating

00:29:04,720 --> 00:29:10,399
legacy code bases to add

00:29:06,799 --> 00:29:12,880
new functionality i've also seen this

00:29:10,399 --> 00:29:13,679
very often with uh just making various

00:29:12,880 --> 00:29:15,440
you know string

00:29:13,679 --> 00:29:16,799
classes work together in different

00:29:15,440 --> 00:29:19,039
libraries where you want to update

00:29:16,799 --> 00:29:21,120
things or add different functionality

00:29:19,039 --> 00:29:23,200
and just make things work so anytime you

00:29:21,120 --> 00:29:25,760
need to wrap something up

00:29:23,200 --> 00:29:28,720
that can be um you know a use case for

00:29:25,760 --> 00:29:28,720
the adapter pattern

00:29:29,279 --> 00:29:33,919
okay uh and here's the analogy uh just

00:29:31,760 --> 00:29:37,520
to make it clear

00:29:33,919 --> 00:29:40,399
for those folks who have traveled across

00:29:37,520 --> 00:29:42,480
continents you can see if you've seen a

00:29:40,399 --> 00:29:44,720
different style wall outlet you often

00:29:42,480 --> 00:29:46,480
buy an adapter that lets you plug in you

00:29:44,720 --> 00:29:49,840
know your version of the outlet

00:29:46,480 --> 00:29:52,559
um into a different one okay

00:29:49,840 --> 00:29:53,360
so we're taking in our adapter which is

00:29:52,559 --> 00:29:55,679
going to be

00:29:53,360 --> 00:29:56,720
sort of the adaptee and able to plug it

00:29:55,679 --> 00:29:59,279
in by using this

00:29:56,720 --> 00:29:59,279
adapter

00:30:02,159 --> 00:30:07,440
okay so again we want to focus on the

00:30:05,200 --> 00:30:09,039
problem that we're actually solving

00:30:07,440 --> 00:30:11,840
and that we have a class here that's

00:30:09,039 --> 00:30:14,480
been provided it's from a third party

00:30:11,840 --> 00:30:14,880
to us as a programmer and we don't have

00:30:14,480 --> 00:30:18,000
the

00:30:14,880 --> 00:30:19,120
functionality that we quite need so we

00:30:18,000 --> 00:30:21,520
want to update our

00:30:19,120 --> 00:30:22,320
software and we also don't want to break

00:30:21,520 --> 00:30:24,640
our old

00:30:22,320 --> 00:30:25,440
uh functionality that did exist because

00:30:24,640 --> 00:30:27,200
um again

00:30:25,440 --> 00:30:28,559
you know this is a big company you can

00:30:27,200 --> 00:30:29,600
imagine yourself in this situation and

00:30:28,559 --> 00:30:33,760
we don't want to break

00:30:29,600 --> 00:30:33,760
this previous uh implementation

00:30:33,840 --> 00:30:37,440
okay so first take at the adapter

00:30:36,480 --> 00:30:40,159
pattern

00:30:37,440 --> 00:30:41,679
is uh to create a new class so here in

00:30:40,159 --> 00:30:45,120
this figure i've created class

00:30:41,679 --> 00:30:45,679
i call adapter text uh here and this is

00:30:45,120 --> 00:30:49,600
going to be

00:30:45,679 --> 00:30:52,640
our adapter and it's going to take

00:30:49,600 --> 00:30:53,279
our previous implementation of text and

00:30:52,640 --> 00:30:55,200
make it a

00:30:53,279 --> 00:30:57,120
member variable here i'm just going to

00:30:55,200 --> 00:30:58,320
call m underscore because it's a member

00:30:57,120 --> 00:31:01,519
variable and they are

00:30:58,320 --> 00:31:03,279
internal text okay so here we're making

00:31:01,519 --> 00:31:06,159
use of composition

00:31:03,279 --> 00:31:08,080
taking some other object and storing it

00:31:06,159 --> 00:31:11,039
in another

00:31:08,080 --> 00:31:11,919
and inside of our constructor it's going

00:31:11,039 --> 00:31:14,159
to take a

00:31:11,919 --> 00:31:16,000
text object as its input that's the sort

00:31:14,159 --> 00:31:18,799
of adaptation what i'm

00:31:16,000 --> 00:31:21,200
feeding into the adapter okay that's

00:31:18,799 --> 00:31:21,200
right here

00:31:23,120 --> 00:31:27,760
so again just a note there's many ways

00:31:25,039 --> 00:31:31,120
to implement the adapter pattern

00:31:27,760 --> 00:31:33,279
you could use inheritance to adapt this

00:31:31,120 --> 00:31:34,320
i think for demonstration this works

00:31:33,279 --> 00:31:37,360
well for the

00:31:34,320 --> 00:31:39,279
object adapter pattern um and you have

00:31:37,360 --> 00:31:41,120
to think about some things like how deep

00:31:39,279 --> 00:31:43,600
your hierarchy is and if you do use

00:31:41,120 --> 00:31:46,960
inheritance that you have to

00:31:43,600 --> 00:31:47,679
you know potentially implement a very

00:31:46,960 --> 00:31:49,679
big

00:31:47,679 --> 00:31:51,760
uh interface right all the virtual

00:31:49,679 --> 00:31:54,880
functions that come with it

00:31:51,760 --> 00:31:56,159
which could be a lot so this usage of

00:31:54,880 --> 00:31:59,200
composition

00:31:56,159 --> 00:32:02,240
this is why i've chosen composition for

00:31:59,200 --> 00:32:02,240
this adapter pattern

00:32:02,399 --> 00:32:07,519
okay so here's a

00:32:05,919 --> 00:32:09,120
a sort of implementation of our

00:32:07,519 --> 00:32:11,919
constructor

00:32:09,120 --> 00:32:14,000
as well as a new behavior that we need

00:32:11,919 --> 00:32:16,799
so i'm looking down here at this

00:32:14,000 --> 00:32:18,320
second block of code here where i've

00:32:16,799 --> 00:32:20,799
read in my

00:32:18,320 --> 00:32:21,519
internal adapter and then i'm going to

00:32:20,799 --> 00:32:22,880
do

00:32:21,519 --> 00:32:24,720
the things that we needed to do in our

00:32:22,880 --> 00:32:26,720
requirements you know set the character

00:32:24,720 --> 00:32:29,120
size to specific

00:32:26,720 --> 00:32:29,760
set set the color uh then i've got a

00:32:29,120 --> 00:32:32,320
little uh

00:32:29,760 --> 00:32:33,760
loop here for uh making sure that all of

00:32:32,320 --> 00:32:35,919
our characters are uppercase

00:32:33,760 --> 00:32:37,200
and then finally setting that string

00:32:35,919 --> 00:32:39,840
okay um so i've

00:32:37,200 --> 00:32:40,399
sort of adapted this object to fit our

00:32:39,840 --> 00:32:43,279
new

00:32:40,399 --> 00:32:44,559
uh interface that we need and then this

00:32:43,279 --> 00:32:46,399
second

00:32:44,559 --> 00:32:48,559
new behavior i have is how i can draw

00:32:46,399 --> 00:32:50,000
this object and i can add as many other

00:32:48,559 --> 00:32:51,840
behaviors as i need

00:32:50,000 --> 00:32:56,880
my adapter but i've added one here to

00:32:51,840 --> 00:32:59,919
actually draw

00:32:56,880 --> 00:33:02,399
okay so here's uh an ex uh the usage of

00:32:59,919 --> 00:33:04,159
our adapter uh pattern so here i'm

00:33:02,399 --> 00:33:04,799
looking at the code snippet in the top

00:33:04,159 --> 00:33:06,799
right

00:33:04,799 --> 00:33:09,120
uh where we have created a new adapter

00:33:06,799 --> 00:33:10,720
text uh here's our new

00:33:09,120 --> 00:33:12,399
object that we've instantiated and we're

00:33:10,720 --> 00:33:14,960
taking in our old

00:33:12,399 --> 00:33:16,320
text here and going to adapt it through

00:33:14,960 --> 00:33:19,120
this new object

00:33:16,320 --> 00:33:20,159
okay so it's just a very quick uh

00:33:19,120 --> 00:33:23,760
wrapper of a

00:33:20,159 --> 00:33:24,240
previous implementation and we see here

00:33:23,760 --> 00:33:27,279
that

00:33:24,240 --> 00:33:28,000
uh the text appears in uppercase it's

00:33:27,279 --> 00:33:29,679
always green

00:33:28,000 --> 00:33:31,360
it's the right font size you know

00:33:29,679 --> 00:33:32,559
whatever the other requirements are that

00:33:31,360 --> 00:33:34,320
you need to add

00:33:32,559 --> 00:33:37,120
can all be wrapped into this adapter

00:33:34,320 --> 00:33:38,399
text okay and then as needed you can add

00:33:37,120 --> 00:33:40,960
more functionality

00:33:38,399 --> 00:33:40,960
no problem

00:33:41,679 --> 00:33:45,360
okay so some pros and cons of the

00:33:43,679 --> 00:33:47,679
adapter pattern again every design

00:33:45,360 --> 00:33:50,640
pattern has some pros and cons

00:33:47,679 --> 00:33:52,480
the pros are we are a few of the pros

00:33:50,640 --> 00:33:53,120
are you know you allow classes with

00:33:52,480 --> 00:33:55,840
otherwise

00:33:53,120 --> 00:33:56,640
in incompatible interfaces to work uh

00:33:55,840 --> 00:33:59,919
together

00:33:56,640 --> 00:34:02,000
okay so you can sort of make things work

00:33:59,919 --> 00:34:02,640
you can grab the exact data that you

00:34:02,000 --> 00:34:06,399
need

00:34:02,640 --> 00:34:06,960
uh from some other class um or extract

00:34:06,399 --> 00:34:09,839
it

00:34:06,960 --> 00:34:11,359
the example i did for that which you can

00:34:09,839 --> 00:34:14,560
see it's a little bit subtle here

00:34:11,359 --> 00:34:17,839
is i'm grabbing in a string the

00:34:14,560 --> 00:34:20,159
text from this class here

00:34:17,839 --> 00:34:21,520
so that was a little bit hidden but you

00:34:20,159 --> 00:34:22,639
know i made it sort of

00:34:21,520 --> 00:34:24,480
work so i could grab each of the

00:34:22,639 --> 00:34:25,919
characters make them uppercase and then

00:34:24,480 --> 00:34:28,320
in my new object

00:34:25,919 --> 00:34:29,119
again set the string here or the

00:34:28,320 --> 00:34:33,359
internal

00:34:29,119 --> 00:34:35,760
object okay so overall this was

00:34:33,359 --> 00:34:36,800
uh this can also work very quickly this

00:34:35,760 --> 00:34:38,560
idea

00:34:36,800 --> 00:34:40,240
of the adapter and sort of wrapping a

00:34:38,560 --> 00:34:41,679
class and adding just a little tiny

00:34:40,240 --> 00:34:42,560
piece of functionality if you just need

00:34:41,679 --> 00:34:46,159
a small

00:34:42,560 --> 00:34:48,800
piece like we did now the cons for this

00:34:46,159 --> 00:34:49,919
is you may introduce more complexity

00:34:48,800 --> 00:34:51,440
into your code

00:34:49,919 --> 00:34:53,440
so you can imagine me seeing this

00:34:51,440 --> 00:34:56,079
pattern saying wow that was easy

00:34:53,440 --> 00:34:57,119
um now i'm just going to you know wrap

00:34:56,079 --> 00:34:58,880
every other

00:34:57,119 --> 00:35:00,320
type into its own sort of unique

00:34:58,880 --> 00:35:02,240
instance

00:35:00,320 --> 00:35:03,520
of another you know data type that i

00:35:02,240 --> 00:35:03,760
need and then all of a sudden if you

00:35:03,520 --> 00:35:05,200
have

00:35:03,760 --> 00:35:07,119
lots and lots of different data types

00:35:05,200 --> 00:35:09,200
with just slight variations

00:35:07,119 --> 00:35:11,359
um you've introduced a lot of complexity

00:35:09,200 --> 00:35:14,480
in your code potentially

00:35:11,359 --> 00:35:17,680
so be a little bit careful with

00:35:14,480 --> 00:35:19,440
uh with that with the adapter pattern it

00:35:17,680 --> 00:35:22,320
also might be just worth noting

00:35:19,440 --> 00:35:23,599
if you do own the code so in our case

00:35:22,320 --> 00:35:25,920
the text

00:35:23,599 --> 00:35:27,200
class it might be worth it to just

00:35:25,920 --> 00:35:29,440
update

00:35:27,200 --> 00:35:31,200
that actual class if you know you'll

00:35:29,440 --> 00:35:32,800
need this functionality going forward

00:35:31,200 --> 00:35:35,520
so again just make sure you're solving

00:35:32,800 --> 00:35:35,520
the right problem

00:35:35,599 --> 00:35:40,480
in my particular example one of the cons

00:35:38,640 --> 00:35:42,640
might be you know you see in these

00:35:40,480 --> 00:35:44,400
snippets is that you might be making

00:35:42,640 --> 00:35:45,680
extra copies when you're wrapping the

00:35:44,400 --> 00:35:47,839
object

00:35:45,680 --> 00:35:48,800
so just be a little bit cognizant of

00:35:47,839 --> 00:35:50,320
that

00:35:48,800 --> 00:35:52,240
you might need to measure if that's

00:35:50,320 --> 00:35:53,760
expensive or ask yourself if you really

00:35:52,240 --> 00:35:56,000
need to make that copy

00:35:53,760 --> 00:35:57,359
or pass in a reference so just something

00:35:56,000 --> 00:36:00,560
to keep in mind with

00:35:57,359 --> 00:36:00,560
the snippets that i'm showing

00:36:02,400 --> 00:36:06,160
okay so with that in mind we have our

00:36:05,280 --> 00:36:07,839
next task

00:36:06,160 --> 00:36:10,960
you know so far we're doing pretty good

00:36:07,839 --> 00:36:13,359
with our screen saver company here

00:36:10,960 --> 00:36:14,720
and we want to fine-tune this just a

00:36:13,359 --> 00:36:16,800
little bit

00:36:14,720 --> 00:36:18,640
because we think we can be you know we

00:36:16,800 --> 00:36:20,480
can improve things just a little bit

00:36:18,640 --> 00:36:22,160
more by adding some more circles you

00:36:20,480 --> 00:36:24,640
know this visual effects just not

00:36:22,160 --> 00:36:25,200
uh grabbing enough uh it's not cool

00:36:24,640 --> 00:36:28,480
enough

00:36:25,200 --> 00:36:31,440
yet so

00:36:28,480 --> 00:36:33,119
again you start looking through the code

00:36:31,440 --> 00:36:34,560
and you want to go through your first

00:36:33,119 --> 00:36:36,560
refactoring

00:36:34,560 --> 00:36:38,480
so you search through the code and you

00:36:36,560 --> 00:36:39,200
start finding for loops that look like

00:36:38,480 --> 00:36:41,599
this

00:36:39,200 --> 00:36:43,119
uh for into i equals zero i is less than

00:36:41,599 --> 00:36:45,280
a hundred i plus plus

00:36:43,119 --> 00:36:47,359
um you know you're pushing a fixed

00:36:45,280 --> 00:36:48,079
number of you know temporary objects

00:36:47,359 --> 00:36:50,240
here

00:36:48,079 --> 00:36:52,000
into a vector uh where they're stored

00:36:50,240 --> 00:36:53,359
and that's where all of your circles are

00:36:52,000 --> 00:36:55,599
in the screen saver

00:36:53,359 --> 00:36:58,000
okay so a bunch of objects pushed into a

00:36:55,599 --> 00:36:58,000
collection

00:36:58,400 --> 00:37:02,000
but later on you see some corresponding

00:37:01,040 --> 00:37:04,240
code

00:37:02,000 --> 00:37:06,560
to loop through all these elements so

00:37:04,240 --> 00:37:08,880
you see we're actually doing the drawing

00:37:06,560 --> 00:37:10,079
for anti-i equals zero i less than 100 i

00:37:08,880 --> 00:37:13,280
plus plus

00:37:10,079 --> 00:37:15,680
you know for the window size um you know

00:37:13,280 --> 00:37:17,040
update all these circles and draw them

00:37:15,680 --> 00:37:19,040
so there's um you know

00:37:17,040 --> 00:37:22,240
something interesting here again that

00:37:19,040 --> 00:37:24,079
you're noticing

00:37:22,240 --> 00:37:26,000
but you know you've learned a little bit

00:37:24,079 --> 00:37:27,520
from before in your coding

00:37:26,000 --> 00:37:29,760
experience that hey you know these

00:37:27,520 --> 00:37:30,480
container data structures like the

00:37:29,760 --> 00:37:33,760
vector

00:37:30,480 --> 00:37:35,119
um they have a handy dot size member

00:37:33,760 --> 00:37:36,720
function which will return

00:37:35,119 --> 00:37:38,560
you know how many items are in that

00:37:36,720 --> 00:37:39,119
collection so you can just loop through

00:37:38,560 --> 00:37:42,160
them all

00:37:39,119 --> 00:37:45,040
on this way okay uh this is

00:37:42,160 --> 00:37:45,599
uh safer uh this is a way to iterate

00:37:45,040 --> 00:37:47,760
through

00:37:45,599 --> 00:37:49,040
um you know all the objects from a

00:37:47,760 --> 00:37:50,960
particular range

00:37:49,040 --> 00:37:52,800
so you can do this but i'm going to

00:37:50,960 --> 00:37:55,599
argue we can do a little bit better for

00:37:52,800 --> 00:37:58,000
this particular use case

00:37:55,599 --> 00:37:59,119
and to do that i can introduce our third

00:37:58,000 --> 00:38:02,640
category

00:37:59,119 --> 00:38:02,640
behavioral design patterns

00:38:02,880 --> 00:38:06,240
okay so behavioral design patterns focus

00:38:05,839 --> 00:38:10,480
on

00:38:06,240 --> 00:38:10,480
communication between objects

00:38:12,160 --> 00:38:15,440
so our behavioral design pattern we're

00:38:14,000 --> 00:38:16,720
going to focus on the communication

00:38:15,440 --> 00:38:18,160
between objects

00:38:16,720 --> 00:38:21,359
and in general behavioral design

00:38:18,160 --> 00:38:23,839
patterns are concerned with

00:38:21,359 --> 00:38:25,200
the responsibilities and the algorithms

00:38:23,839 --> 00:38:28,720
taking place

00:38:25,200 --> 00:38:30,480
amongst you know many similar objects

00:38:28,720 --> 00:38:32,560
the relationship i want to work with in

00:38:30,480 --> 00:38:33,119
this example that i'm showing is just

00:38:32,560 --> 00:38:35,680
how

00:38:33,119 --> 00:38:37,520
each object in a collection is linked on

00:38:35,680 --> 00:38:40,000
how to traverse through that entire

00:38:37,520 --> 00:38:40,000
collection

00:38:42,000 --> 00:38:46,000
so this is given this next pattern is

00:38:45,040 --> 00:38:48,800
called the iterator

00:38:46,000 --> 00:38:50,240
pattern and it provides a sequential

00:38:48,800 --> 00:38:52,320
access to elements

00:38:50,240 --> 00:38:53,839
in a collection without exposing the

00:38:52,320 --> 00:38:55,599
actual representation

00:38:53,839 --> 00:38:58,240
uh so in a word that's saying is it's

00:38:55,599 --> 00:38:59,280
not going to expose how we iterate

00:38:58,240 --> 00:39:03,119
through an entire

00:38:59,280 --> 00:39:03,119
uh container data structure

00:39:03,359 --> 00:39:07,599
okay so the iterator pattern the problem

00:39:06,960 --> 00:39:09,440
is

00:39:07,599 --> 00:39:11,200
you know your data structures hold some

00:39:09,440 --> 00:39:13,520
data in some type of collection whether

00:39:11,200 --> 00:39:15,760
it's a linked list hash

00:39:13,520 --> 00:39:18,160
a heap a tree some sort of graph

00:39:15,760 --> 00:39:20,800
representation it doesn't matter

00:39:18,160 --> 00:39:22,160
and then at some point though a user is

00:39:20,800 --> 00:39:24,960
going to want to

00:39:22,160 --> 00:39:27,119
iterate through and look at all the data

00:39:24,960 --> 00:39:29,599
that's in the container

00:39:27,119 --> 00:39:30,480
so the solution that we can provide our

00:39:29,599 --> 00:39:33,520
user

00:39:30,480 --> 00:39:36,880
is to encapsulate uh the iteration

00:39:33,520 --> 00:39:38,880
um in in some way such that we have a

00:39:36,880 --> 00:39:42,800
consistent way to look through our data

00:39:38,880 --> 00:39:44,880
okay so that could mean uh various um

00:39:42,800 --> 00:39:46,079
traversals perhaps going from the first

00:39:44,880 --> 00:39:48,560
element to the last

00:39:46,079 --> 00:39:49,359
or reverse from the last element to the

00:39:48,560 --> 00:39:50,800
first

00:39:49,359 --> 00:39:52,880
and depending on your data structure

00:39:50,800 --> 00:39:54,560
these are your different uh traversals

00:39:52,880 --> 00:39:59,520
like a breadth first traversal

00:39:54,560 --> 00:39:59,520
depth first traversal and so forth

00:39:59,599 --> 00:40:04,800
okay um so this sort of iterator pattern

00:40:02,880 --> 00:40:06,720
analogy is you know how many possible

00:40:04,800 --> 00:40:08,000
traversals are there at rome you know by

00:40:06,720 --> 00:40:10,880
foot

00:40:08,000 --> 00:40:12,319
walking you know running by using a map

00:40:10,880 --> 00:40:14,079
taking a tour you know there's many

00:40:12,319 --> 00:40:14,720
different ways that you can look through

00:40:14,079 --> 00:40:18,240
some

00:40:14,720 --> 00:40:18,240
collection of data okay

00:40:18,960 --> 00:40:25,359
okay so first take

00:40:22,079 --> 00:40:26,319
the iterator pattern and the good news

00:40:25,359 --> 00:40:29,680
about this pattern

00:40:26,319 --> 00:40:32,400
is um this is one that's actually very

00:40:29,680 --> 00:40:34,160
prevalent throughout c plus plus in the

00:40:32,400 --> 00:40:36,560
standard template library

00:40:34,160 --> 00:40:38,560
okay we often get our iterators for free

00:40:36,560 --> 00:40:39,839
so i don't have to implement many of

00:40:38,560 --> 00:40:42,160
these if you're using

00:40:39,839 --> 00:40:43,440
the standard library's container

00:40:42,160 --> 00:40:45,520
structures

00:40:43,440 --> 00:40:46,880
so we're going from this code snippet

00:40:45,520 --> 00:40:48,880
here

00:40:46,880 --> 00:40:50,400
down to this bottom snippet where i'm

00:40:48,880 --> 00:40:54,079
using iterators

00:40:50,400 --> 00:40:56,640
so on this vector collection here

00:40:54,079 --> 00:40:58,800
i have an iterator that i create and i

00:40:56,640 --> 00:41:00,319
want it to start at the beginning

00:40:58,800 --> 00:41:01,839
and then while my iterator hasn't

00:41:00,319 --> 00:41:04,560
reached the end of the collection

00:41:01,839 --> 00:41:05,599
i want to move my iterator forward one

00:41:04,560 --> 00:41:08,960
element

00:41:05,599 --> 00:41:10,319
okay and uh you know it doesn't look

00:41:08,960 --> 00:41:11,839
like we've done much here but i'm going

00:41:10,319 --> 00:41:13,839
to argue that we've made some nice

00:41:11,839 --> 00:41:16,000
improvements to the code by using this

00:41:13,839 --> 00:41:19,520
iterator design pattern

00:41:16,000 --> 00:41:21,280
um so each time we iterate through

00:41:19,520 --> 00:41:22,800
we're being very explicit here that

00:41:21,280 --> 00:41:24,319
we're starting from the beginning

00:41:22,800 --> 00:41:25,920
you know that's what we meant in our old

00:41:24,319 --> 00:41:27,520
example i equals 0 but

00:41:25,920 --> 00:41:29,359
we could make a mistake that could

00:41:27,520 --> 00:41:30,319
change but we really want to iterate

00:41:29,359 --> 00:41:32,480
from the start

00:41:30,319 --> 00:41:35,119
so i have circles our collection dot

00:41:32,480 --> 00:41:36,880
begin to represent that

00:41:35,119 --> 00:41:38,160
and then we're also maintaining again

00:41:36,880 --> 00:41:40,880
that we want to iterate

00:41:38,160 --> 00:41:42,960
uh to the very end so our iterator here

00:41:40,880 --> 00:41:45,119
while it's not equal to the circles

00:41:42,960 --> 00:41:46,240
dot end the end of the collection has

00:41:45,119 --> 00:41:48,400
been implemented

00:41:46,240 --> 00:41:50,079
okay and this is just very explicit uh

00:41:48,400 --> 00:41:52,720
unclear what's going on

00:41:50,079 --> 00:41:54,079
again um you know if i have circles dot

00:41:52,720 --> 00:41:56,640
size maybe i have a

00:41:54,079 --> 00:41:57,520
size minus one or size plus one or you

00:41:56,640 --> 00:42:00,000
know i might

00:41:57,520 --> 00:42:00,960
forget to have that um sort of off by

00:42:00,000 --> 00:42:02,640
one error

00:42:00,960 --> 00:42:04,160
so again we're just being very explicit

00:42:02,640 --> 00:42:06,560
how we're traversing through

00:42:04,160 --> 00:42:08,079
our data structure and then finally

00:42:06,560 --> 00:42:09,520
we're also being very clear about

00:42:08,079 --> 00:42:11,280
we want to look through everything so

00:42:09,520 --> 00:42:12,319
we're just moving from one item to the

00:42:11,280 --> 00:42:14,480
next

00:42:12,319 --> 00:42:16,480
in a in a vector or a list data

00:42:14,480 --> 00:42:19,599
structure this is pretty clear because

00:42:16,480 --> 00:42:22,480
one item typically follows the other

00:42:19,599 --> 00:42:23,599
but again in a tree or graph data

00:42:22,480 --> 00:42:25,200
structure

00:42:23,599 --> 00:42:26,800
this is nice to have to know that we'll

00:42:25,200 --> 00:42:30,960
eventually look through everything

00:42:26,800 --> 00:42:33,839
just in some traversal

00:42:30,960 --> 00:42:35,200
okay so the result uh on the sort of

00:42:33,839 --> 00:42:38,319
grand finale

00:42:35,200 --> 00:42:40,480
of our work is uh we apply this uh

00:42:38,319 --> 00:42:42,720
traversal so we'll be looking through

00:42:40,480 --> 00:42:44,240
uh all of the circles we've cranked the

00:42:42,720 --> 00:42:46,560
number up to a thousand

00:42:44,240 --> 00:42:48,079
uh and now we get this uh visual here

00:42:46,560 --> 00:42:51,040
which is a little bit more

00:42:48,079 --> 00:42:51,760
uh fun and interesting uh to look at

00:42:51,040 --> 00:42:53,920
okay

00:42:51,760 --> 00:42:55,680
uh so with this we've made our code a

00:42:53,920 --> 00:42:58,800
little bit more maintainable

00:42:55,680 --> 00:43:00,560
i would argue with uh this pattern

00:42:58,800 --> 00:43:02,480
and you know with iterators too we can

00:43:00,560 --> 00:43:04,160
do cool stuff if we advance the data

00:43:02,480 --> 00:43:05,680
structures maybe we want these circles

00:43:04,160 --> 00:43:07,280
to collide with each other and then

00:43:05,680 --> 00:43:09,280
start talking about

00:43:07,280 --> 00:43:11,280
bounding boxes and sort of partitioning

00:43:09,280 --> 00:43:14,560
algorithms and where they should

00:43:11,280 --> 00:43:16,000
uh you know only look for circles nearby

00:43:14,560 --> 00:43:18,400
for conclusions so this can open the

00:43:16,000 --> 00:43:20,319
door for different optimizations

00:43:18,400 --> 00:43:22,560
uh later on so this could be a pretty

00:43:20,319 --> 00:43:24,800
powerful pattern

00:43:22,560 --> 00:43:26,160
okay so iterators are something you

00:43:24,800 --> 00:43:27,160
should consider using

00:43:26,160 --> 00:43:29,280
um if you look through the

00:43:27,160 --> 00:43:32,480
c-plusplus.com reference uh

00:43:29,280 --> 00:43:34,160
or the cppreference.com uh there's lots

00:43:32,480 --> 00:43:34,560
of good information on the iterators for

00:43:34,160 --> 00:43:37,760
the

00:43:34,560 --> 00:43:37,760
standard template library

00:43:37,920 --> 00:43:42,240
uh like everything else there's uh pros

00:43:40,319 --> 00:43:44,720
and cons these design patterns

00:43:42,240 --> 00:43:46,160
um the pros a few pros that i've come up

00:43:44,720 --> 00:43:46,960
with for the iterator are you know

00:43:46,160 --> 00:43:48,720
there's a single

00:43:46,960 --> 00:43:50,000
responsibility it's very clear what the

00:43:48,720 --> 00:43:51,200
iterator should do it should look

00:43:50,000 --> 00:43:53,599
through every element

00:43:51,200 --> 00:43:54,960
uh you know one at a time which is very

00:43:53,599 --> 00:43:56,319
nice

00:43:54,960 --> 00:43:57,839
some other things though that you can

00:43:56,319 --> 00:43:58,640
wrap into iterators to make them more

00:43:57,839 --> 00:44:00,960
robust

00:43:58,640 --> 00:44:02,480
is you can protect yourself from other

00:44:00,960 --> 00:44:05,520
things like insertions and

00:44:02,480 --> 00:44:07,200
removals right since you have this

00:44:05,520 --> 00:44:09,839
iterator interface which we've

00:44:07,200 --> 00:44:09,839
implemented here

00:44:10,240 --> 00:44:13,599
based off of how i move forward or back

00:44:12,800 --> 00:44:17,359
i can

00:44:13,599 --> 00:44:19,040
control you know what happens if another

00:44:17,359 --> 00:44:20,960
one of those circles gets removed or

00:44:19,040 --> 00:44:23,200
deleted especially in an interactive

00:44:20,960 --> 00:44:24,800
application so those are some adding

00:44:23,200 --> 00:44:27,520
some more power to iterators

00:44:24,800 --> 00:44:28,079
as an option which is harder to do with

00:44:27,520 --> 00:44:32,079
the

00:44:28,079 --> 00:44:34,079
the for loops some of the cons

00:44:32,079 --> 00:44:36,000
you know applying this pattern could

00:44:34,079 --> 00:44:38,079
have some performance cost

00:44:36,000 --> 00:44:39,280
especially for just using simple data

00:44:38,079 --> 00:44:42,000
types like um

00:44:39,280 --> 00:44:43,200
you know incrementing integers um and

00:44:42,000 --> 00:44:44,480
some of these things

00:44:43,200 --> 00:44:46,240
so you're going to have to measure and

00:44:44,480 --> 00:44:48,960
profile to see if it's

00:44:46,240 --> 00:44:49,599
worth having an iterator and doing some

00:44:48,960 --> 00:44:51,520
of these

00:44:49,599 --> 00:44:52,640
different algorithmic strategies so that

00:44:51,520 --> 00:44:54,640
could be some con

00:44:52,640 --> 00:44:56,640
along with the actual cost of um you

00:44:54,640 --> 00:44:58,800
know for your custom data structure

00:44:56,640 --> 00:45:02,240
uh the cost of building maintaining and

00:44:58,800 --> 00:45:02,240
implementing the iterator

00:45:02,720 --> 00:45:08,079
okay um so i want to start summarizing

00:45:05,760 --> 00:45:09,200
uh what we've learned we've looked at a

00:45:08,079 --> 00:45:10,960
small project

00:45:09,200 --> 00:45:12,560
uh or we can pretend it's a very large

00:45:10,960 --> 00:45:14,960
project and developing

00:45:12,560 --> 00:45:16,880
a screensaver with some colleagues and

00:45:14,960 --> 00:45:19,680
applying some design patterns

00:45:16,880 --> 00:45:20,079
to a singleton pattern adapter pattern

00:45:19,680 --> 00:45:23,200
and

00:45:20,079 --> 00:45:24,880
iterator uh we've seen the design

00:45:23,200 --> 00:45:26,240
patterns are very helpful we've seen

00:45:24,880 --> 00:45:27,119
some of the strengths and where they can

00:45:26,240 --> 00:45:29,839
help us

00:45:27,119 --> 00:45:30,240
in this example the design patterns

00:45:29,839 --> 00:45:32,960
though

00:45:30,240 --> 00:45:34,000
aren't always a magic solution uh you've

00:45:32,960 --> 00:45:36,240
seen some

00:45:34,000 --> 00:45:37,200
my patterns here and how i've applied

00:45:36,240 --> 00:45:39,839
them

00:45:37,200 --> 00:45:41,440
and i've taken some liberties to

00:45:39,839 --> 00:45:44,079
implement

00:45:41,440 --> 00:45:46,079
as they make sense in each of these

00:45:44,079 --> 00:45:48,240
problems that i'm trying to solve but

00:45:46,079 --> 00:45:49,760
again they're really good starting point

00:45:48,240 --> 00:45:51,359
to solving your problem and having a

00:45:49,760 --> 00:45:53,040
name to the problem that you're trying

00:45:51,359 --> 00:45:56,160
to solve so you can research

00:45:53,040 --> 00:45:57,520
further so my recommendation is to

00:45:56,160 --> 00:45:58,880
for those just learning continue

00:45:57,520 --> 00:46:00,240
learning more about the different design

00:45:58,880 --> 00:46:02,400
patterns that are out there apply them

00:46:00,240 --> 00:46:05,680
to some small projects

00:46:02,400 --> 00:46:07,520
and test out their utility one thing

00:46:05,680 --> 00:46:11,200
that can be helpful

00:46:07,520 --> 00:46:14,240
for design patterns is

00:46:11,200 --> 00:46:16,240
you know learning a little bit of uml

00:46:14,240 --> 00:46:17,760
so i'm just going to run through a few

00:46:16,240 --> 00:46:19,200
slides here because this is how you

00:46:17,760 --> 00:46:22,240
often see them

00:46:19,200 --> 00:46:24,880
in the text so i just want to make you

00:46:22,240 --> 00:46:25,920
aware of it what it is you know there's

00:46:24,880 --> 00:46:28,000
lots of different

00:46:25,920 --> 00:46:30,240
ways to diagram these things but uml is

00:46:28,000 --> 00:46:33,440
the unified modeling language

00:46:30,240 --> 00:46:36,000
it's just a general purpose

00:46:33,440 --> 00:46:37,359
way to diagram a class and the

00:46:36,000 --> 00:46:39,280
relationship amongst

00:46:37,359 --> 00:46:40,720
objects so you'll see these a lot in the

00:46:39,280 --> 00:46:42,880
gang of four book

00:46:40,720 --> 00:46:44,800
they can be useful to look at so the

00:46:42,880 --> 00:46:46,240
very basic example is you'll see a

00:46:44,800 --> 00:46:47,920
diagram like this

00:46:46,240 --> 00:46:50,240
that has the class name the member

00:46:47,920 --> 00:46:52,000
variables member functions

00:46:50,240 --> 00:46:54,560
and then we'll draw you know sort of the

00:46:52,000 --> 00:46:56,960
arrows to show if this class is

00:46:54,560 --> 00:46:58,720
derived or inherited from another class

00:46:56,960 --> 00:47:00,000
and so on okay so just a quick run

00:46:58,720 --> 00:47:03,040
through of uml

00:47:00,000 --> 00:47:05,200
um there just so you're aware of it

00:47:03,040 --> 00:47:06,240
uh further recommended resources i

00:47:05,200 --> 00:47:08,400
recommend

00:47:06,240 --> 00:47:09,440
any of these four books that i've looked

00:47:08,400 --> 00:47:12,000
at

00:47:09,440 --> 00:47:13,040
fedor gave a talk on design patterns i

00:47:12,000 --> 00:47:15,680
think last year

00:47:13,040 --> 00:47:18,240
and then wrote this book which does

00:47:15,680 --> 00:47:19,280
various c-plus plus design patterns

00:47:18,240 --> 00:47:22,000
and these can be some excellent

00:47:19,280 --> 00:47:24,240
resources to get up and running

00:47:22,000 --> 00:47:26,319
the code for today's uh talk was

00:47:24,240 --> 00:47:27,200
developed a little visualization in sfml

00:47:26,319 --> 00:47:28,800
that's a great

00:47:27,200 --> 00:47:30,400
library to practice if you want to

00:47:28,800 --> 00:47:34,559
visualize some of these algorithms

00:47:30,400 --> 00:47:34,559
so i can recommend that as well

00:47:35,200 --> 00:47:38,240
so with that i just want to take some

00:47:36,960 --> 00:47:39,839
time to

00:47:38,240 --> 00:47:42,000
thank you for attending my session at

00:47:39,839 --> 00:47:45,440
cppcon thank you for folks

00:47:42,000 --> 00:47:48,079
asking questions my plan is to join

00:47:45,440 --> 00:47:50,400
folks at a table in remo i've got your

00:47:48,079 --> 00:47:53,440
questions that you've submitted

00:47:50,400 --> 00:48:07,839
and thank you very much again for your

00:47:53,440 --> 00:48:07,839
time and attention today

00:48:14,720 --> 00:48:16,800

YouTube URL: https://www.youtube.com/watch?v=2UUqX2eIdSM


