Title: Making Games Start Fast: A Story About Concurrency - Mathieu Ropert - CppCon 2020
Publication date: 2020-10-03
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/making_games_start_fast/making_games_start_fast__mathieu_ropert__cppcon_2020.pdf
---
A common complaint in game development is that games take to long to start up. Players hate it and developers waste a long time watching loading screens.
Last spring I dived into my game's startup code and figured out ways to shave tens of seconds out of the time to reach main menu, and was able to introduce similar benefits to most of our other titles by looking into threading efficiency.

In this port-mortem analysis, I will present the various steps I took to analyze concurrency, improve threading performance and reduce lock contention.
Attendees will be shown how Intel vTune can be used to profile threading issues, how "thread safe" APIs can be misleading and how re-architecturing code in a lock-free fashion can drastically improve throughput.
We will also briefly touch how user-facing application can cheat and achieve perceived speedups by knowing the users' workflow. 

---
Mathieu Ropert is a French C++ expert working on (somewhat) historical video games. Mathieu decided to upgrade his compiler once and has been blogging about build systems ever since. Mathieu is a past speaker at CppCon, Meeting C++ and ACCU. Used to run the Paris C++ User Group. Currently lives in Sweden. 

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,720 --> 00:00:12,960
hi everyone

00:00:10,080 --> 00:00:14,960
and welcome to my talk about making game

00:00:12,960 --> 00:00:18,880
starts fast

00:00:14,960 --> 00:00:20,960
so let's talk about

00:00:18,880 --> 00:00:22,480
history just real quick let me tell you

00:00:20,960 --> 00:00:25,199
a story once upon a time

00:00:22,480 --> 00:00:27,760
in the early 2000s people started having

00:00:25,199 --> 00:00:31,119
bigger and bigger and bigger cpu

00:00:27,760 --> 00:00:33,200
up until um sometime around 2004

00:00:31,119 --> 00:00:35,280
where as you can see they got into a

00:00:33,200 --> 00:00:37,120
small issue with the clock speeds

00:00:35,280 --> 00:00:39,360
they could not continue the uh

00:00:37,120 --> 00:00:40,559
breathtaking pace of uh increasing the

00:00:39,360 --> 00:00:44,160
frequency

00:00:40,559 --> 00:00:45,520
but luckily after fiddling a bit with

00:00:44,160 --> 00:00:48,239
the problem they figured out the

00:00:45,520 --> 00:00:50,480
solution it was actually easy

00:00:48,239 --> 00:00:51,280
you take one core and since you can't

00:00:50,480 --> 00:00:53,680
make it bigger

00:00:51,280 --> 00:00:54,320
well you just make four smaller cores

00:00:53,680 --> 00:00:57,039
and

00:00:54,320 --> 00:00:58,480
that's done easy problem solved that was

00:00:57,039 --> 00:01:02,399
great

00:00:58,480 --> 00:01:04,799
but then after that i woke up hi

00:01:02,399 --> 00:01:06,320
my name is matthieur i am a tech lead at

00:01:04,799 --> 00:01:08,960
products development studio

00:01:06,320 --> 00:01:10,560
um i work on hearts of i went for

00:01:08,960 --> 00:01:12,960
previously i worked on stellaris

00:01:10,560 --> 00:01:14,080
and i knew bernie was also not the games

00:01:12,960 --> 00:01:16,240
and today i'm going to tell you about

00:01:14,080 --> 00:01:19,360
stellaris

00:01:16,240 --> 00:01:22,400
in this talk we are going to talk about

00:01:19,360 --> 00:01:24,840
threads we're going to talk about logs

00:01:22,400 --> 00:01:27,360
we're going to talk about how to avoid

00:01:24,840 --> 00:01:28,799
blocks and we're going to talk about

00:01:27,360 --> 00:01:31,600
flooding efficiency and how to

00:01:28,799 --> 00:01:31,600
investigate it

00:01:31,920 --> 00:01:36,400
so in the interest of science and

00:01:34,479 --> 00:01:37,200
technology i have decided to do this in

00:01:36,400 --> 00:01:39,119
a demo

00:01:37,200 --> 00:01:40,880
in a live demo fashion which is

00:01:39,119 --> 00:01:42,880
interesting because it bugged out like

00:01:40,880 --> 00:01:44,159
just less than five minutes ago but it

00:01:42,880 --> 00:01:45,439
should be okay

00:01:44,159 --> 00:01:47,360
so you know what we're gonna do we're

00:01:45,439 --> 00:01:48,640
gonna actually boot up the game

00:01:47,360 --> 00:01:51,119
let's see i don't know if any of you

00:01:48,640 --> 00:01:53,360
have played stellaris uh you have like a

00:01:51,119 --> 00:01:55,200
minute to tell me about it because uh

00:01:53,360 --> 00:01:56,719
as you will see it's not super fast to

00:01:55,200 --> 00:01:58,159
start i'm actually gonna use a countdown

00:01:56,719 --> 00:02:00,079
on my phone at the same time

00:01:58,159 --> 00:02:02,079
uh do not count the launcher i'm just

00:02:00,079 --> 00:02:04,960
gonna check this yeah everything is fine

00:02:02,079 --> 00:02:06,399
and i'm gonna hit play now you can see a

00:02:04,960 --> 00:02:08,319
marvelous splash screen

00:02:06,399 --> 00:02:09,840
that is uh showing you that the game is

00:02:08,319 --> 00:02:11,360
actually starting to do something

00:02:09,840 --> 00:02:13,200
it's not the actual loading screen yet

00:02:11,360 --> 00:02:16,319
the loading screen will happen

00:02:13,200 --> 00:02:19,680
in i don't know just about 10

00:02:16,319 --> 00:02:21,120
10 20 seconds maybe fun fact the uh

00:02:19,680 --> 00:02:22,879
loading screen was not part of the

00:02:21,120 --> 00:02:24,239
release it was added later after we got

00:02:22,879 --> 00:02:26,640
the feedback that you

00:02:24,239 --> 00:02:27,920
click play on steam and then you watch a

00:02:26,640 --> 00:02:30,080
blank screen for about

00:02:27,920 --> 00:02:31,920
20 seconds until the game actually

00:02:30,080 --> 00:02:34,640
starts giving you any feedback

00:02:31,920 --> 00:02:35,760
um i really appreciate uh whoever

00:02:34,640 --> 00:02:38,480
brought that up

00:02:35,760 --> 00:02:40,640
so as you can see ah there you go you

00:02:38,480 --> 00:02:43,599
should even be hearing the music

00:02:40,640 --> 00:02:45,599
just just listen it for it for a second

00:02:43,599 --> 00:02:51,680
you should be able to feel the space

00:02:45,599 --> 00:02:54,480
coming up it's a space game

00:02:51,680 --> 00:02:56,000
it's nice right look at these great odd

00:02:54,480 --> 00:02:57,920
pictures you you kind of want to see

00:02:56,000 --> 00:02:59,840
that space you want to explore

00:02:57,920 --> 00:03:01,440
you kind of want to go there i mean you

00:02:59,840 --> 00:03:03,040
might want to go there faster but it's

00:03:01,440 --> 00:03:05,440
still pretty cool

00:03:03,040 --> 00:03:06,879
and we should be in the main menu just

00:03:05,440 --> 00:03:10,159
about now

00:03:06,879 --> 00:03:11,599
and my clock is saying a minute and five

00:03:10,159 --> 00:03:15,040
seconds this is the main menu

00:03:11,599 --> 00:03:17,360
nothing special i'm just gonna exit now

00:03:15,040 --> 00:03:18,720
that's nice and i mean most of our

00:03:17,360 --> 00:03:21,760
players actually

00:03:18,720 --> 00:03:23,840
uh have session times that are usually

00:03:21,760 --> 00:03:25,360
longer than 30 minutes like people play

00:03:23,840 --> 00:03:27,920
all games a lot

00:03:25,360 --> 00:03:29,440
and for a long time but still we

00:03:27,920 --> 00:03:32,319
developers play it

00:03:29,440 --> 00:03:33,440
started a lot every day um so now i'm

00:03:32,319 --> 00:03:36,480
gonna show you the

00:03:33,440 --> 00:03:38,239
secret beta that is uh not released yet

00:03:36,480 --> 00:03:40,319
uh don't worry all the leaks are

00:03:38,239 --> 00:03:42,319
perfectly controlled

00:03:40,319 --> 00:03:44,560
i am just gonna check that everything is

00:03:42,319 --> 00:03:47,519
fine everything is fine let's see play

00:03:44,560 --> 00:03:48,879
this is the exact uh same game except

00:03:47,519 --> 00:03:52,560
it's the unreleased

00:03:48,879 --> 00:03:53,599
version of the next match and as you can

00:03:52,560 --> 00:03:56,640
see

00:03:53,599 --> 00:03:58,640
it's a bit faster to start

00:03:56,640 --> 00:04:01,770
right now if you remember the last time

00:03:58,640 --> 00:04:03,040
you heard the notes and the music

00:04:01,770 --> 00:04:05,280
[Music]

00:04:03,040 --> 00:04:07,120
we're barely hearing the first uh notes

00:04:05,280 --> 00:04:10,159
of the female we already there i have

00:04:07,120 --> 00:04:11,840
like something like 18 or 17 seconds

00:04:10,159 --> 00:04:14,159
this is not a super strong machine by

00:04:11,840 --> 00:04:16,479
the way this is my home uh

00:04:14,159 --> 00:04:18,479
computer and since i've been kind of

00:04:16,479 --> 00:04:21,440
lazy lately i have not upgraded it

00:04:18,479 --> 00:04:22,320
it is still a second generation i7 it

00:04:21,440 --> 00:04:24,960
has like

00:04:22,320 --> 00:04:25,840
four cores and eight threads but i mean

00:04:24,960 --> 00:04:28,560
it's not the

00:04:25,840 --> 00:04:29,520
fastest machine in the market still i

00:04:28,560 --> 00:04:32,639
managed to

00:04:29,520 --> 00:04:35,280
go from like a minute to 20 seconds so

00:04:32,639 --> 00:04:36,720
you know there's something uh yeah

00:04:35,280 --> 00:04:37,840
that's that's kind of similar to the

00:04:36,720 --> 00:04:39,840
measures i had when i

00:04:37,840 --> 00:04:41,759
made this talk uh the important thing is

00:04:39,840 --> 00:04:44,000
that there's the same amount of work

00:04:41,759 --> 00:04:48,000
that's being done in both cases here

00:04:44,000 --> 00:04:49,199
um both uh both version of actually

00:04:48,000 --> 00:04:52,320
multi-threaded it's not like i

00:04:49,199 --> 00:04:55,120
invented multi-threading in the 2.8 beta

00:04:52,320 --> 00:04:56,000
it's already been there in the past the

00:04:55,120 --> 00:05:00,000
difference is

00:04:56,000 --> 00:05:03,360
how the work is done uh it's not really

00:05:00,000 --> 00:05:04,240
let's see so um i don't know if any of

00:05:03,360 --> 00:05:06,160
you have ever seen v

00:05:04,240 --> 00:05:07,680
tune uh which is the tool i use mostly

00:05:06,160 --> 00:05:10,479
to uh to benchmark

00:05:07,680 --> 00:05:12,160
uh and and profile the startup i'm gonna

00:05:10,479 --> 00:05:14,240
run you through it uh this is this is a

00:05:12,160 --> 00:05:15,440
profile of the actual start you just saw

00:05:14,240 --> 00:05:17,919
a minute ago

00:05:15,440 --> 00:05:19,360
uh as you can see it takes about 60

00:05:17,919 --> 00:05:21,280
seconds to start and you have the

00:05:19,360 --> 00:05:22,000
timeline of your cpu and a bunch of

00:05:21,280 --> 00:05:25,280
threads

00:05:22,000 --> 00:05:26,960
if you've never seen vtune um so the

00:05:25,280 --> 00:05:28,479
the brown part here is the good part

00:05:26,960 --> 00:05:30,240
it's the parts you want to see

00:05:28,479 --> 00:05:32,080
when when everything is super brown like

00:05:30,240 --> 00:05:34,000
this it means your core is just like

00:05:32,080 --> 00:05:35,840
going ham and just executing

00:05:34,000 --> 00:05:36,960
instructional instructions doesn't mean

00:05:35,840 --> 00:05:38,400
it's the

00:05:36,960 --> 00:05:40,479
smallest instruction in the world you

00:05:38,400 --> 00:05:41,919
can still have like very stupid code you

00:05:40,479 --> 00:05:43,759
can still have a lot of

00:05:41,919 --> 00:05:45,600
issues with branch prediction cache

00:05:43,759 --> 00:05:48,720
coherency but at least your core is

00:05:45,600 --> 00:05:51,759
busy it's spinning it's doing stuff

00:05:48,720 --> 00:05:54,080
uh green is just meaning that

00:05:51,759 --> 00:05:55,520
the thread is sleeping it has nothing to

00:05:54,080 --> 00:05:57,600
do uh

00:05:55,520 --> 00:05:58,880
it's it's it's it's different from

00:05:57,600 --> 00:06:02,000
waiting from an actual

00:05:58,880 --> 00:06:04,080
uh variable it's just it's there

00:06:02,000 --> 00:06:05,680
it's waiting it has nothing to do

00:06:04,080 --> 00:06:06,880
probably because the job system is not

00:06:05,680 --> 00:06:09,039
started yet

00:06:06,880 --> 00:06:11,360
it's just there it's there it's created

00:06:09,039 --> 00:06:14,639
it's just waiting for something to do

00:06:11,360 --> 00:06:15,840
um this light green on the other hand

00:06:14,639 --> 00:06:18,479
means

00:06:15,840 --> 00:06:20,560
it kind of want to do something but it's

00:06:18,479 --> 00:06:22,160
not doing much it's basically sleeping

00:06:20,560 --> 00:06:24,160
on a conditioned variable

00:06:22,160 --> 00:06:25,280
waiting on the mutex something like it's

00:06:24,160 --> 00:06:27,440
basically

00:06:25,280 --> 00:06:29,680
waiting on a synchronization primitive

00:06:27,440 --> 00:06:33,440
in a in a passive way

00:06:29,680 --> 00:06:35,120
uh red is uh scary uh it's historically

00:06:33,440 --> 00:06:37,199
uh a scary color

00:06:35,120 --> 00:06:38,319
in most cultures because it's related to

00:06:37,199 --> 00:06:40,560
the color of blood

00:06:38,319 --> 00:06:42,080
and nobody wants to see blood um

00:06:40,560 --> 00:06:43,120
anywhere and especially not on his

00:06:42,080 --> 00:06:45,280
provider

00:06:43,120 --> 00:06:46,560
uh what it means here is that there is a

00:06:45,280 --> 00:06:48,800
friend contention

00:06:46,560 --> 00:06:50,080
when your cpu is just red it's either

00:06:48,800 --> 00:06:53,280
spinning

00:06:50,080 --> 00:06:54,720
uh on a spin lock or uh just fight

00:06:53,280 --> 00:06:56,400
usually it's fighting over something

00:06:54,720 --> 00:06:57,039
fighting over a spin lock or something

00:06:56,400 --> 00:06:59,280
similar

00:06:57,039 --> 00:07:01,840
it's not doing any actual work it's just

00:06:59,280 --> 00:07:05,199
desperately trying to

00:07:01,840 --> 00:07:06,479
to get some luck in a in an aggressive

00:07:05,199 --> 00:07:08,479
way

00:07:06,479 --> 00:07:09,759
if we compare it to the new version then

00:07:08,479 --> 00:07:12,240
uh i i

00:07:09,759 --> 00:07:13,840
um i i will publish soon you can already

00:07:12,240 --> 00:07:16,479
first see that the

00:07:13,840 --> 00:07:18,240
the timeline stops at like 20 something

00:07:16,479 --> 00:07:20,639
seconds instead of 60.

00:07:18,240 --> 00:07:22,160
and there is much less red and there is

00:07:20,639 --> 00:07:25,199
also a bit more brown

00:07:22,160 --> 00:07:25,599
in in a bunch of places sure you look at

00:07:25,199 --> 00:07:27,680
this

00:07:25,599 --> 00:07:28,720
it's still not perfect for a machine

00:07:27,680 --> 00:07:30,960
with eight cores

00:07:28,720 --> 00:07:32,080
i mean ideally in the perfect world we

00:07:30,960 --> 00:07:34,400
would have like just

00:07:32,080 --> 00:07:35,360
eight uh you can't see my uh my hand but

00:07:34,400 --> 00:07:38,000
you would see like

00:07:35,360 --> 00:07:38,960
eight uh eight big blocks of brown all

00:07:38,000 --> 00:07:43,840
the way

00:07:38,960 --> 00:07:45,759
uh but i mean it's still much

00:07:43,840 --> 00:07:47,280
so the question is what are we doing

00:07:45,759 --> 00:07:49,599
what is happening why

00:07:47,280 --> 00:07:51,360
wh why do we take so long to do startups

00:07:49,599 --> 00:07:52,240
to give you an idea of what stellaris is

00:07:51,360 --> 00:07:54,720
doing in the

00:07:52,240 --> 00:07:55,680
in this time frame the first thing it's

00:07:54,720 --> 00:07:57,440
going to do is that it's going to

00:07:55,680 --> 00:07:59,440
enumerate all the asset files

00:07:57,440 --> 00:08:01,520
uh i'll get back to that but the the big

00:07:59,440 --> 00:08:02,400
idea is that we do not know uh in

00:08:01,520 --> 00:08:04,000
advance

00:08:02,400 --> 00:08:06,400
which asset files we're gonna load

00:08:04,000 --> 00:08:08,160
because we have a pretty strong modding

00:08:06,400 --> 00:08:11,680
community and modding system

00:08:08,160 --> 00:08:14,160
uh plus we have a bunch of optional uh

00:08:11,680 --> 00:08:15,120
expansion dlcs that you can or cannot

00:08:14,160 --> 00:08:16,479
have

00:08:15,120 --> 00:08:18,960
and you can even if you have then you

00:08:16,479 --> 00:08:21,360
can disable them for some reasons

00:08:18,960 --> 00:08:22,879
so we have to uh actually enumerate

00:08:21,360 --> 00:08:25,280
everything and see which

00:08:22,879 --> 00:08:26,400
actual assets we're gonna have to uh uh

00:08:25,280 --> 00:08:27,759
too low

00:08:26,400 --> 00:08:28,800
uh the other thing we're gonna have to

00:08:27,759 --> 00:08:29,919
do is that you're gonna read the

00:08:28,800 --> 00:08:31,919
localization

00:08:29,919 --> 00:08:33,839
basically every text string you see in

00:08:31,919 --> 00:08:34,959
the game we're gonna have to uh figure

00:08:33,839 --> 00:08:36,719
out which language you

00:08:34,959 --> 00:08:38,240
you're setting up and read all the

00:08:36,719 --> 00:08:39,519
strings it's just a it's basically a

00:08:38,240 --> 00:08:42,880
hash map

00:08:39,519 --> 00:08:44,480
globally it's a hashmap of a key in

00:08:42,880 --> 00:08:46,959
value you just have to load everything

00:08:44,480 --> 00:08:48,240
from a bunch of text files

00:08:46,959 --> 00:08:50,000
then of course we're going to get to the

00:08:48,240 --> 00:08:51,519
more gaming box we're going to load all

00:08:50,000 --> 00:08:52,160
the textures we're going to model the

00:08:51,519 --> 00:08:54,000
models

00:08:52,160 --> 00:08:56,640
and we're going to load everything audio

00:08:54,000 --> 00:08:58,560
so sound effect music all that stuff

00:08:56,640 --> 00:09:00,480
and finally we're gonna loot everything

00:08:58,560 --> 00:09:01,040
that is the game rules and the databases

00:09:00,480 --> 00:09:03,360
which

00:09:01,040 --> 00:09:04,080
other people sometimes call scripting

00:09:03,360 --> 00:09:05,920
it's

00:09:04,080 --> 00:09:07,519
a lot of thing that defines how the game

00:09:05,920 --> 00:09:09,440
play out

00:09:07,519 --> 00:09:10,720
and most of that is defined in script

00:09:09,440 --> 00:09:12,480
because first we want

00:09:10,720 --> 00:09:14,480
uh designers to be able to iterate

00:09:12,480 --> 00:09:16,800
faster so that way it's not

00:09:14,480 --> 00:09:18,800
in code it's in script and also we want

00:09:16,800 --> 00:09:20,959
people again to be able to mod the game

00:09:18,800 --> 00:09:22,959
and so we need to have that exposed to

00:09:20,959 --> 00:09:25,839
the user

00:09:22,959 --> 00:09:27,360
so to give you an id um of the timeline

00:09:25,839 --> 00:09:29,200
basically uh

00:09:27,360 --> 00:09:31,120
we're gonna on the on the main thread

00:09:29,200 --> 00:09:31,920
we're gonna start the uh enumeration in

00:09:31,120 --> 00:09:32,959
the background

00:09:31,920 --> 00:09:35,440
and then we're gonna read the

00:09:32,959 --> 00:09:37,120
localization

00:09:35,440 --> 00:09:39,279
and then we're gonna load the audio you

00:09:37,120 --> 00:09:41,120
have the timings on top uh cpu just

00:09:39,279 --> 00:09:41,680
means like the actual cpu time that the

00:09:41,120 --> 00:09:44,640
the

00:09:41,680 --> 00:09:45,200
the thread itself was burning doing

00:09:44,640 --> 00:09:46,480
something

00:09:45,200 --> 00:09:48,640
and the rest is just waiting on

00:09:46,480 --> 00:09:50,480
synchronization or sleeping

00:09:48,640 --> 00:09:52,080
uh once that is done uh we're gonna

00:09:50,480 --> 00:09:54,720
switch to another thread um

00:09:52,080 --> 00:09:55,680
this is just a technicality because uh

00:09:54,720 --> 00:09:57,360
windows

00:09:55,680 --> 00:09:59,200
on windows you have to have your main

00:09:57,360 --> 00:10:00,240
thread always reading the message loop

00:09:59,200 --> 00:10:02,399
or

00:10:00,240 --> 00:10:03,680
the application looks unresponsive so

00:10:02,399 --> 00:10:04,880
that's why it's happening on two threads

00:10:03,680 --> 00:10:05,839
but it could be the same one it doesn't

00:10:04,880 --> 00:10:07,839
really matter

00:10:05,839 --> 00:10:09,920
uh we're gonna go to 2d assets we're

00:10:07,839 --> 00:10:11,200
going to look at the 3d assets

00:10:09,920 --> 00:10:14,320
and we're going to load the game

00:10:11,200 --> 00:10:16,000
databases uh as you can see there is a

00:10:14,320 --> 00:10:17,600
lot of waiting on the top

00:10:16,000 --> 00:10:19,519
and at the bottom not so much waiting

00:10:17,600 --> 00:10:21,680
but a lot of cpu time

00:10:19,519 --> 00:10:23,200
uh it's much better in the new one but i

00:10:21,680 --> 00:10:24,959
think the best way of looking at it is

00:10:23,200 --> 00:10:27,839
an actual ball chart

00:10:24,959 --> 00:10:30,839
so uh every bar on the left is the uh

00:10:27,839 --> 00:10:33,600
current release every bar on the right

00:10:30,839 --> 00:10:35,200
is the is the new beta that

00:10:33,600 --> 00:10:36,880
we're gonna publish in i don't know

00:10:35,200 --> 00:10:40,160
exactly the reason it's not

00:10:36,880 --> 00:10:43,120
set yet uh blue means i'd also it's just

00:10:40,160 --> 00:10:43,680
you're waiting on something uh and uh

00:10:43,120 --> 00:10:45,519
orange

00:10:43,680 --> 00:10:47,200
you're actually doing work to some

00:10:45,519 --> 00:10:48,800
extent could be a spin lock but you're

00:10:47,200 --> 00:10:50,320
doing something your cpu is just not

00:10:48,800 --> 00:10:52,560
slipping

00:10:50,320 --> 00:10:53,519
and as you can see the the difference is

00:10:52,560 --> 00:10:55,440
kind of

00:10:53,519 --> 00:10:56,720
tremendous and stuff like localization

00:10:55,440 --> 00:10:59,360
in audio and still

00:10:56,720 --> 00:11:00,000
quite visible on 3d and 2d assets and

00:10:59,360 --> 00:11:02,640
this is

00:11:00,000 --> 00:11:05,120
mainly why the game starts 20 seconds

00:11:02,640 --> 00:11:08,320
instead of a minute now

00:11:05,120 --> 00:11:10,399
so let's try to break it down

00:11:08,320 --> 00:11:12,640
what does that mean to have high cpu

00:11:10,399 --> 00:11:12,640
time

00:11:12,800 --> 00:11:16,399
the most obvious option is your code is

00:11:14,640 --> 00:11:19,040
single threaded right like

00:11:16,399 --> 00:11:20,240
you could be using a course 10 course 20

00:11:19,040 --> 00:11:21,440
course i don't know how many course they

00:11:20,240 --> 00:11:24,240
make these days but

00:11:21,440 --> 00:11:24,560
you're not you have you have one thread

00:11:24,240 --> 00:11:25,839
and

00:11:24,560 --> 00:11:29,120
everything in your computation is

00:11:25,839 --> 00:11:32,480
running on one thread so obviously

00:11:29,120 --> 00:11:34,000
like seven eighths of your cpu or how

00:11:32,480 --> 00:11:36,399
many calls you have it's just

00:11:34,000 --> 00:11:39,200
not doing much it could be it could be

00:11:36,399 --> 00:11:40,800
better if it was a parallel algorithm

00:11:39,200 --> 00:11:42,720
you could have an actual inefficient

00:11:40,800 --> 00:11:45,839
algorithm like maybe the way you

00:11:42,720 --> 00:11:47,200
process stuff is not good like i don't

00:11:45,839 --> 00:11:50,000
know maybe you have an

00:11:47,200 --> 00:11:51,600
n square or n cube algorithm when

00:11:50,000 --> 00:11:53,839
something could be done in linear or

00:11:51,600 --> 00:11:55,440
maybe n log in time

00:11:53,839 --> 00:11:57,440
you could have of course more like

00:11:55,440 --> 00:11:59,440
technical cpu bound

00:11:57,440 --> 00:12:02,079
issues like you have a lot of branch

00:11:59,440 --> 00:12:05,920
misprediction or a lot of cash basis

00:12:02,079 --> 00:12:09,120
a lot of funky topic or you could just

00:12:05,920 --> 00:12:10,560
be busy on a spin lock since this is a

00:12:09,120 --> 00:12:12,480
talk about threading

00:12:10,560 --> 00:12:13,839
i am going to leave out inefficient

00:12:12,480 --> 00:12:15,680
algorithm and branch

00:12:13,839 --> 00:12:17,360
prediction and all that funky stuff out

00:12:15,680 --> 00:12:18,800
of the out of the topic it's a

00:12:17,360 --> 00:12:20,240
fascinating topic

00:12:18,800 --> 00:12:22,560
but it's not one that i want to address

00:12:20,240 --> 00:12:24,320
to today and it's not

00:12:22,560 --> 00:12:26,800
one that i needed to achieve those

00:12:24,320 --> 00:12:26,800
results

00:12:27,519 --> 00:12:33,839
what about the wait time the way time

00:12:30,959 --> 00:12:35,200
could be due to disk io just i mean we

00:12:33,839 --> 00:12:37,200
have to read stuff right there's a lot

00:12:35,200 --> 00:12:38,000
of textures there's a lot of files to

00:12:37,200 --> 00:12:40,160
load

00:12:38,000 --> 00:12:41,360
that's not that's not free you need to

00:12:40,160 --> 00:12:44,399
actually spin

00:12:41,360 --> 00:12:45,120
or in case of an hdd or just read in

00:12:44,399 --> 00:12:47,680
case of an

00:12:45,120 --> 00:12:49,600
ssd you need to get the data from from

00:12:47,680 --> 00:12:51,279
an actual physical drive

00:12:49,600 --> 00:12:52,959
could be network course for for some

00:12:51,279 --> 00:12:54,560
reason maybe you need some resources

00:12:52,959 --> 00:12:56,560
that are not on the machine

00:12:54,560 --> 00:12:58,160
and you need to call a remote server to

00:12:56,560 --> 00:13:01,120
get them and maybe you're stalling

00:12:58,160 --> 00:13:03,760
because you're waiting for the answer

00:13:01,120 --> 00:13:05,040
could be locked i mean obviously you can

00:13:03,760 --> 00:13:06,079
kind of guess that there is something

00:13:05,040 --> 00:13:08,079
due to that like

00:13:06,079 --> 00:13:09,680
waiting on a new text or semi-4 or

00:13:08,079 --> 00:13:12,160
something else

00:13:09,680 --> 00:13:14,160
uh it could be synchronization uh which

00:13:12,160 --> 00:13:16,959
is kind of the same thing but not really

00:13:14,160 --> 00:13:18,160
uh you'd be more like you're waiting on

00:13:16,959 --> 00:13:19,839
something to be done

00:13:18,160 --> 00:13:21,680
uh maybe you launched a bunch of

00:13:19,839 --> 00:13:22,800
computation and you have like a run

00:13:21,680 --> 00:13:24,399
different points

00:13:22,800 --> 00:13:25,839
and you hope that everything will be

00:13:24,399 --> 00:13:27,200
done by the time you're actually

00:13:25,839 --> 00:13:28,800
reading the value for example you're

00:13:27,200 --> 00:13:29,360
waiting on the future that is not

00:13:28,800 --> 00:13:32,560
complete

00:13:29,360 --> 00:13:34,320
something like that funny enough the

00:13:32,560 --> 00:13:36,399
only thing i did not have to touch

00:13:34,320 --> 00:13:38,560
to fix the loading problem was this guy

00:13:36,399 --> 00:13:38,560
oh

00:13:39,199 --> 00:13:43,360
all right so let's get into the actual

00:13:42,160 --> 00:13:45,519
uh

00:13:43,360 --> 00:13:48,480
issue one of the main issues we had uh

00:13:45,519 --> 00:13:50,959
in all code and that was locks

00:13:48,480 --> 00:13:52,160
there's a great quote uh that i think i

00:13:50,959 --> 00:13:54,800
learned in another talk

00:13:52,160 --> 00:13:56,000
uh at accu sadly the recording has been

00:13:54,800 --> 00:13:59,279
lost to uh

00:13:56,000 --> 00:14:00,399
bad um equipment but uh it's it's from

00:13:59,279 --> 00:14:04,320
david buten off

00:14:00,399 --> 00:14:05,920
uh i think he wrote that quotes in um

00:14:04,320 --> 00:14:07,760
on the mailing list if i recall

00:14:05,920 --> 00:14:09,040
correctly but that isn't good enough for

00:14:07,760 --> 00:14:11,120
those who don't know him it's the man

00:14:09,040 --> 00:14:12,800
who invented posix threats i mean

00:14:11,120 --> 00:14:14,880
i don't know if you invented them or

00:14:12,800 --> 00:14:16,560
implemented them but he made posix

00:14:14,880 --> 00:14:18,639
threads and he wrote a bunch of books

00:14:16,560 --> 00:14:20,800
about uh about threads and especially

00:14:18,639 --> 00:14:23,600
posix threads

00:14:20,800 --> 00:14:24,160
and he wrote that great quote he said in

00:14:23,600 --> 00:14:25,920
the mail

00:14:24,160 --> 00:14:27,360
email in the menus instead of picking up

00:14:25,920 --> 00:14:28,480
this cubed acronym

00:14:27,360 --> 00:14:31,519
we should have called the basic

00:14:28,480 --> 00:14:33,920
synchronization object the ball neck

00:14:31,519 --> 00:14:35,279
so instead of mutex like start mutex he

00:14:33,920 --> 00:14:37,360
would have preferred if we i mean

00:14:35,279 --> 00:14:38,800
it was not c plus plus but instead of

00:14:37,360 --> 00:14:40,560
stud mutex

00:14:38,800 --> 00:14:42,560
what if we called it stud bottleneck

00:14:40,560 --> 00:14:44,639
maybe it would just make things more

00:14:42,560 --> 00:14:46,880
obvious for people

00:14:44,639 --> 00:14:48,800
he continues on his emails saying

00:14:46,880 --> 00:14:51,120
sometimes bottlenecks are useful

00:14:48,800 --> 00:14:52,880
sometimes they're indispensable but they

00:14:51,120 --> 00:14:55,440
will never be good

00:14:52,880 --> 00:14:58,959
at best they're unnecessary evil and i

00:14:55,440 --> 00:15:02,160
think that explains mutex perfectly

00:14:58,959 --> 00:15:03,360
um to give you an idea i continued on my

00:15:02,160 --> 00:15:06,320
profiling uh

00:15:03,360 --> 00:15:07,680
with with stellaris and i'm gonna remove

00:15:06,320 --> 00:15:08,079
stuff that is not super important for

00:15:07,680 --> 00:15:09,279
that

00:15:08,079 --> 00:15:11,519
for that talk especially because it's

00:15:09,279 --> 00:15:14,240
happening on secondary threads

00:15:11,519 --> 00:15:15,040
but here is here is the idea of what my

00:15:14,240 --> 00:15:18,240
computation

00:15:15,040 --> 00:15:20,560
uh threads are doing during loading

00:15:18,240 --> 00:15:22,399
uh fizzy fest i'm gonna come back to it

00:15:20,560 --> 00:15:23,920
in a minute is the library we use to

00:15:22,399 --> 00:15:27,600
actually access the file system

00:15:23,920 --> 00:15:30,240
and as you can see for about

00:15:27,600 --> 00:15:32,560
less than three seconds uh time waiting

00:15:30,240 --> 00:15:35,759
on actual disc io

00:15:32,560 --> 00:15:38,880
we spend almost a minute

00:15:35,759 --> 00:15:38,880
waiting on the mutex

00:15:39,040 --> 00:15:42,639
as you may imagine that's a lot

00:15:43,279 --> 00:15:48,480
basically um in in this case which

00:15:46,399 --> 00:15:50,480
uh it's it's kind of it's a bit cheating

00:15:48,480 --> 00:15:52,480
because we're accessing hold cache

00:15:50,480 --> 00:15:54,240
so half those files are actually not on

00:15:52,480 --> 00:15:55,759
the on we don't even have to we're not

00:15:54,240 --> 00:15:59,680
bound by uh by ssd

00:15:55,759 --> 00:16:01,600
uh speeds we're bound by uh by

00:15:59,680 --> 00:16:03,360
like disk cache on the operating system

00:16:01,600 --> 00:16:06,079
but even with a good ssd

00:16:03,360 --> 00:16:07,360
uh even without the other disk just with

00:16:06,079 --> 00:16:10,399
a good ssd

00:16:07,360 --> 00:16:15,600
you're still paying in some cases like 5

00:16:10,399 --> 00:16:15,600
10 20 times the actual io cost in io

00:16:16,480 --> 00:16:20,720
to uh to actually

00:16:19,430 --> 00:16:24,959
[Music]

00:16:20,720 --> 00:16:24,959
access to the physical system

00:16:25,279 --> 00:16:29,120
at this point you would probably go

00:16:27,040 --> 00:16:32,399
faster if you would single thread

00:16:29,120 --> 00:16:34,800
because i mean unless you have enough

00:16:32,399 --> 00:16:38,560
course to compensate for the 20

00:16:34,800 --> 00:16:41,600
uh times the i o and

00:16:38,560 --> 00:16:43,519
probably won't even because 20 times uh

00:16:41,600 --> 00:16:44,639
the cost probably would scale with the

00:16:43,519 --> 00:16:47,680
number of uh

00:16:44,639 --> 00:16:49,440
of of course fighting over a lock so

00:16:47,680 --> 00:16:50,800
yeah at this point i think if i just

00:16:49,440 --> 00:16:51,279
changed all the code and said just

00:16:50,800 --> 00:16:52,560
loading

00:16:51,279 --> 00:16:54,079
one thread i would have been faster

00:16:52,560 --> 00:16:55,920
that's not what i did but i could have

00:16:54,079 --> 00:16:59,120
done that

00:16:55,920 --> 00:17:00,880
um so brings us the question why is

00:16:59,120 --> 00:17:03,199
there a way is there a mutex

00:17:00,880 --> 00:17:05,199
right because sure we're reading from

00:17:03,199 --> 00:17:06,079
the file system but as far as i know you

00:17:05,199 --> 00:17:08,400
can have two

00:17:06,079 --> 00:17:10,880
two threads reading two different files

00:17:08,400 --> 00:17:12,799
uh all two copies of the same file

00:17:10,880 --> 00:17:14,400
for that matter and that that shouldn't

00:17:12,799 --> 00:17:18,640
be blocking every other

00:17:14,400 --> 00:17:19,360
i o so let's take a look at fizzfest

00:17:18,640 --> 00:17:21,919
real quick

00:17:19,360 --> 00:17:23,919
fizzfest is an open source library uh

00:17:21,919 --> 00:17:25,280
that we use to handle the file system uh

00:17:23,919 --> 00:17:27,280
in all games

00:17:25,280 --> 00:17:28,559
it's extremely useful for video games

00:17:27,280 --> 00:17:31,280
because it

00:17:28,559 --> 00:17:32,559
emulates the mounting features of unix

00:17:31,280 --> 00:17:34,799
on every platforms

00:17:32,559 --> 00:17:37,120
meaning you can mount folders you can

00:17:34,799 --> 00:17:38,559
mount drives you can mount archives

00:17:37,120 --> 00:17:40,799
and everything looks like something that

00:17:38,559 --> 00:17:41,280
starts from a slash and under it you can

00:17:40,799 --> 00:17:43,280
have

00:17:41,280 --> 00:17:47,200
as many uh sub directories and mount

00:17:43,280 --> 00:17:50,320
points as you want

00:17:47,200 --> 00:17:53,600
it's as i said per the author

00:17:50,320 --> 00:17:55,919
intention on his website uh intended for

00:17:53,600 --> 00:17:58,160
video games and i think if i have one

00:17:55,919 --> 00:18:00,000
criticism is that it's written in c and

00:17:58,160 --> 00:18:03,120
and i don't really like

00:18:00,000 --> 00:18:06,080
not anymore i used to so one of the good

00:18:03,120 --> 00:18:06,799
uh reason why we use this is because uh

00:18:06,080 --> 00:18:08,640
we need to

00:18:06,799 --> 00:18:11,280
have mount points in video games for

00:18:08,640 --> 00:18:15,520
example if i want to resolve an asset

00:18:11,280 --> 00:18:17,679
uh in in my game i have to figure out

00:18:15,520 --> 00:18:19,039
where to find it in the game because

00:18:17,679 --> 00:18:19,840
basically the idea is that we support

00:18:19,039 --> 00:18:21,840
overrides

00:18:19,840 --> 00:18:22,880
so by default you would have something

00:18:21,840 --> 00:18:25,120
like games

00:18:22,880 --> 00:18:26,720
assets which would be the main search

00:18:25,120 --> 00:18:29,840
point but then we happen more

00:18:26,720 --> 00:18:29,840
um search

00:18:30,240 --> 00:18:34,799
search mount points that should take

00:18:31,679 --> 00:18:36,640
precedence the basic idea is that

00:18:34,799 --> 00:18:38,880
anything in the base game can probably

00:18:36,640 --> 00:18:42,400
be overridden by uh by a dlc

00:18:38,880 --> 00:18:43,919
a special adonable expansion

00:18:42,400 --> 00:18:46,240
that would bring up i don't know maybe

00:18:43,919 --> 00:18:48,000
new models new ass

00:18:46,240 --> 00:18:50,480
better version of some assets something

00:18:48,000 --> 00:18:52,720
like that and of course it can then

00:18:50,480 --> 00:18:54,559
again you have it written by mothers

00:18:52,720 --> 00:18:54,960
because they want to actually modify the

00:18:54,559 --> 00:18:56,720
game

00:18:54,960 --> 00:18:59,600
and of course whatever they do should

00:18:56,720 --> 00:18:59,600
come first

00:19:00,720 --> 00:19:03,919
the problem is the threading model of s

00:19:03,200 --> 00:19:05,520
because

00:19:03,919 --> 00:19:07,440
this library was designed in the early

00:19:05,520 --> 00:19:09,520
2000s back

00:19:07,440 --> 00:19:11,840
in a time where i think most cpus had

00:19:09,520 --> 00:19:14,400
only one core and all one thread uh i

00:19:11,840 --> 00:19:15,120
preferred it would come up in 2003 or

00:19:14,400 --> 00:19:17,200
four

00:19:15,120 --> 00:19:19,200
so at the time you could unless you had

00:19:17,200 --> 00:19:20,960
like a very real machine with actual two

00:19:19,200 --> 00:19:23,440
physical cpus

00:19:20,960 --> 00:19:24,000
you would only have one process running

00:19:23,440 --> 00:19:27,039
at the same

00:19:24,000 --> 00:19:29,120
time so people did not like do

00:19:27,039 --> 00:19:30,400
aggressive threading like we do in uh in

00:19:29,120 --> 00:19:33,520
stellaris they would not

00:19:30,400 --> 00:19:37,280
try to uh start up like i don't know

00:19:33,520 --> 00:19:38,799
uh six or eight threads just to access

00:19:37,280 --> 00:19:40,640
the file system in concurrency you would

00:19:38,799 --> 00:19:41,039
just you would just spend your time in a

00:19:40,640 --> 00:19:43,280
in

00:19:41,039 --> 00:19:44,559
in in in in the schedule or on the

00:19:43,280 --> 00:19:46,720
operating system committing between the

00:19:44,559 --> 00:19:48,799
fighters there is nothing to gain there

00:19:46,720 --> 00:19:50,480
and that's why when it started caring

00:19:48,799 --> 00:19:52,240
about uh about fred's

00:19:50,480 --> 00:19:53,919
the biggest concern was threat safety

00:19:52,240 --> 00:19:55,360
that's mostly what what we were

00:19:53,919 --> 00:19:57,919
concerned about was it okay

00:19:55,360 --> 00:19:59,760
if someone decides to be fancy and have

00:19:57,919 --> 00:20:01,760
like effect at the second thread

00:19:59,760 --> 00:20:04,240
we just don't want we just don't want uh

00:20:01,760 --> 00:20:06,000
race conditions

00:20:04,240 --> 00:20:08,159
so basically what did they do they put

00:20:06,000 --> 00:20:11,919
one big mutex on the api

00:20:08,159 --> 00:20:15,520
and every time you get inside the api uh

00:20:11,919 --> 00:20:18,000
you get uh one one ft mutex that blocks

00:20:15,520 --> 00:20:18,000
everything

00:20:18,400 --> 00:20:21,919
which scale as you might guess very very

00:20:21,280 --> 00:20:26,080
badly

00:20:21,919 --> 00:20:26,080
uh if you have multiple phrases doing io

00:20:26,320 --> 00:20:30,320
excuse me i have a lot of uh background

00:20:28,320 --> 00:20:32,000
song i think it's due to slack

00:20:30,320 --> 00:20:34,720
uh i'm gonna see if i can kill it real

00:20:32,000 --> 00:20:36,000
quick no well hopefully it will

00:20:34,720 --> 00:20:38,159
if it comes back i'll try to do

00:20:36,000 --> 00:20:41,840
something about it anyway

00:20:38,159 --> 00:20:42,320
uh so what do you um what what what does

00:20:41,840 --> 00:20:43,760
the

00:20:42,320 --> 00:20:45,679
what is the piece of state what is the

00:20:43,760 --> 00:20:47,520
new text actually protecting

00:20:45,679 --> 00:20:49,600
the first thing is uh mountain points

00:20:47,520 --> 00:20:51,200
and uh library settings

00:20:49,600 --> 00:20:53,520
the debate the big the big thing is the

00:20:51,200 --> 00:20:54,960
configuration right if the user adds a

00:20:53,520 --> 00:20:58,080
new mount point

00:20:54,960 --> 00:21:00,480
while you're trying to seek a file

00:20:58,080 --> 00:21:02,240
uh there's a risk that uh too viable

00:21:00,480 --> 00:21:03,760
will collide and actually the file that

00:21:02,240 --> 00:21:04,559
is supposed to find is another one or

00:21:03,760 --> 00:21:06,159
worse

00:21:04,559 --> 00:21:07,760
they will start reading the same data

00:21:06,159 --> 00:21:08,799
structures and end results in a base

00:21:07,760 --> 00:21:10,880
condition

00:21:08,799 --> 00:21:12,799
there is also an open files list that is

00:21:10,880 --> 00:21:14,400
kept inside psfs i think it's mostly

00:21:12,799 --> 00:21:15,280
because the api being seen they do not

00:21:14,400 --> 00:21:18,000
handle

00:21:15,280 --> 00:21:19,120
ai and there is a mechanism if you shut

00:21:18,000 --> 00:21:20,960
down the library that

00:21:19,120 --> 00:21:22,480
ensures that if you have not closed uh

00:21:20,960 --> 00:21:23,200
some open files you would close them for

00:21:22,480 --> 00:21:24,720
you

00:21:23,200 --> 00:21:26,240
it's mostly a safety feature but that

00:21:24,720 --> 00:21:26,720
means that every time you open a file it

00:21:26,240 --> 00:21:28,840
has to

00:21:26,720 --> 00:21:31,280
put put it somewhere in an open price

00:21:28,840 --> 00:21:33,280
list uh you can also access

00:21:31,280 --> 00:21:35,440
the last error code like like error no

00:21:33,280 --> 00:21:37,120
on c and it's per thread

00:21:35,440 --> 00:21:39,440
and for some reason it's also protected

00:21:37,120 --> 00:21:42,159
by a mutex

00:21:39,440 --> 00:21:42,159
and finally

00:21:42,559 --> 00:21:46,559
if you load archives like zips or other

00:21:45,200 --> 00:21:49,760
archive formats

00:21:46,559 --> 00:21:50,799
uh you usually share the handle and then

00:21:49,760 --> 00:21:52,240
you make a copy

00:21:50,799 --> 00:21:54,000
afterwards but there is a bunch of state

00:21:52,240 --> 00:21:55,360
that is kept for i think it's caching

00:21:54,000 --> 00:21:57,039
basically performance reason

00:21:55,360 --> 00:21:58,720
like i think the index of the of the

00:21:57,039 --> 00:22:01,039
archive is only read once

00:21:58,720 --> 00:22:03,280
so you have to be sure that uh only one

00:22:01,039 --> 00:22:04,960
uh thread is actually uh computing the

00:22:03,280 --> 00:22:07,679
making the index of the archive so then

00:22:04,960 --> 00:22:09,440
the next one can just query it

00:22:07,679 --> 00:22:10,799
so how do they improve it well the first

00:22:09,440 --> 00:22:11,520
thing i do is that i change everything

00:22:10,799 --> 00:22:15,280
to c

00:22:11,520 --> 00:22:17,600
because uh because the c interface was

00:22:15,280 --> 00:22:19,520
making it a bit painful i will not show

00:22:17,600 --> 00:22:21,039
code here but there is a lot of macros

00:22:19,520 --> 00:22:22,000
involved to make sure that you release

00:22:21,039 --> 00:22:25,120
the mutex

00:22:22,000 --> 00:22:26,720
i replaced everything with area i locked

00:22:25,120 --> 00:22:29,039
and then i started splitting the menu

00:22:26,720 --> 00:22:30,799
text into several because i mean

00:22:29,039 --> 00:22:32,559
depending on which data structures you

00:22:30,799 --> 00:22:36,559
want uh

00:22:32,559 --> 00:22:36,559
you don't care about the same things

00:22:37,520 --> 00:22:41,039
so what i did first is that i initially

00:22:39,840 --> 00:22:44,559
removed the error code

00:22:41,039 --> 00:22:47,760
uh mutex because turns out

00:22:44,559 --> 00:22:49,360
you don't need to lock something that is

00:22:47,760 --> 00:22:50,960
linked to the current thread you can

00:22:49,360 --> 00:22:52,559
just use a thread local and that's all

00:22:50,960 --> 00:22:53,360
the entire issue i think the problem was

00:22:52,559 --> 00:22:56,480
but there was no

00:22:53,360 --> 00:22:58,720
easy thread local at the time um

00:22:56,480 --> 00:22:59,600
and then the last ball i did i put the

00:22:58,720 --> 00:23:01,679
toggle

00:22:59,600 --> 00:23:02,880
because as it turns out the main reason

00:23:01,679 --> 00:23:05,120
why we're always locking

00:23:02,880 --> 00:23:06,240
is that we always need to lock the the

00:23:05,120 --> 00:23:09,760
mounts list

00:23:06,240 --> 00:23:12,640
the list of mount points but

00:23:09,760 --> 00:23:13,440
when do you actually change that most of

00:23:12,640 --> 00:23:15,360
the time

00:23:13,440 --> 00:23:16,960
you change it as the game is starting up

00:23:15,360 --> 00:23:18,400
sorry there's really a lot of feedback

00:23:16,960 --> 00:23:20,240
with uh

00:23:18,400 --> 00:23:22,159
uh with something in the background i'll

00:23:20,240 --> 00:23:22,480
i'll try to remove it i think it's due

00:23:22,159 --> 00:23:25,919
to

00:23:22,480 --> 00:23:28,240
um discold and i will kill it right now

00:23:25,919 --> 00:23:30,320
oh yeah please die this gold thank you

00:23:28,240 --> 00:23:33,360
very much

00:23:30,320 --> 00:23:34,240
cool sorry about that uh yeah so a big

00:23:33,360 --> 00:23:36,799
idea was

00:23:34,240 --> 00:23:38,480
you don't mount files and archives all

00:23:36,799 --> 00:23:38,960
the time you mount them at the start

00:23:38,480 --> 00:23:40,400
when you

00:23:38,960 --> 00:23:42,240
when your game is starting up and you're

00:23:40,400 --> 00:23:43,120
figuring out which dlc and which mods

00:23:42,240 --> 00:23:46,400
are enabled

00:23:43,120 --> 00:23:49,679
and once you're done with it well

00:23:46,400 --> 00:23:50,480
you're not gonna touch it so the idea

00:23:49,679 --> 00:23:52,559
was

00:23:50,480 --> 00:23:53,840
if we can guarantee to the api is from

00:23:52,559 --> 00:23:56,960
my set

00:23:53,840 --> 00:23:58,880
i i i i swear i will not change the

00:23:56,960 --> 00:24:00,640
configuration from this point on

00:23:58,880 --> 00:24:04,240
then there is no need for mutex right

00:24:00,640 --> 00:24:05,679
because everybody can just access it

00:24:04,240 --> 00:24:07,919
we could have done something similar

00:24:05,679 --> 00:24:10,880
with a read write mutex but

00:24:07,919 --> 00:24:12,480
um i had some bad experience in the past

00:24:10,880 --> 00:24:14,960
before we write new text i just decided

00:24:12,480 --> 00:24:16,720
to go more simple and say you know what

00:24:14,960 --> 00:24:18,000
i'm just gonna have a setting that says

00:24:16,720 --> 00:24:21,279
i promise you i am not

00:24:18,000 --> 00:24:22,559
doing any uh any change to the

00:24:21,279 --> 00:24:23,840
configuration uh

00:24:22,559 --> 00:24:25,039
from this point on i just put the

00:24:23,840 --> 00:24:26,720
nursery to make sure someone will not

00:24:25,039 --> 00:24:29,120
break that promise later

00:24:26,720 --> 00:24:30,720
and then every uh every concurrent

00:24:29,120 --> 00:24:32,880
access would completely ignore the

00:24:30,720 --> 00:24:35,440
locking mechanic

00:24:32,880 --> 00:24:37,200
so well the first thing we noticed after

00:24:35,440 --> 00:24:39,840
that is that the wait time on

00:24:37,200 --> 00:24:40,880
the physique mutex entirely disappears

00:24:39,840 --> 00:24:44,320
which i mean

00:24:40,880 --> 00:24:47,600
yeah we mostly bypassed it so that's

00:24:44,320 --> 00:24:48,720
that's kind of expected the way time

00:24:47,600 --> 00:24:52,159
goes down

00:24:48,720 --> 00:24:55,120
uh because again

00:24:52,159 --> 00:24:55,520
we are less waiting on the uh on the

00:24:55,120 --> 00:24:58,240
mute

00:24:55,520 --> 00:25:01,039
the game starts a bit faster but just

00:24:58,240 --> 00:25:04,080
not entirely faster just a bit faster

00:25:01,039 --> 00:25:07,360
and the cpu load increases which

00:25:04,080 --> 00:25:09,279
i did not expect right because like even

00:25:07,360 --> 00:25:11,200
if we remove the sleep time on the mutex

00:25:09,279 --> 00:25:12,640
without doing more work we're just doing

00:25:11,200 --> 00:25:14,720
the same amount of work so why is the

00:25:12,640 --> 00:25:18,240
cpu load increasing

00:25:14,720 --> 00:25:20,880
that was weird so

00:25:18,240 --> 00:25:21,520
i don't know if anyone has ever been in

00:25:20,880 --> 00:25:24,480
france

00:25:21,520 --> 00:25:25,600
uh where i come from we have these signs

00:25:24,480 --> 00:25:28,799
on most uh

00:25:25,600 --> 00:25:30,480
railroad crossings that says a train

00:25:28,799 --> 00:25:32,240
might hide another train

00:25:30,480 --> 00:25:33,840
the big idea is that if a train is

00:25:32,240 --> 00:25:37,360
crossing uh

00:25:33,840 --> 00:25:38,720
do not immediately uh go behind that

00:25:37,360 --> 00:25:40,320
once it's gone because maybe there is

00:25:38,720 --> 00:25:42,159
another train behind it you cannot see

00:25:40,320 --> 00:25:43,760
because of the first one and

00:25:42,159 --> 00:25:45,279
it's kind of the same idea a lot may

00:25:43,760 --> 00:25:48,240
hide another lock

00:25:45,279 --> 00:25:50,400
and guess what there was another lock

00:25:48,240 --> 00:25:52,799
because

00:25:50,400 --> 00:25:54,559
we had our own wrapper around fisa fest

00:25:52,799 --> 00:25:56,000
just in case someone in the future would

00:25:54,559 --> 00:25:57,360
want to switch to another library and i

00:25:56,000 --> 00:25:59,679
think on one platform we

00:25:57,360 --> 00:26:00,720
used to but we dropped it historically

00:25:59,679 --> 00:26:02,480
anyway

00:26:00,720 --> 00:26:04,240
someone had put a spin lock on it

00:26:02,480 --> 00:26:06,080
because i don't know

00:26:04,240 --> 00:26:08,559
five ten years ago he got beaten by a

00:26:06,080 --> 00:26:10,640
bug on on linux

00:26:08,559 --> 00:26:12,480
uh there was still a race condition in

00:26:10,640 --> 00:26:15,440
one case that the fisifest mutex was not

00:26:12,480 --> 00:26:15,440
properly protecting

00:26:15,679 --> 00:26:20,559
it could be removed because that issue

00:26:17,520 --> 00:26:22,480
had been fixed i had fixed all the uh

00:26:20,559 --> 00:26:24,559
the the race conditions by making sure

00:26:22,480 --> 00:26:27,600
that my very

00:26:24,559 --> 00:26:29,279
light locking was actually not hiding

00:26:27,600 --> 00:26:32,240
any issue

00:26:29,279 --> 00:26:33,520
so i threw it away and turns out yeah we

00:26:32,240 --> 00:26:35,840
got a bunch faster

00:26:33,520 --> 00:26:37,360
the the big thing was localization and

00:26:35,840 --> 00:26:40,400
audio as you can see

00:26:37,360 --> 00:26:42,159
uh lost the entire wait time uh

00:26:40,400 --> 00:26:43,919
the cpu time for audio did not change

00:26:42,159 --> 00:26:45,600
immediately i i made another change

00:26:43,919 --> 00:26:47,120
which i will come back later

00:26:45,600 --> 00:26:49,200
but the wait time here and here

00:26:47,120 --> 00:26:51,279
completely disappears

00:26:49,200 --> 00:26:52,640
and the reason why if you remember we

00:26:51,279 --> 00:26:55,440
said at the start that we were

00:26:52,640 --> 00:26:57,200
uh starting a background thread that

00:26:55,440 --> 00:26:58,880
would just uh

00:26:57,200 --> 00:27:01,120
analyze the file system and collect the

00:26:58,880 --> 00:27:04,000
list of the assets enumerate everything

00:27:01,120 --> 00:27:05,600
that was done in like on like four or

00:27:04,000 --> 00:27:08,320
five threads

00:27:05,600 --> 00:27:09,440
and that was always colliding with the

00:27:08,320 --> 00:27:11,840
actual loading

00:27:09,440 --> 00:27:12,559
so as i was trying as we were trying to

00:27:11,840 --> 00:27:14,320
fetch

00:27:12,559 --> 00:27:16,240
uh the audio files as we were trying to

00:27:14,320 --> 00:27:17,919
fetch the localization file

00:27:16,240 --> 00:27:19,679
uh there was like four or five other

00:27:17,919 --> 00:27:20,000
threads we were trying to just scan the

00:27:19,679 --> 00:27:22,080
file

00:27:20,000 --> 00:27:23,760
system and list all the assets to be

00:27:22,080 --> 00:27:25,039
loaded in the next phases and they would

00:27:23,760 --> 00:27:25,600
just collide with each other all the

00:27:25,039 --> 00:27:27,120
time and

00:27:25,600 --> 00:27:30,080
the wait time here that completely

00:27:27,120 --> 00:27:33,120
vanished after the fix

00:27:30,080 --> 00:27:35,039
so my early thoughts about logs after

00:27:33,120 --> 00:27:38,320
all that is that

00:27:35,039 --> 00:27:39,039
as uh as as as routine as written in the

00:27:38,320 --> 00:27:41,520
quote

00:27:39,039 --> 00:27:45,440
they make you code thread safe but they

00:27:41,520 --> 00:27:45,440
will probably make it thread inefficient

00:27:47,200 --> 00:27:53,200
keeping a computation log free uh

00:27:50,480 --> 00:27:54,480
will possibly require a refactoring to

00:27:53,200 --> 00:27:57,120
use another approach

00:27:54,480 --> 00:27:58,480
in my case i was lucky turns out that a

00:27:57,120 --> 00:28:02,240
a read write lock

00:27:58,480 --> 00:28:04,799
or uh another kind of uh

00:28:02,240 --> 00:28:06,799
or promise that i will not be locking

00:28:04,799 --> 00:28:07,600
was able to do it but in some cases that

00:28:06,799 --> 00:28:09,360
doesn't work

00:28:07,600 --> 00:28:12,880
and you might need to refactor your code

00:28:09,360 --> 00:28:12,880
we're going to talk about it later on

00:28:13,120 --> 00:28:16,720
and the last issue would be that

00:28:14,720 --> 00:28:18,480
sometimes you have an algorithm

00:28:16,720 --> 00:28:19,919
and you're like oh i might need to lock

00:28:18,480 --> 00:28:21,760
here because i'm not so sure about

00:28:19,919 --> 00:28:24,240
fights 18.

00:28:21,760 --> 00:28:25,200
and even if you want to be sure you just

00:28:24,240 --> 00:28:27,520
add the lock

00:28:25,200 --> 00:28:29,120
run it to a profiler and it still looks

00:28:27,520 --> 00:28:32,240
okay

00:28:29,120 --> 00:28:33,760
potentially it looks okay because you're

00:28:32,240 --> 00:28:34,399
already eating another bottleneck

00:28:33,760 --> 00:28:38,080
somewhere

00:28:34,399 --> 00:28:40,080
and right now uh your code is probably

00:28:38,080 --> 00:28:43,600
not run in a parallel fashion

00:28:40,080 --> 00:28:46,720
uh because another code is uh

00:28:43,600 --> 00:28:49,120
is uh another another reason is

00:28:46,720 --> 00:28:50,640
is preventing that from happening but

00:28:49,120 --> 00:28:52,159
maybe in the future someone will change

00:28:50,640 --> 00:28:55,600
that

00:28:52,159 --> 00:28:57,360
and if he changes that uh he will hit

00:28:55,600 --> 00:28:59,039
your bottleneck now

00:28:57,360 --> 00:29:01,039
so what i'm saying is that you might by

00:28:59,039 --> 00:29:02,399
having a lock on something that is not

00:29:01,039 --> 00:29:05,520
highly parallel today

00:29:02,399 --> 00:29:06,640
you might create problems for the future

00:29:05,520 --> 00:29:08,159
i see there is a bunch of questions

00:29:06,640 --> 00:29:08,960
there i will try to answer them real

00:29:08,159 --> 00:29:11,760
quick

00:29:08,960 --> 00:29:12,159
is vision free yes i'm pretty sure it's

00:29:11,760 --> 00:29:14,399
free

00:29:12,159 --> 00:29:15,840
uh you just have to register on intel's

00:29:14,399 --> 00:29:18,080
website and you get the license

00:29:15,840 --> 00:29:18,960
like a year or something uh but it's

00:29:18,080 --> 00:29:20,240
free i

00:29:18,960 --> 00:29:22,159
i don't i know i don't think i'm paying

00:29:20,240 --> 00:29:24,559
for it uh

00:29:22,159 --> 00:29:26,399
what's the physical rapper proprietary

00:29:24,559 --> 00:29:28,880
or a third-party rapper

00:29:26,399 --> 00:29:30,559
yeah it's the wrapper i'm talking about

00:29:28,880 --> 00:29:30,960
is really not a big rapper it's really

00:29:30,559 --> 00:29:34,559
just

00:29:30,960 --> 00:29:37,360
in our engine code uh we uh we have a

00:29:34,559 --> 00:29:38,720
like an engine like paradox vfs access

00:29:37,360 --> 00:29:41,279
and we just

00:29:38,720 --> 00:29:42,159
either use vfs or use another api it

00:29:41,279 --> 00:29:44,080
turns out that

00:29:42,159 --> 00:29:45,520
we've removed the alternatives over time

00:29:44,080 --> 00:29:46,159
and physique is the only reason it's

00:29:45,520 --> 00:29:48,080
still there

00:29:46,159 --> 00:29:50,480
so it's more like an interface internal

00:29:48,080 --> 00:29:51,919
uh thing it doesn't do anything uh

00:29:50,480 --> 00:29:54,000
special it doesn't bring any

00:29:51,919 --> 00:29:55,919
improvements but i think that might help

00:29:54,000 --> 00:29:59,600
with the third question

00:29:55,919 --> 00:30:02,799
uh were the c physical uh changes uh

00:29:59,600 --> 00:30:04,480
published no uh it's not because of

00:30:02,799 --> 00:30:06,799
copyright or anything we're perfectly

00:30:04,480 --> 00:30:08,960
okay a paradox with publishing them

00:30:06,799 --> 00:30:10,159
the big issue is that in my quest to

00:30:08,960 --> 00:30:12,480
improve the code base

00:30:10,159 --> 00:30:13,200
and uh simplifying everything i switched

00:30:12,480 --> 00:30:16,000
to build

00:30:13,200 --> 00:30:16,960
and a bunch of the code to see and i'm

00:30:16,000 --> 00:30:19,760
pretty certain

00:30:16,960 --> 00:30:20,399
that if there is a gaming library in c

00:30:19,760 --> 00:30:22,640
uh

00:30:20,399 --> 00:30:24,159
the offer will not switch the compiler

00:30:22,640 --> 00:30:26,080
just to get that fixed

00:30:24,159 --> 00:30:27,760
so basically my patches themselves are

00:30:26,080 --> 00:30:30,880
not uh

00:30:27,760 --> 00:30:34,320
will not be able to work what i did is

00:30:30,880 --> 00:30:34,320
that i made a blog post about it

00:30:34,840 --> 00:30:40,240
um that i have the reference at the end

00:30:37,919 --> 00:30:41,200
uh which explains a bit more in detail

00:30:40,240 --> 00:30:42,960
with some code

00:30:41,200 --> 00:30:45,279
what i changed uh if it's still not

00:30:42,960 --> 00:30:45,760
enough feel free to come to me i might

00:30:45,279 --> 00:30:47,919
try to

00:30:45,760 --> 00:30:48,799
to actually uh contact the offer because

00:30:47,919 --> 00:30:51,279
again

00:30:48,799 --> 00:30:52,240
my patches straight up cannot be applied

00:30:51,279 --> 00:30:54,720
because they just

00:30:52,240 --> 00:30:57,120
change everything to c plus plus plus i

00:30:54,720 --> 00:30:59,279
think we also flipped the standard mutex

00:30:57,120 --> 00:31:00,480
with like our own internal engine

00:30:59,279 --> 00:31:02,960
mutexes

00:31:00,480 --> 00:31:06,720
just a weber but whatever so yeah as

00:31:02,960 --> 00:31:06,720
this will not use i have even not usable

00:31:08,559 --> 00:31:14,159
and i i will not answer the third

00:31:11,840 --> 00:31:16,880
question forfeit five question

00:31:14,159 --> 00:31:18,559
um this is just an old meme that doesn't

00:31:16,880 --> 00:31:20,640
want to die

00:31:18,559 --> 00:31:22,159
anyway let's talk about freddie now

00:31:20,640 --> 00:31:26,559
because okay let's see

00:31:22,159 --> 00:31:26,559
let's say okay we want to improve stuff

00:31:27,679 --> 00:31:31,440
last question i will take it afterwards

00:31:29,360 --> 00:31:35,200
to continue a bit with that section

00:31:31,440 --> 00:31:37,440
just to be sure all right so um

00:31:35,200 --> 00:31:38,480
we improve localization we improve the

00:31:37,440 --> 00:31:40,799
audio but

00:31:38,480 --> 00:31:43,279
2d and 3d assets are still not loading

00:31:40,799 --> 00:31:45,360
super fast

00:31:43,279 --> 00:31:46,799
as you can see uh the problem is not so

00:31:45,360 --> 00:31:48,720
much the weight i mean there is some

00:31:46,799 --> 00:31:49,600
weight and i think a bunch of that was

00:31:48,720 --> 00:31:51,279
reduced by the

00:31:49,600 --> 00:31:52,799
by the previous patch but it's not it's

00:31:51,279 --> 00:31:55,279
not a big deal you see the

00:31:52,799 --> 00:31:57,440
by the end of 2d asset loading there is

00:31:55,279 --> 00:31:58,880
not so much contention because the the

00:31:57,440 --> 00:32:00,480
thread that was loading the that was

00:31:58,880 --> 00:32:02,080
inverting the assets is completely

00:32:00,480 --> 00:32:04,559
is completely done so there is no threat

00:32:02,080 --> 00:32:07,760
contention on the on the read part

00:32:04,559 --> 00:32:10,240
it's just that it's just taking a lot of

00:32:07,760 --> 00:32:14,159
cpu time i guess

00:32:10,240 --> 00:32:17,360
uh why why is the question right

00:32:14,159 --> 00:32:18,880
so the problem is loading 2d and 3d

00:32:17,360 --> 00:32:20,559
assets with single threaded we can

00:32:18,880 --> 00:32:22,399
probably guess that because if you look

00:32:20,559 --> 00:32:23,039
at there is not much contention on the

00:32:22,399 --> 00:32:24,960
locks

00:32:23,039 --> 00:32:26,480
which kind of indicates that if there is

00:32:24,960 --> 00:32:28,399
no lock finding on something that was

00:32:26,480 --> 00:32:32,320
accessing the file system it's because

00:32:28,399 --> 00:32:34,480
there was no multi-threading it's

00:32:32,320 --> 00:32:36,640
a huge speed of potential if we can

00:32:34,480 --> 00:32:39,760
manage to actually spin more cores

00:32:36,640 --> 00:32:42,159
and load all that stuff uh in parallel

00:32:39,760 --> 00:32:43,120
but we couldn't do that because telarus

00:32:42,159 --> 00:32:46,960
was

00:32:43,120 --> 00:32:49,039
released in 2016 development started a

00:32:46,960 --> 00:32:51,279
couple years before that we're not a

00:32:49,039 --> 00:32:53,200
company that plays a lot with next-gen

00:32:51,279 --> 00:32:54,559
graphics so we were still in direct x-9s

00:32:53,200 --> 00:32:57,279
at the time

00:32:54,559 --> 00:32:58,880
and here it takes nine is not nice

00:32:57,279 --> 00:32:59,760
actually it literally says in the

00:32:58,880 --> 00:33:02,640
description

00:32:59,760 --> 00:33:04,480
direct3d is not default it does not

00:33:02,640 --> 00:33:06,720
default to thread safe

00:33:04,480 --> 00:33:09,679
when you're actually initializing it you

00:33:06,720 --> 00:33:11,679
can ask for multi-frame support

00:33:09,679 --> 00:33:13,360
but this will cause significant

00:33:11,679 --> 00:33:15,360
synchronization overhead

00:33:13,360 --> 00:33:17,840
basically what it's telling ourselves

00:33:15,360 --> 00:33:19,200
yes we have a multi-threaded support it

00:33:17,840 --> 00:33:20,720
basically means there's going to be a

00:33:19,200 --> 00:33:24,000
mutex on every of your call and we're

00:33:20,720 --> 00:33:26,640
going to go back to the fsps issue

00:33:24,000 --> 00:33:27,840
so basically the answer is like just

00:33:26,640 --> 00:33:30,960
don't

00:33:27,840 --> 00:33:32,799
like if you ask direct3d9 how do i do

00:33:30,960 --> 00:33:36,159
multi-threading the answer is

00:33:32,799 --> 00:33:38,640
don't i wasn't the dead end i

00:33:36,159 --> 00:33:40,320
i can't i can't fix an api that i'm

00:33:38,640 --> 00:33:43,679
using i'm not writing it

00:33:40,320 --> 00:33:45,919
uh and a thing that i did not expect

00:33:43,679 --> 00:33:48,799
happen

00:33:45,919 --> 00:33:49,600
excuse me my focus is failing okay i got

00:33:48,799 --> 00:33:51,919
saved

00:33:49,600 --> 00:33:53,600
by consoles which was very weird to me

00:33:51,919 --> 00:33:55,360
i've been a pc player all my life i own

00:33:53,600 --> 00:33:57,519
the console for like a year

00:33:55,360 --> 00:33:58,799
back in 92 or something i've never been

00:33:57,519 --> 00:34:00,559
into consult

00:33:58,799 --> 00:34:02,480
but guess what when we made the

00:34:00,559 --> 00:34:04,799
stellaris console edition

00:34:02,480 --> 00:34:05,840
we uh work with a partner because we

00:34:04,799 --> 00:34:07,679
don't have a lot of expertise in

00:34:05,840 --> 00:34:08,000
consoles and to put it on xbox it

00:34:07,679 --> 00:34:09,359
doesn't

00:34:08,000 --> 00:34:11,119
he didn't have the choice because xbox

00:34:09,359 --> 00:34:12,480
uh i think it's 360

00:34:11,119 --> 00:34:14,320
or maybe it's another one i don't know

00:34:12,480 --> 00:34:16,079
anything about consoles it does not

00:34:14,320 --> 00:34:18,320
support the x9 anymore instead

00:34:16,079 --> 00:34:19,440
they had to switch to 11. so what we

00:34:18,320 --> 00:34:21,839
could do

00:34:19,440 --> 00:34:23,119
with the uh most actually of that that

00:34:21,839 --> 00:34:25,760
work was done by

00:34:23,119 --> 00:34:26,879
by my colleague and tech director john

00:34:25,760 --> 00:34:29,359
uh

00:34:26,879 --> 00:34:30,960
we just could take the renderer that

00:34:29,359 --> 00:34:33,040
they've made for xbox

00:34:30,960 --> 00:34:34,000
and just put it back because turns out

00:34:33,040 --> 00:34:36,240
they're very close

00:34:34,000 --> 00:34:37,119
to each other because i mean the xbox is

00:34:36,240 --> 00:34:40,639
it's kind of a pc

00:34:37,119 --> 00:34:42,320
these guys and switching to dx11 meant

00:34:40,639 --> 00:34:44,960
we could go back to trying to do

00:34:42,320 --> 00:34:46,399
multi-threading when loading assets

00:34:44,960 --> 00:34:48,720
but of course it meant that we had to

00:34:46,399 --> 00:34:53,359
rewrite the loading algorithm

00:34:48,720 --> 00:34:56,720
because it could could not be an issue

00:34:53,359 --> 00:35:00,720
actually for 3d assets it wasn't hard

00:34:56,720 --> 00:35:02,400
this is mostly a verbatim copy of the

00:35:00,720 --> 00:35:04,400
of the code that loaded the assets on

00:35:02,400 --> 00:35:06,160
stellaris uh and that still loads them

00:35:04,400 --> 00:35:08,720
in the release version it's

00:35:06,160 --> 00:35:09,520
we have uh we have it's uh yeah it's an

00:35:08,720 --> 00:35:12,320
it's a hashmap

00:35:09,520 --> 00:35:13,440
of all the the 3d types uh that all

00:35:12,320 --> 00:35:16,160
declared uh

00:35:13,440 --> 00:35:16,160
three asset types

00:35:16,720 --> 00:35:20,000
we just do a full look for every entry

00:35:18,480 --> 00:35:20,800
and for every entry we just say need for

00:35:20,000 --> 00:35:23,200
device which

00:35:20,800 --> 00:35:25,040
basically is gonna load up the models uh

00:35:23,200 --> 00:35:27,760
the vertex buffers the textures blah

00:35:25,040 --> 00:35:30,880
blah blah blah blah

00:35:27,760 --> 00:35:33,920
how did we make that multithreaded

00:35:30,880 --> 00:35:35,920
we just put that in a parallel form

00:35:33,920 --> 00:35:37,599
and literally the job was done i could

00:35:35,920 --> 00:35:39,520
just go home and have a drink

00:35:37,599 --> 00:35:40,960
that was a that was a short day well i

00:35:39,520 --> 00:35:42,320
mean except i continued working on

00:35:40,960 --> 00:35:43,920
something else but

00:35:42,320 --> 00:35:45,359
realistically it was a very short date

00:35:43,920 --> 00:35:45,760
because the only thing i had to do was

00:35:45,359 --> 00:35:48,800
that

00:35:45,760 --> 00:35:51,680
and it went from there to there because

00:35:48,800 --> 00:35:53,119
suddenly instead of spinning one core i

00:35:51,680 --> 00:35:55,520
was spinning like eight or

00:35:53,119 --> 00:35:56,560
i think even or apparently four

00:35:55,520 --> 00:35:57,839
overcomets

00:35:56,560 --> 00:35:59,599
because it assumes that you're gonna do

00:35:57,839 --> 00:36:01,839
some io which in this case was actually

00:35:59,599 --> 00:36:03,839
a good idea because we do some io we

00:36:01,839 --> 00:36:05,119
we have at any time a bunch of threads

00:36:03,839 --> 00:36:05,920
are sleeping because they're waiting for

00:36:05,119 --> 00:36:07,920
io to happen

00:36:05,920 --> 00:36:10,000
while the other one can just spin and

00:36:07,920 --> 00:36:11,520
just do stuff with textures and vertex

00:36:10,000 --> 00:36:15,200
buffers and stuff like that

00:36:11,520 --> 00:36:19,119
so by spinning like 10 or 11 uh chorus

00:36:15,200 --> 00:36:21,920
on an acor machine uh we could just get

00:36:19,119 --> 00:36:24,320
about 1 8 of the time for the

00:36:21,920 --> 00:36:26,800
computation

00:36:24,320 --> 00:36:27,520
that was great and what it proves to me

00:36:26,800 --> 00:36:29,280
is that

00:36:27,520 --> 00:36:30,720
moving from serial to parallel doesn't

00:36:29,280 --> 00:36:33,920
have to be hard

00:36:30,720 --> 00:36:36,320
sometimes you're lucky sometime

00:36:33,920 --> 00:36:38,000
your loop is already fulfilling any and

00:36:36,320 --> 00:36:39,599
all requirements needed to be replaced

00:36:38,000 --> 00:36:41,200
by a parallel algorithm and you just

00:36:39,599 --> 00:36:43,839
replace your phone by a parallel four

00:36:41,200 --> 00:36:43,839
and you can go home

00:36:45,520 --> 00:36:49,280
the reasons uh the the the things you

00:36:47,599 --> 00:36:51,599
need to guarantee in that case

00:36:49,280 --> 00:36:53,200
uh first your iteration does not you

00:36:51,599 --> 00:36:55,040
should not write to any shared state

00:36:53,200 --> 00:36:56,400
because if they write to a common shared

00:36:55,040 --> 00:36:57,200
state you would need some kind of

00:36:56,400 --> 00:37:00,079
locking

00:36:57,200 --> 00:37:01,680
and then you like to square one uh the

00:37:00,079 --> 00:37:02,320
order of iteration should not be

00:37:01,680 --> 00:37:04,560
important

00:37:02,320 --> 00:37:05,680
because when you when you spin eight or

00:37:04,560 --> 00:37:08,560
ten cores

00:37:05,680 --> 00:37:10,320
into on on a big array and say you just

00:37:08,560 --> 00:37:11,680
get a chunk of it and just process it by

00:37:10,320 --> 00:37:13,200
yourself you have no control of which

00:37:11,680 --> 00:37:14,880
will be done first

00:37:13,200 --> 00:37:16,400
in most cases it's not important but in

00:37:14,880 --> 00:37:17,040
some cases it is for example in game

00:37:16,400 --> 00:37:19,119
logic

00:37:17,040 --> 00:37:20,079
uh we have protections against that in

00:37:19,119 --> 00:37:22,079
some cases because

00:37:20,079 --> 00:37:24,160
we need a deterministic order if you

00:37:22,079 --> 00:37:26,800
don't care about determinism

00:37:24,160 --> 00:37:28,720
you can go with it and yeah again

00:37:26,800 --> 00:37:30,240
finally you should not have any locks

00:37:28,720 --> 00:37:32,079
either because you're trying to protect

00:37:30,240 --> 00:37:33,440
a shared state or i mean

00:37:32,079 --> 00:37:35,200
that's probably the only reason you want

00:37:33,440 --> 00:37:36,800
to lock it but if you have a lock well

00:37:35,200 --> 00:37:39,520
you're back to the fistfest issue

00:37:36,800 --> 00:37:41,040
that you're probably burning more time

00:37:39,520 --> 00:37:44,560
fighting over a lot than doing

00:37:41,040 --> 00:37:45,839
something actually useful but what if

00:37:44,560 --> 00:37:48,160
you have to because i mean

00:37:45,839 --> 00:37:49,760
it's it's well and nice but i mean it's

00:37:48,160 --> 00:37:50,000
kind of a cop-out to say well just don't

00:37:49,760 --> 00:37:53,280
do

00:37:50,000 --> 00:37:54,880
locking just don't have any shirts easy

00:37:53,280 --> 00:37:56,480
sometimes you do sometimes this is what

00:37:54,880 --> 00:37:58,960
you're having sometimes you have

00:37:56,480 --> 00:38:00,640
locks oh no sometimes you have shirt

00:37:58,960 --> 00:38:03,280
state and you need to lock

00:38:00,640 --> 00:38:03,280
what can you do

00:38:03,680 --> 00:38:06,960
you have three options i mean you have

00:38:06,400 --> 00:38:08,400
probably more

00:38:06,960 --> 00:38:10,800
but that's the three easy one i could

00:38:08,400 --> 00:38:14,560
come up uh the first one is make copies

00:38:10,800 --> 00:38:16,480
because potentially the

00:38:14,560 --> 00:38:18,240
the the the the shared state you're

00:38:16,480 --> 00:38:20,480
you're writing to is actually not

00:38:18,240 --> 00:38:22,880
shared it's just a working set that

00:38:20,480 --> 00:38:25,599
happens to be sold in the same place

00:38:22,880 --> 00:38:26,720
and in that case uh the one of the

00:38:25,599 --> 00:38:28,320
solution is just

00:38:26,720 --> 00:38:29,920
make copies make copies and make sure

00:38:28,320 --> 00:38:32,320
that everybody has its own

00:38:29,920 --> 00:38:33,119
working set but sometimes those working

00:38:32,320 --> 00:38:36,160
sets

00:38:33,119 --> 00:38:37,839
actually need to end up together

00:38:36,160 --> 00:38:39,440
and that's where you can use uh you can

00:38:37,839 --> 00:38:43,359
use you can split the problem

00:38:39,440 --> 00:38:43,920
um it's i think it's called split apply

00:38:43,359 --> 00:38:45,200
combine

00:38:43,920 --> 00:38:46,720
or something like that it's i mean it's

00:38:45,200 --> 00:38:49,200
kind of like my produce and all those

00:38:46,720 --> 00:38:52,960
parallel classic algorithms the idea is

00:38:49,200 --> 00:38:55,040
you uh you make all your computation

00:38:52,960 --> 00:38:57,119
work on a private working set

00:38:55,040 --> 00:38:58,480
uh that you can run into in a

00:38:57,119 --> 00:39:00,480
multi-threaded fashion

00:38:58,480 --> 00:39:01,839
and once you're done you combine all the

00:39:00,480 --> 00:39:04,160
results and that

00:39:01,839 --> 00:39:05,920
is the serial loop and the idea is that

00:39:04,160 --> 00:39:09,040
hopefully combining everything

00:39:05,920 --> 00:39:10,960
is quite cheap uh it's basically

00:39:09,040 --> 00:39:12,400
aggregating some values

00:39:10,960 --> 00:39:14,640
you can do it in one core you're not

00:39:12,400 --> 00:39:16,400
losing too much

00:39:14,640 --> 00:39:17,760
the last option you can do is try to be

00:39:16,400 --> 00:39:19,359
smarter about locking

00:39:17,760 --> 00:39:20,800
it's kind of cheating but sometimes it

00:39:19,359 --> 00:39:22,000
works and i actually have a good example

00:39:20,800 --> 00:39:24,240
about that

00:39:22,000 --> 00:39:25,839
because let's look at the 2d asset load

00:39:24,240 --> 00:39:27,760
it's i mean

00:39:25,839 --> 00:39:29,200
word for word with just a very small

00:39:27,760 --> 00:39:30,560
differences it's kind of exactly the

00:39:29,200 --> 00:39:32,320
same code as the one we do

00:39:30,560 --> 00:39:33,680
we take all the sprite types we have in

00:39:32,320 --> 00:39:37,520
our sprite database

00:39:33,680 --> 00:39:40,880
and we just do a straight uh

00:39:37,520 --> 00:39:42,320
uh for at first i just say well i i've

00:39:40,880 --> 00:39:43,040
seen that before just put a parallel

00:39:42,320 --> 00:39:45,839
forward and

00:39:43,040 --> 00:39:46,560
and be done with it sadly didn't work

00:39:45,839 --> 00:39:48,640
because

00:39:46,560 --> 00:39:49,599
if you get inside uh that's what i tried

00:39:48,640 --> 00:39:52,960
first didn't work

00:39:49,599 --> 00:39:54,880
why because if you look at what our init

00:39:52,960 --> 00:39:56,480
for device stuff does it does a bunch of

00:39:54,880 --> 00:39:57,920
stuff but at some point what he does is

00:39:56,480 --> 00:40:00,079
says hey

00:39:57,920 --> 00:40:01,839
pull the texture ender and add the

00:40:00,079 --> 00:40:02,880
texture and just add the texture to that

00:40:01,839 --> 00:40:06,000
list and then you're like

00:40:02,880 --> 00:40:07,599
wait graphics that sounds like a sure

00:40:06,000 --> 00:40:09,280
variable

00:40:07,599 --> 00:40:10,720
texture handler that that sounds like

00:40:09,280 --> 00:40:11,920
something that may be shared and in all

00:40:10,720 --> 00:40:13,280
cases it was shared

00:40:11,920 --> 00:40:14,960
the texture handler is actually

00:40:13,280 --> 00:40:15,440
something in orange and there was at

00:40:14,960 --> 00:40:17,359
this

00:40:15,440 --> 00:40:19,599
in this generation of games was was

00:40:17,359 --> 00:40:22,560
basically it's one big uh

00:40:19,599 --> 00:40:24,319
it's one big ash map uh the goal is to

00:40:22,560 --> 00:40:27,599
to reuse textures right like if

00:40:24,319 --> 00:40:29,119
several uh different sprites share some

00:40:27,599 --> 00:40:30,400
textures because some sprites are

00:40:29,119 --> 00:40:32,079
actually a combination of several

00:40:30,400 --> 00:40:33,520
textures with different effects

00:40:32,079 --> 00:40:35,200
uh we do that a lot for buttons for

00:40:33,520 --> 00:40:36,800
example and a bunch of other stuff

00:40:35,200 --> 00:40:38,400
we don't want to load the same texture

00:40:36,800 --> 00:40:40,560
twice we want

00:40:38,400 --> 00:40:41,680
every sprite to refer to the same

00:40:40,560 --> 00:40:44,640
actually uh

00:40:41,680 --> 00:40:45,280
blob in memory and so to do that it's

00:40:44,640 --> 00:40:47,839
basically

00:40:45,280 --> 00:40:49,599
it's a hash map of a file name texture

00:40:47,839 --> 00:40:52,720
that is protected by a biosphere

00:40:49,599 --> 00:40:53,680
by a biomutex and that's that's the ball

00:40:52,720 --> 00:40:56,319
of leg

00:40:53,680 --> 00:40:57,119
because every time i'm loading a texture

00:40:56,319 --> 00:40:58,960
uh i'm

00:40:57,119 --> 00:41:00,400
basically waiting on the on the texture

00:40:58,960 --> 00:41:03,040
on the new text

00:41:00,400 --> 00:41:04,240
and and that's if i parallelize that i'm

00:41:03,040 --> 00:41:08,400
just gonna spend my time

00:41:04,240 --> 00:41:10,400
waiting here on this vlog all the time

00:41:08,400 --> 00:41:12,240
so i started thinking what can i do the

00:41:10,400 --> 00:41:14,319
best option i had

00:41:12,240 --> 00:41:16,640
my best id and i think the cleaner style

00:41:14,319 --> 00:41:18,400
you would have to split in three phases

00:41:16,640 --> 00:41:20,640
so the first thing would be okay has

00:41:18,400 --> 00:41:23,200
every uh sprites to declare with text

00:41:20,640 --> 00:41:24,079
which textures it needs but do not bind

00:41:23,200 --> 00:41:25,599
them immediately

00:41:24,079 --> 00:41:27,440
because that's the thing right right now

00:41:25,599 --> 00:41:27,920
we declare and we bind the textures at

00:41:27,440 --> 00:41:29,520
the same

00:41:27,920 --> 00:41:31,760
in the same path the idea was to split

00:41:29,520 --> 00:41:33,200
that first you declare what you need

00:41:31,760 --> 00:41:35,200
and that can be done in a parallel

00:41:33,200 --> 00:41:37,520
fashion then we take

00:41:35,200 --> 00:41:38,800
all the all the textures that have been

00:41:37,520 --> 00:41:40,640
uh that have been uh

00:41:38,800 --> 00:41:42,240
said to be needed we we crunch

00:41:40,640 --> 00:41:45,359
everything into one list

00:41:42,240 --> 00:41:45,839
of unique entries and again we spin that

00:41:45,359 --> 00:41:47,599
on

00:41:45,839 --> 00:41:49,920
whatever many calls you have and we load

00:41:47,599 --> 00:41:51,760
all of those in parallel because again

00:41:49,920 --> 00:41:53,119
every every texture has its own entry we

00:41:51,760 --> 00:41:55,119
guarantee it's unique we can just look

00:41:53,119 --> 00:41:58,319
all of them at the same time

00:41:55,119 --> 00:42:00,079
finally we pass back that stuff and we

00:41:58,319 --> 00:42:02,319
go to all sprites and say hey this is

00:42:00,079 --> 00:42:04,720
the constant shared uh

00:42:02,319 --> 00:42:06,000
texture handler just just just now you

00:42:04,720 --> 00:42:08,400
can update your pointers and have a

00:42:06,000 --> 00:42:10,480
direct reference to every texture

00:42:08,400 --> 00:42:13,760
that would be my ideal option the

00:42:10,480 --> 00:42:16,560
problem is to do that i had to refactor

00:42:13,760 --> 00:42:18,240
the entire sprite loading engine and i

00:42:16,560 --> 00:42:21,119
didn't have like a

00:42:18,240 --> 00:42:22,079
week to finish that so i tried something

00:42:21,119 --> 00:42:25,280
smarter

00:42:22,079 --> 00:42:27,280
and i went for reducing the log scope

00:42:25,280 --> 00:42:31,839
because here's the idea if you look back

00:42:27,280 --> 00:42:31,839
at this code

00:42:33,359 --> 00:42:38,480
is the texture already there and if it's

00:42:36,000 --> 00:42:41,359
if it's there it returns it if it's not

00:42:38,480 --> 00:42:42,880
it just uh loads it and adds it and

00:42:41,359 --> 00:42:45,440
actually you can split that operation

00:42:42,880 --> 00:42:49,359
even at this stage and make the lock

00:42:45,440 --> 00:42:52,400
a bit more smaller so here's what we did

00:42:49,359 --> 00:42:55,440
we opened the block same as before

00:42:52,400 --> 00:42:58,319
we block we check is the texture in the

00:42:55,440 --> 00:43:00,800
in the cache yet if it is great we're

00:42:58,319 --> 00:43:04,000
done we return and unlock the mutex

00:43:00,800 --> 00:43:07,359
if not we release the mutex

00:43:04,000 --> 00:43:10,000
and we load the texture then

00:43:07,359 --> 00:43:12,160
once we're done we take the lock again

00:43:10,000 --> 00:43:12,640
we open the cache again say hey do you

00:43:12,160 --> 00:43:14,960
have the

00:43:12,640 --> 00:43:17,280
do you have the texture this time nope

00:43:14,960 --> 00:43:19,760
still not well here it is

00:43:17,280 --> 00:43:20,319
and if by some chance some another

00:43:19,760 --> 00:43:21,760
thread

00:43:20,319 --> 00:43:23,440
managed to finish loading in the

00:43:21,760 --> 00:43:25,440
meantime and put it back

00:43:23,440 --> 00:43:27,280
we just threw away the texture we loaded

00:43:25,440 --> 00:43:29,760
it means that sometimes we're gonna have

00:43:27,280 --> 00:43:29,760
to uh

00:43:30,000 --> 00:43:33,119
it means that sometimes we're gonna have

00:43:31,599 --> 00:43:35,599
to uh

00:43:33,119 --> 00:43:36,960
we're gonna have to uh double uh we're

00:43:35,599 --> 00:43:39,119
gonna have to we're gonna double load

00:43:36,960 --> 00:43:41,920
the same texture and pull the copy away

00:43:39,119 --> 00:43:42,720
but in practice most of our textures do

00:43:41,920 --> 00:43:44,560
not share it

00:43:42,720 --> 00:43:46,000
it's a mechanism of sharing but it's not

00:43:44,560 --> 00:43:48,480
so hard that we

00:43:46,000 --> 00:43:51,040
load everything 10 times most of the

00:43:48,480 --> 00:43:52,560
time it's

00:43:51,040 --> 00:43:54,240
sometimes it happens that there's a

00:43:52,560 --> 00:43:54,960
double load but in most cases it did not

00:43:54,240 --> 00:43:56,400
happen i

00:43:54,960 --> 00:43:57,680
put like a counter somewhere just to

00:43:56,400 --> 00:43:58,240
make sure how many times you would dump

00:43:57,680 --> 00:44:01,520
a double

00:43:58,240 --> 00:44:02,240
uh a double uh load and it it's it's a

00:44:01,520 --> 00:44:05,599
very small

00:44:02,240 --> 00:44:10,000
thing and how did they uh why did

00:44:05,599 --> 00:44:12,800
it actually work the time went down

00:44:10,000 --> 00:44:14,400
and the wait time did not go crazy and

00:44:12,800 --> 00:44:15,200
the reason why i could get away with

00:44:14,400 --> 00:44:18,400
that

00:44:15,200 --> 00:44:19,599
was that the the very slow operation

00:44:18,400 --> 00:44:21,599
that every phrase

00:44:19,599 --> 00:44:23,760
is doing is loading a file from the file

00:44:21,599 --> 00:44:24,960
system actually there is a missing brace

00:44:23,760 --> 00:44:26,240
here oh there's an extra brace here and

00:44:24,960 --> 00:44:30,000
i should fix the slide

00:44:26,240 --> 00:44:31,599
uh and then uh this operation there it

00:44:30,000 --> 00:44:34,720
loads the the texture from the file

00:44:31,599 --> 00:44:38,400
system and then it binds it inside uh

00:44:34,720 --> 00:44:40,720
inside directx by uh doing a bunch of uh

00:44:38,400 --> 00:44:42,720
texture conversion operation feeding

00:44:40,720 --> 00:44:44,400
some stuff to the gpu i'm not a graphics

00:44:42,720 --> 00:44:46,240
expert but uh basically

00:44:44,400 --> 00:44:48,000
it's i o it's computation it's gonna

00:44:46,240 --> 00:44:50,640
take some time

00:44:48,000 --> 00:44:52,640
but it's why this heavy and costly

00:44:50,640 --> 00:44:54,000
operation is done we're not locking

00:44:52,640 --> 00:44:56,240
the only time we're locking is when

00:44:54,000 --> 00:44:58,079
we're trying to access the hash map

00:44:56,240 --> 00:44:59,680
and we're trying to insert into an ash

00:44:58,079 --> 00:45:05,440
map and that part

00:44:59,680 --> 00:45:08,319
is not really very expensive

00:45:05,440 --> 00:45:09,760
and this is why i could tactically

00:45:08,319 --> 00:45:13,040
improve the locking without

00:45:09,760 --> 00:45:15,119
uh and get away with it

00:45:13,040 --> 00:45:16,880
and yeah basically that's what i just

00:45:15,119 --> 00:45:19,680
said tactical changes sometimes

00:45:16,880 --> 00:45:21,359
are enough to improve parallelization i

00:45:19,680 --> 00:45:24,000
would probably get better games

00:45:21,359 --> 00:45:25,040
if i actually went for the first option

00:45:24,000 --> 00:45:28,400
i had

00:45:25,040 --> 00:45:31,359
but i already like reduced the time from

00:45:28,400 --> 00:45:32,000
seven seconds to one sure i could

00:45:31,359 --> 00:45:33,760
probably get

00:45:32,000 --> 00:45:35,280
down to half a sec but i would not get

00:45:33,760 --> 00:45:37,119
six more seconds again

00:45:35,280 --> 00:45:39,680
so it's a question of uh it's a

00:45:37,119 --> 00:45:41,839
trade-off with more time i would

00:45:39,680 --> 00:45:44,880
with just the time it was a great good

00:45:41,839 --> 00:45:46,960
tactical one and i was happy to take it

00:45:44,880 --> 00:45:49,839
i see there's more questions let's see

00:45:46,960 --> 00:45:51,839
do i have or use any tool to verify that

00:45:49,839 --> 00:45:56,400
erases when not inserted uh

00:45:51,839 --> 00:45:59,920
where removing logs um yes and no

00:45:56,400 --> 00:46:02,240
um when i did it on on facebook what i

00:45:59,920 --> 00:46:05,760
did is that i put uh

00:46:02,240 --> 00:46:08,880
i put an atomic variable uh

00:46:05,760 --> 00:46:09,200
to check if we that that that that told

00:46:08,880 --> 00:46:12,160
me

00:46:09,200 --> 00:46:13,119
if we were in a impromised uh read-only

00:46:12,160 --> 00:46:15,119
mode yes no

00:46:13,119 --> 00:46:17,680
and then i put an assert in the in the

00:46:15,119 --> 00:46:19,839
api meaning if at any point someone

00:46:17,680 --> 00:46:23,359
called the fsfs api to modify

00:46:19,839 --> 00:46:25,280
something uh it would track the assert

00:46:23,359 --> 00:46:26,960
that was not perfect i could have

00:46:25,280 --> 00:46:29,280
probably done more stuff with some stuff

00:46:26,960 --> 00:46:31,599
like uh

00:46:29,280 --> 00:46:32,960
what's the thing uh thread sanitizers

00:46:31,599 --> 00:46:36,480
and stuff like that but i

00:46:32,960 --> 00:46:38,079
i did not need to go all that way so far

00:46:36,480 --> 00:46:39,920
is there any other step in the future to

00:46:38,079 --> 00:46:42,560
speeding things up uh

00:46:39,920 --> 00:46:44,079
for the startup of the game i mean i'm

00:46:42,560 --> 00:46:45,119
i'm moving to another team now so i

00:46:44,079 --> 00:46:46,800
don't know

00:46:45,119 --> 00:46:48,560
there's probably still some venue for

00:46:46,800 --> 00:46:50,880
improvements but to be honest

00:46:48,560 --> 00:46:51,599
we already divided the startup time by i

00:46:50,880 --> 00:46:55,440
don't know like

00:46:51,599 --> 00:46:57,760
six five uh it improved us already like

00:46:55,440 --> 00:46:59,200
it improved the workflow for uh of our

00:46:57,760 --> 00:47:01,839
uh

00:46:59,200 --> 00:47:03,520
of our people tremendously i have some

00:47:01,839 --> 00:47:05,280
opinions about what i could not

00:47:03,520 --> 00:47:06,480
uh do in the future but that's that's

00:47:05,280 --> 00:47:08,079
maybe something we should take off

00:47:06,480 --> 00:47:09,599
because uh it's it's not related to

00:47:08,079 --> 00:47:12,079
those changes

00:47:09,599 --> 00:47:14,319
oriented identifier with an underscore

00:47:12,079 --> 00:47:16,319
followed by a pakistan understanding

00:47:14,319 --> 00:47:20,079
yes you should tell that to the people

00:47:16,319 --> 00:47:20,079
who got the code standard my company

00:47:20,800 --> 00:47:26,160
anyway wait is that right

00:47:23,839 --> 00:47:27,680
let's go let's go quickly over the last

00:47:26,160 --> 00:47:30,720
bit that i have

00:47:27,680 --> 00:47:32,319
which is uh trying to be asynchronous

00:47:30,720 --> 00:47:35,119
and smart in some cases because we still

00:47:32,319 --> 00:47:37,599
have about 10 minutes to go for this

00:47:35,119 --> 00:47:39,200
so uh as you can see at the start we

00:47:37,599 --> 00:47:43,040
have an interesting

00:47:39,200 --> 00:47:45,599
uh thing with two threads uh

00:47:43,040 --> 00:47:46,079
fighting over the same thing uh one of

00:47:45,599 --> 00:47:47,680
them

00:47:46,079 --> 00:47:49,280
should be allowed to be red because the

00:47:47,680 --> 00:47:51,599
only thing it does is uh

00:47:49,280 --> 00:47:53,440
spinning on the uh on the input log to

00:47:51,599 --> 00:47:55,760
give the illusion to windows that the uh

00:47:53,440 --> 00:47:57,359
that the program is responding it's uh

00:47:55,760 --> 00:47:59,280
it's the requirements you have to

00:47:57,359 --> 00:48:01,280
respond to you have to pull the message

00:47:59,280 --> 00:48:03,359
queue every x millisecond or the

00:48:01,280 --> 00:48:04,640
the thing seems to dead and it's done in

00:48:03,359 --> 00:48:05,359
an aggressive loop i don't think there

00:48:04,640 --> 00:48:06,640
is any sleep

00:48:05,359 --> 00:48:08,640
we could improve that but it's not

00:48:06,640 --> 00:48:09,920
really super important the real problem

00:48:08,640 --> 00:48:11,440
was that

00:48:09,920 --> 00:48:14,559
it was still fighting with something

00:48:11,440 --> 00:48:17,040
else here and i tried to take a look

00:48:14,559 --> 00:48:18,079
the five seconds here were actually a

00:48:17,040 --> 00:48:21,839
busy weight

00:48:18,079 --> 00:48:23,440
on the network core it was a busy weight

00:48:21,839 --> 00:48:24,880
on a network call

00:48:23,440 --> 00:48:26,640
so what i did first is said you know

00:48:24,880 --> 00:48:28,400
what maybe we don't need to

00:48:26,640 --> 00:48:30,079
busy wait on the network call maybe we

00:48:28,400 --> 00:48:33,119
can just put that in the future and

00:48:30,079 --> 00:48:35,280
and get the results uh later

00:48:33,119 --> 00:48:36,720
so i did that and then i refactored and

00:48:35,280 --> 00:48:40,079
refactored to see

00:48:36,720 --> 00:48:42,559
where the data was used

00:48:40,079 --> 00:48:44,400
it turns out it was not it was a network

00:48:42,559 --> 00:48:47,040
call that was left from the past

00:48:44,400 --> 00:48:48,480
uh before we did some migration to the

00:48:47,040 --> 00:48:51,599
uh to

00:48:48,480 --> 00:48:53,760
use the another launcher and that work

00:48:51,599 --> 00:48:55,040
was completely useless the the the

00:48:53,760 --> 00:48:57,280
values

00:48:55,040 --> 00:48:59,440
read from it was completely used i did

00:48:57,280 --> 00:49:00,160
not need to wait five or ten seconds for

00:48:59,440 --> 00:49:02,000
that network

00:49:00,160 --> 00:49:04,000
to timeout because i did not need the

00:49:02,000 --> 00:49:06,000
data at all i just

00:49:04,000 --> 00:49:07,760
got five seconds back just by throwing

00:49:06,000 --> 00:49:10,880
everything away

00:49:07,760 --> 00:49:12,240
i was pretty happy but sometimes it's

00:49:10,880 --> 00:49:14,240
not that easy sometimes you have

00:49:12,240 --> 00:49:17,440
actually something that you need to do

00:49:14,240 --> 00:49:19,200
it just you need to be smarter about it

00:49:17,440 --> 00:49:20,800
and the big question you have to ask

00:49:19,200 --> 00:49:23,839
yourself is okay you need to load all

00:49:20,800 --> 00:49:26,240
that data but do you have to load it now

00:49:23,839 --> 00:49:27,920
because again right our goal is that we

00:49:26,240 --> 00:49:29,760
want to drop the player in the main menu

00:49:27,920 --> 00:49:30,960
as fast as possible so he

00:49:29,760 --> 00:49:33,280
gets the impression that the game is

00:49:30,960 --> 00:49:36,720
fast and reactive

00:49:33,280 --> 00:49:38,800
but once he's in the main menu he's

00:49:36,720 --> 00:49:40,559
not gonna immediately start the game

00:49:38,800 --> 00:49:41,440
he's gonna start the game pretty fast

00:49:40,559 --> 00:49:44,640
but

00:49:41,440 --> 00:49:45,359
but in a in cpu time he's gonna move his

00:49:44,640 --> 00:49:48,079
mouse

00:49:45,359 --> 00:49:48,720
click on load game select save game

00:49:48,079 --> 00:49:50,400
maybe click

00:49:48,720 --> 00:49:53,839
load or maybe he's gonna actually start

00:49:50,400 --> 00:49:57,119
a new game he's gonna do a bunch of uh

00:49:53,839 --> 00:50:00,640
he's gonna do a bunch of stuff that uh

00:49:57,119 --> 00:50:04,559
that feels like he's active but

00:50:00,640 --> 00:50:06,960
by cpu uh terms

00:50:04,559 --> 00:50:09,119
there's basically one chord that is

00:50:06,960 --> 00:50:11,119
rendering a frame every

00:50:09,119 --> 00:50:13,200
16 milliseconds or something and

00:50:11,119 --> 00:50:17,359
processing his input

00:50:13,200 --> 00:50:17,359
and everything else is just

00:50:17,520 --> 00:50:21,119
nothing the other seven cores are

00:50:19,280 --> 00:50:22,240
probably asleep at that point so what we

00:50:21,119 --> 00:50:23,920
can do

00:50:22,240 --> 00:50:26,079
is actually load a bunch of stuff at

00:50:23,920 --> 00:50:27,359
that moment stop that it's not needed to

00:50:26,079 --> 00:50:29,520
load the

00:50:27,359 --> 00:50:32,720
the data and that that's that's where

00:50:29,520 --> 00:50:32,720
the audio part comes in

00:50:33,119 --> 00:50:37,040
uh because here's the thing i i run a

00:50:35,200 --> 00:50:40,079
benchmark and he said yep

00:50:37,040 --> 00:50:43,040
your cpu time uh your audio load is

00:50:40,079 --> 00:50:43,760
actually it's actually in a cpu

00:50:43,040 --> 00:50:45,760
efficient

00:50:43,760 --> 00:50:47,280
it's it's not like you're sleeping on a

00:50:45,760 --> 00:50:49,119
thread it's not like you're

00:50:47,280 --> 00:50:51,359
you're you're dumb or whatever no you

00:50:49,119 --> 00:50:53,280
just you're reading a lot of zip

00:50:51,359 --> 00:50:55,040
because the main thing we have in

00:50:53,280 --> 00:50:57,680
stellaris in the in the dlc

00:50:55,040 --> 00:50:58,559
folders is uh is music packs so

00:50:57,680 --> 00:51:01,599
basically

00:50:58,559 --> 00:51:05,040
most of my time was spent on deflate can

00:51:01,599 --> 00:51:08,160
i optimize deflate further

00:51:05,040 --> 00:51:09,599
i mean maybe i don't know uh that

00:51:08,160 --> 00:51:11,920
algorithm is probably

00:51:09,599 --> 00:51:12,880
uh inside the fest is probably not super

00:51:11,920 --> 00:51:15,680
early

00:51:12,880 --> 00:51:16,400
maybe there is a more fancy like uh

00:51:15,680 --> 00:51:19,200
multi

00:51:16,400 --> 00:51:19,680
uh sem simd version of it that could be

00:51:19,200 --> 00:51:22,240
better

00:51:19,680 --> 00:51:24,079
i don't know but also fisa fest is a

00:51:22,240 --> 00:51:25,280
local archive remember and we're reading

00:51:24,079 --> 00:51:27,040
from archives so

00:51:25,280 --> 00:51:28,720
maybe even if we optimize on that it's

00:51:27,040 --> 00:51:30,720
not gonna be that much better

00:51:28,720 --> 00:51:32,880
so we can't even like multifading may

00:51:30,720 --> 00:51:35,920
not even solve the problem

00:51:32,880 --> 00:51:36,960
but here's the question how many music

00:51:35,920 --> 00:51:38,319
tracks do you need

00:51:36,960 --> 00:51:41,040
to display the loading screen in the

00:51:38,319 --> 00:51:41,040
main menu

00:51:41,520 --> 00:51:45,119
you need one at the end of the day you

00:51:43,599 --> 00:51:45,520
need one you need the main theme of the

00:51:45,119 --> 00:51:48,079
game

00:51:45,520 --> 00:51:49,280
because that's what you hear that's the

00:51:48,079 --> 00:51:51,760
only thing you have

00:51:49,280 --> 00:51:54,000
you don't care about the i don't know 40

00:51:51,760 --> 00:51:55,359
50 of the music tracks we have

00:51:54,000 --> 00:51:57,520
you'll need them once you start playing

00:51:55,359 --> 00:51:59,760
the game but to display the main menu

00:51:57,520 --> 00:52:03,359
and to let people select your saves and

00:51:59,760 --> 00:52:03,359
show loading bar you don't need that

00:52:03,680 --> 00:52:06,800
so until you're dropped in the game and

00:52:05,280 --> 00:52:08,480
you start interacting with the in-game

00:52:06,800 --> 00:52:10,480
music player you don't care about all

00:52:08,480 --> 00:52:11,920
those other assets

00:52:10,480 --> 00:52:14,160
and i know it's something that a lot of

00:52:11,920 --> 00:52:16,240
games do right between the assets

00:52:14,160 --> 00:52:18,079
but in all cases it's not something that

00:52:16,240 --> 00:52:19,520
is very baked a lot into our engine

00:52:18,079 --> 00:52:21,680
because we're not level based

00:52:19,520 --> 00:52:23,599
or games just below the simulation of

00:52:21,680 --> 00:52:24,640
the world and they play that simulation

00:52:23,599 --> 00:52:26,400
until you

00:52:24,640 --> 00:52:27,920
realize it's 3am in the morning and you

00:52:26,400 --> 00:52:31,440
have to go to bed

00:52:27,920 --> 00:52:32,240
uh so there is it's it's hard for us to

00:52:31,440 --> 00:52:35,040
predict what

00:52:32,240 --> 00:52:36,559
what you will need uh when so

00:52:35,040 --> 00:52:37,839
historically the decision was made to

00:52:36,559 --> 00:52:39,839
just load everything else

00:52:37,839 --> 00:52:42,640
uh from the start but for the music we

00:52:39,839 --> 00:52:44,800
could probably do something smarter

00:52:42,640 --> 00:52:46,400
so that's that's what i did i just

00:52:44,800 --> 00:52:48,160
immediately started loading the main

00:52:46,400 --> 00:52:49,599
theme because we need to play it until

00:52:48,160 --> 00:52:50,400
it slowly then starts playing we're not

00:52:49,599 --> 00:52:51,920
displaying them in

00:52:50,400 --> 00:52:53,920
uh without we don't want to display the

00:52:51,920 --> 00:52:55,200
loading screen but everything else i

00:52:53,920 --> 00:52:56,800
could show in the background

00:52:55,200 --> 00:52:58,880
with low priority and say yeah sure

00:52:56,800 --> 00:53:00,079
whatever do you think uh once we're

00:52:58,880 --> 00:53:03,280
inside the game i'm just gonna

00:53:00,079 --> 00:53:03,280
rendezvous with that uh

00:53:03,920 --> 00:53:08,319
uh with that with that uh future and

00:53:06,319 --> 00:53:10,000
make sure everything is there

00:53:08,319 --> 00:53:11,440
again potentially we could apply to

00:53:10,000 --> 00:53:13,200
other assets but in all cases it's

00:53:11,440 --> 00:53:14,960
complicated because we would have to be

00:53:13,200 --> 00:53:18,640
able to differentiate

00:53:14,960 --> 00:53:20,079
uh data and wherever needed and

00:53:18,640 --> 00:53:22,800
sadly there isn't much i could do

00:53:20,079 --> 00:53:23,520
immediately um it ties down to a big

00:53:22,800 --> 00:53:26,960
lesson

00:53:23,520 --> 00:53:28,800
uh i think which is if you know uh

00:53:26,960 --> 00:53:31,119
your workflow if you know the user

00:53:28,800 --> 00:53:32,880
workflow you can do a lot of things

00:53:31,119 --> 00:53:34,720
right because if you know

00:53:32,880 --> 00:53:36,319
what data you will need when you know

00:53:34,720 --> 00:53:38,400
the timeline and everything

00:53:36,319 --> 00:53:39,760
then you can spread your loading all

00:53:38,400 --> 00:53:42,079
around and

00:53:39,760 --> 00:53:42,960
basically use use the rest of the course

00:53:42,079 --> 00:53:45,440
when there is no

00:53:42,960 --> 00:53:46,800
urgency like displaying menus and a

00:53:45,440 --> 00:53:47,839
bunch of other things that are actually

00:53:46,800 --> 00:53:51,200
not very

00:53:47,839 --> 00:53:51,920
cpu uh intensive so we could do that for

00:53:51,200 --> 00:53:53,280
musics

00:53:51,920 --> 00:53:54,720
we couldn't do that for textures we

00:53:53,280 --> 00:53:56,640
could not easily do that from bubbles

00:53:54,720 --> 00:53:58,880
either because uh portraits can be

00:53:56,640 --> 00:54:00,240
uh all the textures in sprites are used

00:53:58,880 --> 00:54:03,280
by the ui

00:54:00,240 --> 00:54:04,880
uh and the in-game portraits and a lot

00:54:03,280 --> 00:54:06,640
of things so we would have to segregate

00:54:04,880 --> 00:54:08,720
them in a way that we make sure that

00:54:06,640 --> 00:54:10,079
those are never used in the main menu

00:54:08,720 --> 00:54:11,839
we would have to do the same thing for

00:54:10,079 --> 00:54:13,760
the 3d assets

00:54:11,839 --> 00:54:14,880
which you can also see in the main menu

00:54:13,760 --> 00:54:16,800
because the the

00:54:14,880 --> 00:54:18,720
the main menu actually when you create

00:54:16,800 --> 00:54:19,839
your own empire you have a preview of

00:54:18,720 --> 00:54:22,079
everything

00:54:19,839 --> 00:54:23,920
so it could be done maybe with some

00:54:22,079 --> 00:54:25,040
smart lazy loading but that would have

00:54:23,920 --> 00:54:26,400
been much more costly

00:54:25,040 --> 00:54:29,359
it's a venue we could explore in the

00:54:26,400 --> 00:54:30,880
future but right now we're like no just

00:54:29,359 --> 00:54:33,680
load everything in the simulation and

00:54:30,880 --> 00:54:35,359
again even with all that loaded up front

00:54:33,680 --> 00:54:37,119
i still managed to get up to like i

00:54:35,359 --> 00:54:40,319
don't know 10 or 12 seconds which is

00:54:37,119 --> 00:54:43,359
perfectly reasonable so to wrap it up

00:54:40,319 --> 00:54:43,359
and then i'll take the questions

00:54:43,520 --> 00:54:47,839
oh i forgot to change that from another

00:54:45,440 --> 00:54:51,359
talk you haven't seen anything

00:54:47,839 --> 00:54:53,280
so logs will solve your threading

00:54:51,359 --> 00:54:55,520
uh your thread safety problems but they

00:54:53,280 --> 00:54:57,839
will cost you for the efficiency

00:54:55,520 --> 00:54:59,760
and especially on modern machines with a

00:54:57,839 --> 00:55:01,760
lot of cores or threads

00:54:59,760 --> 00:55:04,839
you will you you will feel it if you

00:55:01,760 --> 00:55:06,079
stop to go uh if you try to thread your

00:55:04,839 --> 00:55:08,720
algorithm

00:55:06,079 --> 00:55:10,480
if you need to log to parallelize

00:55:08,720 --> 00:55:12,799
consider another approach consider

00:55:10,480 --> 00:55:13,520
refactoring consider possibly looking in

00:55:12,799 --> 00:55:16,720
a smaller way

00:55:13,520 --> 00:55:18,319
if possible that's not always possible

00:55:16,720 --> 00:55:19,920
and finally do not underestimate the

00:55:18,319 --> 00:55:21,119
potential gain of revisiting all the

00:55:19,920 --> 00:55:22,079
code with threading in mind i think

00:55:21,119 --> 00:55:26,000
that's the biggest

00:55:22,079 --> 00:55:27,440
thing right when i started this uh

00:55:26,000 --> 00:55:29,119
this whole campaign of trying to make

00:55:27,440 --> 00:55:32,559
the game start faster

00:55:29,119 --> 00:55:35,040
my initial id was completely different

00:55:32,559 --> 00:55:36,720
i thought the problem was because i i

00:55:35,040 --> 00:55:38,720
had observed that on another game

00:55:36,720 --> 00:55:40,559
uh the windows file system is super

00:55:38,720 --> 00:55:41,760
simple to load a lot of small files

00:55:40,559 --> 00:55:43,760
and that was that's a problem on the

00:55:41,760 --> 00:55:45,680
opening results for example i

00:55:43,760 --> 00:55:47,440
assume it would be the same issue and i

00:55:45,680 --> 00:55:50,240
was trying to do something smart like

00:55:47,440 --> 00:55:52,160
git does and i was that was my old venue

00:55:50,240 --> 00:55:54,160
it turns out i never needed to even

00:55:52,160 --> 00:55:55,200
remotely touch that because that was not

00:55:54,160 --> 00:55:57,359
the problem

00:55:55,200 --> 00:55:59,440
the problem was locking the problem was

00:55:57,359 --> 00:56:02,000
i could spread smarter

00:55:59,440 --> 00:56:04,400
and i mean i have i've i've been in this

00:56:02,000 --> 00:56:06,079
profession for what 15 years now since i

00:56:04,400 --> 00:56:07,680
got out of school i don't consider

00:56:06,079 --> 00:56:10,000
myself a newbie i

00:56:07,680 --> 00:56:10,720
i go to a lot of conferences i know that

00:56:10,000 --> 00:56:13,839
stuff but

00:56:10,720 --> 00:56:15,760
never would it have crossed my mind that

00:56:13,839 --> 00:56:18,000
i could just

00:56:15,760 --> 00:56:18,880
take my existing operation that takes a

00:56:18,000 --> 00:56:22,160
minute and

00:56:18,880 --> 00:56:24,640
put it down to like 12 or 15 seconds

00:56:22,160 --> 00:56:27,599
i i thought if i got like half that

00:56:24,640 --> 00:56:30,079
would be miraculous

00:56:27,599 --> 00:56:30,720
so yeah never never underestimate the

00:56:30,079 --> 00:56:33,680
potential

00:56:30,720 --> 00:56:34,480
of viewing over code and trying to uh to

00:56:33,680 --> 00:56:36,960
work with

00:56:34,480 --> 00:56:38,400
machines have really changed from

00:56:36,960 --> 00:56:39,200
especially in my case from when i was in

00:56:38,400 --> 00:56:41,599
school

00:56:39,200 --> 00:56:42,720
uh and from the previous applications i

00:56:41,599 --> 00:56:43,680
worked through and there is a lot of

00:56:42,720 --> 00:56:46,000
gain because

00:56:43,680 --> 00:56:47,599
even if you thought about it maybe when

00:56:46,000 --> 00:56:50,720
you when the previous guy

00:56:47,599 --> 00:56:54,319
did it it was not worth it it's uh

00:56:50,720 --> 00:56:57,200
there's a whole venue there oh and

00:56:54,319 --> 00:56:59,200
furthermore i think your bill should be

00:56:57,200 --> 00:57:02,319
destroyed

00:56:59,200 --> 00:57:05,839
thank you i'll

00:57:02,319 --> 00:57:09,200
look at the questions that are remaining

00:57:05,839 --> 00:57:10,960
do i have any insights uh

00:57:09,200 --> 00:57:12,720
to what directives did to improve

00:57:10,960 --> 00:57:16,079
concurrency support

00:57:12,720 --> 00:57:19,839
i am not well versed into graphics

00:57:16,079 --> 00:57:19,839
but i would assume that

00:57:20,880 --> 00:57:24,079
somehow with modern graphics pipeline

00:57:23,359 --> 00:57:26,079
you can actually

00:57:24,079 --> 00:57:27,680
queue up operation of floating textures

00:57:26,079 --> 00:57:29,680
copying texture whatever

00:57:27,680 --> 00:57:30,799
in a way that does not require locking

00:57:29,680 --> 00:57:33,520
concrete viables i

00:57:30,799 --> 00:57:34,160
i i mean if if some people from from

00:57:33,520 --> 00:57:36,079
nvidia

00:57:34,160 --> 00:57:37,599
or whatever or around maybe ask them

00:57:36,079 --> 00:57:39,280
because i am really not an expert on it

00:57:37,599 --> 00:57:40,079
i don't know if bryce is around if he is

00:57:39,280 --> 00:57:41,599
probably asking

00:57:40,079 --> 00:57:44,079
i i don't have a great answer for that

00:57:41,599 --> 00:57:44,079
sadly

00:57:44,319 --> 00:57:49,680
uh do you know if your improvements had

00:57:48,000 --> 00:57:52,240
significant impact on machinery

00:57:49,680 --> 00:57:53,520
with less scores i haven't tried with

00:57:52,240 --> 00:57:57,119
less than four cores

00:57:53,520 --> 00:57:57,599
uh and and like that would translate to

00:57:57,119 --> 00:58:00,960
eight

00:57:57,599 --> 00:58:01,599
uh threats i gave the patch out to our

00:58:00,960 --> 00:58:05,200
testers

00:58:01,599 --> 00:58:07,839
and and beta testers i think our game

00:58:05,200 --> 00:58:09,359
requires at least two threads to start

00:58:07,839 --> 00:58:11,359
uh

00:58:09,359 --> 00:58:12,720
because we have a busy loop as you can

00:58:11,359 --> 00:58:14,240
see because there's a busy loop pumping

00:58:12,720 --> 00:58:16,240
the messages and another one

00:58:14,240 --> 00:58:18,000
we actually had a bug uh someone started

00:58:16,240 --> 00:58:19,440
uh starting to start again with a single

00:58:18,000 --> 00:58:21,760
call and he got stuck in the loaning

00:58:19,440 --> 00:58:23,040
screen i think we have a requirement

00:58:21,760 --> 00:58:24,880
that you that is too course

00:58:23,040 --> 00:58:27,760
uh to be able to start up the game it's

00:58:24,880 --> 00:58:30,400
not ideal we could probably improve it

00:58:27,760 --> 00:58:31,760
uh but i would assume that even if you

00:58:30,400 --> 00:58:34,400
have only like four

00:58:31,760 --> 00:58:35,760
four logical threads you you would see

00:58:34,400 --> 00:58:37,760
something and if you have more

00:58:35,760 --> 00:58:39,680
you can probably see more uh i know for

00:58:37,760 --> 00:58:41,599
example that these uh

00:58:39,680 --> 00:58:43,839
improvements have been put back in the

00:58:41,599 --> 00:58:44,960
in in the modern engine and ck3

00:58:43,839 --> 00:58:47,680
is looking through your latest release

00:58:44,960 --> 00:58:50,960
benefits from them from the start

00:58:47,680 --> 00:58:53,760
and uh it

00:58:50,960 --> 00:58:56,000
uh i think one of my colleagues just

00:58:53,760 --> 00:58:57,520
bought like a crazy thread reaper or

00:58:56,000 --> 00:58:59,040
like something just below the thread

00:58:57,520 --> 00:58:59,680
reaper and he noticed some insane

00:58:59,040 --> 00:59:01,520
improvements

00:58:59,680 --> 00:59:03,920
like ck3 started almost twice as fast

00:59:01,520 --> 00:59:06,240
after i merged to change back into the

00:59:03,920 --> 00:59:08,480
trunk version of the engine

00:59:06,240 --> 00:59:09,760
so i think it scales and i think you

00:59:08,480 --> 00:59:11,599
still get something if it's a bit

00:59:09,760 --> 00:59:13,359
smaller

00:59:11,599 --> 00:59:14,640
uh question number 10 uh do you think

00:59:13,359 --> 00:59:15,599
game developers would benefit from a

00:59:14,640 --> 00:59:16,559
deeper understanding of parallel

00:59:15,599 --> 00:59:19,359
patterns

00:59:16,559 --> 00:59:21,119
i cannot speak for others i have no idea

00:59:19,359 --> 00:59:24,000
i think everybody should benefit

00:59:21,119 --> 00:59:25,599
better from like knowing about uh uh

00:59:24,000 --> 00:59:26,079
threading and everything like that

00:59:25,599 --> 00:59:28,319
because

00:59:26,079 --> 00:59:29,760
i studied all that stuff in school uh i

00:59:28,319 --> 00:59:32,079
guess i did not apply it a lot for a

00:59:29,760 --> 00:59:33,920
long time my previous job was a

00:59:32,079 --> 00:59:35,520
finance application that did not use

00:59:33,920 --> 00:59:37,040
spread because

00:59:35,520 --> 00:59:39,040
because a lot of their models were

00:59:37,040 --> 00:59:39,680
dating back from the pre-multi-trading

00:59:39,040 --> 00:59:42,319
era

00:59:39,680 --> 00:59:43,520
uh i i knew all the theory and i could

00:59:42,319 --> 00:59:45,839
apply it when i

00:59:43,520 --> 00:59:47,119
did it it's just like i don't know i

00:59:45,839 --> 00:59:49,440
think

00:59:47,119 --> 00:59:50,960
today if you want to do something fast

00:59:49,440 --> 00:59:52,880
and reactive

00:59:50,960 --> 00:59:55,119
uh again if you care about latency like

00:59:52,880 --> 00:59:57,200
how fast the computation will go

00:59:55,119 --> 00:59:58,319
uh yes it's it's obvious that you

00:59:57,200 --> 00:59:59,760
probably need a

00:59:58,319 --> 01:00:02,319
some kind of background on threading and

00:59:59,760 --> 01:00:03,680
how to improve that stuff

01:00:02,319 --> 01:00:05,359
has this caused you to move to a

01:00:03,680 --> 01:00:06,880
different file system in the future i

01:00:05,359 --> 01:00:07,920
mean i can't change the file system

01:00:06,880 --> 01:00:10,720
itself right like

01:00:07,920 --> 01:00:13,200
i'm still stuck with ntfs i've been

01:00:10,720 --> 01:00:15,119
toying with the idea of

01:00:13,200 --> 01:00:18,559
trying to have an archive file instead

01:00:15,119 --> 01:00:18,559
of putting the the files

01:00:18,640 --> 01:00:22,480
uh we're running out of time i'm just

01:00:21,200 --> 01:00:24,240
answer that question and for the rest i

01:00:22,480 --> 01:00:26,720
will have to take them offline

01:00:24,240 --> 01:00:28,079
i have considered uh replacing the game

01:00:26,720 --> 01:00:30,079
files that are

01:00:28,079 --> 01:00:31,280
on the flat on the file system by zips

01:00:30,079 --> 01:00:33,520
but the problem is

01:00:31,280 --> 01:00:35,119
uh it breaks the workflow of the modders

01:00:33,520 --> 01:00:36,559
and the

01:00:35,119 --> 01:00:38,720
all developers that are used to work

01:00:36,559 --> 01:00:39,760
with flat files and don't have to visit

01:00:38,720 --> 01:00:40,400
everything every time they want to

01:00:39,760 --> 01:00:43,200
publish

01:00:40,400 --> 01:00:43,680
or make a change we could improve that

01:00:43,200 --> 01:00:45,680
by

01:00:43,680 --> 01:00:47,200
having like two modes like one of them

01:00:45,680 --> 01:00:48,160
is basically the release version that

01:00:47,200 --> 01:00:50,079
packs everything

01:00:48,160 --> 01:00:51,599
and another option for the development

01:00:50,079 --> 01:00:53,280
thing but that will require

01:00:51,599 --> 01:00:54,640
longer longer term changes i am not

01:00:53,280 --> 01:00:56,079
opposed to it but again

01:00:54,640 --> 01:00:57,280
it's time right like i have everything

01:00:56,079 --> 01:00:58,559
there's a lot of things i could improve

01:00:57,280 --> 01:01:00,000
in a lot of places and i'm pretty sure

01:00:58,559 --> 01:01:01,839
you guys have the exact same thing uh

01:01:00,000 --> 01:01:03,440
feeling about whatever you're working on

01:01:01,839 --> 01:01:04,880
because a lot of time you can improve

01:01:03,440 --> 01:01:08,240
stuff the question is how much

01:01:04,880 --> 01:01:08,240
time and effort can you put into it

01:01:09,359 --> 01:01:16,480
and yeah i answered the question yes uh

01:01:12,960 --> 01:01:18,160
the new uh i mean yes and no

01:01:16,480 --> 01:01:20,079
uh the new engine already has some of

01:01:18,160 --> 01:01:24,160
those improvements

01:01:20,079 --> 01:01:25,599
but for the rest uh i don't have um

01:01:24,160 --> 01:01:27,040
the question was will you develop a new

01:01:25,599 --> 01:01:30,079
engine for future projects to

01:01:27,040 --> 01:01:32,079
incorporate these ideas from the start

01:01:30,079 --> 01:01:33,599
we will we continue we have an engine

01:01:32,079 --> 01:01:35,280
that we continue improving over time

01:01:33,599 --> 01:01:37,440
some of those things have been improved

01:01:35,280 --> 01:01:39,119
some of those learnings have already

01:01:37,440 --> 01:01:40,240
been applied but i did not have them in

01:01:39,119 --> 01:01:41,920
stellaris

01:01:40,240 --> 01:01:43,440
for the rest i guess it's up to my

01:01:41,920 --> 01:01:46,799
engine team i think

01:01:43,440 --> 01:01:49,440
yes but again time

01:01:46,799 --> 01:01:50,799
and i will have to stop here but i will

01:01:49,440 --> 01:01:54,079
probably hang out

01:01:50,799 --> 01:01:55,599
in uh in the room and uh take over

01:01:54,079 --> 01:01:56,960
questions

01:01:55,599 --> 01:01:59,119
i have like 10 minutes before the

01:01:56,960 --> 01:02:02,880
lightning talks happen maybe 15 so

01:01:59,119 --> 01:02:07,839
i'll be in some table on the first floor

01:02:02,880 --> 01:02:07,839
thank you guys

01:02:23,920 --> 01:02:26,000

YouTube URL: https://www.youtube.com/watch?v=TcuPIVKNSN0


