Title: CppCon 2018: William Clements “Save $$ Testing Code the Playback-Based Way”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Your actively growing library or component is inadequately tested! Good enough maintenance is nearly impossible, because you cannot run all of your clients' software for regressions. 

Enter Playback-Based Testing (PBT)!!

Record artifact during client live session, playback in your lab with just your library. Curate "recordings" from clients for automated integration testing.The benefit/cost ratio can be spectacular, as library scales. (A cost is adapting or doubling the API layer). 

Consider leveraging these artifacts to improve author-client collaboration.

The talk: General architecture and strategy of PBT tools described. Impactful PBT is arguably most attainable through a Grow-Your-Own effort. Since it works by exploiting data otherwise thrown away,  PBT is like a second cousin of Time Travel Debugging (TTD).

Specific experience: Having been immersed in PBT mindset (a cornerstone of Autodesk Revit's success), William's team attacked flakiness in a Revit integration of provider's cloud data storage framework -- by cobbling together a PBT tool.

Introduce C++ headers-only library ("CppPlayer") intended as a PBT jump-start. It is available as open source at https://github.com/WilliamClements/CppPlayer ...
— 
William Clements, Sr. Principal Engineer
Autodesk

Coding design software for almost 40 years on East coast. Accomplishments include feats of "infrastructure" -- graphics, data archiving, multi-threading. Principle author of a UI-based test recorder that has produced over 15,000 tests for a premier CAD application.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:09,660
okay the stock is called save money

00:00:04,799 --> 00:00:15,660
testing code the playback based way I'm

00:00:09,660 --> 00:00:17,220
William Clements from Autodesk can I get

00:00:15,660 --> 00:00:20,189
a show of hands of people who have

00:00:17,220 --> 00:00:22,080
worked with a tool that works by

00:00:20,189 --> 00:00:27,630
recording something and playing it back

00:00:22,080 --> 00:00:30,230
very good and how many have done that

00:00:27,630 --> 00:00:34,620
successfully was this tool successful

00:00:30,230 --> 00:00:36,210
hmm almost as many and who has all the

00:00:34,620 --> 00:00:43,530
tools they have they need

00:00:36,210 --> 00:00:47,820
oh no hands on that one so a little

00:00:43,530 --> 00:00:50,070
about me very little code slinger about

00:00:47,820 --> 00:00:53,250
my company it's that make anything

00:00:50,070 --> 00:01:02,059
company lots of design manufacturing

00:00:53,250 --> 00:01:04,589
software yes it started with AutoCAD a

00:01:02,059 --> 00:01:07,020
lot of people ask me what is the subject

00:01:04,589 --> 00:01:10,080
of my talk and these are the people who

00:01:07,020 --> 00:01:14,220
have just heard the talk so I decided to

00:01:10,080 --> 00:01:16,290
make it clear I'm here to champion the

00:01:14,220 --> 00:01:21,420
idea of playback based testing and

00:01:16,290 --> 00:01:25,560
specifically for C++ libraries because I

00:01:21,420 --> 00:01:31,110
believe it's an underutilized framework

00:01:25,560 --> 00:01:32,700
or you know paradigm and so the outline

00:01:31,110 --> 00:01:36,439
of the talk or the things I'm going to

00:01:32,700 --> 00:01:42,479
hit on are the library scaling dilemma

00:01:36,439 --> 00:01:44,909
as library gets bigger problems occur

00:01:42,479 --> 00:01:49,649
the anatomy of the playback based

00:01:44,909 --> 00:01:52,380
testing itself and a little side journey

00:01:49,649 --> 00:01:55,740
into what do you mean playback testing

00:01:52,380 --> 00:01:59,100
never works I have an existence proof

00:01:55,740 --> 00:02:03,450
Revit journaling and apparently some of

00:01:59,100 --> 00:02:05,610
you do too and a tour of the CPB player

00:02:03,450 --> 00:02:10,590
there's just my reference implementation

00:02:05,610 --> 00:02:12,840
of playback testing for C++ it's just

00:02:10,590 --> 00:02:15,810
1,200 lines it's not any

00:02:12,840 --> 00:02:18,020
that's not the subject of the talk and

00:02:15,810 --> 00:02:21,120
just the coming slides in a minute

00:02:18,020 --> 00:02:24,209
they're kind of playful or silly but I'm

00:02:21,120 --> 00:02:26,850
just trying to show the the value

00:02:24,209 --> 00:02:29,520
proposition in a certain way I'll

00:02:26,850 --> 00:02:33,870
consistently talk about library and

00:02:29,520 --> 00:02:40,080
client but in your environment it could

00:02:33,870 --> 00:02:43,050
be you and your colleague that you know

00:02:40,080 --> 00:02:45,030
have a layered situation or it could

00:02:43,050 --> 00:02:48,480
even be you need to use this by yourself

00:02:45,030 --> 00:02:53,670
but I've sort of stick with that as the

00:02:48,480 --> 00:02:56,640
value proposition and so I will this is

00:02:53,670 --> 00:02:59,160
these keep in mind czar those general

00:02:56,640 --> 00:03:02,900
observations the library integration

00:02:59,160 --> 00:03:05,700
quality as an issue is a shared problem

00:03:02,900 --> 00:03:09,720
between the library author and the

00:03:05,700 --> 00:03:12,209
client playback testing playback based

00:03:09,720 --> 00:03:17,820
testing happens to be a shared solution

00:03:12,209 --> 00:03:19,019
and you should before investing evaluate

00:03:17,820 --> 00:03:21,620
whether you're going to get return on

00:03:19,019 --> 00:03:24,690
investment of course and the last

00:03:21,620 --> 00:03:28,290
suggestion is do it yourself

00:03:24,690 --> 00:03:30,930
I don't happen this is not a commercial

00:03:28,290 --> 00:03:33,450
product that I'm here to sell and I

00:03:30,930 --> 00:03:37,590
don't know of any I didn't find any that

00:03:33,450 --> 00:03:40,799
exists it's pretty it's you know pretty

00:03:37,590 --> 00:03:44,329
simple basically so this is my finger

00:03:40,799 --> 00:03:48,780
your library is inadequately tested and

00:03:44,329 --> 00:03:51,030
that's you you you can't run all if you

00:03:48,780 --> 00:03:52,109
have multiple clients and I hope you do

00:03:51,030 --> 00:03:55,290
a for your library

00:03:52,109 --> 00:03:58,650
you can't run all of them the actual

00:03:55,290 --> 00:04:01,549
software is it's physically impossible

00:03:58,650 --> 00:04:05,850
usually it could be the US government or

00:04:01,549 --> 00:04:09,590
you can't run their software with your

00:04:05,850 --> 00:04:15,570
library to make sure it's still working

00:04:09,590 --> 00:04:18,079
and so this is a happy slide your

00:04:15,570 --> 00:04:20,880
library is nicely scaling up and

00:04:18,079 --> 00:04:24,290
collecting those are very happy clients

00:04:20,880 --> 00:04:27,850
and you keep releasing new versions

00:04:24,290 --> 00:04:35,090
and they accept them they trust you and

00:04:27,850 --> 00:04:38,060
then whoops then you write some more

00:04:35,090 --> 00:04:41,350
great enhancements and you snag even

00:04:38,060 --> 00:04:45,200
more happy clients but you put these

00:04:41,350 --> 00:04:47,270
enhancements and everyone's keeping up

00:04:45,200 --> 00:04:49,670
with your library as I should with the

00:04:47,270 --> 00:04:52,250
version so but you may regress the

00:04:49,670 --> 00:04:57,980
quality for somebody who's an already

00:04:52,250 --> 00:05:00,140
existing client unhappy client and

00:04:57,980 --> 00:05:03,110
question is that a dilemma or a quandary

00:05:00,140 --> 00:05:07,610
I'm just joking

00:05:03,110 --> 00:05:09,830
how can we this if this is also you how

00:05:07,610 --> 00:05:12,350
can we qualify our library against so

00:05:09,830 --> 00:05:14,960
many different clients needs well let's

00:05:12,350 --> 00:05:17,780
start talking about it differently how

00:05:14,960 --> 00:05:20,630
can we test the integration of that

00:05:17,780 --> 00:05:24,650
library with each client library or

00:05:20,630 --> 00:05:27,350
application that uses it we're not just

00:05:24,650 --> 00:05:32,300
qualifying our library were qualifying

00:05:27,350 --> 00:05:34,400
the integration so my opinion you need

00:05:32,300 --> 00:05:35,090
more data from the clients to solve this

00:05:34,400 --> 00:05:39,740
problem

00:05:35,090 --> 00:05:41,810
so the basic ideas work together to

00:05:39,740 --> 00:05:44,290
capture an exact recording of how they

00:05:41,810 --> 00:05:48,860
use your library in a live session

00:05:44,290 --> 00:05:55,940
literally bit for a bit how they called

00:05:48,860 --> 00:06:00,200
you so into the playback testing talking

00:05:55,940 --> 00:06:01,970
about how what's in it you want to

00:06:00,200 --> 00:06:06,500
capture all data that's entering a

00:06:01,970 --> 00:06:09,860
library almost as if there's a invisible

00:06:06,500 --> 00:06:13,520
shell and this is in the form of every

00:06:09,860 --> 00:06:15,830
API that is called and all the values of

00:06:13,520 --> 00:06:19,930
the arguments if you capture all that

00:06:15,830 --> 00:06:22,040
data and somehow we play it

00:06:19,930 --> 00:06:24,980
deterministically you should get the

00:06:22,040 --> 00:06:30,970
same result I know there are tons of

00:06:24,980 --> 00:06:34,350
corner cases much now these recordings

00:06:30,970 --> 00:06:38,110
that you capture

00:06:34,350 --> 00:06:40,870
from the client you can bring them back

00:06:38,110 --> 00:06:42,750
to your lab and play them back in the

00:06:40,870 --> 00:06:47,950
absence of that client code so that's

00:06:42,750 --> 00:06:50,110
getting it to how you qualify your

00:06:47,950 --> 00:06:55,600
library without running all of the

00:06:50,110 --> 00:06:57,430
client code so does this the the idea of

00:06:55,600 --> 00:07:01,080
playing back recordings and checking the

00:06:57,430 --> 00:07:04,780
results does that expose regressions

00:07:01,080 --> 00:07:09,250
there's something wrong it's that's not

00:07:04,780 --> 00:07:13,810
quite the right word it exposes breaking

00:07:09,250 --> 00:07:16,770
changes so you have to go at this kind

00:07:13,810 --> 00:07:24,750
of with a neutral objective view and

00:07:16,770 --> 00:07:27,960
it's engineering you you know you run

00:07:24,750 --> 00:07:33,180
experiments and everything is very

00:07:27,960 --> 00:07:35,430
tightly controlled and you keep track so

00:07:33,180 --> 00:07:40,390
in the next step

00:07:35,430 --> 00:07:43,810
how would you refactor your code your

00:07:40,390 --> 00:07:47,530
library and this is just so this is how

00:07:43,810 --> 00:07:50,320
it in a block diagram how you would do

00:07:47,530 --> 00:07:53,260
it so we have the classic just single

00:07:50,320 --> 00:07:57,040
layer that client is calling into your

00:07:53,260 --> 00:07:59,430
API your business logic executes we want

00:07:57,040 --> 00:08:02,470
to refactor that simple

00:07:59,430 --> 00:08:04,990
thing into the three blocks where you

00:08:02,470 --> 00:08:07,030
have the client application code you

00:08:04,990 --> 00:08:10,570
have a middle layer which is API plus

00:08:07,030 --> 00:08:14,710
instrumentation plus your business

00:08:10,570 --> 00:08:16,960
object wrappers which are what they say

00:08:14,710 --> 00:08:20,550
they are but off we get into it and then

00:08:16,960 --> 00:08:25,450
business logic is still the same doesn't

00:08:20,550 --> 00:08:29,620
this look similar but it's this is more

00:08:25,450 --> 00:08:32,260
of a data flow diagram on the left is

00:08:29,620 --> 00:08:35,260
kind of like the standard configuration

00:08:32,260 --> 00:08:37,810
or the recording configuration the

00:08:35,260 --> 00:08:41,010
client is running they're generating

00:08:37,810 --> 00:08:44,100
api's and we are capturing them and

00:08:41,010 --> 00:08:47,200
we're also executing the business logic

00:08:44,100 --> 00:08:47,990
in real time on that once we have

00:08:47,200 --> 00:08:52,610
captured those

00:08:47,990 --> 00:08:56,510
files they feed into that can be fed

00:08:52,610 --> 00:08:58,580
into your chest runner which again is

00:08:56,510 --> 00:09:01,610
just a small program without the client

00:08:58,580 --> 00:09:04,279
code and that one goes through the API

00:09:01,610 --> 00:09:13,970
instrumentation layer and through to the

00:09:04,279 --> 00:09:16,850
business logic just to give something a

00:09:13,970 --> 00:09:22,490
concrete face this is like this is a

00:09:16,850 --> 00:09:27,470
captured artifact that we created in my

00:09:22,490 --> 00:09:28,660
lab and it's in JSON so you can see the

00:09:27,470 --> 00:09:33,709
calls

00:09:28,660 --> 00:09:38,120
there's the API it's spelled out C++ and

00:09:33,709 --> 00:09:40,209
in this environment in this sort of play

00:09:38,120 --> 00:09:45,110
environment you know making a lot of

00:09:40,209 --> 00:09:48,200
simplifying assumptions but one

00:09:45,110 --> 00:09:51,290
important factor there is if it's a one

00:09:48,200 --> 00:09:56,720
following the API name then the next

00:09:51,290 --> 00:10:00,140
number is the function return so we'll

00:09:56,720 --> 00:10:03,560
get into that and but JSON is great

00:10:00,140 --> 00:10:10,270
because you can accommodate programming

00:10:03,560 --> 00:10:14,690
interface changes by reading in making

00:10:10,270 --> 00:10:16,850
simple symbolic changes just in the code

00:10:14,690 --> 00:10:21,500
of the structure and then just write it

00:10:16,850 --> 00:10:24,709
out again so I think that would help

00:10:21,500 --> 00:10:27,620
with maintenance but you know if you if

00:10:24,709 --> 00:10:30,110
this is really scaled up as a as a part

00:10:27,620 --> 00:10:31,940
of your organization your process you're

00:10:30,110 --> 00:10:32,899
going to end up you know there's a lot

00:10:31,940 --> 00:10:36,079
of factors you're going to end up

00:10:32,899 --> 00:10:39,050
throwing out some tests that can't can't

00:10:36,079 --> 00:10:41,480
be brought forward so a few more

00:10:39,050 --> 00:10:46,490
engineering talking about engineering

00:10:41,480 --> 00:10:48,140
tips does this is testing clean lab you

00:10:46,490 --> 00:10:52,730
will want to have the initial state of

00:10:48,140 --> 00:10:55,850
the files available that are referenced

00:10:52,730 --> 00:10:56,900
by the playback artifact or it just

00:10:55,850 --> 00:11:01,160
won't

00:10:56,900 --> 00:11:03,710
won't playback and so no secret backdoor

00:11:01,160 --> 00:11:06,980
calls you just you have to get all the

00:11:03,710 --> 00:11:12,680
api's and your taxes has to do with more

00:11:06,980 --> 00:11:16,760
of a scaling up of the process it's not

00:11:12,680 --> 00:11:20,720
the standard way of people do things and

00:11:16,760 --> 00:11:26,360
it just it has some unpleasant tasks

00:11:20,720 --> 00:11:29,030
like programmer doesn't is angry that he

00:11:26,360 --> 00:11:31,580
had to diagnose something that all it is

00:11:29,030 --> 00:11:33,980
is with the testing environment it

00:11:31,580 --> 00:11:39,460
didn't it wasn't a real logic error in

00:11:33,980 --> 00:11:42,350
the code and so that's unpleasant yes

00:11:39,460 --> 00:11:44,630
another tip about this kind of testing

00:11:42,350 --> 00:11:47,000
you raise exception at the very first

00:11:44,630 --> 00:11:49,280
opportunity when you notice something

00:11:47,000 --> 00:11:55,100
missing it's very checked for every

00:11:49,280 --> 00:11:59,810
little thing now when I asked that

00:11:55,100 --> 00:12:02,300
question about whether you had any

00:11:59,810 --> 00:12:06,200
experience with recording and playback

00:12:02,300 --> 00:12:07,700
tools where I talked to my colleagues my

00:12:06,200 --> 00:12:11,930
close colleagues that work on the same

00:12:07,700 --> 00:12:16,310
product it was unanimous that it's very

00:12:11,930 --> 00:12:20,750
successful but this is an you I kind of

00:12:16,310 --> 00:12:22,880
GUI based recording but it's the same

00:12:20,750 --> 00:12:27,370
concept and it it's been incredibly

00:12:22,880 --> 00:12:29,240
scalable and if you don't know CAD

00:12:27,370 --> 00:12:31,610
computer-aided design type of

00:12:29,240 --> 00:12:35,960
applications they just grow and grow and

00:12:31,610 --> 00:12:37,730
grow with more functionality and so we

00:12:35,960 --> 00:12:40,880
test all the functionality that we can

00:12:37,730 --> 00:12:43,990
we have nineteen thousand chess and

00:12:40,880 --> 00:12:48,430
everybody who works on Revit QA

00:12:43,990 --> 00:12:52,850
developers at least deal with these

00:12:48,430 --> 00:12:57,670
playback files every day it's you know

00:12:52,850 --> 00:13:04,120
so that's a very same segue into the

00:12:57,670 --> 00:13:06,800
case study or what kind of ended up

00:13:04,120 --> 00:13:10,399
caused me to end up here

00:13:06,800 --> 00:13:13,640
is that we were faced with a flaky

00:13:10,399 --> 00:13:17,570
integration the great library called HF

00:13:13,640 --> 00:13:22,100
DM it's a cloud storage framework thing

00:13:17,570 --> 00:13:27,320
that's going to evolve and we were an

00:13:22,100 --> 00:13:29,540
early adopter and you know it was flaky

00:13:27,320 --> 00:13:33,410
we had trouble keeping up with the

00:13:29,540 --> 00:13:37,399
versions and still do but we happened

00:13:33,410 --> 00:13:39,589
for our unit testing we had created some

00:13:37,399 --> 00:13:43,190
wrapper objects so that we could have

00:13:39,589 --> 00:13:47,390
nice you know test doubles for our unit

00:13:43,190 --> 00:13:52,040
tests and uh we kind of realized if we

00:13:47,390 --> 00:13:57,200
wrap all the objects we can and we can

00:13:52,040 --> 00:14:03,200
create recording and playback tool and

00:13:57,200 --> 00:14:08,930
that worked actually started that at CPP

00:14:03,200 --> 00:14:09,920
Con 2017 so one example was a

00:14:08,930 --> 00:14:12,800
performance problem

00:14:09,920 --> 00:14:14,839
we recorded everything that our code so

00:14:12,800 --> 00:14:17,270
in a way this doesn't follow the pattern

00:14:14,839 --> 00:14:23,600
because this was the client doing the

00:14:17,270 --> 00:14:28,130
work of making a playback layer we had a

00:14:23,600 --> 00:14:31,339
performance problem and it was kind of

00:14:28,130 --> 00:14:33,440
interesting to see well it was important

00:14:31,339 --> 00:14:38,390
to see is it just something somewhere in

00:14:33,440 --> 00:14:43,490
our code or is it is it inherently

00:14:38,390 --> 00:14:50,180
something slow about hf DM and we went

00:14:43,490 --> 00:14:52,940
one pass where we used this tool and the

00:14:50,180 --> 00:14:55,430
guy was able to you know we're spread

00:14:52,940 --> 00:14:58,220
out all over the world uh I don't

00:14:55,430 --> 00:15:00,620
remember where he was at the time but he

00:14:58,220 --> 00:15:02,300
did get the playback tool to working he

00:15:00,620 --> 00:15:04,610
said ok I've got everything I need but

00:15:02,300 --> 00:15:08,449
the next day that guy was had a

00:15:04,610 --> 00:15:11,180
different job he was promoted and we

00:15:08,449 --> 00:15:12,529
ended up coming back around saying well

00:15:11,180 --> 00:15:16,100
we still don't still have the

00:15:12,529 --> 00:15:19,339
performance problem so another guy who I

00:15:16,100 --> 00:15:20,440
believe is in this room knew how to run

00:15:19,339 --> 00:15:24,279
Revit

00:15:20,440 --> 00:15:27,790
and we finally isolated the performance

00:15:24,279 --> 00:15:29,800
problems so it but it takes longer it

00:15:27,790 --> 00:15:32,769
took longer I think just set it up then

00:15:29,800 --> 00:15:36,879
just set rev it up which is a huge

00:15:32,769 --> 00:15:42,100
install and uses resources than it is

00:15:36,879 --> 00:15:45,779
for a little test player so that it has

00:15:42,100 --> 00:15:51,910
been used in production this tool a

00:15:45,779 --> 00:15:56,649
little bit so as I said somewhere kind

00:15:51,910 --> 00:15:59,670
of distilled the core algorithms of that

00:15:56,649 --> 00:16:07,449
tool into a CP player that I can put on

00:15:59,670 --> 00:16:10,029
github and it supports despite the fact

00:16:07,449 --> 00:16:13,329
that it's called CBB Player it's both

00:16:10,029 --> 00:16:19,360
recording and playback it's very small

00:16:13,329 --> 00:16:23,050
headers only open source the adoption

00:16:19,360 --> 00:16:24,939
strategy is right there so I'd be

00:16:23,050 --> 00:16:29,500
interested if somebody actually tries to

00:16:24,939 --> 00:16:33,100
do that but and this is just a screen

00:16:29,500 --> 00:16:36,730
capture of the readme which I'm not

00:16:33,100 --> 00:16:38,829
going to go into but I guess the main

00:16:36,730 --> 00:16:40,689
thing is instrumentation I think people

00:16:38,829 --> 00:16:43,209
would be interested in well what's the

00:16:40,689 --> 00:16:46,630
cost because it there's extra code

00:16:43,209 --> 00:16:50,350
boilerplate code now added to your API

00:16:46,630 --> 00:16:52,269
and that's sort of unpleasant so from

00:16:50,350 --> 00:16:54,670
each instrumented API you're going to

00:16:52,269 --> 00:16:59,019
invoke some sort of record function at

00:16:54,670 --> 00:17:01,839
the end and you have to declare and

00:16:59,019 --> 00:17:07,720
implement a playback method this is all

00:17:01,839 --> 00:17:09,100
based on classes that objects so in our

00:17:07,720 --> 00:17:11,260
simplifying assumption we said

00:17:09,100 --> 00:17:17,319
everything has to be a call into an

00:17:11,260 --> 00:17:20,169
object so the playback method is or took

00:17:17,319 --> 00:17:22,929
pains to make sure it's declared as a

00:17:20,169 --> 00:17:29,409
member function so it can access

00:17:22,929 --> 00:17:32,470
everything and my opinion is this type

00:17:29,409 --> 00:17:34,320
of tool in its many disguises it's

00:17:32,470 --> 00:17:36,550
almost always growing

00:17:34,320 --> 00:17:40,300
you're not going to see there hasn't

00:17:36,550 --> 00:17:44,200
been in my opinion successful for

00:17:40,300 --> 00:17:47,980
example UI testing engine that people

00:17:44,200 --> 00:17:54,300
can really use long term obviously some

00:17:47,980 --> 00:17:54,300
people will disagree but grow your own

00:17:55,050 --> 00:18:01,480
so I I don't know if anyone's curious to

00:17:58,360 --> 00:18:04,000
see more of what's inside this thing and

00:18:01,480 --> 00:18:08,580
this is just getting into implementation

00:18:04,000 --> 00:18:11,620
of this little of our version of it so

00:18:08,580 --> 00:18:19,960
somebody wants to get back to bigger

00:18:11,620 --> 00:18:21,540
issues they can so this is just the sort

00:18:19,960 --> 00:18:25,420
of going through a few of the basic

00:18:21,540 --> 00:18:30,430
classes have an abstraction of the call

00:18:25,420 --> 00:18:34,150
stream I've got to somehow serialize the

00:18:30,430 --> 00:18:39,060
arguments but JSON is really cool for

00:18:34,150 --> 00:18:42,100
that and the pointers to the objects yet

00:18:39,060 --> 00:18:45,480
unsold and Swiss old as needed

00:18:42,100 --> 00:18:52,530
that's very standard you know

00:18:45,480 --> 00:18:56,260
serialization technology now the next a

00:18:52,530 --> 00:19:02,200
really a lower level kind of object in

00:18:56,260 --> 00:19:04,630
our prototype or our tool is call map

00:19:02,200 --> 00:19:09,040
and this is a map with some calls on it

00:19:04,630 --> 00:19:12,190
and it's static initialized one per

00:19:09,040 --> 00:19:13,750
instrumented line because well you may

00:19:12,190 --> 00:19:18,000
be doing this with more than one library

00:19:13,750 --> 00:19:22,170
so each has to have its own call map and

00:19:18,000 --> 00:19:25,600
getting a little bit into some internals

00:19:22,170 --> 00:19:26,950
the type erased functors outside or so

00:19:25,600 --> 00:19:30,100
that we can have a simple dispatch

00:19:26,950 --> 00:19:33,580
mechanism just get the JSON string that

00:19:30,100 --> 00:19:37,200
represents one call all the arguments

00:19:33,580 --> 00:19:41,290
the name of the API and just dispatch it

00:19:37,200 --> 00:19:46,240
but inside they need to be tight full

00:19:41,290 --> 00:19:46,940
lambdas so that we can write method you

00:19:46,240 --> 00:19:51,530
know

00:19:46,940 --> 00:19:54,830
it's that have access to the object and

00:19:51,530 --> 00:19:57,860
so these this is an argument this is the

00:19:54,830 --> 00:20:01,340
last little bit that I am just

00:19:57,860 --> 00:20:03,620
describing so an argument writer and an

00:20:01,340 --> 00:20:09,470
argument reader the argument writer

00:20:03,620 --> 00:20:11,600
during playback pushes each argument

00:20:09,470 --> 00:20:15,110
into a buffer actually it'll be better

00:20:11,600 --> 00:20:19,130
to look at some code in a minute to show

00:20:15,110 --> 00:20:25,850
that so this happens to be the list of

00:20:19,130 --> 00:20:31,010
files that are up on github and this is

00:20:25,850 --> 00:20:34,400
important I was very concerned with well

00:20:31,010 --> 00:20:37,100
how much ugly boilerplate do I have to

00:20:34,400 --> 00:20:39,890
add to my code because my colleague had

00:20:37,100 --> 00:20:43,640
written this stuff that you know was

00:20:39,890 --> 00:20:48,080
fluent and just returned the value and

00:20:43,640 --> 00:20:51,050
then I made it ugly but in this case is

00:20:48,080 --> 00:20:54,020
what I've circled that's the report this

00:20:51,050 --> 00:20:56,270
is a pretty simple API resolved path to

00:20:54,020 --> 00:20:59,660
reference does have some code here but

00:20:56,270 --> 00:21:02,180
you can imagine much more involved api's

00:20:59,660 --> 00:21:04,760
they would still have the same amount of

00:21:02,180 --> 00:21:07,310
boilerplate which is at the end after

00:21:04,760 --> 00:21:10,370
you have called the function during

00:21:07,310 --> 00:21:14,870
recording you just call this record

00:21:10,370 --> 00:21:20,240
function with the return return value

00:21:14,870 --> 00:21:22,250
that you got and the arguments and c++

00:21:20,240 --> 00:21:25,960
knows what the types of the arguments

00:21:22,250 --> 00:21:28,730
are so it's no issue for it to kind of

00:21:25,960 --> 00:21:31,310
serialize those out now on the other

00:21:28,730 --> 00:21:34,790
side on playback is a separate method to

00:21:31,310 --> 00:21:41,320
the class and you just call the one

00:21:34,790 --> 00:21:44,450
thing which is calling the actual method

00:21:41,320 --> 00:21:47,740
with you pop string that's getting the

00:21:44,450 --> 00:21:52,430
first argument so I just arranges pop

00:21:47,740 --> 00:21:54,440
pop and pop string and tell it what the

00:21:52,430 --> 00:21:58,310
function since this is this is the live

00:21:54,440 --> 00:22:00,360
well this is on playback but it's truly

00:21:58,310 --> 00:22:02,760
it is calling the library

00:22:00,360 --> 00:22:05,340
so we're going to capture the function

00:22:02,760 --> 00:22:08,010
return that actually came from the API

00:22:05,340 --> 00:22:13,860
itself and we're gonna compare it to the

00:22:08,010 --> 00:22:15,540
original function return that's one of

00:22:13,860 --> 00:22:18,090
the things we can compare this to see

00:22:15,540 --> 00:22:22,500
there are things going out of sequence

00:22:18,090 --> 00:22:27,660
and so this shows a little bit on the

00:22:22,500 --> 00:22:31,710
reader side this is inside the library

00:22:27,660 --> 00:22:34,380
I'm going to pop the string which has

00:22:31,710 --> 00:22:36,090
the API name I'm going to pop an integer

00:22:34,380 --> 00:22:40,320
which tells me whether or not there is a

00:22:36,090 --> 00:22:47,429
function return and so that's if it is

00:22:40,320 --> 00:22:51,720
pop a variant to capture the function

00:22:47,429 --> 00:22:56,669
return value and then Swizzle the

00:22:51,720 --> 00:22:59,780
pointer so in order to do this this

00:22:56,669 --> 00:23:02,820
object must already exist at this point

00:22:59,780 --> 00:23:06,660
because it's the object that you're that

00:23:02,820 --> 00:23:10,710
the method is invoked on so it gets it

00:23:06,660 --> 00:23:15,620
from the call stream unsold it no

00:23:10,710 --> 00:23:15,620
swizzles it and now you have the pointer

00:23:15,890 --> 00:23:26,210
so this uses some old fashioned things

00:23:18,360 --> 00:23:34,830
like inheritance class inheritance so

00:23:26,210 --> 00:23:39,160
it's just coming to the end and that's

00:23:34,830 --> 00:23:44,270
it duck five six minutes left

00:23:39,160 --> 00:23:48,350
[Applause]

00:23:44,270 --> 00:23:48,350
any questions arguments

00:24:01,950 --> 00:24:09,100
determinism like at my current employer

00:24:06,820 --> 00:24:11,230
we've tried dealing with playback in a

00:24:09,100 --> 00:24:12,520
couple different times one of the things

00:24:11,230 --> 00:24:14,340
that always needs to be solved for each

00:24:12,520 --> 00:24:17,050
project it gets all different ways is

00:24:14,340 --> 00:24:18,400
the output depends on the ordering of

00:24:17,050 --> 00:24:21,160
things happening in different threads

00:24:18,400 --> 00:24:23,830
concurrently threads the timing of it

00:24:21,160 --> 00:24:28,630
have you have you dealt with that and

00:24:23,830 --> 00:24:34,179
how well god bless you for having that

00:24:28,630 --> 00:24:37,570
that problem just that we there are some

00:24:34,179 --> 00:24:40,030
callbacks the api's but then we record

00:24:37,570 --> 00:24:44,710
what we do during the callback and it

00:24:40,030 --> 00:24:47,050
kind of works out but in the larger

00:24:44,710 --> 00:24:49,470
application I've talked about we have

00:24:47,050 --> 00:24:52,710
some asynchronous things happening and

00:24:49,470 --> 00:24:55,870
you you're gonna have to systematically

00:24:52,710 --> 00:24:58,240
know kind of put things down in a

00:24:55,870 --> 00:25:00,700
sequence where if we do it this is the

00:24:58,240 --> 00:25:02,520
this is the order we did it in and on

00:25:00,700 --> 00:25:09,880
playback kind of force it into that

00:25:02,520 --> 00:25:11,650
order that's the way we handled so I'm

00:25:09,880 --> 00:25:12,820
curious if you used time travel

00:25:11,650 --> 00:25:17,590
debugging at all

00:25:12,820 --> 00:25:19,510
I have not okay the main reason I

00:25:17,590 --> 00:25:22,120
mention it is that it seems like it

00:25:19,510 --> 00:25:25,030
could be substituted for some of the

00:25:22,120 --> 00:25:27,510
instrumentation on recording mm-hmm

00:25:25,030 --> 00:25:30,100
because you can't use it for things like

00:25:27,510 --> 00:25:32,500
performance very often mm-hmm

00:25:30,100 --> 00:25:33,429
and it's only on Windows as far as I

00:25:32,500 --> 00:25:36,880
know although I guess there are other

00:25:33,429 --> 00:25:40,630
versions of it but you could have your

00:25:36,880 --> 00:25:42,550
debugger in it log messages that told

00:25:40,630 --> 00:25:45,910
you whatever you want

00:25:42,550 --> 00:25:50,800
based on a repro captured on a client

00:25:45,910 --> 00:25:53,530
site and then use that in a playback

00:25:50,800 --> 00:25:58,450
tool well after the fact for your

00:25:53,530 --> 00:26:01,390
revolving live so that's a great idea I

00:25:58,450 --> 00:26:04,150
think there's lots of ways to formulate

00:26:01,390 --> 00:26:07,030
it but that's a very sort of current

00:26:04,150 --> 00:26:08,740
current one we found that I think time

00:26:07,030 --> 00:26:11,860
travel debugging is only available the

00:26:08,740 --> 00:26:13,350
Enterprise version of the studio so

00:26:11,860 --> 00:26:16,860
there's one called intellitrace

00:26:13,350 --> 00:26:19,380
for visual studio but windbg preview or

00:26:16,860 --> 00:26:21,480
window i know when the ex you know has

00:26:19,380 --> 00:26:25,799
time travel debugging built-in yeah it's

00:26:21,480 --> 00:26:30,539
i know when bag has it yeah thanks

00:26:25,799 --> 00:26:34,190
i just wanted to make a comment on the

00:26:30,539 --> 00:26:37,130
previous question multi-threaded stuff a

00:26:34,190 --> 00:26:39,330
co-worker of mine had this library

00:26:37,130 --> 00:26:41,130
essentially that could help with this

00:26:39,330 --> 00:26:43,289
it's called step i don't know if it's

00:26:41,130 --> 00:26:46,080
public or anything but the idea is you

00:26:43,289 --> 00:26:49,020
can have like a daemon that waits for a

00:26:46,080 --> 00:26:51,809
specific signal and then every time you

00:26:49,020 --> 00:26:54,390
do a Kollek you could ask it and then it

00:26:51,809 --> 00:26:55,500
only like lets it keep going as soon as

00:26:54,390 --> 00:26:57,059
everything else came in in the right

00:26:55,500 --> 00:26:58,650
order so you could kind of force an

00:26:57,059 --> 00:27:01,289
order such some idea of people are

00:26:58,650 --> 00:27:05,900
thinking about that yeah that sounds

00:27:01,289 --> 00:27:13,260
pretty close to what we have done in the

00:27:05,900 --> 00:27:14,909
UE in the GUI program sorry I just

00:27:13,260 --> 00:27:21,799
looked at the client because I kind of

00:27:14,909 --> 00:27:27,030
work on time travel debugging in so

00:27:21,799 --> 00:27:30,059
there there's one advantage to what you

00:27:27,030 --> 00:27:33,690
were saying you can have a recording

00:27:30,059 --> 00:27:36,539
which is like recording of that process

00:27:33,690 --> 00:27:38,429
is executing you can then extract

00:27:36,539 --> 00:27:41,840
something like what you're recording

00:27:38,429 --> 00:27:48,630
over here without committing okay so

00:27:41,840 --> 00:27:50,520
that being one possibility but apart

00:27:48,630 --> 00:27:53,909
from that it feels like you know killing

00:27:50,520 --> 00:27:56,490
the mosquito be the cannon right I mean

00:27:53,909 --> 00:27:58,860
something like tentative anymore and do

00:27:56,490 --> 00:28:00,059
or RR or whatever you want to use you

00:27:58,860 --> 00:28:05,610
know it's gonna be a little more heavy

00:28:00,059 --> 00:28:07,380
than this and by a little I mean yeah I

00:28:05,610 --> 00:28:09,390
mentioned it despite the fact I haven't

00:28:07,380 --> 00:28:16,650
used it I've known about it for quite a

00:28:09,390 --> 00:28:20,030
while and I mentioned it in the whatever

00:28:16,650 --> 00:28:20,030
you call it the summary

00:28:21,190 --> 00:28:33,470
it just it's a useful thing to capture

00:28:29,290 --> 00:28:38,470
data that's current but otherwise would

00:28:33,470 --> 00:28:43,790
be thrown away so yeah I'd love to

00:28:38,470 --> 00:28:45,710
integrate it now I don't know if if

00:28:43,790 --> 00:28:51,560
anyone's going to have any activity on

00:28:45,710 --> 00:28:54,430
the yet github that I presented but I

00:28:51,560 --> 00:28:59,030
work 60 hours a week on the product so I

00:28:54,430 --> 00:29:02,540
don't know how fast I'll be able to get

00:28:59,030 --> 00:29:07,820
to the PRS but it'll be interesting to

00:29:02,540 --> 00:29:09,110
see if somebody uses it anything else

00:29:07,820 --> 00:29:18,520
we're out of pretty much out of time

00:29:09,110 --> 00:29:22,109
okay thanks

00:29:18,520 --> 00:29:22,109

YouTube URL: https://www.youtube.com/watch?v=DcNYQ4qFpiI


