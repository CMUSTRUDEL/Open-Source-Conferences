Title: CppCon 2018: Timur Doumler & Dmitry Kozhevnikov “Parsing C++”
Publication date: 2018-10-14
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
C++ is a notoriously hard language to parse. Its grammar is highly context-dependent and ambiguous, and cannot be parsed without semantic analysis and arbitrarily long lookahead. Not only programmers, but also compilers (and their authors) often struggle with interpreting certain C++ constructs correctly.

This talk sheds some light on the grammar of C++ and why parsing it is hard. We will discuss which of these problems are inherited from C, and which arise due to features unique to C++. We will also look at a reasonably easy-to-parse subset of C++ (and whether it ever occurs in real life). Most importantly, we will talk about why all this matters for the practical C++ developer, and not just for compiler writers. And of course, we will also show plenty of surprising, brain-twisting code snippets.

This talk is aimed at general C++ programmers and does not require any expert knowledge about parsing and semantic analysis.
— 
Timur Doumler, JetBrains

Timur Doumler works at JetBrains, where he develops the C++ frontend for CLion, the cross-platform C++ IDE. In the past he has spent much time working in the audio tech industry and has written code for the JUCE framework. Timur is an active member of the ISO C++ committee and passionate about clean code, good tools, and the evolution of the C++ language. He regularly speaks at conferences and enjoys C++ community work, currently serving as an organiser and program chair for the Audio Developer Conference and as moderator on includecpp.org.

Dmitry Kozhevnikov
Software Developer, JetBrains
Dmitry works on C++ support in the CLion IDE by JetBrains, covering various aspects like the in-house C++ engine, inspections and refactoring engine, and clang integration.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:05,609
hello everybody my name is Mitri my name

00:00:03,570 --> 00:00:08,160
is Tim wah and I'm Tim or audio unlike

00:00:05,609 --> 00:00:10,440
Twitter and other online platforms and

00:00:08,160 --> 00:00:13,950
we are going to talk about parsing C++

00:00:10,440 --> 00:00:16,250
and we work both the brains at Hawaiian

00:00:13,950 --> 00:00:20,490
and all the sports content related stuff

00:00:16,250 --> 00:00:22,050
so we both have kind of bias and part of

00:00:20,490 --> 00:00:23,750
this talk would be from the tooling

00:00:22,050 --> 00:00:27,900
point of view not from the purely

00:00:23,750 --> 00:00:30,990
theoretical compiler and so a bit of

00:00:27,900 --> 00:00:32,520
disclaimers the main what the main

00:00:30,990 --> 00:00:36,450
purpose of this talk is to have fun

00:00:32,520 --> 00:00:40,290
because it's not like it's too much

00:00:36,450 --> 00:00:42,210
practical if you are writing because it

00:00:40,290 --> 00:00:43,620
was passed front entry probably all the

00:00:42,210 --> 00:00:46,020
know all this stuff and if you are not

00:00:43,620 --> 00:00:47,489
well you better not using all the

00:00:46,020 --> 00:00:52,289
snippets we are showing in production

00:00:47,489 --> 00:00:53,610
anyway but it's still kind of cool it

00:00:52,289 --> 00:00:55,530
kind of helps to understand the language

00:00:53,610 --> 00:00:57,800
better and to have a peek inside the

00:00:55,530 --> 00:00:59,879
language design process and how

00:00:57,800 --> 00:01:06,350
different language features interact

00:00:59,879 --> 00:01:08,850
with each other and stuff like that so I

00:01:06,350 --> 00:01:11,070
very very brief interaction how usually

00:01:08,850 --> 00:01:13,439
come cut how the textbook compiler

00:01:11,070 --> 00:01:16,740
usually works so there is a lecture a

00:01:13,439 --> 00:01:18,150
tool that converts source files to the

00:01:16,740 --> 00:01:21,750
extreme of type tokens usually as

00:01:18,150 --> 00:01:23,430
unusually the read parser - that makes a

00:01:21,750 --> 00:01:25,530
syntax tree from the stream of tokens

00:01:23,430 --> 00:01:26,939
and then goes all the fancy stuff that

00:01:25,530 --> 00:01:28,740
we are not going to talk about today so

00:01:26,939 --> 00:01:33,600
we are mostly focusing on personally and

00:01:28,740 --> 00:01:37,799
a bit of a little exit and how it's how

00:01:33,600 --> 00:01:41,430
C++ parser entries post Xers are kind of

00:01:37,799 --> 00:01:44,759
special and the first thing the special

00:01:41,430 --> 00:01:47,600
is the preprocessor because C++ source

00:01:44,759 --> 00:01:52,259
file doesn't contain consists of C++

00:01:47,600 --> 00:01:54,390
because it consists of P processor and

00:01:52,259 --> 00:01:57,390
it's completely different language it's

00:01:54,390 --> 00:01:58,979
a language in a language so the one

00:01:57,390 --> 00:02:02,820
minor annoyance is you can't even

00:01:58,979 --> 00:02:04,950
properly highlight the users caught

00:02:02,820 --> 00:02:07,170
using collected by based intercalated

00:02:04,950 --> 00:02:09,959
because this these things on the slide

00:02:07,170 --> 00:02:11,680
looks like keywords but except they're

00:02:09,959 --> 00:02:13,880
not and

00:02:11,680 --> 00:02:15,380
these are not suppose basketballs

00:02:13,880 --> 00:02:18,410
because the proper superfast coat is

00:02:15,380 --> 00:02:20,330
like on the right but it's kind of minor

00:02:18,410 --> 00:02:24,440
annoyance and you usually don't notice

00:02:20,330 --> 00:02:26,300
that what is a major annoyance that the

00:02:24,440 --> 00:02:29,090
code reuse and support plus is also

00:02:26,300 --> 00:02:30,710
based on the P processor and science and

00:02:29,090 --> 00:02:34,970
it doesn't care about it

00:02:30,710 --> 00:02:36,980
C++ antics so combined we solve the

00:02:34,970 --> 00:02:39,680
complications with in parses that we are

00:02:36,980 --> 00:02:41,420
going to talk talk about it's kind of

00:02:39,680 --> 00:02:43,010
hard to do to linked properly because

00:02:41,420 --> 00:02:45,560
the holy grail of is s equals pass to

00:02:43,010 --> 00:02:48,260
link is not reparse all include the

00:02:45,560 --> 00:02:50,510
Heelers again and again because like on

00:02:48,260 --> 00:02:54,320
my machine the hello world after p-pods

00:02:50,510 --> 00:02:57,230
think is like forty hundred forty

00:02:54,320 --> 00:02:59,630
thousand lines and we're not we don't

00:02:57,230 --> 00:03:03,170
want to report every type and it could

00:02:59,630 --> 00:03:04,640
be doable just with the preprocessor it

00:03:03,170 --> 00:03:06,020
could be doable just from the point of

00:03:04,640 --> 00:03:08,420
your parser but combined with this -

00:03:06,020 --> 00:03:13,430
it's complicated and we can't wait for

00:03:08,420 --> 00:03:16,820
the models to come and save us but kind

00:03:13,430 --> 00:03:19,700
of reports reddit baton we all know that

00:03:16,820 --> 00:03:22,220
so let's don't talk about it anymore

00:03:19,700 --> 00:03:24,230
let's talk about the grammar and like

00:03:22,220 --> 00:03:27,610
the common talking point is that suppose

00:03:24,230 --> 00:03:31,160
past doesn't really have a grammar so

00:03:27,610 --> 00:03:33,050
people like to say that but it's kind of

00:03:31,160 --> 00:03:36,380
true for a lot of languages because it's

00:03:33,050 --> 00:03:39,050
complicated to this to describe what got

00:03:36,380 --> 00:03:41,959
us well wanted what code is you forms

00:03:39,050 --> 00:03:45,350
using just a grammar so what these

00:03:41,959 --> 00:03:48,110
things it's a part of the C++ standard

00:03:45,350 --> 00:03:48,799
what it says is kind of true for a lot

00:03:48,110 --> 00:03:50,989
of languages

00:03:48,799 --> 00:03:54,080
what's specific for C++ that it's highly

00:03:50,989 --> 00:03:57,049
ambiguous grammar so there are two kind

00:03:54,080 --> 00:04:01,340
from diggities one is that some things

00:03:57,049 --> 00:04:04,640
can just be distinguished at all so you

00:04:01,340 --> 00:04:07,610
have to pick like tell that something is

00:04:04,640 --> 00:04:09,200
always a declaration but it's it's not a

00:04:07,610 --> 00:04:11,420
problem what's the problem that some

00:04:09,200 --> 00:04:13,100
things are distinguishable but to do

00:04:11,420 --> 00:04:18,769
that you require

00:04:13,100 --> 00:04:22,990
cement information how is that it's for

00:04:18,769 --> 00:04:25,180
example in the grammars

00:04:22,990 --> 00:04:28,450
things like type name answer I think

00:04:25,180 --> 00:04:30,490
like expression and both of them can be

00:04:28,450 --> 00:04:32,590
just in that identifier so it doesn't

00:04:30,490 --> 00:04:36,010
can be distinguished use and yet the

00:04:32,590 --> 00:04:37,990
syntax and the keywords and to

00:04:36,010 --> 00:04:40,180
distinguish them and to produce like

00:04:37,990 --> 00:04:44,050
different syntax see for them you have

00:04:40,180 --> 00:04:46,900
to you have to know this semantic

00:04:44,050 --> 00:04:50,050
information or maybe do something else

00:04:46,900 --> 00:04:56,460
because and it's not a problem for a lot

00:04:50,050 --> 00:04:59,590
of modern languages science usually they

00:04:56,460 --> 00:05:01,300
can be parsed without Italy like usually

00:04:59,590 --> 00:05:04,150
you can write the grammar like you

00:05:01,300 --> 00:05:06,400
favorite parser generator description

00:05:04,150 --> 00:05:08,950
generate a person be done but not you

00:05:06,400 --> 00:05:10,840
suppose class and in some other

00:05:08,950 --> 00:05:12,280
languages a kind of such problems like

00:05:10,840 --> 00:05:14,110
there is a minor problem like that in

00:05:12,280 --> 00:05:16,900
Java or like Lisp is all of like that

00:05:14,110 --> 00:05:22,420
although this syntax tree in Lisp is

00:05:16,900 --> 00:05:26,560
just lists nested lists and you can just

00:05:22,420 --> 00:05:28,060
say okay we are not going to distinguish

00:05:26,560 --> 00:05:28,690
it while parsing we're going to postpone

00:05:28,060 --> 00:05:30,640
it for later

00:05:28,690 --> 00:05:32,770
it works for some but it doesn't work I

00:05:30,640 --> 00:05:36,460
suppose C++ because like it's very

00:05:32,770 --> 00:05:38,410
different and also there is a smart ways

00:05:36,460 --> 00:05:40,210
to deal with it just two parts both

00:05:38,410 --> 00:05:42,940
branches small teeny ously but we're not

00:05:40,210 --> 00:05:44,710
going to talk about it because most of

00:05:42,940 --> 00:05:48,130
the mainstream tools that work like that

00:05:44,710 --> 00:05:51,370
and most of the mainstream compilers and

00:05:48,130 --> 00:05:55,960
mainstream tools just pretty simple

00:05:51,370 --> 00:05:59,770
looking parsers but they require to know

00:05:55,960 --> 00:06:02,110
about semantics of the language and you

00:05:59,770 --> 00:06:05,800
require two semantic analyzer such as

00:06:02,110 --> 00:06:11,140
you go so that's why they usually

00:06:05,800 --> 00:06:14,890
complicated and say they're kind of hard

00:06:11,140 --> 00:06:18,370
to write and I'm person to team or to

00:06:14,890 --> 00:06:21,460
have some specific examples right so

00:06:18,370 --> 00:06:24,400
let's dive into some actual code so as

00:06:21,460 --> 00:06:26,290
you know C++ derives a lot from C so it

00:06:24,400 --> 00:06:30,280
also inherited a lot of the grammar from

00:06:26,290 --> 00:06:31,840
C so let's see how what are the problems

00:06:30,280 --> 00:06:34,169
on the grammar and see what are the

00:06:31,840 --> 00:06:35,879
ambiguities that we can have there

00:06:34,169 --> 00:06:37,949
so it turns out there's quite a lot of

00:06:35,879 --> 00:06:40,439
things and see that can be ambiguous for

00:06:37,949 --> 00:06:42,169
example here in the inside main in the

00:06:40,439 --> 00:06:44,699
first line you know this could be either

00:06:42,169 --> 00:06:47,639
declaration of an array of pointers or

00:06:44,699 --> 00:06:49,400
it could be a function call and then a

00:06:47,639 --> 00:06:51,599
subscript on the result of that function

00:06:49,400 --> 00:06:52,979
likewise the return statement it could

00:06:51,599 --> 00:06:54,960
be either the sum of you know two

00:06:52,979 --> 00:07:00,240
variables or it could be one variable

00:06:54,960 --> 00:07:01,560
and then it's cost to type B and so it's

00:07:00,240 --> 00:07:03,840
ambiguous we don't know how to interpret

00:07:01,560 --> 00:07:05,610
this and this depends on the meaning of

00:07:03,840 --> 00:07:08,580
the identifier so for example in the

00:07:05,610 --> 00:07:10,770
first one if you know that T is a type

00:07:08,580 --> 00:07:15,779
and we know that the whole thing is

00:07:10,770 --> 00:07:17,129
going to be a declaration whereas if T

00:07:15,779 --> 00:07:18,449
is function name we know that this is

00:07:17,129 --> 00:07:20,669
going to be a function call and then the

00:07:18,449 --> 00:07:23,340
second one if B is the type then the

00:07:20,669 --> 00:07:25,379
whole thing will be cost if P is

00:07:23,340 --> 00:07:29,490
variable then that's going to be a sum

00:07:25,379 --> 00:07:31,889
so what we need to know to resolve these

00:07:29,490 --> 00:07:33,719
ambiguities is whether they identify us

00:07:31,889 --> 00:07:35,729
our types or not that's basically the

00:07:33,719 --> 00:07:40,139
main the main problem to unambiguously

00:07:35,729 --> 00:07:41,310
past see how do we do that so it turns

00:07:40,139 --> 00:07:44,339
out and see it's actually relatively

00:07:41,310 --> 00:07:46,199
easy because and C type is either a

00:07:44,339 --> 00:07:48,089
fundamental type but then you're talking

00:07:46,199 --> 00:07:49,830
about ends or floats and then those

00:07:48,089 --> 00:07:52,050
things are keywords anyway so you don't

00:07:49,830 --> 00:07:53,310
have a problem there or the only other

00:07:52,050 --> 00:07:56,610
types that you can have and C are

00:07:53,310 --> 00:07:59,099
structs and and see if we have a struct

00:07:56,610 --> 00:08:02,310
type like struck foo and we want to

00:07:59,099 --> 00:08:03,990
declare an instance of this type and see

00:08:02,310 --> 00:08:06,839
it's mandatory to use this called so

00:08:03,990 --> 00:08:09,810
called struck tag so we can't just say

00:08:06,839 --> 00:08:11,430
foo F we have to say structure F and the

00:08:09,810 --> 00:08:14,909
same you know if you declare parameter

00:08:11,430 --> 00:08:18,120
or whatever so this way it's also always

00:08:14,909 --> 00:08:21,210
done big use right so if you have an

00:08:18,120 --> 00:08:26,219
identifier then it's a struct type if

00:08:21,210 --> 00:08:27,689
it's preceded by what struck the only

00:08:26,219 --> 00:08:29,580
case and see where it gets a little bit

00:08:27,689 --> 00:08:30,960
tricky are type def so there's a common

00:08:29,580 --> 00:08:33,870
pattern and see where you write type def

00:08:30,960 --> 00:08:35,940
struct foo and then the definition and

00:08:33,870 --> 00:08:39,599
foo and then you can use it without this

00:08:35,940 --> 00:08:40,860
truck tag and then you run into these

00:08:39,599 --> 00:08:42,810
ambiguities where you need to know what

00:08:40,860 --> 00:08:45,390
foo is but it turns out that it's

00:08:42,810 --> 00:08:47,190
actually enough to just track all the

00:08:45,390 --> 00:08:50,459
identifiers that are type depth

00:08:47,190 --> 00:08:51,899
like keep them in a table and and once

00:08:50,459 --> 00:08:53,610
you once you have that and you know

00:08:51,899 --> 00:08:55,800
whether you know I identify as a type

00:08:53,610 --> 00:08:58,470
there or not that's enough to resolve

00:08:55,800 --> 00:09:00,360
all the ambiguities all right so that's

00:08:58,470 --> 00:09:02,040
okay it's not quite as trivial because

00:09:00,360 --> 00:09:03,480
there are some weird cases where an

00:09:02,040 --> 00:09:05,519
identify actually can change its meaning

00:09:03,480 --> 00:09:08,189
in the middle of a declaration there's

00:09:05,519 --> 00:09:10,230
some weird examples on the Internet

00:09:08,189 --> 00:09:12,899
but you know that's rare and that's also

00:09:10,230 --> 00:09:14,310
you can it's not really a problem you

00:09:12,899 --> 00:09:17,699
know you know people have done this

00:09:14,310 --> 00:09:19,410
since decades but of course we're not in

00:09:17,699 --> 00:09:21,029
a sea conference we are receivers Plus

00:09:19,410 --> 00:09:23,670
conference so how are things in c plus

00:09:21,029 --> 00:09:26,670
plus and of course and C past us it is

00:09:23,670 --> 00:09:29,009
much much worse why is that because we

00:09:26,670 --> 00:09:33,269
have all these nice features that we all

00:09:29,009 --> 00:09:35,069
like to use right so I'm going to try

00:09:33,269 --> 00:09:37,259
and do as as you point out a few

00:09:35,069 --> 00:09:42,089
features that see past us introduced and

00:09:37,259 --> 00:09:43,860
then say how it made it harder to pause

00:09:42,089 --> 00:09:47,910
it and made the grammar more complicated

00:09:43,860 --> 00:09:50,490
so let's start with pretty much like the

00:09:47,910 --> 00:09:54,209
first really cool feature C++ that C

00:09:50,490 --> 00:09:56,779
doesn't have our constructors so in C

00:09:54,209 --> 00:09:58,800
you can construct an object with a

00:09:56,779 --> 00:10:01,769
constructor that takes several arguments

00:09:58,800 --> 00:10:05,189
so you have you give them an in parens

00:10:01,769 --> 00:10:06,860
and by extension it also means that

00:10:05,189 --> 00:10:09,269
SuperStart introduced this

00:10:06,860 --> 00:10:11,639
initialization syntax where you

00:10:09,269 --> 00:10:13,380
initialize a variable with prints so you

00:10:11,639 --> 00:10:15,810
cannot you have the same syntax for

00:10:13,380 --> 00:10:18,300
classes and also all the other types

00:10:15,810 --> 00:10:21,660
like int so you have this new oh I can

00:10:18,300 --> 00:10:24,149
actually point this thing so you have

00:10:21,660 --> 00:10:25,649
this new syntax here where you

00:10:24,149 --> 00:10:28,110
initialize a variable you declare a

00:10:25,649 --> 00:10:30,899
variable initialize it with prints which

00:10:28,110 --> 00:10:33,899
means we have a new ambiguity so if you

00:10:30,899 --> 00:10:35,339
have int J and then in parens I then if

00:10:33,899 --> 00:10:37,439
is a type and the whole thing will be

00:10:35,339 --> 00:10:40,350
function declaration otherwise I will be

00:10:37,439 --> 00:10:42,720
the initialize of J right so far so good

00:10:40,350 --> 00:10:44,399
very easy but the problem is that now

00:10:42,720 --> 00:10:45,990
you have to track whether I is a type in

00:10:44,399 --> 00:10:49,370
order to be able to pause it and it's

00:10:45,990 --> 00:10:49,370
not enough to just try to type this

00:10:51,920 --> 00:10:57,000
basically the origin of this is in C++

00:10:55,800 --> 00:10:59,730
you don't have to write these struck

00:10:57,000 --> 00:11:00,720
tags like it see us as we call them

00:10:59,730 --> 00:11:02,939
elaborate type space

00:11:00,720 --> 00:11:04,949
firestar optional and most of the time

00:11:02,939 --> 00:11:07,050
we don't use them and the reason why

00:11:04,949 --> 00:11:09,089
biana when we created Superstars

00:11:07,050 --> 00:11:12,750
introduced that is the quote from his

00:11:09,089 --> 00:11:15,089
book design and evolution basically he

00:11:12,750 --> 00:11:17,370
wanted user defined types and built-in

00:11:15,089 --> 00:11:20,069
types to be kind of on the same footing

00:11:17,370 --> 00:11:21,300
on the same day he didn't want to you

00:11:20,069 --> 00:11:23,670
know user defined types to be more

00:11:21,300 --> 00:11:27,379
annoying to use than built-in types so

00:11:23,670 --> 00:11:31,079
that's great but it makes pausing harder

00:11:27,379 --> 00:11:32,430
so you know whatever type specify us

00:11:31,079 --> 00:11:34,709
they're optional if you don't use them

00:11:32,430 --> 00:11:37,680
you have these ambiguities actually if

00:11:34,709 --> 00:11:38,759
you do use them I mean that's one use

00:11:37,680 --> 00:11:40,230
case where you actually where they're

00:11:38,759 --> 00:11:42,149
actually useful is when you have an

00:11:40,230 --> 00:11:44,339
identifier it could be both the type and

00:11:42,149 --> 00:11:45,750
a variable in some scope and then you

00:11:44,339 --> 00:11:47,579
have to kind of distinguish it by hand

00:11:45,750 --> 00:11:49,050
this is where you actually use them but

00:11:47,579 --> 00:11:50,160
you can you can also use them another

00:11:49,050 --> 00:11:53,399
context and then it gets really weird

00:11:50,160 --> 00:11:54,959
like for example if you declare a

00:11:53,399 --> 00:11:57,269
function like this and you use an arrow

00:11:54,959 --> 00:11:59,100
to type specifier in there like the

00:11:57,269 --> 00:12:00,509
struct s start and that also actually

00:11:59,100 --> 00:12:03,000
simultaneously acts as a forward

00:12:00,509 --> 00:12:04,949
declaration so that's going to compile

00:12:03,000 --> 00:12:10,410
even if s is not defined anywhere else

00:12:04,949 --> 00:12:12,750
about and actually these implicit

00:12:10,410 --> 00:12:14,279
forward declarations created by the

00:12:12,750 --> 00:12:16,889
library type specifies they have really

00:12:14,279 --> 00:12:18,059
weird scoping rules so actually you can

00:12:16,889 --> 00:12:20,040
write it like that and it's gonna

00:12:18,059 --> 00:12:23,699
actually leak into the outer scope and

00:12:20,040 --> 00:12:28,589
and that bottom line there is also ok so

00:12:23,699 --> 00:12:30,540
this is reread so yeah so they make our

00:12:28,589 --> 00:12:31,800
life harder basically the next thing

00:12:30,540 --> 00:12:33,389
about constructors as there's this

00:12:31,800 --> 00:12:34,980
constructor colon tation where I can

00:12:33,389 --> 00:12:37,769
just write you know type and then parens

00:12:34,980 --> 00:12:39,050
and then some arguments or no arguments

00:12:37,769 --> 00:12:41,160
and that's gonna be kind of an

00:12:39,050 --> 00:12:42,809
constructor call as an expression that's

00:12:41,160 --> 00:12:44,730
super useful right so we can just call

00:12:42,809 --> 00:12:46,680
this constructor create temporary

00:12:44,730 --> 00:12:50,009
objects anywhere in an expression super

00:12:46,680 --> 00:12:52,740
cool feature but it's beyond or you

00:12:50,009 --> 00:12:57,209
recognized decades ago this is the first

00:12:52,740 --> 00:13:00,379
source of more parsing problems so let's

00:12:57,209 --> 00:13:02,879
see what constructor call notation does

00:13:00,379 --> 00:13:04,860
first of all it gives rise to the most

00:13:02,879 --> 00:13:06,569
vexing pass which is probably the most

00:13:04,860 --> 00:13:08,850
famous kind of grammar and bring it in

00:13:06,569 --> 00:13:11,220
C++ I'm sure and if you have heard about

00:13:08,850 --> 00:13:13,830
that so if you have a typed food and

00:13:11,220 --> 00:13:17,460
then we write those kind of foo a fan

00:13:13,830 --> 00:13:19,440
around paren inside the parameter what

00:13:17,460 --> 00:13:21,890
is this thing so it could be either and

00:13:19,440 --> 00:13:24,180
initializer we call the constructor and

00:13:21,890 --> 00:13:26,640
it returns a temporary foo and that's

00:13:24,180 --> 00:13:28,710
gonna be the initializer for F right or

00:13:26,640 --> 00:13:31,080
it could be a function declaration of a

00:13:28,710 --> 00:13:32,820
function type that takes a function that

00:13:31,080 --> 00:13:34,200
takes no arguments and returns a foo and

00:13:32,820 --> 00:13:39,420
then that function returns a foo

00:13:34,200 --> 00:13:41,190
right so and then the sauce grammar says

00:13:39,420 --> 00:13:42,480
well we just invigorated by saying

00:13:41,190 --> 00:13:45,450
everything that could be declaration is

00:13:42,480 --> 00:13:47,160
a declaration so this line would be a

00:13:45,450 --> 00:13:50,070
function declaration actually and if you

00:13:47,160 --> 00:13:51,960
want to you want it to mean that it's an

00:13:50,070 --> 00:13:53,640
initializer we have to you have to use

00:13:51,960 --> 00:13:56,100
these extra parens around which is

00:13:53,640 --> 00:13:58,590
really weird and can bite you in in a

00:13:56,100 --> 00:14:04,080
real-world code nico had a nice example

00:13:58,590 --> 00:14:08,520
in his talk this week but this is kind

00:14:04,080 --> 00:14:10,260
of well-known the other thing that kind

00:14:08,520 --> 00:14:12,120
of goes under the hood that you might

00:14:10,260 --> 00:14:14,550
not maybe be aware of a few if you're

00:14:12,120 --> 00:14:17,760
writing code is that if you try to pause

00:14:14,550 --> 00:14:19,890
the stuff actually you have to resolve

00:14:17,760 --> 00:14:21,270
this ambiguity right so sometimes you

00:14:19,890 --> 00:14:22,440
there's an open paren and you start

00:14:21,270 --> 00:14:24,060
pausing it and then you try to figure

00:14:22,440 --> 00:14:25,050
out if you could this be a type then the

00:14:24,060 --> 00:14:27,630
whole thing is a function declaration

00:14:25,050 --> 00:14:29,040
could this be something else and then

00:14:27,630 --> 00:14:31,700
you can have something arbitrarily long

00:14:29,040 --> 00:14:34,890
there right where you don't know okay so

00:14:31,700 --> 00:14:36,570
you know if it would end here it would

00:14:34,890 --> 00:14:38,880
be like most vexing pass function

00:14:36,570 --> 00:14:40,560
declaration but there's a comma there so

00:14:38,880 --> 00:14:43,260
you know it could also be a constructor

00:14:40,560 --> 00:14:45,030
call you don't know yet and the next one

00:14:43,260 --> 00:14:47,010
well we it also could be either

00:14:45,030 --> 00:14:49,350
constructor call or you know a function

00:14:47,010 --> 00:14:52,340
type and the next one also right so you

00:14:49,350 --> 00:14:54,960
have to you have to keep keep going and

00:14:52,340 --> 00:14:56,400
then at some point there's something

00:14:54,960 --> 00:14:58,530
that will disambiguate it which is in

00:14:56,400 --> 00:14:59,640
case this bar and then if that's a type

00:14:58,530 --> 00:15:02,040
the whole thing will be a function

00:14:59,640 --> 00:15:02,940
declaration if that's a variable the

00:15:02,040 --> 00:15:04,620
whole thing is going to be an

00:15:02,940 --> 00:15:06,510
initializer and then if you get strong

00:15:04,620 --> 00:15:08,940
you have to rewind the whole thing and

00:15:06,510 --> 00:15:10,440
start over with your pausing and if

00:15:08,940 --> 00:15:12,090
you're pausing c++ operations you have

00:15:10,440 --> 00:15:13,860
to do that all the time right there's

00:15:12,090 --> 00:15:15,630
more cases like this where you have like

00:15:13,860 --> 00:15:17,370
two or three different possibilities and

00:15:15,630 --> 00:15:19,320
you keep doing this all the time when

00:15:17,370 --> 00:15:22,050
you pass and your pass code just no

00:15:19,320 --> 00:15:25,940
guest start passing all wrong rewind

00:15:22,050 --> 00:15:25,940
there's some big great UI and start over

00:15:26,030 --> 00:15:30,190
so that's what passes to all the time

00:15:30,220 --> 00:15:34,730
these initializers with parents they

00:15:32,360 --> 00:15:37,100
create more problems so it's it's not

00:15:34,730 --> 00:15:39,380
just you know that you have to rewind

00:15:37,100 --> 00:15:41,660
sometimes and start over

00:15:39,380 --> 00:15:43,580
sometimes this this process of rewinding

00:15:41,660 --> 00:15:47,420
is actually more complicated let's take

00:15:43,580 --> 00:15:49,370
a normal function pointer so you know

00:15:47,420 --> 00:15:51,770
one of the things we talked about it

00:15:49,370 --> 00:15:53,300
also this week is you know we should all

00:15:51,770 --> 00:15:56,360
be using trade in return types because

00:15:53,300 --> 00:15:57,740
they're really cool and more than so we

00:15:56,360 --> 00:15:59,330
can also use them with function pointers

00:15:57,740 --> 00:15:59,950
right so we can write this declaration

00:15:59,330 --> 00:16:03,200
like that

00:15:59,950 --> 00:16:06,230
that's a pointer to a function that

00:16:03,200 --> 00:16:07,820
returns an int now of course a function

00:16:06,230 --> 00:16:10,670
pointer is also simultaneously a

00:16:07,820 --> 00:16:13,100
variable so we can initialize it right

00:16:10,670 --> 00:16:16,480
and the grammar allows initializes and

00:16:13,100 --> 00:16:20,390
parens so we can initialize it like that

00:16:16,480 --> 00:16:21,830
right so in this case ba is a null

00:16:20,390 --> 00:16:22,940
pointer so we initialize the pointer

00:16:21,830 --> 00:16:26,150
with a null pointer which is totally

00:16:22,940 --> 00:16:30,700
valid code but it looks like actually

00:16:26,150 --> 00:16:32,990
this in bar is a function type right

00:16:30,700 --> 00:16:35,030
which is of course not allowed because

00:16:32,990 --> 00:16:37,130
you can't return a function type from

00:16:35,030 --> 00:16:40,370
something like that but you know it's

00:16:37,130 --> 00:16:43,100
still valid grammar so in this case you

00:16:40,370 --> 00:16:45,620
would have to kind of start pausing it

00:16:43,100 --> 00:16:47,000
and then realize oh you know something's

00:16:45,620 --> 00:16:48,680
wrong and then rewind but this makes it

00:16:47,000 --> 00:16:49,390
really tricky here because what's going

00:16:48,680 --> 00:16:51,890
on here

00:16:49,390 --> 00:16:54,260
so we have this one part of the grammar

00:16:51,890 --> 00:16:58,220
which is the grammar of the of the

00:16:54,260 --> 00:17:00,740
decorator which is you know decorator

00:16:58,220 --> 00:17:02,000
has it's kind of named parameters and

00:17:00,740 --> 00:17:04,150
then trading return type and then

00:17:02,000 --> 00:17:07,910
trading turn type is arrow and then type

00:17:04,150 --> 00:17:09,620
and then several levels above this whole

00:17:07,910 --> 00:17:13,490
thing is actually part of a declaration

00:17:09,620 --> 00:17:15,290
which can have in the end an optional

00:17:13,490 --> 00:17:18,680
initializer which can optionally be in

00:17:15,290 --> 00:17:20,569
parens so if you're pausing this arrow

00:17:18,680 --> 00:17:22,130
in and then you hit the paren then you

00:17:20,569 --> 00:17:23,449
think oh this looks like a tight like a

00:17:22,130 --> 00:17:25,400
function type and then you hit the bar

00:17:23,449 --> 00:17:28,189
and then you say okay that's not the

00:17:25,400 --> 00:17:30,050
function type you can't just say okay

00:17:28,189 --> 00:17:33,140
well then this is a wrong function type

00:17:30,050 --> 00:17:34,970
and we roll back the function type right

00:17:33,140 --> 00:17:36,560
so you have to roll back to after the

00:17:34,970 --> 00:17:39,110
int because you have to realize that

00:17:36,560 --> 00:17:41,809
several levels above there was something

00:17:39,110 --> 00:17:43,370
where you know it could be followed by

00:17:41,809 --> 00:17:45,530
something else in parens in this case

00:17:43,370 --> 00:17:48,070
the initializer and then kind of roll

00:17:45,530 --> 00:17:50,990
back to the right point and then kind of

00:17:48,070 --> 00:17:53,179
start start pausing this other part of

00:17:50,990 --> 00:17:55,160
the grammar and this is something where

00:17:53,179 --> 00:17:58,220
these are cases where you can find bugs

00:17:55,160 --> 00:18:00,140
and you know many popular compilers like

00:17:58,220 --> 00:18:04,580
at least one of the three big compilers

00:18:00,140 --> 00:18:08,840
and him even to a this code they fail at

00:18:04,580 --> 00:18:10,460
this code another thing you can do with

00:18:08,840 --> 00:18:11,840
parens is not just put them around

00:18:10,460 --> 00:18:13,309
initialize but also put them around

00:18:11,840 --> 00:18:15,380
decorators all right so if you have a

00:18:13,309 --> 00:18:17,030
decorator this is the example here the

00:18:15,380 --> 00:18:18,530
name of a variable X you can just put

00:18:17,030 --> 00:18:22,580
parens around it as many as you want

00:18:18,530 --> 00:18:25,790
great so obviously we need them because

00:18:22,580 --> 00:18:27,530
and we had that since C because this way

00:18:25,790 --> 00:18:29,870
we can distinguish between function

00:18:27,530 --> 00:18:32,929
pointers and you know functions

00:18:29,870 --> 00:18:34,240
returning pointers and and that's

00:18:32,929 --> 00:18:37,669
actually not a problem you know the

00:18:34,240 --> 00:18:39,640
grammar of these kind of pointers and

00:18:37,669 --> 00:18:45,650
you can also nest them it's a bit nasty

00:18:39,640 --> 00:18:50,660
but it's it's not really ambiguous but

00:18:45,650 --> 00:18:52,070
the possibility of creating having

00:18:50,660 --> 00:18:53,419
decorators with friends around it

00:18:52,070 --> 00:18:55,400
creates these in all these ambiguities

00:18:53,419 --> 00:18:57,260
with other contract on constructs like

00:18:55,400 --> 00:19:00,230
for example if you have who bar and the

00:18:57,260 --> 00:19:02,900
bars and parens and C++ this can be five

00:19:00,230 --> 00:19:04,669
different things right it can be a

00:19:02,900 --> 00:19:06,110
variable declaration where you put like

00:19:04,669 --> 00:19:09,470
a redundant parens around the variable

00:19:06,110 --> 00:19:11,900
name it could be constructor declaration

00:19:09,470 --> 00:19:14,690
if it's inside a class it could be funky

00:19:11,900 --> 00:19:17,240
style cost if foo is a type and positive

00:19:14,690 --> 00:19:19,010
expression could be function call if

00:19:17,240 --> 00:19:21,650
it's a function name it could be

00:19:19,010 --> 00:19:23,929
function type right at both of these are

00:19:21,650 --> 00:19:25,160
types so so there's like at least five

00:19:23,929 --> 00:19:27,020
different things that this thing could

00:19:25,160 --> 00:19:28,580
mean and you have to and this also

00:19:27,020 --> 00:19:31,280
depends obviously on the context or on

00:19:28,580 --> 00:19:33,080
you know the outer things or the things

00:19:31,280 --> 00:19:36,530
before it or whether it's inside a class

00:19:33,080 --> 00:19:38,150
or whether it's somewhere else and you

00:19:36,530 --> 00:19:39,470
have to you have to distinguish all

00:19:38,150 --> 00:19:41,150
these cases and disambiguate all these

00:19:39,470 --> 00:19:51,490
cases which you know makes it

00:19:41,150 --> 00:19:54,520
non non trivial so another example with

00:19:51,490 --> 00:19:56,710
Firenze so this whole thing actually

00:19:54,520 --> 00:19:58,270
nests as well right so you had coals I

00:19:56,710 --> 00:20:00,280
can have parens if you declare parameter

00:19:58,270 --> 00:20:04,870
inside a function and then it gets

00:20:00,280 --> 00:20:07,600
really funny so if you have it like that

00:20:04,870 --> 00:20:09,820
then you know it could be either an

00:20:07,600 --> 00:20:12,700
initializer of an integer foo

00:20:09,820 --> 00:20:18,100
where you know you have X and you just

00:20:12,700 --> 00:20:19,990
cast it to int now or it could be that

00:20:18,100 --> 00:20:22,390
it's a function taking an interferometer

00:20:19,990 --> 00:20:26,920
which is called X and then you just put

00:20:22,390 --> 00:20:28,750
the name in parens so both are perfectly

00:20:26,920 --> 00:20:30,910
valid so there's a standard has all

00:20:28,750 --> 00:20:32,530
these extra rules where it says well if

00:20:30,910 --> 00:20:35,320
it's either this or this then we just

00:20:32,530 --> 00:20:36,850
save that and in this case you know the

00:20:35,320 --> 00:20:38,380
overall rule is whatever can be a

00:20:36,850 --> 00:20:40,450
declaration is a declaration so in this

00:20:38,380 --> 00:20:44,130
case index would be the Declaration of a

00:20:40,450 --> 00:20:47,200
parameter so it's not a cost and oops

00:20:44,130 --> 00:20:52,510
and obviously if X is a type and the

00:20:47,200 --> 00:20:55,030
whole thing is a function type there are

00:20:52,510 --> 00:20:57,640
more funny cases where you you have this

00:20:55,030 --> 00:20:59,890
kind of declaration versus expression

00:20:57,640 --> 00:21:01,840
kind of thing going on one example is

00:20:59,890 --> 00:21:03,550
the initializer in for and since it's a

00:21:01,840 --> 00:21:06,250
17 we can also put them in if it's

00:21:03,550 --> 00:21:07,840
switch so this is a weird case because

00:21:06,250 --> 00:21:10,450
typically we would always put the

00:21:07,840 --> 00:21:12,010
correct like what them may mate for is

00:21:10,450 --> 00:21:14,290
typically we would put a declaration in

00:21:12,010 --> 00:21:15,490
there right so if you have a and if with

00:21:14,290 --> 00:21:16,720
initializer you would use the

00:21:15,490 --> 00:21:19,210
initializer to initialize a variable

00:21:16,720 --> 00:21:20,950
that you then use in the condition and

00:21:19,210 --> 00:21:22,900
maybe in the body with you but the

00:21:20,950 --> 00:21:24,220
grammar allow us to put also arbitrary

00:21:22,900 --> 00:21:26,200
expressions in there well not quite

00:21:24,220 --> 00:21:29,500
arbitrary but it'll also put expressions

00:21:26,200 --> 00:21:33,100
in there so if you have this kind of if

00:21:29,500 --> 00:21:34,480
int a thing then you say okay if in a

00:21:33,100 --> 00:21:37,059
probably this is the classical case

00:21:34,480 --> 00:21:40,380
you're declaring a variable at AE of

00:21:37,059 --> 00:21:43,270
type int in in your if put initializer

00:21:40,380 --> 00:21:45,280
you put extra parens around it you know

00:21:43,270 --> 00:21:47,590
that's that's fine so that's a

00:21:45,280 --> 00:21:52,330
declaration but then it has to then you

00:21:47,590 --> 00:21:55,900
have this curve + whoops sorry wrong

00:21:52,330 --> 00:22:00,130
button did that happen

00:21:55,900 --> 00:22:03,040
sorry then you have this + stuff here

00:22:00,130 --> 00:22:07,450
going on and then actually

00:22:03,040 --> 00:22:10,240
most composers including you know

00:22:07,450 --> 00:22:12,190
popular puzzles they say well okay

00:22:10,240 --> 00:22:14,830
that's that's an inform declaration

00:22:12,190 --> 00:22:16,900
right so and then they spew out these

00:22:14,830 --> 00:22:19,120
like weird errors although in fact

00:22:16,900 --> 00:22:20,830
actually it's valid because it's it's an

00:22:19,120 --> 00:22:22,330
expression right it's some it's a you

00:22:20,830 --> 00:22:23,830
cast it to int and you add another

00:22:22,330 --> 00:22:25,750
variable so it's perfectly valid code

00:22:23,830 --> 00:22:28,200
but most compilers actually fail to

00:22:25,750 --> 00:22:28,200
compile it

00:22:28,390 --> 00:22:35,919
[Music]

00:22:31,169 --> 00:22:39,490
so one last one of these weird code

00:22:35,919 --> 00:22:40,960
examples so we talked about the most

00:22:39,490 --> 00:22:42,370
vexing paths but actually it's not the

00:22:40,960 --> 00:22:45,669
most vexing path because there is some

00:22:42,370 --> 00:22:49,390
more vexing paths the more we keep ours

00:22:45,669 --> 00:22:52,900
goes like this so you have a function

00:22:49,390 --> 00:22:56,220
declaration which is taking a parameter

00:22:52,900 --> 00:22:58,240
of type rule right so far so good

00:22:56,220 --> 00:23:00,040
all right now you're gonna give this

00:22:58,240 --> 00:23:03,250
parameter a name right you can do that

00:23:00,040 --> 00:23:05,799
obviously so you also name it who just

00:23:03,250 --> 00:23:08,500
because you can yeah like it's always

00:23:05,799 --> 00:23:10,030
angers me whites even about it it would

00:23:08,500 --> 00:23:16,990
be so easy to Bennet like 50 years ago

00:23:10,030 --> 00:23:20,020
but yes yeah so but no one did so you

00:23:16,990 --> 00:23:22,150
can have parameter name equals time

00:23:20,020 --> 00:23:25,330
anyway so this is still a function that

00:23:22,150 --> 00:23:29,230
takes the parameter food right right now

00:23:25,330 --> 00:23:31,150
we add parens around the decorator now

00:23:29,230 --> 00:23:34,150
it changes right this is the most vexing

00:23:31,150 --> 00:23:36,070
path so now all of a sudden this is

00:23:34,150 --> 00:23:39,340
interpreted as the whole thing inside

00:23:36,070 --> 00:23:43,360
and also interpreted as a as a

00:23:39,340 --> 00:23:44,740
declaration so bar two would be a

00:23:43,360 --> 00:23:47,140
function that takes a function that

00:23:44,740 --> 00:23:49,240
takes your foo into trance a foo that

00:23:47,140 --> 00:23:51,610
returns void right so those are

00:23:49,240 --> 00:23:53,860
different now

00:23:51,610 --> 00:23:56,169
just because you can what happens if you

00:23:53,860 --> 00:24:01,110
add another pair of parens around the

00:23:56,169 --> 00:24:06,070
name anyone knows the answer

00:24:01,110 --> 00:24:07,510
gonna say that so got balls not gonna

00:24:06,070 --> 00:24:12,549
help you because different compilers

00:24:07,510 --> 00:24:14,770
again give different answers so it's

00:24:12,549 --> 00:24:16,659
actually not not not really easy to work

00:24:14,770 --> 00:24:20,499
this out

00:24:16,659 --> 00:24:22,119
I was funny funny episode at the ACC you

00:24:20,499 --> 00:24:24,249
conference in April this year where I

00:24:22,119 --> 00:24:25,619
was showing this this code sample around

00:24:24,249 --> 00:24:28,570
some point there were like four people

00:24:25,619 --> 00:24:29,799
I'm staring at this like three of them

00:24:28,570 --> 00:24:31,869
were committing members and one of them

00:24:29,799 --> 00:24:33,879
was Richard Smith and we were kind of

00:24:31,869 --> 00:24:35,379
trying to figure out whether by three

00:24:33,879 --> 00:24:38,769
years the same as bar two are the same

00:24:35,379 --> 00:24:41,679
as par one and it took quite a while for

00:24:38,769 --> 00:24:43,179
us to reach no opinion on what it was

00:24:41,679 --> 00:24:44,889
like it was really not obvious and then

00:24:43,179 --> 00:24:46,179
they kind of explanation like the

00:24:44,889 --> 00:24:49,359
grammar production that actually tells

00:24:46,179 --> 00:24:50,859
you like okay which is the correct one

00:24:49,359 --> 00:24:53,289
and then if you really squint hard at

00:24:50,859 --> 00:24:55,809
the standard then actually the rule like

00:24:53,289 --> 00:24:57,460
the usual rule for disambiguating this

00:24:55,809 --> 00:25:01,559
can kind of be applied to figure out

00:24:57,460 --> 00:25:04,389
what this is but it's really not obvious

00:25:01,559 --> 00:25:06,090
yeah so I'm gonna leave it to you as an

00:25:04,389 --> 00:25:10,149
exercise to figure out what that means I

00:25:06,090 --> 00:25:14,229
I think it tweeted the answer somewhere

00:25:10,149 --> 00:25:15,609
at some point anyway but of course you

00:25:14,229 --> 00:25:17,679
can say you know these are all funny

00:25:15,609 --> 00:25:18,789
examples that I'm showing to you because

00:25:17,679 --> 00:25:20,169
I'm trying to be funny but this is

00:25:18,789 --> 00:25:22,210
actually like no one writes code like

00:25:20,169 --> 00:25:24,429
this right so why should we worry about

00:25:22,210 --> 00:25:26,320
this like you know if you add extra

00:25:24,429 --> 00:25:28,629
friends around weird things and you add

00:25:26,320 --> 00:25:30,070
like all these like this is construed

00:25:28,629 --> 00:25:31,989
right like no one writes code like this

00:25:30,070 --> 00:25:37,029
so as long as we just write normal code

00:25:31,989 --> 00:25:39,039
we're all gonna be fine well yes but not

00:25:37,029 --> 00:25:40,779
those of us who write cause us compiled

00:25:39,039 --> 00:25:41,859
us i des and other kinds of tools

00:25:40,779 --> 00:25:44,859
because if you actually you have to

00:25:41,859 --> 00:25:46,179
worry about this stuff because almost no

00:25:44,859 --> 00:25:48,460
one writes code like this but once in a

00:25:46,179 --> 00:25:50,499
while there is going to be a bug report

00:25:48,460 --> 00:25:51,789
where you know someone has these extra

00:25:50,499 --> 00:25:54,220
friends and then they're like this is

00:25:51,789 --> 00:25:55,899
not working and then well you want to be

00:25:54,220 --> 00:25:58,210
standard compliant so we have to fix all

00:25:55,899 --> 00:25:59,739
of these right so you have to write

00:25:58,210 --> 00:26:02,080
tests for all these cases we have to

00:25:59,739 --> 00:26:03,999
figure out what they mean you know we

00:26:02,080 --> 00:26:05,950
have to add all these branches extra

00:26:03,999 --> 00:26:07,629
checks in the parcel that says you know

00:26:05,950 --> 00:26:08,859
it could be this weird thing and we have

00:26:07,629 --> 00:26:12,489
to check for that even though no one's

00:26:08,859 --> 00:26:14,979
going to write that so you know this is

00:26:12,489 --> 00:26:18,820
also no development time goes into this

00:26:14,979 --> 00:26:20,769
and sometimes you know you add these

00:26:18,820 --> 00:26:22,840
fixes into a code that actually passes

00:26:20,769 --> 00:26:25,720
very common constructs normally so it's

00:26:22,840 --> 00:26:27,549
you know how paths that you know makes

00:26:25,720 --> 00:26:29,169
the whole thing slower okay that's not

00:26:27,549 --> 00:26:30,500
really relevant you know the big picture

00:26:29,169 --> 00:26:32,930
because things like template

00:26:30,500 --> 00:26:34,730
Association or the linka will always

00:26:32,930 --> 00:26:37,100
consume more resources than the Basel

00:26:34,730 --> 00:26:39,890
but still you know you might introduce

00:26:37,100 --> 00:26:41,720
more bugs and then overall it has an

00:26:39,890 --> 00:26:44,600
impact on you because it has an impact

00:26:41,720 --> 00:26:47,050
on the tools that we write so so all

00:26:44,600 --> 00:26:49,190
these like weird grammar properties they

00:26:47,050 --> 00:26:54,380
they do it they do have a negative

00:26:49,190 --> 00:26:57,590
impact so we have to handle this

00:26:54,380 --> 00:27:00,920
correction we have to pass all code that

00:26:57,590 --> 00:27:02,750
is correct we have to pass correctly so

00:27:00,920 --> 00:27:04,130
how do we do that well okay so we

00:27:02,750 --> 00:27:05,750
implement the grammar that's understand

00:27:04,130 --> 00:27:07,070
that and we implement the distant

00:27:05,750 --> 00:27:10,310
variation rules that I understand that

00:27:07,070 --> 00:27:12,530
right why is this so hard you know why

00:27:10,310 --> 00:27:16,940
why why do stood we still have all these

00:27:12,530 --> 00:27:18,050
bogs in Hawaii why so hard to do this so

00:27:16,940 --> 00:27:19,280
first of all as you already said you

00:27:18,050 --> 00:27:20,750
know in order to pass things correctly

00:27:19,280 --> 00:27:22,280
you have to track all identify us right

00:27:20,750 --> 00:27:23,660
so for any identifier that gives

00:27:22,280 --> 00:27:25,940
anywhere you have to know is it a

00:27:23,660 --> 00:27:27,800
variable is it a type is the parameter

00:27:25,940 --> 00:27:29,680
pack that's another thing where you know

00:27:27,800 --> 00:27:32,960
if you have template Technium total args

00:27:29,680 --> 00:27:34,670
and then the odds this identify it

00:27:32,960 --> 00:27:39,160
appears somewhere else then depending on

00:27:34,670 --> 00:27:41,090
whether that's that's a very deep

00:27:39,160 --> 00:27:43,520
parameter this could mean either pack

00:27:41,090 --> 00:27:45,260
expansion or an ellipsis so this also

00:27:43,520 --> 00:27:47,870
matters or it could be combinations of

00:27:45,260 --> 00:27:49,370
the above like that bar could be like an

00:27:47,870 --> 00:27:51,530
integer and at the same time it could be

00:27:49,370 --> 00:27:53,660
a type and it could be an undeclared

00:27:51,530 --> 00:27:56,360
identifier so all of these things matter

00:27:53,660 --> 00:27:59,420
and we have to figure that out now this

00:27:56,360 --> 00:28:01,790
still doesn't sound really hard but why

00:27:59,420 --> 00:28:03,440
why is it hard so okay you have an

00:28:01,790 --> 00:28:05,240
identifier and C++ you need to figure

00:28:03,440 --> 00:28:06,950
out what that thing is how do you do

00:28:05,240 --> 00:28:09,260
that right so you're in some kind of

00:28:06,950 --> 00:28:11,300
scope so what you have to do to find the

00:28:09,260 --> 00:28:14,420
meaning of an identifier you have to do

00:28:11,300 --> 00:28:18,140
name lookup write a name lookup in C++

00:28:14,420 --> 00:28:19,550
is really really hard right so what you

00:28:18,140 --> 00:28:22,190
have to do you'd like to even figure out

00:28:19,550 --> 00:28:23,840
what identifier means whether that's a

00:28:22,190 --> 00:28:27,250
variable or a type right that's kind of

00:28:23,840 --> 00:28:29,810
the typical case so first of all we have

00:28:27,250 --> 00:28:31,760
namespaces right so we have also using

00:28:29,810 --> 00:28:33,350
namespace which brings all the

00:28:31,760 --> 00:28:35,510
identifiers from another name space into

00:28:33,350 --> 00:28:38,570
the current scope you have inline

00:28:35,510 --> 00:28:40,520
namespaces we have namespace areas you

00:28:38,570 --> 00:28:42,260
have inheritance which also takes all

00:28:40,520 --> 00:28:43,400
the identifiers from the base class and

00:28:42,260 --> 00:28:44,900
brings them into the current score

00:28:43,400 --> 00:28:46,850
when obviously you also have multiple

00:28:44,900 --> 00:28:48,200
inheritance and then you have more

00:28:46,850 --> 00:28:50,510
ambiguities that you have to deal with

00:28:48,200 --> 00:28:54,730
if argument dependent lookup which has

00:28:50,510 --> 00:28:56,800
really complicated and not obvious rules

00:28:54,730 --> 00:28:59,480
so these are kind of the three big ones

00:28:56,800 --> 00:29:01,940
but then there's also all these extra

00:28:59,480 --> 00:29:05,980
little cases and features and rules like

00:29:01,940 --> 00:29:09,050
for example Auto blind definitions right

00:29:05,980 --> 00:29:11,180
so you have if you have a class and you

00:29:09,050 --> 00:29:12,710
you you can define like a class inside

00:29:11,180 --> 00:29:14,780
there and then you have a constructor

00:29:12,710 --> 00:29:17,000
and you can declare the constructor

00:29:14,780 --> 00:29:19,490
inside you can define it outside and

00:29:17,000 --> 00:29:21,170
then there's this weird rule that you

00:29:19,490 --> 00:29:22,730
know if you have the you have this out

00:29:21,170 --> 00:29:24,140
of line definition of a constructor and

00:29:22,730 --> 00:29:26,120
you haven't identified in here

00:29:24,140 --> 00:29:28,880
then you're not going to look it up in

00:29:26,120 --> 00:29:30,320
the scope you're in because it's an out

00:29:28,880 --> 00:29:33,410
of line definition you have to look it

00:29:30,320 --> 00:29:38,750
up in the scope of that class which is

00:29:33,410 --> 00:29:40,700
somewhere else right so you have all

00:29:38,750 --> 00:29:46,070
these extra rules that you have to take

00:29:40,700 --> 00:29:49,130
care of ok so that's still not hard

00:29:46,070 --> 00:29:50,140
right because the rules are there so why

00:29:49,130 --> 00:29:56,840
is it so hard

00:29:50,140 --> 00:29:59,630
alright so okay actually sorry it is

00:29:56,840 --> 00:30:02,420
hard because all these features

00:29:59,630 --> 00:30:04,280
basically can mean that and you almost

00:30:02,420 --> 00:30:06,770
any identifier from any scope can be in

00:30:04,280 --> 00:30:10,220
any other scope basically through one of

00:30:06,770 --> 00:30:11,870
these rules but okay there are rules

00:30:10,220 --> 00:30:13,250
right so we can you can take all these

00:30:11,870 --> 00:30:16,040
really complicated rules and implement

00:30:13,250 --> 00:30:19,130
them and then it's not really hard that

00:30:16,040 --> 00:30:22,510
was kind of my original point I mean

00:30:19,130 --> 00:30:22,510
it's really really hard but it's doable

00:30:23,140 --> 00:30:33,920
okay it's hard but it's doable but why

00:30:28,040 --> 00:30:36,559
is it really hard and the reason is well

00:30:33,920 --> 00:30:40,600
how do you how do you even find find

00:30:36,559 --> 00:30:43,520
this code right so for example you have

00:30:40,600 --> 00:30:45,710
you have it again this thing where this

00:30:43,520 --> 00:30:51,800
might be an IDE but this might be either

00:30:45,710 --> 00:30:53,840
an initializer if buzz is available or

00:30:51,800 --> 00:30:56,550
it passes a type

00:30:53,840 --> 00:31:00,840
then the whole thing is a function

00:30:56,550 --> 00:31:02,220
declaration okay so you need to find

00:31:00,840 --> 00:31:03,420
buzzer which is in some kind of scope

00:31:02,220 --> 00:31:05,550
okay fine

00:31:03,420 --> 00:31:07,530
there's all these complicated rules you

00:31:05,550 --> 00:31:09,960
look it up you what's about it but

00:31:07,530 --> 00:31:12,240
sometimes in order to even find the

00:31:09,960 --> 00:31:14,010
scope which you have to look into to

00:31:12,240 --> 00:31:16,260
determine whether buzz is a type or a

00:31:14,010 --> 00:31:18,870
variable or something else depends on

00:31:16,260 --> 00:31:21,300
other code like actual code like in this

00:31:18,870 --> 00:31:25,500
example for example the scope is some

00:31:21,300 --> 00:31:27,960
type which is the deco type of some

00:31:25,500 --> 00:31:30,960
expression right so it could be some

00:31:27,960 --> 00:31:33,750
class somewhere whatever but in also you

00:31:30,960 --> 00:31:36,420
can find that scope to look up bars we

00:31:33,750 --> 00:31:40,050
need to evaluate who and bar which are

00:31:36,420 --> 00:31:42,630
some context per functions which would

00:31:40,050 --> 00:31:45,150
code in them right so and then the

00:31:42,630 --> 00:31:47,280
return type for example of foo could

00:31:45,150 --> 00:31:49,800
have an auto return type which depends

00:31:47,280 --> 00:31:51,390
which you know depending on which branch

00:31:49,800 --> 00:31:54,140
you're taking at compile time it could

00:31:51,390 --> 00:31:56,370
return one type or another type and

00:31:54,140 --> 00:31:58,260
which type you're returning depends on

00:31:56,370 --> 00:32:00,360
some kind of if constic spur condition

00:31:58,260 --> 00:32:02,250
which depends on yet other code like

00:32:00,360 --> 00:32:05,070
these other contexts for functions which

00:32:02,250 --> 00:32:08,220
you then also have to evaluate so in

00:32:05,070 --> 00:32:10,710
order to even pass C++

00:32:08,220 --> 00:32:15,630
you need to evaluate almost arbitrary

00:32:10,710 --> 00:32:17,310
code at compile time right so there's

00:32:15,630 --> 00:32:19,050
the subset of C++ which is allowed on

00:32:17,310 --> 00:32:21,210
constant expert is already quite big and

00:32:19,050 --> 00:32:22,980
in C++ 20 as we heard from lui couple

00:32:21,210 --> 00:32:27,660
hours ago it's going to be much bigger

00:32:22,980 --> 00:32:29,760
so every C passed esparza basically has

00:32:27,660 --> 00:32:33,750
to be a full-blown C++ interpreter at

00:32:29,760 --> 00:32:36,150
the same time right and and so this is a

00:32:33,750 --> 00:32:37,980
pretty unusual property for a

00:32:36,150 --> 00:32:40,830
programming language that in order to

00:32:37,980 --> 00:32:43,050
just pass it and like like build an

00:32:40,830 --> 00:32:44,370
abstract syntax tree which is like the

00:32:43,050 --> 00:32:46,950
first thing that you have to do before

00:32:44,370 --> 00:32:52,170
did you do anything you have to execute

00:32:46,950 --> 00:32:56,210
the code right this yeah so this is this

00:32:52,170 --> 00:32:56,210
is what makes C this tooling so hard

00:32:56,300 --> 00:33:06,270
yeah so this is the world

00:33:01,200 --> 00:33:08,250
as to do this of course that's not all

00:33:06,270 --> 00:33:10,350
there's another wonderful CSS feature

00:33:08,250 --> 00:33:14,160
that I haven't talked about yet just

00:33:10,350 --> 00:33:17,490
template so I'm gonna pass pass over to

00:33:14,160 --> 00:33:21,530
Dima and he's got about that yeah it's

00:33:17,490 --> 00:33:24,210
kind of doesn't add much to the like

00:33:21,530 --> 00:33:27,810
conceptual overall picture but it has

00:33:24,210 --> 00:33:29,250
some funny properties like if you open

00:33:27,810 --> 00:33:31,020
capital export window and to navigate

00:33:29,250 --> 00:33:35,820
you move your cursor around you might

00:33:31,020 --> 00:33:37,560
notice that the curly braces highlighted

00:33:35,820 --> 00:33:39,060
the magic utilize highlighted and the

00:33:37,560 --> 00:33:39,660
matching and go brackets I'm not

00:33:39,060 --> 00:33:41,190
highlighted

00:33:39,660 --> 00:33:43,080
well is it because there is another

00:33:41,190 --> 00:33:45,330
conflict obviously it because it's

00:33:43,080 --> 00:33:49,890
really hard to distinguish operator less

00:33:45,330 --> 00:33:52,410
or more from the from the angle brackets

00:33:49,890 --> 00:33:54,960
inside templates unless you again do all

00:33:52,410 --> 00:33:59,280
of that mode was just talking about it's

00:33:54,960 --> 00:34:01,710
a long and and then it was possible ivan

00:33:59,280 --> 00:34:03,900
eight seven like proper lexing of the

00:34:01,710 --> 00:34:06,750
source source code requires all semantic

00:34:03,900 --> 00:34:12,060
information you need you know worst case

00:34:06,750 --> 00:34:15,440
like how how exciting you that adhere

00:34:12,060 --> 00:34:21,929
actually template code has some

00:34:15,440 --> 00:34:23,280
surprising spreading property like you

00:34:21,929 --> 00:34:25,050
know that yesterday you still need to

00:34:23,280 --> 00:34:26,929
parse the coated side function templates

00:34:25,050 --> 00:34:29,220
for example and cross templates so you

00:34:26,929 --> 00:34:32,990
still need to build a step for them it's

00:34:29,220 --> 00:34:36,150
not a it's not a token soup anymore and

00:34:32,990 --> 00:34:38,040
how do you lose it because you don't you

00:34:36,150 --> 00:34:40,169
don't know anything about the dependent

00:34:38,040 --> 00:34:44,820
names when you do it so you have to put

00:34:40,169 --> 00:34:47,040
this kind of ugly these integrators

00:34:44,820 --> 00:34:49,020
before type names when you have a when

00:34:47,040 --> 00:34:51,030
you think you need a type name and

00:34:49,020 --> 00:34:54,330
before the templates when you know you

00:34:51,030 --> 00:34:56,730
have a template so it looks likely but

00:34:54,330 --> 00:34:58,530
it has a nice property that c++ code

00:34:56,730 --> 00:35:01,280
that consists only of dependent names is

00:34:58,530 --> 00:35:04,470
a subset of c++ that's easy to parse and

00:35:01,280 --> 00:35:08,000
it's easy for kind of easy for tooling

00:35:04,470 --> 00:35:10,920
and imagine if it was passed index was

00:35:08,000 --> 00:35:11,869
intimidated imagine if it would be nice

00:35:10,920 --> 00:35:14,869
and

00:35:11,869 --> 00:35:17,180
to work with so you don't in this case

00:35:14,869 --> 00:35:24,140
you also don't want me to have this like

00:35:17,180 --> 00:35:28,579
using bigger Gators okay so we're done

00:35:24,140 --> 00:35:30,259
with crazy examples and you need to talk

00:35:28,579 --> 00:35:34,549
a bit more in depth why does it matter

00:35:30,259 --> 00:35:35,960
you might say it was passed compiler

00:35:34,549 --> 00:35:38,480
implementers we would take care about

00:35:35,960 --> 00:35:39,190
that and we don't need to think about

00:35:38,480 --> 00:35:43,999
that

00:35:39,190 --> 00:35:46,279
what still doesn't matter for for like

00:35:43,999 --> 00:35:48,440
every day it was bad realtor because

00:35:46,279 --> 00:35:50,779
like for compilers it's kind of a minor

00:35:48,440 --> 00:35:52,670
problems there are more difficult

00:35:50,779 --> 00:35:54,259
problem I will next show why it still

00:35:52,670 --> 00:35:56,890
matters for the compilers for the users

00:35:54,259 --> 00:36:00,559
with them but it's kind of doable but

00:35:56,890 --> 00:36:05,240
this means that every tool has either to

00:36:00,559 --> 00:36:08,299
depend on a compiler or to be as be as

00:36:05,240 --> 00:36:16,190
complicated as a compiler which is crazy

00:36:08,299 --> 00:36:17,779
and or it could also don't work so it's

00:36:16,190 --> 00:36:19,819
not exactly healthy like for the

00:36:17,779 --> 00:36:24,700
assistant because you can hack something

00:36:19,819 --> 00:36:27,049
around and can't be done and so you are

00:36:24,700 --> 00:36:29,809
to do a proper to linking for example

00:36:27,049 --> 00:36:32,359
need to first compile your code with the

00:36:29,809 --> 00:36:34,910
compiler you want to use with with this

00:36:32,359 --> 00:36:36,559
tool and it's not always possible for

00:36:34,910 --> 00:36:38,239
example if you some temporary extensions

00:36:36,559 --> 00:36:44,299
some lesser-known

00:36:38,239 --> 00:36:48,009
so on but for the actual compilers it's

00:36:44,299 --> 00:36:50,499
also matters because a good compiler is

00:36:48,009 --> 00:36:53,900
also showing good error messages and

00:36:50,499 --> 00:36:55,910
it's more it's more art than science

00:36:53,900 --> 00:36:58,190
because like it is nothing in standard

00:36:55,910 --> 00:36:59,690
or anything else about how to show the

00:36:58,190 --> 00:37:01,609
show error message how to recover from

00:36:59,690 --> 00:37:06,980
it the compiler must guess the

00:37:01,609 --> 00:37:09,019
programmers intent and it idiot must

00:37:06,980 --> 00:37:11,569
point out why this code is so formed and

00:37:09,019 --> 00:37:13,069
where is the error and it should

00:37:11,569 --> 00:37:14,799
probably recover and continue a person

00:37:13,069 --> 00:37:17,329
because like it's important for the

00:37:14,799 --> 00:37:18,480
developer experience it's important for

00:37:17,329 --> 00:37:22,549
to link

00:37:18,480 --> 00:37:25,460
and because you have an ambiguous syntax

00:37:22,549 --> 00:37:27,900
guessing what's what was mean by by the

00:37:25,460 --> 00:37:30,990
programmers also it's also hard for

00:37:27,900 --> 00:37:34,019
example take this view here's an example

00:37:30,990 --> 00:37:36,660
where you accidentally skip a semicolon

00:37:34,019 --> 00:37:40,490
after a cross definition and then you

00:37:36,660 --> 00:37:43,200
use use its name in the declaration so

00:37:40,490 --> 00:37:47,069
these lines might be in subsequent

00:37:43,200 --> 00:37:50,700
include header files and you might even

00:37:47,069 --> 00:37:53,789
not realize the subsequent so let's take

00:37:50,700 --> 00:37:56,630
a two major compilers one of it says

00:37:53,789 --> 00:38:00,630
like semicolon as expected after day

00:37:56,630 --> 00:38:02,130
after the classifications kind of what

00:38:00,630 --> 00:38:06,329
to expect from the compiler to say to us

00:38:02,130 --> 00:38:09,269
but then other one says oh I didn't

00:38:06,329 --> 00:38:11,339
expect before X and if you think about

00:38:09,269 --> 00:38:15,329
it it kind of makes sense that it's

00:38:11,339 --> 00:38:17,609
doing because it's is resti okay then

00:38:15,329 --> 00:38:19,710
it's is C so it's Inc it's probably a

00:38:17,609 --> 00:38:22,380
variable of the type class see something

00:38:19,710 --> 00:38:24,779
it don't make sense then this X and X is

00:38:22,380 --> 00:38:28,470
not allowed so it has to be almost

00:38:24,779 --> 00:38:30,720
something and it says the obvious things

00:38:28,470 --> 00:38:32,339
that say and I know I'm super excited I

00:38:30,720 --> 00:38:37,579
know how to fix that we can put an extra

00:38:32,339 --> 00:38:40,200
per an hour on to initialize yeah and

00:38:37,579 --> 00:38:42,660
actually ever think like it's because

00:38:40,200 --> 00:38:44,130
the declaration syntax in C++ is worst

00:38:42,660 --> 00:38:46,230
and you can't easily tell apart the

00:38:44,130 --> 00:38:47,279
decorate declaration of a variable from

00:38:46,230 --> 00:38:49,559
like something else

00:38:47,279 --> 00:38:51,509
and I was saying okay most of our

00:38:49,559 --> 00:38:54,750
languages don't have this problem

00:38:51,509 --> 00:38:57,240
because like it's obvious when variables

00:38:54,750 --> 00:39:01,230
declared so let's do something like that

00:38:57,240 --> 00:39:03,180
let's use the almost always auto and it

00:39:01,230 --> 00:39:06,119
should sure it would be the for second

00:39:03,180 --> 00:39:09,210
party end because like it's not a

00:39:06,119 --> 00:39:11,039
variable name anymore so I was sure that

00:39:09,210 --> 00:39:13,140
it would help help things I put it in

00:39:11,039 --> 00:39:17,480
the slide I then I put it in the

00:39:13,140 --> 00:39:17,480
compiler exported around and I got this

00:39:17,690 --> 00:39:24,910
says that I know how well the error

00:39:22,640 --> 00:39:27,530
messages got worse even in both scales

00:39:24,910 --> 00:39:30,350
now in most cases hit point was their

00:39:27,530 --> 00:39:33,310
incorrect line and it doesn't make any

00:39:30,350 --> 00:39:36,410
sense because like this author is

00:39:33,310 --> 00:39:38,690
grating some of the past things it's not

00:39:36,410 --> 00:39:41,450
only what like a Auto variable it's also

00:39:38,690 --> 00:39:44,180
types it specified and probably use it

00:39:41,450 --> 00:39:46,760
like that anymore like I'm sorry the

00:39:44,180 --> 00:39:50,260
storage class spits fire but it still

00:39:46,760 --> 00:39:54,710
exists and you see that this compiler

00:39:50,260 --> 00:39:56,600
doesn't have this special case code for

00:39:54,710 --> 00:39:59,780
this specifically like it did in the

00:39:56,600 --> 00:40:02,540
previous example and here is a similar

00:39:59,780 --> 00:40:05,390
example like zero to another two major

00:40:02,540 --> 00:40:09,440
compilers and there is a type in a type

00:40:05,390 --> 00:40:11,810
name so one of it says okay so you have

00:40:09,440 --> 00:40:16,090
a typo in your type name maybe you want

00:40:11,810 --> 00:40:19,400
to fix it but another I'll say something

00:40:16,090 --> 00:40:21,110
different well it is a undeclared can

00:40:19,400 --> 00:40:25,070
data file what could it be things the

00:40:21,110 --> 00:40:27,320
compiler it could be the like it's not

00:40:25,070 --> 00:40:30,860
the type it's not anything maybe it's a

00:40:27,320 --> 00:40:33,740
declaration with an emitter type

00:40:30,860 --> 00:40:36,290
specifier which is default in things in

00:40:33,740 --> 00:40:38,930
C ok let's come with this let's like

00:40:36,290 --> 00:40:41,530
recover like this but hmm in C++ is not

00:40:38,930 --> 00:40:45,800
a lot so let's diagnose this thing and

00:40:41,530 --> 00:40:48,440
okay but this is a variable of type int

00:40:45,800 --> 00:40:50,420
then this is again the X it's not

00:40:48,440 --> 00:40:54,860
allowed so probably a semicolon is

00:40:50,420 --> 00:40:56,150
recorded between them so that would

00:40:54,860 --> 00:40:58,190
happen when you have an ambiguous

00:40:56,150 --> 00:41:00,710
language is it fixable

00:40:58,190 --> 00:41:02,570
yes it's fixable you can take each one

00:41:00,710 --> 00:41:04,610
of these examples and fix it

00:41:02,570 --> 00:41:06,800
that's what compiler autos are doing

00:41:04,610 --> 00:41:14,690
with the new version but it's a

00:41:06,800 --> 00:41:17,510
complicated and it's yeah and my final

00:41:14,690 --> 00:41:20,210
example is actually heated several times

00:41:17,510 --> 00:41:23,660
like when a program in suppose passing

00:41:20,210 --> 00:41:26,660
an ID is it used claim for error

00:41:23,660 --> 00:41:28,970
messages so you have this function you

00:41:26,660 --> 00:41:31,250
have this lambda and you forget

00:41:28,970 --> 00:41:34,190
capture it capture one of the variables

00:41:31,250 --> 00:41:37,310
and compiler says okay so the variable

00:41:34,190 --> 00:41:39,500
is can be captured Samsung LED and you

00:41:37,310 --> 00:41:43,670
go to the capture list and start to

00:41:39,500 --> 00:41:47,869
capture it and then like hell broke

00:41:43,670 --> 00:41:49,310
loose and it says something about extra

00:41:47,869 --> 00:41:51,530
closing rate and so on and so what's

00:41:49,310 --> 00:41:54,109
more annoying you don't get get your

00:41:51,530 --> 00:41:56,840
initial error message anymore and if you

00:41:54,109 --> 00:42:01,070
forgot what was that variable you kind

00:41:56,840 --> 00:42:05,030
of need to go back and check it again

00:42:01,070 --> 00:42:08,270
and that's actually because the square

00:42:05,030 --> 00:42:11,570
brackets are heart and you know if you

00:42:08,270 --> 00:42:14,150
take all the dialects which Clank

00:42:11,570 --> 00:42:16,790
supports its and very very ambiguous

00:42:14,150 --> 00:42:18,260
things that it can be attributed it can

00:42:16,790 --> 00:42:20,570
be Microsoft Visual Studio style

00:42:18,260 --> 00:42:22,310
attribute that has only one square

00:42:20,570 --> 00:42:25,700
bracket where we can with this objective

00:42:22,310 --> 00:42:27,230
c / c++ and message it also starts with

00:42:25,700 --> 00:42:30,680
two and go bracket as two square

00:42:27,230 --> 00:42:33,680
brackets and so it kind of tries to play

00:42:30,680 --> 00:42:36,950
safe and it doesn't look like that so

00:42:33,680 --> 00:42:40,119
okay let's look still formed and there

00:42:36,950 --> 00:42:42,950
is square beta here i don't care i

00:42:40,119 --> 00:42:45,940
probably skip something in case it's

00:42:42,950 --> 00:42:51,230
lambda and i recover in in this point

00:42:45,940 --> 00:42:53,510
well it doesn't work too well and it

00:42:51,230 --> 00:42:55,040
specially doesn't work too well like if

00:42:53,510 --> 00:42:58,820
you can see this not as a compiler

00:42:55,040 --> 00:43:03,740
output but if you can see as a error

00:42:58,820 --> 00:43:05,170
highlighting key editor and yeah so what

00:43:03,740 --> 00:43:08,869
we're going to do about it

00:43:05,170 --> 00:43:12,560
first is don't panic it's still kind of

00:43:08,869 --> 00:43:17,480
a kid like compiler artists tend to to

00:43:12,560 --> 00:43:21,410
Otto's try hard to to Chile Chile from

00:43:17,480 --> 00:43:24,080
all these problems but if you look at

00:43:21,410 --> 00:43:26,390
these examples and if you think like

00:43:24,080 --> 00:43:28,369
it's resonate with me okay I feel the

00:43:26,390 --> 00:43:30,380
pain you probably want to write simpler

00:43:28,369 --> 00:43:34,550
code because like all of it can be

00:43:30,380 --> 00:43:38,500
avoided quite easily in but what's

00:43:34,550 --> 00:43:38,500
important that when

00:43:38,579 --> 00:43:44,049
when invented here features and for the

00:43:41,739 --> 00:43:46,059
language and when some people say ok I

00:43:44,049 --> 00:43:47,619
have this real-world problem that I want

00:43:46,059 --> 00:43:50,380
to invent this syntax for this problem

00:43:47,619 --> 00:43:52,420
you might want to consider not only if

00:43:50,380 --> 00:43:54,549
it's theoretically implementable in any

00:43:52,420 --> 00:43:58,180
way but you want to also consider how

00:43:54,549 --> 00:43:59,920
its affect the error messages how its

00:43:58,180 --> 00:44:01,869
fix it to link or its effects like some

00:43:59,920 --> 00:44:04,180
number tools that's not yet dependent

00:44:01,869 --> 00:44:06,430
compiler yes actually this is something

00:44:04,180 --> 00:44:08,349
I think every time I certainly WG and

00:44:06,430 --> 00:44:09,910
something someone you know proposes a

00:44:08,349 --> 00:44:11,410
crazy new syntax for that's cool new

00:44:09,910 --> 00:44:13,029
feature that I'm like oh this could be

00:44:11,410 --> 00:44:15,309
really cool for our users but then I

00:44:13,029 --> 00:44:17,650
also think oh but then what what is it

00:44:15,309 --> 00:44:20,339
going to break you know it's kind of

00:44:17,650 --> 00:44:25,420
always these two two things that kind of

00:44:20,339 --> 00:44:28,930
collide in tirana fine I think that we

00:44:25,420 --> 00:44:31,210
never had a chance to clean up some some

00:44:28,930 --> 00:44:34,029
old rusty Selix from City laws because

00:44:31,210 --> 00:44:38,410
again the code reuse was preprocessor

00:44:34,029 --> 00:44:40,390
based and we just can can't remove

00:44:38,410 --> 00:44:41,769
anything we can change a meaning of

00:44:40,390 --> 00:44:45,430
anything without breaking the old code

00:44:41,769 --> 00:44:48,849
but maybe when we when we get modules

00:44:45,430 --> 00:44:51,309
and when they are adopted you can

00:44:48,849 --> 00:44:55,349
compare separated old legacy code and

00:44:51,309 --> 00:44:58,210
then you cause you're writing and maybe

00:44:55,349 --> 00:45:03,930
then you can start cleaning up and

00:44:58,210 --> 00:45:03,930
removing stuff so I think that is who

00:45:04,380 --> 00:45:13,520
asked us questions

00:45:06,390 --> 00:45:13,520
[Applause]

00:45:18,030 --> 00:45:23,530
hi thank you for the presentation at you

00:45:20,950 --> 00:45:25,900
guys said that um it is time like a

00:45:23,530 --> 00:45:26,560
cleanup of the syntax of the language

00:45:25,900 --> 00:45:29,980
right

00:45:26,560 --> 00:45:32,440
I had thought for a long time that maybe

00:45:29,980 --> 00:45:33,820
what is needed is a second version of

00:45:32,440 --> 00:45:35,770
the syntax for the whole language

00:45:33,820 --> 00:45:40,210
something that makes sense it is easy

00:45:35,770 --> 00:45:42,910
for the tools and he can be cleaned

00:45:40,210 --> 00:45:44,620
would you agree with that well the

00:45:42,910 --> 00:45:46,630
important things that you still have to

00:45:44,620 --> 00:45:48,370
maintain the full backward compatibility

00:45:46,630 --> 00:45:51,310
because it's the thing that keeps across

00:45:48,370 --> 00:45:53,950
the float probably and so if you just

00:45:51,310 --> 00:45:56,860
use if you just break header since they

00:45:53,950 --> 00:45:58,900
don't compile anymore you can't clean it

00:45:56,860 --> 00:46:01,990
up and nobody will use and use the new

00:45:58,900 --> 00:46:05,380
version so you have to just use old code

00:46:01,990 --> 00:46:08,470
with the new one and I think modules

00:46:05,380 --> 00:46:15,460
will give a really good chance to do

00:46:08,470 --> 00:46:17,140
that but not before all right so you

00:46:15,460 --> 00:46:19,090
mentioned in your talk that this really

00:46:17,140 --> 00:46:21,460
nasty challenging problem is something

00:46:19,090 --> 00:46:24,160
that each tool needs to solve on their

00:46:21,460 --> 00:46:28,720
own I was wondering if there is any

00:46:24,160 --> 00:46:30,460
attempt to make like a generic c++ parts

00:46:28,720 --> 00:46:32,950
here that spits out some sort of you

00:46:30,460 --> 00:46:36,130
know defined ast that everyone could use

00:46:32,950 --> 00:46:38,740
I don't like clang as well I mean clang

00:46:36,130 --> 00:46:42,820
ast is kind of the industry becoming the

00:46:38,740 --> 00:46:44,590
industry standard in some areas but yeah

00:46:42,820 --> 00:46:46,060
I don't know like I mean there are there

00:46:44,590 --> 00:46:48,190
are things are going a little bit into

00:46:46,060 --> 00:46:49,960
this direction like for example you know

00:46:48,190 --> 00:46:52,240
if you follow if you hold all the work

00:46:49,960 --> 00:46:55,210
what reflection it has some of the

00:46:52,240 --> 00:46:58,270
elements where you have you know certain

00:46:55,210 --> 00:47:00,430
hooks into the ast which are kind of not

00:46:58,270 --> 00:47:02,470
depending on the compiler but something

00:47:00,430 --> 00:47:05,800
like the whole paws are making the whole

00:47:02,470 --> 00:47:07,750
paws are kind of implementation

00:47:05,800 --> 00:47:09,370
independent or like standardized I don't

00:47:07,750 --> 00:47:11,920
think it's you work because you know we

00:47:09,370 --> 00:47:14,050
have several major implementations which

00:47:11,920 --> 00:47:16,750
been around for a while and they work

00:47:14,050 --> 00:47:18,850
the way they work and I I don't know

00:47:16,750 --> 00:47:21,130
like what what problem would be solved

00:47:18,850 --> 00:47:23,380
by that like I'm not sure egg and get it

00:47:21,130 --> 00:47:25,120
and I don't know something like you know

00:47:23,380 --> 00:47:27,460
if you're writing an IDE or if you're at

00:47:25,120 --> 00:47:29,980
incline format you want the same thing

00:47:27,460 --> 00:47:31,900
at your parser well I mean a lot of

00:47:29,980 --> 00:47:35,530
tools they built on you know the clang

00:47:31,900 --> 00:47:37,720
honesty for example so yeah so it kind

00:47:35,530 --> 00:47:39,430
of shows a problem because like you

00:47:37,720 --> 00:47:41,380
might say that you just use a clang

00:47:39,430 --> 00:47:43,360
caste and be done with it but even for

00:47:41,380 --> 00:47:45,040
formatting like crank format doesn't use

00:47:43,360 --> 00:47:47,410
clang pasty it's because it's own parts

00:47:45,040 --> 00:47:48,880
that witch who is a bunch of it doesn't

00:47:47,410 --> 00:47:51,430
look inside haters and has a bunch of

00:47:48,880 --> 00:47:53,710
heuristics so even that shows that you

00:47:51,430 --> 00:47:55,690
have you want to have different like

00:47:53,710 --> 00:47:57,640
parsers for different tasks right so

00:47:55,690 --> 00:47:59,860
yeah I there is no one one fits all

00:47:57,640 --> 00:48:03,850
solution for basically either you have

00:47:59,860 --> 00:48:06,460
to kind of build on top of some of the

00:48:03,850 --> 00:48:08,470
implementations that exist or you have

00:48:06,460 --> 00:48:09,730
to like build something completely from

00:48:08,470 --> 00:48:11,560
scratch which is probably not going to

00:48:09,730 --> 00:48:14,800
work properly and gonna be very limited

00:48:11,560 --> 00:48:16,030
and what it can do so yeah it's it's a I

00:48:14,800 --> 00:48:18,580
think it's a big problem for the kind of

00:48:16,030 --> 00:48:21,880
C++ ecosystem but I don't have a

00:48:18,580 --> 00:48:26,650
solution and anyone has a solution that

00:48:21,880 --> 00:48:29,260
would be will be great so despite all

00:48:26,650 --> 00:48:32,200
the trouble of preprocessor likes to

00:48:29,260 --> 00:48:34,690
give us include they include a

00:48:32,200 --> 00:48:36,970
preprocessor directive is still just

00:48:34,690 --> 00:48:38,740
ultimately a copy-paste mechanism so

00:48:36,970 --> 00:48:41,410
whenever there's a part of the code

00:48:38,740 --> 00:48:46,510
we're parsing and we need to that depend

00:48:41,410 --> 00:48:47,950
whose result depends on other code at

00:48:46,510 --> 00:48:50,620
least we're guaranteed

00:48:47,950 --> 00:48:52,630
according to valid program rules that

00:48:50,620 --> 00:48:56,080
the other code is somewhere up there

00:48:52,630 --> 00:48:59,260
that was included due to declaration or

00:48:56,080 --> 00:49:01,240
definition rules but once modules comes

00:48:59,260 --> 00:49:03,520
in that won't be the case anymore

00:49:01,240 --> 00:49:05,620
I'm curious how modules could actually

00:49:03,520 --> 00:49:07,720
help improve the situation as opposed to

00:49:05,620 --> 00:49:09,870
complicating it with that in that

00:49:07,720 --> 00:49:09,870
respect

00:49:10,170 --> 00:49:17,560
yeah well if you look at a it's a

00:49:15,370 --> 00:49:19,540
technical problem because well you need

00:49:17,560 --> 00:49:22,300
to build a graphic depends with modules

00:49:19,540 --> 00:49:24,790
but it it's should be doable because

00:49:22,300 --> 00:49:26,650
otherwise no tools would work and as you

00:49:24,790 --> 00:49:28,270
as you build a graph of dependencies

00:49:26,650 --> 00:49:31,630
it's a second graph and you can just

00:49:28,270 --> 00:49:34,839
walk it walk it and parse it one by one

00:49:31,630 --> 00:49:37,479
and for the for the include direct

00:49:34,839 --> 00:49:39,609
direct if it's it's not usually the case

00:49:37,479 --> 00:49:41,349
because like you know some quadrant

00:49:39,609 --> 00:49:43,479
cases you can have like include

00:49:41,349 --> 00:49:45,999
directive inside the method but it it

00:49:43,479 --> 00:49:47,890
depends on the tokens that the bill

00:49:45,999 --> 00:49:53,349
technical below and the file but say in

00:49:47,890 --> 00:49:55,239
the class declaration so I think modules

00:49:53,349 --> 00:49:56,499
are you know solving some problems like

00:49:55,239 --> 00:49:57,999
you're not going to have to deal with

00:49:56,499 --> 00:50:00,069
the complicated and cute graph anymore

00:49:57,999 --> 00:50:01,869
but I was creating other problems for

00:50:00,069 --> 00:50:04,779
tooling so there's some stuff that's on

00:50:01,869 --> 00:50:06,849
our minds you know in these days that

00:50:04,779 --> 00:50:07,900
you know as we saw in order to pass

00:50:06,849 --> 00:50:09,940
something you need to know what an

00:50:07,900 --> 00:50:11,650
identifier means and then you know you

00:50:09,940 --> 00:50:14,380
potentially get that from a module but

00:50:11,650 --> 00:50:18,279
then module might be just you know kind

00:50:14,380 --> 00:50:20,499
of module you know use this module and

00:50:18,279 --> 00:50:23,289
then the module might be in some kind of

00:50:20,499 --> 00:50:25,170
binary format whatever and then you have

00:50:23,289 --> 00:50:27,940
to either pass that or figure out

00:50:25,170 --> 00:50:29,769
where's the code that this came from and

00:50:27,940 --> 00:50:31,599
how was that built because you also need

00:50:29,769 --> 00:50:32,890
you know compiler flags and things like

00:50:31,599 --> 00:50:34,420
that to you know be able to properly

00:50:32,890 --> 00:50:36,339
evaluate macros and you don't have this

00:50:34,420 --> 00:50:38,739
information and the kind of precompiled

00:50:36,339 --> 00:50:40,299
module so how do how does that how is

00:50:38,739 --> 00:50:42,579
this even going to suppose to work for

00:50:40,299 --> 00:50:44,979
like the tuning ecosystem and the

00:50:42,579 --> 00:50:46,809
standard doesn't say like the modules TS

00:50:44,979 --> 00:50:48,579
don't say like people on the committee

00:50:46,809 --> 00:50:52,449
say well we don't care this is all set

00:50:48,579 --> 00:50:53,410
of the standard so yeah I mean there's a

00:50:52,449 --> 00:50:56,199
lot to think about here this is

00:50:53,410 --> 00:51:00,219
definitely something that's it's on our

00:50:56,199 --> 00:51:02,049
mind but yeah yeah I also want to like

00:51:00,219 --> 00:51:05,739
it sounds a bit about that because

00:51:02,049 --> 00:51:08,769
conceptually what at least several major

00:51:05,739 --> 00:51:10,869
major like IDs which aims to be

00:51:08,769 --> 00:51:14,410
feature-rich but doesn't use compilers

00:51:10,869 --> 00:51:19,150
are doing it's like well it is that at

00:51:14,410 --> 00:51:21,789
least all of them all of them is that

00:51:19,150 --> 00:51:24,190
they take a header and then they try to

00:51:21,789 --> 00:51:26,079
detect if it's like a well-formed hitter

00:51:24,190 --> 00:51:29,529
that includes like in the top level ends

00:51:26,079 --> 00:51:33,190
it just doesn't affect other ones so

00:51:29,529 --> 00:51:35,259
much and it just and sees what people

00:51:33,190 --> 00:51:38,289
says our state it's left left after it

00:51:35,259 --> 00:51:40,400
and then it kind of treated like a

00:51:38,289 --> 00:51:43,760
module anyway

00:51:40,400 --> 00:51:45,380
to be able to like quick castle like

00:51:43,760 --> 00:51:47,990
quick indexing and quick personal

00:51:45,380 --> 00:51:50,210
project so when proper module select

00:51:47,990 --> 00:51:53,150
arrive at least this would not be

00:51:50,210 --> 00:51:55,030
required and it would be a big win for

00:51:53,150 --> 00:52:00,170
the tool

00:51:55,030 --> 00:52:04,640
okay thank you just a quick comment have

00:52:00,170 --> 00:52:06,890
used tools that generate C++ and macros

00:52:04,640 --> 00:52:10,700
made by other people and even myself

00:52:06,890 --> 00:52:15,140
that are very hard to make that generate

00:52:10,700 --> 00:52:17,990
very very weird code and it's great that

00:52:15,140 --> 00:52:20,060
all a a lot of people do a great effort

00:52:17,990 --> 00:52:22,700
on supporting the language high cities

00:52:20,060 --> 00:52:25,820
and disambiguating all the stuff but

00:52:22,700 --> 00:52:27,740
just to let you know that an ambiguity

00:52:25,820 --> 00:52:31,670
of the extra parentheses I have

00:52:27,740 --> 00:52:34,850
experienced it in same expanding macros

00:52:31,670 --> 00:52:37,130
because macros try to protect against

00:52:34,850 --> 00:52:41,600
side effects and they put things within

00:52:37,130 --> 00:52:45,350
parentheses and that check so I I hope

00:52:41,600 --> 00:52:48,020
that a tool like the ones that Jay

00:52:45,350 --> 00:52:51,560
trains a work on like a sea lion can

00:52:48,020 --> 00:52:55,910
help people to deal with those weirdness

00:52:51,560 --> 00:52:57,680
of interest thank you okay thank you any

00:52:55,910 --> 00:52:59,050
more questions you still have a couple

00:52:57,680 --> 00:53:03,740
minutes left

00:52:59,050 --> 00:53:06,320
all right I see none so thanks again for

00:53:03,740 --> 00:53:12,809
listening and

00:53:06,320 --> 00:53:12,809

YouTube URL: https://www.youtube.com/watch?v=WfIr7lKT4Sk


