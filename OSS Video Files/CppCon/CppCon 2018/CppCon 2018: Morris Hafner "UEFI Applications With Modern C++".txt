Title: CppCon 2018: Morris Hafner "UEFI Applications With Modern C++"
Publication date: 2018-10-12
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Inside of every PC, there is an environment capable of running arbitrary software without an operating system: The Unified Extensible Firmware Interface, or UEFI. Introduced to replace BIOS as a high-level interface between hardware and the kernel, it features many advanced features such as networking right after pressing the power button of your mainboard with a relatively simple C API. 
In this session, we explore how we can apply modern C++ idioms to a bare metal environment like UEFI. Armed with a working modern C++ compiler, we'll wrap the C API with some metaprogramming tricks. This grants us better type safety and a cleaner API with no runtime overhead. Along the way we'll introduce a clean exceptionless error-handling method, and finally write a small demo application. 
Finally, we look at the some of the proposals for the next C++ standard and how it helps us writing more concise yet efficient code that is sill conformant.
— 
Morris Hafner, Codeplay Software
Software Engineer

Morris is a Computer Science undergrad interested in computer graphics, the evolution of C++ and everything low level.
He tries to (ab)use the language and its tooling to prevent mistakes in software while keeping the code as general as possible.
On the GPU, he likes to play with shaders, lighting and bending the graphics pipeline.
When he is not programming, he enjoys travelling and watching movies.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,139 --> 00:00:07,560
welcome everyone to my talk on writing

00:00:03,859 --> 00:00:11,220
UEFI applications with C++ or more in

00:00:07,560 --> 00:00:16,199
C++ my name is Martha

00:00:11,220 --> 00:00:19,289
I moved from Germany to Scotland to eat

00:00:16,199 --> 00:00:21,269
haggis and work on compilers I'm a

00:00:19,289 --> 00:00:24,060
software engineer at help a software

00:00:21,269 --> 00:00:26,339
where I work on sickle the feminist Anna

00:00:24,060 --> 00:00:28,439
for heat Regina's programming for C++

00:00:26,339 --> 00:00:29,810
I'm also a post-grad student at the

00:00:28,439 --> 00:00:32,009
University of Edinburgh and

00:00:29,810 --> 00:00:34,530
unfortunately also have a tendency to

00:00:32,009 --> 00:00:37,980
break compilers debuggers linkers pretty

00:00:34,530 --> 00:00:39,840
much you name it and I like to say that

00:00:37,980 --> 00:00:42,000
it's a curse but it's probably also

00:00:39,840 --> 00:00:43,350
because I want to do fairly solid things

00:00:42,000 --> 00:00:45,840
like trying to make more than C

00:00:43,350 --> 00:00:51,120
must-pass happen on exonic platforms

00:00:45,840 --> 00:00:53,250
like UEFI so what is UEFI it stands for

00:00:51,120 --> 00:00:55,710
unified extensible firmware interface

00:00:53,250 --> 00:00:58,860
and it's meant to be the replacement for

00:00:55,710 --> 00:01:00,630
bias on the PC platform so it was

00:00:58,860 --> 00:01:02,580
initially developed for the

00:01:00,630 --> 00:01:04,769
entertainment platform in the 90s and

00:01:02,580 --> 00:01:06,570
you all know how that went down but the

00:01:04,769 --> 00:01:08,640
technology was real was reused for x86

00:01:06,570 --> 00:01:12,749
and can also be used for arm and respite

00:01:08,640 --> 00:01:14,609
based computers it has many more

00:01:12,749 --> 00:01:16,859
features compared to bias you have

00:01:14,609 --> 00:01:18,539
network access you have secured what's

00:01:16,859 --> 00:01:19,979
quite controversial and the learners

00:01:18,539 --> 00:01:21,929
community

00:01:19,979 --> 00:01:24,030
you also have non-volatile Ram there's

00:01:21,929 --> 00:01:25,770
even an byte code specification if you

00:01:24,030 --> 00:01:28,380
want to share application code between

00:01:25,770 --> 00:01:30,030
different CPU architectures but the most

00:01:28,380 --> 00:01:32,159
interesting thing about you if I

00:01:30,030 --> 00:01:34,020
compared to bias is that they don't need

00:01:32,159 --> 00:01:36,539
to write as much assembler code anymore

00:01:34,020 --> 00:01:38,520
so can I give a short hand who has

00:01:36,539 --> 00:01:42,060
written code for bias maybe a boot

00:01:38,520 --> 00:01:43,829
loader or kernel a couple of people so

00:01:42,060 --> 00:01:48,329
you might all be familiar with this

00:01:43,829 --> 00:01:50,429
there so the bias was English was the

00:01:48,329 --> 00:01:53,609
initialization system so to speak for

00:01:50,429 --> 00:01:55,920
the original IBM PC and what happens

00:01:53,609 --> 00:01:58,979
what happens if you press the power

00:01:55,920 --> 00:02:00,600
button until you is that it is does some

00:01:58,979 --> 00:02:02,880
very basic initialization on your on

00:02:00,600 --> 00:02:05,369
your main board then loads the first 512

00:02:02,880 --> 00:02:06,869
bytes of code from the Master Boot

00:02:05,369 --> 00:02:09,979
Record jumps to the some specific

00:02:06,869 --> 00:02:12,380
address and then your on Yoda and

00:02:09,979 --> 00:02:14,720
things very even very basic things like

00:02:12,380 --> 00:02:16,430
switching from the 16-bit no to 32-bit

00:02:14,720 --> 00:02:17,959
mode to 64-bit mode and so on you have

00:02:16,430 --> 00:02:19,940
to do it yourself and this obviously

00:02:17,959 --> 00:02:22,430
will require assembly covers because

00:02:19,940 --> 00:02:27,709
switching just 32 with no distance count

00:02:22,430 --> 00:02:30,170
by the C language so it is much more

00:02:27,709 --> 00:02:31,610
lower level and you have to call you

00:02:30,170 --> 00:02:33,140
have to call it interrupts instead of

00:02:31,610 --> 00:02:36,890
having proper function it's like you

00:02:33,140 --> 00:02:39,590
have in if I so if I executables are

00:02:36,890 --> 00:02:41,360
just binaries on some factory to

00:02:39,590 --> 00:02:44,390
partition with a very specific file

00:02:41,360 --> 00:02:45,800
system code as you can already see was

00:02:44,390 --> 00:02:47,680
heavily influenced by Microsoft doing

00:02:45,800 --> 00:02:50,720
standardization because it uses the same

00:02:47,680 --> 00:02:52,580
binary format as Microsoft Windows it

00:02:50,720 --> 00:02:54,200
uses the same calling convention as much

00:02:52,580 --> 00:02:55,910
as Windows and unfortunately also used

00:02:54,200 --> 00:02:59,780
it has 16 strengths and strings which

00:02:55,910 --> 00:03:01,670
calls a headache and when you press the

00:02:59,780 --> 00:03:03,500
power button on pretty much every PC

00:03:01,670 --> 00:03:07,340
here in this very room including Mac

00:03:03,500 --> 00:03:10,070
books it does some initialization of

00:03:07,340 --> 00:03:13,220
your hardware like bias but then doesn't

00:03:10,070 --> 00:03:14,930
move junk to some address but largest in

00:03:13,220 --> 00:03:20,120
executable which is usually located in

00:03:14,930 --> 00:03:21,440
if I slash food / root x64 efi so this

00:03:20,120 --> 00:03:23,600
is usually the case you may change the

00:03:21,440 --> 00:03:25,430
default you may also have to deal with

00:03:23,600 --> 00:03:27,320
broken permutations like the one on my

00:03:25,430 --> 00:03:28,820
laptop here which is hot girls apart to

00:03:27,320 --> 00:03:31,370
Windows boot loader and this is an

00:03:28,820 --> 00:03:36,320
interesting exercise I want to it so

00:03:31,370 --> 00:03:39,230
Linux on this machine so how do we get

00:03:36,320 --> 00:03:41,120
an executable to run on this platform so

00:03:39,230 --> 00:03:45,320
first of all we're going to need some

00:03:41,120 --> 00:03:47,570
kind of tool chain if you can so the

00:03:45,320 --> 00:03:50,120
thing you usually want to use is the

00:03:47,570 --> 00:03:51,769
tonic or et k2 which is just a truly

00:03:50,120 --> 00:03:52,640
massive framework and contains function

00:03:51,769 --> 00:03:55,070
for all kinds of things

00:03:52,640 --> 00:03:56,239
it even has a port of Python 2 so if you

00:03:55,070 --> 00:04:00,140
want to run Python 2 without an

00:03:56,239 --> 00:04:01,760
operating system download a TK 2 but I

00:04:00,140 --> 00:04:01,970
want you to have something simpler than

00:04:01,760 --> 00:04:05,239
that

00:04:01,970 --> 00:04:06,470
you can so I went with a video EF I load

00:04:05,239 --> 00:04:10,250
which is pretty much just a set of

00:04:06,470 --> 00:04:13,640
headers a static library linker scripts

00:04:10,250 --> 00:04:18,590
and some basic functionality for certain

00:04:13,640 --> 00:04:22,310
C language features in the CRT 0 as for

00:04:18,590 --> 00:04:22,840
compilers you can use em SVC I am going

00:04:22,310 --> 00:04:26,050
to use

00:04:22,840 --> 00:04:27,460
mingw GCC but you cannot use climb if

00:04:26,050 --> 00:04:29,290
you try to use climb you get a nice

00:04:27,460 --> 00:04:32,700
error message saying that freestanding

00:04:29,290 --> 00:04:35,139
cough executables are not supported and

00:04:32,700 --> 00:04:42,160
you get a nice intro compiler or

00:04:35,139 --> 00:04:44,410
afterwards so the standard library so we

00:04:42,160 --> 00:04:45,790
have an SDK we have three two we have a

00:04:44,410 --> 00:04:48,100
compiler now we have a standard library

00:04:45,790 --> 00:04:49,900
or we need a stand library unfortunately

00:04:48,100 --> 00:04:52,450
we don't have one

00:04:49,900 --> 00:04:54,850
the etk to ships with an implementation

00:04:52,450 --> 00:04:56,500
of the c95 stand-alone which is pretty

00:04:54,850 --> 00:05:00,040
much just the scene idyllic library with

00:04:56,500 --> 00:05:04,120
some bug fixes and the iso six for six

00:05:00,040 --> 00:05:06,100
keywords so and or hit and and so on but

00:05:04,120 --> 00:05:08,800
we also don't have a sea pakistan an ID

00:05:06,100 --> 00:05:10,780
so things like operator new dynamic

00:05:08,800 --> 00:05:14,620
passed our TTI everything that requires

00:05:10,780 --> 00:05:17,380
runtime support is just off the table in

00:05:14,620 --> 00:05:19,479
practice and this is very very happy we

00:05:17,380 --> 00:05:21,190
can we still reuse things from our hosts

00:05:19,479 --> 00:05:22,960
of implementations like state areas the

00:05:21,190 --> 00:05:24,729
tuple or the type trades because those

00:05:22,960 --> 00:05:27,729
are just compile time construct that

00:05:24,729 --> 00:05:31,690
don't have any dependency on on the

00:05:27,729 --> 00:05:35,740
runtime so it's happy what it works and

00:05:31,690 --> 00:05:38,770
i just went with that and with that we

00:05:35,740 --> 00:05:40,510
can finally complain executable so your

00:05:38,770 --> 00:05:44,020
compiler vacation i will probably look

00:05:40,510 --> 00:05:47,140
like that you want to invoke your

00:05:44,020 --> 00:05:50,140
compiler he wants to in a disable the

00:05:47,140 --> 00:05:55,750
red zone which is an optimization in the

00:05:50,140 --> 00:05:58,030
ex stick x86 64 calling convention and

00:05:55,750 --> 00:06:00,190
this allows certain small functions that

00:05:58,030 --> 00:06:04,450
use less than i believe one or 28 bytes

00:06:00,190 --> 00:06:07,960
of stack space to not decrease the stack

00:06:04,450 --> 00:06:10,169
pointer even though you're using second

00:06:07,960 --> 00:06:13,210
stack space beneath the stack pointer

00:06:10,169 --> 00:06:14,440
but we are on a free state environment

00:06:13,210 --> 00:06:16,120
here we don't have an operating system

00:06:14,440 --> 00:06:19,120
that would catch all the interrupts and

00:06:16,120 --> 00:06:20,620
if an interrupt occurs on a system what

00:06:19,120 --> 00:06:23,860
happens is that the processor wants to

00:06:20,620 --> 00:06:25,150
say that state on on the stack and he

00:06:23,860 --> 00:06:26,560
didn't decrease the stack pointer we

00:06:25,150 --> 00:06:30,160
will cause memory corruption so we have

00:06:26,560 --> 00:06:31,750
to disable this optimization next so L

00:06:30,160 --> 00:06:34,120
said we are efficient environment we

00:06:31,750 --> 00:06:36,100
have no operating system we are in

00:06:34,120 --> 00:06:39,370
Microsoft universe where W

00:06:36,100 --> 00:06:41,110
is two bytes and the four bytes we don't

00:06:39,370 --> 00:06:44,440
have standard library we need to change

00:06:41,110 --> 00:06:46,120
the entry point from main to something

00:06:44,440 --> 00:06:48,790
else because the signature is slightly

00:06:46,120 --> 00:06:52,120
different and then we tell the link here

00:06:48,790 --> 00:06:54,640
that we don't have a win32 executable we

00:06:52,120 --> 00:06:58,240
have an EFI application and we tell this

00:06:54,640 --> 00:07:02,500
we we are saving this information base

00:06:58,240 --> 00:07:05,920
setting the subsystem of our application

00:07:02,500 --> 00:07:07,510
to ten so otherwise windows will just

00:07:05,920 --> 00:07:08,770
think that this is valid with win32

00:07:07,510 --> 00:07:11,530
application could launch it our windows

00:07:08,770 --> 00:07:13,270
in horribly crash I can put this in a

00:07:11,530 --> 00:07:16,480
simple chain and then we can find a

00:07:13,270 --> 00:07:20,950
compiler code so hello world looks like

00:07:16,480 --> 00:07:24,220
that we have we have if either H if I

00:07:20,950 --> 00:07:27,310
look at H our empty point is extra and C

00:07:24,220 --> 00:07:30,420
and use the Microsoft ABI and a very

00:07:27,310 --> 00:07:34,090
important thing is here the system table

00:07:30,420 --> 00:07:36,460
which contains all the services you can

00:07:34,090 --> 00:07:39,550
access through the efi for example con

00:07:36,460 --> 00:07:42,520
hours to print out strings on victor on

00:07:39,550 --> 00:07:45,010
the terminal so I add utf-16 string with

00:07:42,520 --> 00:07:46,600
hello world unfortunately I also need to

00:07:45,010 --> 00:07:50,860
cast a concert way because the interface

00:07:46,600 --> 00:07:52,990
is broken and yeah this is how a wall

00:07:50,860 --> 00:07:56,440
for year 5 and you compile this with the

00:07:52,990 --> 00:07:59,380
command line I just showed you here and

00:07:56,440 --> 00:08:02,440
then if you want to run it you can

00:07:59,380 --> 00:08:05,290
download ovm app from the internet which

00:08:02,440 --> 00:08:07,270
is an open-source implementation of UEFI

00:08:05,290 --> 00:08:09,910
and as from pedal was queue email so you

00:08:07,270 --> 00:08:11,710
can just set it as defender for your

00:08:09,910 --> 00:08:14,020
queue Musa a virtual machine you put

00:08:11,710 --> 00:08:16,870
your executable inside of a good tional

00:08:14,020 --> 00:08:18,280
hard drive with weather 532 partition

00:08:16,870 --> 00:08:20,040
and then you can hopefully

00:08:18,280 --> 00:08:22,150
launch your hello world application

00:08:20,040 --> 00:08:24,010
setup for this virtual machine or

00:08:22,150 --> 00:08:28,810
actually on your hardware if you would

00:08:24,010 --> 00:08:33,760
like to do that instead so I've already

00:08:28,810 --> 00:08:35,969
shown you the Khan out thing and there

00:08:33,760 --> 00:08:37,840
are obviously many more features than

00:08:35,969 --> 00:08:41,979
creating something out of the terminal

00:08:37,840 --> 00:08:45,550
and you have I and if you would like to

00:08:41,979 --> 00:08:47,529
to to have access to some servers to

00:08:45,550 --> 00:08:51,160
usually need to clarify their forest

00:08:47,529 --> 00:08:53,310
using DUI DS because for example if I

00:08:51,160 --> 00:08:56,439
want to render something on the screen I

00:08:53,310 --> 00:08:58,120
need to have a graphics card installed

00:08:56,439 --> 00:09:00,550
on my system of every system has a

00:08:58,120 --> 00:09:03,160
graphics card installed on the system so

00:09:00,550 --> 00:09:05,230
this might fail so we need to query it

00:09:03,160 --> 00:09:10,449
for for the existence of certain

00:09:05,230 --> 00:09:12,430
services and if that succeeds we we get

00:09:10,449 --> 00:09:14,019
a nice truck back which contains a bunch

00:09:12,430 --> 00:09:15,790
of function pointers and thus gives us a

00:09:14,019 --> 00:09:20,860
nice object-oriented style interface

00:09:15,790 --> 00:09:26,999
even if the evenin see yeah nice in

00:09:20,860 --> 00:09:26,999
terms of C we're obviously biased here

00:09:27,870 --> 00:09:33,240
and if you look closely here the

00:09:31,029 --> 00:09:35,860
signatures spirit are very very

00:09:33,240 --> 00:09:39,639
interesting because we all we all ways

00:09:35,860 --> 00:09:41,709
have a reach and we always return an

00:09:39,639 --> 00:09:43,360
error code you have AI status we have

00:09:41,709 --> 00:09:44,800
some input parameters we have fun

00:09:43,360 --> 00:09:47,559
immutable parameters and we have some

00:09:44,800 --> 00:09:48,939
other parameters so windows developers

00:09:47,559 --> 00:09:51,759
might be already familiar with those in

00:09:48,939 --> 00:09:55,920
and out and out annotations and Andy if

00:09:51,759 --> 00:09:59,889
I ever seen that's very interesting

00:09:55,920 --> 00:10:02,050
because in C this is probably fine and

00:09:59,889 --> 00:10:04,180
the thing you want to do but in C++ we

00:10:02,050 --> 00:10:08,339
are more used to interfaces like that

00:10:04,180 --> 00:10:12,550
where we return all of our actual output

00:10:08,339 --> 00:10:14,050
arguments by value and don't have and

00:10:12,550 --> 00:10:16,930
usually don't want to deal with any

00:10:14,050 --> 00:10:20,139
error codes so what we really like to

00:10:16,930 --> 00:10:22,750
have is a function that takes all the

00:10:20,139 --> 00:10:25,269
input arguments by value or by contract

00:10:22,750 --> 00:10:27,670
for that matter the meter will arguments

00:10:25,269 --> 00:10:31,600
by reference returns unexpected of a

00:10:27,670 --> 00:10:33,910
tuple or my error code and then I have a

00:10:31,600 --> 00:10:35,709
nice I have a much nicer interface

00:10:33,910 --> 00:10:40,600
because the other the other thing about

00:10:35,709 --> 00:10:42,339
other parameters is on C and that is you

00:10:40,600 --> 00:10:43,660
need to create your output variables on

00:10:42,339 --> 00:10:45,129
the stack right before you make a call

00:10:43,660 --> 00:10:47,559
to the function and those values in

00:10:45,129 --> 00:10:49,029
there don't make sense and we can't make

00:10:47,559 --> 00:10:50,410
mark those as cons because we're only

00:10:49,029 --> 00:10:55,029
recommended to them in the next

00:10:50,410 --> 00:10:57,750
statement so it's just not it's just an

00:10:55,029 --> 00:11:00,450
error-prone way to call your functions

00:10:57,750 --> 00:11:02,840
so how do we improve

00:11:00,450 --> 00:11:06,090
creation I'd like to create a prepper

00:11:02,840 --> 00:11:10,440
for all those for all those EFI

00:11:06,090 --> 00:11:13,740
functions and for that I came up with a

00:11:10,440 --> 00:11:16,410
function called wrap that takes an EFI

00:11:13,740 --> 00:11:19,020
function or EFI function pointer takes

00:11:16,410 --> 00:11:21,210
three integers as a template parameter

00:11:19,020 --> 00:11:22,860
remember input arguments the number of

00:11:21,210 --> 00:11:25,500
mutable arguments and the number of

00:11:22,860 --> 00:11:28,500
output arguments and I'd like to have I

00:11:25,500 --> 00:11:32,670
like to pass them a function pointer and

00:11:28,500 --> 00:11:36,260
then if you do i I get and you lambda

00:11:32,670 --> 00:11:39,360
back on your function back with my fist

00:11:36,260 --> 00:11:41,160
interface there is more C++ for those

00:11:39,360 --> 00:11:43,200
for this to work I need to do a few

00:11:41,160 --> 00:11:47,070
things first of all I need to get the

00:11:43,200 --> 00:11:49,650
list of all my argument types then I

00:11:47,070 --> 00:11:51,690
need to split this up for it to split

00:11:49,650 --> 00:11:53,040
those up so I have my input arguments

00:11:51,690 --> 00:11:55,920
mutual the arguments and the output

00:11:53,040 --> 00:11:57,930
arguments separately and then I can find

00:11:55,920 --> 00:12:01,440
a create my new function and then we can

00:11:57,930 --> 00:12:04,590
add some error and link to that for the

00:12:01,440 --> 00:12:07,920
first step we need to get the argument

00:12:04,590 --> 00:12:09,750
list my advice is don't bother with it

00:12:07,920 --> 00:12:12,900
just don't lose call the trace and your

00:12:09,750 --> 00:12:15,630
stat instead it has a really nice title

00:12:12,900 --> 00:12:18,120
eyes called ox T where you pass them

00:12:15,630 --> 00:12:19,860
into Kabul in my case locate device path

00:12:18,120 --> 00:12:22,560
or the type of locate device to another

00:12:19,860 --> 00:12:27,900
device path and then it returns a tuple

00:12:22,560 --> 00:12:30,540
with all the arguments and then with the

00:12:27,900 --> 00:12:32,610
student the next step would be to split

00:12:30,540 --> 00:12:34,320
up this tuple so we have our inputs the

00:12:32,610 --> 00:12:37,890
MU tables and the output separate

00:12:34,320 --> 00:12:42,810
separate it and we can do this with a

00:12:37,890 --> 00:12:46,050
Const expert function like that so my

00:12:42,810 --> 00:12:48,660
idea is that I split that implement a

00:12:46,050 --> 00:12:50,460
one-way split so given a tuple I want to

00:12:48,660 --> 00:12:52,800
have a new tuple that contains all of

00:12:50,460 --> 00:12:55,530
that contains two tuples where the first

00:12:52,800 --> 00:12:58,230
tuple has every element from 0 to n and

00:12:55,530 --> 00:13:02,130
the second to book contains all ms from

00:12:58,230 --> 00:13:04,560
n to the end and suppose 14 with make

00:13:02,130 --> 00:13:07,440
index sequence makes this actually very

00:13:04,560 --> 00:13:10,510
easy to do I just call make index

00:13:07,440 --> 00:13:13,480
sequence with n for the first

00:13:10,510 --> 00:13:15,310
for the first two pool and then call

00:13:13,480 --> 00:13:17,620
minutes make in a sequence again from

00:13:15,310 --> 00:13:19,930
end to the end for the second tuple and

00:13:17,620 --> 00:13:21,550
follow everything to the STM full

00:13:19,930 --> 00:13:25,269
function that basically just copies

00:13:21,550 --> 00:13:27,550
everything into my new tuple note that I

00:13:25,269 --> 00:13:29,529
actually don't call this function

00:13:27,550 --> 00:13:34,300
business all this is all just to get the

00:13:29,529 --> 00:13:35,110
types types right and here I do my final

00:13:34,300 --> 00:13:37,240
three-way split

00:13:35,110 --> 00:13:39,250
so here I'm just creating a bunch of

00:13:37,240 --> 00:13:43,899
type alliances that don't call us any

00:13:39,250 --> 00:13:45,699
any runtime code and here to get to if I

00:13:43,899 --> 00:13:48,970
have my argument list and I want to get

00:13:45,699 --> 00:13:51,070
the first part in are the all my input

00:13:48,970 --> 00:13:54,000
arguments I just do my split at the

00:13:51,070 --> 00:13:56,139
number of input arguments and to get the

00:13:54,000 --> 00:13:58,269
mutual elements and the output arguments

00:13:56,139 --> 00:14:00,370
I need to do this you need to split the

00:13:58,269 --> 00:14:02,380
second tuple at the number of each other

00:14:00,370 --> 00:14:05,649
arguments and then I end up with be

00:14:02,380 --> 00:14:07,839
meaningful type this year in containing

00:14:05,649 --> 00:14:09,730
before the input arguments and out

00:14:07,839 --> 00:14:14,110
containing the mutual arguments and out

00:14:09,730 --> 00:14:17,620
contain the output arguments and with

00:14:14,110 --> 00:14:20,980
that with those be tight deaths I can

00:14:17,620 --> 00:14:24,310
call another contacts per function calls

00:14:20,980 --> 00:14:29,170
make out parent adapter that takes three

00:14:24,310 --> 00:14:30,940
very attic templates the sequence of

00:14:29,170 --> 00:14:35,529
inputs the sequence of mutable the

00:14:30,940 --> 00:14:39,160
sequence of outputs and it takes the it

00:14:35,529 --> 00:14:42,639
takes the EFI function as a parameter

00:14:39,160 --> 00:14:45,130
here and returns a new lantern that

00:14:42,639 --> 00:14:48,399
captures our EFI function and this

00:14:45,130 --> 00:14:50,709
lambda only part only takes the inputs

00:14:48,399 --> 00:14:52,720
and the new tables as long as an

00:14:50,709 --> 00:14:55,449
argument but not the outputs the outputs

00:14:52,720 --> 00:14:58,660
are just locally allocated on the stack

00:14:55,449 --> 00:15:02,380
here so I removed the pointer type and

00:14:58,660 --> 00:15:04,630
create a tuple of my result then I in a

00:15:02,380 --> 00:15:08,260
second truthful temporarily just to get

00:15:04,630 --> 00:15:11,319
my pointers back to my results right

00:15:08,260 --> 00:15:13,569
here so now I have now I have my inputs

00:15:11,319 --> 00:15:16,089
my Mew tables and the pointers to my

00:15:13,569 --> 00:15:19,269
outputs I concatenate those three those

00:15:16,089 --> 00:15:21,819
three plus everything to still apply and

00:15:19,269 --> 00:15:23,470
then call it can call my yep I function

00:15:21,819 --> 00:15:26,319
with my

00:15:23,470 --> 00:15:30,429
with my reconstructed tuple and then I

00:15:26,319 --> 00:15:36,519
can return this to my the tuple of my

00:15:30,429 --> 00:15:41,379
output Islands so I have a question who

00:15:36,519 --> 00:15:45,869
thinks this process any over hat we have

00:15:41,379 --> 00:15:51,509
one hand two hands okay

00:15:45,869 --> 00:15:51,509
so most people got wrong we have Oh bad

00:15:52,889 --> 00:15:58,540
so here I have a function f that has a

00:15:56,259 --> 00:16:00,399
single output parameter and then I came

00:15:58,540 --> 00:16:02,319
up with a repla that would I would I

00:16:00,399 --> 00:16:05,319
would probably write in C so it returns

00:16:02,319 --> 00:16:07,929
an integer allocates an hour on the

00:16:05,319 --> 00:16:12,480
stack and returns the result and then

00:16:07,929 --> 00:16:14,799
this is the cpp function is something I

00:16:12,480 --> 00:16:16,839
that is more similar to what we just met

00:16:14,799 --> 00:16:19,059
our program so we allocate a two-floor

00:16:16,839 --> 00:16:22,419
int and then return a tuple event and

00:16:19,059 --> 00:16:25,809
you can see on line 11 that we have a

00:16:22,419 --> 00:16:31,149
dead store here so we remove the zero to

00:16:25,809 --> 00:16:34,809
some address so we have some L back here

00:16:31,149 --> 00:16:36,999
and the reason for this is that the

00:16:34,809 --> 00:16:39,910
tuple causes value initialization of

00:16:36,999 --> 00:16:42,429
your functions which means that in our

00:16:39,910 --> 00:16:45,279
case that the integer is initialized to

00:16:42,429 --> 00:16:47,739
zero whereas in C this is just onion an

00:16:45,279 --> 00:16:49,600
initialized value but the compiler

00:16:47,739 --> 00:16:52,439
cannot optimize that out because we're

00:16:49,600 --> 00:16:55,299
wrapping an Opaques function pointer and

00:16:52,439 --> 00:16:57,189
the compiler can't determine that we

00:16:55,299 --> 00:16:59,649
actually only write to this memory

00:16:57,189 --> 00:17:01,269
address we never read from it it's C

00:16:59,649 --> 00:17:02,860
that's easy to tell the compiler has to

00:17:01,269 --> 00:17:04,750
just say okay this uninitialized we just

00:17:02,860 --> 00:17:09,730
optimize it out because we yeah

00:17:04,750 --> 00:17:11,169
undefined in C++ we set as a zero the

00:17:09,730 --> 00:17:13,120
compound has to assume that this may be

00:17:11,169 --> 00:17:16,510
read from some other function it can

00:17:13,120 --> 00:17:21,519
optimize it out how do we get around

00:17:16,510 --> 00:17:24,159
this we can just create a small wrapper

00:17:21,519 --> 00:17:27,159
which I call uninitialized that has an

00:17:24,159 --> 00:17:29,950
empty explicit default constructor and

00:17:27,159 --> 00:17:33,820
when we better when we value initialize

00:17:29,950 --> 00:17:37,100
the struct here this does only default

00:17:33,820 --> 00:17:41,810
initialize our value so initialization

00:17:37,100 --> 00:17:44,390
Association suppose boss and we can we

00:17:41,810 --> 00:17:46,400
can just wrap all our output variables

00:17:44,390 --> 00:17:49,190
in the Sun in the Sun initialized type

00:17:46,400 --> 00:17:52,330
because we are sure that we or that we

00:17:49,190 --> 00:17:56,060
want to have uninitialized values and

00:17:52,330 --> 00:17:57,920
pass this to you - all function so might

00:17:56,060 --> 00:18:05,660
not change and this instruction goes

00:17:57,920 --> 00:18:09,010
away I believe the overhead still

00:18:05,660 --> 00:18:12,140
doesn't go away because this door closes

00:18:09,010 --> 00:18:13,520
it's a belief this still causes valid to

00:18:12,140 --> 00:18:15,650
be default valid in this vise by the

00:18:13,520 --> 00:18:24,500
initialization he just says no I believe

00:18:15,650 --> 00:18:26,690
him yeah ok and now what we still need

00:18:24,500 --> 00:18:28,370
to do is wrap the error codes so as I

00:18:26,690 --> 00:18:30,440
said before we don't have access to

00:18:28,370 --> 00:18:32,300
exceptions and even then exceptions to

00:18:30,440 --> 00:18:34,540
call sum over hat so I don't really want

00:18:32,300 --> 00:18:36,920
to use them instead I want to use an

00:18:34,540 --> 00:18:38,720
expected type so if you haven't seen

00:18:36,920 --> 00:18:40,160
Simon brands and formatters taught or

00:18:38,720 --> 00:18:44,930
unbraced taught from early of this

00:18:40,160 --> 00:18:46,700
conference an expected type is something

00:18:44,930 --> 00:18:50,750
like a special variant that either

00:18:46,700 --> 00:18:53,270
contains a resolve value or an error

00:18:50,750 --> 00:18:56,990
value and my case I'm using some events

00:18:53,270 --> 00:19:02,870
implementation TL expected and now we

00:18:56,990 --> 00:19:05,120
just need to extend our our wrapper with

00:19:02,870 --> 00:19:09,200
a small advance expose so we checked if

00:19:05,120 --> 00:19:11,540
the return type of our function is if I

00:19:09,200 --> 00:19:14,060
status so it can return an error code

00:19:11,540 --> 00:19:15,800
and that can return an error code we

00:19:14,060 --> 00:19:18,470
call our function check the error code

00:19:15,800 --> 00:19:20,720
check if it's not EFI success if it's

00:19:18,470 --> 00:19:22,910
not if I success which means there is

00:19:20,720 --> 00:19:25,340
some error there's some error we return

00:19:22,910 --> 00:19:28,160
only the error code as an unexpected

00:19:25,340 --> 00:19:30,710
value otherwise great we have the

00:19:28,160 --> 00:19:32,510
success we just return our tuple instead

00:19:30,710 --> 00:19:35,060
of the expected then there's also this

00:19:32,510 --> 00:19:36,830
case where EFI functions don't have an

00:19:35,060 --> 00:19:38,390
error code that they return they've just

00:19:36,830 --> 00:19:40,610
returned void in this case we can just

00:19:38,390 --> 00:19:43,360
return our to pool directly without

00:19:40,610 --> 00:19:43,360
wrapping it in

00:19:44,919 --> 00:19:55,369
so question number two over hat good

00:19:49,549 --> 00:20:08,349
things this costs over at no one okay

00:19:55,369 --> 00:20:08,349
oh okay nevermind

00:20:16,800 --> 00:20:19,990
[Music]

00:20:23,410 --> 00:20:29,960
okay so I can't show you that but what I

00:20:27,920 --> 00:20:34,280
essentially did I put my entire wrapper

00:20:29,960 --> 00:20:36,320
inside of compiled Explorer I I wrote

00:20:34,280 --> 00:20:38,630
the same wrapper basically in C and C++

00:20:36,320 --> 00:20:44,480
type all just fall I just caught my ear

00:20:38,630 --> 00:20:46,520
I function and in CMC I create a be a

00:20:44,480 --> 00:20:49,930
kid I create my open variables on the

00:20:46,520 --> 00:20:53,570
stack and suppose possible : wrapper and

00:20:49,930 --> 00:20:55,370
then on I check my error code in C so C

00:20:53,570 --> 00:20:57,830
if something fails something failed a

00:20:55,370 --> 00:20:59,000
print out this print an error message it

00:20:57,830 --> 00:21:01,550
was considered printed another error

00:20:59,000 --> 00:21:05,750
message and of the same in C++ and the

00:21:01,550 --> 00:21:07,910
result was that the generated assembly

00:21:05,750 --> 00:21:10,280
code is indeed different but only

00:21:07,910 --> 00:21:13,250
because the compiler inverted the jump

00:21:10,280 --> 00:21:14,540
instruction so unless you want to take

00:21:13,250 --> 00:21:15,650
something like branch prediction into

00:21:14,540 --> 00:21:20,600
account it does really cause any

00:21:15,650 --> 00:21:23,330
overhead Hey

00:21:20,600 --> 00:21:25,850
so this was the main opening part but I

00:21:23,330 --> 00:21:28,460
still want to make some things very

00:21:25,850 --> 00:21:30,140
clear I made a lot of simplifications

00:21:28,460 --> 00:21:31,820
and assumptions so first of all I only

00:21:30,140 --> 00:21:33,380
have a 30-minute slot I can't cover

00:21:31,820 --> 00:21:38,480
everything second

00:21:33,380 --> 00:21:40,220
secondly I'm reppin C not C++ I made an

00:21:38,480 --> 00:21:43,160
assumption that we are only wrapping

00:21:40,220 --> 00:21:44,540
fundamental types and parts I believe

00:21:43,160 --> 00:21:45,830
the constructor has a matter of the

00:21:44,540 --> 00:21:48,440
compiler as a much harder time

00:21:45,830 --> 00:21:51,340
optimizing things if things are not

00:21:48,440 --> 00:21:54,560
trivially copy constructible for example

00:21:51,340 --> 00:21:56,840
also the trick with the call of traits

00:21:54,560 --> 00:21:58,520
only works because we don't have in any

00:21:56,840 --> 00:22:03,650
overloads I'm only reppin C's he doesn't

00:21:58,520 --> 00:22:07,640
have any overloads but you may want to

00:22:03,650 --> 00:22:11,000
add overloads by yourself with features

00:22:07,640 --> 00:22:12,380
to overload when you're writing a high

00:22:11,000 --> 00:22:17,690
level wrapper using my wrapper for

00:22:12,380 --> 00:22:19,010
example okay so so I've shown me a bunch

00:22:17,690 --> 00:22:21,560
of meta programming I still haven't

00:22:19,010 --> 00:22:23,750
really shown you on how to write some

00:22:21,560 --> 00:22:29,570
more than functional application that

00:22:23,750 --> 00:22:31,910
does not have a world so we could write

00:22:29,570 --> 00:22:34,010
go on colonel now or we could write our

00:22:31,910 --> 00:22:35,580
own bootloader now you just call exit

00:22:34,010 --> 00:22:40,080
boot services

00:22:35,580 --> 00:22:42,330
and the machines joke but I chose to

00:22:40,080 --> 00:22:44,100
render a couple of things on the frame

00:22:42,330 --> 00:22:45,629
back on set and don't think because

00:22:44,100 --> 00:22:47,340
because of time I don't think I have the

00:22:45,629 --> 00:22:52,529
time to show that but it can just show

00:22:47,340 --> 00:22:54,600
you later after the talk but yeah first

00:22:52,529 --> 00:22:56,970
of all I need to create an instance of

00:22:54,600 --> 00:22:59,820
the graphics protocols as I said before

00:22:56,970 --> 00:23:02,039
we we are not sure if our hardware

00:22:59,820 --> 00:23:03,659
actually supports graphics so first of

00:23:02,039 --> 00:23:06,659
all we need to pray for the existence of

00:23:03,659 --> 00:23:09,239
some graphics adapter and we do this by

00:23:06,659 --> 00:23:11,460
first of all trading to wrappers so we

00:23:09,239 --> 00:23:14,690
need we need chip functions locate

00:23:11,460 --> 00:23:17,369
handle buffer and handle protocol and

00:23:14,690 --> 00:23:23,009
with those two functions we can finally

00:23:17,369 --> 00:23:26,070
create our instance so I call locate

00:23:23,009 --> 00:23:28,559
handle buffer and if that succeeds I

00:23:26,070 --> 00:23:31,320
call henna protocol and if that succeeds

00:23:28,559 --> 00:23:34,409
I cast the result of handle protocol to

00:23:31,320 --> 00:23:36,570
efi graphics out protocol and the nice

00:23:34,409 --> 00:23:39,690
thing is but anything fails I just print

00:23:36,570 --> 00:23:40,980
out fail and I'm done with it and the

00:23:39,690 --> 00:23:46,109
last thing is even though we didn't have

00:23:40,980 --> 00:23:47,460
exceptions I could cover I could put in

00:23:46,109 --> 00:23:55,649
my error hunting inside of my slides

00:23:47,460 --> 00:23:59,039
because I use expected okay so with our

00:23:55,649 --> 00:24:00,779
graph is out of protocol instance we can

00:23:59,039 --> 00:24:03,509
create a frame buffer which is just

00:24:00,779 --> 00:24:07,159
iterating over the available modes so

00:24:03,509 --> 00:24:11,639
different resolutions different

00:24:07,159 --> 00:24:14,730
different contacts and so on in my code

00:24:11,639 --> 00:24:16,980
I just chose to choose a very specific

00:24:14,730 --> 00:24:18,509
resolution that is pretty much available

00:24:16,980 --> 00:24:24,749
in every system if that doesn't work

00:24:18,509 --> 00:24:26,159
I'll stuff like I just access and yeah

00:24:24,749 --> 00:24:30,299
we created our friend before we can

00:24:26,159 --> 00:24:31,799
actually draw to the screen now so in my

00:24:30,299 --> 00:24:34,139
case I want to know I also wanted to

00:24:31,799 --> 00:24:36,359
have some double buffering so emulated

00:24:34,139 --> 00:24:38,850
by just stacked allocating and a space

00:24:36,359 --> 00:24:41,700
and then calling then implemented two

00:24:38,850 --> 00:24:44,609
functions Walter screen and clear I'm

00:24:41,700 --> 00:24:46,460
also using s to be fill in SP copy

00:24:44,609 --> 00:24:51,160
because those I don't have

00:24:46,460 --> 00:24:55,960
around appearances either and with that

00:24:51,160 --> 00:24:55,960
I can render things on the screen and

00:24:56,350 --> 00:25:00,950
unfortunately I still don't have access

00:24:59,360 --> 00:25:03,170
to the heat because I'm also I was

00:25:00,950 --> 00:25:06,410
mostly just too lazy to do it I could

00:25:03,170 --> 00:25:09,680
just probably re-implement Malik but I

00:25:06,410 --> 00:25:12,170
can't just open say a G RTF file from

00:25:09,680 --> 00:25:13,880
from the hard drive do some s processing

00:25:12,170 --> 00:25:16,880
in memory and then render render

00:25:13,880 --> 00:25:20,810
everything on my screen I only have I

00:25:16,880 --> 00:25:22,420
only have my stack but implicit surfaces

00:25:20,810 --> 00:25:25,310
give me a stick give me an escape hatch

00:25:22,420 --> 00:25:28,220
implicit surfaces give me a function

00:25:25,310 --> 00:25:30,200
representation of my scene and with that

00:25:28,220 --> 00:25:32,870
everything is just a function or stack

00:25:30,200 --> 00:25:34,700
allocated and I can just read face that

00:25:32,870 --> 00:25:38,090
scene fortunately no time for details

00:25:34,700 --> 00:25:42,440
here I can show the demo after the talk

00:25:38,090 --> 00:25:44,240
oh yeah this was basically to talk on

00:25:42,440 --> 00:25:47,810
your eye so I want to cover a few more

00:25:44,240 --> 00:25:50,660
things everything with it do we I've

00:25:47,810 --> 00:25:54,530
done here was technically incorrect and

00:25:50,660 --> 00:25:57,500
nonconformist mostly because so tough

00:25:54,530 --> 00:26:00,380
especially because I made a bunch of

00:25:57,500 --> 00:26:01,940
hacks but also the standard even if we

00:26:00,380 --> 00:26:05,720
have a super super fast in that library

00:26:01,940 --> 00:26:09,500
FL for EFI the standard says about

00:26:05,720 --> 00:26:11,120
free-standing environments that the that

00:26:09,500 --> 00:26:13,280
the available subset of functions

00:26:11,120 --> 00:26:17,780
available is pretty much just the subset

00:26:13,280 --> 00:26:20,500
of the C standard library now right now

00:26:17,780 --> 00:26:20,500
yes

00:26:31,350 --> 00:26:43,740
so your inclination is to paraphrase we

00:26:41,910 --> 00:26:45,450
shall pointed out that least that an

00:26:43,740 --> 00:26:48,120
implementation is allowed to provide

00:26:45,450 --> 00:26:50,429
more more features from the simplest

00:26:48,120 --> 00:26:52,650
analyzing the same adjustment dates that

00:26:50,429 --> 00:26:56,390
it has to provide at least more or less

00:26:52,650 --> 00:27:00,450
the C subset what's that more us correct

00:26:56,390 --> 00:27:02,520
yeah so right now to fix that

00:27:00,450 --> 00:27:04,650
there's the SG 14 meeting happening

00:27:02,520 --> 00:27:07,650
right now and one of the people papers

00:27:04,650 --> 00:27:09,590
on the agenda is Ben traits proposal for

00:27:07,650 --> 00:27:12,690
free standing environment that tries to

00:27:09,590 --> 00:27:14,309
mandate more classes to be available in

00:27:12,690 --> 00:27:16,710
freestanding environments because why

00:27:14,309 --> 00:27:18,630
I'm why when I'm writing is the tuple

00:27:16,710 --> 00:27:21,000
why am I not allowed to use the tuple or

00:27:18,630 --> 00:27:22,169
when I'm when I want to make sure that

00:27:21,000 --> 00:27:26,100
it works on every freestanding

00:27:22,169 --> 00:27:28,289
environment and there's another

00:27:26,100 --> 00:27:31,530
interesting paper going on right now the

00:27:28,289 --> 00:27:35,610
zero cost deterministic exceptions by

00:27:31,530 --> 00:27:37,860
Aristotle and those allow us so they

00:27:35,610 --> 00:27:40,110
basically introduces something similar

00:27:37,860 --> 00:27:42,600
to the acceptance specifications and

00:27:40,110 --> 00:27:45,360
this will probably allow us to write

00:27:42,600 --> 00:27:47,490
three ones catch statements but this

00:27:45,360 --> 00:27:50,580
will all everything will just map down

00:27:47,490 --> 00:27:52,799
to a language build an expected type so

00:27:50,580 --> 00:27:54,690
to speak so maybe in the future we'll

00:27:52,799 --> 00:27:56,190
still be able to refer catch you if you

00:27:54,690 --> 00:27:59,610
don't have access to the heap or any

00:27:56,190 --> 00:28:03,690
other or any other language runtime

00:27:59,610 --> 00:28:05,460
features so yeah those are my references

00:28:03,690 --> 00:28:08,010
so it can check out my code here on my

00:28:05,460 --> 00:28:10,890
github and a match aged /ef I ray tracer

00:28:08,010 --> 00:28:13,500
if you want to learn more about EFI in

00:28:10,890 --> 00:28:16,940
general I definitely can recommend

00:28:13,500 --> 00:28:20,760
checking out the ISTEP wiki on UEFI

00:28:16,940 --> 00:28:22,590
there's the free-standing proposal there

00:28:20,760 --> 00:28:27,950
is the implementation of expected by

00:28:22,590 --> 00:28:27,950
Simon and yeah that's it thank you

00:28:31,870 --> 00:28:48,920
so too much a surprise we have won a

00:28:34,460 --> 00:28:57,170
half minute of questions yes so the

00:28:48,920 --> 00:29:00,410
question was about the was about right

00:28:57,170 --> 00:29:01,910
this V new M s a B I think yes so the

00:29:00,410 --> 00:29:04,220
thing about Jesus see is that most

00:29:01,910 --> 00:29:06,140
attributes are also available as simple

00:29:04,220 --> 00:29:08,030
transplantation so we can also you can

00:29:06,140 --> 00:29:09,830
also write an economist contribute in

00:29:08,030 --> 00:29:10,790
jesusí but I I think that's ugly I just

00:29:09,830 --> 00:29:49,730
show that suppose they'll have a

00:29:10,790 --> 00:29:52,520
notation so the common the common was

00:29:49,730 --> 00:29:56,180
that I can that I can also use flying by

00:29:52,520 --> 00:30:05,870
using object copy that even more hex I

00:29:56,180 --> 00:30:08,170
won't do that okay yeah so thank you

00:30:05,870 --> 00:30:08,170

YouTube URL: https://www.youtube.com/watch?v=z6wKEJ-daD4


