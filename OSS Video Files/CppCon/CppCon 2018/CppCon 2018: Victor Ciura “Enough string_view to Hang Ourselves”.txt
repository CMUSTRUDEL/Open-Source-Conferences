Title: CppCon 2018: Victor Ciura “Enough string_view to Hang Ourselves”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Wouldn’t it be nice if we had a standard C++ type to represent strings ? Oh, wait... we do: std::string. Wouldn’t it be nice if we could use that standard type throughout our whole application/project ? Well… we can’t ! Unless we’re writing a console app or a service. But, if we’re writing an app with GUI or interacting with modern OS APIs, chances are that we’ll need to deal with at least one other non-standard C++ string type. Depending on the platform and project, it may be CString from MFC or ATL, Platform::String from WinRT, QString from Qt, wxString from wxWidgets, etc. Oh, let’s not forget our old friend `const char*`, better yet `const wchar_t*` for the C family of APIs… 
So we ended up with two string types in our codebase. OK, that’s manageable: we stick with std::string for all platform independent code and convert back-and-forth to the other XString when interacting with system APIs or GUI code. We’ll make some unnecessary copies when crossing this bridge and we’ll end up with some funny looking functions juggling two types of strings; but that’s glue code, anyway… right? 
It’s a good plan... until our project grows and we accumulate lots of string utilities and algorithms. Do we restrict those algorithmic goodies to std::string ? Do we fallback on the common denominator `const char*` and lose the type/memory safety of our C++ type ? Is C++17 std::string_view the answer to all our string problems ? 
We’ll try to explore our options, together: best practices, gotchas, things to avoid... all in the context of modern C++ projects. 
— 
Victor Ciura, CAPHYON
Software Developer

Victor Ciura is a Senior Software Engineer at CAPHYON and Technical Lead on the Advanced Installer team (http://www.advancedinstaller.com). 
For over a decade, he designed and implemented several core components and libraries of Advanced Installer.
He’s a regular guest at Computer Science Department of his Alma Mater, University of Craiova, where he gives student lectures & workshops on “Using C++STL for Competitive Programming and Software Development”. 
Currently, he spends most of his time working with his talented team on improving and extending the repackaging and virtualization technologies in Advanced Installer IDE, helping clients migrate their Win32 desktop apps to the Windows Store (MSIX).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:05,279
my name is Victor Syrah and I'm here to

00:00:03,179 --> 00:00:13,519
talk you would you ask today about

00:00:05,279 --> 00:00:18,380
string view back in July this happened

00:00:13,519 --> 00:00:20,810
and my friend Simon tweeted this and

00:00:18,380 --> 00:00:23,939
ironically the same thing happened to me

00:00:20,810 --> 00:00:26,789
so I'm just gonna roll with it but just

00:00:23,939 --> 00:00:31,529
in case you're confused here's the road

00:00:26,789 --> 00:00:34,320
map for this week you're in string the

00:00:31,529 --> 00:00:38,640
string will talk hopefully you're in the

00:00:34,320 --> 00:00:41,790
right room and this is the part 2 of M

00:00:38,640 --> 00:00:43,770
for talking about string views don't

00:00:41,790 --> 00:00:47,700
worry if you haven't seen the previous

00:00:43,770 --> 00:00:50,820
version of this talk I'm gonna build on

00:00:47,700 --> 00:00:53,610
it and you're not going to miss out on

00:00:50,820 --> 00:00:56,610
any details because I it's just an

00:00:53,610 --> 00:01:00,420
improved version of previous talk by the

00:00:56,610 --> 00:01:03,480
same title and I hope you're properly

00:01:00,420 --> 00:01:07,680
caffeinated and ready to go and start

00:01:03,480 --> 00:01:10,740
with a very uplifting talk as you can

00:01:07,680 --> 00:01:14,070
probably guess by the title so why are

00:01:10,740 --> 00:01:16,590
we talking about string view why are we

00:01:14,070 --> 00:01:18,930
talking about strings have we really

00:01:16,590 --> 00:01:24,290
exhausted all the cool template talks

00:01:18,930 --> 00:01:26,970
and topics well we kind of have to

00:01:24,290 --> 00:01:29,549
because it would be nice if we could

00:01:26,970 --> 00:01:32,100
have a single unified standard type to

00:01:29,549 --> 00:01:34,710
talk and use strings throughout our

00:01:32,100 --> 00:01:36,930
application well you might say we have

00:01:34,710 --> 00:01:39,720
standard string for that but unless

00:01:36,930 --> 00:01:42,810
you're programming like windows like a

00:01:39,720 --> 00:01:44,640
service or some kind of utility

00:01:42,810 --> 00:01:47,189
application without a graphical user

00:01:44,640 --> 00:01:50,040
interface or a very deep interaction

00:01:47,189 --> 00:01:52,350
with system api's then you really cannot

00:01:50,040 --> 00:01:56,549
use standard string throughout your

00:01:52,350 --> 00:01:59,310
application so you end up using multiple

00:01:56,549 --> 00:02:02,219
types of strings in your application if

00:01:59,310 --> 00:02:06,270
you're you have some kind of platform

00:02:02,219 --> 00:02:08,250
dependent GUI or even if you're using

00:02:06,270 --> 00:02:11,580
some kind of cross-platform GUI

00:02:08,250 --> 00:02:13,650
framework like cute or wxwidgets or

00:02:11,580 --> 00:02:15,120
something else so

00:02:13,650 --> 00:02:19,640
you end up with something like this

00:02:15,120 --> 00:02:24,540
basically beat chrome strings or

00:02:19,640 --> 00:02:26,370
eight-year strings or MFC strings cute

00:02:24,540 --> 00:02:28,439
whatever what have you

00:02:26,370 --> 00:02:33,170
the modern windows runtime platform

00:02:28,439 --> 00:02:35,510
string and you basically let's call

00:02:33,170 --> 00:02:38,730
depending on your platform and your

00:02:35,510 --> 00:02:40,409
background and your historical

00:02:38,730 --> 00:02:44,010
requirements for your application you

00:02:40,409 --> 00:02:46,409
end up with something like let's call it

00:02:44,010 --> 00:02:49,700
X string a platform dependent or a

00:02:46,409 --> 00:02:52,470
framework dependent string type and

00:02:49,700 --> 00:02:54,959
standard string that you might want to

00:02:52,470 --> 00:02:57,690
use throughout the platform independent

00:02:54,959 --> 00:03:01,319
part of the code and in the model of

00:02:57,690 --> 00:03:02,579
your applications so depending on the on

00:03:01,319 --> 00:03:05,010
your string pipe you might have

00:03:02,579 --> 00:03:08,040
questions that you might need to

00:03:05,010 --> 00:03:11,010
consider while using that custom string

00:03:08,040 --> 00:03:13,739
type does it support small sink

00:03:11,010 --> 00:03:17,840
optimization does it support

00:03:13,739 --> 00:03:20,400
copy-on-write that is is it thread safe

00:03:17,840 --> 00:03:24,319
does it support configurable charter

00:03:20,400 --> 00:03:27,049
traits that it support custom a locator

00:03:24,319 --> 00:03:30,859
does it play nice with string literals

00:03:27,049 --> 00:03:33,510
can it be used in context by context

00:03:30,859 --> 00:03:37,199
does it have proper support for encoding

00:03:33,510 --> 00:03:41,569
then unicode and system locales all kind

00:03:37,199 --> 00:03:44,849
of complicated questions and of course

00:03:41,569 --> 00:03:50,329
there isn't a perfect string out class

00:03:44,849 --> 00:03:53,729
out there ready to use or maybe there is

00:03:50,329 --> 00:03:57,389
I just found this project on github web

00:03:53,729 --> 00:03:59,729
while scrambling for details

00:03:57,389 --> 00:04:02,129
apparently there's a super string class

00:03:59,729 --> 00:04:04,319
that's very very efficient in some

00:04:02,129 --> 00:04:06,780
scenarios and uses some kind of rope

00:04:04,319 --> 00:04:11,549
data structure underneath or don't know

00:04:06,780 --> 00:04:14,579
much about it but anyway so when the

00:04:11,549 --> 00:04:17,729
wind-ups with something like this our x

00:04:14,579 --> 00:04:19,019
string let's call it class we have our

00:04:17,729 --> 00:04:22,979
standard string in our platform

00:04:19,019 --> 00:04:25,560
independent code and we have to bind

00:04:22,979 --> 00:04:26,740
those together and use some kind of

00:04:25,560 --> 00:04:29,470
common denominator

00:04:26,740 --> 00:04:35,190
to interrupt with it between those

00:04:29,470 --> 00:04:39,759
stream types so we have we might have

00:04:35,190 --> 00:04:41,470
functions that use both sink types we

00:04:39,759 --> 00:04:47,470
might have to make some unnecessary

00:04:41,470 --> 00:04:50,590
copies and cop move data around and yeah

00:04:47,470 --> 00:04:53,830
we might have some weird parts of the

00:04:50,590 --> 00:04:56,889
application that we'll need to translate

00:04:53,830 --> 00:05:00,340
and transfer stream data between our

00:04:56,889 --> 00:05:02,740
platform independent parts and our GUI

00:05:00,340 --> 00:05:04,840
framework or platform dependent parts of

00:05:02,740 --> 00:05:06,759
the application but we call that glue

00:05:04,840 --> 00:05:09,370
code and it's okay you can live with it

00:05:06,759 --> 00:05:13,030
we can try to make it as narrow as

00:05:09,370 --> 00:05:16,090
possible this layer within our

00:05:13,030 --> 00:05:20,080
application and we can live for a while

00:05:16,090 --> 00:05:22,479
with this kind of situation but as our

00:05:20,080 --> 00:05:24,280
application grows and we develop it we

00:05:22,479 --> 00:05:27,370
start to build up and accumulate a set

00:05:24,280 --> 00:05:31,990
of utilities fun and string algorithms

00:05:27,370 --> 00:05:34,770
and helpers and what do we do in this

00:05:31,990 --> 00:05:37,750
case do we restrict ourselves to

00:05:34,770 --> 00:05:40,210
implement those algorithms on top of

00:05:37,750 --> 00:05:41,979
standard string and being unable to use

00:05:40,210 --> 00:05:43,960
them straight out in the platform

00:05:41,979 --> 00:05:46,750
dependent part of our application where

00:05:43,960 --> 00:05:51,820
we have to deal with our custom string

00:05:46,750 --> 00:05:56,830
type or do we implement them again in

00:05:51,820 --> 00:05:59,380
the platform dependent string type or do

00:05:56,830 --> 00:06:02,830
we need to somehow resort to some common

00:05:59,380 --> 00:06:04,830
denominator scenario and implement or

00:06:02,830 --> 00:06:08,469
our string utilities and algorithms

00:06:04,830 --> 00:06:10,150
taking constant care star or something

00:06:08,469 --> 00:06:12,969
like that a common denominator kind of

00:06:10,150 --> 00:06:16,900
thing but we lose the type safety and

00:06:12,969 --> 00:06:24,069
the expressiveness and the full power of

00:06:16,900 --> 00:06:27,849
the type system itself and as we get on

00:06:24,069 --> 00:06:30,460
to modern C++ we encounter string view

00:06:27,849 --> 00:06:32,409
and we'll have to answer ourselves is

00:06:30,460 --> 00:06:37,000
string view the answer to our our string

00:06:32,409 --> 00:06:39,680
problems and we have to explore our

00:06:37,000 --> 00:06:41,540
options together regarding X but first

00:06:39,680 --> 00:06:44,600
let's get to know each other a little

00:06:41,540 --> 00:06:46,820
better I won't I want to probe the room

00:06:44,600 --> 00:06:51,410
a little bit how many of you are still

00:06:46,820 --> 00:06:52,570
stuck on some old compiler okay it's

00:06:51,410 --> 00:06:59,270
better than I expected

00:06:52,570 --> 00:07:07,360
how about C++ 11 Oh way better 14 and

00:06:59,270 --> 00:07:11,690
let's be brave far fewer hands but still

00:07:07,360 --> 00:07:16,160
encouraging so just in case you're not

00:07:11,690 --> 00:07:19,639
there yet there are alternatives we do

00:07:16,160 --> 00:07:23,840
have properly aligned interfaces similar

00:07:19,639 --> 00:07:25,729
to string view for example in abseil we

00:07:23,840 --> 00:07:28,610
have some older implementations like

00:07:25,729 --> 00:07:33,710
string piece from google string graph

00:07:28,610 --> 00:07:36,229
from LLVM boost string graph and fully

00:07:33,710 --> 00:07:40,190
arranged so we've been doing this for a

00:07:36,229 --> 00:07:43,100
while as the community we're just now

00:07:40,190 --> 00:07:45,620
barely trying to standardize on this and

00:07:43,100 --> 00:07:48,320
establish best practices and see what

00:07:45,620 --> 00:07:50,660
else we can figure out about the good

00:07:48,320 --> 00:07:54,229
and the bad things of using such a

00:07:50,660 --> 00:07:57,740
vocabulary type as string you since now

00:07:54,229 --> 00:08:01,430
it's a standard type so we've been doing

00:07:57,740 --> 00:08:05,570
this in some form or another I want to

00:08:01,430 --> 00:08:09,050
spend just a little bit of time to tell

00:08:05,570 --> 00:08:12,949
you about the abseil project that

00:08:09,050 --> 00:08:17,260
debuted exactly one year ago here at cpp

00:08:12,949 --> 00:08:21,199
con how many of you have heard of abseil

00:08:17,260 --> 00:08:22,789
okay good amount not all of you you

00:08:21,199 --> 00:08:27,199
should really check it out it's a cool

00:08:22,789 --> 00:08:31,430
project basically Google open sourced a

00:08:27,199 --> 00:08:34,909
bunch of their foundational library

00:08:31,430 --> 00:08:39,320
types and utilities and the cool thing

00:08:34,909 --> 00:08:43,370
about it is that it's C++ 11 / 14

00:08:39,320 --> 00:08:46,250
compatible and you can get new

00:08:43,370 --> 00:08:48,860
functionality that it's implemented in a

00:08:46,250 --> 00:08:51,470
with a lower requirement for a compiler

00:08:48,860 --> 00:08:52,910
support and basically try out new

00:08:51,470 --> 00:08:57,950
features if you people

00:08:52,910 --> 00:08:59,690
if your compiler isn't there yet so it's

00:08:57,950 --> 00:09:04,430
an open source collection of library

00:08:59,690 --> 00:09:06,710
utilities there dogfooding it so it's

00:09:04,430 --> 00:09:08,900
not something just like a hobby or

00:09:06,710 --> 00:09:10,640
experiment it's actually production

00:09:08,900 --> 00:09:12,830
ready and it's not meant to be a

00:09:10,640 --> 00:09:15,650
competitor for the standard library it's

00:09:12,830 --> 00:09:18,140
I actually meant as a transitional

00:09:15,650 --> 00:09:21,290
crutch for people that need to try out

00:09:18,140 --> 00:09:28,820
new functionality until they're ready to

00:09:21,290 --> 00:09:31,610
ablate the tool chain and there's one

00:09:28,820 --> 00:09:34,490
more thing that I like about abseil and

00:09:31,610 --> 00:09:39,140
that is it very much reminds me of the

00:09:34,490 --> 00:09:42,070
Guru of the wix's back in the day if you

00:09:39,140 --> 00:09:46,250
remember the herps adders series of

00:09:42,070 --> 00:09:48,500
gotchas and questions absolutely right

00:09:46,250 --> 00:09:51,860
the absol blog runs something similar to

00:09:48,500 --> 00:09:54,320
that and they have what they call tips

00:09:51,860 --> 00:09:56,990
of the week and be sure to check those

00:09:54,320 --> 00:09:59,870
out because there's plenty flow of

00:09:56,990 --> 00:10:02,240
information and gotchas and scenarios

00:09:59,870 --> 00:10:06,110
and good advice on designing api's and

00:10:02,240 --> 00:10:10,160
consuming types and wouldn't you know

00:10:06,110 --> 00:10:13,280
the very first tip on that tip of the

00:10:10,160 --> 00:10:17,270
week in abseil is about string views so

00:10:13,280 --> 00:10:20,960
that definitely caught my attention so

00:10:17,270 --> 00:10:25,670
if we go back to our standard vocabulary

00:10:20,960 --> 00:10:29,020
type of screen view and try to make

00:10:25,670 --> 00:10:31,970
sense of its definition and its purpose

00:10:29,020 --> 00:10:33,950
we basically determined that it's it's

00:10:31,970 --> 00:10:36,320
an object that can read refer to a

00:10:33,950 --> 00:10:40,070
constant continuous sequence of

00:10:36,320 --> 00:10:44,090
characters and the key word here being a

00:10:40,070 --> 00:10:47,090
constant sequence basically conceptually

00:10:44,090 --> 00:10:48,890
is a pointer and a size so it's a very

00:10:47,090 --> 00:10:53,420
simple very simple structure underneath

00:10:48,890 --> 00:10:56,480
and it has intentionally the same

00:10:53,420 --> 00:10:59,810
interface as standard string the

00:10:56,480 --> 00:11:02,780
constant parts anyway plus some utility

00:10:59,810 --> 00:11:04,950
utilities specific to moving a view

00:11:02,780 --> 00:11:07,920
throughout a buffer like remove

00:11:04,950 --> 00:11:10,920
prefix or suffix

00:11:07,920 --> 00:11:13,320
it's a lightweight string like view of

00:11:10,920 --> 00:11:15,930
over an array of characters and because

00:11:13,320 --> 00:11:19,589
can be constructed from a pointer and a

00:11:15,930 --> 00:11:22,110
length and it's friendly with string

00:11:19,589 --> 00:11:24,810
literals and it can be used in context /

00:11:22,110 --> 00:11:28,160
context actually this is one of its

00:11:24,810 --> 00:11:34,829
design goals to be used to process

00:11:28,160 --> 00:11:38,699
strings at compile time as well and its

00:11:34,829 --> 00:11:42,990
main goal is to avoid and minimize the

00:11:38,699 --> 00:11:44,910
use of copies of strings and it was

00:11:42,990 --> 00:11:47,820
designed to interoperate with standard

00:11:44,910 --> 00:11:50,250
string and this is a blessing as well as

00:11:47,820 --> 00:11:54,839
a problem as we'll see later on in the

00:11:50,250 --> 00:11:59,430
talk and although it's meant to be a

00:11:54,839 --> 00:12:04,760
kind of a glue code kind of utility it

00:11:59,430 --> 00:12:07,170
ends up being kind of a dangerous

00:12:04,760 --> 00:12:11,160
vocabulary type if you don't know

00:12:07,170 --> 00:12:12,300
exactly the the proper usage scenarios

00:12:11,160 --> 00:12:15,120
and the gotchas that come along with

00:12:12,300 --> 00:12:19,560
this so we'll have to explore some of

00:12:15,120 --> 00:12:21,890
these together while we are trying to

00:12:19,560 --> 00:12:25,800
avoid temporary stinging objects well

00:12:21,890 --> 00:12:29,940
they're not exactly small they can cause

00:12:25,800 --> 00:12:31,110
memory locations in most scenarios you

00:12:29,940 --> 00:12:35,430
can get away with small string

00:12:31,110 --> 00:12:39,209
optimization and maybe even with copy

00:12:35,430 --> 00:12:40,860
elysian in certain scenarios but in

00:12:39,209 --> 00:12:45,810
general it's not something that's

00:12:40,860 --> 00:12:48,449
desirable there are plentiful scenarios

00:12:45,810 --> 00:12:52,040
where unnecessary copies do happen and

00:12:48,449 --> 00:12:55,740
without us knowing about it

00:12:52,040 --> 00:12:58,620
so sting you does not manage the storage

00:12:55,740 --> 00:13:01,740
it refers to this is by design the

00:12:58,620 --> 00:13:05,160
lifetime of the object the string buffer

00:13:01,740 --> 00:13:07,290
itself is at the responsibility of the

00:13:05,160 --> 00:13:10,470
caller so the string view it's it's not

00:13:07,290 --> 00:13:13,230
an owning object and this is a very

00:13:10,470 --> 00:13:16,579
profound has very profound implications

00:13:13,230 --> 00:13:19,369
about its usage and the fact that it

00:13:16,579 --> 00:13:23,209
as an interface and as a designed type

00:13:19,369 --> 00:13:28,040
it actually tries to behave like like a

00:13:23,209 --> 00:13:29,509
regular type so when would we want to

00:13:28,040 --> 00:13:35,329
use a string view instead of a standard

00:13:29,509 --> 00:13:38,749
string so first in order to understand

00:13:35,329 --> 00:13:42,259
this let's try to examine modes in which

00:13:38,749 --> 00:13:48,709
we can construct strings string views we

00:13:42,259 --> 00:13:52,040
can construct it by copy via our pointer

00:13:48,709 --> 00:13:55,249
to characters and a size and it has this

00:13:52,040 --> 00:13:57,350
pesky constructor that can initialize

00:13:55,249 --> 00:14:02,360
from an ultra named terminating sequence

00:13:57,350 --> 00:14:04,309
of characters and this constructor is

00:14:02,360 --> 00:14:06,019
not cheap either

00:14:04,309 --> 00:14:08,749
it actually has to calculate the length

00:14:06,019 --> 00:14:12,170
of the that buffer so this is a linear

00:14:08,749 --> 00:14:14,749
operation and it might happen at compile

00:14:12,170 --> 00:14:16,279
time if that string it's known at

00:14:14,749 --> 00:14:18,230
compile and for example if we're in a

00:14:16,279 --> 00:14:20,809
context a context where we're dealing

00:14:18,230 --> 00:14:22,790
with string literals but in most

00:14:20,809 --> 00:14:25,129
scenarios it might not be so this

00:14:22,790 --> 00:14:27,949
although this constructor is very happy

00:14:25,129 --> 00:14:30,169
to accept and construct the string view

00:14:27,949 --> 00:14:33,410
for you it's actually a very costly

00:14:30,169 --> 00:14:36,199
operation in terms of what string do is

00:14:33,410 --> 00:14:41,269
trying to achieve in that tries to avoid

00:14:36,199 --> 00:14:43,850
costly operations and we do have some

00:14:41,269 --> 00:14:46,209
modifications to standard string to

00:14:43,850 --> 00:14:49,819
interoperate properly with string view

00:14:46,209 --> 00:14:53,269
for example it has an operator that

00:14:49,819 --> 00:14:55,910
tries to construct a string you convert

00:14:53,269 --> 00:15:01,009
it to a string you and it's basically

00:14:55,910 --> 00:15:03,519
constructed as data plus size nothing

00:15:01,009 --> 00:15:06,709
complicated here and we if we try to

00:15:03,519 --> 00:15:10,040
pull everything together and see the

00:15:06,709 --> 00:15:12,110
complete picture of the interoperability

00:15:10,040 --> 00:15:16,339
between standard string and standard

00:15:12,110 --> 00:15:21,169
string view we get this set of

00:15:16,339 --> 00:15:22,850
properties that a string automatic

00:15:21,169 --> 00:15:25,100
pointer to characters automatic converts

00:15:22,850 --> 00:15:27,769
to a string we are constructor that's

00:15:25,100 --> 00:15:29,440
not explicit it automatically converts

00:15:27,769 --> 00:15:31,199
to a sting view again

00:15:29,440 --> 00:15:34,269
we are constructed that's not explicit

00:15:31,199 --> 00:15:36,129
very important standard string

00:15:34,269 --> 00:15:39,819
automatically converts to string do a

00:15:36,129 --> 00:15:41,379
conversion operator and you can

00:15:39,819 --> 00:15:43,720
construct a standard string from a

00:15:41,379 --> 00:15:47,500
string view via a constructor that is

00:15:43,720 --> 00:15:52,290
explicit and this part is important

00:15:47,500 --> 00:15:56,110
we'll still details a little bit later

00:15:52,290 --> 00:16:01,930
so a little thought on storing string

00:15:56,110 --> 00:16:06,550
views because you actually can storing

00:16:01,930 --> 00:16:09,100
string views short answer would be very

00:16:06,550 --> 00:16:11,529
dangerous don't do it because you can

00:16:09,100 --> 00:16:13,750
end up holding a reference to freed

00:16:11,529 --> 00:16:15,879
memory so basically a dangling reference

00:16:13,750 --> 00:16:19,420
and we can see a very simple example

00:16:15,879 --> 00:16:22,500
here we have a vector of seen views and

00:16:19,420 --> 00:16:25,839
we have a safe function that receives

00:16:22,500 --> 00:16:29,439
let's say this function has a prototype

00:16:25,839 --> 00:16:32,290
that was designed previously and is is

00:16:29,439 --> 00:16:37,329
using string referred throughout its

00:16:32,290 --> 00:16:40,110
interface and we store this reference to

00:16:37,329 --> 00:16:43,180
the string in the vector of string views

00:16:40,110 --> 00:16:45,269
we get with this is done via an

00:16:43,180 --> 00:16:49,660
automatic conversion because of the

00:16:45,269 --> 00:16:55,480
Constructors we previously so and we get

00:16:49,660 --> 00:16:58,509
no compiler warning here and basically

00:16:55,480 --> 00:17:00,009
we end up storing a dangling reference

00:16:58,509 --> 00:17:04,659
to some string that might go out of

00:17:00,009 --> 00:17:05,530
scope off of the application what about

00:17:04,659 --> 00:17:08,140
the other way around

00:17:05,530 --> 00:17:11,409
if we've we are storing standard string

00:17:08,140 --> 00:17:14,829
and we receive them through sting views

00:17:11,409 --> 00:17:21,850
as function parameters that sounds much

00:17:14,829 --> 00:17:24,699
more safe to use should that work let's

00:17:21,850 --> 00:17:27,669
say we use a standard map from standard

00:17:24,699 --> 00:17:31,240
string to int and we store some key word

00:17:27,669 --> 00:17:35,110
frequencies very basic stuff well this

00:17:31,240 --> 00:17:37,960
very basic thing of retrieving the

00:17:35,110 --> 00:17:39,340
frequency of a given keyword doesn't

00:17:37,960 --> 00:17:42,100
actually compile

00:17:39,340 --> 00:17:43,900
you would expect it to work but it

00:17:42,100 --> 00:17:46,200
doesn't because there is he there is no

00:17:43,900 --> 00:17:51,880
conversion to standard string here so

00:17:46,200 --> 00:17:53,920
this actually doesn't compile but if we

00:17:51,880 --> 00:17:56,140
do provide standard map with a

00:17:53,920 --> 00:18:01,510
transparent comparator like standard

00:17:56,140 --> 00:18:05,620
less and we do implement get frequency

00:18:01,510 --> 00:18:08,620
from keyword a little bit different we

00:18:05,620 --> 00:18:12,550
can search for the keyword and if we

00:18:08,620 --> 00:18:13,950
find it we return its frequency let's

00:18:12,550 --> 00:18:17,830
see how this works

00:18:13,950 --> 00:18:21,340
well the find member function from

00:18:17,830 --> 00:18:24,040
standard map uses operator less than for

00:18:21,340 --> 00:18:26,850
stream views and this comes in the box

00:18:24,040 --> 00:18:29,590
so standard library actually provides

00:18:26,850 --> 00:18:32,230
utilities such as comparison operators

00:18:29,590 --> 00:18:37,840
for lexicographic compare of stingless

00:18:32,230 --> 00:18:46,810
and this is invoked by the find function

00:18:37,840 --> 00:18:50,940
in the standard map and we're hoping

00:18:46,810 --> 00:18:56,110
that our compiler can help us here and

00:18:50,940 --> 00:18:59,080
why do we forgot to ask is everyone

00:18:56,110 --> 00:19:03,450
following this example I know it's a

00:18:59,080 --> 00:19:06,540
little bit much code but hopefully the

00:19:03,450 --> 00:19:13,900
construction and the operations are ok

00:19:06,540 --> 00:19:16,420
do feel free to ask questions yeah it's

00:19:13,900 --> 00:19:18,370
different when you use the standard when

00:19:16,420 --> 00:19:21,640
use a transparent comparator so what

00:19:18,370 --> 00:19:23,620
this situation is different from this

00:19:21,640 --> 00:19:30,970
situation when you define standard map

00:19:23,620 --> 00:19:32,440
without a transparent comparator yeah so

00:19:30,970 --> 00:19:35,380
do feel free to interrupt me and ask

00:19:32,440 --> 00:19:37,870
questions on any slide if there are

00:19:35,380 --> 00:19:40,450
something that there's something that's

00:19:37,870 --> 00:19:47,050
unclear where ice skipped over too

00:19:40,450 --> 00:19:49,570
quickly over something okay so in

00:19:47,050 --> 00:19:52,750
general we try we try to rely on our

00:19:49,570 --> 00:19:55,870
compiler to help us and give us proper

00:19:52,750 --> 00:19:58,810
when things might fail or if we're doing

00:19:55,870 --> 00:20:02,280
improper usage or if we're in the danger

00:19:58,810 --> 00:20:06,280
of hand hanging on to some dangling

00:20:02,280 --> 00:20:08,800
reference and we hope that the compiler

00:20:06,280 --> 00:20:12,960
will catch that and warn us about things

00:20:08,800 --> 00:20:19,660
like that and let's see another example

00:20:12,960 --> 00:20:23,320
this is a an idiom that got popular last

00:20:19,660 --> 00:20:28,240
few years it's what people call the sink

00:20:23,320 --> 00:20:29,980
idiom like if you're planning on storing

00:20:28,240 --> 00:20:33,790
some value that you receive in your

00:20:29,980 --> 00:20:36,640
constructor and you want to handle all

00:20:33,790 --> 00:20:40,380
kinds of combinations of binding that

00:20:36,640 --> 00:20:42,790
parameter 2l values or our values

00:20:40,380 --> 00:20:45,250
because of the combinatorial nature of

00:20:42,790 --> 00:20:47,650
those parameters in the constructor

00:20:45,250 --> 00:20:51,790
you'd tend to use this pattern of

00:20:47,650 --> 00:20:53,140
actually moving the the given parameter

00:20:51,790 --> 00:20:57,130
into your stored

00:20:53,140 --> 00:21:00,010
slot or for your class that's why it's

00:20:57,130 --> 00:21:03,940
called the sinc pattern or medium

00:21:00,010 --> 00:21:06,700
whatever so if we try to do this with a

00:21:03,940 --> 00:21:09,690
standard string view for example we can

00:21:06,700 --> 00:21:15,160
start this thing with a string view and

00:21:09,690 --> 00:21:17,920
we are storing the the string value we

00:21:15,160 --> 00:21:20,320
met of total thing value we will have to

00:21:17,920 --> 00:21:24,370
store it as a standard string and if we

00:21:20,320 --> 00:21:28,570
actually try to move this string view in

00:21:24,370 --> 00:21:34,000
our stores thing we're hoping to get

00:21:28,570 --> 00:21:39,270
away with this so what do you think is

00:21:34,000 --> 00:21:39,270
this okay should it work does it compile

00:21:39,390 --> 00:22:00,270
why why the original thing you mean the

00:21:58,030 --> 00:22:00,270
source

00:22:04,520 --> 00:22:09,870
yeah but in our construction

00:22:07,650 --> 00:22:12,720
construction never mentioned standard

00:22:09,870 --> 00:22:14,730
swing so if we don't know the source of

00:22:12,720 --> 00:22:18,120
that string my distinct meter might be

00:22:14,730 --> 00:22:30,270
an actual standard string so we lost

00:22:18,120 --> 00:22:35,040
that information so what ends up being

00:22:30,270 --> 00:22:38,040
generated here so first of all let's

00:22:35,040 --> 00:22:42,900
make sure that everybody is on board

00:22:38,040 --> 00:22:46,410
it does compile and but we have to

00:22:42,900 --> 00:22:50,210
examine that cause that special

00:22:46,410 --> 00:22:53,610
constructor that I mentioned earlier and

00:22:50,210 --> 00:22:55,110
we're now talking about a constructor

00:22:53,610 --> 00:22:57,060
that has been added to standard string

00:22:55,110 --> 00:22:59,070
not sting you you see it's very

00:22:57,060 --> 00:23:02,940
confusing I keep mentioning things too

00:22:59,070 --> 00:23:04,590
in view with the changes and the

00:23:02,940 --> 00:23:08,220
functionality I did for string view in

00:23:04,590 --> 00:23:11,360
C++ 17 the standard string class was

00:23:08,220 --> 00:23:15,270
modified as well so this is causing

00:23:11,360 --> 00:23:17,850
confusion maybe and although it's meant

00:23:15,270 --> 00:23:21,840
to help in to interrupt between these

00:23:17,850 --> 00:23:25,710
types sometimes sometimes it gets in

00:23:21,840 --> 00:23:27,540
your way and things become quite quite

00:23:25,710 --> 00:23:29,970
unpleasant so let's examine this

00:23:27,540 --> 00:23:31,830
constructor so this is a special

00:23:29,970 --> 00:23:35,190
constructor it's an explicit constructor

00:23:31,830 --> 00:23:36,780
like I mentioned earlier and it's the

00:23:35,190 --> 00:23:38,310
template in constructor let's ignore the

00:23:36,780 --> 00:23:39,420
allocator part because we don't care

00:23:38,310 --> 00:23:45,720
about that right now

00:23:39,420 --> 00:23:49,620
and this constructor is actually visible

00:23:45,720 --> 00:23:53,700
if T is convertible to a Street View

00:23:49,620 --> 00:23:56,790
tuition wise the string with so this

00:23:53,700 --> 00:23:59,970
basically means that it implicitly

00:23:56,790 --> 00:24:03,690
converse T to a string view as if we

00:23:59,970 --> 00:24:07,440
would write that string view as V equals

00:24:03,690 --> 00:24:09,690
T so as if we write that and it

00:24:07,440 --> 00:24:12,270
initializes the thing and converts it

00:24:09,690 --> 00:24:13,160
like using the data and the size above

00:24:12,270 --> 00:24:17,480
rent size

00:24:13,160 --> 00:24:21,980
but the key thing here is that this

00:24:17,480 --> 00:24:24,080
constructor is actually visible only if

00:24:21,980 --> 00:24:28,730
T is convertible to a stream view so if

00:24:24,080 --> 00:24:30,500
that argument is a string like thing we

00:24:28,730 --> 00:24:33,410
don't know exactly what it is but if

00:24:30,500 --> 00:24:37,610
that thing is convertible as if we would

00:24:33,410 --> 00:24:40,730
write that line there like we would

00:24:37,610 --> 00:24:43,880
initialize it with a string V with it so

00:24:40,730 --> 00:24:46,250
if that entity is something that behaves

00:24:43,880 --> 00:24:49,610
or is convertible for a string then this

00:24:46,250 --> 00:24:51,440
come this constructor kicks in and this

00:24:49,610 --> 00:24:56,500
is a constructor in the standard string

00:24:51,440 --> 00:24:56,500
class so if we go back to this example

00:24:57,850 --> 00:25:05,870
we have we move the string view in this

00:25:03,200 --> 00:25:08,780
in the string itself and the string

00:25:05,870 --> 00:25:11,930
constructor does accept this because the

00:25:08,780 --> 00:25:14,990
smooth string view is something like a

00:25:11,930 --> 00:25:16,820
sting you it is a single so that

00:25:14,990 --> 00:25:20,930
constructor for standard string kicks in

00:25:16,820 --> 00:25:25,400
and this does compile but this it's not

00:25:20,930 --> 00:25:27,700
something that first of all I had to

00:25:25,400 --> 00:25:29,840
spend too many minutes explaining it so

00:25:27,700 --> 00:25:34,130
definitely not something that's

00:25:29,840 --> 00:25:36,920
pleasant to see or intuitive and you

00:25:34,130 --> 00:25:39,380
don't want to have this mental challenge

00:25:36,920 --> 00:25:41,270
every time you see pattern like this and

00:25:39,380 --> 00:25:42,740
it's potentially unsafe because you

00:25:41,270 --> 00:25:46,190
don't know what's happening to the

00:25:42,740 --> 00:25:50,150
source of the actual string so although

00:25:46,190 --> 00:25:53,300
it compiles you should try to always

00:25:50,150 --> 00:25:56,000
avoid to use a string view to initialize

00:25:53,300 --> 00:25:59,330
the string member keyword being here

00:25:56,000 --> 00:26:03,890
string member so if you plan to hold on

00:25:59,330 --> 00:26:05,690
to it try to avoid constructing it from

00:26:03,890 --> 00:26:08,000
a string view because you have no

00:26:05,690 --> 00:26:10,190
control over the whole site and the

00:26:08,000 --> 00:26:13,130
source of that string and although the

00:26:10,190 --> 00:26:15,440
proper constructor kicks in and it does

00:26:13,130 --> 00:26:19,540
compile you end up in a potential nest

00:26:15,440 --> 00:26:19,540
potential might work might not work

00:26:24,950 --> 00:26:31,070
it it will it will but if that string

00:26:29,059 --> 00:26:34,279
did still does the original sourcing

00:26:31,070 --> 00:26:37,190
from which we pass the string view still

00:26:34,279 --> 00:26:48,230
exists so it might actually fail at

00:26:37,190 --> 00:26:50,769
construction so it tries to do the tip

00:26:48,230 --> 00:26:54,080
copy but if that string view doesn't

00:26:50,769 --> 00:26:57,740
it's the string V is basically like a

00:26:54,080 --> 00:27:00,950
reference basically although it tries to

00:26:57,740 --> 00:27:03,110
behave like a value type we'll examine

00:27:00,950 --> 00:27:05,149
this a little bit later when we examine

00:27:03,110 --> 00:27:08,299
it as a proper type as a vocabulary type

00:27:05,149 --> 00:27:11,299
and we see if is it really regular in

00:27:08,299 --> 00:27:15,470
terms of algorithms and the concepts

00:27:11,299 --> 00:27:18,559
required so it it's deceivingly regular

00:27:15,470 --> 00:27:20,600
and it tries to fool you like it's a

00:27:18,559 --> 00:27:24,409
value type but behind the scenes this is

00:27:20,600 --> 00:27:26,120
a non owning type and it it will try to

00:27:24,409 --> 00:27:28,580
construct that string from the string

00:27:26,120 --> 00:27:30,440
you but if the string view didn't extend

00:27:28,580 --> 00:27:33,200
the stiff it doesn't extend the lifetime

00:27:30,440 --> 00:27:35,450
of the source so if the the source is

00:27:33,200 --> 00:27:43,130
not longer they no longer available it

00:27:35,450 --> 00:27:50,809
will fail to construct the string you

00:27:43,130 --> 00:27:53,269
can never know if if the caller passed

00:27:50,809 --> 00:27:57,950
an actual standard string in there it

00:27:53,269 --> 00:28:00,230
works but if the if the color used some

00:27:57,950 --> 00:28:03,710
kind of cold chain you know that was an

00:28:00,230 --> 00:28:06,889
indirect receiving of that buffer

00:28:03,710 --> 00:28:08,779
throughout some mix of string and string

00:28:06,889 --> 00:28:11,389
views this is exactly the point I'm

00:28:08,779 --> 00:28:15,620
trying to make right to the very bottom

00:28:11,389 --> 00:28:18,019
of this slide if so this is the point

00:28:15,620 --> 00:28:21,919
I'm trying to make if you're if you're

00:28:18,019 --> 00:28:25,010
mixing along a cold chain passing the

00:28:21,919 --> 00:28:27,559
string as string or string you along the

00:28:25,010 --> 00:28:29,200
way and you end up storing the standard

00:28:27,559 --> 00:28:32,929
string then you're in trouble

00:28:29,200 --> 00:28:35,779
so if you do actually plan to end up

00:28:32,929 --> 00:28:39,330
with a standard string somewhere along

00:28:35,779 --> 00:28:42,210
the route as storing it for saying

00:28:39,330 --> 00:28:45,000
Tanner were as a member try to avoid

00:28:42,210 --> 00:28:48,480
mixing strings and string views because

00:28:45,000 --> 00:28:51,060
at some point you might be end up in the

00:28:48,480 --> 00:28:53,220
situation where the string by

00:28:51,060 --> 00:28:57,950
construction is no longer guaranteed to

00:28:53,220 --> 00:28:57,950
be available the original string yeah go

00:28:57,980 --> 00:29:00,980
yep

00:29:05,960 --> 00:29:11,310
the question was in this example with

00:29:09,210 --> 00:29:13,860
the sink the STD move doesn't actually

00:29:11,310 --> 00:29:20,000
do it doesn't actually buys us anything

00:29:13,860 --> 00:29:22,620
here exactly exactly yeah but it's in

00:29:20,000 --> 00:29:25,230
the reason I'm mentioning it is because

00:29:22,620 --> 00:29:30,570
this kind of pattern became idiomatic

00:29:25,230 --> 00:29:32,670
for values passed in constructors so if

00:29:30,570 --> 00:29:35,040
this were standard string we would

00:29:32,670 --> 00:29:38,730
consider this unacceptable behavior so

00:29:35,040 --> 00:29:41,760
if our sink would receive a standard

00:29:38,730 --> 00:29:44,100
string by value we would move it inside

00:29:41,760 --> 00:30:15,920
our standard string and this is a proper

00:29:44,100 --> 00:30:19,530
efficient implementation yeah it depends

00:30:15,920 --> 00:30:23,540
how far apart is the standard string of

00:30:19,530 --> 00:30:23,540
source with regards to this constructor

00:30:25,490 --> 00:30:32,640
exactly yeah yeah it's basically the

00:30:30,630 --> 00:30:36,120
same problem with a reference but in

00:30:32,640 --> 00:30:38,010
most situations an l-value reference

00:30:36,120 --> 00:30:40,140
extends the lifetime of a temporary for

00:30:38,010 --> 00:30:47,550
example if if you you're doing it from

00:30:40,140 --> 00:30:49,650
from a temporary standard string in

00:30:47,550 --> 00:30:52,140
these situations not know but imagine

00:30:49,650 --> 00:30:52,920
you have multiple call chains like this

00:30:52,140 --> 00:30:56,720
so

00:30:52,920 --> 00:30:56,720
this is not a first functioning puppet

00:31:00,500 --> 00:31:06,450
it's not exactly like an evaluation in

00:31:04,020 --> 00:31:08,940
the main difference being and I show

00:31:06,450 --> 00:31:10,320
this in a later slide is that it doesn't

00:31:08,940 --> 00:31:16,140
extend the lifetime we were temporary

00:31:10,320 --> 00:31:19,020
which a lot value reference does in its

00:31:16,140 --> 00:31:25,710
context it depends on the actual source

00:31:19,020 --> 00:31:27,390
and on how you end up here maybe we

00:31:25,710 --> 00:31:31,890
should talk this one-on-one after

00:31:27,390 --> 00:31:33,960
because yeah this might get bored so do

00:31:31,890 --> 00:31:37,170
do reach out to me after we finish and

00:31:33,960 --> 00:31:40,910
we will examine this further but thanks

00:31:37,170 --> 00:31:42,570
for the question anyway so where were we

00:31:40,910 --> 00:31:47,190
where were we

00:31:42,570 --> 00:31:50,300
so yeah here so if you're planning to

00:31:47,190 --> 00:31:55,200
end up storing the standard string view

00:31:50,300 --> 00:31:57,390
and your colors might not be aware of

00:31:55,200 --> 00:32:00,750
this this this is where the problem

00:31:57,390 --> 00:32:02,670
comes in because you're designing parts

00:32:00,750 --> 00:32:06,180
of the application in isolation for

00:32:02,670 --> 00:32:09,270
example you I am designing a component

00:32:06,180 --> 00:32:13,980
that wants to send on to some string

00:32:09,270 --> 00:32:17,040
buffer and the color and the user the

00:32:13,980 --> 00:32:19,470
consumer of my component has no way of

00:32:17,040 --> 00:32:24,080
knowing that I try to hang on to that

00:32:19,470 --> 00:32:27,320
original string or not so it's kind of a

00:32:24,080 --> 00:32:29,550
disconnect kind of problem in terms of

00:32:27,320 --> 00:32:32,880
components being designed designed

00:32:29,550 --> 00:32:35,160
separately and if you're trying to mix

00:32:32,880 --> 00:32:39,420
them up you might you might end up in

00:32:35,160 --> 00:32:42,030
trouble or not so going back to the

00:32:39,420 --> 00:32:47,220
theme of compiler trying to help is help

00:32:42,030 --> 00:32:51,030
us surely they are at least static

00:32:47,220 --> 00:32:55,770
analysis checks that would catch these

00:32:51,030 --> 00:32:58,410
kind of situations and Werner's so how

00:32:55,770 --> 00:33:03,090
many of you have used client ID at least

00:32:58,410 --> 00:33:05,160
for static analysis whoo cool so this is

00:33:03,090 --> 00:33:06,400
an excellent opportunity for me to plug

00:33:05,160 --> 00:33:09,250
this

00:33:06,400 --> 00:33:11,950
wonderful open-source project I've been

00:33:09,250 --> 00:33:15,100
involved with for the past year that is

00:33:11,950 --> 00:33:19,810
client power tools and this basically

00:33:15,100 --> 00:33:21,730
brings all the magic of Tidy and checks

00:33:19,810 --> 00:33:25,680
and static analysis and format and

00:33:21,730 --> 00:33:29,200
everything to the visual studio ID and

00:33:25,680 --> 00:33:30,910
it's a free extension for visual studio

00:33:29,200 --> 00:33:31,690
and then it's open source if you want to

00:33:30,910 --> 00:33:35,980
check it out

00:33:31,690 --> 00:33:38,380
so client ID provides over 250 checks

00:33:35,980 --> 00:33:42,160
for various kind of things and static

00:33:38,380 --> 00:33:44,380
analysis and modernizers and and like so

00:33:42,160 --> 00:33:49,260
if we try to examine all the string

00:33:44,380 --> 00:33:54,730
related checks very good stuff in there

00:33:49,260 --> 00:33:56,680
apparently first first scan nothing

00:33:54,730 --> 00:34:00,580
related to string do lettuce that was

00:33:56,680 --> 00:34:04,270
very disappointing but if we look

00:34:00,580 --> 00:34:06,760
carefully there is the check it's just

00:34:04,270 --> 00:34:10,830
in a more general context and it's

00:34:06,760 --> 00:34:14,890
called bug prone dangling handle very

00:34:10,830 --> 00:34:16,210
intuitive name I actually looked for

00:34:14,890 --> 00:34:18,909
something related to seeing you and

00:34:16,210 --> 00:34:21,220
couldn't find anything but if you look

00:34:18,909 --> 00:34:23,860
here for this actual check can detect

00:34:21,220 --> 00:34:27,240
dangling references in value handles

00:34:23,860 --> 00:34:31,540
like strings view so it's a more general

00:34:27,240 --> 00:34:36,360
check but it's basically implemented for

00:34:31,540 --> 00:34:39,790
string this and the key word here being

00:34:36,360 --> 00:34:41,560
it can detect references that can result

00:34:39,790 --> 00:34:44,919
from constructing handles from temporary

00:34:41,560 --> 00:34:46,990
reference temporary values when those

00:34:44,919 --> 00:34:50,200
temporaries are soon destroyed after

00:34:46,990 --> 00:34:52,840
they're bound to the to word here being

00:34:50,200 --> 00:34:55,179
soon because in more complicated

00:34:52,840 --> 00:34:59,260
situations this check will not help you

00:34:55,179 --> 00:35:00,690
a very recent development like three

00:34:59,260 --> 00:35:04,980
days ago

00:35:00,690 --> 00:35:11,500
herb Sutter published a new article on

00:35:04,980 --> 00:35:14,380
lifetime profile one at all and we we

00:35:11,500 --> 00:35:19,660
hope to hear more about this in the

00:35:14,380 --> 00:35:20,760
following month and there is a a check

00:35:19,660 --> 00:35:23,980
for

00:35:20,760 --> 00:35:26,320
but then being stream view because

00:35:23,980 --> 00:35:29,590
eating it's important as it turns out as

00:35:26,320 --> 00:35:32,500
we see as we've seen earlier it's very

00:35:29,590 --> 00:35:35,310
easy to convert a string to a string

00:35:32,500 --> 00:35:40,480
view and end up with a dangling

00:35:35,310 --> 00:35:44,770
reference and basically undefined

00:35:40,480 --> 00:35:48,190
behavior and this is going to be a part

00:35:44,770 --> 00:35:52,480
of the CTP core guidelines and checks

00:35:48,190 --> 00:35:56,440
will help with this so if we examine the

00:35:52,480 --> 00:35:59,250
very sample that herb mentions in this

00:35:56,440 --> 00:36:01,960
article if we have a string view

00:35:59,250 --> 00:36:06,250
initialized with a string string view

00:36:01,960 --> 00:36:08,380
literal and we try to get the first

00:36:06,250 --> 00:36:11,950
character out of that string view we

00:36:08,380 --> 00:36:14,440
immediately have an error because the

00:36:11,950 --> 00:36:18,400
actual string view was destroyed on line

00:36:14,440 --> 00:36:20,730
a and if we do help with if we run an a

00:36:18,400 --> 00:36:24,340
compiler which does support this checker

00:36:20,730 --> 00:36:27,730
we get a warning with for example Clank

00:36:24,340 --> 00:36:31,020
W lifetime switch you get a warning that

00:36:27,730 --> 00:36:37,630
passing the dangling pointer as argument

00:36:31,020 --> 00:36:40,480
in line s index 0 so very helpful

00:36:37,630 --> 00:36:43,390
warning pinpoints the exact problem

00:36:40,480 --> 00:36:47,080
again is a very contrived example in

00:36:43,390 --> 00:36:50,530
real situations scenarios are not that

00:36:47,080 --> 00:36:55,500
simple and going back to what I

00:36:50,530 --> 00:36:58,270
mentioned earlier about conceptually

00:36:55,500 --> 00:37:02,560
string views and constraint graph

00:36:58,270 --> 00:37:06,640
basically almost the same thing one main

00:37:02,560 --> 00:37:08,410
difference would be that string views do

00:37:06,640 --> 00:37:12,370
not extend the lifetime of temporaries

00:37:08,410 --> 00:37:16,360
and this ends up being something rather

00:37:12,370 --> 00:37:18,700
unexpected for people that mentally try

00:37:16,360 --> 00:37:24,880
to map the behavior of string view as a

00:37:18,700 --> 00:37:26,860
constant string graph replacement so you

00:37:24,880 --> 00:37:31,940
shouldn't rely on lifetime extension

00:37:26,860 --> 00:37:34,850
anyway and rather know when copies

00:37:31,940 --> 00:37:38,300
our or not generate it and be aware of

00:37:34,850 --> 00:37:42,740
copy lesion and our view and small sink

00:37:38,300 --> 00:37:50,240
optimization in general regarding string

00:37:42,740 --> 00:37:58,880
literals what do you think we'll print

00:37:50,240 --> 00:38:03,770
for s1 and s2 here care to guess in that

00:37:58,880 --> 00:38:14,050
heart three and eight okay other

00:38:03,770 --> 00:38:14,050
opinions let's see

00:38:23,670 --> 00:38:29,260
can everybody see the yo put yeah let's

00:38:27,640 --> 00:38:42,070
make it a little bit more clear

00:38:29,260 --> 00:38:43,470
oh look at that 3 & 4 s 2 okay so we

00:38:42,070 --> 00:38:48,210
have a winner

00:38:43,470 --> 00:38:48,210
okay going back

00:38:58,310 --> 00:39:03,350
what about if we want a null-terminated

00:39:00,380 --> 00:39:08,770
sing will you consider this an

00:39:03,350 --> 00:39:08,770
acceptable implementation for singles

00:39:09,100 --> 00:39:18,860
would you want to use something like

00:39:11,720 --> 00:39:24,080
this yeah yeah I wouldn't want this in

00:39:18,860 --> 00:39:28,160
my code so after investigating all the

00:39:24,080 --> 00:39:29,750
caches and the issues and I still was

00:39:28,160 --> 00:39:33,170
determined that I wanted some string

00:39:29,750 --> 00:39:37,130
view in my life and the wanted to

00:39:33,170 --> 00:39:40,120
benefit from some kind of clean up in my

00:39:37,130 --> 00:39:41,900
glue code when mixing

00:39:40,120 --> 00:39:46,310
platform-independent platform-specific

00:39:41,900 --> 00:39:49,340
stuff in my application and a year a

00:39:46,310 --> 00:39:53,210
year ago I went to this talk right here

00:39:49,340 --> 00:39:56,300
at this conference and I saw Nico point

00:39:53,210 --> 00:40:01,400
out pretty disturbing stuff about two

00:39:56,300 --> 00:40:02,240
years and we had coats coats like stinky

00:40:01,400 --> 00:40:04,460
is a nightmare

00:40:02,240 --> 00:40:08,060
extreme view is worse than a string wrap

00:40:04,460 --> 00:40:09,770
and stream view sim is the semantic P of

00:40:08,060 --> 00:40:14,060
string graph but concepts concept really

00:40:09,770 --> 00:40:20,840
of value type so I was very very

00:40:14,060 --> 00:40:23,480
disappointing I almost give up I'm gonna

00:40:20,840 --> 00:40:27,500
reiterate a very simple example that he

00:40:23,480 --> 00:40:30,050
showed a year ago here for example we

00:40:27,500 --> 00:40:35,570
have a template function that returns

00:40:30,050 --> 00:40:38,360
that doubles value and be aware that we

00:40:35,570 --> 00:40:40,730
do have an operator that takes two

00:40:38,360 --> 00:40:42,440
string views a plus operator that takes

00:40:40,730 --> 00:40:45,080
two string dues and returns a standard

00:40:42,440 --> 00:40:50,900
string so this is in the standard

00:40:45,080 --> 00:40:56,180
library so if we try to do double from a

00:40:50,900 --> 00:40:59,780
string view and store it using auto here

00:40:56,180 --> 00:41:05,710
we do end up with a runtime error does

00:40:59,780 --> 00:41:05,710
anyone know why yeah

00:41:08,590 --> 00:41:15,440
exactly

00:41:09,710 --> 00:41:17,990
so because of Otto here basically this

00:41:15,440 --> 00:41:22,960
would be the take away don't assign to

00:41:17,990 --> 00:41:25,550
Otto and Niko goes as far as saying that

00:41:22,960 --> 00:41:28,369
almost always Otto is based is broken

00:41:25,550 --> 00:41:31,250
because of sting view and because sting

00:41:28,369 --> 00:41:42,080
this is gonna be a popular vocabulary

00:41:31,250 --> 00:41:46,820
type in use and let's see so I do have

00:41:42,080 --> 00:41:49,190
the example again so if we're using let

00:41:46,820 --> 00:41:53,000
let me go back to the previous sample

00:41:49,190 --> 00:41:56,420
because the return type of double is T

00:41:53,000 --> 00:41:59,119
and we pass in a stream view to the

00:41:56,420 --> 00:42:03,950
double function T ends up being a stream

00:41:59,119 --> 00:42:06,230
view and because operator plus returns

00:42:03,950 --> 00:42:09,740
the standard string we end up with a

00:42:06,230 --> 00:42:12,440
stream view reference to a temporary

00:42:09,740 --> 00:42:15,170
string resulting from that plus operator

00:42:12,440 --> 00:42:17,589
so it's a string view holding onto a

00:42:15,170 --> 00:42:21,080
temporary string of the plus operation

00:42:17,589 --> 00:42:25,700
so that's the that's the problem here

00:42:21,080 --> 00:42:27,560
and if we fix it and change the

00:42:25,700 --> 00:42:31,910
signature of the double function to

00:42:27,560 --> 00:42:35,570
return auto then in this situation R

00:42:31,910 --> 00:42:37,820
becomes a standard string now and it can

00:42:35,570 --> 00:42:40,609
hold on to the temporary result of the

00:42:37,820 --> 00:42:45,109
plus operation that is a string so very

00:42:40,609 --> 00:42:51,470
subtle thing and very easy to mess up

00:42:45,109 --> 00:42:54,320
because of pato basically many other

00:42:51,470 --> 00:42:57,230
issues with string views and very smart

00:42:54,320 --> 00:43:00,140
people are trying to fix them through

00:42:57,230 --> 00:43:03,440
the C++ committee and trying to figure

00:43:00,140 --> 00:43:06,770
out ways to improve the situation and

00:43:03,440 --> 00:43:10,250
maybe fix some of the things for C++ 20

00:43:06,770 --> 00:43:13,390
I am NOT very optimistic about this this

00:43:10,250 --> 00:43:17,170
is one of the papers related to this and

00:43:13,390 --> 00:43:20,109
by the way very recently the last meat

00:43:17,170 --> 00:43:22,839
I think that this is what was the last

00:43:20,109 --> 00:43:24,849
meeting a very sensitive issue of

00:43:22,839 --> 00:43:28,059
constructing a street view from one null

00:43:24,849 --> 00:43:30,520
pointer was discussed and after me you

00:43:28,059 --> 00:43:35,430
would think this is a simple thing turns

00:43:30,520 --> 00:43:40,960
out it's not and after much deliberation

00:43:35,430 --> 00:43:43,480
the common conclusion was that they'll

00:43:40,960 --> 00:43:52,829
just leave it unchanged like and right

00:43:43,480 --> 00:43:56,049
now this is undefined behavior so yeah

00:43:52,829 --> 00:44:00,240
if you construct a standard string from

00:43:56,049 --> 00:44:00,240
a null pointer it's a different thing so

00:44:03,839 --> 00:44:10,299
yeah it's not as simple as it seems so a

00:44:07,299 --> 00:44:14,109
few months passed since CPP Cohen of

00:44:10,299 --> 00:44:16,150
last year and I ended up at meeting C++

00:44:14,109 --> 00:44:18,520
in Berlin and I saw a much more

00:44:16,150 --> 00:44:21,970
optimistic talk on string views about

00:44:18,520 --> 00:44:29,099
the author of Q Street view from cute

00:44:21,970 --> 00:44:32,710
library and the the talk was much more

00:44:29,099 --> 00:44:35,200
embracing the advantages of string views

00:44:32,710 --> 00:44:39,460
and benefits and if you try to stay

00:44:35,200 --> 00:44:42,190
along the good path you might be and end

00:44:39,460 --> 00:44:44,500
up in a in a better place so I was much

00:44:42,190 --> 00:44:49,140
more optimistic about it after seeing

00:44:44,500 --> 00:44:52,079
that talk and I'm still torn and I

00:44:49,140 --> 00:44:55,599
almost feel like I can do this and I can

00:44:52,079 --> 00:44:58,059
let myself down this path of embracing

00:44:55,599 --> 00:45:02,079
string views and using it throughout the

00:44:58,059 --> 00:45:04,980
application but I'm still torn but

00:45:02,079 --> 00:45:07,329
hopefully there are others there to help

00:45:04,980 --> 00:45:11,440
we're starting to see a roll out of

00:45:07,329 --> 00:45:14,609
several good pieces out there in the

00:45:11,440 --> 00:45:16,900
ecosystem and investigations around the

00:45:14,609 --> 00:45:19,299
gotchas and the good practices around

00:45:16,900 --> 00:45:24,250
using string views and staying away from

00:45:19,299 --> 00:45:26,550
the bad stuff for example I'll give a

00:45:24,250 --> 00:45:29,710
shout out to

00:45:26,550 --> 00:45:34,390
excellent article by unit and Muller on

00:45:29,710 --> 00:45:37,140
string views there's a related topic not

00:45:34,390 --> 00:45:41,109
explicitly about string news but about

00:45:37,140 --> 00:45:45,430
strings computing constructors there is

00:45:41,109 --> 00:45:48,849
also performance issues and Bartek did a

00:45:45,430 --> 00:45:52,150
wonderful set of benchmarks and analyze

00:45:48,849 --> 00:45:53,740
certain situations to see exactly where

00:45:52,150 --> 00:45:57,369
the benefits of using string views

00:45:53,740 --> 00:46:01,420
kicking bear in mind that we do see a

00:45:57,369 --> 00:46:03,310
lot of gains from small sting

00:46:01,420 --> 00:46:06,490
optimizations and copy lesions in most

00:46:03,310 --> 00:46:09,970
situations so the benefits of sting use

00:46:06,490 --> 00:46:14,800
are not always as visible in practice as

00:46:09,970 --> 00:46:16,450
you might imagine and of course I have

00:46:14,800 --> 00:46:21,849
to give a shout out to Billy here in the

00:46:16,450 --> 00:46:25,119
room for the wonderful title article and

00:46:21,849 --> 00:46:26,680
I think that the the title summarizes

00:46:25,119 --> 00:46:30,070
perfectly what I'm trying to deliver

00:46:26,680 --> 00:46:32,440
here it is a doctype for Strings

00:46:30,070 --> 00:46:36,790
especially if you're working on a

00:46:32,440 --> 00:46:38,950
platform with so many exotic and

00:46:36,790 --> 00:46:42,849
different string types if we're talking

00:46:38,950 --> 00:46:50,190
just about calm it's complicated enough

00:46:42,849 --> 00:46:53,170
and Arthur wrote wire which makes a very

00:46:50,190 --> 00:46:56,550
nice analysis about string view as a

00:46:53,170 --> 00:46:58,930
value type and tries to point out that

00:46:56,550 --> 00:47:03,940
string who is not actually a value type

00:46:58,930 --> 00:47:07,030
or although it's deceivingly so and it

00:47:03,940 --> 00:47:09,520
tries to fool us as being a drop-in

00:47:07,030 --> 00:47:12,280
replacement for a constraint graph for

00:47:09,520 --> 00:47:15,460
parameters the problem being that it's

00:47:12,280 --> 00:47:19,180
neither reference type or an object type

00:47:15,460 --> 00:47:23,589
nor a proper value type so he is calling

00:47:19,180 --> 00:47:27,010
this borrow type and I think the

00:47:23,589 --> 00:47:29,580
terminology was previously quaint in

00:47:27,010 --> 00:47:33,400
rust I think if I'm not mistaken but

00:47:29,580 --> 00:47:37,359
anyway I like the terminology so if

00:47:33,400 --> 00:47:38,809
we're using Sanka some kind of reference

00:47:37,359 --> 00:47:43,219
type

00:47:38,809 --> 00:47:44,900
it's passed along as a value so the

00:47:43,219 --> 00:47:47,179
problem with burro types is the lack of

00:47:44,900 --> 00:47:51,890
ownership and the fact that they

00:47:47,179 --> 00:47:53,449
generally are short-lived and they can

00:47:51,890 --> 00:47:58,069
generally do without an assignment

00:47:53,449 --> 00:48:00,650
operator and you should try to restrict

00:47:58,069 --> 00:48:04,369
the usage only in function parameter

00:48:00,650 --> 00:48:09,949
lists and avoid storing them in any way

00:48:04,369 --> 00:48:13,999
and there are similarities as with sting

00:48:09,949 --> 00:48:16,130
view the problem is much more much much

00:48:13,999 --> 00:48:19,759
worse with standard span that's coming

00:48:16,130 --> 00:48:23,239
in C++ 20 because we're no longer

00:48:19,759 --> 00:48:25,069
talking about a constant sequence that

00:48:23,239 --> 00:48:29,359
were referring to you can actually

00:48:25,069 --> 00:48:32,150
modify the the thing behind the span so

00:48:29,359 --> 00:48:35,449
the problem because it becomes even even

00:48:32,150 --> 00:48:37,999
worse in C++ 20 so you do need

00:48:35,449 --> 00:48:42,189
contextual information around that's

00:48:37,999 --> 00:48:45,380
doing you things you need to consider is

00:48:42,189 --> 00:48:48,409
do we perform shallow shallow copies do

00:48:45,380 --> 00:48:50,809
we perform deep comparisons is it

00:48:48,409 --> 00:48:54,619
mutable or not for example string view

00:48:50,809 --> 00:48:58,159
is not span is does it provide an

00:48:54,619 --> 00:49:00,259
operator compares comparison operator or

00:48:58,159 --> 00:49:02,299
not should it provide a comparison

00:49:00,259 --> 00:49:05,269
operator or not these are the questions

00:49:02,299 --> 00:49:11,779
that come frequently when discussing

00:49:05,269 --> 00:49:16,099
span for example so problem with string

00:49:11,779 --> 00:49:16,969
view this kind of borrow types are not

00:49:16,099 --> 00:49:18,919
exactly new

00:49:16,969 --> 00:49:21,049
there are throughout the standard lab

00:49:18,919 --> 00:49:23,209
we've already but there are more exotic

00:49:21,049 --> 00:49:25,969
types problem the problem with string

00:49:23,209 --> 00:49:28,609
view is that it has the potential to

00:49:25,969 --> 00:49:31,219
become a mainstream vocabulary type and

00:49:28,609 --> 00:49:34,880
it's very tempting to use and is

00:49:31,219 --> 00:49:36,409
deceptively simple and this is where I

00:49:34,880 --> 00:49:39,019
believe the problem realize the fact

00:49:36,409 --> 00:49:41,479
that it's it's much more appealing than

00:49:39,019 --> 00:49:45,229
other bottle like types in the standard

00:49:41,479 --> 00:49:49,009
library so mind you that a string U is

00:49:45,229 --> 00:49:50,930
assignable and assign assignment has

00:49:49,009 --> 00:49:53,869
shallow semantics

00:49:50,930 --> 00:49:55,940
but comparison has deep semantics it

00:49:53,869 --> 00:49:58,700
actually does the lexicographic compare

00:49:55,940 --> 00:50:02,809
of the underlying strings so there are

00:49:58,700 --> 00:50:05,720
subtle differences there and this non

00:50:02,809 --> 00:50:09,349
owning reference type isn't exactly

00:50:05,720 --> 00:50:11,720
regular in this regard so it looks it

00:50:09,349 --> 00:50:14,660
almost looks regular if you try to

00:50:11,720 --> 00:50:18,190
analyze the requirements and its

00:50:14,660 --> 00:50:23,119
behavior but it's not actually regular

00:50:18,190 --> 00:50:26,599
but being constant helps so in general

00:50:23,119 --> 00:50:28,250
it when used properly restricting

00:50:26,599 --> 00:50:32,059
ourselves just to function parameters

00:50:28,250 --> 00:50:35,119
but its usage it's okay and we can

00:50:32,059 --> 00:50:40,099
almost squint and see it as a regular

00:50:35,119 --> 00:50:43,579
type although it's not so general

00:50:40,099 --> 00:50:46,099
problem with reference types no longer

00:50:43,579 --> 00:50:49,430
instead lasting we were span equality

00:50:46,099 --> 00:50:53,289
operator of course so if we try to

00:50:49,430 --> 00:50:56,510
restrict these types to semi-regular and

00:50:53,289 --> 00:50:58,750
call them as they are and not pretend

00:50:56,510 --> 00:51:01,339
that string U is a proper regular type

00:50:58,750 --> 00:51:03,440
might actually help in help us

00:51:01,339 --> 00:51:07,430
understand and manage expectations

00:51:03,440 --> 00:51:10,279
better and again if we're talking about

00:51:07,430 --> 00:51:14,869
C++ 20 and what's to come standard span

00:51:10,279 --> 00:51:18,849
is like an array view similar to sing

00:51:14,869 --> 00:51:23,539
view but two mutable underlying data and

00:51:18,849 --> 00:51:27,260
I do have some resources related to this

00:51:23,539 --> 00:51:29,839
and I'm actually brazing at this point

00:51:27,260 --> 00:51:33,020
again I do have a talk tomorrow about

00:51:29,839 --> 00:51:36,200
regular types and I go much deeper into

00:51:33,020 --> 00:51:38,200
analyzing the consequences of designing

00:51:36,200 --> 00:51:41,390
proper regular types and using them and

00:51:38,200 --> 00:51:44,170
meeting X the expectations of the colors

00:51:41,390 --> 00:51:46,940
and the users of the consumers of your

00:51:44,170 --> 00:51:49,549
components and I do analyze still view

00:51:46,940 --> 00:51:56,089
in the context and a much larger context

00:51:49,549 --> 00:51:58,250
of regular types and I also discuss the

00:51:56,089 --> 00:52:01,960
parallels and the differences between

00:51:58,250 --> 00:52:04,850
string view and span in this regard so

00:52:01,960 --> 00:52:07,000
there are some resources there

00:52:04,850 --> 00:52:09,790
if you want to consume further on

00:52:07,000 --> 00:52:11,900
resources on regular type and of course

00:52:09,790 --> 00:52:15,230
the talk I'm giving tomorrow

00:52:11,900 --> 00:52:17,630
and tomorrow I'm not going to focus on

00:52:15,230 --> 00:52:21,350
the gotchas of stream view but actually

00:52:17,630 --> 00:52:23,980
analyze the its proper semantics in the

00:52:21,350 --> 00:52:26,930
context of STL algorithms and

00:52:23,980 --> 00:52:31,280
requirements on types and uniform

00:52:26,930 --> 00:52:36,290
interfaces and and the like and I would

00:52:31,280 --> 00:52:38,140
summarize with some rules so if we you

00:52:36,290 --> 00:52:41,600
end up

00:52:38,140 --> 00:52:44,000
straying from the main recommendations

00:52:41,600 --> 00:52:47,150
regarding barrio types or sting like

00:52:44,000 --> 00:52:50,480
reference types try to be explicit about

00:52:47,150 --> 00:52:53,660
it and properly document such API is

00:52:50,480 --> 00:52:56,090
that you design and if you're ending up

00:52:53,660 --> 00:52:57,710
returning some string view because you

00:52:56,090 --> 00:53:00,950
need to or because you know you're

00:52:57,710 --> 00:53:04,580
processing I don't know in context by

00:53:00,950 --> 00:53:06,680
context or processing string literals or

00:53:04,580 --> 00:53:09,770
something another be sure to properly

00:53:06,680 --> 00:53:12,230
add notate your functions and properly

00:53:09,770 --> 00:53:15,050
document the potential problems there so

00:53:12,230 --> 00:53:18,500
that the color might not be caught off

00:53:15,050 --> 00:53:23,420
guard and we expect his expectations are

00:53:18,500 --> 00:53:25,070
met and try to avoid confusing the color

00:53:23,420 --> 00:53:28,790
by using something that looks like a

00:53:25,070 --> 00:53:31,520
value but it's not and why not you can

00:53:28,790 --> 00:53:34,190
use some custom attributes if you need

00:53:31,520 --> 00:53:37,160
to to properly decorate your functions

00:53:34,190 --> 00:53:41,180
in situations where you you might want

00:53:37,160 --> 00:53:46,310
to avoid offending the your users and I

00:53:41,180 --> 00:53:48,080
think I will conclude with one older

00:53:46,310 --> 00:53:51,500
article about sting you one that I

00:53:48,080 --> 00:53:54,170
enjoyed very much by mark arena and I

00:53:51,500 --> 00:53:58,520
think he said it best stream view or the

00:53:54,170 --> 00:54:00,620
Adamu I hate you and I want you that's

00:53:58,520 --> 00:54:02,750
kind of my feeling regards regarding

00:54:00,620 --> 00:54:09,020
sting view and I'm still determined

00:54:02,750 --> 00:54:14,990
through to use it so not very optimistic

00:54:09,020 --> 00:54:16,110
but still determined so that's why I

00:54:14,990 --> 00:54:17,580
think

00:54:16,110 --> 00:54:27,300
we have enough string to hang ourselves

00:54:17,580 --> 00:54:28,560
and thank you I do have a few minutes

00:54:27,300 --> 00:54:31,560
for questions if you like that to the

00:54:28,560 --> 00:54:36,470
mic um would you mind going back to the

00:54:31,560 --> 00:54:43,770
the example with operator + operator +

00:54:36,470 --> 00:54:45,860
sure you mean the Nichols examples the

00:54:43,770 --> 00:54:48,270
one with the fix or the one before

00:54:45,860 --> 00:54:50,790
either one is fine okay um

00:54:48,270 --> 00:54:52,110
I would I would make the observation I

00:54:50,790 --> 00:54:54,150
draw different conclusions through this

00:54:52,110 --> 00:54:56,070
example what is that you shouldn't

00:54:54,150 --> 00:54:57,800
overload operators four types you don't

00:54:56,070 --> 00:55:01,050
don't

00:54:57,800 --> 00:55:02,820
yes that's that's essentially where this

00:55:01,050 --> 00:55:04,980
goes wrong is that double is expecting

00:55:02,820 --> 00:55:06,510
operator + to be well behaved yeah

00:55:04,980 --> 00:55:08,520
here's somebody has written the bad

00:55:06,510 --> 00:55:11,160
operator plus there's a reason string he

00:55:08,520 --> 00:55:12,660
doesn't have this operator yeah so I

00:55:11,160 --> 00:55:21,420
think that's all that this example

00:55:12,660 --> 00:55:23,730
really shows sorry that operator pluses

00:55:21,420 --> 00:55:28,260
is from is Niko's example it's yeah and

00:55:23,730 --> 00:55:30,030
it's not hopefully yeah but if if you

00:55:28,260 --> 00:55:31,680
would implement something like this you

00:55:30,030 --> 00:55:33,840
would have to return a standard string

00:55:31,680 --> 00:55:36,300
because you have to return the result of

00:55:33,840 --> 00:55:39,810
the concatenation yeah but I agree with

00:55:36,300 --> 00:55:40,290
you that it's not the most proper thing

00:55:39,810 --> 00:55:42,270
to do

00:55:40,290 --> 00:55:44,040
so yeah you shouldn't design something

00:55:42,270 --> 00:55:48,360
like this it's a contrived example but

00:55:44,040 --> 00:55:51,480
it makes the point that unexpected

00:55:48,360 --> 00:55:54,600
conversions do happen and hiding them

00:55:51,480 --> 00:55:54,930
behind Auto is a dangerous thing that's

00:55:54,600 --> 00:55:56,760
true

00:55:54,930 --> 00:55:59,790
but I give I agree with you I wouldn't

00:55:56,760 --> 00:56:04,620
want to see this yeah with world without

00:55:59,790 --> 00:56:08,190
auto yeah this one make that observation

00:56:04,620 --> 00:56:10,650
that the question of semantics of owning

00:56:08,190 --> 00:56:12,750
versus borrow and that hot stuff gets

00:56:10,650 --> 00:56:15,720
even much worse when you look at ranges

00:56:12,750 --> 00:56:18,180
TS and you look at the the wild world of

00:56:15,720 --> 00:56:20,880
the zoo of views which are fantastic but

00:56:18,180 --> 00:56:24,240
but are similarly questionable in terms

00:56:20,880 --> 00:56:27,870
of lifetime my view on that pun intended

00:56:24,240 --> 00:56:28,610
is that when I think of ranges I think

00:56:27,870 --> 00:56:30,830
of

00:56:28,610 --> 00:56:34,990
iterate repairs and I don't view them as

00:56:30,830 --> 00:56:38,030
value types at all so I don't expect to

00:56:34,990 --> 00:56:40,580
see you arrange and pretend that I

00:56:38,030 --> 00:56:44,240
copied that range of by referencing it

00:56:40,580 --> 00:56:46,400
in some expression so unless I see an

00:56:44,240 --> 00:56:49,820
explicit copy algorithm there I don't

00:56:46,400 --> 00:56:52,040
expect that means to be hold on to so so

00:56:49,820 --> 00:56:54,650
maybe in the future this for me yeah

00:56:52,040 --> 00:56:56,720
when people are used to the views from

00:56:54,650 --> 00:56:58,580
ranges and whatever type that is if it's

00:56:56,720 --> 00:57:00,440
a borrow type or whatever string you

00:56:58,580 --> 00:57:03,290
should fit into that category not the

00:57:00,440 --> 00:57:06,410
more regular category I would be more

00:57:03,290 --> 00:57:08,690
worried about spam actually I'm much

00:57:06,410 --> 00:57:11,870
more comfortable with string view and I

00:57:08,690 --> 00:57:15,650
I could almost squint and pretend it's

00:57:11,870 --> 00:57:20,540
okay but I'm much more worried about

00:57:15,650 --> 00:57:22,580
spam and that's coming by the way yeah

00:57:20,540 --> 00:57:28,310
hi there can you go back to the string

00:57:22,580 --> 00:57:30,170
view of nobler slide oh my god I hope I

00:57:28,310 --> 00:57:37,520
can find it

00:57:30,170 --> 00:57:40,940
now I passed it yep

00:57:37,520 --> 00:57:42,670
so are you claiming that stirred string

00:57:40,940 --> 00:57:53,510
would be any different in this example

00:57:42,670 --> 00:57:55,430
I'm not claiming it's better okay like

00:57:53,510 --> 00:58:01,490
that's causes you be for both stood

00:57:55,430 --> 00:58:04,460
strange and for stranger yeah I don't

00:58:01,490 --> 00:58:07,490
know would we expect to to end up with

00:58:04,460 --> 00:58:11,660
an empty string here do they actually

00:58:07,490 --> 00:58:19,070
pay the Sterling to be undefined

00:58:11,660 --> 00:58:22,880
behavior yeah yeah I don't know I'm I'm

00:58:19,070 --> 00:58:24,800
not sure there's a better solution I'm

00:58:22,880 --> 00:58:26,210
not claiming we can are you at the point

00:58:24,800 --> 00:58:28,970
I just want to make sure this is not

00:58:26,210 --> 00:58:33,680
different between straining straining we

00:58:28,970 --> 00:58:36,130
could there's the value question of yeah

00:58:33,680 --> 00:58:40,150
it's it's very tricky to fall down the

00:58:36,130 --> 00:58:41,540
path of exceptions here for example

00:58:40,150 --> 00:58:44,510
should I be

00:58:41,540 --> 00:58:47,180
doubling string view or sync issuing an

00:58:44,510 --> 00:58:49,970
exception here but then we'd have to

00:58:47,180 --> 00:58:51,710
think about the scenarios were you're

00:58:49,970 --> 00:58:54,170
restricted and not being able to use

00:58:51,710 --> 00:58:57,980
that all I'm saying that I want to make

00:58:54,170 --> 00:59:02,810
sure is if you change this to string 2

00:58:57,980 --> 00:59:08,530
as of today yeah I agree with you there

00:59:02,810 --> 00:59:17,990
yeah yeah any more questions

00:59:08,530 --> 00:59:19,550
they were just stretching or the

00:59:17,990 --> 00:59:22,420
question was what's the benefit of

00:59:19,550 --> 00:59:26,870
string views after all this discussion

00:59:22,420 --> 00:59:29,960
so avoiding copies so most situations

00:59:26,870 --> 00:59:35,090
you should really check out this article

00:59:29,960 --> 00:59:37,330
up by Bartosz Bartek let me see where is

00:59:35,090 --> 00:59:37,330
it

00:59:37,400 --> 00:59:44,770
I'm skipping really fast this one so

00:59:39,590 --> 00:59:44,770
definitely take a picture of that or

00:59:45,730 --> 00:59:53,810
write down the URL so Bart X analyzes

00:59:51,290 --> 00:59:56,000
here many situations and that's some

00:59:53,810 --> 00:59:58,220
micro benchmarks and I'm not claiming

00:59:56,000 --> 01:00:00,680
they're excellent and they cover every

00:59:58,220 --> 01:00:03,650
kind of scenario there but you do see

01:00:00,680 --> 01:00:05,810
advantages in certain scenarios even

01:00:03,650 --> 01:00:07,550
though you have small sink optimization

01:00:05,810 --> 01:00:09,530
kicking in and copy lesion in more

01:00:07,550 --> 01:00:11,510
situations so you should you should be

01:00:09,530 --> 01:00:16,040
okay even without string view in most

01:00:11,510 --> 01:00:20,120
cases but think about constants tax per

01:00:16,040 --> 01:00:23,360
context and using string functions for

01:00:20,120 --> 01:00:25,400
examples to same functions from as in

01:00:23,360 --> 01:00:29,590
standard string in context for context

01:00:25,400 --> 01:00:29,590
for example here on string literals

01:00:32,170 --> 01:00:39,800
sinck sinck sinck

01:00:34,370 --> 01:01:04,310
yeah yeah yeah yeah sink sink sink sink

01:00:39,800 --> 01:01:07,130
sink sink yeah yeah I decide so I must

01:01:04,310 --> 01:01:10,100
repeat the question so you're more like

01:01:07,130 --> 01:01:12,950
an observation your observation here is

01:01:10,100 --> 01:01:15,500
that I deceivingly name the class thing

01:01:12,950 --> 01:01:17,810
although this is not exactly a sink

01:01:15,500 --> 01:01:19,040
pattern here and I did that on purpose

01:01:17,810 --> 01:01:21,100
yeah

01:01:19,040 --> 01:01:24,170
the adviser the general advice is

01:01:21,100 --> 01:01:26,420
restrict using string use as parameters

01:01:24,170 --> 01:01:29,060
but the pitfall here is that you

01:01:26,420 --> 01:01:38,770
actually try to store it so that's the

01:01:29,060 --> 01:01:43,550
one of the gotchas don't store it yeah

01:01:38,770 --> 01:01:46,100
yeah where your were a little over the

01:01:43,550 --> 01:01:50,620
time we can discuss this one-on-one I'm

01:01:46,100 --> 01:01:50,620
around so do catch me thank you

01:01:50,760 --> 01:01:55,819

YouTube URL: https://www.youtube.com/watch?v=xwP4YCP_0q0


