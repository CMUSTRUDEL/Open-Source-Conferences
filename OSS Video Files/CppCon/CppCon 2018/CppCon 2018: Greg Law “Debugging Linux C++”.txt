Title: CppCon 2018: Greg Law “Debugging Linux C++”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Greg will demonstrate some neat new GDB features and other advanced debugging tools on Linux. 

Debugging dominates software development, and yet all too often we rely on printf or at best a little bit of gdb with a bit of 'next' and 'print'. This talk will demonstrate some of the power of newer versions of GDB (Reverse debug, dynamic printf, amazing scriptability possibilities through Python), as well as some of the other Linux debugging tools at your disposal: ftrace, strace, ltrace, valgrind, rr, asan, and lots of very useful stuff in /proc. 

This presentation works either as a stand-alone talk or as a follow on to Greg's popular 'GDB Power User' talk at cppcon 2016."
— 
Greg Law, Undo Limited
CTO and Co-Founder

Greg is co-founder and CEO at Undo. He is a programmer at heart, but likes to keep one foot in the software world and one in the business world. Greg finds it particularly rewarding to turn innovative software technology into real business development. Greg has over 20 years of experience in both academia and innovative start-up software companies.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,680 --> 00:00:01,520
- So, welcome everyone.

00:00:01,520 --> 00:00:03,883
Hope it was a good lunch.

00:00:04,760 --> 00:00:08,963
So we're gonna talk about lots of cool debugging stuff.

00:00:10,284 --> 00:00:12,210
All right, saw some people coming in.

00:00:12,210 --> 00:00:14,810
This is a big room and these lights are kind of scary,

00:00:14,810 --> 00:00:16,973
but anyway, I'll try, I'll try my best.

00:00:18,180 --> 00:00:22,260
Okay, so just to start off and just to set the scene,

00:00:22,260 --> 00:00:24,683
the scope, of what I wanted to talk about today,

00:00:26,211 --> 00:00:28,650
so gonna just show a bunch of specific tools,

00:00:28,650 --> 00:00:31,150
some of them freely available, some of them,

00:00:31,150 --> 00:00:32,410
some of them commercial.

00:00:32,410 --> 00:00:36,680
Gonna either show or talk about just a random set.

00:00:36,680 --> 00:00:38,906
There's no particular rhyme or reason

00:00:38,906 --> 00:00:40,450
why I chose what I chose.

00:00:40,450 --> 00:00:44,903
If your favorite thing isn't here, then, well, deal with it.

00:00:47,570 --> 00:00:49,863
And it's really about detecting.

00:00:50,810 --> 00:00:52,260
It's about root causing bugs.

00:00:53,230 --> 00:00:54,930
It's debugging.

00:00:54,930 --> 00:00:57,520
So often, these things, scopes are best set, I think,

00:00:57,520 --> 00:00:59,370
by saying what they're not.

00:00:59,370 --> 00:01:02,670
So I'm gonna steer away from generic advice.

00:01:02,670 --> 00:01:04,790
I mean, there's some really useful stuff

00:01:04,790 --> 00:01:05,810
we can do, and I think a lot

00:01:05,810 --> 00:01:10,290
of what makes experienced programmers valuable

00:01:10,290 --> 00:01:13,110
is the tips and tricks they learn themselves

00:01:13,110 --> 00:01:15,630
for how to debug stuff, not necessarily using tools,

00:01:15,630 --> 00:01:17,580
but anyway, this talk isn't about that.

00:01:18,824 --> 00:01:21,060
It's not about testing or testing tools, right?

00:01:21,060 --> 00:01:23,460
There are loads of great testing tools,

00:01:23,460 --> 00:01:26,000
there's loads of great testing talks,

00:01:26,000 --> 00:01:28,230
that's already important stuff, just,

00:01:28,230 --> 00:01:31,180
that's not what I want to talk about today.

00:01:31,180 --> 00:01:33,120
It's not about how to avoid writing bugs.

00:01:33,120 --> 00:01:35,920
I'm gonna assume that nobody in the audience is perfect.

00:01:37,060 --> 00:01:39,680
And it's not about performance profiling.

00:01:39,680 --> 00:01:41,203
Well, not per se.

00:01:43,680 --> 00:01:45,780
In a sense, looking at a performance anomaly

00:01:45,780 --> 00:01:46,680
is a bug, right?

00:01:46,680 --> 00:01:49,840
If the program doesn't comply with the spec,

00:01:49,840 --> 00:01:52,040
and the spec might be that this thing needs to respond

00:01:52,040 --> 00:01:54,440
within so many milliseconds, then if it's not, it's a bug.

00:01:54,440 --> 00:01:57,690
So there's clearly overlap between performance profiling

00:01:57,690 --> 00:02:02,020
and debugging, and sometimes, the two are the same.

00:02:02,020 --> 00:02:04,888
But I'm looking at this from a point of view of debugging,

00:02:04,888 --> 00:02:06,983
not performance profiling.

00:02:08,240 --> 00:02:09,420
Certainly not exhaustive,

00:02:09,420 --> 00:02:11,170
as I kind of said at the beginning.

00:02:14,230 --> 00:02:18,190
So, oh yeah, and also it's not a workshop, right?

00:02:18,190 --> 00:02:21,800
So all the tools I show, nobody's gonna come away expert

00:02:21,800 --> 00:02:23,820
in those tools who wasn't already an expert

00:02:23,820 --> 00:02:25,490
when they walked in.

00:02:25,490 --> 00:02:27,800
And the point of it is, hopefully, you'll see some stuff

00:02:27,800 --> 00:02:29,380
that you just haven't really seen before,

00:02:29,380 --> 00:02:31,070
or you might have heard of,

00:02:31,070 --> 00:02:32,920
but weren't quite sure what it was,

00:02:32,920 --> 00:02:34,430
and then this gives you enough to maybe,

00:02:34,430 --> 00:02:36,600
then you can Google it and you can read the man page

00:02:36,600 --> 00:02:38,810
or whatever, and you'll never become an expert

00:02:38,810 --> 00:02:40,943
without actually using stuff.

00:02:42,900 --> 00:02:46,290
But I do want to talk a little bit about why I care,

00:02:46,290 --> 00:02:49,500
and give it a little bit of context.

00:02:49,500 --> 00:02:53,240
And I'm gonna start at the beginning.

00:02:53,240 --> 00:02:56,060
So this chap, chap called Maurice Wilkes,

00:02:56,060 --> 00:02:59,070
who I think had as good a claim as anybody in the world

00:02:59,070 --> 00:03:01,980
to being the world's first programmer.

00:03:01,980 --> 00:03:05,880
He's the first person to write code on a computer

00:03:05,880 --> 00:03:09,090
to do a real job, to do something other than just test

00:03:09,090 --> 00:03:11,921
this experimental machine that people were building lots of

00:03:11,921 --> 00:03:14,100
just after the Second World War to test that they work.

00:03:14,100 --> 00:03:15,590
He was actually, I can't remember what it was.

00:03:15,590 --> 00:03:19,350
It was some biological problem that was (mumbles)

00:03:19,350 --> 00:03:21,470
very complicated mathematics behind it,

00:03:21,470 --> 00:03:25,200
so he wrote a program on one of the first computers.

00:03:25,200 --> 00:03:29,140
And he said in his memoirs that he remembers

00:03:30,325 --> 00:03:33,230
that the realization came over him in full force,

00:03:33,230 --> 00:03:35,330
that a good part of the remainder of my life

00:03:35,330 --> 00:03:38,963
was going to be spent finding errors in my own programs.

00:03:40,870 --> 00:03:43,020
I kind of remember that feeling as well,

00:03:43,020 --> 00:03:45,147
when I first started to program,

00:03:45,147 --> 00:03:47,290
and I think we've all been there,

00:03:47,290 --> 00:03:48,460
we've all had that realization

00:03:48,460 --> 00:03:50,620
that it's just really not as easy as you might think.

00:03:50,620 --> 00:03:51,500
I mean no one thinks,

00:03:51,500 --> 00:03:52,940
people who've not seen programming before,

00:03:52,940 --> 00:03:54,887
I don't think they think it's easy.

00:03:54,887 --> 00:03:58,780
I don't think you realize just quite how impossible it is

00:03:58,780 --> 00:03:59,650
to get a program right.

00:03:59,650 --> 00:04:01,870
I mean, I like to think of myself

00:04:01,870 --> 00:04:05,340
as a reasonable programmer, at least, perhaps,

00:04:05,340 --> 00:04:07,123
I was before I got out of practice.

00:04:09,500 --> 00:04:11,820
What's the longest program I can write,

00:04:11,820 --> 00:04:14,290
and it will just work first time?

00:04:14,290 --> 00:04:17,923
20 lines, 30 maybe if I try really hard.

00:04:19,410 --> 00:04:24,410
And I think that programming is dominated by debugging.

00:04:24,690 --> 00:04:27,170
I think there's been studies that show most programmers

00:04:27,170 --> 00:04:29,800
spend more than half their time debugging.

00:04:29,800 --> 00:04:32,580
That might not be debugging some in-production failure,

00:04:32,580 --> 00:04:34,670
might not be what we think of debugging, but again,

00:04:34,670 --> 00:04:35,830
just ask yourself that question,

00:04:35,830 --> 00:04:39,747
how often does it work first time?

00:04:39,747 --> 00:04:41,500
I remember a couple of years ago

00:04:41,500 --> 00:04:43,840
when my daughter started programming in Scratch,

00:04:43,840 --> 00:04:45,327
and she said, "Dad, it's lots of fun,

00:04:45,327 --> 00:04:47,647
"but I have to try lots of times to get it

00:04:47,647 --> 00:04:49,100
"to do the right thing," and I was like,

00:04:49,100 --> 00:04:51,500
yup, there's that feeling still happening.

00:04:51,500 --> 00:04:53,830
And it's kind of cool 'cause then she could understand

00:04:53,830 --> 00:04:55,360
a little bit more about what this company

00:04:55,360 --> 00:04:59,510
with a funny name that Dad started actually does.

00:04:59,510 --> 00:05:04,417
So anyway, that's kind of why I think debugging is really,

00:05:06,377 --> 00:05:07,740
underrated's not the word, no one could rate it,

00:05:07,740 --> 00:05:09,870
but it's underappreciated.

00:05:09,870 --> 00:05:12,030
I guess, so there's the obvious thing,

00:05:12,030 --> 00:05:14,680
well, it's better not to write the bugs in the first place.

00:05:14,680 --> 00:05:17,130
Yeah, well, duh, of course it is.

00:05:17,130 --> 00:05:18,690
But none of us is perfect.

00:05:18,690 --> 00:05:20,370
I think a nice test to the statement

00:05:20,370 --> 00:05:22,820
as whether it's worth making is would the opposite

00:05:22,820 --> 00:05:25,790
of that statement be in any way sensible?

00:05:25,790 --> 00:05:28,840
And clearly this one, so obviously better to avoid the bugs,

00:05:28,840 --> 00:05:30,360
writing the bugs in the first place,

00:05:30,360 --> 00:05:32,530
and prevention is always better than cure.

00:05:32,530 --> 00:05:35,820
But whatever prevention you do, you're going to need cure,

00:05:35,820 --> 00:05:36,890
and when it comes to programming,

00:05:36,890 --> 00:05:38,933
you're gonna need quite a lot of it.

00:05:40,008 --> 00:05:43,120
And here's a nice quote from a splendid chap,

00:05:43,120 --> 00:05:46,223
Brian Kernighan, that probably many of you know.

00:05:46,223 --> 00:05:48,250
It's quite well known that everyone knows

00:05:48,250 --> 00:05:50,010
that debugging is twice as hard as writing the program

00:05:50,010 --> 00:05:52,340
in the first place, so if you're as clever as you can be

00:05:52,340 --> 00:05:54,660
when you write it, how will you ever debug it?

00:05:54,660 --> 00:05:56,623
Good quote, makes you think.

00:05:58,600 --> 00:06:00,710
And I think that's another of the differences

00:06:00,710 --> 00:06:02,070
with experienced programmers.

00:06:02,070 --> 00:06:06,190
Someone likened it to learning to ride motorcycles,

00:06:06,190 --> 00:06:08,040
and when, like these 18-year-old guys

00:06:08,040 --> 00:06:09,720
go on their first motorbikes, they tear around

00:06:09,720 --> 00:06:13,090
at 100 miles an hour, and the ones that survive,

00:06:13,090 --> 00:06:14,680
sort of the ones that don't get selected

00:06:14,680 --> 00:06:17,600
out of the gene pool, go on to be kind of middle-aged men

00:06:17,600 --> 00:06:19,770
riding around on motorcycles, nice and slow,

00:06:19,770 --> 00:06:21,810
well within their kind of margin.

00:06:21,810 --> 00:06:23,230
They've got lots of margin for error

00:06:23,230 --> 00:06:24,570
'cause they know they're gonna make mistakes,

00:06:24,570 --> 00:06:26,710
and I think programmers, as programmers,

00:06:26,710 --> 00:06:27,833
we learn this as well.

00:06:32,230 --> 00:06:33,600
I think it's an interesting,

00:06:33,600 --> 00:06:36,063
if you think about what that statement implies,

00:06:38,930 --> 00:06:41,320
it's that debuggability is the limiting factor

00:06:41,320 --> 00:06:43,433
in how good our programs can be.

00:06:44,430 --> 00:06:47,720
So whatever metric for good you have,

00:06:47,720 --> 00:06:51,290
whether it's how fast it goes, whether it's how extensible

00:06:51,290 --> 00:06:54,130
and maintainable it is, whether it's how small it is,

00:06:54,130 --> 00:06:55,330
whether how many features it has,

00:06:55,330 --> 00:06:58,940
whatever the metric for good is,

00:06:58,940 --> 00:07:03,770
if you could make debugging twice as easy or half as hard,

00:07:03,770 --> 00:07:07,250
then you could make those metrics twice as good.

00:07:07,250 --> 00:07:09,700
It's the bottleneck, it's the limiting factor

00:07:09,700 --> 00:07:11,180
in how good our programs are.

00:07:11,180 --> 00:07:13,210
Yet it gets remarkably little attention.

00:07:13,210 --> 00:07:14,830
You look at the ecosystem out there,

00:07:14,830 --> 00:07:18,160
the number of talks available, the number of tools,

00:07:18,160 --> 00:07:22,820
the number of books, the meetups and conferences

00:07:22,820 --> 00:07:26,460
on things like performance profiling or testing, is huge.

00:07:26,460 --> 00:07:27,530
There's loads of it,

00:07:27,530 --> 00:07:30,450
but there's comparatively hardly any on debugging.

00:07:30,450 --> 00:07:32,060
Now, I appreciate, to some extent,

00:07:32,060 --> 00:07:34,800
I am preaching to the choir,

00:07:34,800 --> 00:07:38,550
'cause you guys all turned up today, but still,

00:07:38,550 --> 00:07:40,833
that's my little soapbox bit.

00:07:44,230 --> 00:07:46,300
So, and if you just think for a moment,

00:07:46,300 --> 00:07:48,690
the magnitude of the task, we do this every day,

00:07:48,690 --> 00:07:51,483
this debugging bit, and just kind of normal practice.

00:07:53,810 --> 00:07:56,700
Modern computers issuing billions of instructions

00:07:56,700 --> 00:07:58,670
every second, and that's if you have one thread

00:07:58,670 --> 00:08:01,310
in one process, so that's kind of as simple as it gets.

00:08:01,310 --> 00:08:04,137
And you're looking for that one bad instruction often.

00:08:04,137 --> 00:08:07,693
And it is the ultimate needle in a haystack challenge.

00:08:09,240 --> 00:08:11,560
But here's another quote from that same chap,

00:08:11,560 --> 00:08:14,610
Brian Kernighan, says that the most effective debugging tool

00:08:14,610 --> 00:08:19,610
is careful thought with judiciously placed print statements.

00:08:19,640 --> 00:08:24,640
Now, splendid chap, he did say that in 1979,

00:08:24,928 --> 00:08:27,000
and the world has moved on, I think, a bit.

00:08:27,000 --> 00:08:29,260
In fact, when he said that in 1979,

00:08:29,260 --> 00:08:31,940
interactive terminals were kind of new.

00:08:31,940 --> 00:08:33,500
Print statements, more often than not,

00:08:33,500 --> 00:08:35,800
meant printing things out on a dot matrix printer

00:08:35,800 --> 00:08:37,990
or a line printer or something.

00:08:37,990 --> 00:08:40,390
So I think the world has moved on since 1979,

00:08:40,390 --> 00:08:44,970
and we do have much better tools at our disposal.

00:08:44,970 --> 00:08:46,790
There are times, we all know there are times,

00:08:46,790 --> 00:08:51,200
when good old printf debugging just is the tool for the job,

00:08:51,200 --> 00:08:53,720
so like all these tools, you have to choose the right tool

00:08:53,720 --> 00:08:54,620
at the right time.

00:08:56,940 --> 00:08:59,320
But yeah, world has moved on, so where are we now?

00:08:59,320 --> 00:09:03,260
I think there are really two kinds of debugging tool.

00:09:03,260 --> 00:09:04,380
You can categorize things how you like,

00:09:04,380 --> 00:09:05,899
but I categorize them like this.

00:09:05,899 --> 00:09:07,180
So you've got the kind of checkers,

00:09:07,180 --> 00:09:09,663
so dynamic and static analysis,

00:09:10,830 --> 00:09:13,280
and mostly what you're doing there

00:09:13,280 --> 00:09:15,870
is trying to look for did my code do a particular instance

00:09:15,870 --> 00:09:18,833
of a bad thing, a buffer overrun, for example?

00:09:19,740 --> 00:09:22,500
And then the other kinds of more general purpose debuggers,

00:09:22,500 --> 00:09:25,080
which are really about code exploration

00:09:25,080 --> 00:09:27,250
and trying to work out what did my code do,

00:09:27,250 --> 00:09:29,900
and think actually a good debugger,

00:09:29,900 --> 00:09:32,150
you can spend time in a good debugger

00:09:32,150 --> 00:09:33,920
not actually debugging, just trying to work out

00:09:33,920 --> 00:09:37,995
what some piece of code that you've inherited does.

00:09:37,995 --> 00:09:41,900
Perhaps somebody has been very clever,

00:09:41,900 --> 00:09:43,840
and you need to find out just how clever they've been.

00:09:43,840 --> 00:09:46,030
Perhaps it was you, a few months ago.

00:09:46,030 --> 00:09:50,900
But it's just a general, what did the code do,

00:09:50,900 --> 00:09:51,830
kind of debuggers.

00:09:51,830 --> 00:09:54,800
I'm gonna cover both types a little bit today.

00:09:54,800 --> 00:09:57,040
They definitely both have their place.

00:09:57,040 --> 00:09:58,560
It's usually, if you can catch it in a checker,

00:09:58,560 --> 00:10:00,330
if you can catch it, I mean static analysis

00:10:00,330 --> 00:10:02,367
probably falls into that prevention thing,

00:10:02,367 --> 00:10:04,070
the isn't prevention better than cure,

00:10:04,070 --> 00:10:07,970
but it's still kind of, it's about root causing

00:10:07,970 --> 00:10:10,373
and extracting bugs from your code.

00:10:12,030 --> 00:10:14,730
So running a, I'd say this is roughly what I'm gonna try

00:10:14,730 --> 00:10:15,563
and touch on today.

00:10:15,563 --> 00:10:16,653
Lots of stuff.

00:10:18,355 --> 00:10:21,440
I'm not gonna cut exactly to schedule, but as I say,

00:10:21,440 --> 00:10:23,966
the point is that hopefully we'll see enough of these things

00:10:23,966 --> 00:10:25,840
that you'll say, oh yeah, okay, that's cool,

00:10:25,840 --> 00:10:27,610
I see how that could be useful for me,

00:10:27,610 --> 00:10:29,220
and maybe not too intimidating as well.

00:10:29,220 --> 00:10:30,560
I think a lot of these things,

00:10:30,560 --> 00:10:32,010
you hear about them somewhere,

00:10:32,010 --> 00:10:34,040
probably one of the smartest people you know

00:10:34,040 --> 00:10:35,290
talks about using it, and you think,

00:10:35,290 --> 00:10:36,860
gee, that sounds complicated.

00:10:36,860 --> 00:10:38,040
Actually, lots of these things

00:10:38,040 --> 00:10:42,020
really aren't that complicated, but as per the title

00:10:42,020 --> 00:10:44,580
of this talk, there's going to be a bit of GDB wizardry

00:10:44,580 --> 00:10:47,560
focusing on GDB, just touching some of the stuff.

00:10:47,560 --> 00:10:49,763
I gave a talk last year, two years ago,

00:10:50,830 --> 00:10:52,150
on some advanced GDB stuff.

00:10:52,150 --> 00:10:54,560
I'm gonna cover some different, little bit of overlap,

00:10:54,560 --> 00:10:55,393
little bit different stuff.

00:10:55,393 --> 00:10:59,150
I'm certainly not assuming that you saw

00:10:59,150 --> 00:11:02,224
any of my previous talks already.

00:11:02,224 --> 00:11:03,570
And all the rest of the stuff is new,

00:11:03,570 --> 00:11:06,540
is new, live demos to go wrong

00:11:06,540 --> 00:11:08,890
in all sorts of kinds of new and exciting ways.

00:11:10,460 --> 00:11:13,170
Okay, let's start then with GDB.

00:11:13,170 --> 00:11:16,320
So I think, it was in the abstract anyway,

00:11:16,320 --> 00:11:20,760
this is all Linux-specific, obviously C, C++ specific,

00:11:20,760 --> 00:11:21,593
'cause we're here.

00:11:21,593 --> 00:11:23,119
It's not really about C++, obviously,

00:11:23,119 --> 00:11:26,903
but it's about how you debug binary code, compiled code.

00:11:28,630 --> 00:11:31,840
So yeah, for GDB, it's certainly not intuitive.

00:11:31,840 --> 00:11:34,370
It can be very intimidating.

00:11:34,370 --> 00:11:35,770
It's perhaps, of all the tools, and having said

00:11:35,770 --> 00:11:38,508
that some of these tools sound complicated but easy to use

00:11:38,508 --> 00:11:42,300
or easy to learn, I think GDB probably

00:11:42,300 --> 00:11:45,500
is a good example of one that isn't.

00:11:45,500 --> 00:11:49,403
I think it is easy to use, just not to easy to learn.

00:11:50,570 --> 00:11:53,470
But once you've got the hang of it, it is pretty powerful.

00:11:57,380 --> 00:11:59,290
So the first thing I'm gonna talk about,

00:11:59,290 --> 00:12:01,039
and I find I'm always amazed by this,

00:12:01,039 --> 00:12:04,523
it's the one feature of GDB that I think is least,

00:12:05,721 --> 00:12:09,547
(mumbles) combination, least known and most useful.

00:12:11,300 --> 00:12:16,130
So here is a program, Hello, World

00:12:16,130 --> 00:12:18,810
with just a tiny little bit of extra stuff,

00:12:18,810 --> 00:12:20,510
and so I'm gonna compile it.

00:12:20,510 --> 00:12:23,610
Now, I need you to compile gcc you (mumbles) with -g.

00:12:23,610 --> 00:12:25,240
Actually, it's better to say that.

00:12:25,240 --> 00:12:28,650
That will generate, -ggdb3 will generate more,

00:12:28,650 --> 00:12:30,237
richer debugging information can be,

00:12:30,237 --> 00:12:34,340
and GDB can do much better job of in-lined functions,

00:12:34,340 --> 00:12:37,050
optimize the way data templates

00:12:37,050 --> 00:12:38,950
and all that kind of good stuff.

00:12:38,950 --> 00:12:41,130
So that's, and actually, using a very ancient debugger.

00:12:41,130 --> 00:12:43,380
That's probably a better argument to give it.

00:12:45,290 --> 00:12:46,479
Sorry?

00:12:46,479 --> 00:12:47,312
(man mumbling)

00:12:47,312 --> 00:12:48,470
Can I increase the font?

00:12:48,470 --> 00:12:50,543
Yeah, like that? Good.

00:12:52,480 --> 00:12:55,390
Okay, so made my little program, so now I'm gonna run it

00:12:55,390 --> 00:12:58,540
in GDB, and I'm gonna type start,

00:12:58,540 --> 00:13:01,310
which is basically the temporary breakpoint on main,

00:13:01,310 --> 00:13:03,417
and then continue, and here we are.

00:13:03,417 --> 00:13:08,417
So this is definitely better than Kernighan's 1979 world bit

00:13:11,760 --> 00:13:13,703
but then really not that much, so I can look at my program,

00:13:13,703 --> 00:13:15,090
I'll type list.

00:13:15,090 --> 00:13:18,210
Yeah, this is feeling an awful lot like 1979 actually.

00:13:18,210 --> 00:13:22,450
So let's bring GDB forward into the,

00:13:22,450 --> 00:13:25,910
screaming forward into the 80s by Control X + A,

00:13:25,910 --> 00:13:27,650
and I get my nice cursors interface,

00:13:27,650 --> 00:13:31,600
and now this is much more useful, and now I can next

00:13:31,600 --> 00:13:33,620
and it's much more like being in a debugger.

00:13:33,620 --> 00:13:36,070
So that's a very, very useful feature.

00:13:36,070 --> 00:13:38,710
It does kind of, is a bit temperamental, to be honest.

00:13:38,710 --> 00:13:40,640
It's like most cursors applications.

00:13:40,640 --> 00:13:42,080
It's worse than most cursors applications

00:13:42,080 --> 00:13:43,390
if you're running your program inside it

00:13:43,390 --> 00:13:44,223
like I'm doing here.

00:13:44,223 --> 00:13:45,970
I think it behaves better when you attach

00:13:45,970 --> 00:13:48,400
to a running process because here, it's kind of fighting

00:13:48,400 --> 00:13:50,990
for the terminal with the process that you're debugging,

00:13:50,990 --> 00:13:53,130
with what GDB calls the inferior.

00:13:53,130 --> 00:13:55,870
But nonetheless, we can get some multiple windows,

00:13:55,870 --> 00:13:59,230
so here I can step through the disassembly

00:13:59,230 --> 00:14:02,900
as well as the source code, for example, so all cool stuff.

00:14:02,900 --> 00:14:05,243
I'm not gonna spend too long on that.

00:14:07,380 --> 00:14:09,630
Control + L is very useful in TUI mode

00:14:09,630 --> 00:14:13,100
because it refreshes the screen and you need to do that

00:14:13,100 --> 00:14:14,460
more often than you might hope.

00:14:14,460 --> 00:14:15,640
Sometimes there's no way around it.

00:14:15,640 --> 00:14:17,170
You just have to start again.

00:14:17,170 --> 00:14:19,483
Yeah, terminals are messed up.

00:14:21,940 --> 00:14:25,410
Very, very briefly, my good friend Jeff Turow

00:14:25,410 --> 00:14:28,690
is gonna be talking about Python and GDB later on

00:14:28,690 --> 00:14:30,980
on Thursday, is that right?

00:14:30,980 --> 00:14:32,970
I say good friend, only met him about half an hour ago,

00:14:32,970 --> 00:14:35,973
but we're a conference, so that counts.

00:14:37,160 --> 00:14:38,877
But just very, very briefly then,

00:14:38,877 --> 00:14:42,170
to introduce the Python built into GDB.

00:14:42,170 --> 00:14:43,090
It's really powerful.

00:14:43,090 --> 00:14:45,923
You can do all kinds of cool stuff with it.

00:14:46,880 --> 00:14:49,643
So go like that.

00:14:51,610 --> 00:14:52,610
Or I can...

00:14:56,630 --> 00:15:00,573
I can import print I am pid.

00:15:06,070 --> 00:15:07,750
It's pretty, pretty, pretty complete.

00:15:07,750 --> 00:15:09,707
So it's not just shelling off the Python process

00:15:09,707 --> 00:15:14,020
and running that, and if I look at the processes here,

00:15:14,020 --> 00:15:15,700
so I can, if I want to shell off the process and do that,

00:15:15,700 --> 00:15:17,640
I can do that from the prompt with shell,

00:15:17,640 --> 00:15:21,767
and now I can see there are the pids that GDB is pid to 3905

00:15:23,040 --> 00:15:25,583
and sure enough, that's what it printed up there.

00:15:29,660 --> 00:15:33,380
Now there's a lot of, they've bound the Python interface

00:15:33,380 --> 00:15:35,190
to what's being debugged really quite tightly.

00:15:35,190 --> 00:15:37,070
There's all kinds of things you can do with breakpoints

00:15:37,070 --> 00:15:40,700
and exploring the data, and I'm gonna leave that

00:15:40,700 --> 00:15:45,700
to Jeff's talk to go into that into more detail,

00:15:46,090 --> 00:15:48,040
but those are just some of the commands

00:15:49,400 --> 00:15:50,540
you can just kind of get started.

00:15:50,540 --> 00:15:53,550
You can do, I'll just say heck of a lot with that scripting.

00:15:53,550 --> 00:15:54,523
It's very powerful.

00:15:55,960 --> 00:15:57,580
So I'm not gonna go into any of the details,

00:15:57,580 --> 00:15:59,210
as pretty-print is for STL.

00:15:59,210 --> 00:16:02,440
The only thing I will say, just one little note of advice

00:16:02,440 --> 00:16:06,060
that I've seen before is, generally, you can,

00:16:06,060 --> 00:16:09,410
generally, GDB will debug arbitrary binaries

00:16:09,410 --> 00:16:12,090
that you've made anywhere, and it works well for that.

00:16:12,090 --> 00:16:14,420
If you start trying to debug things like the STL

00:16:14,420 --> 00:16:19,420
using it's pretty-printers, you need to have used a similar,

00:16:20,230 --> 00:16:22,720
probably the same or similar distro

00:16:22,720 --> 00:16:25,220
to have compiled your program

00:16:25,220 --> 00:16:26,660
on which you are now debugging it.

00:16:26,660 --> 00:16:30,180
Otherwise, it gets, it all gets very confused

00:16:30,180 --> 00:16:32,580
with the pretty-printers that live on the machine

00:16:32,580 --> 00:16:33,880
on which you're debugging.

00:16:35,090 --> 00:16:36,840
So you can actually take a copy of the GDB binary

00:16:36,840 --> 00:16:38,540
and move that around quite easily.

00:16:39,391 --> 00:16:41,660
But then, yeah, that's the other thing I see quite a bit

00:16:41,660 --> 00:16:46,660
is the GDB, Python, if you're just using your nice Ubuntu

00:16:46,870 --> 00:16:48,620
or Fedora or whatever, and it's all packaged

00:16:48,620 --> 00:16:50,283
and it all works really well,

00:16:51,690 --> 00:16:54,227
if you start trying to take a GDB, for example,

00:16:54,227 --> 00:16:58,240
and run that GDB binary on another distro,

00:16:58,240 --> 00:17:01,720
it will kind of work, and even the Python integration

00:17:01,720 --> 00:17:03,340
will appear to work, but then it will try

00:17:03,340 --> 00:17:05,590
to use some of the Python libraries,

00:17:05,590 --> 00:17:07,160
and find that there's version mismatch

00:17:07,160 --> 00:17:11,008
between the GDB binary and the Python library,

00:17:11,008 --> 00:17:14,390
the Python interpreter that's inside the GDB

00:17:14,390 --> 00:17:17,310
and the libraries on the system that it's trying to use,

00:17:17,310 --> 00:17:21,037
so that's kind of some of the more commonly,

00:17:21,037 --> 00:17:23,820
just messed up configs that I've seen

00:17:23,820 --> 00:17:25,873
that cause all kinds of issues.

00:17:29,530 --> 00:17:31,180
My one advice, I think I said

00:17:31,180 --> 00:17:32,500
this wasn't gonna be any general advice.

00:17:32,500 --> 00:17:34,670
This is perhaps straying dangerously close to it,

00:17:34,670 --> 00:17:36,560
but the one bit of advice, again,

00:17:36,560 --> 00:17:38,650
this is just kind of pitfalls that I've seen before,

00:17:38,650 --> 00:17:41,713
keep your GDB in it nice and simple.

00:17:42,726 --> 00:17:44,700
I remember years ago, we had to help a customer

00:17:44,700 --> 00:17:46,480
who had some really weird behavior

00:17:46,480 --> 00:17:48,780
and all sorts of mad stuff was happening, and it turned out

00:17:48,780 --> 00:17:52,043
that they had a run command inside their .gdbinit,

00:17:52,043 --> 00:17:55,240
which was something we didn't think to test of ahead of time

00:17:55,240 --> 00:17:57,040
and we didn't quite handle properly.

00:17:58,560 --> 00:18:00,400
It's quite, I mean it's quite a good, if you can put your,

00:18:00,400 --> 00:18:03,070
a nice GDB in it, there's all kinds of functions and things

00:18:03,070 --> 00:18:05,435
in your source control and then source that

00:18:05,435 --> 00:18:07,530
from the GDB command line, that works.

00:18:07,530 --> 00:18:08,630
That works quite well.

00:18:11,610 --> 00:18:12,443
And the history save is good

00:18:12,443 --> 00:18:17,443
because that means your nice up arrow, get my commands

00:18:17,680 --> 00:18:20,730
from before, that saves then across sessions,

00:18:20,730 --> 00:18:23,760
so history save has nothing to do with reversible debugging

00:18:23,760 --> 00:18:26,650
or anything like that, but it just saves the commands

00:18:26,650 --> 00:18:30,610
but often, it's much nicer to type up arrow + Enter

00:18:30,610 --> 00:18:32,843
than actually have to type the thing in again.

00:18:34,620 --> 00:18:37,080
And yeah, pagination off and confirm off

00:18:37,080 --> 00:18:40,370
because if you're not living life, if you're not living life

00:18:40,370 --> 00:18:42,863
on the edge, then you're taking up too much space.

00:18:47,019 --> 00:18:49,630
Okay, little bit just about how GDB is implemented,

00:18:49,630 --> 00:18:51,370
because I think this is useful

00:18:51,370 --> 00:18:52,560
to really get the most out of it.

00:18:52,560 --> 00:18:54,670
You kind of have to, it's like old stuff.

00:18:54,670 --> 00:18:56,997
You can understand kind of the layer at the top

00:18:56,997 --> 00:18:59,850
and you can go so far, but if you do more layers down,

00:18:59,850 --> 00:19:03,270
you can understand, the more you shouldn't get out of it,

00:19:03,270 --> 00:19:06,950
and particularly, the way that GDB interacts with signals

00:19:08,180 --> 00:19:11,380
is, I think, kind of surprising at first.

00:19:11,380 --> 00:19:13,060
It really makes sense when you understand it

00:19:13,060 --> 00:19:14,490
but it's surprising at first.

00:19:14,490 --> 00:19:16,610
So the thing you need to know is that GDB is built on top

00:19:16,610 --> 00:19:21,473
of ptrace, which is like a really horrible API

00:19:22,550 --> 00:19:23,750
in the Linux kernel.

00:19:23,750 --> 00:19:26,430
I think it was inherited from releasing Solaris,

00:19:26,430 --> 00:19:28,493
possibly from longer ago than that.

00:19:30,230 --> 00:19:32,310
And yeah, it's an awful API but it works

00:19:32,310 --> 00:19:35,870
and so that's what, there's been a couple of attempts

00:19:35,870 --> 00:19:37,200
to replace it over the years,

00:19:37,200 --> 00:19:39,923
but none of them have really got traction.

00:19:42,360 --> 00:19:44,610
But so when GDP is running,

00:19:44,610 --> 00:19:46,230
when you're running the inferior, whether you've attached

00:19:46,230 --> 00:19:47,780
to a running process or whether you run it

00:19:47,780 --> 00:19:51,070
from the GDB command prompt, it's doing that

00:19:51,070 --> 00:19:54,430
under the control of ptrace, and the way ptrace works

00:19:54,430 --> 00:19:57,900
is when the inferior process, as GDB called it,

00:19:57,900 --> 00:20:01,496
when the tracee process receives a signal,

00:20:01,496 --> 00:20:04,120
it doesn't actually receive that signal.

00:20:04,120 --> 00:20:05,520
It stops at that point.

00:20:05,520 --> 00:20:07,440
Control is returned to the tracing process,

00:20:07,440 --> 00:20:09,560
which is GDB in this case, which will pick it up

00:20:09,560 --> 00:20:12,410
through a waitpid return, and then GDB can decide what to do

00:20:12,410 --> 00:20:15,800
and it can decide to just continue the program,

00:20:15,800 --> 00:20:18,373
throw that signal away, feed the signal in.

00:20:20,020 --> 00:20:21,473
So let's have a look.

00:20:26,380 --> 00:20:27,817
Oh, I'm gonna set (mumbles).

00:20:31,460 --> 00:20:34,760
So most of the signals, we've got Stop, Print,

00:20:34,760 --> 00:20:35,593
Pass to program.

00:20:35,593 --> 00:20:38,230
Most of the signals that, it'll do all those things,

00:20:38,230 --> 00:20:42,610
so when the inferior gets a SIGHUP, it'll stop,

00:20:42,610 --> 00:20:45,910
control returns to GDB prompt, and it will say,

00:20:45,910 --> 00:20:48,900
got a SIGHUP, and you can press continue, and if you do,

00:20:48,900 --> 00:20:51,355
that SIGHUP will then be passed into the program

00:20:51,355 --> 00:20:53,300
and if it has a handler, that handler will run,

00:20:53,300 --> 00:20:54,820
or if it doesn't, then it will do

00:20:54,820 --> 00:20:56,750
whatever the default action for that signal is,

00:20:56,750 --> 00:20:59,530
usually terminate, sometimes ignore, whatever,

00:20:59,530 --> 00:21:02,490
but some of them don't, so SIGINT, for example,

00:21:02,490 --> 00:21:06,040
that we treat specially, so when you're in your debuggee,

00:21:06,040 --> 00:21:08,490
your inferior process are inside GDB,

00:21:08,490 --> 00:21:10,900
and you hit Control + C to get control back.

00:21:10,900 --> 00:21:14,460
Well, at least if you've launched, if you've run the program

00:21:14,460 --> 00:21:17,060
from GDB prompt itself.

00:21:17,060 --> 00:21:19,455
GDB isn't doing anything special with that.

00:21:19,455 --> 00:21:21,970
It's just that when you type Control + C at the terminal,

00:21:21,970 --> 00:21:25,040
it will generate a SIGINT and deliver that to the program

00:21:25,040 --> 00:21:26,130
that's being run.

00:21:26,130 --> 00:21:28,860
Actually, every process inside the process group

00:21:28,860 --> 00:21:31,730
of which the terminal is the controlling terminal,

00:21:31,730 --> 00:21:36,400
I think, and so the normal thing happens, the process stops,

00:21:36,400 --> 00:21:38,720
GDB gets the notification that SIGINT has arrived

00:21:38,720 --> 00:21:41,270
and it returns to the prompt, and you type continue,

00:21:41,270 --> 00:21:43,600
and you'll notice the pass to program there

00:21:44,605 --> 00:21:47,480
for SIGINT is no, so that if you type continue,

00:21:47,480 --> 00:21:49,810
then that SIGINT will not be delivered to your program.

00:21:49,810 --> 00:21:51,990
So if your program you're debugging has a handler

00:21:51,990 --> 00:21:54,640
for SIGINT and relies on SIGINT being called,

00:21:54,640 --> 00:21:58,507
then you'll need to change that inside what you do with,

00:21:58,507 --> 00:22:03,033
you'd need to say handle SIGINT,

00:22:04,270 --> 00:22:08,710
and then you have print, stop print pass.

00:22:10,610 --> 00:22:13,733
I think if I want to go back to the original behavior,

00:22:15,920 --> 00:22:17,003
I'll do that.

00:22:18,754 --> 00:22:22,840
Okay, so I think that's, oh, SIGTRAP likewise,

00:22:22,840 --> 00:22:24,640
so when you hit a breakpoint,

00:22:24,640 --> 00:22:28,563
it'll just generate a SIGTRAP, and what GDB will do

00:22:28,563 --> 00:22:31,880
when it's a breakpoint is it'll change the code.

00:22:31,880 --> 00:22:34,391
I think it's architecture-specific, but certainly on x86,

00:22:34,391 --> 00:22:37,450
and probably most architectures,

00:22:37,450 --> 00:22:39,458
it will change the code.

00:22:39,458 --> 00:22:41,910
It will write the opcode to generate a trap.

00:22:41,910 --> 00:22:44,710
In the case of x86, it's the 0xCC opcode,

00:22:44,710 --> 00:22:47,543
which is a single byte opcode that generates a trap.

00:22:48,470 --> 00:22:49,560
Other architectures,

00:22:49,560 --> 00:22:51,300
it might generate different instructions,

00:22:51,300 --> 00:22:53,500
and it will just literally plonk that in the text section

00:22:53,500 --> 00:22:54,760
so when the program gets to it,

00:22:54,760 --> 00:22:58,230
the programmer receives a SIGTRAP, GDB stops,

00:22:58,230 --> 00:23:00,780
and returns to prompt, and again, I think if we go,

00:23:03,580 --> 00:23:07,673
we'll see SIGTRAP, which is here.

00:23:08,590 --> 00:23:11,743
Again, does not get passed to the program when you continue.

00:23:13,600 --> 00:23:14,433
Okay.

00:23:18,640 --> 00:23:20,900
So yeah, they'll actually, SIGINT SIGTRAP are used

00:23:20,900 --> 00:23:22,100
when you're normally debugging,

00:23:22,100 --> 00:23:24,380
but GDB doesn't actually hand, doesn't do anything

00:23:24,380 --> 00:23:26,780
particularly special with them other than responding

00:23:26,780 --> 00:23:29,110
to the SIGTRAP in the right way when it hits

00:23:29,110 --> 00:23:30,610
what it knows is a breakpoint.

00:23:32,024 --> 00:23:34,663
Watchpoints are, watchpoints are super cool.

00:23:35,880 --> 00:23:37,360
Really cool with reversible debugging

00:23:37,360 --> 00:23:39,476
which we'll show in a bit.

00:23:39,476 --> 00:23:42,910
So watch foo, so I'm sure most people

00:23:42,910 --> 00:23:44,763
will have had experience with this.

00:23:46,020 --> 00:23:48,110
And so yeah, you've watched and you continue

00:23:48,110 --> 00:23:51,295
and then when foo is not a foo, is a variable in this,

00:23:51,295 --> 00:23:53,230
assume leave a variable here, when foo is modified,

00:23:53,230 --> 00:23:56,110
it will stop and so you can run forward to the next time,

00:23:56,110 --> 00:23:57,723
and the foo is modified.

00:23:59,380 --> 00:24:02,530
It tries to be quite clever, and so foo is a local variable

00:24:02,530 --> 00:24:04,180
when it goes out of scope.

00:24:04,180 --> 00:24:06,040
GDB will actually set a breakpoint internally

00:24:06,040 --> 00:24:07,210
at that function.

00:24:07,210 --> 00:24:08,821
That's the end of that scope and then also, okay,

00:24:08,821 --> 00:24:11,671
that's no longer being watched because it's out of scope.

00:24:12,960 --> 00:24:15,570
Actually, if you're debugging compiled code,

00:24:15,570 --> 00:24:17,810
usually, what you care about is I want to watch that address

00:24:17,810 --> 00:24:20,200
'cause I've got some other stray pointer somewhere

00:24:20,200 --> 00:24:22,400
that's stamping on this or something.

00:24:22,400 --> 00:24:25,360
So watch -l, which is new-ish.

00:24:25,360 --> 00:24:26,573
I don't know (mumbles),

00:24:28,190 --> 00:24:31,200
anything new within a few years old will watch -location,

00:24:31,200 --> 00:24:33,450
and that won't try and do the clever

00:24:33,450 --> 00:24:36,322
when it goes out of scope, stop watching it thing,

00:24:36,322 --> 00:24:37,500
so if you've got some local variable that's being trashed,

00:24:37,500 --> 00:24:39,470
it'll just watch that address.

00:24:39,470 --> 00:24:41,763
Read watchpoints, so generally,

00:24:46,040 --> 00:24:49,070
actually, if the variable foo is written to,

00:24:49,070 --> 00:24:51,650
let's say foo gets an integer and it contained 42,

00:24:51,650 --> 00:24:55,050
if foo is written to and it's updated with the same value

00:24:55,050 --> 00:24:57,390
as before with 42, then it won't stop.

00:24:57,390 --> 00:25:00,370
That's not considered, the variable beta hasn't changed

00:25:00,370 --> 00:25:02,100
even though you actually physically wrote

00:25:02,100 --> 00:25:03,300
to that piece of memory.

00:25:05,340 --> 00:25:06,350
Just waiting for it to change,

00:25:06,350 --> 00:25:08,040
and rwatch is a read watchpoint,

00:25:08,040 --> 00:25:11,110
and if the architecture supports it, x86 does,

00:25:11,110 --> 00:25:15,670
then it can stop whenever that variable's being read,

00:25:15,670 --> 00:25:16,503
which is useful.

00:25:17,740 --> 00:25:20,050
And we can have thread-specific watchpoints

00:25:20,050 --> 00:25:22,980
and we can apply conditions and we can combine these

00:25:22,980 --> 00:25:24,873
in all kinds of useful ways.

00:25:29,270 --> 00:25:31,760
So thread apply, I think, is another useful command.

00:25:31,760 --> 00:25:33,977
Most commonly used, I think, with backtrace.

00:25:35,830 --> 00:25:39,060
So, often, especially if you're debugging some,

00:25:39,060 --> 00:25:40,420
someone else sends you an error report

00:25:40,420 --> 00:25:42,350
or some sort of bug report, and you just want to say,

00:25:42,350 --> 00:25:45,120
yeah, thread apply all backtrace full.

00:25:45,120 --> 00:25:46,930
That's nice, that will give you, let me show you that.

00:25:46,930 --> 00:25:49,503
That will give you a backtrace of,

00:25:51,531 --> 00:25:54,250
we're at a multi-threaded program now, so I've got,

00:25:54,250 --> 00:25:59,250
here's one I made earlier, so that's,

00:26:00,070 --> 00:26:01,590
that program, and if I run that,

00:26:01,590 --> 00:26:04,060
it's just got these 10 threads which were just up,

00:26:04,060 --> 00:26:06,960
just running around updating those values.

00:26:06,960 --> 00:26:08,310
So if I run that...

00:26:11,950 --> 00:26:13,270
All good.

00:26:13,270 --> 00:26:14,340
So as you probably know,

00:26:14,340 --> 00:26:18,050
info threads tells me all of the threads in my process

00:26:18,050 --> 00:26:23,050
and where they are, and yeah, thread apply or backtrace

00:26:23,290 --> 00:26:26,210
gives me a backtrace for all of my threads.

00:26:26,210 --> 00:26:29,367
Thread apply all backtrace full,

00:26:33,230 --> 00:26:36,090
including all the local variables, so that's kind of useful.

00:26:36,090 --> 00:26:39,960
I've only ever seen thread apply used with those options

00:26:39,960 --> 00:26:40,870
but you can do other things,

00:26:40,870 --> 00:26:44,995
so I can say thread apply 1-4 print,

00:26:44,995 --> 00:26:49,220
and $sp is a convenience variable for the stack pointer.

00:26:49,220 --> 00:26:53,233
And so thread apple. (chuckles)

00:26:55,234 --> 00:26:56,234
There we go.

00:27:05,170 --> 00:27:06,800
Dynamic printf, so much maligned printf.

00:27:06,800 --> 00:27:08,950
Printf is the worse debugging tool in the world

00:27:08,950 --> 00:27:11,980
except, of course, it's quite useful, but obviously,

00:27:11,980 --> 00:27:15,460
the worst thing about printf is that you have to think

00:27:15,460 --> 00:27:16,747
in advance where to put the printf,

00:27:16,747 --> 00:27:19,240
and you have to put the right one in with the right date,

00:27:19,240 --> 00:27:20,740
print out the right arguments.

00:27:21,850 --> 00:27:23,780
Otherwise, you need to recompile your program

00:27:23,780 --> 00:27:27,250
and deploy it again and run it again with the printf

00:27:27,250 --> 00:27:29,800
that you wish you'd put in the first place.

00:27:29,800 --> 00:27:34,800
Now, dynamic printf is halfway to solving that problem.

00:27:34,990 --> 00:27:39,163
So it's kind of neat, so we can go, so let's do,

00:27:40,620 --> 00:27:45,620
so dprintf, and it's, the syntax is a little bit arcane.

00:27:46,420 --> 00:27:51,360
I think it's, here it goes, right, yeah,

00:27:51,360 --> 00:27:53,203
so mutex_lock is my function.

00:27:55,545 --> 00:27:57,833
And so that's where I would put a breakpoint.

00:27:58,771 --> 00:28:01,070
I've got a feeling you have to do this without spaces,

00:28:01,070 --> 00:28:03,477
I can't remember, so I've got these mutex things

00:28:03,477 --> 00:28:04,820
that I have got in my little threaded program

00:28:04,820 --> 00:28:07,313
I just showed, and I've got a magic (mumbles) and...

00:28:14,550 --> 00:28:18,173
Okay so kinda crummy, but my program exited.

00:28:19,210 --> 00:28:21,910
But that's okay because I can just start it again

00:28:21,910 --> 00:28:23,590
and run, and there we are.

00:28:23,590 --> 00:28:25,300
Okay, so I've...

00:28:28,120 --> 00:28:28,960
That's...

00:28:30,710 --> 00:28:33,670
I wonder how many times that particular bug is made

00:28:33,670 --> 00:28:35,313
in the world every second.

00:28:36,350 --> 00:28:37,873
All right, there we go.

00:28:40,430 --> 00:28:41,820
Cool, so don't print, it's cool.

00:28:41,820 --> 00:28:44,040
It's a bit slow, I mean it's fast enough

00:28:44,040 --> 00:28:47,140
in this kind of case that we don't care at all.

00:28:47,140 --> 00:28:49,220
Particularly if you're remote debugging,

00:28:49,220 --> 00:28:51,400
which we'll probably won't get time to look at,

00:28:51,400 --> 00:28:53,170
but we'll touch on, if you're remote debugging,

00:28:53,170 --> 00:28:58,170
then it's very slow because what's happening internally

00:28:58,350 --> 00:29:01,140
is GDB is hitting a breakpoint on mutex_lock,

00:29:01,140 --> 00:29:02,770
control is returning to GDB,

00:29:02,770 --> 00:29:05,320
it's then running printf commands,

00:29:05,320 --> 00:29:07,870
like calling those inside the inferior to do the printing

00:29:07,870 --> 00:29:08,870
that it needs to do.

00:29:10,910 --> 00:29:12,540
Getting control back, removing that breakpoint

00:29:12,540 --> 00:29:15,160
and continuing, all of which is very slow,

00:29:15,160 --> 00:29:18,900
and all of which is really slow if you are remote debugging,

00:29:18,900 --> 00:29:23,290
so you can do this dprintf style agent.

00:29:23,290 --> 00:29:24,710
I'm sorry, the first, sorry, I lied.

00:29:24,710 --> 00:29:26,142
The first one, GDB.

00:29:26,142 --> 00:29:27,310
GDB will just figure out what the printf would have been.

00:29:27,310 --> 00:29:30,870
Call will call printf inside your program.

00:29:30,870 --> 00:29:31,940
An agent, if you're running,

00:29:31,940 --> 00:29:34,060
if you're doing remote debugging, so you've got a GDB server

00:29:34,060 --> 00:29:36,560
on some kind of target, it will do the printing

00:29:36,560 --> 00:29:40,633
inside that agent and it can save a lot of time.

00:29:42,180 --> 00:29:45,610
And it's reasonably configurable, as you can see,

00:29:45,610 --> 00:29:46,890
so dynamic printf is cool.

00:29:46,890 --> 00:29:50,930
I mean you still need to put the dprintf in

00:29:50,930 --> 00:29:53,450
before the actual bug has happened.

00:29:53,450 --> 00:29:56,140
You still need to catch it in the act,

00:29:56,140 --> 00:29:57,450
but at least you don't have to change your code

00:29:57,450 --> 00:29:59,540
and recompile your code to get that,

00:29:59,540 --> 00:30:01,323
get more printf info out.

00:30:02,983 --> 00:30:05,580
So I just touched on calling inferior functions,

00:30:05,580 --> 00:30:07,430
and so this is very useful.

00:30:07,430 --> 00:30:09,270
You can just type call foo from the command line

00:30:09,270 --> 00:30:10,970
and it will call the function foo.

00:30:12,430 --> 00:30:14,380
It can be surprising.

00:30:14,380 --> 00:30:17,463
Print foo+bar, if you're in C++ might,

00:30:18,410 --> 00:30:20,140
we might have overloaded the plus operator

00:30:20,140 --> 00:30:22,880
and so GDB is smart enough to figure that out.

00:30:22,880 --> 00:30:26,490
Well, smart enough, and so sometimes, that can be surprising

00:30:26,490 --> 00:30:27,600
that that might call.

00:30:27,600 --> 00:30:32,600
Print errno will call a function in your inferior

00:30:33,100 --> 00:30:37,460
because errno is a thread local and it's actually defined

00:30:37,460 --> 00:30:40,670
as a function called get errno address or Something,

00:30:40,670 --> 00:30:42,910
and GDB will just call that when you call print,

00:30:42,910 --> 00:30:44,310
when you type printer errno.

00:30:46,010 --> 00:30:47,880
And this one caught me out.

00:30:47,880 --> 00:30:49,442
Does my little pointer thing work?

00:30:49,442 --> 00:30:50,275
Good, I think it does.

00:30:50,275 --> 00:30:51,108
This one caught me out.

00:30:52,350 --> 00:30:54,640
Passing literal strings, so from the GDB prompt,

00:30:54,640 --> 00:30:56,893
I type call strcpy( buffer, "Hello, world!

00:30:58,120 --> 00:31:00,770
The first thing it will do is call malloc inside my program.

00:31:00,770 --> 00:31:03,310
So malloc a buffer into which it can put Hello world,

00:31:03,310 --> 00:31:06,293
and so if you're debugging your own malloc implementation,

00:31:07,730 --> 00:31:10,173
then yeah, that can get interesting.

00:31:11,390 --> 00:31:12,730
Catchpoints are very cool.

00:31:12,730 --> 00:31:14,230
I'm not gonna go into them in detail.

00:31:14,230 --> 00:31:16,452
They're kinda like breakpoints but they stop

00:31:16,452 --> 00:31:18,523
on a nominated system call.

00:31:21,740 --> 00:31:24,390
If you say catch syscall or you can catch exceptions,

00:31:25,340 --> 00:31:26,613
which also is useful.

00:31:27,530 --> 00:31:29,260
So yeah, kind of like breakpoints

00:31:29,260 --> 00:31:32,040
but rather than giving a line of code on which to stop,

00:31:32,040 --> 00:31:33,260
they give some kind of condition,

00:31:33,260 --> 00:31:35,733
something your program might do on which to stop.

00:31:38,720 --> 00:31:40,530
Remote debugging, I touched on.

00:31:40,530 --> 00:31:42,630
I think I'm gonna just put that up there so you can,

00:31:42,630 --> 00:31:47,070
I mean it's quite, very simple to use on the same machine,

00:31:47,070 --> 00:31:48,390
so here we're debugging over a socket,

00:31:48,390 --> 00:31:51,540
so you need to run this gdbserver, which is this little,

00:31:51,540 --> 00:31:55,350
little stub application that GDB will connect over a socket

00:31:55,350 --> 00:31:56,910
or whatever, which itself will then,

00:31:56,910 --> 00:32:00,973
then GDB server will debug the inferior using ptrace.

00:32:03,440 --> 00:32:05,550
Yeah, you can do multiprocess debugging, which is good,

00:32:05,550 --> 00:32:08,290
but we're kind of running out of time, but very quickly,

00:32:08,290 --> 00:32:11,000
so I can actually get multiple,

00:32:11,000 --> 00:32:13,057
I can debug multiple processes at same time,

00:32:13,057 --> 00:32:14,120
and it looks very like

00:32:14,120 --> 00:32:16,910
debugging a multi-threaded application.

00:32:16,910 --> 00:32:19,760
So if I just, I have to set the set follow-fork-mode

00:32:19,760 --> 00:32:23,890
child parent, and set, actually, so the key one

00:32:23,890 --> 00:32:25,913
is set detach-on-fork, so by default,

00:32:26,909 --> 00:32:29,310
GDB will detach on a fork from one of the parent

00:32:29,310 --> 00:32:30,210
or the child process,

00:32:30,210 --> 00:32:33,890
depending on what you set the follow fork mode to,

00:32:33,890 --> 00:32:38,890
but if you say detach-on-fork off, then it will continue

00:32:39,660 --> 00:32:44,340
to debug both the parent and the child process after a fork,

00:32:44,340 --> 00:32:46,170
and you can list, just like you say info threads

00:32:46,170 --> 00:32:48,450
to see all the running threads, you can go info inferiors

00:32:48,450 --> 00:32:51,410
and see all the running processes and switch between them,

00:32:51,410 --> 00:32:53,270
like you say thread one to switch to thread one,

00:32:53,270 --> 00:32:56,123
thread two, say inferior one or two.

00:32:57,577 --> 00:32:59,290
So that can be kind of handy if we've got lots of processes

00:32:59,290 --> 00:33:01,623
to debug and to keep in your head all at once,

00:33:02,637 --> 00:33:04,100
or you could just start to copy to GDB,

00:33:04,100 --> 00:33:06,220
whatever floats your boat.

00:33:06,220 --> 00:33:07,770
You can create your own commands in Python.

00:33:07,770 --> 00:33:10,300
I think Jeff is going to talk about this in more detail,

00:33:10,300 --> 00:33:12,020
and so won't go into that.

00:33:12,020 --> 00:33:13,810
You can have little stop handlers,

00:33:13,810 --> 00:33:15,310
so (mumbles) it's a Python that get called

00:33:15,310 --> 00:33:16,580
when certain things happen.

00:33:16,580 --> 00:33:18,350
Also very useful.

00:33:18,350 --> 00:33:19,610
You can do temporary breakpoints,

00:33:19,610 --> 00:33:21,840
you can have breakpoints on a regular expression,

00:33:21,840 --> 00:33:23,790
which is really neat if you want to stop on every,

00:33:23,790 --> 00:33:26,510
and if you've got some library that starts mylib underscore,

00:33:26,510 --> 00:33:28,540
though you can go mylib underscore dot star,

00:33:28,540 --> 00:33:30,680
and it will put a breakpoint on every function

00:33:30,680 --> 00:33:32,593
in your library's API.

00:33:37,320 --> 00:33:38,153
One little note,

00:33:38,153 --> 00:33:41,483
because people often get confused about this.

00:33:43,970 --> 00:33:46,720
Typically, we have debug builds and release builds,

00:33:46,720 --> 00:33:49,640
and in debug builds, we run them with low optimization,

00:33:49,640 --> 00:33:54,640
and debug to find not, not find, sorry,

00:33:56,660 --> 00:33:59,190
and so you got all your assertions in and everything else,

00:33:59,190 --> 00:34:01,520
and it can go a lot slower, depending on,

00:34:01,520 --> 00:34:04,770
I've heard of applications going like 10 times slower

00:34:04,770 --> 00:34:06,920
when they're running the debug build and a release build,

00:34:06,920 --> 00:34:09,130
and so people go, oh, I can't run GDB on my program

00:34:09,130 --> 00:34:11,420
because debug builds are too slow,

00:34:11,420 --> 00:34:15,240
and that life is, the world is more complicated

00:34:15,240 --> 00:34:18,880
than simply having the debug or release.

00:34:18,880 --> 00:34:20,630
They're just sort of conventions,

00:34:20,630 --> 00:34:24,120
and whatever optimization level you have and what debug info

00:34:24,120 --> 00:34:26,030
you're generating are completely orthogonal,

00:34:26,030 --> 00:34:30,340
and so you can have minus 09 and minus GDB3,

00:34:33,240 --> 00:34:35,350
and lots of debug info very optimized code.

00:34:35,350 --> 00:34:36,910
It'll be kind of weird when you debug it

00:34:36,910 --> 00:34:38,710
because you think you're stepping forwards a line

00:34:38,710 --> 00:34:42,050
and the compile has laid out code which you didn't expect,

00:34:42,050 --> 00:34:43,520
so you need to kind of, to be aware of that,

00:34:43,520 --> 00:34:44,353
but it will work,

00:34:44,353 --> 00:34:47,540
and there will be absolutely no runtime performance impact.

00:34:47,540 --> 00:34:49,920
In fact, the only thing you'll use is a bit more disk.

00:34:49,920 --> 00:34:51,440
You won't even, if you're not debugging it,

00:34:51,440 --> 00:34:55,330
you won't page in the debug info sections from disk,

00:34:55,330 --> 00:35:00,330
so just to correct that common misunderstanding.

00:35:05,570 --> 00:35:07,230
All right, enough GDB.

00:35:07,230 --> 00:35:09,090
Let's move on to other things.

00:35:09,090 --> 00:35:12,920
So valgrind, everyone calls it valgrind, but actually,

00:35:12,920 --> 00:35:13,970
it's called valgrind.

00:35:15,710 --> 00:35:16,880
I think, so I'm told.

00:35:16,880 --> 00:35:19,390
Anyway, actually, so the most common one is memch--

00:35:19,390 --> 00:35:21,720
It's a platform, you have all these tools, different tools.

00:35:21,720 --> 00:35:23,538
The most common one is memcheck.

00:35:23,538 --> 00:35:25,490
So they're kind of synonymous, valgrind and memcheck.

00:35:25,490 --> 00:35:27,120
When people say run valgrind on it,

00:35:27,120 --> 00:35:31,430
they often mean run valgrind with memcheck, which is fine.

00:35:31,430 --> 00:35:34,190
Then you've got these, actually so it does strike me,

00:35:34,190 --> 00:35:36,550
it's definitely called valgrind, not valgrind.

00:35:36,550 --> 00:35:38,553
I don't know how you say cachegrind

00:35:38,553 --> 00:35:39,386
'cause that doesn't sound right.

00:35:39,386 --> 00:35:41,230
Cachegrind and callgrind, but anyway,

00:35:41,230 --> 00:35:42,470
there are the other, these other tools

00:35:42,470 --> 00:35:45,683
that you can run within valgrind.

00:35:47,018 --> 00:35:49,640
It can be rather slow, but it just works,

00:35:49,640 --> 00:35:50,490
which is really neat.

00:35:50,490 --> 00:35:52,700
So you don't need to recompile your program,

00:35:52,700 --> 00:35:54,630
you don't need to link against any libraries.

00:35:54,630 --> 00:35:58,110
It's in most distros, so you can just apt install valgrind

00:35:58,110 --> 00:35:59,810
or whatever, and then just use it.

00:36:01,595 --> 00:36:04,770
I'm reminded of a real-world story of using this

00:36:04,770 --> 00:36:09,350
when I worked at my last proper job

00:36:09,350 --> 00:36:12,323
before I started doing Undo was,

00:36:13,170 --> 00:36:16,390
we had an LD_PRELOAD library which was doing kernel bypass

00:36:17,310 --> 00:36:20,860
kind of before that became a common thing,

00:36:20,860 --> 00:36:23,810
and very often, we get this one thing

00:36:23,810 --> 00:36:27,790
that became consistent in my old life and working in Undo

00:36:27,790 --> 00:36:30,667
is customers would often say, well, your stuff's broken,

00:36:30,667 --> 00:36:33,160
it's definitely broken 'cause I run my program

00:36:33,160 --> 00:36:36,160
without your kernel bypass library or without live recorder

00:36:36,160 --> 00:36:38,590
and it worked just fine, and I run it

00:36:38,590 --> 00:36:41,450
with your kernel bypass in set or, and it's broken.

00:36:41,450 --> 00:36:45,980
And like a lot, like most, certainly a good chunk

00:36:45,980 --> 00:36:47,690
of the time, in both cases, they're right.

00:36:47,690 --> 00:36:51,740
It is our stuff that's broken 'cause as I said,

00:36:51,740 --> 00:36:53,193
programming is hard.

00:36:54,120 --> 00:36:56,800
But some of the time, actually, is their program's broken

00:36:56,800 --> 00:36:58,923
and they just didn't notice,

00:36:59,913 --> 00:37:02,770
and so the guy I was working with at the time,

00:37:02,770 --> 00:37:05,600
very smart guys which couldn't believe,

00:37:05,600 --> 00:37:06,940
couldn't understand why our stuff was broken,

00:37:06,940 --> 00:37:08,820
so he just got a copy of their program and ran it

00:37:08,820 --> 00:37:10,300
with valgrind, and sure enough,

00:37:10,300 --> 00:37:14,440
there was some uninitialized data that was being accessed,

00:37:14,440 --> 00:37:16,590
and we could kind of point them at that, so let's show,

00:37:16,590 --> 00:37:18,850
let's show that in practice.

00:37:18,850 --> 00:37:23,850
So here's my little canned version of that bug.

00:37:24,220 --> 00:37:26,620
So here's a nice simple program.

00:37:26,620 --> 00:37:28,320
Of course, I compile it as normal.

00:37:32,010 --> 00:37:35,163
Run it, there's nothing wrong, that's legal.

00:37:36,860 --> 00:37:37,760
Just is undefined.

00:37:38,876 --> 00:37:43,393
So, let's run that inside valgrind,

00:37:45,010 --> 00:37:46,060
and see what happens.

00:37:47,130 --> 00:37:48,323
And so, oh yeah, look.

00:37:49,290 --> 00:37:51,540
Now you'll see it's saying, it's an instruction level thing,

00:37:51,540 --> 00:37:53,040
so what it's doing, actually,

00:37:53,040 --> 00:37:54,143
I asked if Undo works a bit like this.

00:37:54,143 --> 00:37:57,930
What it's doing is it's translating the machine code

00:37:57,930 --> 00:38:02,460
as it runs in a sort of JIT fashion and doing analysis

00:38:02,460 --> 00:38:07,317
on that code, so it's not simulated, but it is (mumbles).

00:38:09,130 --> 00:38:14,130
And of course, if you printf an undefined value,

00:38:15,440 --> 00:38:18,880
the first thing you notice is there's a jump,

00:38:18,880 --> 00:38:21,840
a conditional jump, based on the uninitialized data

00:38:21,840 --> 00:38:24,110
'cause printf is trying to turn your number,

00:38:24,110 --> 00:38:26,713
the number in this case, into a string.

00:38:28,750 --> 00:38:32,150
So it's kind of useful like that, but even more useful

00:38:32,150 --> 00:38:37,140
is you can combine it with GDB, and if I,

00:38:37,140 --> 00:38:40,110
now, the thing you got to remember that I just said,

00:38:40,110 --> 00:38:43,050
I said so valgrind is doing this translation,

00:38:43,050 --> 00:38:44,870
this binary translation of the code, so the code

00:38:44,870 --> 00:38:47,320
that you're executing is under valgrind.

00:38:47,320 --> 00:38:51,780
The code the CPU is executing is functionally identical

00:38:51,780 --> 00:38:56,720
to the original program, but it's got extra stuff in it,

00:38:56,720 --> 00:38:59,230
this different code, and so if you try to debug it

00:38:59,230 --> 00:39:02,730
through GDB in the normal way, you'll just see nonsense,

00:39:02,730 --> 00:39:06,450
because once it tries to, once GDB tries to look

00:39:06,450 --> 00:39:08,810
through ptrace, what it'll see is what the CPU sees,

00:39:08,810 --> 00:39:11,293
which is not what it was expecting to see.

00:39:14,629 --> 00:39:17,350
But valgrind has built into it, a GDB server,

00:39:17,350 --> 00:39:20,290
which you can connect to, and then you can start

00:39:20,290 --> 00:39:23,090
to do all the GDBs, and then the other thing

00:39:23,090 --> 00:39:24,600
we want to say here is if we do it like that,

00:39:24,600 --> 00:39:26,620
it'll just run to the end,

00:39:26,620 --> 00:39:31,620
so you can give it an error count like that.

00:39:32,054 --> 00:39:34,493
I think (mumbles), I don't think it matters but anyway,

00:39:35,440 --> 00:39:36,913
so this thing stopped after zero errors.

00:39:36,913 --> 00:39:37,940
I could say stop after 10 errors,

00:39:37,940 --> 00:39:40,300
and they stop after zero errors, which is gonna stop

00:39:40,300 --> 00:39:41,313
at the beginning.

00:39:44,960 --> 00:39:47,850
Sorry, there are different vgdb modes.

00:39:47,850 --> 00:39:49,690
Full is, I'm gonna use that

00:39:49,690 --> 00:39:52,070
'cause it doesn't have any surprising.

00:39:52,070 --> 00:39:54,923
There is on as well, on or full on,

00:39:56,420 --> 00:40:00,590
just so trades off performance for being,

00:40:00,590 --> 00:40:03,060
it's not incorrect but it just gets a bit weird at times,

00:40:03,060 --> 00:40:05,660
especially with, it can miss watchpoints and things.

00:40:06,730 --> 00:40:09,260
So now, I start valgrind like this,

00:40:09,260 --> 00:40:11,520
and now it's nicely telling me what I need,

00:40:11,520 --> 00:40:13,410
tells me exactly what I need to type somewhere else

00:40:13,410 --> 00:40:18,410
to get GDB to connect to this, the server inside valgrind.

00:40:19,370 --> 00:40:22,950
So it says I'm gonna run GDB a.out,

00:40:22,950 --> 00:40:27,010
so I can run that without, here I can run that

00:40:27,010 --> 00:40:28,183
without copy/paste.

00:40:29,800 --> 00:40:31,720
But the next bit, I can't run without copy/paste

00:40:31,720 --> 00:40:34,873
'cause it's more than nine characters, so,

00:40:37,060 --> 00:40:38,433
that line there.

00:40:46,500 --> 00:40:48,650
Okay, so here I am at the beginning of time,

00:40:48,650 --> 00:40:50,600
and then I can continue.

00:40:50,600 --> 00:40:51,920
As you can see, it's a little bit slow

00:40:51,920 --> 00:40:55,533
but it works just fine, and here I am inside this printf

00:40:56,447 --> 00:40:58,970
and I can get a backtrace, and I can see,

00:40:58,970 --> 00:41:01,130
what's wrong with my program frame 2, and here we are,

00:41:01,130 --> 00:41:04,470
accessing this uninitialized memory,

00:41:04,470 --> 00:41:07,197
so I can do all the all the GDB stuff to walk around

00:41:07,197 --> 00:41:09,913
and explore and try and get a bit more information.

00:41:10,840 --> 00:41:12,330
Now you can't combine, unfortunately,

00:41:12,330 --> 00:41:13,920
you can't combine valgrind

00:41:15,150 --> 00:41:17,200
with any kind of reversible debugging.

00:41:17,200 --> 00:41:18,450
That would be super cool.

00:41:19,490 --> 00:41:20,900
Can do it with AddressSanitizer and stuff,

00:41:20,900 --> 00:41:22,273
which we'll get to in a minute.

00:41:25,830 --> 00:41:27,163
Okay.

00:41:27,163 --> 00:41:29,010
Kind of getting on for time so let me try

00:41:29,010 --> 00:41:33,410
and speed on through.

00:41:33,410 --> 00:41:35,320
So yeah, a whole bunch of different tools.

00:41:35,320 --> 00:41:39,460
The default is memtool, which I think most people think of,

00:41:39,460 --> 00:41:41,750
as I say, all different things you can do with valgrind.

00:41:41,750 --> 00:41:44,240
Right, on sanitizers, which are kind of like valgrind

00:41:44,240 --> 00:41:46,380
but different, so unlike valgrind which will work

00:41:46,380 --> 00:41:48,550
on an unmodified program,

00:41:48,550 --> 00:41:50,510
the sanitizer's built into the compiler.

00:41:50,510 --> 00:41:53,240
Originally came in clang, and has been available in GCC

00:41:53,240 --> 00:41:55,443
for some time now as well.

00:41:56,510 --> 00:41:59,493
Slightly more arcane typing needed for GCC than in clang.

00:41:59,493 --> 00:42:01,890
I don't quite know why but that's what Google told me

00:42:01,890 --> 00:42:05,259
I had to do so that's what I did and it seems to work.

00:42:05,259 --> 00:42:09,580
Anyway, it's quite, it's much faster than valgrind.

00:42:09,580 --> 00:42:14,580
Valgrind will slow down by, can't be anything up like 100x.

00:42:15,110 --> 00:42:19,060
Can be more like 10 but it can be 100x, can be, yeah,

00:42:19,060 --> 00:42:20,163
can be very slow.

00:42:22,380 --> 00:42:25,430
The AddressSanitizers, and the other kind of sanitizers

00:42:25,430 --> 00:42:27,357
are much quicker, typically, 2x.

00:42:28,910 --> 00:42:30,730
So there's still, there's still an overhead

00:42:30,730 --> 00:42:32,970
because it's (mumbles), the compiler, basically,

00:42:32,970 --> 00:42:35,800
is instrumenting all your memory accesses,

00:42:35,800 --> 00:42:39,453
but it's doing it at the compiled time, so pros and cons.

00:42:40,400 --> 00:42:44,130
Also they do find different types of errors.

00:42:44,130 --> 00:42:46,686
There are some that's sort of an overlapping set of bugs

00:42:46,686 --> 00:42:47,973
that they'll find.

00:42:49,110 --> 00:42:53,680
So let's see, so I have,

00:42:53,680 --> 00:42:57,193
so I've got this out of bounds function,

00:42:58,060 --> 00:43:01,420
which is nicely written, so if I give it a number

00:43:01,420 --> 00:43:05,273
to (mumbles), it'll use that directly to indirect this,

00:43:06,280 --> 00:43:07,400
to reference this array here.

00:43:07,400 --> 00:43:11,300
So what did I say?

00:43:11,300 --> 00:43:14,060
Fsanitizer, it calls address and (groans) what's the,

00:43:19,690 --> 00:43:22,797
static-libasan out_bounds.

00:43:28,882 --> 00:43:31,049
Fsanitized, not sanitizer.

00:43:32,110 --> 00:43:37,110
Okay, so if I run this like this, it's fine 'cause that's,

00:43:37,500 --> 00:43:39,480
there's enough elements in my array to access.

00:43:39,480 --> 00:43:41,790
If I do it like this, it's a right activity array

00:43:41,790 --> 00:43:44,040
out of bound, and now my program has told me.

00:43:46,530 --> 00:43:51,320
Now, because this is actually running,

00:43:51,320 --> 00:43:53,200
this isn't doing the JIT binary translation stuff,

00:43:53,200 --> 00:43:55,190
this is really running on the hardware.

00:43:55,190 --> 00:43:58,670
You can combine this with other debugging tools just fine,

00:43:58,670 --> 00:44:00,300
so particularly, with reversible debugging,

00:44:00,300 --> 00:44:04,193
which is something close to my heart, just works.

00:44:05,490 --> 00:44:09,154
So let's first show some reversible debugging

00:44:09,154 --> 00:44:11,110
for those of you who've not seen it.

00:44:11,110 --> 00:44:13,823
So this is a program.

00:44:14,760 --> 00:44:17,913
Bubble sort of program which contains a bug.

00:44:22,150 --> 00:44:24,150
Which is one of those...

00:44:29,240 --> 00:44:31,430
Non-deterministic bugs so if I run it in a loop like that,

00:44:31,430 --> 00:44:36,073
it runs just fine until eventually, it doesn't.

00:44:39,080 --> 00:44:41,380
Now I've got, now I'm running with,

00:44:41,380 --> 00:44:44,800
I wanted to actually do this a different way.

00:44:44,800 --> 00:44:47,730
Anyway, let me, this has got the stacks motion detection

00:44:47,730 --> 00:44:49,590
but it actually slightly messes up this demo,

00:44:49,590 --> 00:44:50,423
so I'm gonna...

00:44:53,917 --> 00:44:56,270
I think that failed first time that time.

00:44:56,270 --> 00:44:57,923
No, it failed every time, okay,

00:44:59,410 --> 00:45:01,007
'cause it's the wrong (mumbles).

00:45:09,598 --> 00:45:10,431
So...

00:45:12,410 --> 00:45:14,983
Non-deterministic bug, it will fail.

00:45:24,140 --> 00:45:25,830
Eventually, that will fail and I'll try to look

00:45:25,830 --> 00:45:28,170
at a core file and I find out the core file is useful.

00:45:28,170 --> 00:45:29,370
You'll have to trust me.

00:45:31,140 --> 00:45:36,140
So, but I'm (mumbles), so gdb bubble sort.

00:45:38,720 --> 00:45:40,420
So I quite like this little trick.

00:45:41,392 --> 00:45:43,920
So I'm gonna run it with process record

00:45:43,920 --> 00:45:47,284
which is the inbuilt GDB reversible debugging stuff.

00:45:47,284 --> 00:45:49,910
So now I need to run it a whole bunch times.

00:45:49,910 --> 00:45:52,730
It doesn't usually, as we've seen, doesn't usually fail.

00:45:52,730 --> 00:45:55,310
So I'm gonna do, put a breakpoint on main.

00:45:55,310 --> 00:45:58,100
I'm gonna put a breakpoint on exit.

00:45:58,100 --> 00:46:02,670
I'm gonna put a condition commands one

00:46:02,670 --> 00:46:03,740
which is gonna run a bunch of commands

00:46:03,740 --> 00:46:05,680
every time it hits breakpoint one,

00:46:05,680 --> 00:46:08,220
and I'm gonna go continue, and I'm gonna, sorry,

00:46:08,220 --> 00:46:10,850
I'm gonna type record to start turn on process record,

00:46:10,850 --> 00:46:13,050
which is the bit that we need for reversible debugging,

00:46:13,050 --> 00:46:16,650
and I'm going to continue, and I'm gonna put a break,

00:46:16,650 --> 00:46:18,970
I'm gonna put my breakpoint on dash it on score exit,

00:46:18,970 --> 00:46:21,543
so commmand 2 and just gonna rerun.

00:46:22,490 --> 00:46:24,280
That's it, all set.

00:46:24,280 --> 00:46:26,670
I think I probably would've done this because of my,

00:46:26,670 --> 00:46:28,740
but I need set confirm off for that to work,

00:46:28,740 --> 00:46:31,407
and off we go.

00:46:31,407 --> 00:46:34,321
And this will keep running it with print,

00:46:34,321 --> 00:46:35,154
and you can see it's slow.

00:46:35,154 --> 00:46:37,350
It's a very, very simple program and it takes,

00:46:37,350 --> 00:46:39,640
now the slowdown of GDB process record

00:46:39,640 --> 00:46:42,320
is kinda bit like tens of thousands of times slowdown.

00:46:42,320 --> 00:46:44,860
What it's doing is single-stepping every single instruction,

00:46:44,860 --> 00:46:47,810
and recording what changed, so it uses lots of memory

00:46:47,810 --> 00:46:51,263
and it goes very slowly, but come on.

00:46:52,399 --> 00:46:53,649
It definitely will crash.

00:46:55,160 --> 00:46:56,910
And when it does, we can step back.

00:46:58,810 --> 00:47:00,410
You know I'm gonna leave that...

00:47:02,472 --> 00:47:04,614
Oh, damn (mumbles).

00:47:04,614 --> 00:47:05,700
Let me try something in parallel, see if we can't,

00:47:05,700 --> 00:47:09,870
let's also try it with the rr which is record and replay,

00:47:09,870 --> 00:47:13,463
so let's do the same so, so rr record,

00:47:15,477 --> 00:47:16,703
my bubble_sort program.

00:47:17,850 --> 00:47:19,710
Does this saves the trace,

00:47:19,710 --> 00:47:23,130
that I can subsequently go and debug.

00:47:23,130 --> 00:47:27,103
So let's just keep doing it.

00:47:31,371 --> 00:47:33,753
Oh no.

00:47:43,330 --> 00:47:45,170
What the (groan) it's crashed.

00:47:45,170 --> 00:47:47,070
Right, so both crashed, so here we are

00:47:47,070 --> 00:47:52,023
inside the process record, so backtrace is garbage.

00:47:53,480 --> 00:47:55,883
Just like, I'm in hyperspace.

00:47:57,019 --> 00:47:58,503
I can look at the program counter.

00:48:00,310 --> 00:48:02,140
That doesn't even look like a sensible address.

00:48:02,140 --> 00:48:03,460
X to examine the contents.

00:48:03,460 --> 00:48:07,650
No, there's no memory there, but I can reverse-stepi,

00:48:07,650 --> 00:48:11,060
or rsi, and that will just go back one instruction

00:48:11,060 --> 00:48:14,660
and now I'm back in insane land.

00:48:14,660 --> 00:48:16,210
I can kind of see where I am.

00:48:16,210 --> 00:48:19,023
Okay, so I'm at the end of the function.

00:48:21,355 --> 00:48:23,150
Let's have a look, so this little arrow here tells me yeah,

00:48:23,150 --> 00:48:23,983
I'm at the end here.

00:48:23,983 --> 00:48:24,920
There's return instructions.

00:48:24,920 --> 00:48:28,200
A return on x86 will pop what is ever on the stack

00:48:28,200 --> 00:48:31,173
and jump to that, so that's the stack pointer.

00:48:32,613 --> 00:48:34,143
If I examine that, whoop.

00:48:37,470 --> 00:48:40,200
Sure enough, that's that garbage address, isn't it?

00:48:40,200 --> 00:48:42,660
So I've got garbage on my stack.

00:48:42,660 --> 00:48:45,190
So I'm gonna set a watchpoint.

00:48:45,190 --> 00:48:50,019
I'm gonna watch that address like that,

00:48:50,019 --> 00:48:51,925
and then I'm gonna reverse continue,

00:48:51,925 --> 00:48:55,500
and sure enough, we've gone back in time.

00:48:55,500 --> 00:48:59,330
Unsurprisingly, to when this array is being written,

00:48:59,330 --> 00:49:04,330
and the array SI is 35, and if I go show type info,

00:49:08,158 --> 00:49:11,020
oh no (mumbles) ptype array.

00:49:11,020 --> 00:49:13,480
I can see the array is actually only 32 elements long,

00:49:13,480 --> 00:49:18,480
and obviously, my bug is the rand P (mumbles)

00:49:19,450 --> 00:49:22,680
module or size of array, which is the size in bytes

00:49:22,680 --> 00:49:24,740
rather than the size of elements.

00:49:24,740 --> 00:49:26,660
I ran it concurrently with rr.

00:49:26,660 --> 00:49:31,660
Considerably quicker, and non-interactive.

00:49:32,260 --> 00:49:33,670
Kind of works, look more like strace,

00:49:33,670 --> 00:49:36,160
which we'll cover in just a minute if we get time.

00:49:36,160 --> 00:49:39,450
So rr replay.

00:49:39,450 --> 00:49:42,683
Now this was the one, the last one that it ran,

00:49:43,520 --> 00:49:45,390
and so this is gonna look kind of similar.

00:49:45,390 --> 00:49:47,270
Now I'm at the beginning of time.

00:49:47,270 --> 00:49:48,350
Continue to the end.

00:49:48,350 --> 00:49:52,180
Here we are, we've got this (mumbles) at this random point

00:49:52,180 --> 00:49:55,030
and I can do all the stuff that I just do.

00:49:55,030 --> 00:49:56,810
So reverse step.

00:49:56,810 --> 00:49:58,340
I should think for some reason actually two reverse,

00:49:58,340 --> 00:50:01,983
so anyway, so reverse step there, and so I can watch.

00:50:04,529 --> 00:50:05,779
So the stack is now that.

00:50:06,900 --> 00:50:11,583
And so I can watch just like I did before.

00:50:15,900 --> 00:50:17,900
To reverse continue, and there we go.

00:50:17,900 --> 00:50:19,600
Right, so it's come down the same thing,

00:50:19,600 --> 00:50:20,610
only it's much quicker,

00:50:20,610 --> 00:50:23,630
and it's got this separate record and replay step.

00:50:23,630 --> 00:50:26,650
It is quite, it's a little bit, it needs to be running

00:50:26,650 --> 00:50:29,570
on the right system, so it must be x86,

00:50:29,570 --> 00:50:31,813
must be a relatively new Intel CPU

00:50:31,813 --> 00:50:32,920
that has the right support.

00:50:32,920 --> 00:50:35,960
Doesn't work on AMD, doesn't work on ARM or anything else.

00:50:35,960 --> 00:50:38,740
I need to be running not in a virtual light,

00:50:38,740 --> 00:50:42,203
not in a cloud environment like AWS or something,

00:50:42,203 --> 00:50:45,380
because they don't have the performance counters exported

00:50:45,380 --> 00:50:47,900
that it needs, but if it's got all the bits it needs,

00:50:47,900 --> 00:50:52,773
it's very cool, it's very fast and works well.

00:50:56,650 --> 00:51:01,650
So I want to go quickly.

00:51:01,890 --> 00:51:06,030
Kinda gonna run out of time but so quickly on to ftrace,

00:51:06,030 --> 00:51:08,940
which is a different thing, so it's a function tracer.

00:51:08,940 --> 00:51:11,540
It's kind of part, this is one of those part profiler,

00:51:11,540 --> 00:51:13,723
part debugger tools.

00:51:14,680 --> 00:51:19,570
And I'm going to talk through a little case study

00:51:21,040 --> 00:51:22,400
that we did it at Undo just a little while ago,

00:51:22,400 --> 00:51:24,127
so we have this thing that's kind of like rr

00:51:24,127 --> 00:51:25,493
but works in different way,

00:51:26,450 --> 00:51:29,273
and so it doesn't have some of the restrictions,

00:51:31,350 --> 00:51:32,940
and we had a customer who's integrating it

00:51:32,940 --> 00:51:33,900
into their test suite.

00:51:33,900 --> 00:51:35,670
It's very useful in that, so you run,

00:51:35,670 --> 00:51:36,800
when you've got those failures

00:51:36,800 --> 00:51:39,380
that just happen one in thousand times,

00:51:39,380 --> 00:51:40,430
and they're not, they're intermittent,

00:51:40,430 --> 00:51:41,850
not reproducible failures.

00:51:41,850 --> 00:51:44,400
You've got a recording and you can just debug that.

00:51:45,380 --> 00:51:48,180
Very, very useful, and so we're trying to integrate it,

00:51:48,180 --> 00:51:51,240
helping our customer integrate it into their test suite,

00:51:51,240 --> 00:51:55,490
and we got to kind of, we've got an exchange

00:51:55,490 --> 00:51:56,610
where a customer came to us and says,

00:51:56,610 --> 00:51:59,360
yeah, Live Recorder keeps dying, keeps getting SIGKILL.

00:52:00,550 --> 00:52:02,230
Think actually in the process I'm recording

00:52:02,230 --> 00:52:05,290
was getting SIGKILL (mumbles) things are dying with SIGKILL.

00:52:06,430 --> 00:52:07,580
So we said okay, well, you got

00:52:07,580 --> 00:52:08,830
this quite complex test suite.

00:52:08,830 --> 00:52:10,360
You sure you don't have some kind of process killer

00:52:10,360 --> 00:52:12,140
running around, killing stuff, and said, yeah,

00:52:12,140 --> 00:52:13,993
no, definitely not doing that.

00:52:13,993 --> 00:52:15,730
Said okay, so we take a look.

00:52:15,730 --> 00:52:18,100
So we had a look around, and after a while,

00:52:18,100 --> 00:52:19,700
we came back to them, we said, you're really sure

00:52:19,700 --> 00:52:20,880
you don't have some kind of process killer?

00:52:20,880 --> 00:52:22,830
And they said, yeah, 100%.

00:52:22,830 --> 00:52:25,200
Said, okay, so we said, can you run this script

00:52:25,200 --> 00:52:27,810
which was an ftrace script and have a look,

00:52:27,810 --> 00:52:31,450
and they ran that, and then we said, oh,

00:52:31,450 --> 00:52:34,110
we've seen a process called watchdog that's sending SIGKILL.

00:52:34,110 --> 00:52:34,943
What's that?

00:52:34,943 --> 00:52:37,610
And they went, hmm, have a look around.

00:52:37,610 --> 00:52:39,550
Oh yeah, that's this process killer we have

00:52:39,550 --> 00:52:41,080
in our test suite.

00:52:41,080 --> 00:52:46,080
So the script we sent them was this,

00:52:46,340 --> 00:52:49,070
and (mumbles) the whole script, but the point,

00:52:49,070 --> 00:52:51,220
the interesting stuff with this was here,

00:52:51,220 --> 00:52:53,830
so ftrace is controlled.

00:52:53,830 --> 00:52:54,937
There are some, there's a wrapper tool you can use

00:52:54,937 --> 00:52:57,880
that's quite cool but the low level, it's controlled

00:52:57,880 --> 00:53:02,880
by this sys kernel debug file system,

00:53:04,620 --> 00:53:07,040
and then you sort of poke different things into that,

00:53:07,040 --> 00:53:12,040
so let me show you essentially what we did here.

00:53:13,522 --> 00:53:18,522
So this is the, so you can just look at the trace.

00:53:19,150 --> 00:53:21,450
If I want to clear that trace, I can just...

00:53:24,560 --> 00:53:28,233
Sys/kernel/debug/tracing it's just echo,

00:53:30,490 --> 00:53:33,710
something at it, and it resets to trace,

00:53:33,710 --> 00:53:37,807
and so what we did here was told it to, first of all,

00:53:40,010 --> 00:53:44,290
tell it to enable signal tracing, and then, say, we're in,

00:53:44,290 --> 00:53:45,799
this is the filter.

00:53:45,799 --> 00:53:49,230
They're interesting in any signal, any signal, basically,

00:53:49,230 --> 00:53:52,220
and then you go echo 1 into tracing on,

00:53:52,220 --> 00:53:53,230
and that starts tracing,

00:53:53,230 --> 00:53:58,230
and now if I look at my trace file, there we go.

00:53:58,270 --> 00:54:00,230
Started to see some signals.

00:54:00,230 --> 00:54:02,170
So everything looking quite normal here.

00:54:02,170 --> 00:54:05,810
Just some sig-17, sorry I was just SIGCHILD, but yeah,

00:54:05,810 --> 00:54:08,410
you can see these two events are the generation

00:54:08,410 --> 00:54:09,870
of the signal and this is the process

00:54:09,870 --> 00:54:10,960
that generated the signal.

00:54:10,960 --> 00:54:13,360
Oh look, cat and bash, so this is me.

00:54:13,360 --> 00:54:14,883
So I think I'm only tracing.

00:54:16,270 --> 00:54:17,830
I said last time I did this, I did it for the whole system

00:54:17,830 --> 00:54:19,260
and somehow I've set this to only trace.

00:54:19,260 --> 00:54:21,570
I think for this process creep or something,

00:54:21,570 --> 00:54:23,320
oh no, no, no, no, no, there are other things

00:54:23,320 --> 00:54:25,520
happening as well here Xorg and the like.

00:54:25,520 --> 00:54:29,220
So, yeah, here you are, sig-14.

00:54:29,220 --> 00:54:32,120
That is SIGALARM, I think, and so you can see

00:54:32,120 --> 00:54:33,060
these two events, generations (mumbles)

00:54:33,060 --> 00:54:34,530
on the delivery of the signal.

00:54:34,530 --> 00:54:35,910
Typically, you'll see the two paired,

00:54:35,910 --> 00:54:36,920
not necessarily always.

00:54:36,920 --> 00:54:40,100
Depends if the, maybe the process has masked the signal

00:54:40,100 --> 00:54:41,250
or something like that.

00:54:42,240 --> 00:54:46,270
By the way, it's another thing, if your program masks SIGINT

00:54:46,270 --> 00:54:49,390
and you're in GDB and you try to Control + C, it won't.

00:54:49,390 --> 00:54:50,990
That's why when interrupted, but the program

00:54:50,990 --> 00:54:53,663
doesn't receive the SIGINT from the kernel.

00:54:56,400 --> 00:55:01,400
Cool, so that is, that is ftrace.

00:55:04,340 --> 00:55:06,983
Oh no, now we have to go through this whole story again.

00:55:12,930 --> 00:55:15,613
Strace is probably better known than ftrace,

00:55:17,153 --> 00:55:19,530
and you can trace all the system calls, so,

00:55:19,530 --> 00:55:20,880
but obviously, you did a little bit more like,

00:55:20,880 --> 00:55:22,960
then strace also is built on top of ptrace.

00:55:22,960 --> 00:55:24,880
So ptrace is the process,

00:55:24,880 --> 00:55:26,750
gets interrupted every time there's a signal.

00:55:26,750 --> 00:55:28,550
You can also configure ptrace to interrupt,

00:55:28,550 --> 00:55:30,300
to return when there's a system call,

00:55:30,300 --> 00:55:32,060
and it will output all the system calls

00:55:32,060 --> 00:55:33,270
being issued by the command.

00:55:33,270 --> 00:55:35,510
You can do all kinds of neat things.

00:55:35,510 --> 00:55:37,870
You can follow fork, you can write the output

00:55:37,870 --> 00:55:41,870
to a command file, to an output file, et cetera.

00:55:41,870 --> 00:55:45,593
Ltrace is like strace but rather than for the system calls,

00:55:46,430 --> 00:55:48,630
it's for library calls.

00:55:48,630 --> 00:55:51,280
And actually can be system calls as well if you want,

00:55:52,520 --> 00:55:54,990
and you can configure it

00:55:54,990 --> 00:55:58,220
to print out sort of certain useful things.

00:55:58,220 --> 00:56:01,190
Oh, I forgot the really cool thing in strace.

00:56:01,190 --> 00:56:03,984
- k, strace -k command gives you a little backtrace

00:56:03,984 --> 00:56:06,970
for each system call that's issued, which is super useful

00:56:06,970 --> 00:56:08,910
because usually, the system call

00:56:08,910 --> 00:56:10,590
is not directly what you want.

00:56:10,590 --> 00:56:11,423
Anyway, sorry.

00:56:12,470 --> 00:56:17,073
So yeah, that's ltrace, so should we simply...

00:56:19,790 --> 00:56:21,485
Show it to you one of these.

00:56:21,485 --> 00:56:24,070
Can't remember what program did I?

00:56:26,530 --> 00:56:31,457
Okay, let's do date, ltrace date,

00:56:32,437 --> 00:56:36,343
and you can see all the library calls and the system calls,

00:56:38,906 --> 00:56:42,953
and obviously, you can be more selective if you want.

00:56:42,953 --> 00:56:44,641
Perf trace is a new one to me.

00:56:44,641 --> 00:56:48,330
I would find this, it's like strace but better and worse,

00:56:48,330 --> 00:56:49,510
so better because it's a lot faster.

00:56:49,510 --> 00:56:51,850
So strace will slow down the program being traced

00:56:51,850 --> 00:56:53,510
quite a lot, particularly, if it's making lots

00:56:53,510 --> 00:56:55,410
of system calls, because every time the process

00:56:55,410 --> 00:56:58,960
makes a system call, it stops, and strace gets control,

00:56:58,960 --> 00:57:00,840
and it does some stuff, and it prints out,

00:57:00,840 --> 00:57:03,250
the system call has happened, and then it continues,

00:57:03,250 --> 00:57:04,960
and that takes time.

00:57:04,960 --> 00:57:07,010
This is built on perf,

00:57:07,010 --> 00:57:09,717
so it works kind of like ptrace, like strace.

00:57:10,950 --> 00:57:12,450
It's so much, much faster.

00:57:12,450 --> 00:57:13,880
It's quite flexible as well.

00:57:13,880 --> 00:57:16,060
You can actually get it to perf all the perf events,

00:57:16,060 --> 00:57:17,960
so all kinds of events like cache misses

00:57:17,960 --> 00:57:19,923
and all kinds of stuff.

00:57:21,530 --> 00:57:25,270
You do need to be root, and it also doesn't,

00:57:25,270 --> 00:57:26,700
it's also, I mean I think this will probably change

00:57:26,700 --> 00:57:28,580
over time but right now, so strace,

00:57:28,580 --> 00:57:30,990
if you've got a string argument, so if you're saying right,

00:57:30,990 --> 00:57:34,467
string to file descriptor, strace will follow the point

00:57:34,467 --> 00:57:36,610
and tell you the string, whereas perf trace

00:57:36,610 --> 00:57:38,640
will just show you the raw pointer.

00:57:38,640 --> 00:57:41,640
That's me running out of time.

00:57:41,640 --> 00:57:43,840
Fortify is very useful, so that would get the compiler

00:57:43,840 --> 00:57:46,290
to check certain things that it can.

00:57:46,290 --> 00:57:49,330
Reversible debugging, we've done.

00:57:49,330 --> 00:57:50,163
Oh, look at that.

00:57:50,163 --> 00:57:52,110
Just a bit quick at the end but I got there at the end,

00:57:52,110 --> 00:57:53,840
so thank you very much for that.

00:57:53,840 --> 00:57:54,900
Whizzed through all the things.

00:57:54,900 --> 00:57:57,290
Could have taken a bit more time.

00:57:57,290 --> 00:57:59,190
I don't think I have time for questions in this session

00:57:59,190 --> 00:58:01,730
but I'm happy to answer any questions at the end.

00:58:01,730 --> 00:58:03,080
How strict are we on time?

00:58:03,080 --> 00:58:03,990
Can we do questions?

00:58:03,990 --> 00:58:05,103
Just couple.

00:58:06,120 --> 00:58:07,203
No one's saying no.

00:58:09,870 --> 00:58:12,223
By just seeing everybody,

00:58:13,899 --> 00:58:15,410
and just suddenly thinking do I want questions

00:58:15,410 --> 00:58:16,243
in front of everybody.

00:58:16,243 --> 00:58:19,073
Probably, I don't, because I probably won't know the answer.

00:58:20,320 --> 00:58:21,160
I think that'll be it.

00:58:21,160 --> 00:58:22,901
All right, thank you very much, everyone.

00:58:22,901 --> 00:58:24,862

YouTube URL: https://www.youtube.com/watch?v=V1t6faOKjuQ


