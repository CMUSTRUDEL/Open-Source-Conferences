Title: CppCon 2018: Simon Brand “How to Write Well-Behaved Value Wrappers”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
There are many useful generic types which wrap a number of values up into one object, e.g. std::optional or std::tuple. These types are conceptually very simple, but designing and implementing them to be as optimal and consistent as possible is deceptively difficult. This talk will outline key considerations, show why they matter by examining the assembly generated from compilers, and describe a number of solutions for problems which arise. Finally, a number of C++ standards papers which could ease the implementation burden for these types will be discussed. 

Topics covered will include implicit/explicit constructors, conditional deletion of special member functions, propagation of special member triviality, noexcept correctness, private inheritance, and comparison operators.
— 
Simon Brand, Microsoft
C++ Developer Advocate

Simon is a C++ Developer Advocate at Microsoft. He turns into a metaprogramming fiend every full moon, when he can be found bringing compilers to their knees with template errors and debating undefined behaviour online. He co-organises the Edinburgh C++ user group and contributes to various programming standards bodies.

Outside of programming, he enjoys experimental films, homebrewing, and board games.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:07,020
hi I'm Simon I'm gonna tell you how to

00:00:03,449 --> 00:00:09,840
write well-behaved value wrappers before

00:00:07,020 --> 00:00:12,300
I go on to define those terms at

00:00:09,840 --> 00:00:13,710
Microsoft we have this survey which

00:00:12,300 --> 00:00:17,180
would be great if you can fill in and

00:00:13,710 --> 00:00:20,660
you can win an Xbox one yay

00:00:17,180 --> 00:00:26,310
yes thank you okay with that the way

00:00:20,660 --> 00:00:29,340
value wrappers what do I mean by mean is

00:00:26,310 --> 00:00:33,690
types with value semantics which can

00:00:29,340 --> 00:00:37,649
store objects of any type so some

00:00:33,690 --> 00:00:39,719
examples of this are stood pair optional

00:00:37,649 --> 00:00:41,940
variant all from the standard library

00:00:39,719 --> 00:00:44,579
and some of you may be familiar with

00:00:41,940 --> 00:00:48,020
Jonathan vacarro's name type library

00:00:44,579 --> 00:00:50,850
which he uses for his strong type posts

00:00:48,020 --> 00:00:53,489
and by value semantics I mean if you

00:00:50,850 --> 00:00:54,780
copy the wrapper you copy the value if

00:00:53,489 --> 00:00:58,260
you move the wrap and you move the value

00:00:54,780 --> 00:01:02,940
to act kind of like this was just an int

00:00:58,260 --> 00:01:05,220
or something like that well behaved I

00:01:02,940 --> 00:01:08,520
have two criteria I'm particularly

00:01:05,220 --> 00:01:12,540
interested in the first is one which

00:01:08,520 --> 00:01:14,970
hopefully we're all interested in as C++

00:01:12,540 --> 00:01:18,930
programmers we want our code to be fast

00:01:14,970 --> 00:01:20,280
and value wrappers can have some

00:01:18,930 --> 00:01:23,009
overhead if you do not write them

00:01:20,280 --> 00:01:25,710
correctly so I care about performance I

00:01:23,009 --> 00:01:28,920
want everything in this talk will either

00:01:25,710 --> 00:01:32,009
focus on performance or on being

00:01:28,920 --> 00:01:34,920
unsurprising now we all care about being

00:01:32,009 --> 00:01:37,049
performant but it seems like a lot of us

00:01:34,920 --> 00:01:41,460
in C++ do not care about being

00:01:37,049 --> 00:01:43,710
unsurprising well I do so I want to make

00:01:41,460 --> 00:01:46,020
these wrappers unsurprising we don't

00:01:43,710 --> 00:01:50,450
want all of these crazy edge cases which

00:01:46,020 --> 00:01:50,450
we hit so often in C++ world a

00:01:51,020 --> 00:01:56,790
cautionary tale

00:01:52,530 --> 00:02:00,990
I find this comment in the source code

00:01:56,790 --> 00:02:03,649
for a huge project one which I'm

00:02:00,990 --> 00:02:08,340
actually using to present these slides

00:02:03,649 --> 00:02:11,069
says nodes GCC has missed optimizations

00:02:08,340 --> 00:02:12,060
with maybe the type is talking about in

00:02:11,069 --> 00:02:14,850
the past

00:02:12,060 --> 00:02:19,560
and it may generate extra branches loads

00:02:14,850 --> 00:02:22,050
and stores use with caution on hot paths

00:02:19,560 --> 00:02:26,850
it is not known whether or not this is

00:02:22,050 --> 00:02:28,370
still a problem if the people who wrote

00:02:26,850 --> 00:02:30,989
this comment or watching this talk

00:02:28,370 --> 00:02:32,550
either in this room or later then

00:02:30,989 --> 00:02:34,739
hopefully you can apply some of these

00:02:32,550 --> 00:02:37,560
things I'm gonna be talking about it so

00:02:34,739 --> 00:02:41,730
you can get rid of this comment and

00:02:37,560 --> 00:02:43,860
actually fix the problem comparison

00:02:41,730 --> 00:02:48,690
operators starting off with something

00:02:43,860 --> 00:02:50,430
we're presumably all familiar with this

00:02:48,690 --> 00:02:52,800
is about the simplest wrapper type I

00:02:50,430 --> 00:02:59,900
could think of you know it takes a

00:02:52,800 --> 00:02:59,900
template parameter it stores it inside

00:03:00,260 --> 00:03:06,930
we might want to write this code we have

00:03:04,440 --> 00:03:09,209
a wrapper events and we like to be able

00:03:06,930 --> 00:03:11,760
to compare ents so maybe we want to be

00:03:09,209 --> 00:03:14,459
able to compare our wrappers as well in

00:03:11,760 --> 00:03:18,329
some cases we don't in a lot of cases we

00:03:14,459 --> 00:03:21,390
do and this will not compile unless we

00:03:18,329 --> 00:03:24,360
do some extra work so we could go ahead

00:03:21,390 --> 00:03:27,420
and do that work after noting that this

00:03:24,360 --> 00:03:32,540
is absolutely not surprising behavior

00:03:27,420 --> 00:03:32,540
for many cases we want this to compile

00:03:33,110 --> 00:03:38,209
so if we start with this blank slate go

00:03:36,030 --> 00:03:44,579
ahead write all our comparison operators

00:03:38,209 --> 00:03:46,560
might look something like this these are

00:03:44,579 --> 00:03:49,100
all the comparison operators for my

00:03:46,560 --> 00:03:51,299
implementation of still optional and

00:03:49,100 --> 00:03:52,530
this is pretty much exactly what you

00:03:51,299 --> 00:03:55,170
have to write if you want to implement

00:03:52,530 --> 00:03:57,750
this there's no getting out of doing

00:03:55,170 --> 00:03:59,910
this work you can implement some in

00:03:57,750 --> 00:04:01,470
terms of others sure but eventually you

00:03:59,910 --> 00:04:05,880
have to write all these overloads and

00:04:01,470 --> 00:04:09,060
it's not going to be pretty so now if we

00:04:05,880 --> 00:04:14,579
write all that it compiles so we are

00:04:09,060 --> 00:04:19,500
unsurprising but it's so much code that

00:04:14,579 --> 00:04:24,870
we do this so often and it just makes me

00:04:19,500 --> 00:04:25,830
so sad so anyone seen this film lego

00:04:24,870 --> 00:04:28,650
movie yeah

00:04:25,830 --> 00:04:33,930
great film my favorite character in the

00:04:28,650 --> 00:04:37,020
lego movie is this guy loves his

00:04:33,930 --> 00:04:38,060
spaceships he particularly likes this

00:04:37,020 --> 00:04:41,669
one

00:04:38,060 --> 00:04:46,020
then C++ instead of looking like this

00:04:41,669 --> 00:04:49,199
our spaceship looks like this so this is

00:04:46,020 --> 00:04:51,629
the new spaceship operator from C++ 20

00:04:49,199 --> 00:04:55,349
and it's going to solve some of our

00:04:51,629 --> 00:04:58,229
problems so it goes something like this

00:04:55,349 --> 00:05:01,919
we have two objects a and B which we

00:04:58,229 --> 00:05:05,159
want to compare so we do this spaceship

00:05:01,919 --> 00:05:07,440
operator on them and compare the result

00:05:05,159 --> 00:05:12,090
against zero that's going to tell us if

00:05:07,440 --> 00:05:14,819
it's greater less than or equal to the

00:05:12,090 --> 00:05:16,469
other one you don't tend to actually

00:05:14,819 --> 00:05:20,669
write the spaceship operator but this is

00:05:16,469 --> 00:05:24,030
kind of how it's defined so if we have a

00:05:20,669 --> 00:05:26,699
pair this is not exactly stood pair this

00:05:24,030 --> 00:05:29,340
is just like a simple pair and value

00:05:26,699 --> 00:05:31,650
wrapper type we can actually get the

00:05:29,340 --> 00:05:35,159
compiler to do essentially all our work

00:05:31,650 --> 00:05:38,940
for us if we write equals default then

00:05:35,159 --> 00:05:40,710
the compiler will generate comparison

00:05:38,940 --> 00:05:44,250
operators which lexicographically

00:05:40,710 --> 00:05:47,490
compare by member so we will first

00:05:44,250 --> 00:05:49,520
compare by T and then compare by U and

00:05:47,490 --> 00:05:53,909
it essentially does what you want Jason

00:05:49,520 --> 00:05:56,509
if the automatically constic Spur I

00:05:53,909 --> 00:05:59,669
can't remember off the top of my head I

00:05:56,509 --> 00:06:00,629
would hope that it would be and maybe

00:05:59,669 --> 00:06:03,000
you have to write that on the

00:06:00,629 --> 00:06:07,680
Declaration I'm not sure I can check

00:06:03,000 --> 00:06:10,770
afterwards and get back to you so this

00:06:07,680 --> 00:06:12,210
generates code is kind of like this you

00:06:10,770 --> 00:06:14,639
don't have to worry so much about the

00:06:12,210 --> 00:06:17,310
those data types and common comparison

00:06:14,639 --> 00:06:20,370
categories but of course this being C++

00:06:17,310 --> 00:06:22,050
it doesn't just return an int it returns

00:06:20,370 --> 00:06:25,139
something a lot more complicated which

00:06:22,050 --> 00:06:26,669
would be an entire talk on its own but

00:06:25,139 --> 00:06:31,409
you can see it's generating code to

00:06:26,669 --> 00:06:33,659
compare T and then compare you so now

00:06:31,409 --> 00:06:36,839
we've gone from all this code and with

00:06:33,659 --> 00:06:39,210
the power of spaceships we've gone to

00:06:36,839 --> 00:06:39,620
this this is code I stole from Barry

00:06:39,210 --> 00:06:42,889
Rebs

00:06:39,620 --> 00:06:49,430
blog post but this is so much easier yes

00:06:42,889 --> 00:06:52,160
Kayson right I did do have context were

00:06:49,430 --> 00:06:56,030
there you're right so that's probably

00:06:52,160 --> 00:06:57,380
needed for it to become stick spur so

00:06:56,030 --> 00:06:59,570
now we've gone from being unsurprising

00:06:57,380 --> 00:07:04,370
with a ton of code to just be playing

00:06:59,570 --> 00:07:06,620
unsurprising this is a huge win that's

00:07:04,370 --> 00:07:11,150
enough for comparison operators I'll

00:07:06,620 --> 00:07:14,720
move on to know except propagation so no

00:07:11,150 --> 00:07:17,090
accept is used quite a lot by some

00:07:14,720 --> 00:07:19,610
people not so much by others if you have

00:07:17,090 --> 00:07:23,060
one piece of advice you want to follow

00:07:19,610 --> 00:07:25,430
it's make sure that you propagate

00:07:23,060 --> 00:07:28,160
whether your move operations and your

00:07:25,430 --> 00:07:31,880
swap operations are no accept because

00:07:28,160 --> 00:07:33,680
this matters for swap people will write

00:07:31,880 --> 00:07:36,889
code which assumes this thing can never

00:07:33,680 --> 00:07:39,260
throw people use the the copy and swap

00:07:36,889 --> 00:07:40,280
idiom for example they will do this

00:07:39,260 --> 00:07:42,789
thing and if it throws you're gonna

00:07:40,280 --> 00:07:47,360
break someone's code don't do that

00:07:42,789 --> 00:07:51,349
remove has even more worth because say

00:07:47,360 --> 00:07:53,479
we we have this vector of optional and

00:07:51,349 --> 00:07:57,680
this tracer type is just something which

00:07:53,479 --> 00:08:01,340
keeps track of and copies and moves if

00:07:57,680 --> 00:08:03,410
we propagate know except correctly then

00:08:01,340 --> 00:08:06,470
we get hundreds thousand copies and more

00:08:03,410 --> 00:08:09,110
than 200 thousand moves but if we don't

00:08:06,470 --> 00:08:11,990
do this work then a bunch of those moves

00:08:09,110 --> 00:08:15,680
turn into copies because stood vector

00:08:11,990 --> 00:08:18,080
internally will not move the underlying

00:08:15,680 --> 00:08:20,419
objects if it could throw because then

00:08:18,080 --> 00:08:21,260
it could move something it throws the

00:08:20,419 --> 00:08:23,960
data is lost

00:08:21,260 --> 00:08:28,310
we hate data loss so vector doesn't do

00:08:23,960 --> 00:08:31,039
that and you do this by say we have a

00:08:28,310 --> 00:08:32,000
move constructor for optional here do

00:08:31,039 --> 00:08:34,490
not to worry much about the

00:08:32,000 --> 00:08:40,550
implementation but we can do something

00:08:34,490 --> 00:08:42,560
like this add no except and check if the

00:08:40,550 --> 00:08:44,720
underlying type is no throw move

00:08:42,560 --> 00:08:48,200
constructible if it is then this is no

00:08:44,720 --> 00:08:52,820
except if it's not it's not so this does

00:08:48,200 --> 00:08:54,070
our work for us you may be familiar with

00:08:52,820 --> 00:08:58,400
this quote

00:08:54,070 --> 00:09:03,490
- explicit or not - explicit that is the

00:08:58,400 --> 00:09:03,490
question and that indeed is the question

00:09:03,910 --> 00:09:11,780
say again we have our rapper type this

00:09:08,750 --> 00:09:13,940
would be a compiler error we have a

00:09:11,780 --> 00:09:18,050
rapper events we try and initialize it

00:09:13,940 --> 00:09:23,690
with an int seems reasonable but it

00:09:18,050 --> 00:09:25,250
doesn't compile so maybe we say okay

00:09:23,690 --> 00:09:28,870
this is fine I'll write constructor

00:09:25,250 --> 00:09:31,160
which takes a T and this is fine

00:09:28,870 --> 00:09:33,740
obviously some of you are super smart

00:09:31,160 --> 00:09:37,280
and you'll be haha yeah he's perfect for

00:09:33,740 --> 00:09:41,540
wording feel very very happy with

00:09:37,280 --> 00:09:43,640
ourselves very pleased but then someone

00:09:41,540 --> 00:09:50,420
comes along and writes this very aptly

00:09:43,640 --> 00:09:52,810
named type oh no this has an explicit

00:09:50,420 --> 00:09:55,220
constructor from bool

00:09:52,810 --> 00:09:57,730
so then if someone tape it writes a

00:09:55,220 --> 00:10:01,550
function which takes a wrapper of oh no

00:09:57,730 --> 00:10:04,370
then we can pass true and it will

00:10:01,550 --> 00:10:06,020
implicitly convert even though the

00:10:04,370 --> 00:10:07,370
author of this type presumably put

00:10:06,020 --> 00:10:14,210
explicit there for a reason

00:10:07,370 --> 00:10:18,530
oh no so this is surprising we don't

00:10:14,210 --> 00:10:22,220
want this so what we usually do at the

00:10:18,530 --> 00:10:26,120
moment is you write two overloads and we

00:10:22,220 --> 00:10:29,900
use X V na like still enable it to

00:10:26,120 --> 00:10:31,640
select between them so don't worry if

00:10:29,900 --> 00:10:34,910
you don't understand enable if it

00:10:31,640 --> 00:10:39,140
essentially means that this version will

00:10:34,910 --> 00:10:42,380
only be a candidate if those things

00:10:39,140 --> 00:10:44,960
evaluate to true so we have one version

00:10:42,380 --> 00:10:47,390
which is not explicit and we have one

00:10:44,960 --> 00:10:48,620
version which is explicit and the only

00:10:47,390 --> 00:10:50,990
thing we switch is this

00:10:48,620 --> 00:10:53,540
it's convertible so if the underlying

00:10:50,990 --> 00:10:58,850
type converts implicitly then we convert

00:10:53,540 --> 00:11:03,360
implicitly otherwise we don't I know

00:10:58,850 --> 00:11:07,649
this compiles and it's great and this

00:11:03,360 --> 00:11:11,670
doesn't compile just as we hoped so

00:11:07,649 --> 00:11:16,250
we're unsurprising but with code

00:11:11,670 --> 00:11:19,170
duplication so this isn't great

00:11:16,250 --> 00:11:22,350
we have no except bill we mentioned it

00:11:19,170 --> 00:11:25,019
literally in the last section what if we

00:11:22,350 --> 00:11:29,490
could have explicit bill this would

00:11:25,019 --> 00:11:33,959
solve our problem instead of having two

00:11:29,490 --> 00:11:36,959
overloads one which is explicit one

00:11:33,959 --> 00:11:40,500
which isn't we just move this is

00:11:36,959 --> 00:11:44,040
convertible thing down into this

00:11:40,500 --> 00:11:46,670
explicit specifier mr the same thing but

00:11:44,040 --> 00:11:53,940
it's just one overload the code is clear

00:11:46,670 --> 00:11:56,670
for some definition of clear for now

00:11:53,940 --> 00:11:58,740
we've gone from unsurprising with code

00:11:56,670 --> 00:12:02,399
duplication to just being unsurprising

00:11:58,740 --> 00:12:05,700
success and this explicit operator is

00:12:02,399 --> 00:12:09,570
actually in C++ 20 so if you happen to

00:12:05,700 --> 00:12:15,690
use C++ 20 then oh great but also you

00:12:09,570 --> 00:12:17,459
can use this yes if you have a time

00:12:15,690 --> 00:12:20,430
machine cache wizards you can use it and

00:12:17,459 --> 00:12:22,140
that's true okay conditionally deleting

00:12:20,430 --> 00:12:29,370
special members now we're getting into

00:12:22,140 --> 00:12:31,560
some arcane stuff so if we have a simple

00:12:29,370 --> 00:12:34,350
imitation of optional here it's

00:12:31,560 --> 00:12:36,480
essentially just a union of a tea and

00:12:34,350 --> 00:12:38,339
some like dummy type that we don't care

00:12:36,480 --> 00:12:42,779
about and then we have a brilliant to

00:12:38,339 --> 00:12:46,140
say weather or engaged or not so if we

00:12:42,779 --> 00:12:48,709
have a copy constructor like this it's

00:12:46,140 --> 00:13:03,089
just kind of normal copy constructor and

00:12:48,709 --> 00:13:06,120
we have a normal distribution just

00:13:03,089 --> 00:13:07,529
default your your operators because it

00:13:06,120 --> 00:13:10,500
might have to delete it might not it

00:13:07,529 --> 00:13:12,060
might have to copy it might not so in

00:13:10,500 --> 00:13:13,529
cases where you do have to write your

00:13:12,060 --> 00:13:15,270
own copy constructors and your own

00:13:13,529 --> 00:13:16,470
destructors you need to think about

00:13:15,270 --> 00:13:20,220
whether you have to conduct

00:13:16,470 --> 00:13:24,000
can we delete your special members so

00:13:20,220 --> 00:13:26,460
this is like not a very good reason but

00:13:24,000 --> 00:13:28,800
part of a reason as you get better error

00:13:26,460 --> 00:13:31,890
message in the first case where we don't

00:13:28,800 --> 00:13:34,610
delete then we kind of get something

00:13:31,890 --> 00:13:37,200
which is internal to the implementation

00:13:34,610 --> 00:13:39,000
rather than just saying what went wrong

00:13:37,200 --> 00:13:46,110
we had a deleted copy constructor of

00:13:39,000 --> 00:13:47,730
optional more important is if we want to

00:13:46,110 --> 00:13:50,100
check if something copy constructible

00:13:47,730 --> 00:13:54,330
say we want to ask Fein a on this say we

00:13:50,100 --> 00:13:55,320
want to do Const x4 if we will get the

00:13:54,330 --> 00:13:58,610
wrong answer

00:13:55,320 --> 00:14:01,920
if we don't propagate our deletion

00:13:58,610 --> 00:14:04,650
because it's not Sen a friendly

00:14:01,920 --> 00:14:05,760
essentially so if we do not do this we

00:14:04,650 --> 00:14:08,570
get the wrong answer and this can lead

00:14:05,760 --> 00:14:12,300
to surprising errors your code will hard

00:14:08,570 --> 00:14:20,310
compiler error even if you think that it

00:14:12,300 --> 00:14:22,320
shouldn't so this is surprising again so

00:14:20,310 --> 00:14:25,710
again back to our simple optional

00:14:22,320 --> 00:14:27,450
implementation what you actually kind of

00:14:25,710 --> 00:14:29,970
need to do at the moment is you you make

00:14:27,450 --> 00:14:32,670
a base class you shove all of your

00:14:29,970 --> 00:14:35,310
details or all of your members into this

00:14:32,670 --> 00:14:37,700
base class and then you privately

00:14:35,310 --> 00:14:40,170
inherit from this class and you

00:14:37,700 --> 00:14:42,150
privately inherit from something which

00:14:40,170 --> 00:14:45,000
will delete your constructors and your

00:14:42,150 --> 00:14:47,760
assignment operators you kind of have to

00:14:45,000 --> 00:14:50,730
do this with inheritance just because of

00:14:47,760 --> 00:14:55,380
how deletion of special member functions

00:14:50,730 --> 00:14:58,050
works and so this these delete seat or

00:14:55,380 --> 00:15:00,630
base and assign bases they look

00:14:58,050 --> 00:15:02,730
something like this we have like a class

00:15:00,630 --> 00:15:05,930
which will check if it's coffee

00:15:02,730 --> 00:15:09,810
constructible and move constructible and

00:15:05,930 --> 00:15:11,760
then we have a specialization so if

00:15:09,810 --> 00:15:14,310
these are both true then they're both

00:15:11,760 --> 00:15:17,060
defaulted if it's true and false then

00:15:14,310 --> 00:15:21,570
it's default delete delete default

00:15:17,060 --> 00:15:23,220
delete delete make sense just dealing

00:15:21,570 --> 00:15:24,780
with all the different cases and we do

00:15:23,220 --> 00:15:28,610
have to write all that code each time

00:15:24,780 --> 00:15:28,610
even though it's essentially the same

00:15:29,620 --> 00:15:35,529
and then we do the same for delete a

00:15:30,700 --> 00:15:37,120
sign base and so this will now do the

00:15:35,529 --> 00:15:40,750
right thing if we try and check if it's

00:15:37,120 --> 00:15:45,210
copy constructible so we're going to be

00:15:40,750 --> 00:15:49,680
unsurprising but a ton of code again

00:15:45,210 --> 00:15:49,680
maybe seeing a pattern developing here

00:15:50,100 --> 00:15:56,620
so concepts would help a lot with this

00:15:53,250 --> 00:15:58,930
because we can actually constrain non

00:15:56,620 --> 00:16:02,490
templates like this you say we require

00:15:58,930 --> 00:16:05,410
its copy constructible and require our

00:16:02,490 --> 00:16:07,690
move constructor the underlying type is

00:16:05,410 --> 00:16:11,940
moved constructible and then do all our

00:16:07,690 --> 00:16:14,230
work in there and this is great because

00:16:11,940 --> 00:16:16,300
we've gone from being on surprising with

00:16:14,230 --> 00:16:22,029
a ton of code to being unsurprising

00:16:16,300 --> 00:16:25,510
again triviality propagation who's even

00:16:22,029 --> 00:16:30,190
familiar with the idea of trivial copy

00:16:25,510 --> 00:16:32,710
constructability maybe about quarter

00:16:30,190 --> 00:16:35,890
third of the room or something okay so

00:16:32,710 --> 00:16:38,650
this is getting a bit weird this is the

00:16:35,890 --> 00:16:45,000
system of five system five system VI can

00:16:38,650 --> 00:16:47,500
never remember the holy tome a quote an

00:16:45,000 --> 00:16:50,140
object with either a non-trivial copy

00:16:47,500 --> 00:16:53,980
constructor or a non-trivial destructor

00:16:50,140 --> 00:16:56,400
cannot be passed by value because some

00:16:53,980 --> 00:17:01,060
objects must have well-defined addresses

00:16:56,400 --> 00:17:05,140
now this isn't meaning like quite C++

00:17:01,060 --> 00:17:08,770
passed by value but it does mean like

00:17:05,140 --> 00:17:11,020
putting it on the stack versus passing

00:17:08,770 --> 00:17:13,000
it in registers passing in registers as

00:17:11,020 --> 00:17:14,230
copying is passing by value in this case

00:17:13,000 --> 00:17:20,290
because you're just copying it into a

00:17:14,230 --> 00:17:22,059
register so this is important I'm so

00:17:20,290 --> 00:17:26,079
trivial copy constructor is defined as

00:17:22,059 --> 00:17:29,980
this the coffee constructor has to be

00:17:26,079 --> 00:17:31,900
defaulted or implicitly defined there's

00:17:29,980 --> 00:17:34,960
some extra wording in there but I kind

00:17:31,900 --> 00:17:36,730
of want to keep it simple can't have any

00:17:34,960 --> 00:17:39,010
virtual member functions or base classes

00:17:36,730 --> 00:17:41,500
and all of the base and member coughing

00:17:39,010 --> 00:17:43,120
instructors have to be trivial kind of

00:17:41,500 --> 00:17:46,120
like you might expect

00:17:43,120 --> 00:17:54,610
and it's very much the same for the DSO

00:17:46,120 --> 00:17:57,010
a question no virtual base classes yes

00:17:54,610 --> 00:17:58,809
so the question was is no base classes

00:17:57,010 --> 00:18:02,050
at all or no virtual base classes just

00:17:58,809 --> 00:18:04,450
virtual base classes and the trivial

00:18:02,050 --> 00:18:10,809
destructor is is essentially very much

00:18:04,450 --> 00:18:15,610
similar so we could actually have a

00:18:10,809 --> 00:18:17,410
static assert which says if it checks if

00:18:15,610 --> 00:18:19,420
my optional int is copy and strip

00:18:17,410 --> 00:18:21,540
trivially copy constructible then

00:18:19,420 --> 00:18:25,960
currently this would compiler error

00:18:21,540 --> 00:18:28,120
which means because what the ABI says we

00:18:25,960 --> 00:18:33,030
cannot pass an optional int in a

00:18:28,120 --> 00:18:34,809
register because this check fails

00:18:33,030 --> 00:18:38,020
similarly for it's trivially

00:18:34,809 --> 00:18:46,360
destructible same thing and this is not

00:18:38,020 --> 00:18:50,170
performant pardon because says it's not

00:18:46,360 --> 00:18:53,140
a word and sure it is for the purposes

00:18:50,170 --> 00:18:56,410
of this talk I define what is purpose to

00:18:53,140 --> 00:18:59,980
go okay so this is some some assembly

00:18:56,410 --> 00:19:03,640
code produced courtesy of not God bolt

00:18:59,980 --> 00:19:06,850
and so you can see if I do not propagate

00:19:03,640 --> 00:19:09,130
then essentially pass things on the

00:19:06,850 --> 00:19:11,650
stack and if I do propagate the

00:19:09,130 --> 00:19:14,110
triviality then the compiler just works

00:19:11,650 --> 00:19:19,050
out what value are in this case 42

00:19:14,110 --> 00:19:19,050
because of course and it just moves it

00:19:19,260 --> 00:19:29,440
into the register and just works gets

00:19:24,610 --> 00:19:32,050
even worse if I start to pass this as as

00:19:29,440 --> 00:19:33,640
a function argument you see this is

00:19:32,050 --> 00:19:37,630
starting to be more code using stack

00:19:33,640 --> 00:19:40,059
more and then if I don't propagate

00:19:37,630 --> 00:19:43,540
trivially destructibility then it gets

00:19:40,059 --> 00:19:47,380
even worse and then even worse if I use

00:19:43,540 --> 00:19:49,780
vectors and this is not so bad it's

00:19:47,380 --> 00:19:51,820
essentially an unrolled loop just throw

00:19:49,780 --> 00:19:54,280
it disrupting all the underlying objects

00:19:51,820 --> 00:19:56,250
you can see how this kind of thing when

00:19:54,280 --> 00:19:57,990
I'm just trying to use any

00:19:56,250 --> 00:20:02,690
that's not great we want this to be

00:19:57,990 --> 00:20:05,730
stuff to be fast and so say we have our

00:20:02,690 --> 00:20:09,740
disruptor here well a lot of people say

00:20:05,730 --> 00:20:16,850
oh it's fine we just use SVA it'll work

00:20:09,740 --> 00:20:19,049
no does not work you cannot have

00:20:16,850 --> 00:20:20,580
disruptors or copy constructors and move

00:20:19,049 --> 00:20:24,330
constructors which are templates so you

00:20:20,580 --> 00:20:27,570
can tasking in them away them's the

00:20:24,330 --> 00:20:33,510
rules I don't make them what you can do

00:20:27,570 --> 00:20:36,720
is make base classes again private base

00:20:33,510 --> 00:20:37,830
classes are used all over the place if

00:20:36,720 --> 00:20:41,370
you ever look at a standard library

00:20:37,830 --> 00:20:43,740
implementation you will see these and so

00:20:41,370 --> 00:20:46,980
we do our our actual destruction in our

00:20:43,740 --> 00:20:49,320
base class and this version is for when

00:20:46,980 --> 00:20:50,850
our thing is not trivially destructible

00:20:49,320 --> 00:20:53,880
so we have to call the disruptor and

00:20:50,850 --> 00:20:55,740
then we have another case where we make

00:20:53,880 --> 00:20:59,030
a template specialization for when we do

00:20:55,740 --> 00:21:01,260
not have to call them we just default it

00:20:59,030 --> 00:21:03,539
and then we do the same with the copy

00:21:01,260 --> 00:21:05,730
constructor and with the coffee

00:21:03,539 --> 00:21:14,909
incitement and the move constructor and

00:21:05,730 --> 00:21:18,780
the move assignment C++ is great yeah

00:21:14,909 --> 00:21:20,190
and then we inherit from these all

00:21:18,780 --> 00:21:22,169
inherit from each other and then we

00:21:20,190 --> 00:21:24,240
inherit from the top-level one and it's

00:21:22,169 --> 00:21:26,970
all fine we just default our destructor

00:21:24,240 --> 00:21:30,539
and the base classes will work out what

00:21:26,970 --> 00:21:36,120
to do essentially so now this compiles

00:21:30,539 --> 00:21:40,559
and this compiles so a performant can

00:21:36,120 --> 00:21:43,620
anyone tell me what comes next but with

00:21:40,559 --> 00:21:46,679
lots of codes there we go starting catch

00:21:43,620 --> 00:21:52,850
on okay so how do we fix this

00:21:46,679 --> 00:21:56,539
well we can actually use concepts again

00:21:52,850 --> 00:22:02,610
we do need this other paper written by

00:21:56,539 --> 00:22:04,260
by reps and Andrew Sutton I believe it's

00:22:02,610 --> 00:22:05,850
not being discussed yet I think it's

00:22:04,260 --> 00:22:07,590
gonna be discussed at San Diego but it

00:22:05,850 --> 00:22:09,960
essentially means that it would make

00:22:07,590 --> 00:22:12,270
this work currently just because

00:22:09,960 --> 00:22:15,270
some wording it doesn't it's not quite

00:22:12,270 --> 00:22:17,490
there hopefully we'll get this and it

00:22:15,270 --> 00:22:19,380
will all be great and we can go from

00:22:17,490 --> 00:22:25,980
being performant with a ton of code to

00:22:19,380 --> 00:22:28,440
just being performed again for five more

00:22:25,980 --> 00:22:32,760
seconds this one see you can have a look

00:22:28,440 --> 00:22:34,649
oops ah there you go yes you just say we

00:22:32,760 --> 00:22:37,679
require copy constructible and move

00:22:34,649 --> 00:22:39,240
constructible and it's can't remember

00:22:37,679 --> 00:22:42,809
exactly the wording the paper but it

00:22:39,240 --> 00:22:46,460
means that if these things are are

00:22:42,809 --> 00:22:55,020
removed then you retain triviality

00:22:46,460 --> 00:23:00,059
yes meow so the question was is the the

00:22:55,020 --> 00:23:02,070
problem that yes so the the questions

00:23:00,059 --> 00:23:03,299
about the current wording I can't

00:23:02,070 --> 00:23:05,669
remember exactly I think the current

00:23:03,299 --> 00:23:07,919
wording means that even if they're

00:23:05,669 --> 00:23:12,690
removed it's not trivial and this paper

00:23:07,919 --> 00:23:14,159
makes it such that they are trivial yes

00:23:12,690 --> 00:23:17,700
that works for destructors as well -

00:23:14,159 --> 00:23:24,480
thank you okay I noticed Jeff is in the

00:23:17,700 --> 00:23:25,679
room so I still is tweet how do you know

00:23:24,480 --> 00:23:33,230
if a simple sports developer is

00:23:25,679 --> 00:23:33,230
qualified yeah you check their CV

00:23:33,630 --> 00:23:43,169
I did not plan for Kiev to be in the

00:23:37,980 --> 00:23:45,960
room that this is so much better another

00:23:43,169 --> 00:23:48,470
answer would be you look at their

00:23:45,960 --> 00:23:48,470
references

00:23:49,100 --> 00:23:56,100
yeah and this is what I'm good at

00:23:53,610 --> 00:23:58,640
talking about now rest qualified access

00:23:56,100 --> 00:23:58,640
your functions

00:23:58,820 --> 00:24:06,270
okay so this is what a lot of love code

00:24:02,970 --> 00:24:07,770
I see looks like you know you have a you

00:24:06,270 --> 00:24:10,260
want to write an access your function it

00:24:07,770 --> 00:24:11,580
looks kind of like a DRS this would be

00:24:10,260 --> 00:24:14,250
what you might write for optional or

00:24:11,580 --> 00:24:16,049
something like that you want to this

00:24:14,250 --> 00:24:18,480
could just equally be called get or

00:24:16,049 --> 00:24:21,120
value or whatever people have different

00:24:18,480 --> 00:24:23,220
names for this you'll see this a lot of

00:24:21,120 --> 00:24:25,380
people will have a non-count Spurgeon

00:24:23,220 --> 00:24:32,610
and a Const version because you want it

00:24:25,380 --> 00:24:35,760
to work in both cases right this can

00:24:32,610 --> 00:24:50,280
anyone tell me whether these lines copy

00:24:35,760 --> 00:24:54,720
or move with this operator copy first

00:24:50,280 --> 00:24:57,870
one copies second one moves because in

00:24:54,720 --> 00:25:00,900
the first example we move and then we

00:24:57,870 --> 00:25:03,539
take use our operator by our operator

00:25:00,900 --> 00:25:05,900
doesn't care about whether it uses it's

00:25:03,539 --> 00:25:09,230
called on an L value or an R value

00:25:05,900 --> 00:25:11,880
whereas the second example you do the

00:25:09,230 --> 00:25:13,049
the dereference or whatever and then you

00:25:11,880 --> 00:25:17,760
do the move so this is always going to

00:25:13,049 --> 00:25:24,120
be an R value so you'll do do move this

00:25:17,760 --> 00:25:25,950
is not performant or I'm surprising so

00:25:24,120 --> 00:25:30,990
what we can do is instead of just having

00:25:25,950 --> 00:25:36,289
a non constant a Const person and C++ 11

00:25:30,990 --> 00:25:39,120
onwards we can and reference qualifiers

00:25:36,289 --> 00:25:43,640
yay multiply the amount of code we have

00:25:39,120 --> 00:25:48,740
to write by to construe

00:25:43,640 --> 00:25:50,000
I have a slide on contrast oh dear

00:25:48,740 --> 00:25:56,330
here's your response yes

00:25:50,000 --> 00:26:00,070
very much oh dear contrast here's one

00:25:56,330 --> 00:26:05,380
reason why contract might actually help

00:26:00,070 --> 00:26:05,380
so if you if you something like Stinson

00:26:06,280 --> 00:26:13,840
let the audience compose themselves so

00:26:11,300 --> 00:26:17,920
if you have something like stood C ref

00:26:13,840 --> 00:26:22,810
which creates a Const reference rapper

00:26:17,920 --> 00:26:25,790
this actually has the the contra 4 F

00:26:22,810 --> 00:26:28,030
version deleted so that you do not

00:26:25,790 --> 00:26:31,010
actually accidentally make references to

00:26:28,030 --> 00:26:33,320
temporaries because it will just be like

00:26:31,010 --> 00:26:35,240
deleted be destroyed and it'll be

00:26:33,320 --> 00:26:37,700
undefined behavior yeah so without

00:26:35,240 --> 00:26:40,280
contraire f you get whatever your

00:26:37,700 --> 00:26:42,830
favorite undefined behavior metaphor is

00:26:40,280 --> 00:26:45,710
and if you do do the contraire for F

00:26:42,830 --> 00:26:48,530
version then you get a proper compiler

00:26:45,710 --> 00:26:51,710
ever so I mean it's it's an edgy edgy

00:26:48,530 --> 00:27:01,940
edgy edgy case but you know it could be

00:26:51,710 --> 00:27:03,560
worthwhile Kasper right so the code the

00:27:01,940 --> 00:27:06,470
comment was if you have Universal

00:27:03,560 --> 00:27:08,510
references sometimes it will just get

00:27:06,470 --> 00:27:10,670
deduced like that especially if you're

00:27:08,510 --> 00:27:12,020
in a generic context and you have a

00:27:10,670 --> 00:27:13,430
bunch of things which are calling each

00:27:12,020 --> 00:27:17,120
other and returning from each other

00:27:13,430 --> 00:27:20,000
these things turn up so it's not like

00:27:17,120 --> 00:27:22,850
you're just gonna be stood moving a

00:27:20,000 --> 00:27:24,350
constant because that's weird but this

00:27:22,850 --> 00:27:27,940
does turn out when you have Universal

00:27:24,350 --> 00:27:32,090
references in generic code thank you

00:27:27,940 --> 00:27:37,190
yep so we have this and we're now

00:27:32,090 --> 00:27:41,670
performant and I'm surprising but code

00:27:37,190 --> 00:27:45,090
duplication yes

00:27:41,670 --> 00:27:48,990
education but we could have deducing

00:27:45,090 --> 00:27:53,430
this so this is a paper which myself and

00:27:48,990 --> 00:27:56,610
Gasper and Ben and Ben Dean and Barry

00:27:53,430 --> 00:28:00,180
resin are working on so the idea is that

00:27:56,610 --> 00:28:04,500
you deduce the type of the implicit

00:28:00,180 --> 00:28:06,210
object parameter so this might look a

00:28:04,500 --> 00:28:10,800
little bit weird at first if you used to

00:28:06,210 --> 00:28:12,900
like - where self is like an explicit

00:28:10,800 --> 00:28:14,190
parameter - member function then this

00:28:12,900 --> 00:28:18,030
maybe looks a little bit more reasonable

00:28:14,190 --> 00:28:20,130
to you so we have qualified that this

00:28:18,030 --> 00:28:23,760
parameter is the implicit object

00:28:20,130 --> 00:28:27,720
parameter and then just use universal

00:28:23,760 --> 00:28:30,510
references to deduce what the type is

00:28:27,720 --> 00:28:32,130
and I have a feeling Gasper is gonna

00:28:30,510 --> 00:28:41,070
tell me this code is slightly wrong but

00:28:32,130 --> 00:28:43,080
I don't care yeah yeah so we could do

00:28:41,070 --> 00:28:53,640
this does anyone have any questions

00:28:43,080 --> 00:28:56,730
about so okay so yes does it require

00:28:53,640 --> 00:29:01,680
deco type ATO sure if you want to return

00:28:56,730 --> 00:29:03,270
a reference then yeah yeah you're right

00:29:01,680 --> 00:29:06,560
this should have been deco type art or

00:29:03,270 --> 00:29:06,560
not Otto thank you Jason

00:29:11,320 --> 00:29:16,580
yeah okay so now we've gone from being

00:29:14,690 --> 00:29:18,320
performant and unsurprising but with

00:29:16,580 --> 00:29:23,840
code duplication and we've got rid of

00:29:18,320 --> 00:29:26,440
all of that okay I wasn't sure whether

00:29:23,840 --> 00:29:30,200
to include this or not

00:29:26,440 --> 00:29:33,920
SVA unfriendly collar balls this stuff

00:29:30,200 --> 00:29:35,810
is hairy I included this purely for the

00:29:33,920 --> 00:29:37,640
people who are in the room maybe just

00:29:35,810 --> 00:29:39,050
knew everything I talked about and you

00:29:37,640 --> 00:29:41,030
might still learn something from this

00:29:39,050 --> 00:29:43,190
one so there we go

00:29:41,030 --> 00:29:50,240
right we have our rapper return of the

00:29:43,190 --> 00:29:57,490
rapper so then we have this these member

00:29:50,240 --> 00:29:59,360
functions called pass - now these take

00:29:57,490 --> 00:30:01,280
template because you're going to take

00:29:59,360 --> 00:30:03,230
like lambdas or function objects or

00:30:01,280 --> 00:30:05,570
whatever you want just a template

00:30:03,230 --> 00:30:09,410
parameter don't worry about it being by

00:30:05,570 --> 00:30:13,460
value and we have const and we have non

00:30:09,410 --> 00:30:15,820
corn stover loads and this is important

00:30:13,460 --> 00:30:18,710
and then we just have a deco type

00:30:15,820 --> 00:30:24,260
because we want to if this call is not

00:30:18,710 --> 00:30:29,390
valid we want to espy Nate out this is

00:30:24,260 --> 00:30:31,400
useful in in many contexts so we have

00:30:29,390 --> 00:30:35,060
this code familiarize yourself with it

00:30:31,400 --> 00:30:38,480
it will be important non Const Const

00:30:35,060 --> 00:30:41,990
overload SP nee friendliness using the

00:30:38,480 --> 00:30:50,090
deckle type calling the function okay

00:30:41,990 --> 00:30:54,170
everyone got that okay so we have a

00:30:50,090 --> 00:30:59,690
wrapper of a foo which just has a

00:30:54,170 --> 00:31:03,020
non-constant function and we pass in a

00:30:59,690 --> 00:31:08,060
generic lambda which we'll call do thing

00:31:03,020 --> 00:31:11,990
on X now this seems like reasonable

00:31:08,060 --> 00:31:14,600
issue code again for some definition of

00:31:11,990 --> 00:31:17,960
reasonable having to make these lambdas

00:31:14,600 --> 00:31:20,240
is super annoying in C++ but we have

00:31:17,960 --> 00:31:22,490
what we have so we have a wrapper of

00:31:20,240 --> 00:31:23,630
food hmm has a member function and non

00:31:22,490 --> 00:31:28,970
constant

00:31:23,630 --> 00:31:33,400
important we pass a generic lambda which

00:31:28,970 --> 00:31:38,260
calls this function okay still with me

00:31:33,400 --> 00:31:41,930
no compiler error

00:31:38,260 --> 00:31:47,210
don't try and read this file explain way

00:31:41,930 --> 00:31:52,760
says it says passing construe as this

00:31:47,210 --> 00:31:59,200
argument discards qualifiers where did

00:31:52,760 --> 00:32:04,030
construe come from the Const overload

00:31:59,200 --> 00:32:06,800
exactly so there's no Const in this code

00:32:04,030 --> 00:32:09,800
at all that we can see we don't have a

00:32:06,800 --> 00:32:14,180
Const wrapper a foo if we did this would

00:32:09,800 --> 00:32:16,280
make sense more sense it's not a wrapper

00:32:14,180 --> 00:32:19,360
of construes we don't see Const on this

00:32:16,280 --> 00:32:26,270
slide but there is Const

00:32:19,360 --> 00:32:30,650
here so what happens is these are both

00:32:26,270 --> 00:32:33,910
candidates for overloads which could be

00:32:30,650 --> 00:32:39,620
called right they're both called pass to

00:32:33,910 --> 00:32:43,490
the arguments look okay so what we do is

00:32:39,620 --> 00:32:44,990
we check the deckle type we want the

00:32:43,490 --> 00:32:48,680
deckle type because we want to be s

00:32:44,990 --> 00:32:50,150
phoenix friendly and so we checked the

00:32:48,680 --> 00:32:53,870
deco type for the first one and it says

00:32:50,150 --> 00:32:59,450
okay we return the thing is Floyd yep we

00:32:53,870 --> 00:33:02,210
return void the second one we try and

00:32:59,450 --> 00:33:04,940
work out what we return and we hit

00:33:02,210 --> 00:33:08,390
compiler error because this call to X do

00:33:04,940 --> 00:33:11,120
thing where X is concise is not valid

00:33:08,390 --> 00:33:12,670
because our member function is constant

00:33:11,120 --> 00:33:16,820
qualified

00:33:12,670 --> 00:33:19,310
see what I meant about Harry so just to

00:33:16,820 --> 00:33:21,440
explain in slightly different words the

00:33:19,310 --> 00:33:23,030
fact that we have a constant non

00:33:21,440 --> 00:33:26,420
constant overload and they're both

00:33:23,030 --> 00:33:29,060
candidates means that these devil types

00:33:26,420 --> 00:33:32,360
have to be checked and if the deckle

00:33:29,060 --> 00:33:34,760
type does something invalid which is not

00:33:32,360 --> 00:33:37,549
in an SP na context then you're going to

00:33:34,760 --> 00:33:39,139
get hard error and

00:33:37,549 --> 00:33:43,340
there's fundamentally no way to get

00:33:39,139 --> 00:33:45,230
around this in C++ today both having

00:33:43,340 --> 00:33:48,649
their Sweeney friendliness and having

00:33:45,230 --> 00:33:54,100
constant non Const overloads no way to

00:33:48,649 --> 00:33:58,460
get around it this is surprising this

00:33:54,100 --> 00:34:02,570
this bug took me days to work out while

00:33:58,460 --> 00:34:06,919
I optional implementation was having

00:34:02,570 --> 00:34:10,480
some bugs it's horrible so we could do

00:34:06,919 --> 00:34:14,109
is just get rid of the deckle types and

00:34:10,480 --> 00:34:18,530
this works because of her auto works

00:34:14,109 --> 00:34:20,690
essentially Auto is not worked out when

00:34:18,530 --> 00:34:22,490
you try and instantiate the the

00:34:20,690 --> 00:34:26,210
signature of this function it's only

00:34:22,490 --> 00:34:29,230
when the body is instantiated that

00:34:26,210 --> 00:34:32,629
should have had return FTS in there but

00:34:29,230 --> 00:34:34,700
yes we could remove the deckle type it

00:34:32,629 --> 00:34:37,490
will compile now but we lose the SP na

00:34:34,700 --> 00:34:40,460
friendliness so now we don't get

00:34:37,490 --> 00:34:41,899
compiler error yeah if you just look at

00:34:40,460 --> 00:34:43,819
this and think oh I remove the deckle

00:34:41,899 --> 00:34:45,829
type and suddenly it fixed everything

00:34:43,819 --> 00:34:47,720
like what on earth is going on with this

00:34:45,829 --> 00:34:48,080
language and that is a very valid

00:34:47,720 --> 00:34:51,170
question

00:34:48,080 --> 00:34:51,170
[Music]

00:34:53,379 --> 00:34:57,530
you can't forward no except here yes you

00:34:56,329 --> 00:34:59,240
couldn't forward no except either

00:34:57,530 --> 00:35:01,099
because it would have the same problem

00:34:59,240 --> 00:35:03,470
of trying to do something SP nee

00:35:01,099 --> 00:35:07,819
unfriendly because it has to instantiate

00:35:03,470 --> 00:35:10,220
the signature of the function so now

00:35:07,819 --> 00:35:13,839
we're unsurprising but we're no longer

00:35:10,220 --> 00:35:16,849
SVN a friendly and this can be a problem

00:35:13,839 --> 00:35:20,359
some code relies on your stuff being a

00:35:16,849 --> 00:35:24,220
spinning friendly so we we would like

00:35:20,359 --> 00:35:24,220
this it's literally impossible right now

00:35:24,280 --> 00:35:31,780
but we can use deducing this again turns

00:35:30,260 --> 00:35:35,930
out we accidentally solved this problem

00:35:31,780 --> 00:35:40,430
without really realizing we need this

00:35:35,930 --> 00:35:41,930
paper and then Agusta and beerus I don't

00:35:40,430 --> 00:35:43,760
have pronounce his name right he said oh

00:35:41,930 --> 00:35:45,920
yeah this solves my problem I wrote a

00:35:43,760 --> 00:35:49,130
paper on this and this actually fixes

00:35:45,920 --> 00:35:51,320
the the deckle type issue so the reason

00:35:49,130 --> 00:35:52,790
is because this is a template

00:35:51,320 --> 00:35:55,550
and it's going to deduce whether it's

00:35:52,790 --> 00:36:01,130
constant non Const we're not having to

00:35:55,550 --> 00:36:03,500
instantiate invalid Dettol type types

00:36:01,130 --> 00:36:06,080
when we're doing our overload resolution

00:36:03,500 --> 00:36:07,850
it will just say okay well it's conical

00:36:06,080 --> 00:36:10,100
fyodor it's not cons qualified so that's

00:36:07,850 --> 00:36:13,640
the only candidate the other ones not

00:36:10,100 --> 00:36:17,210
even not even checked and that's kind of

00:36:13,640 --> 00:36:18,920
how how this gets gets around it it's

00:36:17,210 --> 00:36:20,960
also this is only a problem with member

00:36:18,920 --> 00:36:26,180
functions if you have non-members then

00:36:20,960 --> 00:36:27,920
then we don't have this problem I know

00:36:26,180 --> 00:36:29,540
we've gone from unsurprising but no

00:36:27,920 --> 00:36:32,480
longer SP any friendly to just

00:36:29,540 --> 00:36:35,480
unsurprising so these are all the things

00:36:32,480 --> 00:36:38,690
which I talked about I hope that you've

00:36:35,480 --> 00:36:41,720
come away with some ideas of how in your

00:36:38,690 --> 00:36:43,820
own libraries or maybe even problems

00:36:41,720 --> 00:36:45,860
you've seen in libraries you use such as

00:36:43,820 --> 00:36:49,640
I mentioned at the start how you could

00:36:45,860 --> 00:36:53,270
solve some of these problems there are

00:36:49,640 --> 00:36:54,800
more kind of topics and things like that

00:36:53,270 --> 00:36:57,740
I could cover in here but these ones are

00:36:54,800 --> 00:37:00,800
important for being unsurprising and for

00:36:57,740 --> 00:37:02,570
being performant and that's is how to

00:37:00,800 --> 00:37:04,720
write well-behaved value wrappers thank

00:37:02,570 --> 00:37:04,720
you

00:37:10,930 --> 00:37:15,530
and some resources here if you'd like to

00:37:14,119 --> 00:37:17,710
check them out and I will not take

00:37:15,530 --> 00:37:17,710
questions

00:37:21,940 --> 00:37:54,260
lots of phones no hands and yes great

00:37:51,710 --> 00:37:57,140
yes so the question was and whether I

00:37:54,260 --> 00:37:59,359
can comment for the kind of libraries

00:37:57,140 --> 00:38:02,960
which are used by a lot of developers

00:37:59,359 --> 00:38:05,869
like boost how many of these kinds of

00:38:02,960 --> 00:38:09,950
topics are are actually applied and

00:38:05,869 --> 00:38:14,210
which ones could be applied to to make

00:38:09,950 --> 00:38:17,000
it better so for boost optional and

00:38:14,210 --> 00:38:20,570
things like that as far as I remember

00:38:17,000 --> 00:38:22,339
they do all of this stuff same for all

00:38:20,570 --> 00:38:26,810
the standard implementations of optional

00:38:22,339 --> 00:38:30,680
narrow lips did C++ didn't propagate

00:38:26,810 --> 00:38:32,359
triviality for a while which meant you

00:38:30,680 --> 00:38:34,880
got some bad code gen in cases but he

00:38:32,359 --> 00:38:38,390
fixed it and so the standard versions

00:38:34,880 --> 00:38:40,550
the boost versions are all good in fact

00:38:38,390 --> 00:38:42,080
a lot of these ideas I got from like

00:38:40,550 --> 00:38:46,490
reading boost code or standard library

00:38:42,080 --> 00:38:49,700
code things like that things like that

00:38:46,490 --> 00:38:54,440
that comment which was at the top if you

00:38:49,700 --> 00:38:57,710
look at libraries which are used by like

00:38:54,440 --> 00:39:00,349
Britain for major projects but which

00:38:57,710 --> 00:39:02,180
don't aim to be a high performance

00:39:00,349 --> 00:39:07,220
generic libraries in their own right

00:39:02,180 --> 00:39:09,859
like LLVM like Mozilla's I'm kind

00:39:07,220 --> 00:39:13,700
standard library type thing those don't

00:39:09,859 --> 00:39:15,800
tend to follow these these guidelines so

00:39:13,700 --> 00:39:19,160
no LLVM optional does not do a lot of

00:39:15,800 --> 00:39:20,599
this stuff and Mozilla's maybe doesn't

00:39:19,160 --> 00:39:22,410
do a lot of this stuff

00:39:20,599 --> 00:39:25,430
I'm sure there

00:39:22,410 --> 00:39:27,630
many many other cases which are the same

00:39:25,430 --> 00:40:10,410
most as a quick follow-up will take me

00:39:27,630 --> 00:40:14,160
huh okay okay Mike Hales comment was

00:40:10,410 --> 00:40:16,500
that I was incorrect about the the no

00:40:14,160 --> 00:40:19,470
except having the same issues the deckle

00:40:16,500 --> 00:40:23,039
type which was guessed this question and

00:40:19,470 --> 00:40:25,349
the reason is that no except similarly

00:40:23,039 --> 00:40:28,859
to when I mentioned Auto and how its

00:40:25,349 --> 00:40:31,680
only evaluated once the function body is

00:40:28,859 --> 00:40:34,710
instantiated missus same for know except

00:40:31,680 --> 00:40:36,000
it doesn't happen when you're inside

00:40:34,710 --> 00:40:37,890
changing the signature and doing

00:40:36,000 --> 00:41:12,119
overload resolution that correct me huh

00:40:37,890 --> 00:41:15,480
thank you yes yes so the difference

00:41:12,119 --> 00:41:18,559
between so this is the concept plus p0

00:41:15,480 --> 00:41:18,559
eight four eight

00:41:20,720 --> 00:41:29,029
teens I have a lot of slides must be

00:41:26,819 --> 00:41:29,029
soon

00:41:30,300 --> 00:41:39,690
oh yes this one yes so the difference is

00:41:34,680 --> 00:41:45,510
the current wording will in deletion

00:41:39,690 --> 00:41:47,460
works if the if one of these is SP na

00:41:45,510 --> 00:41:49,080
well no I spin a doubt that the the

00:41:47,460 --> 00:41:53,760
equivalent like if the the requires

00:41:49,080 --> 00:41:55,740
Clause resolves to false then this thing

00:41:53,760 --> 00:41:57,960
will be deleted that's in the current

00:41:55,740 --> 00:42:00,000
wording it's just it wouldn't be trivial

00:41:57,960 --> 00:42:03,990
and that's the thing which is missing so

00:42:00,000 --> 00:42:07,880
the true the deletion works today the

00:42:03,990 --> 00:42:07,880
triviality requires the other paper

00:42:10,160 --> 00:42:17,280
nobody so yes yes clone was it can be

00:42:15,930 --> 00:42:19,350
trivial and deleted

00:42:17,280 --> 00:42:21,870
yeah it's matters in different cases

00:42:19,350 --> 00:42:24,570
where the whether the underlying type

00:42:21,870 --> 00:42:35,850
you're wrapping has them deleted trivial

00:42:24,570 --> 00:42:38,190
or non trivial there are three cases yes

00:42:35,850 --> 00:42:39,690
and I find myself often lately thinking

00:42:38,190 --> 00:42:42,480
when I'm working on something that's a

00:42:39,690 --> 00:42:45,420
simple wrapper a wrap around int like

00:42:42,480 --> 00:42:46,650
you had earlier also I'm saying well you

00:42:45,420 --> 00:42:50,520
know what all of this would be much

00:42:46,650 --> 00:42:53,070
simpler if all of the numbers are public

00:42:50,520 --> 00:42:55,350
as it is here and I have no constructors

00:42:53,070 --> 00:42:57,990
then you don't have to worry about any

00:42:55,350 --> 00:43:00,300
of these questions right so the I just

00:42:57,990 --> 00:43:02,070
wanted your comments on that yes so and

00:43:00,300 --> 00:43:04,350
I mentioned that briefly in the talk

00:43:02,070 --> 00:43:06,180
maybe I didn't yeah maybe it wasn't

00:43:04,350 --> 00:43:08,130
clear enough so some of these things

00:43:06,180 --> 00:43:10,320
only matter when you have to write your

00:43:08,130 --> 00:43:12,510
own constructors and destructors like

00:43:10,320 --> 00:43:13,920
for optional if you are writing if you

00:43:12,510 --> 00:43:15,510
personally are writing a class like that

00:43:13,920 --> 00:43:22,950
today you just leave it like that

00:43:15,510 --> 00:43:24,330
right okay and for depending on what

00:43:22,950 --> 00:43:25,650
kind of things you want because the

00:43:24,330 --> 00:43:29,610
comparison operators and the

00:43:25,650 --> 00:43:30,990
explicitness still matter is if you want

00:43:29,610 --> 00:43:32,940
implicit conversions you have to do more

00:43:30,990 --> 00:43:34,290
stuff and if you want the comparison

00:43:32,940 --> 00:43:35,310
operators you have to do more stuff but

00:43:34,290 --> 00:43:39,270
you don't have to do all the nonsense

00:43:35,310 --> 00:43:41,610
with like propagating deletion and

00:43:39,270 --> 00:43:44,360
triviality that just works it's only if

00:43:41,610 --> 00:43:44,360
you have to write your own

00:43:48,800 --> 00:43:56,210
today we can mix them and you mean eyes

00:43:51,510 --> 00:43:56,210
like a private base class or something

00:43:57,260 --> 00:44:01,530
right right yeah so we could inherit

00:44:00,300 --> 00:44:04,590
from that and then mix in all the

00:44:01,530 --> 00:44:06,660
operators you want which is kind of it's

00:44:04,590 --> 00:44:08,610
a similar technique to how I deleted all

00:44:06,660 --> 00:44:10,260
the members by moving this into the base

00:44:08,610 --> 00:44:11,850
class inheriting from that and then

00:44:10,260 --> 00:44:13,320
inheriting things we deleted it you

00:44:11,850 --> 00:44:27,030
could inherit from things with define

00:44:13,320 --> 00:44:31,310
operators yes the assembly slides I will

00:44:27,030 --> 00:44:34,590
have a shot I won't have any jokes one

00:44:31,310 --> 00:44:38,550
and I'm just trying to understand why

00:44:34,590 --> 00:44:42,450
the code and yeah which one are you

00:44:38,550 --> 00:44:44,970
particularly interested in the last one

00:44:42,450 --> 00:44:50,670
okay this is the simplest case yeah why

00:44:44,970 --> 00:44:53,310
why did move absolute and because this

00:44:50,670 --> 00:44:58,470
is a this is an optional int so it has

00:44:53,310 --> 00:45:00,030
the the int part and the bool so this

00:44:58,470 --> 00:45:03,270
just happens to be the byte

00:45:00,030 --> 00:45:07,370
representation for encoding oh for c2

00:45:03,270 --> 00:45:07,370
and true because there's a high

00:45:24,350 --> 00:45:30,000
constitute a good value cemented class

00:45:27,960 --> 00:45:35,910
that's right in the annex I can find

00:45:30,000 --> 00:45:40,950
that one it seems like this would be a

00:45:35,910 --> 00:45:45,210
great example case or a concept and say

00:45:40,950 --> 00:45:48,540
this is a correct semantic value wrapper

00:45:45,210 --> 00:45:52,080
class that's something you found over

00:45:48,540 --> 00:45:54,150
there plant a you know a concept versus

00:45:52,080 --> 00:45:57,470
evil is plenty to be able to check these

00:45:54,150 --> 00:45:57,470
all of these at compile time

00:45:57,920 --> 00:46:04,310
yes that's interesting question I think

00:46:00,510 --> 00:46:08,730
because this these are all related to

00:46:04,310 --> 00:46:12,960
instantiation of of types you care how

00:46:08,730 --> 00:46:15,750
it works for like optional impt versus

00:46:12,960 --> 00:46:18,740
optional state vector or something like

00:46:15,750 --> 00:46:20,819
that and checking behavior between

00:46:18,740 --> 00:46:23,160
instantiations is not really something

00:46:20,819 --> 00:46:35,280
which concepts map to well did you have

00:46:23,160 --> 00:46:36,530
a comment Cashman how could you use the

00:46:35,280 --> 00:46:51,329
microphone please

00:46:36,530 --> 00:46:53,130
so I don't have to repeat so because

00:46:51,329 --> 00:46:55,650
that's what we think of when you say

00:46:53,130 --> 00:46:57,750
wrapper type you're basically saying

00:46:55,650 --> 00:47:00,000
we're gonna forward all of the sub

00:46:57,750 --> 00:47:02,609
things of regular that you can put into

00:47:00,000 --> 00:47:05,190
the interface including comparison

00:47:02,609 --> 00:47:12,930
because that's what the POV regular

00:47:05,190 --> 00:47:19,980
happen unlike unfortunately regular does

00:47:12,930 --> 00:47:26,910
not do being showed all of the you know

00:47:19,980 --> 00:47:28,980
various that stuff is not in regular so

00:47:26,910 --> 00:47:31,950
you have a family of concepts that is

00:47:28,980 --> 00:47:35,040
literally 2 ^ things that you have over

00:47:31,950 --> 00:47:38,010
that this is how many concepts there are

00:47:35,040 --> 00:47:39,869
up here so you could write probably

00:47:38,010 --> 00:47:42,660
something like 60 different concepts

00:47:39,869 --> 00:47:44,609
basically whether you have no except

00:47:42,660 --> 00:47:48,450
swap or not those are two separate

00:47:44,609 --> 00:47:49,650
concepts or families we me because every

00:47:48,450 --> 00:47:58,380
one of those can have an explicit

00:47:49,650 --> 00:47:59,760
constructor or loss yes and that that's

00:47:58,380 --> 00:48:02,790
what I'm talking about like this is not

00:47:59,760 --> 00:48:11,630
one concept this is a family of concepts

00:48:02,790 --> 00:48:11,630
so what is giant decision tree the

00:48:14,060 --> 00:48:21,230
regular parameter yeah it's like if you

00:48:18,320 --> 00:48:23,930
tried to plot this on a graph this is

00:48:21,230 --> 00:48:27,200
not like a line of do i fulfill this

00:48:23,930 --> 00:48:29,270
thing or doing not it's like a line for

00:48:27,200 --> 00:48:31,220
every single one of these I knew you

00:48:29,270 --> 00:48:40,480
exist somewhere on this like

00:48:31,220 --> 00:48:43,340
n-dimensional er sort of purpose-built

00:48:40,480 --> 00:48:44,810
exemplar for what concepts are supposed

00:48:43,340 --> 00:48:46,940
to provide conceptually you're supposed

00:48:44,810 --> 00:48:48,740
to be able to tell the compiler I want

00:48:46,940 --> 00:48:51,020
this to have rough qualified member

00:48:48,740 --> 00:49:17,150
accessible and trivial propagation and

00:48:51,020 --> 00:49:19,010
blah blah blah the characteristics the

00:49:17,150 --> 00:49:20,390
common ways we could have essentially

00:49:19,010 --> 00:49:24,109
something which is parameterize by all

00:49:20,390 --> 00:49:28,820
of these and say okay I'm interested in

00:49:24,109 --> 00:49:37,460
these parts so I think you're next in

00:49:28,820 --> 00:49:39,109
the microphone Thanks I think has these

00:49:37,460 --> 00:49:44,570
value semantics for this common use case

00:49:39,109 --> 00:49:48,940
so I yeah you could do things like that

00:49:44,570 --> 00:49:51,200
I think if I was to use something like

00:49:48,940 --> 00:49:56,990
concepts for things like this it would

00:49:51,200 --> 00:49:59,990
actually be more for testing so if I if

00:49:56,990 --> 00:50:02,240
I wrote out like a list of requirements

00:49:59,990 --> 00:50:07,040
that I wanted my generic type to have

00:50:02,240 --> 00:50:11,359
and then I could have tests which run a

00:50:07,040 --> 00:50:13,910
compile time and check that I actually

00:50:11,359 --> 00:50:16,550
have like implemented triviality

00:50:13,910 --> 00:50:18,320
propagation correctly or no accept

00:50:16,550 --> 00:50:21,020
propagation I can have those checked in

00:50:18,320 --> 00:50:23,760
my test Suites so that because a lot of

00:50:21,020 --> 00:50:25,290
this stuff is kind of subtle

00:50:23,760 --> 00:50:26,670
so maybe if you if you don't know what

00:50:25,290 --> 00:50:28,380
you're doing and you make a small change

00:50:26,670 --> 00:50:31,880
you might affect some of this so you

00:50:28,380 --> 00:50:34,500
could have you could have a testing to

00:50:31,880 --> 00:50:38,580
to actually check some of this stuff and

00:50:34,500 --> 00:51:00,630
that might be useful any other questions

00:50:38,580 --> 00:51:02,790
or comments yes Matthew yes so the

00:51:00,630 --> 00:51:04,590
question is like so if I'm implementing

00:51:02,790 --> 00:51:07,190
like if I'm a standard library implement

00:51:04,590 --> 00:51:09,359
or a boost implement or something and

00:51:07,190 --> 00:51:12,720
because I had examples that start like a

00:51:09,359 --> 00:51:15,930
pear tuple variant and all of those

00:51:12,720 --> 00:51:18,740
things I would want to fulfill as many

00:51:15,930 --> 00:51:22,200
of these criteria which are applicable

00:51:18,740 --> 00:51:26,310
so some of this stuff you can rip out so

00:51:22,200 --> 00:51:28,050
for example the the deletion of of the

00:51:26,310 --> 00:51:31,080
special member functions you can have

00:51:28,050 --> 00:51:34,550
like one implementation of that which

00:51:31,080 --> 00:51:40,880
takes brilliant template parameters and

00:51:34,550 --> 00:51:45,020
a new would say for example for optional

00:51:40,880 --> 00:51:47,220
you would just check if T is copy

00:51:45,020 --> 00:51:50,520
constructibility recopy constructible

00:51:47,220 --> 00:51:53,130
moveable whatever but for expected you

00:51:50,520 --> 00:51:55,400
would check T and E and you would just

00:51:53,130 --> 00:51:58,020
pass these in this template parameters

00:51:55,400 --> 00:52:00,720
template arguments even and then you

00:51:58,020 --> 00:52:02,220
could reuse all of the that code which I

00:52:00,720 --> 00:52:03,810
had like the the four different things

00:52:02,220 --> 00:52:06,780
on the slide that would all just work

00:52:03,810 --> 00:52:08,580
and that is what standard libraries tend

00:52:06,780 --> 00:52:10,830
to do they have like one version which

00:52:08,580 --> 00:52:12,960
takes build parameters and then they

00:52:10,830 --> 00:52:20,010
reuse it so things like that you can

00:52:12,960 --> 00:52:22,200
reuse off the top of my head some things

00:52:20,010 --> 00:52:24,359
like if you if you wrote your types in

00:52:22,200 --> 00:52:26,130
particular ways you could use like

00:52:24,359 --> 00:52:30,119
mix-ins for the comparison operators

00:52:26,130 --> 00:52:34,410
like peter mentioned for no except

00:52:30,119 --> 00:52:36,330
propagation probably not so yeah it

00:52:34,410 --> 00:52:37,230
depends on the topic some of these yes

00:52:36,330 --> 00:52:40,050
some of these No

00:52:37,230 --> 00:52:42,560
that answer question cool there was

00:52:40,050 --> 00:52:48,050
another question over there I thought so

00:52:42,560 --> 00:52:55,239
no good okay thank you very much

00:52:48,050 --> 00:52:55,239

YouTube URL: https://www.youtube.com/watch?v=J4A2B9eexiw


