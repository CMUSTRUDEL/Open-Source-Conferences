Title: CppCon 2018: Kate Gregory “What Do We Mean When We Say Nothing At All?”
Publication date: 2018-10-13
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
They say silence can speak volumes. In a C++ application there are many places where not using a keyword or a piece of punctuation is a deliberate decision that carries a lot of information. Consider not marking a member function const, or virtual, or consider not indicating that a parameter is passed by reference. While in some cases this may be an oversight, a reliance on defaults that might or might not be appropriate, in others its a deliberate decision based on careful thought and design. How is a reader to know which is the case? 

In this talk I will show some of the many places where nothingness carries meaning, and talk about approaches to increase the information others can get from your nothingness.
— 
Kate Gregory, Gregory Consulting
Partner

Kate Gregory has been using C++ since before Microsoft had a C++ compiler. She writes, mentors, codes, and leads projects, in both C++ and .NET, especially for Windows. Kate is a Microsoft Regional Director, a Visual C++ MVP, has written over a dozen books, and speaks at conferences and user groups around the world. Kate develops courses on C++, Visual Studio, and Windows programming for Pluralsight. 
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,179 --> 00:00:08,490
good morning thank you for waking up it

00:00:04,859 --> 00:00:11,429
was probably an effort right I came from

00:00:08,490 --> 00:00:13,889
East Coast so Sunday morning I woke up

00:00:11,429 --> 00:00:16,320
at like 4:00 Monday morning I woke up at

00:00:13,889 --> 00:00:18,210
like 5:00 this morning the alarm went

00:00:16,320 --> 00:00:19,590
off at 6:00 that's the first time I

00:00:18,210 --> 00:00:22,769
needed the alarm it's going to get worse

00:00:19,590 --> 00:00:24,269
as the week goes on but thank you for

00:00:22,769 --> 00:00:26,580
coming I hope you have a coffee or

00:00:24,269 --> 00:00:28,769
whatever else you need to bring your

00:00:26,580 --> 00:00:36,210
brain into gear is I want to talk to you

00:00:28,769 --> 00:00:40,170
about nothing when you write code who do

00:00:36,210 --> 00:00:43,050
you write that code for like the

00:00:40,170 --> 00:00:45,510
compiler has an opinion right it's going

00:00:43,050 --> 00:00:48,629
to object if you get your syntax wrong

00:00:45,510 --> 00:00:51,329
but the compiler does not care what your

00:00:48,629 --> 00:00:55,379
variable names are they could be a b c

00:00:51,329 --> 00:00:58,379
a1 a2 a3 compiler wouldn't care but the

00:00:55,379 --> 00:01:01,879
people yourself while you're thinking it

00:00:58,379 --> 00:01:04,350
through so the total revenue is the I

00:01:01,879 --> 00:01:06,119
don't know European revenue plus the

00:01:04,350 --> 00:01:09,930
North American revenue and calling them

00:01:06,119 --> 00:01:11,520
that helps you and of course you partly

00:01:09,930 --> 00:01:15,150
do that because you know you'll be back

00:01:11,520 --> 00:01:17,880
in this code again and always we are

00:01:15,150 --> 00:01:19,920
appealing to your altruism when we tell

00:01:17,880 --> 00:01:22,470
you to remember that other people are

00:01:19,920 --> 00:01:24,930
going to read your code later too and

00:01:22,470 --> 00:01:27,390
I've noticed a switch in the last few

00:01:24,930 --> 00:01:28,770
years from pretend your codes going to

00:01:27,390 --> 00:01:30,630
be maintained by a violent psychopath

00:01:28,770 --> 00:01:33,119
who knows where you live that was a real

00:01:30,630 --> 00:01:35,369
popular saying now we have a more tender

00:01:33,119 --> 00:01:37,470
and generous approach pretend your code

00:01:35,369 --> 00:01:40,380
is going to be maintained by your own

00:01:37,470 --> 00:01:45,420
child and I think that will make you

00:01:40,380 --> 00:01:46,950
write very very good code but you see

00:01:45,420 --> 00:01:50,220
the reason that it matters is because

00:01:46,950 --> 00:01:51,689
writing code is communicating the

00:01:50,220 --> 00:01:53,640
communication where the compiler is

00:01:51,689 --> 00:01:54,930
short and brisk and and a lot of it

00:01:53,640 --> 00:01:57,380
doesn't matter like your variable names

00:01:54,930 --> 00:02:01,590
but you're communicating with the future

00:01:57,380 --> 00:02:03,719
you are talking to future you and future

00:02:01,590 --> 00:02:06,390
co-workers and future people you have

00:02:03,719 --> 00:02:08,340
never met and never will and you're

00:02:06,390 --> 00:02:10,979
leaving these kind of trail markers

00:02:08,340 --> 00:02:13,470
behind this is a picture of some trail

00:02:10,979 --> 00:02:16,200
markers and the obvious thing the

00:02:13,470 --> 00:02:19,380
and brown thing in the foreground for

00:02:16,200 --> 00:02:20,610
those of you who don't take a canoe into

00:02:19,380 --> 00:02:22,920
the wilderness and carry it between

00:02:20,610 --> 00:02:26,070
lakes this is a place where a hiking

00:02:22,920 --> 00:02:28,080
trail and a portage trail coincided for

00:02:26,070 --> 00:02:29,610
a little while and then the portage

00:02:28,080 --> 00:02:31,650
trail breaks off and sew the bottom

00:02:29,610 --> 00:02:33,270
symbol the person with a canoe on their

00:02:31,650 --> 00:02:34,860
head is the universal portage symbol

00:02:33,270 --> 00:02:37,080
that's not what I want you to look at

00:02:34,860 --> 00:02:41,130
though if you look on the trees in the

00:02:37,080 --> 00:02:43,410
background there's a blue circle on one

00:02:41,130 --> 00:02:44,610
tree and a yellow diamond with something

00:02:43,410 --> 00:02:46,110
on it that you can't quite make out

00:02:44,610 --> 00:02:49,110
which is actually again the portage

00:02:46,110 --> 00:02:51,090
symbol mister canoe head - absolutely

00:02:49,110 --> 00:02:52,590
emphasized this is the way to go go

00:02:51,090 --> 00:02:54,270
straight if you have a canoe on your

00:02:52,590 --> 00:02:57,240
head and turn left if you're just

00:02:54,270 --> 00:02:59,130
walking and so not one sign but two

00:02:57,240 --> 00:03:00,810
signs because it's kind of important

00:02:59,130 --> 00:03:02,730
that's like a 50 kilometer hiking trail

00:03:00,810 --> 00:03:04,170
and if you have a canoe on your head you

00:03:02,730 --> 00:03:07,680
do not want to accidentally walk 50

00:03:04,170 --> 00:03:11,130
kilometers well that's what you're doing

00:03:07,680 --> 00:03:13,680
in your coat like it's not enough to say

00:03:11,130 --> 00:03:15,959
well this code compiles so I must be a

00:03:13,680 --> 00:03:18,450
winner please give me my salary it's not

00:03:15,959 --> 00:03:21,750
even enough that your code runs although

00:03:18,450 --> 00:03:24,420
it has to I started out in math it's

00:03:21,750 --> 00:03:26,250
necessary but not sufficient for your

00:03:24,420 --> 00:03:29,269
code to run your code has to be

00:03:26,250 --> 00:03:31,560
understandable by your fellow humans

00:03:29,269 --> 00:03:35,430
which means we spend a lot of time

00:03:31,560 --> 00:03:37,590
reading code and when I read code I come

00:03:35,430 --> 00:03:40,680
into companies sometimes to help them or

00:03:37,590 --> 00:03:43,110
I pick up a project after 10 years and I

00:03:40,680 --> 00:03:44,810
ask myself these sorts of questions what

00:03:43,110 --> 00:03:49,170
the heck does this do

00:03:44,810 --> 00:03:50,940
why is it doing that has anyone proven

00:03:49,170 --> 00:03:52,500
this is right like does this work this

00:03:50,940 --> 00:03:57,290
is come on you're telling me this

00:03:52,500 --> 00:04:03,620
actually does who wrote this garbage owe

00:03:57,290 --> 00:04:06,120
me like why did that that complete

00:04:03,620 --> 00:04:09,780
newbie that absolute beginner that was

00:04:06,120 --> 00:04:14,940
me two years ago never think about bla

00:04:09,780 --> 00:04:18,120
bla bla and so well written code pre

00:04:14,940 --> 00:04:20,310
answers those questions yes it works

00:04:18,120 --> 00:04:23,280
yes it's cross whatever it needs to be

00:04:20,310 --> 00:04:27,090
for your universe but it has the answers

00:04:23,280 --> 00:04:30,060
to those questions in it and not like

00:04:27,090 --> 00:04:32,490
this and technically that tells me who

00:04:30,060 --> 00:04:33,810
wrote it and when but if I never see

00:04:32,490 --> 00:04:35,240
another comment like that again it'll be

00:04:33,810 --> 00:04:37,890
too soon

00:04:35,240 --> 00:04:41,840
the way you answer those questions is

00:04:37,890 --> 00:04:44,940
because the code expresses itself it is

00:04:41,840 --> 00:04:47,580
open and obvious about what it does how

00:04:44,940 --> 00:04:52,590
it does it why it does it when you read

00:04:47,580 --> 00:04:54,510
it you understand it it communicates now

00:04:52,590 --> 00:04:56,880
I spend a lot of time talking about this

00:04:54,510 --> 00:05:00,090
in general and I want to zero in on one

00:04:56,880 --> 00:05:03,000
little part of it today how many of you

00:05:00,090 --> 00:05:06,690
have met or heard of Roger ORS favorite

00:05:03,000 --> 00:05:08,070
code snippet I get like one or two hands

00:05:06,690 --> 00:05:09,060
it's a shame it's a marvelous code

00:05:08,070 --> 00:05:10,590
snippet there was a thing

00:05:09,060 --> 00:05:11,849
I think the ACC you did there like

00:05:10,590 --> 00:05:14,340
what's your favorite ten line or less

00:05:11,849 --> 00:05:15,930
code snippet of suposse plus you can

00:05:14,340 --> 00:05:20,520
think of someone your head this what he

00:05:15,930 --> 00:05:22,080
suggested right come on that's amazing

00:05:20,520 --> 00:05:25,380
right think what happens when that

00:05:22,080 --> 00:05:29,640
happens that's amazing and that's a very

00:05:25,380 --> 00:05:31,200
very dense code snippet may depending on

00:05:29,640 --> 00:05:32,550
how many things you have in scope when

00:05:31,200 --> 00:05:34,080
you hit that closed brace and all there

00:05:32,550 --> 00:05:36,870
destructors are going off all the stuff

00:05:34,080 --> 00:05:39,120
that's happening so in terms of stuff

00:05:36,870 --> 00:05:43,789
divided by characters that's very

00:05:39,120 --> 00:05:45,630
intense but I can beat it with this I

00:05:43,789 --> 00:05:47,940
don't have another built

00:05:45,630 --> 00:05:50,880
that's the symbol I want you to think

00:05:47,940 --> 00:05:56,160
about what this token that is to say no

00:05:50,880 --> 00:05:58,050
token whatsoever means in your code it's

00:05:56,160 --> 00:06:01,650
one thing to choose a good variable name

00:05:58,050 --> 00:06:05,300
total revenue instead of B but how can

00:06:01,650 --> 00:06:08,669
you make Nothingness communicative

00:06:05,300 --> 00:06:11,419
that's what I'm asking you to have

00:06:08,669 --> 00:06:15,300
another sip of coffee and think about

00:06:11,419 --> 00:06:17,039
here's a boring class oops

00:06:15,300 --> 00:06:20,940
that broke my own punch line here's a

00:06:17,039 --> 00:06:22,800
boring class it holds an integer right

00:06:20,940 --> 00:06:24,900
it's got a constructors got another

00:06:22,800 --> 00:06:25,289
constructors got business logic that

00:06:24,900 --> 00:06:27,479
increment

00:06:25,289 --> 00:06:30,270
the number it's got a get number and

00:06:27,479 --> 00:06:32,369
it's got a two string if you've ever

00:06:30,270 --> 00:06:33,599
done any kind of intro to C++ you've

00:06:32,369 --> 00:06:35,879
seen something like this or someone's

00:06:33,599 --> 00:06:38,969
written it for you and here's a

00:06:35,879 --> 00:06:41,189
different version and when I see the

00:06:38,969 --> 00:06:44,490
different version I go like oh so before

00:06:41,189 --> 00:06:47,639
the one argument constructor was not

00:06:44,490 --> 00:06:49,349
marked explicit so it could be implicit

00:06:47,639 --> 00:06:52,789
so you could make a holder rights a

00:06:49,349 --> 00:06:55,349
holder H equals seven now you can't Oh

00:06:52,789 --> 00:06:56,629
get numbers marked constants so it's

00:06:55,349 --> 00:06:59,430
just string that makes sense

00:06:56,629 --> 00:07:00,779
get a number the implementations right

00:06:59,430 --> 00:07:02,550
there you can see it doesn't change a

00:07:00,779 --> 00:07:04,860
member variable right I don't see the

00:07:02,550 --> 00:07:06,509
implementation of two string but if it

00:07:04,860 --> 00:07:08,309
changes the number I'd probably be

00:07:06,509 --> 00:07:09,779
pretty angry again that's about

00:07:08,309 --> 00:07:11,039
communicating to humans the compilers

00:07:09,779 --> 00:07:12,930
like if you want to call it two string

00:07:11,039 --> 00:07:19,399
and then increment number every time

00:07:12,930 --> 00:07:19,399
it's called compiler doesn't care and

00:07:19,879 --> 00:07:26,669
two string is virtual and back here it

00:07:23,159 --> 00:07:28,519
was not virtual so it's not just that

00:07:26,669 --> 00:07:31,889
these two classes are really different

00:07:28,519 --> 00:07:34,229
it's that on this slide you probably

00:07:31,889 --> 00:07:35,939
didn't think and I I know I told you it

00:07:34,229 --> 00:07:37,830
was trivial kind of turn turned off

00:07:35,939 --> 00:07:40,080
you're thinking you didn't think to

00:07:37,830 --> 00:07:44,789
yourself I wonder if any of those

00:07:40,080 --> 00:07:46,919
functions are Const but as soon as two

00:07:44,789 --> 00:07:49,620
functions are marked Const then you

00:07:46,919 --> 00:07:50,789
notice that ink is not which makes sense

00:07:49,620 --> 00:07:53,969
because it increments the number so

00:07:50,789 --> 00:07:58,800
chris is not constant but now that

00:07:53,969 --> 00:08:01,050
nothing is sort of standing out now we

00:07:58,800 --> 00:08:03,719
have lots of pairs of opposites all

00:08:01,050 --> 00:08:07,529
right plus and minus dereference an

00:08:03,719 --> 00:08:11,999
address of all the brackets but most of

00:08:07,529 --> 00:08:15,779
c++ does not have opposites and what is

00:08:11,999 --> 00:08:17,360
the opposite of return it's any whatever

00:08:15,779 --> 00:08:19,080
line of code you want to have next right

00:08:17,360 --> 00:08:20,339
what's the opposite of calling a

00:08:19,080 --> 00:08:21,389
function I don't know not calling that

00:08:20,339 --> 00:08:24,449
function calling a different function

00:08:21,389 --> 00:08:26,219
like that yet there's no answer and I

00:08:24,449 --> 00:08:30,659
want to specifically talk about things

00:08:26,219 --> 00:08:35,169
that could have opposites but don't so

00:08:30,659 --> 00:08:39,260
virtual the opposite virtual is

00:08:35,169 --> 00:08:46,910
the opposite of explicit noting opposite

00:08:39,260 --> 00:08:50,930
of Const nothing I have a theme even

00:08:46,910 --> 00:08:52,670
taking a parameter by value you don't

00:08:50,930 --> 00:08:54,440
put any punctuation when you declare

00:08:52,670 --> 00:08:57,320
that function when you take it by

00:08:54,440 --> 00:08:58,490
reference or by R value reference or

00:08:57,320 --> 00:09:01,730
whatever now you start loading in

00:08:58,490 --> 00:09:04,730
punctuation and so I got kind of

00:09:01,730 --> 00:09:07,850
interested in this in things that are

00:09:04,730 --> 00:09:09,650
the opposite of nothing because we want

00:09:07,850 --> 00:09:11,930
to be able to make our code express

00:09:09,650 --> 00:09:15,920
itself but we don't seem to have any raw

00:09:11,930 --> 00:09:18,260
materials for that expression and I want

00:09:15,920 --> 00:09:20,780
specifically to talk about three new C++

00:09:18,260 --> 00:09:23,120
seventeen attributes that don't change

00:09:20,780 --> 00:09:25,430
the way your code behaves at all

00:09:23,120 --> 00:09:27,800
make no runtime difference whatsoever

00:09:25,430 --> 00:09:31,550
that they affect your compiler and the

00:09:27,800 --> 00:09:33,380
warnings that it issues so here's a

00:09:31,550 --> 00:09:35,780
switch we're switching on some variable

00:09:33,380 --> 00:09:37,580
I and in the case of both one and two

00:09:35,780 --> 00:09:38,990
we're going to do the same thing that's

00:09:37,580 --> 00:09:41,330
common as dirt we all do that all the

00:09:38,990 --> 00:09:43,910
time and then we've got three and four

00:09:41,330 --> 00:09:46,220
and a default and I've kind of

00:09:43,910 --> 00:09:48,770
telegraphed it because of the wording of

00:09:46,220 --> 00:09:51,860
the message for case three normally you

00:09:48,770 --> 00:09:54,860
don't see that hint of the nor hanging

00:09:51,860 --> 00:09:56,990
out there right if I is three this is

00:09:54,860 --> 00:09:59,210
going to do both case three and case

00:09:56,990 --> 00:10:02,000
four it's going to fall through into

00:09:59,210 --> 00:10:03,830
case four and the fall through from one

00:10:02,000 --> 00:10:05,180
to two is common and ordinary and normal

00:10:03,830 --> 00:10:07,310
and there's nothing weird about it at

00:10:05,180 --> 00:10:10,850
all but the fall through from three to

00:10:07,310 --> 00:10:14,470
four it's not common it's probably not

00:10:10,850 --> 00:10:17,210
even normal and it could be a mistake

00:10:14,470 --> 00:10:19,670
because you have to remember to type

00:10:17,210 --> 00:10:21,080
break at the end of each of your cases

00:10:19,670 --> 00:10:22,910
and if you quickly go in and stick one

00:10:21,080 --> 00:10:24,500
in you might be like oh and then in case

00:10:22,910 --> 00:10:25,820
three I'm gonna do that and then you

00:10:24,500 --> 00:10:26,870
leave and then you forgot the break and

00:10:25,820 --> 00:10:30,080
now you're falling through and doing the

00:10:26,870 --> 00:10:31,850
case for stuff I often see it right

00:10:30,080 --> 00:10:34,070
before a default right because we've

00:10:31,850 --> 00:10:36,260
added another another value to the ANU

00:10:34,070 --> 00:10:39,050
m'm we've come in and added another case

00:10:36,260 --> 00:10:41,840
to the switch statement and some

00:10:39,050 --> 00:10:44,470
compilers will warn you if you fall

00:10:41,840 --> 00:10:44,470
through like this

00:10:45,959 --> 00:10:53,920
you can put a comment the compiler does

00:10:51,100 --> 00:10:57,129
not read comments and I do not want to

00:10:53,920 --> 00:10:58,720
open the door to the compiler reading

00:10:57,129 --> 00:11:01,779
comments and backing off of warnings

00:10:58,720 --> 00:11:03,100
because you had a comment er no likes to

00:11:01,779 --> 00:11:05,079
say the the compiler doesn't read

00:11:03,100 --> 00:11:07,559
comments and neither do I and I think

00:11:05,079 --> 00:11:10,059
it's a pretty good point

00:11:07,559 --> 00:11:13,049
this comment won't make a compiler happy

00:11:10,059 --> 00:11:16,360
it just causes a human to maybe

00:11:13,049 --> 00:11:18,610
ignore the warning very anti ignoring

00:11:16,360 --> 00:11:21,879
warnings ok a warning that can be

00:11:18,610 --> 00:11:24,339
ignored is not doing its job so this is

00:11:21,879 --> 00:11:27,339
a C++ 17 attribute that the compiler

00:11:24,339 --> 00:11:30,249
reads and unlike the comment if you use

00:11:27,339 --> 00:11:32,259
the attribute and then break you'll get

00:11:30,249 --> 00:11:34,119
yelled at okay so it will stay

00:11:32,259 --> 00:11:37,089
consistent which the comment does not

00:11:34,119 --> 00:11:38,949
have to so in terms of the way your

00:11:37,089 --> 00:11:40,629
program runs there's no difference

00:11:38,949 --> 00:11:43,929
whether you have this attribute there or

00:11:40,629 --> 00:11:45,819
not it's not that the opposite of this

00:11:43,929 --> 00:11:51,129
is nothing this is actually the same as

00:11:45,819 --> 00:11:52,929
nothing but it's not right because a its

00:11:51,129 --> 00:11:55,240
suppressing a compiler warning and B

00:11:52,929 --> 00:11:59,889
it's speaking to humans and those are

00:11:55,240 --> 00:12:03,579
both really good things to do let's try

00:11:59,889 --> 00:12:05,439
this one I have some function that does

00:12:03,579 --> 00:12:06,970
something reads a file writes a file

00:12:05,439 --> 00:12:11,679
whatever I need to call this function

00:12:06,970 --> 00:12:13,689
and it returns a value that is so kind

00:12:11,679 --> 00:12:15,189
of sometimes occasionally important it's

00:12:13,689 --> 00:12:18,160
more important than the return from

00:12:15,189 --> 00:12:19,689
printf but it's not really important

00:12:18,160 --> 00:12:21,189
once that you know the program is

00:12:19,689 --> 00:12:25,329
working so you have some assert

00:12:21,189 --> 00:12:27,279
involving this return value and I can't

00:12:25,329 --> 00:12:28,839
say assert function with side-effects is

00:12:27,279 --> 00:12:30,309
greater than zero because then when the

00:12:28,839 --> 00:12:33,459
assert falls away in a release build I

00:12:30,309 --> 00:12:34,929
won't call the function right but when

00:12:33,459 --> 00:12:37,629
the assert falls away in the release

00:12:34,929 --> 00:12:40,059
build do you know what I get I get an

00:12:37,629 --> 00:12:42,160
unused variable warning right because I

00:12:40,059 --> 00:12:43,389
put some value in this J and then I did

00:12:42,160 --> 00:12:45,819
nothing with it and I'm obviously a bad

00:12:43,389 --> 00:12:47,980
person and again if you treat warnings

00:12:45,819 --> 00:12:50,230
as errors it's now not possible to get a

00:12:47,980 --> 00:12:52,360
clean build and people do all this gross

00:12:50,230 --> 00:12:54,020
things with testing for debug and stuff

00:12:52,360 --> 00:12:57,480
like that

00:12:54,020 --> 00:13:00,480
but this attribute says to the compiler

00:12:57,480 --> 00:13:02,910
I get it it's possible I'm not using

00:13:00,480 --> 00:13:05,550
this variable leave me alone and you

00:13:02,910 --> 00:13:06,720
won't get the warning that's also handy

00:13:05,550 --> 00:13:07,770
for a variable that you only have

00:13:06,720 --> 00:13:09,660
therefore when you're in the debugger

00:13:07,770 --> 00:13:11,399
and you want to see its value but no one

00:13:09,660 --> 00:13:13,320
ever does a calculation with its value

00:13:11,399 --> 00:13:15,649
you can also use it for that so again

00:13:13,320 --> 00:13:18,540
there's no difference at run time

00:13:15,649 --> 00:13:20,640
between the top line on this slide

00:13:18,540 --> 00:13:22,140
without the attribute and the bottom

00:13:20,640 --> 00:13:24,990
line that you see right now without the

00:13:22,140 --> 00:13:27,690
attribute it's simply a matter of

00:13:24,990 --> 00:13:32,100
suppressing the warning in release when

00:13:27,690 --> 00:13:34,230
this cert line falls away but it's doing

00:13:32,100 --> 00:13:35,940
something not just to change the

00:13:34,230 --> 00:13:37,440
compiler it's also doing something to

00:13:35,940 --> 00:13:43,230
the people who read the code in a way

00:13:37,440 --> 00:13:44,370
that a comment does not another kind of

00:13:43,230 --> 00:13:46,529
nothing is when you don't use your

00:13:44,370 --> 00:13:48,750
return value inside this function get

00:13:46,529 --> 00:13:50,339
number that took me forever to code this

00:13:48,750 --> 00:13:53,820
I have slaved over the demos for you to

00:13:50,339 --> 00:13:55,350
people I want you to know fine I can put

00:13:53,820 --> 00:13:57,149
the result in this local variable but I

00:13:55,350 --> 00:13:58,470
don't have to that's a really stupid

00:13:57,149 --> 00:14:00,089
thing to do because there's no side

00:13:58,470 --> 00:14:03,450
effects in that function so it's a

00:14:00,089 --> 00:14:05,100
pointless behavior but if you haven't

00:14:03,450 --> 00:14:06,450
met any function any code yet that does

00:14:05,100 --> 00:14:10,320
pointless things then you have not been

00:14:06,450 --> 00:14:13,560
in the industry long enough so if the

00:14:10,320 --> 00:14:15,870
person who wrote get number feels that

00:14:13,560 --> 00:14:18,089
this would be very important mistake to

00:14:15,870 --> 00:14:21,329
avoid they can put this no discard

00:14:18,089 --> 00:14:23,130
attribute and now everything's still

00:14:21,329 --> 00:14:25,290
fine if I put it in a variable if I

00:14:23,130 --> 00:14:28,440
don't put it in a variable I will get a

00:14:25,290 --> 00:14:30,660
compiler error I believe but it might be

00:14:28,440 --> 00:14:34,110
a warning discarding your return value

00:14:30,660 --> 00:14:35,640
when you said no so this is different

00:14:34,110 --> 00:14:36,870
kind of nothing right then nothing if

00:14:35,640 --> 00:14:39,810
not bothering to use what you were given

00:14:36,870 --> 00:14:42,209
but now is the author the giver I can

00:14:39,810 --> 00:14:44,250
say you will not ignore what I give you

00:14:42,209 --> 00:14:45,990
now you might put it in a variable and

00:14:44,250 --> 00:14:49,260
mark that variable is maybe unused I

00:14:45,990 --> 00:14:50,940
can't I can't stop you but something is

00:14:49,260 --> 00:14:52,950
going to happen with the return value I

00:14:50,940 --> 00:14:56,040
am NOT printf I need you to at least

00:14:52,950 --> 00:14:58,230
look at my return value so this is

00:14:56,040 --> 00:15:00,320
something that you know didn't come up

00:14:58,230 --> 00:15:03,480
when I was first programming in C++

00:15:00,320 --> 00:15:05,310
because the teams I was on in the 80s

00:15:03,480 --> 00:15:08,759
were teams of one

00:15:05,310 --> 00:15:13,199
and I didn't think my code would last

00:15:08,759 --> 00:15:14,910
long my tuque a problem I didn't worry

00:15:13,199 --> 00:15:16,139
about communicating with my teammates

00:15:14,910 --> 00:15:17,100
because I didn't have an e and it didn't

00:15:16,139 --> 00:15:18,149
worry about communicating with the

00:15:17,100 --> 00:15:20,550
future because I didn't really think the

00:15:18,149 --> 00:15:22,170
application had a future but today we

00:15:20,550 --> 00:15:24,449
have teammates and today we have the

00:15:22,170 --> 00:15:26,939
future and so we are communicating with

00:15:24,449 --> 00:15:28,939
them and we are finding things that are

00:15:26,939 --> 00:15:30,839
semantically perhaps the same as nothing

00:15:28,939 --> 00:15:34,769
except that they communicate with the

00:15:30,839 --> 00:15:37,860
future and that's what I really want you

00:15:34,769 --> 00:15:43,339
to think about expressing intent in a

00:15:37,860 --> 00:15:46,439
place where you don't have to last night

00:15:43,339 --> 00:15:47,610
the quote was by default all the

00:15:46,439 --> 00:15:49,170
defaults are wrong and that's the wrong

00:15:47,610 --> 00:15:51,180
default is that what Titus said

00:15:49,170 --> 00:15:52,649
something like that and it's become a

00:15:51,180 --> 00:15:55,379
trope that all our defaults are wrong

00:15:52,649 --> 00:15:57,930
and I'm not going to argue you know like

00:15:55,379 --> 00:16:01,259
should things be mutable by default and

00:15:57,930 --> 00:16:05,189
only constant them mm-hmm that's that's

00:16:01,259 --> 00:16:08,449
pretty supportable don't use defaults if

00:16:05,189 --> 00:16:12,600
you have a choice so when I go class

00:16:08,449 --> 00:16:15,959
employee open brace the next thing I

00:16:12,600 --> 00:16:16,529
type is private : you know I don't need

00:16:15,959 --> 00:16:18,300
to do that

00:16:16,529 --> 00:16:21,470
right you know in a class there private

00:16:18,300 --> 00:16:24,540
until you say otherwise I do it anyway I

00:16:21,470 --> 00:16:28,529
do it partly because not everybody knows

00:16:24,540 --> 00:16:30,329
that and partly to just be super clear

00:16:28,529 --> 00:16:32,250
doesn't take long for you to go look

00:16:30,329 --> 00:16:34,439
that piece of information up we're all

00:16:32,250 --> 00:16:36,360
very good at looking up things in our

00:16:34,439 --> 00:16:39,389
own brains or on CPP reference which is

00:16:36,360 --> 00:16:40,800
close enough but it does take a little

00:16:39,389 --> 00:16:43,040
bit of time it's kind of like getting

00:16:40,800 --> 00:16:46,079
stuff from cache and so when I put

00:16:43,040 --> 00:16:48,899
private : you don't have to do that and

00:16:46,079 --> 00:16:50,579
yes I will do a struct point with an int

00:16:48,899 --> 00:16:52,829
X and int Y and it will say public

00:16:50,579 --> 00:16:55,980
before that even though of course they

00:16:52,829 --> 00:16:58,290
already are I don't fall out the bottom

00:16:55,980 --> 00:17:02,009
of void functions I have an example on

00:16:58,290 --> 00:17:03,420
that later once something's virtual in

00:17:02,009 --> 00:17:04,860
the base class you don't need to say

00:17:03,420 --> 00:17:07,530
virtual ever again and you certainly

00:17:04,860 --> 00:17:10,980
don't need to say override but you can

00:17:07,530 --> 00:17:12,630
and I'm here to say that you should many

00:17:10,980 --> 00:17:15,720
people say that you should because if

00:17:12,630 --> 00:17:17,490
you are an idiot like me and try to

00:17:15,720 --> 00:17:18,569
override something that isn't virtual in

00:17:17,490 --> 00:17:18,990
the base class you'll get an error

00:17:18,569 --> 00:17:21,540
message

00:17:18,990 --> 00:17:24,360
and while they're not wrong that's an

00:17:21,540 --> 00:17:26,550
easily rebutted argument you simply say

00:17:24,360 --> 00:17:28,190
like we all say all the time oh great

00:17:26,550 --> 00:17:32,460
rule but I'm not an idiot

00:17:28,190 --> 00:17:34,320
well okay yeah I often am but that's not

00:17:32,460 --> 00:17:36,300
the reason I'm giving you that rule the

00:17:34,320 --> 00:17:38,790
rule is so that the person who reads the

00:17:36,300 --> 00:17:40,530
derived class doesn't have to go up and

00:17:38,790 --> 00:17:42,630
look you're telling them it's an

00:17:40,530 --> 00:17:44,760
override and you can't say overwrite if

00:17:42,630 --> 00:17:45,990
it's not so they don't have to check the

00:17:44,760 --> 00:17:47,760
compiler has already checked they can

00:17:45,990 --> 00:17:49,490
count on it because of the keyword not a

00:17:47,760 --> 00:17:55,140
comment

00:17:49,490 --> 00:17:57,059
got any no accept fans I think people

00:17:55,140 --> 00:17:59,010
are just tired like I got like no hands

00:17:57,059 --> 00:18:00,150
and then slowly I got oh wait yeah

00:17:59,010 --> 00:18:03,480
actually I know what that is

00:18:00,150 --> 00:18:05,580
I've heard of no accept that we have no

00:18:03,480 --> 00:18:07,470
except at boule so that people can do

00:18:05,580 --> 00:18:10,130
like complicated spinny things bla bla

00:18:07,470 --> 00:18:13,710
bla but you can just say no except false

00:18:10,130 --> 00:18:16,470
that's legit and it means exactly the

00:18:13,710 --> 00:18:21,990
same as not saying anything he become

00:18:16,470 --> 00:18:24,890
Pilar but of course to me it says this

00:18:21,990 --> 00:18:28,500
function probably throws could throw

00:18:24,890 --> 00:18:32,040
I've thought about it I've heard of no

00:18:28,500 --> 00:18:36,000
accept and I've decided it doesn't apply

00:18:32,040 --> 00:18:38,100
here and that's huge that's a big big

00:18:36,000 --> 00:18:44,610
piece of information compared to not

00:18:38,100 --> 00:18:46,800
saying anything think about how long it

00:18:44,610 --> 00:18:49,020
takes you to make a decision about what

00:18:46,800 --> 00:18:50,520
to do in your code sometimes it comes

00:18:49,020 --> 00:18:53,160
out of your fingers as fast as you can

00:18:50,520 --> 00:18:55,920
type but other times you're gonna stop

00:18:53,160 --> 00:18:58,140
and let go and talk to someone and do

00:18:55,920 --> 00:19:00,750
things at a whiteboard and finally come

00:18:58,140 --> 00:19:06,059
back and put one character into the file

00:19:00,750 --> 00:19:08,000
or don't type something right oh this

00:19:06,059 --> 00:19:11,040
constructor shouldn't be explicit and

00:19:08,000 --> 00:19:14,520
then what do you put in the file nothing

00:19:11,040 --> 00:19:16,980
but you just spent like an hour to make

00:19:14,520 --> 00:19:18,630
that decision why isn't it there why

00:19:16,980 --> 00:19:20,700
does everyone else have to reget that

00:19:18,630 --> 00:19:23,100
decision every time they read your code

00:19:20,700 --> 00:19:28,280
so you're trying to save that time for

00:19:23,100 --> 00:19:32,270
other people now we do not have implicit

00:19:28,280 --> 00:19:32,270
all right would you use implicit

00:19:32,930 --> 00:19:36,960
I'm happy you know cuz that now I think

00:19:35,430 --> 00:19:39,120
this hand delay was like I never thought

00:19:36,960 --> 00:19:40,830
about that before but yeah maybe I would

00:19:39,120 --> 00:19:41,400
write because sometimes that's what you

00:19:40,830 --> 00:19:43,620
want

00:19:41,400 --> 00:19:46,530
you actually want people to say holder h

00:19:43,620 --> 00:19:48,120
equals three and you don't want someone

00:19:46,530 --> 00:19:49,320
else coming along who's read one and a

00:19:48,120 --> 00:19:50,910
half text books and is heard that

00:19:49,320 --> 00:19:53,010
constructors and conversion operators

00:19:50,910 --> 00:19:54,210
should be explicit and slams explicit on

00:19:53,010 --> 00:19:58,980
everything without thinking and breaks

00:19:54,210 --> 00:20:01,110
your code we can't say not Const mutable

00:19:58,980 --> 00:20:04,830
and Const or not really opposites right

00:20:01,110 --> 00:20:06,930
but it might be interesting we don't

00:20:04,830 --> 00:20:09,300
have non virtual when we declare a

00:20:06,930 --> 00:20:11,460
function and this is not VB we don't

00:20:09,300 --> 00:20:15,240
have by Val when we're declaring

00:20:11,460 --> 00:20:17,340
parameters or passing parameters but you

00:20:15,240 --> 00:20:22,010
can kind of see how maybe some days you

00:20:17,340 --> 00:20:24,780
might want them please don't do this

00:20:22,010 --> 00:20:26,730
I've seen this kind of comment the

00:20:24,780 --> 00:20:30,300
famous one of course is trust me on this

00:20:26,730 --> 00:20:34,320
magic that person can live in legend the

00:20:30,300 --> 00:20:37,290
rest of us do not get to do that this is

00:20:34,320 --> 00:20:39,000
a little better right

00:20:37,290 --> 00:20:42,510
drawing someone's attention to your

00:20:39,000 --> 00:20:44,970
nothing passing it by value but you

00:20:42,510 --> 00:20:48,680
haven't said why you haven't really

00:20:44,970 --> 00:20:48,680
communicated as much as you could I

00:20:49,880 --> 00:20:53,910
mentioned this before but I really want

00:20:51,900 --> 00:20:57,450
to spend some time on this if you have a

00:20:53,910 --> 00:20:58,800
function f in some class X and I'm

00:20:57,450 --> 00:21:01,980
choosing these names deliberately

00:20:58,800 --> 00:21:04,320
because to show you know nothing it's

00:21:01,980 --> 00:21:05,790
not get last name an employee you know

00:21:04,320 --> 00:21:08,430
things about that you don't know

00:21:05,790 --> 00:21:13,500
anything and it doesn't say Const on the

00:21:08,430 --> 00:21:15,870
end your decision now is Mike that

00:21:13,500 --> 00:21:19,110
really truly change member variables or

00:21:15,870 --> 00:21:20,520
not and you need to know this for some

00:21:19,110 --> 00:21:24,450
reason that I'm not going to you know

00:21:20,520 --> 00:21:27,480
stuff happens and you have to shake the

00:21:24,450 --> 00:21:31,680
screen and try to reach that person who

00:21:27,480 --> 00:21:34,560
in 1991 wrote this code and say did you

00:21:31,680 --> 00:21:39,080
just not know there was Const I'm not

00:21:34,560 --> 00:21:39,080
sure if there was in 1991

00:21:40,020 --> 00:21:47,700
my I have a 25 year old and he's younger

00:21:42,420 --> 00:21:50,850
than mutable okay but you've heard of

00:21:47,700 --> 00:21:52,440
Const and you just didn't consider it

00:21:50,850 --> 00:21:55,650
here you didn't think it mattered you

00:21:52,440 --> 00:21:58,050
only use it when it matters or you've

00:21:55,650 --> 00:22:00,150
heard of Const you use it all the time

00:21:58,050 --> 00:22:02,130
you're a real pro conscious person my

00:22:00,150 --> 00:22:03,960
badge is off you're an east constant

00:22:02,130 --> 00:22:07,710
because that's correct

00:22:03,960 --> 00:22:12,990
and you're just not using it here

00:22:07,710 --> 00:22:15,540
because you can't because it changes if

00:22:12,990 --> 00:22:18,120
I look at the rest of the code and I see

00:22:15,540 --> 00:22:20,220
lots of Const then when I bump into the

00:22:18,120 --> 00:22:23,040
function f in class X and it's not

00:22:20,220 --> 00:22:26,370
marked Const I can immediately say this

00:22:23,040 --> 00:22:28,470
function changes member variables if the

00:22:26,370 --> 00:22:30,210
parameter is not a con stress but just a

00:22:28,470 --> 00:22:33,090
ref I'm like oh it's an in-out they're

00:22:30,210 --> 00:22:35,580
changing it right I've learned from the

00:22:33,090 --> 00:22:40,650
rest of your codebase what nothing means

00:22:35,580 --> 00:22:43,140
right here so that's kind of weird

00:22:40,650 --> 00:22:44,880
because you're on a team now that's

00:22:43,140 --> 00:22:48,030
spread across people but also across

00:22:44,880 --> 00:22:49,440
time and you know about Const and the

00:22:48,030 --> 00:22:51,420
whole rest of your codebase doesn't say

00:22:49,440 --> 00:22:54,090
Const anywhere in it and you don't want

00:22:51,420 --> 00:22:55,890
to use Const here does that mean you now

00:22:54,090 --> 00:22:57,300
don't need to go fix the whole rest of

00:22:55,890 --> 00:23:04,470
the code base in order to cause this

00:22:57,300 --> 00:23:07,560
absence of cons to speak loudly I try to

00:23:04,470 --> 00:23:10,830
save the comments for the surprising or

00:23:07,560 --> 00:23:12,990
tricky parts of the code and I will say

00:23:10,830 --> 00:23:17,480
I know this looks like X but it's really

00:23:12,990 --> 00:23:21,810
Y so if you have for example a get

00:23:17,480 --> 00:23:23,430
temperature that name tells us all it

00:23:21,810 --> 00:23:26,340
should be Const what that have before to

00:23:23,430 --> 00:23:28,530
string shouldn't increment number right

00:23:26,340 --> 00:23:30,030
so if you have a name that makes people

00:23:28,530 --> 00:23:31,620
think it's just a simple gap and it's

00:23:30,030 --> 00:23:33,570
like oh actually I get the temperature

00:23:31,620 --> 00:23:37,290
from the sensor and then I cache it and

00:23:33,570 --> 00:23:39,600
I and I change the date last temperature

00:23:37,290 --> 00:23:41,850
was God or whatever so it's not constat

00:23:39,600 --> 00:23:43,770
all and that's why and you put a comment

00:23:41,850 --> 00:23:45,800
and you explain why you're deceiving

00:23:43,770 --> 00:23:45,800
people

00:23:46,640 --> 00:23:51,290
I mentioned falling out the bottom of a

00:23:49,340 --> 00:23:54,290
void function take a look at this one I

00:23:51,290 --> 00:23:56,390
got fed up of having F and G so I made

00:23:54,290 --> 00:23:58,160
nonsense words they're also easier for

00:23:56,390 --> 00:23:59,720
me to tell apart when I'm talking so I

00:23:58,160 --> 00:24:02,000
have this function thin Buell that takes

00:23:59,720 --> 00:24:03,800
a robit and messes around with it might

00:24:02,000 --> 00:24:06,290
return in the middle but falls at the

00:24:03,800 --> 00:24:10,490
bottom and there's no return statement

00:24:06,290 --> 00:24:11,330
there other void functions do not fall

00:24:10,490 --> 00:24:13,550
out the bottom

00:24:11,330 --> 00:24:15,230
this is Spri --all it takes an uber

00:24:13,550 --> 00:24:17,510
Naboo messes around with them for a

00:24:15,230 --> 00:24:19,100
while inside a while true and if uber

00:24:17,510 --> 00:24:21,620
finally manages to get bigger than boo

00:24:19,100 --> 00:24:23,720
will return and until that day we will

00:24:21,620 --> 00:24:25,700
not there is no falling out the bottom

00:24:23,720 --> 00:24:28,970
and that's an important piece of

00:24:25,700 --> 00:24:31,430
information about spry 'el and never

00:24:28,970 --> 00:24:35,990
having returned on the bottom of thimble

00:24:31,430 --> 00:24:38,030
you're hiding you're hiding in

00:24:35,990 --> 00:24:41,510
nothingness the important information

00:24:38,030 --> 00:24:43,130
about spry oh okay if you always have a

00:24:41,510 --> 00:24:45,800
return at the bottom if you can actually

00:24:43,130 --> 00:24:48,110
fall at the bottom then when there is no

00:24:45,800 --> 00:24:49,760
return before the last closed brace it's

00:24:48,110 --> 00:24:51,890
because this function doesn't fall out

00:24:49,760 --> 00:24:56,420
the bottom which is something people

00:24:51,890 --> 00:25:00,080
might need to know so you're actually

00:24:56,420 --> 00:25:02,540
adding information to the Spile function

00:25:00,080 --> 00:25:05,330
by typing more code in the thin Buhl

00:25:02,540 --> 00:25:07,310
function and that's what's i'm asking

00:25:05,330 --> 00:25:09,290
you to do something quite strange right

00:25:07,310 --> 00:25:10,940
but that's what I'm asking

00:25:09,290 --> 00:25:12,470
to make your nothing mean something

00:25:10,940 --> 00:25:15,490
there has to be something in the

00:25:12,470 --> 00:25:15,490
equivalent places elsewhere

00:25:20,649 --> 00:25:26,509
all the cool kids do ranged force all

00:25:23,749 --> 00:25:28,279
the time right it's a pretty good one

00:25:26,509 --> 00:25:30,080
I'm gonna go through all the employees

00:25:28,279 --> 00:25:33,200
in the department I'm gonna do something

00:25:30,080 --> 00:25:36,919
with them it's boring till I show you

00:25:33,200 --> 00:25:41,720
this one when I show you this one most

00:25:36,919 --> 00:25:44,690
of you reevaluate the first one Oh huh

00:25:41,720 --> 00:25:48,739
I guess maybe employees are expensive to

00:25:44,690 --> 00:25:49,789
copy or non copyable or something so

00:25:48,739 --> 00:25:51,409
that makes sense we just need we're

00:25:49,789 --> 00:25:53,210
going to go through references okay that

00:25:51,409 --> 00:25:56,419
makes sense that's cool I get it and

00:25:53,210 --> 00:25:58,070
then I'll show you this one now Yuri

00:25:56,419 --> 00:26:00,320
evaluate your opinion of the middle one

00:25:58,070 --> 00:26:03,139
oh the middle one must be changing the

00:26:00,320 --> 00:26:06,139
employee right because you're not taking

00:26:03,139 --> 00:26:10,519
a cost Ref and these aren't necessarily

00:26:06,139 --> 00:26:14,389
valid conclusions emptied not become

00:26:10,519 --> 00:26:18,139
more expensive to copy because I put an

00:26:14,389 --> 00:26:22,249
ampersand in my coat amp is or is not

00:26:18,139 --> 00:26:24,619
expensive to copy did I naively work

00:26:22,249 --> 00:26:29,570
with a copy work by value in the first

00:26:24,619 --> 00:26:31,970
example maybe the middle for loop if it

00:26:29,570 --> 00:26:36,320
didn't have dots wouldn't magically

00:26:31,970 --> 00:26:39,619
start mutating these employees because I

00:26:36,320 --> 00:26:42,649
didn't say Const ref it does or it

00:26:39,619 --> 00:26:44,179
doesn't mutate them but now you start to

00:26:42,649 --> 00:26:45,980
think about the possibility once you're

00:26:44,179 --> 00:26:52,070
reminded that if it didn't it could say

00:26:45,980 --> 00:26:55,789
it didn't so again you have this cool

00:26:52,070 --> 00:26:57,950
kids effect someone who's just starting

00:26:55,789 --> 00:26:58,970
in the language they go Auto AMP :

00:26:57,950 --> 00:27:01,159
Department because that's what they were

00:26:58,970 --> 00:27:02,330
taught and they do it no matter how big

00:27:01,159 --> 00:27:03,559
the thing is and they don't worry about

00:27:02,330 --> 00:27:04,999
perf because we have big powerful

00:27:03,559 --> 00:27:07,159
computers and it's not an important loop

00:27:04,999 --> 00:27:08,600
in blah blah blah and then someone else

00:27:07,159 --> 00:27:11,809
tells them you should be doing that by

00:27:08,600 --> 00:27:15,559
reference and they may even be right in

00:27:11,809 --> 00:27:17,440
that case but the learner says ranged

00:27:15,559 --> 00:27:20,169
for loops should be by reference got it

00:27:17,440 --> 00:27:23,119
so now all their loops are by reference

00:27:20,169 --> 00:27:25,009
whether they need it or not and then

00:27:23,119 --> 00:27:26,509
another cool kid comes along and tells

00:27:25,009 --> 00:27:28,309
them but you're not changing anything so

00:27:26,509 --> 00:27:30,019
it should be constant reference and very

00:27:28,309 --> 00:27:32,419
often they hear Oh all the ranged for

00:27:30,019 --> 00:27:33,770
should be constant reference and so you

00:27:32,419 --> 00:27:36,170
don't know

00:27:33,770 --> 00:27:40,520
if these artifacts are in the code on

00:27:36,170 --> 00:27:45,320
purpose or not and yet they send us

00:27:40,520 --> 00:27:47,720
information when I don't see that the

00:27:45,320 --> 00:27:49,280
first one I don't see any punctuation it

00:27:47,720 --> 00:27:51,830
sends me the information this guy's

00:27:49,280 --> 00:27:53,450
cheap to copy or this loop is a very

00:27:51,830 --> 00:27:56,000
small loop and a tiny backwater of the

00:27:53,450 --> 00:27:57,980
program it would be wonderful if those

00:27:56,000 --> 00:28:00,020
things were true I want you to write

00:27:57,980 --> 00:28:01,910
code where you only send those messages

00:28:00,020 --> 00:28:04,070
when those messages are true that's

00:28:01,910 --> 00:28:06,710
really what I'm that's my message today

00:28:04,070 --> 00:28:08,750
right think about what you sent if it's

00:28:06,710 --> 00:28:10,190
not true don't say it so in the middle

00:28:08,750 --> 00:28:11,720
one if it's not true that you're gonna

00:28:10,190 --> 00:28:15,950
change it why are you saying that you

00:28:11,720 --> 00:28:17,900
might send put the constant so this

00:28:15,950 --> 00:28:20,630
requires a little more like meta

00:28:17,900 --> 00:28:21,890
thinking your heads already full of I

00:28:20,630 --> 00:28:23,240
need to go through all the employees in

00:28:21,890 --> 00:28:25,220
the department and bla bla bla bla bla

00:28:23,240 --> 00:28:26,929
and then on top of that you need to be

00:28:25,220 --> 00:28:28,820
saying not just what about performance

00:28:26,929 --> 00:28:30,920
but like what message am i sending to

00:28:28,820 --> 00:28:33,770
the future and I understand I'm layering

00:28:30,920 --> 00:28:35,660
work on but for me when I come in 15

00:28:33,770 --> 00:28:37,780
years later and nobody knows what the

00:28:35,660 --> 00:28:40,100
heck it's doing or why it works I'm

00:28:37,780 --> 00:28:44,150
desperate for this kind of context in

00:28:40,100 --> 00:28:46,010
this kind of information and it's true

00:28:44,150 --> 00:28:49,580
when you're passing parameters exactly

00:28:46,010 --> 00:28:53,420
the same let's create an order we take a

00:28:49,580 --> 00:28:57,380
customer and an order item do we would

00:28:53,420 --> 00:29:00,020
that be right like wouldn't a customer

00:28:57,380 --> 00:29:02,510
object somehow be able to get to its

00:29:00,020 --> 00:29:06,140
orders so wouldn't the act of creating

00:29:02,510 --> 00:29:09,410
an order somehow change the customer by

00:29:06,140 --> 00:29:12,080
adding something to its collection so if

00:29:09,410 --> 00:29:14,390
I see that you take a customer reference

00:29:12,080 --> 00:29:15,410
I'm like ah that makes sense I know what

00:29:14,390 --> 00:29:17,000
you're gonna do to the customers

00:29:15,410 --> 00:29:19,730
non-cost reference that learn something

00:29:17,000 --> 00:29:23,990
you're still taking the order item by

00:29:19,730 --> 00:29:26,540
value why are you doing that why is it

00:29:23,990 --> 00:29:30,440
gonna have an independent life outside

00:29:26,540 --> 00:29:32,320
the order what is it gonna go in another

00:29:30,440 --> 00:29:35,540
order as well like why is this a copy

00:29:32,320 --> 00:29:36,740
well if you go to enough conferences you

00:29:35,540 --> 00:29:39,260
start to meet the people who are like

00:29:36,740 --> 00:29:41,690
take it by value and then move it that

00:29:39,260 --> 00:29:43,040
kind of thing so you're like oh maybe

00:29:41,690 --> 00:29:44,809
that's what's happening maybe it doesn't

00:29:43,040 --> 00:29:46,370
have an independent life outside you're

00:29:44,809 --> 00:29:47,450
going to move it inside which has some

00:29:46,370 --> 00:29:53,299
performance benefits if

00:29:47,450 --> 00:29:54,620
and our value now we're back to a Const

00:29:53,299 --> 00:29:55,850
ref on the customer and I'm again I'm

00:29:54,620 --> 00:29:58,429
like what the customer doesn't know

00:29:55,850 --> 00:30:01,690
about its orders so most of these

00:29:58,429 --> 00:30:06,139
signatures are confusing me a lot and

00:30:01,690 --> 00:30:08,510
you're focused on perf maybe constants

00:30:06,139 --> 00:30:12,380
if I'm lucky but I'm saying like what

00:30:08,510 --> 00:30:15,590
are you telling me and it it might not

00:30:12,380 --> 00:30:18,860
hurt to throw in a comment okay

00:30:15,590 --> 00:30:21,289
perhaps the this thing returns an order

00:30:18,860 --> 00:30:23,029
perhaps whatever created the order will

00:30:21,289 --> 00:30:25,100
now also go and tell the customer this

00:30:23,029 --> 00:30:26,659
is your new order and it is in fact the

00:30:25,100 --> 00:30:28,880
case that the act the create order

00:30:26,659 --> 00:30:31,399
function doesn't touch the customer at

00:30:28,880 --> 00:30:34,070
all it just uses it for pricing tiers or

00:30:31,399 --> 00:30:36,769
something that's cool a comment here

00:30:34,070 --> 00:30:38,240
would help with that right so you think

00:30:36,769 --> 00:30:40,760
it's just all about well how expensive

00:30:38,240 --> 00:30:41,960
is it to copy a thing there's more going

00:30:40,760 --> 00:30:45,830
on than that in terms of people

00:30:41,960 --> 00:30:48,880
understanding your api's philosophy from

00:30:45,830 --> 00:30:51,500
just looking at a couple of signatures

00:30:48,880 --> 00:30:53,330
the middle one is the one that I'm most

00:30:51,500 --> 00:30:56,029
likely to think the person thought it

00:30:53,330 --> 00:30:57,679
through both the top and the bottom one

00:30:56,029 --> 00:30:59,899
I think are kind of just reflexive

00:30:57,679 --> 00:31:02,450
habits and hasn't had a lot of thought

00:30:59,899 --> 00:31:04,100
put into it and that's just I guess they

00:31:02,450 --> 00:31:05,690
probably just Prejudice on my part

00:31:04,100 --> 00:31:06,889
that's probably understand anything

00:31:05,690 --> 00:31:08,929
technical behind that I was telling you

00:31:06,889 --> 00:31:14,029
how it makes me feel probably makes you

00:31:08,929 --> 00:31:15,279
feel something similar another kind of

00:31:14,029 --> 00:31:19,100
nothing

00:31:15,279 --> 00:31:20,600
who did see before they did C++ it's

00:31:19,100 --> 00:31:24,230
less it's less hands every year but I'd

00:31:20,600 --> 00:31:25,610
say it's still a good third so in C you

00:31:24,230 --> 00:31:26,659
know you don't you know well if you go

00:31:25,610 --> 00:31:29,210
back far enough you don't even have to

00:31:26,659 --> 00:31:31,399
say parameters but you you can and you

00:31:29,210 --> 00:31:33,679
can still in C++ leave out the parameter

00:31:31,399 --> 00:31:35,630
names there's this function called

00:31:33,679 --> 00:31:40,429
determine total taxes and it takes int

00:31:35,630 --> 00:31:42,080
int int and I tested this last week and

00:31:40,429 --> 00:31:44,690
a very up-to-date compiler and it's like

00:31:42,080 --> 00:31:47,360
yep I'm good thanks okay but you're not

00:31:44,690 --> 00:31:51,100
good don't do that okay that's not fair

00:31:47,360 --> 00:31:53,600
or right and most of us never do that

00:31:51,100 --> 00:31:57,830
but did you know that you can also in

00:31:53,600 --> 00:32:00,379
the definition if you're not using the

00:31:57,830 --> 00:32:01,200
parameter which can totally happen you

00:32:00,379 --> 00:32:02,490
know it's some kind of virtual

00:32:01,200 --> 00:32:04,529
function that takes three parameters you

00:32:02,490 --> 00:32:09,330
don't care about them also api's change

00:32:04,529 --> 00:32:11,700
over time and the reason that you can

00:32:09,330 --> 00:32:13,320
and the reason it was added and I have

00:32:11,700 --> 00:32:15,419
this from the horse's mouth is to

00:32:13,320 --> 00:32:17,159
suppress the warning about not using one

00:32:15,419 --> 00:32:18,360
of your parameters so if you take three

00:32:17,159 --> 00:32:19,590
parameters you give them all names you

00:32:18,360 --> 00:32:21,179
don't use one of them you get a warning

00:32:19,590 --> 00:32:25,529
but if you don't give it a name you

00:32:21,179 --> 00:32:26,610
don't get the warning yeah but even if

00:32:25,529 --> 00:32:29,580
you're someone who's like oh yeah we

00:32:26,610 --> 00:32:30,630
compiled at a high warning level and we

00:32:29,580 --> 00:32:32,220
get three hundred and forty seven

00:32:30,630 --> 00:32:33,899
warnings and if we ever get three

00:32:32,220 --> 00:32:36,149
hundred forty-eight will investigate but

00:32:33,899 --> 00:32:37,169
there's a there's a huge 347 on the

00:32:36,149 --> 00:32:38,639
white board in the team room and

00:32:37,169 --> 00:32:40,019
everyone knows as long as you get three

00:32:38,639 --> 00:32:45,139
hundred forty seven warnings you're

00:32:40,019 --> 00:32:45,139
golden I wish I was making that up

00:32:45,889 --> 00:32:51,659
but you can suppress the warning by

00:32:48,840 --> 00:32:53,850
hiding the name but even if you don't

00:32:51,659 --> 00:32:55,950
care about suppressing the warning once

00:32:53,850 --> 00:32:59,220
you hide the name you make the function

00:32:55,950 --> 00:33:01,950
easier to call imagine I need to call

00:32:59,220 --> 00:33:04,350
determine total taxes and these are

00:33:01,950 --> 00:33:06,120
proud rate Fed rate and municipal rate

00:33:04,350 --> 00:33:09,029
this is a Canadian slide deck we have

00:33:06,120 --> 00:33:12,059
provincial rates state rates for

00:33:09,029 --> 00:33:13,679
Americans in the room and says municipal

00:33:12,059 --> 00:33:15,750
rate and where I live there is no

00:33:13,679 --> 00:33:17,940
municipal rate so now I'm like oh no I

00:33:15,750 --> 00:33:20,610
can't use this function because I don't

00:33:17,940 --> 00:33:23,100
know a municipal rate to pass but if I

00:33:20,610 --> 00:33:25,409
see that it takes prod rate Fed rate and

00:33:23,100 --> 00:33:27,059
then just an unnamed int I know that

00:33:25,409 --> 00:33:29,580
means it doesn't use the third parameter

00:33:27,059 --> 00:33:31,289
and I can pass zero or minus one or ten

00:33:29,580 --> 00:33:33,539
thousand or whatever I feel like because

00:33:31,289 --> 00:33:35,820
it won't be used I'll probably pass zero

00:33:33,539 --> 00:33:38,519
that's kind of polite but I get a

00:33:35,820 --> 00:33:40,980
reassurance as an API consumer that in

00:33:38,519 --> 00:33:42,000
this particular case it's okay it

00:33:40,980 --> 00:33:43,649
doesn't matter that you don't know what

00:33:42,000 --> 00:33:44,850
to pass for the third parameter nobody

00:33:43,649 --> 00:33:46,769
cares what you pass for the third

00:33:44,850 --> 00:33:49,919
parameter whereas when you gave it a

00:33:46,769 --> 00:33:51,720
name and ignored the warning you did it

00:33:49,919 --> 00:33:55,230
you missed an opportunity to give

00:33:51,720 --> 00:33:56,970
information to the caller and it is a

00:33:55,230 --> 00:33:59,450
very big signal and one that I wish more

00:33:56,970 --> 00:33:59,450
people gave

00:34:02,820 --> 00:34:07,000
this is the recommendation from me for

00:34:05,530 --> 00:34:10,030
how you declare these functions then

00:34:07,000 --> 00:34:11,740
okay do include variable names if you're

00:34:10,030 --> 00:34:18,760
going to use the parameter and don't if

00:34:11,740 --> 00:34:20,350
you're not now I want to drift a little

00:34:18,760 --> 00:34:21,909
from nothing because I think there's

00:34:20,350 --> 00:34:24,490
some related things where you're making

00:34:21,909 --> 00:34:26,980
a seemingly arbitrary choice that

00:34:24,490 --> 00:34:28,810
communicates and and these are not so

00:34:26,980 --> 00:34:30,909
cut and dried about what the choice

00:34:28,810 --> 00:34:36,480
means I just want you to start loading

00:34:30,909 --> 00:34:39,129
them into your head when we first got

00:34:36,480 --> 00:34:40,389
truly smart smart pointers compared to

00:34:39,129 --> 00:34:43,540
the dumb smart pointers we had had

00:34:40,389 --> 00:34:45,159
before there was a great rush to say

00:34:43,540 --> 00:34:47,500
that there should be no more raw

00:34:45,159 --> 00:34:50,740
pointers and that was never the actual

00:34:47,500 --> 00:34:54,010
rule right there should be no owning raw

00:34:50,740 --> 00:34:57,730
pointers so if I meet a raw pointer in

00:34:54,010 --> 00:35:04,330
your code is it an owning raw pointer or

00:34:57,730 --> 00:35:07,570
are you a good person send emails takes

00:35:04,330 --> 00:35:10,870
an employee pointer without going and

00:35:07,570 --> 00:35:12,340
looking at the code for send emails if

00:35:10,870 --> 00:35:14,500
you're the proud owner of an employee

00:35:12,340 --> 00:35:17,380
pointer and it's an owning pointer that

00:35:14,500 --> 00:35:18,850
you intend to delete is send emails

00:35:17,380 --> 00:35:19,120
going to clean it up on you when it's

00:35:18,850 --> 00:35:25,210
done

00:35:19,120 --> 00:35:28,030
I dunno could it come back null and you

00:35:25,210 --> 00:35:30,580
can't delete anymore I don't know this

00:35:28,030 --> 00:35:32,110
one I'm is this a scarier send emails

00:35:30,580 --> 00:35:34,900
now is gonna give me back a message

00:35:32,110 --> 00:35:38,550
pointer I bet you it nude up that darn

00:35:34,900 --> 00:35:41,680
message but maybe not maybe someone else

00:35:38,550 --> 00:35:46,030
did it who's managing messages lifetime

00:35:41,680 --> 00:35:48,190
is this my problem and it's a very hard

00:35:46,030 --> 00:35:49,840
question to answer if you can't talk to

00:35:48,190 --> 00:35:51,010
the developers even going and reading

00:35:49,840 --> 00:35:54,070
the code for send emails isn't

00:35:51,010 --> 00:35:55,840
necessarily going to help you so I try

00:35:54,070 --> 00:35:58,630
to talk to the developers by reading all

00:35:55,840 --> 00:36:00,130
the rest of the code if the rest of the

00:35:58,630 --> 00:36:03,700
code is full of shared and unique

00:36:00,130 --> 00:36:06,160
pointers these people know about smart

00:36:03,700 --> 00:36:08,380
pointers and this is probably just a

00:36:06,160 --> 00:36:11,220
sort of observing pointer that I don't

00:36:08,380 --> 00:36:13,410
have to worry about the lifetime if

00:36:11,220 --> 00:36:16,080
every class

00:36:13,410 --> 00:36:17,580
has constructors and destructors and the

00:36:16,080 --> 00:36:19,560
constructors are doing things in the

00:36:17,580 --> 00:36:21,570
destructors deleting things and they've

00:36:19,560 --> 00:36:22,650
clearly shown their their grasp of the

00:36:21,570 --> 00:36:24,090
rule of three so they have copy

00:36:22,650 --> 00:36:25,590
constructors they have copy assignment

00:36:24,090 --> 00:36:26,880
operators some of them have got move

00:36:25,590 --> 00:36:27,990
constructors and move assignment

00:36:26,880 --> 00:36:31,680
operators so they're doing the rule of

00:36:27,990 --> 00:36:33,840
five that's the game they're playing in

00:36:31,680 --> 00:36:37,040
their code they're doing new and delete

00:36:33,840 --> 00:36:39,750
themselves and that raises the chances

00:36:37,040 --> 00:36:42,290
dramatically that message is an owning

00:36:39,750 --> 00:36:46,530
pointer that I'm supposed to clean up

00:36:42,290 --> 00:36:50,100
right but if I go through their code and

00:36:46,530 --> 00:36:51,420
I don't see any destructors or I see one

00:36:50,100 --> 00:36:53,820
that closes a file but I don't see any

00:36:51,420 --> 00:36:56,250
memory management don't see any deletes

00:36:53,820 --> 00:36:59,040
I'm not introducing delete into this

00:36:56,250 --> 00:37:00,150
code base right message pointer is

00:36:59,040 --> 00:37:02,490
clearly they're just given me an

00:37:00,150 --> 00:37:04,380
observer pointer in case I'm curious and

00:37:02,490 --> 00:37:05,820
want to look at it or log something but

00:37:04,380 --> 00:37:09,630
its life time is being managed by

00:37:05,820 --> 00:37:14,130
someone else I can only learn that from

00:37:09,630 --> 00:37:15,960
the other code well or maybe maybe by

00:37:14,130 --> 00:37:18,780
reading send emails but I don't want to

00:37:15,960 --> 00:37:22,200
and there are rappers right you can find

00:37:18,780 --> 00:37:24,390
the observer pointer the guidelines

00:37:22,200 --> 00:37:26,880
support library has an owner which does

00:37:24,390 --> 00:37:28,290
nothing but it's just tags that this is

00:37:26,880 --> 00:37:31,110
an owning pointer as opposed to an on

00:37:28,290 --> 00:37:32,550
owning one but you really have to use

00:37:31,110 --> 00:37:34,980
the rest of the code to speak what the

00:37:32,550 --> 00:37:36,780
default is and if it's not tagged it

00:37:34,980 --> 00:37:42,270
must be owning or if it's not tagged it

00:37:36,780 --> 00:37:43,890
must be non owning what does it mean to

00:37:42,270 --> 00:37:47,760
take something by reference versus to

00:37:43,890 --> 00:37:50,400
take something by address back in the

00:37:47,760 --> 00:37:53,070
day when we were trying to still do new

00:37:50,400 --> 00:37:55,710
and delete by hand we tried to make this

00:37:53,070 --> 00:37:58,320
choice which is arbitrary carry meaning

00:37:55,710 --> 00:38:01,680
and you may have worked in places like

00:37:58,320 --> 00:38:05,160
that too if I pass it to you by

00:38:01,680 --> 00:38:08,070
reference you can change it but I still

00:38:05,160 --> 00:38:10,260
own it if I pass it to you by address

00:38:08,070 --> 00:38:15,480
you can delete it when you're done it's

00:38:10,260 --> 00:38:17,430
yours and I'm glad we don't do that

00:38:15,480 --> 00:38:19,800
anymore but I still meet code that does

00:38:17,430 --> 00:38:22,740
that and in some cases that rule is not

00:38:19,800 --> 00:38:25,530
written down anywhere everybody knows it

00:38:22,740 --> 00:38:27,390
except that everybody who knew it you

00:38:25,530 --> 00:38:29,970
know has left in about 2000

00:38:27,390 --> 00:38:34,200
and so we have to deduce it from the

00:38:29,970 --> 00:38:36,540
code that's left behind it can be really

00:38:34,200 --> 00:38:38,520
kind of mind twisting to come across a

00:38:36,540 --> 00:38:40,440
paradigm like that it's not a rule it's

00:38:38,520 --> 00:38:42,960
it's a foundational belief and behavior

00:38:40,440 --> 00:38:45,570
system simply because it is not written

00:38:42,960 --> 00:38:47,250
down when I was when I was a young

00:38:45,570 --> 00:38:49,020
person someone asked me if I felt

00:38:47,250 --> 00:38:51,060
pressured to go to university when I

00:38:49,020 --> 00:38:53,310
finished high school both of my parents

00:38:51,060 --> 00:38:55,050
have PhDs and were University professors

00:38:53,310 --> 00:38:57,060
and I said to the person did you feel

00:38:55,050 --> 00:38:59,730
pressure to wear clothes when you were a

00:38:57,060 --> 00:39:01,050
child like you can only feel pressure to

00:38:59,730 --> 00:39:03,300
do something if you have an option not

00:39:01,050 --> 00:39:05,940
to do it and that's the level of rule

00:39:03,300 --> 00:39:08,310
I'm talking about with this star

00:39:05,940 --> 00:39:09,660
ampersand business that people do it's

00:39:08,310 --> 00:39:10,800
not written down because it's like you

00:39:09,660 --> 00:39:12,210
have to wear clothes when you come to

00:39:10,800 --> 00:39:18,630
the office that's not written down

00:39:12,210 --> 00:39:19,950
either but everybody does it I hope we

00:39:18,630 --> 00:39:23,760
have lots of ways of doing things over

00:39:19,950 --> 00:39:27,450
and over we have while we have two kinds

00:39:23,760 --> 00:39:31,800
of four how do you choose which kind of

00:39:27,450 --> 00:39:33,600
four to use some people default to the

00:39:31,800 --> 00:39:36,990
four they've been using for thirty years

00:39:33,600 --> 00:39:40,590
and only use arranged for in special

00:39:36,990 --> 00:39:42,360
cases and some people default arranged

00:39:40,590 --> 00:39:47,490
for and only use a traditional foreign

00:39:42,360 --> 00:39:51,630
special cases so if I see a non ranged

00:39:47,490 --> 00:39:54,150
for loop is this like alert alert danger

00:39:51,630 --> 00:39:56,490
Will Robinson this is a strange loop

00:39:54,150 --> 00:39:57,870
it's not touching them all maybe it's

00:39:56,490 --> 00:39:59,820
touching every other one maybe it's

00:39:57,870 --> 00:40:03,300
sometimes backs up and does it again or

00:39:59,820 --> 00:40:05,550
are you just a person who likes using

00:40:03,300 --> 00:40:08,130
the old style loop even if you are

00:40:05,550 --> 00:40:11,130
touching every element so once again the

00:40:08,130 --> 00:40:12,990
answer is not in this file right the

00:40:11,130 --> 00:40:15,120
answer is probably in your other files

00:40:12,990 --> 00:40:17,280
what is the reason why you did it this

00:40:15,120 --> 00:40:19,590
way and for that matter why are you

00:40:17,280 --> 00:40:22,070
writing a loop Scott's here this week

00:40:19,590 --> 00:40:27,560
right how long has Scott been saying no

00:40:22,070 --> 00:40:31,710
raw loops we have a function for that

00:40:27,560 --> 00:40:34,170
now we have lambdas now you know mmm the

00:40:31,710 --> 00:40:36,300
last seven years we have no excuse

00:40:34,170 --> 00:40:37,050
though I don't like function pointers

00:40:36,300 --> 00:40:40,080
they're so yucky

00:40:37,050 --> 00:40:41,220
I agree but we have algorithm it's

00:40:40,080 --> 00:40:43,859
available to us

00:40:41,220 --> 00:40:48,060
if your loop is finding all the rush

00:40:43,859 --> 00:40:51,180
orders if your loop is updating the date

00:40:48,060 --> 00:40:53,310
on everybody's file we have algorithms

00:40:51,180 --> 00:40:55,230
for that why aren't you using an

00:40:53,310 --> 00:40:59,520
algorithm and then you may say to me oh

00:40:55,230 --> 00:41:01,280
because for my data this is weird edge

00:40:59,520 --> 00:41:05,490
case and such a thing doesn't work well

00:41:01,280 --> 00:41:07,950
okay if I know you use algorithms if I

00:41:05,490 --> 00:41:09,510
saw accumulate which in my mind is an

00:41:07,950 --> 00:41:11,849
honorary member of algorithm even though

00:41:09,510 --> 00:41:15,900
it's in numeric if I saw accumulate if I

00:41:11,849 --> 00:41:18,810
saw find if I saw any of love any of and

00:41:15,900 --> 00:41:20,760
all of and none of they're amazing they

00:41:18,810 --> 00:41:22,560
do what they say I don't want to know if

00:41:20,760 --> 00:41:25,950
all of these are rush orders you get

00:41:22,560 --> 00:41:28,710
back to or false if I see those

00:41:25,950 --> 00:41:31,349
elsewhere then this loop gets my

00:41:28,710 --> 00:41:33,660
attention right what is happening here

00:41:31,349 --> 00:41:36,030
what is so unique and special that it's

00:41:33,660 --> 00:41:38,660
not a problem any other programmer has

00:41:36,030 --> 00:41:41,190
ever had before I want to read this loop

00:41:38,660 --> 00:41:42,839
but if you just apparently aren't aware

00:41:41,190 --> 00:41:45,119
that there's a standard library then

00:41:42,839 --> 00:41:48,920
your loop doesn't carry that sense of

00:41:45,119 --> 00:41:48,920
drama and tension to me right

00:41:51,319 --> 00:41:58,140
initializing here's another piece of

00:41:55,470 --> 00:42:00,480
nothing I got five or six constructors

00:41:58,140 --> 00:42:02,550
in a class that's got five or six member

00:42:00,480 --> 00:42:04,440
variables and I'm reading one of the

00:42:02,550 --> 00:42:05,910
constructors and we all know the best

00:42:04,440 --> 00:42:08,670
place to initialize the member variables

00:42:05,910 --> 00:42:10,170
is before the braces after the colon and

00:42:08,670 --> 00:42:14,609
there's a member variable that's not

00:42:10,170 --> 00:42:18,300
there so they're never ABCDE but let's

00:42:14,609 --> 00:42:20,520
make them ABCDE and E is not there he is

00:42:18,300 --> 00:42:25,400
not initialized in this constructors

00:42:20,520 --> 00:42:27,630
initialization clause why is that well

00:42:25,400 --> 00:42:29,910
maybe there's a non-static member

00:42:27,630 --> 00:42:31,650
initializer when you're initializing to

00:42:29,910 --> 00:42:33,869
a default value rather than a parameter

00:42:31,650 --> 00:42:35,369
to the constructor a non-static member

00:42:33,869 --> 00:42:37,950
initializer is a better place to do it

00:42:35,369 --> 00:42:39,119
because you do it once and then as long

00:42:37,950 --> 00:42:40,980
as the other constructors don't mention

00:42:39,119 --> 00:42:43,410
it that's the value it will get that's

00:42:40,980 --> 00:42:45,480
actually better that that's a good thing

00:42:43,410 --> 00:42:47,010
but that's not the only reason it's not

00:42:45,480 --> 00:42:50,270
there you you all know that the other

00:42:47,010 --> 00:42:53,910
reason is maybe it's between the braces

00:42:50,270 --> 00:42:54,960
which isn't always wrong but is often

00:42:53,910 --> 00:42:56,700
wrong right

00:42:54,960 --> 00:42:58,380
so the answer to why might be because it

00:42:56,700 --> 00:42:59,760
was done by a Java programmer who's come

00:42:58,380 --> 00:43:03,450
into C++ and putting all their

00:42:59,760 --> 00:43:05,869
initialization in the braces but I like

00:43:03,450 --> 00:43:08,790
this one oh yeah when we added e I

00:43:05,869 --> 00:43:12,420
forgot to go to all the initializer

00:43:08,790 --> 00:43:14,430
clauses and initialize E or I forgot in

00:43:12,420 --> 00:43:14,790
some of the constructors that's a good

00:43:14,430 --> 00:43:20,490
one

00:43:14,790 --> 00:43:23,069
that's that's a fun one it all boils

00:43:20,490 --> 00:43:25,920
down to this did you say nothing because

00:43:23,069 --> 00:43:29,130
you forgot or did you say nothing

00:43:25,920 --> 00:43:32,460
because there was nothing to say what

00:43:29,130 --> 00:43:35,849
can you do that everybody knows which

00:43:32,460 --> 00:43:36,990
game you're in now there's one

00:43:35,849 --> 00:43:40,859
contradiction and since we're on

00:43:36,990 --> 00:43:44,280
initialization I put it here here I want

00:43:40,859 --> 00:43:50,040
you to say nothing this code puzzles me

00:43:44,280 --> 00:43:54,390
and I see it a lot and I go but if you

00:43:50,040 --> 00:43:57,000
just said string s you'd get quote quote

00:43:54,390 --> 00:43:59,839
right you'd get an empty string if you

00:43:57,000 --> 00:44:03,869
just said vector of employee Department

00:43:59,839 --> 00:44:08,369
semicolon you'd get a zero length vector

00:44:03,869 --> 00:44:10,410
of employees why are you doing this now

00:44:08,369 --> 00:44:12,750
I'm not I don't feel I'm not when these

00:44:10,410 --> 00:44:15,000
people who feel sorry for the CPU you

00:44:12,750 --> 00:44:20,130
know like oh the poor little CPU at but

00:44:15,000 --> 00:44:22,130
no what are you doing to me okay do you

00:44:20,130 --> 00:44:25,500
not know that that's what you get

00:44:22,130 --> 00:44:27,809
because to be fair if you say int I it's

00:44:25,500 --> 00:44:29,970
not zero right

00:44:27,809 --> 00:44:32,280
so the person especially again coming

00:44:29,970 --> 00:44:33,630
from another language like C++ doesn't

00:44:32,280 --> 00:44:35,849
initialize things for you you got to

00:44:33,630 --> 00:44:38,339
initialize your stuff and that's a good

00:44:35,849 --> 00:44:40,410
lesson and is that all that's happening

00:44:38,339 --> 00:44:43,980
here or did he use to initialize the

00:44:40,410 --> 00:44:45,569
string to like space or 27 X's or

00:44:43,980 --> 00:44:47,490
something and then there was a business

00:44:45,569 --> 00:44:48,750
rule change and they just chopped it

00:44:47,490 --> 00:44:49,920
down to quote quote without thinking

00:44:48,750 --> 00:44:52,410
about the fact they could just take it

00:44:49,920 --> 00:44:54,839
away completely so suddenly this like a

00:44:52,410 --> 00:44:56,520
little undock you assign I'm staring at

00:44:54,839 --> 00:44:58,049
for 10 minutes and I'm reading all the

00:44:56,520 --> 00:45:00,480
rest of things and I'm what do we do

00:44:58,049 --> 00:45:01,680
with s after this and and and is there

00:45:00,480 --> 00:45:06,030
something important in the changelog

00:45:01,680 --> 00:45:07,210
because I I'm at the door to the pyramid

00:45:06,030 --> 00:45:08,920
and I'm trying to understand how

00:45:07,210 --> 00:45:11,560
to get in you know if I slide this rock

00:45:08,920 --> 00:45:13,030
this way and the person probably didn't

00:45:11,560 --> 00:45:15,010
give any thought at all to writing this

00:45:13,030 --> 00:45:18,460
line of code but they've stopped me in

00:45:15,010 --> 00:45:19,960
my tracks and so here is actually the

00:45:18,460 --> 00:45:23,920
one place where I'm going to advocate

00:45:19,960 --> 00:45:26,260
for nothing you just say string s just

00:45:23,920 --> 00:45:33,310
say vector of employees Department

00:45:26,260 --> 00:45:36,369
I asked if you would use implicit we are

00:45:33,310 --> 00:45:39,099
probably getting explicit at false just

00:45:36,369 --> 00:45:43,150
like no except at false actually there

00:45:39,099 --> 00:45:45,490
to help people writing templated code if

00:45:43,150 --> 00:45:46,900
you're trying to wrap something up and

00:45:45,490 --> 00:45:49,150
the thing you're wrapping has a

00:45:46,900 --> 00:45:50,380
constructor that is implicit it would be

00:45:49,150 --> 00:45:51,670
good if your constructor was implicit

00:45:50,380 --> 00:45:52,630
but if it has a constructor that's

00:45:51,670 --> 00:45:54,460
explicit it'd be good if your

00:45:52,630 --> 00:45:56,260
constructor was explicit that's a hard

00:45:54,460 --> 00:45:59,800
problem to solve but if you get explicit

00:45:56,260 --> 00:46:01,660
at boule then you can say wrappers

00:45:59,800 --> 00:46:03,820
constructor is implicit depending on

00:46:01,660 --> 00:46:06,970
whether or not the wrapped item T is

00:46:03,820 --> 00:46:08,920
implicit or not but I can now say

00:46:06,970 --> 00:46:11,260
explicit at false and it's a way of

00:46:08,920 --> 00:46:13,869
saying implicit back then might use a

00:46:11,260 --> 00:46:16,690
macro for that but we're not gonna get

00:46:13,869 --> 00:46:17,830
constant false I don't think so we're

00:46:16,690 --> 00:46:21,670
not gonna get a non-virtual we're not

00:46:17,830 --> 00:46:25,089
gonna get by that we got these compiler

00:46:21,670 --> 00:46:25,660
warnings suppressor attributes fall

00:46:25,089 --> 00:46:30,760
through

00:46:25,660 --> 00:46:32,380
maybe unused anyone using them very

00:46:30,760 --> 00:46:34,599
small number of hands all in the first

00:46:32,380 --> 00:46:37,270
three rows I'm just saying clearly where

00:46:34,599 --> 00:46:38,830
the Keene people sit come early get a

00:46:37,270 --> 00:46:43,839
seat at the front use the new keywords

00:46:38,830 --> 00:46:48,250
if you're not using them don't tell me

00:46:43,839 --> 00:46:51,730
but ask yourself why not I think it's

00:46:48,250 --> 00:46:54,160
because they don't do anything right

00:46:51,730 --> 00:46:56,890
they don't change your code why am i

00:46:54,160 --> 00:46:59,920
typing it nothing is different after I

00:46:56,890 --> 00:47:02,650
typed it if all there is in the world is

00:46:59,920 --> 00:47:05,220
the compiler nothing is different but in

00:47:02,650 --> 00:47:08,410
my brain when I have to read your code

00:47:05,220 --> 00:47:13,089
something is different right and you're

00:47:08,410 --> 00:47:17,349
communicating with the future and that's

00:47:13,089 --> 00:47:20,950
what I want you to do communicate you

00:47:17,349 --> 00:47:23,589
know when you write code yeah

00:47:20,950 --> 00:47:26,320
works calculates the taxes good for you

00:47:23,589 --> 00:47:27,880
we get the revenue I like that but if

00:47:26,320 --> 00:47:30,700
you're also writing it as a

00:47:27,880 --> 00:47:33,730
communication device you have to think

00:47:30,700 --> 00:47:37,060
about your message to that future reader

00:47:33,730 --> 00:47:39,040
and I know we're not all altruistic so

00:47:37,060 --> 00:47:42,490
remember that the Future reader might be

00:47:39,040 --> 00:47:45,640
you or that nice junior developer who

00:47:42,490 --> 00:47:47,170
just started who you like and who you

00:47:45,640 --> 00:47:48,700
would like to take this project over for

00:47:47,170 --> 00:47:51,310
you when you move on to bigger and

00:47:48,700 --> 00:47:52,990
better things okay it could also be your

00:47:51,310 --> 00:47:56,320
child I have actually employed one of my

00:47:52,990 --> 00:47:59,940
children both of my children so show

00:47:56,320 --> 00:48:03,339
that future reader why you did this

00:47:59,940 --> 00:48:04,510
don't leave them that puzzle where

00:48:03,339 --> 00:48:06,910
they're trying to figure out how to get

00:48:04,510 --> 00:48:11,320
through the big stone door don't leave

00:48:06,910 --> 00:48:12,970
them going what I don't I can't huh

00:48:11,320 --> 00:48:16,300
that's not nice

00:48:12,970 --> 00:48:20,650
and even if you don't care about them at

00:48:16,300 --> 00:48:23,349
all don't have them think you didn't

00:48:20,650 --> 00:48:25,300
know any better I can't believe that

00:48:23,349 --> 00:48:26,770
Kate Gregory wrote this code that

00:48:25,300 --> 00:48:29,560
doesn't even know that there's such a

00:48:26,770 --> 00:48:30,849
thing as constant right that's terrible

00:48:29,560 --> 00:48:32,859
know you don't want people thinking

00:48:30,849 --> 00:48:34,300
things like that about you so you want

00:48:32,859 --> 00:48:36,550
to make sure that your code explains

00:48:34,300 --> 00:48:38,829
itself in in that and that means really

00:48:36,550 --> 00:48:41,349
focusing on what you did not say as well

00:48:38,829 --> 00:48:45,599
as what you said what are you not

00:48:41,349 --> 00:48:49,060
choosing to do what are you not using

00:48:45,599 --> 00:48:50,859
this is C++ we have five ways to do

00:48:49,060 --> 00:48:52,420
everything and if you find something

00:48:50,859 --> 00:48:56,500
there's only three ways to do go to the

00:48:52,420 --> 00:48:59,500
committee we'll add the missing ones so

00:48:56,500 --> 00:49:00,450
you always had choices did I use a

00:48:59,500 --> 00:49:02,800
for-loop

00:49:00,450 --> 00:49:04,150
traditional arranged for do I use a

00:49:02,800 --> 00:49:07,390
while do I call something from

00:49:04,150 --> 00:49:10,119
accumulate do I use go twos and ifs what

00:49:07,390 --> 00:49:13,329
does it mean that I made that choice

00:49:10,119 --> 00:49:17,020
what am I trying to tell you how can

00:49:13,329 --> 00:49:19,089
people understand you understand your

00:49:17,020 --> 00:49:24,160
defaults and your behaviors from those

00:49:19,089 --> 00:49:27,510
choices not everything you want to

00:49:24,160 --> 00:49:30,099
express can only be expressed as nothing

00:49:27,510 --> 00:49:31,750
right all the way back to returning at

00:49:30,099 --> 00:49:34,150
the bottom of voids and public in your

00:49:31,750 --> 00:49:34,950
structs and there are times you just be

00:49:34,150 --> 00:49:37,839
verbose

00:49:34,950 --> 00:49:40,390
but sometimes all you have is nothing

00:49:37,839 --> 00:49:44,920
and so then the challenge is make that

00:49:40,390 --> 00:49:47,770
nothing carry information and show in

00:49:44,920 --> 00:49:48,730
the rest of the code in the context show

00:49:47,770 --> 00:49:51,670
who you are

00:49:48,730 --> 00:49:53,950
show what you do so that someone can say

00:49:51,670 --> 00:49:55,420
if Kate didn't mark this know except

00:49:53,950 --> 00:49:57,130
well that's bad choice clicking no

00:49:55,420 --> 00:49:59,740
accept Falls if Kate didn't not mark

00:49:57,130 --> 00:50:03,190
this Const it's for a reason it must

00:49:59,740 --> 00:50:06,010
change things and I want you to be

00:50:03,190 --> 00:50:08,319
generous to future you who deserves it

00:50:06,010 --> 00:50:09,700
to your future reader give them

00:50:08,319 --> 00:50:12,310
everything they need because your

00:50:09,700 --> 00:50:14,589
nothingness is speaking volumes and they

00:50:12,310 --> 00:50:18,930
will understand what you mean when you

00:50:14,589 --> 00:50:18,930
say nothing at all thank you

00:50:23,150 --> 00:50:30,290
I have a small amount of time for

00:50:25,760 --> 00:50:33,350
questions at the mic so in the slide

00:50:30,290 --> 00:50:36,320
where there are two functions and both

00:50:33,350 --> 00:50:38,090
don't have a return statement symbol and

00:50:36,320 --> 00:50:40,640
spiral I can't believe you couldn't

00:50:38,090 --> 00:50:45,170
remember my function names and one of

00:50:40,640 --> 00:50:47,960
them actually reaches the end and

00:50:45,170 --> 00:50:50,770
doesn't reach then the one that reaches

00:50:47,960 --> 00:50:53,000
the end you suggest to explicitly

00:50:50,770 --> 00:50:56,450
provide the return statement on the left

00:50:53,000 --> 00:50:58,720
right after Robert - - yes return ok

00:50:56,450 --> 00:51:03,830
thank you yes

00:50:58,720 --> 00:51:07,970
all right on really vehicle semi related

00:51:03,830 --> 00:51:10,550
topic one of the challenges I think that

00:51:07,970 --> 00:51:14,300
we're facing is that the language is

00:51:10,550 --> 00:51:16,820
progressing now at a far higher rate new

00:51:14,300 --> 00:51:19,160
syntax new idioms are occurring on an

00:51:16,820 --> 00:51:21,230
almost daily basis depending on how many

00:51:19,160 --> 00:51:24,950
blogs you read it's a great time to be a

00:51:21,230 --> 00:51:28,810
developer absolutely to the point of

00:51:24,950 --> 00:51:33,380
expressiveness yes do you have any

00:51:28,810 --> 00:51:37,760
thoughts on how to deal with the fact to

00:51:33,380 --> 00:51:40,070
say now we have Falls which if you're a

00:51:37,760 --> 00:51:44,240
programmer that has not come across them

00:51:40,070 --> 00:51:46,100
looked absolutely insane but really

00:51:44,240 --> 00:51:48,590
Express what you're trying to do rather

00:51:46,100 --> 00:51:50,210
than the alternatives I'll give you an

00:51:48,590 --> 00:51:52,670
example the immediately invoked

00:51:50,210 --> 00:51:53,180
initializing lambda expression mm-hmm

00:51:52,670 --> 00:51:54,680
okay

00:51:53,180 --> 00:51:56,540
beautiful idiom for those who haven't

00:51:54,680 --> 00:51:58,070
met it before you've got some variable

00:51:56,540 --> 00:51:59,720
that's complicated to initialize you

00:51:58,070 --> 00:52:01,790
need a loop or switch or something and

00:51:59,720 --> 00:52:03,890
you want it to be constants you've got

00:52:01,790 --> 00:52:07,130
to initialize it never changes and so

00:52:03,890 --> 00:52:08,720
you can write a lambda and say whatever

00:52:07,130 --> 00:52:10,100
the type is I never use auto here

00:52:08,720 --> 00:52:12,110
whatever the type is complicated

00:52:10,100 --> 00:52:14,540
variable equals lambda and then at the

00:52:12,110 --> 00:52:17,120
end a pair of parentheses so that

00:52:14,540 --> 00:52:19,130
invokes the lambda immediately the

00:52:17,120 --> 00:52:21,230
problem is people who don't know the

00:52:19,130 --> 00:52:22,700
idiom don't necessarily see especially

00:52:21,230 --> 00:52:24,290
if it's a three or four line lambda they

00:52:22,700 --> 00:52:25,190
don't necessarily see those parentheses

00:52:24,290 --> 00:52:26,690
and they don't realize it's being

00:52:25,190 --> 00:52:27,830
invoked they're like oh they're setting

00:52:26,690 --> 00:52:29,660
up some lambda for something whatever

00:52:27,830 --> 00:52:33,440
and then I'm like no one ever calls this

00:52:29,660 --> 00:52:34,960
lambda I don't understand if everyone

00:52:33,440 --> 00:52:37,390
knows the idiom you

00:52:34,960 --> 00:52:40,480
fantastic if they don't you just made it

00:52:37,390 --> 00:52:46,570
confusing I do not have an answer it is

00:52:40,480 --> 00:52:49,390
it is the question yes over here so

00:52:46,570 --> 00:52:51,730
first of all thanks for writing the talk

00:52:49,390 --> 00:52:53,830
that I'm supposed to be writing for the

00:52:51,730 --> 00:52:56,560
next six months to deliver to our devs

00:52:53,830 --> 00:53:00,700
so I wanted to ask you about the slide

00:52:56,560 --> 00:53:03,010
like dark chocolate okay I wanted to ask

00:53:00,700 --> 00:53:07,810
you about the slide that I will plan to

00:53:03,010 --> 00:53:10,510
skip when I show this and that was your

00:53:07,810 --> 00:53:12,220
talk about default initializers it seems

00:53:10,510 --> 00:53:18,190
to be at odds with your statement

00:53:12,220 --> 00:53:20,560
absolutely that you write private right

00:53:18,190 --> 00:53:22,599
after you write class or public right

00:53:20,560 --> 00:53:27,520
after you write struct I agree I know I

00:53:22,599 --> 00:53:30,460
figure I feel funny here I I'm a change

00:53:27,520 --> 00:53:33,070
over time today I'm like why are you

00:53:30,460 --> 00:53:34,089
telling me what I know yet I want to

00:53:33,070 --> 00:53:35,589
return at the bottom of the void

00:53:34,089 --> 00:53:39,250
function I want to say private and

00:53:35,589 --> 00:53:41,290
public in the structs I want to express

00:53:39,250 --> 00:53:43,900
every default I can except for some

00:53:41,290 --> 00:53:45,339
reason not these and I and I went on

00:53:43,900 --> 00:53:46,690
social media and asked other people to

00:53:45,339 --> 00:53:47,830
see if it was just me and other people

00:53:46,690 --> 00:53:52,780
like no I hate that that's really

00:53:47,830 --> 00:53:56,109
confusing I I may change over time today

00:53:52,780 --> 00:53:58,420
I'm like don't tell me that so the other

00:53:56,109 --> 00:54:00,940
two reasons why I disagree with that and

00:53:58,420 --> 00:54:03,550
you can tell me why I'm wrong first of

00:54:00,940 --> 00:54:06,460
all what happens when someone comes

00:54:03,550 --> 00:54:08,290
along later and changes this to generic

00:54:06,460 --> 00:54:10,480
code and instead of string you now have

00:54:08,290 --> 00:54:12,339
tea and the default might be different

00:54:10,480 --> 00:54:14,890
because maybe you change string to

00:54:12,339 --> 00:54:17,020
string view or something like that or

00:54:14,890 --> 00:54:20,310
stream could be either string or string

00:54:17,020 --> 00:54:23,109
to you and the second one is that

00:54:20,310 --> 00:54:25,030
default initializers don't do what

00:54:23,109 --> 00:54:26,800
people think they do for built-in types

00:54:25,030 --> 00:54:28,359
for built-in types absolutely and I

00:54:26,800 --> 00:54:30,580
think that's what it comes from people

00:54:28,359 --> 00:54:32,380
are busy doing as the Institute so this

00:54:30,580 --> 00:54:34,450
is probably the least strongly held of

00:54:32,380 --> 00:54:35,740
all of my opinions so I'm not gonna read

00:54:34,450 --> 00:54:41,710
but you when you argue with me cuz you

00:54:35,740 --> 00:54:42,070
might be right over here a comment and a

00:54:41,710 --> 00:54:44,080
question

00:54:42,070 --> 00:54:46,450
so on the when you talk about optional

00:54:44,080 --> 00:54:47,620
returns yes maybe this is a portability

00:54:46,450 --> 00:54:50,500
thing but one

00:54:47,620 --> 00:54:52,510
that I use and really like is you can

00:54:50,500 --> 00:54:54,360
tell the compiler like I think assumed

00:54:52,510 --> 00:54:56,560
unreachable or something like that and

00:54:54,360 --> 00:54:58,990
even better you can have a macro that

00:54:56,560 --> 00:55:01,450
expands to that in production and like

00:54:58,990 --> 00:55:03,430
aborts in debug and it's really great

00:55:01,450 --> 00:55:06,520
because it well that's the comments

00:55:03,430 --> 00:55:08,320
should never get here line yeah well

00:55:06,520 --> 00:55:10,120
it's not a comment the crowler uses it

00:55:08,320 --> 00:55:11,920
and it produces better assembly and you

00:55:10,120 --> 00:55:14,350
get the abort and debug it's actually

00:55:11,920 --> 00:55:16,120
really nice and communicates and so in

00:55:14,350 --> 00:55:17,710
the case of spry 'el you would put it

00:55:16,120 --> 00:55:19,210
after the loop saying we can't get out

00:55:17,710 --> 00:55:22,110
of this loop if you get out of this loop

00:55:19,210 --> 00:55:25,420
something really bad has happened yeah

00:55:22,110 --> 00:55:26,860
and I have a question so one key word

00:55:25,420 --> 00:55:29,620
you didn't talk about that I think is

00:55:26,860 --> 00:55:31,990
really interesting is a final because

00:55:29,620 --> 00:55:34,000
I've seen people before I recommend yeah

00:55:31,990 --> 00:55:36,040
like don't use final on a class unless

00:55:34,000 --> 00:55:37,840
you have a reason and what's funny is

00:55:36,040 --> 00:55:39,640
then I say to those people okay let's

00:55:37,840 --> 00:55:42,460
assume that final didn't exist and

00:55:39,640 --> 00:55:44,080
instead you had derive a pool would you

00:55:42,460 --> 00:55:45,970
use would you be telling people the same

00:55:44,080 --> 00:55:47,710
thing always used arrival unless you had

00:55:45,970 --> 00:55:48,970
a reason and then rights people if

00:55:47,710 --> 00:55:51,190
they're honest stop and they're like oh

00:55:48,970 --> 00:55:53,740
wait like I probably wouldn't tell

00:55:51,190 --> 00:55:56,310
people to do that so so this is the king

00:55:53,740 --> 00:55:58,720
all our all our defaults are wrong right

00:55:56,310 --> 00:56:00,310
it is again and and in there is

00:55:58,720 --> 00:56:01,990
something really powerful about doing

00:56:00,310 --> 00:56:04,330
the default versus not doing the default

00:56:01,990 --> 00:56:06,040
and if the default was final and you had

00:56:04,330 --> 00:56:07,060
to say derive Abul most things would

00:56:06,040 --> 00:56:08,320
just be final because you're like well

00:56:07,060 --> 00:56:12,130
i'm not writing it to be inherited from

00:56:08,320 --> 00:56:16,180
sure you know that's cool but the that's

00:56:12,130 --> 00:56:18,850
why sometimes just the silent default it

00:56:16,180 --> 00:56:20,050
doesn't show any thinking as soon as you

00:56:18,850 --> 00:56:22,270
put a key word in there you're showing

00:56:20,050 --> 00:56:25,099
that you thought so do you use final in

00:56:22,270 --> 00:56:30,929
most of your classes I do not

00:56:25,099 --> 00:56:33,959
but I probably should thanks hi okay a

00:56:30,929 --> 00:56:36,569
quick question about the infants that

00:56:33,959 --> 00:56:38,549
you never named yes the pod name

00:56:36,569 --> 00:56:40,169
parameter I'm wondering why there is

00:56:38,549 --> 00:56:41,699
that it's an interface you got from

00:56:40,169 --> 00:56:44,549
somewhere else sometimes it's an API

00:56:41,699 --> 00:56:46,140
drift okay yeah there's there's a

00:56:44,549 --> 00:56:48,509
million lines of code they're all

00:56:46,140 --> 00:56:51,390
calling this function but there is no

00:56:48,509 --> 00:56:54,029
need for the third parameter anymore but

00:56:51,390 --> 00:56:55,229
but at some time when there were no

00:56:54,029 --> 00:56:57,359
refactoring tools

00:56:55,229 --> 00:57:00,479
the decision was majors leave the API

00:56:57,359 --> 00:57:03,419
alone but very often it's a virtual

00:57:00,479 --> 00:57:04,769
function situation right so when I was

00:57:03,419 --> 00:57:06,179
writing Windows stuff you get command

00:57:04,769 --> 00:57:08,009
handlers they give you two things like

00:57:06,179 --> 00:57:09,390
the control that was clicked then the

00:57:08,009 --> 00:57:11,519
place that was clicked or something and

00:57:09,390 --> 00:57:12,959
usually I don't do not care where on the

00:57:11,519 --> 00:57:14,969
button you click so I never look at that

00:57:12,959 --> 00:57:16,199
parameter and that's fine there's

00:57:14,969 --> 00:57:17,939
nothing wrong with that whatsoever and

00:57:16,199 --> 00:57:19,859
in a lot of virtual hierarchies you'll

00:57:17,939 --> 00:57:21,929
be getting information you don't need so

00:57:19,859 --> 00:57:23,609
that's a sort of bad example because a

00:57:21,929 --> 00:57:25,049
human isn't typing code to call the

00:57:23,609 --> 00:57:30,209
event handler but it happens in other

00:57:25,049 --> 00:57:33,959
contexts as well thank you hi

00:57:30,209 --> 00:57:37,049
in one of the dog you told that if you

00:57:33,959 --> 00:57:41,669
don't use parameter then don't pass the

00:57:37,049 --> 00:57:44,669
type if you know I passed the type give

00:57:41,669 --> 00:57:46,319
any name yeah name and type yeah so what

00:57:44,669 --> 00:57:48,449
about passing null let's say for the

00:57:46,319 --> 00:57:51,569
future use I want to use some of the

00:57:48,449 --> 00:57:53,809
parameters of a method so I want to pass

00:57:51,569 --> 00:57:58,109
it as a null instead of passing the type

00:57:53,809 --> 00:58:00,569
good no I you cannot really future-proof

00:57:58,109 --> 00:58:02,189
your api i hear what you're saying like

00:58:00,569 --> 00:58:03,809
let's add another parameter and today

00:58:02,189 --> 00:58:06,079
people aren't gonna pass null and later

00:58:03,809 --> 00:58:08,489
they'll pass a pointer to something real

00:58:06,079 --> 00:58:10,259
we live in a land of refactoring tools

00:58:08,489 --> 00:58:12,979
if you want to add a parameter or take

00:58:10,259 --> 00:58:15,149
parameter away today you should do that

00:58:12,979 --> 00:58:18,239
but there is a ton of code that's out

00:58:15,149 --> 00:58:20,999
there that is calling functions that

00:58:18,239 --> 00:58:23,489
were written in 2002 and no one's going

00:58:20,999 --> 00:58:25,859
to go in and change all the calling code

00:58:23,489 --> 00:58:27,449
not to pass the third parameter so we'll

00:58:25,859 --> 00:58:29,579
just settle for telling you I don't care

00:58:27,449 --> 00:58:31,829
what you passed you passed zero minus

00:58:29,579 --> 00:58:32,880
one a thousand doesn't matter we I'm not

00:58:31,829 --> 00:58:34,949
going to use it and that's what this

00:58:32,880 --> 00:58:36,340
signals so when the four last parameter

00:58:34,949 --> 00:58:39,250
has no name

00:58:36,340 --> 00:58:40,810
and I'm calling the function I know that

00:58:39,250 --> 00:58:43,150
I can put anything as long as it's

00:58:40,810 --> 00:58:44,590
integer I can pass anything I want it

00:58:43,150 --> 00:58:49,270
won't be used it won't affect the

00:58:44,590 --> 00:58:50,800
runtime behavior okay thank you I have

00:58:49,270 --> 00:58:53,530
one minute okay

00:58:50,800 --> 00:58:55,170
just since we're on this topic I did

00:58:53,530 --> 00:58:58,660
have two comments on this one too I

00:58:55,170 --> 00:59:01,090
think that whether you name it or not

00:58:58,660 --> 00:59:03,250
should reflect your implementation but

00:59:01,090 --> 00:59:05,650
your interface so it's helpful for

00:59:03,250 --> 00:59:08,160
reading code and definitely encounter

00:59:05,650 --> 00:59:12,130
justice case within the past two weeks

00:59:08,160 --> 00:59:15,850
but it on the definition if it doesn't

00:59:12,130 --> 00:59:18,700
then I know it's something about how

00:59:15,850 --> 00:59:21,280
it's implemented and so maybe in some

00:59:18,700 --> 00:59:24,190
cases if I'm updating it it's fine that

00:59:21,280 --> 00:59:26,530
I don't know what to pass in but if

00:59:24,190 --> 00:59:30,130
anyone of in the virtual hierarchy if

00:59:26,530 --> 00:59:33,130
any one of them cares then I would like

00:59:30,130 --> 00:59:36,640
to know what I should put in in case

00:59:33,130 --> 00:59:39,130
eventually someone else is gonna care so

00:59:36,640 --> 00:59:40,990
if it's an interface it's ignored I'm

00:59:39,130 --> 00:59:43,980
expecting it never to be cared

00:59:40,990 --> 00:59:48,760
I suppose here's the thing if you're

00:59:43,980 --> 00:59:51,610
checking account update service charges

00:59:48,760 --> 00:59:53,650
method is virtual but calls the base and

00:59:51,610 --> 00:59:56,320
passes all its parameters up to the base

00:59:53,650 --> 00:59:57,760
and then does its own stuff then it's

00:59:56,320 --> 00:59:59,170
using that third parameter because it's

00:59:57,760 --> 01:00:02,170
using it to pass it to the base and so

00:59:59,170 --> 01:00:03,490
it should give it a name right but if it

01:00:02,170 --> 01:00:06,070
never does it at all because it's a

01:00:03,490 --> 01:00:07,780
complete override then I think the

01:00:06,070 --> 01:00:10,210
information of actually checking

01:00:07,780 --> 01:00:12,100
accounts don't care I don't know what

01:00:10,210 --> 01:00:13,690
state you live in the carries

01:00:12,100 --> 01:00:16,000
information and it won't break any code

01:00:13,690 --> 01:00:19,840
that chooses to pass the meaningful

01:00:16,000 --> 01:00:21,970
values meaningful values but if I think

01:00:19,840 --> 01:00:24,190
like it was being said that you could

01:00:21,970 --> 01:00:27,010
possibly not pass

01:00:24,190 --> 01:00:28,600
so what is - - special value it's right

01:00:27,010 --> 01:00:31,420
you don't know right if you see - when

01:00:28,600 --> 01:00:35,080
you think it's a signal yes yes the

01:00:31,420 --> 01:00:37,360
other thing is about non-virtual that's

01:00:35,080 --> 01:00:39,820
the scariest one for me that we don't

01:00:37,360 --> 01:00:43,840
have something there because nothing

01:00:39,820 --> 01:00:46,540
doesn't isn't the opposite even it's

01:00:43,840 --> 01:00:48,850
whether someone in your entire higher up

01:00:46,540 --> 01:00:49,260
the stream yes maybe I don't need to say

01:00:48,850 --> 01:00:51,540
it because

01:00:49,260 --> 01:00:54,750
inheriting from a virtual function yep I

01:00:51,540 --> 01:00:57,540
agree so is there some reason why you

01:00:54,750 --> 01:01:01,110
said that you were expecting we won't

01:00:57,540 --> 01:01:03,720
get this some of the I just don't think

01:01:01,110 --> 01:01:05,550
it's an easy problem to solve yeah yeah

01:01:03,720 --> 01:01:07,140
that's all unfortunately out of time but

01:01:05,550 --> 01:01:08,490
I'm welcome to talk to everyone 101 and

01:01:07,140 --> 01:01:09,800
thank you again for getting up and

01:01:08,490 --> 01:01:15,569
coming in saying

01:01:09,800 --> 01:01:15,569

YouTube URL: https://www.youtube.com/watch?v=kYVxGyido9g


