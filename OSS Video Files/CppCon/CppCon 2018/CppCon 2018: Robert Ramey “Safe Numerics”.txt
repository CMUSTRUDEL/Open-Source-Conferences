Title: CppCon 2018: Robert Ramey “Safe Numerics”
Publication date: 2018-10-12
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Most computer languages, including C++, cannot guarantee that an integer expression will not produce a incorrect arithmetic result. 

This fact is documented in numerous books, articles and conference presentations such as CPPCon. These presentations give good explanations of the problem and it's causes. But they are short on specific practical strategies to address the problem. The Boost.SafeNumerics library addresses this problem through C++ techniques such as operator overloading, template meta-programming. This library can be used to write C or C++ code guaranteed not to produce erroneous arithmetic results. In many cases, this guarantee can be made without adding any run-time overhead. 

This presentation will 

* illustrate some common problems such as integer overflows and type conversions. 
* illustrate how the library can be used to address these problems. 
* describe in general terms what the library does and how it works. 
* describe the library API in some detail. 
* present a case study applying the library to embedded motor controller written in C. 
— 
Robert Ramey, Robert Ramey Software Development
Software Developer

Robert Ramey is a freelance Software Developer living in Santa Barbara, California. (See www.rrsd.com.)  His long and varied career spans various aspects of software development including business data processing, product, embedded systems, custom software, and C++ library development. Lately, he has been mostly interested in C++ library design and implementation related to Boost.  He is the author and maintainer of the Boost Serialization library and a frequent contributor to the Boost developers list.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:05,190
my name is Robert Ramey thank you two

00:00:02,669 --> 00:00:07,730
for coming to my presentation I see I

00:00:05,190 --> 00:00:10,740
have an extremely exclusive group today

00:00:07,730 --> 00:00:12,630
but that it's not important to me at all

00:00:10,740 --> 00:00:13,610
you're gonna get a hundred percent as

00:00:12,630 --> 00:00:16,350
you should

00:00:13,610 --> 00:00:20,039
I'm the I've been associated with boost

00:00:16,350 --> 00:00:21,539
for many years I'm the author of the

00:00:20,039 --> 00:00:24,840
booth serialization library

00:00:21,539 --> 00:00:27,599
I'm also the maintainer of the booth

00:00:24,840 --> 00:00:31,199
library incubator and now I am the

00:00:27,599 --> 00:00:33,690
author of the booster sue safe numerix

00:00:31,199 --> 00:00:39,120
library which is the subject of our talk

00:00:33,690 --> 00:00:41,520
today there's in every conference

00:00:39,120 --> 00:00:43,320
there's at least one session and usually

00:00:41,520 --> 00:00:46,469
more where they talk about the problems

00:00:43,320 --> 00:00:48,300
with integer arithmetic and that you can

00:00:46,469 --> 00:00:51,180
this can happen that can happen in yada

00:00:48,300 --> 00:00:53,399
yada yada and it's kind of interesting

00:00:51,180 --> 00:00:54,379
and it has repercussions and cetera et

00:00:53,399 --> 00:00:57,510
cetera

00:00:54,379 --> 00:00:59,160
unfortunately the convert those sessions

00:00:57,510 --> 00:01:01,829
actually stop

00:00:59,160 --> 00:01:07,049
before they give you any idea what you

00:01:01,829 --> 00:01:09,720
can do to actually fix the problem they

00:01:07,049 --> 00:01:13,890
talk about practices you can do to avoid

00:01:09,720 --> 00:01:16,530
the problem but they're very ad hoc what

00:01:13,890 --> 00:01:19,430
we're doing today is different we're

00:01:16,530 --> 00:01:22,650
going to use the power of C++ to

00:01:19,430 --> 00:01:25,229
overload all the integer operations to

00:01:22,650 --> 00:01:29,759
make our own drop-in replacement for

00:01:25,229 --> 00:01:34,320
integers and if you use these substitute

00:01:29,759 --> 00:01:37,979
integers for your regular integers you

00:01:34,320 --> 00:01:42,119
will be absolutely certain that your the

00:01:37,979 --> 00:01:46,439
expressions in your program that include

00:01:42,119 --> 00:01:50,850
integers will never fail they will never

00:01:46,439 --> 00:01:53,369
deliver a false resort false response

00:01:50,850 --> 00:01:55,770
and continue on the program might crash

00:01:53,369 --> 00:01:58,049
at that point it might fail to compile

00:01:55,770 --> 00:02:02,219
but it won't do what it traditionally

00:01:58,049 --> 00:02:05,930
does which is return on arithmetic

00:02:02,219 --> 00:02:12,950
erroneous result and continue to execute

00:02:05,930 --> 00:02:16,129
this that's that's that's that's

00:02:12,950 --> 00:02:21,640
the gist of it I'm gonna talk show a

00:02:16,129 --> 00:02:27,040
couple cases and I'm not gonna really

00:02:21,640 --> 00:02:31,670
retread the past and John rehgar made a

00:02:27,040 --> 00:02:34,189
two presentations back-to-back last year

00:02:31,670 --> 00:02:37,310
on this subject I made a small one two

00:02:34,189 --> 00:02:39,590
years ago and there's also some

00:02:37,310 --> 00:02:41,209
interesting things a doob to problems

00:02:39,590 --> 00:02:43,900
such as this

00:02:41,209 --> 00:02:47,840
we've have some multi-million dollar

00:02:43,900 --> 00:02:50,599
major Fiasco's nobody's taking credit

00:02:47,840 --> 00:02:53,989
for them personally but the fact is that

00:02:50,599 --> 00:02:57,530
those are the ones we know about here's

00:02:53,989 --> 00:02:59,810
a typical case integer overflow we have

00:02:57,530 --> 00:03:02,840
a couple eight integers we add

00:02:59,810 --> 00:03:05,150
them together the C++ compiler promotes

00:03:02,840 --> 00:03:06,769
them to integers adds them together and

00:03:05,150 --> 00:03:09,859
tries to stuff it and stuffs it back

00:03:06,769 --> 00:03:12,409
into another 8-bit integer some C

00:03:09,859 --> 00:03:16,010
compilers may give you a compile time

00:03:12,409 --> 00:03:17,659
warning but if they if they don't or

00:03:16,010 --> 00:03:20,599
whether they do or not when they execute

00:03:17,659 --> 00:03:22,609
this you will end up with a result in

00:03:20,599 --> 00:03:25,040
your code which is wrong and you will

00:03:22,609 --> 00:03:28,659
continue to use it and it'll and it will

00:03:25,040 --> 00:03:31,459
be silent you don't know about it and

00:03:28,659 --> 00:03:33,979
here's another common one

00:03:31,459 --> 00:03:35,870
these are conversions that have the C

00:03:33,979 --> 00:03:38,949
compiler does to you or for you

00:03:35,870 --> 00:03:42,379
depending on your perspective where it

00:03:38,949 --> 00:03:44,870
the depending on the combination of

00:03:42,379 --> 00:03:47,900
operands here we have an unsigned and

00:03:44,870 --> 00:03:52,639
signed type depending on the rules of

00:03:47,900 --> 00:03:54,709
C++ which are a little bit obscure you

00:03:52,639 --> 00:03:56,949
will get a result which will not be the

00:03:54,709 --> 00:03:59,599
result that you expect to see and as

00:03:56,949 --> 00:04:03,349
before you'll get a compile and you

00:03:59,599 --> 00:04:06,109
might get a compile time warning and but

00:04:03,349 --> 00:04:09,290
when it comes to execution time the code

00:04:06,109 --> 00:04:11,900
will execute soldier on and you will

00:04:09,290 --> 00:04:16,280
have if your code is important it will

00:04:11,900 --> 00:04:18,829
you will suffer here's another one

00:04:16,280 --> 00:04:23,380
happens all the time we anticipate a

00:04:18,829 --> 00:04:24,970
certain range of variables and people

00:04:23,380 --> 00:04:27,940
type in

00:04:24,970 --> 00:04:29,260
different numbers then we anticipate we

00:04:27,940 --> 00:04:32,410
don't check them we know we're supposed

00:04:29,260 --> 00:04:35,590
to check them but a lot of times we

00:04:32,410 --> 00:04:39,610
forget to do it or for whatever reason

00:04:35,590 --> 00:04:43,110
and the X won't contain the variable we

00:04:39,610 --> 00:04:45,910
expected tend to contain and again oh

00:04:43,110 --> 00:04:48,010
it's unclear whether you'll get some

00:04:45,910 --> 00:04:51,280
sort of advice that that problem has

00:04:48,010 --> 00:04:54,760
occurred so there's no way to guarantee

00:04:51,280 --> 00:04:57,520
under the current regimen that that

00:04:54,760 --> 00:05:00,190
arithmetic errors will not occur almost

00:04:57,520 --> 00:05:01,900
all language not just c and c++ almost

00:05:00,190 --> 00:05:04,240
all language have the similar problem

00:05:01,900 --> 00:05:08,380
there's a couple languages that have a

00:05:04,240 --> 00:05:11,890
few help ada has some integer arithmetic

00:05:08,380 --> 00:05:15,750
help c-sharp I believe has some

00:05:11,890 --> 00:05:19,440
functions which which are helpful there

00:05:15,750 --> 00:05:23,350
and but it's there it just ad hoc

00:05:19,440 --> 00:05:26,400
solutions this problem has been around

00:05:23,350 --> 00:05:29,790
for forty years since the beginning of C

00:05:26,400 --> 00:05:34,270
we have every year a conference every

00:05:29,790 --> 00:05:40,290
year it gets remarked upon and every

00:05:34,270 --> 00:05:42,850
year nothing happens until now today

00:05:40,290 --> 00:05:45,510
September 26 you people are present in

00:05:42,850 --> 00:05:50,080
the creation it's a new day from now on

00:05:45,510 --> 00:05:55,270
these problems will not occur it's the

00:05:50,080 --> 00:05:56,850
end of error this enthusiasm is palpable

00:05:55,270 --> 00:06:01,360
here

00:05:56,850 --> 00:06:03,910
so here's the real solution is we

00:06:01,360 --> 00:06:05,890
include a part of the safe numeric

00:06:03,910 --> 00:06:10,240
library and we replace our types int

00:06:05,890 --> 00:06:13,510
long whatever with these types safe and

00:06:10,240 --> 00:06:17,200
safe long etc we can do that as soon as

00:06:13,510 --> 00:06:20,080
we incorporate the safe integer library

00:06:17,200 --> 00:06:22,240
and make sure we are the boost

00:06:20,080 --> 00:06:25,140
namespaces available to them to us in

00:06:22,240 --> 00:06:28,090
this previous example which we

00:06:25,140 --> 00:06:33,160
Illustrated before we'll throw an error

00:06:28,090 --> 00:06:37,000
at runtime in this case because since

00:06:33,160 --> 00:06:42,450
the addition operation is overloaded

00:06:37,000 --> 00:06:45,400
and then it will detect that the result

00:06:42,450 --> 00:06:48,400
will not fit into the the variables

00:06:45,400 --> 00:06:52,090
which C++ has converted these to for its

00:06:48,400 --> 00:06:53,860
operations so at that point if this

00:06:52,090 --> 00:06:58,350
particular code something was depending

00:06:53,860 --> 00:07:03,430
on this being correct we're saved from a

00:06:58,350 --> 00:07:09,040
erroneous result now whenever I expound

00:07:03,430 --> 00:07:11,790
upon this idea the immediate response is

00:07:09,040 --> 00:07:16,630
well you know I don't really want to

00:07:11,790 --> 00:07:19,270
include extra runtime checking in every

00:07:16,630 --> 00:07:23,169
arithmetic operation I do it's going to

00:07:19,270 --> 00:07:27,310
slow my program down which it might or

00:07:23,169 --> 00:07:29,530
might not but it's I will say it doesn't

00:07:27,310 --> 00:07:31,630
happen nearly as much as one thinks at

00:07:29,530 --> 00:07:32,260
what it will and that's because of the

00:07:31,630 --> 00:07:35,169
following

00:07:32,260 --> 00:07:38,590
we don't overload every operation and

00:07:35,169 --> 00:07:40,450
then insert the checking we analyze the

00:07:38,590 --> 00:07:43,060
code at runtime or when the templates

00:07:40,450 --> 00:07:45,880
are instantiated and we can compare the

00:07:43,060 --> 00:07:48,190
types and we can exclude those cases

00:07:45,880 --> 00:07:50,800
where an error will never occur anyway

00:07:48,190 --> 00:07:54,970
and no checking is required and here's

00:07:50,800 --> 00:07:58,060
here's a the an example similar to the

00:07:54,970 --> 00:08:02,050
one we had before x and y are 16-bit

00:07:58,060 --> 00:08:05,950
integers if we going to store the result

00:08:02,050 --> 00:08:11,470
in a 32-bit integer when we do this this

00:08:05,950 --> 00:08:15,130
addition it's it's it's going to be a

00:08:11,470 --> 00:08:18,850
number a result which is less than 17

00:08:15,130 --> 00:08:22,720
bits long so and then when you sign it

00:08:18,850 --> 00:08:25,630
to Z we reserved 32 bits there we know

00:08:22,720 --> 00:08:28,510
for an absolute fact that that addition

00:08:25,630 --> 00:08:30,760
will never fail so there's no point

00:08:28,510 --> 00:08:33,640
checking it so there's no code emitted

00:08:30,760 --> 00:08:37,240
in this case and that's a key thing

00:08:33,640 --> 00:08:39,099
because what it means is it turns out

00:08:37,240 --> 00:08:41,500
that and we'll see in a little while

00:08:39,099 --> 00:08:43,240
that you can eliminate almost all the

00:08:41,500 --> 00:08:46,540
runtime checking if you know where to do

00:08:43,240 --> 00:08:49,470
it and we have help for determining that

00:08:46,540 --> 00:08:49,470
so

00:08:50,380 --> 00:08:57,040
[Music]

00:08:53,410 --> 00:09:01,030
I'm gonna use as an example now the next

00:08:57,040 --> 00:09:04,160
let's call it objection is well you know

00:09:01,030 --> 00:09:05,540
you're you guys especially in boost you

00:09:04,160 --> 00:09:08,090
know you're always making this really

00:09:05,540 --> 00:09:10,610
fancy stuff and you know it's too

00:09:08,090 --> 00:09:14,060
complicated and by the way it's not

00:09:10,610 --> 00:09:17,270
really necessary and you know etc etc

00:09:14,060 --> 00:09:20,870
etc so I'm gonna I picked out an example

00:09:17,270 --> 00:09:25,220
here which is a hard example it's a

00:09:20,870 --> 00:09:28,880
small program written in C and it

00:09:25,220 --> 00:09:32,330
operate it runs the stepper motor of a

00:09:28,880 --> 00:09:35,330
surgical knife so next time you guys go

00:09:32,330 --> 00:09:39,050
in and get a vasectomy you'll know where

00:09:35,330 --> 00:09:41,300
it's coming from so any case but this

00:09:39,050 --> 00:09:46,480
gotta be right right we can't just say

00:09:41,300 --> 00:09:46,480
oh sorry you know there was an overflow

00:09:46,600 --> 00:09:54,410
so the so we're gonna make a program

00:09:51,860 --> 00:09:57,350
that we have confidence supreme

00:09:54,410 --> 00:10:00,500
confidence is correct and it drives a

00:09:57,350 --> 00:10:02,240
stepper motor uses a a pick my truck

00:10:00,500 --> 00:10:06,110
microcontroller this is a very commonly

00:10:02,240 --> 00:10:09,710
used small one ship computer it's a 16

00:10:06,110 --> 00:10:12,410
bit processor it's got 32 KB memory now

00:10:09,710 --> 00:10:14,210
we can see that we're already kind of

00:10:12,410 --> 00:10:18,770
got a question rising because it was a

00:10:14,210 --> 00:10:20,780
C++ conference and that certainly a the

00:10:18,770 --> 00:10:23,660
compiler that we have for this runs C

00:10:20,780 --> 00:10:26,960
but it doesn't handle templates it

00:10:23,660 --> 00:10:30,560
doesn't handle C++ etcetera etc but it

00:10:26,960 --> 00:10:35,720
turns out that the C and C++ share all

00:10:30,560 --> 00:10:39,350
the expression syntax and semantics for

00:10:35,720 --> 00:10:41,150
integer arithmetic so we're going to use

00:10:39,350 --> 00:10:43,910
the c cup plus plus compiler to

00:10:41,150 --> 00:10:48,290
absolutely prove that our c program

00:10:43,910 --> 00:10:50,540
cannot fail it's a combined environments

00:10:48,290 --> 00:10:54,320
hard to work it it's a single chip thing

00:10:50,540 --> 00:10:55,850
often times you don't have logging often

00:10:54,320 --> 00:10:59,630
times you can't even print anything out

00:10:55,850 --> 00:11:03,260
because you all the pins got occupied on

00:10:59,630 --> 00:11:05,390
the app itself if there's a mistake

00:11:03,260 --> 00:11:07,910
that you detect there's no recovery

00:11:05,390 --> 00:11:11,440
usually the mistakes aren't detected and

00:11:07,910 --> 00:11:16,760
a failure can be critical and even fatal

00:11:11,440 --> 00:11:20,690
the that's not a unknown situation we've

00:11:16,760 --> 00:11:23,360
heard about what's a good one unintended

00:11:20,690 --> 00:11:25,370
acceleration in those cases they'd never

00:11:23,360 --> 00:11:28,610
been able to find the actual cause and

00:11:25,370 --> 00:11:30,110
I'm gonna suggest that if the cause was

00:11:28,610 --> 00:11:32,480
something along the lines we've been

00:11:30,110 --> 00:11:35,060
discussing there's no reason why they

00:11:32,480 --> 00:11:39,440
would ever expect to find it unless they

00:11:35,060 --> 00:11:42,470
use this technique so here's here's how

00:11:39,440 --> 00:11:45,620
a stepper motor functions in simple

00:11:42,470 --> 00:11:49,100
terms it's got a rotor and the rotor is

00:11:45,620 --> 00:11:52,010
magnetized and there are coils around a

00:11:49,100 --> 00:11:54,440
circle and these coils get energized

00:11:52,010 --> 00:11:57,950
sequentially and they draw the motor

00:11:54,440 --> 00:12:00,800
around the circle it's this is the

00:11:57,950 --> 00:12:03,680
really simple idea the real idea it's

00:12:00,800 --> 00:12:09,290
the same thing just made more complex so

00:12:03,680 --> 00:12:11,300
our goal here is going to be to energize

00:12:09,290 --> 00:12:14,000
these things in the right sequence so

00:12:11,300 --> 00:12:26,750
far sounds pretty simple and that's not

00:12:14,000 --> 00:12:30,020
too bad but nothing is simple that when

00:12:26,750 --> 00:12:32,330
you have a situation like this the trick

00:12:30,020 --> 00:12:35,360
is the width of the pulses if you make

00:12:32,330 --> 00:12:38,240
the pulses really long the motors going

00:12:35,360 --> 00:12:41,960
to take forever run too slow if you make

00:12:38,240 --> 00:12:44,360
them pulses short them especially when

00:12:41,960 --> 00:12:47,180
the motor stopped you need it won't have

00:12:44,360 --> 00:12:49,280
enough time to get up to speed so it's a

00:12:47,180 --> 00:12:52,490
practical matter what you want to do is

00:12:49,280 --> 00:12:55,280
accelerate the motor smoothly from stop

00:12:52,490 --> 00:12:58,220
up into the speed that it runs so this

00:12:55,280 --> 00:13:01,250
means that these pulses need to start

00:12:58,220 --> 00:13:06,490
out at a certain width and then get

00:13:01,250 --> 00:13:10,610
smaller as we get up to speed and

00:13:06,490 --> 00:13:13,280
already this is kind of it seems dual

00:13:10,610 --> 00:13:13,940
but there's a little it's a little

00:13:13,280 --> 00:13:15,410
unclear

00:13:13,940 --> 00:13:16,480
remember we're sending thousands of

00:13:15,410 --> 00:13:18,130
pulses a second

00:13:16,480 --> 00:13:19,630
it's a little unclear how we're gonna do

00:13:18,130 --> 00:13:29,980
all this calculation in the ax time

00:13:19,630 --> 00:13:31,390
allotted so what are we gonna do well

00:13:29,980 --> 00:13:35,860
we're gonna do what we always do we're

00:13:31,390 --> 00:13:38,650
gonna start trawling the net for some

00:13:35,860 --> 00:13:41,770
guy who's already figured it out and I

00:13:38,650 --> 00:13:43,660
came upon this article and it's written

00:13:41,770 --> 00:13:46,000
by a guy named David Austin it's a

00:13:43,660 --> 00:13:47,170
beautifully written article and by the

00:13:46,000 --> 00:13:49,030
time you look around

00:13:47,170 --> 00:13:51,540
almost all the articles which deal with

00:13:49,030 --> 00:13:56,620
the subject end up coming back to this

00:13:51,540 --> 00:13:58,330
so and this is written in 2004 and was

00:13:56,620 --> 00:14:00,940
printed and invested embedded systems

00:13:58,330 --> 00:14:03,400
journal or something like that and so I

00:14:00,940 --> 00:14:05,590
looked at this article and of course you

00:14:03,400 --> 00:14:07,890
know you look through the math and yadda

00:14:05,590 --> 00:14:10,810
yadda yadda and mm-hmm

00:14:07,890 --> 00:14:15,580
already man I'm already thinking how the

00:14:10,810 --> 00:14:17,530
heck is this gonna work until I get and

00:14:15,580 --> 00:14:19,180
he does the whole analysis and he

00:14:17,530 --> 00:14:21,010
figures out how to calculate the width

00:14:19,180 --> 00:14:22,720
of every pulse and then he said you know

00:14:21,010 --> 00:14:24,670
that's gonna take too long so we're

00:14:22,720 --> 00:14:26,440
gonna make a an approximation to that

00:14:24,670 --> 00:14:28,750
that can work just an integer arithmetic

00:14:26,440 --> 00:14:32,820
and check to see if that approximation

00:14:28,750 --> 00:14:39,210
is good enough and he does all of that

00:14:32,820 --> 00:14:42,220
and he ends up with our original our

00:14:39,210 --> 00:14:43,210
original pulse is distributed according

00:14:42,220 --> 00:14:47,200
to plan

00:14:43,210 --> 00:14:49,090
and let's and let's have a look here now

00:14:47,200 --> 00:14:51,640
about halfway through the year through

00:14:49,090 --> 00:14:55,720
the paper he gets well that's equation

00:14:51,640 --> 00:14:59,500
four or nine ah okay he comes up with a

00:14:55,720 --> 00:15:02,290
magic that if we take the width of one

00:14:59,500 --> 00:15:04,680
pulse by using a simple formula we can

00:15:02,290 --> 00:15:07,060
take the width of the next pulse and

00:15:04,680 --> 00:15:08,680
then from then on we can do that

00:15:07,060 --> 00:15:10,900
iterative Li and we can generate all the

00:15:08,680 --> 00:15:12,820
pulses and the formula is super simple

00:15:10,900 --> 00:15:15,130
it works well within our integer

00:15:12,820 --> 00:15:17,290
arithmetic scheme so now we have

00:15:15,130 --> 00:15:20,920
something it's going to take my wife

00:15:17,290 --> 00:15:22,870
five or ten instructions and that's fast

00:15:20,920 --> 00:15:25,300
enough so that we can do it in the in

00:15:22,870 --> 00:15:29,180
the width of a pulse so that means now

00:15:25,300 --> 00:15:34,520
we can run our motorized knife on this

00:15:29,180 --> 00:15:39,710
small microprocessor and so this this is

00:15:34,520 --> 00:15:41,630
the actual one that he's got and it

00:15:39,710 --> 00:15:43,850
turns out that you refactor this

00:15:41,630 --> 00:15:46,610
slightly it's exactly the same formula

00:15:43,850 --> 00:15:49,250
and then if you do it on the down ramp

00:15:46,610 --> 00:15:51,560
it's slightly different because the

00:15:49,250 --> 00:15:53,900
pulses start out very very narrow and

00:15:51,560 --> 00:15:56,870
they get wider as you get it is a slow

00:15:53,900 --> 00:15:58,730
down to a stop but the interesting thing

00:15:56,870 --> 00:16:00,080
in this guy's so this guy's done frankly

00:15:58,730 --> 00:16:03,050
it's a beautiful piece of work he's

00:16:00,080 --> 00:16:04,610
taking a the physics and then he's

00:16:03,050 --> 00:16:06,530
taking the engine and then he's made an

00:16:04,610 --> 00:16:08,690
engineering job out of it which can

00:16:06,530 --> 00:16:12,580
really make something practical and all

00:16:08,690 --> 00:16:20,060
we got to do now is just write the code

00:16:12,580 --> 00:16:22,160
so uh so what was a code going to look

00:16:20,060 --> 00:16:24,680
like it's going to have some sort of

00:16:22,160 --> 00:16:30,080
setup because the pic microprocessor has

00:16:24,680 --> 00:16:32,480
a 449 page datasheet and it's filled

00:16:30,080 --> 00:16:34,250
with options and things to set and

00:16:32,480 --> 00:16:37,430
whatever it takes you days to figure it

00:16:34,250 --> 00:16:40,850
out but once it's done you kind of don't

00:16:37,430 --> 00:16:42,170
have to think about it very much and so

00:16:40,850 --> 00:16:44,300
we're gonna have a routine we're gonna

00:16:42,170 --> 00:16:47,240
have a call where you specify the target

00:16:44,300 --> 00:16:49,700
destination in number of steps number of

00:16:47,240 --> 00:16:53,450
clicks along the stepper motor and then

00:16:49,700 --> 00:16:55,640
you're going to specify an initial an

00:16:53,450 --> 00:16:57,800
initial width because the algorithm

00:16:55,640 --> 00:16:59,930
starts out with some initial width and

00:16:57,800 --> 00:17:02,090
then gets smaller and then you're gonna

00:16:59,930 --> 00:17:05,660
just turn on the interrupts and sit back

00:17:02,090 --> 00:17:08,750
and when an interrupt occurs if it's at

00:17:05,660 --> 00:17:11,030
the target position it stops the it

00:17:08,750 --> 00:17:14,329
doesn't do anymore interrupts if it's

00:17:11,030 --> 00:17:17,540
ramping up it uses equation 13 to make a

00:17:14,329 --> 00:17:21,290
smaller delay for the next one and if

00:17:17,540 --> 00:17:23,510
it's ramping down it uses equation 14 to

00:17:21,290 --> 00:17:23,839
make a little larger delay for the next

00:17:23,510 --> 00:17:26,000
one

00:17:23,839 --> 00:17:28,850
then it sits back again and waits for

00:17:26,000 --> 00:17:31,340
the next interrupt and so in principle

00:17:28,850 --> 00:17:34,250
it's very simple and also it's pretty

00:17:31,340 --> 00:17:36,140
accurate because we're not really

00:17:34,250 --> 00:17:38,390
counting in the instructions or whatever

00:17:36,140 --> 00:17:40,370
we're just setting it up and setting the

00:17:38,390 --> 00:17:42,530
up the interrupt in terms of clocks and

00:17:40,370 --> 00:17:44,300
whatever little diddling around we

00:17:42,530 --> 00:17:46,940
in there it doesn't really matter

00:17:44,300 --> 00:17:47,630
because it's going to come back at the

00:17:46,940 --> 00:17:50,150
right time

00:17:47,630 --> 00:17:58,660
so now this is look starting to look

00:17:50,150 --> 00:18:02,450
super promising and well and this guy

00:17:58,660 --> 00:18:05,210
David Austin he was so nice so kind to

00:18:02,450 --> 00:18:10,250
include us the whole damn program so

00:18:05,210 --> 00:18:12,260
it's like idiot proof and you know he

00:18:10,250 --> 00:18:16,910
does the initial things in here and

00:18:12,260 --> 00:18:20,030
here's his step motor routine and here

00:18:16,910 --> 00:18:23,420
is the where you specify that new target

00:18:20,030 --> 00:18:25,580
position and and here's where you

00:18:23,420 --> 00:18:26,720
initialize some registers and you're in

00:18:25,580 --> 00:18:30,050
business

00:18:26,720 --> 00:18:32,810
I'm gonna take a little slight one

00:18:30,050 --> 00:18:36,140
minute detour here in that you look at

00:18:32,810 --> 00:18:38,090
this and I mean we've established the

00:18:36,140 --> 00:18:39,860
guy is a really smart guy I mean there's

00:18:38,090 --> 00:18:42,800
no question there and then we look at

00:18:39,860 --> 00:18:45,800
this and you know it's totally

00:18:42,800 --> 00:18:48,560
impenetrable to me I look at it and I

00:18:45,800 --> 00:18:52,100
try and follow it and it takes me like

00:18:48,560 --> 00:18:56,150
all morning to actually convince myself

00:18:52,100 --> 00:18:59,030
that this implements the algorithm which

00:18:56,150 --> 00:19:01,910
he is described now this is not really a

00:18:59,030 --> 00:19:04,640
good situation because I'm making a

00:19:01,910 --> 00:19:06,680
surgical knife I want to be able to look

00:19:04,640 --> 00:19:09,380
at the code and know that it Maps

00:19:06,680 --> 00:19:12,110
exactly to the formulas that's already

00:19:09,380 --> 00:19:14,360
been derived I can't do that here so

00:19:12,110 --> 00:19:15,800
that's kind of a side issue we're gonna

00:19:14,360 --> 00:19:18,890
address that a little later

00:19:15,800 --> 00:19:21,410
but it's also very intriguing that such

00:19:18,890 --> 00:19:24,230
a smart guy and knowledgeable about

00:19:21,410 --> 00:19:26,120
physics and engineering the minute he

00:19:24,230 --> 00:19:30,080
starts to type code he just turns into a

00:19:26,120 --> 00:19:33,800
hacker like the rest of us and it's very

00:19:30,080 --> 00:19:35,870
disheartening so anyway we'll just keep

00:19:33,800 --> 00:19:41,300
that in mind and see if we can avoid

00:19:35,870 --> 00:19:44,900
that fate I the original code was

00:19:41,300 --> 00:19:48,470
written in a a see like language so I

00:19:44,900 --> 00:19:52,010
had to tweak it to fit into the

00:19:48,470 --> 00:19:56,620
microchip 8-bit compiler which is an

00:19:52,010 --> 00:20:01,310
ANSI C compiler so now I have code which

00:19:56,620 --> 00:20:03,800
purportedly I can compile for my for my

00:20:01,310 --> 00:20:06,320
microprocessor also could compile on my

00:20:03,800 --> 00:20:07,910
desktop now that's kind of moving in the

00:20:06,320 --> 00:20:10,610
direction where I want where we're going

00:20:07,910 --> 00:20:12,230
to have a real algorithm and it's not

00:20:10,610 --> 00:20:18,770
really necessarily connected to a

00:20:12,230 --> 00:20:21,230
particular machine and I verify that by

00:20:18,770 --> 00:20:25,730
I run the compiler and this is what the

00:20:21,230 --> 00:20:28,580
the the Microsoft xc8 compiler gives me

00:20:25,730 --> 00:20:31,850
back it's actually pretty interesting uh

00:20:28,580 --> 00:20:32,870
it it's the whole code as we described

00:20:31,850 --> 00:20:36,020
they're the hundred and seventy-nine

00:20:32,870 --> 00:20:39,260
lines of code works out to 1300 bytes

00:20:36,020 --> 00:20:44,320
and we've got 32 K so we're you know

00:20:39,260 --> 00:20:47,060
we're liking we're we're relaxed now the

00:20:44,320 --> 00:20:51,380
the amount of data space we use there's

00:20:47,060 --> 00:20:54,920
only 78 bytes and we have 16 K bailable

00:20:51,380 --> 00:20:58,340
so you know how we could go to smaller

00:20:54,920 --> 00:20:59,780
processor but anyway we're not gonna do

00:20:58,340 --> 00:21:01,250
that because we're not gonna change

00:20:59,780 --> 00:21:02,870
anything because they already wanted

00:21:01,250 --> 00:21:06,580
yesterday you know we hate working like

00:21:02,870 --> 00:21:10,400
under pressure on something like this so

00:21:06,580 --> 00:21:12,410
anyway so what we do is we take this

00:21:10,400 --> 00:21:16,640
code and we factor it into a couple

00:21:12,410 --> 00:21:20,150
pieces the main piece this piece I

00:21:16,640 --> 00:21:23,810
called motorcy that's C code that

00:21:20,150 --> 00:21:26,720
doesn't have the types in it it doesn't

00:21:23,810 --> 00:21:28,580
have the test framework that that tries

00:21:26,720 --> 00:21:30,950
different things doesn't have logging or

00:21:28,580 --> 00:21:32,900
anything like that and so we have two

00:21:30,950 --> 00:21:37,100
versions of our program this one runs on

00:21:32,900 --> 00:21:38,660
this one up here runs on the processor

00:21:37,100 --> 00:21:41,480
on the microprocessor so we can download

00:21:38,660 --> 00:21:44,410
it and hit the start button and it'll

00:21:41,480 --> 00:21:48,410
work or it won't work this is the the

00:21:44,410 --> 00:21:51,920
burnin crash method and then we have

00:21:48,410 --> 00:21:54,950
another version that we can run on the

00:21:51,920 --> 00:21:57,230
desktop and when it runs through the the

00:21:54,950 --> 00:22:00,950
desktop code it calls the functions in

00:21:57,230 --> 00:22:03,260
our main routine but then it does

00:22:00,950 --> 00:22:05,450
logging or it does tests or whatever we

00:22:03,260 --> 00:22:07,460
want so now we have we're really in a

00:22:05,450 --> 00:22:10,440
much better place than when we started

00:22:07,460 --> 00:22:14,850
because this code which is going to

00:22:10,440 --> 00:22:16,860
run our target product is we can

00:22:14,850 --> 00:22:23,750
actually test on the desktop whereas

00:22:16,860 --> 00:22:23,750
before it was just about impossible so

00:22:24,799 --> 00:22:30,899
and this is what this looks like it's

00:22:29,250 --> 00:22:34,710
got a bunch of stuff at the big includes

00:22:30,899 --> 00:22:36,450
new safe numerix it includes I think

00:22:34,710 --> 00:22:38,159
we'll talk about in a minute and

00:22:36,450 --> 00:22:41,220
includes a couple macros which are

00:22:38,159 --> 00:22:44,190
decide which are manifest constants

00:22:41,220 --> 00:22:49,019
which are related to the total length of

00:22:44,190 --> 00:22:52,620
the linear motor and then we define with

00:22:49,019 --> 00:22:56,460
the type deaths a bunch of type deaths

00:22:52,620 --> 00:22:59,730
which are the types that are motor dot

00:22:56,460 --> 00:23:01,710
see our target code uses so on the

00:22:59,730 --> 00:23:04,200
desktop when we run our test it's going

00:23:01,710 --> 00:23:07,740
to be using the safe numeric library on

00:23:04,200 --> 00:23:09,210
the on the target when we download it

00:23:07,740 --> 00:23:11,580
and push the button it's going to be

00:23:09,210 --> 00:23:14,669
using its normal types that it uses

00:23:11,580 --> 00:23:18,210
there so we're gonna be running the same

00:23:14,669 --> 00:23:19,590
program in exactly the same code and -

00:23:18,210 --> 00:23:21,389
not exactly the same code it's so

00:23:19,590 --> 00:23:25,370
totally different processor but the same

00:23:21,389 --> 00:23:28,529
source code in two different places so

00:23:25,370 --> 00:23:31,409
and then there's a there's a there's

00:23:28,529 --> 00:23:34,350
another spot here we the pic has some

00:23:31,409 --> 00:23:35,970
special syntax and features for dealing

00:23:34,350 --> 00:23:37,350
with some pic stuff it's not

00:23:35,970 --> 00:23:39,960
particularly interesting but we can

00:23:37,350 --> 00:23:42,750
emulate it on the desktop and the reason

00:23:39,960 --> 00:23:44,700
why that's interesting though is that we

00:23:42,750 --> 00:23:47,129
will have exec we won't have a different

00:23:44,700 --> 00:23:49,200
different version of our program that

00:23:47,129 --> 00:23:51,750
works on a desktop and it works on the

00:23:49,200 --> 00:23:53,759
target will have exactly the same source

00:23:51,750 --> 00:23:55,980
code and that's important because the

00:23:53,759 --> 00:23:57,960
minute some guy sticks his finger to

00:23:55,980 --> 00:23:59,159
change one thing then we don't have the

00:23:57,960 --> 00:24:03,570
confidence that we're really testing

00:23:59,159 --> 00:24:06,299
what we're flying so I made this little

00:24:03,570 --> 00:24:08,070
bit to emulate the that pic has some

00:24:06,299 --> 00:24:10,350
instructions for changing one bit at a

00:24:08,070 --> 00:24:14,399
time and whatever but I with a sort of

00:24:10,350 --> 00:24:18,480
magic of C++ I was able to replicate

00:24:14,399 --> 00:24:23,680
that and now we just include right here

00:24:18,480 --> 00:24:25,690
our motor program and that is

00:24:23,680 --> 00:24:28,270
butts gonna run on the target and run in

00:24:25,690 --> 00:24:30,460
our desktop and then here's the desktop

00:24:28,270 --> 00:24:33,490
code and it's got out here it's got a

00:24:30,460 --> 00:24:36,100
test routine and it it prints some stuff

00:24:33,490 --> 00:24:37,570
out and it does all the stuff that test

00:24:36,100 --> 00:24:39,700
code normally does in here it

00:24:37,570 --> 00:24:41,350
initializes a system and it moves us

00:24:39,700 --> 00:24:43,750
position to a thousand then it moves the

00:24:41,350 --> 00:24:46,330
most efficient position 100 and then it

00:24:43,750 --> 00:24:48,070
moves to position 200 again and and then

00:24:46,330 --> 00:24:50,830
it keeps a log of all the places it

00:24:48,070 --> 00:24:53,980
moved to so I can actually verify that

00:24:50,830 --> 00:24:56,590
this thing is is actually producing this

00:24:53,980 --> 00:24:59,350
curve here because I had the width of

00:24:56,590 --> 00:25:02,320
the steps and I could graph it or

00:24:59,350 --> 00:25:05,620
whatever if I had time interestingly

00:25:02,320 --> 00:25:11,740
enough the first time I did this this

00:25:05,620 --> 00:25:16,540
thing choked at position 5 if 500

00:25:11,740 --> 00:25:19,930
millimeters out because apparently mr.

00:25:16,540 --> 00:25:21,580
Austin didn't run his to that extent so

00:25:19,930 --> 00:25:24,070
either he never had a problem or he a

00:25:21,580 --> 00:25:28,750
problem had a problem never knew it so

00:25:24,070 --> 00:25:33,400
anyway that's so we already got some

00:25:28,750 --> 00:25:36,130
bang for the buck right there now one

00:25:33,400 --> 00:25:37,660
thing I alluded to was from the very

00:25:36,130 --> 00:25:40,420
beginning and also here is this

00:25:37,660 --> 00:25:43,600
promotion policy I that we're running

00:25:40,420 --> 00:25:46,420
the same code the same program on the

00:25:43,600 --> 00:25:49,060
desktop and on the target that's not

00:25:46,420 --> 00:25:51,400
strictly true and but we're gonna fix

00:25:49,060 --> 00:25:54,400
them now it's not true because if I have

00:25:51,400 --> 00:25:57,730
two 16-bit integers and on the target

00:25:54,400 --> 00:26:00,220
the natural they're they're promoted to

00:25:57,730 --> 00:26:02,170
the natural interest integer size of the

00:26:00,220 --> 00:26:04,420
compiler in the machine it's running on

00:26:02,170 --> 00:26:07,510
now that natural integer size is

00:26:04,420 --> 00:26:12,480
different on the microprocessor target

00:26:07,510 --> 00:26:16,180
than it is on my desktop so there are

00:26:12,480 --> 00:26:18,460
situations where the the code would run

00:26:16,180 --> 00:26:21,700
fine on my desktop but overflow when

00:26:18,460 --> 00:26:23,260
moved to the target this is a totally

00:26:21,700 --> 00:26:26,260
what I'm trying to avoid I want to be

00:26:23,260 --> 00:26:28,980
able to prove they're the same so and

00:26:26,260 --> 00:26:32,380
here's the question if I if I have

00:26:28,980 --> 00:26:34,470
30,000 and I do this expression here

00:26:32,380 --> 00:26:37,570
what is the value of the X going to be

00:26:34,470 --> 00:26:41,920
on anybody got want to take

00:26:37,570 --> 00:26:44,650
yes well it's not gonna be 60,000 I'll

00:26:41,920 --> 00:26:54,150
tell you that because 60,000 won't fit

00:26:44,650 --> 00:26:59,140
into a 16-bit number more maybe not the

00:26:54,150 --> 00:27:02,440
the if I put that on the desktop on the

00:26:59,140 --> 00:27:06,190
other hand the desktop has a 32-bit

00:27:02,440 --> 00:27:09,640
integer size and but it's this was this

00:27:06,190 --> 00:27:11,680
so when this expression here gets

00:27:09,640 --> 00:27:14,320
subjected to the arithmetic promotion

00:27:11,680 --> 00:27:17,140
that C++ does it'll automatically bump

00:27:14,320 --> 00:27:19,690
them up to it to 32-bit integers and it

00:27:17,140 --> 00:27:22,180
will return the right at right result so

00:27:19,690 --> 00:27:24,910
this is this is illustration of the

00:27:22,180 --> 00:27:27,340
problem that we're not mapping the

00:27:24,910 --> 00:27:30,610
actual arithmetic from the target to the

00:27:27,340 --> 00:27:33,280
desktop so the desktop doesn't give us

00:27:30,610 --> 00:27:36,700
real confidence that our algorithm

00:27:33,280 --> 00:27:39,580
actually has been tested so what we for

00:27:36,700 --> 00:27:42,070
our safe numeric types we we can specify

00:27:39,580 --> 00:27:46,020
what's referred to as the promotion

00:27:42,070 --> 00:27:52,950
policy since we're overloading all the

00:27:46,020 --> 00:27:56,350
the integer arithmetic we can specify

00:27:52,950 --> 00:27:59,440
this these promotions and we handle them

00:27:56,350 --> 00:28:02,110
explicitly and via this policy we're

00:27:59,440 --> 00:28:05,260
saying when I make these safe integers

00:28:02,110 --> 00:28:09,490
that which is in this case is safe in 16

00:28:05,260 --> 00:28:12,970
and using this promotion policy then do

00:28:09,490 --> 00:28:18,340
not promote it to the natural integer

00:28:12,970 --> 00:28:23,530
the desktop promote it to a 16-bit

00:28:18,340 --> 00:28:25,990
integer now when I do the the integer

00:28:23,530 --> 00:28:31,030
arithmetic it will fail in the desktop

00:28:25,990 --> 00:28:32,590
and that's my key at that point in an on

00:28:31,030 --> 00:28:35,350
the desktop since we have the ability to

00:28:32,590 --> 00:28:37,900
trap interrupts and whatever this code

00:28:35,350 --> 00:28:39,910
that previous code will fail on the

00:28:37,900 --> 00:28:41,590
desktop and show me where it failed so

00:28:39,910 --> 00:28:43,960
that when I download it to the target I

00:28:41,590 --> 00:28:46,360
know it will I know it will work I knew

00:28:43,960 --> 00:28:48,820
it will fail there as well if it passes

00:28:46,360 --> 00:28:51,040
on the desktop I'll know that it passes

00:28:48,820 --> 00:28:54,610
on the target as well because the

00:28:51,040 --> 00:28:59,950
the integer promotion policies are being

00:28:54,610 --> 00:29:02,710
maintained to be the same so how the

00:28:59,950 --> 00:29:04,630
interesting thing is let's suppose I

00:29:02,710 --> 00:29:06,790
have a mistake and it shows up in the

00:29:04,630 --> 00:29:08,220
disk part I download it to the pic and I

00:29:06,790 --> 00:29:12,400
run it anyway

00:29:08,220 --> 00:29:15,580
hmm what's gonna happen anybody want to

00:29:12,400 --> 00:29:17,290
take a guess it's gonna do what it

00:29:15,580 --> 00:29:19,600
always does and what we've been doing

00:29:17,290 --> 00:29:22,330
for 40 years it's going to do the

00:29:19,600 --> 00:29:26,200
calculation return the wrong result and

00:29:22,330 --> 00:29:28,930
keep going because that's what C++ does

00:29:26,200 --> 00:29:31,030
and once we've take the code off the

00:29:28,930 --> 00:29:32,590
desktop and we put it into the target we

00:29:31,030 --> 00:29:34,360
don't have the safe numeric library

00:29:32,590 --> 00:29:36,730
anymore we only really used it to check

00:29:34,360 --> 00:29:40,120
the stuff on the desktop but once we put

00:29:36,730 --> 00:29:43,450
this stuff in the in the target we've

00:29:40,120 --> 00:29:48,190
taken off our seat belts and you know

00:29:43,450 --> 00:29:52,090
we're skinny dipping again so that's

00:29:48,190 --> 00:29:55,630
that that describes the necessity in the

00:29:52,090 --> 00:29:58,510
utility of this being able to specify

00:29:55,630 --> 00:30:00,520
the type promotion for safe integers it

00:29:58,510 --> 00:30:03,520
means that our safe integers can be used

00:30:00,520 --> 00:30:14,800
to actually emulate the arithmetic that

00:30:03,520 --> 00:30:15,580
occurs on another machine okay here's a

00:30:14,800 --> 00:30:17,860
way to fix this

00:30:15,580 --> 00:30:19,450
or here's a way it went now if you had

00:30:17,860 --> 00:30:23,080
this problem then what would you do

00:30:19,450 --> 00:30:24,910
hmm well we know in the in the target

00:30:23,080 --> 00:30:27,460
machine we don't have the ability to

00:30:24,910 --> 00:30:31,150
throw an interrupt or catch something or

00:30:27,460 --> 00:30:33,610
even emit an error message we want to

00:30:31,150 --> 00:30:37,750
fix it well one way of fixing it would

00:30:33,610 --> 00:30:41,410
be to use a larger type for doing it to

00:30:37,750 --> 00:30:44,770
promote to a larger type and the way we

00:30:41,410 --> 00:30:49,780
could do that is in this case we create

00:30:44,770 --> 00:30:52,900
a safe integer of 32 bits wide from the

00:30:49,780 --> 00:30:55,750
value 2 now when we multiply that by X

00:30:52,900 --> 00:30:57,880
which is a 16-bit integer the C++

00:30:55,750 --> 00:30:59,860
compiler the way it works is it takes

00:30:57,880 --> 00:31:02,050
the two operands and it makes sure

00:30:59,860 --> 00:31:03,380
they're the same type by taking the

00:31:02,050 --> 00:31:06,560
shorter one in X

00:31:03,380 --> 00:31:09,290
ending it to match the larger one so at

00:31:06,560 --> 00:31:11,870
this point when this multiplication is

00:31:09,290 --> 00:31:14,690
done now the temporary result which is

00:31:11,870 --> 00:31:17,930
in the CPU or is on the registers is a

00:31:14,690 --> 00:31:22,850
32-bit number there's no overflow here

00:31:17,930 --> 00:31:25,220
and then we divide that by four which is

00:31:22,850 --> 00:31:26,960
a long division oh no actually that's a

00:31:25,220 --> 00:31:30,560
super simple division is two shifting

00:31:26,960 --> 00:31:33,680
and then we'll come up with a result

00:31:30,560 --> 00:31:34,160
which is how fits in a 16-bit number

00:31:33,680 --> 00:31:37,340
again

00:31:34,160 --> 00:31:41,780
so if we'd assign that back to X we know

00:31:37,340 --> 00:31:43,760
it's still gonna work so and we know it

00:31:41,780 --> 00:31:46,610
has zero overhead the only extra

00:31:43,760 --> 00:31:49,130
overhead is doing this using this 32-bit

00:31:46,610 --> 00:31:52,040
number for the calculation and which is

00:31:49,130 --> 00:31:54,470
the only which is basically one

00:31:52,040 --> 00:31:57,260
instruction overhead that we need and

00:31:54,470 --> 00:31:59,300
cannot avoid if we're will in because

00:31:57,260 --> 00:32:02,810
we've already said we're not going to

00:31:59,300 --> 00:32:05,330
tolerate any mistakes and so the only

00:32:02,810 --> 00:32:07,820
way to guarantee that would be to do

00:32:05,330 --> 00:32:09,680
something like this now those who are

00:32:07,820 --> 00:32:12,320
going to complain well the safe numeric

00:32:09,680 --> 00:32:16,430
library is going to increase your

00:32:12,320 --> 00:32:19,010
overhead whatever I say no it will in

00:32:16,430 --> 00:32:22,550
this case find a place where you need

00:32:19,010 --> 00:32:25,070
the tweak to guarantee exactly the

00:32:22,550 --> 00:32:37,790
relative result you need with no extra

00:32:25,070 --> 00:32:41,120
overhead at all there's other promotion

00:32:37,790 --> 00:32:43,220
policies the default one is native it

00:32:41,120 --> 00:32:46,880
just and most of you use this all the

00:32:43,220 --> 00:32:48,860
time that real I'm this usage case for

00:32:46,880 --> 00:32:50,960
the safety of Marik's library I picked

00:32:48,860 --> 00:32:53,810
out because it's the very hardest one

00:32:50,960 --> 00:32:56,390
and it illustrates the most difficult

00:32:53,810 --> 00:32:58,760
problems that we have to solve but it's

00:32:56,390 --> 00:33:01,220
a practical matter I would expect more

00:32:58,760 --> 00:33:02,960
people just to say oh you know this

00:33:01,220 --> 00:33:04,730
program is not working I'm just gonna

00:33:02,960 --> 00:33:06,530
change the interview integers to the

00:33:04,730 --> 00:33:08,690
safe numerix energies and see what

00:33:06,530 --> 00:33:09,770
happens in that case what you really

00:33:08,690 --> 00:33:11,270
wanted you don't really want to

00:33:09,770 --> 00:33:14,090
replicate anything else you just want

00:33:11,270 --> 00:33:15,520
the normal desktop arithmetic to happen

00:33:14,090 --> 00:33:17,770
but you want it to happen

00:33:15,520 --> 00:33:19,840
than the environment of the safe numerix

00:33:17,770 --> 00:33:22,750
library so that any mistakes can be cat

00:33:19,840 --> 00:33:24,820
caught in check that's what you do is

00:33:22,750 --> 00:33:27,040
the native and that's the default one

00:33:24,820 --> 00:33:29,920
and that's what you'd use the native

00:33:27,040 --> 00:33:32,650
promotion policy for you can use the

00:33:29,920 --> 00:33:35,260
automatic one the CPP one is when you

00:33:32,650 --> 00:33:37,690
want to specify qui views here that uses

00:33:35,260 --> 00:33:39,940
CPP type promotion but you get to

00:33:37,690 --> 00:33:41,950
specify the size of the types which

00:33:39,940 --> 00:33:44,110
things are promoted to and then there's

00:33:41,950 --> 00:33:48,220
the automatic one and what that does

00:33:44,110 --> 00:33:52,270
that automatically this thing that we

00:33:48,220 --> 00:33:55,240
inserted by hand by using a larger

00:33:52,270 --> 00:33:58,990
variable for the temporary result it

00:33:55,240 --> 00:34:02,350
does that automatically so if this were

00:33:58,990 --> 00:34:05,440
a type for which automatic promotion was

00:34:02,350 --> 00:34:09,100
specified then this with zero runtime

00:34:05,440 --> 00:34:12,300
overhead would never fail unfortunately

00:34:09,100 --> 00:34:16,090
your program wouldn't be c++ anymore

00:34:12,300 --> 00:34:19,480
because you've overridden the normal

00:34:16,090 --> 00:34:24,190
promotion rules in a in exchange for

00:34:19,480 --> 00:34:26,409
ones you think are better not everyone's

00:34:24,190 --> 00:34:28,360
gonna agree on that but in any case the

00:34:26,409 --> 00:34:33,280
fact is your program is not portable

00:34:28,360 --> 00:34:35,260
anymore because you've your program is

00:34:33,280 --> 00:34:37,690
not portable to regular integers anymore

00:34:35,260 --> 00:34:40,600
because you've actually altered the way

00:34:37,690 --> 00:34:43,840
that integers function it's there

00:34:40,600 --> 00:34:46,600
because it's doable and some people

00:34:43,840 --> 00:34:49,380
might find it it's really unclear what

00:34:46,600 --> 00:34:51,460
the future of that will be it does work

00:34:49,380 --> 00:34:52,960
but I'm wondering about the

00:34:51,460 --> 00:34:57,580
repercussions if somebody that were to

00:34:52,960 --> 00:35:01,570
actually use this in a big project so so

00:34:57,580 --> 00:35:04,960
far we made huge progress we have our

00:35:01,570 --> 00:35:07,120
microprocessor we can we build a code on

00:35:04,960 --> 00:35:10,900
our own on our desktop we download it in

00:35:07,120 --> 00:35:12,970
there in order verify that our actual

00:35:10,900 --> 00:35:16,470
code works we can run it on our desktop

00:35:12,970 --> 00:35:19,870
we can run it fully check to know to

00:35:16,470 --> 00:35:22,930
find every single Aerith arithmetic

00:35:19,870 --> 00:35:25,390
error we can run we can make 50 tests

00:35:22,930 --> 00:35:27,340
for it and run them all on the desktop

00:35:25,390 --> 00:35:28,700
and we know that if they pass on the

00:35:27,340 --> 00:35:31,970
desktop they'll pass on the

00:35:28,700 --> 00:35:40,070
target I feel much better about going to

00:35:31,970 --> 00:35:43,820
the doctor's office now so the normally

00:35:40,070 --> 00:35:47,930
on the desktop it whenever we have an

00:35:43,820 --> 00:35:51,770
exceptional situation divided by zero or

00:35:47,930 --> 00:35:53,930
overflow or any number of these

00:35:51,770 --> 00:35:56,930
situations which we detect up until now

00:35:53,930 --> 00:36:00,380
we've detected them at runtime and had

00:35:56,930 --> 00:36:03,859
the program throw an exception as is

00:36:00,380 --> 00:36:06,260
there a promotion policy there's also an

00:36:03,859 --> 00:36:08,750
exception policy where I can say what I

00:36:06,260 --> 00:36:11,780
wanted to do if it discovers if it comes

00:36:08,750 --> 00:36:16,820
upon any situation which it can't handle

00:36:11,780 --> 00:36:18,650
and so normally it throws an exception I

00:36:16,820 --> 00:36:20,390
could specify my own function and

00:36:18,650 --> 00:36:21,829
there's a couple options there but

00:36:20,390 --> 00:36:25,790
there's one in particular that's very

00:36:21,829 --> 00:36:29,599
interesting it's I call it a trap policy

00:36:25,790 --> 00:36:34,010
and what that does is if your program

00:36:29,599 --> 00:36:37,310
comes upon any part that will invokes

00:36:34,010 --> 00:36:41,329
this trap policy the program will not

00:36:37,310 --> 00:36:44,420
compile or if it comes upon any part

00:36:41,329 --> 00:36:47,869
where it has to check to do some runtime

00:36:44,420 --> 00:36:50,810
checking it will fail to compile at that

00:36:47,869 --> 00:36:52,790
moment so if you want to say you know my

00:36:50,810 --> 00:36:55,069
program and this is the case we have

00:36:52,790 --> 00:36:57,170
here our target system can't do any

00:36:55,069 --> 00:36:59,390
runtime checking it doesn't have the

00:36:57,170 --> 00:37:01,730
capability it's being made in the C but

00:36:59,390 --> 00:37:04,010
on the other hand I don't feel confident

00:37:01,730 --> 00:37:06,890
releasing that to the world knowing that

00:37:04,010 --> 00:37:09,710
I could still have an error oh yeah I

00:37:06,890 --> 00:37:11,839
could I could I could I could put it I

00:37:09,710 --> 00:37:15,950
could discover it on the desktop if I

00:37:11,839 --> 00:37:18,530
make the right test case but who wants

00:37:15,950 --> 00:37:21,740
to be the test case on the target

00:37:18,530 --> 00:37:25,700
no volunteer is available what we want

00:37:21,740 --> 00:37:29,780
is a provably correct arithmetic

00:37:25,700 --> 00:37:34,369
expression and the way we do that is we

00:37:29,780 --> 00:37:36,589
compile art we change our type from the

00:37:34,369 --> 00:37:40,640
normal exception policy where it throws

00:37:36,589 --> 00:37:42,140
an exception to the loose trap policy or

00:37:40,640 --> 00:37:45,470
that trap Paulo

00:37:42,140 --> 00:37:49,190
whereby if it even thinks about throwing

00:37:45,470 --> 00:37:51,319
an exception it would basically declares

00:37:49,190 --> 00:37:54,140
an exception function which is not

00:37:51,319 --> 00:37:57,140
implemented and so it fails to compile

00:37:54,140 --> 00:37:58,670
right at that moment so if and then of

00:37:57,140 --> 00:38:00,319
course what do I do I go back and zero

00:37:58,670 --> 00:38:04,039
my program a little bit like I had

00:38:00,319 --> 00:38:07,220
before to know that there's it can never

00:38:04,039 --> 00:38:10,099
fail at compile it can never ever ething

00:38:07,220 --> 00:38:13,549
runtime overhead excuse me there's no

00:38:10,099 --> 00:38:16,250
rent I'm overhead I change the types so

00:38:13,549 --> 00:38:17,690
that when the arithmetic is done that

00:38:16,250 --> 00:38:19,579
there can never be any overflow and

00:38:17,690 --> 00:38:21,769
normally this would be by using little

00:38:19,579 --> 00:38:23,539
larger types in particular situations or

00:38:21,769 --> 00:38:25,670
whatever it does turn into kind of a

00:38:23,539 --> 00:38:28,190
tedious operation but the final result

00:38:25,670 --> 00:38:30,230
if you can manage to do it then you will

00:38:28,190 --> 00:38:32,779
have a program that you know with

00:38:30,230 --> 00:38:36,529
absolute certainty will never fail and

00:38:32,779 --> 00:38:38,750
to has zero runtime overhead and can

00:38:36,529 --> 00:38:41,859
operand therefore can operate in an

00:38:38,750 --> 00:38:51,230
environment where there is no error

00:38:41,859 --> 00:38:54,049
processing and so and here's how you use

00:38:51,230 --> 00:38:58,369
it when you in this particular case I

00:38:54,049 --> 00:39:00,140
made a variable C remember we talked

00:38:58,369 --> 00:39:03,619
about the pulse-width in this guy's code

00:39:00,140 --> 00:39:06,380
he specified the variable C is the

00:39:03,619 --> 00:39:11,359
length the width of that pulse and the

00:39:06,380 --> 00:39:13,730
width of that pulse we figured out could

00:39:11,359 --> 00:39:15,700
vary between some minimum and some

00:39:13,730 --> 00:39:17,630
maximum there's some there's some pulse

00:39:15,700 --> 00:39:19,369
larger than which we don't want to

00:39:17,630 --> 00:39:20,660
exceed and there's some minimum size

00:39:19,369 --> 00:39:25,160
pulse we don't want to make it smaller

00:39:20,660 --> 00:39:27,170
than that so I there's a particular type

00:39:25,160 --> 00:39:29,539
of safe type where I can specify the

00:39:27,170 --> 00:39:31,880
range if I were to try and store

00:39:29,539 --> 00:39:35,470
anything in which was outside of the

00:39:31,880 --> 00:39:38,900
range program would fail right away and

00:39:35,470 --> 00:39:42,289
if I try to do that at compile time it

00:39:38,900 --> 00:39:45,650
won't compile and right now in this case

00:39:42,289 --> 00:39:47,960
this has the exception policy so it

00:39:45,650 --> 00:39:50,839
would it would compile but if it were to

00:39:47,960 --> 00:39:53,200
occur it would throw an exception this

00:39:50,839 --> 00:39:55,450
actually turns out to be pretty handy

00:39:53,200 --> 00:39:57,309
when you're talking engineering stuff or

00:39:55,450 --> 00:39:59,049
whatever a lot of things have limits

00:39:57,309 --> 00:40:02,470
you're not allowed to exceed or indicate

00:39:59,049 --> 00:40:05,859
some other error and it's very easy to

00:40:02,470 --> 00:40:09,900
actually specify more information about

00:40:05,859 --> 00:40:12,130
your variables and it's bigger than that

00:40:09,900 --> 00:40:14,890
let's see what the next slide is I

00:40:12,130 --> 00:40:17,170
forgot already yeah we'll talk about it

00:40:14,890 --> 00:40:19,690
now it's a it's a little bit more than

00:40:17,170 --> 00:40:22,450
that if I have two variables and I know

00:40:19,690 --> 00:40:28,030
that they're only limited between with a

00:40:22,450 --> 00:40:31,359
range of 0 to 34 and I know that because

00:40:28,030 --> 00:40:35,559
they're safe ranges and they can have

00:40:31,359 --> 00:40:38,920
any value from 0 to 34 well you know if

00:40:35,559 --> 00:40:41,079
I add two of those I absolutely know

00:40:38,920 --> 00:40:44,950
that those the result of that cannot

00:40:41,079 --> 00:40:49,359
exceed 68 I also happen to know that

00:40:44,950 --> 00:40:52,210
that fits into an 8-bit integer so now

00:40:49,359 --> 00:40:53,770
if I have an expression which similar to

00:40:52,210 --> 00:40:56,349
the ones we had before where I was

00:40:53,770 --> 00:40:57,880
adding two 8 bit numbers I had to

00:40:56,349 --> 00:41:01,329
account for the possibility that they

00:40:57,880 --> 00:41:05,730
might require 16 bits now I don't

00:41:01,329 --> 00:41:08,859
because those calculations are done at

00:41:05,730 --> 00:41:11,290
compile time to know what the range of

00:41:08,859 --> 00:41:14,230
the final result is and compare it to

00:41:11,290 --> 00:41:18,760
the type of the final result so this

00:41:14,230 --> 00:41:20,440
eliminates any so so so a lot of the

00:41:18,760 --> 00:41:22,510
things we think need to be checked

00:41:20,440 --> 00:41:25,450
actually can be checked at compile time

00:41:22,510 --> 00:41:28,510
we do range arithmetic on the operands

00:41:25,450 --> 00:41:31,059
to know what the result operand is and

00:41:28,510 --> 00:41:34,390
if that operand fits in the type and the

00:41:31,059 --> 00:41:36,490
destination type we're golden we don't

00:41:34,390 --> 00:41:39,099
have to check it and the library will

00:41:36,490 --> 00:41:42,730
not check it if it exceeds what the

00:41:39,099 --> 00:41:44,170
destination type can hold it will insert

00:41:42,730 --> 00:41:49,720
the checking code to make sure that that

00:41:44,170 --> 00:41:53,710
never happens and so that's that would

00:41:49,720 --> 00:41:55,599
mean if this thing passes well that's

00:41:53,710 --> 00:41:57,040
that's pretty much I don't want to I

00:41:55,599 --> 00:42:00,819
don't know what else to say about that I

00:41:57,040 --> 00:42:03,309
know it's it's a little bit obscure but

00:42:00,819 --> 00:42:06,380
it's not that easy for me to figure out

00:42:03,309 --> 00:42:08,420
a better way to explain it

00:42:06,380 --> 00:42:10,730
here's another case I have a number like

00:42:08,420 --> 00:42:13,280
in an Eric's and we have we've had Lisa

00:42:10,730 --> 00:42:16,910
seen some arithmetic expressions which

00:42:13,280 --> 00:42:20,300
have the number 2 or 4 in them now when

00:42:16,910 --> 00:42:24,020
the C compiler compiles those it it

00:42:20,300 --> 00:42:27,680
figures it's an integer whose value

00:42:24,020 --> 00:42:30,380
could be anywhere from 0 to 30 mm and

00:42:27,680 --> 00:42:32,450
when it does the compile time arithmetic

00:42:30,380 --> 00:42:35,600
it takes that into account even though I

00:42:32,450 --> 00:42:38,720
happen to know it's 42 but the compiler

00:42:35,600 --> 00:42:41,990
kind of ignores that so if I use this

00:42:38,720 --> 00:42:44,810
safe literal thing what it does is it

00:42:41,990 --> 00:42:46,910
takes the number 4 and it makes a

00:42:44,810 --> 00:42:48,530
special type for the number 4 and then

00:42:46,910 --> 00:42:51,110
when it does the range bass to let

00:42:48,530 --> 00:42:54,950
arithmetic it takes into account ah if I

00:42:51,110 --> 00:42:58,280
take the literal 4 and multiply it by 27

00:42:54,950 --> 00:43:03,080
the maximum amount that that can reach

00:42:58,280 --> 00:43:03,620
is a 109 and if that fits into a 8 bit

00:43:03,080 --> 00:43:07,760
number

00:43:03,620 --> 00:43:12,350
I'm also golden so we basically insert a

00:43:07,760 --> 00:43:14,140
lot of information about each integer so

00:43:12,350 --> 00:43:16,850
that it when it does that

00:43:14,140 --> 00:43:19,210
compilation it's checking ahead it's

00:43:16,850 --> 00:43:21,440
thinking ahead into the runtime to know

00:43:19,210 --> 00:43:24,290
when it needs to include the checking

00:43:21,440 --> 00:43:28,130
code and when it doesn't this is all

00:43:24,290 --> 00:43:30,170
this has been fruit of the response to

00:43:28,130 --> 00:43:32,270
the question is I don't want to have it

00:43:30,170 --> 00:43:33,980
check all this stuff because frankly it

00:43:32,270 --> 00:43:36,770
takes a lot of time and it's not

00:43:33,980 --> 00:43:38,180
necessary and if I say it's necessary

00:43:36,770 --> 00:43:40,940
let's say but it still takes a lot of

00:43:38,180 --> 00:43:50,150
time and I'm arguing it doesn't really

00:43:40,940 --> 00:43:52,190
anymore so now when we add 1 in for a

00:43:50,150 --> 00:43:53,870
diamond in for a dollar I'd say well hey

00:43:52,190 --> 00:43:57,410
this is a great idea I have a special

00:43:53,870 --> 00:43:59,660
type just for the step with and that has

00:43:57,410 --> 00:44:02,270
a range on it so that's actually checked

00:43:59,660 --> 00:44:05,210
at compile time every time I use it and

00:44:02,270 --> 00:44:06,830
then when I make an expression it takes

00:44:05,210 --> 00:44:09,680
that type and it takes into account

00:44:06,830 --> 00:44:11,570
though the maximum the range of it and

00:44:09,680 --> 00:44:14,150
it figures out the value of the result

00:44:11,570 --> 00:44:17,930
so I'm keeping track of a lot of stuff

00:44:14,150 --> 00:44:19,310
here and whoa let's go for broke so in

00:44:17,930 --> 00:44:21,800
this case

00:44:19,310 --> 00:44:23,630
I've what have I done here let's have a

00:44:21,800 --> 00:44:31,640
look

00:44:23,630 --> 00:44:34,430
I created let's let's finish this well I

00:44:31,640 --> 00:44:35,990
think here I skipped a slide or I was

00:44:34,430 --> 00:44:38,870
worried about putting too much in but

00:44:35,990 --> 00:44:41,300
anyway what you can see here is these

00:44:38,870 --> 00:44:43,760
are our state variables which control

00:44:41,300 --> 00:44:46,100
where we are in the algorithm it's the

00:44:43,760 --> 00:44:47,960
number of step we're on the width of the

00:44:46,100 --> 00:44:52,910
steps the position of the stepper motor

00:44:47,960 --> 00:44:54,890
the which phase winding we're in and so

00:44:52,910 --> 00:44:56,900
we I created types for each one of those

00:44:54,890 --> 00:44:59,630
things for example the phase index

00:44:56,900 --> 00:45:02,060
around the the rotor in this case it's

00:44:59,630 --> 00:45:07,040
only four so I said that's a variable

00:45:02,060 --> 00:45:09,440
from zero to three and the pulse width

00:45:07,040 --> 00:45:13,010
is a maximum I forget what it is and the

00:45:09,440 --> 00:45:20,630
number of steps is a maximum of 50,000

00:45:13,010 --> 00:45:25,850
so now when I do all the the expressions

00:45:20,630 --> 00:45:29,900
in here to with these variables they're

00:45:25,850 --> 00:45:31,760
automatically getting checked and and I

00:45:29,900 --> 00:45:35,870
know that they're that well they're

00:45:31,760 --> 00:45:38,270
getting checked on the desktop and the

00:45:35,870 --> 00:45:39,590
other thing that yeah and that's so

00:45:38,270 --> 00:45:42,050
that's what that's what's happening here

00:45:39,590 --> 00:45:44,030
I'm kind of overload I'm inserting into

00:45:42,050 --> 00:45:46,160
my program a lot more information about

00:45:44,030 --> 00:45:47,870
the variables that I mean I inserted for

00:45:46,160 --> 00:45:50,480
each variable the range which is the

00:45:47,870 --> 00:45:52,460
legal range for that it's costing a

00:45:50,480 --> 00:45:56,480
little bit at compile time but no more

00:45:52,460 --> 00:46:00,380
extra runtime another thing we've done

00:45:56,480 --> 00:46:05,300
is I've taken the liberty of taking mr.

00:46:00,380 --> 00:46:08,780
Austin's program and I've I've just

00:46:05,300 --> 00:46:13,100
rewritten the the main guts of it here

00:46:08,780 --> 00:46:17,830
so that this expression here is exactly

00:46:13,100 --> 00:46:21,080
the same expression equation number 12

00:46:17,830 --> 00:46:24,200
exactly transcripted so I know it's

00:46:21,080 --> 00:46:26,780
right because I haven't had to in my

00:46:24,200 --> 00:46:29,720
brain shuffle stuff around and convince

00:46:26,780 --> 00:46:32,480
myself that what I ended up with is the

00:46:29,720 --> 00:46:37,310
same as what he started with so

00:46:32,480 --> 00:46:40,670
I've I've made my program replicate the

00:46:37,310 --> 00:46:42,980
algorithm is he defined it now the boss

00:46:40,670 --> 00:46:46,000
comes along or something blows up or

00:46:42,980 --> 00:46:49,130
there's a self-driving car crash or

00:46:46,000 --> 00:46:52,100
whatever and the lawyers come to me I

00:46:49,130 --> 00:46:54,140
say here's here's the algorithm we used

00:46:52,100 --> 00:46:57,109
and here's the code we use to implement

00:46:54,140 --> 00:46:59,930
it oh and by the way we've used a safe

00:46:57,109 --> 00:47:02,630
numeric library so I know that this code

00:46:59,930 --> 00:47:04,670
implements that algorithm we have a

00:47:02,630 --> 00:47:07,160
chain of responsibility that we can

00:47:04,670 --> 00:47:09,320
defend now as a practical matter that's

00:47:07,160 --> 00:47:14,060
never gonna happen because when there's

00:47:09,320 --> 00:47:17,030
a disaster everybody makes sure that

00:47:14,060 --> 00:47:19,250
they're not anywhere in the area and the

00:47:17,030 --> 00:47:21,350
whole and all of these really bad cases

00:47:19,250 --> 00:47:23,390
nobody is personally nobody's ever

00:47:21,350 --> 00:47:25,880
gotten fired nobody's ever been named

00:47:23,390 --> 00:47:27,619
nobody's ever actually been blamed so

00:47:25,880 --> 00:47:31,880
this is actually just a hypothetical

00:47:27,619 --> 00:47:35,780
concern but anyway it is nice to know

00:47:31,880 --> 00:47:37,880
that you can prove that your stuff works

00:47:35,780 --> 00:47:42,250
it's and you know and this is not by

00:47:37,880 --> 00:47:45,350
testing this is by this is by

00:47:42,250 --> 00:47:47,960
observation and those things that we can

00:47:45,350 --> 00:47:49,820
observe for example knowing that there's

00:47:47,960 --> 00:47:52,460
no overflows or whatever we're proving

00:47:49,820 --> 00:48:01,910
in a different way with a C++ template

00:47:52,460 --> 00:48:03,560
metaprogramming so here's here's what I

00:48:01,910 --> 00:48:05,570
just described here's here's our

00:48:03,560 --> 00:48:07,010
original equations and you can see how I

00:48:05,570 --> 00:48:13,550
transcribe them you can double check

00:48:07,010 --> 00:48:16,100
them yourself that it's it's it's if we

00:48:13,550 --> 00:48:19,369
know that the arithmetic is correct we

00:48:16,100 --> 00:48:21,950
can verify that that this mirrors the

00:48:19,369 --> 00:48:23,750
formula that's all I'm saying here on

00:48:21,950 --> 00:48:27,170
this previous setup there was no way to

00:48:23,750 --> 00:48:29,180
do that and the interesting thing is

00:48:27,170 --> 00:48:31,130
this doesn't take extra time if we look

00:48:29,180 --> 00:48:32,420
at the amount of operations in here

00:48:31,130 --> 00:48:34,400
multiplying by two

00:48:32,420 --> 00:48:37,940
that's one machine instructions a shift

00:48:34,400 --> 00:48:40,600
here we divide we we take a four and we

00:48:37,940 --> 00:48:43,130
we multiply it by the the current step

00:48:40,600 --> 00:48:45,170
that's that's a shift to two bits

00:48:43,130 --> 00:48:46,130
that's one might one instruction as well

00:48:45,170 --> 00:48:47,690
we

00:48:46,130 --> 00:48:50,359
incremented by one that's one

00:48:47,690 --> 00:48:52,759
instruction the only and then on the

00:48:50,359 --> 00:48:54,440
numerator we have taken the current step

00:48:52,759 --> 00:48:56,809
size and multiplying it by two

00:48:54,440 --> 00:48:58,400
that's another shift to the left so

00:48:56,809 --> 00:49:00,230
right now we're going up into like four

00:48:58,400 --> 00:49:03,410
machine instructions and this is on a

00:49:00,230 --> 00:49:07,099
16-bit processor so hey we're golden

00:49:03,410 --> 00:49:09,529
here the only guy that is really a

00:49:07,099 --> 00:49:11,750
possibility that create a problem is

00:49:09,529 --> 00:49:14,599
that that's a long integer division on

00:49:11,750 --> 00:49:17,630
this machine there is no such thing as

00:49:14,599 --> 00:49:19,430
implementing the subroutine so if you're

00:49:17,630 --> 00:49:21,980
worried about time in this whole

00:49:19,430 --> 00:49:24,529
operation that's the only thing you have

00:49:21,980 --> 00:49:28,430
to worry about everything else is just a

00:49:24,529 --> 00:49:30,230
waste of time to think about and we've

00:49:28,430 --> 00:49:33,440
narrowed it in his original algorithm

00:49:30,230 --> 00:49:36,500
specified the same thing one long

00:49:33,440 --> 00:49:38,299
division in each interrupt that's

00:49:36,500 --> 00:49:41,089
exactly what we've got we're no worse

00:49:38,299 --> 00:49:42,980
off except for the fact that we have

00:49:41,089 --> 00:49:45,019
something that we can understand and

00:49:42,980 --> 00:49:53,180
probably even explain to them to the

00:49:45,019 --> 00:49:56,480
manager maybe okay so here's that here's

00:49:53,180 --> 00:50:01,609
the strategy to minimize the cost time

00:49:56,480 --> 00:50:04,670
the the the checking that occurs we take

00:50:01,609 --> 00:50:06,470
our code we run it we we do what we've

00:50:04,670 --> 00:50:08,240
done and now we got to the point where

00:50:06,470 --> 00:50:12,740
it's running and somebody says you know

00:50:08,240 --> 00:50:15,259
how much are we spending on how do we

00:50:12,740 --> 00:50:18,410
really know it never fails or what how

00:50:15,259 --> 00:50:22,309
do we do with a measure the amount of

00:50:18,410 --> 00:50:24,829
time wasted in runtime so it all the all

00:50:22,309 --> 00:50:28,009
the things what we do is every place

00:50:24,829 --> 00:50:30,410
we're using the default exception policy

00:50:28,009 --> 00:50:31,849
which is to throw an exception we say no

00:50:30,410 --> 00:50:35,029
we're going to replace that with the

00:50:31,849 --> 00:50:36,650
trap and that means any time it has to

00:50:35,029 --> 00:50:38,779
do any checking it might call an

00:50:36,650 --> 00:50:40,819
exception at that point it fails the

00:50:38,779 --> 00:50:42,680
compile time because we've said that

00:50:40,819 --> 00:50:45,410
that exception function is not going to

00:50:42,680 --> 00:50:48,079
be visible so you'll get a syntax error

00:50:45,410 --> 00:50:50,569
at every point in the program where it

00:50:48,079 --> 00:50:53,089
might possibly throw an exception in

00:50:50,569 --> 00:50:57,710
this particular program it comes up in

00:50:53,089 --> 00:50:59,400
seven statements so I know that those

00:50:57,710 --> 00:51:03,660
seven statements is

00:50:59,400 --> 00:51:04,980
possible that there could be i if i'm

00:51:03,660 --> 00:51:07,020
wearing on a desktop it'll do the

00:51:04,980 --> 00:51:08,970
checking if i download it to the target

00:51:07,020 --> 00:51:12,720
it's possible that there might be an

00:51:08,970 --> 00:51:16,079
undetected error so our original goal to

00:51:12,720 --> 00:51:18,869
eliminate all the positive error turns

00:51:16,079 --> 00:51:22,680
out that it hasn't been realized

00:51:18,869 --> 00:51:25,589
we've just reduced it to seven instances

00:51:22,680 --> 00:51:29,339
in this particular example it perhaps

00:51:25,589 --> 00:51:33,569
with my more work it might it might be

00:51:29,339 --> 00:51:35,520
possible but the fact is when you have a

00:51:33,569 --> 00:51:38,460
situation and this is a interesting

00:51:35,520 --> 00:51:40,470
algorithm we have C the next C is equal

00:51:38,460 --> 00:51:44,730
to the last C times some arithmetic

00:51:40,470 --> 00:51:47,430
stuff so what when I depend on my range

00:51:44,730 --> 00:51:50,250
of arithmetic to predict the range of

00:51:47,430 --> 00:51:52,230
the next value but since it just turns

00:51:50,250 --> 00:51:54,569
out that you you can't increment

00:51:52,230 --> 00:51:56,430
something because the the the range of

00:51:54,569 --> 00:52:00,809
the result is always going to be the

00:51:56,430 --> 00:52:01,410
range of the operand and so it's hard to

00:52:00,809 --> 00:52:04,859
explain

00:52:01,410 --> 00:52:07,799
so but the fact is that there's still a

00:52:04,859 --> 00:52:10,230
little bit left for us to do as far as

00:52:07,799 --> 00:52:14,279
very verifying and guaranteeing that

00:52:10,230 --> 00:52:17,039
this cannot fail but instead of the

00:52:14,279 --> 00:52:20,579
whole program with well it's now it's up

00:52:17,039 --> 00:52:24,900
to like 180 lines we got seven lines to

00:52:20,579 --> 00:52:27,750
check and by the way when you start

00:52:24,900 --> 00:52:30,150
doing this you end up discovering all

00:52:27,750 --> 00:52:35,299
the stuff in your program was going on

00:52:30,150 --> 00:52:40,680
that you that you took for granted so

00:52:35,299 --> 00:52:43,770
that's the overall strategy we we fix it

00:52:40,680 --> 00:52:45,599
so we run it on the desktop we we change

00:52:43,770 --> 00:52:49,349
all the types so that there make the

00:52:45,599 --> 00:52:53,309
minimum size we run our tests we think

00:52:49,349 --> 00:52:55,470
we got it we our test pass we impose we

00:52:53,309 --> 00:52:58,619
change the exception policy to a trap

00:52:55,470 --> 00:53:00,990
instead of a throw and we discover that

00:52:58,619 --> 00:53:03,720
that here are some cases our test did

00:53:00,990 --> 00:53:05,490
not catch and we have to determine how

00:53:03,720 --> 00:53:08,099
we're going to deal with them but here

00:53:05,490 --> 00:53:11,220
at least we have regardless size of the

00:53:08,099 --> 00:53:13,350
program we've got a manageable task it

00:53:11,220 --> 00:53:15,810
and it may be

00:53:13,350 --> 00:53:20,880
in the future that a number of these

00:53:15,810 --> 00:53:24,960
will also be addressed but for now I'm

00:53:20,880 --> 00:53:26,940
kind of done yeah oh yeah and here's the

00:53:24,960 --> 00:53:33,840
final result resulting program that we

00:53:26,940 --> 00:53:36,960
have it it has it it uses our custom

00:53:33,840 --> 00:53:39,390
types which are really aliases for safe

00:53:36,960 --> 00:53:42,210
integers with specific ranges it

00:53:39,390 --> 00:53:45,030
surrounds all the literal values with

00:53:42,210 --> 00:53:47,580
basically that word literal so that the

00:53:45,030 --> 00:53:50,580
compiler knows a compile time their

00:53:47,580 --> 00:53:53,550
range in the future I believe that this

00:53:50,580 --> 00:53:59,160
won't be necessary because I think C++

00:53:53,550 --> 00:54:02,970
17 has a new wrinkle on the Const expert

00:53:59,160 --> 00:54:05,060
stuff that it may make it this whole

00:54:02,970 --> 00:54:09,210
concept of specifying literal

00:54:05,060 --> 00:54:11,670
unnecessary we refactor the code so it's

00:54:09,210 --> 00:54:15,780
easier to understand and verify and

00:54:11,670 --> 00:54:19,250
we've seen how we've done it and so here

00:54:15,780 --> 00:54:21,800
we come up with the way our code looks

00:54:19,250 --> 00:54:25,620
this is something we can walk through

00:54:21,800 --> 00:54:27,870
and understand and also know that if it

00:54:25,620 --> 00:54:29,100
looks like arithmetic here it's going to

00:54:27,870 --> 00:54:36,150
look like arithmetic when you actually

00:54:29,100 --> 00:54:38,040
do it and let's have a look oh and

00:54:36,150 --> 00:54:41,400
that's our code that's the whole thing

00:54:38,040 --> 00:54:43,530
the run this motor run is where you set

00:54:41,400 --> 00:54:45,690
the new position and basically all that

00:54:43,530 --> 00:54:47,520
does is set some variables and those

00:54:45,690 --> 00:54:50,160
variables also check to make sure you

00:54:47,520 --> 00:54:52,890
didn't for example set a position which

00:54:50,160 --> 00:54:55,920
is beyond the the 500 millimeter width

00:54:52,890 --> 00:54:58,020
of the stepper motor because we because

00:54:55,920 --> 00:54:59,730
the range of the stepper motor has the

00:54:58,020 --> 00:55:02,070
limits in it so if you were to by any

00:54:59,730 --> 00:55:03,750
chance do what these guys did hey man

00:55:02,070 --> 00:55:06,360
this is great you know but we need the

00:55:03,750 --> 00:55:08,970
mark 2.0 it's just the same it just has

00:55:06,360 --> 00:55:09,330
a longer linear motor how hard can that

00:55:08,970 --> 00:55:11,970
be

00:55:09,330 --> 00:55:13,920
ah okay no problem we put in a new canoe

00:55:11,970 --> 00:55:17,280
constant there and maybe it works maybe

00:55:13,920 --> 00:55:20,190
it doesn't but the thing is we're not

00:55:17,280 --> 00:55:26,210
where we normally are and the normally

00:55:20,190 --> 00:55:26,210
are is plug it in let it fly so

00:55:26,250 --> 00:55:31,109
let's have a little see what I got oh

00:55:28,290 --> 00:55:34,230
and that's the recap okay

00:55:31,109 --> 00:55:39,720
so Wow four minutes that's perfect

00:55:34,230 --> 00:56:02,250
anybody got a question well it's either

00:55:39,720 --> 00:56:08,340
that or shout take your pick okay okay

00:56:02,250 --> 00:56:09,990
the question is would this apply also to

00:56:08,340 --> 00:56:11,730
floating with the whole question with

00:56:09,990 --> 00:56:14,520
the whole issues we just raised and

00:56:11,730 --> 00:56:17,609
apply to floating numbers as well I

00:56:14,520 --> 00:56:20,070
would say the answer is yes the the

00:56:17,609 --> 00:56:23,250
questions that arise are of a very very

00:56:20,070 --> 00:56:25,970
different character but the same problem

00:56:23,250 --> 00:56:28,290
occurs in that we have floating point

00:56:25,970 --> 00:56:31,170
numbers sometimes they give subnormal

00:56:28,290 --> 00:56:34,830
results sometimes we get an an one thing

00:56:31,170 --> 00:56:37,349
here for example if I divide an integer

00:56:34,830 --> 00:56:39,960
by zero it doesn't crack necessarily

00:56:37,349 --> 00:56:43,920
crash the program it throws an exception

00:56:39,960 --> 00:56:45,650
so I can handle it or reset the floating

00:56:43,920 --> 00:56:49,250
point needs that too a lot of

00:56:45,650 --> 00:56:52,410
floating-point is pretty complicated and

00:56:49,250 --> 00:56:54,570
but the same we the same the more

00:56:52,410 --> 00:56:57,030
problems are worse than integers but

00:56:54,570 --> 00:56:59,119
they exist on floating point as well

00:56:57,030 --> 00:57:04,410
and if we want to make programs which

00:56:59,119 --> 00:57:06,300
which drive cars we have to up our game

00:57:04,410 --> 00:57:09,859
and floating point would be part of that

00:57:06,300 --> 00:57:12,030
but given the huge turnout we have today

00:57:09,859 --> 00:57:15,089
you can see it's going to be a while

00:57:12,030 --> 00:57:16,140
before there's demand for that so I'm

00:57:15,089 --> 00:57:18,420
very discouraged

00:57:16,140 --> 00:57:22,230
I'm very disheartened at the future of

00:57:18,420 --> 00:57:26,420
this but that doesn't but I did probably

00:57:22,230 --> 00:57:26,420
pair the talk already so here I am

00:57:26,550 --> 00:57:31,380
I don't know if you've covered this and

00:57:28,830 --> 00:57:34,440
I just didn't quite catch it but if I

00:57:31,380 --> 00:57:37,950
have a bounded range from say 0 to 15

00:57:34,440 --> 00:57:39,870
and a bounded range from 20 to 30 and I

00:57:37,950 --> 00:57:41,280
add them together what's the result of

00:57:39,870 --> 00:57:45,360
that operation

00:57:41,280 --> 00:57:47,640
do the math you take the minimum from

00:57:45,360 --> 00:57:51,120
both sides that add them up and it would

00:57:47,640 --> 00:57:54,870
be 20 to 30 and 0 would be the minute we

00:57:51,120 --> 00:57:55,560
thought I'd be 20 and then 20 what was

00:57:54,870 --> 00:57:57,630
the other range

00:57:55,560 --> 00:58:00,420
oh the 1 was 30 and the other was 20 so

00:57:57,630 --> 00:58:04,440
that would be 50 so the resulting value

00:58:00,420 --> 00:58:07,620
would be from 20 to 50 and then that

00:58:04,440 --> 00:58:09,330
since if the expressions more complex

00:58:07,620 --> 00:58:11,610
then of course that would be plugged

00:58:09,330 --> 00:58:14,160
into the next stage and it keeps track

00:58:11,610 --> 00:58:16,620
of this all through the whole process so

00:58:14,160 --> 00:58:18,300
it that's exactly how it works and

00:58:16,620 --> 00:58:20,790
matter of fact you can already figure

00:58:18,300 --> 00:58:24,650
out just from that explanation what this

00:58:20,790 --> 00:58:27,470
does it it intervenes and traps the

00:58:24,650 --> 00:58:30,510
overloads the integer operations it

00:58:27,470 --> 00:58:37,500
calculates the does the range of with

00:58:30,510 --> 00:58:39,780
meticulous a result it's fine it just

00:58:37,500 --> 00:58:43,070
keeps it for the next operation

00:58:39,780 --> 00:58:45,480
so in principle is very simple and you

00:58:43,070 --> 00:58:48,510
hit it right on the head and the range

00:58:45,480 --> 00:58:50,970
is of course can be a negative and pot

00:58:48,510 --> 00:58:54,630
could range can be anything they they're

00:58:50,970 --> 00:58:57,200
because of problems in C++ arithmetic

00:58:54,630 --> 00:59:00,210
for example when I when I add an

00:58:57,200 --> 00:59:02,010
unsigned value to assign value and then

00:59:00,210 --> 00:59:04,530
the though it's not just a question of

00:59:02,010 --> 00:59:07,830
promotion for size it's converting the

00:59:04,530 --> 00:59:09,540
the the sign value to an unsigned value

00:59:07,830 --> 00:59:13,440
but then what if the value is negative

00:59:09,540 --> 00:59:14,940
it it's it's just so murky it's worse

00:59:13,440 --> 00:59:18,240
than floating-point flooding points

00:59:14,940 --> 00:59:20,070
pretty bad too but the integer it's it's

00:59:18,240 --> 00:59:23,760
worse but you're you have it right on

00:59:20,070 --> 00:59:27,060
the head here that the it does exactly

00:59:23,760 --> 00:59:30,780
how you do it by hand it just does it at

00:59:27,060 --> 00:59:32,190
compile time by the way if if you didn't

00:59:30,780 --> 00:59:33,750
have a safe numeric library and you want

00:59:32,190 --> 00:59:35,970
something like this and you're really

00:59:33,750 --> 00:59:37,950
serious about not having an error of

00:59:35,970 --> 00:59:40,530
this nature you have to do the same

00:59:37,950 --> 00:59:41,940
calculations by hand to know that

00:59:40,530 --> 00:59:44,940
that intermediate variable which you

00:59:41,940 --> 00:59:48,600
selected is it's actually not gonna give

00:59:44,940 --> 00:59:51,840
you back the wrong result so it does if

00:59:48,600 --> 00:59:53,850
you think about it everybody should be

00:59:51,840 --> 00:59:55,740
doing it matter of fact and if they're

00:59:53,850 --> 00:59:57,030
they're not because if they were doing

00:59:55,740 --> 01:00:33,750
it by hand they'd be sitting here right

00:59:57,030 --> 01:00:37,440
now okay well let's let's divide that

01:00:33,750 --> 01:00:40,170
into a at least the first part is a real

01:00:37,440 --> 01:00:40,830
simple question if you're reading input

01:00:40,170 --> 01:00:42,810
from the user

01:00:40,830 --> 01:00:44,940
we all know you're supposed to check it

01:00:42,810 --> 01:00:48,030
and of course we all know that a lot of

01:00:44,940 --> 01:00:50,130
times that doesn't happen because it's

01:00:48,030 --> 01:00:51,960
coming from some other profs some some

01:00:50,130 --> 01:00:53,340
BS excuse you know it's a big pain you

01:00:51,960 --> 01:00:55,950
know and then you have to deal with the

01:00:53,340 --> 01:00:58,320
error and whatever so but in fact if

01:00:55,950 --> 01:01:02,010
you're using the safe numeric you can't

01:00:58,320 --> 01:01:04,290
avoid that if you read a safe numeric

01:01:02,010 --> 01:01:07,380
value from a stream it's absolutely

01:01:04,290 --> 01:01:10,680
guaranteed that before it loads that

01:01:07,380 --> 01:01:12,390
integer it fits and actually one of the

01:01:10,680 --> 01:01:15,240
very first slides show that is one of

01:01:12,390 --> 01:01:17,580
the examples now I didn't understand

01:01:15,240 --> 01:01:20,720
your other question so let's go to the

01:01:17,580 --> 01:01:20,720
next guy and then we'll come back

01:01:49,750 --> 01:01:55,180
okay okay that that's questions got AB

01:01:53,260 --> 01:01:57,760
like about four things in it so let's

01:01:55,180 --> 01:02:00,400
start off one by one when you mix this

01:01:57,760 --> 01:02:02,829
with regular integers as you would be if

01:02:00,400 --> 01:02:05,079
you were using another library no so the

01:02:02,829 --> 01:02:06,789
question is what happens first question

01:02:05,079 --> 01:02:11,440
is what happens if you mix it with other

01:02:06,789 --> 01:02:14,109
integers with normal ones right and what

01:02:11,440 --> 01:02:17,230
it does is it does the conversion that

01:02:14,109 --> 01:02:19,420
when it builds the expression it does

01:02:17,230 --> 01:02:22,839
the conversion into safe integers so

01:02:19,420 --> 01:02:25,750
that everything is checked so and then

01:02:22,839 --> 01:02:29,950
if you want to take an integer out a raw

01:02:25,750 --> 01:02:32,109
integer it will take the value and make

01:02:29,950 --> 01:02:34,000
sure that it verifies in the target it

01:02:32,109 --> 01:02:35,920
works so for example if I do a

01:02:34,000 --> 01:02:38,260
complicated expression using safe

01:02:35,920 --> 01:02:40,839
integers and I pass it to some regular

01:02:38,260 --> 01:02:42,039
values well take the values turn into

01:02:40,839 --> 01:02:44,950
say safe integers

01:02:42,039 --> 01:02:47,829
do the math take the result and then

01:02:44,950 --> 01:02:50,619
turn it back into the final result which

01:02:47,829 --> 01:02:52,539
is not a safe integer but make sure that

01:02:50,619 --> 01:02:54,849
it doesn't make a mistake when a trunk

01:02:52,539 --> 01:02:57,789
when it fits it in there so that's the

01:02:54,849 --> 01:03:01,380
first question was how you combine this

01:02:57,789 --> 01:03:04,240
with regular integers that's that answer

01:03:01,380 --> 01:03:12,190
okay now remind me what the second

01:03:04,240 --> 01:03:15,150
question was okay the question is are

01:03:12,190 --> 01:03:19,510
you willing to provide a default value

01:03:15,150 --> 01:03:23,170
the I you have the ability to specify

01:03:19,510 --> 01:03:25,180
your own exception policy and I don't

01:03:23,170 --> 01:03:28,450
know if that's sufficiently rich enough

01:03:25,180 --> 01:03:30,910
I haven't investigated in principle you

01:03:28,450 --> 01:03:32,740
can in it what it does is it calls your

01:03:30,910 --> 01:03:36,840
function that you specify that's what

01:03:32,740 --> 01:03:40,970
the policy does now is that is the

01:03:36,840 --> 01:03:45,750
the surface of that rich enough to

01:03:40,970 --> 01:03:49,710
create a bounding or a truncating thing

01:03:45,750 --> 01:03:50,820
I don't know I'd have to look so that's

01:03:49,710 --> 01:04:11,130
one question and it was your other

01:03:50,820 --> 01:04:13,200
question again okay the question is if

01:04:11,130 --> 01:04:15,330
you had an NPI system which is really

01:04:13,200 --> 01:04:17,040
complex and passing data around how

01:04:15,330 --> 01:04:20,730
would you use this is that a fairy

01:04:17,040 --> 01:04:22,470
rendition of it and the question is you

01:04:20,730 --> 01:04:24,660
use it the way you whatever however you

01:04:22,470 --> 01:04:26,850
use an integer now is how would you you

01:04:24,660 --> 01:04:28,620
would use it then that's that's the

01:04:26,850 --> 01:04:30,570
simple answer it all comes down to

01:04:28,620 --> 01:04:34,050
original arithmetic integer arithmetic

01:04:30,570 --> 01:04:35,820
and in that MPI system you might have

01:04:34,050 --> 01:04:40,200
stuff user you're afraid might overflow

01:04:35,820 --> 01:04:42,090
or you know that we and we anticipated

01:04:40,200 --> 01:04:43,350
thirty-two thousand processors and some

01:04:42,090 --> 01:04:46,320
guy comes along with thirty three

01:04:43,350 --> 01:04:48,510
thousand and now it's the same problem

01:04:46,320 --> 01:04:51,660
it's got nothing to it sits at a much

01:04:48,510 --> 01:04:53,790
lower level when you define your integer

01:04:51,660 --> 01:04:57,090
arithmetic in your arithmetic types you

01:04:53,790 --> 01:04:58,740
would specify the limits and where those

01:04:57,090 --> 01:05:03,150
limits come from or what the related to

01:04:58,740 --> 01:05:06,060
not am not important anymore right in

01:05:03,150 --> 01:05:11,580
other words this doesn't fix your app it

01:05:06,060 --> 01:05:14,820
fixes your integer arithmetic okay that

01:05:11,580 --> 01:05:19,170
sounds like we have no more questions

01:05:14,820 --> 01:05:21,000
yeah well thank you for coming remember

01:05:19,170 --> 01:05:23,820
you guys heard it here first go forth

01:05:21,000 --> 01:05:25,900
upon the world and new you know now what

01:05:23,820 --> 01:05:29,699
no one else knows

01:05:25,900 --> 01:05:29,699

YouTube URL: https://www.youtube.com/watch?v=93Cjg42bGEw


