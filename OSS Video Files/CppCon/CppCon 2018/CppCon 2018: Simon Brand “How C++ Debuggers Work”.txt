Title: CppCon 2018: Simon Brand “How C++ Debuggers Work”
Publication date: 2018-10-19
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Debuggers are one of the most important tools in the belt of any developer, but they are often seen as a magic black box. This is compounded by the lack of available literature, especially when compared to other toolchain components like compilers. This talk aims to demystify debuggers by showing how the utilities you use every day actually work. 

Topics which will be covered include debug information and object file formats, breakpoints, stepping, register and memory manipulation, stack unwinding, multi-threaded applications, and expression evaluation. x86 Linux platforms will be used for demonstrative purposes, but the general concepts are platform independent.
— 
Simon Brand, Microsoft
C++ Developer Advocate

Simon is a C++ Developer Advocate at Microsoft. He turns into a metaprogramming fiend every full moon, when he can be found bringing compilers to their knees with template errors and debating undefined behaviour online. He co-organises the Edinburgh C++ user group and contributes to various programming standards bodies.

Outside of programming, he enjoys experimental films, homebrewing, and board games.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,250 --> 00:00:02,810
- Hi everyone, my name is Simon

00:00:02,810 --> 00:00:05,210
and if you're here how C++ Debuggers work

00:00:05,210 --> 00:00:07,470
then you're in the right room.

00:00:07,470 --> 00:00:10,400
Before I get started, the Microsoft we do have

00:00:10,400 --> 00:00:12,640
a survey which would be great if you could complete

00:00:12,640 --> 00:00:16,853
and you can win an Xbox One, woo.

00:00:18,220 --> 00:00:20,680
That's half hearted but I'll let away with it.

00:00:20,680 --> 00:00:23,560
Okay so this is a bit of my background in debuggers

00:00:23,560 --> 00:00:25,080
so you know that I actually kind of

00:00:25,080 --> 00:00:27,170
understand vaguely what I'm talking about.

00:00:27,170 --> 00:00:29,348
So I used to work for a great company in Edinburgh

00:00:29,348 --> 00:00:32,380
called Codeplay literally until this week.

00:00:32,380 --> 00:00:34,180
And there I worked a lot on debuggers

00:00:34,180 --> 00:00:37,014
so I worked on a debugger for HSA

00:00:37,014 --> 00:00:39,710
which is like a low level standard

00:00:39,710 --> 00:00:42,070
for heterogeneous systems.

00:00:42,070 --> 00:00:45,930
We have gpu's and dsp's and tiny image processors

00:00:45,930 --> 00:00:46,763
and whatever.

00:00:47,800 --> 00:00:50,200
I also worked a lot with open cl debuggers

00:00:50,200 --> 00:00:53,120
which is another kind of similar standard

00:00:55,176 --> 00:00:58,270
and I worked a lot with LLVM's debugger, lldb.

00:00:58,270 --> 00:01:00,480
There are few people at this conference

00:01:00,480 --> 00:01:01,760
who actually work on lldb

00:01:01,760 --> 00:01:03,200
so if you'd like to talk to them

00:01:03,200 --> 00:01:04,993
come see me and I'll introduce you.

00:01:07,460 --> 00:01:11,701
So a bit about what I'm talking about here.

00:01:11,701 --> 00:01:15,760
Presumably we all have used a debugger at some point.

00:01:15,760 --> 00:01:18,390
Hands? Everyone use debugger?

00:01:18,390 --> 00:01:21,313
That's the right number of hands, I'm in the right room.

00:01:22,937 --> 00:01:24,363
Anyone know what this is?

00:01:27,200 --> 00:01:29,323
The bug, yes. This is the bug.

00:01:30,340 --> 00:01:31,720
Grace Hoppers bug, yes.

00:01:31,720 --> 00:01:33,570
Anyone know what machine it was from?

00:01:36,890 --> 00:01:41,580
No, I believe it was Harvard's Mark 2 calculator.

00:01:41,580 --> 00:01:43,223
They found literally a moth.

00:01:44,160 --> 00:01:46,663
Our debuggers don't tend to look like this.

00:01:47,560 --> 00:01:50,600
If you're doing this then come speak to me after.

00:01:50,600 --> 00:01:51,800
I want to hear about it.

00:01:53,449 --> 00:01:55,860
Our debuggers sometimes look like this.

00:01:55,860 --> 00:01:58,333
Which is LDB running inside a terminal.

00:01:59,700 --> 00:02:01,340
Sometimes they'll look like this

00:02:01,340 --> 00:02:04,103
which is GDB running inside Emac's.

00:02:04,990 --> 00:02:06,753
Yup, some people like that.

00:02:08,630 --> 00:02:12,020
Some people might use the LDB cursor interface,

00:02:12,020 --> 00:02:12,873
it's quite nice.

00:02:14,040 --> 00:02:15,603
Visual studio debugger.

00:02:18,930 --> 00:02:22,060
My definition is, I definitely did not steal this

00:02:22,060 --> 00:02:23,163
from Wikipedia.

00:02:24,360 --> 00:02:26,130
An application which is used to test

00:02:26,130 --> 00:02:28,493
and debug other applications.

00:02:29,540 --> 00:02:32,250
And the most common actions you will use

00:02:32,250 --> 00:02:35,333
with a debugger are breakpoints,

00:02:36,210 --> 00:02:39,150
saying I want to stop here at this line of code

00:02:39,150 --> 00:02:40,900
or I want to stop at this function.

00:02:41,820 --> 00:02:46,820
You could step around, could be just instructions

00:02:46,940 --> 00:02:50,163
could be jumping over functions, jumping into functions.

00:02:51,630 --> 00:02:53,980
You might want to do expression evaluation.

00:02:53,980 --> 00:02:56,723
What is the value of X right now.

00:02:58,830 --> 00:03:01,490
Or you might want to say, how did I get here.

00:03:01,490 --> 00:03:02,773
What's my call stack.

00:03:03,860 --> 00:03:06,980
So these are the main things I'm going to talk about

00:03:06,980 --> 00:03:09,293
and a little bit more towards the end as well.

00:03:11,810 --> 00:03:13,440
A bit of an introduction to the platform

00:03:13,440 --> 00:03:14,760
I'm going to talk about.

00:03:14,760 --> 00:03:18,220
So I will be focusing on Linux system's

00:03:19,160 --> 00:03:24,160
on X86_64 with ELF as a binary format

00:03:24,280 --> 00:03:25,900
you don't need to know what that is yet

00:03:25,900 --> 00:03:28,490
similar for DWARF, which is debug format

00:03:28,490 --> 00:03:32,943
and using ptrace as the main interface library.

00:03:33,880 --> 00:03:35,680
So most of the concepts which I will talk about

00:03:35,680 --> 00:03:39,887
are transferrable to other platforms and systems

00:03:39,887 --> 00:03:42,350
obviously the function calls will change

00:03:42,350 --> 00:03:44,950
you might be working at a different level of abstraction

00:03:44,950 --> 00:03:48,363
but the kind of general concepts will apply.

00:03:51,600 --> 00:03:56,600
So this is a very nice look at what ELF is.

00:03:57,130 --> 00:03:59,550
There is an even more detailed version of this

00:03:59,550 --> 00:04:01,400
but it looks terrible on slides.

00:04:01,400 --> 00:04:06,400
So go to this Ange Albertini's website if you'd like to see

00:04:09,440 --> 00:04:10,960
an even better introduction.

00:04:10,960 --> 00:04:14,080
But the basic idea is that it's a binary format

00:04:14,080 --> 00:04:17,940
for executable's and objects.

00:04:17,940 --> 00:04:19,570
So it consists of a header

00:04:19,570 --> 00:04:22,690
which tells you about what this executable is

00:04:23,625 --> 00:04:26,870
and what machine am I compiled for

00:04:28,170 --> 00:04:32,613
and then a bunch of code which is separated into sections.

00:04:34,490 --> 00:04:36,460
So you don't need to know a whole lot about ELF

00:04:36,460 --> 00:04:40,510
but this the kind of main format for Linux executable's

00:04:40,510 --> 00:04:42,560
so it's useful to learn a little about it

00:04:42,560 --> 00:04:45,193
if you want to actually work on debuggers.

00:04:48,090 --> 00:04:51,939
DWARF, you noticed the funny joke ELF, DWARF

00:04:51,939 --> 00:04:53,490
Knut people are hilarious

00:04:54,900 --> 00:04:57,547
and Dwarf mostly consists of die's

00:04:57,547 --> 00:05:01,720
not like this, they look like this.

00:05:01,720 --> 00:05:03,840
This is a Dwarf information entry

00:05:04,890 --> 00:05:08,360
and these are used to describe the entirety

00:05:08,360 --> 00:05:11,230
of your programs from compilation units

00:05:11,230 --> 00:05:12,430
which is what we have here

00:05:12,430 --> 00:05:15,533
it's like files with all the includes already in.

00:05:17,110 --> 00:05:20,270
Functions, variables, types,

00:05:20,270 --> 00:05:21,750
pretty much everything you can think of

00:05:21,750 --> 00:05:25,143
can be expressed someway in Dwarf information.

00:05:26,120 --> 00:05:28,580
And this is a standard, you can go and download it

00:05:28,580 --> 00:05:29,540
you can have a read.

00:05:29,540 --> 00:05:31,720
It's actually for a programming standard

00:05:31,720 --> 00:05:33,090
it's quite understandable.

00:05:33,090 --> 00:05:34,780
So I would recommend going and having a look

00:05:34,780 --> 00:05:35,880
if you are interested.

00:05:37,200 --> 00:05:40,760
This is an example of a compilation unit die.

00:05:40,760 --> 00:05:44,510
So it tells you like that was compiled by clang 3.9.1.

00:05:44,510 --> 00:05:48,470
This is the file that is compiled for C++

00:05:48,470 --> 00:05:51,010
you can get quite a lot of information about your programs

00:05:51,010 --> 00:05:52,800
just by looking at these.

00:05:52,800 --> 00:05:55,240
And this is what the debugger will be consuming

00:05:55,240 --> 00:05:58,220
when it's trying to understand everything

00:05:58,220 --> 00:05:59,170
about your program.

00:06:00,227 --> 00:06:03,276
Debuggers can do a lot of things without Dwarf

00:06:03,276 --> 00:06:07,000
just by looking at the Elf file, symbol tables,

00:06:07,000 --> 00:06:08,080
things like that.

00:06:08,080 --> 00:06:10,150
But for any like heavy weight debugging

00:06:10,150 --> 00:06:14,033
you need the Dwarf information.

00:06:15,624 --> 00:06:17,490
So as well as die's like this

00:06:17,490 --> 00:06:19,963
there is line table information.

00:06:20,820 --> 00:06:25,500
So this tells you which lines of my source code

00:06:25,500 --> 00:06:29,693
correspond to which machine code addresses.

00:06:30,990 --> 00:06:33,610
So you'll see that these have the addresses

00:06:33,610 --> 00:06:38,610
on the left hand side and then you have rows and columns

00:06:38,710 --> 00:06:39,923
for your source code.

00:06:41,600 --> 00:06:43,170
And then over on the right hand side

00:06:43,170 --> 00:06:47,200
there's some descriptions which are all in nice acronyms.

00:06:47,200 --> 00:06:52,200
So NS is new statement, prologue end, end text

00:06:52,210 --> 00:06:53,820
the end of the program.

00:06:53,820 --> 00:06:55,760
So this is what the debugger is going to look at

00:06:55,760 --> 00:06:58,840
to try and understand how your source code

00:06:58,840 --> 00:07:00,570
relates to the machine code.

00:07:00,570 --> 00:07:05,570
Not only how your C++, like your representation

00:07:06,710 --> 00:07:08,770
of your program maps to it.

00:07:08,770 --> 00:07:11,303
But also the literal text in the file.

00:07:14,050 --> 00:07:15,207
This is Ptrace.

00:07:16,850 --> 00:07:20,773
Ptrace is, well it's Ptrace.

00:07:21,970 --> 00:07:25,170
Everyone who's worked with debuggers at any time

00:07:25,170 --> 00:07:30,130
if you say Ptrace, their face will just drop.

00:07:31,550 --> 00:07:33,943
That's because this is Ptrace's one function

00:07:33,943 --> 00:07:38,943
you pass it a request, a process ID

00:07:39,498 --> 00:07:42,490
and then an address and data.

00:07:42,490 --> 00:07:44,690
And depending on what this request is

00:07:44,690 --> 00:07:47,490
maybe it ignores these other two.

00:07:47,490 --> 00:07:49,340
Maybe they mean something different

00:07:49,340 --> 00:07:51,490
maybe you just an all pointer all the time.

00:07:52,610 --> 00:07:54,760
So a few things you can do as like say

00:07:54,760 --> 00:07:57,820
I want my debugger to be allowed to trace me.

00:07:57,820 --> 00:07:59,670
I want to read and write memory,

00:07:59,670 --> 00:08:01,523
I want to read and write registers.

00:08:02,470 --> 00:08:06,365
And so you just pass these enum's into this function

00:08:06,365 --> 00:08:09,233
and it will do wildly different things.

00:08:10,640 --> 00:08:15,470
So Ptrace exists, it mostly does its job.

00:08:15,470 --> 00:08:18,653
If you want to read more about it there is a page.

00:08:21,850 --> 00:08:23,223
Breakpoints.

00:08:24,460 --> 00:08:26,880
So breakpoints I think are,

00:08:26,880 --> 00:08:28,775
I mean debuggers in general are quite

00:08:28,775 --> 00:08:31,468
compared to something like compilers

00:08:31,468 --> 00:08:35,173
people don't know a lot about how debuggers work.

00:08:36,030 --> 00:08:39,240
Compilers there's tons of books, there are blog posts.

00:08:39,240 --> 00:08:42,420
Most people who can kind of do a little bit of C++

00:08:42,420 --> 00:08:45,500
will have some understanding of how a compiler works, right?

00:08:45,500 --> 00:08:47,707
You get in text, you build an AST,

00:08:48,800 --> 00:08:52,193
maybe you haven't been prepped in representation

00:08:52,193 --> 00:08:53,100
and you get to machine code

00:08:53,100 --> 00:08:55,170
and their number step to get you there.

00:08:55,170 --> 00:08:57,050
But debuggers breakpoints are like

00:08:57,050 --> 00:08:59,886
one of the most fundamental parts

00:08:59,886 --> 00:09:03,420
and people see it as black magic.

00:09:03,420 --> 00:09:05,370
This is some box where I say

00:09:05,370 --> 00:09:09,120
oh holy oracle, please place a breakpoint at line 20

00:09:09,120 --> 00:09:12,420
of this file and by some magic you get

00:09:12,420 --> 00:09:15,380
a breakpoint at the line in that file.

00:09:15,380 --> 00:09:17,380
But they're actually not so complicated.

00:09:18,500 --> 00:09:21,180
So there are two main kinds of breakpoints.

00:09:21,180 --> 00:09:23,733
Hardware breakpoints and Software breakpoints.

00:09:25,640 --> 00:09:28,452
Difference between these two is that hardware breakpoints

00:09:28,452 --> 00:09:31,400
usually have some kind of special registers

00:09:31,400 --> 00:09:33,240
which you're going to write values into

00:09:33,240 --> 00:09:35,750
and the hardware is going to take control

00:09:35,750 --> 00:09:38,400
make sure that when you actually hit those addresses

00:09:38,400 --> 00:09:40,893
that something happens, you get a breakpoint.

00:09:41,970 --> 00:09:44,163
Software breakpoints on the other hand

00:09:44,163 --> 00:09:47,990
you actually take the code which you're executing in memory

00:09:47,990 --> 00:09:52,990
and you're going to modify it so that a breakpoint gets set.

00:09:53,020 --> 00:09:55,620
And we'll see how these both work a little bit more.

00:09:57,300 --> 00:09:59,594
Hardware breakpoints are limited

00:09:59,594 --> 00:10:02,542
because you're not using physical registers.

00:10:02,542 --> 00:10:04,203
You only have so many.

00:10:05,350 --> 00:10:06,910
Whereas software breakpoints

00:10:06,910 --> 00:10:08,790
because you're just dealing with memory,

00:10:08,790 --> 00:10:11,427
it's essentially unlimited, you know,

00:10:11,427 --> 00:10:13,650
apart from however much memory you actually have

00:10:13,650 --> 00:10:14,483
and what not.

00:10:15,629 --> 00:10:18,300
The cool thing about hardware breakpoints

00:10:18,300 --> 00:10:21,920
is that you can set them to break on reading

00:10:21,920 --> 00:10:24,530
or writing or executing an address.

00:10:24,530 --> 00:10:27,970
Where software breakpoints are only on execution.

00:10:27,970 --> 00:10:32,240
So if you want to say, debugger I want to be notified

00:10:32,240 --> 00:10:36,020
every time this address is changed

00:10:36,020 --> 00:10:37,540
which can be really useful if you're trying

00:10:37,540 --> 00:10:41,110
to track down some really weird bugs.

00:10:41,110 --> 00:10:43,873
But you can only really do that with hardware breakpoints.

00:10:44,780 --> 00:10:46,780
Software breakpoints are just execution.

00:10:48,460 --> 00:10:50,434
So I talked briefly about hardware breakpoints

00:10:50,434 --> 00:10:53,090
and we're more going to focus on software ones.

00:10:53,090 --> 00:10:57,190
So in x86, you have four debug registers

00:10:57,190 --> 00:10:59,890
which used to write addresses into these

00:10:59,890 --> 00:11:01,470
and then when you get to that address

00:11:01,470 --> 00:11:04,510
the debugger will get notified

00:11:04,510 --> 00:11:06,710
by means we're going to see in a little bit.

00:11:07,720 --> 00:11:11,920
It has a register which you can read the status of

00:11:11,920 --> 00:11:14,860
and see like what's going on with them

00:11:14,860 --> 00:11:17,760
with all these breakpoints I've set.

00:11:17,760 --> 00:11:19,730
And you have something which you can actually control

00:11:19,730 --> 00:11:23,543
to say I want a break on reading, writing, executing.

00:11:23,543 --> 00:11:26,140
I won't go into much more detail about hardware breakpoints

00:11:26,140 --> 00:11:29,333
especially because they're very hardware specific.

00:11:30,490 --> 00:11:32,970
Software breakpoints on the other hand

00:11:32,970 --> 00:11:35,560
tend to be implemented in very similar ways

00:11:35,560 --> 00:11:36,810
so if you read a debugger

00:11:38,435 --> 00:11:41,320
read the source code for a debugger

00:11:41,320 --> 00:11:43,410
then when you get down to actually setting breakpoints

00:11:43,410 --> 00:11:48,410
it's all very similar on x86 and this is how it works.

00:11:49,560 --> 00:11:51,210
So say we have some assembly code

00:11:52,130 --> 00:11:54,170
This is x86 assembly.

00:11:54,170 --> 00:11:56,420
You don't have to understand what it's doing.

00:11:57,690 --> 00:11:59,810
So on the right we have the assembly

00:11:59,810 --> 00:12:03,570
on the left we have the actual hexadecimal representation

00:12:03,570 --> 00:12:04,813
of these instructions.

00:12:07,570 --> 00:12:11,090
I want to set a breakpoint at this new instruction

00:12:12,241 --> 00:12:16,520
Maybe I know the address of this and I'm explicitly

00:12:16,520 --> 00:12:18,920
telling my debugger set a breakpoint right here.

00:12:19,818 --> 00:12:24,540
What the debugger then does is it takes this first bite

00:12:24,540 --> 00:12:29,370
this ox48 and it's going to set it off to the side

00:12:29,370 --> 00:12:30,733
remember it for later.

00:12:33,010 --> 00:12:36,003
What's then going to do is replace the old value

00:12:36,003 --> 00:12:39,290
with this special ox cc

00:12:40,440 --> 00:12:44,800
and what this is int3 instruction

00:12:44,800 --> 00:12:47,343
and this is going to trigger a software interrupt.

00:12:50,720 --> 00:12:53,760
So if our pc is sitting at the top of the program counter

00:12:54,786 --> 00:12:59,786
we go down, we stop, software interrupt.

00:13:03,170 --> 00:13:04,920
Basic idea is the operating system,

00:13:04,920 --> 00:13:06,915
if you don't know how interrupts work

00:13:06,915 --> 00:13:09,280
the operating system is going to register

00:13:09,280 --> 00:13:11,450
some interrupt handlers.

00:13:11,450 --> 00:13:13,930
And when an interrupt is triggered

00:13:13,930 --> 00:13:18,130
then the handler for that interrupt will be invoked.

00:13:18,130 --> 00:13:21,374
So for int3, which is our one up here

00:13:21,374 --> 00:13:25,890
then the operating system will put into place

00:13:25,890 --> 00:13:28,760
something which will be called for int3

00:13:28,760 --> 00:13:33,270
and on Linux this is the function which gets invoked

00:13:33,270 --> 00:13:35,340
eventually do int3.

00:13:35,340 --> 00:13:37,603
So this is the actual code from the kernel.

00:13:38,870 --> 00:13:42,860
The most important part here is that in the middle of this

00:13:42,860 --> 00:13:47,370
we have our do trap and this sigtrap thing is important

00:13:47,370 --> 00:13:49,433
this is debugger magic.

00:13:51,770 --> 00:13:55,053
So if we look at the man pages for signals

00:13:55,053 --> 00:13:58,483
sigtrap is the trace and breakpoint trap.

00:14:00,650 --> 00:14:03,770
Now a unique signal will get sent to our process

00:14:03,770 --> 00:14:08,173
and our debugger can then say okay we hit a breakpoint.

00:14:09,240 --> 00:14:10,840
And this is how the magic works.

00:14:11,830 --> 00:14:14,230
So I'll show an example of this all put together

00:14:15,330 --> 00:14:18,600
we start off we have our debugger is awaiting input.

00:14:18,600 --> 00:14:20,590
Sitting there waiting for us to type continue

00:14:20,590 --> 00:14:23,263
or breakpoint or whatever.

00:14:24,180 --> 00:14:28,140
Our debuggee is stopped, not doing anything.

00:14:28,140 --> 00:14:30,690
We have set a breakpoint at this second instruction here

00:14:30,690 --> 00:14:33,223
note the cc on the left hand side.

00:14:34,700 --> 00:14:36,720
So what it's going to do is the debugger

00:14:36,720 --> 00:14:39,020
is going to wait for us to do something

00:14:39,020 --> 00:14:40,423
and we type in continue.

00:14:42,321 --> 00:14:43,990
So it's going to continue the debuggee

00:14:43,990 --> 00:14:46,950
and then it's going to wait on a signal

00:14:46,950 --> 00:14:50,220
as it's using waitpid which is a Linux thing.

00:14:50,220 --> 00:14:52,040
This is essentially saying okay

00:14:53,010 --> 00:14:55,120
do nothing until I get a signal and then I'm going

00:14:55,120 --> 00:14:57,620
to wake up and I'm going to do something about it.

00:14:58,890 --> 00:15:01,390
So we continue the debuggee so this is now running

00:15:02,290 --> 00:15:04,240
forget about the debugger for a minute.

00:15:05,180 --> 00:15:09,420
We go down and we hit int3, we stop, software interrupt

00:15:09,420 --> 00:15:13,790
we drop down into our interrupt handler

00:15:13,790 --> 00:15:18,790
which issues a signal, now the debugger is woken up

00:15:19,523 --> 00:15:21,410
because it was waiting on a signal

00:15:22,470 --> 00:15:24,060
now we've got one.

00:15:24,060 --> 00:15:26,280
I got a signal, yay.

00:15:26,280 --> 00:15:28,080
And now there are a bunch of methods

00:15:28,080 --> 00:15:30,058
which we can use to say okay.

00:15:30,058 --> 00:15:34,740
Where am I stopped, where did this signal come from

00:15:34,740 --> 00:15:38,250
and we can report this in some way to the user.

00:15:38,250 --> 00:15:39,550
Does anyone want me to go over that again?

00:15:39,550 --> 00:15:42,533
Because that's all the magic of software breakpoints.

00:16:03,460 --> 00:16:06,340
Yes, the question was about if we have something like this

00:16:06,340 --> 00:16:08,930
continue debuggee and then waitpid

00:16:08,930 --> 00:16:12,417
like what happens if we have the pathological case

00:16:12,417 --> 00:16:17,417
where thread scheduler like preempts us

00:16:18,015 --> 00:16:23,015
right after we call continue debuggee.

00:16:23,035 --> 00:16:26,487
Debuggee runs and we haven't hit our waitpid

00:16:26,487 --> 00:16:27,963
and we miss a signal.

00:16:30,881 --> 00:16:32,340
I honestly cannot remember off the top of my head

00:16:32,340 --> 00:16:34,850
I think it would be possible to miss signals

00:16:34,850 --> 00:16:36,610
with something like this unless you did

00:16:36,610 --> 00:16:40,380
some extra synchronization and I can't remember

00:16:40,380 --> 00:16:42,380
what kind of extra synchronization you would do.

00:16:42,380 --> 00:16:45,304
So there would be methods of doing this

00:16:45,304 --> 00:16:48,383
the overhead may or may not be worth it.

00:16:51,420 --> 00:16:54,593
Source level breakpoints, oh sorry question.

00:17:00,439 --> 00:17:03,000
What's stopping the debuggee from continuing?

00:17:03,000 --> 00:17:06,350
It's the operating system, so this ptrace thing

00:17:06,350 --> 00:17:11,300
is known by the operating system and interacts

00:17:11,300 --> 00:17:12,940
directly with the operating system.

00:17:12,940 --> 00:17:17,940
So when something is halted, it won't be scheduled.

00:17:18,060 --> 00:17:19,550
So the operating system will make sure

00:17:19,550 --> 00:17:21,710
it's not going to run, yup.

00:17:34,550 --> 00:17:37,713
What was the question, sorry?

00:17:39,897 --> 00:17:42,147
Okay good question, I didn't cover that

00:17:42,147 --> 00:17:43,260
but I can go over it.

00:17:43,260 --> 00:17:46,640
So the question was, I talked about earlier

00:17:46,640 --> 00:17:50,400
when the debugger will save out the value

00:17:50,400 --> 00:17:53,309
that was previously in this cc

00:17:53,309 --> 00:17:55,330
and then the question was how,

00:17:55,330 --> 00:18:00,330
when does it get restored back and continue execution.

00:18:00,690 --> 00:18:03,270
So there are few methods to do this

00:18:03,270 --> 00:18:06,570
the most simple is to actually manipulate

00:18:06,570 --> 00:18:09,552
the program counter so you go back over the instruction

00:18:09,552 --> 00:18:14,470
you replace the ox cc with the original bite

00:18:14,470 --> 00:18:18,030
you single step and then you continue execution

00:18:18,030 --> 00:18:19,423
then after you've replaced the breaking point.

00:18:19,423 --> 00:18:24,181
Because you don't want the case where you continue

00:18:24,181 --> 00:18:27,200
and maybe you have a loop and it should

00:18:27,200 --> 00:18:28,620
instantly hit the breakpoint

00:18:29,630 --> 00:18:32,090
and that's actually not, this happens a lot.

00:18:32,090 --> 00:18:35,460
So you want to take the breakpoint off

00:18:35,460 --> 00:18:37,100
put the old value in single step,

00:18:37,100 --> 00:18:39,350
put the breakpoint back on and continue.

00:18:39,350 --> 00:18:41,690
That's the way a lot of debuggers do it.

00:18:41,690 --> 00:18:44,968
Another possible way is actually having some memory

00:18:44,968 --> 00:18:46,633
put off to the side.

00:18:48,020 --> 00:18:53,020
And relocating that instruction into the block

00:18:54,920 --> 00:18:58,435
changing the program counter so that it essentially

00:18:58,435 --> 00:19:01,410
will eventually jump back to the right point.

00:19:01,410 --> 00:19:03,620
And it means you don't have to single step

00:19:03,620 --> 00:19:05,310
and replace the breakpoint.

00:19:05,310 --> 00:19:08,640
I think GDB calls it displaced stepping

00:19:08,640 --> 00:19:11,388
so it's very useful for multi threaded environments

00:19:11,388 --> 00:19:15,320
if you're operating in a context where some threads

00:19:15,320 --> 00:19:17,780
are running and some threads are stopped.

00:19:17,780 --> 00:19:20,744
Does that answer the question?

00:19:20,744 --> 00:19:25,744
Okay, yes.

00:19:45,498 --> 00:19:47,617
That's correct, yes.

00:19:47,617 --> 00:19:49,889
So the question was about the interrupt

00:19:49,889 --> 00:19:53,258
and so the cc, most interrupt instructions

00:19:53,258 --> 00:19:55,560
are not just one bite.

00:19:55,560 --> 00:19:57,760
They're like an interrupt and something else

00:19:57,760 --> 00:19:59,869
but int3 is special because it wants to be used

00:19:59,869 --> 00:20:01,710
for debugging so there's a special

00:20:01,710 --> 00:20:03,600
one bite instruction for it.

00:20:03,600 --> 00:20:07,830
And Linux will register a handler

00:20:07,830 --> 00:20:10,700
in the interrupt vector table and descriptor table

00:20:10,700 --> 00:20:12,808
I can never remember which one's which.

00:20:12,808 --> 00:20:15,153
And that is the do int.

00:20:24,140 --> 00:20:29,140
So the bites after int3, after the ox cc are not touched

00:20:29,330 --> 00:20:33,930
because when we eventually get rid of our breakpoint

00:20:33,930 --> 00:20:36,770
put the ox 48 back, then we want the instruction

00:20:36,770 --> 00:20:39,792
to still be as it was, so they're not touched.

00:20:39,792 --> 00:20:40,625
Yes.

00:20:45,508 --> 00:20:48,750
How does it a single set, well we have slides on that.

00:20:48,750 --> 00:20:50,630
You'll see in a minute.

00:20:50,630 --> 00:20:51,463
Yes.

00:20:54,500 --> 00:20:56,380
When you disable the breakpoint and not delete it

00:20:56,380 --> 00:21:01,380
so one thing is debuggers can just swallow breakpoints.

00:21:01,740 --> 00:21:03,475
So they can just,

00:21:03,475 --> 00:21:06,920
a breakpoint is hit but the debugger continues

00:21:06,920 --> 00:21:08,720
and doesn't tell you about it.

00:21:08,720 --> 00:21:10,573
So it could do that or it could.

00:21:15,670 --> 00:21:18,654
Yes, so in the debugger, the question was

00:21:18,654 --> 00:21:21,490
data structure set aside to remember what's disabled

00:21:21,490 --> 00:21:22,370
and what's deleted.

00:21:22,370 --> 00:21:25,790
And yes, the debugger will have some data structures

00:21:25,790 --> 00:21:29,090
to say okay well the user set this breakpoint

00:21:29,090 --> 00:21:32,480
and currently asked for it to be disabled

00:21:32,480 --> 00:21:34,440
but may want to enable it again later

00:21:34,440 --> 00:21:37,930
so just remember the address and then maybe

00:21:37,930 --> 00:21:40,580
just remove the breakpoint or just swallow

00:21:40,580 --> 00:21:41,680
any ones that come up.

00:21:42,842 --> 00:21:47,842
Is there another question, yes.

00:22:08,670 --> 00:22:12,733
Sorry can you repeat, I didn't quite understand the question

00:22:18,500 --> 00:22:22,510
Yes so, maybe this is a little bit misleading.

00:22:22,510 --> 00:22:24,510
I put the arrow

00:22:31,120 --> 00:22:34,680
I was supposed to have an arrow from the do int up.

00:22:34,680 --> 00:22:35,980
But it got lost somehow.

00:22:35,980 --> 00:22:39,334
But yeah the do int will send a signal to the debuggee

00:22:39,334 --> 00:22:43,361
and the waitpid is waiting for a signal on that process.

00:22:43,361 --> 00:22:46,623
Okay that's the last question for now, I'll take more later.

00:22:48,640 --> 00:22:52,000
Source level breakpoints, very simple example

00:22:52,000 --> 00:22:53,293
we want to break on main.

00:22:54,139 --> 00:22:59,060
So what we do is we look up our Dwarf information

00:22:59,060 --> 00:23:01,637
we find a die with the right name

00:23:01,637 --> 00:23:05,200
and we look at the low pc

00:23:05,200 --> 00:23:07,217
this gives us an address.

00:23:07,217 --> 00:23:09,285
We can then set a breakpoint at this address

00:23:09,285 --> 00:23:13,300
and it all works using what we just talked about.

00:23:13,300 --> 00:23:16,680
In reality, debuggers will skip over the function prologue

00:23:16,680 --> 00:23:19,693
things like that, but this is essentially what it's doing.

00:23:21,020 --> 00:23:25,920
So yeah, going from being able to break point on an address

00:23:25,920 --> 00:23:28,760
to certain breakpoint on a function like this.

00:23:28,760 --> 00:23:30,570
I mean you have to have a Dwarf parcer,

00:23:30,570 --> 00:23:32,423
but it's not a huge step.

00:23:34,570 --> 00:23:37,090
How about we have an overloaded function.

00:23:37,090 --> 00:23:39,229
So most things I've talked about so far have applied

00:23:39,229 --> 00:23:43,789
pretty much to assembly or nothing c++ specific.

00:23:43,789 --> 00:23:47,200
In c++ we can overload functions.

00:23:47,200 --> 00:23:50,220
So what happens if we want to set a breakpoint on just

00:23:50,220 --> 00:23:52,883
do_thing double and not do_thing string.

00:23:54,900 --> 00:23:57,060
So one thing, what's going to be different

00:23:57,060 --> 00:23:59,913
about these two functions when they're compiled?

00:24:01,490 --> 00:24:03,950
Mangling, exactly.

00:24:03,950 --> 00:24:06,320
So do_thing double will be mangled like so

00:24:08,093 --> 00:24:11,493
do_thing string we mangled like this.

00:24:13,890 --> 00:24:15,653
Because c++ is fantastic.

00:24:17,490 --> 00:24:19,900
So what we can do is look for something

00:24:19,900 --> 00:24:21,940
if we want to set on just the double one

00:24:21,940 --> 00:24:24,440
we can mangle the name and then just look

00:24:24,440 --> 00:24:27,070
for something with that linkage name

00:24:27,070 --> 00:24:30,510
look at the low pc, rinse repeat. Same as before.

00:24:30,510 --> 00:24:31,343
Yes, Victor.

00:24:36,590 --> 00:24:39,800
Yes, mangling can depend from compiler to compiler

00:24:39,800 --> 00:24:42,030
so if you're doing, there are other methods to do this

00:24:42,030 --> 00:24:43,940
I just picked a simple one.

00:24:43,940 --> 00:24:46,340
But yeah, this will only work if you knew

00:24:46,340 --> 00:24:48,433
that you're working with the itanium api.

00:24:48,433 --> 00:24:52,293
So if you've compiled something with msvc mangling

00:24:52,293 --> 00:24:55,905
and you tried to do this but mangled

00:24:55,905 --> 00:24:58,740
your debugger mangled using itanium abi

00:24:58,740 --> 00:25:00,853
then they would miss.

00:25:07,130 --> 00:25:10,270
Yes, so on Linux, Itanium abi for mangling

00:25:10,270 --> 00:25:13,073
is like defacto standard essentially.

00:25:15,370 --> 00:25:17,080
How about lines.

00:25:17,080 --> 00:25:21,686
So if I want to set a breakpoint on foo.cpp line four.

00:25:21,686 --> 00:25:23,790
Then we talked about dies

00:25:23,790 --> 00:25:26,343
and we talked about line table information.

00:25:27,480 --> 00:25:29,920
So this is line table information

00:25:29,920 --> 00:25:34,920
and we can see there is line four over here

00:25:35,710 --> 00:25:38,372
there are fewer entries for line four

00:25:38,372 --> 00:25:41,430
this could be because there are one line

00:25:41,430 --> 00:25:43,530
with multiple expressions, which generate

00:25:43,530 --> 00:25:46,510
multiple assembly instructions.

00:25:46,510 --> 00:25:49,570
So we wont' set one on the start of the statement

00:25:49,570 --> 00:25:53,090
so we look at this NS and set a breakpoint there.

00:25:53,090 --> 00:25:55,590
Have the address, it's the one on the left there

00:25:57,146 --> 00:26:00,772
Again, going from instructions to source

00:26:00,772 --> 00:26:04,895
is just a case of looking at Dwarf and mapping it back.

00:26:04,895 --> 00:26:08,149
Stepping, here's the answer to your question

00:26:08,149 --> 00:26:11,880
So the main types of stepping you want to do are

00:26:11,880 --> 00:26:14,662
over single assembly instructions,

00:26:14,662 --> 00:26:17,050
stepping over functions calls,

00:26:17,050 --> 00:26:21,783
so you don't want to go inside a function if you call it.

00:26:21,783 --> 00:26:24,550
Stepping in is when you do want to go

00:26:24,550 --> 00:26:26,640
and stepping out is when you want to

00:26:26,640 --> 00:26:28,973
finish this function or turn out.

00:26:30,590 --> 00:26:35,590
So on x86 with sufficiently high kernel version number

00:26:37,070 --> 00:26:39,863
you can just do this for instruction stepping.

00:26:41,684 --> 00:26:45,330
I will go into a bit more complex things

00:26:45,330 --> 00:26:46,440
you might have to do.

00:26:46,440 --> 00:26:50,090
But ptrace has a single step enumerator

00:26:50,090 --> 00:26:51,650
so you can just pass this and it will

00:26:51,650 --> 00:26:53,563
do an instructional single step.

00:26:56,170 --> 00:26:59,140
For stepping out, you can find the return address

00:26:59,140 --> 00:27:00,290
I'll talk a little bit about that

00:27:00,290 --> 00:27:03,250
when I go into stack unwinding.

00:27:03,250 --> 00:27:04,490
But you can find the return address

00:27:04,490 --> 00:27:06,553
and you can set a breakpoint there.

00:27:09,120 --> 00:27:13,000
Now if you're stepping in you want to set a breakpoint

00:27:13,000 --> 00:27:16,500
at the return address, in case you're not actually

00:27:16,500 --> 00:27:17,420
stepping into a function.

00:27:17,420 --> 00:27:19,090
Actually you're turning out and you don't want to

00:27:19,090 --> 00:27:23,330
just continue into cyber space and never gain control

00:27:23,330 --> 00:27:24,930
over your debuggee again.

00:27:24,930 --> 00:27:27,530
So you want to set the breakpoint at the return address

00:27:27,530 --> 00:27:30,300
and you want to set a breakpoint at the next instruction

00:27:30,300 --> 00:27:32,797
in this function or the callee.

00:27:33,720 --> 00:27:34,583
Great, simple.

00:27:35,820 --> 00:27:36,653
Not really.

00:27:38,330 --> 00:27:40,163
What is the next instruction?

00:27:41,041 --> 00:27:43,243
If I'm on some assembly instruction,

00:27:44,260 --> 00:27:46,493
how do I know where I'm going to go?

00:27:49,946 --> 00:27:51,761
Software breakpoints.

00:27:51,761 --> 00:27:53,140
You want to set software breakpoints

00:27:54,203 --> 00:27:56,023
but you need to know where to set the breakpoints.

00:27:57,010 --> 00:28:01,600
Yeah, so you might just be going to the next instruction

00:28:01,600 --> 00:28:03,310
you know, you're doing an add, you're doing a subtract,

00:28:03,310 --> 00:28:05,400
you're doing a move, you're doing another move.

00:28:05,400 --> 00:28:08,100
Simple, you just set a breakpoint at the next instruction.

00:28:08,100 --> 00:28:09,982
Maybe you're doing a jump,

00:28:09,982 --> 00:28:12,407
maybe you're doing a conditional jump,

00:28:12,407 --> 00:28:15,039
maybe you have no idea what's going on.

00:28:15,039 --> 00:28:17,880
So actually, answering what's the next instruction

00:28:17,880 --> 00:28:21,315
requires understanding your actual target.

00:28:21,315 --> 00:28:25,470
So in reality, you need to inspect the code

00:28:25,470 --> 00:28:29,193
to work out possible branch targets, set breakpoints there.

00:28:30,170 --> 00:28:33,690
What this essentially ends with is your debugger ships

00:28:33,690 --> 00:28:36,756
like an instruction emulator for your target.

00:28:36,756 --> 00:28:38,475
It's what LDB does.

00:28:38,475 --> 00:28:40,330
I'll talk a little bit more about

00:28:41,270 --> 00:28:43,368
how that makes a mess of some things, later.

00:28:43,368 --> 00:28:45,083
This is okay for now.

00:28:46,500 --> 00:28:48,250
Stepping over is very, very similar

00:28:48,250 --> 00:28:49,700
set a breakpoint at return address

00:28:49,700 --> 00:28:51,960
and the next instruction in this function.

00:28:51,960 --> 00:28:53,730
We still have that same question

00:28:53,730 --> 00:28:54,980
but the answer is the same.

00:28:54,980 --> 00:28:57,313
You know you need to work out your branch targets.

00:28:58,900 --> 00:29:00,737
Registers and memory.

00:29:00,737 --> 00:29:02,970
This is a useful thing if you're doing

00:29:02,970 --> 00:29:04,770
like really low level stuff,

00:29:04,770 --> 00:29:07,710
you want to be able to write or read your registers.

00:29:07,710 --> 00:29:10,670
Reading memory is useful for a whole host of problems.

00:29:10,670 --> 00:29:13,740
So reading registers is actually way more simple

00:29:13,740 --> 00:29:15,420
than you might expect.

00:29:15,420 --> 00:29:17,768
There's just a ptrace call for it.

00:29:17,768 --> 00:29:21,490
So you say, I have this user_regs_struct thing

00:29:21,490 --> 00:29:23,540
which I construct and I just pass it in

00:29:23,540 --> 00:29:25,450
and I get out something like this.

00:29:25,450 --> 00:29:30,000
Which just has a field for every single register

00:29:30,000 --> 00:29:31,600
which I might want the value of.

00:29:33,750 --> 00:29:34,863
Fairly simple.

00:29:36,270 --> 00:29:38,730
If I want to then write the registers,

00:29:38,730 --> 00:29:41,780
then I just do the read, I set some value

00:29:41,780 --> 00:29:43,083
and then I write it back.

00:29:46,481 --> 00:29:47,531
Not that magical, eh?

00:29:49,870 --> 00:29:52,720
For reading and writing memory it's the same kind of thing

00:29:52,720 --> 00:29:55,573
I have these peekdata and these pokedata calls.

00:29:56,455 --> 00:29:59,630
The unfortunate thing about this,

00:29:59,630 --> 00:30:02,653
can anyone see something, yes?

00:30:05,360 --> 00:30:07,403
Exactly, it's a word at a time.

00:30:08,410 --> 00:30:12,190
So if you're wanting to read a big amount of memory

00:30:12,190 --> 00:30:15,750
maybe I have a massive array

00:30:15,750 --> 00:30:19,700
which I want to show to the user.

00:30:19,700 --> 00:30:22,120
Or the user has requested I want a memory dump

00:30:22,120 --> 00:30:25,111
of like this entire bit of my program.

00:30:25,111 --> 00:30:27,230
Doing all that reading a word at a time

00:30:27,230 --> 00:30:28,690
is super inefficient.

00:30:28,690 --> 00:30:31,120
Because we have a siscall and we have a contact switch

00:30:31,120 --> 00:30:33,150
down into kernel mode and then we come back up

00:30:33,150 --> 00:30:35,023
every single word.

00:30:35,910 --> 00:30:36,910
So that's not great.

00:30:37,920 --> 00:30:40,630
So there are calls like process_vm_readv

00:30:40,630 --> 00:30:45,630
and write which can do multi word reading and writing.

00:30:45,940 --> 00:30:48,693
So this in one case where you can use ptrace

00:30:48,693 --> 00:30:51,113
but you don't really want to.

00:30:53,840 --> 00:30:54,963
Stack unwinding.

00:30:55,840 --> 00:30:59,640
So stack unwinding can get very complicated.

00:30:59,640 --> 00:31:04,400
There is in fact, an entire talk on exceptions in c++

00:31:04,400 --> 00:31:06,750
and how the stack is unwound on windows

00:31:07,619 --> 00:31:09,120
that's James' talk later today

00:31:10,318 --> 00:31:12,188
so I recommend going to see this

00:31:12,188 --> 00:31:13,920
if you want a more comprehensive view.

00:31:13,920 --> 00:31:17,614
I'm going to cover the kind of most simple case

00:31:17,614 --> 00:31:21,240
it should give you a flavor for the kinds of things

00:31:21,240 --> 00:31:23,383
which will actually occur.

00:31:24,560 --> 00:31:28,294
So this is what a stack could look like for x86 64

00:31:28,294 --> 00:31:30,633
given the system 5 abi.

00:31:31,840 --> 00:31:35,648
So you have all your arguments, your return address

00:31:35,648 --> 00:31:39,580
the old frame pointer, so the pointer to the previous

00:31:39,580 --> 00:31:41,388
stack frame.

00:31:41,388 --> 00:31:43,593
And then your local variables.

00:31:45,365 --> 00:31:47,583
Everyone okay with this, any questions?

00:31:49,479 --> 00:31:51,164
Cool.

00:31:51,164 --> 00:31:53,853
So we have a code like this.

00:31:56,388 --> 00:31:59,200
Bar plus foo, foo, hi

00:32:00,607 --> 00:32:04,593
I'm going to set a breakpoint, here on the cout.

00:32:07,450 --> 00:32:10,420
Then what are we in? We are in some stack frame

00:32:11,810 --> 00:32:14,550
we don't really have any information apart from that.

00:32:14,550 --> 00:32:16,120
So if we want to show the user

00:32:17,770 --> 00:32:20,458
how we actually got to this function

00:32:20,458 --> 00:32:22,110
and what functions did we call on the way

00:32:22,110 --> 00:32:23,810
then we need to walk up the stack.

00:32:25,030 --> 00:32:26,770
So what we can do is you can say,

00:32:26,770 --> 00:32:28,680
okay well we have the frame pointer

00:32:28,680 --> 00:32:32,470
for the previous stack frame.

00:32:32,470 --> 00:32:34,013
So we can just go back.

00:32:35,020 --> 00:32:37,260
Now we found another stack frame

00:32:37,260 --> 00:32:40,260
but we have no idea what it's for.

00:32:40,260 --> 00:32:44,820
Like, above this return we have some arguments

00:32:44,820 --> 00:32:47,520
and then we'll have some local variables

00:32:47,520 --> 00:32:48,353
and things like that.

00:32:48,353 --> 00:32:49,820
But we don't really know what this thing is

00:32:49,820 --> 00:32:50,920
it's just stack frame.

00:32:51,830 --> 00:32:53,810
So we can use the return address

00:32:54,680 --> 00:32:56,373
to look up the Dwarf information.

00:32:57,387 --> 00:33:01,600
Because the dwarf information says okay here's the range

00:33:01,600 --> 00:33:03,850
that this function's code lives at.

00:33:03,850 --> 00:33:05,750
If I know my return address I can say

00:33:05,750 --> 00:33:07,340
okay it doesn't match this function,

00:33:07,340 --> 00:33:09,310
it doesn't match this function,

00:33:09,310 --> 00:33:10,410
here's the function we're in.

00:33:10,410 --> 00:33:15,090
We know it's between this low value and this high value.

00:33:15,090 --> 00:33:16,550
And that's how we can find out okay,

00:33:16,550 --> 00:33:19,600
our last stack frame was bar.

00:33:19,600 --> 00:33:22,840
And we can then send that to the user.

00:33:22,840 --> 00:33:24,580
And then we just do the same thing again

00:33:24,580 --> 00:33:28,661
we go back along the frame pointer,

00:33:28,661 --> 00:33:32,650
check the return, and we know we've done

00:33:32,650 --> 00:33:34,023
baz call, bar call, foo.

00:33:34,980 --> 00:33:37,633
Then we stop when the frame pointer is zero.

00:33:38,490 --> 00:33:41,030
In reality above this, we'd have main and like

00:33:41,030 --> 00:33:42,930
underscore start and things like that.

00:33:43,992 --> 00:33:44,825
But for sake of brevity.

00:33:45,900 --> 00:33:48,210
So this is how stack unwinding would work

00:33:48,210 --> 00:33:50,533
if you have easy access to frame pointers.

00:33:52,700 --> 00:33:53,700
Sometimes you don't.

00:33:55,070 --> 00:33:56,950
Expression evaluation.

00:33:56,950 --> 00:33:59,730
Now you might notice as I get further into this talk

00:33:59,730 --> 00:34:02,100
things get more and more complicated

00:34:02,100 --> 00:34:04,320
And Expression evaluation could certainly

00:34:04,320 --> 00:34:08,560
be an entire hour talk on it, it's multiple talks.

00:34:08,560 --> 00:34:11,650
So I'll talk about the kind of broad aspect of it.

00:34:11,650 --> 00:34:15,660
We want to print my integer.

00:34:15,660 --> 00:34:17,080
It's a local variable

00:34:18,160 --> 00:34:20,393
has some value, it's on the stack.

00:34:21,500 --> 00:34:23,663
Fairly easy to get a hold of.

00:34:24,700 --> 00:34:27,433
So what we can do is look at our dwarf information.

00:34:28,490 --> 00:34:30,770
Dwarf information is so handy

00:34:30,770 --> 00:34:32,190
and this tells us its names

00:34:32,190 --> 00:34:34,280
we've found the name, we might have multiple

00:34:34,280 --> 00:34:36,326
things named in the dwarf information

00:34:36,326 --> 00:34:39,077
you have scopes so you can work out which scope you are in

00:34:39,077 --> 00:34:40,473
and which is the right one.

00:34:41,494 --> 00:34:46,494
And this tells us where our variable is located

00:34:47,100 --> 00:34:51,163
so this might be, oh it's just in register n.

00:34:52,090 --> 00:34:55,290
Or it could be, in this case, it's an offset

00:34:55,290 --> 00:34:57,670
from our stack frame.

00:34:57,670 --> 00:35:00,170
This thing is stored on the stack.

00:35:00,170 --> 00:35:02,698
So we then need to go and find where our stack frame is

00:35:02,698 --> 00:35:05,930
and offset it by negative 8 and we'll find our value.

00:35:05,930 --> 00:35:09,266
And then using ptrace or the vm process

00:35:09,266 --> 00:35:14,266
then we can go ahead and look where that address is

00:35:15,270 --> 00:35:16,816
and read the value.

00:35:16,816 --> 00:35:17,899
Yes question.

00:35:26,440 --> 00:35:29,810
Yes, so the question was if something is relocated

00:35:29,810 --> 00:35:33,370
like if it starts off in register 12 and then

00:35:33,370 --> 00:35:36,670
is moved to register 17 because the register allocator

00:35:36,670 --> 00:35:39,030
decides it needs to move things around

00:35:39,030 --> 00:35:41,240
is that reflect the dwarf information.

00:35:41,240 --> 00:35:42,393
The answer is yes.

00:35:43,902 --> 00:35:46,620
There are various different ways that dwarf information

00:35:46,620 --> 00:35:51,620
can represent addresses, and one of those is list of ranges.

00:35:52,120 --> 00:35:56,150
So it can say between this pc and that pc it lives here.

00:35:56,150 --> 00:35:58,870
Between this pc and that pc, it lives over there.

00:35:58,870 --> 00:36:00,969
Here it's on the stack, here it's on the register

00:36:00,969 --> 00:36:03,223
and that can all be represented by dwarf.

00:36:04,140 --> 00:36:04,973
Answer question?

00:36:06,180 --> 00:36:07,013
Yeah.

00:36:09,020 --> 00:36:10,490
And yes, so I just mentioned that there are

00:36:10,490 --> 00:36:15,462
various ways for dwarf information to represent addresses.

00:36:15,462 --> 00:36:19,820
So this becomes annoying for debuggers to handle

00:36:19,820 --> 00:36:22,330
because, you know, maybe my frame base

00:36:22,330 --> 00:36:24,700
is just in register 6 and I can go read that register

00:36:24,700 --> 00:36:27,150
and I can offset it and it's all fine.

00:36:27,150 --> 00:36:30,323
Maybe I need to go look a the call frame information

00:36:30,323 --> 00:36:33,330
this is like a section in our ELF,

00:36:33,330 --> 00:36:35,760
which stores information for stack unwinding

00:36:35,760 --> 00:36:37,120
for exceptions.

00:36:37,120 --> 00:36:40,964
This is like the real way which you could do stack unwinding

00:36:40,964 --> 00:36:44,390
in the absence of pin pointer information

00:36:44,390 --> 00:36:46,670
and things like that, but it gets quite hairy

00:36:46,670 --> 00:36:48,733
so I'm not going to show that.

00:36:48,733 --> 00:36:52,957
And this example right in the bottom shows the ranges.

00:36:52,957 --> 00:36:57,100
I didn't really expect people to be able to read this

00:36:57,100 --> 00:36:59,725
but this just showing that there are a bunch

00:36:59,725 --> 00:37:00,817
of different ways in which it's represented

00:37:00,817 --> 00:37:03,130
and that's how the ranges kind of look

00:37:03,130 --> 00:37:04,280
when you dump them out.

00:37:06,750 --> 00:37:09,130
Getting a little bit more complicated

00:37:09,130 --> 00:37:11,910
we have some local variable my_int

00:37:11,910 --> 00:37:13,130
and another one called a

00:37:13,130 --> 00:37:14,580
and we went to multiply them.

00:37:16,190 --> 00:37:20,587
So we could kind of do a lot of stuff in the debugger

00:37:20,587 --> 00:37:23,900
but what some things do, this is what LDB actually does

00:37:23,900 --> 00:37:28,900
generates function, so this has some special magic in it

00:37:30,530 --> 00:37:35,080
to say what local variables I'm using and things like that.

00:37:35,080 --> 00:37:38,691
It generates a function, generates llbmir from it.

00:37:38,691 --> 00:37:40,910
You don't need to understand what this is doing

00:37:40,910 --> 00:37:42,660
just note that it exists

00:37:42,660 --> 00:37:45,273
and this is actually what lldb actually produces.

00:37:46,510 --> 00:37:51,510
And then that ir is interpreted to get out the final result.

00:37:51,630 --> 00:37:55,630
So the debugger isn't having to implement its own c++

00:37:55,630 --> 00:37:58,853
expression parser and evaluator.

00:38:02,220 --> 00:38:05,010
If you want to do something like call a function

00:38:05,010 --> 00:38:07,090
maybe this function has side effect.

00:38:07,090 --> 00:38:08,810
Maybe we want the side effects to happen

00:38:08,810 --> 00:38:11,280
maybe it's going to change some values

00:38:11,280 --> 00:38:12,380
or print something out

00:38:12,380 --> 00:38:16,130
and we want this to actually be occurring

00:38:16,130 --> 00:38:19,380
as if we called the function in our code.

00:38:19,380 --> 00:38:22,560
So we can create some ir and interpret that

00:38:22,560 --> 00:38:26,233
because the side effects won't be properly represented.

00:38:27,187 --> 00:38:29,693
So instead we can compile ir,

00:38:31,048 --> 00:38:33,373
lower to machine code,

00:38:34,859 --> 00:38:39,660
map this code into the address space of our debuggee

00:38:44,868 --> 00:38:47,550
and then execute that function.

00:38:47,550 --> 00:38:50,303
Just by manipulating our registers.

00:38:51,590 --> 00:38:54,410
So this is how you actually end up calling functions

00:38:54,410 --> 00:38:56,690
within the address space and having all

00:38:56,690 --> 00:38:58,033
the side effects work.

00:38:59,780 --> 00:39:01,770
So it's pretty interesting.

00:39:01,770 --> 00:39:05,210
There's a whole lot of research in to various ways

00:39:06,126 --> 00:39:09,320
to achieve this and it's really cool.

00:39:09,320 --> 00:39:11,160
If you go and Google some stuff afterwards

00:39:11,160 --> 00:39:14,988
or come talk to me or some other debugger experts here.

00:39:14,988 --> 00:39:15,903
Yes, question.

00:39:25,304 --> 00:39:27,407
So the question was do the debugger need to know how

00:39:27,407 --> 00:39:29,053
the debuggee was compiled.

00:39:31,970 --> 00:39:34,470
I'm trying to think if it would need

00:39:34,470 --> 00:39:37,280
to do anything to match calling interventions

00:39:37,280 --> 00:39:38,563
or abi or anything.

00:39:41,990 --> 00:39:45,310
Probably not because you can find the address

00:39:45,310 --> 00:39:47,590
of functions by looking at symbol table

00:39:47,590 --> 00:39:49,270
or the dwarf information.

00:39:49,270 --> 00:39:53,700
So you know where the functions are gonna live.

00:39:53,700 --> 00:39:56,600
You just need to make sure that the addresses are correct.

00:39:59,430 --> 00:40:01,233
Does that answer?

00:40:02,390 --> 00:40:04,290
There's another question here I think.

00:40:09,100 --> 00:40:12,185
Yes so if our expression that we're,

00:40:12,185 --> 00:40:15,740
like if we're not calling a function here

00:40:15,740 --> 00:40:18,210
but say this expression is inset

00:40:18,210 --> 00:40:22,860
or like right into a memory address

00:40:22,860 --> 00:40:24,760
then yes we have to do the same thing.

00:40:27,540 --> 00:40:29,240
Why do we not always do that?

00:40:29,240 --> 00:40:33,080
I think this has changed in lldb sometimes

00:40:33,080 --> 00:40:35,960
I think it used to do more interpretation

00:40:35,960 --> 00:40:37,550
than it does now.

00:40:37,550 --> 00:40:40,660
But I'm willing to be proven wrong on that.

00:40:40,660 --> 00:40:44,860
I think maybe it now just always gets it.

00:40:44,860 --> 00:40:47,120
But yeah I would have to check.

00:40:47,120 --> 00:40:48,220
Victor had a question.

00:40:52,240 --> 00:40:53,073
What if the functions in line

00:40:53,073 --> 00:40:54,660
that's a very good question.

00:40:54,660 --> 00:40:58,930
So dwarf information does give you information

00:40:58,930 --> 00:41:00,460
about in line functions

00:41:00,460 --> 00:41:04,170
but a lot of the time not very useful

00:41:04,170 --> 00:41:07,387
because in line functions are subject to other things

00:41:07,387 --> 00:41:08,984
other than just in lining

00:41:08,984 --> 00:41:10,850
because you have more local information.

00:41:10,850 --> 00:41:13,100
I do have an example coming right up.

00:41:13,100 --> 00:41:15,883
So just a second.

00:41:19,606 --> 00:41:20,439
Yes.

00:41:26,264 --> 00:41:28,930
So I think this is how it gets mapped in

00:41:28,930 --> 00:41:31,960
they can get calls and m-map essentially

00:41:31,960 --> 00:41:34,373
and then writes into the map memory.

00:41:41,219 --> 00:41:45,248
It has to generate a call to m-map

00:41:45,248 --> 00:41:48,070
that it calls m-map within the address space

00:41:48,070 --> 00:41:49,327
and get the address out.

00:41:55,456 --> 00:41:57,893
So the functions actually in the debuggees.

00:42:03,850 --> 00:42:05,200
Yeah come talk to me after.

00:42:10,270 --> 00:42:12,063
This is getting to the end lining.

00:42:13,320 --> 00:42:16,033
How many of you have tried doing something like this?

00:42:17,870 --> 00:42:20,040
Quite a few, did it work?

00:42:20,040 --> 00:42:22,523
No? Did you get something like this?

00:42:23,970 --> 00:42:25,610
Yeah.

00:42:25,610 --> 00:42:27,140
This happens a lot.

00:42:27,140 --> 00:42:30,110
Especially with templates everywhere in c++

00:42:31,330 --> 00:42:33,190
things get in lined,

00:42:33,190 --> 00:42:34,960
you don't have a definition for the function

00:42:34,960 --> 00:42:37,430
so you what do you call?

00:42:37,430 --> 00:42:38,623
It's not there.

00:42:39,652 --> 00:42:40,533
Pardon?

00:42:42,271 --> 00:42:43,731
(laughter)

00:42:43,731 --> 00:42:45,120
Who are you gonna call, yes

00:42:47,160 --> 00:42:50,290
So what you can do is just write this

00:42:55,010 --> 00:42:59,894
So you could just write this in some translation unit

00:42:59,894 --> 00:43:04,894
output actual definition for this in satiation

00:43:05,160 --> 00:43:07,784
I have actually used this quite a lot

00:43:07,784 --> 00:43:09,530
it's awful but it works quite nicely.

00:43:09,530 --> 00:43:13,900
So if you want to be printing out a bunch of expressions

00:43:15,290 --> 00:43:20,240
which are requiring functions of class templates

00:43:20,240 --> 00:43:24,060
which would otherwise not have definitions outputted

00:43:24,060 --> 00:43:26,170
then you can make sure definition is outputted somewhere

00:43:26,170 --> 00:43:28,440
and then the debugger can call it.

00:43:28,440 --> 00:43:31,313
So this is like a hacky debugger tip.

00:43:33,510 --> 00:43:35,610
Multi threaded applications,

00:43:35,610 --> 00:43:39,253
again could be like an entire course.

00:43:40,600 --> 00:43:44,060
So you could do ptrace has options you can set.

00:43:44,060 --> 00:43:47,390
So you can say I want to get a trap every time

00:43:47,390 --> 00:43:48,963
the clones is called.

00:43:50,169 --> 00:43:54,750
And that is what happens when you create a new thread.

00:43:54,750 --> 00:43:56,720
And then there's some magic you can do to say

00:43:56,720 --> 00:43:58,633
oh what's this.

00:43:58,633 --> 00:44:02,480
Sigtrap from a clone call and if it was

00:44:02,480 --> 00:44:04,920
then you can work out what the new pid is

00:44:04,920 --> 00:44:06,570
and add it into your internal data structures

00:44:06,570 --> 00:44:07,620
and things like that.

00:44:08,570 --> 00:44:11,135
So this is like the thousand mile view

00:44:11,135 --> 00:44:13,130
of what the setup is for dealing

00:44:13,130 --> 00:44:15,483
with multi threaded applications.

00:44:17,510 --> 00:44:18,440
Shared libraries,

00:44:18,440 --> 00:44:19,600
Oh sorry, Victor, yes?

00:44:31,920 --> 00:44:35,942
Yeah that's the question I didn't want to get into much.

00:44:35,942 --> 00:44:38,776
(audience laughter)

00:44:38,776 --> 00:44:42,220
The question was when you set a breakpoint

00:44:42,220 --> 00:44:45,520
do all threads stop, does just one thread stop

00:44:45,520 --> 00:44:47,341
the answer is complicated

00:44:47,341 --> 00:44:48,940
because debuggers will have different modes

00:44:48,940 --> 00:44:52,410
which allow you to have non stop mode or all stop mode

00:44:52,410 --> 00:44:54,692
and some dealers do it better than others.

00:44:54,692 --> 00:44:56,680
Yeah it's another big topic

00:44:56,680 --> 00:44:58,710
which I didn't quite want to cover.

00:44:58,710 --> 00:44:59,543
Yes.

00:45:01,810 --> 00:45:03,350
Isn't it wrong to stop only one thread?

00:45:03,350 --> 00:45:04,959
Maybe, maybe not.

00:45:04,959 --> 00:45:07,959
(audience laughter)

00:45:11,570 --> 00:45:12,820
Well if you stop only one thread

00:45:12,820 --> 00:45:14,520
maybe your gooey can keep running.

00:45:25,070 --> 00:45:27,390
Right yeah, if you have a multi threaded server

00:45:28,344 --> 00:45:30,344
and maybe you're debugging infraduction.

00:45:31,814 --> 00:45:35,159
(audience laughter)

00:45:35,159 --> 00:45:36,007
Maybe you're a terrible person.

00:45:37,770 --> 00:45:39,553
Then you can do this, yes.

00:45:40,720 --> 00:45:42,070
Yeah come talk to me after.

00:45:43,917 --> 00:45:46,773
Don't debug infraduction.

00:45:46,773 --> 00:45:48,140
Okay shared libraries

00:45:48,140 --> 00:45:50,140
this was something in which I didn't understand

00:45:50,140 --> 00:45:51,260
for the longest time.

00:45:51,260 --> 00:45:53,410
Because it's really badly documented

00:45:53,410 --> 00:45:55,480
until you find the header file

00:45:55,480 --> 00:45:58,143
which explains everything and it's great.

00:45:59,099 --> 00:46:01,450
But if you wanna trace when shared libraries

00:46:01,450 --> 00:46:03,798
are loaded and unloaded because maybe you,

00:46:03,798 --> 00:46:06,700
if you use shared libraries at all

00:46:06,700 --> 00:46:08,960
you've probably got to the situation where you want to set

00:46:08,960 --> 00:46:11,370
a breakpoint on something in the shared library

00:46:11,370 --> 00:46:14,270
and the debugger says oh we couldn't find this

00:46:14,270 --> 00:46:16,220
do you want to wait and we'll try and set it

00:46:16,220 --> 00:46:17,800
if the library turns up.

00:46:17,800 --> 00:46:19,450
This happens a lot.

00:46:19,450 --> 00:46:21,101
This is how it's implemented

00:46:21,101 --> 00:46:23,920
because it has to know when something is being loaded.

00:46:23,920 --> 00:46:28,290
Because maybe you just hit a breakpoint on function

00:46:28,290 --> 00:46:29,253
you continue.

00:46:32,215 --> 00:46:34,840
If shared library has loaded with that function in it

00:46:34,840 --> 00:46:36,250
you want that breakpoint to be hit

00:46:36,250 --> 00:46:39,190
rather than just waiting for the death of the universe

00:46:39,190 --> 00:46:43,790
or the program terminates or something.

00:46:43,790 --> 00:46:47,140
So somewhere in your program

00:46:47,140 --> 00:46:49,273
there is a way to get this somewhere.

00:46:50,960 --> 00:46:53,870
There is this kind of data structure

00:46:53,870 --> 00:46:56,762
which has a bunch of tags and information

00:46:56,762 --> 00:46:58,890
about your program.

00:46:58,890 --> 00:47:01,563
This is like dynamic process information.

00:47:02,468 --> 00:47:05,430
And one of these entries points

00:47:05,430 --> 00:47:07,923
to something like this, r_debug.

00:47:09,310 --> 00:47:11,120
Now the most important things in this

00:47:11,120 --> 00:47:13,714
are this link map which tells you

00:47:13,714 --> 00:47:16,780
every single shared library which is loaded,

00:47:16,780 --> 00:47:18,650
its name, where it's loaded.

00:47:18,650 --> 00:47:20,440
So this is the kind of thing we want to be,

00:47:20,440 --> 00:47:21,730
it's a link list.

00:47:21,730 --> 00:47:23,070
So we want to walk the link list

00:47:23,070 --> 00:47:27,460
and find what our shared libraries are.

00:47:27,460 --> 00:47:30,060
The really cool thing, at least I think it's really cool

00:47:30,060 --> 00:47:31,600
I'm really nerdy.

00:47:31,600 --> 00:47:32,733
Is this.

00:47:33,840 --> 00:47:37,790
So this is an address of a function which will get called

00:47:37,790 --> 00:47:40,613
every time a shared library is loaded or unloaded.

00:47:42,100 --> 00:47:47,100
So what can we do in order to read the link map every time

00:47:48,330 --> 00:47:50,080
it's something our debugger can do.

00:47:51,370 --> 00:47:52,670
Set a software breakpoint.

00:47:53,620 --> 00:47:57,120
So we set a software breakpoint at this address

00:47:57,120 --> 00:47:59,040
and every time the function is called

00:47:59,040 --> 00:48:02,290
we know that the library is being loaded or unloaded

00:48:02,290 --> 00:48:04,587
we can then walk this link map,

00:48:04,587 --> 00:48:06,694
see if there are any differences.

00:48:06,694 --> 00:48:10,500
There's some ways for the operating system to tell

00:48:10,500 --> 00:48:12,037
if there are changes, things like that.

00:48:12,037 --> 00:48:14,430
But we can essentially walk it up our data structure,

00:48:14,430 --> 00:48:15,633
set break points.

00:48:16,720 --> 00:48:20,160
And this breakpoint is hidden from the user.

00:48:20,160 --> 00:48:23,610
So the debuggers are setting breakpoints all the time

00:48:23,610 --> 00:48:25,950
without you actually noticing it.

00:48:25,950 --> 00:48:27,670
But they're doing it to do things like this.

00:48:27,670 --> 00:48:32,020
Trace, shared library loading and it's all hidden.

00:48:32,020 --> 00:48:33,540
There are some ways to get the debugger

00:48:33,540 --> 00:48:35,120
to show you these things.

00:48:35,120 --> 00:48:39,810
I think lldb has a option to print internal breakpoints

00:48:39,810 --> 00:48:41,940
so you will see things like this being set

00:48:41,940 --> 00:48:43,033
which is pretty cool.

00:48:45,250 --> 00:48:46,290
So this kind of how it goes

00:48:46,290 --> 00:48:48,110
the debugger sets breakpoint, magic function,

00:48:48,110 --> 00:48:49,550
when it's hit you walk through the link map,

00:48:49,550 --> 00:48:50,743
update data structures.

00:48:52,090 --> 00:48:53,253
Remote debugging.

00:48:54,630 --> 00:48:58,700
So this is kind of how a remote debugging session looks.

00:48:58,700 --> 00:49:01,530
You have the debugger on your host,

00:49:01,530 --> 00:49:04,273
you have a debug stub on the target.

00:49:05,490 --> 00:49:07,740
Now this debug stub is supposed to be,

00:49:07,740 --> 00:49:11,510
supposed to be, a very thin wrapper around

00:49:11,510 --> 00:49:14,440
the operating system, debug interface.

00:49:14,440 --> 00:49:15,860
Like ptrace.

00:49:15,860 --> 00:49:18,880
In reality, this thing is massive.

00:49:18,880 --> 00:49:21,570
Like, lldb debug stub for x86

00:49:21,570 --> 00:49:23,853
ships like an entire instruction emulator.

00:49:24,900 --> 00:49:28,360
So yeah, it's not really a tiny thing anymore

00:49:28,360 --> 00:49:30,040
which is a bit frustrating.

00:49:30,040 --> 00:49:32,740
The idea is that the debugger communicates

00:49:32,740 --> 00:49:36,050
with the debug stub, the debug stub operates

00:49:36,050 --> 00:49:39,033
with the debuggee in some os specific manner like ptrace.

00:49:41,120 --> 00:49:44,287
And then just everything sent between the debugger

00:49:44,287 --> 00:49:45,593
and the debug stub.

00:49:47,000 --> 00:49:50,290
Now, the interesting thing is your actually

00:49:50,290 --> 00:49:51,653
using this all the time.

00:49:52,991 --> 00:49:57,396
Because this how quite a lot debuggers operate,

00:49:57,396 --> 00:49:59,710
just doing local debugging.

00:49:59,710 --> 00:50:02,084
Because it means it's a whole lot easier

00:50:02,084 --> 00:50:03,500
to implement a bunch of this stuff.

00:50:03,500 --> 00:50:07,470
You just always have a debugger connecting to a debug stub.

00:50:07,470 --> 00:50:09,270
It just so happens that the debug stub

00:50:09,270 --> 00:50:11,883
is on the same machine as you run on the debugger.

00:50:13,020 --> 00:50:16,223
So this is how lldb operates all the time for example.

00:50:16,223 --> 00:50:20,183
I think GDB does as well but I don't know GDB as well.

00:50:22,420 --> 00:50:23,253
Yes?

00:50:31,230 --> 00:50:32,380
That's a very good question.

00:50:32,380 --> 00:50:34,340
What if the debug symbols are not available?

00:50:34,340 --> 00:50:37,470
And yes debug symbols should generally,

00:50:37,470 --> 00:50:39,607
are not available on the debug stub

00:50:39,607 --> 00:50:43,780
because the debug symbols information

00:50:43,780 --> 00:50:45,660
is high level information

00:50:45,660 --> 00:50:47,540
which only the debugger has access to.

00:50:47,540 --> 00:50:51,590
The idea is that the debug stub should just be handling

00:50:51,590 --> 00:50:53,330
addresses and super low level stuff.

00:50:53,330 --> 00:50:56,330
So generally the debug stub does not have access

00:50:56,330 --> 00:50:58,040
to the debug info.

00:50:58,040 --> 00:51:01,262
It's just the debugger works out all the address

00:51:01,262 --> 00:51:03,203
and sends it to the debug stub.

00:51:04,140 --> 00:51:04,973
Okay.

00:51:14,900 --> 00:51:17,840
Yeah, so I'm going to show how it sends request just now.

00:51:17,840 --> 00:51:20,660
So there is a remote protocol called

00:51:20,660 --> 00:51:22,210
the gdb remote protocol.

00:51:22,210 --> 00:51:24,364
That's what gdb and lldb use.

00:51:24,364 --> 00:51:27,006
So it looks kind of like this.

00:51:27,006 --> 00:51:30,260
This is just blown up a bit,

00:51:30,260 --> 00:51:32,930
so I can explain all the different parts.

00:51:32,930 --> 00:51:35,300
So you have packet start, some types

00:51:35,300 --> 00:51:37,170
which is a little identifier.

00:51:37,170 --> 00:51:38,840
Arguments and then check sum.

00:51:38,840 --> 00:51:41,540
So this is just sent over a network

00:51:41,540 --> 00:51:44,393
or over any kind of communication channel.

00:51:45,580 --> 00:51:48,110
So for example, this is a debug

00:51:48,110 --> 00:51:49,363
breakpoint packet.

00:51:50,610 --> 00:51:53,920
Which sets the breakpoint at some address

00:51:53,920 --> 00:51:56,400
and there's an architecture specific thing

00:51:56,400 --> 00:51:59,293
I can't remember what that's actually used for on x86.

00:52:01,660 --> 00:52:06,630
And that's how you write, or that's how c++ debuggers work.

00:52:06,630 --> 00:52:07,463
Thank you.

00:52:16,010 --> 00:52:18,160
Okay I have resources there if anyone would like

00:52:18,160 --> 00:52:19,490
and I will now take questions.

00:52:19,490 --> 00:52:20,323
Yes.

00:52:24,760 --> 00:52:27,690
Why can't we properly debug over fork.

00:52:27,690 --> 00:52:29,238
This annoys me too.

00:52:29,238 --> 00:52:31,630
GDB has a very, very good,

00:52:31,630 --> 00:52:34,650
well comparatively very good follow forks mode

00:52:34,650 --> 00:52:35,923
lldb does not.

00:52:36,920 --> 00:52:38,890
So the gdb follow forks mode has,

00:52:38,890 --> 00:52:40,750
in my experience mostly worked okay.

00:52:40,750 --> 00:52:42,810
So it's just something you can set and say

00:52:42,810 --> 00:52:45,630
okay when my program forks, I want to follow my child

00:52:45,630 --> 00:52:46,890
rather than the parent

00:52:46,890 --> 00:52:49,090
and maybe you had bad experiences with that.

00:52:53,490 --> 00:52:54,913
You want it to follow both.

00:53:02,460 --> 00:53:04,563
Right, yeah.

00:53:05,460 --> 00:53:07,010
I haven't thought much about

00:53:07,010 --> 00:53:08,750
debugging both at the same time.

00:53:08,750 --> 00:53:12,223
Maybe modern GDB has more support for that or something.

00:53:30,060 --> 00:53:35,050
Yeah GDB just connects to the child as soon as it can

00:53:35,050 --> 00:53:37,313
rather than doing something nice.

00:53:40,990 --> 00:53:43,531
I know some people who have worked on

00:53:43,531 --> 00:53:45,903
follow forks mode stuff.

00:53:47,830 --> 00:53:49,380
But can't remember the details.

00:53:51,872 --> 00:53:54,270
I'm not so sure about that part myself.

00:53:54,270 --> 00:53:56,193
Other questions, yes in the back.

00:53:57,493 --> 00:53:59,413
Sorry can you come to the microphone.

00:54:05,870 --> 00:54:07,320
- [Man] How do watch points work?

00:54:07,320 --> 00:54:09,880
- So watch points you use the Hardware break points

00:54:09,880 --> 00:54:13,580
because you can set them on reading and writing as well

00:54:13,580 --> 00:54:16,150
so you say I want a set watch point at this variable

00:54:16,150 --> 00:54:17,830
I know where that variable lives

00:54:17,830 --> 00:54:19,400
because I have the dwarf information

00:54:19,400 --> 00:54:22,260
and then I can set harder breakpoints to trap

00:54:22,260 --> 00:54:23,230
on reading and writing.

00:54:23,230 --> 00:54:25,630
- [Man] So you can only do that on registers then?

00:54:26,598 --> 00:54:31,029
- No the registers are having addresses written into them.

00:54:31,029 --> 00:54:33,673
So you're watching addresses.

00:54:36,370 --> 00:54:37,823
Other questions? Victor?

00:54:39,425 --> 00:54:43,130
- [Victor] So you have a protocol between the debugger

00:54:43,130 --> 00:54:45,830
and this stub.

00:54:45,830 --> 00:54:48,640
Is that standardized or.

00:54:48,640 --> 00:54:53,290
- Yes, well it's partially

00:54:53,290 --> 00:54:57,578
there is a document which shows all the

00:54:57,578 --> 00:54:59,520
different gdb remote packets,

00:54:59,520 --> 00:55:01,793
I think I have a link to it in my resources.

00:55:02,960 --> 00:55:07,370
In reality, debuggers will have their own extensions

00:55:07,370 --> 00:55:12,370
so lldb has its own packets which gdb doesn't support.

00:55:12,710 --> 00:55:16,500
The packet format will have multiple versions

00:55:16,500 --> 00:55:19,280
so if you're using different versions of gdb

00:55:19,280 --> 00:55:22,780
or your debug stub, then maybe there's a mismatch

00:55:22,780 --> 00:55:23,830
and things like that.

00:55:24,815 --> 00:55:29,815
So it's not like a standard, but it's documented at least.

00:55:30,150 --> 00:55:31,950
Or at least most of it's documented.

00:55:33,147 --> 00:55:33,980
Yeah.

00:55:36,380 --> 00:55:39,175
- [Man] I think somebody over there was actually

00:55:39,175 --> 00:55:40,564
trying to ask this earlier.

00:55:40,564 --> 00:55:42,857
Maybe I just didn't understand the response

00:55:42,857 --> 00:55:46,250
but some debuggers have a pause button, right?

00:55:46,250 --> 00:55:50,750
How are you inserting a breakpoint wherever you happen to be

00:55:50,750 --> 00:55:51,960
at the time.

00:55:51,960 --> 00:55:55,340
- Okay, so the pause button on debuggers

00:55:55,340 --> 00:55:59,640
usually just sends like a second to the debuggee process.

00:55:59,640 --> 00:56:02,640
So it's not like taking a breakpoint wherever you are

00:56:02,640 --> 00:56:05,993
it just sends a signal and that will stop the process.

00:56:08,610 --> 00:56:13,210
- [Man] Question about core dump debugging works.

00:56:13,210 --> 00:56:16,270
We don't have a process that will work.

00:56:16,270 --> 00:56:18,070
- Yeah for core dump debugging,

00:56:18,070 --> 00:56:20,243
I never looked into a whole lot.

00:56:24,430 --> 00:56:27,290
My naive understanding is that you just have

00:56:27,290 --> 00:56:29,745
your core dump will have enough information

00:56:29,745 --> 00:56:32,040
to give you some experience

00:56:32,040 --> 00:56:33,820
and then your debugger is responsible

00:56:33,820 --> 00:56:38,333
for using that information as best it can to provide.

00:56:54,159 --> 00:56:57,730
- [Man] Petrie skulls to get registers to get memory

00:56:57,730 --> 00:57:02,200
are replaced by reading from core dump, right?

00:57:02,200 --> 00:57:04,556
- Right, yeah, as I said

00:57:04,556 --> 00:57:06,376
I haven't looked into core dumps much

00:57:06,376 --> 00:57:08,563
but I would guess that's what's done.

00:57:17,791 --> 00:57:20,960
So if you evaluate an expression

00:57:20,960 --> 00:57:24,830
which results in an exception

00:57:26,580 --> 00:57:31,450
I guess when you're getting the call to the function

00:57:31,450 --> 00:57:35,360
then the compiler which you're using, would have to

00:57:35,360 --> 00:57:39,921
I would put code to handle to deal with the exceptions.

00:57:39,921 --> 00:57:44,506
Like report back to the user that an exception was thrown

00:57:44,506 --> 00:57:47,353
and not just end up terminating everything.

00:57:55,955 --> 00:57:59,026
Sorry can you stand closer to the microphone?

00:57:59,026 --> 00:58:03,660
How does the debugger know whether it's an exception.

00:58:03,660 --> 00:58:08,660
Well I mean the debugger is using like a full on compiler

00:58:10,120 --> 00:58:15,120
so the lldb calls aren't inclined to actually compile

00:58:16,140 --> 00:58:17,480
the expressions which you use.

00:58:17,480 --> 00:58:19,694
So it's not one of these things

00:58:19,694 --> 00:58:22,090
where it's just hacked together.

00:58:22,090 --> 00:58:24,780
C++ subset is like actually using clang

00:58:24,780 --> 00:58:27,600
so it has everything in clang available.

00:58:41,740 --> 00:58:43,820
Sorry can you say that again?

00:58:43,820 --> 00:58:45,800
- [Man] Do you know why the Linux kernel

00:58:45,960 --> 00:58:47,708
only got single step support recently

00:58:47,708 --> 00:58:50,060
because x86, I think has single step hardware support.

00:58:50,060 --> 00:58:52,740
- Yeah do I know why ptrace only got single step recently

00:58:52,740 --> 00:58:54,890
I mean it wasn't recent, recent.

00:58:54,890 --> 00:58:58,963
This was a number of years.

00:59:00,220 --> 00:59:03,030
I can't remember exactly what kernel version it changed at

00:59:03,030 --> 00:59:05,810
and I'm not sure why it took longer

00:59:05,810 --> 00:59:07,380
maybe it was just ptrace didn't

00:59:07,380 --> 00:59:11,137
have that actual part available.

00:59:11,137 --> 00:59:14,740
Before then to do single step you'd have to do

00:59:14,740 --> 00:59:17,760
something like the branch target.

00:59:17,760 --> 00:59:19,963
Finding and then taking breakpoints there.

00:59:25,210 --> 00:59:26,950
- [Man] When debugging application that was built with clang

00:59:26,950 --> 00:59:31,650
sometimes I can't see the internal representations of memory

00:59:31,650 --> 00:59:32,660
but I can with gcc.

00:59:32,660 --> 00:59:34,730
Is there anyway I can instruct the debugger

00:59:34,730 --> 00:59:36,520
what I've built with so that I can give it better,

00:59:36,520 --> 00:59:37,830
rich information.

00:59:37,830 --> 00:59:39,350
- Sorry can you say that first bit again

00:59:39,350 --> 00:59:41,330
- [Man] Oh so sometimes when we build

00:59:41,330 --> 00:59:42,500
an application with clang

00:59:42,500 --> 00:59:44,360
you can't really see the internal data

00:59:44,360 --> 00:59:48,680
but we go to gcc and see your strings for whatever you need

00:59:48,680 --> 00:59:50,600
is there anyway to instruct the debugger

00:59:50,600 --> 00:59:52,130
like hey I'm building a clang,

00:59:52,130 --> 00:59:54,050
use clang internals to represent this data

00:59:54,050 --> 00:59:59,050
- So yeah the debugger will know what you've compiled with

00:59:59,350 --> 01:00:01,417
because it will be set in the start

01:00:01,417 --> 01:00:05,500
of the compilation unit and it said which compiler

01:00:05,500 --> 01:00:06,380
is being used.

01:00:06,380 --> 01:00:09,447
So will have that information available to it,

01:00:09,447 --> 01:00:11,780
it's just a case of what it does with that

01:00:11,780 --> 01:00:15,430
and whether it implements all the necessary

01:00:15,430 --> 01:00:16,763
machinery to do that.

01:00:18,460 --> 01:00:19,670
Thanks, one more question.

01:00:19,670 --> 01:00:22,360
We have seconds left.

01:00:22,360 --> 01:00:25,630
- [Man] How do you debug when the variable is optimized away

01:00:25,630 --> 01:00:27,500
- When a variable is optimized away,

01:00:27,500 --> 01:00:30,900
then the debugger will just often say

01:00:30,900 --> 01:00:32,324
this is being optimized away.

01:00:32,324 --> 01:00:36,530
So if it's not there, you can't visualize it.

01:00:36,530 --> 01:00:39,520
- [Man] So then do you add printer statements

01:00:39,520 --> 01:00:43,180
for the variable and not make it get optimized

01:00:44,035 --> 01:00:47,770
- Yeah you could, in your program,

01:00:47,770 --> 01:00:49,750
try to do things to stop it being optimized away

01:00:49,750 --> 01:00:52,533
like stick it in a volatile or something like that.

01:00:54,150 --> 01:00:55,400
Okay thank you very much.

01:00:56,292 --> 01:00:58,542

YouTube URL: https://www.youtube.com/watch?v=0DDrseUomfU


