Title: CppCon 2018: Chandler Carruth “Spectre: Secrets, Side-Channels, Sandboxes, and Security”
Publication date: 2018-10-02
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
The discovery of speculative execution side-channel attacks (called "Spectre") fundamentally changes the security model of every modern superscalar microprocessor. Extracting secret data (credit cards, cryptographic keys) through side-channels is not new and has challenged the cryptographic community for decades. Despite this, the industry has often been complacent in our response, viewing these attacks as impacting a tiny amount of code and being nearly impossible to weaponize. But speculative execution attack techniques have fundamentally altered the ease and applicability of side-channels, making them a serious threat to computer security. Responding to these issues has impacted CPU design, compiler design, library design, sandbox techniques and even the C++ programming language and standard. 

This talk will explain how these kinds of attacks work at a high level and provide a clear set of terminology to describe these classes of vulnerabilities and attacks. It will show how the different variants work at the low level of modern hardware to give a detailed and precise understanding of the mechanics involved on CPUs today. 

It will also provide guidance about what makes applications and services vulnerable and how to analyze your software to understand the degree of its exposure. It will include an overview of the numerous different mitigation techniques available, how to deploy them, and what tradeoffs come with them. Some of these mitigations will be covered in detail: how they work at a hardware level, where they don't work, and what attack vectors remain. 

Finally, the talk will show how traditional side-channel risks are made substantially easier to exploit due to speculative execution. This will cover how cryptographic and other libraries dealing in high-value secrets need to be adapted to correctly defend against these attacks. Further, it will introduce general problems of sandboxing untrusted code from secret data and the current best techniques in those circumstances. 

This talk will be accessible to most C and C++ programmers. No deep background on CPUs, assembly, hardware instructions, Spectre, side-channels, or security is needed.
— 
Chandler Carruth, Google
Software Engineer

Chandler Carruth leads the Clang team at Google, building better diagnostics, tools, and more. Previously, he worked on several pieces of Google’s distributed build system. He makes guest appearances helping to maintain a few core C++ libraries across Google’s codebase, and is active in the LLVM and Clang open source communities. He received his M.S. and B.S. in Computer Science from Wake Forest University, but disavows all knowledge of the contents of his Master’s thesis. He is regularly found drinking Cherry Coke Zero in the daytime and pontificating over a single malt scotch in the evening.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,170 --> 00:00:10,880
[Music]

00:00:11,280 --> 00:00:16,110
so I'm sure that none of you really need

00:00:14,070 --> 00:00:18,779
an introduction for our closing plenary

00:00:16,110 --> 00:00:20,610
speaker I know everyone is really tired

00:00:18,779 --> 00:00:23,910
but if you could all get up some energy

00:00:20,610 --> 00:00:26,850
put it together for Chandler Carruth who

00:00:23,910 --> 00:00:28,800
is going to scare the heck out of us

00:00:26,850 --> 00:00:34,460
about the things that can get into our

00:00:28,800 --> 00:00:36,960
systems all right everybody

00:00:34,460 --> 00:00:38,969
how are folks doing folks like energized

00:00:36,960 --> 00:00:41,540
you sticking strong to the end of the

00:00:38,969 --> 00:00:43,710
conference no it's been a long week so

00:00:41,540 --> 00:00:45,930
I'm here to talk to you about Specter

00:00:43,710 --> 00:00:47,520
how many folks here do not know anything

00:00:45,930 --> 00:00:49,379
about Specter I have no idea why this is

00:00:47,520 --> 00:00:50,399
even an interesting talk it's okay you

00:00:49,379 --> 00:00:54,510
can put your hand out it's not a problem

00:00:50,399 --> 00:00:56,250
a few people so spectra is a big

00:00:54,510 --> 00:01:00,120
security issue that was kind of

00:00:56,250 --> 00:01:01,410
uncovered over a year ago and and it

00:01:00,120 --> 00:01:02,789
seemed really interesting to me to come

00:01:01,410 --> 00:01:05,850
and give a talk about this in part

00:01:02,789 --> 00:01:08,789
because last year I was up on a stage

00:01:05,850 --> 00:01:10,170
here giving a talk I was really hoping

00:01:08,789 --> 00:01:11,280
to actually roll the video for you but I

00:01:10,170 --> 00:01:13,560
don't think we managed to get all the

00:01:11,280 --> 00:01:15,360
technical issues sorted out here but the

00:01:13,560 --> 00:01:18,119
key thing here is the very last question

00:01:15,360 --> 00:01:19,799
in my talk last year I didn't give a

00:01:18,119 --> 00:01:21,510
very good answer to someone asked me

00:01:19,799 --> 00:01:23,759
well so the whole talk is about

00:01:21,510 --> 00:01:25,110
speculative execution if you haven't

00:01:23,759 --> 00:01:26,930
seen it it's great talk not to

00:01:25,110 --> 00:01:29,340
self-promote but it's a great talk and

00:01:26,930 --> 00:01:31,979
at the end of it when asked like well

00:01:29,340 --> 00:01:33,659
what happens to instructions that are

00:01:31,979 --> 00:01:37,100
expected to be executed if they would

00:01:33,659 --> 00:01:39,450
only crash or do something weird and

00:01:37,100 --> 00:01:41,820
very fortunately for me that was at the

00:01:39,450 --> 00:01:44,700
end of the talk I said that I don't know

00:01:41,820 --> 00:01:46,020
and I kind of blew it off and I said the

00:01:44,700 --> 00:01:50,939
session was over and we wrapped up for

00:01:46,020 --> 00:01:52,439
the day that's not a great response and

00:01:50,939 --> 00:01:56,759
so I'm gonna give you an entire talk

00:01:52,439 --> 00:01:58,740
instead before we get too far into it

00:01:56,759 --> 00:02:00,689
we've got to set some ground rules I'm

00:01:58,740 --> 00:02:02,790
talking about security issues today and

00:02:00,689 --> 00:02:04,350
I'm actually not a security person may

00:02:02,790 --> 00:02:07,079
not know this I don't I'm not a security

00:02:04,350 --> 00:02:08,790
expert and I'm not gonna know all of the

00:02:07,079 --> 00:02:10,950
answers that I'm talking about here okay

00:02:08,790 --> 00:02:12,900
and that's okay that's part of why a

00:02:10,950 --> 00:02:14,970
bunch of the Q&A is gonna be in a panel

00:02:12,900 --> 00:02:16,890
that we have after the talk so I can

00:02:14,970 --> 00:02:18,360
bring some other experts who've been

00:02:16,890 --> 00:02:19,810
working on Spectre with me and with a

00:02:18,360 --> 00:02:21,340
lot of other people in the industry

00:02:19,810 --> 00:02:24,459
up onto the stage and they can help me

00:02:21,340 --> 00:02:25,630
out in answering your questions but we

00:02:24,459 --> 00:02:29,140
need some ground rules because security

00:02:25,630 --> 00:02:30,489
can be tricky to talk about okay a good

00:02:29,140 --> 00:02:33,430
friend of mine who's also been working

00:02:30,489 --> 00:02:35,260
on this was at a conference and he was

00:02:33,430 --> 00:02:36,640
talking about security issues and they

00:02:35,260 --> 00:02:38,650
were having a great holiday conversation

00:02:36,640 --> 00:02:40,480
he ended up tweeting about you know like

00:02:38,650 --> 00:02:42,280
well I think I could probably attack

00:02:40,480 --> 00:02:45,099
this particular vulnerability this way

00:02:42,280 --> 00:02:47,019
and didn't really give a lot of context

00:02:45,099 --> 00:02:49,450
it was a tweet you know we've all made

00:02:47,019 --> 00:02:50,739
tweets without adequate context and so

00:02:49,450 --> 00:02:52,900
the you know Las Vegas police department

00:02:50,739 --> 00:02:55,150
came and talked to him about exactly why

00:02:52,900 --> 00:02:59,110
he was figuring out how to attack people

00:02:55,150 --> 00:03:00,459
at this conference it have a very long

00:02:59,110 --> 00:03:01,630
conversation with them I don't want any

00:03:00,459 --> 00:03:04,180
of you to have that conversation I don't

00:03:01,630 --> 00:03:05,650
want to have that conversation so we're

00:03:04,180 --> 00:03:07,239
gonna try and use careful words I don't

00:03:05,650 --> 00:03:08,650
really want to talk about exploiting

00:03:07,239 --> 00:03:10,989
things I want to talk about

00:03:08,650 --> 00:03:12,459
vulnerabilities okay I don't want to

00:03:10,989 --> 00:03:14,890
talk about attackers I want to talk

00:03:12,459 --> 00:03:16,299
about threat actors okay sometimes these

00:03:14,890 --> 00:03:17,590
people are actually white hats they're

00:03:16,299 --> 00:03:19,200
actually working for the good people

00:03:17,590 --> 00:03:21,610
they're trying to find vulnerabilities

00:03:19,200 --> 00:03:22,660
now I'm not going to be perfect but I

00:03:21,610 --> 00:03:24,370
just want to encourage people to really

00:03:22,660 --> 00:03:26,230
think about what words we use as we're

00:03:24,370 --> 00:03:28,000
talking about this stuff the other thing

00:03:26,230 --> 00:03:29,950
I got to tell you is unfortunately with

00:03:28,000 --> 00:03:32,170
the sensitive topic like security I am

00:03:29,950 --> 00:03:34,390
NOT gonna be able to say everything that

00:03:32,170 --> 00:03:35,680
I know okay I couldn't say it last year

00:03:34,390 --> 00:03:37,000
and I'm still not gonna be able to say

00:03:35,680 --> 00:03:38,920
everything I know I'm gonna do my very

00:03:37,000 --> 00:03:40,150
best but please understand when I have

00:03:38,920 --> 00:03:43,060
to cut you off or say like I'm really

00:03:40,150 --> 00:03:44,230
sorry I can't talk about that please be

00:03:43,060 --> 00:03:45,310
respectful understand I'm doing

00:03:44,230 --> 00:03:47,590
everything I can but there are

00:03:45,310 --> 00:03:49,540
restrictions these deal with you know

00:03:47,590 --> 00:03:51,400
issues spanning multiple companies right

00:03:49,540 --> 00:03:54,010
sometimes intellectual property issues

00:03:51,400 --> 00:03:55,480
and also security issues where we can't

00:03:54,010 --> 00:03:57,100
disclose things without kind of

00:03:55,480 --> 00:03:59,889
responsible time for people to get

00:03:57,100 --> 00:04:01,389
patched and that last point brings me to

00:03:59,889 --> 00:04:03,100
another thing if you're out here and

00:04:01,389 --> 00:04:05,470
there's some really brilliant people in

00:04:03,100 --> 00:04:08,109
the room I'm sure if you think I've got

00:04:05,470 --> 00:04:11,139
it I totally see this way more awesome

00:04:08,109 --> 00:04:13,540
way to break through that system to find

00:04:11,139 --> 00:04:15,700
a new vulnerability I would ask you

00:04:13,540 --> 00:04:18,340
don't come up to the microphone in

00:04:15,700 --> 00:04:20,799
public with that right here and now

00:04:18,340 --> 00:04:22,240
because none of the security people

00:04:20,799 --> 00:04:24,130
really like to have instantaneous

00:04:22,240 --> 00:04:25,870
disclosure they like responsible

00:04:24,130 --> 00:04:27,370
disclosure I'm happy to talk to you

00:04:25,870 --> 00:04:28,900
offline I'm happy to point you at other

00:04:27,370 --> 00:04:30,130
people who can talk to you offline and

00:04:28,900 --> 00:04:32,229
figure out how to go through that

00:04:30,130 --> 00:04:33,370
process now that's it I do want you to

00:04:32,229 --> 00:04:34,690
ask questions a

00:04:33,370 --> 00:04:35,770
especially at the panel please come up

00:04:34,690 --> 00:04:37,660
to the microphone with questions just

00:04:35,770 --> 00:04:39,100
understand if we if you have to push

00:04:37,660 --> 00:04:40,990
back a little bit we're doing what we

00:04:39,100 --> 00:04:42,250
can to try and keep this discussion at

00:04:40,990 --> 00:04:43,720
the right level because we're talking

00:04:42,250 --> 00:04:47,620
about very recent and very current

00:04:43,720 --> 00:04:49,870
events okay with that let's get started

00:04:47,620 --> 00:04:51,460
when I first started working on this I

00:04:49,870 --> 00:04:53,350
actually had a hard time even following

00:04:51,460 --> 00:04:55,300
the discussions I felt like I was a kid

00:04:53,350 --> 00:04:56,410
I didn't know what I was doing and a lot

00:04:55,300 --> 00:04:58,060
of that was because there's background

00:04:56,410 --> 00:05:00,190
and terminology that I simply didn't

00:04:58,060 --> 00:05:01,870
have I can't give you all of that I'm

00:05:00,190 --> 00:05:03,370
not even I don't have all of it myself

00:05:01,870 --> 00:05:05,080
I'm not a security researcher but I'm

00:05:03,370 --> 00:05:07,060
gonna try and give you enough for this

00:05:05,080 --> 00:05:09,490
talk first off we have vulnerabilities

00:05:07,060 --> 00:05:11,320
this is a common thing right is pretty

00:05:09,490 --> 00:05:13,300
obvious it's some way you can take a

00:05:11,320 --> 00:05:15,490
system and cause it to behave in an

00:05:13,300 --> 00:05:18,729
unexpected and unintended manner okay

00:05:15,490 --> 00:05:20,229
not too fancy but a gadget is a weird

00:05:18,729 --> 00:05:22,210
thing in a security context doing

00:05:20,229 --> 00:05:25,539
something very specific by the term

00:05:22,210 --> 00:05:28,479
gadget we mean some pattern of codes

00:05:25,539 --> 00:05:32,410
some some thing in a program that you

00:05:28,479 --> 00:05:34,300
can actually leverage to actually make a

00:05:32,410 --> 00:05:35,500
vulnerability work okay

00:05:34,300 --> 00:05:37,720
these tend to be the little building

00:05:35,500 --> 00:05:39,729
blocks of vulnerabilities so whenever we

00:05:37,720 --> 00:05:42,780
hear security people talking about a

00:05:39,729 --> 00:05:45,550
gadget in the code that's what we mean

00:05:42,780 --> 00:05:47,320
so now let's get to slightly more

00:05:45,550 --> 00:05:49,720
interesting terminology up an

00:05:47,320 --> 00:05:51,789
information leak this is a kind of

00:05:49,720 --> 00:05:54,340
vulnerability okay there's a very

00:05:51,789 --> 00:05:56,320
classic example heartbleed okay now what

00:05:54,340 --> 00:05:57,669
does it information leak do well it

00:05:56,320 --> 00:05:59,530
takes information that you shouldn't

00:05:57,669 --> 00:06:01,870
have access to and it gives you access

00:05:59,530 --> 00:06:02,919
to it but I don't think you know talking

00:06:01,870 --> 00:06:05,520
about it's the easiest way to figure

00:06:02,919 --> 00:06:08,139
this out let's see if we can actually

00:06:05,520 --> 00:06:11,740
show you what an information leak looks

00:06:08,139 --> 00:06:14,199
like okay hopefully my live demo

00:06:11,740 --> 00:06:16,180
actually works here so I've written

00:06:14,199 --> 00:06:17,770
probably the world's most simple

00:06:16,180 --> 00:06:21,669
information leak that you'll ever find

00:06:17,770 --> 00:06:23,650
okay we have some some lovely data here

00:06:21,669 --> 00:06:26,110
including hello world and hello all of

00:06:23,650 --> 00:06:27,699
you but we also have a secret okay

00:06:26,110 --> 00:06:30,400
something we don't want to share

00:06:27,699 --> 00:06:32,560
publicly and we have a main function

00:06:30,400 --> 00:06:34,180
it's going to go through and process

00:06:32,560 --> 00:06:36,099
some arguments right this could be just

00:06:34,180 --> 00:06:38,860
any old API that a tip that takes

00:06:36,099 --> 00:06:40,389
untrusted input and it tries to validate

00:06:38,860 --> 00:06:42,340
it right we try and make sure that you

00:06:40,389 --> 00:06:44,140
know we actually if we don't have the

00:06:42,340 --> 00:06:45,550
argument we give it a nice default right

00:06:44,140 --> 00:06:46,729
if we do we actually set it from the

00:06:45,550 --> 00:06:49,219
command line

00:06:46,729 --> 00:06:50,749
we we extract this length and then we

00:06:49,219 --> 00:06:52,759
even balance check it but we wrote our

00:06:50,749 --> 00:06:54,199
bounds check in a really funny way some

00:06:52,759 --> 00:06:56,029
of you may be reading this bounds check

00:06:54,199 --> 00:06:57,669
in just being like oh this isn't gonna

00:06:56,029 --> 00:06:59,689
end well for you buddy well

00:06:57,669 --> 00:07:01,270
unfortunately it's not let's take a look

00:06:59,689 --> 00:07:03,949
at how this actually works

00:07:01,270 --> 00:07:05,240
so if I run this program it doesn't do

00:07:03,949 --> 00:07:07,520
anything interesting it has defaults

00:07:05,240 --> 00:07:09,710
says hello world I don't like just

00:07:07,520 --> 00:07:11,689
talking to the world let's talk to you

00:07:09,710 --> 00:07:13,879
all of you all hi everybody

00:07:11,689 --> 00:07:16,490
right is this all fine we see we have a

00:07:13,879 --> 00:07:18,050
length of 13 that's our default now if I

00:07:16,490 --> 00:07:19,639
give it a small length it just truncates

00:07:18,050 --> 00:07:20,870
it off that's fine what happens if I

00:07:19,639 --> 00:07:24,740
give it too long of a length

00:07:20,870 --> 00:07:26,330
oh so this is this is because my bounds

00:07:24,740 --> 00:07:28,189
check isn't very good right and if I

00:07:26,330 --> 00:07:30,110
give it a long enough link length it's

00:07:28,189 --> 00:07:31,309
actually going to print out all of this

00:07:30,110 --> 00:07:32,960
secret okay

00:07:31,309 --> 00:07:34,569
now it wasn't intended I didn't write

00:07:32,960 --> 00:07:37,159
any code that would have allowed it

00:07:34,569 --> 00:07:39,110
naturally to go and read that secret I

00:07:37,159 --> 00:07:41,360
mean if I try and just give it a higher

00:07:39,110 --> 00:07:44,120
index right it's like no you can't read

00:07:41,360 --> 00:07:45,409
it okay but because there is a bug in my

00:07:44,120 --> 00:07:48,259
code I could have an information leak

00:07:45,409 --> 00:07:50,089
and this is this is literally the core

00:07:48,259 --> 00:07:53,779
bug behind heartbleed this is how

00:07:50,089 --> 00:07:55,629
heartbleed happened okay all right is

00:07:53,779 --> 00:07:58,459
everybody happy with information leaks

00:07:55,629 --> 00:08:00,139
let's talk about side channels a side

00:07:58,459 --> 00:08:02,060
channels is the next core component of

00:08:00,139 --> 00:08:04,669
this side channel is some way of

00:08:02,060 --> 00:08:07,069
conveying information using the natural

00:08:04,669 --> 00:08:08,899
behavior of the system okay without

00:08:07,069 --> 00:08:10,939
setting up some kind of explicit

00:08:08,899 --> 00:08:12,740
communication channel can we embed a

00:08:10,939 --> 00:08:15,110
communication inside of something that's

00:08:12,740 --> 00:08:18,229
already taking place that's routine and

00:08:15,110 --> 00:08:20,029
common and expected to take place you'll

00:08:18,229 --> 00:08:22,249
see in some discussions this gets kind

00:08:20,029 --> 00:08:24,289
of muddied with the term covert channel

00:08:22,249 --> 00:08:26,539
I don't particularly like the using that

00:08:24,289 --> 00:08:28,039
term for things like Spectre a covert

00:08:26,539 --> 00:08:29,330
channel I understand much better by

00:08:28,039 --> 00:08:31,999
thinking about old-fashioned spot over

00:08:29,330 --> 00:08:33,469
here like spy movies okay I've got some

00:08:31,999 --> 00:08:35,029
people who like spider all right covert

00:08:33,469 --> 00:08:36,680
channels like spy movies that's like

00:08:35,029 --> 00:08:39,019
what he's like okay when I raise my

00:08:36,680 --> 00:08:40,159
blinds on the third Wednesday of the

00:08:39,019 --> 00:08:43,430
month we meet

00:08:40,159 --> 00:08:45,319
that's a covert channel okay it's not a

00:08:43,430 --> 00:08:47,209
normal thing I'm not always raising and

00:08:45,319 --> 00:08:48,860
lowering my blinds right it's just that

00:08:47,209 --> 00:08:50,839
it doesn't look like a communication

00:08:48,860 --> 00:08:52,639
mechanism but it is intentionally set up

00:08:50,839 --> 00:08:54,920
as a communication mechanism and used

00:08:52,639 --> 00:08:56,240
for that purpose okay a side channel is

00:08:54,920 --> 00:08:57,319
not something we intentionally set up

00:08:56,240 --> 00:08:58,630
it's just something we can take

00:08:57,319 --> 00:09:00,970
advantage of that was already happening

00:08:58,630 --> 00:09:03,730
so let's look at a side channel

00:09:00,970 --> 00:09:06,400
again I think seeing this stuff is a lot

00:09:03,730 --> 00:09:08,230
better than just describing it so I

00:09:06,400 --> 00:09:09,850
built a little side channel demo for you

00:09:08,230 --> 00:09:11,470
all but unfortunately this is gonna be a

00:09:09,850 --> 00:09:13,180
lot more code so I'm gonna try and step

00:09:11,470 --> 00:09:14,530
through it it's ok if you don't

00:09:13,180 --> 00:09:16,090
understand everything like I said we're

00:09:14,530 --> 00:09:17,470
gonna have a whole panel but I'm gonna

00:09:16,090 --> 00:09:18,730
try and give you at least the gist of

00:09:17,470 --> 00:09:21,310
how this how this works

00:09:18,730 --> 00:09:23,710
so the first thing I have is a secret

00:09:21,310 --> 00:09:26,230
okay the secret is just a string it's

00:09:23,710 --> 00:09:28,630
nothing too fancy and I have some code

00:09:26,230 --> 00:09:31,060
that does force reading right and I have

00:09:28,630 --> 00:09:33,700
some timing code I have some random math

00:09:31,060 --> 00:09:36,610
code that's not super important the main

00:09:33,700 --> 00:09:39,700
body of this is this leak bytes thing

00:09:36,610 --> 00:09:42,700
okay the very first line of this up at

00:09:39,700 --> 00:09:44,860
the top I have a timing array and this

00:09:42,700 --> 00:09:47,080
timing array is a big array of memory

00:09:44,860 --> 00:09:49,630
that I can access in different ways to

00:09:47,080 --> 00:09:53,890
access different cache lines on a modern

00:09:49,630 --> 00:09:55,570
processor right now I then extract you

00:09:53,890 --> 00:09:56,980
know this this string view this nice

00:09:55,570 --> 00:10:00,040
string view which tells me about this

00:09:56,980 --> 00:10:01,570
this in bounds range of text and I built

00:10:00,040 --> 00:10:04,270
some data structures to collect

00:10:01,570 --> 00:10:06,400
information latency and scores and then

00:10:04,270 --> 00:10:08,530
we start runs and we do a bunch of runs

00:10:06,400 --> 00:10:12,160
until we get enough information to

00:10:08,530 --> 00:10:14,980
believe that we have actually found some

00:10:12,160 --> 00:10:17,020
information embedded in another medium

00:10:14,980 --> 00:10:19,300
in this case in a timing side channel

00:10:17,020 --> 00:10:21,790
okay first thing we do is we flush all

00:10:19,300 --> 00:10:24,910
of the memory then we force a read but

00:10:21,790 --> 00:10:28,000
not just any read okay we load the

00:10:24,910 --> 00:10:31,870
information out of data okay then we use

00:10:28,000 --> 00:10:33,820
that to access the timing array alright

00:10:31,870 --> 00:10:36,190
and we access it not just locally but it

00:10:33,820 --> 00:10:38,740
strides and so this means that for

00:10:36,190 --> 00:10:41,500
different values in this data array I'm

00:10:38,740 --> 00:10:44,830
gonna access different cache lines all

00:10:41,500 --> 00:10:47,140
right now then I have to go and see

00:10:44,830 --> 00:10:48,460
whether that was successful okay and in

00:10:47,140 --> 00:10:50,770
order to see whether it was successful I

00:10:48,460 --> 00:10:53,440
have a loop down here which kind of

00:10:50,770 --> 00:10:56,230
looks for which kind of shuffles the way

00:10:53,440 --> 00:10:58,720
I access memory and then accesses each

00:10:56,230 --> 00:11:02,140
and every cache line in this timing

00:10:58,720 --> 00:11:05,380
array does a read and computes the

00:11:02,140 --> 00:11:08,260
latency of that read okay this is just

00:11:05,380 --> 00:11:10,330
timing each cache line in a way that

00:11:08,260 --> 00:11:12,100
lets us see whether one of these cache

00:11:10,330 --> 00:11:14,230
lines was faster than all of the others

00:11:12,100 --> 00:11:16,270
because we've already accessed it we

00:11:14,230 --> 00:11:20,050
accessed it right before in in the

00:11:16,270 --> 00:11:22,150
previous loop make some sense and then

00:11:20,050 --> 00:11:23,410
we go and we find the average latency

00:11:22,150 --> 00:11:25,930
because we don't want it we don't want

00:11:23,410 --> 00:11:28,540
to hard-code any constants here we see

00:11:25,930 --> 00:11:29,920
if our if one of the Layton sees if one

00:11:28,540 --> 00:11:32,350
of the Layton sees for one of the cache

00:11:29,920 --> 00:11:34,630
lines was substantially below the

00:11:32,350 --> 00:11:36,760
average than we think cool that was

00:11:34,630 --> 00:11:39,520
probably a signal embedded in our timing

00:11:36,760 --> 00:11:41,080
side channel we bumped the score and if

00:11:39,520 --> 00:11:42,250
we get the score high enough down here

00:11:41,080 --> 00:11:44,920
at the bottom if you get the score high

00:11:42,250 --> 00:11:46,990
enough we gain confidence yeah we found

00:11:44,920 --> 00:11:50,500
our signal we've actually found the

00:11:46,990 --> 00:11:54,730
information make sense to folks alright

00:11:50,500 --> 00:11:59,770
so let's see how this works so if I run

00:11:54,730 --> 00:12:00,940
this that was pretty fast so if I run

00:11:59,770 --> 00:12:02,980
this you're gonna see it's gonna print

00:12:00,940 --> 00:12:04,360
out each of those characters okay and

00:12:02,980 --> 00:12:07,270
each one of those it's not actually

00:12:04,360 --> 00:12:10,960
looking at the character its timing the

00:12:07,270 --> 00:12:12,670
access to memory make some sense it's

00:12:10,960 --> 00:12:13,780
actually that simple there's not there's

00:12:12,670 --> 00:12:15,520
not more I don't have anything up my

00:12:13,780 --> 00:12:19,180
sleeves like I promised this is like a

00:12:15,520 --> 00:12:22,300
real this is a real demo okay do you

00:12:19,180 --> 00:12:23,920
have one more key pieces of you know

00:12:22,300 --> 00:12:26,110
quarter knowledge and that's speculative

00:12:23,920 --> 00:12:28,000
execution okay and we talked a lot about

00:12:26,110 --> 00:12:29,500
speculum execution in the talk I gave

00:12:28,000 --> 00:12:31,390
last year I'm not going to try and give

00:12:29,500 --> 00:12:33,400
you a full rundown on how processors do

00:12:31,390 --> 00:12:35,370
speculative execution the key thing is

00:12:33,400 --> 00:12:38,140
that it allows them to execute

00:12:35,370 --> 00:12:41,260
instructions way past what the program

00:12:38,140 --> 00:12:43,600
currently is at and sometimes with

00:12:41,260 --> 00:12:45,370
interesting assumptions because in order

00:12:43,600 --> 00:12:47,050
to execute further along than the

00:12:45,370 --> 00:12:49,300
program currently has the processor has

00:12:47,050 --> 00:12:51,430
to make predictions okay these

00:12:49,300 --> 00:12:52,360
predictions are really more like guesses

00:12:51,430 --> 00:12:54,610
okay

00:12:52,360 --> 00:12:56,500
and sometimes it guesses wrong and it

00:12:54,610 --> 00:12:58,330
makes an incorrect prediction but it

00:12:56,500 --> 00:13:02,710
continues to speculatively execute and

00:12:58,330 --> 00:13:05,860
it just unwinds all of that later but

00:13:02,710 --> 00:13:09,700
when you have this miss speculation and

00:13:05,860 --> 00:13:11,770
you combine it with a side channel it

00:13:09,700 --> 00:13:14,080
allows you to leak information that was

00:13:11,770 --> 00:13:16,480
only visible during that speculative

00:13:14,080 --> 00:13:19,240
execution okay and that specula Texa cue

00:13:16,480 --> 00:13:20,920
ssin may have occurred with strange and

00:13:19,240 --> 00:13:22,750
variants within variants simply not

00:13:20,920 --> 00:13:25,660
holding okay and so you can actually

00:13:22,750 --> 00:13:27,260
observe behavior from a program that

00:13:25,660 --> 00:13:29,120
violates the fundamental

00:13:27,260 --> 00:13:31,670
to invariance the program set up and

00:13:29,120 --> 00:13:32,330
that's Spectre and that's why Spectre so

00:13:31,670 --> 00:13:34,910
confusing

00:13:32,330 --> 00:13:37,850
you wrote the code and it clearly only

00:13:34,910 --> 00:13:40,280
does one thing but observation shows

00:13:37,850 --> 00:13:43,610
something else so let's see if we can we

00:13:40,280 --> 00:13:45,770
can map this on so my demo for this one

00:13:43,610 --> 00:13:48,230
is going to be essentially Specter v1

00:13:45,770 --> 00:13:50,780
but I've tried to make it as similar to

00:13:48,230 --> 00:13:52,610
the previous two demos as I could so

00:13:50,780 --> 00:13:54,350
just like last time I have a text table

00:13:52,610 --> 00:13:57,230
with three strings okay

00:13:54,350 --> 00:13:59,150
I've hard coded it to try and read using

00:13:57,230 --> 00:14:01,190
this second string we can jump down to

00:13:59,150 --> 00:14:03,950
the to the main function and you can see

00:14:01,190 --> 00:14:07,400
what it's actually doing here so we

00:14:03,950 --> 00:14:10,490
actually are going to always use this

00:14:07,400 --> 00:14:13,160
text table one alright that's the only

00:14:10,490 --> 00:14:15,470
thing we handle each byte we do not hand

00:14:13,160 --> 00:14:17,270
the second like the third entry in our

00:14:15,470 --> 00:14:19,490
text table to this routine and we handed

00:14:17,270 --> 00:14:21,950
a string view with a bound in it okay

00:14:19,490 --> 00:14:23,450
and then this loop is essentially

00:14:21,950 --> 00:14:26,570
computing an out of bounds

00:14:23,450 --> 00:14:29,000
index into this thing and we're passing

00:14:26,570 --> 00:14:30,440
this index but this eye is always going

00:14:29,000 --> 00:14:32,660
to be out of bounds right we're

00:14:30,440 --> 00:14:36,170
computing it based on a totally

00:14:32,660 --> 00:14:39,710
different string all right this index is

00:14:36,170 --> 00:14:41,180
never in balance so once we get up to

00:14:39,710 --> 00:14:42,650
the leak byte we have a slightly

00:14:41,180 --> 00:14:46,340
different routine we have the same setup

00:14:42,650 --> 00:14:50,030
with one small difference we put the

00:14:46,340 --> 00:14:51,620
size of our string view into memory this

00:14:50,030 --> 00:14:54,410
is me cheating so that it fits on a

00:14:51,620 --> 00:14:56,420
slide but the idea being that your size

00:14:54,410 --> 00:15:00,980
might not be sitting in a register it

00:14:56,420 --> 00:15:04,340
might be slow to access okay so then we

00:15:00,980 --> 00:15:06,380
have our runs now getting a good demo of

00:15:04,340 --> 00:15:08,360
this is a bit tricky one thing we need

00:15:06,380 --> 00:15:10,250
to do is we have to essentially train

00:15:08,360 --> 00:15:12,890
the entire system using correct

00:15:10,250 --> 00:15:15,830
executions before we can get it to

00:15:12,890 --> 00:15:19,760
predict an incorrect execution and so I

00:15:15,830 --> 00:15:21,470
build a safe index into my buffer of

00:15:19,760 --> 00:15:23,450
text right and this is this is always

00:15:21,470 --> 00:15:25,700
gonna be in bounds this index is totally

00:15:23,450 --> 00:15:27,590
fine all right but it's important to

00:15:25,700 --> 00:15:29,720
note like this this this index is not

00:15:27,590 --> 00:15:31,970
stable each run gets a different one

00:15:29,720 --> 00:15:33,770
it's not at all going to be useful for

00:15:31,970 --> 00:15:35,780
extracting any information from this

00:15:33,770 --> 00:15:38,480
routine the only thing is useful for is

00:15:35,780 --> 00:15:39,790
actually accessing my data in a safe

00:15:38,480 --> 00:15:40,850
manner

00:15:39,790 --> 00:15:44,449
the

00:15:40,850 --> 00:15:46,610
I'm going to flush the size out of my

00:15:44,449 --> 00:15:48,019
cache now it doesn't matter that I'm

00:15:46,610 --> 00:15:50,089
flushing it or doing something else all

00:15:48,019 --> 00:15:53,170
I really need to do is make size very

00:15:50,089 --> 00:15:55,550
slow to compute then I wait a while

00:15:53,170 --> 00:15:57,560
turns out that this little stall here is

00:15:55,550 --> 00:16:00,319
important or it doesn't sit in tend to

00:15:57,560 --> 00:16:02,149
work and I compute this weird local

00:16:00,319 --> 00:16:04,670
index now this local index is

00:16:02,149 --> 00:16:08,209
essentially the training and then the

00:16:04,670 --> 00:16:11,630
attack for the first nine runs we just

00:16:08,209 --> 00:16:13,970
access a perfectly safe index but then

00:16:11,630 --> 00:16:15,110
on the tenth run we switch to the index

00:16:13,970 --> 00:16:20,380
the user passed in

00:16:15,110 --> 00:16:22,550
okay so just nine good a tenth one bad

00:16:20,380 --> 00:16:25,940
then we do a balance check now want to

00:16:22,550 --> 00:16:28,160
be really clear we always do a balance

00:16:25,940 --> 00:16:30,199
check and this is a correct balance

00:16:28,160 --> 00:16:32,990
check we make sure that the index is

00:16:30,199 --> 00:16:35,569
smaller than the size and that means we

00:16:32,990 --> 00:16:37,850
will never access the data out of bounds

00:16:35,569 --> 00:16:38,959
here all right we hated it a string view

00:16:37,850 --> 00:16:41,569
a safe

00:16:38,959 --> 00:16:44,029
entity herb has told us all about how

00:16:41,569 --> 00:16:47,449
safe string view is but then when I come

00:16:44,029 --> 00:16:49,370
down here I'm going to access it using a

00:16:47,449 --> 00:16:53,029
local index and the problem is that this

00:16:49,370 --> 00:16:55,790
access right here using the index may

00:16:53,029 --> 00:16:58,399
happen speculatively and it may happen

00:16:55,790 --> 00:17:00,199
before the bounds check finishes and

00:16:58,399 --> 00:17:03,980
when the bounds check was going to fail

00:17:00,199 --> 00:17:07,459
right so it accesses an out-of-bounds

00:17:03,980 --> 00:17:09,589
piece of memory it uses that scaled up

00:17:07,459 --> 00:17:12,260
taxes the timing array then we read

00:17:09,589 --> 00:17:14,150
through that yet again and all of a

00:17:12,260 --> 00:17:16,400
sudden we have leaked information we've

00:17:14,150 --> 00:17:17,959
actually accessed our side Channel the

00:17:16,400 --> 00:17:19,459
rest of this is the exact same code

00:17:17,959 --> 00:17:21,350
right we go through and we measure all

00:17:19,459 --> 00:17:23,630
the times to see like yes did we in fact

00:17:21,350 --> 00:17:25,339
like find one of these cache lines being

00:17:23,630 --> 00:17:27,079
slower and if so we compute it there's

00:17:25,339 --> 00:17:31,150
nothing else different from this example

00:17:27,079 --> 00:17:33,580
in the previous one and when I run this

00:17:31,150 --> 00:17:37,010
it's actually going to print the string

00:17:33,580 --> 00:17:39,140
and we never accessed this memory okay

00:17:37,010 --> 00:17:40,669
like if I if I made this example a lot

00:17:39,140 --> 00:17:42,080
more complicated and moves that memory

00:17:40,669 --> 00:17:43,640
on to a separate page I could even

00:17:42,080 --> 00:17:45,380
protect the page so that any access

00:17:43,640 --> 00:17:46,520
would fault the program would run fine

00:17:45,380 --> 00:17:48,200
okay

00:17:46,520 --> 00:17:49,880
because we never access the memory

00:17:48,200 --> 00:17:53,630
directly we leaked it through a side

00:17:49,880 --> 00:17:54,100
channel so that is Specter okay I know

00:17:53,630 --> 00:17:55,660
this isn't

00:17:54,100 --> 00:17:58,510
cooked thing I just ran it on an Intel

00:17:55,660 --> 00:18:00,130
laptop here if we make really good time

00:17:58,510 --> 00:18:02,020
I'm happy to try and actually show you

00:18:00,130 --> 00:18:03,490
this actually working on a non Intel

00:18:02,020 --> 00:18:05,020
machine as well I have it but

00:18:03,490 --> 00:18:06,730
unfortunately we had some AV issues and

00:18:05,020 --> 00:18:08,440
so I'll have to sit here and type in

00:18:06,730 --> 00:18:10,960
passwords or half of like like half a

00:18:08,440 --> 00:18:12,990
minute it's not really fun so let's

00:18:10,960 --> 00:18:18,370
let's pretend of go back to to

00:18:12,990 --> 00:18:20,020
presentation so we've gone through and

00:18:18,370 --> 00:18:21,100
we've looked at all this specular

00:18:20,020 --> 00:18:22,750
execution we've looked at Specter and

00:18:21,100 --> 00:18:24,760
miss specular of execution but if this

00:18:22,750 --> 00:18:28,179
were just one issue maybe it wouldn't be

00:18:24,760 --> 00:18:30,100
that bad it isn't just one issue this is

00:18:28,179 --> 00:18:31,659
an entirely new class of security

00:18:30,100 --> 00:18:33,280
vulnerabilities no one had really

00:18:31,659 --> 00:18:35,320
thought about what would happen if you

00:18:33,280 --> 00:18:38,169
combine speculative execution and

00:18:35,320 --> 00:18:39,549
information leaks they had no idea that

00:18:38,169 --> 00:18:41,200
there was something interesting here and

00:18:39,549 --> 00:18:44,650
as a consequence we have had a

00:18:41,200 --> 00:18:46,450
tremendous new set of security issues

00:18:44,650 --> 00:18:49,090
coming in and I'm gonna try and give you

00:18:46,450 --> 00:18:51,490
a rough timeline of all of this so it

00:18:49,090 --> 00:18:54,250
started off last year in June when

00:18:51,490 --> 00:18:58,059
project 0 at Google informed vendors of

00:18:54,250 --> 00:19:00,280
various CPUs and other parties about the

00:18:58,059 --> 00:19:02,200
first two variants of specter which are

00:19:00,280 --> 00:19:05,039
called bounce check bypass and branch

00:19:02,200 --> 00:19:07,179
target injection or variants one and two

00:19:05,039 --> 00:19:09,190
all right then

00:19:07,179 --> 00:19:12,220
a few weeks later they found a third

00:19:09,190 --> 00:19:14,320
variant covariant three or rogue data

00:19:12,220 --> 00:19:17,230
cache load or much more popularly

00:19:14,320 --> 00:19:19,390
meltdown and vendors were working

00:19:17,230 --> 00:19:21,580
furiously for the rest of the time until

00:19:19,390 --> 00:19:23,470
January when these were finally

00:19:21,580 --> 00:19:24,970
disclosed publicly as variants one and

00:19:23,470 --> 00:19:27,159
two of Spectre and variant three of

00:19:24,970 --> 00:19:28,299
meltdown during this time period they

00:19:27,159 --> 00:19:29,799
were they were found by other

00:19:28,299 --> 00:19:32,590
researchers who were looking in the same

00:19:29,799 --> 00:19:33,640
areas kind of concurrently and all of

00:19:32,590 --> 00:19:34,929
the researchers could have held their

00:19:33,640 --> 00:19:37,030
findings in order to have a coordinated

00:19:34,929 --> 00:19:39,159
disclosure here that cause this was such

00:19:37,030 --> 00:19:40,570
a big and disruptive change to how

00:19:39,159 --> 00:19:42,880
people thought about security

00:19:40,570 --> 00:19:45,100
most of the companies working in this

00:19:42,880 --> 00:19:46,360
space actually didn't have teams set up

00:19:45,100 --> 00:19:48,549
in the right place or with the right

00:19:46,360 --> 00:19:50,289
expertise to even address these security

00:19:48,549 --> 00:19:52,570
issues so it was a very very disruptive

00:19:50,289 --> 00:19:54,010
and very challenging endeavor because it

00:19:52,570 --> 00:19:58,659
was the first time and a totally new

00:19:54,010 --> 00:20:00,340
experience but we weren't done so after

00:19:58,659 --> 00:20:01,809
this we started to see more things the

00:20:00,340 --> 00:20:04,900
next one was in March called branch

00:20:01,809 --> 00:20:06,640
scope a branch scope wasn't a new form

00:20:04,900 --> 00:20:07,480
of attack it was actually a new side

00:20:06,640 --> 00:20:09,040
channel

00:20:07,480 --> 00:20:10,570
instead of using cash timings that

00:20:09,040 --> 00:20:13,030
pointed out that you could use the

00:20:10,570 --> 00:20:15,340
branch predictor itself to exfiltrate

00:20:13,030 --> 00:20:18,130
data from inside a speculative execution

00:20:15,340 --> 00:20:20,680
to a normal execution just a different

00:20:18,130 --> 00:20:22,690
side channel we also started to see

00:20:20,680 --> 00:20:24,940
issues coming up which had nothing to do

00:20:22,690 --> 00:20:27,190
with Spectre but we're unfortunately

00:20:24,940 --> 00:20:28,720
often grouped with Spectre because this

00:20:27,190 --> 00:20:29,800
stuff is complicated I don't know that

00:20:28,720 --> 00:20:31,600
you all but I think this stuff is

00:20:29,800 --> 00:20:33,010
complicated the press thinks this stuff

00:20:31,600 --> 00:20:34,540
is complicated and they ended up merging

00:20:33,010 --> 00:20:37,030
things together understandably

00:20:34,540 --> 00:20:40,450
and so there were issues around pop and

00:20:37,030 --> 00:20:42,400
move SS which are weird Intel and x86

00:20:40,450 --> 00:20:44,530
instructions that have a surprising

00:20:42,400 --> 00:20:46,780
semantic property that essentially every

00:20:44,530 --> 00:20:49,510
operating system vendor failed to notice

00:20:46,780 --> 00:20:51,700
when reading the spec and unfortunately

00:20:49,510 --> 00:20:53,590
those bugs persisted for a long time but

00:20:51,700 --> 00:20:55,390
now that people were looking at CPUs and

00:20:53,590 --> 00:20:57,130
CPU of ulnar abilities they were able to

00:20:55,390 --> 00:20:57,910
uncover these and get them fixed they

00:20:57,130 --> 00:21:00,400
don't have anything to do with

00:20:57,910 --> 00:21:02,800
speculative execution or Spectre there's

00:21:00,400 --> 00:21:04,480
also glitch again doesn't have anything

00:21:02,800 --> 00:21:07,180
to do aspect of execution on CPUs

00:21:04,480 --> 00:21:10,030
inspector but there was another

00:21:07,180 --> 00:21:10,420
interesting one in May and this is two

00:21:10,030 --> 00:21:15,340
things

00:21:10,420 --> 00:21:18,760
a variant 3a was was a very kind of

00:21:15,340 --> 00:21:21,580
obscure variation on variant 3 and and

00:21:18,760 --> 00:21:23,350
then variant for variant 4 was really

00:21:21,580 --> 00:21:24,400
interesting and I mean really

00:21:23,350 --> 00:21:27,580
interesting this one's called

00:21:24,400 --> 00:21:29,380
speculative store bypass this was also

00:21:27,580 --> 00:21:31,870
discovered by project 0 and by other

00:21:29,380 --> 00:21:33,820
researchers concurrently and and this

00:21:31,870 --> 00:21:36,070
one made Specter even worse than it

00:21:33,820 --> 00:21:38,020
already was and so this is really kind

00:21:36,070 --> 00:21:41,320
of amplified everything we were dealing

00:21:38,020 --> 00:21:43,330
with and we still weren't done the next

00:21:41,320 --> 00:21:46,690
issue is we're lazy FPU save and restore

00:21:43,330 --> 00:21:49,360
which we saw in June this was super easy

00:21:46,690 --> 00:21:50,860
to fix it's kind of a legacy thing that

00:21:49,360 --> 00:21:52,330
hadn't been turned off everywhere it

00:21:50,860 --> 00:21:53,170
should have been and it turns out

00:21:52,330 --> 00:21:55,240
there's a bug

00:21:53,170 --> 00:21:57,520
during speculative execution you may be

00:21:55,240 --> 00:21:59,470
able to access FP you state that the

00:21:57,520 --> 00:22:01,900
operating system has kind of left there

00:21:59,470 --> 00:22:03,790
from when the previous process was

00:22:01,900 --> 00:22:05,680
running with the idea being that it

00:22:03,790 --> 00:22:07,270
hasn't you know it's good at rap if you

00:22:05,680 --> 00:22:10,090
actually access it and once it traps

00:22:07,270 --> 00:22:11,800
it'll say that it'll restore your FPU

00:22:10,090 --> 00:22:14,410
state and then let your execution

00:22:11,800 --> 00:22:16,360
proceed but the trap happens after

00:22:14,410 --> 00:22:18,910
speculative execution and so you can

00:22:16,360 --> 00:22:20,860
speculate right past it access the FPU

00:22:18,910 --> 00:22:22,659
state and leak it

00:22:20,860 --> 00:22:24,429
now this is an arbitrary memory but it

00:22:22,659 --> 00:22:27,309
ends up still being fairly scary because

00:22:24,429 --> 00:22:29,169
inside of the FPU state includes you

00:22:27,309 --> 00:22:31,419
know things that are part of that are

00:22:29,169 --> 00:22:33,250
they're used by Intel's encryption

00:22:31,419 --> 00:22:36,279
instructions and so you would actually

00:22:33,250 --> 00:22:37,960
put private key data in the exact place

00:22:36,279 --> 00:22:40,299
that you leaved which was really

00:22:37,960 --> 00:22:42,070
unfortunate again this was mostly a

00:22:40,299 --> 00:22:44,890
legacy thing very quickly and easily

00:22:42,070 --> 00:22:46,240
turned off Intel and other vendors have

00:22:44,890 --> 00:22:47,890
been providing better mechanisms than

00:22:46,240 --> 00:22:49,380
this for a long time but we hadn't

00:22:47,890 --> 00:22:52,750
turned it off everywhere that we needed

00:22:49,380 --> 00:22:54,909
we got another kind of mistaken entity

00:22:52,750 --> 00:22:56,559
in this we got a new side channel attack

00:22:54,909 --> 00:22:58,330
that had nothing to do a spectrum of

00:22:56,559 --> 00:23:00,070
execution this is just a traditional

00:22:58,330 --> 00:23:02,649
side channel attack on cryptographic

00:23:00,070 --> 00:23:04,090
libraries called teal bleed it's a very

00:23:02,649 --> 00:23:05,559
interesting attack is very interesting

00:23:04,090 --> 00:23:10,659
research but it doesn't have a lot to do

00:23:05,559 --> 00:23:13,149
a Spectre and apparently I have ok so

00:23:10,659 --> 00:23:14,710
then then in July we start to solve even

00:23:13,149 --> 00:23:16,769
more interesting things in my opinion

00:23:14,710 --> 00:23:18,940
even more interesting things coming up

00:23:16,769 --> 00:23:23,200
so this one these ones are called

00:23:18,940 --> 00:23:26,230
variants 1.1 1.2 0 and 1.21 or

00:23:23,200 --> 00:23:28,240
collectively bounds check bypass store

00:23:26,230 --> 00:23:29,980
which is a kind of a mouthful but this

00:23:28,240 --> 00:23:32,260
was a big big thing this essentially

00:23:29,980 --> 00:23:34,960
extended variant one in really exciting

00:23:32,260 --> 00:23:37,120
ways that we're gonna look at then later

00:23:34,960 --> 00:23:39,399
in July we got still more good news we

00:23:37,120 --> 00:23:42,630
got to hear about Specter rsb and rep 2

00:23:39,399 --> 00:23:45,309
spec yet more variations on this and

00:23:42,630 --> 00:23:47,440
then in July we got the worst news for

00:23:45,309 --> 00:23:49,840
me at least which was a net Specter net

00:23:47,440 --> 00:23:52,000
Spectre was not a new voluntary was not

00:23:49,840 --> 00:23:55,240
a new variation on Spectre it was a

00:23:52,000 --> 00:23:56,830
really exemplary demonstration that all

00:23:55,240 --> 00:24:00,429
of the Spectre things we were looking at

00:23:56,830 --> 00:24:03,039
can be leveraged remotely it does not

00:24:00,429 --> 00:24:07,809
require local access so the net Spectre

00:24:03,039 --> 00:24:09,789
paper actually used this remotely ok

00:24:07,809 --> 00:24:12,399
oh sorry and one more thing l1 Terminal

00:24:09,789 --> 00:24:14,320
fault this one was extremely scary but

00:24:12,399 --> 00:24:16,330
fortunately has relatively little impact

00:24:14,320 --> 00:24:17,559
outside of operating system vendors so

00:24:16,330 --> 00:24:19,720
we're not going to spend too much time

00:24:17,559 --> 00:24:22,659
on that one but there was yet another

00:24:19,720 --> 00:24:24,850
one that happened pretty recently now I

00:24:22,659 --> 00:24:26,769
don't think this that we're over ok this

00:24:24,850 --> 00:24:28,990
this timelines going to keep going as

00:24:26,769 --> 00:24:30,730
time passes we're going to keep seeing

00:24:28,990 --> 00:24:32,679
more things come up as the researchers

00:24:30,730 --> 00:24:34,330
and the vendors kind of explore this new

00:24:32,679 --> 00:24:36,309
space so you should not expect this

00:24:34,330 --> 00:24:37,899
to stop that doesn't mean that the sky

00:24:36,309 --> 00:24:39,309
is falling it's just that we have to

00:24:37,899 --> 00:24:41,200
keep exploring the space and

00:24:39,309 --> 00:24:42,549
understanding the security issues within

00:24:41,200 --> 00:24:45,070
it alright and this is gonna keep going

00:24:42,549 --> 00:24:47,049
for some time but for now let's try and

00:24:45,070 --> 00:24:48,730
dig into these things and understand how

00:24:47,049 --> 00:24:50,980
they work in a little bit more detail

00:24:48,730 --> 00:24:53,710
especially outside of the one example

00:24:50,980 --> 00:24:55,149
that I've kind of shown you already so

00:24:53,710 --> 00:24:56,890
look at the broader scope of variant 1

00:24:55,149 --> 00:24:58,720
because variant 1 I've shown you just by

00:24:56,890 --> 00:25:00,279
passing a balanced check but variant 1

00:24:58,720 --> 00:25:03,370
is actually a much more general problem

00:25:00,279 --> 00:25:07,240
any predicate that the processor can

00:25:03,370 --> 00:25:10,750
predict can be bypassed okay and if that

00:25:07,240 --> 00:25:12,309
predicate guards unexpected behavior by

00:25:10,750 --> 00:25:15,519
setting up some invariants or

00:25:12,309 --> 00:25:18,159
assumptions which most predicates do you

00:25:15,519 --> 00:25:20,769
may have very surprising consequences so

00:25:18,159 --> 00:25:22,889
as an example we might have a small

00:25:20,769 --> 00:25:24,490
string a small string optimized

00:25:22,889 --> 00:25:25,870
representation here where we have a

00:25:24,490 --> 00:25:28,899
different representation for a long

00:25:25,870 --> 00:25:31,240
string and a short string now up here we

00:25:28,899 --> 00:25:33,220
have a predicate like is this long is

00:25:31,240 --> 00:25:35,260
this in the long representation and you

00:25:33,220 --> 00:25:36,669
might actually train and like the branch

00:25:35,260 --> 00:25:38,950
predictor might think this is probably

00:25:36,669 --> 00:25:40,870
long right or it might think this is

00:25:38,950 --> 00:25:42,130
probably short turns out short strings

00:25:40,870 --> 00:25:43,149
are the most common cases the branch

00:25:42,130 --> 00:25:45,580
feature will predict that this is

00:25:43,149 --> 00:25:47,200
probably going to be short unfortunately

00:25:45,580 --> 00:25:49,480
a lot of short string optimization

00:25:47,200 --> 00:25:51,760
strings the pointer to the short string

00:25:49,480 --> 00:25:54,130
is inside the object itself often on the

00:25:51,760 --> 00:25:55,659
stack right where there are other things

00:25:54,130 --> 00:25:57,429
that are really really interesting to

00:25:55,659 --> 00:26:00,130
look at adjacent to the string object

00:25:57,429 --> 00:26:01,750
and so if we predict that this is short

00:26:00,130 --> 00:26:03,669
we're going to get the short pointer

00:26:01,750 --> 00:26:05,590
who's actually just a pointer to the

00:26:03,669 --> 00:26:07,419
stack and we're going to start

00:26:05,590 --> 00:26:10,389
speculating on it and if we speculate

00:26:07,419 --> 00:26:14,980
far enough to find some some information

00:26:10,389 --> 00:26:17,110
link this can be exploited ok then you

00:26:14,980 --> 00:26:18,700
have another interesting case what about

00:26:17,110 --> 00:26:21,399
virtual functions what about type

00:26:18,700 --> 00:26:23,590
hierarchies so here we have a type

00:26:21,399 --> 00:26:26,019
hierarchy we have some base class for

00:26:23,590 --> 00:26:27,789
implementing key data and hashing of the

00:26:26,019 --> 00:26:29,380
key data right and then we have public

00:26:27,789 --> 00:26:30,789
keys where we don't have to worry about

00:26:29,380 --> 00:26:32,200
leaking the public key you only have a

00:26:30,789 --> 00:26:35,500
private key or you have to worry about

00:26:32,200 --> 00:26:37,630
leaking the key data now we have this

00:26:35,500 --> 00:26:39,580
virtual dispatch here and what happens

00:26:37,630 --> 00:26:41,649
if we've been hashing public keys over

00:26:39,580 --> 00:26:43,270
and over and over again and then we

00:26:41,649 --> 00:26:46,000
predict that in fact we think we have

00:26:43,270 --> 00:26:47,120
another public key when we don't we may

00:26:46,000 --> 00:26:50,360
dispatch to the wrong route

00:26:47,120 --> 00:26:52,850
- the non-constant time one speculate it

00:26:50,360 --> 00:26:54,920
and run right across the cryptography

00:26:52,850 --> 00:26:56,600
bug that this whole thing was designed

00:26:54,920 --> 00:26:58,850
to prevent okay

00:26:56,600 --> 00:27:01,610
again the invariance you expect in your

00:26:58,850 --> 00:27:03,500
software don't hold one speculative

00:27:01,610 --> 00:27:06,770
execution starts that's what makes it so

00:27:03,500 --> 00:27:08,780
hard to reason about there are also

00:27:06,770 --> 00:27:09,950
other variant one derivatives so far

00:27:08,780 --> 00:27:12,380
we've looked at cases where you

00:27:09,950 --> 00:27:15,110
speculate passed some predicates and you

00:27:12,380 --> 00:27:17,570
immediately find an information leak but

00:27:15,110 --> 00:27:19,670
there aren't that many information leak

00:27:17,570 --> 00:27:21,520
code patterns in your software maybe and

00:27:19,670 --> 00:27:26,660
so that might be relatively rare but

00:27:21,520 --> 00:27:28,790
that's where the the variance 1.1 1.2 or

00:27:26,660 --> 00:27:32,000
call or the bounds check bypass variance

00:27:28,790 --> 00:27:34,610
came into the picture so here we have

00:27:32,000 --> 00:27:36,980
some delightful code right which has

00:27:34,610 --> 00:27:39,380
some untrusted size we're gonna come in

00:27:36,980 --> 00:27:41,720
we're gonna have an out-of-bounds access

00:27:39,380 --> 00:27:43,910
here and once we have this out-of-bounds

00:27:41,720 --> 00:27:47,270
access we're actually going to copy into

00:27:43,910 --> 00:27:49,300
a local buffer on our stack data that

00:27:47,270 --> 00:27:52,420
has been given to us by the attacker

00:27:49,300 --> 00:27:55,580
okay because we've got an out of bounds

00:27:52,420 --> 00:27:58,730
store that we can also specularly

00:27:55,580 --> 00:28:01,630
execute okay so this speculatively

00:27:58,730 --> 00:28:04,850
stores attacker data over the stack and

00:28:01,630 --> 00:28:06,290
if this happens then later on we're

00:28:04,850 --> 00:28:07,850
going to potentially return from this

00:28:06,290 --> 00:28:10,610
function and we return from this

00:28:07,850 --> 00:28:12,470
function the return address is stored on

00:28:10,610 --> 00:28:14,480
the stack but we've speculatively

00:28:12,470 --> 00:28:17,210
written over it this is a classic stack

00:28:14,480 --> 00:28:20,750
smashing bug now come back to haunt us

00:28:17,210 --> 00:28:22,520
in the speculative domain okay even

00:28:20,750 --> 00:28:23,990
though the bounds check is correct it

00:28:22,520 --> 00:28:26,300
didn't help we were still able to

00:28:23,990 --> 00:28:28,340
conduct a speculative stack smash and

00:28:26,300 --> 00:28:30,290
this in speculative execution to an

00:28:28,340 --> 00:28:30,800
arbitrary address controlled by the

00:28:30,290 --> 00:28:35,870
attacker

00:28:30,800 --> 00:28:38,210
okay Oh probably one it's important to

00:28:35,870 --> 00:28:39,770
really think about flying sending

00:28:38,210 --> 00:28:43,100
control to an arbitrary address is so

00:28:39,770 --> 00:28:44,690
scary so we've had bugs involving stack

00:28:43,100 --> 00:28:46,730
smashing forever it's one of the most

00:28:44,690 --> 00:28:48,230
common security vulnerabilities but once

00:28:46,730 --> 00:28:50,600
you do that you tend to want to you know

00:28:48,230 --> 00:28:52,880
build some kind of remote code execution

00:28:50,600 --> 00:28:55,310
you want to build logic and trigger

00:28:52,880 --> 00:28:57,650
logic out of that the best way to do

00:28:55,310 --> 00:28:59,149
this is to find the logic you want

00:28:57,650 --> 00:29:01,279
inside the existing

00:28:59,149 --> 00:29:03,769
execute Apple and just send the return

00:29:01,279 --> 00:29:05,029
to that location okay

00:29:03,769 --> 00:29:08,389
this is called return oriented

00:29:05,029 --> 00:29:10,729
programming right you take the binary

00:29:08,389 --> 00:29:12,830
and you analyze all of the code patterns

00:29:10,729 --> 00:29:14,719
in the binary to find little pieces of

00:29:12,830 --> 00:29:17,029
code that implement the functionality

00:29:14,719 --> 00:29:20,179
you want and then you string them

00:29:17,029 --> 00:29:21,799
together with returns by smashing the

00:29:20,179 --> 00:29:23,330
stack and going to the first one which

00:29:21,799 --> 00:29:25,729
does something and then goes the second

00:29:23,330 --> 00:29:27,289
one and so on and so on the most amazing

00:29:25,729 --> 00:29:28,729
thing to me again I'm not a security

00:29:27,289 --> 00:29:30,259
researcher so when I heard about this it

00:29:28,729 --> 00:29:32,089
just like blew my mind

00:29:30,259 --> 00:29:34,009
all right the most amazing thing is that

00:29:32,089 --> 00:29:38,929
some very very delightful individuals

00:29:34,009 --> 00:29:41,210
have built a compiler that analyzes an

00:29:38,929 --> 00:29:44,929
arbitrary binary to build a Turing

00:29:41,210 --> 00:29:47,330
complete set of these gadgets and then

00:29:44,929 --> 00:29:49,969
emit a particular set of you know data

00:29:47,330 --> 00:29:54,169
values and in a start point which can

00:29:49,969 --> 00:29:56,179
implement any program which is a little

00:29:54,169 --> 00:29:58,700
bit frustrating and then you realize

00:29:56,179 --> 00:30:01,129
that it's actually easier in the

00:29:58,700 --> 00:30:03,889
speculative domain it doesn't matter if

00:30:01,129 --> 00:30:05,749
it crashes after I do my information

00:30:03,889 --> 00:30:07,460
leak for a real code execution I don't

00:30:05,749 --> 00:30:09,229
just have to you know execute the code I

00:30:07,460 --> 00:30:11,419
want you also probably want to keep the

00:30:09,229 --> 00:30:12,919
service running for a while like I want

00:30:11,419 --> 00:30:15,559
to like like set it aside and not

00:30:12,919 --> 00:30:15,739
disturb it too much don't need to do

00:30:15,559 --> 00:30:17,599
that

00:30:15,739 --> 00:30:20,029
I just need to hit my information leak

00:30:17,599 --> 00:30:22,549
you can do whatever at once crash can do

00:30:20,029 --> 00:30:24,859
anything all right and this means if the

00:30:22,549 --> 00:30:27,320
attacker can get to this return they're

00:30:24,859 --> 00:30:29,389
done okay they have so much power

00:30:27,320 --> 00:30:31,820
because you have this long history of

00:30:29,389 --> 00:30:33,919
work figuring out how to use this return

00:30:31,820 --> 00:30:38,960
to do really really bad stuff to the

00:30:33,919 --> 00:30:40,249
program makes sense all right but there

00:30:38,960 --> 00:30:42,289
are more ways you can you can do this

00:30:40,249 --> 00:30:44,570
you can imagine you have again some some

00:30:42,289 --> 00:30:47,389
type with some virtual interface right

00:30:44,570 --> 00:30:50,299
and you have this virtual function you

00:30:47,389 --> 00:30:52,849
created on your stack right but then you

00:30:50,299 --> 00:30:54,499
you you process some code also on the

00:30:52,849 --> 00:30:57,409
stack but with an attacker controlled

00:30:54,499 --> 00:31:00,200
offset that may be mispredicted and then

00:30:57,409 --> 00:31:01,700
you're going to use that offset to index

00:31:00,200 --> 00:31:03,080
and this can index from one object on

00:31:01,700 --> 00:31:04,309
the stack to another because it can go

00:31:03,080 --> 00:31:07,369
out of balance because we're in the

00:31:04,309 --> 00:31:09,139
spectrum of execution all right and then

00:31:07,369 --> 00:31:11,389
we can potentially write attacker data

00:31:09,139 --> 00:31:12,960
over the stack and this might write over

00:31:11,389 --> 00:31:15,390
the actual V pointer

00:31:12,960 --> 00:31:17,640
points the vtable for this object again

00:31:15,390 --> 00:31:19,740
speculatively it's all gonna get rolled

00:31:17,640 --> 00:31:21,720
back eventually but if we then hand

00:31:19,740 --> 00:31:25,050
control off to some other function and

00:31:21,720 --> 00:31:27,330
this other function doesn't use the the

00:31:25,050 --> 00:31:29,430
derived type it uses the base class to

00:31:27,330 --> 00:31:31,920
access it it's going to use that virtue

00:31:29,430 --> 00:31:33,660
that V pointer to load the virtual table

00:31:31,920 --> 00:31:35,610
to load a function out of it and call

00:31:33,660 --> 00:31:37,380
that but you just got to point it at any

00:31:35,610 --> 00:31:39,840
memory you want which means you get to

00:31:37,380 --> 00:31:41,880
send this virtual function call anywhere

00:31:39,840 --> 00:31:43,860
you want and the speculative domain it's

00:31:41,880 --> 00:31:45,630
just like the return except this time

00:31:43,860 --> 00:31:46,620
with the virtual function call and I can

00:31:45,630 --> 00:31:48,570
keep going there are a bunch of

00:31:46,620 --> 00:31:52,950
different permutations of how you can

00:31:48,570 --> 00:31:54,870
hijack control flow here okay but the

00:31:52,950 --> 00:31:56,880
easiest way to hijack control flow and

00:31:54,870 --> 00:31:59,670
send it to your information leak gadget

00:31:56,880 --> 00:32:03,180
was in variant 2 and this is y variate 2

00:31:59,670 --> 00:32:05,370
was extra scary until I got mitigated so

00:32:03,180 --> 00:32:08,640
very to work something like this right

00:32:05,370 --> 00:32:10,770
again we have our our class hierarchy

00:32:08,640 --> 00:32:12,090
right we have some or sorry no class

00:32:10,770 --> 00:32:14,400
sorry we have a function pointer here

00:32:12,090 --> 00:32:16,080
just any any indirect function called

00:32:14,400 --> 00:32:19,200
doesn't matter how you get there we're

00:32:16,080 --> 00:32:20,580
gonna call through it well how does this

00:32:19,200 --> 00:32:22,200
actually get implemented in the hardware

00:32:20,580 --> 00:32:24,060
to really understand right - we've got

00:32:22,200 --> 00:32:25,830
to start dropping down a few layers into

00:32:24,060 --> 00:32:27,930
hardware so we're gonna drop into x86

00:32:25,830 --> 00:32:30,450
assembly at this point I mean this is

00:32:27,930 --> 00:32:33,420
actually the x86 assembly produced by

00:32:30,450 --> 00:32:36,800
clang you know a little while ago for

00:32:33,420 --> 00:32:39,630
that see flex equals plus code ok and

00:32:36,800 --> 00:32:41,520
right here we have this cul with the

00:32:39,630 --> 00:32:43,830
weird syntax we're actually calling at a

00:32:41,520 --> 00:32:46,140
like through memory what this is doing

00:32:43,830 --> 00:32:48,000
it's actually loading an address out of

00:32:46,140 --> 00:32:49,680
the virtual tape sorry out of the stitch

00:32:48,000 --> 00:32:52,470
function and then calling through it

00:32:49,680 --> 00:32:54,360
right this is an indirect call now this

00:32:52,470 --> 00:32:56,010
is really hard on the processor because

00:32:54,360 --> 00:32:57,990
it doesn't know where this call is going

00:32:56,010 --> 00:32:59,300
to go and it wants to predict it that's

00:32:57,990 --> 00:33:01,950
how he got into speculative execution

00:32:59,300 --> 00:33:05,730
but the implementation of this predictor

00:33:01,950 --> 00:33:07,500
has a special problem this is my world's

00:33:05,730 --> 00:33:08,850
worst diagram for it but it gets the

00:33:07,500 --> 00:33:11,090
point across the implementation of this

00:33:08,850 --> 00:33:13,470
predictor is essentially a hash table

00:33:11,090 --> 00:33:15,540
okay it's a hash table that maps from

00:33:13,470 --> 00:33:18,390
the program counter or the instruction

00:33:15,540 --> 00:33:20,940
pointer of the in direct call to a

00:33:18,390 --> 00:33:23,070
particular target did you want that we

00:33:20,940 --> 00:33:25,980
want to predict but it doesn't map it to

00:33:23,070 --> 00:33:26,640
the actual target address oh no it maps

00:33:25,980 --> 00:33:29,190
it to a

00:33:26,640 --> 00:33:31,020
relative displacement from the current

00:33:29,190 --> 00:33:33,240
location because that's smaller we can

00:33:31,020 --> 00:33:34,350
encode that in much a lot fewer bits

00:33:33,240 --> 00:33:36,840
okay

00:33:34,350 --> 00:33:38,400
and then you realize something else this

00:33:36,840 --> 00:33:40,050
is a really size constraint thing this

00:33:38,400 --> 00:33:42,120
is literally a hash table implemented in

00:33:40,050 --> 00:33:44,280
silicon right and so in order to

00:33:42,120 --> 00:33:47,640
implement this the the hash function

00:33:44,280 --> 00:33:50,160
actually has to reduce this key by a lot

00:33:47,640 --> 00:33:51,840
it doesn't use most of the bits and the

00:33:50,160 --> 00:33:53,610
hash functions really straightforward in

00:33:51,840 --> 00:33:55,440
a lot of cases and so there are

00:33:53,610 --> 00:33:57,330
collisions in these hash tables all the

00:33:55,440 --> 00:33:59,370
time they're tiny you would expect

00:33:57,330 --> 00:34:01,380
collisions and that's okay so all those

00:33:59,370 --> 00:34:04,710
collisions are infrequent enough the

00:34:01,380 --> 00:34:06,870
performance is still good but if you can

00:34:04,710 --> 00:34:08,730
kind of try out the collisions long

00:34:06,870 --> 00:34:11,850
enough you can figure out how to cause a

00:34:08,730 --> 00:34:13,919
collision reliably in this hash table if

00:34:11,850 --> 00:34:17,100
you can cause a collision reliably you

00:34:13,919 --> 00:34:20,640
can train this predictor to go to your

00:34:17,100 --> 00:34:22,350
displacement okay and then when we do

00:34:20,640 --> 00:34:24,179
this call we look up in the hash table

00:34:22,350 --> 00:34:25,710
we hit a collision we get the wrong

00:34:24,179 --> 00:34:27,929
displacement and we go to the wrong

00:34:25,710 --> 00:34:29,909
location and it turns out this is really

00:34:27,929 --> 00:34:31,919
easy the only thing you have to have in

00:34:29,909 --> 00:34:34,710
the victim code here is an indirect call

00:34:31,919 --> 00:34:36,450
right and that's everywhere or even just

00:34:34,710 --> 00:34:38,040
a jump table for it to implement a

00:34:36,450 --> 00:34:40,080
switch is it enough to trigger the same

00:34:38,040 --> 00:34:42,240
behavior that makes this really really

00:34:40,080 --> 00:34:44,220
easy to exploit and actually take and

00:34:42,240 --> 00:34:47,159
sin control flow to wherever you want

00:34:44,220 --> 00:34:51,270
but it's worse than that there's another

00:34:47,159 --> 00:34:54,540
kind of indirect branch in in x86 code

00:34:51,270 --> 00:34:56,130
if you have a return so returns on x86

00:34:54,540 --> 00:34:58,530
get implemented with instruction

00:34:56,130 --> 00:35:00,570
sequences that look like this and again

00:34:58,530 --> 00:35:02,790
we don't have a specific destination

00:35:00,570 --> 00:35:04,890
here right the destinations in memory

00:35:02,790 --> 00:35:06,630
it's on the stack and so when you won't

00:35:04,890 --> 00:35:09,510
go to return the processor has to

00:35:06,630 --> 00:35:11,490
predict it somehow now for calls it

00:35:09,510 --> 00:35:13,320
returns two processors all have very

00:35:11,490 --> 00:35:15,000
specialized predictors that are super

00:35:13,320 --> 00:35:17,430
super accurate typically called the

00:35:15,000 --> 00:35:19,680
return stack buffer unfortunately

00:35:17,430 --> 00:35:21,090
sometimes these predictors run out they

00:35:19,680 --> 00:35:23,520
may not have enough information to

00:35:21,090 --> 00:35:26,460
predict it and on some processors when

00:35:23,520 --> 00:35:28,980
that happens they fall back to the exact

00:35:26,460 --> 00:35:31,620
same hash table solution as we solve for

00:35:28,980 --> 00:35:33,300
virtual calls and for jump tables and so

00:35:31,620 --> 00:35:35,490
even a return cane in some cases

00:35:33,300 --> 00:35:36,870
triggered this behavior all right and

00:35:35,490 --> 00:35:39,380
that means it's actually pretty easy to

00:35:36,870 --> 00:35:42,140
find these in code

00:35:39,380 --> 00:35:44,330
okay so that's variant two I'm gonna

00:35:42,140 --> 00:35:46,700
keep going I'm skipping over variant 3

00:35:44,330 --> 00:35:48,800
because variant 3 was completely

00:35:46,700 --> 00:35:49,910
addressed by the operating system user

00:35:48,800 --> 00:35:51,950
code does not need to worry about

00:35:49,910 --> 00:35:54,920
variant 3 so let's look next at variant

00:35:51,950 --> 00:35:57,740
for variant 4 is called speculative

00:35:54,920 --> 00:36:00,170
store bypass and this is actually pretty

00:35:57,740 --> 00:36:01,610
easy to understand what it does it's

00:36:00,170 --> 00:36:04,970
exactly what it says in the name

00:36:01,610 --> 00:36:07,340
sometimes when you read from memory

00:36:04,970 --> 00:36:10,360
instead of reading memory that was just

00:36:07,340 --> 00:36:14,780
stored at that location you will read

00:36:10,360 --> 00:36:17,030
speculatively an old value that's really

00:36:14,780 --> 00:36:19,370
it the problem here is that the

00:36:17,030 --> 00:36:21,020
processor may not know whether the

00:36:19,370 --> 00:36:23,990
addresses of these loads and stores

00:36:21,020 --> 00:36:26,090
match and so instead of waiting to see

00:36:23,990 --> 00:36:28,430
if they match they'll guess they'll

00:36:26,090 --> 00:36:30,890
predict if they miss predict they may

00:36:28,430 --> 00:36:34,100
predict that the store and the load

00:36:30,890 --> 00:36:35,120
don't have the same address and if it

00:36:34,100 --> 00:36:36,860
predicts they don't have the same

00:36:35,120 --> 00:36:39,590
address it may speculatively execute the

00:36:36,860 --> 00:36:43,940
load with whatever was there before that

00:36:39,590 --> 00:36:45,470
store ok that's pretty pretty simple and

00:36:43,940 --> 00:36:47,600
you can imagine how this works imagine

00:36:45,470 --> 00:36:50,420
you have an application which runs some

00:36:47,600 --> 00:36:53,300
sandbox code in the callback here and

00:36:50,420 --> 00:36:55,610
hands that sandbox code a specific

00:36:53,300 --> 00:36:58,490
private key now we don't ever want to

00:36:55,610 --> 00:37:00,560
hand a private key to the wrong callback

00:36:58,490 --> 00:37:02,420
here write one of these callbacks that

00:37:00,560 --> 00:37:05,330
owns one of the keys another callback

00:37:02,420 --> 00:37:06,800
owns a different key right but when

00:37:05,330 --> 00:37:08,630
we're going through this loop the key

00:37:06,800 --> 00:37:10,160
gets passed by value then that means

00:37:08,630 --> 00:37:12,290
this is this is a bit big to fit into

00:37:10,160 --> 00:37:14,630
registers we're going to store a copy of

00:37:12,290 --> 00:37:16,010
this key onto the stack then we're gonna

00:37:14,630 --> 00:37:17,690
call the function with the pointer to

00:37:16,010 --> 00:37:19,880
that entry on the stack it's gonna

00:37:17,690 --> 00:37:22,250
finish come back we go to the next one

00:37:19,880 --> 00:37:23,930
we store the next key onto the stack and

00:37:22,250 --> 00:37:30,860
call the next function but if that

00:37:23,930 --> 00:37:33,200
function happens to speculate stored key

00:37:30,860 --> 00:37:36,620
it may observe the previous function

00:37:33,200 --> 00:37:38,300
stored key right and then be able to

00:37:36,620 --> 00:37:41,410
leak it and we have another information

00:37:38,300 --> 00:37:44,180
leak it turns out that this is the

00:37:41,410 --> 00:37:46,820
fastest of the information leaks that we

00:37:44,180 --> 00:37:49,400
have found if you can hit this reliably

00:37:46,820 --> 00:37:51,530
you can extract data at an unbelievable

00:37:49,400 --> 00:37:52,849
rate with this particular technique this

00:37:51,530 --> 00:37:54,950
technique calls tremendous prob

00:37:52,849 --> 00:37:58,009
for browsers and other people doing

00:37:54,950 --> 00:38:00,019
sandboxing as a consequence but there's

00:37:58,009 --> 00:38:03,079
also has other implications you can

00:38:00,019 --> 00:38:05,450
imagine a variant one style information

00:38:03,079 --> 00:38:09,109
leak that's actually powered by variant

00:38:05,450 --> 00:38:10,910
4 so here we have a vector that we're

00:38:09,109 --> 00:38:12,710
returning from some function which means

00:38:10,910 --> 00:38:15,440
we're gonna store a pointer like some

00:38:12,710 --> 00:38:17,059
pointers but also a size into memory

00:38:15,440 --> 00:38:20,029
here all right

00:38:17,059 --> 00:38:22,430
now then when we come down to our bounds

00:38:20,029 --> 00:38:24,109
check we may be reading size out of

00:38:22,430 --> 00:38:26,119
memory and if we're reading size out of

00:38:24,109 --> 00:38:28,249
memory and we happened and it happens to

00:38:26,119 --> 00:38:30,440
be slow it may not see the store just

00:38:28,249 --> 00:38:33,079
before this of size and so it may

00:38:30,440 --> 00:38:35,089
speculate instead reading whatever was

00:38:33,079 --> 00:38:36,470
on the stack before the store all right

00:38:35,089 --> 00:38:38,329
which might just be a random collection

00:38:36,470 --> 00:38:42,049
of bytes probably a very large number

00:38:38,329 --> 00:38:43,789
means this bound check will pass right

00:38:42,049 --> 00:38:45,589
but it's using the wrong bound it's not

00:38:43,789 --> 00:38:47,329
that we've bypassed the bounds check the

00:38:45,589 --> 00:38:50,690
balance check occurred it just used the

00:38:47,329 --> 00:38:51,829
wrong bound and again we get into the

00:38:50,690 --> 00:38:56,089
classic information leak as a

00:38:51,829 --> 00:38:57,619
consequence all right so variant three

00:38:56,089 --> 00:38:59,809
like I said this is this is mostly about

00:38:57,619 --> 00:39:01,309
operating systems I can explain if folks

00:38:59,809 --> 00:39:03,769
want but I'm just gonna keep moving for

00:39:01,309 --> 00:39:05,450
the sake of time we also have lazy FPU

00:39:03,769 --> 00:39:07,489
save and restore I mentioned kind of how

00:39:05,450 --> 00:39:09,109
this worked but again this was largely

00:39:07,489 --> 00:39:11,210
fixed by operating systems since the

00:39:09,109 --> 00:39:12,979
operating system is the one switching

00:39:11,210 --> 00:39:14,479
context it can change its behavior and

00:39:12,979 --> 00:39:17,059
prevent application code from having to

00:39:14,479 --> 00:39:18,739
worry about this an l1 terminal fault

00:39:17,059 --> 00:39:20,390
the way oh one terminal fault works is

00:39:18,739 --> 00:39:23,059
amazing there are certain kinds of

00:39:20,390 --> 00:39:24,739
faults that when they happen spective

00:39:23,059 --> 00:39:27,019
execution can again occur and if you

00:39:24,739 --> 00:39:28,880
arrange everything just right especially

00:39:27,019 --> 00:39:31,460
with page tables and other aspects of

00:39:28,880 --> 00:39:34,549
your system you can essentially read

00:39:31,460 --> 00:39:36,499
arbitrary data out of the l1 cache while

00:39:34,549 --> 00:39:38,809
this terminal fault is being handled and

00:39:36,499 --> 00:39:39,829
leak it with speculative execution and

00:39:38,809 --> 00:39:41,690
there are a bunch of different ways to

00:39:39,829 --> 00:39:43,430
observe this there is a great paper that

00:39:41,690 --> 00:39:45,349
introduced this called for shadow and

00:39:43,430 --> 00:39:49,400
showed that this actually works inside

00:39:45,349 --> 00:39:50,569
of Intel's secure Enclave SGX and and

00:39:49,400 --> 00:39:52,819
yes it just allows you to read the

00:39:50,569 --> 00:39:54,680
entirety of l1 if you if you haven't

00:39:52,819 --> 00:39:56,450
seen it yet go and look for the video

00:39:54,680 --> 00:39:58,549
online about this you can actually find

00:39:56,450 --> 00:39:59,809
one of the researchers which has a

00:39:58,549 --> 00:40:01,519
window at the bottom of a Windows

00:39:59,809 --> 00:40:03,769
machine and as they type in the

00:40:01,519 --> 00:40:05,620
administrator password the window shows

00:40:03,769 --> 00:40:08,830
the administrator password in real time

00:40:05,620 --> 00:40:09,940
it's really really effective but again

00:40:08,830 --> 00:40:11,710
this is mostly an operating system

00:40:09,940 --> 00:40:13,540
concern and so operating system changes

00:40:11,710 --> 00:40:15,190
and hardware changes are being used to

00:40:13,540 --> 00:40:18,430
address this application code doesn't

00:40:15,190 --> 00:40:19,930
have to deal with this directly all

00:40:18,430 --> 00:40:21,670
right so I don't know about all of you

00:40:19,930 --> 00:40:24,970
but like I think that was too much

00:40:21,670 --> 00:40:26,710
information so I'm gonna try and

00:40:24,970 --> 00:40:28,510
summarize in a way that you can kind of

00:40:26,710 --> 00:40:30,430
wrap your head around this is gonna be

00:40:28,510 --> 00:40:33,460
the most busy slide I have alright so

00:40:30,430 --> 00:40:34,780
this is the summary slide okay of

00:40:33,460 --> 00:40:39,400
essentially all of this background

00:40:34,780 --> 00:40:44,170
information we have four variations on

00:40:39,400 --> 00:40:45,670
Specter v1 okay is it v1 1.1 1.2 Rhett -

00:40:44,170 --> 00:40:48,550
spec which I just didn't have time to

00:40:45,670 --> 00:40:50,230
show you all these are all taking

00:40:48,550 --> 00:40:52,480
advantage of the same fundamental

00:40:50,230 --> 00:40:54,250
mechanisms right and they have very

00:40:52,480 --> 00:40:55,720
similar properties they can impact

00:40:54,250 --> 00:40:58,780
application code they can impact

00:40:55,720 --> 00:41:00,100
operating system code they don't require

00:40:58,780 --> 00:41:02,230
to be using hyper threading or

00:41:00,100 --> 00:41:05,770
simultaneous multi-threading in your cpu

00:41:02,230 --> 00:41:08,140
we have really slow software fixes that

00:41:05,770 --> 00:41:10,210
none of us like and we don't have any

00:41:08,140 --> 00:41:11,860
realistic hardware fix on the horizon

00:41:10,210 --> 00:41:13,810
these are actually the thing I'm gonna

00:41:11,860 --> 00:41:16,510
talk about most because these are for me

00:41:13,810 --> 00:41:19,870
the most scary note that read column on

00:41:16,510 --> 00:41:21,460
the right we also have variant 2 which

00:41:19,870 --> 00:41:23,830
actually isn't the primary variant 2 but

00:41:21,460 --> 00:41:25,510
also Specter rsb which helps show how

00:41:23,830 --> 00:41:27,940
you can actually get variant you to work

00:41:25,510 --> 00:41:29,380
on returns these are a bit different

00:41:27,940 --> 00:41:31,630
while they impact both the application

00:41:29,380 --> 00:41:33,610
and the operating system code right they

00:41:31,630 --> 00:41:35,170
do require some things to be true for

00:41:33,610 --> 00:41:37,060
you to attack from one application to

00:41:35,170 --> 00:41:40,750
another you really have to be using

00:41:37,060 --> 00:41:42,730
hyper threads or SMT ok the other nice

00:41:40,750 --> 00:41:44,800
thing is that we have some much better

00:41:42,730 --> 00:41:47,590
hope of fixing these we have a very good

00:41:44,800 --> 00:41:50,230
software fix for variant 2 we don't have

00:41:47,590 --> 00:41:52,660
a great software fix for Specter our SB

00:41:50,230 --> 00:41:54,400
or variant 2 when it's it's hit with the

00:41:52,660 --> 00:41:55,540
return instruction but there's some

00:41:54,400 --> 00:41:58,030
stuff you can do but it's not a

00:41:55,540 --> 00:42:00,490
satisfying but we do have good Hardware

00:41:58,030 --> 00:42:02,260
fixes on the horizon a future Intel

00:42:00,490 --> 00:42:03,610
hardware future other a future harder

00:42:02,260 --> 00:42:06,460
from other vendors is going to do a very

00:42:03,610 --> 00:42:08,980
good job of defending against this then

00:42:06,460 --> 00:42:11,500
we have variant for variant for looks in

00:42:08,980 --> 00:42:14,080
terms of the risk more like Specter v1

00:42:11,500 --> 00:42:15,910
but with less hope of mitigating it ok

00:42:14,080 --> 00:42:17,440
so it impacts applications it impacts

00:42:15,910 --> 00:42:18,910
operating systems it does not require

00:42:17,440 --> 00:42:21,910
hyper threading for one applique

00:42:18,910 --> 00:42:23,970
to attack another on we have absolutely

00:42:21,910 --> 00:42:27,609
no hope of fixing this in software and

00:42:23,970 --> 00:42:30,039
so far the hardware fixes are proving

00:42:27,609 --> 00:42:31,930
problematic there is one that slow and

00:42:30,039 --> 00:42:33,460
the browser vendors aren't using it and

00:42:31,930 --> 00:42:36,280
have some concerns about it and so this

00:42:33,460 --> 00:42:37,960
one's still pretty pretty fuzzy and then

00:42:36,280 --> 00:42:39,789
we have a bunch of things at the bottom

00:42:37,960 --> 00:42:41,289
that I really view very differently from

00:42:39,789 --> 00:42:44,680
the rest because these are fundamentally

00:42:41,289 --> 00:42:47,079
CPU bugs that just interacted very

00:42:44,680 --> 00:42:49,960
poorly respective of execution and the

00:42:47,079 --> 00:42:51,730
specter techniques okay and these I

00:42:49,960 --> 00:42:53,410
think are going to very consistently get

00:42:51,730 --> 00:42:55,480
fixed rapidly I think these are in some

00:42:53,410 --> 00:42:57,549
ways the least scary for for application

00:42:55,480 --> 00:42:58,960
developers most of them don't impact

00:42:57,549 --> 00:43:01,059
applications at all you don't have to

00:42:58,960 --> 00:43:04,119
change your code at all they're only in

00:43:01,059 --> 00:43:06,520
the OS we have a great software fix for

00:43:04,119 --> 00:43:08,500
lazy FPU so good that no one is going to

00:43:06,520 --> 00:43:10,089
try and fix the hardware and we have

00:43:08,500 --> 00:43:12,010
great harder fixes for the other ones

00:43:10,089 --> 00:43:13,960
and so I think these are these are

00:43:12,010 --> 00:43:15,910
generally speaking going very well I'm

00:43:13,960 --> 00:43:18,520
gonna really focus on spectral variant 1

00:43:15,910 --> 00:43:19,240
variant 2 and variant 4 because those

00:43:18,520 --> 00:43:23,650
are the things that are really

00:43:19,240 --> 00:43:25,660
continuing to impact software today now

00:43:23,650 --> 00:43:27,369
to really talk about what you need to

00:43:25,660 --> 00:43:28,960
know in this space we need to have a

00:43:27,369 --> 00:43:30,549
threat model if you went to one of the

00:43:28,960 --> 00:43:32,589
earlier talks at the conference about

00:43:30,549 --> 00:43:33,849
security there was a great discussion

00:43:32,589 --> 00:43:35,710
around how you do threat modeling

00:43:33,849 --> 00:43:36,970
unfortunately that that person is

00:43:35,710 --> 00:43:38,829
actually a security researcher now I'm

00:43:36,970 --> 00:43:40,900
not and I'm certainly not your security

00:43:38,829 --> 00:43:42,099
researcher and so I can't help you build

00:43:40,900 --> 00:43:44,319
a threat model and that's not what I'm

00:43:42,099 --> 00:43:46,539
gonna do up here but I can give you some

00:43:44,319 --> 00:43:48,579
questions you can use when building your

00:43:46,539 --> 00:43:49,960
own threat model to really understand

00:43:48,579 --> 00:43:52,599
the implications of Spectre and

00:43:49,960 --> 00:43:56,410
speculative execution attacks on on your

00:43:52,599 --> 00:43:58,720
particular software system so first off

00:43:56,410 --> 00:44:02,559
does your service have any data that is

00:43:58,720 --> 00:44:03,640
confidential right because if not it

00:44:02,559 --> 00:44:05,170
doesn't matter if you have an

00:44:03,640 --> 00:44:07,480
information leak vulnerability it's a

00:44:05,170 --> 00:44:11,440
very simple simple answer I love this

00:44:07,480 --> 00:44:14,170
threat model ok next does our service

00:44:11,440 --> 00:44:15,940
interact with any untrusted services or

00:44:14,170 --> 00:44:18,760
inputs is there any input you don't

00:44:15,940 --> 00:44:21,460
fully trust right is there any entity

00:44:18,760 --> 00:44:23,020
that talks to you in some way that you

00:44:21,460 --> 00:44:25,150
would not want to share all of the

00:44:23,020 --> 00:44:29,170
information you have with the answers

00:44:25,150 --> 00:44:30,910
again No then you're fine this gives you

00:44:29,170 --> 00:44:32,240
a nice simple rule that fortunately

00:44:30,910 --> 00:44:34,460
excludes I think the majority

00:44:32,240 --> 00:44:36,830
software we have out there if you have

00:44:34,460 --> 00:44:38,839
nothing to steal or no and no or no one

00:44:36,830 --> 00:44:42,470
to steal it you have nothing to secure

00:44:38,839 --> 00:44:45,380
okay from information leaks this is this

00:44:42,470 --> 00:44:47,980
is a pretty solid mental model to use

00:44:45,380 --> 00:44:49,700
when coming up with your threat model

00:44:47,980 --> 00:44:51,680
unfortunately we do still have a lot of

00:44:49,700 --> 00:44:53,089
software that doesn't fit this model so

00:44:51,680 --> 00:44:56,750
let's talk about how we can dig through

00:44:53,089 --> 00:45:00,020
that those pieces of software do you run

00:44:56,750 --> 00:45:02,060
untrusted code in the same address space

00:45:00,020 --> 00:45:03,830
as you have confidential information

00:45:02,060 --> 00:45:05,330
stored right you have some information

00:45:03,830 --> 00:45:08,330
there and you're gonna run untrusted

00:45:05,330 --> 00:45:12,109
code right next to it if this is the

00:45:08,330 --> 00:45:15,619
case you have a hard problem we do not

00:45:12,109 --> 00:45:20,270
know how to solve Spectre effectively

00:45:15,619 --> 00:45:23,420
for this case outside of isolating your

00:45:20,270 --> 00:45:24,950
entire code from your confidential

00:45:23,420 --> 00:45:26,480
information this is the case that

00:45:24,950 --> 00:45:28,640
browsers are in you're going to see

00:45:26,480 --> 00:45:30,859
browsers increasingly dealing with this

00:45:28,640 --> 00:45:33,290
particular case do you have if you hit

00:45:30,859 --> 00:45:34,820
this almost nothing else about the

00:45:33,290 --> 00:45:38,030
questions here matters you're going to

00:45:34,820 --> 00:45:39,349
have the highest risk from Spectre but

00:45:38,030 --> 00:45:40,460
maybe you don't have untrusted code

00:45:39,349 --> 00:45:41,690
running in the same address space

00:45:40,460 --> 00:45:43,930
there's a lot of software that doesn't

00:45:41,690 --> 00:45:45,950
run untrusted code that's which is good

00:45:43,930 --> 00:45:48,830
now you need to ask yourself does an

00:45:45,950 --> 00:45:51,140
attacker have access to your executable

00:45:48,830 --> 00:45:53,300
right can they actually look at your

00:45:51,140 --> 00:45:55,849
binary and reason about it in some way

00:45:53,300 --> 00:45:57,349
can they steal a copy of it easily is it

00:45:55,849 --> 00:45:59,630
distributed in some way that they would

00:45:57,349 --> 00:46:01,670
have access that's gonna really change

00:45:59,630 --> 00:46:03,349
the threat model if the attack if no one

00:46:01,670 --> 00:46:04,849
has access to your executable they're

00:46:03,349 --> 00:46:07,220
going to have an extremely hard time

00:46:04,849 --> 00:46:09,710
using these techniques it's not

00:46:07,220 --> 00:46:12,380
impossible but it becomes incredibly

00:46:09,710 --> 00:46:13,880
difficult however you want to be a

00:46:12,380 --> 00:46:15,230
little bit careful here because they

00:46:13,880 --> 00:46:17,599
don't need access to the entire

00:46:15,230 --> 00:46:19,670
executable if you use common open source

00:46:17,599 --> 00:46:21,050
libraries right and if you if you link

00:46:19,670 --> 00:46:23,300
them in and if you build them with

00:46:21,050 --> 00:46:25,490
common Flags then they have access to

00:46:23,300 --> 00:46:27,589
part of your executable if you run on a

00:46:25,490 --> 00:46:29,960
distribution and you dynamically link

00:46:27,589 --> 00:46:31,369
the common distribution shared objects

00:46:29,960 --> 00:46:33,050
they may have the exact same

00:46:31,369 --> 00:46:35,359
distribution and they'll have access to

00:46:33,050 --> 00:46:36,950
some of the executable and they don't

00:46:35,359 --> 00:46:39,740
need access to all of it to mount a

00:46:36,950 --> 00:46:40,849
successful attack okay so you want to be

00:46:39,740 --> 00:46:42,589
a little bit careful how you think about

00:46:40,849 --> 00:46:45,500
this but it does really dramatically

00:46:42,589 --> 00:46:45,950
influence how open you are to these

00:46:45,500 --> 00:46:50,150
kinds of

00:46:45,950 --> 00:46:52,220
of risks the next question is does any

00:46:50,150 --> 00:46:55,880
untrusted code run on the same physical

00:46:52,220 --> 00:46:58,240
machine because if the answer here is no

00:46:55,880 --> 00:47:00,980
you're really looking at a single

00:46:58,240 --> 00:47:03,079
mechanism for attack and that's the ones

00:47:00,980 --> 00:47:05,540
presented Annette Spector okay that's

00:47:03,079 --> 00:47:07,940
that's the way you're going to be seeing

00:47:05,540 --> 00:47:10,160
this and Annette's vector gives us

00:47:07,940 --> 00:47:12,500
pretty clear bandwidth rules and it

00:47:10,160 --> 00:47:14,210
turns out the bandwidth is low and so if

00:47:12,500 --> 00:47:16,040
you don't have untrusted code running on

00:47:14,210 --> 00:47:18,440
the same machine there's some very

00:47:16,040 --> 00:47:21,440
specific questions you want to ask how

00:47:18,440 --> 00:47:23,420
many bits need to be leaked for this

00:47:21,440 --> 00:47:26,089
information leak to actually be valuable

00:47:23,420 --> 00:47:28,940
to someone else right how many bits are

00:47:26,089 --> 00:47:30,920
at risk if you have you know a bunch of

00:47:28,940 --> 00:47:33,829
data if you have like if you have the

00:47:30,920 --> 00:47:35,780
next manuscript for I guess Harry Potter

00:47:33,829 --> 00:47:38,030
is over but whatever the next fancy book

00:47:35,780 --> 00:47:40,280
is leaking that manuscript is going to

00:47:38,030 --> 00:47:41,780
be really hard it's big right you don't

00:47:40,280 --> 00:47:43,880
need to worry about someone leaking you

00:47:41,780 --> 00:47:45,410
know the next huts you know video game

00:47:43,880 --> 00:47:47,079
that you've got a copy of on your

00:47:45,410 --> 00:47:49,550
machine that's gonna be really slow

00:47:47,079 --> 00:47:52,670
right but if you have a cryptographic

00:47:49,550 --> 00:47:55,069
key that may only be a few thousand bits

00:47:52,670 --> 00:47:57,319
if you have an elliptic curve

00:47:55,069 --> 00:47:59,930
cryptography key that may only be a

00:47:57,319 --> 00:48:01,819
hundred or two hundred bits okay before

00:47:59,930 --> 00:48:04,790
it's compromised and worse with

00:48:01,819 --> 00:48:06,770
cryptographic issues you may not need

00:48:04,790 --> 00:48:08,540
all the bits for it to be valuable so

00:48:06,770 --> 00:48:10,520
you really want to think about this

00:48:08,540 --> 00:48:13,880
another thing to think about is how long

00:48:10,520 --> 00:48:16,369
is this data accessible okay if it's in

00:48:13,880 --> 00:48:17,930
the same place for one request and your

00:48:16,369 --> 00:48:20,359
service and then you throw it away and

00:48:17,930 --> 00:48:21,920
then it shows up somewhere else then you

00:48:20,359 --> 00:48:23,960
may not have big problems here because

00:48:21,920 --> 00:48:25,609
it may be very hard to you know conduct

00:48:23,960 --> 00:48:29,119
all of the things necessary while the

00:48:25,609 --> 00:48:31,220
data is in the same place you also want

00:48:29,119 --> 00:48:33,290
to look at what kind of timings that

00:48:31,220 --> 00:48:35,119
someone can get in the net specter style

00:48:33,290 --> 00:48:37,130
of attack okay you want to look at what

00:48:35,119 --> 00:48:39,260
is the latency of your system okay

00:48:37,130 --> 00:48:41,660
how low is that latency how low can they

00:48:39,260 --> 00:48:45,020
get it all right and you also want to

00:48:41,660 --> 00:48:48,050
look at just how many different systems

00:48:45,020 --> 00:48:50,599
have the same information so if you have

00:48:48,050 --> 00:48:52,970
for example a cryptographic key that is

00:48:50,599 --> 00:48:54,950
super important and you have distributed

00:48:52,970 --> 00:48:57,530
it across thousands and thousands of

00:48:54,950 --> 00:48:59,720
machines and all of those machines can

00:48:57,530 --> 00:49:02,570
all be attacked simultaneous

00:48:59,720 --> 00:49:04,369
we okay you have a much bigger bandwidth

00:49:02,570 --> 00:49:06,859
problem than if it only exists on one

00:49:04,369 --> 00:49:08,690
machine because then the bandwidth is

00:49:06,859 --> 00:49:09,170
much narrower so these are key things to

00:49:08,690 --> 00:49:13,760
think about

00:49:09,170 --> 00:49:14,900
around bandwidth and really nestled

00:49:13,760 --> 00:49:17,390
about this you're essentially always

00:49:14,900 --> 00:49:19,790
going to be making this bandwidth risk

00:49:17,390 --> 00:49:21,410
value and complexity trade-off because

00:49:19,790 --> 00:49:22,970
it's going to be very hard to mitigate

00:49:21,410 --> 00:49:25,940
this otherwise you want to think very

00:49:22,970 --> 00:49:27,470
carefully about this but what if you do

00:49:25,940 --> 00:49:29,780
run untrusted code on the same machine

00:49:27,470 --> 00:49:31,820
right there is there are a lot of shared

00:49:29,780 --> 00:49:33,200
shared machines that actually have you

00:49:31,820 --> 00:49:35,540
know shared users here and I don't mean

00:49:33,200 --> 00:49:37,250
in the cloud since if you have separate

00:49:35,540 --> 00:49:38,480
VMs that that's enough right like you

00:49:37,250 --> 00:49:39,590
can think of those as separate machines

00:49:38,480 --> 00:49:43,220
but what if you're actually really

00:49:39,590 --> 00:49:44,480
running on the same machine do you then

00:49:43,220 --> 00:49:46,369
you have to ask more questions do you

00:49:44,480 --> 00:49:48,859
run untrusted code on the same physical

00:49:46,369 --> 00:49:50,690
core all right and this may not always

00:49:48,859 --> 00:49:52,160
be obvious if you don't have hyper

00:49:50,690 --> 00:49:53,810
threading or simultaneous

00:49:52,160 --> 00:49:55,760
multi-threading then you clearly don't

00:49:53,810 --> 00:49:58,460
run untrusted code on the same physical

00:49:55,760 --> 00:49:59,869
core simultaneously but there are other

00:49:58,460 --> 00:50:01,340
ways you may get here you may partition

00:49:59,869 --> 00:50:02,570
your workload across different cores

00:50:01,340 --> 00:50:04,670
there are a lot of ways that may

00:50:02,570 --> 00:50:06,530
influence this and all of the variant 2

00:50:04,670 --> 00:50:08,930
style attacks from application to

00:50:06,530 --> 00:50:11,420
application rely on running on the same

00:50:08,930 --> 00:50:13,609
physical core and so in a lot of ways if

00:50:11,420 --> 00:50:15,230
you can exclude this you get to take out

00:50:13,609 --> 00:50:18,849
an entire variant from your threat model

00:50:15,230 --> 00:50:18,849
and that's that's really really useful

00:50:19,119 --> 00:50:22,460
ok so with that we've kind of talked

00:50:21,410 --> 00:50:23,869
about all of the different things you

00:50:22,460 --> 00:50:26,450
want to think about from threat modeling

00:50:23,869 --> 00:50:28,580
I do want to re-emphasize this is about

00:50:26,450 --> 00:50:30,170
applications operating systems and

00:50:28,580 --> 00:50:32,720
hypervisors have totally different

00:50:30,170 --> 00:50:34,280
challenges here ok I'm not covering them

00:50:32,720 --> 00:50:35,720
they're there they're very real risks

00:50:34,280 --> 00:50:36,920
but I'm not covering them if you want to

00:50:35,720 --> 00:50:38,660
know all about operating systems and

00:50:36,920 --> 00:50:40,640
hypervisors you can come and ask all

00:50:38,660 --> 00:50:42,440
about them at the panel but but I'm

00:50:40,640 --> 00:50:43,760
actually not the expert there and it's a

00:50:42,440 --> 00:50:45,349
very different thing and it seems like a

00:50:43,760 --> 00:50:47,150
different crowd that might be more

00:50:45,349 --> 00:50:50,930
interested in that so I'm focusing on

00:50:47,150 --> 00:50:52,310
application issues here with that let's

00:50:50,930 --> 00:50:55,460
move over to talking about mitigations

00:50:52,310 --> 00:50:57,530
how do we actually cope with this first

00:50:55,460 --> 00:50:59,900
things first you have to mitigate your

00:50:57,530 --> 00:51:01,700
operating system otherwise none of this

00:50:59,900 --> 00:51:03,050
matters if you do not deploy the

00:51:01,700 --> 00:51:05,270
operating system mitigations that your

00:51:03,050 --> 00:51:08,119
operating system vendor is providing you

00:51:05,270 --> 00:51:11,000
cannot do anything useful here ok these

00:51:08,119 --> 00:51:13,470
are essential so please especially now

00:51:11,000 --> 00:51:15,720
it's increasingly important

00:51:13,470 --> 00:51:17,250
you have a way to update your operating

00:51:15,720 --> 00:51:19,440
system and that your operating system

00:51:17,250 --> 00:51:21,599
vendor is actively providing you updates

00:51:19,440 --> 00:51:23,130
they aren't you should probably look for

00:51:21,599 --> 00:51:25,830
a different operating system vendor this

00:51:23,130 --> 00:51:27,210
stuff is important okay so let's assume

00:51:25,830 --> 00:51:28,349
you've gotten all of your operating

00:51:27,210 --> 00:51:29,849
system mitigations and all of your

00:51:28,349 --> 00:51:31,890
operating system updates and so you're

00:51:29,849 --> 00:51:34,650
good and let's talk about how you can

00:51:31,890 --> 00:51:36,359
mitigate your application code first off

00:51:34,650 --> 00:51:38,430
there are some x86 kind of operating

00:51:36,359 --> 00:51:41,310
system and hardware based mitigations

00:51:38,430 --> 00:51:43,980
for application code these come in three

00:51:41,310 --> 00:51:46,200
flavors they are they are they have

00:51:43,980 --> 00:51:49,650
again weird acronyms IBRS which is

00:51:46,200 --> 00:51:51,869
indirect branch reduced speculation IB

00:51:49,650 --> 00:51:53,910
PB which I miss say every time I try

00:51:51,869 --> 00:51:57,960
which is indirect branch prediction

00:51:53,910 --> 00:51:59,700
barrier and STI B P which is the single

00:51:57,960 --> 00:52:02,550
threaded indirect branch prediction

00:51:59,700 --> 00:52:05,520
feature okay now your operating system

00:52:02,550 --> 00:52:07,140
in your hardware can turn these on and

00:52:05,520 --> 00:52:08,520
when they do they can provide certain

00:52:07,140 --> 00:52:10,140
levels of protection from some of these

00:52:08,520 --> 00:52:13,619
variants but an important thing to

00:52:10,140 --> 00:52:16,500
realize for an application these do not

00:52:13,619 --> 00:52:18,359
help with variants 1 or 4 they're

00:52:16,500 --> 00:52:22,380
exclusively helping with variant 2

00:52:18,359 --> 00:52:24,690
okay and they also may be very slow in

00:52:22,380 --> 00:52:27,690
some cases these are especially slow on

00:52:24,690 --> 00:52:29,700
current and older CPUs we're expecting

00:52:27,690 --> 00:52:31,770
newer CPUs to increasingly make these

00:52:29,700 --> 00:52:33,750
things fast and for this them to be

00:52:31,770 --> 00:52:35,790
essentially unobservable in terms of

00:52:33,750 --> 00:52:37,500
performance but if you have older CPUs

00:52:35,790 --> 00:52:38,849
even turning these on with your

00:52:37,500 --> 00:52:40,349
operating system may be a very

00:52:38,849 --> 00:52:42,420
significant performance hit and there

00:52:40,349 --> 00:52:44,640
are some alternatives but the

00:52:42,420 --> 00:52:45,780
alternatives are software based so we

00:52:44,640 --> 00:52:48,349
need to talk about how we can use

00:52:45,780 --> 00:52:50,849
software to go after mitigation the

00:52:48,349 --> 00:52:52,920
first one is called ret pullings this

00:52:50,849 --> 00:52:56,580
was developed by Google a colleague of

00:52:52,920 --> 00:52:58,080
mine and the idea is well we can

00:52:56,580 --> 00:52:59,640
recompile our source code to our

00:52:58,080 --> 00:53:01,050
application as we wanted to see is there

00:52:59,640 --> 00:53:03,060
something we could change in the source

00:53:01,050 --> 00:53:04,800
code that could be effective at

00:53:03,060 --> 00:53:07,650
mitigating at least some of the most

00:53:04,800 --> 00:53:10,140
risky variations on this notably variant

00:53:07,650 --> 00:53:12,570
2 which is far and away the easiest to

00:53:10,140 --> 00:53:13,800
attack in in a working system seemed

00:53:12,570 --> 00:53:15,570
like something we really wanted to

00:53:13,800 --> 00:53:17,490
mitigate in software given the

00:53:15,570 --> 00:53:20,060
performance impact we were seeing from

00:53:17,490 --> 00:53:22,619
the the OS hardware-based mitigations

00:53:20,060 --> 00:53:24,990
does require recompiling your source

00:53:22,619 --> 00:53:26,619
which is can be painful but if you can

00:53:24,990 --> 00:53:29,529
this mitigates

00:53:26,619 --> 00:53:31,420
variant two and Specter RSV in

00:53:29,529 --> 00:53:33,839
restricted cases but they're a bunch of

00:53:31,420 --> 00:53:36,969
like asterisks and and and hedges there

00:53:33,839 --> 00:53:41,079
and it's usually going to be faster than

00:53:36,969 --> 00:53:42,299
STI BP on current CPUs and older CPUs

00:53:41,079 --> 00:53:44,769
for mitigating your current application

00:53:42,299 --> 00:53:47,739
not always but there's a decent chance

00:53:44,769 --> 00:53:49,299
you probably want to look at it going

00:53:47,739 --> 00:53:50,829
for it in the future we do expect this

00:53:49,299 --> 00:53:53,049
to become less and less relevant because

00:53:50,829 --> 00:53:54,759
the hardware is really catching up we're

00:53:53,049 --> 00:53:56,289
expecting in the future this is just

00:53:54,759 --> 00:53:57,759
going to work on hardware and you're not

00:53:56,289 --> 00:53:59,049
going to need to worry about this but

00:53:57,759 --> 00:54:00,609
for now you might want to worry about

00:53:59,049 --> 00:54:04,180
this if you have a service that is that

00:54:00,609 --> 00:54:06,160
is at risk here so how does this work we

00:54:04,180 --> 00:54:07,930
have some indirect call okay just like

00:54:06,160 --> 00:54:09,670
the previous one but when you compile

00:54:07,930 --> 00:54:11,259
your code with ret Pauline's we don't

00:54:09,670 --> 00:54:13,450
omit these instructions we emit a

00:54:11,259 --> 00:54:15,219
different set of instructions so here

00:54:13,450 --> 00:54:17,200
we've taken this address that you wanted

00:54:15,219 --> 00:54:20,650
to call and we've put it into a register

00:54:17,200 --> 00:54:22,900
R 11 and then we've transformed the call

00:54:20,650 --> 00:54:27,400
into a call to this helper routine LLVM

00:54:22,900 --> 00:54:30,369
ret Pauline R 11 okay now if we look at

00:54:27,400 --> 00:54:32,829
this routine this is a very very strange

00:54:30,369 --> 00:54:35,049
function okay the first thing it does is

00:54:32,829 --> 00:54:39,219
a call but it doesn't call a function it

00:54:35,049 --> 00:54:43,960
calls a label a basic block inside of

00:54:39,219 --> 00:54:46,180
itself okay and once it does that it

00:54:43,960 --> 00:54:49,509
then takes the address you wanted to

00:54:46,180 --> 00:54:51,700
call and smashes the stack with it this

00:54:49,509 --> 00:54:53,469
is a stack smash this is what clobbers

00:54:51,700 --> 00:54:55,450
the return address with this address you

00:54:53,469 --> 00:54:57,729
wanting to call and then it uses a

00:54:55,450 --> 00:55:00,219
return to actually branch to that

00:54:57,729 --> 00:55:04,390
location so that's a pretty weird thing

00:55:00,219 --> 00:55:07,390
to do the key idea here is that by doing

00:55:04,390 --> 00:55:09,700
a call followed by a return we put a

00:55:07,390 --> 00:55:11,849
particular address an unambiguous

00:55:09,700 --> 00:55:14,440
address into the call and return

00:55:11,849 --> 00:55:17,229
predictor the return stack buffer and

00:55:14,440 --> 00:55:19,150
this predictor is really fast and really

00:55:17,229 --> 00:55:21,219
good so the processor prefers it anytime

00:55:19,150 --> 00:55:23,619
it can use it and in the vast majority

00:55:21,219 --> 00:55:26,140
of cases it's going to be able to use it

00:55:23,619 --> 00:55:28,979
here and when it does if it speculates

00:55:26,140 --> 00:55:32,829
this return it actually ends up here

00:55:28,979 --> 00:55:35,460
okay because the speculative return

00:55:32,829 --> 00:55:38,259
can't see that stack smash operation

00:55:35,460 --> 00:55:40,150
okay so when it specs its attorney goes

00:55:38,259 --> 00:55:41,770
here which then goes to this weird

00:55:40,150 --> 00:55:44,200
pause instruction how many folks here

00:55:41,770 --> 00:55:46,150
have used the x86 Paul's instruction I

00:55:44,200 --> 00:55:47,380
don't know what kind of code you people

00:55:46,150 --> 00:55:49,869
are writing except for this one over

00:55:47,380 --> 00:55:51,339
here I know what you're doing - so the

00:55:49,869 --> 00:55:52,750
pause instructions super weird I never

00:55:51,339 --> 00:55:55,240
even knew what this was I thought this

00:55:52,750 --> 00:55:56,770
was like something from old old old x86

00:55:55,240 --> 00:55:58,990
days but no it actually has lots of uses

00:55:56,770 --> 00:56:01,240
and in this case it is the cheapest

00:55:58,990 --> 00:56:04,180
possible way to abort speculative

00:56:01,240 --> 00:56:05,680
execution all right and we want to abort

00:56:04,180 --> 00:56:08,380
it the consecutive execution consumes

00:56:05,680 --> 00:56:09,880
resources you know like power so we do

00:56:08,380 --> 00:56:12,039
want to abort it and so we cut it off

00:56:09,880 --> 00:56:13,839
here unfortunately pause doesn't do that

00:56:12,039 --> 00:56:16,089
on AMD processors it only does it on

00:56:13,839 --> 00:56:18,099
Intel processors so after we pause

00:56:16,089 --> 00:56:20,200
within doing elephants and this will

00:56:18,099 --> 00:56:21,869
actually work on AMD processors once you

00:56:20,200 --> 00:56:24,910
install your operating system updates

00:56:21,869 --> 00:56:28,349
finally just in case all of this magic

00:56:24,910 --> 00:56:31,299
fails we make this into an infinite loop

00:56:28,349 --> 00:56:33,190
okay so you're just you're not getting

00:56:31,299 --> 00:56:34,569
out of here this is keeping the

00:56:33,190 --> 00:56:37,150
speculative execution in a safe

00:56:34,569 --> 00:56:38,770
predictable place okay this essentially

00:56:37,150 --> 00:56:40,930
turns off speculative execution and

00:56:38,770 --> 00:56:43,119
branch prediction for indirect calls and

00:56:40,930 --> 00:56:46,270
indirect branches but that protects us

00:56:43,119 --> 00:56:49,150
from variant - okay the overhead of

00:56:46,270 --> 00:56:51,279
doing this is remarkably small so if

00:56:49,150 --> 00:56:54,250
this is about your worst case scenario

00:56:51,279 --> 00:56:56,680
we've built very large c++ servers with

00:56:54,250 --> 00:56:59,650
this enabled and the overhead was under

00:56:56,680 --> 00:57:01,059
3% reliably under 3% but it does require

00:56:59,650 --> 00:57:02,799
that you use some pretty advanced

00:57:01,059 --> 00:57:04,420
compilation techniques you need to be

00:57:02,799 --> 00:57:06,369
using profile guided optimizations you

00:57:04,420 --> 00:57:08,740
need to be using thin LTO or some other

00:57:06,369 --> 00:57:10,210
form of LTO okay I can't emphasize that

00:57:08,740 --> 00:57:12,039
enough but when you use them you can

00:57:10,210 --> 00:57:13,450
keep the overhead here very very low and

00:57:12,039 --> 00:57:15,670
if you're working in something very

00:57:13,450 --> 00:57:18,339
specialized like some really specialized

00:57:15,670 --> 00:57:20,170
code at code or a kernel you can usually

00:57:18,339 --> 00:57:22,329
avoid the indirect branches and indirect

00:57:20,170 --> 00:57:24,520
coals manually with essentially no

00:57:22,329 --> 00:57:27,880
measurable performance overhead by

00:57:24,520 --> 00:57:29,559
introducing kind of good guesses for

00:57:27,880 --> 00:57:31,240
what the direct code should be and a

00:57:29,559 --> 00:57:33,190
test to make sure that that's correct

00:57:31,240 --> 00:57:35,230
rather than relying on indirect calls

00:57:33,190 --> 00:57:37,210
and indirect branches we've we've been

00:57:35,230 --> 00:57:38,529
able to use this to make our our kernel

00:57:37,210 --> 00:57:40,980
our operating system mitigations

00:57:38,529 --> 00:57:43,539
incredibly inexpensive as a consequence

00:57:40,980 --> 00:57:45,160
but this is only for variant two and and

00:57:43,539 --> 00:57:46,839
maybe they're int 2 is going to be fixed

00:57:45,160 --> 00:57:48,430
in future hardware and and maybe you

00:57:46,839 --> 00:57:50,710
don't even you're not even subject to it

00:57:48,430 --> 00:57:52,180
so what about the other variants that's

00:57:50,710 --> 00:57:54,339
where things start to get bad

00:57:52,180 --> 00:57:56,319
so you can manually harden your branches

00:57:54,339 --> 00:57:58,960
for variant one just which is nice right

00:57:56,319 --> 00:58:00,910
but it can be a bit painful until an AMD

00:57:58,960 --> 00:58:02,980
are suggesting that you use the

00:58:00,910 --> 00:58:05,440
elephant's instruction right after a

00:58:02,980 --> 00:58:08,309
branch and actually while we're here I

00:58:05,440 --> 00:58:08,309
think we have enough time

00:58:09,119 --> 00:58:15,010
everybody likes live didn't let's see if

00:58:11,079 --> 00:58:25,329
we can actually just do this so they

00:58:15,010 --> 00:58:33,240
come down here and after my branch I do

00:58:25,329 --> 00:58:33,240
an elephants we would expect this to

00:58:36,329 --> 00:58:43,210
mitigate things hopefully it does this

00:58:41,529 --> 00:58:45,430
is gonna run really slow but it's also

00:58:43,210 --> 00:58:46,480
not gonna produce my stream all right

00:58:45,430 --> 00:58:47,500
it's not it's not like nothing's

00:58:46,480 --> 00:58:49,779
happening here and that's that's a good

00:58:47,500 --> 00:58:51,130
thing it's running I can even I can even

00:58:49,779 --> 00:58:52,869
build the debug version if you if you're

00:58:51,130 --> 00:58:56,619
all are worried that I'm playing I'm

00:58:52,869 --> 00:58:57,849
being sneaky here so I have a debug

00:58:56,619 --> 00:58:59,920
version that actually prints out stuff

00:58:57,849 --> 00:59:01,539
while it's going we're trying to leak

00:58:59,920 --> 00:59:02,829
you at the secret and you're seeing what

00:59:01,539 --> 00:59:06,690
it's finding here and it's not finding

00:59:02,829 --> 00:59:09,640
any character data from the secret right

00:59:06,690 --> 00:59:14,109
and just so that we're all clear I don't

00:59:09,640 --> 00:59:16,260
have anything up my sleeve comment this

00:59:14,109 --> 00:59:16,260
out

00:59:18,510 --> 00:59:23,369
have to rebuild goes right back to

00:59:22,380 --> 00:59:26,609
working okay

00:59:23,369 --> 00:59:29,760
so elephants works that's nice we like

00:59:26,609 --> 00:59:31,619
we like like mitigations that work but

00:59:29,760 --> 00:59:33,000
it is a bit slow and it can be really

00:59:31,619 --> 00:59:34,590
expensive and they're cheaper ways to do

00:59:33,000 --> 00:59:35,880
the same thing if you can go through and

00:59:34,590 --> 00:59:37,680
mitigate each and every one of your

00:59:35,880 --> 00:59:39,600
branches so with Google and arm have

00:59:37,680 --> 00:59:41,760
been looking at building api's to do

00:59:39,600 --> 00:59:42,960
this in a more more efficient way and in

00:59:41,760 --> 00:59:44,580
a little bit more clear way in the

00:59:42,960 --> 00:59:46,590
source code because an elephant feels

00:59:44,580 --> 00:59:48,270
pretty magical to just like oh no I just

00:59:46,590 --> 00:59:49,680
put in elephants here I'm good

00:59:48,270 --> 00:59:51,990
we can do something a little bit better

00:59:49,680 --> 00:59:53,280
with an API there's a lot of work to do

00:59:51,990 --> 00:59:55,740
that though I've got links up on the

00:59:53,280 --> 00:59:57,300
slides if you want to go to them this is

00:59:55,740 --> 00:59:58,380
going to show you kind of where where

00:59:57,300 --> 01:00:00,210
these different organizations are

00:59:58,380 --> 01:00:01,260
looking to build api's but we don't have

01:00:00,210 --> 01:00:02,369
anything that's really production

01:00:01,260 --> 01:00:04,260
quality and that you can reach out and

01:00:02,369 --> 01:00:05,760
use today the best you can do right now

01:00:04,260 --> 01:00:06,990
is actually something like elephants I

01:00:05,760 --> 01:00:08,400
think arm has a similar thing to

01:00:06,990 --> 01:00:10,710
elephants that they suggest within it

01:00:08,400 --> 01:00:12,420
within intrinsic as well but this

01:00:10,710 --> 01:00:14,460
doesn't scale well you have to manually

01:00:12,420 --> 01:00:18,210
do this to every single point in your

01:00:14,460 --> 01:00:19,980
code that's really really painful maybe

01:00:18,210 --> 01:00:21,810
you can use a static analysis tool to

01:00:19,980 --> 01:00:24,270
automate this but what we found is that

01:00:21,810 --> 01:00:26,670
the static analysis tools either cannot

01:00:24,270 --> 01:00:29,580
find the interesting gadgets that look

01:00:26,670 --> 01:00:31,170
like specter variant one because they

01:00:29,580 --> 01:00:32,820
are very careful and accurate and then

01:00:31,170 --> 01:00:36,720
they have they leave lots of unmitigated

01:00:32,820 --> 01:00:38,400
code or they find hundreds and hundreds

01:00:36,720 --> 01:00:40,530
and hundreds of gadgets that are

01:00:38,400 --> 01:00:43,710
completely impossible to actually reach

01:00:40,530 --> 01:00:45,930
with any kind of real-world scenario you

01:00:43,710 --> 01:00:48,300
can't actually get there and use them to

01:00:45,930 --> 01:00:49,850
conduct a specter kind of information

01:00:48,300 --> 01:00:52,950
leak so this means that they're not

01:00:49,850 --> 01:00:54,090
super satisfying to use they're better

01:00:52,950 --> 01:00:56,160
than the alternatives of doing it

01:00:54,090 --> 01:00:58,530
manually without static analysis tool

01:00:56,160 --> 01:01:01,980
but they're still pose real scalability

01:00:58,530 --> 01:01:03,330
problems so ultimately my conclusion is

01:01:01,980 --> 01:01:04,950
that this isn't going to continue to

01:01:03,330 --> 01:01:06,990
scale up to larger and larger

01:01:04,950 --> 01:01:08,490
applications we're already right about

01:01:06,990 --> 01:01:10,609
at the threshold of how much we can do

01:01:08,490 --> 01:01:13,380
with static analysis tools and manual

01:01:10,609 --> 01:01:17,460
mitigations when we're working on large

01:01:13,380 --> 01:01:19,740
applications so we need an alternative

01:01:17,460 --> 01:01:21,420
so there's another system called

01:01:19,740 --> 01:01:23,070
speculative load hardening this is also

01:01:21,420 --> 01:01:26,280
developed by Google and this is an

01:01:23,070 --> 01:01:28,710
automatic mitigation of variant 1 now

01:01:26,280 --> 01:01:31,010
this is not related to the specter flag

01:01:28,710 --> 01:01:32,810
in Microsoft's compiler that is not

01:01:31,010 --> 01:01:35,390
matic mitigation of variant 1 in all

01:01:32,810 --> 01:01:37,580
cases that handles specific cases that

01:01:35,390 --> 01:01:39,500
they've taught it about other kinds of

01:01:37,580 --> 01:01:40,970
variant 1 other instances of variant 1

01:01:39,500 --> 01:01:43,340
aren't caught by it which makes it

01:01:40,970 --> 01:01:46,250
potentially risky to use but this is a

01:01:43,340 --> 01:01:48,440
categorically different thing this is a

01:01:46,250 --> 01:01:50,720
transformation that removes the

01:01:48,440 --> 01:01:53,630
fundamental exploitable entity of

01:01:50,720 --> 01:01:55,400
variant 1 from your code and it does it

01:01:53,630 --> 01:01:57,530
systematically across every single piece

01:01:55,400 --> 01:01:59,540
of code you compile you still have to

01:01:57,530 --> 01:02:00,860
recompile your code but you can deploy

01:01:59,540 --> 01:02:03,800
this to get kind of comprehensive

01:02:00,860 --> 01:02:06,140
mitigation of variant 1 just so you are

01:02:03,800 --> 01:02:08,000
aware this is incredibly complex it's

01:02:06,140 --> 01:02:09,590
still very very brittle this has been

01:02:08,000 --> 01:02:11,690
you know something we're working on for

01:02:09,590 --> 01:02:12,710
a long time but I don't want you to get

01:02:11,690 --> 01:02:14,390
the impression that like this is

01:02:12,710 --> 01:02:16,370
production quality ready to go right out

01:02:14,390 --> 01:02:17,780
the door right we're all still really

01:02:16,370 --> 01:02:20,150
working on this but I wanna try to

01:02:17,780 --> 01:02:22,220
explain how this can work so let's take

01:02:20,150 --> 01:02:24,410
an example this is a little bit

01:02:22,220 --> 01:02:26,060
simplified version of the spectrum

01:02:24,410 --> 01:02:27,890
variant one example from from the

01:02:26,060 --> 01:02:30,140
original paper alright so we have a

01:02:27,890 --> 01:02:32,330
function except some untrusted offset

01:02:30,140 --> 01:02:35,420
some arrays right and it's going to try

01:02:32,330 --> 01:02:36,830
and do a balance check all right so we

01:02:35,420 --> 01:02:38,600
come down we do a balance check when you

01:02:36,830 --> 01:02:40,610
potentially bypass this balance check so

01:02:38,600 --> 01:02:42,280
let's look at how this bypass will

01:02:40,610 --> 01:02:46,010
balance check is actually implemented in

01:02:42,280 --> 01:02:48,260
x86 if we compile this code down we get

01:02:46,010 --> 01:02:49,940
the instructions on the right ok these

01:02:48,260 --> 01:02:51,950
instructions are going to compare

01:02:49,940 --> 01:02:53,390
whether we're below the bound right if

01:02:51,950 --> 01:02:56,720
we're greater than or equal to the bound

01:02:53,390 --> 01:03:00,650
we're going to skip this body of code ok

01:02:56,720 --> 01:03:02,360
that's what this does now when we're

01:03:00,650 --> 01:03:04,430
going to use speculative load hardening

01:03:02,360 --> 01:03:06,920
we need to somehow transform this so

01:03:04,430 --> 01:03:10,100
that a branch predictor predicting that

01:03:06,920 --> 01:03:12,350
the bound is within the index is within

01:03:10,100 --> 01:03:14,330
the bound and predicting that we enter

01:03:12,350 --> 01:03:15,980
the code from working the way we do this

01:03:14,330 --> 01:03:17,630
is by instead of generating the code on

01:03:15,980 --> 01:03:19,280
the right we generate the code on the

01:03:17,630 --> 01:03:20,510
left so we're trying to walk through

01:03:19,280 --> 01:03:23,630
this code on the left this is for the

01:03:20,510 --> 01:03:26,330
same seek C++ pattern and understand how

01:03:23,630 --> 01:03:28,700
it works first we need to build what we

01:03:26,330 --> 01:03:30,680
call a Miss speculation mask this is

01:03:28,700 --> 01:03:32,720
just all ones we're going to use this

01:03:30,680 --> 01:03:34,940
whenever we detect MS speculation in

01:03:32,720 --> 01:03:38,030
order to harden the behavior of the

01:03:34,940 --> 01:03:39,740
program we also need to extract the

01:03:38,030 --> 01:03:42,290
callers mask because speculative

01:03:39,740 --> 01:03:43,340
execution can move across function calls

01:03:42,290 --> 01:03:44,960
it could be interpreter

01:03:43,340 --> 01:03:47,750
so we want to

01:03:44,960 --> 01:03:49,220
the color pass in any speculation state

01:03:47,750 --> 01:03:52,099
that it has and we pass it in in the

01:03:49,220 --> 01:03:53,630
high bit of the stack pointer okay so

01:03:52,099 --> 01:03:55,460
this transforms the hive it in the stack

01:03:53,630 --> 01:03:57,800
pointer into a mask of either all ones

01:03:55,460 --> 01:03:59,510
or LZ rows and in a normal program you'd

01:03:57,800 --> 01:04:01,490
expect this to all be zeros and in a

01:03:59,510 --> 01:04:03,349
Miss speculated execution this is going

01:04:01,490 --> 01:04:06,410
to be all ones just like our miss

01:04:03,349 --> 01:04:08,270
speculation mask now we do our

01:04:06,410 --> 01:04:10,640
comparison just like we did before we

01:04:08,270 --> 01:04:12,950
have our branch just like we did before

01:04:10,640 --> 01:04:15,349
and we may miss predict this branch

01:04:12,950 --> 01:04:17,410
if we miss predict the branch though

01:04:15,349 --> 01:04:20,210
we're going to enter this basic block

01:04:17,410 --> 01:04:23,210
when the condition is actually greater

01:04:20,210 --> 01:04:25,160
than or equal to and so in that case we

01:04:23,210 --> 01:04:29,329
have a seam of instruction and seam of

01:04:25,160 --> 01:04:33,170
instructions today are not predicted by

01:04:29,329 --> 01:04:35,300
any x86 hardware and so as a consequence

01:04:33,170 --> 01:04:37,910
we can write the see move using the same

01:04:35,300 --> 01:04:39,710
flag greater than or equal to and if we

01:04:37,910 --> 01:04:43,220
enter this block when that flag is set

01:04:39,710 --> 01:04:45,859
which should never happen we write the

01:04:43,220 --> 01:04:48,440
Miss speculation mask over our predicate

01:04:45,859 --> 01:04:50,150
state over this this state that we got

01:04:48,440 --> 01:04:52,579
from the color right this essentially

01:04:50,150 --> 01:04:56,869
collapses us to the all one's if we ever

01:04:52,579 --> 01:04:58,400
miss speculate this branch then we come

01:04:56,869 --> 01:05:00,109
down we load some memory just like

01:04:58,400 --> 01:05:03,020
normal but keep in mind this may have

01:05:00,109 --> 01:05:04,490
loaded Ally Keable bits these these bits

01:05:03,020 --> 01:05:06,829
may actually be something that can get

01:05:04,490 --> 01:05:09,530
leaked in in an in some kind of actual

01:05:06,829 --> 01:05:11,480
attack scenario there's some operations

01:05:09,530 --> 01:05:13,309
on this that we actually allow these are

01:05:11,480 --> 01:05:14,809
data invariant operations these are the

01:05:13,309 --> 01:05:17,299
same kinds of operations we would allow

01:05:14,809 --> 01:05:19,640
on private keys if we were implementing

01:05:17,299 --> 01:05:22,430
a cryptographic algorithm they do not

01:05:19,640 --> 01:05:24,530
exhibit any change in behavior based on

01:05:22,430 --> 01:05:26,270
the data that they observe and so

01:05:24,530 --> 01:05:27,650
they're safe to run over this data they

01:05:26,270 --> 01:05:29,210
don't they just they just move things

01:05:27,650 --> 01:05:32,540
around and there's nothing that you can

01:05:29,210 --> 01:05:35,839
glean from these but before we actually

01:05:32,540 --> 01:05:38,900
use this piece of data to to index

01:05:35,839 --> 01:05:40,970
another array we mask it with our

01:05:38,900 --> 01:05:44,000
predicate state we or all of those bits

01:05:40,970 --> 01:05:45,829
over the data that we loaded okay and

01:05:44,000 --> 01:05:48,740
because of this if we miss speculated

01:05:45,829 --> 01:05:51,140
all of the bits are now all ones none of

01:05:48,740 --> 01:05:52,819
what we loaded is observable and so the

01:05:51,140 --> 01:05:57,829
fact that we then do this data dependent

01:05:52,819 --> 01:05:58,950
load remains safe okay so this is the

01:05:57,829 --> 01:06:00,960
core

01:05:58,950 --> 01:06:04,020
spective lode hardening and we do this

01:06:00,960 --> 01:06:06,540
for every single predictable branch in

01:06:04,020 --> 01:06:08,640
the entire program and we do this

01:06:06,540 --> 01:06:11,430
hardening for every single piece of

01:06:08,640 --> 01:06:13,650
loaded data in the entire program it's

01:06:11,430 --> 01:06:16,349
very very comprehensive there aren't

01:06:13,650 --> 01:06:18,869
these huge gaps in what gets hardened

01:06:16,349 --> 01:06:22,859
and what doesn't get hardened okay but

01:06:18,869 --> 01:06:25,470
there is a catch the overhead is nuts

01:06:22,859 --> 01:06:28,859
it's just beyond belief it's huge

01:06:25,470 --> 01:06:32,640
30 to 40% CPU overhead is a best-case

01:06:28,859 --> 01:06:34,619
scenario scenario okay worst-case

01:06:32,640 --> 01:06:36,390
scenario is even worse than this right I

01:06:34,619 --> 01:06:38,339
if you don't you don't access a lot of

01:06:36,390 --> 01:06:40,560
memory then it can be lower overhead

01:06:38,339 --> 01:06:43,619
than this but I don't know you don't

01:06:40,560 --> 01:06:45,480
access a lot of memory which is weird so

01:06:43,619 --> 01:06:46,800
for most applications we expected this

01:06:45,480 --> 01:06:48,150
overhead to be very large we've built a

01:06:46,800 --> 01:06:49,950
very large service with this we've

01:06:48,150 --> 01:06:51,570
actually like had them test it right in

01:06:49,950 --> 01:06:53,280
in a live situation so we could actually

01:06:51,570 --> 01:06:54,780
measure the real-world performance

01:06:53,280 --> 01:06:56,880
overhead this is a very realistic

01:06:54,780 --> 01:06:58,680
performance overhead you can expect from

01:06:56,880 --> 01:07:01,440
deploying spective load hardening to

01:06:58,680 --> 01:07:02,910
your service and I am very aware that

01:07:01,440 --> 01:07:04,800
this is not an acceptable amount of

01:07:02,910 --> 01:07:07,200
overhead for most systems they probably

01:07:04,800 --> 01:07:09,510
don't have the CPU just kicking around

01:07:07,200 --> 01:07:10,770
if their latency sensitive this is

01:07:09,510 --> 01:07:13,319
actually going to impact your latency

01:07:10,770 --> 01:07:15,450
right if you're not latency sensitive

01:07:13,319 --> 01:07:18,150
you're still going to need a 30 to 40

01:07:15,450 --> 01:07:20,579
percent increase in capacity of CPU to

01:07:18,150 --> 01:07:22,020
handle this or 30 to 40 percent decrease

01:07:20,579 --> 01:07:23,790
in the amount of battery you have if

01:07:22,020 --> 01:07:25,770
you're running on a device this is a

01:07:23,790 --> 01:07:27,420
really really problematic overhead

01:07:25,770 --> 01:07:29,609
unfortunately this is the best that we

01:07:27,420 --> 01:07:31,800
know how to do while still being truly

01:07:29,609 --> 01:07:33,630
comprehensive the only things we know to

01:07:31,800 --> 01:07:36,599
really reduce this at this point also

01:07:33,630 --> 01:07:38,609
open up exposure to various forms of

01:07:36,599 --> 01:07:41,250
attack and that's not what we want it's

01:07:38,609 --> 01:07:43,400
not the trade-off we want to make so

01:07:41,250 --> 01:07:45,990
what else can we do this has been a grim

01:07:43,400 --> 01:07:48,300
list of stories about mitigation well

01:07:45,990 --> 01:07:51,089
the other thing you can do is you can

01:07:48,300 --> 01:07:54,119
isolate your secret data from the risky

01:07:51,089 --> 01:07:55,290
code okay sandbox any and this is

01:07:54,119 --> 01:07:58,140
actually the thing that works even for

01:07:55,290 --> 01:08:00,569
untrusted code when you have sandbox

01:07:58,140 --> 01:08:03,030
code right you have to actually separate

01:08:00,569 --> 01:08:06,980
it from the Dana with some kind of

01:08:03,030 --> 01:08:09,690
processor level a security abstraction

01:08:06,980 --> 01:08:11,819
typically separate processes on a modern

01:08:09,690 --> 01:08:12,510
operating system right that's really the

01:08:11,819 --> 01:08:14,369
only thing

01:08:12,510 --> 01:08:15,780
it's enough for untrusted code because

01:08:14,369 --> 01:08:18,000
this is the only mitigation we

01:08:15,780 --> 01:08:19,680
realistically have for variant for this

01:08:18,000 --> 01:08:21,930
is what all the browsers are working on

01:08:19,680 --> 01:08:24,089
in order to mitigate variant for long

01:08:21,930 --> 01:08:26,190
term everything else looks short-term

01:08:24,089 --> 01:08:29,700
too expensive or doesn't work in enough

01:08:26,190 --> 01:08:31,680
cases the other interesting thing is if

01:08:29,700 --> 01:08:34,049
you do this this protects against all of

01:08:31,680 --> 01:08:35,790
the other variants of Spectre okay if

01:08:34,049 --> 01:08:38,040
you if you actually can separate your

01:08:35,790 --> 01:08:39,600
code in this way you are truly protected

01:08:38,040 --> 01:08:41,520
from Spectre and it gets better

01:08:39,600 --> 01:08:44,069
you're also protected from bugs like

01:08:41,520 --> 01:08:46,290
heartbleed right it's now very hard to

01:08:44,069 --> 01:08:48,390
leak information at all because the

01:08:46,290 --> 01:08:50,370
attacker doesn't have access to the

01:08:48,390 --> 01:08:52,319
program that actually is touching the

01:08:50,370 --> 01:08:54,540
secret data so the extent to which you

01:08:52,319 --> 01:08:56,549
can design your system this way is it

01:08:54,540 --> 01:08:58,170
can really really increase the security

01:08:56,549 --> 01:09:00,569
of your system it can really make it

01:08:58,170 --> 01:09:03,450
hard to to suffer from information leak

01:09:00,569 --> 01:09:04,739
vulnerabilities in general so we really

01:09:03,450 --> 01:09:09,210
do think this is a this is a powerful

01:09:04,739 --> 01:09:11,069
mitigation approach ultimately you're

01:09:09,210 --> 01:09:12,270
going to need some combination of

01:09:11,069 --> 01:09:16,049
approaches target to your application oh

01:09:12,270 --> 01:09:19,109
I almost forgot sorry I forgot we

01:09:16,049 --> 01:09:21,029
actually can live - about this - so

01:09:19,109 --> 01:09:26,970
justjust just so that we're all on the

01:09:21,029 --> 01:09:29,040
same side I build this and you can see

01:09:26,970 --> 01:09:31,230
there's there's a little there's an

01:09:29,040 --> 01:09:35,069
extra flag in there and now when I run

01:09:31,230 --> 01:09:37,529
it whoa that's not good helps if you run

01:09:35,069 --> 01:09:41,009
the right program so when I actually run

01:09:37,529 --> 01:09:42,569
the mitigated one it doesn't leak

01:09:41,009 --> 01:09:46,230
anything alright this is just like

01:09:42,569 --> 01:09:47,580
linking random bytes of data okay and if

01:09:46,230 --> 01:09:48,750
you want I can like open up the binary

01:09:47,580 --> 01:09:50,370
we can stare at it it's going to look a

01:09:48,750 --> 01:09:55,700
lot like what I present it but this

01:09:50,370 --> 01:09:55,700
actually does work okay

01:09:58,030 --> 01:10:02,260
so you do want to expect to like need

01:10:00,940 --> 01:10:03,700
some mixture of these things you've got

01:10:02,260 --> 01:10:05,740
to look at your application your threat

01:10:03,700 --> 01:10:07,930
model your performance characteristics

01:10:05,740 --> 01:10:09,850
how much of an overhead you can take to

01:10:07,930 --> 01:10:11,560
pick some approach here right there's

01:10:09,850 --> 01:10:13,270
not this like oh yeah you do this this

01:10:11,560 --> 01:10:14,650
this you're done go home everything is

01:10:13,270 --> 01:10:16,270
easy that's why I gave a long

01:10:14,650 --> 01:10:19,390
presentation about it this isn't this

01:10:16,270 --> 01:10:20,800
isn't sadly the easy easy case so

01:10:19,390 --> 01:10:21,970
there's also some stuff I want to see

01:10:20,800 --> 01:10:23,080
you in the future because like I said

01:10:21,970 --> 01:10:24,850
we're not done here

01:10:23,080 --> 01:10:26,080
like we're not finished so I've got

01:10:24,850 --> 01:10:28,750
three things that I would really really

01:10:26,080 --> 01:10:30,910
like to see number one we have to have a

01:10:28,750 --> 01:10:33,430
cheaper operating system and hardware

01:10:30,910 --> 01:10:34,900
solution for sandboxing protections like

01:10:33,430 --> 01:10:36,730
the last one I mentioned because that's

01:10:34,900 --> 01:10:39,190
the most durable protection provides the

01:10:36,730 --> 01:10:40,660
most value by far we need an easier way

01:10:39,190 --> 01:10:42,550
to do this the browser vendors are

01:10:40,660 --> 01:10:44,770
really struggling doing this today and

01:10:42,550 --> 01:10:47,560
we should make that much much better so

01:10:44,770 --> 01:10:50,020
that we can deploy it more widely the

01:10:47,560 --> 01:10:52,180
second thing is cryptography really

01:10:50,020 --> 01:10:54,490
needs to change the idea that you do

01:10:52,180 --> 01:10:57,130
cryptography with a long-lived

01:10:54,490 --> 01:11:01,450
private key that you keep in your memory

01:10:57,130 --> 01:11:02,980
is a very bad idea we need to go and

01:11:01,450 --> 01:11:05,260
make sure every single cryptographic

01:11:02,980 --> 01:11:07,120
system is separating the long-lived

01:11:05,260 --> 01:11:08,970
private key data into a separate

01:11:07,120 --> 01:11:11,530
subsystem in a separate process

01:11:08,970 --> 01:11:13,840
potentially leaving it on disk until it

01:11:11,530 --> 01:11:15,490
needs it because this is too high risk

01:11:13,840 --> 01:11:17,530
we have the cryptographic primitives we

01:11:15,490 --> 01:11:21,460
need here things like ephemeral keys in

01:11:17,530 --> 01:11:24,640
a TLS 1.3 we have good techniques here

01:11:21,460 --> 01:11:26,470
in the cryptographic space we need to

01:11:24,640 --> 01:11:28,660
use them we need to stop using older

01:11:26,470 --> 01:11:30,550
cryptographic systems that require these

01:11:28,660 --> 01:11:34,180
long-lived stable private keys

01:11:30,550 --> 01:11:36,670
especially small elliptic curve stable

01:11:34,180 --> 01:11:38,530
private keys to be visible in memory to

01:11:36,670 --> 01:11:40,930
a system under attack that's a very very

01:11:38,530 --> 01:11:44,920
bad long-term proposition in the wake of

01:11:40,930 --> 01:11:47,020
Spectre and last I think we have to

01:11:44,920 --> 01:11:49,450
solve Spectre v1 and hardware I do not

01:11:47,020 --> 01:11:52,840
think that anything I've shown you for a

01:11:49,450 --> 01:11:55,270
v1 is tenable long term I think we may

01:11:52,840 --> 01:11:57,700
be able to sneak by for the next five to

01:11:55,270 --> 01:11:59,320
ten years while the hardware community

01:11:57,700 --> 01:12:01,660
moves on this I understand that there

01:11:59,320 --> 01:12:04,030
are real timeline issues here that they

01:12:01,660 --> 01:12:06,640
cannot change but they must actually

01:12:04,030 --> 01:12:07,330
solve this in Hardware think of it a

01:12:06,640 --> 01:12:09,660
different way

01:12:07,330 --> 01:12:10,960
I do not believe that we can teach

01:12:09,660 --> 01:12:14,469
programmers

01:12:10,960 --> 01:12:16,180
to think about Spectre v1 all right how

01:12:14,469 --> 01:12:18,010
do we teach programmers we say like well

01:12:16,180 --> 01:12:19,390
you have these set of assumptions and

01:12:18,010 --> 01:12:20,800
once you build up these assumptions you

01:12:19,390 --> 01:12:21,880
work within them and then you build up

01:12:20,800 --> 01:12:23,230
more assumptions and you work within

01:12:21,880 --> 01:12:25,000
those and you build up more assumptions

01:12:23,230 --> 01:12:29,739
you work within those and how to Spectre

01:12:25,000 --> 01:12:31,150
work it says not really I mean you have

01:12:29,739 --> 01:12:32,820
all those assumptions they're very nice

01:12:31,150 --> 01:12:35,350
but I didn't pay any attention to them

01:12:32,820 --> 01:12:37,000
right now we have to teach people to

01:12:35,350 --> 01:12:39,280
think about the behavior of their code

01:12:37,000 --> 01:12:42,360
when literally none of their predicates

01:12:39,280 --> 01:12:44,920
hold and I don't think that's viable

01:12:42,360 --> 01:12:46,719
right this is different from saying like

01:12:44,920 --> 01:12:48,610
today we have C++ without contracts

01:12:46,719 --> 01:12:50,530
right we're going to get contracts to it

01:12:48,610 --> 01:12:52,660
this is worse than going back to C++

01:12:50,530 --> 01:12:54,580
without contracts because today what we

01:12:52,660 --> 01:12:56,350
have are unenforced contracts we have

01:12:54,580 --> 01:12:58,120
contracts in our documentation in our

01:12:56,350 --> 01:13:00,430
comments everywhere right we have

01:12:58,120 --> 01:13:03,430
asserts we have predicates everywhere

01:13:00,430 --> 01:13:05,650
imagine having none of them and having

01:13:03,430 --> 01:13:07,989
to write code that was correctly behaved

01:13:05,650 --> 01:13:10,300
even in their absence I don't think that

01:13:07,989 --> 01:13:12,040
that's viable and so I do not think we

01:13:10,300 --> 01:13:14,200
can exist in the computational world

01:13:12,040 --> 01:13:16,570
where a specter of e1 is the thing

01:13:14,200 --> 01:13:18,400
programmers are thinking about I think

01:13:16,570 --> 01:13:21,580
we have to actually remove it right and

01:13:18,400 --> 01:13:24,430
so I give you a brief conclusion right

01:13:21,580 --> 01:13:27,330
Spectre missed speculation side channels

01:13:24,430 --> 01:13:29,620
give you information leak of secrets

01:13:27,330 --> 01:13:31,420
it's a new and it's an active area of

01:13:29,620 --> 01:13:35,230
research this is going to keep happening

01:13:31,420 --> 01:13:38,800
for a long long time we have at least a

01:13:35,230 --> 01:13:41,739
year maybe years plural of issues that

01:13:38,800 --> 01:13:43,180
have yet to be discovered you need to

01:13:41,739 --> 01:13:45,910
have a threat model to understand its

01:13:43,180 --> 01:13:47,920
implications for you and you need to

01:13:45,910 --> 01:13:50,050
tailor whatever mitigation strategy to

01:13:47,920 --> 01:13:52,710
your application because there is not a

01:13:50,050 --> 01:13:55,210
single one that looks promising and

01:13:52,710 --> 01:13:59,020
ultimately I want all of you to help me

01:13:55,210 --> 01:14:02,650
convince our CPU vendors they must fix

01:13:59,020 --> 01:14:05,380
Spectre v1 in hardware we can't actually

01:14:02,650 --> 01:14:07,480
sustain this this world where our

01:14:05,380 --> 01:14:08,440
assumptions do not hold all right and so

01:14:07,480 --> 01:14:10,300
hopefully you all can help me with that

01:14:08,440 --> 01:14:11,920
and I thank all of you and I also want

01:14:10,300 --> 01:14:13,030
to thank all the security researchers

01:14:11,920 --> 01:14:15,340
that I've been working with for the last

01:14:13,030 --> 01:14:16,840
year across the industry it's a

01:14:15,340 --> 01:14:18,370
tremendous group of people they've

01:14:16,840 --> 01:14:19,810
taught me a whole lot hopefully I've

01:14:18,370 --> 01:14:22,240
taught you all at least a little bit and

01:14:19,810 --> 01:14:25,830
I'm happy to take questions

01:14:22,240 --> 01:14:25,830
[Applause]

01:14:30,110 --> 01:14:35,000
and it just as a quick reminder we only

01:14:33,410 --> 01:14:36,530
have a few minutes for questions like

01:14:35,000 --> 01:14:37,820
four or five minutes for questions I'm

01:14:36,530 --> 01:14:39,650
just I would really encourage you to

01:14:37,820 --> 01:14:41,030
focus your questions on my talk we're

01:14:39,650 --> 01:14:43,370
going to have a panel to talk about

01:14:41,030 --> 01:14:45,230
everything to do with Specter in about

01:14:43,370 --> 01:14:47,150
you know just over half an hour I'll be

01:14:45,230 --> 01:14:48,710
there a couple of of the other folks

01:14:47,150 --> 01:14:50,300
working on this will be there if you

01:14:48,710 --> 01:14:51,680
have generic questions feel free to wait

01:14:50,300 --> 01:14:53,480
until then and we'll try to answer them

01:14:51,680 --> 01:14:54,620
in with that let's let's do the question

01:14:53,480 --> 01:14:56,990
on the left or the right here

01:14:54,620 --> 01:15:00,710
so some mitigations require a

01:14:56,990 --> 01:15:03,470
compilation i'm i'd like to understand

01:15:00,710 --> 01:15:06,530
it's like a compilation of everything

01:15:03,470 --> 01:15:09,110
right so it's not see specific problem

01:15:06,530 --> 01:15:09,650
it's processor instructions specific

01:15:09,110 --> 01:15:12,650
problem

01:15:09,650 --> 01:15:14,420
yes right so the key thing here is as we

01:15:12,650 --> 01:15:16,040
as we start to work with Specter we see

01:15:14,420 --> 01:15:18,620
an increasing need for you to be able to

01:15:16,040 --> 01:15:22,310
recompile all of your source code in

01:15:18,620 --> 01:15:24,740
your application somehow ok because all

01:15:22,310 --> 01:15:28,100
of it potentially has the vulnerable

01:15:24,740 --> 01:15:30,380
piece so that's true about Java managed

01:15:28,100 --> 01:15:31,640
systems and whatever to a certain extent

01:15:30,380 --> 01:15:34,940
is true of Java and managed systems

01:15:31,640 --> 01:15:36,950
however constructing ways to actually

01:15:34,940 --> 01:15:46,660
break these types of things as much

01:15:36,950 --> 01:15:48,950
harder in managed systems so this this

01:15:46,660 --> 01:15:51,020
is based on the fact that the

01:15:48,950 --> 01:15:53,090
speculative execution executes its code

01:15:51,020 --> 01:15:56,030
that is actually not supposed to run in

01:15:53,090 --> 01:15:58,130
so eventually the pipeline will catch up

01:15:56,030 --> 01:15:59,600
and the CPU will realize that ok I'm

01:15:58,130 --> 01:16:02,410
actually not supposed to execute this

01:15:59,600 --> 01:16:05,540
branch and then stop executing it yeah

01:16:02,410 --> 01:16:08,150
just like a ballpark estimate how much

01:16:05,540 --> 01:16:09,890
code can I get into that before the CPU

01:16:08,150 --> 01:16:12,440
realizes that oh I shouldn't be

01:16:09,890 --> 01:16:13,790
executing this and stops doing it that's

01:16:12,440 --> 01:16:16,340
a great question so the key question is

01:16:13,790 --> 01:16:18,260
how much code can be spectively executed

01:16:16,340 --> 01:16:20,780
in this window what's the window of my

01:16:18,260 --> 01:16:22,190
risk I have been asking processor

01:16:20,780 --> 01:16:24,460
vendors with that question for a long

01:16:22,190 --> 01:16:26,390
time and they they will not answer me

01:16:24,460 --> 01:16:28,370
but I'm not throwing them under the bus

01:16:26,390 --> 01:16:29,570
I actually understand why increasingly I

01:16:28,370 --> 01:16:31,580
really understand white I don't think

01:16:29,570 --> 01:16:34,340
that there is a simple answer it's not

01:16:31,580 --> 01:16:35,390
that easy to reason about because what

01:16:34,340 --> 01:16:37,400
you actually are seeing is the

01:16:35,390 --> 01:16:39,560
exhaustion of resources on the processor

01:16:37,400 --> 01:16:42,260
but different kinds of instructions

01:16:39,560 --> 01:16:44,450
exhaust resources at different rates

01:16:42,260 --> 01:16:45,650
it's very hard to say oh no 100

01:16:44,450 --> 01:16:47,570
instructions and then you'll be done

01:16:45,650 --> 01:16:48,770
because different instructions may take

01:16:47,570 --> 01:16:50,980
up different amounts of resources

01:16:48,770 --> 01:16:53,270
however in practice we have seen

01:16:50,980 --> 01:16:57,890
hundreds of instructions execute

01:16:53,270 --> 01:16:59,390
speculate not tens hundreds and we

01:16:57,890 --> 01:17:02,239
should expect that we will get better

01:16:59,390 --> 01:17:04,370
and better and at tickling this

01:17:02,239 --> 01:17:06,290
particular weird part of the processor

01:17:04,370 --> 01:17:08,660
and sending it further and further down

01:17:06,290 --> 01:17:10,310
these traces we should also expect that

01:17:08,660 --> 01:17:11,870
processors are going to speculate more

01:17:10,310 --> 01:17:16,700
and more as they get larger and more

01:17:11,870 --> 01:17:18,770
powerful okay thanks you said a

01:17:16,700 --> 01:17:20,930
mitigation for this is to put the

01:17:18,770 --> 01:17:23,390
untrusted Kohner separate process from

01:17:20,930 --> 01:17:24,440
the secret data correct but you also

01:17:23,390 --> 01:17:26,960
said that there's something called Nets

01:17:24,440 --> 01:17:29,540
vector where you can exploit over a

01:17:26,960 --> 01:17:31,400
network how does that work so if you're

01:17:29,540 --> 01:17:33,980
moving untrusted code into a separate

01:17:31,400 --> 01:17:36,590
process which are protecting the data

01:17:33,980 --> 01:17:39,680
from is the untrusted code you can also

01:17:36,590 --> 01:17:42,530
move trusted code that handles untrusted

01:17:39,680 --> 01:17:45,140
inputs to a separate process okay and

01:17:42,530 --> 01:17:48,080
then net Spectre is going to you know

01:17:45,140 --> 01:17:50,450
leverage that code to read data in that

01:17:48,080 --> 01:17:52,670
process but if that process doesn't

01:17:50,450 --> 01:17:55,370
expose to its untrusted inputs any

01:17:52,670 --> 01:17:57,710
control over the inputs to the process

01:17:55,370 --> 01:18:00,050
with the secret data you can't construct

01:17:57,710 --> 01:18:02,239
an attack you have to think really

01:18:00,050 --> 01:18:07,010
carefully about just how trusted is my

01:18:02,239 --> 01:18:10,100
input right can I fully a a fully trust

01:18:07,010 --> 01:18:12,380
can fully validate your communication

01:18:10,100 --> 01:18:15,080
the secondary communication from the RIT

01:18:12,380 --> 01:18:17,060
at risk process to the trusted process

01:18:15,080 --> 01:18:19,130
right but sometimes you can do that

01:18:17,060 --> 01:18:21,440
right sometimes you can say like no all

01:18:19,130 --> 01:18:24,320
of the communication there is written by

01:18:21,440 --> 01:18:26,390
the programmer is trusted all all we can

01:18:24,320 --> 01:18:28,760
do is select between those we can't

01:18:26,390 --> 01:18:30,290
construct arbitrary risky inputs so now

01:18:28,760 --> 01:18:32,060
we can trust our inputs and the trusted

01:18:30,290 --> 01:18:38,540
process we don't have to worry about a

01:18:32,060 --> 01:18:41,870
specter vulnerability absolutely at risk

01:18:38,540 --> 01:18:44,920
code is either untrusted code or code

01:18:41,870 --> 01:18:44,920
handling untrusted data

01:18:48,780 --> 01:18:55,849
it seems to me that the whole issue is

01:18:51,889 --> 01:18:59,010
because the CPUs are trying to speculate

01:18:55,849 --> 01:19:04,500
where they are going or try to do this

01:18:59,010 --> 01:19:10,309
optimize optimization on their own the

01:19:04,500 --> 01:19:10,309
way of they are working yes

01:19:10,730 --> 01:19:18,030
so how how bad would be to turn this

01:19:15,840 --> 01:19:21,449
completely off what's the cost of

01:19:18,030 --> 01:19:22,770
turning off specter of execution it's

01:19:21,449 --> 01:19:24,840
actually pretty easy to simulate this

01:19:22,770 --> 01:19:26,880
when I built the spectra of load

01:19:24,840 --> 01:19:29,760
hardening compiler pass I also built

01:19:26,880 --> 01:19:31,679
something that added Intel's suggested

01:19:29,760 --> 01:19:33,869
mitigation of an elephants but instead

01:19:31,679 --> 01:19:36,659
of doing it only on the risky branch it

01:19:33,869 --> 01:19:38,340
adds them on all of them it's a very

01:19:36,659 --> 01:19:40,500
simple transformation much simpler than

01:19:38,340 --> 01:19:41,670
the specter of load hardening and I

01:19:40,500 --> 01:19:42,719
measured the performance of that and

01:19:41,670 --> 01:19:44,250
that's actually an interesting thing to

01:19:42,719 --> 01:19:46,530
look at because what elephants does is

01:19:44,250 --> 01:19:49,020
it essentially blocks speculation past

01:19:46,530 --> 01:19:51,210
the fence and so this doesn't turn it's

01:19:49,020 --> 01:19:53,099
speculative execution completely off but

01:19:51,210 --> 01:19:54,719
it dramatically reduces speculative

01:19:53,099 --> 01:19:56,039
execution on the processor the

01:19:54,719 --> 01:20:00,090
performance overhead of this

01:19:56,039 --> 01:20:04,909
transformation was somewhere between a 5

01:20:00,090 --> 01:20:07,289
X to a 20 or 50 X performance reduction

01:20:04,909 --> 01:20:09,929
there was like several several very

01:20:07,289 --> 01:20:12,809
tight computational loops so well over

01:20:09,929 --> 01:20:14,250
20 X performance reductions and at that

01:20:12,809 --> 01:20:18,900
point I started having trouble measuring

01:20:14,250 --> 01:20:21,570
with high accuracy so so I I don't think

01:20:18,900 --> 01:20:22,829
that's even remotely desirable due to

01:20:21,570 --> 01:20:24,869
the performance impact this is this

01:20:22,829 --> 01:20:27,030
shows you also how incredibly important

01:20:24,869 --> 01:20:28,409
aspect of execution is no one should

01:20:27,030 --> 01:20:30,570
leave this and be like oh those

01:20:28,409 --> 01:20:31,739
processor designers why do they have to

01:20:30,570 --> 01:20:36,539
use speculative execution

01:20:31,739 --> 01:20:39,480
it makes your program 20x faster right

01:20:36,539 --> 01:20:45,599
like it's really good unfortunately it

01:20:39,480 --> 01:20:46,980
does come with a problem hello I wonder

01:20:45,599 --> 01:20:49,469
on the impact on like compile

01:20:46,980 --> 01:20:51,770
optimizations for example when it was

01:20:49,469 --> 01:20:54,119
pretty new I'd try to get rid of all my

01:20:51,770 --> 01:20:56,039
indirect jumps by just not using

01:20:54,119 --> 01:20:57,690
function pointers and I observed that

01:20:56,039 --> 01:21:00,990
basically the only option I had to pass

01:20:57,690 --> 01:21:04,940
to my compiler was to disable

01:21:00,990 --> 01:21:07,770
jump tables to to get rid of it like

01:21:04,940 --> 01:21:10,920
like some compiler passes now being over

01:21:07,770 --> 01:21:12,660
thought to like maybe generate

01:21:10,920 --> 01:21:14,700
completely different code so the

01:21:12,660 --> 01:21:15,510
question is is Spectre really changing

01:21:14,700 --> 01:21:18,150
how we think about compiler

01:21:15,510 --> 01:21:19,620
optimizations I don't think it is in a

01:21:18,150 --> 01:21:22,170
lot of ways because a lot of software

01:21:19,620 --> 01:21:23,880
isn't really impacted by Specter and so

01:21:22,170 --> 01:21:25,620
we want the optimizations to run there

01:21:23,880 --> 01:21:27,180
but when we know we're mitigating

01:21:25,620 --> 01:21:29,550
against some part of Specter we

01:21:27,180 --> 01:21:30,930
definitely turn things off as necessary

01:21:29,550 --> 01:21:32,610
so when you're using reptilians for

01:21:30,930 --> 01:21:35,190
example we turn off building jump tables

01:21:32,610 --> 01:21:37,350
so that you know we we don't introduce

01:21:35,190 --> 01:21:40,350
more of these risky things that we then

01:21:37,350 --> 01:21:42,210
have to transform but I don't think

01:21:40,350 --> 01:21:44,250
there's a lot of impact beyond that long

01:21:42,210 --> 01:21:46,410
term mostly the impact on compiler

01:21:44,250 --> 01:21:48,920
optimizations is figuring out how we can

01:21:46,410 --> 01:21:56,460
mitigate these things less expensively

01:21:48,920 --> 01:21:58,140
okay thanks so most of the stuff for

01:21:56,460 --> 01:22:01,620
memory leaks all happens during

01:21:58,140 --> 01:22:03,980
speculative execution and gadget chains

01:22:01,620 --> 01:22:07,800
are relatively inefficient use of

01:22:03,980 --> 01:22:09,300
instructions how deep can you go how

01:22:07,800 --> 01:22:12,510
many instructions can you execute

01:22:09,300 --> 01:22:15,390
speculatively given the those two things

01:22:12,510 --> 01:22:17,460
combined so again we don't know we don't

01:22:15,390 --> 01:22:19,740
have card answers here but our our

01:22:17,460 --> 01:22:21,780
experimentation shows hundreds of

01:22:19,740 --> 01:22:23,730
instructions which is more than enough

01:22:21,780 --> 01:22:26,550
to to to form any of these information

01:22:23,730 --> 01:22:29,010
leaks I remember even even though your

01:22:26,550 --> 01:22:31,830
gadget chain for a wrap based gadget

01:22:29,010 --> 01:22:33,360
chain may be fairly inefficient the set

01:22:31,830 --> 01:22:35,730
of operations needed here is fairly

01:22:33,360 --> 01:22:37,830
small they fit into a pretty tight loop

01:22:35,730 --> 01:22:40,950
especially if you're willing to have a

01:22:37,830 --> 01:22:43,020
lower bandwidth timing mechanism so I

01:22:40,950 --> 01:22:45,030
used a fairly high bandwidth high

01:22:43,020 --> 01:22:46,950
reliability timing mechanism there are

01:22:45,030 --> 01:22:49,710
other approaches that are much shorter

01:22:46,950 --> 01:22:51,360
code sequences that for example extract

01:22:49,710 --> 01:22:53,400
a single bit at a time rather than

01:22:51,360 --> 01:22:55,440
extracting all eight bits of a byte in

01:22:53,400 --> 01:22:56,640
one go and so there are a lot of

01:22:55,440 --> 01:23:01,590
different ways you can you can construct

01:22:56,640 --> 01:23:04,230
this thank you so it sounds like you

01:23:01,590 --> 01:23:06,210
said that none of these approaches will

01:23:04,230 --> 01:23:08,010
work across a process or a hypervisor

01:23:06,210 --> 01:23:09,630
boundary and I was just curious if you

01:23:08,010 --> 01:23:11,900
could elaborate a little bit on why that

01:23:09,630 --> 01:23:14,880
is and what protects us in that scenario

01:23:11,900 --> 01:23:16,620
so the the key question here is the wire

01:23:14,880 --> 01:23:17,820
why are we safe across these these

01:23:16,620 --> 01:23:19,980
boundaries these operating system and

01:23:17,820 --> 01:23:23,100
hardware boundaries such as system calls

01:23:19,980 --> 01:23:24,989
privilege transitions virtual machine

01:23:23,100 --> 01:23:27,960
transitions fundamentally we aren't

01:23:24,989 --> 01:23:29,520
protected by these but inherently but

01:23:27,960 --> 01:23:31,320
the operating systems and hypervisors

01:23:29,520 --> 01:23:32,969
have all been updated in conjunction

01:23:31,320 --> 01:23:34,860
with the hardware to introduce

01:23:32,969 --> 01:23:36,179
protections on those boundaries so

01:23:34,860 --> 01:23:38,429
that's why the very first thing I said

01:23:36,179 --> 01:23:40,679
was you must have the operating system

01:23:38,429 --> 01:23:42,389
mitigations in place otherwise you don't

01:23:40,679 --> 01:23:46,380
have the fundamental tools to insulate

01:23:42,389 --> 01:23:47,670
one process from another thank you we're

01:23:46,380 --> 01:23:49,020
we're we're gonna cut this short but

01:23:47,670 --> 01:23:50,400
I'll take I'll take these three

01:23:49,020 --> 01:23:52,050
questions if you do have a question that

01:23:50,400 --> 01:23:54,150
would be fine at the panel consider if

01:23:52,050 --> 01:23:55,889
you can just wait in in 20 minutes and

01:23:54,150 --> 01:23:57,389
you can ask it then so you said that

01:23:55,889 --> 01:23:59,610
basically if you don't have anybody to

01:23:57,389 --> 01:24:01,440
steal the secrets then you're safe so

01:23:59,610 --> 01:24:04,159
like nobody process communicates with

01:24:01,440 --> 01:24:08,520
you're safe from from information leaks

01:24:04,159 --> 01:24:10,050
yes so I think I remember reading like

01:24:08,520 --> 01:24:12,570
when spectra came out that you can

01:24:10,050 --> 01:24:13,889
actually use it by just running another

01:24:12,570 --> 01:24:15,300
process on the same machine so like

01:24:13,889 --> 01:24:17,250
there's no obvious communication going

01:24:15,300 --> 01:24:19,860
on but you can like time caches or

01:24:17,250 --> 01:24:21,840
something yes like without any relation

01:24:19,860 --> 01:24:23,699
to unit processes you have to have some

01:24:21,840 --> 01:24:25,590
way of influencing the behavior of the

01:24:23,699 --> 01:24:27,330
thing you're running there are some edge

01:24:25,590 --> 01:24:30,000
cases where you can do that from outside

01:24:27,330 --> 01:24:32,940
of the process as just a sibling but

01:24:30,000 --> 01:24:34,380
those are pretty rare and isolated I

01:24:32,940 --> 01:24:36,530
think would be very very hard to do that

01:24:34,380 --> 01:24:38,909
you have no way of triggering a

01:24:36,530 --> 01:24:41,159
particular type of behavior of the

01:24:38,909 --> 01:24:44,219
victim it's gonna be very hard to cause

01:24:41,159 --> 01:24:46,920
it to then actually leak the information

01:24:44,219 --> 01:24:48,090
you really care about this is less true

01:24:46,920 --> 01:24:49,139
for some of the other things that are

01:24:48,090 --> 01:24:54,780
mitigated at the operating system level

01:24:49,139 --> 01:24:56,850
but for spectre specifically can you

01:24:54,780 --> 01:25:00,210
tell us anything about spectre and non

01:24:56,850 --> 01:25:01,409
memory related side channel attacks the

01:25:00,210 --> 01:25:03,360
question is are there other side

01:25:01,409 --> 01:25:05,610
channels and the answer is yes there are

01:25:03,360 --> 01:25:08,820
many many many other side channels

01:25:05,610 --> 01:25:10,679
branch scope showed a branch predictor

01:25:08,820 --> 01:25:14,190
of a side channel the net Spectre paper

01:25:10,679 --> 01:25:15,989
included a frequency based very

01:25:14,190 --> 01:25:18,330
generally a frequency slash power based

01:25:15,989 --> 01:25:20,670
side channel essentially any bit of

01:25:18,330 --> 01:25:23,790
state in the micro architecture of the

01:25:20,670 --> 01:25:26,400
processor that you can cause to change

01:25:23,790 --> 01:25:28,200
during speculative execution and that

01:25:26,400 --> 01:25:30,300
does not get rolled back

01:25:28,200 --> 01:25:33,300
is a candidate and there are a

01:25:30,300 --> 01:25:37,920
tremendous number of these things thank

01:25:33,300 --> 01:25:40,560
you so you ended with you talked with a

01:25:37,920 --> 01:25:42,810
sort of call to arms for us to help you

01:25:40,560 --> 01:25:47,430
convince I wouldn't say arms I would say

01:25:42,810 --> 01:25:49,050
action professions sure for us to help

01:25:47,430 --> 01:25:53,040
you convince hardware vendors to

01:25:49,050 --> 01:25:55,170
mitigate this in hardware yes I have

01:25:53,040 --> 01:25:57,450
heard that Google spends quite a lot of

01:25:55,170 --> 01:25:58,890
money with hardware vendors yeah so one

01:25:57,450 --> 01:26:01,950
might be forgiven for wondering if

01:25:58,890 --> 01:26:04,560
Google can't convince them what hope do

01:26:01,950 --> 01:26:06,630
the rest of us have so the key issue is

01:26:04,560 --> 01:26:08,700
why is one person asking the hardware

01:26:06,630 --> 01:26:10,140
vendor if that person buys an F CPUs why

01:26:08,700 --> 01:26:12,030
is one entity asking the hardware vendor

01:26:10,140 --> 01:26:14,850
not enough fundamentally these harder

01:26:12,030 --> 01:26:16,800
vendors are not in a good position to

01:26:14,850 --> 01:26:19,710
scale their production and their

01:26:16,800 --> 01:26:21,690
economies of their production in ways

01:26:19,710 --> 01:26:24,900
that differentiate between customers

01:26:21,690 --> 01:26:27,210
arbitrarily so so if only one customer

01:26:24,900 --> 01:26:29,070
really needs this to happen they may not

01:26:27,210 --> 01:26:30,990
be in a good position to spend a

01:26:29,070 --> 01:26:32,910
tremendous amount of money building that

01:26:30,990 --> 01:26:34,860
when only one of their customers will

01:26:32,910 --> 01:26:36,540
benefit if all of their customers want

01:26:34,860 --> 01:26:37,920
it right then they get the full

01:26:36,540 --> 01:26:40,140
economies of scale for that particular

01:26:37,920 --> 01:26:41,520
feature my fear is that this feature is

01:26:40,140 --> 01:26:43,350
going to be expensive enough when the

01:26:41,520 --> 01:26:45,900
hardware end that unless it's

01:26:43,350 --> 01:26:47,790
universally desired it won't make

01:26:45,900 --> 01:26:49,320
economic sense to the hardware vendor

01:26:47,790 --> 01:26:50,700
and so that's why I think everyone needs

01:26:49,320 --> 01:26:52,950
to do this but it's also important to

01:26:50,700 --> 01:26:56,040
keep in mind we literally do not know

01:26:52,950 --> 01:26:58,350
how to do this yet we have some ideas a

01:26:56,040 --> 01:26:59,940
few people have ideas they're not fully

01:26:58,350 --> 01:27:00,960
fleshed out we're not sure that they

01:26:59,940 --> 01:27:02,820
work we're not sure that they're

01:27:00,960 --> 01:27:05,940
implementable and so really the first

01:27:02,820 --> 01:27:08,400
step is to try and figure out how to do

01:27:05,940 --> 01:27:10,710
this what the cost would be and then

01:27:08,400 --> 01:27:13,200
hopefully if there is a way to do it at

01:27:10,710 --> 01:27:16,350
a cost that at least is reasonable if

01:27:13,200 --> 01:27:19,050
the entire user base of these processors

01:27:16,350 --> 01:27:20,220
lobby's very effectively I'm hopeful

01:27:19,050 --> 01:27:23,040
that the processor vendors will actually

01:27:20,220 --> 01:27:25,260
step up and and and provide a real

01:27:23,040 --> 01:27:27,810
solution long term but with that we

01:27:25,260 --> 01:27:28,740
should probably in the QA and hopefully

01:27:27,810 --> 01:27:32,060
you'll all come to the panel session

01:27:28,740 --> 01:27:32,060

YouTube URL: https://www.youtube.com/watch?v=_f7O3IfIR2k


