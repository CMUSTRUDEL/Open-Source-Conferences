Title: CppCon 2018: Jonathan Boccara “105 STL Algorithms in Less Than an Hour”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
We are all aware that we should know the STL algorithms. Including them in our designs allows us to make our code more expressive and more robust. And sometimes, in a spectacular way. 

But do you know your STL algorithms? 

In this presentation, you’ll see the 105 algorithms that the STL currently has, including those added in C++11 and C++17. But more than just a listing, the point of this presentation is to highlight the different groups of algorithms, the patterns they form in the STL, and how the algorithms relate together. And all this in an entertaining way. 

This kind of big picture is the best way I know to actually remember them all, and constitute a toolbox chock-full of ways to make our code more expressive and more robust.
— 

Jonathan Boccara, Murex

Jonathan Boccara is a Principal Engineering Lead at Murex where he works on large codebases in C++.
His primary focus is searching how to make code more expressive. He has dedicated his blog, Fluent C++, to writing expressive code in C++. 
He also gives internal trainings on C++ every day, in the short format called "Dailies".
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,440 --> 00:00:08,120
hi i'm jonathan wakaru I write on the

00:00:05,450 --> 00:00:10,700
blog through n C++ it's broke about

00:00:08,120 --> 00:00:13,730
expressive code in C++ with an article

00:00:10,700 --> 00:00:17,930
every Tuesday and Friday and I work at

00:00:13,730 --> 00:00:25,029
your ex I am sim lead of a C++ developer

00:00:17,930 --> 00:00:25,029
software so far I develop our team sorry

00:00:25,210 --> 00:00:38,600
it's not working oh it's okay let me put

00:00:30,289 --> 00:00:43,280
that up hi hi everyone here's me we're

00:00:38,600 --> 00:00:45,440
good okay right so I was Jonathan

00:00:43,280 --> 00:00:47,420
bukhara I was on fluency plus press

00:00:45,440 --> 00:00:49,760
writing twice a week about expressive

00:00:47,420 --> 00:00:53,480
code in C++ and I'm still working at

00:00:49,760 --> 00:00:56,030
near X as a team need of a C++ software

00:00:53,480 --> 00:01:00,920
developer team what we're going to talk

00:00:56,030 --> 00:01:02,899
about today is the stl algorithms we're

00:01:00,920 --> 00:01:06,470
going to start off this talk with a

00:01:02,899 --> 00:01:09,770
question to you who in this room is

00:01:06,470 --> 00:01:12,530
aware of the fact that it's a good thing

00:01:09,770 --> 00:01:13,730
to know the FDLR algorithms just raise

00:01:12,530 --> 00:01:15,770
your hand if you're aware of that

00:01:13,730 --> 00:01:19,990
aware of that fact pretty much every

00:01:15,770 --> 00:01:25,160
everyone hands rising that's pretty cool

00:01:19,990 --> 00:01:31,010
second question who knows them all raise

00:01:25,160 --> 00:01:33,140
your hand go on then that's pretty much

00:01:31,010 --> 00:01:35,060
that that's actually no one no one's

00:01:33,140 --> 00:01:38,270
hand rising now that's exactly the

00:01:35,060 --> 00:01:42,140
purpose of this talk when you walk out

00:01:38,270 --> 00:01:45,110
of that room you will know every single

00:01:42,140 --> 00:01:49,430
thing that's in the stl algorithms

00:01:45,110 --> 00:01:52,280
library to do that I suggest that we

00:01:49,430 --> 00:01:54,770
start with a brief chat about why it's

00:01:52,280 --> 00:01:58,100
important to know them and what to learn

00:01:54,770 --> 00:02:04,580
in them and then we dive in the sto that

00:01:58,100 --> 00:02:06,970
algorithms themselves alright so there's

00:02:04,580 --> 00:02:09,470
this thing that's been popularized

00:02:06,970 --> 00:02:10,190
across the C++ community over the past

00:02:09,470 --> 00:02:14,220
few years

00:02:10,190 --> 00:02:17,150
that's we we need to know all the SDR

00:02:14,220 --> 00:02:24,780
and we need to know them well very well

00:02:17,150 --> 00:02:28,770
but why what for one thing they can make

00:02:24,780 --> 00:02:32,010
our code more expressive and they do

00:02:28,770 --> 00:02:34,710
that by raising levels of abstraction

00:02:32,010 --> 00:02:38,130
which means that they allow to express

00:02:34,710 --> 00:02:40,500
what we want to do as opposed to how we

00:02:38,130 --> 00:02:43,650
want it executed and I think that

00:02:40,500 --> 00:02:45,510
raising the level of attraction is one

00:02:43,650 --> 00:02:50,870
of the most efficient way to roil

00:02:45,510 --> 00:02:55,500
expressive codes and it can be sometimes

00:02:50,870 --> 00:02:58,230
spectacular Lloyd if you've seen that

00:02:55,500 --> 00:03:00,540
talk couple of years back by Shawn

00:02:58,230 --> 00:03:05,100
parent which was called C++ seasoning

00:03:00,540 --> 00:03:08,340
and that talk Shawn took a chunk of code

00:03:05,100 --> 00:03:10,680
there was bit hard to understand and he

00:03:08,340 --> 00:03:14,850
refactored it into a more concise and

00:03:10,680 --> 00:03:18,840
expressive piece of code just by picking

00:03:14,850 --> 00:03:24,200
the right SEO algorithm that's not the

00:03:18,840 --> 00:03:26,820
only reason if we write ourselves our

00:03:24,200 --> 00:03:30,239
manipulations on collections then we

00:03:26,820 --> 00:03:32,940
have to have to write somehow the

00:03:30,239 --> 00:03:35,580
traversal of a collection you have to

00:03:32,940 --> 00:03:38,790
write a followed if we don't resort

00:03:35,580 --> 00:03:41,550
using STR algorithms and when we write

00:03:38,790 --> 00:03:44,850
for ifs there are things that can go

00:03:41,550 --> 00:03:48,870
wrong like for example we need to be

00:03:44,850 --> 00:03:51,480
sure that the traversal doesn't go past

00:03:48,870 --> 00:03:54,300
the ends like we have to run that mental

00:03:51,480 --> 00:03:56,130
check run the loop we now head to make

00:03:54,300 --> 00:03:59,280
sure when even then there's a risk and

00:03:56,130 --> 00:04:01,769
if we go past the end of a collection in

00:03:59,280 --> 00:04:05,100
C++ then we get into undefined behavior

00:04:01,769 --> 00:04:06,140
and from that point on anything can

00:04:05,100 --> 00:04:10,110
happen

00:04:06,140 --> 00:04:11,640
literally anything can happen and and

00:04:10,110 --> 00:04:13,530
that's a load by under standards was

00:04:11,640 --> 00:04:17,790
happening on the screen right now is

00:04:13,530 --> 00:04:20,580
absolutely legal C++ even though it's

00:04:17,790 --> 00:04:23,250
probably more likely that you get a

00:04:20,580 --> 00:04:25,530
crash than clown popping up next to you

00:04:23,250 --> 00:04:28,110
bots 2 or the clown is legal

00:04:25,530 --> 00:04:30,580
I just under

00:04:28,110 --> 00:04:32,680
another kind of mistake is dealing with

00:04:30,580 --> 00:04:35,199
the kind of with the case of an empty

00:04:32,680 --> 00:04:37,599
loop and and that's the same thing we

00:04:35,199 --> 00:04:40,479
have to run it in our head have a risk

00:04:37,599 --> 00:04:42,430
of it going wrong sometimes and then

00:04:40,479 --> 00:04:46,449
going to undefined behavior all over

00:04:42,430 --> 00:04:49,000
again with the SD algorithm this doesn't

00:04:46,449 --> 00:04:52,990
happen that's one more reason to use

00:04:49,000 --> 00:04:55,569
them another case of mistake we can make

00:04:52,990 --> 00:04:58,990
when writing our own for news is is

00:04:55,569 --> 00:05:02,370
about complexity like some algorithms

00:04:58,990 --> 00:05:05,080
that they can be implemented naively in

00:05:02,370 --> 00:05:09,430
quadratic complexity and in a more

00:05:05,080 --> 00:05:11,860
astute manner in a linear complexity we

00:05:09,430 --> 00:05:18,490
go back to an example later with

00:05:11,860 --> 00:05:21,810
algorithms on sets also STR rhythms are

00:05:18,490 --> 00:05:24,430
used by billions of people every day

00:05:21,810 --> 00:05:26,139
well maybe not billions of people every

00:05:24,430 --> 00:05:31,960
day but quite a lot of people fairly

00:05:26,139 --> 00:05:35,409
often one seriously there are parts of

00:05:31,960 --> 00:05:37,630
standard C++ which means that you should

00:05:35,409 --> 00:05:39,310
not be afraid to use them and think that

00:05:37,630 --> 00:05:41,080
maybe somebody's not going to be able to

00:05:39,310 --> 00:05:43,690
understand them because they don't know

00:05:41,080 --> 00:05:45,880
them I think we should level up to the

00:05:43,690 --> 00:05:49,150
EFD algorithms and not the other way

00:05:45,880 --> 00:05:51,520
around so this is the common this is

00:05:49,150 --> 00:05:54,969
part of the common vocabulary of C++

00:05:51,520 --> 00:06:01,270
just as much as int or if or whatever

00:05:54,969 --> 00:06:04,120
the language is and it's so so standard

00:06:01,270 --> 00:06:07,240
that even if you're running an older C++

00:06:04,120 --> 00:06:09,130
version you can still get most of the

00:06:07,240 --> 00:06:12,280
essay algorithms like for example if

00:06:09,130 --> 00:06:15,909
you're in C++ oh three for example and

00:06:12,280 --> 00:06:18,610
and you want to use like all over any

00:06:15,909 --> 00:06:21,520
open none of which appeared in C++ 11

00:06:18,610 --> 00:06:23,919
what you can just grab that code and

00:06:21,520 --> 00:06:26,590
copy it into your code bases just start

00:06:23,919 --> 00:06:28,930
using them so most of them are within

00:06:26,590 --> 00:06:34,930
your reach whichever version of super

00:06:28,930 --> 00:06:39,190
special right now right so now let's say

00:06:34,930 --> 00:06:40,740
that you want to go to the SD algorithms

00:06:39,190 --> 00:06:46,420
you want to take that part

00:06:40,740 --> 00:06:49,930
well there's a trap that's lying just at

00:06:46,420 --> 00:06:55,120
the beginning of that path and this is

00:06:49,930 --> 00:07:01,240
called for each for each is one of the

00:06:55,120 --> 00:07:02,350
SD algorithms it's it's nothing there's

00:07:01,240 --> 00:07:04,540
nothing wrong with it

00:07:02,350 --> 00:07:07,570
it has a use case I will see bit later

00:07:04,540 --> 00:07:10,480
but the trap that it represents is that

00:07:07,570 --> 00:07:12,760
it looks like a full roof right because

00:07:10,480 --> 00:07:15,160
it takes a beginning an end and some

00:07:12,760 --> 00:07:17,230
code that you can like it will execute

00:07:15,160 --> 00:07:19,090
an every element of the collection just

00:07:17,230 --> 00:07:21,130
like you for it so you might be tempted

00:07:19,090 --> 00:07:24,670
to think that you can replace all you

00:07:21,130 --> 00:07:26,410
for lips by forage and and that and that

00:07:24,670 --> 00:07:28,600
you'd be done I'll be using VSD

00:07:26,410 --> 00:07:32,560
algorithms and that's not quite the

00:07:28,600 --> 00:07:35,380
spirit because there's much more than

00:07:32,560 --> 00:07:37,600
for each in in VSD algorithms library

00:07:35,380 --> 00:07:40,030
there is much many more many more

00:07:37,600 --> 00:07:43,660
algorithms that let you express more new

00:07:40,030 --> 00:07:45,370
ends when you write your code I'm going

00:07:43,660 --> 00:07:47,590
to show you something to illustrate the

00:07:45,370 --> 00:07:51,810
fact that there's much more than forage

00:07:47,590 --> 00:07:51,810
in the STR rhythms library

00:07:58,220 --> 00:08:20,170
[Music]

00:08:22,330 --> 00:08:30,290
[Music]

00:08:32,409 --> 00:08:40,950
[Music]

00:08:45,730 --> 00:08:54,489
[Music]

00:08:58,240 --> 00:09:03,889
[Music]

00:09:04,490 --> 00:09:08,970
ladies and gentlemen I present you the

00:09:07,080 --> 00:09:14,360
world of the earth there are Gardens

00:09:08,970 --> 00:09:19,200
[Applause]

00:09:14,360 --> 00:09:23,850
on this map I've placed all the STR

00:09:19,200 --> 00:09:28,970
algorithms as of C++ 17 and I've grouped

00:09:23,850 --> 00:09:32,550
them by region according to the logical

00:09:28,970 --> 00:09:35,340
relationship they have right the rest of

00:09:32,550 --> 00:09:41,280
this talk will consist in exploring that

00:09:35,340 --> 00:09:43,830
world but before diving in we can note a

00:09:41,280 --> 00:09:46,890
few things while I'm looking at it from

00:09:43,830 --> 00:09:52,200
the farm the first thing we can note is

00:09:46,890 --> 00:09:54,750
that for each is just one of them on one

00:09:52,200 --> 00:09:57,890
island loston Rost on the on the middle

00:09:54,750 --> 00:10:01,770
of the ocean so it's just one of them

00:09:57,890 --> 00:10:04,860
what we can know also is where most of

00:10:01,770 --> 00:10:09,300
them are you can observe that the

00:10:04,860 --> 00:10:13,110
largest region on that world is over

00:10:09,300 --> 00:10:15,900
here and that's the lands of queries

00:10:13,110 --> 00:10:20,790
call that queries because all those

00:10:15,900 --> 00:10:23,490
algorithms are live here they just read

00:10:20,790 --> 00:10:25,170
into the collection and an extract some

00:10:23,490 --> 00:10:27,510
piece of information and they don't

00:10:25,170 --> 00:10:29,310
actually modify it I don't know what you

00:10:27,510 --> 00:10:31,230
think but I would have thought that most

00:10:29,310 --> 00:10:33,330
algorithm would somehow change the

00:10:31,230 --> 00:10:35,880
collection like sort of partition or

00:10:33,330 --> 00:10:40,250
whatever like are there as well but most

00:10:35,880 --> 00:10:44,190
of them to just read any operations I

00:10:40,250 --> 00:10:46,040
suggest that it stars our journey by the

00:10:44,190 --> 00:10:52,140
other end of the world from for each

00:10:46,040 --> 00:10:56,400
down here on the algorithms on heat so

00:10:52,140 --> 00:11:00,090
what is a heap to begin with a heap is a

00:10:56,400 --> 00:11:03,210
data structure that looks like a tree

00:11:00,090 --> 00:11:08,300
but that has a property it's that every

00:11:03,210 --> 00:11:11,130
node must be smaller than its children I

00:11:08,300 --> 00:11:13,170
think it's called that because it kind

00:11:11,130 --> 00:11:15,960
of like looks like a heap in real life

00:11:13,170 --> 00:11:18,300
like the small ones are at the top

00:11:15,960 --> 00:11:22,800
and the bigger one has at the bottom we

00:11:18,300 --> 00:11:25,380
it's better having a heap now you can

00:11:22,800 --> 00:11:28,200
observe that the heap on the rice of a

00:11:25,380 --> 00:11:30,150
picture is the other way around right

00:11:28,200 --> 00:11:32,250
the biggest element is at the top and

00:11:30,150 --> 00:11:32,850
every element is bigger than its

00:11:32,250 --> 00:11:35,460
children

00:11:32,850 --> 00:11:39,660
that's the C++ heap it's called a max

00:11:35,460 --> 00:11:42,150
heap the relationship between the parent

00:11:39,660 --> 00:11:45,090
and his children is the parent is bigger

00:11:42,150 --> 00:11:49,110
right so it's it's the other one from

00:11:45,090 --> 00:11:51,960
the heap from real life but you know we

00:11:49,110 --> 00:11:54,510
develop I don't really live in real life

00:11:51,960 --> 00:11:56,360
anyway so that's it really Mossad I

00:11:54,510 --> 00:12:00,720
think so

00:11:56,360 --> 00:12:04,380
so one interesting property of a heap is

00:12:00,720 --> 00:12:08,970
is that we can squash it down into a

00:12:04,380 --> 00:12:12,120
range like that one more time more

00:12:08,970 --> 00:12:14,700
slowly to squash down the heap into a

00:12:12,120 --> 00:12:17,070
range we take the first row which is

00:12:14,700 --> 00:12:20,100
just a root of the tree and then the

00:12:17,070 --> 00:12:22,710
second row and then the third row and so

00:12:20,100 --> 00:12:26,730
on and so forth and when we do this

00:12:22,710 --> 00:12:29,010
there's this nice property that it's

00:12:26,730 --> 00:12:31,050
arranged so we can represent it with a

00:12:29,010 --> 00:12:35,220
vector for example which is quite

00:12:31,050 --> 00:12:39,750
convenient to work with and also to go

00:12:35,220 --> 00:12:42,240
from a node to its left child it's

00:12:39,750 --> 00:12:45,570
essentially taking its index and

00:12:42,240 --> 00:12:47,670
multiplying it by toes nearly that so

00:12:45,570 --> 00:12:50,310
it's it's a it's a way to represent a

00:12:47,670 --> 00:12:51,720
tree into a range if we have a range we

00:12:50,310 --> 00:12:55,260
have a beginning and then and we can use

00:12:51,720 --> 00:12:59,340
FDR algorithms so the first thing we can

00:12:55,260 --> 00:13:02,130
do is taking values that are not

00:12:59,340 --> 00:13:03,860
particularly a heap and rearrange them

00:13:02,130 --> 00:13:07,470
so that they respect the heap property

00:13:03,860 --> 00:13:09,390
to make a heap to make a heap we use

00:13:07,470 --> 00:13:11,820
stood make heap with the beginning and

00:13:09,390 --> 00:13:14,010
then and that rearranges the element

00:13:11,820 --> 00:13:16,650
inside of a collection that's our first

00:13:14,010 --> 00:13:21,810
algorithm of the day that's one down

00:13:16,650 --> 00:13:26,630
104 to go I forgot to mention it's 105

00:13:21,810 --> 00:13:26,630
STR algorithms in less than an hour each

00:13:27,430 --> 00:13:32,420
just making sure we've got the same

00:13:29,720 --> 00:13:34,790
understanding here right now enjoy again

00:13:32,420 --> 00:13:39,110
there all right well either way you'll

00:13:34,790 --> 00:13:41,830
find out let's move on what we can do

00:13:39,110 --> 00:13:43,940
with a heap is add something to it

00:13:41,830 --> 00:13:45,770
independently from C++ to add some

00:13:43,940 --> 00:13:48,290
things to heap we put the new thing

00:13:45,770 --> 00:13:51,230
right at the end and it might not be its

00:13:48,290 --> 00:13:56,540
right position because it may be smaller

00:13:51,230 --> 00:13:59,240
than its father and the way to add it to

00:13:56,540 --> 00:14:01,490
the heap is to swap it with its parent

00:13:59,240 --> 00:14:04,910
until it reaches its final position

00:14:01,490 --> 00:14:08,029
all right now to do that in C++ we can

00:14:04,910 --> 00:14:10,040
squash down the heap right to represent

00:14:08,029 --> 00:14:13,190
it as a range say that its effects are

00:14:10,040 --> 00:14:14,750
we add something to the end and then we

00:14:13,190 --> 00:14:17,240
need to do some we need something to

00:14:14,750 --> 00:14:17,750
make it bubble it's way up to its final

00:14:17,240 --> 00:14:24,709
position

00:14:17,750 --> 00:14:27,260
and that's push it now for shape just

00:14:24,709 --> 00:14:30,589
does the same thing we've seen with the

00:14:27,260 --> 00:14:33,680
tree vision but in range vision now to

00:14:30,589 --> 00:14:37,010
remove something from a heap or there's

00:14:33,680 --> 00:14:39,740
this thing with heap why do we use heaps

00:14:37,010 --> 00:14:41,829
in the first place is to be able to get

00:14:39,740 --> 00:14:45,200
the maximum value of the collection in

00:14:41,829 --> 00:14:48,890
in not too much time and constants on

00:14:45,200 --> 00:14:51,230
time like the heap the max element of

00:14:48,890 --> 00:14:53,060
the collection is just a font so this is

00:14:51,230 --> 00:14:57,529
what we access and this is also what we

00:14:53,060 --> 00:15:01,100
allowed to remove to do that we swap it

00:14:57,529 --> 00:15:04,880
with the last one that's what pop heap

00:15:01,100 --> 00:15:07,100
does at this point the the the range in

00:15:04,880 --> 00:15:08,450
yellow is probably not a heap because

00:15:07,100 --> 00:15:10,370
that's the one at the end that was

00:15:08,450 --> 00:15:14,329
probably this one of the smallest ones

00:15:10,370 --> 00:15:16,070
that that was at the beginning so we

00:15:14,329 --> 00:15:16,880
need to make it bubble it's way down to

00:15:16,070 --> 00:15:19,430
its final position

00:15:16,880 --> 00:15:22,910
that's what pop hip does and if we want

00:15:19,430 --> 00:15:25,370
to remove to actually remove that value

00:15:22,910 --> 00:15:27,500
we pop it back from the rec time now if

00:15:25,370 --> 00:15:31,750
we don't pop you back from the vector

00:15:27,500 --> 00:15:35,900
but leave it here and and do that again

00:15:31,750 --> 00:15:38,720
for the part in yellow that the

00:15:35,900 --> 00:15:39,290
shrinking heap if we do that over and

00:15:38,720 --> 00:15:44,270
over

00:15:39,290 --> 00:15:48,320
at the end we'll get can can someone see

00:15:44,270 --> 00:15:51,050
what we'll get at the end yeah right a

00:15:48,320 --> 00:15:55,430
sorted collection so that's a way to

00:15:51,050 --> 00:15:59,380
sort a collection and that's what sort

00:15:55,430 --> 00:16:03,980
heap Stood Still thought heap dots

00:15:59,380 --> 00:16:06,250
talking about sorting this is the region

00:16:03,980 --> 00:16:10,130
around the corner the short of sorting

00:16:06,250 --> 00:16:12,740
so let's see how to source with the STL

00:16:10,130 --> 00:16:14,570
well the simplest way probably is stood

00:16:12,740 --> 00:16:17,090
sorts that takes a collection they can

00:16:14,570 --> 00:16:21,440
end and rearranges them so that they're

00:16:17,090 --> 00:16:24,230
in sorted order okay now if we only want

00:16:21,440 --> 00:16:28,510
to sort the beginning of a collection as

00:16:24,230 --> 00:16:31,610
we sew in we saw in depth in fretts dog

00:16:28,510 --> 00:16:33,020
we can just partial sort the things a

00:16:31,610 --> 00:16:34,640
partial sort takes the beginning and

00:16:33,020 --> 00:16:37,460
then and sort of like a middle something

00:16:34,640 --> 00:16:40,160
inside of the collection and sorts the

00:16:37,460 --> 00:16:42,950
connection from the beginning to that

00:16:40,160 --> 00:16:45,950
point and the rest is in unspecified

00:16:42,950 --> 00:16:47,270
order right so they're the left-hand

00:16:45,950 --> 00:16:51,650
side of the collection is what would be

00:16:47,270 --> 00:16:54,920
that if it was completely sorted now to

00:16:51,650 --> 00:16:58,010
sort just one element that's enth

00:16:54,920 --> 00:16:59,600
elements which takes a begin and end and

00:16:58,010 --> 00:17:01,490
something inside of the collection and

00:16:59,600 --> 00:17:03,350
puts at that position inside of the

00:17:01,490 --> 00:17:07,000
collection the element that would be

00:17:03,350 --> 00:17:11,089
there if the whole thing was sorted and

00:17:07,000 --> 00:17:13,490
and for the rest everything that's on

00:17:11,089 --> 00:17:17,050
the left is smaller and everything

00:17:13,490 --> 00:17:17,050
that's on the right is not smaller

00:17:17,620 --> 00:17:23,480
there's saw heap which we've mentioned

00:17:20,540 --> 00:17:27,709
with repeatedly coding pop eep and

00:17:23,480 --> 00:17:32,210
there's in place March in place March is

00:17:27,709 --> 00:17:34,670
the incremental step in a merge sort so

00:17:32,210 --> 00:17:39,940
we've got a collection that we can

00:17:34,670 --> 00:17:43,190
mentally think of as two two halves and

00:17:39,940 --> 00:17:45,310
merge swords so the to map the two

00:17:43,190 --> 00:17:48,320
halves are sorted and March thoughts

00:17:45,310 --> 00:17:50,510
combines the whole thing into into a

00:17:48,320 --> 00:17:52,380
sorted collection so that's about

00:17:50,510 --> 00:17:55,360
sorting with the SDR

00:17:52,380 --> 00:17:58,080
just further the show

00:17:55,360 --> 00:18:01,540
there's the region of party partitioning

00:17:58,080 --> 00:18:04,000
so what's what's partitioning in the

00:18:01,540 --> 00:18:07,690
first place to partition a collection is

00:18:04,000 --> 00:18:10,600
to look at it through a predicate

00:18:07,690 --> 00:18:13,480
something that returns a boolean hey our

00:18:10,600 --> 00:18:15,910
predicate is being blue to partition a

00:18:13,480 --> 00:18:18,730
collection is putting all the blue ones

00:18:15,910 --> 00:18:21,280
at the beginning and although not blue

00:18:18,730 --> 00:18:24,250
ones on the end of course it works poor

00:18:21,280 --> 00:18:31,090
blue and red and yellow and actually

00:18:24,250 --> 00:18:33,790
every any predicate there is the the

00:18:31,090 --> 00:18:35,650
border between the blue ones and the not

00:18:33,790 --> 00:18:39,190
blue ones is called the partition point

00:18:35,650 --> 00:18:41,740
that's the end of the blue range and

00:18:39,190 --> 00:18:46,150
that's also the begin of the not blue

00:18:41,740 --> 00:18:48,070
wrench can you see that okay that's

00:18:46,150 --> 00:18:50,440
called partition point and to retrieve

00:18:48,070 --> 00:18:55,390
it from a partition collection they

00:18:50,440 --> 00:18:58,210
stood partition point right if we take a

00:18:55,390 --> 00:19:00,700
step back on that part of the world that

00:18:58,210 --> 00:19:03,520
was the land of permutation that place

00:19:00,700 --> 00:19:06,130
where elements move around the

00:19:03,520 --> 00:19:11,440
collection even if they don't change

00:19:06,130 --> 00:19:14,170
value within heaps salt partition and

00:19:11,440 --> 00:19:16,380
there are a few others that we'll go

00:19:14,170 --> 00:19:20,380
through quickly

00:19:16,380 --> 00:19:23,500
there's the this permutation that takes

00:19:20,380 --> 00:19:25,900
the element at the end and put it at the

00:19:23,500 --> 00:19:26,640
bottom put them at about the beginning

00:19:25,900 --> 00:19:31,750
sorry

00:19:26,640 --> 00:19:33,100
that's rotate another way to change the

00:19:31,750 --> 00:19:36,670
order of the element of the collection

00:19:33,100 --> 00:19:39,490
is to do that randomly that's word stood

00:19:36,670 --> 00:19:41,710
shuffled ours so stew truffle takes a

00:19:39,490 --> 00:19:44,530
collection with elements in a certain

00:19:41,710 --> 00:19:47,620
order and takes something that generates

00:19:44,530 --> 00:19:52,450
random numbers and rearranges the

00:19:47,620 --> 00:19:55,470
collection in random order there is an

00:19:52,450 --> 00:19:58,750
order we can define on permutations

00:19:55,470 --> 00:20:01,450
given us given a set of objects even a

00:19:58,750 --> 00:20:03,490
collection of object we can order them

00:20:01,450 --> 00:20:04,460
order all they have possible

00:20:03,490 --> 00:20:06,950
arrangements

00:20:04,460 --> 00:20:09,980
and an intuitive way to see that is

00:20:06,950 --> 00:20:13,519
thinking about an alphabetical order

00:20:09,980 --> 00:20:16,279
right so in this collection 1 2 3 all

00:20:13,519 --> 00:20:19,399
the way to 9 the smallest one if those

00:20:16,279 --> 00:20:22,519
we're in a dictionary would be first 1 1

00:20:19,399 --> 00:20:24,499
all the way to 9 and the one just after

00:20:22,519 --> 00:20:27,230
would be the same thing with a nine and

00:20:24,499 --> 00:20:29,419
an eight swoop together right and and so

00:20:27,230 --> 00:20:33,259
on and the largest one with the one at

00:20:29,419 --> 00:20:37,490
the bottom here from nine down to one

00:20:33,259 --> 00:20:40,340
right if you have a collection in a

00:20:37,490 --> 00:20:42,889
given order any order between the

00:20:40,340 --> 00:20:45,080
smallest and the biggest one next

00:20:42,889 --> 00:20:48,110
permutation which takes beginning then

00:20:45,080 --> 00:20:50,539
would rearrange it so that it goes to

00:20:48,110 --> 00:20:53,360
the older that's just after it and

00:20:50,539 --> 00:20:56,059
preffer mutation to the order that's

00:20:53,360 --> 00:20:57,919
just before it that's interesting if

00:20:56,059 --> 00:21:00,980
you'd like to do something for every

00:20:57,919 --> 00:21:03,230
possible arrangement of a collection you

00:21:00,980 --> 00:21:04,700
can repeatedly call next permutation

00:21:03,230 --> 00:21:08,330
until you've recycled back to the

00:21:04,700 --> 00:21:12,799
beginning and finally the last one is

00:21:08,330 --> 00:21:16,309
reverse that reverse is the element

00:21:12,799 --> 00:21:19,190
collection right so we've been all

00:21:16,309 --> 00:21:22,730
around the lands of permutation just in

00:21:19,190 --> 00:21:27,590
the corner of the map here are the

00:21:22,730 --> 00:21:30,019
secret rooms the secret rooms are things

00:21:27,590 --> 00:21:33,230
that you can combine with other

00:21:30,019 --> 00:21:37,369
algorithms to generate new algorithms

00:21:33,230 --> 00:21:39,379
I call them runes because it's like it's

00:21:37,369 --> 00:21:42,740
like going to see runes to augment your

00:21:39,379 --> 00:21:45,919
powers and also because I find that kind

00:21:42,740 --> 00:21:50,230
of cool as a name so let's let's call

00:21:45,919 --> 00:21:50,230
them that purpose of this presentation

00:21:50,529 --> 00:21:57,499
we've we've seen all the algorithm that

00:21:54,799 --> 00:22:00,259
go with the stable brain so stable when

00:21:57,499 --> 00:22:03,080
you tack it on to an algorithm it does

00:22:00,259 --> 00:22:06,049
what this algorithm does but keep the

00:22:03,080 --> 00:22:07,909
relative order think about partition for

00:22:06,049 --> 00:22:10,369
example it put all the blue ones at the

00:22:07,909 --> 00:22:12,440
beginning that's for sure but maybe in

00:22:10,369 --> 00:22:14,869
the process some of them got swapped

00:22:12,440 --> 00:22:16,460
around with stable partition they all

00:22:14,869 --> 00:22:20,690
keep the same relative

00:22:16,460 --> 00:22:23,029
same thing the stable saw the is rain

00:22:20,690 --> 00:22:25,940
checks for a predicate on the collection

00:22:23,029 --> 00:22:29,690
we know what sort partition he means or

00:22:25,940 --> 00:22:32,539
assorted each partition is heap returns

00:22:29,690 --> 00:22:36,379
a boolean to say to indicate whether

00:22:32,539 --> 00:22:40,190
it's a sorter the partition or heap that

00:22:36,379 --> 00:22:44,600
way looking at and is until returns an

00:22:40,190 --> 00:22:48,409
iterator that's the first position where

00:22:44,600 --> 00:22:50,629
that predicate doesn't hold anyone right

00:22:48,409 --> 00:22:52,460
so for example if we have a sorted

00:22:50,629 --> 00:22:55,070
collection and then we call is sorted

00:22:52,460 --> 00:23:00,320
until we'll get the end of that

00:22:55,070 --> 00:23:03,740
collection all right let's take a step

00:23:00,320 --> 00:23:06,679
back so we've been down there in the

00:23:03,740 --> 00:23:11,360
lands of permutation let's now focus on

00:23:06,679 --> 00:23:14,539
the largest part of the world the lands

00:23:11,360 --> 00:23:16,999
of queries now quite a few of them in

00:23:14,539 --> 00:23:23,330
there but we'll go through them quite

00:23:16,999 --> 00:23:27,730
quickly so one thing you can extract out

00:23:23,330 --> 00:23:30,409
of a collection is some sort of value

00:23:27,730 --> 00:23:33,470
for example the simplest one is probably

00:23:30,409 --> 00:23:35,840
count that takes beginning and then and

00:23:33,470 --> 00:23:38,840
value and returns how many times this

00:23:35,840 --> 00:23:41,809
value occurs in the collection there's

00:23:38,840 --> 00:23:43,059
accumulate that makes the sum of the

00:23:41,809 --> 00:23:46,820
element of the collection calling

00:23:43,059 --> 00:23:51,080
operator plus or any custom function

00:23:46,820 --> 00:23:54,470
you'd pass it in C++ 17 there's reduce

00:23:51,080 --> 00:23:56,779
that appeared that there's practically

00:23:54,470 --> 00:23:58,340
the same thing as accumulate except it

00:23:56,779 --> 00:24:01,159
has a slightly different interface if

00:23:58,340 --> 00:24:04,730
you can accept to take no initial value

00:24:01,159 --> 00:24:06,019
and it's it can also be run in peril but

00:24:04,730 --> 00:24:09,799
essentially is the same as accumulate

00:24:06,019 --> 00:24:12,769
and transform reduce takes a function

00:24:09,799 --> 00:24:14,240
and applies that function to the element

00:24:12,769 --> 00:24:20,749
of the collection before occurring

00:24:14,240 --> 00:24:23,419
accordingly reduce partial sum well it

00:24:20,749 --> 00:24:25,879
sounds the all the elements starting

00:24:23,419 --> 00:24:28,039
from the beginning to the current point

00:24:25,879 --> 00:24:28,800
of the collection so here partial Sun

00:24:28,039 --> 00:24:31,860
will read

00:24:28,800 --> 00:24:34,140
a collection with in the first position

00:24:31,860 --> 00:24:36,060
the what was in the first position of

00:24:34,140 --> 00:24:38,130
the original collection and in the

00:24:36,060 --> 00:24:40,140
second one would be the first one plus

00:24:38,130 --> 00:24:42,060
the second one and the third one will be

00:24:40,140 --> 00:24:47,310
the first pass the second plus the third

00:24:42,060 --> 00:24:50,370
so on and so forth interpret in C++ 17

00:24:47,310 --> 00:24:52,110
there is inclusive scan exclusive scan

00:24:50,370 --> 00:24:55,200
transform inclusive scan transform

00:24:52,110 --> 00:24:58,860
exclusive scan shall have interesting

00:24:55,200 --> 00:25:01,140
names let's say well inclusive scan is

00:24:58,860 --> 00:25:03,480
the same thing is the same thing as

00:25:01,140 --> 00:25:07,320
partial sum except it can be run into

00:25:03,480 --> 00:25:09,330
how parallel exclusive scan is the same

00:25:07,320 --> 00:25:12,780
thing as inclusive scan except it

00:25:09,330 --> 00:25:15,000
doesn't include the current element so

00:25:12,780 --> 00:25:18,000
for example with the exclusive scan the

00:25:15,000 --> 00:25:19,770
second element would be equal to the

00:25:18,000 --> 00:25:22,020
first element of the photo of the

00:25:19,770 --> 00:25:24,570
original collection the third one would

00:25:22,020 --> 00:25:27,630
be one plus two the fourth one would be

00:25:24,570 --> 00:25:31,470
1 plus 2 / 3 and so on and so forth and

00:25:27,630 --> 00:25:34,020
the transform versions of those two guys

00:25:31,470 --> 00:25:36,150
take a function apply to the collection

00:25:34,020 --> 00:25:40,170
and then perform the including stash

00:25:36,150 --> 00:25:42,770
exclusive scan in a product makes the

00:25:40,170 --> 00:25:45,650
inner product a collection which is

00:25:42,770 --> 00:25:48,450
multiplication of the counter pal

00:25:45,650 --> 00:25:52,100
counterparts elements and then summing

00:25:48,450 --> 00:25:55,310
that whole thing adjacent difference

00:25:52,100 --> 00:25:57,330
makes the difference between every two

00:25:55,310 --> 00:26:02,220
neighbors in the collection

00:25:57,330 --> 00:26:04,650
and sample appeared in pairing in C++ 17

00:26:02,220 --> 00:26:08,130
take something that can return some I

00:26:04,650 --> 00:26:14,300
can generate random numbers and it takes

00:26:08,130 --> 00:26:17,310
a number say n and it produces n

00:26:14,300 --> 00:26:24,540
elements of that collection selected

00:26:17,310 --> 00:26:28,800
randomly apart from query value we can

00:26:24,540 --> 00:26:31,740
query a property well there's all of any

00:26:28,800 --> 00:26:34,740
other none of which are really useful in

00:26:31,740 --> 00:26:36,870
everyday code all of Tech's collection

00:26:34,740 --> 00:26:38,730
and predicate returns if all of the

00:26:36,870 --> 00:26:41,220
elements satisfy the predicate any of if

00:26:38,730 --> 00:26:42,330
at least one element satisfy the

00:26:41,220 --> 00:26:45,050
predicate and non

00:26:42,330 --> 00:26:49,970
if no element satisfy our pretty good

00:26:45,050 --> 00:26:54,240
now what do you think all of return

00:26:49,970 --> 00:27:00,180
returns with an empty collection what do

00:26:54,240 --> 00:27:07,320
you think right true does everyone

00:27:00,180 --> 00:27:09,080
everyone agrees with Fred yeah that's

00:27:07,320 --> 00:27:15,710
true

00:27:09,080 --> 00:27:23,100
any of an empty collection yeah false

00:27:15,710 --> 00:27:27,420
no no come on there's only two possible

00:27:23,100 --> 00:27:30,630
answer answers yeah true

00:27:27,420 --> 00:27:32,340
absolutely that was squaring a property

00:27:30,630 --> 00:27:33,960
of one range we can also query a

00:27:32,340 --> 00:27:36,120
property on two ranges which is

00:27:33,960 --> 00:27:39,120
essentially different ways of comparing

00:27:36,120 --> 00:27:41,490
them the simplest words compared to

00:27:39,120 --> 00:27:44,010
ranges is to see if they have the exact

00:27:41,490 --> 00:27:46,200
same contents so the element would be

00:27:44,010 --> 00:27:48,150
equal to by two and it will have the

00:27:46,200 --> 00:27:51,870
same size and that's what stood equal

00:27:48,150 --> 00:27:54,240
returns returns a boolean now if we'd

00:27:51,870 --> 00:27:57,030
like to know if the two collections

00:27:54,240 --> 00:27:59,760
contain the same elements but not

00:27:57,030 --> 00:28:02,930
necessarily in the same order that's is

00:27:59,760 --> 00:28:07,020
fermentation also returning a boolean

00:28:02,930 --> 00:28:10,380
now we can also compare ranges and and

00:28:07,020 --> 00:28:13,620
say which one is smaller than the other

00:28:10,380 --> 00:28:17,460
one to define smaller we could go with

00:28:13,620 --> 00:28:20,100
size that's not very precise that's

00:28:17,460 --> 00:28:22,730
another way to do that is going back to

00:28:20,100 --> 00:28:25,830
the alphabetical lexicographical

00:28:22,730 --> 00:28:28,400
ordering right like in this example I've

00:28:25,830 --> 00:28:31,770
used characters but that that can be

00:28:28,400 --> 00:28:34,290
with any type that has a comparison

00:28:31,770 --> 00:28:41,220
operator you can see on this example

00:28:34,290 --> 00:28:44,070
that the left collection is smaller than

00:28:41,220 --> 00:28:46,970
the second one on the right one if it

00:28:44,070 --> 00:28:49,710
was in if they were in a in a dictionary

00:28:46,970 --> 00:28:53,340
right even though it's it's longer in

00:28:49,710 --> 00:28:55,389
terms of size it would come before in a

00:28:53,340 --> 00:28:58,539
dictionary and that's what Lex

00:28:55,389 --> 00:29:02,739
a graphical compare returns in the form

00:28:58,539 --> 00:29:07,869
of a boolean now the last way to compare

00:29:02,739 --> 00:29:12,629
to collection is to traverse them both

00:29:07,869 --> 00:29:17,829
and stop whenever they start to defer

00:29:12,629 --> 00:29:20,349
the differ mm and miss that's what miss

00:29:17,829 --> 00:29:25,029
much has stood miss much and it returns

00:29:20,349 --> 00:29:26,559
a pair of iterators pointing to the the

00:29:25,029 --> 00:29:32,489
respective position where they start to

00:29:26,559 --> 00:29:35,169
differ in the two collections now a

00:29:32,489 --> 00:29:37,629
classical classic a classic thing to

00:29:35,169 --> 00:29:41,229
extract in the neglection is a position

00:29:37,629 --> 00:29:42,549
like looking for something or to look

00:29:41,229 --> 00:29:45,070
for something in a collection are

00:29:42,549 --> 00:29:46,929
essentially two ways to do that it

00:29:45,070 --> 00:29:51,009
depends on whether the collection is

00:29:46,929 --> 00:29:54,429
sorted or not sorted if it's sorted we

00:29:51,009 --> 00:29:55,659
can use binary search it's not saw to

00:29:54,429 --> 00:29:58,450
have to go all the way through from

00:29:55,659 --> 00:30:00,969
beginning let's start with a not sorted

00:29:58,450 --> 00:30:03,669
case because it has the least number

00:30:00,969 --> 00:30:06,820
the lower number of algorithms well the

00:30:03,669 --> 00:30:08,859
simplest one and very famous one is fine

00:30:06,820 --> 00:30:11,499
good fine takes a value takes sorry a

00:30:08,859 --> 00:30:14,739
beginning and end and value and returns

00:30:11,499 --> 00:30:19,959
the iterator we're pointing to that

00:30:14,739 --> 00:30:25,209
value now or end if that value is not

00:30:19,959 --> 00:30:27,519
it's not found now it has a sort of like

00:30:25,209 --> 00:30:30,070
twin brother that's much less famous but

00:30:27,519 --> 00:30:33,940
why do you spell as well and it's called

00:30:30,070 --> 00:30:39,909
a Jason point and that returns the first

00:30:33,940 --> 00:30:43,059
position where two adjacent value occur

00:30:39,909 --> 00:30:44,859
and are equal to the value search so

00:30:43,059 --> 00:30:47,589
jason firing takes beginning and end and

00:30:44,859 --> 00:30:50,529
add value and returns the first position

00:30:47,589 --> 00:30:54,940
where two of those values appear in a

00:30:50,529 --> 00:30:58,169
row on the sources side we are not

00:30:54,940 --> 00:31:00,759
really looking for a value because

00:30:58,169 --> 00:31:03,609
searching for a given value could could

00:31:00,759 --> 00:31:05,559
it could be at several places and since

00:31:03,609 --> 00:31:08,049
it's sorted there would be lumped

00:31:05,559 --> 00:31:09,260
together right so in this example if

00:31:08,049 --> 00:31:11,659
we're searching for all

00:31:09,260 --> 00:31:13,460
we're actually looking for a sub range

00:31:11,659 --> 00:31:15,559
that could be MC for orange it's not

00:31:13,460 --> 00:31:17,480
there at all and that's what equal range

00:31:15,559 --> 00:31:21,710
returns its search in a sorted

00:31:17,480 --> 00:31:25,039
collection we use equal range now other

00:31:21,710 --> 00:31:27,110
algorithms that sort of like look like a

00:31:25,039 --> 00:31:30,309
lower bound and upper bound and they

00:31:27,110 --> 00:31:33,649
only indicate positions to insert

00:31:30,309 --> 00:31:36,080
elements or if I were to insert a new

00:31:33,649 --> 00:31:38,120
orange at the left of the existing

00:31:36,080 --> 00:31:39,710
orange I would use lower bound and on

00:31:38,120 --> 00:31:43,130
the right of the existing orange I would

00:31:39,710 --> 00:31:45,289
use up about and there's this guy a

00:31:43,130 --> 00:31:48,769
binary search that returns a boolean

00:31:45,289 --> 00:31:50,389
which is a bit unexpected because he

00:31:48,769 --> 00:31:52,809
takes beginning then and the value and

00:31:50,389 --> 00:31:55,960
only tells you whether it's there or not

00:31:52,809 --> 00:31:58,639
but doesn't tell you where it found it

00:31:55,960 --> 00:32:04,639
and it uses a binary search which is

00:31:58,639 --> 00:32:06,919
there which is a good thing now we've

00:32:04,639 --> 00:32:08,750
been looking for one value in a

00:32:06,919 --> 00:32:11,769
collection like orange we can also look

00:32:08,750 --> 00:32:14,840
for a range of value in a collection

00:32:11,769 --> 00:32:18,139
like looking for the first occurrence of

00:32:14,840 --> 00:32:20,000
the sub range in a big range like like

00:32:18,139 --> 00:32:23,330
looking for that range on the left in

00:32:20,000 --> 00:32:26,230
the big range to do that there's an

00:32:23,330 --> 00:32:30,980
algorithm that has a very bizarre name

00:32:26,230 --> 00:32:33,740
because it's called search I don't know

00:32:30,980 --> 00:32:37,940
what you think but for me search is

00:32:33,740 --> 00:32:39,710
almost the same as find except fine safe

00:32:37,940 --> 00:32:42,169
that it will find it right and search

00:32:39,710 --> 00:32:44,510
says it will try to find it but such has

00:32:42,169 --> 00:32:48,049
nothing to do with fine it searches a

00:32:44,510 --> 00:32:51,980
sub range into a range that's not the

00:32:48,049 --> 00:32:55,120
best name the best I think the most

00:32:51,980 --> 00:32:58,669
curious name the whole STL armory is

00:32:55,120 --> 00:33:00,909
what follows which is looking for a sub

00:32:58,669 --> 00:33:05,260
range but starting from the end

00:33:00,909 --> 00:33:05,260
it's called point end

00:33:07,890 --> 00:33:17,110
that's good to know isn't it and what we

00:33:13,270 --> 00:33:20,529
can search in a sub range is any of any

00:33:17,110 --> 00:33:22,059
of the value in the lethal range finding

00:33:20,529 --> 00:33:26,020
its first occurrence in the big range

00:33:22,059 --> 00:33:27,940
and that's fine first of and finally we

00:33:26,020 --> 00:33:31,350
can search for a relative value which is

00:33:27,940 --> 00:33:34,570
the largest 100 or the smallest one

00:33:31,350 --> 00:33:35,260
that's Mac cinnamons or main element or

00:33:34,570 --> 00:33:38,020
both

00:33:35,260 --> 00:33:41,020
I mean Mac cinnamon that returns a pair

00:33:38,020 --> 00:33:44,429
of iterators pointing to the max and the

00:33:41,020 --> 00:33:48,370
min sorry that min and the max amounts

00:33:44,429 --> 00:33:51,669
Freud we've been around the largest part

00:33:48,370 --> 00:33:54,340
of the world now we're going to move in

00:33:51,669 --> 00:33:56,220
my favorite place it's the glorious

00:33:54,340 --> 00:34:01,510
County of the algorithms and sets

00:33:56,220 --> 00:34:04,570
because they're glorious well what's a

00:34:01,510 --> 00:34:08,109
set to begin with it includes stood set

00:34:04,570 --> 00:34:11,619
but not not only in C++ what we call a

00:34:08,109 --> 00:34:13,960
set is any sorted collection so still

00:34:11,619 --> 00:34:16,119
set is sorted and is a set but a sorted

00:34:13,960 --> 00:34:19,649
vector for the purpose of the sto

00:34:16,119 --> 00:34:22,720
algorithms is also considered as a set

00:34:19,649 --> 00:34:28,929
set difference which is my favorite

00:34:22,720 --> 00:34:30,700
algorithm takes two sets and returns the

00:34:28,929 --> 00:34:34,119
elements that are in the first one but

00:34:30,700 --> 00:34:36,520
not in the second one and it's in phases

00:34:34,119 --> 00:34:37,929
like that it produces is output by out

00:34:36,520 --> 00:34:41,349
an output writer

00:34:37,929 --> 00:34:44,169
I like it so much because it's useful

00:34:41,349 --> 00:34:48,159
all the time and it's also in linear

00:34:44,169 --> 00:34:50,290
complexity and it would be easy to

00:34:48,159 --> 00:34:52,149
implement in quadratic complexity but

00:34:50,290 --> 00:34:55,000
it's an inner complexity because it uses

00:34:52,149 --> 00:34:59,589
the fact that the input that sorted and

00:34:55,000 --> 00:35:02,830
also its output is sorted set difference

00:34:59,589 --> 00:35:05,260
half-siblings set intersection that

00:35:02,830 --> 00:35:08,410
returns cinnamon they are both in a and

00:35:05,260 --> 00:35:12,849
B set Union that returns element that

00:35:08,410 --> 00:35:15,550
are in a or in B so everyone set

00:35:12,849 --> 00:35:16,359
symmetric difference which is I think

00:35:15,550 --> 00:35:17,769
the longer

00:35:16,359 --> 00:35:22,299
name yeah it's the longest name in the

00:35:17,769 --> 00:35:24,430
whole area fun fact that returns the

00:35:22,299 --> 00:35:29,859
elements are in a and not in B and those

00:35:24,430 --> 00:35:32,890
that are in B and not in a includes that

00:35:29,859 --> 00:35:37,140
returns a boolean that indicates whether

00:35:32,890 --> 00:35:40,239
all the elements of B are also in a and

00:35:37,140 --> 00:35:42,579
merge that takes two sorts of the

00:35:40,239 --> 00:35:45,839
collection and puts them together into

00:35:42,579 --> 00:35:52,180
one big sorted collection oh that's it

00:35:45,839 --> 00:35:56,170
was that - sure okay let's take a step

00:35:52,180 --> 00:35:59,380
back we've we've been in their most

00:35:56,170 --> 00:36:06,849
populated regions of the world all over

00:35:59,380 --> 00:36:10,900
here we now have just these parts small

00:36:06,849 --> 00:36:15,700
parts to cover so maybe we'll take an

00:36:10,900 --> 00:36:18,819
hour after all so let's let's go to this

00:36:15,700 --> 00:36:23,140
place that the place of movers movers

00:36:18,819 --> 00:36:25,269
are Gotham's that move things around the

00:36:23,140 --> 00:36:28,359
simplest way to move things around is

00:36:25,269 --> 00:36:30,609
probably to copy them so sit copy is

00:36:28,359 --> 00:36:33,369
probably the simplest algorithm in the

00:36:30,609 --> 00:36:35,499
whole library takes to collection well

00:36:33,369 --> 00:36:40,150
takes one collection with a beginning an

00:36:35,499 --> 00:36:41,589
end and the outputs iterator of a second

00:36:40,150 --> 00:36:45,430
collection or back in size that I'll

00:36:41,589 --> 00:36:47,559
stream it writer whatever and copies

00:36:45,430 --> 00:36:49,980
every element of the first collection

00:36:47,559 --> 00:36:54,369
into the this out page writer

00:36:49,980 --> 00:36:56,980
there's also stirred move like we nice

00:36:54,369 --> 00:37:00,789
Ted move likes to move but there's also

00:36:56,980 --> 00:37:02,920
stirred move the algorithm and it takes

00:37:00,789 --> 00:37:05,349
beginning an end and in our output

00:37:02,920 --> 00:37:08,349
iterator just likes it copy and it's

00:37:05,349 --> 00:37:11,200
cause the usual student move on every

00:37:08,349 --> 00:37:13,059
element of the input collection so after

00:37:11,200 --> 00:37:14,529
stood move the algorithm all the

00:37:13,059 --> 00:37:19,720
elements of the input collection are

00:37:14,529 --> 00:37:21,369
moved and to swap the contents of two

00:37:19,720 --> 00:37:25,259
ranges they're swap branches and they

00:37:21,369 --> 00:37:28,599
all obviously have to be the same size

00:37:25,259 --> 00:37:31,670
now a little exercise

00:37:28,599 --> 00:37:34,700
let's say is that we've got a collection

00:37:31,670 --> 00:37:38,390
at the top one two three all the way up

00:37:34,700 --> 00:37:41,030
to ten and we would like to write some

00:37:38,390 --> 00:37:44,180
codes and use an algorithm that we've

00:37:41,030 --> 00:37:48,080
seen from the beginning of that talk up

00:37:44,180 --> 00:37:52,310
until now to turn it into the connection

00:37:48,080 --> 00:37:57,609
at the bottom so we want to copy the

00:37:52,310 --> 00:38:00,440
first five elements for positions down

00:37:57,609 --> 00:38:06,020
which algorithm do you think we could

00:38:00,440 --> 00:38:09,770
use to do that on there's less than 105

00:38:06,020 --> 00:38:15,440
possible answers yeah copy

00:38:09,770 --> 00:38:17,810
absolutely so we just copy I I thought I

00:38:15,440 --> 00:38:20,570
thought it used copy as well and and

00:38:17,810 --> 00:38:23,060
they did I think it crashed when I used

00:38:20,570 --> 00:38:27,050
it so let's see what happens

00:38:23,060 --> 00:38:30,560
what's happening so the first thing copy

00:38:27,050 --> 00:38:33,410
does is to copy the first element right

00:38:30,560 --> 00:38:37,250
to the output so so I don't know if you

00:38:33,410 --> 00:38:42,260
were thinking about that but I put as an

00:38:37,250 --> 00:38:47,060
output iterator begin + 4 + sorry

00:38:42,260 --> 00:38:51,470
+ 3 and then we've lost a value we've

00:38:47,060 --> 00:38:54,310
lost four right which is annoying what

00:38:51,470 --> 00:38:56,630
we would like to do is to copy but

00:38:54,310 --> 00:39:00,170
starting from the last one why because

00:38:56,630 --> 00:39:01,940
we think care about the eight that used

00:39:00,170 --> 00:39:05,540
to be there and then move all the way

00:39:01,940 --> 00:39:07,960
back up yeah so what we would really

00:39:05,540 --> 00:39:11,589
like to do is to copy but backwards

00:39:07,960 --> 00:39:16,030
that's what you're going to say right

00:39:11,589 --> 00:39:19,760
yeah copy backwards no anything

00:39:16,030 --> 00:39:24,230
and there's also move backwards that

00:39:19,760 --> 00:39:28,460
does the same thing but moves right so

00:39:24,230 --> 00:39:31,220
that's the movers now just down around

00:39:28,460 --> 00:39:32,660
the corner as the value modifiers which

00:39:31,220 --> 00:39:34,990
I would have expected to be more

00:39:32,660 --> 00:39:38,740
numerous but there's just four of them

00:39:34,990 --> 00:39:41,170
large piece of land so those guys

00:39:38,740 --> 00:39:43,780
actually change the values inside of a

00:39:41,170 --> 00:39:45,910
collection so how can we change the

00:39:43,780 --> 00:39:49,180
values inside of the collection one easy

00:39:45,910 --> 00:39:50,050
way to do that is to put the same value

00:39:49,180 --> 00:39:52,000
everywhere

00:39:50,050 --> 00:39:54,040
that's what filled-out does it takes

00:39:52,000 --> 00:39:58,540
begin and end value and cookies up

00:39:54,040 --> 00:40:02,350
values all the way through another way

00:39:58,540 --> 00:40:05,110
that submit similar in spirit is to use

00:40:02,350 --> 00:40:08,830
a function that that can be called with

00:40:05,110 --> 00:40:12,300
no arguments and we call that function

00:40:08,830 --> 00:40:17,860
once for every element of the collection

00:40:12,300 --> 00:40:19,119
that's generate another way to feed a

00:40:17,860 --> 00:40:21,820
collection and that's quite useful to

00:40:19,119 --> 00:40:24,510
have like I don't know a unit test is

00:40:21,820 --> 00:40:29,080
stuff like that to have a quickly a

00:40:24,510 --> 00:40:32,320
sequence of values its iota has a funny

00:40:29,080 --> 00:40:34,360
name I think it takes beginning and then

00:40:32,320 --> 00:40:38,010
value put that value at the beginning

00:40:34,360 --> 00:40:40,930
and then increment it and increments it

00:40:38,010 --> 00:40:43,930
until it fills the whole collection with

00:40:40,930 --> 00:40:50,200
increments and finally there's replays

00:40:43,930 --> 00:40:52,690
that quite expectedly replaces the

00:40:50,200 --> 00:40:55,810
values in a collection like replace 42

00:40:52,690 --> 00:41:04,810
43 will replace every 42 you buy your 43

00:40:55,810 --> 00:41:07,780
in collection events right now jumping

00:41:04,810 --> 00:41:10,600
above the water that's this islands of

00:41:07,780 --> 00:41:13,630
the structure changes what I call the

00:41:10,600 --> 00:41:17,980
structure changes is is the algorithms

00:41:13,630 --> 00:41:19,810
that after I've done that drove the the

00:41:17,980 --> 00:41:25,869
collection doesn't look the same even

00:41:19,810 --> 00:41:31,450
from afar so there are two of them

00:41:25,869 --> 00:41:34,030
remove an unique remove is used to

00:41:31,450 --> 00:41:38,560
remove values but has something peculiar

00:41:34,030 --> 00:41:40,540
with it since SD algorithms only access

00:41:38,560 --> 00:41:43,530
the iterators of a collection and not

00:41:40,540 --> 00:41:46,960
the collections themselves they can't

00:41:43,530 --> 00:41:48,130
change the size for example of election

00:41:46,960 --> 00:41:50,980
they can't perform

00:41:48,130 --> 00:41:53,740
arrays in a collection or the can do is

00:41:50,980 --> 00:41:54,790
to change the values between the

00:41:53,740 --> 00:42:00,360
beginning and the end

00:41:54,790 --> 00:42:04,150
so what remove stood remove does is to

00:42:00,360 --> 00:42:06,730
pull up the collection by leaving only

00:42:04,150 --> 00:42:10,390
those that should not be removed so if

00:42:06,730 --> 00:42:14,170
we want to remove 99s we used to remove

00:42:10,390 --> 00:42:17,350
begin and 99 and it will pull up

00:42:14,170 --> 00:42:20,280
everything that's left without the 99

00:42:17,350 --> 00:42:22,720
and what what's at the end is not

00:42:20,280 --> 00:42:25,030
specified we can't rely on it it could

00:42:22,720 --> 00:42:27,790
be it could be theorem and that were

00:42:25,030 --> 00:42:30,670
there before it could be 99 s be

00:42:27,790 --> 00:42:33,040
anything else it could change vary from

00:42:30,670 --> 00:42:36,880
compiler to compile and from version to

00:42:33,040 --> 00:42:39,670
version so we can't rely on that and to

00:42:36,880 --> 00:42:41,500
actually remove those element from say a

00:42:39,670 --> 00:42:44,140
vector we have to call a method on the

00:42:41,500 --> 00:42:47,290
container like arrays on a back some

00:42:44,140 --> 00:42:50,980
would like to erase what all the other

00:42:47,290 --> 00:42:54,100
element that are crossed out and to do

00:42:50,980 --> 00:42:56,230
that remove returns an iterator that

00:42:54,100 --> 00:42:58,270
points to the first element that's it

00:42:56,230 --> 00:43:01,030
crossed out so we have two arrays

00:42:58,270 --> 00:43:05,620
between what remote remove returns and

00:43:01,030 --> 00:43:08,530
the ends which is quite of a mouthful of

00:43:05,620 --> 00:43:13,150
code to remove the 99 in the collection

00:43:08,530 --> 00:43:15,610
isn't it I think that we should not use

00:43:13,150 --> 00:43:18,370
that codes and should wrap it into a

00:43:15,610 --> 00:43:22,030
function with a nicer name and use this

00:43:18,370 --> 00:43:27,070
you know everyday code I reckon there's

00:43:22,030 --> 00:43:30,610
been a proposal by STL Miss Tyus the

00:43:27,070 --> 00:43:32,350
other guy to add those functions to the

00:43:30,610 --> 00:43:35,890
standard hasn't been accepted yet so

00:43:32,350 --> 00:43:37,510
until it is if it is we should just wrap

00:43:35,890 --> 00:43:39,520
this function it's quite another thing

00:43:37,510 --> 00:43:42,010
to do if you want to grab the code is

00:43:39,520 --> 00:43:46,720
it's been published on free on c++ last

00:43:42,010 --> 00:43:49,780
week are again unique does something

00:43:46,720 --> 00:43:52,240
quite seminar it removes a double the

00:43:49,780 --> 00:43:54,520
the duplicates in a collection or more

00:43:52,240 --> 00:43:58,180
precisely the adjacent duplicates in a

00:43:54,520 --> 00:44:01,050
collection right so if we do unique here

00:43:58,180 --> 00:44:04,650
this correction has several 99

00:44:01,050 --> 00:44:07,320
and we'll remove only the adjacent 99

00:44:04,650 --> 00:44:09,890
because it has a linear complexity when

00:44:07,320 --> 00:44:14,280
a traverse the collection wants and

00:44:09,890 --> 00:44:17,130
unique we'll also put up the values that

00:44:14,280 --> 00:44:19,080
are to be left and return an iterator

00:44:17,130 --> 00:44:21,180
answer the values to them

00:44:19,080 --> 00:44:23,190
yeah the values that crossed out those

00:44:21,180 --> 00:44:26,400
value we can't rely on them just right

00:44:23,190 --> 00:44:29,460
remove and we have to erase them quite a

00:44:26,400 --> 00:44:31,260
bit of code not much and we should

00:44:29,460 --> 00:44:33,420
package that into the function with a

00:44:31,260 --> 00:44:36,180
bad name without unique it's a better

00:44:33,420 --> 00:44:40,440
name I'm not sure but we should at least

00:44:36,180 --> 00:44:45,050
package that into a function I've got a

00:44:40,440 --> 00:44:49,140
question there so I couldn't hear that

00:44:45,050 --> 00:44:50,550
you need one was not removed that's good

00:44:49,140 --> 00:44:53,340
as a very I mean it's not removed

00:44:50,550 --> 00:44:59,010
because there's no adjacent ones in the

00:44:53,340 --> 00:45:01,710
collection thanks for that we've been

00:44:59,010 --> 00:45:02,910
locked in your own copy we've seen all

00:45:01,710 --> 00:45:04,620
the algorithm that I'll combine with

00:45:02,910 --> 00:45:08,940
copy in the yesterday logarithms library

00:45:04,620 --> 00:45:12,120
so copy you can check it on an algorithm

00:45:08,940 --> 00:45:15,720
like those algorithms and it creates new

00:45:12,120 --> 00:45:18,360
yorker' them that do the same thing but

00:45:15,720 --> 00:45:22,050
in a new collection so like remove or

00:45:18,360 --> 00:45:25,530
unique or replace whatever they operate

00:45:22,050 --> 00:45:27,840
in place those guys they leave the

00:45:25,530 --> 00:45:29,940
collection untouched and and they're

00:45:27,840 --> 00:45:34,220
taken out for iterator and they produced

00:45:29,940 --> 00:45:39,890
output to that output iterator

00:45:34,220 --> 00:45:43,920
we've also unlocked if that as a

00:45:39,890 --> 00:45:45,900
predicate so we're say fine for example

00:45:43,920 --> 00:45:47,400
what's taking the value fine if takes a

00:45:45,900 --> 00:45:53,460
predicate it does essentially the same

00:45:47,400 --> 00:45:56,550
thing and we're going to go to that part

00:45:53,460 --> 00:45:59,990
we started with a talk with the Lonely

00:45:56,550 --> 00:46:03,270
Island's with for each and transform

00:45:59,990 --> 00:46:04,830
let's start with transform I there's

00:46:03,270 --> 00:46:07,200
nothing wrong with for each transform

00:46:04,830 --> 00:46:09,780
the reason why I put them on on Lonely

00:46:07,200 --> 00:46:11,940
Island's is because I couldn't see in

00:46:09,780 --> 00:46:12,240
what family they would belong I think

00:46:11,940 --> 00:46:15,810
they

00:46:12,240 --> 00:46:19,020
sort of like separate even though it's

00:46:15,810 --> 00:46:20,970
not a problem in itself so transform

00:46:19,020 --> 00:46:23,700
essentially the applies a function to

00:46:20,970 --> 00:46:28,050
the elements of a collection so it takes

00:46:23,700 --> 00:46:30,630
a collection began a function f and an

00:46:28,050 --> 00:46:34,680
output like an output iterator such as

00:46:30,630 --> 00:46:38,640
this back insert here and and it

00:46:34,680 --> 00:46:40,080
produces the well the applicant

00:46:38,640 --> 00:46:42,540
application of that function to every

00:46:40,080 --> 00:46:45,720
element in the collection what's a bit

00:46:42,540 --> 00:46:50,369
less famous that transform is its author

00:46:45,720 --> 00:46:52,349
of overloads the one that takes two

00:46:50,369 --> 00:46:59,310
collections in a function that takes two

00:46:52,349 --> 00:47:01,099
parameters right so a it applies that

00:46:59,310 --> 00:47:03,839
function just like transform with one

00:47:01,099 --> 00:47:06,150
input collection to the the two

00:47:03,839 --> 00:47:08,430
collection by feeding the two collection

00:47:06,150 --> 00:47:13,050
into F for each element in producing the

00:47:08,430 --> 00:47:16,859
output yeah like for example if you'd

00:47:13,050 --> 00:47:19,500
like to sum the elements of two

00:47:16,859 --> 00:47:22,170
collection 2 by C you can do that with

00:47:19,500 --> 00:47:26,640
one line of code in with transform and F

00:47:22,170 --> 00:47:30,300
would be stood plus and that's for each

00:47:26,640 --> 00:47:32,910
and for each if we if we think about

00:47:30,300 --> 00:47:35,790
what it does so for each takes begin and

00:47:32,910 --> 00:47:37,730
end and some piece of code a function it

00:47:35,790 --> 00:47:42,890
could be a lambda for example or a

00:47:37,730 --> 00:47:46,470
regular function and it applies that

00:47:42,890 --> 00:47:50,010
function to every element what's

00:47:46,470 --> 00:47:55,830
interesting to note is that it doesn't

00:47:50,010 --> 00:47:58,980
care about what f returns so for the

00:47:55,830 --> 00:48:04,619
purpose of for each F miners well return

00:47:58,980 --> 00:48:13,259
void now what does a function that

00:48:04,619 --> 00:48:18,279
return that returns void do anyone idea

00:48:13,259 --> 00:48:20,019
yeah exactly sign events for each is

00:48:18,279 --> 00:48:22,539
made to perform side effects

00:48:20,019 --> 00:48:24,189
now our side effects a good thing or a

00:48:22,539 --> 00:48:26,469
bad thing is absolutely not the purpose

00:48:24,189 --> 00:48:28,779
of that talk even though I think that

00:48:26,469 --> 00:48:31,390
some case are useful for sale with side

00:48:28,779 --> 00:48:33,219
effects but for each is made for doing

00:48:31,390 --> 00:48:36,339
side effects that could be side effects

00:48:33,219 --> 00:48:37,989
on the LMS and felt that themselves

00:48:36,339 --> 00:48:41,349
modifying the elements of the collection

00:48:37,989 --> 00:48:44,349
or that the side effect in the more

00:48:41,349 --> 00:48:45,969
general sense of sending stuff to logger

00:48:44,349 --> 00:48:48,159
or whatever

00:48:45,969 --> 00:48:50,650
right but for each is made for side

00:48:48,159 --> 00:48:52,809
effects using for each for making

00:48:50,650 --> 00:48:55,749
anything else such as a partition or

00:48:52,809 --> 00:48:58,359
refine or whatever is not the right user

00:48:55,749 --> 00:49:00,579
to for each their algorithms are more

00:48:58,359 --> 00:49:03,069
appropriate than for each and if there's

00:49:00,579 --> 00:49:05,559
no algorithm more appropriate than for

00:49:03,069 --> 00:49:08,049
each in the Esther algorithms then the

00:49:05,559 --> 00:49:10,479
algorithms outside of the SDL are away

00:49:08,049 --> 00:49:12,179
and we briefly talk about them in a

00:49:10,479 --> 00:49:18,219
minute

00:49:12,179 --> 00:49:18,999
okay so we've been literally all around

00:49:18,219 --> 00:49:21,640
the world

00:49:18,999 --> 00:49:25,029
we've sorted down there we've been in a

00:49:21,640 --> 00:49:27,519
lot of queries the glorious Qin County

00:49:25,029 --> 00:49:29,829
of algorithms and set movers the value

00:49:27,519 --> 00:49:33,579
modifier is and the structure changes

00:49:29,829 --> 00:49:39,969
and even up there there's only one place

00:49:33,579 --> 00:49:42,029
we haven't been yet the raw memory so

00:49:39,969 --> 00:49:44,979
we're going to finish up with that one

00:49:42,029 --> 00:49:50,289
what does that mean algorithms on the

00:49:44,979 --> 00:49:55,119
wall memory well if you think back to

00:49:50,289 --> 00:49:58,449
fill and copy and move they have one

00:49:55,119 --> 00:50:01,380
thing in common is it 1 does anyone see

00:49:58,449 --> 00:50:01,380
what they have in common

00:50:07,350 --> 00:50:14,740
if that they use the assignment operator

00:50:11,430 --> 00:50:18,460
for each the signs are 42 sorry Phil

00:50:14,740 --> 00:50:21,610
assigns a 42 copy of signs with the copy

00:50:18,460 --> 00:50:23,440
assignments moves assigns we move the

00:50:21,610 --> 00:50:27,310
science with a move assignment they all

00:50:23,440 --> 00:50:31,690
use an assignment now if we use an

00:50:27,310 --> 00:50:33,990
assignment operator it means that the

00:50:31,690 --> 00:50:39,730
object has been constructed and

00:50:33,990 --> 00:50:44,320
hopefully that's true but in some rare

00:50:39,730 --> 00:50:46,690
cases we have objects that are not

00:50:44,320 --> 00:50:49,180
constructed yet if we have just just the

00:50:46,690 --> 00:50:51,550
memory just chunks of memory that we got

00:50:49,180 --> 00:50:55,030
from somewhere and we'd like to

00:50:51,550 --> 00:50:57,370
construct instead of of calling the

00:50:55,030 --> 00:50:59,820
assignment operator we'd like to call

00:50:57,370 --> 00:51:03,190
constructor on those chunks of memory

00:50:59,820 --> 00:51:05,350
well for that we use their uninitialized

00:51:03,190 --> 00:51:08,230
counterparts and they should i spell the

00:51:05,350 --> 00:51:10,930
initials copy initiative move and those

00:51:08,230 --> 00:51:13,240
use constructors so this takes this is

00:51:10,930 --> 00:51:15,130
the constructor that takes a value this

00:51:13,240 --> 00:51:18,490
is a copy constructor this is a move

00:51:15,130 --> 00:51:21,100
constructor so in practice you get a

00:51:18,490 --> 00:51:27,430
chunk of memory from somewhere shared

00:51:21,100 --> 00:51:30,400
memory or whatever and you'd like to

00:51:27,430 --> 00:51:32,770
fill it with values but you can't call

00:51:30,400 --> 00:51:34,900
fill because you can't call the

00:51:32,770 --> 00:51:37,090
assignment operator because it's just

00:51:34,900 --> 00:51:39,300
raw memory right hasn't been initialized

00:51:37,090 --> 00:51:42,010
yet so we need to call the constructor

00:51:39,300 --> 00:51:45,190
this is what initial and initials fill

00:51:42,010 --> 00:51:47,100
does right it cool it takes two pointers

00:51:45,190 --> 00:51:52,240
well at the beginning in the end and

00:51:47,100 --> 00:51:54,130
cause the value constructor leading to

00:51:52,240 --> 00:51:58,800
an initially is our initialization in

00:51:54,130 --> 00:52:02,410
this relation of that chunk of memory

00:51:58,800 --> 00:52:05,410
now once we were done with it we want to

00:52:02,410 --> 00:52:07,330
call the destructor of those guys

00:52:05,410 --> 00:52:10,150
because we've been in charge of that

00:52:07,330 --> 00:52:11,590
constructor probably also in charge of

00:52:10,150 --> 00:52:15,550
cording the destructor and that was

00:52:11,590 --> 00:52:17,470
stood destroy does kind of like sounds

00:52:15,550 --> 00:52:18,670
familiar right destroy BA we're doing

00:52:17,470 --> 00:52:20,650
from the you there

00:52:18,670 --> 00:52:25,090
day-to-day basis but that's that's what

00:52:20,650 --> 00:52:27,460
it does so destroy will destroy the call

00:52:25,090 --> 00:52:30,610
the destructor of all the elements in

00:52:27,460 --> 00:52:32,410
that collection and if we'd like to call

00:52:30,610 --> 00:52:34,330
the other kinds of constructors does

00:52:32,410 --> 00:52:36,700
default constructor or value good

00:52:34,330 --> 00:52:38,920
structure what value in Australia in

00:52:36,700 --> 00:52:41,080
initialization cause any an initialize

00:52:38,920 --> 00:52:44,350
different construct yesterday's value

00:52:41,080 --> 00:52:49,360
construct and we've unlocked our final

00:52:44,350 --> 00:52:51,880
rune the underscore n that that changes

00:52:49,360 --> 00:52:54,070
the little the interface like instead of

00:52:51,880 --> 00:52:59,110
taking a beginning an end it takes it

00:52:54,070 --> 00:53:03,070
begin and a sighs a second example so

00:52:59,110 --> 00:53:05,740
studio thing Phil so Phil takes begin

00:53:03,070 --> 00:53:09,760
and then value put that value all the

00:53:05,740 --> 00:53:13,540
way through Phil n takes a begin and a

00:53:09,760 --> 00:53:16,630
sighs okay and a value and it fills the

00:53:13,540 --> 00:53:18,490
fight the first five elements starting

00:53:16,630 --> 00:53:23,590
from begin it fills them with the

00:53:18,490 --> 00:53:27,130
fortitude now would you think this line

00:53:23,590 --> 00:53:29,380
of this third line of code does imagine

00:53:27,130 --> 00:53:31,480
that collection is a vector an empty

00:53:29,380 --> 00:53:33,040
vector for example what do you think is

00:53:31,480 --> 00:53:38,200
in collection after executing executing

00:53:33,040 --> 00:53:40,380
that third line of code so that a little

00:53:38,200 --> 00:53:40,380
louder

00:53:40,440 --> 00:53:47,080
absolutely that would insert five

00:53:43,840 --> 00:53:48,820
elements equal to 42 right because it

00:53:47,080 --> 00:53:53,500
would sign through the back insert

00:53:48,820 --> 00:53:56,700
operator five signs right this time

00:53:53,500 --> 00:54:00,460
we've been around the world everywhere

00:53:56,700 --> 00:54:07,900
you know everything in the STL

00:54:00,460 --> 00:54:09,880
algorithms library now what what's one

00:54:07,900 --> 00:54:12,760
thing you can use them in your code to

00:54:09,880 --> 00:54:16,210
make it more expressive right you can

00:54:12,760 --> 00:54:18,670
think about if you'll want to write a

00:54:16,210 --> 00:54:20,200
for loop think about if you could use an

00:54:18,670 --> 00:54:23,770
algorithm instead or if you could

00:54:20,200 --> 00:54:26,620
replace existing for lips there are like

00:54:23,770 --> 00:54:29,450
a bit of a problem in your code by an SL

00:54:26,620 --> 00:54:32,089
Gotham to make it smoother at work with

00:54:29,450 --> 00:54:34,790
and you should like second pair of eyes

00:54:32,089 --> 00:54:36,560
I always like to read code so you can

00:54:34,790 --> 00:54:40,010
reach out to me and show me your code

00:54:36,560 --> 00:54:42,320
then I can have a look and think about

00:54:40,010 --> 00:54:43,630
which algorithm with you we can put in

00:54:42,320 --> 00:54:47,990
your code I've been more than happy to

00:54:43,630 --> 00:54:50,329
look at code if you'd like to see more

00:54:47,990 --> 00:54:53,920
algorithms there are some outside of the

00:54:50,329 --> 00:54:57,230
STL and the library next door is boost

00:54:53,920 --> 00:54:59,540
boost algorithms which contains all the

00:54:57,230 --> 00:55:03,680
algorithms that are in the same spirit

00:54:59,540 --> 00:55:05,869
as the algorithms of the STL soon our

00:55:03,680 --> 00:55:08,380
wall Pablito I will publish on free on

00:55:05,869 --> 00:55:12,560
C++ a series of articles going all

00:55:08,380 --> 00:55:17,770
through all these guys to go further

00:55:12,560 --> 00:55:20,060
it's a good thing to understand in depth

00:55:17,770 --> 00:55:25,190
VSD algorithm since I think it's a good

00:55:20,060 --> 00:55:28,130
investor investment of our time about

00:55:25,190 --> 00:55:30,140
that complexity about their prerequisite

00:55:28,130 --> 00:55:33,440
post requisite think about sorted

00:55:30,140 --> 00:55:36,020
collections for example and and see how

00:55:33,440 --> 00:55:40,579
they're implemented them that's often

00:55:36,020 --> 00:55:44,720
quite instructive and finally if you use

00:55:40,579 --> 00:55:50,540
them on a day to day basis you can get

00:55:44,720 --> 00:55:54,050
inspired you can have a better intuition

00:55:50,540 --> 00:55:56,060
of abstractions work well and that's

00:55:54,050 --> 00:55:59,060
fundamental for writing good code and

00:55:56,060 --> 00:56:02,960
that that intuition you can use that in

00:55:59,060 --> 00:56:05,089
your own code and once you're familiar

00:56:02,960 --> 00:56:07,490
enough you can start thinking about

00:56:05,089 --> 00:56:10,190
writing your own algorithm so what sort

00:56:07,490 --> 00:56:11,960
of algorithm can we write well we can

00:56:10,190 --> 00:56:13,310
combine an algorithm an existing

00:56:11,960 --> 00:56:15,859
algorithm with an existing room to

00:56:13,310 --> 00:56:18,470
create a new a new combination like salt

00:56:15,859 --> 00:56:23,210
copy as an exists for example or we

00:56:18,470 --> 00:56:24,410
could add a city on the map if I were to

00:56:23,210 --> 00:56:26,510
add something I think I would add

00:56:24,410 --> 00:56:27,770
something to the algorithm and sets do

00:56:26,510 --> 00:56:30,260
something like an algorithm that would

00:56:27,770 --> 00:56:31,339
have three outputs those are in a not in

00:56:30,260 --> 00:56:34,339
bb9

00:56:31,339 --> 00:56:37,670
a and both in a and B or in Singapore I

00:56:34,339 --> 00:56:40,910
think if you think about things to add

00:56:37,670 --> 00:56:43,010
I'm happy to hear about that too I'll

00:56:40,910 --> 00:56:45,990
start a new family

00:56:43,010 --> 00:56:49,079
if you'd like to get the map you can

00:56:45,990 --> 00:56:51,960
download it on fluency peepee calm slash

00:56:49,079 --> 00:56:54,480
get the map and there you can also order

00:56:51,960 --> 00:56:57,089
the poster that you can hang in your

00:56:54,480 --> 00:57:03,260
homes and offices and for the people in

00:56:57,089 --> 00:57:07,289
the room you should like to acquire

00:57:03,260 --> 00:57:09,569
poster right now like those one I've got

00:57:07,289 --> 00:57:15,569
a bunch of them with me so you can come

00:57:09,569 --> 00:57:17,819
and see me after the talk you should

00:57:15,569 --> 00:57:21,539
like to get in touch you can find me on

00:57:17,819 --> 00:57:23,730
Twitter at Jericho and if you're

00:57:21,539 --> 00:57:26,910
interested in reading about the STL or

00:57:23,730 --> 00:57:29,970
about expressive code in general you can

00:57:26,910 --> 00:57:31,950
check out fluency PP Kampf UN C++ with a

00:57:29,970 --> 00:57:36,950
new post every every Tuesday and every

00:57:31,950 --> 00:57:36,950
Friday about expressive code in C++

00:57:37,309 --> 00:57:40,309
thanks

00:57:44,220 --> 00:57:46,280

YouTube URL: https://www.youtube.com/watch?v=2olsGf6JIkU


