Title: CppCon 2018: Bjarne Stroustrup “Concepts: The Future of Generic Programming (the future is here)”
Publication date: 2018-09-25
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Concepts have arrived. They will change the way we think about programming. Implementations are available in GCC and Clang. Many fundamental concepts are in the standard committee’s working paper and the next generation of the STL depends critically on concepts.

After briefly introducing concepts, I consider their role in design. What makes a good/useful concept? How do you design good concepts and use them well?

From a language-technical point of view, concepts are a way of constraining template arguments. From a design perspective, they are a focus comparable to user-defined types (classes): The intent is for a concept to represent a fundamental concept in an applications domain (hence the name “concept”).

I will mention technical issues recently resolved  or currently being resolved in the committee, but my primarily focus is not concepts as a language mechanism but as a support for the development of good software.
— 
Bjarne Stroustrup
MD, MorganStanley
C++: history, design, use, standardization, future; performance, reliability; software developer education; | distributed systems | Bio: www.stroustrup.com/bio.html
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,600 --> 00:00:18,530
[Music]

00:00:15,580 --> 00:00:21,200
journeys through syrup has been a

00:00:18,530 --> 00:00:27,050
guiding force for this community and has

00:00:21,200 --> 00:00:29,119
done a lot work to promote c++ and to

00:00:27,050 --> 00:00:32,090
build a community out of that and so i

00:00:29,119 --> 00:00:33,199
wanna i'm looking forward to his talk

00:00:32,090 --> 00:00:34,820
today where he's going to tell us a

00:00:33,199 --> 00:00:47,210
little bit about concepts and what that

00:00:34,820 --> 00:00:49,579
means thank you very much Gary okay Wow

00:00:47,210 --> 00:00:53,210
if I could see all of you are be

00:00:49,579 --> 00:00:55,130
intimidated but fortunately thanks to

00:00:53,210 --> 00:00:59,360
the lights I can see about two lines

00:00:55,130 --> 00:01:02,059
here so I'm going to tell you a little

00:00:59,360 --> 00:01:05,690
bit about concepts and in some ways

00:01:02,059 --> 00:01:09,560
that's a very old topic and other since

00:01:05,690 --> 00:01:12,350
its new you can start using it some of

00:01:09,560 --> 00:01:15,830
us has been using it for years it's

00:01:12,350 --> 00:01:17,539
getting into production in places so I'm

00:01:15,830 --> 00:01:21,080
going to talk a little bit about generic

00:01:17,539 --> 00:01:23,179
programming then I'm going to say what

00:01:21,080 --> 00:01:27,679
what do we actually get out of concepts

00:01:23,179 --> 00:01:32,149
and what are concepts and how do you

00:01:27,679 --> 00:01:35,690
build useful ones so basically you can

00:01:32,149 --> 00:01:38,479
go back to the early aims of David

00:01:35,690 --> 00:01:42,080
Martin masa and alex definite

00:01:38,479 --> 00:01:45,410
basically wanting to get generic

00:01:42,080 --> 00:01:48,590
programming in as a discipline providing

00:01:45,410 --> 00:01:55,039
more flexible better code with with a

00:01:48,590 --> 00:02:00,679
focus on on algorithms as opposed to

00:01:55,039 --> 00:02:03,470
data types and my aim is sort of fairly

00:02:00,679 --> 00:02:06,679
simply stated making generic code as

00:02:03,470 --> 00:02:10,989
simple as non generic code this is one

00:02:06,679 --> 00:02:14,780
of these modest and ambitious aims that

00:02:10,989 --> 00:02:17,030
that can drive development so I'm going

00:02:14,780 --> 00:02:19,849
to do that obviously when you have

00:02:17,030 --> 00:02:21,799
generic code not all code can be as

00:02:19,849 --> 00:02:23,319
simple as if you're just writing code

00:02:21,799 --> 00:02:26,980
based on

00:02:23,319 --> 00:02:30,329
knowing that everything is a CC so more

00:02:26,980 --> 00:02:33,310
advanced generic code should be not

00:02:30,329 --> 00:02:37,150
unnecessarily complicated but it can't

00:02:33,310 --> 00:02:39,909
quite be as simple as that's non generic

00:02:37,150 --> 00:02:42,819
code and and one thing I would like to

00:02:39,909 --> 00:02:45,760
emphasize and I feel I probably won't be

00:02:42,819 --> 00:02:47,980
able to do it as much as I would like to

00:02:45,760 --> 00:02:50,620
is it's not just for foundation

00:02:47,980 --> 00:02:55,269
libraries there's a lot of application

00:02:50,620 --> 00:02:57,340
code that is generic and you shouldn't

00:02:55,269 --> 00:02:59,439
just think about it as something or on

00:02:57,340 --> 00:03:02,980
the standard library that you don't

00:02:59,439 --> 00:03:05,590
really need to think about I was talking

00:03:02,980 --> 00:03:09,159
to a bunch of theoretical physicists a

00:03:05,590 --> 00:03:11,199
couple of weeks ago it it's they're in

00:03:09,159 --> 00:03:14,049
their stuff that's certainly not

00:03:11,199 --> 00:03:16,599
foundation library talk to generic

00:03:14,049 --> 00:03:21,569
program embedded systems programmers

00:03:16,599 --> 00:03:25,959
that use it for certain aspects of

00:03:21,569 --> 00:03:28,030
device controls this the stuff concepts

00:03:25,959 --> 00:03:32,139
is not just as hysteric it's not

00:03:28,030 --> 00:03:34,989
academic at all and it is is not just

00:03:32,139 --> 00:03:37,259
for foundation library basically the

00:03:34,989 --> 00:03:39,359
whole game is to are a better code and

00:03:37,259 --> 00:03:42,790
better code has all the usual

00:03:39,359 --> 00:03:45,250
requirements here nothing has much to do

00:03:42,790 --> 00:03:48,250
with generic programming but the point

00:03:45,250 --> 00:03:50,799
is that if you write generic program in

00:03:48,250 --> 00:03:55,269
good generic code it helps with all of

00:03:50,799 --> 00:03:59,859
those things and it's basically a

00:03:55,269 --> 00:04:02,169
significant help I I really don't like

00:03:59,859 --> 00:04:04,509
talk much about individual language

00:04:02,169 --> 00:04:07,840
features a language feature and

00:04:04,509 --> 00:04:09,639
isolation is usually boring and you can

00:04:07,840 --> 00:04:13,239
still talk about where you put your

00:04:09,639 --> 00:04:15,579
commas and semicolons and some people

00:04:13,239 --> 00:04:18,400
like that I don't I I tend to fall

00:04:15,579 --> 00:04:20,889
asleep over that it's necessary at some

00:04:18,400 --> 00:04:22,949
level but I'm trying to get the big

00:04:20,889 --> 00:04:25,750
picture so this is not a talk about

00:04:22,949 --> 00:04:29,349
language technical details if you want

00:04:25,750 --> 00:04:32,080
to know the the latest about the debates

00:04:29,349 --> 00:04:34,540
in the Standards Committee well go to

00:04:32,080 --> 00:04:37,500
one of the other talks to the girl

00:04:34,540 --> 00:04:39,790
a committee panel or something like that

00:04:37,500 --> 00:04:42,870
this is not what I'm trying to talk

00:04:39,790 --> 00:04:45,760
about and there are at least four talks

00:04:42,870 --> 00:04:50,260
at this conference that that goes into

00:04:45,760 --> 00:04:52,540
details about generic programming and

00:04:50,260 --> 00:04:57,000
concepts so that's another good reason

00:04:52,540 --> 00:05:01,270
for me not to go into those details so

00:04:57,000 --> 00:05:03,730
the concepts have have been moving

00:05:01,270 --> 00:05:06,490
through the standards process too slowly

00:05:03,730 --> 00:05:11,080
in my opinion of course but I'm known to

00:05:06,490 --> 00:05:14,980
be impatient and basically the GS was

00:05:11,080 --> 00:05:17,170
approved two years ago and we have the

00:05:14,980 --> 00:05:20,380
expertise requires clauses in the

00:05:17,170 --> 00:05:23,650
working paper now barring utter disaster

00:05:20,380 --> 00:05:25,900
it will be in C++ 20 we have the

00:05:23,650 --> 00:05:28,150
shorthand notation so that you can

00:05:25,900 --> 00:05:31,330
instead of just saying I want the type

00:05:28,150 --> 00:05:33,670
and I can say I want that here random

00:05:31,330 --> 00:05:36,160
access iterator and we have requires

00:05:33,670 --> 00:05:39,880
expressions to to express things

00:05:36,160 --> 00:05:45,160
directly in the language not quite yet

00:05:39,880 --> 00:05:49,150
we hope to get ranges into the working

00:05:45,160 --> 00:05:54,130
paper in San Diego let's listen to month

00:05:49,150 --> 00:05:56,050
away and again that seems to to very

00:05:54,130 --> 00:05:59,380
little work which means that you are

00:05:56,050 --> 00:06:02,410
algorithms and containers and stuff like

00:05:59,380 --> 00:06:04,780
that I can start using concepts and you

00:06:02,410 --> 00:06:10,270
get the benefits right out of the box

00:06:04,780 --> 00:06:12,670
with with C++ 20 there there's work

00:06:10,270 --> 00:06:17,370
going on on the function declaration

00:06:12,670 --> 00:06:20,170
like syntax that's not settled yet and

00:06:17,370 --> 00:06:22,810
my guess is you won't get the concept

00:06:20,170 --> 00:06:25,600
type name introduces if you don't know

00:06:22,810 --> 00:06:27,730
what that is well tough you can find out

00:06:25,600 --> 00:06:31,510
in anyway you probably won't be able to

00:06:27,730 --> 00:06:35,350
use it in production for another couple

00:06:31,510 --> 00:06:37,660
of years it's all available in the GCC

00:06:35,350 --> 00:06:43,510
implementation now

00:06:37,660 --> 00:06:46,020
so my main sort of thesis here is that

00:06:43,510 --> 00:06:51,670
genetic program is just programming and

00:06:46,020 --> 00:06:55,060
my aim is to make this more true than it

00:06:51,670 --> 00:06:57,730
is now and this implies that we need to

00:06:55,060 --> 00:07:01,480
improve some of our type checking to

00:06:57,730 --> 00:07:05,850
make type checking for generic code much

00:07:01,480 --> 00:07:07,930
more like checking for ordinary code

00:07:05,850 --> 00:07:10,720
eventually the generic code will be

00:07:07,930 --> 00:07:15,550
ordinary code we need to improve the

00:07:10,720 --> 00:07:19,750
syntax the template syntax is clunky it

00:07:15,550 --> 00:07:20,590
has been clunky since the the simplest

00:07:19,750 --> 00:07:26,050
syntax

00:07:20,590 --> 00:07:28,780
didn't-didn't fly-in in the 80s and we

00:07:26,050 --> 00:07:31,420
have to organize our code for generic

00:07:28,780 --> 00:07:33,700
and non-generic code in the same way not

00:07:31,420 --> 00:07:39,040
all of this head of stuff for templates

00:07:33,700 --> 00:07:42,070
and dot c for CBP 4 4 code that's the

00:07:39,040 --> 00:07:44,530
modules stuff so I'm not going to talk

00:07:42,070 --> 00:07:49,000
about that so basically there's a

00:07:44,530 --> 00:07:52,060
history to this in in the 80s most of

00:07:49,000 --> 00:07:57,040
the 90s if you wanted generic code in

00:07:52,060 --> 00:07:59,500
C++ you ended up using macros and I have

00:07:57,040 --> 00:08:01,810
a paper from 81 that says we need

00:07:59,500 --> 00:08:04,480
generic programming and macros we'll

00:08:01,810 --> 00:08:06,280
just do it for us I was right about the

00:08:04,480 --> 00:08:09,910
first part and I was very wrong about

00:08:06,280 --> 00:08:13,990
the second part macros just poisons

00:08:09,910 --> 00:08:17,050
everything including your your IDE and

00:08:13,990 --> 00:08:19,000
your editor and scrambled your brain so

00:08:17,050 --> 00:08:26,170
we have to do better than that

00:08:19,000 --> 00:08:30,250
in 87 and on so now that I have some

00:08:26,170 --> 00:08:33,370
fairly specific aims at 4-4 templates I

00:08:30,250 --> 00:08:35,950
want them to be flexible at the time I

00:08:33,370 --> 00:08:37,450
said I don't want a language that can

00:08:35,950 --> 00:08:41,410
only do what I can imagine

00:08:37,450 --> 00:08:43,620
I mean maybe my imagination is good but

00:08:41,410 --> 00:08:47,200
sure isn't as good as the union of

00:08:43,620 --> 00:08:49,420
people in a room like this and I want a

00:08:47,200 --> 00:08:50,980
serie overhead otherwise people are

00:08:49,420 --> 00:08:55,600
right this sort of

00:08:50,980 --> 00:08:59,350
ugly pointers and and and array kind of

00:08:55,600 --> 00:09:03,579
code that they then think is is more

00:08:59,350 --> 00:09:05,829
efficient it often isn't and it's

00:09:03,579 --> 00:09:08,649
certainly less maintainable that and

00:09:05,829 --> 00:09:09,370
good generic code so it had to have zero

00:09:08,649 --> 00:09:13,380
overhead

00:09:09,370 --> 00:09:17,560
this is C++ has to be used for really

00:09:13,380 --> 00:09:20,740
critical embedded system stuff it has to

00:09:17,560 --> 00:09:25,019
be used for high-performance stuff and

00:09:20,740 --> 00:09:28,269
it is today and then of course I wanted

00:09:25,019 --> 00:09:31,779
good interfaces because good interfaces

00:09:28,269 --> 00:09:34,060
is essential for large for large

00:09:31,779 --> 00:09:36,519
software that's how we partition our

00:09:34,060 --> 00:09:39,399
code we only have two ways of of

00:09:36,519 --> 00:09:40,570
simplifying code its abstraction and

00:09:39,399 --> 00:09:42,579
divide and conquer

00:09:40,570 --> 00:09:44,410
divide and conquer means putting a

00:09:42,579 --> 00:09:48,610
barrier between two parts of the code

00:09:44,410 --> 00:09:50,769
and we get there and as I used to say

00:09:48,610 --> 00:09:51,339
two out of three ain't bad but it isn't

00:09:50,769 --> 00:09:54,670
good either

00:09:51,339 --> 00:09:58,329
so I've been trying to figure out how to

00:09:54,670 --> 00:10:00,190
get away from the basic templates on

00:09:58,329 --> 00:10:03,010
constraint templates header only

00:10:00,190 --> 00:10:05,410
organization because it's fundamentally

00:10:03,010 --> 00:10:07,690
not right it may be good enough we've

00:10:05,410 --> 00:10:11,980
done superb things as a community in

00:10:07,690 --> 00:10:15,430
this period what we can do better okay

00:10:11,980 --> 00:10:19,449
so let's let's take the time machine go

00:10:15,430 --> 00:10:22,420
back to 78 and that's how we wrote code

00:10:19,449 --> 00:10:24,760
this is KN our code say that square root

00:10:22,420 --> 00:10:29,019
returns a double we give it a two and it

00:10:24,760 --> 00:10:34,060
crashes of course because two happens

00:10:29,019 --> 00:10:37,060
not to be a double well so what well we

00:10:34,060 --> 00:10:39,370
didn't say it was a double all we can

00:10:37,060 --> 00:10:41,589
say is we can go to the source code and

00:10:39,370 --> 00:10:44,800
look at it and say that square root

00:10:41,589 --> 00:10:49,180
takes an X and it would it treats it as

00:10:44,800 --> 00:10:52,810
a double it does not say you must give

00:10:49,180 --> 00:10:57,910
it a double or you get an error get a

00:10:52,810 --> 00:11:01,240
runtime error no you get a crash and I I

00:10:57,910 --> 00:11:02,829
had sort of one look and another look at

00:11:01,240 --> 00:11:03,840
this couldn't quite believe what I was

00:11:02,829 --> 00:11:07,980
seeing

00:11:03,840 --> 00:11:12,150
and made some changes in the last in the

00:11:07,980 --> 00:11:15,000
first two to week two months of the C++

00:11:12,150 --> 00:11:17,250
project see the classes that was called

00:11:15,000 --> 00:11:21,150
so now we can write double square root

00:11:17,250 --> 00:11:24,990
of double I mean I want my square root

00:11:21,150 --> 00:11:27,120
and I want the declaration to say that

00:11:24,990 --> 00:11:29,730
it expects a double so that if we get

00:11:27,120 --> 00:11:33,890
square root or true I get the right

00:11:29,730 --> 00:11:37,080
answer it converts to true 2.0 or 2.0

00:11:33,890 --> 00:11:40,590
similarly if I give it some rubbish like

00:11:37,080 --> 00:11:43,470
a string I get an error right there this

00:11:40,590 --> 00:11:46,320
made a huge difference and I also

00:11:43,470 --> 00:11:49,620
cleaned up the syntax so that the

00:11:46,320 --> 00:11:52,890
definition now looks like declaration

00:11:49,620 --> 00:11:54,750
and if you've been writing C++ you

00:11:52,890 --> 00:11:57,150
probably never seen anything else if

00:11:54,750 --> 00:11:59,040
you've been writing C in the last sort

00:11:57,150 --> 00:12:02,820
of thirty years you've been seeing

00:11:59,040 --> 00:12:05,070
things roughly like that and it's it's

00:12:02,820 --> 00:12:09,330
an operation like that that I think

00:12:05,070 --> 00:12:13,320
we're trying to do with with with with

00:12:09,330 --> 00:12:17,220
concepts relative to checking go back to

00:12:13,320 --> 00:12:21,000
88 and we're saying that there must be a

00:12:17,220 --> 00:12:25,040
type which we will use as an iterator

00:12:21,000 --> 00:12:28,170
and since we don't know too much about

00:12:25,040 --> 00:12:30,990
the interface it just says there must be

00:12:28,170 --> 00:12:32,820
a type and we'll use two of them it has

00:12:30,990 --> 00:12:35,100
to be in the header file so that we can

00:12:32,820 --> 00:12:37,950
do some compilation and I can say a

00:12:35,100 --> 00:12:40,200
vector of integers that's fine list of

00:12:37,950 --> 00:12:42,150
integers fine vector of s fine

00:12:40,200 --> 00:12:45,840
everything works fine so we start using

00:12:42,150 --> 00:12:49,770
it and then sorting vectors happens to

00:12:45,840 --> 00:12:52,250
work sorting lists doesn't work from

00:12:49,770 --> 00:12:57,240
deep down in the implementation of salt

00:12:52,250 --> 00:13:00,330
we will be told that there is an absence

00:12:57,240 --> 00:13:02,730
of a subscript or a plus or something to

00:13:00,330 --> 00:13:04,860
some type that we probably haven't heard

00:13:02,730 --> 00:13:07,860
of because it is

00:13:04,860 --> 00:13:12,000
it's an implementation detail and if you

00:13:07,860 --> 00:13:15,650
want to sort the the vector of s well

00:13:12,000 --> 00:13:18,180
because we couldn't get D for

00:13:15,650 --> 00:13:22,200
definitions of equality and less than

00:13:18,180 --> 00:13:25,080
four types your jars it'll just tell you

00:13:22,200 --> 00:13:28,520
that you can't compare two struts and

00:13:25,080 --> 00:13:31,980
the error messages are spectacularly bad

00:13:28,520 --> 00:13:35,160
this is because we have duck typing if

00:13:31,980 --> 00:13:37,520
it looks like a duck if it water will

00:13:35,160 --> 00:13:39,450
sniff it quacks it's a duck

00:13:37,520 --> 00:13:41,820
unfortunately of course it could be a

00:13:39,450 --> 00:13:44,910
rubber ducky or something like that and

00:13:41,820 --> 00:13:47,370
we get these strange errors we really

00:13:44,910 --> 00:13:52,320
want to be able to say that we want

00:13:47,370 --> 00:13:54,030
something better than just a type and on

00:13:52,320 --> 00:13:57,420
the other hand templates was a massive

00:13:54,030 --> 00:14:00,360
success it's one of the things that kept

00:13:57,420 --> 00:14:03,500
C++ going and at the edge of things we

00:14:00,360 --> 00:14:06,120
have flexibility type safety spec glass

00:14:03,500 --> 00:14:08,550
specialization for you right there are

00:14:06,120 --> 00:14:11,220
types and the basis of Merit template

00:14:08,550 --> 00:14:13,800
lot much template metaprogramming and a

00:14:11,220 --> 00:14:15,870
lot of type based optimizations the

00:14:13,800 --> 00:14:19,290
result is great flexibility great

00:14:15,870 --> 00:14:22,740
performance and has huge flaws as I

00:14:19,290 --> 00:14:25,470
pointed out the syntax I mean even its

00:14:22,740 --> 00:14:28,860
mother couldn't couldn't appreciate it

00:14:25,470 --> 00:14:31,500
doc typing error messages the

00:14:28,860 --> 00:14:35,250
overloading with templates is really

00:14:31,500 --> 00:14:39,180
quite complicated code organization gets

00:14:35,250 --> 00:14:41,970
messy and the compilers get slow very

00:14:39,180 --> 00:14:44,600
slow we have to do something about it

00:14:41,970 --> 00:14:48,660
and I would like to address all of these

00:14:44,600 --> 00:14:52,500
aspects not just fiddle with the corners

00:14:48,660 --> 00:14:55,650
of it so let's see what I want and what

00:14:52,500 --> 00:14:59,130
we are getting I would like to say that

00:14:55,650 --> 00:15:03,710
sort takes a sortable concept is a

00:14:59,130 --> 00:15:07,740
specification of what is sortable and

00:15:03,710 --> 00:15:09,600
you can look it up in the standard it

00:15:07,740 --> 00:15:13,680
says that you have to have a beginning

00:15:09,600 --> 00:15:15,400
and end you being a sequence it has to

00:15:13,680 --> 00:15:18,040
have random access and

00:15:15,400 --> 00:15:20,880
the value type the element type has to

00:15:18,040 --> 00:15:25,470
be something you can compare fine

00:15:20,880 --> 00:15:27,850
unfortunately in the previous 20 years

00:15:25,470 --> 00:15:31,450
compilers and users don't greet the

00:15:27,850 --> 00:15:35,100
manual however now we can write this so

00:15:31,450 --> 00:15:37,840
that it works I am using the concept es

00:15:35,100 --> 00:15:43,720
notation just now because then I can

00:15:37,840 --> 00:15:47,140
test my code this is not likely to

00:15:43,720 --> 00:15:50,470
become C++ 20 but it sits in that shears

00:15:47,140 --> 00:15:53,050
so if I sort a vector it matches the

00:15:50,470 --> 00:15:56,850
requirements of a vector of integers

00:15:53,050 --> 00:15:59,830
it matches the requirements of

00:15:56,850 --> 00:16:01,450
absorbable list doesn't because it

00:15:59,830 --> 00:16:04,720
doesn't have a subscript doesn't have

00:16:01,450 --> 00:16:07,540
random access and sort of the esses

00:16:04,720 --> 00:16:13,990
doesn't because value type doesn't have

00:16:07,540 --> 00:16:17,650
the the the comparison operator so I get

00:16:13,990 --> 00:16:19,750
an error right there and it should be

00:16:17,650 --> 00:16:22,810
readable they will become even more

00:16:19,750 --> 00:16:26,410
readable over the years when when when

00:16:22,810 --> 00:16:29,800
things get tuned to to use concepts well

00:16:26,410 --> 00:16:32,260
and now can I can now sort anything

00:16:29,800 --> 00:16:34,390
that's audible and the implementation of

00:16:32,260 --> 00:16:38,590
sortable could simply be to call the old

00:16:34,390 --> 00:16:41,170
sortable and if you want to be more

00:16:38,590 --> 00:16:43,660
flexible i can say i actually would like

00:16:41,170 --> 00:16:44,770
to sort lists even though they are not

00:16:43,660 --> 00:16:47,230
solvable

00:16:44,770 --> 00:16:49,300
they don't have random access and so we

00:16:47,230 --> 00:16:51,820
just define the notion of something that

00:16:49,300 --> 00:16:54,040
lists like which has the properties of

00:16:51,820 --> 00:16:57,420
being a sequence with elements that you

00:16:54,040 --> 00:17:00,400
can compare and i can implement them by

00:16:57,420 --> 00:17:03,480
by putting them into a vector sorting

00:17:00,400 --> 00:17:05,860
them and putting them back again that's

00:17:03,480 --> 00:17:09,520
simple and quite often a reasonable

00:17:05,860 --> 00:17:14,440
people performing regulation and if we

00:17:09,520 --> 00:17:17,800
if we do this once it sees the list it

00:17:14,440 --> 00:17:21,130
will say oh I can't do the the simplest

00:17:17,800 --> 00:17:23,080
sortable but because of lack of property

00:17:21,130 --> 00:17:26,140
but I have enough properties to call the

00:17:23,080 --> 00:17:27,049
list so we'll do it so we're getting the

00:17:26,140 --> 00:17:29,059
oh loading

00:17:27,049 --> 00:17:34,299
like we got the holding for ordinary

00:17:29,059 --> 00:17:35,480
types in the in the standard language

00:17:34,299 --> 00:17:40,700
well

00:17:35,480 --> 00:17:42,799
almost 40 years ago and the the rules

00:17:40,700 --> 00:17:45,489
for loading you can look at them up a

00:17:42,799 --> 00:17:49,549
much simpler than four basic types and

00:17:45,489 --> 00:17:52,220
by the way as ranges are now coming we

00:17:49,549 --> 00:17:55,100
can simplify see why do I have to say

00:17:52,220 --> 00:17:57,619
begin and end all the time I mean one of

00:17:55,100 --> 00:17:59,720
the principles that we're trying to work

00:17:57,619 --> 00:18:01,879
towards is to make simple things symbol

00:17:59,720 --> 00:18:04,129
and the simplest case of sorting a

00:18:01,879 --> 00:18:07,340
sequence is to sort all the elements of

00:18:04,129 --> 00:18:08,960
a container anything that we just give

00:18:07,340 --> 00:18:12,200
it the whole range and it'll figure out

00:18:08,960 --> 00:18:14,690
what the details are so things things

00:18:12,200 --> 00:18:16,460
are improving notice also I didn't say

00:18:14,690 --> 00:18:20,299
what the element title of the vector is

00:18:16,460 --> 00:18:23,090
I can now deduce it we are moving ahead

00:18:20,299 --> 00:18:27,889
and it's it's getting simpler to write

00:18:23,090 --> 00:18:32,480
good code so if we look at it when I

00:18:27,889 --> 00:18:34,159
want to make ordinary code and generic

00:18:32,480 --> 00:18:36,679
code the same I have to think about

00:18:34,159 --> 00:18:40,159
types and I have to think about how

00:18:36,679 --> 00:18:42,830
concepts fits into the type system and a

00:18:40,159 --> 00:18:45,799
type basically specifies what operations

00:18:42,830 --> 00:18:48,679
I can use on an object implicitly or

00:18:45,799 --> 00:18:50,600
explicitly and it relies on function

00:18:48,679 --> 00:18:53,450
declarations and language rules to make

00:18:50,600 --> 00:18:55,789
sure this works and in addition a type

00:18:53,450 --> 00:18:59,210
specifies how an object is laid out in

00:18:55,789 --> 00:19:03,169
memory so it says what can you do to an

00:18:59,210 --> 00:19:06,440
object and how can you can you make the

00:19:03,169 --> 00:19:08,899
object a concept on the other hand

00:19:06,440 --> 00:19:13,460
basically specifies how you can use an

00:19:08,899 --> 00:19:16,009
object how implicitly or explicitly what

00:19:13,460 --> 00:19:18,769
operations you can use and that is

00:19:16,009 --> 00:19:20,869
specified in terms of something called

00:19:18,769 --> 00:19:24,320
use patterns basically expressions and

00:19:20,869 --> 00:19:28,129
it reflects the the rules of the

00:19:24,320 --> 00:19:30,710
language and it says absolutely nothing

00:19:28,129 --> 00:19:33,399
about the layout layout of the object

00:19:30,710 --> 00:19:37,580
and ideally that would be the only

00:19:33,399 --> 00:19:40,679
difference between types and concepts we

00:19:37,580 --> 00:19:43,950
are close to that so

00:19:40,679 --> 00:19:47,070
you can think about simple objects of

00:19:43,950 --> 00:19:51,389
concept concepts that only take one

00:19:47,070 --> 00:19:54,179
argument as basically something that is

00:19:51,389 --> 00:19:55,159
how to use an object as opposed to how

00:19:54,179 --> 00:19:58,769
to make it

00:19:55,159 --> 00:20:04,169
okay so here's an example types and

00:19:58,769 --> 00:20:07,799
concepts I have here a concept which is

00:20:04,169 --> 00:20:10,980
same which is that a capitalized int is

00:20:07,799 --> 00:20:15,330
really an inch and I can now start

00:20:10,980 --> 00:20:18,049
writing code with that concept so x1 it

00:20:15,330 --> 00:20:20,850
will take anything that is an int and

00:20:18,049 --> 00:20:23,970
seven is an int so it'll do it oh I

00:20:20,850 --> 00:20:27,929
could use the integer directly I can do

00:20:23,970 --> 00:20:29,970
operations and again I can say for for

00:20:27,929 --> 00:20:32,519
the capitalized int I'm saying the

00:20:29,970 --> 00:20:35,369
result must be something that isn't it

00:20:32,519 --> 00:20:39,149
and the other one it says it isn't it

00:20:35,369 --> 00:20:41,700
and I can pass arguments and I can

00:20:39,149 --> 00:20:45,299
overload on it this looks very very

00:20:41,700 --> 00:20:47,070
similar and it is deliberate I even

00:20:45,299 --> 00:20:49,950
thought of using a font that'll make it

00:20:47,070 --> 00:20:52,649
easier to tell the difference between

00:20:49,950 --> 00:20:55,379
the capitalized int and the lowercase

00:20:52,649 --> 00:21:03,299
int and decided no actually the point is

00:20:55,379 --> 00:21:07,289
they're similar the the syntax here made

00:21:03,299 --> 00:21:09,720
a movable objections and the Standards

00:21:07,289 --> 00:21:13,139
Committee so it's unlikely you will be

00:21:09,720 --> 00:21:16,499
able to say sort of sortable you will

00:21:13,139 --> 00:21:19,080
probably being able to say sort of

00:21:16,499 --> 00:21:23,210
sortable or throw stuff people seem to

00:21:19,080 --> 00:21:27,629
like that better it's it's a compromise

00:21:23,210 --> 00:21:29,580
proposed by villoputo Leinen so you can

00:21:27,629 --> 00:21:32,279
get very close to what I'm saying here

00:21:29,580 --> 00:21:37,110
one of the main reasons is a discussion

00:21:32,279 --> 00:21:40,019
is sortable of ref ref if that is a Tim

00:21:37,110 --> 00:21:44,970
if that was a concept then would be a

00:21:40,019 --> 00:21:47,549
temple let and the the the the the ref

00:21:44,970 --> 00:21:50,519
ref would be a forwarding reference if

00:21:47,549 --> 00:21:52,650
not it will be an r-value reference I

00:21:50,519 --> 00:21:56,340
have taught concepts

00:21:52,650 --> 00:21:59,280
about five years too many dozens of

00:21:56,340 --> 00:22:01,320
people talk to pee many hundreds of

00:21:59,280 --> 00:22:04,500
people I've never seen this kind of

00:22:01,320 --> 00:22:07,290
stuff in real life but that's a fact to

00:22:04,500 --> 00:22:09,930
the standards committee and I think I

00:22:07,290 --> 00:22:14,730
can live with what there is what we are

00:22:09,930 --> 00:22:16,890
likely to get so that's sort of as much

00:22:14,730 --> 00:22:19,200
as I'm going to say about what the

00:22:16,890 --> 00:22:21,690
techniques take technicalities about

00:22:19,200 --> 00:22:25,440
concepts I'm going to talk about what

00:22:21,690 --> 00:22:28,040
benefits we might get out of it by the

00:22:25,440 --> 00:22:31,080
way my section breaks has people who

00:22:28,040 --> 00:22:34,500
contributed to this Andrew Sutton there

00:22:31,080 --> 00:22:36,960
is the initial implementer of the stuff

00:22:34,500 --> 00:22:39,890
you can get in TCC now and he's worked

00:22:36,960 --> 00:22:41,160
very hard on specification and

00:22:39,890 --> 00:22:45,000
implementation

00:22:41,160 --> 00:22:50,940
so basically concept supports good

00:22:45,000 --> 00:22:54,140
design and they are doing to design

00:22:50,940 --> 00:22:57,480
using templates roughly what classes did

00:22:54,140 --> 00:22:59,850
so ordinary programming it allows us to

00:22:57,480 --> 00:23:02,970
structure our code better it allows us

00:22:59,850 --> 00:23:06,630
to think about code better if I'm going

00:23:02,970 --> 00:23:10,050
to call something with a couple of

00:23:06,630 --> 00:23:11,940
points like draw a line you can do it

00:23:10,050 --> 00:23:14,250
the old way incoming incoming incoming

00:23:11,940 --> 00:23:17,190
int and start wondering what the ins

00:23:14,250 --> 00:23:21,360
mean or you could have a point comma

00:23:17,190 --> 00:23:24,210
point or point comma box and be more

00:23:21,360 --> 00:23:27,810
specific about what design is that kind

00:23:24,210 --> 00:23:30,090
of way of changing the way you think is

00:23:27,810 --> 00:23:34,650
what we're after it it gives better

00:23:30,090 --> 00:23:36,720
reliability and better maintainability I

00:23:34,650 --> 00:23:40,050
have some practical experience with that

00:23:36,720 --> 00:23:42,990
and again for all loading that's

00:23:40,050 --> 00:23:46,500
important because overloading is the

00:23:42,990 --> 00:23:49,020
basis of generic programming if things

00:23:46,500 --> 00:23:52,230
aren't called the same when they're

00:23:49,020 --> 00:23:53,880
doing the same thing semantically two

00:23:52,230 --> 00:24:00,630
different types you can't write generic

00:23:53,880 --> 00:24:02,660
code we have to go there and so let's

00:24:00,630 --> 00:24:04,980
let's see some example here here's the

00:24:02,660 --> 00:24:06,269
classical example the slightly

00:24:04,980 --> 00:24:08,429
simplified

00:24:06,269 --> 00:24:12,239
version of advance from the standard

00:24:08,429 --> 00:24:14,669
library we can say that we if we take if

00:24:12,239 --> 00:24:17,609
we are given a forward iterator we have

00:24:14,669 --> 00:24:21,629
to do things a slow way don't don't

00:24:17,609 --> 00:24:24,179
don't don't don't go forward if I get a

00:24:21,629 --> 00:24:27,479
random access is right I can just go or

00:24:24,179 --> 00:24:31,499
there and one hop this is a very

00:24:27,479 --> 00:24:34,139
important difference and we reply we

00:24:31,499 --> 00:24:36,989
have it in the standard library now we

00:24:34,139 --> 00:24:40,379
can write it as simply as this basically

00:24:36,989 --> 00:24:46,739
give it a vector and advance is a it's a

00:24:40,379 --> 00:24:50,129
very simple operation one if if we give

00:24:46,739 --> 00:24:54,779
it a list it will be relatively slow

00:24:50,129 --> 00:24:57,570
operation om and basically getting this

00:24:54,779 --> 00:25:00,359
kind of stuff simplifies our code

00:24:57,570 --> 00:25:03,599
relative to what we have to write today

00:25:00,359 --> 00:25:06,659
and makes it much more similar to other

00:25:03,599 --> 00:25:10,469
kinds of code and note that we are not

00:25:06,659 --> 00:25:13,139
actually saying you have to write a

00:25:10,469 --> 00:25:16,979
concept hierarchy and make your code

00:25:13,139 --> 00:25:19,769
rigid and only do the things that has

00:25:16,979 --> 00:25:22,409
been pre declared to work

00:25:19,769 --> 00:25:24,959
concepts are predicates we just figure

00:25:22,409 --> 00:25:25,799
out which predicate matches the best and

00:25:24,959 --> 00:25:30,509
get on with it

00:25:25,799 --> 00:25:32,309
the code is simpler so yeah as I pointed

00:25:30,509 --> 00:25:34,289
out all loading is fundamental so

00:25:32,309 --> 00:25:37,529
generic programming the way we do it in

00:25:34,289 --> 00:25:41,820
C++ we have been using a lot of traits

00:25:37,529 --> 00:25:46,139
which can be quite complicated if you

00:25:41,820 --> 00:25:49,279
looked at code using in April if you

00:25:46,139 --> 00:25:53,479
know it can be headache-inducing and

00:25:49,279 --> 00:25:56,159
also the workarounds using these

00:25:53,479 --> 00:26:01,289
programming techniques on basically on

00:25:56,159 --> 00:26:03,529
type code the fully generic stuff it

00:26:01,289 --> 00:26:06,739
gets quite complicated and slow to

00:26:03,529 --> 00:26:12,450
compile type checking happens at the end

00:26:06,739 --> 00:26:14,579
at the very last moment and that's at

00:26:12,450 --> 00:26:17,029
least its type safe for some definition

00:26:14,579 --> 00:26:20,010
of type safety but it doesn't give the

00:26:17,029 --> 00:26:25,280
errors upfront and it gives the compile

00:26:20,010 --> 00:26:25,280
time so let's see an example

00:26:25,490 --> 00:26:31,170
conditional properties they're very

00:26:27,930 --> 00:26:34,550
widespread these days basically we want

00:26:31,170 --> 00:26:37,860
to say that something like a class

00:26:34,550 --> 00:26:42,900
offers a property if and only if another

00:26:37,860 --> 00:26:46,170
type behaves in a certain way so here is

00:26:42,900 --> 00:26:51,480
the classic pointer type

00:26:46,170 --> 00:26:53,760
you smart pointer it could be a unique

00:26:51,480 --> 00:26:54,270
point it could be a shared point or

00:26:53,760 --> 00:26:56,730
something

00:26:54,270 --> 00:27:00,260
all of them does the equivalence what

00:26:56,730 --> 00:27:07,200
you see there you have an operator

00:27:00,260 --> 00:27:12,300
dereference if and only if the the thing

00:27:07,200 --> 00:27:14,370
the element type is a class otherwise

00:27:12,300 --> 00:27:17,450
you have to dereference so that's

00:27:14,370 --> 00:27:22,020
expressed very directly you get a

00:27:17,450 --> 00:27:25,710
dereference it requires that T is a

00:27:22,020 --> 00:27:29,130
class take a more complicated example I

00:27:25,710 --> 00:27:32,370
have a class pair still borrowing

00:27:29,130 --> 00:27:35,070
examples from the standard library and

00:27:32,370 --> 00:27:37,790
still capitalizing my type so that you

00:27:35,070 --> 00:27:41,610
know it isn't really in standard library

00:27:37,790 --> 00:27:44,490
so I want to be able to make a pair out

00:27:41,610 --> 00:27:47,760
of two values and I want to make the

00:27:44,490 --> 00:27:50,970
pair out of two values if and only if

00:27:47,760 --> 00:27:54,870
each of the two values can be converted

00:27:50,970 --> 00:27:59,190
into the appropriate type of the pair

00:27:54,870 --> 00:28:02,370
and so I write this there are two

00:27:59,190 --> 00:28:03,960
element types if there types are

00:28:02,370 --> 00:28:04,950
convertible to the appropriate

00:28:03,960 --> 00:28:06,930
da-da-da-da-da

00:28:04,950 --> 00:28:09,720
in other words the code reflects very

00:28:06,930 --> 00:28:12,780
directly the way I expressed what I

00:28:09,720 --> 00:28:15,870
wanted this is this is nice

00:28:12,780 --> 00:28:18,890
it's a compare for those of you who

00:28:15,870 --> 00:28:22,640
haven't seen too much enable if code

00:28:18,890 --> 00:28:25,740
here's the simplest version of the

00:28:22,640 --> 00:28:28,690
pointer version written the old way it

00:28:25,740 --> 00:28:32,270
says that there's

00:28:28,690 --> 00:28:37,220
there's an arrow operator dereference

00:28:32,270 --> 00:28:42,590
operator if well you can see the stuff

00:28:37,220 --> 00:28:44,780
there this this is sort of painful and

00:28:42,590 --> 00:28:47,840
particular it's not universal you can't

00:28:44,780 --> 00:28:51,290
use the same technique everywhere I was

00:28:47,840 --> 00:28:55,220
thinking of showing the the payer

00:28:51,290 --> 00:28:58,550
constructor and I decided not to because

00:28:55,220 --> 00:29:00,200
I had trouble fitting it on a slide for

00:28:58,550 --> 00:29:03,490
starters there's no place in a

00:29:00,200 --> 00:29:08,740
constructor to use it in a table if

00:29:03,490 --> 00:29:13,970
secondly you have to deal with the city

00:29:08,740 --> 00:29:16,730
of situations it gets very messy concept

00:29:13,970 --> 00:29:21,410
Maps the way we think about our problems

00:29:16,730 --> 00:29:25,070
the workarounds do not so we simply cut

00:29:21,410 --> 00:29:31,910
out a part of the thought process that's

00:29:25,070 --> 00:29:36,110
good some people who has tried to use

00:29:31,910 --> 00:29:40,370
auto and fully generic stuff has find

00:29:36,110 --> 00:29:43,130
that it leads to some problems every new

00:29:40,370 --> 00:29:46,490
feature get misused and overused that's

00:29:43,130 --> 00:29:48,230
fine I love also and so does a lot of

00:29:46,490 --> 00:29:53,090
other people so it gets you all used and

00:29:48,230 --> 00:29:55,280
one thing we found was that people call

00:29:53,090 --> 00:29:58,790
a function and they put the result into

00:29:55,280 --> 00:30:01,340
Auto that's reasonable if there's

00:29:58,790 --> 00:30:03,530
generic code you don't know the exact

00:30:01,340 --> 00:30:06,440
type or you don't want to bind it to a

00:30:03,530 --> 00:30:09,020
particular type just yet so you just

00:30:06,440 --> 00:30:12,020
bring the generic code forward and you

00:30:09,020 --> 00:30:15,340
get things like foo by X or Y you put it

00:30:12,020 --> 00:30:19,670
into true to some value or some type

00:30:15,340 --> 00:30:21,950
fine except we find that the programmers

00:30:19,670 --> 00:30:24,800
keep looking into the header files and

00:30:21,950 --> 00:30:29,480
flipping forwards and backwards in the

00:30:24,800 --> 00:30:34,250
code readability is seriously decreased

00:30:29,480 --> 00:30:37,640
this becomes a bug source so the

00:30:34,250 --> 00:30:40,130
response for for now has been put a

00:30:37,640 --> 00:30:41,179
comment in every time you assign

00:30:40,130 --> 00:30:44,929
something that's not

00:30:41,179 --> 00:30:47,690
obvious really alpha type put a comment

00:30:44,929 --> 00:30:49,309
on it sure make sure you don't have to

00:30:47,690 --> 00:30:52,190
have a comment because you know make

00:30:49,309 --> 00:30:55,669
sure it makes a share pointer but a lot

00:30:52,190 --> 00:30:57,969
of cases if it goes beyond that you have

00:30:55,669 --> 00:31:01,369
to put comments in and your code gets

00:30:57,969 --> 00:31:04,070
uglier larger and comments are not

00:31:01,369 --> 00:31:06,049
always right the concept you can say

00:31:04,070 --> 00:31:09,559
well I'll take anything as long as it's

00:31:06,049 --> 00:31:13,190
an input Channel and you can do that in

00:31:09,559 --> 00:31:16,279
any context that clears our code a lot

00:31:13,190 --> 00:31:17,929
eliminates programmers flicking back and

00:31:16,279 --> 00:31:20,149
forth between different parts of the

00:31:17,929 --> 00:31:22,759
code which is very distracting and

00:31:20,149 --> 00:31:25,070
breaking concentration and you just get

00:31:22,759 --> 00:31:31,330
much better code readability is one of

00:31:25,070 --> 00:31:35,359
the benefits of concepts and then I

00:31:31,330 --> 00:31:39,349
don't know familiarity is a strong force

00:31:35,359 --> 00:31:45,349
but you look at that template there it's

00:31:39,349 --> 00:31:47,450
really quite clunky and for new things

00:31:45,349 --> 00:31:49,909
they're scary people want prefix

00:31:47,450 --> 00:31:53,029
keywords and that's how we got to here

00:31:49,909 --> 00:31:56,029
names become very important because

00:31:53,029 --> 00:31:59,450
there's not really a type system here in

00:31:56,029 --> 00:32:00,830
play that that says what the the type

00:31:59,450 --> 00:32:04,309
name really means

00:32:00,830 --> 00:32:07,879
I mean type name input iterator means I

00:32:04,309 --> 00:32:10,909
hope that the input iterator is an input

00:32:07,879 --> 00:32:13,399
iterator it's it's just a matter of hope

00:32:10,909 --> 00:32:15,619
and this was what we got out of some

00:32:13,399 --> 00:32:18,469
historical process where people were a

00:32:15,619 --> 00:32:23,529
bit panicked or templates they were very

00:32:18,469 --> 00:32:28,519
new at the time when we can be specific

00:32:23,529 --> 00:32:32,570
things get far more readable the the

00:32:28,519 --> 00:32:35,839
version of there is slightly longer but

00:32:32,570 --> 00:32:39,649
it says much more it says I'm going to

00:32:35,839 --> 00:32:41,899
get an input iterator now take any I'll

00:32:39,649 --> 00:32:45,529
compare and I'll take any other type as

00:32:41,899 --> 00:32:49,369
long as it in equality comparable with

00:32:45,529 --> 00:32:51,259
the value type let's see do I I don't

00:32:49,369 --> 00:32:52,969
have a definition of value type there

00:32:51,259 --> 00:32:53,420
but that's the one that looks in and

00:32:52,969 --> 00:32:55,790
fine

00:32:53,420 --> 00:33:00,290
what the value type is the element type

00:32:55,790 --> 00:33:02,960
and with Auto on type name we have two

00:33:00,290 --> 00:33:05,450
so to read the implementation again

00:33:02,960 --> 00:33:10,010
we are back to the sort of the key and

00:33:05,450 --> 00:33:13,280
our style of C declarations that there's

00:33:10,010 --> 00:33:15,200
simply not information enough and here

00:33:13,280 --> 00:33:16,670
that people who look at the top and says

00:33:15,200 --> 00:33:21,920
ooh that's complicated

00:33:16,670 --> 00:33:25,310
it isn't really it's just unfamiliar for

00:33:21,920 --> 00:33:31,840
a day or two I I know from students that

00:33:25,310 --> 00:33:35,530
on day two they wouldn't go back and so

00:33:31,840 --> 00:33:38,450
oops I'm going the wrong way here

00:33:35,530 --> 00:33:41,150
sequences are expressed as pairs of

00:33:38,450 --> 00:33:43,640
iterators we are going to move forward

00:33:41,150 --> 00:33:45,170
we're going to get the range TS so we

00:33:43,640 --> 00:33:47,750
can stay instead of saying there's a

00:33:45,170 --> 00:33:51,050
pair of iterators we can say I want a

00:33:47,750 --> 00:33:54,560
range however I expressed and you you

00:33:51,050 --> 00:33:56,510
get to the lower version there it's

00:33:54,560 --> 00:33:59,090
important that we are now moving from

00:33:56,510 --> 00:34:05,030
the sort of language experimentation to

00:33:59,090 --> 00:34:07,720
the supported use of things with with us

00:34:05,030 --> 00:34:12,429
with standard library support and such

00:34:07,720 --> 00:34:15,710
and by the way don't expect optimal

00:34:12,429 --> 00:34:17,990
reliable readability from older code

00:34:15,710 --> 00:34:21,290
that has been Bach compatibly moved

00:34:17,990 --> 00:34:24,380
forward to use concepts and don't expect

00:34:21,290 --> 00:34:26,720
the most readability to come from the

00:34:24,380 --> 00:34:28,940
deep foundation libraries that has to

00:34:26,720 --> 00:34:32,179
have the ultimate flexibility I have

00:34:28,940 --> 00:34:35,090
observed that the most benefits from

00:34:32,179 --> 00:34:37,790
really readability actually comes from

00:34:35,090 --> 00:34:39,950
relatively simple and relatively new

00:34:37,790 --> 00:34:42,830
libraries written by people who

00:34:39,950 --> 00:34:45,740
understand concepts as opposed to people

00:34:42,830 --> 00:34:49,970
who understood the old techniques very

00:34:45,740 --> 00:34:54,140
well and replicates them using concepts

00:34:49,970 --> 00:34:57,500
so we still have a ways to go to

00:34:54,140 --> 00:35:00,140
overcome the ways of old thing that

00:34:57,500 --> 00:35:02,670
leaves the complexity in place expressed

00:35:00,140 --> 00:35:07,500
with the new facilities

00:35:02,670 --> 00:35:10,830
so again back to this notion that also

00:35:07,500 --> 00:35:15,870
and type name gives is the weakest form

00:35:10,830 --> 00:35:19,440
of typing simply says it's a type in in

00:35:15,870 --> 00:35:21,360
in theory we could actually do without

00:35:19,440 --> 00:35:25,190
having Auto in the language

00:35:21,360 --> 00:35:27,720
look at that concept their capital Auto

00:35:25,190 --> 00:35:31,920
that's the way we could do it if we

00:35:27,720 --> 00:35:34,860
started designing C++ today quite likely

00:35:31,920 --> 00:35:39,300
the building feature auto could be

00:35:34,860 --> 00:35:41,370
eliminated and my aim is that you would

00:35:39,300 --> 00:35:44,220
accept the constants you can accept the

00:35:41,370 --> 00:35:46,980
concept wherever also is now that's

00:35:44,220 --> 00:35:51,330
backwards I really would like to use the

00:35:46,980 --> 00:35:53,640
fully generic concept also if and only

00:35:51,330 --> 00:35:55,530
if there isn't a more precise way of

00:35:53,640 --> 00:35:59,160
stating what I'm trying to state and

00:35:55,530 --> 00:36:01,410
that's not so good and again this this

00:35:59,160 --> 00:36:04,140
has been around for a while I proposed

00:36:01,410 --> 00:36:07,890
Auto F of auto in the Standards

00:36:04,140 --> 00:36:14,820
Committee in 2003 and the screams of

00:36:07,890 --> 00:36:19,230
horror were rather loud basically in C++

00:36:14,820 --> 00:36:24,840
we tend to rely on types and find things

00:36:19,230 --> 00:36:28,440
like void star and sort of suspect it's

00:36:24,840 --> 00:36:31,530
a code smell and I think we will get to

00:36:28,440 --> 00:36:35,670
the point where we think the type name

00:36:31,530 --> 00:36:37,710
and also will be will a code smell that

00:36:35,670 --> 00:36:40,260
if if they're there somebody hasn't

00:36:37,710 --> 00:36:44,130
thought it through there at least if you

00:36:40,260 --> 00:36:46,620
have an auto or type name at T the obeah

00:36:44,130 --> 00:36:49,410
requires clause coming later to see what

00:36:46,620 --> 00:36:51,570
it means but what we really need to get

00:36:49,410 --> 00:36:54,090
away from this fairly primitive thinking

00:36:51,570 --> 00:36:56,370
that we take a type and we do anything

00:36:54,090 --> 00:36:58,950
something with it and we try and write

00:36:56,370 --> 00:37:02,820
code that doesn't work if you get

00:36:58,950 --> 00:37:04,710
something that is slightly wrong and we

00:37:02,820 --> 00:37:07,350
anyway it gets complicated

00:37:04,710 --> 00:37:09,900
so concept will change the way we think

00:37:07,350 --> 00:37:12,060
about it it's not just a hope it's what

00:37:09,900 --> 00:37:13,560
I have observed again and again with

00:37:12,060 --> 00:37:14,460
people who have learnt this kind of

00:37:13,560 --> 00:37:17,010
stuff

00:37:14,460 --> 00:37:19,170
and this is not just support for

00:37:17,010 --> 00:37:22,650
business as usual this is major it

00:37:19,170 --> 00:37:24,960
changes the way we think as a as a

00:37:22,650 --> 00:37:29,490
thinker said I'm not keen on individual

00:37:24,960 --> 00:37:31,829
language feature talks and details talk

00:37:29,490 --> 00:37:35,339
this is not a detail this changes the

00:37:31,829 --> 00:37:38,609
foundation and the community as a whole

00:37:35,339 --> 00:37:41,160
is going to be slow as usual it takes a

00:37:38,609 --> 00:37:43,140
long long time to get millions of people

00:37:41,160 --> 00:37:44,880
to change their mind about anything and

00:37:43,140 --> 00:37:47,550
there are people who will never change

00:37:44,880 --> 00:37:50,670
their mind but individual can do much

00:37:47,550 --> 00:37:52,680
better so even if we can't get

00:37:50,670 --> 00:37:55,530
everything we want in all the code now

00:37:52,680 --> 00:37:57,780
maybe you can do better in your local

00:37:55,530 --> 00:38:00,000
code and maybe you can start

00:37:57,780 --> 00:38:02,609
experimenting even if you can't deploy

00:38:00,000 --> 00:38:05,670
it yet that that's what I and others

00:38:02,609 --> 00:38:08,940
started doing a few years ago it works

00:38:05,670 --> 00:38:11,880
first experiment figure out what works

00:38:08,940 --> 00:38:15,150
in your context move on and it can get

00:38:11,880 --> 00:38:19,140
to the production level GCC has pretty

00:38:15,150 --> 00:38:20,130
good support for concepts clang is

00:38:19,140 --> 00:38:22,680
coming

00:38:20,130 --> 00:38:24,869
I believe Microsoft is thinking hard

00:38:22,680 --> 00:38:27,000
about it and it's not really that hard

00:38:24,869 --> 00:38:30,690
to implement once you once you get going

00:38:27,000 --> 00:38:34,380
and the standard library has it so come

00:38:30,690 --> 00:38:36,450
C++ 20 we should all be there so it's

00:38:34,380 --> 00:38:39,150
time to get ready

00:38:36,450 --> 00:38:41,670
concepts weren't born yesterday there's

00:38:39,150 --> 00:38:44,819
a lot of people says oh it's new it's

00:38:41,670 --> 00:38:48,359
it's dangerous or as opposed to oh it's

00:38:44,819 --> 00:38:50,880
new it's great or it's new it's really

00:38:48,359 --> 00:38:52,319
should have been something else no it

00:38:50,880 --> 00:38:54,630
shouldn't have been something else we

00:38:52,319 --> 00:38:59,670
have spent a lot of time figuring out

00:38:54,630 --> 00:39:04,950
what fits with C++ and how to work it in

00:38:59,670 --> 00:39:08,099
how to work the details Alex started in

00:39:04,950 --> 00:39:11,609
81 called algebraic structures and then

00:39:08,099 --> 00:39:15,059
he's been calling them concepts since

00:39:11,609 --> 00:39:19,619
somewhere in the 90s early 90s I think

00:39:15,059 --> 00:39:22,290
no no no no late ages and I tried to

00:39:19,619 --> 00:39:26,099
find a way of constraining templates in

00:39:22,290 --> 00:39:27,060
88 it failed and either I know anybody

00:39:26,099 --> 00:39:29,280
else

00:39:27,060 --> 00:39:33,990
how to get all three properties I wanted

00:39:29,280 --> 00:39:36,720
but we have it oh the STL is specified

00:39:33,990 --> 00:39:38,670
in terms of concepts even though there's

00:39:36,720 --> 00:39:40,560
no language support for it it's a

00:39:38,670 --> 00:39:43,700
fundament way of thinking and therefore

00:39:40,560 --> 00:39:46,440
it makes sense to talk about concepts

00:39:43,700 --> 00:39:48,690
even if there's no language support for

00:39:46,440 --> 00:39:50,850
it and then there's a lot of history

00:39:48,690 --> 00:39:53,700
here I'm not going to go into it that's

00:39:50,850 --> 00:39:55,290
a different talk but don't think it's

00:39:53,700 --> 00:39:59,250
something new or something totally

00:39:55,290 --> 00:40:03,480
malleable good people have worked hard

00:39:59,250 --> 00:40:05,940
on this stuff especially him okay

00:40:03,480 --> 00:40:08,520
I haven't actually said that much about

00:40:05,940 --> 00:40:12,360
what is the concept and how I know I

00:40:08,520 --> 00:40:15,090
should and Alex is competent concepts

00:40:12,360 --> 00:40:17,160
are all about semantics this might

00:40:15,090 --> 00:40:19,980
surprise you because there's no semantic

00:40:17,160 --> 00:40:22,950
part to the language support however it

00:40:19,980 --> 00:40:25,740
says what kind of properties a type must

00:40:22,950 --> 00:40:27,840
have how can you use it and you have to

00:40:25,740 --> 00:40:29,760
think about what that means what what

00:40:27,840 --> 00:40:33,300
what what makes sense

00:40:29,760 --> 00:40:36,090
so basically come technically concepts

00:40:33,300 --> 00:40:39,630
are compile-time predicates for dinner a

00:40:36,090 --> 00:40:42,480
dirty it's true if T is a forward

00:40:39,630 --> 00:40:46,950
iterator and it is false otherwise and

00:40:42,480 --> 00:40:48,750
that can be used in the in the language

00:40:46,950 --> 00:40:51,450
and the language rules that that's the

00:40:48,750 --> 00:40:53,280
idea what a forward iterator is we can

00:40:51,450 --> 00:40:55,200
define somewhere else

00:40:53,280 --> 00:40:57,960
we know what it is we can look it up in

00:40:55,200 --> 00:40:59,930
the in the standard and concepts are

00:40:57,960 --> 00:41:04,830
fundamental they tend to represent

00:40:59,930 --> 00:41:06,930
fundamental concepts of our domains so

00:41:04,830 --> 00:41:09,510
if you you're mathematically inclined

00:41:06,930 --> 00:41:13,500
you have concepts like mono a group

00:41:09,510 --> 00:41:15,600
field and ring in in C++ we have input

00:41:13,500 --> 00:41:18,150
either rate of or iterator by

00:41:15,600 --> 00:41:21,870
directional iterator random access

00:41:18,150 --> 00:41:24,210
operators these are there today we just

00:41:21,870 --> 00:41:30,330
have to represent them with stand with

00:41:24,210 --> 00:41:33,570
with with language support and so we've

00:41:30,330 --> 00:41:35,790
always had concepts I mean you read K

00:41:33,570 --> 00:41:38,280
NRC the first definition says an

00:41:35,790 --> 00:41:39,750
integral type is an integer type is

00:41:38,280 --> 00:41:42,570
these are

00:41:39,750 --> 00:41:45,660
concepts now today we can actually

00:41:42,570 --> 00:41:48,480
represent that in in C++ but we've been

00:41:45,660 --> 00:41:55,680
using that for some definition of we for

00:41:48,480 --> 00:41:57,870
more than 40 years and we yes we have

00:41:55,680 --> 00:42:00,890
direct language support so this is

00:41:57,870 --> 00:42:06,870
philosophy you have played so this is

00:42:00,890 --> 00:42:10,140
this is the engineering you Archimedes

00:42:06,870 --> 00:42:13,050
he's an engineer and we must learn to

00:42:10,140 --> 00:42:15,720
use the techniques well not just

00:42:13,050 --> 00:42:19,800
philosophy but but actually practical

00:42:15,720 --> 00:42:23,750
use and practical support and the

00:42:19,800 --> 00:42:26,850
concept is good if it represents

00:42:23,750 --> 00:42:28,290
well-thought-out concepts it is not the

00:42:26,850 --> 00:42:30,000
minimum requirement for an

00:42:28,290 --> 00:42:32,340
implementation we've been spending some

00:42:30,000 --> 00:42:34,920
time doing lifting and trying to find

00:42:32,340 --> 00:42:37,310
the absolute minimal requirements of an

00:42:34,920 --> 00:42:41,370
algorithm that's not it

00:42:37,310 --> 00:42:43,680
the at the ability to to add things is

00:42:41,370 --> 00:42:46,710
not a fundamental thing for a large

00:42:43,680 --> 00:42:51,390
group of things the ability to use plus

00:42:46,710 --> 00:42:55,590
plus is not you need something more well

00:42:51,390 --> 00:42:58,200
thought out and there's no semantics to

00:42:55,590 --> 00:43:01,110
an individual operation but there is a

00:42:58,200 --> 00:43:05,450
semantics to a combination of operations

00:43:01,110 --> 00:43:07,620
like plus minus multiply and divide and

00:43:05,450 --> 00:43:16,620
good concept should support

00:43:07,620 --> 00:43:19,530
interoperability so hmm okay a lot of

00:43:16,620 --> 00:43:23,640
people think about concepts as types of

00:43:19,530 --> 00:43:25,530
types and that's that's not it you don't

00:43:23,640 --> 00:43:27,870
do too much harm thinking about a

00:43:25,530 --> 00:43:31,710
concept that takes a single argument as

00:43:27,870 --> 00:43:34,170
a type of a type however most concepts

00:43:31,710 --> 00:43:37,370
take more than one argument if you have

00:43:34,170 --> 00:43:40,530
a template that takes two type arguments

00:43:37,370 --> 00:43:43,020
almost by definition there will be some

00:43:40,530 --> 00:43:45,600
relationship between those two type

00:43:43,020 --> 00:43:48,000
arguments why else are these higher type

00:43:45,600 --> 00:43:50,520
arguments to the same function to same

00:43:48,000 --> 00:43:53,609
algorithm there has to be a relation you

00:43:50,520 --> 00:43:59,720
using them in combination the second you

00:43:53,609 --> 00:44:02,940
two arguments of different types you

00:43:59,720 --> 00:44:06,960
need a concept with two arguments and

00:44:02,940 --> 00:44:10,859
you're out of the type of type world the

00:44:06,960 --> 00:44:14,190
other thing is that like templates

00:44:10,859 --> 00:44:16,499
concept can take value arguments it's

00:44:14,190 --> 00:44:20,910
not that common just now but since we

00:44:16,499 --> 00:44:25,440
now have value arguments of different

00:44:20,910 --> 00:44:29,249
types in C++ 1720 it'll become more

00:44:25,440 --> 00:44:35,249
common so some of the arc concepts takes

00:44:29,249 --> 00:44:38,190
things like type and and the value this

00:44:35,249 --> 00:44:40,710
is not type of type kind of stuff and if

00:44:38,190 --> 00:44:42,779
you look at it that means that concepts

00:44:40,710 --> 00:44:46,430
are not type classes and they were not

00:44:42,779 --> 00:44:49,849
meant to be type classes it's posed to

00:44:46,430 --> 00:44:53,700
you they give you implicit conversions

00:44:49,849 --> 00:44:57,599
mixed type operations which people have

00:44:53,700 --> 00:44:59,880
insisted on since Fortran and that type

00:44:57,599 --> 00:45:03,269
theorists have disliked since about the

00:44:59,880 --> 00:45:07,739
same time but this C++ we have to serve

00:45:03,269 --> 00:45:11,160
the C++ styles of uses and C++ users

00:45:07,739 --> 00:45:13,829
they are not deterred expressed in terms

00:45:11,160 --> 00:45:17,999
of sets of functions either

00:45:13,829 --> 00:45:19,829
we tried that it didn't scale so one

00:45:17,999 --> 00:45:22,130
thing to remember when you define

00:45:19,829 --> 00:45:26,039
concept when you think about concepts is

00:45:22,130 --> 00:45:29,369
describe the concept for clusters of

00:45:26,039 --> 00:45:31,829
operations I mean plus minus multiply

00:45:29,369 --> 00:45:34,650
divide and then you also probably need

00:45:31,829 --> 00:45:38,640
plus equals minus equal to plus plus and

00:45:34,650 --> 00:45:43,730
such for stacks you have push and pop

00:45:38,640 --> 00:45:47,339
and very rarely does a concept

00:45:43,730 --> 00:45:50,309
characterize a single operation has plus

00:45:47,339 --> 00:45:53,910
and has minus a very suspect when you

00:45:50,309 --> 00:45:57,989
see them as as concepts because they

00:45:53,910 --> 00:46:00,230
don't actually work in in lots of places

00:45:57,989 --> 00:46:03,630
and they they're used for ad hoc

00:46:00,230 --> 00:46:07,880
combinations of features and you get a

00:46:03,630 --> 00:46:10,220
set of concept of operations that does

00:46:07,880 --> 00:46:12,950
actually interoperate so you have to

00:46:10,220 --> 00:46:15,500
think about that here's a plug-and-play

00:46:12,950 --> 00:46:19,009
example I wrote a simple implementation

00:46:15,500 --> 00:46:21,289
of a some could have been going up in

00:46:19,009 --> 00:46:25,880
accumulate or something but I wrote it

00:46:21,289 --> 00:46:29,839
in terms of plus equals if I did the

00:46:25,880 --> 00:46:33,670
minimal dependency on that I would have

00:46:29,839 --> 00:46:36,829
a dependency on a plus equalization a

00:46:33,670 --> 00:46:38,990
plus equal about something like that B

00:46:36,829 --> 00:46:41,960
way of the dreaded ables if your tie if

00:46:38,990 --> 00:46:44,210
your types have an able at the end think

00:46:41,960 --> 00:46:47,960
a little bit harder there are useful

00:46:44,210 --> 00:46:51,619
concepts that is named like that but

00:46:47,960 --> 00:46:57,099
most of them are so basically when I

00:46:51,619 --> 00:46:59,990
wanted assistant constraint for that

00:46:57,099 --> 00:47:02,019
algorithm there I have to think how else

00:46:59,990 --> 00:47:05,390
might I have expressed that algorithm

00:47:02,019 --> 00:47:08,500
should I just take plus equal or should

00:47:05,390 --> 00:47:12,500
I take plus equals and plus an equals

00:47:08,500 --> 00:47:14,809
basically some kind of number is a

00:47:12,500 --> 00:47:17,900
better answer because you actually also

00:47:14,809 --> 00:47:19,700
want to have copyable on movable things

00:47:17,900 --> 00:47:22,279
you didn't think about just when you

00:47:19,700 --> 00:47:24,980
were doing it so want to express the

00:47:22,279 --> 00:47:28,279
concept you have to raise the level of

00:47:24,980 --> 00:47:32,569
discourse to something that makes sense

00:47:28,279 --> 00:47:35,000
basically in isolation what is it that

00:47:32,569 --> 00:47:36,859
I'm really relying on what is the

00:47:35,000 --> 00:47:39,920
fundamental concept we're doing with

00:47:36,859 --> 00:47:44,660
here it's at least number and additive

00:47:39,920 --> 00:47:46,759
mono it put out say a number and it's

00:47:44,660 --> 00:47:50,410
not just for algorithms here's a piece

00:47:46,759 --> 00:47:54,559
of code which happens to be a very minor

00:47:50,410 --> 00:47:56,539
simplification of some real code it is

00:47:54,559 --> 00:47:58,059
an input channel it takes some transport

00:47:56,539 --> 00:48:01,250
in a message decoder

00:47:58,059 --> 00:48:04,099
what's an input transport well as

00:48:01,250 --> 00:48:06,259
concept that says what it is and what's

00:48:04,099 --> 00:48:09,019
a message decoder there's a concept that

00:48:06,259 --> 00:48:11,509
says what it is basically saying what

00:48:09,019 --> 00:48:15,740
you can do to them and then you build up

00:48:11,509 --> 00:48:20,230
some context and then you have a very

00:48:15,740 --> 00:48:23,770
attic very attic template here that

00:48:20,230 --> 00:48:29,109
is used to initialize the representation

00:48:23,770 --> 00:48:32,080
of the transport this kind of stuff is

00:48:29,109 --> 00:48:35,320
really quite hard to to write and

00:48:32,080 --> 00:48:41,859
understand and it's really hard to

00:48:35,320 --> 00:48:45,090
explain to new developers unless you

00:48:41,859 --> 00:48:49,420
have the the the conceptual framework

00:48:45,090 --> 00:48:51,130
provided by the concepts that also gives

00:48:49,420 --> 00:48:53,440
you the error handling if people

00:48:51,130 --> 00:48:57,340
misunderstand this kind of stuff so you

00:48:53,440 --> 00:49:01,450
can build it use it for for for for

00:48:57,340 --> 00:49:04,840
large frameworks let's see how do we

00:49:01,450 --> 00:49:07,930
define concepts as cavitus race who work

00:49:04,840 --> 00:49:11,290
with me and others for many many years

00:49:07,930 --> 00:49:16,480
are for for building up this kind of

00:49:11,290 --> 00:49:18,700
stuff if you are going to use some

00:49:16,480 --> 00:49:21,010
concepts obviously the first choice is

00:49:18,700 --> 00:49:24,580
to find some concepts that somebody else

00:49:21,010 --> 00:49:27,130
has built I have a slide of some sources

00:49:24,580 --> 00:49:30,310
but basically the range library and the

00:49:27,130 --> 00:49:32,590
working period standard has examples but

00:49:30,310 --> 00:49:34,960
if you have to build your own one the

00:49:32,590 --> 00:49:37,630
best thing to say is that you can build

00:49:34,960 --> 00:49:41,619
it out of existing things so I talked

00:49:37,630 --> 00:49:43,690
about sortable a type T is sortable if

00:49:41,619 --> 00:49:46,600
it is a sequence meaning it has begin

00:49:43,690 --> 00:49:49,600
and end has random access means you can

00:49:46,600 --> 00:49:52,450
subscript an ad and this value type is

00:49:49,600 --> 00:49:55,119
comparable it has the operations there

00:49:52,450 --> 00:49:57,850
this is not brain surgery this is not

00:49:55,119 --> 00:49:59,710
rocket science though I'm sure we're

00:49:57,850 --> 00:50:03,880
going to use this and stuff for brain

00:49:59,710 --> 00:50:06,820
surgery and rockets but but this really

00:50:03,880 --> 00:50:09,580
is just a notation for the way we talk

00:50:06,820 --> 00:50:12,880
about these things we have hit some

00:50:09,580 --> 00:50:14,740
fundamental top concepts and it becomes

00:50:12,880 --> 00:50:17,500
easy to talk about them easy to write

00:50:14,740 --> 00:50:23,380
them down if you go down and want to

00:50:17,500 --> 00:50:27,730
define some of the simpler concepts

00:50:23,380 --> 00:50:31,510
directly instead of using things done by

00:50:27,730 --> 00:50:33,950
others like in every other area you you

00:50:31,510 --> 00:50:35,990
get to more complication

00:50:33,950 --> 00:50:39,530
and more trickery it's easy to say

00:50:35,990 --> 00:50:41,599
square root of qu but if you're going to

00:50:39,530 --> 00:50:43,640
write a square root you have to know a

00:50:41,599 --> 00:50:45,770
little bit more are you going to use

00:50:43,640 --> 00:50:47,930
Newton grab some and how do you express

00:50:45,770 --> 00:50:49,520
it and it's a better algorithm the

00:50:47,930 --> 00:50:51,710
minute you go down one level of

00:50:49,520 --> 00:50:54,619
abstraction things gets more complicated

00:50:51,710 --> 00:50:56,720
sometimes very much more complicated but

00:50:54,619 --> 00:50:58,339
in here it's it's it's it's fairly

00:50:56,720 --> 00:51:01,660
simple

00:50:58,339 --> 00:51:05,000
I want the type to be equal to compare

00:51:01,660 --> 00:51:07,910
equality comparable comparable equals so

00:51:05,000 --> 00:51:11,030
there is a support in a language Court

00:51:07,910 --> 00:51:15,050
requires which is that it can specify

00:51:11,030 --> 00:51:19,369
what the properties of expressions are

00:51:15,050 --> 00:51:21,619
so it says that if I have two t's they

00:51:19,369 --> 00:51:24,980
have to be able to be compared to equals

00:51:21,619 --> 00:51:28,700
and non equals and both cases they have

00:51:24,980 --> 00:51:30,710
to return a bool it's again not brain

00:51:28,700 --> 00:51:35,180
surgery but it's more complicated than

00:51:30,710 --> 00:51:36,859
that and you can get to slightly more

00:51:35,180 --> 00:51:39,500
complicated things the way you get

00:51:36,859 --> 00:51:42,290
closer to the core language you have to

00:51:39,500 --> 00:51:44,450
represent the facilities of the core

00:51:42,290 --> 00:51:47,599
language a bit better so a sequence

00:51:44,450 --> 00:51:50,569
requires it has to be a value type there

00:51:47,599 --> 00:51:52,730
has to be an iterator type and I've

00:51:50,569 --> 00:51:55,490
those are things I've just defined up

00:51:52,730 --> 00:51:58,010
there and the must be a begin that gives

00:51:55,490 --> 00:52:01,760
an iterator there it is there has to be

00:51:58,010 --> 00:52:05,720
an end that gives an iterator and the

00:52:01,760 --> 00:52:08,060
input iterator sorry the iterator of T

00:52:05,720 --> 00:52:10,579
has to be an input iterator I mean it's

00:52:08,060 --> 00:52:12,800
not just returning a type called an

00:52:10,579 --> 00:52:15,310
iterator we can actually say that it is

00:52:12,800 --> 00:52:19,400
an iterator or else we're in trouble

00:52:15,310 --> 00:52:22,119
and by the way the value type of the

00:52:19,400 --> 00:52:28,849
iterator CH must be the value type of

00:52:22,119 --> 00:52:30,770
the type t44 comparable so that's one

00:52:28,849 --> 00:52:33,920
way of doing it now we're getting down

00:52:30,770 --> 00:52:37,670
to two to the level we don't usually get

00:52:33,920 --> 00:52:39,650
much deeper than this but if you look at

00:52:37,670 --> 00:52:42,410
the definition of the range library you

00:52:39,650 --> 00:52:45,020
can see that as we go down closer to the

00:52:42,410 --> 00:52:46,610
hardware two so the trickier bits in the

00:52:45,020 --> 00:52:50,420
language they get more complex

00:52:46,610 --> 00:52:53,570
if we can stay there at the top slide

00:52:50,420 --> 00:52:56,390
it's better and if we can stay out of

00:52:53,570 --> 00:52:58,730
this it's even better like our

00:52:56,390 --> 00:53:02,720
fundamental functions like square root

00:52:58,730 --> 00:53:06,050
or sort we we get them out of the

00:53:02,720 --> 00:53:08,240
library so do we get our concepts there

00:53:06,050 --> 00:53:10,970
are in the working paper a concept

00:53:08,240 --> 00:53:14,090
session which has concepts so you will

00:53:10,970 --> 00:53:15,950
never actually have to do equality

00:53:14,090 --> 00:53:19,910
comparable on such because they already

00:53:15,950 --> 00:53:25,150
understand it ranges just about anything

00:53:19,910 --> 00:53:29,030
to do with algorithms and iterators and

00:53:25,150 --> 00:53:32,120
there's more places to find them one

00:53:29,030 --> 00:53:36,830
thing to remember is I emphasize the

00:53:32,120 --> 00:53:40,580
importance of complete concept concepts

00:53:36,830 --> 00:53:42,890
with semantics make sense they are

00:53:40,580 --> 00:53:45,650
fundamental how do we get there

00:53:42,890 --> 00:53:46,430
well there are two things during

00:53:45,650 --> 00:53:48,350
development

00:53:46,430 --> 00:53:50,900
we are almost going to get it wrong the

00:53:48,350 --> 00:53:53,090
first time so we need to get there

00:53:50,900 --> 00:53:55,970
somehow secondly sometimes we need

00:53:53,090 --> 00:54:00,650
building blocks so so take an example

00:53:55,970 --> 00:54:05,540
here here is sort of an ad hoc thing it

00:54:00,650 --> 00:54:10,400
says that I requires something that you

00:54:05,540 --> 00:54:13,220
can add that's usually a mistake I

00:54:10,400 --> 00:54:15,620
consider requires requires a code smell

00:54:13,220 --> 00:54:17,980
if you see that in your code you

00:54:15,620 --> 00:54:21,920
probably haven't thought hard enough

00:54:17,980 --> 00:54:24,970
because usually when we want plus we

00:54:21,920 --> 00:54:28,730
also want these other properties like

00:54:24,970 --> 00:54:31,220
you can get a plus B but you can also

00:54:28,730 --> 00:54:33,290
increment and you can copy the thing and

00:54:31,220 --> 00:54:34,190
quite often you want to construct it

00:54:33,290 --> 00:54:39,020
from a zero

00:54:34,190 --> 00:54:43,190
things like that so if you write some in

00:54:39,020 --> 00:54:45,740
terms of a concept you can improve it as

00:54:43,190 --> 00:54:48,080
you go along this kind of requires

00:54:45,740 --> 00:54:50,960
requires which I've seen in far too much

00:54:48,080 --> 00:54:53,720
code done by people who are just coming

00:54:50,960 --> 00:54:55,850
to concepts they think well I know the

00:54:53,720 --> 00:54:58,100
syntax I can write these things just

00:54:55,850 --> 00:54:59,990
show me the syntax and I'll write you

00:54:58,100 --> 00:55:02,810
get this kind of stuff and

00:54:59,990 --> 00:55:05,540
these requirements starts growing

00:55:02,810 --> 00:55:08,420
growing growing growing and they they

00:55:05,540 --> 00:55:15,230
don't lead to interoperability because

00:55:08,420 --> 00:55:17,150
each operation is done by itself what

00:55:15,230 --> 00:55:20,630
you need to do is to think about what

00:55:17,150 --> 00:55:23,240
can you do what can you build up now

00:55:20,630 --> 00:55:26,600
arable is one of these dangerous edibles

00:55:23,240 --> 00:55:30,350
so you you think is it really what I

00:55:26,600 --> 00:55:34,160
have what don't I want a number don't

00:55:30,350 --> 00:55:35,570
know what - also if I don't want - why

00:55:34,160 --> 00:55:37,760
why don't I

00:55:35,570 --> 00:55:41,720
the minute you generalize some to

00:55:37,760 --> 00:55:44,000
accumulate you are up into the next

00:55:41,720 --> 00:55:46,340
level of abstraction where you need a

00:55:44,000 --> 00:55:51,610
proper concept to constrain what you can

00:55:46,340 --> 00:55:55,310
do there's been people complaining about

00:55:51,610 --> 00:56:00,340
you can get written accidental matches

00:55:55,310 --> 00:56:04,910
if your cat if we are calculating what

00:56:00,340 --> 00:56:07,400
use of a concept matches various

00:56:04,910 --> 00:56:09,710
concepts you can get things that that

00:56:07,400 --> 00:56:12,440
could accidentally match now picked here

00:56:09,710 --> 00:56:14,720
an example from the old days of

00:56:12,440 --> 00:56:17,950
object-oriented programming where people

00:56:14,720 --> 00:56:20,960
were worried sometimes reasonably

00:56:17,950 --> 00:56:24,290
drawable I define something drawable

00:56:20,960 --> 00:56:26,660
it's something that you can draw be

00:56:24,290 --> 00:56:29,660
suspicious it's only got one operation

00:56:26,660 --> 00:56:32,180
it's unlikely to be a good concept it

00:56:29,660 --> 00:56:34,520
may be something we did just at the

00:56:32,180 --> 00:56:38,180
beginning of a development before we

00:56:34,520 --> 00:56:40,550
knew exactly what it was but be PPP

00:56:38,180 --> 00:56:44,990
careful it's got a single operation is

00:56:40,550 --> 00:56:49,190
called able be careful anyway so we make

00:56:44,990 --> 00:56:51,710
a shape it draws make a cowboy because

00:56:49,190 --> 00:56:55,580
in the games industry the trawlers and

00:56:51,710 --> 00:56:58,190
so now we can do a draw or and it draws

00:56:55,580 --> 00:57:00,830
or now this is alright

00:56:58,190 --> 00:57:03,440
if draw is really is the shape that

00:57:00,830 --> 00:57:07,810
draws it's not so alright if it pulls a

00:57:03,440 --> 00:57:10,220
gun so that's that's an example from

00:57:07,810 --> 00:57:12,930
from the early days of object-oriented

00:57:10,220 --> 00:57:15,900
programming just translated into

00:57:12,930 --> 00:57:18,990
jump to modern terminology accidental

00:57:15,900 --> 00:57:22,320
matches can happen but really that's a

00:57:18,990 --> 00:57:27,960
bad concept it's it doesn't represent

00:57:22,320 --> 00:57:32,100
anything fundamental if you have if you

00:57:27,960 --> 00:57:34,470
have done this properly there would have

00:57:32,100 --> 00:57:36,780
been more to operations than just draw

00:57:34,470 --> 00:57:39,480
and it's unlikely the cowboy would have

00:57:36,780 --> 00:57:41,700
had the more similarly for a cowboy

00:57:39,480 --> 00:57:43,890
there would be operations that probably

00:57:41,700 --> 00:57:45,270
didn't fit with a shape like get on the

00:57:43,890 --> 00:57:48,510
horse

00:57:45,270 --> 00:57:51,420
so the accidental match can happen it

00:57:48,510 --> 00:57:53,700
definitely can classical examples input

00:57:51,420 --> 00:57:56,130
operator and forward iterator they only

00:57:53,700 --> 00:57:59,840
change in their semantics not in the set

00:57:56,130 --> 00:58:02,910
of operations and if they do you can add

00:57:59,840 --> 00:58:06,120
disambiguation operator I mean there's

00:58:02,910 --> 00:58:09,510
things that for iterator can do that

00:58:06,120 --> 00:58:11,340
input iterator is cut and I go back to

00:58:09,510 --> 00:58:14,730
the beginning operation or something

00:58:11,340 --> 00:58:17,610
like that it's not that hard or you can

00:58:14,730 --> 00:58:21,720
use a trade clasp they still have their

00:58:17,610 --> 00:58:25,500
uses but we we have the single single

00:58:21,720 --> 00:58:30,600
symbol single constraint concepts here's

00:58:25,500 --> 00:58:34,620
a thing that I found I started like a

00:58:30,600 --> 00:58:37,680
lot of people with concept like a number

00:58:34,620 --> 00:58:40,560
that had the four operations and then I

00:58:37,680 --> 00:58:43,320
realize that I needed that one then I

00:58:40,560 --> 00:58:46,170
realized I needed that one but notice

00:58:43,320 --> 00:58:49,110
one thing my initial concept the

00:58:46,170 --> 00:58:51,540
incomplete concept were useful it caught

00:58:49,110 --> 00:58:54,180
a lot of the errors and allowed me to

00:58:51,540 --> 00:58:57,690
think and I could just improve it as we

00:58:54,180 --> 00:59:01,500
went along what's missing here the fact

00:58:57,690 --> 00:59:04,110
that numbers can be copied and moved so

00:59:01,500 --> 00:59:08,090
I haven't quite gotten there yet but you

00:59:04,110 --> 00:59:11,340
develop these once at a time the

00:59:08,090 --> 00:59:14,340
refinement of concepts in our minds is a

00:59:11,340 --> 00:59:16,770
gradual process as we learn and we

00:59:14,340 --> 00:59:18,600
improve our concepts they have names so

00:59:16,770 --> 00:59:21,540
we can do it

00:59:18,600 --> 00:59:25,600
one thing that concept do not two

00:59:21,540 --> 00:59:27,670
concepts as designed force for C++ you

00:59:25,600 --> 00:59:30,640
does not catch all type errors and

00:59:27,670 --> 00:59:32,590
template definitions this this was a bit

00:59:30,640 --> 00:59:34,390
of a surprise to some of us if you read

00:59:32,590 --> 00:59:38,110
the early papers it was one of the

00:59:34,390 --> 00:59:43,180
things we wanted and we didn't get it

00:59:38,110 --> 00:59:46,630
for a variety of reasons here do we

00:59:43,180 --> 00:59:50,290
really want to catch this early so for

00:59:46,630 --> 00:59:54,310
dinner radar and it does an ad yeah it

00:59:50,290 --> 00:59:56,590
would be good if we could do it but as a

00:59:54,310 --> 00:59:58,450
matter of fact doing that puts

00:59:56,590 --> 01:00:02,980
constraints and the performance puts

00:59:58,450 --> 01:00:06,930
constraints on the compilation feature

01:00:02,980 --> 01:00:11,920
and it actually constrains things rather

01:00:06,930 --> 01:00:14,860
dramatically and this kind of error will

01:00:11,920 --> 01:00:17,350
eventually be caught but only at an

01:00:14,860 --> 01:00:20,200
instantiation time we're falling back to

01:00:17,350 --> 01:00:23,290
the bad old techniques for catching the

01:00:20,200 --> 01:00:28,900
errors on the other hand it allows us to

01:00:23,290 --> 01:00:31,840
write simple concept simply and so to

01:00:28,900 --> 01:00:35,890
have fast compilers and be very very

01:00:31,840 --> 01:00:39,120
flexible and I was look I have a set of

01:00:35,890 --> 01:00:42,310
rules that I'm following from the DNA

01:00:39,120 --> 01:00:44,740
expressed in the DNA book it's more

01:00:42,310 --> 01:00:49,470
important to allow a useful feature than

01:00:44,740 --> 01:00:52,150
to prevent every missha's so why not

01:00:49,470 --> 01:00:58,060
basically we decided when we started

01:00:52,150 --> 01:01:03,490
redesigning concepts after the C++ oh X

01:00:58,060 --> 01:01:06,940
T partly that 90% of the benefit came

01:01:03,490 --> 01:01:08,740
from use checking and we figured out how

01:01:06,940 --> 01:01:11,620
to do use checking with the current

01:01:08,740 --> 01:01:13,930
notion of syntax gap it did some

01:01:11,620 --> 01:01:17,140
experiments we know how to do it it's

01:01:13,930 --> 01:01:22,030
just we got more and more worried that

01:01:17,140 --> 01:01:25,330
we were wrong to close the system like

01:01:22,030 --> 01:01:28,990
that how do I build these since these

01:01:25,330 --> 01:01:32,440
concepts up slowly before I know all the

01:01:28,990 --> 01:01:36,580
constraints how about debug eighths

01:01:32,440 --> 01:01:39,460
how about telemetry logging

01:01:36,580 --> 01:01:41,530
if the concept has to be complete so

01:01:39,460 --> 01:01:43,450
that you can check and catch everything

01:01:41,530 --> 01:01:46,300
that you use in the implementation that

01:01:43,450 --> 01:01:48,610
you didn't mention in the interface then

01:01:46,300 --> 01:01:50,170
you have a closed system and you sort of

01:01:48,610 --> 01:01:52,570
have to reach a level of perfection

01:01:50,170 --> 01:01:56,350
before you can use it and since you

01:01:52,570 --> 01:01:59,470
don't because perfection doesn't come

01:01:56,350 --> 01:02:01,660
early you keep changing the interface

01:01:59,470 --> 01:02:05,760
you want a debugger you have to add

01:02:01,660 --> 01:02:08,530
debug ability in the interface you want

01:02:05,760 --> 01:02:10,750
statistics added to an old concept you

01:02:08,530 --> 01:02:13,870
have to add that to the interface now

01:02:10,750 --> 01:02:16,720
all the user code might break so we were

01:02:13,870 --> 01:02:19,900
beginning to get very worried about how

01:02:16,720 --> 01:02:22,750
you transfer how you do a transition

01:02:19,900 --> 01:02:25,360
from existing type the code to new code

01:02:22,750 --> 01:02:28,210
how do you use old code from new code

01:02:25,360 --> 01:02:29,890
how do you use new code from old code we

01:02:28,210 --> 01:02:32,380
decided we are not going to touch

01:02:29,890 --> 01:02:35,140
definition checking for now this

01:02:32,380 --> 01:02:38,290
actually requires serious syncing not

01:02:35,140 --> 01:02:40,660
just the fact that we know how to do it

01:02:38,290 --> 01:02:43,140
is not sufficient just because you can

01:02:40,660 --> 01:02:50,020
do something doesn't mean you have to

01:02:43,140 --> 01:02:52,630
okay you can still do some checking like

01:02:50,020 --> 01:02:55,870
static a search I want to know if my

01:02:52,630 --> 01:02:58,120
type is this matches the range concept

01:02:55,870 --> 01:03:02,950
there it is

01:02:58,120 --> 01:03:05,470
and for for testing of my algorithms I

01:03:02,950 --> 01:03:10,540
can just build what's called archetypes

01:03:05,470 --> 01:03:12,610
sort of a class called sum of X that has

01:03:10,540 --> 01:03:14,980
all the properties that I'm expecting

01:03:12,610 --> 01:03:17,260
and you feed that into a static assert

01:03:14,980 --> 01:03:19,960
with my algorithm and you see if it

01:03:17,260 --> 01:03:22,510
works the only snag is that you are

01:03:19,960 --> 01:03:24,520
likely to make the same mistakes when

01:03:22,510 --> 01:03:29,070
you are defining the architect type as

01:03:24,520 --> 01:03:33,310
you did when you defined the concepts

01:03:29,070 --> 01:03:34,780
this can be of course mitigated by

01:03:33,310 --> 01:03:37,270
having different people and borrow from

01:03:34,780 --> 01:03:41,950
such but but just because there's no

01:03:37,270 --> 01:03:43,840
default definition shaking doesn't mean

01:03:41,950 --> 01:03:46,150
that there's no checking you can do

01:03:43,840 --> 01:03:49,950
because well you can

01:03:46,150 --> 01:03:49,950
you can just see it there this works

01:03:50,730 --> 01:03:58,539
let's see we would like to use

01:03:54,730 --> 01:04:03,750
high-level concepts more often and so

01:03:58,539 --> 01:04:09,329
here's sort of a first cut on

01:04:03,750 --> 01:04:12,940
constraining merge merge is standard

01:04:09,329 --> 01:04:15,220
standard algorithm and it's it's one of

01:04:12,940 --> 01:04:17,920
the more complicated ones and so the

01:04:15,220 --> 01:04:19,990
first cut looks like this I need three

01:04:17,920 --> 01:04:21,760
types the first one is a forward

01:04:19,990 --> 01:04:24,069
iterator the segment one is afforded

01:04:21,760 --> 01:04:26,440
oreder and the third one is an output

01:04:24,069 --> 01:04:29,109
operator and you have to be able to

01:04:26,440 --> 01:04:31,599
compare and assign to all of these

01:04:29,109 --> 01:04:35,890
things this is somewhat tedious and

01:04:31,599 --> 01:04:38,140
that's what the standard says but we are

01:04:35,890 --> 01:04:42,220
doing the equivalent of sort of doing

01:04:38,140 --> 01:04:43,720
primitive operations we in real world

01:04:42,220 --> 01:04:47,140
we've learned we have to aggregate

01:04:43,720 --> 01:04:50,920
operations into functions classes and

01:04:47,140 --> 01:04:52,839
such and so this is a sort of it's easy

01:04:50,920 --> 01:04:55,720
to make a mistake when you write so much

01:04:52,839 --> 01:04:57,809
and it's hard to read one of my favorite

01:04:55,720 --> 01:05:00,730
phrases he died again using an

01:04:57,809 --> 01:05:04,539
accumulator is much worse and by the way

01:05:00,730 --> 01:05:08,740
this particular pattern appears I think

01:05:04,539 --> 01:05:12,549
four times in the standard so what we do

01:05:08,740 --> 01:05:17,130
is we design mirja ball which is the

01:05:12,549 --> 01:05:20,829
concept that requires three types and

01:05:17,130 --> 01:05:24,730
then does or the checking so we need to

01:05:20,829 --> 01:05:28,020
get away from the most simple-minded

01:05:24,730 --> 01:05:31,240
things often starting out with single

01:05:28,020 --> 01:05:33,339
single type concepts and then going into

01:05:31,240 --> 01:05:36,010
the relationship between those concepts

01:05:33,339 --> 01:05:38,980
and simply saying I want three types and

01:05:36,010 --> 01:05:42,329
they have the problem relationships

01:05:38,980 --> 01:05:46,630
among themselves for being merciful

01:05:42,329 --> 01:05:48,460
there's a more elegant way for doing

01:05:46,630 --> 01:05:51,099
that saying I want to introduce three

01:05:48,460 --> 01:05:53,950
type names and they should be mirja but

01:05:51,099 --> 01:05:56,470
that's not going to make it into C++ 20

01:05:53,950 --> 01:05:59,940
though that is my favorite for

01:05:56,470 --> 01:06:02,380
expressing this idea and

01:05:59,940 --> 01:06:05,980
basically then you just have to define

01:06:02,380 --> 01:06:10,349
merger and merger boy is the one that

01:06:05,980 --> 01:06:15,609
has the properties we require and

01:06:10,349 --> 01:06:17,740
obviously this has the point that this

01:06:15,609 --> 01:06:21,670
has the advantage that if you write your

01:06:17,740 --> 01:06:24,700
code like this you can improve that

01:06:21,670 --> 01:06:26,140
concept should go along because the

01:06:24,700 --> 01:06:31,030
first time you're not going to get it

01:06:26,140 --> 01:06:33,280
right so having it named is helpful

01:06:31,030 --> 01:06:35,619
having it in one place to fix it is

01:06:33,280 --> 01:06:37,990
helpful it is just like when you're

01:06:35,619 --> 01:06:42,039
defining functions you are defining

01:06:37,990 --> 01:06:46,450
functions so the the principles of

01:06:42,039 --> 01:06:48,460
concept design is basically think harder

01:06:46,450 --> 01:06:50,799
about the semantics think harder about

01:06:48,460 --> 01:06:52,690
the fundamental concepts this is why

01:06:50,799 --> 01:06:57,910
concepts are core concepts by the way

01:06:52,690 --> 01:06:59,950
and you have to think about what is

01:06:57,910 --> 01:07:03,490
universal what can be used in many

01:06:59,950 --> 01:07:06,460
places as opposed to ad-hoc if you find

01:07:03,490 --> 01:07:10,210
you write a lot of similar concepts and

01:07:06,460 --> 01:07:12,670
a lot of long complicated concepts like

01:07:10,210 --> 01:07:14,740
if you see something like that it's like

01:07:12,670 --> 01:07:16,869
seeing a whole lot of statements and a

01:07:14,740 --> 01:07:19,630
large function you should eventually get

01:07:16,869 --> 01:07:22,029
used to thinking that's a code smell it

01:07:19,630 --> 01:07:25,470
really are there something that you can

01:07:22,029 --> 01:07:28,720
abstract from it and build something

01:07:25,470 --> 01:07:30,849
manageable like that and you can

01:07:28,720 --> 01:07:32,559
actually predict that you're going to

01:07:30,849 --> 01:07:35,650
find in this case so it's better to

01:07:32,559 --> 01:07:38,760
introduce the name concept earlier even

01:07:35,650 --> 01:07:41,980
if you can't do all the details yet

01:07:38,760 --> 01:07:44,549
consistent set of properties you make

01:07:41,980 --> 01:07:48,069
them concrete by using concepts and

01:07:44,549 --> 01:07:52,270
basically it's much easier to think

01:07:48,069 --> 01:07:55,059
about your code in terms of concepts

01:07:52,270 --> 01:07:57,220
again and again I have said met people

01:07:55,059 --> 01:08:00,099
says well I couldn't even think of this

01:07:57,220 --> 01:08:02,109
solution without concepts just like I've

01:08:00,099 --> 01:08:04,779
met people I can't even think about this

01:08:02,109 --> 01:08:06,730
solution without classes it's it's it's

01:08:04,779 --> 01:08:10,150
a fundamental thing it helps thinking

01:08:06,730 --> 01:08:13,089
the major inspiration for a lot of this

01:08:10,150 --> 01:08:20,770
elements of programming by Steph enough

01:08:13,089 --> 01:08:25,449
and at Jones I stopped on done back us

01:08:20,770 --> 01:08:28,029
was in this picture so it's it's it's

01:08:25,449 --> 01:08:30,130
it's it's interesting he was the one

01:08:28,029 --> 01:08:33,250
that did Fortran by the way so there's a

01:08:30,130 --> 01:08:40,000
certain continuity in the programming

01:08:33,250 --> 01:08:43,359
world and so concrete suggestions make

01:08:40,000 --> 01:08:46,330
sure that you can think about the

01:08:43,359 --> 01:08:51,339
semantics when you see a concept it's

01:08:46,330 --> 01:08:53,529
expressed in terms of syntax part you

01:08:51,339 --> 01:08:55,960
should be able to think about it as

01:08:53,529 --> 01:08:58,150
having semantics eventually we may get

01:08:55,960 --> 01:09:00,540
support for doing that that will be

01:08:58,150 --> 01:09:03,310
called actions but we are not there yet

01:09:00,540 --> 01:09:05,710
incomplete concepts are far better than

01:09:03,310 --> 01:09:08,650
no concepts and basically you tend to

01:09:05,710 --> 01:09:11,980
start thinking then you have simple

01:09:08,650 --> 01:09:14,469
concepts and let them grow later use

01:09:11,980 --> 01:09:17,259
name concept requires requires code

01:09:14,469 --> 01:09:20,230
smell you can use static a search to get

01:09:17,259 --> 01:09:23,739
upfront testing of your types and your

01:09:20,230 --> 01:09:27,130
concepts to find the algorithms in terms

01:09:23,739 --> 01:09:30,069
of general types the ideal is

01:09:27,130 --> 01:09:34,330
plug-and-play not absolute minimization

01:09:30,069 --> 01:09:37,210
and variables should be constrained with

01:09:34,330 --> 01:09:39,580
concepts so that you don't have to write

01:09:37,210 --> 01:09:43,509
in a fully functional style and you

01:09:39,580 --> 01:09:47,380
don't have to fix the type too early to

01:09:43,509 --> 01:09:52,420
be able to get readability this dis

01:09:47,380 --> 01:09:54,219
improves readability and basically for

01:09:52,420 --> 01:09:58,600
those of you who haven't already been

01:09:54,219 --> 01:10:03,420
using concepts for months or years try

01:09:58,600 --> 01:10:06,760
them I have not personally met any

01:10:03,420 --> 01:10:12,250
anybody who who tried them and went back

01:10:06,760 --> 01:10:15,040
to on typed templates because they

01:10:12,250 --> 01:10:18,520
wanted to it's quite often that you have

01:10:15,040 --> 01:10:20,989
to go back because the implementations

01:10:18,520 --> 01:10:25,730
are not universal yes

01:10:20,989 --> 01:10:27,769
and codebases cannot always be updated

01:10:25,730 --> 01:10:31,940
to the latest compiled on all of this

01:10:27,769 --> 01:10:34,400
stuff but I think it's much better if

01:10:31,940 --> 01:10:36,530
you try concepts and so for withdrawal

01:10:34,400 --> 01:10:40,249
symptoms four years after til they

01:10:36,530 --> 01:10:42,380
upgrade the compilers and the code bases

01:10:40,249 --> 01:10:44,840
that then you don't think in terms of

01:10:42,380 --> 01:10:47,389
concept because you will not go back

01:10:44,840 --> 01:10:49,760
once you have used concept you think in

01:10:47,389 --> 01:10:51,170
terms of them and it improves your code

01:10:49,760 --> 01:10:53,749
even if you don't have the language

01:10:51,170 --> 01:10:57,340
support this is the underlying argument

01:10:53,749 --> 01:10:59,749
for that why this is fundamental and

01:10:57,340 --> 01:11:02,840
part of the basic structure of the

01:10:59,749 --> 01:11:05,380
language and basically good interfaces

01:11:02,840 --> 01:11:08,719
is key to good code you can do it now

01:11:05,380 --> 01:11:11,619
you simplify the code there's a lot of

01:11:08,719 --> 01:11:14,749
complicated template metaprogramming

01:11:11,619 --> 01:11:18,499
using enable ifs that gets radically

01:11:14,749 --> 01:11:19,940
simplified by using concepts so if

01:11:18,499 --> 01:11:21,679
you're saying no no I'm not doing

01:11:19,940 --> 01:11:23,840
generic programming I'm doing template

01:11:21,679 --> 01:11:25,780
metaprogramming there's two things wrong

01:11:23,840 --> 01:11:28,309
with this one is the word template

01:11:25,780 --> 01:11:29,809
metaprogramming doesn't have to be

01:11:28,309 --> 01:11:32,510
template so anymore

01:11:29,809 --> 01:11:36,760
a lot of cons context but functions will

01:11:32,510 --> 01:11:39,710
help you secondly concepts help with

01:11:36,760 --> 01:11:42,099
template metaprogramming because not all

01:11:39,710 --> 01:11:43,280
of template metaprogramming is on J on

01:11:42,099 --> 01:11:46,010
untyped

01:11:43,280 --> 01:11:48,710
and basically the thing that people

01:11:46,010 --> 01:11:53,269
always say well you want concept because

01:11:48,710 --> 01:11:55,730
it gives better error messages no you

01:11:53,269 --> 01:11:57,860
want concepts because of all of these

01:11:55,730 --> 01:12:00,079
other things and as a side-effect you

01:11:57,860 --> 01:12:01,460
get better error messages because you

01:12:00,079 --> 01:12:03,710
have expressed your ideas more clearly

01:12:01,460 --> 01:12:06,980
so that even a compiler can understand

01:12:03,710 --> 01:12:11,449
you okay

01:12:06,980 --> 01:12:14,780
and of course fewer errors that's what I

01:12:11,449 --> 01:12:20,289
have to say so questions

01:12:14,780 --> 01:12:20,289
[Applause]

01:12:24,860 --> 01:12:35,600
do we have microphones no microphones

01:12:32,139 --> 01:13:02,449
you can probably yell loud enough for me

01:12:35,600 --> 01:13:04,699
to hear it yeah so the question is that

01:13:02,449 --> 01:13:08,840
he'd gotten the impression that concepts

01:13:04,699 --> 01:13:11,030
were there to express algebras and my

01:13:08,840 --> 01:13:13,940
examples doesn't seem to reflects that

01:13:11,030 --> 01:13:16,550
idea and and I I just think don't think

01:13:13,940 --> 01:13:18,679
that idea is correct it's not just for

01:13:16,550 --> 01:13:22,040
math it's not just for things you have

01:13:18,679 --> 01:13:24,949
an underlying theory about I showed

01:13:22,040 --> 01:13:28,610
mirabile which is part of the standard

01:13:24,949 --> 01:13:34,790
library I that's that's for an algorithm

01:13:28,610 --> 01:13:37,340
and I I showed the input channel example

01:13:34,790 --> 01:13:40,429
where we're using concepts to constrain

01:13:37,340 --> 01:13:44,780
and specify actually the types that take

01:13:40,429 --> 01:13:46,460
part of a composition of things so this

01:13:44,780 --> 01:13:48,739
was why I said it's not just for

01:13:46,460 --> 01:13:51,949
foundation libraries which a slightly

01:13:48,739 --> 01:13:54,650
stronger statement I think it becomes

01:13:51,949 --> 01:13:57,440
very very important in application

01:13:54,650 --> 01:14:00,650
programming and I've seen that again and

01:13:57,440 --> 01:14:03,020
again I've seen it in industrial code

01:14:00,650 --> 01:14:07,909
and I've seen it very often in student

01:14:03,020 --> 01:14:14,260
code very good yeah

01:14:07,909 --> 01:14:14,260
can you go back to slide 51 and just

01:14:14,800 --> 01:14:19,670
that point yeah can you help me

01:14:17,900 --> 01:14:23,420
understand what the error was that

01:14:19,670 --> 01:14:26,630
didn't get caught Oh an input iterator

01:14:23,420 --> 01:14:29,989
does not support clause it only supports

01:14:26,630 --> 01:14:32,050
plus plus so this is the kind of mistake

01:14:29,989 --> 01:14:33,849
that you can actually see in real life

01:14:32,050 --> 01:14:40,359
somebody

01:14:33,849 --> 01:14:43,929
had in their head the notion that that +

01:14:40,359 --> 01:14:45,669
1 + + + was the same thing but it so

01:14:43,929 --> 01:14:51,090
happens that that's not the way it's

01:14:45,669 --> 01:14:55,479
defined because + 1 is 2 the type system

01:14:51,090 --> 01:14:58,649
basically the same as + 20 and you don't

01:14:55,479 --> 01:15:02,709
want to be able to go 20 steps into a

01:14:58,649 --> 01:15:08,919
list because that is an O n operation

01:15:02,709 --> 01:15:12,399
and so we can't distinguish +1 from plus

01:15:08,919 --> 01:15:14,590
10 plus 10,000 and so it the library is

01:15:12,399 --> 01:15:17,739
defined like that and so this is the

01:15:14,590 --> 01:15:21,489
kind of mistake that we would sort of

01:15:17,739 --> 01:15:24,099
like to catch but the side effects of

01:15:21,489 --> 01:15:26,530
catching that kind of thing is to close

01:15:24,099 --> 01:15:28,929
the interface around algorithms so that

01:15:26,530 --> 01:15:32,409
you can't debug you can't have telemetry

01:15:28,929 --> 01:15:34,179
you can't have gradual evolution and you

01:15:32,409 --> 01:15:38,019
can't have stable interfaces so we

01:15:34,179 --> 01:15:39,939
decided that this one yeah would like to

01:15:38,019 --> 01:15:47,649
do it but we don't quite know how yet

01:15:39,939 --> 01:15:51,159
this takes more work I think now I want

01:15:47,649 --> 01:15:55,989
to say something please if I find a

01:15:51,159 --> 01:15:58,149
microphone the other two go back to the

01:15:55,989 --> 01:16:01,269
point about algebra is I think in a more

01:15:58,149 --> 01:16:03,749
general sense you do have some examples

01:16:01,269 --> 01:16:06,369
here like advanced where you're using

01:16:03,749 --> 01:16:08,800
concepts to constrain and to create an

01:16:06,369 --> 01:16:10,510
overload set you have advanced for 42

01:16:08,800 --> 01:16:13,300
red max is iterators but then you have

01:16:10,510 --> 01:16:15,129
other examples like sort which sort

01:16:13,300 --> 01:16:17,320
takes something sortable merge takes

01:16:15,129 --> 01:16:19,510
something mirja belen the standard swap

01:16:17,320 --> 01:16:21,459
takes something swappable and it's a

01:16:19,510 --> 01:16:25,599
little bit circular right in that case

01:16:21,459 --> 01:16:27,849
where we become unclear well is is it

01:16:25,599 --> 01:16:29,169
sortable because i can pass it to the

01:16:27,849 --> 01:16:31,300
standard sword or is that a

01:16:29,169 --> 01:16:32,260
customization point where someone with

01:16:31,300 --> 01:16:33,639
advanced you're using it as

01:16:32,260 --> 01:16:35,590
customization for it someone could add

01:16:33,639 --> 01:16:38,079
their own advanced that was less

01:16:35,590 --> 01:16:39,699
constrained or more constrained and it

01:16:38,079 --> 01:16:41,919
would pop into the overload set at the

01:16:39,699 --> 01:16:43,359
right point which sounds horrible but

01:16:41,919 --> 01:16:44,429
like that's the functionality you're

01:16:43,359 --> 01:16:46,020
enabling by

01:16:44,429 --> 01:16:46,890
like that as opposed to if contacts for

01:16:46,020 --> 01:16:50,250
something like that inside the

01:16:46,890 --> 01:16:51,960
implementation what sort are we using it

01:16:50,250 --> 01:16:54,270
as a customization point is that the

01:16:51,960 --> 01:16:57,570
reason for creating an overload set yeah

01:16:54,270 --> 01:17:00,870
I'm supposed to repeat questions this

01:16:57,570 --> 01:17:05,040
one is a little bit hard to repeat so

01:17:00,870 --> 01:17:07,620
I'll take it in chunks and repeat if I

01:17:05,040 --> 01:17:09,390
don't get to the real point first of all

01:17:07,620 --> 01:17:14,040
of course we can do it with our G press

01:17:09,390 --> 01:17:17,850
we've done the Mon I'd ring vector space

01:17:14,040 --> 01:17:24,360
stuff on the other hand we want the open

01:17:17,850 --> 01:17:27,989
overload that we get from from C++ from

01:17:24,360 --> 01:17:31,320
from the earliest days I want to say if

01:17:27,989 --> 01:17:34,530
I want to specify the algorithms in the

01:17:31,320 --> 01:17:36,060
standard library with concepts and once

01:17:34,530 --> 01:17:38,460
you have done them with concept you

01:17:36,060 --> 01:17:41,219
actually will be able to add your own

01:17:38,460 --> 01:17:43,140
versions to it just you can like you can

01:17:41,219 --> 01:17:45,719
add your own versions through

01:17:43,140 --> 01:17:47,429
overloading or if you're doing up to

01:17:45,719 --> 01:17:54,390
tour and hierarchies you can add your

01:17:47,429 --> 01:17:57,530
own versions by by by by derivation now

01:17:54,390 --> 01:18:03,449
some people call that ad hoc and

01:17:57,530 --> 01:18:04,949
definitely meant to support that also in

01:18:03,449 --> 01:18:07,170
that case with sort

01:18:04,949 --> 01:18:09,060
you're saying someone could add a more

01:18:07,170 --> 01:18:10,980
constrained sort that required sortable

01:18:09,060 --> 01:18:13,159
add also something else and that's what

01:18:10,980 --> 01:18:16,920
we get picked sure then you've got it I

01:18:13,159 --> 01:18:21,900
can use it both to get a more

01:18:16,920 --> 01:18:28,110
constrained version so if you wanted a s

01:18:21,900 --> 01:18:30,480
or Apple that also could do fubar

01:18:28,110 --> 01:18:34,440
whatever it is you would simply take

01:18:30,480 --> 01:18:37,530
sort saw horrible and and fubar so you

01:18:34,440 --> 01:18:39,810
can so you can get a narrower version a

01:18:37,530 --> 01:18:41,760
more constrained version as opposed to

01:18:39,810 --> 01:18:43,949
what I was doing was I was opening up

01:18:41,760 --> 01:18:48,929
how do you sort when you don't have all

01:18:43,949 --> 01:18:51,960
the properties you can do both I'm going

01:18:48,929 --> 01:18:56,400
for flexibility here not not not for any

01:18:51,960 --> 01:18:57,739
particular theory and in some sense any

01:18:56,400 --> 01:19:01,189
concept

01:18:57,739 --> 01:19:08,059
in any algorithm can be more or less

01:19:01,189 --> 01:19:10,670
constrained I so I've seen in the

01:19:08,059 --> 01:19:13,159
examples of a scene so far mostly just

01:19:10,670 --> 01:19:15,469
checks for existence of operations on

01:19:13,159 --> 01:19:17,329
types which is kind of something that we

01:19:15,469 --> 01:19:20,090
have been able to do before

01:19:17,329 --> 01:19:21,889
with enable if it's tough why does it

01:19:20,090 --> 01:19:25,360
stop there and I'll go further and also

01:19:21,889 --> 01:19:28,849
check between relations of operations

01:19:25,360 --> 01:19:32,209
for example for the concept equality

01:19:28,849 --> 01:19:34,429
comparable it's not just enough to check

01:19:32,209 --> 01:19:38,439
that there is the operation equal and

01:19:34,429 --> 01:19:43,789
unequal but also they should return the

01:19:38,439 --> 01:19:48,050
opposing value hey I think there are two

01:19:43,789 --> 01:19:51,469
questions here the second one is why

01:19:48,050 --> 01:19:54,979
can't we take the C semantic connections

01:19:51,469 --> 01:19:58,849
between the functions of a concept we

01:19:54,979 --> 01:20:02,059
had a design for that for C++ or ex

01:19:58,849 --> 01:20:04,999
corde actions which I actually think is

01:20:02,059 --> 01:20:07,369
very good and could do exactly that it

01:20:04,999 --> 01:20:14,630
expresses relationship between two

01:20:07,369 --> 01:20:17,479
operations and we just didn't think we

01:20:14,630 --> 01:20:20,989
could get that done now and we didn't

01:20:17,479 --> 01:20:23,539
want to complete the to come complicate

01:20:20,989 --> 01:20:25,459
the process through acceptance in the

01:20:23,539 --> 01:20:30,139
Standards Committee by throwing in more

01:20:25,459 --> 01:20:32,380
features is that is that where contracts

01:20:30,139 --> 01:20:38,599
could come in I mean no it's not

01:20:32,380 --> 01:20:41,689
contracts work on values concept works

01:20:38,599 --> 01:20:47,179
on types and it is still the type

01:20:41,689 --> 01:20:51,070
relations between between the operations

01:20:47,179 --> 01:20:54,340
that we would be able to handle with

01:20:51,070 --> 01:20:56,479
with with concepts and with actions

01:20:54,340 --> 01:21:01,429
there was a first part of your question

01:20:56,479 --> 01:21:05,619
that I don't think I answered I think

01:21:01,429 --> 01:21:05,619
I'm answered okay thank you

01:21:10,219 --> 01:21:16,099
I'm thinking about the operators which

01:21:13,010 --> 01:21:17,719
like plus unsigned integers which are

01:21:16,099 --> 01:21:22,849
not defined for the whole range of the

01:21:17,719 --> 01:21:27,639
thing or less than for floats right and

01:21:22,849 --> 01:21:31,599
you have the concepts which would cover

01:21:27,639 --> 01:21:36,079
these types like sortable floats right

01:21:31,599 --> 01:21:40,909
would you include lotus or table or not

01:21:36,079 --> 01:21:44,389
I would definitely consider floating

01:21:40,909 --> 01:21:49,780
point numbers horrible

01:21:44,389 --> 01:21:49,780
and I would just ignore another number

01:21:51,099 --> 01:21:56,989
there's been long long debates about

01:21:53,510 --> 01:22:01,010
this and it relates to the issue of

01:21:56,989 --> 01:22:03,530
whether concept is a type of type it is

01:22:01,010 --> 01:22:06,530
not is a requirement of what you get in

01:22:03,530 --> 01:22:10,969
and as I pointed out repeatedly it may

01:22:06,530 --> 01:22:12,949
not be the complete constraint of the

01:22:10,969 --> 01:22:16,459
implementation it is still the

01:22:12,949 --> 01:22:22,249
implementations job to know what is

01:22:16,459 --> 01:22:24,260
coming in in case a in case of a

01:22:22,249 --> 01:22:28,219
floating point number it might get in

01:22:24,260 --> 01:22:29,900
and then and it is the algorithms job to

01:22:28,219 --> 01:22:34,280
decide whether I'd wants to do anything

01:22:29,900 --> 01:22:37,130
about it right but but then you wouldn't

01:22:34,280 --> 01:22:39,260
have the same semantics for example plus

01:22:37,130 --> 01:22:41,659
plus it has not the same semantics

01:22:39,260 --> 01:22:44,599
between instant loads right so if you

01:22:41,659 --> 01:22:47,269
have a number that is not actually a

01:22:44,599 --> 01:22:50,659
number do you want me to also chip sorry

01:22:47,269 --> 01:22:53,119
do you want me to also check for flow

01:22:50,659 --> 01:22:55,280
and underflow and and everything that is

01:22:53,119 --> 01:22:58,249
actually hard it's very hard

01:22:55,280 --> 01:23:00,919
checking for not in number is very hard

01:22:58,249 --> 01:23:04,699
checking for another number only when

01:23:00,919 --> 01:23:08,719
you've got a floating point type is very

01:23:04,699 --> 01:23:12,139
hard if I was going to work things out

01:23:08,719 --> 01:23:15,610
for a small example I might consider it

01:23:12,139 --> 01:23:20,209
but I think it's a wrong approach for

01:23:15,610 --> 01:23:23,950
real-world scalable code yeah but that

01:23:20,209 --> 01:23:27,100
would result in incorrect code yeah

01:23:23,950 --> 01:23:32,310
I mean it's a great helpful for thinking

01:23:27,100 --> 01:23:35,650
but I I think trying to constrain the

01:23:32,310 --> 01:23:39,670
concept used to the things like that is

01:23:35,650 --> 01:23:44,110
wrong I have another argument which I

01:23:39,670 --> 01:23:46,150
can't put my mind to just now the not an

01:23:44,110 --> 01:23:48,520
N number was discussed again and again

01:23:46,150 --> 01:23:51,730
and again I suggest you go to Andrew

01:23:48,520 --> 01:23:55,300
Sutton's talk about concepts he's really

01:23:51,730 --> 01:24:03,310
good at that point and and and isn't two

01:23:55,300 --> 01:24:05,890
hours into a presentation hi

01:24:03,310 --> 01:24:07,990
a bit concerned about the kind of coarse

01:24:05,890 --> 01:24:09,580
graining of concepts so you kind of

01:24:07,990 --> 01:24:12,370
address this preempted what you talked

01:24:09,580 --> 01:24:15,030
about how Abel was not a good concept

01:24:12,370 --> 01:24:16,960
and instead okay we have numeric right I

01:24:15,030 --> 01:24:19,360
think one of the issues with this is

01:24:16,960 --> 01:24:21,720
that you know in general when you're

01:24:19,360 --> 01:24:23,680
designing classes and especially for

01:24:21,720 --> 01:24:25,330
application developers usually spread it

01:24:23,680 --> 01:24:28,000
out to error on the concider of a

01:24:25,330 --> 01:24:30,640
constrained interface so you know if you

01:24:28,000 --> 01:24:32,250
don't need multiply then you don't write

01:24:30,640 --> 01:24:34,330
it you can add it later if you need it

01:24:32,250 --> 01:24:35,590
if you don't think it's if you think

01:24:34,330 --> 01:24:38,770
it's confusing or misleading you don't

01:24:35,590 --> 01:24:40,450
have it so we're in the situation now

01:24:38,770 --> 01:24:41,980
where if we start using this numeric

01:24:40,450 --> 01:24:44,380
constrain you know in many many

01:24:41,980 --> 01:24:47,740
algorithms even though let's say

01:24:44,380 --> 01:24:49,750
multiplications not used like I know

01:24:47,740 --> 01:24:51,280
accumulate probably isn't actually done

01:24:49,750 --> 01:24:54,460
this way but imagine if accumulate was

01:24:51,280 --> 01:24:56,110
done using numeric then suddenly you

01:24:54,460 --> 01:24:58,390
know any type that I write that doesn't

01:24:56,110 --> 01:24:59,650
have multiply we can't use with

01:24:58,390 --> 01:25:02,050
accumulate so it's actually kind of

01:24:59,650 --> 01:25:05,050
encouraging people to like slot

01:25:02,050 --> 01:25:06,940
themselves into these concepts which it

01:25:05,050 --> 01:25:08,230
can be a good thing in some cases but I

01:25:06,940 --> 01:25:10,870
think sometimes is actually pretty bad

01:25:08,230 --> 01:25:12,100
if you're basically saying to people if

01:25:10,870 --> 01:25:14,230
you want to reuse this high-quality

01:25:12,100 --> 01:25:16,060
generic code you better add like all

01:25:14,230 --> 01:25:18,790
these other operations you don't really

01:25:16,060 --> 01:25:21,250
need and the algorithm doesn't need this

01:25:18,790 --> 01:25:24,250
is a very old debate should you have

01:25:21,250 --> 01:25:27,100
absolute many more yeah I'm repeating

01:25:24,250 --> 01:25:30,940
the question do you have absolute many

01:25:27,100 --> 01:25:35,240
more requirements or to encourage people

01:25:30,940 --> 01:25:38,930
to build more complete types

01:25:35,240 --> 01:25:42,350
and I don't think encouraging people to

01:25:38,930 --> 01:25:46,490
think about where their types fit

01:25:42,350 --> 01:25:49,310
semantically and put some extra work in

01:25:46,490 --> 01:25:52,220
is encouraging sloppiness on the

01:25:49,310 --> 01:25:56,450
contrary you need to look at experience

01:25:52,220 --> 01:25:59,270
and my experience and other people's

01:25:56,450 --> 01:26:02,180
experience has been that encouraging

01:25:59,270 --> 01:26:06,220
plug-and-play encouraging high level

01:26:02,180 --> 01:26:10,040
concepts is useful and important

01:26:06,220 --> 01:26:13,520
furthermore I'm not being rigid about

01:26:10,040 --> 01:26:17,390
that notice us that you evolve concepts

01:26:13,520 --> 01:26:21,020
and furthermore you can have various

01:26:17,390 --> 01:26:24,770
levels of concepts it would be quite

01:26:21,020 --> 01:26:26,750
reasonable to have concept for things

01:26:24,770 --> 01:26:30,590
that could be added and subtracted but

01:26:26,750 --> 01:26:35,050
not having multiply so you have that

01:26:30,590 --> 01:26:37,730
flexibility when you see a new feature

01:26:35,050 --> 01:26:40,670
especially a major new feature I find

01:26:37,730 --> 01:26:44,150
the programmers are amazingly good at

01:26:40,670 --> 01:26:47,110
imagining problems and they are actually

01:26:44,150 --> 01:26:51,440
quite often dramatically lousy in

01:26:47,110 --> 01:26:54,920
imagining benefits and my view is that

01:26:51,440 --> 01:27:01,970
any language feature any concept if you

01:26:54,920 --> 01:27:07,460
have used the pond has benefits and and

01:27:01,970 --> 01:27:09,920
potential errors and I consider software

01:27:07,460 --> 01:27:12,590
development fundamentally an engineering

01:27:09,920 --> 01:27:18,620
discipline as opposed to a branch of

01:27:12,590 --> 01:27:23,890
mathematics or type theory and you you

01:27:18,620 --> 01:27:26,150
have to evaluate the benefits and the

01:27:23,890 --> 01:27:29,350
disadvantages and then you have to

01:27:26,150 --> 01:27:33,500
observe what happens in in real life and

01:27:29,350 --> 01:27:35,330
I have come to the conclusion after

01:27:33,500 --> 01:27:41,090
watching this kind of stuff and people

01:27:35,330 --> 01:27:45,800
using it for a decade plus that aiming

01:27:41,090 --> 01:27:48,880
for more general more complete concepts

01:27:45,800 --> 01:27:53,929
actually improve code

01:27:48,880 --> 01:27:55,909
thank you with introduction of

01:27:53,929 --> 01:27:58,670
template's we had to change syntax to

01:27:55,909 --> 01:28:02,300
allow things to be constructed to move

01:27:58,670 --> 01:28:05,480
syntax is intended for classes so now we

01:28:02,300 --> 01:28:07,909
can use it for building types so we made

01:28:05,480 --> 01:28:10,880
changes to the language to allow you to

01:28:07,909 --> 01:28:14,300
use it more uniformly now with concept I

01:28:10,880 --> 01:28:16,550
see similar danger you know the concept

01:28:14,300 --> 01:28:19,159
will be easier to use obviously but it

01:28:16,550 --> 01:28:21,199
could be realized in multiple ways do

01:28:19,159 --> 01:28:24,560
you see ways to change the language to

01:28:21,199 --> 01:28:29,080
help us realize the same concept in

01:28:24,560 --> 01:28:33,170
multiple implementations not sure

01:28:29,080 --> 01:28:35,360
understand the question imagine that we

01:28:33,170 --> 01:28:37,969
talk about ratability in future you

01:28:35,360 --> 01:28:40,340
might be able to use it do it using the

01:28:37,969 --> 01:28:42,830
spaceship operator always in the past

01:28:40,340 --> 01:28:44,630
you'd collect some other operators you'd

01:28:42,830 --> 01:28:49,060
still get the same thing semantically

01:28:44,630 --> 01:28:49,060
but it's really different implementation

01:28:49,929 --> 01:28:56,869
so the point is that you can implement

01:28:53,389 --> 01:28:59,960
things in different ways and you need

01:28:56,869 --> 01:29:02,449
some freedom to do this and that relates

01:28:59,960 --> 01:29:07,099
to the previous question do you define

01:29:02,449 --> 01:29:10,540
your concepts really tightly sortable is

01:29:07,099 --> 01:29:13,670
defined in terms of begin in less than

01:29:10,540 --> 01:29:16,909
that's what the standard says and that's

01:29:13,670 --> 01:29:20,119
what the concepts is as a user you then

01:29:16,909 --> 01:29:23,840
use the name of the concept when the

01:29:20,119 --> 01:29:26,920
standard changes say to say that sort

01:29:23,840 --> 01:29:30,050
uses the spaceship operator directly

01:29:26,920 --> 01:29:32,900
your code will not change your

01:29:30,050 --> 01:29:36,380
requirement on your users may change and

01:29:32,900 --> 01:29:39,739
you may have to fix that because the

01:29:36,380 --> 01:29:42,500
standard changed but there's this

01:29:39,739 --> 01:29:45,550
interaction through the specification of

01:29:42,500 --> 01:29:51,530
the concept that gives you some freedom

01:29:45,550 --> 01:29:55,130
and that your argument is an argument

01:29:51,530 --> 01:29:58,630
for the more general concepts as opposed

01:29:55,130 --> 01:29:58,630
to the minimal constraints

01:30:01,800 --> 01:30:07,210
and I have a question about the

01:30:05,380 --> 01:30:09,010
relevance of Const expert in some of

01:30:07,210 --> 01:30:11,260
this I know within a function for

01:30:09,010 --> 01:30:13,540
example if con sex were inside a

01:30:11,260 --> 01:30:15,730
template expansion has different

01:30:13,540 --> 01:30:19,329
properties in some ways than it does

01:30:15,730 --> 01:30:21,340
outside that how would they concepts for

01:30:19,329 --> 01:30:24,820
interact with say function definitions

01:30:21,340 --> 01:30:30,520
and concepts with requires how would

01:30:24,820 --> 01:30:32,949
constitute the functions relate to the

01:30:30,520 --> 01:30:35,619
weight used in concepts there are

01:30:32,949 --> 01:30:38,320
currently not in concepts a way of

01:30:35,619 --> 01:30:41,260
requiring constant for functions for

01:30:38,320 --> 01:30:44,110
instance that is something with disgusto

01:30:41,260 --> 01:30:46,510
order I was thinking more of trying to

01:30:44,110 --> 01:30:48,520
express prop test properties using Const

01:30:46,510 --> 01:30:51,040
X but instead of forcing people to use

01:30:48,520 --> 01:30:52,570
enable F inside a function that's very

01:30:51,040 --> 01:30:56,650
simple but I was wondering if there is a

01:30:52,570 --> 01:31:00,599
way to do that with like to see most

01:30:56,650 --> 01:31:04,619
users of an able if disappear they are

01:31:00,599 --> 01:31:08,530
more error prone more complicated you

01:31:04,619 --> 01:31:10,860
sometimes have to have both the enable F

01:31:08,530 --> 01:31:13,570
of a condition the able if on the

01:31:10,860 --> 01:31:16,719
opposite of the condition if you have

01:31:13,570 --> 01:31:19,090
two predicates you you can end up with

01:31:16,719 --> 01:31:23,250
four versions of the code this is horrid

01:31:19,090 --> 01:31:26,349
that's limonade by concepts that helps

01:31:23,250 --> 01:31:30,219
context for functions fit with concepts

01:31:26,349 --> 01:31:33,040
because they both ways of expressing a

01:31:30,219 --> 01:31:36,400
predicate if they return in ab or so so

01:31:33,040 --> 01:31:38,650
it works together there's a few rough

01:31:36,400 --> 01:31:43,260
edges you cannot write a concept this is

01:31:38,650 --> 01:31:48,579
require constant function by the way

01:31:43,260 --> 01:31:52,809
code using concepts compile faster than

01:31:48,579 --> 01:31:56,710
code using workarounds Eric nibbler

01:31:52,809 --> 01:31:59,829
reported two weeks ago that the range is

01:31:56,710 --> 01:32:03,460
TS that exists in two versions and April

01:31:59,829 --> 01:32:07,090
if and the concepts compiler 25% faster

01:32:03,460 --> 01:32:09,980
with concepts expressing things directly

01:32:07,090 --> 01:32:12,470
is better than representing things

01:32:09,980 --> 01:32:15,650
directly and we are winning on all couch

01:32:12,470 --> 01:32:19,360
with concepts or the previous work

01:32:15,650 --> 01:32:19,360
around thank you

01:32:20,830 --> 01:32:29,900
regarding the idea of Espen a and

01:32:25,870 --> 01:32:33,110
default template arguments template

01:32:29,900 --> 01:32:36,140
deduction what is the opportunity that

01:32:33,110 --> 01:32:38,000
exists between concepts as it exists

01:32:36,140 --> 01:32:39,560
right now and the ability for those to

01:32:38,000 --> 01:32:44,510
participate in template template

01:32:39,560 --> 01:32:47,989
arguments in deduction in Espen a style

01:32:44,510 --> 01:32:50,480
sort of errors that you may argue as far

01:32:47,989 --> 01:32:54,080
okay the question is how does take the

01:32:50,480 --> 01:32:56,810
template arguments fit into it I think

01:32:54,080 --> 01:33:04,790
it they simply fit into it that is you

01:32:56,810 --> 01:33:08,060
can express concepts that involve simple

01:33:04,790 --> 01:33:10,820
template argument again this is a level

01:33:08,060 --> 01:33:13,790
of detail I don't want to go into for

01:33:10,820 --> 01:33:16,580
the fundamental things but I think you

01:33:13,790 --> 01:33:19,330
you you you take the fundamental ideas

01:33:16,580 --> 01:33:22,880
the fundamental techniques in the

01:33:19,330 --> 01:33:26,810
standard you you pull the crank and out

01:33:22,880 --> 01:33:29,630
comes the right solution secondly as

01:33:26,810 --> 01:33:33,020
well with the ever widening gap between

01:33:29,630 --> 01:33:34,040
C and C++ for this matter there have

01:33:33,020 --> 01:33:35,900
been many features that have been

01:33:34,040 --> 01:33:39,110
introduced into the language over the

01:33:35,900 --> 01:33:42,080
years that have allowed me to do certain

01:33:39,110 --> 01:33:44,210
things that I could still accomplish and

01:33:42,080 --> 01:33:49,010
compile with the previous generation of

01:33:44,210 --> 01:33:51,350
our language how do concepts and their

01:33:49,010 --> 01:33:54,710
forward slash backwards compatibility

01:33:51,350 --> 01:33:57,230
for that matter restrict me from porting

01:33:54,710 --> 01:34:03,680
code or using development environments

01:33:57,230 --> 01:34:06,860
that exist in both C and C++ can you use

01:34:03,680 --> 01:34:10,430
concepts both with over compilers and C

01:34:06,860 --> 01:34:14,840
and C++ and and C and C++

01:34:10,430 --> 01:34:18,860
well concepts are not actually meant to

01:34:14,840 --> 01:34:21,590
be backwards compatible obviously and I

01:34:18,860 --> 01:34:23,690
think C is totally lost in this game

01:34:21,590 --> 01:34:27,170
because it doesn't have proper generics

01:34:23,690 --> 01:34:31,940
you can't have concepts as a language

01:34:27,170 --> 01:34:34,880
feature supporting macros and in

01:34:31,940 --> 01:34:40,510
practical terms if you need to work on a

01:34:34,880 --> 01:34:45,140
variety of environment some are old you

01:34:40,510 --> 01:34:48,980
can use things like if you restrict

01:34:45,140 --> 01:34:53,870
yourself to explicit requires closes you

01:34:48,980 --> 01:34:55,970
can you can have requires macro that

01:34:53,870 --> 01:34:59,000
turns into nothing for all the

01:34:55,970 --> 01:35:02,210
environments and so what you can do is

01:34:59,000 --> 01:35:04,430
you can develop your stuff on a modern

01:35:02,210 --> 01:35:06,650
compiler get the checking in place do

01:35:04,430 --> 01:35:09,650
the testing on a modern compiler then

01:35:06,650 --> 01:35:11,870
throw the switch so that the concept

01:35:09,650 --> 01:35:14,540
becomes nothing and if you have not used

01:35:11,870 --> 01:35:18,500
overloading it'll then run correctly on

01:35:14,540 --> 01:35:25,160
old compilers a slightly more subtle

01:35:18,500 --> 01:35:29,030
version of that is to define your actual

01:35:25,160 --> 01:35:32,660
concepts as sort of capital concept

01:35:29,030 --> 01:35:35,150
macros that either turn into the concept

01:35:32,660 --> 01:35:38,030
for the modern compiler or to type name

01:35:35,150 --> 01:35:42,220
on the old one again you lose your

01:35:38,030 --> 01:35:47,810
loading but you can you can compile with

01:35:42,220 --> 01:35:52,420
GCC 4.2 if you're unhappy enough it's

01:35:47,810 --> 01:35:57,620
it's pretty horrid but there are ways of

01:35:52,420 --> 01:36:01,130
using older code over the compilers but

01:35:57,620 --> 01:36:04,330
you have to do nasty things and will

01:36:01,130 --> 01:36:08,090
there be a the ability to default or

01:36:04,330 --> 01:36:13,310
specialize on concepts within template

01:36:08,090 --> 01:36:16,610
programming will be thing for defaulting

01:36:13,310 --> 01:36:19,550
specializing specializing yes defaulting

01:36:16,610 --> 01:36:23,050
I took quite understand what it means in

01:36:19,550 --> 01:36:27,749
particular so probably

01:36:23,050 --> 01:36:27,749
whatever another time I some other time

01:36:28,800 --> 01:36:33,760
hello I'm coming actually from a

01:36:32,110 --> 01:36:35,650
theoretical physics background and I'm

01:36:33,760 --> 01:36:38,079
very excited to about these developments

01:36:35,650 --> 01:36:40,630
that you've just talked about I had a

01:36:38,079 --> 01:36:42,400
question much of or some of what can be

01:36:40,630 --> 01:36:44,110
achieved very elegantly with concepts

01:36:42,400 --> 01:36:46,719
has previously been achieved by

01:36:44,110 --> 01:36:49,780
inheritance through abstract classes and

01:36:46,719 --> 01:36:52,420
I wonder what is what is this take that

01:36:49,780 --> 01:36:54,849
you have won the position of abstract

01:36:52,420 --> 01:37:00,400
classes in in the future with concepts

01:36:54,849 --> 01:37:05,039
being present so abstract classes versus

01:37:00,400 --> 01:37:08,909
concepts one thing I failed to emphasize

01:37:05,039 --> 01:37:11,710
because I've become so used to it

01:37:08,909 --> 01:37:16,119
concepts is a zero overhead feature

01:37:11,710 --> 01:37:17,920
there is no runtime cost and that's

01:37:16,119 --> 01:37:22,179
that's important and I should have said

01:37:17,920 --> 01:37:25,749
so and I as once you get used to things

01:37:22,179 --> 01:37:30,400
you forget so for abstract classes if

01:37:25,749 --> 01:37:32,469
you want a binary compatible gradable

01:37:30,400 --> 01:37:35,260
interface abstract classes are

01:37:32,469 --> 01:37:36,309
unbeatable just a set of functions on

01:37:35,260 --> 01:37:39,900
the other hand

01:37:36,309 --> 01:37:46,539
it causes indirect function call that

01:37:39,900 --> 01:37:48,670
can be expensive concepts are the

01:37:46,539 --> 01:37:51,519
opposite there's no overhead they're

01:37:48,670 --> 01:37:55,110
just compile-time predicates on the

01:37:51,519 --> 01:37:59,079
other hand since concepts are

01:37:55,110 --> 01:38:01,980
independent of the layout of the objects

01:37:59,079 --> 01:38:04,780
they manipulate they don't actually

01:38:01,980 --> 01:38:08,769
address the issue of binary

01:38:04,780 --> 01:38:10,780
compatibility at all so I think they're

01:38:08,769 --> 01:38:17,590
sort of neutral you have to you have to

01:38:10,780 --> 01:38:19,090
orthogonal chores okay thank you so we

01:38:17,590 --> 01:38:21,369
do have 12 minutes the next task that

01:38:19,090 --> 01:38:26,110
you ask your question may be to the

01:38:21,369 --> 01:38:33,220
stage okay thank you thank you

01:38:26,110 --> 01:38:33,220

YouTube URL: https://www.youtube.com/watch?v=HddFGPTAmtU


