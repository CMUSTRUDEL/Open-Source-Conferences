Title: CppCon 2018: Michael Price “Concepts and Contracts: When, What, and How”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Challenge: Write a library function template that takes exactly one positive, integral parameter. 

There are many different ways to implement this function template in standard C++. The future additions of Concepts and Contracts will provide even more, possibly simpler, implementations as well. We will review the current status of both of these important new features, conduct a brief overview of what they can do, and then examine how they can work together towards an interface specification nirvana.
— 
Michael Price, Synopsys, Inc.
Senior Software Engineer

Michael Price has developed and taught C++ for more than a decade and has been an active participant in WG21 since 2014, allocating most of his committee-time to EWG and the Reflection Study Group. He professes interest in making C++ "safer" to use through language and library design, automation, testing, and education. His past work includes enterprise-grade screen sharing applications, ABI-safe C++ component design, network protocol design, software development utilities, large-scale build and test automation, C/C++ compiler front-end development for static analysis tools, and a smidge of management experience.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,009
this talk is called concepts and

00:00:02,070 --> 00:00:07,319
contracts when wat and how so there are

00:00:05,009 --> 00:00:08,639
a few things I need to say before we

00:00:07,319 --> 00:00:12,090
actually start getting into the slides

00:00:08,639 --> 00:00:15,109
so this is a very high-level sort of

00:00:12,090 --> 00:00:19,109
skim the surface of these two features

00:00:15,109 --> 00:00:21,810
right if you're interested in after this

00:00:19,109 --> 00:00:23,130
if you're interested in the nitty-gritty

00:00:21,810 --> 00:00:25,590
the more details there are other

00:00:23,130 --> 00:00:27,240
sessions I'll have a slide that shows

00:00:25,590 --> 00:00:29,699
some of those that are going to go into

00:00:27,240 --> 00:00:33,440
far more detail about how they work what

00:00:29,699 --> 00:00:36,030
the syntaxes are that sort of stuff and

00:00:33,440 --> 00:00:38,280
specifically what I'm interested in is

00:00:36,030 --> 00:00:43,129
how are these things going to work

00:00:38,280 --> 00:00:49,250
together to allow us to write beautiful

00:00:43,129 --> 00:00:52,590
you know nirvanic like interfaces right

00:00:49,250 --> 00:00:54,180
we're rapidly approaching where we'll be

00:00:52,590 --> 00:00:57,000
able to specify more things in the

00:00:54,180 --> 00:00:59,070
interface to make our programming faster

00:00:57,000 --> 00:01:02,850
will make less mistakes as we're

00:00:59,070 --> 00:01:06,000
programming and safer okay that's the

00:01:02,850 --> 00:01:08,250
first thing the second thing is all

00:01:06,000 --> 00:01:11,490
these slides that have code and the

00:01:08,250 --> 00:01:15,720
slides themselves will be up in a github

00:01:11,490 --> 00:01:18,299
repository it's not there yet right it

00:01:15,720 --> 00:01:19,860
will be I just didn't have enough time

00:01:18,299 --> 00:01:22,619
to prep everything and get everything

00:01:19,860 --> 00:01:23,820
pushed in but it will be hopefully by

00:01:22,619 --> 00:01:25,890
the end of the conference it'll all be

00:01:23,820 --> 00:01:28,380
up there so you know you'll be able to

00:01:25,890 --> 00:01:30,119
if you're viewing online later it should

00:01:28,380 --> 00:01:31,710
definitely be up there by then and you

00:01:30,119 --> 00:01:36,450
can actually go and get and play with

00:01:31,710 --> 00:01:38,520
the code examples if you want the third

00:01:36,450 --> 00:01:40,290
thing I need to say is that I like to

00:01:38,520 --> 00:01:41,670
keep my slides nice and simple there's

00:01:40,290 --> 00:01:44,549
not a lot of graphics they're mostly

00:01:41,670 --> 00:01:45,930
either short texts I'm not going to read

00:01:44,549 --> 00:01:49,290
a lot of stuff off the screen there give

00:01:45,930 --> 00:01:52,470
me a lot of code examples I did this

00:01:49,290 --> 00:01:54,780
year throw in some emojis though for

00:01:52,470 --> 00:01:56,969
some flavor all right so hopefully

00:01:54,780 --> 00:02:00,869
you'll see those and and and they'll

00:01:56,969 --> 00:02:03,479
kind of put some pizzazz in the in the

00:02:00,869 --> 00:02:06,689
presentation all right let's get started

00:02:03,479 --> 00:02:08,670
then we got about 70 slides so concepts

00:02:06,689 --> 00:02:11,220
and contracts are already both in the

00:02:08,670 --> 00:02:13,210
sequel standard working draft that means

00:02:11,220 --> 00:02:15,610
that unless some catastrophe

00:02:13,210 --> 00:02:17,290
happens they will ship as a part of the

00:02:15,610 --> 00:02:21,070
next standard which should be shipping

00:02:17,290 --> 00:02:22,450
we expect in the year 2020 right so

00:02:21,070 --> 00:02:24,670
we've got we've got some lead time to

00:02:22,450 --> 00:02:26,800
get more comfortable with them but the

00:02:24,670 --> 00:02:28,450
good thing is that we have vendors that

00:02:26,800 --> 00:02:30,450
are already implementing these things so

00:02:28,450 --> 00:02:34,480
we don't have to wait right

00:02:30,450 --> 00:02:36,190
alright so jumping right in concepts so

00:02:34,480 --> 00:02:38,020
you know yarn as keynote was about

00:02:36,190 --> 00:02:40,090
concepts I unfortunately missed the very

00:02:38,020 --> 00:02:42,150
beginning of that so I don't know how

00:02:40,090 --> 00:02:45,630
much he he discussed this is sort of my

00:02:42,150 --> 00:02:48,240
one small sentence description of what

00:02:45,630 --> 00:02:50,800
concepts are when we talk about them in

00:02:48,240 --> 00:02:52,270
language a collection of features that

00:02:50,800 --> 00:02:55,300
can be used to constrain the arguments

00:02:52,270 --> 00:02:58,180
of templates right types and non types

00:02:55,300 --> 00:03:00,100
now this is sort of like the collection

00:02:58,180 --> 00:03:01,960
of all the features there are actually

00:03:00,100 --> 00:03:04,600
several features that we've added to the

00:03:01,960 --> 00:03:06,820
language that work together to allow us

00:03:04,600 --> 00:03:10,300
to do these constraining of template

00:03:06,820 --> 00:03:15,180
arguments most often it's types but

00:03:10,300 --> 00:03:19,540
you'll see it can be non types as well

00:03:15,180 --> 00:03:22,680
okay so here is an example sort of my

00:03:19,540 --> 00:03:24,040
like hey this is what concepts look like

00:03:22,680 --> 00:03:25,900
this

00:03:24,040 --> 00:03:28,090
Oh other thing all my code examples

00:03:25,900 --> 00:03:29,230
should be fully functional like I have a

00:03:28,090 --> 00:03:30,670
script that runs them and actually

00:03:29,230 --> 00:03:32,410
compiles them and gets the output and

00:03:30,670 --> 00:03:35,500
stuff so there shouldn't be any errors

00:03:32,410 --> 00:03:37,450
on here we'll see so in this in this

00:03:35,500 --> 00:03:38,980
example we're going to define a concept

00:03:37,450 --> 00:03:42,250
called audible and really all that means

00:03:38,980 --> 00:03:44,050
is that the the type that satisfies an

00:03:42,250 --> 00:03:47,650
audible just means you can stream

00:03:44,050 --> 00:03:49,930
strings into it and it's kind of chain

00:03:47,650 --> 00:03:52,150
them up right I'm not gonna explain this

00:03:49,930 --> 00:03:56,680
is a good concept right but it's a

00:03:52,150 --> 00:03:59,500
concept okay and then we have a function

00:03:56,680 --> 00:04:03,070
hello a template function to put hello

00:03:59,500 --> 00:04:04,270
that takes a T and it takes some char

00:04:03,070 --> 00:04:07,300
array that you're gonna you're gonna

00:04:04,270 --> 00:04:09,460
spit out right but we have some we have

00:04:07,300 --> 00:04:12,250
some special we have a special rule

00:04:09,460 --> 00:04:13,810
about this first off you need to be able

00:04:12,250 --> 00:04:15,190
to put things into the outer ball right

00:04:13,810 --> 00:04:20,710
you need to be able to stream things

00:04:15,190 --> 00:04:24,010
into it our sorry out through it and our

00:04:20,710 --> 00:04:26,990
stream is special though we we only want

00:04:24,010 --> 00:04:28,970
to allow less than 10 characters we

00:04:26,990 --> 00:04:30,710
you know our Conor our screen is really

00:04:28,970 --> 00:04:32,840
small right we don't want people to you

00:04:30,710 --> 00:04:35,300
know just cycle stuff 3 1 we want 10

00:04:32,840 --> 00:04:37,100
characters at a time max right this is

00:04:35,300 --> 00:04:40,460
an artificial restriction that I've

00:04:37,100 --> 00:04:42,710
added into there okay so we say okay we

00:04:40,460 --> 00:04:44,930
have a template it takes an audible and

00:04:42,710 --> 00:04:47,660
a size the size needs to be greater than

00:04:44,930 --> 00:04:49,100
zero and less than 10 and that size is

00:04:47,660 --> 00:04:52,419
basically the size of the character

00:04:49,100 --> 00:04:55,550
array right and then we print that out

00:04:52,419 --> 00:04:58,190
so then in our main function I say hello

00:04:55,550 --> 00:05:00,139
and I give it the C out stream and I

00:04:58,190 --> 00:05:04,910
pass you know it's concepts the string

00:05:00,139 --> 00:05:07,360
concepts and that works fine but if I

00:05:04,910 --> 00:05:09,710
pass it you know darkness my old friend

00:05:07,360 --> 00:05:13,130
that is more than 10 characters long

00:05:09,710 --> 00:05:14,690
that's going to be a compile failure the

00:05:13,130 --> 00:05:17,419
concept is going to check that and it's

00:05:14,690 --> 00:05:18,889
going to fail and then the next the line

00:05:17,419 --> 00:05:21,770
00:05:18,889 --> 00:05:24,979
I accidentally pass in an ice dream

00:05:21,770 --> 00:05:27,259
instead of an O stream write something

00:05:24,979 --> 00:05:29,150
that doesn't take that form of the

00:05:27,259 --> 00:05:31,849
stream operator that's also gonna fail

00:05:29,150 --> 00:05:36,949
so just immediately I've I've prevented

00:05:31,849 --> 00:05:40,550
a what would have later been a compile

00:05:36,949 --> 00:05:41,840
time failure for number 7 or line 17 but

00:05:40,550 --> 00:05:43,940
for number 16 that might not have been a

00:05:41,840 --> 00:05:46,340
compile failure right that might have

00:05:43,940 --> 00:05:48,830
been an actual runtime requirement of my

00:05:46,340 --> 00:05:50,210
system and I and I've prevented somebody

00:05:48,830 --> 00:05:55,580
from doing something that they shouldn't

00:05:50,210 --> 00:05:58,009
have done so you know here's what the

00:05:55,580 --> 00:05:59,930
error output looks like right you know

00:05:58,009 --> 00:06:02,000
you can see no matching function for a

00:05:59,930 --> 00:06:04,610
call to hello when you pass darkness my

00:06:02,000 --> 00:06:06,320
old friend because the constraint isn't

00:06:04,610 --> 00:06:09,199
satisfied and the constraint that wasn't

00:06:06,320 --> 00:06:12,650
satisfied was that 24 the size of

00:06:09,199 --> 00:06:16,070
darkness my old friend is greater than

00:06:12,650 --> 00:06:19,190
is not less than 10 right so that saved

00:06:16,070 --> 00:06:21,229
us there not much else interesting in

00:06:19,190 --> 00:06:22,909
that but usually it does actually give

00:06:21,229 --> 00:06:24,620
you a hint of what's like this

00:06:22,909 --> 00:06:31,230
substitution failed because this

00:06:24,620 --> 00:06:32,320
constraint wasn't satisfied right okay

00:06:31,230 --> 00:06:35,120
[Music]

00:06:32,320 --> 00:06:38,270
you know I if people have it like an

00:06:35,120 --> 00:06:40,130
urgent question of anything feel free to

00:06:38,270 --> 00:06:40,820
hold your hand up and hopefully I'll see

00:06:40,130 --> 00:06:42,710
it

00:06:40,820 --> 00:06:46,190
but I do need to try to get through the

00:06:42,710 --> 00:06:48,350
slides more quickly so concepts

00:06:46,190 --> 00:06:51,050
implementation so GCC has had it for a

00:06:48,350 --> 00:06:53,120
while you just use - F concepts which I

00:06:51,050 --> 00:06:55,760
believe that this may have implemented

00:06:53,120 --> 00:06:57,500
the TS version of what and it may not be

00:06:55,760 --> 00:06:59,120
the version that's in the standard so

00:06:57,500 --> 00:07:03,620
there there gonna be some differences

00:06:59,120 --> 00:07:05,300
here I'll try to find out later if what

00:07:03,620 --> 00:07:07,250
the plans are for actually magic having

00:07:05,300 --> 00:07:10,730
it matched the the draft instead of the

00:07:07,250 --> 00:07:13,940
TS in clang there is an experimental

00:07:10,730 --> 00:07:15,410
fork there's a link to it there there's

00:07:13,940 --> 00:07:19,310
instructions on how to build it out

00:07:15,410 --> 00:07:21,050
there at the github repository and you

00:07:19,310 --> 00:07:23,030
have to you have to use those switches

00:07:21,050 --> 00:07:26,930
to to make it work

00:07:23,030 --> 00:07:29,860
MSV see they don't have anything public

00:07:26,930 --> 00:07:32,600
yet they are working on this internally

00:07:29,860 --> 00:07:34,190
and you know they'll get to it as they

00:07:32,600 --> 00:07:36,230
get to it I do want to take a quick

00:07:34,190 --> 00:07:38,180
aside and just kind of like clap for

00:07:36,230 --> 00:07:39,560
Microsoft they've done a lot they've

00:07:38,180 --> 00:07:43,130
made a lot of progress on keeping up

00:07:39,560 --> 00:07:44,690
with things and so if you if you had

00:07:43,130 --> 00:07:45,920
said 10 years ago that Microsoft was

00:07:44,690 --> 00:07:48,080
already implementing something that

00:07:45,920 --> 00:07:49,970
wasn't even finalized yeah I've been

00:07:48,080 --> 00:07:52,550
like no that's not right right but

00:07:49,970 --> 00:07:54,470
Microsoft has changed and and there

00:07:52,550 --> 00:07:55,880
inevitably will be others other other

00:07:54,470 --> 00:07:58,670
front-end vendors that will implement

00:07:55,880 --> 00:07:59,390
this if you're more interested in

00:07:58,670 --> 00:08:01,810
concepts

00:07:59,390 --> 00:08:05,450
obviously there was yarn as keynote

00:08:01,810 --> 00:08:08,330
there is a very detailed concepts talk

00:08:05,450 --> 00:08:10,060
on Thursday concepts as she spoke and

00:08:08,330 --> 00:08:13,130
then there are a couple of other

00:08:10,060 --> 00:08:13,480
sessions that will touch on concepts as

00:08:13,130 --> 00:08:15,070
well

00:08:13,480 --> 00:08:20,750
[Music]

00:08:15,070 --> 00:08:22,550
ok contracts this is also a collection

00:08:20,750 --> 00:08:24,770
of features that can be used to assert

00:08:22,550 --> 00:08:26,660
the validity of function preconditions

00:08:24,770 --> 00:08:28,520
and postconditions as well as the

00:08:26,660 --> 00:08:30,970
internal state use in an implementation

00:08:28,520 --> 00:08:32,900
[Music]

00:08:30,970 --> 00:08:35,650
you know basically this is all about

00:08:32,900 --> 00:08:40,280
checking the values of your program and

00:08:35,650 --> 00:08:43,849
best of them to say that gin necks just

00:08:40,280 --> 00:08:45,380
cutting up function should accept these

00:08:43,849 --> 00:08:47,500
things but not these things and if

00:08:45,380 --> 00:08:51,200
somebody passes the wrong things to it

00:08:47,500 --> 00:08:53,630
then that's a programming error right

00:08:51,200 --> 00:08:54,649
it's not an unfortunate situation of

00:08:53,630 --> 00:08:56,809
your system it's the

00:08:54,649 --> 00:08:59,509
programmer did something wrong here and

00:08:56,809 --> 00:09:01,910
and the programmer that needs to be

00:08:59,509 --> 00:09:05,680
alerted by it alerted about it and and

00:09:01,910 --> 00:09:10,699
that's what the contracts do for you so

00:09:05,680 --> 00:09:14,119
here is a slightly longer example for

00:09:10,699 --> 00:09:15,910
for for contracts and I have to set this

00:09:14,119 --> 00:09:20,089
up a little bit so imagine we have a

00:09:15,910 --> 00:09:22,069
buffer that lives somewhere and it's a

00:09:20,089 --> 00:09:23,839
certain size and there's something

00:09:22,069 --> 00:09:25,699
that's like grabbing things out of this

00:09:23,839 --> 00:09:29,179
buffer and doing things with it right

00:09:25,699 --> 00:09:30,589
and we are on the producer side right so

00:09:29,179 --> 00:09:32,569
we're stuffing things into this buffer

00:09:30,589 --> 00:09:34,220
and something else is coming and sucking

00:09:32,569 --> 00:09:36,319
things out of it right but it's a it's a

00:09:34,220 --> 00:09:37,579
limited size and the thing that's

00:09:36,319 --> 00:09:40,429
consuming things out of this is

00:09:37,579 --> 00:09:42,110
expecting the things that it finds in

00:09:40,429 --> 00:09:44,660
the buffer as it marches along it to be

00:09:42,110 --> 00:09:48,230
monotonically increasing right so if it

00:09:44,660 --> 00:09:51,290
sees a 1 it expects the next thing to be

00:09:48,230 --> 00:09:52,790
2 or higher right but we want to be able

00:09:51,290 --> 00:09:58,429
to just pump stuff into this buffer

00:09:52,790 --> 00:10:00,139
right so you know we can have this push

00:09:58,429 --> 00:10:02,209
monotonic sequence right it takes a

00:10:00,139 --> 00:10:04,759
vector or a bunch of ants and it's gonna

00:10:02,209 --> 00:10:07,160
push them all in but we have these

00:10:04,759 --> 00:10:09,079
restrictions right we can't we can't

00:10:07,160 --> 00:10:13,100
write something that's going to violate

00:10:09,079 --> 00:10:15,410
our art and our preconditions so you

00:10:13,100 --> 00:10:20,600
know it says if you see the line 11

00:10:15,410 --> 00:10:23,449
there's a contract there that says this

00:10:20,600 --> 00:10:25,399
function expects that the size of the

00:10:23,449 --> 00:10:27,259
vector you pass in is less than the size

00:10:25,399 --> 00:10:28,970
of the buffer that we have to put it in

00:10:27,259 --> 00:10:30,769
other words don't give me 12 things

00:10:28,970 --> 00:10:35,290
because I know that we're gonna lose

00:10:30,769 --> 00:10:38,839
things right because it can only hold 10

00:10:35,290 --> 00:10:41,449
and then there's an insurer's contract

00:10:38,839 --> 00:10:43,699
that says when this function exits make

00:10:41,449 --> 00:10:45,980
sure that you've that that the entirety

00:10:43,699 --> 00:10:47,089
of the vector has been processed right

00:10:45,980 --> 00:10:48,470
all of the input sequence has been

00:10:47,089 --> 00:10:50,990
processed and it's clear there's no more

00:10:48,470 --> 00:10:53,929
work to do right so there's an

00:10:50,990 --> 00:10:57,709
implementation here on line 17 R sorry

00:10:53,929 --> 00:11:00,589
16 there is an assert contract it's not

00:10:57,709 --> 00:11:03,920
really a contract as much but this is

00:11:00,589 --> 00:11:06,560
just saying that this is satisfying the

00:11:03,920 --> 00:11:10,440
monotonically increasing

00:11:06,560 --> 00:11:12,420
condition right we could put it in the

00:11:10,440 --> 00:11:14,730
expects somehow but it would be a comp

00:11:12,420 --> 00:11:17,160
would have to traverse the array the

00:11:14,730 --> 00:11:18,450
vector in order to verify that we're

00:11:17,160 --> 00:11:20,670
going to reverse the array anyways

00:11:18,450 --> 00:11:22,980
inside the function body so I'm just

00:11:20,670 --> 00:11:25,770
putting the asserts contract there and

00:11:22,980 --> 00:11:27,180
it says if we're not the first element

00:11:25,770 --> 00:11:28,590
and then the element that we're seeing

00:11:27,180 --> 00:11:30,630
now has to be greater than the last

00:11:28,590 --> 00:11:33,900
element we put into the buffer right

00:11:30,630 --> 00:11:36,210
monotonically increasing and it does

00:11:33,900 --> 00:11:38,640
some swap it does some assignments there

00:11:36,210 --> 00:11:40,400
and then it clears the it clears the the

00:11:38,640 --> 00:11:42,750
the vector after we're all done

00:11:40,400 --> 00:11:45,840
okay so then this is our driver here

00:11:42,750 --> 00:11:48,390
right so we have a vector of zero one

00:11:45,840 --> 00:11:50,310
two and three we push monotonic sequence

00:11:48,390 --> 00:11:53,340
that's perfectly fine it's less than ten

00:11:50,310 --> 00:11:56,370
its monotonically increasing we then

00:11:53,340 --> 00:11:57,570
assign the ten fourteen again ten is

00:11:56,370 --> 00:12:00,060
greater than three so we're still

00:11:57,570 --> 00:12:01,350
monotonically increasing the number of

00:12:00,060 --> 00:12:04,560
elements is less than ten we're still

00:12:01,350 --> 00:12:07,950
good we push that but then we try to

00:12:04,560 --> 00:12:10,740
push zero and we should fail our

00:12:07,950 --> 00:12:14,340
monotonically increasing constraint our

00:12:10,740 --> 00:12:17,120
our contract I have to avoid using

00:12:14,340 --> 00:12:19,440
constraint because that's a concept term

00:12:17,120 --> 00:12:22,230
and you know there will be a runtime

00:12:19,440 --> 00:12:24,060
failure there and then on line 34 we try

00:12:22,230 --> 00:12:26,400
to pump too much stuff into our into our

00:12:24,060 --> 00:12:28,190
into our array and we're gonna get a

00:12:26,400 --> 00:12:31,800
failure on line 36 as well

00:12:28,190 --> 00:12:34,920
and sure enough with my little helpful

00:12:31,800 --> 00:12:37,430
build script thing we compile it we run

00:12:34,920 --> 00:12:38,940
it and we get those two violations

00:12:37,430 --> 00:12:43,070
amount of Kompany

00:12:38,940 --> 00:12:47,300
ping and the size of the buffer right

00:12:43,070 --> 00:12:48,720
okay so contracts is not as well

00:12:47,300 --> 00:12:50,460
supported

00:12:48,720 --> 00:12:52,910
does anybody here that's involved with

00:12:50,460 --> 00:12:56,850
GCC know where they're at

00:12:52,910 --> 00:13:01,410
no okay there is a experimental fork of

00:12:56,850 --> 00:13:04,290
clang for contracts at that URL there

00:13:01,410 --> 00:13:09,300
and you just have to specify the the

00:13:04,290 --> 00:13:11,270
c-plus to a dialect switch there and III

00:13:09,300 --> 00:13:13,860
hear that Emeth vc doesn't have anything

00:13:11,270 --> 00:13:17,610
that's that's you know discussable yet

00:13:13,860 --> 00:13:19,750
either so okay there are also contract

00:13:17,610 --> 00:13:23,290
related talks at this at this conference

00:13:19,750 --> 00:13:25,509
so in this room the the the next session

00:13:23,290 --> 00:13:28,540
after this one bitterly after lunch in

00:13:25,509 --> 00:13:31,509
this same room Alastair Meredith is

00:13:28,540 --> 00:13:32,050
going to have a two part two two hours

00:13:31,509 --> 00:13:36,009
long

00:13:32,050 --> 00:13:37,870
deep dive into contract programming okay

00:13:36,009 --> 00:13:39,069
I highly recommend it Alistair is a

00:13:37,870 --> 00:13:41,019
great speaker

00:13:39,069 --> 00:13:42,790
I encourage you if you're interested in

00:13:41,019 --> 00:13:44,110
that and don't have other sessions that

00:13:42,790 --> 00:13:46,269
you're more interested in you should you

00:13:44,110 --> 00:13:47,889
should definitely attend this and then

00:13:46,269 --> 00:13:55,990
there are some other ones later in the

00:13:47,889 --> 00:13:57,670
week okay so in my in my abstract for

00:13:55,990 --> 00:13:59,949
the talk I put this sort of challenge

00:13:57,670 --> 00:14:02,939
right let's write a library function

00:13:59,949 --> 00:14:07,509
template that takes exactly one positive

00:14:02,939 --> 00:14:10,149
integral parameter that's the challenge

00:14:07,509 --> 00:14:12,639
all right and I phrase this in a

00:14:10,149 --> 00:14:17,199
particular way I'm using positive here

00:14:12,639 --> 00:14:18,850
in the sense of not zero right so it's a

00:14:17,199 --> 00:14:22,269
little more complicated and I'm using

00:14:18,850 --> 00:14:25,509
integral here in the sense of not a char

00:14:22,269 --> 00:14:28,569
or a bool which in C++ are integral

00:14:25,509 --> 00:14:31,209
types but those aren't integers right

00:14:28,569 --> 00:14:35,290
they're not actual integer types right

00:14:31,209 --> 00:14:39,459
conceptually so first thing let's let's

00:14:35,290 --> 00:14:43,029
have a little driver program right so in

00:14:39,459 --> 00:14:45,430
this you know if I pass one to my

00:14:43,029 --> 00:14:49,569
function it should pass if I if I give

00:14:45,430 --> 00:14:52,360
it a a large number the squiggly is you

00:14:49,569 --> 00:14:54,759
know flip the bits right then it should

00:14:52,360 --> 00:14:57,250
still pass but if I give it a negative

00:14:54,759 --> 00:14:59,350
number or if I give it zero or if I give

00:14:57,250 --> 00:15:01,089
it a double or if I give it a character

00:14:59,350 --> 00:15:03,519
if I give a bool if I provide too many

00:15:01,089 --> 00:15:07,750
parameters those should fail in some way

00:15:03,519 --> 00:15:11,559
or another right it turns out that the

00:15:07,750 --> 00:15:13,720
would way we can do this 11 through 14

00:15:11,559 --> 00:15:18,639
lines 11 through 14 we can do a

00:15:13,720 --> 00:15:23,230
compile-time lines 9 and 10 we have we

00:15:18,639 --> 00:15:24,910
have to do with contracts ok so I'm

00:15:23,230 --> 00:15:27,129
gonna run through a series of different

00:15:24,910 --> 00:15:30,790
approaches to doing this right working

00:15:27,129 --> 00:15:33,350
up to adding in contracts and concepts

00:15:30,790 --> 00:15:37,670
features to to solve this problem

00:15:33,350 --> 00:15:39,380
so we could specialize this thing sure

00:15:37,670 --> 00:15:42,170
why not

00:15:39,380 --> 00:15:44,030
so we could have this type there's this

00:15:42,170 --> 00:15:46,370
template which is kind of a helper that

00:15:44,030 --> 00:15:48,350
just says yeah for any type that I don't

00:15:46,370 --> 00:15:50,990
specialize this thing for just this

00:15:48,350 --> 00:15:52,580
isn't allowed right then we specialize

00:15:50,990 --> 00:15:55,780
on all the integral types we have to

00:15:52,580 --> 00:15:58,160
make sure we get them all right right

00:15:55,780 --> 00:16:00,350
that's not a good idea please don't

00:15:58,160 --> 00:16:02,960
please don't do that but this is an

00:16:00,350 --> 00:16:07,850
approach you could take and then we've

00:16:02,960 --> 00:16:10,820
got a function template line 17 the if t

00:16:07,850 --> 00:16:15,890
less than equals 0 throw 1 and that is

00:16:10,820 --> 00:16:18,650
my form of pre-contract a certain you

00:16:15,890 --> 00:16:20,840
know expects to expect statement right

00:16:18,650 --> 00:16:21,770
yeah yeah if this is it just just throw

00:16:20,840 --> 00:16:24,380
and get out of here there'll be

00:16:21,770 --> 00:16:29,150
something later on that will consume

00:16:24,380 --> 00:16:32,990
that and do the right thing ok so when

00:16:29,150 --> 00:16:35,750
we do that with our driver program we

00:16:32,990 --> 00:16:37,610
get what we expect right so if you give

00:16:35,750 --> 00:16:39,680
it two parameters that doesn't work if

00:16:37,610 --> 00:16:41,900
you give it a double that doesn't work

00:16:39,680 --> 00:16:43,280
you give it a character that doesn't

00:16:41,900 --> 00:16:46,370
work if you give it a bool that doesn't

00:16:43,280 --> 00:16:48,350
work but if we sort of ignore the

00:16:46,370 --> 00:16:49,670
compile failures we kind of lead those

00:16:48,350 --> 00:16:51,680
from the source and we compile

00:16:49,670 --> 00:16:55,460
everything that compiles and we run it

00:16:51,680 --> 00:16:57,890
we'll get an assertion at line 9 and 10

00:16:55,460 --> 00:17:01,010
right the negative value and the zero

00:16:57,890 --> 00:17:07,970
value right we saw we solved our

00:17:01,010 --> 00:17:09,410
functions contract ok like I said don't

00:17:07,970 --> 00:17:11,240
please don't do it that way that's

00:17:09,410 --> 00:17:14,660
error-prone and it's gonna it's gonna be

00:17:11,240 --> 00:17:19,160
it's gonna fail in okay so let's use

00:17:14,660 --> 00:17:20,750
traits instead so this time we're not

00:17:19,160 --> 00:17:22,490
going to have a helper we're just gonna

00:17:20,750 --> 00:17:24,949
we're just going to do all this straight

00:17:22,490 --> 00:17:26,870
in our function right at the top of our

00:17:24,949 --> 00:17:28,520
function we're just gonna say we're

00:17:26,870 --> 00:17:31,490
gonna assert that the type you gave me

00:17:28,520 --> 00:17:34,640
is either it is an integral but now we

00:17:31,490 --> 00:17:37,130
have to carve out that exception for the

00:17:34,640 --> 00:17:40,190
things that are true for is integral V

00:17:37,130 --> 00:17:43,490
but we don't want to consider integrals

00:17:40,190 --> 00:17:45,380
characters of various kinds who will

00:17:43,490 --> 00:17:47,000
ever and then we're still going to do

00:17:45,380 --> 00:17:50,360
our little our

00:17:47,000 --> 00:17:50,960
precondition check right it's a lot

00:17:50,360 --> 00:17:53,600
simpler

00:17:50,960 --> 00:17:55,970
you can still mess this up how many

00:17:53,600 --> 00:17:58,280
people knew that char unsigned char and

00:17:55,970 --> 00:18:00,080
sign char are not necessarily like char

00:17:58,280 --> 00:18:01,750
is not necessarily unsigned or signed

00:18:00,080 --> 00:18:05,930
right like it could be a distinct type

00:18:01,750 --> 00:18:07,280
right and so most people are gonna like

00:18:05,930 --> 00:18:12,830
not realize that and they're gonna

00:18:07,280 --> 00:18:15,650
implement it wrong and so same thing we

00:18:12,830 --> 00:18:19,120
get the expected output right we still

00:18:15,650 --> 00:18:23,480
get the the the assertions at the bottom

00:18:19,120 --> 00:18:27,110
okay so you know there there's there's

00:18:23,480 --> 00:18:31,660
something about this that is bothersome

00:18:27,110 --> 00:18:34,460
right line six through 12 we're sort of

00:18:31,660 --> 00:18:38,270
specifying what is valid for our type

00:18:34,460 --> 00:18:41,270
right it would be nice if we could put

00:18:38,270 --> 00:18:45,200
that somewhere around where the type is

00:18:41,270 --> 00:18:47,360
declared right if we could just say oh

00:18:45,200 --> 00:18:50,180
well the thing that needs to be here is

00:18:47,360 --> 00:18:53,150
an integral type according to the the

00:18:50,180 --> 00:18:55,310
way that we're specifying integral so

00:18:53,150 --> 00:18:57,560
you know normally when we've tried to

00:18:55,310 --> 00:19:00,650
like in the in C++ when we've tried to

00:18:57,560 --> 00:19:02,630
sort of provide names to sort of an idea

00:19:00,650 --> 00:19:06,920
of something where we've made a class

00:19:02,630 --> 00:19:10,340
for it right so let's try that and see

00:19:06,920 --> 00:19:11,840
what happens so you know maybe we have a

00:19:10,340 --> 00:19:13,820
class template called

00:19:11,840 --> 00:19:17,320
integral and we put and we put the

00:19:13,820 --> 00:19:20,120
checks the static asserts in there right

00:19:17,320 --> 00:19:23,330
and we can just construct from whatever

00:19:20,120 --> 00:19:25,850
the underlying type is make sure there

00:19:23,330 --> 00:19:28,040
are no that capital e should be a

00:19:25,850 --> 00:19:32,060
lowercase e but make sure there are no

00:19:28,040 --> 00:19:36,980
unwanted conversions you know but then

00:19:32,060 --> 00:19:40,780
we can't just our template on line 17 we

00:19:36,980 --> 00:19:45,260
can't just put integral T in there

00:19:40,780 --> 00:19:48,050
because the type that it's going to get

00:19:45,260 --> 00:19:52,340
when I pass in you know one is int it's

00:19:48,050 --> 00:19:54,770
not integral T right so we have to have

00:19:52,340 --> 00:19:57,350
some way than to say no no you need to

00:19:54,770 --> 00:19:58,310
actually form an integral T from that

00:19:57,350 --> 00:20:00,590
one from that

00:19:58,310 --> 00:20:03,020
from that integer right and pass it in

00:20:00,590 --> 00:20:07,400
so we've got to help her do FN that

00:20:03,020 --> 00:20:09,590
basically does the does the work of the

00:20:07,400 --> 00:20:13,100
body of the function and the f n on line

00:20:09,590 --> 00:20:14,990
17 does that construction of the

00:20:13,100 --> 00:20:19,970
interval type which will then go do the

00:20:14,990 --> 00:20:21,410
check all right this is I mean I don't

00:20:19,970 --> 00:20:22,220
necessarily think it's any better than

00:20:21,410 --> 00:20:24,560
the previous one

00:20:22,220 --> 00:20:27,130
right we've created this thing now that

00:20:24,560 --> 00:20:31,370
exists that's called integral and like

00:20:27,130 --> 00:20:33,740
it doesn't really do anything right it's

00:20:31,370 --> 00:20:36,440
just there to sort of manipulate the

00:20:33,740 --> 00:20:37,700
type system and that that's kind of

00:20:36,440 --> 00:20:39,920
bothers me and then we have to do this

00:20:37,700 --> 00:20:43,310
extra little funny business down here

00:20:39,920 --> 00:20:46,640
and I don't like it but it gets us the

00:20:43,310 --> 00:20:48,410
results right it does it satisfies all

00:20:46,640 --> 00:20:52,910
the contract stuff that we had said that

00:20:48,410 --> 00:20:56,170
we need to satisfy okay so now we're

00:20:52,910 --> 00:20:58,850
actually we're gonna move from the pre

00:20:56,170 --> 00:21:05,990
concepts and contracts stuff into our

00:20:58,850 --> 00:21:09,430
new world so in concepts there are lots

00:21:05,990 --> 00:21:09,430
of related features that work together

00:21:09,760 --> 00:21:17,680
there are constraints constraints over

00:21:13,550 --> 00:21:23,120
types or non type template arguments

00:21:17,680 --> 00:21:27,800
there are requires clauses which

00:21:23,120 --> 00:21:29,980
introduce constraints that then get the

00:21:27,800 --> 00:21:35,060
the template arguments get mapped in

00:21:29,980 --> 00:21:38,270
right that requires clauses then there

00:21:35,060 --> 00:21:42,650
are requires expressions requires

00:21:38,270 --> 00:21:47,030
expressions are a way to create a sort

00:21:42,650 --> 00:21:49,010
of syntactic constraint right like as

00:21:47,030 --> 00:21:52,760
you may have seen in darkness keynote

00:21:49,010 --> 00:21:56,030
right like I can apply the star operator

00:21:52,760 --> 00:21:58,820
to this tea that I have right you would

00:21:56,030 --> 00:22:00,890
use a requires expression to introduce

00:21:58,820 --> 00:22:06,500
that constraint or to describe that

00:22:00,890 --> 00:22:10,150
constraint and then we have concepts

00:22:06,500 --> 00:22:12,290
concepts are basically named

00:22:10,150 --> 00:22:14,210
collections of Constraints where those

00:22:12,290 --> 00:22:18,470
collections can be conjunctions or

00:22:14,210 --> 00:22:20,210
disjunctions or atomic right so in this

00:22:18,470 --> 00:22:24,590
case though we're using a requires

00:22:20,210 --> 00:22:26,660
clause on line 5 to say apply the

00:22:24,590 --> 00:22:29,180
following constraints this is a

00:22:26,660 --> 00:22:35,630
conjunction of the following constraints

00:22:29,180 --> 00:22:37,850
to the type name T right and then the

00:22:35,630 --> 00:22:41,030
rest of you know lines 10 through 12 are

00:22:37,850 --> 00:22:43,280
our normal that we have let's let's do a

00:22:41,030 --> 00:22:46,010
precondition check and throw if that

00:22:43,280 --> 00:22:48,350
failed right so this is this is much

00:22:46,010 --> 00:22:50,330
cleaner than the other approaches that

00:22:48,350 --> 00:22:54,320
we've had so far right in particular I

00:22:50,330 --> 00:22:57,290
can look at the Declaration of FN and I

00:22:54,320 --> 00:22:59,620
can actually reason then about oh that

00:22:57,290 --> 00:23:03,500
that's what that's what this means right

00:22:59,620 --> 00:23:06,770
but I still don't have the name of what

00:23:03,500 --> 00:23:12,490
this thing is in the in the signature

00:23:06,770 --> 00:23:14,840
anywhere but it works right you can see

00:23:12,490 --> 00:23:16,040
you can't pass a double in you can't

00:23:14,840 --> 00:23:17,600
pass a character in you can't pass a

00:23:16,040 --> 00:23:20,060
bull in and you can't pass more than one

00:23:17,600 --> 00:23:26,830
argument in and the assertions for the

00:23:20,060 --> 00:23:30,920
precondition checks still still fire ok

00:23:26,830 --> 00:23:34,970
so let's see if we can do something

00:23:30,920 --> 00:23:36,860
about that that ad-hoc assertion

00:23:34,970 --> 00:23:38,780
mechanism I have for the preconditions

00:23:36,860 --> 00:23:41,060
right that's not if you don't ever want

00:23:38,780 --> 00:23:45,020
to throw one with nobody that's it

00:23:41,060 --> 00:23:47,720
that's a toy example right it's pretty

00:23:45,020 --> 00:23:48,890
simple right online Alette so this is

00:23:47,720 --> 00:23:52,520
exactly the same as the previous one

00:23:48,890 --> 00:23:55,160
except on line 11 instead of my instead

00:23:52,520 --> 00:23:58,900
of my ad-hoc solution for that I have an

00:23:55,160 --> 00:24:01,850
attribute actually it should be the

00:23:58,900 --> 00:24:05,420
brace on line at the end of line 10

00:24:01,850 --> 00:24:08,030
should not be there I have an attribute

00:24:05,420 --> 00:24:11,420
that applies to the function the

00:24:08,030 --> 00:24:13,130
function template that says I expect

00:24:11,420 --> 00:24:17,420
this T you give me to be greater than

00:24:13,130 --> 00:24:22,890
zero at runtime whenever someone calls F

00:24:17,420 --> 00:24:25,050
n depending on some variables

00:24:22,890 --> 00:24:30,180
I mean variables in the abstract sense

00:24:25,050 --> 00:24:35,430
there it may or may not fire a contract

00:24:30,180 --> 00:24:37,320
violation off assuming that you have

00:24:35,430 --> 00:24:42,900
everything set up and it does fire off a

00:24:37,320 --> 00:24:45,690
contract violation you will see down

00:24:42,900 --> 00:24:47,460
there at the bottom of this I report out

00:24:45,690 --> 00:24:49,050
the violations now this is a bit weird

00:24:47,460 --> 00:24:50,970
right it's not actually reporting the

00:24:49,050 --> 00:24:53,960
line on which the call was made its

00:24:50,970 --> 00:24:58,290
reporting the line on which the expects

00:24:53,960 --> 00:25:01,680
contract precondition was so the good

00:24:58,290 --> 00:25:03,720
thing is that that stuff is customizable

00:25:01,680 --> 00:25:08,210
so when a contract is fired off or

00:25:03,720 --> 00:25:11,610
whenever our contract assertion fails it

00:25:08,210 --> 00:25:13,740
passes control to a assert to a

00:25:11,610 --> 00:25:15,810
violation handler and you can define

00:25:13,740 --> 00:25:17,460
what that is I just happen to define

00:25:15,810 --> 00:25:19,500
mine to print out some information about

00:25:17,460 --> 00:25:22,950
the data structure that it that it gave

00:25:19,500 --> 00:25:25,950
me you might also notice though that

00:25:22,950 --> 00:25:28,590
this this output here doesn't list all

00:25:25,950 --> 00:25:33,870
of the compilation failures that I

00:25:28,590 --> 00:25:37,440
expected I discovered so the source of

00:25:33,870 --> 00:25:40,170
that is that we have the two tools right

00:25:37,440 --> 00:25:42,300
we have the concepts fork of clang and

00:25:40,170 --> 00:25:46,020
we have the contracts fork of clang and

00:25:42,300 --> 00:25:48,150
they aren't the same right so my build

00:25:46,020 --> 00:25:50,190
script and stuff that I have sort of

00:25:48,150 --> 00:25:51,750
selects which one of those things to use

00:25:50,190 --> 00:25:54,480
depending on which example that I'm

00:25:51,750 --> 00:25:58,650
trying to show but it turns out that the

00:25:54,480 --> 00:26:01,020
contracts front-end just silently

00:25:58,650 --> 00:26:03,030
swallows that requires clause and just

00:26:01,020 --> 00:26:07,530
like oh thanks he does nothing with it

00:26:03,030 --> 00:26:08,970
which is kind of great but you know III

00:26:07,530 --> 00:26:10,290
thought that was interesting that it

00:26:08,970 --> 00:26:13,320
just went ahead and accepted that and

00:26:10,290 --> 00:26:16,370
then just ignored it so so that's why

00:26:13,320 --> 00:26:19,950
you don't see that output on this screen

00:26:16,370 --> 00:26:23,900
but we do get our contract for

00:26:19,950 --> 00:26:30,470
violations down there okay

00:26:23,900 --> 00:26:33,050
I'm making pretty good time so now let's

00:26:30,470 --> 00:26:37,250
actually talk about concept so I'm gonna

00:26:33,050 --> 00:26:41,360
go back real quick so if you know I name

00:26:37,250 --> 00:26:44,560
this requires right so while I'm using a

00:26:41,360 --> 00:26:49,040
feature from the concepts features right

00:26:44,560 --> 00:26:53,090
there's no concept involved in this

00:26:49,040 --> 00:26:55,280
right this is just a requires clause so

00:26:53,090 --> 00:26:57,710
now we're gonna take that requires

00:26:55,280 --> 00:27:02,780
clause and we're gonna pull it out into

00:26:57,710 --> 00:27:04,220
a concept and you know you may have you

00:27:02,780 --> 00:27:06,140
may have noticed from beyond his keynote

00:27:04,220 --> 00:27:08,390
he did this in a couple of places right

00:27:06,140 --> 00:27:09,980
where he lifted these requires clauses

00:27:08,390 --> 00:27:12,490
out into something that's an Aimable

00:27:09,980 --> 00:27:14,930
right some higher-level

00:27:12,490 --> 00:27:18,740
object or a higher-level aspect of

00:27:14,930 --> 00:27:20,180
something in your domain right so I'm

00:27:18,740 --> 00:27:23,170
just gonna say instead of instead of

00:27:20,180 --> 00:27:26,090
putting it on the function declaration

00:27:23,170 --> 00:27:28,160
the template declaration I'm going to

00:27:26,090 --> 00:27:30,200
make a new concept I'm going to call it

00:27:28,160 --> 00:27:31,820
integral and I'm going to do all those

00:27:30,200 --> 00:27:35,420
same things that one is missing a

00:27:31,820 --> 00:27:38,540
semicolon at the end of line 10 but that

00:27:35,420 --> 00:27:42,110
now I could use that concept name

00:27:38,540 --> 00:27:48,410
integral to introduce constraints in

00:27:42,110 --> 00:27:54,050
various ways on things so on line 12

00:27:48,410 --> 00:27:58,300
I've now constrained the type T to be an

00:27:54,050 --> 00:28:00,500
integral with the concept integral I

00:27:58,300 --> 00:28:01,850
could have actually had a require

00:28:00,500 --> 00:28:06,680
instead of that I still could have done

00:28:01,850 --> 00:28:08,360
type name and then after after void FN

00:28:06,680 --> 00:28:10,700
after after the header for that

00:28:08,360 --> 00:28:13,300
declaration I could have actually then

00:28:10,700 --> 00:28:18,590
put a requires clause and so it requires

00:28:13,300 --> 00:28:22,880
integral T right but this is a simpler

00:28:18,590 --> 00:28:25,670
syntax has potential to cause some

00:28:22,880 --> 00:28:27,530
confusion with what exactly the T is you

00:28:25,670 --> 00:28:29,810
have to know that integral is a concept

00:28:27,530 --> 00:28:34,730
to really know that T then is a type

00:28:29,810 --> 00:28:38,029
because if integral was a class then T

00:28:34,730 --> 00:28:40,849
would not be a type name it would be a

00:28:38,029 --> 00:28:44,210
non-type template argument like a

00:28:40,849 --> 00:28:48,469
literal right and there's some there's

00:28:44,210 --> 00:28:51,799
some still discussions and the in the in

00:28:48,469 --> 00:28:53,450
the committee about is that necessarily

00:28:51,799 --> 00:28:54,259
a bad thing do we want to do anything

00:28:53,450 --> 00:28:59,479
about that

00:28:54,259 --> 00:29:03,399
so okay if you notice here too I on line

00:28:59,479 --> 00:29:05,599
14 I removed my precondition contract

00:29:03,399 --> 00:29:07,669
again because of the difference in the

00:29:05,599 --> 00:29:09,729
front ends right the concepts front end

00:29:07,669 --> 00:29:13,909
that I have doesn't understand the

00:29:09,729 --> 00:29:15,109
contracts expects attribute fails on

00:29:13,909 --> 00:29:16,929
that so I just removed it for this

00:29:15,109 --> 00:29:20,869
example

00:29:16,929 --> 00:29:22,820
okay so here now we get what we expect

00:29:20,869 --> 00:29:24,619
right you can't give it a double you

00:29:22,820 --> 00:29:26,960
can't give it a character you can't give

00:29:24,619 --> 00:29:31,070
it a bull you can't give it more than

00:29:26,960 --> 00:29:36,169
one argument and our precondition check

00:29:31,070 --> 00:29:38,779
still still fires okay and so putting

00:29:36,169 --> 00:29:40,690
those two things together right that's

00:29:38,779 --> 00:29:44,659
that's what the that's what the

00:29:40,690 --> 00:29:46,369
contracts plus concept solution for this

00:29:44,659 --> 00:29:48,799
particular toy problem that I came up

00:29:46,369 --> 00:29:50,419
with would look like now you know you

00:29:48,799 --> 00:29:52,429
could quibble about whether integral

00:29:50,419 --> 00:29:54,019
with if integral means something

00:29:52,429 --> 00:29:55,460
different than what I've said for this

00:29:54,019 --> 00:29:58,460
particular exercise but for this

00:29:55,460 --> 00:30:03,889
exercise that that's what the solution

00:29:58,460 --> 00:30:05,989
was also if you notice at each of these

00:30:03,889 --> 00:30:08,330
things there's a path down at the bottom

00:30:05,989 --> 00:30:10,190
of the source code where there's a path

00:30:08,330 --> 00:30:11,389
that means you'll you'll be able to find

00:30:10,190 --> 00:30:14,539
that piece of source code in my

00:30:11,389 --> 00:30:23,269
repository at that path once it is

00:30:14,539 --> 00:30:24,979
published well I mean that's that's not

00:30:23,269 --> 00:30:29,359
the sort of request I wasn't ad these

00:30:24,979 --> 00:30:31,789
are my emoji right so you know clapping

00:30:29,359 --> 00:30:36,469
hands and raising hands we're getting to

00:30:31,789 --> 00:30:38,359
a good point right okay we've got 30

00:30:36,469 --> 00:30:38,960
minutes so we've we're doing really well

00:30:38,359 --> 00:30:41,239
on time

00:30:38,960 --> 00:30:42,469
so means we can slow down some does

00:30:41,239 --> 00:30:49,009
anybody have any questions about the

00:30:42,469 --> 00:30:52,210
stuff that I showed already yes do

00:30:49,009 --> 00:30:59,260
contracts work in context

00:30:52,210 --> 00:30:59,260
contexts I'll talk about that later yes

00:31:22,779 --> 00:31:27,889
right I could I is that the is that the

00:31:26,059 --> 00:31:30,320
rest of it is there any other clause if

00:31:27,889 --> 00:31:33,739
clause because I can say okay so the

00:31:30,320 --> 00:31:35,690
question is contracts are nothing new

00:31:33,739 --> 00:31:39,289
contracts have been around since at

00:31:35,690 --> 00:31:41,359
least the mid 80s right and you can

00:31:39,289 --> 00:31:43,070
apply contracts to non templated things

00:31:41,359 --> 00:31:45,519
right

00:31:43,070 --> 00:31:49,009
and so the question was is that true for

00:31:45,519 --> 00:31:51,320
for the contracts that are in C++ 20 and

00:31:49,009 --> 00:31:52,820
the answer is yeah you can apply them

00:31:51,320 --> 00:31:55,869
things that are not templates did you

00:31:52,820 --> 00:31:55,869
have another part of the question

00:32:12,520 --> 00:32:22,270
right so the the remainder of the

00:32:17,020 --> 00:32:23,260
question is if I you can correct me if I

00:32:22,270 --> 00:32:25,720
summarize this wrong

00:32:23,260 --> 00:32:27,700
are these things composable in some sort

00:32:25,720 --> 00:32:29,380
of hierarchy like an object hierarchy

00:32:27,700 --> 00:32:33,100
right

00:32:29,380 --> 00:32:35,110
my understanding is yes I would highly

00:32:33,100 --> 00:32:38,740
encourage you to go to Alice dares talk

00:32:35,110 --> 00:32:42,940
to get more details he will be able to

00:32:38,740 --> 00:32:48,940
more answer your question better than I

00:32:42,940 --> 00:32:52,380
would in the time we have yes sure if

00:32:48,940 --> 00:32:55,540
it's if it's all work yeah I've recently

00:32:52,380 --> 00:32:58,750
played around with a tool called Daphne

00:32:55,540 --> 00:33:01,960
from Microsoft research where there is

00:32:58,750 --> 00:33:04,710
also an SMT solver connected to your

00:33:01,960 --> 00:33:08,050
program so it can prove correctness

00:33:04,710 --> 00:33:08,800
based on specifying preconditions and

00:33:08,050 --> 00:33:10,840
postconditions

00:33:08,800 --> 00:33:13,570
is that also the intention of the

00:33:10,840 --> 00:33:16,450
standards proposal here to finally hook

00:33:13,570 --> 00:33:21,850
up some kind of proof proof or tools

00:33:16,450 --> 00:33:25,390
right oh so yes so the question is can

00:33:21,850 --> 00:33:28,420
we use formal verification methods via

00:33:25,390 --> 00:33:30,010
some tooling to sort of prove things

00:33:28,420 --> 00:33:33,490
about your program without actually

00:33:30,010 --> 00:33:35,830
having to run run them right and I think

00:33:33,490 --> 00:33:37,630
the answer is yes there's actually a

00:33:35,830 --> 00:33:41,740
specific feature of contracts called

00:33:37,630 --> 00:33:43,780
axioms that are meant so that you can

00:33:41,740 --> 00:33:46,150
describe things that you don't actually

00:33:43,780 --> 00:33:48,670
want to run at runtime but they're there

00:33:46,150 --> 00:33:51,190
to describe some nature of of the

00:33:48,670 --> 00:33:53,980
contract for that thing that is

00:33:51,190 --> 00:33:55,750
important and the idea being that static

00:33:53,980 --> 00:33:57,340
analysis tools and other tools

00:33:55,750 --> 00:34:01,990
constraint solvers might be able to use

00:33:57,340 --> 00:34:03,160
that information to do their work you

00:34:01,990 --> 00:34:11,859
know the question is about stuff we've

00:34:03,160 --> 00:34:15,010
seen so far yes okay so violations are

00:34:11,859 --> 00:34:15,760
technically I knew this is a technically

00:34:15,010 --> 00:34:18,490
a new idea

00:34:15,760 --> 00:34:21,869
I was wondering how closely or how far

00:34:18,490 --> 00:34:24,070
is it from concept of exceptions and

00:34:21,869 --> 00:34:26,560
what kind of information can we get from

00:34:24,070 --> 00:34:28,270
our violation handler whether it's false

00:34:26,560 --> 00:34:29,650
tres or whether this is something that

00:34:28,270 --> 00:34:32,650
we can have to provide that by ourselves

00:34:29,650 --> 00:34:35,770
because on your example I saw that you

00:34:32,650 --> 00:34:39,130
get on violation location but this is

00:34:35,770 --> 00:34:40,810
exactly where the yeah yeah so so the

00:34:39,130 --> 00:34:42,130
question is what sort of stuff what sort

00:34:40,810 --> 00:34:44,860
of information can you get out of a

00:34:42,130 --> 00:34:48,280
contract violation it's documented you

00:34:44,860 --> 00:34:50,290
can go to cpp reference comm and look up

00:34:48,280 --> 00:34:52,750
I think it's contract underscore

00:34:50,290 --> 00:34:54,670
violation and it's there right now it's

00:34:52,750 --> 00:34:58,030
pretty basic information it's nothing

00:34:54,670 --> 00:34:59,560
fancy but you know it's also not

00:34:58,030 --> 00:35:01,810
something that's solidified in the

00:34:59,560 --> 00:35:02,980
standard it could change alright so

00:35:01,810 --> 00:35:04,600
we're gonna we're gonna move on

00:35:02,980 --> 00:35:07,210
hopefully there'll be more time for more

00:35:04,600 --> 00:35:09,250
questions later I'll try to get get

00:35:07,210 --> 00:35:12,370
through this so you know let's get real

00:35:09,250 --> 00:35:14,740
for some value of real and by real here

00:35:12,370 --> 00:35:18,480
what I mean is let's look at something

00:35:14,740 --> 00:35:20,890
in the standard library currently and

00:35:18,480 --> 00:35:21,870
it's in quotes because we're going to

00:35:20,890 --> 00:35:24,160
talk

00:35:21,870 --> 00:35:27,160
abstract are theoretically about what it

00:35:24,160 --> 00:35:30,160
might look like to apply concepts and

00:35:27,160 --> 00:35:32,200
and contracts do something in in in the

00:35:30,160 --> 00:35:33,610
standard library the thing the codes

00:35:32,200 --> 00:35:35,260
you'll see here is not actually code

00:35:33,610 --> 00:35:37,000
examples because it's something

00:35:35,260 --> 00:35:40,780
theoretical but it's it doesn't work

00:35:37,000 --> 00:35:44,260
right rather it's not what the cases so

00:35:40,780 --> 00:35:48,820
let's take a look at the copy if from

00:35:44,260 --> 00:35:52,150
the algorithms header in the standard

00:35:48,820 --> 00:35:54,340
library so you know it takes two input

00:35:52,150 --> 00:35:56,110
iterators which define a range it takes

00:35:54,340 --> 00:35:58,720
an output iterator which is where you

00:35:56,110 --> 00:36:00,310
want to start copying things into and

00:35:58,720 --> 00:36:02,170
then it takes a predicate that you apply

00:36:00,310 --> 00:36:03,310
to each element in the range to

00:36:02,170 --> 00:36:06,490
determine whether or not it actually

00:36:03,310 --> 00:36:09,490
gets copied to the output location right

00:36:06,490 --> 00:36:11,800
and so this is actually text I copied

00:36:09,490 --> 00:36:17,350
from the standards right so you see here

00:36:11,800 --> 00:36:19,660
one sort of sub Clause 12 requires the

00:36:17,350 --> 00:36:22,840
range is the source range and the

00:36:19,660 --> 00:36:24,970
destination range shall not overlap if

00:36:22,840 --> 00:36:27,670
you start trying to write things over

00:36:24,970 --> 00:36:30,640
the your source that that is that that

00:36:27,670 --> 00:36:34,720
means undefined behavior for this for

00:36:30,640 --> 00:36:36,490
this for this for this function the

00:36:34,720 --> 00:36:38,650
effects so the requires is equivalent

00:36:36,490 --> 00:36:40,540
requires as equivalent to pre sorry not

00:36:38,650 --> 00:36:44,200
preconditions that's

00:36:40,540 --> 00:36:45,700
yes it is a precondition clause 13

00:36:44,200 --> 00:36:46,810
effects copies all of the elements

00:36:45,700 --> 00:36:48,340
referred to by the iterator and the

00:36:46,810 --> 00:36:52,420
range for which the predicate is true

00:36:48,340 --> 00:36:55,840
this is a post condition right like it

00:36:52,420 --> 00:36:58,150
has to have done the work right it may

00:36:55,840 --> 00:37:00,100
turn out that there's no work if the

00:36:58,150 --> 00:37:03,430
predicate is false for everything but

00:37:00,100 --> 00:37:04,960
this will always hold true for anything

00:37:03,430 --> 00:37:07,230
that you do as long as the

00:37:04,960 --> 00:37:09,550
implementation is correct

00:37:07,230 --> 00:37:11,380
it never turns the end of the resulting

00:37:09,550 --> 00:37:13,300
range and then in Clause 15 the

00:37:11,380 --> 00:37:15,970
complexity it tries to give an idea of

00:37:13,300 --> 00:37:22,060
okay what what's the cost of calling

00:37:15,970 --> 00:37:26,830
this thing okay so let's let's try to

00:37:22,060 --> 00:37:28,480
just write a concept fi this thing okay

00:37:26,830 --> 00:37:30,640
so you know assuming that we have

00:37:28,480 --> 00:37:32,850
concepts called input iterator an output

00:37:30,640 --> 00:37:36,970
where diretor and unary predicate and

00:37:32,850 --> 00:37:39,340
copyable from to which these are not

00:37:36,970 --> 00:37:41,460
necessarily concepts that are in the

00:37:39,340 --> 00:37:44,230
standard that's why I'm saying this is

00:37:41,460 --> 00:37:45,280
theoretical right there are concepts in

00:37:44,230 --> 00:37:51,120
the center that do some of these things

00:37:45,280 --> 00:37:54,220
but this isn't them necessarily and then

00:37:51,120 --> 00:37:58,900
you you're just going to replace instead

00:37:54,220 --> 00:38:01,930
of having the template type name in the

00:37:58,900 --> 00:38:05,350
signature you're going to sorry that's

00:38:01,930 --> 00:38:07,150
so if you look here we say class and

00:38:05,350 --> 00:38:11,140
then we provide a name for that type

00:38:07,150 --> 00:38:13,090
right the name of the type is what

00:38:11,140 --> 00:38:14,440
appears in the signature but if you

00:38:13,090 --> 00:38:19,240
notice the name of the type here is

00:38:14,440 --> 00:38:21,580
input iterator in this one the name of

00:38:19,240 --> 00:38:24,010
the type is not input iterator it's in

00:38:21,580 --> 00:38:28,810
we've applied as the input iterator

00:38:24,010 --> 00:38:30,160
constraint to the in type right so the

00:38:28,810 --> 00:38:34,240
thing that appears in our function

00:38:30,160 --> 00:38:38,590
signature is in right so now if I'm

00:38:34,240 --> 00:38:42,070
looking at just say say I ignore the

00:38:38,590 --> 00:38:43,780
template header at the top right I'm

00:38:42,070 --> 00:38:47,890
just looking at the function declaration

00:38:43,780 --> 00:38:51,040
portion right I don't really understand

00:38:47,890 --> 00:38:53,200
what in is right and unfortunately I

00:38:51,040 --> 00:38:56,109
can't use input iterator

00:38:53,200 --> 00:38:58,060
there because input iterator is being

00:38:56,109 --> 00:39:02,140
used as the concept name that I'm being

00:38:58,060 --> 00:39:03,760
applied right whereas here in the

00:39:02,140 --> 00:39:06,220
Declaration the debt and the Declaration

00:39:03,760 --> 00:39:08,380
of the parameter list there oh yeah

00:39:06,220 --> 00:39:12,910
first is an input iterator it's pretty

00:39:08,380 --> 00:39:15,369
clear what that is but in this first is

00:39:12,910 --> 00:39:16,300
an in now I could have named it

00:39:15,369 --> 00:39:18,310
something I could have named it lower

00:39:16,300 --> 00:39:21,670
case input iterator or whatever right

00:39:18,310 --> 00:39:24,369
but this I think that this is this

00:39:21,670 --> 00:39:26,619
shifting of what we have called concepts

00:39:24,369 --> 00:39:28,869
from being the declared type name to

00:39:26,619 --> 00:39:33,280
being the concept that gets a applied to

00:39:28,869 --> 00:39:37,329
it is going to make naming the actual

00:39:33,280 --> 00:39:40,329
type name they're more important for us

00:39:37,329 --> 00:39:44,920
right if we want to retain the same

00:39:40,329 --> 00:39:47,560
level of readability as we had here then

00:39:44,920 --> 00:39:49,630
we're gonna have to get better and this

00:39:47,560 --> 00:39:52,480
isn't going to cut it right but now the

00:39:49,630 --> 00:39:54,940
good thing is that the tools will be

00:39:52,480 --> 00:39:56,560
much better off right so if you never

00:39:54,940 --> 00:39:58,480
have to look at this and understand what

00:39:56,560 --> 00:40:02,760
it is and just let your tools take care

00:39:58,480 --> 00:40:04,170
of it you you won't have this problem

00:40:02,760 --> 00:40:07,030
okay

00:40:04,170 --> 00:40:09,010
so that's not that's not too bad right

00:40:07,030 --> 00:40:15,730
that's a straightforward sort of

00:40:09,010 --> 00:40:17,319
translation of what's going on right so

00:40:15,730 --> 00:40:20,619
let's look at what happens if we try to

00:40:17,319 --> 00:40:23,050
make it contract apply contracts to it

00:40:20,619 --> 00:40:25,480
instead we're gonna go back to the to

00:40:23,050 --> 00:40:28,569
the I guess we still have the concept if

00:40:25,480 --> 00:40:32,260
I'd form of the thing at the top so you

00:40:28,569 --> 00:40:36,069
know I've got some comment box here with

00:40:32,260 --> 00:40:38,410
some with some things so you know

00:40:36,069 --> 00:40:41,079
whenever you have a range - iterators

00:40:38,410 --> 00:40:43,030
that define a range right it's really

00:40:41,079 --> 00:40:46,000
important that those two iterators came

00:40:43,030 --> 00:40:48,940
from the same container right it wasn't

00:40:46,000 --> 00:40:51,430
explicitly specified in in the in the

00:40:48,940 --> 00:40:53,859
description of of copy if but that's

00:40:51,430 --> 00:40:55,900
just sort of like you need to have that

00:40:53,859 --> 00:40:59,079
right and that's only something we can

00:40:55,900 --> 00:41:02,890
check at run time if you're a if you're

00:40:59,079 --> 00:41:04,300
able to check it we need to make sure

00:41:02,890 --> 00:41:05,480
that source and destination do not

00:41:04,300 --> 00:41:07,339
overlap

00:41:05,480 --> 00:41:09,530
right but we don't have a good mechanism

00:41:07,339 --> 00:41:12,859
for doing this right because as soon as

00:41:09,530 --> 00:41:15,940
we if we try to like compare the in

00:41:12,859 --> 00:41:19,820
iterators with the out iterators if

00:41:15,940 --> 00:41:24,349
they're from different containers that

00:41:19,820 --> 00:41:27,500
comparison is undefined Bayer right so

00:41:24,349 --> 00:41:29,329
how how could we write that without

00:41:27,500 --> 00:41:31,700
instantly just triggering and defined

00:41:29,329 --> 00:41:36,020
behavior and and and throwing everything

00:41:31,700 --> 00:41:38,300
in the trash right the source shaders

00:41:36,020 --> 00:41:40,640
are not miss ordered right again this

00:41:38,300 --> 00:41:42,680
isn't something that was listed in the

00:41:40,640 --> 00:41:44,000
standard right but it it's it's fairly

00:41:42,680 --> 00:41:46,609
common sense so you don't want to pass

00:41:44,000 --> 00:41:49,400
the end iterator first and then the

00:41:46,609 --> 00:41:51,890
begin iterator next right this is a

00:41:49,400 --> 00:41:54,470
mistake that programmers make and it's

00:41:51,890 --> 00:41:56,390
clearly a programming error right that

00:41:54,470 --> 00:41:59,060
is something we can test we can test the

00:41:56,390 --> 00:42:00,740
distance between them and if it's

00:41:59,060 --> 00:42:05,859
greater than zero that means that the

00:42:00,740 --> 00:42:08,839
last iterator came after the first one

00:42:05,859 --> 00:42:11,240
and then we need to make sure that we

00:42:08,839 --> 00:42:13,550
add the number of elements we we added

00:42:11,240 --> 00:42:17,150
is actually bounded by something right

00:42:13,550 --> 00:42:19,849
so if if the source had ten elements in

00:42:17,150 --> 00:42:25,010
it we better not have added twenty

00:42:19,849 --> 00:42:26,480
elements to the result right and so you

00:42:25,010 --> 00:42:30,380
can do that with this with this other

00:42:26,480 --> 00:42:33,770
distance calculation but I put not so

00:42:30,380 --> 00:42:35,089
fast on there for some reason there's

00:42:33,770 --> 00:42:38,650
some reason why that doesn't work right

00:42:35,089 --> 00:42:38,650
and I don't know what it is now but

00:42:39,579 --> 00:42:47,099
what's that

00:42:41,940 --> 00:42:49,470
oh right yes so that's another problem

00:42:47,099 --> 00:42:51,660
there is another problem and this is

00:42:49,470 --> 00:42:56,750
important for contracts that is an

00:42:51,660 --> 00:43:00,630
insurer's contract an insurer's contract

00:42:56,750 --> 00:43:04,049
gets gets checked on exit from the

00:43:00,630 --> 00:43:05,970
function so what happens if in my

00:43:04,049 --> 00:43:07,980
implementation of this instead of having

00:43:05,970 --> 00:43:11,190
some other iterator that walks through I

00:43:07,980 --> 00:43:14,940
just increment first until it gets to

00:43:11,190 --> 00:43:17,490
the end right at the end of my function

00:43:14,940 --> 00:43:19,650
at the execution first is now equal to n

00:43:17,490 --> 00:43:22,470
that's that's the point of it right and

00:43:19,650 --> 00:43:26,220
so distance there would be equal to zero

00:43:22,470 --> 00:43:27,740
anyways right and so this is a tricky

00:43:26,220 --> 00:43:30,930
part about contracts with

00:43:27,740 --> 00:43:33,900
post-conditions they are checked with

00:43:30,930 --> 00:43:37,380
the state at the end of the function if

00:43:33,900 --> 00:43:38,700
you had some state at the beginning of

00:43:37,380 --> 00:43:41,010
the function that you wanted to keep

00:43:38,700 --> 00:43:42,630
around just to check in the post

00:43:41,010 --> 00:43:46,140
condition that doesn't work either

00:43:42,630 --> 00:43:49,859
because the functions body has ended

00:43:46,140 --> 00:43:55,559
those things are no longer valid right

00:43:49,859 --> 00:43:58,650
so it is limited in what it can do and

00:43:55,559 --> 00:44:00,480
then there's another precondition there

00:43:58,650 --> 00:44:02,190
are sorry another yet another

00:44:00,480 --> 00:44:06,900
precondition there at the end the

00:44:02,190 --> 00:44:09,150
predicate that you pass shouldn't modify

00:44:06,900 --> 00:44:13,319
the input iterator or modify the the

00:44:09,150 --> 00:44:15,539
input the values of the inputs the

00:44:13,319 --> 00:44:17,819
elements that are in the range right and

00:44:15,539 --> 00:44:19,589
so normally you would say okay that's

00:44:17,819 --> 00:44:21,510
fine in my predicate when you know the

00:44:19,589 --> 00:44:24,240
parameter I pass I'll just provide a

00:44:21,510 --> 00:44:25,980
concert version Const ref of that right

00:44:24,240 --> 00:44:27,930
and then I know my predicate can't

00:44:25,980 --> 00:44:31,859
modify that because it's cause unless

00:44:27,930 --> 00:44:33,630
you do weird stuff but you can't

00:44:31,859 --> 00:44:36,000
actually pet you can actually give it a

00:44:33,630 --> 00:44:39,660
predicate that doesn't take it by Const

00:44:36,000 --> 00:44:45,480
and the sort of arrangement is please

00:44:39,660 --> 00:44:48,000
don't modify anything right but how how

00:44:45,480 --> 00:44:51,559
do we test that I right that's that's

00:44:48,000 --> 00:44:51,559
difficult to test right

00:44:52,160 --> 00:44:59,340
so the the the lesson of this slide is

00:44:57,020 --> 00:45:01,140
there are all sorts of things that

00:44:59,340 --> 00:45:05,160
contracts are not going to be able to

00:45:01,140 --> 00:45:07,230
test right so if people have the idea

00:45:05,160 --> 00:45:08,700
that oh this is great

00:45:07,230 --> 00:45:10,650
I'll be able to fully specify my

00:45:08,700 --> 00:45:12,180
contracting code there will be no

00:45:10,650 --> 00:45:14,910
confusion people won't have to

00:45:12,180 --> 00:45:16,560
disambiguate the English too to prepare

00:45:14,910 --> 00:45:18,780
parse out what needs to happen here

00:45:16,560 --> 00:45:20,910
that's just wrong right

00:45:18,780 --> 00:45:22,740
having contracts are written in English

00:45:20,910 --> 00:45:25,619
you're still going to be important I'll

00:45:22,740 --> 00:45:27,780
leave it up to the to the reader to

00:45:25,619 --> 00:45:29,220
decide whether or not you should

00:45:27,780 --> 00:45:33,480
duplicate things in English that are

00:45:29,220 --> 00:45:36,710
also written as a contract but different

00:45:33,480 --> 00:45:40,500
people have different opinions okay

00:45:36,710 --> 00:45:42,660
you're doing good on time any questions

00:45:40,500 --> 00:45:44,760
about this stuff that I'm gonna move on

00:45:42,660 --> 00:45:55,500
from here fairly fairly soon to some

00:45:44,760 --> 00:45:56,970
other things yes so the question so the

00:45:55,500 --> 00:45:58,200
question that I'm being asked is the

00:45:56,970 --> 00:46:00,600
question marks that I have in these

00:45:58,200 --> 00:46:02,400
comments what what do I mean by that

00:46:00,600 --> 00:46:05,070
so the question marks that I have in the

00:46:02,400 --> 00:46:08,430
comments means I don't know how to write

00:46:05,070 --> 00:46:11,280
this right the the statement that's

00:46:08,430 --> 00:46:13,440
coming after it is true like it's a it

00:46:11,280 --> 00:46:15,240
is a part of what you need to do if

00:46:13,440 --> 00:46:22,680
you're calling this and you want defined

00:46:15,240 --> 00:46:25,890
behavior right oh yeah yeah so and for

00:46:22,680 --> 00:46:29,609
that particular one yeah sure but at but

00:46:25,890 --> 00:46:30,780
as as Pablo was saying yeah you don't

00:46:29,609 --> 00:46:32,250
want you don't want to be calling

00:46:30,780 --> 00:46:34,350
distance on the iterators cuz again he

00:46:32,250 --> 00:46:35,730
might modify the iterator to like you

00:46:34,350 --> 00:46:38,369
can't you can't do that multiple times

00:46:35,730 --> 00:46:40,410
and it be defined so there are all sorts

00:46:38,369 --> 00:46:43,859
of problems with with doing the sort of

00:46:40,410 --> 00:46:45,180
stuff in contracts yes yeah this might

00:46:43,859 --> 00:46:46,820
actually end up being the same question

00:46:45,180 --> 00:46:48,900
I'm very intrigued by this distance

00:46:46,820 --> 00:46:51,420
problem because this is it's sort of

00:46:48,900 --> 00:46:53,160
saying I expect this to be true but it

00:46:51,420 --> 00:46:54,960
could have undefined behavior it's using

00:46:53,160 --> 00:46:57,030
a DL so it could call arbitrary code

00:46:54,960 --> 00:46:58,810
that could do anything yep this this

00:46:57,030 --> 00:47:00,730
code is going to get run

00:46:58,810 --> 00:47:02,350
run-time right every time we enter this

00:47:00,730 --> 00:47:05,680
function it's gonna check the constraint

00:47:02,350 --> 00:47:08,740
which means an arbitrary ADL call yeah

00:47:05,680 --> 00:47:09,940
yeah it could these things are my

00:47:08,740 --> 00:47:12,460
understanding is that these things are

00:47:09,940 --> 00:47:16,750
evaluated in the context in which they

00:47:12,460 --> 00:47:18,850
are written right like it's it's as if

00:47:16,750 --> 00:47:20,230
you know it was there right like you had

00:47:18,850 --> 00:47:21,520
caught it there but it's just do I'm

00:47:20,230 --> 00:47:24,790
gonna actually gonna call that stuff

00:47:21,520 --> 00:47:25,870
later right that makes sense and this

00:47:24,790 --> 00:47:27,550
stuff might have undefined behavior

00:47:25,870 --> 00:47:29,800
which gave yeah it's my program at

00:47:27,550 --> 00:47:32,140
London yeah any contract that does

00:47:29,800 --> 00:47:34,690
something that's undefined behavior I

00:47:32,140 --> 00:47:36,190
think I think the committee went back

00:47:34,690 --> 00:47:38,980
and for I think it may actually be

00:47:36,190 --> 00:47:40,990
ill-formed but I'm not I'm not sure ask

00:47:38,980 --> 00:47:44,020
Alastair and in the next in the next

00:47:40,990 --> 00:47:47,440
session he even know for sure okay

00:47:44,020 --> 00:47:49,630
yes sorry sorry if you already said this

00:47:47,440 --> 00:47:54,700
but I might have missed it what exactly

00:47:49,630 --> 00:47:58,420
does Rhett referred yes good call good

00:47:54,700 --> 00:48:03,010
cat just say so the the attribute syntax

00:47:58,420 --> 00:48:05,620
for contracts is different than all the

00:48:03,010 --> 00:48:08,260
other attribute syntax is that that we

00:48:05,620 --> 00:48:11,760
know from you know from C plus 11 and

00:48:08,260 --> 00:48:18,390
everything the attribute syntax for

00:48:11,760 --> 00:48:18,390
expects is expects and then optionally a

00:48:18,930 --> 00:48:24,870
mode isn't the right word but a sort of

00:48:22,180 --> 00:48:29,400
strictness right right and then a colon

00:48:24,870 --> 00:48:32,880
for insurer's it ensures some strictness

00:48:29,400 --> 00:48:36,790
value and then an optional identifier

00:48:32,880 --> 00:48:38,680
that represents the return value okay so

00:48:36,790 --> 00:48:41,020
it's not an identifier that was declared

00:48:38,680 --> 00:48:42,640
in the function it wrecked it's just

00:48:41,020 --> 00:48:44,560
giving a name to an unnamed thing

00:48:42,640 --> 00:48:46,420
correct and in fact any identifier that

00:48:44,560 --> 00:48:48,490
you declared in the function are no

00:48:46,420 --> 00:48:49,990
longer in scope when these things run

00:48:48,490 --> 00:48:53,110
they they're not there

00:48:49,990 --> 00:48:54,640
okay which makes sense right because

00:48:53,110 --> 00:48:57,100
you're declaring your writing meeting

00:48:54,640 --> 00:48:59,110
before the function right Adi

00:48:57,100 --> 00:49:02,710
right - like they're not lexically in

00:48:59,110 --> 00:49:06,349
scope there either right that was a good

00:49:02,710 --> 00:49:09,680
question okay

00:49:06,349 --> 00:49:11,989
yes another one the I assume there's

00:49:09,680 --> 00:49:14,569
some restraint on what the expression

00:49:11,989 --> 00:49:16,130
can be inside the predicate yeah there

00:49:14,569 --> 00:49:19,219
are there are various constraints about

00:49:16,130 --> 00:49:21,559
what can be the condition expression in

00:49:19,219 --> 00:49:23,959
there's no arbitrary what you could

00:49:21,559 --> 00:49:25,579
actually yeah if you're more interested

00:49:23,959 --> 00:49:27,049
in that you should you should definitely

00:49:25,579 --> 00:49:28,609
check out alistair stock i'm talking up

00:49:27,049 --> 00:49:32,809
his talk because it's gonna be good and

00:49:28,609 --> 00:49:34,969
also um i assume the idea is that for a

00:49:32,809 --> 00:49:38,930
release version you can switch it off

00:49:34,969 --> 00:49:41,630
just like yes so i'll discuss that very

00:49:38,930 --> 00:49:43,940
briefly there are different modes that

00:49:41,630 --> 00:49:46,459
you can compile in that will cause

00:49:43,940 --> 00:49:48,499
different kinds of behavior whenever

00:49:46,459 --> 00:49:50,660
there is whenever there's a contract

00:49:48,499 --> 00:49:52,699
that needs to happen so there are ways

00:49:50,660 --> 00:49:57,019
to turn them all off there are ways to

00:49:52,699 --> 00:49:59,599
run them all there are ways to say keep

00:49:57,019 --> 00:50:01,160
going if there's a failure or terminate

00:49:59,599 --> 00:50:03,440
when there's a failure all sorts of

00:50:01,160 --> 00:50:04,579
stuff like that i'm gonna move on to the

00:50:03,440 --> 00:50:07,549
next thing i have to get some more

00:50:04,579 --> 00:50:09,199
slides but but if you you can ask the

00:50:07,549 --> 00:50:15,829
question again later if you still have

00:50:09,199 --> 00:50:17,390
it okay okay so you know let's let's

00:50:15,829 --> 00:50:23,509
look at something that's in the range is

00:50:17,390 --> 00:50:25,819
TS you know I kind of showed this that's

00:50:23,509 --> 00:50:29,869
not too bad that's not scary we can all

00:50:25,819 --> 00:50:34,630
understand that right um so this is the

00:50:29,869 --> 00:50:34,630
copy if that's in the ranges - yes

00:50:35,630 --> 00:50:40,549
the range of TS is not integrated in

00:50:37,969 --> 00:50:44,299
with the working graph yet I think

00:50:40,549 --> 00:50:46,489
that's right and the rangers TS defines

00:50:44,299 --> 00:50:51,769
a lot more concepts than what are

00:50:46,489 --> 00:50:54,199
currently in the working draft when i

00:50:51,769 --> 00:50:55,069
you know not knowing what these things

00:50:54,199 --> 00:50:58,339
are

00:50:55,069 --> 00:51:03,039
does this become really difficult for me

00:50:58,339 --> 00:51:05,329
to understand what's going on now right

00:51:03,039 --> 00:51:09,339
you know i what

00:51:05,329 --> 00:51:11,630
what does indirect unary predicate mean

00:51:09,339 --> 00:51:13,579
and what does it mean to be indirectly

00:51:11,630 --> 00:51:16,059
copyable and what is this tagged pair

00:51:13,579 --> 00:51:17,650
thing and projections and

00:51:16,059 --> 00:51:19,630
understand conceptually what projections

00:51:17,650 --> 00:51:22,180
are but what does it mean in this in

00:51:19,630 --> 00:51:23,439
this context and in order to understand

00:51:22,180 --> 00:51:25,269
what this means you didn't have to dig

00:51:23,439 --> 00:51:27,579
into each one of those other things and

00:51:25,269 --> 00:51:30,249
then understand them discreetly what is

00:51:27,579 --> 00:51:32,680
Sentinel mean since I'm here Central and

00:51:30,249 --> 00:51:34,959
I really means yeah you can compare this

00:51:32,680 --> 00:51:37,900
to an AI to get it whether it's they're

00:51:34,959 --> 00:51:40,839
equal or not right I think there may be

00:51:37,900 --> 00:51:43,979
some other stuff to it but this is this

00:51:40,839 --> 00:51:46,569
is this is complicated right and so I

00:51:43,979 --> 00:51:49,150
don't I don't know if this is a good

00:51:46,569 --> 00:51:51,609
thing or not it's definitely a good

00:51:49,150 --> 00:51:52,839
thing for us as programmers right like

00:51:51,609 --> 00:51:55,749
if you're just using the stuff and you

00:51:52,839 --> 00:51:59,559
don't need to understand why something

00:51:55,749 --> 00:52:00,759
fails when it fails right if you're

00:51:59,559 --> 00:52:02,589
using everything correctly it's gonna be

00:52:00,759 --> 00:52:09,900
beautiful but this is this kind of

00:52:02,589 --> 00:52:13,029
scares me a little bit they it's okay

00:52:09,900 --> 00:52:16,119
so we got less than ten minutes so

00:52:13,029 --> 00:52:17,859
there's some what about X and what about

00:52:16,119 --> 00:52:22,269
Y sort of questions that we should

00:52:17,859 --> 00:52:24,670
probably still talk about we mentioned

00:52:22,269 --> 00:52:26,709
it some there are they're just going to

00:52:24,670 --> 00:52:31,390
be things that are contracts they're

00:52:26,709 --> 00:52:33,160
uncheck able there may be things that

00:52:31,390 --> 00:52:35,729
are preconditions or post conditions

00:52:33,160 --> 00:52:37,569
that practically speaking aren't safely

00:52:35,729 --> 00:52:39,429
checkable I mean you could write it

00:52:37,569 --> 00:52:43,179
right you could write the thing but you

00:52:39,429 --> 00:52:45,339
but it's not safe to do it changes the

00:52:43,179 --> 00:52:53,910
observation of the state changes the

00:52:45,339 --> 00:52:56,049
state right and so there's this I

00:52:53,910 --> 00:53:00,549
mentioned this sort of strictness level

00:52:56,049 --> 00:53:03,239
for for contracts there's audit and then

00:53:00,549 --> 00:53:10,839
there's default and then there's axiom

00:53:03,239 --> 00:53:15,239
axiom is basically says don't ever

00:53:10,839 --> 00:53:20,650
actually check this this is here for

00:53:15,239 --> 00:53:23,679
sort of expository purposes but it's

00:53:20,650 --> 00:53:27,400
better than a comment as exposition

00:53:23,679 --> 00:53:30,779
because a tool can actually understand

00:53:27,400 --> 00:53:34,359
these things because this is C++ syntax

00:53:30,779 --> 00:53:35,950
right a tool parsing the comment

00:53:34,359 --> 00:53:37,539
structure of a comment to understand

00:53:35,950 --> 00:53:41,770
what a contract is that can't be checked

00:53:37,539 --> 00:53:44,859
is rather difficult right but if

00:53:41,770 --> 00:53:47,289
something is an axiom I could very

00:53:44,859 --> 00:53:49,839
easily say oh yeah there's this thing

00:53:47,289 --> 00:53:51,520
called non mutating and when you take

00:53:49,839 --> 00:53:52,690
this pred you that means that the tools

00:53:51,520 --> 00:53:55,599
should go and check and make sure that

00:53:52,690 --> 00:53:57,369
this predicate never modified it's it's

00:53:55,599 --> 00:53:59,859
there it's it's value get they got

00:53:57,369 --> 00:54:01,299
passed in right but we have static

00:53:59,859 --> 00:54:04,329
analysis tools that can do things like

00:54:01,299 --> 00:54:06,910
that right and now this axiom gives it

00:54:04,329 --> 00:54:11,589
the ability to go and do that sort of

00:54:06,910 --> 00:54:13,210
analysis you know you can have an axiom

00:54:11,589 --> 00:54:15,640
that says make sure this is a valid

00:54:13,210 --> 00:54:17,950
iterator pair because again static

00:54:15,640 --> 00:54:19,420
analysis tools can go back and look in

00:54:17,950 --> 00:54:20,890
the control flow graph as I oh yeah

00:54:19,420 --> 00:54:23,079
these two iterators came from the same

00:54:20,890 --> 00:54:25,029
container right we wouldn't want to

00:54:23,079 --> 00:54:27,039
check that at runtime it would be

00:54:25,029 --> 00:54:28,720
expensive but a static analysis tool

00:54:27,039 --> 00:54:30,250
could do it so you can rest you could

00:54:28,720 --> 00:54:32,380
you could do that with actually now the

00:54:30,250 --> 00:54:36,670
thing here is that this is valid editor

00:54:32,380 --> 00:54:41,349
pair and non mutating those do have to

00:54:36,670 --> 00:54:43,450
be valid C++ functions that return a

00:54:41,349 --> 00:54:46,240
bool right so they would still have to

00:54:43,450 --> 00:54:47,740
be defined somewhere or at least declare

00:54:46,240 --> 00:54:51,099
it I'm not sure if they're happy to find

00:54:47,740 --> 00:54:56,710
if they never get invoked but so that's

00:54:51,099 --> 00:54:59,380
axiom there may I should be precondition

00:54:56,710 --> 00:55:03,700
to that that you can't detect at runtime

00:54:59,380 --> 00:55:06,700
like how what's the runtime complexity

00:55:03,700 --> 00:55:08,380
for this thing or can this thing be

00:55:06,700 --> 00:55:12,010
called from multiple threads safely

00:55:08,380 --> 00:55:14,799
right is it possible that we could use

00:55:12,010 --> 00:55:16,960
axioms in a way to specify for tools to

00:55:14,799 --> 00:55:18,819
say this is this should only ever be

00:55:16,960 --> 00:55:21,220
called from one thread or this is thread

00:55:18,819 --> 00:55:23,859
safe or the runtime of this algorithm is

00:55:21,220 --> 00:55:26,559
o of n wherein is some piece of the

00:55:23,859 --> 00:55:29,430
input right I don't know the answers

00:55:26,559 --> 00:55:29,430
that's why it's a question mark

00:55:30,520 --> 00:55:36,900
okay compile-time contract checking okay

00:55:34,150 --> 00:55:39,850
this was a question earlier can

00:55:36,900 --> 00:55:41,070
contracts be used in a context / context

00:55:39,850 --> 00:55:45,400
that makes sense

00:55:41,070 --> 00:55:49,380
the answer is my current understanding

00:55:45,400 --> 00:55:51,910
of it is it's an unfortunate not quite

00:55:49,380 --> 00:55:55,840
so say you have a context or function

00:55:51,910 --> 00:55:57,550
that you know if you've passed in a V

00:55:55,840 --> 00:56:00,490
this is like the first function that the

00:55:57,550 --> 00:56:02,920
toy program the toy problem we did right

00:56:00,490 --> 00:56:05,200
if it's if it's zero or less this is not

00:56:02,920 --> 00:56:08,290
good right get out of here otherwise

00:56:05,200 --> 00:56:10,900
just return the V you know I so I can on

00:56:08,290 --> 00:56:13,030
line 10 I can say function of two and I

00:56:10,900 --> 00:56:18,070
can assign it to a context per thing but

00:56:13,030 --> 00:56:21,700
on line 11 if I pass in zero the context

00:56:18,070 --> 00:56:23,290
per function can't run in a context for

00:56:21,700 --> 00:56:25,480
context because as soon as it sees a

00:56:23,290 --> 00:56:28,270
throw statement it goes ah I can't do

00:56:25,480 --> 00:56:31,450
this in issues a compiler okay

00:56:28,270 --> 00:56:34,810
the throw the throw throw expression

00:56:31,450 --> 00:56:37,720
being in there doesn't cause it to be an

00:56:34,810 --> 00:56:41,830
invalid contacts per function but just

00:56:37,720 --> 00:56:45,240
if the branching hits it right so with

00:56:41,830 --> 00:56:48,550
this one we actually can say oh yeah

00:56:45,240 --> 00:56:52,450
we're okay right like we can say we can

00:56:48,550 --> 00:56:55,600
check the contract for this function at

00:56:52,450 --> 00:56:57,690
compile time right to say you can't pass

00:56:55,600 --> 00:57:00,760
a zero or something else in there right

00:56:57,690 --> 00:57:03,460
so that's lines one through eleven lines

00:57:00,760 --> 00:57:05,320
13 through 23 are okay well let's let's

00:57:03,460 --> 00:57:06,760
let's use contracts instead right we're

00:57:05,320 --> 00:57:08,859
suppose use contracts to do these things

00:57:06,760 --> 00:57:15,280
let's use that instead of this Hokie

00:57:08,859 --> 00:57:18,670
throw expression that line 18 is not a

00:57:15,280 --> 00:57:21,580
compile time failure even worse not only

00:57:18,670 --> 00:57:26,109
is it not a compile time failure the

00:57:21,580 --> 00:57:29,910
contract never gets checked right it's a

00:57:26,109 --> 00:57:34,900
context / there is no runtime behavior

00:57:29,910 --> 00:57:38,050
for that right so I see this as a whole

00:57:34,900 --> 00:57:42,510
and my understanding is that it's going

00:57:38,050 --> 00:57:42,510
to get possibly get fixed

00:57:42,710 --> 00:57:49,020
we'll see so that's unfortunate you know

00:57:46,110 --> 00:57:51,210
is there anything we can do my

00:57:49,020 --> 00:57:55,920
understanding is that at the end of

00:57:51,210 --> 00:57:58,410
Alistair's second portion of the talk in

00:57:55,920 --> 00:58:01,860
his his his abstract of his talk he

00:57:58,410 --> 00:58:05,930
mentions constant expert checking of

00:58:01,860 --> 00:58:09,450
contracts so i'm going to attend that i

00:58:05,930 --> 00:58:11,580
plan on attending it to see what he what

00:58:09,450 --> 00:58:16,560
he has to say about it I encourage

00:58:11,580 --> 00:58:20,400
everybody else do what did I do here oh

00:58:16,560 --> 00:58:22,770
yes but there's a thing we can do which

00:58:20,400 --> 00:58:26,850
is we can have two versions of this

00:58:22,770 --> 00:58:28,380
function right and the one that we want

00:58:26,850 --> 00:58:30,900
to do at compile time you can just make

00:58:28,380 --> 00:58:32,700
it a template non type template argument

00:58:30,900 --> 00:58:36,990
instead and we could do it that way but

00:58:32,700 --> 00:58:39,180
like this that's that's that's just

00:58:36,990 --> 00:58:42,810
gross let's not let's do it let's solve

00:58:39,180 --> 00:58:43,910
let's solve the other problem it's got

00:58:42,810 --> 00:58:48,030
about a minute left

00:58:43,910 --> 00:58:53,040
so we're checking some both of these

00:58:48,030 --> 00:58:55,500
features are checking constraints over

00:58:53,040 --> 00:58:57,320
some sort of domain right concepts are

00:58:55,500 --> 00:58:59,670
checking our constraining types

00:58:57,320 --> 00:59:03,180
contracts are constraining values at

00:58:59,670 --> 00:59:04,560
runtime right so you know is there a way

00:59:03,180 --> 00:59:06,690
that we could make these things work

00:59:04,560 --> 00:59:09,440
together somehow there are lots of

00:59:06,690 --> 00:59:12,630
papers they describe some thorny issues

00:59:09,440 --> 00:59:14,850
it's it's but it's important to remember

00:59:12,630 --> 00:59:17,310
that concepts constraint template

00:59:14,850 --> 00:59:20,430
arguments contract describe behavior and

00:59:17,310 --> 00:59:22,410
check state right that's the the big

00:59:20,430 --> 00:59:25,100
takeaway from this there might still be

00:59:22,410 --> 00:59:28,830
room to make things work more nicely

00:59:25,100 --> 00:59:31,860
like could we use do we make requires

00:59:28,830 --> 00:59:33,930
clauses take runtime things right like

00:59:31,860 --> 00:59:35,280
if we have a context for function and we

00:59:33,930 --> 00:59:37,650
know it's being caught on a context for

00:59:35,280 --> 00:59:40,260
context could we just use a requires

00:59:37,650 --> 00:59:42,420
clause that just check that thing okay

00:59:40,260 --> 00:59:43,260
probably not there there are some issues

00:59:42,420 --> 00:59:45,660
with it

00:59:43,260 --> 00:59:47,790
but what if we have what if we have like

00:59:45,660 --> 00:59:49,080
the console expert bang which is a no I

00:59:47,790 --> 00:59:50,430
guarantee you this thing is always

00:59:49,080 --> 00:59:53,760
compile time

00:59:50,430 --> 00:59:55,630
that's what context would bang modifier

00:59:53,760 --> 00:59:58,270
would do if it were approved

00:59:55,630 --> 01:00:00,820
we know then okay I can get the value of

00:59:58,270 --> 01:00:03,250
V like it's a compile-time known

01:00:00,820 --> 01:00:05,920
constant you know thing then right

01:00:03,250 --> 01:00:10,620
should we do that because if we do it

01:00:05,920 --> 01:00:12,970
expects it will never fire you know

01:00:10,620 --> 01:00:15,340
that's interesting but requires is a

01:00:12,970 --> 01:00:20,260
concepts thing right remember concepts

01:00:15,340 --> 01:00:22,030
constraint types right so maybe maybe

01:00:20,260 --> 01:00:26,430
instead we should go that path of just

01:00:22,030 --> 01:00:31,510
saying if we if we make contract checks

01:00:26,430 --> 01:00:34,060
const x per knowledgeable right so that

01:00:31,510 --> 01:00:36,190
if you're gonna contact for context and

01:00:34,060 --> 01:00:37,930
you do this and you can check that at

01:00:36,190 --> 01:00:40,480
compile compile time let's just make

01:00:37,930 --> 01:00:42,930
that happen that solves that problem for

01:00:40,480 --> 01:00:45,370
us right we don't have to worry about

01:00:42,930 --> 01:00:48,070
merging these two different things that

01:00:45,370 --> 01:00:52,990
are similar but two different domains at

01:00:48,070 --> 01:00:56,110
that point okay you know i think i think

01:00:52,990 --> 01:00:58,000
we're out of time now if you guys have

01:00:56,110 --> 01:00:59,290
any other questions for me i'll hang

01:00:58,000 --> 01:01:02,380
around out here or something for a

01:00:59,290 --> 01:01:04,270
little bit and thanks for coming to my

01:01:02,380 --> 01:01:05,130
session and enjoy the rest of the

01:01:04,270 --> 01:01:10,939
conference

01:01:05,130 --> 01:01:10,939

YouTube URL: https://www.youtube.com/watch?v=Vj2vuoPJNfE


