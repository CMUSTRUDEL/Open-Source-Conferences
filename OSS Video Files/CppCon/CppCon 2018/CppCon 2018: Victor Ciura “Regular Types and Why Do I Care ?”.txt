Title: CppCon 2018: Victor Ciura “Regular Types and Why Do I Care ?”
Publication date: 2018-10-14
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
“Regular” is not exactly a new concept (pun intended). If we reflect back on STL and its design principles, as best described by Alexander Stepanov in his 1998 “Fundamentals of Generic Programming” paper or his lecture on this topic, from 2002, we see that regular types naturally appear as necessary foundational concepts in programming. 
Why do we need to bother with such taxonomies ? Well, the STL now informally assumes such properties about the types it deals with and imposes such conceptual requirements for its data structures and algorithms to work properly. The new Concepts Lite proposal (hopefully part of C++20) is based on precisely defined foundational concepts such as Semiregular, Regular, EqualityComparable, DefaultConstructible, LessThanComparable (strict weak ordering), etc. Formal specification of concepts is an ongoing effort in the ISO C++ Committee and these STL library concepts requirements are being refined as part of Ranges TS proposal (＜experimental/ranges/concepts＞). 
Recent STL additions such as string_view, tuple, reference_wrapper, as well as new incoming types for C++20 like std::span raise new questions regarding values types, reference types and non-owning “borrow” types. 
Designing and implementing regular types is crucial in everyday programing, not just library design. Properly constraining types and function prototypes will result in intuitive usage; conversely, breaking subtle contracts for functions and algorithms will result in unexpected behavior for the caller. 
This talk will explore the relation between Regular types (and other concepts) and STL containers & algorithms with examples, common pitfalls and guidance. 
— 
Victor Ciura, CAPHYON
Software Developer

Victor Ciura is a Senior Software Engineer at CAPHYON and Technical Lead on the Advanced Installer team (http://www.advancedinstaller.com). 
For over a decade, he designed and implemented several core components and libraries of Advanced Installer.
He’s a regular guest at Computer Science Department of his Alma Mater, University of Craiova, where he gives student lectures & workshops on “Using C++STL for Competitive Programming and Software Development”. 
Currently, he spends most of his time working with his talented team on improving and extending the repackaging and virtualization technologies in Advanced Installer IDE, helping clients migrate their Win32 desktop apps to the Windows Store (MSIX).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,819
morning everyone thank you for coming I

00:00:03,120 --> 00:00:09,320
hope you're properly caffeinated and

00:00:05,819 --> 00:00:14,309
ready to go for an hour of regular fun

00:00:09,320 --> 00:00:17,609
so back in July my friend Simon tweeted

00:00:14,309 --> 00:00:21,449
this and I felt in a very similar

00:00:17,609 --> 00:00:21,750
situation there but I'm going to roll

00:00:21,449 --> 00:00:24,180
with it

00:00:21,750 --> 00:00:26,279
and just in case you're a little

00:00:24,180 --> 00:00:29,189
confused this is the roadmap for this

00:00:26,279 --> 00:00:32,610
week so just to make sure you're in the

00:00:29,189 --> 00:00:38,969
right talk this is the talk on regular

00:00:32,610 --> 00:00:42,170
types and I'm trying to build much

00:00:38,969 --> 00:00:47,190
larger picture here on this theme and

00:00:42,170 --> 00:00:50,730
this is my first take edit and depending

00:00:47,190 --> 00:00:53,550
on how well it does several iterations

00:00:50,730 --> 00:00:57,210
over this will come up over the coming

00:00:53,550 --> 00:01:01,500
months so why are we talking about

00:00:57,210 --> 00:01:05,460
regular types have we really exhausted

00:01:01,500 --> 00:01:08,520
all the cool C++ template topics well

00:01:05,460 --> 00:01:10,939
this talk is not just about regular

00:01:08,520 --> 00:01:14,820
types that's just the catchy title I

00:01:10,939 --> 00:01:17,310
threw through there it's a moment

00:01:14,820 --> 00:01:22,590
reflect back on STL and its design

00:01:17,310 --> 00:01:25,619
principles and I think best described in

00:01:22,590 --> 00:01:29,100
Alexander Stepanov paper from back 20

00:01:25,619 --> 00:01:32,610
years ago now on fundamentals of generic

00:01:29,100 --> 00:01:35,040
programming we shall see that regular

00:01:32,610 --> 00:01:37,460
types naturally appear as necessary

00:01:35,040 --> 00:01:39,450
foundational concepts in programming and

00:01:37,460 --> 00:01:43,530
we'll investigate some of the

00:01:39,450 --> 00:01:45,869
requirements that we need to fulfill in

00:01:43,530 --> 00:01:50,450
order to be able to use and design such

00:01:45,869 --> 00:01:54,689
types in the context of STL algorithms

00:01:50,450 --> 00:01:57,750
so this talk is about values about

00:01:54,689 --> 00:01:58,500
objects but not about object-oriented

00:01:57,750 --> 00:02:01,560
programming

00:01:58,500 --> 00:02:05,969
it's about concepts ordering relations

00:02:01,560 --> 00:02:09,410
and requirements how many of you have

00:02:05,969 --> 00:02:13,740
been in Titus's talk from yesterday a

00:02:09,410 --> 00:02:17,940
few of you it was an excellent two-part

00:02:13,740 --> 00:02:19,920
talk on modern C++ API design I highly

00:02:17,940 --> 00:02:22,970
recommend that you watch it later on

00:02:19,920 --> 00:02:29,390
YouTube if you haven't been it and

00:02:22,970 --> 00:02:32,900
basically examines two fundamental

00:02:29,390 --> 00:02:35,250
properties of types and type families

00:02:32,900 --> 00:02:40,860
combination of properties that make

00:02:35,250 --> 00:02:47,010
useful type designs so let's start with

00:02:40,860 --> 00:02:48,450
the basics let's define the terminology

00:02:47,010 --> 00:02:51,570
that we were going to use throughout

00:02:48,450 --> 00:02:55,560
this talk a datum is a finite sequence

00:02:51,570 --> 00:02:58,860
of zeros and ones a value type is a

00:02:55,560 --> 00:03:01,830
correspondence between species better as

00:02:58,860 --> 00:03:06,450
abstract or concrete and a set of such

00:03:01,830 --> 00:03:09,210
datums a value is a datum together with

00:03:06,450 --> 00:03:12,600
its interpretation for example an

00:03:09,210 --> 00:03:15,830
integer a 32-bit integer represented in

00:03:12,600 --> 00:03:18,660
two's complement began Jian is a value

00:03:15,830 --> 00:03:25,560
bear in mind that a value cannot change

00:03:18,660 --> 00:03:28,710
a value is an abstract idea and we have

00:03:25,560 --> 00:03:31,850
some properties like if a value type is

00:03:28,710 --> 00:03:35,280
uniquely represented equality implies

00:03:31,850 --> 00:03:37,440
representational equality so we try to

00:03:35,280 --> 00:03:38,940
differentiate between the abstract

00:03:37,440 --> 00:03:42,750
concept of a value and its

00:03:38,940 --> 00:03:44,580
representation in computers and if a

00:03:42,750 --> 00:03:46,320
value type is not ambiguous in its

00:03:44,580 --> 00:03:50,970
definition representational equality

00:03:46,320 --> 00:03:53,490
implies equality an object on the other

00:03:50,970 --> 00:03:56,340
hand it's something that it's much more

00:03:53,490 --> 00:03:58,440
closer to us as programmers is a

00:03:56,340 --> 00:04:02,130
representation of a concrete entity as a

00:03:58,440 --> 00:04:06,540
value in computer memory by its address

00:04:02,130 --> 00:04:10,290
and its length so in situ value in

00:04:06,540 --> 00:04:13,350
computer memory is an object an object

00:04:10,290 --> 00:04:17,250
has a state that is a value of some

00:04:13,350 --> 00:04:19,170
value type that we assign to it and the

00:04:17,250 --> 00:04:24,080
state of an object of course can change

00:04:19,170 --> 00:04:25,400
that's how we program computers a type

00:04:24,080 --> 00:04:27,650
is a set of values with the same

00:04:25,400 --> 00:04:32,000
interpretation function and operations

00:04:27,650 --> 00:04:37,340
on those values and the concept is a

00:04:32,000 --> 00:04:40,550
collection of similar types so if we

00:04:37,340 --> 00:04:44,960
established a common ground of talking

00:04:40,550 --> 00:04:47,270
about these concepts it would be much

00:04:44,960 --> 00:04:50,150
easier for us to reason about the

00:04:47,270 --> 00:04:51,710
consequences of good pipe design so

00:04:50,150 --> 00:04:55,430
where did I pick up all these

00:04:51,710 --> 00:05:01,909
definitions from does anyone know what

00:04:55,430 --> 00:05:04,580
yo P stands for yeah is this book right

00:05:01,909 --> 00:05:07,069
here elements of programming by

00:05:04,580 --> 00:05:10,129
Alexander Stepanov and describes the

00:05:07,069 --> 00:05:12,650
foundation and the mathematical

00:05:10,129 --> 00:05:16,039
underpinnings of basic programming

00:05:12,650 --> 00:05:19,310
concepts if you think about regular

00:05:16,039 --> 00:05:22,460
books about programming you can kind of

00:05:19,310 --> 00:05:27,020
think of them as recipe books for

00:05:22,460 --> 00:05:29,180
cooking tasty dishes quickly this book

00:05:27,020 --> 00:05:31,669
is not about that this book is more like

00:05:29,180 --> 00:05:34,789
a book about kitchen chemistry in

00:05:31,669 --> 00:05:38,779
teaching you the subtleties of combining

00:05:34,789 --> 00:05:44,389
different substances to obtain refined

00:05:38,779 --> 00:05:46,210
tastes so this is one of my favorite

00:05:44,389 --> 00:05:49,940
books and I highly recommend that you

00:05:46,210 --> 00:05:52,810
own and browse through it at least does

00:05:49,940 --> 00:06:00,110
anyone know what F m2 G P stands for

00:05:52,810 --> 00:06:04,039
it's more complicated acronym exactly so

00:06:00,110 --> 00:06:06,199
this is another book I consider

00:06:04,039 --> 00:06:09,979
foundational for every programmer that

00:06:06,199 --> 00:06:14,289
wants to improve him or herself

00:06:09,979 --> 00:06:17,120
and it basically takes one algorithm and

00:06:14,289 --> 00:06:19,759
sees its evolution as it shaped

00:06:17,120 --> 00:06:23,180
mathematics throughout almost 4000 years

00:06:19,759 --> 00:06:26,360
and that algorithm is GCD greatest

00:06:23,180 --> 00:06:29,930
common divisor and goes through several

00:06:26,360 --> 00:06:31,849
steps of math mathematical evolution and

00:06:29,930 --> 00:06:36,620
the human understanding of mathematics

00:06:31,849 --> 00:06:37,910
and we see how we can better define and

00:06:36,620 --> 00:06:39,980
refine the way we

00:06:37,910 --> 00:06:45,970
think conceptually about this very

00:06:39,980 --> 00:06:48,770
simple algorithm and it's all of all up

00:06:45,970 --> 00:06:52,910
all of this because of this man

00:06:48,770 --> 00:06:56,290
Alexander Stepanov but why am I talking

00:06:52,910 --> 00:06:59,300
about this where am I going it well I

00:06:56,290 --> 00:07:00,950
have I have a theme here in that

00:06:59,300 --> 00:07:04,990
mathematics really does matter

00:07:00,950 --> 00:07:07,430
and I recently discovered a new

00:07:04,990 --> 00:07:13,490
recording of a session by Alexander

00:07:07,430 --> 00:07:15,140
Stepanov from 2003 on GCD and a path for

00:07:13,490 --> 00:07:17,480
one simple algorithm refined and

00:07:15,140 --> 00:07:18,830
improved over 2,000 years while

00:07:17,480 --> 00:07:22,970
advancing human understanding of

00:07:18,830 --> 00:07:26,330
mathematics and does it really really

00:07:22,970 --> 00:07:28,970
matter well to those who do not know

00:07:26,330 --> 00:07:30,680
mathematics is difficult to get across a

00:07:28,970 --> 00:07:33,140
real feeling as to the beauty and the

00:07:30,680 --> 00:07:34,880
deepest beauty of nature if you want to

00:07:33,140 --> 00:07:36,980
learn about nature and appreciate nature

00:07:34,880 --> 00:07:39,590
it is necessary to understand the

00:07:36,980 --> 00:07:43,280
language that she speaks in as Richard

00:07:39,590 --> 00:07:46,400
Feynman said but hold on I've been

00:07:43,280 --> 00:07:48,680
programming for n years and I've never

00:07:46,400 --> 00:07:52,220
needed any math to do it I'll be just

00:07:48,680 --> 00:07:54,830
fine thank you first of all I don't

00:07:52,220 --> 00:07:57,680
really believe you the reason that

00:07:54,830 --> 00:07:59,630
things just worked for you is that other

00:07:57,680 --> 00:08:01,940
people have thought long and hard about

00:07:59,630 --> 00:08:04,280
the details of the type system and of

00:08:01,940 --> 00:08:06,980
the libraries that you're using such

00:08:04,280 --> 00:08:10,880
that it feels natural and intuitive to

00:08:06,980 --> 00:08:13,400
you and this theme of X meeting

00:08:10,880 --> 00:08:15,380
expectations and intuitive design is

00:08:13,400 --> 00:08:17,960
something we're going to dwell on a

00:08:15,380 --> 00:08:22,190
little bit so stay with me I'm going

00:08:17,960 --> 00:08:24,860
somewhere with this and I'm gonna show

00:08:22,190 --> 00:08:26,660
you just one more instructive path you

00:08:24,860 --> 00:08:29,200
can you could take in your free time and

00:08:26,660 --> 00:08:34,750
that is three our College our goalie

00:08:29,200 --> 00:08:38,479
algorithmic journeys excuse me a rather

00:08:34,750 --> 00:08:43,130
long but very instructive course by

00:08:38,479 --> 00:08:45,650
Alexander Stepanov from 2012 and it

00:08:43,130 --> 00:08:48,290
talks about elementary properties of

00:08:45,650 --> 00:08:50,000
commutativity and also associativity of

00:08:48,290 --> 00:08:53,779
addition and multiplication

00:08:50,000 --> 00:08:57,079
and fundamental algorithmic discoveries

00:08:53,779 --> 00:08:58,519
over time it tells us how division with

00:08:57,079 --> 00:09:01,100
remainder led to discovery of many

00:08:58,519 --> 00:09:03,019
fundamental abstractions and about the

00:09:01,100 --> 00:09:07,519
axioms of natural numbers and the

00:09:03,019 --> 00:09:12,860
relations to iterators it all leads up

00:09:07,519 --> 00:09:16,069
to this seminal paper from fundamentals

00:09:12,860 --> 00:09:19,850
of genetic programming from 1998 so 20

00:09:16,069 --> 00:09:22,399
years ago today genetic programming

00:09:19,850 --> 00:09:24,649
depends on the decomposition of programs

00:09:22,399 --> 00:09:27,949
into components which may be developed

00:09:24,649 --> 00:09:30,170
separately combined arbitrarily subject

00:09:27,949 --> 00:09:32,209
well-defined interfaces and this is a

00:09:30,170 --> 00:09:34,040
very important point that I need to

00:09:32,209 --> 00:09:37,759
stress out about defining proper

00:09:34,040 --> 00:09:39,350
interfaces amount among the interest

00:09:37,759 --> 00:09:41,689
interfaces of interest the most

00:09:39,350 --> 00:09:45,110
pervasively and unconsciously used are

00:09:41,689 --> 00:09:48,410
the found fundamental operations common

00:09:45,110 --> 00:09:51,170
to all C++ building types as extended to

00:09:48,410 --> 00:09:53,930
easily defined types for example copy

00:09:51,170 --> 00:09:56,990
constructors assignment inequality so

00:09:53,930 --> 00:09:59,620
when we design user-defined types we

00:09:56,990 --> 00:10:01,879
should really think of them in terms of

00:09:59,620 --> 00:10:05,420
uniformity with the built in and

00:10:01,879 --> 00:10:08,540
mathematical types we must investigate

00:10:05,420 --> 00:10:10,129
the relations with which might must hold

00:10:08,540 --> 00:10:12,529
among these operations to preserve

00:10:10,129 --> 00:10:14,839
consistency with the mathematical

00:10:12,529 --> 00:10:19,569
building types and the expectations of

00:10:14,839 --> 00:10:22,519
the programmers so we can produce an

00:10:19,569 --> 00:10:25,339
axiomatization of these operations which

00:10:22,519 --> 00:10:27,439
yields required consistency matches

00:10:25,339 --> 00:10:30,500
intuitive expectations of programmers

00:10:27,439 --> 00:10:34,610
and reflects our underlying mathematical

00:10:30,500 --> 00:10:36,920
expectations in other words we want a

00:10:34,610 --> 00:10:38,750
foundational power in powerful enough to

00:10:36,920 --> 00:10:42,430
support any sophisticated programming

00:10:38,750 --> 00:10:48,470
but simple and intuitive to reason about

00:10:42,430 --> 00:10:50,829
that's quite a tall order but is this

00:10:48,470 --> 00:10:55,839
simplicity a good goal

00:10:50,829 --> 00:10:58,490
where C++ programmers are we not well I

00:10:55,839 --> 00:11:00,470
kind of hate it when C++ programmers

00:10:58,490 --> 00:11:03,750
brag about being able to reason about

00:11:00,470 --> 00:11:05,430
some of the obscure language constructs

00:11:03,750 --> 00:11:07,890
proud as if they've discovered some new

00:11:05,430 --> 00:11:10,740
physical law I think simplicity is

00:11:07,890 --> 00:11:14,250
something good to strive for even as

00:11:10,740 --> 00:11:18,720
experienced programmers if you haven't

00:11:14,250 --> 00:11:22,350
seen this talk by category from this is

00:11:18,720 --> 00:11:26,310
from meeting C++ last year it's all

00:11:22,350 --> 00:11:29,100
about simplicity although the title

00:11:26,310 --> 00:11:30,950
might convince you otherwise is

00:11:29,100 --> 00:11:34,140
simplicity a good goal

00:11:30,950 --> 00:11:36,750
simpler code is more readable code to

00:11:34,140 --> 00:11:39,810
you and to others and surprising code is

00:11:36,750 --> 00:11:42,780
a more maintainable code code that moves

00:11:39,810 --> 00:11:46,110
complexity to abstractions often has

00:11:42,780 --> 00:11:48,690
less bugs and compilers and libraries

00:11:46,110 --> 00:11:52,160
are much much more often better than you

00:11:48,690 --> 00:11:54,240
and it's not just for beginners

00:11:52,160 --> 00:11:57,230
simplicity requires knowledge on

00:11:54,240 --> 00:11:59,880
language idioms domain experience

00:11:57,230 --> 00:12:03,930
simplicity is an act of generosity to

00:11:59,880 --> 00:12:08,130
you and future you and others and it's

00:12:03,930 --> 00:12:12,390
not about hiding details or leaving them

00:12:08,130 --> 00:12:17,370
out I highly recommend that you visit

00:12:12,390 --> 00:12:22,680
this essay we have the author right here

00:12:17,370 --> 00:12:24,750
in the room and I think VSA basically

00:12:22,680 --> 00:12:27,660
evokes the Anna Karenina principles to

00:12:24,750 --> 00:12:30,270
designing c++ types in that good types

00:12:27,660 --> 00:12:33,260
are all alike every poorly designed type

00:12:30,270 --> 00:12:36,630
is poorly defined in its own way

00:12:33,260 --> 00:12:39,060
so this essay in my opinion is both the

00:12:36,630 --> 00:12:41,100
best up-to-date synthesis of the

00:12:39,060 --> 00:12:43,380
original Stepanov paper as well as an

00:12:41,100 --> 00:12:47,190
investigation on using known values as

00:12:43,380 --> 00:12:50,070
if they were regular types this analysis

00:12:47,190 --> 00:12:52,530
provides us some basis to evaluate non

00:12:50,070 --> 00:12:55,710
owning reference parameter types like

00:12:52,530 --> 00:12:58,650
string view and span in practical

00:12:55,710 --> 00:13:04,050
fashion without disregarding regular

00:12:58,650 --> 00:13:08,400
design these types shall appear regular

00:13:04,050 --> 00:13:10,170
although they are not let's go back to

00:13:08,400 --> 00:13:12,230
the roots STL annette's design

00:13:10,170 --> 00:13:15,620
principles

00:13:12,230 --> 00:13:18,320
and this stock I think most

00:13:15,620 --> 00:13:24,940
representative of this mission statement

00:13:18,320 --> 00:13:28,610
of our industry and craft about STL and

00:13:24,940 --> 00:13:30,500
design guidance in extending STL because

00:13:28,610 --> 00:13:33,470
this library was meant to be extended

00:13:30,500 --> 00:13:35,330
and I'm not referring here only on the

00:13:33,470 --> 00:13:38,200
standards efforts of extending and

00:13:35,330 --> 00:13:41,420
refining this library I'm talking about

00:13:38,200 --> 00:13:44,900
us as a community as programmers in

00:13:41,420 --> 00:13:47,210
extending this library in our

00:13:44,900 --> 00:13:51,430
applications and in our foundational

00:13:47,210 --> 00:13:53,330
libraries fundamental principles are

00:13:51,430 --> 00:13:55,490
systematically identifying and

00:13:53,330 --> 00:13:58,610
organising useful algorithms and data

00:13:55,490 --> 00:14:03,010
structures finding the most general

00:13:58,610 --> 00:14:04,160
representation of algorithms using

00:14:03,010 --> 00:14:06,860
whole-part

00:14:04,160 --> 00:14:09,590
value semantics for data structures and

00:14:06,860 --> 00:14:13,250
this is an important issue that most of

00:14:09,590 --> 00:14:15,320
us freely disregard using abstractions

00:14:13,250 --> 00:14:17,900
of addresses as interfaces between

00:14:15,320 --> 00:14:24,650
algorithms and data structures basically

00:14:17,900 --> 00:14:26,690
iterators and nowadays ranges algorithms

00:14:24,650 --> 00:14:28,850
are associated with a set of common

00:14:26,690 --> 00:14:30,920
properties for example addition

00:14:28,850 --> 00:14:33,800
multiplication min/max are all

00:14:30,920 --> 00:14:36,230
associative operations and because of

00:14:33,800 --> 00:14:38,900
this we can reorder operands we can

00:14:36,230 --> 00:14:42,770
paralyze the operations and we can

00:14:38,900 --> 00:14:46,100
reduce them so these kind of operations

00:14:42,770 --> 00:14:49,280
are amenable to reduction such as STD

00:14:46,100 --> 00:14:52,070
accumulate and of course they're a

00:14:49,280 --> 00:14:55,630
natural extension of 4,000 years of

00:14:52,070 --> 00:15:00,470
mathematics as we've seen in the preview

00:14:55,630 --> 00:15:02,690
and as Alex left likes to say there

00:15:00,470 --> 00:15:06,820
exists a generic algorithm behind every

00:15:02,690 --> 00:15:06,820
while and for loop that you would write

00:15:07,150 --> 00:15:14,180
STL data structures extend the semantics

00:15:11,480 --> 00:15:17,570
of C structures and we do have to think

00:15:14,180 --> 00:15:19,760
about them in those terms as we talked

00:15:17,570 --> 00:15:23,060
earlier about their representation in

00:15:19,760 --> 00:15:25,610
memory as objects to objects never

00:15:23,060 --> 00:15:28,310
intersect and they

00:15:25,610 --> 00:15:32,510
our separate entities philosophically

00:15:28,310 --> 00:15:35,899
and so representational and two objects

00:15:32,510 --> 00:15:37,700
should have separate lifetimes and we

00:15:35,899 --> 00:15:40,820
don't have to think very hard about this

00:15:37,700 --> 00:15:42,350
when designing dependencies and when we

00:15:40,820 --> 00:15:46,850
have to reason about the context in

00:15:42,350 --> 00:15:52,130
which we use our objects I think we had

00:15:46,850 --> 00:15:53,959
a very good treatment on that in title

00:15:52,130 --> 00:15:57,490
so spoke from yesterday that I mentioned

00:15:53,959 --> 00:16:00,560
earlier and how important it is to

00:15:57,490 --> 00:16:02,690
design types so that we have we can

00:16:00,560 --> 00:16:07,370
reason about them without a dependency

00:16:02,690 --> 00:16:09,560
on the context STL data structures have

00:16:07,370 --> 00:16:13,190
whole-part semantics I said we're going

00:16:09,560 --> 00:16:16,100
to dwell on that a bit we copied the

00:16:13,190 --> 00:16:18,920
whole and when we copy the whole object

00:16:16,100 --> 00:16:23,450
we copy its parts if it's a composite

00:16:18,920 --> 00:16:25,399
object and most of them are and when the

00:16:23,450 --> 00:16:29,779
whole is destroyed all the parts are

00:16:25,399 --> 00:16:31,880
destroyed two things are equal if they

00:16:29,779 --> 00:16:34,550
have the same number of parts and their

00:16:31,880 --> 00:16:36,980
corresponding parts are equal and we

00:16:34,550 --> 00:16:42,110
shall see that it's very hard for us to

00:16:36,980 --> 00:16:45,290
define what it means to for two objects

00:16:42,110 --> 00:16:49,940
to be equal equality is not of an easy

00:16:45,290 --> 00:16:52,220
thing to define of course all this comes

00:16:49,940 --> 00:16:54,560
with drawbacks like for generic

00:16:52,220 --> 00:16:56,750
programming sometimes very early

00:16:54,560 --> 00:16:58,279
abstraction penalty implementation

00:16:56,750 --> 00:17:01,550
interface we all know these early

00:16:58,279 --> 00:17:03,260
binding horrible error messages because

00:17:01,550 --> 00:17:06,079
we don't have a formal specification or

00:17:03,260 --> 00:17:08,299
the interfaces yet duck typing the fact

00:17:06,079 --> 00:17:11,809
that an algorithm that we write today

00:17:08,299 --> 00:17:14,750
might not work several months from now

00:17:11,809 --> 00:17:16,730
and used in another context so we need

00:17:14,750 --> 00:17:21,350
to fully specify requirements on

00:17:16,730 --> 00:17:23,650
algorithm types but what does that mean

00:17:21,350 --> 00:17:23,650
for us

00:17:25,480 --> 00:17:33,730
a few examples from STL of requirements

00:17:30,280 --> 00:17:39,010
like destructible copy assignable

00:17:33,730 --> 00:17:42,429
swappable equality comparable just a few

00:17:39,010 --> 00:17:44,590
example many more define their named

00:17:42,429 --> 00:17:46,600
requirements are used in the normative

00:17:44,590 --> 00:17:48,490
text of the stipple of the standard to

00:17:46,600 --> 00:17:51,640
define expectations of the standard

00:17:48,490 --> 00:17:54,160
library some of these requirements are

00:17:51,640 --> 00:17:54,780
going to be formalized in C++ 20 using

00:17:54,160 --> 00:17:57,700
concepts

00:17:54,780 --> 00:18:00,220
until then the burden is on us as

00:17:57,700 --> 00:18:02,770
programmers to ensure that library

00:18:00,220 --> 00:18:04,240
templates are instantiated with template

00:18:02,770 --> 00:18:15,669
arguments that satisfies these

00:18:04,240 --> 00:18:20,620
requirements so what exactly in

00:18:15,669 --> 00:18:22,720
combining them even more so but what is

00:18:20,620 --> 00:18:25,690
a concept anyway it's a formal

00:18:22,720 --> 00:18:27,669
specification that makes it possible to

00:18:25,690 --> 00:18:30,250
verify that template arguments satisfy

00:18:27,669 --> 00:18:31,919
expectations of a template or function

00:18:30,250 --> 00:18:35,350
during overload resolution and

00:18:31,919 --> 00:18:38,049
specialization each concept is a

00:18:35,350 --> 00:18:40,600
predicate evaluated at compile time and

00:18:38,049 --> 00:18:42,850
becomes part of the interface of the

00:18:40,600 --> 00:18:48,040
template where it is used as a

00:18:42,850 --> 00:18:52,059
constraint on its usage but all this

00:18:48,040 --> 00:18:54,640
theoretical talk what was the practical

00:18:52,059 --> 00:18:59,020
upside and not reliability writer why

00:18:54,640 --> 00:19:01,660
should I care well you should care in

00:18:59,020 --> 00:19:05,370
using STL algorithms and data structures

00:19:01,660 --> 00:19:08,290
and if you're not aware of these

00:19:05,370 --> 00:19:10,830
requirements you're not gonna be able to

00:19:08,290 --> 00:19:15,309
use STL algorithms and data structures

00:19:10,830 --> 00:19:18,010
safely and designing and exposing your

00:19:15,309 --> 00:19:21,309
own vocabulary types in interface is an

00:19:18,010 --> 00:19:26,770
API is that you write and I want to tell

00:19:21,309 --> 00:19:29,460
you a story now every year I mean guests

00:19:26,770 --> 00:19:33,340
lecture at my alma mater and I give a

00:19:29,460 --> 00:19:36,540
workshop on using C++ STL or for

00:19:33,340 --> 00:19:38,890
competitive programming and software

00:19:36,540 --> 00:19:41,650
programming and

00:19:38,890 --> 00:19:46,330
each year I'm faced with the difficult

00:19:41,650 --> 00:19:49,260
task and on explaining to students how

00:19:46,330 --> 00:19:51,610
to properly use STL algorithms because

00:19:49,260 --> 00:19:55,720
when they do encounter unexpected

00:19:51,610 --> 00:19:59,740
results they steer away from using STL

00:19:55,720 --> 00:20:03,000
because of the fear of unknown and I'm

00:19:59,740 --> 00:20:05,770
always trying to convey the message that

00:20:03,000 --> 00:20:09,100
properly understanding the mathematical

00:20:05,770 --> 00:20:10,840
underpinnings of genetic programming and

00:20:09,100 --> 00:20:13,660
type design will help them better

00:20:10,840 --> 00:20:18,550
understand and reliably use steel

00:20:13,660 --> 00:20:21,490
algorithm and data structures so as I

00:20:18,550 --> 00:20:23,980
did with them let's explore one popular

00:20:21,490 --> 00:20:29,290
STL algorithm and its requirements and

00:20:23,980 --> 00:20:33,160
that it's stds sort stds sort deals with

00:20:29,290 --> 00:20:36,610
a compare concept and compare is this a

00:20:33,160 --> 00:20:39,310
function object that is a predicate or

00:20:36,610 --> 00:20:42,880
explicitly a binary predicate and why is

00:20:39,310 --> 00:20:46,300
this so special it's because 50 or so

00:20:42,880 --> 00:20:51,270
STL facilities expect some kind of

00:20:46,300 --> 00:20:54,040
compare type for example STD sort here

00:20:51,270 --> 00:20:57,790
so what are the requirements for compare

00:20:54,040 --> 00:21:00,330
type well it's a binary predicate so it

00:20:57,790 --> 00:21:03,640
kind of have to look something like this

00:21:00,330 --> 00:21:05,590
but what kind of ordering relationship

00:21:03,640 --> 00:21:08,320
is needed for the elements of a

00:21:05,590 --> 00:21:15,130
collection because we do need to compare

00:21:08,320 --> 00:21:18,040
them by some criteria first things we

00:21:15,130 --> 00:21:19,840
can think about if we reflect on the

00:21:18,040 --> 00:21:23,970
mathematical underpinnings are evil

00:21:19,840 --> 00:21:26,710
activity of course the anti symmetry if

00:21:23,970 --> 00:21:28,690
when we need this comp reparation to be

00:21:26,710 --> 00:21:33,250
an under symmetrical that's kind of

00:21:28,690 --> 00:21:36,760
intuitive and of course transitivity so

00:21:33,250 --> 00:21:40,030
this will be our first take on it what

00:21:36,760 --> 00:21:42,790
we call partial ordering is this

00:21:40,030 --> 00:21:46,450
sufficient for a compare call algorithm

00:21:42,790 --> 00:21:48,760
and for a compare predicate and if we

00:21:46,450 --> 00:21:51,960
look at some very very simple examples

00:21:48,760 --> 00:21:53,610
the very first examples that do

00:21:51,960 --> 00:21:56,960
usually see when they meet this

00:21:53,610 --> 00:21:58,500
algorithm are sorting strings

00:21:56,960 --> 00:22:03,570
lexicographically case-sensitive

00:21:58,500 --> 00:22:06,000
insensitive what having so so far the

00:22:03,570 --> 00:22:09,030
best meets their expectation and the

00:22:06,000 --> 00:22:14,850
unbalanced int seems rather handy to use

00:22:09,030 --> 00:22:17,700
and no unexpected results this is up

00:22:14,850 --> 00:22:20,400
until you have to compare some other

00:22:17,700 --> 00:22:22,770
data structures that you design and in

00:22:20,400 --> 00:22:26,760
this case I picked a very simple data

00:22:22,770 --> 00:22:30,480
structure like a 2d point and I give

00:22:26,760 --> 00:22:33,090
them such a predicate to compare points

00:22:30,480 --> 00:22:35,300
and I asked them is this a good

00:22:33,090 --> 00:22:38,790
predicate to compare to the points and

00:22:35,300 --> 00:22:42,660
they're very puzzled because they never

00:22:38,790 --> 00:22:44,040
see why this is not at all an

00:22:42,660 --> 00:22:48,570
appropriate predicate for comparing

00:22:44,040 --> 00:22:53,730
plates and I think this visualization

00:22:48,570 --> 00:22:57,750
helps here if we have a concrete example

00:22:53,730 --> 00:23:00,420
let's say we have three points we see

00:22:57,750 --> 00:23:03,570
here in the picture that X 1 is less

00:23:00,420 --> 00:23:06,420
than X 2 but my 1 it's greater than Y 2

00:23:03,570 --> 00:23:09,690
and you can see the layout in the 2d

00:23:06,420 --> 00:23:13,050
planar so if we examine our given

00:23:09,690 --> 00:23:16,860
compare predicate we can see that P 2

00:23:13,050 --> 00:23:19,560
and P 1 are unordered because our

00:23:16,860 --> 00:23:24,810
compare yields false in both directions

00:23:19,560 --> 00:23:29,370
and P 1 mp3 Ravn are ordered because of

00:23:24,810 --> 00:23:42,140
the same conditions but P 2 and 3 P 3

00:23:29,370 --> 00:23:45,210
are ordered yeah the way the these very

00:23:42,140 --> 00:23:48,540
axioms and trying out these very axioms

00:23:45,210 --> 00:23:50,730
and deciding if we can establish a

00:23:48,540 --> 00:23:53,250
relationship of ordering between those

00:23:50,730 --> 00:23:56,280
between those points with just partial

00:23:53,250 --> 00:24:01,070
ordering so basically I'm running

00:23:56,280 --> 00:24:03,330
through the this predicate this lambda

00:24:01,070 --> 00:24:05,760
through the concrete example I have in

00:24:03,330 --> 00:24:08,250
the picture there so

00:24:05,760 --> 00:24:12,390
just let me know if something is unclear

00:24:08,250 --> 00:24:14,070
do interrupt me I don't mind so as we

00:24:12,390 --> 00:24:16,320
can see in the graphical depiction we

00:24:14,070 --> 00:24:20,010
can say something according to our

00:24:16,320 --> 00:24:23,940
chosen predicate that we designed about

00:24:20,010 --> 00:24:26,460
p2 mp3 but we cannot give a ruling as to

00:24:23,940 --> 00:24:30,170
ordering relation between p1 and p2 or

00:24:26,460 --> 00:24:35,520
p1 and p3 that's why there in red there

00:24:30,170 --> 00:24:38,010
so if we define equivalence as the

00:24:35,520 --> 00:24:39,510
problem that we're having with the red

00:24:38,010 --> 00:24:43,500
lines there in the group in the picture

00:24:39,510 --> 00:24:46,620
and we say that a and B are equivalent

00:24:43,500 --> 00:24:50,220
if the compare the our chosen comparator

00:24:46,620 --> 00:24:53,400
yields false in both directions then we

00:24:50,220 --> 00:24:55,800
can say that in our example p2 p2 is

00:24:53,400 --> 00:24:58,290
equivalent to p1 according to our

00:24:55,800 --> 00:25:03,990
predicate saying p1 is equivalent to p3

00:24:58,290 --> 00:25:09,150
but p2 is less than P 3 everyone is

00:25:03,990 --> 00:25:13,440
following so far so clearly we failed in

00:25:09,150 --> 00:25:16,140
defining a proper ordering relations in

00:25:13,440 --> 00:25:20,070
this example for such a simple structure

00:25:16,140 --> 00:25:24,120
like a 2d point let's not even think

00:25:20,070 --> 00:25:26,340
about much more complex situations so

00:25:24,120 --> 00:25:28,260
partial ordering relationship is not

00:25:26,340 --> 00:25:32,760
enough compare needs a stronger

00:25:28,260 --> 00:25:36,030
constraint and next level we can think

00:25:32,760 --> 00:25:37,740
about is strict weak ordering and we

00:25:36,030 --> 00:25:40,110
don't discover this by chance we just

00:25:37,740 --> 00:25:43,320
have to look up documentation for STL

00:25:40,110 --> 00:25:45,600
algorithms and when we look this up we

00:25:43,320 --> 00:25:47,730
need to understand what strict weak

00:25:45,600 --> 00:25:50,790
ordering means if we're using some

00:25:47,730 --> 00:25:53,850
custom defined type that we provide into

00:25:50,790 --> 00:25:56,820
the algo algorithm so cyclic ordering

00:25:53,850 --> 00:25:58,830
means partial ordering plus sensitivity

00:25:56,820 --> 00:26:01,860
of equivalence and we saw that

00:25:58,830 --> 00:26:03,600
equivalence we define it that when the

00:26:01,860 --> 00:26:08,040
comparator yields false in both

00:26:03,600 --> 00:26:11,820
directions for the two inputs so if we

00:26:08,040 --> 00:26:14,070
add this to our axioms and we add

00:26:11,820 --> 00:26:17,790
transitivity of equivalents for stick

00:26:14,070 --> 00:26:18,690
recording we can extend it even further

00:26:17,790 --> 00:26:21,630
and

00:26:18,690 --> 00:26:24,300
say that compare function induces a

00:26:21,630 --> 00:26:27,030
strict total ordering on the equivalence

00:26:24,300 --> 00:26:30,210
classes determined by our equivalence

00:26:27,030 --> 00:26:34,380
function but we're getting very esoteric

00:26:30,210 --> 00:26:36,030
right now and in more simple terms the

00:26:34,380 --> 00:26:37,860
equivalence relations and the

00:26:36,030 --> 00:26:39,750
equivalence classes partition the

00:26:37,860 --> 00:26:41,370
elements of the set and are totally

00:26:39,750 --> 00:26:47,310
ordered with regards to the less

00:26:41,370 --> 00:26:49,860
operation and we go a step further and

00:26:47,310 --> 00:26:53,280
try to refine our predicate for sorting

00:26:49,860 --> 00:26:58,650
points and we come up with some other

00:26:53,280 --> 00:27:00,630
criteria for sorting points and in this

00:26:58,650 --> 00:27:07,670
situation is basically the distance from

00:27:00,630 --> 00:27:07,670
origin is this proper compare predicate

00:27:08,210 --> 00:27:17,960
well yes it meets the requirements that

00:27:11,940 --> 00:27:17,960
we set on our algorithm how about this

00:27:18,110 --> 00:27:26,640
what is this predicate trying to do

00:27:20,670 --> 00:27:29,280
can anyone state in words exactly

00:27:26,640 --> 00:27:33,930
lexicographic compares so what we're

00:27:29,280 --> 00:27:37,170
trying to do is basically pick apart the

00:27:33,930 --> 00:27:41,660
object and compare by the first part

00:27:37,170 --> 00:27:45,300
which is our x-coordinate and in case of

00:27:41,660 --> 00:27:47,160
equivalence regarding the first part we

00:27:45,300 --> 00:27:50,250
compare by the second part which is the

00:27:47,160 --> 00:27:53,490
y component for out to the point so in

00:27:50,250 --> 00:27:56,760
this case we see that the two ifs here

00:27:53,490 --> 00:27:58,710
handle the cases with it's a little

00:27:56,760 --> 00:28:01,140
backwards written because we try to

00:27:58,710 --> 00:28:04,470
reuse only less than operator not

00:28:01,140 --> 00:28:07,710
greater than because we don't want to

00:28:04,470 --> 00:28:12,090
impose further requirements on the type

00:28:07,710 --> 00:28:16,710
so the two if cases handle the case of

00:28:12,090 --> 00:28:18,570
equivalence over X so if we reach the

00:28:16,710 --> 00:28:20,280
return statement we can say that the two

00:28:18,570 --> 00:28:23,370
points are equivalent with regards to

00:28:20,280 --> 00:28:28,140
the x coordinate and then we compare by

00:28:23,370 --> 00:28:29,640
Y so the strategy is what it's often

00:28:28,140 --> 00:28:31,070
called the dictionary order or

00:28:29,640 --> 00:28:34,370
lexicographic compare

00:28:31,070 --> 00:28:40,280
like Titus said and we have several of

00:28:34,370 --> 00:28:42,110
these examples in s STL for STD per as

00:28:40,280 --> 00:28:43,610
the deeper defines it's six comparative

00:28:42,110 --> 00:28:45,230
comparison operations in terms of

00:28:43,610 --> 00:28:50,090
corresponding operations on the pair's

00:28:45,230 --> 00:28:53,360
components and many others so let's go

00:28:50,090 --> 00:28:58,430
back to this huge array of requirements

00:28:53,360 --> 00:29:03,830
and pick just a few the ones that serve

00:28:58,430 --> 00:29:07,280
our purpose for this talk and we can

00:29:03,830 --> 00:29:09,470
define a semi-regular in terms of a type

00:29:07,280 --> 00:29:11,300
that is before constructible move

00:29:09,470 --> 00:29:13,220
constructible nowadays copy

00:29:11,300 --> 00:29:16,340
constructible move assignable copy

00:29:13,220 --> 00:29:20,810
assignable swappable and of course

00:29:16,340 --> 00:29:23,870
destructible and we can define regular

00:29:20,810 --> 00:29:26,830
as in Stepanov regular I very much like

00:29:23,870 --> 00:29:29,330
that term when Titus said yesterday so

00:29:26,830 --> 00:29:31,880
we can define Stepanov regular as

00:29:29,330 --> 00:29:36,560
something that is semi regular plus

00:29:31,880 --> 00:29:38,660
equality comparable comparable but it's

00:29:36,560 --> 00:29:41,710
very difficult and we have to carefully

00:29:38,660 --> 00:29:44,990
define what equality comparable means

00:29:41,710 --> 00:29:47,450
STL in general assumes equality is

00:29:44,990 --> 00:29:50,120
always defined or at least equivalence

00:29:47,450 --> 00:29:52,700
relations and STL algorithms assume

00:29:50,120 --> 00:29:56,330
regular data structures that's why we're

00:29:52,700 --> 00:29:59,240
talking about about this so before we

00:29:56,330 --> 00:30:01,370
get to equality let's talk about less

00:29:59,240 --> 00:30:04,820
than comparable because we saw this in

00:30:01,370 --> 00:30:08,660
our example so if we put up together the

00:30:04,820 --> 00:30:11,960
same axioms and replace comp with less

00:30:08,660 --> 00:30:14,480
than we get this set of axioms to define

00:30:11,960 --> 00:30:18,040
less than comparable and it's very

00:30:14,480 --> 00:30:21,200
useful for us when restraining and

00:30:18,040 --> 00:30:25,790
constraining our STL algorithms such a

00:30:21,200 --> 00:30:28,780
sort and if we're visiting equality

00:30:25,790 --> 00:30:31,490
comparable the actions change a little

00:30:28,780 --> 00:30:32,840
instead of irreflexive ax t we're

00:30:31,490 --> 00:30:35,360
talking about reflexivity

00:30:32,840 --> 00:30:38,210
instead of anti symmetry we are talking

00:30:35,360 --> 00:30:40,690
about symmetry of equality and of course

00:30:38,210 --> 00:30:40,690
transitivity

00:30:41,290 --> 00:30:47,140
and the fact that operator equal equals

00:30:43,720 --> 00:30:49,630
and its results should have standard

00:30:47,140 --> 00:30:54,340
semantics we cannot impose our custom

00:30:49,630 --> 00:30:56,200
behavior on equals equal equal has to

00:30:54,340 --> 00:30:59,620
mean the same thing that it means in

00:30:56,200 --> 00:31:04,630
mathematics and Alexandre Stepanov has

00:30:59,620 --> 00:31:08,530
even more strict view on this in terms

00:31:04,630 --> 00:31:11,110
of that operator not equals should be

00:31:08,530 --> 00:31:15,190
the exact opposite of operator equals

00:31:11,110 --> 00:31:32,920
equals but we don't have that in C++

00:31:15,190 --> 00:31:35,440
you'll just have to well behave I'm

00:31:32,920 --> 00:31:39,130
thinking in general when you define

00:31:35,440 --> 00:31:42,430
equality for types in that in the true

00:31:39,130 --> 00:31:44,050
mathematical sense if two type if two

00:31:42,430 --> 00:31:47,680
objects are not equal should be the

00:31:44,050 --> 00:31:49,390
exact negation of equality you cannot

00:31:47,680 --> 00:31:53,670
define something that's not equal as

00:31:49,390 --> 00:31:53,670
some please something slightly different

00:32:03,570 --> 00:32:09,070
no no I was just referring to the fact

00:32:06,310 --> 00:32:10,930
that when we define the operator not

00:32:09,070 --> 00:32:13,480
equal should be the exact opposite of

00:32:10,930 --> 00:32:15,520
equal for example when we define greater

00:32:13,480 --> 00:32:17,520
than or equal should be the exact

00:32:15,520 --> 00:32:21,730
opposite of less than not something else

00:32:17,520 --> 00:32:24,610
so but that battle was lost long ago so

00:32:21,730 --> 00:32:27,220
we just maybe things would be better for

00:32:24,610 --> 00:32:29,500
us with spaceship operator in terms of

00:32:27,220 --> 00:32:31,930
unifying and a coherent view of what

00:32:29,500 --> 00:32:36,730
ordering is and I'm going to show that a

00:32:31,930 --> 00:32:39,820
few slides later on so photo types that

00:32:36,730 --> 00:32:41,860
are both equality comparable and less

00:32:39,820 --> 00:32:42,970
than comparable the C++ standard library

00:32:41,860 --> 00:32:46,330
makes a clear distinction between

00:32:42,970 --> 00:32:48,850
equality and equivalence such as we

00:32:46,330 --> 00:32:50,110
define them earlier and of course

00:32:48,850 --> 00:32:51,900
equality is a special case of

00:32:50,110 --> 00:32:54,780
equivalence

00:32:51,900 --> 00:32:57,090
and equality is both an equivalence

00:32:54,780 --> 00:33:00,690
relation and as a part of a partial

00:32:57,090 --> 00:33:05,340
order we saw the axioms and it's clear

00:33:00,690 --> 00:33:08,060
from that but defining equality is very

00:33:05,340 --> 00:33:10,320
different difficult for example

00:33:08,060 --> 00:33:13,710
logicians might define equality with the

00:33:10,320 --> 00:33:16,350
following C as statement that two values

00:33:13,710 --> 00:33:20,040
are equal if for any predicate applied

00:33:16,350 --> 00:33:22,560
to them the result is equal but that's

00:33:20,040 --> 00:33:26,190
not very practical for us because how

00:33:22,560 --> 00:33:28,590
can we try out any predicate so defining

00:33:26,190 --> 00:33:31,740
quality is hard and Stepanov himself

00:33:28,590 --> 00:33:33,900
says that and he ultimately reaches this

00:33:31,740 --> 00:33:35,280
definition as two objects are equal if

00:33:33,900 --> 00:33:38,550
their corresponding parts are equal

00:33:35,280 --> 00:33:40,500
applied recursively of course including

00:33:38,550 --> 00:33:43,440
remote parts but not comparing their

00:33:40,500 --> 00:33:45,780
addresses excluding in essential

00:33:43,440 --> 00:33:48,180
components and excluding components

00:33:45,780 --> 00:33:52,650
which identify related objects talk

00:33:48,180 --> 00:33:54,690
about whole-part semantics so even for

00:33:52,650 --> 00:33:59,310
Stepanov this definition is hard to

00:33:54,690 --> 00:34:01,200
reach let's get the audience a little

00:33:59,310 --> 00:34:07,350
bit how many of you are still still

00:34:01,200 --> 00:34:07,650
stuck on an old compiler nah I'm getting

00:34:07,350 --> 00:34:16,919
there

00:34:07,650 --> 00:34:22,560
C++ 11 excellent 14 even better 17 Wow

00:34:16,919 --> 00:34:25,409
good crowd so we have high hopes in

00:34:22,560 --> 00:34:29,429
defining equality and a coherent view

00:34:25,409 --> 00:34:32,010
like I mentioned earlier C++ 20 gives us

00:34:29,429 --> 00:34:34,140
3-way comparison and just brings

00:34:32,010 --> 00:34:40,110
consistency due to comparison operations

00:34:34,140 --> 00:34:43,050
with a spaceship operator and we define

00:34:40,110 --> 00:34:47,250
as the result of the spaceship operator

00:34:43,050 --> 00:34:49,950
as less than zero if a is less than B

00:34:47,250 --> 00:34:53,060
greater than zero otherwise or equal to

00:34:49,950 --> 00:34:56,760
zero if the two are equal or equivalent

00:34:53,060 --> 00:34:59,430
if we want to go in further details and

00:34:56,760 --> 00:35:03,990
examine the relation strength with

00:34:59,430 --> 00:35:05,440
between the operations the spaceship or

00:35:03,990 --> 00:35:09,280
the three weight comparison is

00:35:05,440 --> 00:35:11,650
much more refined in how it defines your

00:35:09,280 --> 00:35:15,090
the the equality and you alternate

00:35:11,650 --> 00:35:17,740
between the types so we have several

00:35:15,090 --> 00:35:21,340
strength classes and several ordering

00:35:17,740 --> 00:35:22,930
relations possible and if we define our

00:35:21,340 --> 00:35:25,950
custom types we really have to think

00:35:22,930 --> 00:35:28,540
about it and how do we choose which

00:35:25,950 --> 00:35:33,160
relations strength is appropriate for

00:35:28,540 --> 00:35:35,590
our type and as a personal preference I

00:35:33,160 --> 00:35:38,050
would really like to see these this

00:35:35,590 --> 00:35:40,720
operator implemented in common

00:35:38,050 --> 00:35:43,990
vocabulary types but I don't think we're

00:35:40,720 --> 00:35:46,890
going to see that very soon but I am I

00:35:43,990 --> 00:36:13,720
would like to see them implement it

00:35:46,890 --> 00:36:17,290
maybe in terms you mean that if a user

00:36:13,720 --> 00:36:19,860
has defined a specific operation that

00:36:17,290 --> 00:36:28,120
has precedence over the generated

00:36:19,860 --> 00:36:30,250
three-way comparison and there's also

00:36:28,120 --> 00:36:33,700
the performance issues to consider

00:36:30,250 --> 00:36:36,130
because you would have to be careful in

00:36:33,700 --> 00:36:38,380
when implementing that maybe some

00:36:36,130 --> 00:36:47,080
operation is much faster to implement

00:36:38,380 --> 00:36:54,880
than all three together so here is

00:36:47,080 --> 00:36:57,070
tricky yeah I'm still optimistic and if

00:36:54,880 --> 00:36:58,930
we're talking about new data types new

00:36:57,070 --> 00:37:02,680
vocabulary types we have to mention

00:36:58,930 --> 00:37:05,940
optional and it's a type that you

00:37:02,680 --> 00:37:09,070
express a value or not a value or

00:37:05,940 --> 00:37:12,790
possibly an answer or an object with

00:37:09,070 --> 00:37:14,290
delayed initialization and using a

00:37:12,790 --> 00:37:16,960
common vocabulary type for these cases

00:37:14,290 --> 00:37:18,360
raises the level of abstraction it's a

00:37:16,960 --> 00:37:20,010
good thing

00:37:18,360 --> 00:37:22,080
and makes it easier for others to

00:37:20,010 --> 00:37:26,970
understand what your code is doing so

00:37:22,080 --> 00:37:31,770
it's a simplification clearly much more

00:37:26,970 --> 00:37:34,290
readable than error checking and of

00:37:31,770 --> 00:37:37,140
course STD optional extends these

00:37:34,290 --> 00:37:39,600
ordering operations which is what we're

00:37:37,140 --> 00:37:42,030
talking about today and an empty

00:37:39,600 --> 00:37:44,550
optional compares less than any option

00:37:42,030 --> 00:37:48,620
that contains a T so you can use it in

00:37:44,550 --> 00:37:53,790
the exact same context as if it were a T

00:37:48,620 --> 00:37:56,490
so library these designers and we as

00:37:53,790 --> 00:38:00,840
types designers really have to think

00:37:56,490 --> 00:38:05,130
when building such types in terms of the

00:38:00,840 --> 00:38:07,320
ordering linear relationships and using

00:38:05,130 --> 00:38:09,360
STD optional as vocab realize a lot us

00:38:07,320 --> 00:38:13,560
to simplify code as I said earlier and

00:38:09,360 --> 00:38:15,720
to compose easily way more easily see

00:38:13,560 --> 00:38:19,400
where I'm going with this I call this

00:38:15,720 --> 00:38:23,610
the Simon brand slide so there's a

00:38:19,400 --> 00:38:26,760
proposal on extending STD optional with

00:38:23,610 --> 00:38:30,450
a monadic interface and this would allow

00:38:26,760 --> 00:38:33,930
chaining of such optionals with and then

00:38:30,450 --> 00:38:37,290
or else functions much like in other

00:38:33,930 --> 00:38:44,340
functional languages we'll see how that

00:38:37,290 --> 00:38:58,470
goes titus gives a clear sign there it's

00:38:44,340 --> 00:39:15,000
a it's an ambitious effort looking for

00:38:58,470 --> 00:39:16,860
that yeah compromises okay if you want

00:39:15,000 --> 00:39:19,140
to read about the proposal I put the

00:39:16,860 --> 00:39:23,100
link there it's an interesting read at

00:39:19,140 --> 00:39:25,950
least but wait we have another cool

00:39:23,100 --> 00:39:30,410
thing on the block here optional of tier

00:39:25,950 --> 00:39:36,080
F and defining it's operator equals

00:39:30,410 --> 00:39:39,110
and if you read about this the community

00:39:36,080 --> 00:39:40,790
is very split around this issue so lots

00:39:39,110 --> 00:39:44,980
of things to consider in terms of

00:39:40,790 --> 00:39:48,980
rebinding that shallow comparison and

00:39:44,980 --> 00:39:52,970
people are still in flux about whether

00:39:48,980 --> 00:39:58,400
we should have or if we need this in the

00:39:52,970 --> 00:40:00,410
standard so it's complicated going to

00:39:58,400 --> 00:40:05,330
still view another vocabulary type that

00:40:00,410 --> 00:40:07,910
is standard and a string view is

00:40:05,330 --> 00:40:14,120
basically a constant continuous sequence

00:40:07,910 --> 00:40:15,830
of char like objects and it's it met it

00:40:14,120 --> 00:40:18,500
does not manage the storage it refers to

00:40:15,830 --> 00:40:21,290
and of course the lifetime is up to the

00:40:18,500 --> 00:40:23,390
caller to manage I have a whole talk

00:40:21,290 --> 00:40:26,260
about string view that happened in the

00:40:23,390 --> 00:40:30,290
past you can catch the recording later

00:40:26,260 --> 00:40:35,020
but suffice to say that string view is

00:40:30,290 --> 00:40:37,850
an interesting piece of type design and

00:40:35,020 --> 00:40:40,160
for better or for worse we have to live

00:40:37,850 --> 00:40:44,300
with it and we have to understand it and

00:40:40,160 --> 00:40:48,100
use it properly and string view as we

00:40:44,300 --> 00:40:52,850
have it today is a borough type and that

00:40:48,100 --> 00:40:54,860
means that it's succeed admirably at the

00:40:52,850 --> 00:40:57,830
goal of dropping replacement for

00:40:54,860 --> 00:41:01,640
constraint graph parameters problem

00:40:57,830 --> 00:41:03,740
being that it's not an object type nor a

00:41:01,640 --> 00:41:06,650
value type although it likes to pretend

00:41:03,740 --> 00:41:09,830
it's a value type it's a new kind of

00:41:06,650 --> 00:41:12,320
type and we've seen this kind of types

00:41:09,830 --> 00:41:15,500
before in the standard library but I

00:41:12,320 --> 00:41:18,080
think string view is much more prominent

00:41:15,500 --> 00:41:20,000
and much more important for us to

00:41:18,080 --> 00:41:23,900
understand to the l to deal with because

00:41:20,000 --> 00:41:26,750
it's deceptively appealing and easy to

00:41:23,900 --> 00:41:29,000
use it's something very interesting and

00:41:26,750 --> 00:41:31,460
I that I remember the first time I

00:41:29,000 --> 00:41:35,140
learned about it I immediately went I

00:41:31,460 --> 00:41:38,750
should sprinkle this all over my coat so

00:41:35,140 --> 00:41:40,760
watch out for that borrow types are

00:41:38,750 --> 00:41:43,099
essentially references to existing

00:41:40,760 --> 00:41:45,859
objects they lack ownership the

00:41:43,099 --> 00:41:47,569
usually short-lived the journey can do

00:41:45,859 --> 00:41:49,569
without an assignment operator although

00:41:47,569 --> 00:41:52,160
this is not the case for string view

00:41:49,569 --> 00:41:54,229
they generally appear only in function

00:41:52,160 --> 00:41:57,859
parameter lists and cannot be stored

00:41:54,229 --> 00:42:01,519
safely or returned from functions you

00:41:57,859 --> 00:42:03,259
really have to think about this string

00:42:01,519 --> 00:42:07,009
view is perhaps the first mainstream

00:42:03,259 --> 00:42:09,170
borrow type but watch out for the fact

00:42:07,009 --> 00:42:13,039
that string V is assignable and the

00:42:09,170 --> 00:42:14,479
segment has shallow semantics but of

00:42:13,039 --> 00:42:16,369
course the viewed strings are immutable

00:42:14,479 --> 00:42:19,039
and that helps a lot

00:42:16,369 --> 00:42:20,900
meanwhile comparison has deep semantics

00:42:19,039 --> 00:42:25,460
in terms that it does lexicography

00:42:20,900 --> 00:42:28,910
compare over the strings so it's a non

00:42:25,460 --> 00:42:31,759
owning reference type and when the

00:42:28,910 --> 00:42:33,650
underlying data is extant or constant we

00:42:31,759 --> 00:42:36,529
can determine whether the rest of its ug

00:42:33,650 --> 00:42:40,329
usage still looks regular although it's

00:42:36,529 --> 00:42:42,890
not as per Stefano definition so

00:42:40,329 --> 00:42:44,690
generally when used properly as a

00:42:42,890 --> 00:42:47,420
function parameter for example string V

00:42:44,690 --> 00:42:51,440
works well as if we can squint a little

00:42:47,420 --> 00:42:55,609
and pretend it's regular but I give you

00:42:51,440 --> 00:42:58,160
span the C++ style type that's so

00:42:55,609 --> 00:43:01,549
confusing even the world's best C++

00:42:58,160 --> 00:43:04,789
experts cannot agree on how to properly

00:43:01,549 --> 00:43:07,489
design and constrain it and think a

00:43:04,789 --> 00:43:11,569
review as in string view but with

00:43:07,489 --> 00:43:26,690
mutable underlying data kind of like

00:43:11,569 --> 00:43:32,630
this yeah sort of sort of yeah it's

00:43:26,690 --> 00:43:34,759
that's more general and there are lots

00:43:32,630 --> 00:43:37,640
of resources and discussions on span

00:43:34,759 --> 00:43:40,670
online plenty of material to go through

00:43:37,640 --> 00:43:42,650
unfortunately not very coherent so

00:43:40,670 --> 00:43:43,069
you'll have to make your own judgment on

00:43:42,650 --> 00:43:45,410
that

00:43:43,069 --> 00:43:49,069
so no known in reference types like

00:43:45,410 --> 00:43:51,140
stream viewers span for those types you

00:43:49,069 --> 00:43:54,710
need more contextual information when

00:43:51,140 --> 00:43:56,170
working with an such an instance things

00:43:54,710 --> 00:43:59,440
to consider are shallow

00:43:56,170 --> 00:44:02,319
coppy shallow versus deep compare const

00:43:59,440 --> 00:44:06,760
mutability the existence of operator

00:44:02,319 --> 00:44:11,500
equals equals and my call to action to

00:44:06,760 --> 00:44:13,619
you would be make your types regular the

00:44:11,500 --> 00:44:18,750
best regular types are those that model

00:44:13,619 --> 00:44:21,160
built-in types and most closely behaved

00:44:18,750 --> 00:44:23,859
without having any dependent

00:44:21,160 --> 00:44:27,940
preconditions so they're independent of

00:44:23,859 --> 00:44:32,920
the context of their usage think int or

00:44:27,940 --> 00:44:34,869
standard string in this regard for non

00:44:32,920 --> 00:44:38,410
owning reference types like string view

00:44:34,869 --> 00:44:40,710
or span clearly you need more contextual

00:44:38,410 --> 00:44:44,650
information when working with those and

00:44:40,710 --> 00:44:46,630
as to not fool ourselves we should try

00:44:44,650 --> 00:44:48,910
to restrict those types to being semi

00:44:46,630 --> 00:44:51,099
regular and be explicit about it

00:44:48,910 --> 00:44:57,309
to avoid confusion to your users when

00:44:51,099 --> 00:45:00,160
you define that I would like to close

00:44:57,309 --> 00:45:02,440
with a personal statement that clearly

00:45:00,160 --> 00:45:05,589
this one of the one was one of the most

00:45:02,440 --> 00:45:07,630
fun talks that I had right and mainly

00:45:05,589 --> 00:45:09,549
because of some wonderful people that

00:45:07,630 --> 00:45:13,240
wrote excellent articles about the topic

00:45:09,549 --> 00:45:15,069
and I want to thank them for their work

00:45:13,240 --> 00:45:17,920
and I want to encourage you to read

00:45:15,069 --> 00:45:20,730
their work because it will change the

00:45:17,920 --> 00:45:24,099
way you think about designing your types

00:45:20,730 --> 00:45:26,680
I've put on several references here I

00:45:24,099 --> 00:45:28,869
don't expect you to reach out for them

00:45:26,680 --> 00:45:31,630
right now but when you do get the slides

00:45:28,869 --> 00:45:35,849
or you get them on video I do encourage

00:45:31,630 --> 00:45:35,849
you to read carefully through them

00:45:36,089 --> 00:45:42,910
plentiful material on this topic and

00:45:40,410 --> 00:45:47,530
excellent although sometimes

00:45:42,910 --> 00:45:49,220
controversial opinions this is just some

00:45:47,530 --> 00:45:53,480
of them

00:45:49,220 --> 00:46:02,690
and this is why I care about regular

00:45:53,480 --> 00:46:07,520
types thank you I do have a few minutes

00:46:02,690 --> 00:46:11,300
for questions if you have them just try

00:46:07,520 --> 00:46:12,140
to line up to the mic maybe or I'll

00:46:11,300 --> 00:46:27,950
repeat the question

00:46:12,140 --> 00:46:29,690
I don't mind the question was are there

00:46:27,950 --> 00:46:34,250
any STL algorithms that actually

00:46:29,690 --> 00:46:38,589
requires the pun of regularity kind you

00:46:34,250 --> 00:46:42,680
should pretend that they require it yeah

00:46:38,589 --> 00:46:46,400
not exactly to be fair but you should

00:46:42,680 --> 00:46:50,900
pretend that that they required if if

00:46:46,400 --> 00:46:53,240
you want to have and not saying protect

00:46:50,900 --> 00:46:55,790
yourself against unexpected results I'm

00:46:53,240 --> 00:46:58,369
saying if you want the reader of your

00:46:55,790 --> 00:47:02,030
code to really understand what what goes

00:46:58,369 --> 00:47:05,630
on you should really strive for Stepanov

00:47:02,030 --> 00:47:08,720
regular okay maybe we you can disregard

00:47:05,630 --> 00:47:12,200
movable or swappable or in some

00:47:08,720 --> 00:47:14,089
situations but I think I think you

00:47:12,200 --> 00:47:16,490
should strive to at least properly

00:47:14,089 --> 00:47:19,550
define what it means if if you define

00:47:16,490 --> 00:47:23,450
equality for your type mean it equality

00:47:19,550 --> 00:47:31,790
not something else try to try to that it

00:47:23,450 --> 00:47:35,109
means really quality so every also takes

00:47:31,790 --> 00:47:37,010
is a separate either provided in quality

00:47:35,109 --> 00:47:40,220
is there any reason to think of them

00:47:37,010 --> 00:47:44,270
differently rather than just the most

00:47:40,220 --> 00:47:46,670
natural equality form rather because if

00:47:44,270 --> 00:47:48,920
you say that their equality is one true

00:47:46,670 --> 00:47:51,589
thing yeah there shouldn't be another

00:47:48,920 --> 00:47:53,560
one that you could use it with love I'm

00:47:51,589 --> 00:47:57,700
not sure I understand the question

00:47:53,560 --> 00:47:57,700
titus did you understand how

00:48:00,660 --> 00:48:15,450
where you only care about her you don't

00:48:04,170 --> 00:48:17,730
care about case but I think Titus made

00:48:15,450 --> 00:48:20,280
the point yesterday as to not define

00:48:17,730 --> 00:48:22,950
such an operator just for the sake of

00:48:20,280 --> 00:48:25,530
using some container like map or

00:48:22,950 --> 00:48:29,039
something like that so if you define if

00:48:25,530 --> 00:48:30,839
you need to sort by some criteria use

00:48:29,039 --> 00:48:33,960
that criteria explicitly in some lambda

00:48:30,839 --> 00:48:36,750
predicate and not strap that in your

00:48:33,960 --> 00:48:39,390
type because that that will define

00:48:36,750 --> 00:48:42,180
forever and every usage of your type not

00:48:39,390 --> 00:48:44,190
not just in the context of that specific

00:48:42,180 --> 00:48:46,530
algorithm that you invoke or that

00:48:44,190 --> 00:48:49,109
container that you put it in rather so

00:48:46,530 --> 00:48:52,829
if it's something that's contextual like

00:48:49,109 --> 00:48:56,220
I want to sort by first name now define

00:48:52,829 --> 00:49:01,049
it ad-hoc there and not strap it to the

00:48:56,220 --> 00:49:08,339
type itself I don't know if I answered

00:49:01,049 --> 00:49:11,039
your questions or not yeah so what do

00:49:08,339 --> 00:49:13,500
you think about semantic invariants that

00:49:11,039 --> 00:49:14,940
these operators should have as opposed

00:49:13,500 --> 00:49:17,760
to just syntactic all that comparison

00:49:14,940 --> 00:49:19,230
should be like translator symmetric for

00:49:17,760 --> 00:49:22,829
example you mentioned string views

00:49:19,230 --> 00:49:24,450
having their quality be deep but given

00:49:22,829 --> 00:49:26,460
that they don't own their contents you

00:49:24,450 --> 00:49:28,859
could change the underlying strings and

00:49:26,460 --> 00:49:31,799
to Constituent views could be equal one

00:49:28,859 --> 00:49:34,230
moment I'm not equal the next one so do

00:49:31,799 --> 00:49:36,660
you think there's room for harder like

00:49:34,230 --> 00:49:40,410
rules about how these operators should

00:49:36,660 --> 00:49:46,500
interact over time for example that's a

00:49:40,410 --> 00:49:49,349
difficult question I'll try to shorten

00:49:46,500 --> 00:49:51,000
it in terms of how important is the

00:49:49,349 --> 00:49:53,099
distinction between syntactically

00:49:51,000 --> 00:49:54,839
quality and semantic equality for

00:49:53,099 --> 00:49:57,930
example for string views that do deep

00:49:54,839 --> 00:49:59,819
comparison but you can actually for

00:49:57,930 --> 00:50:02,309
example you can restrict the window into

00:49:59,819 --> 00:50:04,799
that string by using remove prefix or is

00:50:02,309 --> 00:50:06,690
this something you're referring to even

00:50:04,799 --> 00:50:09,570
worse you could have two constituent

00:50:06,690 --> 00:50:11,880
views that are equal in time T not

00:50:09,570 --> 00:50:13,470
people's want because you on the other

00:50:11,880 --> 00:50:16,550
hand change the underlying extremely

00:50:13,470 --> 00:50:20,550
appointed to that ties into the whole

00:50:16,550 --> 00:50:24,210
part semantics of the the whole Stepanov

00:50:20,550 --> 00:50:27,990
design fundamental principle still you

00:50:24,210 --> 00:50:31,740
is not a standalone data type it's not

00:50:27,990 --> 00:50:36,020
fully isolated it has external parts so

00:50:31,740 --> 00:50:39,510
in in that regard it's hard for us to be

00:50:36,020 --> 00:50:43,080
pure in terms of defining semantically

00:50:39,510 --> 00:50:45,450
quality and stick with it because it

00:50:43,080 --> 00:50:48,930
doesn't meet the whole part requirement

00:50:45,450 --> 00:50:53,520
as in the Stepanov description of the

00:50:48,930 --> 00:50:56,190
fundamental principle here so if like I

00:50:53,520 --> 00:50:58,620
said earlier if you know the context of

00:50:56,190 --> 00:51:01,560
usage and for string view and more so

00:50:58,620 --> 00:51:04,620
for span because it's mutable if you

00:51:01,560 --> 00:51:08,160
know the context of usage in some

00:51:04,620 --> 00:51:11,400
scenarios you can guarantee equality as

00:51:08,160 --> 00:51:13,320
ins also semantic equality but that's

00:51:11,400 --> 00:51:14,850
not always the case so you can never

00:51:13,320 --> 00:51:19,080
make such guarantee for sting view for

00:51:14,850 --> 00:51:21,200
example but in general for proper

00:51:19,080 --> 00:51:27,360
regular types yes they should be

00:51:21,200 --> 00:51:31,250
semantically equal as well force types

00:51:27,360 --> 00:51:31,250
like string use all about the context

00:51:31,550 --> 00:51:38,340
any more questions

00:51:34,850 --> 00:51:44,360
no okay then thank you

00:51:38,340 --> 00:51:44,360

YouTube URL: https://www.youtube.com/watch?v=h60zqdzIelE


