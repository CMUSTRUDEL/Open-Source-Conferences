Title: CppCon 2018: Nir Friedman “Understanding Optimizers: Helping the Compiler Help You”
Publication date: 2018-10-12
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Optimizing compilers can seem rather fickle: sometimes they do something very sophisticated that surprises us, other times they fail to perform an optimization we assumed they would. By understanding the limits on their knowledge, and the constraints in their output, we can much more reliably predict when certain kinds of optimizations can occur. This, in turn, allows our designs to be informed by being friendly to the optimizer. 

This talk will discuss concepts fundamental to understanding optimization such as the role of static types, basic blocks, and correctness of emitted code. It will also go through many examples: where inlining does and doesn't occur and why, const propagation, branch pruning, utilizing inferred information/values, the roles of const and value vs reference semantics, etc. It will also show how to help the compiler: writing code in different ways which encourages different optimization strategies. 
— 
Nir Friedman
Quantitative Developer, Tower Research Capital

After completing a PhD in physics, Nir started working doing C++ in low latency and high frequency trading. He's interested in the challenges of writing robust code at scale, and highly configurable code that minimizes performance trade-offs.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,920 --> 00:00:06,810
welcome okay so the titles on the screen

00:00:05,549 --> 00:00:10,469
in case you want to make sure you're in

00:00:06,810 --> 00:00:12,599
the right room so let me start off by

00:00:10,469 --> 00:00:14,789
asking everyone how many of you guys

00:00:12,599 --> 00:00:18,570
have ever looked at the assembly your

00:00:14,789 --> 00:00:20,759
compiler spit out great how many of you

00:00:18,570 --> 00:00:22,769
felt like you understood it to at least

00:00:20,759 --> 00:00:27,089
some degree any amount greater than zero

00:00:22,769 --> 00:00:28,769
of understanding excellent how many of

00:00:27,089 --> 00:00:33,180
you ever looked at the assembly and just

00:00:28,769 --> 00:00:38,520
felt man this assemblies crap ok good so

00:00:33,180 --> 00:00:42,359
about half a couple of weeks ago story

00:00:38,520 --> 00:00:47,129
time I I was flying with my son without

00:00:42,359 --> 00:00:49,079
my wife not a good combination and he

00:00:47,129 --> 00:00:52,230
you know he was staring at some

00:00:49,079 --> 00:00:53,370
airplanes then he said to me potty so I

00:00:52,230 --> 00:00:56,820
picked him up and I ran through the

00:00:53,370 --> 00:00:58,980
airport but I was too late and you know

00:00:56,820 --> 00:01:02,969
everything just came out it wasn't only

00:00:58,980 --> 00:01:05,220
pee I'll say that I was covered he was

00:01:02,969 --> 00:01:06,960
covered I took him to the bathroom all

00:01:05,220 --> 00:01:09,360
of his clothing went in the garbage I

00:01:06,960 --> 00:01:13,110
washed him in the bathtub I ran back out

00:01:09,360 --> 00:01:16,410
with him naked in my arms and I dressed

00:01:13,110 --> 00:01:17,760
him so I'm not as quick to call assembly

00:01:16,410 --> 00:01:23,550
crap anymore once you've seen the real

00:01:17,760 --> 00:01:27,000
thing up close so let's talk about what

00:01:23,550 --> 00:01:29,430
the talk is the idea of the talk is to

00:01:27,000 --> 00:01:32,910
get a better feel for the assembly

00:01:29,430 --> 00:01:34,950
that's produced not all the detailed

00:01:32,910 --> 00:01:37,860
instructions but the overarching

00:01:34,950 --> 00:01:39,810
features especially really critical

00:01:37,860 --> 00:01:44,880
things like in lining and branches

00:01:39,810 --> 00:01:46,710
saying it's try to understand this is

00:01:44,880 --> 00:01:49,020
very important what optimizations can

00:01:46,710 --> 00:01:54,620
you expect a production grade compiler

00:01:49,020 --> 00:01:57,840
to do for you which ones can it not do

00:01:54,620 --> 00:01:59,340
and also to understand how the compiler

00:01:57,840 --> 00:02:01,200
is limited there are some cases where

00:01:59,340 --> 00:02:02,490
it's not the problems now that the

00:02:01,200 --> 00:02:04,500
compiler is not smart enough it's just

00:02:02,490 --> 00:02:07,080
that it's not possible for the compiler

00:02:04,500 --> 00:02:11,969
to know what it needs to know or do what

00:02:07,080 --> 00:02:14,629
you want it to do what the talk is not

00:02:11,969 --> 00:02:17,580
is all these things

00:02:14,629 --> 00:02:19,410
that is to say I'm not giving a hardcore

00:02:17,580 --> 00:02:20,310
tutorial and assembly I'm not qualified

00:02:19,410 --> 00:02:23,250
to do that

00:02:20,310 --> 00:02:24,989
there's no benchmarks I know it's almost

00:02:23,250 --> 00:02:27,090
heretical to not have benchmarks in a

00:02:24,989 --> 00:02:29,069
talk like this but that's just not the

00:02:27,090 --> 00:02:30,390
focus of the talk

00:02:29,069 --> 00:02:31,440
there's nothing about multi-threading

00:02:30,390 --> 00:02:33,629
we're just going to be talking in the

00:02:31,440 --> 00:02:36,629
single threaded universe multi-threading

00:02:33,629 --> 00:02:40,049
is a huge topic and the same goes with

00:02:36,629 --> 00:02:43,470
link time optimization it's just things

00:02:40,049 --> 00:02:46,739
that I'm not going to be covering okay

00:02:43,470 --> 00:02:48,269
so why is it important to to understand

00:02:46,739 --> 00:02:51,000
this well you could just write and

00:02:48,269 --> 00:02:52,670
measure this isn't very efficient right

00:02:51,000 --> 00:02:54,989
you could just randomly type some code

00:02:52,670 --> 00:02:57,239
measure something and then you could

00:02:54,989 --> 00:02:58,650
start making random changes and measure

00:02:57,239 --> 00:03:00,900
again and you can just keep doing this

00:02:58,650 --> 00:03:03,599
but this is a random walk you're not

00:03:00,900 --> 00:03:04,980
gonna get the fast code very quickly so

00:03:03,599 --> 00:03:07,079
it's a lot better if your changes are

00:03:04,980 --> 00:03:11,010
motivated at least if they're educated

00:03:07,079 --> 00:03:13,260
guesses right measurement can be hard if

00:03:11,010 --> 00:03:15,480
you're not the end user you know you

00:03:13,260 --> 00:03:16,890
don't have a benchmark per se right you

00:03:15,480 --> 00:03:18,980
have your benchmark you might be

00:03:16,890 --> 00:03:21,600
different from the users benchmark so

00:03:18,980 --> 00:03:23,040
it's not always good enough to say well

00:03:21,600 --> 00:03:26,010
this code path doesn't matter in my

00:03:23,040 --> 00:03:29,130
benchmarks maybe in your users benchmark

00:03:26,010 --> 00:03:31,019
it will matter and finally you know when

00:03:29,130 --> 00:03:32,639
you design code it's not you know people

00:03:31,019 --> 00:03:35,340
sometimes have this idealized notion

00:03:32,639 --> 00:03:37,620
like they're gonna have this 150 line

00:03:35,340 --> 00:03:38,970
function that accounts for 99% of the

00:03:37,620 --> 00:03:40,410
running time that they care about and

00:03:38,970 --> 00:03:43,650
they're just gonna optimize it at the

00:03:40,410 --> 00:03:45,480
end it doesn't usually end up working

00:03:43,650 --> 00:03:48,720
that way or would be a lot easier if it

00:03:45,480 --> 00:03:51,720
did if you guys went to mark Ellen stock

00:03:48,720 --> 00:03:54,060
on Tuesday he said performance is hard

00:03:51,720 --> 00:03:56,639
to retrofit right and if you have no

00:03:54,060 --> 00:03:58,620
clue what the compiler is producing then

00:03:56,639 --> 00:04:00,120
it's hard to design and and if you can't

00:03:58,620 --> 00:04:02,340
design it and you can't retrofit it then

00:04:00,120 --> 00:04:06,720
you're you're not then performance just

00:04:02,340 --> 00:04:09,389
becomes hard right or harder so what's

00:04:06,720 --> 00:04:10,829
my job I work in the high-frequency

00:04:09,389 --> 00:04:12,900
trading

00:04:10,829 --> 00:04:15,630
I'm not on an infrastructural team I'm

00:04:12,900 --> 00:04:17,070
actually on a trading team itself so

00:04:15,630 --> 00:04:21,030
it's a very small team of people just

00:04:17,070 --> 00:04:24,419
six and there's only maybe four people

00:04:21,030 --> 00:04:27,270
say that our proficient at C++ we have

00:04:24,419 --> 00:04:28,320
lots of responsibilities other than just

00:04:27,270 --> 00:04:32,550
purely

00:04:28,320 --> 00:04:34,320
no cranking out C++ so there's just not

00:04:32,550 --> 00:04:36,240
a lot of time to go around I mean

00:04:34,320 --> 00:04:39,420
there's been times when we said hey

00:04:36,240 --> 00:04:42,630
let's let's optimize this and six months

00:04:39,420 --> 00:04:45,450
go by and we just don't have a chance we

00:04:42,630 --> 00:04:47,700
don't have time so you need to write

00:04:45,450 --> 00:04:49,020
fast code quickly you may not have all

00:04:47,700 --> 00:04:50,880
the time in the world to sit there

00:04:49,020 --> 00:04:52,410
benchmark all the different cases you

00:04:50,880 --> 00:04:55,740
need a good intuition about what is

00:04:52,410 --> 00:04:59,640
likely to be fast or at least some

00:04:55,740 --> 00:05:01,890
intuition maybe not a good one okay so

00:04:59,640 --> 00:05:05,010
why am I giving this talk that's a good

00:05:01,890 --> 00:05:08,250
question I'm not a compiler developer or

00:05:05,010 --> 00:05:10,980
expert or on the standard but I do write

00:05:08,250 --> 00:05:12,450
a lot of code and I looked pretty

00:05:10,980 --> 00:05:15,690
carefully at the assembly that comes out

00:05:12,450 --> 00:05:20,340
and you know I have a mental model that

00:05:15,690 --> 00:05:24,750
works reasonably well for me at least to

00:05:20,340 --> 00:05:29,820
infer certain kind of conclusions so you

00:05:24,750 --> 00:05:31,320
know yeah so I've said that you know

00:05:29,820 --> 00:05:32,910
that the talks not that exciting and

00:05:31,320 --> 00:05:35,190
it's not about these things and that I'm

00:05:32,910 --> 00:05:36,480
not super qualified so the secret to a

00:05:35,190 --> 00:05:39,080
good talk is like the secret to a good

00:05:36,480 --> 00:05:43,230
marriage lower expectations right I

00:05:39,080 --> 00:05:44,820
always tell my wife this okay so let's

00:05:43,230 --> 00:05:47,160
motivate things with a more clear-cut

00:05:44,820 --> 00:05:49,790
example so this is real thing that came

00:05:47,160 --> 00:05:53,670
up in code review a few weeks ago so

00:05:49,790 --> 00:05:55,710
someone was using a vector event and

00:05:53,670 --> 00:05:57,660
they were basically keeping like their

00:05:55,710 --> 00:06:00,330
own size so they wouldn't have to call

00:05:57,660 --> 00:06:04,020
clear because the documentation for

00:06:00,330 --> 00:06:06,360
clear says well this is Oh n right the

00:06:04,020 --> 00:06:09,180
what is clear do it destroys all the

00:06:06,360 --> 00:06:12,540
elements right so if you have a vector

00:06:09,180 --> 00:06:15,870
in twel is it still going to be Oh n how

00:06:12,540 --> 00:06:22,020
many people think yes how many people

00:06:15,870 --> 00:06:24,660
think no how positive are you 100% so

00:06:22,020 --> 00:06:29,700
fewer hints so we'll come back to this

00:06:24,660 --> 00:06:31,680
example later okay next example I mean

00:06:29,700 --> 00:06:34,470
you know Q sort stood sort there's such

00:06:31,680 --> 00:06:36,540
canonical examples in terms of both C

00:06:34,470 --> 00:06:38,760
versus C++ in terms of function pointers

00:06:36,540 --> 00:06:41,130
so here's how I see the average C++

00:06:38,760 --> 00:06:41,970
developer progressing you're a beginner

00:06:41,130 --> 00:06:43,410
you learn there

00:06:41,970 --> 00:06:47,370
and log n because they're both quick

00:06:43,410 --> 00:06:49,080
sorts in school done then you start to

00:06:47,370 --> 00:06:51,930
learn you read Scott Myers

00:06:49,080 --> 00:06:56,250
he says stood sword is faster because

00:06:51,930 --> 00:06:57,900
you get in lining great that's not

00:06:56,250 --> 00:07:00,030
that's that's pretty good actually but

00:06:57,900 --> 00:07:01,560
then you go to the next level and I've

00:07:00,030 --> 00:07:03,750
had very experienced developers tell me

00:07:01,560 --> 00:07:05,280
no no it'll be the same because the

00:07:03,750 --> 00:07:09,750
function pointer will get in line modern

00:07:05,280 --> 00:07:13,500
compilers are smarter than that and then

00:07:09,750 --> 00:07:15,960
you realize it depends I mean maybe they

00:07:13,500 --> 00:07:17,850
will maybe they won't and will also come

00:07:15,960 --> 00:07:21,840
back to that example so here's another

00:07:17,850 --> 00:07:24,630
kind of weird example so here's two

00:07:21,840 --> 00:07:26,640
calls two stood sort they have the exact

00:07:24,630 --> 00:07:29,610
same behavior right I have a comparator

00:07:26,640 --> 00:07:32,160
which is a function in the first case I

00:07:29,610 --> 00:07:33,510
passed the function directly in the

00:07:32,160 --> 00:07:35,250
second case I'm doing something kind of

00:07:33,510 --> 00:07:39,390
weird right I'm creating a lambda in the

00:07:35,250 --> 00:07:43,020
land that calls the function right what

00:07:39,390 --> 00:07:47,660
the heck's going on okay so who thinks

00:07:43,020 --> 00:07:47,660
that one would be faster raise your hand

00:07:48,050 --> 00:07:55,710
okay few hands not too many who think

00:07:51,840 --> 00:07:59,250
that they're the same who thinks that

00:07:55,710 --> 00:08:01,950
the second one's faster great so I'll

00:07:59,250 --> 00:08:04,200
say that the same was most more than

00:08:01,950 --> 00:08:05,669
half of the people and some people said

00:08:04,200 --> 00:08:08,490
the second was faster and almost no one

00:08:05,669 --> 00:08:09,180
said the first was faster we'll come

00:08:08,490 --> 00:08:13,950
back to this too

00:08:09,180 --> 00:08:17,910
I remember I remember who put up their

00:08:13,950 --> 00:08:19,740
hand okay so how could we resolve this

00:08:17,910 --> 00:08:21,360
well we could run a benchmark but you

00:08:19,740 --> 00:08:23,130
know what if you think the assembly

00:08:21,360 --> 00:08:24,600
might be identical it's actually a lot

00:08:23,130 --> 00:08:26,430
faster just to look at the assembly and

00:08:24,600 --> 00:08:27,900
dip it and it's more reliable because

00:08:26,430 --> 00:08:29,820
measurements have noise right and

00:08:27,900 --> 00:08:30,900
there's also a lot of pitfalls so you

00:08:29,820 --> 00:08:32,700
look at the assembly for one you looking

00:08:30,900 --> 00:08:34,650
for the assembly for the other and then

00:08:32,700 --> 00:08:37,710
you start to see well is it exactly the

00:08:34,650 --> 00:08:39,090
same and then if it's not then you can

00:08:37,710 --> 00:08:43,770
benchmark them and think about which

00:08:39,090 --> 00:08:45,870
one's faster right so we're getting the

00:08:43,770 --> 00:08:48,300
kind of whether there's a difference or

00:08:45,870 --> 00:08:51,950
not straight from the machine itself so

00:08:48,300 --> 00:08:53,880
we look deep inside our our function and

00:08:51,950 --> 00:08:55,470
when you look deep inside the function

00:08:53,880 --> 00:08:55,740
you'll see a call to this intro sort

00:08:55,470 --> 00:08:58,380
glue

00:08:55,740 --> 00:09:01,620
so intro cert is the hybrid loop that

00:08:58,380 --> 00:09:06,150
sorry hybrid sort that the standard

00:09:01,620 --> 00:09:07,410
sword uses and deep inside its bowels if

00:09:06,150 --> 00:09:10,590
you go through the assembly you'll find

00:09:07,410 --> 00:09:13,680
this call R 12 so R 12 is a register

00:09:10,590 --> 00:09:16,640
call is calling it so there's a indirect

00:09:13,680 --> 00:09:16,640
jump okay

00:09:16,730 --> 00:09:24,810
and the only compiler and our flag

00:09:22,530 --> 00:09:29,970
optimization at least out of O one o two

00:09:24,810 --> 00:09:31,950
or three in in all cases except for GCC

00:09:29,970 --> 00:09:35,250
with oh three for every other compiler

00:09:31,950 --> 00:09:37,920
and optimization flag if you have the

00:09:35,250 --> 00:09:41,700
lambda it gets in lined and the one with

00:09:37,920 --> 00:09:43,560
the function pointer does not and you

00:09:41,700 --> 00:09:44,790
can benchmark this but and obviously you

00:09:43,560 --> 00:09:46,170
can always concoct an artificial

00:09:44,790 --> 00:09:48,210
benchmark but generally speaking the

00:09:46,170 --> 00:09:51,780
inline one will be faster in almost any

00:09:48,210 --> 00:09:53,850
benchmark so majority of people thought

00:09:51,780 --> 00:09:56,730
that it would be the same right but it's

00:09:53,850 --> 00:10:00,720
not so when you add that lambda in most

00:09:56,730 --> 00:10:02,160
cases it will make things faster so it

00:10:00,720 --> 00:10:05,010
just kind of shows the relationship

00:10:02,160 --> 00:10:07,350
between assembly and code is pretty

00:10:05,010 --> 00:10:09,990
tenuous right an extra function call in

00:10:07,350 --> 00:10:11,310
code actually made things faster so in

00:10:09,990 --> 00:10:21,090
this case the lambda was like negative

00:10:11,310 --> 00:10:23,430
cost right pretty weird okay so okay so

00:10:21,090 --> 00:10:23,760
isn't this optimization easy well no not

00:10:23,430 --> 00:10:28,050
really

00:10:23,760 --> 00:10:29,370
depends how you look at it okay so in

00:10:28,050 --> 00:10:32,910
order to make this all seem less weird

00:10:29,370 --> 00:10:35,190
we're gonna talk a little bit about some

00:10:32,910 --> 00:10:38,070
very basic tools to think about what an

00:10:35,190 --> 00:10:39,480
optimizer has to work with and then

00:10:38,070 --> 00:10:43,650
we're gonna come back to more examples a

00:10:39,480 --> 00:10:45,780
lot more examples okay who's seen the

00:10:43,650 --> 00:10:48,030
movie training day it's like 10 years

00:10:45,780 --> 00:10:52,290
old now I guess oh my god everyone else

00:10:48,030 --> 00:10:54,360
get out no I'm just kidding okay so the

00:10:52,290 --> 00:10:56,520
movies about this naive cop that joins

00:10:54,360 --> 00:10:59,220
the unit with this corrupt but effective

00:10:56,520 --> 00:11:01,380
cop played by the ever wonderful Denzel

00:10:59,220 --> 00:11:02,730
Washington and the refer one of the

00:11:01,380 --> 00:11:04,290
refrains in the movie is he keeps

00:11:02,730 --> 00:11:07,740
telling the younger cop it's not what

00:11:04,290 --> 00:11:09,450
you know it's what you can prove so the

00:11:07,740 --> 00:11:11,310
same thing is true about the compiler

00:11:09,450 --> 00:11:12,930
okay you may think you know something

00:11:11,310 --> 00:11:14,760
I'm only going to use the function this

00:11:12,930 --> 00:11:17,310
way I'm only going to do that the

00:11:14,760 --> 00:11:20,970
compiler doesn't care the compiler will

00:11:17,310 --> 00:11:24,240
only do what it can prove is correct so

00:11:20,970 --> 00:11:26,940
every optimization is like a proof right

00:11:24,240 --> 00:11:29,820
it has to prove that given what it knows

00:11:26,940 --> 00:11:33,510
that all of the observable behavior is

00:11:29,820 --> 00:11:35,750
always the same in the original code in

00:11:33,510 --> 00:11:38,760
the optimized code okay

00:11:35,750 --> 00:11:41,070
so you know you have to define

00:11:38,760 --> 00:11:42,990
observable I'm not going to do that

00:11:41,070 --> 00:11:45,900
I think Brice's talk talked a bit about

00:11:42,990 --> 00:11:48,570
this the C++ execution model definitely

00:11:45,900 --> 00:11:49,530
should watch that talk but we're not

00:11:48,570 --> 00:11:52,140
going to get into the details of

00:11:49,530 --> 00:11:53,490
observable but it's a very least common

00:11:52,140 --> 00:11:55,530
sense things right it's got to return

00:11:53,490 --> 00:12:00,450
the same value from the function right

00:11:55,530 --> 00:12:02,520
for legal inputs okay

00:12:00,450 --> 00:12:04,320
so basic blocks I'm not going to get

00:12:02,520 --> 00:12:06,120
again in very much detail here but it's

00:12:04,320 --> 00:12:10,170
a basic concept that it's worth at least

00:12:06,120 --> 00:12:12,240
knowing the Wikipedia definition of so

00:12:10,170 --> 00:12:15,720
it's just basically a chunk of code that

00:12:12,240 --> 00:12:16,950
you enter at the beginning you have to

00:12:15,720 --> 00:12:20,190
go through the whole thing and leave at

00:12:16,950 --> 00:12:21,570
the end that's it and compilers have a

00:12:20,190 --> 00:12:23,850
lot of freedom within basic blocks

00:12:21,570 --> 00:12:25,820
because they can rearrange things and

00:12:23,850 --> 00:12:28,410
move things and eliminate things and

00:12:25,820 --> 00:12:30,150
most things that happen inside a basic

00:12:28,410 --> 00:12:31,560
block can't be observed from the outside

00:12:30,150 --> 00:12:34,110
right because you can't leave and you

00:12:31,560 --> 00:12:37,250
can't enter so there's only a handful of

00:12:34,110 --> 00:12:41,400
things you know Global's multi-threading

00:12:37,250 --> 00:12:44,040
volatile these are side-effects that

00:12:41,400 --> 00:12:45,240
have to be still preserved inside basic

00:12:44,040 --> 00:12:48,660
blocks but we're not going to talk much

00:12:45,240 --> 00:12:51,300
about any of those for the most part but

00:12:48,660 --> 00:12:53,010
again one thing to note is that when you

00:12:51,300 --> 00:12:55,200
call a function that doesn't get in line

00:12:53,010 --> 00:12:58,710
right it's always the start of a new

00:12:55,200 --> 00:13:00,660
basic block and what makes functions

00:12:58,710 --> 00:13:02,310
tricky is that especially from the

00:13:00,660 --> 00:13:04,080
compilers perspective without the linker

00:13:02,310 --> 00:13:06,960
it doesn't know all the places the

00:13:04,080 --> 00:13:08,970
function will get called from right so

00:13:06,960 --> 00:13:10,200
it means that functions have to be

00:13:08,970 --> 00:13:11,850
correct no matter where they're called

00:13:10,200 --> 00:13:14,100
from I know that sounds like a really

00:13:11,850 --> 00:13:17,070
trite observation but if you actually

00:13:14,100 --> 00:13:19,200
use that and apply it to the examples

00:13:17,070 --> 00:13:21,750
you're going to see you'll actually get

00:13:19,200 --> 00:13:24,290
some mileage from this really trite

00:13:21,750 --> 00:13:24,290
observation

00:13:24,300 --> 00:13:30,480
and here's a couple of examples of basic

00:13:26,550 --> 00:13:32,280
blocks those pictures could be bigger so

00:13:30,480 --> 00:13:36,270
what's the first one can anyone just

00:13:32,280 --> 00:13:41,160
yell it out if else right what's the

00:13:36,270 --> 00:13:43,800
second one it's a loop right some kind

00:13:41,160 --> 00:13:46,680
of loop it's not a for loop but either I

00:13:43,800 --> 00:13:48,630
do or a while okay

00:13:46,680 --> 00:13:50,100
another thing to think about from the

00:13:48,630 --> 00:13:51,480
compilers perspective is that there's

00:13:50,100 --> 00:13:52,800
two types of information when you

00:13:51,480 --> 00:13:55,650
compile a program okay

00:13:52,800 --> 00:13:57,150
very bright basically there's static

00:13:55,650 --> 00:13:59,640
information and dynamic information

00:13:57,150 --> 00:14:01,650
static is basically whatever enters at

00:13:59,640 --> 00:14:05,430
compile time and dynamic is whatever

00:14:01,650 --> 00:14:07,440
enters at runtime so very very broadly

00:14:05,430 --> 00:14:09,870
speaking this isn't you know literally

00:14:07,440 --> 00:14:12,600
true but static information is reflected

00:14:09,870 --> 00:14:14,370
by types or at least all types have to

00:14:12,600 --> 00:14:15,780
be known at compile time everywhere

00:14:14,370 --> 00:14:19,080
locally that's the whole point of a

00:14:15,780 --> 00:14:21,390
statically typed language right dynamic

00:14:19,080 --> 00:14:23,370
basically means values like you pass you

00:14:21,390 --> 00:14:25,680
know a double the type of the double is

00:14:23,370 --> 00:14:28,050
known everywhere in the program but the

00:14:25,680 --> 00:14:31,290
value of the double is not that's

00:14:28,050 --> 00:14:34,080
dynamic so like very very simple

00:14:31,290 --> 00:14:38,190
illustration you've got a foo that takes

00:14:34,080 --> 00:14:41,430
a vector okay but with a vector the size

00:14:38,190 --> 00:14:42,810
is a runtime value right so if you have

00:14:41,430 --> 00:14:44,730
a loop over a vector it's not going to

00:14:42,810 --> 00:14:47,220
know is the loop small is the loop big I

00:14:44,730 --> 00:14:48,390
mean we want compilers to optimize these

00:14:47,220 --> 00:14:50,070
things but think about it from the

00:14:48,390 --> 00:14:53,430
compilers perspective right it has no

00:14:50,070 --> 00:14:55,800
idea typically if you're asking for a

00:14:53,430 --> 00:14:59,400
loop over a million elements or a loop

00:14:55,800 --> 00:15:01,380
over two it has no clue so you can start

00:14:59,400 --> 00:15:03,960
to see the the constraints of the

00:15:01,380 --> 00:15:05,490
compiler which are difficult and the

00:15:03,960 --> 00:15:07,500
second example of course he passes did

00:15:05,490 --> 00:15:10,260
array and the said array does have the

00:15:07,500 --> 00:15:17,550
size as part of the type right so the

00:15:10,260 --> 00:15:19,110
compiler will know last slide I just

00:15:17,550 --> 00:15:21,590
talked about this briefly it's a bit of

00:15:19,110 --> 00:15:23,610
a toy example but a couple years ago

00:15:21,590 --> 00:15:26,340
Chandler Carruth gave a really good talk

00:15:23,610 --> 00:15:28,860
about fast modulus basically or that was

00:15:26,340 --> 00:15:30,630
part of his talk sorry and the idea was

00:15:28,860 --> 00:15:32,870
well if you add this branch into a

00:15:30,630 --> 00:15:35,520
modulus right you make it faster because

00:15:32,870 --> 00:15:36,660
the branch predictor is great you know

00:15:35,520 --> 00:15:39,540
integer division is

00:15:36,660 --> 00:15:43,379
crazy-expensive and this works out

00:15:39,540 --> 00:15:44,399
better right okay and what was

00:15:43,379 --> 00:15:45,600
interesting is the end of the talk you

00:15:44,399 --> 00:15:48,089
said yeah I should teach the compiler

00:15:45,600 --> 00:15:53,009
how to generate the branch in the

00:15:48,089 --> 00:15:54,629
assembly even if you just do X mod M now

00:15:53,009 --> 00:15:57,540
clang still doesn't do this I don't know

00:15:54,629 --> 00:15:58,980
the reason but one thing I'd like to

00:15:57,540 --> 00:16:00,089
kind of throw out there is maybe this is

00:15:58,980 --> 00:16:04,110
not such a bad thing

00:16:00,089 --> 00:16:05,910
because you know is fast modulus better

00:16:04,110 --> 00:16:07,379
like the assembly that's equivalent to

00:16:05,910 --> 00:16:10,110
this is this always the assembly that we

00:16:07,379 --> 00:16:12,269
want well the mean performance is better

00:16:10,110 --> 00:16:14,189
but you don't always care about the mean

00:16:12,269 --> 00:16:18,209
like for instance what about worst case

00:16:14,189 --> 00:16:20,009
I mean I mean yes the processor is so

00:16:18,209 --> 00:16:23,790
weird that I guess it is possible that

00:16:20,009 --> 00:16:26,129
this is somehow you know better in the

00:16:23,790 --> 00:16:27,899
worst case but it's very unlikely right

00:16:26,129 --> 00:16:31,649
I mean you have an extra branch and then

00:16:27,899 --> 00:16:33,500
the same operation right so the worst

00:16:31,649 --> 00:16:36,230
case performance is almost certainly

00:16:33,500 --> 00:16:39,240
better if you don't have the branch so

00:16:36,230 --> 00:16:42,449
there's an advantage in the compiler

00:16:39,240 --> 00:16:44,939
generating assembly that is kind of more

00:16:42,449 --> 00:16:47,310
similar in spirit to the code that you

00:16:44,939 --> 00:16:49,740
write if the compilers not convinced

00:16:47,310 --> 00:16:51,689
that it has a good optimization to make

00:16:49,740 --> 00:16:54,420
there's value in that because it gives

00:16:51,689 --> 00:16:58,350
you more control right and compilers do

00:16:54,420 --> 00:17:02,519
do this often and we will also see that

00:16:58,350 --> 00:17:04,589
in the examples okay so a quick summary

00:17:02,519 --> 00:17:06,419
so it's compiler has to always produce

00:17:04,589 --> 00:17:09,030
correct code it's got to think about

00:17:06,419 --> 00:17:12,809
basic blocks and all the entry points as

00:17:09,030 --> 00:17:14,669
part of that correctness it has a lot of

00:17:12,809 --> 00:17:16,490
some information like types it's got

00:17:14,669 --> 00:17:19,650
very little of other information like

00:17:16,490 --> 00:17:21,360
values typically or what you care about

00:17:19,650 --> 00:17:25,260
that's one of the things the compiler

00:17:21,360 --> 00:17:27,780
really does not know in general and it

00:17:25,260 --> 00:17:30,210
tries to make you know definitely better

00:17:27,780 --> 00:17:32,250
optimizations but if it can't if it's a

00:17:30,210 --> 00:17:34,770
judgment call it may fall back on

00:17:32,250 --> 00:17:39,539
writing it on generating assembly

00:17:34,770 --> 00:17:41,640
similar to the code you write okay so

00:17:39,539 --> 00:17:44,490
we're going to go through basically a

00:17:41,640 --> 00:17:47,640
very large number very large we're going

00:17:44,490 --> 00:17:48,840
to go through a number of examples and

00:17:47,640 --> 00:17:50,080
if you organized in a few different

00:17:48,840 --> 00:17:51,370
sections so we're

00:17:50,080 --> 00:17:54,399
looking at a lot of people's plus code

00:17:51,370 --> 00:17:58,330
and understanding why he generates some

00:17:54,399 --> 00:18:01,840
particular assembly okay I'm gonna start

00:17:58,330 --> 00:18:05,980
with inlining inlining is super duper

00:18:01,840 --> 00:18:07,299
duper important okay when I first when

00:18:05,980 --> 00:18:10,090
you first hear about inlining as an

00:18:07,299 --> 00:18:13,210
optimization I feel like what we almost

00:18:10,090 --> 00:18:16,179
always tell people is look calling a

00:18:13,210 --> 00:18:17,529
function has a cost you have to load the

00:18:16,179 --> 00:18:19,870
arguments up somewhere into some

00:18:17,529 --> 00:18:22,210
registers and then you have to call a

00:18:19,870 --> 00:18:23,529
function pointer and loading it up and

00:18:22,210 --> 00:18:26,460
calling the function pointer has cost

00:18:23,529 --> 00:18:29,830
and therefore inlining can be better

00:18:26,460 --> 00:18:33,340
okay this is obviously true right but

00:18:29,830 --> 00:18:34,600
the the real killer effect from inlining

00:18:33,340 --> 00:18:36,789
is that it makes so many other

00:18:34,600 --> 00:18:40,000
optimizations possible when you inline a

00:18:36,789 --> 00:18:42,880
function into another you basically fold

00:18:40,000 --> 00:18:44,919
them into the same basic block and then

00:18:42,880 --> 00:18:48,070
what can happen is that you get all of

00:18:44,919 --> 00:18:50,409
these other nice optimizations and my

00:18:48,070 --> 00:18:51,730
inlining example is not that interesting

00:18:50,409 --> 00:18:57,429
but in the other examples you'll see how

00:18:51,730 --> 00:18:58,960
inlining plays a huge role okay so when

00:18:57,429 --> 00:19:00,399
is inlining happen they're basically

00:18:58,960 --> 00:19:02,139
there's got to be two things that are

00:19:00,399 --> 00:19:04,630
satisfied right first it's got to be

00:19:02,139 --> 00:19:07,500
able to if you have for instance a

00:19:04,630 --> 00:19:09,549
function pointer in some totally random

00:19:07,500 --> 00:19:11,889
situation where the compiler has no

00:19:09,549 --> 00:19:14,110
additional information that it's just

00:19:11,889 --> 00:19:16,600
not possible right in a jittered

00:19:14,110 --> 00:19:18,429
language a compiler could maybe decide

00:19:16,600 --> 00:19:20,169
to inline it after a certain number of

00:19:18,429 --> 00:19:24,130
calls went to the same place with like a

00:19:20,169 --> 00:19:27,039
fallback right but in a in C++ it's just

00:19:24,130 --> 00:19:28,419
not it's not possible the second thing

00:19:27,039 --> 00:19:30,940
is that the compiler has to decide that

00:19:28,419 --> 00:19:32,769
it wants to inline and become you know

00:19:30,940 --> 00:19:35,169
direct calls obviously don't always get

00:19:32,769 --> 00:19:37,330
in line and it then becomes a code block

00:19:35,169 --> 00:19:39,190
trade-off right so if you have a

00:19:37,330 --> 00:19:42,370
function that's 100 lines and you in

00:19:39,190 --> 00:19:44,620
line at 10 times you just added 900

00:19:42,370 --> 00:19:48,190
excess lines of assembly as opposed to

00:19:44,620 --> 00:19:50,710
it not being in line right there are two

00:19:48,190 --> 00:19:52,149
cases where it's very very like it's

00:19:50,710 --> 00:19:54,639
pretty safe to assume the compiler will

00:19:52,149 --> 00:20:01,029
in line something to anyone think of

00:19:54,639 --> 00:20:01,850
what those two cases are if the function

00:20:01,029 --> 00:20:05,090
is only called one

00:20:01,850 --> 00:20:06,980
then there's no code bloat cost so there

00:20:05,090 --> 00:20:09,799
are still some things to consider like

00:20:06,980 --> 00:20:11,360
if the function has to be exposed in the

00:20:09,799 --> 00:20:13,160
symbol table like if it's not static or

00:20:11,360 --> 00:20:15,320
if it's not a lambda it may still need

00:20:13,160 --> 00:20:17,510
to generate a body but oftentimes if a

00:20:15,320 --> 00:20:19,010
function is only called once it's gonna

00:20:17,510 --> 00:20:24,320
inline you see this a lot with lambdas

00:20:19,010 --> 00:20:26,480
and the second example functions too

00:20:24,320 --> 00:20:28,640
small and in particular if the function

00:20:26,480 --> 00:20:30,200
is length zero okay and that's you know

00:20:28,640 --> 00:20:32,960
you may laugh like wow why would you

00:20:30,200 --> 00:20:34,610
ever call an empty function but it you

00:20:32,960 --> 00:20:36,440
build up abstractions and then sometimes

00:20:34,610 --> 00:20:39,380
you want no ops in certain cases right

00:20:36,440 --> 00:20:41,419
so you will see this so the compiler

00:20:39,380 --> 00:20:42,830
should always or will always really

00:20:41,419 --> 00:20:45,980
inline these things if it is capable

00:20:42,830 --> 00:20:48,130
right or basically always I should

00:20:45,980 --> 00:20:50,570
probably never say always in this talk

00:20:48,130 --> 00:20:53,059
okay so here's really really simple

00:20:50,570 --> 00:20:57,860
example of inlining we've got food we've

00:20:53,059 --> 00:20:59,809
got bar bar calls foo you know and it

00:20:57,860 --> 00:21:08,030
does not call foo in the assembly right

00:20:59,809 --> 00:21:09,530
this is super simple so we can think

00:21:08,030 --> 00:21:12,590
about inlining we can go back to our

00:21:09,530 --> 00:21:14,360
example with clear right so well

00:21:12,590 --> 00:21:15,409
what does clear look like I mean it

00:21:14,360 --> 00:21:18,620
basically looks something like this

00:21:15,409 --> 00:21:22,460
right vector T clear it iterates over

00:21:18,620 --> 00:21:24,169
all the elements and destroys them right

00:21:22,460 --> 00:21:28,820
and then it sets n to begin that's

00:21:24,169 --> 00:21:31,280
basically what it does so you know the T

00:21:28,820 --> 00:21:34,520
the type is known right so this call

00:21:31,280 --> 00:21:38,030
like till T T's the structure statically

00:21:34,520 --> 00:21:40,370
it knows exactly what it's calling the

00:21:38,030 --> 00:21:42,890
destructor of int is a no op right so

00:21:40,370 --> 00:21:44,090
when it considers intz destructor for in

00:21:42,890 --> 00:21:46,940
lining I mean I don't know if that

00:21:44,090 --> 00:21:49,220
literally happens but conceptually it

00:21:46,940 --> 00:21:50,750
obviously will say well you know in

00:21:49,220 --> 00:21:53,600
lining and no off function is just

00:21:50,750 --> 00:21:56,210
basically doing nothing so the for loop

00:21:53,600 --> 00:21:59,150
body becomes empty and then it will

00:21:56,210 --> 00:22:01,010
delete the for loop although you can't

00:21:59,150 --> 00:22:02,570
immediately delete the for loop even

00:22:01,010 --> 00:22:04,940
once you delete the body what else do

00:22:02,570 --> 00:22:10,750
you have to do what does the compiler

00:22:04,940 --> 00:22:10,750
have to prove no side-effects to what

00:22:11,870 --> 00:22:14,900
incrementing and equals right because

00:22:13,309 --> 00:22:18,260
it's going to keep that's part of the

00:22:14,900 --> 00:22:20,500
loop code so in this case like your raw

00:22:18,260 --> 00:22:23,480
implementation of vector it's probably

00:22:20,500 --> 00:22:25,220
well I mean it's not probably Rupp

00:22:23,480 --> 00:22:27,470
pointers it's a pointer type theft that

00:22:25,220 --> 00:22:28,760
comes from the allocator but it's all

00:22:27,470 --> 00:22:30,500
going to be resolved hopefully but you

00:22:28,760 --> 00:22:31,940
can see the even in this trivial case

00:22:30,500 --> 00:22:34,279
the compiler has to eat away a lot of

00:22:31,940 --> 00:22:35,900
compile time abstraction to fully make

00:22:34,279 --> 00:22:37,340
the optimization and this is a very

00:22:35,900 --> 00:22:39,710
simple example

00:22:37,340 --> 00:22:42,950
but it does do it very reliably in these

00:22:39,710 --> 00:22:45,320
cases so yes if you look at the assembly

00:22:42,950 --> 00:22:47,890
by the way spoiler yeah it optimizes

00:22:45,320 --> 00:22:47,890
away completely

00:22:49,130 --> 00:22:53,840
okay so cons propagation is kind of

00:22:51,830 --> 00:22:55,490
after in lining those are maybe two of

00:22:53,840 --> 00:22:58,340
the most important canonical

00:22:55,490 --> 00:23:00,470
optimizations so remember before I said

00:22:58,340 --> 00:23:04,070
well types are compile time and values

00:23:00,470 --> 00:23:07,370
our run time right okay well this is an

00:23:04,070 --> 00:23:10,870
exception so basically cost propagation

00:23:07,370 --> 00:23:14,659
is when knowing a value at compile time

00:23:10,870 --> 00:23:16,970
influences the the generated assembly of

00:23:14,659 --> 00:23:20,450
the compiler that's at least a working

00:23:16,970 --> 00:23:24,649
definition of what it is so it's super

00:23:20,450 --> 00:23:26,809
important as a result so let's look at

00:23:24,649 --> 00:23:28,760
another example this is an example of

00:23:26,809 --> 00:23:32,779
sort of arithmetic const propagation you

00:23:28,760 --> 00:23:35,059
can think of it so matt god bolt gave a

00:23:32,779 --> 00:23:36,799
keynote a couple last year i think where

00:23:35,059 --> 00:23:41,000
he went through a lot of arithmetic

00:23:36,799 --> 00:23:43,909
optimizations so here's one very simple

00:23:41,000 --> 00:23:46,789
example so foo calls factorial with the

00:23:43,909 --> 00:23:48,890
constant and you know not one thing to

00:23:46,789 --> 00:23:51,830
note in this example right is notice

00:23:48,890 --> 00:23:53,720
there's a relationship with inlining so

00:23:51,830 --> 00:23:57,169
it's not just the fact that the call to

00:23:53,720 --> 00:23:59,029
factorial is gone but you again this

00:23:57,169 --> 00:24:01,970
will sound trite but foo cannot call

00:23:59,029 --> 00:24:04,039
factorial and get back 24 the constant

00:24:01,970 --> 00:24:06,559
right because factorial has to be

00:24:04,039 --> 00:24:08,450
correct for all values of x right so

00:24:06,559 --> 00:24:09,559
once you're actually entering factorial

00:24:08,450 --> 00:24:11,179
you

00:24:09,559 --> 00:24:12,620
you know the main factorial function I'm

00:24:11,179 --> 00:24:14,090
not really going to talk about cloning

00:24:12,620 --> 00:24:15,799
in this talk but there's a thing called

00:24:14,090 --> 00:24:17,750
cloning but we're not going to talk

00:24:15,799 --> 00:24:20,480
about it but once you enter the main

00:24:17,750 --> 00:24:22,250
factorial body it's it has to be correct

00:24:20,480 --> 00:24:24,440
so you're not going to get cons

00:24:22,250 --> 00:24:25,460
propagation through a function boundary

00:24:24,440 --> 00:24:29,240
in most case

00:24:25,460 --> 00:24:30,740
and this is all based on really tried

00:24:29,240 --> 00:24:31,850
observations but a lot of people when

00:24:30,740 --> 00:24:33,140
looking at code will sort of be

00:24:31,850 --> 00:24:38,300
surprised they are like why didn't this

00:24:33,140 --> 00:24:40,400
kant's propagate I mean that's why and

00:24:38,300 --> 00:24:42,950
by the way notice has nothing to do with

00:24:40,400 --> 00:24:44,420
the keyword Const right no relationship

00:24:42,950 --> 00:24:47,960
the keyword cons but we will talk about

00:24:44,420 --> 00:24:49,490
that too okay so this is though

00:24:47,960 --> 00:24:50,780
arithmetic optimizations are nice

00:24:49,490 --> 00:24:52,580
depending what kind of code you write

00:24:50,780 --> 00:24:54,530
they might be important but I think

00:24:52,580 --> 00:24:57,890
these this is to me a more interesting

00:24:54,530 --> 00:25:00,710
example of con strop ocation so here

00:24:57,890 --> 00:25:03,350
I've written you know sort of my own for

00:25:00,710 --> 00:25:04,850
each function it takes a function

00:25:03,350 --> 00:25:06,920
pointer and a vector and it just calls

00:25:04,850 --> 00:25:11,300
the function pointer on every element of

00:25:06,920 --> 00:25:15,830
the vector right so here we have bar bar

00:25:11,300 --> 00:25:20,090
calls my for each V foo okay so who is a

00:25:15,830 --> 00:25:23,180
function that does something right so if

00:25:20,090 --> 00:25:25,400
you were looking at this code maybe and

00:25:23,180 --> 00:25:27,350
you hadn't been at this talk and

00:25:25,400 --> 00:25:30,170
thinking about these things you would

00:25:27,350 --> 00:25:32,180
probably just think well i 100% expect

00:25:30,170 --> 00:25:34,430
you know food again in the line because

00:25:32,180 --> 00:25:37,240
look like bar is saying exactly what

00:25:34,430 --> 00:25:39,770
it's calling so why wouldn't it be

00:25:37,240 --> 00:25:42,440
what's kind but but what is basically a

00:25:39,770 --> 00:25:44,030
necessary condition for food to get in

00:25:42,440 --> 00:25:47,530
lined in the total generated assembly

00:25:44,030 --> 00:25:47,530
here do anyone say

00:25:55,090 --> 00:26:00,250
ah yeah well food well food won't be

00:25:58,870 --> 00:26:03,010
eliminated but I'm saying for it to be

00:26:00,250 --> 00:26:06,000
in line so I mean the answer is that my

00:26:03,010 --> 00:26:09,700
for each has to be inlined into bar

00:26:06,000 --> 00:26:12,490
because if bar calls my for each a

00:26:09,700 --> 00:26:16,030
naturally incidentally I started this

00:26:12,490 --> 00:26:18,040
example with standard algorithms and to

00:26:16,030 --> 00:26:20,230
my surprise a lot of standard algorithms

00:26:18,040 --> 00:26:22,120
do not get in lined fully us

00:26:20,230 --> 00:26:25,180
even at a toe to a toe three they

00:26:22,120 --> 00:26:28,030
typically do but you'd be surprised so

00:26:25,180 --> 00:26:31,150
if my for each does not get in line

00:26:28,030 --> 00:26:34,930
right there's no way that my for each

00:26:31,150 --> 00:26:36,670
can in line F right because it has to be

00:26:34,930 --> 00:26:39,700
correct no matter who calls it and no

00:26:36,670 --> 00:26:41,620
matter what value of f is passed so to

00:26:39,700 --> 00:26:43,900
you it seems like I'm passing foo why

00:26:41,620 --> 00:26:46,120
aren't you in lining me well that's why

00:26:43,900 --> 00:26:48,970
because you can't cons propagate across

00:26:46,120 --> 00:26:51,880
this this function boundary if you in

00:26:48,970 --> 00:26:54,490
line my for each then all the code is in

00:26:51,880 --> 00:26:59,310
one scope right it's one big chunk and

00:26:54,490 --> 00:26:59,310
now the compiler can do some stuff right

00:27:02,640 --> 00:27:07,150
so here's the assembly and fortunately

00:27:04,840 --> 00:27:08,800
it didn't entirely fit on one slide but

00:27:07,150 --> 00:27:10,930
if you go through and you'll see the bar

00:27:08,800 --> 00:27:13,330
and either calls my for each nor does it

00:27:10,930 --> 00:27:18,190
call foo it's just generates a bunch of

00:27:13,330 --> 00:27:21,310
instructions okay oh yeah so for

00:27:18,190 --> 00:27:22,960
instance STD find if that's all most

00:27:21,310 --> 00:27:25,150
probably one of the simplest algorithms

00:27:22,960 --> 00:27:27,670
you can think of if you call it with a

00:27:25,150 --> 00:27:30,340
function pointer for instance GCC eight

00:27:27,670 --> 00:27:32,020
with o2 will not inline it it will not

00:27:30,340 --> 00:27:34,170
inline find if and then it will not

00:27:32,020 --> 00:27:36,580
inline the function pointer either so

00:27:34,170 --> 00:27:39,520
you will actually end up with assembly

00:27:36,580 --> 00:27:41,860
significantly problem you can always say

00:27:39,520 --> 00:27:43,420
maybe in lining is is bad in this case

00:27:41,860 --> 00:27:44,620
because if code bloat but in practice

00:27:43,420 --> 00:27:46,870
you almost always want this small

00:27:44,620 --> 00:27:48,790
function inline right so you will

00:27:46,870 --> 00:27:51,820
actually get worst performance with find

00:27:48,790 --> 00:27:52,500
if in this example so you know lambdas

00:27:51,820 --> 00:27:56,590
are good

00:27:52,500 --> 00:27:59,080
okay passing by reference so you know

00:27:56,590 --> 00:28:00,690
notice what am I doing here I'm passing

00:27:59,080 --> 00:28:05,770
a bool by reference why would I do that

00:28:00,690 --> 00:28:08,650
well I don't know don't don't do that

00:28:05,770 --> 00:28:10,660
huh templates right so

00:28:08,650 --> 00:28:12,550
when you write generic code right like

00:28:10,660 --> 00:28:14,980
you know your first reactions like oh no

00:28:12,550 --> 00:28:17,110
one passes that bool by reference yeah

00:28:14,980 --> 00:28:19,030
you do every time you write consti

00:28:17,110 --> 00:28:20,680
ampersand and T gets the deuce to bool

00:28:19,030 --> 00:28:23,290
Congrats you passed a bool by reference

00:28:20,680 --> 00:28:25,780
right and this is actually you can be a

00:28:23,290 --> 00:28:28,720
real issue in some code so let's look at

00:28:25,780 --> 00:28:30,880
this example so we have quacks sorry

00:28:28,720 --> 00:28:33,010
about the function names I'm lazy I

00:28:30,880 --> 00:28:35,770
couldn't think of like cute examples

00:28:33,010 --> 00:28:37,720
like some speakers okay so you've got

00:28:35,770 --> 00:28:41,020
quacks quacks goes in a loop every time

00:28:37,720 --> 00:28:42,340
through the loop it calls bar if B is

00:28:41,020 --> 00:28:45,670
true it also calls this other function

00:28:42,340 --> 00:28:47,200
foo okay and you have foo and bar the

00:28:45,670 --> 00:28:50,500
compiler doesn't see their definitions

00:28:47,200 --> 00:28:52,870
only their declarations great great okay

00:28:50,500 --> 00:28:55,330
so here's the assembly one of these is

00:28:52,870 --> 00:28:58,120
from if it's a reference one of them is

00:28:55,330 --> 00:29:01,300
if it's by value can anyone guess which

00:28:58,120 --> 00:29:03,370
is which who thinks that the one on the

00:29:01,300 --> 00:29:06,220
the call by reference the pass by

00:29:03,370 --> 00:29:09,480
reference is the top one who thinks it's

00:29:06,220 --> 00:29:12,970
the bottom one okay so most people

00:29:09,480 --> 00:29:14,440
aren't sure so it's the top one you the

00:29:12,970 --> 00:29:16,450
comparison is sort of on this byte

00:29:14,440 --> 00:29:18,070
pointer indirection instead of this

00:29:16,450 --> 00:29:23,440
direct register test that you have in

00:29:18,070 --> 00:29:25,630
the bottom one so you know actually let

00:29:23,440 --> 00:29:26,980
me take a step back so the difference in

00:29:25,630 --> 00:29:32,050
this assembly is quite small in

00:29:26,980 --> 00:29:34,809
practical terms but but there are other

00:29:32,050 --> 00:29:36,460
optimizations that you can do that are

00:29:34,809 --> 00:29:38,320
important so for instance in this code

00:29:36,460 --> 00:29:40,480
which is quite small one thing the

00:29:38,320 --> 00:29:42,640
compiler could do is they could take the

00:29:40,480 --> 00:29:45,460
loop out of the for loop sorry take the

00:29:42,640 --> 00:29:46,630
branch ahead of the for loop right so in

00:29:45,460 --> 00:29:48,400
other words you could have the branch at

00:29:46,630 --> 00:29:50,050
the beginning and then it could have one

00:29:48,400 --> 00:29:51,460
loop that only calls bar and one loop

00:29:50,050 --> 00:30:00,190
that only call it that cause both bar

00:29:51,460 --> 00:30:03,239
and foo yeah yes you're stealing my

00:30:00,190 --> 00:30:06,489
thunder but yes so

00:30:03,239 --> 00:30:08,470
okay so you know aside from this small

00:30:06,489 --> 00:30:11,019
change in assembly if you check crank up

00:30:08,470 --> 00:30:12,909
optimization 203 it will do this if you

00:30:11,019 --> 00:30:14,830
pass by value but not by reference and

00:30:12,909 --> 00:30:17,379
also more broadly like even in that

00:30:14,830 --> 00:30:19,450
small example you could ask why are you

00:30:17,379 --> 00:30:21,580
doing this in direct comparison over and

00:30:19,450 --> 00:30:24,519
over why not copy the bull into a

00:30:21,580 --> 00:30:26,470
register right once and then when the

00:30:24,519 --> 00:30:27,669
loop iterates like a million times you

00:30:26,470 --> 00:30:31,989
can just do the cheap register

00:30:27,669 --> 00:30:34,929
comparison right right wrong okay you

00:30:31,989 --> 00:30:37,899
can't do that so here's my bull it's a

00:30:34,929 --> 00:30:39,940
global everyone's spider sends should be

00:30:37,899 --> 00:30:43,509
tingling now something bad is coming so

00:30:39,940 --> 00:30:45,190
my bull is a global and bar is flipping

00:30:43,509 --> 00:30:48,369
the global over and over and over and

00:30:45,190 --> 00:30:49,899
over how super obnoxious is that so

00:30:48,369 --> 00:30:51,519
when you call this for a loop you'll

00:30:49,899 --> 00:30:55,690
actually alternate between calling foo

00:30:51,519 --> 00:30:56,919
and not calling foo okay so whenever you

00:30:55,690 --> 00:30:58,419
pass something by reference and you want

00:30:56,919 --> 00:31:00,789
to ask yourself how will this optimize

00:30:58,419 --> 00:31:02,679
you really need to assume the worst the

00:31:00,789 --> 00:31:04,090
worst for passing by reference is

00:31:02,679 --> 00:31:05,769
basically if you pass a global because

00:31:04,090 --> 00:31:08,559
now every single function can change it

00:31:05,769 --> 00:31:09,100
and of course it you know well here's

00:31:08,559 --> 00:31:11,590
the next one

00:31:09,100 --> 00:31:13,419
cons doesn't matter right apply to a

00:31:11,590 --> 00:31:16,600
reference it's basically useless for

00:31:13,419 --> 00:31:20,139
optimizations again basically I'm

00:31:16,600 --> 00:31:21,730
leaving myself an escape hatch so you

00:31:20,139 --> 00:31:23,799
can always cast away Kant's so if the

00:31:21,730 --> 00:31:25,929
underlying value is not constant its

00:31:23,799 --> 00:31:29,350
defined to cast away constant modify it

00:31:25,929 --> 00:31:31,869
and so in this example right like foo

00:31:29,350 --> 00:31:34,840
does not know if the original value is

00:31:31,869 --> 00:31:38,590
constant or not so who maybe written

00:31:34,840 --> 00:31:41,259
such that it modifies its argument right

00:31:38,590 --> 00:31:44,919
that will only be UB at runtime if it's

00:31:41,259 --> 00:31:46,509
called with a constant argument so so

00:31:44,919 --> 00:31:51,129
this gets pretty nasty so here in this

00:31:46,509 --> 00:31:52,450
example right you know you can see what

00:31:51,129 --> 00:31:56,440
I'm doing right so there's signed

00:31:52,450 --> 00:31:58,720
integers X so Y is equal to X plus 1 so

00:31:56,440 --> 00:32:01,450
if Y doesn't change it's now always

00:31:58,720 --> 00:32:03,639
bigger than X okay the compilers allowed

00:32:01,450 --> 00:32:05,799
to make that assumption for signed not

00:32:03,639 --> 00:32:09,429
for unsigned that's just throwing in

00:32:05,799 --> 00:32:11,649
their integer from optimization okay so

00:32:09,429 --> 00:32:13,749
this will not optimize right because foo

00:32:11,649 --> 00:32:15,929
can change the argument has already told

00:32:13,749 --> 00:32:15,929
you

00:32:18,510 --> 00:32:24,880
sorry let me take a step back it will

00:32:21,820 --> 00:32:27,789
not do the optimization if the Const is

00:32:24,880 --> 00:32:30,250
not applied now let's say that Y is

00:32:27,789 --> 00:32:32,370
actually Const okay like in the code on

00:32:30,250 --> 00:32:35,049
the slide sorry about that

00:32:32,370 --> 00:32:37,990
how many people think that you will just

00:32:35,049 --> 00:32:41,559
return true at the end I mean why is con

00:32:37,990 --> 00:32:43,029
stride it's illegal to change right like

00:32:41,559 --> 00:32:44,529
it's actually illegal to change Y in

00:32:43,029 --> 00:32:47,250
this program how many people think that

00:32:44,529 --> 00:32:49,990
it will still do a comparison of Y and X

00:32:47,250 --> 00:32:52,299
okay maybe I set you guys up for that

00:32:49,990 --> 00:32:53,559
but you you know you really you guys

00:32:52,299 --> 00:32:56,200
should have said the first answer right

00:32:53,559 --> 00:32:59,409
I mean the compiler is allowed as far as

00:32:56,200 --> 00:33:01,950
I know to just return true because it

00:32:59,409 --> 00:33:05,500
really is illegal for food a change Y

00:33:01,950 --> 00:33:07,600
but it doesn't cons caste would be

00:33:05,500 --> 00:33:09,909
undefined behavior here because Y is

00:33:07,600 --> 00:33:14,220
actually constant so like actually

00:33:09,909 --> 00:33:16,480
changing a value that is Const is UB but

00:33:14,220 --> 00:33:19,840
casting away cons for something that's

00:33:16,480 --> 00:33:22,210
not Const is not so Y the value here is

00:33:19,840 --> 00:33:27,399
actually Const the compiler doesn't do

00:33:22,210 --> 00:33:28,990
anything with that I mean you know so

00:33:27,399 --> 00:33:31,929
there's like there's a comp instruction

00:33:28,990 --> 00:33:34,179
there as you can clearly see so it if

00:33:31,929 --> 00:33:36,730
you change it to pass by value then it

00:33:34,179 --> 00:33:38,769
works but once you change it to pass by

00:33:36,730 --> 00:33:41,380
value you don't need the constant e more

00:33:38,769 --> 00:33:44,769
so you know

00:33:41,380 --> 00:33:46,809
so I guess different views on everything

00:33:44,769 --> 00:33:49,029
like how cons effects optimization one

00:33:46,809 --> 00:33:51,159
person that I talked to said well the

00:33:49,029 --> 00:33:54,399
impact is not zero but it rounds to zero

00:33:51,159 --> 00:33:56,139
so that's kind of my view on it but you

00:33:54,399 --> 00:33:58,090
can't find edge cases where cons makes a

00:33:56,139 --> 00:33:59,950
difference but this is a pretty simple

00:33:58,090 --> 00:34:01,350
case and the compilers not doing

00:33:59,950 --> 00:34:04,779
anything

00:34:01,350 --> 00:34:08,649
ok branches um so let's talk about

00:34:04,779 --> 00:34:11,619
optional so one fun fact about optional

00:34:08,649 --> 00:34:13,800
is that the you know the star value the

00:34:11,619 --> 00:34:16,480
starring like dereference optional is

00:34:13,800 --> 00:34:18,730
not checking anything so it's undefined

00:34:16,480 --> 00:34:20,560
behavior if it's empty and dot value

00:34:18,730 --> 00:34:24,250
does a check and a throw if it's empty

00:34:20,560 --> 00:34:25,659
right I've always disliked this but I

00:34:24,250 --> 00:34:28,119
was really embarrassed to say this

00:34:25,659 --> 00:34:29,589
during my talk but then Andrei said it

00:34:28,119 --> 00:34:29,919
so now I'm in good company if you guys

00:34:29,589 --> 00:34:32,919
were

00:34:29,919 --> 00:34:34,780
Andres talk and one of the argument that

00:34:32,919 --> 00:34:36,609
I always heard from people that said no

00:34:34,780 --> 00:34:38,740
no like stars shouldn't do the check

00:34:36,609 --> 00:34:40,780
like the undefined behaviors okay

00:34:38,740 --> 00:34:44,710
they always said look this is the

00:34:40,780 --> 00:34:47,790
idiomatic usage right well imagine that

00:34:44,710 --> 00:34:49,869
was a star instead of a value they say

00:34:47,790 --> 00:34:54,399
well imagine if you use it like this

00:34:49,869 --> 00:34:57,309
right then you know you have one branch

00:34:54,399 --> 00:34:59,829
in the code and then inside the body of

00:34:57,309 --> 00:35:01,900
value or inside the body of my

00:34:59,829 --> 00:35:04,359
hypothetical star you have another

00:35:01,900 --> 00:35:05,770
branch right you have to check if it's

00:35:04,359 --> 00:35:10,470
true to see whether to throw or not two

00:35:05,770 --> 00:35:13,329
branches instead of one branch right

00:35:10,470 --> 00:35:14,130
well you guys probably know where this

00:35:13,329 --> 00:35:18,250
is going

00:35:14,130 --> 00:35:19,809
you compile this okay so can all the

00:35:18,250 --> 00:35:23,410
assembly experts tell me how many

00:35:19,809 --> 00:35:26,920
branches are in this code just yell it

00:35:23,410 --> 00:35:29,079
one assembly experts wasn't intended

00:35:26,920 --> 00:35:33,190
sarcastically here because you know you

00:35:29,079 --> 00:35:35,859
don't have to be an expert okay so why

00:35:33,190 --> 00:35:37,450
why does this happen well with our new

00:35:35,859 --> 00:35:39,040
and improved mental model of the

00:35:37,450 --> 00:35:41,319
compiled or even though it's hilariously

00:35:39,040 --> 00:35:43,799
simple we can still explain this really

00:35:41,319 --> 00:35:46,660
easily okay here's a very simple

00:35:43,799 --> 00:35:48,790
optional probably wrong because my

00:35:46,660 --> 00:35:53,020
reinterpret cast is probably somehow you

00:35:48,790 --> 00:35:55,780
be I don't know so this is the idea

00:35:53,020 --> 00:35:59,170
right if active returned some cast of

00:35:55,780 --> 00:36:00,910
the storage otherwise throw right and

00:35:59,170 --> 00:36:02,589
there's a valid I didn't even write it

00:36:00,910 --> 00:36:05,230
but you guys can imagine what valid

00:36:02,589 --> 00:36:07,780
looks like or the bool okay so here's

00:36:05,230 --> 00:36:10,119
the original code here's what it looks

00:36:07,780 --> 00:36:11,589
like all these these functions are

00:36:10,119 --> 00:36:15,339
really short and they're going to get in

00:36:11,589 --> 00:36:20,200
line and what happens well if M active

00:36:15,339 --> 00:36:22,210
if M active I mean if you're in the m

00:36:20,200 --> 00:36:24,670
active branch then M active is true

00:36:22,210 --> 00:36:25,809
right I mean like that's pretty easy for

00:36:24,670 --> 00:36:27,910
you to figure out it's pretty easy for a

00:36:25,809 --> 00:36:30,609
compiler to figure out too so the second

00:36:27,910 --> 00:36:33,069
branch is vanishes and you just don't

00:36:30,609 --> 00:36:34,960
get any of that junk and you saw what

00:36:33,069 --> 00:36:36,280
the assembly looks like right not only

00:36:34,960 --> 00:36:39,369
is there no second branch there's none

00:36:36,280 --> 00:36:42,220
of the exception related junk that you

00:36:39,369 --> 00:36:43,859
might expect so the compiler does this

00:36:42,220 --> 00:36:46,410
very very well so

00:36:43,859 --> 00:36:48,720
you know so that is not a good reason

00:36:46,410 --> 00:36:51,299
why star should not do the check maybe

00:36:48,720 --> 00:36:52,140
there are better reasons I don't know

00:36:51,299 --> 00:36:54,359
okay

00:36:52,140 --> 00:36:55,799
so this section we're gonna talk about a

00:36:54,359 --> 00:36:59,059
little bit about how to write code a

00:36:55,799 --> 00:37:01,680
little differently to help the compiler

00:36:59,059 --> 00:37:03,539
okay so this first technique I call with

00:37:01,680 --> 00:37:05,130
bool it's a little bit comes back to our

00:37:03,539 --> 00:37:10,319
previous example where we have a boolean

00:37:05,130 --> 00:37:12,509
in a loop so one thing is that compilers

00:37:10,319 --> 00:37:16,499
are not very aggressive about pulling a

00:37:12,509 --> 00:37:17,670
boolean out of a loop even at O 3 and I

00:37:16,499 --> 00:37:19,079
actually understand where the compiler

00:37:17,670 --> 00:37:21,839
is coming from it duplicates a lot of

00:37:19,079 --> 00:37:23,660
code and the branch predictor is good

00:37:21,839 --> 00:37:26,579
right so that branch doesn't cost much

00:37:23,660 --> 00:37:28,200
necessarily but sometimes you really

00:37:26,579 --> 00:37:31,079
know that you want to pull the branch

00:37:28,200 --> 00:37:32,549
out of the loop despite everything can

00:37:31,079 --> 00:37:33,299
someone give me an example like why

00:37:32,549 --> 00:37:35,099
would I know

00:37:33,299 --> 00:37:37,160
even without measuring that I really

00:37:35,099 --> 00:37:39,390
want to pull this branch out of the loop

00:37:37,160 --> 00:37:44,640
there's actually a very one very simple

00:37:39,390 --> 00:37:48,089
example so very simple example is

00:37:44,640 --> 00:37:50,069
basically if you all know that you're

00:37:48,089 --> 00:37:52,470
only ever going to call one version ever

00:37:50,069 --> 00:37:53,880
in your program and that may sound

00:37:52,470 --> 00:37:54,450
really weird but this happens all the

00:37:53,880 --> 00:37:56,700
time

00:37:54,450 --> 00:37:59,400
you have boolean that enter at configure

00:37:56,700 --> 00:38:01,170
time and you read it once from the

00:37:59,400 --> 00:38:03,720
configuration you're only ever going to

00:38:01,170 --> 00:38:05,099
use that value so it's a runtime option

00:38:03,720 --> 00:38:07,109
but it doesn't change for the life of

00:38:05,099 --> 00:38:08,640
the program so depending what domain you

00:38:07,109 --> 00:38:10,710
program in you might have a lot of data

00:38:08,640 --> 00:38:13,619
like this you might have a little an H

00:38:10,710 --> 00:38:15,420
of T this is super common so if that

00:38:13,619 --> 00:38:18,210
happens you're making your binary bigger

00:38:15,420 --> 00:38:20,400
but that extra code is never being

00:38:18,210 --> 00:38:23,609
executed so the i-cash impact is

00:38:20,400 --> 00:38:25,380
basically zero and you know it probably

00:38:23,609 --> 00:38:27,150
makes sense to pull it out although you

00:38:25,380 --> 00:38:29,039
know you probably should measure to

00:38:27,150 --> 00:38:32,880
double check but you know you need a

00:38:29,039 --> 00:38:35,099
default let's put it this way so how can

00:38:32,880 --> 00:38:36,839
we force the compiler to do this even

00:38:35,099 --> 00:38:38,309
though it doesn't want to of course

00:38:36,839 --> 00:38:39,900
templates I think templates are

00:38:38,309 --> 00:38:42,930
basically there to careers to compiler

00:38:39,900 --> 00:38:44,220
so you know if you just use a template

00:38:42,930 --> 00:38:46,289
though you'd need to pass the bool or

00:38:44,220 --> 00:38:47,489
compile time but we have a runtime bool

00:38:46,289 --> 00:38:50,999
that's no problem

00:38:47,489 --> 00:38:52,680
we do this this pattern I don't know the

00:38:50,999 --> 00:38:55,200
name for it I always think of it as a

00:38:52,680 --> 00:38:56,849
lift you take a runtime value and lift

00:38:55,200 --> 00:38:57,930
it back into the type system by paying a

00:38:56,849 --> 00:39:00,290
one time

00:38:57,930 --> 00:39:03,090
so that's sort of what's going on here

00:39:00,290 --> 00:39:05,730
and we can actually extract the generic

00:39:03,090 --> 00:39:08,310
part of this so here's with pool it

00:39:05,730 --> 00:39:09,870
takes a functor and it calls it with

00:39:08,310 --> 00:39:12,570
either stood true type or stood false

00:39:09,870 --> 00:39:16,710
type depending on the value of a runtime

00:39:12,570 --> 00:39:18,480
ball and you you can use this generic

00:39:16,710 --> 00:39:20,640
construct to rewrite quacks and it's

00:39:18,480 --> 00:39:22,800
it's pretty nice right I mean it looks

00:39:20,640 --> 00:39:28,500
pretty much like the original with one

00:39:22,800 --> 00:39:30,060
extra set of indentation so yeah so

00:39:28,500 --> 00:39:34,830
let's kind of conclude this the sorting

00:39:30,060 --> 00:39:36,180
saga so why if we think about all the

00:39:34,830 --> 00:39:38,700
you know things we've talked about so

00:39:36,180 --> 00:39:42,000
far why does this produce poor assembly

00:39:38,700 --> 00:39:44,850
well it comes back to through this

00:39:42,000 --> 00:39:46,830
problem when the function pointer gets

00:39:44,850 --> 00:39:49,020
passed to sort it reduces its type and

00:39:46,830 --> 00:39:51,090
its type is going to be a generic not a

00:39:49,020 --> 00:39:54,780
generic a function pointer type right

00:39:51,090 --> 00:39:56,550
and that function pointer the type it

00:39:54,780 --> 00:39:58,110
does not encode what's getting called

00:39:56,550 --> 00:40:00,200
it's the value of the function pointer

00:39:58,110 --> 00:40:03,240
that decides what's getting called so

00:40:00,200 --> 00:40:05,520
remember now you're gonna say well but

00:40:03,240 --> 00:40:08,430
I'm calling you know my you know sort

00:40:05,520 --> 00:40:11,520
with the constant right but we saw in

00:40:08,430 --> 00:40:12,750
the previous example if sort is not in

00:40:11,520 --> 00:40:15,750
line and it's not going to be in line

00:40:12,750 --> 00:40:17,630
it's big then you're not going to expect

00:40:15,750 --> 00:40:21,420
my comp to be in line in the sort I

00:40:17,630 --> 00:40:23,340
generally speaking GCC with O three will

00:40:21,420 --> 00:40:26,720
not in line sort but it actually clones

00:40:23,340 --> 00:40:28,980
sort and then you get the inlining but

00:40:26,720 --> 00:40:31,140
it's very hard for the compiler to know

00:40:28,980 --> 00:40:33,000
whether it's worth it and that's why

00:40:31,140 --> 00:40:35,670
doing something ridiculous like wrapping

00:40:33,000 --> 00:40:37,170
a function pointer in a lambda it

00:40:35,670 --> 00:40:39,570
actually communicates a kind of intent

00:40:37,170 --> 00:40:42,330
to your compiler right like no compiler

00:40:39,570 --> 00:40:43,980
will ever take multiple sorts called

00:40:42,330 --> 00:40:45,600
with different lambdas and then fold

00:40:43,980 --> 00:40:49,950
them back together and add indirection

00:40:45,600 --> 00:40:51,120
that doesn't happen so there's like a

00:40:49,950 --> 00:40:53,100
really interesting thing you can do

00:40:51,120 --> 00:40:54,600
around this especially in C++ seventeen

00:40:53,100 --> 00:40:57,660
you can have this function object

00:40:54,600 --> 00:41:02,610
function object lifts the function

00:40:57,660 --> 00:41:03,960
pointer into a type and you know there's

00:41:02,610 --> 00:41:06,330
actually a proposal for this it's called

00:41:03,960 --> 00:41:07,800
mono state function so this is kind of

00:41:06,330 --> 00:41:11,350
like the lambda but with all the details

00:41:07,800 --> 00:41:13,180
taken care of for you okay

00:41:11,350 --> 00:41:15,340
this last section is called it well it's

00:41:13,180 --> 00:41:17,380
a cry for help so this is about code

00:41:15,340 --> 00:41:19,570
that's like hard to write efficiently as

00:41:17,380 --> 00:41:23,260
things stand so I don't know maybe the

00:41:19,570 --> 00:41:25,330
goal is to draw attention to it so you

00:41:23,260 --> 00:41:27,370
know the talks originally about you know

00:41:25,330 --> 00:41:30,370
me helping you help the compiler help

00:41:27,370 --> 00:41:31,990
you and now I'm trying to help the

00:41:30,370 --> 00:41:35,640
committee help you to help the compiler

00:41:31,990 --> 00:41:36,850
to help you so it's all very helpful

00:41:35,640 --> 00:41:40,000
okay

00:41:36,850 --> 00:41:41,920
so reading bytes destruct so in certain

00:41:40,000 --> 00:41:44,290
industries like H of T you know this

00:41:41,920 --> 00:41:46,510
pattern you have a buffer of bytes you

00:41:44,290 --> 00:41:48,220
have a header you reinterpret cast to

00:41:46,510 --> 00:41:49,480
get the header at the front the header

00:41:48,220 --> 00:41:51,640
tells you the type of the data that

00:41:49,480 --> 00:41:53,590
follows okay if you're at age of T you

00:41:51,640 --> 00:41:56,140
write this code like you breathe I mean

00:41:53,590 --> 00:41:59,040
it's just seems totally natural everyone

00:41:56,140 --> 00:42:01,090
does is with reinterpret cast everyone

00:41:59,040 --> 00:42:05,530
there's like one little problem with

00:42:01,090 --> 00:42:06,790
reinterpret casting here which is it's

00:42:05,530 --> 00:42:08,890
undefined okay

00:42:06,790 --> 00:42:10,630
maybe my alignment is wrong these slides

00:42:08,890 --> 00:42:12,010
are super simplified but even if the

00:42:10,630 --> 00:42:15,280
alignment was perfect it would still be

00:42:12,010 --> 00:42:17,380
undefined behavior you know there is no

00:42:15,280 --> 00:42:18,850
object that's ever been created as far

00:42:17,380 --> 00:42:21,280
as the compiler is concerned of header

00:42:18,850 --> 00:42:24,720
type so this is the compliant way to do

00:42:21,280 --> 00:42:27,670
this you header type you men copy

00:42:24,720 --> 00:42:30,880
okay well mem copying is doing stuff

00:42:27,670 --> 00:42:32,620
right now if you talk to people like one

00:42:30,880 --> 00:42:33,820
of these tried generic observations that

00:42:32,620 --> 00:42:35,410
people will make that I really dislike

00:42:33,820 --> 00:42:38,320
is the big R but the mem copy will get

00:42:35,410 --> 00:42:40,090
optimized right so I hope by this point

00:42:38,320 --> 00:42:42,490
in the talk you guys are too suspicious

00:42:40,090 --> 00:42:45,070
to just accept the idea that the mem

00:42:42,490 --> 00:42:46,810
copy is going to get optimized so here's

00:42:45,070 --> 00:42:49,600
a example I can actually feed the

00:42:46,810 --> 00:42:51,670
compiler so header type and first type

00:42:49,600 --> 00:42:55,260
are just basic structs with a couple of

00:42:51,670 --> 00:42:59,530
int and double fields nothing special

00:42:55,260 --> 00:43:03,520
so I feed this in and basically what you

00:42:59,530 --> 00:43:05,680
will see is that one of the men copies

00:43:03,520 --> 00:43:08,770
gets gets eliminated and one does not

00:43:05,680 --> 00:43:10,440
okay so the first part of the code that

00:43:08,770 --> 00:43:12,850
corresponds to reading the header

00:43:10,440 --> 00:43:15,010
there's no man copy there but the second

00:43:12,850 --> 00:43:17,860
part of the code you'll see the move DQ

00:43:15,010 --> 00:43:19,300
you and move ApS instructions for my

00:43:17,860 --> 00:43:20,680
small struck that's actually what mem

00:43:19,300 --> 00:43:22,780
copy ended up being because it was just

00:43:20,680 --> 00:43:24,300
a couple of fields so one gets optimized

00:43:22,780 --> 00:43:30,000
but not the other okay

00:43:24,300 --> 00:43:31,800
so so why you know why the answer is

00:43:30,000 --> 00:43:33,660
basically like in the first case it's

00:43:31,800 --> 00:43:35,490
only using header type locally right

00:43:33,660 --> 00:43:37,770
everything's by value everything's local

00:43:35,490 --> 00:43:39,480
you're all in one block the compiler can

00:43:37,770 --> 00:43:41,070
see exactly what's going on in the

00:43:39,480 --> 00:43:42,870
second case you're taking this object

00:43:41,070 --> 00:43:44,970
and you're passing it into a function

00:43:42,870 --> 00:43:45,920
that the compiler knows nothing about by

00:43:44,970 --> 00:43:48,210
reference

00:43:45,920 --> 00:43:50,640
remember how const reference is

00:43:48,210 --> 00:43:52,320
worthless right so this function can

00:43:50,640 --> 00:43:55,500
cast away Const and it can mutate the

00:43:52,320 --> 00:43:56,820
type and now suddenly whether you mem

00:43:55,500 --> 00:43:59,550
copy it or not as a semantic difference

00:43:56,820 --> 00:44:00,960
right in one case the buffer is being

00:43:59,550 --> 00:44:03,870
mutated and in the other case it's not

00:44:00,960 --> 00:44:08,420
and the compiler will not will mem copy

00:44:03,870 --> 00:44:12,300
for that reason so how can we fix this

00:44:08,420 --> 00:44:13,560
so we want an object so it's not you be

00:44:12,300 --> 00:44:15,090
like a true object and we want to

00:44:13,560 --> 00:44:17,540
construct it in an arbitrary point how

00:44:15,090 --> 00:44:17,540
do we do that

00:44:17,720 --> 00:44:24,000
placement no don't do this

00:44:20,490 --> 00:44:26,340
so this version of safecast that just

00:44:24,000 --> 00:44:27,960
placements new an object we should

00:44:26,340 --> 00:44:30,870
really static assert that the object is

00:44:27,960 --> 00:44:32,940
trivially everything and this will

00:44:30,870 --> 00:44:35,160
actually work typically but you're just

00:44:32,940 --> 00:44:38,280
banking on the fact that a placement new

00:44:35,160 --> 00:44:40,170
literally does nothing right like that's

00:44:38,280 --> 00:44:42,150
not required by the standard it's

00:44:40,170 --> 00:44:43,590
actually unspecified what happens like

00:44:42,150 --> 00:44:45,630
it's equivalent to int X and then

00:44:43,590 --> 00:44:47,070
reading you know well it's not quite

00:44:45,630 --> 00:44:48,390
equivalent but there's no guarantee that

00:44:47,070 --> 00:44:51,750
the underlying memory is the same it's

00:44:48,390 --> 00:44:53,790
just unspecified so so here's a really

00:44:51,750 --> 00:44:56,400
crazy trick I can't take credit for some

00:44:53,790 --> 00:44:59,040
dude on reddit told me this it's pretty

00:44:56,400 --> 00:45:01,080
cool so the idea is that the placement

00:44:59,040 --> 00:45:03,660
new could actually overwrite stuff if it

00:45:01,080 --> 00:45:06,180
wanted to so you create a buffer you

00:45:03,660 --> 00:45:07,980
copy out where you want to placement new

00:45:06,180 --> 00:45:13,140
then you placement new and then you copy

00:45:07,980 --> 00:45:15,090
back so it's like the song like to mem

00:45:13,140 --> 00:45:17,940
copies are better than one right because

00:45:15,090 --> 00:45:21,660
this just optimizes to nothing no mem

00:45:17,940 --> 00:45:23,040
copies ever pretty crazy should you

00:45:21,660 --> 00:45:24,570
there's a new problem that's been

00:45:23,040 --> 00:45:29,060
introduced by placement nuke anyone tell

00:45:24,570 --> 00:45:32,400
me what it is I introduced a new problem

00:45:29,060 --> 00:45:34,770
right it's like trying to cover you know

00:45:32,400 --> 00:45:36,720
a large animal with a very small piece

00:45:34,770 --> 00:45:37,980
of cloth like you shift it around in a

00:45:36,720 --> 00:45:41,270
different part of the animals

00:45:37,980 --> 00:45:45,270
not covered right what's the new problem

00:45:41,270 --> 00:45:47,430
what's that no the new problem is that

00:45:45,270 --> 00:45:49,320
it's not contract okay I mean the

00:45:47,430 --> 00:45:51,900
placement new you need mutable access

00:45:49,320 --> 00:45:53,760
and conceptually we are not writing to

00:45:51,900 --> 00:45:55,290
the buffer why should we need mutable

00:45:53,760 --> 00:45:58,740
access to this buffer this is nonsense

00:45:55,290 --> 00:46:00,690
so you could Const caste see the dark

00:45:58,740 --> 00:46:02,040
road were going down but I guarantee you

00:46:00,690 --> 00:46:03,660
and a large enough program if you cast

00:46:02,040 --> 00:46:05,460
away Const someone will eventually pass

00:46:03,660 --> 00:46:05,880
in something Const and you will psyche

00:46:05,460 --> 00:46:07,980
fault

00:46:05,880 --> 00:46:09,690
so should you do that should you

00:46:07,980 --> 00:46:11,430
reinterpret cast all the options here

00:46:09,690 --> 00:46:13,920
are terrible I don't know what to tell

00:46:11,430 --> 00:46:16,410
you three months ago I would have said

00:46:13,920 --> 00:46:17,790
just reinterpret cast and I thought

00:46:16,410 --> 00:46:19,770
there was like a gentlemen's agreement

00:46:17,790 --> 00:46:22,350
that compilers would not optimize based

00:46:19,770 --> 00:46:25,350
on that UB because there's no other good

00:46:22,350 --> 00:46:28,500
way to do it but now seems like they are

00:46:25,350 --> 00:46:31,859
I had a crazy bug with GCC at o3 where

00:46:28,500 --> 00:46:33,359
it just turned a perfect like a function

00:46:31,859 --> 00:46:36,450
that used reinterpret cast into garbage

00:46:33,359 --> 00:46:38,640
and it took a long time to track down

00:46:36,450 --> 00:46:40,560
because like adding a print statement

00:46:38,640 --> 00:46:43,020
would change all the code gem and make

00:46:40,560 --> 00:46:47,640
the bug go away so that's super fun to

00:46:43,020 --> 00:46:50,850
debug okay so my last example I'm gonna

00:46:47,640 --> 00:46:52,800
grind through this really quick so this

00:46:50,850 --> 00:46:55,260
is related to the first example a little

00:46:52,800 --> 00:46:57,300
bit so you have the situation where you

00:46:55,260 --> 00:46:59,040
have a runtime variable telling you how

00:46:57,300 --> 00:47:02,640
to understand a certain piece of memory

00:46:59,040 --> 00:47:04,140
right and you know maybe you want to

00:47:02,640 --> 00:47:06,660
apply some function that depends on the

00:47:04,140 --> 00:47:11,010
type so here we have a visitor we have a

00:47:06,660 --> 00:47:12,420
runtime index and you know we're calling

00:47:11,010 --> 00:47:15,300
different functions this is great right

00:47:12,420 --> 00:47:16,980
there's one problem with this code it

00:47:15,300 --> 00:47:19,530
can't be made generic right like switch

00:47:16,980 --> 00:47:22,920
cases cannot be generated so how do we

00:47:19,530 --> 00:47:26,340
do this generically well you can use

00:47:22,920 --> 00:47:28,950
function pointers so this is my really

00:47:26,340 --> 00:47:31,470
bad approximation of you know template

00:47:28,950 --> 00:47:33,119
magic stuff but the basic gist of it is

00:47:31,470 --> 00:47:35,910
you create a function pointer that takes

00:47:33,119 --> 00:47:38,280
the data buffer and the visitor it casts

00:47:35,910 --> 00:47:40,859
it to the particular type and then it

00:47:38,280 --> 00:47:42,780
applies the visitor and then you can

00:47:40,859 --> 00:47:45,450
write a generic foo with whatever types

00:47:42,780 --> 00:47:47,790
you want and it generates this array of

00:47:45,450 --> 00:47:50,430
function pointers at compile time right

00:47:47,790 --> 00:47:51,840
Const exper and then it calls the right

00:47:50,430 --> 00:47:55,020
function pointer

00:47:51,840 --> 00:47:57,480
based on the index SuperDuper awesome

00:47:55,020 --> 00:47:58,770
okay this is really weird code why am I

00:47:57,480 --> 00:48:00,510
talking about this if you're a library

00:47:58,770 --> 00:48:04,520
implementer don't answer why am I

00:48:00,510 --> 00:48:07,530
talking about this example anyone know

00:48:04,520 --> 00:48:09,870
okay this is how very very very very

00:48:07,530 --> 00:48:11,790
roughly please don't kill me this is how

00:48:09,870 --> 00:48:13,800
a variant is and visitar implemented

00:48:11,790 --> 00:48:15,810
okay if you've ever wondered by what

00:48:13,800 --> 00:48:18,180
dark magic you can call visit on a

00:48:15,810 --> 00:48:20,100
variant right and it this is exactly

00:48:18,180 --> 00:48:22,650
what visit does right it's got some

00:48:20,100 --> 00:48:24,570
memory it's one of a list of types based

00:48:22,650 --> 00:48:27,150
on some runtime variable and it will

00:48:24,570 --> 00:48:33,110
call the right function and your visitor

00:48:27,150 --> 00:48:38,070
and this is basically how it works great

00:48:33,110 --> 00:48:40,200
there's only one problem so this is some

00:48:38,070 --> 00:48:42,600
code standard library code that you

00:48:40,200 --> 00:48:45,060
could run today with you know multiple

00:48:42,600 --> 00:48:49,020
compilers what what what do you guys

00:48:45,060 --> 00:48:52,740
think this generates right the compilers

00:48:49,020 --> 00:48:54,180
smart right it is but this code is

00:48:52,740 --> 00:48:59,400
probably not everything you would hope

00:48:54,180 --> 00:49:01,320
for this is really bad I mean remember

00:48:59,400 --> 00:49:02,880
my story at the beginning those of you

00:49:01,320 --> 00:49:05,490
who didn't put up your hand when I asked

00:49:02,880 --> 00:49:10,320
you if you'd seen crappy assembly now

00:49:05,490 --> 00:49:12,840
you have this is a no op visitor so if

00:49:10,320 --> 00:49:16,350
this function does nothing ever like

00:49:12,840 --> 00:49:19,700
guaranteed to do nothing why doesn't it

00:49:16,350 --> 00:49:19,700
get optimized I have no idea

00:49:19,940 --> 00:49:24,720
you can't optimize it you can actually

00:49:22,650 --> 00:49:26,640
write your own visit function for it's

00:49:24,720 --> 00:49:29,430
very straightforward for the single

00:49:26,640 --> 00:49:32,940
variant case you do have to cover by

00:49:29,430 --> 00:49:35,460
hand the different arenas of the

00:49:32,940 --> 00:49:37,380
variants so you have to do one type

00:49:35,460 --> 00:49:39,510
vector a variant and a to type variant

00:49:37,380 --> 00:49:42,720
but you can do it and you can do it with

00:49:39,510 --> 00:49:45,600
switch case and write it up by hand and

00:49:42,720 --> 00:49:48,360
you know you could wrap a visit in your

00:49:45,600 --> 00:49:50,490
own visit right that that calls out to

00:49:48,360 --> 00:49:57,810
the other visit if you're not handling

00:49:50,490 --> 00:49:59,820
that case and if you okay anyway so you

00:49:57,810 --> 00:50:02,040
know if you change the visit from the

00:49:59,820 --> 00:50:05,230
standard visit to this visit here you

00:50:02,040 --> 00:50:07,000
will actually get no assembly right

00:50:05,230 --> 00:50:08,440
and aside from the fact that like I'm

00:50:07,000 --> 00:50:09,760
sure all the details and consecration

00:50:08,440 --> 00:50:11,800
isn't forwarding everything is wrong

00:50:09,760 --> 00:50:13,900
with this snippet but if you fixed all

00:50:11,800 --> 00:50:17,320
that up you could write a visitor for

00:50:13,900 --> 00:50:19,030
for to type variants and it would be

00:50:17,320 --> 00:50:21,700
correct all the time and it would give

00:50:19,030 --> 00:50:24,790
you better assembly so the state of

00:50:21,700 --> 00:50:27,310
affairs for variant a you know it's not

00:50:24,790 --> 00:50:29,430
great I wouldn't personally I wouldn't

00:50:27,310 --> 00:50:32,140
use visiting performance critical code

00:50:29,430 --> 00:50:35,560
just right off the bat because of these

00:50:32,140 --> 00:50:37,300
issues but you know you might want to

00:50:35,560 --> 00:50:40,000
consider if you do that write your own

00:50:37,300 --> 00:50:41,770
visit and hopefully at some point I mean

00:50:40,000 --> 00:50:44,650
the compiler should be able to optimize

00:50:41,770 --> 00:50:47,530
this so you know I can see the

00:50:44,650 --> 00:50:51,220
perspective that the implementation is

00:50:47,530 --> 00:50:52,660
fine because all the function pointers

00:50:51,220 --> 00:50:55,150
are contexts per right so the compiler

00:50:52,660 --> 00:50:57,550
should know them at compile time but it

00:50:55,150 --> 00:51:03,880
just doesn't inline them and that's why

00:50:57,550 --> 00:51:05,890
you have this problem okay so please try

00:51:03,880 --> 00:51:07,599
to avoid generalizations the compilers

00:51:05,890 --> 00:51:09,130
smart the compilers Dom like the

00:51:07,599 --> 00:51:11,500
compiler doesn't have an IQ it's not a

00:51:09,130 --> 00:51:14,380
person it's great at some things it's

00:51:11,500 --> 00:51:16,680
bad at others it's a tool okay it's

00:51:14,380 --> 00:51:18,849
usually very very good within its domain

00:51:16,680 --> 00:51:21,819
when it has the information that it

00:51:18,849 --> 00:51:23,980
needs but it also has blind spots right

00:51:21,819 --> 00:51:26,619
like I saw in the previous slide so you

00:51:23,980 --> 00:51:28,900
know you'll pick up what those are by

00:51:26,619 --> 00:51:30,579
experience understand when you can

00:51:28,900 --> 00:51:32,260
change the way you write code to help

00:51:30,579 --> 00:51:36,609
the compiler generate the assembly that

00:51:32,260 --> 00:51:39,550
you want and I mean I just want to close

00:51:36,609 --> 00:51:40,930
off by going back to my story so you

00:51:39,550 --> 00:51:43,060
know you may have thought that my son

00:51:40,930 --> 00:51:45,810
was like 10 from the story but actually

00:51:43,060 --> 00:51:48,280
he was 2 and he was potty training so I

00:51:45,810 --> 00:51:49,750
mean it was totally my fault I should

00:51:48,280 --> 00:51:51,940
have put him in a diaper for the flight

00:51:49,750 --> 00:51:54,640
so you know I had to take responsibility

00:51:51,940 --> 00:51:56,470
for that and when you look at assembly

00:51:54,640 --> 00:51:58,109
and you feel like it's crap then you

00:51:56,470 --> 00:52:00,250
know take responsibility for your crap

00:51:58,109 --> 00:52:09,170
thank you

00:52:00,250 --> 00:52:14,640
[Applause]

00:52:09,170 --> 00:52:17,520
question you want to just use the mic

00:52:14,640 --> 00:52:18,630
I'll be looking here I don't know I

00:52:17,520 --> 00:52:20,040
don't know I'm leaning into that

00:52:18,630 --> 00:52:20,670
microphone it's pretty dumb I have a

00:52:20,040 --> 00:52:24,569
question

00:52:20,670 --> 00:52:27,869
oh sorry questions last comment I also

00:52:24,569 --> 00:52:31,920
work in trading go and I also

00:52:27,869 --> 00:52:34,319
reinterpret cast yeah I gave a lightning

00:52:31,920 --> 00:52:35,970
talk of years ago about how nasty it is

00:52:34,319 --> 00:52:39,599
that memory thing is really interesting

00:52:35,970 --> 00:52:41,760
I'm hoping maybe possibly that the that

00:52:39,599 --> 00:52:45,119
the big cast that is being proposed

00:52:41,760 --> 00:52:46,799
might be not 100% there right now but

00:52:45,119 --> 00:52:49,559
like the right customization point to

00:52:46,799 --> 00:52:53,309
make that just be better I had my mind

00:52:49,559 --> 00:52:55,049
alias cast but maybe will do it yeah I

00:52:53,309 --> 00:52:57,780
actually I've totally forgot there's a

00:52:55,049 --> 00:53:00,150
proposal called implicit instantiation

00:52:57,780 --> 00:53:02,069
of low-level objects for bike

00:53:00,150 --> 00:53:05,130
manipulation or something like that and

00:53:02,069 --> 00:53:07,349
I don't I didn't read all of it but it

00:53:05,130 --> 00:53:08,670
introduces this thing called bless where

00:53:07,349 --> 00:53:10,200
I think you can like bless an object

00:53:08,670 --> 00:53:12,270
into existence are you involved with

00:53:10,200 --> 00:53:14,579
that paper no but it sounds awesome yeah

00:53:12,270 --> 00:53:16,680
it's it's really cool and actually yeah

00:53:14,579 --> 00:53:18,510
like let's move that along so all the

00:53:16,680 --> 00:53:20,730
horrors from that part of the

00:53:18,510 --> 00:53:23,099
presentation can die one would think

00:53:20,730 --> 00:53:24,930
that that people over an SG 14 would be

00:53:23,099 --> 00:53:26,819
talking about it yeah I'm sure they are

00:53:24,930 --> 00:53:28,319
but you know it's uh it's a lot of work

00:53:26,819 --> 00:53:29,760
to move out anything through right so

00:53:28,319 --> 00:53:31,380
but hopefully we'll have it soon it

00:53:29,760 --> 00:53:31,650
seems to have picked up something thank

00:53:31,380 --> 00:53:39,349
you

00:53:31,650 --> 00:53:39,349
oh thanks yeah the importance of knowing

00:53:40,910 --> 00:53:54,690
in blind assembly if do you have any

00:53:48,119 --> 00:53:56,549
suggestions from knowing that I mean the

00:53:54,690 --> 00:53:57,480
assembly is the sir the question was

00:53:56,549 --> 00:53:59,910
like how do you defend it like

00:53:57,480 --> 00:54:03,270
definitively know if a function was in

00:53:59,910 --> 00:54:04,770
line aside from the assembly I mean the

00:54:03,270 --> 00:54:07,260
assembly is only the the only way to

00:54:04,770 --> 00:54:09,690
know for sure right I mean the assembly

00:54:07,260 --> 00:54:12,030
is what's executed so the assembly is

00:54:09,690 --> 00:54:13,410
definitive and other than that I mean

00:54:12,030 --> 00:54:14,880
you have these heuristics

00:54:13,410 --> 00:54:17,640
I don't know of

00:54:14,880 --> 00:54:19,110
like if there's a way I mean you can use

00:54:17,640 --> 00:54:20,850
attribute in line if you know you want

00:54:19,110 --> 00:54:25,590
to force it but I don't know a way to

00:54:20,850 --> 00:54:27,360
like you know maybe LLVM well that's

00:54:25,590 --> 00:54:29,580
mostly yeah I don't know a way to like

00:54:27,360 --> 00:54:33,390
log whether a function was in line or

00:54:29,580 --> 00:54:38,790
not it's not that you asked yeah

00:54:33,390 --> 00:54:41,490
question over here I have some comments

00:54:38,790 --> 00:54:44,700
about to talk no questions

00:54:41,490 --> 00:54:48,510
that's so high qualified compiler guy

00:54:44,700 --> 00:54:50,660
but I have some vision and know

00:54:48,510 --> 00:54:53,850
something about source internal details

00:54:50,660 --> 00:54:57,030
so its first about inlining and

00:54:53,850 --> 00:55:00,990
differences between compilers and there

00:54:57,030 --> 00:55:03,300
is no very simple source of the

00:55:00,990 --> 00:55:07,650
differences because different compilers

00:55:03,300 --> 00:55:12,240
have different in in line in winding

00:55:07,650 --> 00:55:14,490
mechanism inside inside and they have a

00:55:12,240 --> 00:55:20,010
lot of differences between thresholds

00:55:14,490 --> 00:55:23,460
for inlining so if you look into clang

00:55:20,010 --> 00:55:28,830
or GCC you will find a lot of different

00:55:23,460 --> 00:55:34,920
magic numbers for different cost code

00:55:28,830 --> 00:55:37,650
models and in inline ink you can you

00:55:34,920 --> 00:55:42,180
know for betting line Inc you can use LT

00:55:37,650 --> 00:55:44,480
oh yeah I mean so like I mentioned LT I

00:55:42,180 --> 00:55:48,960
was like a whole kettle of fish you can

00:55:44,480 --> 00:55:53,700
it can help you with in lining I mean my

00:55:48,960 --> 00:55:55,020
main observation is you know potentially

00:55:53,700 --> 00:55:57,690
one of the issues of the LTO is that

00:55:55,020 --> 00:55:59,460
like in lining is not like the end game

00:55:57,690 --> 00:56:02,130
optimization right in lining could be

00:55:59,460 --> 00:56:03,600
the start of many more and at least

00:56:02,130 --> 00:56:04,560
based on my understanding of LT o is

00:56:03,600 --> 00:56:07,500
like because linking is not

00:56:04,560 --> 00:56:10,440
parallelizable I don't as far as I know

00:56:07,500 --> 00:56:13,380
it's not able to spend as long grinding

00:56:10,440 --> 00:56:15,060
through so I think LT o is like amazing

00:56:13,380 --> 00:56:17,190
and if you just want to make your

00:56:15,060 --> 00:56:19,710
application faster in general of course

00:56:17,190 --> 00:56:21,330
it's something you should do but like

00:56:19,710 --> 00:56:22,800
for us and aegypti like usually it's

00:56:21,330 --> 00:56:25,080
much more like black and white like

00:56:22,800 --> 00:56:26,970
either I on the compiler to know about

00:56:25,080 --> 00:56:28,770
this function and definitely like

00:56:26,970 --> 00:56:30,480
optimize it or I don't

00:56:28,770 --> 00:56:32,550
and if you're working in that kind of

00:56:30,480 --> 00:56:34,590
world LTO is much less I think it's much

00:56:32,550 --> 00:56:36,810
less valuable because I'm rather

00:56:34,590 --> 00:56:39,960
defining a function in a header file or

00:56:36,810 --> 00:56:43,320
I don't care that's like very simple for

00:56:39,960 --> 00:56:47,150
me right and about your last example

00:56:43,320 --> 00:56:50,400
we've stood variant it's a known bug in

00:56:47,150 --> 00:56:53,010
jesusí at least and Anthony pollution

00:56:50,400 --> 00:56:54,960
already reported about this Oh like this

00:56:53,010 --> 00:56:57,090
was reported as a performance bug yep

00:56:54,960 --> 00:56:59,010
okay well clang does the same thing both

00:56:57,090 --> 00:57:03,180
with GCC and with its own standard

00:56:59,010 --> 00:57:03,710
library yeah I mean the thing to keep in

00:57:03,180 --> 00:57:05,670
mind

00:57:03,710 --> 00:57:08,400
yeah the compiler should probably

00:57:05,670 --> 00:57:10,650
optimize that but at some level I do

00:57:08,400 --> 00:57:13,020
still wish that like an optimization for

00:57:10,650 --> 00:57:14,280
the common cases had been written but on

00:57:13,020 --> 00:57:16,680
the flip side I know the library

00:57:14,280 --> 00:57:17,670
maintainer czar crazy-busy I'm one thing

00:57:16,680 --> 00:57:19,350
to keep in mind is like the average

00:57:17,670 --> 00:57:23,430
person in this room is probably on what

00:57:19,350 --> 00:57:25,530
GCC six maybe so we're on GCC eight now

00:57:23,430 --> 00:57:27,300
and so like if this lands and if this

00:57:25,530 --> 00:57:29,220
landed tomorrow then most people in this

00:57:27,300 --> 00:57:31,170
room would still not be getting great

00:57:29,220 --> 00:57:34,830
assembly from variant for like two years

00:57:31,170 --> 00:57:36,390
so you know so I think you know my

00:57:34,830 --> 00:57:38,460
advice of maybe consider writing your

00:57:36,390 --> 00:57:39,810
own visit you know two years is like

00:57:38,460 --> 00:57:41,970
pretty good half-life for that for that

00:57:39,810 --> 00:57:43,140
suggestion right but but it's good to

00:57:41,970 --> 00:57:45,630
know that it's been reported and it's

00:57:43,140 --> 00:57:47,359
being taken seriously so thank you thank

00:57:45,630 --> 00:57:50,970
you

00:57:47,359 --> 00:57:53,280
yes just a small question you mentioned

00:57:50,970 --> 00:57:55,560
that lambda gets in line better than the

00:57:53,280 --> 00:57:56,760
other option in that sort example yes do

00:57:55,560 --> 00:58:01,530
you know if it matters if you give it a

00:57:56,760 --> 00:58:04,980
name if you just like do Auto x equals

00:58:01,530 --> 00:58:07,619
lambda and then you pass in X I'm I'd

00:58:04,980 --> 00:58:09,180
have to look but based on what I said in

00:58:07,619 --> 00:58:11,960
this talk I would say that it's almost

00:58:09,180 --> 00:58:14,640
certainly gonna not make a difference

00:58:11,960 --> 00:58:16,410
the compiler actually doesn't really

00:58:14,640 --> 00:58:18,990
necessarily care that much if you assign

00:58:16,410 --> 00:58:20,970
intermediate variables like I think like

00:58:18,990 --> 00:58:23,190
write the earliest optimization myth

00:58:20,970 --> 00:58:26,430
that you have to dispel for people

00:58:23,190 --> 00:58:28,530
learning C++ is that like if they put an

00:58:26,430 --> 00:58:30,000
intermediate calculation in a variable

00:58:28,530 --> 00:58:34,530
and give it a name they think it'll make

00:58:30,000 --> 00:58:38,190
things slower right like Auto you know s

00:58:34,530 --> 00:58:40,020
equals x plus y and then you know return

00:58:38,190 --> 00:58:42,600
S Plus Z they think that's lower than X

00:58:40,020 --> 00:58:44,760
plus y plus that and it's obviously not

00:58:42,600 --> 00:58:46,770
with the lambda I mean you make the

00:58:44,760 --> 00:58:48,030
local variable right there you pass it

00:58:46,770 --> 00:58:50,490
into the function right there in the

00:58:48,030 --> 00:58:52,620
same scope I mean not only it's gonna

00:58:50,490 --> 00:58:55,260
make a difference but but if you created

00:58:52,620 --> 00:58:56,400
like as a global lambda right then maybe

00:58:55,260 --> 00:58:58,590
things will be different because it

00:58:56,400 --> 00:59:00,450
could get used more than once you know

00:58:58,590 --> 00:59:05,460
who knows that's what I thought thank

00:59:00,450 --> 00:59:08,550
you very prompt yes so you can have more

00:59:05,460 --> 00:59:11,220
control over compiler with like built-in

00:59:08,550 --> 00:59:13,350
attributes and like things like building

00:59:11,220 --> 00:59:15,990
as soon hmm yes

00:59:13,350 --> 00:59:18,690
how much did does use this getting yo

00:59:15,990 --> 00:59:20,810
code base and again it gets used a lot

00:59:18,690 --> 00:59:24,180
I'll give like one of the most canonical

00:59:20,810 --> 00:59:26,190
examples and also I get to rant about

00:59:24,180 --> 00:59:28,320
something that I don't like so unlikely

00:59:26,190 --> 00:59:29,970
and likely they've been they're actually

00:59:28,320 --> 00:59:33,720
supposed to be standardized now for 20 I

00:59:29,970 --> 00:59:36,570
think and one thing that makes hft

00:59:33,720 --> 00:59:38,940
tricky is that you know we have code

00:59:36,570 --> 00:59:41,070
paths which we really care about but are

00:59:38,940 --> 00:59:42,630
almost never entered because when you're

00:59:41,070 --> 00:59:45,510
trading on an exchange you have millions

00:59:42,630 --> 00:59:47,250
of events and you don't trade 99.9

00:59:45,510 --> 00:59:50,250
percent of the time but nobody cares how

00:59:47,250 --> 00:59:51,960
fast you don't trade so any branch

00:59:50,250 --> 00:59:54,480
predictor right left to its own devices

00:59:51,960 --> 00:59:56,550
will say oh I'm gonna make your program

00:59:54,480 --> 00:59:58,830
run faster by always assuming that you

00:59:56,550 --> 01:00:01,010
don't trade and now trading is slow so

00:59:58,830 --> 01:00:03,060
this is the opposite of what you want so

01:00:01,010 --> 01:00:04,920
typically what you would do is and

01:00:03,060 --> 01:00:07,230
here's why I hate the names you would

01:00:04,920 --> 01:00:09,870
take the likely attribute and you would

01:00:07,230 --> 01:00:11,580
put it on the really unlikely branch and

01:00:09,870 --> 01:00:14,640
take the unlikely attribute and put it

01:00:11,580 --> 01:00:16,590
on the really likely branch so you know

01:00:14,640 --> 01:00:18,930
so the likely attribute kind of means

01:00:16,590 --> 01:00:20,640
compiler priests please pretend this is

01:00:18,930 --> 01:00:22,590
likely even if you don't think it is a

01:00:20,640 --> 01:00:24,660
better name I think would be like

01:00:22,590 --> 01:00:27,720
prioritize D prioritize or something

01:00:24,660 --> 01:00:30,000
like that but yeah that would be one

01:00:27,720 --> 01:00:32,160
example I mean one thing that's on from

01:00:30,000 --> 01:00:35,880
our company looked at which I think is

01:00:32,160 --> 01:00:38,490
is kind of funny is is just you have a

01:00:35,880 --> 01:00:40,530
branch on any arbitrary condition and

01:00:38,490 --> 01:00:43,560
then inside the branch you put assumed

01:00:40,530 --> 01:00:45,480
unreachable and now who the compiler

01:00:43,560 --> 01:00:49,350
will just be allowed to assume that that

01:00:45,480 --> 01:00:51,030
thing is not true and he actually found

01:00:49,350 --> 01:00:52,530
examples where the compiler leveraged

01:00:51,030 --> 01:00:54,720
that information to produce better code

01:00:52,530 --> 01:00:56,160
it's kind of crazy and also dangerous

01:00:54,720 --> 01:00:56,460
because if you violate the assumption

01:00:56,160 --> 01:00:59,910
then

01:00:56,460 --> 01:01:00,930
it's just pure on you b-but you see that

01:00:59,910 --> 01:01:03,560
actually a lot at the end of switch

01:01:00,930 --> 01:01:05,760
cases right if you have a switch case

01:01:03,560 --> 01:01:08,850
it's pretty common like if let's say you

01:01:05,760 --> 01:01:10,350
have return return return then

01:01:08,850 --> 01:01:12,150
technically you're hitting the end of a

01:01:10,350 --> 01:01:14,190
function body without a return after the

01:01:12,150 --> 01:01:18,540
switch case it's common to put like

01:01:14,190 --> 01:01:21,300
built-in unreachable yeah yeah very

01:01:18,540 --> 01:01:27,030
common usage yeah thank you no problem

01:01:21,300 --> 01:01:29,130
like yep so suppose you take a function

01:01:27,030 --> 01:01:30,990
you'll run the secret process or you say

01:01:29,130 --> 01:01:33,000
it's inline you take another function do

01:01:30,990 --> 01:01:34,170
the same you see what it's being

01:01:33,000 --> 01:01:35,880
produced in alignment you think you're

01:01:34,170 --> 01:01:37,440
gonna be very smart take all these

01:01:35,880 --> 01:01:40,200
pieces of code and try to inline

01:01:37,440 --> 01:01:41,430
yourself and try at some point you start

01:01:40,200 --> 01:01:42,750
getting functions that are bigger and

01:01:41,430 --> 01:01:44,400
bigger and you think that right the

01:01:42,750 --> 01:01:46,890
compiler should be able to do a great

01:01:44,400 --> 01:01:48,750
job at which point this is to counter

01:01:46,890 --> 01:01:50,550
producing and the compiler will stop

01:01:48,750 --> 01:01:51,140
giving on optimizations according to

01:01:50,550 --> 01:01:57,210
your experience

01:01:51,140 --> 01:02:00,540
I mean I don't I don't typically

01:01:57,210 --> 01:02:02,280
advocate doing like in none of what I

01:02:00,540 --> 01:02:03,930
wrote here did i really suggest like you

01:02:02,280 --> 01:02:05,280
should just assume you know better than

01:02:03,930 --> 01:02:07,260
the compiler from the get-go

01:02:05,280 --> 01:02:10,620
like i don't use force in line very

01:02:07,260 --> 01:02:12,510
often you should probably very rarely

01:02:10,620 --> 01:02:13,710
use it without measuring unless like

01:02:12,510 --> 01:02:16,920
again you have some kind of knowledge

01:02:13,710 --> 01:02:18,510
about prioritization I would say in

01:02:16,920 --> 01:02:20,400
general like write the code in a way

01:02:18,510 --> 01:02:22,320
that the compiler has the option to

01:02:20,400 --> 01:02:25,770
inline which in many of these cases like

01:02:22,320 --> 01:02:27,480
it it doesn't or it barely does but let

01:02:25,770 --> 01:02:30,570
the compiler make most of the in line

01:02:27,480 --> 01:02:33,300
decisions on its own I've personally

01:02:30,570 --> 01:02:36,030
only seen two examples where people in

01:02:33,300 --> 01:02:38,190
lined or otherwise bloated code so much

01:02:36,030 --> 01:02:40,350
that it hurt performance and both

01:02:38,190 --> 01:02:42,120
examples were very extreme one person

01:02:40,350 --> 01:02:44,610
was just going crazy with templates and

01:02:42,120 --> 01:02:47,490
the second was doing literal code gem

01:02:44,610 --> 01:02:49,320
like printing C++ code that then got

01:02:47,490 --> 01:02:52,560
recompiled like they were unrolling

01:02:49,320 --> 01:02:54,240
loops with like a thousand elements so

01:02:52,560 --> 01:02:56,040
that's my experience a lot of other

01:02:54,240 --> 01:02:58,560
people will say yeah like code bloat

01:02:56,040 --> 01:03:00,450
hurts performance all the time I mean I

01:02:58,560 --> 01:03:03,090
think it's kind of unlikely but I also

01:03:00,450 --> 01:03:05,150
don't recommend just sprinkling force in

01:03:03,090 --> 01:03:07,710
line like that's that's not a good idea

01:03:05,150 --> 01:03:08,849
yeah but in general do you think

01:03:07,710 --> 01:03:14,339
functions that are really

01:03:08,849 --> 01:03:15,809
long tend to be no not demise about what

01:03:14,339 --> 01:03:18,210
do you mean by non optimizable well in

01:03:15,809 --> 01:03:20,099
the sense that if the compiler if you

01:03:18,210 --> 01:03:22,349
buy a function you try to boil in life's

01:03:20,099 --> 01:03:25,859
everywhere function that is many lines

01:03:22,349 --> 01:03:27,599
say no for 500 lines of a single

01:03:25,859 --> 01:03:30,509
function what the compiler give open

01:03:27,599 --> 01:03:33,960
optimizing I mean I don't know I'd say

01:03:30,509 --> 01:03:35,549
see the specific case I mean when you

01:03:33,960 --> 01:03:39,119
have a 4 or 500 line function I mean

01:03:35,549 --> 01:03:40,319
there's already a lot of basic block in

01:03:39,119 --> 01:03:42,749
there there's already a lot of scope for

01:03:40,319 --> 01:03:45,450
optimization so you know the benefits

01:03:42,749 --> 01:03:47,460
tend to be less I mean that's you know

01:03:45,450 --> 01:03:49,559
it's it's generally better to inline

01:03:47,460 --> 01:03:52,680
smaller functions and bigger ones but

01:03:49,559 --> 01:03:53,880
you know you it's it's it's really hard

01:03:52,680 --> 01:03:55,589
for me to answer your question in

01:03:53,880 --> 01:03:56,999
generality I think at that point it all

01:03:55,589 --> 01:03:58,170
depends on its but that's that's the

01:03:56,999 --> 01:04:00,150
point where I would say you just have to

01:03:58,170 --> 01:04:02,269
measure I mean it's hard to answer that

01:04:00,150 --> 01:04:02,269

YouTube URL: https://www.youtube.com/watch?v=8nyq8SNUTSc


