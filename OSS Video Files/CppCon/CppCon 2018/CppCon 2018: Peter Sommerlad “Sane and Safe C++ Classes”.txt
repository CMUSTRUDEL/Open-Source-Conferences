Title: CppCon 2018: Peter Sommerlad “Sane and Safe C++ Classes”
Publication date: 2018-10-12
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
C++ is a complex language and with the introduction of move semantics, noexcept and constexpr in C++11 and later, defining or declaring the right combination of magic keywords in the right place is daunting for the uninitiated. The talk will provide guidelines for how to circumvent expert territory and if needed, how to step there without shooting yourself in the foot or tripping a mine. 

Many C++ guidelines try to limit the use of language features so that resulting code has higher chances to be correct and safe. This talk will give an overview of the kind of classes you can create in such a controlled setting and provides a map to where is expert territory that requires deliberate care about your classes. 

For example, there is the Rule of Zero telling that you should let the compiler figure out what to provide. It carries far for the application level programmer, but still might not be sufficient. Should you then rely on the Rule of Five or Six? What would be the consequences? When should you actually deviate from the Rule of Zero and how? 

Another area are classes representing values. Value classes better not have virtual member functions. But should you use final or not? Do you really need class hierarchies? 

You will learn what kinds of classes are safe to design and how to spell their special member functions.
— 
Peter Sommerlad, HSR Rapperswil
Professor

Prof. Peter Sommerlad is director of IFS Institute for Software at FHO HSR Rapperswil where he inspired the C++ IDE Cevelop. Peter is co-author of the books POSA Vol.1 and Security Patterns. His goal is to make software simpler by Decremental Development: Refactoring software down to 10% its size with better architecture, testability and quality and functionality. Peter is a member of the C++ standardization committee, ACCU, ACM, IEEE Computer Society.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,089 --> 00:00:09,450
good morning I'm Peter and I'm here to

00:00:05,460 --> 00:00:12,780
talk about sane and safe C++ class types

00:00:09,450 --> 00:00:17,070
or types and when I refer to sanity I'm

00:00:12,780 --> 00:00:19,590
not referring to mental health issues I

00:00:17,070 --> 00:00:21,689
know people have that so please don't be

00:00:19,590 --> 00:00:31,500
offended if I talk about sanity it's not

00:00:21,689 --> 00:00:33,360
about you it's about C++ types so to

00:00:31,500 --> 00:00:36,000
figure out how to actually categorize

00:00:33,360 --> 00:00:38,430
types I made a little map and that's a

00:00:36,000 --> 00:00:40,980
typical quadrant thing so you have

00:00:38,430 --> 00:00:42,989
things that are sane and other things

00:00:40,980 --> 00:00:44,850
that are safe to use and if it's sane

00:00:42,989 --> 00:00:47,120
and safe it's easy to use

00:00:44,850 --> 00:00:50,460
that's a quadrant you want to be in and

00:00:47,120 --> 00:00:54,329
there are other things that everything

00:00:50,460 --> 00:00:57,870
on the left part is things that require

00:00:54,329 --> 00:00:59,100
high discipline may be hard heads to go

00:00:57,870 --> 00:01:02,399
there and sometimes it's really

00:00:59,100 --> 00:01:04,530
dangerous and we have that thing called

00:01:02,399 --> 00:01:08,040
undefined behavior and that's where you

00:01:04,530 --> 00:01:09,619
know know don't want to be yet and there

00:01:08,040 --> 00:01:13,170
are some things that are not that

00:01:09,619 --> 00:01:15,869
dangerous but still ill-advised so they

00:01:13,170 --> 00:01:19,350
might poison your codebase because you

00:01:15,869 --> 00:01:21,509
will have things that seem to be a nice

00:01:19,350 --> 00:01:25,310
idea and everybody is using that in your

00:01:21,509 --> 00:01:28,080
code base but it makes your code ugly

00:01:25,310 --> 00:01:30,210
and I'm not sure if I can give you more

00:01:28,080 --> 00:01:31,950
exam exam of the poison but you might

00:01:30,210 --> 00:01:37,500
have seen that I'm at home or somewhere

00:01:31,950 --> 00:01:39,600
else in the code bases you have first

00:01:37,500 --> 00:01:42,090
I'd like to talk about values because

00:01:39,600 --> 00:01:45,479
values actually belong and that green

00:01:42,090 --> 00:01:47,790
part usually values are really easy to

00:01:45,479 --> 00:01:51,950
use they are safe they get copied you

00:01:47,790 --> 00:01:54,390
don't have to care about changing things

00:01:51,950 --> 00:01:57,840
unintentionally because a value is just

00:01:54,390 --> 00:02:01,130
a value and our friend Scott Meyer says

00:01:57,840 --> 00:02:06,149
okay when in doubt do as the in store

00:02:01,130 --> 00:02:10,259
int might be the type that is can give

00:02:06,149 --> 00:02:12,530
the category of value types but not

00:02:10,259 --> 00:02:12,530
always

00:02:12,690 --> 00:02:18,030
stay tuned so value types in the

00:02:16,320 --> 00:02:19,590
standard and in the concept of the

00:02:18,030 --> 00:02:23,940
sentence we have the concept of a

00:02:19,590 --> 00:02:26,670
regular type and see plasters containers

00:02:23,940 --> 00:02:30,750
assume that you put more or less regular

00:02:26,670 --> 00:02:32,220
types in as template arguments for the

00:02:30,750 --> 00:02:34,260
elements that you put in the container

00:02:32,220 --> 00:02:36,360
and then everything works fine and

00:02:34,260 --> 00:02:39,420
smoothly and if you put very interesting

00:02:36,360 --> 00:02:42,180
types in your containers they might work

00:02:39,420 --> 00:02:44,720
partially or not at all and you might

00:02:42,180 --> 00:02:47,360
end up in undefined behavior land

00:02:44,720 --> 00:02:50,790
Stepanov originally actually said that

00:02:47,360 --> 00:02:55,620
templates that regular types includes

00:02:50,790 --> 00:02:57,780
ordering so that standard less works and

00:02:55,620 --> 00:03:04,710
that's important for the associative

00:02:57,780 --> 00:03:08,700
containers that sort the elements in c

00:03:04,710 --> 00:03:10,920
plus 20 it's not only less than operator

00:03:08,700 --> 00:03:12,960
that makes defines the ordering but the

00:03:10,920 --> 00:03:15,960
spaceship operator so stay tuned for

00:03:12,960 --> 00:03:19,020
that I still haven't used a compiler

00:03:15,960 --> 00:03:21,209
implement supporting it or at least I

00:03:19,020 --> 00:03:25,230
haven't tried it but that's the future

00:03:21,209 --> 00:03:29,100
to define sorting so what goes into

00:03:25,230 --> 00:03:29,610
regular you can compare elements for

00:03:29,100 --> 00:03:31,740
equality

00:03:29,610 --> 00:03:36,900
you can default construct them if you

00:03:31,740 --> 00:03:39,390
copy them the Equality should be given

00:03:36,900 --> 00:03:42,270
so if you copy if you assign B from a

00:03:39,390 --> 00:03:45,140
then a and B should be equal they should

00:03:42,270 --> 00:03:47,970
be movable and move assignable swappable

00:03:45,140 --> 00:03:50,670
better without throwing exceptions and

00:03:47,970 --> 00:03:55,280
all the things that you would expect

00:03:50,670 --> 00:03:59,310
from them now if you fill out with

00:03:55,280 --> 00:04:02,040
categories of types that I would like to

00:03:59,310 --> 00:04:06,570
explain to you we have things value

00:04:02,040 --> 00:04:08,010
types upper right corner empty types if

00:04:06,570 --> 00:04:09,840
you don't have data you can have rate

00:04:08,010 --> 00:04:13,980
can't have raises so nothing can go

00:04:09,840 --> 00:04:17,400
wrong and that's the corner where

00:04:13,980 --> 00:04:19,680
everything is sane and safe but there

00:04:17,400 --> 00:04:22,169
are other types like or polymorphic

00:04:19,680 --> 00:04:25,500
types and then they are on the hard-hit

00:04:22,169 --> 00:04:26,610
side of the quadrants you have to take

00:04:25,500 --> 00:04:29,039
make sure

00:04:26,610 --> 00:04:31,139
that you're not doing insane things for

00:04:29,039 --> 00:04:33,740
them and there are other things like

00:04:31,139 --> 00:04:38,370
pointing types which includes references

00:04:33,740 --> 00:04:40,319
string view span which I also require

00:04:38,370 --> 00:04:44,759
very high discipline they can be quite

00:04:40,319 --> 00:04:47,520
saintly used but only if you apply that

00:04:44,759 --> 00:04:50,310
high discipline and not doing insane

00:04:47,520 --> 00:04:53,969
things with them and a category that's

00:04:50,310 --> 00:04:58,500
often not obvious is what I call

00:04:53,969 --> 00:05:02,099
managing types types that manage the

00:04:58,500 --> 00:05:05,580
lifetime of other objects a canonical

00:05:02,099 --> 00:05:07,800
example is vector vector manages a

00:05:05,580 --> 00:05:10,919
lifetime and the memory occupation of

00:05:07,800 --> 00:05:14,370
its elements and the vector when the

00:05:10,919 --> 00:05:18,479
vector goes away the elements disappear

00:05:14,370 --> 00:05:21,750
but also you can retrieve a reference or

00:05:18,479 --> 00:05:23,699
a pointer or an iterator to a single

00:05:21,750 --> 00:05:29,550
element and work on that single element

00:05:23,699 --> 00:05:34,229
managed by the vector and then there's

00:05:29,550 --> 00:05:38,009
the area of insane or ill-advised and

00:05:34,229 --> 00:05:41,909
dangerous things like plane pointers in

00:05:38,009 --> 00:05:44,550
my opinion plane pointers have no real

00:05:41,909 --> 00:05:48,120
use in user level code in the standard

00:05:44,550 --> 00:05:50,759
library in the user code in the in C++

00:05:48,120 --> 00:05:52,800
or in the standard library we have a

00:05:50,759 --> 00:05:56,699
unique pointer that actually makes the

00:05:52,800 --> 00:05:58,529
manage memory management more sane but

00:05:56,699 --> 00:06:03,210
still they might be now so that's

00:05:58,529 --> 00:06:06,270
dangerous if you apply the B reference

00:06:03,210 --> 00:06:08,520
operate on them but plane pointers even

00:06:06,270 --> 00:06:11,159
though people say okay we should use

00:06:08,520 --> 00:06:14,669
plane pointers to denote single objects

00:06:11,159 --> 00:06:16,729
the problem is they still allow all the

00:06:14,669 --> 00:06:19,589
dangerous operations on them like

00:06:16,729 --> 00:06:22,139
indexing and that's not what you want to

00:06:19,589 --> 00:06:24,839
do and then I've seen code where you

00:06:22,139 --> 00:06:29,240
have very interesting combinations of

00:06:24,839 --> 00:06:32,729
special member functions don't do that

00:06:29,240 --> 00:06:35,250
rely on the rule of zero or if you

00:06:32,729 --> 00:06:38,490
actually do something interesting then

00:06:35,250 --> 00:06:39,870
you end up at least in the hard hat high

00:06:38,490 --> 00:06:42,300
discipline air

00:06:39,870 --> 00:06:44,390
of polymorphic types or managing types

00:06:42,300 --> 00:06:47,570
we actually have to deal about

00:06:44,390 --> 00:06:50,340
destruction and so on

00:06:47,570 --> 00:06:52,530
the only reason to write these minute

00:06:50,340 --> 00:06:55,620
combination of special members is for

00:06:52,530 --> 00:06:58,380
testing templates and I gave some

00:06:55,620 --> 00:07:00,990
examples yesterday but the question is

00:06:58,380 --> 00:07:04,680
where are the built-in types they are

00:07:00,990 --> 00:07:11,760
not class types any idea would it be

00:07:04,680 --> 00:07:17,630
that quadrant same but dangerous anyone

00:07:11,760 --> 00:07:17,630
their value types sane and safe oh

00:07:18,110 --> 00:07:27,290
you're so wrong they are actually in

00:07:24,390 --> 00:07:34,740
that other area I'll give you an example

00:07:27,290 --> 00:07:40,380
rule simple there are regular types in

00:07:34,740 --> 00:07:46,650
char bool double but just see what is

00:07:40,380 --> 00:07:49,350
the result of that the answer assignment

00:07:46,650 --> 00:07:56,570
or initialization what should go in

00:07:49,350 --> 00:08:04,080
there it's a quiz who knows the answer

00:07:56,570 --> 00:08:08,750
is it it's either yes or no is it easy

00:08:04,080 --> 00:08:12,440
to spot have you seen code like that

00:08:08,750 --> 00:08:12,440
make the same box

00:08:17,229 --> 00:08:38,849
any volunteers come on it's a boolean

00:08:25,240 --> 00:08:52,199
decision yes or no so you say it's no

00:08:38,849 --> 00:08:52,199
okay 41 modulo 3 is 2 2 bit and 42

00:09:00,530 --> 00:09:10,610
homework now now the interesting feature

00:09:06,030 --> 00:09:10,610
doubles are double safe to use and sane

00:09:11,780 --> 00:09:18,870
someone is as the opinion no what is the

00:09:16,440 --> 00:09:23,220
size of that piece of code of that

00:09:18,870 --> 00:09:25,950
vector of the set sorry you just have a

00:09:23,220 --> 00:09:28,260
vector of a couple of values double

00:09:25,950 --> 00:09:32,480
values class simply the argument

00:09:28,260 --> 00:09:39,210
deduction in c-plus was 17 and we insert

00:09:32,480 --> 00:09:41,460
division of each pair of elements in

00:09:39,210 --> 00:09:47,420
that vector so the vector has four

00:09:41,460 --> 00:09:50,790
elements so we have four by four sixteen

00:09:47,420 --> 00:09:57,900
potential quotients in the vector in the

00:09:50,790 --> 00:10:04,790
set - the ones that you get when D

00:09:57,900 --> 00:10:17,910
divided by itself what is the size here

00:10:04,790 --> 00:10:21,530
of that set is it hmm divided by zero if

00:10:17,910 --> 00:10:26,130
I divide one by zero what do I get

00:10:21,530 --> 00:10:30,450
infinity not too bad the problem is what

00:10:26,130 --> 00:10:35,280
if I divide 0 by 0 in floating point its

00:10:30,450 --> 00:10:37,830
well-defined not a number I get not a

00:10:35,280 --> 00:10:43,040
number what happens if I insert not a

00:10:37,830 --> 00:10:46,200
number into that set bad things yes

00:10:43,040 --> 00:10:48,780
because not a number doesn't compare

00:10:46,200 --> 00:10:52,440
less with any other number not even with

00:10:48,780 --> 00:10:56,990
itself and the equivalents in the set is

00:10:52,440 --> 00:11:00,360
defined by not being less in both ways

00:10:56,990 --> 00:11:02,520
so not a number is not less than itself

00:11:00,360 --> 00:11:04,350
and not less than any other number and

00:11:02,520 --> 00:11:06,180
not in any other number is not less than

00:11:04,350 --> 00:11:10,050
other numbers or any other number is

00:11:06,180 --> 00:11:13,010
equivalent with not a number so that set

00:11:10,050 --> 00:11:14,750
has a size of exactly 1 because

00:11:13,010 --> 00:11:17,150
the first element you insert into it is

00:11:14,750 --> 00:11:19,460
not a number and no other element can be

00:11:17,150 --> 00:11:23,720
insert because they are all considered

00:11:19,460 --> 00:11:25,880
equivalent with not a number very

00:11:23,720 --> 00:11:28,780
interesting behavior often forgotten

00:11:25,880 --> 00:11:34,010
when you put interesting types into

00:11:28,780 --> 00:11:35,330
associative containers and the spaceship

00:11:34,010 --> 00:11:37,700
operator doesn't help with that because

00:11:35,330 --> 00:11:40,460
it's wrong it has the same behavior with

00:11:37,700 --> 00:11:46,250
not a number some actually doubles are

00:11:40,460 --> 00:11:48,290
not strictly ordered another thing

00:11:46,250 --> 00:11:50,510
that's a typical common mistake and

00:11:48,290 --> 00:11:54,080
that's why people want to have span

00:11:50,510 --> 00:11:58,040
which size returning an integer which I

00:11:54,080 --> 00:12:03,520
consider a bad idea and I'm open to

00:11:58,040 --> 00:12:03,520
other opinions what happens in that case

00:12:03,760 --> 00:12:08,660
say it again you get an infinite loop

00:12:07,640 --> 00:12:15,320
why

00:12:08,660 --> 00:12:19,340
well size returns an unsigned integer if

00:12:15,320 --> 00:12:22,160
you subtract minus 1 it still remains an

00:12:19,340 --> 00:12:26,270
unsigned integer if that vector has

00:12:22,160 --> 00:12:36,620
happens to have size 0 because it's

00:12:26,270 --> 00:12:41,480
empty it will not work and

00:12:36,620 --> 00:12:45,740
I becomes an unsigned integer so for an

00:12:41,480 --> 00:12:47,870
unsigned integer it's never less than

00:12:45,740 --> 00:12:50,540
zero because that's how unsigned is

00:12:47,870 --> 00:12:52,610
defined so we haven't a compiler will

00:12:50,540 --> 00:13:00,860
put that in true and we have an endless

00:12:52,610 --> 00:13:03,200
loop regardless interesting behavior so

00:13:00,860 --> 00:13:06,560
some problems with primitive types that

00:13:03,200 --> 00:13:12,020
put them into the hardhat very dangerous

00:13:06,560 --> 00:13:14,600
quadrant integral promotion who can

00:13:12,020 --> 00:13:17,900
claim to know all the tricky rules of

00:13:14,600 --> 00:13:23,020
integral promotion by heart and follows

00:13:17,900 --> 00:13:27,800
them every line of code they ride I

00:13:23,020 --> 00:13:31,120
don't see any hands me neither

00:13:27,800 --> 00:13:34,040
because it's really intricate and

00:13:31,120 --> 00:13:35,690
sometimes you get interesting warnings

00:13:34,040 --> 00:13:38,120
by the compiler and we learned yesterday

00:13:35,690 --> 00:13:41,000
or you should better listen to your

00:13:38,120 --> 00:13:43,910
compiler but very often what happens Oh

00:13:41,000 --> 00:13:46,940
signed unsigned mixtures in comparison

00:13:43,910 --> 00:13:50,180
or arithmetic I know that it's okay I

00:13:46,940 --> 00:13:53,360
just discard it with the cost so I don't

00:13:50,180 --> 00:13:57,380
get that warning sometimes we have the

00:13:53,360 --> 00:14:00,890
silenced changes of values like the

00:13:57,380 --> 00:14:04,700
wrapping of unsigned or undefined

00:14:00,890 --> 00:14:07,760
behavior on signed overflow and we know

00:14:04,700 --> 00:14:10,490
undefined behavior is not the place you

00:14:07,760 --> 00:14:15,740
want to be because all your code is

00:14:10,490 --> 00:14:18,350
invalidated by that sometimes I would

00:14:15,740 --> 00:14:20,330
love to have the carry bit and who

00:14:18,350 --> 00:14:22,460
doesn't know what a carry bit is you're

00:14:20,330 --> 00:14:25,640
not old enough to appreciate the carry

00:14:22,460 --> 00:14:29,750
bit or haven't done assembly language

00:14:25,640 --> 00:14:31,640
you know so we don't have that in C++ so

00:14:29,750 --> 00:14:34,910
the abstract machine does it allow us to

00:14:31,640 --> 00:14:38,900
detect overflow and assign numbers or

00:14:34,910 --> 00:14:41,540
not even on some unsigned we have the

00:14:38,900 --> 00:14:43,640
automatic numeric conversions that

00:14:41,540 --> 00:14:44,990
certainly take a promotion so a bool can

00:14:43,640 --> 00:14:45,590
be interpreted as a floating-point

00:14:44,990 --> 00:14:49,400
number

00:14:45,590 --> 00:14:53,000
easily and vice-versa which is sometimes

00:14:49,400 --> 00:14:55,420
nice but can be very surprising if you

00:14:53,000 --> 00:14:58,550
make mistakes with operator precedence

00:14:55,420 --> 00:15:00,410
which is also a nasty thing with these

00:14:58,550 --> 00:15:02,900
many levels of rules of operator

00:15:00,410 --> 00:15:04,610
precedence and the special values for

00:15:02,900 --> 00:15:09,920
floating-point numbers that we already

00:15:04,610 --> 00:15:13,850
had talked about even the standard

00:15:09,920 --> 00:15:16,190
library implementations suffer from that

00:15:13,850 --> 00:15:18,290
and there are other problems what if I

00:15:16,190 --> 00:15:21,110
have a function with three ins as a

00:15:18,290 --> 00:15:24,290
parameter type how do I know what the

00:15:21,110 --> 00:15:26,300
meaning of these three ins are is it

00:15:24,290 --> 00:15:28,190
flux made three to one the right order

00:15:26,300 --> 00:15:31,880
to call it or is it the other way around

00:15:28,190 --> 00:15:33,500
and which is which and there are some

00:15:31,880 --> 00:15:38,709
approaches where people say oh we want

00:15:33,500 --> 00:15:38,709
named arguments on calling the functions

00:15:38,740 --> 00:15:43,040
not a good idea

00:15:40,670 --> 00:15:45,350
I believe that's just curing a symptom

00:15:43,040 --> 00:15:47,750
and not solving it in the right way

00:15:45,350 --> 00:15:52,040
because you still have three arguments

00:15:47,750 --> 00:15:54,290
that the primitive types there and the

00:15:52,040 --> 00:15:56,750
good thing in C++ is we can actually

00:15:54,290 --> 00:16:01,149
wrap those primitive types into you in

00:15:56,750 --> 00:16:05,120
our own domain specific types without

00:16:01,149 --> 00:16:09,769
overhead except for some ancient

00:16:05,120 --> 00:16:12,350
compilers the next thing is if i mix

00:16:09,769 --> 00:16:14,600
signed and unsigned arithmetic in the

00:16:12,350 --> 00:16:17,779
standard library we have size T and size

00:16:14,600 --> 00:16:21,560
types of containers and therefore

00:16:17,779 --> 00:16:26,120
counting elements counting is based on

00:16:21,560 --> 00:16:28,069
natural numbers including zero so if I

00:16:26,120 --> 00:16:30,860
count things I should stay in that

00:16:28,069 --> 00:16:34,759
domain but if I subtract at subtraction

00:16:30,860 --> 00:16:37,579
to the operator domain of natural

00:16:34,759 --> 00:16:42,380
numbers I go into the domain of of whole

00:16:37,579 --> 00:16:46,790
numbers so if I subtract natural numbers

00:16:42,380 --> 00:16:51,860
I might go out of their domain into the

00:16:46,790 --> 00:16:54,980
domain of integers and we suffer from

00:16:51,860 --> 00:16:57,019
that in the sender library that if we

00:16:54,980 --> 00:16:59,689
have two natural numbers represented as

00:16:57,019 --> 00:17:04,220
unsigned numbers like size T and we

00:16:59,689 --> 00:17:12,260
subtract them we still remain in the

00:17:04,220 --> 00:17:15,500
domain of unsigned and not signed the

00:17:12,260 --> 00:17:17,569
reason is well they don't match because

00:17:15,500 --> 00:17:20,480
we have limited a number of bits for

00:17:17,569 --> 00:17:23,449
representation but also it's very

00:17:20,480 --> 00:17:26,750
interesting things happen for example if

00:17:23,449 --> 00:17:27,809
you see that code this distance return

00:17:26,750 --> 00:17:29,639
type of distance

00:17:27,809 --> 00:17:34,980
difference type with a signed integer

00:17:29,639 --> 00:17:39,360
type it's silently Casas to an unsigned

00:17:34,980 --> 00:17:42,059
in that n and then there's a subtraction

00:17:39,360 --> 00:17:44,879
of two unsigned values capacity and

00:17:42,059 --> 00:17:48,029
signed and that is compared with that n

00:17:44,879 --> 00:17:52,850
and this is regular C plus with just

00:17:48,029 --> 00:17:57,600
interesting code with a font with

00:17:52,850 --> 00:18:01,980
ligatures firfer Grady equal so to

00:17:57,600 --> 00:18:04,679
silence me if I would have write written

00:18:01,980 --> 00:18:07,139
otto here this would give us a compiler

00:18:04,679 --> 00:18:10,049
warning or you're comparing assigned and

00:18:07,139 --> 00:18:11,610
an unsigned number but the problem is

00:18:10,049 --> 00:18:13,710
not the comparison the problem is that

00:18:11,610 --> 00:18:16,110
this subtraction actually creates a

00:18:13,710 --> 00:18:17,759
still an unsigned number where the

00:18:16,110 --> 00:18:19,499
domain of subtracting two of two

00:18:17,759 --> 00:18:23,610
national numbers goes into the integers

00:18:19,499 --> 00:18:27,830
and later on we have a additional class

00:18:23,610 --> 00:18:30,419
because actually that end there is

00:18:27,830 --> 00:18:32,429
considered a signed number because it's

00:18:30,419 --> 00:18:36,029
used in all different places where the

00:18:32,429 --> 00:18:40,740
signed type is required it's only to

00:18:36,029 --> 00:18:44,539
silence this comparison that is defined

00:18:40,740 --> 00:18:47,639
as a size type and it's cast back again

00:18:44,539 --> 00:18:52,559
casts are an indication of a problem in

00:18:47,639 --> 00:18:54,809
your type application and at least we

00:18:52,559 --> 00:18:58,919
could have done a single cast instead of

00:18:54,809 --> 00:19:02,899
two so one place where you bend the

00:18:58,919 --> 00:19:02,899
compiler there are three places there

00:19:05,149 --> 00:19:11,059
what can we do about that well we

00:19:08,960 --> 00:19:13,820
learned about code that is old enough to

00:19:11,059 --> 00:19:16,960
vote here we got design patterns that

00:19:13,820 --> 00:19:21,259
are old enough to drink legally in most

00:19:16,960 --> 00:19:23,419
countries of the world there's a pattern

00:19:21,259 --> 00:19:25,159
called the whole value pattern the whole

00:19:23,419 --> 00:19:27,200
value pattern is what we know about

00:19:25,159 --> 00:19:30,080
strong typing and so on

00:19:27,200 --> 00:19:32,149
and where does it come from or what's

00:19:30,080 --> 00:19:33,979
the example I go of that we had another

00:19:32,149 --> 00:19:37,009
example buy on or lipstick yesterday

00:19:33,979 --> 00:19:39,019
lévesque yesterday on how to do that I

00:19:37,009 --> 00:19:40,969
did that already that's the whole value

00:19:39,019 --> 00:19:43,789
pattern it's from the checks pattern

00:19:40,969 --> 00:19:46,759
language of Ward Cunningham what

00:19:43,789 --> 00:19:49,339
Cunningham is the inventor of the wiki

00:19:46,759 --> 00:19:53,960
wiki Beth not Wikipedia the wikiwikiweb

00:19:49,339 --> 00:19:55,639
the original one by the way and I that's

00:19:53,960 --> 00:19:57,440
one of the slides I want to read out

00:19:55,639 --> 00:19:59,479
when parameterizing or otherwise

00:19:57,440 --> 00:20:01,369
quantifying a business domain model

00:19:59,479 --> 00:20:03,979
there remains an overwhelming desire to

00:20:01,369 --> 00:20:06,769
express these parameters in the most

00:20:03,979 --> 00:20:08,599
fundamental units of computation not

00:20:06,769 --> 00:20:13,849
only is this no longer necessary

00:20:08,599 --> 00:20:16,339
remember this was 1995 it was standard

00:20:13,849 --> 00:20:18,729
practice in languages with weak or no

00:20:16,339 --> 00:20:20,989
abstraction my Edition like C it

00:20:18,729 --> 00:20:22,580
actually interferes the smooth and

00:20:20,989 --> 00:20:25,909
proper communication between parts of

00:20:22,580 --> 00:20:29,119
your program and with its users because

00:20:25,909 --> 00:20:32,269
bits strings numbers can be used to

00:20:29,119 --> 00:20:36,849
represent almost anything anyone in

00:20:32,269 --> 00:20:39,769
isolation means almost nothing therefore

00:20:36,849 --> 00:20:41,479
construct specialized values to quantify

00:20:39,769 --> 00:20:43,759
your domain model and use these values

00:20:41,479 --> 00:20:46,519
as arguments of the messages which is

00:20:43,759 --> 00:20:49,279
functions in c++ terminology and as a

00:20:46,519 --> 00:20:53,210
unit of input and output that's what

00:20:49,279 --> 00:20:54,979
value types are 4 strong types make sure

00:20:53,210 --> 00:20:57,799
these objects capture the whole quantity

00:20:54,979 --> 00:21:00,049
with all its implications beyond merely

00:20:57,799 --> 00:21:02,479
magnitude but keep them independent of

00:21:00,049 --> 00:21:04,580
any a particular domain so we add

00:21:02,479 --> 00:21:07,969
functions and operators to operate on

00:21:04,580 --> 00:21:10,399
them include format converters in your

00:21:07,969 --> 00:21:12,589
user interface that can only correctly

00:21:10,399 --> 00:21:14,589
and reliably construct these objects on

00:21:12,589 --> 00:21:18,289
input and print them on output

00:21:14,589 --> 00:21:18,820
constructors io operations do not expect

00:21:18,289 --> 00:21:20,470
you to make

00:21:18,820 --> 00:21:21,970
model to handle string on America

00:21:20,470 --> 00:21:25,570
representations of the same information

00:21:21,970 --> 00:21:30,159
so no mixing up of ins and the strong

00:21:25,570 --> 00:21:32,620
thing no implicit conversions always be

00:21:30,159 --> 00:21:35,190
explicit when you interpret a value in a

00:21:32,620 --> 00:21:35,190
different domain

00:21:36,029 --> 00:21:39,759
think about that

00:21:37,690 --> 00:21:41,049
take it home this is the most important

00:21:39,759 --> 00:21:47,590
slide for you to take home if you

00:21:41,049 --> 00:21:49,899
haven't heard about that now if I do my

00:21:47,590 --> 00:21:52,240
strong types and read everything in the

00:21:49,899 --> 00:21:54,399
nice value type classes should I make

00:21:52,240 --> 00:21:56,830
these value types default constructible

00:21:54,399 --> 00:21:59,379
by defaulting the default constructor

00:21:56,830 --> 00:22:04,059
for example or not defining it a

00:21:59,379 --> 00:22:06,159
constructor at all and my take is yes if

00:22:04,059 --> 00:22:08,980
you have a natural default or neutral

00:22:06,159 --> 00:22:12,129
value in your types domain for integers

00:22:08,980 --> 00:22:16,029
zero is somehow the natural default

00:22:12,129 --> 00:22:18,279
value which is okayish but it depends on

00:22:16,029 --> 00:22:21,730
what is a major operation if you use

00:22:18,279 --> 00:22:24,039
numbers for multiplication only zero

00:22:21,730 --> 00:22:26,169
might not be a very good default because

00:22:24,039 --> 00:22:28,029
then everything multiplies as zero if

00:22:26,169 --> 00:22:33,340
you put that default value into the

00:22:28,029 --> 00:22:35,950
operation so be aware of that sometimes

00:22:33,340 --> 00:22:37,750
you've won the default value when it's

00:22:35,950 --> 00:22:40,389
very hard to figure out what the initial

00:22:37,750 --> 00:22:43,899
value should be but there are tricks

00:22:40,389 --> 00:22:46,179
like using ternary operators or lambdas

00:22:43,899 --> 00:22:47,710
in place if you have complex logic to to

00:22:46,179 --> 00:22:51,730
define what the initial value should be

00:22:47,710 --> 00:22:54,340
that give you a good initialization

00:22:51,730 --> 00:22:56,860
strategy without having the thing oh I I

00:22:54,340 --> 00:22:58,899
define a variable and then I initialize

00:22:56,860 --> 00:23:02,110
this by by assignment in a complex logic

00:22:58,899 --> 00:23:05,769
way which is easy to get wrong or I mean

00:23:02,110 --> 00:23:08,440
keep the value uninitialized don't

00:23:05,769 --> 00:23:11,110
define a default constructor or provide

00:23:08,440 --> 00:23:12,700
one or get one automatically when you

00:23:11,110 --> 00:23:15,220
have a domain where is no natural

00:23:12,700 --> 00:23:17,710
default value example poker cards

00:23:15,220 --> 00:23:22,299
playing cards what does default playing

00:23:17,710 --> 00:23:23,500
card all are equal but different there's

00:23:22,299 --> 00:23:25,059
no default constructor

00:23:23,500 --> 00:23:28,000
some people said okay we can't have a

00:23:25,059 --> 00:23:30,909
joker there yes but how many joke is do

00:23:28,000 --> 00:23:32,600
you having in your deck none or three or

00:23:30,909 --> 00:23:35,120
maybe four on extra

00:23:32,600 --> 00:23:37,250
but that's not the default value it's

00:23:35,120 --> 00:23:42,890
just an arbitrary special value in that

00:23:37,250 --> 00:23:46,040
domain and you shouldn't have a default

00:23:42,890 --> 00:23:48,820
constructor when you have an invariant

00:23:46,040 --> 00:23:51,710
in your class that requires reasonable

00:23:48,820 --> 00:23:54,170
initialization some of you ask yeah with

00:23:51,710 --> 00:23:56,720
what kind of types of it consider a

00:23:54,170 --> 00:23:58,850
cryptographic key you don't want to have

00:23:56,720 --> 00:24:00,290
a default constructor cryptographic key

00:23:58,850 --> 00:24:02,420
because that's the first one everybody

00:24:00,290 --> 00:24:06,590
uses and everybody uses the same key and

00:24:02,420 --> 00:24:10,640
that's the curse of many of the problems

00:24:06,590 --> 00:24:12,890
with security holds using bad keys and a

00:24:10,640 --> 00:24:19,640
cryptographic key you don't want to have

00:24:12,890 --> 00:24:21,860
a default I explained that already we

00:24:19,640 --> 00:24:24,470
have and the reason for the problem is

00:24:21,860 --> 00:24:31,000
we have a relative value of the distance

00:24:24,470 --> 00:24:34,100
between two indices or pointers and then

00:24:31,000 --> 00:24:37,100
we subtract two pointers and compared to

00:24:34,100 --> 00:24:41,020
the relative type again and just to

00:24:37,100 --> 00:24:43,970
silence that warning in comparison

00:24:41,020 --> 00:24:46,040
actually the difference between two

00:24:43,970 --> 00:24:48,830
absolute values should be a relative

00:24:46,040 --> 00:24:50,750
value and Senate Crono is the best

00:24:48,830 --> 00:24:53,330
example that we have a duration which is

00:24:50,750 --> 00:24:55,309
the relative value and the time points

00:24:53,330 --> 00:24:57,110
which are absolute and if you did

00:24:55,309 --> 00:24:59,690
subtract two times once we get a

00:24:57,110 --> 00:25:01,820
duration we added eration to report time

00:24:59,690 --> 00:25:04,160
point we get a new time point and we're

00:25:01,820 --> 00:25:07,100
adding two time points it's nonsense it

00:25:04,160 --> 00:25:09,820
doesn't compile which is good if you

00:25:07,100 --> 00:25:13,040
model your domain value values like that

00:25:09,820 --> 00:25:16,970
make sure that you consider no if it's

00:25:13,040 --> 00:25:20,570
an absolute or relative value and just

00:25:16,970 --> 00:25:23,300
using an int doesn't help you a lot some

00:25:20,570 --> 00:25:26,720
people do a lot of 3d graphics or have a

00:25:23,300 --> 00:25:28,640
Veck 3d or rec 40 and it's very nice to

00:25:26,720 --> 00:25:30,500
work with them but very often in the

00:25:28,640 --> 00:25:33,679
domain where them model and use them

00:25:30,500 --> 00:25:35,990
they don't distinguish between location

00:25:33,679 --> 00:25:38,380
or precision absolute and the

00:25:35,990 --> 00:25:42,169
displacement which is also vector and

00:25:38,380 --> 00:25:44,600
that's representation is identical but

00:25:42,169 --> 00:25:45,549
the meaning is different and it might

00:25:44,600 --> 00:25:48,519
not make

00:25:45,549 --> 00:25:50,529
to add to absolute points but it might

00:25:48,519 --> 00:25:55,119
make sense to subtract them to get the

00:25:50,529 --> 00:25:57,909
displacement between them if you model

00:25:55,119 --> 00:26:00,700
generic unit frameworks it's very hard

00:25:57,909 --> 00:26:04,360
to make that distinction correctly

00:26:00,700 --> 00:26:05,739
especially when you do the dimensional

00:26:04,360 --> 00:26:07,989
analysis you end up with the same

00:26:05,739 --> 00:26:10,809
dimension but with different meaning so

00:26:07,989 --> 00:26:15,309
that's the hard part to solve in any

00:26:10,809 --> 00:26:17,529
generic units framework but you don't

00:26:15,309 --> 00:26:20,919
have to do generic unix frameworks

00:26:17,529 --> 00:26:24,009
just wrap your types accordingly your

00:26:20,919 --> 00:26:26,470
domain so the mistake of step enough was

00:26:24,009 --> 00:26:29,529
to have size type and difference type

00:26:26,470 --> 00:26:33,999
not being a struct that have a distinct

00:26:29,529 --> 00:26:40,480
meaning from unsigned long and int for

00:26:33,999 --> 00:26:42,179
example there are more generic strong

00:26:40,480 --> 00:26:45,070
types

00:26:42,179 --> 00:26:48,700
bein followed on from pokhara yesterday

00:26:45,070 --> 00:26:51,159
I forgot to note the name I put it on

00:26:48,700 --> 00:26:53,049
the other slide unit and Muller and me

00:26:51,159 --> 00:26:55,929
I'm trying as well I try to make it

00:26:53,049 --> 00:26:58,659
simpler than the other things like no

00:26:55,929 --> 00:27:03,639
constructors just aggregates and mixing

00:26:58,659 --> 00:27:07,179
in operators with empty base class

00:27:03,639 --> 00:27:13,090
optimizations of my type stay small as

00:27:07,179 --> 00:27:14,889
the original base types and let's see

00:27:13,090 --> 00:27:17,139
how that works I don't know yet if it

00:27:14,889 --> 00:27:21,789
works in general but I think it's a nice

00:27:17,139 --> 00:27:23,879
idea to play with now empty classes I

00:27:21,789 --> 00:27:29,200
said okay they might be in the same

00:27:23,879 --> 00:27:30,580
quarter less value types there are

00:27:29,200 --> 00:27:32,919
things like you don't get something for

00:27:30,580 --> 00:27:36,789
nothing or you get something for nothing

00:27:32,919 --> 00:27:38,529
and Kevin honey and in C++ empty classes

00:27:36,789 --> 00:27:43,529
you can actually get something from

00:27:38,529 --> 00:27:46,570
nothing for nothing so they're

00:27:43,529 --> 00:27:49,710
considering safety usually empty types

00:27:46,570 --> 00:27:52,390
can't go wrong because there's no data

00:27:49,710 --> 00:27:54,789
nothing to lose

00:27:52,390 --> 00:27:56,890
and that typically works and you use

00:27:54,789 --> 00:27:59,860
them very often in combination less for

00:27:56,890 --> 00:28:02,769
example to create well better value

00:27:59,860 --> 00:28:05,980
types by mixing in curiously recurring

00:28:02,769 --> 00:28:08,980
template parameter pattern or idiom into

00:28:05,980 --> 00:28:10,919
value types or other types you get that

00:28:08,980 --> 00:28:13,990
mix and you get empty base class

00:28:10,919 --> 00:28:15,610
optimisation so you types don't grow

00:28:13,990 --> 00:28:17,350
abbott rly and sometimes they are even

00:28:15,610 --> 00:28:20,169
used for empty base cause of demise

00:28:17,350 --> 00:28:24,190
agent to make types smaller and more

00:28:20,169 --> 00:28:26,559
efficient we have a whole set of empty

00:28:24,190 --> 00:28:30,220
types that give us information about

00:28:26,559 --> 00:28:33,190
other things like types and compile time

00:28:30,220 --> 00:28:36,940
values we have tags and trades types and

00:28:33,190 --> 00:28:39,250
that's all kind of making making stuff

00:28:36,940 --> 00:28:43,600
work and figuring something out about

00:28:39,250 --> 00:28:51,070
the less safe parts to make their use

00:28:43,600 --> 00:28:53,260
safer examples are iterator tags that we

00:28:51,070 --> 00:28:55,510
use for tag dispatching just to figure

00:28:53,260 --> 00:28:59,070
out what might be a better algorithm to

00:28:55,510 --> 00:28:59,070
call if you have a higher category

00:28:59,940 --> 00:29:06,250
iterator type or we have tags that allow

00:29:03,789 --> 00:29:08,769
us overload selection as well to give a

00:29:06,250 --> 00:29:10,929
better initialization behavior of some

00:29:08,769 --> 00:29:13,480
of the constructors and there's a

00:29:10,929 --> 00:29:27,580
question can you walk to the microphone

00:29:13,480 --> 00:29:30,010
because then it's taped the question is

00:29:27,580 --> 00:29:36,639
are polymorphic types without data

00:29:30,010 --> 00:29:39,700
members empty or not that they are not

00:29:36,639 --> 00:29:44,260
empty because they have a vtable pointer

00:29:39,700 --> 00:29:46,000
and that's you don't get a lot of let's

00:29:44,260 --> 00:29:49,120
say you lose a lot of things that you

00:29:46,000 --> 00:29:52,919
get from empty types because polymorphic

00:29:49,120 --> 00:29:52,919
types are not really empty

00:29:56,340 --> 00:30:02,410
we can represent values as types which

00:30:00,190 --> 00:30:05,020
is often use in meta programming like

00:30:02,410 --> 00:30:07,090
integral constant ratio to actually mark

00:30:05,020 --> 00:30:10,660
other types with the ratio which makes

00:30:07,090 --> 00:30:14,200
some dimensional analysis easier

00:30:10,660 --> 00:30:16,990
we have sequences to actually unpack

00:30:14,200 --> 00:30:19,180
tuples which is a nice feature but

00:30:16,990 --> 00:30:22,000
tuples are often lis of an overused

00:30:19,180 --> 00:30:24,490
there only have used in generic code we

00:30:22,000 --> 00:30:26,260
actually need them but not in user level

00:30:24,490 --> 00:30:31,330
code if you have an abstraction you name

00:30:26,260 --> 00:30:33,220
it like that don't use tool for

00:30:31,330 --> 00:30:35,560
substitution failure is not an area of

00:30:33,220 --> 00:30:38,530
error application enable if it's also an

00:30:35,560 --> 00:30:45,280
empty type that gives us interesting

00:30:38,530 --> 00:30:49,240
features how does empty base class

00:30:45,280 --> 00:30:50,950
optimization work in C++ standard tells

00:30:49,240 --> 00:30:54,010
us that every type

00:30:50,950 --> 00:30:58,030
regardless occupies at least one byte

00:30:54,010 --> 00:31:02,380
and today we can say 1 byte because we

00:30:58,030 --> 00:31:04,270
have standard by now in the standard but

00:31:02,380 --> 00:31:06,310
it doesn't have to because if you don't

00:31:04,270 --> 00:31:09,220
have to any bits to represent something

00:31:06,310 --> 00:31:13,690
the compiler is allowed to leave out

00:31:09,220 --> 00:31:16,030
these bits if it can and that's very

00:31:13,690 --> 00:31:19,720
often used as a trick to make things

00:31:16,030 --> 00:31:21,880
smaller for example unique pointer with

00:31:19,720 --> 00:31:25,180
the deleter object that is a class

00:31:21,880 --> 00:31:27,280
actually tries hard to make unique

00:31:25,180 --> 00:31:29,830
pointer only the size of a regular

00:31:27,280 --> 00:31:31,750
pointer which is nice thing to have

00:31:29,830 --> 00:31:35,610
because you don't pay any overhead in

00:31:31,750 --> 00:31:40,480
space if you use a unique pointer

00:31:35,610 --> 00:31:42,550
correctly it's also good for CRT P

00:31:40,480 --> 00:31:45,730
mixing classes because they typically

00:31:42,550 --> 00:31:49,150
come only with other functionality that

00:31:45,730 --> 00:31:52,350
is and no data and if they don't occupy

00:31:49,150 --> 00:31:55,930
extra space in your object that's fine

00:31:52,350 --> 00:32:01,000
there are some tricks to play out to

00:31:55,930 --> 00:32:03,340
have it work nicely with the empty base

00:32:01,000 --> 00:32:05,290
customization that it actually works and

00:32:03,340 --> 00:32:07,960
there are quite complicated rules to do

00:32:05,290 --> 00:32:09,280
so and the thing is if you combine

00:32:07,960 --> 00:32:11,740
something that has a

00:32:09,280 --> 00:32:15,490
Datta member with something that doesn't

00:32:11,740 --> 00:32:18,280
in this base class of a third class then

00:32:15,490 --> 00:32:20,500
the third class only is as big as the

00:32:18,280 --> 00:32:25,320
one with the data member like in this

00:32:20,500 --> 00:32:28,660
code example there in c-plus was twenty

00:32:25,320 --> 00:32:31,180
the standard people or some people

00:32:28,660 --> 00:32:32,980
actually figure out wait maybe we should

00:32:31,180 --> 00:32:35,980
make it a little bit simpler to apply

00:32:32,980 --> 00:32:38,080
that and we have now an attribute no

00:32:35,980 --> 00:32:42,460
unique address that you can use for

00:32:38,080 --> 00:32:44,620
empty four members that are might be

00:32:42,460 --> 00:32:48,070
empty types and get rid of the

00:32:44,620 --> 00:32:50,980
complicated convoluted infrastructure of

00:32:48,070 --> 00:32:54,100
inheriting arbitral of arbitrary base

00:32:50,980 --> 00:33:07,960
types to have these to make use of the

00:32:54,100 --> 00:33:11,410
empty base optimization when does it not

00:33:07,960 --> 00:33:13,720
work well if your class has the first

00:33:11,410 --> 00:33:16,840
member of that is the same time as the

00:33:13,720 --> 00:33:19,210
base class type that is empty you have

00:33:16,840 --> 00:33:21,160
distinct object the base object and the

00:33:19,210 --> 00:33:23,380
member object and they have to have

00:33:21,160 --> 00:33:25,590
distinct addresses and therefore they

00:33:23,380 --> 00:33:29,230
cannot be empty

00:33:25,590 --> 00:33:32,440
must occupy space so there's a nice

00:33:29,230 --> 00:33:36,280
example here where we see that this EB

00:33:32,440 --> 00:33:38,380
Oh actually inherits from empty and has

00:33:36,280 --> 00:33:40,330
an empty member and both would actually

00:33:38,380 --> 00:33:43,750
happen to be at the same address at the

00:33:40,330 --> 00:33:46,900
start of the object and that will hinder

00:33:43,750 --> 00:33:49,810
you distinct objects have to have

00:33:46,900 --> 00:33:50,650
distinct addresses the sink object of

00:33:49,810 --> 00:33:52,480
the same type

00:33:50,650 --> 00:33:55,180
even though they are empty these two

00:33:52,480 --> 00:33:57,880
will occupy space and with some

00:33:55,180 --> 00:34:05,560
alignment we might even add extra space

00:33:57,880 --> 00:34:07,660
in the middle of the object that is the

00:34:05,560 --> 00:34:12,510
glimpse of what I'm trying to do with my

00:34:07,660 --> 00:34:17,950
simple strong types it uses aggregates

00:34:12,510 --> 00:34:22,440
public members not a big deal it's just

00:34:17,950 --> 00:34:24,360
public structured bindings to work

00:34:22,440 --> 00:34:28,220
with the mix-ins to actually work with

00:34:24,360 --> 00:34:31,290
other types of just our aggregates to

00:34:28,220 --> 00:34:33,320
access the elements so the operators

00:34:31,290 --> 00:34:36,810
work generically they are all friends so

00:34:33,320 --> 00:34:38,930
they instruct so they don't pollute the

00:34:36,810 --> 00:34:40,770
global namespace but still work with the

00:34:38,930 --> 00:34:43,650
types that I use

00:34:40,770 --> 00:34:45,720
there's an interesting very attic

00:34:43,650 --> 00:34:49,440
template to inherit from all the friends

00:34:45,720 --> 00:34:51,870
passing in the place of the derived

00:34:49,440 --> 00:34:54,870
class as a CRT P parameter and it's

00:34:51,870 --> 00:34:56,640
applied here we have our rate counter

00:34:54,870 --> 00:34:59,130
from the slides before that are being

00:34:56,640 --> 00:35:01,950
explained well enough it's an unsigned

00:34:59,130 --> 00:35:05,400
type that is strongly typed so it gets

00:35:01,950 --> 00:35:08,160
own name as a tag and it has operations

00:35:05,400 --> 00:35:10,590
on that type equality comparison

00:35:08,160 --> 00:35:14,010
increments and output and now we can use

00:35:10,590 --> 00:35:17,580
our counter perfectly in our test case

00:35:14,010 --> 00:35:19,830
without mixing counters weight counters

00:35:17,580 --> 00:35:25,140
with other counters or other integers or

00:35:19,830 --> 00:35:28,110
unsigned numbers there's another

00:35:25,140 --> 00:35:32,160
category of empty things that is halfway

00:35:28,110 --> 00:35:36,420
to be unsafe and maybe insane category

00:35:32,160 --> 00:35:38,910
it's empty adapters see pluses eleven

00:35:36,420 --> 00:35:40,770
inheriting constructors made it and a

00:35:38,910 --> 00:35:44,210
very thick templates made it very easy

00:35:40,770 --> 00:35:47,310
to write adapters to standard containers

00:35:44,210 --> 00:35:50,220
like oh I have a set I want to have that

00:35:47,310 --> 00:35:52,530
index operator for whatever reason maybe

00:35:50,220 --> 00:35:56,520
because I want to write for loops like

00:35:52,530 --> 00:35:58,440
hello and then you can actually provide

00:35:56,520 --> 00:36:00,570
these at the cost because they are not

00:35:58,440 --> 00:36:05,490
that cheaply implementable with Senate

00:36:00,570 --> 00:36:07,740
set but you might just like them so you

00:36:05,490 --> 00:36:10,260
can actually write an adapter indexable

00:36:07,740 --> 00:36:13,230
set without any data in there adding

00:36:10,260 --> 00:36:15,120
additional operations and maybe changing

00:36:13,230 --> 00:36:17,610
existing operations and if you only

00:36:15,120 --> 00:36:20,370
exclusively use that indexable set in

00:36:17,610 --> 00:36:23,250
your system you're fine

00:36:20,370 --> 00:36:25,020
you better not up cast it to this set

00:36:23,250 --> 00:36:27,930
because then you lose all the facilities

00:36:25,020 --> 00:36:30,180
and also it's very hard to down cast

00:36:27,930 --> 00:36:34,830
down casting only works with again

00:36:30,180 --> 00:36:40,230
wrapping it within indexable set and not

00:36:34,830 --> 00:36:46,860
reference note we don't have any virtual

00:36:40,230 --> 00:36:48,570
there so if you overload a base class

00:36:46,860 --> 00:36:50,220
member function it's not automatically

00:36:48,570 --> 00:36:54,240
called if you referred through base

00:36:50,220 --> 00:37:01,940
class reference which is a good thing in

00:36:54,240 --> 00:37:06,060
that case next topic empties are over

00:37:01,940 --> 00:37:09,720
pointers we have a whole set of things

00:37:06,060 --> 00:37:12,750
that point somewhere unit on mullah

00:37:09,720 --> 00:37:15,060
actually gave a target a CCU on I just

00:37:12,750 --> 00:37:16,590
want to point to something and it's

00:37:15,060 --> 00:37:18,740
really interesting what's happening

00:37:16,590 --> 00:37:22,800
there and we have types that are

00:37:18,740 --> 00:37:24,870
pointers in this guy disguise which

00:37:22,800 --> 00:37:26,760
might not be obvious at their point even

00:37:24,870 --> 00:37:29,430
the standard library provides with those

00:37:26,760 --> 00:37:32,970
types and using anything that refers to

00:37:29,430 --> 00:37:38,490
something else is requires high

00:37:32,970 --> 00:37:41,130
discipline you should have your drill

00:37:38,490 --> 00:37:42,590
instructor in the background to watch

00:37:41,130 --> 00:37:45,350
what you're doing

00:37:42,590 --> 00:37:48,810
because you don't want to shoot yourself

00:37:45,350 --> 00:37:53,970
when you use things that refer that

00:37:48,810 --> 00:37:57,450
point somewhere it's on the other hand

00:37:53,970 --> 00:38:00,720
you need pointing things for example the

00:37:57,450 --> 00:38:03,180
managing types they usually need

00:38:00,720 --> 00:38:04,710
pointing types to give out so they can

00:38:03,180 --> 00:38:08,160
keep track of the things that they

00:38:04,710 --> 00:38:11,310
manage the OL polymorphic type the

00:38:08,160 --> 00:38:14,490
polymorphism only works through pointers

00:38:11,310 --> 00:38:18,000
or things that act like pointers

00:38:14,490 --> 00:38:19,730
references which is a better means some

00:38:18,000 --> 00:38:21,570
pointing types are even nullable

00:38:19,730 --> 00:38:27,900
dereferencing a null pointer is

00:38:21,570 --> 00:38:30,710
undefined behavior boom and the bad

00:38:27,900 --> 00:38:35,100
thing is all pointing times regardless

00:38:30,710 --> 00:38:37,200
can be dang mate dangling and accessing

00:38:35,100 --> 00:38:40,650
a dangling resource accessing an object

00:38:37,200 --> 00:38:43,140
that's no longer existent gives you very

00:38:40,650 --> 00:38:45,030
very bad things and you better not do

00:38:43,140 --> 00:38:46,030
that because you're an undefined

00:38:45,030 --> 00:38:50,080
behavior

00:38:46,030 --> 00:38:52,870
land there are same uses of pointing

00:38:50,080 --> 00:38:55,510
types you can make them smart so they

00:38:52,870 --> 00:39:00,430
manage what they point to like unique

00:38:55,510 --> 00:39:02,470
pointer and one the only place where

00:39:00,430 --> 00:39:05,800
it's very safe to use them is down the

00:39:02,470 --> 00:39:09,990
call chain if you call a function taking

00:39:05,800 --> 00:39:12,400
something by reference that's safe

00:39:09,990 --> 00:39:17,080
nothing bad can happen because you only

00:39:12,400 --> 00:39:19,210
can call it with an object existing but

00:39:17,080 --> 00:39:23,140
if you memorize that reference somewhere

00:39:19,210 --> 00:39:25,360
else either capturing in the lambda and

00:39:23,140 --> 00:39:27,490
do something strange with lambda you

00:39:25,360 --> 00:39:29,410
easily end up in the situation where

00:39:27,490 --> 00:39:33,820
that reference is dangling and then

00:39:29,410 --> 00:39:37,680
you're down here or even way off the

00:39:33,820 --> 00:39:37,680
screen lower left

00:39:37,860 --> 00:39:44,050
so in c-plus was one of the strengths we

00:39:42,100 --> 00:39:49,240
can define things that refer to other

00:39:44,050 --> 00:39:54,760
objects but the lifetime dependency is

00:39:49,240 --> 00:39:58,570
there often we have types that are these

00:39:54,760 --> 00:40:01,180
pointing types that are class types that

00:39:58,570 --> 00:40:04,960
are regular that can be copied and

00:40:01,180 --> 00:40:08,050
everything but they are not value types

00:40:04,960 --> 00:40:09,460
because they don't exist out of time and

00:40:08,050 --> 00:40:12,130
space they don't exist

00:40:09,460 --> 00:40:15,630
on their own they have the number 42

00:40:12,130 --> 00:40:18,280
it's always 42 regardless where it is

00:40:15,630 --> 00:40:20,830
but if I have a pointer to a memory

00:40:18,280 --> 00:40:23,350
location where 42 might have been stored

00:40:20,830 --> 00:40:25,960
and if that memory location is freed my

00:40:23,350 --> 00:40:29,310
pointer is no longer valid so it doesn't

00:40:25,960 --> 00:40:34,020
stay even the point of value is the same

00:40:29,310 --> 00:40:37,200
and pointers in Disguise are iterators

00:40:34,020 --> 00:40:41,110
smarter pointers reference wrappers

00:40:37,200 --> 00:40:45,880
references views and spans the string

00:40:41,110 --> 00:40:48,820
view is a pointer you might not see it

00:40:45,880 --> 00:40:51,520
like that it's a pointer the C array is

00:40:48,820 --> 00:40:55,030
a pointer especially if it's passed as a

00:40:51,520 --> 00:40:59,180
function type advancing parameter type

00:40:55,030 --> 00:41:03,290
because then it generates to a pointer

00:40:59,180 --> 00:41:06,710
so the problem is dangling invalid

00:41:03,290 --> 00:41:09,180
reference pointers null pointers

00:41:06,710 --> 00:41:11,670
invalidated iterators because a call

00:41:09,180 --> 00:41:14,520
container has changed or passed the end

00:41:11,670 --> 00:41:16,950
iterators which are valid but we which

00:41:14,520 --> 00:41:24,630
only supported a partial comparison with

00:41:16,950 --> 00:41:28,160
other iterators iterators must be

00:41:24,630 --> 00:41:30,300
regular that's the concept by Stepanov

00:41:28,160 --> 00:41:32,160
sometimes they don't need to be default

00:41:30,300 --> 00:41:35,310
constructible i think that might have

00:41:32,160 --> 00:41:37,680
changed in between and most iterators

00:41:35,310 --> 00:41:39,900
refer to other objects in containers so

00:41:37,680 --> 00:41:43,170
they depend on the lifetime of another

00:41:39,900 --> 00:41:44,940
object they are not values they depend

00:41:43,170 --> 00:41:46,860
on a lifetime of another object and

00:41:44,940 --> 00:41:51,810
changing that other object might

00:41:46,860 --> 00:41:53,460
actually break the iterator and there

00:41:51,810 --> 00:41:55,410
are special values you have to deal with

00:41:53,460 --> 00:41:57,510
you consciously have to make sure that

00:41:55,410 --> 00:41:59,940
you know that this iterator has a

00:41:57,510 --> 00:42:02,240
special value and sometimes the only

00:41:59,940 --> 00:42:04,860
means to figure that else have the

00:42:02,240 --> 00:42:07,680
original container at hand to figure out

00:42:04,860 --> 00:42:10,740
if that iterator actually is invalid for

00:42:07,680 --> 00:42:13,020
example in C+ as they have it if you

00:42:10,740 --> 00:42:14,940
have a single iterative value we have no

00:42:13,020 --> 00:42:20,520
idea to know of that iterator value is

00:42:14,940 --> 00:42:23,400
valid or not high discipline you need to

00:42:20,520 --> 00:42:26,640
have things together in context ranges

00:42:23,400 --> 00:42:28,740
might make things a little bit saner in

00:42:26,640 --> 00:42:31,440
that sense but I haven't tried enough of

00:42:28,740 --> 00:42:35,910
ranges to understand if there are dark

00:42:31,440 --> 00:42:39,560
holes as well reference Ripper who's

00:42:35,910 --> 00:42:43,130
using reference wrapper in the codebase

00:42:39,560 --> 00:42:45,510
who knows that reference wrapper exists

00:42:43,130 --> 00:42:52,050
who has never heard of reference Ripper

00:42:45,510 --> 00:42:55,290
now you have it's used in the standard

00:42:52,050 --> 00:42:57,570
library it was invented for bind it has

00:42:55,290 --> 00:42:59,550
some nice properties some people says is

00:42:57,570 --> 00:43:02,220
head it has ugly properties but it's

00:42:59,550 --> 00:43:05,880
sometimes useful in generic code to pass

00:43:02,220 --> 00:43:07,650
it around to pass and to keep classes

00:43:05,880 --> 00:43:11,100
that hold the reference that cannot be

00:43:07,650 --> 00:43:12,750
null and still make them regular by

00:43:11,100 --> 00:43:15,300
making them a sign

00:43:12,750 --> 00:43:18,640
because you cannot reset a reference

00:43:15,300 --> 00:43:25,510
member but you can reset a reference rep

00:43:18,640 --> 00:43:28,900
and member smart pointers the assistant

00:43:25,510 --> 00:43:30,910
standard library fundamentals technical

00:43:28,900 --> 00:43:33,640
specification where we have the observer

00:43:30,910 --> 00:43:36,160
pointer in there this is the pointer

00:43:33,640 --> 00:43:44,260
that I would like to get for referring

00:43:36,160 --> 00:43:47,500
to single objects on nothing what could

00:43:44,260 --> 00:43:49,870
one could say ok if you don't meet that

00:43:47,500 --> 00:43:53,260
nothing why don't we use optional to

00:43:49,870 --> 00:43:56,590
reference to the type well unfortunately

00:43:53,260 --> 00:44:01,240
optional two references up to references

00:43:56,590 --> 00:44:03,220
are not allowed may be yet so it's

00:44:01,240 --> 00:44:05,500
either optional reference or observer

00:44:03,220 --> 00:44:07,600
pointer but not defined like that

00:44:05,500 --> 00:44:10,240
because I want more semantics I want to

00:44:07,600 --> 00:44:14,260
but maybe it's the right way to do I am

00:44:10,240 --> 00:44:16,390
Not sure she had pointer if you ever

00:44:14,260 --> 00:44:18,760
have seen one of Miko Yasuda's talk on

00:44:16,390 --> 00:44:22,750
shared pointer look if you haven't

00:44:18,760 --> 00:44:24,580
looked it has its own issues it can be a

00:44:22,750 --> 00:44:27,190
nice thing especially if you come from

00:44:24,580 --> 00:44:29,740
Java but you end up with more problems

00:44:27,190 --> 00:44:33,250
than you might have experienced in Java

00:44:29,740 --> 00:44:35,560
with SharePoint better use unique

00:44:33,250 --> 00:44:38,560
pointer exclusively and know when you

00:44:35,560 --> 00:44:39,910
refer to something that's held by a unit

00:44:38,560 --> 00:44:42,370
pointer and manage the lifetime

00:44:39,910 --> 00:44:48,130
explicitly because that's much easier to

00:44:42,370 --> 00:44:53,470
get right and fewer surprises string

00:44:48,130 --> 00:44:55,290
view is another pointing type it's okay

00:44:53,470 --> 00:44:59,920
as a parameter type for functions

00:44:55,290 --> 00:45:06,310
because passing pointing things down the

00:44:59,920 --> 00:45:08,590
khole chain is safe but don't never

00:45:06,310 --> 00:45:12,640
return string views from functions

00:45:08,590 --> 00:45:14,560
especially if the caller doesn't know

00:45:12,640 --> 00:45:18,070
about the lifetime of the underlying

00:45:14,560 --> 00:45:20,550
object that it refers to returned

00:45:18,070 --> 00:45:20,550
strings

00:45:21,110 --> 00:45:27,220
it's good for using for replacing

00:45:24,050 --> 00:45:31,160
character pointers and string construe

00:45:27,220 --> 00:45:32,840
parameters by string view it can be

00:45:31,160 --> 00:45:35,990
better performance if your parsing

00:45:32,840 --> 00:45:38,210
string literals but be aware if you have

00:45:35,990 --> 00:45:40,850
generic code it's very hard to get right

00:45:38,210 --> 00:45:42,830
I try to write a paper on replacing all

00:45:40,850 --> 00:45:45,010
standard library overloads that have

00:45:42,830 --> 00:45:48,170
character pointers and string references

00:45:45,010 --> 00:45:52,730
considering reference by string view and

00:45:48,170 --> 00:45:55,040
I failed or horribly put in a lot of

00:45:52,730 --> 00:45:57,110
work without getting anywhere it was

00:45:55,040 --> 00:46:05,690
unemployment able and would break

00:45:57,110 --> 00:46:08,140
existing code see style pointers I don't

00:46:05,690 --> 00:46:13,940
want to go into detail don't use them

00:46:08,140 --> 00:46:17,300
they are dangerous and insane they allow

00:46:13,940 --> 00:46:20,030
arithmetic they allow indexing you never

00:46:17,300 --> 00:46:23,210
know what you're doing you have things

00:46:20,030 --> 00:46:29,330
like where is caused by longing on the

00:46:23,210 --> 00:46:32,300
right on the east side and it's very

00:46:29,330 --> 00:46:36,800
hard to use them safely and sanely and

00:46:32,300 --> 00:46:43,400
they require high high discipline so if

00:46:36,800 --> 00:46:47,030
you meet a C programmer he or she well

00:46:43,400 --> 00:46:50,630
they need to have their drill instructor

00:46:47,030 --> 00:46:53,000
in them back of the mind every single

00:46:50,630 --> 00:46:55,340
piece of code that they write because

00:46:53,000 --> 00:46:57,170
they use plain pointers they use

00:46:55,340 --> 00:47:01,160
dangerous things and they will shoot

00:46:57,170 --> 00:47:04,430
their food without recognizing and if

00:47:01,160 --> 00:47:09,370
you program the same way in C++ that's a

00:47:04,430 --> 00:47:12,500
way to get into insanity land and

00:47:09,370 --> 00:47:16,910
undefined behavior unicorn land or

00:47:12,500 --> 00:47:19,910
whatever you call it don't do it all

00:47:16,910 --> 00:47:22,460
pointing types and sometimes we are not

00:47:19,910 --> 00:47:24,320
even aware that they are live in the

00:47:22,460 --> 00:47:29,750
dangerous quadrant requiring high

00:47:24,320 --> 00:47:33,550
discipline the back bad thing is very

00:47:29,750 --> 00:47:33,550
often code just compiles

00:47:35,109 --> 00:47:40,670
like the integer promotion rules nobody

00:47:38,029 --> 00:47:42,980
can remember who knows all the iterator

00:47:40,670 --> 00:47:47,180
invalidation rules in the standard

00:47:42,980 --> 00:47:48,980
library containers when I insert

00:47:47,180 --> 00:47:55,369
something in a vector R the iterators

00:47:48,980 --> 00:47:57,140
valid it depends when the vector he

00:47:55,369 --> 00:47:59,779
needs to relocate all it arrays are

00:47:57,140 --> 00:48:03,609
invalidated when I insert in the list

00:47:59,779 --> 00:48:12,710
are the existing iterator still valid

00:48:03,609 --> 00:48:15,019
yes should we use lists no there are

00:48:12,710 --> 00:48:18,109
ideas on setting analysis to figure out

00:48:15,019 --> 00:48:20,180
if pointing types are only used in the

00:48:18,109 --> 00:48:23,930
same way we are trying to implement that

00:48:20,180 --> 00:48:26,420
for our IDE the true if that works out

00:48:23,930 --> 00:48:28,460
we have languages like Russ to try to

00:48:26,420 --> 00:48:31,339
give you that safety guarantee but the

00:48:28,460 --> 00:48:33,109
only interesting things that you can

00:48:31,339 --> 00:48:36,289
write and rust that are interesting

00:48:33,109 --> 00:48:39,730
require used to use unsafe at least

00:48:36,289 --> 00:48:48,650
you're honest in that way so we get

00:48:39,730 --> 00:48:52,460
their temporaries another thing that's

00:48:48,650 --> 00:48:53,809
bad Java programmers don't know that

00:48:52,460 --> 00:48:56,299
because there you have garbage

00:48:53,809 --> 00:48:59,150
collection everything is a reference in

00:48:56,299 --> 00:49:04,339
C++ you get interesting undefined

00:48:59,150 --> 00:49:06,349
behavior oh yeah one idea I had maybe we

00:49:04,339 --> 00:49:10,990
should make sure that we never return

00:49:06,349 --> 00:49:13,579
iterator from a temporary container

00:49:10,990 --> 00:49:17,059
because when that iterator is used the

00:49:13,579 --> 00:49:22,039
container might be gang one idea would

00:49:17,059 --> 00:49:25,759
have these referenced begin versions and

00:49:22,039 --> 00:49:27,680
delete the reference but I'm not sure if

00:49:25,759 --> 00:49:28,369
that's valid and it would require the

00:49:27,680 --> 00:49:31,789
Const

00:49:28,369 --> 00:49:34,130
ref ref deleted as well an idea think

00:49:31,789 --> 00:49:36,170
about it if you have if you believe

00:49:34,130 --> 00:49:37,460
that's a good idea tell me if you

00:49:36,170 --> 00:49:40,640
believe it's a good better idea

00:49:37,460 --> 00:49:42,410
explaining why and I'm sure it will

00:49:40,640 --> 00:49:44,359
never be standardized because it might

00:49:42,410 --> 00:49:47,760
break existing code that's wrong anyway

00:49:44,359 --> 00:49:51,330
it's always a danger

00:49:47,760 --> 00:49:53,700
managing stuff Richard Corden told me

00:49:51,330 --> 00:49:54,180
when trying to figuring out a name for

00:49:53,700 --> 00:49:56,730
that Oh

00:49:54,180 --> 00:50:00,900
I call these monomorphic object types

00:49:56,730 --> 00:50:03,150
they have state they have behavior

00:50:00,900 --> 00:50:10,170
that's interesting they keep changing

00:50:03,150 --> 00:50:11,940
their state so they are not values but

00:50:10,170 --> 00:50:13,470
they don't inherit from something

00:50:11,940 --> 00:50:14,520
interesting and don't provide virtual

00:50:13,470 --> 00:50:17,160
mental functions

00:50:14,520 --> 00:50:20,730
I cannot while these types actually

00:50:17,160 --> 00:50:23,340
manage stuff you have a lot of managing

00:50:20,730 --> 00:50:26,730
types in the standard library those that

00:50:23,340 --> 00:50:29,220
are III those that manage memory all

00:50:26,730 --> 00:50:31,620
kind of resource management I talked

00:50:29,220 --> 00:50:35,190
about that yesterday a little bit and

00:50:31,620 --> 00:50:37,440
they might meet pointing types to

00:50:35,190 --> 00:50:40,140
actually make use of that and that

00:50:37,440 --> 00:50:42,180
requires discipline to only call it down

00:50:40,140 --> 00:50:45,360
the call chain very off managing types

00:50:42,180 --> 00:50:47,370
are high up to a located high up the

00:50:45,360 --> 00:50:49,770
call chain on the stack and then pass

00:50:47,370 --> 00:50:53,220
the reference down they call chain so

00:50:49,770 --> 00:50:57,210
that they remain the same object and you

00:50:53,220 --> 00:50:58,740
can refer to it there are things like

00:50:57,210 --> 00:51:00,420
the manager design pattern and I'm

00:50:58,740 --> 00:51:04,050
running out of time I don't want to go

00:51:00,420 --> 00:51:06,500
into that detail Rai was to talk about I

00:51:04,050 --> 00:51:09,960
talked about yesterday intensively

00:51:06,500 --> 00:51:12,300
dynamic polymorphism from parent has the

00:51:09,960 --> 00:51:17,850
opinion inheritance is the base class of

00:51:12,300 --> 00:51:19,500
evil and I started out in C plasters and

00:51:17,850 --> 00:51:23,130
I liked inheritance because that was

00:51:19,500 --> 00:51:26,160
cool and new and fresh in around 1990

00:51:23,130 --> 00:51:29,400
and today I hate inheritance at least

00:51:26,160 --> 00:51:34,890
dynamic polymorphism because it makes

00:51:29,400 --> 00:51:37,370
you design in life interesting that

00:51:34,890 --> 00:51:40,170
table is something you should memorize

00:51:37,370 --> 00:51:42,420
or at least know that it exists and know

00:51:40,170 --> 00:51:46,830
where to find it produced by Howerton

00:51:42,420 --> 00:51:49,410
and showing you what you get when you

00:51:46,830 --> 00:51:53,160
define one of these special member

00:51:49,410 --> 00:51:55,950
functions or nothing and there are few

00:51:53,160 --> 00:51:56,520
holes for backward compatibility the red

00:51:55,950 --> 00:51:59,820
ones

00:51:56,520 --> 00:52:01,150
if you define the distractor use objects

00:51:59,820 --> 00:52:06,700
are still copyable

00:52:01,150 --> 00:52:09,549
and you get a default copy mechanism for

00:52:06,700 --> 00:52:12,430
that you don't want that because if you

00:52:09,549 --> 00:52:15,160
define a destructive with semantics you

00:52:12,430 --> 00:52:17,589
want something interesting happening and

00:52:15,160 --> 00:52:20,859
usually your types are no longer value

00:52:17,589 --> 00:52:23,980
types and you definitely don't want a

00:52:20,859 --> 00:52:26,349
default copy constructor the good thing

00:52:23,980 --> 00:52:29,519
is when you declare a remove assignment

00:52:26,349 --> 00:52:32,140
all the other interesting things are

00:52:29,519 --> 00:52:35,710
deleted are now declared so nothing bad

00:52:32,140 --> 00:52:38,099
happens that made me to come up with a

00:52:35,710 --> 00:52:40,809
suggestion whenever you define a

00:52:38,099 --> 00:52:44,349
destructor like you are in the base

00:52:40,809 --> 00:52:48,940
class of a dynamic polymorphic hierarchy

00:52:44,349 --> 00:52:52,480
you better use the declare move the sign

00:52:48,940 --> 00:52:54,309
but as deleted and then nothing bad

00:52:52,480 --> 00:52:56,789
happens you have your usually clear

00:52:54,309 --> 00:52:58,740
destructor and you might have additional

00:52:56,789 --> 00:53:02,099
constructors and a default constructor

00:52:58,740 --> 00:53:05,259
but you never get are able to

00:53:02,099 --> 00:53:10,089
intentionally copy and thus slice your

00:53:05,259 --> 00:53:14,259
hierarchy objects good that's how all

00:53:10,089 --> 00:53:17,739
hierarchies should be done very often

00:53:14,259 --> 00:53:20,440
they are applied badly that's a typical

00:53:17,739 --> 00:53:23,230
textbook example and object orientation

00:53:20,440 --> 00:53:26,200
we have a person class and soon and

00:53:23,230 --> 00:53:29,049
professor inherit from person is that

00:53:26,200 --> 00:53:33,940
good design who has written class

00:53:29,049 --> 00:53:36,029
hierarchies like that confess it's bad

00:53:33,940 --> 00:53:40,359
idea

00:53:36,029 --> 00:53:43,269
don't there are a few situations where

00:53:40,359 --> 00:53:46,420
you actually have dynamic polymorphic

00:53:43,269 --> 00:53:49,210
behavior where you change behavior at

00:53:46,420 --> 00:53:51,519
runtime in a polymorphic way of a common

00:53:49,210 --> 00:53:54,509
abstraction and you can program to the

00:53:51,519 --> 00:53:57,249
base class in C++ we have a much richer

00:53:54,509 --> 00:53:59,230
vocabulary on programming against

00:53:57,249 --> 00:54:02,400
abstraction like against the template

00:53:59,230 --> 00:54:04,900
parameter and make it statically

00:54:02,400 --> 00:54:08,319
polymorphic at compile time which is

00:54:04,900 --> 00:54:10,630
first more efficient and safer and you

00:54:08,319 --> 00:54:14,609
don't need to pass use these reference

00:54:10,630 --> 00:54:14,609
things that can be dangling

00:54:19,230 --> 00:54:26,710
so what are same combinations of special

00:54:23,500 --> 00:54:28,630
member functions the first thing is two

00:54:26,710 --> 00:54:30,520
things are the green ones aggregates

00:54:28,630 --> 00:54:32,460
and value types aggregates by definition

00:54:30,520 --> 00:54:36,300
are value types unless you have a

00:54:32,460 --> 00:54:41,080
interesting member in the aggregate

00:54:36,300 --> 00:54:43,000
everything is defaulted and maybe in the

00:54:41,080 --> 00:54:45,280
befall constructor you have none because

00:54:43,000 --> 00:54:45,790
you have a class invariant but that's

00:54:45,280 --> 00:54:48,730
good

00:54:45,790 --> 00:54:52,060
you have manager classes that are not

00:54:48,730 --> 00:54:53,410
copyable often not movable sometimes you

00:54:52,060 --> 00:54:57,340
might want to move them but then you

00:54:53,410 --> 00:55:02,380
spell it out you have usually an expert

00:54:57,340 --> 00:55:04,240
level code in the destructor to clean up

00:55:02,380 --> 00:55:06,220
stuff like vector has to lead all the

00:55:04,240 --> 00:55:07,570
elements in its destructor that's expert

00:55:06,220 --> 00:55:10,360
level code you don't want to write that

00:55:07,570 --> 00:55:13,390
every day because it's too easy to get

00:55:10,360 --> 00:55:17,740
it wrong or even get into undefined

00:55:13,390 --> 00:55:21,250
behavior land which vector might be if

00:55:17,740 --> 00:55:24,870
you do it in itself rai classes have

00:55:21,250 --> 00:55:27,850
user declared and often user-defined

00:55:24,870 --> 00:55:30,780
destructors and better not be copyable

00:55:27,850 --> 00:55:35,260
but might be movable if you need that

00:55:30,780 --> 00:55:37,360
our base classes should have a defaulted

00:55:35,260 --> 00:55:39,820
virtual destructor in the base class

00:55:37,360 --> 00:55:46,840
only it's automatically inherited and

00:55:39,820 --> 00:55:49,630
not be copyable or movable you might

00:55:46,840 --> 00:55:51,610
retrofit value semantics to manage a

00:55:49,630 --> 00:55:54,340
class like it's done for vector but

00:55:51,610 --> 00:55:57,250
that's really expert level territory it

00:55:54,340 --> 00:56:01,060
requires a higher expertise to make it

00:55:57,250 --> 00:56:04,390
work correctly don't do that every day

00:56:01,060 --> 00:56:07,210
do that if your standard library

00:56:04,390 --> 00:56:09,760
implementer or I would say a standard

00:56:07,210 --> 00:56:11,830
library level library implementer but

00:56:09,760 --> 00:56:17,880
not in day to day code for your domain

00:56:11,830 --> 00:56:21,130
because it's too easy to mess it up you

00:56:17,880 --> 00:56:23,410
can actually combine a whole dynamic

00:56:21,130 --> 00:56:25,240
polymorphism with valued semantics

00:56:23,410 --> 00:56:27,580
strong parent showed that he has a nice

00:56:25,240 --> 00:56:28,300
talk I believe it was also in CPP

00:56:27,580 --> 00:56:31,090
callosum

00:56:28,300 --> 00:56:34,630
when you on video I don't want to go

00:56:31,090 --> 00:56:36,550
into the details because it's once you

00:56:34,630 --> 00:56:40,180
got it is easy to understand but to

00:56:36,550 --> 00:56:42,340
understand it's really hard so if you

00:56:40,180 --> 00:56:45,550
look at our landscape of safety and

00:56:42,340 --> 00:56:48,850
sanity there are many things to look out

00:56:45,550 --> 00:56:51,880
for a lot of things can be done put into

00:56:48,850 --> 00:56:54,250
the safe quadrant up here by library

00:56:51,880 --> 00:56:56,170
experts by using good things I didn't go

00:56:54,250 --> 00:56:58,480
into standard variant for variation at

00:56:56,170 --> 00:57:01,810
runtime but there are the things you can

00:56:58,480 --> 00:57:05,620
do and remember the building types are

00:57:01,810 --> 00:57:09,930
close to insanity just remember that the

00:57:05,620 --> 00:57:09,930
next time you spell out I and T

00:57:10,320 --> 00:57:18,460
takeaways learn to appreciate the C++

00:57:15,940 --> 00:57:22,240
type system every class is an indication

00:57:18,460 --> 00:57:25,090
to think and refactor you could even

00:57:22,240 --> 00:57:32,170
treat every cast as a mistake of your

00:57:25,090 --> 00:57:37,180
program design model with value types

00:57:32,170 --> 00:57:39,370
almost always be aware and you model

00:57:37,180 --> 00:57:42,190
with dimensions about the distinction of

00:57:39,370 --> 00:57:46,930
relative and absolute values in the same

00:57:42,190 --> 00:57:50,260
unit rep remoted types using the whole

00:57:46,930 --> 00:57:52,750
value design pattern and even a name

00:57:50,260 --> 00:57:58,060
simple struct wrapping an end is better

00:57:52,750 --> 00:58:00,400
than using int be aware of the required

00:57:58,060 --> 00:58:03,040
expertise and discipline for manager

00:58:00,400 --> 00:58:05,800
types and oo hierarchies it's not that

00:58:03,040 --> 00:58:08,290
simple it's easy to get wrong or get

00:58:05,800 --> 00:58:11,590
into undefined behavior land especially

00:58:08,290 --> 00:58:15,370
when you combine them be disciplined

00:58:11,590 --> 00:58:17,200
about pointing types and this includes

00:58:15,370 --> 00:58:19,810
reference and string view it's not

00:58:17,200 --> 00:58:21,310
impossible to get it right but get your

00:58:19,810 --> 00:58:23,350
drill instructor in your back of the

00:58:21,310 --> 00:58:25,660
head every time you use the pointer a

00:58:23,350 --> 00:58:28,930
reference every time you use something

00:58:25,660 --> 00:58:31,210
it's not a value run away from special

00:58:28,930 --> 00:58:34,140
from view special member function

00:58:31,210 --> 00:58:38,740
combinations even if they are defaulted

00:58:34,140 --> 00:58:39,630
that's danger lurking might explode in

00:58:38,740 --> 00:58:42,040
your face

00:58:39,630 --> 00:58:45,390
usually they tried to

00:58:42,040 --> 00:58:48,030
do too much or the wrong thing and

00:58:45,390 --> 00:59:05,890
that's it

00:58:48,030 --> 00:59:09,760
questions for you to read I think we can

00:59:05,890 --> 00:59:12,550
take two or three maybe one a question

00:59:09,760 --> 00:59:15,490
about pointing types so he said it

00:59:12,550 --> 00:59:18,880
dangerous but if he talked about unique

00:59:15,490 --> 00:59:21,820
and short and shared pointers it feels

00:59:18,880 --> 00:59:24,310
like they kind of a completely different

00:59:21,820 --> 00:59:26,890
part of the Quadra that they are much

00:59:24,310 --> 00:59:32,740
safer and actually requires much less

00:59:26,890 --> 00:59:35,110
discipline to everything else the thing

00:59:32,740 --> 00:59:36,430
was unique point and share point and

00:59:35,110 --> 00:59:37,090
require less discipline than other

00:59:36,430 --> 00:59:39,100
pointers

00:59:37,090 --> 00:59:41,770
yes but they still require discipline

00:59:39,100 --> 00:59:43,930
like not calling get arbitrarily and

00:59:41,770 --> 00:59:46,270
converting them to the plain pointer and

00:59:43,930 --> 00:59:48,600
also they might be null which is also

00:59:46,270 --> 00:59:51,070
something you have to take care of so

00:59:48,600 --> 00:59:53,680
better unique point and share point that

00:59:51,070 --> 00:59:59,130
in-plane pointers but better use just

00:59:53,680 --> 01:00:01,360
values if possible that's my guidance

00:59:59,130 --> 01:00:05,080
when you were talking about ranges and

01:00:01,360 --> 01:00:08,110
and deleting the begin and end for our

01:00:05,080 --> 01:00:10,660
values one thing that I think is

01:00:08,110 --> 01:00:12,130
interesting about range v3 is that the

01:00:10,660 --> 01:00:14,620
views that you get which are similar to

01:00:12,130 --> 01:00:17,080
spans which are you know kind of can can

01:00:14,620 --> 01:00:18,940
dangle if you're not careful you can

01:00:17,080 --> 01:00:22,390
only create a range out of an L value of

01:00:18,940 --> 01:00:23,980
a container it's it's it's you can't

01:00:22,390 --> 01:00:26,020
create one out of an R value just

01:00:23,980 --> 01:00:27,820
precisely for that same reason of not

01:00:26,020 --> 01:00:29,800
you wanting to not be able to get

01:00:27,820 --> 01:00:32,470
iterator so it kind of follows along the

01:00:29,800 --> 01:00:34,420
the right pattern thank you for that

01:00:32,470 --> 01:00:41,210
information I haven't learned that yet

01:00:34,420 --> 01:00:49,610
okay and do you want a head

01:00:41,210 --> 01:00:52,490
I have two left so the most interesting

01:00:49,610 --> 01:00:58,520
question get a question about the ranges

01:00:52,490 --> 01:01:00,380
and go up on your remark about when you

01:00:58,520 --> 01:01:02,480
use eto returning integrator from the

01:01:00,380 --> 01:01:04,760
container that's Valhalla maybe you know

01:01:02,480 --> 01:01:08,450
already delete it out those cops of you

01:01:04,760 --> 01:01:11,630
you need for regular chaps a lot of time

01:01:08,450 --> 01:01:14,360
to have an identity element for the

01:01:11,630 --> 01:01:17,090
Rangers no onions writer and you usually

01:01:14,360 --> 01:01:20,420
use it at some and or you know something

01:01:17,090 --> 01:01:24,670
such as a special value for to to

01:01:20,420 --> 01:01:26,720
indicate on that structure so I mean

01:01:24,670 --> 01:01:31,090
what would you what do you sing like

01:01:26,720 --> 01:01:33,890
what's your opinion on using that as a

01:01:31,090 --> 01:01:36,260
zero or identity element and you know

01:01:33,890 --> 01:01:40,580
what why don't you just do two night at

01:01:36,260 --> 01:01:43,370
a special and I'm not sure if I

01:01:40,580 --> 01:01:45,710
understood you your question is I said

01:01:43,370 --> 01:01:48,290
be aware of iterators they might be bad

01:01:45,710 --> 01:01:50,840
but you have to use them anyway that

01:01:48,290 --> 01:01:52,550
your your statement yeah well you have

01:01:50,840 --> 01:01:54,080
to you have to use it and some sometimes

01:01:52,550 --> 01:01:55,910
it's just worried you know best as you

01:01:54,080 --> 01:01:58,040
can find if you just have a range and

01:01:55,910 --> 01:01:59,780
you have you know some scissors one

01:01:58,040 --> 01:02:01,790
special iterator that it would be

01:01:59,780 --> 01:02:04,280
already identity or a minute that's

01:02:01,790 --> 01:02:06,980
let's say that design decision was taken

01:02:04,280 --> 01:02:10,280
when Stepanov wanted to make the STL

01:02:06,980 --> 01:02:12,350
compatible with c arrays and we cannot

01:02:10,280 --> 01:02:14,030
change that at the moment but Rangers

01:02:12,350 --> 01:02:15,770
might help with that because you no

01:02:14,030 --> 01:02:18,950
longer have these pair that might not

01:02:15,770 --> 01:02:21,920
work together and again you must use

01:02:18,950 --> 01:02:27,020
iterators but better just pass them down

01:02:21,920 --> 01:02:29,120
the algorithm library or make sure your

01:02:27,020 --> 01:02:32,050
discipline with them it's not you

01:02:29,120 --> 01:02:35,720
shouldn't you cannot use them it's just

01:02:32,050 --> 01:02:37,640
be disciplined with them and sorry I

01:02:35,720 --> 01:02:42,200
cannot answer that better at the moment

01:02:37,640 --> 01:02:45,110
I think we need to finish up is there

01:02:42,200 --> 01:02:49,880
one final question or is it should be

01:02:45,110 --> 01:02:51,970
quick I love your part about a you know

01:02:49,880 --> 01:02:55,099
being very careful with built in types

01:02:51,970 --> 01:02:56,390
unfortunately particularly C

01:02:55,099 --> 01:02:59,029
people with C backgrounds Fortran

01:02:56,390 --> 01:03:00,229
backgrounds in scientific computing they

01:02:59,029 --> 01:03:02,239
don't feel like they're getting the most

01:03:00,229 --> 01:03:05,660
out of the compiler unless they're using

01:03:02,239 --> 01:03:08,299
the bare types how do we instill a trust

01:03:05,660 --> 01:03:12,140
for the compiler in them do we do do we

01:03:08,299 --> 01:03:13,130
teach maybe benchmarking exercises how

01:03:12,140 --> 01:03:16,880
would you go about doing that especially

01:03:13,130 --> 01:03:26,630
at a university or in a company I would

01:03:16,880 --> 01:03:29,359
say got bold okay thank you very much

01:03:26,630 --> 01:03:31,819
have fun I have two hats left and a lot

01:03:29,359 --> 01:03:34,549
of Swiss chocolate come see me and grab

01:03:31,819 --> 01:03:36,559
stuff cap grab the chocolate and there's

01:03:34,549 --> 01:03:39,640
a lightning talk tonight so maybe I give

01:03:36,559 --> 01:03:39,640

YouTube URL: https://www.youtube.com/watch?v=REIEaUY9np4


