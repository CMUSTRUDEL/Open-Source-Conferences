Title: CppCon 2018: Boris Kolpackov “What to Expect from a Next-Generation C++ Build System”
Publication date: 2018-10-13
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Few will argue that a standard build system would greatly benefit the C++ community. And the change is in the air: the upcoming C++ Modules are bound to shake things up, the need to support multiple build systems is putting pressure on our packaging efforts, and languages like Rust and Go clearly show things work much better if the build system and package manager are well integrated. Perhaps then this is the C++ community's "git moment": an opportunity to get a next-generation build system that everyone is finally happy to use. 

In this talk I will demonstrate key features the next-generation C++ build system should have in order to achieve that elusive happy-to-use property. It is based on our experience developing the build2 toolchain, an integrated build system and package/project dependency managers (and which already supports C++ Modules). 

We start with a brief discussion of overall design choices: native or project generator/meta build system, black box or a concept of build, declarative or scripted (or perhaps a hybrid), uniform or platform-specific, in which language can/should it be implemented, and, finally, what about IDE/tools integration? 

Next, we go over what any current-generation build system should already support: build configuration management, cross-compilation, additional operations (test, install/uninstall, dist), out of source builds, and wildcard patterns. 

Then on to the next-generation: high-fidelity hermetic builds, precise change detection, portable, parallel testing, project importing/composability, and support for C++ Modules which should pave the way to reliable, generally-available distribution compilation.
— 
Boris Kolpackov, Code Synthesis
Chief Hacking Officer

Boris Kolpackov is a founder and CHO (Chief Hacking Officer) at Code Synthesis, a company focusing on the development of open-source tools and libraries for C++. For the past 10 years Boris has been working on solving interesting problems in the context of C++ using domain-specific languages (DSL), C++ parsing, source-to-source translation, and code generation. His notable projects to date include ODB (ORM for C++), XSD and XSD/e (XML Schema to C++ compilers), as well as libstudxml (XML parser/serializer library for C++).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,569 --> 00:00:06,129
so today I'd like to talk about build

00:00:03,580 --> 00:00:08,969
systems specifically what a

00:00:06,129 --> 00:00:11,080
next-generation build system for C++

00:00:08,969 --> 00:00:13,719
should look like or what we should

00:00:11,080 --> 00:00:16,570
expect a demand from it so this is based

00:00:13,719 --> 00:00:20,710
on our experience developing build to

00:00:16,570 --> 00:00:23,980
build toolchain for C++ so to make these

00:00:20,710 --> 00:00:25,930
things can create out sometimes show you

00:00:23,980 --> 00:00:29,800
examples so tell you how we do it and

00:00:25,930 --> 00:00:32,290
build two I don't think anyone will

00:00:29,800 --> 00:00:35,620
argue that having a standard build

00:00:32,290 --> 00:00:37,960
system in C++ would greatly benefit the

00:00:35,620 --> 00:00:40,059
community and I think you can all feel

00:00:37,960 --> 00:00:42,039
that the changes in the air there's a

00:00:40,059 --> 00:00:45,370
lot been going on in the past couple of

00:00:42,039 --> 00:00:50,379
years so perhaps this is our get moment

00:00:45,370 --> 00:00:51,940
this is our chance to get build a

00:00:50,379 --> 00:00:55,749
next-generation build system that

00:00:51,940 --> 00:00:58,120
everyone is more or less okay to use so

00:00:55,749 --> 00:00:59,219
what's exactly driving this change now

00:00:58,120 --> 00:01:02,769
several things

00:00:59,219 --> 00:01:05,380
mojo C++ modules on the horizon and as

00:01:02,769 --> 00:01:07,420
we'll see later in the talk they are

00:01:05,380 --> 00:01:10,600
bound to shake things up in the build

00:01:07,420 --> 00:01:12,550
system space I believe some more

00:01:10,600 --> 00:01:16,810
antiquated build systems won't be able

00:01:12,550 --> 00:01:19,570
to support modules properly having to

00:01:16,810 --> 00:01:22,000
support multiple build systems is also

00:01:19,570 --> 00:01:23,740
putting pressure on our packaging

00:01:22,000 --> 00:01:25,780
efforts and if you've some of you've

00:01:23,740 --> 00:01:28,660
seen my talk on Monday I showed some

00:01:25,780 --> 00:01:32,410
statistics the largest package

00:01:28,660 --> 00:01:35,920
repository in C++ has about 800 packages

00:01:32,410 --> 00:01:38,380
in comparison rust added 2,000 packages

00:01:35,920 --> 00:01:41,110
in the last three months so I think that

00:01:38,380 --> 00:01:42,760
clearly shows we have a problem also

00:01:41,110 --> 00:01:44,980
languages like rust show I think

00:01:42,760 --> 00:01:48,460
demonstrate pretty clearly that things

00:01:44,980 --> 00:01:51,370
worked much smoother and would let lost

00:01:48,460 --> 00:01:53,290
let a lot less friction if a build

00:01:51,370 --> 00:01:56,200
system is part of an integrated build

00:01:53,290 --> 00:01:57,940
tool chain so we want to to work well

00:01:56,200 --> 00:02:01,420
with the dependency manager with our

00:01:57,940 --> 00:02:03,250
dependency management tools I also think

00:02:01,420 --> 00:02:05,410
we are at a point where distributed

00:02:03,250 --> 00:02:06,190
compilation is sketching is no longer an

00:02:05,410 --> 00:02:09,429
option

00:02:06,190 --> 00:02:11,499
CPU progress has stagnated yeah we've

00:02:09,429 --> 00:02:12,610
been adding course but it seems like

00:02:11,499 --> 00:02:16,780
this is coming to an

00:02:12,610 --> 00:02:18,250
as well and the C++ standards committee

00:02:16,780 --> 00:02:21,340
is paying attention there is a study

00:02:18,250 --> 00:02:23,590
group sg-15 which is focusing on tools

00:02:21,340 --> 00:02:26,770
and dependence management and build

00:02:23,590 --> 00:02:28,750
systems is a big part of that and by the

00:02:26,770 --> 00:02:31,500
way mailing list is open unlike other

00:02:28,750 --> 00:02:33,700
mailing lists for Standards Committee so

00:02:31,500 --> 00:02:37,600
everyone is welcome to join and

00:02:33,700 --> 00:02:39,459
participate okay so these these are the

00:02:37,600 --> 00:02:42,690
key points that I think will shake

00:02:39,459 --> 00:02:45,850
things up in the build system space so

00:02:42,690 --> 00:02:47,650
which one what what is the next

00:02:45,850 --> 00:02:50,650
generation built system well I could

00:02:47,650 --> 00:02:52,630
tell you my opinion all of you have your

00:02:50,650 --> 00:02:55,060
own opinions will probably end up with

00:02:52,630 --> 00:02:56,350
15 options so today I will actually want

00:02:55,060 --> 00:03:02,080
to try something different

00:02:56,350 --> 00:03:06,130
I want to analyze our the the overall

00:03:02,080 --> 00:03:10,030
design of a build system for C++ based

00:03:06,130 --> 00:03:12,610
on our core values as a C++ community so

00:03:10,030 --> 00:03:15,760
this idea is based on a talk by Brian

00:03:12,610 --> 00:03:19,440
Cantrell called platform as a reflection

00:03:15,760 --> 00:03:20,739
of values you know anyone seen this top

00:03:19,440 --> 00:03:23,680
nobody

00:03:20,739 --> 00:03:25,420
Wow okay but highly recommend it's only

00:03:23,680 --> 00:03:29,290
half a now and makes you think about

00:03:25,420 --> 00:03:33,700
things so Brian listed this platform

00:03:29,290 --> 00:03:35,860
values so I just copied them so as a

00:03:33,700 --> 00:03:40,030
little detour let's try to figure out

00:03:35,860 --> 00:03:44,590
what our our core values as a C++

00:03:40,030 --> 00:03:47,250
community so a value is something that

00:03:44,590 --> 00:03:49,360
is important to us and a core value is

00:03:47,250 --> 00:03:51,940
something that's really important so

00:03:49,360 --> 00:03:53,830
some of them my intention and if we have

00:03:51,940 --> 00:03:59,140
to pick then we will choose one from our

00:03:53,830 --> 00:04:02,049
core subset also Brian suggested that a

00:03:59,140 --> 00:04:04,480
good way to determine a value of a

00:04:02,049 --> 00:04:08,380
platform or a language is to read the

00:04:04,480 --> 00:04:11,590
opening paragraph over from a book by

00:04:08,380 --> 00:04:13,390
the author of this language a platform

00:04:11,590 --> 00:04:15,479
so we're gonna do that but we're gonna

00:04:13,390 --> 00:04:17,979
start with C just a little exercise

00:04:15,479 --> 00:04:19,840
philosophical exercise so this is the

00:04:17,979 --> 00:04:22,419
opening paragraph from the C programming

00:04:19,840 --> 00:04:24,490
language read it C is a general-purpose

00:04:22,419 --> 00:04:25,470
programming language which features

00:04:24,490 --> 00:04:28,200
economy works

00:04:25,470 --> 00:04:31,620
pression modern control flow and data

00:04:28,200 --> 00:04:33,840
structures and a rich set of operators C

00:04:31,620 --> 00:04:36,750
is not a very high-level language not a

00:04:33,840 --> 00:04:39,690
big one and is not not specialized to

00:04:36,750 --> 00:04:41,880
any particular area of application but

00:04:39,690 --> 00:04:44,550
its absence of restrictions and a

00:04:41,880 --> 00:04:47,430
generality make it more convenient and

00:04:44,550 --> 00:04:50,490
effective for many tasks than supposedly

00:04:47,430 --> 00:04:54,390
more powerful languages so I've

00:04:50,490 --> 00:04:56,670
highlighted some value words in this

00:04:54,390 --> 00:04:59,220
paragraph so I think this should be

00:04:56,670 --> 00:05:01,980
feeling anthem traversal right so the

00:04:59,220 --> 00:05:04,620
core values are portability portability

00:05:01,980 --> 00:05:07,170
performance portability and simplicity

00:05:04,620 --> 00:05:11,060
right and we are not confusing simple

00:05:07,170 --> 00:05:15,570
and easy but we've all seen the talk

00:05:11,060 --> 00:05:18,020
previous talk C++ and C is simple but

00:05:15,570 --> 00:05:20,820
might not necessarily be easy okay

00:05:18,020 --> 00:05:23,760
moving on that was I think fairly easy

00:05:20,820 --> 00:05:26,100
so this is the opening paragraph from

00:05:23,760 --> 00:05:28,590
the first edition of the C++ programming

00:05:26,100 --> 00:05:31,140
language its original c plus plus c plus

00:05:28,590 --> 00:05:32,820
plus 98 so c plus plus is a

00:05:31,140 --> 00:05:34,470
general-purpose programming language

00:05:32,820 --> 00:05:37,260
designed to make programming more

00:05:34,470 --> 00:05:40,080
enjoyable for the serious program except

00:05:37,260 --> 00:05:42,570
for minor details C++ is a superset of

00:05:40,080 --> 00:05:45,540
the C programming language in addition

00:05:42,570 --> 00:05:47,580
to the facilities provided by C C++

00:05:45,540 --> 00:05:51,390
provides flexible and efficient

00:05:47,580 --> 00:05:55,110
facilities for defining new types again

00:05:51,390 --> 00:05:57,510
highlighted some key words ok so it's

00:05:55,110 --> 00:06:00,330
based on C so we probably carry over

00:05:57,510 --> 00:06:02,640
some values from there right performance

00:06:00,330 --> 00:06:05,910
and portability I don't think anyone

00:06:02,640 --> 00:06:08,760
will argue simplicity is gone right in

00:06:05,910 --> 00:06:11,880
return we get extensibility the ability

00:06:08,760 --> 00:06:14,250
define new types and compatibility with

00:06:11,880 --> 00:06:19,080
C is also important explicitly mentioned

00:06:14,250 --> 00:06:22,050
in that first paragraph okay moving on

00:06:19,080 --> 00:06:25,350
to C++ 11 brand new language so this is

00:06:22,050 --> 00:06:27,750
from the fourth edition of the C++

00:06:25,350 --> 00:06:29,750
programming language C++ is a

00:06:27,750 --> 00:06:32,160
general-purpose programming language

00:06:29,750 --> 00:06:34,830
emphasizing the design and use of type

00:06:32,160 --> 00:06:36,780
reach lightweight abstractions this

00:06:34,830 --> 00:06:39,090
particularly suited to for

00:06:36,780 --> 00:06:41,750
resource-constrained applications

00:06:39,090 --> 00:06:44,550
those found in software infrastructures

00:06:41,750 --> 00:06:46,440
C++ rewards the programmer who takes the

00:06:44,550 --> 00:06:49,440
time to master techniques for writing

00:06:46,440 --> 00:06:51,270
quality code C++ is a language for

00:06:49,440 --> 00:06:54,720
someone who takes the task of

00:06:51,270 --> 00:06:57,419
programming seriously so quite some

00:06:54,720 --> 00:07:00,570
changes there think you all agree all

00:06:57,419 --> 00:07:02,280
right let's see so it's based on C++

00:07:00,570 --> 00:07:03,870
elements in evolution of a language so

00:07:02,280 --> 00:07:06,720
probably carry all the Sun values

00:07:03,870 --> 00:07:09,090
performance portability extensibility

00:07:06,720 --> 00:07:11,610
notice that the compatibility with C is

00:07:09,090 --> 00:07:13,350
not mentioned explicitly anymore but I

00:07:11,610 --> 00:07:18,750
think we all agree that without C

00:07:13,350 --> 00:07:20,610
compatibility there will be no c++ we

00:07:18,750 --> 00:07:22,979
also got expressiveness nobody will

00:07:20,610 --> 00:07:26,130
argue I think that C++ 11 got a lot more

00:07:22,979 --> 00:07:29,190
expressive this also talked about code

00:07:26,130 --> 00:07:31,530
quality robustness and it is actually

00:07:29,190 --> 00:07:33,780
backed by what's been going on for

00:07:31,530 --> 00:07:36,990
example exception safe design good

00:07:33,780 --> 00:07:39,419
example this will c plus plus 11 also

00:07:36,990 --> 00:07:44,400
got quite a bit more approachable they

00:07:39,419 --> 00:07:46,620
are high level constructs and facilities

00:07:44,400 --> 00:07:49,669
in the standard library and there's also

00:07:46,620 --> 00:07:52,710
things like code guidelines which help

00:07:49,669 --> 00:07:54,840
newcomers get started with the language

00:07:52,710 --> 00:07:58,940
so I would say these are these are the

00:07:54,840 --> 00:08:02,099
core values of C plus of the modern C++

00:07:58,940 --> 00:08:04,500
they are I would list them in the order

00:08:02,099 --> 00:08:06,240
of preference of performances top

00:08:04,500 --> 00:08:08,419
priority right then we have expects

00:08:06,240 --> 00:08:11,610
extensibility and expressiveness

00:08:08,419 --> 00:08:15,440
portability compatibility robustness and

00:08:11,610 --> 00:08:15,440
at the end we have approachability

00:08:16,099 --> 00:08:22,380
splinters sake a little little detour

00:08:18,930 --> 00:08:26,490
inside the detour these are the the core

00:08:22,380 --> 00:08:28,710
values of Java scripts or listed in the

00:08:26,490 --> 00:08:30,330
Brian stock C as you can see there is a

00:08:28,710 --> 00:08:32,760
bit of an overlap right we have

00:08:30,330 --> 00:08:35,130
approached built-in expressiveness in

00:08:32,760 --> 00:08:38,849
common so there is not bringing up I

00:08:35,130 --> 00:08:43,320
want to highlight an interesting aspect

00:08:38,849 --> 00:08:45,779
as the community grows we might end up

00:08:43,320 --> 00:08:47,459
with a divergence of values so different

00:08:45,779 --> 00:08:50,610
sections of the community they start

00:08:47,459 --> 00:08:52,130
pulling you know the community in

00:08:50,610 --> 00:08:54,320
slightly different there

00:08:52,130 --> 00:08:57,770
actions and I don't know I personally

00:08:54,320 --> 00:09:00,740
think we have some of that in C++ we

00:08:57,770 --> 00:09:03,020
have some C++ now is again a popular

00:09:00,740 --> 00:09:05,360
language and there are newcomers that

00:09:03,020 --> 00:09:06,980
may become a JavaScript background and

00:09:05,360 --> 00:09:08,810
they have different values or they

00:09:06,980 --> 00:09:12,290
assign different priorities to their

00:09:08,810 --> 00:09:16,850
values just a little thing to think

00:09:12,290 --> 00:09:18,710
about okay so these are the values the

00:09:16,850 --> 00:09:21,470
next two questions to ask well the first

00:09:18,710 --> 00:09:25,190
question to ask whether they translate

00:09:21,470 --> 00:09:28,430
to us as a community right so these are

00:09:25,190 --> 00:09:31,370
the values as expressed by the RNA in

00:09:28,430 --> 00:09:35,810
his thought for the language and as

00:09:31,370 --> 00:09:37,220
interpreted by me so the question is are

00:09:35,810 --> 00:09:40,670
they actually the values of our

00:09:37,220 --> 00:09:41,870
community are they because it's entirely

00:09:40,670 --> 00:09:43,280
possible in your biani

00:09:41,870 --> 00:09:45,050
thought they are I'm going to design

00:09:43,280 --> 00:09:46,400
language some for one thing and the

00:09:45,050 --> 00:09:48,020
community came and said now you know

00:09:46,400 --> 00:09:51,020
we're gonna use something else entirely

00:09:48,020 --> 00:09:53,480
we have something else in mind I don't

00:09:51,020 --> 00:09:58,430
know what what do you think does that

00:09:53,480 --> 00:10:03,650
represent why you are using C++ for me

00:09:58,430 --> 00:10:05,960
personally does okay so I don't see a

00:10:03,650 --> 00:10:08,660
violent objection so I would just go

00:10:05,960 --> 00:10:12,440
with that so I would assume these are

00:10:08,660 --> 00:10:14,960
more or less the present values of the

00:10:12,440 --> 00:10:16,990
city of the C++ community so the next

00:10:14,960 --> 00:10:20,630
question is does it necessarily

00:10:16,990 --> 00:10:23,090
translate to our tools right it's also

00:10:20,630 --> 00:10:24,920
possible that we will assign completely

00:10:23,090 --> 00:10:27,790
different set of values to our tooling

00:10:24,920 --> 00:10:30,710
but again that sounds a bit strange

00:10:27,790 --> 00:10:33,470
natural thing to assume that they are

00:10:30,710 --> 00:10:35,930
the same so I'll go with that

00:10:33,470 --> 00:10:38,330
all right so these are our core values

00:10:35,930 --> 00:10:42,050
and we'll what we're gonna do next we

00:10:38,330 --> 00:10:44,420
are going to analyze some high-level

00:10:42,050 --> 00:10:48,350
meta design questions of a build system

00:10:44,420 --> 00:10:52,490
for C++ using these core values of the

00:10:48,350 --> 00:10:54,500
C++ community well the first question is

00:10:52,490 --> 00:10:56,600
actually do we do we need a build system

00:10:54,500 --> 00:10:58,010
at all right if you look at trust for

00:10:56,600 --> 00:11:00,470
example they use what I would call a

00:10:58,010 --> 00:11:02,240
build system let's model put things in

00:11:00,470 --> 00:11:05,720
certain places everything is done by

00:11:02,240 --> 00:11:09,050
convention I don't think this is

00:11:05,720 --> 00:11:11,689
to scale to C++ we have fairly complex

00:11:09,050 --> 00:11:14,120
projects in fact it doesn't scale for

00:11:11,689 --> 00:11:17,120
those languages as they're finding out

00:11:14,120 --> 00:11:18,680
for their more complex projects for

00:11:17,120 --> 00:11:21,050
example I've heard that the latest

00:11:18,680 --> 00:11:23,649
strain in the NGO communities go back to

00:11:21,050 --> 00:11:26,480
make files for building these things

00:11:23,649 --> 00:11:29,000
okay so I think I think we all agree

00:11:26,480 --> 00:11:31,120
that we do need a build system it would

00:11:29,000 --> 00:11:34,100
be nice if for simple projects we can

00:11:31,120 --> 00:11:36,500
approximate them approximate the build

00:11:34,100 --> 00:11:39,319
system less model and as I'll show later

00:11:36,500 --> 00:11:42,860
we we can actually do that so we can

00:11:39,319 --> 00:11:46,879
have our cake and eat it too okay now is

00:11:42,860 --> 00:11:49,579
the egg throwing question right native

00:11:46,879 --> 00:11:53,509
or meter build system or also known as a

00:11:49,579 --> 00:11:56,259
project generator so the idea of a metal

00:11:53,509 --> 00:11:59,990
build system on the surface is actually

00:11:56,259 --> 00:12:02,269
quite quite sane right so we have all

00:11:59,990 --> 00:12:03,860
these different build systems on

00:12:02,269 --> 00:12:06,019
different platforms why don't we come up

00:12:03,860 --> 00:12:07,819
with a high-level description language

00:12:06,019 --> 00:12:10,850
that we just translate all of them and

00:12:07,819 --> 00:12:12,529
the uses of our language there will be

00:12:10,850 --> 00:12:15,110
comfortable with the underlying build

00:12:12,529 --> 00:12:18,019
system and so on but if you look under

00:12:15,110 --> 00:12:20,689
the surface you will quickly realize

00:12:18,019 --> 00:12:22,639
that a meta build system is a race to

00:12:20,689 --> 00:12:25,040
the bottom it's a it's a race to the

00:12:22,639 --> 00:12:26,779
lowest common denominator right if you

00:12:25,040 --> 00:12:29,149
if you have to target three different

00:12:26,779 --> 00:12:30,740
underlying build systems the set of

00:12:29,149 --> 00:12:32,600
features that you can rely on is

00:12:30,740 --> 00:12:36,110
basically an intersection of them all

00:12:32,600 --> 00:12:38,839
right and that hurts and the some of the

00:12:36,110 --> 00:12:40,600
areas some of the major areas where it

00:12:38,839 --> 00:12:44,870
hurts

00:12:40,600 --> 00:12:46,519
C++ modules I believe in now III hope

00:12:44,870 --> 00:12:48,920
I'll show you it towards the end of the

00:12:46,519 --> 00:12:51,559
talk that for me to build system to

00:12:48,920 --> 00:12:53,509
support modules it will require the

00:12:51,559 --> 00:12:56,240
supporting the underlying build systems

00:12:53,509 --> 00:12:57,889
it's pretty much similar to how it is

00:12:56,240 --> 00:12:59,990
done now with here the dependency

00:12:57,889 --> 00:13:02,930
instruction extraction so if the

00:12:59,990 --> 00:13:05,750
underlying bill system doesn't support

00:13:02,930 --> 00:13:09,139
it I don't believe that a method build

00:13:05,750 --> 00:13:14,870
system has a chance of providing decent

00:13:09,139 --> 00:13:17,120
module support the other point so point

00:13:14,870 --> 00:13:19,040
of meta bill system is generated source

00:13:17,120 --> 00:13:20,160
code again the same problem if the

00:13:19,040 --> 00:13:22,079
underlying build system that

00:13:20,160 --> 00:13:25,110
and support then we have to resort to

00:13:22,079 --> 00:13:28,490
things like pre-built steps and so on

00:13:25,110 --> 00:13:30,959
which have a lot of limitations

00:13:28,490 --> 00:13:32,610
distributed compilation caching the same

00:13:30,959 --> 00:13:34,470
story we have to resort to rappers

00:13:32,610 --> 00:13:36,089
because the underlying build system

00:13:34,470 --> 00:13:38,610
doesn't support it so the meta built

00:13:36,089 --> 00:13:41,519
system can do it is either compilation

00:13:38,610 --> 00:13:43,370
database again another example the meta

00:13:41,519 --> 00:13:46,290
build system does not necessarily

00:13:43,370 --> 00:13:50,240
control on know how things are built so

00:13:46,290 --> 00:13:50,240
it simply cannot produce it

00:13:50,300 --> 00:13:57,120
there is one and probably major reason

00:13:53,790 --> 00:14:01,709
why we had to build systems are popular

00:13:57,120 --> 00:14:03,209
and that's IDE support you can use a

00:14:01,709 --> 00:14:04,920
meta build system to generate your

00:14:03,209 --> 00:14:07,110
projects and then you can work in the

00:14:04,920 --> 00:14:08,639
comfort of your ID but if you think

00:14:07,110 --> 00:14:12,959
about it we ended up in a situation

00:14:08,639 --> 00:14:15,269
where a tail is wagging the dog right we

00:14:12,959 --> 00:14:18,019
are using our build systems are using

00:14:15,269 --> 00:14:20,040
our IDs to build our code which is

00:14:18,019 --> 00:14:23,009
serial thing in a sense

00:14:20,040 --> 00:14:25,500
in contrast a native build system would

00:14:23,009 --> 00:14:28,350
have full control of compilation right

00:14:25,500 --> 00:14:30,360
you can dump the database compilation

00:14:28,350 --> 00:14:32,699
database if we need to change how things

00:14:30,360 --> 00:14:35,100
are built we are in control it also

00:14:32,699 --> 00:14:36,870
uniform right it can work exactly the

00:14:35,100 --> 00:14:39,959
same on all the platforms but all the

00:14:36,870 --> 00:14:44,730
compilers and as a bonus you know there

00:14:39,959 --> 00:14:47,459
is no a project generation step ok let's

00:14:44,730 --> 00:14:50,180
take a look at our values so this does

00:14:47,459 --> 00:14:52,560
work my opinion so here we try to

00:14:50,180 --> 00:14:56,430
compare them so on the Left I have met a

00:14:52,560 --> 00:14:58,199
build system right native met a build

00:14:56,430 --> 00:15:00,180
system have will have issues with

00:14:58,199 --> 00:15:02,939
performance never talking about the

00:15:00,180 --> 00:15:04,079
build itself or pre-built step that's a

00:15:02,939 --> 00:15:06,589
minor thing I'm talking about

00:15:04,079 --> 00:15:09,329
forward-looking features like modules or

00:15:06,589 --> 00:15:11,399
distributed compilation meta build

00:15:09,329 --> 00:15:14,069
system might not be able to support it

00:15:11,399 --> 00:15:16,829
or might take longer to make it

00:15:14,069 --> 00:15:19,220
available to its users which won't be

00:15:16,829 --> 00:15:21,569
able to take advantage of that benefit

00:15:19,220 --> 00:15:23,639
extensibility again you are in a

00:15:21,569 --> 00:15:26,430
straightjacket you can only use the

00:15:23,639 --> 00:15:30,360
lowest common denominator so it's hard

00:15:26,430 --> 00:15:32,579
to extend it with anything robustness

00:15:30,360 --> 00:15:33,690
also suffer because we now have more

00:15:32,579 --> 00:15:36,630
moving parts

00:15:33,690 --> 00:15:40,200
and underlying build systems that we

00:15:36,630 --> 00:15:42,950
need to support tests and so on the only

00:15:40,200 --> 00:15:45,690
major issue of a native build system is

00:15:42,950 --> 00:15:48,120
compatibility as I mentioned so we have

00:15:45,690 --> 00:15:50,550
a an IDE that we want to generate a

00:15:48,120 --> 00:15:53,100
project so that would be problematic but

00:15:50,550 --> 00:15:54,900
yeah in a sane world I would say it

00:15:53,100 --> 00:15:57,090
would be and not the other way around

00:15:54,900 --> 00:16:01,590
and an idea would use the build system

00:15:57,090 --> 00:16:04,260
to build things which sounds sane to me

00:16:01,590 --> 00:16:06,210
and it is actually movement in the

00:16:04,260 --> 00:16:08,910
direction visuals to you for example

00:16:06,210 --> 00:16:11,880
provides open folder functionality for

00:16:08,910 --> 00:16:18,980
this kind of integration just some

00:16:11,880 --> 00:16:22,770
issues so my personal thinking is that

00:16:18,980 --> 00:16:24,630
for a C++ community to standardize on a

00:16:22,770 --> 00:16:33,440
meta build system would be a fundamental

00:16:24,630 --> 00:16:36,120
mistake okay moving on black box or a

00:16:33,440 --> 00:16:37,980
concept of build or a conceptual model

00:16:36,120 --> 00:16:40,530
of build so just to illustrate what I

00:16:37,980 --> 00:16:42,420
mean there are two examples one is a

00:16:40,530 --> 00:16:44,550
make file that tries to build a portable

00:16:42,420 --> 00:16:47,280
hello world program and the other one is

00:16:44,550 --> 00:16:49,710
a Simic right so if you're not familiar

00:16:47,280 --> 00:16:51,480
with make language the make file

00:16:49,710 --> 00:16:53,340
probably looks to you like like line

00:16:51,480 --> 00:16:56,640
noise right it's it's basically

00:16:53,340 --> 00:16:59,070
gibberish but if you actually read the

00:16:56,640 --> 00:17:03,090
manual you we will start understand

00:16:59,070 --> 00:17:05,370
underlying concepts that that in what's

00:17:03,090 --> 00:17:07,140
going on the model how things are built

00:17:05,370 --> 00:17:08,280
so on the first line on the Left we have

00:17:07,140 --> 00:17:10,829
a target on the right we have

00:17:08,280 --> 00:17:13,410
prerequisites next line is a rule that

00:17:10,829 --> 00:17:15,660
that specifies how these things are

00:17:13,410 --> 00:17:17,339
built then the last two lines is

00:17:15,660 --> 00:17:19,949
actually a pattern rule which is kind of

00:17:17,339 --> 00:17:23,990
similar to C++ templates which can be

00:17:19,949 --> 00:17:26,130
used to build several targets so that's

00:17:23,990 --> 00:17:28,410
the idea here is that there is actually

00:17:26,130 --> 00:17:31,200
a model underneath that you can

00:17:28,410 --> 00:17:34,140
understand and you can adjust and use to

00:17:31,200 --> 00:17:37,650
customize things well contrasted to see

00:17:34,140 --> 00:17:39,990
make so this how you would build a Hello

00:17:37,650 --> 00:17:42,630
example I personally don't know what is

00:17:39,990 --> 00:17:43,760
add executable doesn't even know is the

00:17:42,630 --> 00:17:49,250
function is the match

00:17:43,760 --> 00:17:51,350
crow anyone knows also there is a space

00:17:49,250 --> 00:17:53,630
after project but not after add

00:17:51,350 --> 00:17:56,630
executable I've saw I saw three

00:17:53,630 --> 00:18:00,650
tutorials including the one on the sea

00:17:56,630 --> 00:18:01,760
my official site and they all have this

00:18:00,650 --> 00:18:06,290
difference I don't know is it

00:18:01,760 --> 00:18:09,010
significant so I think this illustrates

00:18:06,290 --> 00:18:11,060
the difference between a black box and a

00:18:09,010 --> 00:18:12,440
conceptual model of build so you see

00:18:11,060 --> 00:18:14,060
Mike you have this something and

00:18:12,440 --> 00:18:16,310
executable you don't even know what it

00:18:14,060 --> 00:18:17,810
is and the documentation is written in a

00:18:16,310 --> 00:18:20,210
sense you know if you want an executable

00:18:17,810 --> 00:18:22,780
put this thingy there and those things

00:18:20,210 --> 00:18:27,140
there and it will happen

00:18:22,780 --> 00:18:29,690
okay so there's some analysis against

00:18:27,140 --> 00:18:31,730
our values the major issue with black

00:18:29,690 --> 00:18:33,710
box is extensibility right if you need

00:18:31,730 --> 00:18:36,230
another as something to do something

00:18:33,710 --> 00:18:39,170
different or completely different the

00:18:36,230 --> 00:18:41,180
only option is to create another black

00:18:39,170 --> 00:18:42,620
box right you cannot see inside you

00:18:41,180 --> 00:18:47,480
cannot understand how things are done

00:18:42,620 --> 00:18:49,670
the problem with a conceptual model of

00:18:47,480 --> 00:18:52,040
built is approachability right if you

00:18:49,670 --> 00:18:53,870
look at this make file its not very

00:18:52,040 --> 00:18:55,430
approachable but it actually doesn't

00:18:53,870 --> 00:18:57,760
have to be it's not a fundamental

00:18:55,430 --> 00:19:01,010
property and how hopefully I'll show you

00:18:57,760 --> 00:19:05,120
that it that it can can actually make

00:19:01,010 --> 00:19:06,980
sense okay so yeah I think it's also

00:19:05,120 --> 00:19:10,600
pretty clear we need a conceptual model

00:19:06,980 --> 00:19:13,870
I don't think this is very controversial

00:19:10,600 --> 00:19:17,780
if we want an extensible build system

00:19:13,870 --> 00:19:21,950
okay implementation language another egg

00:19:17,780 --> 00:19:24,800
throwing potentially question so the

00:19:21,950 --> 00:19:27,620
question is can we afford to heat

00:19:24,800 --> 00:19:32,740
ourselves to another system might be the

00:19:27,620 --> 00:19:35,660
Python or Java or some other language

00:19:32,740 --> 00:19:38,600
when I ask other developers that choose

00:19:35,660 --> 00:19:40,490
other languages than C++ why they went

00:19:38,600 --> 00:19:42,440
this way the answer is usually you need

00:19:40,490 --> 00:19:45,140
you have to use the right tool for the

00:19:42,440 --> 00:19:47,590
job which which suggests that C++ is

00:19:45,140 --> 00:19:50,600
somehow inadequate for the job right I

00:19:47,590 --> 00:19:53,240
don't know in case of build 2 for us it

00:19:50,600 --> 00:19:54,110
wasn't even a debate or a question which

00:19:53,240 --> 00:19:55,970
language

00:19:54,110 --> 00:19:57,440
use but looking back that was probably

00:19:55,970 --> 00:20:00,320
one of the best decisions we've made

00:19:57,440 --> 00:20:02,809
because nothing gives you as good of a

00:20:00,320 --> 00:20:04,429
reality check as using your own build

00:20:02,809 --> 00:20:06,860
system for build for everyday

00:20:04,429 --> 00:20:09,920
development which actually brings an

00:20:06,860 --> 00:20:12,520
interesting aspect to this question I

00:20:09,920 --> 00:20:15,110
don't think anyone will argue that

00:20:12,520 --> 00:20:19,220
developing a build a general build

00:20:15,110 --> 00:20:21,860
system is a multi-year full-time job so

00:20:19,220 --> 00:20:23,690
it's a full-time project so if you say

00:20:21,860 --> 00:20:25,309
using Python a Java for it you're

00:20:23,690 --> 00:20:27,890
actually a full-time Python a Java

00:20:25,309 --> 00:20:31,160
derail actually not using C++ yourself

00:20:27,890 --> 00:20:33,440
for anything real world and in this

00:20:31,160 --> 00:20:40,280
position actually deciding how things

00:20:33,440 --> 00:20:43,010
should be built for C++ okay so back to

00:20:40,280 --> 00:20:46,280
our values yeah we have a little bit of

00:20:43,010 --> 00:20:49,760
a bloodbath on the left so I've chosen

00:20:46,280 --> 00:20:52,669
Java and Python as examples the most

00:20:49,760 --> 00:20:54,530
common choices again performance suffers

00:20:52,669 --> 00:20:56,809
extensibility suffers and by

00:20:54,530 --> 00:20:59,929
extensibility I mean what what I mean

00:20:56,809 --> 00:21:02,360
here is that as a C++ developer I don't

00:20:59,929 --> 00:21:04,190
necessarily know the language that

00:21:02,360 --> 00:21:06,320
you've selected for your implementation

00:21:04,190 --> 00:21:08,360
I don't want to use it this is also

00:21:06,320 --> 00:21:10,880
portability right we are depending on

00:21:08,360 --> 00:21:12,530
other things there is a Barra bus'ness

00:21:10,880 --> 00:21:15,260
again more moving parts and

00:21:12,530 --> 00:21:20,120
approachability again the same issue

00:21:15,260 --> 00:21:24,669
that as a C++ developer item is in oil

00:21:20,120 --> 00:21:27,919
language now naturally doing it in C++

00:21:24,669 --> 00:21:35,240
doesn't really conflict with any our

00:21:27,919 --> 00:21:37,820
values okay next question should our

00:21:35,240 --> 00:21:41,120
build definition language be declarative

00:21:37,820 --> 00:21:45,169
or scripted and I personally believe

00:21:41,120 --> 00:21:47,320
that the complexity and the importance

00:21:45,169 --> 00:21:51,410
of the problem actually warrants a

00:21:47,320 --> 00:21:53,780
custom-built language so let's let's

00:21:51,410 --> 00:21:55,970
analyze it using our values so on the

00:21:53,780 --> 00:21:58,669
Left we have scripted performance will

00:21:55,970 --> 00:21:59,240
probably suffer expressiveness will also

00:21:58,669 --> 00:22:01,640
suffer

00:21:59,240 --> 00:22:03,860
you'll probably wrap your scripting

00:22:01,640 --> 00:22:04,770
language in some kind of dsl but still

00:22:03,860 --> 00:22:06,930
not gonna match

00:22:04,770 --> 00:22:10,020
what can be done with a custom language

00:22:06,930 --> 00:22:11,580
we also have issue with portability and

00:22:10,020 --> 00:22:14,070
depending on another system and

00:22:11,580 --> 00:22:16,920
approachability the same issue I don't I

00:22:14,070 --> 00:22:19,220
might not know your scripting language

00:22:16,920 --> 00:22:22,730
the problem with declarative approach

00:22:19,220 --> 00:22:26,700
extensibility and it's actually a pretty

00:22:22,730 --> 00:22:29,210
bad problem right it's pretty this value

00:22:26,700 --> 00:22:32,490
is pretty high on our list and it's also

00:22:29,210 --> 00:22:35,760
you know affected severely so perhaps it

00:22:32,490 --> 00:22:38,760
actually makes it it's worth trying to

00:22:35,760 --> 00:22:41,370
fix that and perhaps what we can do is

00:22:38,760 --> 00:22:45,240
as a hybrid mostly declarative language

00:22:41,370 --> 00:22:48,480
this is what we've done in build 2 so it

00:22:45,240 --> 00:22:51,180
is declarative it kind of looks similar

00:22:48,480 --> 00:22:52,740
in a sense to make so you know you have

00:22:51,180 --> 00:22:55,440
declarations this is a target is

00:22:52,740 --> 00:22:57,870
prerequisite those have variables type

00:22:55,440 --> 00:23:00,600
we have pure functions and by pure I

00:22:57,870 --> 00:23:03,180
mean they they cannot modify the build

00:23:00,600 --> 00:23:04,890
state you know again Rodrigues analyze

00:23:03,180 --> 00:23:07,050
chop values and so on but you cannot

00:23:04,890 --> 00:23:09,660
actually enter new new targets

00:23:07,050 --> 00:23:12,500
programmatically we also have exclusions

00:23:09,660 --> 00:23:14,880
if-else note that I phrase it as

00:23:12,500 --> 00:23:16,920
exclusion or inclusion of a build file

00:23:14,880 --> 00:23:18,170
fragment rather than control flow so

00:23:16,920 --> 00:23:21,690
it's still not a programming language

00:23:18,170 --> 00:23:24,960
was have repetitions a for loop again

00:23:21,690 --> 00:23:27,780
you can repeat a fragment of the build

00:23:24,960 --> 00:23:30,450
file several times for substituted with

00:23:27,780 --> 00:23:33,630
different values and so on and the

00:23:30,450 --> 00:23:39,200
extension is done by providing custom

00:23:33,630 --> 00:23:42,300
functions and custom rules also in C++

00:23:39,200 --> 00:23:42,660
so I think this is the probably the way

00:23:42,300 --> 00:23:46,260
to go

00:23:42,660 --> 00:23:48,540
I think declarative language is as a

00:23:46,260 --> 00:23:54,390
major benefit but we can argument it a

00:23:48,540 --> 00:23:57,720
bit with some nice things to to make it

00:23:54,390 --> 00:24:00,800
more expressive and extensible all right

00:23:57,720 --> 00:24:04,350
so this is the then the summary of our

00:24:00,800 --> 00:24:06,270
high-level overview so the next

00:24:04,350 --> 00:24:08,940
generation build system is native build

00:24:06,270 --> 00:24:11,580
system with a conceptual model of built

00:24:08,940 --> 00:24:14,610
it succeeds implemented and is

00:24:11,580 --> 00:24:18,250
extensible in C++ and there's a mostly

00:24:14,610 --> 00:24:22,130
declarative type save build land

00:24:18,250 --> 00:24:25,130
I'll also add that it probably should be

00:24:22,130 --> 00:24:27,590
part of the larger build tool chain that

00:24:25,130 --> 00:24:29,929
includes dependency management and it

00:24:27,590 --> 00:24:33,409
should be a libraries to ease

00:24:29,929 --> 00:24:36,830
integration with ideas and tools so that

00:24:33,409 --> 00:24:39,320
would be my scorecard for a build system

00:24:36,830 --> 00:24:42,110
so if I were choosing a build system for

00:24:39,320 --> 00:24:50,210
my next project I would try to see how

00:24:42,110 --> 00:24:51,740
it matches this point just for interest

00:24:50,210 --> 00:24:54,950
sake this is the first paragraph from

00:24:51,740 --> 00:24:57,140
the build to build system manual I'm

00:24:54,950 --> 00:24:59,120
gonna read it till - is a native

00:24:57,140 --> 00:25:01,309
cross-platform build system with a terse

00:24:59,120 --> 00:25:03,470
mostly declarative description language

00:25:01,309 --> 00:25:05,690
a conceptual model of built and a

00:25:03,470 --> 00:25:07,789
uniform interface with consistent

00:25:05,690 --> 00:25:10,039
behavior across platforms and compilers

00:25:07,789 --> 00:25:12,260
build - is an honest build system

00:25:10,039 --> 00:25:13,970
without magical black boxes you can

00:25:12,260 --> 00:25:16,669
expect to understand what's going on

00:25:13,970 --> 00:25:19,210
underneath and be able to customize most

00:25:16,669 --> 00:25:22,880
of its behavior to suit your needs

00:25:19,210 --> 00:25:25,070
also for completeness this is our make

00:25:22,880 --> 00:25:27,620
file and C make example so at the bottom

00:25:25,070 --> 00:25:29,929
I have built through example fact if you

00:25:27,620 --> 00:25:31,970
look at it for the first time you'll

00:25:29,929 --> 00:25:35,120
probably say it's exactly the same as

00:25:31,970 --> 00:25:37,789
seaming right at least a lot closer to

00:25:35,120 --> 00:25:39,470
see Megan and make file in fact again if

00:25:37,789 --> 00:25:41,600
you understand the underlying model it's

00:25:39,470 --> 00:25:45,110
actually a lot closer to make file and C

00:25:41,600 --> 00:25:46,850
make so we just have a declaration here

00:25:45,110 --> 00:25:49,850
with all the implementation details

00:25:46,850 --> 00:25:51,679
actually handled by default routes so on

00:25:49,850 --> 00:25:55,179
the Left we can have a target on the

00:25:51,679 --> 00:25:58,700
right we have a prerequisite and so on

00:25:55,179 --> 00:26:01,159
okay so and I think this highlights the

00:25:58,700 --> 00:26:03,320
that issue with approachability doesn't

00:26:01,159 --> 00:26:05,600
actually have to be unapproachable I

00:26:03,320 --> 00:26:07,580
think this is pretty fairly clear what's

00:26:05,600 --> 00:26:12,590
going on here even if you haven't read

00:26:07,580 --> 00:26:15,350
any documentation okay so the the second

00:26:12,590 --> 00:26:19,010
half of my talk will be about major

00:26:15,350 --> 00:26:20,870
features that we should demand or expect

00:26:19,010 --> 00:26:23,659
from a next-generation adult system I'll

00:26:20,870 --> 00:26:26,299
quickly go over some that that most

00:26:23,659 --> 00:26:29,090
modern build system already have just

00:26:26,299 --> 00:26:31,460
for completeness and very briefly

00:26:29,090 --> 00:26:34,820
I think by now everyone agreed we need

00:26:31,460 --> 00:26:37,970
out and insource builds we act I think

00:26:34,820 --> 00:26:39,320
we need both sometimes you know most of

00:26:37,970 --> 00:26:42,230
the time you'll probably for development

00:26:39,320 --> 00:26:45,230
you will have multiple out of source

00:26:42,230 --> 00:26:46,700
builds but it's they're all situations

00:26:45,230 --> 00:26:48,230
where you want to build in source way

00:26:46,700 --> 00:26:50,030
for example you just want to build

00:26:48,230 --> 00:26:52,390
someone's package and just mock on me

00:26:50,030 --> 00:26:54,770
and to do that

00:26:52,390 --> 00:26:58,250
wildcard patterns this somewhat

00:26:54,770 --> 00:27:00,440
controversial topic and I personally was

00:26:58,250 --> 00:27:03,230
also skeptical before we added to build

00:27:00,440 --> 00:27:06,590
two and converted all our projects but

00:27:03,230 --> 00:27:08,750
yeah now I'm also converted the nice

00:27:06,590 --> 00:27:10,880
thing about wildcards is that I hardly

00:27:08,750 --> 00:27:15,010
ever need to touch my build files

00:27:10,880 --> 00:27:17,600
anymore and problem with wildcards that

00:27:15,010 --> 00:27:20,560
is usually brought up or the major issue

00:27:17,600 --> 00:27:23,390
is that you know you can pick up some

00:27:20,560 --> 00:27:25,400
stray files that happen to be in your

00:27:23,390 --> 00:27:27,860
source directory and so on I personally

00:27:25,400 --> 00:27:29,570
never ran into it maybe because I use

00:27:27,860 --> 00:27:32,210
version control system so for me a

00:27:29,570 --> 00:27:35,930
straight file will be immediately shown

00:27:32,210 --> 00:27:38,510
by the next run of get stat so but I

00:27:35,930 --> 00:27:40,520
think I think it's important to to give

00:27:38,510 --> 00:27:43,010
full control so in case of build to e

00:27:40,520 --> 00:27:45,170
you can do it either way so you can use

00:27:43,010 --> 00:27:49,130
wild card so you can spell your source

00:27:45,170 --> 00:27:50,990
files exactly but I think wild cards

00:27:49,130 --> 00:27:54,470
actually pretty nice makes the

00:27:50,990 --> 00:27:56,420
development workflow much smoother this

00:27:54,470 --> 00:27:58,460
is also allows us to approximate this

00:27:56,420 --> 00:28:00,800
build system list model for a simple

00:27:58,460 --> 00:28:02,870
project so if your source files are

00:28:00,800 --> 00:28:04,730
picked up by a wild card and provide you

00:28:02,870 --> 00:28:07,430
put them in the right place you know you

00:28:04,730 --> 00:28:09,830
can add remove them rename them and so

00:28:07,430 --> 00:28:11,600
on so this also works quite nice

00:28:09,830 --> 00:28:15,770
especially for someone who wants to

00:28:11,600 --> 00:28:17,960
start using the tool chain without

00:28:15,770 --> 00:28:22,280
reading too much documentation up front

00:28:17,960 --> 00:28:23,990
okay cross compilation shouldn't really

00:28:22,280 --> 00:28:25,850
need to mention it but some build

00:28:23,990 --> 00:28:27,590
systems still cannot get it right so it

00:28:25,850 --> 00:28:29,750
should be a norm and not an afterthought

00:28:27,590 --> 00:28:32,270
once you actually have a build system

00:28:29,750 --> 00:28:34,010
that has it done reliably and properly

00:28:32,270 --> 00:28:36,650
the next natural thing you want to do is

00:28:34,010 --> 00:28:39,710
cross testing right you want to run the

00:28:36,650 --> 00:28:42,070
the test for that for what you cross

00:28:39,710 --> 00:28:43,720
compile for and it's actually possible

00:28:42,070 --> 00:28:46,420
the probably the best example is running

00:28:43,720 --> 00:28:48,850
tests under wine emulation so we do it a

00:28:46,420 --> 00:28:51,870
lot and when coined the term cross

00:28:48,850 --> 00:28:54,760
testing very handy so I for example can

00:28:51,870 --> 00:28:59,200
run tests for windows on my linux

00:28:54,760 --> 00:29:01,390
machine modern build systems also really

00:28:59,200 --> 00:29:05,280
need to support just building there are

00:29:01,390 --> 00:29:08,530
other operations this test installation

00:29:05,280 --> 00:29:12,250
preparation of distributions it's also

00:29:08,530 --> 00:29:14,290
would be nice if configuration

00:29:12,250 --> 00:29:17,800
management was integrated into a build

00:29:14,290 --> 00:29:21,790
system and this is a good example when

00:29:17,800 --> 00:29:24,640
when you actually get get the design or

00:29:21,790 --> 00:29:27,220
the underlying model right then you you

00:29:24,640 --> 00:29:29,200
end up with some nice features popping

00:29:27,220 --> 00:29:31,150
out that you didn't even expect haven't

00:29:29,200 --> 00:29:33,730
even thought about so just to give you

00:29:31,150 --> 00:29:36,250
an example that we found in case of

00:29:33,730 --> 00:29:37,240
build two so I have a little Hollow

00:29:36,250 --> 00:29:38,590
example here

00:29:37,240 --> 00:29:42,090
nothing interesting so I'm gonna

00:29:38,590 --> 00:29:45,810
configure to use clang with optimization

00:29:42,090 --> 00:29:48,670
so this is how you do it in build to

00:29:45,810 --> 00:29:51,460
gonna run the build system let me use

00:29:48,670 --> 00:29:54,250
clang as you can see and with

00:29:51,460 --> 00:29:56,470
optimization right let's say I made some

00:29:54,250 --> 00:29:58,210
change and now I want I'm not sure what

00:29:56,470 --> 00:30:00,760
the GC is gonna be happy with it

00:29:58,210 --> 00:30:03,640
so I want to quickly read the test is

00:30:00,760 --> 00:30:06,400
just with GCC for just one around of the

00:30:03,640 --> 00:30:10,030
build system it'd be a pain if I had to

00:30:06,400 --> 00:30:11,800
actually go and do it manually or create

00:30:10,030 --> 00:30:15,420
a separate build configuration I just

00:30:11,800 --> 00:30:18,420
want to quickly test it so if your

00:30:15,420 --> 00:30:20,800
configuration and actual build system

00:30:18,420 --> 00:30:22,990
separate that's those are the only

00:30:20,800 --> 00:30:24,850
choices are you even to configure all

00:30:22,990 --> 00:30:26,530
you need to create a new one if they

00:30:24,850 --> 00:30:28,360
integrate that well in case of build two

00:30:26,530 --> 00:30:31,300
at least you can just override it for a

00:30:28,360 --> 00:30:34,660
build system and weication that's okay

00:30:31,300 --> 00:30:37,590
I'm gonna change it to GCC let's build a

00:30:34,660 --> 00:30:37,590
debug also

00:30:39,070 --> 00:30:46,810
these are GCC and is our debug so the

00:30:45,010 --> 00:30:49,630
cool thing is now if I remove those

00:30:46,810 --> 00:30:51,580
overrides right so okay test GC works

00:30:49,630 --> 00:30:53,800
great you know I want to go back to

00:30:51,580 --> 00:30:57,970
claim all I need to do is just remove

00:30:53,800 --> 00:31:00,010
the overrides and rebuilds that claim so

00:30:57,970 --> 00:31:02,500
this is a good example of once you get

00:31:00,010 --> 00:31:08,770
things right you know interesting things

00:31:02,500 --> 00:31:11,370
happen okay so now moving to the fun

00:31:08,770 --> 00:31:14,710
part next generation functionality I

00:31:11,370 --> 00:31:16,660
think most existing build systems really

00:31:14,710 --> 00:31:18,970
done handle project composition very

00:31:16,660 --> 00:31:20,740
well just to give an example itself to

00:31:18,970 --> 00:31:22,900
independent projects I have a library

00:31:20,740 --> 00:31:25,000
and I'm an executable that I want to use

00:31:22,900 --> 00:31:26,440
it in and then they are separate you

00:31:25,000 --> 00:31:28,930
know I don't want necessary to be tear

00:31:26,440 --> 00:31:31,120
and bundled that independent potential

00:31:28,930 --> 00:31:32,860
independently developed maybe I clone

00:31:31,120 --> 00:31:35,380
someone projects from github

00:31:32,860 --> 00:31:37,660
so there's several scenarios or setups

00:31:35,380 --> 00:31:40,090
in which are I might want to use it so

00:31:37,660 --> 00:31:41,940
they can be just completely independent

00:31:40,090 --> 00:31:44,830
projects so it would be nice if I could

00:31:41,940 --> 00:31:46,450
import a target from one project in

00:31:44,830 --> 00:31:48,520
another like for example a library that

00:31:46,450 --> 00:31:50,770
I can just link and that things

00:31:48,520 --> 00:31:52,510
automatically build an update when I

00:31:50,770 --> 00:31:55,420
when I actually want to use that library

00:31:52,510 --> 00:31:57,490
so that's one scenario I might also want

00:31:55,420 --> 00:31:59,650
to drop this library copy this library

00:31:57,490 --> 00:32:02,890
into my project so that you know I

00:31:59,650 --> 00:32:04,810
create a dependency free bundle so this

00:32:02,890 --> 00:32:07,210
is also useful not always recommended

00:32:04,810 --> 00:32:10,120
but a useful technique so it would be

00:32:07,210 --> 00:32:11,920
nice that it used the same mechanism as

00:32:10,120 --> 00:32:14,440
when I had the project's completely

00:32:11,920 --> 00:32:16,540
independent and the third scenario is

00:32:14,440 --> 00:32:18,790
when you want to consume an installed

00:32:16,540 --> 00:32:21,370
library write potentially built by

00:32:18,790 --> 00:32:23,980
different build system so again in this

00:32:21,370 --> 00:32:26,320
in this case it would be nice that this

00:32:23,980 --> 00:32:28,810
the all these three scenarios actually

00:32:26,320 --> 00:32:30,730
handled by the same mechanism that's how

00:32:28,810 --> 00:32:36,730
we've done it in build two and I think

00:32:30,730 --> 00:32:41,230
it works it is the way to go okay I also

00:32:36,730 --> 00:32:44,370
think testing needs some addressing if

00:32:41,230 --> 00:32:46,990
you look for example at LLVM and clang

00:32:44,370 --> 00:32:50,020
projects it's quite an interesting

00:32:46,990 --> 00:32:52,950
example they both came up they both have

00:32:50,020 --> 00:32:55,409
a taste testing

00:32:52,950 --> 00:32:57,480
a scripting language for tests for

00:32:55,409 --> 00:32:59,610
running tests like running compiler and

00:32:57,480 --> 00:33:02,039
some input analyzing output they look

00:32:59,610 --> 00:33:04,049
nothing like each other completely

00:33:02,039 --> 00:33:08,490
different ideas but they they have

00:33:04,049 --> 00:33:11,909
essentially the same the same purpose so

00:33:08,490 --> 00:33:15,090
I think this is this handle underlines a

00:33:11,909 --> 00:33:17,940
common need of a land of a portable

00:33:15,090 --> 00:33:20,730
language for concise test description

00:33:17,940 --> 00:33:23,159
that allows you to supply input to your

00:33:20,730 --> 00:33:25,950
tests in analyze output using regular

00:33:23,159 --> 00:33:28,409
expressions and so on so in build two we

00:33:25,950 --> 00:33:33,630
came up with such a language we call the

00:33:28,409 --> 00:33:36,330
test script it's also optimized for

00:33:33,630 --> 00:33:38,669
parallel execution of tests in the same

00:33:36,330 --> 00:33:42,330
file so you will have a file let's say

00:33:38,669 --> 00:33:45,690
with 20 different test cases and it will

00:33:42,330 --> 00:33:48,149
execute them all in parallel once you

00:33:45,690 --> 00:33:50,820
get that the next natural thing is

00:33:48,149 --> 00:33:52,529
incremental testing we already haven't

00:33:50,820 --> 00:33:55,500
incremental builds incremental

00:33:52,529 --> 00:33:57,029
compilation so if you changed one file

00:33:55,500 --> 00:33:59,789
in your project and you know it took a

00:33:57,029 --> 00:34:02,130
second to cut to update to rebuild but

00:33:59,789 --> 00:34:05,909
then it takes ten minutes to run the

00:34:02,130 --> 00:34:08,879
tests it's not you know use right took

00:34:05,909 --> 00:34:12,000
only one second to rebuild so it would

00:34:08,879 --> 00:34:15,000
be nice to also have incremental testing

00:34:12,000 --> 00:34:17,879
right both basically execute tests that

00:34:15,000 --> 00:34:19,619
we actually only affect only execute

00:34:17,879 --> 00:34:22,500
tests that were affected by the change

00:34:19,619 --> 00:34:24,389
that you've made and this is actually

00:34:22,500 --> 00:34:30,560
tricky but I think that that's something

00:34:24,389 --> 00:34:34,619
we also need to address ok next point is

00:34:30,560 --> 00:34:38,669
high fidelity hermetic builds so the

00:34:34,619 --> 00:34:41,030
idea here is that a change to a source

00:34:38,669 --> 00:34:44,399
file section on a small part of what can

00:34:41,030 --> 00:34:45,929
affect the end result the object file

00:34:44,399 --> 00:34:49,560
for example other things like

00:34:45,929 --> 00:34:54,240
environment tools options and even

00:34:49,560 --> 00:34:56,339
source code sets can all affect your the

00:34:54,240 --> 00:35:00,869
end result and this is this is actually

00:34:56,339 --> 00:35:03,420
an important an important aspect to get

00:35:00,869 --> 00:35:05,099
right first because it's it effects

00:35:03,420 --> 00:35:06,500
trust in the build system if you don't

00:35:05,099 --> 00:35:08,180
trust your build system

00:35:06,500 --> 00:35:10,220
you know if you think I'd say that

00:35:08,180 --> 00:35:11,960
everything is up to date but just to be

00:35:10,220 --> 00:35:13,550
sure I'm gonna clean everything and

00:35:11,960 --> 00:35:15,290
rebuild from scratch because I don't

00:35:13,550 --> 00:35:18,740
quite trust it if you lose that trust

00:35:15,290 --> 00:35:22,720
sexually very hard to regain so this is

00:35:18,740 --> 00:35:25,490
something that needs to be done properly

00:35:22,720 --> 00:35:27,710
from the get-go and actually that

00:35:25,490 --> 00:35:29,870
example that I showed you where we once

00:35:27,710 --> 00:35:32,300
I removed the override and things got

00:35:29,870 --> 00:35:35,450
rebuilt again but clang that relied on

00:35:32,300 --> 00:35:37,160
the fact that built - detected that I've

00:35:35,450 --> 00:35:39,110
changed the compiler and I changed the

00:35:37,160 --> 00:35:46,400
options and automatically rebuild

00:35:39,110 --> 00:35:48,860
everything okay a somewhat related area

00:35:46,400 --> 00:35:51,320
to the previous one is more precise

00:35:48,860 --> 00:35:53,480
change detection quite a few build

00:35:51,320 --> 00:35:55,160
systems already don't just use time

00:35:53,480 --> 00:35:58,160
stamps to detect changes they for

00:35:55,160 --> 00:36:01,220
example hash your translation units your

00:35:58,160 --> 00:36:03,320
inputs and if the hashes English hasn't

00:36:01,220 --> 00:36:05,390
changed and they skip building things

00:36:03,320 --> 00:36:07,040
this helps for example with switching

00:36:05,390 --> 00:36:12,260
branches and so on but we can actually

00:36:07,040 --> 00:36:14,510
go a step further and ignore more things

00:36:12,260 --> 00:36:16,850
like for example whitespace only changes

00:36:14,510 --> 00:36:22,130
or changes to comments and so on again

00:36:16,850 --> 00:36:27,860
just to show you an example again I'm in

00:36:22,130 --> 00:36:36,290
my hello program so I'm gonna go and

00:36:27,860 --> 00:36:39,470
just add a comment Clemence actually

00:36:36,290 --> 00:36:41,780
changes anything semantically right so

00:36:39,470 --> 00:36:45,050
if I run the build system it actually

00:36:41,780 --> 00:36:46,850
detects that nothing changed and keeps

00:36:45,050 --> 00:36:51,160
updating the target so I'll explain how

00:36:46,850 --> 00:36:51,160
this is actually done in a few minutes

00:36:53,910 --> 00:37:03,359
okay fun part right C++ modules so the

00:36:59,220 --> 00:37:06,420
two major challenges in supporting

00:37:03,359 --> 00:37:09,089
modules appears to be discovering the

00:37:06,420 --> 00:37:11,849
set of modules a translation unit

00:37:09,089 --> 00:37:14,910
actually needs as well as mapping them

00:37:11,849 --> 00:37:17,700
to file names the first one is actually

00:37:14,910 --> 00:37:19,530
a really hard problem the second one is

00:37:17,700 --> 00:37:21,660
actually not that difficult note is why

00:37:19,530 --> 00:37:24,030
there is so much noise about it but for

00:37:21,660 --> 00:37:26,190
some reason yeah people like to complain

00:37:24,030 --> 00:37:31,049
about that the first one is a real

00:37:26,190 --> 00:37:33,150
killer actually so we kind of have a

00:37:31,049 --> 00:37:37,380
chicken-and-egg problem it is getting

00:37:33,150 --> 00:37:38,400
better but recently but until now that's

00:37:37,380 --> 00:37:40,799
been this way

00:37:38,400 --> 00:37:43,980
so the build system vendors look at

00:37:40,799 --> 00:37:45,480
modules in there also so complicated I

00:37:43,980 --> 00:37:47,099
have no idea so I'll just wait for the

00:37:45,480 --> 00:37:49,049
compiler vendors and the Standards

00:37:47,099 --> 00:37:50,880
Committee to sort it out and the

00:37:49,049 --> 00:37:53,490
compiler vendors and standards committee

00:37:50,880 --> 00:37:56,970
they just wait for the build systems to

00:37:53,490 --> 00:37:58,500
tell you know what what we need so it's

00:37:56,970 --> 00:38:00,500
actually important for build system

00:37:58,500 --> 00:38:03,119
vendors to start looking into it and

00:38:00,500 --> 00:38:05,010
provide feedback to the Standards

00:38:03,119 --> 00:38:06,930
Committee and the compiler vendors and

00:38:05,010 --> 00:38:10,140
the best way to do it I think is by

00:38:06,930 --> 00:38:11,849
submitting papers to for the Standards

00:38:10,140 --> 00:38:15,869
Committee so there's some links to some

00:38:11,849 --> 00:38:18,839
of the relevant papers this also I gave

00:38:15,869 --> 00:38:21,539
a talk last year about building C++

00:38:18,839 --> 00:38:23,160
modules and also Nathan's talk yesterday

00:38:21,539 --> 00:38:26,250
is very good if you want to understand

00:38:23,160 --> 00:38:31,770
how things changed and what is the

00:38:26,250 --> 00:38:34,109
current state of things distribute

00:38:31,770 --> 00:38:36,029
compilation and caching again as I

00:38:34,109 --> 00:38:38,730
mentioned earlier I don't think it is

00:38:36,029 --> 00:38:40,980
going I think we've reached the point

00:38:38,730 --> 00:38:42,960
where we needed to be part of the build

00:38:40,980 --> 00:38:46,319
system and it should be reliable and

00:38:42,960 --> 00:38:49,140
generally available mechanism right we

00:38:46,319 --> 00:38:53,250
don't want to have wrappers in a highly

00:38:49,140 --> 00:38:58,020
controlled environment and so on which

00:38:53,250 --> 00:39:01,529
brings us to the way we build C++ so if

00:38:58,020 --> 00:39:03,630
you look at this item so we have C++

00:39:01,529 --> 00:39:05,819
modules auto-generated here there's

00:39:03,630 --> 00:39:06,840
stability compilation and ignore about

00:39:05,819 --> 00:39:09,660
change detection

00:39:06,840 --> 00:39:11,070
what they have in common is that most

00:39:09,660 --> 00:39:13,770
existing build systems don't support

00:39:11,070 --> 00:39:17,910
them and it will be really difficult to

00:39:13,770 --> 00:39:20,100
do and to understand why we we need to

00:39:17,910 --> 00:39:23,130
look at how we build things currently

00:39:20,100 --> 00:39:25,830
and how it needs to change so this is a

00:39:23,130 --> 00:39:27,840
current oh I'll call it an old model of

00:39:25,830 --> 00:39:31,590
building things so we have a source file

00:39:27,840 --> 00:39:35,070
and we compile it in an object file and

00:39:31,590 --> 00:39:38,040
as as a byproduct of this compilation we

00:39:35,070 --> 00:39:39,870
end up with a here the dependence

00:39:38,040 --> 00:39:44,460
equation a list of headers that this

00:39:39,870 --> 00:39:46,260
source file includes transitive so next

00:39:44,460 --> 00:39:48,660
time we need to decide whether they need

00:39:46,260 --> 00:39:50,790
to recompile anything we take this the

00:39:48,660 --> 00:39:54,270
source file as well as the extract here

00:39:50,790 --> 00:39:56,250
the dependencies and we make a decision

00:39:54,270 --> 00:39:58,260
if none of them changed we don't need to

00:39:56,250 --> 00:40:01,020
recompile otherwise we compile right

00:39:58,260 --> 00:40:05,010
this is how we this is how most build

00:40:01,020 --> 00:40:08,390
systems work these days and it's a light

00:40:05,010 --> 00:40:10,880
and a couple of clever observations but

00:40:08,390 --> 00:40:14,910
all of these points are actually

00:40:10,880 --> 00:40:17,550
affected by this model this model makes

00:40:14,910 --> 00:40:19,410
for example ham handling auto-generated

00:40:17,550 --> 00:40:21,690
source code painful and that's why most

00:40:19,410 --> 00:40:25,110
build system resort to some kind of

00:40:21,690 --> 00:40:29,100
pre-built steps so I believe we need to

00:40:25,110 --> 00:40:31,770
change that I think we need a new build

00:40:29,100 --> 00:40:34,290
model for C++ and I think it will look

00:40:31,770 --> 00:40:37,050
like this so we have the source file but

00:40:34,290 --> 00:40:39,410
instead of actually going straight to an

00:40:37,050 --> 00:40:43,440
object file we first going to partially

00:40:39,410 --> 00:40:45,150
pre-process it so I don't know if how

00:40:43,440 --> 00:40:48,030
many of you are familiar for example G

00:40:45,150 --> 00:40:49,550
support GCC and clang they have an

00:40:48,030 --> 00:40:52,230
option where you can partially

00:40:49,550 --> 00:40:54,510
pre-process a translation unit and what

00:40:52,230 --> 00:40:56,640
that does is essentially expands the

00:40:54,510 --> 00:41:00,810
include directives but does not expand

00:40:56,640 --> 00:41:02,760
the macros right so you had a file that

00:41:00,810 --> 00:41:05,670
had all this bunch of includes and now

00:41:02,760 --> 00:41:09,540
you have a file that is self-sufficient

00:41:05,670 --> 00:41:12,390
right it doesn't have any external

00:41:09,540 --> 00:41:15,240
references to any other hips so once

00:41:12,390 --> 00:41:17,130
we've got there so and also visual

00:41:15,240 --> 00:41:18,750
studio team is working on a new

00:41:17,130 --> 00:41:21,480
preprocessor and

00:41:18,750 --> 00:41:22,950
I've asked them many times to consider

00:41:21,480 --> 00:41:26,880
this feature so hopefully we'll have

00:41:22,950 --> 00:41:28,910
that in visuals two years now okay once

00:41:26,880 --> 00:41:32,010
we have this partially processed

00:41:28,910 --> 00:41:34,800
translation unit we reprocess it fully

00:41:32,010 --> 00:41:38,369
maybe in memory without actually storing

00:41:34,800 --> 00:41:41,580
anything on disk then we tokenize it you

00:41:38,369 --> 00:41:43,260
know using the c++ preprocessor rules

00:41:41,580 --> 00:41:48,000
which is actually not that difficult and

00:41:43,260 --> 00:41:50,130
then we shall up our set to module

00:41:48,000 --> 00:41:53,310
dependency information so we extract the

00:41:50,130 --> 00:41:55,380
imports and so yesterday the panel

00:41:53,310 --> 00:41:58,170
someone said to extract module

00:41:55,380 --> 00:42:01,950
dependencies you need to implement the

00:41:58,170 --> 00:42:04,830
C++ parser that is not the case it was

00:42:01,950 --> 00:42:07,470
not the case in case of module tears and

00:42:04,830 --> 00:42:10,859
it's even less of a case now with a

00:42:07,470 --> 00:42:12,750
payable and so on but all of this will

00:42:10,859 --> 00:42:16,859
actually be provided by the company most

00:42:12,750 --> 00:42:18,090
likely eventually so it's actually we've

00:42:16,859 --> 00:42:19,320
done it and it's actually not that

00:42:18,090 --> 00:42:21,420
difficult to do

00:42:19,320 --> 00:42:23,880
one interesting thing that you can also

00:42:21,420 --> 00:42:26,460
do while you once you've tokenize the

00:42:23,880 --> 00:42:28,380
input you can hash the tokens and maybe

00:42:26,460 --> 00:42:30,839
the allocation information and so on and

00:42:28,380 --> 00:42:33,450
produce a precise change detection

00:42:30,839 --> 00:42:36,150
checksum for your translation unit so

00:42:33,450 --> 00:42:38,280
that will all skip all the comments

00:42:36,150 --> 00:42:39,660
ignore all the white space changes and

00:42:38,280 --> 00:42:42,660
so on okay

00:42:39,660 --> 00:42:44,910
so now we take all this information here

00:42:42,660 --> 00:42:48,540
the dependencies module dependencies and

00:42:44,910 --> 00:42:51,869
a checksum and partially processed file

00:42:48,540 --> 00:42:54,450
and we make a decision wave whether we

00:42:51,869 --> 00:42:57,869
need to recompile and if so we go and

00:42:54,450 --> 00:43:01,050
compile the partially processed file

00:42:57,869 --> 00:43:03,330
into an object file I think you can all

00:43:01,050 --> 00:43:04,740
see how the distributed compilation will

00:43:03,330 --> 00:43:07,080
work in this case right

00:43:04,740 --> 00:43:09,510
instead of compiling it locally we just

00:43:07,080 --> 00:43:12,510
send this self-sufficient partially

00:43:09,510 --> 00:43:14,820
processed file in case of modules

00:43:12,510 --> 00:43:16,500
probably together with a BMIs that it

00:43:14,820 --> 00:43:19,140
needs them with a binary module

00:43:16,500 --> 00:43:22,140
interfaces to a remote machine where it

00:43:19,140 --> 00:43:29,130
gets compiled and it sends you back the

00:43:22,140 --> 00:43:32,430
object file now if you if you

00:43:29,130 --> 00:43:36,859
observe how this this this new model

00:43:32,430 --> 00:43:39,509
you'll realize that with a clean build

00:43:36,859 --> 00:43:42,359
with a first build we will actually

00:43:39,509 --> 00:43:45,509
going to pre-process all our translation

00:43:42,359 --> 00:43:47,789
unit up units up front right that might

00:43:45,509 --> 00:43:50,519
sound crazy to some it's probably a huge

00:43:47,789 --> 00:43:52,230
performance we're going to take a huge

00:43:50,519 --> 00:43:54,750
performance hit doing it you know

00:43:52,230 --> 00:43:57,720
partially pre-processing then processing

00:43:54,750 --> 00:43:59,430
again turns out this is actually can

00:43:57,720 --> 00:44:01,049
result in fast overall build

00:43:59,430 --> 00:44:04,769
surprisingly I think it is a good

00:44:01,049 --> 00:44:07,200
example where our from our intuition

00:44:04,769 --> 00:44:08,970
does not translate to modern hardware

00:44:07,200 --> 00:44:11,599
but if you think about it it makes sense

00:44:08,970 --> 00:44:15,029
so what we have now we have all the

00:44:11,599 --> 00:44:17,369
pre-processing happening up front at the

00:44:15,029 --> 00:44:19,829
beginning of the built in a very small

00:44:17,369 --> 00:44:22,650
point in time and pre-processing is

00:44:19,829 --> 00:44:24,569
mostly reading the same files over and

00:44:22,650 --> 00:44:27,869
over again right your standard library

00:44:24,569 --> 00:44:30,299
your operating system headers so now

00:44:27,869 --> 00:44:32,460
this is all concentrated in a small

00:44:30,299 --> 00:44:33,900
point of time which means that chances

00:44:32,460 --> 00:44:36,569
are pretty high all those here is

00:44:33,900 --> 00:44:38,569
actually sitting in memory in contrast

00:44:36,569 --> 00:44:40,859
if the pre-processing is spread out

00:44:38,569 --> 00:44:42,900
throughout the compilation which is by

00:44:40,859 --> 00:44:45,539
the way memory intensive thing most

00:44:42,900 --> 00:44:48,059
likely those files get flushed so that's

00:44:45,539 --> 00:44:53,099
why this in certain cases this actually

00:44:48,059 --> 00:44:55,829
can result in faster build okay so these

00:44:53,099 --> 00:44:57,509
are this is the new model this is how it

00:44:55,829 --> 00:45:00,809
works for example in the case of build

00:44:57,509 --> 00:45:04,380
two and yeah I haven't didn't didn't

00:45:00,809 --> 00:45:06,750
want to complicate the diagram but you

00:45:04,380 --> 00:45:09,329
can probably see what happens if we if

00:45:06,750 --> 00:45:11,880
we have a generated source file I mean

00:45:09,329 --> 00:45:14,279
generated here than we need to generate

00:45:11,880 --> 00:45:15,869
it if we detect it at that point and

00:45:14,279 --> 00:45:20,640
then we'll have to restart the whole

00:45:15,869 --> 00:45:24,859
thing try again so we've implemented

00:45:20,640 --> 00:45:29,430
this in build two it works pretty well

00:45:24,859 --> 00:45:32,039
okay and just a summary of what I think

00:45:29,430 --> 00:45:34,859
a next-generation build system should

00:45:32,039 --> 00:45:36,829
look like for c++ will be native with a

00:45:34,859 --> 00:45:40,259
conceptual model built of built

00:45:36,829 --> 00:45:42,779
implemented and extensible in C++ what

00:45:40,259 --> 00:45:45,019
we'll use mostly declarative language

00:45:42,779 --> 00:45:49,459
it will and it will be part of a

00:45:45,019 --> 00:45:52,769
dependency management tool chain and

00:45:49,459 --> 00:45:54,419
yeah that's it thank you very much I

00:45:52,769 --> 00:46:05,429
think we have quite a bit of time for

00:45:54,419 --> 00:46:09,239
questions just a good question on

00:46:05,429 --> 00:46:11,189
previous page why do you not use the

00:46:09,239 --> 00:46:15,329
fully pre-processed file to compile is

00:46:11,189 --> 00:46:16,799
just like a space issue no actually well

00:46:15,329 --> 00:46:19,469
there's a theoretical and practical

00:46:16,799 --> 00:46:21,539
answer to that a theoretical is a

00:46:19,469 --> 00:46:24,239
dependent it's not even valid to compile

00:46:21,539 --> 00:46:28,109
to the first pre-processing and compile

00:46:24,239 --> 00:46:29,849
a translation unit yep I was also

00:46:28,109 --> 00:46:32,759
surprised but the practical issues that

00:46:29,849 --> 00:46:35,130
you lose macro expansion information so

00:46:32,759 --> 00:46:37,109
the error messages are not gonna contain

00:46:35,130 --> 00:46:43,829
all the information except they cannot

00:46:37,109 --> 00:46:45,929
carry the position information thank you

00:46:43,829 --> 00:46:50,880
for the presentation very I mean I would

00:46:45,929 --> 00:46:53,609
use this build system but so in terms of

00:46:50,880 --> 00:46:57,119
IDE support obviously having a native

00:46:53,609 --> 00:46:58,169
workflow would be nicer from the stand

00:46:57,119 --> 00:47:00,209
point of not having to have this

00:46:58,169 --> 00:47:02,009
configure step like meta build system so

00:47:00,209 --> 00:47:04,859
of course you need to get the ideas to

00:47:02,009 --> 00:47:07,829
support it I'm curious if there's been a

00:47:04,859 --> 00:47:12,419
success so far getting build - in some

00:47:07,829 --> 00:47:16,109
of the common C++ ID ease we personally

00:47:12,419 --> 00:47:18,479
haven't tried it but I think Visual

00:47:16,109 --> 00:47:20,459
Studio open folder functionality looks

00:47:18,479 --> 00:47:24,179
quite promising so if anyone wants to

00:47:20,459 --> 00:47:27,779
take a stab at it we will help and

00:47:24,179 --> 00:47:30,390
assist as much as we can in the sense I

00:47:27,779 --> 00:47:32,759
just interrupt it's it's in a sense that

00:47:30,390 --> 00:47:37,439
we did some thinking and analysis about

00:47:32,759 --> 00:47:39,719
it it is similar issued to or if you

00:47:37,439 --> 00:47:42,719
look at how open folder works and how

00:47:39,719 --> 00:47:44,279
what the metadata that it requires it

00:47:42,719 --> 00:47:47,099
looks very similar to the compilation

00:47:44,279 --> 00:47:50,640
database so this it looks like this some

00:47:47,099 --> 00:47:52,890
kind of you know overall model of a tool

00:47:50,640 --> 00:47:55,650
needs to know you know what

00:47:52,890 --> 00:47:58,170
include parts what defines you have to

00:47:55,650 --> 00:48:00,720
in order to be able to like an IDE or a

00:47:58,170 --> 00:48:02,400
static checker to understand your

00:48:00,720 --> 00:48:05,040
codebase so there seems to be some

00:48:02,400 --> 00:48:08,700
commonality in that so hopefully we can

00:48:05,040 --> 00:48:12,240
maybe unify this some such and then on

00:48:08,700 --> 00:48:14,640
an unrelated matter of course one of the

00:48:12,240 --> 00:48:17,670
things with kind of starting over is is

00:48:14,640 --> 00:48:20,430
trying to get everyone to move have you

00:48:17,670 --> 00:48:22,530
thought of ways that that that could be

00:48:20,430 --> 00:48:23,940
made easier than it has in the past

00:48:22,530 --> 00:48:26,310
because usually it's pretty much like

00:48:23,940 --> 00:48:28,320
well start over in your build system and

00:48:26,310 --> 00:48:30,180
that's it's kind of a non-starter for a

00:48:28,320 --> 00:48:34,200
lot of organizations especially smaller

00:48:30,180 --> 00:48:37,830
ones yeah it is a problem but yeah I

00:48:34,200 --> 00:48:40,170
think I don't think there's magic so

00:48:37,830 --> 00:48:41,640
it's I think the options are if we

00:48:40,170 --> 00:48:43,500
tighter tomayto could probably be

00:48:41,640 --> 00:48:46,140
brittle and you know we'll spend most of

00:48:43,500 --> 00:48:49,010
our time fixing that or some you just

00:48:46,140 --> 00:48:56,190
have to bite the bullet and do it and

00:48:49,010 --> 00:48:59,640
our approach is to is to make it is to

00:48:56,190 --> 00:49:01,440
provide functionality that makes it you

00:48:59,640 --> 00:49:03,120
know worthwhile like to give you an

00:49:01,440 --> 00:49:05,550
example for example we are running a CI

00:49:03,120 --> 00:49:08,130
service so if you have an open source

00:49:05,550 --> 00:49:09,960
project you can see I your project on

00:49:08,130 --> 00:49:14,190
all the major platforms and compilers

00:49:09,960 --> 00:49:20,460
for free so that that's all I did our

00:49:14,190 --> 00:49:22,590
plan at least alright thank you in the

00:49:20,460 --> 00:49:25,680
in the big Bill's dependency checking

00:49:22,590 --> 00:49:27,510
takes for build projects like most of

00:49:25,680 --> 00:49:30,660
the time because you pretty much for

00:49:27,510 --> 00:49:33,420
every file have to scan STD libraries

00:49:30,660 --> 00:49:37,170
boost and those just a number of files

00:49:33,420 --> 00:49:39,630
can be huge so it feels like the

00:49:37,170 --> 00:49:42,780
solution to that would be a demon mode

00:49:39,630 --> 00:49:45,090
where you have some server running and

00:49:42,780 --> 00:49:47,250
using OS support like inotify

00:49:45,090 --> 00:49:50,010
so just build the dependency tree once

00:49:47,250 --> 00:49:53,160
and then you just watch your change and

00:49:50,010 --> 00:49:56,790
Ribeiro's necessary also this opens an

00:49:53,160 --> 00:49:59,610
opportunity for your IDE to integrate

00:49:56,790 --> 00:50:02,580
using some standard API and actually use

00:49:59,610 --> 00:50:04,620
things like remote build and also not to

00:50:02,580 --> 00:50:06,640
be dependent on your build system at all

00:50:04,620 --> 00:50:09,160
did you think about

00:50:06,640 --> 00:50:10,569
development of bill to in this direction

00:50:09,160 --> 00:50:14,559
I

00:50:10,569 --> 00:50:18,130
yes we've thought about that and also I

00:50:14,559 --> 00:50:20,140
think I think again going back to that

00:50:18,130 --> 00:50:21,730
point of pre-processing actually ending

00:50:20,140 --> 00:50:24,430
up with a faster but I think our

00:50:21,730 --> 00:50:27,670
intuition is really not translating very

00:50:24,430 --> 00:50:29,079
well to me personally you know if you

00:50:27,670 --> 00:50:32,190
have a more than hard way for example

00:50:29,079 --> 00:50:36,609
solid-state drives a lot of a lot of

00:50:32,190 --> 00:50:40,329
memory this problem actually pushes

00:50:36,609 --> 00:50:42,999
pushes this pushes the problem to really

00:50:40,329 --> 00:50:44,559
extremely large projects so I personally

00:50:42,999 --> 00:50:48,279
think an offense mmm

00:50:44,559 --> 00:50:51,369
think about NFS yeah well yeah NFS is

00:50:48,279 --> 00:50:53,559
usually what was brought up I don't

00:50:51,369 --> 00:50:56,710
personally I don't know it to me sounds

00:50:53,559 --> 00:50:59,349
like using NFS is a bad idea it feels

00:50:56,710 --> 00:51:02,049
like we we are going to spend time and

00:50:59,349 --> 00:51:04,869
and add complexity to optimize for a

00:51:02,049 --> 00:51:07,720
small subset of users that made by bad

00:51:04,869 --> 00:51:09,460
choices which which sounds unfair

00:51:07,720 --> 00:51:14,309
actually to the rest of the community

00:51:09,460 --> 00:51:17,349
right but but and going back to that

00:51:14,309 --> 00:51:19,119
demon mode and identify I think that's a

00:51:17,349 --> 00:51:20,769
good idea and also that's why I

00:51:19,119 --> 00:51:23,650
mentioned that I think the build system

00:51:20,769 --> 00:51:25,900
needs to be available as a library so it

00:51:23,650 --> 00:51:32,769
theoretically you could do a demon out

00:51:25,900 --> 00:51:34,630
if you wanted to so thank you I'm not

00:51:32,769 --> 00:51:36,730
I'm not unsympathetic to this model I

00:51:34,630 --> 00:51:43,089
think it's it's got some benefits I

00:51:36,730 --> 00:51:45,339
guess another someone else asked what

00:51:43,089 --> 00:51:48,039
success have you had or have you had

00:51:45,339 --> 00:51:50,769
success and could you describe it with

00:51:48,039 --> 00:51:52,239
translating existing projects because

00:51:50,769 --> 00:51:57,039
it's one thing to start from the ground

00:51:52,239 --> 00:51:59,049
up and build but starting but making a

00:51:57,039 --> 00:52:01,529
system so that you know not necessarily

00:51:59,049 --> 00:52:06,069
bite for bite but as close as possible I

00:52:01,529 --> 00:52:07,359
have 100% successfully built the same

00:52:06,069 --> 00:52:09,700
binaries and have some sort of

00:52:07,359 --> 00:52:11,140
confidence with that because I agree

00:52:09,700 --> 00:52:13,450
with what you're saying we shouldn't

00:52:11,140 --> 00:52:15,609
penalize the rest of the community for

00:52:13,450 --> 00:52:18,849
bad decisions and how people have

00:52:15,609 --> 00:52:20,030
designed their build but I think

00:52:18,849 --> 00:52:21,650
everybody in this room can

00:52:20,030 --> 00:52:23,390
agree that we all work at companies that

00:52:21,650 --> 00:52:27,380
have made some horrible decisions with

00:52:23,390 --> 00:52:30,170
build systems so that's really not the

00:52:27,380 --> 00:52:33,680
10% or 20% case it's probably more like

00:52:30,170 --> 00:52:35,810
the 97% case where we've all met the

00:52:33,680 --> 00:52:40,370
people's build systems are horrendous

00:52:35,810 --> 00:52:42,680
and this is kind of great but unless we

00:52:40,370 --> 00:52:46,490
look at this from how do what is the

00:52:42,680 --> 00:52:50,360
success rate from adopting this and is

00:52:46,490 --> 00:52:51,950
it even tenable I don't see where I

00:52:50,360 --> 00:52:55,490
don't see the compelling reason to do

00:52:51,950 --> 00:52:57,560
this so do you have examples yes we

00:52:55,490 --> 00:52:59,270
actually converted some of our projects

00:52:57,560 --> 00:53:01,340
some of the dependencies that we need

00:52:59,270 --> 00:53:04,970
probably a good example I like to give

00:53:01,340 --> 00:53:06,800
is as a MySQL client library and if you

00:53:04,970 --> 00:53:09,140
look at it it's it's pretty heavy thing

00:53:06,800 --> 00:53:11,930
well to start off with it's actually a

00:53:09,140 --> 00:53:14,870
sea library that is in that has C++

00:53:11,930 --> 00:53:16,340
implementation so I personally haven't

00:53:14,870 --> 00:53:18,980
encountered things like that

00:53:16,340 --> 00:53:21,320
before but it is it has a lot of things

00:53:18,980 --> 00:53:23,390
that are vendored that you know copied

00:53:21,320 --> 00:53:26,120
inside and there's a lot of of course

00:53:23,390 --> 00:53:28,070
variation and going back to the success

00:53:26,120 --> 00:53:30,170
rate I'm not exactly sure so we've

00:53:28,070 --> 00:53:32,030
converted my skill and my ADB client

00:53:30,170 --> 00:53:34,100
libraries I think one of them they just

00:53:32,030 --> 00:53:36,890
outright said we don't support me in GB

00:53:34,100 --> 00:53:39,650
on Windows and we've converted and

00:53:36,890 --> 00:53:41,540
actually built so in a sense we actually

00:53:39,650 --> 00:53:46,400
achieved higher success rate than their

00:53:41,540 --> 00:53:47,930
than their native build system okay but

00:53:46,400 --> 00:53:49,450
does I guess then that's that's an

00:53:47,930 --> 00:53:52,790
interesting question

00:53:49,450 --> 00:53:56,360
and did you miss something in their old

00:53:52,790 --> 00:53:59,030
build system that indicated this doesn't

00:53:56,360 --> 00:54:01,180
work on that compiler it'll compile but

00:53:59,030 --> 00:54:03,680
it won't really run and you've kind of

00:54:01,180 --> 00:54:05,570
hidden the problem now because oh yeah

00:54:03,680 --> 00:54:08,000
it compiles we translated it and that

00:54:05,570 --> 00:54:10,700
translation has missed something that is

00:54:08,000 --> 00:54:12,230
intrinsic to that build system that was

00:54:10,700 --> 00:54:15,740
ever there like those are the problems

00:54:12,230 --> 00:54:17,990
that I think that are inevitably come up

00:54:15,740 --> 00:54:21,230
with adopting a new build system because

00:54:17,990 --> 00:54:23,030
like I work on the core CLR and no way

00:54:21,230 --> 00:54:24,650
are we changing that from the build

00:54:23,030 --> 00:54:27,860
system because there's no real way to

00:54:24,650 --> 00:54:29,360
detected and so it kind of adopting and

00:54:27,860 --> 00:54:31,020
moving to new build systems without a

00:54:29,360 --> 00:54:35,340
way of

00:54:31,020 --> 00:54:38,700
is a really hard sell I again not only

00:54:35,340 --> 00:54:40,860
sympathetic I just I'm curious as to

00:54:38,700 --> 00:54:43,080
what the success rate is and how that

00:54:40,860 --> 00:54:45,000
works over time no yeah I think the only

00:54:43,080 --> 00:54:48,180
way to check would be to if you have

00:54:45,000 --> 00:54:53,220
tests for your project that would be the

00:54:48,180 --> 00:54:55,950
way to do and and which which is how we

00:54:53,220 --> 00:54:58,170
do that so we convert my skill my ADB

00:54:55,950 --> 00:55:00,240
because we needed that for our project

00:54:58,170 --> 00:55:02,850
our tech our project has extensive test

00:55:00,240 --> 00:55:05,100
suite and we just ran against it and we

00:55:02,850 --> 00:55:08,790
are pretty confident that at least for

00:55:05,100 --> 00:55:13,380
our scenario it works so I've sort of a

00:55:08,790 --> 00:55:14,550
meta question observation and it was

00:55:13,380 --> 00:55:16,170
sort of glossed over a little bit

00:55:14,550 --> 00:55:18,060
earlier in the talk when you talked

00:55:16,170 --> 00:55:20,370
about the difference between you know

00:55:18,060 --> 00:55:22,350
what an IDE might require in terms of

00:55:20,370 --> 00:55:23,850
project you know management structure

00:55:22,350 --> 00:55:26,190
organization versus what it builds a

00:55:23,850 --> 00:55:29,070
certain require and it occurs to me that

00:55:26,190 --> 00:55:31,260
there are several steps in real-world

00:55:29,070 --> 00:55:34,680
software development that have high

00:55:31,260 --> 00:55:38,490
overlap in that conceptual kind of thing

00:55:34,680 --> 00:55:40,890
like a manifest of what all the source

00:55:38,490 --> 00:55:42,480
files are what they all generate you

00:55:40,890 --> 00:55:44,910
know what steps are supposed to be done

00:55:42,480 --> 00:55:47,490
from you know the IDE

00:55:44,910 --> 00:55:49,440
you know project management sort of

00:55:47,490 --> 00:55:54,210
stuff to the build system to package

00:55:49,440 --> 00:55:58,110
managers to installers and it kind of

00:55:54,210 --> 00:56:02,490
seems to me like a next-generation build

00:55:58,110 --> 00:56:04,980
model would be more encapsulating of a

00:56:02,490 --> 00:56:07,170
next-generation project management you

00:56:04,980 --> 00:56:10,500
know manifest tracking model I'm

00:56:07,170 --> 00:56:12,600
wondering if you've thought about that

00:56:10,500 --> 00:56:15,300
in the larger context of the other

00:56:12,600 --> 00:56:19,500
related systems that have a high overlap

00:56:15,300 --> 00:56:22,470
in what they need to consider and is

00:56:19,500 --> 00:56:24,330
there any sort of a how to get there

00:56:22,470 --> 00:56:26,610
from here where we have a lot of

00:56:24,330 --> 00:56:28,380
disparate systems that all sort of need

00:56:26,610 --> 00:56:28,860
the same data and none of them play nice

00:56:28,380 --> 00:56:31,350
together

00:56:28,860 --> 00:56:33,260
unless you have a very integrated IDE

00:56:31,350 --> 00:56:37,830
environment sometimes

00:56:33,260 --> 00:56:41,250
so I'm sitting your first question

00:56:37,830 --> 00:56:43,800
so there's actually there are two things

00:56:41,250 --> 00:56:44,890
that we've done first is well first of

00:56:43,800 --> 00:56:47,830
all at Mis

00:56:44,890 --> 00:56:50,500
with that I think I believe a package

00:56:47,830 --> 00:56:53,080
manager and build system and project

00:56:50,500 --> 00:56:54,850
dependency manager they should be

00:56:53,080 --> 00:56:56,890
integrated in the sense that they should

00:56:54,850 --> 00:56:58,330
inform each other's design but they

00:56:56,890 --> 00:56:59,860
shouldn't be the same thing because

00:56:58,330 --> 00:57:02,080
sometimes you just want to use build

00:56:59,860 --> 00:57:04,720
system and a good example for that is is

00:57:02,080 --> 00:57:07,210
a is a distribution package manager for

00:57:04,720 --> 00:57:09,310
example all the Debian RedHat they just

00:57:07,210 --> 00:57:12,430
hate all this rust people because you

00:57:09,310 --> 00:57:15,430
know it's just all tied together so

00:57:12,430 --> 00:57:18,190
that's that's the prelude I guess what

00:57:15,430 --> 00:57:20,320
we've the two things that we've done to

00:57:18,190 --> 00:57:23,260
address the question of you know

00:57:20,320 --> 00:57:25,540
different tools needing and of mostly

00:57:23,260 --> 00:57:26,920
the same information so in the build

00:57:25,540 --> 00:57:29,770
system we made sure that you actually

00:57:26,920 --> 00:57:32,440
have to list everything so for example

00:57:29,770 --> 00:57:34,690
you have to list all your headers that

00:57:32,440 --> 00:57:36,670
you use in the project which is

00:57:34,690 --> 00:57:39,100
stickiness well at least in the old

00:57:36,670 --> 00:57:41,080
build model is strictly not necessary

00:57:39,100 --> 00:57:43,810
but we made it a requirement for other

00:57:41,080 --> 00:57:45,730
reasons but also in part four to make

00:57:43,810 --> 00:57:47,920
sure that you know if someone else wants

00:57:45,730 --> 00:57:50,140
to use this information for something

00:57:47,920 --> 00:57:51,670
other than building it's there so that's

00:57:50,140 --> 00:57:54,970
one thing and going back to the

00:57:51,670 --> 00:57:56,500
packaging this is all covered again I

00:57:54,970 --> 00:57:59,290
believe that a build system build

00:57:56,500 --> 00:58:02,170
definition language and a and a package

00:57:59,290 --> 00:58:03,910
description manager language manifest

00:58:02,170 --> 00:58:06,010
they should be separate but they are all

00:58:03,910 --> 00:58:07,570
specified and they're there so for

00:58:06,010 --> 00:58:10,620
example we specified version of your

00:58:07,570 --> 00:58:10,620
package in the manifest

00:58:11,250 --> 00:58:16,480
I mean how functionally consumable is

00:58:14,620 --> 00:58:18,280
that in the real world like the build

00:58:16,480 --> 00:58:20,190
system is going to generate you know X

00:58:18,280 --> 00:58:22,660
number of object files X number of

00:58:20,190 --> 00:58:25,240
executables two lives you know output

00:58:22,660 --> 00:58:28,660
dependencies you know how much of that

00:58:25,240 --> 00:58:30,100
is understandable by other I des how

00:58:28,660 --> 00:58:32,200
much of that is understandable and

00:58:30,100 --> 00:58:34,120
consumable by other project managers

00:58:32,200 --> 00:58:36,670
like in the real world how much of this

00:58:34,120 --> 00:58:39,190
can I actually compose in my overall

00:58:36,670 --> 00:58:41,020
project system versus this being sort of

00:58:39,190 --> 00:58:45,040
designed in a vacuum just for the build

00:58:41,020 --> 00:58:47,740
part of it but you mean right now as in

00:58:45,040 --> 00:58:49,990
there any IDs or other package managers

00:58:47,740 --> 00:58:51,820
that can consume this information how

00:58:49,990 --> 00:58:54,010
what's the status right now and what's

00:58:51,820 --> 00:58:56,140
the plan to get to something that is

00:58:54,010 --> 00:58:59,080
more integrated assuming that that's the

00:58:56,140 --> 00:59:01,240
go well the status now I'm not aware of

00:58:59,080 --> 00:59:04,270
any other package managers or IDs

00:59:01,240 --> 00:59:06,040
consuming it but and the plan is as I

00:59:04,270 --> 00:59:08,200
said to provide to make the build system

00:59:06,040 --> 00:59:11,380
a library and have a you know the

00:59:08,200 --> 00:59:13,270
manifest file is easy easy to parse so

00:59:11,380 --> 00:59:15,070
it should all be possible to extract

00:59:13,270 --> 00:59:18,970
very easily and this is of course

00:59:15,070 --> 00:59:20,710
compilation database which an existing

00:59:18,970 --> 00:59:22,630
it's probably compilation database is

00:59:20,710 --> 00:59:25,420
probably the closest what we occur until

00:59:22,630 --> 00:59:27,720
I have to do an industry standard for

00:59:25,420 --> 00:59:36,730
interchanging this kind of information

00:59:27,720 --> 00:59:39,490
so amiss in other words question about

00:59:36,730 --> 00:59:40,930
that I notified driven demon authority

00:59:39,490 --> 00:59:42,970
does that so if you want to build using

00:59:40,930 --> 00:59:45,400
your library something that could be a

00:59:42,970 --> 00:59:48,280
good example and your earlier Steven

00:59:45,400 --> 00:59:50,050
though about wild card globbing mmm he

00:59:48,280 --> 00:59:53,560
mentioned the possibility of picking up

00:59:50,050 --> 00:59:55,000
a stray source file why would I see that

00:59:53,560 --> 00:59:57,580
as a negative though why should that

00:59:55,000 --> 00:59:58,930
file be allowed to persist in that

00:59:57,580 --> 01:00:00,670
directory the source directory of a

00:59:58,930 --> 01:00:03,280
module if it's not source for that

01:00:00,670 --> 01:00:04,870
module shouldn't it shouldn't I see that

01:00:03,280 --> 01:00:08,890
as a positive that it forces people to

01:00:04,870 --> 01:00:12,280
confront this yeah I believe so but the

01:00:08,890 --> 01:00:14,830
the rationale that is normally brought

01:00:12,280 --> 01:00:17,980
against wild cards is that they might be

01:00:14,830 --> 01:00:19,900
source I will build it I want notice I

01:00:17,980 --> 01:00:21,670
will ship this library I'll package this

01:00:19,900 --> 01:00:24,700
and put it in our kite repository which

01:00:21,670 --> 01:00:27,040
cannot be deleted so it is it's easy to

01:00:24,700 --> 01:00:29,320
make a mistake that won't be noticed but

01:00:27,040 --> 01:00:33,400
again me personally using version

01:00:29,320 --> 01:00:36,340
control system like it I I can't

01:00:33,400 --> 01:00:39,190
remember in my life checking in garbage

01:00:36,340 --> 01:00:42,040
in my repository maybe I'm an exception

01:00:39,190 --> 01:00:43,900
but yeah I have actually a trickier

01:00:42,040 --> 01:00:45,460
question one of the trickiest things

01:00:43,900 --> 01:00:48,220
I've had to do was and had trouble with

01:00:45,460 --> 01:00:50,770
other built systems so I have a general

01:00:48,220 --> 01:00:52,900
process process by using the coverage of

01:00:50,770 --> 01:00:54,400
profiling information from unit tests to

01:00:52,900 --> 01:00:55,960
decide which source files the unit test

01:00:54,400 --> 01:00:57,790
depended on so next time the source file

01:00:55,960 --> 01:01:00,220
is modified the build system knows to

01:00:57,790 --> 01:01:02,350
recompile and rerun this unit test do

01:01:00,220 --> 01:01:04,420
you have an example like that using bill

01:01:02,350 --> 01:01:06,040
to that so we can see how it would be

01:01:04,420 --> 01:01:07,900
done because a lot of times feeding back

01:01:06,040 --> 01:01:10,180
into the next build this

01:01:07,900 --> 01:01:12,700
hmm can can cause problem for some

01:01:10,180 --> 01:01:16,750
building systems I'm not sure

01:01:12,700 --> 01:01:20,319
can you can you maybe rephrase so what

01:01:16,750 --> 01:01:22,960
what exactly is nation so if for example

01:01:20,319 --> 01:01:25,809
reading the the cheek of information

01:01:22,960 --> 01:01:28,539
that produced by a unit test somehow

01:01:25,809 --> 01:01:30,760
feeding that back into like generated

01:01:28,539 --> 01:01:32,650
you know make file or what can be

01:01:30,760 --> 01:01:34,900
included so the next time when it runs

01:01:32,650 --> 01:01:36,400
it knows this you know test also depends

01:01:34,900 --> 01:01:38,440
on these other things that got linked in

01:01:36,400 --> 01:01:40,690
through the static meter for example

01:01:38,440 --> 01:01:43,839
okay so yeah this is this is a more

01:01:40,690 --> 01:01:47,770
general programming she goes back to to

01:01:43,839 --> 01:01:50,730
this to the generated source code so you

01:01:47,770 --> 01:01:52,930
need to be able to to feed at home

01:01:50,730 --> 01:01:56,020
dependency information to your build

01:01:52,930 --> 01:02:03,940
system so in build two year we have

01:01:56,020 --> 01:02:05,799
support that so the way you would do it

01:02:03,940 --> 01:02:07,270
you will actually to customize a rule

01:02:05,799 --> 01:02:09,369
that will will

01:02:07,270 --> 01:02:11,380
so yeah you cannot do it in a build file

01:02:09,369 --> 01:02:14,319
you'll just need to write some C++ does

01:02:11,380 --> 01:02:16,400
that okay I think yeah we are out of

01:02:14,319 --> 01:02:21,729
time again thank you

01:02:16,400 --> 01:02:21,729

YouTube URL: https://www.youtube.com/watch?v=cJP7SSLjvSI


