Title: Making Iterators, Views and Containers Easier to Write with Boost.STLInterfaces - Zach Laine CppCon
Publication date: 2020-09-23
Playlist: CppCon Day 1
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/making_iterators_views_and_containers_easier_to_write_with_booststlinterfaces/making_iterators_views_and_containers_easier_to_write_with_booststlinterfaces__zach_laine__cppcon_2020.pdf
---
Writing standard-compliant iterators is surprisingly easy to get wrong. Standard containers are tedious to write, because they have such large interfaces, involving lots of similar operations. For many years, Boost.Iterator's iterator_facade and iterator_adaptor were the state of the art for automating the creation of iterators with minimal effort. However, that library has not kept up with the evolution of C++, particularly with regard to constexpr and noexcept.

Boost.STLInterfaces is a newly-accepted Boost library that solves these problems for authors of iterators and sequence containers. It does this using the same approach as C++20's std::ranges::view_interface. The view_interface template is a CRTP base that implements all the possible view member functions when inherited by a derived type containing just begin() and end(). This pattern allows the user to use Boost.STLInterfaces to write correct iterators, views, and/or sequence containers, requiring surprisingly little code.
---
Zach Laine
Sr. Principal Software Engineer, Cadence Design Systems
Zach Laine has been using C++ in industry for 15 years, focusing on data visualization, numeric computing, games, generic programming, and good library design. He finds the process of writing bio blurbs to be a little uncomfortable.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,880 --> 00:00:14,080
all right hi everybody my name is zach

00:00:10,639 --> 00:00:16,560
and i'm uh i'm a boost author and a uh

00:00:14,080 --> 00:00:17,520
standards library uh i mean standards uh

00:00:16,560 --> 00:00:18,800
committee member

00:00:17,520 --> 00:00:20,720
and i'll be talking to you about boost

00:00:18,800 --> 00:00:22,080
stl interfaces which is um

00:00:20,720 --> 00:00:23,199
the latest boost library i've written

00:00:22,080 --> 00:00:24,720
and i hope it's something that's going

00:00:23,199 --> 00:00:26,000
to be useful for a lot of people so so

00:00:24,720 --> 00:00:28,800
let's jump right in

00:00:26,000 --> 00:00:30,240
um all right so so as we know iterators

00:00:28,800 --> 00:00:31,840
are this glue that sort of holds

00:00:30,240 --> 00:00:33,360
together the stl

00:00:31,840 --> 00:00:35,760
in particular the containers talk to the

00:00:33,360 --> 00:00:37,280
containers via you know iterator pairs

00:00:35,760 --> 00:00:38,879
and the stl talks to the containers the

00:00:37,280 --> 00:00:41,200
same way containers talk to the stl the

00:00:38,879 --> 00:00:41,200
same way

00:00:41,360 --> 00:00:45,760
because of that glue being so important

00:00:44,320 --> 00:00:47,840
and because we want to reuse the stl

00:00:45,760 --> 00:00:49,440
containers and iterators everywhere

00:00:47,840 --> 00:00:51,600
we really want to have iterator types

00:00:49,440 --> 00:00:52,960
for uh or iterators on types that we

00:00:51,600 --> 00:00:54,879
write so we can enjoy that same degree

00:00:52,960 --> 00:00:56,800
of interoperability and inter integrated

00:00:54,879 --> 00:00:58,320
present all of our interfaces in fact

00:00:56,800 --> 00:01:00,480
unfortunately that's not very

00:00:58,320 --> 00:01:02,320
straightforward um

00:01:00,480 --> 00:01:03,840
what typically happens is that if we can

00:01:02,320 --> 00:01:06,799
make a pointer

00:01:03,840 --> 00:01:07,280
uh for some sequence of things or or as

00:01:06,799 --> 00:01:08,799
a

00:01:07,280 --> 00:01:10,479
begin and end of some container we're

00:01:08,799 --> 00:01:12,159
writing uh we tend to do that and then

00:01:10,479 --> 00:01:13,760
if we have to write an actual stl

00:01:12,159 --> 00:01:14,640
complying iterator we tend not to do

00:01:13,760 --> 00:01:17,200
that

00:01:14,640 --> 00:01:18,479
so the whole point of this library is to

00:01:17,200 --> 00:01:20,640
make that more

00:01:18,479 --> 00:01:22,880
palatable to do as a day-to-day activity

00:01:20,640 --> 00:01:24,640
to make writing iterators so easy

00:01:22,880 --> 00:01:26,080
uh that you do it all the time whenever

00:01:24,640 --> 00:01:27,280
the need arises right

00:01:26,080 --> 00:01:28,640
you don't make everything an iterator

00:01:27,280 --> 00:01:29,680
just because you have this library but

00:01:28,640 --> 00:01:33,040
it comes up a lot

00:01:29,680 --> 00:01:34,079
um as an option and if that option is

00:01:33,040 --> 00:01:36,000
easy then

00:01:34,079 --> 00:01:37,520
it's it's much more attractive to to

00:01:36,000 --> 00:01:40,079
follow that okay

00:01:37,520 --> 00:01:42,399
so here's an example real quick of an

00:01:40,079 --> 00:01:45,040
iterator i had for a type i wrote

00:01:42,399 --> 00:01:45,680
in a library before i had stl interfaces

00:01:45,040 --> 00:01:48,159
so

00:01:45,680 --> 00:01:49,600
the type uh was essentially a repeated

00:01:48,159 --> 00:01:50,640
string view so imagine you have the

00:01:49,600 --> 00:01:53,200
string view foo

00:01:50,640 --> 00:01:54,479
f-o-o and you repeat it eight times so

00:01:53,200 --> 00:01:56,880
you would expect to see

00:01:54,479 --> 00:01:58,640
you know fufu fufu eight times uh if you

00:01:56,880 --> 00:02:00,960
were to print that out or iterate over

00:01:58,640 --> 00:02:02,399
the elements so the way i accomplished

00:02:00,960 --> 00:02:04,399
that was i just had the

00:02:02,399 --> 00:02:06,320
string view itself and the number n and

00:02:04,399 --> 00:02:08,000
that's it uh and then the iterator did

00:02:06,320 --> 00:02:09,360
all the heavy lifting so

00:02:08,000 --> 00:02:11,840
this is the iterator that i wrote that

00:02:09,360 --> 00:02:13,360
did that um so we can see here it's a

00:02:11,840 --> 00:02:14,239
random access iterator because obviously

00:02:13,360 --> 00:02:15,360
i can um

00:02:14,239 --> 00:02:16,959
i could just jump to any point in the

00:02:15,360 --> 00:02:18,720
sequence by just doing a modulus

00:02:16,959 --> 00:02:20,319
operation to figure out where within foo

00:02:18,720 --> 00:02:22,000
i'm supposed to land if i need to

00:02:20,319 --> 00:02:24,239
line up a particular element okay so

00:02:22,000 --> 00:02:26,080
here's how this works i've got

00:02:24,239 --> 00:02:27,440
all the using directives i have to have

00:02:26,080 --> 00:02:28,000
or sorry using decorations i have to

00:02:27,440 --> 00:02:30,000
have

00:02:28,000 --> 00:02:31,440
to meet the contract of an iterator i

00:02:30,000 --> 00:02:32,720
have to have default constructability

00:02:31,440 --> 00:02:33,519
constructability for the underlying

00:02:32,720 --> 00:02:35,440
iterator

00:02:33,519 --> 00:02:37,120
and then all these operations now all

00:02:35,440 --> 00:02:38,800
these operations are from a table

00:02:37,120 --> 00:02:40,160
in the standard that says a random

00:02:38,800 --> 00:02:41,599
access iterator will have all these

00:02:40,160 --> 00:02:43,040
operations on it and i'm scrolling

00:02:41,599 --> 00:02:43,920
through it somewhat slow so you can see

00:02:43,040 --> 00:02:45,200
all of it

00:02:43,920 --> 00:02:47,440
it's not important to digest them all

00:02:45,200 --> 00:02:49,920
right now the point is to see how much

00:02:47,440 --> 00:02:51,120
effort i had to expend to get this

00:02:49,920 --> 00:02:54,239
iterator into my code

00:02:51,120 --> 00:02:55,840
okay so then after i'd written sdl

00:02:54,239 --> 00:02:57,840
interfaces i went back and

00:02:55,840 --> 00:02:59,200
rewrote that iterator and i did this

00:02:57,840 --> 00:03:00,800
with lots of iterators in the library

00:02:59,200 --> 00:03:01,760
that i was using or that i was writing a

00:03:00,800 --> 00:03:03,680
code for

00:03:01,760 --> 00:03:05,840
and using iterator interface to get

00:03:03,680 --> 00:03:09,360
there so that is this template

00:03:05,840 --> 00:03:11,519
iterator interface and it is a

00:03:09,360 --> 00:03:13,680
crtp based class so i think a lot of you

00:03:11,519 --> 00:03:14,879
probably know what crtp means and for

00:03:13,680 --> 00:03:17,120
those of you who do not

00:03:14,879 --> 00:03:18,319
uh it stands for the curiously recurring

00:03:17,120 --> 00:03:20,480
template pattern

00:03:18,319 --> 00:03:22,159
so this is the template that we're

00:03:20,480 --> 00:03:25,280
deriving from

00:03:22,159 --> 00:03:27,599
this is a class that we're deriving

00:03:25,280 --> 00:03:29,680
and here's the repetition the curious

00:03:27,599 --> 00:03:31,599
repetition right that we pass

00:03:29,680 --> 00:03:32,799
the name of the type we're writing to

00:03:31,599 --> 00:03:34,319
the base class

00:03:32,799 --> 00:03:36,080
and the reason we do that is because the

00:03:34,319 --> 00:03:37,360
base class wants to

00:03:36,080 --> 00:03:38,640
we want the base class to provide all

00:03:37,360 --> 00:03:40,000
these operations right so the way the

00:03:38,640 --> 00:03:43,040
base class does that

00:03:40,000 --> 00:03:45,840
is it looks within some type

00:03:43,040 --> 00:03:46,879
and sees its operations that it can use

00:03:45,840 --> 00:03:48,239
to generate a bunch

00:03:46,879 --> 00:03:50,319
more operations right so all the

00:03:48,239 --> 00:03:51,840
operations it provides it does in terms

00:03:50,319 --> 00:03:53,280
of those operations of this

00:03:51,840 --> 00:03:55,200
template parameter this template

00:03:53,280 --> 00:03:57,280
parameter happens to be the drive type

00:03:55,200 --> 00:03:58,560
and we have to do that because of course

00:03:57,280 --> 00:04:00,400
the base class doesn't know anything

00:03:58,560 --> 00:04:02,239
about the drive class in the typical

00:04:00,400 --> 00:04:04,400
inheritance situation so this is how we

00:04:02,239 --> 00:04:05,920
we square that circle and make sure that

00:04:04,400 --> 00:04:07,439
the base class

00:04:05,920 --> 00:04:09,439
actually has enough knowledge of how the

00:04:07,439 --> 00:04:11,840
drive type works in order to provide the

00:04:09,439 --> 00:04:13,920
operations the derived type does not

00:04:11,840 --> 00:04:16,079
okay so we provide that as the first

00:04:13,920 --> 00:04:18,560
template parameter to the to the crtb

00:04:16,079 --> 00:04:20,239
base we say we're random access iterator

00:04:18,560 --> 00:04:21,759
this is the value type of the iterator

00:04:20,239 --> 00:04:23,680
and this is the um

00:04:21,759 --> 00:04:25,120
the reference type of the iterator the

00:04:23,680 --> 00:04:28,639
uh

00:04:25,120 --> 00:04:30,160
embedded or the nested uh type def

00:04:28,639 --> 00:04:31,280
reference not it doesn't have to be a

00:04:30,160 --> 00:04:32,560
language reference and you see here i'm

00:04:31,280 --> 00:04:34,560
not actually using language reference

00:04:32,560 --> 00:04:35,919
and the only reason i didn't was that

00:04:34,560 --> 00:04:37,759
in this case i'm going to be passing

00:04:35,919 --> 00:04:39,199
around essentially what is a pointer to

00:04:37,759 --> 00:04:40,880
an individual byte which is not very

00:04:39,199 --> 00:04:42,080
efficient so i just made it an actual

00:04:40,880 --> 00:04:44,800
value instead of a

00:04:42,080 --> 00:04:45,440
reference okay so here's what i had to

00:04:44,800 --> 00:04:48,000
do

00:04:45,440 --> 00:04:49,040
inside the implementation i had to have

00:04:48,000 --> 00:04:50,800
the constructors

00:04:49,040 --> 00:04:52,080
i still have to write because you know

00:04:50,800 --> 00:04:53,199
because the language rules the base

00:04:52,080 --> 00:04:54,639
class can't really provide me the

00:04:53,199 --> 00:04:56,080
constructors

00:04:54,639 --> 00:04:57,440
and then i have to have the dereference

00:04:56,080 --> 00:04:58,479
operation i have to be able to do an

00:04:57,440 --> 00:05:00,160
offset and i have to be able to

00:04:58,479 --> 00:05:01,759
subtraction

00:05:00,160 --> 00:05:03,680
it turns out that if i can do those

00:05:01,759 --> 00:05:05,039
three operations all the other

00:05:03,680 --> 00:05:05,919
operations i showed you on the previous

00:05:05,039 --> 00:05:08,160
slide

00:05:05,919 --> 00:05:09,600
uh can be done in terms of those three

00:05:08,160 --> 00:05:11,919
so the crtp base

00:05:09,600 --> 00:05:12,800
this iterator interfaces or iterator

00:05:11,919 --> 00:05:15,680
interface base

00:05:12,800 --> 00:05:17,440
um takes these three operations and it

00:05:15,680 --> 00:05:19,039
uses them to implement the

00:05:17,440 --> 00:05:21,039
the free operator minus the free

00:05:19,039 --> 00:05:22,840
operator plus the all the relational

00:05:21,039 --> 00:05:25,280
operators and so on

00:05:22,840 --> 00:05:27,039
okay it turns out

00:05:25,280 --> 00:05:28,479
that when i did this transformation of

00:05:27,039 --> 00:05:31,440
this other library i was working on

00:05:28,479 --> 00:05:32,880
using stl interfaces i fixed a bunch of

00:05:31,440 --> 00:05:34,639
bugs i didn't know i had

00:05:32,880 --> 00:05:36,479
um the reason i didn't know i had them

00:05:34,639 --> 00:05:38,240
was they were essentially unexercised

00:05:36,479 --> 00:05:40,400
code that was wrong

00:05:38,240 --> 00:05:42,160
i actually included two of the bugs on

00:05:40,400 --> 00:05:45,039
this slide because this is

00:05:42,160 --> 00:05:46,479
how i came to find out about them was

00:05:45,039 --> 00:05:47,680
showing people this example

00:05:46,479 --> 00:05:48,960
so i put a little space here so i can

00:05:47,680 --> 00:05:50,720
spot them more easily so this is the

00:05:48,960 --> 00:05:52,880
first one

00:05:50,720 --> 00:05:53,840
we commonly write for a random access

00:05:52,880 --> 00:05:56,400
iterator i t

00:05:53,840 --> 00:05:58,080
minus or i t plus some offset right but

00:05:56,400 --> 00:06:01,199
we never really write

00:05:58,080 --> 00:06:01,600
uh some offset minus i t that's just not

00:06:01,199 --> 00:06:03,280
one

00:06:01,600 --> 00:06:05,600
of the operations we expect for random

00:06:03,280 --> 00:06:07,280
access iterator i was working too fast i

00:06:05,600 --> 00:06:09,039
was cutting and pasting and so i put

00:06:07,280 --> 00:06:10,800
this operation here where i've got the

00:06:09,039 --> 00:06:12,319
difference type on the left

00:06:10,800 --> 00:06:14,960
which it shouldn't have been so it's an

00:06:12,319 --> 00:06:16,720
extra operation that didn't belong here

00:06:14,960 --> 00:06:18,240
this is innocuous in the sense that it

00:06:16,720 --> 00:06:20,000
does what you expect

00:06:18,240 --> 00:06:21,919
it's not innocuous in the sense that if

00:06:20,000 --> 00:06:23,840
someone wrote that backwards in their

00:06:21,919 --> 00:06:24,560
code they probably just made a logical

00:06:23,840 --> 00:06:25,759
error

00:06:24,560 --> 00:06:27,520
while writing their code and i'm going

00:06:25,759 --> 00:06:29,039
to help perpetuate that error by

00:06:27,520 --> 00:06:30,000
providing an overload for that that does

00:06:29,039 --> 00:06:31,520
something

00:06:30,000 --> 00:06:33,199
so this is the kind of bug that can

00:06:31,520 --> 00:06:34,880
linger for a very long time and it's

00:06:33,199 --> 00:06:36,319
good that i replaced it with something

00:06:34,880 --> 00:06:37,919
that works

00:06:36,319 --> 00:06:40,479
the other one is perhaps even worse

00:06:37,919 --> 00:06:42,479
which is i try to do the

00:06:40,479 --> 00:06:44,400
you know the old trick of taking the

00:06:42,479 --> 00:06:45,919
operator less than up here

00:06:44,400 --> 00:06:47,759
and then using that to implement

00:06:45,919 --> 00:06:49,599
operator greater than down here but the

00:06:47,759 --> 00:06:51,039
problem is that i didn't actually swap

00:06:49,599 --> 00:06:53,199
the arguments to make that work

00:06:51,039 --> 00:06:54,080
so i just implemented operator greater

00:06:53,199 --> 00:06:55,680
than as

00:06:54,080 --> 00:06:57,120
operated less than instead of in terms

00:06:55,680 --> 00:07:00,639
of it and so it's just the wrong

00:06:57,120 --> 00:07:02,240
operation this is another thing that is

00:07:00,639 --> 00:07:03,599
unlikely to get spotted for a very long

00:07:02,240 --> 00:07:05,199
time because that's not an operation we

00:07:03,599 --> 00:07:06,479
use on random access iterators all that

00:07:05,199 --> 00:07:08,479
often i mean typically we use an

00:07:06,479 --> 00:07:10,160
iterator where we say some iterator not

00:07:08,479 --> 00:07:12,160
equals the end iterator and that's the

00:07:10,160 --> 00:07:13,680
only operation we really use on it um so

00:07:12,160 --> 00:07:15,120
this could have again persisted for a

00:07:13,680 --> 00:07:16,800
very long time and in fact the only

00:07:15,120 --> 00:07:18,560
reason i know that these two problems

00:07:16,800 --> 00:07:20,319
existed because as i said i never

00:07:18,560 --> 00:07:21,599
exercised that code

00:07:20,319 --> 00:07:23,440
was that when i first submitted this to

00:07:21,599 --> 00:07:25,680
boost as a you know

00:07:23,440 --> 00:07:26,720
the sort of pre-ambulatory boost

00:07:25,680 --> 00:07:28,479
submission where i say hey

00:07:26,720 --> 00:07:30,319
is anybody interested in this library i

00:07:28,479 --> 00:07:32,240
directed people to the github page

00:07:30,319 --> 00:07:33,759
and on the github page this example was

00:07:32,240 --> 00:07:35,440
the first thing you see and someone

00:07:33,759 --> 00:07:36,880
immediately said hey you've got this

00:07:35,440 --> 00:07:39,199
completely

00:07:36,880 --> 00:07:40,800
broken relational operator and that's

00:07:39,199 --> 00:07:42,160
how i knew it existed i never would have

00:07:40,800 --> 00:07:43,199
known and in fact i replaced it with

00:07:42,160 --> 00:07:46,160
something

00:07:43,199 --> 00:07:48,639
that was working so i never would have

00:07:46,160 --> 00:07:51,840
found it eventually either

00:07:48,639 --> 00:07:52,960
so the point is that instead of trying

00:07:51,840 --> 00:07:54,800
to test

00:07:52,960 --> 00:07:56,560
all those individual operations that i

00:07:54,800 --> 00:07:58,080
showed you in the first implementation

00:07:56,560 --> 00:07:59,680
i'm able to test basically just three

00:07:58,080 --> 00:08:01,440
operations and the constructors

00:07:59,680 --> 00:08:02,879
and that's a much better story in terms

00:08:01,440 --> 00:08:04,240
of testing and making sure that you got

00:08:02,879 --> 00:08:05,360
everything right and then

00:08:04,240 --> 00:08:08,479
the rest of the testing burden

00:08:05,360 --> 00:08:11,199
essentially is relying on the testing

00:08:08,479 --> 00:08:12,160
within sdl interfaces itself and that's

00:08:11,199 --> 00:08:14,319
you know rigorously

00:08:12,160 --> 00:08:15,759
testing all the api of all the uh

00:08:14,319 --> 00:08:18,080
iterators

00:08:15,759 --> 00:08:18,879
so i had written other iterators that i

00:08:18,080 --> 00:08:21,120
tested

00:08:18,879 --> 00:08:23,360
pretty exhaustively the entire interface

00:08:21,120 --> 00:08:26,400
i didn't test this one because

00:08:23,360 --> 00:08:27,759
it just was not used that often

00:08:26,400 --> 00:08:29,199
and it wasn't used independently as an

00:08:27,759 --> 00:08:30,080
iterator it's basically just used inside

00:08:29,199 --> 00:08:32,080
of a

00:08:30,080 --> 00:08:33,919
range operation on this repeated string

00:08:32,080 --> 00:08:35,519
view thing so

00:08:33,919 --> 00:08:37,279
that kind of thing happens a lot where

00:08:35,519 --> 00:08:38,640
we've got so much work to do

00:08:37,279 --> 00:08:40,000
that we essentially just bail on some of

00:08:38,640 --> 00:08:41,279
the work that we feel like is probably

00:08:40,000 --> 00:08:42,640
not that important anyway

00:08:41,279 --> 00:08:44,800
and we introduce bugs like this that

00:08:42,640 --> 00:08:46,240
persist for a long time so

00:08:44,800 --> 00:08:49,040
this is essentially the problem with

00:08:46,240 --> 00:08:52,240
writing iterators

00:08:49,040 --> 00:08:53,680
you know writ small that we have a huge

00:08:52,240 --> 00:08:55,440
amount of work we have to do to make a

00:08:53,680 --> 00:08:55,680
conforming one and so we tend not to do

00:08:55,440 --> 00:08:57,360
it

00:08:55,680 --> 00:08:58,720
and in part we do that because we're

00:08:57,360 --> 00:09:00,080
afraid of introducing the kind of bugs i

00:08:58,720 --> 00:09:02,160
just showed you

00:09:00,080 --> 00:09:04,240
okay so the whole point of sdl

00:09:02,160 --> 00:09:06,080
interfaces is to make this easier and

00:09:04,240 --> 00:09:08,000
it's not just for iterators i've also

00:09:06,080 --> 00:09:09,600
got support for views and sequence

00:09:08,000 --> 00:09:11,279
containers as well it's actually

00:09:09,600 --> 00:09:12,720
instructive to start with views so let's

00:09:11,279 --> 00:09:14,560
start with that first

00:09:12,720 --> 00:09:16,160
so in case you didn't know this already

00:09:14,560 --> 00:09:17,839
uh c plus 20 introduces

00:09:16,160 --> 00:09:19,440
uh in the stood range's name space stood

00:09:17,839 --> 00:09:23,279
range as view interface

00:09:19,440 --> 00:09:24,640
and view interface is the crtp base for

00:09:23,279 --> 00:09:25,440
doing views just like i showed you for

00:09:24,640 --> 00:09:27,120
iterators so

00:09:25,440 --> 00:09:28,640
if you want to make a view you just

00:09:27,120 --> 00:09:30,399
provide a begin and an end

00:09:28,640 --> 00:09:32,160
for your view and you derive from view

00:09:30,399 --> 00:09:33,680
interface you pass the type you're

00:09:32,160 --> 00:09:35,120
making as the first template parameter

00:09:33,680 --> 00:09:37,760
and you get all the operations you would

00:09:35,120 --> 00:09:37,760
want out of you

00:09:37,839 --> 00:09:40,720
another thing that we should probably

00:09:39,360 --> 00:09:43,440
touch on because i know a lot of people

00:09:40,720 --> 00:09:45,120
have missed this detail the ranges work

00:09:43,440 --> 00:09:47,040
is that the c plus 20 ranges allow you

00:09:45,120 --> 00:09:49,920
to use not just pairs of iterators

00:09:47,040 --> 00:09:51,519
um in the range case or a range that has

00:09:49,920 --> 00:09:52,000
a pair of iterations for the begin and

00:09:51,519 --> 00:09:55,519
end

00:09:52,000 --> 00:09:56,160
but also that provides um the support

00:09:55,519 --> 00:09:58,880
for

00:09:56,160 --> 00:09:59,680
mismatched iterator type so you can have

00:09:58,880 --> 00:10:01,519
the begin

00:09:59,680 --> 00:10:03,360
be an iterator and the end be something

00:10:01,519 --> 00:10:04,640
else that is as long as it's comparable

00:10:03,360 --> 00:10:05,839
to an iterator with the right semantics

00:10:04,640 --> 00:10:07,360
everything works

00:10:05,839 --> 00:10:09,760
so here's an example of how we would do

00:10:07,360 --> 00:10:11,760
this uh we use this new facility with

00:10:09,760 --> 00:10:12,880
null sentinel so the idea of null

00:10:11,760 --> 00:10:15,120
sentinel is that

00:10:12,880 --> 00:10:16,839
it's a sort of placeholder that means

00:10:15,120 --> 00:10:18,640
i'm at the end but it's not an iterator

00:10:16,839 --> 00:10:20,399
itself and

00:10:18,640 --> 00:10:22,560
how you would use that is of course this

00:10:20,399 --> 00:10:23,920
is the equality operation on it and

00:10:22,560 --> 00:10:25,680
all the quality operation does is

00:10:23,920 --> 00:10:27,680
dereference the pointer and text

00:10:25,680 --> 00:10:29,279
then check that it's null and if it is

00:10:27,680 --> 00:10:31,519
null we say true

00:10:29,279 --> 00:10:32,800
from the comparison operation and so

00:10:31,519 --> 00:10:33,519
essentially what we've done is we've

00:10:32,800 --> 00:10:35,040
made this

00:10:33,519 --> 00:10:37,440
null sentinel we've used it kind of as a

00:10:35,040 --> 00:10:39,200
tag type saying am i at the end

00:10:37,440 --> 00:10:40,560
and we don't have an actual iterator

00:10:39,200 --> 00:10:42,800
that we're using

00:10:40,560 --> 00:10:44,959
so if i were to pass this to stood

00:10:42,800 --> 00:10:46,320
range's distance which is

00:10:44,959 --> 00:10:48,640
perfectly fine to do because again it

00:10:46,320 --> 00:10:51,360
supports iterator sentinel pairs

00:10:48,640 --> 00:10:52,640
i can pass an alternated string and the

00:10:51,360 --> 00:10:55,680
null sentinel itself

00:10:52,640 --> 00:10:57,120
and sure enough there's 15 characters

00:10:55,680 --> 00:10:58,640
and that will terminate string

00:10:57,120 --> 00:11:00,320
it had to actually walk through the

00:10:58,640 --> 00:11:01,920
individual characters so it's an order

00:11:00,320 --> 00:11:03,519
in operation

00:11:01,920 --> 00:11:04,959
but the only reason i asked it to go

00:11:03,519 --> 00:11:06,160
through all n

00:11:04,959 --> 00:11:08,000
characters in the string is because

00:11:06,160 --> 00:11:12,000
that's what distance does

00:11:08,000 --> 00:11:14,640
um a good example of this is so

00:11:12,000 --> 00:11:16,000
what if putter pointed to let's say a

00:11:14,640 --> 00:11:18,160
trillion bytes on the heap

00:11:16,000 --> 00:11:19,760
okay i have this big memory space and i

00:11:18,160 --> 00:11:21,040
have a trillion bytes on 0.2

00:11:19,760 --> 00:11:23,519
and i know that i want to find a

00:11:21,040 --> 00:11:27,120
character that's just in the first 1k

00:11:23,519 --> 00:11:29,760
um using the algorithms in stood ranges

00:11:27,120 --> 00:11:31,120
or sorry i stood uh itself just stood

00:11:29,760 --> 00:11:33,120
fined or something

00:11:31,120 --> 00:11:34,880
i have to know the iterator at the end

00:11:33,120 --> 00:11:36,880
so i have to actually call sterling

00:11:34,880 --> 00:11:39,200
on this pointer and go all the way to

00:11:36,880 --> 00:11:42,160
the end uh before i can even call

00:11:39,200 --> 00:11:44,000
find if this lets you or stood fine so i

00:11:42,160 --> 00:11:46,240
can call stood fines to find if

00:11:44,000 --> 00:11:47,600
um only by knowing the iterator but i

00:11:46,240 --> 00:11:48,800
can call stood range is fine just a

00:11:47,600 --> 00:11:50,720
ranges find if

00:11:48,800 --> 00:11:52,160
knowing that there is an end coming at

00:11:50,720 --> 00:11:52,639
some point and it's an old terminated

00:11:52,160 --> 00:11:54,720
string

00:11:52,639 --> 00:11:56,000
and i don't have to do the operation of

00:11:54,720 --> 00:11:57,760
finding the end first

00:11:56,000 --> 00:11:59,200
so in those kind of cases particularly

00:11:57,760 --> 00:12:00,720
terminated strings it does have

00:11:59,200 --> 00:12:02,079
other applications too but that's where

00:12:00,720 --> 00:12:03,279
it really shines with no terminated

00:12:02,079 --> 00:12:07,120
strings

00:12:03,279 --> 00:12:10,240
okay so view interface

00:12:07,120 --> 00:12:10,639
is this is the definition straight out

00:12:10,240 --> 00:12:13,360
of the

00:12:10,639 --> 00:12:14,000
standard this is view interface i pass

00:12:13,360 --> 00:12:16,560
the

00:12:14,000 --> 00:12:17,600
derived type d that i want to derive

00:12:16,560 --> 00:12:19,600
from view interface

00:12:17,600 --> 00:12:21,120
and i've got this view base which is

00:12:19,600 --> 00:12:22,000
basically just a way of tagging a view

00:12:21,120 --> 00:12:25,200
as a view

00:12:22,000 --> 00:12:27,200
there are places within the stood ranges

00:12:25,200 --> 00:12:28,959
operations where you need to know if

00:12:27,200 --> 00:12:31,200
something's of your range and a range

00:12:28,959 --> 00:12:32,880
is something that may or may not own the

00:12:31,200 --> 00:12:34,720
elements that is a range over

00:12:32,880 --> 00:12:36,240
and a view never does so for instance a

00:12:34,720 --> 00:12:39,200
stood uh vector of

00:12:36,240 --> 00:12:40,800
int is a view or sorry it is a range but

00:12:39,200 --> 00:12:42,880
not a view

00:12:40,800 --> 00:12:45,040
because it owns its elements it is not a

00:12:42,880 --> 00:12:46,959
view uh so a view is always a range but

00:12:45,040 --> 00:12:48,639
not the other way around

00:12:46,959 --> 00:12:50,000
uh and then we have these two uh

00:12:48,639 --> 00:12:52,560
convenience functions

00:12:50,000 --> 00:12:54,639
to essentially do the cast to the base

00:12:52,560 --> 00:12:56,639
that's right to the drive

00:12:54,639 --> 00:12:58,399
type so we just take our this pointer we

00:12:56,639 --> 00:12:58,720
know that it saves the static cast down

00:12:58,399 --> 00:13:00,880
to

00:12:58,720 --> 00:13:02,240
d because we know it derived from d uh

00:13:00,880 --> 00:13:03,760
and this just makes it

00:13:02,240 --> 00:13:05,440
you know more concise to write the the

00:13:03,760 --> 00:13:06,320
implementations okay so we're not going

00:13:05,440 --> 00:13:09,920
to look at all these but

00:13:06,320 --> 00:13:12,079
an instructive one to look at is size so

00:13:09,920 --> 00:13:13,519
if you look at size right here you know

00:13:12,079 --> 00:13:16,800
at high level of abstraction

00:13:13,519 --> 00:13:20,079
if you can take the

00:13:16,800 --> 00:13:22,560
end minus the beginning then you

00:13:20,079 --> 00:13:23,120
know the size of the underlying uh

00:13:22,560 --> 00:13:27,279
sequence

00:13:23,120 --> 00:13:28,880
right so if that is well formed we

00:13:27,279 --> 00:13:32,079
probably want to have size

00:13:28,880 --> 00:13:34,000
as part of our view now you could have

00:13:32,079 --> 00:13:36,560
written just requires requires

00:13:34,000 --> 00:13:38,000
you know ranges and minus ranges begin

00:13:36,560 --> 00:13:39,680
but it turns out that there's some other

00:13:38,000 --> 00:13:42,639
requirements that

00:13:39,680 --> 00:13:43,519
for which you you want to use the sort

00:13:42,639 --> 00:13:47,519
of built-in

00:13:43,519 --> 00:13:50,560
concepts here so this concept constraint

00:13:47,519 --> 00:13:52,480
boils down to if it's a good idea to run

00:13:50,560 --> 00:13:53,920
uh to to execute and minus begin

00:13:52,480 --> 00:13:54,800
including it's well formed and a few

00:13:53,920 --> 00:13:56,720
other properties

00:13:54,800 --> 00:13:59,360
that those uh concepts are checking then

00:13:56,720 --> 00:14:01,440
this size overload is in play and if

00:13:59,360 --> 00:14:02,480
that concept requirement uh is not met

00:14:01,440 --> 00:14:05,360
then that size

00:14:02,480 --> 00:14:06,160
overload is not in play so when i

00:14:05,360 --> 00:14:08,079
instantiate

00:14:06,160 --> 00:14:10,160
this template with something that

00:14:08,079 --> 00:14:13,440
doesn't have

00:14:10,160 --> 00:14:16,079
random access iteration then i know

00:14:13,440 --> 00:14:17,600
just for the first thing that i consider

00:14:16,079 --> 00:14:19,839
that that is an ill-formed expression

00:14:17,600 --> 00:14:22,720
the minus expression

00:14:19,839 --> 00:14:24,480
and so i can't have that size number as

00:14:22,720 --> 00:14:27,120
part of my view

00:14:24,480 --> 00:14:28,560
if the end is not an iterator but a

00:14:27,120 --> 00:14:29,600
sentinel i also can't do that

00:14:28,560 --> 00:14:31,680
subtraction

00:14:29,600 --> 00:14:33,680
so again i don't want the size member to

00:14:31,680 --> 00:14:36,160
be part of the view

00:14:33,680 --> 00:14:37,760
okay so similar logic is applied to all

00:14:36,160 --> 00:14:39,199
these operations that you see so we've

00:14:37,760 --> 00:14:41,279
got um

00:14:39,199 --> 00:14:42,720
we've got empty we've got contextual

00:14:41,279 --> 00:14:44,240
conversion to bool

00:14:42,720 --> 00:14:46,399
we've got data which is just a pointer

00:14:44,240 --> 00:14:49,600
to the first element size front

00:14:46,399 --> 00:14:52,160
back and the index operation so

00:14:49,600 --> 00:14:52,880
for some given begin and end you may

00:14:52,160 --> 00:14:55,680
want

00:14:52,880 --> 00:14:57,040
one or more maybe none of these

00:14:55,680 --> 00:14:58,480
operations depending on the beginning of

00:14:57,040 --> 00:15:00,959
the end

00:14:58,480 --> 00:15:02,639
you get whichever ones apply to your

00:15:00,959 --> 00:15:04,079
beginning end based on the category of

00:15:02,639 --> 00:15:07,040
the iterator and whether or not

00:15:04,079 --> 00:15:08,240
the end is a sentinel or an iterator

00:15:07,040 --> 00:15:09,199
based on just deriving from view

00:15:08,240 --> 00:15:11,120
interface

00:15:09,199 --> 00:15:12,959
so as a quick example of use if we use

00:15:11,120 --> 00:15:14,160
this null sentinel and the equality

00:15:12,959 --> 00:15:16,720
operations that we just saw

00:15:14,160 --> 00:15:17,360
a little bit earlier i can make my view

00:15:16,720 --> 00:15:19,440
here

00:15:17,360 --> 00:15:21,279
i can derive that from view interface

00:15:19,440 --> 00:15:23,040
passing myself as a first parameter

00:15:21,279 --> 00:15:24,720
i do default construction construction

00:15:23,040 --> 00:15:25,519
from a null pointed null terminated

00:15:24,720 --> 00:15:27,760
pointer

00:15:25,519 --> 00:15:28,800
uh and then begin is just an alternative

00:15:27,760 --> 00:15:31,360
pointer itself and then

00:15:28,800 --> 00:15:33,040
end is just the null sentinel and that's

00:15:31,360 --> 00:15:37,040
it that's the whole thing

00:15:33,040 --> 00:15:40,480
now there is a a range overload of

00:15:37,040 --> 00:15:42,079
range's distance and just looking at

00:15:40,480 --> 00:15:43,600
what i wrote here lexically

00:15:42,079 --> 00:15:45,440
you can see okay i've got to begin and

00:15:43,600 --> 00:15:47,440
end so i would expect that this

00:15:45,440 --> 00:15:48,800
call to distance works and that's sort

00:15:47,440 --> 00:15:51,440
of natural

00:15:48,800 --> 00:15:52,079
however what i did not write explicitly

00:15:51,440 --> 00:15:53,920
was front

00:15:52,079 --> 00:15:56,000
and the index operation yet i have those

00:15:53,920 --> 00:15:59,440
two and of course that comes from

00:15:56,000 --> 00:16:01,839
the um the view interface

00:15:59,440 --> 00:16:03,519
uh base class which knows that that's

00:16:01,839 --> 00:16:05,120
random access iterator and so we can do

00:16:03,519 --> 00:16:09,040
things like the index operation

00:16:05,120 --> 00:16:11,040
in front okay so it makes it really nice

00:16:09,040 --> 00:16:12,560
to write any kind of view you might need

00:16:11,040 --> 00:16:14,000
by just putting begin and end and then

00:16:12,560 --> 00:16:15,600
driving and in fact all

00:16:14,000 --> 00:16:17,040
of the views in the start range's name

00:16:15,600 --> 00:16:18,880
space are implemented in terms of

00:16:17,040 --> 00:16:19,519
derivation from view interface so this

00:16:18,880 --> 00:16:21,279
is how

00:16:19,519 --> 00:16:24,000
you get this really nice generic code

00:16:21,279 --> 00:16:24,880
that gives you all the api you could

00:16:24,000 --> 00:16:26,959
want

00:16:24,880 --> 00:16:28,079
in whatever cases it can possibly do it

00:16:26,959 --> 00:16:29,360
in and

00:16:28,079 --> 00:16:31,519
leaves out the api that doesn't make

00:16:29,360 --> 00:16:33,920
sense

00:16:31,519 --> 00:16:35,519
so view interface was sort of the

00:16:33,920 --> 00:16:36,000
inspiration for the implementation

00:16:35,519 --> 00:16:37,759
technique

00:16:36,000 --> 00:16:39,519
that i used for everything in fact there

00:16:37,759 --> 00:16:40,639
was an earlier version of the iterator

00:16:39,519 --> 00:16:41,920
interface

00:16:40,639 --> 00:16:43,040
that did not work like this and i

00:16:41,920 --> 00:16:44,240
basically changed it to be like view

00:16:43,040 --> 00:16:45,680
interface because i like the approach so

00:16:44,240 --> 00:16:48,639
much

00:16:45,680 --> 00:16:50,320
now view interface is really nice to use

00:16:48,639 --> 00:16:51,920
even if you're not using c plus 20 so

00:16:50,320 --> 00:16:54,480
there's a back port

00:16:51,920 --> 00:16:56,160
within boost steel interfaces that works

00:16:54,480 --> 00:16:58,240
with c plus 17 and 14

00:16:56,160 --> 00:16:59,600
um and that is uh using sphenae

00:16:58,240 --> 00:17:00,720
obviously instead of concepts because we

00:16:59,600 --> 00:17:01,759
don't have concept support in those

00:17:00,720 --> 00:17:04,720
versions of language

00:17:01,759 --> 00:17:06,640
but if you want to use that technique uh

00:17:04,720 --> 00:17:07,839
before you can use equals 20 this is how

00:17:06,640 --> 00:17:09,520
you can get that

00:17:07,839 --> 00:17:10,720
so now something entirely new so that

00:17:09,520 --> 00:17:11,919
that's just basically a back port of

00:17:10,720 --> 00:17:12,480
existing functionality and later

00:17:11,919 --> 00:17:13,760
standard

00:17:12,480 --> 00:17:15,280
but the support for iterators is

00:17:13,760 --> 00:17:17,839
something that's totally novel so let's

00:17:15,280 --> 00:17:19,679
look at that for a second

00:17:17,839 --> 00:17:21,280
you know custom iterators or the need to

00:17:19,679 --> 00:17:24,079
write a custom iterator comes up

00:17:21,280 --> 00:17:25,280
fairly frequently um it comes up when

00:17:24,079 --> 00:17:27,280
let's say you want to

00:17:25,280 --> 00:17:28,720
make a checking iterator uh that only a

00:17:27,280 --> 00:17:30,559
debug mode does some kind of checks like

00:17:28,720 --> 00:17:31,760
msvc has these great checking iterators

00:17:30,559 --> 00:17:32,000
that catch all kinds of stuff you didn't

00:17:31,760 --> 00:17:34,799
know

00:17:32,000 --> 00:17:36,799
was problematic until you run them maybe

00:17:34,799 --> 00:17:38,240
you want to apply that to your own

00:17:36,799 --> 00:17:41,120
container or maybe you want to apply

00:17:38,240 --> 00:17:44,400
that to use with clang or gcc

00:17:41,120 --> 00:17:46,960
you might also want to make an iterator

00:17:44,400 --> 00:17:48,480
for some legacy container you have a c

00:17:46,960 --> 00:17:49,760
linked list from a legacy library is a

00:17:48,480 --> 00:17:51,520
great example there's there's lots of

00:17:49,760 --> 00:17:53,200
those around and lots of code bases

00:17:51,520 --> 00:17:54,559
and you have this problem that if you

00:17:53,200 --> 00:17:56,799
want to do something that's semantically

00:17:54,559 --> 00:17:58,720
identical to find or find if you end up

00:17:56,799 --> 00:18:00,559
writing that by hand instead of just

00:17:58,720 --> 00:18:02,720
using stood fine just to find if unless

00:18:00,559 --> 00:18:04,559
you have an iterator that adapts that

00:18:02,720 --> 00:18:06,559
and then there's sometimes we just want

00:18:04,559 --> 00:18:08,400
to write an iterator because

00:18:06,559 --> 00:18:09,760
this one specific use case would be

00:18:08,400 --> 00:18:10,880
really nice if you had this iterator

00:18:09,760 --> 00:18:12,960
that sort of

00:18:10,880 --> 00:18:14,480
made everything work with the standard

00:18:12,960 --> 00:18:16,080
algorithms in a way that doesn't quite

00:18:14,480 --> 00:18:19,200
work without that iterator

00:18:16,080 --> 00:18:21,120
um and this kind of ad hoc case

00:18:19,200 --> 00:18:22,720
sometimes

00:18:21,120 --> 00:18:23,919
if it's only to write this iterator for

00:18:22,720 --> 00:18:24,480
this ad hoc case you're not going to

00:18:23,919 --> 00:18:25,919
reuse it

00:18:24,480 --> 00:18:27,600
it's just not worth the effort to write

00:18:25,919 --> 00:18:29,120
iterators without some kind of bridging

00:18:27,600 --> 00:18:30,400
library like steel interfaces so we're

00:18:29,120 --> 00:18:32,640
going to take a look at

00:18:30,400 --> 00:18:34,400
such an ad hoc case all right so let's

00:18:32,640 --> 00:18:35,360
say you have two sequences

00:18:34,400 --> 00:18:36,720
and you want to treat them as if they're

00:18:35,360 --> 00:18:39,120
one big sequence you want to do one or

00:18:36,720 --> 00:18:41,600
more operations over the big sequence

00:18:39,120 --> 00:18:42,720
so let's say you just take an example of

00:18:41,600 --> 00:18:45,200
find one of the simplest

00:18:42,720 --> 00:18:46,400
algorithms uh if you want to do find you

00:18:45,200 --> 00:18:47,120
would do something like this you would

00:18:46,400 --> 00:18:49,760
pass

00:18:47,120 --> 00:18:50,640
the first and last of each range that

00:18:49,760 --> 00:18:52,000
you wanted to

00:18:50,640 --> 00:18:53,760
do the big operation over in this case

00:18:52,000 --> 00:18:54,640
find and then you would pass the thing

00:18:53,760 --> 00:18:56,799
you wanted to find

00:18:54,640 --> 00:18:58,080
and this this is basically the interface

00:18:56,799 --> 00:19:00,880
you would probably write

00:18:58,080 --> 00:19:02,000
um so within the implementation you

00:19:00,880 --> 00:19:02,960
would probably do stood find on the

00:19:02,000 --> 00:19:04,080
first range

00:19:02,960 --> 00:19:05,360
and then if you found it return the

00:19:04,080 --> 00:19:06,799
result otherwise juice would find the

00:19:05,360 --> 00:19:08,160
second range

00:19:06,799 --> 00:19:09,760
when you want to return the result

00:19:08,160 --> 00:19:11,200
you've already got a problem because

00:19:09,760 --> 00:19:12,160
it's not the same kind of iterator you

00:19:11,200 --> 00:19:13,600
would return

00:19:12,160 --> 00:19:16,160
you're going to return something like a

00:19:13,600 --> 00:19:18,240
stood variant or boost variant

00:19:16,160 --> 00:19:19,280
and the problem with that is as soon as

00:19:18,240 --> 00:19:21,360
you want to compare that to

00:19:19,280 --> 00:19:23,679
end you have to do a little bit of work

00:19:21,360 --> 00:19:24,799
manually the user does to make those

00:19:23,679 --> 00:19:26,000
compare the same or you have to write

00:19:24,799 --> 00:19:27,039
some custom type that knows how to

00:19:26,000 --> 00:19:29,919
compare just to the

00:19:27,039 --> 00:19:31,120
uh type on the right-hand side um you

00:19:29,919 --> 00:19:32,720
could also return

00:19:31,120 --> 00:19:36,400
a pointer to the value that you found

00:19:32,720 --> 00:19:38,640
instead that has the problem that

00:19:36,400 --> 00:19:40,080
when you have that pointer you know you

00:19:38,640 --> 00:19:41,200
can check it for null let's say and that

00:19:40,080 --> 00:19:42,400
indicates you didn't find what you're

00:19:41,200 --> 00:19:43,360
looking for but then you can't like

00:19:42,400 --> 00:19:45,280
research

00:19:43,360 --> 00:19:47,600
from there like you can't call find a

00:19:45,280 --> 00:19:50,640
second time to find the next thing

00:19:47,600 --> 00:19:51,360
because the pointer loses the underlying

00:19:50,640 --> 00:19:52,960
iterators

00:19:51,360 --> 00:19:55,520
essentially that that you would need to

00:19:52,960 --> 00:19:57,280
to resume that operation so

00:19:55,520 --> 00:19:58,880
you know and and the bottom line is

00:19:57,280 --> 00:20:00,320
you're rewriting find we don't rewrite

00:19:58,880 --> 00:20:02,640
find right and so

00:20:00,320 --> 00:20:04,400
um this is problematic especially if you

00:20:02,640 --> 00:20:05,360
end up wanting to use mismatch and find

00:20:04,400 --> 00:20:08,720
if etc

00:20:05,360 --> 00:20:10,960
okay there is a

00:20:08,720 --> 00:20:12,080
nice facility for this in the range v3

00:20:10,960 --> 00:20:14,320
library uh most people are probably

00:20:12,080 --> 00:20:17,360
aware already that eric neebler is the

00:20:14,320 --> 00:20:18,000
the main person behind the rangers work

00:20:17,360 --> 00:20:20,960
and

00:20:18,000 --> 00:20:23,039
all that uh code started out in the

00:20:20,960 --> 00:20:24,320
range v3 library and got ported over

00:20:23,039 --> 00:20:25,840
one of the things that did not make it

00:20:24,320 --> 00:20:27,280
because of time was concat view so what

00:20:25,840 --> 00:20:28,720
concat view does is exactly the thing

00:20:27,280 --> 00:20:29,440
we've been talking about wanted to do in

00:20:28,720 --> 00:20:32,480
the previous

00:20:29,440 --> 00:20:35,520
example and here's how we use it so

00:20:32,480 --> 00:20:36,080
this is the range v3 namespace not stood

00:20:35,520 --> 00:20:38,640
ranges

00:20:36,080 --> 00:20:40,400
we do ranges concat and then well that's

00:20:38,640 --> 00:20:41,280
not what i wanted we do ranges concat on

00:20:40,400 --> 00:20:43,039
the vec in the list

00:20:41,280 --> 00:20:45,120
and then that gives us the view of the

00:20:43,039 --> 00:20:46,960
whole thing as one big sequence

00:20:45,120 --> 00:20:48,480
and then we try to find 42 within it

00:20:46,960 --> 00:20:50,559
with ranges find

00:20:48,480 --> 00:20:52,080
and we find it we don't okay very

00:20:50,559 --> 00:20:53,360
straightforward works it does exactly

00:20:52,080 --> 00:20:56,720
what we want

00:20:53,360 --> 00:20:59,840
now range v3 is a fairly big dependency

00:20:56,720 --> 00:21:00,480
some code bases or some scenarios like

00:20:59,840 --> 00:21:03,360
won't let you

00:21:00,480 --> 00:21:04,799
pull in an external dependency but more

00:21:03,360 --> 00:21:06,559
importantly there's some places where

00:21:04,799 --> 00:21:07,840
you just can't use

00:21:06,559 --> 00:21:09,840
range of skin cap because it doesn't

00:21:07,840 --> 00:21:12,400
work specifically

00:21:09,840 --> 00:21:14,080
if the first sequence in the second

00:21:12,400 --> 00:21:14,480
sequence if you take a reference to

00:21:14,080 --> 00:21:16,559
either

00:21:14,480 --> 00:21:18,000
iterator uh the iterators on both sides

00:21:16,559 --> 00:21:19,120
rather and you get some reference type

00:21:18,000 --> 00:21:21,039
for each one

00:21:19,120 --> 00:21:23,360
you need to be able to form a common

00:21:21,039 --> 00:21:25,120
reference using stood common reference

00:21:23,360 --> 00:21:26,559
or common reference type i think is

00:21:25,120 --> 00:21:28,000
what's called um so you have to

00:21:26,559 --> 00:21:29,520
form a common reference with those two

00:21:28,000 --> 00:21:30,880
and there might be a case where even

00:21:29,520 --> 00:21:32,240
those those two sequences are

00:21:30,880 --> 00:21:33,520
essentially the same thing you

00:21:32,240 --> 00:21:35,360
actually can't form a common reference

00:21:33,520 --> 00:21:37,360
type so in this example we have my

00:21:35,360 --> 00:21:38,799
end which is a strong type def and so

00:21:37,360 --> 00:21:40,320
we've

00:21:38,799 --> 00:21:41,520
made the explicit choice that this is an

00:21:40,320 --> 00:21:43,120
explicit construction you can't

00:21:41,520 --> 00:21:45,760
implicitly construct from an int and

00:21:43,120 --> 00:21:47,280
of course we did not provide an implicit

00:21:45,760 --> 00:21:49,760
conversion to end

00:21:47,280 --> 00:21:51,760
so what that means is that there is no

00:21:49,760 --> 00:21:53,440
common reference and this

00:21:51,760 --> 00:21:55,360
concept common reference with says no

00:21:53,440 --> 00:21:58,480
there's no common reference there

00:21:55,360 --> 00:22:00,720
so it turns out that we have

00:21:58,480 --> 00:22:02,960
this function overloaded for ends and

00:22:00,720 --> 00:22:05,840
mayans that we can use as a projection

00:22:02,960 --> 00:22:07,200
and we can say with just a call to azent

00:22:05,840 --> 00:22:08,559
uh give me the int

00:22:07,200 --> 00:22:10,480
that is either within this or the hint

00:22:08,559 --> 00:22:11,840
itself and so we can sort of regularize

00:22:10,480 --> 00:22:12,799
this and make it all look like ends on

00:22:11,840 --> 00:22:14,960
both sides

00:22:12,799 --> 00:22:16,320
but unfortunately ranges can cat doesn't

00:22:14,960 --> 00:22:18,080
have support for a

00:22:16,320 --> 00:22:20,159
projection of this kind and so you're

00:22:18,080 --> 00:22:21,039
just stuck right it relies on making a

00:22:20,159 --> 00:22:23,280
common reference

00:22:21,039 --> 00:22:24,400
and it's a general purpose facility so

00:22:23,280 --> 00:22:25,679
um you know

00:22:24,400 --> 00:22:27,120
allowing these kind of workarounds is

00:22:25,679 --> 00:22:27,840
maybe not what you want you want

00:22:27,120 --> 00:22:29,760
something where

00:22:27,840 --> 00:22:31,440
the types in the left and right and the

00:22:29,760 --> 00:22:33,679
two sequences are actually like

00:22:31,440 --> 00:22:35,280
essentially the same thing uh and that's

00:22:33,679 --> 00:22:37,039
important for reasoning if you have some

00:22:35,280 --> 00:22:38,960
specific workaround you need to do then

00:22:37,039 --> 00:22:40,559
then that should be um

00:22:38,960 --> 00:22:41,919
you know the provenance of your own code

00:22:40,559 --> 00:22:43,280
and not something like ranges concat so

00:22:41,919 --> 00:22:44,240
that makes sense for rages and cap but

00:22:43,280 --> 00:22:45,520
it's a limitation so

00:22:44,240 --> 00:22:47,760
put a pin in that we'll talk about that

00:22:45,520 --> 00:22:50,320
a little bit later

00:22:47,760 --> 00:22:51,840
so if we just want to find um a value

00:22:50,320 --> 00:22:53,280
like i mentioned before we just find out

00:22:51,840 --> 00:22:55,679
the first and then find the second

00:22:53,280 --> 00:22:57,200
range and if we find it we return

00:22:55,679 --> 00:22:58,640
ourselves

00:22:57,200 --> 00:23:00,559
but if we have an algorithm we want to

00:22:58,640 --> 00:23:03,440
implement that uses

00:23:00,559 --> 00:23:05,039
two elements at the same time now it

00:23:03,440 --> 00:23:05,600
won't work to decompose the problem and

00:23:05,039 --> 00:23:06,960
to

00:23:05,600 --> 00:23:09,440
do it in the first range and then do it

00:23:06,960 --> 00:23:11,120
in second range because

00:23:09,440 --> 00:23:12,960
at some point we may have a scenario

00:23:11,120 --> 00:23:14,320
where we have to find

00:23:12,960 --> 00:23:16,960
what we have to do an operation on an

00:23:14,320 --> 00:23:18,799
element from the end of the first

00:23:16,960 --> 00:23:20,480
range and the beginning of the second

00:23:18,799 --> 00:23:22,480
range

00:23:20,480 --> 00:23:23,840
if that's the case then we can't do that

00:23:22,480 --> 00:23:25,120
kind of decomposition at all

00:23:23,840 --> 00:23:28,000
right so we still have to use something

00:23:25,120 --> 00:23:30,320
like uh concat that we just saw

00:23:28,000 --> 00:23:31,760
so here was my solution for this i

00:23:30,320 --> 00:23:32,960
actually had the scenario where i had

00:23:31,760 --> 00:23:33,440
all three of those problems that i just

00:23:32,960 --> 00:23:34,640
mentioned

00:23:33,440 --> 00:23:36,559
i was writing code for boost so i

00:23:34,640 --> 00:23:37,360
couldn't pull in range v3 as an external

00:23:36,559 --> 00:23:38,799
dependency

00:23:37,360 --> 00:23:41,279
i sometimes didn't have a common

00:23:38,799 --> 00:23:42,880
reference type and i also

00:23:41,279 --> 00:23:45,360
had an algorithm that used more than one

00:23:42,880 --> 00:23:47,679
element and one step of the algorithm

00:23:45,360 --> 00:23:49,679
so the way i solved the common reference

00:23:47,679 --> 00:23:51,200
problem was i just have an explicit

00:23:49,679 --> 00:23:52,799
template parameter t that says this is

00:23:51,200 --> 00:23:54,159
the value type so there's no need to try

00:23:52,799 --> 00:23:55,840
to form the value type

00:23:54,159 --> 00:23:57,679
implicitly i just tell you explicitly

00:23:55,840 --> 00:24:00,000
what it has to be

00:23:57,679 --> 00:24:01,520
then i'm using the proxy iterator

00:24:00,000 --> 00:24:04,480
interface which is

00:24:01,520 --> 00:24:05,600
a an alias template for iterator

00:24:04,480 --> 00:24:07,200
interface

00:24:05,600 --> 00:24:08,240
all it does is have some nice defaults

00:24:07,200 --> 00:24:09,360
and makes it easier to write proxy

00:24:08,240 --> 00:24:10,320
iterators if you don't know what that is

00:24:09,360 --> 00:24:12,159
we're going to talk about it in just a

00:24:10,320 --> 00:24:14,240
minute so hang on

00:24:12,159 --> 00:24:15,440
and as always i pass myself as the first

00:24:14,240 --> 00:24:16,559
template parameter indicates

00:24:15,440 --> 00:24:18,159
bidirectional

00:24:16,559 --> 00:24:20,000
iterator and i see what the value type

00:24:18,159 --> 00:24:22,240
is so

00:24:20,000 --> 00:24:24,240
i've got this little end tag that we'll

00:24:22,240 --> 00:24:25,760
see how it's used in a second

00:24:24,240 --> 00:24:27,520
and then i've got the constructors here

00:24:25,760 --> 00:24:28,720
so i've got default construction i do a

00:24:27,520 --> 00:24:32,000
construction from

00:24:28,720 --> 00:24:32,320
an iterator in the first range or i can

00:24:32,000 --> 00:24:34,080
do

00:24:32,320 --> 00:24:35,760
a construction from an iterator in the

00:24:34,080 --> 00:24:37,600
second range now

00:24:35,760 --> 00:24:39,200
the iterators for the first and second

00:24:37,600 --> 00:24:41,600
ranges may actually be the same type

00:24:39,200 --> 00:24:42,880
and so these two constructors would be

00:24:41,600 --> 00:24:44,320
ambiguous

00:24:42,880 --> 00:24:46,320
that's why i have this end tag here to

00:24:44,320 --> 00:24:48,559
disambiguate the end case

00:24:46,320 --> 00:24:49,840
now the actual work that i have to do to

00:24:48,559 --> 00:24:51,039
implement this iterator is pretty

00:24:49,840 --> 00:24:54,320
straightforward

00:24:51,039 --> 00:24:54,960
um ironically because it's ironic

00:24:54,320 --> 00:24:56,640
because the

00:24:54,960 --> 00:24:57,760
bi-directional has fewer operations but

00:24:56,640 --> 00:24:59,600
i have to actually implement more

00:24:57,760 --> 00:25:01,039
members for bi-directional than for uh

00:24:59,600 --> 00:25:04,159
random access but

00:25:01,039 --> 00:25:06,240
uh here i just implement the increment

00:25:04,159 --> 00:25:08,880
operation the decrement operation

00:25:06,240 --> 00:25:09,520
and then i implement the dereference and

00:25:08,880 --> 00:25:10,880
equality

00:25:09,520 --> 00:25:12,559
so those four operations give me

00:25:10,880 --> 00:25:15,520
everything i need for bidirectional

00:25:12,559 --> 00:25:16,799
now because i wrote operator minus minus

00:25:15,520 --> 00:25:18,960
right here

00:25:16,799 --> 00:25:20,720
the base class is implementing operator

00:25:18,960 --> 00:25:24,240
minus minus int you know the other

00:25:20,720 --> 00:25:25,039
the uh the other the post decrement uh

00:25:24,240 --> 00:25:26,720
version

00:25:25,039 --> 00:25:28,240
but i'm hiding that name with this name

00:25:26,720 --> 00:25:30,080
so down here

00:25:28,240 --> 00:25:31,840
i have to pull the name back in and same

00:25:30,080 --> 00:25:34,159
thing for the other operator

00:25:31,840 --> 00:25:35,840
so anytime you implement something for

00:25:34,159 --> 00:25:37,440
which the base class

00:25:35,840 --> 00:25:39,760
implements overloads you need to have

00:25:37,440 --> 00:25:41,279
using uh declarations here to pull in

00:25:39,760 --> 00:25:43,360
those other names from the base

00:25:41,279 --> 00:25:44,559
okay so that's that and that's you know

00:25:43,360 --> 00:25:45,919
not much code to write it's pretty

00:25:44,559 --> 00:25:49,039
straightforward

00:25:45,919 --> 00:25:50,880
and here's the view that i make for

00:25:49,039 --> 00:25:53,840
using these kind of iterators so my

00:25:50,880 --> 00:25:55,760
iterator type is just a concat iterator

00:25:53,840 --> 00:25:57,279
i've got a begin and an end and that's

00:25:55,760 --> 00:25:58,640
all i have to do because i'm deriving

00:25:57,279 --> 00:25:59,919
from view interface

00:25:58,640 --> 00:26:01,919
and that gives me all the other

00:25:59,919 --> 00:26:03,279
operations i might want so

00:26:01,919 --> 00:26:05,600
for my use case i think it was actually

00:26:03,279 --> 00:26:07,520
maybe only using begin and end

00:26:05,600 --> 00:26:08,720
but it's just nice to have if you're

00:26:07,520 --> 00:26:09,760
going to make lots of views all the time

00:26:08,720 --> 00:26:11,360
to do this in case

00:26:09,760 --> 00:26:13,679
it comes up that you want to you know

00:26:11,360 --> 00:26:16,000
say index into something that's a random

00:26:13,679 --> 00:26:17,679
access range uh something like that

00:26:16,000 --> 00:26:20,400
and then i've got the concat function

00:26:17,679 --> 00:26:23,120
itself which makes a concat view

00:26:20,400 --> 00:26:24,400
in my case i want it to be an lvalue

00:26:23,120 --> 00:26:24,799
reference every time because i didn't

00:26:24,400 --> 00:26:26,400
want

00:26:24,799 --> 00:26:27,600
to worry about a dangling case that

00:26:26,400 --> 00:26:28,480
doesn't have to be this way i'm just

00:26:27,600 --> 00:26:29,840
pointing that out to

00:26:28,480 --> 00:26:31,360
by way of saying that that could be a

00:26:29,840 --> 00:26:32,960
forwarding range if you want or avoiding

00:26:31,360 --> 00:26:35,600
uh reference rather

00:26:32,960 --> 00:26:36,400
and then i construct from the iterator

00:26:35,600 --> 00:26:38,559
to the beginning

00:26:36,400 --> 00:26:40,240
and i construct with an iterator to the

00:26:38,559 --> 00:26:42,159
end and of course i have to have that

00:26:40,240 --> 00:26:42,400
disambiguating end tag here and that's

00:26:42,159 --> 00:26:44,400
it

00:26:42,400 --> 00:26:45,760
that's all i had to do here it is an

00:26:44,400 --> 00:26:48,320
action

00:26:45,760 --> 00:26:50,159
so i've got a vector i've got a list i

00:26:48,320 --> 00:26:51,360
say i want to concatenate and i'm saying

00:26:50,159 --> 00:26:52,720
these are hints

00:26:51,360 --> 00:26:54,799
i want to concatenate the vector in the

00:26:52,720 --> 00:26:56,640
list that gives me this view v

00:26:54,799 --> 00:26:58,720
and then i can just do stud ranges find

00:26:56,640 --> 00:27:00,320
on v i can look for 42 within v

00:26:58,720 --> 00:27:02,480
and i see that it's not found i can look

00:27:00,320 --> 00:27:03,679
for 58 within v and i see yep there it

00:27:02,480 --> 00:27:06,159
is it's the second element

00:27:03,679 --> 00:27:07,600
so it works as advertised it works a lot

00:27:06,159 --> 00:27:09,120
like the

00:27:07,600 --> 00:27:12,400
ranges concat thing we just saw except

00:27:09,120 --> 00:27:14,159
they don't have to use range v3 and

00:27:12,400 --> 00:27:16,400
i actually because it's all custom code

00:27:14,159 --> 00:27:18,480
i have the opportunity to add

00:27:16,400 --> 00:27:19,440
as a further sort of customization a

00:27:18,480 --> 00:27:21,120
further option

00:27:19,440 --> 00:27:23,039
i can add in let's say a projection like

00:27:21,120 --> 00:27:26,640
that as int function we saw earlier

00:27:23,039 --> 00:27:28,559
so if i wanted to add as in to concat i

00:27:26,640 --> 00:27:32,240
would put it

00:27:28,559 --> 00:27:33,919
right here i would pass in some callable

00:27:32,240 --> 00:27:35,120
and then i would pass that call but

00:27:33,919 --> 00:27:36,480
probably have to be part of the type of

00:27:35,120 --> 00:27:37,760
concatenator and then i would pass the

00:27:36,480 --> 00:27:42,000
callable probably here

00:27:37,760 --> 00:27:44,399
and here and then inside of the iterator

00:27:42,000 --> 00:27:45,200
i would call the callable on the result

00:27:44,399 --> 00:27:47,919
here

00:27:45,200 --> 00:27:50,000
on on both of these on both sides and so

00:27:47,919 --> 00:27:51,200
if the callable was something like azent

00:27:50,000 --> 00:27:54,320
and it would project from

00:27:51,200 --> 00:27:57,120
either range's types to one common type

00:27:54,320 --> 00:27:57,600
then everything works so again we don't

00:27:57,120 --> 00:27:59,440
want

00:27:57,600 --> 00:28:01,679
necessarily to have this kind of

00:27:59,440 --> 00:28:03,360
facility with

00:28:01,679 --> 00:28:06,320
ranges concat and certainly if it

00:28:03,360 --> 00:28:08,000
becomes stood ranges concat

00:28:06,320 --> 00:28:09,279
i don't know that that's a good idea to

00:28:08,000 --> 00:28:10,159
have that kind of flexibility for

00:28:09,279 --> 00:28:11,919
everyday code

00:28:10,159 --> 00:28:13,679
but it certainly is nice to be able to

00:28:11,919 --> 00:28:15,679
get to that flexibility if you need it

00:28:13,679 --> 00:28:18,880
in some very specific use case

00:28:15,679 --> 00:28:22,240
so the ability to write these kinds of

00:28:18,880 --> 00:28:23,120
iterators and views with like such a

00:28:22,240 --> 00:28:25,120
small amount of

00:28:23,120 --> 00:28:27,520
effort really makes that possible and

00:28:25,120 --> 00:28:29,200
it's nice for those kind of use cases

00:28:27,520 --> 00:28:30,960
okay so proxy iterators i talked about

00:28:29,200 --> 00:28:34,159
them a second ago

00:28:30,960 --> 00:28:37,600
what they are is any iterator for which

00:28:34,159 --> 00:28:38,960
the the nested type def reference is not

00:28:37,600 --> 00:28:40,640
a language reference it's not something

00:28:38,960 --> 00:28:41,919
ref

00:28:40,640 --> 00:28:42,880
anything for which that is true any

00:28:41,919 --> 00:28:44,480
iterator for which that's true is a

00:28:42,880 --> 00:28:46,880
proxy iterator um

00:28:44,480 --> 00:28:47,520
so we've seen proxy iterators in in many

00:28:46,880 --> 00:28:50,880
cases

00:28:47,520 --> 00:28:52,640
so like the uh istream iterator is a

00:28:50,880 --> 00:28:53,919
proxy it's an input iterator so it only

00:28:52,640 --> 00:28:55,360
produces values it doesn't produce

00:28:53,919 --> 00:28:56,880
references to an underlying value

00:28:55,360 --> 00:28:59,039
there's no underlying value there

00:28:56,880 --> 00:29:01,520
but also like stood ranges iota view is

00:28:59,039 --> 00:29:04,640
the same story right iota view produces

00:29:01,520 --> 00:29:06,080
you know all the values from 5 to 20 or

00:29:04,640 --> 00:29:07,360
all the values from 0 to infinity or

00:29:06,080 --> 00:29:08,720
what have you

00:29:07,360 --> 00:29:10,399
and each time it produces a value

00:29:08,720 --> 00:29:12,799
there's no underlying value to form a

00:29:10,399 --> 00:29:15,840
reference to so it's just that value

00:29:12,799 --> 00:29:17,600
as uh a non-language reference

00:29:15,840 --> 00:29:20,000
so those have to be proxy integrators

00:29:17,600 --> 00:29:20,880
the the reference nested type def is not

00:29:20,000 --> 00:29:22,080
reference type

00:29:20,880 --> 00:29:24,080
same thing if you're transcoding from

00:29:22,080 --> 00:29:25,679
utf-8 to utf-32 you reduce you're

00:29:24,080 --> 00:29:29,600
producing something as 32 bits

00:29:25,679 --> 00:29:32,399
from a value a series of values that is

00:29:29,600 --> 00:29:34,320
eight bits and so there's no 32 value

00:29:32,399 --> 00:29:36,799
bit value to form a reference to

00:29:34,320 --> 00:29:38,320
um there is some wonkiness involved in

00:29:36,799 --> 00:29:39,440
writing proxy iterators in particular

00:29:38,320 --> 00:29:40,640
the arrow operator you have to do

00:29:39,440 --> 00:29:42,720
something kind of funny

00:29:40,640 --> 00:29:44,559
um and booster steel interface is built

00:29:42,720 --> 00:29:45,120
with support for proxy iterators from

00:29:44,559 --> 00:29:46,640
the beginning

00:29:45,120 --> 00:29:48,399
and it handles that walkiness for you

00:29:46,640 --> 00:29:50,159
the first time you write a proxy

00:29:48,399 --> 00:29:51,760
iterator and you get to the arrow

00:29:50,159 --> 00:29:54,159
operation you're like how do i do this

00:29:51,760 --> 00:29:57,039
and this handles it for you

00:29:54,159 --> 00:29:58,399
so the sort of classic example of a

00:29:57,039 --> 00:30:01,760
proxy iterator is zip

00:29:58,399 --> 00:30:03,840
iteration so in this case we again

00:30:01,760 --> 00:30:05,520
derive from proxy iterator interface

00:30:03,840 --> 00:30:07,600
pass ourselves to the first type

00:30:05,520 --> 00:30:09,440
we save a random access iterator and

00:30:07,600 --> 00:30:10,880
what the zip iterator does it takes two

00:30:09,440 --> 00:30:14,640
underlying sequences of end

00:30:10,880 --> 00:30:17,520
and produces a sequence of tuples event

00:30:14,640 --> 00:30:19,360
so notionally so this is our value type

00:30:17,520 --> 00:30:20,720
that we have to provide to the template

00:30:19,360 --> 00:30:22,399
and notionally this is the

00:30:20,720 --> 00:30:24,799
value that we're iterating over we don't

00:30:22,399 --> 00:30:26,399
actually produce these values anywhere

00:30:24,799 --> 00:30:27,760
but that's kind of the thing that we do

00:30:26,399 --> 00:30:29,360
with value type value types funny that

00:30:27,760 --> 00:30:30,559
way that sometimes you write a type for

00:30:29,360 --> 00:30:31,520
value type that you never actually use

00:30:30,559 --> 00:30:34,799
for instance in

00:30:31,520 --> 00:30:36,880
stood map the value type is stood pair

00:30:34,799 --> 00:30:38,480
of key and value whatever your key value

00:30:36,880 --> 00:30:39,840
types are for your map

00:30:38,480 --> 00:30:42,399
that never gets produced by the map the

00:30:39,840 --> 00:30:45,600
map actually produces references

00:30:42,399 --> 00:30:49,200
to pairs of key

00:30:45,600 --> 00:30:51,200
const and value so

00:30:49,200 --> 00:30:52,640
it still has that value type because we

00:30:51,200 --> 00:30:54,000
want to know like notionally what is

00:30:52,640 --> 00:30:54,640
this a sequence of but that value type

00:30:54,000 --> 00:30:56,960
is never used

00:30:54,640 --> 00:30:57,679
same same thing here and this is the

00:30:56,960 --> 00:30:59,360
actual

00:30:57,679 --> 00:31:00,960
uh type we use in the dereference

00:30:59,360 --> 00:31:03,360
operation so this

00:31:00,960 --> 00:31:05,519
is not itself a language reference it is

00:31:03,360 --> 00:31:07,039
a tuple that contains two references

00:31:05,519 --> 00:31:09,200
but it itself is not a reference type

00:31:07,039 --> 00:31:11,200
there's no ampersand at the end

00:31:09,200 --> 00:31:12,720
so i can default construct one of these

00:31:11,200 --> 00:31:13,440
zip editors i can make one from a pair

00:31:12,720 --> 00:31:15,039
of pointers

00:31:13,440 --> 00:31:16,559
uh to end and this is just to keep

00:31:15,039 --> 00:31:18,000
things real simple it's only supports

00:31:16,559 --> 00:31:20,080
pointers to end

00:31:18,000 --> 00:31:21,519
when i do the de-reference operation i

00:31:20,080 --> 00:31:22,640
just dereference each of the underlying

00:31:21,519 --> 00:31:24,399
iterators

00:31:22,640 --> 00:31:26,399
and then i take those resulting

00:31:24,399 --> 00:31:28,080
references and i pass those out

00:31:26,399 --> 00:31:29,519
as an anatomical with those two

00:31:28,080 --> 00:31:31,679
references

00:31:29,519 --> 00:31:33,200
when i do this offset operation i just

00:31:31,679 --> 00:31:35,039
offset the two underlying

00:31:33,200 --> 00:31:36,399
pointers and lock step and then when i

00:31:35,039 --> 00:31:38,960
want to do subtraction

00:31:36,399 --> 00:31:39,840
i do the first iterate on the right hand

00:31:38,960 --> 00:31:41,360
side minus the

00:31:39,840 --> 00:31:43,440
first iterator on the left hand side

00:31:41,360 --> 00:31:46,960
okay very straightforward

00:31:43,440 --> 00:31:50,240
now again the reference type

00:31:46,960 --> 00:31:51,279
um the nested typedef reference is not a

00:31:50,240 --> 00:31:52,240
reference type it's not a language

00:31:51,279 --> 00:31:55,679
reference

00:31:52,240 --> 00:31:58,240
um and that's fine with c plus

00:31:55,679 --> 00:31:59,519
20. so none of the concepts for any of

00:31:58,240 --> 00:32:01,360
the iterator categories since people's

00:31:59,519 --> 00:32:02,640
20 care about this issue

00:32:01,360 --> 00:32:04,080
they're all written in a way where they

00:32:02,640 --> 00:32:05,519
don't care about if it's a proxy

00:32:04,080 --> 00:32:06,880
iterator or

00:32:05,519 --> 00:32:08,960
a non-proxy iterator it makes no

00:32:06,880 --> 00:32:12,399
difference the

00:32:08,960 --> 00:32:15,760
tables in the c plus 98

00:32:12,399 --> 00:32:18,799
standard everything before 20 say that

00:32:15,760 --> 00:32:20,720
if you don't have well it says for

00:32:18,799 --> 00:32:22,080
forward iteration and later anything

00:32:20,720 --> 00:32:25,279
past input iterator

00:32:22,080 --> 00:32:28,480
has to have t ref as the

00:32:25,279 --> 00:32:29,919
uh the nested typedef reference so

00:32:28,480 --> 00:32:32,080
if you don't have that then it's

00:32:29,919 --> 00:32:34,159
technically an input iterator so even

00:32:32,080 --> 00:32:35,519
though zip iter is random access

00:32:34,159 --> 00:32:37,679
it's technically an input iterator

00:32:35,519 --> 00:32:39,200
according to c plus 98. so

00:32:37,679 --> 00:32:40,720
if you're going to write proxy iterators

00:32:39,200 --> 00:32:42,080
try to use them with sequel says 20 but

00:32:40,720 --> 00:32:43,519
the good news is it doesn't even matter

00:32:42,080 --> 00:32:45,440
if you use them with sql system 98

00:32:43,519 --> 00:32:47,039
in in practical terms um it's

00:32:45,440 --> 00:32:47,760
technically undefined behavior to do

00:32:47,039 --> 00:32:49,600
that because the

00:32:47,760 --> 00:32:51,039
the table says thou shalt have a type

00:32:49,600 --> 00:32:52,640
that looks like this but in

00:32:51,039 --> 00:32:54,640
in practical matter it doesn't matter

00:32:52,640 --> 00:32:56,799
because um

00:32:54,640 --> 00:32:58,559
the algorithms don't do any concept

00:32:56,799 --> 00:33:00,399
checking they just use the operations on

00:32:58,559 --> 00:33:02,320
the value you give it

00:33:00,399 --> 00:33:03,679
the value had better have the operations

00:33:02,320 --> 00:33:05,600
it requires but if it has those

00:33:03,679 --> 00:33:07,279
operations that's all it cares about

00:33:05,600 --> 00:33:09,279
this is true even if you're using sort

00:33:07,279 --> 00:33:10,720
of the full interface of a random access

00:33:09,279 --> 00:33:11,039
iterator so i was actually able to get

00:33:10,720 --> 00:33:13,360
this

00:33:11,039 --> 00:33:14,320
zip hitter to work with stood sort which

00:33:13,360 --> 00:33:15,600
not only

00:33:14,320 --> 00:33:17,200
bounces around and uses the random

00:33:15,600 --> 00:33:18,480
access iteration but actually uses the

00:33:17,200 --> 00:33:20,159
value that it dereferences

00:33:18,480 --> 00:33:21,519
in some very specific ways like swapping

00:33:20,159 --> 00:33:23,600
the underlying value and stuff

00:33:21,519 --> 00:33:24,640
i did have to specialize stood interswap

00:33:23,600 --> 00:33:26,960
which is a no-no

00:33:24,640 --> 00:33:28,480
um you can specialize stood ranges

00:33:26,960 --> 00:33:31,360
interswap

00:33:28,480 --> 00:33:32,960
and that is in particular like specified

00:33:31,360 --> 00:33:34,880
to be a customization point

00:33:32,960 --> 00:33:36,320
so though i've not done the same thing

00:33:34,880 --> 00:33:39,360
with stud ranges sort

00:33:36,320 --> 00:33:41,039
if you're afraid of running afoul of um

00:33:39,360 --> 00:33:42,240
even theoretical undefined behavior you

00:33:41,039 --> 00:33:43,919
could stick with stood ranges sort i

00:33:42,240 --> 00:33:46,000
think that works although you know

00:33:43,919 --> 00:33:47,840
kevin hampton have not actually tried to

00:33:46,000 --> 00:33:51,039
implement that myself

00:33:47,840 --> 00:33:51,840
okay so there's another mode with this

00:33:51,039 --> 00:33:53,120
template

00:33:51,840 --> 00:33:54,640
that's kind of interesting and that is

00:33:53,120 --> 00:33:55,360
you can use it to adapt an existing

00:33:54,640 --> 00:33:58,480
iterator

00:33:55,360 --> 00:34:00,399
with even less code so in this case i've

00:33:58,480 --> 00:34:02,960
got a proxy iterator

00:34:00,399 --> 00:34:04,960
that i'm making and it's random access

00:34:02,960 --> 00:34:08,879
and it produces string views

00:34:04,960 --> 00:34:12,240
it is constructed from a pointer to

00:34:08,879 --> 00:34:15,679
um conch char stars so this was for

00:34:12,240 --> 00:34:16,720
using rxc rv pairs from you know from

00:34:15,679 --> 00:34:19,839
main

00:34:16,720 --> 00:34:22,720
so if i construct this with rxe

00:34:19,839 --> 00:34:23,040
or sorry arc v or arc v plus c then i

00:34:22,720 --> 00:34:24,960
get

00:34:23,040 --> 00:34:26,560
um a pair of iterators and when i go

00:34:24,960 --> 00:34:29,599
across the iterators instead of

00:34:26,560 --> 00:34:30,079
when i do reference it i get a construct

00:34:29,599 --> 00:34:33,440
star

00:34:30,079 --> 00:34:36,639
now i get a string view instead

00:34:33,440 --> 00:34:37,760
so that's a much nicer interface and all

00:34:36,639 --> 00:34:39,359
i really want to do

00:34:37,760 --> 00:34:41,440
is change that one aspect of the

00:34:39,359 --> 00:34:43,200
operation where the dereference gives me

00:34:41,440 --> 00:34:44,480
not a pointer but a string view

00:34:43,200 --> 00:34:46,320
and i didn't want to have to implement

00:34:44,480 --> 00:34:47,760
like the offset operation and the

00:34:46,320 --> 00:34:49,839
subtraction operation and the good news

00:34:47,760 --> 00:34:50,879
is i don't have to so what i can do is i

00:34:49,839 --> 00:34:51,919
can give

00:34:50,879 --> 00:34:53,919
if i want these things to be in the

00:34:51,919 --> 00:34:56,079
private section i can give

00:34:53,919 --> 00:34:56,960
sdl interfaces access to my private

00:34:56,079 --> 00:34:58,320
members just

00:34:56,960 --> 00:34:59,520
for picking up these two members and

00:34:58,320 --> 00:35:00,960
then i've got these two members base

00:34:59,520 --> 00:35:02,400
reference and they're just you know a

00:35:00,960 --> 00:35:03,599
constant on const overload and all they

00:35:02,400 --> 00:35:06,960
do is return

00:35:03,599 --> 00:35:09,200
the underlying iterator and

00:35:06,960 --> 00:35:10,960
the iterator interface template knows

00:35:09,200 --> 00:35:12,880
that if you have base reference

00:35:10,960 --> 00:35:14,160
it will prefer to do any of the

00:35:12,880 --> 00:35:14,560
operations that it implements in terms

00:35:14,160 --> 00:35:15,920
of that

00:35:14,560 --> 00:35:18,079
it'll even do some that it normally

00:35:15,920 --> 00:35:19,520
can't implement like the uh

00:35:18,079 --> 00:35:20,960
the offset operation the plus equals

00:35:19,520 --> 00:35:22,640
operation we saw that we had to do

00:35:20,960 --> 00:35:24,079
earlier with random access iterator so

00:35:22,640 --> 00:35:26,160
this is a really small amount of code i

00:35:24,079 --> 00:35:27,119
had to write um and you know the base

00:35:26,160 --> 00:35:28,880
reference stuff is

00:35:27,119 --> 00:35:30,320
is obviously trivial to write so pretty

00:35:28,880 --> 00:35:32,320
nice

00:35:30,320 --> 00:35:34,240
and here's the view that i that i made

00:35:32,320 --> 00:35:35,760
for this as well so i

00:35:34,240 --> 00:35:37,280
again derive from view interface and

00:35:35,760 --> 00:35:41,920
i've just got to begin and end

00:35:37,280 --> 00:35:43,440
that return these are of some char so

00:35:41,920 --> 00:35:45,359
this was actually a particular use case

00:35:43,440 --> 00:35:48,560
where i had um

00:35:45,359 --> 00:35:50,480
uh main giving me rxc and rv and in a

00:35:48,560 --> 00:35:52,079
few places passing around rxe and rv

00:35:50,480 --> 00:35:53,680
internally within my code

00:35:52,079 --> 00:35:56,240
and this means i can just pass around a

00:35:53,680 --> 00:35:57,760
few whenever i was using rxc and rv i

00:35:56,240 --> 00:35:59,680
had to write a raw for loop and now i

00:35:57,760 --> 00:36:01,520
can just do a range base for

00:35:59,680 --> 00:36:04,240
for loop using arc v and then the

00:36:01,520 --> 00:36:06,640
resulting type that i get at each

00:36:04,240 --> 00:36:08,800
step of that range base for loop is now

00:36:06,640 --> 00:36:08,800
a

00:36:09,119 --> 00:36:12,079
a string view instead of a pointer so

00:36:10,720 --> 00:36:13,359
i'm dealing with string views and ranges

00:36:12,079 --> 00:36:14,160
instead of raw pointers and all that's

00:36:13,359 --> 00:36:16,000
nice

00:36:14,160 --> 00:36:17,040
so that's a very small amount of code

00:36:16,000 --> 00:36:18,320
and you know i'm very familiar with the

00:36:17,040 --> 00:36:19,200
library but if you're using a library

00:36:18,320 --> 00:36:20,720
for a long time you'll have the same

00:36:19,200 --> 00:36:22,560
experience this took me literally five

00:36:20,720 --> 00:36:23,839
to ten minutes to write this and

00:36:22,560 --> 00:36:25,760
i cleaned up a whole bunch of code that

00:36:23,839 --> 00:36:27,200
was sort of messy and i was going to

00:36:25,760 --> 00:36:28,720
have to repeat the messiness in more

00:36:27,200 --> 00:36:30,160
places and now i've got a system for

00:36:28,720 --> 00:36:31,520
this and again this is very ad hoc

00:36:30,160 --> 00:36:33,040
this is not general purpose stuff that

00:36:31,520 --> 00:36:34,960
i'm going to give to everybody it was

00:36:33,040 --> 00:36:38,160
just in my code i had

00:36:34,960 --> 00:36:39,440
a nice way to use these views um and

00:36:38,160 --> 00:36:41,920
this library lets me do that very

00:36:39,440 --> 00:36:43,760
quickly okay

00:36:41,920 --> 00:36:45,119
another thing that the library does is

00:36:43,760 --> 00:36:47,200
let you make

00:36:45,119 --> 00:36:49,200
sequence containers with the same kind

00:36:47,200 --> 00:36:53,119
of approach that we've seen with

00:36:49,200 --> 00:36:54,240
iterators and views so as an example

00:36:53,119 --> 00:36:56,160
in the committee there's some interest

00:36:54,240 --> 00:36:57,359
in standardizing static vector and small

00:36:56,160 --> 00:36:59,359
vector and what those are

00:36:57,359 --> 00:37:00,640
is they're virtually identical to

00:36:59,359 --> 00:37:03,680
vectors except that

00:37:00,640 --> 00:37:04,880
the um the capacity there's different

00:37:03,680 --> 00:37:06,720
implications for the capacity so for

00:37:04,880 --> 00:37:08,000
instance a static vector has all of its

00:37:06,720 --> 00:37:09,920
capacity inside the vector

00:37:08,000 --> 00:37:11,520
it's basically got an array inside of it

00:37:09,920 --> 00:37:12,720
and when it exceeds that capacity it

00:37:11,520 --> 00:37:14,880
never goes to the heap you're just out

00:37:12,720 --> 00:37:16,400
of capacity

00:37:14,880 --> 00:37:18,240
small vector is similar in that it has

00:37:16,400 --> 00:37:19,280
an array inside of it but what it does

00:37:18,240 --> 00:37:21,119
instead is

00:37:19,280 --> 00:37:22,640
when you exceed that capacity it then

00:37:21,119 --> 00:37:24,079
goes to the heap so it's got basically a

00:37:22,640 --> 00:37:25,359
small buffer optimization and of course

00:37:24,079 --> 00:37:26,560
we know stood vector is always on the

00:37:25,359 --> 00:37:27,920
heap so that's kind of the three

00:37:26,560 --> 00:37:30,480
approaches for those

00:37:27,920 --> 00:37:33,200
and it's nice to have types individual

00:37:30,480 --> 00:37:35,280
types for a static vector a small vector

00:37:33,200 --> 00:37:36,400
so they both have exactly the same

00:37:35,280 --> 00:37:38,720
interfaces vector

00:37:36,400 --> 00:37:40,160
except that static vector does not have

00:37:38,720 --> 00:37:41,440
the allocator or where parts of the

00:37:40,160 --> 00:37:42,800
interface and so we're going to show

00:37:41,440 --> 00:37:43,839
that because it's it's more slide

00:37:42,800 --> 00:37:44,960
friendly

00:37:43,839 --> 00:37:47,520
okay so first of all this is the

00:37:44,960 --> 00:37:49,520
synopsis for vector and

00:37:47,520 --> 00:37:51,520
it's big right you can see all this

00:37:49,520 --> 00:37:53,280
stuff there's a lot of it

00:37:51,520 --> 00:37:57,280
and still keep going that's there's more

00:37:53,280 --> 00:37:58,960
of it and yet more and still more okay

00:37:57,280 --> 00:38:00,880
there's a lot of redundancy there within

00:37:58,960 --> 00:38:01,599
that type itself so there's lots of

00:38:00,880 --> 00:38:03,440
overloads

00:38:01,599 --> 00:38:04,880
where you could implement one overload

00:38:03,440 --> 00:38:07,359
in terms of another

00:38:04,880 --> 00:38:09,200
there's also a lot of redundancy across

00:38:07,359 --> 00:38:11,520
the sequence containers though too

00:38:09,200 --> 00:38:13,119
so for instance if you consider a sign

00:38:11,520 --> 00:38:15,599
if you look inside a vector assigned

00:38:13,119 --> 00:38:16,960
deck assign list to sign you're going to

00:38:15,599 --> 00:38:18,880
find that they do things

00:38:16,960 --> 00:38:20,480
almost identically the algorithm at a

00:38:18,880 --> 00:38:22,400
high level abstraction is the same and

00:38:20,480 --> 00:38:23,680
sometimes the code is almost literally

00:38:22,400 --> 00:38:26,800
the same too

00:38:23,680 --> 00:38:28,800
so what you do is you basically copy all

00:38:26,800 --> 00:38:31,119
the input as long as it will fit in the

00:38:28,800 --> 00:38:32,160
current storage of the container

00:38:31,119 --> 00:38:33,920
and then when you're done with that

00:38:32,160 --> 00:38:34,800
operation you either had extra storage

00:38:33,920 --> 00:38:37,599
left over

00:38:34,800 --> 00:38:39,119
that you want to erase or you had extra

00:38:37,599 --> 00:38:41,440
input that wouldn't fit and you want to

00:38:39,119 --> 00:38:44,480
insert that extra input that's left over

00:38:41,440 --> 00:38:47,119
and that's it that's the whole thing now

00:38:44,480 --> 00:38:48,160
what's interesting about this is that

00:38:47,119 --> 00:38:50,320
you have to have

00:38:48,160 --> 00:38:52,160
insert and erase for mutable sequence

00:38:50,320 --> 00:38:53,839
containers the immutable ones like stud

00:38:52,160 --> 00:38:56,240
vector don't have those operations

00:38:53,839 --> 00:38:57,520
so it would be possible to write so if

00:38:56,240 --> 00:39:00,000
you don't know about student race

00:38:57,520 --> 00:39:01,200
study race is this set of overloads for

00:39:00,000 --> 00:39:02,240
the standard containers that was

00:39:01,200 --> 00:39:03,920
introduced in 20

00:39:02,240 --> 00:39:05,440
and so it allows you to erase there's

00:39:03,920 --> 00:39:06,640
also a stud eraser that allows you to

00:39:05,440 --> 00:39:07,920
erase elements

00:39:06,640 --> 00:39:10,320
from these containers actually

00:39:07,920 --> 00:39:12,720
overloaded for the different containers

00:39:10,320 --> 00:39:14,480
well we could have written an assign as

00:39:12,720 --> 00:39:16,000
stood assigned instead of member

00:39:14,480 --> 00:39:18,079
uh assign on all these different

00:39:16,000 --> 00:39:19,680
containers that

00:39:18,079 --> 00:39:20,880
essentially works the same way except

00:39:19,680 --> 00:39:22,000
instead of having a different overload

00:39:20,880 --> 00:39:24,720
for each container

00:39:22,000 --> 00:39:25,440
if we just apply design to sequence

00:39:24,720 --> 00:39:27,040
containers

00:39:25,440 --> 00:39:29,040
that is things that have an erase and an

00:39:27,040 --> 00:39:30,320
insert with the right semantics

00:39:29,040 --> 00:39:32,240
then it would work for all the sequence

00:39:30,320 --> 00:39:33,520
containers because it doesn't work for

00:39:32,240 --> 00:39:34,880
array and that's what we want array

00:39:33,520 --> 00:39:36,560
doesn't have an assigned

00:39:34,880 --> 00:39:38,079
member and because it doesn't have a

00:39:36,560 --> 00:39:41,359
race and insert it can't do this

00:39:38,079 --> 00:39:42,800
assign operation basically um so

00:39:41,359 --> 00:39:45,040
that's pretty nice and this is just an

00:39:42,800 --> 00:39:46,640
aside that i think if we had to do it

00:39:45,040 --> 00:39:49,440
all over again if we were starting with

00:39:46,640 --> 00:39:51,040
containers from scratch we would be

00:39:49,440 --> 00:39:52,400
better served by writing interfaces like

00:39:51,040 --> 00:39:53,599
this and in fact adding new things to

00:39:52,400 --> 00:39:54,880
the standard i think we'd be better

00:39:53,599 --> 00:39:56,880
writing interfaces like this where we've

00:39:54,880 --> 00:39:58,400
got an operation that's done in terms of

00:39:56,880 --> 00:39:59,680
these basis operations of the type

00:39:58,400 --> 00:40:00,880
and we define it one time and it just

00:39:59,680 --> 00:40:01,839
works for all the types we might want to

00:40:00,880 --> 00:40:03,920
add

00:40:01,839 --> 00:40:05,599
um it's it's natural that we didn't

00:40:03,920 --> 00:40:06,960
write it like this in simplest 98

00:40:05,599 --> 00:40:08,880
because it would have required like

00:40:06,960 --> 00:40:10,000
really slow compile times based on

00:40:08,880 --> 00:40:11,599
sphenae constraints and

00:40:10,000 --> 00:40:13,599
it's just generally not the way we wrote

00:40:11,599 --> 00:40:14,880
code back then but in particular because

00:40:13,599 --> 00:40:16,800
we have concepts to make

00:40:14,880 --> 00:40:18,240
the expression of which things should

00:40:16,800 --> 00:40:19,920
work with a sign of which one shouldn't

00:40:18,240 --> 00:40:22,720
it makes it very easy to write code like

00:40:19,920 --> 00:40:24,319
this now okay

00:40:22,720 --> 00:40:25,760
so there is a sequence container

00:40:24,319 --> 00:40:27,200
interface as part of boost still

00:40:25,760 --> 00:40:29,200
interfaces that lets you

00:40:27,200 --> 00:40:31,200
write sequence containers uh so taking

00:40:29,200 --> 00:40:32,400
that example of a vector like type let's

00:40:31,200 --> 00:40:33,200
look at static vector and this is

00:40:32,400 --> 00:40:36,319
actually from

00:40:33,200 --> 00:40:38,640
the um the the documentation it's one of

00:40:36,319 --> 00:40:39,839
the examples for sdl interfaces

00:40:38,640 --> 00:40:41,359
so we've got sequence container

00:40:39,839 --> 00:40:42,720
interface we pass ourselves to the first

00:40:41,359 --> 00:40:44,960
template parameter

00:40:42,720 --> 00:40:46,240
now we have to do something a little bit

00:40:44,960 --> 00:40:47,920
wonky here because

00:40:46,240 --> 00:40:49,359
it's equal to 20 i can tell from the

00:40:47,920 --> 00:40:51,680
iterator type

00:40:49,359 --> 00:40:53,119
of static vector itself whether or not

00:40:51,680 --> 00:40:53,680
it has a contiguous layout because

00:40:53,119 --> 00:40:56,240
that's

00:40:53,680 --> 00:40:58,240
a property of iterators that i'm able to

00:40:56,240 --> 00:41:00,560
find out now in a standard way

00:40:58,240 --> 00:41:01,359
but before that i can't and so uh if you

00:41:00,560 --> 00:41:05,359
want to provide

00:41:01,359 --> 00:41:08,800
a dot data member um for

00:41:05,359 --> 00:41:10,400
the um the resulting type you need to

00:41:08,800 --> 00:41:11,839
know whether the layout is contiguous so

00:41:10,400 --> 00:41:12,880
i have to actually pass it as a template

00:41:11,839 --> 00:41:14,160
parameter and not take template

00:41:12,880 --> 00:41:16,800
parameter in this case

00:41:14,160 --> 00:41:19,520
okay so let's get to the the actual body

00:41:16,800 --> 00:41:21,200
of it here so we've got all the same

00:41:19,520 --> 00:41:23,520
using declarations i had to add before

00:41:21,200 --> 00:41:25,599
in vector so that's not improvement

00:41:23,520 --> 00:41:26,720
i've got essentially the same thing well

00:41:25,599 --> 00:41:28,079
not essentially i have actually the

00:41:26,720 --> 00:41:29,200
exact same set of

00:41:28,079 --> 00:41:31,200
constructors as a special number

00:41:29,200 --> 00:41:32,640
function so that's also not a win but

00:41:31,200 --> 00:41:33,920
then we see a dramatic

00:41:32,640 --> 00:41:35,920
reduction in what i have to write the

00:41:33,920 --> 00:41:38,240
rest of it in fact all the other

00:41:35,920 --> 00:41:41,839
operations the real

00:41:38,240 --> 00:41:43,359
meat of the the operation of the type is

00:41:41,839 --> 00:41:44,720
expressed in this interface here right

00:41:43,359 --> 00:41:46,720
this is essentially the basis

00:41:44,720 --> 00:41:48,000
that we can use to make all the other

00:41:46,720 --> 00:41:51,040
operations you saw on that previous

00:41:48,000 --> 00:41:52,480
slide um and note that we've got this in

00:41:51,040 --> 00:41:53,680
place back even though we've got in

00:41:52,480 --> 00:41:55,040
place and we've got end

00:41:53,680 --> 00:41:56,720
and we'll explain why that exists in

00:41:55,040 --> 00:41:57,920
just a second part of this is not

00:41:56,720 --> 00:41:59,680
actually part of the sequence container

00:41:57,920 --> 00:42:01,040
interface so like capacity and reserve

00:41:59,680 --> 00:42:01,440
and shrink to fit those are things that

00:42:01,040 --> 00:42:03,839
are

00:42:01,440 --> 00:42:04,880
particular to vector and perhaps some

00:42:03,839 --> 00:42:06,160
other types

00:42:04,880 --> 00:42:07,440
like string and stuff but they're not

00:42:06,160 --> 00:42:08,960
part of the sequence container interface

00:42:07,440 --> 00:42:11,920
itself

00:42:08,960 --> 00:42:12,800
okay so if you look at vectors

00:42:11,920 --> 00:42:16,800
operations

00:42:12,800 --> 00:42:18,800
there's um i think 61 member functions

00:42:16,800 --> 00:42:20,319
we only had to implement 22 members

00:42:18,800 --> 00:42:22,480
right there to make this work

00:42:20,319 --> 00:42:23,680
and we get the other 39 for free those

00:42:22,480 --> 00:42:28,480
are implemented by the

00:42:23,680 --> 00:42:30,400
the crt base um and then if you look at

00:42:28,480 --> 00:42:31,920
the implementation or see the testing

00:42:30,400 --> 00:42:34,400
burden that you have to

00:42:31,920 --> 00:42:35,839
um overcome to implement your own

00:42:34,400 --> 00:42:38,160
sequence type

00:42:35,839 --> 00:42:39,520
you you see it reduced from 61 members

00:42:38,160 --> 00:42:41,760
you have to test to 22

00:42:39,520 --> 00:42:43,760
which is you know night and day

00:42:41,760 --> 00:42:45,440
different

00:42:43,760 --> 00:42:46,720
what's crazy though is that a lot of

00:42:45,440 --> 00:42:47,760
those are special member functions are

00:42:46,720 --> 00:42:50,160
constructors so

00:42:47,760 --> 00:42:50,960
for copy assignment move and move

00:42:50,160 --> 00:42:52,560
assignment

00:42:50,960 --> 00:42:54,240
you might want to do something very

00:42:52,560 --> 00:42:56,800
specific to your type with those

00:42:54,240 --> 00:42:57,599
but for the other um the other

00:42:56,800 --> 00:42:59,200
constructors

00:42:57,599 --> 00:43:00,640
all of those constructors you can

00:42:59,200 --> 00:43:02,319
implement in terms of

00:43:00,640 --> 00:43:03,920
operations given to you by the base

00:43:02,319 --> 00:43:06,000
class so

00:43:03,920 --> 00:43:07,680
as an example the uh the constructor

00:43:06,000 --> 00:43:08,960
there's a all sequence continuous after

00:43:07,680 --> 00:43:12,079
constructor that takes a first and a

00:43:08,960 --> 00:43:13,520
last and all that does is call a sign

00:43:12,079 --> 00:43:15,359
that's easy right that's the whole

00:43:13,520 --> 00:43:16,319
implementation you just say this arrow

00:43:15,359 --> 00:43:18,800
assign

00:43:16,319 --> 00:43:20,720
inside there and you're done so that's

00:43:18,800 --> 00:43:21,839
all just copy pasta right and we don't

00:43:20,720 --> 00:43:24,800
have to worry about

00:43:21,839 --> 00:43:26,000
uh testing that stuff probably uh that

00:43:24,800 --> 00:43:27,040
brings our testing burn down to

00:43:26,000 --> 00:43:29,440
something even more like

00:43:27,040 --> 00:43:31,200
11 members i wish i could provide those

00:43:29,440 --> 00:43:32,319
really boilerplate uh constructors for

00:43:31,200 --> 00:43:33,680
you but i can't because the language

00:43:32,319 --> 00:43:35,680
rules i can't put them in the base class

00:43:33,680 --> 00:43:37,359
they don't they don't work that way

00:43:35,680 --> 00:43:39,520
um now in place back i pointed out

00:43:37,359 --> 00:43:42,560
before that's important to note because

00:43:39,520 --> 00:43:44,400
in place back is a signal to

00:43:42,560 --> 00:43:46,560
sequence container interface that it is

00:43:44,400 --> 00:43:50,160
efficient to do pushes and pops

00:43:46,560 --> 00:43:52,640
at the end of the sequence without that

00:43:50,160 --> 00:43:54,560
i would have to maybe pass a separate

00:43:52,640 --> 00:43:56,160
template parameter or something i felt

00:43:54,560 --> 00:43:57,760
this was more idiomatic given the the

00:43:56,160 --> 00:43:58,640
way the rest of the uh the interface

00:43:57,760 --> 00:44:00,560
works

00:43:58,640 --> 00:44:02,560
uh if i were to put in place front it

00:44:00,560 --> 00:44:05,119
would also generate push front and push

00:44:02,560 --> 00:44:06,640
uh and pop front as well um that would

00:44:05,119 --> 00:44:07,760
belong on like a deck like type since

00:44:06,640 --> 00:44:08,160
we're making effects like type we don't

00:44:07,760 --> 00:44:10,480
want

00:44:08,160 --> 00:44:11,760
insertions uh and erasures at the front

00:44:10,480 --> 00:44:13,359
and of course here i was making an array

00:44:11,760 --> 00:44:16,079
like type i wouldn't have in place front

00:44:13,359 --> 00:44:16,079
or in place back

00:44:16,640 --> 00:44:19,920
so if for so for this container in

00:44:19,200 --> 00:44:22,000
particular

00:44:19,920 --> 00:44:23,520
um or this interface in particular but

00:44:22,000 --> 00:44:25,040
also for all the interfaces they work

00:44:23,520 --> 00:44:25,520
the same way because you're getting all

00:44:25,040 --> 00:44:27,920
the

00:44:25,520 --> 00:44:28,880
uh sort of provided functions from a

00:44:27,920 --> 00:44:30,000
base class

00:44:28,880 --> 00:44:31,599
if you don't like any of those

00:44:30,000 --> 00:44:33,040
implementations you just provide your

00:44:31,599 --> 00:44:33,680
own implementation for that function and

00:44:33,040 --> 00:44:35,760
the drive

00:44:33,680 --> 00:44:37,280
class and it hides the name of the one

00:44:35,760 --> 00:44:38,319
from the base class and that's the one

00:44:37,280 --> 00:44:39,839
that gets you so

00:44:38,319 --> 00:44:41,359
you've got a very easy override

00:44:39,839 --> 00:44:42,960
mechanism by just supplying any

00:44:41,359 --> 00:44:45,280
operation you care about so

00:44:42,960 --> 00:44:46,720
if for your particular type you didn't

00:44:45,280 --> 00:44:48,160
like that assign algorithm that i showed

00:44:46,720 --> 00:44:49,599
you before you don't want that assigned

00:44:48,160 --> 00:44:50,800
to be done that way for your sequence

00:44:49,599 --> 00:44:52,000
container type you just provide an

00:44:50,800 --> 00:44:54,640
assign that does what you want and it

00:44:52,000 --> 00:44:54,640
just gets used

00:44:54,960 --> 00:44:59,119
so we have a lot of container-like types

00:44:58,480 --> 00:45:02,640
that we write

00:44:59,119 --> 00:45:05,040
it turns out what we usually do

00:45:02,640 --> 00:45:06,640
is we only provide iterators for those

00:45:05,040 --> 00:45:07,200
container like types if it's convenient

00:45:06,640 --> 00:45:08,800
to do so

00:45:07,200 --> 00:45:10,560
usually convenience in that case means

00:45:08,800 --> 00:45:12,880
that i can write begin and

00:45:10,560 --> 00:45:13,920
end the return pointers and if i can't

00:45:12,880 --> 00:45:16,319
do that

00:45:13,920 --> 00:45:17,359
um i generally skip it skip the support

00:45:16,319 --> 00:45:19,760
for that

00:45:17,359 --> 00:45:20,560
now that you have iterator interfaces

00:45:19,760 --> 00:45:22,720
iterate interface

00:45:20,560 --> 00:45:24,400
i should say um you can just provide

00:45:22,720 --> 00:45:24,880
those more complicated iterators if they

00:45:24,400 --> 00:45:27,359
have to

00:45:24,880 --> 00:45:28,640
be more complicated than a pointer and

00:45:27,359 --> 00:45:30,880
then of course

00:45:28,640 --> 00:45:32,240
providing all the other sequence

00:45:30,880 --> 00:45:34,560
container operations

00:45:32,240 --> 00:45:36,319
is a lot more palatable if you have a

00:45:34,560 --> 00:45:38,960
sequence container interface as well

00:45:36,319 --> 00:45:39,760
and it turns out that if it's so much

00:45:38,960 --> 00:45:41,280
easier

00:45:39,760 --> 00:45:42,560
it's pretty nice to have the full

00:45:41,280 --> 00:45:44,240
sequence container interface because

00:45:42,560 --> 00:45:46,640
then in some generic code you can pass

00:45:44,240 --> 00:45:48,160
in a deck or a vector or a list or your

00:45:46,640 --> 00:45:48,880
type that you just made up that has the

00:45:48,160 --> 00:45:52,880
full interface

00:45:48,880 --> 00:45:55,119
and that's pretty nice so

00:45:52,880 --> 00:45:56,800
another sort of corollary to the ease of

00:45:55,119 --> 00:45:58,960
which at which

00:45:56,800 --> 00:46:00,319
you can write a new sequence container

00:45:58,960 --> 00:46:01,280
type is that

00:46:00,319 --> 00:46:03,359
i think people shouldn't be writing

00:46:01,280 --> 00:46:05,359
allocator support into them if it's

00:46:03,359 --> 00:46:07,119
so much easier because i think for most

00:46:05,359 --> 00:46:09,920
people writing

00:46:07,119 --> 00:46:11,599
or adding an allocator support uh to an

00:46:09,920 --> 00:46:12,960
existing sequence container

00:46:11,599 --> 00:46:14,160
is probably equivalent to the amount of

00:46:12,960 --> 00:46:15,680
work it would take to write an entirely

00:46:14,160 --> 00:46:17,760
new sequence container or maybe two

00:46:15,680 --> 00:46:19,200
entirely new sequence containers

00:46:17,760 --> 00:46:21,119
um and that is because like the

00:46:19,200 --> 00:46:22,400
allocator support is like kind of wonky

00:46:21,119 --> 00:46:22,880
it's not something you deal with all the

00:46:22,400 --> 00:46:24,880
time

00:46:22,880 --> 00:46:26,319
a lot of people are ignorant about it

00:46:24,880 --> 00:46:27,359
there's some real gotchas there that you

00:46:26,319 --> 00:46:28,880
have to be careful of and there's some

00:46:27,359 --> 00:46:29,920
bugs that can linger for a long time if

00:46:28,880 --> 00:46:32,720
you aren't careful

00:46:29,920 --> 00:46:34,240
now some people are experts at doing

00:46:32,720 --> 00:46:35,280
allocator aware support and so they're

00:46:34,240 --> 00:46:36,480
going to say well that's

00:46:35,280 --> 00:46:37,839
crazy i'm going to i'm going to do that

00:46:36,480 --> 00:46:39,200
because that's the way i work and they

00:46:37,839 --> 00:46:42,160
aren't going to run afoul of those

00:46:39,200 --> 00:46:43,599
of those problems but there's still a

00:46:42,160 --> 00:46:45,359
problem with the way we specify

00:46:43,599 --> 00:46:46,720
allocators today which is that

00:46:45,359 --> 00:46:50,160
they're really loose i can make an

00:46:46,720 --> 00:46:52,319
allocator that has a fixed inline

00:46:50,160 --> 00:46:53,520
um buffer inside of it that allocates

00:46:52,319 --> 00:46:55,119
from and that makes

00:46:53,520 --> 00:46:56,400
that would using that allocator with my

00:46:55,119 --> 00:46:58,160
vector would make that vector basically

00:46:56,400 --> 00:47:01,119
into a static vector

00:46:58,160 --> 00:47:02,400
um the existence of that flexibility

00:47:01,119 --> 00:47:04,000
with allocators means that you're

00:47:02,400 --> 00:47:07,040
allowed to change the meaning

00:47:04,000 --> 00:47:07,520
of the type that you're using allocators

00:47:07,040 --> 00:47:09,280
with

00:47:07,520 --> 00:47:10,640
pretty dramatically so if you consider

00:47:09,280 --> 00:47:11,920
just insert how you would

00:47:10,640 --> 00:47:14,079
you would write that if you're writing

00:47:11,920 --> 00:47:15,920
vector um you would

00:47:14,079 --> 00:47:17,920
you know you're taking a sequence of

00:47:15,920 --> 00:47:19,280
things you're going to input

00:47:17,920 --> 00:47:20,559
sorry insert into your vector you're

00:47:19,280 --> 00:47:22,160
going to insert some spot and you've got

00:47:20,559 --> 00:47:22,880
a prefix before that and a suffix that

00:47:22,160 --> 00:47:25,440
that

00:47:22,880 --> 00:47:26,880
needs to end up after that so when you

00:47:25,440 --> 00:47:29,359
do that operation

00:47:26,880 --> 00:47:31,119
you need to um see well how much

00:47:29,359 --> 00:47:32,000
capacity do i have on the spill capacity

00:47:31,119 --> 00:47:34,160
i'm going to go to heap

00:47:32,000 --> 00:47:35,440
i'm going to make a big array that has

00:47:34,160 --> 00:47:36,720
the capacity of everything i need and

00:47:35,440 --> 00:47:38,400
then you know bump the capacity by

00:47:36,720 --> 00:47:40,400
whatever the growth factor is

00:47:38,400 --> 00:47:42,319
uh and then i put the prefix and copy

00:47:40,400 --> 00:47:43,280
the prefix in copy the insertion copy

00:47:42,319 --> 00:47:44,960
the suffix and

00:47:43,280 --> 00:47:46,960
and i'm done i swapped the pointers

00:47:44,960 --> 00:47:49,599
delete the old thing

00:47:46,960 --> 00:47:51,359
if i'm doing the same operation for

00:47:49,599 --> 00:47:53,599
static vector i want to do

00:47:51,359 --> 00:47:55,280
i want to skip that step where i try to

00:47:53,599 --> 00:47:56,800
make a new thing on the heap and then

00:47:55,280 --> 00:47:58,480
copy everything into it because i've got

00:47:56,800 --> 00:47:59,920
a fixed size buffer and if i try to

00:47:58,480 --> 00:48:01,680
allocate with the allocator

00:47:59,920 --> 00:48:03,200
i'm going to get that same fixed size

00:48:01,680 --> 00:48:04,640
buffer that maybe i'm using a bunch of

00:48:03,200 --> 00:48:06,880
it up already

00:48:04,640 --> 00:48:08,480
so it's not going to work it's maybe

00:48:06,880 --> 00:48:09,839
going to throw a bad alec or something

00:48:08,480 --> 00:48:10,800
and then even if it did work it'd be

00:48:09,839 --> 00:48:12,960
less efficient so

00:48:10,800 --> 00:48:14,160
that's weird right you can only have one

00:48:12,960 --> 00:48:15,680
implementation of insert

00:48:14,160 --> 00:48:17,040
insert doesn't have knowledge of how the

00:48:15,680 --> 00:48:18,800
allocator actually does its allocation

00:48:17,040 --> 00:48:20,960
so it can't adapt

00:48:18,800 --> 00:48:22,319
you also have just a complete change in

00:48:20,960 --> 00:48:25,440
semantics with moves right

00:48:22,319 --> 00:48:28,319
so with a static vector or an allocator

00:48:25,440 --> 00:48:30,640
based static vector like stood vector

00:48:28,319 --> 00:48:32,480
you have an order n

00:48:30,640 --> 00:48:35,359
operation that is maybe no except

00:48:32,480 --> 00:48:36,960
depending on if you can no except

00:48:35,359 --> 00:48:39,200
these things are no except copyable like

00:48:36,960 --> 00:48:40,480
they're you know a literal type or

00:48:39,200 --> 00:48:43,359
something

00:48:40,480 --> 00:48:44,800
but you may have a move operation that

00:48:43,359 --> 00:48:46,480
goes from no accept to

00:48:44,800 --> 00:48:48,640
now possibly throwing exception it goes

00:48:46,480 --> 00:48:50,000
from order one to order hand

00:48:48,640 --> 00:48:52,240
right so you're completely changing the

00:48:50,000 --> 00:48:54,160
semantics so my hope that people write

00:48:52,240 --> 00:48:56,000
more types like static vector and small

00:48:54,160 --> 00:48:57,440
vector and less types like stood vector

00:48:56,000 --> 00:48:58,880
with an allocator because i think it

00:48:57,440 --> 00:49:00,319
makes everyone's life easier and makes

00:48:58,880 --> 00:49:00,640
it easier for you to reason about your

00:49:00,319 --> 00:49:02,800
code

00:49:00,640 --> 00:49:04,000
you're users to do so okay so some

00:49:02,800 --> 00:49:04,800
things that might be coming for the

00:49:04,000 --> 00:49:06,400
library well

00:49:04,800 --> 00:49:08,160
this is the first thing um that i

00:49:06,400 --> 00:49:10,160
mentioned it's actually done

00:49:08,160 --> 00:49:11,359
uh so i have concept constrained the

00:49:10,160 --> 00:49:14,079
whole thing there's a c plus

00:49:11,359 --> 00:49:15,280
20 uh mode of building that's already in

00:49:14,079 --> 00:49:16,960
github now that's not in

00:49:15,280 --> 00:49:18,480
the latest boost release but probably in

00:49:16,960 --> 00:49:19,440
the next one uh it will it will be

00:49:18,480 --> 00:49:21,440
available

00:49:19,440 --> 00:49:23,440
uh and the way i've done this is i've

00:49:21,440 --> 00:49:26,079
got a v1 namespace

00:49:23,440 --> 00:49:26,559
that has the svna version of things and

00:49:26,079 --> 00:49:28,720
i've got

00:49:26,559 --> 00:49:30,319
the v2 namespace which has the concept

00:49:28,720 --> 00:49:33,680
version of things

00:49:30,319 --> 00:49:35,119
when you build in c plus 20 mode the v2

00:49:33,680 --> 00:49:37,760
namespace gets inlined

00:49:35,119 --> 00:49:38,240
and when you build in a pre sql system

00:49:37,760 --> 00:49:41,119
mode

00:49:38,240 --> 00:49:41,680
the v1 namespace gets inline so if you

00:49:41,119 --> 00:49:43,680
write

00:49:41,680 --> 00:49:45,119
boost stl interfaces foo for any

00:49:43,680 --> 00:49:47,359
template foo

00:49:45,119 --> 00:49:49,440
you will silently get concept

00:49:47,359 --> 00:49:51,920
constraints in simplices 20 and later

00:49:49,440 --> 00:49:53,359
and sphenae constraints in c plus 17 and

00:49:51,920 --> 00:49:54,559
earlier

00:49:53,359 --> 00:49:55,839
i think that's going to work really well

00:49:54,559 --> 00:49:57,119
for most users think most people are

00:49:55,839 --> 00:49:58,319
going to want to use concepts where

00:49:57,119 --> 00:49:59,200
they're available the concept

00:49:58,319 --> 00:50:00,559
constraints actually

00:49:59,200 --> 00:50:02,160
make more sense because it's really hard

00:50:00,559 --> 00:50:02,720
to write the exact thing you want with

00:50:02,160 --> 00:50:04,720
sphenae

00:50:02,720 --> 00:50:06,800
in many cases so there's some slight

00:50:04,720 --> 00:50:08,480
differences the

00:50:06,800 --> 00:50:09,839
sphenae ones are strictly less

00:50:08,480 --> 00:50:11,200
constrained in the cases where they're

00:50:09,839 --> 00:50:13,280
different

00:50:11,200 --> 00:50:14,640
and some people are going to hate this

00:50:13,280 --> 00:50:16,720
so there's a macro you can turn it off

00:50:14,640 --> 00:50:19,359
if you don't like that

00:50:16,720 --> 00:50:21,280
there's another possible direction which

00:50:19,359 --> 00:50:22,559
is if people like the sequence container

00:50:21,280 --> 00:50:23,680
interface and they say well i would like

00:50:22,559 --> 00:50:24,559
to do the same thing with associative

00:50:23,680 --> 00:50:25,520
containers

00:50:24,559 --> 00:50:27,599
i don't think that's going to come up

00:50:25,520 --> 00:50:29,200
nearly as often but if it does i don't

00:50:27,599 --> 00:50:30,640
have support for that yet

00:50:29,200 --> 00:50:32,160
um essentially the thing that make me

00:50:30,640 --> 00:50:33,119
stop and i was about to write support

00:50:32,160 --> 00:50:34,800
for was one the

00:50:33,119 --> 00:50:36,480
the specific containers have a gigantic

00:50:34,800 --> 00:50:38,640
interface so it's a lot more work

00:50:36,480 --> 00:50:40,160
but also uh they have this node-based

00:50:38,640 --> 00:50:43,040
interface so

00:50:40,160 --> 00:50:45,280
you're able to get nodes into and out of

00:50:43,040 --> 00:50:47,839
maps and sets

00:50:45,280 --> 00:50:49,280
the existence of that interface means

00:50:47,839 --> 00:50:50,720
that if you were to use the associative

00:50:49,280 --> 00:50:52,319
container interface and actually conform

00:50:50,720 --> 00:50:53,920
to the standard requirements

00:50:52,319 --> 00:50:55,599
you could only really write things that

00:50:53,920 --> 00:50:56,960
are almost identical to map and set

00:50:55,599 --> 00:50:59,119
you have to you know you could use

00:50:56,960 --> 00:51:02,240
something like an avl tree instead of

00:50:59,119 --> 00:51:03,760
uh the uh a red black tree

00:51:02,240 --> 00:51:04,960
you have to do some kind of tree based

00:51:03,760 --> 00:51:06,640
implementation or at least a node based

00:51:04,960 --> 00:51:09,040
implementation to make that work

00:51:06,640 --> 00:51:10,640
so it's not really attractive to be able

00:51:09,040 --> 00:51:11,760
to just rewrite your own map and set

00:51:10,640 --> 00:51:13,359
when they have to have

00:51:11,760 --> 00:51:15,200
almost identical semantics because of

00:51:13,359 --> 00:51:16,240
the interface so that kind of made me

00:51:15,200 --> 00:51:18,240
stop and if there's

00:51:16,240 --> 00:51:20,400
interest in that i'll probably add it

00:51:18,240 --> 00:51:21,839
with sort of the node part optional but

00:51:20,400 --> 00:51:23,920
so far i have no idea if there's even

00:51:21,839 --> 00:51:24,400
demand for it so that's that's something

00:51:23,920 --> 00:51:26,480
that's

00:51:24,400 --> 00:51:28,559
possibly on the time horizon for later

00:51:26,480 --> 00:51:30,640
all right and so with that

00:51:28,559 --> 00:51:32,559
we have um a little bit of time for

00:51:30,640 --> 00:51:34,720
questions i suppose right at the end

00:51:32,559 --> 00:51:36,000
and any other time or any other

00:51:34,720 --> 00:51:37,680
questions that we can't get

00:51:36,000 --> 00:51:40,000
answered right now we're going to have

00:51:37,680 --> 00:51:41,119
another session i have an ama right

00:51:40,000 --> 00:51:42,880
after this

00:51:41,119 --> 00:51:51,839
so thanks for attending and i'll see you

00:51:42,880 --> 00:51:51,839
in a second

00:52:03,040 --> 00:52:05,119

YouTube URL: https://www.youtube.com/watch?v=JByCzWaGxhE


