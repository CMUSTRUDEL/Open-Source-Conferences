Title: The Future of C++ Parallel and Concurrency Safety Guidelines - Michael Wong & Ilya Burylov CppCon 20
Publication date: 2020-09-23
Playlist: CppCon Day 1
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
As we move into a world of multicore, manycore, and heterogeneous cores, we foresee a need for safety guidelines and standards for these domains. Yet most safety guidelines only cover sequential programming.

There has never really been any guidelines for safe parallel/concurrency C++. This is not an oversight. The challenge of creating safety standards and guidelines has been so involved that just focusing on the rules for sequential programming has consumed most group's time, especially as they track a rapidly changing C++ Standard. There have been only a few concurrency related-rules in HIC++, SEI CERT C++, C++CG, WG23, Khronos Safety forum(SCAF), as well as several European H2020 projects, though none of them are specifically for static analyzers, with a mixture of meta-guidelines and specific guidance. However, they have formed a useful starting point Over the last 2 years, I have been working with experts from various Safety Groups including WG23, SG1, and MISRA to develop a set of guidelines for safe concurrency and have developed nearly 100 rules which I plan to put into C++CG, and MISRA C++. We have needed this collaboration among all the groups because not everyone who is a concurrency expert is a safety experts, and vice versa. Many more people are experts in neither domain, and need to still understand how to program parallelism and concurrency safely.

In this talk, I will show some of the developing rules, none of it will be in its final form obviously, but it will develop the argument on the rationale on these rules. Some are uncheckable and are more meta-rules that are appropriate for C++ CG, such as don't use Mutex. But if you do, there are a bunch of more specific rules that you need to be aware of (i.e.e do not destroy a locked mutex while some are very specific). Others are checkable and are appropriate for a safety standard like MISRA C++ or a future Safe version of SYCL or any other heterogeneous framework. As none of these rules are in any guideline or standard as yet, there will be an opportunity for you to participate and help shape the future of safety in parallelism and concurrency.

---
Michael Wong
Codeplay

Ilya Burylov
Intel Corporation

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,960 --> 00:00:14,880
hello

00:00:12,080 --> 00:00:16,640
hi everybody out there um this talk is

00:00:14,880 --> 00:00:18,880
going to be about the future of c

00:00:16,640 --> 00:00:20,480
plus plus parallel and concurrency

00:00:18,880 --> 00:00:22,800
safety guidelines

00:00:20,480 --> 00:00:24,800
my name is michael wong and along with

00:00:22,800 --> 00:00:27,840
my colleague ilya berloff

00:00:24,800 --> 00:00:29,599
we're going to show you where the safety

00:00:27,840 --> 00:00:31,279
and concurrency guidelines for

00:00:29,599 --> 00:00:33,920
parallelism and concurrency is going to

00:00:31,279 --> 00:00:33,920
head towards

00:00:34,239 --> 00:00:37,600
first a little bit about my colleague

00:00:35,840 --> 00:00:39,840
ilya berloff

00:00:37,600 --> 00:00:41,680
he'll come on the camera soon or when

00:00:39,840 --> 00:00:44,079
he's when he comes to talk

00:00:41,680 --> 00:00:45,920
he's a principal engineer at intel and

00:00:44,079 --> 00:00:47,680
he's been an architect of c plus

00:00:45,920 --> 00:00:49,840
software solutions autonomous driving

00:00:47,680 --> 00:00:51,360
markets with contributions into

00:00:49,840 --> 00:00:52,239
functional safety the miserable

00:00:51,360 --> 00:00:55,760
standards

00:00:52,239 --> 00:00:57,600
and contribution into sg1 wgg21 in

00:00:55,760 --> 00:00:59,520
threading vectorization and numerics as

00:00:57,600 --> 00:01:02,160
well as contributing into sickle

00:00:59,520 --> 00:01:04,640
the heterogeneous c plus programming

00:01:02,160 --> 00:01:04,640
language

00:01:06,240 --> 00:01:09,600
a little bit about me i'm a

00:01:07,520 --> 00:01:11,119
distinguished engineer at coldplay i'm

00:01:09,600 --> 00:01:12,960
the chair of sickle heterogeneous

00:01:11,119 --> 00:01:13,439
programming language as well as chair of

00:01:12,960 --> 00:01:15,600
the c

00:01:13,439 --> 00:01:18,080
plus directions group i've been involved

00:01:15,600 --> 00:01:20,159
in c plus plus for a long long time as

00:01:18,080 --> 00:01:22,080
many of you guys probably know

00:01:20,159 --> 00:01:23,840
but i've been interested spanning a

00:01:22,080 --> 00:01:25,280
career from high performance computing i

00:01:23,840 --> 00:01:28,560
was this previous ceo

00:01:25,280 --> 00:01:30,560
of openmp mp to today

00:01:28,560 --> 00:01:31,680
doing a lot of work in terms of

00:01:30,560 --> 00:01:33,759
autonomous driving

00:01:31,680 --> 00:01:36,000
and safety so a lot of this talk comes

00:01:33,759 --> 00:01:36,479
from our collective experience in that

00:01:36,000 --> 00:01:38,880
space

00:01:36,479 --> 00:01:40,000
i'm also the chair of sg19 on machine

00:01:38,880 --> 00:01:42,560
learning

00:01:40,000 --> 00:01:43,119
and the chair of sg14 on games low

00:01:42,560 --> 00:01:45,280
latency

00:01:43,119 --> 00:01:47,200
finance embedded many of you guys out

00:01:45,280 --> 00:01:48,640
there know me and i really enjoy

00:01:47,200 --> 00:01:50,079
knowing you guys and been working

00:01:48,640 --> 00:01:52,320
together with you guys on many of these

00:01:50,079 --> 00:01:52,320
things

00:01:52,840 --> 00:01:58,320
so a bit of an acknowledgement of course

00:01:55,920 --> 00:01:59,439
um nothing a talk like this spanning

00:01:58,320 --> 00:02:01,040
many disciplines

00:01:59,439 --> 00:02:02,880
cannot happen without the help of so

00:02:01,040 --> 00:02:04,560
many many people and we're going to be

00:02:02,880 --> 00:02:06,159
using some images they'll have their own

00:02:04,560 --> 00:02:07,600
copyrights we're going to have company

00:02:06,159 --> 00:02:09,119
logos company products

00:02:07,600 --> 00:02:11,039
from other companies and we want to

00:02:09,119 --> 00:02:12,879
acknowledge and

00:02:11,039 --> 00:02:14,959
acknowledge their rights as well too but

00:02:12,879 --> 00:02:22,080
they're going to be any remaining errors

00:02:14,959 --> 00:02:23,599
and stupid mistakes those are all ours

00:02:22,080 --> 00:02:25,840
so we're going to talk about three

00:02:23,599 --> 00:02:27,680
things um we start with what if you

00:02:25,840 --> 00:02:29,840
can't test everything

00:02:27,680 --> 00:02:31,680
and then we go on to try to answer

00:02:29,840 --> 00:02:32,879
partially the question is c plus plus

00:02:31,680 --> 00:02:35,760
core guideline

00:02:32,879 --> 00:02:36,720
or misrec plus enough for concurrent

00:02:35,760 --> 00:02:38,000
safety

00:02:36,720 --> 00:02:39,840
and then finally we're going to talk

00:02:38,000 --> 00:02:42,480
about the work that we've been doing um

00:02:39,840 --> 00:02:44,239
as a group for the last two years on

00:02:42,480 --> 00:02:45,760
heading towards safe concurrency

00:02:44,239 --> 00:02:47,280
standards

00:02:45,760 --> 00:02:49,599
this is actually the first time we've

00:02:47,280 --> 00:02:50,000
revealed this we've had a collaborative

00:02:49,599 --> 00:02:53,200
group for

00:02:50,000 --> 00:02:55,280
quite some time so let's start

00:02:53,200 --> 00:02:56,480
so many of us here are engineers and

00:02:55,280 --> 00:02:58,400
computer scientists

00:02:56,480 --> 00:03:00,000
and of course as engineers and computer

00:02:58,400 --> 00:03:02,640
scientists we have been

00:03:00,000 --> 00:03:03,599
absolutely been trained to test and test

00:03:02,640 --> 00:03:05,680
everything

00:03:03,599 --> 00:03:06,800
we have so many different kinds of tests

00:03:05,680 --> 00:03:09,599
it's a major

00:03:06,800 --> 00:03:10,640
major department in any in any of our

00:03:09,599 --> 00:03:13,120
organizations

00:03:10,640 --> 00:03:13,760
from unit tests to black box white box

00:03:13,120 --> 00:03:16,480
tests

00:03:13,760 --> 00:03:18,080
in conformance tests integration tests

00:03:16,480 --> 00:03:21,200
systems as sniffed as

00:03:18,080 --> 00:03:22,720
sanity tests um

00:03:21,200 --> 00:03:23,840
these days of course there's also covet

00:03:22,720 --> 00:03:25,360
tests but we're not going to talk too

00:03:23,840 --> 00:03:28,159
much about that

00:03:25,360 --> 00:03:30,080
um what if so the question comes to mind

00:03:28,159 --> 00:03:32,000
is of course what if exhaustive testing

00:03:30,080 --> 00:03:34,720
is impossible

00:03:32,000 --> 00:03:35,519
that guy certainly looks exhausted it

00:03:34,720 --> 00:03:38,560
turns out that

00:03:35,519 --> 00:03:40,239
in many of our our reality um

00:03:38,560 --> 00:03:41,760
exhaustive testing is actually

00:03:40,239 --> 00:03:43,599
impossible even

00:03:41,760 --> 00:03:45,280
before you go to autonomous vehicles

00:03:43,599 --> 00:03:47,360
with non-autonomous vehicles

00:03:45,280 --> 00:03:48,879
there's simply too many possible faults

00:03:47,360 --> 00:03:50,959
some are intermittent

00:03:48,879 --> 00:03:53,280
some are operating conditions that has a

00:03:50,959 --> 00:03:55,360
timing consequence that only happens

00:03:53,280 --> 00:03:56,400
you know you can imagine the times when

00:03:55,360 --> 00:03:58,720
you bring your car

00:03:56,400 --> 00:04:00,400
in for surfacing for some trouble but it

00:03:58,720 --> 00:04:03,040
doesn't show up when you bring it to the

00:04:00,400 --> 00:04:04,640
dealership it's so frustrating

00:04:03,040 --> 00:04:07,599
it's you keep telling them it's there

00:04:04,640 --> 00:04:10,080
but when they try it it's not there

00:04:07,599 --> 00:04:11,280
autonomous vehicle testing brings up a

00:04:10,080 --> 00:04:13,519
whole new domain

00:04:11,280 --> 00:04:15,519
with machine learning algorithms and

00:04:13,519 --> 00:04:18,000
object identifications which can be

00:04:15,519 --> 00:04:18,560
which is now known to be brittle you you

00:04:18,000 --> 00:04:19,919
you paint

00:04:18,560 --> 00:04:22,000
you put a little bit of square tape on

00:04:19,919 --> 00:04:24,240
the stop sign and it stops

00:04:22,000 --> 00:04:27,199
being identified as a stop sign and

00:04:24,240 --> 00:04:29,040
that's just a very very simple tempering

00:04:27,199 --> 00:04:30,880
nuclear reactors can certainly have

00:04:29,040 --> 00:04:32,000
possible combinations of faults which

00:04:30,880 --> 00:04:35,120
are staggering

00:04:32,000 --> 00:04:36,880
um aircrafts can have huge effects from

00:04:35,120 --> 00:04:38,479
weather and human areas that are really

00:04:36,880 --> 00:04:40,240
hard to account for

00:04:38,479 --> 00:04:42,240
and medical has very complex

00:04:40,240 --> 00:04:44,320
interactions with other drugs

00:04:42,240 --> 00:04:45,440
and of course spacecraft deals with the

00:04:44,320 --> 00:04:48,400
unknown unknown

00:04:45,440 --> 00:04:49,040
besides the besides the known unknowns

00:04:48,400 --> 00:04:51,759
so

00:04:49,040 --> 00:04:51,759
what do we do

00:04:52,880 --> 00:04:58,400
well it's already commonly known how

00:04:56,000 --> 00:05:00,479
to reasonably solve this problem

00:04:58,400 --> 00:05:03,360
obviously you can't actually

00:05:00,479 --> 00:05:05,199
um remove all possible faults what you

00:05:03,360 --> 00:05:06,639
can do is build up something called a

00:05:05,199 --> 00:05:09,280
safety integrity

00:05:06,639 --> 00:05:10,000
level approach and what this is these

00:05:09,280 --> 00:05:12,880
are bins

00:05:10,000 --> 00:05:14,240
for levels of safety that is based on

00:05:12,880 --> 00:05:17,039
effects

00:05:14,240 --> 00:05:18,960
if the fault is not properly mitigated

00:05:17,039 --> 00:05:22,080
what it's saying is that if the failure

00:05:18,960 --> 00:05:23,600
results in poor controllability like you

00:05:22,080 --> 00:05:25,039
can't control the car anymore and i use

00:05:23,600 --> 00:05:27,840
automotive constantly because that's the

00:05:25,039 --> 00:05:30,160
domain that alien and i do work in

00:05:27,840 --> 00:05:31,360
as well as high performance computing

00:05:30,160 --> 00:05:34,320
but

00:05:31,360 --> 00:05:35,680
so then you have to then what that would

00:05:34,320 --> 00:05:38,960
demand is that it has to

00:05:35,680 --> 00:05:41,440
demand a low acceptable failure rate

00:05:38,960 --> 00:05:43,600
so something that's uncontrollable has

00:05:41,440 --> 00:05:45,039
to be extremely improbable we call that

00:05:43,600 --> 00:05:47,360
sil4

00:05:45,039 --> 00:05:49,199
something that's difficult to control

00:05:47,360 --> 00:05:52,160
has to be very remote

00:05:49,199 --> 00:05:52,560
and that's the sl3 and those two almost

00:05:52,160 --> 00:05:55,039
all

00:05:52,560 --> 00:05:56,560
most likely will result in death if your

00:05:55,039 --> 00:05:58,400
vehicle becomes uncontrollable or

00:05:56,560 --> 00:06:01,120
difficult to control

00:05:58,400 --> 00:06:02,080
something that's debilitating it should

00:06:01,120 --> 00:06:04,240
be remote

00:06:02,080 --> 00:06:06,319
and it's called sl2 something that's

00:06:04,240 --> 00:06:08,080
distracting like maybe i don't know your

00:06:06,319 --> 00:06:10,800
white put doesn't work anymore

00:06:08,080 --> 00:06:12,080
that's unlikely but it could happen but

00:06:10,800 --> 00:06:13,440
you know what if it doesn't

00:06:12,080 --> 00:06:15,919
happen if it does happen it probably

00:06:13,440 --> 00:06:17,360
won't kill you so it's a sil one

00:06:15,919 --> 00:06:19,199
and then and then finally going down

00:06:17,360 --> 00:06:21,039
even further there's the nuisance only

00:06:19,199 --> 00:06:24,160
type of controllability let's say

00:06:21,039 --> 00:06:25,759
i don't know maybe maybe your headlight

00:06:24,160 --> 00:06:27,600
maybe your door won't open or something

00:06:25,759 --> 00:06:29,360
like that okay so that's

00:06:27,600 --> 00:06:30,720
kind of a problem but it's a nuisance

00:06:29,360 --> 00:06:32,000
right you can maybe crawl through the

00:06:30,720 --> 00:06:34,560
window

00:06:32,000 --> 00:06:36,240
so the acceptable failure rate is that

00:06:34,560 --> 00:06:39,680
okay that's reasonably possible

00:06:36,240 --> 00:06:39,680
and it's sio zero

00:06:40,800 --> 00:06:45,280
in the in by the way sil zero is also

00:06:44,319 --> 00:06:47,759
something we're all

00:06:45,280 --> 00:06:49,520
fairly familiar with it's also known as

00:06:47,759 --> 00:06:52,000
iso 9001

00:06:49,520 --> 00:06:53,039
many many companies go through iso 9001

00:06:52,000 --> 00:06:56,319
just to get through

00:06:53,039 --> 00:06:57,599
at least sil zero um and that's because

00:06:56,319 --> 00:06:59,280
most of the processes

00:06:57,599 --> 00:07:01,120
that we go through don't need the higher

00:06:59,280 --> 00:07:02,880
level but some do if you're talking

00:07:01,120 --> 00:07:04,639
about braking system

00:07:02,880 --> 00:07:06,319
that's probably what right up there to

00:07:04,639 --> 00:07:07,840
slow three or four

00:07:06,319 --> 00:07:10,240
so the idea is that the whole thing

00:07:07,840 --> 00:07:12,960
doesn't have to be safe we selectively

00:07:10,240 --> 00:07:13,360
um demand certain amount of safety so

00:07:12,960 --> 00:07:16,400
here

00:07:13,360 --> 00:07:19,280
across the top you'll see that sr01 has

00:07:16,400 --> 00:07:21,120
a probability of failure on demand of

00:07:19,280 --> 00:07:23,440
something like

00:07:21,120 --> 00:07:25,759
of 10 to the 2 to 10 to the 1 and it

00:07:23,440 --> 00:07:28,560
keeps going up to sr4 where it's 10 to

00:07:25,759 --> 00:07:31,919
the 4 to 10 to the 5 probability

00:07:28,560 --> 00:07:33,280
and the risk reduction factor for sio1

00:07:31,919 --> 00:07:36,319
is 100 to 10

00:07:33,280 --> 00:07:40,240
was the risk reduction factor for sl4 is

00:07:36,319 --> 00:07:42,560
100 000 to 10 000.

00:07:40,240 --> 00:07:44,639
now then i followed on and lists several

00:07:42,560 --> 00:07:47,680
different domains

00:07:44,639 --> 00:07:50,720
so you have things like mizra automotive

00:07:47,680 --> 00:07:52,000
aviation and railway now most of these

00:07:50,720 --> 00:07:54,080
as it turns out

00:07:52,000 --> 00:07:56,400
follows the general process which has

00:07:54,080 --> 00:07:57,599
been encoded in 61508 the one in the

00:07:56,400 --> 00:08:00,000
middle

00:07:57,599 --> 00:08:01,840
and other ones duplicate on top of that

00:08:00,000 --> 00:08:03,360
there are specific levels miserable of

00:08:01,840 --> 00:08:06,160
course follows

00:08:03,360 --> 00:08:08,639
the general process of 61508 for style

00:08:06,160 --> 00:08:11,039
one two three and four

00:08:08,639 --> 00:08:12,080
automotive is very specific they have

00:08:11,039 --> 00:08:15,199
automotive safety

00:08:12,080 --> 00:08:17,919
integrity levels si ai asil

00:08:15,199 --> 00:08:18,560
and they have aiasioa which is just

00:08:17,919 --> 00:08:21,440
basically

00:08:18,560 --> 00:08:23,520
your your qa your quality of

00:08:21,440 --> 00:08:24,000
implementation that's your iso 9001

00:08:23,520 --> 00:08:28,639
level

00:08:24,000 --> 00:08:30,160
pushing all the way to asod at sll3

00:08:28,639 --> 00:08:33,360
okay so your braking system would

00:08:30,160 --> 00:08:35,599
probably be sild oh sorry asod

00:08:33,360 --> 00:08:37,680
your your wiper or your your light might

00:08:35,599 --> 00:08:39,839
be a best sr1

00:08:37,680 --> 00:08:41,120
okay uh many years ago there was this

00:08:39,839 --> 00:08:44,480
intel unintended

00:08:41,120 --> 00:08:46,320
um acceleration issue and that's um

00:08:44,480 --> 00:08:48,000
comfort by something called the electron

00:08:46,320 --> 00:08:50,800
electronic throttle

00:08:48,000 --> 00:08:52,560
control system etcs and that's

00:08:50,800 --> 00:08:54,720
definitely in the domain of sil3 i'll

00:08:52,560 --> 00:08:57,839
talk a little more about that

00:08:54,720 --> 00:08:59,360
but aviation also has the d-a-l-e

00:08:57,839 --> 00:09:01,600
except they go there they go the other

00:08:59,360 --> 00:09:05,120
way so it's d-a-d-a-l-d-e

00:09:01,600 --> 00:09:06,560
to d c d and a and railway and nuclear

00:09:05,120 --> 00:09:09,279
and medical all have them i'm not going

00:09:06,560 --> 00:09:13,920
to list them all

00:09:09,279 --> 00:09:15,680
so misra

00:09:13,920 --> 00:09:17,279
based on these sils actually have

00:09:15,680 --> 00:09:19,760
specific guidelines for

00:09:17,279 --> 00:09:21,760
required practices at various level so

00:09:19,760 --> 00:09:23,839
i'll just walk through some of the

00:09:21,760 --> 00:09:25,839
design if you're at sio1 the lowest

00:09:23,839 --> 00:09:28,320
level you have to have structure method

00:09:25,839 --> 00:09:30,080
if you're at sio2 you have to have add

00:09:28,320 --> 00:09:32,480
case tools on top of that

00:09:30,080 --> 00:09:34,080
and then at three now you need formal

00:09:32,480 --> 00:09:35,760
specifications for those functions at

00:09:34,080 --> 00:09:37,040
this level and therefore

00:09:35,760 --> 00:09:38,800
you have to have automated code

00:09:37,040 --> 00:09:40,240
generation when possible

00:09:38,800 --> 00:09:41,839
now let's go to the second which is the

00:09:40,240 --> 00:09:43,600
one that many of us are more familiar

00:09:41,839 --> 00:09:46,240
with languages and compilers

00:09:43,600 --> 00:09:47,360
for sio1 you need a structure a standard

00:09:46,240 --> 00:09:50,560
structural language

00:09:47,360 --> 00:09:52,720
for sil2 you need a restricted subset of

00:09:50,560 --> 00:09:54,240
a standardized structured language which

00:09:52,720 --> 00:09:57,040
is which is validated

00:09:54,240 --> 00:09:58,480
or tested compilers if possible that's

00:09:57,040 --> 00:10:01,839
kind of where mizra

00:09:58,480 --> 00:10:02,720
comes in and sl3 says it has to be same

00:10:01,839 --> 00:10:05,519
as 2

00:10:02,720 --> 00:10:07,680
sr4 says it has to be independently

00:10:05,519 --> 00:10:09,920
certified compilers with proven formal

00:10:07,680 --> 00:10:12,160
syntax and semantics you actually have

00:10:09,920 --> 00:10:14,720
to do formal verifications

00:10:12,160 --> 00:10:16,160
okay and then there's two more uh row

00:10:14,720 --> 00:10:17,200
that talks about what you have to do for

00:10:16,160 --> 00:10:19,200
your configuration

00:10:17,200 --> 00:10:21,040
management product and configuration

00:10:19,200 --> 00:10:22,399
management process i only took

00:10:21,040 --> 00:10:24,000
a few of these there's actually a long

00:10:22,399 --> 00:10:24,480
list of other things that you have to

00:10:24,000 --> 00:10:28,079
follow

00:10:24,480 --> 00:10:29,120
for each of those columns the key thing

00:10:28,079 --> 00:10:32,720
here is to note

00:10:29,120 --> 00:10:35,600
is that we think about this because

00:10:32,720 --> 00:10:36,720
in the world of safety uh two of the big

00:10:35,600 --> 00:10:39,360
things that happen

00:10:36,720 --> 00:10:41,279
um of concern is dynamic memory

00:10:39,360 --> 00:10:42,640
management and exception handling

00:10:41,279 --> 00:10:44,640
and of course in c plus plus and

00:10:42,640 --> 00:10:46,079
obviously exception handling defaults to

00:10:44,640 --> 00:10:47,279
dynamic memory management because that's

00:10:46,079 --> 00:10:49,040
one of the biggest issue

00:10:47,279 --> 00:10:52,800
of exception handling among many other

00:10:49,040 --> 00:10:52,800
ones if you've been to my sg14

00:10:52,880 --> 00:10:56,720
study group you'll know that we talk

00:10:54,560 --> 00:10:58,959
about both very a lot

00:10:56,720 --> 00:11:00,240
so what's the big deal there well i show

00:10:58,959 --> 00:11:02,959
here that

00:11:00,240 --> 00:11:04,399
they're actually in today's automobile

00:11:02,959 --> 00:11:06,640
they're actually

00:11:04,399 --> 00:11:08,240
you know in the past the wisdom was you

00:11:06,640 --> 00:11:09,920
shouldn't do any dynamic memory

00:11:08,240 --> 00:11:11,120
management in the car it should all be

00:11:09,920 --> 00:11:13,120
statically memory

00:11:11,120 --> 00:11:15,680
statically organized in other words

00:11:13,120 --> 00:11:18,560
after you turn the key to the ignition

00:11:15,680 --> 00:11:19,279
um you should not have any more dynamic

00:11:18,560 --> 00:11:22,079
memory

00:11:19,279 --> 00:11:23,200
access or creation you can do it before

00:11:22,079 --> 00:11:24,800
you turn the key

00:11:23,200 --> 00:11:26,560
but that's just simply not good enough

00:11:24,800 --> 00:11:28,560
today as you can see in the picture

00:11:26,560 --> 00:11:30,000
there are many many places that is now

00:11:28,560 --> 00:11:32,640
doing memory management

00:11:30,000 --> 00:11:33,680
we're talking about the the the ethernet

00:11:32,640 --> 00:11:36,800
the can bus

00:11:33,680 --> 00:11:38,880
the cockpit computer the a the adas

00:11:36,800 --> 00:11:40,399
um the pedestrian tracking system and

00:11:38,880 --> 00:11:42,720
especially you're talking about

00:11:40,399 --> 00:11:44,720
um convolution algorithms in machine

00:11:42,720 --> 00:11:47,200
learning that is using ai to do

00:11:44,720 --> 00:11:48,959
pedestrian detection and object tracking

00:11:47,200 --> 00:11:50,800
there's there's there's just too many

00:11:48,959 --> 00:11:51,760
places you have to be doing uh dynamic

00:11:50,800 --> 00:11:54,720
memory management

00:11:51,760 --> 00:11:55,440
so in other words it's now everywhere

00:11:54,720 --> 00:11:57,760
and yet

00:11:55,440 --> 00:11:59,279
if you look at the two major rules

00:11:57,760 --> 00:12:02,160
governing automotive

00:11:59,279 --> 00:12:04,079
one of them says miserable c plus says

00:12:02,160 --> 00:12:06,160
that dynamic memory managers show not

00:12:04,079 --> 00:12:09,040
shall not be used

00:12:06,160 --> 00:12:10,399
now that was built in 2008 auto saw

00:12:09,040 --> 00:12:10,800
which i'll talk a lot more about later

00:12:10,399 --> 00:12:13,839
on

00:12:10,800 --> 00:12:15,360
says you shall you have to allow it but

00:12:13,839 --> 00:12:16,079
only under these very specific

00:12:15,360 --> 00:12:18,000
conditions

00:12:16,079 --> 00:12:19,279
you have to be deterministic make sure

00:12:18,000 --> 00:12:22,399
that it results with

00:12:19,279 --> 00:12:24,160
uh with what they call wcet you know

00:12:22,399 --> 00:12:25,839
bounded by wcet

00:12:24,160 --> 00:12:27,120
you have to avoid memory fragmentation

00:12:25,839 --> 00:12:29,040
you have to work running out of memory

00:12:27,120 --> 00:12:30,560
you have to avoid mismatch allocations

00:12:29,040 --> 00:12:32,399
and don't call anybody else that has

00:12:30,560 --> 00:12:35,360
non-deterministic

00:12:32,399 --> 00:12:36,560
natures to them so how do you reconcile

00:12:35,360 --> 00:12:38,160
that

00:12:36,560 --> 00:12:39,760
well i'm going gonna show you how we how

00:12:38,160 --> 00:12:40,079
how we're planning to move forward with

00:12:39,760 --> 00:12:41,760
that

00:12:40,079 --> 00:12:43,680
and this is gonna be one of the major

00:12:41,760 --> 00:12:46,720
discussions uh going forward

00:12:43,680 --> 00:12:46,720
in terms of safety

00:12:47,600 --> 00:12:51,440
so continuing on i want to highlight one

00:12:50,240 --> 00:12:54,639
of the key things

00:12:51,440 --> 00:12:55,519
that is happening right now and this is

00:12:54,639 --> 00:12:57,040
something that most

00:12:55,519 --> 00:12:58,639
concurrency parallel experts or

00:12:57,040 --> 00:12:59,519
especially concurrency experts know and

00:12:58,639 --> 00:13:02,560
that has to do with

00:12:59,519 --> 00:13:03,200
race conditions it is simply when one

00:13:02,560 --> 00:13:05,519
cpu

00:13:03,200 --> 00:13:07,760
can have many tasks and the task takes

00:13:05,519 --> 00:13:10,320
to ensuring the cpu and memory

00:13:07,760 --> 00:13:11,920
and the concurrency defect comes when

00:13:10,320 --> 00:13:15,040
there's a timing difference

00:13:11,920 --> 00:13:16,480
at which one at which uh data there's

00:13:15,040 --> 00:13:18,800
some shared data in between

00:13:16,480 --> 00:13:20,240
that is both being read and written by

00:13:18,800 --> 00:13:22,160
both tasks

00:13:20,240 --> 00:13:23,680
and there's just there's such a timing

00:13:22,160 --> 00:13:25,440
difference between the read and write

00:13:23,680 --> 00:13:26,720
i don't know maybe one clock is faster

00:13:25,440 --> 00:13:30,480
or slower than the other

00:13:26,720 --> 00:13:33,360
such that um a write by task two

00:13:30,480 --> 00:13:34,480
here is overwritten by another right by

00:13:33,360 --> 00:13:35,839
task one

00:13:34,480 --> 00:13:37,200
now in a bank account that can be

00:13:35,839 --> 00:13:38,320
disastrous because it means that

00:13:37,200 --> 00:13:40,079
somebody's updating it

00:13:38,320 --> 00:13:41,519
you could be overwriting the update and

00:13:40,079 --> 00:13:43,199
now you lose the money that was

00:13:41,519 --> 00:13:45,120
previously updated

00:13:43,199 --> 00:13:46,639
because you were reading from a result

00:13:45,120 --> 00:13:49,680
that was previous to that

00:13:46,639 --> 00:13:51,839
update so in days

00:13:49,680 --> 00:13:54,160
past and still today one way to fix this

00:13:51,839 --> 00:13:57,279
is to disable interrupts before reading

00:13:54,160 --> 00:14:00,880
to ensure your task rewrites you know

00:13:57,279 --> 00:14:02,399
only one task rewrites at a time and

00:14:00,880 --> 00:14:04,399
if you don't do that then you're going

00:14:02,399 --> 00:14:05,839
to get some subtle defects

00:14:04,399 --> 00:14:07,680
now i don't know if you guys how many

00:14:05,839 --> 00:14:09,199
you guys were young enough to remember

00:14:07,680 --> 00:14:11,199
unintended acceleration it certainly

00:14:09,199 --> 00:14:12,639
made a lot of history

00:14:11,199 --> 00:14:14,320
um this had to do with the fact that

00:14:12,639 --> 00:14:15,120
there were many calls by a couple of

00:14:14,320 --> 00:14:16,079
companies

00:14:15,120 --> 00:14:18,720
i'm not gonna name them name you can

00:14:16,079 --> 00:14:20,480
look them up um that for some reason

00:14:18,720 --> 00:14:22,639
they were reporting that the cars would

00:14:20,480 --> 00:14:24,320
with excel with the throttle would would

00:14:22,639 --> 00:14:26,959
be stuck wide open

00:14:24,320 --> 00:14:28,800
and even though people were not um

00:14:26,959 --> 00:14:30,079
depressing the throttle at all

00:14:28,800 --> 00:14:31,839
in fact they were they were putting all

00:14:30,079 --> 00:14:34,399
their weight on the on the on the

00:14:31,839 --> 00:14:34,880
on on the break they swear up and down

00:14:34,399 --> 00:14:37,040
that

00:14:34,880 --> 00:14:38,959
that's what it was now i suffice to say

00:14:37,040 --> 00:14:42,079
that after numerous amounts of

00:14:38,959 --> 00:14:45,199
investigation one by nasa then then

00:14:42,079 --> 00:14:48,720
uh then another one

00:14:45,199 --> 00:14:51,440
the court eventually awarded um um

00:14:48,720 --> 00:14:51,839
fines to the companies involved and it

00:14:51,440 --> 00:14:53,600
all

00:14:51,839 --> 00:14:55,519
come down to the fact of this that they

00:14:53,600 --> 00:14:57,279
noticed that even though they did not

00:14:55,519 --> 00:14:59,440
find a smoking gun they find enough

00:14:57,279 --> 00:15:01,279
suspicions remember remember this is not

00:14:59,440 --> 00:15:04,240
a

00:15:01,279 --> 00:15:05,360
criminal trial the passing rate of a

00:15:04,240 --> 00:15:07,519
civil trial was a lot

00:15:05,360 --> 00:15:09,199
a little bit lower that there was enough

00:15:07,519 --> 00:15:09,760
evidence to point out that there were

00:15:09,199 --> 00:15:12,160
enough

00:15:09,760 --> 00:15:13,279
spaghetti code which resulted in enough

00:15:12,160 --> 00:15:15,839
which had a lot of

00:15:13,279 --> 00:15:17,920
a lot of shared gold global variables

00:15:15,839 --> 00:15:18,399
and they were all not accessed without

00:15:17,920 --> 00:15:20,480
being

00:15:18,399 --> 00:15:22,240
set to volatile without the interrupt

00:15:20,480 --> 00:15:23,600
mask being set so you read the bottom

00:15:22,240 --> 00:15:26,000
line it says they're only there

00:15:23,600 --> 00:15:29,360
865 users of interrupt masking in the

00:15:26,000 --> 00:15:30,959
code in 194 different source files

00:15:29,360 --> 00:15:32,399
and this indicates the access to global

00:15:30,959 --> 00:15:34,240
variables is not always done

00:15:32,399 --> 00:15:35,440
under the protection of interrupt mass

00:15:34,240 --> 00:15:37,360
and this has to do with the fact that

00:15:35,440 --> 00:15:38,160
the electronic throttle control system

00:15:37,360 --> 00:15:40,160
etcs

00:15:38,160 --> 00:15:42,320
has both a cpu chip and a monitoring

00:15:40,160 --> 00:15:42,959
chip and they would both interact with

00:15:42,320 --> 00:15:45,040
each other

00:15:42,959 --> 00:15:48,480
using global variables you can kind of

00:15:45,040 --> 00:15:52,560
imagine how that works out

00:15:48,480 --> 00:15:55,600
so in the automotive world we have

00:15:52,560 --> 00:15:57,120
we have always known that there is uh

00:15:55,600 --> 00:15:59,680
stringent safety and it's essentially

00:15:57,120 --> 00:16:02,079
governed by this document iso 26262 on

00:15:59,680 --> 00:16:03,519
road vehicles functional safety

00:16:02,079 --> 00:16:05,519
and in there if you think there's

00:16:03,519 --> 00:16:06,800
nothing to cover software you're wrong

00:16:05,519 --> 00:16:09,519
there are specific

00:16:06,800 --> 00:16:11,199
work task that covers software in terms

00:16:09,519 --> 00:16:13,120
of control flow analysis data flow

00:16:11,199 --> 00:16:16,800
analysis static code analysis

00:16:13,120 --> 00:16:18,399
static static analyze analysis based on

00:16:16,800 --> 00:16:19,759
abstract interpretation you see that

00:16:18,399 --> 00:16:22,480
under the aso levels

00:16:19,759 --> 00:16:24,000
under static code analysis it's a double

00:16:22,480 --> 00:16:27,360
plus which means you it is

00:16:24,000 --> 00:16:30,480
it is required okay that

00:16:27,360 --> 00:16:34,000
you follow um aso um

00:16:30,480 --> 00:16:36,079
in this area so

00:16:34,000 --> 00:16:37,759
let's step back and see what does our

00:16:36,079 --> 00:16:39,279
community offer well

00:16:37,759 --> 00:16:40,560
the two well-known guidelines i'm going

00:16:39,279 --> 00:16:41,360
to step back and talk a little bit about

00:16:40,560 --> 00:16:42,959
the history so

00:16:41,360 --> 00:16:44,720
the question that we're trying to answer

00:16:42,959 --> 00:16:45,199
is what's in the core guideline or even

00:16:44,720 --> 00:16:47,199
misery

00:16:45,199 --> 00:16:48,399
class was enough for concurrency for

00:16:47,199 --> 00:16:50,399
concurrent safety

00:16:48,399 --> 00:16:52,240
last year you saw a talk by me talking

00:16:50,399 --> 00:16:54,079
about misera

00:16:52,240 --> 00:16:55,279
sequential rule safety and they're all

00:16:54,079 --> 00:16:57,120
over it

00:16:55,279 --> 00:16:58,560
so here's what here's the current state

00:16:57,120 --> 00:17:00,240
of where that is right now

00:16:58,560 --> 00:17:01,680
the c plus source code guideline of

00:17:00,240 --> 00:17:04,000
course is

00:17:01,680 --> 00:17:05,919
wonderful it's a trend it allows you to

00:17:04,000 --> 00:17:07,600
transition from legacy c fossils code to

00:17:05,919 --> 00:17:09,439
modern c plus plus code

00:17:07,600 --> 00:17:11,760
there's an underlying idea that it

00:17:09,439 --> 00:17:14,559
provides static analysis tools

00:17:11,760 --> 00:17:16,079
um ability to warn some violations but

00:17:14,559 --> 00:17:18,640
also meta guidelines to improve

00:17:16,079 --> 00:17:20,400
efficiency performance and elegance

00:17:18,640 --> 00:17:22,240
and the philosophy there is to write

00:17:20,400 --> 00:17:24,799
modern c plus plus code

00:17:22,240 --> 00:17:26,640
okay and it's supported by the

00:17:24,799 --> 00:17:28,720
guidelines support library which i think

00:17:26,640 --> 00:17:30,799
is offered by microsoft and red hat

00:17:28,720 --> 00:17:32,559
and so that it allows you to do things

00:17:30,799 --> 00:17:34,640
like all aii but with

00:17:32,559 --> 00:17:35,600
things like finally safe narrowing

00:17:34,640 --> 00:17:40,400
contracts

00:17:35,600 --> 00:17:42,880
span okay um so

00:17:40,400 --> 00:17:43,840
some of these so what are those

00:17:42,880 --> 00:17:46,799
guidelines

00:17:43,840 --> 00:17:47,919
well those guidelines follow um 11

00:17:46,799 --> 00:17:49,440
philosophies

00:17:47,919 --> 00:17:50,799
and these philosophies are quite

00:17:49,440 --> 00:17:52,080
important and they'll be expressed

00:17:50,799 --> 00:17:54,480
throughout this talk

00:17:52,080 --> 00:17:55,200
this uh sorry this conference you know

00:17:54,480 --> 00:17:57,679
express

00:17:55,200 --> 00:17:59,200
directly inco ideas directly in code

00:17:57,679 --> 00:18:01,600
write an iso standard c

00:17:59,200 --> 00:18:03,440
plus plus express your intent ideally

00:18:01,600 --> 00:18:04,000
approach a program should be statically

00:18:03,440 --> 00:18:06,160
types

00:18:04,000 --> 00:18:08,240
type safe prefer compile time checking

00:18:06,160 --> 00:18:09,679
to run time checking

00:18:08,240 --> 00:18:11,440
and what cannot be checked the compile

00:18:09,679 --> 00:18:13,760
time should be checkable at runtime

00:18:11,440 --> 00:18:14,640
catch runtime errors early don't leak

00:18:13,760 --> 00:18:16,799
any resources

00:18:14,640 --> 00:18:17,919
don't waste time or space prefer

00:18:16,799 --> 00:18:20,720
immutable data

00:18:17,919 --> 00:18:22,640
encapsulate messy constructs rather than

00:18:20,720 --> 00:18:26,799
spreading them throughout the code

00:18:22,640 --> 00:18:28,000
it also covers a number of areas and i

00:18:26,799 --> 00:18:29,600
want to highlight the fact that of all

00:18:28,000 --> 00:18:33,039
these areas

00:18:29,600 --> 00:18:36,160
concurrency and parallelism actually is

00:18:33,039 --> 00:18:40,240
one of the least complete section okay

00:18:36,160 --> 00:18:43,360
um it starts off with about nine rules

00:18:40,240 --> 00:18:44,080
um that is mostly meta meta-ish type of

00:18:43,360 --> 00:18:45,520
rules

00:18:44,080 --> 00:18:48,559
then also then it breaks into

00:18:45,520 --> 00:18:50,559
sub-sections for concurrency parallelism

00:18:48,559 --> 00:18:52,320
message passing vectorization log-free

00:18:50,559 --> 00:18:53,120
programming and etc which is anything

00:18:52,320 --> 00:18:55,600
left over

00:18:53,120 --> 00:18:57,440
so under concurrency there's a fair bit

00:18:55,600 --> 00:18:59,760
of decent rules some of them pretty

00:18:57,440 --> 00:19:01,840
specific

00:18:59,760 --> 00:19:03,360
and then and then there's a whole bunch

00:19:01,840 --> 00:19:04,559
with question marks that have not been

00:19:03,360 --> 00:19:06,000
filled in yet because they don't know

00:19:04,559 --> 00:19:07,760
what to do with it when to use the spin

00:19:06,000 --> 00:19:09,280
lock when to use trilog because there

00:19:07,760 --> 00:19:12,640
just has not been enough concurrency

00:19:09,280 --> 00:19:15,039
experts adding to these so

00:19:12,640 --> 00:19:16,480
and under parallelism there's nothing

00:19:15,039 --> 00:19:18,640
under message passing there are two

00:19:16,480 --> 00:19:20,559
rules and two unfilled rules on message

00:19:18,640 --> 00:19:23,440
queues and messaging libraries

00:19:20,559 --> 00:19:24,559
under vectorization there's nothing um

00:19:23,440 --> 00:19:27,039
under the et cetera

00:19:24,559 --> 00:19:27,919
category there are two use volatile only

00:19:27,039 --> 00:19:30,400
to talk to non-c

00:19:27,919 --> 00:19:31,360
plus memory and something about signals

00:19:30,400 --> 00:19:33,039
under three

00:19:31,360 --> 00:19:34,640
under sorry under log free programming

00:19:33,039 --> 00:19:36,799
they're about one two three four

00:19:34,640 --> 00:19:37,919
five and a whole bunch of ones that have

00:19:36,799 --> 00:19:39,200
no links to them which means they

00:19:37,919 --> 00:19:41,200
haven't been filled in yet

00:19:39,200 --> 00:19:43,039
they need somebody to fill it in so if

00:19:41,200 --> 00:19:44,880
anything this this talk is also a call

00:19:43,039 --> 00:19:45,360
to arms to help with some of this some

00:19:44,880 --> 00:19:49,200
of this

00:19:45,360 --> 00:19:49,200
but i'll tell you what we've done okay

00:19:49,360 --> 00:19:53,280
so in summary i just want to point out

00:19:51,440 --> 00:19:54,480
that while the c plus score guidelines

00:19:53,280 --> 00:19:59,039
have been great

00:19:54,480 --> 00:20:00,480
um you need to take them with a bit of a

00:19:59,039 --> 00:20:01,600
grain of salt because there are some

00:20:00,480 --> 00:20:04,840
some area that is still

00:20:01,600 --> 00:20:07,520
somewhat disputed some editing required

00:20:04,840 --> 00:20:08,080
um but the one thing that i want to

00:20:07,520 --> 00:20:09,200
focus on

00:20:08,080 --> 00:20:12,080
is the fact that it needs more

00:20:09,200 --> 00:20:14,720
concurrency and parallelism

00:20:12,080 --> 00:20:15,760
and this is what we're planning to do so

00:20:14,720 --> 00:20:18,400
c plus plus

00:20:15,760 --> 00:20:20,000
undoubtedly is a complex language um the

00:20:18,400 --> 00:20:21,440
honor himself says that it makes it

00:20:20,000 --> 00:20:23,600
c makes it easier for you to shoot

00:20:21,440 --> 00:20:25,600
yourself in the foot but c plus plus

00:20:23,600 --> 00:20:27,600
makes it harder but when you do it blows

00:20:25,600 --> 00:20:29,200
your whole foot away

00:20:27,600 --> 00:20:31,280
well there are these many things that

00:20:29,200 --> 00:20:33,600
could be potentially

00:20:31,280 --> 00:20:35,200
um adds to the complexity not gonna go

00:20:33,600 --> 00:20:37,200
through them i think you kind of

00:20:35,200 --> 00:20:39,440
can pick out your favorite among amongst

00:20:37,200 --> 00:20:39,440
there

00:20:40,080 --> 00:20:44,080
now stepping back to see what are the

00:20:42,080 --> 00:20:44,480
safety critical guidelines i enumerate

00:20:44,080 --> 00:20:46,480
almost

00:20:44,480 --> 00:20:47,760
most of the ones that i know i know

00:20:46,480 --> 00:20:49,280
there might be one or two missing but

00:20:47,760 --> 00:20:50,960
here they are i highlight and read some

00:20:49,280 --> 00:20:53,520
of the most recent and

00:20:50,960 --> 00:20:55,120
probably the most um valuable ones that

00:20:53,520 --> 00:20:56,960
that that are still being

00:20:55,120 --> 00:20:59,039
attracting to the latest standard like

00:20:56,960 --> 00:21:00,000
mr c and c plus plus auto saw c plus

00:20:59,039 --> 00:21:02,480
plus guidelines

00:21:00,000 --> 00:21:04,320
and c plus plus core guidelines the rest

00:21:02,480 --> 00:21:05,200
have slowly fallen off because they

00:21:04,320 --> 00:21:06,880
either

00:21:05,200 --> 00:21:09,039
track to an older standard they're not

00:21:06,880 --> 00:21:11,679
being updated okay

00:21:09,039 --> 00:21:13,919
um on the right i track a bunch of

00:21:11,679 --> 00:21:16,960
standard that is related but not

00:21:13,919 --> 00:21:18,080
but but not specifically to coding so

00:21:16,960 --> 00:21:20,640
some of these standards

00:21:18,080 --> 00:21:22,799
have different intended target audience

00:21:20,640 --> 00:21:23,360
for instance misery are checkable rules

00:21:22,799 --> 00:21:26,159
only

00:21:23,360 --> 00:21:28,159
they need to do they have rules that are

00:21:26,159 --> 00:21:30,080
automatically statically checkable

00:21:28,159 --> 00:21:31,600
this is valuable because in a large code

00:21:30,080 --> 00:21:32,880
phase you can't actually

00:21:31,600 --> 00:21:34,880
read the whole code for all the

00:21:32,880 --> 00:21:35,840
violations you need something that's

00:21:34,880 --> 00:21:38,640
automatic

00:21:35,840 --> 00:21:42,480
autosol c plus is a mix and c plus

00:21:38,640 --> 00:21:42,480
what's called guidelines is also a mix

00:21:42,840 --> 00:21:46,080
okay

00:21:44,480 --> 00:21:47,840
so which one to choose and what is the

00:21:46,080 --> 00:21:49,360
difference well

00:21:47,840 --> 00:21:51,600
because of the various different stage

00:21:49,360 --> 00:21:54,240
of the guidelines if you want safe but

00:21:51,600 --> 00:21:56,320
not c plus plus 11 14 or 17 well you can

00:21:54,240 --> 00:21:57,440
either use the joint strike fighter

00:21:56,320 --> 00:22:00,080
which was done with the help of be

00:21:57,440 --> 00:22:02,080
honest trailstroke or you can

00:22:00,080 --> 00:22:03,440
use mizra c plus plus but it's based on

00:22:02,080 --> 00:22:05,280
00:22:03,440 --> 00:22:06,640
but it unfortunately because of its

00:22:05,280 --> 00:22:07,520
popularity and the fact that it was

00:22:06,640 --> 00:22:09,760
nearly the first

00:22:07,520 --> 00:22:11,520
it continued to be the reference by for

00:22:09,760 --> 00:22:12,080
every other safety guidelines going

00:22:11,520 --> 00:22:15,919
forward

00:22:12,080 --> 00:22:17,679
they all reach for that old standard

00:22:15,919 --> 00:22:19,200
but it's good in that it allows you and

00:22:17,679 --> 00:22:20,799
but many people still use it because in

00:22:19,200 --> 00:22:21,760
the embedded world compilers don't move

00:22:20,799 --> 00:22:24,559
that quickly

00:22:21,760 --> 00:22:26,159
so until recently there has not yet been

00:22:24,559 --> 00:22:28,159
the massive outcry that

00:22:26,159 --> 00:22:29,760
that's been required for them to update

00:22:28,159 --> 00:22:31,360
because people are now finding even the

00:22:29,760 --> 00:22:33,600
embedded compilers

00:22:31,360 --> 00:22:35,120
are moving forward to c plus 11 14 and

00:22:33,600 --> 00:22:37,679
17 but in the meantime

00:22:35,120 --> 00:22:39,520
for their code that is they they provide

00:22:37,679 --> 00:22:41,440
automatic static tools

00:22:39,520 --> 00:22:43,600
okay and now an aiming to the embedded

00:22:41,440 --> 00:22:45,600
domain then the one on the right are the

00:22:43,600 --> 00:22:47,120
sequel source 11 14 17 that's

00:22:45,600 --> 00:22:49,440
reasonably up to date but they're not

00:22:47,120 --> 00:22:49,919
safe so like high integrity c plus plus

00:22:49,440 --> 00:22:53,760
like

00:22:49,919 --> 00:22:55,280
search from cmu the core guidelines

00:22:53,760 --> 00:22:56,799
kog island is actually unique in that

00:22:55,280 --> 00:22:58,480
it's actually tracked to almost

00:22:56,799 --> 00:22:59,919
to the latest standard and it keeps

00:22:58,480 --> 00:23:03,520
moving um

00:22:59,919 --> 00:23:05,840
and wg23 a working group within sc22

00:23:03,520 --> 00:23:07,440
um is trying to track volts programming

00:23:05,840 --> 00:23:08,240
vulnerabilities and that's meant to be

00:23:07,440 --> 00:23:09,919
for team lead

00:23:08,240 --> 00:23:11,440
who might not know this language and

00:23:09,919 --> 00:23:14,720
they need to scan quickly

00:23:11,440 --> 00:23:18,799
and build their own guidelines

00:23:14,720 --> 00:23:21,360
there is one um that is both safe but

00:23:18,799 --> 00:23:23,440
only up to c plus plus 14 that's autosar

00:23:21,360 --> 00:23:25,039
but it's not being updated anymore

00:23:23,440 --> 00:23:26,320
because one of the effort of our group

00:23:25,039 --> 00:23:28,720
was to try to get make sure that we

00:23:26,320 --> 00:23:31,760
don't end up with two safety guidelines

00:23:28,720 --> 00:23:33,039
um we were able to merge um autosol and

00:23:31,760 --> 00:23:35,679
mizra so that

00:23:33,039 --> 00:23:37,600
it ended up everything is now in mizrah

00:23:35,679 --> 00:23:39,840
in the next update

00:23:37,600 --> 00:23:41,679
um ilya is here because he actually

00:23:39,840 --> 00:23:44,320
worked on the original autosol

00:23:41,679 --> 00:23:46,080
standard so comparing coding standard in

00:23:44,320 --> 00:23:48,320
this one slide you can see that

00:23:46,080 --> 00:23:50,320
autosar is c plus plus 14 it doesn't

00:23:48,320 --> 00:23:52,000
have any parallel sections mizra was c

00:23:50,320 --> 00:23:53,760
plus plus o3

00:23:52,000 --> 00:23:55,840
but we're working towards something that

00:23:53,760 --> 00:23:58,159
might cover c plus plus 17

00:23:55,840 --> 00:24:00,880
no parallel sections high integrity c

00:23:58,159 --> 00:24:03,600
plus plus is c plus plus 11

00:24:00,880 --> 00:24:05,200
it has some parallel sections joints jsf

00:24:03,600 --> 00:24:07,440
is c plus plus o3

00:24:05,200 --> 00:24:09,600
and it has none c plus plus core

00:24:07,440 --> 00:24:10,880
guideline is basically tracking whatever

00:24:09,600 --> 00:24:13,200
whatever is the latest

00:24:10,880 --> 00:24:15,520
and it has some parallel section and the

00:24:13,200 --> 00:24:18,320
search c plus plus is tracking the 14

00:24:15,520 --> 00:24:20,720
but it has very few rules regarding

00:24:18,320 --> 00:24:22,720
parallel and concurrency

00:24:20,720 --> 00:24:24,640
so let's step look at look at israel and

00:24:22,720 --> 00:24:26,000
why misra well israel essentially here's

00:24:24,640 --> 00:24:28,159
the origin of misra

00:24:26,000 --> 00:24:29,440
originally when ford and jaguar land

00:24:28,159 --> 00:24:32,000
rover asked

00:24:29,440 --> 00:24:32,960
in the uk asked to create something that

00:24:32,000 --> 00:24:35,600
would work in c

00:24:32,960 --> 00:24:36,559
so there's so that's when 1998 mr c was

00:24:35,600 --> 00:24:39,520
created

00:24:36,559 --> 00:24:40,159
that became the input to jsf to some

00:24:39,520 --> 00:24:43,679
degree

00:24:40,159 --> 00:24:46,400
a minor degree possibly um so

00:24:43,679 --> 00:24:48,640
um and then jsf became the input to

00:24:46,400 --> 00:24:50,320
mizra c plus plus 2008

00:24:48,640 --> 00:24:52,159
and something from the uk ministry of

00:24:50,320 --> 00:24:53,360
defense and along with miss the next

00:24:52,159 --> 00:24:56,640
revision of mizrah

00:24:53,360 --> 00:25:00,000
see smithers c is now up to misra c 2012

00:24:56,640 --> 00:25:00,720
okay and and this is a list of some of

00:25:00,000 --> 00:25:03,279
the

00:25:00,720 --> 00:25:03,919
the um the appearance right now there's

00:25:03,279 --> 00:25:06,960
the

00:25:03,919 --> 00:25:09,360
miser c has been revised 1998 2004

00:25:06,960 --> 00:25:11,120
it's and then 2012. and then miserable c

00:25:09,360 --> 00:25:12,159
plus plus was last reside revised in

00:25:11,120 --> 00:25:15,679
00:25:12,159 --> 00:25:17,520
with 228 rules of which 219 of them are

00:25:15,679 --> 00:25:19,440
statically enforceable

00:25:17,520 --> 00:25:22,960
and many compilers make their money on

00:25:19,440 --> 00:25:22,960
on this selling it to you

00:25:23,520 --> 00:25:27,279
you knew there was a commercial angle to

00:25:24,960 --> 00:25:29,360
that but i'm not involved in it

00:25:27,279 --> 00:25:30,799
c plus plus in safety critical there are

00:25:29,360 --> 00:25:32,400
many things that are good and the main

00:25:30,799 --> 00:25:34,480
thing that we inherited from c that

00:25:32,400 --> 00:25:36,880
has data that loopholes has to be

00:25:34,480 --> 00:25:40,080
covered by tools like mizra tools

00:25:36,880 --> 00:25:42,080
preprocessor you know undefined language

00:25:40,080 --> 00:25:43,440
undefined implementations and type

00:25:42,080 --> 00:25:45,440
systems multiple intelligence

00:25:43,440 --> 00:25:48,080
inheritance and dynamic memory on the

00:25:45,440 --> 00:25:49,440
good side c plus is undoubtedly good in

00:25:48,080 --> 00:25:53,200
the fact that it supplies you with

00:25:49,440 --> 00:25:53,760
rei compile time polymorphism regular

00:25:53,200 --> 00:25:55,760
types

00:25:53,760 --> 00:25:57,760
you might wonder why i think exceptions

00:25:55,760 --> 00:26:00,320
is good because i because and i do

00:25:57,760 --> 00:26:02,400
exceptions both c plus plus is suitable

00:26:00,320 --> 00:26:04,480
for both exceptions and error codes

00:26:02,400 --> 00:26:05,600
um tomorrow's talk when i talk about

00:26:04,480 --> 00:26:06,960
embedded programming i'm talking more

00:26:05,600 --> 00:26:07,840
about that but has been the chair of

00:26:06,960 --> 00:26:09,840
sg14

00:26:07,840 --> 00:26:11,919
we've come to the conclusion that c plus

00:26:09,840 --> 00:26:13,360
needs both exceptions and error codes

00:26:11,919 --> 00:26:14,960
i mean how do you how are you going to

00:26:13,360 --> 00:26:17,840
report errors coming out of

00:26:14,960 --> 00:26:19,440
constructors and operators right if not

00:26:17,840 --> 00:26:21,919
for exceptions

00:26:19,440 --> 00:26:23,760
there's smart pointers lambdas is good

00:26:21,919 --> 00:26:25,360
for safety critical because it allows

00:26:23,760 --> 00:26:26,880
you to throw away that lambda to a

00:26:25,360 --> 00:26:30,080
separate thread

00:26:26,880 --> 00:26:30,960
in a value capture so that there are no

00:26:30,080 --> 00:26:32,720
dangling

00:26:30,960 --> 00:26:34,320
um then there's parallel algorithms and

00:26:32,720 --> 00:26:36,080
of course 20 comes with contracts and

00:26:34,320 --> 00:26:39,840
concepts c plus first is moving in the

00:26:36,080 --> 00:26:39,840
right direction for safety critical

00:26:40,240 --> 00:26:44,640
so just to give you an idea about some

00:26:42,320 --> 00:26:47,120
examples that need safety net um i can't

00:26:44,640 --> 00:26:48,480
actually show you examples from israel

00:26:47,120 --> 00:26:49,919
because they are copyrighted i can't

00:26:48,480 --> 00:26:50,720
actually i shouldn't even be showing you

00:26:49,919 --> 00:26:52,880
the actual

00:26:50,720 --> 00:26:54,320
headlines to some extent but you can see

00:26:52,880 --> 00:26:55,840
that what they're looking for is to make

00:26:54,320 --> 00:26:58,159
sure that if you have an if else

00:26:55,840 --> 00:26:59,440
you have braces like properly enclosing

00:26:58,159 --> 00:27:02,000
them so that somebody can't

00:26:59,440 --> 00:27:03,840
intercede um a line following the else

00:27:02,000 --> 00:27:06,000
accidentally into the if else that's

00:27:03,840 --> 00:27:06,960
most of these these the sections the

00:27:06,000 --> 00:27:08,559
selection statements

00:27:06,960 --> 00:27:10,480
is talking about you know what kind of

00:27:08,559 --> 00:27:12,080
conditions you know and

00:27:10,480 --> 00:27:13,840
switch statements and things like that

00:27:12,080 --> 00:27:16,799
and certainly in the type system

00:27:13,840 --> 00:27:17,760
um this is one of the loopholes you know

00:27:16,799 --> 00:27:20,000
this because c plus

00:27:17,760 --> 00:27:21,120
standard doesn't define fixed sizes for

00:27:20,000 --> 00:27:22,880
built-in types

00:27:21,120 --> 00:27:24,799
it makes it hard to write portable code

00:27:22,880 --> 00:27:25,600
requiring fixed size integer now that's

00:27:24,799 --> 00:27:27,279
obviously being

00:27:25,600 --> 00:27:29,120
addressed and being fixed right now

00:27:27,279 --> 00:27:30,000
there are quite a few sg14 proposals in

00:27:29,120 --> 00:27:32,799
that direction

00:27:30,000 --> 00:27:33,360
and i'll talk about that tomorrow so c

00:27:32,799 --> 00:27:36,080
plus was

00:27:33,360 --> 00:27:36,559
there's all the arithmetic operations in

00:27:36,080 --> 00:27:38,240
either

00:27:36,559 --> 00:27:39,840
in or long depending on the original

00:27:38,240 --> 00:27:44,720
operand

00:27:39,840 --> 00:27:46,799
so here in this case this can um

00:27:44,720 --> 00:27:48,720
because of the promotion this can easily

00:27:46,799 --> 00:27:49,600
lead to non-portable code so here in the

00:27:48,720 --> 00:27:51,760
following here

00:27:49,600 --> 00:27:53,279
on a system where end is 32 bits and

00:27:51,760 --> 00:27:55,679
short is 16 bits

00:27:53,279 --> 00:27:56,799
the result is going to be 80 000 but as

00:27:55,679 --> 00:27:58,240
one would expect

00:27:56,799 --> 00:28:00,320
considering that the multiplication is

00:27:58,240 --> 00:28:01,520
going to carry out and both operands

00:28:00,320 --> 00:28:03,520
promoted to end

00:28:01,520 --> 00:28:05,679
however on a system where in this just

00:28:03,520 --> 00:28:07,039
16 bits the results will be undefined

00:28:05,679 --> 00:28:07,919
because the multiplication is going to

00:28:07,039 --> 00:28:11,360
be carried out

00:28:07,919 --> 00:28:12,880
in 16 bits and the result sorry in in um

00:28:11,360 --> 00:28:14,399
carry on six and then and then there

00:28:12,880 --> 00:28:16,559
will be an overflow

00:28:14,399 --> 00:28:18,960
and so then only the wrong result will

00:28:16,559 --> 00:28:21,200
then be converted to n32

00:28:18,960 --> 00:28:22,960
so this is a bit of uh this is what um

00:28:21,200 --> 00:28:24,799
the mizra will try to

00:28:22,960 --> 00:28:26,799
help you to identify and then it's up to

00:28:24,799 --> 00:28:28,159
you whether you want to fix it or not

00:28:26,799 --> 00:28:30,000
because they have different levels which

00:28:28,159 --> 00:28:31,360
ilia is going to explain so let's look

00:28:30,000 --> 00:28:32,960
at the pedigree again c plus plus with

00:28:31,360 --> 00:28:36,240
safety critical api

00:28:32,960 --> 00:28:38,080
um in c plus 98 and all three we got

00:28:36,240 --> 00:28:39,520
things like inheritance exceptions and

00:28:38,080 --> 00:28:41,520
template stl

00:28:39,520 --> 00:28:43,440
and based on that we built miserable

00:28:41,520 --> 00:28:46,480
2008 which came in c plus

00:28:43,440 --> 00:28:47,360
was covered 98 and o3 then 11 we got

00:28:46,480 --> 00:28:50,720
things like auto

00:28:47,360 --> 00:28:52,080
lambda concurrency move and futures and

00:28:50,720 --> 00:28:53,679
all through that time there's been no

00:28:52,080 --> 00:28:56,399
update to mizrah howev and that's when

00:28:53,679 --> 00:28:57,760
otto saw came in and said hey look guys

00:28:56,399 --> 00:28:59,679
we really need something that covers

00:28:57,760 --> 00:29:01,200
more recent c plus plus because the

00:28:59,679 --> 00:29:03,120
embedded tools are moving up

00:29:01,200 --> 00:29:05,760
so they got something that covers c plus

00:29:03,120 --> 00:29:07,600
14 in 2017

00:29:05,760 --> 00:29:09,679
but by 17 we already got things like

00:29:07,600 --> 00:29:11,360
template deductions compile time if

00:29:09,679 --> 00:29:14,480
parallel stl

00:29:11,360 --> 00:29:14,799
so in 2019 our group moved to help otto

00:29:14,480 --> 00:29:16,720
saw

00:29:14,799 --> 00:29:18,399
join with mizrah remember also actually

00:29:16,720 --> 00:29:19,919
came to this conference once or twice

00:29:18,399 --> 00:29:20,640
asking if we wanted to take over that

00:29:19,919 --> 00:29:23,760
standard

00:29:20,640 --> 00:29:25,200
and and the c plus one standard said uh

00:29:23,760 --> 00:29:27,120
no we're not we're not doing

00:29:25,200 --> 00:29:28,320
this is not part of our job but there

00:29:27,120 --> 00:29:29,840
are people out there who are good at

00:29:28,320 --> 00:29:30,799
these kinds of jobs and so miser and

00:29:29,840 --> 00:29:32,399
autosar

00:29:30,799 --> 00:29:34,799
amicably agree that this should be a

00:29:32,399 --> 00:29:36,480
joint uh committee

00:29:34,799 --> 00:29:39,039
so in 20 we're going to get things like

00:29:36,480 --> 00:29:41,279
modules concepts co-routines and ranges

00:29:39,039 --> 00:29:42,320
and so the next miserable that comes out

00:29:41,279 --> 00:29:45,520
will be joined from

00:29:42,320 --> 00:29:48,399
with misread and otto saw and

00:29:45,520 --> 00:29:50,080
it could be aiming for c plus plus 17 i

00:29:48,399 --> 00:29:51,440
hope

00:29:50,080 --> 00:29:53,360
that many of our current committee

00:29:51,440 --> 00:29:55,039
members are now joining misra

00:29:53,360 --> 00:29:57,360
when i first joined israel it was like

00:29:55,039 --> 00:29:58,880
five people now there are 15 of us 10 of

00:29:57,360 --> 00:30:00,399
us are actually from the c plus plus

00:29:58,880 --> 00:30:01,840
standard commit so i think

00:30:00,399 --> 00:30:03,840
we're hoping that that will result in a

00:30:01,840 --> 00:30:05,600
much stronger standard so what's still

00:30:03,840 --> 00:30:07,679
missing in the safety guidelines

00:30:05,600 --> 00:30:09,279
so far mostly only deal with sequential

00:30:07,679 --> 00:30:11,039
code as you can see there are very few

00:30:09,279 --> 00:30:13,039
that deal with parallel code

00:30:11,039 --> 00:30:14,720
even fewer deal with concurrent avenger

00:30:13,039 --> 00:30:16,480
inco and none of them actually deal with

00:30:14,720 --> 00:30:18,320
heterogeneous dispatch and the rest of

00:30:16,480 --> 00:30:20,000
this talk is going to show you a path

00:30:18,320 --> 00:30:22,399
that we hope will lead in that direction

00:30:20,000 --> 00:30:25,760
because the industry badly needs it

00:30:22,399 --> 00:30:27,679
as a reminder um this injecting of

00:30:25,760 --> 00:30:29,120
injection of safe concurrency rules is a

00:30:27,679 --> 00:30:30,720
work in progress

00:30:29,120 --> 00:30:32,480
and many of these rules have not been

00:30:30,720 --> 00:30:33,679
merged yet and can still change and this

00:30:32,480 --> 00:30:35,200
is why we can talk about it because

00:30:33,679 --> 00:30:37,520
they're not in misery yet so

00:30:35,200 --> 00:30:38,399
we um ili and i can actually talk about

00:30:37,520 --> 00:30:39,919
these things

00:30:38,399 --> 00:30:41,360
however we are actually highlighting

00:30:39,919 --> 00:30:42,880
this so they're calling it out so that

00:30:41,360 --> 00:30:44,880
if you want to give your feedback on

00:30:42,880 --> 00:30:47,600
what you prefer as a safety rule

00:30:44,880 --> 00:30:48,559
you can certainly join our group um so

00:30:47,600 --> 00:30:50,640
at this point

00:30:48,559 --> 00:30:54,000
i would like to turn it over to my

00:30:50,640 --> 00:30:54,000
colleague elia thank you

00:30:57,679 --> 00:31:04,080
okay so why can't currency

00:31:00,720 --> 00:31:06,000
in parallel autonomous

00:31:04,080 --> 00:31:07,760
driving vehicles require more and more

00:31:06,000 --> 00:31:10,640
computational resources

00:31:07,760 --> 00:31:12,559
and this is why can highly parallel

00:31:10,640 --> 00:31:16,399
concurrent and heterogeneous

00:31:12,559 --> 00:31:17,919
system come in we

00:31:16,399 --> 00:31:20,399
will need more machine learning

00:31:17,919 --> 00:31:21,519
algorithms which will detect objects in

00:31:20,399 --> 00:31:26,080
real time

00:31:21,519 --> 00:31:29,919
and for trajectory planning as well

00:31:26,080 --> 00:31:33,840
many hd devices such as medical

00:31:29,919 --> 00:31:38,240
devices will need to do real-time safe

00:31:33,840 --> 00:31:41,679
decisions drones

00:31:38,240 --> 00:31:42,799
are also flying and a part of safety

00:31:41,679 --> 00:31:46,320
rules

00:31:42,799 --> 00:31:49,440
regulations so with that we need more

00:31:46,320 --> 00:31:52,559
and more concurrency and paralysis rules

00:31:49,440 --> 00:31:53,200
we started this effort around two years

00:31:52,559 --> 00:31:57,120
ago

00:31:53,200 --> 00:31:59,120
and currently this is a list of people

00:31:57,120 --> 00:32:02,480
who are

00:31:59,120 --> 00:32:07,039
involved in that there are war group 21

00:32:02,480 --> 00:32:10,080
uh sg-1 members there is a work group 23

00:32:07,039 --> 00:32:12,880
paralysis vulnerability members

00:32:10,080 --> 00:32:13,679
here and here is the list of individuals

00:32:12,880 --> 00:32:15,840
which are

00:32:13,679 --> 00:32:19,200
currently actively working on this set

00:32:15,840 --> 00:32:19,200
of rules for parallelism

00:32:21,919 --> 00:32:28,240
here you can see the

00:32:25,279 --> 00:32:30,000
screenshot of the table of contents for

00:32:28,240 --> 00:32:33,760
the current document which we are

00:32:30,000 --> 00:32:36,799
working on uh this is just

00:32:33,760 --> 00:32:38,399
uh to have to give you an idea of how we

00:32:36,799 --> 00:32:42,960
are working on

00:32:38,399 --> 00:32:46,320
and with that we came to the 81 rule

00:32:42,960 --> 00:32:47,519
as of now within nine sections we have a

00:32:46,320 --> 00:32:51,039
dedicated section

00:32:47,519 --> 00:32:52,399
for threads for mutexes for conditional

00:32:51,039 --> 00:32:55,519
variables

00:32:52,399 --> 00:32:59,039
for atomic or future

00:32:55,519 --> 00:33:02,720
for volatile operations

00:32:59,039 --> 00:33:03,600
we have more meta rules for log-free

00:33:02,720 --> 00:33:06,000
programming

00:33:03,600 --> 00:33:11,840
general parallelism and interaction

00:33:06,000 --> 00:33:11,840
between the tasks

00:33:12,480 --> 00:33:17,039
this effort mainly is uh driven by the

00:33:16,159 --> 00:33:20,000
idea that

00:33:17,039 --> 00:33:22,000
some specific rules will go to misra and

00:33:20,000 --> 00:33:25,120
where group 23.

00:33:22,000 --> 00:33:28,240
some materials will come to oc plus plus

00:33:25,120 --> 00:33:30,320
core guidelines with the help of work

00:33:28,240 --> 00:33:35,440
group 23

00:33:30,320 --> 00:33:38,080
and uh we also finding some defects

00:33:35,440 --> 00:33:39,279
we are cross checking of all the rules

00:33:38,080 --> 00:33:42,480
and the current c

00:33:39,279 --> 00:33:45,679
plus plus standard which we actually go

00:33:42,480 --> 00:33:49,679
to fixing to work group 21

00:33:45,679 --> 00:33:52,480
draft the rest of the talk will be

00:33:49,679 --> 00:33:53,440
focused on demonstrating some specific

00:33:52,480 --> 00:33:56,080
rules

00:33:53,440 --> 00:33:57,200
which are decidable or hard disabled

00:33:56,080 --> 00:34:00,320
decidable

00:33:57,200 --> 00:34:01,360
some materials some rules which feed

00:34:00,320 --> 00:34:04,720
better mitra

00:34:01,360 --> 00:34:08,079
guidelines or core guidelines some rules

00:34:04,720 --> 00:34:11,520
which are wrong or that show defects

00:34:08,079 --> 00:34:11,520
in c plus plus standard

00:34:12,560 --> 00:34:17,359
general rules in misra follow this

00:34:15,520 --> 00:34:20,560
following structure

00:34:17,359 --> 00:34:22,800
there is a key rule statement which

00:34:20,560 --> 00:34:24,480
describes the essence of the rule there

00:34:22,800 --> 00:34:27,760
is a category

00:34:24,480 --> 00:34:31,440
on that array required advisory which

00:34:27,760 --> 00:34:35,359
explains how much efforts you should put

00:34:31,440 --> 00:34:38,800
to avoid using this rule in your code

00:34:35,359 --> 00:34:39,520
within mandatory category you are not

00:34:38,800 --> 00:34:42,800
allowed

00:34:39,520 --> 00:34:45,760
to violate the rule

00:34:42,800 --> 00:34:47,119
in the required category each violated

00:34:45,760 --> 00:34:49,679
rule will require

00:34:47,119 --> 00:34:51,679
a specific written deviation in your

00:34:49,679 --> 00:34:55,200
safety case

00:34:51,679 --> 00:34:58,720
within advisory rule you

00:34:55,200 --> 00:35:01,599
have more freedom to avoid using this

00:34:58,720 --> 00:35:05,680
rule in your specific code

00:35:01,599 --> 00:35:09,040
the next thing is analysis

00:35:05,680 --> 00:35:11,520
it shows the rule from the perspective

00:35:09,040 --> 00:35:14,720
for static analysis tool

00:35:11,520 --> 00:35:18,240
whether it is decidable or undecidable

00:35:14,720 --> 00:35:20,640
means if your static analysis tool

00:35:18,240 --> 00:35:23,119
or some static analysis tool can

00:35:20,640 --> 00:35:26,160
possibly detect this

00:35:23,119 --> 00:35:29,760
thing in the code and within scope

00:35:26,160 --> 00:35:32,160
means whether

00:35:29,760 --> 00:35:32,800
single translation unit is enough to

00:35:32,160 --> 00:35:35,359
understand

00:35:32,800 --> 00:35:35,920
for the tool to understand that the rule

00:35:35,359 --> 00:35:39,760
is

00:35:35,920 --> 00:35:40,720
violated or the tool should have a

00:35:39,760 --> 00:35:45,119
visibility

00:35:40,720 --> 00:35:48,800
on the application level rationale

00:35:45,119 --> 00:35:52,640
gives the reason for this rule to exist

00:35:48,800 --> 00:35:53,920
in a safety case some rules have

00:35:52,640 --> 00:35:56,240
exceptions

00:35:53,920 --> 00:35:58,320
where the rule is not applicable in

00:35:56,240 --> 00:36:02,480
certain cases

00:35:58,320 --> 00:36:05,520
and almost any rule has an example of

00:36:02,480 --> 00:36:07,440
the code which is

00:36:05,520 --> 00:36:12,160
compliant and non-compliant with the

00:36:07,440 --> 00:36:14,720
given rule

00:36:12,160 --> 00:36:16,480
is an example of the rule from the

00:36:14,720 --> 00:36:20,880
thread section

00:36:16,480 --> 00:36:20,880
do not call std thread detach function

00:36:22,960 --> 00:36:26,160
the main reason for this rule is the

00:36:25,440 --> 00:36:28,560
analysis

00:36:26,160 --> 00:36:30,400
of the lifetime of the resources

00:36:28,560 --> 00:36:33,040
connected with the thread

00:36:30,400 --> 00:36:35,520
is much more difficult when the detach

00:36:33,040 --> 00:36:35,520
is used

00:36:36,640 --> 00:36:40,800
this is why the category for this rule

00:36:39,760 --> 00:36:43,280
is required

00:36:40,800 --> 00:36:44,400
meaning you need to write a formal

00:36:43,280 --> 00:36:47,920
deviation

00:36:44,400 --> 00:36:50,320
within your safety code

00:36:47,920 --> 00:36:51,440
and provide the reason why your code

00:36:50,320 --> 00:36:54,880
still

00:36:51,440 --> 00:36:58,000
is still safe

00:36:54,880 --> 00:37:01,200
it is decidable that is

00:36:58,000 --> 00:37:05,200
if the static analysis tool finds the

00:37:01,200 --> 00:37:08,480
call for thread for the touch function

00:37:05,200 --> 00:37:09,040
it means the rule is violated and it can

00:37:08,480 --> 00:37:11,440
be done

00:37:09,040 --> 00:37:12,480
on the level of the single translation

00:37:11,440 --> 00:37:14,400
unit

00:37:12,480 --> 00:37:16,160
the tool doesn't need to know anything

00:37:14,400 --> 00:37:16,880
about other parts of your program to

00:37:16,160 --> 00:37:22,240
understand

00:37:16,880 --> 00:37:25,280
that here the detach function is called

00:37:22,240 --> 00:37:27,520
the rule has uh different sources

00:37:25,280 --> 00:37:29,280
four guidelines have don't detach a

00:37:27,520 --> 00:37:33,280
thread rule

00:37:29,280 --> 00:37:36,800
uh guidelines

00:37:33,280 --> 00:37:40,160
high integrity c plus plus rules and

00:37:36,800 --> 00:37:42,000
the c plus plus 20 have somewhat

00:37:40,160 --> 00:37:45,119
connected rules about

00:37:42,000 --> 00:37:48,240
using std

00:37:45,119 --> 00:37:51,839
thread replacement which will join

00:37:48,240 --> 00:37:51,839
on the destruction

00:37:53,680 --> 00:37:57,119
here is another rule from the mutex

00:37:55,839 --> 00:37:59,680
section

00:37:57,119 --> 00:38:01,440
the order of nested logs shall form a

00:37:59,680 --> 00:38:04,720
deck

00:38:01,440 --> 00:38:08,000
it is an example of the rule which is

00:38:04,720 --> 00:38:10,079
theoretically decidable but two will

00:38:08,000 --> 00:38:12,800
need to observe the whole code base to

00:38:10,079 --> 00:38:18,800
understand whether

00:38:12,800 --> 00:38:22,079
you have a violation of this rule

00:38:18,800 --> 00:38:25,200
this rule has

00:38:22,079 --> 00:38:28,560
roots from high integrity c plus plus

00:38:25,200 --> 00:38:31,599
where it is almost exactly the same

00:38:28,560 --> 00:38:32,720
also search rule has a very similar

00:38:31,599 --> 00:38:36,000
nature

00:38:32,720 --> 00:38:40,720
of avoiding the lock

00:38:36,000 --> 00:38:40,720
by using locking in predefined order

00:38:44,160 --> 00:38:54,720
here is an example of for another rule

00:38:49,359 --> 00:38:54,720
it is almost meta level rule

00:38:54,800 --> 00:39:01,680
and uh its source is

00:38:58,320 --> 00:39:02,320
uh c plus plus cogai lines where the

00:39:01,680 --> 00:39:05,280
rule

00:39:02,320 --> 00:39:07,920
was a thinking template of task rather

00:39:05,280 --> 00:39:11,920
than threads

00:39:07,920 --> 00:39:14,160
a very meta meta description

00:39:11,920 --> 00:39:15,280
we translated this role into the most

00:39:14,160 --> 00:39:18,880
specific

00:39:15,280 --> 00:39:18,880
do not use std thread

00:39:19,440 --> 00:39:26,079
in order to try to push people

00:39:22,960 --> 00:39:26,880
using higher level apis such as stds

00:39:26,079 --> 00:39:32,560
sync

00:39:26,880 --> 00:39:32,560
or algorithms with execution policies

00:39:34,000 --> 00:39:37,920
parallel or parasec

00:39:39,200 --> 00:39:46,480
this rule is of advisory level

00:39:42,320 --> 00:39:49,119
so if you still want to use std threat

00:39:46,480 --> 00:39:50,079
you don't have to put too much effort to

00:39:49,119 --> 00:39:54,160
explain why

00:39:50,079 --> 00:39:54,160
in your safety related project

00:39:54,480 --> 00:39:58,240
it is easy to detect by the tool

00:39:59,040 --> 00:40:03,760
but it has a specific exception

00:40:05,359 --> 00:40:09,760
if you're accessing native thread

00:40:08,000 --> 00:40:12,800
handler

00:40:09,760 --> 00:40:15,520
to do some specific threads

00:40:12,800 --> 00:40:18,560
specific work such as changing the

00:40:15,520 --> 00:40:18,560
priority of the thread

00:40:19,359 --> 00:40:25,760
then this rule becomes non-applicable

00:40:23,200 --> 00:40:27,280
with that static analysis tool we'll

00:40:25,760 --> 00:40:30,560
need to detect

00:40:27,280 --> 00:40:34,640
the access to the native thread handle

00:40:30,560 --> 00:40:39,839
in order to accurately fulfill

00:40:34,640 --> 00:40:39,839
and check this rule

00:40:40,000 --> 00:40:43,760
and here is an example of the rule in

00:40:42,160 --> 00:40:47,200
the atomic section

00:40:43,760 --> 00:40:48,880
which we currently have a significant

00:40:47,200 --> 00:40:52,000
debate on

00:40:48,880 --> 00:40:54,560
use only std memory

00:40:52,000 --> 00:40:57,200
order sequentially consistent for atomic

00:40:54,560 --> 00:40:57,200
operations

00:40:57,280 --> 00:41:00,720
we have more or less agreement that is a

00:40:59,520 --> 00:41:03,760
good rule

00:41:00,720 --> 00:41:06,640
but there is ongoing debate of the

00:41:03,760 --> 00:41:10,880
category for this rule whether it should

00:41:06,640 --> 00:41:10,880
be mandatory or quiet or advisory

00:41:11,119 --> 00:41:14,079
there is also

00:41:16,160 --> 00:41:25,119
many use cases where there is a

00:41:19,599 --> 00:41:27,920
reason to use more relaxed memory orders

00:41:25,119 --> 00:41:30,079
with that there is a idea is to put a

00:41:27,920 --> 00:41:33,040
set of exceptions

00:41:30,079 --> 00:41:34,000
that in certain cases in order to get

00:41:33,040 --> 00:41:37,680
more performance

00:41:34,000 --> 00:41:40,800
you may use other

00:41:37,680 --> 00:41:43,520
uh other uh more orders

00:41:40,800 --> 00:41:45,440
but with that if you put all these

00:41:43,520 --> 00:41:48,800
exceptions in place

00:41:45,440 --> 00:41:53,040
the rules becomes non-decidable

00:41:48,800 --> 00:41:53,040
because the main problem with that

00:41:53,760 --> 00:42:02,079
all these exceptions apply when there is

00:41:57,520 --> 00:42:04,800
uh some when they

00:42:02,079 --> 00:42:08,560
user have some intention which is not

00:42:04,800 --> 00:42:08,560
visible to the static analysis tool

00:42:12,800 --> 00:42:16,160
here's another example of the rule which

00:42:15,440 --> 00:42:20,480
we looked

00:42:16,160 --> 00:42:23,359
through from c plus plus cogai lines

00:42:20,480 --> 00:42:25,280
and dropped this is don't use log free

00:42:23,359 --> 00:42:26,800
programming unless you absolutely have

00:42:25,280 --> 00:42:29,200
to

00:42:26,800 --> 00:42:30,560
the reason from c plus plus co

00:42:29,200 --> 00:42:32,560
guidelines was

00:42:30,560 --> 00:42:33,599
it is error prone and require expert

00:42:32,560 --> 00:42:36,640
level knowledge

00:42:33,599 --> 00:42:36,640
of language features

00:42:38,240 --> 00:42:43,280
kogi lines have an exception of using

00:42:40,480 --> 00:42:48,240
atomic variables in this case

00:42:43,280 --> 00:42:51,520
which which makes this

00:42:48,240 --> 00:42:55,040
simple and not require expert level

00:42:51,520 --> 00:42:56,319
knowledge we looked at this rule and

00:42:55,040 --> 00:42:58,880
decided that

00:42:56,319 --> 00:43:00,480
it is too metal level four considered at

00:42:58,880 --> 00:43:02,160
misery level

00:43:00,480 --> 00:43:04,400
and there is no any chance to make it

00:43:02,160 --> 00:43:06,560
decidable

00:43:04,400 --> 00:43:07,839
and with regards to atomic concern it is

00:43:06,560 --> 00:43:10,960
already discussed in

00:43:07,839 --> 00:43:14,400
other sections of the

00:43:10,960 --> 00:43:15,520
see that guidelines so with that

00:43:14,400 --> 00:43:18,400
consideration we

00:43:15,520 --> 00:43:20,720
drop this rule from from this from our

00:43:18,400 --> 00:43:20,720
scope

00:43:22,560 --> 00:43:26,079
and the next one is an example of the

00:43:25,680 --> 00:43:29,440
rule

00:43:26,079 --> 00:43:33,119
which we may consider

00:43:29,440 --> 00:43:36,240
as a reason to review the

00:43:33,119 --> 00:43:38,800
c plus plus draft

00:43:36,240 --> 00:43:39,520
is it may have some issues and michael

00:43:38,800 --> 00:43:42,880
can

00:43:39,520 --> 00:43:45,920
explain later ah thank you

00:43:42,880 --> 00:43:45,920
thank you yeah

00:43:46,960 --> 00:43:51,280
so actually i want to go back to this

00:43:48,800 --> 00:43:52,720
particular rule um

00:43:51,280 --> 00:43:54,880
the core guideline wording says it's

00:43:52,720 --> 00:43:56,240
error-prone and requires expert level

00:43:54,880 --> 00:44:00,000
knowledge no it's not

00:43:56,240 --> 00:44:01,200
um lawfully programming is not

00:44:00,000 --> 00:44:04,480
error-prone

00:44:01,200 --> 00:44:06,720
it's people who are error prone actually

00:44:04,480 --> 00:44:08,560
so with that i want to cover this one uh

00:44:06,720 --> 00:44:10,079
thanks to uh paul mckenny and megan

00:44:08,560 --> 00:44:11,440
michael we've been working this rule and

00:44:10,079 --> 00:44:13,200
it says that there should be no code

00:44:11,440 --> 00:44:15,200
path which results in locking of the

00:44:13,200 --> 00:44:17,119
non-recursive mutex within the scope

00:44:15,200 --> 00:44:18,720
when this mutex is already locked now

00:44:17,119 --> 00:44:20,560
this is just common sense right

00:44:18,720 --> 00:44:22,400
if you're using a non-recursive mutex

00:44:20,560 --> 00:44:25,280
once you start the lock you really

00:44:22,400 --> 00:44:26,800
shouldn't have another lock going okay

00:44:25,280 --> 00:44:30,240
on that same thread

00:44:26,800 --> 00:44:31,119
um the question comes in is that foodon

00:44:30,240 --> 00:44:32,720
under rationale

00:44:31,119 --> 00:44:34,400
they also try to push speculative

00:44:32,720 --> 00:44:36,400
locking to say that you shouldn't

00:44:34,400 --> 00:44:37,680
speculatively lock it either

00:44:36,400 --> 00:44:39,440
and so you shouldn't call things like

00:44:37,680 --> 00:44:41,520
try lock or any of the time

00:44:39,440 --> 00:44:43,440
try lock versions like try lock 4 and

00:44:41,520 --> 00:44:45,680
until and things like that

00:44:43,440 --> 00:44:46,560
so that made us look deeper into the

00:44:45,680 --> 00:44:48,880
standard because

00:44:46,560 --> 00:44:51,520
try lock really has only two possible

00:44:48,880 --> 00:44:53,560
states it can either succeed or it fail

00:44:51,520 --> 00:44:54,800
so when we looked at the standard under

00:44:53,560 --> 00:44:56,800
threat.log.uniquelocking

00:44:54,800 --> 00:44:58,160
it actually says there are two possible

00:44:56,800 --> 00:45:00,480
error conditions

00:44:58,160 --> 00:45:02,960
which we think doesn't make sense for

00:45:00,480 --> 00:45:05,119
this particular case for trilog

00:45:02,960 --> 00:45:07,280
then we started looking at trilok until

00:45:05,119 --> 00:45:08,000
which is possible you could do a try

00:45:07,280 --> 00:45:10,319
lock until

00:45:08,000 --> 00:45:12,079
inside of a non-reclusive mutex okay

00:45:10,319 --> 00:45:14,240
fine i can accept that

00:45:12,079 --> 00:45:16,960
but when you look at the errors in

00:45:14,240 --> 00:45:18,319
trilok until

00:45:16,960 --> 00:45:20,400
none of it has anything to do with

00:45:18,319 --> 00:45:22,480
timing it seems to be a copy and paste

00:45:20,400 --> 00:45:24,319
from the other sections in fact that

00:45:22,480 --> 00:45:26,240
copy and paste happens everywhere

00:45:24,319 --> 00:45:28,240
so i need to discuss this with my

00:45:26,240 --> 00:45:29,680
colleagues and friends in sg1 and then

00:45:28,240 --> 00:45:32,160
to decide whether we should just

00:45:29,680 --> 00:45:33,119
go ahead and file a bug um on something

00:45:32,160 --> 00:45:35,760
like this

00:45:33,119 --> 00:45:37,040
so as you can see our exercise of work

00:45:35,760 --> 00:45:37,359
walking through and now we're almost

00:45:37,040 --> 00:45:40,720
like

00:45:37,359 --> 00:45:42,720
about two-thirds done but that's only

00:45:40,720 --> 00:45:44,240
the first pass which resulted in a lot

00:45:42,720 --> 00:45:45,839
of discussions and and

00:45:44,240 --> 00:45:47,760
and we need to go back to do a full

00:45:45,839 --> 00:45:49,920
second pass and maybe a third pass

00:45:47,760 --> 00:45:51,200
before we can even release these rules

00:45:49,920 --> 00:45:54,560
to the world

00:45:51,200 --> 00:45:55,520
but here's the thing um so what is still

00:45:54,560 --> 00:45:57,119
missing in these

00:45:55,520 --> 00:45:58,640
guidelines okay we already said that

00:45:57,119 --> 00:46:00,079
there's nothing that there's very little

00:45:58,640 --> 00:46:01,839
out there that covers safety

00:46:00,079 --> 00:46:03,760
of parallel and concurrent rules and we

00:46:01,839 --> 00:46:05,200
showed a work in progress

00:46:03,760 --> 00:46:07,040
of where we are right now and we're

00:46:05,200 --> 00:46:07,839
welcoming hoping that many more people

00:46:07,040 --> 00:46:09,680
will join

00:46:07,839 --> 00:46:10,880
who's interested in building such safety

00:46:09,680 --> 00:46:12,960
guidelines uh

00:46:10,880 --> 00:46:14,480
for um safety critical cases like

00:46:12,960 --> 00:46:16,319
aviation and automotive

00:46:14,480 --> 00:46:18,640
but you'll notice that none of this deal

00:46:16,319 --> 00:46:20,400
with heterogeneous dispatch code still

00:46:18,640 --> 00:46:21,920
that's another level that we still have

00:46:20,400 --> 00:46:24,079
to have to deal with

00:46:21,920 --> 00:46:26,240
now i'm also involved in kronos and

00:46:24,079 --> 00:46:27,440
chronos do have a bunch of safety

00:46:26,240 --> 00:46:30,560
critical gpu

00:46:27,440 --> 00:46:32,079
like apis like opengl and they're safety

00:46:30,560 --> 00:46:33,599
critical versions of those

00:46:32,079 --> 00:46:35,359
and they also have vulkan and there's a

00:46:33,599 --> 00:46:37,839
safety critical version of those

00:46:35,359 --> 00:46:39,760
and the idea there is that largely those

00:46:37,839 --> 00:46:41,280
are using miserable rules so up to be

00:46:39,760 --> 00:46:43,440
applied to the apis

00:46:41,280 --> 00:46:45,359
and it's because those apis tend to be

00:46:43,440 --> 00:46:47,760
older they can use the current mizera

00:46:45,359 --> 00:46:48,560
but sickle on the other hand is modern c

00:46:47,760 --> 00:46:50,720
plus plus

00:46:48,560 --> 00:46:53,040
and we need these miserables to be

00:46:50,720 --> 00:46:54,640
updated so that we can apply them

00:46:53,040 --> 00:46:56,319
in general so that they can be combined

00:46:54,640 --> 00:46:57,680
with iso 26262

00:46:56,319 --> 00:46:59,359
and the other standard that i'm working

00:46:57,680 --> 00:47:00,800
on which is so tiff safety of the

00:46:59,359 --> 00:47:04,160
intended functionality

00:47:00,800 --> 00:47:04,880
iso 2144a which is safety for autonomous

00:47:04,160 --> 00:47:06,720
vehicles

00:47:04,880 --> 00:47:08,560
so that we can build a language that

00:47:06,720 --> 00:47:10,240
hopefully will be safe

00:47:08,560 --> 00:47:12,079
and build other languages that is that

00:47:10,240 --> 00:47:14,240
will be saved not just sicko maybe

00:47:12,079 --> 00:47:15,520
it's cuda or maybe other ones so that we

00:47:14,240 --> 00:47:16,560
can help to make sure that every

00:47:15,520 --> 00:47:19,760
language out there

00:47:16,560 --> 00:47:22,640
uh has a safety component

00:47:19,760 --> 00:47:24,000
so where are we well the present state

00:47:22,640 --> 00:47:26,880
is that miserable c and

00:47:24,000 --> 00:47:28,640
c plus um remains the de facto coding

00:47:26,880 --> 00:47:29,280
standard for automotive and the base

00:47:28,640 --> 00:47:31,200
upon

00:47:29,280 --> 00:47:32,559
uh which others are built in fact it's

00:47:31,200 --> 00:47:33,280
not just automotive mystery is now

00:47:32,559 --> 00:47:36,319
really for

00:47:33,280 --> 00:47:37,839
almost every embedded cases and what is

00:47:36,319 --> 00:47:39,280
embedded well that's a big definition

00:47:37,839 --> 00:47:41,440
that i'm going to talk about tomorrow

00:47:39,280 --> 00:47:42,800
mizrah has been integrated with autosol

00:47:41,440 --> 00:47:43,920
that's at least one thing we can be

00:47:42,800 --> 00:47:46,480
proud of is

00:47:43,920 --> 00:47:48,160
reduce numbers standard by one nuts have

00:47:46,480 --> 00:47:50,400
many more proliferated standards that

00:47:48,160 --> 00:47:51,520
just confuses people i i've hated that

00:47:50,400 --> 00:47:54,640
since i was involved

00:47:51,520 --> 00:47:54,960
with openmp and all that so you know i

00:47:54,640 --> 00:47:56,319
didn't

00:47:54,960 --> 00:47:58,079
i never liked more than you know

00:47:56,319 --> 00:47:59,280
multiple standards although invariably

00:47:58,079 --> 00:48:01,040
that seems to happen

00:47:59,280 --> 00:48:02,559
but there's still work needed to add

00:48:01,040 --> 00:48:05,680
additional features from

00:48:02,559 --> 00:48:07,440
c plus 11 14 and 17 17. um

00:48:05,680 --> 00:48:08,960
what that means is that even when the

00:48:07,440 --> 00:48:10,720
new miserable comes out

00:48:08,960 --> 00:48:12,880
we will still be missing some amount of

00:48:10,720 --> 00:48:13,440
features from 11 14 and 17. mainly

00:48:12,880 --> 00:48:15,839
that's

00:48:13,440 --> 00:48:16,480
mostly um we just don't have enough

00:48:15,839 --> 00:48:17,839
hands

00:48:16,480 --> 00:48:19,680
but we are getting more and more hands

00:48:17,839 --> 00:48:21,440
now but it's still not enough we have

00:48:19,680 --> 00:48:23,359
calls like almost every friday

00:48:21,440 --> 00:48:25,119
at six a.m in the morning or eastern

00:48:23,359 --> 00:48:26,480
time so imagine what it would be like

00:48:25,119 --> 00:48:27,839
for pacific because this is mostly

00:48:26,480 --> 00:48:30,240
driven from the uk

00:48:27,839 --> 00:48:32,720
so we lead the effort in misra and sg1

00:48:30,240 --> 00:48:34,480
wgg23 to add parallel concurrency

00:48:32,720 --> 00:48:36,800
and hopefully in future to heterogeneous

00:48:34,480 --> 00:48:37,920
support and the whole point i've been

00:48:36,800 --> 00:48:39,280
interested in this is because i mean

00:48:37,920 --> 00:48:42,319
trying to drive sickle

00:48:39,280 --> 00:48:43,599
in that direction to have safety so that

00:48:42,319 --> 00:48:46,400
it can work for safety

00:48:43,599 --> 00:48:47,680
critical applications so the conclusion

00:48:46,400 --> 00:48:48,960
coming down

00:48:47,680 --> 00:48:50,079
we're getting down to close and i'll be

00:48:48,960 --> 00:48:51,599
able to address some of the questions

00:48:50,079 --> 00:48:53,359
some of these questions are really good

00:48:51,599 --> 00:48:55,040
um the world has been building safe

00:48:53,359 --> 00:48:57,599
sequential programming rules

00:48:55,040 --> 00:48:58,319
and even that effort has been constantly

00:48:57,599 --> 00:49:00,960
behind

00:48:58,319 --> 00:49:01,440
the ratify standards there are very few

00:49:00,960 --> 00:49:03,040
safe

00:49:01,440 --> 00:49:05,119
rules for concurrent programming right

00:49:03,040 --> 00:49:06,160
now and these bugs are extraordinarily

00:49:05,119 --> 00:49:07,760
subtle

00:49:06,160 --> 00:49:09,160
and the world is transitioning to

00:49:07,760 --> 00:49:10,880
parallel devices even in

00:49:09,160 --> 00:49:12,559
non-self-driving cars

00:49:10,880 --> 00:49:14,720
you not never mind autonomous vehicles

00:49:12,559 --> 00:49:16,960
and most domain experts are not c

00:49:14,720 --> 00:49:18,880
plus experts and few of those are

00:49:16,960 --> 00:49:20,160
concurrency experts so they need us they

00:49:18,880 --> 00:49:22,079
need people like you

00:49:20,160 --> 00:49:23,599
and me and you know ilia who are

00:49:22,079 --> 00:49:25,920
concurrency experts with

00:49:23,599 --> 00:49:27,920
you know somewhat of concurrency experts

00:49:25,920 --> 00:49:29,040
to under to to talk about what it takes

00:49:27,920 --> 00:49:31,280
to make

00:49:29,040 --> 00:49:32,640
c plus one safe in that domain these

00:49:31,280 --> 00:49:33,920
autonomous vehicles are pushing the

00:49:32,640 --> 00:49:35,440
boundary with machine learning

00:49:33,920 --> 00:49:36,720
algorithms for object recognition

00:49:35,440 --> 00:49:38,960
detection and tracking

00:49:36,720 --> 00:49:40,319
so we're building safe rules safety

00:49:38,960 --> 00:49:42,160
rules to augment misera

00:49:40,319 --> 00:49:44,559
and core guidelines so that both can

00:49:42,160 --> 00:49:46,319
benefit um core guideline

00:49:44,559 --> 00:49:48,240
could work it could be benefit with the

00:49:46,319 --> 00:49:49,359
meta rules as well as the decidable

00:49:48,240 --> 00:49:51,280
rules some of them

00:49:49,359 --> 00:49:53,040
was misra is mostly just looking at

00:49:51,280 --> 00:49:53,520
things that's that's decidable that can

00:49:53,040 --> 00:49:56,559
be done

00:49:53,520 --> 00:49:58,720
automatically so please help us and join

00:49:56,559 --> 00:49:59,920
join our effort i'll close by saying

00:49:58,720 --> 00:50:03,280
that um

00:49:59,920 --> 00:50:05,280
i like to envision a future where um

00:50:03,280 --> 00:50:06,800
otto saw has already merged with mizrah

00:50:05,280 --> 00:50:09,280
and then coming out of this

00:50:06,800 --> 00:50:10,319
miserable effort it will go to isil c

00:50:09,280 --> 00:50:12,079
plus plus

00:50:10,319 --> 00:50:14,319
some of these rules might in fact um

00:50:12,079 --> 00:50:16,319
encapsulate into actual standard um

00:50:14,319 --> 00:50:18,079
text and some of it will go to the core

00:50:16,319 --> 00:50:20,240
guideline others will go to

00:50:18,079 --> 00:50:22,000
um the safety critical groups that are

00:50:20,240 --> 00:50:25,200
involved in chronos like opencl

00:50:22,000 --> 00:50:29,200
vulcan and secco so with that

00:50:25,200 --> 00:50:31,200
i think that's my last slide

00:50:29,200 --> 00:50:32,960
and i'm going to head towards taking

00:50:31,200 --> 00:50:35,040
questions i'm going to pick ask ilia to

00:50:32,960 --> 00:50:37,839
come back on

00:50:35,040 --> 00:50:39,040
so the first question is really good is

00:50:37,839 --> 00:50:41,119
a complete ban

00:50:39,040 --> 00:50:44,400
on dynamic allocation too limiting for

00:50:41,119 --> 00:50:44,400
modern software systems

00:50:45,599 --> 00:50:50,000
and how can someone prove that custom

00:50:47,359 --> 00:50:52,480
allocators meet the auto start guideline

00:50:50,000 --> 00:50:53,520
i i want to say that without

00:50:52,480 --> 00:50:56,480
categorically

00:50:53,520 --> 00:50:57,440
that you cannot ban dynamic allocations

00:50:56,480 --> 00:51:00,240
um

00:50:57,440 --> 00:51:01,599
um in modern software systems you have

00:51:00,240 --> 00:51:04,480
to allow it the question

00:51:01,599 --> 00:51:06,559
is so mizra i think has accepted that

00:51:04,480 --> 00:51:08,800
you know that slide where we showed

00:51:06,559 --> 00:51:09,599
miso will probably head towards changing

00:51:08,800 --> 00:51:10,880
their rules

00:51:09,599 --> 00:51:13,040
so that it's a complete instead of a

00:51:10,880 --> 00:51:14,800
complete ban they'll

00:51:13,040 --> 00:51:16,079
i think they'll take some of the autosar

00:51:14,800 --> 00:51:18,559
rules um

00:51:16,079 --> 00:51:20,000
the problem is some of those auto rules

00:51:18,559 --> 00:51:22,400
are hard to

00:51:20,000 --> 00:51:23,760
to uh to meet um for instance

00:51:22,400 --> 00:51:24,480
guaranteeing that you will never

00:51:23,760 --> 00:51:26,000
fragment

00:51:24,480 --> 00:51:28,000
guarantee that you will never run out of

00:51:26,000 --> 00:51:30,000
memory guaranteeing that

00:51:28,000 --> 00:51:31,119
you'll you will you will fit a certain

00:51:30,000 --> 00:51:33,440
wcet

00:51:31,119 --> 00:51:35,440
worst case execution time those are

00:51:33,440 --> 00:51:36,160
difficult difficult parameters to do to

00:51:35,440 --> 00:51:38,400
go through

00:51:36,160 --> 00:51:39,920
i think i know of a few libraries that

00:51:38,400 --> 00:51:44,000
actually can

00:51:39,920 --> 00:51:46,960
um can work for um no fragmentation

00:51:44,000 --> 00:51:48,319
and no no uh no errors but there but

00:51:46,960 --> 00:51:50,559
other ones are going to be hard

00:51:48,319 --> 00:51:51,599
to to to get to i i want to hear what

00:51:50,559 --> 00:51:53,680
what ilia's

00:51:51,599 --> 00:51:55,440
thought is that he was actually one of

00:51:53,680 --> 00:51:56,960
the people that was in auto saw that

00:51:55,440 --> 00:51:58,400
that dealt with this particular area i'm

00:51:56,960 --> 00:52:00,640
just going to go back to that slide if i

00:51:58,400 --> 00:52:00,640
can

00:52:01,520 --> 00:52:05,040
go ahead elia well from my side i can

00:52:03,839 --> 00:52:08,079
add that

00:52:05,040 --> 00:52:08,880
there is almost no chance that uh system

00:52:08,079 --> 00:52:11,680
malek can

00:52:08,880 --> 00:52:12,559
fulfill all the requirements of otazar

00:52:11,680 --> 00:52:16,160
but the reason

00:52:12,559 --> 00:52:19,119
here for this rule is that

00:52:16,160 --> 00:52:19,520
you should consider that those aspects

00:52:19,119 --> 00:52:22,480
of

00:52:19,520 --> 00:52:23,119
the malloc will fail and you should have

00:52:22,480 --> 00:52:25,680
a plan

00:52:23,119 --> 00:52:27,440
for the case where when it fails what

00:52:25,680 --> 00:52:30,319
the system will do

00:52:27,440 --> 00:52:32,240
and how it will detect that how to

00:52:30,319 --> 00:52:34,960
handle that

00:52:32,240 --> 00:52:35,520
and reason reasonable approach for that

00:52:34,960 --> 00:52:38,400
is

00:52:35,520 --> 00:52:39,520
when the molecule fails you can just

00:52:38,400 --> 00:52:41,680
kill this

00:52:39,520 --> 00:52:44,079
this process and restart it and start

00:52:41,680 --> 00:52:47,040
from the scratch

00:52:44,079 --> 00:52:47,680
there are other things you can do with

00:52:47,040 --> 00:52:50,160
that

00:52:47,680 --> 00:52:52,000
but the main reason for this rule in

00:52:50,160 --> 00:52:53,920
authors are to exist

00:52:52,000 --> 00:52:55,599
that you should analyze all these

00:52:53,920 --> 00:52:58,720
aspects

00:52:55,599 --> 00:53:01,839
of the application and consider

00:52:58,720 --> 00:53:01,839
plan b

00:53:01,920 --> 00:53:05,599
very good the second part of that

00:53:04,800 --> 00:53:08,160
question says

00:53:05,599 --> 00:53:09,280
how can someone prove that custom

00:53:08,160 --> 00:53:12,400
allocators meet

00:53:09,280 --> 00:53:12,880
the autosol guidelines assuming those

00:53:12,400 --> 00:53:14,079
auto

00:53:12,880 --> 00:53:16,559
guidelines also become miserable

00:53:14,079 --> 00:53:16,559
guidelines

00:53:16,960 --> 00:53:20,880
there are certain customer locators like

00:53:19,440 --> 00:53:24,480
monotonic allocators

00:53:20,880 --> 00:53:27,280
or pool based allocators where you can

00:53:24,480 --> 00:53:28,960
almost prove most of these aspects of

00:53:27,280 --> 00:53:31,520
the

00:53:28,960 --> 00:53:33,839
of the authors are role but it is not

00:53:31,520 --> 00:53:34,960
the silver bullet allocator for all the

00:53:33,839 --> 00:53:37,520
cases it is

00:53:34,960 --> 00:53:38,880
the specialized allocator for your

00:53:37,520 --> 00:53:40,960
specific use case

00:53:38,880 --> 00:53:42,480
yeah i remember talking to john lyco

00:53:40,960 --> 00:53:44,559
that monotonic um

00:53:42,480 --> 00:53:46,319
the one that's monotonic um allocator

00:53:44,559 --> 00:53:48,400
can do most of this

00:53:46,319 --> 00:53:50,559
but it's still not the complete picture

00:53:48,400 --> 00:53:52,559
yet and i would like to push for

00:53:50,559 --> 00:53:53,760
certain types of allocators that can

00:53:52,559 --> 00:53:57,280
satisfy this

00:53:53,760 --> 00:53:58,000
this complete list so i think that

00:53:57,280 --> 00:54:00,720
answers

00:53:58,000 --> 00:54:02,559
that top question the next hops question

00:54:00,720 --> 00:54:03,760
asks how can we take advantage of those

00:54:02,559 --> 00:54:06,720
safety guidelines in

00:54:03,760 --> 00:54:07,839
user applications so by by that i mean

00:54:06,720 --> 00:54:09,599
the safety guidelines that we're

00:54:07,839 --> 00:54:11,920
building right here

00:54:09,599 --> 00:54:13,200
um if you talk about the concurrence

00:54:11,920 --> 00:54:14,800
guideline the the not

00:54:13,200 --> 00:54:16,720
sorry the sequential guidelines there

00:54:14,800 --> 00:54:19,839
are already tools out there

00:54:16,720 --> 00:54:23,040
um by perforce

00:54:19,839 --> 00:54:24,640
synopsis coverity ldia

00:54:23,040 --> 00:54:26,400
that already do those things they will

00:54:24,640 --> 00:54:26,720
generate thousands of these errors for

00:54:26,400 --> 00:54:28,160
you

00:54:26,720 --> 00:54:30,000
in fact that's what they did with the

00:54:28,160 --> 00:54:31,760
unintended acceleration they ran their

00:54:30,000 --> 00:54:33,200
term and found something like 100 like

00:54:31,760 --> 00:54:37,119
10 000 errors

00:54:33,200 --> 00:54:39,440
that 10 000 advisory or issues

00:54:37,119 --> 00:54:41,520
for the sequential guidelines these have

00:54:39,440 --> 00:54:43,599
not built into the tools yet

00:54:41,520 --> 00:54:45,440
because we're still debating it and it

00:54:43,599 --> 00:54:47,119
will probably be a year two years before

00:54:45,440 --> 00:54:48,480
we can materialize them in the mizrah

00:54:47,119 --> 00:54:50,079
standard but you can certainly have a

00:54:48,480 --> 00:54:51,680
look at it i'm not

00:54:50,079 --> 00:54:53,119
i'm not making it like restricted or

00:54:51,680 --> 00:54:54,640
anything and you can certainly i'm

00:54:53,119 --> 00:54:55,440
hoping that that will actually galvanize

00:54:54,640 --> 00:54:58,960
you to help

00:54:55,440 --> 00:55:01,760
help help um help improve it and help us

00:54:58,960 --> 00:55:02,240
um but right now the only way is if they

00:55:01,760 --> 00:55:03,599
you

00:55:02,240 --> 00:55:06,880
right now the only way is if you follow

00:55:03,599 --> 00:55:08,880
the guideline without by eyeballing it

00:55:06,880 --> 00:55:10,079
or or build it some sort of tool but the

00:55:08,880 --> 00:55:11,920
whole point is that this goes into

00:55:10,079 --> 00:55:12,480
miserable and then miserable creates the

00:55:11,920 --> 00:55:15,680
two

00:55:12,480 --> 00:55:18,400
the miser um tool vendors create um

00:55:15,680 --> 00:55:19,599
uh automated tools right they are also

00:55:18,400 --> 00:55:21,280
on board they are always

00:55:19,599 --> 00:55:22,720
asking us you know is this checkable can

00:55:21,280 --> 00:55:24,480
you check this you know

00:55:22,720 --> 00:55:26,000
obviously with a lot of things if we're

00:55:24,480 --> 00:55:28,640
talking about um

00:55:26,000 --> 00:55:30,319
intentions like double double check

00:55:28,640 --> 00:55:31,839
locking it's just really hard to tell

00:55:30,319 --> 00:55:32,799
somebody's actually using double check

00:55:31,839 --> 00:55:34,640
locking

00:55:32,799 --> 00:55:36,640
right that is essentially banned in the

00:55:34,640 --> 00:55:38,319
miseries uh in the miseries uh

00:55:36,640 --> 00:55:40,079
concurrency guidelines right now in in

00:55:38,319 --> 00:55:42,319
our document but it's just really hard

00:55:40,079 --> 00:55:44,640
to tell somebody's actually using that

00:55:42,319 --> 00:55:45,760
right so you can't really easily ban it

00:55:44,640 --> 00:55:48,960
right

00:55:45,760 --> 00:55:52,160
so um ilia did you want to add something

00:55:48,960 --> 00:55:55,200
i think um probably no

00:55:52,160 --> 00:55:55,920
yeah okay that takes care of that next

00:55:55,200 --> 00:55:59,200
question says

00:55:55,920 --> 00:56:01,119
what efforts to what efforts exist

00:55:59,200 --> 00:56:02,480
to shape the design of the c plus

00:56:01,119 --> 00:56:04,319
language based on these safety

00:56:02,480 --> 00:56:04,960
considerations to take a more proactive

00:56:04,319 --> 00:56:07,280
approach

00:56:04,960 --> 00:56:08,720
to ensuring safety really good question

00:56:07,280 --> 00:56:10,559
i'll take a crack at answering that and

00:56:08,720 --> 00:56:13,599
maybe ella can help

00:56:10,559 --> 00:56:14,559
so yes part of we part of our intent was

00:56:13,599 --> 00:56:17,839
always to

00:56:14,559 --> 00:56:19,280
feedback this back to c plus plus

00:56:17,839 --> 00:56:21,040
and there are several group that that

00:56:19,280 --> 00:56:23,200
could that is possibly the right place

00:56:21,040 --> 00:56:26,640
for that that is sg12

00:56:23,200 --> 00:56:28,079
um um on vulnerable on

00:56:26,640 --> 00:56:31,280
on vulnerabilities and undefined

00:56:28,079 --> 00:56:33,520
behavior there's sg14 on embedded

00:56:31,280 --> 00:56:35,200
there's this proto group that has been

00:56:33,520 --> 00:56:36,559
starting on safety critical

00:56:35,200 --> 00:56:38,000
which people have been talking about

00:56:36,559 --> 00:56:40,960
either starting their own group or for

00:56:38,000 --> 00:56:42,960
or adding that to sg14

00:56:40,960 --> 00:56:44,000
i have no personal position on that but

00:56:42,960 --> 00:56:46,480
but we we

00:56:44,000 --> 00:56:47,839
recognize that it would be possible if

00:56:46,480 --> 00:56:50,240
we could add some of these

00:56:47,839 --> 00:56:51,839
um prohibitions back into c plus plus

00:56:50,240 --> 00:56:53,599
standards so that you don't have

00:56:51,839 --> 00:56:54,960
but i think the reality is that you will

00:56:53,599 --> 00:56:57,599
always have to have some

00:56:54,960 --> 00:56:58,720
that's in a tool and some that is in the

00:56:57,599 --> 00:57:01,359
standard

00:56:58,720 --> 00:57:03,280
okay you cannot the c plus one standard

00:57:01,359 --> 00:57:03,680
i'll speaking now with my directions hat

00:57:03,280 --> 00:57:05,839
on

00:57:03,680 --> 00:57:07,359
is not specifically as much as i'd like

00:57:05,839 --> 00:57:09,119
it to be it's not specifically there to

00:57:07,359 --> 00:57:11,440
serve the safety community

00:57:09,119 --> 00:57:12,319
it's there to do performance for high

00:57:11,440 --> 00:57:13,839
productivity

00:57:12,319 --> 00:57:15,599
some of it is high performance computing

00:57:13,839 --> 00:57:16,480
some of it is just it's just good old

00:57:15,599 --> 00:57:19,359
manufacturing

00:57:16,480 --> 00:57:21,200
banking games so it needs to be able to

00:57:19,359 --> 00:57:25,119
serve a wide community

00:57:21,200 --> 00:57:27,440
so as such i can say that that

00:57:25,119 --> 00:57:29,599
while it might be good to us to to

00:57:27,440 --> 00:57:30,799
segment some features towards the c plus

00:57:29,599 --> 00:57:32,880
plus standard

00:57:30,799 --> 00:57:34,480
it will be necessary to keep some of

00:57:32,880 --> 00:57:36,000
that in the tools because some

00:57:34,480 --> 00:57:38,319
some of it i just don't see the c plus

00:57:36,000 --> 00:57:39,359
one standard um accepting

00:57:38,319 --> 00:57:41,680
because it would just limit the

00:57:39,359 --> 00:57:45,359
performance significantly further

00:57:41,680 --> 00:57:47,920
for other domains uh ilia

00:57:45,359 --> 00:57:48,880
we also consulting with different people

00:57:47,920 --> 00:57:53,599
from several

00:57:48,880 --> 00:57:56,400
work groups in uh were group 21 so

00:57:53,599 --> 00:57:59,200
the work through individuals is also

00:57:56,400 --> 00:57:59,200
work in progress

00:58:01,359 --> 00:58:05,599
exactly so we only have about three

00:58:03,599 --> 00:58:07,359
minutes left so i'm gonna take one more

00:58:05,599 --> 00:58:11,760
question

00:58:07,359 --> 00:58:14,640
uh how to get involved

00:58:11,760 --> 00:58:16,400
um i have um an email um in the slides

00:58:14,640 --> 00:58:18,240
you can easily find me obviously

00:58:16,400 --> 00:58:19,839
and he should be able to easily find

00:58:18,240 --> 00:58:21,359
ilya and um

00:58:19,839 --> 00:58:23,040
we are basically having a call every

00:58:21,359 --> 00:58:26,880
month on the stuff

00:58:23,040 --> 00:58:28,400
um and and i will give you this link to

00:58:26,880 --> 00:58:28,960
this document so that you can get

00:58:28,400 --> 00:58:31,440
involved

00:58:28,960 --> 00:58:33,280
um right now it's not restricted to

00:58:31,440 --> 00:58:35,680
mizrah because even though the aim

00:58:33,280 --> 00:58:36,640
started in misra i've opened it up sort

00:58:35,680 --> 00:58:40,079
of so that it's now

00:58:36,640 --> 00:58:42,319
available sg1 to pretty much everybody

00:58:40,079 --> 00:58:44,319
um so that we can have as you can see

00:58:42,319 --> 00:58:44,799
the uh the guest list has been quite

00:58:44,319 --> 00:58:47,760
large

00:58:44,799 --> 00:58:49,520
uh ilia and i started this and then

00:58:47,760 --> 00:58:51,760
bogdan from nvidia join

00:58:49,520 --> 00:58:52,559
a bunch of people from uh ldi and

00:58:51,760 --> 00:58:55,520
perforce

00:58:52,559 --> 00:58:56,400
joined as well as people from auto saw

00:58:55,520 --> 00:59:00,240
jaguar llano

00:58:56,400 --> 00:59:03,200
rover qnx so

00:59:00,240 --> 00:59:03,680
so yeah there's just get it get in touch

00:59:03,200 --> 00:59:06,160
with us

00:59:03,680 --> 00:59:06,720
and we'll we'll we'll happily try to try

00:59:06,160 --> 00:59:09,839
to get you

00:59:06,720 --> 00:59:15,359
uh involved okay

00:59:09,839 --> 00:59:15,359
um 10 seconds left

00:59:16,240 --> 00:59:19,200
i don't know we're going to be able to

00:59:17,520 --> 00:59:20,000
get through to the last few questions

00:59:19,200 --> 00:59:22,000
but

00:59:20,000 --> 00:59:24,000
there's one here on fmea and fta

00:59:22,000 --> 00:59:25,119
analysis that is extremely interesting

00:59:24,000 --> 00:59:27,119
that i'm going to have to

00:59:25,119 --> 00:59:29,280
make sure that i keep and then we can uh

00:59:27,119 --> 00:59:33,520
save those um save those answers

00:59:29,280 --> 00:59:35,040
um so that um we can relate them

00:59:33,520 --> 00:59:37,040
because we are involved with all of

00:59:35,040 --> 00:59:39,440
those um

00:59:37,040 --> 00:59:40,400
system theoretic process stpa analysis

00:59:39,440 --> 00:59:43,520
uh techniques

00:59:40,400 --> 00:59:44,880
uh through um through the um iso 26262

00:59:43,520 --> 00:59:48,880
and 21448

00:59:44,880 --> 00:59:50,960
as well as ul 4600 um

00:59:48,880 --> 00:59:52,559
so let me see i think yeah i think

00:59:50,960 --> 00:59:53,839
that's that's that we should we should

00:59:52,559 --> 00:59:55,520
stop here

00:59:53,839 --> 00:59:58,799
uh thank you very much once again for

00:59:55,520 --> 01:00:00,400
myself and for elia

00:59:58,799 --> 01:00:01,680
um it's been wonderful talking to you

01:00:00,400 --> 01:00:02,319
about this this is one of our favorite

01:00:01,680 --> 01:00:04,799
topics

01:00:02,319 --> 01:00:05,520
and we hope to engage with you somewhere

01:00:04,799 --> 01:00:07,760
some

01:00:05,520 --> 01:00:10,160
some some time thank you cheers guys

01:00:07,760 --> 01:00:10,160
bye-bye

01:00:12,839 --> 01:00:15,839
bye

01:00:29,359 --> 01:00:31,440

YouTube URL: https://www.youtube.com/watch?v=SbQVY-JOrgg


