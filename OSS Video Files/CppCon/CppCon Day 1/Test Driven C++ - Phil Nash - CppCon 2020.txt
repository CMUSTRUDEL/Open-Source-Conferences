Title: Test Driven C++ - Phil Nash - CppCon 2020
Publication date: 2020-09-24
Playlist: CppCon Day 1
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---

We know that testing is important, but writing tests is hard and takes time - and can be demotivating when you want to hack out features.

But what if we flipped the whole thing around? It turns out that by writing tests _first_ the dynamic changes in unexpected ways. Testing becomes easier. Adding features becomes easier. The dopamine hit you get from seeing something work becomes more frequent. Time lost to bugs and regressions virtually disappears. You start to get invited to bigger and better parties!

Ok, one of those statements is not guaranteed - but the rest are! If you've never tried TDD (perhaps you have heard of it but been skeptical), or maybe had a bad experience in the past, this talk will give you a sound intro to how it work, how you can get started, and what you can expect to achieve.

---
Phil Nash
Developer Advocate, JetBrains
Developer Advocate at JetBrains, author of Catch/Catch2, co-host of cpp.chat, host of C++ London, chair and organiser of C++ on Sea.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,040 --> 00:00:13,440
hello and welcome to

00:00:10,480 --> 00:00:14,719
test driven c plus plus i'm phil nash

00:00:13,440 --> 00:00:15,120
we're going to be spending the next six

00:00:14,719 --> 00:00:17,440
minutes

00:00:15,120 --> 00:00:18,400
60 minutes talking about tdd in the

00:00:17,440 --> 00:00:21,840
context of

00:00:18,400 --> 00:00:23,760
c plus so if um if you've been to these

00:00:21,840 --> 00:00:25,359
conferences before you you may know me

00:00:23,760 --> 00:00:27,439
i'm a regular speaker

00:00:25,359 --> 00:00:29,199
both here and at other conferences and

00:00:27,439 --> 00:00:31,920
events but you may also know me

00:00:29,199 --> 00:00:32,960
as the original author of catch two

00:00:31,920 --> 00:00:35,920
originally catch

00:00:32,960 --> 00:00:37,200
of course the unit testing framework for

00:00:35,920 --> 00:00:39,920
suplex plus

00:00:37,200 --> 00:00:40,719
so that's why i'm speaking to you about

00:00:39,920 --> 00:00:42,960
test ribbon c

00:00:40,719 --> 00:00:44,399
plus plus now now i've done a few talks

00:00:42,960 --> 00:00:46,239
on catch before that's not going to be

00:00:44,399 --> 00:00:47,760
the focus of this talk

00:00:46,239 --> 00:00:49,440
in this talk we're going to concentrate

00:00:47,760 --> 00:00:52,800
more on uh tdd

00:00:49,440 --> 00:00:53,680
itself uh and particularly how you can

00:00:52,800 --> 00:00:56,320
do that in c

00:00:53,680 --> 00:00:59,680
plus and what the idiosyncrasies are i'm

00:00:56,320 --> 00:01:02,000
also a developer advocate at jetbrains

00:00:59,680 --> 00:01:03,359
and again we're not going to talk about

00:01:02,000 --> 00:01:05,760
that today but you will see

00:01:03,359 --> 00:01:06,400
uh c-line in my demo later we're also an

00:01:05,760 --> 00:01:09,439
exhibitor

00:01:06,400 --> 00:01:11,600
this week on thursday uh we will have a

00:01:09,439 --> 00:01:12,720
our own room it will magically appear in

00:01:11,600 --> 00:01:14,560
the uh

00:01:12,720 --> 00:01:15,759
the bar at the bottom of the screen you

00:01:14,560 --> 00:01:17,360
can come into our room and

00:01:15,759 --> 00:01:18,880
do a couple of demos and you can speak

00:01:17,360 --> 00:01:20,640
to the team so

00:01:18,880 --> 00:01:21,920
don't miss that but that's what i'm

00:01:20,640 --> 00:01:24,840
going to say about that for now

00:01:21,920 --> 00:01:26,320
let's get back to test driving safe plus

00:01:24,840 --> 00:01:29,119
plus

00:01:26,320 --> 00:01:30,479
now i want to start with the absolute

00:01:29,119 --> 00:01:33,119
basics

00:01:30,479 --> 00:01:34,479
and talk about what is tdd and talk of

00:01:33,119 --> 00:01:37,040
the basics

00:01:34,479 --> 00:01:38,799
originally i proposed this talk for the

00:01:37,040 --> 00:01:40,799
back to basics track

00:01:38,799 --> 00:01:42,720
that's how it's pitched and that's how i

00:01:40,799 --> 00:01:45,280
uh prepared the material

00:01:42,720 --> 00:01:46,000
but uh the back to base extract was full

00:01:45,280 --> 00:01:48,159
up so we got

00:01:46,000 --> 00:01:49,920
pushed off and we've got actually a a

00:01:48,159 --> 00:01:53,439
sort of a pseudo

00:01:49,920 --> 00:01:53,759
sub track on testing uh the the fuzzing

00:01:53,439 --> 00:01:56,960
room

00:01:53,759 --> 00:01:58,479
is all about testing and fuzzing and uh

00:01:56,960 --> 00:02:00,399
that sort of thing so we're sort of

00:01:58,479 --> 00:02:01,600
kicking that off now it does mean i've

00:02:00,399 --> 00:02:03,680
got a little bit more

00:02:01,600 --> 00:02:05,119
leeway but this talk is gonna be mostly

00:02:03,680 --> 00:02:08,640
introductory

00:02:05,119 --> 00:02:09,679
if you have used tdd before that's um

00:02:08,640 --> 00:02:11,920
hopefully you're still gonna be able to

00:02:09,679 --> 00:02:15,200
get something out of it now

00:02:11,920 --> 00:02:17,360
if you go to the q a in remo right now

00:02:15,200 --> 00:02:19,120
you'll see that uh tim the the

00:02:17,360 --> 00:02:22,879
volunteers running this session

00:02:19,120 --> 00:02:25,360
has posted a number of poll questions

00:02:22,879 --> 00:02:27,760
uh some actually abusing the the q a

00:02:25,360 --> 00:02:30,400
feature to tickle his polling

00:02:27,760 --> 00:02:31,840
you can actually vote on the q a

00:02:30,400 --> 00:02:33,920
questions

00:02:31,840 --> 00:02:35,599
so because they are poll items you can

00:02:33,920 --> 00:02:37,040
actually let me know how much experience

00:02:35,599 --> 00:02:38,239
you do have with tdd and i can get an

00:02:37,040 --> 00:02:40,080
idea of what the

00:02:38,239 --> 00:02:41,680
room is like so i can see a couple of

00:02:40,080 --> 00:02:44,560
votes in already

00:02:41,680 --> 00:02:46,319
uh be nice to see a few more quite a few

00:02:44,560 --> 00:02:46,800
people have used tdd before and still

00:02:46,319 --> 00:02:48,720
use it

00:02:46,800 --> 00:02:50,160
so that's good quite a few have never

00:02:48,720 --> 00:02:52,160
used it so great

00:02:50,160 --> 00:02:54,000
keep those coming there's a little bit

00:02:52,160 --> 00:02:56,080
of delay on the stream so

00:02:54,000 --> 00:02:58,560
um what i'm seeing now is uh a little

00:02:56,080 --> 00:03:00,319
bit behind what you're doing

00:02:58,560 --> 00:03:01,840
so that's great you should uh hopefully

00:03:00,319 --> 00:03:03,599
get a lot out of this talk

00:03:01,840 --> 00:03:05,120
let's get back to that question then

00:03:03,599 --> 00:03:08,000
what is tdd

00:03:05,120 --> 00:03:09,599
now that's the easy one obviously it's

00:03:08,000 --> 00:03:10,480
test driven development everybody knows

00:03:09,599 --> 00:03:13,360
that

00:03:10,480 --> 00:03:15,360
except some people seem to think it's

00:03:13,360 --> 00:03:17,280
test driven design

00:03:15,360 --> 00:03:18,640
and i've got a lot of sympathy for this

00:03:17,280 --> 00:03:20,959
interpretation

00:03:18,640 --> 00:03:22,080
because really it's actually more about

00:03:20,959 --> 00:03:24,959
the design

00:03:22,080 --> 00:03:26,400
of your code than the development of it

00:03:24,959 --> 00:03:28,400
i think either works but

00:03:26,400 --> 00:03:30,319
it's useful to think about it this way

00:03:28,400 --> 00:03:32,480
you think of tdd if you think of

00:03:30,319 --> 00:03:34,480
test driven design i think it actually

00:03:32,480 --> 00:03:37,519
puts a better emphasis

00:03:34,480 --> 00:03:38,879
on how tdd actually helps you much more

00:03:37,519 --> 00:03:41,680
so than if we get too

00:03:38,879 --> 00:03:44,400
caught up with the word test and some

00:03:41,680 --> 00:03:46,799
people have wanted to replace that word

00:03:44,400 --> 00:03:48,239
which has led to things like bdd

00:03:46,799 --> 00:03:50,239
behavior driven development

00:03:48,239 --> 00:03:51,280
which you can see as a an evolution of

00:03:50,239 --> 00:03:52,799
of tdd

00:03:51,280 --> 00:03:54,959
and we think well it's not really the

00:03:52,799 --> 00:03:56,959
test so much it's the behavior

00:03:54,959 --> 00:03:58,480
that we actually want to drive our

00:03:56,959 --> 00:04:00,480
development in our design

00:03:58,480 --> 00:04:02,080
and the tests are just a way of of

00:04:00,480 --> 00:04:04,400
helping with that

00:04:02,080 --> 00:04:06,080
so yeah the tests are not the uh the

00:04:04,400 --> 00:04:08,080
desired final outcome they're

00:04:06,080 --> 00:04:10,000
they're really almost like a a side

00:04:08,080 --> 00:04:10,400
effect a very useful side effect which

00:04:10,000 --> 00:04:12,959
has

00:04:10,400 --> 00:04:13,599
adds a lot of value and is an important

00:04:12,959 --> 00:04:15,920
feedback

00:04:13,599 --> 00:04:18,079
in the whole cycle but that's not

00:04:15,920 --> 00:04:20,160
actually the main focus

00:04:18,079 --> 00:04:22,400
and if anything i want to concentrate

00:04:20,160 --> 00:04:25,360
more on the word driven

00:04:22,400 --> 00:04:27,600
because a lot of people again that say

00:04:25,360 --> 00:04:29,759
that they're doing tdd

00:04:27,600 --> 00:04:31,680
they don't necessarily drive their

00:04:29,759 --> 00:04:34,240
design or their development

00:04:31,680 --> 00:04:37,440
from tests or from behavior but they

00:04:34,240 --> 00:04:39,600
sort of just led it to drag it along

00:04:37,440 --> 00:04:41,120
so although test first development it's

00:04:39,600 --> 00:04:42,720
not exactly the same thing as test

00:04:41,120 --> 00:04:45,919
driven development

00:04:42,720 --> 00:04:47,120
to do tdd strictly speaking you need to

00:04:45,919 --> 00:04:48,960
be writing your tests

00:04:47,120 --> 00:04:50,479
first and that's really that sort of

00:04:48,960 --> 00:04:51,440
core fundamental thing that i want to

00:04:50,479 --> 00:04:53,919
emphasize

00:04:51,440 --> 00:04:55,120
today because i used to be one of those

00:04:53,919 --> 00:04:56,720
people that would say well as long as

00:04:55,120 --> 00:04:57,680
i'm writing tests around the same time

00:04:56,720 --> 00:04:59,680
as i'm developing

00:04:57,680 --> 00:05:01,919
it's an integral part of it you know

00:04:59,680 --> 00:05:04,800
that i'm influencing my design

00:05:01,919 --> 00:05:07,120
i'm doing tdd until i had one of these

00:05:04,800 --> 00:05:08,800
light bulb moments when i realized

00:05:07,120 --> 00:05:10,320
actually some of those benefits that

00:05:08,800 --> 00:05:12,560
i've been promised i'm not getting

00:05:10,320 --> 00:05:13,919
because i'm not writing the test first

00:05:12,560 --> 00:05:16,320
and when i started writing the test

00:05:13,919 --> 00:05:19,120
first that's when i finally saw them

00:05:16,320 --> 00:05:20,400
and ttd is like a series of of light

00:05:19,120 --> 00:05:22,880
bulb moments where

00:05:20,400 --> 00:05:24,000
you do sort of move up to different

00:05:22,880 --> 00:05:26,639
levels of insight

00:05:24,000 --> 00:05:27,520
and understanding in 60 minutes i'm not

00:05:26,639 --> 00:05:28,800
going to

00:05:27,520 --> 00:05:30,320
necessarily take you through all of

00:05:28,800 --> 00:05:31,680
those light bulb moments i've just done

00:05:30,320 --> 00:05:34,800
a two day class

00:05:31,680 --> 00:05:36,000
on tdd and c plus plus where i hoped to

00:05:34,800 --> 00:05:37,360
nudge people along

00:05:36,000 --> 00:05:38,880
it does take a bit of experience and

00:05:37,360 --> 00:05:39,360
practice but hopefully i'm going to give

00:05:38,880 --> 00:05:42,560
you some

00:05:39,360 --> 00:05:45,120
pointers too to get you going so

00:05:42,560 --> 00:05:46,400
let's move on to something that may be

00:05:45,120 --> 00:05:49,759
familiar to

00:05:46,400 --> 00:05:51,039
the uh the 17 that have tried tdd before

00:05:49,759 --> 00:05:54,240
but it fizzled out

00:05:51,039 --> 00:05:57,120
or the the other 17 that sorry the 10

00:05:54,240 --> 00:05:59,120
that have used tdd and still use it

00:05:57,120 --> 00:06:01,680
the 17 that had never used tdd before

00:05:59,120 --> 00:06:05,039
may even still be familiar with this

00:06:01,680 --> 00:06:06,880
so this is the tdd cycle

00:06:05,039 --> 00:06:09,759
um you've probably seen something very

00:06:06,880 --> 00:06:11,440
similar to this lots of variations

00:06:09,759 --> 00:06:13,120
the essential components are the free

00:06:11,440 --> 00:06:15,199
colored blocks

00:06:13,120 --> 00:06:16,240
and it's often named after those colors

00:06:15,199 --> 00:06:19,360
the the red green

00:06:16,240 --> 00:06:21,600
refactor cycle now apologies if you do

00:06:19,360 --> 00:06:23,199
have the color vision deficiency

00:06:21,600 --> 00:06:25,600
but it's not really essential to

00:06:23,199 --> 00:06:27,199
actually see the difference in colors to

00:06:25,600 --> 00:06:28,960
to understand it that just there is an

00:06:27,199 --> 00:06:30,800
extra layer really

00:06:28,960 --> 00:06:32,960
the important thing is what's in the

00:06:30,800 --> 00:06:35,360
boxes and

00:06:32,960 --> 00:06:36,960
it's only a few words and they seem

00:06:35,360 --> 00:06:39,360
pretty simple but

00:06:36,960 --> 00:06:40,960
people that try tdd often miss some of

00:06:39,360 --> 00:06:42,160
these keywords so i think it's worth

00:06:40,960 --> 00:06:44,160
emphasizing

00:06:42,160 --> 00:06:46,840
some of them so let's go around the tdd

00:06:44,160 --> 00:06:49,840
cycle and see how it works

00:06:46,840 --> 00:06:52,720
so we start at the start

00:06:49,840 --> 00:06:54,400
finally enough work by writing a failing

00:06:52,720 --> 00:06:57,440
test

00:06:54,400 --> 00:06:59,520
so putting the start there is important

00:06:57,440 --> 00:07:01,360
you know we have to start by writing a

00:06:59,520 --> 00:07:02,800
failing test

00:07:01,360 --> 00:07:05,280
then i've emphasized a couple of words

00:07:02,800 --> 00:07:06,400
there so the word test for example is

00:07:05,280 --> 00:07:08,160
highlighted

00:07:06,400 --> 00:07:09,680
mostly because i want to take the

00:07:08,160 --> 00:07:12,319
opportunity to say

00:07:09,680 --> 00:07:14,240
although we might think of a test as an

00:07:12,319 --> 00:07:16,400
assertion and a test framework

00:07:14,240 --> 00:07:17,680
and it very often is it's a really great

00:07:16,400 --> 00:07:20,800
way to write a failing test

00:07:17,680 --> 00:07:23,039
it doesn't have to be and very often

00:07:20,800 --> 00:07:24,319
particularly you'll hear tdd

00:07:23,039 --> 00:07:25,759
practitioners say that

00:07:24,319 --> 00:07:27,680
especially in a language like c plus

00:07:25,759 --> 00:07:29,520
plus statically typed

00:07:27,680 --> 00:07:31,120
you'll actually use the compiler as an

00:07:29,520 --> 00:07:33,280
extension of your test framework

00:07:31,120 --> 00:07:35,039
if something doesn't compile that can be

00:07:33,280 --> 00:07:37,120
considered a failing test

00:07:35,039 --> 00:07:39,360
if you're using it in that way so

00:07:37,120 --> 00:07:41,840
typical example of that would be

00:07:39,360 --> 00:07:42,960
you're making a new call to an api that

00:07:41,840 --> 00:07:45,680
you need

00:07:42,960 --> 00:07:46,800
but that function or method or class

00:07:45,680 --> 00:07:49,039
doesn't exist yet

00:07:46,800 --> 00:07:50,479
you still have to write it but by

00:07:49,039 --> 00:07:53,520
writing the code that calls it

00:07:50,479 --> 00:07:54,240
first that's the failing test and that

00:07:53,520 --> 00:07:56,800
gives you

00:07:54,240 --> 00:07:58,160
once around this tdd cycle along with

00:07:56,800 --> 00:07:59,919
all the benefits and

00:07:58,160 --> 00:08:01,360
i'm not the consequences of doing that

00:07:59,919 --> 00:08:03,280
as we'll see

00:08:01,360 --> 00:08:04,479
so consider that we'll see an example of

00:08:03,280 --> 00:08:06,400
that in a bit

00:08:04,479 --> 00:08:08,479
so tests don't just mean assertions in a

00:08:06,400 --> 00:08:09,680
test framework uh they can mean anything

00:08:08,479 --> 00:08:10,400
that tell you that the thing that you

00:08:09,680 --> 00:08:13,039
actually want

00:08:10,400 --> 00:08:15,919
is not done yet and will give you a

00:08:13,039 --> 00:08:15,919
signal when it is

00:08:16,000 --> 00:08:18,960
and then it has to be failing that's the

00:08:17,599 --> 00:08:20,319
whole purpose of this being the red

00:08:18,960 --> 00:08:23,360
phase

00:08:20,319 --> 00:08:25,520
you have to start with a failing test

00:08:23,360 --> 00:08:26,960
but very often you'll write a test and

00:08:25,520 --> 00:08:28,560
it will pass first time and that's

00:08:26,960 --> 00:08:31,039
actually fine

00:08:28,560 --> 00:08:32,959
but it's not tdd it's not part of the

00:08:31,039 --> 00:08:34,240
tdd cycle

00:08:32,959 --> 00:08:35,440
that doesn't mean it's wrong it doesn't

00:08:34,240 --> 00:08:36,640
mean it's bad it doesn't mean it's

00:08:35,440 --> 00:08:39,120
valuable

00:08:36,640 --> 00:08:41,120
but understanding the difference is key

00:08:39,120 --> 00:08:43,519
to knowing what to expect

00:08:41,120 --> 00:08:45,120
and and how to work these things through

00:08:43,519 --> 00:08:47,760
so we have to start with a failing test

00:08:45,120 --> 00:08:50,880
for it to be tdd

00:08:47,760 --> 00:08:51,279
now just to emphasize that again uh

00:08:50,880 --> 00:08:53,360
although

00:08:51,279 --> 00:08:54,399
you may rate write a test and it passes

00:08:53,360 --> 00:08:56,160
first time

00:08:54,399 --> 00:08:57,839
and you would expect that you can do

00:08:56,160 --> 00:08:59,760
that while you're doing tdd

00:08:57,839 --> 00:09:01,519
but it's just not part of the tdd cycle

00:08:59,760 --> 00:09:03,040
but it's also the case where you write a

00:09:01,519 --> 00:09:06,240
a test that passes but you expected it

00:09:03,040 --> 00:09:07,600
to fail and that's giving you feedback

00:09:06,240 --> 00:09:08,959
that's telling you that an assumption

00:09:07,600 --> 00:09:10,000
that you had is wrong you may need to

00:09:08,959 --> 00:09:12,000
look into that

00:09:10,000 --> 00:09:14,320
and better understand your code and

00:09:12,000 --> 00:09:17,360
that's a big part of this is testing

00:09:14,320 --> 00:09:18,880
assumptions because so often we make

00:09:17,360 --> 00:09:19,920
assumptions about things we think yeah i

00:09:18,880 --> 00:09:20,320
know exactly what's going on there

00:09:19,920 --> 00:09:22,240
that's

00:09:20,320 --> 00:09:23,519
that's trivial i don't need to write a

00:09:22,240 --> 00:09:24,320
test for that and you write a test and

00:09:23,519 --> 00:09:26,320
it fails

00:09:24,320 --> 00:09:27,519
or it passes and you expected it to fail

00:09:26,320 --> 00:09:29,920
that's giving you information because

00:09:27,519 --> 00:09:32,080
your assumption is broken

00:09:29,920 --> 00:09:33,920
we hear a lot about listening to our

00:09:32,080 --> 00:09:37,040
test and that includes

00:09:33,920 --> 00:09:38,880
exactly this this point listen to what

00:09:37,040 --> 00:09:40,720
the tests are telling us

00:09:38,880 --> 00:09:42,080
if it's telling us that we've made an

00:09:40,720 --> 00:09:44,800
incorrect assumption we need to look

00:09:42,080 --> 00:09:46,080
into that don't just let it pass by

00:09:44,800 --> 00:09:48,480
so it's been quite a lot just on that

00:09:46,080 --> 00:09:51,040
red failing test

00:09:48,480 --> 00:09:54,160
the next step the green step is we write

00:09:51,040 --> 00:09:55,760
just the code to make the test pass

00:09:54,160 --> 00:09:57,360
so yeah making the test pass is the

00:09:55,760 --> 00:10:00,480
desired outcome of this

00:09:57,360 --> 00:10:01,600
hence the green color but notice i've

00:10:00,480 --> 00:10:04,959
highlighted the word

00:10:01,600 --> 00:10:08,320
just write just the code

00:10:04,959 --> 00:10:10,399
to make the test pass and this is very

00:10:08,320 --> 00:10:13,120
often overlooked

00:10:10,399 --> 00:10:14,399
we're not concentrating here on writing

00:10:13,120 --> 00:10:16,399
uh clean code

00:10:14,399 --> 00:10:18,240
really well structured code really

00:10:16,399 --> 00:10:21,200
thoughtfully considered code

00:10:18,240 --> 00:10:22,880
that's what we want but at this stage

00:10:21,200 --> 00:10:24,720
what we're gonna do is the simplest

00:10:22,880 --> 00:10:26,320
quickest dirtiest thing that will get

00:10:24,720 --> 00:10:28,320
that test passing

00:10:26,320 --> 00:10:29,440
and in many cases that's gonna involve

00:10:28,320 --> 00:10:33,440
doing things we think

00:10:29,440 --> 00:10:36,079
i'm not gonna change that immediately

00:10:33,440 --> 00:10:38,000
part of the discipline of tdd is

00:10:36,079 --> 00:10:41,760
actually working through things in

00:10:38,000 --> 00:10:44,720
a specific order which includes the

00:10:41,760 --> 00:10:46,000
complexity or simplicity of the code and

00:10:44,720 --> 00:10:47,120
working up these levels and we're going

00:10:46,000 --> 00:10:49,279
to talk about that

00:10:47,120 --> 00:10:50,320
a bit more uh later the important thing

00:10:49,279 --> 00:10:51,519
for now

00:10:50,320 --> 00:10:54,240
is to remember we're just doing the

00:10:51,519 --> 00:10:57,760
minimum to make that test pass

00:10:54,240 --> 00:11:00,480
because we have one further step

00:10:57,760 --> 00:11:01,200
one further colored box the refactor

00:11:00,480 --> 00:11:03,920
step

00:11:01,200 --> 00:11:04,480
where our sole focus is on making the

00:11:03,920 --> 00:11:07,600
code

00:11:04,480 --> 00:11:10,640
cleaner better structured

00:11:07,600 --> 00:11:11,839
easier to read all of those great

00:11:10,640 --> 00:11:12,320
properties that we're looking for in

00:11:11,839 --> 00:11:15,519
code

00:11:12,320 --> 00:11:18,000
that happens here in the refactor box

00:11:15,519 --> 00:11:19,440
because that's the only thing that we're

00:11:18,000 --> 00:11:20,079
concentrating on here our tests are

00:11:19,440 --> 00:11:22,720
passing

00:11:20,079 --> 00:11:23,519
because we've moved through green and

00:11:22,720 --> 00:11:25,040
now

00:11:23,519 --> 00:11:27,279
we can make changes knowing that if we

00:11:25,040 --> 00:11:28,640
break anything our tests are going to

00:11:27,279 --> 00:11:30,079
cover us

00:11:28,640 --> 00:11:32,560
so that's where the tests are valuable

00:11:30,079 --> 00:11:34,800
they start to act as well they first act

00:11:32,560 --> 00:11:36,000
as a signal to tell us when we've

00:11:34,800 --> 00:11:36,959
actually implemented the thing in the

00:11:36,000 --> 00:11:39,440
first place

00:11:36,959 --> 00:11:41,120
and then they act as a regression test

00:11:39,440 --> 00:11:42,800
to tell us when we've broken something

00:11:41,120 --> 00:11:44,320
and we don't just have the the last test

00:11:42,800 --> 00:11:44,959
that we wrote we have all the tests that

00:11:44,320 --> 00:11:46,320
we wrote

00:11:44,959 --> 00:11:48,560
to tell us we've broken anything

00:11:46,320 --> 00:11:52,639
anywhere

00:11:48,560 --> 00:11:55,440
so because we get close to 100 coverage

00:11:52,639 --> 00:11:57,120
if we're doing strict tdd that gives us

00:11:55,440 --> 00:11:59,279
a high degree of confidence

00:11:57,120 --> 00:12:00,639
that we haven't broken anything as we'll

00:11:59,279 --> 00:12:02,320
see that's still not enough

00:12:00,639 --> 00:12:03,680
we still need to consider other types of

00:12:02,320 --> 00:12:05,600
testing as well

00:12:03,680 --> 00:12:07,680
so we can get a full sense of security

00:12:05,600 --> 00:12:08,639
so there is a bit of a warning there

00:12:07,680 --> 00:12:11,680
but if we're following all these

00:12:08,639 --> 00:12:12,880
principles we should be in a good shape

00:12:11,680 --> 00:12:15,279
so it's actually at this point at the

00:12:12,880 --> 00:12:18,399
refactor step that we need to

00:12:15,279 --> 00:12:20,079
consider certain design principles that

00:12:18,399 --> 00:12:22,639
are going to make tdd work

00:12:20,079 --> 00:12:23,360
and they're not actually part of tdd

00:12:22,639 --> 00:12:25,040
they're sort of like

00:12:23,360 --> 00:12:27,360
assumed that you you have this

00:12:25,040 --> 00:12:29,920
background in in how to

00:12:27,360 --> 00:12:31,040
design code well you have to know what

00:12:29,920 --> 00:12:31,440
these principles are we're going to

00:12:31,040 --> 00:12:33,279
we'll

00:12:31,440 --> 00:12:34,959
talk about those hopefully at the end if

00:12:33,279 --> 00:12:36,720
we have time

00:12:34,959 --> 00:12:38,399
um but the main one is going to be like

00:12:36,720 --> 00:12:40,959
separation of concerns

00:12:38,399 --> 00:12:43,040
keeping things loosely coupled is

00:12:40,959 --> 00:12:44,240
probably the the biggest thing that tdd

00:12:43,040 --> 00:12:46,079
is going to help you with in terms of

00:12:44,240 --> 00:12:46,880
design principles and just like the

00:12:46,079 --> 00:12:49,279
simplicity

00:12:46,880 --> 00:12:50,959
of your code maybe we'll dig into that a

00:12:49,279 --> 00:12:52,639
bit more later

00:12:50,959 --> 00:12:54,000
but but what happens here at the

00:12:52,639 --> 00:12:56,240
refactor stage

00:12:54,000 --> 00:12:57,279
so if you if you skip this you're not

00:12:56,240 --> 00:12:59,600
going to get that benefit

00:12:57,279 --> 00:13:01,920
in fact at the green stage because

00:12:59,600 --> 00:13:02,800
you're just trying to make the code pass

00:13:01,920 --> 00:13:04,000
you're going to end up with lots of

00:13:02,800 --> 00:13:06,160
quick and dirty code and if you don't

00:13:04,000 --> 00:13:08,320
refactor that's all you'll end up with

00:13:06,160 --> 00:13:09,360
and it will degenerate into a big ball

00:13:08,320 --> 00:13:10,560
of mud

00:13:09,360 --> 00:13:13,920
which is the opposite of what we

00:13:10,560 --> 00:13:16,399
actually want so those two stages go

00:13:13,920 --> 00:13:17,760
really hand in hand they don't have to

00:13:16,399 --> 00:13:21,200
always refactor

00:13:17,760 --> 00:13:23,839
you may get to that step and decide well

00:13:21,200 --> 00:13:25,200
there's nothing to refactor here or well

00:13:23,839 --> 00:13:26,240
i can clean that up a bit but i know i'm

00:13:25,200 --> 00:13:27,760
going to change it in the next loop

00:13:26,240 --> 00:13:30,959
round so i'll hold off for now

00:13:27,760 --> 00:13:31,680
you can defer a little bit from time to

00:13:30,959 --> 00:13:33,200
time

00:13:31,680 --> 00:13:34,959
but you have to be really careful with

00:13:33,200 --> 00:13:37,600
that because it's so easy to

00:13:34,959 --> 00:13:39,600
just not come back to it and realize ah

00:13:37,600 --> 00:13:42,000
now i've designed myself into a corner

00:13:39,600 --> 00:13:44,320
and i should have refactored sooner the

00:13:42,000 --> 00:13:47,519
the best of us make that mistake so

00:13:44,320 --> 00:13:48,959
it is a bit of a an artful dance to to

00:13:47,519 --> 00:13:51,920
get the balance here right

00:13:48,959 --> 00:13:53,600
it does take experience so i said that

00:13:51,920 --> 00:13:54,320
you don't automatically get these design

00:13:53,600 --> 00:13:57,680
principles

00:13:54,320 --> 00:14:01,360
as part of tdd what you do get

00:13:57,680 --> 00:14:05,360
is what we call design pressure so

00:14:01,360 --> 00:14:07,120
again thinking of listening to the test

00:14:05,360 --> 00:14:08,399
if you're finding this the tests are

00:14:07,120 --> 00:14:12,160
hard to write

00:14:08,399 --> 00:14:13,680
or it's hard to make the the test pass

00:14:12,160 --> 00:14:15,600
that's telling you that you've probably

00:14:13,680 --> 00:14:17,040
not designed it well or

00:14:15,600 --> 00:14:20,000
maybe you've missed too many refactoring

00:14:17,040 --> 00:14:24,720
steps which is almost the same thing

00:14:20,000 --> 00:14:26,800
so that's that's um that's telling you

00:14:24,720 --> 00:14:28,399
that you have um sometimes called them

00:14:26,800 --> 00:14:29,920
code smells

00:14:28,399 --> 00:14:30,959
which are things that you need to look

00:14:29,920 --> 00:14:31,760
at to see whether they need to be

00:14:30,959 --> 00:14:33,360
refactored

00:14:31,760 --> 00:14:34,880
or you need to apply design principles

00:14:33,360 --> 00:14:37,120
to that's

00:14:34,880 --> 00:14:38,720
one of the key benefits of tdd is

00:14:37,120 --> 00:14:41,199
telling you where to look

00:14:38,720 --> 00:14:42,639
not necessarily telling you what to do

00:14:41,199 --> 00:14:44,560
but at least telling you

00:14:42,639 --> 00:14:47,760
where and when to look and that in

00:14:44,560 --> 00:14:49,279
itself is really valuable

00:14:47,760 --> 00:14:50,959
so soon when we got through the refactor

00:14:49,279 --> 00:14:52,240
step well

00:14:50,959 --> 00:14:53,680
most loops just say well you just go

00:14:52,240 --> 00:14:54,000
back around again back to the red stage

00:14:53,680 --> 00:14:55,519
but

00:14:54,000 --> 00:14:57,199
i like to just insert that extra

00:14:55,519 --> 00:15:00,160
explicit step where you take

00:14:57,199 --> 00:15:02,800
you stop take a look and say are we

00:15:00,160 --> 00:15:04,880
actually done now

00:15:02,800 --> 00:15:05,920
and we'll come back to this again when

00:15:04,880 --> 00:15:07,920
we revisit the

00:15:05,920 --> 00:15:09,199
tdd cycle later we're going to talk

00:15:07,920 --> 00:15:10,800
about the the

00:15:09,199 --> 00:15:13,120
psychological mindsets that you go

00:15:10,800 --> 00:15:13,920
through but but i'll just consider that

00:15:13,120 --> 00:15:15,360
at this point

00:15:13,920 --> 00:15:16,800
you've moved away from looking at the

00:15:15,360 --> 00:15:18,560
low-level code and now you're starting

00:15:16,800 --> 00:15:20,720
to think about requirements again

00:15:18,560 --> 00:15:22,240
this is the time to think have we

00:15:20,720 --> 00:15:23,760
actually met all the requirements that

00:15:22,240 --> 00:15:25,440
we needed

00:15:23,760 --> 00:15:27,440
or are we just going to carry on gold

00:15:25,440 --> 00:15:28,720
plating and doing things for the sake of

00:15:27,440 --> 00:15:31,839
it because it seems like

00:15:28,720 --> 00:15:33,600
a good idea so we have that

00:15:31,839 --> 00:15:35,440
moment to just reflect and consider that

00:15:33,600 --> 00:15:39,199
and say actually are we done

00:15:35,440 --> 00:15:40,720
or do we need to go around again and

00:15:39,199 --> 00:15:42,399
just realized i wasn't advancing my

00:15:40,720 --> 00:15:45,680
slides so catch up

00:15:42,399 --> 00:15:46,560
there we go so either are we done or we

00:15:45,680 --> 00:15:48,399
go back

00:15:46,560 --> 00:15:50,800
i write the next failing test which we

00:15:48,399 --> 00:15:55,360
have to select

00:15:50,800 --> 00:15:56,880
so that in a nutshell it's the tdd cycle

00:15:55,360 --> 00:15:58,480
it's actually really simple

00:15:56,880 --> 00:16:00,560
straightforward

00:15:58,480 --> 00:16:01,519
but hopefully i've already shown that

00:16:00,560 --> 00:16:05,440
there are some

00:16:01,519 --> 00:16:07,440
nuances to it that do take experience

00:16:05,440 --> 00:16:08,959
they take some knowledge of some design

00:16:07,440 --> 00:16:10,079
principles and there's a bit of an art

00:16:08,959 --> 00:16:13,839
to it

00:16:10,079 --> 00:16:15,759
so that's actually the the tricky part

00:16:13,839 --> 00:16:18,320
of tdd is understanding all these

00:16:15,759 --> 00:16:19,920
nuances understanding the basic cycle

00:16:18,320 --> 00:16:21,519
is pretty straightforward are they even

00:16:19,920 --> 00:16:24,880
then even the best of us

00:16:21,519 --> 00:16:26,800
to get sometimes so

00:16:24,880 --> 00:16:28,079
before we go into the demo where we're

00:16:26,800 --> 00:16:31,360
going to try and

00:16:28,079 --> 00:16:34,720
um make some of this a bit more concrete

00:16:31,360 --> 00:16:36,000
i want to give you a chance to ask some

00:16:34,720 --> 00:16:39,120
questions and i can see that there

00:16:36,000 --> 00:16:41,360
are some already in the q a so

00:16:39,120 --> 00:16:42,720
if you have any more that now's your

00:16:41,360 --> 00:16:44,480
time

00:16:42,720 --> 00:16:46,720
so the top one is how would you

00:16:44,480 --> 00:16:48,639
introduce tdd to a legacy code base with

00:16:46,720 --> 00:16:50,800
little or no tests

00:16:48,639 --> 00:16:52,240
which is a really good question which

00:16:50,800 --> 00:16:53,199
i'm going to come back to towards the

00:16:52,240 --> 00:16:55,199
end

00:16:53,199 --> 00:16:56,399
so i'm going to defer that one for the

00:16:55,199 --> 00:17:00,959
moment

00:16:56,399 --> 00:17:02,959
and except to say that it's very hard

00:17:00,959 --> 00:17:04,640
sometimes not even worth it but there

00:17:02,959 --> 00:17:06,959
are some techniques and tricks

00:17:04,640 --> 00:17:07,760
that can make make it more manageable

00:17:06,959 --> 00:17:10,079
and

00:17:07,760 --> 00:17:10,799
uh give you a fighting chance but yeah

00:17:10,079 --> 00:17:13,039
it's

00:17:10,799 --> 00:17:14,959
probably the number one sticking point

00:17:13,039 --> 00:17:16,480
in adopting tdds how do you

00:17:14,959 --> 00:17:18,000
how do you adopt tdd when you have a big

00:17:16,480 --> 00:17:18,720
legacy code base there are things you

00:17:18,000 --> 00:17:20,400
can do

00:17:18,720 --> 00:17:22,959
and there are some approaches but i'm

00:17:20,400 --> 00:17:26,160
not going to say they're easy

00:17:22,959 --> 00:17:26,640
so thank you for that um that's just the

00:17:26,160 --> 00:17:28,480
code

00:17:26,640 --> 00:17:30,160
to make the test pass i suggest

00:17:28,480 --> 00:17:32,000
implementing a stub

00:17:30,160 --> 00:17:33,360
which hard codes the result and ignores

00:17:32,000 --> 00:17:34,480
the parameters the first time through

00:17:33,360 --> 00:17:38,400
the loop

00:17:34,480 --> 00:17:41,120
um i'm not sure i'd say it suggests that

00:17:38,400 --> 00:17:42,400
but that often is what happens we will

00:17:41,120 --> 00:17:44,320
look at that when we go through the demo

00:17:42,400 --> 00:17:46,640
we'll talk about it a bit more then

00:17:44,320 --> 00:17:47,440
i will also talk about why we do that

00:17:46,640 --> 00:17:49,039
because

00:17:47,440 --> 00:17:51,039
that's confounding to a lot of people

00:17:49,039 --> 00:17:52,240
they say why do we do this

00:17:51,039 --> 00:17:54,160
why would we write something we know

00:17:52,240 --> 00:17:57,039
we're going to replace

00:17:54,160 --> 00:17:57,360
almost straight away so we'll talk about

00:17:57,039 --> 00:17:59,600
that

00:17:57,360 --> 00:18:01,360
so a good question these are all good

00:17:59,600 --> 00:18:04,480
questions of course

00:18:01,360 --> 00:18:05,200
um is it particularly important to write

00:18:04,480 --> 00:18:06,880
just

00:18:05,200 --> 00:18:08,240
one failing test in the loop or is it

00:18:06,880 --> 00:18:10,960
okay to write a couple of similar

00:18:08,240 --> 00:18:12,880
failing tests and work them together

00:18:10,960 --> 00:18:15,840
yeah that's a tricky one um by default

00:18:12,880 --> 00:18:18,880
i'd say no you should have just one

00:18:15,840 --> 00:18:20,160
but sometimes it can be worth writing a

00:18:18,880 --> 00:18:21,440
few tests while you've

00:18:20,160 --> 00:18:22,720
all you've got those requirements in

00:18:21,440 --> 00:18:23,919
your mind and you're you're thinking in

00:18:22,720 --> 00:18:26,240
that frame of mind

00:18:23,919 --> 00:18:28,240
uh get them all out but you may want to

00:18:26,240 --> 00:18:30,720
comment some of them out temporarily

00:18:28,240 --> 00:18:31,919
so that you can focus on making one test

00:18:30,720 --> 00:18:34,240
at a time work

00:18:31,919 --> 00:18:35,679
and hopefully we'll see in the demo that

00:18:34,240 --> 00:18:36,799
there is a bit of a dance backwards and

00:18:35,679 --> 00:18:40,240
forwards that

00:18:36,799 --> 00:18:42,960
you miss if you go too far ahead so

00:18:40,240 --> 00:18:44,000
yeah by default i'd say no but it does

00:18:42,960 --> 00:18:47,840
sometimes make sense

00:18:44,000 --> 00:18:49,760
we have to know what you're doing um

00:18:47,840 --> 00:18:51,280
each test would they be testing the

00:18:49,760 --> 00:18:53,679
smallest part of the application

00:18:51,280 --> 00:18:55,039
how would you decide what your test

00:18:53,679 --> 00:18:58,240
should be

00:18:55,039 --> 00:18:58,960
um and i shall be really going to cover

00:18:58,240 --> 00:19:01,360
that

00:18:58,960 --> 00:19:03,280
it's um it's an interesting question and

00:19:01,360 --> 00:19:06,320
i often talk about fractal

00:19:03,280 --> 00:19:08,240
tdd in terms of sort of the multiple

00:19:06,320 --> 00:19:10,559
levels that you can apply

00:19:08,240 --> 00:19:12,320
uh tdd principles out all the way from

00:19:10,559 --> 00:19:13,360
acceptance test driven development down

00:19:12,320 --> 00:19:16,000
to the lowest level

00:19:13,360 --> 00:19:18,160
code and everything in between so it's

00:19:16,000 --> 00:19:20,559
this uh self-similar nature of

00:19:18,160 --> 00:19:21,760
how that works all the way down hence

00:19:20,559 --> 00:19:24,160
the fractal

00:19:21,760 --> 00:19:25,200
so what you consider the the unit here

00:19:24,160 --> 00:19:26,320
really depends on what level you're

00:19:25,200 --> 00:19:28,160
operating at

00:19:26,320 --> 00:19:29,679
i tend to mostly focus at the lower

00:19:28,160 --> 00:19:32,240
levels so what we

00:19:29,679 --> 00:19:33,440
actually call unit testing um and

00:19:32,240 --> 00:19:34,960
sometimes just above that

00:19:33,440 --> 00:19:37,440
but it actually works all the way up to

00:19:34,960 --> 00:19:38,880
to the top but it's a bit more of an

00:19:37,440 --> 00:19:41,679
open philosophical question i'm not

00:19:38,880 --> 00:19:43,440
going to get into so much more today

00:19:41,679 --> 00:19:46,000
i've got lots of questions coming in i

00:19:43,440 --> 00:19:48,480
may have to defer some of these

00:19:46,000 --> 00:19:50,799
uh does it still make sense to attempt

00:19:48,480 --> 00:19:52,960
red green refactor when the code

00:19:50,799 --> 00:19:56,080
subject to testing needs to be

00:19:52,960 --> 00:19:57,280
refactored to become testable

00:19:56,080 --> 00:19:58,960
that's a really good question and we're

00:19:57,280 --> 00:20:00,000
going to see this in in the demo

00:19:58,960 --> 00:20:01,440
actually that

00:20:00,000 --> 00:20:03,360
we'll get to a point where we say right

00:20:01,440 --> 00:20:05,600
to to move on from here

00:20:03,360 --> 00:20:07,280
we actually need to back up a bit just

00:20:05,600 --> 00:20:10,640
get back to green

00:20:07,280 --> 00:20:12,640
do some refactoring ready to

00:20:10,640 --> 00:20:13,919
tackle the next test so that's

00:20:12,640 --> 00:20:17,760
absolutely the case

00:20:13,919 --> 00:20:19,520
um you want to try and minimize

00:20:17,760 --> 00:20:20,960
when that happens if that's happening

00:20:19,520 --> 00:20:23,520
too much it probably means you're just

00:20:20,960 --> 00:20:25,520
missing refactoring steps but sometimes

00:20:23,520 --> 00:20:27,760
you'll say right i actually need to make

00:20:25,520 --> 00:20:30,240
some changes at the design level

00:20:27,760 --> 00:20:31,840
rather than a pure refactoring in order

00:20:30,240 --> 00:20:34,159
to accommodate this next thing we'll see

00:20:31,840 --> 00:20:35,840
an example of that

00:20:34,159 --> 00:20:37,360
should just be strictly unit tests or

00:20:35,840 --> 00:20:38,720
should tests include interactions

00:20:37,360 --> 00:20:40,720
between units

00:20:38,720 --> 00:20:42,000
that's sort of implicit in my fractal

00:20:40,720 --> 00:20:44,799
tdd comment that

00:20:42,000 --> 00:20:47,600
depends which level you're operating at

00:20:44,799 --> 00:20:48,240
tdd purists will often say no no a unit

00:20:47,600 --> 00:20:50,640
has to be

00:20:48,240 --> 00:20:52,320
completely isolated um has to be a pure

00:20:50,640 --> 00:20:54,720
unit test

00:20:52,320 --> 00:20:55,600
i'm a lot more relaxed on that and i

00:20:54,720 --> 00:20:57,280
tend to follow

00:20:55,600 --> 00:20:59,520
microfiber's definition of a unit test

00:20:57,280 --> 00:21:01,840
anyway which is that

00:20:59,520 --> 00:21:03,760
basically they should run fast which

00:21:01,840 --> 00:21:05,919
implies

00:21:03,760 --> 00:21:07,039
no to minimal dependencies and being

00:21:05,919 --> 00:21:10,400
reproducible

00:21:07,039 --> 00:21:12,240
and deterministic but there's not like a

00:21:10,400 --> 00:21:14,720
hard and fast rule at what level you can

00:21:12,240 --> 00:21:14,720
operate on

00:21:14,880 --> 00:21:19,919
um and what's the best way to introduce

00:21:17,600 --> 00:21:21,760
tdd in a project that mostly relies on

00:21:19,919 --> 00:21:23,760
integration-based tests

00:21:21,760 --> 00:21:26,799
where database access for example has

00:21:23,760 --> 00:21:28,880
not been properly marked out

00:21:26,799 --> 00:21:30,000
um that's another big open question and

00:21:28,880 --> 00:21:32,880
i put that in the the

00:21:30,000 --> 00:21:33,760
legacy code camp so let's park that one

00:21:32,880 --> 00:21:35,840
for now

00:21:33,760 --> 00:21:37,760
and if we get time towards the end uh

00:21:35,840 --> 00:21:38,799
when we talk about legacy code maybe i

00:21:37,760 --> 00:21:42,000
try and address that one

00:21:38,799 --> 00:21:43,679
specifically um

00:21:42,000 --> 00:21:45,280
i'm gonna move on and i've just noticed

00:21:43,679 --> 00:21:46,799
my

00:21:45,280 --> 00:21:47,919
laptop is not charging which means the

00:21:46,799 --> 00:21:48,960
battery is about to run out and i won't

00:21:47,919 --> 00:21:51,760
be able to see the questions anymore so

00:21:48,960 --> 00:21:51,760
bear with me one second

00:21:54,320 --> 00:22:01,280
right that's charging let's move on

00:21:58,880 --> 00:22:02,880
so i mentioned this demo we're going to

00:22:01,280 --> 00:22:04,960
do and this is what we're going to

00:22:02,880 --> 00:22:06,240
uh take on so obviously snakes and

00:22:04,960 --> 00:22:08,960
ladders

00:22:06,240 --> 00:22:09,679
now this is an example of what we call a

00:22:08,960 --> 00:22:13,840
coding

00:22:09,679 --> 00:22:15,679
cata so from the japanese term for a

00:22:13,840 --> 00:22:17,120
very sort of specific small exercise

00:22:15,679 --> 00:22:18,720
that you can do repeatedly

00:22:17,120 --> 00:22:19,679
to get very good at a skill so nothing

00:22:18,720 --> 00:22:20,799
to do with software development

00:22:19,679 --> 00:22:24,080
originally

00:22:20,799 --> 00:22:26,000
um typically in the context of martial

00:22:24,080 --> 00:22:27,919
arts but then

00:22:26,000 --> 00:22:29,360
we have applied that to things like

00:22:27,919 --> 00:22:31,280
learning a musical instrument or

00:22:29,360 --> 00:22:32,720
certain other skills we're sort of

00:22:31,280 --> 00:22:34,480
abusing this term a bit

00:22:32,720 --> 00:22:36,559
in software development when we adopted

00:22:34,480 --> 00:22:37,919
it because

00:22:36,559 --> 00:22:40,159
the thing that we're practicing over and

00:22:37,919 --> 00:22:42,240
over again these these cutters

00:22:40,159 --> 00:22:43,200
like the stakes they know this one

00:22:42,240 --> 00:22:44,640
that's not the thing we're actually

00:22:43,200 --> 00:22:46,559
trying to get good at

00:22:44,640 --> 00:22:48,000
we're trying to use that to explore some

00:22:46,559 --> 00:22:50,320
other skill in this case

00:22:48,000 --> 00:22:51,600
tdd it could be learning a language or

00:22:50,320 --> 00:22:53,919
technology

00:22:51,600 --> 00:22:54,640
so just bear that in mind that it's not

00:22:53,919 --> 00:22:56,080
that we're

00:22:54,640 --> 00:22:58,480
going to do snakes and added again and

00:22:56,080 --> 00:23:00,480
again to to get good at that

00:22:58,480 --> 00:23:01,840
there's some other objective and we just

00:23:00,480 --> 00:23:05,200
want to practice

00:23:01,840 --> 00:23:07,520
the actual skill that we have in mind so

00:23:05,200 --> 00:23:08,880
one of the problems that people hit when

00:23:07,520 --> 00:23:10,880
they're trying to learn tdd

00:23:08,880 --> 00:23:12,400
or trying to practice it is they try to

00:23:10,880 --> 00:23:14,000
put it into practice straight away in

00:23:12,400 --> 00:23:15,200
their day jobs

00:23:14,000 --> 00:23:17,679
and that they hit some sort of

00:23:15,200 --> 00:23:19,360
productivity slump before they

00:23:17,679 --> 00:23:20,720
actually reach a level of competency

00:23:19,360 --> 00:23:23,280
where they can

00:23:20,720 --> 00:23:24,159
start to become more productive so it's

00:23:23,280 --> 00:23:26,960
really important

00:23:24,159 --> 00:23:28,080
to um to do set aside time for what we

00:23:26,960 --> 00:23:29,760
call deliberate practice

00:23:28,080 --> 00:23:31,760
which involves working through these

00:23:29,760 --> 00:23:34,480
little coding chatters

00:23:31,760 --> 00:23:35,840
in order to practice this new skill and

00:23:34,480 --> 00:23:36,640
only once we start to get a bit more

00:23:35,840 --> 00:23:39,600
confident that

00:23:36,640 --> 00:23:40,640
yeah now i can work in this new way then

00:23:39,600 --> 00:23:44,159
start to apply that

00:23:40,640 --> 00:23:46,320
to your day job so we're going to do one

00:23:44,159 --> 00:23:48,559
of these as an example now

00:23:46,320 --> 00:23:51,279
and i've chosen this one because i think

00:23:48,559 --> 00:23:54,640
it's relatively universally known

00:23:51,279 --> 00:23:56,320
this uh this bold game uh charles ball

00:23:54,640 --> 00:23:57,279
game really because it really is just a

00:23:56,320 --> 00:23:58,880
game of chance

00:23:57,279 --> 00:24:00,159
the rules are pretty simple so not too

00:23:58,880 --> 00:24:01,760
much to model we're not gonna do the

00:24:00,159 --> 00:24:03,120
whole thing

00:24:01,760 --> 00:24:05,120
just to look at that board from the top

00:24:03,120 --> 00:24:09,360
down this is one my

00:24:05,120 --> 00:24:10,400
kids actually used years ago

00:24:09,360 --> 00:24:12,400
modelling the board is pretty

00:24:10,400 --> 00:24:14,720
straightforward

00:24:12,400 --> 00:24:15,760
there's a hundred squares there each one

00:24:14,720 --> 00:24:17,840
is either empty

00:24:15,760 --> 00:24:20,240
which case if you land on it you don't

00:24:17,840 --> 00:24:22,159
move or it's the bottom of a ladder

00:24:20,240 --> 00:24:24,720
or the head of a snake if you'd end up

00:24:22,159 --> 00:24:26,480
one of those two you go to the other end

00:24:24,720 --> 00:24:29,520
the top of the ladder or the bottom of

00:24:26,480 --> 00:24:31,520
the snake so i call these portals

00:24:29,520 --> 00:24:34,480
more abstractly because they take you

00:24:31,520 --> 00:24:35,679
from one part of the board to the other

00:24:34,480 --> 00:24:37,600
uh the fact that it's in the grid is

00:24:35,679 --> 00:24:40,000
just a presentation artifact you can

00:24:37,600 --> 00:24:41,520
think of it as just a hundred squares

00:24:40,000 --> 00:24:43,520
so players will move along the grid by

00:24:41,520 --> 00:24:47,039
rolling a die

00:24:43,520 --> 00:24:48,960
until they reach square 100.

00:24:47,039 --> 00:24:50,640
uh the first one to square 100 wins the

00:24:48,960 --> 00:24:52,080
game but you have to land exactly on the

00:24:50,640 --> 00:24:53,679
square 100.

00:24:52,080 --> 00:24:55,200
so if you're one in one of the last few

00:24:53,679 --> 00:24:56,480
squares and you throw a number that's

00:24:55,200 --> 00:24:59,919
too high

00:24:56,480 --> 00:25:00,799
you miss you go uh that's pretty much it

00:24:59,919 --> 00:25:02,320
there's a little bit more to the

00:25:00,799 --> 00:25:03,039
gameplay mechanics but we'll skip that

00:25:02,320 --> 00:25:05,120
for now

00:25:03,039 --> 00:25:06,720
because we're just gonna model the bald

00:25:05,120 --> 00:25:10,320
so how we're gonna

00:25:06,720 --> 00:25:12,080
capture the board model so

00:25:10,320 --> 00:25:14,400
really the interesting bits of

00:25:12,080 --> 00:25:15,760
information are these snakes and ladders

00:25:14,400 --> 00:25:18,080
for example there's a ladder there from

00:25:15,760 --> 00:25:20,320
square 2 to 38 so we can

00:25:18,080 --> 00:25:23,039
capture that information out there's

00:25:20,320 --> 00:25:27,039
another one there from 4 to 14.

00:25:23,039 --> 00:25:28,960
so we'll pull that out and so on until

00:25:27,039 --> 00:25:30,559
we've captured the whole board because

00:25:28,960 --> 00:25:32,880
anything that's not a snake or a ladder

00:25:30,559 --> 00:25:35,200
is an empty square that gives us a nice

00:25:32,880 --> 00:25:38,559
starting point a nice declarative

00:25:35,200 --> 00:25:41,360
view of how the board works and we can

00:25:38,559 --> 00:25:42,960
project that into code very easily it's

00:25:41,360 --> 00:25:44,480
still fairly declarative

00:25:42,960 --> 00:25:46,080
looks like some sort of map so let's

00:25:44,480 --> 00:25:49,200
wrap that in a

00:25:46,080 --> 00:25:52,400
a map of uh make a uint32t

00:25:49,200 --> 00:25:55,039
to something i call a portal

00:25:52,400 --> 00:25:56,159
so i've chosen unsigned integers so we

00:25:55,039 --> 00:25:57,039
don't have to worry about negative

00:25:56,159 --> 00:25:59,039
numbers

00:25:57,039 --> 00:26:00,559
if you can use the type system to reduce

00:25:59,039 --> 00:26:02,880
things you need to test for

00:26:00,559 --> 00:26:05,600
that's always a big win the best test is

00:26:02,880 --> 00:26:07,919
the one you didn't have to write

00:26:05,600 --> 00:26:09,440
we do need a portal type that's pretty

00:26:07,919 --> 00:26:11,520
straightforward

00:26:09,440 --> 00:26:13,360
just a little structure with an enum a

00:26:11,520 --> 00:26:17,760
snake or a ladder

00:26:13,360 --> 00:26:20,000
and a target cell

00:26:17,760 --> 00:26:21,600
that's pretty much it so that's a good

00:26:20,000 --> 00:26:22,799
starting point

00:26:21,600 --> 00:26:25,679
what we're going to do now is i'm going

00:26:22,799 --> 00:26:27,600
to drop to um an editor

00:26:25,679 --> 00:26:29,200
and start to to work this through in

00:26:27,600 --> 00:26:31,919
code so

00:26:29,200 --> 00:26:33,200
we are going to break for a demo and

00:26:31,919 --> 00:26:34,880
then we'll come back and

00:26:33,200 --> 00:26:38,960
go around the the tdd cycle again and

00:26:34,880 --> 00:26:41,440
see what we've learned

00:26:38,960 --> 00:26:44,240
we will also have to see how we do for

00:26:41,440 --> 00:26:47,440
time i may have to cut it short

00:26:44,240 --> 00:26:49,279
so i have this starting point it's

00:26:47,440 --> 00:26:52,640
basically what we saw on the slide

00:26:49,279 --> 00:26:54,080
we have our map of with the portal class

00:26:52,640 --> 00:26:56,720
itself

00:26:54,080 --> 00:26:57,840
uh i'm already including the header for

00:26:56,720 --> 00:27:00,240
catch

00:26:57,840 --> 00:27:01,600
so that's my test framework obviously

00:27:00,240 --> 00:27:04,960
i'm familiar with that

00:27:01,600 --> 00:27:06,559
um you could do this in any test

00:27:04,960 --> 00:27:08,880
framework of course

00:27:06,559 --> 00:27:09,919
and i've already got a test case started

00:27:08,880 --> 00:27:11,840
noticing catch

00:27:09,919 --> 00:27:14,480
test names are free form strings which

00:27:11,840 --> 00:27:17,279
is really nice because

00:27:14,480 --> 00:27:18,399
test naming is actually really important

00:27:17,279 --> 00:27:19,520
it's uh

00:27:18,399 --> 00:27:21,679
much more important than most people

00:27:19,520 --> 00:27:23,760
think in fact because it acts as

00:27:21,679 --> 00:27:26,000
a part of the documentation for the code

00:27:23,760 --> 00:27:28,240
as well as the tests

00:27:26,000 --> 00:27:29,760
and it could also act as a point of

00:27:28,240 --> 00:27:31,679
communication between you

00:27:29,760 --> 00:27:33,440
and maybe people that are even

00:27:31,679 --> 00:27:34,720
non-technical or at least not familiar

00:27:33,440 --> 00:27:37,760
with your code base

00:27:34,720 --> 00:27:39,279
so do bear that in mind how are we going

00:27:37,760 --> 00:27:42,480
to start

00:27:39,279 --> 00:27:46,960
writing tests here we have these portals

00:27:42,480 --> 00:27:50,399
now obviously we could just start um

00:27:46,960 --> 00:27:51,520
using it we could see what's a square

00:27:50,399 --> 00:27:55,200
one

00:27:51,520 --> 00:27:59,120
and with catch the assertion macro

00:27:55,200 --> 00:28:03,520
is required and i could say

00:27:59,120 --> 00:28:06,000
maybe uh portals is

00:28:03,520 --> 00:28:08,640
do you need to pull out the target will

00:28:06,000 --> 00:28:08,640
take us to

00:28:09,120 --> 00:28:13,120
well actually we don't know let's let's

00:28:10,720 --> 00:28:13,120
try it

00:28:14,480 --> 00:28:21,600
and that fails because

00:28:18,320 --> 00:28:23,520
obviously maps when you try to access

00:28:21,600 --> 00:28:24,960
a an element that's not in the map and

00:28:23,520 --> 00:28:27,760
that's not in the map

00:28:24,960 --> 00:28:28,720
but give us a default instance so okay

00:28:27,760 --> 00:28:31,760
maybe we could get an

00:28:28,720 --> 00:28:34,000
iterator out and query that but

00:28:31,760 --> 00:28:35,279
this is this is the wrong direction this

00:28:34,000 --> 00:28:36,399
is not what we want to do we don't want

00:28:35,279 --> 00:28:39,360
to

00:28:36,399 --> 00:28:40,880
be testing stood map that's not the

00:28:39,360 --> 00:28:43,520
purpose of tdd

00:28:40,880 --> 00:28:45,039
or at least not at our level if you're a

00:28:43,520 --> 00:28:46,559
standard library implementer maybe but

00:28:45,039 --> 00:28:48,480
that's not what we're doing here

00:28:46,559 --> 00:28:50,320
we want to test the board we don't have

00:28:48,480 --> 00:28:54,080
a bulb we just have this list of portals

00:28:50,320 --> 00:28:58,320
with mapper portals what we want

00:28:54,080 --> 00:29:01,919
is a board object

00:28:58,320 --> 00:29:04,240
something like this uh now obviously

00:29:01,919 --> 00:29:05,760
we haven't written a board object and uh

00:29:04,240 --> 00:29:07,440
i'm using c line here so it's telling me

00:29:05,760 --> 00:29:08,240
that straight away maybe your ad does

00:29:07,440 --> 00:29:10,960
too

00:29:08,240 --> 00:29:13,600
if not obviously you can just build it

00:29:10,960 --> 00:29:15,120
so this is our first failing test

00:29:13,600 --> 00:29:17,360
remember i said the compiler can be your

00:29:15,120 --> 00:29:18,480
test framework it's just telling us we

00:29:17,360 --> 00:29:26,559
need a board object

00:29:18,480 --> 00:29:30,159
or build class so let's do that

00:29:26,559 --> 00:29:33,360
remember also said we need to write

00:29:30,159 --> 00:29:34,640
just the code to make the test pass

00:29:33,360 --> 00:29:36,720
and that does it we don't need anything

00:29:34,640 --> 00:29:39,520
in there yet so

00:29:36,720 --> 00:29:40,000
i can now build that that compiles and

00:29:39,520 --> 00:29:43,200
that means

00:29:40,000 --> 00:29:45,679
i've now passed that test that's another

00:29:43,200 --> 00:29:46,720
time around the tdd cycle

00:29:45,679 --> 00:29:48,720
even though we haven't actually written

00:29:46,720 --> 00:29:51,200
any assertions yet

00:29:48,720 --> 00:29:52,960
now why is this necessary why do we do

00:29:51,200 --> 00:29:54,480
this well

00:29:52,960 --> 00:29:56,480
if you consider that that line of code

00:29:54,480 --> 00:29:58,960
is acting as our test

00:29:56,480 --> 00:30:00,480
that means that even this empty class

00:29:58,960 --> 00:30:02,559
has a test for it

00:30:00,480 --> 00:30:04,240
and that's what we want to end up with

00:30:02,559 --> 00:30:07,520
we want to end up with a test

00:30:04,240 --> 00:30:09,120
for every line of code that we write now

00:30:07,520 --> 00:30:11,200
i say that's not necessarily sufficient

00:30:09,120 --> 00:30:13,200
because we also have to consider

00:30:11,200 --> 00:30:15,360
um data and different paths through the

00:30:13,200 --> 00:30:17,120
code but as a starting point

00:30:15,360 --> 00:30:20,640
having a test for every line of code

00:30:17,120 --> 00:30:23,200
that we write is a really great start

00:30:20,640 --> 00:30:23,919
all right what can we do with this board

00:30:23,200 --> 00:30:24,960
so

00:30:23,919 --> 00:30:26,559
we want to raise the level of

00:30:24,960 --> 00:30:27,840
abstraction now so rather than just

00:30:26,559 --> 00:30:28,960
looking up things on a map we want to

00:30:27,840 --> 00:30:31,039
say

00:30:28,960 --> 00:30:32,320
what happens if we land on a particular

00:30:31,039 --> 00:30:34,240
square

00:30:32,320 --> 00:30:36,880
so we've thinking about one before well

00:30:34,240 --> 00:30:39,200
now we can say ah right

00:30:36,880 --> 00:30:40,399
the board knows that if you land on an

00:30:39,200 --> 00:30:44,159
empty square

00:30:40,399 --> 00:30:44,159
you just stay on that square so

00:30:44,880 --> 00:30:52,480
i can say uh sorry jumping head

00:30:49,360 --> 00:30:53,679
let's just assume it returns the square

00:30:52,480 --> 00:30:57,120
that we

00:30:53,679 --> 00:30:58,640
we landed on so now we have another

00:30:57,120 --> 00:31:02,080
compiler error

00:30:58,640 --> 00:31:02,840
landon hasn't been written so i can add

00:31:02,080 --> 00:31:07,039
that

00:31:02,840 --> 00:31:08,960
oops a little bit awkward

00:31:07,039 --> 00:31:11,120
writing with this microphone in my way

00:31:08,960 --> 00:31:11,120
but

00:31:11,279 --> 00:31:19,679
i'll make that return are you in 32

00:31:15,679 --> 00:31:21,679
take away 32.

00:31:19,679 --> 00:31:23,039
it's probably going to be const should

00:31:21,679 --> 00:31:24,399
always be const by default unless you

00:31:23,039 --> 00:31:26,960
know otherwise

00:31:24,399 --> 00:31:28,080
that's my principle now what's this

00:31:26,960 --> 00:31:30,720
going to return

00:31:28,080 --> 00:31:33,039
it has a return value we know that our

00:31:30,720 --> 00:31:36,640
test is expecting a one

00:31:33,039 --> 00:31:40,559
but we want to start with a failing test

00:31:36,640 --> 00:31:43,120
so we've returned zero

00:31:40,559 --> 00:31:44,399
now at this point we still have a

00:31:43,120 --> 00:31:48,159
failing

00:31:44,399 --> 00:31:49,519
compiler test so now we'll demonstrate

00:31:48,159 --> 00:31:51,840
that that now compiles

00:31:49,519 --> 00:31:53,120
that's one time around the tdd cycle and

00:31:51,840 --> 00:31:55,679
if we run

00:31:53,120 --> 00:31:57,039
that's the next time round now we have

00:31:55,679 --> 00:32:00,240
now we're back to red

00:31:57,039 --> 00:32:02,640
we now have a failing test again

00:32:00,240 --> 00:32:02,640
because

00:32:03,440 --> 00:32:08,000
we've got a zero instead of a one which

00:32:05,200 --> 00:32:11,039
we can see down here in the output

00:32:08,000 --> 00:32:12,960
by the way i'm using c line's built-in

00:32:11,039 --> 00:32:15,840
integration with catch to to give us a

00:32:12,960 --> 00:32:15,840
nice test runner output

00:32:16,159 --> 00:32:21,440
okay now how do we make this pass well

00:32:18,960 --> 00:32:22,720
we know that the rule is that

00:32:21,440 --> 00:32:24,640
if it's an empty square we're going to

00:32:22,720 --> 00:32:28,080
return the square that we passed in

00:32:24,640 --> 00:32:29,600
but we want to force our test code to

00:32:28,080 --> 00:32:33,039
test for that

00:32:29,600 --> 00:32:36,799
and that's why the next step should be

00:32:33,039 --> 00:32:38,399
to return a constant

00:32:36,799 --> 00:32:42,159
so the constant we're testing for what

00:32:38,399 --> 00:32:45,200
we should return here

00:32:42,159 --> 00:32:46,720
that gets us back to green

00:32:45,200 --> 00:32:49,440
the tests are passing but we know this

00:32:46,720 --> 00:32:51,760
is not what we want but

00:32:49,440 --> 00:32:54,320
to force us to generalize that we need

00:32:51,760 --> 00:32:57,919
to write another test

00:32:54,320 --> 00:33:00,799
let's make this a um the next empty

00:32:57,919 --> 00:33:00,799
square which will be free

00:33:02,080 --> 00:33:04,960
because if we do that

00:33:05,120 --> 00:33:10,080
that will fail because it's returning

00:33:08,080 --> 00:33:11,679
the one as we will expect our

00:33:10,080 --> 00:33:14,159
assumptions are holding

00:33:11,679 --> 00:33:14,159
and now

00:33:15,679 --> 00:33:22,000
we can make that return square

00:33:19,279 --> 00:33:22,000
and that should pass

00:33:23,360 --> 00:33:27,279
so already we've noticed something we're

00:33:26,320 --> 00:33:29,120
going

00:33:27,279 --> 00:33:30,559
rapidly between red and green red and

00:33:29,120 --> 00:33:32,320
green red and green

00:33:30,559 --> 00:33:33,519
okay i haven't stopped to refactor yet

00:33:32,320 --> 00:33:34,240
because we just don't have enough code

00:33:33,519 --> 00:33:35,679
but

00:33:34,240 --> 00:33:37,600
imagine i'm considering the refactor

00:33:35,679 --> 00:33:39,120
step each time we're going around that

00:33:37,600 --> 00:33:41,760
tdd cycle

00:33:39,120 --> 00:33:42,720
in seconds this is a really important

00:33:41,760 --> 00:33:44,799
part

00:33:42,720 --> 00:33:46,240
of tdd now it's not always possible

00:33:44,799 --> 00:33:48,720
especially in c plus plus

00:33:46,240 --> 00:33:50,799
in compile times but we should be aiming

00:33:48,720 --> 00:33:53,840
for most of the tdd cycle to be

00:33:50,799 --> 00:33:53,840
in the order of seconds

00:33:54,080 --> 00:33:58,399
and that way we can afford to make those

00:33:56,320 --> 00:34:00,640
extra steps the returning a constant

00:33:58,399 --> 00:34:02,000
now we've returned the square we haven't

00:34:00,640 --> 00:34:05,279
considered portals yet

00:34:02,000 --> 00:34:08,720
because we haven't got a test that

00:34:05,279 --> 00:34:11,280
bears that out so let's write one

00:34:08,720 --> 00:34:11,280
we know that

00:34:11,839 --> 00:34:19,760
square two is a ladder to square 38

00:34:16,159 --> 00:34:24,240
so we would expect that to

00:34:19,760 --> 00:34:25,679
give us a 38 and of course it doesn't

00:34:24,240 --> 00:34:27,440
because we're not considering portals

00:34:25,679 --> 00:34:29,119
yet so this is what we want we have a

00:34:27,440 --> 00:34:32,240
failing test

00:34:29,119 --> 00:34:33,200
that now forces us to consider the

00:34:32,240 --> 00:34:36,320
portals

00:34:33,200 --> 00:34:38,079
while also retaining the behavior of the

00:34:36,320 --> 00:34:40,000
empty squares

00:34:38,079 --> 00:34:41,919
now bulk doesn't actually have the

00:34:40,000 --> 00:34:44,159
portals

00:34:41,919 --> 00:34:45,440
we could refer to it as a global but i'm

00:34:44,159 --> 00:34:49,359
going to take this opportunity to move

00:34:45,440 --> 00:34:50,879
it in so i'll put it here

00:34:49,359 --> 00:34:53,599
but i also want to make it constant

00:34:50,879 --> 00:34:56,960
static so

00:34:53,599 --> 00:34:59,440
i'm going to actually paste it

00:34:56,960 --> 00:34:59,440
at the end

00:35:00,079 --> 00:35:07,119
make it a

00:35:03,680 --> 00:35:07,119
static const here

00:35:11,040 --> 00:35:20,160
and then at the end

00:35:16,160 --> 00:35:23,200
let's make that const and on board

00:35:20,160 --> 00:35:23,200
did i miss something there

00:35:28,839 --> 00:35:34,000
um

00:35:30,320 --> 00:35:37,200
ah that's the trouble with this

00:35:34,000 --> 00:35:37,200
microphone being in my way

00:35:37,359 --> 00:35:41,440
straight character okay so i've just

00:35:40,400 --> 00:35:44,240
moved

00:35:41,440 --> 00:35:45,440
portals to be a member of bald but i've

00:35:44,240 --> 00:35:46,800
actually defined it

00:35:45,440 --> 00:35:49,119
after my test and that means i don't

00:35:46,800 --> 00:35:50,960
have to scroll up up and down so much

00:35:49,119 --> 00:35:53,280
because it's out of the way of my test

00:35:50,960 --> 00:35:53,280
code

00:35:53,440 --> 00:35:57,280
i do tend to write my test code or

00:35:55,760 --> 00:35:58,720
rather write my new code

00:35:57,280 --> 00:36:00,400
in with my test code to begin with and

00:35:58,720 --> 00:36:01,359
then later i transplant it out into my

00:36:00,400 --> 00:36:03,280
production code

00:36:01,359 --> 00:36:05,440
that's just my style it's not required

00:36:03,280 --> 00:36:08,240
as part of tdd

00:36:05,440 --> 00:36:08,240
all right so

00:36:08,720 --> 00:36:13,200
i still haven't actually implemented

00:36:12,000 --> 00:36:15,200
this i should have commented that out so

00:36:13,200 --> 00:36:19,920
i stayed green while i refactored

00:36:15,200 --> 00:36:25,119
but now we can say or we can

00:36:19,920 --> 00:36:29,280
use an iterator to find the square

00:36:25,119 --> 00:36:29,280
and if we found it

00:36:31,200 --> 00:36:35,040
it's raised not at the end then

00:36:35,280 --> 00:36:41,839
we can pull the target out and

00:36:38,400 --> 00:36:41,839
return that

00:36:42,000 --> 00:36:45,760
otherwise we fall back to returning our

00:36:43,839 --> 00:36:49,200
square

00:36:45,760 --> 00:36:53,119
so that should now

00:36:49,200 --> 00:36:53,119
and it does pass our test

00:36:53,520 --> 00:36:58,640
so there are empty squares are still

00:36:54,800 --> 00:37:02,720
working our ladder is working

00:36:58,640 --> 00:37:06,839
what if we look for the first snake

00:37:02,720 --> 00:37:11,280
square 47 is a snake

00:37:06,839 --> 00:37:13,520
to square 26

00:37:11,280 --> 00:37:16,480
that's what we'd expect now we've

00:37:13,520 --> 00:37:19,119
written a new test do we expect this to

00:37:16,480 --> 00:37:20,800
pass or fail well we know that it's just

00:37:19,119 --> 00:37:23,359
another portal in the map so we actually

00:37:20,800 --> 00:37:26,480
expect this to pass first time

00:37:23,359 --> 00:37:27,839
so we're going from green to green so

00:37:26,480 --> 00:37:28,880
remember i said that's it's not that

00:37:27,839 --> 00:37:31,839
that's not valuable

00:37:28,880 --> 00:37:33,599
but it's not part of the tdd cycle and

00:37:31,839 --> 00:37:35,040
when you do like one or two extra things

00:37:33,599 --> 00:37:38,079
like this

00:37:35,040 --> 00:37:40,079
just sort of probing at that edge of the

00:37:38,079 --> 00:37:42,079
design a little bit

00:37:40,079 --> 00:37:44,560
i'm okay just doing this along with my

00:37:42,079 --> 00:37:47,599
other tdd tests

00:37:44,560 --> 00:37:50,320
but there's also a case for doing

00:37:47,599 --> 00:37:51,040
some more exhaustive testing or extra

00:37:50,320 --> 00:37:53,599
testing of

00:37:51,040 --> 00:37:55,440
whole ranges of values where i'd say

00:37:53,599 --> 00:37:56,720
well that's a dedicated separate task

00:37:55,440 --> 00:37:59,119
and should be in a separate area

00:37:56,720 --> 00:38:00,079
and maybe if we have time we'll look at

00:37:59,119 --> 00:38:02,000
that as well

00:38:00,079 --> 00:38:03,599
but i think we're getting short on time

00:38:02,000 --> 00:38:06,720
so we're going to carry on

00:38:03,599 --> 00:38:09,839
for now so we have a snake in a ladder

00:38:06,720 --> 00:38:13,920
i think the next interesting test

00:38:09,839 --> 00:38:17,359
is going to be the winning square

00:38:13,920 --> 00:38:19,920
square 100 now what's

00:38:17,359 --> 00:38:20,800
bald going to return when we land on

00:38:19,920 --> 00:38:22,560
that

00:38:20,800 --> 00:38:24,079
that's an interesting question i mean

00:38:22,560 --> 00:38:26,160
yeah technically

00:38:24,079 --> 00:38:28,960
100 and that should actually pass but is

00:38:26,160 --> 00:38:32,000
that what we want

00:38:28,960 --> 00:38:34,400
yeah that's interesting by writing this

00:38:32,000 --> 00:38:36,960
test it's forced us to consider the

00:38:34,400 --> 00:38:39,200
design requirements

00:38:36,960 --> 00:38:40,400
what do we actually want land on to

00:38:39,200 --> 00:38:43,359
return here

00:38:40,400 --> 00:38:44,960
after whose responsibility is it to know

00:38:43,359 --> 00:38:46,000
what the size of the board is and what

00:38:44,960 --> 00:38:47,760
therefore what the winning

00:38:46,000 --> 00:38:49,760
square is that's really the board's

00:38:47,760 --> 00:38:51,119
responsibility

00:38:49,760 --> 00:38:53,920
so really the board should be telling us

00:38:51,119 --> 00:38:57,119
that so i'm going to back that out

00:38:53,920 --> 00:38:58,400
for now so we're back to our previous

00:38:57,119 --> 00:38:59,520
green state

00:38:58,400 --> 00:39:01,839
and i'm going to say right let's have a

00:38:59,520 --> 00:39:04,400
look at this design

00:39:01,839 --> 00:39:06,480
landon just returns the target square no

00:39:04,400 --> 00:39:10,880
other information

00:39:06,480 --> 00:39:13,280
let's instead say we're going to return

00:39:10,880 --> 00:39:14,960
a type called action that's going to

00:39:13,280 --> 00:39:17,440
contain the target and also some more

00:39:14,960 --> 00:39:20,240
information

00:39:17,440 --> 00:39:21,599
now just to save a bit of time i'm going

00:39:20,240 --> 00:39:23,040
to

00:39:21,599 --> 00:39:24,720
allow for the fact that it looks very

00:39:23,040 --> 00:39:27,760
much like portal

00:39:24,720 --> 00:39:29,119
just a coincidence it's another thing

00:39:27,760 --> 00:39:33,200
with a type in the target

00:39:29,119 --> 00:39:36,000
but this time the num is move

00:39:33,200 --> 00:39:37,520
which is what we've been doing and we're

00:39:36,000 --> 00:39:39,359
going to want to win

00:39:37,520 --> 00:39:41,520
as well now technically i shouldn't have

00:39:39,359 --> 00:39:43,040
this yet until i have a test for it

00:39:41,520 --> 00:39:44,160
i'm actually okay to let that pass

00:39:43,040 --> 00:39:45,520
because it makes some other things

00:39:44,160 --> 00:39:48,640
easier

00:39:45,520 --> 00:39:49,440
uh sa line's grey bits out anyway so we

00:39:48,640 --> 00:39:53,599
have our

00:39:49,440 --> 00:39:55,839
action type movabin and the target

00:39:53,599 --> 00:39:58,320
we just need to fix the code up to

00:39:55,839 --> 00:40:01,440
return that

00:39:58,320 --> 00:40:05,040
so action type

00:40:01,440 --> 00:40:08,240
move this will be a lot easier with c

00:40:05,040 --> 00:40:11,839
plus plus 20s using enum i think it made

00:40:08,240 --> 00:40:11,839
it into 20.

00:40:15,280 --> 00:40:18,480
and then we also have to change the

00:40:17,280 --> 00:40:20,000
tests

00:40:18,480 --> 00:40:22,000
now because this is the refactoring step

00:40:20,000 --> 00:40:27,359
i want to do the minimum

00:40:22,000 --> 00:40:27,359
to make this work which is going to be

00:40:28,000 --> 00:40:32,720
just to pull out the targets so we're

00:40:30,000 --> 00:40:36,000
not actually considering

00:40:32,720 --> 00:40:36,000
whether it's a move or not yet

00:40:36,560 --> 00:40:42,319
and we're back to green so

00:40:39,599 --> 00:40:43,520
now we can say okay can i refactor this

00:40:42,319 --> 00:40:46,720
a bit

00:40:43,520 --> 00:40:50,839
for example maybe i want to say

00:40:46,720 --> 00:40:54,319
compare that against action

00:40:50,839 --> 00:40:54,319
type move

00:40:55,920 --> 00:41:03,359
cover one and so i need to

00:41:00,160 --> 00:41:03,359
specify the type here

00:41:03,920 --> 00:41:07,680
and it doesn't work because we don't

00:41:06,640 --> 00:41:10,800
have a

00:41:07,680 --> 00:41:12,480
an equals operator for action at least

00:41:10,800 --> 00:41:15,359
not until

00:41:12,480 --> 00:41:16,960
the spaceship operator synthesizes that

00:41:15,359 --> 00:41:19,119
for us

00:41:16,960 --> 00:41:20,560
so i'm going to do the next best thing

00:41:19,119 --> 00:41:24,079
and let

00:41:20,560 --> 00:41:26,880
c-line do that for me

00:41:24,079 --> 00:41:27,440
so when i need equals here we'll use

00:41:26,880 --> 00:41:30,079
dead

00:41:27,440 --> 00:41:31,839
time there you go there's my little demo

00:41:30,079 --> 00:41:33,520
of c line

00:41:31,839 --> 00:41:35,839
so we didn't have to write that that's

00:41:33,520 --> 00:41:35,839
nice

00:41:35,920 --> 00:41:41,440
um that should now make that compile

00:41:41,599 --> 00:41:46,079
and it still runs so i should probably

00:41:44,480 --> 00:41:47,359
go through and add those

00:41:46,079 --> 00:41:48,480
to the others as well but i'm just going

00:41:47,359 --> 00:41:50,240
to skip on because we're getting a

00:41:48,480 --> 00:41:52,000
little bit shorter time

00:41:50,240 --> 00:41:53,680
but we do now have the ability to

00:41:52,000 --> 00:41:56,880
express what we want here

00:41:53,680 --> 00:41:58,240
which is that this will be

00:41:56,880 --> 00:42:01,280
what in fact we're not even interested

00:41:58,240 --> 00:42:05,040
in the the target

00:42:01,280 --> 00:42:08,640
only want to know what the type is

00:42:05,040 --> 00:42:13,680
which is um

00:42:08,640 --> 00:42:13,680
action type win

00:42:15,040 --> 00:42:19,040
okay so all of that refactoring was just

00:42:17,599 --> 00:42:22,319
so that we could enable this

00:42:19,040 --> 00:42:25,280
this line and of course

00:42:22,319 --> 00:42:28,240
it's our new failing test so now we need

00:42:25,280 --> 00:42:29,520
to make this pass but before we do that

00:42:28,240 --> 00:42:31,359
we should also have a look at the

00:42:29,520 --> 00:42:33,119
feedback we're getting here

00:42:31,359 --> 00:42:35,280
so we're expecting it to fail but this

00:42:33,119 --> 00:42:37,520
is not very helpful failure

00:42:35,280 --> 00:42:39,839
because it's just giving us integers for

00:42:37,520 --> 00:42:41,760
our enum values

00:42:39,839 --> 00:42:42,880
so what we need to do is tell catch how

00:42:41,760 --> 00:42:46,880
to read

00:42:42,880 --> 00:42:49,680
these action types and we could use

00:42:46,880 --> 00:42:50,240
um an o stream operator uh insertion

00:42:49,680 --> 00:42:53,280
operator

00:42:50,240 --> 00:42:54,960
overload but

00:42:53,280 --> 00:42:57,280
or we could even get c line to do it for

00:42:54,960 --> 00:42:59,680
us again there is a

00:42:57,280 --> 00:43:01,440
i'll do it down here a featuring catch

00:42:59,680 --> 00:43:05,119
that can be useful here

00:43:01,440 --> 00:43:05,119
uh catch register enum

00:43:06,319 --> 00:43:09,200
i just give it the

00:43:10,800 --> 00:43:13,839
type and

00:43:16,480 --> 00:43:19,119
the values

00:43:23,200 --> 00:43:28,319
and after some painful retypes there it

00:43:26,160 --> 00:43:28,319
is

00:43:28,880 --> 00:43:32,160
now catch will just generate

00:43:32,319 --> 00:43:35,599
the code necessary to make that that

00:43:34,160 --> 00:43:36,800
print now so now we can see yeah we've

00:43:35,599 --> 00:43:38,800
got a move instead of a win

00:43:36,800 --> 00:43:40,560
which is what we expected it's nice to

00:43:38,800 --> 00:43:41,280
see it there now if one of these tests

00:43:40,560 --> 00:43:44,560
fails

00:43:41,280 --> 00:43:45,920
later on a build server perhaps

00:43:44,560 --> 00:43:49,040
we don't actually have access to it on a

00:43:45,920 --> 00:43:50,640
local machine we get a lot more feedback

00:43:49,040 --> 00:43:52,960
from the test framework as to what

00:43:50,640 --> 00:43:56,079
actually went wrong so that's also

00:43:52,960 --> 00:43:56,640
really important now how do we make this

00:43:56,079 --> 00:43:59,680
pass

00:43:56,640 --> 00:44:02,800
that's fairly straightforward now we

00:43:59,680 --> 00:44:02,800
could just put an f at the start

00:44:05,119 --> 00:44:11,359
it squares up 100 then return

00:44:09,119 --> 00:44:11,359
uh

00:44:12,560 --> 00:44:17,440
action type win

00:44:18,800 --> 00:44:24,640
and we'll put 100 again

00:44:22,800 --> 00:44:27,040
unfortunately what we really want here

00:44:24,640 --> 00:44:28,400
is a proper discriminated union which c

00:44:27,040 --> 00:44:30,720
plus plus doesn't have

00:44:28,400 --> 00:44:32,160
uh in another language i'll be able to

00:44:30,720 --> 00:44:34,160
write this so

00:44:32,160 --> 00:44:36,400
if it's a win we don't have specified a

00:44:34,160 --> 00:44:37,839
target you could do it with a variant

00:44:36,400 --> 00:44:41,040
i think that's a little bit heavy weight

00:44:37,839 --> 00:44:43,760
for this so we'll leave this for now

00:44:41,040 --> 00:44:45,440
let's just check that that passes and it

00:44:43,760 --> 00:44:47,119
does so we're green

00:44:45,440 --> 00:44:49,359
and now i can see an opportunity to

00:44:47,119 --> 00:44:52,160
refactor

00:44:49,359 --> 00:44:54,000
because we have this magic number and

00:44:52,160 --> 00:44:58,880
duplication of it

00:44:54,000 --> 00:44:58,880
so i'm going to um

00:45:00,160 --> 00:45:04,319
yeah i'm going to try and extract that

00:45:02,839 --> 00:45:07,040
actually

00:45:04,319 --> 00:45:07,040
as size

00:45:08,160 --> 00:45:15,920
and then put that up there

00:45:13,119 --> 00:45:16,880
so i did say that the size should be a

00:45:15,920 --> 00:45:20,560
property of the bold

00:45:16,880 --> 00:45:22,800
and now it literally is there we go so

00:45:20,560 --> 00:45:24,400
we don't have any magic numbers in the

00:45:22,800 --> 00:45:26,000
in the method anymore

00:45:24,400 --> 00:45:28,400
i run it again to check we're still

00:45:26,000 --> 00:45:30,079
green again the fact that we can do this

00:45:28,400 --> 00:45:32,319
so instantly

00:45:30,079 --> 00:45:33,680
makes this really doable to go backwards

00:45:32,319 --> 00:45:34,880
and forwards between changing the code

00:45:33,680 --> 00:45:37,920
and testing

00:45:34,880 --> 00:45:37,920
to make sure we're still green

00:45:38,800 --> 00:45:43,040
so there's a couple more things i wanted

00:45:41,040 --> 00:45:45,839
to do but we're going to do one of them

00:45:43,040 --> 00:45:47,200
because we're a bit short on time and

00:45:45,839 --> 00:45:49,680
that is

00:45:47,200 --> 00:45:49,680
to note

00:45:50,400 --> 00:45:55,760
that oops square 80

00:45:53,920 --> 00:45:59,040
if you didn't notice this before is a

00:45:55,760 --> 00:46:02,880
ladder to square 100

00:45:59,040 --> 00:46:02,880
which means that's also a winning move

00:46:03,119 --> 00:46:06,160
so we would expect

00:46:06,560 --> 00:46:13,040
this to also work except that

00:46:10,079 --> 00:46:14,880
we know we haven't coded for that yet so

00:46:13,040 --> 00:46:17,119
it doesn't

00:46:14,880 --> 00:46:19,280
and now we get the benefit of seeing

00:46:17,119 --> 00:46:21,119
that um being unprinting

00:46:19,280 --> 00:46:23,440
yeah it's just doing a move because of

00:46:21,119 --> 00:46:23,440
course

00:46:23,920 --> 00:46:30,400
our if is before

00:46:28,000 --> 00:46:32,079
the mapping and we can't just move it to

00:46:30,400 --> 00:46:34,640
the end

00:46:32,079 --> 00:46:36,079
now it's grayed out because it's

00:46:34,640 --> 00:46:38,000
unreachable code because we're returning

00:46:36,079 --> 00:46:39,200
before that

00:46:38,000 --> 00:46:42,160
so we're going to need some sort of

00:46:39,200 --> 00:46:46,480
intermediate state

00:46:42,160 --> 00:46:46,480
so something like let's say final square

00:46:46,960 --> 00:46:52,960
and we could give it an initial value

00:46:50,560 --> 00:46:54,240
and then mutate it here and that would

00:46:52,960 --> 00:46:57,760
be fine

00:46:54,240 --> 00:46:58,960
um i prefer to do things immutably where

00:46:57,760 --> 00:47:01,599
possible

00:46:58,960 --> 00:47:02,880
what i'd really like to do is just treat

00:47:01,599 --> 00:47:06,400
this all

00:47:02,880 --> 00:47:08,880
as an expression again c plus plus

00:47:06,400 --> 00:47:12,400
doesn't let us do that

00:47:08,880 --> 00:47:14,720
or does it it turns out

00:47:12,400 --> 00:47:17,280
that you can write an immediately

00:47:14,720 --> 00:47:19,680
invoked lambda expression

00:47:17,280 --> 00:47:20,319
so you push it all into a lambda i've

00:47:19,680 --> 00:47:24,240
captured

00:47:20,319 --> 00:47:27,760
square and then just invoke it

00:47:24,240 --> 00:47:30,160
immediately hence the name this is all

00:47:27,760 --> 00:47:32,000
red because

00:47:30,160 --> 00:47:33,119
um it doesn't know how to infer the type

00:47:32,000 --> 00:47:36,160
but i actually want to change it anyway

00:47:33,119 --> 00:47:37,280
and just return the integers here

00:47:36,160 --> 00:47:40,400
you'll see where i'm going with this in

00:47:37,280 --> 00:47:40,400
a moment i hope

00:47:40,880 --> 00:47:45,119
so that's initialized our final square

00:47:43,680 --> 00:47:45,680
it's either the square that was passed

00:47:45,119 --> 00:47:48,720
in

00:47:45,680 --> 00:47:48,720
or or the target

00:47:49,040 --> 00:47:55,200
that's always going to be a move to so

00:47:52,880 --> 00:47:57,520
i can now write this in terms of final

00:47:55,200 --> 00:48:00,559
square

00:47:57,520 --> 00:48:07,839
and then do an else

00:48:00,559 --> 00:48:07,839
and here's where our move comes back in

00:48:14,720 --> 00:48:18,160
there so

00:48:19,280 --> 00:48:22,559
just to go over that again because i did

00:48:20,720 --> 00:48:26,160
quite a bit in one go

00:48:22,559 --> 00:48:29,119
we pushed our mapping into this lambda

00:48:26,160 --> 00:48:30,640
so captured square so we can refer to it

00:48:29,119 --> 00:48:32,960
and we returned either the mapped

00:48:30,640 --> 00:48:35,280
square or the original square as final

00:48:32,960 --> 00:48:37,119
square

00:48:35,280 --> 00:48:38,880
then separately being referred to final

00:48:37,119 --> 00:48:40,160
square check whether that's the winning

00:48:38,880 --> 00:48:43,359
move

00:48:40,160 --> 00:48:46,480
if not we'll return just that as a move

00:48:43,359 --> 00:48:48,960
that should be enough to

00:48:46,480 --> 00:48:50,000
actually make that pass as well and

00:48:48,960 --> 00:48:52,240
we're green

00:48:50,000 --> 00:48:56,240
that all worked didn't break anything

00:48:52,240 --> 00:48:56,240
else and we've got our new functionality

00:48:56,400 --> 00:48:59,920
now the final thing i would do but i'm

00:48:58,480 --> 00:49:02,000
going to skip ahead

00:48:59,920 --> 00:49:03,680
is just to look at what happens if you

00:49:02,000 --> 00:49:06,079
ask for a

00:49:03,680 --> 00:49:07,200
a square beyond the end and then we add

00:49:06,079 --> 00:49:09,760
a new state called

00:49:07,200 --> 00:49:12,640
no move because you have to miss a go

00:49:09,760 --> 00:49:16,800
that ends up just adding an extra

00:49:12,640 --> 00:49:18,880
an extra if else here and so our final

00:49:16,800 --> 00:49:22,720
implementation

00:49:18,880 --> 00:49:24,400
basically looks like this lambda to map

00:49:22,720 --> 00:49:26,079
from our input square to an intermediate

00:49:24,400 --> 00:49:27,359
state

00:49:26,079 --> 00:49:30,480
and then we look at our intermediate

00:49:27,359 --> 00:49:33,839
state and map that to our output state

00:49:30,480 --> 00:49:36,960
and that's it no mutability

00:49:33,839 --> 00:49:38,000
just two straightforward mappings which

00:49:36,960 --> 00:49:40,160
we arrived at

00:49:38,000 --> 00:49:41,280
at least primarily because of the way i

00:49:40,160 --> 00:49:42,480
was test driving it

00:49:41,280 --> 00:49:44,720
obviously i did went through this a few

00:49:42,480 --> 00:49:46,559
times the first time to arrive at that

00:49:44,720 --> 00:49:48,079
but that's another useful properties you

00:49:46,559 --> 00:49:49,839
can you can uh

00:49:48,079 --> 00:49:51,119
try different things and then roll back

00:49:49,839 --> 00:49:52,960
knowing you can always go back to a

00:49:51,119 --> 00:49:55,760
green state

00:49:52,960 --> 00:49:57,359
so it actually really works well for

00:49:55,760 --> 00:49:59,440
exploring different design spaces as

00:49:57,359 --> 00:50:01,680
well

00:49:59,440 --> 00:50:03,040
now though we stopped there and i was

00:50:01,680 --> 00:50:06,160
going to add one more

00:50:03,040 --> 00:50:07,839
that is mostly done it's only a small

00:50:06,160 --> 00:50:09,280
number of tests

00:50:07,839 --> 00:50:11,200
and that surprises some people don't

00:50:09,280 --> 00:50:12,079
expect but it just feels like there

00:50:11,200 --> 00:50:14,800
should be more tests

00:50:12,079 --> 00:50:16,640
here and you could write more like we

00:50:14,800 --> 00:50:19,920
did with our

00:50:16,640 --> 00:50:20,800
extra uh snake we could write some more

00:50:19,920 --> 00:50:22,160
of those

00:50:20,800 --> 00:50:24,319
just test some more things out just to

00:50:22,160 --> 00:50:26,160
give us a bit more confidence

00:50:24,319 --> 00:50:27,760
there's also things like we didn't test

00:50:26,160 --> 00:50:29,440
for xero

00:50:27,760 --> 00:50:32,079
uh we could write lots more beyond the

00:50:29,440 --> 00:50:33,680
end but they're not really going to be

00:50:32,079 --> 00:50:36,240
we don't expect them to actually change

00:50:33,680 --> 00:50:36,240
our design

00:50:36,480 --> 00:50:40,079
so remember we said about test driven

00:50:38,160 --> 00:50:42,319
design well if we're not driving a

00:50:40,079 --> 00:50:43,920
design it's not really part of tdd

00:50:42,319 --> 00:50:45,839
it doesn't mean it's not valuable but we

00:50:43,920 --> 00:50:47,920
should do that separately

00:50:45,839 --> 00:50:49,599
and in fact we're not going to have time

00:50:47,920 --> 00:50:50,079
for it now but there's a feature in

00:50:49,599 --> 00:50:52,720
catch

00:50:50,079 --> 00:50:54,319
called generators which is really great

00:50:52,720 --> 00:50:56,720
for this because we can

00:50:54,319 --> 00:50:57,680
we can write tests that hold for many

00:50:56,720 --> 00:51:00,480
different values

00:50:57,680 --> 00:51:01,280
called properties that we can generate

00:51:00,480 --> 00:51:04,960
values

00:51:01,280 --> 00:51:08,640
at random in that space say from

00:51:04,960 --> 00:51:11,520
102 to um the max of

00:51:08,640 --> 00:51:12,960
uint32 and it will just every time you

00:51:11,520 --> 00:51:14,960
run it it would test

00:51:12,960 --> 00:51:16,559
a different subset of that randomly

00:51:14,960 --> 00:51:19,440
until eventually it's progressively

00:51:16,559 --> 00:51:22,559
covered more and more of that space

00:51:19,440 --> 00:51:24,079
now again that's not deterministic which

00:51:22,559 --> 00:51:25,440
is another reason it's not really part

00:51:24,079 --> 00:51:28,400
of the tdd cycle

00:51:25,440 --> 00:51:30,079
although you can reproduce these things

00:51:28,400 --> 00:51:32,960
if they do fail

00:51:30,079 --> 00:51:34,079
that's another topic in the um in the

00:51:32,960 --> 00:51:34,960
links that i'm going to give you at the

00:51:34,079 --> 00:51:37,520
end

00:51:34,960 --> 00:51:38,800
there are there are links to things on

00:51:37,520 --> 00:51:40,079
property-based testing you should check

00:51:38,800 --> 00:51:42,240
out if that interests you

00:51:40,079 --> 00:51:43,280
as well as some other forms of testing

00:51:42,240 --> 00:51:45,599
but

00:51:43,280 --> 00:51:46,880
i am aware that we are running short of

00:51:45,599 --> 00:51:47,920
time and i've got a little bit more to

00:51:46,880 --> 00:51:50,480
get through before we

00:51:47,920 --> 00:51:51,680
wrap up so i'm going to cut that short

00:51:50,480 --> 00:51:54,640
for now

00:51:51,680 --> 00:51:56,000
um i should have also mentioned that

00:51:54,640 --> 00:51:59,599
what we didn't do here

00:51:56,000 --> 00:52:01,200
is give names to each of these

00:51:59,599 --> 00:52:02,319
assertions because they are effectively

00:52:01,200 --> 00:52:03,760
separate tests and we should be

00:52:02,319 --> 00:52:05,599
documenting that but

00:52:03,760 --> 00:52:08,319
that would take a bit more time so i

00:52:05,599 --> 00:52:11,520
just want to mention that in passing

00:52:08,319 --> 00:52:15,280
that's the end of that demo

00:52:11,520 --> 00:52:17,760
so let's come back here

00:52:15,280 --> 00:52:19,520
and i say there are a few more questions

00:52:17,760 --> 00:52:22,800
that are coming let's see

00:52:19,520 --> 00:52:25,359
how many we get through of those in time

00:52:22,800 --> 00:52:26,800
um so we've got the couple we're going

00:52:25,359 --> 00:52:29,119
to come back to

00:52:26,800 --> 00:52:30,240
then how important is it to hit 100

00:52:29,119 --> 00:52:31,760
coverage

00:52:30,240 --> 00:52:33,440
i've seen this being done at the expense

00:52:31,760 --> 00:52:35,040
of making tests dependent

00:52:33,440 --> 00:52:38,000
on the internal logic of the function on

00:52:35,040 --> 00:52:41,119
the test is that a worthwhile trade-off

00:52:38,000 --> 00:52:43,839
so short answer no um

00:52:41,119 --> 00:52:45,520
not a worthwhile trade-off i i do have

00:52:43,839 --> 00:52:47,440
in my class i have a slide

00:52:45,520 --> 00:52:49,599
that says how do you test the private

00:52:47,440 --> 00:52:51,920
implementation and the answer is

00:52:49,599 --> 00:52:53,200
you don't and then there's a third

00:52:51,920 --> 00:52:54,960
answer it says but if you really really

00:52:53,200 --> 00:52:56,559
need to we're not going to go into that

00:52:54,960 --> 00:52:58,079
by default you should not be testing

00:52:56,559 --> 00:53:00,880
internal um

00:52:58,079 --> 00:53:02,400
implementation uh there's a few

00:53:00,880 --> 00:53:04,480
exceptions

00:53:02,400 --> 00:53:05,680
to that but by default so in terms of

00:53:04,480 --> 00:53:07,760
code coverage

00:53:05,680 --> 00:53:09,200
well first of all um i'm a little bit

00:53:07,760 --> 00:53:12,880
wary of code coverage

00:53:09,200 --> 00:53:14,240
as a as a goal once you start

00:53:12,880 --> 00:53:15,680
getting code coverage figures that they

00:53:14,240 --> 00:53:16,960
can be useful but they start to become a

00:53:15,680 --> 00:53:18,480
goal in themselves and that's not the

00:53:16,960 --> 00:53:20,480
point of this

00:53:18,480 --> 00:53:23,520
if you're doing strict tdd you should

00:53:20,480 --> 00:53:25,359
naturally end up with 100 code coverage

00:53:23,520 --> 00:53:26,720
at least for everything that you are

00:53:25,359 --> 00:53:28,800
test driving

00:53:26,720 --> 00:53:30,240
uh and you wouldn't even need to measure

00:53:28,800 --> 00:53:32,240
it maybe you measure it just to give you

00:53:30,240 --> 00:53:34,800
some confidence in that

00:53:32,240 --> 00:53:36,079
and that includes private implementation

00:53:34,800 --> 00:53:36,960
because of this rule that you don't

00:53:36,079 --> 00:53:39,040
write a line

00:53:36,960 --> 00:53:40,079
the production code until you have a

00:53:39,040 --> 00:53:43,119
test

00:53:40,079 --> 00:53:46,000
that fails until you've written that

00:53:43,119 --> 00:53:47,359
line of code then even in your private

00:53:46,000 --> 00:53:49,599
implementation there should be no code

00:53:47,359 --> 00:53:52,559
there that's not covered by tests

00:53:49,599 --> 00:53:53,839
but only through the public interface is

00:53:52,559 --> 00:53:57,839
the point

00:53:53,839 --> 00:53:57,839
so i hope that answers your question

00:53:58,240 --> 00:54:04,480
um can you explain your thought process

00:54:02,480 --> 00:54:06,559
in how much code and data structures

00:54:04,480 --> 00:54:08,640
you sketched out before writing your

00:54:06,559 --> 00:54:09,920
first test

00:54:08,640 --> 00:54:12,960
that's a good question and that really

00:54:09,920 --> 00:54:15,520
gets to the uh the art of tdd

00:54:12,960 --> 00:54:16,079
uh there is a misconception that tdd is

00:54:15,520 --> 00:54:18,079
about

00:54:16,079 --> 00:54:19,520
no upfront design and that's definitely

00:54:18,079 --> 00:54:22,720
not the case

00:54:19,520 --> 00:54:24,559
uh there's no big upfront design they're

00:54:22,720 --> 00:54:27,119
the type where people

00:54:24,559 --> 00:54:28,880
go through stages of analysis and draw

00:54:27,119 --> 00:54:30,319
out their their class diagrams and get

00:54:28,880 --> 00:54:32,160
it all pinned down before writing a

00:54:30,319 --> 00:54:33,680
line of code there's more reaction

00:54:32,160 --> 00:54:36,079
against that

00:54:33,680 --> 00:54:38,240
you should have an idea of what you're

00:54:36,079 --> 00:54:39,839
going to do up front

00:54:38,240 --> 00:54:41,920
how much of an idea depends on a number

00:54:39,839 --> 00:54:44,000
of factors

00:54:41,920 --> 00:54:46,079
but generally you have an idea going in

00:54:44,000 --> 00:54:48,079
it's probably gonna look a bit like this

00:54:46,079 --> 00:54:49,920
and you can use that just sort of guide

00:54:48,079 --> 00:54:52,160
how you're gonna start off but then

00:54:49,920 --> 00:54:53,040
as you go as he get feedback from your

00:54:52,160 --> 00:54:56,400
tests

00:54:53,040 --> 00:54:57,920
that may change you may find

00:54:56,400 --> 00:54:59,119
a big part of the design that's going to

00:54:57,920 --> 00:54:59,680
be quite complex you didn't actually

00:54:59,119 --> 00:55:01,359
need

00:54:59,680 --> 00:55:02,799
in order to implement your your

00:55:01,359 --> 00:55:04,319
requirements and so you save yourself a

00:55:02,799 --> 00:55:06,960
maxim effort

00:55:04,319 --> 00:55:08,240
or maybe you had to add some other stuff

00:55:06,960 --> 00:55:09,760
you didn't think of

00:55:08,240 --> 00:55:12,480
and so it wasn't in your original design

00:55:09,760 --> 00:55:15,920
and that changes how how that works

00:55:12,480 --> 00:55:17,040
so it's about starting with a flexible

00:55:15,920 --> 00:55:19,359
idea

00:55:17,040 --> 00:55:20,799
of what you want to do and then being

00:55:19,359 --> 00:55:21,680
able to adapt that over time it's all

00:55:20,799 --> 00:55:23,760
about

00:55:21,680 --> 00:55:25,200
as the agile tagline says you know

00:55:23,760 --> 00:55:28,160
embracing change

00:55:25,200 --> 00:55:29,599
making the code easy to change by making

00:55:28,160 --> 00:55:30,880
sure your test will tell you if you've

00:55:29,599 --> 00:55:34,079
broken anything

00:55:30,880 --> 00:55:36,240
um leaving the design flexible by being

00:55:34,079 --> 00:55:37,119
loosely coupled remember that design

00:55:36,240 --> 00:55:40,240
pressure

00:55:37,119 --> 00:55:40,880
leads us to that um so by making it

00:55:40,240 --> 00:55:45,200
changeable

00:55:40,880 --> 00:55:48,079
means that as we meet un anticipated

00:55:45,200 --> 00:55:50,400
sort of sub requirements we can we can

00:55:48,079 --> 00:55:54,240
adapt to that we can change our design

00:55:50,400 --> 00:55:54,240
um on the fly

00:55:54,319 --> 00:55:57,599
so obviously that's that's quite a big

00:55:56,000 --> 00:56:00,160
topic but hopefully that

00:55:57,599 --> 00:56:01,920
covers your question for now are there

00:56:00,160 --> 00:56:03,280
any rules or principles to consider when

00:56:01,920 --> 00:56:04,880
naming tests or is it a matter of

00:56:03,280 --> 00:56:07,440
preference

00:56:04,880 --> 00:56:09,280
big topic um so you should go for

00:56:07,440 --> 00:56:12,160
descriptive names that should

00:56:09,280 --> 00:56:12,640
capture the expectations of your your

00:56:12,160 --> 00:56:15,119
test

00:56:12,640 --> 00:56:18,319
what you actually expect it to do um

00:56:15,119 --> 00:56:21,520
rather than just oh it does this

00:56:18,319 --> 00:56:22,720
uh and there are some tools for making

00:56:21,520 --> 00:56:25,119
it a bit more structured

00:56:22,720 --> 00:56:27,200
so if you look at bdds given when then

00:56:25,119 --> 00:56:29,200
structuring which catch nicely supports

00:56:27,200 --> 00:56:30,480
that really sort of helps you to write

00:56:29,200 --> 00:56:33,280
nice descriptive

00:56:30,480 --> 00:56:34,079
test names is there a limit to the

00:56:33,280 --> 00:56:37,760
number of checks

00:56:34,079 --> 00:56:38,799
one should put into a single test um

00:56:37,760 --> 00:56:41,119
there's this thing called the single

00:56:38,799 --> 00:56:42,720
assert rule which doesn't really mean

00:56:41,119 --> 00:56:44,060
single assert it just means that you

00:56:42,720 --> 00:56:45,440
shouldn't be

00:56:44,060 --> 00:56:49,119
[Music]

00:56:45,440 --> 00:56:50,880
performing an action and then asserting

00:56:49,119 --> 00:56:52,480
that state and then performing another

00:56:50,880 --> 00:56:54,000
action and performing some different

00:56:52,480 --> 00:56:55,440
state

00:56:54,000 --> 00:56:57,440
but sometimes you might perform an

00:56:55,440 --> 00:56:59,839
action and then you have to

00:56:57,440 --> 00:57:01,680
assert on several different things in

00:56:59,839 --> 00:57:02,720
order to verify that one piece of state

00:57:01,680 --> 00:57:04,319
change

00:57:02,720 --> 00:57:06,079
and that's considered a single logical

00:57:04,319 --> 00:57:07,839
assertion that's okay so there's not

00:57:06,079 --> 00:57:11,440
really a hard and fast rule

00:57:07,839 --> 00:57:14,240
but um if you get lots of asserts

00:57:11,440 --> 00:57:16,160
then you should question whether you are

00:57:14,240 --> 00:57:18,319
testing more than one thing

00:57:16,160 --> 00:57:20,240
so in the example i just gave i i was

00:57:18,319 --> 00:57:21,599
trying to say

00:57:20,240 --> 00:57:23,119
what i would have done is actually

00:57:21,599 --> 00:57:24,640
separate them into separate sections

00:57:23,119 --> 00:57:26,319
which you can do in catch

00:57:24,640 --> 00:57:27,599
which are all effectively like separate

00:57:26,319 --> 00:57:29,280
tests and that would have been a better

00:57:27,599 --> 00:57:31,359
structuring but we didn't get time to go

00:57:29,280 --> 00:57:32,880
into that

00:57:31,359 --> 00:57:34,400
how often should you commit code during

00:57:32,880 --> 00:57:37,440
this sort of quick tdd

00:57:34,400 --> 00:57:39,280
um fairly often um

00:57:37,440 --> 00:57:40,799
particularly after a refactoring you may

00:57:39,280 --> 00:57:41,839
want to do it after the green phase as

00:57:40,799 --> 00:57:44,000
well

00:57:41,839 --> 00:57:45,760
uh again another nice feature of c-line

00:57:44,000 --> 00:57:47,680
is something called local history

00:57:45,760 --> 00:57:49,200
which sort of does that for you with its

00:57:47,680 --> 00:57:50,960
own sort of built-in

00:57:49,200 --> 00:57:52,559
it's like an undo on steroids but it's

00:57:50,960 --> 00:57:54,880
um it works a bit like version control

00:57:52,559 --> 00:57:56,400
so every time you do a compile or a test

00:57:54,880 --> 00:57:58,000
it gives you a checkpoint that you can

00:57:56,400 --> 00:57:58,640
go back to in diff just like version

00:57:58,000 --> 00:58:00,240
control

00:57:58,640 --> 00:58:01,920
if you don't have that you can use a

00:58:00,240 --> 00:58:04,079
local version control

00:58:01,920 --> 00:58:05,520
and maybe do squash commits later that's

00:58:04,079 --> 00:58:06,400
quite effective but of course that's

00:58:05,520 --> 00:58:08,640
going to be extra

00:58:06,400 --> 00:58:10,079
overhead on the cycle so you may not

00:58:08,640 --> 00:58:12,160
want to do that every time

00:58:10,079 --> 00:58:13,920
but definitely not quite nice points

00:58:12,160 --> 00:58:16,319
after refactoring you probably want to

00:58:13,920 --> 00:58:16,319
do that

00:58:17,599 --> 00:58:20,559
how much designing should be done up

00:58:19,200 --> 00:58:21,520
front before beginning to write the

00:58:20,559 --> 00:58:25,520
tests

00:58:21,520 --> 00:58:25,520
i sort of covered that i think um

00:58:26,079 --> 00:58:30,480
the short answer is just enough which i

00:58:28,720 --> 00:58:32,720
know is not very satisfactory but

00:58:30,480 --> 00:58:33,920
so it is about having an idea of the

00:58:32,720 --> 00:58:34,799
design and you may even have some

00:58:33,920 --> 00:58:35,920
sketches on it

00:58:34,799 --> 00:58:37,920
but you don't want to invest a lot of

00:58:35,920 --> 00:58:39,440
time trying to pin it down too much

00:58:37,920 --> 00:58:41,520
um i think that's as much as i can say

00:58:39,440 --> 00:58:43,599
in in a few seconds

00:58:41,520 --> 00:58:45,839
um where do you typically put your catch

00:58:43,599 --> 00:58:50,240
test cases in their own file

00:58:45,839 --> 00:58:52,319
with the source um so i usually

00:58:50,240 --> 00:58:54,559
write the production code in the same

00:58:52,319 --> 00:58:56,319
file as test code

00:58:54,559 --> 00:58:58,480
which has the advantage it keeps it

00:58:56,319 --> 00:59:00,079
better isolated while i'm developing it

00:58:58,480 --> 00:59:01,520
and then when it's sort of mostly baked

00:59:00,079 --> 00:59:02,720
then i'll move it into its own files and

00:59:01,520 --> 00:59:03,599
it can start interacting with the rest

00:59:02,720 --> 00:59:05,119
of the system

00:59:03,599 --> 00:59:07,119
but so that's my preference and it also

00:59:05,119 --> 00:59:09,920
doesn't always work uh other people have

00:59:07,119 --> 00:59:09,920
different preferences

00:59:10,079 --> 00:59:15,599
um why did catch two fork from catch

00:59:13,440 --> 00:59:17,440
it was mostly well partly because we

00:59:15,599 --> 00:59:19,520
wanted to move to c plus plus 11

00:59:17,440 --> 00:59:21,440
and it was a big change but also just to

00:59:19,520 --> 00:59:22,720
get that naming in because people found

00:59:21,440 --> 00:59:24,480
that catch on its own wasn't very

00:59:22,720 --> 00:59:27,359
googleable

00:59:24,480 --> 00:59:28,319
um the two big questions to do with

00:59:27,359 --> 00:59:30,319
legacy code which

00:59:28,319 --> 00:59:31,520
i'm afraid we're actually out of time to

00:59:30,319 --> 00:59:32,240
to get to because that's quite a big

00:59:31,520 --> 00:59:35,520
topic

00:59:32,240 --> 00:59:38,319
this whole extra section i didn't get to

00:59:35,520 --> 00:59:39,520
uh so maybe if you find me afterwards we

00:59:38,319 --> 00:59:41,119
can

00:59:39,520 --> 00:59:43,359
go through some of that but i think at

00:59:41,119 --> 00:59:44,559
this point i'm gonna have to wrap up so

00:59:43,359 --> 00:59:46,319
i'm gonna whiz through the next few

00:59:44,559 --> 00:59:48,400
slides i was going to go around the tdd

00:59:46,319 --> 00:59:51,680
cycle again

00:59:48,400 --> 00:59:53,680
the big insight here is that as you go

00:59:51,680 --> 00:59:56,079
through different stages

00:59:53,680 --> 00:59:57,520
you actually go through different mental

00:59:56,079 --> 00:59:58,960
modes

00:59:57,520 --> 01:00:00,240
so you have different sets of mental

00:59:58,960 --> 01:00:02,400
resources that you can bring to a

01:00:00,240 --> 01:00:04,240
problem so you start off with

01:00:02,400 --> 01:00:05,680
high level design requirements user

01:00:04,240 --> 01:00:08,720
experience

01:00:05,680 --> 01:00:10,160
that's your mental focus and then

01:00:08,720 --> 01:00:11,760
you can put that to one side because a

01:00:10,160 --> 01:00:13,760
test has you and you

01:00:11,760 --> 01:00:15,359
concentrate just on making the test pass

01:00:13,760 --> 01:00:17,280
it's like this

01:00:15,359 --> 01:00:18,480
hacker mentality race to green you can

01:00:17,280 --> 01:00:19,760
actually give yourself permission to

01:00:18,480 --> 01:00:21,760
just hack code

01:00:19,760 --> 01:00:23,839
which is actually quite fun once you've

01:00:21,760 --> 01:00:26,000
given yourself that permission

01:00:23,839 --> 01:00:27,440
and then the refactor stage the only

01:00:26,000 --> 01:00:30,640
thing you need to worry about there

01:00:27,440 --> 01:00:33,359
is design principles clean code um

01:00:30,640 --> 01:00:34,960
restructuring it and then you go back

01:00:33,359 --> 01:00:36,400
around again

01:00:34,960 --> 01:00:38,480
i wanted to say more about that but

01:00:36,400 --> 01:00:40,079
we're going to need to wrap up so we

01:00:38,480 --> 01:00:43,359
won't really get

01:00:40,079 --> 01:00:46,480
time to look at my bonus um

01:00:43,359 --> 01:00:46,480
bonus uh material

01:00:47,040 --> 01:00:50,319
one of which was the legacy code so

01:00:49,440 --> 01:00:54,079
sorry about that

01:00:50,319 --> 01:00:54,720
but on this link level of indirection

01:00:54,079 --> 01:00:59,359
dot com

01:00:54,720 --> 01:01:03,359
slash tdcpp.html for

01:00:59,359 --> 01:01:06,799
test driven c plus um i do have

01:01:03,359 --> 01:01:09,119
a whole load of articles blogs videos

01:01:06,799 --> 01:01:10,559
on all of these topics so you can dig

01:01:09,119 --> 01:01:12,960
into that a bit on your own

01:01:10,559 --> 01:01:13,760
um of course you can always reach out to

01:01:12,960 --> 01:01:16,480
me to

01:01:13,760 --> 01:01:18,000
come into your company and give you a a

01:01:16,480 --> 01:01:20,799
workshop as well if you want

01:01:18,000 --> 01:01:22,240
um or just catch me afterwards or on

01:01:20,799 --> 01:01:24,400
twitter

01:01:22,240 --> 01:01:25,280
and i think we're gonna have to wrap up

01:01:24,400 --> 01:01:26,880
there so

01:01:25,280 --> 01:01:39,839
i'll speak to you all afterwards thank

01:01:26,880 --> 01:01:39,839
you very much

01:01:47,760 --> 01:01:49,839

YouTube URL: https://www.youtube.com/watch?v=N2gTxeIHMP0


