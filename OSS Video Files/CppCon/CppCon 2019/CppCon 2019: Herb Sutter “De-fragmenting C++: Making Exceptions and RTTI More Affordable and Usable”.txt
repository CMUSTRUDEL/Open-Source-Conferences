Title: CppCon 2019: Herb Sutter “De-fragmenting C++: Making Exceptions and RTTI More Affordable and Usable”
Publication date: 2019-09-23
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
A fundamental reason why C++ is successful and loved is its adherence to Stroustrup’s zero-overhead principle: You don’t pay for what you don’t use, and if you do use a feature you can’t reasonably code it better by hand. In the C++ language itself, there are only two features that violate the zero-overhead principle, exception handling and RTTI – and, unsurprisingly, these are also the only two C++ language features that every C++ compiler has switches to turn off and that are regularly discouraged or even banned. This matters because not using these features is the largest current cause of fragmentation of the C++ community into incompatible dialects, and the cause of recurring problems including type confusion security vulnerabilities arising from “didn’t down-cast using dynamic_cast because that would be too slow.” This talk is about ongoing long-term efforts to try to unify the community in this area, not by replacing exceptions and RTTI, but by doubling down: fully embracing exceptions and RTTI, and improving them so they can be zero-overhead too.
— 
Herb Sutter
Software architect, Microsoft
Herb is an author, designer of several Standard C++ features, and chair of the ISO C++ committee and the Standard C++ Foundation. His current interest is simplifying C++.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,269 --> 00:00:14,660
so now I'm going to introduce someone

00:00:12,080 --> 00:00:15,920
who again as most of our keynote

00:00:14,660 --> 00:00:18,439
speakers and he's little introduction

00:00:15,920 --> 00:00:22,700
but it really cannot be overstated how

00:00:18,439 --> 00:00:24,169
much herb does for C++ not just all of

00:00:22,700 --> 00:00:26,560
his work on the standards committee all

00:00:24,169 --> 00:00:28,670
the wonderful papers he writes the

00:00:26,560 --> 00:00:30,650
contributions he gives to various other

00:00:28,670 --> 00:00:32,449
projects also all the work he does to

00:00:30,650 --> 00:00:34,489
this conference all the work he does for

00:00:32,449 --> 00:00:36,980
this community making a better place to

00:00:34,489 --> 00:00:40,720
be so please join me in giving a very

00:00:36,980 --> 00:00:40,720
warm welcome to herb Sutter

00:00:48,320 --> 00:00:54,510
thank you well thank you for that warm

00:00:53,070 --> 00:00:57,329
welcome thank you for that introduction

00:00:54,510 --> 00:01:01,350
and thank you all for being here this

00:00:57,329 --> 00:01:04,710
week and here we are Friday just about

00:01:01,350 --> 00:01:07,049
evening and I hope you enjoyed the week

00:01:04,710 --> 00:01:10,490
I certainly enjoyed so many of the talks

00:01:07,049 --> 00:01:12,690
and the panels the breath and and

00:01:10,490 --> 00:01:14,610
differences in people that we could

00:01:12,690 --> 00:01:17,820
enjoy no matter what sector we're in

00:01:14,610 --> 00:01:20,130
what way we use C++ where we live in the

00:01:17,820 --> 00:01:23,069
world or anything else that we have a

00:01:20,130 --> 00:01:26,100
lot in common here so if you enjoyed

00:01:23,069 --> 00:01:28,050
some talk sometime this week possibly

00:01:26,100 --> 00:01:29,250
multiple in the same timeslot where

00:01:28,050 --> 00:01:31,830
you're going to get the next one YouTube

00:01:29,250 --> 00:01:33,899
please join me in thanking all the

00:01:31,830 --> 00:01:35,700
speakers all the volunteers and everyone

00:01:33,899 --> 00:01:46,619
who made this conference possible it's

00:01:35,700 --> 00:01:52,470
such a delight so thank you very much

00:01:46,619 --> 00:01:56,429
for that let's talk for a moment about a

00:01:52,470 --> 00:01:59,580
topic that is very general this is a

00:01:56,429 --> 00:02:02,039
lead-in to the topic so specifically of

00:01:59,580 --> 00:02:03,360
exception handling and the runtime type

00:02:02,039 --> 00:02:06,060
information which are the two main

00:02:03,360 --> 00:02:10,440
things that we'll talk about about 70%

00:02:06,060 --> 00:02:11,840
and 30% in about that order but first

00:02:10,440 --> 00:02:14,640
it's useful to have some perspective

00:02:11,840 --> 00:02:16,590
because it's very easy to solve a point

00:02:14,640 --> 00:02:20,160
problem I see a problem I'm going to

00:02:16,590 --> 00:02:23,550
attack that but no problem exists in a

00:02:20,160 --> 00:02:25,590
vacuum and there are usually many and

00:02:23,550 --> 00:02:27,030
often principled reasons to address a

00:02:25,590 --> 00:02:29,400
problem is so I want to set the stage

00:02:27,030 --> 00:02:31,110
for why I think these are important

00:02:29,400 --> 00:02:33,209
because there are many other problems we

00:02:31,110 --> 00:02:34,379
could be trying to solve and and as you

00:02:33,209 --> 00:02:37,860
know I'm working on several different

00:02:34,379 --> 00:02:40,920
proposals but why these particular ones

00:02:37,860 --> 00:02:44,300
so first of all Andre how many of you

00:02:40,920 --> 00:02:44,300
enjoyed Andres keynote

00:02:47,300 --> 00:02:52,160
I cannot promise to be as entertaining

00:02:49,700 --> 00:02:54,650
as ondrea's I don't know if that's

00:02:52,160 --> 00:02:59,990
humanly possible for anyone else but he

00:02:54,650 --> 00:03:03,380
is such a troll sometimes so he he

00:02:59,990 --> 00:03:05,660
trolled you with some assembler said you

00:03:03,380 --> 00:03:08,300
have 15 minutes to recognize this common

00:03:05,660 --> 00:03:10,250
algorithm and then after about 5 seconds

00:03:08,300 --> 00:03:12,260
he said if you have 15 seconds then

00:03:10,250 --> 00:03:13,910
after about 5 seconds he said no it's

00:03:12,260 --> 00:03:16,190
just some random random assembler just

00:03:13,910 --> 00:03:18,770
trying to get your attention this is not

00:03:16,190 --> 00:03:20,900
that this is a real piece of assembler

00:03:18,770 --> 00:03:24,940
and you will get 15 seconds and I'm

00:03:20,900 --> 00:03:24,940
curious to see what you think of it

00:03:25,750 --> 00:03:39,230
please raise your hand when you think

00:03:27,710 --> 00:03:41,390
you recognize what this is doing did I

00:03:39,230 --> 00:03:42,650
see missiny hands I see a head just yell

00:03:41,390 --> 00:03:48,920
out what you think is doing a couple of

00:03:42,650 --> 00:03:51,500
words say again is space no but that's a

00:03:48,920 --> 00:03:56,360
valiant effort anyone else want to shout

00:03:51,500 --> 00:04:02,000
out one more dynamic I think I heard

00:03:56,360 --> 00:04:06,070
that did I heard dynamic cast what in

00:04:02,000 --> 00:04:08,450
five instructions are you kidding me

00:04:06,070 --> 00:04:11,240
well kind of sorta

00:04:08,450 --> 00:04:14,660
if I take out the redacted parts you'll

00:04:11,240 --> 00:04:17,959
see that the first two loads are about D

00:04:14,660 --> 00:04:23,180
table pointers and then we do a range

00:04:17,959 --> 00:04:25,520
check to do a cast this is in five

00:04:23,180 --> 00:04:26,840
instructions ignoring there's a you can

00:04:25,520 --> 00:04:28,160
also do a null check which is two more

00:04:26,840 --> 00:04:30,820
instructions than the top and that can

00:04:28,160 --> 00:04:34,310
often be elided this is a five

00:04:30,820 --> 00:04:37,070
instruction dynamic cast that cannot do

00:04:34,310 --> 00:04:40,520
the general dynamic cast but that can do

00:04:37,070 --> 00:04:43,600
down casts not cross but down only and

00:04:40,520 --> 00:04:47,810
not across a virtual inheritance link

00:04:43,600 --> 00:04:50,300
turns out if that's all you need we can

00:04:47,810 --> 00:04:52,400
do that way more efficiently than today

00:04:50,300 --> 00:04:56,630
we'll come back to this example at the

00:04:52,400 --> 00:04:59,360
end of the talk so to set the stage this

00:04:56,630 --> 00:05:01,230
is the context I was talking about last

00:04:59,360 --> 00:05:03,270
year I showed this law

00:05:01,230 --> 00:05:04,620
about what is C++ it was actually

00:05:03,270 --> 00:05:06,690
several slides and this was sort of the

00:05:04,620 --> 00:05:08,490
culmination and working from the bottom

00:05:06,690 --> 00:05:11,280
up it was about saying what things are

00:05:08,490 --> 00:05:14,970
not core to C++ like any particular

00:05:11,280 --> 00:05:17,430
syntax we add and syntax all the time

00:05:14,970 --> 00:05:19,260
tedium lack of good defaults just ugly

00:05:17,430 --> 00:05:20,610
this is not core to C++ it's just

00:05:19,260 --> 00:05:22,800
something we put up with sometimes and

00:05:20,610 --> 00:05:25,290
we try to fix it and also the middle

00:05:22,800 --> 00:05:27,300
part backwards source compatibility is

00:05:25,290 --> 00:05:29,420
not really core to C++ but it's very

00:05:27,300 --> 00:05:32,640
important to adoption adoptability

00:05:29,420 --> 00:05:34,350
migrating code bases forward but it's

00:05:32,640 --> 00:05:36,930
really the top part and especially the

00:05:34,350 --> 00:05:40,680
first bullet I want to focus it on for

00:05:36,930 --> 00:05:42,030
today the zero overhead principle that I

00:05:40,680 --> 00:05:44,460
couldn't write zero overhead

00:05:42,030 --> 00:05:48,000
abstractions it is true there are no

00:05:44,460 --> 00:05:50,400
zero cost abstractions because zero

00:05:48,000 --> 00:05:51,840
overhead does not mean zero cost the

00:05:50,400 --> 00:05:54,000
people often make this mistake so let me

00:05:51,840 --> 00:05:55,380
be very clear what zero overhead means

00:05:54,000 --> 00:05:57,390
two things

00:05:55,380 --> 00:06:00,930
there are both on the slide you don't

00:05:57,390 --> 00:06:03,570
pay for it if you don't use it and if

00:06:00,930 --> 00:06:05,220
you do use it you can't do better by

00:06:03,570 --> 00:06:08,610
hand and we know your C and C++

00:06:05,220 --> 00:06:10,830
programmer so you're gonna try but if

00:06:08,610 --> 00:06:13,800
you do use it you can't do better by

00:06:10,830 --> 00:06:16,740
hand what those two things add up to is

00:06:13,800 --> 00:06:21,270
there is no valid technical reason not

00:06:16,740 --> 00:06:23,460
to use the feature and as we evolve C++

00:06:21,270 --> 00:06:28,170
one of the things that we're observing

00:06:23,460 --> 00:06:30,390
happening before our eyes is largely we

00:06:28,170 --> 00:06:33,360
are moving to be a more static language

00:06:30,390 --> 00:06:35,190
we are doing we still have virtual

00:06:33,360 --> 00:06:37,230
functions we love them but instead of

00:06:35,190 --> 00:06:39,120
the 90s when everything was about oo we

00:06:37,230 --> 00:06:40,590
are doing more and more templates since

00:06:39,120 --> 00:06:43,950
the nineties and it's only been ramping

00:06:40,590 --> 00:06:45,810
up from there we are doing contracts for

00:06:43,950 --> 00:06:46,170
example soon they almost made sequel so

00:06:45,810 --> 00:06:48,600
sweaty

00:06:46,170 --> 00:06:50,220
hopefully sequel sauce 23 which yes

00:06:48,600 --> 00:06:52,050
could be about runtime checking but

00:06:50,220 --> 00:06:55,440
they're also about static checking

00:06:52,050 --> 00:06:58,050
enabling static analysis and so this

00:06:55,440 --> 00:06:59,670
talk is talking about how static can

00:06:58,050 --> 00:07:02,640
help us because very often when we find

00:06:59,670 --> 00:07:05,610
we have a performance problem in the

00:07:02,640 --> 00:07:08,370
language especially often the root is

00:07:05,610 --> 00:07:11,550
the word dynamic and if we can make

00:07:08,370 --> 00:07:14,370
dynamic be static that is often a good

00:07:11,550 --> 00:07:15,199
solution path to fixing the problem that

00:07:14,370 --> 00:07:19,289
were faced

00:07:15,199 --> 00:07:21,029
as we evolved C++ historically and you

00:07:19,289 --> 00:07:23,689
can quibble about sort of the sizes of

00:07:21,029 --> 00:07:26,309
these I'm gonna give sort of a ruff-ruff

00:07:23,689 --> 00:07:28,379
priority we've been very good at adding

00:07:26,309 --> 00:07:30,449
things we just are shipping a sea

00:07:28,379 --> 00:07:32,370
fossils 20 standard next year that has

00:07:30,449 --> 00:07:35,279
many major features it's the biggest

00:07:32,370 --> 00:07:39,839
future release since C+ 11 so we're very

00:07:35,279 --> 00:07:43,080
good at adding features sometimes we fix

00:07:39,839 --> 00:07:44,699
things and by this I don't mean the

00:07:43,080 --> 00:07:46,080
sometimes we fix things by adding

00:07:44,699 --> 00:07:47,550
features but in this category I'm

00:07:46,080 --> 00:07:49,860
specifically saying we take an existing

00:07:47,550 --> 00:07:50,999
feature and say we add an incremental

00:07:49,860 --> 00:07:53,039
knob on it or something

00:07:50,999 --> 00:07:54,599
like for instance enabling this capture

00:07:53,039 --> 00:07:57,180
and move capture and lambdas we already

00:07:54,599 --> 00:07:58,949
had lambdas but certain cases were hard

00:07:57,180 --> 00:08:01,979
to use so we had to go and fix it so we

00:07:58,949 --> 00:08:03,960
do do some of that but I perhaps not as

00:08:01,979 --> 00:08:07,919
much as we're good at adding new shiny

00:08:03,960 --> 00:08:10,319
things and rarely in part because of

00:08:07,919 --> 00:08:13,529
backward compatibility rarely do we

00:08:10,319 --> 00:08:15,449
actually simplify something in place now

00:08:13,529 --> 00:08:16,949
often we simplify by going to the top

00:08:15,449 --> 00:08:19,080
thing by adding a new feature that

00:08:16,949 --> 00:08:20,399
subsumes the bottom one but that means

00:08:19,080 --> 00:08:22,709
we now have a language that has both of

00:08:20,399 --> 00:08:25,080
them so we have using aliases are much

00:08:22,709 --> 00:08:26,789
more general than type deaths but type

00:08:25,080 --> 00:08:29,789
tests are still there that's the code

00:08:26,789 --> 00:08:31,680
still compiles so what can we do to

00:08:29,789 --> 00:08:33,449
simplify we haven't maybe done as much

00:08:31,680 --> 00:08:34,319
there and in part we in fairness we

00:08:33,449 --> 00:08:37,079
couldn't because of backward

00:08:34,319 --> 00:08:42,329
compatibility so I have a modest

00:08:37,079 --> 00:08:44,910
proposal what if in future c-plus us

00:08:42,329 --> 00:08:47,069
evolution we reversed the amount of

00:08:44,910 --> 00:08:48,750
effort we put into those three things is

00:08:47,069 --> 00:08:51,060
that something you would be interested

00:08:48,750 --> 00:08:53,720
in seeing as c-plus involves in the next

00:08:51,060 --> 00:08:53,720
five or ten years

00:08:58,089 --> 00:09:04,459
well that's heartening now easier said

00:09:01,250 --> 00:09:06,589
than done but you know first we have to

00:09:04,459 --> 00:09:07,730
have an aspirational goal and notice

00:09:06,589 --> 00:09:09,320
there are some arrows on the screen

00:09:07,730 --> 00:09:11,149
because sometimes we do need to add

00:09:09,320 --> 00:09:13,040
things so some of you I'm sure are

00:09:11,149 --> 00:09:14,779
thinking but herb you're talking you're

00:09:13,040 --> 00:09:16,399
about metaclasses which is now a thin

00:09:14,779 --> 00:09:17,870
layer over reflection and generation you

00:09:16,399 --> 00:09:21,230
want to add reflection to the language

00:09:17,870 --> 00:09:22,779
uh-huh yeah that's a big thing but it

00:09:21,230 --> 00:09:25,070
greatly simplifies the code we write

00:09:22,779 --> 00:09:27,529
that's why I want to add it so when we

00:09:25,070 --> 00:09:29,389
add things or when we fix things it

00:09:27,529 --> 00:09:31,190
should be with a view especially to

00:09:29,389 --> 00:09:32,600
having a simplification target and so

00:09:31,190 --> 00:09:34,399
I'm going to present the things

00:09:32,600 --> 00:09:35,930
especially with exception handling that

00:09:34,399 --> 00:09:38,240
I'm going to present in this context

00:09:35,930 --> 00:09:40,459
with the focus on simplification in this

00:09:38,240 --> 00:09:42,709
talk were mainly focused on fixing two

00:09:40,459 --> 00:09:47,170
things and then seeing also how they

00:09:42,709 --> 00:09:52,339
help us simplify code there are

00:09:47,170 --> 00:09:57,980
notoriously only two features in the

00:09:52,339 --> 00:10:02,180
entire C++ language that every compiler

00:09:57,980 --> 00:10:04,339
has a tool to switch to turn off every

00:10:02,180 --> 00:10:06,829
compiler and in the case of the macro

00:10:04,339 --> 00:10:09,920
has exceptions some standard libraries

00:10:06,829 --> 00:10:11,209
and those are exceptions in our TTI and

00:10:09,920 --> 00:10:14,420
in case you're not close enough to see

00:10:11,209 --> 00:10:16,610
the slides that is not a love emoji that

00:10:14,420 --> 00:10:21,230
is a heartbreak emoji according to emoji

00:10:16,610 --> 00:10:22,670
pedia because we love exceptions but for

00:10:21,230 --> 00:10:24,709
some of us they've led us down and we

00:10:22,670 --> 00:10:27,410
love our TTI but for some of us they've

00:10:24,709 --> 00:10:29,630
led us down and the problem is actually

00:10:27,410 --> 00:10:32,029
already on the screen the arty in our

00:10:29,630 --> 00:10:34,820
TTI what does that stand for run time

00:10:32,029 --> 00:10:38,449
it's dynamic there's that dynamic word

00:10:34,820 --> 00:10:41,870
again and it's a feature where the data

00:10:38,449 --> 00:10:45,140
has to be available at runtime a lot

00:10:41,870 --> 00:10:47,600
like dotnet and Java metadata in case

00:10:45,140 --> 00:10:50,810
anyone ever asks for it even if they

00:10:47,600 --> 00:10:52,760
don't and other languages are all in on

00:10:50,810 --> 00:10:54,610
that and we only have it for one or two

00:10:52,760 --> 00:10:57,230
features that which is already better

00:10:54,610 --> 00:10:58,519
but that's a symptom and so I'm going to

00:10:57,230 --> 00:10:59,899
give you a sneak peek of the whole talk

00:10:58,519 --> 00:11:01,329
so if you have to leave early to catch a

00:10:59,899 --> 00:11:03,790
flight here's the spoiler

00:11:01,329 --> 00:11:07,160
today's exception handling requires

00:11:03,790 --> 00:11:08,000
throwing type erased values that means

00:11:07,160 --> 00:11:10,250
you're going to dine

00:11:08,000 --> 00:11:11,900
we allocate when you throw it means that

00:11:10,250 --> 00:11:12,710
you're going to do a form of our TTI

00:11:11,900 --> 00:11:14,870
when you catch

00:11:12,710 --> 00:11:16,640
that's overhead whether you ask for it

00:11:14,870 --> 00:11:21,200
or not even if you throw 42 and catch

00:11:16,640 --> 00:11:23,900
int and our TTI requires binary system

00:11:21,200 --> 00:11:27,380
metadata strings of type information a

00:11:23,900 --> 00:11:30,890
hash values of types whether the program

00:11:27,380 --> 00:11:32,210
ever uses them or not now you will find

00:11:30,890 --> 00:11:33,620
people who defend this saying well we

00:11:32,210 --> 00:11:36,470
could optimize this better and they are

00:11:33,620 --> 00:11:39,320
perfectly correct but you can't get rid

00:11:36,470 --> 00:11:41,090
of them by construction because some

00:11:39,320 --> 00:11:42,500
code might ask for it so they must the

00:11:41,090 --> 00:11:44,840
information must be there

00:11:42,500 --> 00:11:46,790
and those optimizations are really I

00:11:44,840 --> 00:11:49,130
will characterize they would probably

00:11:46,790 --> 00:11:50,840
disagree but I will characterize as they

00:11:49,130 --> 00:11:55,630
are digging ourselves out of a hole that

00:11:50,840 --> 00:11:58,370
we already jumped into just a suggestion

00:11:55,630 --> 00:12:01,970
how about not jumping into the hole

00:11:58,370 --> 00:12:03,800
unless we need the information unless we

00:12:01,970 --> 00:12:05,300
need the we know there's treasure right

00:12:03,800 --> 00:12:06,980
here in the field instead of digging up

00:12:05,300 --> 00:12:09,020
the whole field and jumping into every

00:12:06,980 --> 00:12:10,370
hole oh no only the time that we need to

00:12:09,020 --> 00:12:14,540
get the treasure chest we'll go and

00:12:10,370 --> 00:12:17,570
we'll dig there it will opt-in and so a

00:12:14,540 --> 00:12:20,720
pay for what you use principle to keep

00:12:17,570 --> 00:12:24,710
in mind for the rest of the talk make

00:12:20,720 --> 00:12:27,350
things static compile time by default

00:12:24,710 --> 00:12:30,320
and dynamic is still there we're not

00:12:27,350 --> 00:12:31,880
taking anything away from you but it's

00:12:30,320 --> 00:12:34,460
only if you ask for it and make it easy

00:12:31,880 --> 00:12:36,860
to ask for making convenient but dynamic

00:12:34,460 --> 00:12:39,410
by opt-in static by default dynamic by

00:12:36,860 --> 00:12:41,180
opt-in so let's take a look at the first

00:12:39,410 --> 00:12:43,580
part of the talk which is about

00:12:41,180 --> 00:12:45,589
exception handling the first thing to do

00:12:43,580 --> 00:12:47,300
is establish the problem then we'll talk

00:12:45,589 --> 00:12:48,920
about what is an error for a couple of

00:12:47,300 --> 00:12:51,350
slides just to make sure we know haven't

00:12:48,920 --> 00:12:52,610
reminds what a runtime error is and then

00:12:51,350 --> 00:12:54,440
I'll show the proposals that I'm

00:12:52,610 --> 00:12:55,970
bringing forward and again I should put

00:12:54,440 --> 00:12:57,890
into slavery here I do chair the

00:12:55,970 --> 00:12:59,720
Standards Committee but this is just me

00:12:57,890 --> 00:13:00,980
talking as an individual the Standards

00:12:59,720 --> 00:13:03,560
Committee may or may not like any of

00:13:00,980 --> 00:13:04,730
this I'm not speaking for them but as I

00:13:03,560 --> 00:13:06,770
go through the talk in a couple of

00:13:04,730 --> 00:13:08,780
places I will show straw poll results as

00:13:06,770 --> 00:13:10,580
to what the committee does think and

00:13:08,780 --> 00:13:12,380
I'll put context in it from the cologne

00:13:10,580 --> 00:13:13,730
meeting two months ago about this

00:13:12,380 --> 00:13:15,800
proposal where it was seen for the first

00:13:13,730 --> 00:13:19,190
time in the full language evolution

00:13:15,800 --> 00:13:21,230
working group but let's now first

00:13:19,190 --> 00:13:22,230
establish the problem let's say we have

00:13:21,230 --> 00:13:23,519
this

00:13:22,230 --> 00:13:33,089
what do you think of this code just

00:13:23,519 --> 00:13:35,790
shout it out to two fours I've ever had

00:13:33,089 --> 00:13:40,139
like something unprincipled n't quite

00:13:35,790 --> 00:13:42,899
hear a fireable offense perhaps maybe

00:13:40,139 --> 00:13:45,269
and maybe not quite that bad but it's

00:13:42,899 --> 00:13:47,459
like driving you're behind a driver

00:13:45,269 --> 00:13:50,790
who's white lining it and drifting a

00:13:47,459 --> 00:13:52,199
little and your choices are say behind

00:13:50,790 --> 00:13:54,149
that is you can't pass on the left or on

00:13:52,199 --> 00:13:57,000
the right or call 9-1-1 they probably

00:13:54,149 --> 00:13:58,800
wanted consider the latter if you're in

00:13:57,000 --> 00:14:01,350
most countries in some countries this is

00:13:58,800 --> 00:14:03,209
normal so they they know what to do but

00:14:01,350 --> 00:14:05,639
they haven't decided the author of this

00:14:03,209 --> 00:14:09,019
function hasn't made a decision that the

00:14:05,639 --> 00:14:12,959
author of a function has a duty to make

00:14:09,019 --> 00:14:18,300
when I design a function or a class part

00:14:12,959 --> 00:14:20,550
of my responsibility as a designer is to

00:14:18,300 --> 00:14:22,980
specify the air-handling and decide on

00:14:20,550 --> 00:14:24,180
the air handling policy here if I say

00:14:22,980 --> 00:14:26,370
yeah sometimes we'll throw something

00:14:24,180 --> 00:14:28,529
sometimes we'll return something I have

00:14:26,370 --> 00:14:31,620
abdicated my responsibility as a

00:14:28,529 --> 00:14:33,720
designer now what's harder than getting

00:14:31,620 --> 00:14:36,300
your collar to do air handling getting

00:14:33,720 --> 00:14:38,459
them to do it twice in two ways now this

00:14:36,300 --> 00:14:41,069
is a real problem because today we are

00:14:38,459 --> 00:14:43,019
bifurcated and some libraries may return

00:14:41,069 --> 00:14:45,540
to widget air some libraries may return

00:14:43,019 --> 00:14:47,879
may throw an exception and how am I ever

00:14:45,540 --> 00:14:49,740
going to write template of code that can

00:14:47,879 --> 00:14:52,230
call either of these and do something

00:14:49,740 --> 00:14:55,350
sensible because in one case even if

00:14:52,230 --> 00:15:00,269
this this function this template doesn't

00:14:55,350 --> 00:15:02,639
handle the error just to propagate it it

00:15:00,269 --> 00:15:03,959
has to know do I do nothing and let the

00:15:02,639 --> 00:15:05,819
exception propagate because that's nice

00:15:03,959 --> 00:15:09,569
and automatic or do I have to say if

00:15:05,819 --> 00:15:11,790
error return air I don't know this is

00:15:09,569 --> 00:15:14,490
also an example why not agreeing on a

00:15:11,790 --> 00:15:16,500
common air handling policy means I'm

00:15:14,490 --> 00:15:18,600
effectively bifurcated in the community

00:15:16,500 --> 00:15:20,730
I am effectively programming in a

00:15:18,600 --> 00:15:22,290
language dialect and incompatible one

00:15:20,730 --> 00:15:26,160
because I can't compose these two

00:15:22,290 --> 00:15:28,589
libraries easily in cases like this so I

00:15:26,160 --> 00:15:30,480
took a survey and this is the part of

00:15:28,589 --> 00:15:32,250
the ISO C TV Norg survey I talked about

00:15:30,480 --> 00:15:33,920
this when I gave this talk this part of

00:15:32,250 --> 00:15:35,610
the talk at ACC you this spring and

00:15:33,920 --> 00:15:38,130
about half of

00:15:35,610 --> 00:15:40,440
those projects ban exceptions in whole

00:15:38,130 --> 00:15:43,410
or in part and these are the numbers

00:15:40,440 --> 00:15:47,610
from about 18 months ago there was

00:15:43,410 --> 00:15:50,520
another survey done about about 12

00:15:47,610 --> 00:15:53,340
months ago notice the numbers are very

00:15:50,520 --> 00:15:55,860
much the same and then the most recent

00:15:53,340 --> 00:15:57,900
one which was done this spring the good

00:15:55,860 --> 00:15:59,070
news is there are now in this could be

00:15:57,900 --> 00:16:01,230
measurement error will keep measuring

00:15:59,070 --> 00:16:02,970
this but there are 3% more notice we

00:16:01,230 --> 00:16:05,070
went from 49 to 52 percent three percent

00:16:02,970 --> 00:16:06,480
more that allow exceptions everywhere

00:16:05,070 --> 00:16:08,130
but you might have noticed there are

00:16:06,480 --> 00:16:11,100
also three percent more that say they're

00:16:08,130 --> 00:16:12,690
banned completely so that is not

00:16:11,100 --> 00:16:15,540
improvement that is a further

00:16:12,690 --> 00:16:20,330
bifurcation you're getting less middle

00:16:15,540 --> 00:16:22,650
ground and more the polar ends and

00:16:20,330 --> 00:16:28,110
that's a shame because if we ban

00:16:22,650 --> 00:16:29,850
exceptions we're not using C++ and as I

00:16:28,110 --> 00:16:31,500
said at ACC you that may sound like an

00:16:29,850 --> 00:16:33,810
ideological statement but I think it's a

00:16:31,500 --> 00:16:36,560
factual one not ideological we're not

00:16:33,810 --> 00:16:38,640
using standard C++ because standard C++

00:16:36,560 --> 00:16:40,560
requires the constructors that fail

00:16:38,640 --> 00:16:42,480
throw an exception there is no other

00:16:40,560 --> 00:16:44,070
reasonable way to report errors and

00:16:42,480 --> 00:16:47,010
that's what the standard library does if

00:16:44,070 --> 00:16:48,660
you overload an operator there's no

00:16:47,010 --> 00:16:50,820
space of the signature the signature is

00:16:48,660 --> 00:16:52,470
defined by the language if your operator

00:16:50,820 --> 00:16:54,420
plus you take two things and return our

00:16:52,470 --> 00:16:58,650
thing where do you stick an error code

00:16:54,420 --> 00:17:00,570
you can't so if you're in a an F no

00:16:58,650 --> 00:17:01,860
exceptions world you're not using

00:17:00,570 --> 00:17:04,170
constructors you're using factory

00:17:01,860 --> 00:17:06,030
functions generally if they're if they

00:17:04,170 --> 00:17:07,620
can fail if they can fail you're not

00:17:06,030 --> 00:17:10,440
using operator overloading using name

00:17:07,620 --> 00:17:13,589
functions you're likely not using the

00:17:10,440 --> 00:17:15,270
standard library except maybe for the

00:17:13,589 --> 00:17:17,250
algorithms because they generally don't

00:17:15,270 --> 00:17:18,810
throw especially if you've disabled

00:17:17,250 --> 00:17:20,880
about Alec most library functions

00:17:18,810 --> 00:17:23,070
standard library algorithms don't throw

00:17:20,880 --> 00:17:24,839
that you're not using the containers at

00:17:23,070 --> 00:17:26,940
least not the standard ones you may be

00:17:24,839 --> 00:17:29,490
in a divergent version of the STL that's

00:17:26,940 --> 00:17:31,800
not compatible that does something else

00:17:29,490 --> 00:17:34,770
when the when exception handling is

00:17:31,800 --> 00:17:36,540
turned off and this is fragmentation

00:17:34,770 --> 00:17:38,280
interestingly when you take these same

00:17:36,540 --> 00:17:40,380
numbers and you look at them by the

00:17:38,280 --> 00:17:42,360
three kinds of error reporting that we

00:17:40,380 --> 00:17:44,550
polled which was exceptions numeric

00:17:42,360 --> 00:17:47,670
error codes and sort of expected outcome

00:17:44,550 --> 00:17:49,170
results style types one of the most

00:17:47,670 --> 00:17:49,470
interesting data points I found is that

00:17:49,170 --> 00:17:51,570
air

00:17:49,470 --> 00:17:56,610
our codes have the strongest support of

00:17:51,570 --> 00:18:01,260
those three that's the community voting

00:17:56,610 --> 00:18:03,120
with their feet the expected outcome

00:18:01,260 --> 00:18:04,799
types which are totally non-standard

00:18:03,120 --> 00:18:07,200
even though some of them are in boost

00:18:04,799 --> 00:18:10,110
but many of them are custom are allowed

00:18:07,200 --> 00:18:12,000
everywhere almost as much as exceptions

00:18:10,110 --> 00:18:18,260
which are blessed in the c+ off standard

00:18:12,000 --> 00:18:21,659
and have language support and finally

00:18:18,260 --> 00:18:23,820
perhaps most disturbingly every one of

00:18:21,659 --> 00:18:25,860
these is banned outright in more than

00:18:23,820 --> 00:18:28,740
10% of projects according to these

00:18:25,860 --> 00:18:32,309
surveys and that is a measure of how

00:18:28,740 --> 00:18:33,539
fragmented the world has become because

00:18:32,309 --> 00:18:35,190
that means there are projects that

00:18:33,539 --> 00:18:37,530
cannot talk to each other at all they

00:18:35,190 --> 00:18:40,049
cannot share code at all at least not

00:18:37,530 --> 00:18:42,860
code that has air handling and I hope

00:18:40,049 --> 00:18:44,520
that most of our code does or aspires to

00:18:42,860 --> 00:18:46,799
when you look at these same numbers

00:18:44,520 --> 00:18:48,419
there's the original there's six months

00:18:46,799 --> 00:18:50,370
later and here's the gross recent one

00:18:48,419 --> 00:18:53,659
from this year you see a very similar

00:18:50,370 --> 00:18:59,100
pattern so this is pretty stable across

00:18:53,659 --> 00:19:00,330
surveys so standard C plus L says we

00:18:59,100 --> 00:19:01,950
have exceptions enabled we use

00:19:00,330 --> 00:19:03,480
constructors and operators normally we

00:19:01,950 --> 00:19:05,970
use the standard template library and

00:19:03,480 --> 00:19:07,440
then there's dialects and there's not

00:19:05,970 --> 00:19:09,720
just one there are many of them because

00:19:07,440 --> 00:19:11,549
we keep inventing new ways to not use

00:19:09,720 --> 00:19:13,799
exceptions in to report errors some

00:19:11,549 --> 00:19:15,720
other way and question which of these

00:19:13,799 --> 00:19:17,120
the state file system use and the answer

00:19:15,720 --> 00:19:19,950
is two of them

00:19:17,120 --> 00:19:22,559
so throughout the now-standard file

00:19:19,950 --> 00:19:25,289
system library pervasively there are

00:19:22,559 --> 00:19:27,570
overloads one of which will return an

00:19:25,289 --> 00:19:29,460
error and one of which will throw an

00:19:27,570 --> 00:19:31,679
exception just in case you're in one of

00:19:29,460 --> 00:19:34,110
those worlds it the the C false

00:19:31,679 --> 00:19:36,840
community is so bifurcated that the

00:19:34,110 --> 00:19:39,030
Standards Committee feels they need to

00:19:36,840 --> 00:19:41,010
support both of these dialects and they

00:19:39,030 --> 00:19:43,620
will probably not say it in those terms

00:19:41,010 --> 00:19:45,720
but I will we are supporting what is

00:19:43,620 --> 00:19:47,909
effectively becoming two languages and

00:19:45,720 --> 00:19:49,679
that is not a good thing and we have

00:19:47,909 --> 00:19:52,710
pressure to do this with our next round

00:19:49,679 --> 00:19:54,270
of libraries like networking and other

00:19:52,710 --> 00:19:58,500
libraries that are coming to do the same

00:19:54,270 --> 00:20:01,010
thing just so C++ developers can use

00:19:58,500 --> 00:20:01,010
them

00:20:01,410 --> 00:20:06,450
that's a problem that needs a solution

00:20:03,120 --> 00:20:08,310
and what's the root cause today's

00:20:06,450 --> 00:20:11,310
exception handling is not zero overhead

00:20:08,310 --> 00:20:13,320
so summarizing the reasons as I've gone

00:20:11,310 --> 00:20:16,170
and surveyed people and teams over the

00:20:13,320 --> 00:20:17,670
last five years or so and longer than

00:20:16,170 --> 00:20:19,410
that but especially systematically in

00:20:17,670 --> 00:20:22,260
the last five years I've been hearing

00:20:19,410 --> 00:20:24,240
the same three things over and over two

00:20:22,260 --> 00:20:25,710
things and then an optional one the

00:20:24,240 --> 00:20:27,540
first is I can't turn on exception

00:20:25,710 --> 00:20:30,090
handling at all and you ask them why

00:20:27,540 --> 00:20:33,120
it's standard we recommend it it's

00:20:30,090 --> 00:20:35,160
beautiful is it but look what it costs

00:20:33,120 --> 00:20:37,890
and they show binary size or they show

00:20:35,160 --> 00:20:39,450
the the other expense of it because just

00:20:37,890 --> 00:20:41,610
turning on exception handling incurs

00:20:39,450 --> 00:20:43,350
space overhead on every implementation

00:20:41,610 --> 00:20:44,550
whether you throw anything or not and

00:20:43,350 --> 00:20:46,770
this is regardless of whether you're

00:20:44,550 --> 00:20:48,660
using table-based exceptions or non

00:20:46,770 --> 00:20:50,280
table-based exceptions it is even with

00:20:48,660 --> 00:20:51,840
the optimizations that have been

00:20:50,280 --> 00:20:54,900
proposed and reported in this year

00:20:51,840 --> 00:20:56,430
standards committee mailings and this

00:20:54,900 --> 00:20:58,680
violates the first part of the zero

00:20:56,430 --> 00:21:01,590
overhead principle which was you don't

00:20:58,680 --> 00:21:03,360
pay for what you don't use I should be

00:21:01,590 --> 00:21:05,460
able to turn on exception handling and

00:21:03,360 --> 00:21:07,890
if I don't throw an exception I should

00:21:05,460 --> 00:21:11,010
pay approximately zero a nice round

00:21:07,890 --> 00:21:13,530
number and we're not there today the

00:21:11,010 --> 00:21:15,690
second problem is okay even if I have a

00:21:13,530 --> 00:21:17,790
H enabled in certain code I may not be

00:21:15,690 --> 00:21:20,760
able to throw an exception and you ask

00:21:17,790 --> 00:21:25,110
them why and there's two sub reasons for

00:21:20,760 --> 00:21:27,450
this one in real-time systems or memory

00:21:25,110 --> 00:21:30,090
coentrão constrain systems where they

00:21:27,450 --> 00:21:32,790
have to be able to predict for a call

00:21:30,090 --> 00:21:36,690
tree including for reporting an error

00:21:32,790 --> 00:21:39,060
how much space and or how much time it

00:21:36,690 --> 00:21:41,670
will maximally take so compute an upper

00:21:39,060 --> 00:21:44,400
bound on either space or time or in some

00:21:41,670 --> 00:21:46,440
cases both can't throw an exception

00:21:44,400 --> 00:21:47,940
because I could not statically compute

00:21:46,440 --> 00:21:49,830
an upper bound for how much space or

00:21:47,940 --> 00:21:51,390
time might be needed and it's because I

00:21:49,830 --> 00:21:56,040
have to do dynamic allocation to throw

00:21:51,390 --> 00:21:57,660
and a form of our TTI to catch even if

00:21:56,040 --> 00:21:59,850
they're not in that kind of constrained

00:21:57,660 --> 00:22:01,710
system where the performance of an the

00:21:59,850 --> 00:22:06,240
deterministic performance of exceptions

00:22:01,710 --> 00:22:08,700
is important they may say yeah I could

00:22:06,240 --> 00:22:10,290
throw but look I returned and expected

00:22:08,700 --> 00:22:13,230
and I can prove it's a hundred times

00:22:10,290 --> 00:22:15,059
faster in my scenario and that may

00:22:13,230 --> 00:22:16,370
matter even when

00:22:15,059 --> 00:22:18,120
people say well you know you should

00:22:16,370 --> 00:22:20,730
exceptions only in exceptional

00:22:18,120 --> 00:22:22,799
circumstances we're gonna get a better

00:22:20,730 --> 00:22:25,080
definition in a few minutes but that's

00:22:22,799 --> 00:22:26,940
not always true you need to throw an

00:22:25,080 --> 00:22:29,100
exception when the function couldn't do

00:22:26,940 --> 00:22:34,259
what it advertised and that usually is

00:22:29,100 --> 00:22:36,149
rare but there are some functions that

00:22:34,259 --> 00:22:39,269
actually may fail often and that is a

00:22:36,149 --> 00:22:42,149
legitimate failure imagine parsing XML

00:22:39,269 --> 00:22:44,669
part or parsing something that you got

00:22:42,149 --> 00:22:46,559
off the web it may be quite common to

00:22:44,669 --> 00:22:49,470
say parse int and like you hear that but

00:22:46,559 --> 00:22:52,470
that's the word hello is not an int

00:22:49,470 --> 00:22:54,779
sorry right it may be common to get

00:22:52,470 --> 00:22:56,159
errors you may get errors in 10% of your

00:22:54,779 --> 00:22:59,009
calls and you may not be able to predict

00:22:56,159 --> 00:23:01,409
where those are this violates the zero

00:22:59,009 --> 00:23:03,450
overhead principle part two when you do

00:23:01,409 --> 00:23:05,399
use the feature you generally couldn't

00:23:03,450 --> 00:23:07,919
reasonably do better by rolling your own

00:23:05,399 --> 00:23:09,419
and then finally the bonus problem is

00:23:07,919 --> 00:23:12,240
sometimes people say well I can't throw

00:23:09,419 --> 00:23:13,769
through this code because they may like

00:23:12,240 --> 00:23:16,769
the fact that exceptions propagate

00:23:13,769 --> 00:23:18,389
automatically but not invisibly they

00:23:16,769 --> 00:23:20,309
can't see look at their read their

00:23:18,389 --> 00:23:23,039
source code of their function and see

00:23:20,309 --> 00:23:24,960
the control flow has because of throwing

00:23:23,039 --> 00:23:27,240
exceptions where as you can easily see

00:23:24,960 --> 00:23:28,799
all the others the is the while those

00:23:27,240 --> 00:23:31,350
are visible you can grep for them I

00:23:28,799 --> 00:23:33,929
can't grep I can't even see the

00:23:31,350 --> 00:23:37,169
exceptional powers so that's something

00:23:33,929 --> 00:23:38,610
that people volunteered as a problem

00:23:37,169 --> 00:23:42,779
they regularly face so these are the

00:23:38,610 --> 00:23:44,519
problems that I heard most often when I

00:23:42,779 --> 00:23:46,679
presented this for the first time I

00:23:44,519 --> 00:23:48,779
presented it to subgroups last year

00:23:46,679 --> 00:23:51,029
already but this was the first time in

00:23:48,779 --> 00:23:53,009
two months ago in Cologne where it came

00:23:51,029 --> 00:23:55,009
before the full evolution working group

00:23:53,009 --> 00:23:57,119
that's really responsible for

00:23:55,009 --> 00:24:00,960
recommending the design of the language

00:23:57,119 --> 00:24:03,809
and I actually asked them to pull each

00:24:00,960 --> 00:24:05,549
of these complaints I can't afford to

00:24:03,809 --> 00:24:07,110
enable it I can't afford to throw and I

00:24:05,549 --> 00:24:09,570
can't throw through this codes I can't

00:24:07,110 --> 00:24:12,240
see the code path and we actually took a

00:24:09,570 --> 00:24:13,980
poll not on the solution I'm going to

00:24:12,240 --> 00:24:15,860
show I'll show those polls later but

00:24:13,980 --> 00:24:18,360
just on is this an important problem

00:24:15,860 --> 00:24:20,669
specifically the poll was of the form it

00:24:18,360 --> 00:24:23,759
said for each one of these is this a

00:24:20,669 --> 00:24:27,899
problem that is worth this committees

00:24:23,759 --> 00:24:28,620
time to try to solve you will notice

00:24:27,899 --> 00:24:29,850
that for

00:24:28,620 --> 00:24:31,050
all of them there were some people who

00:24:29,850 --> 00:24:35,460
thought it wasn't worth the committee's

00:24:31,050 --> 00:24:38,160
time to solve them but fortunately the

00:24:35,460 --> 00:24:41,070
large majority of the evolution group

00:24:38,160 --> 00:24:42,300
felt yes these are problems that would

00:24:41,070 --> 00:24:43,770
be worth trying to solve that doesn't

00:24:42,300 --> 00:24:45,930
mean we can find a solution we'll accept

00:24:43,770 --> 00:24:47,700
but in principle yes we would like to

00:24:45,930 --> 00:24:51,570
invest time in solving these problems so

00:24:47,700 --> 00:24:54,240
that's very heartening let's for a

00:24:51,570 --> 00:24:55,800
moment define what is an error if you go

00:24:54,240 --> 00:24:58,290
to the dictionary merriam-webster is a

00:24:55,800 --> 00:25:00,929
good one they define error as an act

00:24:58,290 --> 00:25:04,010
that fails to achieve what should be

00:25:00,929 --> 00:25:08,760
done so if you call a function that says

00:25:04,010 --> 00:25:10,920
parse ins and you pass it a string if it

00:25:08,760 --> 00:25:13,440
can't get you an integer out of that

00:25:10,920 --> 00:25:15,320
string then it can't achieve what you

00:25:13,440 --> 00:25:17,970
asked it to do that's a simple example

00:25:15,320 --> 00:25:19,320
basically it comes down to can the

00:25:17,970 --> 00:25:21,600
function achieve its success

00:25:19,320 --> 00:25:25,980
post-conditions can it do the thing it

00:25:21,600 --> 00:25:28,290
advertises and I'll say let's use the

00:25:25,980 --> 00:25:30,330
term error and to be crisper a

00:25:28,290 --> 00:25:32,580
recoverable error a program recoverable

00:25:30,330 --> 00:25:36,420
error means a function couldn't do what

00:25:32,580 --> 00:25:38,790
it advertised only those should be

00:25:36,420 --> 00:25:40,559
reported as errors to the caller and

00:25:38,790 --> 00:25:42,330
notice I did not say anything about it

00:25:40,559 --> 00:25:45,450
whether you use exceptions or result

00:25:42,330 --> 00:25:47,400
types or error codes this is a very

00:25:45,450 --> 00:25:50,190
general principle that doesn't it is

00:25:47,400 --> 00:25:52,500
agnostic to the actual mechanism you use

00:25:50,190 --> 00:25:54,300
to report the error is it you shouldn't

00:25:52,500 --> 00:25:59,250
even be telling the calling code about

00:25:54,300 --> 00:26:01,380
it unless it's in this category this has

00:25:59,250 --> 00:26:03,540
some consequences there are certain

00:26:01,380 --> 00:26:05,550
things that the calling code cannot do

00:26:03,540 --> 00:26:06,929
anything about so abstract machine

00:26:05,550 --> 00:26:09,929
corruption is a very simple example

00:26:06,929 --> 00:26:11,900
let's say you stack overflow not the

00:26:09,929 --> 00:26:13,679
online one but you know actually really

00:26:11,900 --> 00:26:15,690
trying to make a stack array of a

00:26:13,679 --> 00:26:19,410
billion or something oops that didn't

00:26:15,690 --> 00:26:21,330
work if we treated that think about if

00:26:19,410 --> 00:26:22,710
we treated that as an error code or an

00:26:21,330 --> 00:26:25,530
exception we were report to the calling

00:26:22,710 --> 00:26:27,030
code well first of all what on earth is

00:26:25,530 --> 00:26:28,920
the calling code going to do about it

00:26:27,030 --> 00:26:30,809
it cannot programmatically recover

00:26:28,920 --> 00:26:32,280
because you may be in a corrupted state

00:26:30,809 --> 00:26:34,080
if you run out of stack you may actually

00:26:32,280 --> 00:26:35,370
not be in the consistent state anymore

00:26:34,080 --> 00:26:38,850
because you might have spilled some of

00:26:35,370 --> 00:26:42,660
your rights or corrupted memory but

00:26:38,850 --> 00:26:45,690
more to the point if we did that there

00:26:42,660 --> 00:26:48,360
would be no no except functions every

00:26:45,690 --> 00:26:50,820
function could throw because any

00:26:48,360 --> 00:26:53,070
function could be the last one who's got

00:26:50,820 --> 00:26:57,180
one bite left on the stack when you try

00:26:53,070 --> 00:26:58,350
to call it so this is not a kind of

00:26:57,180 --> 00:26:59,760
error that we should report to the

00:26:58,350 --> 00:27:00,900
calling code because the calling code

00:26:59,760 --> 00:27:02,700
can't do anything about it

00:27:00,900 --> 00:27:04,440
and if we tried we would do damage to

00:27:02,700 --> 00:27:06,570
our programming model we would be losing

00:27:04,440 --> 00:27:09,540
no except for practice all practical

00:27:06,570 --> 00:27:11,040
purposes for example so reporting that

00:27:09,540 --> 00:27:13,760
as a runtime error would really be a

00:27:11,040 --> 00:27:17,130
category err it's not a runtime

00:27:13,760 --> 00:27:18,630
recoverable error the same thing is true

00:27:17,130 --> 00:27:20,280
of a programming bug so if we have an

00:27:18,630 --> 00:27:22,770
assertion in our program or a

00:27:20,280 --> 00:27:25,380
precondition or a post condition and

00:27:22,770 --> 00:27:28,770
it's a statement about the expected

00:27:25,380 --> 00:27:30,810
state of our program if we're using

00:27:28,770 --> 00:27:33,090
assertions in that way then by

00:27:30,810 --> 00:27:35,880
definition if we violate one what does

00:27:33,090 --> 00:27:38,370
it mean it means the program is in the

00:27:35,880 --> 00:27:41,430
state that the code was not expecting

00:27:38,370 --> 00:27:43,350
and is not designed to recover from now

00:27:41,430 --> 00:27:44,850
there are techniques for if you can

00:27:43,350 --> 00:27:47,250
partition your memory and have memory

00:27:44,850 --> 00:27:48,870
isolation and you have you can throw

00:27:47,250 --> 00:27:50,220
away parts of your program and restart

00:27:48,870 --> 00:27:52,860
them are there are techniques to try to

00:27:50,220 --> 00:27:54,600
recover but it's not by normal stacking

00:27:52,860 --> 00:27:57,180
unwinding and fixing things on the way

00:27:54,600 --> 00:27:58,650
back usually it's by abandoning parts of

00:27:57,180 --> 00:28:02,490
possibly corrupt process and then

00:27:58,650 --> 00:28:06,090
resuming restarting these also should

00:28:02,490 --> 00:28:10,290
not be reported as runtime errors so out

00:28:06,090 --> 00:28:14,580
of bounds should never ever be an error

00:28:10,290 --> 00:28:16,250
code or an exception I know that that is

00:28:14,580 --> 00:28:18,570
gonna raised hackles with some of you

00:28:16,250 --> 00:28:20,850
because we're used to that you'll say

00:28:18,570 --> 00:28:22,140
the standard library does that I will

00:28:20,850 --> 00:28:23,760
show you that we talk to the standard

00:28:22,140 --> 00:28:26,130
library folks I believe I have the poles

00:28:23,760 --> 00:28:28,590
and a few slides and they agree

00:28:26,130 --> 00:28:30,060
unanimously yeah that's a problem and

00:28:28,590 --> 00:28:34,440
we're going to gradually migrate the

00:28:30,060 --> 00:28:36,630
standard library away from basically the

00:28:34,440 --> 00:28:40,290
logic underscore error which you might

00:28:36,630 --> 00:28:43,910
say is inherently a logic error that

00:28:40,290 --> 00:28:48,610
shouldn't exist so here's our texana me

00:28:43,910 --> 00:28:50,590
if we corrupt the abstract machine

00:28:48,610 --> 00:28:51,789
we need to stop we might terminate

00:28:50,590 --> 00:28:53,350
doesn't mean right away we might have

00:28:51,789 --> 00:28:55,390
some last-ditch you know try to save

00:28:53,350 --> 00:28:57,279
some state before we terminate but we

00:28:55,390 --> 00:29:00,220
can't really continue we have to tell us

00:28:57,279 --> 00:29:03,309
this hop or somebody like that and we

00:29:00,220 --> 00:29:04,990
are telling a human being because we

00:29:03,309 --> 00:29:06,659
need more space the program failed and

00:29:04,990 --> 00:29:09,399
you need to restart it

00:29:06,659 --> 00:29:11,380
category B if there is a programming bug

00:29:09,399 --> 00:29:15,340
like an assert violation or a

00:29:11,380 --> 00:29:17,679
precondition violation we express that

00:29:15,340 --> 00:29:21,490
using assertions log checks hopefully

00:29:17,679 --> 00:29:22,750
soon contracts and we tell also a human

00:29:21,490 --> 00:29:23,559
being but this time we tell the

00:29:22,750 --> 00:29:25,630
programmer

00:29:23,559 --> 00:29:28,019
this is category B we want to come out

00:29:25,630 --> 00:29:30,700
at unit testing and system testing and

00:29:28,019 --> 00:29:33,549
we go identified a bug please go fix

00:29:30,700 --> 00:29:34,990
your bug category B we don't throw an

00:29:33,549 --> 00:29:36,549
exception because the program can't fix

00:29:34,990 --> 00:29:37,990
itself we can't we don't want to tell

00:29:36,549 --> 00:29:40,330
the code we want to tell a human being

00:29:37,990 --> 00:29:42,909
and finally we have our coverable error

00:29:40,330 --> 00:29:44,500
like host not found or know that string

00:29:42,909 --> 00:29:46,870
did not contain an in please try again

00:29:44,500 --> 00:29:48,639
and there we could throw an exception or

00:29:46,870 --> 00:29:51,460
use an error code and we're reporting to

00:29:48,639 --> 00:29:53,500
different species to code and the

00:29:51,460 --> 00:29:56,169
calling code should recover so that's

00:29:53,500 --> 00:29:57,909
the taxonomy I want to to highlight

00:29:56,169 --> 00:29:59,620
because it's part of these four

00:29:57,909 --> 00:30:01,059
coordinated proposals and it comes up

00:29:59,620 --> 00:30:04,779
when we talk about number two in

00:30:01,059 --> 00:30:07,240
particular at number three so here are

00:30:04,779 --> 00:30:09,519
four coordinated proposals which are

00:30:07,240 --> 00:30:12,610
about trying to solve the problems we

00:30:09,519 --> 00:30:14,649
identified at the top each one of them

00:30:12,610 --> 00:30:16,600
could be its own paper but I

00:30:14,649 --> 00:30:18,429
deliberately and normally I encourage

00:30:16,600 --> 00:30:20,799
people to write narrower papers instead

00:30:18,429 --> 00:30:23,860
of big monolithic omnibus papers with a

00:30:20,799 --> 00:30:26,889
jumble of features but this isn't just a

00:30:23,860 --> 00:30:29,380
jumbo these are related it could

00:30:26,889 --> 00:30:30,600
actually be a problem if we tried to

00:30:29,380 --> 00:30:33,250
solve these problems in isolation

00:30:30,600 --> 00:30:36,010
because we might get a local maximum and

00:30:33,250 --> 00:30:38,049
we might say oh here's a solution for a

00:30:36,010 --> 00:30:39,580
and here's a solution for B and for C

00:30:38,049 --> 00:30:41,320
and for D and then you stand back and

00:30:39,580 --> 00:30:43,179
we'd standardize it and lived with it

00:30:41,320 --> 00:30:44,649
for 10 years when we realize if we only

00:30:43,179 --> 00:30:46,539
had a time machine how often that we

00:30:44,649 --> 00:30:48,490
said that we'd go back and if we

00:30:46,539 --> 00:30:49,539
actually thought about ABCD together we

00:30:48,490 --> 00:30:51,700
would have designed C a little

00:30:49,539 --> 00:30:53,409
differently which was just as efficient

00:30:51,700 --> 00:30:54,880
and just as useful but now it doesn't

00:30:53,409 --> 00:30:56,770
cause a problem with integrating with

00:30:54,880 --> 00:30:58,029
the other three so that's why I think

00:30:56,770 --> 00:30:59,830
it's important to look at these three

00:30:58,029 --> 00:31:01,900
together and I think by the end of this

00:30:59,830 --> 00:31:05,320
section I hope to convince you that

00:31:01,900 --> 00:31:07,060
if we do all of them the sum is greater

00:31:05,320 --> 00:31:09,750
the whole is greater than the sum of the

00:31:07,060 --> 00:31:12,160
parts in terms of what we get to achieve

00:31:09,750 --> 00:31:14,500
so let's look at the first part of the

00:31:12,160 --> 00:31:16,240
proposal the first part of the proposal

00:31:14,500 --> 00:31:20,110
and the one that probably gets the most

00:31:16,240 --> 00:31:22,990
notice is that we want to address the

00:31:20,110 --> 00:31:26,560
zero overhead of throwing exceptions so

00:31:22,990 --> 00:31:28,750
inherently today we are throwing objects

00:31:26,560 --> 00:31:31,000
that have to be type erased and

00:31:28,750 --> 00:31:33,610
dynamically allocated and we catch using

00:31:31,000 --> 00:31:35,440
a form of our TTI it's not dynamic cast

00:31:33,610 --> 00:31:36,880
that you can spell yourself but it's an

00:31:35,440 --> 00:31:38,920
equivalent form that's built into the

00:31:36,880 --> 00:31:40,360
compiler that's basically a close cousin

00:31:38,920 --> 00:31:43,210
of dynamic casts that you can't spell

00:31:40,360 --> 00:31:46,230
yourself except as catch based reference

00:31:43,210 --> 00:31:48,640
there is a there's a different kind of

00:31:46,230 --> 00:31:51,040
exception classification going on there

00:31:48,640 --> 00:31:54,880
so the proposal is well if dynamic is

00:31:51,040 --> 00:31:56,350
the problem static may not be the answer

00:31:54,880 --> 00:32:00,880
but it ought to be the first place you

00:31:56,350 --> 00:32:02,830
look so let's try to see if static is

00:32:00,880 --> 00:32:05,470
the problem to this to the solution to

00:32:02,830 --> 00:32:10,090
this dynamic problem if we can throw

00:32:05,470 --> 00:32:13,120
values of a statically known type that

00:32:10,090 --> 00:32:15,490
means we can return it by value and if

00:32:13,120 --> 00:32:17,860
we catch by value that means we don't

00:32:15,490 --> 00:32:19,690
need to allocate and we don't do a heap

00:32:17,860 --> 00:32:23,830
allocation and we don't need to do our

00:32:19,690 --> 00:32:26,500
TTI because we know its type it turns

00:32:23,830 --> 00:32:28,510
out that if you do it this way and this

00:32:26,500 --> 00:32:30,880
is basically the same as many languages

00:32:28,510 --> 00:32:34,750
have invented with a result type such as

00:32:30,880 --> 00:32:38,650
in rust and go also a the same thing

00:32:34,750 --> 00:32:40,900
boost expected does an outcome if you do

00:32:38,650 --> 00:32:42,610
that the result is isomorphic to error

00:32:40,900 --> 00:32:45,340
codes but one of the benefits of baking

00:32:42,610 --> 00:32:48,010
this into the language is the language

00:32:45,340 --> 00:32:49,270
can basically overlap your success and

00:32:48,010 --> 00:32:51,250
failure returns and use the same

00:32:49,270 --> 00:32:52,300
registers or the same channel for either

00:32:51,250 --> 00:32:53,830
one because it's only going to be one or

00:32:52,300 --> 00:32:56,380
the other you're either gonna succeed

00:32:53,830 --> 00:32:57,700
and here you go here's your your int or

00:32:56,380 --> 00:32:59,170
you're gonna fail and here's your error

00:32:57,700 --> 00:33:01,390
right and you can overlap those if

00:32:59,170 --> 00:33:05,230
you're the compiler and that could be a

00:33:01,390 --> 00:33:06,730
lot more efficient the thing is we want

00:33:05,230 --> 00:33:08,440
this to be backward compatible so

00:33:06,730 --> 00:33:10,690
because C++ already has dynamic

00:33:08,440 --> 00:33:12,370
exceptions we want to keep all of the

00:33:10,690 --> 00:33:15,409
exception handling we have today the in

00:33:12,370 --> 00:33:18,470
terms of the programming model try catch

00:33:15,409 --> 00:33:20,460
but we want to be able to opt in

00:33:18,470 --> 00:33:22,470
therefore this is not a breaking change

00:33:20,460 --> 00:33:25,289
to say oh by the way for my function mr.

00:33:22,470 --> 00:33:28,769
compiler please go and implement this

00:33:25,289 --> 00:33:33,509
using the fast path because I promise to

00:33:28,769 --> 00:33:35,970
only throw a stood error so here's how

00:33:33,509 --> 00:33:39,450
it would operate it's as if you returned

00:33:35,970 --> 00:33:41,370
a union of success and error and the

00:33:39,450 --> 00:33:42,929
boolean discriminant could even go in a

00:33:41,370 --> 00:33:44,940
register or a CPU flag that's an

00:33:42,929 --> 00:33:47,909
implementation detail the idea is it can

00:33:44,940 --> 00:33:49,110
be made efficient but the nice thing is

00:33:47,909 --> 00:33:50,580
we still have the exceptional

00:33:49,110 --> 00:33:51,330
programming model we still have throw

00:33:50,580 --> 00:33:55,919
and catch

00:33:51,330 --> 00:33:58,710
we still have automatic propagation but

00:33:55,919 --> 00:34:00,480
we have the same implementation as error

00:33:58,710 --> 00:34:03,120
codes it's just the compiler does it for

00:34:00,480 --> 00:34:06,179
us so we're really doubling down on

00:34:03,120 --> 00:34:08,099
value semantics you see how going static

00:34:06,179 --> 00:34:10,079
lets us double down on value semantics

00:34:08,099 --> 00:34:11,909
and c-plus class just like we've done

00:34:10,079 --> 00:34:14,129
with every major release of the standard

00:34:11,909 --> 00:34:16,679
and see fossils 11 we doubled down on

00:34:14,129 --> 00:34:18,720
value semantics by and became move a

00:34:16,679 --> 00:34:20,429
major part that integrated throughout

00:34:18,720 --> 00:34:22,859
the whole language and throughout the

00:34:20,429 --> 00:34:25,560
type system and that made our code

00:34:22,859 --> 00:34:27,300
faster because we said we're about

00:34:25,560 --> 00:34:28,679
values and we will optimize for those

00:34:27,300 --> 00:34:31,440
and we will embrace that that's what

00:34:28,679 --> 00:34:32,760
this is saying so now from a sales point

00:34:31,440 --> 00:34:34,050
of view let's put on our sales hats for

00:34:32,760 --> 00:34:36,629
a moment let's say you love this

00:34:34,050 --> 00:34:38,250
proposal as much as I do and you want to

00:34:36,629 --> 00:34:39,780
tell someone about it and if you're

00:34:38,250 --> 00:34:42,540
talking to somebody who loves exceptions

00:34:39,780 --> 00:34:44,190
you can say this is great just makes

00:34:42,540 --> 00:34:46,230
exceptions more efficient it's the same

00:34:44,190 --> 00:34:48,419
programming model you throw you catch

00:34:46,230 --> 00:34:49,859
but now all the unwashed masses who

00:34:48,419 --> 00:34:53,240
thought they couldn't afford it they now

00:34:49,859 --> 00:34:56,060
they can use it and we've won them over

00:34:53,240 --> 00:34:58,470
if you're talking to somebody in the

00:34:56,060 --> 00:35:00,540
aforementioned so-called unwashed masses

00:34:58,470 --> 00:35:03,450
who is using expected outcome and knew

00:35:00,540 --> 00:35:05,970
very well why they were using it because

00:35:03,450 --> 00:35:10,380
they couldn't use exceptions you say to

00:35:05,970 --> 00:35:12,569
them you know what we're taking over the

00:35:10,380 --> 00:35:14,310
world we're building expected an outcome

00:35:12,569 --> 00:35:15,720
into the compiler in that grade and

00:35:14,310 --> 00:35:18,180
they're going to use it with their their

00:35:15,720 --> 00:35:19,859
throw catch oh and by the way you know

00:35:18,180 --> 00:35:21,900
how when you use expected and outcome

00:35:19,859 --> 00:35:25,589
you always have to write if air return

00:35:21,900 --> 00:35:27,599
air if air return air we can get rid of

00:35:25,589 --> 00:35:28,290
that automated automate the propagation

00:35:27,599 --> 00:35:30,870
for you

00:35:28,290 --> 00:35:33,210
so you're getting expected outcome baked

00:35:30,870 --> 00:35:34,590
into the language but better because you

00:35:33,210 --> 00:35:37,500
don't have to automatically propagate it

00:35:34,590 --> 00:35:39,330
the compiler will do it for you if

00:35:37,500 --> 00:35:42,570
you're talking to a C programmer who

00:35:39,330 --> 00:35:46,170
says I you will never take my return

00:35:42,570 --> 00:35:49,680
code out of my cold dead hands you'll

00:35:46,170 --> 00:35:53,010
say it's okay what we're doing is we're

00:35:49,680 --> 00:35:54,570
convincing those newfangled C++ people

00:35:53,010 --> 00:35:55,950
to adopt error codes you're really

00:35:54,570 --> 00:35:57,480
automating error codes they just don't

00:35:55,950 --> 00:35:58,980
know it it's giving a nice syntax it's

00:35:57,480 --> 00:36:01,740
just a syntactic sugar for error codes

00:35:58,980 --> 00:36:03,560
by the way you know how when you use an

00:36:01,740 --> 00:36:05,880
error code and you return an error code

00:36:03,560 --> 00:36:07,440
when you use it as a return value you

00:36:05,880 --> 00:36:09,510
don't get to actually have a return

00:36:07,440 --> 00:36:11,820
value they say well yeah that's kind of

00:36:09,510 --> 00:36:13,290
annoying and if so what if you do want

00:36:11,820 --> 00:36:17,640
to return the result well I pass it by

00:36:13,290 --> 00:36:19,110
an out star parameter yeah so if you

00:36:17,640 --> 00:36:20,970
have a return value and you want to add

00:36:19,110 --> 00:36:23,880
an error type well then I add an error

00:36:20,970 --> 00:36:24,990
code star parameter yeah yeah I know

00:36:23,880 --> 00:36:27,180
wouldn't be nice if you didn't have to

00:36:24,990 --> 00:36:30,330
do that wouldn't be nice if you could

00:36:27,180 --> 00:36:31,590
just return your result or an error and

00:36:30,330 --> 00:36:32,940
the compiler do that for you and you

00:36:31,590 --> 00:36:35,130
didn't have to have these out parameters

00:36:32,940 --> 00:36:37,920
so you didn't it didn't have the error

00:36:35,130 --> 00:36:40,850
code type monopolize the return channel

00:36:37,920 --> 00:36:43,080
think about our folds and for you oh

00:36:40,850 --> 00:36:44,730
that's pretty good oh by the way well

00:36:43,080 --> 00:36:46,260
propagate them for you so you also don't

00:36:44,730 --> 00:36:49,980
have to write if error return an error

00:36:46,260 --> 00:36:52,140
all over the place now there I start to

00:36:49,980 --> 00:36:56,010
get warmer and barrier start to break

00:36:52,140 --> 00:36:59,190
down so here's the core proposal summary

00:36:56,010 --> 00:37:01,620
the dark green the try-catch no change

00:36:59,190 --> 00:37:05,820
this is still c+ exception handling as

00:37:01,620 --> 00:37:08,430
we program it as we know it the only

00:37:05,820 --> 00:37:10,590
thing is different is the word throws on

00:37:08,430 --> 00:37:14,910
the function f and function G in this

00:37:10,590 --> 00:37:18,870
example where the function is opting in

00:37:14,910 --> 00:37:21,300
to say by the way I but when I do fail I

00:37:18,870 --> 00:37:24,450
may not always fail but when I fail I

00:37:21,300 --> 00:37:27,330
will throw a student : : error type

00:37:24,450 --> 00:37:27,960
which by the way is trivially capo

00:37:27,330 --> 00:37:29,610
copyable

00:37:27,960 --> 00:37:32,340
and moveable it's actually even a little

00:37:29,610 --> 00:37:35,100
bit better than that so I to throw I

00:37:32,340 --> 00:37:37,830
need no dynamic memory allocation I can

00:37:35,100 --> 00:37:39,690
bit blit it all the way back to wherever

00:37:37,830 --> 00:37:41,700
it's being handled even if it has a

00:37:39,690 --> 00:37:44,260
non-trivial destructor

00:37:41,700 --> 00:37:47,190
see the paper for the magic and see the

00:37:44,260 --> 00:37:50,200
other related papers this is not just a

00:37:47,190 --> 00:37:51,460
little bow pod type this is a type that

00:37:50,200 --> 00:37:54,640
could have a destructor but I don't have

00:37:51,460 --> 00:37:56,079
a bit litt move so that if it does have

00:37:54,640 --> 00:37:58,450
one at the catch side I can destroy it

00:37:56,079 --> 00:38:01,140
properly it's totally typesafe but

00:37:58,450 --> 00:38:03,339
totally efficient no allocation no RTC I

00:38:01,140 --> 00:38:06,190
still with destructors we're doubling

00:38:03,339 --> 00:38:07,839
down on value types and for

00:38:06,190 --> 00:38:12,789
compatibility let's say that I call

00:38:07,839 --> 00:38:14,980
something that like return quote X Y Z Z

00:38:12,789 --> 00:38:17,770
Y quot s now that is a string literal

00:38:14,980 --> 00:38:20,289
that is a stood string in the standard

00:38:17,770 --> 00:38:21,789
and then I add plover another string so

00:38:20,289 --> 00:38:23,140
I'm creating a temporary stood string

00:38:21,789 --> 00:38:26,829
object and I'm through and I'm returning

00:38:23,140 --> 00:38:28,539
that if I call something that throws

00:38:26,829 --> 00:38:30,520
something could throw something else

00:38:28,539 --> 00:38:34,240
because that string concatenation could

00:38:30,520 --> 00:38:37,420
throw I can translate that into a stood

00:38:34,240 --> 00:38:38,710
error and we'll see where particularly

00:38:37,420 --> 00:38:40,390
bad alec we would like to treat

00:38:38,710 --> 00:38:41,559
differently anyway but that alec isn't

00:38:40,390 --> 00:38:43,569
gonna go away it's just gonna get

00:38:41,559 --> 00:38:45,940
greatly reduced we hope that this

00:38:43,569 --> 00:38:47,650
applies to all of the standard errors so

00:38:45,940 --> 00:38:49,180
we can still call the existing code that

00:38:47,650 --> 00:38:51,460
uses dynamic exceptions but if they

00:38:49,180 --> 00:38:52,690
throw something and we don't catch it

00:38:51,460 --> 00:38:54,099
that's fine it still propagates

00:38:52,690 --> 00:38:55,809
automatically we'll just convert it to

00:38:54,099 --> 00:38:57,369
his stood error so they would have still

00:38:55,809 --> 00:38:59,140
had to allocate it and incur the cost

00:38:57,369 --> 00:39:01,390
they had so no change to their status

00:38:59,140 --> 00:39:03,039
quo but as soon as it hits us we are

00:39:01,390 --> 00:39:06,220
adding no extra overhead we just zip it

00:39:03,039 --> 00:39:08,799
right along that's the model and again

00:39:06,220 --> 00:39:11,079
it's fully backward-compatible it does

00:39:08,799 --> 00:39:12,789
not require change to the ABI it does

00:39:11,079 --> 00:39:15,430
not require changed in the semantics of

00:39:12,789 --> 00:39:17,289
any existing function because you're

00:39:15,430 --> 00:39:19,510
opting in and then we can take the fast

00:39:17,289 --> 00:39:22,420
path and it converts to and from as you

00:39:19,510 --> 00:39:24,609
cross boundaries from the old sow

00:39:22,420 --> 00:39:27,730
exceptions to the new stop functions

00:39:24,609 --> 00:39:29,230
that use the new style ones so because

00:39:27,730 --> 00:39:32,200
of this because it is isomorphic to

00:39:29,230 --> 00:39:34,720
error codes it has all the overheads of

00:39:32,200 --> 00:39:37,270
error codes which is minimal typically

00:39:34,720 --> 00:39:39,849
constant time and it's at urbanistic

00:39:37,270 --> 00:39:42,369
because with error codes we have static

00:39:39,849 --> 00:39:44,890
tools that can compute upper bounds on

00:39:42,369 --> 00:39:48,190
how much time it may take to return an

00:39:44,890 --> 00:39:49,089
error code those we still need I still

00:39:48,190 --> 00:39:51,130
need to validate this with

00:39:49,089 --> 00:39:53,230
implementation my expectation is that

00:39:51,130 --> 00:39:55,030
with very minimal if any adjustments

00:39:53,230 --> 00:39:56,470
those will direct

00:39:55,030 --> 00:39:58,690
the work with these exceptions whereas

00:39:56,470 --> 00:40:00,100
today we do not have tools that for

00:39:58,690 --> 00:40:03,430
today's exceptions can compute upper

00:40:00,100 --> 00:40:05,170
bounds but we will for these why because

00:40:03,430 --> 00:40:06,580
they're isomorphic to error codes by the

00:40:05,170 --> 00:40:10,270
way a nice trick when you're designing a

00:40:06,580 --> 00:40:13,740
new thing if you can say it's isomorphic

00:40:10,270 --> 00:40:15,760
to something else that is well known and

00:40:13,740 --> 00:40:17,020
you're not just saying it it's actually

00:40:15,760 --> 00:40:19,210
true you can demonstrate there's an

00:40:17,020 --> 00:40:21,640
isomorphism right yeah I see here the

00:40:19,210 --> 00:40:24,100
Chuckle yes okay sales hat off yeah I

00:40:21,640 --> 00:40:27,580
forgot to do that before technical hat

00:40:24,100 --> 00:40:28,780
firmly back on it over the ears if you

00:40:27,580 --> 00:40:29,140
can show it's isomorphic to something

00:40:28,780 --> 00:40:30,940
else

00:40:29,140 --> 00:40:32,530
all your proofs just come right over

00:40:30,940 --> 00:40:34,660
everything that was proved about that is

00:40:32,530 --> 00:40:36,370
now true for you too so there's a great

00:40:34,660 --> 00:40:39,460
power and saying it's isomorphic to

00:40:36,370 --> 00:40:41,020
error codes so in pseudocode to

00:40:39,460 --> 00:40:46,090
summarize here's what it looks like on

00:40:41,020 --> 00:40:49,030
the left to throw my exception I have to

00:40:46,090 --> 00:40:50,470
essentially new up you can do this a bit

00:40:49,030 --> 00:40:51,760
more efficiently but essentially new up

00:40:50,470 --> 00:40:54,250
I need some sort of dynamic allocation

00:40:51,760 --> 00:40:55,480
that is not stack allocation and if

00:40:54,250 --> 00:40:58,090
you're thinking but windows does it on

00:40:55,480 --> 00:41:02,470
the stack no it doesn't CP zero seven

00:40:58,090 --> 00:41:04,630
zero nine appendix au it cheats by using

00:41:02,470 --> 00:41:06,580
stack memory and interfering with the

00:41:04,630 --> 00:41:08,800
stack by using a weird stack based

00:41:06,580 --> 00:41:10,630
allocator that will make you run out of

00:41:08,800 --> 00:41:13,270
stack faster but it is not a stack

00:41:10,630 --> 00:41:15,220
allocation it is not a lagaye so you

00:41:13,270 --> 00:41:17,020
need a dynamic allocation and then at

00:41:15,220 --> 00:41:19,330
the catch side at the bottom-left you

00:41:17,020 --> 00:41:23,050
need to do a form of RTT i to say is

00:41:19,330 --> 00:41:26,980
this void pointer a basestar you need it

00:41:23,050 --> 00:41:29,080
basically a dynamic cast that goes from

00:41:26,980 --> 00:41:31,540
a void star which dynamic cast the

00:41:29,080 --> 00:41:33,580
standard one does not do to a particular

00:41:31,540 --> 00:41:35,380
base pointer whereas the proposal on the

00:41:33,580 --> 00:41:38,350
right hand side is simply return a value

00:41:35,380 --> 00:41:41,560
that is basically two words return it by

00:41:38,350 --> 00:41:43,330
value and catch it by value and that's

00:41:41,560 --> 00:41:46,990
where the efficiency comes from so what

00:41:43,330 --> 00:41:48,610
are the benefits I hope if this succeeds

00:41:46,990 --> 00:41:50,530
and this is a long-term thing like

00:41:48,610 --> 00:41:54,450
please do not ask is this in C plus 20

00:41:50,530 --> 00:41:56,800
or C plus 23 this is a long lead

00:41:54,450 --> 00:41:58,450
endeavor that is still in its early

00:41:56,800 --> 00:41:59,950
phases we still have to for instance do

00:41:58,450 --> 00:42:00,700
a prototype implementation that does not

00:41:59,950 --> 00:42:04,690
yet exist

00:42:00,700 --> 00:42:08,050
not a full one anyway but we hope that

00:42:04,690 --> 00:42:08,830
what this will achieve is that there is

00:42:08,050 --> 00:42:13,090
no longer

00:42:08,830 --> 00:42:15,370
any valid technical reason not to enable

00:42:13,090 --> 00:42:16,690
exception handling of this form even if

00:42:15,370 --> 00:42:19,270
you still disabled the old exceptions

00:42:16,690 --> 00:42:21,940
you may still disable dynamically typed

00:42:19,270 --> 00:42:24,970
exceptions but there should be no reason

00:42:21,940 --> 00:42:28,750
anybody ever asks their compiler vendor

00:42:24,970 --> 00:42:33,400
for a switch to turn this off because

00:42:28,750 --> 00:42:35,860
it's zero overhead and it hopefully will

00:42:33,400 --> 00:42:39,640
let all code report errors using

00:42:35,860 --> 00:42:41,530
exceptions even real time code even

00:42:39,640 --> 00:42:44,650
embedded systems that are very space

00:42:41,530 --> 00:42:46,150
constrained because I can't reasonably

00:42:44,650 --> 00:42:48,310
write it better than this even if I'm

00:42:46,150 --> 00:42:51,010
using a C error code and C developers

00:42:48,310 --> 00:42:53,650
one of the things that I do like about C

00:42:51,010 --> 00:42:55,450
I don't use it regularly I use default

00:42:53,650 --> 00:42:56,890
house because I like it better but one

00:42:55,450 --> 00:43:01,060
of the things I like about C is that you

00:42:56,890 --> 00:43:03,160
see what you get you can see the costs

00:43:01,060 --> 00:43:05,560
of things to some degree so memory

00:43:03,160 --> 00:43:08,320
allocation etc if the memory hierarchy

00:43:05,560 --> 00:43:10,320
is still opaque but the costs of things

00:43:08,320 --> 00:43:13,150
are more visible than they are in C++

00:43:10,320 --> 00:43:15,310
but even in those for those C

00:43:13,150 --> 00:43:17,020
programmers we can do better than you

00:43:15,310 --> 00:43:18,520
can do by hand because you can't fold

00:43:17,020 --> 00:43:21,400
the error code and a meaningful result

00:43:18,520 --> 00:43:22,870
into the same return unless you return

00:43:21,400 --> 00:43:24,250
to Union all the time and do your own

00:43:22,870 --> 00:43:26,470
discriminant like I mean you have to do

00:43:24,250 --> 00:43:29,230
a lot of work by hand to get an

00:43:26,470 --> 00:43:30,520
equivalent semantics so no it fails the

00:43:29,230 --> 00:43:33,910
test of you couldn't reasonably write

00:43:30,520 --> 00:43:37,720
something better by hand and then we get

00:43:33,910 --> 00:43:39,580
if we can get to this then we can get to

00:43:37,720 --> 00:43:41,730
the bottom part of that pyramid that I

00:43:39,580 --> 00:43:46,330
was proposing and we get to an actual

00:43:41,730 --> 00:43:49,300
simplification in teaching we could

00:43:46,330 --> 00:43:51,130
start to teach a rule as simple as every

00:43:49,300 --> 00:43:56,220
function should be declared with exactly

00:43:51,130 --> 00:43:56,220
one of no except or throws all new code

00:43:56,640 --> 00:44:02,650
this has happened before

00:43:58,390 --> 00:44:06,010
as the last bullet says we now teach now

00:44:02,650 --> 00:44:07,900
that we added override and final we can

00:44:06,010 --> 00:44:10,660
do something we could not do in C

00:44:07,900 --> 00:44:13,600
Fussell's 98 we can and we do in the

00:44:10,660 --> 00:44:15,250
core guidelines teach that every virtual

00:44:13,600 --> 00:44:16,990
function should be declared whether it's

00:44:15,250 --> 00:44:21,190
the base or derived should be declared

00:44:16,990 --> 00:44:22,210
with exactly one of virtual override or

00:44:21,190 --> 00:44:23,890
final

00:44:22,210 --> 00:44:25,330
and you can show that this people can

00:44:23,890 --> 00:44:27,310
argue about styles they haven't I'd like

00:44:25,330 --> 00:44:29,290
to say too but you can show no you don't

00:44:27,310 --> 00:44:31,540
need to this is perfectly clear and

00:44:29,290 --> 00:44:32,830
consistent the same thing can be true of

00:44:31,540 --> 00:44:35,530
exception handling that you have to

00:44:32,830 --> 00:44:38,140
write just one of no accept or throws

00:44:35,530 --> 00:44:41,950
and that's the simplification of the way

00:44:38,140 --> 00:44:43,480
we teach C++ but now let's look at the

00:44:41,950 --> 00:44:45,550
second and third parts of these

00:44:43,480 --> 00:44:50,680
coordinated proposals because these are

00:44:45,550 --> 00:44:52,410
about throwing fewer exceptions the fact

00:44:50,680 --> 00:44:53,800
that's on the screen is actually

00:44:52,410 --> 00:44:56,050
language-independent

00:44:53,800 --> 00:44:59,710
go has discovered this dotnet and Java

00:44:56,050 --> 00:45:01,870
all of them have discovered this here's

00:44:59,710 --> 00:45:04,690
a quote from Joe Duffy where he points

00:45:01,870 --> 00:45:07,030
out who's a dotnet expert and worked on

00:45:04,690 --> 00:45:10,150
a systems a version of c-sharp that was

00:45:07,030 --> 00:45:11,230
used within Microsoft for a while and he

00:45:10,150 --> 00:45:13,000
pointed out that you know once you have

00:45:11,230 --> 00:45:14,980
contracts and this is irrespective of

00:45:13,000 --> 00:45:19,840
language but he specifically ties it to

00:45:14,980 --> 00:45:22,570
a java.net something like 90% of all of

00:45:19,840 --> 00:45:24,370
the exceptions specified in the Java

00:45:22,570 --> 00:45:26,320
and.net standard libraries become

00:45:24,370 --> 00:45:28,650
preconditions and you don't throw them

00:45:26,320 --> 00:45:28,650
no more

00:45:29,100 --> 00:45:33,790
remember if an assertion or precondition

00:45:32,080 --> 00:45:36,490
fails it indicates there's a bug in the

00:45:33,790 --> 00:45:40,000
program so you shouldn't be reporting it

00:45:36,490 --> 00:45:41,710
as a dynamic error to the calling code

00:45:40,000 --> 00:45:43,720
as if it could do something to recover

00:45:41,710 --> 00:45:45,070
it can't by definition your program is

00:45:43,720 --> 00:45:48,520
in a state that that code was not

00:45:45,070 --> 00:45:49,990
intended not designed to handle instead

00:45:48,520 --> 00:45:51,850
this should be happening during testing

00:45:49,990 --> 00:45:54,960
and you reported to a human being the

00:45:51,850 --> 00:45:58,270
developer and say please go fix your bug

00:45:54,960 --> 00:46:00,280
and that means that it could get rid of

00:45:58,270 --> 00:46:02,140
something like 90% of the fun of the

00:46:00,280 --> 00:46:05,170
exceptions in Java and.net and the same

00:46:02,140 --> 00:46:07,380
thing is true in C++ so the summary of

00:46:05,170 --> 00:46:11,080
the proposal is as I alluded to before

00:46:07,380 --> 00:46:13,390
in the standard library let's actually

00:46:11,080 --> 00:46:15,100
with a transition path because this is a

00:46:13,390 --> 00:46:18,460
multi-year multirow least transition

00:46:15,100 --> 00:46:20,830
path start especially for new things in

00:46:18,460 --> 00:46:24,430
the library start moving to a world

00:46:20,830 --> 00:46:26,080
where we no longer make preconditions

00:46:24,430 --> 00:46:29,050
throw exceptions and if we do that

00:46:26,080 --> 00:46:32,470
suddenly many functions in the library

00:46:29,050 --> 00:46:35,430
can start becoming no accept and so far

00:46:32,470 --> 00:46:37,829
the library evolution working group is a

00:46:35,430 --> 00:46:41,069
very strongly in most polls unanimously

00:46:37,829 --> 00:46:44,760
behind that direction and so the uses of

00:46:41,069 --> 00:46:46,920
stewed logic error should eventually

00:46:44,760 --> 00:46:49,559
turn into things like assertions or

00:46:46,920 --> 00:46:51,540
preconditions or things like that but

00:46:49,559 --> 00:46:54,809
it's a long migration and with

00:46:51,540 --> 00:47:00,510
compatibility in mind and that brings us

00:46:54,809 --> 00:47:02,099
to the third part what's odd here what I

00:47:00,510 --> 00:47:05,849
first saw this I thought it's kind of

00:47:02,099 --> 00:47:12,180
odd that this astronaut is playing their

00:47:05,849 --> 00:47:14,700
guitar in a vacuum but if you think

00:47:12,180 --> 00:47:17,550
about a fictitious scene which maybe

00:47:14,700 --> 00:47:19,050
isn't the most productive thing in the

00:47:17,550 --> 00:47:21,960
world but if you think about this

00:47:19,050 --> 00:47:26,160
fantasy scene there's no audience so

00:47:21,960 --> 00:47:28,530
that's okay and the guitar is in

00:47:26,160 --> 00:47:30,750
physical contact with the suit so it may

00:47:28,530 --> 00:47:33,119
not be a very clear audio but they can

00:47:30,750 --> 00:47:34,349
probably hear the guitar and then in

00:47:33,119 --> 00:47:36,150
their microphone maybe the audience on

00:47:34,349 --> 00:47:37,530
earth can hear so yeah okay you can

00:47:36,150 --> 00:47:40,200
squit and make that make sense but it

00:47:37,530 --> 00:47:42,329
looks kind of odd similar to today here

00:47:40,200 --> 00:47:46,500
are two oddities numbered 1 & 3 because

00:47:42,329 --> 00:47:49,589
they're oddities oddity number one is

00:47:46,500 --> 00:47:52,400
exceptions must be dynamically allocated

00:47:49,589 --> 00:47:56,280
today we talked about that already

00:47:52,400 --> 00:47:58,410
oddity number three is that dynamic

00:47:56,280 --> 00:48:01,710
allocation failures are reported using

00:47:58,410 --> 00:48:03,750
exceptions what's wrong with this

00:48:01,710 --> 00:48:09,809
statement with putting those two

00:48:03,750 --> 00:48:13,890
statements together actually two

00:48:09,809 --> 00:48:15,059
different things the first is well we

00:48:13,890 --> 00:48:17,520
already saw it would be nice and

00:48:15,059 --> 00:48:18,960
exceptions didn't have to be dynamically

00:48:17,520 --> 00:48:23,780
allocated so we already addressed that

00:48:18,960 --> 00:48:26,190
part but also many allocation failures

00:48:23,780 --> 00:48:30,510
don't need to be reported as runtime

00:48:26,190 --> 00:48:34,829
recoverable exceptions for example if

00:48:30,510 --> 00:48:36,630
you knew int a million or let's say char

00:48:34,829 --> 00:48:39,780
or byte that's because that's a better

00:48:36,630 --> 00:48:44,430
raw buffer let's say you knew a buffer

00:48:39,780 --> 00:48:46,230
of a million bytes and that fails does

00:48:44,430 --> 00:48:47,800
that mean you've exhausted the limits of

00:48:46,230 --> 00:48:51,080
the machine

00:48:47,800 --> 00:48:52,700
no you can still write a normal code in

00:48:51,080 --> 00:48:54,170
fact you might say okay give me a but

00:48:52,700 --> 00:48:57,080
for half that size and let me try again

00:48:54,170 --> 00:48:58,790
you may do fall backs so that doesn't

00:48:57,080 --> 00:49:02,900
necessarily mean that you've corrupted

00:48:58,790 --> 00:49:08,600
your machine but if you try to do new of

00:49:02,900 --> 00:49:11,600
a single int and that fails you are in

00:49:08,600 --> 00:49:14,840
deep deep trouble because you have

00:49:11,600 --> 00:49:17,630
pretty much exhausted the the abstract

00:49:14,840 --> 00:49:21,260
machine the actual machine you may not

00:49:17,630 --> 00:49:23,060
even be able to return from the function

00:49:21,260 --> 00:49:25,340
which means you can't throw an exception

00:49:23,060 --> 00:49:28,700
or return an error code reliably why not

00:49:25,340 --> 00:49:30,380
because to return means first before you

00:49:28,700 --> 00:49:32,570
can even deliver the error code or the

00:49:30,380 --> 00:49:35,240
exception you have to unwind by running

00:49:32,570 --> 00:49:40,100
the destructors destructors our normal

00:49:35,240 --> 00:49:43,190
code normal code often allocates unless

00:49:40,100 --> 00:49:45,740
you know that nothing not one of those

00:49:43,190 --> 00:49:48,170
destructors or anything they

00:49:45,740 --> 00:49:50,000
transitively call down to a million

00:49:48,170 --> 00:49:52,130
function calls deep will perform an

00:49:50,000 --> 00:49:54,650
allocation you have no guarantee that

00:49:52,130 --> 00:49:56,630
you'll even be able to return so you

00:49:54,650 --> 00:49:58,970
cannot continue executing and so

00:49:56,630 --> 00:50:01,310
termination semantics anytime I see say

00:49:58,970 --> 00:50:03,680
fail faster termination sure you'll

00:50:01,310 --> 00:50:05,990
there you'll want to have to have a fail

00:50:03,680 --> 00:50:07,970
fast handler or last-ditch a little itty

00:50:05,990 --> 00:50:10,490
flush what I can to disk and hope for

00:50:07,970 --> 00:50:12,050
the best you know to rent data loss but

00:50:10,490 --> 00:50:13,520
I can't just continue on as if I can

00:50:12,050 --> 00:50:16,580
recover from this and nothing happened

00:50:13,520 --> 00:50:18,650
so where we are now is we've we think

00:50:16,580 --> 00:50:20,660
we've addressed the first one with

00:50:18,650 --> 00:50:22,640
having lightweight exceptions but so now

00:50:20,660 --> 00:50:24,800
what do we do about memory failures

00:50:22,640 --> 00:50:27,530
sometimes I'll say out of memory and

00:50:24,800 --> 00:50:30,320
that's fine but that's a shorthand for a

00:50:27,530 --> 00:50:32,360
broader term that is allocation failure

00:50:30,320 --> 00:50:34,700
so sometimes people who were rightly say

00:50:32,360 --> 00:50:36,020
not every failure to allocate really

00:50:34,700 --> 00:50:37,880
means I'm out of memory and that's true

00:50:36,020 --> 00:50:38,630
because there could be fragmentation it

00:50:37,880 --> 00:50:41,540
could be just at that particular

00:50:38,630 --> 00:50:42,650
allocator or pool is full it could be

00:50:41,540 --> 00:50:44,480
because it was a big thing and you're

00:50:42,650 --> 00:50:47,660
trying a big buffer allocation request

00:50:44,480 --> 00:50:49,820
and you can try a smaller one but I

00:50:47,660 --> 00:50:51,350
think we know that when we say whom so

00:50:49,820 --> 00:50:53,060
sometimes I'll say is a shorthand for

00:50:51,350 --> 00:50:56,210
all of that but a more technically

00:50:53,060 --> 00:50:58,520
correct term is allocation failure so

00:50:56,210 --> 00:50:59,600
the direction from the Cologne meeting

00:50:58,520 --> 00:51:01,220
two months ago is one that I actually

00:50:59,600 --> 00:51:03,349
strongly agree with it was

00:51:01,220 --> 00:51:05,750
that's the proposal I walked into the

00:51:03,349 --> 00:51:07,339
room with it was one of the alternatives

00:51:05,750 --> 00:51:08,869
that we had talked about but it was not

00:51:07,339 --> 00:51:10,550
the one I walked into the room with I

00:51:08,869 --> 00:51:12,500
think it is way better than my previous

00:51:10,550 --> 00:51:14,569
idea so thank you

00:51:12,500 --> 00:51:17,569
library evolution working group because

00:51:14,569 --> 00:51:19,339
I I love that old that'll say there's

00:51:17,569 --> 00:51:21,530
that isn't from South Park I'd ever seen

00:51:19,339 --> 00:51:23,540
South Park so I only see the memes I

00:51:21,530 --> 00:51:26,150
think it's from there that none of us is

00:51:23,540 --> 00:51:29,060
as dumb as all of us yeah that that's

00:51:26,150 --> 00:51:31,880
fun to say none of us is as smart as all

00:51:29,060 --> 00:51:34,250
of us so this proposal would not be as

00:51:31,880 --> 00:51:35,660
good as it is without the help of many

00:51:34,250 --> 00:51:38,240
many people dozens of people

00:51:35,660 --> 00:51:39,920
acknowledged in my paper as certainly

00:51:38,240 --> 00:51:41,630
here I did not come up with this very

00:51:39,920 --> 00:51:43,430
simple and nice idea thank you to Niall

00:51:41,630 --> 00:51:46,190
and Titus and many others who came up

00:51:43,430 --> 00:51:48,790
with it the idea is let the allocator

00:51:46,190 --> 00:51:51,890
decide we're gonna have allocators

00:51:48,790 --> 00:51:54,800
advertised in a no accept queryable way

00:51:51,890 --> 00:51:58,339
so it's part of their static type hey if

00:51:54,800 --> 00:52:03,500
I can't allocate do I fail fast or do I

00:51:58,339 --> 00:52:07,599
report the air throw about Alec that's

00:52:03,500 --> 00:52:10,970
all simple idea and then add a

00:52:07,599 --> 00:52:13,730
conditional no accept to every function

00:52:10,970 --> 00:52:16,220
in the standard library where allocation

00:52:13,730 --> 00:52:18,800
failure is the only possible failure and

00:52:16,220 --> 00:52:20,540
if you're using a fail fast allocator

00:52:18,800 --> 00:52:24,079
that doesn't report that function can be

00:52:20,540 --> 00:52:26,359
no except now you have great control and

00:52:24,079 --> 00:52:29,450
can make large parts of the standard

00:52:26,359 --> 00:52:32,210
library know except as actually used in

00:52:29,450 --> 00:52:36,500
the field and that leaves only one major

00:52:32,210 --> 00:52:37,970
question what about the standard stood

00:52:36,500 --> 00:52:39,560
allocator that everybody uses by default

00:52:37,970 --> 00:52:41,990
like when you have a vector event you're

00:52:39,560 --> 00:52:43,970
implicitly using stood alligator which

00:52:41,990 --> 00:52:45,680
uses global knew basically there's

00:52:43,970 --> 00:52:47,660
several global news but as a shorthand

00:52:45,680 --> 00:52:53,000
I'm just gonna say this the default

00:52:47,660 --> 00:52:54,829
global knew the third poll that was

00:52:53,000 --> 00:52:57,230
taken actually a second in order but the

00:52:54,829 --> 00:52:59,150
third I'm showing on the screen is okay

00:52:57,230 --> 00:53:02,510
so now we categorize these two kinds of

00:52:59,150 --> 00:53:05,420
alligators on allocation failure they

00:53:02,510 --> 00:53:07,339
either fail fast and abort or they throw

00:53:05,420 --> 00:53:10,819
about Alec and report the air they're

00:53:07,339 --> 00:53:12,890
aborting or reporting what should the

00:53:10,819 --> 00:53:14,570
standard one be library evolution

00:53:12,890 --> 00:53:16,760
working group with only one weekly

00:53:14,570 --> 00:53:19,040
these numbers are strongly in favor

00:53:16,760 --> 00:53:22,310
weekly in favor neutral weekly against

00:53:19,040 --> 00:53:25,040
strongly against except for one person

00:53:22,310 --> 00:53:27,860
who was weekly against that group that

00:53:25,040 --> 00:53:30,770
day was unanimously in favor - one

00:53:27,860 --> 00:53:32,300
person of changing the global default on

00:53:30,770 --> 00:53:35,510
everybody even though that would be a

00:53:32,300 --> 00:53:37,610
breaking change does that scare you or

00:53:35,510 --> 00:53:42,680
delight you this applause for if that

00:53:37,610 --> 00:53:52,460
scares you okay applause for if that

00:53:42,680 --> 00:53:54,140
delights you this is a good play if you

00:53:52,460 --> 00:53:55,370
look pardon me a tangent we'll come back

00:53:54,140 --> 00:53:58,190
to this in a moment this is a very good

00:53:55,370 --> 00:54:00,310
place to to use an object lesson to give

00:53:58,190 --> 00:54:03,770
an illustration of what consensus means

00:54:00,310 --> 00:54:04,880
we just had roughly by decibels the AV

00:54:03,770 --> 00:54:07,040
people could probably measure it

00:54:04,880 --> 00:54:08,810
accurately I don't know something like 4

00:54:07,040 --> 00:54:11,350
to 1 in favor of yeah this delights us

00:54:08,810 --> 00:54:11,350
let's go do it

00:54:11,410 --> 00:54:16,070
but if we just did that

00:54:14,240 --> 00:54:16,970
we took that result and said say this

00:54:16,070 --> 00:54:18,290
was in the committee and we were

00:54:16,970 --> 00:54:21,470
deciding it we took that result and said

00:54:18,290 --> 00:54:24,800
great has changed and we run over those

00:54:21,470 --> 00:54:29,350
people who clapped first that is called

00:54:24,800 --> 00:54:32,390
tyranny of the majority you can do it

00:54:29,350 --> 00:54:33,710
but it's it's not consensus so sometimes

00:54:32,390 --> 00:54:37,160
people ask well what is consensus nice

00:54:33,710 --> 00:54:39,140
oh it is not tyranny of the majority

00:54:37,160 --> 00:54:40,850
it's not because you got the votes even

00:54:39,140 --> 00:54:43,370
though that's greater than the 3 to 1 in

00:54:40,850 --> 00:54:44,840
favor that we usually look for it also

00:54:43,370 --> 00:54:47,380
includes the absence of sustained

00:54:44,840 --> 00:54:51,110
opposition so the majority is required

00:54:47,380 --> 00:54:54,260
to listen to the minority you can't just

00:54:51,110 --> 00:54:57,620
take a vote and say I won terrible to be

00:54:54,260 --> 00:54:59,120
you know you have to listen to the

00:54:57,620 --> 00:55:02,360
concerns of the minority you have to

00:54:59,120 --> 00:55:05,150
actually try to change the proposal to

00:55:02,360 --> 00:55:06,740
satisfy their concerns and now if after

00:55:05,150 --> 00:55:07,760
you've tried that you can't satisfy

00:55:06,740 --> 00:55:10,760
their concerns

00:55:07,760 --> 00:55:12,110
then you take a vote as 41 and and you

00:55:10,760 --> 00:55:14,390
win and you go home and you do it anyway

00:55:12,110 --> 00:55:16,580
but not without first listening to them

00:55:14,390 --> 00:55:18,140
so that's the first of the two parts of

00:55:16,580 --> 00:55:21,740
consensus it's not a tyranny of the

00:55:18,140 --> 00:55:25,960
majority the second part is it's also

00:55:21,740 --> 00:55:25,960
not a tyranny of the minority

00:55:26,050 --> 00:55:32,500
the minority can object and must be

00:55:30,550 --> 00:55:35,200
listened to but after they have been

00:55:32,500 --> 00:55:37,210
listened to and a real solid sustained

00:55:35,200 --> 00:55:40,120
good-faith effort has been made to take

00:55:37,210 --> 00:55:42,190
into account their objections and then

00:55:40,120 --> 00:55:44,730
the majority still decides no we just we

00:55:42,190 --> 00:55:46,960
just can't do that

00:55:44,730 --> 00:55:49,150
they've been listened to they cannot

00:55:46,960 --> 00:55:51,340
prevent they cannot veto it

00:55:49,150 --> 00:55:53,440
forever by simply saying no no we have

00:55:51,340 --> 00:55:56,110
to have unanimity that would be tyranny

00:55:53,440 --> 00:55:58,410
of the minority so it requires a real

00:55:56,110 --> 00:56:00,700
collaboration and a real amount of work

00:55:58,410 --> 00:56:02,080
so that it's not just a numerical thing

00:56:00,700 --> 00:56:04,690
so sometimes people will ask you what's

00:56:02,080 --> 00:56:06,220
the numerical pole and yeah the

00:56:04,690 --> 00:56:08,770
numerical pole matters less than the

00:56:06,220 --> 00:56:11,190
effort to converge and to work together

00:56:08,770 --> 00:56:14,350
to solve the problem in the way that

00:56:11,190 --> 00:56:15,610
addresses sustained opposition so sorry

00:56:14,350 --> 00:56:17,470
for the diversion but it's something

00:56:15,610 --> 00:56:19,510
that I live all the time and my job as

00:56:17,470 --> 00:56:20,470
chairing the committee and so and it's

00:56:19,510 --> 00:56:21,880
something very important to how the

00:56:20,470 --> 00:56:24,280
committee operates and so is a nice

00:56:21,880 --> 00:56:26,830
lesson so those of us who clapped for

00:56:24,280 --> 00:56:28,330
this coming back to the slide library

00:56:26,830 --> 00:56:30,520
evolution working group agrees with you

00:56:28,330 --> 00:56:32,530
those of you who clapped first saying

00:56:30,520 --> 00:56:34,150
you're kind of uncomfortable evolution

00:56:32,530 --> 00:56:35,950
working group half of them agree with

00:56:34,150 --> 00:56:37,540
you and so the language evolution

00:56:35,950 --> 00:56:39,340
working group was split right down the

00:56:37,540 --> 00:56:41,650
middle on this poll which would be a

00:56:39,340 --> 00:56:43,810
breaking change for existing programs

00:56:41,650 --> 00:56:45,490
now if you think about what this means

00:56:43,810 --> 00:56:50,860
if we suddenly start saying that global

00:56:45,490 --> 00:56:52,720
knew fails fast by default you can argue

00:56:50,860 --> 00:56:55,180
that's not actually a breaking change

00:56:52,720 --> 00:56:58,390
for most programs and the way you argue

00:56:55,180 --> 00:57:00,550
that is as follows most programs today

00:56:58,390 --> 00:57:02,590
and I say this with more words in the

00:57:00,550 --> 00:57:07,740
paper and examples but most programs

00:57:02,590 --> 00:57:12,310
today already aren't safe for bad Alec

00:57:07,740 --> 00:57:14,700
they aren't some are there are programs

00:57:12,310 --> 00:57:18,190
there is code that is that is safe for

00:57:14,700 --> 00:57:21,040
allocation failure but most of the code

00:57:18,190 --> 00:57:24,100
you think is safe for allocation failure

00:57:21,040 --> 00:57:26,080
when you actually look a very like a

00:57:24,100 --> 00:57:27,850
super common result way over 90% of

00:57:26,080 --> 00:57:29,800
cases I've seen personally and worked

00:57:27,850 --> 00:57:32,800
with people they're sure their code is

00:57:29,800 --> 00:57:35,080
right and then they realize those

00:57:32,800 --> 00:57:37,450
actually that code couldn't even execute

00:57:35,080 --> 00:57:38,920
it we never even tried that path why did

00:57:37,450 --> 00:57:39,790
they get away with it for reason number

00:57:38,920 --> 00:57:41,560
two why this is

00:57:39,790 --> 00:57:44,260
really a breaking change for many people

00:57:41,560 --> 00:57:47,530
is because bad alec almost never happens

00:57:44,260 --> 00:57:50,110
in a real practice they practice if you

00:57:47,530 --> 00:57:53,800
are on a lazy commit system allocator

00:57:50,110 --> 00:57:55,780
unless you have specifically worked with

00:57:53,800 --> 00:57:58,450
your user commit settings say on Linux

00:57:55,780 --> 00:58:01,080
or your or your using a pool based

00:57:58,450 --> 00:58:05,500
allocator that can throw an exception

00:58:01,080 --> 00:58:07,390
when you exhaust that pool you can go

00:58:05,500 --> 00:58:09,580
decades and never actually see about

00:58:07,390 --> 00:58:11,470
alec even if technically could be thrown

00:58:09,580 --> 00:58:13,570
if you're on a system that has virtual

00:58:11,470 --> 00:58:15,970
memory you may thrash and run slower and

00:58:13,570 --> 00:58:18,940
slower and slower before you ever get to

00:58:15,970 --> 00:58:22,270
the bat Alec you'll be executing yeah

00:58:18,940 --> 00:58:24,040
not executing your program overload of

00:58:22,270 --> 00:58:28,240
the word executing you'll be killing

00:58:24,040 --> 00:58:29,650
your process however so you could say

00:58:28,240 --> 00:58:31,660
that many wouldn't even notice okay let

00:58:29,650 --> 00:58:34,600
me give just a couple of anecdotes so I

00:58:31,660 --> 00:58:36,160
actually created a with Marshall Clow

00:58:34,600 --> 00:58:38,230
and the help of others but especially

00:58:36,160 --> 00:58:40,060
Marshall after ACC you we talked about

00:58:38,230 --> 00:58:42,520
this and on the plane ride home we

00:58:40,060 --> 00:58:44,920
created something called bad ba BB you

00:58:42,520 --> 00:58:48,160
can find it as a project on my github

00:58:44,920 --> 00:58:51,220
it's a repo and under github.com H

00:58:48,160 --> 00:58:54,670
Sutter and or herp cetera I forget

00:58:51,220 --> 00:58:57,070
whatever my handle is on github and the

00:58:54,670 --> 00:59:00,520
the point of it is it's a very simple

00:58:57,070 --> 00:59:02,590
little fault injector that you can

00:59:00,520 --> 00:59:04,120
instrument into the edge of your global

00:59:02,590 --> 00:59:06,070
allocator or to your custom allocators

00:59:04,120 --> 00:59:10,300
that will inject random false with a

00:59:06,070 --> 00:59:11,950
determine frequency and and profile so I

00:59:10,300 --> 00:59:13,450
asked the power point team well first of

00:59:11,950 --> 00:59:16,120
all I asked the compiler team to say

00:59:13,450 --> 00:59:18,010
could you try this and see if the visual

00:59:16,120 --> 00:59:20,500
c++ compiler team could you try this and

00:59:18,010 --> 00:59:22,420
see if it finds any any errors like

00:59:20,500 --> 00:59:24,700
we're throwing a bib a Ballack that we

00:59:22,420 --> 00:59:27,100
inject at an allocation point to make it

00:59:24,700 --> 00:59:30,580
appear to fail might take down the

00:59:27,100 --> 00:59:31,930
compiler and the answer was no we can't

00:59:30,580 --> 00:59:35,470
do that of course it'll take down the

00:59:31,930 --> 00:59:36,910
Kamata we don't even try oh okay well

00:59:35,470 --> 00:59:38,410
okay well should I do well you might try

00:59:36,910 --> 00:59:40,600
the libraries team next door or

00:59:38,410 --> 00:59:41,860
literally next door the next team room

00:59:40,600 --> 00:59:43,960
over so I walked to the next team room

00:59:41,860 --> 00:59:46,930
over and talked to STL who might be in

00:59:43,960 --> 00:59:49,510
the audience here today and I said so

00:59:46,930 --> 00:59:53,410
can we try it against our standard

00:59:49,510 --> 00:59:54,640
library and instrument it and

00:59:53,410 --> 00:59:56,230
I'd be able to do that I don't know what

00:59:54,640 --> 00:59:58,330
you learned from it cuz we don't I mean

00:59:56,230 --> 00:59:59,770
the standard library implementations are

00:59:58,330 --> 01:00:02,880
probably the most battle-tested

00:59:59,770 --> 01:00:04,960
exception hardened C++ code in the world

01:00:02,880 --> 01:00:09,460
well I wouldn't be surprised if we just

01:00:04,960 --> 01:00:12,550
fall over so I tried I went home that

01:00:09,460 --> 01:00:16,300
afternoon created a new project in

01:00:12,550 --> 01:00:19,780
Visual Studio created LinkedIn included

01:00:16,300 --> 01:00:22,570
Bab dot H and all I did was create a

01:00:19,780 --> 01:00:26,800
test loop which did push back into a

01:00:22,570 --> 01:00:28,180
vector of string and ran it with random

01:00:26,800 --> 01:00:29,790
faults being injected like once every

01:00:28,180 --> 01:00:32,470
once every thousand allocations or so

01:00:29,790 --> 01:00:35,560
see the paper for the longer story short

01:00:32,470 --> 01:00:37,180
version is it fell over it crashed even

01:00:35,560 --> 01:00:39,220
though it should three because even

01:00:37,180 --> 01:00:41,620
though it through an exception and there

01:00:39,220 --> 01:00:44,260
was a try-catch block around the vector

01:00:41,620 --> 01:00:46,930
string push back push back loop the

01:00:44,260 --> 01:00:48,010
exception never made it why because you

01:00:46,930 --> 01:00:51,760
might have need to allocate throat

01:00:48,010 --> 01:00:53,560
exception no it just fell over and I did

01:00:51,760 --> 01:00:55,990
not get I think they don't get to try

01:00:53,560 --> 01:00:58,120
any other examples with lib c-plus

01:00:55,990 --> 01:01:00,640
ellipse stood c-plus boss that example

01:00:58,120 --> 01:01:03,760
worked on those implementations but that

01:01:00,640 --> 01:01:06,820
to me was strong data that none of our

01:01:03,760 --> 01:01:09,880
customers who ever build in debug mode

01:01:06,820 --> 01:01:12,760
and use the STL are actually hitting bad

01:01:09,880 --> 01:01:15,910
Alec ever and I know that because the

01:01:12,760 --> 01:01:19,630
the actual root cause is something that

01:01:15,910 --> 01:01:20,800
is on by default in our debug in our

01:01:19,630 --> 01:01:22,870
debug mode /od

01:01:20,800 --> 01:01:24,430
and it is something we know from Salemi

01:01:22,870 --> 01:01:27,010
tree that ninety percent of customers do

01:01:24,430 --> 01:01:28,300
not turn off so we know if you're ninety

01:01:27,010 --> 01:01:30,580
percent of you if you're using visual

01:01:28,300 --> 01:01:32,860
c++ and you're you're running in debug

01:01:30,580 --> 01:01:34,690
mode you would be in this situation and

01:01:32,860 --> 01:01:36,310
we have had like I forget the number it

01:01:34,690 --> 01:01:39,340
was like four or six bug reports in the

01:01:36,310 --> 01:01:41,200
last three years about this hard but

01:01:39,340 --> 01:01:43,260
it's the very first thing I tried vector

01:01:41,200 --> 01:01:46,120
a string pushback just falls over if

01:01:43,260 --> 01:01:48,430
allocation fails that is data that

01:01:46,120 --> 01:01:49,960
people don't write bad Alec Hardin code

01:01:48,430 --> 01:01:51,190
or they would have been testing it in

01:01:49,960 --> 01:01:53,910
fact the bug reports were people who

01:01:51,190 --> 01:01:55,720
were testing for bad alec hardening and

01:01:53,910 --> 01:01:57,490
most of the time people aren't

01:01:55,720 --> 01:01:59,800
encountering about Alec in the first

01:01:57,490 --> 01:02:01,540
place so that explains why library

01:01:59,800 --> 01:02:03,550
evolution working group was willing to

01:02:01,540 --> 01:02:05,140
take this change because they figured a

01:02:03,550 --> 01:02:06,880
lot of people will just never noticed

01:02:05,140 --> 01:02:07,660
because it just doesn't actually happen

01:02:06,880 --> 01:02:09,130
but it will

01:02:07,660 --> 01:02:12,039
let's make a swath of the library no

01:02:09,130 --> 01:02:14,920
accept but then we come back to the

01:02:12,039 --> 01:02:16,780
first group who applauded there is code

01:02:14,920 --> 01:02:19,780
there that relies on this behavior and

01:02:16,780 --> 01:02:22,569
so the updated proposal I'm going to

01:02:19,780 --> 01:02:25,089
make is basically the same thing except

01:02:22,569 --> 01:02:27,250
instead of saying unilaterally that

01:02:25,089 --> 01:02:30,520
these default global and standard

01:02:27,250 --> 01:02:34,539
allocators fail fast and a Bourdon

01:02:30,520 --> 01:02:36,880
failure make it a configurable option to

01:02:34,539 --> 01:02:38,230
let the programmer decide for their

01:02:36,880 --> 01:02:40,359
whole program what they want the

01:02:38,230 --> 01:02:42,369
behavior to be that way it is not a

01:02:40,359 --> 01:02:44,140
breaking change but anyone who wants to

01:02:42,369 --> 01:02:46,809
adopt the new behavior can start seeing

01:02:44,140 --> 01:02:49,450
no accept performance improvements in

01:02:46,809 --> 01:02:52,059
the standard library as we roll this out

01:02:49,450 --> 01:02:54,609
if we go this direction some a few years

01:02:52,059 --> 01:02:55,780
from now so that's where we are right

01:02:54,609 --> 01:02:58,000
now so it looks like that's the path

01:02:55,780 --> 01:02:59,410
we're gonna go to but it's going to

01:02:58,000 --> 01:03:00,910
require to make sure we just don't break

01:02:59,410 --> 01:03:02,740
the world because that would create hard

01:03:00,910 --> 01:03:04,599
opposition even if it's minor opposition

01:03:02,740 --> 01:03:06,309
that's important so I think just to

01:03:04,599 --> 01:03:08,530
switch to let the programmer decide

01:03:06,309 --> 01:03:10,180
which kind of allocator the global

01:03:08,530 --> 01:03:13,690
allocator should be should be enough

01:03:10,180 --> 01:03:16,210
here so our taxonomy we can extend that

01:03:13,690 --> 01:03:18,190
saying a failure aborting allocator is

01:03:16,210 --> 01:03:20,589
considered in category a corrupting the

01:03:18,190 --> 01:03:23,109
abstract machine and a failure reporting

01:03:20,589 --> 01:03:26,400
allocator while it reports errors so

01:03:23,109 --> 01:03:28,660
what are the benefits well we can turn

01:03:26,400 --> 01:03:32,289
we talked about writing preconditions

01:03:28,660 --> 01:03:36,490
from exceptions into static bug

01:03:32,289 --> 01:03:38,170
reporting to the developer and putting

01:03:36,490 --> 01:03:40,660
these two things together taking

01:03:38,170 --> 01:03:42,640
assertions and preconditions and much

01:03:40,660 --> 01:03:46,059
out of memory allocation failure and

01:03:42,640 --> 01:03:48,460
making them not be exceptions will

01:03:46,059 --> 01:03:50,529
eliminate something like 90 95 % of all

01:03:48,460 --> 01:03:53,950
exceptions there are and will let us

01:03:50,529 --> 01:03:56,980
make most code most functions be no

01:03:53,950 --> 01:03:58,930
accept and that is a performance carrot

01:03:56,980 --> 01:04:00,549
because no accept does I know you're

01:03:58,930 --> 01:04:03,220
gonna hear people who say it doesn't you

01:04:00,549 --> 01:04:07,510
can go out bolt it it does make your

01:04:03,220 --> 01:04:10,390
code faster as a bonus it will eliminate

01:04:07,510 --> 01:04:11,650
about 90% of those invisible control

01:04:10,390 --> 01:04:13,510
flow up has because those are the

01:04:11,650 --> 01:04:16,480
exceptional ones the ones that are hard

01:04:13,510 --> 01:04:18,490
to reason about and if you look at guru

01:04:16,480 --> 01:04:20,349
of the week number 20 I showed a four

01:04:18,490 --> 01:04:21,160
line function with three normal control

01:04:20,349 --> 01:04:24,880
flow paths

01:04:21,160 --> 01:04:27,069
and 20 exceptional invisible ones we can

01:04:24,880 --> 01:04:28,539
do a great simplification by getting rid

01:04:27,069 --> 01:04:30,220
of many of those invisible ones that

01:04:28,539 --> 01:04:33,910
makes our code cleaner easier to reason

01:04:30,220 --> 01:04:36,010
about a more robust finally in the

01:04:33,910 --> 01:04:38,890
exception handling section what about

01:04:36,010 --> 01:04:41,950
supporting an explicit way to see where

01:04:38,890 --> 01:04:44,530
my exceptional powers are so if you are

01:04:41,950 --> 01:04:46,299
familiar with Swift or if you looked at

01:04:44,530 --> 01:04:47,619
ago doesn't have this yet but they

01:04:46,299 --> 01:04:49,960
recently announced that they're working

01:04:47,619 --> 01:04:52,900
on it many languages have this idea of

01:04:49,960 --> 01:04:54,700
at the call site to write a word like in

01:04:52,900 --> 01:04:58,240
the NGO proposal I think is checked in

01:04:54,700 --> 01:05:00,730
swift it's try here it's try on the

01:04:58,240 --> 01:05:04,210
expression or statement they call

01:05:00,730 --> 01:05:06,369
something that might throw if I do that

01:05:04,210 --> 01:05:08,710
notice that exception propagation is

01:05:06,369 --> 01:05:10,630
still automatic there's no catch here

01:05:08,710 --> 01:05:13,539
necessarily it's just say I'm annotating

01:05:10,630 --> 01:05:15,520
with the word try just its signal in the

01:05:13,539 --> 01:05:18,819
source code I can now see and grep and

01:05:15,520 --> 01:05:21,369
reason about this line of code may have

01:05:18,819 --> 01:05:25,500
an edge out out of the function I can

01:05:21,369 --> 01:05:28,720
reason about my control flow now today

01:05:25,500 --> 01:05:29,890
we could not possibly even if we had

01:05:28,720 --> 01:05:32,950
this at a language we could not possibly

01:05:29,890 --> 01:05:36,579
require it because almost everything can

01:05:32,950 --> 01:05:38,829
throw that's the default that would if

01:05:36,579 --> 01:05:41,230
we required people to write try on

01:05:38,829 --> 01:05:42,579
everything that could throw there would

01:05:41,230 --> 01:05:44,260
be mass rebellion and there would be a

01:05:42,579 --> 01:05:46,270
new switch among the first two for

01:05:44,260 --> 01:05:50,740
exception handling an RCT I saying turn

01:05:46,270 --> 01:05:52,869
off or try requirement because you'd be

01:05:50,740 --> 01:05:56,079
writing it on almost every line of code

01:05:52,869 --> 01:05:58,779
and it's like highlighting every line on

01:05:56,079 --> 01:06:00,970
a page in a book it defeats the purpose

01:05:58,779 --> 01:06:02,740
nothing stands out anymore all you have

01:06:00,970 --> 01:06:05,650
is a yellow or a green page now that

01:06:02,740 --> 01:06:07,299
makes the text a bit harder to read but

01:06:05,650 --> 01:06:09,970
if we are in a world where most

01:06:07,299 --> 01:06:11,770
functions don't throw and certainly as

01:06:09,970 --> 01:06:16,000
it says in the text bullet in the middle

01:06:11,770 --> 01:06:17,260
if we required this in new code in such

01:06:16,000 --> 01:06:19,660
a world where you didn't have to just

01:06:17,260 --> 01:06:21,819
annotate every single function call now

01:06:19,660 --> 01:06:23,650
we could get to a world where we can

01:06:21,819 --> 01:06:27,039
actually give compile time guarantees

01:06:23,650 --> 01:06:30,309
that there if there is no try or throw

01:06:27,039 --> 01:06:32,380
there is no exception and that's a very

01:06:30,309 --> 01:06:34,059
interesting place to go so what are the

01:06:32,380 --> 01:06:34,930
benefits of this convenience we still

01:06:34,059 --> 01:06:37,599
get automatically

01:06:34,930 --> 01:06:39,279
propogation no change to that we're just

01:06:37,599 --> 01:06:40,839
making it visible in a lightweight way

01:06:39,279 --> 01:06:43,240
so we can see the paths where the

01:06:40,839 --> 01:06:44,829
exceptions might go and if you put all

01:06:43,240 --> 01:06:47,440
these four things together that I've

01:06:44,829 --> 01:06:49,779
just said two and three enabled that

01:06:47,440 --> 01:06:50,799
most functions are no except two three

01:06:49,779 --> 01:06:53,170
and four together

01:06:50,799 --> 01:06:57,460
enables us to require writing the word

01:06:53,170 --> 01:07:00,039
try every place that could throw now I

01:06:57,460 --> 01:07:02,079
could take C code and compile that C++

01:07:00,039 --> 01:07:04,270
and either I manually or a linter tool

01:07:02,079 --> 01:07:06,789
could immediately piont ID tool could

01:07:04,270 --> 01:07:09,309
just put tri in the things that could

01:07:06,789 --> 01:07:11,410
throw because one of the big objections

01:07:09,309 --> 01:07:16,000
to taking C code and compiling at a C++

01:07:11,410 --> 01:07:18,609
in a C puzzles project is now it's

01:07:16,000 --> 01:07:20,589
probably not exception safe it's C it

01:07:18,609 --> 01:07:22,630
was not designed by the author of that

01:07:20,589 --> 01:07:25,329
code with exceptions in mind it's not

01:07:22,630 --> 01:07:27,160
probably doing ra íí- that's the

01:07:25,329 --> 01:07:29,619
language of no destructors it probably

01:07:27,160 --> 01:07:32,740
has its F close without a catch cuz

01:07:29,619 --> 01:07:37,839
there's no catch right so if I take that

01:07:32,740 --> 01:07:41,260
C code and I can compile the C++ but

01:07:37,839 --> 01:07:43,359
like today but now automatically putting

01:07:41,260 --> 01:07:45,069
in the word try at all the places that

01:07:43,359 --> 01:07:47,440
could throw and that's the minority of

01:07:45,069 --> 01:07:48,849
places now I can actually look at that

01:07:47,440 --> 01:07:52,059
code and reason about whether it's

01:07:48,849 --> 01:07:55,089
exception safe or not and know where to

01:07:52,059 --> 01:07:57,069
look to do tweaks to fix it to make an

01:07:55,089 --> 01:07:59,380
exception say if it's not I can now

01:07:57,069 --> 01:08:03,130
migrate converge C and c plus those code

01:07:59,380 --> 01:08:04,690
with more confidence so I showed at the

01:08:03,130 --> 01:08:07,240
top of the street in the top right the

01:08:04,690 --> 01:08:08,859
poles on these three problems are they

01:08:07,240 --> 01:08:10,690
problems worth committee time to solve

01:08:08,859 --> 01:08:13,119
the Committee agreed yes this is worth

01:08:10,690 --> 01:08:14,950
committee time to solve that's not

01:08:13,119 --> 01:08:16,870
that's not the same thing as saying that

01:08:14,950 --> 01:08:20,290
will like your particular solution to

01:08:16,870 --> 01:08:21,460
those problem to that problem so for the

01:08:20,290 --> 01:08:22,810
things that I've just shown you I've

01:08:21,460 --> 01:08:25,900
already shown you the votes for number

01:08:22,810 --> 01:08:28,750
two and three for number one enabling

01:08:25,900 --> 01:08:31,620
the throws state the throws decoration

01:08:28,750 --> 01:08:34,750
to have the efficient value based

01:08:31,620 --> 01:08:37,120
exception handling there was large

01:08:34,750 --> 01:08:39,370
supports don't mind people against but

01:08:37,120 --> 01:08:41,049
there was large support for continuing

01:08:39,370 --> 01:08:45,370
to pursue that direction which basically

01:08:41,049 --> 01:08:47,170
means they said no promises herb we may

01:08:45,370 --> 01:08:49,599
not ever accept your proposal but we

01:08:47,170 --> 01:08:52,520
agree you should do more work

01:08:49,599 --> 01:08:55,339
just to be totally clear that's what

01:08:52,520 --> 01:08:56,929
these votes mean at this stage but it

01:08:55,339 --> 01:08:58,429
was also implicitly a promise that if

01:08:56,929 --> 01:09:00,440
you do it we will look at it again

01:08:58,429 --> 01:09:02,119
so it was an incur it was encouragement

01:09:00,440 --> 01:09:05,389
but not a promise that they'll ever take

01:09:02,119 --> 01:09:08,569
it for number four there was not

01:09:05,389 --> 01:09:12,020
consensus there was mostly opposition to

01:09:08,569 --> 01:09:13,730
try expressions and so I may decouple

01:09:12,020 --> 01:09:15,319
that from the proposal and that can be

01:09:13,730 --> 01:09:17,259
separated but I'm still going to design

01:09:15,319 --> 01:09:19,730
the whole thing all four of these parts

01:09:17,259 --> 01:09:21,920
together they just may not all be off

01:09:19,730 --> 01:09:23,210
adopted at the same time or some parts

01:09:21,920 --> 01:09:25,790
may not be adopted in standards he

01:09:23,210 --> 01:09:28,069
process in the foreseeable future we'll

01:09:25,790 --> 01:09:29,989
see but the core of the proposal numbers

01:09:28,069 --> 01:09:34,670
1 2 & 3 seem to be going well and that's

01:09:29,989 --> 01:09:39,520
a status update for that now we're going

01:09:34,670 --> 01:09:39,520
to talk about a totally unrelated thing

01:09:39,819 --> 01:09:47,650
using almost the same slides cuz it's

01:09:43,909 --> 01:09:47,650
the same pattern

01:09:48,489 --> 01:09:53,750
first we establish the problem today's

01:09:50,839 --> 01:09:54,619
RTT I notice how I just changed eh to

01:09:53,750 --> 01:09:57,190
our TTI

01:09:54,619 --> 01:09:59,329
if you compare slides they're identical

01:09:57,190 --> 01:10:00,949
violates does your overhead principal I

01:09:59,329 --> 01:10:03,530
can't afford to enable it means I'm

01:10:00,949 --> 01:10:06,770
because I'm paying for what I don't use

01:10:03,530 --> 01:10:08,179
I can't afford to use dynamic cast that

01:10:06,770 --> 01:10:10,219
used to say throw an exception but it

01:10:08,179 --> 01:10:13,550
applies to dynamic cast because I can

01:10:10,219 --> 01:10:16,310
write in a more efficient one by hand so

01:10:13,550 --> 01:10:22,329
here's a code review what do you think

01:10:16,310 --> 01:10:22,329
of this code anyone

01:10:24,210 --> 01:10:30,909
say again should use a reference yeah

01:10:29,350 --> 01:10:31,989
okay but this is supposed to work with

01:10:30,909 --> 01:10:34,239
pointers too right

01:10:31,989 --> 01:10:40,929
so if you want it to be null there was

01:10:34,239 --> 01:10:44,670
another comment in the front no what's

01:10:40,929 --> 01:10:51,630
wrong with the code even using pointers

01:10:44,670 --> 01:10:54,190
static cast because it's a downcast

01:10:51,630 --> 01:10:55,929
emoji pedia does not say that this is

01:10:54,190 --> 01:10:57,610
called downcast is just called it's sad

01:10:55,929 --> 01:11:00,570
face but it should be called downcast

01:10:57,610 --> 01:11:04,030
because that works better for this talk

01:11:00,570 --> 01:11:06,929
wait that's an uncheck downcast nobody

01:11:04,030 --> 01:11:10,510
would ever do that right how many of you

01:11:06,929 --> 01:11:12,310
not not doubting yourselves now but how

01:11:10,510 --> 01:11:13,900
many of you like know somebody like

01:11:12,310 --> 01:11:15,489
maybe a friend or colleague who might

01:11:13,900 --> 01:11:18,850
have written something like this once

01:11:15,489 --> 01:11:23,920
before keep your hands up if it was you

01:11:18,850 --> 01:11:26,170
know just kidding if you were in the

01:11:23,920 --> 01:11:28,600
talk by Joe and Shane on Wednesday and

01:11:26,170 --> 01:11:30,790
thank you Joe and Shane for letting me

01:11:28,600 --> 01:11:31,960
use this slide they were talking about a

01:11:30,790 --> 01:11:34,330
different part of the security

01:11:31,960 --> 01:11:35,650
vulnerability landscape well one of the

01:11:34,330 --> 01:11:37,300
things that we've discovered over that

01:11:35,650 --> 01:11:38,290
I've learned over the last five years or

01:11:37,300 --> 01:11:39,639
so and I've been thinking about this

01:11:38,290 --> 01:11:41,080
particular problem for the last five

01:11:39,639 --> 01:11:44,409
years or trying to make dynamic cast

01:11:41,080 --> 01:11:47,290
more affordable because we hear about

01:11:44,409 --> 01:11:50,230
bounds problems as a source of security

01:11:47,290 --> 01:11:51,760
vulnerabilities buffer overruns and so

01:11:50,230 --> 01:11:56,199
we should do something about that we did

01:11:51,760 --> 01:11:58,150
we standardized spam so all don't use

01:11:56,199 --> 01:12:00,219
part of my take always use span it

01:11:58,150 --> 01:12:02,679
pretty much solves bounds safety and

01:12:00,219 --> 01:12:04,570
things like don't reinterpret cast to a

01:12:02,679 --> 01:12:07,420
larger type which also is a way of going

01:12:04,570 --> 01:12:09,219
over bounds and some of these

01:12:07,420 --> 01:12:11,620
vulnerabilities are about use after free

01:12:09,219 --> 01:12:13,239
so see my previous talks see the the

01:12:11,620 --> 01:12:15,190
lifetime profile which is now being up

01:12:13,239 --> 01:12:17,080
streamed into clang and has already

01:12:15,190 --> 01:12:19,719
found bugs in chromium and a low VM

01:12:17,080 --> 01:12:22,300
Thank You gob or and Mattias for your

01:12:19,719 --> 01:12:23,949
help there Kyle Neil and those who have

01:12:22,300 --> 01:12:25,179
helped with that but I'm gonna focus on

01:12:23,949 --> 01:12:27,989
a different part of this chart now

01:12:25,179 --> 01:12:30,030
notice type confusion type confusion

01:12:27,989 --> 01:12:33,610
vulnerabilities now these are security

01:12:30,030 --> 01:12:35,679
exploitable problems that can cause an

01:12:33,610 --> 01:12:36,970
attacker whether a board kid or a

01:12:35,679 --> 01:12:38,650
nation-state

01:12:36,970 --> 01:12:41,260
to use your machine for things you did

01:12:38,650 --> 01:12:42,880
not want and to do bad things right you

01:12:41,260 --> 01:12:45,040
could hold it hostage they can sit there

01:12:42,880 --> 01:12:47,970
for a long time all this stuff that

01:12:45,040 --> 01:12:51,700
blackhat conferences enjoy talking about

01:12:47,970 --> 01:12:53,610
type confusion in particular include

01:12:51,700 --> 01:12:56,290
several things but one of them is

01:12:53,610 --> 01:12:58,330
downcast from base to derived accept

01:12:56,290 --> 01:12:59,200
guess what it wasn't a derived hahaha

01:12:58,330 --> 01:13:01,630
isn't that funny

01:12:59,200 --> 01:13:03,940
well no it's not when an attacker uses

01:13:01,630 --> 01:13:06,640
that to cause an exploit and that

01:13:03,940 --> 01:13:11,440
damages the reputation and the security

01:13:06,640 --> 01:13:13,840
in fact of C++ that does harm to our

01:13:11,440 --> 01:13:17,110
reputation but also harm to our use of

01:13:13,840 --> 01:13:18,280
C++ in fact and here you'll see that in

01:13:17,110 --> 01:13:20,470
the middle of the screen that's not an

01:13:18,280 --> 01:13:21,370
it's a not insignificant part not all of

01:13:20,470 --> 01:13:23,890
those hundred and fifty two

01:13:21,370 --> 01:13:25,600
vulnerabilities known vulnerabilities

01:13:23,890 --> 01:13:27,640
that were identified in the last two

01:13:25,600 --> 01:13:29,260
years there were type confusion where

01:13:27,640 --> 01:13:32,940
static downcast but a good chunk of them

01:13:29,260 --> 01:13:35,500
were we're in fact what happened was

01:13:32,940 --> 01:13:39,100
going back a couple of slides in fact

01:13:35,500 --> 01:13:41,830
that is exactly what the code did the

01:13:39,100 --> 01:13:44,950
vulnerability was caused large class of

01:13:41,830 --> 01:13:49,630
those by doing essentially a static cast

01:13:44,950 --> 01:13:55,210
downcast why would otherwise smart

01:13:49,630 --> 01:13:58,870
people do that well as shown in the the

01:13:55,210 --> 01:14:00,850
smaller sub bullets I found as I talked

01:13:58,870 --> 01:14:03,070
to these people a couple of patterns the

01:14:00,850 --> 01:14:05,110
very first one sounds a lot like the

01:14:03,070 --> 01:14:07,090
exception handling one well I can't use

01:14:05,110 --> 01:14:09,160
the batma cache because our TTI isn't

01:14:07,090 --> 01:14:11,770
enabled because it's too expensive just

01:14:09,160 --> 01:14:13,990
turning on our TC I even if I never use

01:14:11,770 --> 01:14:16,330
it even if I never use type ID or I

01:14:13,990 --> 01:14:18,340
never use the dynamic cast bloats my

01:14:16,330 --> 01:14:19,510
binary size and look here my numbers I

01:14:18,340 --> 01:14:22,030
can prove it

01:14:19,510 --> 01:14:24,250
in fact our TTI is essentially banned in

01:14:22,030 --> 01:14:25,720
Windows for that reason exception

01:14:24,250 --> 01:14:30,300
handling is being allowed more about our

01:14:25,720 --> 01:14:33,220
TTI's Bend that largely the second

01:14:30,300 --> 01:14:35,710
category was a people who did have our

01:14:33,220 --> 01:14:37,960
TTI enabled so they already had the

01:14:35,710 --> 01:14:40,300
binary bloat and of their executable so

01:14:37,960 --> 01:14:42,760
that didn't bother them but they didn't

01:14:40,300 --> 01:14:45,640
use dynamic cast because dynamic cast

01:14:42,760 --> 01:14:46,750
itself was too expensive and I know some

01:14:45,640 --> 01:14:49,190
of you will say but we know that

01:14:46,750 --> 01:14:51,110
Microsoft's implementation does string

01:14:49,190 --> 01:14:52,670
comparisons yeah we're fixing that but

01:14:51,110 --> 01:14:54,860
it wasn't just that it's also on other

01:14:52,670 --> 01:14:57,110
implementations that people were doing

01:14:54,860 --> 01:14:58,160
the same thing and saying no I can't use

01:14:57,110 --> 01:15:01,969
dynamic cast because it's too expensive

01:14:58,160 --> 01:15:03,710
and then the many of them did say the

01:15:01,969 --> 01:15:06,400
same thing at the end which was and we

01:15:03,710 --> 01:15:08,000
tested so we knew the down cast was safe

01:15:06,400 --> 01:15:10,280
remember we're having this conversation

01:15:08,000 --> 01:15:14,239
because this was an exploited security

01:15:10,280 --> 01:15:16,390
vulnerability no it wasn't safe you may

01:15:14,239 --> 01:15:18,890
have tested but it was still a bug oh

01:15:16,390 --> 01:15:22,219
and by the way if you look at the ISO

01:15:18,890 --> 01:15:25,160
CDP survey from this year about a third

01:15:22,219 --> 01:15:28,310
of projects ban exception except been

01:15:25,160 --> 01:15:30,680
RCT I in whole or in parts of their

01:15:28,310 --> 01:15:32,780
projects so the fragmentation is not as

01:15:30,680 --> 01:15:35,270
great as with exception handling but

01:15:32,780 --> 01:15:38,230
it's still very significant it's this is

01:15:35,270 --> 01:15:41,780
not a trivial part of the community and

01:15:38,230 --> 01:15:45,080
again if you bucket these by dynamic

01:15:41,780 --> 01:15:47,000
cast a virtual Curie like a comm query

01:15:45,080 --> 01:15:48,949
interface or just something custom like

01:15:47,000 --> 01:15:50,330
a type tag that people often invent when

01:15:48,949 --> 01:15:53,210
they can't do their own dynamic house

01:15:50,330 --> 01:15:56,030
and you say how how many of you are

01:15:53,210 --> 01:15:58,100
allowed to use each of these all of the

01:15:56,030 --> 01:16:00,410
non-standard methods like calm and

01:15:58,100 --> 01:16:03,320
custom type tag I rolled by hand last

01:16:00,410 --> 01:16:05,480
night are allowed everywhere only a

01:16:03,320 --> 01:16:09,500
little less than an amicus they're

01:16:05,480 --> 01:16:10,580
widely permitted and the worst part this

01:16:09,500 --> 01:16:12,230
is the place where this is worse than

01:16:10,580 --> 01:16:14,900
the story with exception handling

01:16:12,230 --> 01:16:16,370
remember with exception handling a great

01:16:14,900 --> 01:16:20,300
measure of the fracturing of the

01:16:16,370 --> 01:16:22,310
community was that more than 10% of

01:16:20,300 --> 01:16:24,469
projects Bend each one of them like

01:16:22,310 --> 01:16:26,989
every one of them was banned by 10% or

01:16:24,469 --> 01:16:30,949
more of projects with our TTI

01:16:26,989 --> 01:16:33,199
it's 20 percent or more every single one

01:16:30,949 --> 01:16:34,790
of these is banned in 20 percent or more

01:16:33,199 --> 01:16:39,500
projects this is an even greater

01:16:34,790 --> 01:16:41,750
fracturing so again this violates it's

01:16:39,500 --> 01:16:43,460
because our TTI violates the zero

01:16:41,750 --> 01:16:45,260
overhead principle in two ways people

01:16:43,460 --> 01:16:46,760
say I can't afford to enable it because

01:16:45,260 --> 01:16:48,949
just turning it on and curse face

01:16:46,760 --> 01:16:50,390
overhead and then they say well even if

01:16:48,949 --> 01:16:53,449
it's enabled I can't afford to call

01:16:50,390 --> 01:16:56,660
dynamic cast because I can do better by

01:16:53,449 --> 01:16:58,489
hand and that violates don't pay for

01:16:56,660 --> 01:17:00,590
what you don't use and it violates when

01:16:58,489 --> 01:17:03,320
you do use it you can't write it better

01:17:00,590 --> 01:17:05,090
by hand reasonably again it's the Z

01:17:03,320 --> 01:17:06,860
overhead principle the language violates

01:17:05,090 --> 01:17:11,329
it and so users vote with their feet and

01:17:06,860 --> 01:17:16,699
say no we're not doing that so what do

01:17:11,329 --> 01:17:19,099
we do type information is not bad

01:17:16,699 --> 01:17:20,929
I like type ID and type info what I

01:17:19,099 --> 01:17:22,190
don't like is that all of their

01:17:20,929 --> 01:17:23,960
information gets baked into my

01:17:22,190 --> 01:17:28,119
executable whether I ever look at it or

01:17:23,960 --> 01:17:31,610
not I want it when I want it

01:17:28,119 --> 01:17:33,650
so again if your problem is dynamic that

01:17:31,610 --> 01:17:35,570
doesn't mean that your solution is to

01:17:33,650 --> 01:17:37,659
use something static but it's a good

01:17:35,570 --> 01:17:43,670
place to start so let's start there

01:17:37,659 --> 01:17:45,349
prefer static type information the first

01:17:43,670 --> 01:17:47,690
observation is once we have static

01:17:45,349 --> 01:17:49,369
reflection which is making its way

01:17:47,690 --> 01:17:50,929
through the sanitization process and

01:17:49,369 --> 01:17:53,170
perhaps a few years from now it will

01:17:50,929 --> 01:17:56,119
become more commonly available

01:17:53,170 --> 01:18:00,079
we don't need runtime type information

01:17:56,119 --> 01:18:02,570
at all it is totally subsumed totally

01:18:00,079 --> 01:18:05,329
obsoleted by static reflection which

01:18:02,570 --> 01:18:07,429
gives you much more information than the

01:18:05,329 --> 01:18:08,900
runtime one does and before you say yeah

01:18:07,429 --> 01:18:11,630
but the runtime one is available a

01:18:08,900 --> 01:18:15,230
runtime if I need it what can you do

01:18:11,630 --> 01:18:17,150
with any static information store it

01:18:15,230 --> 01:18:20,900
somewhere and it's dynamic information

01:18:17,150 --> 01:18:22,280
and in fact as soon as you say yes as

01:18:20,900 --> 01:18:26,060
soon as we have static reflection you

01:18:22,280 --> 01:18:28,960
can easily create very pretty simply

01:18:26,060 --> 01:18:32,510
create your own runtime dynamic

01:18:28,960 --> 01:18:34,909
reflection in fact I did not know this

01:18:32,510 --> 01:18:36,199
until his talk but Andrew Sutton and his

01:18:34,909 --> 01:18:37,780
talk on Wednesday mentioned that yeah in

01:18:36,199 --> 01:18:40,280
the last two weeks he wrote one of those

01:18:37,780 --> 01:18:41,929
because once you have the reflection and

01:18:40,280 --> 01:18:43,550
he owns through the one of the remains

01:18:41,929 --> 01:18:45,949
or reflection prototypes what you can do

01:18:43,550 --> 01:18:47,449
this once you have the reflection

01:18:45,949 --> 01:18:49,880
information all you need to do is store

01:18:47,449 --> 01:18:52,610
it somewhere and now it's runtime

01:18:49,880 --> 01:18:54,530
available but you only get the things

01:18:52,610 --> 01:18:56,960
stored at runtime that you asked for a

01:18:54,530 --> 01:19:01,099
compile time so you only pay for what

01:18:56,960 --> 01:19:03,139
you use what you actually use so the

01:19:01,099 --> 01:19:05,150
proposal to solve this part of the

01:19:03,139 --> 01:19:07,340
problem is I believe we should adopt

01:19:05,150 --> 01:19:08,900
static reflection and compile time

01:19:07,340 --> 01:19:12,380
programming both of which are already in

01:19:08,900 --> 01:19:14,210
progress and then we could just get rid

01:19:12,380 --> 01:19:15,889
of type ID and type info but I think

01:19:14,210 --> 01:19:17,160
type ID and type in for not bad like

01:19:15,889 --> 01:19:19,620
type info can give

01:19:17,160 --> 01:19:21,390
you a hash that that's useful but make

01:19:19,620 --> 01:19:23,010
them constable make them available only

01:19:21,390 --> 01:19:29,370
a compile-time and if you really want

01:19:23,010 --> 01:19:32,100
the value at runtime store it so the

01:19:29,370 --> 01:19:33,690
second part is dynamic cast it's also

01:19:32,100 --> 01:19:35,340
great when you need it but that Emma

01:19:33,690 --> 01:19:37,860
cast is really powerful they can croc

01:19:35,340 --> 01:19:40,260
cast across inheritance hierarchies to

01:19:37,860 --> 01:19:42,330
sibling that are bases that are under

01:19:40,260 --> 01:19:44,490
otherwise unrelated but happen to be

01:19:42,330 --> 01:19:46,830
inherited by the same derive type it can

01:19:44,490 --> 01:19:49,020
navigate virtual base classes with ease

01:19:46,830 --> 01:19:50,940
and do backflips at the same time it's

01:19:49,020 --> 01:19:52,920
also super expensive because it can do

01:19:50,940 --> 01:19:55,170
all those things and if you ask for a

01:19:52,920 --> 01:19:58,080
dynamic cast you are asking for the

01:19:55,170 --> 01:20:00,480
ability to do all of that just like we

01:19:58,080 --> 01:20:02,880
tell people if all you need is the lower

01:20:00,480 --> 01:20:05,550
bound the the lowest value in an STL

01:20:02,880 --> 01:20:07,110
container that has this value don't ask

01:20:05,550 --> 01:20:09,090
for the equal range which gives you the

01:20:07,110 --> 01:20:10,460
lower and the upper you're asking for

01:20:09,090 --> 01:20:12,900
more work it'll be slower

01:20:10,460 --> 01:20:15,180
same thing with dynamic cast if all you

01:20:12,900 --> 01:20:16,980
need is a down cast don't ask for a

01:20:15,180 --> 01:20:21,660
dynamic cast it'll be slower because

01:20:16,980 --> 01:20:23,700
you're asking for a more work there's a

01:20:21,660 --> 01:20:26,040
sweet spot I think and this actually

01:20:23,700 --> 01:20:27,630
hits all of the type all of these type

01:20:26,040 --> 01:20:29,700
vulnerabilities that I have seen that

01:20:27,630 --> 01:20:33,060
we're root caused by not using dynamic

01:20:29,700 --> 01:20:35,600
cast if you are using need a down cast

01:20:33,060 --> 01:20:37,680
that doesn't cross a virtual inheritance

01:20:35,600 --> 01:20:39,030
link so they can be virtual inheritance

01:20:37,680 --> 01:20:41,250
above or below you but you're not

01:20:39,030 --> 01:20:43,760
crossing the in between the basin drive

01:20:41,250 --> 01:20:46,620
there isn't a virtual inheritance Lane

01:20:43,760 --> 01:20:48,420
turns out we can implement that super

01:20:46,620 --> 01:20:50,280
efficiently and here I'm going to

01:20:48,420 --> 01:20:52,890
present other people's work not my own

01:20:50,280 --> 01:20:54,450
my contribution was just to say hmm

01:20:52,890 --> 01:20:55,920
seems like that should be able to be

01:20:54,450 --> 01:20:57,510
done faster and then other people

01:20:55,920 --> 01:20:59,040
pointed out yes we've been doing it here

01:20:57,510 --> 01:21:02,910
our results and so I'm pleased to report

01:20:59,040 --> 01:21:04,560
their work so here is work done by many

01:21:02,910 --> 01:21:08,460
people but particularly by Peter

01:21:04,560 --> 01:21:11,370
collingborne costea and Joe and Jim and

01:21:08,460 --> 01:21:14,130
I'm going to talk about the windows cast

01:21:11,370 --> 01:21:16,560
guard but it is derived from clang CFI

01:21:14,130 --> 01:21:19,860
so even though I'm giving the windows

01:21:16,560 --> 01:21:21,690
numbers kudos to the clang folks to

01:21:19,860 --> 01:21:26,010
Peter cost you to everybody who worked

01:21:21,690 --> 01:21:27,330
on the clang CFI it requires it's it's

01:21:26,010 --> 01:21:28,860
super compatible you don't have to

01:21:27,330 --> 01:21:31,740
change the ABI

01:21:28,860 --> 01:21:33,510
have to change the tables doesn't use

01:21:31,740 --> 01:21:36,720
our TTI everything I'm about to say

01:21:33,510 --> 01:21:41,550
works with /gr - on Windows with no type

01:21:36,720 --> 01:21:43,740
ID type info support it you do a simple

01:21:41,550 --> 01:21:46,530
arrange check you saw the code earlier

01:21:43,740 --> 01:21:48,870
the way it works is the super smart

01:21:46,530 --> 01:21:50,850
insight and I think the primary person

01:21:48,870 --> 01:21:52,170
here is Peter calling born for this

01:21:50,850 --> 01:21:55,950
insight thank you Peter

01:21:52,170 --> 01:21:58,050
is that if you take your v tables and

01:21:55,950 --> 01:22:02,970
you don't change them but you arrange

01:21:58,050 --> 01:22:04,800
them in memory in a certain order then

01:22:02,970 --> 01:22:07,530
if you are given dynamic pointers to two

01:22:04,800 --> 01:22:11,130
objects you can look at their v pointers

01:22:07,530 --> 01:22:15,000
and know just by doing a rain check on

01:22:11,130 --> 01:22:17,670
the V pointers if the if the hopefully

01:22:15,000 --> 01:22:19,800
derived objects V pointer is it a

01:22:17,670 --> 01:22:22,950
certain range is in the range of all the

01:22:19,800 --> 01:22:25,740
V tables of types derived from that that

01:22:22,950 --> 01:22:27,750
base with a simple bounds check on the V

01:22:25,740 --> 01:22:30,330
pointer which is constant time and

01:22:27,750 --> 01:22:32,930
requires in general two memory accesses

01:22:30,330 --> 01:22:35,550
one of which is likely already in cache

01:22:32,930 --> 01:22:37,950
you can compute in five instructions and

01:22:35,550 --> 01:22:41,040
two memory accesses whether the downcast

01:22:37,950 --> 01:22:43,380
succeeds with perfect type safety and

01:22:41,040 --> 01:22:48,060
fidelity this is a very important result

01:22:43,380 --> 01:22:52,080
now it's intra do L but so it doesn't

01:22:48,060 --> 01:22:55,830
work across dll's the preliminary

01:22:52,080 --> 01:22:58,230
results on trying this with spec and

01:22:55,830 --> 01:23:00,930
with Windows like is that there is very

01:22:58,230 --> 01:23:05,340
low impact negligible impact on binary

01:23:00,930 --> 01:23:07,680
size and on runtime the highest overhead

01:23:05,340 --> 01:23:10,650
we have measured so far that Joe has

01:23:07,680 --> 01:23:14,370
measured so far one of the windows is

01:23:10,650 --> 01:23:15,990
largest dll's is 1.5 percent bigger

01:23:14,370 --> 01:23:17,670
because of checks performed and function

01:23:15,990 --> 01:23:19,470
calls injected checks because the

01:23:17,670 --> 01:23:21,060
current one all it's doing is saying oh

01:23:19,470 --> 01:23:23,790
I noticed you're doing a static downcast

01:23:21,060 --> 01:23:24,840
I'm going to inject a check for you so

01:23:23,790 --> 01:23:25,800
you don't actually change the code to

01:23:24,840 --> 01:23:27,420
down underscore cast

01:23:25,800 --> 01:23:31,170
it's just noticing you're doing a static

01:23:27,420 --> 01:23:33,510
downcast and injecting a chapter but

01:23:31,170 --> 01:23:36,630
that 1.5 percent is not compared to our

01:23:33,510 --> 01:23:38,640
TTI it's compared to doing nothing at

01:23:36,630 --> 01:23:40,710
all it's compared to static cast because

01:23:38,640 --> 01:23:42,690
our TTI isn't even allowed in Windows

01:23:40,710 --> 01:23:44,670
because of the binary blow

01:23:42,690 --> 01:23:47,010
and the dynamic cast I should say in

01:23:44,670 --> 01:23:49,260
particular so the proposal is for

01:23:47,010 --> 01:23:52,530
standardization that I would like to

01:23:49,260 --> 01:23:55,800
propose is to provide a way to ask for

01:23:52,530 --> 01:23:57,750
only what you want cast down from base

01:23:55,800 --> 01:24:01,920
to derived not across a virtual

01:23:57,750 --> 01:24:03,270
inheritance link and then I can know at

01:24:01,920 --> 01:24:04,290
compile time give you an error if you

01:24:03,270 --> 01:24:05,790
don't do it because I can statically

01:24:04,290 --> 01:24:07,410
know whether you're obeying whether

01:24:05,790 --> 01:24:09,030
you're in that sweet spot but if it

01:24:07,410 --> 01:24:11,850
compiles is guaranteed to be five

01:24:09,030 --> 01:24:14,070
instructions or so which is way

01:24:11,850 --> 01:24:15,600
different than today and you don't pay

01:24:14,070 --> 01:24:19,550
unless you use it and you cannot write

01:24:15,600 --> 01:24:22,470
it better by hand for example Joe did a

01:24:19,550 --> 01:24:24,180
test for a simple single inheritance

01:24:22,470 --> 01:24:26,040
hierarchy where he instrumented dynamic

01:24:24,180 --> 01:24:27,540
cast and we can about whether

01:24:26,040 --> 01:24:29,400
it's the best possible that Emma cast

01:24:27,540 --> 01:24:32,100
but this is just actual data from the

01:24:29,400 --> 01:24:34,170
field and he looked and did an

01:24:32,100 --> 01:24:36,630
instruction trace so he's not this isn't

01:24:34,170 --> 01:24:39,170
source code this is going through just

01:24:36,630 --> 01:24:43,670
the instructions actually executed and

01:24:39,170 --> 01:24:48,330
that I am a cast was not this not this

01:24:43,670 --> 01:24:52,340
not this but there it was that much that

01:24:48,330 --> 01:24:55,320
many instructions the cast guard version

01:24:52,340 --> 01:24:56,790
was this much code most of which is

01:24:55,320 --> 01:25:00,240
comments and I'll let you see it a bit

01:24:56,790 --> 01:25:01,740
better now so the first two instructions

01:25:00,240 --> 01:25:03,990
so the first half of that which is all

01:25:01,740 --> 01:25:05,880
comments and two instructions as you see

01:25:03,990 --> 01:25:08,460
in the comments is a null pointer check

01:25:05,880 --> 01:25:10,770
which we would have already done with

01:25:08,460 --> 01:25:12,180
static cast anyway so that is not

01:25:10,770 --> 01:25:13,980
overhead compared to static cast so you

01:25:12,180 --> 01:25:16,710
can already ignore the top half of this

01:25:13,980 --> 01:25:18,540
what remains is five instructions where

01:25:16,710 --> 01:25:21,150
I load to the pointers basically and

01:25:18,540 --> 01:25:27,780
that you arrange check I do a sub comp

01:25:21,150 --> 01:25:30,660
that's it if we can standardize a down

01:25:27,780 --> 01:25:34,590
cast that people can use then we're in a

01:25:30,660 --> 01:25:36,720
world where there is no valid reason not

01:25:34,590 --> 01:25:39,900
to use the standard cast that is type

01:25:36,720 --> 01:25:41,250
safe and is zero overhead don't pay if

01:25:39,900 --> 01:25:44,310
you don't use and you cannot do better

01:25:41,250 --> 01:25:45,450
by hand so this talk has been largely

01:25:44,310 --> 01:25:48,470
about fixing things

01:25:45,450 --> 01:25:50,610
fixing exception handling in our TTI

01:25:48,470 --> 01:25:52,830
sometimes it's a bit about adding a knob

01:25:50,610 --> 01:25:54,600
buts adding a knob like throws to an

01:25:52,830 --> 01:25:56,219
existing thing it's not like inventing a

01:25:54,600 --> 01:25:58,530
new thing like concepts which is

01:25:56,219 --> 01:26:00,150
the add things bucket but by fixing

01:25:58,530 --> 01:26:03,449
things we can simplify the programming

01:26:00,150 --> 01:26:05,610
model and the language and I'd like to

01:26:03,449 --> 01:26:09,329
suggest that it's the right hand side is

01:26:05,610 --> 01:26:11,309
a future worth considering if we

01:26:09,329 --> 01:26:14,269
inverted this pyramid so that in the

01:26:11,309 --> 01:26:18,090
future we had much more emphasis on

01:26:14,269 --> 01:26:20,849
simplifying the C++ we have and also on

01:26:18,090 --> 01:26:23,070
fixing the C++ we have in ways like I

01:26:20,849 --> 01:26:24,510
talked about today is that something

01:26:23,070 --> 01:26:27,320
that you would like to see happen with C

01:26:24,510 --> 01:26:27,320
+ S evolution

01:26:34,340 --> 01:26:39,300
so we're gonna try and I'm I will try to

01:26:37,680 --> 01:26:43,170
convince more people than especially the

01:26:39,300 --> 01:26:46,590
simplify part is worth doing remember a

01:26:43,170 --> 01:26:50,640
really good rule of thumb static by

01:26:46,590 --> 01:26:52,680
default dynamic by opt-in that gets you

01:26:50,640 --> 01:26:55,500
to don't pay for what you don't use and

01:26:52,680 --> 01:26:58,170
when you do use it it's as efficient as

01:26:55,500 --> 01:27:01,170
you could write by hand that is c plus

01:26:58,170 --> 01:27:03,660
plus that is c plus plus ik so to say

01:27:01,170 --> 01:27:05,550
and like it says in the top right our

01:27:03,660 --> 01:27:07,050
historical sitting strength is static

01:27:05,550 --> 01:27:09,030
and every time that we have added a

01:27:07,050 --> 01:27:11,250
feature in the last 20 years that has

01:27:09,030 --> 01:27:13,140
markedly improved the language nearly

01:27:11,250 --> 01:27:16,350
always it has been doubling down on our

01:27:13,140 --> 01:27:19,050
static nature concepts for static typing

01:27:16,350 --> 01:27:22,410
templates for static polymorphism and

01:27:19,050 --> 01:27:25,770
now static exception typing static our

01:27:22,410 --> 01:27:27,600
TTI with reflection so let's make

01:27:25,770 --> 01:27:30,750
exceptions in our TTI more affordable

01:27:27,600 --> 01:27:33,780
and usable let's actually do work to fix

01:27:30,750 --> 01:27:36,660
c++ it's no wonder that the only two

01:27:33,780 --> 01:27:39,030
features in the standard that are not

01:27:36,660 --> 01:27:41,370
zero overhead are the ones that every

01:27:39,030 --> 01:27:43,650
compiler has a switch to turn off people

01:27:41,370 --> 01:27:47,460
are voting with their feet let's fix it

01:27:43,650 --> 01:27:49,740
and unfragmented e and then also besides

01:27:47,460 --> 01:27:51,810
fixing things as we go into the future

01:27:49,740 --> 01:27:53,970
and in later talks in later years and

01:27:51,810 --> 01:27:56,400
later cpp cons and other conferences i

01:27:53,970 --> 01:27:59,460
would love to see more talks more

01:27:56,400 --> 01:28:01,380
proposals about actually aggressively

01:27:59,460 --> 01:28:03,750
simplifying the language that we have

01:28:01,380 --> 01:28:06,560
today to get rid of pitfalls get rid of

01:28:03,750 --> 01:28:09,450
corner cases and the more we can do that

01:28:06,560 --> 01:28:12,800
the more we can benefit c++ now and in

01:28:09,450 --> 01:28:12,800
the future thank you

01:28:21,789 --> 01:28:27,639
I know you John I know you want to make

01:28:26,440 --> 01:28:31,269
some announcements do we have any time

01:28:27,639 --> 01:28:32,679
for questions take two all right we have

01:28:31,269 --> 01:28:34,179
I'll take what over here because I know

01:28:32,679 --> 01:28:35,650
who you are and you're on the committee

01:28:34,179 --> 01:28:36,940
so I'm gonna I'm sorry I'm gonna down

01:28:35,650 --> 01:28:49,409
vote you because I can only do so sorry

01:28:36,940 --> 01:28:53,440
Peter I'll buy you a beer later places

01:28:49,409 --> 01:28:57,750
and you said we have to be conditional

01:28:53,440 --> 01:29:01,539
he also said well the future new code

01:28:57,750 --> 01:29:04,719
would either be annotated no accept or

01:29:01,539 --> 01:29:07,690
the throat attribute would it mean that

01:29:04,719 --> 01:29:10,989
the library also needs a conditional

01:29:07,690 --> 01:29:12,760
throws so the conditional so the

01:29:10,989 --> 01:29:15,880
conditional no accept is a conditional

01:29:12,760 --> 01:29:17,110
throws in that world so if we are in a

01:29:15,880 --> 01:29:18,909
world where we're teaching people for

01:29:17,110 --> 01:29:21,010
new code right exactly one of no

01:29:18,909 --> 01:29:22,780
acceptor throws there's no room for

01:29:21,010 --> 01:29:24,969
conditional no accept to compute it if

01:29:22,780 --> 01:29:28,719
you can compute it as a simple example

01:29:24,969 --> 01:29:30,400
if you're using a vector instantiated

01:29:28,719 --> 01:29:32,559
with an alligator you know doesn't throw

01:29:30,400 --> 01:29:35,079
then you know accept your conditional no

01:29:32,559 --> 01:29:37,090
accept will become no accept true

01:29:35,079 --> 01:29:40,800
otherwise no accept false would be

01:29:37,090 --> 01:29:40,800
equivalent to throws that's the idea

01:29:48,090 --> 01:29:53,019
yeah I see what you mean so certainly in

01:29:50,889 --> 01:29:55,179
a world where we didn't have the

01:29:53,019 --> 01:29:56,920
existing dynamic exceptions at all what

01:29:55,179 --> 01:29:58,780
I just said would be true but but you

01:29:56,920 --> 01:30:00,730
are correct that in the conditional case

01:29:58,780 --> 01:30:03,159
you want to say where if it's not if

01:30:00,730 --> 01:30:04,840
it's not true if it is true which one is

01:30:03,159 --> 01:30:06,639
it say yes you're correct you would need

01:30:04,840 --> 01:30:09,550
in that world a conditional throws as

01:30:06,639 --> 01:30:12,070
well I think I have that in the paper I

01:30:09,550 --> 01:30:13,929
I like to live in the future and fast

01:30:12,070 --> 01:30:20,170
forward to the world where it's just one

01:30:13,929 --> 01:30:20,889
or the other but you're right can we do

01:30:20,170 --> 01:30:22,090
one at a time

01:30:20,889 --> 01:30:23,679
sorry thank you very much for your

01:30:22,090 --> 01:30:25,420
question but we only have time for one

01:30:23,679 --> 01:30:27,219
or two more please you said there were

01:30:25,420 --> 01:30:28,989
some Co bases that bandage

01:30:27,219 --> 01:30:32,139
and there were even more where you were

01:30:28,989 --> 01:30:34,059
not allowed to use our TTI but that

01:30:32,139 --> 01:30:39,639
confused me because I thought exceptions

01:30:34,059 --> 01:30:40,989
relied on my TTI so if you look at first

01:30:39,639 --> 01:30:43,719
of all if you look at the numbers I if I

01:30:40,989 --> 01:30:45,369
said it backwards I apologize the actual

01:30:43,719 --> 01:30:47,170
data on the slide showed that there were

01:30:45,369 --> 01:30:50,079
it was like two thirds of projects

01:30:47,170 --> 01:30:51,429
enabled our TTI whereas only it was only

01:30:50,079 --> 01:30:53,860
about half of exceptions so there is

01:30:51,429 --> 01:30:55,329
more our TTI use in the wild there is

01:30:53,860 --> 01:30:57,940
less banding of our TTI then of

01:30:55,329 --> 01:31:00,489
exceptions however yes you are correct

01:30:57,940 --> 01:31:04,090
that exception handling does require our

01:31:00,489 --> 01:31:06,880
TTI so that that order is natural the

01:31:04,090 --> 01:31:09,940
the thing that however is the compiler

01:31:06,880 --> 01:31:11,530
can generate a dependency where you must

01:31:09,940 --> 01:31:13,630
have our TTI to enable exception

01:31:11,530 --> 01:31:15,429
handling and that's common theoretically

01:31:13,630 --> 01:31:16,749
a compiler could also just implement

01:31:15,429 --> 01:31:21,219
exception handling with just enough AR

01:31:16,749 --> 01:31:25,360
TTI to do the void star to base cast to

01:31:21,219 --> 01:31:27,760
base star cast yes I'm gonna cheat one

01:31:25,360 --> 01:31:32,949
more but then we have to go sorry God

01:31:27,760 --> 01:31:35,940
thank you so one thing that came to my

01:31:32,949 --> 01:31:38,949
mind is and are you worried about that

01:31:35,940 --> 01:31:43,539
these two words of information that you

01:31:38,949 --> 01:31:45,880
can Conway using STD arrow like most of

01:31:43,539 --> 01:31:47,679
the languages that use modern languages

01:31:45,880 --> 01:31:49,449
that use error codes usually have some

01:31:47,679 --> 01:31:52,989
kind of type where you can put in

01:31:49,449 --> 01:31:56,380
anything and um are you worried about

01:31:52,989 --> 01:31:58,719
that if they propagate they would it

01:31:56,380 --> 01:32:01,599
would be hard for the programmer to

01:31:58,719 --> 01:32:04,749
always choose different codes and be

01:32:01,599 --> 01:32:06,010
sure to handle the right arrow so it's a

01:32:04,749 --> 01:32:08,349
good question that will have a long

01:32:06,010 --> 01:32:09,909
answer the short answer to take a look

01:32:08,349 --> 01:32:11,920
at that section of the paper and also

01:32:09,909 --> 01:32:13,960
the related papers like Nile Douglass's

01:32:11,920 --> 01:32:15,940
in particular that talk about the error

01:32:13,960 --> 01:32:19,449
code the short answer is the error code

01:32:15,940 --> 01:32:21,699
is two words because one of them is like

01:32:19,449 --> 01:32:22,809
the payload usually an integer but it

01:32:21,699 --> 01:32:24,099
could also be a pointer to a dynamic

01:32:22,809 --> 01:32:26,650
exception if you're wrapping one of

01:32:24,099 --> 01:32:28,809
those and the other one is a discrete is

01:32:26,650 --> 01:32:31,749
a category which is usually a void star

01:32:28,809 --> 01:32:35,229
to a singleton the to the category of

01:32:31,749 --> 01:32:38,590
air that can represent any conceivable

01:32:35,229 --> 01:32:40,810
air in posix in Windows in carbon and

01:32:38,590 --> 01:32:43,840
calm and all of those things

01:32:40,810 --> 01:32:45,310
and allow customization so including as

01:32:43,840 --> 01:32:47,550
I mentioned it can wrap a dynamic

01:32:45,310 --> 01:32:50,260
exception which is how we can go from

01:32:47,550 --> 01:32:52,720
from if we call a function that throws a

01:32:50,260 --> 01:32:54,940
dynamic exception and we're a throws

01:32:52,720 --> 01:32:57,190
function a new style value throwing

01:32:54,940 --> 01:32:59,440
function we can wrap the dynamic

01:32:57,190 --> 01:33:01,960
exception in a stood air and then

01:32:59,440 --> 01:33:03,220
propagated with bit blit so that's the

01:33:01,960 --> 01:33:05,350
short answer but please see the paper

01:33:03,220 --> 01:33:07,750
for the answer thank you thank you again

01:33:05,350 --> 01:33:09,490
and I hope you enjoy the rest of what

01:33:07,750 --> 01:33:13,279
John has to say thank you John

01:33:09,490 --> 01:33:13,279

YouTube URL: https://www.youtube.com/watch?v=ARYP83yNAWk


