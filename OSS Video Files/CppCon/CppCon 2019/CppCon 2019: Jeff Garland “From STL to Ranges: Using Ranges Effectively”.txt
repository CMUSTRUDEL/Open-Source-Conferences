Title: CppCon 2019: Jeff Garland “From STL to Ranges: Using Ranges Effectively”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
This course provides a survey of C++20 ranges and their application. Ranges are the largest revamp of the Standard Template Library (STL) in 20 years and will impact daily C++ programming dramatically. Some of the changes seem minor, but full utilization of ranges is much more transformational to coding practice.

The tutorial goes beyond the basics to explore what's behind the library. For example, understand the key differences between algorithms and views and when to apply them.  Chock full of example code this tutorial will bootstrap programmer's usage of std::ranges.
— 
Jeff Garland
CrystalClear Software
Phoenix, Az
Jeff Garland has worked on many large-scale, distributed software projects over the past 25+ years. The systems span many different domains including telephone switching, industrial process control, satellite ground control, ip-based communications, and financial systems. He has written C++ networked code for several large systems including the development high performance network servers and data distribution frameworks.Mr. Garland’s interest in Boost started in 2000 as a user. Since then he has developed Boost.date_time, become a moderator, served as a review manager for several libraries (including asio and serialization), administered the Boost wiki, and served as a mentor for Google Summer of Code. Mr. Garland holds a Master’s degree in Computer Science from Arizona State University and a Bachelor of Science in Systems Engineering from the University of Arizona. He is co-author of Large Scale Software Architecture: A Practical Guide Using UML. He is currently Principal Consultant for his own company: CrystalClear Software, Inc.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,570 --> 00:00:13,320
let's go ahead and get started whoo

00:00:11,190 --> 00:00:15,600
there we go

00:00:13,320 --> 00:00:17,580
let me get a little bit of a census in

00:00:15,600 --> 00:00:20,430
the room before I get started

00:00:17,580 --> 00:00:25,050
who here has done anything with ranges

00:00:20,430 --> 00:00:27,300
at this point okay so a bunch of people

00:00:25,050 --> 00:00:31,189
the plants in the front row that you

00:00:27,300 --> 00:00:37,320
guys are you know you're not fair

00:00:31,189 --> 00:00:40,520
so ranges is something new in C++ 20 and

00:00:37,320 --> 00:00:48,030
it's really a fundamental redesign of

00:00:40,520 --> 00:00:50,340
the STL and how I started looking at

00:00:48,030 --> 00:00:54,090
ranges was really a few years back

00:00:50,340 --> 00:00:57,720
it was clear after any blur he gave a

00:00:54,090 --> 00:01:00,300
presentation and C++ now about ranges

00:00:57,720 --> 00:01:01,830
and was actively working on proposals

00:01:00,300 --> 00:01:04,259
for the Standards Committee that this is

00:01:01,830 --> 00:01:06,450
where things were going to go so a few

00:01:04,259 --> 00:01:09,720
years ago at C++ now in a library in a

00:01:06,450 --> 00:01:12,200
week kind of out of frustration we

00:01:09,720 --> 00:01:16,679
decided that we needed to write some

00:01:12,200 --> 00:01:19,890
example code for ranges and after that

00:01:16,679 --> 00:01:22,619
point in time we started using ranges in

00:01:19,890 --> 00:01:27,420
production even though that was verboten

00:01:22,619 --> 00:01:29,490
by mr. kneedler as well but we decided

00:01:27,420 --> 00:01:32,789
that we would do it anyway and so far

00:01:29,490 --> 00:01:35,520
it's been a good experience today I'm

00:01:32,789 --> 00:01:39,359
going to talk to you about C++ 20 ranges

00:01:35,520 --> 00:01:42,509
and so I'm gonna limit myself to the

00:01:39,359 --> 00:01:44,159
content that will be in C++ 20 as best I

00:01:42,509 --> 00:01:46,520
can do that and I'll tell you the status

00:01:44,159 --> 00:01:49,979
of that in a bit

00:01:46,520 --> 00:01:53,880
so we're going to go through a lot of

00:01:49,979 --> 00:01:56,759
code and hopefully when you walk away

00:01:53,880 --> 00:01:58,439
from the talk today you'll have a good

00:01:56,759 --> 00:02:00,959
idea about the different parts of the

00:01:58,439 --> 00:02:06,079
library and how its structured and how

00:02:00,959 --> 00:02:10,310
you might apply it to your own situation

00:02:06,079 --> 00:02:14,040
okay so let's just start with the basics

00:02:10,310 --> 00:02:16,050
in STL the old way to run a sort would

00:02:14,040 --> 00:02:19,500
be something like this I have an STD

00:02:16,050 --> 00:02:22,200
array I call sort with began an end all

00:02:19,500 --> 00:02:22,500
very straightforward we all know and

00:02:22,200 --> 00:02:24,810
love

00:02:22,500 --> 00:02:28,890
this or maybe we don't love it so much

00:02:24,810 --> 00:02:30,960
because of that began end so really at

00:02:28,890 --> 00:02:33,330
its most core level ranges is going to

00:02:30,960 --> 00:02:34,890
give you a way to write STL code like

00:02:33,330 --> 00:02:39,650
you wanted to write it for two decades

00:02:34,890 --> 00:02:43,860
now in a clear and big unambiguous way

00:02:39,650 --> 00:02:46,680
and you know the 13 characters there is

00:02:43,860 --> 00:02:50,250
really not the important point really

00:02:46,680 --> 00:02:52,500
the important point is that there's a

00:02:50,250 --> 00:02:58,680
higher signal-to-noise ratio in this

00:02:52,500 --> 00:03:02,010
code here's how you might do find if the

00:02:58,680 --> 00:03:03,750
old way once again you would have

00:03:02,010 --> 00:03:07,260
something like a collection like an

00:03:03,750 --> 00:03:08,760
array you have a predicate and you would

00:03:07,260 --> 00:03:11,640
pass that predicate to the find if

00:03:08,760 --> 00:03:14,100
algorithm returning an iterator if the

00:03:11,640 --> 00:03:18,450
iterator is not and then you can

00:03:14,100 --> 00:03:20,400
dereference it and access its value it's

00:03:18,450 --> 00:03:23,280
pretty much the same thing in ranges

00:03:20,400 --> 00:03:25,890
once again except for once again that

00:03:23,280 --> 00:03:27,900
began an end is gone now you're starting

00:03:25,890 --> 00:03:29,820
to see the point of the quote on the

00:03:27,900 --> 00:03:31,739
first slide you can see that the

00:03:29,820 --> 00:03:36,480
beginning end starts to evaporate from

00:03:31,739 --> 00:03:39,920
your code but there's something that's

00:03:36,480 --> 00:03:44,489
really much more radical about the range

00:03:39,920 --> 00:03:48,600
library and that part of the radical

00:03:44,489 --> 00:03:50,700
change is views and we're gonna go

00:03:48,600 --> 00:03:53,370
through and define what these things are

00:03:50,700 --> 00:03:55,769
in some depth as we go through the

00:03:53,370 --> 00:03:58,200
presentation but if you look at this

00:03:55,769 --> 00:04:00,840
particular code you'll notice I have my

00:03:58,200 --> 00:04:05,459
same array I have my same predicate and

00:04:00,840 --> 00:04:09,989
now I have a for loop I'll get to the P

00:04:05,459 --> 00:04:12,390
note point earlier today about for loops

00:04:09,989 --> 00:04:16,350
but in any case you can see I have a

00:04:12,390 --> 00:04:18,600
range filter it takes the range and it

00:04:16,350 --> 00:04:20,760
applies the predicate and I only drop

00:04:18,600 --> 00:04:24,030
into the loop when the predicate is

00:04:20,760 --> 00:04:27,540
actually evaluated to true now if you

00:04:24,030 --> 00:04:30,870
look carefully you'll note there are no

00:04:27,540 --> 00:04:33,180
iterators you do not see the presence of

00:04:30,870 --> 00:04:36,330
iterators in this code you only get

00:04:33,180 --> 00:04:38,220
values in the for loop that you know

00:04:36,330 --> 00:04:41,639
you can access and that's what's very

00:04:38,220 --> 00:04:44,430
radical about this and we'll see how

00:04:41,639 --> 00:04:46,650
that's actually done so what are the

00:04:44,430 --> 00:04:48,539
goals of this talk I'm gonna give you a

00:04:46,650 --> 00:04:50,789
lot of range code today so you're gonna

00:04:48,539 --> 00:04:55,080
see a lot of what's going to be in

00:04:50,789 --> 00:04:57,930
standard ranges in C++ 20 will talk

00:04:55,080 --> 00:05:00,780
about some things how to apply it this

00:04:57,930 --> 00:05:03,210
even though I think I accidentally said

00:05:00,780 --> 00:05:05,939
this was a intermediate to advanced it's

00:05:03,210 --> 00:05:07,949
probably more beginner intermediate in

00:05:05,939 --> 00:05:10,770
that I'm not going to show you some

00:05:07,949 --> 00:05:13,289
super complicated crazy examples for how

00:05:10,770 --> 00:05:15,840
to use range code because reality is

00:05:13,289 --> 00:05:18,840
that 90% of your uses are going to be

00:05:15,840 --> 00:05:20,699
very straightforward and simple and I

00:05:18,840 --> 00:05:24,560
think it's easier to see how things go

00:05:20,699 --> 00:05:27,270
together when we keep it reasonably easy

00:05:24,560 --> 00:05:30,449
so we'll also talk about some of the

00:05:27,270 --> 00:05:32,190
other changes that go along with like

00:05:30,449 --> 00:05:35,340
projections on algorithms we'll cover

00:05:32,190 --> 00:05:37,770
that briefly and we'll talk about what's

00:05:35,340 --> 00:05:39,990
a range versus a V versus an adapter

00:05:37,770 --> 00:05:42,810
those are fundamental concepts in using

00:05:39,990 --> 00:05:45,360
this library so here's the outline of

00:05:42,810 --> 00:05:46,740
the talk I'm not going to dwell on it so

00:05:45,360 --> 00:05:48,690
we're going to go through basics we're

00:05:46,740 --> 00:05:50,849
going to go through the algorithms will

00:05:48,690 --> 00:05:52,379
go through views we'll talk a little bit

00:05:50,849 --> 00:05:55,020
about string view and span which are

00:05:52,379 --> 00:05:57,270
view types and then we're gonna survey

00:05:55,020 --> 00:05:59,610
views because as I said that's the

00:05:57,270 --> 00:06:04,229
radical part of this and some

00:05:59,610 --> 00:06:06,479
performance and and observations so

00:06:04,229 --> 00:06:08,839
things you'll see me do in this talk I

00:06:06,479 --> 00:06:11,669
will refer to the standard in places I

00:06:08,839 --> 00:06:13,740
am gonna take questions so this can be

00:06:11,669 --> 00:06:17,699
interactive at least until we get behind

00:06:13,740 --> 00:06:19,490
on time if I can't answer something

00:06:17,699 --> 00:06:21,569
right away we'll talk about it afterward

00:06:19,490 --> 00:06:24,930
to make sure that we get through the

00:06:21,569 --> 00:06:28,259
material like I said I will show you

00:06:24,930 --> 00:06:31,050
lots of code and as far as I'm concerned

00:06:28,259 --> 00:06:34,469
I won't show you any code that I haven't

00:06:31,050 --> 00:06:37,289
compiled somewhere in some universe on

00:06:34,469 --> 00:06:41,639
some compiler with some version of

00:06:37,289 --> 00:06:44,539
ranges which is a little harder than you

00:06:41,639 --> 00:06:46,830
might think over the last six months but

00:06:44,539 --> 00:06:49,229
now it's getting easier and I'll shut

00:06:46,830 --> 00:06:50,230
I'll show you about that so the primary

00:06:49,229 --> 00:06:52,120
environment I

00:06:50,230 --> 00:06:55,450
which is not for any reason other than

00:06:52,120 --> 00:06:58,600
it's easy for me is mostly GCC and Linux

00:06:55,450 --> 00:07:00,460
and this presentation has really been

00:06:58,600 --> 00:07:02,290
developed over the past six months when

00:07:00,460 --> 00:07:05,500
many things in the ranges

00:07:02,290 --> 00:07:09,490
implementations have been in flux the

00:07:05,500 --> 00:07:10,870
standard has been in flux as the process

00:07:09,490 --> 00:07:13,060
of standardization has been happening

00:07:10,870 --> 00:07:14,680
but now we're at a point and I'll go

00:07:13,060 --> 00:07:17,140
through this in a minute

00:07:14,680 --> 00:07:19,930
that the design is settled and the

00:07:17,140 --> 00:07:21,160
committee is only bug-fixing so really

00:07:19,930 --> 00:07:24,210
what I'm going to present today should

00:07:21,160 --> 00:07:27,990
stay rather stable as we go forward so

00:07:24,210 --> 00:07:30,550
there's three canonical implementations

00:07:27,990 --> 00:07:34,330
range v3 of course as Eric dealers

00:07:30,550 --> 00:07:38,110
that's the most famous one if you ask

00:07:34,330 --> 00:07:42,940
for ranges CPP 20 namespace that will

00:07:38,110 --> 00:07:48,010
get you the CPP 20 part of the library

00:07:42,940 --> 00:07:51,640
CMC sto 2 is Casey Carter's and you use

00:07:48,010 --> 00:07:54,460
STD experimental ranges to get the C++

00:07:51,640 --> 00:07:56,230
20 part and then there's nano range with

00:07:54,460 --> 00:07:59,010
Tristan brindle who's sitting in the

00:07:56,230 --> 00:08:01,630
front row here and really that's an

00:07:59,010 --> 00:08:04,150
independent from the specification

00:08:01,630 --> 00:08:08,050
development of ranges which is very

00:08:04,150 --> 00:08:10,000
interesting and quite frankly was new I

00:08:08,050 --> 00:08:17,620
learned about it at the conference this

00:08:10,000 --> 00:08:19,960
week and it's really cool so so the

00:08:17,620 --> 00:08:23,560
status of this has been as I said in

00:08:19,960 --> 00:08:28,450
much flux and there were many

00:08:23,560 --> 00:08:30,220
interactions between compilers and so at

00:08:28,450 --> 00:08:33,190
times it was quite difficult to actually

00:08:30,220 --> 00:08:35,010
get this code to compile but it is

00:08:33,190 --> 00:08:37,750
getting much better

00:08:35,010 --> 00:08:41,860
the primary proposal that went into the

00:08:37,750 --> 00:08:44,950
standard was really adopted in 2018 in

00:08:41,860 --> 00:08:47,580
San Diego it really had been multiple

00:08:44,950 --> 00:08:51,010
years in the making

00:08:47,580 --> 00:08:53,230
and that was not everything there were a

00:08:51,010 --> 00:08:55,480
series of follow ups including changes

00:08:53,230 --> 00:08:57,550
that went into the Cologne meeting about

00:08:55,480 --> 00:09:00,730
a month and a half ago but as I said

00:08:57,550 --> 00:09:03,760
we're designed complete and only bug

00:09:00,730 --> 00:09:07,950
fixes in the next year and change

00:09:03,760 --> 00:09:11,440
before the final stamp goes on C++ 20 so

00:09:07,950 --> 00:09:14,530
how does it feel to use ranges now I

00:09:11,440 --> 00:09:16,390
think we're getting close there are

00:09:14,530 --> 00:09:18,390
still bugs and the implementations of

00:09:16,390 --> 00:09:21,850
course

00:09:18,390 --> 00:09:22,180
how about God Bowl can we use it on God

00:09:21,850 --> 00:09:26,940
Bowl

00:09:22,180 --> 00:09:29,950
yes we can both CMC STL 2 and V 3 are

00:09:26,940 --> 00:09:31,990
libraries that are selectable so you can

00:09:29,950 --> 00:09:33,670
play around with range code there you

00:09:31,990 --> 00:09:35,830
don't know about God Bowl

00:09:33,670 --> 00:09:38,220
try and find mat God bowled he's here

00:09:35,830 --> 00:09:38,220
somewhere

00:09:38,680 --> 00:09:43,600
and Tristan actually should be a neat

00:09:42,220 --> 00:09:45,400
trick you can actually pull in an

00:09:43,600 --> 00:09:48,240
arranged by doing and include to the

00:09:45,400 --> 00:09:51,070
github which is which is awesome

00:09:48,240 --> 00:09:53,050
how about CPP reference anybody use this

00:09:51,070 --> 00:09:58,810
site yeah

00:09:53,050 --> 00:09:59,530
so yeah it doesn't quite work they use

00:09:58,810 --> 00:10:02,380
kolleru

00:09:59,530 --> 00:10:05,320
as their back in for compilation so they

00:10:02,380 --> 00:10:08,440
have code as examples but it doesn't

00:10:05,320 --> 00:10:12,190
actually compile so you know your

00:10:08,440 --> 00:10:14,170
mileage may vary with that one but

00:10:12,190 --> 00:10:16,930
overall I'd say things are in a state

00:10:14,170 --> 00:10:19,360
where you can definitely get started and

00:10:16,930 --> 00:10:23,500
you can definitely at least experiment

00:10:19,360 --> 00:10:26,070
with C++ 20 ranges all right so let's

00:10:23,500 --> 00:10:30,040
step back and talk about the basics

00:10:26,070 --> 00:10:31,690
there's really four important things and

00:10:30,040 --> 00:10:33,730
one of the things that's gotten really

00:10:31,690 --> 00:10:35,230
hard about giving a talk about something

00:10:33,730 --> 00:10:43,320
is you can't use the word concept

00:10:35,230 --> 00:10:45,160
anymore well so there are ranges and

00:10:43,320 --> 00:10:47,680
ranges are something that can be

00:10:45,160 --> 00:10:50,170
iterated over but there's a multitude of

00:10:47,680 --> 00:10:51,370
different range concepts and I'm not

00:10:50,170 --> 00:10:54,690
really going to talk about the range

00:10:51,370 --> 00:10:57,670
concepts today because of lack of time

00:10:54,690 --> 00:10:59,110
but needless to say in general a range

00:10:57,670 --> 00:11:00,880
is something that can be iterated over

00:10:59,110 --> 00:11:04,780
and we'll detail this a little bit more

00:11:00,880 --> 00:11:06,700
a range algorithm is something that

00:11:04,780 --> 00:11:10,540
obviously an algorithm that takes a

00:11:06,700 --> 00:11:14,920
range and a view is a lazy range such

00:11:10,540 --> 00:11:16,480
cheap to copy now you might say

00:11:14,920 --> 00:11:17,540
something about programmers and being

00:11:16,480 --> 00:11:21,110
lazy and cheap

00:11:17,540 --> 00:11:24,440
but then you might have to do more of my

00:11:21,110 --> 00:11:26,350
bad humor and then there's a range

00:11:24,440 --> 00:11:30,550
adapter which is a way to make a range

00:11:26,350 --> 00:11:35,480
into a view so that you can use a

00:11:30,550 --> 00:11:37,339
regular range as of you and we're going

00:11:35,480 --> 00:11:40,370
to detail that a little bit more in a

00:11:37,339 --> 00:11:41,630
minute so how does this layout in terms

00:11:40,370 --> 00:11:44,029
of the mechanics of it

00:11:41,630 --> 00:11:47,810
so in C++ 20 there'll be a new header

00:11:44,029 --> 00:11:50,560
called ranges there will be three new

00:11:47,810 --> 00:11:55,610
namespaces there's the ranges namespace

00:11:50,560 --> 00:11:59,959
that has both new algorithms and the

00:11:55,610 --> 00:12:02,149
views in it and there's a ranges sub

00:11:59,959 --> 00:12:04,940
namespace called view which has the

00:12:02,149 --> 00:12:07,370
range adapters in it now you're already

00:12:04,940 --> 00:12:10,130
thinking STD colon colon ranges Cohen

00:12:07,370 --> 00:12:13,970
colon views is getting too long which it

00:12:10,130 --> 00:12:16,519
is so there's a shortcut to the adapter

00:12:13,970 --> 00:12:18,440
namespace called views and so that's how

00:12:16,519 --> 00:12:20,480
you'll see most of the code written and

00:12:18,440 --> 00:12:22,130
you'll notice that there's going to be a

00:12:20,480 --> 00:12:25,459
naming pattern here when we start

00:12:22,130 --> 00:12:29,240
looking at these you'll see that things

00:12:25,459 --> 00:12:33,230
an STD Cohen colon ranges like take view

00:12:29,240 --> 00:12:36,680
turn into STD colon colon views colon

00:12:33,230 --> 00:12:40,010
colon take so you can already see the

00:12:36,680 --> 00:12:42,380
name difference tells you whether the

00:12:40,010 --> 00:12:46,490
thing is really an adapter or whether

00:12:42,380 --> 00:12:49,790
it's a view itself an adapter again is

00:12:46,490 --> 00:12:53,600
just a something that can manufacture

00:12:49,790 --> 00:12:56,779
review so you'll see in a lot of my talk

00:12:53,600 --> 00:12:58,910
here I short cut everything to RNG I

00:12:56,779 --> 00:13:00,800
also take a lot of other shortcuts on

00:12:58,910 --> 00:13:03,860
the slides sometimes I show you

00:13:00,800 --> 00:13:09,079
everything but often it's a shortcut to

00:13:03,860 --> 00:13:11,089
make it easier to see so why did the

00:13:09,079 --> 00:13:15,529
committee make this decision to sub

00:13:11,089 --> 00:13:17,810
namespace well the primary reason is

00:13:15,529 --> 00:13:19,550
that these things the new algorithms are

00:13:17,810 --> 00:13:23,930
not just new overloads they have

00:13:19,550 --> 00:13:27,550
different return types they have some

00:13:23,930 --> 00:13:30,050
additional parameters in many cases and

00:13:27,550 --> 00:13:31,690
anything that removes the parameter of

00:13:30,050 --> 00:13:35,450
course is going to break

00:13:31,690 --> 00:13:37,610
so really I think there were a lot of

00:13:35,450 --> 00:13:40,970
folks on the committee that didn't want

00:13:37,610 --> 00:13:42,820
to do it this way but it was the

00:13:40,970 --> 00:13:45,740
compromise that made the most sense for

00:13:42,820 --> 00:13:48,820
backward compatibility so that's why

00:13:45,740 --> 00:13:48,820
it's in a different namespace

00:13:49,660 --> 00:13:56,899
all right so really Jeff what's a range

00:13:53,959 --> 00:14:01,730
you haven't really told me what a range

00:13:56,899 --> 00:14:05,810
is yet so an iterator pairs the most

00:14:01,730 --> 00:14:07,700
simple version that's really the idea of

00:14:05,810 --> 00:14:10,100
a common range where the iterators are

00:14:07,700 --> 00:14:13,850
the same but one of the things that's

00:14:10,100 --> 00:14:15,740
new in these algorithms and in the views

00:14:13,850 --> 00:14:18,140
is that the iterator type and the

00:14:15,740 --> 00:14:19,610
sentinel do not have to be the same in

00:14:18,140 --> 00:14:21,470
other words the end of the range can be

00:14:19,610 --> 00:14:23,089
a different type from the iterator as

00:14:21,470 --> 00:14:25,430
long as they can compare to each other

00:14:23,089 --> 00:14:28,459
and this gives us some interesting

00:14:25,430 --> 00:14:30,350
properties now where ranges and in

00:14:28,459 --> 00:14:35,450
particular views can be logically

00:14:30,350 --> 00:14:37,070
infinite so channeling Andree we're

00:14:35,450 --> 00:14:42,529
always going to have infinite for loops

00:14:37,070 --> 00:14:44,529
and infinite ranges going forward so

00:14:42,529 --> 00:14:49,190
let's look at some concrete examples so

00:14:44,529 --> 00:14:51,310
clearly collections are ranges strings

00:14:49,190 --> 00:14:54,410
are ranges they're sequence containers

00:14:51,310 --> 00:14:56,149
and many other things in the standard

00:14:54,410 --> 00:14:59,350
library are ranges so your arrays

00:14:56,149 --> 00:15:04,010
vectors maps sets lists can all be

00:14:59,350 --> 00:15:08,420
ranges the container adapters yeah

00:15:04,010 --> 00:15:10,220
nut ranges and why not because they

00:15:08,420 --> 00:15:15,649
don't have a begin end and you cannot

00:15:10,220 --> 00:15:17,779
iterate over them so other things like

00:15:15,649 --> 00:15:20,839
directory iterators stream iterators and

00:15:17,779 --> 00:15:22,010
so forth can can be ranges and then

00:15:20,839 --> 00:15:27,140
finally at the bottom we'll talk a

00:15:22,010 --> 00:15:28,490
little bit about string being span so

00:15:27,140 --> 00:15:32,329
one of the most powerful things about

00:15:28,490 --> 00:15:36,170
the range design is that it leverages 20

00:15:32,329 --> 00:15:39,770
years of C++ experience and specifically

00:15:36,170 --> 00:15:44,149
that began end semantics allows us to

00:15:39,770 --> 00:15:45,500
now apply ranges to all the existing

00:15:44,149 --> 00:15:49,400
code in the world

00:15:45,500 --> 00:15:52,340
has begin and in iterators and it

00:15:49,400 --> 00:15:53,930
doesn't need to be modified at all so

00:15:52,340 --> 00:15:57,260
what I have here is an example where

00:15:53,930 --> 00:16:00,860
boost flatmap which is not range if I'd

00:15:57,260 --> 00:16:03,080
in anyway I construct the flat map I put

00:16:00,860 --> 00:16:06,050
a couple of elements in it and as you

00:16:03,080 --> 00:16:09,080
see here in the for loop I get out the

00:16:06,050 --> 00:16:11,210
key and the value by calling the singing

00:16:09,080 --> 00:16:15,140
reverse whew I've wrapped reversed view

00:16:11,210 --> 00:16:17,330
around the flat map instance and then

00:16:15,140 --> 00:16:20,720
iterate over it and print out the key

00:16:17,330 --> 00:16:23,840
and the value so that's one of the most

00:16:20,720 --> 00:16:27,680
powerful and amazing things is that

00:16:23,840 --> 00:16:30,050
we're actually extending all of the

00:16:27,680 --> 00:16:31,550
libraries that we already have that

00:16:30,050 --> 00:16:33,910
follow the conventions that we've had

00:16:31,550 --> 00:16:33,910
all along

00:16:36,850 --> 00:16:43,610
so the range algorithms as mentioned are

00:16:39,680 --> 00:16:45,500
very much like the STL algorithms and if

00:16:43,610 --> 00:16:47,570
you think deeply about algorithms for a

00:16:45,500 --> 00:16:50,120
minute you'll realize that one of the

00:16:47,570 --> 00:16:51,560
properties of these algorithms is that

00:16:50,120 --> 00:16:55,070
when you call them they execute

00:16:51,560 --> 00:16:57,430
immediately there's no waiting they

00:16:55,070 --> 00:17:00,500
execute exactly when they're called and

00:16:57,430 --> 00:17:02,150
internal to the algorithm itself is

00:17:00,500 --> 00:17:05,449
where the iteration is called and

00:17:02,150 --> 00:17:09,319
controlled so once you give up to the

00:17:05,449 --> 00:17:12,050
algorithm it does its work and you can

00:17:09,319 --> 00:17:13,310
you can see it and as mentioned these

00:17:12,050 --> 00:17:16,970
are not always a drop-in replacement

00:17:13,310 --> 00:17:20,949
although what you'll see is that you can

00:17:16,970 --> 00:17:23,770
actually use iterators in most cases

00:17:20,949 --> 00:17:26,839
just the same way as you had in the past

00:17:23,770 --> 00:17:36,320
with the STL in the ranges version of

00:17:26,839 --> 00:17:41,830
them okay so the views besides being

00:17:36,320 --> 00:17:44,150
lazy importantly do not own elements

00:17:41,830 --> 00:17:48,140
which is the primary reason that

00:17:44,150 --> 00:17:50,330
collections are not views and the

00:17:48,140 --> 00:17:52,160
important property here is that views

00:17:50,330 --> 00:17:53,870
are meant to be order one copying

00:17:52,160 --> 00:17:57,400
assignable so that means you can move

00:17:53,870 --> 00:17:59,389
them around in memory very quickly and

00:17:57,400 --> 00:18:01,729
it means that you can

00:17:59,389 --> 00:18:04,820
by value you can pass them between

00:18:01,729 --> 00:18:07,879
processing phases and steps at very low

00:18:04,820 --> 00:18:11,869
cost and this is also the thing that

00:18:07,879 --> 00:18:13,929
allows some of the infinite ranges but

00:18:11,869 --> 00:18:16,669
the important thing here is actually

00:18:13,929 --> 00:18:18,769
you'll notice about the views is that

00:18:16,669 --> 00:18:20,629
the iteration is no longer controlled by

00:18:18,769 --> 00:18:24,349
the view that's what the laziness really

00:18:20,629 --> 00:18:26,179
means it really just means that you the

00:18:24,349 --> 00:18:28,700
programmer will control the iteration

00:18:26,179 --> 00:18:33,679
over the view instead of having the

00:18:28,700 --> 00:18:36,320
algorithm do it for you and then finally

00:18:33,679 --> 00:18:40,070
as mentioned we have a lot of cases

00:18:36,320 --> 00:18:42,349
where we want to transport a regular

00:18:40,070 --> 00:18:44,629
range like a collection into a view

00:18:42,349 --> 00:18:47,690
itself and we can use range adapters to

00:18:44,629 --> 00:18:50,749
do that and the range adapters also give

00:18:47,690 --> 00:18:53,869
us one other important facility they

00:18:50,749 --> 00:18:57,229
allow us to create a piping syntax that

00:18:53,869 --> 00:19:00,829
is analogous in some ways to what you

00:18:57,229 --> 00:19:03,619
might see in UNIX piping it's not

00:19:00,829 --> 00:19:07,279
exactly the same but the analogy is

00:19:03,619 --> 00:19:11,869
though and it's mentioned these are

00:19:07,279 --> 00:19:14,149
declared in ranges views okay so let's

00:19:11,869 --> 00:19:17,269
look at some more examples so this one

00:19:14,149 --> 00:19:20,749
comes from CMC SDL - I could have used

00:19:17,269 --> 00:19:22,999
any of the other ones as well so I have

00:19:20,749 --> 00:19:27,049
a standard vector I have a predicate

00:19:22,999 --> 00:19:30,079
that checks if the values are even in

00:19:27,049 --> 00:19:33,079
this case I construct the view called

00:19:30,079 --> 00:19:35,239
evens and you'll note I pass in the

00:19:33,079 --> 00:19:36,919
vector to the constructor with the

00:19:35,239 --> 00:19:39,639
predicate and at the point of

00:19:36,919 --> 00:19:44,719
construction no computation is occurring

00:19:39,639 --> 00:19:48,349
okay it's only constructing the object

00:19:44,719 --> 00:19:50,629
itself and I have to iterate over it so

00:19:48,349 --> 00:19:54,079
here's the for loop it's a range for

00:19:50,629 --> 00:19:56,570
loop I get the error I get the integers

00:19:54,079 --> 00:19:59,419
back out and print them pretty

00:19:56,570 --> 00:20:04,519
straightforward extremely elegant piece

00:19:59,419 --> 00:20:08,629
of code so I can write this a different

00:20:04,519 --> 00:20:11,359
way I have the same vector here and I

00:20:08,629 --> 00:20:13,009
have the same is even predicated in this

00:20:11,359 --> 00:20:13,340
case I don't construct it on the stack

00:20:13,009 --> 00:20:16,310
at

00:20:13,340 --> 00:20:19,940
I just make it the expression to the

00:20:16,310 --> 00:20:26,480
for-loop itself and that's a very nice

00:20:19,940 --> 00:20:30,920
way to write the same code and now I can

00:20:26,480 --> 00:20:31,760
use an adapter so if you were paying

00:20:30,920 --> 00:20:38,030
close attention

00:20:31,760 --> 00:20:39,440
oops not that not that error sorry if

00:20:38,030 --> 00:20:41,810
you were playing close attention to this

00:20:39,440 --> 00:20:46,040
you would have noted its ranges : :

00:20:41,810 --> 00:20:48,230
filter view so the underscore view is

00:20:46,040 --> 00:20:52,340
attached to the name there but here

00:20:48,230 --> 00:20:55,670
you'll see I have a pipeline and I have

00:20:52,340 --> 00:20:58,880
ranges calling : views filter so in this

00:20:55,670 --> 00:21:01,520
case I'm actually using an adapter to

00:20:58,880 --> 00:21:05,180
create the view in conjunction with the

00:21:01,520 --> 00:21:09,230
vector itself and this code operates

00:21:05,180 --> 00:21:14,050
exactly the same as the prior so what if

00:21:09,230 --> 00:21:14,050
I had to write this with an algorithm

00:21:14,140 --> 00:21:18,920
more than likely I would have ended up

00:21:16,220 --> 00:21:21,110
doing something like this with 4 eh and

00:21:18,920 --> 00:21:25,790
I would have probably combined the

00:21:21,110 --> 00:21:30,230
predicate and the printing which really

00:21:25,790 --> 00:21:32,060
makes my code less modular but one of

00:21:30,230 --> 00:21:35,810
the things you're going to see here is

00:21:32,060 --> 00:21:37,850
that these are very composable so the

00:21:35,810 --> 00:21:40,430
views are composable and the adapters

00:21:37,850 --> 00:21:47,540
are composable whereas the algorithms

00:21:40,430 --> 00:21:50,840
were never terribly composable ok so I

00:21:47,540 --> 00:21:52,790
think we've already said all this but

00:21:50,840 --> 00:21:57,200
this is what's in the standard and I

00:21:52,790 --> 00:22:01,250
thought it was particularly clear views

00:21:57,200 --> 00:22:06,010
are ranges but they're special kind of

00:22:01,250 --> 00:22:10,810
range so you can go reread that later on

00:22:06,010 --> 00:22:10,810
okay loops

00:22:10,909 --> 00:22:17,070
all right let's do another poll of the

00:22:14,340 --> 00:22:22,799
audience who doesn't write any for loops

00:22:17,070 --> 00:22:26,610
in their code oh my that was the null

00:22:22,799 --> 00:22:27,960
set okay so I guess I won't get in too

00:22:26,610 --> 00:22:31,200
much trouble even though I'm not

00:22:27,960 --> 00:22:33,840
following Sean parents guidelines so but

00:22:31,200 --> 00:22:38,460
you know I guess this is a question

00:22:33,840 --> 00:22:40,230
right here we have the range for loop

00:22:38,460 --> 00:22:43,080
which was really made for ranges

00:22:40,230 --> 00:22:45,450
actually it was an earlier proposal and

00:22:43,080 --> 00:22:47,870
it happened in C++ 17 when ranges were

00:22:45,450 --> 00:22:52,919
already in the pipeline to be coming and

00:22:47,870 --> 00:22:55,799
yet again in C++ 20 the range for loop

00:22:52,919 --> 00:22:59,070
is being improved so that first part

00:22:55,799 --> 00:23:02,549
that an it statement optional is very

00:22:59,070 --> 00:23:05,880
much like the if optional in its

00:23:02,549 --> 00:23:08,250
statement in C++ 17 and it's an

00:23:05,880 --> 00:23:12,299
enhancement so has the committee really

00:23:08,250 --> 00:23:13,980
gone crazy you know they decided they

00:23:12,299 --> 00:23:16,110
are never going to listen to Sean parent

00:23:13,980 --> 00:23:17,880
well I think from a practical point of

00:23:16,110 --> 00:23:23,279
view people are going to write for loops

00:23:17,880 --> 00:23:25,529
and it's an improvement to have

00:23:23,279 --> 00:23:29,100
additional facilities to write them well

00:23:25,529 --> 00:23:32,070
and I think I'm going to argue that in a

00:23:29,100 --> 00:23:37,380
lot of cases with range code the for

00:23:32,070 --> 00:23:40,080
loop is not really so bad but let's say

00:23:37,380 --> 00:23:44,520
that we do want to follow the advice we

00:23:40,080 --> 00:23:47,220
can solve that problem there's nothing

00:23:44,520 --> 00:23:50,549
that says that you cannot use algorithms

00:23:47,220 --> 00:23:53,220
and views together you absolutely can

00:23:50,549 --> 00:23:57,149
use them together so in this case I have

00:23:53,220 --> 00:24:00,690
a print lambda I have my predicate for

00:23:57,149 --> 00:24:06,020
is even my vector again and in this case

00:24:00,690 --> 00:24:09,149
I've created a view called drop while

00:24:06,020 --> 00:24:13,309
using an adapter and it takes the

00:24:09,149 --> 00:24:16,380
predicate and I use the for each

00:24:13,309 --> 00:24:18,870
algorithm to iterate and make the

00:24:16,380 --> 00:24:21,899
iteration happen and I pass the print in

00:24:18,870 --> 00:24:24,450
so you can adhere to the guideline of no

00:24:21,899 --> 00:24:28,679
raw loops if you want to

00:24:24,450 --> 00:24:31,799
I think it's also the case it would be

00:24:28,679 --> 00:24:34,049
fair to say that you'll see in the wild

00:24:31,799 --> 00:24:36,960
when you start looking at range examples

00:24:34,049 --> 00:24:39,539
this isn't uncommon that something like

00:24:36,960 --> 00:24:45,989
a for each and an algorithm would be

00:24:39,539 --> 00:24:50,450
paired together with a view okay so

00:24:45,989 --> 00:24:50,450
let's talk a little bit more in detail

00:24:50,720 --> 00:24:58,109
so we've already said that some of them

00:24:53,580 --> 00:25:01,679
are better so there's the rough cheat

00:24:58,109 --> 00:25:07,429
sheet I'm not sure that's quite on the

00:25:01,679 --> 00:25:11,039
screen it's a lot of a lot of algorithms

00:25:07,429 --> 00:25:15,539
but it's not all of the algorithms that

00:25:11,039 --> 00:25:18,629
you have today in the STL particularly

00:25:15,539 --> 00:25:20,669
missing are things like accumulate and

00:25:18,629 --> 00:25:25,070
some of the numeric related algorithms

00:25:20,669 --> 00:25:28,590
and if you're interested in that subject

00:25:25,070 --> 00:25:30,480
having range algorithms for those kinds

00:25:28,590 --> 00:25:32,909
of things please see myself for

00:25:30,480 --> 00:25:35,100
christabella afterwards who's also

00:25:32,909 --> 00:25:42,539
sitting up here in the front row because

00:25:35,100 --> 00:25:48,539
he's working on that topic for C++ 23 so

00:25:42,539 --> 00:25:52,169
should we go through all of these is

00:25:48,539 --> 00:25:56,159
this to be the Jonathan Becerra 105

00:25:52,169 --> 00:25:58,470
algorithms and no I don't think so

00:25:56,159 --> 00:26:00,720
but let's look at a couple more and

00:25:58,470 --> 00:26:03,539
again I think there's nothing mysterious

00:26:00,720 --> 00:26:04,889
about this at all these are easy to

00:26:03,539 --> 00:26:06,659
understand

00:26:04,889 --> 00:26:09,899
the four-h we've already seen in the

00:26:06,659 --> 00:26:12,359
example of the count on the second line

00:26:09,899 --> 00:26:14,279
is an example again all you're really

00:26:12,359 --> 00:26:17,220
losing there's the beginning and on the

00:26:14,279 --> 00:26:19,799
count algorithm is sorted as another

00:26:17,220 --> 00:26:22,559
standard algorithm today and again the

00:26:19,799 --> 00:26:25,220
only difference is you're losing the

00:26:22,559 --> 00:26:25,220
began in the end

00:26:27,920 --> 00:26:37,570
oh and this example which I forgot to

00:26:33,560 --> 00:26:42,350
fix but in any case so here's a min/max

00:26:37,570 --> 00:26:45,860
example so in the first part I'm finding

00:26:42,350 --> 00:26:48,860
the iterator to the main element so

00:26:45,860 --> 00:26:50,900
again what we're seeing here is that all

00:26:48,860 --> 00:26:54,260
of the iterators do not disappear with

00:26:50,900 --> 00:26:57,290
the algorithms because several of the

00:26:54,260 --> 00:26:58,790
algorithms will return an iterator and

00:26:57,290 --> 00:27:00,490
of course you'll need to check against

00:26:58,790 --> 00:27:02,570
the end before you dereference and

00:27:00,490 --> 00:27:06,890
that's what the problem with the min/max

00:27:02,570 --> 00:27:10,730
is probably should have in checking that

00:27:06,890 --> 00:27:15,350
before printing them out okay let's look

00:27:10,730 --> 00:27:17,150
at another one copy it again very much

00:27:15,350 --> 00:27:19,760
the same as the standard algorithm today

00:27:17,150 --> 00:27:23,180
you have a copy if you pass it the

00:27:19,760 --> 00:27:25,250
vector that's the range that it gets and

00:27:23,180 --> 00:27:27,260
then you use the range back in server so

00:27:25,250 --> 00:27:30,770
the theme that you're seeing here is

00:27:27,260 --> 00:27:33,140
that the things that you've seen in STL

00:27:30,770 --> 00:27:37,370
for 20 years are still there they're in

00:27:33,140 --> 00:27:41,960
a new namespace but they operate very

00:27:37,370 --> 00:27:44,600
much the same and once again here we're

00:27:41,960 --> 00:27:48,080
doing a copy into the V underscore or

00:27:44,600 --> 00:27:50,230
cpy vector and then we're printing it

00:27:48,080 --> 00:27:50,230
out

00:27:54,920 --> 00:28:01,130
so I already showed you one sort at the

00:27:57,470 --> 00:28:04,880
beginning here's another sort and like

00:28:01,130 --> 00:28:08,750
the STL algorithms there's a lot more

00:28:04,880 --> 00:28:12,170
overloads than I'm showing you and I'm

00:28:08,750 --> 00:28:15,140
actually not going to show you all of

00:28:12,170 --> 00:28:17,860
the overloads there are extensive but in

00:28:15,140 --> 00:28:20,390
the second example there with the deck

00:28:17,860 --> 00:28:23,990
what's going on is I've created a

00:28:20,390 --> 00:28:24,950
function reverse compare and when I'm

00:28:23,990 --> 00:28:27,260
calling the sort

00:28:24,950 --> 00:28:30,560
I'll have it compare in the reverse

00:28:27,260 --> 00:28:36,350
order and I'll end up sorted backwards

00:28:30,560 --> 00:28:40,460
in that particular case and now I have

00:28:36,350 --> 00:28:53,870
to say that I lied does any anybody see

00:28:40,460 --> 00:29:00,320
a problem here not the front row I can't

00:28:53,870 --> 00:29:02,900
hear you so the problem is that list is

00:29:00,320 --> 00:29:06,170
not sortable right because it doesn't

00:29:02,900 --> 00:29:12,050
meet it doesn't meet the requirements of

00:29:06,170 --> 00:29:14,030
the of the algorithm right so if you've

00:29:12,050 --> 00:29:16,640
ever tried to sort standard list in the

00:29:14,030 --> 00:29:19,280
STL you'll you'll get an error and so

00:29:16,640 --> 00:29:20,870
what I told you is I wouldn't show you

00:29:19,280 --> 00:29:21,890
something that didn't compile but I just

00:29:20,870 --> 00:29:25,310
showed you something that actually

00:29:21,890 --> 00:29:26,870
doesn't compile and I mention it in part

00:29:25,310 --> 00:29:29,990
because one of the things that I think

00:29:26,870 --> 00:29:33,380
should happen and I should have actually

00:29:29,990 --> 00:29:35,300
done this but the problem is and we

00:29:33,380 --> 00:29:38,390
don't really have a fully concept af--

00:29:35,300 --> 00:29:41,540
ID compiler at this point but we should

00:29:38,390 --> 00:29:43,790
get a nicer air out of that sort that

00:29:41,540 --> 00:29:45,800
tells us something about you know the

00:29:43,790 --> 00:29:49,160
list does not meet the requirements of

00:29:45,800 --> 00:29:52,070
the algorithm instead of you know

00:29:49,160 --> 00:29:58,240
horrible failure that has a hundred

00:29:52,070 --> 00:29:58,240
pages of error message okay

00:29:59,700 --> 00:30:06,790
so we're still talking about algorithms

00:30:03,750 --> 00:30:09,250
and one of the interesting things that's

00:30:06,790 --> 00:30:11,140
been added to many of the algorithms in

00:30:09,250 --> 00:30:15,100
the ranges library as projection

00:30:11,140 --> 00:30:19,480
parameters so projections give you a

00:30:15,100 --> 00:30:21,490
first-class way of getting at the object

00:30:19,480 --> 00:30:26,110
before it's sent to the predicate for

00:30:21,490 --> 00:30:29,230
example in in something like a for each

00:30:26,110 --> 00:30:33,070
algorithm so this really started with

00:30:29,230 --> 00:30:35,679
the Adobe source libraries the ASL so if

00:30:33,070 --> 00:30:38,770
you shop sasch on parents talk earlier

00:30:35,679 --> 00:30:43,270
he was involved in the creation of a bat

00:30:38,770 --> 00:30:46,150
and this concept has been around but it

00:30:43,270 --> 00:30:49,120
couldn't really go into the STL as it

00:30:46,150 --> 00:30:51,520
stood because it would be a breaking

00:30:49,120 --> 00:30:55,090
change in many cases so here's an

00:30:51,520 --> 00:30:58,480
example of how it looks let's say that

00:30:55,090 --> 00:31:02,710
we have a structure like stuff and what

00:30:58,480 --> 00:31:06,340
we really want to do is we want to sort

00:31:02,710 --> 00:31:08,620
it only by the ID X we don't really want

00:31:06,340 --> 00:31:10,299
to use both so one of the problems you

00:31:08,620 --> 00:31:12,820
can see when you get into something like

00:31:10,299 --> 00:31:16,150
aggregate types is you really only get

00:31:12,820 --> 00:31:18,400
one opportunity to write the equal less

00:31:16,150 --> 00:31:22,480
and so forth but you might want to sort

00:31:18,400 --> 00:31:24,280
in many different ways now I've shown it

00:31:22,480 --> 00:31:25,929
here where I have a little lambda that's

00:31:24,280 --> 00:31:28,900
the projection parameter that's the

00:31:25,929 --> 00:31:31,660
third parameter to the sort and it's

00:31:28,900 --> 00:31:33,700
just simply returning the ID x value but

00:31:31,660 --> 00:31:35,890
you could call a member function and do

00:31:33,700 --> 00:31:38,559
other things that would return the value

00:31:35,890 --> 00:31:40,990
that you actually want to sort on and so

00:31:38,559 --> 00:31:43,960
in that case you can get different sort

00:31:40,990 --> 00:31:45,690
behaviors for the same type and you

00:31:43,960 --> 00:31:49,390
don't actually have to write your own

00:31:45,690 --> 00:31:56,890
less or your own comparison operations

00:31:49,390 --> 00:32:00,860
in those cases okay

00:31:56,890 --> 00:32:08,030
is everyone still here has everyone had

00:32:00,860 --> 00:32:12,580
enough coffee to be awake alright so

00:32:08,030 --> 00:32:14,870
let's talk about views in some detail so

00:32:12,580 --> 00:32:19,000
I'm gonna spend the rest of the talk

00:32:14,870 --> 00:32:21,500
mostly on views and view adapters

00:32:19,000 --> 00:32:24,830
because as mentioned before I think this

00:32:21,500 --> 00:32:30,170
is where you're going to get the most

00:32:24,830 --> 00:32:32,420
benefit so before I was showing you

00:32:30,170 --> 00:32:39,380
different ways that you can actually

00:32:32,420 --> 00:32:41,960
write adapters and write code and I was

00:32:39,380 --> 00:32:44,180
showing you the pipe operator versus

00:32:41,960 --> 00:32:47,000
construction and so forth so if you dig

00:32:44,180 --> 00:32:50,510
into the standard you'll see this little

00:32:47,000 --> 00:32:52,940
bit of this little bit of information it

00:32:50,510 --> 00:32:55,430
says an adapter constructed from a range

00:32:52,940 --> 00:32:59,150
and a list of arguments is equivalent to

00:32:55,430 --> 00:33:02,870
an adapter with a set of arguments and a

00:32:59,150 --> 00:33:04,850
range or a range pipe to an adapter with

00:33:02,870 --> 00:33:07,210
a set of arguments those are all

00:33:04,850 --> 00:33:10,310
equivalent ways to write the same code

00:33:07,210 --> 00:33:15,020
and I have to say the first time I

00:33:10,310 --> 00:33:19,820
encountered ranges this went completely

00:33:15,020 --> 00:33:22,060
over my head I had no idea so let's look

00:33:19,820 --> 00:33:26,810
at it a little bit more complicated case

00:33:22,060 --> 00:33:30,950
so I have the vector a vinta ghin and i

00:33:26,810 --> 00:33:32,720
have a predicate called even and then a

00:33:30,950 --> 00:33:37,340
lambda that will actually square the

00:33:32,720 --> 00:33:41,900
value of the input and so in the top

00:33:37,340 --> 00:33:45,380
loop here we have a 4 and we have the

00:33:41,900 --> 00:33:49,190
vector event pipe to an adapter for the

00:33:45,380 --> 00:33:52,310
filter of even and then transform of

00:33:49,190 --> 00:33:54,410
square so everyone knows what that code

00:33:52,310 --> 00:33:57,290
does right it's very easy to understand

00:33:54,410 --> 00:34:01,190
what it does so it actually does exactly

00:33:57,290 --> 00:34:02,870
what you think you know it goes through

00:34:01,190 --> 00:34:06,020
and for all the even values that squares

00:34:02,870 --> 00:34:07,580
them announce outputs them and we're

00:34:06,020 --> 00:34:09,459
gonna actually trace through that

00:34:07,580 --> 00:34:12,589
example in a second

00:34:09,459 --> 00:34:15,199
just to see what's really going on under

00:34:12,589 --> 00:34:16,819
that piping operator so that you can

00:34:15,199 --> 00:34:20,690
feel comfortable that it's doing what

00:34:16,819 --> 00:34:23,149
you expect but if you want to convince

00:34:20,690 --> 00:34:24,559
yourself that the two things from the

00:34:23,149 --> 00:34:28,279
last side or at least some of the things

00:34:24,559 --> 00:34:31,669
from last slide are the case you can do

00:34:28,279 --> 00:34:33,049
this if range is equal blow and if

00:34:31,669 --> 00:34:35,329
you'll note the first parameter to the

00:34:33,049 --> 00:34:39,859
range is equal is the vector event piped

00:34:35,329 --> 00:34:42,979
to the filter and the second is the

00:34:39,859 --> 00:34:54,769
filter constructed with the vector event

00:34:42,979 --> 00:34:58,880
and the even coops so it's this in code

00:34:54,769 --> 00:35:02,059
and indeed if you run this code you will

00:34:58,880 --> 00:35:05,630
find out that the two views that are

00:35:02,059 --> 00:35:08,119
created by the pipe operator versus the

00:35:05,630 --> 00:35:09,680
construction are exactly the same so

00:35:08,119 --> 00:35:11,900
it's two different ways to write that

00:35:09,680 --> 00:35:14,539
exact same code and this is one of the

00:35:11,900 --> 00:35:16,190
flexibilities that the range library is

00:35:14,539 --> 00:35:21,519
going to give you there's multiple ways

00:35:16,190 --> 00:35:21,519
to express what you're attempting to do

00:35:22,479 --> 00:35:31,309
all right so there are no free

00:35:26,839 --> 00:35:34,999
abstractions right so the first thing I

00:35:31,309 --> 00:35:39,979
want to know is yeah sure what's

00:35:34,999 --> 00:35:48,039
actually happening how many times are we

00:35:39,979 --> 00:35:50,680
actually calling transform any guesses

00:35:48,039 --> 00:35:56,329
yeah

00:35:50,680 --> 00:35:57,829
shout it three correct so this does

00:35:56,329 --> 00:36:01,519
exactly what you do so I've annotated

00:35:57,829 --> 00:36:04,069
the lambdas to print out either

00:36:01,519 --> 00:36:06,140
evie when it's an even or square and if

00:36:04,069 --> 00:36:11,209
you run this program what you'll see is

00:36:06,140 --> 00:36:14,089
exactly what you expect even is called

00:36:11,209 --> 00:36:16,519
six times square is called three times

00:36:14,089 --> 00:36:18,759
and you drop into the for loop exactly

00:36:16,519 --> 00:36:18,759
three times

00:36:23,030 --> 00:36:32,730
now I will tell you this is not always

00:36:26,970 --> 00:36:35,340
the case if you remember the views have

00:36:32,730 --> 00:36:37,410
these properties of being copied to

00:36:35,340 --> 00:36:40,680
cheat cheap to copy and so forth in

00:36:37,410 --> 00:36:43,980
general views do not cache

00:36:40,680 --> 00:36:45,990
so there are circumstances where you may

00:36:43,980 --> 00:36:48,810
be surprised by how many times something

00:36:45,990 --> 00:36:51,900
executes in a pipeline because there is

00:36:48,810 --> 00:36:55,080
no caching going on in this particular

00:36:51,900 --> 00:36:57,690
simple case it works so now what would

00:36:55,080 --> 00:37:01,950
happen if I took this same bit of code

00:36:57,690 --> 00:37:03,420
and I put the transform first well the

00:37:01,950 --> 00:37:05,190
obvious thing would happen we would call

00:37:03,420 --> 00:37:16,950
transform a bunch of times that we don't

00:37:05,190 --> 00:37:20,700
need to ok so now I want to look even

00:37:16,950 --> 00:37:24,630
further under the hood and to do that I

00:37:20,700 --> 00:37:26,280
have to get a little bit clever I'm sure

00:37:24,630 --> 00:37:29,880
somebody's showed this at this

00:37:26,280 --> 00:37:31,970
conference this is a function which

00:37:29,880 --> 00:37:35,940
allows you to print out the type of

00:37:31,970 --> 00:37:37,800
something in your program this

00:37:35,940 --> 00:37:39,510
particular version of this thing is is

00:37:37,800 --> 00:37:41,850
GCC specific there's a stack overflow

00:37:39,510 --> 00:37:46,260
link there if you want to find out how

00:37:41,850 --> 00:37:49,800
to do this but it's nifty so the

00:37:46,260 --> 00:37:52,230
question is what is all this machinery

00:37:49,800 --> 00:37:55,650
actually generating in terms of types in

00:37:52,230 --> 00:37:57,690
my program so in this particular case I

00:37:55,650 --> 00:38:00,780
have the vector event or vector of

00:37:57,690 --> 00:38:02,640
strings sorry at the top and I use the

00:38:00,780 --> 00:38:05,180
type name thing I just showed you with

00:38:02,640 --> 00:38:09,240
deckle type of the vector of string and

00:38:05,180 --> 00:38:11,450
it prints out in simplified form I

00:38:09,240 --> 00:38:14,070
simplified it a little bit for the slide

00:38:11,450 --> 00:38:19,740
exactly what you expect vector or string

00:38:14,070 --> 00:38:22,980
of charm so next when I drop a joint

00:38:19,740 --> 00:38:26,760
view around it and I get the type name

00:38:22,980 --> 00:38:29,430
of it what do I get I get join view of

00:38:26,760 --> 00:38:31,920
ref view of vector a basic string of

00:38:29,430 --> 00:38:32,369
chakra interesting weird that ref you

00:38:31,920 --> 00:38:35,729
thing

00:38:32,369 --> 00:38:39,329
from so the ref view is part of the

00:38:35,729 --> 00:38:41,700
machinery of the library and it's part

00:38:39,329 --> 00:38:45,719
of what gets wrapped around and then

00:38:41,700 --> 00:38:47,759
you'll see below with take view once

00:38:45,719 --> 00:38:50,779
again I've wrapped that around the join

00:38:47,759 --> 00:38:53,219
view and I'm building up a string of

00:38:50,779 --> 00:38:54,809
types that are wrapped around each other

00:38:53,219 --> 00:38:56,910
so what you're doing when you're

00:38:54,809 --> 00:39:00,599
chaining things together is you're

00:38:56,910 --> 00:39:03,150
actually building a type and that type

00:39:00,599 --> 00:39:09,359
knows how to execute the computation

00:39:03,150 --> 00:39:17,039
that you're trying to perform so it's

00:39:09,359 --> 00:39:19,619
clever okay any questions all right

00:39:17,039 --> 00:39:22,170
let's talk a little bit about a string

00:39:19,619 --> 00:39:23,400
view and span and then I'm going to show

00:39:22,170 --> 00:39:25,680
you the rest of the views that are gonna

00:39:23,400 --> 00:39:30,960
be in C++ 20 or a big chunk of them

00:39:25,680 --> 00:39:32,849
anyway and some examples so string vien

00:39:30,960 --> 00:39:35,190
and span aren't really technically part

00:39:32,849 --> 00:39:38,339
of the ranges proposal but they are

00:39:35,190 --> 00:39:40,979
range types in the sense that they're

00:39:38,339 --> 00:39:43,559
really there to interoperate and they

00:39:40,979 --> 00:39:45,839
satisfy a contiguous range concept which

00:39:43,559 --> 00:39:47,579
we didn't talk about the concepts but a

00:39:45,839 --> 00:39:50,160
contiguous range is exactly what you

00:39:47,579 --> 00:39:52,829
think it's laid out contiguously in

00:39:50,160 --> 00:39:57,299
memory so that allows you to have high

00:39:52,829 --> 00:40:00,989
performance for many operations so the

00:39:57,299 --> 00:40:03,539
string view of course is from C++ 17 it

00:40:00,989 --> 00:40:05,309
works with strings and I'm not really

00:40:03,539 --> 00:40:06,960
going to talk about it further other

00:40:05,309 --> 00:40:10,920
than to say that obviously it works

00:40:06,960 --> 00:40:15,749
perfectly with these perfectly it works

00:40:10,920 --> 00:40:18,539
well with views and and range algorithms

00:40:15,749 --> 00:40:23,009
in general but I will talk for a minute

00:40:18,539 --> 00:40:26,029
about span because it is new and span is

00:40:23,009 --> 00:40:30,319
a template in a new header called span

00:40:26,029 --> 00:40:35,069
and it takes a parameter T so it's a

00:40:30,319 --> 00:40:38,640
span of a certain type and again to be

00:40:35,069 --> 00:40:41,430
satisfying view type behavior it has to

00:40:38,640 --> 00:40:44,519
be cheap to copy so it's really a

00:40:41,430 --> 00:40:46,190
pointer in size to pointers and it has

00:40:44,519 --> 00:40:49,130
constant time complexity

00:40:46,190 --> 00:40:56,660
for all of its methods so not just copy

00:40:49,130 --> 00:40:59,000
and assign it's also able to run during

00:40:56,660 --> 00:41:03,490
compile time evaluation is context pert

00:40:59,000 --> 00:41:06,470
and it does actually allow you to modify

00:41:03,490 --> 00:41:07,970
types which is unique compared to most

00:41:06,470 --> 00:41:10,880
of the views I'm going to show you

00:41:07,970 --> 00:41:15,680
otherwise so here's how you can

00:41:10,880 --> 00:41:19,069
construct one a vector event again and I

00:41:15,680 --> 00:41:22,700
can construct a span of int from that

00:41:19,069 --> 00:41:26,990
vector that looks range like already in

00:41:22,700 --> 00:41:29,329
a way and then I have an array of five

00:41:26,990 --> 00:41:32,480
integers which I can wrap a span around

00:41:29,329 --> 00:41:34,789
and I also have a C array which is

00:41:32,480 --> 00:41:40,579
interesting which I can wrap a span

00:41:34,789 --> 00:41:43,450
around hmm so now I might be able to do

00:41:40,579 --> 00:41:46,579
something like this I can pass the span

00:41:43,450 --> 00:41:50,000
as a parameter to a function that I

00:41:46,579 --> 00:41:51,650
write called print reverse and that uses

00:41:50,000 --> 00:41:55,430
the reverse view which is one of the

00:41:51,650 --> 00:41:58,970
views in C++ 22 simply iterate over in

00:41:55,430 --> 00:42:01,099
reverse and print them out so in the

00:41:58,970 --> 00:42:02,900
first call here I pass the whole vector

00:42:01,099 --> 00:42:05,029
event you'll note I didn't construct a

00:42:02,900 --> 00:42:07,690
span anywhere that just constructed

00:42:05,029 --> 00:42:10,220
automatically for me

00:42:07,690 --> 00:42:13,670
so that's nice it was an implicit

00:42:10,220 --> 00:42:17,299
construction in the bottom two I'm using

00:42:13,670 --> 00:42:19,849
the first and the last two subsets the

00:42:17,299 --> 00:42:21,440
range of the vector itself so that's

00:42:19,849 --> 00:42:24,289
another reason why you might use a span

00:42:21,440 --> 00:42:26,150
you want to take part of it so the span

00:42:24,289 --> 00:42:28,789
has a lot of other collection like

00:42:26,150 --> 00:42:31,789
interfaces obviously to support ranges

00:42:28,789 --> 00:42:35,960
it has began an end but it has a number

00:42:31,789 --> 00:42:39,319
of other capabilities as well all right

00:42:35,960 --> 00:42:41,539
so that is a handy type that you might

00:42:39,319 --> 00:42:44,539
find one thing to be aware of of course

00:42:41,539 --> 00:42:46,670
is you're giving out a reference to your

00:42:44,539 --> 00:42:53,680
collection so make sure the lifetime of

00:42:46,670 --> 00:42:53,680
your collection is maintained okay

00:42:57,020 --> 00:43:03,900
so here's a cheat sheet these divisions

00:43:01,650 --> 00:43:08,520
by the way modifiers and sampling and

00:43:03,900 --> 00:43:10,039
whatever those are just my my idea you

00:43:08,520 --> 00:43:12,210
can decide whether you like them or not

00:43:10,039 --> 00:43:13,619
we're not going to quite go through all

00:43:12,210 --> 00:43:17,450
of them but we'll go through a few of

00:43:13,619 --> 00:43:21,990
them here's an example with IO to view

00:43:17,450 --> 00:43:23,730
just like the IO 2 algorithm in this

00:43:21,990 --> 00:43:27,510
case we've constructed it right in the

00:43:23,730 --> 00:43:31,789
in the expression and we get the open

00:43:27,510 --> 00:43:37,380
range from 1 to 5 which is 1 2 3 4

00:43:31,789 --> 00:43:40,730
here's take view so yes can you come up

00:43:37,380 --> 00:43:40,730
to the mic that's probably the best way

00:43:49,039 --> 00:44:08,339
yeah I mean that's it's a it's a range

00:43:56,010 --> 00:44:11,670
for loop no there's no yeah there's

00:44:08,339 --> 00:44:13,680
nothing different about the range for

00:44:11,670 --> 00:44:16,650
loop so the range for loop was actually

00:44:13,680 --> 00:44:19,470
introduced in C++ 17 and it has that

00:44:16,650 --> 00:44:21,930
colon syntax and you'll see in a lot of

00:44:19,470 --> 00:44:25,559
presentations you'll see stuff like auto

00:44:21,930 --> 00:44:29,579
ref ref you know as the supposed

00:44:25,559 --> 00:44:33,150
preferred way to access the values one

00:44:29,579 --> 00:44:34,980
at a time okay I think the main

00:44:33,150 --> 00:44:36,359
differentiator there right is that colon

00:44:34,980 --> 00:44:44,779
is the indicator to you that it's

00:44:36,359 --> 00:44:47,460
arranged for loop okay so take view and

00:44:44,779 --> 00:44:49,380
again a little variation on the

00:44:47,460 --> 00:44:51,510
construction but take view is

00:44:49,380 --> 00:44:55,170
essentially going to give you a finite

00:44:51,510 --> 00:44:56,609
number of elements from a range so in

00:44:55,170 --> 00:45:00,690
this case we're going to take two

00:44:56,609 --> 00:45:03,569
elements from the range and you can see

00:45:00,690 --> 00:45:05,150
you can also construct by an assignment

00:45:03,569 --> 00:45:07,740
that's another thing because remember

00:45:05,150 --> 00:45:10,710
assignment copy

00:45:07,740 --> 00:45:14,900
all of these things are cheap and then

00:45:10,710 --> 00:45:16,440
we can also say ranges take view ooh

00:45:14,900 --> 00:45:18,890
interesting

00:45:16,440 --> 00:45:21,180
right what happens if I specify

00:45:18,890 --> 00:45:23,730
something that's larger than the size of

00:45:21,180 --> 00:45:25,410
the range it turns out it actually does

00:45:23,730 --> 00:45:27,630
the right thing

00:45:25,410 --> 00:45:33,809
it will only iterate over the elements

00:45:27,630 --> 00:45:36,569
up to the point of the size so another

00:45:33,809 --> 00:45:40,550
new one is joint view this is a way to

00:45:36,569 --> 00:45:42,990
flatten things out so this one is very

00:45:40,550 --> 00:45:46,290
simple and straightforward I suppose

00:45:42,990 --> 00:45:48,540
what's interesting here and in probably

00:45:46,290 --> 00:45:50,579
the next one you're gonna see we're

00:45:48,540 --> 00:45:53,700
actually doing this at the character

00:45:50,579 --> 00:45:56,339
level and that has to do with the way

00:45:53,700 --> 00:45:58,430
that joined the flattened flattens

00:45:56,339 --> 00:46:01,319
things out

00:45:58,430 --> 00:46:04,079
there's transform view I already showed

00:46:01,319 --> 00:46:06,480
you one of these as well so again I'm

00:46:04,079 --> 00:46:10,290
just taking a landing and iterating

00:46:06,480 --> 00:46:12,059
through and again important point the

00:46:10,290 --> 00:46:14,579
underlying vector if I printed it out

00:46:12,059 --> 00:46:20,040
has not been modified or molested in any

00:46:14,579 --> 00:46:25,680
way here all right so let's combine a

00:46:20,040 --> 00:46:29,299
couple in a chain so I have my is even

00:46:25,680 --> 00:46:33,000
predicate I have a print and I have

00:46:29,299 --> 00:46:35,400
constructed from adapters this time

00:46:33,000 --> 00:46:39,180
right so after leading evens with a

00:46:35,400 --> 00:46:44,220
range view drop while that's an adapter

00:46:39,180 --> 00:46:47,640
and the take so if we went back a couple

00:46:44,220 --> 00:46:49,500
slides to the take you notice there's

00:46:47,640 --> 00:46:52,140
two constructor parameters in all of

00:46:49,500 --> 00:46:56,940
these cases right and again that's that

00:46:52,140 --> 00:46:59,250
I can construct a view several different

00:46:56,940 --> 00:47:03,210
ways in this case I'm constructing the

00:46:59,250 --> 00:47:06,089
actual view type directly and in this

00:47:03,210 --> 00:47:12,299
case we're actually using range adapters

00:47:06,089 --> 00:47:14,490
and it's the equivalent okay and this

00:47:12,299 --> 00:47:16,589
time I'm using the for each algorithm to

00:47:14,490 --> 00:47:19,730
print out three and four anybody know

00:47:16,589 --> 00:47:19,730
why it's just three and four

00:47:20,730 --> 00:47:27,220
and that's because drop while is going

00:47:25,180 --> 00:47:30,430
to just drop until the condition becomes

00:47:27,220 --> 00:47:33,040
true right so it's going to drop the six

00:47:30,430 --> 00:47:35,790
in the two because they're even and then

00:47:33,040 --> 00:47:40,140
it's going to print for two more and

00:47:35,790 --> 00:47:40,140
you'll get three and four out of that

00:47:42,930 --> 00:47:48,510
another one is a nice dream view so if

00:47:45,970 --> 00:47:52,750
we want to iterate over an input stream

00:47:48,510 --> 00:47:59,860
and in this case we're basically parsing

00:47:52,750 --> 00:48:03,390
intz out of this string empty view is a

00:47:59,860 --> 00:48:05,890
special case that you might use in

00:48:03,390 --> 00:48:09,040
development of your own functions and

00:48:05,890 --> 00:48:12,100
own views it would come in particularly

00:48:09,040 --> 00:48:16,360
handy in the case where you might have a

00:48:12,100 --> 00:48:18,910
branch of something that is reached a

00:48:16,360 --> 00:48:20,830
point where you have no useful results

00:48:18,910 --> 00:48:23,860
to return so you would return an empty

00:48:20,830 --> 00:48:26,410
view you know instead of something that

00:48:23,860 --> 00:48:29,170
actually has values in it and single

00:48:26,410 --> 00:48:33,490
view is a very similar kind of thing it

00:48:29,170 --> 00:48:35,550
has actually only a single value and it

00:48:33,490 --> 00:48:39,220
is a weird view in that it actually

00:48:35,550 --> 00:48:42,430
contains set value so it's the one view

00:48:39,220 --> 00:48:44,200
that's a little different but again you

00:48:42,430 --> 00:48:49,510
can see you just iterate normally and

00:48:44,200 --> 00:48:52,570
naturally and then there's split view so

00:48:49,510 --> 00:48:55,510
split view does the opposite it allows

00:48:52,570 --> 00:48:58,480
you to pull things apart so I have a

00:48:55,510 --> 00:49:02,400
string which of course is the canonical

00:48:58,480 --> 00:49:07,360
string for a programming conference and

00:49:02,400 --> 00:49:10,300
the split view with the value allows us

00:49:07,360 --> 00:49:13,240
to pull it apart now one of the

00:49:10,300 --> 00:49:14,650
interesting things here is what actually

00:49:13,240 --> 00:49:17,590
happens and I was showing you the

00:49:14,650 --> 00:49:19,630
chaining of types we don't actually get

00:49:17,590 --> 00:49:21,580
strings back out of this we actually

00:49:19,630 --> 00:49:25,620
have to drop down and get characters

00:49:21,580 --> 00:49:28,980
back out of this and that's a little bit

00:49:25,620 --> 00:49:28,980
interesting and surprising

00:49:31,390 --> 00:49:38,980
okay everything I'm about to tell you

00:49:35,540 --> 00:49:42,590
about performance is entirely anecdotal

00:49:38,980 --> 00:49:45,710
which is to say it's meaningless so take

00:49:42,590 --> 00:49:48,050
it from what it's worth so as I said

00:49:45,710 --> 00:49:51,410
we've been using range v3 in production

00:49:48,050 --> 00:49:53,150
for a couple of years now and our

00:49:51,410 --> 00:49:55,430
experiences that we mostly use range

00:49:53,150 --> 00:49:58,660
algorithms mostly because when we

00:49:55,430 --> 00:50:02,320
started we didn't know how to use views

00:49:58,660 --> 00:50:05,600
so we're gradually using more views

00:50:02,320 --> 00:50:10,600
we've seen no measurable difference in

00:50:05,600 --> 00:50:12,980
compile time performance but that's just

00:50:10,600 --> 00:50:16,370
us putting our finger in the wind and

00:50:12,980 --> 00:50:17,720
not noticing perhaps and one of the

00:50:16,370 --> 00:50:21,560
things that's here is and the current

00:50:17,720 --> 00:50:25,670
implementations almost all of them have

00:50:21,560 --> 00:50:29,450
to emulate concepts in some way which is

00:50:25,670 --> 00:50:31,280
a bit of nasty business with macros and

00:50:29,450 --> 00:50:36,200
other things that are not particularly

00:50:31,280 --> 00:50:38,980
fast at compile time so it is possible

00:50:36,200 --> 00:50:42,890
the current range heavy code would not

00:50:38,980 --> 00:50:44,660
compile particularly quickly but as I

00:50:42,890 --> 00:51:00,170
said at least in our case we haven't

00:50:44,660 --> 00:51:02,480
seen any real problem yes okay that's

00:51:00,170 --> 00:51:04,610
that's interesting and CMC STL 2 I

00:51:02,480 --> 00:51:10,670
believe has been doing that for a while

00:51:04,610 --> 00:51:12,760
sorry what 30% that was eric Niebuhr for

00:51:10,670 --> 00:51:17,390
the record thank you Eric

00:51:12,760 --> 00:51:19,940
ok but even with the old bad version it

00:51:17,390 --> 00:51:21,320
really isn't noticeable from a runtime

00:51:19,940 --> 00:51:23,030
point of view it's a similar kind of

00:51:21,320 --> 00:51:25,040
thing but our applications are limited

00:51:23,030 --> 00:51:28,310
we probably only deal with ranges of

00:51:25,040 --> 00:51:30,760
hundreds of thousands of things instead

00:51:28,310 --> 00:51:33,020
of millions of things in a typical day

00:51:30,760 --> 00:51:34,970
but I have a little bit of a theory

00:51:33,020 --> 00:51:37,580
about this and maybe Eric will confirm

00:51:34,970 --> 00:51:39,860
or deny but I think the range algorithms

00:51:37,580 --> 00:51:41,540
themselves are going to basically be the

00:51:39,860 --> 00:51:43,820
same as the STL although interestingly

00:51:41,540 --> 00:51:44,450
and De Beers presentation right before

00:51:43,820 --> 00:51:47,990
this

00:51:44,450 --> 00:51:50,000
he actually showed how the views were

00:51:47,990 --> 00:51:52,880
actually faster in a simple performance

00:51:50,000 --> 00:51:55,150
test but look we've been using things

00:51:52,880 --> 00:51:58,520
like boost range for a decade or more

00:51:55,150 --> 00:52:00,080
the straining algorithms and really what

00:51:58,520 --> 00:52:03,020
the algorithms are doing here is just

00:52:00,080 --> 00:52:05,710
pulling out the begin and end so there's

00:52:03,020 --> 00:52:09,110
really not a huge amount of difference

00:52:05,710 --> 00:52:11,840
conceptually there and maybe it's just

00:52:09,110 --> 00:52:14,390
possible that with writing views

00:52:11,840 --> 00:52:15,860
you're gonna avoid naive copies and

00:52:14,390 --> 00:52:19,370
other things that you might accidentally

00:52:15,860 --> 00:52:23,860
do with algorithms but we'll see how it

00:52:19,370 --> 00:52:25,820
goes okay so when these slides go up

00:52:23,860 --> 00:52:29,240
there should be a large number of

00:52:25,820 --> 00:52:31,910
resources for you here's the links to

00:52:29,240 --> 00:52:39,430
the implementations we've already talked

00:52:31,910 --> 00:52:43,610
about range v3 as of yesterday the

00:52:39,430 --> 00:52:47,660
examples have been making progress I

00:52:43,610 --> 00:52:50,660
know that the you know the group from

00:52:47,660 --> 00:52:52,940
Super Plus now library in a week we did

00:52:50,660 --> 00:52:55,100
end up contributing some and I can see

00:52:52,940 --> 00:52:58,870
that Eric or somebody else has done some

00:52:55,100 --> 00:53:02,420
more work on it recently I have a rather

00:52:58,870 --> 00:53:05,450
older thing not came from C++ now so we

00:53:02,420 --> 00:53:08,450
were doing range by example so there's a

00:53:05,450 --> 00:53:12,380
bunch of examples there those are not

00:53:08,450 --> 00:53:16,820
tuned down to the C++ 20 ranges but are

00:53:12,380 --> 00:53:19,250
against range v3 directly working drafts

00:53:16,820 --> 00:53:19,820
if you'd like you can read the 1 ranges

00:53:19,250 --> 00:53:25,090
paper

00:53:19,820 --> 00:53:28,850
it's 226 pages of scintillating material

00:53:25,090 --> 00:53:33,290
that no doubt will put you to sleep

00:53:28,850 --> 00:53:35,300
quickly but yeah and now probably the

00:53:33,290 --> 00:53:38,390
best thing to really read is the latest

00:53:35,300 --> 00:53:41,150
working draft you can go to that link

00:53:38,390 --> 00:53:43,940
and you can get a copy of it because

00:53:41,150 --> 00:53:47,540
additional algorithm since the one

00:53:43,940 --> 00:53:51,380
ranges proposal have gone in and here's

00:53:47,540 --> 00:53:54,380
some of the new ones now I will say I'm

00:53:51,380 --> 00:53:56,720
sure there are some fans of range v3

00:53:54,380 --> 00:53:58,340
that will be disappointed there's things

00:53:56,720 --> 00:54:01,760
like ranges too

00:53:58,340 --> 00:54:05,000
which did not get in to C++ 20 the

00:54:01,760 --> 00:54:08,810
ranges that should be really : : - that

00:54:05,000 --> 00:54:11,600
allows you to take the result of your

00:54:08,810 --> 00:54:16,100
range view and create a new collection

00:54:11,600 --> 00:54:18,230
from it projections on algorithms and a

00:54:16,100 --> 00:54:22,160
lot of this is you know going off the

00:54:18,230 --> 00:54:26,690
slide but you can go learn all the

00:54:22,160 --> 00:54:29,090
details about it the 2014 paper talks a

00:54:26,690 --> 00:54:30,890
lot about it there was a recent reddit

00:54:29,090 --> 00:54:34,550
conversation that I linked here and

00:54:30,890 --> 00:54:39,130
Shawn parents talks are always worth the

00:54:34,550 --> 00:54:41,950
time and then some more videos and blogs

00:54:39,130 --> 00:54:44,960
Chris who's just stood up a min ago

00:54:41,950 --> 00:54:46,730
wrote a nice blog post a while back and

00:54:44,960 --> 00:54:52,040
so forth and there's some links to the

00:54:46,730 --> 00:54:57,110
span resources and that's just about it

00:54:52,040 --> 00:55:00,500
so I think you know my reflection on

00:54:57,110 --> 00:55:04,250
this is that ranges is a key building

00:55:00,500 --> 00:55:06,650
block for the future and even if it was

00:55:04,250 --> 00:55:09,290
just getting rid of began an end we're

00:55:06,650 --> 00:55:13,880
gonna see a lot nicer cleaner more

00:55:09,290 --> 00:55:16,310
interesting code we didn't see all of

00:55:13,880 --> 00:55:19,220
range v3 which is a very large library

00:55:16,310 --> 00:55:23,710
make it into C++ 20 but I think we saw

00:55:19,220 --> 00:55:28,730
the core the kernel part that we need

00:55:23,710 --> 00:55:30,830
you know to move things forward so thank

00:55:28,730 --> 00:55:32,730
you we have some time for questions

00:55:30,830 --> 00:55:40,060
three minutes

00:55:32,730 --> 00:55:50,930
[Applause]

00:55:40,060 --> 00:55:55,070
Peter in the type system so far in

00:55:50,930 --> 00:55:59,530
hospice and my question is are the few

00:55:55,070 --> 00:56:02,360
adapters protecting against fine thing

00:55:59,530 --> 00:56:04,550
are protected against finding to a

00:56:02,360 --> 00:56:14,480
temporary because today it's very easy

00:56:04,550 --> 00:56:16,670
to create temporary containers what

00:56:14,480 --> 00:56:18,770
happens it's a good question

00:56:16,670 --> 00:56:20,420
I'm not a hundred percent sure of the

00:56:18,770 --> 00:56:26,800
answer but my guess is it's probably

00:56:20,420 --> 00:56:29,360
harder sorry what was that

00:56:26,800 --> 00:56:39,620
okay so as you can't form a view around

00:56:29,360 --> 00:56:42,950
an r-value so there you go yep changes

00:56:39,620 --> 00:56:50,450
for example I said take two and in my

00:56:42,950 --> 00:56:54,950
first print its invalidated the same as

00:56:50,450 --> 00:56:58,910
iteration it seems like there's been a

00:56:54,950 --> 00:57:03,440
lot of recent flak against ranges from

00:56:58,910 --> 00:57:05,270
the community you know similar to what

00:57:03,440 --> 00:57:10,120
happened when when a sting was

00:57:05,270 --> 00:57:14,540
introduced and drug do you feel that

00:57:10,120 --> 00:57:17,570
ranges are ready for primetime or is

00:57:14,540 --> 00:57:21,490
there still a lot of evolution that

00:57:17,570 --> 00:57:25,120
needs to happen for them to be useful

00:57:21,490 --> 00:57:30,320
yeah I've read some of those posts and

00:57:25,120 --> 00:57:33,890
my personal take on it is we're going to

00:57:30,320 --> 00:57:36,740
say oh you know let's let you know

00:57:33,890 --> 00:57:40,100
perfect be the enemy of the good

00:57:36,740 --> 00:57:43,070
and so yes I think ranges are totally

00:57:40,100 --> 00:57:46,580
ready for primetime a decade ago if we

00:57:43,070 --> 00:57:49,080
would have had Eric's library at ago but

00:57:46,580 --> 00:57:51,540
with concepts and

00:57:49,080 --> 00:57:53,190
you know with this initial set of

00:57:51,540 --> 00:57:53,970
libraries absolutely I think it's ready

00:57:53,190 --> 00:57:57,900
for primetime

00:57:53,970 --> 00:58:00,360
so I think those things are misguided in

00:57:57,900 --> 00:58:03,450
the sense that you're still able to go

00:58:00,360 --> 00:58:06,090
write your own range light library if

00:58:03,450 --> 00:58:08,670
you want to but in terms of being able

00:58:06,090 --> 00:58:12,119
to have standard algorithms evolve and

00:58:08,670 --> 00:58:13,490
have new views and other facilities in

00:58:12,119 --> 00:58:28,260
the language that we can build on

00:58:13,490 --> 00:58:43,530
absolutely it was ready yeah I don't

00:58:28,260 --> 00:58:47,610
think so right type of range I think you

00:58:43,530 --> 00:58:54,170
should ask Tristan or Eric because

00:58:47,610 --> 00:58:54,170
they're the implementers so I noticed

00:58:57,770 --> 00:59:07,740
yes do you do you know if there's

00:59:00,380 --> 00:59:10,080
intention to get ranges I do not know of

00:59:07,740 --> 00:59:13,470
any movement to do so other than maybe

00:59:10,080 --> 00:59:15,150
tackling one of these implementers and

00:59:13,470 --> 00:59:18,869
convincing them that it would be worth

00:59:15,150 --> 00:59:21,660
their time to do so or alternatively a

00:59:18,869 --> 00:59:25,980
group of motivated people going about

00:59:21,660 --> 00:59:28,980
and doing it so I can see that there

00:59:25,980 --> 00:59:32,630
will be you know a group of people that

00:59:28,980 --> 00:59:34,770
will want ranges maybe before C++ 20

00:59:32,630 --> 00:59:37,080
because they won't be able to upgrade to

00:59:34,770 --> 00:59:37,560
C++ 20 for a long extended period of

00:59:37,080 --> 00:59:41,910
time

00:59:37,560 --> 00:59:44,580
so that's I guess a new new thing for

00:59:41,910 --> 00:59:46,740
boost which is sort of supporting the

00:59:44,580 --> 00:59:47,760
legacy versions of things for a longer

00:59:46,740 --> 00:59:51,240
period of time

00:59:47,760 --> 00:59:54,210
so but I'm not aware of any movement to

00:59:51,240 --> 00:59:55,920
do so hopefully there will be one at

00:59:54,210 --> 00:59:59,700
some point by the way the other thing I

00:59:55,920 --> 01:00:02,130
think we absolutely need is we

00:59:59,700 --> 01:00:02,790
absolutely need you know some extensions

01:00:02,130 --> 01:00:06,600
to range

01:00:02,790 --> 01:00:08,850
that aren't in 20 and boost would be a

01:00:06,600 --> 01:00:11,490
wonderful place to have those as well

01:00:08,850 --> 01:00:14,190
because many of us do use boost and have

01:00:11,490 --> 01:00:18,960
it anyway so it makes it easier for us

01:00:14,190 --> 01:00:21,150
to get that so yeah okay I think we're

01:00:18,960 --> 01:00:22,890
out of time but we can keep going as

01:00:21,150 --> 01:00:26,250
long as the room is available so go

01:00:22,890 --> 01:00:28,950
ahead confuse be concatenated or

01:00:26,250 --> 01:00:30,960
appended to each other for example if

01:00:28,950 --> 01:00:33,360
you have a view that shows only numbers

01:00:30,960 --> 01:00:35,010
that are divisible by three and a

01:00:33,360 --> 01:00:37,770
different view that shows only numbers

01:00:35,010 --> 01:00:40,200
divisible by four and numbers that are

01:00:37,770 --> 01:00:42,510
divisible by five can you like

01:00:40,200 --> 01:00:44,700
concatenate all those to get one view

01:00:42,510 --> 01:00:48,060
that would then only show numbers that

01:00:44,700 --> 01:00:49,680
are divisible by 3 and by 4 at 5 I think

01:00:48,060 --> 01:00:53,340
you would use join view to do that

01:00:49,680 --> 01:00:55,930
probably join yeah ok

01:00:53,340 --> 01:01:01,020
all right thank you very much

01:00:55,930 --> 01:01:01,020

YouTube URL: https://www.youtube.com/watch?v=vJ290qlAbbw


