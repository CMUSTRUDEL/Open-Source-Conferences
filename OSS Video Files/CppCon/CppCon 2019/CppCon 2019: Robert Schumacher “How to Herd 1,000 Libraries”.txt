Title: CppCon 2019: Robert Schumacher “How to Herd 1,000 Libraries”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
In the current C++ world, it is a struggle to convince even a single external library to build and behave. Adding a third and fourth dependency causes quadratic grief as each library interacts with each other and One Definition Rule violations lurk around every corner.

How, then, is it possible to manage over 1,000?

In this talk, we'll talk about the techniques, shims, and hacks used in the Vcpkg package manager to persuade, connive, and coerce all these independent moving parts into a single robust ecosystem. We'll sample the myriad approaches used by real-world libraries to declare dependence and walk through how they can be guided to do the right thing at the end of the day.

Private package management systems still thrive in corporations and these approaches can provide method to the madness of consuming open source.
— 
Robert Schumacher
Software Developer, Microsoft
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,500 --> 00:00:14,670
good morning everyone so I'm Robert

00:00:13,110 --> 00:00:17,250
Schumacher I'm a developer at Microsoft

00:00:14,670 --> 00:00:18,420
working on VC package and today what I'm

00:00:17,250 --> 00:00:21,630
going to talk about is I'm going to talk

00:00:18,420 --> 00:00:23,970
about the things that we need to do to

00:00:21,630 --> 00:00:26,609
get over a thousand libraries to build

00:00:23,970 --> 00:00:29,760
consistently against each other in our

00:00:26,609 --> 00:00:33,239
catalog what I'm hoping that you'll be

00:00:29,760 --> 00:00:35,190
able to take from this is one you'll be

00:00:33,239 --> 00:00:37,320
able to gain an appreciation for how the

00:00:35,190 --> 00:00:40,440
sausage is made and you know how part of

00:00:37,320 --> 00:00:42,690
a life that I have but but also you'll

00:00:40,440 --> 00:00:45,239
be able to take this on and you'll be

00:00:42,690 --> 00:00:47,879
able to write better libraries that are

00:00:45,239 --> 00:00:50,790
easier to integrate into systems like

00:00:47,879 --> 00:00:52,290
this and if you manage a proprietary

00:00:50,790 --> 00:00:55,020
system like this inside of your company

00:00:52,290 --> 00:00:56,879
which is unfortunately still very common

00:00:55,020 --> 00:00:58,289
today then maybe some of these

00:00:56,879 --> 00:01:00,989
techniques will be of use to you

00:00:58,289 --> 00:01:04,759
to frame your thinking around how to

00:01:00,989 --> 00:01:07,200
work with those systems so I'm gonna go

00:01:04,759 --> 00:01:09,899
in three parts first we're going to talk

00:01:07,200 --> 00:01:13,290
about effectively what's the anatomy of

00:01:09,899 --> 00:01:15,920
getting a library a single library to

00:01:13,290 --> 00:01:18,360
build then we're gonna talk about some

00:01:15,920 --> 00:01:21,540
ecosystem aspects of it so when you

00:01:18,360 --> 00:01:23,460
scale out how do these things interplay

00:01:21,540 --> 00:01:25,680
with each other and what you need to do

00:01:23,460 --> 00:01:27,210
to make them all play nice and then

00:01:25,680 --> 00:01:29,009
we're going to kind of draw some

00:01:27,210 --> 00:01:31,200
conclusions at the very end so first

00:01:29,009 --> 00:01:32,580
walking through what it takes to build a

00:01:31,200 --> 00:01:34,619
single library so the first step of

00:01:32,580 --> 00:01:38,670
course is always acquiring the sources

00:01:34,619 --> 00:01:40,560
there's pretty much two generic ways to

00:01:38,670 --> 00:01:42,000
acquire sources there's get and then

00:01:40,560 --> 00:01:44,100
there's just doing a direct HTTP

00:01:42,000 --> 00:01:46,040
download of some kind of zip or tar.gz

00:01:44,100 --> 00:01:48,390
or what-have-you

00:01:46,040 --> 00:01:50,189
MVC package what we found is that doing

00:01:48,390 --> 00:01:52,909
that direct archive download is actually

00:01:50,189 --> 00:01:57,680
for the better so most get the most

00:01:52,909 --> 00:02:00,780
hosts such as github gitlab bit bucket

00:01:57,680 --> 00:02:02,430
fabricator used to have issues but I

00:02:00,780 --> 00:02:05,670
think that they fixed them they all

00:02:02,430 --> 00:02:07,200
provide direct tarballs of a particular

00:02:05,670 --> 00:02:09,269
commit what this means is that you can

00:02:07,200 --> 00:02:11,100
download just the code you need and you

00:02:09,269 --> 00:02:12,750
don't have to clone every mistake that

00:02:11,100 --> 00:02:15,090
was ever made in the entire repo right

00:02:12,750 --> 00:02:16,980
so that's pretty good so we tend to

00:02:15,090 --> 00:02:20,450
prefer direct archive downloads this

00:02:16,980 --> 00:02:22,140
also allows us to perform a very

00:02:20,450 --> 00:02:24,540
effective

00:02:22,140 --> 00:02:26,790
- it's a very straightforward system a

00:02:24,540 --> 00:02:28,440
very uniform system because some people

00:02:26,790 --> 00:02:31,040
are get some people are not get if we

00:02:28,440 --> 00:02:32,760
use these direct archived downloads then

00:02:31,040 --> 00:02:35,760
everything goes through the same system

00:02:32,760 --> 00:02:37,260
and we perform a 512 shell 5 roll hash

00:02:35,760 --> 00:02:38,520
check of that source code so we can

00:02:37,260 --> 00:02:40,310
guarantee that this is not going to

00:02:38,520 --> 00:02:42,420
change and that you get reproducibility

00:02:40,310 --> 00:02:46,310
reproducible builds day-in day-out

00:02:42,420 --> 00:02:49,709
tomorrow in the rain upside down etc

00:02:46,310 --> 00:02:52,410
unfortunately we already run into

00:02:49,709 --> 00:02:54,660
problems so the first problem is that

00:02:52,410 --> 00:02:55,980
some library authors change their tags

00:02:54,660 --> 00:02:59,400
after they publish them so they'll

00:02:55,980 --> 00:03:01,230
though you know they tag v 1.0 0.0 and

00:02:59,400 --> 00:03:04,620
they'll push that to github and that's

00:03:01,230 --> 00:03:07,980
great but then you know an hour a day

00:03:04,620 --> 00:03:10,050
goes by and they think oh there's an

00:03:07,980 --> 00:03:11,400
issue in that release customer just

00:03:10,050 --> 00:03:15,300
reported a bug there was a regression

00:03:11,400 --> 00:03:17,040
and well it's fine I'm just gonna I'm

00:03:15,300 --> 00:03:19,739
just gonna update the tag it'll be it'll

00:03:17,040 --> 00:03:21,720
be fine that's that's not okay

00:03:19,739 --> 00:03:24,330
right that's not okay for you as a

00:03:21,720 --> 00:03:26,280
consumer that's not okay for libraries

00:03:24,330 --> 00:03:29,190
to be silently updating out from

00:03:26,280 --> 00:03:31,440
underneath you so in VC package we have

00:03:29,190 --> 00:03:33,510
as I mentioned we have sha-512 hashes on

00:03:31,440 --> 00:03:36,120
top of all of the source code so this

00:03:33,510 --> 00:03:39,120
guarantees that if someone was to try to

00:03:36,120 --> 00:03:43,019
change something maliciously or benignly

00:03:39,120 --> 00:03:44,850
as is most of the cases that it will be

00:03:43,019 --> 00:03:46,620
caught and then you can actually decide

00:03:44,850 --> 00:03:49,560
what the appropriate action is in your

00:03:46,620 --> 00:03:52,019
particular case maybe it is to redirect

00:03:49,560 --> 00:03:53,160
you an archive of a pre of that previous

00:03:52,019 --> 00:03:54,329
version that you are already using

00:03:53,160 --> 00:03:55,769
because maybe that's what you're using

00:03:54,329 --> 00:03:58,049
in a field and you can't change it at

00:03:55,769 --> 00:03:59,519
this time or maybe it's simply to

00:03:58,049 --> 00:04:01,230
upgrade to the newest version but now

00:03:59,519 --> 00:04:03,530
that you've acknowledged that changes

00:04:01,230 --> 00:04:03,530
have been made

00:04:04,880 --> 00:04:08,420
however what we found is that probably

00:04:07,130 --> 00:04:10,820
the best way to handle this is to

00:04:08,420 --> 00:04:13,760
directly access get commit IDs so the

00:04:10,820 --> 00:04:16,250
first point is that you should prefer

00:04:13,760 --> 00:04:20,209
get commit IDs as your point of truth

00:04:16,250 --> 00:04:22,280
because that doesn't change this seems

00:04:20,209 --> 00:04:24,170
obvious but a lot of systems are

00:04:22,280 --> 00:04:28,850
predicated on using the human readable

00:04:24,170 --> 00:04:30,020
name the tag as the reference identifier

00:04:28,850 --> 00:04:34,150
and the problem is as those are not

00:04:30,020 --> 00:04:34,150
truly those are not truly stable

00:04:34,930 --> 00:04:40,490
unfortunately the preferring the hashes

00:04:38,150 --> 00:04:42,140
sometimes breaks referring archive

00:04:40,490 --> 00:04:45,080
downloads sometimes breaks down because

00:04:42,140 --> 00:04:46,340
there are hosts which actually have

00:04:45,080 --> 00:04:50,510
different hashes every time you download

00:04:46,340 --> 00:04:52,040
them so Google source comm for example

00:04:50,510 --> 00:04:54,500
um which androids

00:04:52,040 --> 00:04:55,910
source code is hosted here along with

00:04:54,500 --> 00:04:57,260
many libraries that are developed as

00:04:55,910 --> 00:05:00,920
part of Android that one might want to

00:04:57,260 --> 00:05:04,270
use outside of Android those archives

00:05:00,920 --> 00:05:07,400
are down are created on demand and

00:05:04,270 --> 00:05:10,670
they're tar.gz x' and they have embedded

00:05:07,400 --> 00:05:14,030
timestamps and their particular method

00:05:10,670 --> 00:05:15,680
for producing these uses the current

00:05:14,030 --> 00:05:17,090
time for some of those timestamps which

00:05:15,680 --> 00:05:19,310
means that every time you go to download

00:05:17,090 --> 00:05:22,490
that tar ball it changes the hash so you

00:05:19,310 --> 00:05:24,650
can't actually easily guarantee that you

00:05:22,490 --> 00:05:26,630
get the same source code every single

00:05:24,650 --> 00:05:28,400
time in PC package what we've done in

00:05:26,630 --> 00:05:30,680
this case is we've fallen back to doing

00:05:28,400 --> 00:05:33,680
the git clone which means that for this

00:05:30,680 --> 00:05:35,390
particular library it does act

00:05:33,680 --> 00:05:38,180
differently than everyone else which

00:05:35,390 --> 00:05:44,000
causes pain in management of the system

00:05:38,180 --> 00:05:45,580
because consistency is king here once

00:05:44,000 --> 00:05:48,080
we've got these source code we

00:05:45,580 --> 00:05:50,870
introduced our most powerful weapon

00:05:48,080 --> 00:05:53,960
which is patching fundamentally that is

00:05:50,870 --> 00:05:56,810
what enables us to do anything that is

00:05:53,960 --> 00:05:58,160
required at the end of the day we can

00:05:56,810 --> 00:06:01,100
completely replace the source code if

00:05:58,160 --> 00:06:04,250
that's what is necessary to make make

00:06:01,100 --> 00:06:07,040
things build but this is the latter that

00:06:04,250 --> 00:06:11,320
goes over any wall that the upstream

00:06:07,040 --> 00:06:11,320
maintainer may accidentally introduce

00:06:12,910 --> 00:06:18,380
so now right before we build we do need

00:06:17,150 --> 00:06:20,990
to make sure that we have all of our

00:06:18,380 --> 00:06:22,520
dependencies available so in VC package

00:06:20,990 --> 00:06:24,110
and in most systems you will have

00:06:22,520 --> 00:06:26,150
already transitively built and installed

00:06:24,110 --> 00:06:29,120
any necessary dependencies so if you

00:06:26,150 --> 00:06:31,730
have something like say you're trying to

00:06:29,120 --> 00:06:33,200
build CPS SDK so CPP rest SDK is a

00:06:31,730 --> 00:06:36,470
library that I used to work on it

00:06:33,200 --> 00:06:38,060
depends on boost so we have to download

00:06:36,470 --> 00:06:39,410
and acquire boost and install it and

00:06:38,060 --> 00:06:42,770
make it available in the same way that

00:06:39,410 --> 00:06:44,090
it would be available for a consumer we

00:06:42,770 --> 00:06:45,560
have to make it available for the

00:06:44,090 --> 00:06:47,990
particular build of CPU rusticate this

00:06:45,560 --> 00:06:50,810
is kind of obvious for libraries however

00:06:47,990 --> 00:06:52,490
for tools things are a little bit more

00:06:50,810 --> 00:06:54,290
complicated and there's a little bit

00:06:52,490 --> 00:06:57,260
more flexibility in what you need to do

00:06:54,290 --> 00:06:59,840
when a library says oh you have to build

00:06:57,260 --> 00:07:01,970
this inside of emesis like ffmpeg does

00:06:59,840 --> 00:07:05,120
or oh you need to build this with

00:07:01,970 --> 00:07:06,680
pearl-like OpenSSL does or you need to

00:07:05,120 --> 00:07:08,990
have a copy of python with this

00:07:06,680 --> 00:07:12,410
particular module pip installed so that

00:07:08,990 --> 00:07:15,290
our code generator can run well we think

00:07:12,410 --> 00:07:17,390
it's unacceptable to modify the system

00:07:15,290 --> 00:07:19,580
State in that way underneath the user I

00:07:17,390 --> 00:07:21,470
don't think that using a package manager

00:07:19,580 --> 00:07:24,070
for C++ should silently pip install

00:07:21,470 --> 00:07:26,720
things on your system maybe that's a

00:07:24,070 --> 00:07:28,910
personal opinion but that's not what VC

00:07:26,720 --> 00:07:33,760
package does so instead what we prefer

00:07:28,910 --> 00:07:33,760
to do is we prepare for prefer excuse me

00:07:34,450 --> 00:07:39,080
we prefer to get isolated copies of

00:07:37,580 --> 00:07:40,580
these tools as much as possible so for

00:07:39,080 --> 00:07:42,470
example on Windows will download a

00:07:40,580 --> 00:07:44,300
private copy of Python that we can then

00:07:42,470 --> 00:07:46,790
do this pip install for will download a

00:07:44,300 --> 00:07:49,040
private copy of ninja of C make of pearl

00:07:46,790 --> 00:07:49,940
of any tools that we can so that we can

00:07:49,040 --> 00:07:51,170
make sure that these builds are

00:07:49,940 --> 00:07:52,790
absolutely wanted to present

00:07:51,170 --> 00:07:59,660
reproducible from machine to machine

00:07:52,790 --> 00:08:02,180
from day to day now we get on to

00:07:59,660 --> 00:08:04,010
actually doing the build so there are

00:08:02,180 --> 00:08:06,920
many different build systems in place

00:08:04,010 --> 00:08:10,820
today in various in various libraries

00:08:06,920 --> 00:08:12,890
however in VC package in practice what

00:08:10,820 --> 00:08:14,810
we found is that the vast majority of

00:08:12,890 --> 00:08:18,260
our libraries either supports he make

00:08:14,810 --> 00:08:21,230
primarily or secondarily so this means

00:08:18,260 --> 00:08:23,009
that again consistency is king if we

00:08:21,230 --> 00:08:27,650
make C make work

00:08:23,009 --> 00:08:30,240
and most libraries actually do just work

00:08:27,650 --> 00:08:34,229
unfortunately this isn't the only case

00:08:30,240 --> 00:08:36,930
also with scale you and you attach cases

00:08:34,229 --> 00:08:38,430
you hit edge cases where they don't have

00:08:36,930 --> 00:08:41,449
seen make they have the aforementioned

00:08:38,430 --> 00:08:43,649
bash script or the perl script or the

00:08:41,449 --> 00:08:47,100
custom build system that is really only

00:08:43,649 --> 00:08:48,630
used by them or the build system that

00:08:47,100 --> 00:08:51,630
they published as part of producing that

00:08:48,630 --> 00:08:53,699
project but doesn't necessarily have

00:08:51,630 --> 00:08:55,050
enough adoption or you have new build

00:08:53,699 --> 00:08:57,990
systems that are still somewhat immature

00:08:55,050 --> 00:08:59,519
and are still growing into possibly

00:08:57,990 --> 00:09:01,079
delightful things in the future but

00:08:59,519 --> 00:09:06,149
right now that can sometimes be painful

00:09:01,079 --> 00:09:08,519
to work with so at scale of course this

00:09:06,149 --> 00:09:10,529
means you don't want to write the

00:09:08,519 --> 00:09:13,170
individual you know execute process

00:09:10,529 --> 00:09:14,670
calls for every single library every

00:09:13,170 --> 00:09:16,980
single time you build helpers that's

00:09:14,670 --> 00:09:19,370
what we do we build functions that wrap

00:09:16,980 --> 00:09:21,449
particular kinds of build systems but

00:09:19,370 --> 00:09:22,860
similar to how there's varying levels of

00:09:21,449 --> 00:09:24,329
Dopson there are varying levels of

00:09:22,860 --> 00:09:29,569
quality and how these wrappers can work

00:09:24,329 --> 00:09:31,740
as the most compelling example you have

00:09:29,569 --> 00:09:34,680
things like tall chains how do you

00:09:31,740 --> 00:09:35,850
specify what compiler to use cxx

00:09:34,680 --> 00:09:37,709
environment variable that wasn't that

00:09:35,850 --> 00:09:41,579
hard how do you specify what compiler

00:09:37,709 --> 00:09:45,660
flags to use well cxx flags still not

00:09:41,579 --> 00:09:47,279
that bad how do i specify that the

00:09:45,660 --> 00:09:53,250
platform that I'm targeting produces

00:09:47,279 --> 00:09:55,529
executables that end in dot j/s that's a

00:09:53,250 --> 00:09:57,600
little bit more difficult C make has a

00:09:55,529 --> 00:09:58,860
mechanism to do this and I'm sure that

00:09:57,600 --> 00:10:03,899
other build systems have a mechanism to

00:09:58,860 --> 00:10:06,630
do this as well but there is no genuine

00:10:03,899 --> 00:10:08,880
wide consensus on how to specify this in

00:10:06,630 --> 00:10:10,319
a way that is agnostic to the underlying

00:10:08,880 --> 00:10:12,240
build system this is the fundamental

00:10:10,319 --> 00:10:15,149
problem with tool chains if you crack

00:10:12,240 --> 00:10:16,410
open a C make installation on your

00:10:15,149 --> 00:10:18,930
machine and you look through kind of

00:10:16,410 --> 00:10:21,300
those platform files there are and in

00:10:18,930 --> 00:10:23,819
there's an enormous enormous amount of

00:10:21,300 --> 00:10:26,310
code that goes into defining exactly

00:10:23,819 --> 00:10:27,839
what a target looks like so the hope

00:10:26,310 --> 00:10:30,839
that we can define it in just a handful

00:10:27,839 --> 00:10:35,000
of environment variables seems not

00:10:30,839 --> 00:10:36,740
really workable from the very start so

00:10:35,000 --> 00:10:38,840
this is where you get varying levels of

00:10:36,740 --> 00:10:41,150
quality that are more and less difficult

00:10:38,840 --> 00:10:42,830
to control so toolchain files you know

00:10:41,150 --> 00:10:44,870
see make has a bunch of those and if you

00:10:42,830 --> 00:10:47,030
as a user provide a tool chain file then

00:10:44,870 --> 00:10:50,240
that means that we can make scenic

00:10:47,030 --> 00:10:52,640
behave as you intended but how do we

00:10:50,240 --> 00:10:55,540
make ffmpeg deal deal with them how do

00:10:52,640 --> 00:10:57,770
we make ffmpeg work the way you intended

00:10:55,540 --> 00:11:01,310
we have some strategies and I'll get to

00:10:57,770 --> 00:11:03,200
those in a moment but also say that with

00:11:01,310 --> 00:11:05,720
these helpers with certain build systems

00:11:03,200 --> 00:11:07,550
we also know what formed the standard

00:11:05,720 --> 00:11:09,830
parameters for that particular system so

00:11:07,550 --> 00:11:11,960
with C make for example there are a

00:11:09,830 --> 00:11:13,370
bunch of standard flags that you can

00:11:11,960 --> 00:11:16,160
pass such as you know see Mike installed

00:11:13,370 --> 00:11:18,260
prefix see Mike installed bin dere see

00:11:16,160 --> 00:11:22,130
Mike install Lib Deere build shared

00:11:18,260 --> 00:11:24,310
libraries etc by knowing these standard

00:11:22,130 --> 00:11:27,320
variables what this means is that we can

00:11:24,310 --> 00:11:28,070
more easily handle libraries that we've

00:11:27,320 --> 00:11:29,810
never seen before

00:11:28,070 --> 00:11:31,840
this means that porting a new library

00:11:29,810 --> 00:11:34,580
adding a new library to the ecosystem is

00:11:31,840 --> 00:11:36,500
infinitely easier when it is one of

00:11:34,580 --> 00:11:37,910
these build systems that we already have

00:11:36,500 --> 00:11:39,530
a helper for that has well established

00:11:37,910 --> 00:11:43,970
conventions for the way that things are

00:11:39,530 --> 00:11:47,030
done so what do we do in these worst

00:11:43,970 --> 00:11:50,390
case scenarios where a user has say

00:11:47,030 --> 00:11:52,880
custom Python script that is hard-coded

00:11:50,390 --> 00:11:54,980
to use GCC for example and we want to

00:11:52,880 --> 00:12:01,370
enable users to use clang or god forbid

00:11:54,980 --> 00:12:02,810
MSV seen so honestly most of the time in

00:12:01,370 --> 00:12:04,160
these cases the easiest answer is

00:12:02,810 --> 00:12:09,140
actually to replace the build system

00:12:04,160 --> 00:12:10,580
when they're in this problematic is

00:12:09,140 --> 00:12:12,260
because in fact the vast majority of

00:12:10,580 --> 00:12:14,060
libraries actually from a package

00:12:12,260 --> 00:12:20,630
managers perspective really do boil down

00:12:14,060 --> 00:12:23,780
to just start out CC so we invite

00:12:20,630 --> 00:12:26,390
embrace globs and we rewrite the build

00:12:23,780 --> 00:12:29,150
system with C make you honestly if you

00:12:26,390 --> 00:12:33,370
use if you are pragmatic about it if you

00:12:29,150 --> 00:12:35,930
are focused on the task at hand which is

00:12:33,370 --> 00:12:37,910
delivering the build in a reproducible

00:12:35,930 --> 00:12:39,670
reliable way that consumes dependencies

00:12:37,910 --> 00:12:44,240
correctly from the rest of the system

00:12:39,670 --> 00:12:46,839
these are very easy to write 30 lines or

00:12:44,240 --> 00:12:48,750
less even it's actually quite easy so

00:12:46,839 --> 00:12:51,450
while it seems dress

00:12:48,750 --> 00:12:52,950
to say replace the build system frankly

00:12:51,450 --> 00:12:54,270
replacing the build system is less lines

00:12:52,950 --> 00:12:55,500
than the patch file that would be

00:12:54,270 --> 00:12:59,730
required to make the original build

00:12:55,500 --> 00:13:01,500
system work and our built and the build

00:12:59,730 --> 00:13:02,850
system replacement you know what

00:13:01,500 --> 00:13:04,410
conventions it's using you know that

00:13:02,850 --> 00:13:05,790
it's going to respect to build shared

00:13:04,410 --> 00:13:08,490
lives you know that it's going to

00:13:05,790 --> 00:13:13,200
respect fine package whereas in the case

00:13:08,490 --> 00:13:15,540
of a dozens or hundreds of files of

00:13:13,200 --> 00:13:20,700
build scripts you don't necessarily know

00:13:15,540 --> 00:13:22,410
that however replacing only really does

00:13:20,700 --> 00:13:23,790
work effectively if it is that short if

00:13:22,410 --> 00:13:25,560
it is that simple there are libraries

00:13:23,790 --> 00:13:26,880
that are not and these are really

00:13:25,560 --> 00:13:28,800
important libraries that we really want

00:13:26,880 --> 00:13:33,150
to use things like UT things like boost

00:13:28,800 --> 00:13:34,050
things like C make itself no withdrawn

00:13:33,150 --> 00:13:37,170
sorry

00:13:34,050 --> 00:13:39,660
things like LOV M these really

00:13:37,170 --> 00:13:43,440
complicated libraries we can't just

00:13:39,660 --> 00:13:46,740
replace them when we find a problem in

00:13:43,440 --> 00:13:48,600
the cases where they're using a build

00:13:46,740 --> 00:13:50,340
system other than one of the ones that

00:13:48,600 --> 00:13:51,750
we have first-class support for and we

00:13:50,340 --> 00:13:54,480
really do want to make that toolchain

00:13:51,750 --> 00:13:59,400
scenario work where we can specify

00:13:54,480 --> 00:14:00,870
things like how exactly should you how

00:13:59,400 --> 00:14:01,980
exactly should you pull in a dependency

00:14:00,870 --> 00:14:03,480
library what are the transitive

00:14:01,980 --> 00:14:05,580
requirements of that dependency library

00:14:03,480 --> 00:14:08,250
and how are those encoded in the system

00:14:05,580 --> 00:14:10,170
when you have to extract all of this

00:14:08,250 --> 00:14:12,000
information out from what the user is

00:14:10,170 --> 00:14:13,800
provided and what four other libraries

00:14:12,000 --> 00:14:16,230
have provided and there's problems in

00:14:13,800 --> 00:14:17,970
the existing build system one approach

00:14:16,230 --> 00:14:19,950
that we can take is we can actually wrap

00:14:17,970 --> 00:14:21,480
the existing build system in another

00:14:19,950 --> 00:14:25,560
build system so this is not a

00:14:21,480 --> 00:14:27,690
replacement this is instead effectively

00:14:25,560 --> 00:14:29,760
adding a second configure step that runs

00:14:27,690 --> 00:14:33,030
ahead of time so as zeroth configure

00:14:29,760 --> 00:14:35,790
step which pulls in all of the

00:14:33,030 --> 00:14:38,850
information specified by the user in a

00:14:35,790 --> 00:14:41,400
say cm8 toolchain file this way the user

00:14:38,850 --> 00:14:42,930
only needs to specify things in a single

00:14:41,400 --> 00:14:45,089
place we pull all that information in

00:14:42,930 --> 00:14:46,800
and then we can pass that in a build

00:14:45,089 --> 00:14:49,470
system specific form to the underlying

00:14:46,800 --> 00:14:51,360
build system MVC package today we

00:14:49,470 --> 00:14:54,300
actually do this in two cases we do this

00:14:51,360 --> 00:14:57,330
in boost to construct a be Jam user

00:14:54,300 --> 00:14:59,490
config so B Jam is boosts build system

00:14:57,330 --> 00:15:01,050
today they are looking at moving to C

00:14:59,490 --> 00:15:02,220
make but I'm sure that that's going to

00:15:01,050 --> 00:15:05,120
be a multi-year endeavor

00:15:02,220 --> 00:15:07,890
so for now we continue to use be jammer

00:15:05,120 --> 00:15:09,960
but the problem with BGM of course is

00:15:07,890 --> 00:15:13,110
that its particular toolchain format is

00:15:09,960 --> 00:15:15,780
used by only the people who use Boost

00:15:13,110 --> 00:15:19,400
build and be Jam which is for the most

00:15:15,780 --> 00:15:25,020
part just boost so that means that users

00:15:19,400 --> 00:15:27,810
it's a bit you really can't expect users

00:15:25,020 --> 00:15:30,060
to provide a user config file or a user

00:15:27,810 --> 00:15:32,370
config game file which is the name of

00:15:30,060 --> 00:15:34,410
the tool chain file for B Jam

00:15:32,370 --> 00:15:36,960
you really can't users can't expect

00:15:34,410 --> 00:15:40,350
users to provide that file for every

00:15:36,960 --> 00:15:43,590
possible build system that we package so

00:15:40,350 --> 00:15:45,150
instead we run a seam ik build on top we

00:15:43,590 --> 00:15:47,130
gather information such as the compiler

00:15:45,150 --> 00:15:48,420
flags that have been set by the user the

00:15:47,130 --> 00:15:49,920
run time that has been set by the user

00:15:48,420 --> 00:15:51,780
the compiler that is being used by the

00:15:49,920 --> 00:15:53,420
user other environment variables that

00:15:51,780 --> 00:15:55,620
are being by the used by the user the

00:15:53,420 --> 00:15:57,480
names of the libraries that will be

00:15:55,620 --> 00:15:59,040
pulled in because we can run find a

00:15:57,480 --> 00:16:00,450
library and see make or we can run find

00:15:59,040 --> 00:16:02,820
package and we can kind of extract that

00:16:00,450 --> 00:16:05,220
information out and then we push that

00:16:02,820 --> 00:16:08,580
and we generate a tool chain on-the-fly

00:16:05,220 --> 00:16:10,440
for the underlying build system we also

00:16:08,580 --> 00:16:12,090
do this for openness no open SSL uses

00:16:10,440 --> 00:16:14,310
Perl and it takes its particular

00:16:12,090 --> 00:16:19,590
parameters in a certain different way

00:16:14,310 --> 00:16:21,780
and what this results in is that this

00:16:19,590 --> 00:16:24,030
enables us to build boost and open SSL

00:16:21,780 --> 00:16:28,200
with the Android tool chain built inside

00:16:24,030 --> 00:16:30,240
scénic by simply setting the C make

00:16:28,200 --> 00:16:31,830
system name and selecting the Android

00:16:30,240 --> 00:16:35,430
tool chain we're actually able to use

00:16:31,830 --> 00:16:39,030
all of that incredibly incredibly

00:16:35,430 --> 00:16:41,700
expensive to develop detection logic of

00:16:39,030 --> 00:16:43,890
what NDK version are using what STL

00:16:41,700 --> 00:16:46,589
version are you using etc etc using

00:16:43,890 --> 00:16:49,050
reusing all of that to then build these

00:16:46,589 --> 00:16:51,210
libraries which don't support C me to do

00:16:49,050 --> 00:16:53,220
so this is a powerful technique but it's

00:16:51,210 --> 00:16:55,470
also incredibly difficult we're only

00:16:53,220 --> 00:16:57,150
using it in two cases today but we will

00:16:55,470 --> 00:16:59,580
probably need to use it further in the

00:16:57,150 --> 00:17:01,230
future in order to improve support

00:16:59,580 --> 00:17:03,440
throughout the ecosystem for custom tool

00:17:01,230 --> 00:17:03,440
sets

00:17:04,540 --> 00:17:09,610
so there's a few different ways that

00:17:06,699 --> 00:17:12,260
libraries can ask for their dependencies

00:17:09,610 --> 00:17:14,270
during their build one is package

00:17:12,260 --> 00:17:16,280
configure this is popular on UNIX

00:17:14,270 --> 00:17:17,720
platforms it's used by Auto contracts

00:17:16,280 --> 00:17:19,910
used by meson and it's used by many

00:17:17,720 --> 00:17:21,740
other build systems even hand-rolled

00:17:19,910 --> 00:17:25,100
makes scripts can use package config

00:17:21,740 --> 00:17:26,810
other build systems will do directs

00:17:25,100 --> 00:17:28,820
library name references they'll just

00:17:26,810 --> 00:17:31,310
effectively hard-code either a - little

00:17:28,820 --> 00:17:34,100
L name or they have some other facility

00:17:31,310 --> 00:17:38,120
which morally is adding just a library

00:17:34,100 --> 00:17:40,580
name to the linker line in this build in

00:17:38,120 --> 00:17:42,470
particular for us is this is the primary

00:17:40,580 --> 00:17:46,280
way to add dependencies Damus build is

00:17:42,470 --> 00:17:48,530
to have a list of library paths to

00:17:46,280 --> 00:17:51,380
search for effectively - capitals and

00:17:48,530 --> 00:17:55,610
then the individual libraries - link -

00:17:51,380 --> 00:17:56,960
little Isles in C make you have fine

00:17:55,610 --> 00:17:59,120
package and find library fine library

00:17:56,960 --> 00:18:00,290
acts very similar to this direct library

00:17:59,120 --> 00:18:01,580
name reference it has a little bit of

00:18:00,290 --> 00:18:04,480
fallback logic inside of it which is

00:18:01,580 --> 00:18:07,310
very nice but fine packages really the

00:18:04,480 --> 00:18:09,170
the preferred method and that works more

00:18:07,310 --> 00:18:11,750
like package config so both of those

00:18:09,170 --> 00:18:15,070
systems find package and package config

00:18:11,750 --> 00:18:19,130
let you declare a dependency on a

00:18:15,070 --> 00:18:21,680
package by name on a more complete

00:18:19,130 --> 00:18:23,930
understanding of what it is more than

00:18:21,680 --> 00:18:26,200
just its library name so this includes

00:18:23,930 --> 00:18:27,980
headers this includes potentially

00:18:26,200 --> 00:18:29,900
configuration flags that you need to

00:18:27,980 --> 00:18:31,730
pass to your compiler and most

00:18:29,900 --> 00:18:36,590
importantly it in contains transitive

00:18:31,730 --> 00:18:38,330
dependency information in fine package

00:18:36,590 --> 00:18:40,250
and specific comes in kind of two

00:18:38,330 --> 00:18:42,650
flavors there's two ways that find a

00:18:40,250 --> 00:18:46,760
find package call can be resolved at

00:18:42,650 --> 00:18:48,230
runtime one flavor is config files which

00:18:46,760 --> 00:18:50,270
are intended to be provided by the

00:18:48,230 --> 00:18:53,060
project and the other flavor is find it

00:18:50,270 --> 00:18:55,580
scripts which can either be provided by

00:18:53,060 --> 00:18:56,750
the consumer so just to clarify the

00:18:55,580 --> 00:18:59,600
config files are provided by the

00:18:56,750 --> 00:19:01,970
producer so fine fine scripts can be

00:18:59,600 --> 00:19:04,250
provided by the consumer or they could

00:19:01,970 --> 00:19:06,770
be built into C make itself these are

00:19:04,250 --> 00:19:08,360
incredibly popular and widely used both

00:19:06,770 --> 00:19:09,560
of these so there are a bunch of

00:19:08,360 --> 00:19:10,850
libraries that provide config files

00:19:09,560 --> 00:19:13,310
there are just as many libraries that

00:19:10,850 --> 00:19:15,770
don't provide config files and C make

00:19:13,310 --> 00:19:16,730
has a bunch of fine scripts for what you

00:19:15,770 --> 00:19:19,760
consider to be

00:19:16,730 --> 00:19:22,490
critical to build software things like

00:19:19,760 --> 00:19:26,900
boost things like open SSL things like

00:19:22,490 --> 00:19:28,640
live XML - these things are provided by

00:19:26,900 --> 00:19:30,169
sea make itself to help bootstrap the

00:19:28,640 --> 00:19:31,429
ecosystem once upon a time and they're

00:19:30,169 --> 00:19:36,950
still around and they're still widely

00:19:31,429 --> 00:19:39,350
used and they still work however this

00:19:36,950 --> 00:19:42,830
doesn't come this isn't a perfect right

00:19:39,350 --> 00:19:45,530
there aren't it's not it's not error

00:19:42,830 --> 00:19:47,450
free so the two most common issues that

00:19:45,530 --> 00:19:50,690
we have in a fine packaged call things

00:19:47,450 --> 00:19:53,720
that can break down here one is that the

00:19:50,690 --> 00:19:55,610
libraries themselves are not specifying

00:19:53,720 --> 00:19:58,610
all of their dependencies correctly so

00:19:55,610 --> 00:20:01,520
this happens unfortunately in the case

00:19:58,610 --> 00:20:03,770
of find Xyz scripts provided by C make

00:20:01,520 --> 00:20:06,530
itself and this is because he make

00:20:03,770 --> 00:20:09,650
really can't do the right thing here C

00:20:06,530 --> 00:20:11,450
mcdo the particular ways that the

00:20:09,650 --> 00:20:13,400
library that you are consuming was built

00:20:11,450 --> 00:20:14,780
it has to make the best - guess it

00:20:13,400 --> 00:20:17,540
doesn't know that curl was built

00:20:14,780 --> 00:20:19,010
statically with open SSL or not so

00:20:17,540 --> 00:20:20,990
therefore it can't know whether it needs

00:20:19,010 --> 00:20:23,450
to transitively go and try to find open

00:20:20,990 --> 00:20:26,210
SSL it just tries to do its best effort

00:20:23,450 --> 00:20:28,070
it finds curl itself it links curl and

00:20:26,210 --> 00:20:30,290
hopes that that's all you needed and if

00:20:28,070 --> 00:20:33,380
you needed more then sometimes you will

00:20:30,290 --> 00:20:36,740
have to go and explicitly find package

00:20:33,380 --> 00:20:40,850
those yourself or we can fix it in one

00:20:36,740 --> 00:20:44,210
place so in BC package what we do is

00:20:40,850 --> 00:20:50,270
that we actually are able to hook find

00:20:44,210 --> 00:20:51,650
package this is not using a public well

00:20:50,270 --> 00:20:53,150
public is in the right word

00:20:51,650 --> 00:20:54,890
this isn't used of using a preferred

00:20:53,150 --> 00:20:56,990
method in C macand and we're looking for

00:20:54,890 --> 00:20:58,400
better alternatives but for now what we

00:20:56,990 --> 00:21:00,169
found to be highly effective is that we

00:20:58,400 --> 00:21:03,830
actually hook find package itself and

00:21:00,169 --> 00:21:05,360
what this lets us do is it lets us do

00:21:03,830 --> 00:21:08,590
the normal resolution fall through to

00:21:05,360 --> 00:21:11,780
the fine script underlying the

00:21:08,590 --> 00:21:14,030
underlying that particular call but then

00:21:11,780 --> 00:21:15,980
on the way back out we can fix this

00:21:14,030 --> 00:21:19,309
issue we can add additional dependencies

00:21:15,980 --> 00:21:21,169
to that dependency list so we know that

00:21:19,309 --> 00:21:23,000
we built curl statically with open SSL

00:21:21,169 --> 00:21:24,620
we know that this means you need to call

00:21:23,000 --> 00:21:26,720
fine package open SSL in order to be

00:21:24,620 --> 00:21:28,520
able to use curl and you need to add its

00:21:26,720 --> 00:21:29,360
dependencies into the dependency list to

00:21:28,520 --> 00:21:32,690
provide that transitive

00:21:29,360 --> 00:21:35,170
information and so we do that another

00:21:32,690 --> 00:21:38,809
example that we run into problems is

00:21:35,170 --> 00:21:41,090
incomplete targets so the way that

00:21:38,809 --> 00:21:42,410
seemeth works with fine package is you

00:21:41,090 --> 00:21:43,850
call fine package and then this can

00:21:42,410 --> 00:21:45,110
provide a list of targets at least this

00:21:43,850 --> 00:21:46,610
is the modern scene make that we're

00:21:45,110 --> 00:21:48,200
trying to move towards and is

00:21:46,610 --> 00:21:50,809
significantly better I highly recommend

00:21:48,200 --> 00:21:53,380
it in general however it is possible

00:21:50,809 --> 00:21:56,179
that in a particular configuration a

00:21:53,380 --> 00:21:57,590
library is not providing the same

00:21:56,179 --> 00:22:00,679
targets as it would in another

00:21:57,590 --> 00:22:04,400
configuration the number one the number

00:22:00,679 --> 00:22:06,950
one bad bad behavior here is static

00:22:04,400 --> 00:22:08,450
versus dynamic builds a lot of libraries

00:22:06,950 --> 00:22:10,640
will provide a static target that's

00:22:08,450 --> 00:22:13,130
different than their dynamic target so

00:22:10,640 --> 00:22:15,260
Zillah - static instead of Zeeland as

00:22:13,130 --> 00:22:18,260
the target name and in your sea make

00:22:15,260 --> 00:22:20,809
that means that you have to choose which

00:22:18,260 --> 00:22:23,840
one that you depend upon which means

00:22:20,809 --> 00:22:26,540
that somehow you need to intuit the way

00:22:23,840 --> 00:22:29,720
that the downstream library was

00:22:26,540 --> 00:22:31,970
preferred to be built it really it

00:22:29,720 --> 00:22:34,400
doesn't work it doesn't scale that means

00:22:31,970 --> 00:22:37,730
that every single consumer needs to be

00:22:34,400 --> 00:22:39,980
configured to every single consumer

00:22:37,730 --> 00:22:42,549
needs to be configured in the exact same

00:22:39,980 --> 00:22:47,030
way every time and if you get it wrong

00:22:42,549 --> 00:22:49,400
bad things happen so what we can do with

00:22:47,030 --> 00:22:51,559
this fine packaged script is that we can

00:22:49,400 --> 00:22:55,190
paper over these sorts of issues we can

00:22:51,559 --> 00:22:57,320
say don't worry they look don't build

00:22:55,190 --> 00:22:59,809
your static form only build your dynamic

00:22:57,320 --> 00:23:01,610
form and in order to make the libraries

00:22:59,809 --> 00:23:03,440
that try to use the static form work

00:23:01,610 --> 00:23:06,590
what we can do is we can inject alias

00:23:03,440 --> 00:23:08,540
targets that alias back to the dynamic

00:23:06,590 --> 00:23:10,520
name so we introduced the static name

00:23:08,540 --> 00:23:14,809
but it actually resolves to the dynamic

00:23:10,520 --> 00:23:20,570
name so this enables us to undo this

00:23:14,809 --> 00:23:23,480
decision point in the graph and

00:23:20,570 --> 00:23:25,429
currently we use we use this technique

00:23:23,480 --> 00:23:28,720
in 35 different places across our

00:23:25,429 --> 00:23:32,110
ecosystem so three percent of libraries

00:23:28,720 --> 00:23:32,110
we need to fix

00:23:32,609 --> 00:23:37,059
so we've actually we've managed to build

00:23:35,139 --> 00:23:40,149
the library we dealt with all of its

00:23:37,059 --> 00:23:43,269
dependency problems we patched whatever

00:23:40,149 --> 00:23:45,369
was necessary to patch so now we have

00:23:43,269 --> 00:23:47,950
the binary artifacts coming out of the

00:23:45,369 --> 00:23:50,019
build system so these need to be

00:23:47,950 --> 00:23:53,919
rearranged into a standard way so that

00:23:50,019 --> 00:23:56,109
that we can provide further services on

00:23:53,919 --> 00:23:57,729
top so this means things like well being

00:23:56,109 --> 00:23:59,739
able to build code on top of it directly

00:23:57,729 --> 00:24:01,090
so we want all of the Lib files to be in

00:23:59,739 --> 00:24:02,259
a certain directory when all the days to

00:24:01,090 --> 00:24:03,759
be in a certain directory we want that

00:24:02,259 --> 00:24:05,739
supposed to be in a different directory

00:24:03,759 --> 00:24:07,679
if you built any tools we want those

00:24:05,739 --> 00:24:10,119
packaged this way if you provided

00:24:07,679 --> 00:24:12,129
integration files like package config or

00:24:10,119 --> 00:24:14,139
C make scripts then we want those to be

00:24:12,129 --> 00:24:16,509
in certain arrangement in a certain way

00:24:14,139 --> 00:24:19,809
so that we can do things like tell the

00:24:16,509 --> 00:24:21,190
user hey this library provided this kind

00:24:19,809 --> 00:24:23,320
of integration here's how you should

00:24:21,190 --> 00:24:25,119
take take advantage of it and in order

00:24:23,320 --> 00:24:31,859
to do that we need things to be

00:24:25,119 --> 00:24:36,609
organized in a certain way furthermore

00:24:31,859 --> 00:24:38,470
beyond just organization we sometimes

00:24:36,609 --> 00:24:42,700
need to make some patches at this point

00:24:38,470 --> 00:24:44,739
because for example the files that you

00:24:42,700 --> 00:24:46,869
generated might have absolute pounds in

00:24:44,739 --> 00:24:48,669
them and relocation is not optional it

00:24:46,869 --> 00:24:52,389
is a requirement being relocatable

00:24:48,669 --> 00:24:55,479
having your binary outputs be usable

00:24:52,389 --> 00:24:56,799
either on a different machine or even in

00:24:55,479 --> 00:24:59,080
a different directory on the same

00:24:56,799 --> 00:25:01,119
machine is is really mandatory that's

00:24:59,080 --> 00:25:03,429
not an optional step so the way that we

00:25:01,119 --> 00:25:07,899
can achieve this often the easiest way

00:25:03,429 --> 00:25:11,109
to achieve this is to replace in those

00:25:07,899 --> 00:25:12,999
files absolute paths with relative paths

00:25:11,109 --> 00:25:16,239
and do this as kind of a generic records

00:25:12,999 --> 00:25:18,009
I will skip over some of these other for

00:25:16,239 --> 00:25:18,609
time to make sure that we have questions

00:25:18,009 --> 00:25:20,679
at the end

00:25:18,609 --> 00:25:22,869
I mentioned static libraries and dynamic

00:25:20,679 --> 00:25:24,729
libraries before but in addition to

00:25:22,869 --> 00:25:27,729
simply needing to patch the consuming

00:25:24,729 --> 00:25:30,429
side this usually takes several steps to

00:25:27,729 --> 00:25:32,229
resolve if a library is designed to

00:25:30,429 --> 00:25:33,789
provide both static and dynamic at the

00:25:32,229 --> 00:25:35,289
same time we'll have to patch the

00:25:33,789 --> 00:25:37,259
original build to make sure that they

00:25:35,289 --> 00:25:39,960
have an option to only build one of them

00:25:37,259 --> 00:25:42,519
we'll need to patch the headers

00:25:39,960 --> 00:25:44,349
post-install to make sure that any

00:25:42,519 --> 00:25:44,920
macros in this configuration state you

00:25:44,349 --> 00:25:46,870
know curl

00:25:44,920 --> 00:25:48,910
underscore static means to be defined if

00:25:46,870 --> 00:25:50,350
you are consuming it statically or Z

00:25:48,910 --> 00:25:51,520
live underscore static maybe needs to be

00:25:50,350 --> 00:25:53,290
defined or what-have-you

00:25:51,520 --> 00:25:55,030
we may need to patch the headers

00:25:53,290 --> 00:25:56,980
post-install to make sure that

00:25:55,030 --> 00:26:00,490
downstream consumers are getting the

00:25:56,980 --> 00:26:01,750
right macros and then finally we may

00:26:00,490 --> 00:26:03,610
need to intercept things like fine

00:26:01,750 --> 00:26:06,090
package in order to make sure that if

00:26:03,610 --> 00:26:09,130
someone is depending on Z lab static and

00:26:06,090 --> 00:26:11,620
we've chosen or the user has told us

00:26:09,130 --> 00:26:13,480
that no I want the dynamic Zeeland

00:26:11,620 --> 00:26:15,910
we need to make sure that that results

00:26:13,480 --> 00:26:17,860
correctly which in the case of Z lib

00:26:15,910 --> 00:26:19,980
static would mean resolving to the

00:26:17,860 --> 00:26:23,710
dynamic sealable

00:26:19,980 --> 00:26:25,480
so those were a summary of some issues

00:26:23,710 --> 00:26:28,300
that happen when you look at mostly a

00:26:25,480 --> 00:26:31,360
single library in isolation but there

00:26:28,300 --> 00:26:33,030
are additionally techniques around how

00:26:31,360 --> 00:26:35,020
to manage the ecosystem as a whole and

00:26:33,030 --> 00:26:36,970
probably the most important of these is

00:26:35,020 --> 00:26:39,850
how do you upgrade package management is

00:26:36,970 --> 00:26:42,220
not just a point in time problem it's

00:26:39,850 --> 00:26:44,410
really a problem over time and a

00:26:42,220 --> 00:26:49,570
question of how can you stay up to date

00:26:44,410 --> 00:26:53,830
how can you resolve CVEs quickly to ship

00:26:49,570 --> 00:26:56,550
good robust software so at scale you

00:26:53,830 --> 00:26:59,950
can't assume zember any system that is

00:26:56,550 --> 00:27:02,920
dependent upon cember really can't work

00:26:59,950 --> 00:27:04,750
at beyond a certain scale yes any of the

00:27:02,920 --> 00:27:05,950
libraries that you produce I highly

00:27:04,750 --> 00:27:07,390
recommend you take a look at SEM 4 and

00:27:05,950 --> 00:27:10,810
you see if it makes sense to you and

00:27:07,390 --> 00:27:12,250
adhere to it if you can but in general

00:27:10,810 --> 00:27:16,120
if you are packaging other peoples code

00:27:12,250 --> 00:27:17,890
you cannot assume sever so instead what

00:27:16,120 --> 00:27:20,020
we do is when we want to upgrade

00:27:17,890 --> 00:27:21,190
something we build everything we build

00:27:20,020 --> 00:27:24,010
everything and we make sure that they

00:27:21,190 --> 00:27:26,400
still work and that's much more powerful

00:27:24,010 --> 00:27:28,840
than Cimber can be because semver is

00:27:26,400 --> 00:27:32,500
intentionally much lossy or than that

00:27:28,840 --> 00:27:34,840
just because boost has said I broke an

00:27:32,500 --> 00:27:36,700
API which they do every time that

00:27:34,840 --> 00:27:42,580
doesn't mean that other libraries fail

00:27:36,700 --> 00:27:46,090
to build secondly is the title of this

00:27:42,580 --> 00:27:48,040
slide upgrading everything together the

00:27:46,090 --> 00:27:50,680
realities of software development today

00:27:48,040 --> 00:27:54,130
is that you are testing against a finite

00:27:50,680 --> 00:27:56,110
set of versions for your dependencies

00:27:54,130 --> 00:27:58,169
and one of those versions I hope is the

00:27:56,110 --> 00:28:00,820
latest

00:27:58,169 --> 00:28:04,750
what this means though is that your

00:28:00,820 --> 00:28:06,820
latest version primarily is tested

00:28:04,750 --> 00:28:08,380
against the latest version of your

00:28:06,820 --> 00:28:09,580
dependency and they are tested against

00:28:08,380 --> 00:28:11,049
the latest version of their dependency

00:28:09,580 --> 00:28:12,610
and they're tested against the latest

00:28:11,049 --> 00:28:13,750
version of their dependency so what

00:28:12,610 --> 00:28:15,820
makes you think that you can take one of

00:28:13,750 --> 00:28:18,279
these pieces and upgrade it without

00:28:15,820 --> 00:28:21,070
upgrading everything else and the answer

00:28:18,279 --> 00:28:23,590
is is you really can't at scale so this

00:28:21,070 --> 00:28:26,470
is why in vc package again we do

00:28:23,590 --> 00:28:30,090
upgrades together we move every library

00:28:26,470 --> 00:28:32,620
forward at the same rate and we

00:28:30,090 --> 00:28:34,750
discourage pinning though of course in

00:28:32,620 --> 00:28:37,870
specific instances pinning is always a

00:28:34,750 --> 00:28:40,480
necessary fallback but the happy path

00:28:37,870 --> 00:28:42,730
the optimal path the path that produces

00:28:40,480 --> 00:28:47,260
the best results is upgrading everything

00:28:42,730 --> 00:28:50,620
together additionally when we do this

00:28:47,260 --> 00:28:52,179
upgrades we want the ecosystem to still

00:28:50,620 --> 00:28:53,889
function we need the ecosystem to still

00:28:52,179 --> 00:28:56,169
function and what this means is that we

00:28:53,889 --> 00:28:59,350
need to address regressions then and

00:28:56,169 --> 00:29:02,740
there because otherwise you end up with

00:28:59,350 --> 00:29:06,700
broken diamonds broken diamonds are the

00:29:02,740 --> 00:29:09,250
case where you your library may depend

00:29:06,700 --> 00:29:11,559
on an A and a B and a and B both use

00:29:09,250 --> 00:29:13,899
boost but they use different versions of

00:29:11,559 --> 00:29:18,549
boost because boost released a new

00:29:13,899 --> 00:29:19,720
version and someone didn't fix B they

00:29:18,549 --> 00:29:21,760
just released the new version of boost

00:29:19,720 --> 00:29:22,840
so B tries to get the old version of

00:29:21,760 --> 00:29:28,149
boost and as long as you're only using

00:29:22,840 --> 00:29:29,529
B's and this is fine enough you this is

00:29:28,149 --> 00:29:38,049
fine enough you get the old version of

00:29:29,529 --> 00:29:39,460
boost but as soon as a besides I'm going

00:29:38,049 --> 00:29:41,649
to move my testing forward to the new

00:29:39,460 --> 00:29:42,850
latest version right that's what we do

00:29:41,649 --> 00:29:44,799
is good software developers the new

00:29:42,850 --> 00:29:47,110
version has seen who literally has C the

00:29:44,799 --> 00:29:49,179
ease out it has security vulnerabilities

00:29:47,110 --> 00:29:51,340
against it I cannot responsibly continue

00:29:49,179 --> 00:29:55,269
to ship the old version B still isn't

00:29:51,340 --> 00:29:57,970
updated so then if you want to use a and

00:29:55,269 --> 00:30:00,330
B your software has a problem you can't

00:29:57,970 --> 00:30:03,580
upgrade to the new a just because of

00:30:00,330 --> 00:30:04,809
boost here because they took a

00:30:03,580 --> 00:30:08,320
dependency on the new version of boost

00:30:04,809 --> 00:30:10,210
so this is why managing everything

00:30:08,320 --> 00:30:10,770
together in a centralized repository

00:30:10,210 --> 00:30:12,870
really

00:30:10,770 --> 00:30:14,520
is the best way to scale this particular

00:30:12,870 --> 00:30:17,490
problem so we can ensure that we push

00:30:14,520 --> 00:30:19,890
regressions all the way we can push

00:30:17,490 --> 00:30:21,750
regressions out of the system as we go

00:30:19,890 --> 00:30:23,610
through so it looks like I am out of

00:30:21,750 --> 00:30:26,520
time I'm so sorry that I was unable to

00:30:23,610 --> 00:30:29,490
reserve enough time my voice is going

00:30:26,520 --> 00:30:31,920
out already but I'm going to skip to the

00:30:29,490 --> 00:30:34,920
end and just go over to brief

00:30:31,920 --> 00:30:37,860
conclusions first is that oftentimes the

00:30:34,920 --> 00:30:40,920
problems that you need to fix our route

00:30:37,860 --> 00:30:44,700
caused in the producer and the best way

00:30:40,920 --> 00:30:46,770
the sound engineering practices is to

00:30:44,700 --> 00:30:48,480
fix it in the producer and not do

00:30:46,770 --> 00:30:50,520
workarounds in all of the consumers this

00:30:48,480 --> 00:30:52,260
is just obvious prefer the OA order one

00:30:50,520 --> 00:30:55,050
solution then the order n solution right

00:30:52,260 --> 00:30:56,910
and in order to do that that means you

00:30:55,050 --> 00:30:57,860
need a single consistent view over the

00:30:56,910 --> 00:31:00,360
entire world

00:30:57,860 --> 00:31:06,090
and the second point is simply that

00:31:00,360 --> 00:31:06,840
problems are repeated and with all of

00:31:06,090 --> 00:31:08,580
these techniques that I've mentioned

00:31:06,840 --> 00:31:10,080
this is what we're able to achieve in a

00:31:08,580 --> 00:31:12,450
VC package we've got a thousand over a

00:31:10,080 --> 00:31:15,150
thousand libraries on Windows 850 on

00:31:12,450 --> 00:31:18,270
Linux and about 800 on Mac and it's

00:31:15,150 --> 00:31:20,540
increasing at a rate of one per day so

00:31:18,270 --> 00:31:20,540
thank you

00:31:21,470 --> 00:31:25,210

YouTube URL: https://www.youtube.com/watch?v=Lb3hlLlHTrs


