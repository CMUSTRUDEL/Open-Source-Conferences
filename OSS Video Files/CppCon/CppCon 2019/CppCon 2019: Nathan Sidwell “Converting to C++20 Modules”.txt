Title: CppCon 2019: Nathan Sidwell “Converting to C++20 Modules”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
C++20 will have a module system, which provides benefits beyond simple code hygiene. C++20 modules uses new keywords and explicit source-level annotations. How do we get there from here?

I have been implementing this in the GNU compiler, and will talk about the broad strokes of the module specification.
I will describe how:
* one may incrementally convert source code,
* build systems might be augmented,
— 
Nathan Sidwell
Software Engineer, Facebook
Nathan is a developer of the GNU Compiler Collection, particularly the C++ Front End. His current major project is implementing and influencing the modules TS.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,000 --> 00:00:14,270
in previous years I've talked about

00:00:11,590 --> 00:00:16,400
implementing the module specification

00:00:14,270 --> 00:00:20,410
and how that module specification has

00:00:16,400 --> 00:00:23,060
changed during the development process

00:00:20,410 --> 00:00:26,420
this year I'm going to talk about how to

00:00:23,060 --> 00:00:28,460
convert an existing code to modules I'm

00:00:26,420 --> 00:00:30,470
not going to talk about why you would

00:00:28,460 --> 00:00:34,489
want modules we're going to take that as

00:00:30,470 --> 00:00:39,590
a given it's going to be in C++ 20 so

00:00:34,489 --> 00:00:43,879
it's here the I'm assuming that you've

00:00:39,590 --> 00:00:48,350
saw Gaby's talk yesterday who here did

00:00:43,879 --> 00:00:52,250
not see that talk okay right oh well

00:00:48,350 --> 00:00:54,790
okay hopefully cover enough of it of of

00:00:52,250 --> 00:00:56,780
modules that this talk will make sense

00:00:54,790 --> 00:00:58,580
the implementation I'm going to talk

00:00:56,780 --> 00:01:02,059
about is GCC's because that's the one

00:00:58,580 --> 00:01:05,479
I've been writing it's experimental it

00:01:02,059 --> 00:01:07,159
breaks its owner development branch is

00:01:05,479 --> 00:01:11,330
not in trunk it's not in any released

00:01:07,159 --> 00:01:14,960
version of GCC wiki page here that talks

00:01:11,330 --> 00:01:19,939
about the the state of that development

00:01:14,960 --> 00:01:22,579
and how to use it short answer is you

00:01:19,939 --> 00:01:27,909
just invoke it with the SF modules ts

00:01:22,579 --> 00:01:27,909
option and it will be in modules mode

00:01:28,060 --> 00:01:32,689
for this talk I decided to actually go

00:01:30,409 --> 00:01:34,070
and convert some existing software and I

00:01:32,689 --> 00:01:37,100
picked a library that I did not know

00:01:34,070 --> 00:01:40,070
about I looked on the ISO CPP webpage

00:01:37,100 --> 00:01:43,429
and found tiny XML too as an example

00:01:40,070 --> 00:01:46,850
library the original is on github by Lee

00:01:43,429 --> 00:01:50,450
Thomason go there if you want the real

00:01:46,850 --> 00:01:51,710
thing I cloned it to here which I then

00:01:50,450 --> 00:01:54,200
ripped out all the bits that weren't

00:01:51,710 --> 00:01:56,929
relevant to this talk so after this talk

00:01:54,200 --> 00:01:59,270
you can go and look at that look at that

00:01:56,929 --> 00:02:01,100
github repo and see the commits that

00:01:59,270 --> 00:02:01,340
I've made I've got a link at the end as

00:02:01,100 --> 00:02:03,340
well

00:02:01,340 --> 00:02:10,160
so this talk may make more sense

00:02:03,340 --> 00:02:13,450
watching it on YouTube OOP no go back

00:02:10,160 --> 00:02:15,980
there we go right it has one header file

00:02:13,450 --> 00:02:17,600
it has one source file which has got the

00:02:15,980 --> 00:02:21,799
implementation in it all the non inline

00:02:17,600 --> 00:02:24,110
stuff it has one make fight it also does

00:02:21,799 --> 00:02:25,160
see make but it has a make file which I

00:02:24,110 --> 00:02:28,460
liked because I know

00:02:25,160 --> 00:02:30,770
I know too much about make and it has

00:02:28,460 --> 00:02:32,090
one test program which you just wish to

00:02:30,770 --> 00:02:35,300
make file bills and you run it and it

00:02:32,090 --> 00:02:37,190
runs a bunch of tests so it's a fairly

00:02:35,300 --> 00:02:39,640
straightforward library that I thought

00:02:37,190 --> 00:02:44,480
was a good candidate for this conversion

00:02:39,640 --> 00:02:46,460
so step 0 let's make sure we can

00:02:44,480 --> 00:02:49,910
actually build it with the new compiler

00:02:46,460 --> 00:02:52,370
when it's unchanged so the only change

00:02:49,910 --> 00:02:56,360
there that I made is adding this line

00:02:52,370 --> 00:02:58,970
into the make file point point the see

00:02:56,360 --> 00:03:01,490
excited to see the the CX X variable at

00:02:58,970 --> 00:03:10,040
my new compiler and turn on modules mode

00:03:01,490 --> 00:03:12,950
for it run make o run make and you get a

00:03:10,040 --> 00:03:16,730
number of build commands it builds the

00:03:12,950 --> 00:03:20,480
library CPP file turned it into a Lib

00:03:16,730 --> 00:03:23,060
archive builds the test program run the

00:03:20,480 --> 00:03:27,590
test program all the tests pass hooray

00:03:23,060 --> 00:03:30,680
this compilers not completely broken ok

00:03:27,590 --> 00:03:34,340
so step right bit of background so this

00:03:30,680 --> 00:03:36,260
is a bit that Gaby kind of covered in

00:03:34,340 --> 00:03:38,810
his talk and Boris have covered a bit in

00:03:36,260 --> 00:03:41,540
his talk this morning is that when you

00:03:38,810 --> 00:03:44,540
build it module you get an object file

00:03:41,540 --> 00:03:46,190
but you also get this new artifact

00:03:44,540 --> 00:03:48,440
called a compiled module interface

00:03:46,190 --> 00:03:49,850
there's also called a BMI a binary

00:03:48,440 --> 00:03:53,390
module interface but it might not be a

00:03:49,850 --> 00:03:55,040
binary but whatever you get this new

00:03:53,390 --> 00:03:57,320
artifact that we have to teach the build

00:03:55,040 --> 00:04:01,490
system about so it knows dependencies

00:03:57,320 --> 00:04:05,000
between things and as as as Boris

00:04:01,490 --> 00:04:08,330
covered this morning there's no defined

00:04:05,000 --> 00:04:11,060
relationship between the file names of

00:04:08,330 --> 00:04:14,900
the see em I see em I file names and the

00:04:11,060 --> 00:04:18,530
module name that they are CMI for that's

00:04:14,900 --> 00:04:23,270
implementation defined I'm gonna cover a

00:04:18,530 --> 00:04:24,830
bit of that for how and also the CM is

00:04:23,270 --> 00:04:26,420
maybe placed in a particular place in

00:04:24,830 --> 00:04:29,150
the file system where that is is again

00:04:26,420 --> 00:04:33,050
implementation defined so there's a

00:04:29,150 --> 00:04:35,090
study group sg-15 is looking at what it

00:04:33,050 --> 00:04:36,380
would be best practice for these cut to

00:04:35,090 --> 00:04:38,590
answers answers for these kind of

00:04:36,380 --> 00:04:38,590
questions

00:04:38,789 --> 00:04:45,789
so simplest kind of easy the easiest

00:04:43,900 --> 00:04:49,780
conversion is to turn it into a head a

00:04:45,789 --> 00:04:54,789
unit a head a unit is a way of taking an

00:04:49,780 --> 00:04:58,090
existing header file and producing a CMI

00:04:54,789 --> 00:04:59,919
from it now that's a simpler conversion

00:04:58,090 --> 00:05:02,889
because you basically point the compiler

00:04:59,919 --> 00:05:04,990
at your header file and that's going to

00:05:02,889 --> 00:05:06,789
be essentially it but you don't get all

00:05:04,990 --> 00:05:08,590
the benefits of modules and you can't do

00:05:06,789 --> 00:05:09,789
it to every header file the header file

00:05:08,590 --> 00:05:12,759
have to have has to have certain

00:05:09,789 --> 00:05:14,050
constraints in particular it doesn't it

00:05:12,759 --> 00:05:16,629
shouldn't be a header file that's

00:05:14,050 --> 00:05:26,710
extended to black out you know templated

00:05:16,629 --> 00:05:28,479
code via macros because history so the

00:05:26,710 --> 00:05:31,090
tiny XML to header files will be ok for

00:05:28,479 --> 00:05:32,740
this you can explicitly import them in

00:05:31,090 --> 00:05:34,629
the source code you could say import and

00:05:32,740 --> 00:05:35,919
then a thing that looks like a header

00:05:34,629 --> 00:05:38,169
name because it is a header name of the

00:05:35,919 --> 00:05:39,370
semicolon on the end it guess it starts

00:05:38,169 --> 00:05:41,020
off being a bit strange putting

00:05:39,370 --> 00:05:42,639
semicolons on the end of something that

00:05:41,020 --> 00:05:47,580
conceptually you think is a header file

00:05:42,639 --> 00:05:50,590
B gaze to it or they can be implicitly

00:05:47,580 --> 00:05:52,719
imported which is where you've told the

00:05:50,590 --> 00:05:55,960
bill system and compiler that when it

00:05:52,719 --> 00:05:57,879
sees a hash include of tiny XML - it

00:05:55,960 --> 00:06:00,490
should treat that as if it was an import

00:05:57,879 --> 00:06:03,819
and read the CMI and then it won't

00:06:00,490 --> 00:06:06,190
textually include the tiny XML - it'll

00:06:03,819 --> 00:06:08,370
just go off and read the CMI and that's

00:06:06,190 --> 00:06:13,029
one way of improving the build speed

00:06:08,370 --> 00:06:15,909
we're using header units so how do we do

00:06:13,029 --> 00:06:17,710
this step one is to we're going to

00:06:15,909 --> 00:06:24,310
create a we're going to turn tiny at

00:06:17,710 --> 00:06:26,319
tiny XML to into a header unit now the

00:06:24,310 --> 00:06:29,650
first thing that I need to do is create

00:06:26,319 --> 00:06:31,870
some kind of representation of how the

00:06:29,650 --> 00:06:34,750
file names relate to module names and

00:06:31,870 --> 00:06:39,430
that's called a mapping file in the GCC

00:06:34,750 --> 00:06:41,620
implementation so here's the head and

00:06:39,430 --> 00:06:43,419
header name tiny axonal - dot H and it

00:06:41,620 --> 00:06:45,190
has to look like a file name with a dot

00:06:43,419 --> 00:06:48,219
slash in front of it because otherwise

00:06:45,190 --> 00:06:49,670
it could be a valid module name called

00:06:48,219 --> 00:06:51,200
tiny XML -

00:06:49,670 --> 00:06:53,750
and that's not what we're trying to do

00:06:51,200 --> 00:06:57,110
here and we're going to put the head the

00:06:53,750 --> 00:07:01,460
CMI into this file here cool tiny XML

00:06:57,110 --> 00:07:03,170
2.8 GCN and this dollar group thing is

00:07:01,460 --> 00:07:07,940
just saying oh and put all the cm eyes

00:07:03,170 --> 00:07:09,170
in dot the current directory then the

00:07:07,940 --> 00:07:11,810
other changes we have to make is to

00:07:09,170 --> 00:07:14,810
update the make file by essentially

00:07:11,810 --> 00:07:16,730
telling with compiler that we should

00:07:14,810 --> 00:07:18,500
that it should look at that mapping file

00:07:16,730 --> 00:07:21,590
so that's what this module mapper equals

00:07:18,500 --> 00:07:23,330
mapping is I should probably have added

00:07:21,590 --> 00:07:26,030
these two flags rather than see X X

00:07:23,330 --> 00:07:29,990
variable itself but oh well if in mind

00:07:26,030 --> 00:07:32,420
and also adding this other option note

00:07:29,990 --> 00:07:34,370
include translate because if this all

00:07:32,420 --> 00:07:36,080
goes well it'll behave just as if we

00:07:34,370 --> 00:07:37,820
hash included it so unless there's

00:07:36,080 --> 00:07:40,750
something telling us that it did this

00:07:37,820 --> 00:07:44,060
translation we would be none the wiser

00:07:40,750 --> 00:07:46,280
and we need to send them add a root rule

00:07:44,060 --> 00:07:48,920
to the head of up to the make file to

00:07:46,280 --> 00:07:51,830
say that the GCM file is dependent on

00:07:48,920 --> 00:07:53,930
that on the dot H file and this is how

00:07:51,830 --> 00:07:56,030
you build it invoke the compiler add

00:07:53,930 --> 00:07:59,300
this other option if module header to

00:07:56,030 --> 00:08:00,920
say this file I'm feeding you is is a

00:07:59,300 --> 00:08:03,530
header there's a header file and you

00:08:00,920 --> 00:08:05,240
should turn it into a header unit as

00:08:03,530 --> 00:08:08,390
normal make comes here with the dollar

00:08:05,240 --> 00:08:10,040
angle brackets oh yeah and then the

00:08:08,390 --> 00:08:11,420
other changes on the make file is

00:08:10,040 --> 00:08:15,800
obviously there's a dependency change

00:08:11,420 --> 00:08:19,130
now that building the like the library

00:08:15,800 --> 00:08:21,170
implementation file is not dependent on

00:08:19,130 --> 00:08:24,770
the dot H file anymore but dependent on

00:08:21,170 --> 00:08:26,000
the GCM so we don't take any changes to

00:08:24,770 --> 00:08:28,460
source code at this point we're just

00:08:26,000 --> 00:08:29,870
telling the bill system there's some

00:08:28,460 --> 00:08:31,850
more dependencies and creating this

00:08:29,870 --> 00:08:37,250
other file that the compiler and the

00:08:31,850 --> 00:08:39,110
build system know about so this would

00:08:37,250 --> 00:08:43,640
have been animated but I'll give me the

00:08:39,110 --> 00:08:45,560
punchline away now nevermind so here we

00:08:43,640 --> 00:08:49,280
build the header file at the foot of the

00:08:45,560 --> 00:08:53,440
first step and then we build a CPP for

00:08:49,280 --> 00:08:55,940
the implementation file and we get this

00:08:53,440 --> 00:08:58,940
diagnostic note to tell us that oh the

00:08:55,940 --> 00:09:02,970
hash include' that was in tiny XML - dot

00:08:58,940 --> 00:09:04,410
CPP got turned into an import and

00:09:02,970 --> 00:09:07,350
our only indication that this actually

00:09:04,410 --> 00:09:08,879
worked and I got it right hooray then

00:09:07,350 --> 00:09:12,540
that turned into libraries before and

00:09:08,879 --> 00:09:14,399
then we build the the the test program

00:09:12,540 --> 00:09:15,930
and you'll notice that actually we've

00:09:14,399 --> 00:09:17,790
got three compiles going on here was

00:09:15,930 --> 00:09:20,850
before we had two compiles because

00:09:17,790 --> 00:09:25,430
obviously this first step here didn't

00:09:20,850 --> 00:09:28,829
happen let's go back there we go

00:09:25,430 --> 00:09:30,810
right so tiny XML two dot H gets tend to

00:09:28,829 --> 00:09:34,129
turned into an import and then we get

00:09:30,810 --> 00:09:34,129
this error thing happening at the bottom

00:09:34,160 --> 00:09:45,420
and this is actually an interesting

00:09:41,069 --> 00:09:46,680
error because it shows some of the

00:09:45,420 --> 00:09:48,029
behavior of what's going to happen

00:09:46,680 --> 00:09:51,120
what's happening behind the scenes when

00:09:48,029 --> 00:09:51,480
you're dealing with header units the

00:09:51,120 --> 00:09:53,250
Long's

00:09:51,480 --> 00:09:57,689
the short story of this is actually as a

00:09:53,250 --> 00:09:59,399
compiler bug but you'll see it's it's

00:09:57,689 --> 00:10:01,110
got confused bit by pointing at the same

00:09:59,399 --> 00:10:03,389
type def twice new and this is a bit

00:10:01,110 --> 00:10:05,579
strange why is the same thing problem

00:10:03,389 --> 00:10:09,269
particularly the type death but what's

00:10:05,579 --> 00:10:10,709
actually going on here is I'm going to

00:10:09,269 --> 00:10:16,319
take a slightly different example with a

00:10:10,709 --> 00:10:18,449
class because that you can't multiple II

00:10:16,319 --> 00:10:20,519
define whereas type deaths of allowed to

00:10:18,449 --> 00:10:22,769
be multiple eat declared as long as they

00:10:20,519 --> 00:10:30,559
declare to the same type you're all okay

00:10:22,769 --> 00:10:30,559
hence compiler bug then here in in

00:10:31,250 --> 00:10:36,839
header and you define your class in a

00:10:34,410 --> 00:10:39,389
header file you would include it in some

00:10:36,839 --> 00:10:41,040
other header file that for instance will

00:10:39,389 --> 00:10:43,079
also make it visible use it some

00:10:41,040 --> 00:10:44,910
something and then you'll source file

00:10:43,079 --> 00:10:47,069
may include both those two header files

00:10:44,910 --> 00:10:49,290
and of course this thing here when you

00:10:47,069 --> 00:10:51,750
do the second include you're gonna get a

00:10:49,290 --> 00:10:53,220
compile error at this point because

00:10:51,750 --> 00:10:55,579
you've got a multiple definition of

00:10:53,220 --> 00:10:55,579
widget

00:10:58,040 --> 00:11:06,110
so what you do you put header protection

00:11:00,590 --> 00:11:08,390
around it and then we're all okay

00:11:06,110 --> 00:11:10,910
and what's happening here of course is

00:11:08,390 --> 00:11:13,220
that you've preventing the textual

00:11:10,910 --> 00:11:15,770
stamping out of the second nested the

00:11:13,220 --> 00:11:19,580
nested include a widget here by the by

00:11:15,770 --> 00:11:22,010
its include guards so the pros that this

00:11:19,580 --> 00:11:27,440
the compiler only seems one set of

00:11:22,010 --> 00:11:29,570
tokens for widget header units are

00:11:27,440 --> 00:11:32,990
slightly different in that include

00:11:29,570 --> 00:11:34,550
guards essentially don't work on them so

00:11:32,990 --> 00:11:36,050
this is the code that I just showed you

00:11:34,550 --> 00:11:37,670
here with the header guards and a hash

00:11:36,050 --> 00:11:41,150
include' and we've turned this hash

00:11:37,670 --> 00:11:44,620
include' into a hand into an import so

00:11:41,150 --> 00:11:47,690
what's actually happened here is that

00:11:44,620 --> 00:11:51,410
we've texted included the widget header

00:11:47,690 --> 00:11:53,510
file seen a definition of widget from

00:11:51,410 --> 00:11:57,470
here and we now know about the widget

00:11:53,510 --> 00:11:59,750
class but we've also imported food or

00:11:57,470 --> 00:12:01,670
age which itself had textually included

00:11:59,750 --> 00:12:04,130
widget and because that wasn't a header

00:12:01,670 --> 00:12:07,760
file ahead of unit that point it itself

00:12:04,130 --> 00:12:10,190
has made has made this definition of

00:12:07,760 --> 00:12:12,230
widget visible and so we end up here at

00:12:10,190 --> 00:12:14,090
this import having another definition of

00:12:12,230 --> 00:12:16,520
widget and the compiler has to now go

00:12:14,090 --> 00:12:18,800
and merge these things and figure out oh

00:12:16,520 --> 00:12:20,540
these are actually the same widget I've

00:12:18,800 --> 00:12:23,440
only got one entity here so I haven't

00:12:20,540 --> 00:12:28,310
got any ambiguity now this kind of

00:12:23,440 --> 00:12:30,290
merging of entities is the thing that

00:12:28,310 --> 00:12:33,230
happens we've had a header unit because

00:12:30,290 --> 00:12:35,360
there's some header files and it's now

00:12:33,230 --> 00:12:36,950
happening in the compiler rather than

00:12:35,360 --> 00:12:38,540
happening the linker where the linker

00:12:36,950 --> 00:12:39,680
goes above these are accomplices these

00:12:38,540 --> 00:12:41,600
have to be the same I'm just going to

00:12:39,680 --> 00:12:44,600
assume it and weird things happen if

00:12:41,600 --> 00:12:46,370
they're not the compiler now has a

00:12:44,600 --> 00:12:48,050
chance of actually detecting that these

00:12:46,370 --> 00:12:50,210
things you've said were the same are not

00:12:48,050 --> 00:12:53,660
the same that's quality of inferno

00:12:50,210 --> 00:12:55,040
implementation issue anyway so at the

00:12:53,660 --> 00:12:56,990
point I got that error I wondered who

00:12:55,040 --> 00:12:58,430
know precisely how robust this compiler

00:12:56,990 --> 00:13:02,950
was and whether it was a bit too early

00:12:58,430 --> 00:13:05,810
for a prime time so I was having I think

00:13:02,950 --> 00:13:10,470
anyway

00:13:05,810 --> 00:13:12,480
several compiler fixes later hooray

00:13:10,470 --> 00:13:14,580
it doesn't give us this error at the bar

00:13:12,480 --> 00:13:16,140
at the bottom and I actually added than

00:13:14,580 --> 00:13:17,370
the noting through translate at that

00:13:16,140 --> 00:13:19,020
point because I realized I hadn't

00:13:17,370 --> 00:13:21,810
actually got any indication that we've

00:13:19,020 --> 00:13:24,750
got the translation happen we run the

00:13:21,810 --> 00:13:28,410
run the tests everything runs the test

00:13:24,750 --> 00:13:35,450
pass we're all good okay so we've now

00:13:28,410 --> 00:13:35,450
got a header unit there any questions or

00:13:37,130 --> 00:13:41,270
do you want to talk to the talk to the

00:13:39,089 --> 00:13:41,270
mic

00:13:45,490 --> 00:13:51,269
I was just knowing the position

00:13:48,579 --> 00:13:54,300
independent code like just curious

00:13:51,269 --> 00:14:00,759
mm-hmm that was on the original library

00:13:54,300 --> 00:14:05,170
so the XML library builders pick so that

00:14:00,759 --> 00:14:07,509
that's why that flag is there whether

00:14:05,170 --> 00:14:09,939
those those kind of flags affect the

00:14:07,509 --> 00:14:12,910
shape of the CMI is rather dependent on

00:14:09,939 --> 00:14:14,740
what the flag is I've taken a more

00:14:12,910 --> 00:14:16,899
relaxed attitude than that at the moment

00:14:14,740 --> 00:14:19,119
now I when I first started I was quite

00:14:16,899 --> 00:14:21,970
paranoid of avoiding problems and

00:14:19,119 --> 00:14:23,379
forcing them all to be the same but he's

00:14:21,970 --> 00:14:24,819
only the pick one goes all the way to

00:14:23,379 --> 00:14:26,439
the back end of the compiler so the

00:14:24,819 --> 00:14:28,809
front end doesn't really need to know

00:14:26,439 --> 00:14:30,249
about it the library may generate

00:14:28,809 --> 00:14:32,230
different things because it's a hash

00:14:30,249 --> 00:14:34,329
define that tells it but this pick is on

00:14:32,230 --> 00:14:37,019
and it may have different Azzam inserts

00:14:34,329 --> 00:14:37,019
your mileage may vary

00:14:37,649 --> 00:14:45,399
okay so step number two we can turn this

00:14:43,269 --> 00:14:46,809
into an explicit header unit this is

00:14:45,399 --> 00:14:48,850
where we start changing source code we

00:14:46,809 --> 00:14:53,350
changed the hash include' tiny XML to

00:14:48,850 --> 00:14:54,509
dot H in to import tiny XML to dot

00:14:53,350 --> 00:14:56,559
actually we do that in the

00:14:54,509 --> 00:15:00,490
implementation file of the library and

00:14:56,559 --> 00:15:02,740
we can do that in XML test we don't

00:15:00,490 --> 00:15:04,629
change that make the bill system at all

00:15:02,740 --> 00:15:06,759
at this point then at this step because

00:15:04,629 --> 00:15:09,549
we're just because that's just the same

00:15:06,759 --> 00:15:11,860
he needs to build the the header unit

00:15:09,549 --> 00:15:13,420
and then compile the sources but you'll

00:15:11,860 --> 00:15:14,920
notice here what I wrote I can make I'm

00:15:13,420 --> 00:15:16,149
not rebuilding the head of unit because

00:15:14,920 --> 00:15:18,790
I didn't change anything in the header

00:15:16,149 --> 00:15:21,399
unit it's already there but I didn't

00:15:18,790 --> 00:15:23,110
clean do a clean build at this point so

00:15:21,399 --> 00:15:27,519
I've got the two trying to compilations

00:15:23,110 --> 00:15:29,709
of the of the library interface unit and

00:15:27,519 --> 00:15:31,329
of the test program and you see there's

00:15:29,709 --> 00:15:32,860
there's no comment there's no note that

00:15:31,329 --> 00:15:35,920
include translation happened because I

00:15:32,860 --> 00:15:38,740
explicitly said do the thing and array

00:15:35,920 --> 00:15:41,249
everything passes we're good so we can

00:15:38,740 --> 00:15:41,249
now relax

00:15:43,010 --> 00:15:49,699
so the next bit is the name the main

00:15:46,279 --> 00:15:52,459
event of turning it into a named module

00:15:49,699 --> 00:15:55,220
which is where we want to all get to and

00:15:52,459 --> 00:15:58,420
just to recap on what others talks have

00:15:55,220 --> 00:16:01,220
talked about is that a named module

00:15:58,420 --> 00:16:03,800
looks like this you've got a module

00:16:01,220 --> 00:16:05,420
semicolon the front followed by a global

00:16:03,800 --> 00:16:08,329
module fragment where you put all your

00:16:05,420 --> 00:16:11,029
hash includes okay and that legacy hash

00:16:08,329 --> 00:16:13,310
includes stuff goes there if you have no

00:16:11,029 --> 00:16:15,079
legacy hash include' stuff you don't

00:16:13,310 --> 00:16:17,870
need the module semicolon you can just

00:16:15,079 --> 00:16:19,610
start with the module purview where you

00:16:17,870 --> 00:16:22,040
say module and then the name of the

00:16:19,610 --> 00:16:23,930
module and if it's an interface unit you

00:16:22,040 --> 00:16:26,930
will put the export here to say this is

00:16:23,930 --> 00:16:30,139
an interface defining the interface of

00:16:26,930 --> 00:16:32,000
tiny XML - and the module to think all

00:16:30,139 --> 00:16:34,100
the module purview starts at this point

00:16:32,000 --> 00:16:36,079
so everything after this is regular

00:16:34,100 --> 00:16:39,769
declarations and they're owned by that

00:16:36,079 --> 00:16:42,320
module and you can put imports explicit

00:16:39,769 --> 00:16:44,899
imports it at the beginning of this

00:16:42,320 --> 00:16:49,220
purview imports of both other named

00:16:44,899 --> 00:16:50,720
modules and imports of header units you

00:16:49,220 --> 00:16:52,010
can put them up here in the global

00:16:50,720 --> 00:16:54,050
module fragment but there's no

00:16:52,010 --> 00:16:59,269
difference so you may as well put them

00:16:54,050 --> 00:17:00,769
down here the immediate question you

00:16:59,269 --> 00:17:03,290
need to ask value yourself to yourself

00:17:00,769 --> 00:17:05,299
is whether the implementation whether

00:17:03,290 --> 00:17:08,720
your header like your header file is

00:17:05,299 --> 00:17:11,089
making header making macros visible to

00:17:08,720 --> 00:17:14,959
the user because at this point they will

00:17:11,089 --> 00:17:21,620
stop working so if they do you need to

00:17:14,959 --> 00:17:22,880
redesign your API or stop that's one of

00:17:21,620 --> 00:17:25,309
the significant differences between

00:17:22,880 --> 00:17:28,820
header units and named modules is header

00:17:25,309 --> 00:17:30,350
units preserve the macro behavior of

00:17:28,820 --> 00:17:33,380
header files and make those macros

00:17:30,350 --> 00:17:35,870
visible but they don't unlike header

00:17:33,380 --> 00:17:38,809
files they don't pay attention to macros

00:17:35,870 --> 00:17:41,780
that we defined before you imported them

00:17:38,809 --> 00:17:44,000
so they're somewhat isolated from macro

00:17:41,780 --> 00:17:46,190
pollution but they will pollute other

00:17:44,000 --> 00:17:48,410
cut other other textual code that

00:17:46,190 --> 00:17:50,360
appears after them after their import

00:17:48,410 --> 00:17:55,760
with the macros that they themselves

00:17:50,360 --> 00:17:56,750
exported or made visible so pick a

00:17:55,760 --> 00:17:58,610
module name

00:17:56,750 --> 00:18:01,010
see this case I'm gonna use tiny XML too

00:17:58,610 --> 00:18:04,040
because that's the name I have and then

00:18:01,010 --> 00:18:06,560
I'm gonna rename the header file to a

00:18:04,040 --> 00:18:08,030
source file because it's the source file

00:18:06,560 --> 00:18:10,970
now it's no longer a header file

00:18:08,030 --> 00:18:14,180
I think produces an object file so I've

00:18:10,970 --> 00:18:17,480
just renamed it tiny XML to - mcvp

00:18:14,180 --> 00:18:19,820
I don't see the need to change it to a

00:18:17,480 --> 00:18:21,440
different suffix there is if you change

00:18:19,820 --> 00:18:22,940
it to a different suffix a new suffix

00:18:21,440 --> 00:18:25,820
you have to teach all your tools about

00:18:22,940 --> 00:18:27,920
the new suffix and besides if you have a

00:18:25,820 --> 00:18:30,140
new suffix they leads to the thinking

00:18:27,920 --> 00:18:32,120
that I can it leads to breakage on build

00:18:30,140 --> 00:18:33,500
systems that assume they can just take

00:18:32,120 --> 00:18:36,380
the suffix off and replace it with the

00:18:33,500 --> 00:18:38,980
dotto or D or whatever to get dependency

00:18:36,380 --> 00:18:41,660
file or the name of the object file

00:18:38,980 --> 00:18:43,220
there are other ways of saying of making

00:18:41,660 --> 00:18:45,590
it clear that this is an this is an

00:18:43,220 --> 00:18:47,990
implementation file - aim is there if

00:18:45,590 --> 00:18:49,610
you file system understands it's not

00:18:47,990 --> 00:18:52,880
case folding you but a capital letter

00:18:49,610 --> 00:18:56,510
may be leaning with a prefix there's a

00:18:52,880 --> 00:18:59,690
lot of scope there this one worked for

00:18:56,510 --> 00:19:02,870
me and I'm gonna be to edit the

00:18:59,690 --> 00:19:06,050
interface file so the interface file

00:19:02,870 --> 00:19:10,160
tiny XML - dot CPP tiny available - -

00:19:06,050 --> 00:19:11,360
indoor CPP we can take out the FDF

00:19:10,160 --> 00:19:11,870
header protection we don't need it

00:19:11,360 --> 00:19:14,300
anymore

00:19:11,870 --> 00:19:17,320
it's just confusing and we want to

00:19:14,300 --> 00:19:19,730
insert a global module fragment into it

00:19:17,320 --> 00:19:21,830
so that means that I mean put a module

00:19:19,730 --> 00:19:28,190
semicolon right at the beginning of it

00:19:21,830 --> 00:19:30,800
and then we need to put the module

00:19:28,190 --> 00:19:32,660
purview to start after it's inked done

00:19:30,800 --> 00:19:35,300
all this hash includes of stood i/o and

00:19:32,660 --> 00:19:38,210
whatnot so after those we can put export

00:19:35,300 --> 00:19:40,580
module tiny XML - to start the module

00:19:38,210 --> 00:19:41,810
proper and to make things simple at this

00:19:40,580 --> 00:19:43,880
point we're just going to export

00:19:41,810 --> 00:19:45,170
everything from the module everything

00:19:43,880 --> 00:19:46,760
was visible before when it was a header

00:19:45,170 --> 00:19:47,270
file so exporting everything at this

00:19:46,760 --> 00:19:49,520
point

00:19:47,270 --> 00:19:54,590
is not gonna make more things visible to

00:19:49,520 --> 00:19:57,440
the user and we can do that by export

00:19:54,590 --> 00:19:59,630
squiggly braces just after this module

00:19:57,440 --> 00:20:01,970
declaration and put a squiggly brace

00:19:59,630 --> 00:20:04,010
close at the end so this is one of the

00:20:01,970 --> 00:20:05,570
ways of saying export this is way of

00:20:04,010 --> 00:20:07,250
saying export a block of code in a

00:20:05,570 --> 00:20:08,220
similar way that you can give see

00:20:07,250 --> 00:20:10,350
linkage to a box

00:20:08,220 --> 00:20:12,390
so with extern see or whatever it's

00:20:10,350 --> 00:20:20,120
exactly the same idea the these squiggly

00:20:12,390 --> 00:20:23,010
braces are not a scope right change the

00:20:20,120 --> 00:20:25,260
implementation file we've now got tiny

00:20:23,010 --> 00:20:27,000
XML - dot CPP which was the library

00:20:25,260 --> 00:20:30,510
implementation before is now a module

00:20:27,000 --> 00:20:33,510
implementation we take out the import

00:20:30,510 --> 00:20:35,520
tiny Maxell - dot H that was there in

00:20:33,510 --> 00:20:37,620
module semicolon at the start it's got a

00:20:35,520 --> 00:20:39,900
bunch of hash includes and then we put

00:20:37,620 --> 00:20:42,030
module tiny XML - after those includes

00:20:39,900 --> 00:20:44,340
without the export there so this is

00:20:42,030 --> 00:20:46,860
saying this is an implementation unities

00:20:44,340 --> 00:20:48,570
it's going to stamp out some code but

00:20:46,860 --> 00:20:52,289
otherwise these contents are not visible

00:20:48,570 --> 00:20:54,690
to importers of the module and we edit

00:20:52,289 --> 00:20:57,740
the test program so not import the

00:20:54,690 --> 00:21:01,770
header unit but import this named module

00:20:57,740 --> 00:21:04,110
that's a fairly simple change right oh

00:21:01,770 --> 00:21:05,700
yes and now we have to change bits of

00:21:04,110 --> 00:21:09,059
the build system because we no longer

00:21:05,700 --> 00:21:11,580
have a header unit module we have a

00:21:09,059 --> 00:21:12,960
named module so we changed the mapping

00:21:11,580 --> 00:21:14,820
file and we probably don't want to put

00:21:12,960 --> 00:21:16,740
it in the same place as before because

00:21:14,820 --> 00:21:20,490
that would just be confusing so we'll

00:21:16,740 --> 00:21:23,700
put it in a different file and the name

00:21:20,490 --> 00:21:25,320
of the module is just tiny XML - and we

00:21:23,700 --> 00:21:26,610
have to update the make file by ripping

00:21:25,320 --> 00:21:28,650
bits out of it because of course now

00:21:26,610 --> 00:21:30,630
that the GCM file there's a different

00:21:28,650 --> 00:21:34,250
name so we change the name there and

00:21:30,630 --> 00:21:36,570
it's dependent on the - m dot o file

00:21:34,250 --> 00:21:40,500
this is a bit of a sleight of hand in

00:21:36,570 --> 00:21:43,350
make because it's produced at the same

00:21:40,500 --> 00:21:45,210
time as the dot dot o file but if I do

00:21:43,350 --> 00:21:47,070
do it this way make will already know

00:21:45,210 --> 00:21:48,990
have an implicit rule for generating a

00:21:47,070 --> 00:21:51,809
dot o from a dot CPP so I don't have to

00:21:48,990 --> 00:21:54,090
teach it any more stuff I can just say

00:21:51,809 --> 00:21:56,309
that this GCM is dependent on the dot o

00:21:54,090 --> 00:21:58,320
knowing that when dodos produced this

00:21:56,309 --> 00:22:00,210
GCM is produced but I have to explicitly

00:21:58,320 --> 00:22:02,640
sell make it doesn't do it doesn't need

00:22:00,210 --> 00:22:04,080
to do anything because otherwise make as

00:22:02,640 --> 00:22:06,210
often tries to find an expert an

00:22:04,080 --> 00:22:09,390
implicit role and it'll fail because it

00:22:06,210 --> 00:22:11,400
doesn't have one no longer need this

00:22:09,390 --> 00:22:14,250
explicit build of header unit doesn't

00:22:11,400 --> 00:22:17,399
exist and a bit of changing in the

00:22:14,250 --> 00:22:19,799
dependencies of the interface of the

00:22:17,399 --> 00:22:20,700
implementation file and of course now

00:22:19,799 --> 00:22:22,260
I've got another object

00:22:20,700 --> 00:22:23,580
file that I need to add to the libraries

00:22:22,260 --> 00:22:26,900
that the library's now actually contain

00:22:23,580 --> 00:22:31,340
contains to object files rather than one

00:22:26,900 --> 00:22:34,940
and I build it and it builds the

00:22:31,340 --> 00:22:37,200
interface file quite happily array

00:22:34,940 --> 00:22:42,210
starts building the implementation file

00:22:37,200 --> 00:22:46,350
and I get a whole slew of errors this is

00:22:42,210 --> 00:22:51,810
not unsurprising and I will go through

00:22:46,350 --> 00:22:53,460
why I'm getting those errors and you

00:22:51,810 --> 00:22:55,580
will become convinced the reason behind

00:22:53,460 --> 00:22:59,280
those errors are good things

00:22:55,580 --> 00:23:02,940
so first error oh right yeah

00:22:59,280 --> 00:23:06,090
okay picture first error was this one

00:23:02,940 --> 00:23:10,070
error vs n printf was not declared in

00:23:06,090 --> 00:23:13,980
this scope so what happened here is that

00:23:10,070 --> 00:23:16,470
tiny X the the implementation file who

00:23:13,980 --> 00:23:18,270
was relying on a hash include that had

00:23:16,470 --> 00:23:19,320
been included by the header file but

00:23:18,270 --> 00:23:20,970
wasn't part of the header files

00:23:19,320 --> 00:23:23,570
interface because he couldn't do

00:23:20,970 --> 00:23:28,410
anything else he hash include' stood i/o

00:23:23,570 --> 00:23:30,750
which gave a 8v this printf function but

00:23:28,410 --> 00:23:33,480
now that the name module that visibility

00:23:30,750 --> 00:23:37,860
of the studio that was included in the

00:23:33,480 --> 00:23:40,290
header you in the interfaces on in the

00:23:37,860 --> 00:23:42,270
module interface was not exported to

00:23:40,290 --> 00:23:44,580
anything that in the outside of that

00:23:42,270 --> 00:23:46,940
translation unit so no wonder when when

00:23:44,580 --> 00:23:49,140
tiny XML - when the implementation file

00:23:46,940 --> 00:23:52,050
looks up for this name it can't find

00:23:49,140 --> 00:23:53,850
anything a similar in xml test that had

00:23:52,050 --> 00:23:55,260
the same problem it was relying on the

00:23:53,850 --> 00:23:58,020
hash include' so the obvious solution is

00:23:55,260 --> 00:24:00,540
well you have to explicitly include all

00:23:58,020 --> 00:24:02,370
the things you depend on so this problem

00:24:00,540 --> 00:24:05,670
with implicit dependence is that you can

00:24:02,370 --> 00:24:08,370
get through nested header files goes

00:24:05,670 --> 00:24:14,400
away and your dependencies become

00:24:08,370 --> 00:24:16,440
explicit so I sort of that not declared

00:24:14,400 --> 00:24:18,960
in this scope problem the next one is

00:24:16,440 --> 00:24:22,590
this ticks ml assert was not declared in

00:24:18,960 --> 00:24:23,910
this scope and because it's in uppercase

00:24:22,590 --> 00:24:24,480
you assume it's a macro and you're

00:24:23,910 --> 00:24:26,790
correct

00:24:24,480 --> 00:24:30,240
it's an assert macro that's used

00:24:26,790 --> 00:24:33,120
internally in the interface file now and

00:24:30,240 --> 00:24:33,950
was also used in the implementation file

00:24:33,120 --> 00:24:36,080
but of course think

00:24:33,950 --> 00:24:39,320
- profile can't see the macros from the

00:24:36,080 --> 00:24:40,850
interface file so we can either abstract

00:24:39,320 --> 00:24:43,940
that out into an internal header file

00:24:40,850 --> 00:24:46,610
and include it in both places or we can

00:24:43,940 --> 00:24:49,340
just cut and paste it if we're lazy I

00:24:46,610 --> 00:24:51,650
was lazy I cut and pasted it because it

00:24:49,340 --> 00:24:54,170
was one macro and I incurred some

00:24:51,650 --> 00:25:00,110
technical debt which I will pay back by

00:24:54,170 --> 00:25:02,960
the end of this talk and of course the

00:25:00,110 --> 00:25:04,610
xml tests the test program tested this

00:25:02,960 --> 00:25:06,410
macro but it actually tested this macro

00:25:04,610 --> 00:25:08,930
past but of course this macro was being

00:25:06,410 --> 00:25:10,670
tested implicitly because it was in all

00:25:08,930 --> 00:25:13,340
the bits of code files that were being

00:25:10,670 --> 00:25:15,140
tested by the xml test you don't really

00:25:13,340 --> 00:25:16,760
need an explicit test in that so I just

00:25:15,140 --> 00:25:19,160
do need to do but you can do the same

00:25:16,760 --> 00:25:24,530
thing if you abstracted into an internal

00:25:19,160 --> 00:25:28,010
header file ok fixed number three which

00:25:24,530 --> 00:25:29,960
this this tiny XML to maximum depth it

00:25:28,010 --> 00:25:32,330
was not declared in this scope what was

00:25:29,960 --> 00:25:35,750
going on here is that tiny X not the the

00:25:32,330 --> 00:25:41,570
the header file contains this internal

00:25:35,750 --> 00:25:43,340
linkage constant very constant that was

00:25:41,570 --> 00:25:46,490
used only inside the library as far as I

00:25:43,340 --> 00:25:48,350
can tell but I'm not quite sure but this

00:25:46,490 --> 00:25:52,220
is the thing went mod putting internal

00:25:48,350 --> 00:25:54,170
linkage things in header files means

00:25:52,220 --> 00:25:55,870
they can't turn into they can't because

00:25:54,170 --> 00:25:58,580
that can't be explicitly imported it

00:25:55,870 --> 00:25:59,960
explicitly exported so this is actually

00:25:58,580 --> 00:26:01,810
a Kannada compiler bug where it was

00:25:59,960 --> 00:26:04,250
failing to detect this problem when I

00:26:01,810 --> 00:26:06,110
compiled the interface it should have

00:26:04,250 --> 00:26:08,420
shouted I mean say hey you you're trying

00:26:06,110 --> 00:26:13,070
to export an internal linkage thing stop

00:26:08,420 --> 00:26:15,650
I haven't got all the errors in yet nor

00:26:13,070 --> 00:26:18,170
the error checking in it didn't export

00:26:15,650 --> 00:26:19,580
it it wasn't visible so at least some

00:26:18,170 --> 00:26:22,570
goodness happened something was right

00:26:19,580 --> 00:26:24,890
and we can either make it not external

00:26:22,570 --> 00:26:26,930
sorry not an internal English thing by

00:26:24,890 --> 00:26:28,640
dropping the static or we could to make

00:26:26,930 --> 00:26:33,340
it a nun scope key numerated value

00:26:28,640 --> 00:26:36,200
because it's an into that that works or

00:26:33,340 --> 00:26:39,290
if neither of those things are can we

00:26:36,200 --> 00:26:43,120
could have not exported it by closing

00:26:39,290 --> 00:26:45,030
the squiggly brace of the block

00:26:43,120 --> 00:26:47,590
export and reopening it just afterwards

00:26:45,030 --> 00:26:49,150
and then it would have into either

00:26:47,590 --> 00:26:55,480
internal linkage or we could make it

00:26:49,150 --> 00:26:56,740
module linkage by yeah by dropping the

00:26:55,480 --> 00:26:59,500
static it would then get more drilling

00:26:56,740 --> 00:27:01,690
Kitsch for than external linkage anyway

00:26:59,500 --> 00:27:04,470
I chose this last approach because

00:27:01,690 --> 00:27:08,650
that's the one that worked in this case

00:27:04,470 --> 00:27:10,870
right so compile it this time it

00:27:08,650 --> 00:27:12,790
compiles okay and all the tests pass

00:27:10,870 --> 00:27:16,420
hooray we've turned it into a named

00:27:12,790 --> 00:27:24,059
module so there we go was something

00:27:16,420 --> 00:27:24,059
there any other questions at this point

00:27:25,620 --> 00:27:29,429
do you only use the microphone

00:27:32,409 --> 00:27:39,279
on slide 25 could that be constants /

00:27:35,200 --> 00:27:41,379
instead of the enum yeah I mean I can

00:27:39,279 --> 00:27:47,879
say I'm taking an existing library it is

00:27:41,379 --> 00:27:50,799
what it is you know Troy yeah anyway

00:27:47,879 --> 00:27:54,309
right so this library is quite a small

00:27:50,799 --> 00:27:58,149
library it's a few thousand lines of

00:27:54,309 --> 00:27:59,289
code but we've we've maintained it when

00:27:58,149 --> 00:28:02,080
it was ahead of fire we had a header

00:27:59,289 --> 00:28:04,179
file and a source file pair because

00:28:02,080 --> 00:28:07,629
that's how header files and libraries

00:28:04,179 --> 00:28:09,669
work and we've copied that that model

00:28:07,629 --> 00:28:10,899
over into module and with an implement

00:28:09,669 --> 00:28:13,259
interface file and an implementation

00:28:10,899 --> 00:28:16,090
file but we don't really need to do that

00:28:13,259 --> 00:28:20,049
we could put all our implementation in

00:28:16,090 --> 00:28:21,759
one in the single interface file there's

00:28:20,049 --> 00:28:24,549
nothing wrong with it it produces an

00:28:21,759 --> 00:28:26,799
object file we can Stamper him it code

00:28:24,549 --> 00:28:28,480
from it unlike a header file of course

00:28:26,799 --> 00:28:30,159
you can't put things that he met code

00:28:28,480 --> 00:28:31,899
inside it directly inside the header

00:28:30,159 --> 00:28:33,549
file because you get obviously link

00:28:31,899 --> 00:28:37,899
errors that point with multiple

00:28:33,549 --> 00:28:42,840
definitions and so we're going to turn

00:28:37,899 --> 00:28:46,059
it into a single single file module and

00:28:42,840 --> 00:28:48,039
to do that we're essentially undoing

00:28:46,059 --> 00:28:52,119
some of the things we just did to make

00:28:48,039 --> 00:28:54,570
it a named module we could cop it the

00:28:52,119 --> 00:28:58,119
implementation file had some unique

00:28:54,570 --> 00:29:00,249
sorry there we go yeah the

00:28:58,119 --> 00:29:02,679
implementation of tiny XML to dot CPP

00:29:00,249 --> 00:29:04,629
had some unique hash includes that

00:29:02,679 --> 00:29:06,549
weren't in the header file for variant

00:29:04,629 --> 00:29:09,940
or the interface so we need to copy them

00:29:06,549 --> 00:29:11,889
into the interfaces global module

00:29:09,940 --> 00:29:13,960
fragment I think there was one I think

00:29:11,889 --> 00:29:18,009
included new or something I'm not sure

00:29:13,960 --> 00:29:20,019
anyway and then everything after the in

00:29:18,009 --> 00:29:22,149
the implementation file after the module

00:29:20,019 --> 00:29:23,470
declaration which is part of the

00:29:22,149 --> 00:29:25,269
implementation of the module we just

00:29:23,470 --> 00:29:28,509
copy that all that text and stick it

00:29:25,269 --> 00:29:30,690
after the closing squiggly brace of the

00:29:28,509 --> 00:29:34,119
big export blocks that we created and

00:29:30,690 --> 00:29:35,529
then or we can delete the opposite the

00:29:34,119 --> 00:29:37,110
implementation file we don't need it and

00:29:35,529 --> 00:29:40,570
what doesn't contain any implementation

00:29:37,110 --> 00:29:42,090
we don't need and then we simplified

00:29:40,570 --> 00:29:44,590
make far

00:29:42,090 --> 00:29:46,480
we can actually get rid of this implicit

00:29:44,590 --> 00:29:48,880
this this dependency photos that I

00:29:46,480 --> 00:29:50,559
actually put there and then the library

00:29:48,880 --> 00:29:52,059
goes back to being made from one object

00:29:50,559 --> 00:29:53,440
file but this time it's the object file

00:29:52,059 --> 00:29:55,390
that came out of the interface which has

00:29:53,440 --> 00:29:57,340
got this name rather than the object

00:29:55,390 --> 00:29:58,630
file that came in originally the object

00:29:57,340 --> 00:30:00,340
file that came out of a single source

00:29:58,630 --> 00:30:02,710
file this name and we change the

00:30:00,340 --> 00:30:04,179
dependency slightly because now we've

00:30:02,710 --> 00:30:07,179
got the implementation file we need to

00:30:04,179 --> 00:30:09,429
be told we need to tell it about and we

00:30:07,179 --> 00:30:11,320
build it we only get to compile this

00:30:09,429 --> 00:30:15,460
time rather than three so we're back to

00:30:11,320 --> 00:30:18,399
the original to compile to compile job's

00:30:15,460 --> 00:30:21,370
going on burn all the tests and they all

00:30:18,399 --> 00:30:23,350
pass so right we're now actually I'm

00:30:21,370 --> 00:30:25,750
going to get so this is as far as I

00:30:23,350 --> 00:30:27,549
wanted to get because now I can go

00:30:25,750 --> 00:30:29,019
further but it requires more semantic

00:30:27,549 --> 00:30:31,210
information about the library and its

00:30:29,019 --> 00:30:34,029
API and stuff like that and I don't know

00:30:31,210 --> 00:30:35,590
the library very well in fact this is

00:30:34,029 --> 00:30:38,440
about sum total of my knowledge of the

00:30:35,590 --> 00:30:41,380
library um but they're a bunch of stuff

00:30:38,440 --> 00:30:43,029
we can do oh right yes I've repaid the

00:30:41,380 --> 00:30:45,490
technical debt by the way because I

00:30:43,029 --> 00:30:48,220
threw away everything from the

00:30:45,490 --> 00:30:55,870
implementation file that wasn't that was

00:30:48,220 --> 00:30:58,510
before the the declaration here I threw

00:30:55,870 --> 00:31:00,309
away everything but it was a copy of the

00:30:58,510 --> 00:31:01,870
Uni concludes copied the stuff that was

00:31:00,309 --> 00:31:04,179
after that declaration and then threw

00:31:01,870 --> 00:31:06,010
away the rest of it that cut and paste

00:31:04,179 --> 00:31:07,870
job that I did with that macro has now

00:31:06,010 --> 00:31:12,250
gone away I've only got one copy of that

00:31:07,870 --> 00:31:15,880
definition so it was a temporary hack to

00:31:12,250 --> 00:31:18,549
get where I wanted to go so this tick

00:31:15,880 --> 00:31:19,990
some L max element depth I mean and they

00:31:18,549 --> 00:31:22,330
I'm exporting that but that's actually

00:31:19,990 --> 00:31:24,760
an internal link internal piece of the

00:31:22,330 --> 00:31:27,220
library so I don't need to export it

00:31:24,760 --> 00:31:29,350
I can turn everything rather than export

00:31:27,220 --> 00:31:31,090
everything I should just put individual

00:31:29,350 --> 00:31:33,100
exports on the pieces that I want to

00:31:31,090 --> 00:31:35,080
export and not put it on the things that

00:31:33,100 --> 00:31:38,799
I don't want to export and think things

00:31:35,080 --> 00:31:40,450
that they're internal use only the other

00:31:38,799 --> 00:31:42,760
thing that I probably ended up with at

00:31:40,450 --> 00:31:44,139
this point is I've got set are separated

00:31:42,760 --> 00:31:46,389
declarations and definitions because I

00:31:44,139 --> 00:31:49,690
essentially did this by text or pasting

00:31:46,389 --> 00:31:51,870
of code the original library will have

00:31:49,690 --> 00:31:54,420
declared for declared an entry for

00:31:51,870 --> 00:31:55,920
function the original header file I've

00:31:54,420 --> 00:31:57,570
put an export in front of that and

00:31:55,920 --> 00:31:58,980
that's that son total of that

00:31:57,570 --> 00:32:01,170
declaration and then later on I've

00:31:58,980 --> 00:32:05,130
pasted the definition that was in the

00:32:01,170 --> 00:32:08,730
source file of the library I have now

00:32:05,130 --> 00:32:10,080
pasted that in so further on down I've

00:32:08,730 --> 00:32:12,360
got the definition of that file so I've

00:32:10,080 --> 00:32:14,040
declared it you know I've written the

00:32:12,360 --> 00:32:15,780
same thing twice which is probably I

00:32:14,040 --> 00:32:18,290
think you know gonna be a maintenance

00:32:15,780 --> 00:32:20,400
burden I can just put it all in one one

00:32:18,290 --> 00:32:23,040
declaration stick the export on the

00:32:20,400 --> 00:32:24,929
definition move the definition of the

00:32:23,040 --> 00:32:26,550
front if if that's where I need it to be

00:32:24,929 --> 00:32:31,320
there's no particular ordering

00:32:26,550 --> 00:32:33,480
constraint on on where you put the how

00:32:31,320 --> 00:32:37,050
you mix exported and non exported

00:32:33,480 --> 00:32:39,809
entities what you can't do is declare a

00:32:37,050 --> 00:32:41,880
thing and then decide to export it in

00:32:39,809 --> 00:32:44,220
the later declaration you have to export

00:32:41,880 --> 00:32:46,650
it at its first declaration the later

00:32:44,220 --> 00:32:48,210
declarations inherits the export in the

00:32:46,650 --> 00:32:50,850
similar way the Vader declarations of

00:32:48,210 --> 00:32:54,740
functions will inherit and explicit

00:32:50,850 --> 00:32:59,570
static or oh all that kind of thing

00:32:54,740 --> 00:33:02,340
right right okay so this is the git repo

00:32:59,570 --> 00:33:04,350
it's there and this is the mapping onto

00:33:02,340 --> 00:33:07,920
the slides of the ver of the various

00:33:04,350 --> 00:33:09,630
commit messages that are in that you can

00:33:07,920 --> 00:33:11,550
guess I flubbed the first commit on that

00:33:09,630 --> 00:33:14,550
one there's a v2 commit but you'll see

00:33:11,550 --> 00:33:16,590
it as I say thanks to Lee Thomas and for

00:33:14,550 --> 00:33:19,050
providing a library that was suitable to

00:33:16,590 --> 00:33:23,240
convert in the time available if you

00:33:19,050 --> 00:33:24,450
want a real XML to go there to get it

00:33:23,240 --> 00:33:28,350
okay

00:33:24,450 --> 00:33:31,940
so questions

00:33:28,350 --> 00:33:35,029
[Applause]

00:33:31,940 --> 00:33:35,029
[Music]

00:33:35,419 --> 00:33:41,159
hi I didn't attend the other meeting so

00:33:39,179 --> 00:33:44,100
this might be answered but if I want to

00:33:41,159 --> 00:33:46,710
distribute a binary package of this

00:33:44,100 --> 00:33:49,500
library is that a file the only thing

00:33:46,710 --> 00:33:50,970
that I need to distribute the CM I found

00:33:49,500 --> 00:33:58,770
should be thought of as a caching

00:33:50,970 --> 00:34:00,390
artifact it's it it's clearly tied to

00:33:58,770 --> 00:34:02,580
the implementation of the compiler and

00:34:00,390 --> 00:34:05,929
not just the flavor the Karno GCC or

00:34:02,580 --> 00:34:08,399
clang or Microsoft or whatever but in

00:34:05,929 --> 00:34:08,940
EDNOS it's tied to the version of the

00:34:08,399 --> 00:34:12,359
compiler

00:34:08,940 --> 00:34:13,770
I intend tie it to the version of the

00:34:12,359 --> 00:34:15,990
compiler when we have release of

00:34:13,770 --> 00:34:19,290
compilers but obviously it's quite

00:34:15,990 --> 00:34:21,810
tightly coded tight it represents the

00:34:19,290 --> 00:34:25,409
ast so if the ast changes this

00:34:21,810 --> 00:34:27,960
representation changes at the moment

00:34:25,409 --> 00:34:30,210
when you build it it's tight the build

00:34:27,960 --> 00:34:35,280
time of the compiler because that's the

00:34:30,210 --> 00:34:37,169
only way I can say say if if you if you

00:34:35,280 --> 00:34:39,109
don't want to distribute source code

00:34:37,169 --> 00:34:41,700
you're probably going to have to have

00:34:39,109 --> 00:34:43,349
interface files and separate

00:34:41,700 --> 00:34:45,089
implementation files and deliver the

00:34:43,349 --> 00:34:47,849
interface file in the same way you would

00:34:45,089 --> 00:35:00,650
have delivered a header file okay thank

00:34:47,849 --> 00:35:06,540
you I can get it go that one yeah so

00:35:00,650 --> 00:35:12,150
doesn't so what's the dependency line

00:35:06,540 --> 00:35:15,359
looked like for the final library or for

00:35:12,150 --> 00:35:17,339
the final the test file the test the

00:35:15,359 --> 00:35:19,440
test line debug write the test file

00:35:17,339 --> 00:35:22,980
depends on the library it has a

00:35:19,440 --> 00:35:28,140
dependency on the dot a which implicitly

00:35:22,980 --> 00:35:29,730
has which then yes yes yeah I've done a

00:35:28,140 --> 00:35:31,890
bit I have done a bit of sleight of hand

00:35:29,730 --> 00:35:33,300
there in this particular case yeah so

00:35:31,890 --> 00:35:35,940
you dropped the explicitly dependent

00:35:33,300 --> 00:35:38,849
dependency on the B of I or see my

00:35:35,940 --> 00:35:44,049
because you're just relying on

00:35:38,849 --> 00:35:47,319
okay and having an implicit name I'm

00:35:44,049 --> 00:35:51,250
sorry having a implicit name like what

00:35:47,319 --> 00:35:53,799
the name of the the DCM the name of the

00:35:51,250 --> 00:35:55,869
DS yes based on that name I've

00:35:53,799 --> 00:35:58,240
explicitly done that in the mapping file

00:35:55,869 --> 00:36:01,210
okay if I didn't have them mapping file

00:35:58,240 --> 00:36:02,770
you get a default which actually will do

00:36:01,210 --> 00:36:04,390
exactly what I did in that mapping file

00:36:02,770 --> 00:36:06,130
except the root directory not dot

00:36:04,390 --> 00:36:08,500
because cluttering up your current

00:36:06,130 --> 00:36:10,180
working directory with GCMs turned out

00:36:08,500 --> 00:36:10,839
to be annoying so I've just put them in

00:36:10,180 --> 00:36:14,109
a thing called

00:36:10,839 --> 00:36:19,510
cache GCM or something yeah I can't

00:36:14,109 --> 00:36:22,619
remember I saw that you had the

00:36:19,510 --> 00:36:27,430
opportunity to pound include files by

00:36:22,619 --> 00:36:29,520
double quotes we're here the opportunity

00:36:27,430 --> 00:36:32,260
to count include import as well or yes

00:36:29,520 --> 00:36:35,020
yes the answer the actual mechanism

00:36:32,260 --> 00:36:36,490
there is that you wherever you go to

00:36:35,020 --> 00:36:38,200
hash include' you can turn it into an

00:36:36,490 --> 00:36:42,369
import with exactly the same spelling of

00:36:38,200 --> 00:36:45,039
the file name okay and because of things

00:36:42,369 --> 00:36:47,170
like config dot H which you could which

00:36:45,039 --> 00:36:51,130
there could be multiple conflicts on H's

00:36:47,170 --> 00:36:52,210
that get included by different files and

00:36:51,130 --> 00:36:53,950
different directories because they

00:36:52,210 --> 00:36:57,849
including the one in their own directory

00:36:53,950 --> 00:37:00,250
you actually have to resolve that module

00:36:57,849 --> 00:37:03,160
that the header file the header mod the

00:37:00,250 --> 00:37:06,309
header unit name to an actual file on

00:37:03,160 --> 00:37:08,349
disk in so you need the header file

00:37:06,309 --> 00:37:10,270
there so what what actually happens is

00:37:08,349 --> 00:37:11,650
and this is I think I believe it's true

00:37:10,270 --> 00:37:13,720
many other compilers as well because

00:37:11,650 --> 00:37:16,089
it's anyway I can see a good working if

00:37:13,720 --> 00:37:18,160
you resolve that as if it was a header

00:37:16,089 --> 00:37:21,160
file to a file on this somewhere and

00:37:18,160 --> 00:37:23,770
then you import using that fully

00:37:21,160 --> 00:37:25,779
resolved name so in this case they all

00:37:23,770 --> 00:37:27,220
got resolved to dot slash because I use

00:37:25,779 --> 00:37:28,900
single quotes and there was one right

00:37:27,220 --> 00:37:30,819
there in the same directory as the file

00:37:28,900 --> 00:37:32,910
I'm dealing with but if not it would

00:37:30,819 --> 00:37:36,069
have done search the hash include' path

00:37:32,910 --> 00:37:37,630
and found the right would find the one

00:37:36,069 --> 00:37:40,990
you intended and then said you know

00:37:37,630 --> 00:37:42,250
slash did it at a dot slash you're

00:37:40,990 --> 00:37:43,779
answering half of my question there

00:37:42,250 --> 00:37:46,930
which would be do the imports then

00:37:43,779 --> 00:37:48,240
follow system include yes up or do they

00:37:46,930 --> 00:37:50,380
follow

00:37:48,240 --> 00:37:52,539
it depends if you spell that with quotes

00:37:50,380 --> 00:37:54,250
or angle bracket okay what if I don't

00:37:52,539 --> 00:37:55,839
use either if I'm using this module and

00:37:54,250 --> 00:37:57,220
my next question if you want to roll in

00:37:55,839 --> 00:37:59,049
your questions we're gonna be what if I

00:37:57,220 --> 00:38:01,690
have I know the module name is not tied

00:37:59,049 --> 00:38:03,010
to the final name is it possible that I

00:38:01,690 --> 00:38:04,779
could have a collision between a an

00:38:03,010 --> 00:38:06,549
import file name that I'm trying to go

00:38:04,779 --> 00:38:07,839
for that has a module that doesn't match

00:38:06,549 --> 00:38:10,539
and a pound include of something else

00:38:07,839 --> 00:38:13,690
that is the same name so doing the same

00:38:10,539 --> 00:38:15,130
thing okay so I think your question is

00:38:13,690 --> 00:38:18,190
is that is there possibility of

00:38:15,130 --> 00:38:20,829
collisions between header unit names

00:38:18,190 --> 00:38:24,880
which are hash include' from hash

00:38:20,829 --> 00:38:29,700
include' names and their hashes because

00:38:24,880 --> 00:38:32,109
that's where I grew up and named modules

00:38:29,700 --> 00:38:33,849
which looks the same because I could as

00:38:32,109 --> 00:38:35,200
I did mention that the name Mudge I

00:38:33,849 --> 00:38:36,609
could have had it I could make a named

00:38:35,200 --> 00:38:40,089
module against the dotted sequence so

00:38:36,609 --> 00:38:42,039
XML two dot H could be a named module

00:38:40,089 --> 00:38:44,950
name it very stupid one because it'd be

00:38:42,039 --> 00:38:48,130
confusing the implementation that I have

00:38:44,950 --> 00:38:50,010
keeps those distinct and doesn't have

00:38:48,130 --> 00:38:55,509
the possibility of a collision there

00:38:50,010 --> 00:38:58,539
okay all right okay thanks a great

00:38:55,509 --> 00:39:00,640
presentation but my question is in my

00:38:58,539 --> 00:39:02,920
project I have lots and lots of

00:39:00,640 --> 00:39:06,839
libraries that depend on each other all

00:39:02,920 --> 00:39:09,400
the way up to you know an executable and

00:39:06,839 --> 00:39:12,220
converting everything over to modules

00:39:09,400 --> 00:39:12,970
will be a long arduous process and so

00:39:12,220 --> 00:39:16,539
I'm wondering if you have a

00:39:12,970 --> 00:39:19,930
recommendation on a you know top-down or

00:39:16,539 --> 00:39:21,789
bottom-up approach on which you know

00:39:19,930 --> 00:39:23,890
which way I might start converting first

00:39:21,789 --> 00:39:26,799
yeah you can actually do it in either

00:39:23,890 --> 00:39:30,519
way in using different techniques so a

00:39:26,799 --> 00:39:32,589
top-down technique you would use the

00:39:30,519 --> 00:39:34,750
global module fragment quite a lot you

00:39:32,589 --> 00:39:37,569
would put all your original all your

00:39:34,750 --> 00:39:39,789
existing hash includes inside the global

00:39:37,569 --> 00:39:42,730
module fragments and then your new

00:39:39,789 --> 00:39:44,829
module do your new code after the the

00:39:42,730 --> 00:39:46,809
module declaration okay and then

00:39:44,829 --> 00:39:48,759
obviously as things get converted you

00:39:46,809 --> 00:39:50,859
can turn those hash includes to imports

00:39:48,759 --> 00:39:52,599
and believe them there or move them down

00:39:50,859 --> 00:39:55,990
and then eventually your global module

00:39:52,599 --> 00:39:58,059
fragment evaporates right if you went

00:39:55,990 --> 00:40:01,140
the other way and converted the the

00:39:58,059 --> 00:40:03,790
Leafs of your include graph

00:40:01,140 --> 00:40:05,950
that would also work but then you don't

00:40:03,790 --> 00:40:07,660
you'd end up returning either using

00:40:05,950 --> 00:40:08,920
include translation a lot so that

00:40:07,660 --> 00:40:10,300
everything that hash included and

00:40:08,920 --> 00:40:12,910
suddenly started importing them or

00:40:10,300 --> 00:40:15,480
explicitly convert into imports I don't

00:40:12,910 --> 00:40:19,500
know which is the easiest way to go

00:40:15,480 --> 00:40:19,500
sorry okay thank you

00:40:19,740 --> 00:40:25,900
following up on the question before last

00:40:22,000 --> 00:40:28,300
in the pound include world we have a

00:40:25,900 --> 00:40:30,040
distinction between my header files in

00:40:28,300 --> 00:40:33,700
quotes and system header file you know I

00:40:30,040 --> 00:40:35,440
see some capital I it's very similar

00:40:33,700 --> 00:40:37,750
distinction with modules with system

00:40:35,440 --> 00:40:40,000
modules and verses my modules where we

00:40:37,750 --> 00:40:42,130
finish them so yes essentially

00:40:40,000 --> 00:40:45,250
essentially the way the way this is

00:40:42,130 --> 00:40:47,770
specified is in terms of header files or

00:40:45,250 --> 00:40:49,990
in terms of system headers which may or

00:40:47,770 --> 00:40:52,540
may not be files but let's just assume

00:40:49,990 --> 00:40:56,170
they are files so whatever mechanism

00:40:52,540 --> 00:41:00,550
your comp nation system uses to locate

00:40:56,170 --> 00:41:03,580
files that would be included you use the

00:41:00,550 --> 00:41:06,520
same mechanism to uniquely identify a

00:41:03,580 --> 00:41:08,230
particular CMI okay talking about names

00:41:06,520 --> 00:41:10,530
modules I'm sorry I'm talking about

00:41:08,230 --> 00:41:15,070
names modules oh sorry names modules

00:41:10,530 --> 00:41:16,720
yeah this is that somewhat ambiguous at

00:41:15,070 --> 00:41:19,360
this point of the best way of dealing

00:41:16,720 --> 00:41:21,970
with that and so the question you then

00:41:19,360 --> 00:41:25,180
get there for Bill system really is that

00:41:21,970 --> 00:41:29,680
given an import of food I want to find

00:41:25,180 --> 00:41:31,810
the interface file for the in defines

00:41:29,680 --> 00:41:34,330
foods interface so I can go build it cuz

00:41:31,810 --> 00:41:37,320
I don't want to because you know it's

00:41:34,330 --> 00:41:43,180
like I said it's a caching artifact and

00:41:37,320 --> 00:41:44,560
that is kind of a different question for

00:41:43,180 --> 00:41:48,940
which I had a picture actually I

00:41:44,560 --> 00:41:53,560
anticipated that there you go not not a

00:41:48,940 --> 00:42:00,550
boat so again this is the kind of thing

00:41:53,560 --> 00:42:02,800
that sg-15 is looking at and there is no

00:42:00,550 --> 00:42:05,980
well-defined answer to that question at

00:42:02,800 --> 00:42:09,670
this point okay

00:42:05,980 --> 00:42:12,100
is the various online compiling tools

00:42:09,670 --> 00:42:15,820
Ino got bold and one box and moliro and

00:42:12,100 --> 00:42:17,140
idea and all this do any of could I like

00:42:15,820 --> 00:42:20,050
reproduce or play around with this in

00:42:17,140 --> 00:42:22,780
any of those yeah believe God bolt has

00:42:20,050 --> 00:42:30,550
and does regular bills of my branch of

00:42:22,780 --> 00:42:32,500
GCC yeah I I don't know yeah yeah it was

00:42:30,550 --> 00:42:35,160
sufficient to report something to try it

00:42:32,500 --> 00:42:42,130
and refined a bug that I need to do it

00:42:35,160 --> 00:42:47,410
I'm sure yeah we we can talk do you plan

00:42:42,130 --> 00:42:51,880
any tools or perhaps to inspect the

00:42:47,410 --> 00:42:52,510
content of say my file like dump or for

00:42:51,880 --> 00:42:56,170
sale

00:42:52,510 --> 00:42:58,660
yeah so in my particular case because

00:42:56,170 --> 00:43:00,220
these are all bespoke formats your

00:42:58,660 --> 00:43:02,770
mileage varies depending on what

00:43:00,220 --> 00:43:05,530
compiler you're using I just happened to

00:43:02,770 --> 00:43:08,980
have used elf in capsulation or this new

00:43:05,530 --> 00:43:11,200
because it has lazy loading and stuff so

00:43:08,980 --> 00:43:13,390
it basically needs something I can index

00:43:11,200 --> 00:43:17,800
the section indexing the health gives me

00:43:13,390 --> 00:43:19,600
is fine for what I need and so the

00:43:17,800 --> 00:43:22,600
byproducts that you get to look at this

00:43:19,600 --> 00:43:24,250
and one of these fight one of these you

00:43:22,600 --> 00:43:27,160
will notice is a readme and that's

00:43:24,250 --> 00:43:29,710
intended for human readers and maybe

00:43:27,160 --> 00:43:33,400
build tools and it looks like this at

00:43:29,710 --> 00:43:37,450
the moment it's just a string section so

00:43:33,400 --> 00:43:39,970
it tells you you know what this thing is

00:43:37,450 --> 00:43:43,060
when it was what it was built by it has

00:43:39,970 --> 00:43:46,780
some temper at this this is the only

00:43:43,060 --> 00:43:48,790
information in this CMI that is volatile

00:43:46,780 --> 00:43:51,190
and I'm probably going to add an option

00:43:48,790 --> 00:43:52,990
to enable that or disable that as you

00:43:51,190 --> 00:43:55,420
require it's useful to have it if you

00:43:52,990 --> 00:43:57,369
want it but if you want a bit identical

00:43:55,420 --> 00:44:01,750
rebuild you clearly do not want a

00:43:57,369 --> 00:44:04,390
timestamp in the CMI but that's what I

00:44:01,750 --> 00:44:05,920
have in a moment and it will show

00:44:04,390 --> 00:44:08,310
actually the imports but this case they

00:44:05,920 --> 00:44:12,119
were no imports to show

00:44:08,310 --> 00:44:14,420
okay and another question if you merge

00:44:12,119 --> 00:44:17,300
interface translation

00:44:14,420 --> 00:44:19,430
and implementation translation unit does

00:44:17,300 --> 00:44:23,930
it hurt the parallelism of the build

00:44:19,430 --> 00:44:26,810
does it help hurt is multi built so I

00:44:23,930 --> 00:44:30,310
can't question that does it affect

00:44:26,810 --> 00:44:33,830
negatively the parallelism of the build

00:44:30,310 --> 00:44:35,510
because all the been business like if

00:44:33,830 --> 00:44:38,680
you have this transaction you separate

00:44:35,510 --> 00:44:42,680
and then all dependencies can start

00:44:38,680 --> 00:44:44,780
building after interfaces built and Rio

00:44:42,680 --> 00:44:49,340
joined it into a single translation unit

00:44:44,780 --> 00:44:51,290
they can start on the Oh both of them

00:44:49,340 --> 00:44:53,660
are built sorry yes I understand so your

00:44:51,290 --> 00:44:56,690
question is turning it into a single

00:44:53,660 --> 00:45:01,730
file module has that affected the build

00:44:56,690 --> 00:45:05,260
latency and the answer is yes do this

00:45:01,730 --> 00:45:08,300
yeah it's a small library you know I

00:45:05,260 --> 00:45:09,890
think you know if your library is large

00:45:08,300 --> 00:45:12,640
you will probably want to split it up

00:45:09,890 --> 00:45:17,930
into maybe even partition the interface

00:45:12,640 --> 00:45:22,730
itself but into smaller units purely for

00:45:17,930 --> 00:45:25,130
a code management thing I know offhand I

00:45:22,730 --> 00:45:27,380
don't know how much it slows it down one

00:45:25,130 --> 00:45:28,670
of the things that gets that in this

00:45:27,380 --> 00:45:30,950
particular implementation is that

00:45:28,670 --> 00:45:33,410
there's a protocol where the compiler

00:45:30,950 --> 00:45:36,620
can tell query the build system has the

00:45:33,410 --> 00:45:40,700
compilation is going on and it comes at

00:45:36,620 --> 00:45:43,610
the end of parsing that the source it

00:45:40,700 --> 00:45:45,350
can tell it writes the CMI and can tell

00:45:43,610 --> 00:45:47,510
the build system over cm is ready now

00:45:45,350 --> 00:45:48,740
even though the object file may not have

00:45:47,510 --> 00:45:50,810
been generated because it's still doing

00:45:48,740 --> 00:45:53,030
all the optimizations of the actual

00:45:50,810 --> 00:45:55,430
stuff is going to emit so there's a

00:45:53,030 --> 00:45:58,670
possibility there that you know that you

00:45:55,430 --> 00:46:01,070
can overlap things but that's kind of

00:45:58,670 --> 00:46:04,670
speculative at this point okay thank you

00:46:01,070 --> 00:46:07,130
I think John has a question I just

00:46:04,670 --> 00:46:09,920
wanted to ask to what extent have we

00:46:07,130 --> 00:46:14,150
been able to limit the private access

00:46:09,920 --> 00:46:15,620
across module boundaries okay so I

00:46:14,150 --> 00:46:18,020
haven't I haven't implemented the

00:46:15,620 --> 00:46:20,180
private module fragment I'd do it I have

00:46:18,020 --> 00:46:23,540
implemented module partitions both

00:46:20,180 --> 00:46:27,560
interface and implementation partitions

00:46:23,540 --> 00:46:30,500
but I don't do any of the

00:46:27,560 --> 00:46:34,330
completeness visibility that the

00:46:30,500 --> 00:46:37,070
implementation partitions imply about

00:46:34,330 --> 00:46:38,780
imports okay so let me clarify the

00:46:37,070 --> 00:46:41,150
question what I mean is at the highest

00:46:38,780 --> 00:46:42,680
level module and what precautions do we

00:46:41,150 --> 00:46:44,660
take to make sure that we don't have

00:46:42,680 --> 00:46:46,970
long-distance friendship or any other

00:46:44,660 --> 00:46:50,150
device that allows us to access the

00:46:46,970 --> 00:46:53,570
internal implementation let's say a

00:46:50,150 --> 00:47:01,490
class defined in one module okay right

00:46:53,570 --> 00:47:09,620
so you could know you could get that

00:47:01,490 --> 00:47:11,180
longest in friendship by in the you

00:47:09,620 --> 00:47:14,360
would have to do a bit of work to get it

00:47:11,180 --> 00:47:18,200
but because the the import graph is a

00:47:14,360 --> 00:47:20,360
dag it's hard to afford you can't for

00:47:18,200 --> 00:47:23,900
declare from one module to another and

00:47:20,360 --> 00:47:27,560
and have that kind of mutual declaration

00:47:23,900 --> 00:47:29,180
within interfaces but you can do it with

00:47:27,560 --> 00:47:31,640
from an interface to an implementation

00:47:29,180 --> 00:47:36,710
because an implementation file can of

00:47:31,640 --> 00:47:39,860
course import a an interface and so the

00:47:36,710 --> 00:47:42,200
implementation translation units could

00:47:39,860 --> 00:47:46,130
see stuff that you can't get at in the

00:47:42,200 --> 00:47:48,770
interface file does that make sense

00:47:46,130 --> 00:47:50,480
I think so but at the end of the day

00:47:48,770 --> 00:47:52,340
what I'm concerned about is there may be

00:47:50,480 --> 00:47:55,580
because this is a very difficult part

00:47:52,340 --> 00:47:57,290
you know to just sort of nail down and

00:47:55,580 --> 00:47:58,610
there are tricks they don't even involve

00:47:57,290 --> 00:48:00,580
friendships that allow you to get

00:47:58,610 --> 00:48:02,450
private access using partial

00:48:00,580 --> 00:48:03,770
specializations and such I was wondering

00:48:02,450 --> 00:48:06,230
to what extent and we go out of our way

00:48:03,770 --> 00:48:07,970
to make sure to plug every hole so that

00:48:06,230 --> 00:48:13,520
we don't dismiss friendship

00:48:07,970 --> 00:48:16,100
yes module boundaries yeah I don't think

00:48:13,520 --> 00:48:18,560
that has been explicitly considered at

00:48:16,100 --> 00:48:21,200
this point that kind of using

00:48:18,560 --> 00:48:25,470
instantiations to get around that what

00:48:21,200 --> 00:48:29,460
you've just described sorry yeah

00:48:25,470 --> 00:48:32,820
won't solve everything okay and I'm

00:48:29,460 --> 00:48:35,490
sorry that the the showing decides was

00:48:32,820 --> 00:48:36,840
not as quite as I intended but and

00:48:35,490 --> 00:48:39,780
thanks Thoris for letting me use your

00:48:36,840 --> 00:48:40,660
laptops to get it on so thank you

00:48:39,780 --> 00:48:47,790
everybody

00:48:40,660 --> 00:48:47,790

YouTube URL: https://www.youtube.com/watch?v=KVsWIEw3TTw


