Title: CppCon 2019: Titus Winters “Maintainability and Refactoring Impact of Higher-Level Design Features”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Higher levels of abstraction are useful for building things out of, but also have a higher cognitive and maintenance cost. That is, it's a lot easier to refactor a function than it is to change a type, and similarly easier to deal with a single concrete type than a class template, or a Concept, or a meta-Concept ... In this talk I'll present example strategies for refactoring the interface of functions, classes, and class templates. I'll also discuss how the recent addition of Concepts and the proposals for even-more-abstract features affect long-term refactoring in C++. If you're interested in refactoring and it isn't immediately clear that a Concept published in a library can never change, this talk is for you.
— 

Titus Winters
Google
C++ Codebase Cultivator
NYC
Titus Winters has spent the past 6 years working on Google's core C++ libraries. He's particularly interested in issues of large scale software engineer and codebase maintenance: how do we keep a codebase of over 100M lines of code consistent and flexible for the next decade? Along the way he has helped Google teams pioneer techniques to perform automated code transformations on a massive scale, and helps maintain the Google C++ Style Guide.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,740 --> 00:00:13,840
afternoon everybody and welcome to what

00:00:11,530 --> 00:00:16,450
I expect to be my least accessible talk

00:00:13,840 --> 00:00:18,630
ever you're all probably in the wrong

00:00:16,450 --> 00:00:18,630
room

00:00:19,960 --> 00:00:28,450
I am Titus winters I'm Google's C++

00:00:24,250 --> 00:00:31,810
libraries lead and chair of WG 21s

00:00:28,450 --> 00:00:34,840
library evolution working group and I'm

00:00:31,810 --> 00:00:36,850
gonna talk today about the refactoring

00:00:34,840 --> 00:00:41,289
impact of higher level design features

00:00:36,850 --> 00:00:42,370
as with many titus talks I'm going to

00:00:41,289 --> 00:00:46,019
start with a little bit of historical

00:00:42,370 --> 00:00:49,420
context general ground note general

00:00:46,019 --> 00:00:50,980
sorry ground rules general note I'm

00:00:49,420 --> 00:00:53,469
perfectly happy for this to be

00:00:50,980 --> 00:00:56,289
interactive if you have questions don't

00:00:53,469 --> 00:00:59,980
hesitate to get up and come over to the

00:00:56,289 --> 00:01:02,769
microphone to ask your question there's

00:00:59,980 --> 00:01:05,650
there's I think plenty of slack in the

00:01:02,769 --> 00:01:06,970
presentation and I'm almost positive

00:01:05,650 --> 00:01:09,820
that there are plenty of things that

00:01:06,970 --> 00:01:11,290
will be not entirely obvious so if I'm

00:01:09,820 --> 00:01:14,439
going too fast feel free to ask

00:01:11,290 --> 00:01:17,140
questions okay but we'll start in the

00:01:14,439 --> 00:01:20,979
past in the long long ago in the

00:01:17,140 --> 00:01:25,390
beginning all code was basically just a

00:01:20,979 --> 00:01:26,860
mess the first couple decades of

00:01:25,390 --> 00:01:29,890
computer programming code was

00:01:26,860 --> 00:01:32,229
effectively just a pile right you see

00:01:29,890 --> 00:01:35,200
this in old code that relies on go-to

00:01:32,229 --> 00:01:37,299
everywhere or programming languages that

00:01:35,200 --> 00:01:41,409
are based on line numbers preceding

00:01:37,299 --> 00:01:44,409
every statement right we hadn't learned

00:01:41,409 --> 00:01:46,719
yet unsurprisingly that it's easier to

00:01:44,409 --> 00:01:49,740
read and write and maintain code that

00:01:46,719 --> 00:01:53,920
structurally enforces some invariants

00:01:49,740 --> 00:01:55,869
what values are in memory what values

00:01:53,920 --> 00:01:58,719
are in registers how to call a function

00:01:55,869 --> 00:02:00,430
what variables are in scope right these

00:01:58,719 --> 00:02:02,289
sorts of invariants that make it much

00:02:00,430 --> 00:02:05,259
easier for you to reason about your code

00:02:02,289 --> 00:02:07,179
and so over time there started becoming

00:02:05,259 --> 00:02:10,179
a push for what was called structured

00:02:07,179 --> 00:02:12,700
programming this started roughly in the

00:02:10,179 --> 00:02:14,140
50s and came to so completely dominate

00:02:12,700 --> 00:02:16,420
the programming landscape by the late

00:02:14,140 --> 00:02:18,640
80s that we don't really even talk about

00:02:16,420 --> 00:02:21,280
it anymore it's sort of assumed and in

00:02:18,640 --> 00:02:21,580
the move from a big pile of code to

00:02:21,280 --> 00:02:23,740
start

00:02:21,580 --> 00:02:26,440
programming we moved to having

00:02:23,740 --> 00:02:28,930
structures we moved to having functions

00:02:26,440 --> 00:02:29,710
with well-defined signatures and

00:02:28,930 --> 00:02:32,290
well-defined

00:02:29,710 --> 00:02:34,870
ways that you call them we went to

00:02:32,290 --> 00:02:36,820
having loose and conditionals this is

00:02:34,870 --> 00:02:39,310
the movement that gave us go to

00:02:36,820 --> 00:02:42,070
considered harmful it's not a moral

00:02:39,310 --> 00:02:44,350
judgement about go to it's that the

00:02:42,070 --> 00:02:47,470
structures that are capable of replacing

00:02:44,350 --> 00:02:50,070
go to give us invariants that make it

00:02:47,470 --> 00:02:54,940
much easier for us to reason about code

00:02:50,070 --> 00:02:57,850
it gives us the ability locally reason

00:02:54,940 --> 00:02:59,410
about what is going on which is critical

00:02:57,850 --> 00:03:02,950
to scaling into larger and larger

00:02:59,410 --> 00:03:05,890
software I can't easily modify a

00:03:02,950 --> 00:03:08,560
function to take an additional parameter

00:03:05,890 --> 00:03:11,680
if I have to know what is in a given

00:03:08,560 --> 00:03:13,780
register at every possible call site

00:03:11,680 --> 00:03:15,910
everywhere in my codebase all right

00:03:13,780 --> 00:03:18,940
that's going to be a very hard you know

00:03:15,910 --> 00:03:20,920
add a new default parameter right so the

00:03:18,940 --> 00:03:23,320
move to structured programming like

00:03:20,920 --> 00:03:26,230
inherently took us out of the chaos and

00:03:23,320 --> 00:03:28,630
gave us structures and local invariants

00:03:26,230 --> 00:03:30,760
so that we can think about things so you

00:03:28,630 --> 00:03:32,110
could summarize the first 30 or 40 years

00:03:30,760 --> 00:03:34,660
of programming in a sort of

00:03:32,110 --> 00:03:37,300
counterintuitive way by adding

00:03:34,660 --> 00:03:40,810
additional constraints and structure on

00:03:37,300 --> 00:03:43,330
how you write code limiting the types of

00:03:40,810 --> 00:03:46,300
things that you write it actually gave

00:03:43,330 --> 00:03:50,260
us greater flexibility to write bigger

00:03:46,300 --> 00:03:52,930
and more expressive programs and thus

00:03:50,260 --> 00:03:55,120
having gotten a taste for it

00:03:52,930 --> 00:03:56,489
we started extending that set of

00:03:55,120 --> 00:03:59,590
structures right we went from just

00:03:56,489 --> 00:04:02,980
functions and conditionals and things

00:03:59,590 --> 00:04:06,550
like that into object-oriented world

00:04:02,980 --> 00:04:08,500
giving us classes and with C++ we

00:04:06,550 --> 00:04:11,290
started having templates and now with

00:04:08,500 --> 00:04:12,519
C++ 20 we have concepts and I suspect

00:04:11,290 --> 00:04:16,239
that this is not the end of that

00:04:12,519 --> 00:04:18,820
progression the motivation for this talk

00:04:16,239 --> 00:04:21,580
is that I said a few months ago in a

00:04:18,820 --> 00:04:24,340
committee meeting offhandedly I guess

00:04:21,580 --> 00:04:26,380
that types are harder to refactor than

00:04:24,340 --> 00:04:28,450
functions and that templates are harder

00:04:26,380 --> 00:04:30,580
to refactor than types and that concepts

00:04:28,450 --> 00:04:32,320
are impossible and a bunch of people on

00:04:30,580 --> 00:04:34,270
the committee very smart people on the

00:04:32,320 --> 00:04:35,480
committee that I respect deeply didn't

00:04:34,270 --> 00:04:38,480
understand inherently

00:04:35,480 --> 00:04:39,410
I meant by that so I'm going to bore you

00:04:38,480 --> 00:04:43,220
for an hour

00:04:39,410 --> 00:04:45,230
with what this means okay but in order

00:04:43,220 --> 00:04:47,030
to explain why these higher level like

00:04:45,230 --> 00:04:49,280
this progression into higher-level

00:04:47,030 --> 00:04:52,040
structures in order to explain why that

00:04:49,280 --> 00:04:54,500
is increasingly difficult to refactor I

00:04:52,040 --> 00:04:55,490
have to also explain what I mean when we

00:04:54,500 --> 00:04:59,120
at Google

00:04:55,490 --> 00:05:02,000
talk about refactoring hence what do we

00:04:59,120 --> 00:05:03,980
mean by refactoring and a lot of people

00:05:02,000 --> 00:05:05,750
when we say refactoring are thinking of

00:05:03,980 --> 00:05:07,130
effectively the family refactorings

00:05:05,750 --> 00:05:09,500
right Martin Fowler published a great

00:05:07,130 --> 00:05:11,990
book a couple decades ago on like

00:05:09,500 --> 00:05:14,660
refactoring basically he came up with

00:05:11,990 --> 00:05:16,190
sort of an initial list of these are the

00:05:14,660 --> 00:05:18,050
sorts of changes that you might want to

00:05:16,190 --> 00:05:19,340
make to a program the Fowler

00:05:18,050 --> 00:05:21,140
refactorings are the types of things

00:05:19,340 --> 00:05:23,000
that you might find in an IDE in a

00:05:21,140 --> 00:05:25,250
little refactoring menu you might say

00:05:23,000 --> 00:05:27,940
highlight a block of code in the

00:05:25,250 --> 00:05:31,820
function go to your IDE hit refactor

00:05:27,940 --> 00:05:34,100
extract function and it's going to pull

00:05:31,820 --> 00:05:35,930
that block of code into a new function

00:05:34,100 --> 00:05:38,030
you give it a name and it figures out

00:05:35,930 --> 00:05:39,410
which you know variables are coming in

00:05:38,030 --> 00:05:41,170
and out and figures out how to pass

00:05:39,410 --> 00:05:42,530
those variables to that function

00:05:41,170 --> 00:05:46,280
congratulations you've done a

00:05:42,530 --> 00:05:48,530
refactoring other things from

00:05:46,280 --> 00:05:50,900
refactoring comm slash catalog you might

00:05:48,530 --> 00:05:53,210
inline or outline a function you might

00:05:50,900 --> 00:05:55,030
replace you know magic literals and

00:05:53,210 --> 00:05:57,260
string constants things like that

00:05:55,030 --> 00:06:00,080
there's a whole list of these that goes

00:05:57,260 --> 00:06:03,890
on for several pages I would describe

00:06:00,080 --> 00:06:07,190
all of this model as single step

00:06:03,890 --> 00:06:09,080
refactoring right the model that most

00:06:07,190 --> 00:06:12,770
people understand is I'm going to

00:06:09,080 --> 00:06:16,490
generate a set of changes and commit

00:06:12,770 --> 00:06:18,740
that change in one step and here I'm

00:06:16,490 --> 00:06:21,710
going to admit the terminology becomes

00:06:18,740 --> 00:06:23,300
difficult and annoying and I'm it's the

00:06:21,710 --> 00:06:25,430
terminology here's a work in progress I

00:06:23,300 --> 00:06:27,560
have for a while been talking about

00:06:25,430 --> 00:06:29,690
atomic and non-atomic refactoring and

00:06:27,560 --> 00:06:31,070
I'm trying to move away from that in

00:06:29,690 --> 00:06:33,560
this talk so this is the first time that

00:06:31,070 --> 00:06:35,660
I'm trying this new terminology the

00:06:33,560 --> 00:06:37,880
trouble is we have been talking about

00:06:35,660 --> 00:06:40,040
atomic refactoring or single step

00:06:37,880 --> 00:06:42,860
refactoring using the model from version

00:06:40,040 --> 00:06:44,690
control right an atomic commit to your

00:06:42,860 --> 00:06:46,550
version control system an atomic commit

00:06:44,690 --> 00:06:48,890
to your code base atomic commit to your

00:06:46,550 --> 00:06:49,160
repository alright is all of the things

00:06:48,890 --> 00:06:53,030
that you

00:06:49,160 --> 00:06:54,410
can do in one step alright it's great so

00:06:53,030 --> 00:06:58,070
you can do all the fallow refactorings

00:06:54,410 --> 00:07:00,830
if you can find every caller to your

00:06:58,070 --> 00:07:02,270
function you could change the behavior

00:07:00,830 --> 00:07:04,160
of your function however you want

00:07:02,270 --> 00:07:07,370
because you can make all of those

00:07:04,160 --> 00:07:08,780
callers acceptant of that change

00:07:07,370 --> 00:07:10,550
you could add a default parameter that's

00:07:08,780 --> 00:07:13,040
nice and easy everyone understands that

00:07:10,550 --> 00:07:15,320
you could potentially even do a global

00:07:13,040 --> 00:07:17,450
find/replace for an API right you go

00:07:15,320 --> 00:07:18,800
find everywhere that we spell stood

00:07:17,450 --> 00:07:21,490
string and you change it to some other

00:07:18,800 --> 00:07:25,520
name right find/replace no problem

00:07:21,490 --> 00:07:29,600
but my question is are these sorts of

00:07:25,520 --> 00:07:31,910
changes what you're trying to achieve or

00:07:29,600 --> 00:07:35,450
how you achieve it all right what is

00:07:31,910 --> 00:07:37,700
really the basic unit of change and I

00:07:35,450 --> 00:07:41,030
would argue that some of these are kind

00:07:37,700 --> 00:07:44,120
of how you draw an owl right like

00:07:41,030 --> 00:07:47,390
there's a lot of messy details in there

00:07:44,120 --> 00:07:50,540
in some instances right there's simpler

00:07:47,390 --> 00:07:53,330
more basic pieces available because this

00:07:50,540 --> 00:07:57,020
list has kind of a mix of circles and

00:07:53,330 --> 00:07:58,670
owls in what I think and what are

00:07:57,020 --> 00:08:00,530
commonly described as sort of basic

00:07:58,670 --> 00:08:02,420
refactorings some of these are

00:08:00,530 --> 00:08:04,730
definitely like I could change one or

00:08:02,420 --> 00:08:07,640
two files I can add a default parameter

00:08:04,730 --> 00:08:11,540
I'm gonna edit a header or a header on a

00:08:07,640 --> 00:08:14,330
cc alright that's fine and some of them

00:08:11,540 --> 00:08:16,820
are going to scale with how much usage

00:08:14,330 --> 00:08:18,590
there is of the interface in question

00:08:16,820 --> 00:08:21,140
right if I'm doing a fine replace for

00:08:18,590 --> 00:08:23,770
vector I need to find every place in my

00:08:21,140 --> 00:08:26,030
project that actually spells out vector

00:08:23,770 --> 00:08:28,780
that make sense right there's a

00:08:26,030 --> 00:08:34,330
difference in scale there those

00:08:28,780 --> 00:08:37,840
refactorings that scale with usage have

00:08:34,330 --> 00:08:39,770
different risks when we rely on those

00:08:37,840 --> 00:08:44,300
exclusively right if that is the only

00:08:39,770 --> 00:08:45,950
thing in our toolbox then we are reliant

00:08:44,300 --> 00:08:48,740
on the fact that we never have to do

00:08:45,950 --> 00:08:51,500
anything so big that that becomes

00:08:48,740 --> 00:08:54,110
infeasible and so we should consider

00:08:51,500 --> 00:08:57,410
these larger scale sorts of things

00:08:54,110 --> 00:09:00,020
separately and the scale issue comes up

00:08:57,410 --> 00:09:01,910
for several different reasons you're

00:09:00,020 --> 00:09:04,850
going to need a

00:09:01,910 --> 00:09:06,560
or complex refactoring strategy if you

00:09:04,850 --> 00:09:07,630
have any of the following and if you're

00:09:06,560 --> 00:09:09,890
trying to make a change across

00:09:07,630 --> 00:09:12,770
organizational or repository boundaries

00:09:09,890 --> 00:09:15,800
say you implement a standard library and

00:09:12,770 --> 00:09:17,600
you don't see all of the users of your

00:09:15,800 --> 00:09:20,030
standard library right you're going to

00:09:17,600 --> 00:09:22,130
have to rely on harder refactorings

00:09:20,030 --> 00:09:25,070
because you can't just do a global find

00:09:22,130 --> 00:09:27,620
replace make sense

00:09:25,070 --> 00:09:30,980
Google's issue comes from a different

00:09:27,620 --> 00:09:33,530
sort of scale problem which is there's

00:09:30,980 --> 00:09:36,230
many times that we want to do refactor

00:09:33,530 --> 00:09:38,420
something and it touches more files than

00:09:36,230 --> 00:09:42,710
we can commit to version control in one

00:09:38,420 --> 00:09:44,960
step right when we're if we were to do

00:09:42,710 --> 00:09:47,210
you know a find/replace on vector that's

00:09:44,960 --> 00:09:50,030
going to touch hundreds of thousands of

00:09:47,210 --> 00:09:51,680
file now maybe not 100 but way more

00:09:50,030 --> 00:09:53,510
files than we can commit in a single

00:09:51,680 --> 00:09:55,310
step and that's not actually even a

00:09:53,510 --> 00:09:57,320
limitation of the version control system

00:09:55,310 --> 00:09:59,630
it's a limitation of the usage of the

00:09:57,320 --> 00:10:00,980
version control system all right Hyrum

00:09:59,630 --> 00:10:03,140
and I have both given talks where we've

00:10:00,980 --> 00:10:05,000
mentioned this sort of inherent limit on

00:10:03,140 --> 00:10:08,930
your code base in your organization of

00:10:05,000 --> 00:10:11,870
how many files can you have any change

00:10:08,930 --> 00:10:14,210
and submit it in one step because

00:10:11,870 --> 00:10:16,580
there's a constant background rate of

00:10:14,210 --> 00:10:19,640
people also modifying the code base

00:10:16,580 --> 00:10:24,050
right what is the average time between

00:10:19,640 --> 00:10:26,960
change for a file right can you sink to

00:10:24,050 --> 00:10:28,970
trunk can you sink to head before

00:10:26,960 --> 00:10:32,330
someone has modified a file that you're

00:10:28,970 --> 00:10:34,820
touching right and even if you managed

00:10:32,330 --> 00:10:36,860
to pull that off will you be able to

00:10:34,820 --> 00:10:39,770
roll it back in the event that you made

00:10:36,860 --> 00:10:41,480
that change incorrectly right making it

00:10:39,770 --> 00:10:43,070
landing a single change that touches

00:10:41,480 --> 00:10:44,930
hundreds of thousands or tens of

00:10:43,070 --> 00:10:46,580
thousands of files at once even if

00:10:44,930 --> 00:10:48,980
you're technically capable of doing it

00:10:46,580 --> 00:10:50,630
he's probably not smart right you

00:10:48,980 --> 00:10:52,910
probably don't want to be betting on

00:10:50,630 --> 00:10:55,670
that as a reliable strategy on the

00:10:52,910 --> 00:10:59,330
regular basis you can also get into this

00:10:55,670 --> 00:11:01,730
if you have contracts about how long a

00:10:59,330 --> 00:11:04,240
given API is going to exist for right

00:11:01,730 --> 00:11:06,380
it's not unheard of in our industry I

00:11:04,240 --> 00:11:09,740
think all of these basically boil down

00:11:06,380 --> 00:11:12,260
to two primary forms scale or your

00:11:09,740 --> 00:11:13,730
ability to how many files can you touch

00:11:12,260 --> 00:11:15,589
or

00:11:13,730 --> 00:11:19,070
if you're an organization that has

00:11:15,589 --> 00:11:22,550
multiple git repos but you don't have

00:11:19,070 --> 00:11:24,649
any ability to atomically commit to both

00:11:22,550 --> 00:11:27,230
repos right then you're gonna have one

00:11:24,649 --> 00:11:30,230
this type of problem alright if you have

00:11:27,230 --> 00:11:32,390
AP is defined in one repo and callers in

00:11:30,230 --> 00:11:34,279
another you're in the same sort of boat

00:11:32,390 --> 00:11:36,410
but then the harder problem is

00:11:34,279 --> 00:11:38,209
visibility right most people that are

00:11:36,410 --> 00:11:39,920
going to benefit from the sorts of

00:11:38,209 --> 00:11:41,600
techniques that I'm describing in this

00:11:39,920 --> 00:11:43,970
talk are going to get into it not

00:11:41,600 --> 00:11:45,950
because of version control sink or

00:11:43,970 --> 00:11:47,779
Google's scale problems but because of

00:11:45,950 --> 00:11:50,269
problems more like the standard library

00:11:47,779 --> 00:11:51,980
right you've released an interface and

00:11:50,269 --> 00:11:54,860
you don't know where all of the users

00:11:51,980 --> 00:11:56,540
are right they might be private repos

00:11:54,860 --> 00:11:57,620
they might be open source they might be

00:11:56,540 --> 00:12:00,769
all sorts of things right but you have

00:11:57,620 --> 00:12:02,570
no reason to believe that you can track

00:12:00,769 --> 00:12:06,010
all of them down right you've released

00:12:02,570 --> 00:12:06,010
it into the world and now it's out there

00:12:07,209 --> 00:12:12,470
tool assisted refactoring can get you a

00:12:09,800 --> 00:12:14,810
long way in doing operations in that

00:12:12,470 --> 00:12:17,529
sort of environment this is what abseil

00:12:14,810 --> 00:12:20,360
is sort of predicated on but it is

00:12:17,529 --> 00:12:22,670
meaningfully harder to be like I'm gonna

00:12:20,360 --> 00:12:26,870
throw a tool over the wall to fix

00:12:22,670 --> 00:12:29,180
whatever problem I have caused good luck

00:12:26,870 --> 00:12:31,279
like it's definitely doable but the long

00:12:29,180 --> 00:12:34,220
tail on ways that that can go wrong is

00:12:31,279 --> 00:12:35,899
is fairly long because of that

00:12:34,220 --> 00:12:38,510
difficulty and because of our increasing

00:12:35,899 --> 00:12:41,180
like dependency trees

00:12:38,510 --> 00:12:43,310
I sort of abstractly as a side note I

00:12:41,180 --> 00:12:47,779
think the next decade is gonna see a lot

00:12:43,310 --> 00:12:51,140
of progress on sharing web api's where

00:12:47,779 --> 00:12:54,140
providers can say I'm gonna make this

00:12:51,140 --> 00:12:56,540
change is this gonna break you have your

00:12:54,140 --> 00:12:58,970
CI systems and unit tests you know

00:12:56,540 --> 00:13:02,089
execute with that potential change and

00:12:58,970 --> 00:13:04,670
feedback to you yes or no all right

00:13:02,089 --> 00:13:07,430
without necessarily sharing your code

00:13:04,670 --> 00:13:08,959
things like that or at least I'd like to

00:13:07,430 --> 00:13:10,760
see us move that way we'll see if that

00:13:08,959 --> 00:13:13,190
actually comes to pass but in any case

00:13:10,760 --> 00:13:15,140
if you have scale problems or visibility

00:13:13,190 --> 00:13:17,480
problems that prevent you from just

00:13:15,140 --> 00:13:19,160
changing your API sources and users in a

00:13:17,480 --> 00:13:21,260
single step then you're going to need

00:13:19,160 --> 00:13:23,760
something more than this single step

00:13:21,260 --> 00:13:25,120
refactoring mindset and

00:13:23,760 --> 00:13:26,890
[Music]

00:13:25,120 --> 00:13:29,040
so I guess we call that multi-step

00:13:26,890 --> 00:13:32,500
refactoring this is the idea of

00:13:29,040 --> 00:13:35,890
executing a large or distributed set of

00:13:32,500 --> 00:13:38,110
chain change in a series of steps so

00:13:35,890 --> 00:13:40,450
that the ecosystem continues to build

00:13:38,110 --> 00:13:44,020
and function cleanly at every individual

00:13:40,450 --> 00:13:45,550
point in time but each step is small

00:13:44,020 --> 00:13:49,060
enough to be handled as part of the

00:13:45,550 --> 00:13:50,620
normal developer workflow most steps in

00:13:49,060 --> 00:13:52,990
this process if you're doing it well

00:13:50,620 --> 00:13:54,730
don't need to be sequenced in any

00:13:52,990 --> 00:13:58,150
particular way usually this is going to

00:13:54,730 --> 00:14:00,150
be introduced a new API find all of the

00:13:58,150 --> 00:14:02,620
caller's of the old API and convert them

00:14:00,150 --> 00:14:06,220
individually with no dependency between

00:14:02,620 --> 00:14:07,870
how they convert and then clean up all

00:14:06,220 --> 00:14:09,250
right so there's minor sequencing

00:14:07,870 --> 00:14:11,710
between those two things but it's

00:14:09,250 --> 00:14:15,520
basically three phases and the phase in

00:14:11,710 --> 00:14:19,870
the middle should largely be completely

00:14:15,520 --> 00:14:21,610
independent and so if we look what are

00:14:19,870 --> 00:14:23,110
the things that we might rely on for

00:14:21,610 --> 00:14:26,200
multi-step refactoring and I would say

00:14:23,110 --> 00:14:28,420
that the basic atoms here are of a

00:14:26,200 --> 00:14:29,800
different sort of flavor than the things

00:14:28,420 --> 00:14:32,020
that you see in a faller refactoring

00:14:29,800 --> 00:14:33,670
right I could add an overload I know

00:14:32,020 --> 00:14:35,980
that that's gonna be fine I know that I

00:14:33,670 --> 00:14:37,330
can do that locally I can add an alias I

00:14:35,980 --> 00:14:39,100
know that that's gonna be fine

00:14:37,330 --> 00:14:40,990
I know I can do that locally I can

00:14:39,100 --> 00:14:44,800
change a caller from one function to

00:14:40,990 --> 00:14:46,440
another that's local I can change an

00:14:44,800 --> 00:14:51,250
instantiation from one type to another

00:14:46,440 --> 00:14:53,980
that's local ish I can remove an unused

00:14:51,250 --> 00:14:56,950
API right that requires global knowledge

00:14:53,980 --> 00:14:59,020
and some synchronization but can be done

00:14:56,950 --> 00:15:02,860
with only modifying a couple files at a

00:14:59,020 --> 00:15:04,570
time all of these are very nice atoms to

00:15:02,860 --> 00:15:06,790
base your refactoring strategies on

00:15:04,570 --> 00:15:08,410
because they can be done while editing a

00:15:06,790 --> 00:15:13,110
constant number of files like one or two

00:15:08,410 --> 00:15:18,040
files in most cases other operations

00:15:13,110 --> 00:15:21,250
might be atoms I don't know some in some

00:15:18,040 --> 00:15:23,550
scenarios renaming a type like the state

00:15:21,250 --> 00:15:27,820
vector example could still be considered

00:15:23,550 --> 00:15:30,160
atomic if the usage of vector is small

00:15:27,820 --> 00:15:32,950
enough that you can do that as a single

00:15:30,160 --> 00:15:34,959
step alright and so these sort of have a

00:15:32,950 --> 00:15:36,730
different flavor and renaming a type

00:15:34,959 --> 00:15:38,400
changing a function signature all right

00:15:36,730 --> 00:15:41,250
these inherently

00:15:38,400 --> 00:15:44,339
have a larger atom size or maybe their

00:15:41,250 --> 00:15:45,870
molecules I don't know like we're

00:15:44,339 --> 00:15:48,270
working out the terminology as we go

00:15:45,870 --> 00:15:50,970
here but if you're looking into

00:15:48,270 --> 00:15:52,529
multi-step refactoring especially for

00:15:50,970 --> 00:15:54,540
Google sorts of reasons just because you

00:15:52,529 --> 00:15:55,680
have a big scale problem these are the

00:15:54,540 --> 00:15:59,310
ones that you're gonna lose access to

00:15:55,680 --> 00:16:02,700
early on so this looks through some

00:15:59,310 --> 00:16:05,040
examples for instance we needed to

00:16:02,700 --> 00:16:06,839
rename a type we had a string piece that

00:16:05,040 --> 00:16:08,730
was the original impetus for the

00:16:06,839 --> 00:16:12,150
proposal that eventually became string

00:16:08,730 --> 00:16:14,100
view and internally during the Delta

00:16:12,150 --> 00:16:17,250
between string view being accepted and

00:16:14,100 --> 00:16:20,760
us actually moving to C++ 17 we also

00:16:17,250 --> 00:16:23,790
implemented this in abseil as abseil

00:16:20,760 --> 00:16:27,210
string view so we wanted to rename all

00:16:23,790 --> 00:16:31,140
of the usage in our code base from

00:16:27,210 --> 00:16:34,110
string piece to string view because of

00:16:31,140 --> 00:16:36,630
scale we couldn't use rename the type as

00:16:34,110 --> 00:16:39,600
an atom there were tens of thousands of

00:16:36,630 --> 00:16:42,330
files that referred to this name so

00:16:39,600 --> 00:16:45,360
obviously this is not really gonna be a

00:16:42,330 --> 00:16:47,160
whole hour long talk all you do is you

00:16:45,360 --> 00:16:49,950
copy the body of the class and you put

00:16:47,160 --> 00:16:54,380
it in the new namespace right and you're

00:16:49,950 --> 00:16:57,000
fine right it's easy peasy obviously not

00:16:54,380 --> 00:16:59,209
there are so many details that go wrong

00:16:57,000 --> 00:17:02,760
if you do this without thinking about it

00:16:59,209 --> 00:17:05,000
so I will go through some of the way

00:17:02,760 --> 00:17:08,339
some of the ways that this goes wrong

00:17:05,000 --> 00:17:10,589
for instance I said before a multi-step

00:17:08,339 --> 00:17:13,770
refactoring is going to be much smoother

00:17:10,589 --> 00:17:15,660
much easier if you can do it in such a

00:17:13,770 --> 00:17:18,750
way that when you're updating callers

00:17:15,660 --> 00:17:21,089
you don't have dependencies in which of

00:17:18,750 --> 00:17:24,240
them gets updated first right so I don't

00:17:21,089 --> 00:17:27,179
want it to be the case that foo and bar

00:17:24,240 --> 00:17:30,150
dot CC have to be refactored to use the

00:17:27,179 --> 00:17:32,429
new type at the same time right I would

00:17:30,150 --> 00:17:35,400
like it if whatever strategy whatever

00:17:32,429 --> 00:17:37,500
refactoring plan I have I could Reeve

00:17:35,400 --> 00:17:40,290
place string piece with string view in

00:17:37,500 --> 00:17:42,300
either of these first or both of them at

00:17:40,290 --> 00:17:46,410
the same time all right that's going to

00:17:42,300 --> 00:17:48,870
be a much easier refactoring but if I do

00:17:46,410 --> 00:17:51,470
this naively and just touch bar first

00:17:48,870 --> 00:17:53,480
this is not going to work because the

00:17:51,470 --> 00:17:56,750
two completely different classes all

00:17:53,480 --> 00:17:59,570
right so maybe we just write conversions

00:17:56,750 --> 00:18:01,309
between each other all right so I could

00:17:59,570 --> 00:18:03,250
write a conversion so that string view

00:18:01,309 --> 00:18:06,590
converts some string piece or vice-versa

00:18:03,250 --> 00:18:08,929
but that fails if you have any users in

00:18:06,590 --> 00:18:12,049
your code base that have user-defined

00:18:08,929 --> 00:18:14,120
conversions to your type right because

00:18:12,049 --> 00:18:18,740
you can't do two steps of user-defined

00:18:14,120 --> 00:18:21,379
conversions so even if we tracked down

00:18:18,740 --> 00:18:23,029
or even if we added conversions between

00:18:21,379 --> 00:18:25,490
string piece and string view this

00:18:23,029 --> 00:18:27,139
user-defined conversion is gonna fail

00:18:25,490 --> 00:18:30,019
right order is gonna make our

00:18:27,139 --> 00:18:33,110
refactoring more difficult so I guess

00:18:30,019 --> 00:18:35,000
what we do is we first track down all of

00:18:33,110 --> 00:18:36,970
the places that there's a user-defined

00:18:35,000 --> 00:18:39,470
conversion and make it convert to both

00:18:36,970 --> 00:18:42,799
but then that fails if you have an

00:18:39,470 --> 00:18:44,149
overload set that accepts both so that's

00:18:42,799 --> 00:18:46,100
no good

00:18:44,149 --> 00:18:48,860
and then furthermore if you have any

00:18:46,100 --> 00:18:51,860
like atomic update that touches that

00:18:48,860 --> 00:18:55,250
string like overload set you might have

00:18:51,860 --> 00:18:59,149
a whole separate problem in there so

00:18:55,250 --> 00:19:01,220
this is this is gonna be tricky maybe a

00:18:59,149 --> 00:19:03,139
better answer here is to not worry about

00:19:01,220 --> 00:19:05,600
conversions but actually keep them as

00:19:03,139 --> 00:19:08,059
the same type so what we could do

00:19:05,600 --> 00:19:10,250
instead is move the type where we want

00:19:08,059 --> 00:19:13,460
it into the new namespace and leave

00:19:10,250 --> 00:19:17,149
behind a spelling a using alias are

00:19:13,460 --> 00:19:20,090
using declaration for the type in its

00:19:17,149 --> 00:19:24,950
old home all right does anyone see why

00:19:20,090 --> 00:19:28,309
this brings I got a couple for you first

00:19:24,950 --> 00:19:30,950
there's forward declarations because we

00:19:28,309 --> 00:19:33,350
smart we think that forward declarations

00:19:30,950 --> 00:19:37,460
save on build time that is statistically

00:19:33,350 --> 00:19:40,909
unlikely you are going to save on build

00:19:37,460 --> 00:19:42,830
time in cases where every single

00:19:40,909 --> 00:19:44,509
reference to that type in your

00:19:42,830 --> 00:19:47,830
translation unit is a forward

00:19:44,509 --> 00:19:50,769
declaration and nobody has included it

00:19:47,830 --> 00:19:53,750
good luck with that

00:19:50,769 --> 00:19:56,809
furthermore by forward declaring it in

00:19:53,750 --> 00:19:59,269
user code age for instance this is now a

00:19:56,809 --> 00:20:01,909
built break for the users of user code

00:19:59,269 --> 00:20:04,279
dot H because you can't forward declare

00:20:01,909 --> 00:20:04,929
it as a class when it is in fact an

00:20:04,279 --> 00:20:08,510
alias

00:20:04,929 --> 00:20:11,419
right so now you've just gotten in my

00:20:08,510 --> 00:20:13,100
way so my team will go through and take

00:20:11,419 --> 00:20:14,630
all your four declarations and change

00:20:13,100 --> 00:20:16,160
those to includes which doesn't actually

00:20:14,630 --> 00:20:18,919
change your build speed and we're just

00:20:16,160 --> 00:20:22,010
annoyed and yelling at you and then

00:20:18,919 --> 00:20:24,440
maybe this will work of course it

00:20:22,010 --> 00:20:26,450
doesn't it doesn't now because of

00:20:24,440 --> 00:20:29,660
something deeper scarier one of the

00:20:26,450 --> 00:20:33,710
eldritch horrors of refactoring it's my

00:20:29,660 --> 00:20:35,059
friend ADL several talks I've given in

00:20:33,710 --> 00:20:37,490
last year or two have gone into detail

00:20:35,059 --> 00:20:40,280
here so I'll just do this briefly and

00:20:37,490 --> 00:20:44,720
short you can't change the namespace of

00:20:40,280 --> 00:20:47,630
a type because callers that refer to

00:20:44,720 --> 00:20:50,090
that type anywhere maybe depending on

00:20:47,630 --> 00:20:53,419
the Associated namespace of your type in

00:20:50,090 --> 00:20:56,120
order to find functions that also live

00:20:53,419 --> 00:20:58,400
in that namespace so in short for an

00:20:56,120 --> 00:21:01,160
unqualified function call log to stood

00:20:58,400 --> 00:21:03,350
out if there's no qualifiers if there's

00:21:01,160 --> 00:21:05,179
no colon colons anywhere in that then

00:21:03,350 --> 00:21:07,700
we're triggering an unqualified look at

00:21:05,179 --> 00:21:09,200
first it's going to look in F and then

00:21:07,700 --> 00:21:11,450
it's going to look in user and then it's

00:21:09,200 --> 00:21:14,630
going to look in the global namespace as

00:21:11,450 --> 00:21:16,549
you expect but it's also going to look

00:21:14,630 --> 00:21:20,809
in the namespaces that are associated

00:21:16,549 --> 00:21:22,610
with the arguments to your function so

00:21:20,809 --> 00:21:24,620
if my function some string piece is

00:21:22,610 --> 00:21:26,929
actually returning a string piece then I

00:21:24,620 --> 00:21:29,720
get to also look in the namespaces

00:21:26,929 --> 00:21:33,049
associated with string peace in the old

00:21:29,720 --> 00:21:35,929
version of my code base string peace was

00:21:33,049 --> 00:21:37,520
the primary type and lived in old NS

00:21:35,929 --> 00:21:39,890
which happened to be the same namespace

00:21:37,520 --> 00:21:41,960
as log two stood out and so this all

00:21:39,890 --> 00:21:43,700
works without a using declaration

00:21:41,960 --> 00:21:45,620
without qualifications without saying

00:21:43,700 --> 00:21:48,950
what namespace you're in right but as

00:21:45,620 --> 00:21:51,100
soon as you separate a type from any of

00:21:48,950 --> 00:21:55,190
the functions in that same namespace

00:21:51,100 --> 00:21:58,910
it's a built break right so that's not

00:21:55,190 --> 00:22:01,000
great in practice what you're more

00:21:58,910 --> 00:22:03,860
likely to do is do it in the other order

00:22:01,000 --> 00:22:06,140
which is we leave the class where it

00:22:03,860 --> 00:22:08,750
started we add the alias in the new

00:22:06,140 --> 00:22:10,580
namespace we blast through the code base

00:22:08,750 --> 00:22:13,700
to find everywhere that you're spelling

00:22:10,580 --> 00:22:16,070
string peace and change it to absol

00:22:13,700 --> 00:22:17,680
string view and also at the same time

00:22:16,070 --> 00:22:19,930
find all of the um

00:22:17,680 --> 00:22:22,450
qualified calls that depend on ADL Thank

00:22:19,930 --> 00:22:25,270
You clang tooling qualify those calls

00:22:22,450 --> 00:22:27,730
and then when we're done with all of the

00:22:25,270 --> 00:22:31,300
old spellings and ADL is no longer in

00:22:27,730 --> 00:22:36,120
our way then we till we move the class

00:22:31,300 --> 00:22:38,800
body into a BSL delete the alias

00:22:36,120 --> 00:22:41,260
easy-peasy

00:22:38,800 --> 00:22:43,300
this is obviously imperfect you're going

00:22:41,260 --> 00:22:45,910
to have some stragglers things right if

00:22:43,300 --> 00:22:48,580
you actually had functions that encoded

00:22:45,910 --> 00:22:50,890
the name of the type you're not gonna

00:22:48,580 --> 00:22:52,930
hit those with a clang based tool or any

00:22:50,890 --> 00:22:54,370
other automatic refactoring your

00:22:52,930 --> 00:22:56,530
comments are probably gonna be slightly

00:22:54,370 --> 00:22:58,870
out of date things like that we don't

00:22:56,530 --> 00:23:00,430
have perfect AI you are going to leave a

00:22:58,870 --> 00:23:02,560
little bit of a mess doing these sorts

00:23:00,430 --> 00:23:06,550
of things but I think on net it is still

00:23:02,560 --> 00:23:08,980
worth it and this model of finding a way

00:23:06,550 --> 00:23:12,100
to add an alias in order to enable

00:23:08,980 --> 00:23:13,860
multiple spellings is actually sort of

00:23:12,100 --> 00:23:16,000
critical at leasts the class of

00:23:13,860 --> 00:23:18,810
refactorings that are based on renaming

00:23:16,000 --> 00:23:21,610
things so four types you use type alias

00:23:18,810 --> 00:23:26,320
for class templates you use template

00:23:21,610 --> 00:23:29,710
alias for concepts we spent a little

00:23:26,320 --> 00:23:31,600
while and we think this works this is

00:23:29,710 --> 00:23:34,600
not actually an alias those are two

00:23:31,600 --> 00:23:36,640
distinct things but they do subsume one

00:23:34,600 --> 00:23:39,970
another so in like concepts checking

00:23:36,640 --> 00:23:42,100
logic they are equivalent we're not

00:23:39,970 --> 00:23:46,510
currently aware of any way that that's

00:23:42,100 --> 00:23:48,880
going to fail when you do this that said

00:23:46,510 --> 00:23:50,920
I guarantee that there is nobody on the

00:23:48,880 --> 00:23:56,050
planet that has refactored a code base

00:23:50,920 --> 00:23:58,360
in anger that uses concepts so this is

00:23:56,050 --> 00:24:00,160
untested but in theory this is the

00:23:58,360 --> 00:24:02,530
starting point

00:24:00,160 --> 00:24:05,110
weirdly we don't have any way to rename

00:24:02,530 --> 00:24:08,860
a function I find that kind of bizarre

00:24:05,110 --> 00:24:11,710
but this sort of kind of works thanks

00:24:08,860 --> 00:24:13,900
jörg except that's now a function object

00:24:11,710 --> 00:24:16,480
not a function and so it'll fail if

00:24:13,900 --> 00:24:19,960
there's overload sets or at or if you

00:24:16,480 --> 00:24:23,110
actually wanted a DL god forbid so it's

00:24:19,960 --> 00:24:26,890
not actually 100% of the same whereas

00:24:23,110 --> 00:24:30,070
the other alias forms are more high

00:24:26,890 --> 00:24:31,480
fidelity most of the time you probably

00:24:30,070 --> 00:24:33,670
just bespoke do some

00:24:31,480 --> 00:24:36,010
thing with an inline function it kind of

00:24:33,670 --> 00:24:40,030
works but again it changes behavior for

00:24:36,010 --> 00:24:41,740
ADL and some other things and if for

00:24:40,030 --> 00:24:43,360
some horrible reason you have code that

00:24:41,740 --> 00:24:46,720
is comparing function pointers this is

00:24:43,360 --> 00:24:49,810
definitely not the same none of this is

00:24:46,720 --> 00:24:53,470
100% provable we just also know that you

00:24:49,810 --> 00:24:55,120
can definitely get away with it amusing

00:24:53,470 --> 00:24:56,650
that you can change namespaces for

00:24:55,120 --> 00:24:58,620
functions you just can't change the name

00:24:56,650 --> 00:25:02,470
right a using declaration works fine

00:24:58,620 --> 00:25:04,360
anyway this is sort of 101 on how to add

00:25:02,470 --> 00:25:08,860
a different name for an existing thing

00:25:04,360 --> 00:25:10,750
which is sort of key to a lot of the big

00:25:08,860 --> 00:25:13,570
picture pattern for a multi-step

00:25:10,750 --> 00:25:17,140
refactoring most of the time what you're

00:25:13,570 --> 00:25:21,750
trying to do is find a way to allow the

00:25:17,140 --> 00:25:24,040
before and after to coexist peacefully

00:25:21,750 --> 00:25:25,870
right you want two different spellings

00:25:24,040 --> 00:25:27,610
for the same name but you want them to

00:25:25,870 --> 00:25:29,650
be the same thing there's two different

00:25:27,610 --> 00:25:31,540
spellings for the same type but you want

00:25:29,650 --> 00:25:33,520
them to be the same thing right or you

00:25:31,540 --> 00:25:35,080
want two different spellings for

00:25:33,520 --> 00:25:37,390
behavior or you want two different

00:25:35,080 --> 00:25:39,820
spellings for whatever right but you're

00:25:37,390 --> 00:25:42,130
trying to find a way to break it down so

00:25:39,820 --> 00:25:44,350
that you don't have to in a single step

00:25:42,130 --> 00:25:45,850
refactor every caller and every

00:25:44,350 --> 00:25:48,820
reference to whatever thing that you're

00:25:45,850 --> 00:25:51,700
talking about and in order to smear that

00:25:48,820 --> 00:25:54,250
over time inherently you need to be able

00:25:51,700 --> 00:25:57,070
to express both the before and after

00:25:54,250 --> 00:26:02,490
like in a collaborative sort of like

00:25:57,070 --> 00:26:02,490
mutually allowable way that make sense

00:26:03,360 --> 00:26:08,470
we'll do another example

00:26:05,140 --> 00:26:11,470
now with behavioral change so once upon

00:26:08,470 --> 00:26:13,810
a time we had stir cat internally and

00:26:11,470 --> 00:26:17,680
the original implementation for whatever

00:26:13,810 --> 00:26:20,020
reason when you printed a double printed

00:26:17,680 --> 00:26:23,500
a full precision representation of that

00:26:20,020 --> 00:26:25,510
double it turns out that is fairly

00:26:23,500 --> 00:26:28,270
expensive because it is just as much

00:26:25,510 --> 00:26:30,180
work to format the last bits as it is to

00:26:28,270 --> 00:26:33,040
format the most significant bits and

00:26:30,180 --> 00:26:35,050
almost nobody actually wants 34

00:26:33,040 --> 00:26:36,970
characters worth of precision when

00:26:35,050 --> 00:26:39,610
they're like printing the string output

00:26:36,970 --> 00:26:44,080
for a double right that's kind of a bad

00:26:39,610 --> 00:26:46,090
default and so to save both some CPU and

00:26:44,080 --> 00:26:47,320
provide a better user experience for

00:26:46,090 --> 00:26:49,300
like we should really change the

00:26:47,320 --> 00:26:51,400
behavior here but behavior change is

00:26:49,300 --> 00:26:56,530
hard people are going to be depending on

00:26:51,400 --> 00:26:59,110
this so you find a way to make to

00:26:56,530 --> 00:27:01,560
express the intent of I would like the

00:26:59,110 --> 00:27:04,120
old behavior and to let that coexist

00:27:01,560 --> 00:27:06,880
while you're in the process of prepping

00:27:04,120 --> 00:27:09,130
the codebase to make that change and so

00:27:06,880 --> 00:27:10,870
we introduced something legacy precision

00:27:09,130 --> 00:27:12,670
and the original implementation of

00:27:10,870 --> 00:27:14,830
legacy precision is brain-dead simple

00:27:12,670 --> 00:27:18,640
there is no point to this other than to

00:27:14,830 --> 00:27:21,790
provide a different spelling so now we

00:27:18,640 --> 00:27:24,070
use clang tools to go through the code

00:27:21,790 --> 00:27:26,290
base and find it every invocation of

00:27:24,070 --> 00:27:29,470
stir cat where the expression passed

00:27:26,290 --> 00:27:31,780
into it is a double that isn't a call to

00:27:29,470 --> 00:27:34,600
legacy precision and then we wrap all of

00:27:31,780 --> 00:27:37,180
those in a call to legacy precision and

00:27:34,600 --> 00:27:40,410
now we know exactly where all of those

00:27:37,180 --> 00:27:44,260
are and that the old behavior is unused

00:27:40,410 --> 00:27:47,080
right aha and so then in a single step

00:27:44,260 --> 00:27:49,090
you can change the unused behavior and

00:27:47,080 --> 00:27:51,370
change the implementation of legacy

00:27:49,090 --> 00:27:54,070
precision to return a string view

00:27:51,370 --> 00:27:56,950
instead of the double alright and you

00:27:54,070 --> 00:27:59,130
preserve the old semantics while

00:27:56,950 --> 00:28:03,730
changing like pulling the tablecloth out

00:27:59,130 --> 00:28:05,740
right you see how that works in practice

00:28:03,730 --> 00:28:09,090
we applied some heuristics when we're

00:28:05,740 --> 00:28:12,250
doing this because we wanted to only

00:28:09,090 --> 00:28:15,520
deploy the minimum set of calls to

00:28:12,250 --> 00:28:17,740
legacy precision because if the

00:28:15,520 --> 00:28:20,200
motivation for this change was most

00:28:17,740 --> 00:28:22,840
people don't want this behavior it would

00:28:20,200 --> 00:28:24,910
be awfully unfortunate to go force all

00:28:22,840 --> 00:28:27,040
existing users of it to stick with that

00:28:24,910 --> 00:28:29,110
behavior and leave that as a thing that

00:28:27,040 --> 00:28:31,060
is copy and pasted everywhere so you

00:28:29,110 --> 00:28:32,920
apply some heuristics you try to

00:28:31,060 --> 00:28:36,040
minimize the set of places where you do

00:28:32,920 --> 00:28:39,250
that you take hopefully well justified

00:28:36,040 --> 00:28:43,750
shortcuts and you see what you use your

00:28:39,250 --> 00:28:45,400
best judgment and of course that is even

00:28:43,750 --> 00:28:46,930
still simplifying a little bit because

00:28:45,400 --> 00:28:48,970
the code base doesn't stop moving just

00:28:46,930 --> 00:28:50,680
because we started doing this operation

00:28:48,970 --> 00:28:52,300
right there are new calls to stir cat

00:28:50,680 --> 00:28:54,750
there are new calls to stir cat on a

00:28:52,300 --> 00:28:57,580
double that are creeping in constantly

00:28:54,750 --> 00:28:59,410
and so we have to do

00:28:57,580 --> 00:29:02,230
something in some cases at least to

00:28:59,410 --> 00:29:04,030
manage the backsliding for smaller

00:29:02,230 --> 00:29:06,460
interfaces we just don't worry about it

00:29:04,030 --> 00:29:08,800
because the rate that we can generate

00:29:06,460 --> 00:29:11,620
those changes with tooling and blast

00:29:08,800 --> 00:29:15,190
them out with tools that we've discussed

00:29:11,620 --> 00:29:17,230
in previous talks like rosy are just so

00:29:15,190 --> 00:29:19,330
much higher than the like nominal rate

00:29:17,230 --> 00:29:21,010
of backsliding on a small interface then

00:29:19,330 --> 00:29:23,620
you just don't worry about it for big

00:29:21,010 --> 00:29:26,050
things like stare cat or the spelling of

00:29:23,620 --> 00:29:27,490
string piece for a string view then you

00:29:26,050 --> 00:29:30,250
might have to bring to bear some hot

00:29:27,490 --> 00:29:32,620
bigger guns static analysis warnings and

00:29:30,250 --> 00:29:35,080
linters and things like that and of

00:29:32,620 --> 00:29:37,420
course there is also the certainty that

00:29:35,080 --> 00:29:40,720
someone is going to misuse a legacy

00:29:37,420 --> 00:29:41,920
precision for no reason and wind up with

00:29:40,720 --> 00:29:45,190
broken code when we make this change

00:29:41,920 --> 00:29:50,680
because Hiram's law yeah that's just

00:29:45,190 --> 00:29:53,140
annoying but in summary you kind of you

00:29:50,680 --> 00:29:55,210
know ignore the details and roughly the

00:29:53,140 --> 00:29:56,340
you know the the plan looks something

00:29:55,210 --> 00:30:00,580
like this

00:29:56,340 --> 00:30:02,850
does that make sense of course we don't

00:30:00,580 --> 00:30:05,320
rely on this all the time because

00:30:02,850 --> 00:30:07,060
multi-step refactoring is expensive and

00:30:05,320 --> 00:30:09,880
most things don't require this right

00:30:07,060 --> 00:30:12,730
most of the changes that you are used to

00:30:09,880 --> 00:30:14,170
are perfectly fine right you can add a

00:30:12,730 --> 00:30:15,790
new function you can add a new class

00:30:14,170 --> 00:30:17,620
we're gonna add a member to a class you

00:30:15,790 --> 00:30:20,680
can add a new entry to an overload set

00:30:17,620 --> 00:30:23,920
there are a lot of things even on higher

00:30:20,680 --> 00:30:25,660
level structures in our you know catalog

00:30:23,920 --> 00:30:27,160
of design structures there are a lot of

00:30:25,660 --> 00:30:30,280
things that you can change that are

00:30:27,160 --> 00:30:32,170
cheap and easy most of the time we'll

00:30:30,280 --> 00:30:34,360
get into that and it's of course not

00:30:32,170 --> 00:30:37,600
just additions there are some things you

00:30:34,360 --> 00:30:38,860
can do you can weaken a precondition you

00:30:37,600 --> 00:30:40,720
can define things that weren't but

00:30:38,860 --> 00:30:44,890
defined or stabilized things that were

00:30:40,720 --> 00:30:46,300
random all of those are feasible so I'm

00:30:44,890 --> 00:30:48,480
going to go through for a while now and

00:30:46,300 --> 00:30:52,330
look at starting sort of at the bottom

00:30:48,480 --> 00:30:53,890
functions classes templates concepts and

00:30:52,330 --> 00:30:55,300
look at the types of things that we can

00:30:53,890 --> 00:30:59,200
actually change and how hard they are

00:30:55,300 --> 00:31:02,800
either as a single step thing or how

00:30:59,200 --> 00:31:05,770
hard is a multi-step plan to execute

00:31:02,800 --> 00:31:07,600
such a change okay so first off can we

00:31:05,770 --> 00:31:09,160
change functions there's a bunch of

00:31:07,600 --> 00:31:10,900
questions in exactly what you might want

00:31:09,160 --> 00:31:11,130
there if it's just a rename we already

00:31:10,900 --> 00:31:13,500
want

00:31:11,130 --> 00:31:15,720
through sort of how to do that if you

00:31:13,500 --> 00:31:19,800
want to change behavior there are things

00:31:15,720 --> 00:31:21,510
that we know are mostly small easy easy

00:31:19,800 --> 00:31:23,280
to apply atoms of change

00:31:21,510 --> 00:31:25,230
you can always weaken preconditions or

00:31:23,280 --> 00:31:27,000
strengths and postconditions to allow

00:31:25,230 --> 00:31:29,730
the function to be called in more

00:31:27,000 --> 00:31:32,100
contexts or to weaken the set of things

00:31:29,730 --> 00:31:33,930
that it's likely to output alright and

00:31:32,100 --> 00:31:36,090
of course because those things are

00:31:33,930 --> 00:31:37,800
technically observable there is going to

00:31:36,090 --> 00:31:40,080
be some amount of Hiram's law annoyance

00:31:37,800 --> 00:31:43,500
that comes into that but in theory this

00:31:40,080 --> 00:31:45,750
is all doable it is on the flip side

00:31:43,500 --> 00:31:47,850
vastly more expensive to strengthen

00:31:45,750 --> 00:31:49,200
preconditions you're going to have to go

00:31:47,850 --> 00:31:51,000
through the whole code base to find all

00:31:49,200 --> 00:31:54,090
of the callers and figure out who is

00:31:51,000 --> 00:31:56,670
actually doing that ideally statically

00:31:54,090 --> 00:31:58,050
and if you can't do it statically if you

00:31:56,670 --> 00:32:00,630
can't do it through like type inference

00:31:58,050 --> 00:32:03,570
or local reasoning you're gonna have to

00:32:00,630 --> 00:32:05,760
do it with dynamic reasoning and that's

00:32:03,570 --> 00:32:08,490
gonna add runtime overhead and risk and

00:32:05,760 --> 00:32:10,770
all sorts of things you can weaken

00:32:08,490 --> 00:32:12,120
preconditions etc right but these are

00:32:10,770 --> 00:32:14,360
inherently going to involve some

00:32:12,120 --> 00:32:19,740
investigation of every single call sight

00:32:14,360 --> 00:32:22,080
doable but expensive instead of changing

00:32:19,740 --> 00:32:24,930
the behavior of your type how about we

00:32:22,080 --> 00:32:27,950
change the type signature can we change

00:32:24,930 --> 00:32:31,350
return types and the case is void

00:32:27,950 --> 00:32:32,820
probably yes mostly yes it's the only

00:32:31,350 --> 00:32:34,410
thing that I've ever actually seen go

00:32:32,820 --> 00:32:37,350
wrong here when changing a void function

00:32:34,410 --> 00:32:38,940
to return something is when callers are

00:32:37,350 --> 00:32:41,820
writing out return statements that

00:32:38,940 --> 00:32:44,280
invoke your existing void function which

00:32:41,820 --> 00:32:47,130
is weird and rare probably not worth

00:32:44,280 --> 00:32:48,540
losing any sleep over and in fact the

00:32:47,130 --> 00:32:50,700
committee which is pretty good about not

00:32:48,540 --> 00:32:53,820
breaking people's code most of the time

00:32:50,700 --> 00:32:56,070
we already did this once between 14 and

00:32:53,820 --> 00:32:57,540
17 we changed in place back to return

00:32:56,070 --> 00:33:00,150
you a reference to the newly in place to

00:32:57,540 --> 00:33:02,580
thing right we don't believe that people

00:33:00,150 --> 00:33:05,460
are returning the value of in place back

00:33:02,580 --> 00:33:09,240
enough for us to worry about it I think

00:33:05,460 --> 00:33:11,700
we're probably right but if you're

00:33:09,240 --> 00:33:15,270
changing something more than void to

00:33:11,700 --> 00:33:18,450
other things it's sometimes harder can

00:33:15,270 --> 00:33:20,450
we change into n 6040 anyone think we

00:33:18,450 --> 00:33:23,590
can do that cheaply

00:33:20,450 --> 00:33:25,810
nobody is foolish

00:33:23,590 --> 00:33:29,890
in the case of widening an integer type

00:33:25,810 --> 00:33:31,930
or numerix in general no because the

00:33:29,890 --> 00:33:34,960
output of one function is the input to

00:33:31,930 --> 00:33:36,640
another function right and so a simple

00:33:34,960 --> 00:33:39,460
little call chain like this is a

00:33:36,640 --> 00:33:40,870
narrowing problem and depending on your

00:33:39,460 --> 00:33:44,140
compiler settings

00:33:40,870 --> 00:33:45,760
hopefully this becomes a built break so

00:33:44,140 --> 00:33:48,310
we're gonna have to use some non-atomic

00:33:45,760 --> 00:33:50,800
some multi-step refactoring approach in

00:33:48,310 --> 00:33:53,560
order to execute this change and that

00:33:50,800 --> 00:33:57,340
might be as expensive as renaming the

00:33:53,560 --> 00:34:00,250
thing away renaming foo to something

00:33:57,340 --> 00:34:01,810
completely different reintroducing food

00:34:00,250 --> 00:34:05,020
with the signature that you want and

00:34:01,810 --> 00:34:07,000
then converting people back alright so

00:34:05,020 --> 00:34:10,720
you're gonna hit all callers to foo

00:34:07,000 --> 00:34:14,560
maybe twice this is doable but is not

00:34:10,720 --> 00:34:19,000
cheap it's gonna be a bit of work so if

00:34:14,560 --> 00:34:22,630
we can't whiten can we narrow anyone's

00:34:19,000 --> 00:34:26,470
think we can narrow everyone's terrified

00:34:22,630 --> 00:34:27,970
oh yeah maybe and interestingly it

00:34:26,470 --> 00:34:31,120
actually isn't any easier but for

00:34:27,970 --> 00:34:36,090
different reasons it is also hard for

00:34:31,120 --> 00:34:40,360
instance printf is demonically annoying

00:34:36,090 --> 00:34:44,980
there I cannot express how much this

00:34:40,360 --> 00:34:47,620
bothers me it is honestly the fact that

00:34:44,980 --> 00:34:49,270
like one of the long-standing things

00:34:47,620 --> 00:34:51,940
that I desperately want to change in our

00:34:49,270 --> 00:34:56,890
code base is a type def that would

00:34:51,940 --> 00:35:00,190
change long to int 6040 and it would

00:34:56,890 --> 00:35:03,460
break so many format strings that it was

00:35:00,190 --> 00:35:07,380
easier for us to design implement deploy

00:35:03,460 --> 00:35:11,560
convert callers for absol ster format

00:35:07,380 --> 00:35:14,440
than to fix this problem which is kind

00:35:11,560 --> 00:35:16,660
of an amazing yak shave you also get

00:35:14,440 --> 00:35:19,410
into template deduction fails right you

00:35:16,660 --> 00:35:21,430
can't call stood min if the two

00:35:19,410 --> 00:35:23,470
arguments are not actually of the same

00:35:21,430 --> 00:35:27,880
type so if I change one of these from

00:35:23,470 --> 00:35:29,220
long to int deduction failure alright

00:35:27,880 --> 00:35:31,420
not great

00:35:29,220 --> 00:35:33,550
basically amenable to the same trick as

00:35:31,420 --> 00:35:35,119
before you rename it away you've

00:35:33,550 --> 00:35:36,589
introduced the new thing you

00:35:35,119 --> 00:35:39,559
identify the places that you can convert

00:35:36,589 --> 00:35:41,749
back you prey it's a lot of work

00:35:39,559 --> 00:35:45,799
so changing function signatures is

00:35:41,749 --> 00:35:47,809
broadly hard the signature of a function

00:35:45,799 --> 00:35:50,660
is going to break something right as a

00:35:47,809 --> 00:35:53,480
basic refactoring it is a fairly

00:35:50,660 --> 00:35:55,009
expensive one and that's true even in

00:35:53,480 --> 00:35:57,230
the case where your programmers are well

00:35:55,009 --> 00:35:59,359
behaved and they're just calling the

00:35:57,230 --> 00:36:00,890
function if anyone is taking the address

00:35:59,359 --> 00:36:02,569
of your function if function pointers

00:36:00,890 --> 00:36:04,339
are involved anywhere then you have a

00:36:02,569 --> 00:36:07,180
whole additional level of complexity

00:36:04,339 --> 00:36:10,279
because those types become dependent

00:36:07,180 --> 00:36:13,519
alright if you have function pointers or

00:36:10,279 --> 00:36:15,380
forward declarations in place all bets

00:36:13,519 --> 00:36:18,980
are off right it becomes just more

00:36:15,380 --> 00:36:24,589
expensive so functions that's what you

00:36:18,980 --> 00:36:27,069
can do basically can we change types for

00:36:24,589 --> 00:36:29,690
example can we change between two

00:36:27,069 --> 00:36:33,799
compatible types I have an unordered map

00:36:29,690 --> 00:36:36,440
can I make that a faster hash map I can

00:36:33,799 --> 00:36:38,690
I use node hash map has effectively the

00:36:36,440 --> 00:36:41,529
same semantics as far as iterator and

00:36:38,690 --> 00:36:42,650
pointer and validation goes and

00:36:41,529 --> 00:36:45,559
unsurprisingly

00:36:42,650 --> 00:36:47,390
this is hard this is expensive for two

00:36:45,559 --> 00:36:51,289
reasons the first of which is Hiram's

00:36:47,390 --> 00:36:54,319
law again always Thank You Hiram

00:36:51,289 --> 00:36:57,920
for instance this test will fail because

00:36:54,319 --> 00:37:00,650
the iteration order of an ordered map is

00:36:57,920 --> 00:37:02,450
fixed and stable right if you insert two

00:37:00,650 --> 00:37:04,279
elements into the map and you iterate

00:37:02,450 --> 00:37:05,660
through the results you're going to get

00:37:04,279 --> 00:37:08,059
those two elements out in the same order

00:37:05,660 --> 00:37:10,460
all the time people are going to write

00:37:08,059 --> 00:37:13,369
this test that depends on encountering

00:37:10,460 --> 00:37:15,440
those elements in that order hopefully

00:37:13,369 --> 00:37:17,450
it's only tests and not production code

00:37:15,440 --> 00:37:20,480
hopefully you're not serializing things

00:37:17,450 --> 00:37:24,589
to your database but with a large enough

00:37:20,480 --> 00:37:27,470
usage you are so have fun with that

00:37:24,589 --> 00:37:29,869
for a lot more stories on this topic in

00:37:27,470 --> 00:37:31,849
particular go see my friend matt

00:37:29,869 --> 00:37:34,460
kulakundis his talk on hash tables and

00:37:31,849 --> 00:37:37,819
recent optimizations tomorrow afternoon

00:37:34,460 --> 00:37:40,940
because we have got some wild Hiram's

00:37:37,819 --> 00:37:43,069
law stories in that talk it is also

00:37:40,940 --> 00:37:46,039
expensive though because vocabulary

00:37:43,069 --> 00:37:47,830
types are not independent right

00:37:46,039 --> 00:37:50,470
vocabulary types things

00:37:47,830 --> 00:37:53,590
the pass-through ap is form dependency

00:37:50,470 --> 00:37:55,210
networks so it isn't just that I can

00:37:53,590 --> 00:37:57,880
refactor F by changing that

00:37:55,210 --> 00:37:59,830
instantiation I have to also refactor

00:37:57,880 --> 00:38:02,320
everything that that instantiation is

00:37:59,830 --> 00:38:05,320
passed to alright so I have to also hit

00:38:02,320 --> 00:38:08,200
G alright and it isn't that I can just

00:38:05,320 --> 00:38:10,030
refactor F and G it is also that I have

00:38:08,200 --> 00:38:13,540
to refactor everything else in the code

00:38:10,030 --> 00:38:16,330
base that calls G and it is not just

00:38:13,540 --> 00:38:19,920
that it is also everything else that the

00:38:16,330 --> 00:38:26,740
things passed to G are passed 2 etc

00:38:19,920 --> 00:38:29,710
recurse right this can be difficult so

00:38:26,740 --> 00:38:33,250
you can kind of do it and we've done it

00:38:29,710 --> 00:38:34,920
but it's tricky and expensive and we're

00:38:33,250 --> 00:38:37,780
kind of just beating it with a hammer

00:38:34,920 --> 00:38:41,080
amusingly the I have been terrified of

00:38:37,780 --> 00:38:43,660
this exact example for years and Matt

00:38:41,080 --> 00:38:45,340
Kula Candice was like you know let's

00:38:43,660 --> 00:38:47,170
just see what happens I'll see how many

00:38:45,340 --> 00:38:48,970
of these changes I can commit without

00:38:47,170 --> 00:38:50,760
breaking anybody's built and so we're

00:38:48,970 --> 00:38:53,050
just blowing through the codebase

00:38:50,760 --> 00:38:55,180
attempting to make changes and seeing

00:38:53,050 --> 00:38:57,520
what the CI results look like and if it

00:38:55,180 --> 00:39:00,070
passes then welcome it this is not

00:38:57,520 --> 00:39:03,010
particularly robust or reliable it's

00:39:00,070 --> 00:39:04,900
very reliable it's not very smart it's

00:39:03,010 --> 00:39:08,710
not very efficient but it gets the job

00:39:04,900 --> 00:39:12,010
done so there's that I guess so you can

00:39:08,710 --> 00:39:15,190
sort of do this but it's tricky and

00:39:12,010 --> 00:39:17,560
vocabulary types are hard right this is

00:39:15,190 --> 00:39:19,300
a big part of why I say do not introduce

00:39:17,560 --> 00:39:21,700
more vocabulary types into your

00:39:19,300 --> 00:39:24,010
ecosystem lightly this is a big part of

00:39:21,700 --> 00:39:27,220
why when I sit in library evolution I

00:39:24,010 --> 00:39:28,480
fight pretty hard against why do we have

00:39:27,220 --> 00:39:33,480
a second one of these for the same

00:39:28,480 --> 00:39:33,480
purpose I don't always win that but

00:39:34,200 --> 00:39:40,150
functionally changing behavior or

00:39:38,110 --> 00:39:44,040
semantics or class invariants of a type

00:39:40,150 --> 00:39:46,210
is harder than a function right there's

00:39:44,040 --> 00:39:47,530
some things you can do to a function

00:39:46,210 --> 00:39:49,210
right you can weaken preconditions to a

00:39:47,530 --> 00:39:51,190
function I don't believe that there's

00:39:49,210 --> 00:39:52,990
anything you can do to a type that isn't

00:39:51,190 --> 00:39:55,750
going to be this sort of multi step

00:39:52,990 --> 00:39:58,800
refactoring process right it's doable

00:39:55,750 --> 00:39:58,800
but it's expensive

00:39:59,079 --> 00:40:02,499
we're gonna hit everything probably once

00:40:01,880 --> 00:40:06,499
or twice

00:40:02,499 --> 00:40:11,499
can we change virtual interfaces imagine

00:40:06,499 --> 00:40:11,499
I wanted to change that int to a double

00:40:11,859 --> 00:40:17,779
my guess is this is the cheapest you can

00:40:14,990 --> 00:40:20,299
do and this is hitting all callers

00:40:17,779 --> 00:40:22,509
probably twice plus all derived classes

00:40:20,299 --> 00:40:25,609
several times

00:40:22,509 --> 00:40:28,730
amusingly the addition of the override

00:40:25,609 --> 00:40:33,470
keyword adds new exciting levels of

00:40:28,730 --> 00:40:36,859
complexity to this task change is not

00:40:33,470 --> 00:40:39,710
easy Ram and do not get me started on

00:40:36,859 --> 00:40:41,599
your foolish warnings there are some

00:40:39,710 --> 00:40:43,099
compiler warnings that are actively

00:40:41,599 --> 00:40:46,369
hostile to making any sort of

00:40:43,099 --> 00:40:48,529
interesting change so I think it is safe

00:40:46,369 --> 00:40:50,299
to say this is meaningfully harder than

00:40:48,529 --> 00:40:52,789
changing just the type on a function

00:40:50,299 --> 00:40:56,059
right because we have a higher level

00:40:52,789 --> 00:41:00,740
abstraction this virtual function we are

00:40:56,059 --> 00:41:02,239
paying more cost and you see a sort of

00:41:00,740 --> 00:41:05,779
similar thing with function templates

00:41:02,239 --> 00:41:07,339
much like virtual functions you can

00:41:05,779 --> 00:41:09,349
weaken preconditions or strengthen post

00:41:07,339 --> 00:41:14,569
conditions unless there are

00:41:09,349 --> 00:41:17,660
specializations right and depending on

00:41:14,569 --> 00:41:19,609
how many user provided types get rinsed

00:41:17,660 --> 00:41:23,180
through the body of your function

00:41:19,609 --> 00:41:25,190
template it is entirely possible for all

00:41:23,180 --> 00:41:27,730
of the implementation details of your

00:41:25,190 --> 00:41:31,430
function template to be exactly

00:41:27,730 --> 00:41:34,759
necessary right you cannot add any

00:41:31,430 --> 00:41:36,589
additional operations because people

00:41:34,759 --> 00:41:39,289
will have absolutely implemented a type

00:41:36,589 --> 00:41:41,150
and given it only a less than in order

00:41:39,289 --> 00:41:42,680
to make your you know like rinse it

00:41:41,150 --> 00:41:44,210
through your function template right

00:41:42,680 --> 00:41:47,650
even if you designed everything to work

00:41:44,210 --> 00:41:50,660
on sensible values right users are

00:41:47,650 --> 00:41:54,680
clever and take shortcuts

00:41:50,660 --> 00:41:58,009
Hiram's law always works and now we get

00:41:54,680 --> 00:42:01,549
into kind of my point here can we change

00:41:58,009 --> 00:42:03,890
concepts and I will admit in a single

00:42:01,549 --> 00:42:06,529
step concepts are like everything else

00:42:03,890 --> 00:42:08,720
right if you have absolute visibility

00:42:06,529 --> 00:42:10,800
into the source of the thing that you're

00:42:08,720 --> 00:42:13,140
talking about and every

00:42:10,800 --> 00:42:15,780
of it you can change whatever you want

00:42:13,140 --> 00:42:18,260
right deleting your codebase is always

00:42:15,780 --> 00:42:21,510
an option and can be done in one step

00:42:18,260 --> 00:42:23,490
alright renaming your concept or

00:42:21,510 --> 00:42:26,730
changing its behavior completely is

00:42:23,490 --> 00:42:29,640
always possible if you have small enough

00:42:26,730 --> 00:42:32,970
usage and perfect visibility that's not

00:42:29,640 --> 00:42:35,310
interesting though and in the multi step

00:42:32,970 --> 00:42:37,230
world I do not believe that there is

00:42:35,310 --> 00:42:40,380
anything that you can do to a concept

00:42:37,230 --> 00:42:43,260
once it has escaped your control we can

00:42:40,380 --> 00:42:45,330
rename them I guess but that's sort of

00:42:43,260 --> 00:42:49,290
just introducing a new name that's

00:42:45,330 --> 00:42:50,580
equivalent so I'll go into the two

00:42:49,290 --> 00:42:52,380
things that you might do right in

00:42:50,580 --> 00:42:54,630
concepts you're going to try to either

00:42:52,380 --> 00:42:56,270
weaken or strengthen the concept right

00:42:54,630 --> 00:42:59,460
you either want fewer or more

00:42:56,270 --> 00:43:00,900
requirements and I will show you that

00:42:59,460 --> 00:43:03,000
neither is possible right

00:43:00,900 --> 00:43:05,610
weakening is out of the question so

00:43:03,000 --> 00:43:10,110
here's a slightly contrived example out

00:43:05,610 --> 00:43:11,940
of C++ 20 where we are we had a

00:43:10,110 --> 00:43:13,770
late-breaking proposal to change the

00:43:11,940 --> 00:43:17,190
requirements on input and output

00:43:13,770 --> 00:43:20,630
iterators from requiring Coffeyville to

00:43:17,190 --> 00:43:23,250
only require removable all right this is

00:43:20,630 --> 00:43:25,950
sounds actually quite reasonable because

00:43:23,250 --> 00:43:27,990
if you had an input iterator and you

00:43:25,950 --> 00:43:31,880
made a copy of it and you increment one

00:43:27,990 --> 00:43:33,960
of them the old one is nonsense right

00:43:31,880 --> 00:43:36,300
functionally we should probably be

00:43:33,960 --> 00:43:39,600
treating these as move only types or at

00:43:36,300 --> 00:43:41,490
least requiring only move but this

00:43:39,600 --> 00:43:44,670
implementation of wrapped iterator for

00:43:41,490 --> 00:43:47,220
instance is accidentally copying it it

00:43:44,670 --> 00:43:49,140
doesn't break that like requirement that

00:43:47,220 --> 00:43:50,550
you don't touch the old one it just sort

00:43:49,140 --> 00:43:52,620
of accidentally copies it because it's

00:43:50,550 --> 00:43:54,120
an iterator it's trivial to copy calling

00:43:52,620 --> 00:43:56,760
stood move on it would be kind of weird

00:43:54,120 --> 00:43:59,580
right but code would absolutely be

00:43:56,760 --> 00:44:01,650
written again like this if we published

00:43:59,580 --> 00:44:04,050
the concept in the original form as

00:44:01,650 --> 00:44:06,150
copyable right so changing it after the

00:44:04,050 --> 00:44:08,820
fact to require moveable would break

00:44:06,150 --> 00:44:13,230
everyone that had implemented this all

00:44:08,820 --> 00:44:14,700
right that's not great and anyone who

00:44:13,230 --> 00:44:17,370
passed it by value without moving it and

00:44:14,700 --> 00:44:18,710
all of those things yes there was a hand

00:44:17,370 --> 00:44:20,820
maybe but you should go to the mic

00:44:18,710 --> 00:44:23,310
you're working on it okay

00:44:20,820 --> 00:44:25,650
and this is central to a lot of the last

00:44:23,310 --> 00:44:28,830
minute changes in ranges and the new

00:44:25,650 --> 00:44:31,260
iterator machinery in C++ 20 right all

00:44:28,830 --> 00:44:34,350
these things should presumably be single

00:44:31,260 --> 00:44:36,360
pass and we recognize that and move only

00:44:34,350 --> 00:44:39,240
is actually a better match for the

00:44:36,360 --> 00:44:41,040
behavior but we have to do an awful lot

00:44:39,240 --> 00:44:43,170
of work at the very last minute to make

00:44:41,040 --> 00:44:52,370
this change because we can't weaken it

00:44:43,170 --> 00:44:52,370
after the fact Chris I think because

00:44:52,670 --> 00:45:00,020
where is the break here the break is the

00:44:56,310 --> 00:45:13,490
user that is copying it because these

00:45:00,020 --> 00:45:17,060
was that but if the user is user code

00:45:13,490 --> 00:45:20,250
should be written against what the

00:45:17,060 --> 00:45:23,280
concept actually provides right if the

00:45:20,250 --> 00:45:26,670
concept says movable does not say

00:45:23,280 --> 00:45:30,710
copyable and you copy it that does not

00:45:26,670 --> 00:45:40,850
sound like adhering to the concept right

00:45:30,710 --> 00:45:44,580
yeah that's the crux of it I

00:45:40,850 --> 00:45:46,920
depending on how checked your concept

00:45:44,580 --> 00:45:49,950
specification is it may very well be a

00:45:46,920 --> 00:45:51,630
break but it is also important to keep

00:45:49,950 --> 00:45:53,760
in mind the concepts are both some

00:45:51,630 --> 00:45:57,150
syntactic requirements and semantic

00:45:53,760 --> 00:45:58,920
requirements and weakening semantic

00:45:57,150 --> 00:46:00,450
requirement at the same time still

00:45:58,920 --> 00:46:02,640
throws it out of conformance even if it

00:46:00,450 --> 00:46:12,260
happens to build right you do have to

00:46:02,640 --> 00:46:16,260
match what it says yep okay words

00:46:12,260 --> 00:46:20,100
there's no one's calling this with a not

00:46:16,260 --> 00:46:21,650
copyable input iterator before the

00:46:20,100 --> 00:46:24,930
change

00:46:21,650 --> 00:46:28,470
no one is copping yes before the change

00:46:24,930 --> 00:46:32,610
is correct you make the change no code

00:46:28,470 --> 00:46:34,329
no code breaks immediately unless your

00:46:32,610 --> 00:46:40,380
compiler is checking

00:46:34,329 --> 00:46:43,809
the syntactic requirements yes like I

00:46:40,380 --> 00:46:46,689
you might get away with it but it's a

00:46:43,809 --> 00:46:49,239
mite and I actually not convinced that

00:46:46,689 --> 00:46:51,099
you will and as soon as the change lands

00:46:49,239 --> 00:46:53,019
in any form and someone implements a

00:46:51,099 --> 00:46:55,749
thing that does the minimum or correct

00:46:53,019 --> 00:47:02,429
job for that iterator then you're having

00:46:55,749 --> 00:47:05,109
deeper problems you might get away with

00:47:02,429 --> 00:47:08,890
there's a lot of things you might get

00:47:05,109 --> 00:47:10,809
away strengthening is also out of the

00:47:08,890 --> 00:47:14,410
question for sort of the reverse reason

00:47:10,809 --> 00:47:16,650
right if I had a poor concept edible

00:47:14,410 --> 00:47:19,269
that was just the syntactic requirement

00:47:16,650 --> 00:47:21,039
if I wanted to add a semantic

00:47:19,269 --> 00:47:23,920
requirement that has to also be

00:47:21,039 --> 00:47:27,369
commutative old types that matched

00:47:23,920 --> 00:47:28,989
string is a double under the old model

00:47:27,369 --> 00:47:31,569
but is not edible because it's not

00:47:28,989 --> 00:47:34,119
commutative can't just swap them back

00:47:31,569 --> 00:47:38,679
and forth right so you'd throw something

00:47:34,119 --> 00:47:42,489
else out of conformance if you don't

00:47:38,679 --> 00:47:44,890
have perfect visibility for this sort of

00:47:42,489 --> 00:47:47,729
change the only thing that you can

00:47:44,890 --> 00:47:50,229
really do is rename the concept away and

00:47:47,729 --> 00:47:52,059
reuse the name or find a new name and

00:47:50,229 --> 00:47:55,089
just add a new concept right we'll have

00:47:52,059 --> 00:47:58,660
iterator two or three four seven

00:47:55,089 --> 00:48:01,059
whatever and because like I said

00:47:58,660 --> 00:48:03,699
concepts should have both syntactic and

00:48:01,059 --> 00:48:05,499
semantic meaning to them even just the

00:48:03,699 --> 00:48:07,689
fact that it still builds does not mean

00:48:05,499 --> 00:48:10,900
it is correct right you might be

00:48:07,689 --> 00:48:12,459
semantically out of conformance we also

00:48:10,900 --> 00:48:15,219
see this in type erasure for things like

00:48:12,459 --> 00:48:17,529
stood function or stood any which is not

00:48:15,219 --> 00:48:20,499
surprising because type erased types are

00:48:17,529 --> 00:48:23,410
very much the dynamic runtime library

00:48:20,499 --> 00:48:25,029
version of concepts in fact it might

00:48:23,410 --> 00:48:27,729
even be easier to see why there's no

00:48:25,029 --> 00:48:30,789
small atom of change for concept we

00:48:27,729 --> 00:48:32,589
can't add an API to stead function and

00:48:30,789 --> 00:48:35,289
have it go through to the underlying

00:48:32,589 --> 00:48:38,319
callable because many existing call

00:48:35,289 --> 00:48:41,380
evel's don't have that API right

00:48:38,319 --> 00:48:43,479
similarly we can't remove an API from

00:48:41,380 --> 00:48:46,509
stood function can't remove the call

00:48:43,479 --> 00:48:47,410
operator because everything that is

00:48:46,509 --> 00:48:50,069
written in term

00:48:47,410 --> 00:48:53,200
of the API instead function provides is

00:48:50,069 --> 00:48:54,490
using that interface right you can

00:48:53,200 --> 00:49:00,160
either weaken or strengthen you can

00:48:54,490 --> 00:49:02,049
either add nor remove I don't think

00:49:00,160 --> 00:49:04,690
concepts and type race types are

00:49:02,049 --> 00:49:05,890
uniquely hard in this case for any

00:49:04,690 --> 00:49:09,609
structure that can be used as both

00:49:05,890 --> 00:49:12,069
constraint and interface changes are

00:49:09,609 --> 00:49:13,839
going to be effectively impossible we

00:49:12,069 --> 00:49:17,500
encountered a limited form of this with

00:49:13,839 --> 00:49:20,440
the the old iterator hierarchy where the

00:49:17,500 --> 00:49:22,990
set of tags suggested that that set was

00:49:20,440 --> 00:49:25,990
complete right there was code out there

00:49:22,990 --> 00:49:28,630
in the wild that had a exhaustive switch

00:49:25,990 --> 00:49:31,329
effectively on the set of iterator tags

00:49:28,630 --> 00:49:33,609
and even if we wanted to add new things

00:49:31,329 --> 00:49:36,339
like contiguous iterator under the old

00:49:33,609 --> 00:49:41,530
model there's nowhere to put that tag

00:49:36,339 --> 00:49:44,200
without breaking existing code and you

00:49:41,530 --> 00:49:48,069
can't remove existing tags for obvious

00:49:44,200 --> 00:49:49,770
reasons all of which brings us to the

00:49:48,069 --> 00:49:54,520
suggestion that the higher-level

00:49:49,770 --> 00:49:56,799
expressive structures scale with

00:49:54,520 --> 00:49:59,230
refactoring costs right if you're trying

00:49:56,799 --> 00:50:01,210
to make any sort of change even in the

00:49:59,230 --> 00:50:04,240
concepts space just weakening or

00:50:01,210 --> 00:50:06,220
strengthening something right it's

00:50:04,240 --> 00:50:09,130
becoming increasingly expensive if not

00:50:06,220 --> 00:50:10,809
impossible and this is I think very

00:50:09,130 --> 00:50:13,510
interesting because this is the opposite

00:50:10,809 --> 00:50:15,490
of how everything started here we moved

00:50:13,510 --> 00:50:17,559
away from pile of code to structured

00:50:15,490 --> 00:50:19,720
programming and that additional

00:50:17,559 --> 00:50:21,789
structure gave us more flexibility it

00:50:19,720 --> 00:50:24,730
gave us invariants that allowed local

00:50:21,789 --> 00:50:27,039
reasoning but now the higher-level

00:50:24,730 --> 00:50:30,549
structures have taken those invariants

00:50:27,039 --> 00:50:33,490
and spread them through your whole code

00:50:30,549 --> 00:50:35,349
base all of your users and so now it is

00:50:33,490 --> 00:50:38,770
no longer local reasoning it is once

00:50:35,349 --> 00:50:44,440
again global which is complicated and

00:50:38,770 --> 00:50:46,660
doesn't scale well and that is also to

00:50:44,440 --> 00:50:49,240
say that the higher-level structures

00:50:46,660 --> 00:50:50,049
even though these are arguably zero cost

00:50:49,240 --> 00:50:52,720
abstractions

00:50:50,049 --> 00:50:55,960
in terms of runtime they have meaningful

00:50:52,720 --> 00:50:58,119
costs elsewhere right you have saved

00:50:55,960 --> 00:50:59,799
some on expressivity you have saved some

00:50:58,119 --> 00:51:00,420
on being able to write it or specify it

00:50:59,799 --> 00:51:02,490
more easy

00:51:00,420 --> 00:51:04,559
but you have also painted yourself into

00:51:02,490 --> 00:51:06,900
new and exciting corners that we don't

00:51:04,559 --> 00:51:10,970
fully understand yet for more on that

00:51:06,900 --> 00:51:15,210
see Chandler's talk later this afternoon

00:51:10,970 --> 00:51:16,890
to recap we looked at the difference

00:51:15,210 --> 00:51:18,960
between traditional refactoring Fowler

00:51:16,890 --> 00:51:21,680
refactorings things that you would see

00:51:18,960 --> 00:51:25,200
in your IDE and what I am turning

00:51:21,680 --> 00:51:26,940
multi-step refactoring suggestions for

00:51:25,200 --> 00:51:30,150
better terminology very welcome

00:51:26,940 --> 00:51:33,690
and this multi-step refactoring model

00:51:30,150 --> 00:51:35,369
covers a wider scope of things and is

00:51:33,690 --> 00:51:38,640
applicable in many many more scenarios

00:51:35,369 --> 00:51:42,089
than the traditional single step Fowler

00:51:38,640 --> 00:51:45,000
models another way of looking at it is

00:51:42,089 --> 00:51:47,010
that these multi-step methods are what

00:51:45,000 --> 00:51:49,769
we rely upon to make what others would

00:51:47,010 --> 00:51:52,799
call a breaking change I think that is a

00:51:49,769 --> 00:51:54,150
dumb term still because if literally

00:51:52,799 --> 00:51:56,309
everything you do is going to break

00:51:54,150 --> 00:52:00,000
someone because Hiram's law works all

00:51:56,309 --> 00:52:02,700
the time I hate the term because

00:52:00,000 --> 00:52:06,720
breaking change is not binary it is a

00:52:02,700 --> 00:52:08,940
gradient it is shades of gray we've seen

00:52:06,720 --> 00:52:11,339
in this talk the changes to function

00:52:08,940 --> 00:52:13,829
semantics may be cheap in some forms

00:52:11,339 --> 00:52:16,049
weakening preconditions for instance but

00:52:13,829 --> 00:52:18,390
in a strongly typed language like C++

00:52:16,049 --> 00:52:22,170
changing the typed signature of a

00:52:18,390 --> 00:52:23,910
function is not necessarily safe even

00:52:22,170 --> 00:52:25,440
just widening an output type is a

00:52:23,910 --> 00:52:28,730
potentially breaking change because

00:52:25,440 --> 00:52:32,700
types are both inputs and outputs

00:52:28,730 --> 00:52:35,460
classes do the same except now they're

00:52:32,700 --> 00:52:38,339
even harder because they tie interfaces

00:52:35,460 --> 00:52:40,349
together in these sorts of dependency

00:52:38,339 --> 00:52:42,059
and declaration networks vocabulary

00:52:40,349 --> 00:52:44,339
types are particularly expensive and

00:52:42,059 --> 00:52:47,250
even if your type isn't vocabulary

00:52:44,339 --> 00:52:49,319
it has inherently like that whole reason

00:52:47,250 --> 00:52:51,000
you have types is to have invariants on

00:52:49,319 --> 00:52:52,680
your data right

00:52:51,000 --> 00:52:54,839
those invariants need to hold for the

00:52:52,680 --> 00:52:57,720
lifetime of your type right you're going

00:52:54,839 --> 00:53:01,589
to have time concerns that are much more

00:52:57,720 --> 00:53:04,170
complicated than just the functional

00:53:01,589 --> 00:53:07,130
immediate imperative behavioral change

00:53:04,170 --> 00:53:09,869
when you're refactoring a function

00:53:07,130 --> 00:53:12,829
classes help us encapsulate but they are

00:53:09,869 --> 00:53:14,240
harder to refactor templates and

00:53:12,829 --> 00:53:16,490
polymorphism

00:53:14,240 --> 00:53:18,830
generalizing further and gave us more

00:53:16,490 --> 00:53:20,990
expressive power but we pay for that

00:53:18,830 --> 00:53:23,300
with higher difficulty and more exciting

00:53:20,990 --> 00:53:24,680
ways for things to go wrong even simple

00:53:23,300 --> 00:53:27,070
things like refactoring a function

00:53:24,680 --> 00:53:30,250
template get really bad if you have

00:53:27,070 --> 00:53:32,630
exciting users and poorly defined

00:53:30,250 --> 00:53:35,270
specializations or interesting

00:53:32,630 --> 00:53:36,590
user-defined types concepts are the

00:53:35,270 --> 00:53:38,630
newest addition to all of this hierarchy

00:53:36,590 --> 00:53:41,720
and no one has any real experience

00:53:38,630 --> 00:53:43,369
maintaining them at present to my mind

00:53:41,720 --> 00:53:45,680
it does not look like concepts are

00:53:43,369 --> 00:53:48,260
amenable to change in any way once they

00:53:45,680 --> 00:53:49,700
escape your control you can need to

00:53:48,260 --> 00:53:52,400
weaken or strengthen them without

00:53:49,700 --> 00:53:55,190
potentially breaking users of existing

00:53:52,400 --> 00:53:58,550
code these multi-step methods may

00:53:55,190 --> 00:54:00,619
mitigate it slightly if you have

00:53:58,550 --> 00:54:03,260
visibility at least or if you're just

00:54:00,619 --> 00:54:05,630
trying to rename something away but I

00:54:03,260 --> 00:54:08,000
strongly encourage authors of C++ 20

00:54:05,630 --> 00:54:10,790
libraries to be very careful do not

00:54:08,000 --> 00:54:13,190
publish new concepts unless you are 100%

00:54:10,790 --> 00:54:18,160
sure about them or you don't care about

00:54:13,190 --> 00:54:18,160
breaking users in the future questions

00:54:18,510 --> 00:54:20,480
[Applause]

00:54:19,260 --> 00:54:23,600
[Music]

00:54:20,480 --> 00:54:26,820
[Applause]

00:54:23,600 --> 00:54:26,820
[Music]

00:54:28,109 --> 00:54:34,180
Chris so something that well something

00:54:31,959 --> 00:54:36,339
that I've been thinking about since you

00:54:34,180 --> 00:54:37,599
started mentioning that we can't just

00:54:36,339 --> 00:54:41,769
arbitrarily change concepts without

00:54:37,599 --> 00:54:44,979
these concerns is well what happens if I

00:54:41,769 --> 00:54:46,359
have a requirement in a concept and we

00:54:44,979 --> 00:54:47,799
also have a multiple recurrence of the

00:54:46,359 --> 00:54:50,019
concept and then I want to factor that

00:54:47,799 --> 00:54:52,329
into a into another concept post-release

00:54:50,019 --> 00:54:54,729
say I have another name that I'm going

00:54:52,329 --> 00:54:55,630
to add that's technically changing the

00:54:54,729 --> 00:54:57,609
concept that keeping all the

00:54:55,630 --> 00:55:01,930
requirements and also introducing a new

00:54:57,609 --> 00:55:05,859
name is that problematic nobody has done

00:55:01,930 --> 00:55:09,069
any of this in anger I assume so because

00:55:05,859 --> 00:55:11,380
of like your brief description of it my

00:55:09,069 --> 00:55:13,779
gut says yes and Hiram's law always wins

00:55:11,380 --> 00:55:15,989
like I cannot imagine that you get away

00:55:13,779 --> 00:55:19,979
with anything at scale if you have

00:55:15,989 --> 00:55:21,880
relatively few users yeah sure but I

00:55:19,979 --> 00:55:23,079
don't think there's an easy out here

00:55:21,880 --> 00:55:26,920
that's disappointing

00:55:23,079 --> 00:55:28,989
thank you yep hi I'm Roth I just was

00:55:26,920 --> 00:55:32,019
wondering in situations where your

00:55:28,989 --> 00:55:33,939
subpoena is being used to essentially

00:55:32,019 --> 00:55:37,029
kind of be creating implicit concepts in

00:55:33,939 --> 00:55:38,949
a library do you see that as different

00:55:37,029 --> 00:55:40,900
and and true language concepts it's

00:55:38,949 --> 00:55:46,749
being hard to refactor or are they one

00:55:40,900 --> 00:55:55,089
in the same fina is different because it

00:55:46,749 --> 00:55:57,549
is condition 8 like subpoena is only one

00:55:55,089 --> 00:56:00,160
half of the concept in the sense of it

00:55:57,549 --> 00:56:03,519
is setting the requirements on invoking

00:56:00,160 --> 00:56:06,549
this function but it is not necessarily

00:56:03,519 --> 00:56:08,529
the entirety of the interface that that

00:56:06,549 --> 00:56:08,949
function is relying upon if that makes

00:56:08,529 --> 00:56:10,569
sense

00:56:08,949 --> 00:56:12,729
yeah I think so yeah yeah so like

00:56:10,569 --> 00:56:15,579
because of that minor discrepancy I

00:56:12,729 --> 00:56:20,400
think you have more likelihood to get

00:56:15,579 --> 00:56:22,420
away with some things hey Titus I

00:56:20,400 --> 00:56:25,539
following up on the question that I

00:56:22,420 --> 00:56:27,160
asked earlier I I think I agree with

00:56:25,539 --> 00:56:28,630
everything in this talk except for the

00:56:27,160 --> 00:56:31,390
weakening of concepts I think the

00:56:28,630 --> 00:56:33,069
weakening example you showed is pretty

00:56:31,390 --> 00:56:35,410
similar to the example you showed

00:56:33,069 --> 00:56:38,119
earlier with the change in behavior of

00:56:35,410 --> 00:56:41,930
the function where you slide in the leg

00:56:38,119 --> 00:56:43,759
the precision function that does the

00:56:41,930 --> 00:56:46,039
conversion from the weaker version

00:56:43,759 --> 00:56:47,900
initially does nothing eventually does

00:56:46,039 --> 00:56:49,609
the conversion of the weaker version to

00:56:47,900 --> 00:56:52,069
the stronger version and then you

00:56:49,609 --> 00:56:54,140
eventually slide it out yes if you have

00:56:52,069 --> 00:56:56,359
perfect visibility into the users of

00:56:54,140 --> 00:56:58,819
your concept if you have the same

00:56:56,359 --> 00:57:02,450
visibility as the example you described

00:56:58,819 --> 00:57:04,789
before right so I can do this but if you

00:57:02,450 --> 00:57:07,400
are publishing concepts and lose

00:57:04,789 --> 00:57:09,680
visibility because the multi-step

00:57:07,400 --> 00:57:12,579
refactoring becomes necessary either at

00:57:09,680 --> 00:57:15,529
scale or because you lost visibility

00:57:12,579 --> 00:57:20,630
right I can do this because we have

00:57:15,529 --> 00:57:23,210
scale and so with visibility scale is

00:57:20,630 --> 00:57:25,819
annoying but all tractable once you have

00:57:23,210 --> 00:57:27,829
lost visibility like you could try to

00:57:25,819 --> 00:57:29,599
ship a tool to find everyone that was

00:57:27,829 --> 00:57:31,460
depending on the old behavior and try to

00:57:29,599 --> 00:57:36,079
come up with some way to refactor them

00:57:31,460 --> 00:57:38,269
so that they are not bad e'en that will

00:57:36,079 --> 00:57:39,710
be an awesome new research project but

00:57:38,269 --> 00:57:42,650
that was the same as the sterk at an

00:57:39,710 --> 00:57:45,890
example yes ok right behavioral changes

00:57:42,650 --> 00:57:48,460
are very difficult if you don't have

00:57:45,890 --> 00:57:53,539
disability scale helps

00:57:48,460 --> 00:57:55,309
visibility is great scale yeah yeah so

00:57:53,539 --> 00:57:57,049
the implication of refactoring is that

00:57:55,309 --> 00:57:58,220
you're kind of either finding and

00:57:57,049 --> 00:58:01,519
replacing something immediately or not

00:57:58,220 --> 00:58:03,200
long after sorry I keep quite here you

00:58:01,519 --> 00:58:04,880
can get close to the mic so the

00:58:03,200 --> 00:58:06,170
implication of refactoring is that

00:58:04,880 --> 00:58:07,849
you're either replacing something

00:58:06,170 --> 00:58:10,640
immediately or replacing it along

00:58:07,849 --> 00:58:13,009
afterwards at what point do you decide

00:58:10,640 --> 00:58:15,410
that you have tools like deprecated up

00:58:13,009 --> 00:58:17,210
attribute inline namespaces when do you

00:58:15,410 --> 00:58:19,789
decide that you want both of things to

00:58:17,210 --> 00:58:24,349
coexist without immediately replacing

00:58:19,789 --> 00:58:26,180
them for us I think it is almost always

00:58:24,349 --> 00:58:29,660
a matter of how many times it is spelled

00:58:26,180 --> 00:58:32,509
in the codebase if you have perfect

00:58:29,660 --> 00:58:35,239
visibility and it's only used 500 times

00:58:32,509 --> 00:58:37,309
we'll just do it right you don't have to

00:58:35,239 --> 00:58:39,710
go to multi-step methods all of these

00:58:37,309 --> 00:58:41,569
things right if it is spelled many more

00:58:39,710 --> 00:58:44,509
times than that then you almost

00:58:41,569 --> 00:58:49,609
certainly or we have to come up with a

00:58:44,509 --> 00:58:51,060
more intricate plan and of course on top

00:58:49,609 --> 00:58:53,520
of that

00:58:51,060 --> 00:58:56,609
none of this is possible at all without

00:58:53,520 --> 00:58:59,369
tests and CI right like you have to have

00:58:56,609 --> 00:59:01,920
visibility into does your users code

00:58:59,369 --> 00:59:03,089
still bill do the tests still pass like

00:59:01,920 --> 00:59:05,369
have they done something super weird

00:59:03,089 --> 00:59:07,560
some Arthur could you go back to the

00:59:05,369 --> 00:59:10,410
slide it was about 67 or so we had the

00:59:07,560 --> 00:59:12,390
step by step for naming a pure virtual

00:59:10,410 --> 00:59:15,300
function yeah

00:59:12,390 --> 00:59:17,490
so my undo things about this my

00:59:15,300 --> 00:59:20,190
understanding is that if this were a

00:59:17,490 --> 00:59:24,150
concept you could do basically the same

00:59:20,190 --> 00:59:25,710
steps to to change the concept in some

00:59:24,150 --> 00:59:28,890
way again as you say this requires

00:59:25,710 --> 00:59:30,660
perfect visibility yes but is your

00:59:28,890 --> 00:59:32,820
understanding also that if you had

00:59:30,660 --> 00:59:35,869
visibility you could do these steps or

00:59:32,820 --> 00:59:39,089
their analogs and change the concepts

00:59:35,869 --> 00:59:40,890
probably and that first step

00:59:39,089 --> 00:59:43,349
renamed get area to get into area

00:59:40,890 --> 00:59:45,930
everywhere even isn't it's very

00:59:43,349 --> 00:59:47,579
expensive thing on its own okay that

00:59:45,930 --> 00:59:48,930
that if you have scale is still very

00:59:47,579 --> 00:59:52,920
expensive you don't have a good way to

00:59:48,930 --> 00:59:53,670
do that at scale okay I think I got time

00:59:52,920 --> 00:59:56,700
for one more

00:59:53,670 --> 01:00:00,270
hi I'm Stephan am i right in thinking

00:59:56,700 --> 01:00:04,829
that all of this essentially means that

01:00:00,270 --> 01:00:08,869
there is a continuum between library

01:00:04,829 --> 01:00:13,109
features and how they're implemented and

01:00:08,869 --> 01:00:16,170
the cost to an organization using that

01:00:13,109 --> 01:00:19,050
feature at scale so taking for instance

01:00:16,170 --> 01:00:23,310
a strong type library that generates

01:00:19,050 --> 01:00:26,220
lots of templates and you find that you

01:00:23,310 --> 01:00:29,359
want to refactor something in that

01:00:26,220 --> 01:00:33,079
library that suddenly doesn't feel funny

01:00:29,359 --> 01:00:35,830
right definitely go to Chandlers talk

01:00:33,079 --> 01:00:43,539
yep thank you all very much

01:00:35,830 --> 01:00:43,539

YouTube URL: https://www.youtube.com/watch?v=v_yzLe-wnfk


