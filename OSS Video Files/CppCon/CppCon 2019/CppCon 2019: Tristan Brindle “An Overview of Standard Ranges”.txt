Title: CppCon 2019: Tristan Brindle “An Overview of Standard Ranges”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
The ranges revolution is nearly upon us! C++20 will include concept-enabled, range-based versions of all the standard algorithms you know and love, as well as new “views” which can transform the way you write code. In this talk we’ll offer an overview of the ranges features currently in the C++20 draft, with examples of how you can use them to reduce verbosity, avoid bugs and improve the correctness of your code, and in some cases get better performance. We’ll also cover the currently-available ranges implementations that you can use today, without having to wait for the next version of the standard.

If you've heard the buzz around ranges and are wondering what they'll bring and how they'll benefit your code-base, then this is the talk for you.
— 
Tristan Brindle

Tristan is a freelance developer, C++ trainer and BSI committee member based in London. He’s the author of NanoRange, a C++14-compatible Ranges implementation, and lead tutor for C++ London Uni, a not-for-profit organisation offering free weekly C++ classes for students in London and around the world.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,310 --> 00:00:11,640
okay good morning everybody welcome to

00:00:10,650 --> 00:00:14,700
and over the

00:00:11,640 --> 00:00:18,210
standard ranges my name is Tristan hope

00:00:14,700 --> 00:00:20,100
you're everybody's in the right place so

00:00:18,210 --> 00:00:23,820
first question show of hands who's on

00:00:20,100 --> 00:00:27,720
Twitter a lot of you who who follows

00:00:23,820 --> 00:00:28,349
Brice lower back on Twitter well more of

00:00:27,720 --> 00:00:30,660
you should

00:00:28,349 --> 00:00:32,880
so last week on press it was the week

00:00:30,660 --> 00:00:33,720
before Brice tweeted this tweeted CP

00:00:32,880 --> 00:00:36,450
peak on bingo

00:00:33,720 --> 00:00:40,710
and your CP pika bingo card looks like

00:00:36,450 --> 00:00:42,780
this and right off the bat that this is

00:00:40,710 --> 00:00:45,149
the very first session other than the

00:00:42,780 --> 00:00:46,739
keynote I've given you box to tick off

00:00:45,149 --> 00:00:49,649
because this is indeed a hipster

00:00:46,739 --> 00:00:51,539
reveal.js presentation so there you go

00:00:49,649 --> 00:00:53,579
just for coming to this presentation

00:00:51,539 --> 00:00:55,410
even if you get nothing else out of it

00:00:53,579 --> 00:00:58,079
you can tick off see you can take off

00:00:55,410 --> 00:00:59,399
one of your CPP con bingo boxes in fact

00:00:58,079 --> 00:01:01,800
by the end of this talk you should be

00:00:59,399 --> 00:01:03,269
able to tick off an awful lot more so

00:01:01,800 --> 00:01:06,680
you know you've if you're playing bingo

00:01:03,269 --> 00:01:06,680
you've absolutely come to the right tool

00:01:07,580 --> 00:01:13,860
okay so who am i well as I said my name

00:01:11,520 --> 00:01:16,470
is Tristan I'm a independent contractor

00:01:13,860 --> 00:01:19,740
freelancer based in London in the UK I'm

00:01:16,470 --> 00:01:21,990
a member of the BSI that's the UK C++

00:01:19,740 --> 00:01:23,549
national body for Standardization I'm

00:01:21,990 --> 00:01:25,650
also the director of an organization

00:01:23,549 --> 00:01:27,630
called C++ London uni you might have

00:01:25,650 --> 00:01:30,299
heard us talking on cpp cast or cpp

00:01:27,630 --> 00:01:33,750
chats we offer we're nonprofit we offer

00:01:30,299 --> 00:01:35,159
free beginner C++ classes in London and

00:01:33,750 --> 00:01:36,930
also online so if that's something

00:01:35,159 --> 00:01:38,549
you're interested in talking to me about

00:01:36,930 --> 00:01:40,350
then please come and find me afterwards

00:01:38,549 --> 00:01:48,570
because I'm very happy to talk to talk

00:01:40,350 --> 00:01:51,420
about it anyway onwards today's talk so

00:01:48,570 --> 00:01:53,280
today I'm hoping that by the end of the

00:01:51,420 --> 00:01:54,869
session by the time you leave this room

00:01:53,280 --> 00:01:58,049
I'll have been able to answer three

00:01:54,869 --> 00:02:00,719
questions for you first of all what is

00:01:58,049 --> 00:02:02,759
this range of stuff all about you're

00:02:00,719 --> 00:02:04,590
here I guess because you've heard that

00:02:02,759 --> 00:02:06,930
we're getting this new fancy great new

00:02:04,590 --> 00:02:09,119
stuff in C++ 20 and you want to know

00:02:06,930 --> 00:02:13,280
what's all about and in particular

00:02:09,119 --> 00:02:13,280
what's in it for me by which I mean you

00:02:13,490 --> 00:02:19,769
and thirdly how can I use this stuff

00:02:17,100 --> 00:02:22,379
today yes it's coming in 20 but there

00:02:19,769 --> 00:02:24,360
are three implementations that I know of

00:02:22,379 --> 00:02:25,050
of this stuff that you can use today and

00:02:24,360 --> 00:02:27,000
so on

00:02:25,050 --> 00:02:29,250
briefly gonna go over at the end what

00:02:27,000 --> 00:02:30,690
those implementations are and how you

00:02:29,250 --> 00:02:34,590
can how you can get them how you can use

00:02:30,690 --> 00:02:37,740
them so actually just on this using the

00:02:34,590 --> 00:02:41,420
stuff today how many people use range v3

00:02:37,740 --> 00:02:44,100
in production or for personal projects

00:02:41,420 --> 00:02:45,990
actually a lot fewer of you than I've

00:02:44,100 --> 00:02:48,210
been I expected who has heard of range

00:02:45,990 --> 00:02:51,600
v3 but hasn't really tried it out okay

00:02:48,210 --> 00:02:54,560
so the majority of hands and lastly who

00:02:51,600 --> 00:02:56,880
uses STL algorithms in their code today

00:02:54,560 --> 00:02:59,240
okay I'm hoping that's every hand in the

00:02:56,880 --> 00:03:02,100
room right because it really should be

00:02:59,240 --> 00:03:04,640
so if you're in that last group that put

00:03:02,100 --> 00:03:06,540
your hand up if you're not shame on you

00:03:04,640 --> 00:03:08,280
but if you're in that last group that

00:03:06,540 --> 00:03:10,350
put your hand up then this is a talk you

00:03:08,280 --> 00:03:11,610
should be interested in because the

00:03:10,350 --> 00:03:12,890
standard algorithms that we know and

00:03:11,610 --> 00:03:15,150
love today are going to get even better

00:03:12,890 --> 00:03:18,990
and that's mostly what I'm going to be

00:03:15,150 --> 00:03:21,810
talking about so let's kick off with

00:03:18,990 --> 00:03:26,580
question one what is this range of stuff

00:03:21,810 --> 00:03:29,000
all about well if you really had to boil

00:03:26,580 --> 00:03:37,500
it down to you know a really simple

00:03:29,000 --> 00:03:42,600
pithy one-line phrase just six words STL

00:03:37,500 --> 00:03:45,840
2.0 right so very very brief history

00:03:42,600 --> 00:03:47,250
less than 1994 Alex Stepanov ming-lee

00:03:45,840 --> 00:03:49,530
they produced their their master work

00:03:47,250 --> 00:03:53,790
their magnum opus the HP standard

00:03:49,530 --> 00:03:55,560
template library 1998 large parts of

00:03:53,790 --> 00:03:59,790
this become part of the C++ standard

00:03:55,560 --> 00:04:02,959
library and then we fast-forward a bit

00:03:59,790 --> 00:04:05,640
and we'll not really much has changed

00:04:02,959 --> 00:04:08,760
we've got a few new algorithms in C++ 11

00:04:05,640 --> 00:04:10,440
couple new overloads in 14 and 17 but by

00:04:08,760 --> 00:04:13,380
and large what we have in the standard

00:04:10,440 --> 00:04:18,600
today is more or less what Stepanov and

00:04:13,380 --> 00:04:20,760
Lee came up with 25 years ago now you

00:04:18,600 --> 00:04:22,680
could argue and I probably would that

00:04:20,760 --> 00:04:24,780
this actually proves that this was a

00:04:22,680 --> 00:04:30,210
good design that has stood the test of

00:04:24,780 --> 00:04:32,790
time but C++ the language has evolved

00:04:30,210 --> 00:04:34,590
considerably in that time we can do

00:04:32,790 --> 00:04:39,230
things today that we simply could not do

00:04:34,590 --> 00:04:43,080
in 1998 let alone 1994

00:04:39,230 --> 00:04:44,940
so it's time to take this venerable

00:04:43,080 --> 00:04:46,860
library that we've been using for a

00:04:44,940 --> 00:04:51,720
quarter of a century and to update it

00:04:46,860 --> 00:04:53,220
for today's C++ and as I say if you

00:04:51,720 --> 00:04:55,530
really had to boil it down to what this

00:04:53,220 --> 00:04:58,140
range of stuff is about it's STL 2.0

00:04:55,530 --> 00:05:01,470
it's a new major release of this piece

00:04:58,140 --> 00:05:03,150
of software and like any new major

00:05:01,470 --> 00:05:05,430
release we're getting lots of new

00:05:03,150 --> 00:05:09,570
features and most of the talk today is

00:05:05,430 --> 00:05:11,700
going to be about these new features in

00:05:09,570 --> 00:05:14,430
full disclosure because it's a new major

00:05:11,700 --> 00:05:17,310
release new 2.0 it's not quite 100%

00:05:14,430 --> 00:05:19,350
backwards compatible it's more

00:05:17,310 --> 00:05:22,890
permissive in some ways more strict in

00:05:19,350 --> 00:05:24,600
other ways so if you have if you're one

00:05:22,890 --> 00:05:27,120
of these places that uses lots of custom

00:05:24,600 --> 00:05:29,760
iterators custom containers there's a

00:05:27,120 --> 00:05:33,320
possibility you might need to change

00:05:29,760 --> 00:05:36,360
slightly some of your iterator

00:05:33,320 --> 00:05:39,960
definitions in particular but that's a

00:05:36,360 --> 00:05:42,420
rare sort of corner case and you know 95

00:05:39,960 --> 00:05:43,890
98 percent of the time you're going to

00:05:42,420 --> 00:05:45,780
be able to jump straight to ranges and

00:05:43,890 --> 00:05:52,560
reap the benefits without having to do

00:05:45,780 --> 00:05:54,060
anything except change the namespace so

00:05:52,560 --> 00:05:55,710
all of the new facilities that we're

00:05:54,060 --> 00:06:02,780
getting are going in this nested

00:05:55,710 --> 00:06:07,080
namespace STD ranges and your old code

00:06:02,780 --> 00:06:09,420
that uses namespace standard will

00:06:07,080 --> 00:06:11,940
continuing working just as it always has

00:06:09,420 --> 00:06:13,560
so this new all the new stuff I'm going

00:06:11,940 --> 00:06:15,110
to be talking about is not going to

00:06:13,560 --> 00:06:18,360
break any code

00:06:15,110 --> 00:06:20,880
this is opt-in you opt-in to the new

00:06:18,360 --> 00:06:25,410
stuff in this standard namespace founded

00:06:20,880 --> 00:06:26,910
ranges namespace so just as an aside I

00:06:25,410 --> 00:06:29,520
don't know people been following this

00:06:26,910 --> 00:06:30,900
for a while there was a proposal that we

00:06:29,520 --> 00:06:32,970
should have a new top-level namespace

00:06:30,900 --> 00:06:36,420
which is STD - this was actually

00:06:32,970 --> 00:06:40,140
reserved in C++ 17 we've reserved STD

00:06:36,420 --> 00:06:41,730
followed by any number of digits in the

00:06:40,140 --> 00:06:44,010
end it was decided an STD namespace

00:06:41,730 --> 00:06:45,630
within STD was probably the way to go I

00:06:44,010 --> 00:06:47,580
think people were kind of worried about

00:06:45,630 --> 00:06:49,830
like a Python 2 3 situation like

00:06:47,580 --> 00:06:51,390
bifurcation kind of thing so we're

00:06:49,830 --> 00:06:53,690
getting we're getting this nested

00:06:51,390 --> 00:06:55,230
namespaces

00:06:53,690 --> 00:06:57,630
everything that I'm going to show you

00:06:55,230 --> 00:07:00,300
today all being well borrowing an

00:06:57,630 --> 00:07:01,680
absolute disaster will be part of C++ 20

00:07:00,300 --> 00:07:04,410
that's another box you can take off on

00:07:01,680 --> 00:07:05,550
your bingo promising something is going

00:07:04,410 --> 00:07:06,600
to be in the standard version know

00:07:05,550 --> 00:07:09,120
everything I'm going to show you today

00:07:06,600 --> 00:07:11,090
is in the C++ 20 committee draft that's

00:07:09,120 --> 00:07:14,700
the stage we're at is standardization

00:07:11,090 --> 00:07:16,500
and at the moment it's just a matter of

00:07:14,700 --> 00:07:18,300
sort of dotting the is crossing the t's

00:07:16,500 --> 00:07:19,680
making sure everything's everything is

00:07:18,300 --> 00:07:24,150
right so everything I'll show you today

00:07:19,680 --> 00:07:26,760
should be in C++ 20 and as I mentioned

00:07:24,150 --> 00:07:29,520
there are three implementations three

00:07:26,760 --> 00:07:31,560
libraries that are compatible with older

00:07:29,520 --> 00:07:33,240
versions of C++ that you can use today

00:07:31,560 --> 00:07:40,320
if you want to get a head start and

00:07:33,240 --> 00:07:41,910
start using this great new stuff so so

00:07:40,320 --> 00:07:46,080
far I've said the word range is probably

00:07:41,910 --> 00:07:49,740
about 200 times perhaps we ought to take

00:07:46,080 --> 00:07:56,940
a step back and say well what is a range

00:07:49,740 --> 00:08:01,770
anyway well a range is an objects on

00:07:56,940 --> 00:08:03,450
which you can call begin where begin

00:08:01,770 --> 00:08:06,720
returns you something called an iterator

00:08:03,450 --> 00:08:08,340
which could be incremented which we can

00:08:06,720 --> 00:08:10,110
dereference to obtain the value at that

00:08:08,340 --> 00:08:13,230
position but which we can increment

00:08:10,110 --> 00:08:20,000
until it compares equal to the thing we

00:08:13,230 --> 00:08:26,400
got from ends like for example a

00:08:20,000 --> 00:08:27,230
standard vector so if this seems

00:08:26,400 --> 00:08:29,940
familiar

00:08:27,230 --> 00:08:33,680
it's because it's more or less the same

00:08:29,940 --> 00:08:36,330
definition of a range that we have today

00:08:33,680 --> 00:08:40,320
ranges don't replace the use of

00:08:36,330 --> 00:08:43,410
iterators they build on them so I've

00:08:40,320 --> 00:08:45,090
seen I'd spend more time than is then

00:08:43,410 --> 00:08:48,810
this healthy one ready on the cpp ready

00:08:45,090 --> 00:08:50,130
right just and I see comments on there

00:08:48,810 --> 00:08:52,110
from time to time with people going our

00:08:50,130 --> 00:08:53,610
while iterators are the old stuff it's

00:08:52,110 --> 00:08:55,680
raters are old and now we're going to

00:08:53,610 --> 00:08:58,590
have ranges and you if you use iterate

00:08:55,680 --> 00:09:00,030
as you're wrong that's not the case yes

00:08:58,590 --> 00:09:01,560
we've got these new abstractions on top

00:09:00,030 --> 00:09:03,240
of iterators but iterators are still

00:09:01,560 --> 00:09:05,850
there under the surface doing the work

00:09:03,240 --> 00:09:10,940
just like they always have

00:09:05,850 --> 00:09:10,940
this is evolution not revolution yes

00:09:15,020 --> 00:09:20,640
does end have to return in its rater

00:09:18,200 --> 00:09:27,350
in about half an hour you'll get the

00:09:20,640 --> 00:09:29,640
answers a question so the Rangers work

00:09:27,350 --> 00:09:31,680
formalizes many of the notions that were

00:09:29,640 --> 00:09:33,480
implicit in the existing STL

00:09:31,680 --> 00:09:35,700
we already had this notion of a range

00:09:33,480 --> 00:09:36,600
you know like a sequence of values that

00:09:35,700 --> 00:09:39,540
we can iterate over

00:09:36,600 --> 00:09:41,340
we have range based for loops we've had

00:09:39,540 --> 00:09:43,410
these things for a while a range is

00:09:41,340 --> 00:09:51,390
really formalizes a lot of this language

00:09:43,410 --> 00:09:54,270
so that's sort of the thousand-mile view

00:09:51,390 --> 00:09:55,920
the really high-level view the you know

00:09:54,270 --> 00:09:58,560
where is this coming from why are we

00:09:55,920 --> 00:09:59,700
doing it but the really important thing

00:09:58,560 --> 00:10:01,950
the thing you will want to know the

00:09:59,700 --> 00:10:03,360
reason you're here unless you hone

00:10:01,950 --> 00:10:07,350
English accent and toil is not good

00:10:03,360 --> 00:10:08,880
vault in which case sorry what you

00:10:07,350 --> 00:10:11,730
really want to know is what's in it for

00:10:08,880 --> 00:10:13,380
me why is this a good thing

00:10:11,730 --> 00:10:16,920
how is this going to make my code better

00:10:13,380 --> 00:10:18,330
and so bulk of the rest of this talk is

00:10:16,920 --> 00:10:23,850
going to be about answering this

00:10:18,330 --> 00:10:27,540
question so the first thing we want to

00:10:23,850 --> 00:10:29,070
talk about is concepts now talking about

00:10:27,540 --> 00:10:31,860
concepts would easily be an hour long

00:10:29,070 --> 00:10:33,840
talk just by itself and there are in

00:10:31,860 --> 00:10:36,540
fact talks this week that will go into a

00:10:33,840 --> 00:10:38,250
lot more detail about concepts than I

00:10:36,540 --> 00:10:42,150
can do when I have a lot of other things

00:10:38,250 --> 00:10:43,860
to talk about but as many of you

00:10:42,150 --> 00:10:45,720
probably know concepts are a new

00:10:43,860 --> 00:10:48,270
language feature that we're getting in

00:10:45,720 --> 00:10:49,680
C++ 20 they've had a so long and

00:10:48,270 --> 00:10:50,310
tortured history they're originally part

00:10:49,680 --> 00:10:53,250
of C++

00:10:50,310 --> 00:10:55,190
so X which became C++ 11 they were sort

00:10:53,250 --> 00:10:57,900
of yanked out at the last minute

00:10:55,190 --> 00:11:00,150
reworked in this this new sort of

00:10:57,900 --> 00:11:02,760
simpler form called concept light

00:11:00,150 --> 00:11:05,100
concepts lights eventually became the

00:11:02,760 --> 00:11:07,230
concepts TS and then the concepts TS

00:11:05,100 --> 00:11:09,060
again where underwent some modifications

00:11:07,230 --> 00:11:13,890
and is now going to be part of the next

00:11:09,060 --> 00:11:16,410
standard C++ 20 so the concepts language

00:11:13,890 --> 00:11:19,050
feature has been available in GCC for a

00:11:16,410 --> 00:11:22,250
long time use the F concept switch and

00:11:19,050 --> 00:11:24,570
in fact just a few days ago last week

00:11:22,250 --> 00:11:26,700
Microsoft announced that the new version

00:11:24,570 --> 00:11:29,580
of MSB see the new preview version is

00:11:26,700 --> 00:11:30,720
actually going to support concepts which

00:11:29,580 --> 00:11:32,700
you have to give Microsoft a lot of

00:11:30,720 --> 00:11:35,160
credit because they have done absolutely

00:11:32,700 --> 00:11:38,519
stunning work in updating their compiler

00:11:35,160 --> 00:11:41,010
to the latest latest standards so kudos

00:11:38,519 --> 00:11:43,200
to them there's a planning

00:11:41,010 --> 00:11:45,240
implementation in progress as far as I

00:11:43,200 --> 00:11:46,829
know unless anyone correctly it's not

00:11:45,240 --> 00:11:50,040
part of the main not part of trunk yet

00:11:46,829 --> 00:11:54,089
but it is there on compiler Explorer and

00:11:50,040 --> 00:11:56,310
you can play with it so all three major

00:11:54,089 --> 00:11:58,040
implementations are working on this and

00:11:56,310 --> 00:12:01,890
so fingers crossed in a year or two

00:11:58,040 --> 00:12:04,279
we'll have concept support in all of our

00:12:01,890 --> 00:12:04,279
compilers

00:12:04,399 --> 00:12:09,660
so what do concepts actually do well

00:12:08,010 --> 00:12:12,089
concepts allow us to control the

00:12:09,660 --> 00:12:16,980
instantiation of templates by testing

00:12:12,089 --> 00:12:18,690
syntactic conditions and again if you

00:12:16,980 --> 00:12:21,360
really wanted to boil this down to a

00:12:18,690 --> 00:12:22,500
pithy phrase and I'm aware that I'm on

00:12:21,360 --> 00:12:24,029
video and I probably shouldn't be saying

00:12:22,500 --> 00:12:25,350
this on video because it's something

00:12:24,029 --> 00:12:28,320
that people who are really into concepts

00:12:25,350 --> 00:12:30,420
won't like me saying right but if you if

00:12:28,320 --> 00:12:33,570
you you know you need to explain it to

00:12:30,420 --> 00:12:39,000
your your co-workers in three words its

00:12:33,570 --> 00:12:43,110
Sweeney on steroids or perhaps Sweeney

00:12:39,000 --> 00:12:45,270
in the language so for years we've been

00:12:43,110 --> 00:12:47,610
able to do these horrible hacks using

00:12:45,270 --> 00:12:49,829
standard enable if lately later we've

00:12:47,610 --> 00:12:52,920
got void tea we have these methods of

00:12:49,829 --> 00:12:56,070
constraining our templates today but

00:12:52,920 --> 00:12:57,510
they're horrible let's be honest they

00:12:56,070 --> 00:12:59,610
sort of abusing these template

00:12:57,510 --> 00:13:01,290
instantiation rules they were kind of as

00:12:59,610 --> 00:13:03,630
far as I know discovered by accident

00:13:01,290 --> 00:13:06,810
rather than designed into the language

00:13:03,630 --> 00:13:08,279
so concepts give us a much nicer way of

00:13:06,810 --> 00:13:11,360
doing this a much better way of doing

00:13:08,279 --> 00:13:14,760
this that is part of the language and

00:13:11,360 --> 00:13:18,660
hopefully usable by you know mere

00:13:14,760 --> 00:13:20,430
mortals as opposed to template experts

00:13:18,660 --> 00:13:24,959
because who wants to be a templating

00:13:20,430 --> 00:13:26,579
expert really so concept is a

00:13:24,959 --> 00:13:28,709
compile-time predicate that's a true or

00:13:26,579 --> 00:13:34,220
false value which is true if the given

00:13:28,709 --> 00:13:34,220
type meets requirements we give it so

00:13:35,220 --> 00:13:42,410
we can have we can say for an inn for a

00:13:38,579 --> 00:13:45,779
type T given an instance of that type

00:13:42,410 --> 00:13:47,940
will some expression compile and is the

00:13:45,779 --> 00:13:52,140
type of that expression does that meet

00:13:47,940 --> 00:13:54,450
certain other criteria so here's an

00:13:52,140 --> 00:13:56,370
example of a concept it's not a very

00:13:54,450 --> 00:13:58,110
good concept I have to say don't use

00:13:56,370 --> 00:13:59,399
things like this in your own code but

00:13:58,110 --> 00:14:02,430
you know it's one line in it fits on a

00:13:59,399 --> 00:14:05,399
slide so here we've got a concept called

00:14:02,430 --> 00:14:07,470
string convertible and what we say is

00:14:05,399 --> 00:14:11,430
that we require that it's given a

00:14:07,470 --> 00:14:13,649
constant reference to a T we are able to

00:14:11,430 --> 00:14:16,890
call the member function t dots to

00:14:13,649 --> 00:14:22,290
string and this returns something that

00:14:16,890 --> 00:14:23,880
is convertible to a standard string okay

00:14:22,290 --> 00:14:26,000
so as I said this is not really a great

00:14:23,880 --> 00:14:27,750
example of the concept they're just so

00:14:26,000 --> 00:14:32,519
demonstrating the syntax more than

00:14:27,750 --> 00:14:34,860
anything so how can we use these well as

00:14:32,519 --> 00:14:37,140
I say we can use these to control the

00:14:34,860 --> 00:14:42,750
instantiation of our function templates

00:14:37,140 --> 00:14:48,360
and class templates and we do that like

00:14:42,750 --> 00:14:52,920
so so here we've got a function template

00:14:48,360 --> 00:14:55,709
convert to string and in the body of

00:14:52,920 --> 00:14:58,410
this we call t dot - string but we've

00:14:55,709 --> 00:15:02,190
used the keyword requires to constrain

00:14:58,410 --> 00:15:04,649
this template so that it's only usable

00:15:02,190 --> 00:15:10,079
by types which meet the requirements of

00:15:04,649 --> 00:15:12,839
the string convertible concept so if we

00:15:10,079 --> 00:15:14,670
try and sensate this template with a

00:15:12,839 --> 00:15:17,220
type that doesn't have a two string

00:15:14,670 --> 00:15:19,290
method this function template is going

00:15:17,220 --> 00:15:21,570
to disappear from consideration for

00:15:19,290 --> 00:15:23,070
overload resolution and if it was the

00:15:21,570 --> 00:15:25,260
only candidate we'll probably get an

00:15:23,070 --> 00:15:26,970
error message saying well I couldn't use

00:15:25,260 --> 00:15:30,320
this because he does not meet the

00:15:26,970 --> 00:15:30,320
requirements of string convertible

00:15:33,550 --> 00:15:39,379
as I say this is like the three-minute

00:15:36,680 --> 00:15:41,389
version of concepts and I do encourage

00:15:39,379 --> 00:15:43,069
you if you are don't know a lot about

00:15:41,389 --> 00:15:44,540
this to go to some of the other concepts

00:15:43,069 --> 00:15:50,600
towards this week if you want to learn

00:15:44,540 --> 00:15:53,720
more this is the sort of long winded way

00:15:50,600 --> 00:15:56,149
of writing these things in some cases we

00:15:53,720 --> 00:15:58,550
can use a shorthand version we can write

00:15:56,149 --> 00:16:00,499
things like this so this is exactly

00:15:58,550 --> 00:16:03,230
equivalent to what we had before this

00:16:00,499 --> 00:16:06,410
says convert to string is again a

00:16:03,230 --> 00:16:11,569
function template and now we require the

00:16:06,410 --> 00:16:16,910
T matches the string convertible

00:16:11,569 --> 00:16:18,199
template we can actually abbreviate this

00:16:16,910 --> 00:16:21,949
even more this was something that was

00:16:18,199 --> 00:16:22,759
controversial it was a lot of people

00:16:21,949 --> 00:16:25,129
didn't like and there were a lot of

00:16:22,759 --> 00:16:27,199
arguments about in the sender committee

00:16:25,129 --> 00:16:28,369
but eventually we reached a consensus

00:16:27,199 --> 00:16:29,899
that you would also be able to write it

00:16:28,369 --> 00:16:34,129
like this there's actually a slight type

00:16:29,899 --> 00:16:36,230
on my slide apologies that should be the

00:16:34,129 --> 00:16:38,720
meaning is clear or should be hope or is

00:16:36,230 --> 00:16:42,470
hopefully that this is saying that this

00:16:38,720 --> 00:16:44,720
is some deduced type and the deduced

00:16:42,470 --> 00:16:48,199
type must meet the requirements of

00:16:44,720 --> 00:16:49,730
string convertible so this is still a

00:16:48,199 --> 00:16:51,499
function template even though we're not

00:16:49,730 --> 00:16:54,410
using the template key words but rather

00:16:51,499 --> 00:16:56,629
like with lambdas the appearance of Auto

00:16:54,410 --> 00:17:02,959
in the parameter list specifies this is

00:16:56,629 --> 00:17:05,929
actually so again really hard to rush

00:17:02,959 --> 00:17:08,870
through concepts so you're all concept

00:17:05,929 --> 00:17:12,490
experts now I hope well maybe not but

00:17:08,870 --> 00:17:12,490
you know perhaps what they are at least

00:17:12,640 --> 00:17:17,419
so that's a language feature but

00:17:15,799 --> 00:17:20,390
actually what the ranges work will gives

00:17:17,419 --> 00:17:23,809
us is we're getting lots of new

00:17:20,390 --> 00:17:26,750
low-level concepts defined in the

00:17:23,809 --> 00:17:29,419
standard library things like standard

00:17:26,750 --> 00:17:32,539
same as found a constructible frog sound

00:17:29,419 --> 00:17:35,630
convertible - these are new low-level

00:17:32,539 --> 00:17:38,929
concepts that we can use as building

00:17:35,630 --> 00:17:41,630
blocks for defining our own concepts so

00:17:38,929 --> 00:17:42,860
these largely replace all the things

00:17:41,630 --> 00:17:45,190
that we have in the type traits header

00:17:42,860 --> 00:17:45,190
today

00:17:45,650 --> 00:17:50,480
we can use real language concepts and we

00:17:48,620 --> 00:17:54,520
can use those to build up our own

00:17:50,480 --> 00:17:54,520
concepts that we can use in our own code

00:17:55,720 --> 00:18:02,960
on top of that the standard library C++

00:18:00,590 --> 00:18:05,450
20 builds its own higher-level concepts

00:18:02,960 --> 00:18:06,830
as we should be doing in our own code so

00:18:05,450 --> 00:18:08,360
the standard library does and it

00:18:06,830 --> 00:18:10,130
introduces these higher-level concepts

00:18:08,360 --> 00:18:12,110
things like bi-directional iterator

00:18:10,130 --> 00:18:14,390
things like random access range and

00:18:12,110 --> 00:18:20,990
these are built out of these lower level

00:18:14,390 --> 00:18:22,580
concepts so we've got these concepts

00:18:20,990 --> 00:18:25,220
that we can use to constrain our

00:18:22,580 --> 00:18:27,559
algorithms and in fact sorry to

00:18:25,220 --> 00:18:29,990
constrain our functions and in fact

00:18:27,559 --> 00:18:33,020
that's exactly what the standard library

00:18:29,990 --> 00:18:37,850
will do with all the algorithms that we

00:18:33,020 --> 00:18:44,750
already know and love from the STL will

00:18:37,850 --> 00:18:48,470
be getting constrained algorithms so why

00:18:44,750 --> 00:18:53,120
is that a good thing well let's have a

00:18:48,470 --> 00:18:57,289
little example who's seen code like this

00:18:53,120 --> 00:19:01,149
before a few hands not many people want

00:18:57,289 --> 00:19:07,340
to admit right because nobody writes

00:19:01,149 --> 00:19:17,570
because well it's it's gonna work no no

00:19:07,340 --> 00:19:19,100
why is this not going to work I hear an

00:19:17,570 --> 00:19:23,950
Australian voice in the front most salt

00:19:19,100 --> 00:19:26,570
requires random access iteration yes and

00:19:23,950 --> 00:19:30,039
a list iterator is only a bi-directional

00:19:26,570 --> 00:19:31,850
iterator which you will new of course

00:19:30,039 --> 00:19:33,919
everybody said this wasn't going to work

00:19:31,850 --> 00:19:37,070
because you all knew the standard sort

00:19:33,919 --> 00:19:38,500
requires a random exit pair of random

00:19:37,070 --> 00:19:43,130
access iterator

00:19:38,500 --> 00:19:44,779
but the compiler doesn't know that so

00:19:43,130 --> 00:19:47,440
what's going to happen when I try and

00:19:44,779 --> 00:19:47,440
compile this code

00:19:50,420 --> 00:19:56,730
what's going to happen when I when I try

00:19:52,620 --> 00:19:59,400
and compile this code template error

00:19:56,730 --> 00:20:02,900
messages yes last time I gave this talk

00:19:59,400 --> 00:20:02,900
there was a shout on the back of kaboom

00:20:05,420 --> 00:20:13,650
yeah we get something that looks like

00:20:07,530 --> 00:20:14,130
this yeah and like this oh yeah and like

00:20:13,650 --> 00:20:30,180
this

00:20:14,130 --> 00:20:32,010
oh yeah and like this and right and and

00:20:30,180 --> 00:20:33,360
by the way I didn't like I haven't made

00:20:32,010 --> 00:20:34,680
this deliberately bad just for the

00:20:33,360 --> 00:20:37,800
purposes of demonstration I do this

00:20:34,680 --> 00:20:40,080
today with the latest Apple clang on my

00:20:37,800 --> 00:20:45,870
laptop this is this is actually what

00:20:40,080 --> 00:20:51,060
happens 442 lines of error messages for

00:20:45,870 --> 00:20:53,550
a two line program right you want to

00:20:51,060 --> 00:20:56,070
know the the reasons that you know

00:20:53,550 --> 00:20:58,680
people complain about C++ the reasons

00:20:56,070 --> 00:21:00,150
people don't like using C++ one of them

00:20:58,680 --> 00:21:03,480
that will rank pretty high on the list

00:21:00,150 --> 00:21:04,440
is this template error spew if you get

00:21:03,480 --> 00:21:06,600
something wrong you know if you're a

00:21:04,440 --> 00:21:08,490
newcomer to C++ it's not necessarily

00:21:06,600 --> 00:21:10,560
obvious why you can't sort of linked

00:21:08,490 --> 00:21:13,050
lists and then when you try and do it

00:21:10,560 --> 00:21:20,580
you're confronted with this 442 lines of

00:21:13,050 --> 00:21:25,290
errors I mean where do you even begin so

00:21:20,580 --> 00:21:27,750
let's try again this time instead of

00:21:25,290 --> 00:21:30,450
standard sort we're going to call ranges

00:21:27,750 --> 00:21:33,120
source and again no tricks

00:21:30,450 --> 00:21:35,610
nothing up my sleeve I did this this

00:21:33,120 --> 00:21:38,400
morning with my range and implementation

00:21:35,610 --> 00:21:45,930
that I'll tell you about later this is

00:21:38,400 --> 00:21:48,180
the entire error output that's it and if

00:21:45,930 --> 00:21:50,040
we scroll over here you'll see that we

00:21:48,180 --> 00:21:52,110
see tamper candidate template ignored

00:21:50,040 --> 00:21:55,680
requirement random access iterator over

00:21:52,110 --> 00:21:57,030
list there traitor was not satisfied and

00:21:55,680 --> 00:21:58,560
the second message is saying that the

00:21:57,030 --> 00:21:59,970
second candidate was ignored because the

00:21:58,560 --> 00:22:02,600
list is erasure is not arranged which

00:21:59,970 --> 00:22:07,110
I'll get onto in a second

00:22:02,600 --> 00:22:09,810
so we've gone from four hundred-plus

00:22:07,110 --> 00:22:12,120
lines of our messages to what's there

00:22:09,810 --> 00:22:14,120
eight or ten lines that make it exactly

00:22:12,120 --> 00:22:17,790
clear what the problem is

00:22:14,120 --> 00:22:18,990
so you know there's a lot of other

00:22:17,790 --> 00:22:22,440
ranges stuff I'm going to tell you about

00:22:18,990 --> 00:22:24,810
for the next 40 minutes or so but just

00:22:22,440 --> 00:22:27,360
for me personally if the ranges work

00:22:24,810 --> 00:22:29,580
brought us nothing else except this

00:22:27,360 --> 00:22:30,980
except better error messages for me that

00:22:29,580 --> 00:22:34,110
would be worth the price of admission a

00:22:30,980 --> 00:22:35,790
lot you know I think this is fantastic

00:22:34,110 --> 00:22:37,860
and it's going to make such a big

00:22:35,790 --> 00:22:39,990
difference to the everyday experience of

00:22:37,860 --> 00:22:48,780
people using C++ I really think this is

00:22:39,990 --> 00:22:50,490
great so the second thing that he's

00:22:48,780 --> 00:22:52,760
going to you know it's it's not

00:22:50,490 --> 00:22:55,290
world-changing but it's going to make

00:22:52,760 --> 00:22:57,240
just make your everyday experience of

00:22:55,290 --> 00:22:59,010
using the standard library that bit

00:22:57,240 --> 00:23:07,290
nicer we're getting range based

00:22:59,010 --> 00:23:08,520
overloads so here we have almost

00:23:07,290 --> 00:23:09,960
identical code to what we had before

00:23:08,520 --> 00:23:11,880
except this time we're using a standard

00:23:09,960 --> 00:23:13,410
vector so this is going to work this is

00:23:11,880 --> 00:23:16,440
fine this is good code this is what you

00:23:13,410 --> 00:23:19,950
write today in fact this is what you

00:23:16,440 --> 00:23:21,630
write a lot don't begin dot end don't

00:23:19,950 --> 00:23:22,890
begin dot n don't begin dot end you

00:23:21,630 --> 00:23:24,590
probably write it if you're anything

00:23:22,890 --> 00:23:33,870
like me write it dozens of times a day

00:23:24,590 --> 00:23:35,790
right no more with the new ranges

00:23:33,870 --> 00:23:36,420
libraries we're getting range based

00:23:35,790 --> 00:23:40,860
overloads

00:23:36,420 --> 00:23:43,470
you will finally be able to say standard

00:23:40,860 --> 00:23:46,160
ranges sort of my vector of my range

00:23:43,470 --> 00:23:48,720
whatever that range might be and it will

00:23:46,160 --> 00:23:52,220
sort the whole container for you the

00:23:48,720 --> 00:23:52,220
whole range for you at last

00:23:58,520 --> 00:24:04,280
one slight note of sadness one slight

00:24:01,250 --> 00:24:06,860
confession I'm sorry

00:24:04,280 --> 00:24:08,570
as it stands in C++ 20 it's only the

00:24:06,860 --> 00:24:11,150
algorithms that are in the algorithm

00:24:08,570 --> 00:24:14,810
header that are getting this range of

00:24:11,150 --> 00:24:19,460
vacation treatment there are other

00:24:14,810 --> 00:24:22,520
algorithms in the numeric header that

00:24:19,460 --> 00:24:27,380
won't be updated yet fingers crossed for

00:24:22,520 --> 00:24:28,790
C++ 23 but the vast majority of

00:24:27,380 --> 00:24:32,630
algorithms that appear in the algorithm

00:24:28,790 --> 00:24:34,100
header you will be able to use range

00:24:32,630 --> 00:24:36,290
based overloads you'll have constrained

00:24:34,100 --> 00:24:38,750
called better error messages life will

00:24:36,290 --> 00:24:41,930
be better you have what you had before

00:24:38,750 --> 00:24:44,710
but better and that's what a new major

00:24:41,930 --> 00:24:44,710
release is all about

00:24:52,640 --> 00:24:57,679
so those two features are really about

00:24:55,880 --> 00:24:58,010
taking what we had before and making you

00:24:57,679 --> 00:25:01,790
better

00:24:58,010 --> 00:25:03,370
but we've also getting some some new

00:25:01,790 --> 00:25:06,710
things that we we didn't have before

00:25:03,370 --> 00:25:12,230
things that we that are strict

00:25:06,710 --> 00:25:16,179
improvements and one of those sort of

00:25:12,230 --> 00:25:18,290
subtle but it's about sentinels so I

00:25:16,179 --> 00:25:20,390
gave a sort of very hand wavy

00:25:18,290 --> 00:25:22,309
description of what arranges what

00:25:20,390 --> 00:25:24,710
arrange is at the beginning of the talk

00:25:22,309 --> 00:25:26,840
I said the range is something upon which

00:25:24,710 --> 00:25:28,130
you can call begin and end where begin

00:25:26,840 --> 00:25:28,540
returns you this thing called knitter

00:25:28,130 --> 00:25:30,980
Aitor

00:25:28,540 --> 00:25:33,200
and we can increment the iterator until

00:25:30,980 --> 00:25:36,440
it compares equal to the thing we got

00:25:33,200 --> 00:25:39,140
from end and I was very astutely pulled

00:25:36,440 --> 00:25:43,190
up on this at the front because this was

00:25:39,140 --> 00:25:45,770
a deliberate hand wavy thing because in

00:25:43,190 --> 00:25:47,990
the new ranges worlds begin and ends

00:25:45,770 --> 00:25:50,809
don't necessarily need to return the

00:25:47,990 --> 00:25:53,840
same type in the existing engine and the

00:25:50,809 --> 00:25:57,940
existing STL end must return an iterator

00:25:53,840 --> 00:25:57,940
begin and end must return the same type

00:25:58,090 --> 00:26:03,940
as I say in the ranges world we have

00:26:01,280 --> 00:26:08,600
this new Colin new idea of a sentinel

00:26:03,940 --> 00:26:11,530
and a sentinels only job is to mark the

00:26:08,600 --> 00:26:11,530
end of a range

00:26:16,360 --> 00:26:22,659
oh I'm sorry so a sentinel is some type

00:26:20,860 --> 00:26:24,130
that is equality comparable with that's

00:26:22,659 --> 00:26:26,019
one of these new low-level concepts I

00:26:24,130 --> 00:26:27,730
was talking about senthil is some type

00:26:26,019 --> 00:26:30,100
there's equality comparable with its

00:26:27,730 --> 00:26:34,600
corresponding iterator which denotes the

00:26:30,100 --> 00:26:41,260
end of the range so why do we want this

00:26:34,600 --> 00:26:43,000
things well the first thing is that if

00:26:41,260 --> 00:26:45,519
you're using your own custom iterators

00:26:43,000 --> 00:26:48,850
using separate central types in some

00:26:45,519 --> 00:26:53,440
cases allows us to simplify writing our

00:26:48,850 --> 00:26:55,299
own iterators and you know that's nice

00:26:53,440 --> 00:26:59,559
but not many people right they're only

00:26:55,299 --> 00:27:02,740
traitors what I like even better about

00:26:59,559 --> 00:27:05,250
sentinels is that in some cases they

00:27:02,740 --> 00:27:08,350
actually allow us better code generation

00:27:05,250 --> 00:27:10,690
that is they give the optimizer more

00:27:08,350 --> 00:27:14,110
information upon which to opt optimize

00:27:10,690 --> 00:27:17,039
your code and so you get faster code and

00:27:14,110 --> 00:27:17,039
who doesn't like faster code

00:27:22,540 --> 00:27:30,400
so show you what I mean here we've got

00:27:26,720 --> 00:27:33,200
an imaginary function called read file

00:27:30,400 --> 00:27:37,640
whatever our custom file format is this

00:27:33,200 --> 00:27:41,420
reads in a string fix string several

00:27:37,640 --> 00:27:43,550
megabytes maybe and we know because we

00:27:41,420 --> 00:27:45,650
wrote the read file function we know

00:27:43,550 --> 00:27:48,530
that this string is guaranteed to

00:27:45,650 --> 00:27:50,060
contain a newline character that's this

00:27:48,530 --> 00:27:53,900
because read file just pops one on the

00:27:50,060 --> 00:27:56,360
end when it loads it in okay we know for

00:27:53,900 --> 00:27:59,900
a fact the big string contains slash in

00:27:56,360 --> 00:28:03,080
somewhere but it might might contain

00:27:59,900 --> 00:28:04,580
more than one so what we want to do is

00:28:03,080 --> 00:28:06,680
we want to find the first newline

00:28:04,580 --> 00:28:11,840
character that appears in our big string

00:28:06,680 --> 00:28:13,010
that we read in from the file so we

00:28:11,840 --> 00:28:14,870
begin at the beginning

00:28:13,010 --> 00:28:17,150
we compare every character to see

00:28:14,870 --> 00:28:19,190
whether we've got a slash n it's a

00:28:17,150 --> 00:28:23,030
linear search linear search of course

00:28:19,190 --> 00:28:27,110
you standard find get intercept or mode

00:28:23,030 --> 00:28:29,360
obviously that's fine so this is how you

00:28:27,110 --> 00:28:30,560
do it today we search from the beginning

00:28:29,360 --> 00:28:33,080
of the string to the end of the string

00:28:30,560 --> 00:28:34,280
for the slash n character and this is

00:28:33,080 --> 00:28:36,170
fine this is good there's nothing wrong

00:28:34,280 --> 00:28:38,810
with this code right this is this is

00:28:36,170 --> 00:28:44,600
good code with pass code review today I

00:28:38,810 --> 00:28:48,860
hope in your organization's but this is

00:28:44,600 --> 00:28:50,930
not optimal and the reason it's not

00:28:48,860 --> 00:28:53,180
optimal is because we have extra

00:28:50,930 --> 00:28:56,390
information that we're not communicating

00:28:53,180 --> 00:28:58,310
to the compiler and really to get a

00:28:56,390 --> 00:29:00,470
sense of that let's have a quick look at

00:28:58,310 --> 00:29:02,300
an implementation of standard find so

00:29:00,470 --> 00:29:04,790
this is a conforming implementation of

00:29:02,300 --> 00:29:08,720
find as it exists today we take two

00:29:04,790 --> 00:29:11,690
iterators we say while first is not

00:29:08,720 --> 00:29:15,470
equal to last that is if we're not at

00:29:11,690 --> 00:29:18,020
the end of the range we compare the

00:29:15,470 --> 00:29:21,050
value that's the first position to the

00:29:18,020 --> 00:29:23,000
given value and if that matches we break

00:29:21,050 --> 00:29:26,120
out a loop and we return the iterator

00:29:23,000 --> 00:29:27,560
that we currently use if not we

00:29:26,120 --> 00:29:30,260
increment the iterator and we start

00:29:27,560 --> 00:29:34,330
again we make we say are we at the end

00:29:30,260 --> 00:29:34,330
of the range yet okay no we're not

00:29:35,040 --> 00:29:44,760
let's test to see whether we've reached

00:29:37,290 --> 00:29:48,230
the values the thing is we know because

00:29:44,760 --> 00:29:51,570
we wrote a read file function we know

00:29:48,230 --> 00:29:52,920
that we're going to find a new line

00:29:51,570 --> 00:29:55,140
before we reach the end of the range

00:29:52,920 --> 00:29:56,570
we're sure about that you're a hundred

00:29:55,140 --> 00:30:01,320
percent sure

00:29:56,570 --> 00:30:04,380
so this first condition well first not

00:30:01,320 --> 00:30:06,480
equal to last that is never gonna return

00:30:04,380 --> 00:30:08,280
true we are always going to break out of

00:30:06,480 --> 00:30:14,180
the loop before we reach the end of the

00:30:08,280 --> 00:30:14,180
range but the compiler doesn't know that

00:30:16,190 --> 00:30:21,570
we've got no way of communicating it in

00:30:18,750 --> 00:30:26,100
today's world to the compiler well in

00:30:21,570 --> 00:30:30,150
the ranges world C++ 20 world we have we

00:30:26,100 --> 00:30:34,320
have this new special sentinel type it's

00:30:30,150 --> 00:30:39,390
called unreachable sentinel and what not

00:30:34,320 --> 00:30:42,330
reachable sentinel is is a sort of how

00:30:39,390 --> 00:30:44,940
to put it a sentinel that you can use

00:30:42,330 --> 00:30:47,850
with any iterator type that always

00:30:44,940 --> 00:30:49,800
returns false when you say is it equal

00:30:47,850 --> 00:30:52,440
to an iterator for any given iterator

00:30:49,800 --> 00:30:54,330
unreachable sentinel will return false

00:30:52,440 --> 00:30:59,970
from its overloaded operator equals

00:30:54,330 --> 00:31:02,640
equals that is to say with this version

00:30:59,970 --> 00:31:03,270
of ranges finds we are communicating to

00:31:02,640 --> 00:31:05,580
the compiler

00:31:03,270 --> 00:31:12,420
now that we can never reach the end of

00:31:05,580 --> 00:31:15,720
the range so our sort of pseudocode

00:31:12,420 --> 00:31:17,850
implementation or specialization of find

00:31:15,720 --> 00:31:20,150
looks something like this I didn't want

00:31:17,850 --> 00:31:24,450
to put in all the string iterator noise

00:31:20,150 --> 00:31:28,230
so we'll stick with I in Bao for now but

00:31:24,450 --> 00:31:31,650
now we have our unreachable sentinel for

00:31:28,230 --> 00:31:33,330
the last and now the compiler is going

00:31:31,650 --> 00:31:35,040
to compile this code and it's going to

00:31:33,330 --> 00:31:39,660
look at this condition while first it's

00:31:35,040 --> 00:31:41,790
not equal to last well an unreachable

00:31:39,660 --> 00:31:45,600
sentinel unconditionally returns false

00:31:41,790 --> 00:31:48,909
from operator equals and returns true

00:31:45,600 --> 00:31:51,159
from operator not equals unconditionally

00:31:48,909 --> 00:31:52,869
and the come but this is all you know

00:31:51,159 --> 00:31:54,460
inline functions the compiler can see

00:31:52,869 --> 00:31:58,349
this the compiler can use this

00:31:54,460 --> 00:32:02,320
information the compiler effectively

00:31:58,349 --> 00:32:04,690
transforms this into while true it

00:32:02,320 --> 00:32:07,419
removes a comparison we were previously

00:32:04,690 --> 00:32:11,619
doing two comparisons for every element

00:32:07,419 --> 00:32:14,950
in the loop we're now doing only one so

00:32:11,619 --> 00:32:17,139
I have a link there to compiler Explorer

00:32:14,950 --> 00:32:18,820
that I was going to show you but I'm not

00:32:17,139 --> 00:32:21,759
100% convinced I'm going to be able to

00:32:18,820 --> 00:32:23,679
flick back to the slides so you're going

00:32:21,759 --> 00:32:26,249
to have to take it on trust that this

00:32:23,679 --> 00:32:29,229
actually does compile to shorter

00:32:26,249 --> 00:32:31,989
assembly if you want to look at the

00:32:29,229 --> 00:32:33,669
slides earlier later you can go to this

00:32:31,989 --> 00:32:35,559
link yourself you can verify it for

00:32:33,669 --> 00:32:37,239
yourself but just for now you're going

00:32:35,559 --> 00:32:39,629
to have to believe me that this actually

00:32:37,239 --> 00:32:42,639
really does make a difference and you

00:32:39,629 --> 00:32:44,470
can benchmark this and show that it it

00:32:42,639 --> 00:32:47,859
makes a difference in actual micro

00:32:44,470 --> 00:32:52,559
benchmarks as well this is good stuff

00:32:47,859 --> 00:32:52,559
this is making your code faster and

00:33:02,130 --> 00:33:04,400
okay

00:33:05,399 --> 00:33:11,460
talked about constrain calls range based

00:33:09,419 --> 00:33:13,200
overloads there's new feature we're

00:33:11,460 --> 00:33:14,730
getting called sentinels just perhaps

00:33:13,200 --> 00:33:16,740
not something you'll be using every day

00:33:14,730 --> 00:33:19,499
but something that you can use that is

00:33:16,740 --> 00:33:23,159
there a new tool in your toolbox when

00:33:19,499 --> 00:33:25,769
it's appropriate let's talk about

00:33:23,159 --> 00:33:26,970
something else that's actually in my

00:33:25,769 --> 00:33:29,340
experience not a lot of people know

00:33:26,970 --> 00:33:32,159
about it and that's something called

00:33:29,340 --> 00:33:34,110
projections so a few of you perhaps

00:33:32,159 --> 00:33:35,429
doesn't know if you put your hands up at

00:33:34,110 --> 00:33:43,289
the beginning when asked who uses range

00:33:35,429 --> 00:33:48,179
of e3 so Eric D blur at the back put his

00:33:43,289 --> 00:33:49,080
hand up I wonder why so of those people

00:33:48,179 --> 00:33:57,360
who put their hands up who uses

00:33:49,080 --> 00:33:59,129
projections Chris Chris Dodd here so my

00:33:57,360 --> 00:34:01,289
experience with this is that even for

00:33:59,129 --> 00:34:03,779
people who are who are using ranges who

00:34:01,289 --> 00:34:05,970
using the using rings we've three using

00:34:03,779 --> 00:34:07,350
one of the implementations projections

00:34:05,970 --> 00:34:10,169
are sort of a bit mysterious and a bit

00:34:07,350 --> 00:34:12,599
new and a bit weird and people aren't

00:34:10,169 --> 00:34:15,060
really familiar with them so my goal

00:34:12,599 --> 00:34:17,280
over the next five minutes or so is to

00:34:15,060 --> 00:34:20,639
try and demystify what projections are

00:34:17,280 --> 00:34:23,220
and show you an example of how

00:34:20,639 --> 00:34:26,270
projections can you know make your code

00:34:23,220 --> 00:34:29,579
look pretty

00:34:26,270 --> 00:34:31,200
so demystifying projections well what is

00:34:29,579 --> 00:34:32,940
a projection okay projection is a unary

00:34:31,200 --> 00:34:38,040
callable which may be passed to most

00:34:32,940 --> 00:34:41,879
algorithms and which modify the view of

00:34:38,040 --> 00:34:46,079
the data that the algorithm sees okay

00:34:41,879 --> 00:34:48,389
that's nice and clear alright move on no

00:34:46,079 --> 00:34:54,510
I'm I'm not sure this this demystifies

00:34:48,389 --> 00:34:56,669
it very much let's try and have a look

00:34:54,510 --> 00:35:00,079
at it example to see if that can

00:34:56,669 --> 00:35:00,079
demonstrate what I'm talking about in it

00:35:01,760 --> 00:35:09,450
so here we've got two strokes we've got

00:35:05,730 --> 00:35:11,490
an employee and a payslip so an employee

00:35:09,450 --> 00:35:13,170
has a name and an ID number and a

00:35:11,490 --> 00:35:14,549
payslip has the paying foe we don't

00:35:13,170 --> 00:35:15,839
really care what that is the employee

00:35:14,549 --> 00:35:17,760
might but we don't really for the

00:35:15,839 --> 00:35:19,079
purposes of this demonstration and a

00:35:17,760 --> 00:35:21,329
payslip also has the employee

00:35:19,079 --> 00:35:24,180
Eydie the employee to which the payslip

00:35:21,329 --> 00:35:25,469
corresponds and we've got a vector of

00:35:24,180 --> 00:35:26,819
employees and we've got a vector up a

00:35:25,469 --> 00:35:29,190
slit spatula writing you know some

00:35:26,819 --> 00:35:30,509
accounting software or whatever we have

00:35:29,190 --> 00:35:33,660
the vector of employees and a vector of

00:35:30,509 --> 00:35:35,880
pay slips and now a job what we want to

00:35:33,660 --> 00:35:38,369
do our goal is to make sure that every

00:35:35,880 --> 00:35:41,519
employee receives exactly one pay slip

00:35:38,369 --> 00:35:43,529
every month okay we don't want the

00:35:41,519 --> 00:35:45,180
employee to receive zero pay slips they

00:35:43,529 --> 00:35:46,890
wouldn't be very happy about that we

00:35:45,180 --> 00:35:47,940
don't want to pay any employee twice the

00:35:46,890 --> 00:35:49,019
company wouldn't be very happy about

00:35:47,940 --> 00:35:52,619
that although the employee would

00:35:49,019 --> 00:35:57,559
probably like it so we want to make sure

00:35:52,619 --> 00:35:57,559
every employee has precisely one Paisley

00:35:57,709 --> 00:36:03,029
so can anybody think of how we might do

00:36:00,390 --> 00:36:09,599
that given these definitions that are on

00:36:03,029 --> 00:36:13,079
the screen right now no limit is okay

00:36:09,599 --> 00:36:16,650
well one way that we might do it is we

00:36:13,079 --> 00:36:18,630
might think okay how about I sort my

00:36:16,650 --> 00:36:22,579
vector of employees according to their

00:36:18,630 --> 00:36:26,130
ID and we sort our vector of pay slips

00:36:22,579 --> 00:36:29,549
according to the employee ID and then we

00:36:26,130 --> 00:36:32,729
compare those two vectors by their

00:36:29,549 --> 00:36:34,259
respective ID values and make sure that

00:36:32,729 --> 00:36:44,789
they contain the same IDs in the same

00:36:34,259 --> 00:36:46,890
orders right sorry intersection we could

00:36:44,789 --> 00:36:52,650
but you know I've written sort on the

00:36:46,890 --> 00:36:57,769
slide so that's where you get so this is

00:36:52,650 --> 00:36:59,670
what that approach might look like today

00:36:57,769 --> 00:37:01,890
with the existing Sto

00:36:59,670 --> 00:37:03,809
we can say we sort our employees we

00:37:01,890 --> 00:37:07,430
passed a custom comparator that compares

00:37:03,809 --> 00:37:10,170
their IDs we sort the payslips vector

00:37:07,430 --> 00:37:12,749
again with a custom comparator comparing

00:37:10,170 --> 00:37:15,719
the employee ID fields and then finally

00:37:12,749 --> 00:37:17,789
we call this standard equal algorithm

00:37:15,719 --> 00:37:20,009
that make sure the two vectors have the

00:37:17,789 --> 00:37:23,039
same elements in the same order and

00:37:20,009 --> 00:37:23,930
again we pass a custom comparator to

00:37:23,039 --> 00:37:26,039
that

00:37:23,930 --> 00:37:28,319
well of course have just explained we're

00:37:26,039 --> 00:37:30,390
getting nice new range based overloads

00:37:28,319 --> 00:37:33,850
so the first thing we want to do is make

00:37:30,390 --> 00:37:41,920
use of that get rid of all that begin

00:37:33,850 --> 00:37:45,880
so things get nicer already but we can

00:37:41,920 --> 00:37:47,470
make this better still so remember what

00:37:45,880 --> 00:37:49,570
I said at the beginning or the beginning

00:37:47,470 --> 00:37:51,400
of this section projection is you know

00:37:49,570 --> 00:37:52,930
recallable that we can pass to most

00:37:51,400 --> 00:37:55,119
algorithms including the three that were

00:37:52,930 --> 00:37:58,000
on the screen just now and a projection

00:37:55,119 --> 00:38:03,400
modifies the view of the data that the

00:37:58,000 --> 00:38:04,930
algorithm sees so it's now write down

00:38:03,400 --> 00:38:07,540
we'll just look at our first call to

00:38:04,930 --> 00:38:09,760
sort so we're sorting the employees

00:38:07,540 --> 00:38:12,490
vector using this custom comparator and

00:38:09,760 --> 00:38:15,550
the custom comparator says okay if X is

00:38:12,490 --> 00:38:25,990
ID field is less than wise ID field then

00:38:15,550 --> 00:38:30,820
I'm going to use that well we can modify

00:38:25,990 --> 00:38:35,290
this to use a projection to project each

00:38:30,820 --> 00:38:37,270
employee to its ID field so we've added

00:38:35,290 --> 00:38:38,920
an extra parameter this time this time

00:38:37,270 --> 00:38:40,270
we're not using a custom comparator

00:38:38,920 --> 00:38:42,790
we're using one of the standard

00:38:40,270 --> 00:38:44,260
comparators standard range is less this

00:38:42,790 --> 00:38:45,750
is more or less the same as standard

00:38:44,260 --> 00:38:50,050
less that we've got at the moment except

00:38:45,750 --> 00:38:52,090
uses the new concepts constraints so

00:38:50,050 --> 00:38:54,700
we've got standard range is less and now

00:38:52,090 --> 00:38:57,700
we're passing a new parameter which is

00:38:54,700 --> 00:39:03,190
the projection so we are projecting each

00:38:57,700 --> 00:39:05,590
employee E to its ID field so now sort

00:39:03,190 --> 00:39:08,710
is operating as far as thought is

00:39:05,590 --> 00:39:11,440
concerned it only sees integers salt is

00:39:08,710 --> 00:39:15,210
operating purely on its because each

00:39:11,440 --> 00:39:15,210
employee has been projected to an int

00:39:17,310 --> 00:39:25,000
and we can apply this to our other call

00:39:20,619 --> 00:39:28,119
to sort and to equal as well so now

00:39:25,000 --> 00:39:32,770
we're using projections for our to sort

00:39:28,119 --> 00:39:37,690
calls and for their call to equal we're

00:39:32,770 --> 00:39:39,280
using the equal to comparator and then

00:39:37,690 --> 00:39:43,300
we're projecting the employee in the pay

00:39:39,280 --> 00:39:44,290
slip to their respective fields and you

00:39:43,300 --> 00:39:45,520
might look at this and say well that

00:39:44,290 --> 00:39:46,420
doesn't actually look like too much of a

00:39:45,520 --> 00:39:49,210
benefit to me right

00:39:46,420 --> 00:39:52,599
because well it's still using lambdas

00:39:49,210 --> 00:39:54,849
still using a lot of noise but in fact

00:39:52,599 --> 00:39:58,119
the way projections work the way this is

00:39:54,849 --> 00:40:00,190
specified in the new standards is that

00:39:58,119 --> 00:40:03,700
these projections are going to be routed

00:40:00,190 --> 00:40:06,160
through an implementation of standard in

00:40:03,700 --> 00:40:08,950
bulk and standard in vogue for those who

00:40:06,160 --> 00:40:10,690
don't know has a bit of magic has a bit

00:40:08,950 --> 00:40:15,460
of magic that lets you treat pointers to

00:40:10,690 --> 00:40:17,440
members effectively as callable so we

00:40:15,460 --> 00:40:19,890
can use this new magic that's in

00:40:17,440 --> 00:40:25,839
standard invoke to replace these lambdas

00:40:19,890 --> 00:40:28,630
with pointers to member data so we can

00:40:25,839 --> 00:40:31,480
read this and say okay we're going to

00:40:28,630 --> 00:40:34,089
sort employees using the less comparator

00:40:31,480 --> 00:40:37,990
where each employee is projected to its

00:40:34,089 --> 00:40:41,799
ID field and we're going to compare the

00:40:37,990 --> 00:40:43,869
employees and payslips vectors using the

00:40:41,799 --> 00:40:46,450
equal to comparator where each employee

00:40:43,869 --> 00:40:48,490
is projected to its ID field and where

00:40:46,450 --> 00:40:54,490
each payslip is projected to its

00:40:48,490 --> 00:40:58,690
employee ID field we can actually make

00:40:54,490 --> 00:41:01,150
this better yet because they default

00:40:58,690 --> 00:41:02,950
comparator for sort is to use less the

00:41:01,150 --> 00:41:06,609
default comparator for equal is to use

00:41:02,950 --> 00:41:10,780
equal to so we can in fact just default

00:41:06,609 --> 00:41:15,880
construct these parameters just by using

00:41:10,780 --> 00:41:18,130
an empty pair of curly braces so we now

00:41:15,880 --> 00:41:20,020
say we want to sort employees using the

00:41:18,130 --> 00:41:22,450
default comparator where each according

00:41:20,020 --> 00:41:24,010
to the employee ID we want to sort the

00:41:22,450 --> 00:41:26,799
payslips using the default comparator

00:41:24,010 --> 00:41:29,589
according to the employee ID then we

00:41:26,799 --> 00:41:34,030
want to compare employees and payslips

00:41:29,589 --> 00:41:36,309
using the default comparator according

00:41:34,030 --> 00:41:40,930
to the employee ID field and the payslip

00:41:36,309 --> 00:41:43,780
employee ID field so this was our

00:41:40,930 --> 00:41:49,390
original standard today's sequence bus

00:41:43,780 --> 00:41:52,030
17 standard code and this is what we're

00:41:49,390 --> 00:41:55,530
getting in c++ 20 this is what you can

00:41:52,030 --> 00:41:55,530
do with the new

00:41:56,510 --> 00:42:08,000
punctuality yes well then you might have

00:42:06,560 --> 00:42:10,340
to use a different approach you know

00:42:08,000 --> 00:42:17,119
this is there are various ways of doing

00:42:10,340 --> 00:42:18,890
this well if you want to sort you have

00:42:17,119 --> 00:42:21,320
to you know take a copy then I'll guess

00:42:18,890 --> 00:42:23,710
or yeah we use a different approach that

00:42:21,320 --> 00:42:23,710
doesn't evolve

00:42:31,540 --> 00:42:38,420
you didn't know that well by the way do

00:42:37,040 --> 00:42:40,040
you know how nerve-racking it is for me

00:42:38,420 --> 00:42:43,300
talking about ranges when Eric Niebla

00:42:40,040 --> 00:42:43,300
has a question in the background

00:43:10,140 --> 00:43:17,109
of course yeah yes so Aaron makes a very

00:43:14,800 --> 00:43:19,930
good point is that I was slightly lacks

00:43:17,109 --> 00:43:22,090
in my terminology on the slides I'll

00:43:19,930 --> 00:43:25,140
remember that for next time but actually

00:43:22,090 --> 00:43:27,790
this is going to sort the employee

00:43:25,140 --> 00:43:29,109
struct themselves right this is not just

00:43:27,790 --> 00:43:30,280
going to swap the IDS because that's

00:43:29,109 --> 00:43:33,130
definitely not something you want to do

00:43:30,280 --> 00:43:34,330
low perhaps if you got your ID swapped

00:43:33,130 --> 00:43:39,010
with the managers and you got his pay

00:43:34,330 --> 00:43:41,400
slip you wouldn't complain taken about

00:43:39,010 --> 00:43:44,920
money is the company's concern anyway

00:43:41,400 --> 00:43:47,380
yes so this as eric of course riley

00:43:44,920 --> 00:43:51,270
points out this is going to swap the

00:43:47,380 --> 00:43:51,270
employee stock yes

00:44:11,130 --> 00:44:15,599
right and the so the algorithms you're

00:44:14,309 --> 00:44:17,039
saying the algorithms have to document

00:44:15,599 --> 00:44:19,319
what they do with the projections and in

00:44:17,039 --> 00:44:22,380
fact they do exactly that so they if you

00:44:19,319 --> 00:44:23,940
you read the sand at ease and on cpp

00:44:22,380 --> 00:44:25,170
reference as well I'm sure it actually

00:44:23,940 --> 00:44:27,479
documents how many times these

00:44:25,170 --> 00:44:31,519
projection functions get called for all

00:44:27,479 --> 00:44:33,809
of the algorithms yeah and actually it's

00:44:31,519 --> 00:44:35,880
not your question but just came to mind

00:44:33,809 --> 00:44:37,769
while you're saying it they're actually

00:44:35,880 --> 00:44:41,809
default projections that is just like a

00:44:37,769 --> 00:44:43,769
pass through is what so these are like

00:44:41,809 --> 00:44:44,940
default parameters and the default

00:44:43,769 --> 00:44:47,940
parameter is just to pass through

00:44:44,940 --> 00:44:48,900
projection that the identity projection

00:44:47,940 --> 00:45:01,710
the compiler can see straight through

00:44:48,900 --> 00:45:03,509
yes yeah so so we're using here we're

00:45:01,710 --> 00:45:05,670
using a pointer to a member data as our

00:45:03,509 --> 00:45:07,890
projection what if we wanted to use a

00:45:05,670 --> 00:45:10,140
getter function say we can use a pointer

00:45:07,890 --> 00:45:14,789
to a member function as well that works

00:45:10,140 --> 00:45:17,299
just fine yes yes yeah one more and then

00:45:14,789 --> 00:45:17,299
we're gonna have to

00:45:29,690 --> 00:45:37,680
it so if you were to switch employee ID

00:45:34,320 --> 00:45:39,810
of ref employee ID and pay slip employee

00:45:37,680 --> 00:45:47,340
ID in this function call it would not

00:45:39,810 --> 00:45:50,040
compile it's not good so it would not

00:45:47,340 --> 00:45:53,310
compile because it's using a pointer to

00:45:50,040 --> 00:45:59,400
a member and you know that it's just the

00:45:53,310 --> 00:46:01,830
wrong type for the pointers okay

00:45:59,400 --> 00:46:03,600
so the last thing we're going to talk

00:46:01,830 --> 00:46:06,300
about today before we get on to the

00:46:03,600 --> 00:46:08,580
implementations is perhaps the biggest

00:46:06,300 --> 00:46:12,360
headline feature and perhaps the one

00:46:08,580 --> 00:46:17,880
that you are most interested in so I

00:46:12,360 --> 00:46:19,470
want to talk about views so I say where

00:46:17,880 --> 00:46:22,770
are we we've got about 15 minutes left

00:46:19,470 --> 00:46:25,290
so I can't do justice to what views can

00:46:22,770 --> 00:46:27,600
bring to your code in 15 minutes

00:46:25,290 --> 00:46:31,230
in fact you could do an entire talk or a

00:46:27,600 --> 00:46:34,170
couple of our talks just on views and

00:46:31,230 --> 00:46:35,820
range adapters and the good news is that

00:46:34,170 --> 00:46:37,290
this week people are doing exactly that

00:46:35,820 --> 00:46:39,570
there are many talks about ranges this

00:46:37,290 --> 00:46:41,670
week and whilst I'm giving kind of the

00:46:39,570 --> 00:46:43,410
broad brush overview of what the new

00:46:41,670 --> 00:46:46,230
features are there are people who are

00:46:43,410 --> 00:46:48,510
going into more detail so I really

00:46:46,230 --> 00:46:50,220
encourage you you know I'm going to give

00:46:48,510 --> 00:46:52,200
you the very short version but I really

00:46:50,220 --> 00:46:53,730
encourage you if you're interested to

00:46:52,200 --> 00:46:56,280
have a look through the schedule look at

00:46:53,730 --> 00:47:04,500
the ranges talks and pick out the ones

00:46:56,280 --> 00:47:06,150
you like so views range adapters let's

00:47:04,500 --> 00:47:09,420
begin at the beginning the standard

00:47:06,150 --> 00:47:11,820
algorithms are great everyone agrees

00:47:09,420 --> 00:47:13,800
right San Diegans are great so that

00:47:11,820 --> 00:47:15,710
wasn't the standard algorithms are great

00:47:13,800 --> 00:47:18,420
and they're going to get even better

00:47:15,710 --> 00:47:20,010
everything I've talked about so far is

00:47:18,420 --> 00:47:24,720
about making the standard algorithms

00:47:20,010 --> 00:47:28,920
even better but the standard algorithms

00:47:24,720 --> 00:47:32,270
have a drawback and the drawback is they

00:47:28,920 --> 00:47:32,270
don't compose well

00:47:34,540 --> 00:47:43,910
what I mean by that is they perform

00:47:36,980 --> 00:47:45,680
their operations eagerly so again a very

00:47:43,910 --> 00:47:50,150
short code example to show you what I'm

00:47:45,680 --> 00:47:54,770
getting at so here we've got a function

00:47:50,150 --> 00:47:57,260
called print squares very simple all we

00:47:54,770 --> 00:47:59,119
do is we iterate over every element in

00:47:57,260 --> 00:48:03,140
the vector and we print out the square

00:47:59,119 --> 00:48:08,900
of that int right pretty straightforward

00:48:03,140 --> 00:48:10,820
okay but we are very diligent C++

00:48:08,900 --> 00:48:12,100
programmers we watch a lot of conference

00:48:10,820 --> 00:48:15,290
talks we attend a lot of conferences

00:48:12,100 --> 00:48:16,790
conferences we listen to the experts we

00:48:15,290 --> 00:48:21,050
listen to the masters and in particular

00:48:16,790 --> 00:48:25,220
we listen to Shawn parents and Shawn

00:48:21,050 --> 00:48:27,440
parents says no wrong loops right prefer

00:48:25,220 --> 00:48:31,310
the standard library algorithms whenever

00:48:27,440 --> 00:48:33,140
it's appropriate now in fairness of

00:48:31,310 --> 00:48:35,090
course Shawn is not talking about you

00:48:33,140 --> 00:48:37,640
know trivial one-line for loops like

00:48:35,090 --> 00:48:39,380
this no definitely not but I didn't have

00:48:37,640 --> 00:48:41,359
space on the slide to fit a whole

00:48:39,380 --> 00:48:44,660
implementation of rotates on there so

00:48:41,359 --> 00:48:47,420
you've got a very simple one so although

00:48:44,660 --> 00:48:50,020
this is simply a demonstration let's

00:48:47,420 --> 00:48:52,970
take the spirit of what Shawn means and

00:48:50,020 --> 00:48:54,800
apply this to our little print squares

00:48:52,970 --> 00:48:58,580
function so there are a few ways you

00:48:54,800 --> 00:49:00,320
could do this here is one we're going to

00:48:58,580 --> 00:49:03,740
use standard transform which is going to

00:49:00,320 --> 00:49:06,980
become ranges transform and we're going

00:49:03,740 --> 00:49:08,210
to transform our vector and we're going

00:49:06,980 --> 00:49:11,109
to place the output from this

00:49:08,210 --> 00:49:14,060
calculation into this Oh stream iterator

00:49:11,109 --> 00:49:16,880
this is the same Oh stream iterator we

00:49:14,060 --> 00:49:18,710
already have so you're not familiar with

00:49:16,880 --> 00:49:21,470
it this is you can look this up this is

00:49:18,710 --> 00:49:26,210
not changing so we're going to again

00:49:21,470 --> 00:49:28,730
iterate over our vector call this

00:49:26,210 --> 00:49:31,040
function perform this calculation for

00:49:28,730 --> 00:49:35,540
every element in the vector and then

00:49:31,040 --> 00:49:37,070
we're going to print the output so this

00:49:35,540 --> 00:49:41,050
is equivalent to what we had before this

00:49:37,070 --> 00:49:41,050
is taking the spirit of Shawn's advice

00:49:41,260 --> 00:49:45,470
albeit in a situation that you shouldn't

00:49:43,580 --> 00:49:47,299
actually because we did had just have a

00:49:45,470 --> 00:49:49,909
trivial loop but taking the spirit

00:49:47,299 --> 00:49:53,719
and using a standard library call

00:49:49,909 --> 00:49:55,429
instead but what happens if the

00:49:53,719 --> 00:49:58,939
requirements of our function now change

00:49:55,429 --> 00:50:05,839
so instead of print squares we want to

00:49:58,939 --> 00:50:08,329
print the even squares so back to our

00:50:05,839 --> 00:50:09,709
for loop implementation this again is

00:50:08,329 --> 00:50:13,429
pretty simple we iterate over every

00:50:09,709 --> 00:50:16,039
element I in the vector we say I'm

00:50:13,429 --> 00:50:17,839
module a2 is 0 that's if I is even we're

00:50:16,039 --> 00:50:24,049
going to print it and otherwise you know

00:50:17,839 --> 00:50:26,659
we just skip to the next element fairly

00:50:24,049 --> 00:50:30,909
straightforward but how do we do this

00:50:26,659 --> 00:50:30,909
using the standard library algorithms

00:50:31,989 --> 00:50:41,779
hmm this is uh this is this is not so

00:50:36,649 --> 00:50:43,640
easy hmm okay well here's way one way

00:50:41,779 --> 00:50:45,259
you might do it there are again a few

00:50:43,640 --> 00:50:47,419
different ways that you could you could

00:50:45,259 --> 00:50:49,519
approach this this is one way that you

00:50:47,419 --> 00:50:53,769
might do it you might say okay well

00:50:49,519 --> 00:50:57,289
we're going to remove remove all of the

00:50:53,769 --> 00:50:58,999
odd elements and of course the remove

00:50:57,289 --> 00:51:01,429
algorithm actually reorders the

00:50:58,999 --> 00:51:03,649
container moves all the false elements

00:51:01,429 --> 00:51:05,029
to the end so we're going to reorder our

00:51:03,649 --> 00:51:05,869
container move all the false elements to

00:51:05,029 --> 00:51:08,479
the end and then we're just going to

00:51:05,869 --> 00:51:09,829
again as we did before transform the

00:51:08,479 --> 00:51:16,579
subset of these elements that are true

00:51:09,829 --> 00:51:20,419
and this is fine this works but it's not

00:51:16,579 --> 00:51:21,859
great we're having to modify the vector

00:51:20,419 --> 00:51:23,299
when we didn't before you see we're now

00:51:21,859 --> 00:51:24,619
taking the vector we're taking a copy of

00:51:23,299 --> 00:51:29,089
the vector whereas before we're taking a

00:51:24,619 --> 00:51:30,769
Const reference and the reason we've had

00:51:29,089 --> 00:51:34,819
to do this is because the standard

00:51:30,769 --> 00:51:38,059
library algorithms operate eagerly that

00:51:34,819 --> 00:51:39,979
is we've had to remove if has had to

00:51:38,059 --> 00:51:44,509
finish all of its work before we move on

00:51:39,979 --> 00:51:46,939
to doing the transform so C++ 20

00:51:44,509 --> 00:51:49,429
includes new range adapters these things

00:51:46,939 --> 00:51:54,769
mysterious things we call views and

00:51:49,429 --> 00:51:55,939
offer lazy evaluation this is something

00:51:54,769 --> 00:51:57,469
functional programmers have been doing

00:51:55,939 --> 00:52:00,470
for years and something that we will be

00:51:57,469 --> 00:52:02,750
getting in C++ 20

00:52:00,470 --> 00:52:06,800
so what's this look like if we use these

00:52:02,750 --> 00:52:07,760
range adapters well it might look

00:52:06,800 --> 00:52:10,460
something like this

00:52:07,760 --> 00:52:15,760
so here we're making use of two of these

00:52:10,460 --> 00:52:17,960
adapters namely filter and transform so

00:52:15,760 --> 00:52:18,849
let's look at the inner filter called

00:52:17,960 --> 00:52:22,460
first

00:52:18,849 --> 00:52:27,319
so we're saying we want to adapt our

00:52:22,460 --> 00:52:30,020
vector adapt this range and we want to

00:52:27,319 --> 00:52:33,020
filter so it only returns those elements

00:52:30,020 --> 00:52:37,960
that are true so ranges views filter

00:52:33,020 --> 00:52:41,599
that you see there returns a new range

00:52:37,960 --> 00:52:43,420
but a lazy range it does nothing until

00:52:41,599 --> 00:52:47,270
you start to iterate over it

00:52:43,420 --> 00:52:49,579
it's an adapted range and then we passed

00:52:47,270 --> 00:52:52,069
this adapted range into a second adapter

00:52:49,579 --> 00:52:55,430
into a transform adapter and this

00:52:52,069 --> 00:52:58,220
transform applies this square function

00:52:55,430 --> 00:53:06,880
every time we directly reference one of

00:52:58,220 --> 00:53:11,359
its iterators so we set up this view

00:53:06,880 --> 00:53:15,740
this in these nested adapters we filter

00:53:11,359 --> 00:53:20,599
and then we transform and then finally

00:53:15,740 --> 00:53:23,380
we copy the values into the old stream

00:53:20,599 --> 00:53:23,380
as we did before

00:53:27,109 --> 00:53:32,269
so it's worth pointing out that actually

00:53:29,089 --> 00:53:35,029
no work no iteration happens in the

00:53:32,269 --> 00:53:37,009
setup step in the view step that just

00:53:35,029 --> 00:53:38,239
sets up the transforms with the

00:53:37,009 --> 00:53:40,099
transform and the filter that we want to

00:53:38,239 --> 00:53:42,380
do the work in this case the actual

00:53:40,099 --> 00:53:45,170
iteration happens in the algorithm call

00:53:42,380 --> 00:53:50,390
in the copy call the rest is just

00:53:45,170 --> 00:53:55,579
setting up our adapter schemes our

00:53:50,390 --> 00:53:58,880
adapter scheme and this you know this is

00:53:55,579 --> 00:54:00,619
this is great this means that we don't

00:53:58,880 --> 00:54:03,859
we can now just have our con specter

00:54:00,619 --> 00:54:05,959
again and we're going to lazily apply

00:54:03,859 --> 00:54:13,279
this filter in this transform as we

00:54:05,959 --> 00:54:16,489
iterate only once over our vector and

00:54:13,279 --> 00:54:19,279
this is good but you know we can make it

00:54:16,489 --> 00:54:22,940
even better and the problem with this is

00:54:19,279 --> 00:54:24,589
that it's sort of inside out because

00:54:22,940 --> 00:54:27,279
first of all we're filtering the vector

00:54:24,589 --> 00:54:30,469
and then we're applying a transform and

00:54:27,279 --> 00:54:34,339
so you have to read this sort of inside

00:54:30,469 --> 00:54:36,949
out and the equivalent functionality in

00:54:34,339 --> 00:54:38,989
other languages you'll know c-sharp for

00:54:36,949 --> 00:54:43,309
example you can just do you know dot

00:54:38,989 --> 00:54:48,440
this dot that you can set up your calls

00:54:43,309 --> 00:54:51,229
so they form a linear sequence and the

00:54:48,440 --> 00:54:54,410
ranges work has overloads

00:54:51,229 --> 00:54:55,729
that allow us to do this so this is

00:54:54,410 --> 00:55:01,640
exactly equivalent to what we had before

00:54:55,729 --> 00:55:02,779
oh except I've got the the - sorry I've

00:55:01,640 --> 00:55:06,259
got the to lambda calls the wrong way

00:55:02,779 --> 00:55:09,890
rounds apologies for that but imagine

00:55:06,259 --> 00:55:12,140
that I have not made that mistake so

00:55:09,890 --> 00:55:14,809
this is we've got no overload of the

00:55:12,140 --> 00:55:16,729
bitwise or operator and you can think of

00:55:14,809 --> 00:55:20,209
this sort of roughly not exactly but

00:55:16,729 --> 00:55:22,729
roughly like the pipe operator in UNIX

00:55:20,209 --> 00:55:27,289
so we're taking our vector and we are

00:55:22,729 --> 00:55:29,150
piping it through the filter adapter and

00:55:27,289 --> 00:55:32,900
then we are piping the result of that

00:55:29,150 --> 00:55:35,390
through the transform adapter and now

00:55:32,900 --> 00:55:39,969
the flow of data is clear it flows from

00:55:35,390 --> 00:55:39,969
vac through filter through transform

00:55:40,599 --> 00:55:50,930
and then we're applying this copy so I

00:55:47,539 --> 00:55:53,150
am a little bit pushed for time so I

00:55:50,930 --> 00:55:55,609
can't tell you as much of this about

00:55:53,150 --> 00:55:56,960
this next one as I wanted to but we can

00:55:55,609 --> 00:55:58,849
actually make some quite complicated

00:55:56,960 --> 00:56:00,710
pipelines so this is from a library I

00:55:58,849 --> 00:56:03,309
wrote a couple of years ago it uses

00:56:00,710 --> 00:56:08,029
range v3 to translate between different

00:56:03,309 --> 00:56:13,039
Unicode encoding so we read in a file we

00:56:08,029 --> 00:56:14,660
consume the Unicode byte order mark we

00:56:13,039 --> 00:56:18,380
convert internally to you tf-x

00:56:14,660 --> 00:56:21,799
utf-16 we add by prepend to byte order

00:56:18,380 --> 00:56:26,059
mark to the front convert it to

00:56:21,799 --> 00:56:28,549
big-endian and then view apply a view

00:56:26,059 --> 00:56:28,880
that makes it appear as as if these are

00:56:28,549 --> 00:56:31,869
bytes

00:56:28,880 --> 00:56:35,180
and then we can copy to an output file

00:56:31,869 --> 00:56:39,140
so this copies from utf-8 to big-endian

00:56:35,180 --> 00:56:41,749
utf-16 using this sequence of

00:56:39,140 --> 00:56:43,789
transformations so this does it without

00:56:41,749 --> 00:56:46,390
ever loading the entire file into memory

00:56:43,789 --> 00:56:50,329
this does it on the fly and

00:56:46,390 --> 00:56:51,739
unfortunately running short on time so I

00:56:50,329 --> 00:56:54,349
can't quite go into it as much as I'd

00:56:51,739 --> 00:56:56,029
like but if you are curious the URL is

00:56:54,349 --> 00:56:59,989
there on the screen and I'm happy to

00:56:56,029 --> 00:57:02,170
talk about it afterwards but just in the

00:56:59,989 --> 00:57:04,910
last couple of minutes that we have left

00:57:02,170 --> 00:57:05,779
let's quickly go over the third question

00:57:04,910 --> 00:57:09,999
that I asked right at the beginning

00:57:05,779 --> 00:57:09,999
which is how can I use this stuff today

00:57:10,509 --> 00:57:16,009
so there are three implementations that

00:57:13,430 --> 00:57:17,809
I know of that are available they're all

00:57:16,009 --> 00:57:21,230
you know open source the raw and github

00:57:17,809 --> 00:57:23,900
you can use them today so the first one

00:57:21,230 --> 00:57:26,150
is Rain Tree three primary author is

00:57:23,900 --> 00:57:27,950
that gentleman in the back row this is

00:57:26,150 --> 00:57:30,289
Eric nibblers original ranges

00:57:27,950 --> 00:57:34,869
implementation this is the work from

00:57:30,289 --> 00:57:37,130
which everything else sprang so it has

00:57:34,869 --> 00:57:39,619
all the everything that's going to be

00:57:37,130 --> 00:57:41,239
proposed in 20 and many many extra views

00:57:39,619 --> 00:57:44,170
and actions which we haven't talked

00:57:41,239 --> 00:57:47,059
about today extra views and actions

00:57:44,170 --> 00:57:51,049
which are not part of C++ 20 and perhaps

00:57:47,059 --> 00:57:53,790
hopefully we'll see in 20 it's extremely

00:57:51,049 --> 00:57:57,330
popular widely used and

00:57:53,790 --> 00:57:59,250
no even with my own internal bias I have

00:57:57,330 --> 00:58:00,960
to say if you are looking for a range

00:57:59,250 --> 00:58:01,590
implementation if you want to use this

00:58:00,960 --> 00:58:03,380
stuff today

00:58:01,590 --> 00:58:08,130
you can't go wrong with Raintree three

00:58:03,380 --> 00:58:11,550
so sequence plus 14 I believe works on

00:58:08,130 --> 00:58:14,040
all the major compilers and uses

00:58:11,550 --> 00:58:17,730
actually this kind of preprocessor magic

00:58:14,040 --> 00:58:19,500
to actually make use of core language

00:58:17,730 --> 00:58:21,540
concepts if they're available if you're

00:58:19,500 --> 00:58:24,410
using a compiler if using a new GCC

00:58:21,540 --> 00:58:26,970
their supports concepts then actually

00:58:24,410 --> 00:58:28,410
range v3 can make use of that otherwise

00:58:26,970 --> 00:58:30,830
it emulates concepts using all that

00:58:28,410 --> 00:58:30,830
horrible stuff

00:58:32,570 --> 00:58:38,610
the second implementation is one you

00:58:35,610 --> 00:58:43,290
perhaps haven't heard of called CMC STL

00:58:38,610 --> 00:58:45,930
two and this is the reference

00:58:43,290 --> 00:58:48,720
implementation of what was the ranges TS

00:58:45,930 --> 00:58:50,670
and is now C++ 20 ranges this is the

00:58:48,720 --> 00:58:51,930
reference implementation by dinickel

00:58:50,670 --> 00:58:53,970
Casey Carter who is the other big

00:58:51,930 --> 00:58:59,300
driving force behind ranges along with

00:58:53,970 --> 00:59:02,700
Eric so this uses language concepts

00:58:59,300 --> 00:59:07,050
exclusively this is the as I say the

00:59:02,700 --> 00:59:08,400
reference implementation so uses

00:59:07,050 --> 00:59:12,810
language concepts so it's restricted to

00:59:08,400 --> 00:59:14,250
GCC or MSV C possibly I'm not sure

00:59:12,810 --> 00:59:21,570
perhaps Chris knows the latest status

00:59:14,250 --> 00:59:25,380
but I believe it does work so CMC STL to

00:59:21,570 --> 00:59:28,020
now works with GCC and M SVC no clang

00:59:25,380 --> 00:59:31,470
yet but I'm sure it's on the horizon um

00:59:28,020 --> 00:59:33,060
CMC STL 2 has a couple of extensions

00:59:31,470 --> 00:59:35,460
they're not part of the proposals but by

00:59:33,060 --> 00:59:41,460
and large it is what you are going to

00:59:35,460 --> 00:59:43,200
get in C++ 20 and just finally very

00:59:41,460 --> 00:59:47,610
quickly because I have to do it because

00:59:43,200 --> 00:59:48,840
you know I'm standing here this is one

00:59:47,610 --> 00:59:51,600
you almost certainly haven't heard of

00:59:48,840 --> 00:59:53,280
it's called nano range and this is my

00:59:51,600 --> 00:59:56,130
implementation or the range of

00:59:53,280 --> 01:00:00,710
specifications so this is an independent

00:59:56,130 --> 01:00:05,340
reimplementation from the specs that are

01:00:00,710 --> 01:00:09,000
published online uses C++ 17 works with

01:00:05,340 --> 01:00:10,950
clang with GCC with M SVC

01:00:09,000 --> 01:00:15,270
doesn't use language concepts but he

01:00:10,950 --> 01:00:18,030
said uses lovely ever template stuff to

01:00:15,270 --> 01:00:22,080
emulate concepts just the proposed

01:00:18,030 --> 01:00:25,260
features of C++ 20 there's nothing else

01:00:22,080 --> 01:00:27,600
in there and the idea the reason I've

01:00:25,260 --> 01:00:29,940
done this is because I want to provide a

01:00:27,600 --> 01:00:31,200
smooth upgrade path to standard ranges I

01:00:29,940 --> 01:00:33,920
want you to be able to use narrator

01:00:31,200 --> 01:00:36,540
today and tomorrow to be able to upgrade

01:00:33,920 --> 01:00:38,720
to standard ranges hopefully if I've

01:00:36,540 --> 01:00:39,930
done it right just by changing the names

01:00:38,720 --> 01:00:43,200
okay

01:00:39,930 --> 01:00:45,240
I have used my allotted time in 30

01:00:43,200 --> 01:00:47,040
seconds over so if you've got questions

01:00:45,240 --> 01:00:49,170
please do come in and talk to me

01:00:47,040 --> 01:00:53,010
afterwards I'm very sorry we haven't

01:00:49,170 --> 01:00:54,750
managed quite manage to to have time for

01:00:53,010 --> 01:00:55,400
questions at the end but thank you very

01:00:54,750 --> 01:01:01,739
much

01:00:55,400 --> 01:01:01,739

YouTube URL: https://www.youtube.com/watch?v=SYLgG7Q5Zws


