Title: CppCon 2019: Ben Smith “Applied WebAssembly: Compiling and Running C++ in Your Web Browser”
Publication date: 2019-09-19
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
WebAssembly is a new technology in all modern browsers designed to let you run high-performance code. Maybe you've heard of WebAssembly before, read an article or two, or even tried to use it with your software project. Since WebAssembly is a low-level language, it's easy to get bogged down in the technical details, and leave without knowing whether WebAssembly will be useful for you. In this talk, I'll take a top-down approach, showing a real problem and how WebAssembly can help.

From August to December this year, I'll be teaching C++ to students at Morehouse College. Having a tool like Compiler Explorer is invaluable as a teaching aid, since it allows the students to immediately see C++ compilation results, on any device that has a web browser. But Compiler Explorer and tools like it require a server to do compilation, so they're hard to use offline. With WebAssembly, we can run the compiler client-side, in the browser, no server required.

First, I'll show how I ported the clang compiler and linker to WebAssembly. Since Clang 8 supports WebAssembly as a compilation target, we can even run the resulting executable sandboxed in the browser. Next, we'll dive into how Clang compiles C++ constructs into WebAssembly. Finally, we'll look at some of the new WebAssembly features in development.
— 
Ben Smith
Google
Software Engineer

Ben Smith is a Software Engineer at Google, on the WebAssembly team. His primary work involves adding new features to V8, Chrome's JavaScript and WebAssembly engine. He's also the chair of the WebAssembly Community and Working Groups, where he helps move new features forward. From August to December 2019, he will be teaching introductory C++ classes at Morehouse University, as part of the Google-in-Residence program.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:10,280 --> 00:00:17,020
who here uses a web browser sometimes

00:00:14,259 --> 00:00:18,849
yeah so our next speaker works on a web

00:00:17,020 --> 00:00:22,329
browser called chrome he works for

00:00:18,849 --> 00:00:24,250
Google and I assume most of you know of

00:00:22,329 --> 00:00:26,500
JavaScript its programming language so

00:00:24,250 --> 00:00:28,239
javascript around 2008-2009 started

00:00:26,500 --> 00:00:32,230
getting much faster through compiler

00:00:28,239 --> 00:00:35,050
technology and our next speaker works

00:00:32,230 --> 00:00:37,150
sometimes on JavaScript and sometimes on

00:00:35,050 --> 00:00:39,220
something called web assembly the point

00:00:37,150 --> 00:00:41,559
of web assembly is to allow you to run

00:00:39,220 --> 00:00:43,120
native code inside your browser and many

00:00:41,559 --> 00:00:45,820
other things as he'll tell you now he

00:00:43,120 --> 00:00:48,070
joined chrome in 2011 right so the

00:00:45,820 --> 00:00:49,719
browser's got way faster around 2009 and

00:00:48,070 --> 00:00:50,379
then they kind of hit a ceiling with

00:00:49,719 --> 00:00:52,480
JavaScript

00:00:50,379 --> 00:00:54,309
so what browser vendors started doing is

00:00:52,480 --> 00:00:56,520
looking at how we could bring more speed

00:00:54,309 --> 00:00:58,480
and more capabilities to the web through

00:00:56,520 --> 00:01:00,960
sandboxing technologies and other stuff

00:00:58,480 --> 00:01:03,820
that's what Ben has done since 2011

00:01:00,960 --> 00:01:05,350
after a few years of doing this the

00:01:03,820 --> 00:01:06,820
browser vendors got together all four of

00:01:05,350 --> 00:01:09,460
them for the stent form the Standards

00:01:06,820 --> 00:01:11,320
Committee for web assembly and Ben is

00:01:09,460 --> 00:01:13,270
the chair of that standards committee so

00:01:11,320 --> 00:01:14,770
not only is he the implementer of a

00:01:13,270 --> 00:01:16,179
large part of the tool chain you use

00:01:14,770 --> 00:01:18,130
when you target web assembly he's also

00:01:16,179 --> 00:01:20,800
the implementer of what's in your

00:01:18,130 --> 00:01:22,390
browser and helps guide the technology

00:01:20,800 --> 00:01:24,550
forward through the standards committee

00:01:22,390 --> 00:01:26,979
just like the C++ Times Committee guides

00:01:24,550 --> 00:01:28,060
the implementation of suppose bus so

00:01:26,979 --> 00:01:32,310
there's no better person to tell you

00:01:28,060 --> 00:01:32,310
about what assembly then Ben Smith Ben

00:01:39,140 --> 00:01:45,440
thanks John

00:01:41,210 --> 00:01:49,440
Wow this is amazing

00:01:45,440 --> 00:01:58,909
welcome everyone hold on let me unlock

00:01:49,440 --> 00:02:01,050
my computer yeah great okay welcome yeah

00:01:58,909 --> 00:02:03,930
well first of all I want to thank you

00:02:01,050 --> 00:02:06,300
all for coming this is such an honor to

00:02:03,930 --> 00:02:09,899
be here to be able to speak to all of

00:02:06,300 --> 00:02:11,880
you and I also want to thank jf for that

00:02:09,899 --> 00:02:15,600
great introduction jf and I worked

00:02:11,880 --> 00:02:17,760
together for a long time since 2012 we

00:02:15,600 --> 00:02:20,610
were at Google together work together

00:02:17,760 --> 00:02:23,730
for four years and jf has actually been

00:02:20,610 --> 00:02:27,600
encouraging me to do all sorts of things

00:02:23,730 --> 00:02:30,840
like this give talks but it didn't start

00:02:27,600 --> 00:02:33,420
with this talk actually happened a long

00:02:30,840 --> 00:02:37,200
time ago so back in 2016

00:02:33,420 --> 00:02:39,540
jf asked me would you like to give a

00:02:37,200 --> 00:02:41,610
presentation for the chrome all-hands

00:02:39,540 --> 00:02:45,180
that's where all of us on the chrome

00:02:41,610 --> 00:02:46,799
team get together and talk about new

00:02:45,180 --> 00:02:52,560
technologies things that were working on

00:02:46,799 --> 00:02:54,720
so I said sure why not

00:02:52,560 --> 00:02:56,820
it was a great experience it was

00:02:54,720 --> 00:03:00,380
nerve-wracking to be talking to my

00:02:56,820 --> 00:03:04,049
boss's boss's boss but I did it then

00:03:00,380 --> 00:03:06,750
later that year jf signed up for a talk

00:03:04,049 --> 00:03:08,220
full-stack fest but then decided he

00:03:06,750 --> 00:03:11,100
didn't want to do and he said no Ben do

00:03:08,220 --> 00:03:12,720
you do you want to do it instead and I

00:03:11,100 --> 00:03:15,750
said okay why not

00:03:12,720 --> 00:03:18,720
I need up giving the talk in Barcelona

00:03:15,750 --> 00:03:20,760
it was amazing it was a really great

00:03:18,720 --> 00:03:23,310
place to be and I was excellent to be

00:03:20,760 --> 00:03:24,269
able to meet so many people and tell him

00:03:23,310 --> 00:03:25,950
about webassembly

00:03:24,269 --> 00:03:29,640
so I've been talking about this for a

00:03:25,950 --> 00:03:31,340
long time as jf mentioned I'm the chair

00:03:29,640 --> 00:03:34,799
of the webassembly community group and

00:03:31,340 --> 00:03:38,310
even he was the chair before I was and

00:03:34,799 --> 00:03:39,420
so when he came to me and said actually

00:03:38,310 --> 00:03:42,510
I don't know if I want to be cheering

00:03:39,420 --> 00:03:48,569
more I want to focus on C++ do you want

00:03:42,510 --> 00:03:49,410
to be chair and I said okay sure so

00:03:48,569 --> 00:03:52,050
obviously

00:03:49,410 --> 00:03:56,450
when jf said do you want to speak Etsy

00:03:52,050 --> 00:03:58,950
if you pecan 2019 I said absolutely not

00:03:56,450 --> 00:04:02,910
okay so don't get me wrong actually

00:03:58,950 --> 00:04:04,830
this is amazing I love C++ I've been

00:04:02,910 --> 00:04:08,480
programming in it for something like 25

00:04:04,830 --> 00:04:10,410
years but I actually had previous

00:04:08,480 --> 00:04:13,650
responsibilities that I had to take care

00:04:10,410 --> 00:04:16,650
of in particular I'm currently in a

00:04:13,650 --> 00:04:18,540
program called Google and residents this

00:04:16,650 --> 00:04:20,489
is a program where we take software

00:04:18,540 --> 00:04:23,340
engineers from Google and we send them

00:04:20,489 --> 00:04:24,960
around the United States and to

00:04:23,340 --> 00:04:27,540
historically black colleges and

00:04:24,960 --> 00:04:30,120
universities or Hispanic serving

00:04:27,540 --> 00:04:35,220
institutions and the idea of the program

00:04:30,120 --> 00:04:38,750
is to try and have better connections

00:04:35,220 --> 00:04:41,940
between industry like Google and

00:04:38,750 --> 00:04:44,820
education what we found is that our

00:04:41,940 --> 00:04:47,820
diversity numbers are not great we have

00:04:44,820 --> 00:04:50,370
diversity report and what we've found

00:04:47,820 --> 00:04:52,140
from this diversity report is that we

00:04:50,370 --> 00:04:54,780
need to do a lot better and this is one

00:04:52,140 --> 00:04:56,940
way that we we are trying to do that and

00:04:54,780 --> 00:05:01,020
so what happens is software engineer is

00:04:56,940 --> 00:05:06,360
like me is embedded into this university

00:05:01,020 --> 00:05:08,910
and I teach intro to programming so this

00:05:06,360 --> 00:05:12,690
program actually works with 13 schools

00:05:08,910 --> 00:05:15,020
around the United States Cal State for

00:05:12,690 --> 00:05:19,320
Ovaltine University of Texas El Paso

00:05:15,020 --> 00:05:21,540
even in Puerto Rico and so a bunch of my

00:05:19,320 --> 00:05:27,090
colleagues are currently teaching

00:05:21,540 --> 00:05:31,880
classes in in these locations so when I

00:05:27,090 --> 00:05:34,770
applied to the program back in January I

00:05:31,880 --> 00:05:36,030
knew that I was going to be accepted I

00:05:34,770 --> 00:05:37,680
was pretty sure I was going to be

00:05:36,030 --> 00:05:41,130
accepted and so when J have contacted me

00:05:37,680 --> 00:05:44,550
I naturally told him I can't do it I'm

00:05:41,130 --> 00:05:48,330
gonna be too focused on on this this

00:05:44,550 --> 00:05:54,180
work and so when I was accepted I ended

00:05:48,330 --> 00:05:57,510
up at Morehouse College which is this

00:05:54,180 --> 00:05:59,340
school here so Morehouse is a school

00:05:57,510 --> 00:06:00,979
that probably is most famous for being

00:05:59,340 --> 00:06:02,789
this school that Martin Luther King jr.

00:06:00,979 --> 00:06:05,220
attended

00:06:02,789 --> 00:06:08,550
he entered at the age of 15 actually and

00:06:05,220 --> 00:06:11,699
in 1944 and he graduated the bachelors

00:06:08,550 --> 00:06:14,129
of Art in sociology school was founded

00:06:11,699 --> 00:06:16,199
in 1867 and it's actually one of the

00:06:14,129 --> 00:06:19,139
only remaining men's colleges in the

00:06:16,199 --> 00:06:21,020
United States it's located an area

00:06:19,139 --> 00:06:24,919
called the Atlanta University Center

00:06:21,020 --> 00:06:28,139
where there's a couple of other HBCUs

00:06:24,919 --> 00:06:29,849
nearby Spelman which is a women's

00:06:28,139 --> 00:06:35,430
college and then Clark Atlanta

00:06:29,849 --> 00:06:36,930
University as well so as I said I knew

00:06:35,430 --> 00:06:39,379
that I was going to be incredibly busy

00:06:36,930 --> 00:06:41,520
I'm sure some of you are teachers

00:06:39,379 --> 00:06:43,110
there's a lot of work that goes into

00:06:41,520 --> 00:06:45,539
teaching I've only been teaching for

00:06:43,110 --> 00:06:47,490
four weeks now and I am already

00:06:45,539 --> 00:06:49,190
incredibly overloaded with things like

00:06:47,490 --> 00:06:51,930
preparing lectures grading homework

00:06:49,190 --> 00:06:55,259
teaching labs mock interviews because a

00:06:51,930 --> 00:06:58,080
lot of these students want to be able to

00:06:55,259 --> 00:07:02,219
be prepared for coming in and doing

00:06:58,080 --> 00:07:03,860
interview at Google so naturally I told

00:07:02,219 --> 00:07:07,650
GFI I just can't do it

00:07:03,860 --> 00:07:10,319
but if you know j.f you know that he's a

00:07:07,650 --> 00:07:13,319
very persistent person and so when he

00:07:10,319 --> 00:07:16,490
said he asked me again I actually

00:07:13,319 --> 00:07:20,360
thought oops

00:07:16,490 --> 00:07:24,620
hmm let's see maybe I should try this

00:07:20,360 --> 00:07:24,620
running me while I take a sip of water

00:07:28,879 --> 00:07:34,169
so it turns out that the languages that

00:07:31,259 --> 00:07:36,979
are taught by the Gir instructors the my

00:07:34,169 --> 00:07:40,879
fellow colleagues is primarily Python

00:07:36,979 --> 00:07:42,629
maybe not super surprising Morehouse

00:07:40,879 --> 00:07:45,839
actually is one of the schools that

00:07:42,629 --> 00:07:47,719
teaches C++ I know it's hard to imagine

00:07:45,839 --> 00:07:51,900
but yeah just one of the two schools

00:07:47,719 --> 00:07:53,849
uses soup O's Plus and so when I told my

00:07:51,900 --> 00:07:58,589
colleagues about this they kind of said

00:07:53,849 --> 00:08:00,479
this to me really C++ are you gonna

00:07:58,589 --> 00:08:02,789
teach under behind undefined behavior

00:08:00,479 --> 00:08:03,960
are you gonna are you gonna teach some

00:08:02,789 --> 00:08:05,279
pointers are you gonna teach them

00:08:03,960 --> 00:08:07,589
lambdas are you gonna teach them all

00:08:05,279 --> 00:08:08,580
this stuff and I said no no I'm not

00:08:07,589 --> 00:08:14,580
gonna teach them all that stuff we're

00:08:08,580 --> 00:08:15,899
gonna teach intro intro and so this is

00:08:14,580 --> 00:08:16,500
one reason why I was a little bit

00:08:15,899 --> 00:08:21,420
concerned

00:08:16,500 --> 00:08:23,700
about teaching C++ if y'all have ever

00:08:21,420 --> 00:08:25,260
tried to use C++ there's a lot of stuff

00:08:23,700 --> 00:08:26,550
that you need to learn you have to maybe

00:08:25,260 --> 00:08:29,400
you learn the command line you maybe

00:08:26,550 --> 00:08:33,000
have to learn tools like vim you might

00:08:29,400 --> 00:08:34,860
have to learn tools like git you might

00:08:33,000 --> 00:08:47,430
have to try and remember how to quit out

00:08:34,860 --> 00:08:49,860
of them right so then you have to

00:08:47,430 --> 00:08:53,790
remember how to compile your code

00:08:49,860 --> 00:08:57,420
oh wait note you have to remember to run

00:08:53,790 --> 00:08:58,830
clang plus plus of course sure then of

00:08:57,420 --> 00:09:00,210
course you want to commit your code oh

00:08:58,830 --> 00:09:01,770
no you can't just run commit that

00:09:00,210 --> 00:09:05,430
doesn't work you have to add no you

00:09:01,770 --> 00:09:09,260
can't do add right Oh get add okay nope

00:09:05,430 --> 00:09:09,260
well I added the executable that's wrong

00:09:09,620 --> 00:09:19,890
okay so you have to remove that right so

00:09:16,770 --> 00:09:21,960
I didn't want it I didn't want to have

00:09:19,890 --> 00:09:24,780
to teach the students this so it turns

00:09:21,960 --> 00:09:28,740
out that there's actually a really great

00:09:24,780 --> 00:09:30,960
tool that a lot of schools are using and

00:09:28,740 --> 00:09:34,670
it's called repple it and so this is an

00:09:30,960 --> 00:09:37,200
example of what it kind of looks like

00:09:34,670 --> 00:09:39,270
essentially on the left-hand side of the

00:09:37,200 --> 00:09:41,010
screen you have the code that you can

00:09:39,270 --> 00:09:42,660
type in on the right hand side of the

00:09:41,010 --> 00:09:45,780
screen it has a sort of a terminal view

00:09:42,660 --> 00:09:47,520
and you can hit the big green button at

00:09:45,780 --> 00:09:49,740
the top play and it'll compile your code

00:09:47,520 --> 00:09:51,540
and it'll run it and then it'll print

00:09:49,740 --> 00:09:53,070
your output so you can see here I have a

00:09:51,540 --> 00:09:54,480
very very simple program this is

00:09:53,070 --> 00:09:58,470
something that my students could write

00:09:54,480 --> 00:10:03,180
and and then you can run it and you can

00:09:58,470 --> 00:10:05,640
see the the output on on the right so I

00:10:03,180 --> 00:10:06,960
imagine I don't know exactly how repli'd

00:10:05,640 --> 00:10:10,200
works but I imagine it works something

00:10:06,960 --> 00:10:12,330
like this you say something like compile

00:10:10,200 --> 00:10:13,800
and run my code and it sends from the

00:10:12,330 --> 00:10:16,920
client to the server and then the server

00:10:13,800 --> 00:10:19,440
says okay I compiled it and I linked it

00:10:16,920 --> 00:10:22,290
and now it's running and then it comes

00:10:19,440 --> 00:10:23,970
back to the client and and meanwhile it

00:10:22,290 --> 00:10:25,709
also says something like oh by the way

00:10:23,970 --> 00:10:27,240
what's your name because the program is

00:10:25,709 --> 00:10:29,580
now running and then you send your

00:10:27,240 --> 00:10:30,329
output across and then the sir meanwhile

00:10:29,580 --> 00:10:31,529
the server's wait

00:10:30,329 --> 00:10:32,910
for your response right it's just

00:10:31,529 --> 00:10:37,279
sitting there running your program and

00:10:32,910 --> 00:10:40,980
then it returns with the actual result

00:10:37,279 --> 00:10:42,689
so this is something like I mean if

00:10:40,980 --> 00:10:44,519
y'all have used compiler Explorer this

00:10:42,689 --> 00:10:47,160
is very very similar sort of behavior

00:10:44,519 --> 00:10:49,220
right client-server architecture but one

00:10:47,160 --> 00:10:51,749
of the problems is of course with

00:10:49,220 --> 00:10:53,579
client-server programs is like you know

00:10:51,749 --> 00:10:55,739
sometimes the internet doesn't work very

00:10:53,579 --> 00:10:59,069
well and it actually turns out that at

00:10:55,739 --> 00:11:01,290
the University this is a real problem

00:10:59,069 --> 00:11:03,239
like we've been sitting in labs before

00:11:01,290 --> 00:11:05,639
where you know the students will raise

00:11:03,239 --> 00:11:07,350
their hand and say I don't come over OQ

00:11:05,639 --> 00:11:09,720
having problems a program and they're

00:11:07,350 --> 00:11:13,350
like no I don't I can't run the code

00:11:09,720 --> 00:11:15,239
it's just sitting there loading and so a

00:11:13,350 --> 00:11:16,860
lot of the students actually have their

00:11:15,239 --> 00:11:18,480
own personal hot spots on their phone

00:11:16,860 --> 00:11:19,889
and so whenever it goes down they just

00:11:18,480 --> 00:11:20,970
sort of pull up their hotspot and they

00:11:19,889 --> 00:11:25,439
start working but if they don't have

00:11:20,970 --> 00:11:27,749
their hotspot they can't do it at all so

00:11:25,439 --> 00:11:29,759
the reason we use repple it I mean part

00:11:27,749 --> 00:11:30,929
of the reason was because of you know

00:11:29,759 --> 00:11:32,249
not having to learn the terminal and

00:11:30,929 --> 00:11:35,100
stuff but part of it is also because

00:11:32,249 --> 00:11:36,600
these students you know they have a wide

00:11:35,100 --> 00:11:37,889
variety of computers some of them work

00:11:36,600 --> 00:11:41,069
on iPads some of them work on

00:11:37,889 --> 00:11:44,959
Chromebooks some of them work on Macs

00:11:41,069 --> 00:11:47,249
and all sorts of different computers so

00:11:44,959 --> 00:11:52,379
we need to do something better I think

00:11:47,249 --> 00:11:55,679
maybe and so I had this thought what if

00:11:52,379 --> 00:11:58,439
we take our client code and we say okay

00:11:55,679 --> 00:11:59,610
give me the full tool chain and then the

00:11:58,439 --> 00:12:03,839
server says okay here you go

00:11:59,610 --> 00:12:05,279
and it says all right here's all your

00:12:03,839 --> 00:12:08,129
data and then you can just do everything

00:12:05,279 --> 00:12:09,419
client-side yeah why not and then the

00:12:08,129 --> 00:12:11,040
server can just sit there in I don't

00:12:09,419 --> 00:12:13,319
know calculate digits of pi or whatever

00:12:11,040 --> 00:12:17,279
servers do when they have nothing better

00:12:13,319 --> 00:12:18,569
to do right so I wasn't the first person

00:12:17,279 --> 00:12:22,069
to think of this idea there's actually a

00:12:18,569 --> 00:12:24,299
really great project that top plumbing

00:12:22,069 --> 00:12:25,860
worked on before it called clang and

00:12:24,299 --> 00:12:28,679
browser and does something very similar

00:12:25,860 --> 00:12:31,470
to this I have a little bit of a

00:12:28,679 --> 00:12:33,410
different implementation but I wanted to

00:12:31,470 --> 00:12:37,410
talk about some some prior work here

00:12:33,410 --> 00:12:41,850
there's also I can't pronounce his name

00:12:37,410 --> 00:12:43,830
focus Bernard J s Linux which actually

00:12:41,850 --> 00:12:47,010
solves this problem by

00:12:43,830 --> 00:12:48,930
filing an entire x86 machine inside of

00:12:47,010 --> 00:12:52,290
the browser and of course you can do

00:12:48,930 --> 00:12:55,680
this you can run GCC here I think it

00:12:52,290 --> 00:12:57,480
takes 15 seconds to compile this

00:12:55,680 --> 00:12:59,370
something like that because you know of

00:12:57,480 --> 00:13:01,680
course it's emulating the entire x86

00:12:59,370 --> 00:13:05,220
machine to do it but it does work so

00:13:01,680 --> 00:13:06,690
this is a possibility as well very very

00:13:05,220 --> 00:13:08,460
cool demo by the way if you want to

00:13:06,690 --> 00:13:12,060
check out some stuff you can do in the

00:13:08,460 --> 00:13:13,380
browser so the thing that's the common

00:13:12,060 --> 00:13:17,520
thread about both of these is that they

00:13:13,380 --> 00:13:18,960
use web assembly as Jeff said whoever

00:13:17,520 --> 00:13:21,840
sembly was designed to do this it was

00:13:18,960 --> 00:13:25,020
designed to run this type of code in the

00:13:21,840 --> 00:13:31,530
browser things that JavaScript could do

00:13:25,020 --> 00:13:34,650
but maybe wasn't well suited to do right

00:13:31,530 --> 00:13:37,890
so when Jeff asked me he said yes please

00:13:34,650 --> 00:13:41,010
please come to CPP con I finally said

00:13:37,890 --> 00:13:42,180
all right let's do it honestly how hard

00:13:41,010 --> 00:13:44,760
could it be right you know I'm just

00:13:42,180 --> 00:13:46,170
teaching classes and then also coming up

00:13:44,760 --> 00:13:49,260
with an awesome demo of a thing that I

00:13:46,170 --> 00:13:54,710
haven't written yet and producing a 90

00:13:49,260 --> 00:13:58,410
minute keynote so you know not so hard

00:13:54,710 --> 00:14:00,240
so here's the plan for the talk first

00:13:58,410 --> 00:14:02,700
I'm going to talk about web assembly and

00:14:00,240 --> 00:14:04,080
Razzie I'll tell you what Ghazi is then

00:14:02,700 --> 00:14:07,290
I'm gonna show you how I made the demo

00:14:04,080 --> 00:14:09,150
and then finally I'm gonna have a demo

00:14:07,290 --> 00:14:14,820
time with some live coding and we'll see

00:14:09,150 --> 00:14:18,300
how that works out in the end all right

00:14:14,820 --> 00:14:20,760
so first what is web assembly you

00:14:18,300 --> 00:14:22,380
probably have seen if you've heard

00:14:20,760 --> 00:14:25,460
anything about webOS only many many

00:14:22,380 --> 00:14:27,870
articles and talks and podcasts about

00:14:25,460 --> 00:14:30,990
that actually asked this exact question

00:14:27,870 --> 00:14:33,870
so rather than reiterate I actually took

00:14:30,990 --> 00:14:36,930
a quick search of the top hits for what

00:14:33,870 --> 00:14:39,720
is web assembly and made a little nice

00:14:36,930 --> 00:14:42,270
dot graph of all the different words

00:14:39,720 --> 00:14:43,320
here so you could probably I don't know

00:14:42,270 --> 00:14:44,820
it's a little bit hard to read but if

00:14:43,320 --> 00:14:46,410
you follow through you can probably find

00:14:44,820 --> 00:14:48,690
what I think is probably the best

00:14:46,410 --> 00:14:50,310
definition which is web assembly is an

00:14:48,690 --> 00:14:51,930
efficient safe low-level bytecode for

00:14:50,310 --> 00:14:54,870
the web standard binary instruction

00:14:51,930 --> 00:14:58,199
format for the web so clearly that is

00:14:54,870 --> 00:15:00,660
what web assembly is okay not really

00:14:58,199 --> 00:15:02,790
whoever simply is really kind of all of

00:15:00,660 --> 00:15:06,350
these things it's about being low level

00:15:02,790 --> 00:15:09,000
it's about being a VM it's about being

00:15:06,350 --> 00:15:10,939
binary format but it's a lot more than

00:15:09,000 --> 00:15:13,949
that

00:15:10,939 --> 00:15:18,569
previously webassembly was actually at

00:15:13,949 --> 00:15:21,180
CPP con so Dan Goleman who works still

00:15:18,569 --> 00:15:24,209
works on web assembly at Mozilla gave a

00:15:21,180 --> 00:15:28,430
talk at 2016 web assembly was still

00:15:24,209 --> 00:15:30,540
pretty new then it wasn't wasn't yet

00:15:28,430 --> 00:15:32,550
officially released I think you could

00:15:30,540 --> 00:15:34,139
you could play around with it and

00:15:32,550 --> 00:15:35,910
actually even just last year damien

00:15:34,139 --> 00:15:37,019
boule gave a talk about web assembly and

00:15:35,910 --> 00:15:39,389
some of the cool things you can do there

00:15:37,019 --> 00:15:40,680
so it's this isn't the the first time

00:15:39,389 --> 00:15:43,500
we've heard about web somebody and

00:15:40,680 --> 00:15:46,230
probably not the last I like to I'd like

00:15:43,500 --> 00:15:47,790
to think anyway both of those talks do a

00:15:46,230 --> 00:15:50,730
lot of talking about what web assembly

00:15:47,790 --> 00:15:52,139
is and so you know rather than repeat

00:15:50,730 --> 00:15:54,120
what they've said I'm actually going to

00:15:52,139 --> 00:15:56,250
try and take a little bit of a different

00:15:54,120 --> 00:15:58,379
tack so what I want to do is talk about

00:15:56,250 --> 00:16:00,569
how web assembly is different than the

00:15:58,379 --> 00:16:02,309
things that you know right since

00:16:00,569 --> 00:16:04,230
everybody here uses compiler Explorer

00:16:02,309 --> 00:16:06,839
now you're all experts at assembly

00:16:04,230 --> 00:16:09,120
language I'm sure and so let's talk

00:16:06,839 --> 00:16:12,110
about how web assembly which we like to

00:16:09,120 --> 00:16:14,490
think of it as being an ice ax is is

00:16:12,110 --> 00:16:19,829
similar and yet different for some of

00:16:14,490 --> 00:16:22,170
the examples that you can see here okay

00:16:19,829 --> 00:16:28,050
so the first thing is that web assembly

00:16:22,170 --> 00:16:31,079
is a typed stack machine so that means

00:16:28,050 --> 00:16:34,379
that at every point in time in the

00:16:31,079 --> 00:16:37,439
program the type of a stack slot is

00:16:34,379 --> 00:16:39,329
known but it's not a pure stack machine

00:16:37,439 --> 00:16:41,370
we actually have unlimited virtual

00:16:39,329 --> 00:16:45,360
registers so what that means is that you

00:16:41,370 --> 00:16:46,800
can use locals to access values that you

00:16:45,360 --> 00:16:48,779
don't want to necessarily store on the

00:16:46,800 --> 00:16:50,220
stack so sometimes people say web

00:16:48,779 --> 00:16:51,990
assembly is not a stack machine but it

00:16:50,220 --> 00:16:54,540
is it's just we've got sort of an escape

00:16:51,990 --> 00:16:56,129
hatch as well so this just gives you a

00:16:54,540 --> 00:16:57,360
little bit of an example of the stack

00:16:56,129 --> 00:16:59,699
machine if you did something like one

00:16:57,360 --> 00:17:03,990
plus two you would say a 32 Const

00:16:59,699 --> 00:17:05,400
one-eye 32 constitu and then I 32 add so

00:17:03,990 --> 00:17:07,230
the first instruction pushes the one

00:17:05,400 --> 00:17:09,780
second in structured pushes the two and

00:17:07,230 --> 00:17:11,199
then the third instruction pops those

00:17:09,780 --> 00:17:14,850
two values and then adds

00:17:11,199 --> 00:17:18,250
and pushes that result onto the stack so

00:17:14,850 --> 00:17:20,049
we could take a C++ program like this

00:17:18,250 --> 00:17:23,439
and we could translate it into web

00:17:20,049 --> 00:17:25,380
assembly something like this perhaps so

00:17:23,439 --> 00:17:29,070
you can see the bottom it looks kind of

00:17:25,380 --> 00:17:31,750
wispy that's just sort of a syntax thing

00:17:29,070 --> 00:17:35,049
internally it's it's really just storing

00:17:31,750 --> 00:17:36,789
numbers values here so you can see the

00:17:35,049 --> 00:17:37,929
basic behavior here one thing to point

00:17:36,789 --> 00:17:41,350
out is that you don't actually need to

00:17:37,929 --> 00:17:42,940
return values and webassembly the last

00:17:41,350 --> 00:17:47,710
value on the stack is the implicit

00:17:42,940 --> 00:17:50,049
return value and you can also see an

00:17:47,710 --> 00:17:52,330
example here of using locals so local

00:17:50,049 --> 00:17:54,309
dot get is an example of being able to

00:17:52,330 --> 00:17:59,500
pull that parameter in from the function

00:17:54,309 --> 00:18:01,870
and then return it rustling alright so

00:17:59,500 --> 00:18:04,149
another thing about web assembly is that

00:18:01,870 --> 00:18:08,649
web assembly is validated before

00:18:04,149 --> 00:18:11,049
execution a lot of CPUs maybe don't do

00:18:08,649 --> 00:18:13,360
this right but because it's statically

00:18:11,049 --> 00:18:16,240
typed we can actually validate the

00:18:13,360 --> 00:18:18,580
entire binary and this is necessary

00:18:16,240 --> 00:18:20,139
right one of the things that we reasons

00:18:18,580 --> 00:18:21,820
that we created web assembly is because

00:18:20,139 --> 00:18:24,250
we need to be able to take code

00:18:21,820 --> 00:18:27,580
untrusted code from the web and then run

00:18:24,250 --> 00:18:29,679
it in the browser right so we need to be

00:18:27,580 --> 00:18:30,850
able to rely on the fact that that code

00:18:29,679 --> 00:18:35,350
isn't going to be able to do anything

00:18:30,850 --> 00:18:37,059
nasty so obviously we can take that code

00:18:35,350 --> 00:18:38,250
and we can validate it some of the other

00:18:37,059 --> 00:18:42,909
things we do is that we bounce checks

00:18:38,250 --> 00:18:44,799
all memory accesses so just to make sure

00:18:42,909 --> 00:18:48,190
that we we don't allow you to read

00:18:44,799 --> 00:18:51,220
outside of the bounds so just an example

00:18:48,190 --> 00:18:54,880
of that if we have our function like

00:18:51,220 --> 00:18:57,519
this and then we try and call it with a

00:18:54,880 --> 00:18:58,840
float value that's what that F 32 Const

00:18:57,519 --> 00:19:01,029
is there then we actually get a

00:18:58,840 --> 00:19:02,740
validation error and what that means is

00:19:01,029 --> 00:19:04,419
that when you actually try and run the

00:19:02,740 --> 00:19:06,580
code it won't it won't actually even run

00:19:04,419 --> 00:19:08,559
you won't get to that point it's

00:19:06,580 --> 00:19:10,870
basically like you you had a compile

00:19:08,559 --> 00:19:14,669
failure but it's actually running on the

00:19:10,870 --> 00:19:14,669
clients side when that happens

00:19:16,950 --> 00:19:22,770
another thing about webassembly is that

00:19:18,900 --> 00:19:24,900
it has a machine verified formal

00:19:22,770 --> 00:19:27,720
specification and this is very important

00:19:24,900 --> 00:19:30,090
actually because like c++ we need to

00:19:27,720 --> 00:19:32,160
make sure that a lot of different people

00:19:30,090 --> 00:19:37,290
can use web assembly and can implement

00:19:32,160 --> 00:19:38,700
it right so for example chrome has an

00:19:37,290 --> 00:19:42,360
implementation of web assembly and so

00:19:38,700 --> 00:19:47,220
does Firefox and so does Safari WebKit

00:19:42,360 --> 00:19:48,630
and so does edge and so does a lot of

00:19:47,220 --> 00:19:50,850
other implementations that are not even

00:19:48,630 --> 00:19:52,290
browser-based so having a formal

00:19:50,850 --> 00:19:55,170
specification actually means that

00:19:52,290 --> 00:19:57,690
everybody can be fairly certain that

00:19:55,170 --> 00:20:00,270
their code will run the same in all

00:19:57,690 --> 00:20:02,520
those different environments so here's

00:20:00,270 --> 00:20:05,010
some papers there are actually some

00:20:02,520 --> 00:20:06,840
really great stuff in here the first one

00:20:05,010 --> 00:20:08,760
is the sort of original web assembly

00:20:06,840 --> 00:20:09,990
paper bringing the web up to speed with

00:20:08,760 --> 00:20:12,660
web assembly there are a number of

00:20:09,990 --> 00:20:14,580
authors here and it's a actually a

00:20:12,660 --> 00:20:17,280
really great read it's like 15 pages and

00:20:14,580 --> 00:20:19,350
you can I think it's 15 pages something

00:20:17,280 --> 00:20:21,900
like that and it and it goes through a

00:20:19,350 --> 00:20:23,070
lot of the important details of web

00:20:21,900 --> 00:20:25,050
assembly

00:20:23,070 --> 00:20:27,270
the second paper here is mechanizing

00:20:25,050 --> 00:20:29,970
verifying the web assembly specification

00:20:27,270 --> 00:20:36,360
so this is where researcher conrad watt

00:20:29,970 --> 00:20:39,360
actually did a machine verified verified

00:20:36,360 --> 00:20:40,920
the implementation using isabel and then

00:20:39,360 --> 00:20:45,270
the last one here is actually the core

00:20:40,920 --> 00:20:46,980
specification we're a w3 standard and so

00:20:45,270 --> 00:20:48,120
it's currently a candidate

00:20:46,980 --> 00:20:49,980
recommendation actually I think it's

00:20:48,120 --> 00:20:52,800
currently a proposed recommendation I

00:20:49,980 --> 00:20:54,770
think it just happened a week ago and

00:20:52,800 --> 00:20:57,060
you can read through the spec here it's

00:20:54,770 --> 00:20:58,530
I've heard people say that it's

00:20:57,060 --> 00:20:59,940
difficult to read but if you can read

00:20:58,530 --> 00:21:01,740
the C++ spec I think you can probably

00:20:59,940 --> 00:21:04,110
read this and it goes into actually a

00:21:01,740 --> 00:21:06,390
lot of really great detail about how

00:21:04,110 --> 00:21:08,820
everything works even a floating-point

00:21:06,390 --> 00:21:12,510
so like if you've tried to read the I

00:21:08,820 --> 00:21:14,190
Triple E 754 spec you might find that it

00:21:12,510 --> 00:21:16,350
doesn't go into a lot of mathematical

00:21:14,190 --> 00:21:18,510
detail but this spec actually does about

00:21:16,350 --> 00:21:21,120
all the operations that we do so it's

00:21:18,510 --> 00:21:23,730
pretty cool another very very cool thing

00:21:21,120 --> 00:21:30,050
about that first paper at least I think

00:21:23,730 --> 00:21:33,200
it's cool is that these two I guess

00:21:30,050 --> 00:21:34,820
ages here have the entire typing

00:21:33,200 --> 00:21:38,120
semantics and the entire execution

00:21:34,820 --> 00:21:39,380
semantics on one page so you can just

00:21:38,120 --> 00:21:40,610
sort of look through and I mean it's

00:21:39,380 --> 00:21:43,880
hard to see here I guess I should have

00:21:40,610 --> 00:21:45,170
had a higher resolution but very cool to

00:21:43,880 --> 00:21:46,880
be able to just sort of like scan

00:21:45,170 --> 00:21:53,080
through and see the entire behavior of

00:21:46,880 --> 00:21:55,370
webassembly on on two pages okay so

00:21:53,080 --> 00:21:58,040
another thing about webassembly is that

00:21:55,370 --> 00:22:03,860
it's a Harvard architecture so this

00:21:58,040 --> 00:22:07,430
means that the program State is actually

00:22:03,860 --> 00:22:11,300
separate from its code right so it's not

00:22:07,430 --> 00:22:14,360
very common in most systems but it

00:22:11,300 --> 00:22:16,010
actually does provide some benefits it

00:22:14,360 --> 00:22:19,070
actually means that it's impossible for

00:22:16,010 --> 00:22:22,700
a program to read or write it's anything

00:22:19,070 --> 00:22:28,250
in its instructions it's not possible to

00:22:22,700 --> 00:22:31,640
modify the call stack and so that might

00:22:28,250 --> 00:22:34,250
look something like this so the top part

00:22:31,640 --> 00:22:36,800
would be say your trusted code you might

00:22:34,250 --> 00:22:39,230
have things like your the binary format

00:22:36,800 --> 00:22:40,780
of your wasn't webassembly blob you

00:22:39,230 --> 00:22:43,280
might have some internal data structures

00:22:40,780 --> 00:22:46,700
you'll probably have your compiled x86

00:22:43,280 --> 00:22:48,050
code and then the actual call stack and

00:22:46,700 --> 00:22:52,910
then at the bottom you'll see something

00:22:48,050 --> 00:22:54,950
which is our untrusted memory and that's

00:22:52,910 --> 00:22:56,720
the only memory that webassembly can

00:22:54,950 --> 00:22:59,570
actually access it can't access any of

00:22:56,720 --> 00:23:01,640
this stuff on the top and this does

00:22:59,570 --> 00:23:04,280
prevent a certain class of exploits so

00:23:01,640 --> 00:23:07,070
for example like return oriented

00:23:04,280 --> 00:23:08,480
programming isn't possible with code

00:23:07,070 --> 00:23:15,860
like this because you can't modify the

00:23:08,480 --> 00:23:17,480
stack so another example and this is

00:23:15,860 --> 00:23:19,580
probably the most controversial thing is

00:23:17,480 --> 00:23:21,650
that webassembly has structured control

00:23:19,580 --> 00:23:24,230
flow what that means is that we don't

00:23:21,650 --> 00:23:27,890
have a go-to statement we don't have a

00:23:24,230 --> 00:23:31,580
go-to instruction in webassembly instead

00:23:27,890 --> 00:23:33,770
what we have is very much like you might

00:23:31,580 --> 00:23:35,870
expect in a very low-level programming

00:23:33,770 --> 00:23:38,770
language so we have a thing like a block

00:23:35,870 --> 00:23:41,720
and when a block means is that when you

00:23:38,770 --> 00:23:43,850
branch to a block it branches out to the

00:23:41,720 --> 00:23:45,440
bottom of it we have a loop which

00:23:43,850 --> 00:23:48,140
means when you branch to it it branches

00:23:45,440 --> 00:23:50,570
to the top of it and you can also have

00:23:48,140 --> 00:23:53,510
structures like if which allow you to

00:23:50,570 --> 00:23:55,929
branch outside of it so if it's sort of

00:23:53,510 --> 00:23:58,280
a syntactic sugar you don't need it but

00:23:55,929 --> 00:23:59,510
but it does make the code a little bit

00:23:58,280 --> 00:24:04,610
smaller which is important when you want

00:23:59,510 --> 00:24:06,860
to send it over the web so here's an

00:24:04,610 --> 00:24:09,980
example the obligatory compiler Explorer

00:24:06,860 --> 00:24:13,280
example one cool thing about this is

00:24:09,980 --> 00:24:15,799
that you can actually produce web

00:24:13,280 --> 00:24:18,380
assembly code in compiler Explorer by

00:24:15,799 --> 00:24:20,120
passing - - target Eagles wasm 32 I

00:24:18,380 --> 00:24:23,179
think there was actually a drop down for

00:24:20,120 --> 00:24:24,740
it for Reb assembly that my colleague at

00:24:23,179 --> 00:24:27,679
it and then maybe it was removed I don't

00:24:24,740 --> 00:24:29,900
know yeah not on purpose not on purpose

00:24:27,679 --> 00:24:31,549
okay yeah so it was there before and

00:24:29,900 --> 00:24:34,370
maybe it is there now again I'm not

00:24:31,549 --> 00:24:37,570
certain but so this is an example of

00:24:34,370 --> 00:24:40,429
some code here and so I'm gonna try and

00:24:37,570 --> 00:24:42,020
recreate it here so we can look at

00:24:40,429 --> 00:24:44,720
something a little bit more interesting

00:24:42,020 --> 00:24:47,390
so this is what clang did with an

00:24:44,720 --> 00:24:50,480
example where we're basically just doing

00:24:47,390 --> 00:24:52,909
a search through a linked list so you

00:24:50,480 --> 00:24:57,220
can first see that clang already did a

00:24:52,909 --> 00:25:01,460
nice unrolling of our recursive function

00:24:57,220 --> 00:25:03,200
and I'm gonna try and get into some of

00:25:01,460 --> 00:25:06,679
the detail here so the first thing you

00:25:03,200 --> 00:25:08,720
can see is we actually turn that

00:25:06,679 --> 00:25:10,700
recursive call into a loop back to the

00:25:08,720 --> 00:25:13,010
top so you can see that BRF at the

00:25:10,700 --> 00:25:16,490
bottom there BRF is a conditional branch

00:25:13,010 --> 00:25:18,080
instruction and allows you to decide

00:25:16,490 --> 00:25:20,059
whether or not it takes the value on the

00:25:18,080 --> 00:25:23,330
top of the stack compares that to zero

00:25:20,059 --> 00:25:29,390
if it's nonzero then it branches to the

00:25:23,330 --> 00:25:32,600
top then you can see this BRF at the top

00:25:29,390 --> 00:25:34,880
that BRF is essentially doing the

00:25:32,600 --> 00:25:36,890
equivalent of this if not root then

00:25:34,880 --> 00:25:40,340
return root and you can see actually

00:25:36,890 --> 00:25:42,140
something cool here we branch to the

00:25:40,340 --> 00:25:44,390
bottom and we just return zero and we

00:25:42,140 --> 00:25:46,760
know of course that root must be null in

00:25:44,390 --> 00:25:48,500
this case if and so we don't actually

00:25:46,760 --> 00:25:50,600
have to read it again we can just return

00:25:48,500 --> 00:25:53,020
I thirty-two concierge is our null

00:25:50,600 --> 00:25:53,020
pointer

00:25:56,680 --> 00:26:02,470
yeah okay so here's the next section

00:25:59,960 --> 00:26:05,900
here where we actually do a comparison

00:26:02,470 --> 00:26:07,640
let's let's drill into that a little bit

00:26:05,900 --> 00:26:12,050
so the first part here is where we

00:26:07,640 --> 00:26:14,720
actually say take the roots ex-member

00:26:12,050 --> 00:26:17,630
and then compare it to X so you can see

00:26:14,720 --> 00:26:20,120
here we do local get zero and then we do

00:26:17,630 --> 00:26:24,080
an i-32 load that actually reads from

00:26:20,120 --> 00:26:26,330
that value then we do local get 1 again

00:26:24,080 --> 00:26:29,690
that's the value we're looking for and

00:26:26,330 --> 00:26:32,260
then we do I 32 + e that means compare

00:26:29,690 --> 00:26:35,300
the two values are not equal and then we

00:26:32,260 --> 00:26:37,250
follow that up with a PRF that allows us

00:26:35,300 --> 00:26:41,420
to check whether or not those are true

00:26:37,250 --> 00:26:43,670
if so and actually yes so it actually

00:26:41,420 --> 00:26:45,500
flipped the check right it was an

00:26:43,670 --> 00:26:47,600
equality check but the compiler decided

00:26:45,500 --> 00:26:49,850
it was better to do it as a not equal

00:26:47,600 --> 00:26:55,400
check and then it can branch out from

00:26:49,850 --> 00:26:57,520
there and then finally like I said yeah

00:26:55,400 --> 00:27:00,800
we we have this recursive call here

00:26:57,520 --> 00:27:02,420
local dot get and then I 32 load 4 is

00:27:00,800 --> 00:27:06,140
actually reading the next pointer you

00:27:02,420 --> 00:27:08,570
can see because in soar or 4 bytes

00:27:06,140 --> 00:27:10,880
that's because webassembly is a 32-bit

00:27:08,570 --> 00:27:12,890
machine and then we have something a

00:27:10,880 --> 00:27:15,500
little bit weird here that's the local

00:27:12,890 --> 00:27:18,260
dot e local that T is an instruction

00:27:15,500 --> 00:27:20,420
that allows you to set a value in a

00:27:18,260 --> 00:27:22,190
local and then also leave it on the

00:27:20,420 --> 00:27:24,260
stack so it's just a nice way to be able

00:27:22,190 --> 00:27:32,000
to use the stack more efficiently but

00:27:24,260 --> 00:27:34,070
also set a local value okay so this is a

00:27:32,000 --> 00:27:36,550
question that I often hear from people

00:27:34,070 --> 00:27:38,930
when they first hear about web assembly

00:27:36,550 --> 00:27:40,730
people say stuff like kimbab assembly

00:27:38,930 --> 00:27:42,890
render graphics can well assembly access

00:27:40,730 --> 00:27:45,500
the Dom things like that can have

00:27:42,890 --> 00:27:48,160
assembly tuck me in at night and these

00:27:45,500 --> 00:27:50,900
are understandable questions because for

00:27:48,160 --> 00:27:52,760
JavaScript the answer to a lot of these

00:27:50,900 --> 00:27:55,580
things is true maybe not tucking you in

00:27:52,760 --> 00:27:57,590
but a lot of the other things right and

00:27:55,580 --> 00:28:00,200
so the way that I have actually started

00:27:57,590 --> 00:28:02,810
to answer this question is this

00:28:00,200 --> 00:28:05,009
whoever simply can't do anything you can

00:28:02,810 --> 00:28:07,710
quote me on this

00:28:05,009 --> 00:28:10,119
okay so this is this is kind of a joke

00:28:07,710 --> 00:28:13,529
but it but like what some of the best

00:28:10,119 --> 00:28:15,759
jokes it's actually also kind of true

00:28:13,529 --> 00:28:20,139
the thing is what was simply can't do

00:28:15,759 --> 00:28:22,179
anything unless you allow it to and so

00:28:20,139 --> 00:28:24,340
the way that works is that you have a

00:28:22,179 --> 00:28:26,919
web assembly module and a web assembly

00:28:24,340 --> 00:28:29,440
module has a collection of imports and a

00:28:26,919 --> 00:28:32,049
collection of exports and so the imports

00:28:29,440 --> 00:28:35,980
are what your web assembly program is

00:28:32,049 --> 00:28:39,070
allowed to do and the exports is

00:28:35,980 --> 00:28:42,450
basically what you are the web assembly

00:28:39,070 --> 00:28:46,690
module is allowing you to do to it

00:28:42,450 --> 00:28:48,700
that's maybe a way to think of it so for

00:28:46,690 --> 00:28:52,359
example if you have a web assembly

00:28:48,700 --> 00:28:56,710
module that is has maybe a carnivorous

00:28:52,359 --> 00:28:58,720
plant living outside of it you don't

00:28:56,710 --> 00:29:01,149
actually have to worry about that

00:28:58,720 --> 00:29:04,499
carnivorous plant being fed unless you

00:29:01,149 --> 00:29:06,999
provide a feed pant plants blood import

00:29:04,499 --> 00:29:10,299
if all you have is water plant then

00:29:06,999 --> 00:29:14,799
you're safe so you can actually rely on

00:29:10,299 --> 00:29:17,100
this by the way yes don't feed the

00:29:14,799 --> 00:29:17,100
plants

00:29:17,879 --> 00:29:27,039
Adri to anyone okay so this actually

00:29:25,119 --> 00:29:29,859
presents a strength and a weakness of

00:29:27,039 --> 00:29:32,529
web assembly right because what we've

00:29:29,859 --> 00:29:35,830
ended up with is that whoever simply

00:29:32,529 --> 00:29:37,359
can't really do anything by default and

00:29:35,830 --> 00:29:38,919
what that means is that you can craft a

00:29:37,359 --> 00:29:41,289
web assembly module to do exactly what

00:29:38,919 --> 00:29:42,850
you want right you can provide exactly

00:29:41,289 --> 00:29:44,529
the imports you want in exactly the

00:29:42,850 --> 00:29:47,289
exports that you want but that also

00:29:44,529 --> 00:29:50,379
means that if you have a web module and

00:29:47,289 --> 00:29:52,059
a non web module you might actually need

00:29:50,379 --> 00:29:54,940
to provide different implementations so

00:29:52,059 --> 00:29:56,739
for example here we have a console log

00:29:54,940 --> 00:29:59,499
which is how you might do it if you are

00:29:56,739 --> 00:30:01,299
using a web module and you might have a

00:29:59,499 --> 00:30:03,309
function like right if you're using a

00:30:01,299 --> 00:30:06,279
non web module right and so

00:30:03,309 --> 00:30:09,159
theoretically these these modules should

00:30:06,279 --> 00:30:10,809
be able to run identically right there

00:30:09,159 --> 00:30:12,609
there's no reason that we need to

00:30:10,809 --> 00:30:15,460
actually have a difference here but

00:30:12,609 --> 00:30:16,599
there's just no standard one way you

00:30:15,460 --> 00:30:18,220
could work around this is by by

00:30:16,599 --> 00:30:24,549
providing a shim you

00:30:18,220 --> 00:30:28,059
have a function that say implements

00:30:24,549 --> 00:30:30,360
these equivalently but what's better it

00:30:28,059 --> 00:30:35,169
is to have some kind of standard and

00:30:30,360 --> 00:30:37,390
that's actually what Y Z is so Y Z is

00:30:35,169 --> 00:30:39,730
also being developed as a standard in

00:30:37,390 --> 00:30:41,590
the w3 as a sub subgroup of the

00:30:39,730 --> 00:30:43,659
webassembly group I was originally

00:30:41,590 --> 00:30:46,179
proposed by Dan Goleman but it's it's

00:30:43,659 --> 00:30:50,710
there's a large group of people working

00:30:46,179 --> 00:30:52,450
on this and the way to think of it is is

00:30:50,710 --> 00:30:55,799
that it's got a kind of a similar

00:30:52,450 --> 00:30:57,610
functionality to a stripped-down POSIX

00:30:55,799 --> 00:31:00,159
the difference is that it's actually

00:30:57,610 --> 00:31:03,100
been developed as a capability system so

00:31:00,159 --> 00:31:04,390
unlike POSIX you know that it's and

00:31:03,100 --> 00:31:07,299
similar to webassembly

00:31:04,390 --> 00:31:10,539
you only have the behavior that you

00:31:07,299 --> 00:31:12,250
allow right so you can't access any

00:31:10,539 --> 00:31:16,240
files in the file system that aren't

00:31:12,250 --> 00:31:20,409
actually given to the to the huazi

00:31:16,240 --> 00:31:23,799
interface so currently huazi is actually

00:31:20,409 --> 00:31:25,299
very small there's only 45 functions if

00:31:23,799 --> 00:31:29,770
you know POSIX I think there's something

00:31:25,299 --> 00:31:31,059
like 300 or 400 maybe sis calls you can

00:31:29,770 --> 00:31:34,179
think of it as being very similar as

00:31:31,059 --> 00:31:36,850
this calls and so you can see some of

00:31:34,179 --> 00:31:38,289
the the common functionality that you'd

00:31:36,850 --> 00:31:40,929
expect right so we have things like

00:31:38,289 --> 00:31:43,390
being able to read arguments get clocks

00:31:40,929 --> 00:31:45,580
we can read from the environment we can

00:31:43,390 --> 00:31:48,820
read a lot of things from files and

00:31:45,580 --> 00:31:53,679
write to files we can look up things in

00:31:48,820 --> 00:31:55,960
a path we can you know exit that's

00:31:53,679 --> 00:31:57,820
always important to do we can get random

00:31:55,960 --> 00:32:04,059
numbers and then there's some scheduling

00:31:57,820 --> 00:32:08,289
as well so the way to think of this is

00:32:04,059 --> 00:32:12,010
that y'see actually is also comes with

00:32:08,289 --> 00:32:14,169
Lib C so when you use it you can

00:32:12,010 --> 00:32:16,299
actually write code like F open and that

00:32:14,169 --> 00:32:17,200
will be translated into the Y Z function

00:32:16,299 --> 00:32:18,880
path open

00:32:17,200 --> 00:32:22,659
similarly something like printf will be

00:32:18,880 --> 00:32:26,049
turned into FD write re F read will be

00:32:22,659 --> 00:32:29,919
turned into F D read and so on and since

00:32:26,049 --> 00:32:31,330
this is of course a C++ talk you could

00:32:29,919 --> 00:32:32,799
do the same thing with the C++

00:32:31,330 --> 00:32:42,480
improvements

00:32:32,799 --> 00:32:46,000
I assume people use f string so there is

00:32:42,480 --> 00:32:48,309
additionally a tool called wasm time and

00:32:46,000 --> 00:32:52,029
one of the things that's very cool about

00:32:48,309 --> 00:32:54,580
once we have Y Z is we can take our

00:32:52,029 --> 00:32:57,220
environments web and non web and we can

00:32:54,580 --> 00:33:00,340
run them identically right and so has

00:32:57,220 --> 00:33:04,269
some time is a tool that allows you to

00:33:00,340 --> 00:33:07,960
run web assembly code natively in a

00:33:04,269 --> 00:33:10,120
non-web environment using a different

00:33:07,960 --> 00:33:13,029
web assembly JIT it's actually called

00:33:10,120 --> 00:33:16,559
the crane lift jet also being worked on

00:33:13,029 --> 00:33:16,559
by a number of people that moves along

00:33:16,860 --> 00:33:22,870
so I just want to give a warning wozy is

00:33:20,830 --> 00:33:24,340
still very very early I'm gonna be

00:33:22,870 --> 00:33:27,490
talking about huasi for the rest of the

00:33:24,340 --> 00:33:29,470
talk but if you try and use this I just

00:33:27,490 --> 00:33:31,000
want you to know that there's a good

00:33:29,470 --> 00:33:34,570
chance that you might have to spend a

00:33:31,000 --> 00:33:41,230
long time fixing issues maybe even up to

00:33:34,570 --> 00:33:42,970
250,000 minutes ok just kidding if you

00:33:41,230 --> 00:33:45,789
want something more mature there is a

00:33:42,970 --> 00:33:46,389
much more mature tool chain called

00:33:45,789 --> 00:33:48,250
Emscripten

00:33:46,389 --> 00:33:51,220
it's been around for a very long time

00:33:48,250 --> 00:33:53,500
since 2010 I think originally developed

00:33:51,220 --> 00:33:56,080
by alone Sakai but now there's a large

00:33:53,500 --> 00:33:58,090
community of people working on it it

00:33:56,080 --> 00:34:00,789
provides a lot of the functionality that

00:33:58,090 --> 00:34:03,549
you might want a POSIX environment but

00:34:00,789 --> 00:34:06,279
it also has a graphics and it has audio

00:34:03,549 --> 00:34:09,040
and has built-in sdl and it has it has a

00:34:06,279 --> 00:34:10,780
lot of features so if you want a more

00:34:09,040 --> 00:34:12,250
mature environment this is what you

00:34:10,780 --> 00:34:17,169
should use but this is not what I'm

00:34:12,250 --> 00:34:19,810
going to talk about today just one more

00:34:17,169 --> 00:34:22,060
thing about M scripting this was

00:34:19,810 --> 00:34:24,909
actually presented at CPP con as well so

00:34:22,060 --> 00:34:27,700
Alonso Chi talked about it back in 2014

00:34:24,909 --> 00:34:29,679
and actually chat Austin did as well

00:34:27,700 --> 00:34:31,179
back in 2014

00:34:29,679 --> 00:34:32,950
presented on it back then they were

00:34:31,179 --> 00:34:34,690
using it to produce as MJ s which is

00:34:32,950 --> 00:34:36,580
kind of like a precursor to web assembly

00:34:34,690 --> 00:34:38,889
but a lot of the things from this talk

00:34:36,580 --> 00:34:40,659
from these talks is still true and you

00:34:38,889 --> 00:34:43,030
can still use it so you should go back

00:34:40,659 --> 00:34:44,530
and watch those talks if you're curious

00:34:43,030 --> 00:34:45,850
about this and of course there's there's

00:34:44,530 --> 00:34:48,130
many many resources on

00:34:45,850 --> 00:34:54,700
line to find a lot more about how in

00:34:48,130 --> 00:34:58,450
script in words okay so the to-do list

00:34:54,700 --> 00:35:01,780
for now this is what I basically came to

00:34:58,450 --> 00:35:03,720
when I wanted to to make my demo I said

00:35:01,780 --> 00:35:07,450
okay well the first thing I got to do is

00:35:03,720 --> 00:35:09,790
get an SDK and then I'm gonna compile

00:35:07,450 --> 00:35:11,520
clang and then I'm gonna compile lld the

00:35:09,790 --> 00:35:15,280
linker and then I'm gonna be done right

00:35:11,520 --> 00:35:23,080
okay simple this is of course after I

00:35:15,280 --> 00:35:29,020
did nothing so the plan here is to take

00:35:23,080 --> 00:35:32,830
the SDK tools which by the way run on

00:35:29,020 --> 00:35:35,410
x86 but then target wasm 32 and then

00:35:32,830 --> 00:35:37,120
take the LVM source and then compile

00:35:35,410 --> 00:35:40,110
those and then i will get something

00:35:37,120 --> 00:35:43,930
which is clang running on webassembly

00:35:40,110 --> 00:35:46,330
the wisdom plasm 32 host and awasum 32

00:35:43,930 --> 00:35:48,790
target so clang already is a cross

00:35:46,330 --> 00:35:50,950
compiler but now I'm going to have

00:35:48,790 --> 00:35:53,440
essentially a cross compiler based on

00:35:50,950 --> 00:35:55,480
the well I guess I'll have a native Tyre

00:35:53,440 --> 00:36:02,680
a compiler for the web web assembly

00:35:55,480 --> 00:36:06,340
target so the first thing I did was I

00:36:02,680 --> 00:36:09,160
downloaded that SDK from this website

00:36:06,340 --> 00:36:14,470
here and the next thing I did was I

00:36:09,160 --> 00:36:15,820
cloned LVM from this here I think it's

00:36:14,470 --> 00:36:18,850
actually pretty recent that you can

00:36:15,820 --> 00:36:21,430
actually get LVM via get I think before

00:36:18,850 --> 00:36:25,300
you had to get it on SVN so this is very

00:36:21,430 --> 00:36:27,850
cool and then I perused these docs here

00:36:25,300 --> 00:36:31,080
how to cross compile LVM very very

00:36:27,850 --> 00:36:31,080
useful for this sort of thing

00:36:37,539 --> 00:36:43,059
so the first step that you find if you

00:36:40,389 --> 00:36:45,069
look at those docs is it you actually

00:36:43,059 --> 00:36:48,849
need the system clang and the system LD

00:36:45,069 --> 00:36:51,819
to produce a couple of these files in

00:36:48,849 --> 00:36:54,459
particular there's a executable called

00:36:51,819 --> 00:36:57,789
table gen which is used to to actually

00:36:54,459 --> 00:37:00,389
be able to do the compilation normally

00:36:57,789 --> 00:37:02,859
when you're doing a compilation of of

00:37:00,389 --> 00:37:04,749
LVM it'll do this for you automatically

00:37:02,859 --> 00:37:06,759
but when you're cross compiling what'll

00:37:04,749 --> 00:37:08,559
happen is it'll compile for the wrong

00:37:06,759 --> 00:37:10,569
target right and so if you're compiling

00:37:08,559 --> 00:37:12,369
for a 32 and then you're trying to run

00:37:10,569 --> 00:37:14,949
it then your compiler can't do it so you

00:37:12,369 --> 00:37:16,899
do this as a pre step you compile it and

00:37:14,949 --> 00:37:24,279
then you produce these outputs which run

00:37:16,899 --> 00:37:27,909
on x86 so now that I have the tools and

00:37:24,279 --> 00:37:30,729
I have table Jen and I have the LVM

00:37:27,909 --> 00:37:33,039
source now I can take these files and I

00:37:30,729 --> 00:37:36,399
compile them and I can do my cross

00:37:33,039 --> 00:37:39,639
compile so when I did that I got this

00:37:36,399 --> 00:37:41,169
issue atomic is not supported on this

00:37:39,639 --> 00:37:44,259
single threaded system now this is a

00:37:41,169 --> 00:37:47,159
reasonable thing for the web assembly

00:37:44,259 --> 00:37:49,539
SDK to do because actually threads are

00:37:47,159 --> 00:37:52,419
currently being developed as a proposal

00:37:49,539 --> 00:37:54,339
but they're not ready yet in all

00:37:52,419 --> 00:37:58,259
environments and so to be conservative

00:37:54,339 --> 00:38:00,579
it makes sense to disable it I want to

00:37:58,259 --> 00:38:02,919
say though that this is not the

00:38:00,579 --> 00:38:04,779
long-term goal we definitely are working

00:38:02,919 --> 00:38:08,349
on thread support it's just not there

00:38:04,779 --> 00:38:11,619
yet but I knew for example that LVM

00:38:08,349 --> 00:38:13,749
didn't need threats clang and an LOD

00:38:11,619 --> 00:38:16,599
don't need threads so I was able to just

00:38:13,749 --> 00:38:19,959
disable the code so the way that I did

00:38:16,599 --> 00:38:23,259
that was it's actually very cool if you

00:38:19,959 --> 00:38:26,469
have Lib C++ they allow you to provide

00:38:23,259 --> 00:38:30,519
your own threading library and so I did

00:38:26,469 --> 00:38:35,889
a very very nasty thing which is have

00:38:30,519 --> 00:38:37,709
them all do exactly nothing and you will

00:38:35,889 --> 00:38:41,529
be surprised but this actually does work

00:38:37,709 --> 00:38:46,869
I'm I see some shocked faces in the

00:38:41,529 --> 00:38:49,569
audience ok so then I started running

00:38:46,869 --> 00:38:51,190
into some of the issues that you might

00:38:49,569 --> 00:38:53,230
expect to see

00:38:51,190 --> 00:38:56,650
when you're compiling code for a

00:38:53,230 --> 00:38:59,530
different environment so rasli doesn't

00:38:56,650 --> 00:39:01,839
have signals webassembly doesn't either

00:38:59,530 --> 00:39:02,650
I knew that I didn't really need any of

00:39:01,839 --> 00:39:04,540
these

00:39:02,650 --> 00:39:08,079
so I basically commented out any of the

00:39:04,540 --> 00:39:10,390
code that used this again

00:39:08,079 --> 00:39:13,089
I'm scripting I think does have

00:39:10,390 --> 00:39:14,560
implementations of a lot of these but

00:39:13,089 --> 00:39:18,810
again from my case I knew that I didn't

00:39:14,560 --> 00:39:22,000
need to to handle any of these similarly

00:39:18,810 --> 00:39:24,790
webassembly doesn't have a map and mom

00:39:22,000 --> 00:39:26,319
on map and M protect we definitely want

00:39:24,790 --> 00:39:29,740
to support these but you know

00:39:26,319 --> 00:39:31,960
webassembly is still very early it turns

00:39:29,740 --> 00:39:34,390
out that in my case I actually knew that

00:39:31,960 --> 00:39:36,040
I didn't really need the sort of

00:39:34,390 --> 00:39:38,589
advanced features of M map so I could

00:39:36,040 --> 00:39:40,930
turn this into a malloc and free and

00:39:38,589 --> 00:39:45,460
that was basically enough to do what I I

00:39:40,930 --> 00:39:47,500
needed to do l LD actually does have an

00:39:45,460 --> 00:39:49,060
optimization where they M map files and

00:39:47,500 --> 00:39:52,510
then they can just write directly into

00:39:49,060 --> 00:39:54,160
it for to make it run very fast it's

00:39:52,510 --> 00:39:56,950
very cool though actually they have a

00:39:54,160 --> 00:39:59,200
they have a fallback where if M map

00:39:56,950 --> 00:40:00,550
isn't supported it'll just you know

00:39:59,200 --> 00:40:03,520
write into a buffer and then write it

00:40:00,550 --> 00:40:05,230
out as a file so turns out that they

00:40:03,520 --> 00:40:10,599
kind of already solved the problem for

00:40:05,230 --> 00:40:13,420
me so there's some issues with things

00:40:10,599 --> 00:40:17,010
like I mean by the way I just want to

00:40:13,420 --> 00:40:17,010
say these names are horrible right

00:40:17,160 --> 00:40:23,619
anyway so yeah so these are like things

00:40:21,160 --> 00:40:25,150
about users and passwords and such I

00:40:23,619 --> 00:40:27,490
knew that I didn't need any of this

00:40:25,150 --> 00:40:28,660
stuff so again I just sort of put in

00:40:27,490 --> 00:40:30,430
dummy values

00:40:28,660 --> 00:40:34,050
I forget what I actually put in for

00:40:30,430 --> 00:40:34,050
these but I'm sure it was something fun

00:40:34,230 --> 00:40:37,960
these ones are a little bit more

00:40:35,980 --> 00:40:39,940
surprising to me actually I think

00:40:37,960 --> 00:40:42,310
huazi is actually kind of conservative

00:40:39,940 --> 00:40:48,010
in in the features that it provides and

00:40:42,310 --> 00:40:49,780
so in particular gets get CVWD and real

00:40:48,010 --> 00:40:55,210
path really should be provided and maybe

00:40:49,780 --> 00:40:56,740
trigger as well and so I I basically

00:40:55,210 --> 00:40:59,440
just wrote sort of simple

00:40:56,740 --> 00:41:01,329
implementations of those stab BFS and F

00:40:59,440 --> 00:41:02,920
stat VFS those are like basically

00:41:01,329 --> 00:41:04,660
looking at information inside the file

00:41:02,920 --> 00:41:07,900
system I

00:41:04,660 --> 00:41:10,390
I heard dummy values as well and then up

00:41:07,900 --> 00:41:14,319
to I think that's actually a capability

00:41:10,390 --> 00:41:16,630
restriction so but again I don't think

00:41:14,319 --> 00:41:18,609
that that one was actually required so I

00:41:16,630 --> 00:41:21,599
commented that out and of course I octal

00:41:18,609 --> 00:41:24,309
is the the grab bag of the POSIX

00:41:21,599 --> 00:41:28,200
functions I think in this case it was

00:41:24,309 --> 00:41:30,640
just used to maybe it was to change the

00:41:28,200 --> 00:41:32,849
mmm I actually can't remember I think it

00:41:30,640 --> 00:41:35,530
might have had something to do with like

00:41:32,849 --> 00:41:41,559
changing the the width of the terminal

00:41:35,530 --> 00:41:44,020
in any case it wasn't necessary okay so

00:41:41,559 --> 00:41:46,000
these ones are people's favorites as

00:41:44,020 --> 00:41:49,089
well said jump long jump

00:41:46,000 --> 00:41:52,119
those ones actually are supported in M

00:41:49,089 --> 00:41:54,970
scripting in a very very nasty way what

00:41:52,119 --> 00:41:56,650
actually happens is when you call set

00:41:54,970 --> 00:41:59,049
jump what actually happens is it calls

00:41:56,650 --> 00:42:01,930
out to JavaScript creates a try block

00:41:59,049 --> 00:42:03,130
calls back into your web assembly calls

00:42:01,930 --> 00:42:05,740
your functions and then when you do a

00:42:03,130 --> 00:42:08,589
long jump it actually calls up to

00:42:05,740 --> 00:42:10,089
javascript throws and then it catches in

00:42:08,589 --> 00:42:12,460
the JavaScript block and then goes back

00:42:10,089 --> 00:42:17,650
and it turns out that that actually does

00:42:12,460 --> 00:42:19,779
work but it's not preferred and so I

00:42:17,650 --> 00:42:23,309
will also like to say that there is a

00:42:19,779 --> 00:42:26,500
proposal an ongoing proposal to add real

00:42:23,309 --> 00:42:28,809
zero or low cost exceptions to to

00:42:26,500 --> 00:42:31,539
webassembly that's actually pretty far

00:42:28,809 --> 00:42:34,510
along it has some of the limitation in

00:42:31,539 --> 00:42:36,400
in some browsers it's just it's a little

00:42:34,510 --> 00:42:38,740
too early for huazi and so again because

00:42:36,400 --> 00:42:45,010
of being conservative it's not it's not

00:42:38,740 --> 00:42:48,369
here so yes and then get host name again

00:42:45,010 --> 00:42:50,980
that can just be stubbed out and then

00:42:48,369 --> 00:42:53,920
finally everyone's favorite the the

00:42:50,980 --> 00:42:56,470
lovely process functions so things like

00:42:53,920 --> 00:43:02,529
POSIX spawn and get paid and gets it and

00:42:56,470 --> 00:43:05,230
we pit all that stuff yeah that's more

00:43:02,529 --> 00:43:08,529
stuff that only is necessary if you run

00:43:05,230 --> 00:43:11,529
the compiler as a driver so it turns out

00:43:08,529 --> 00:43:13,180
because the compiler actually has the

00:43:11,529 --> 00:43:15,130
compiler and the driver in the same

00:43:13,180 --> 00:43:18,000
executable we can just sort of skip all

00:43:15,130 --> 00:43:20,880
of the process stuff

00:43:18,000 --> 00:43:23,160
there are ways we can make this sort of

00:43:20,880 --> 00:43:25,230
thing work using the hostess kind of an

00:43:23,160 --> 00:43:27,480
environment maybe running JavaScript as

00:43:25,230 --> 00:43:30,359
a as a pseudo kernel I know that sounds

00:43:27,480 --> 00:43:32,700
horrible but you could do it but for now

00:43:30,359 --> 00:43:37,410
I know we don't need these and so I skip

00:43:32,700 --> 00:43:41,730
these as well okay so 28 functions later

00:43:37,410 --> 00:43:45,390
I finally had enough to make this work

00:43:41,730 --> 00:43:47,400
and actually in the case of LVM I only

00:43:45,390 --> 00:43:49,380
had to touch 12 files because they they

00:43:47,400 --> 00:43:52,410
actually condensed all the code that I

00:43:49,380 --> 00:43:54,210
need to change down to about yeah 12

00:43:52,410 --> 00:44:01,170
files it's all in this support library

00:43:54,210 --> 00:44:02,430
so it was very convenient to do so at

00:44:01,170 --> 00:44:06,690
this point I started getting some weird

00:44:02,430 --> 00:44:08,010
linkers stuff like this which I mean I

00:44:06,690 --> 00:44:10,230
don't know if you can read this but I

00:44:08,010 --> 00:44:14,010
certainly couldn't I asked my colleague

00:44:10,230 --> 00:44:16,290
Sam about it and he told me that the

00:44:14,010 --> 00:44:18,090
problem was actually probably that the

00:44:16,290 --> 00:44:20,040
libraries that were being generated

00:44:18,090 --> 00:44:22,680
weren't being indexed I don't know if

00:44:20,040 --> 00:44:24,270
anyone's run into this problem before it

00:44:22,680 --> 00:44:26,820
turns out that bran Lib normally does

00:44:24,270 --> 00:44:29,940
this basically takes your your library

00:44:26,820 --> 00:44:31,290
file and then it it puts a little index

00:44:29,940 --> 00:44:34,380
in there so it can find the symbols more

00:44:31,290 --> 00:44:37,290
quickly the problem was is that I was

00:44:34,380 --> 00:44:40,200
using the system's brand Lib to try and

00:44:37,290 --> 00:44:43,260
work on a web assembly library and so as

00:44:40,200 --> 00:44:45,180
a result it wouldn't work so of course

00:44:43,260 --> 00:44:51,500
now I have to add another step I have to

00:44:45,180 --> 00:44:55,680
compile a LLVM AR and LLVM ran Lib for

00:44:51,500 --> 00:44:57,839
for x86 and then use those as well along

00:44:55,680 --> 00:44:59,820
with my hacked LVM source and actually

00:44:57,839 --> 00:45:02,609
it doesn't say it here but my hacked

00:44:59,820 --> 00:45:06,810
huazi sdk tools and then finally finally

00:45:02,609 --> 00:45:13,470
finally finally I got this all to work I

00:45:06,810 --> 00:45:17,190
got a clang and I got an LD so this is

00:45:13,470 --> 00:45:19,050
what I ended up with a clang binary that

00:45:17,190 --> 00:45:22,050
was about 50 megabytes I think that

00:45:19,050 --> 00:45:23,820
could actually be shrunk down currently

00:45:22,050 --> 00:45:26,280
the one I have is about 35 megabytes

00:45:23,820 --> 00:45:28,140
after I did some I ran an optimizer on

00:45:26,280 --> 00:45:30,180
it I think that could probably be

00:45:28,140 --> 00:45:31,650
smaller than that though and then LD is

00:45:30,180 --> 00:45:35,370
also 28

00:45:31,650 --> 00:45:37,500
megabytes and so you can see because

00:45:35,370 --> 00:45:39,600
we're using Waze II it's not even using

00:45:37,500 --> 00:45:44,010
actually all of those 45 functions it's

00:45:39,600 --> 00:45:46,260
only using about 25 of them and then it

00:45:44,010 --> 00:45:48,990
only actually exports one function start

00:45:46,260 --> 00:45:50,880
and the start function is basically the

00:45:48,990 --> 00:45:52,920
intro and then we'll call your main

00:45:50,880 --> 00:45:56,130
function and then run and do and then do

00:45:52,920 --> 00:45:58,200
everything it also exports us a couple

00:45:56,130 --> 00:46:01,350
of other useful things you can see that

00:45:58,200 --> 00:46:05,220
I exports a heap base and data end and

00:46:01,350 --> 00:46:10,620
then an object called memory and I'll

00:46:05,220 --> 00:46:13,500
talk about those now so the way that web

00:46:10,620 --> 00:46:15,270
assembly memory is laid out in LVM at

00:46:13,500 --> 00:46:16,770
least LVM produce web assembly is

00:46:15,270 --> 00:46:21,090
something like this

00:46:16,770 --> 00:46:23,670
we have a giant block of memory the part

00:46:21,090 --> 00:46:26,130
at the bottom is unused it turns out

00:46:23,670 --> 00:46:28,020
that webassembly a null pointer is

00:46:26,130 --> 00:46:30,390
completely fine to read and write

00:46:28,020 --> 00:46:33,720
because it's just reading index 0 of

00:46:30,390 --> 00:46:35,280
your memory so it's maybe a good idea to

00:46:33,720 --> 00:46:37,230
leave a little bit of space there in

00:46:35,280 --> 00:46:38,490
case people start scribbling over the

00:46:37,230 --> 00:46:41,700
null pointer you don't actually write

00:46:38,490 --> 00:46:43,080
over any of your static data so then we

00:46:41,700 --> 00:46:47,220
start writing your static data at about

00:46:43,080 --> 00:46:49,920
1k we have data end which represents the

00:46:47,220 --> 00:46:52,560
this sort of the end of the stack and

00:46:49,920 --> 00:46:55,170
then we have heap base which represents

00:46:52,560 --> 00:46:56,940
the the start of your heap and you can

00:46:55,170 --> 00:46:58,710
see the stack grows downward like all

00:46:56,940 --> 00:47:00,870
proper stacks do and the heap grows

00:46:58,710 --> 00:47:04,530
upward and the nice part here is that

00:47:00,870 --> 00:47:06,060
memory can actually grow so we can grow

00:47:04,530 --> 00:47:09,810
the size of the webassembly memory and

00:47:06,060 --> 00:47:17,430
then the heap will i'll be allowed to

00:47:09,810 --> 00:47:19,530
expand out in that direction as well so

00:47:17,430 --> 00:47:21,150
you might have remembered that I said

00:47:19,530 --> 00:47:24,030
that web assembly doesn't allow you to

00:47:21,150 --> 00:47:27,780
access the stack and it turns out that

00:47:24,030 --> 00:47:30,840
it doesn't but because we can do things

00:47:27,780 --> 00:47:32,820
like take address taken local variables

00:47:30,840 --> 00:47:37,130
or have dynamically sized local

00:47:32,820 --> 00:47:40,710
variables we do actually need to have a

00:47:37,130 --> 00:47:43,500
shadow stack as what we call it and this

00:47:40,710 --> 00:47:45,210
does live in memory this lives in

00:47:43,500 --> 00:47:47,700
webassembly memory and you're allowed to

00:47:45,210 --> 00:47:49,230
access it so these are a couple of cases

00:47:47,700 --> 00:47:51,180
where we actually do have a stack

00:47:49,230 --> 00:47:52,950
pointer that does move inside the

00:47:51,180 --> 00:47:54,870
webassembly memory and we store it for

00:47:52,950 --> 00:47:58,890
these values but only for the values

00:47:54,870 --> 00:48:01,050
that that the compiler knows it needs to

00:47:58,890 --> 00:48:12,270
actually allocate space on the untrusted

00:48:01,050 --> 00:48:15,960
stack for so as I said before clang

00:48:12,270 --> 00:48:18,360
actually is a driver and a compiler so

00:48:15,960 --> 00:48:20,760
when you run clang normally what happens

00:48:18,360 --> 00:48:23,310
is it runs both of these pieces for you

00:48:20,760 --> 00:48:26,820
so for example if you do food at C - au

00:48:23,310 --> 00:48:29,700
feu it will compile to a few executable

00:48:26,820 --> 00:48:32,490
by running the compiler and the linker

00:48:29,700 --> 00:48:34,320
for you and if you run a - hash hash

00:48:32,490 --> 00:48:36,750
hash I think that's how you might say

00:48:34,320 --> 00:48:39,450
that it will tell you what it's actually

00:48:36,750 --> 00:48:41,790
running under the hood this is sort of

00:48:39,450 --> 00:48:44,070
stripped-down version of it but it gives

00:48:41,790 --> 00:48:46,740
you the right idea it runs a number of

00:48:44,070 --> 00:48:49,020
different arguments here passing the the

00:48:46,740 --> 00:48:52,290
triple that's required you can see it

00:48:49,020 --> 00:48:56,790
does emit AUB's that's what the dot - Oh

00:48:52,290 --> 00:48:58,620
turns out actually yeah that that's how

00:48:56,790 --> 00:49:02,100
that would be the equivalent of like -

00:48:58,620 --> 00:49:03,840
see yeah right thank you and then it

00:49:02,100 --> 00:49:07,070
also passed it it passes in things like

00:49:03,840 --> 00:49:07,070
this this route and so on

00:49:12,579 --> 00:49:18,980
so one cool thing that we can do now

00:49:16,490 --> 00:49:21,800
that we have these wasm binaries in

00:49:18,980 --> 00:49:27,069
huazi is we can take wesam time our

00:49:21,800 --> 00:49:31,040
non-web tool and we can run our compiler

00:49:27,069 --> 00:49:32,660
using wasm but but in the just like from

00:49:31,040 --> 00:49:35,359
the command line and the way you do that

00:49:32,660 --> 00:49:36,829
is you run wasm time and then as I said

00:49:35,359 --> 00:49:39,020
it's a capability system so you actually

00:49:36,829 --> 00:49:40,579
have to provide you have to tell it what

00:49:39,020 --> 00:49:43,819
it's allowed to access and so in this

00:49:40,579 --> 00:49:45,200
case we say you're allowed to access the

00:49:43,819 --> 00:49:50,030
current working directory I'm calling

00:49:45,200 --> 00:49:52,819
PWD here and it's called source inside

00:49:50,030 --> 00:49:55,010
the inside the system and then similarly

00:49:52,819 --> 00:49:57,319
we can access a directory called sis

00:49:55,010 --> 00:49:59,119
root and that's called sis inside the

00:49:57,319 --> 00:50:02,270
system so you can see the sort of colors

00:49:59,119 --> 00:50:04,700
match map up here and so we can run this

00:50:02,270 --> 00:50:06,349
and test this and it works and that's

00:50:04,700 --> 00:50:09,800
very cool because now I don't even have

00:50:06,349 --> 00:50:13,300
to like there's no JavaScript yet this

00:50:09,800 --> 00:50:13,300
is all just running on the command line

00:50:16,900 --> 00:50:22,670
and so one cool thing about this

00:50:19,520 --> 00:50:26,450
capability system is that actually you

00:50:22,670 --> 00:50:28,910
are prevented I guess you might say from

00:50:26,450 --> 00:50:32,869
from accessing outside of there so in

00:50:28,910 --> 00:50:35,660
this case I'm trying to access outside

00:50:32,869 --> 00:50:38,180
of the source directory but in as far as

00:50:35,660 --> 00:50:39,710
wasm time is concerned as far as he is

00:50:38,180 --> 00:50:41,119
concerned that's not a real thing

00:50:39,710 --> 00:50:45,079
there's nothing outside of that it's

00:50:41,119 --> 00:50:45,980
kind of like you're in a showroom yeah

00:50:45,079 --> 00:50:48,319
exactly

00:50:45,980 --> 00:50:49,640
thank you for help anyone who's helping

00:50:48,319 --> 00:50:53,770
me out when I'm trying to remember words

00:50:49,640 --> 00:50:57,109
by the way so yeah this actually uses

00:50:53,770 --> 00:50:59,569
lib pre-open to handle this behavior I

00:50:57,109 --> 00:51:02,300
think it's all ready to borrow some of

00:50:59,569 --> 00:51:06,160
the code from that so this is very very

00:51:02,300 --> 00:51:06,160
cool for being able to do sandboxing

00:51:06,310 --> 00:51:13,099
okay so what we have now is we have wasm

00:51:09,650 --> 00:51:15,530
time which has the Razzie imports

00:51:13,099 --> 00:51:19,490
already implemented and then we can use

00:51:15,530 --> 00:51:21,530
those to run clang but if we want to run

00:51:19,490 --> 00:51:23,480
this in the browser we actually need to

00:51:21,530 --> 00:51:25,280
provide our own Wasley implementation

00:51:23,480 --> 00:51:25,819
because that's not currently provided in

00:51:25,280 --> 00:51:27,619
the

00:51:25,819 --> 00:51:30,229
yet it might be in the future but for

00:51:27,619 --> 00:51:33,079
now it isn't but fortunately we can

00:51:30,229 --> 00:51:35,660
write some amount of web assembly and

00:51:33,079 --> 00:51:41,059
JavaScript to be able to implement those

00:51:35,660 --> 00:51:42,349
imports and then run clang so it turns

00:51:41,059 --> 00:51:45,229
out that Wesley actually already has a

00:51:42,349 --> 00:51:48,469
polyfill for this but you know because

00:51:45,229 --> 00:51:51,739
my job was not hard enough as it is I

00:51:48,469 --> 00:51:54,829
decided to write my own in-memory file

00:51:51,739 --> 00:51:57,049
system to be able to implement huazi

00:51:54,829 --> 00:52:02,209
here so that I could run clang in the

00:51:57,049 --> 00:52:05,329
browser so this is how I did that I have

00:52:02,209 --> 00:52:07,670
my JavaScript code here and then I have

00:52:05,329 --> 00:52:10,969
a mem FS web assembly module that I

00:52:07,670 --> 00:52:13,219
compiled using C++ and using huazi which

00:52:10,969 --> 00:52:16,279
implements the imports that are required

00:52:13,219 --> 00:52:18,469
for clang including things like FD read

00:52:16,279 --> 00:52:20,749
FD seek and so on as you can see here

00:52:18,469 --> 00:52:23,140
and then I have other implementations

00:52:20,749 --> 00:52:25,489
that are not related to the file system

00:52:23,140 --> 00:52:26,660
that are implemented in JavaScript so

00:52:25,489 --> 00:52:30,829
things like being able to get the

00:52:26,660 --> 00:52:32,089
arguments from the from the color also

00:52:30,829 --> 00:52:34,900
being able to read the environment and

00:52:32,089 --> 00:52:43,900
things like doing a process exit

00:52:34,900 --> 00:52:46,880
something like that so to make this work

00:52:43,900 --> 00:52:50,029
we actually need to add a little bit of

00:52:46,880 --> 00:52:52,759
functionality that in JavaScript what

00:52:50,029 --> 00:52:55,339
happens is we have an in-memory file

00:52:52,759 --> 00:52:56,809
system that has its own memory and then

00:52:55,339 --> 00:53:01,069
we have clang which has its own memory

00:52:56,809 --> 00:53:02,719
and we want to be able to copy data back

00:53:01,069 --> 00:53:03,890
and forth between the two right because

00:53:02,719 --> 00:53:07,160
what will happen is clang will say

00:53:03,890 --> 00:53:09,199
something like read this file and it has

00:53:07,160 --> 00:53:11,599
some buffer that it wants to get filled

00:53:09,199 --> 00:53:13,549
in and the Memphis has that data

00:53:11,599 --> 00:53:15,529
available and it wants to be able to

00:53:13,549 --> 00:53:17,779
take the data from the memory FS and

00:53:15,529 --> 00:53:19,609
then copy it into claim and now

00:53:17,779 --> 00:53:21,949
currently web assembly does not allow

00:53:19,609 --> 00:53:24,920
multiple accesses to memory so a

00:53:21,949 --> 00:53:29,539
particular web assembly module can only

00:53:24,920 --> 00:53:33,410
access its own memory but JavaScript has

00:53:29,539 --> 00:53:35,509
access to both memories so what you can

00:53:33,410 --> 00:53:37,579
do is import a copy in and copy out

00:53:35,509 --> 00:53:39,440
function from JavaScript which knows how

00:53:37,579 --> 00:53:42,170
to do the behavior and

00:53:39,440 --> 00:53:44,540
and call that from inside mem if s to be

00:53:42,170 --> 00:53:47,570
able to say copy my data in or copy my

00:53:44,540 --> 00:53:56,270
data out to the to the running

00:53:47,570 --> 00:53:58,760
executable so the other thing that you

00:53:56,270 --> 00:54:03,020
need for a compiler I did not have in my

00:53:58,760 --> 00:54:05,120
to-do list is you need includes you need

00:54:03,020 --> 00:54:07,700
libraries and things like that but one

00:54:05,120 --> 00:54:09,710
of the very very cool things about what

00:54:07,700 --> 00:54:12,110
we just did is that we already have this

00:54:09,710 --> 00:54:14,630
stuff available in the web assembly the

00:54:12,110 --> 00:54:17,090
huazi sdk it needs that to be able to

00:54:14,630 --> 00:54:19,040
run Rasim 32 in the first place so we

00:54:17,090 --> 00:54:23,240
can actually take the exact same sis

00:54:19,040 --> 00:54:26,840
route from the huazi sdk and we can tar

00:54:23,240 --> 00:54:30,260
it up together and include that instead

00:54:26,840 --> 00:54:36,770
and write that directly into our memory

00:54:30,260 --> 00:54:38,930
in memory file system so what I did was

00:54:36,770 --> 00:54:42,110
I well I got ahead of myself here a

00:54:38,930 --> 00:54:43,970
little bit I up this data and I produced

00:54:42,110 --> 00:54:45,620
a sister oogtar and then I wrote a

00:54:43,970 --> 00:54:47,540
little function in JavaScript that

00:54:45,620 --> 00:54:50,420
allows you to enter it and it turns out

00:54:47,540 --> 00:54:52,820
that actually tar is an incredibly

00:54:50,420 --> 00:54:55,400
simple format so I think this function

00:54:52,820 --> 00:54:56,660
is something like 15 lines or something

00:54:55,400 --> 00:55:01,750
to be able to read it out into the

00:54:56,660 --> 00:55:05,120
in-memory file system it's very cool and

00:55:01,750 --> 00:55:07,130
so this actually allows us to do pretty

00:55:05,120 --> 00:55:10,010
much everything we need the only other

00:55:07,130 --> 00:55:11,990
thing I had to add here is that it would

00:55:10,010 --> 00:55:14,240
it's nice to be able to rather than

00:55:11,990 --> 00:55:16,100
using the low-level interface for

00:55:14,240 --> 00:55:18,140
reading and writing files to the memory

00:55:16,100 --> 00:55:20,090
filesystem I I have a little sort of

00:55:18,140 --> 00:55:23,810
cheap function that allows me to just

00:55:20,090 --> 00:55:30,770
write whole files indirectly just a nice

00:55:23,810 --> 00:55:33,740
little convenience there okay so taking

00:55:30,770 --> 00:55:35,660
a step back this is how our system is

00:55:33,740 --> 00:55:38,540
set up we have JavaScript and we have

00:55:35,660 --> 00:55:40,640
our memory FS so the very first thing we

00:55:38,540 --> 00:55:44,600
do is we take our sister me on

00:55:40,640 --> 00:55:47,120
Tarth at into the memory FS then the

00:55:44,600 --> 00:55:49,550
next thing we do is we take our CC file

00:55:47,120 --> 00:55:51,920
that's in JavaScript somewhere and then

00:55:49,550 --> 00:55:53,420
we write that across into our memory FS

00:55:51,920 --> 00:55:56,470
as well so

00:55:53,420 --> 00:55:59,569
it's available to be accessed by claim

00:55:56,470 --> 00:56:03,319
then we take that file and we write it

00:55:59,569 --> 00:56:06,859
into clang using our copy in when we get

00:56:03,319 --> 00:56:08,420
a compile call from JavaScript what

00:56:06,859 --> 00:56:10,430
clang will do then is we'll use that

00:56:08,420 --> 00:56:13,760
memory FS and then write it back out as

00:56:10,430 --> 00:56:16,880
a an object file into the same in-memory

00:56:13,760 --> 00:56:19,579
filesystem then as you might expect when

00:56:16,880 --> 00:56:21,680
you do your link call it'll take that

00:56:19,579 --> 00:56:24,020
object file link it and then it will

00:56:21,680 --> 00:56:26,930
produce a web assembly file again in the

00:56:24,020 --> 00:56:28,819
mem memory filesystem and then finally

00:56:26,930 --> 00:56:32,140
what we can do is we can pull that web

00:56:28,819 --> 00:56:35,690
assembly file out and then we can

00:56:32,140 --> 00:56:38,210
compile that using the normal web

00:56:35,690 --> 00:56:41,569
assembly compilation tools which will

00:56:38,210 --> 00:56:43,130
produce a new foo module here which we

00:56:41,569 --> 00:56:47,990
can then run and hook up to the same

00:56:43,130 --> 00:56:49,579
in-memory file system and then it can

00:56:47,990 --> 00:56:52,069
actually do any of the access that we

00:56:49,579 --> 00:56:56,930
need to do here so that gives you may be

00:56:52,069 --> 00:57:00,559
sort of a lay of the land here but I

00:56:56,930 --> 00:57:01,760
actually was being a little bit I didn't

00:57:00,559 --> 00:57:04,099
go into all the details that are

00:57:01,760 --> 00:57:06,230
required here so there there are a

00:57:04,099 --> 00:57:09,380
couple of steps that are necessary to

00:57:06,230 --> 00:57:11,059
produce a web assembly module the module

00:57:09,380 --> 00:57:13,579
isn't actually the thing that you run

00:57:11,059 --> 00:57:16,160
the module is more sort of like the

00:57:13,579 --> 00:57:18,799
compiled code you might say the instance

00:57:16,160 --> 00:57:21,410
is more like the running process so the

00:57:18,799 --> 00:57:23,500
the module is sort of like the static

00:57:21,410 --> 00:57:25,760
data and the instance is sort of the

00:57:23,500 --> 00:57:28,880
dynamic data it actually has the memory

00:57:25,760 --> 00:57:30,380
objects and so on and one of the cool

00:57:28,880 --> 00:57:32,599
things here is that you can actually

00:57:30,380 --> 00:57:34,849
take a single module and you can produce

00:57:32,599 --> 00:57:36,619
multiple instances in exactly the same

00:57:34,849 --> 00:57:38,680
way that you have one executable and you

00:57:36,619 --> 00:57:41,329
have multiple running processes of that

00:57:38,680 --> 00:57:46,940
and so what this means is that we can

00:57:41,329 --> 00:57:51,079
actually compile our code once for clang

00:57:46,940 --> 00:57:53,359
and instantiate it which is to say sort

00:57:51,079 --> 00:57:56,299
of run that process many many times

00:57:53,359 --> 00:57:59,660
and so the compilation is is relatively

00:57:56,299 --> 00:58:02,180
slow three seconds or so depends on the

00:57:59,660 --> 00:58:05,390
implementation but instantiation is much

00:58:02,180 --> 00:58:07,010
much faster because all that work is

00:58:05,390 --> 00:58:10,070
pretty much done you just sort of

00:58:07,010 --> 00:58:11,990
have to fill in the holes there's there

00:58:10,070 --> 00:58:14,270
certain stubs that are not completely

00:58:11,990 --> 00:58:20,810
filled in and so instantiation sort of

00:58:14,270 --> 00:58:26,690
fills in those pockets some final things

00:58:20,810 --> 00:58:28,070
about the implementation here so there

00:58:26,690 --> 00:58:32,360
are a couple things that you need to do

00:58:28,070 --> 00:58:36,440
when you're running on the web there is

00:58:32,360 --> 00:58:37,880
a kind of issue which is that pretty

00:58:36,440 --> 00:58:40,850
much everything runs on the main thread

00:58:37,880 --> 00:58:43,010
including the UI and JavaScript so if

00:58:40,850 --> 00:58:46,190
you run code in JavaScript and it blocks

00:58:43,010 --> 00:58:48,230
the UI that means your your web page

00:58:46,190 --> 00:58:52,760
won't be able to be interacted with

00:58:48,230 --> 00:58:55,100
anymore and of course the one solution

00:58:52,760 --> 00:58:57,050
to that is to create a worker so what I

00:58:55,100 --> 00:58:58,610
do is I actually create a worker and

00:58:57,050 --> 00:59:00,650
that's where all of that behavior that I

00:58:58,610 --> 00:59:03,740
talked about before actually happens so

00:59:00,650 --> 00:59:05,840
when you click a button to run it says

00:59:03,740 --> 00:59:08,030
run on the worker and then it actually

00:59:05,840 --> 00:59:10,280
runs all of that code inside the worker

00:59:08,030 --> 00:59:13,160
and then it sends the results back to

00:59:10,280 --> 00:59:15,380
the main thread to for display and

00:59:13,160 --> 00:59:17,390
similarly I have a service worker that I

00:59:15,380 --> 00:59:20,570
run a service worker is kind of like a

00:59:17,390 --> 00:59:22,940
programmable Network proxy and the idea

00:59:20,570 --> 00:59:25,250
there is that now when we do a fetch for

00:59:22,940 --> 00:59:28,100
the clang module and for the LD module

00:59:25,250 --> 00:59:29,870
which are they're both pretty large we

00:59:28,100 --> 00:59:33,620
can actually cache those on your system

00:59:29,870 --> 00:59:36,020
and so the demo that I'll show you very

00:59:33,620 --> 00:59:37,880
soon actually does that and it means

00:59:36,020 --> 00:59:40,670
that once you download it you don't

00:59:37,880 --> 00:59:45,380
really have to download it again so

00:59:40,670 --> 00:59:47,540
that's pretty cool too there are a

00:59:45,380 --> 00:59:49,400
couple of other things that I use mostly

00:59:47,540 --> 00:59:49,790
because I saw that compiler Explorer use

00:59:49,400 --> 00:59:52,550
them

00:59:49,790 --> 00:59:56,330
I don't think compiler Explorer uses ace

00:59:52,550 --> 00:59:58,310
maybe Monaco Monaco yeah ok so I ended

00:59:56,330 --> 01:00:00,970
up using ace I also use golden layout

00:59:58,310 --> 01:00:03,110
which is an amazing tool very very cool

01:00:00,970 --> 01:00:06,530
highly recommend and then I also use

01:00:03,110 --> 01:00:09,260
x-term j/s that's basically a terminal

01:00:06,530 --> 01:00:11,560
that allows you to display all the nice

01:00:09,260 --> 01:00:13,910
output I think it's very commonly used

01:00:11,560 --> 01:00:17,060
so yeah these are all really excellent

01:00:13,910 --> 01:00:21,760
tools and made my job a lot easier

01:00:17,060 --> 01:00:21,760
for making this stuff look good

01:00:22,140 --> 01:00:29,710
all right

01:00:24,039 --> 01:00:44,500
and with that who's ready for some super

01:00:29,710 --> 01:00:52,270
live demos okay ah nervousness okay

01:00:44,500 --> 01:00:56,799
can we see this can I see this all right

01:00:52,270 --> 01:00:58,750
so this is currently what I have so this

01:00:56,799 --> 01:01:00,849
is the the first tool that I sort of

01:00:58,750 --> 01:01:04,270
played around with this is basically

01:01:00,849 --> 01:01:06,160
doing what compiler Explorer does so I

01:01:04,270 --> 01:01:08,260
have my terminal over here let's see if

01:01:06,160 --> 01:01:11,529
I can this is much harder to do than I

01:01:08,260 --> 01:01:14,020
thought it was going to be okay so you

01:01:11,529 --> 01:01:17,559
can see the assembly code on the right

01:01:14,020 --> 01:01:19,270
I actually cross-compiled the tool so

01:01:17,559 --> 01:01:22,089
the I I sort of lied when I said that

01:01:19,270 --> 01:01:23,799
the web assembly tool was was compiling

01:01:22,089 --> 01:01:25,299
to webassembly it because clang is a

01:01:23,799 --> 01:01:28,000
cross compiler you can just add another

01:01:25,299 --> 01:01:30,460
target in so I added in x86 as well so

01:01:28,000 --> 01:01:34,029
you can see that here so if I do

01:01:30,460 --> 01:01:35,650
something like changes to a two you can

01:01:34,029 --> 01:01:39,160
see that it changes that to there on the

01:01:35,650 --> 01:01:40,750
movie ax 2 or so on right so let's see

01:01:39,160 --> 01:01:45,520
if I can do the thing that I was

01:01:40,750 --> 01:01:49,599
practicing we can do like and and do

01:01:45,520 --> 01:01:54,849
that and then say this and it's

01:01:49,599 --> 01:01:58,029
compiling stuff and I can say if let's

01:01:54,849 --> 01:02:01,329
see n is less than to return B that's

01:01:58,029 --> 01:02:05,109
right right then I can do something like

01:02:01,329 --> 01:02:11,020
this and there should be B and a plus B

01:02:05,109 --> 01:02:12,490
right ok right is that correct

01:02:11,020 --> 01:02:16,329
all right I don't know if it's correct

01:02:12,490 --> 01:02:20,069
but we can do is we can do a test

01:02:16,329 --> 01:02:27,069
function here I actually don't need that

01:02:20,069 --> 01:02:33,450
and then oops we can say return fit up

01:02:27,069 --> 01:02:33,450
to ok and we can just increase this song

01:02:34,089 --> 01:02:42,079
right okay I mean I think that's right

01:02:39,430 --> 01:02:43,720
okay so this is this is sort of like the

01:02:42,079 --> 01:02:47,809
in-browser

01:02:43,720 --> 01:02:49,369
equivalent of compiler Explorer and yeah

01:02:47,809 --> 01:02:51,319
so this is all there's there's no

01:02:49,369 --> 01:02:53,809
server's involved here I actually slowed

01:02:51,319 --> 01:02:56,599
down the the compiling but previously I

01:02:53,809 --> 01:02:58,460
was testing it with compiling like every

01:02:56,599 --> 01:03:01,430
hundred milliseconds or something I

01:02:58,460 --> 01:03:04,220
bounced it and it was still fine it's

01:03:01,430 --> 01:03:06,260
pretty fast in fact I have a little show

01:03:04,220 --> 01:03:11,839
timing here I think that'll work

01:03:06,260 --> 01:03:15,980
we'll see yeah this is way harder to see

01:03:11,839 --> 01:03:17,119
than I thought it would be all right I'm

01:03:15,980 --> 01:03:21,140
not gonna mess with that I can't I can't

01:03:17,119 --> 01:03:24,380
find the scrollbar okay so let's look at

01:03:21,140 --> 01:03:26,630
some other demos so the cool thing about

01:03:24,380 --> 01:03:29,900
that previous demo is that it's a it's

01:03:26,630 --> 01:03:31,730
compiling and it's just producing

01:03:29,900 --> 01:03:34,160
assembly output right but we can also

01:03:31,730 --> 01:03:35,630
run remember that was what that foo has

01:03:34,160 --> 01:03:37,549
and was doing so we can take our code

01:03:35,630 --> 01:03:40,970
and we can compile so you can see this

01:03:37,549 --> 01:03:48,549
is actually compiling clang and then

01:03:40,970 --> 01:03:48,549
it's compiling LD and that it runs right

01:03:51,819 --> 01:03:58,659
so of course we can you know whoops oh

01:03:54,219 --> 01:04:00,249
yeah this is I really need a and so you

01:03:58,659 --> 01:04:02,319
can see the second time it's a little

01:04:00,249 --> 01:04:06,669
bit faster okay so clearly my scroll bar

01:04:02,319 --> 01:04:08,939
is not moving with me but you can see

01:04:06,669 --> 01:04:15,729
there okay

01:04:08,939 --> 01:04:19,630
I'm gonna actually close this and reopen

01:04:15,729 --> 01:04:20,949
it okay I actually also added some local

01:04:19,630 --> 01:04:22,689
storage here so you can see that it

01:04:20,949 --> 01:04:25,929
keeps that this again just sort of a

01:04:22,689 --> 01:04:28,509
nice compiler Explorer feature so you

01:04:25,929 --> 01:04:31,479
can see this stuff there okay so let's

01:04:28,509 --> 01:04:34,899
see oh my goodness

01:04:31,479 --> 01:04:36,929
okay so there's an example I dropped in

01:04:34,899 --> 01:04:39,909
the compile time regular expression

01:04:36,929 --> 01:04:44,229
header so I just sort of put it in

01:04:39,909 --> 01:04:48,209
include so yeah I'm sure it's fine and

01:04:44,229 --> 01:04:54,099
so you can see here if I compile it

01:04:48,209 --> 01:04:55,630
should all compile and work okay so this

01:04:54,099 --> 01:04:57,009
doesn't actually do anything because all

01:04:55,630 --> 01:04:58,479
it's doing is the static assert down

01:04:57,009 --> 01:05:00,339
here but you can see that it actually

01:04:58,479 --> 01:05:05,199
does work so if I change this to like

01:05:00,339 --> 01:05:06,249
you know 2017 yeah so it gives me an

01:05:05,199 --> 01:05:08,529
error here

01:05:06,249 --> 01:05:10,509
static assert failed and you can see

01:05:08,529 --> 01:05:11,859
it's actually pretty fast right I mean I

01:05:10,509 --> 01:05:13,569
don't know this isn't doing a whole lot

01:05:11,859 --> 01:05:16,709
of work but I think it's pretty cool

01:05:13,569 --> 01:05:19,449
that it's like you know pretty zippy

01:05:16,709 --> 01:05:21,039
okay so that's compile time regular

01:05:19,449 --> 01:05:23,380
expressions

01:05:21,039 --> 01:05:24,849
okay so here's some silly stuff that I

01:05:23,380 --> 01:05:26,619
was playing around with so you can see

01:05:24,849 --> 01:05:33,969
some some lambdas here and things like

01:05:26,619 --> 01:05:36,249
that okay that's too too big actually I

01:05:33,969 --> 01:05:37,869
can just change it let's change that to

01:05:36,249 --> 01:05:39,249
be a little smaller so I added some

01:05:37,869 --> 01:05:43,599
stuff where you can like you know draw

01:05:39,249 --> 01:05:46,569
tree and draw diamond and yeah ASCII art

01:05:43,599 --> 01:05:49,059
right it's cool kids are into it

01:05:46,569 --> 01:05:50,739
actually the kids are into it I I asked

01:05:49,059 --> 01:05:52,329
them to do an assignment where they drew

01:05:50,739 --> 01:05:57,699
stuff with asking art and they were like

01:05:52,329 --> 01:06:00,369
they had a lot of fun doing that yeah so

01:05:57,699 --> 01:06:04,980
anyway just a silly little thing that I

01:06:00,369 --> 01:06:10,750
that I wrote up okay so that's shapes

01:06:04,980 --> 01:06:14,050
let's see alright of course we need to

01:06:10,750 --> 01:06:19,780
do our Mandelbrot Mandal bro fractals

01:06:14,050 --> 01:06:20,920
okay so that's let's see if I can make

01:06:19,780 --> 01:06:28,360
that a little smaller there you go

01:06:20,920 --> 01:06:29,590
yeah so there's an ASCII art so that's

01:06:28,360 --> 01:06:32,130
pretty cool

01:06:29,590 --> 01:06:34,210
you can you know zoom in and stuff

01:06:32,130 --> 01:06:36,700
that's probably not a great place to

01:06:34,210 --> 01:06:38,680
zoom in but you can see so it's not

01:06:36,700 --> 01:06:43,290
super fast but it's I think it's fast

01:06:38,680 --> 01:06:49,660
enough okay

01:06:43,290 --> 01:06:53,080
but of course ASCII art is like not the

01:06:49,660 --> 01:06:57,430
only thing you can do so I took a small

01:06:53,080 --> 01:07:00,460
PT which is a small path tracer by Kevin

01:06:57,430 --> 01:07:03,540
Beeson and I made some tweaks to it and

01:07:00,460 --> 01:07:05,560
of course added a canvas and let's see

01:07:03,540 --> 01:07:08,830
so actually I'll leave it here for now

01:07:05,560 --> 01:07:12,610
so we can see it running so it's it's

01:07:08,830 --> 01:07:20,560
running you can see it's it like you

01:07:12,610 --> 01:07:26,230
know wait for it okay so says it's done

01:07:20,560 --> 01:07:28,650
let's see what we got yeah so that's

01:07:26,230 --> 01:07:28,650
pretty cool

01:07:29,480 --> 01:07:35,130
so what's cool about this actually is

01:07:31,799 --> 01:07:36,930
that it's using the browsers canvas to

01:07:35,130 --> 01:07:39,750
do this I basically just wired up

01:07:36,930 --> 01:07:42,029
imports so that you get all the features

01:07:39,750 --> 01:07:44,880
of the JavaScript canvas but you can

01:07:42,029 --> 01:07:47,339
access it via C++ so you can take a look

01:07:44,880 --> 01:07:49,349
at the code down here I made this like

01:07:47,339 --> 01:07:51,420
little canvas class and then an image

01:07:49,349 --> 01:07:53,069
data and then you can write in the data

01:07:51,420 --> 01:07:54,660
and then do commit commit basically

01:07:53,069 --> 01:07:57,960
takes that data and then copies it out

01:07:54,660 --> 01:07:59,940
into JavaScript and then you can do put

01:07:57,960 --> 01:08:02,759
image data which is exactly the same

01:07:59,940 --> 01:08:03,829
name as it is in JavaScript and and draw

01:08:02,759 --> 01:08:12,359
it

01:08:03,829 --> 01:08:14,430
alright so that's an example oh yeah so

01:08:12,359 --> 01:08:17,429
then here's an example of something that

01:08:14,430 --> 01:08:20,429
I actually ported I originally wrote

01:08:17,429 --> 01:08:23,159
this in in raw web assembly but then I

01:08:20,429 --> 01:08:27,299
decided well why not port this to C++

01:08:23,159 --> 01:08:29,989
for the talk so this is a meta ball so

01:08:27,299 --> 01:08:32,639
let's see if this works yeah there we go

01:08:29,989 --> 01:08:36,569
so this actually does something a little

01:08:32,639 --> 01:08:38,310
bit sneaky I guess I'll say is that

01:08:36,569 --> 01:08:40,889
there's actually a set up function and a

01:08:38,310 --> 01:08:44,120
loop function the set up function is

01:08:40,889 --> 01:08:48,330
called from main and then main exits and

01:08:44,120 --> 01:08:50,370
then loop is called intermittently to

01:08:48,330 --> 01:08:54,659
update the frame and the way that works

01:08:50,370 --> 01:08:56,580
is actually I I actually throw an

01:08:54,659 --> 01:08:58,799
exception so that it doesn't clean up

01:08:56,580 --> 01:09:02,100
any of the data so that I can still

01:08:58,799 --> 01:09:05,069
access everything after so that's a

01:09:02,100 --> 01:09:06,480
that's a super nasty hack and there will

01:09:05,069 --> 01:09:08,580
be a better solution this for this in

01:09:06,480 --> 01:09:10,949
the future but for now I realized this

01:09:08,580 --> 01:09:13,080
in my hotel like yesterday that I was

01:09:10,949 --> 01:09:15,540
like wait this doesn't actually work so

01:09:13,080 --> 01:09:16,859
I had to I had to like fix that but

01:09:15,540 --> 01:09:22,799
anyway so that's a that's a fun little

01:09:16,859 --> 01:09:28,710
demo old-school metaball demo okay and

01:09:22,799 --> 01:09:32,819
then here's everyone's favorite the doom

01:09:28,710 --> 01:09:35,790
fire effect I basically got the code

01:09:32,819 --> 01:09:38,609
from a fabian Sinclair's book excellent

01:09:35,790 --> 01:09:40,710
book by the way and you can actually see

01:09:38,609 --> 01:09:42,929
that the code it creates such a good

01:09:40,710 --> 01:09:44,789
effect and the the code is

01:09:42,929 --> 01:09:47,039
really simple you can see it's just like

01:09:44,789 --> 01:09:49,799
this is the entire loop that that does

01:09:47,039 --> 01:09:51,959
it and you know because this is CPP con

01:09:49,799 --> 01:09:56,639
I'm using the seatpost bus random

01:09:51,959 --> 01:09:57,900
functions I copied those from CPP

01:09:56,639 --> 01:10:03,630
reference because I do not know how to

01:09:57,900 --> 01:10:07,670
write it otherwise okay last one that I

01:10:03,630 --> 01:10:13,229
wanted to try and do I wanted to try and

01:10:07,670 --> 01:10:15,599
work with you all okay so this is this

01:10:13,229 --> 01:10:17,519
is my little starter code that I wanted

01:10:15,599 --> 01:10:19,139
to start with it's just doing something

01:10:17,519 --> 01:10:22,199
simple right now it takes the image data

01:10:19,139 --> 01:10:24,179
it draws a little pattern here it puts

01:10:22,199 --> 01:10:25,679
it out and then you can see that the

01:10:24,179 --> 01:10:28,590
code here or at least I hope you can see

01:10:25,679 --> 01:10:30,030
it you can change the fill style and you

01:10:28,590 --> 01:10:31,619
can change the font and you can change

01:10:30,030 --> 01:10:35,550
the text here and then it's actually

01:10:31,619 --> 01:10:40,260
centering the text okay so if I get rid

01:10:35,550 --> 01:10:46,130
of this I really should have practiced

01:10:40,260 --> 01:10:49,079
this okay I can change this to CPP con

01:10:46,130 --> 01:10:53,309
and I should see that and I can do

01:10:49,079 --> 01:10:59,219
something like how does this work set

01:10:53,309 --> 01:11:02,880
fill style to black and I can do fill

01:10:59,219 --> 01:11:07,619
wrecked mmm

01:11:02,880 --> 01:11:09,989
with height I think okay that works

01:11:07,619 --> 01:11:17,179
and then I can make a little function

01:11:09,989 --> 01:11:17,179
like draw and I can take that here I

01:11:18,679 --> 01:11:27,469
don't want to Center it anymore so let's

01:11:21,570 --> 01:11:27,469
do that and

01:11:29,750 --> 01:11:35,600
I think I can do this this is great like

01:11:33,920 --> 01:11:42,020
I'm sure that all of you are like

01:11:35,600 --> 01:11:46,449
looking like you forgot a semicolon okay

01:11:42,020 --> 01:11:50,320
so I think this is looking okay yeah

01:11:46,449 --> 01:11:54,590
let's make that a little bit smaller

01:11:50,320 --> 01:12:02,090
cool and now we can do other nasty

01:11:54,590 --> 01:12:05,480
things like this global variables and

01:12:02,090 --> 01:12:09,170
we'll just do something like that and

01:12:05,480 --> 01:12:12,250
we'll start this off here this is way

01:12:09,170 --> 01:12:12,250
harder than I thought it was gonna be

01:12:15,190 --> 01:12:19,940
okay so that's not doing anything yet

01:12:17,630 --> 01:12:31,520
but of course I can do actually let's

01:12:19,940 --> 01:12:35,170
make these doubles I still have time is

01:12:31,520 --> 01:12:35,170
that a plus oh my gosh

01:12:36,110 --> 01:12:42,090
okay so we should be able to run that

01:12:39,420 --> 01:12:43,800
and see okay it's starting to move okay

01:12:42,090 --> 01:12:47,700
and of course we want to multiply this

01:12:43,800 --> 01:12:48,810
by our elapsed I think that might be too

01:12:47,700 --> 01:12:55,020
slow

01:12:48,810 --> 01:13:01,200
yeah so let's do that it's a little

01:12:55,020 --> 01:13:03,810
faster okay that's better we can say if

01:13:01,200 --> 01:13:11,640
X is greater than with - I mean I don't

01:13:03,810 --> 01:13:18,960
know or X is less than zero then we'll

01:13:11,640 --> 01:13:25,350
just turn it around why did I decide to

01:13:18,960 --> 01:13:27,450
do this I hope y'all are still enjoying

01:13:25,350 --> 01:13:38,730
this cuz right at this point I'm just

01:13:27,450 --> 01:13:42,290
coding I don't know okay it's got to be

01:13:38,730 --> 01:13:42,290
faster than this we can't wait

01:13:48,240 --> 01:13:58,180
yeah so the problem is I don't know if

01:13:56,830 --> 01:14:01,270
this is actually gonna be able to hit a

01:13:58,180 --> 01:14:07,380
corner which is I know what we all want

01:14:01,270 --> 01:14:11,140
anyway okay yeah so so then that was fun

01:14:07,380 --> 01:14:14,380
okay did I have anything else that I was

01:14:11,140 --> 01:14:15,610
gonna do I don't think so okay back to

01:14:14,380 --> 01:14:18,400
the slides back to the sides

01:14:15,610 --> 01:14:28,930
thank you thank you for thank you for

01:14:18,400 --> 01:14:30,150
indulging me okay yes almost out of time

01:14:28,930 --> 01:14:34,900
okay

01:14:30,150 --> 01:14:36,990
does my clicker still work no that's

01:14:34,900 --> 01:14:40,450
fine

01:14:36,990 --> 01:14:43,870
does anything still work yes okay so

01:14:40,450 --> 01:14:49,390
technical limitations of of this

01:14:43,870 --> 01:14:52,870
prototype first off reading input

01:14:49,390 --> 01:14:55,090
blocking calls co-routines okay so one

01:14:52,870 --> 01:14:56,770
of the problems with running on the web

01:14:55,090 --> 01:14:58,690
is that the web doesn't want a block

01:14:56,770 --> 01:15:01,300
right everything is asynchronous and so

01:14:58,690 --> 01:15:04,090
if you try and do something like C in or

01:15:01,300 --> 01:15:05,170
reading from from the network or

01:15:04,090 --> 01:15:08,680
anything like that where you need to

01:15:05,170 --> 01:15:13,600
block it's just not going to work there

01:15:08,680 --> 01:15:18,580
is a way to do this by transforming your

01:15:13,600 --> 01:15:19,780
code so Alonza kai the author of whom

01:15:18,580 --> 01:15:22,330
scripting actually added a feature

01:15:19,780 --> 01:15:25,120
called async of phi i think it's called

01:15:22,330 --> 01:15:28,330
and he gave a talk about it I think two

01:15:25,120 --> 01:15:30,700
days ago actually where he goes into

01:15:28,330 --> 01:15:32,410
details about how you can convert a code

01:15:30,700 --> 01:15:34,990
that does do blocking into sort of like

01:15:32,410 --> 01:15:38,950
maintaining and sort of unwinding and

01:15:34,990 --> 01:15:42,340
rewinding the stack so that's a good

01:15:38,950 --> 01:15:44,320
tool based solution but there's also in

01:15:42,340 --> 01:15:46,000
the future we're going to have solutions

01:15:44,320 --> 01:15:47,860
for this using the exception handing

01:15:46,000 --> 01:15:50,920
proposal to provide something like

01:15:47,860 --> 01:15:55,240
delimited continuations so watch this

01:15:50,920 --> 01:15:57,010
space for the future exceptions as I

01:15:55,240 --> 01:15:58,990
mentioned before exceptions are not

01:15:57,010 --> 01:16:00,080
currently supported I think if you tried

01:15:58,990 --> 01:16:05,350
to throw an exception it

01:16:00,080 --> 01:16:06,950
just abort but this is again a proposal

01:16:05,350 --> 01:16:08,960
for webassembly

01:16:06,950 --> 01:16:11,030
we were actively working on it we're

01:16:08,960 --> 01:16:12,980
gonna add this feature I hope very very

01:16:11,030 --> 01:16:14,930
soon

01:16:12,980 --> 01:16:17,510
threads and Atomics I mentioned this

01:16:14,930 --> 01:16:22,280
before but it's just not currently in

01:16:17,510 --> 01:16:24,860
the in the in the tool we're working on

01:16:22,280 --> 01:16:26,630
it there's a proposal I'm actually the

01:16:24,860 --> 01:16:28,310
champion of the the proposal and I'd

01:16:26,630 --> 01:16:31,910
really like to see it move forward we

01:16:28,310 --> 01:16:34,040
have an implementation in Chrome but the

01:16:31,910 --> 01:16:38,930
the spec is a little bit further behind

01:16:34,040 --> 01:16:41,060
so just some quick links if you're

01:16:38,930 --> 01:16:43,880
interested in web assembly you want to

01:16:41,060 --> 01:16:46,070
come to the meetings they are open it's

01:16:43,880 --> 01:16:48,410
a web assembly community group you can

01:16:46,070 --> 01:16:50,240
go to meetings and you can see all the

01:16:48,410 --> 01:16:51,470
notes from our previous meetings if

01:16:50,240 --> 01:16:53,120
you're curious about the future

01:16:51,470 --> 01:16:54,530
proposals go to web assembly proposals

01:16:53,120 --> 01:16:57,440
there's a huge list of them the

01:16:54,530 --> 01:16:59,510
champions and their current stages if

01:16:57,440 --> 01:17:01,670
you want to read the spec there's this

01:16:59,510 --> 01:17:03,980
link here if you're interested in y'see

01:17:01,670 --> 01:17:06,170
go to huazi dev of course I'm scripting

01:17:03,980 --> 01:17:09,230
now org and then this demo that I just

01:17:06,170 --> 01:17:14,090
showed you is right there at Benjie

01:17:09,230 --> 01:17:17,360
github iOS and clang yeah it's very

01:17:14,090 --> 01:17:23,800
alpha so you know do it with what you

01:17:17,360 --> 01:17:23,800
will and that's it thank you

01:17:30,219 --> 01:17:37,360
I have 11 minutes so if people have

01:17:33,880 --> 01:17:42,039
questions I have answers or I have

01:17:37,360 --> 01:17:44,349
dodges hi thanks for the talk

01:17:42,039 --> 01:17:46,389
thank you at the very end emotion that

01:17:44,349 --> 01:17:50,349
exceptions are not supported and by that

01:17:46,389 --> 01:17:52,179
amended exceptions in in webassembly are

01:17:50,349 --> 01:17:55,719
not supported their exception in the

01:17:52,179 --> 01:17:57,249
compiler which targets the C++ compiler

01:17:55,719 --> 01:18:02,079
which targets webassembly all supported

01:17:57,249 --> 01:18:03,610
or both yes so the question is I I said

01:18:02,079 --> 01:18:06,579
that exceptions are not supported what

01:18:03,610 --> 01:18:08,260
did I mean and the answer is yes so

01:18:06,579 --> 01:18:11,260
obviously exceptions are supported in

01:18:08,260 --> 01:18:13,090
clang you can use them they will be

01:18:11,260 --> 01:18:17,380
compiled but they will could be compiled

01:18:13,090 --> 01:18:20,229
into an abort currently in my

01:18:17,380 --> 01:18:23,829
implementation of this in the future we

01:18:20,229 --> 01:18:27,309
there's active work adding exception

01:18:23,829 --> 01:18:30,760
support to LVM I think it's pretty much

01:18:27,309 --> 01:18:32,559
there but don't quote me on that and at

01:18:30,760 --> 01:18:34,809
that point you should be able to use it

01:18:32,559 --> 01:18:37,809
to compile to web assembly using the new

01:18:34,809 --> 01:18:39,429
exceptions proposal and then then be

01:18:37,809 --> 01:18:41,849
able to run that in web assembly as well

01:18:39,429 --> 01:18:45,340
it does that answer your question

01:18:41,849 --> 01:18:49,269
so if I compute exceptions called the

01:18:45,340 --> 01:18:52,659
Teelin success yes will with the board

01:18:49,269 --> 01:18:55,679
it'll it'll run but it old board if you

01:18:52,659 --> 01:18:58,900
throw currently yes but in the future it

01:18:55,679 --> 01:19:01,329
and if you use them script in it

01:18:58,900 --> 01:19:04,389
actually like I says turns exceptions

01:19:01,329 --> 01:19:06,459
into a thunk out and a thunk back and so

01:19:04,389 --> 01:19:08,530
those that actually will work but that's

01:19:06,459 --> 01:19:11,579
sort of a stopgap until we actually have

01:19:08,530 --> 01:19:13,889
the full support okay thanks thank you

01:19:11,579 --> 01:19:17,439
alright Ben you mentioned this

01:19:13,889 --> 01:19:19,300
workaround I guess for the fact that in

01:19:17,439 --> 01:19:21,670
webassembly you can't share memory

01:19:19,300 --> 01:19:23,619
between different modules yeah and I go

01:19:21,670 --> 01:19:26,860
back to JavaScript inheritance so are

01:19:23,619 --> 01:19:29,320
there plans to loosen that limitation so

01:19:26,860 --> 01:19:32,769
it doesn't feel so happy yeah there are

01:19:29,320 --> 01:19:35,139
plans to reduce that it's actually the

01:19:32,769 --> 01:19:37,090
the binary format is extensible to this

01:19:35,139 --> 01:19:39,189
point where you we could actually add

01:19:37,090 --> 01:19:41,530
support for multiple memories we

01:19:39,189 --> 01:19:42,409
currently just have a limitation there's

01:19:41,530 --> 01:19:44,260
no

01:19:42,409 --> 01:19:47,300
proposal about adding multiple memories

01:19:44,260 --> 01:19:48,350
but it's we've talked about it a lot for

01:19:47,300 --> 01:19:52,639
exactly this reason

01:19:48,350 --> 01:19:56,120
yeah so in this slide of yours with the

01:19:52,639 --> 01:20:01,520
memory map I don't see a code section so

01:19:56,120 --> 01:20:03,920
how do function corners work yes member

01:20:01,520 --> 01:20:06,409
functions member function partners with

01:20:03,920 --> 01:20:08,900
yes so the question is how do functional

01:20:06,409 --> 01:20:11,090
Earth yeah I kind of glossed over that

01:20:08,900 --> 01:20:13,880
entirely they do work there's a separate

01:20:11,090 --> 01:20:17,409
structure called a table that does that

01:20:13,880 --> 01:20:20,360
the idea of the table is that it stores

01:20:17,409 --> 01:20:22,929
anything that's a reference that is not

01:20:20,360 --> 01:20:25,760
like raw date raw date I like raw bytes

01:20:22,929 --> 01:20:27,949
and so currently that's only used for

01:20:25,760 --> 01:20:29,870
functions you can basically there's an

01:20:27,949 --> 01:20:31,730
instruction called call indirect that

01:20:29,870 --> 01:20:33,429
will take an index and then index into

01:20:31,730 --> 01:20:36,020
that table and then call that function

01:20:33,429 --> 01:20:37,760
and it's in its type safe so you have to

01:20:36,020 --> 01:20:39,830
provide the type signature as well in

01:20:37,760 --> 01:20:41,060
the future actually very very soon we're

01:20:39,830 --> 01:20:43,280
going to have features where you can

01:20:41,060 --> 01:20:44,750
take any number of tables and you can

01:20:43,280 --> 01:20:46,790
store other data in them as well as

01:20:44,750 --> 01:20:48,110
opaque handles that's so that way you

01:20:46,790 --> 01:20:50,780
could actually take a JavaScript object

01:20:48,110 --> 01:20:54,260
store it in a table and then reference

01:20:50,780 --> 01:20:56,780
it from from web assembly so so tables

01:20:54,260 --> 01:20:59,900
are sort of the our mechanism for

01:20:56,780 --> 01:21:01,429
dealing with objects like data object

01:20:59,900 --> 01:21:06,440
meaning like JavaScript objects are like

01:21:01,429 --> 01:21:09,409
host object yeah thank you a question hi

01:21:06,440 --> 01:21:10,820
so it was a little bit painful watching

01:21:09,409 --> 01:21:12,110
your talk not because of your talk but

01:21:10,820 --> 01:21:14,179
because you went through a lot of the

01:21:12,110 --> 01:21:16,520
things that we went through so we have

01:21:14,179 --> 01:21:19,429
this project called browse --ax yes

01:21:16,520 --> 01:21:22,130
basically everything that you your thing

01:21:19,429 --> 01:21:23,960
does but it also has more yeah you can

01:21:22,130 --> 01:21:25,909
do synchronous i/o you can do

01:21:23,960 --> 01:21:29,510
synchronous i/o from a file system

01:21:25,909 --> 01:21:31,580
that's mounted over HTTP right it's it's

01:21:29,510 --> 01:21:33,350
quite general we just ported it forwards

01:21:31,580 --> 01:21:36,650
to to wowza

01:21:33,350 --> 01:21:38,900
recently so if people are interested in

01:21:36,650 --> 01:21:39,530
using something that may make this job a

01:21:38,900 --> 01:21:42,739
little easier

01:21:39,530 --> 01:21:45,260
it supports almost all of POSIX and it

01:21:42,739 --> 01:21:47,980
actually supports multiple processes IPC

01:21:45,260 --> 01:21:50,360
all kinds of stuff yeah yeah so

01:21:47,980 --> 01:21:51,739
basically just saying browse like is

01:21:50,360 --> 01:21:53,060
something that does something very

01:21:51,739 --> 01:21:54,980
similar I'm sorry I didn't mention

01:21:53,060 --> 01:21:55,969
actually knew about browse X it's very

01:21:54,980 --> 01:21:58,640
very cool too

01:21:55,969 --> 01:22:00,140
to to do that sort of stuff again yeah

01:21:58,640 --> 01:22:02,170
running that all on the web yeah thank

01:22:00,140 --> 01:22:02,170
you

01:22:02,620 --> 01:22:08,770
does your project run on Firefox it does

01:22:06,830 --> 01:22:11,030
run on Firefox I test it on on firefox

01:22:08,770 --> 01:22:14,180
there was one issue that I ran into

01:22:11,030 --> 01:22:16,130
which is that the the canvas feature

01:22:14,180 --> 01:22:18,530
that I use actually relies on off-screen

01:22:16,130 --> 01:22:20,690
canvas which is supported in Firefox but

01:22:18,530 --> 01:22:22,130
it's behind a flag currently so if you

01:22:20,690 --> 01:22:23,660
try and load that up in Firefox it

01:22:22,130 --> 01:22:26,449
currently I think will print an error

01:22:23,660 --> 01:22:29,199
message but if as soon as poss screen

01:22:26,449 --> 01:22:32,690
canvas is supported then it should work

01:22:29,199 --> 01:22:36,350
all that stuff I tried it thank you

01:22:32,690 --> 01:22:39,890
yeah hello I actually have two questions

01:22:36,350 --> 01:22:42,050
if that's okay the first one is why is

01:22:39,890 --> 01:22:44,989
webassembly advertised as 32 bits

01:22:42,050 --> 01:22:47,750
targets and are there plans in creating

01:22:44,989 --> 01:22:51,949
a 64-bit version of the same way uh-huh

01:22:47,750 --> 01:22:55,670
yeah so the question is why is

01:22:51,949 --> 01:22:57,890
webassembly 32 bit yeah it's a good

01:22:55,670 --> 01:23:01,370
question I think originally it was

01:22:57,890 --> 01:23:04,760
because we figured that was all we would

01:23:01,370 --> 01:23:06,830
need for to get a lot of a lot of the at

01:23:04,760 --> 01:23:09,800
work that we needed to get done done we

01:23:06,830 --> 01:23:11,630
always had plans for Assam 64 but as of

01:23:09,800 --> 01:23:14,719
now that's currently vaporware I think

01:23:11,630 --> 01:23:18,290
if you look at LVM there is wasm 64

01:23:14,719 --> 01:23:20,719
target that could work maybe I don't

01:23:18,290 --> 01:23:22,760
think there are any implementations the

01:23:20,719 --> 01:23:25,250
way that you could extend wasman 32 to

01:23:22,760 --> 01:23:27,730
Assam 64 like in our heads we've sort of

01:23:25,250 --> 01:23:30,440
gone like well it should just work right

01:23:27,730 --> 01:23:31,790
but yeah it's it's not it's not clear it

01:23:30,440 --> 01:23:33,770
would be a different binary format as

01:23:31,790 --> 01:23:36,380
well so there definitely some issues

01:23:33,770 --> 01:23:39,530
there yes okay thank you and the second

01:23:36,380 --> 01:23:41,330
question is how this actually was

01:23:39,530 --> 01:23:43,550
different from the aim scooter because

01:23:41,330 --> 01:23:46,610
on your slides you'll have shown how you

01:23:43,550 --> 01:23:48,770
implemented most of the POSIX functions

01:23:46,610 --> 01:23:52,040
which are already implemented in X

01:23:48,770 --> 01:23:54,290
scripted so I'm curious to know why you

01:23:52,040 --> 01:23:56,900
didn't use that and what's actually the

01:23:54,290 --> 01:23:59,230
benefits of using the way was it

01:23:56,900 --> 01:24:01,730
directly uh yeah okay so the question is

01:23:59,230 --> 01:24:03,050
why didn't I use the Emscripten versions

01:24:01,730 --> 01:24:06,949
I mean part of it was just because I

01:24:03,050 --> 01:24:08,810
wanted to talk about you know how this

01:24:06,949 --> 01:24:09,769
is implemented if I just using scripting

01:24:08,810 --> 01:24:11,900
I'd have to sort of say

01:24:09,769 --> 01:24:14,570
well I'm scripting does this and I don't

01:24:11,900 --> 01:24:18,079
really understand that code but also

01:24:14,570 --> 01:24:19,760
because yeah I don't know yeah mostly

01:24:18,079 --> 01:24:22,480
that's the reason okay thank you very

01:24:19,760 --> 01:24:22,480
much yeah thank you

01:24:25,239 --> 01:24:33,829
you mentioned that the web assembly is

01:24:29,989 --> 01:24:34,670
typed so yeah you have you push an int

01:24:33,829 --> 01:24:38,960
01:24:34,670 --> 01:24:44,150
to the stack and everything does when

01:24:38,960 --> 01:24:46,789
you compile C++ code do the types on C++

01:24:44,150 --> 01:24:49,760
get translated into a type from web

01:24:46,789 --> 01:24:53,179
assembly or are those just the native

01:24:49,760 --> 01:24:56,539
types yeah so the question is web

01:24:53,179 --> 01:24:58,190
assembly is typed does do C++ types get

01:24:56,539 --> 01:24:58,639
converted into web assembly types is

01:24:58,190 --> 01:25:01,820
that right

01:24:58,639 --> 01:25:03,949
yes yeah so the answer is that it does

01:25:01,820 --> 01:25:08,150
in a sense it's very similar the way

01:25:03,949 --> 01:25:09,769
that LVM will lower to lv miR except for

01:25:08,150 --> 01:25:12,619
it's even lower than that because I

01:25:09,769 --> 01:25:14,869
think L V Mir has pointer types and

01:25:12,619 --> 01:25:18,739
things like that and in webassembly

01:25:14,869 --> 01:25:21,139
pointers are just 32-bit integers so it

01:25:18,739 --> 01:25:23,300
really is just an index into into linear

01:25:21,139 --> 01:25:26,749
memory into the untrusted memory space

01:25:23,300 --> 01:25:28,639
so the types are all basically lost at

01:25:26,749 --> 01:25:31,940
that point by the time you compile to

01:25:28,639 --> 01:25:34,099
webassembly the high higher types of c++

01:25:31,940 --> 01:25:35,510
are lost and they're converted into the

01:25:34,099 --> 01:25:39,289
lower types of web assembly which

01:25:35,510 --> 01:25:44,119
currently just is in 32 in 64 float32

01:25:39,289 --> 01:25:46,150
float 64 and that's it okay yeah thank

01:25:44,119 --> 01:25:46,150
you

01:25:46,389 --> 01:25:52,849
since web assembly has some protection

01:25:48,829 --> 01:25:54,710
against array out of bounds accesses and

01:25:52,849 --> 01:25:57,860
things like that what happens if you do

01:25:54,710 --> 01:25:59,510
that in your C++ code yeah okay so the

01:25:57,860 --> 01:26:02,420
question is what happens if you try and

01:25:59,510 --> 01:26:03,469
access out of bounds in C++ code so the

01:26:02,420 --> 01:26:05,599
first thing I should mention is

01:26:03,469 --> 01:26:06,769
accessing out of bounds if you have an

01:26:05,599 --> 01:26:10,219
array and you access that out of bounds

01:26:06,769 --> 01:26:12,619
that probably will work right because we

01:26:10,219 --> 01:26:14,179
just have a big bag of bytes right and

01:26:12,619 --> 01:26:15,829
if you have an array that starts here

01:26:14,179 --> 01:26:17,360
and ends here and you access outside

01:26:15,829 --> 01:26:18,440
you're just gonna access some other data

01:26:17,360 --> 01:26:20,449
just like you couldn't see you pose plus

01:26:18,440 --> 01:26:22,640
now if you access something that's

01:26:20,449 --> 01:26:25,430
completely outside of memory what

01:26:22,640 --> 01:26:28,760
happen as a trap and trap is sort of

01:26:25,430 --> 01:26:31,280
like the equivalent of yeah like a a

01:26:28,760 --> 01:26:33,500
segfault or something except for you can

01:26:31,280 --> 01:26:35,750
catch it in JavaScript and then do

01:26:33,500 --> 01:26:38,210
something with it so there are a number

01:26:35,750 --> 01:26:39,530
of different traps dividing by zero if

01:26:38,210 --> 01:26:41,210
you try and do a call indirect and the

01:26:39,530 --> 01:26:43,250
type signature doesn't match that's

01:26:41,210 --> 01:26:45,410
actually a runtime check so that's a

01:26:43,250 --> 01:26:47,420
trap as well there's other other traps

01:26:45,410 --> 01:26:50,330
as well so thank you

01:26:47,420 --> 01:26:54,500
the question is can can do have any way

01:26:50,330 --> 01:26:59,270
to debug code suppose code compile to

01:26:54,500 --> 01:27:00,830
but by simply in the classic way yeah so

01:26:59,270 --> 01:27:04,430
the question is how do you do bug the

01:27:00,830 --> 01:27:08,240
code and the answer is right now very

01:27:04,430 --> 01:27:10,700
carefully and in the future actually I

01:27:08,240 --> 01:27:13,220
think very soon there is a debugging

01:27:10,700 --> 01:27:14,990
subgroup of the web assembly group that

01:27:13,220 --> 01:27:17,450
is focused on this topic I think the

01:27:14,990 --> 01:27:22,010
idea will be that you you will have a

01:27:17,450 --> 01:27:23,720
separate module that has a everything

01:27:22,010 --> 01:27:27,650
went off okay you'll have a separate

01:27:23,720 --> 01:27:29,810
module that basically is intermediary

01:27:27,650 --> 01:27:33,260
between the web assembly environment and

01:27:29,810 --> 01:27:36,320
your executable and that will be able to

01:27:33,260 --> 01:27:39,710
handle the bugging for you so it will do

01:27:36,320 --> 01:27:42,430
something very similar to like I think

01:27:39,710 --> 01:27:44,900
in the browser if you're running like on

01:27:42,430 --> 01:27:47,900
what's that tool that the JetBrains

01:27:44,900 --> 01:27:50,240
browse debugger anyway when you're using

01:27:47,900 --> 01:27:53,300
that it communicates with the chrome dev

01:27:50,240 --> 01:27:54,560
tools to be able to do debugging it'll

01:27:53,300 --> 01:27:56,990
be something very similar to that but

01:27:54,560 --> 01:27:58,760
it'll be its own executable that it's

01:27:56,990 --> 01:28:01,040
running and doing the communication

01:27:58,760 --> 01:28:03,700
that's the current plan but as of now I

01:28:01,040 --> 01:28:06,500
don't think there's much there yet so

01:28:03,700 --> 01:28:09,350
yeah right now it's a lot of printf

01:28:06,500 --> 01:28:11,030
debugging but we do actually I should

01:28:09,350 --> 01:28:13,550
take a step back from that we do have

01:28:11,030 --> 01:28:17,300
some support inside dev tools in chrome

01:28:13,550 --> 01:28:19,430
and in Firefox that's limited but but

01:28:17,300 --> 01:28:22,640
not bad it'll give you stack traces with

01:28:19,430 --> 01:28:25,360
with actual C++ names and it but it will

01:28:22,640 --> 01:28:28,550
show you and it'll show you source lines

01:28:25,360 --> 01:28:36,010
but you can't actually inspect values as

01:28:28,550 --> 01:28:36,010
if you were C++ values so yeah thank you

01:28:36,090 --> 01:28:39,430
it looks like one more question and

01:28:38,590 --> 01:28:44,890
that's probably it

01:28:39,430 --> 01:28:50,920
so adding to that question you mentioned

01:28:44,890 --> 01:28:56,820
that you cannot alter the the exact

01:28:50,920 --> 01:29:01,510
table code yeah usually that's how the

01:28:56,820 --> 01:29:06,940
debugger servers work by putting a trap

01:29:01,510 --> 01:29:09,790
on that is there kind of a hardware way

01:29:06,940 --> 01:29:14,110
of doing that saying I want you two to

01:29:09,790 --> 01:29:17,080
trap when you get to this point the

01:29:14,110 --> 01:29:18,940
question is is is will you be able to

01:29:17,080 --> 01:29:21,100
modify the executable code to insert a

01:29:18,940 --> 01:29:22,990
like a breakpoint or something yeah yeah

01:29:21,100 --> 01:29:24,580
I I don't think that's gonna be the way

01:29:22,990 --> 01:29:26,860
it works I think it's probably gonna be

01:29:24,580 --> 01:29:29,290
something more like there's a

01:29:26,860 --> 01:29:30,790
communication protocol and so the web

01:29:29,290 --> 01:29:32,290
assembly engine already knows how to do

01:29:30,790 --> 01:29:33,820
all that stuff itself so you don't

01:29:32,290 --> 01:29:36,130
actually need to modify the executable

01:29:33,820 --> 01:29:37,810
code to do it that way we'll probably

01:29:36,130 --> 01:29:39,010
end up using the internal breakpoint

01:29:37,810 --> 01:29:41,980
structures that are already there for

01:29:39,010 --> 01:29:45,190
JavaScript so that's that's my guess

01:29:41,980 --> 01:29:51,130
yeah I was thinking more like if you

01:29:45,190 --> 01:29:56,850
could have a ported version of a gdb

01:29:51,130 --> 01:30:00,850
server or so you could do remote

01:29:56,850 --> 01:30:01,990
debugging well I'd like to talk to you

01:30:00,850 --> 01:30:04,960
more about this but the session is over

01:30:01,990 --> 01:30:09,689
so thank you everyone thank you

01:30:04,960 --> 01:30:09,689

YouTube URL: https://www.youtube.com/watch?v=5N4b-rU-OAA


