Title: CppCon 2019: Hyrum Wright Time Travel: Applying Gradual Typing to Time Types with Clang's LibTooling
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Libraries for C++ are constantly evolving, with new APIs being added, old ones being deprecated and functionality continually changing. In past CppCon talks, I've described in abstract how Google manages this change by applying large-scale changes across our C++ codebase using clang's libTooling infrastructure.

In this talk, we'll put this previous work in practice by demonstrating how we use clang-tidy and clang's libTooling library to improve type safety of time types across Google's 250M lines of C++. Using tools currently open sourced as part of clang-tidy, we'll show how the underlying model of time types allow us to migrate from a collection of integers and floating point types to the much more strongly typed `absl::Time` and `absl::Duration` types representing time instants and intervals. Along the way, we'll discover how this process finds existing bugs and prevents new ones from creeping in.

This "gradual typing" technique is not limited to just Time types, and we'll explore how this can be used to improve pointer ownership deduction and other places where more constraining types eliminate classes of bugs.
— 
Hyrum Wright
Google
Software Engineer

@hyrumwright"＞ Hyrum Wright hates C++ less than the rest of the programming languages he's worked with, and works on large-scale change infrastructure at Google. He writes programs to rewrite other programs, and will eventually put himself out of a job. In a former life, he was an author of Apache Subversion, and still retains membership in the Apache Software Foundation. Hyrum enjoys hiking and backpacking, but probably won't get out much while at CppCon. Twitter handle: @hyrumwright
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,310 --> 00:00:12,639
welcome to

00:00:10,840 --> 00:00:17,349
can't we talk about time travel gradual

00:00:12,639 --> 00:00:24,490
typing in C++ and I am sorry to

00:00:17,349 --> 00:00:26,529
disappoint but there we go we already

00:00:24,490 --> 00:00:30,040
have an existence proof that time travel

00:00:26,529 --> 00:00:30,910
isn't actually a thing right because

00:00:30,040 --> 00:00:32,200
we're a thing

00:00:30,910 --> 00:00:34,000
all those misconfigured time machines

00:00:32,200 --> 00:00:39,910
would have shown up at the beginning of

00:00:34,000 --> 00:00:42,640
the epoch right so like don't so sadly

00:00:39,910 --> 00:00:45,280
we're back to just gradual typing in C++

00:00:42,640 --> 00:00:48,340
so that's sorry if I misled you on this

00:00:45,280 --> 00:00:50,800
talk let me make a bold assertion at the

00:00:48,340 --> 00:00:53,380
beginning of this talk that C++ is a

00:00:50,800 --> 00:00:57,450
dynamically typed language how many

00:00:53,380 --> 00:01:00,760
people here believe this all right I see

00:00:57,450 --> 00:01:02,710
I also see your your battle scars right

00:01:00,760 --> 00:01:03,970
so I will weaken this assertion a little

00:01:02,710 --> 00:01:06,579
bit by saying that C was supposed to let

00:01:03,970 --> 00:01:09,640
you write to dynamically typed code okay

00:01:06,579 --> 00:01:11,140
so like the language itself may be

00:01:09,640 --> 00:01:13,780
statically typed like the language may

00:01:11,140 --> 00:01:16,539
do appropriate type checking for you but

00:01:13,780 --> 00:01:18,850
you can still defeat that in marvelous

00:01:16,539 --> 00:01:20,590
and wonderful ways right so let's start

00:01:18,850 --> 00:01:23,499
let's think about an example so if we

00:01:20,590 --> 00:01:24,969
want to have a simple string class right

00:01:23,499 --> 00:01:26,229
so the first thing here you see the word

00:01:24,969 --> 00:01:29,200
Union and you should also be like

00:01:26,229 --> 00:01:31,959
cringing right so this is a simple

00:01:29,200 --> 00:01:33,549
string class it uses the short string

00:01:31,959 --> 00:01:35,920
optimization right so in some cases we

00:01:33,549 --> 00:01:36,939
have like pointer plus length and but if

00:01:35,920 --> 00:01:39,249
we have a short string we want to keep

00:01:36,939 --> 00:01:42,279
that all in the same cache line so we

00:01:39,249 --> 00:01:43,600
have a buffer just to hold that right

00:01:42,279 --> 00:01:45,509
and of course the next thing we do is

00:01:43,600 --> 00:01:49,209
write an API that uses this thing right

00:01:45,509 --> 00:01:51,069
so s should always have data set right

00:01:49,209 --> 00:01:52,479
so like if you call this function you

00:01:51,069 --> 00:01:55,749
should always have this precondition met

00:01:52,479 --> 00:01:59,229
and like okay so the first thing someone

00:01:55,749 --> 00:02:00,549
will do is do this right they will call

00:01:59,229 --> 00:02:03,130
the function without the precondition

00:02:00,549 --> 00:02:04,990
being met okay like there's nothing in

00:02:03,130 --> 00:02:07,140
the language that prevents you from

00:02:04,990 --> 00:02:09,580
doing this

00:02:07,140 --> 00:02:11,440
right so like we're writing dynamically

00:02:09,580 --> 00:02:13,690
typed code in a statically typed

00:02:11,440 --> 00:02:16,450
language right because like this type up

00:02:13,690 --> 00:02:17,890
here this Union is dynamically fact it

00:02:16,450 --> 00:02:19,900
can be one thing or the other and this

00:02:17,890 --> 00:02:21,730
function except it expects you to pass

00:02:19,900 --> 00:02:23,010
one thing but you're instead passing the

00:02:21,730 --> 00:02:24,000
other so

00:02:23,010 --> 00:02:25,830
this is the point at which I am

00:02:24,000 --> 00:02:28,200
contractually obligated to point this

00:02:25,830 --> 00:02:29,459
out right this is hi arms law which I

00:02:28,200 --> 00:02:30,560
won't read it to you because enough

00:02:29,459 --> 00:02:32,400
people have done that this week already

00:02:30,560 --> 00:02:36,659
essentially it means that if someone can

00:02:32,400 --> 00:02:39,989
abuse your API they will okay again like

00:02:36,659 --> 00:02:41,640
this is should be fairly obvious to

00:02:39,989 --> 00:02:43,170
folks that maintain large enough systems

00:02:41,640 --> 00:02:45,690
that somebody is always going to be

00:02:43,170 --> 00:02:46,890
doing something that they like as long

00:02:45,690 --> 00:02:49,560
as they can they will be doing it

00:02:46,890 --> 00:02:52,049
trained so how do we prevent this right

00:02:49,560 --> 00:02:54,120
so okay like in this case maybe we add a

00:02:52,049 --> 00:02:55,680
struct that has the appropriate boolean

00:02:54,120 --> 00:02:57,569
flag and then we wrap it all up in a

00:02:55,680 --> 00:02:58,829
class and hide all that stuff from our

00:02:57,569 --> 00:03:00,030
user so that that way like we have a

00:02:58,829 --> 00:03:02,400
single class that we're passing around

00:03:00,030 --> 00:03:04,739
that maintains invariants and all of a

00:03:02,400 --> 00:03:06,180
sudden we can use the facilities of the

00:03:04,739 --> 00:03:11,720
language to get rid of this like

00:03:06,180 --> 00:03:15,780
dynamically typed code problem right so

00:03:11,720 --> 00:03:17,310
why do we have types right so we like it

00:03:15,780 --> 00:03:19,829
gives us this types and I would say that

00:03:17,310 --> 00:03:23,430
we have types because types essentially

00:03:19,829 --> 00:03:27,450
encode constraints right types are a way

00:03:23,430 --> 00:03:29,790
that allow us to encode limitations on

00:03:27,450 --> 00:03:34,560
what you can do with data or values in

00:03:29,790 --> 00:03:35,880
this in C++ right so if we didn't want

00:03:34,560 --> 00:03:37,560
to have any limitations everything would

00:03:35,880 --> 00:03:39,750
be an int or everything would be a charm

00:03:37,560 --> 00:03:41,579
right because like no limitations you

00:03:39,750 --> 00:03:44,370
can do anything you want there but the

00:03:41,579 --> 00:03:45,269
types restrict we can do they encode

00:03:44,370 --> 00:03:46,980
these constraints and that gives us a

00:03:45,269 --> 00:03:49,169
lot of power it gives us the ability of

00:03:46,980 --> 00:03:52,950
reason about higher order things in our

00:03:49,169 --> 00:03:55,470
in our software it lets the compiler

00:03:52,950 --> 00:03:57,090
reason about it and in other ways right

00:03:55,470 --> 00:03:58,560
these come in a cost if you watch

00:03:57,090 --> 00:03:59,880
Chandler's talk a couple weeks ago or a

00:03:58,560 --> 00:04:02,910
couple days ago all right these come at

00:03:59,880 --> 00:04:04,620
a cost and that cost as Titus pointed

00:04:02,910 --> 00:04:06,840
out a couple days ago as well is in

00:04:04,620 --> 00:04:10,049
refactor ability right so like we like

00:04:06,840 --> 00:04:11,459
types but because they give us these

00:04:10,049 --> 00:04:15,569
constraints but there is a cost but in

00:04:11,459 --> 00:04:16,919
most cases the costs outweigh or the

00:04:15,569 --> 00:04:19,620
benefits outweigh the costs and we're

00:04:16,919 --> 00:04:24,120
happy to use types so back to dynamic

00:04:19,620 --> 00:04:26,580
context software what is this audience

00:04:24,120 --> 00:04:28,470
participation time like what is this

00:04:26,580 --> 00:04:34,680
it's an integer like what does I

00:04:28,470 --> 00:04:36,810
represent number of horses okay right

00:04:34,680 --> 00:04:39,090
like it could I mean there's nothing

00:04:36,810 --> 00:04:41,250
that there's nothing in the language

00:04:39,090 --> 00:04:42,990
that prevents us from like using this in

00:04:41,250 --> 00:04:44,490
that way right it's just an integer

00:04:42,990 --> 00:04:47,220
there's no semantic information attached

00:04:44,490 --> 00:04:49,250
to I in this case what's that

00:04:47,220 --> 00:04:49,250
Oh

00:04:51,030 --> 00:04:54,330
could be negative right because like you

00:04:52,560 --> 00:04:55,470
know a number of horses it could be

00:04:54,330 --> 00:04:56,849
negative right well you know I mean

00:04:55,470 --> 00:04:57,090
they're imaginary horses so maybe I

00:04:56,849 --> 00:05:01,469
don't

00:04:57,090 --> 00:05:05,219
yeah so so anyway

00:05:01,469 --> 00:05:07,050
back off of horses um so we can rename

00:05:05,219 --> 00:05:08,310
this variable okay we rename it

00:05:07,050 --> 00:05:11,759
something like time out right maybe that

00:05:08,310 --> 00:05:14,849
make it may maybe that may give us more

00:05:11,759 --> 00:05:17,909
contextual information about what this

00:05:14,849 --> 00:05:19,889
means okay and if we're really good

00:05:17,909 --> 00:05:21,810
we'll even put a comment on it right

00:05:19,889 --> 00:05:27,659
expiration time any idea what this

00:05:21,810 --> 00:05:30,300
represents now number of horses number

00:05:27,659 --> 00:05:33,090
of horses in time out is the is the

00:05:30,300 --> 00:05:36,900
response I'm gonna stop listening to

00:05:33,090 --> 00:05:41,009
that half of the room okay what else any

00:05:36,900 --> 00:05:42,389
of their ideas whether or not you could

00:05:41,009 --> 00:05:43,259
hit the expiration time okay that

00:05:42,389 --> 00:05:46,080
statement is actually a boolean

00:05:43,259 --> 00:05:48,300
statement okay because whether or not is

00:05:46,080 --> 00:05:50,340
a boolean expression but yeah you could

00:05:48,300 --> 00:05:53,779
think about this as like the amount of

00:05:50,340 --> 00:05:56,879
time until some operation expires right

00:05:53,779 --> 00:05:58,400
or you could think about it as the time

00:05:56,879 --> 00:05:59,940
at which an operation should expire

00:05:58,400 --> 00:06:02,219
these are actually two different

00:05:59,940 --> 00:06:05,759
semantic concepts and yet we're using

00:06:02,219 --> 00:06:07,560
our friend int to represent them bolt we

00:06:05,759 --> 00:06:09,389
can also do things like this right the

00:06:07,560 --> 00:06:11,000
language lets us do this right sorry

00:06:09,389 --> 00:06:13,650
it's not number of horses right um

00:06:11,000 --> 00:06:15,000
number of pumpkins right is time out

00:06:13,650 --> 00:06:17,819
plus five right we're in kind of harvest

00:06:15,000 --> 00:06:20,520
season and pittsburgh ran from right so

00:06:17,819 --> 00:06:22,259
number of toothbrushes is six times time

00:06:20,520 --> 00:06:24,029
out right like the language does not

00:06:22,259 --> 00:06:27,180
prevent us from doing any of these

00:06:24,029 --> 00:06:28,500
terrible things now code review y'all do

00:06:27,180 --> 00:06:31,349
code review yes okay

00:06:28,500 --> 00:06:33,539
code review should prevent like big

00:06:31,349 --> 00:06:36,169
arias violations of like semantic

00:06:33,539 --> 00:06:38,399
knowledge that like this right but like

00:06:36,169 --> 00:06:39,590
you know you kind of don't want to

00:06:38,399 --> 00:06:41,240
depend on that

00:06:39,590 --> 00:06:42,950
so let's look at another example right

00:06:41,240 --> 00:06:47,690
so we have our friend time out here set

00:06:42,950 --> 00:06:49,520
deadlines okay takes an integer was what

00:06:47,690 --> 00:06:51,650
does it represent right some period of

00:06:49,520 --> 00:06:53,420
time until something inspires me set

00:06:51,650 --> 00:06:54,470
timeout right why do we have two

00:06:53,420 --> 00:06:56,390
different functions maybe they mean two

00:06:54,470 --> 00:06:58,400
different things who knows we had some

00:06:56,390 --> 00:07:01,910
comments because comments prevent people

00:06:58,400 --> 00:07:03,860
from doing poor things right consider

00:07:01,910 --> 00:07:08,330
the source comments make sure that

00:07:03,860 --> 00:07:10,340
people don't write so like we have you

00:07:08,330 --> 00:07:13,520
know this this worked last time right

00:07:10,340 --> 00:07:16,490
so someone starts calling this function

00:07:13,520 --> 00:07:21,410
so set deadlines right is documented to

00:07:16,490 --> 00:07:24,050
be a thing that like set it for some

00:07:21,410 --> 00:07:25,280
time period in the future right or said

00:07:24,050 --> 00:07:26,690
we're trying to set up 30 seconds from

00:07:25,280 --> 00:07:27,950
now right this violates the comment you

00:07:26,690 --> 00:07:30,290
know who knows what's going to happen um

00:07:27,950 --> 00:07:31,520
even better is if set that in that set

00:07:30,290 --> 00:07:34,370
deadline is actually implemented like

00:07:31,520 --> 00:07:36,410
this so we think we're setting a

00:07:34,370 --> 00:07:37,880
deadline for 30 seconds into the future

00:07:36,410 --> 00:07:41,990
or setting a timeout sorry for 30

00:07:37,880 --> 00:07:43,670
seconds into the future and yet even

00:07:41,990 --> 00:07:44,260
though we got like the kind of thing

00:07:43,670 --> 00:07:47,120
correct

00:07:44,260 --> 00:07:49,550
we got the scale wrong and so instead

00:07:47,120 --> 00:07:52,970
we're setting a deadline for you know 30

00:07:49,550 --> 00:07:54,860
milliseconds into the future okay so

00:07:52,970 --> 00:07:56,810
this is actually a common thing with

00:07:54,860 --> 00:07:58,460
time types right there's a lot of other

00:07:56,810 --> 00:07:59,450
domains where you could think that like

00:07:58,460 --> 00:08:03,830
this is a bad thing

00:07:59,450 --> 00:08:08,750
this happens in in time types of fair

00:08:03,830 --> 00:08:12,560
amount right and so we don't like this

00:08:08,750 --> 00:08:14,840
property so a few years ago SD chrono is

00:08:12,560 --> 00:08:16,520
now the standard library at Google we

00:08:14,840 --> 00:08:18,890
use the abseil time libraries which

00:08:16,520 --> 00:08:20,990
provide similar functionality to avoid

00:08:18,890 --> 00:08:21,950
this very thing right so if I have code

00:08:20,990 --> 00:08:25,430
that looks like this

00:08:21,950 --> 00:08:27,380
right I'm setting a deadline and or

00:08:25,430 --> 00:08:28,730
sorry I have a function and it interacts

00:08:27,380 --> 00:08:30,200
with times in different ways right some

00:08:28,730 --> 00:08:31,850
of them are relative some of them are

00:08:30,200 --> 00:08:33,290
absolute times right I'm doing

00:08:31,850 --> 00:08:37,280
arithmetic I'm doing all this stuff like

00:08:33,290 --> 00:08:39,650
like this is code like maybe correct but

00:08:37,280 --> 00:08:42,340
like the type system in the C++ doesn't

00:08:39,650 --> 00:08:44,270
actually enforce correctness in any way

00:08:42,340 --> 00:08:46,370
right we're on our own

00:08:44,270 --> 00:08:47,900
hopefully your hey you have tests okay

00:08:46,370 --> 00:08:49,700
you do in code review but like we're on

00:08:47,900 --> 00:08:51,860
our own what we would really like is to

00:08:49,700 --> 00:08:52,610
actually use the language surprise right

00:08:51,860 --> 00:08:54,200
to actually

00:08:52,610 --> 00:08:55,310
for some of these things we'd like to be

00:08:54,200 --> 00:08:57,920
able to have stronger type guarantees

00:08:55,310 --> 00:09:00,380
we'd like to be able to to do to be able

00:08:57,920 --> 00:09:01,490
to reason about these statically and so

00:09:00,380 --> 00:09:04,550
we'd like to have code that looks like

00:09:01,490 --> 00:09:06,079
this where I'm using so duration is the

00:09:04,550 --> 00:09:08,660
AB cell type that represents an interval

00:09:06,079 --> 00:09:10,040
in time time is the episode time type

00:09:08,660 --> 00:09:11,660
that rips an instant in time we'll talk

00:09:10,040 --> 00:09:14,870
about those a little bit more later like

00:09:11,660 --> 00:09:17,810
this is actually doing arithmetic in you

00:09:14,870 --> 00:09:19,490
know the like the proper domain it

00:09:17,810 --> 00:09:20,930
prevents you from doing things that you

00:09:19,490 --> 00:09:22,490
shouldn't be able to do right if you're

00:09:20,930 --> 00:09:24,920
trying to add two times together and

00:09:22,490 --> 00:09:27,800
come up with a time that's a lot more in

00:09:24,920 --> 00:09:29,870
the future like that's actually

00:09:27,800 --> 00:09:33,050
nonsensical and so like the the type

00:09:29,870 --> 00:09:35,720
system will will protect you here right

00:09:33,050 --> 00:09:38,360
so I won't go too deep into that because

00:09:35,720 --> 00:09:41,029
in 2015 a colleague of mine Greg Miller

00:09:38,360 --> 00:09:42,800
gave a talk called time programming

00:09:41,029 --> 00:09:45,079
fundamentals here at CPP con you should

00:09:42,800 --> 00:09:47,390
go watch it because it talks about the

00:09:45,079 --> 00:09:50,800
nuances of time programming and like the

00:09:47,390 --> 00:09:53,240
difference is actually between like time

00:09:50,800 --> 00:09:55,940
like time types and like actually the

00:09:53,240 --> 00:09:58,699
calendars and and civil time and these

00:09:55,940 --> 00:10:00,050
kinds of things and there's a bunch of

00:09:58,699 --> 00:10:02,149
stuff in there that's like kind of

00:10:00,050 --> 00:10:05,390
fundamental for time programming so if

00:10:02,149 --> 00:10:06,380
you haven't seen that talk but like

00:10:05,390 --> 00:10:09,290
let's review a couple of things real

00:10:06,380 --> 00:10:11,269
quick so the abseil time library it

00:10:09,290 --> 00:10:14,029
models time as a one-dimensional affine

00:10:11,269 --> 00:10:17,089
space okay I have no idea what this

00:10:14,029 --> 00:10:18,680
means but no like an affine space is you

00:10:17,089 --> 00:10:20,060
can imagine it as a number line right so

00:10:18,680 --> 00:10:22,220
just a number line from negative

00:10:20,060 --> 00:10:25,399
infinity to positive infinity there is

00:10:22,220 --> 00:10:29,120
no zero point right so there's no UNIX

00:10:25,399 --> 00:10:30,890
epoch in that sense like these variable

00:10:29,120 --> 00:10:33,350
these types you have obviously default

00:10:30,890 --> 00:10:34,790
values but like as a user of them you

00:10:33,350 --> 00:10:36,350
really shouldn't like rely on them

00:10:34,790 --> 00:10:37,940
there's there's because like timed

00:10:36,350 --> 00:10:39,350
itself doesn't have necessarily a zero

00:10:37,940 --> 00:10:41,690
point if unless you count like the Big

00:10:39,350 --> 00:10:43,750
Bang right like there's no zero point on

00:10:41,690 --> 00:10:45,890
that time line time instants are

00:10:43,750 --> 00:10:48,740
absolute time time intervals are absol

00:10:45,890 --> 00:10:50,140
duration and once we have this this type

00:10:48,740 --> 00:10:52,100
system we can actually think about

00:10:50,140 --> 00:10:54,019
different operations in that system

00:10:52,100 --> 00:10:57,890
right we can use the the algebra of

00:10:54,019 --> 00:11:00,529
affine spaces to define what's possible

00:10:57,890 --> 00:11:02,839
and what's not within and between those

00:11:00,529 --> 00:11:05,060
types right so if I add a time and

00:11:02,839 --> 00:11:05,950
iteration you know if I say 30 seconds

00:11:05,060 --> 00:11:07,450
from now

00:11:05,950 --> 00:11:11,139
right obviously that's another point in

00:11:07,450 --> 00:11:12,790
time if I say 30 seconds plus another 30

00:11:11,139 --> 00:11:14,320
seconds you know I hit the ad 30 seconds

00:11:12,790 --> 00:11:16,209
button on my microwave right that's

00:11:14,320 --> 00:11:17,560
that's another that's that yields

00:11:16,209 --> 00:11:19,630
another duration so I have two durations

00:11:17,560 --> 00:11:20,889
yields another duration what's

00:11:19,630 --> 00:11:22,660
interesting here is that there's

00:11:20,889 --> 00:11:23,769
actually undefined behavior

00:11:22,660 --> 00:11:25,810
we're not behavior sorry that's a

00:11:23,769 --> 00:11:28,959
technical term of art there's undefined

00:11:25,810 --> 00:11:31,389
operations so a time point plus a time

00:11:28,959 --> 00:11:34,079
point doesn't actually mean anything so

00:11:31,389 --> 00:11:36,910
I can't say what is today plus tomorrow

00:11:34,079 --> 00:11:38,860
like that's a nonsensical like question

00:11:36,910 --> 00:11:40,410
to ask and the type system actually

00:11:38,860 --> 00:11:44,110
doesn't allow you to ask that question

00:11:40,410 --> 00:11:45,910
it will be a compile time error I am

00:11:44,110 --> 00:11:48,940
very happy when I can turn runtime

00:11:45,910 --> 00:11:52,120
errors into compile time errors okay and

00:11:48,940 --> 00:11:54,790
having a stronger type before these

00:11:52,120 --> 00:11:56,230
concepts lets us do that there's other

00:11:54,790 --> 00:11:58,899
things you can do too right so like

00:11:56,230 --> 00:12:00,430
there's you know duration can be

00:11:58,899 --> 00:12:02,019
multiplied by a scalar and that gives

00:12:00,430 --> 00:12:03,730
another duration so I can say I will

00:12:02,019 --> 00:12:05,199
wait twice colloquial you might think of

00:12:03,730 --> 00:12:06,670
that as saying I will wait twice as long

00:12:05,199 --> 00:12:08,220
so I'm waiting for a minute I will wait

00:12:06,670 --> 00:12:10,480
twice as long that gives me two minutes

00:12:08,220 --> 00:12:12,670
you can do division by scalar you can

00:12:10,480 --> 00:12:13,959
like find what's the relationship

00:12:12,670 --> 00:12:16,540
between two durations right so the

00:12:13,959 --> 00:12:20,320
division of two duration durations you

00:12:16,540 --> 00:12:22,300
can do comparison between time and time

00:12:20,320 --> 00:12:24,880
I you can do person between a duration

00:12:22,300 --> 00:12:26,380
and duration in fact it's nonsensical to

00:12:24,880 --> 00:12:29,440
do comparison between like duration in

00:12:26,380 --> 00:12:31,260
time or duration in int so 30 seconds

00:12:29,440 --> 00:12:33,760
everyone I compare 30 seconds to 20

00:12:31,260 --> 00:12:36,010
that's actually undefined operation like

00:12:33,760 --> 00:12:38,680
I need to be able to compare a duration

00:12:36,010 --> 00:12:40,060
it with another duration there's also

00:12:38,680 --> 00:12:42,279
things that here like that aren't

00:12:40,060 --> 00:12:46,769
emitted them but like you can't multiply

00:12:42,279 --> 00:12:50,949
a time by a scalar right so you know

00:12:46,769 --> 00:12:53,230
2020 times 2 like that you know 40 40

00:12:50,949 --> 00:12:55,630
like like that doesn't mean anything in

00:12:53,230 --> 00:12:59,410
a domain in which their action actually

00:12:55,630 --> 00:13:01,300
isn't a zero point right so like these

00:12:59,410 --> 00:13:05,410
operations are all defined in the app

00:13:01,300 --> 00:13:07,029
cell in in abseil time and others aren't

00:13:05,410 --> 00:13:08,260
and that's that the fact that others

00:13:07,029 --> 00:13:10,449
aren't is actually powerful as part of

00:13:08,260 --> 00:13:12,040
this process their various conversion

00:13:10,449 --> 00:13:14,589
functions so you can convert from an

00:13:12,040 --> 00:13:18,440
integer or double to a duration these

00:13:14,589 --> 00:13:19,490
are actually defined for stuff for other

00:13:18,440 --> 00:13:20,960
beyond just minutes seconds and

00:13:19,490 --> 00:13:21,830
milliseconds I'll use those as you know

00:13:20,960 --> 00:13:23,600
for convenience but like you know

00:13:21,830 --> 00:13:25,580
seconds microseconds hours right these

00:13:23,600 --> 00:13:28,520
are always you know it's got full range

00:13:25,580 --> 00:13:32,150
of scales for conversion you can go back

00:13:28,520 --> 00:13:34,460
to double and int and so like what this

00:13:32,150 --> 00:13:36,050
means is by having these conversion and

00:13:34,460 --> 00:13:38,600
factory functions that we can migrate

00:13:36,050 --> 00:13:40,100
stuff piecemeal right so the whole goal

00:13:38,600 --> 00:13:42,140
of this entire process is to be able to

00:13:40,100 --> 00:13:44,440
migrate old code that's using integers

00:13:42,140 --> 00:13:46,670
and doubles to represent time to use

00:13:44,440 --> 00:13:49,580
proper types to represent time and

00:13:46,670 --> 00:13:52,220
either find bugs or like just improve

00:13:49,580 --> 00:13:53,300
future maintainability and we want to be

00:13:52,220 --> 00:13:54,410
able to do it incrementally which means

00:13:53,300 --> 00:13:55,610
we need to be able to convert at the

00:13:54,410 --> 00:13:57,340
boundaries right and so having

00:13:55,610 --> 00:14:00,710
conversion functions lets us do this

00:13:57,340 --> 00:14:02,960
same thing with Excel time and as

00:14:00,710 --> 00:14:04,280
opposed to duration most by the way most

00:14:02,960 --> 00:14:07,100
of the examples that I'll use will be

00:14:04,280 --> 00:14:09,520
duration centric but time is like the

00:14:07,100 --> 00:14:12,050
time type has a similar analog right so

00:14:09,520 --> 00:14:16,100
we can think about doing conversions

00:14:12,050 --> 00:14:18,740
from in this case front we're declaring

00:14:16,100 --> 00:14:21,680
a particularly epoch right so from UNIX

00:14:18,740 --> 00:14:23,120
seconds to an app cell time and if you

00:14:21,680 --> 00:14:25,670
wanted to you could convert those back

00:14:23,120 --> 00:14:27,320
to Julianne seconds right because you're

00:14:25,670 --> 00:14:31,640
picking a zero point as part of the

00:14:27,320 --> 00:14:33,890
conversion process so that's kind of a

00:14:31,640 --> 00:14:35,240
brief overview of absol time gradual

00:14:33,890 --> 00:14:38,630
typing all right so the other half of

00:14:35,240 --> 00:14:40,520
this the title of the talk so gradual

00:14:38,630 --> 00:14:43,640
typing is this this notion that we're

00:14:40,520 --> 00:14:44,630
going to take some type information and

00:14:43,640 --> 00:14:46,550
we're going to try to propagate it

00:14:44,630 --> 00:14:48,530
through our system so this is a term

00:14:46,550 --> 00:14:50,870
that comes up a lot in dynamically typed

00:14:48,530 --> 00:14:53,630
languages so Python for instance has

00:14:50,870 --> 00:14:54,740
added type annotations as part of the

00:14:53,630 --> 00:14:57,080
language now those aren't checked at

00:14:54,740 --> 00:15:00,350
runtime those are checked by by static

00:14:57,080 --> 00:15:02,300
checking or static analysis tools but

00:15:00,350 --> 00:15:05,930
python is out of these this ability to

00:15:02,300 --> 00:15:07,610
add type information to your your

00:15:05,930 --> 00:15:09,920
program and so what you can do in Python

00:15:07,610 --> 00:15:11,540
is you can say like oh hey I have a

00:15:09,920 --> 00:15:13,550
function that's being called everywhere

00:15:11,540 --> 00:15:15,260
I'm calling that function I'm calling it

00:15:13,550 --> 00:15:18,620
with us like the first argument is a

00:15:15,260 --> 00:15:20,450
string and a gradual typing tool can say

00:15:18,620 --> 00:15:22,520
maybe that argument should be annotated

00:15:20,450 --> 00:15:24,230
as only accepting a string and it will

00:15:22,520 --> 00:15:25,310
go through and add that annotation right

00:15:24,230 --> 00:15:27,220
and this is really useful because the

00:15:25,310 --> 00:15:30,170
next time you go to call that function

00:15:27,220 --> 00:15:31,740
you can it'll error if you try to give

00:15:30,170 --> 00:15:34,200
it anything other than a string

00:15:31,740 --> 00:15:36,750
right now this is this has obviously

00:15:34,200 --> 00:15:38,400
obvious downsides in that it's using

00:15:36,750 --> 00:15:39,810
existing context right what if you just

00:15:38,400 --> 00:15:42,270
happen to be passing strings but other

00:15:39,810 --> 00:15:44,100
things are valid what if you know you

00:15:42,270 --> 00:15:45,450
you aren't passing you should only be

00:15:44,100 --> 00:15:48,180
passing strings but you aren't great

00:15:45,450 --> 00:15:49,580
these inference tools kind of describe

00:15:48,180 --> 00:15:51,510
the state of the world as it is but

00:15:49,580 --> 00:15:52,710
maybe not the state of the world as you

00:15:51,510 --> 00:15:53,760
wish it to be and that's that's

00:15:52,710 --> 00:15:58,800
essentially what we're going to be doing

00:15:53,760 --> 00:16:01,200
with time types in this work with c++ so

00:15:58,800 --> 00:16:03,270
in order to do that right to propagate

00:16:01,200 --> 00:16:05,580
time information and type stronger type

00:16:03,270 --> 00:16:07,380
information through our C++ code base we

00:16:05,580 --> 00:16:08,910
have a few goals we want to be able to

00:16:07,380 --> 00:16:10,380
automate everything almost everything

00:16:08,910 --> 00:16:13,380
right won't be automate as much as

00:16:10,380 --> 00:16:14,490
possible because I I could base the size

00:16:13,380 --> 00:16:16,770
if Google is right we're talking about

00:16:14,490 --> 00:16:18,660
you know thousands and thousands and

00:16:16,770 --> 00:16:20,700
thousands of instances automate as much

00:16:18,660 --> 00:16:22,410
as we possibly can I want to make sure

00:16:20,700 --> 00:16:24,570
everything's buildable at incremental

00:16:22,410 --> 00:16:27,680
steps right so we might not be able to

00:16:24,570 --> 00:16:29,940
we are not going to be able to propagate

00:16:27,680 --> 00:16:33,000
type information straight through

00:16:29,940 --> 00:16:34,770
everywhere and so we're going to do this

00:16:33,000 --> 00:16:36,780
incrementally we're going to do a

00:16:34,770 --> 00:16:38,190
multi-step process again if you watch

00:16:36,780 --> 00:16:40,410
Titus 2 talk from a couple weeks or a

00:16:38,190 --> 00:16:41,730
couple days ago a multi-step process

00:16:40,410 --> 00:16:44,280
will make sure that everything's still

00:16:41,730 --> 00:16:45,000
buildable that incremental steps we will

00:16:44,280 --> 00:16:46,680
make sure that everything's still

00:16:45,000 --> 00:16:48,030
readable in incremental steps right we

00:16:46,680 --> 00:16:49,470
don't have produced code that like a

00:16:48,030 --> 00:16:51,810
human would look at and say like that's

00:16:49,470 --> 00:16:53,280
terrible code and just have to say like

00:16:51,810 --> 00:16:55,560
well trust us it'll get better right

00:16:53,280 --> 00:16:58,110
like that actually doesn't fly very well

00:16:55,560 --> 00:16:59,040
with most mustered years and what we

00:16:58,110 --> 00:17:00,750
would like is we would like to

00:16:59,040 --> 00:17:02,430
eventually converge you to fix the point

00:17:00,750 --> 00:17:05,250
we would eventually like to get to the

00:17:02,430 --> 00:17:06,540
point where our tools are running but

00:17:05,250 --> 00:17:07,740
you know they're not fighting each other

00:17:06,540 --> 00:17:11,970
right they eventually get to a point

00:17:07,740 --> 00:17:14,790
that that that that we have our final

00:17:11,970 --> 00:17:16,650
result so things that don't work right

00:17:14,790 --> 00:17:17,459
we can't do everything at once ok just

00:17:16,650 --> 00:17:20,520
talked about that you can't do

00:17:17,459 --> 00:17:24,780
everything else we can't use the

00:17:20,520 --> 00:17:27,200
variable type to do part time conversion

00:17:24,780 --> 00:17:31,140
analysis right because not every integer

00:17:27,200 --> 00:17:33,090
represents a time instant or a time

00:17:31,140 --> 00:17:35,280
duration not every double represents a

00:17:33,090 --> 00:17:38,490
time duration or the time instant in

00:17:35,280 --> 00:17:40,020
fact even if they like even if they did

00:17:38,490 --> 00:17:41,430
you know does it you know integers

00:17:40,020 --> 00:17:44,190
represent both time durations and in

00:17:41,430 --> 00:17:44,970
instance right like like how do we judge

00:17:44,190 --> 00:17:47,309
between the two you race

00:17:44,970 --> 00:17:49,679
we can't use use just the variable type

00:17:47,309 --> 00:17:50,850
to do this kind of thing right which is

00:17:49,679 --> 00:17:52,740
different again from some of the other

00:17:50,850 --> 00:17:53,850
type migration stuff that we have that

00:17:52,740 --> 00:17:55,350
we've talked about in the past we're

00:17:53,850 --> 00:17:57,809
just like we're just trying to rename a

00:17:55,350 --> 00:18:00,809
type okay in this case we're not just

00:17:57,809 --> 00:18:02,970
renaming or adding like stronger

00:18:00,809 --> 00:18:04,230
semantics to the type and so we need to

00:18:02,970 --> 00:18:06,090
things like the conversion functions and

00:18:04,230 --> 00:18:08,070
whatnot but we can't just use the the

00:18:06,090 --> 00:18:11,309
spelling of the existing type to do the

00:18:08,070 --> 00:18:13,919
analysis we can't just use the name of

00:18:11,309 --> 00:18:17,070
the variable because like what is

00:18:13,919 --> 00:18:18,480
timeout seconds actually me right it

00:18:17,070 --> 00:18:21,000
could be a time point it could be a

00:18:18,480 --> 00:18:22,860
duration it could be miss named like

00:18:21,000 --> 00:18:25,020
that you know who knows right

00:18:22,860 --> 00:18:26,820
like we don't actually know the name and

00:18:25,020 --> 00:18:29,220
so we can use that as a hint in some

00:18:26,820 --> 00:18:31,350
cases but we don't want to rely just on

00:18:29,220 --> 00:18:33,780
rename all the things that are suffixed

00:18:31,350 --> 00:18:36,650
seconds and call them durations don't

00:18:33,780 --> 00:18:40,440
want to do that you know of course our

00:18:36,650 --> 00:18:42,900
other option is to use comments right

00:18:40,440 --> 00:18:44,760
like and no don't use comments right

00:18:42,900 --> 00:18:47,789
like if you think that variable type is

00:18:44,760 --> 00:18:49,860
unreliable or variable name is

00:18:47,789 --> 00:18:52,620
unreliable like comments are going to be

00:18:49,860 --> 00:18:53,760
extremely unreliable if they're even

00:18:52,620 --> 00:18:56,880
there at all right it's like we can't

00:18:53,760 --> 00:19:09,809
use comments to to infer stronger type

00:18:56,880 --> 00:19:12,299
information yes yes so there are some

00:19:09,809 --> 00:19:13,799
things so tight sort of view the

00:19:12,299 --> 00:19:16,919
question right so if your legacy code

00:19:13,799 --> 00:19:18,630
has time underbar teehee like that might

00:19:16,919 --> 00:19:20,460
be a help yes

00:19:18,630 --> 00:19:24,690
so time under party you could use that

00:19:20,460 --> 00:19:26,039
as an analogue for a time instant except

00:19:24,690 --> 00:19:29,820
for the fact that because it's just in

00:19:26,039 --> 00:19:33,900
64 people actually don't always use it

00:19:29,820 --> 00:19:37,490
just as a time instant right they may

00:19:33,900 --> 00:19:39,990
use it as a time underbar t 30 seconds

00:19:37,490 --> 00:19:42,419
right like they may use it in a way

00:19:39,990 --> 00:19:45,419
that's interpreted as a duration and not

00:19:42,419 --> 00:19:48,750
just an instant right you could use like

00:19:45,419 --> 00:19:50,309
calls to time the the C standard you

00:19:48,750 --> 00:19:51,419
could you could use calls to time as a

00:19:50,309 --> 00:19:52,590
signal and we'll talk a little bit more

00:19:51,419 --> 00:19:55,110
about that in a minute right but like

00:19:52,590 --> 00:19:56,399
you can't just use the type we actually

00:19:55,110 --> 00:19:58,390
have a type inside Google called wall

00:19:56,399 --> 00:20:00,070
time that's like document

00:19:58,390 --> 00:20:01,900
find it's a dump it's just type def to

00:20:00,070 --> 00:20:04,300
double its like the number of seconds

00:20:01,900 --> 00:20:07,570
since the epoch if you think about that

00:20:04,300 --> 00:20:09,340
for a moment it means that it is half as

00:20:07,570 --> 00:20:11,770
precise now than it was 20 years ago

00:20:09,340 --> 00:20:14,440
when it was introduced because this is

00:20:11,770 --> 00:20:16,300
double right and we're about you know

00:20:14,440 --> 00:20:19,150
the epoch is almost 50 years ago and so

00:20:16,300 --> 00:20:23,050
like we've added another digit to the to

00:20:19,150 --> 00:20:24,490
the the floating point it's just right

00:20:23,050 --> 00:20:25,660
but like it's documented to be number of

00:20:24,490 --> 00:20:28,450
seconds since the epoch and yet people

00:20:25,660 --> 00:20:32,500
use it all over the place as an interval

00:20:28,450 --> 00:20:33,510
instead of an instant right so our

00:20:32,500 --> 00:20:35,740
general approach is going to be

00:20:33,510 --> 00:20:39,010
developed kind of a grab bag of tools

00:20:35,740 --> 00:20:41,260
and have them run across the code base

00:20:39,010 --> 00:20:43,060
like inside in parallel simultaneously

00:20:41,260 --> 00:20:45,490
right so a bunch of autonomous robots

00:20:43,060 --> 00:20:48,990
kind of running across the codebase that

00:20:45,490 --> 00:20:51,280
do very specific kinds of changes and

00:20:48,990 --> 00:20:53,260
let's run through what some of these

00:20:51,280 --> 00:20:54,700
tools look like and then we'll talk

00:20:53,260 --> 00:20:56,980
about how we kind of integrate them into

00:20:54,700 --> 00:20:59,710
an autonomous system that does gradual

00:20:56,980 --> 00:21:01,240
typing great so we can do expression

00:20:59,710 --> 00:21:02,860
based transformations so we can do

00:21:01,240 --> 00:21:05,530
things like simplify an existing

00:21:02,860 --> 00:21:07,380
expression you know simplify comparisons

00:21:05,530 --> 00:21:10,960
look at addition and subtraction

00:21:07,380 --> 00:21:12,600
distribute factory function calls and

00:21:10,960 --> 00:21:16,810
other kinds of function calls across

00:21:12,600 --> 00:21:18,940
various operators we can talk about and

00:21:16,810 --> 00:21:23,830
most of these today incidentally I think

00:21:18,940 --> 00:21:25,510
all of these are upstream in clinked ID

00:21:23,830 --> 00:21:27,100
in the abseil

00:21:25,510 --> 00:21:29,080
namespace so I can go look at how these

00:21:27,100 --> 00:21:31,060
are implemented and we'll look at at one

00:21:29,080 --> 00:21:32,080
of them a few minutes but like all of

00:21:31,060 --> 00:21:34,570
them are upstream you can play with me

00:21:32,080 --> 00:21:35,950
today we call so do variable

00:21:34,570 --> 00:21:37,930
transformation it's like actually

00:21:35,950 --> 00:21:39,550
transforming the types of variables so

00:21:37,930 --> 00:21:40,690
we simplify expressions and that may

00:21:39,550 --> 00:21:42,310
give us additional information that we

00:21:40,690 --> 00:21:44,830
can then use to go simplify a variables

00:21:42,310 --> 00:21:47,230
in a local scope or maybe even in class

00:21:44,830 --> 00:21:48,430
code or maybe even in global scope right

00:21:47,230 --> 00:21:49,690
there's actually not too much difference

00:21:48,430 --> 00:21:52,810
between global scope and local scope in

00:21:49,690 --> 00:21:54,700
terms of the tooling so really bother

00:21:52,810 --> 00:21:57,040
with that right but like we can rewrite

00:21:54,700 --> 00:21:58,690
variable types okay and kind of push

00:21:57,040 --> 00:22:03,000
this information beyond just single

00:21:58,690 --> 00:22:04,930
expressions we causative inter function

00:22:03,000 --> 00:22:06,970
transformations right so we're talking

00:22:04,930 --> 00:22:09,400
about parameters and change it in adding

00:22:06,970 --> 00:22:10,750
overloads and changing return values and

00:22:09,400 --> 00:22:12,730
like this is actually

00:22:10,750 --> 00:22:14,530
hard because of all the reasons that we

00:22:12,730 --> 00:22:16,660
talked about a couple days ago with you

00:22:14,530 --> 00:22:18,130
know if I add a over load like this

00:22:16,660 --> 00:22:19,690
someone taking the address and now it's

00:22:18,130 --> 00:22:21,220
ambiguous and you know we're gonna hand

00:22:19,690 --> 00:22:23,170
wave away some of that right now but

00:22:21,220 --> 00:22:25,060
like you know on a theoretical

00:22:23,170 --> 00:22:27,220
perspective like we can change the type

00:22:25,060 --> 00:22:29,590
of functions based on some of the

00:22:27,220 --> 00:22:32,650
contextual information so let's talk

00:22:29,590 --> 00:22:36,520
about simplification so we want to be

00:22:32,650 --> 00:22:38,950
able to simplify our our time

00:22:36,520 --> 00:22:42,730
expressions for a couple of reasons one

00:22:38,950 --> 00:22:45,550
is that it gives us it usually results

00:22:42,730 --> 00:22:47,620
in better code for the user but also

00:22:45,550 --> 00:22:49,060
cleans up the clang ast the clang ast

00:22:47,620 --> 00:22:51,190
has a lot of nodes in it and it's really

00:22:49,060 --> 00:22:52,270
messy and if we can simplify existing

00:22:51,190 --> 00:22:54,190
nodes it means that other

00:22:52,270 --> 00:22:56,440
transformations have fewer patterns to

00:22:54,190 --> 00:22:58,420
match right they don't have to match the

00:22:56,440 --> 00:23:01,600
entire kind of universe of possibilities

00:22:58,420 --> 00:23:03,130
if we have a tool whose entire job is to

00:23:01,600 --> 00:23:06,010
simplify expressions to a well known set

00:23:03,130 --> 00:23:07,510
so for instance you can link about if I

00:23:06,010 --> 00:23:10,870
have an expression like this right so

00:23:07,510 --> 00:23:12,340
I'm constructing a private this is all

00:23:10,870 --> 00:23:13,360
slide code I know guarantees about

00:23:12,340 --> 00:23:15,250
whether compiles I don't know if the

00:23:13,360 --> 00:23:21,580
down arrow is an actual operator in C++

00:23:15,250 --> 00:23:27,700
so richard it's coming in like z+ was 23

00:23:21,580 --> 00:23:32,520
no all right so that'd be awesome

00:23:27,700 --> 00:23:32,520
my great Mike oh this is how I write so

00:23:32,640 --> 00:23:38,260
yeah it's a shorthand for go to yes so

00:23:35,760 --> 00:23:40,060
if I have an integer that represents the

00:23:38,260 --> 00:23:41,650
number of seconds and I'm calling say

00:23:40,060 --> 00:23:43,420
the milliseconds factory function and

00:23:41,650 --> 00:23:48,160
I'm multiplying that integer by a

00:23:43,420 --> 00:23:49,690
thousand then like this is clearly you

00:23:48,160 --> 00:23:50,800
know based on just this not the name of

00:23:49,690 --> 00:23:52,030
the variable based on just the

00:23:50,800 --> 00:23:53,800
expression inside of the factory

00:23:52,030 --> 00:23:55,210
function I can rewrite this to be a

00:23:53,800 --> 00:23:56,590
factory call to seconds instead of

00:23:55,210 --> 00:23:58,180
milliseconds right this is a cleaner

00:23:56,590 --> 00:23:59,890
kind of thing it removes the

00:23:58,180 --> 00:24:02,920
multiplication which is happy for

00:23:59,890 --> 00:24:05,500
efficiency purposes but it also makes it

00:24:02,920 --> 00:24:06,520
easier to match this this second

00:24:05,500 --> 00:24:09,340
expression that they had simplified

00:24:06,520 --> 00:24:12,070
expression in other tools we can also do

00:24:09,340 --> 00:24:15,160
things like removes data cast right so

00:24:12,070 --> 00:24:16,480
the factory functions take both have

00:24:15,160 --> 00:24:18,520
overloads for both floating-point types

00:24:16,480 --> 00:24:20,710
as well as integer types this static

00:24:18,520 --> 00:24:22,060
cast here is now superfluous in fact as

00:24:20,710 --> 00:24:23,570
a pessimism because the floating-point

00:24:22,060 --> 00:24:26,330
version is a little bit

00:24:23,570 --> 00:24:27,860
performance has a is worse in

00:24:26,330 --> 00:24:31,010
performance than the integrated integer

00:24:27,860 --> 00:24:32,870
version and so we can remove the static

00:24:31,010 --> 00:24:35,410
cast and that gives us the same result

00:24:32,870 --> 00:24:37,940
in fact if we remove the static cast

00:24:35,410 --> 00:24:39,890
right you can start to see that she's

00:24:37,940 --> 00:24:43,310
doing one simplification actually yields

00:24:39,890 --> 00:24:45,560
input for another type of simplification

00:24:43,310 --> 00:24:47,390
right and so we have these we can run

00:24:45,560 --> 00:24:48,830
this tool kind of like continuously in

00:24:47,390 --> 00:24:52,100
the background over our code base and

00:24:48,830 --> 00:24:53,570
whenever a pattern pops up that we want

00:24:52,100 --> 00:24:54,740
to simplify the tool will just say AHA

00:24:53,570 --> 00:24:56,480
we should simplify this generate a

00:24:54,740 --> 00:24:57,860
change go through the standard testing

00:24:56,480 --> 00:25:00,050
process and get it submitted right so we

00:24:57,860 --> 00:25:02,410
can we can automatically do all this yes

00:25:00,050 --> 00:25:02,410
question

00:25:03,410 --> 00:25:08,870
yes and no right so the question was are

00:25:05,930 --> 00:25:11,180
they different atomic commits and they

00:25:08,870 --> 00:25:13,610
in initial kind of iterations of this

00:25:11,180 --> 00:25:15,620
process they were the way that our

00:25:13,610 --> 00:25:18,140
analysis tooling works in some cases

00:25:15,620 --> 00:25:20,390
they need to be but today these are

00:25:18,140 --> 00:25:24,200
playing tiny checks that run at code

00:25:20,390 --> 00:25:26,660
review time and so if an engineer like

00:25:24,200 --> 00:25:29,060
types one of like this thing into their

00:25:26,660 --> 00:25:31,220
into a change that they're making the

00:25:29,060 --> 00:25:32,660
tool will run at code review and say

00:25:31,220 --> 00:25:34,550
like you should have typed this instead

00:25:32,660 --> 00:25:35,810
match the button and it updates that

00:25:34,550 --> 00:25:38,540
code for them so it doesn't have to be

00:25:35,810 --> 00:25:40,430
committed some of the other more complex

00:25:38,540 --> 00:25:42,230
changes do actually need to be committed

00:25:40,430 --> 00:25:43,760
because like the way that the our

00:25:42,230 --> 00:25:46,250
pipeline pipelines work and sing like

00:25:43,760 --> 00:25:50,560
this right but but these do not have to

00:25:46,250 --> 00:25:53,030
be all right so like this talk

00:25:50,560 --> 00:25:55,760
advertised that you would get some

00:25:53,030 --> 00:25:58,400
playing tooling you would be using lib

00:25:55,760 --> 00:26:02,780
tooling so like now truth in advertising

00:25:58,400 --> 00:26:05,480
right so um this is like the matcher

00:26:02,780 --> 00:26:08,720
that finds all of the you know for that

00:26:05,480 --> 00:26:09,920
cast remove the casts rights like and

00:26:08,720 --> 00:26:11,210
I'm even like leaving a bunch of stuff

00:26:09,920 --> 00:26:13,490
out here because if you think about like

00:26:11,210 --> 00:26:14,420
this is calling this duration factory

00:26:13,490 --> 00:26:16,490
function which is a whole nother

00:26:14,420 --> 00:26:18,080
function that's like yielding the right

00:26:16,490 --> 00:26:21,640
sets of functions that we're trying to

00:26:18,080 --> 00:26:23,330
match and you know we match against

00:26:21,640 --> 00:26:25,040
different we have to match against

00:26:23,330 --> 00:26:26,480
several different kinds of casts right

00:26:25,040 --> 00:26:29,810
not just static cast it could be

00:26:26,480 --> 00:26:33,080
functional cast or it could be a c-style

00:26:29,810 --> 00:26:34,550
cast c-style cast right you know and we

00:26:33,080 --> 00:26:36,680
actually even in the same tool we match

00:26:34,550 --> 00:26:37,370
against floating-point literals because

00:26:36,680 --> 00:26:40,580
if you're calling

00:26:37,370 --> 00:26:42,080
like seconds you know 1.0 we can

00:26:40,580 --> 00:26:44,360
actually trim the dot zero and just give

00:26:42,080 --> 00:26:46,070
you seconds one which actually has a

00:26:44,360 --> 00:26:48,080
constant expert constructor for various

00:26:46,070 --> 00:26:51,530
technical reasons so you can get a like

00:26:48,080 --> 00:26:52,850
a constant you can get a compile time

00:26:51,530 --> 00:26:55,400
constant there instead of a runtime

00:26:52,850 --> 00:26:58,460
constant and so so we want to be able to

00:26:55,400 --> 00:27:01,520
simplify this right so that's the that's

00:26:58,460 --> 00:27:04,910
the thing that matches okay and if you

00:27:01,520 --> 00:27:07,550
don't understand all this like good for

00:27:04,910 --> 00:27:09,080
you okay

00:27:07,550 --> 00:27:10,940
suffice it to say that the way that

00:27:09,080 --> 00:27:12,500
clang tidy and and the clang ast

00:27:10,940 --> 00:27:14,179
matching infrastructure works is these

00:27:12,500 --> 00:27:17,120
essentially like this is essentially a

00:27:14,179 --> 00:27:19,100
functional style language that matches

00:27:17,120 --> 00:27:21,470
various nodes in the ast right so we're

00:27:19,100 --> 00:27:23,240
just matching brace nodes in the st and

00:27:21,470 --> 00:27:26,600
then because the other stuff is actually

00:27:23,240 --> 00:27:29,270
like way too big to actually show on the

00:27:26,600 --> 00:27:34,160
screen if I do this right if I do this

00:27:29,270 --> 00:27:37,910
right I didn't do it right but I can do

00:27:34,160 --> 00:27:38,960
it right here actually okay so like what

00:27:37,910 --> 00:27:45,640
are we actually doing here we're

00:27:38,960 --> 00:27:49,610
actually like this is the so this is the

00:27:45,640 --> 00:27:51,920
we're matching we have our sorry this is

00:27:49,610 --> 00:27:53,960
the this is the thing that does the

00:27:51,920 --> 00:27:55,429
rewriting right so like we have a node

00:27:53,960 --> 00:27:56,929
we think we can we can rewrite it

00:27:55,429 --> 00:27:57,950
actually pass it into this function

00:27:56,929 --> 00:27:59,900
which is a lottery functions you want to

00:27:57,950 --> 00:28:01,370
use other places I want to compose this

00:27:59,900 --> 00:28:03,380
into other tools that we have and so

00:28:01,370 --> 00:28:06,020
we're looking at like if I've matched

00:28:03,380 --> 00:28:07,700
any of these things then go get the the

00:28:06,020 --> 00:28:09,500
context of it and return it but if I

00:28:07,700 --> 00:28:11,030
don't then I return lvl not me like this

00:28:09,500 --> 00:28:12,590
just gets really complex really fast I

00:28:11,030 --> 00:28:13,610
don't expect you to understand all this

00:28:12,590 --> 00:28:15,050
like I said it's open source it's

00:28:13,610 --> 00:28:17,990
upstream if you really want to know like

00:28:15,050 --> 00:28:21,140
go dig into it but like the point here

00:28:17,990 --> 00:28:23,720
being that like these tools get can get

00:28:21,140 --> 00:28:27,230
unwieldy really quick right but like

00:28:23,720 --> 00:28:34,809
that's the that's the goal to see if I

00:28:27,230 --> 00:28:38,500
do my slides back here yes I want to

00:28:34,809 --> 00:28:38,500
full screen this puppy

00:28:40,730 --> 00:28:53,700
all right maybe it's full screen as we

00:28:43,530 --> 00:29:01,830
get but this okay okay

00:28:53,700 --> 00:29:06,540
so I can't even see the okay so let's go

00:29:01,830 --> 00:29:07,920
back to there we go okay so there we go

00:29:06,540 --> 00:29:10,140
just ikkyu late I'll just wave my hands

00:29:07,920 --> 00:29:11,640
wildly and like that make it go away so

00:29:10,140 --> 00:29:14,700
the next thing we can look at is is

00:29:11,640 --> 00:29:16,200
comparison right so we can compare we

00:29:14,700 --> 00:29:21,480
know when we're doing comparisons for

00:29:16,200 --> 00:29:26,820
instance that if we are comparing the if

00:29:21,480 --> 00:29:28,170
we have a if we have a duration

00:29:26,820 --> 00:29:29,520
expression on one side and we should

00:29:28,170 --> 00:29:33,570
also be comparing consideration on the

00:29:29,520 --> 00:29:36,900
other side so for example we are doing

00:29:33,570 --> 00:29:40,830
this type of like we are converting from

00:29:36,900 --> 00:29:43,950
a duration on the left hand side of the

00:29:40,830 --> 00:29:45,570
expression and we know that the right

00:29:43,950 --> 00:29:47,160
hand side should also be at duration

00:29:45,570 --> 00:29:48,810
right because comparisons are only

00:29:47,160 --> 00:29:50,640
well-defined between two durations and

00:29:48,810 --> 00:29:52,800
so instead of doing the comparison in

00:29:50,640 --> 00:29:56,010
the in to in the numeric domain we're

00:29:52,800 --> 00:29:57,660
doing the comparison in the we can

00:29:56,010 --> 00:30:03,000
switch to doing the comparison in the

00:29:57,660 --> 00:30:05,010
the duration domain right so like this

00:30:03,000 --> 00:30:06,900
is we could do this on time can do it in

00:30:05,010 --> 00:30:08,250
in duration as well right so this is

00:30:06,900 --> 00:30:11,870
another expression simplification we can

00:30:08,250 --> 00:30:16,170
do now lets thing about addition so from

00:30:11,870 --> 00:30:17,610
like high school algebra we know that if

00:30:16,170 --> 00:30:19,650
we have two thing if we're doing an

00:30:17,610 --> 00:30:21,030
addition right a plus B equals C or if

00:30:19,650 --> 00:30:24,330
we write it in C++ yeah

00:30:21,030 --> 00:30:26,490
C equals a plus B like we know that if

00:30:24,330 --> 00:30:29,100
we have at three things and we have a

00:30:26,490 --> 00:30:31,350
single unknown right we can solve for

00:30:29,100 --> 00:30:34,050
that unknown right like this you know

00:30:31,350 --> 00:30:36,240
eighth grade algebra ninth grade over we

00:30:34,050 --> 00:30:38,550
can do the same thing four types in this

00:30:36,240 --> 00:30:42,450
context so remember this this chart

00:30:38,550 --> 00:30:44,190
right like if we have one if we have two

00:30:42,450 --> 00:30:46,140
of these types in this chart in any

00:30:44,190 --> 00:30:49,750
given row then we know what the other

00:30:46,140 --> 00:30:51,790
type is okay so

00:30:49,750 --> 00:30:52,840
and there's even a couple here where we

00:30:51,790 --> 00:30:54,490
only have to know one of the types

00:30:52,840 --> 00:30:56,950
because the operation is undefined if

00:30:54,490 --> 00:30:59,230
it's the other type right so like we can

00:30:56,950 --> 00:31:01,540
actually use that information to do

00:30:59,230 --> 00:31:04,060
addition transformations right so in

00:31:01,540 --> 00:31:07,300
this case we're saying I have a result

00:31:04,060 --> 00:31:09,250
that is a time okay the the I'm

00:31:07,300 --> 00:31:11,560
converting from an addition that's

00:31:09,250 --> 00:31:12,850
happening in the integer domain or in

00:31:11,560 --> 00:31:16,450
the in the double domain in this case

00:31:12,850 --> 00:31:18,210
right that's a a thing plus anything

00:31:16,450 --> 00:31:22,660
that's being converted from a duration

00:31:18,210 --> 00:31:25,900
right there and follow that so I can

00:31:22,660 --> 00:31:28,800
actually infer that the other thing

00:31:25,900 --> 00:31:32,200
right this time seconds thing here is

00:31:28,800 --> 00:31:35,260
itself a time because the only operation

00:31:32,200 --> 00:31:39,070
that's defined for types in this way is

00:31:35,260 --> 00:31:40,360
that the other operand is a time and so

00:31:39,070 --> 00:31:42,430
instead of actually doing all these

00:31:40,360 --> 00:31:44,380
conversions up here what I can do is I

00:31:42,430 --> 00:31:46,600
can unwrap the conversions and just

00:31:44,380 --> 00:31:50,770
convert the first operand of the

00:31:46,600 --> 00:31:54,040
addition and then I'm doing the addition

00:31:50,770 --> 00:31:57,700
in the time the time / duration domain

00:31:54,040 --> 00:31:59,770
okay and like this actually means I can

00:31:57,700 --> 00:32:01,780
do future expression simplifications or

00:31:59,770 --> 00:32:06,150
other simplifications based on for this

00:32:01,780 --> 00:32:08,830
first argument right this first operand

00:32:06,150 --> 00:32:10,330
because some operations are undefined we

00:32:08,830 --> 00:32:12,460
can actually like do some additional

00:32:10,330 --> 00:32:14,860
inference right so in this case I have a

00:32:12,460 --> 00:32:18,700
a place where I'm converting from a time

00:32:14,860 --> 00:32:20,740
and then adding it to a thing because

00:32:18,700 --> 00:32:24,550
the only thing that I can add a time to

00:32:20,740 --> 00:32:27,280
is a duration I can infer that that

00:32:24,550 --> 00:32:29,830
second operand must be a duration and

00:32:27,280 --> 00:32:32,170
more importantly or and also because I'm

00:32:29,830 --> 00:32:34,810
converting from a thing that's scaled by

00:32:32,170 --> 00:32:37,300
seconds I'm converting to the seconds

00:32:34,810 --> 00:32:39,670
scale I can infer that other second

00:32:37,300 --> 00:32:42,370
operand must also be converted in the

00:32:39,670 --> 00:32:44,560
second scale right and then I convert

00:32:42,370 --> 00:32:49,110
the entire result of the expression back

00:32:44,560 --> 00:32:51,730
to the integer domain for the results

00:32:49,110 --> 00:32:53,470
okay now this looks like longer code

00:32:51,730 --> 00:32:55,570
right this looks like oh no my code is

00:32:53,470 --> 00:32:57,190
worse right but in reality what this is

00:32:55,570 --> 00:32:59,260
giving us is safer addition because

00:32:57,190 --> 00:33:01,540
we're only now we're using our type safe

00:32:59,260 --> 00:33:03,130
kind of addition here but it's also

00:33:01,540 --> 00:33:04,600
giving us additional information about

00:33:03,130 --> 00:33:05,530
the variable X it's also giving us

00:33:04,600 --> 00:33:06,760
additional information about the

00:33:05,530 --> 00:33:08,049
variable result and we'll talk about

00:33:06,760 --> 00:33:09,090
what that what we can do in a few

00:33:08,049 --> 00:33:11,020
minutes

00:33:09,090 --> 00:33:12,400
subtraction works kind of the same way

00:33:11,020 --> 00:33:14,440
right I can look at the different

00:33:12,400 --> 00:33:15,910
operands I can infer information about

00:33:14,440 --> 00:33:18,400
them and I can make the irrelevant

00:33:15,910 --> 00:33:20,440
transformation and subtraction also can

00:33:18,400 --> 00:33:21,669
do things like if I'm subtracting two

00:33:20,440 --> 00:33:23,559
things that are converted from a

00:33:21,669 --> 00:33:25,210
duration right I know that the result

00:33:23,559 --> 00:33:27,429
also must be a duration and so I just do

00:33:25,210 --> 00:33:28,660
that subtraction in the duration domain

00:33:27,429 --> 00:33:30,070
and then convert it back to an integer

00:33:28,660 --> 00:33:31,480
at the end right it's like there's a

00:33:30,070 --> 00:33:33,010
number of these tools that are doing

00:33:31,480 --> 00:33:34,539
these kinds of interesting you know we

00:33:33,010 --> 00:33:36,039
can make these expression

00:33:34,539 --> 00:33:38,370
simplifications another type of

00:33:36,039 --> 00:33:41,169
simplification we can do is distribution

00:33:38,370 --> 00:33:42,940
so the factory functions distribute

00:33:41,169 --> 00:33:44,679
across the various other operations

00:33:42,940 --> 00:33:46,179
within the type system so for instance

00:33:44,679 --> 00:33:48,630
if I have a ternary operator and I'm

00:33:46,179 --> 00:33:51,580
converting the result to a duration I

00:33:48,630 --> 00:33:53,080
can actually convert each part of the

00:33:51,580 --> 00:33:55,990
Turner each branch of the ternary

00:33:53,080 --> 00:33:58,630
operator to in duration independently in

00:33:55,990 --> 00:34:00,750
many cases practically one of these

00:33:58,630 --> 00:34:02,950
things is like zero or some constant

00:34:00,750 --> 00:34:05,679
right and that because this is a

00:34:02,950 --> 00:34:07,570
constant factor e function right it's

00:34:05,679 --> 00:34:09,010
I'm now doing that for free on that side

00:34:07,570 --> 00:34:11,409
of the branch raised on the if I'm

00:34:09,010 --> 00:34:12,580
converting on the outside of the ternary

00:34:11,409 --> 00:34:15,280
operator I'm always doing the conversion

00:34:12,580 --> 00:34:17,139
at runtime we can also think about

00:34:15,280 --> 00:34:21,190
converting also distributes across

00:34:17,139 --> 00:34:23,950
things like STD max where I can write

00:34:21,190 --> 00:34:25,690
cuz we push that factory function

00:34:23,950 --> 00:34:28,419
through they call the STD max to the

00:34:25,690 --> 00:34:29,830
different arguments of Max what also

00:34:28,419 --> 00:34:32,560
happens is the tools are smart enough to

00:34:29,830 --> 00:34:35,409
recognize when I'm going from a duration

00:34:32,560 --> 00:34:36,730
to a double back to a duration right I

00:34:35,409 --> 00:34:38,679
can just like it's like you know

00:34:36,730 --> 00:34:40,540
matter/antimatter they collide and on

00:34:38,679 --> 00:34:42,100
Islay and i you can just get rid of the

00:34:40,540 --> 00:34:43,869
conversion all together and i can just

00:34:42,100 --> 00:34:46,869
use in this case just use Y instead of

00:34:43,869 --> 00:34:49,149
both you know instead of having seconds

00:34:46,869 --> 00:34:51,300
to double seconds of Y I can just move

00:34:49,149 --> 00:34:53,020
them both and I have the same thing

00:34:51,300 --> 00:34:55,590
interesting thing that happens when you

00:34:53,020 --> 00:34:55,590
do this by the way

00:34:56,210 --> 00:35:05,250
duration and double have different

00:34:59,100 --> 00:35:13,620
levels of precision and some people

00:35:05,250 --> 00:35:15,840
depend on the level of precision I will

00:35:13,620 --> 00:35:19,230
make no moral judgments about those

00:35:15,840 --> 00:35:25,110
types of people in this form come talk

00:35:19,230 --> 00:35:29,340
to me afterwards right so the next thing

00:35:25,110 --> 00:35:31,620
we can do so we can also once we have

00:35:29,340 --> 00:35:33,120
our expression simplified we can look at

00:35:31,620 --> 00:35:36,120
code like this and we can say wait a

00:35:33,120 --> 00:35:38,100
minute this timeout seconds is being

00:35:36,120 --> 00:35:42,210
initialized by converting from a

00:35:38,100 --> 00:35:44,790
duration and scaled appropriately right

00:35:42,210 --> 00:35:47,610
maybe it should itself be a duration

00:35:44,790 --> 00:35:48,660
okay so we can like we now have we have

00:35:47,610 --> 00:35:50,550
a tool they'll read through and say like

00:35:48,660 --> 00:35:52,200
go find variables that have this

00:35:50,550 --> 00:35:54,720
property right there being initialized

00:35:52,200 --> 00:35:58,170
by a conversion from a duration like

00:35:54,720 --> 00:36:00,660
make those variables a duration so do

00:35:58,170 --> 00:36:02,220
this essentially make those variables a

00:36:00,660 --> 00:36:03,540
duration and then I have to go rewrite

00:36:02,220 --> 00:36:06,540
their other references to those

00:36:03,540 --> 00:36:09,150
variables too so the code still compiles

00:36:06,540 --> 00:36:11,910
so in this case I am converting back to

00:36:09,150 --> 00:36:13,680
a double on this if statement I'm

00:36:11,910 --> 00:36:15,590
converting back to a double at the call

00:36:13,680 --> 00:36:18,480
to bar because that's what Bar expects

00:36:15,590 --> 00:36:22,130
when I miss doing the assignment in the

00:36:18,480 --> 00:36:24,150
next line I have to convert on the

00:36:22,130 --> 00:36:25,170
right-hand side of the equals sign like

00:36:24,150 --> 00:36:26,160
I can't do the conversion on the

00:36:25,170 --> 00:36:27,000
left-hand side of the other side do the

00:36:26,160 --> 00:36:28,920
converse on the right-hand side of the

00:36:27,000 --> 00:36:31,590
equal sign right but again now I have

00:36:28,920 --> 00:36:34,110
context per here right that makes this

00:36:31,590 --> 00:36:36,480
app so seconds 10 is essentially for you

00:36:34,110 --> 00:36:37,950
I mean the assignment is stuff to happen

00:36:36,480 --> 00:36:41,460
but like the expression to compute app

00:36:37,950 --> 00:36:43,530
so seconds times essentially free but

00:36:41,460 --> 00:36:46,080
you'll notice what happened here is now

00:36:43,530 --> 00:36:48,690
I have a place where I could do you

00:36:46,080 --> 00:36:51,210
might comparison conversion tool will

00:36:48,690 --> 00:36:52,950
run through my code base right and it'll

00:36:51,210 --> 00:36:55,500
find this thing and it will this thing

00:36:52,950 --> 00:36:58,350
in the if statement right and it will

00:36:55,500 --> 00:37:00,360
then say hey you should be comparing in

00:36:58,350 --> 00:37:02,460
the duration domain and it will rewrite

00:37:00,360 --> 00:37:04,440
that to look like what we saw just a

00:37:02,460 --> 00:37:06,570
minute ago right so that the the seconds

00:37:04,440 --> 00:37:08,070
is being happy it's converting the 32

00:37:06,570 --> 00:37:10,580
seconds instead of doing this to double

00:37:08,070 --> 00:37:10,580
seconds business

00:37:12,349 --> 00:37:20,220
that's a slight issue yes yes oh no this

00:37:17,609 --> 00:37:25,230
isn't the slide show what's different

00:37:20,220 --> 00:37:28,049
anyone notice I didn't notice no we've

00:37:25,230 --> 00:37:31,680
changed the name right so right here we

00:37:28,049 --> 00:37:32,490
have absolution timeout seconds right

00:37:31,680 --> 00:37:34,109
well that's actually somewhat

00:37:32,490 --> 00:37:36,809
nonsensical because durations don't have

00:37:34,109 --> 00:37:38,039
a scale right they only have a scale

00:37:36,809 --> 00:37:39,329
it's like you know they only this scale

00:37:38,039 --> 00:37:41,700
when you observe them right when you

00:37:39,329 --> 00:37:43,769
convert them into some other thing okay

00:37:41,700 --> 00:37:45,299
so in this case this duration doesn't

00:37:43,769 --> 00:37:46,289
have a scale so we'd really mean if you

00:37:45,299 --> 00:37:47,819
human was writing this code they

00:37:46,289 --> 00:37:49,470
wouldn't call it time out seconds they

00:37:47,819 --> 00:37:51,269
just call it time out well as part of

00:37:49,470 --> 00:37:52,829
our local variable rewriting tools we

00:37:51,269 --> 00:37:55,380
just find places where it makes sense

00:37:52,829 --> 00:37:59,400
and like strip off the suffix so that

00:37:55,380 --> 00:38:00,390
looks like a human rodent right I mean

00:37:59,400 --> 00:38:01,440
that's what you would write if you were

00:38:00,390 --> 00:38:03,630
writing this and so we want to be able

00:38:01,440 --> 00:38:06,150
to write this code as much as as much as

00:38:03,630 --> 00:38:07,260
possible as like a human we do it we can

00:38:06,150 --> 00:38:10,109
do the same thing for class number

00:38:07,260 --> 00:38:12,869
variables right so like in this case I'm

00:38:10,109 --> 00:38:14,460
not initializing by a conversion from

00:38:12,869 --> 00:38:16,109
iteration I'm actually converting the

00:38:14,460 --> 00:38:17,940
variable to be a duration for a

00:38:16,109 --> 00:38:19,769
subsequent function call all right this

00:38:17,940 --> 00:38:21,599
is another signal that that variable

00:38:19,769 --> 00:38:22,920
that class member should be a duration

00:38:21,599 --> 00:38:24,359
like it's morally and semantically

00:38:22,920 --> 00:38:29,069
equivalent to a duration and so what do

00:38:24,359 --> 00:38:31,740
we do we give it a or we can take this

00:38:29,069 --> 00:38:33,599
line right here or that bottom line that

00:38:31,740 --> 00:38:35,130
calls a bar and we can say we can infer

00:38:33,599 --> 00:38:37,170
that timeout seconds should itself be a

00:38:35,130 --> 00:38:41,400
duration we can rewrite the name and we

00:38:37,170 --> 00:38:43,230
can end up with this this starts to get

00:38:41,400 --> 00:38:46,279
a little bit tricky right because where

00:38:43,230 --> 00:38:48,380
our variable is usually declared right

00:38:46,279 --> 00:38:51,059
there you just declared it here files

00:38:48,380 --> 00:38:52,349
where they often used we have to rewrite

00:38:51,059 --> 00:38:55,309
all the references of that variable

00:38:52,349 --> 00:38:57,900
they're often used in dot CC files right

00:38:55,309 --> 00:38:59,039
the dot the header file is like part of

00:38:57,900 --> 00:39:00,450
a lot of different translation units

00:38:59,039 --> 00:39:02,789
because it's included and presumably

00:39:00,450 --> 00:39:05,039
places where it's being used the dot CC

00:39:02,789 --> 00:39:06,809
file is its own translation unit but

00:39:05,039 --> 00:39:10,140
turns out the header file is also part

00:39:06,809 --> 00:39:11,849
of the CC as part of being included

00:39:10,140 --> 00:39:13,769
right and so there exists a translation

00:39:11,849 --> 00:39:15,299
unit for which all of you can do all

00:39:13,769 --> 00:39:16,799
these things for private variables if

00:39:15,299 --> 00:39:18,059
you're doing public variables like all

00:39:16,799 --> 00:39:20,400
bets are off right this gets much harder

00:39:18,059 --> 00:39:21,900
but for private variables like you can

00:39:20,400 --> 00:39:22,319
do these rewrites because there exists a

00:39:21,900 --> 00:39:25,829
trans

00:39:22,319 --> 00:39:30,359
for which there both of them are visible

00:39:25,829 --> 00:39:31,829
in the same translation so we've talked

00:39:30,359 --> 00:39:33,479
about variables right now let's push it

00:39:31,829 --> 00:39:36,390
out a little bit farther right so even

00:39:33,479 --> 00:39:38,519
in this case we can see that like hey

00:39:36,390 --> 00:39:39,809
I'm converting like this timeout

00:39:38,519 --> 00:39:43,229
parameter to the function to the

00:39:39,809 --> 00:39:45,929
constructor right I'm converting that

00:39:43,229 --> 00:39:47,189
from a to a duration maybe it itself

00:39:45,929 --> 00:39:50,939
should be iteration right so unique bat

00:39:47,189 --> 00:39:52,140
that's the next logical step here so in

00:39:50,939 --> 00:39:54,059
this case we have function do it

00:39:52,140 --> 00:39:55,919
function foo function foo is calling do

00:39:54,059 --> 00:39:58,079
it with a conversion from a duration as

00:39:55,919 --> 00:40:00,059
the second argument and that can tell us

00:39:58,079 --> 00:40:02,939
that like hey maybe that second argument

00:40:00,059 --> 00:40:05,759
is is again morally a duration we should

00:40:02,939 --> 00:40:07,109
do that conversion note that because we

00:40:05,759 --> 00:40:09,509
have so so we can do that conversion

00:40:07,109 --> 00:40:12,269
here note that because we are nowhere

00:40:09,509 --> 00:40:14,099
nowhere are we using like the first

00:40:12,269 --> 00:40:16,769
argument now you and I may look at this

00:40:14,099 --> 00:40:20,489
and say hey that first argument should

00:40:16,769 --> 00:40:23,130
be is is a time instant right we should

00:40:20,489 --> 00:40:26,519
convert that as well and I would agree

00:40:23,130 --> 00:40:28,589
but the tools don't know that right

00:40:26,519 --> 00:40:30,689
they're conservative enough that they

00:40:28,589 --> 00:40:33,059
can't tell that that's the case or even

00:40:30,689 --> 00:40:35,609
this addition expression right start

00:40:33,059 --> 00:40:37,499
time could be per the type system a

00:40:35,609 --> 00:40:40,349
duration or an instance so we can't

00:40:37,499 --> 00:40:41,699
infer that addition expression we can't

00:40:40,349 --> 00:40:44,579
simplify that that particular addition

00:40:41,699 --> 00:40:46,409
expression further alright now to this

00:40:44,579 --> 00:40:49,739
earlier point right we have a call to

00:40:46,409 --> 00:40:51,359
time right that itself is yields a time

00:40:49,739 --> 00:40:53,189
instant and we might be able to use in

00:40:51,359 --> 00:40:54,959
fact we could use that as the third

00:40:53,189 --> 00:40:57,630
variable in our type algebra to infer

00:40:54,959 --> 00:40:59,159
what this other addition should do right

00:40:57,630 --> 00:41:01,469
and eventually back that out and figure

00:40:59,159 --> 00:41:03,349
out the you know figure infer the type

00:41:01,469 --> 00:41:06,059
of the the first argument and do it

00:41:03,349 --> 00:41:07,199
that's kind of turning the crank a few

00:41:06,059 --> 00:41:10,469
times and getting through this iterative

00:41:07,199 --> 00:41:12,929
process we can also do with return to

00:41:10,469 --> 00:41:14,309
values so here I'm returning a value and

00:41:12,929 --> 00:41:16,859
I'm in the return statement I'm

00:41:14,309 --> 00:41:19,409
converting from a duration to a deadline

00:41:16,859 --> 00:41:21,779
or two to a double well maybe the return

00:41:19,409 --> 00:41:22,859
value should be a duration instead of a

00:41:21,779 --> 00:41:25,499
double right you kind of get the theme

00:41:22,859 --> 00:41:27,390
here where we're looking at context of

00:41:25,499 --> 00:41:29,489
specific uses of variables or parameters

00:41:27,390 --> 00:41:32,069
or return values and we're using that to

00:41:29,489 --> 00:41:34,529
infer how we can modify the function or

00:41:32,069 --> 00:41:35,759
the variable or the expression right so

00:41:34,529 --> 00:41:39,419
in this case we

00:41:35,759 --> 00:41:41,069
get to we can simplify it looks like

00:41:39,419 --> 00:41:44,519
this right we still have to adapt the

00:41:41,069 --> 00:41:47,849
collar to convert back to a double

00:41:44,519 --> 00:41:49,439
because we didn't you know it needs to

00:41:47,849 --> 00:41:51,509
be say it's still safe and you able to

00:41:49,439 --> 00:41:53,999
compile the nice thing about doing inter

00:41:51,509 --> 00:41:56,789
function transformations is that when

00:41:53,999 --> 00:41:58,559
you do that you in fluent you you you

00:41:56,789 --> 00:41:59,729
can spread information laterally through

00:41:58,559 --> 00:42:02,089
the code base right because when I

00:41:59,729 --> 00:42:04,199
change the type of a function parameter

00:42:02,089 --> 00:42:05,759
because I've been you know if function a

00:42:04,199 --> 00:42:09,179
can give me information about the type

00:42:05,759 --> 00:42:10,529
of parameter for function B that I now

00:42:09,179 --> 00:42:14,339
know a bunch of information about

00:42:10,529 --> 00:42:15,839
everyone who calls B not just the first

00:42:14,339 --> 00:42:18,059
function that I was able to infer that

00:42:15,839 --> 00:42:21,029
type information from everyone who calls

00:42:18,059 --> 00:42:23,279
be right that that argument should not

00:42:21,029 --> 00:42:27,299
write C++ let you write dynamic a typed

00:42:23,279 --> 00:42:30,029
code it should not be different for

00:42:27,299 --> 00:42:33,119
different callers now I can tell you by

00:42:30,029 --> 00:42:35,219
experience that it is but it shouldn't

00:42:33,119 --> 00:42:37,229
be and so we can use that information to

00:42:35,219 --> 00:42:38,789
infer across laterally across the code

00:42:37,229 --> 00:42:40,769
base for all the caller's would be now

00:42:38,789 --> 00:42:41,999
that's really that's a nice property but

00:42:40,769 --> 00:42:43,529
it's also really terrible property for

00:42:41,999 --> 00:42:45,929
maintance reasons that for migrate like

00:42:43,529 --> 00:42:47,369
migrating actually actually enacting and

00:42:45,929 --> 00:42:48,869
using that property is really hard right

00:42:47,369 --> 00:42:51,599
so in practice we usually add an

00:42:48,869 --> 00:42:54,449
overload migrate College piecemeal and

00:42:51,599 --> 00:42:56,569
and again multi-step migration go listen

00:42:54,449 --> 00:42:59,609
to dices doc from a couple days ago so

00:42:56,569 --> 00:43:01,439
we've built up this this tool set we

00:42:59,609 --> 00:43:03,239
build up the set of tools that we can

00:43:01,439 --> 00:43:04,679
use to do type migration right do this

00:43:03,239 --> 00:43:06,169
gradual typing we have all these tools

00:43:04,679 --> 00:43:08,189
kind of running across our code base

00:43:06,169 --> 00:43:10,259
some of them run automatically like the

00:43:08,189 --> 00:43:12,089
expression base stuff some of them are

00:43:10,259 --> 00:43:13,619
not quite automatic right they require

00:43:12,089 --> 00:43:15,239
human to run a thing every couple of

00:43:13,619 --> 00:43:16,529
would you know days and mash a button

00:43:15,239 --> 00:43:19,499
and then like they go do their thing

00:43:16,529 --> 00:43:21,059
right like that could be automated some

00:43:19,499 --> 00:43:22,499
of them are much harder because of the

00:43:21,059 --> 00:43:24,059
context in fact the tools that we've

00:43:22,499 --> 00:43:27,419
written today only do change return

00:43:24,059 --> 00:43:28,709
values in like farfel functions defined

00:43:27,419 --> 00:43:29,809
in the anonymous namespace so you know

00:43:28,709 --> 00:43:31,919
that they're in the same you can do

00:43:29,809 --> 00:43:33,209
anatomic thing in the same translation

00:43:31,919 --> 00:43:34,380
unit like we haven't yet gotten to the

00:43:33,209 --> 00:43:36,779
point where we can do this automatically

00:43:34,380 --> 00:43:39,689
like an across a broad swathe of the

00:43:36,779 --> 00:43:41,579
code base right but but how do we start

00:43:39,689 --> 00:43:43,469
this process right we've got all these

00:43:41,579 --> 00:43:45,299
tools running right but they need

00:43:43,469 --> 00:43:46,619
something to munch on right how do we

00:43:45,299 --> 00:43:48,490
start this process well I can tell you

00:43:46,619 --> 00:43:50,109
first of all that there

00:43:48,490 --> 00:43:51,580
there's already a number of places where

00:43:50,109 --> 00:43:53,530
these things would pick up changes right

00:43:51,580 --> 00:43:54,970
because of existing people you know code

00:43:53,530 --> 00:43:56,589
right I kind of this heterogeneous

00:43:54,970 --> 00:43:57,849
environment but we need to do but

00:43:56,589 --> 00:43:59,890
generally we need to do a process called

00:43:57,849 --> 00:44:01,150
seating right we seed type information

00:43:59,890 --> 00:44:02,950
throughout the code base the way that we

00:44:01,150 --> 00:44:05,349
do this is we look at what are some

00:44:02,950 --> 00:44:08,560
high-value function calls right so we

00:44:05,349 --> 00:44:10,930
have an RPC framework many users of the

00:44:08,560 --> 00:44:13,270
RPC framework call set deadlines on the

00:44:10,930 --> 00:44:15,550
RPC object right here I'm going to make

00:44:13,270 --> 00:44:17,020
an RPC here is the context object call

00:44:15,550 --> 00:44:18,580
set deadline and I would give you a

00:44:17,020 --> 00:44:21,460
value and that's when you know I'm gonna

00:44:18,580 --> 00:44:25,270
result back then like you know expire

00:44:21,460 --> 00:44:27,520
the operation remember um I should be

00:44:25,270 --> 00:44:29,859
able like I can manually add an overload

00:44:27,520 --> 00:44:32,080
to that thing right so I can identify a

00:44:29,859 --> 00:44:34,180
bunch of high value targets in my code

00:44:32,080 --> 00:44:38,500
base I can manually add appropriate

00:44:34,180 --> 00:44:40,210
overloads okay and then I'm done right

00:44:38,500 --> 00:44:41,619
because we actually have tools that will

00:44:40,210 --> 00:44:44,109
say you can give it a configuration like

00:44:41,619 --> 00:44:46,359
this right you can say here is the

00:44:44,109 --> 00:44:48,670
function name and here is the argument

00:44:46,359 --> 00:44:51,670
and here's the scale now go convert all

00:44:48,670 --> 00:44:54,400
the callers so in this case it would see

00:44:51,670 --> 00:44:56,890
set timeout 30 and it would migrate that

00:44:54,400 --> 00:44:59,790
to set timeout milliseconds 30 right

00:44:56,890 --> 00:45:02,170
automatically no problem okay

00:44:59,790 --> 00:45:04,480
what's even more fun is when you end up

00:45:02,170 --> 00:45:08,619
with things like this right like set

00:45:04,480 --> 00:45:13,180
timeout timeout seconds right someone

00:45:08,619 --> 00:45:15,609
see the problem here right like what was

00:45:13,180 --> 00:45:17,650
happening they were calling a function

00:45:15,609 --> 00:45:20,230
that interpreted its argument as a

00:45:17,650 --> 00:45:21,670
number of milliseconds but in all

00:45:20,230 --> 00:45:23,290
likelihood the color of this function

00:45:21,670 --> 00:45:25,540
thought the function was interpreting

00:45:23,290 --> 00:45:27,099
its argument as a number of seconds like

00:45:25,540 --> 00:45:29,200
congratulations you just got a timeout

00:45:27,099 --> 00:45:32,440
that thousand times longer than you

00:45:29,200 --> 00:45:33,970
expected okay and and my favorite

00:45:32,440 --> 00:45:36,030
response when I when people comment on

00:45:33,970 --> 00:45:41,410
this like hey you introduced a bug

00:45:36,030 --> 00:45:44,830
no the bug has always been there now you

00:45:41,410 --> 00:45:47,890
know about it right in fact we have a

00:45:44,830 --> 00:45:50,859
tool inside of Google that will flag

00:45:47,890 --> 00:45:53,830
instances of just this pattern right you

00:45:50,859 --> 00:45:56,200
are using a constructor the factory

00:45:53,830 --> 00:45:57,880
function - Millis like for milliseconds

00:45:56,200 --> 00:45:59,980
for a variable that looks like it is

00:45:57,880 --> 00:46:02,289
denominated in seconds like are you sure

00:45:59,980 --> 00:46:03,970
you want to do that okay

00:46:02,289 --> 00:46:07,240
I actually if people ask me to fix this

00:46:03,970 --> 00:46:09,280
bug I tell them no because the bug

00:46:07,240 --> 00:46:10,510
pre-exists might change right and I

00:46:09,280 --> 00:46:12,190
don't want to change semantics in my

00:46:10,510 --> 00:46:14,440
migration I want to keep my migration as

00:46:12,190 --> 00:46:15,880
semantic preserving as possible right

00:46:14,440 --> 00:46:18,369
because the minute I start changing

00:46:15,880 --> 00:46:20,980
semantics their tests start failing and

00:46:18,369 --> 00:46:22,869
I don't want that to be on me right so I

00:46:20,980 --> 00:46:24,460
let them worry about changing semantics

00:46:22,869 --> 00:46:26,920
later but now they know about it right

00:46:24,460 --> 00:46:31,799
this is really useful but you can see

00:46:26,920 --> 00:46:33,640
more fun when like right like

00:46:31,799 --> 00:46:35,799
congratulations you have just set a

00:46:33,640 --> 00:46:37,869
deadline that's like fifty thousand

00:46:35,799 --> 00:46:40,660
years into the future right like you

00:46:37,869 --> 00:46:45,609
know because you have or you know you've

00:46:40,660 --> 00:46:50,349
got this I mean like these things happen

00:46:45,609 --> 00:46:51,970
right like what's going on here and yet

00:46:50,349 --> 00:46:54,099
this that's the benefit of doing this

00:46:51,970 --> 00:46:56,380
type migration right what's the point of

00:46:54,099 --> 00:46:58,930
all this right the point is finding bugs

00:46:56,380 --> 00:47:00,760
in your legacy code finding bugs in an

00:46:58,930 --> 00:47:02,170
existing code and being able to then

00:47:00,760 --> 00:47:03,910
propagate that information so that when

00:47:02,170 --> 00:47:05,559
people read it they know what's going on

00:47:03,910 --> 00:47:07,720
when tools read it they know what's

00:47:05,559 --> 00:47:09,190
going on and when you go to change it or

00:47:07,720 --> 00:47:11,859
interact with it right you can use the

00:47:09,190 --> 00:47:14,799
modern types so let's briefly go through

00:47:11,859 --> 00:47:16,869
a kind of a front to end example right

00:47:14,799 --> 00:47:18,309
so how would we apply this to remember

00:47:16,869 --> 00:47:21,279
that initial piece of code that I had

00:47:18,309 --> 00:47:22,869
right so like this set deadlines seconds

00:47:21,279 --> 00:47:24,849
blah blah blah all right all this stuff

00:47:22,869 --> 00:47:26,289
right how would this happen right well

00:47:24,849 --> 00:47:28,150
first thing we do is we add an overload

00:47:26,289 --> 00:47:30,549
for set deadlines to have an app

00:47:28,150 --> 00:47:32,650
celebration okay that's simple enough

00:47:30,549 --> 00:47:34,119
that can happen not in the same file

00:47:32,650 --> 00:47:36,309
that's like can be something in some

00:47:34,119 --> 00:47:38,260
other translation unit once we have that

00:47:36,309 --> 00:47:40,450
we can update our collar

00:47:38,260 --> 00:47:43,869
to use the factory the right factory

00:47:40,450 --> 00:47:46,359
function to so we're now calling the

00:47:43,869 --> 00:47:48,400
thing the duration overload instead of

00:47:46,359 --> 00:47:49,779
the seconds overload like once we've

00:47:48,400 --> 00:47:50,950
updated all those things we can just

00:47:49,779 --> 00:47:53,470
remove the seconds overload so now

00:47:50,950 --> 00:47:57,160
people have to call the duration

00:47:53,470 --> 00:48:00,069
overload right this is great but this

00:47:57,160 --> 00:48:02,700
foo function here can be improved right

00:48:00,069 --> 00:48:04,839
so what we're doing here is we're gonna

00:48:02,700 --> 00:48:07,599
the first thing we can do is we can

00:48:04,839 --> 00:48:10,119
change the type of deadline we can infer

00:48:07,599 --> 00:48:11,829
that because so going back here right we

00:48:10,119 --> 00:48:13,359
can infer that because deadline is being

00:48:11,829 --> 00:48:15,099
converted from app cell seconds it

00:48:13,359 --> 00:48:16,660
should itself be a duration with

00:48:15,099 --> 00:48:19,210
scale of seconds rate so we can change

00:48:16,660 --> 00:48:21,579
the initializer we can change the places

00:48:19,210 --> 00:48:23,769
that it's referenced we have to convert

00:48:21,579 --> 00:48:26,019
back to a double in this bottom

00:48:23,769 --> 00:48:28,799
expression right but we can we can do

00:48:26,019 --> 00:48:30,489
all this using this set of variable

00:48:28,799 --> 00:48:33,279
transformation tools that we just talked

00:48:30,489 --> 00:48:34,539
about well what's next anybody have an

00:48:33,279 --> 00:48:37,900
idea what's the next transformation we

00:48:34,539 --> 00:48:40,329
took we should do distribution right so

00:48:37,900 --> 00:48:42,130
let's do distribution so we can push

00:48:40,329 --> 00:48:44,019
that we did know we didn't do

00:48:42,130 --> 00:48:46,869
distribution we did subtraction so we

00:48:44,019 --> 00:48:49,569
could do distribution that is actually

00:48:46,869 --> 00:48:50,349
one of the things that we could do but

00:48:49,569 --> 00:48:51,609
instead we're going to look at

00:48:50,349 --> 00:48:53,619
subtraction because it's actually has

00:48:51,609 --> 00:48:55,029
the outer thing note that like these

00:48:53,619 --> 00:48:56,109
tools are running simultaneously and so

00:48:55,029 --> 00:48:58,890
they could actually fight each other and

00:48:56,109 --> 00:49:00,970
like try to which one goes first right

00:48:58,890 --> 00:49:02,829
it does not matter they will actually

00:49:00,970 --> 00:49:03,940
arrive at the same fixed point depending

00:49:02,829 --> 00:49:05,799
on which one does first we're going to

00:49:03,940 --> 00:49:07,150
select subtraction here but you could

00:49:05,799 --> 00:49:10,720
just as easily have done distribution

00:49:07,150 --> 00:49:12,489
through through STD min so in this case

00:49:10,720 --> 00:49:15,039
we're going to do subtraction so we can

00:49:12,489 --> 00:49:16,779
infer the result at the bottom that

00:49:15,039 --> 00:49:20,200
we're just doing subtraction now in the

00:49:16,779 --> 00:49:22,089
time / duration domain and in the top

00:49:20,200 --> 00:49:23,739
part we're doing subtraction just in the

00:49:22,089 --> 00:49:24,849
duration domain right so there are two

00:49:23,739 --> 00:49:27,039
operands iterations we can do

00:49:24,849 --> 00:49:29,380
subtraction we're fine and now we can do

00:49:27,039 --> 00:49:31,749
distribution right so now we can say the

00:49:29,380 --> 00:49:33,460
call to STD min I'm going to push the

00:49:31,749 --> 00:49:34,930
factory function through that call so

00:49:33,460 --> 00:49:38,019
I'm gonna have seconds on the one

00:49:34,930 --> 00:49:40,239
operand and call to wrap that call to

00:49:38,019 --> 00:49:42,640
deadlines and the other operand okay

00:49:40,239 --> 00:49:46,150
what's next yes there's actually a

00:49:42,640 --> 00:49:48,969
couple of them the input argument right

00:49:46,150 --> 00:49:51,519
so like double offset or offset seconds

00:49:48,969 --> 00:49:53,769
right we're converting that to a

00:49:51,519 --> 00:49:54,789
duration with scale seconds and so we

00:49:53,769 --> 00:49:56,229
can go through and we can change the

00:49:54,789 --> 00:49:58,150
input argument we can make that a

00:49:56,229 --> 00:50:00,759
duration we can change the reference to

00:49:58,150 --> 00:50:06,549
offset we can rewrite the name I'm just

00:50:00,759 --> 00:50:07,719
saying offset right and now we can go

00:50:06,549 --> 00:50:09,519
back and through now we can say like

00:50:07,719 --> 00:50:11,259
well we can also change the return type

00:50:09,519 --> 00:50:12,609
of this function so we can change the

00:50:11,259 --> 00:50:15,039
return type to abseil time sorry the

00:50:12,609 --> 00:50:17,589
highlighting is not there we can return

00:50:15,039 --> 00:50:19,359
an app sale time directly instead of

00:50:17,589 --> 00:50:23,469
converting to an integer and then

00:50:19,359 --> 00:50:25,630
returning that integer right and the

00:50:23,469 --> 00:50:27,729
last thing we can do is we can infer the

00:50:25,630 --> 00:50:28,900
return type of deadline so we can change

00:50:27,729 --> 00:50:31,450
deadlines to be in absol

00:50:28,900 --> 00:50:33,580
duration return absol duration and we

00:50:31,450 --> 00:50:35,470
can change its reference calls to

00:50:33,580 --> 00:50:38,920
Deadline inside of the function foo

00:50:35,470 --> 00:50:42,940
right so we have arrived completely

00:50:38,920 --> 00:50:44,620
autonomously at this ideal thing right

00:50:42,940 --> 00:50:49,330
we've gotten to the from the point all

00:50:44,620 --> 00:50:50,950
by adding manually one constructor the

00:50:49,330 --> 00:50:51,940
rest of its automatic the rest of is

00:50:50,950 --> 00:50:54,910
just a bunch of tools running through

00:50:51,940 --> 00:50:57,100
the codebase iteratively kind of

00:50:54,910 --> 00:50:58,330
churning through these patterns right

00:50:57,100 --> 00:51:01,210
and pushing this type information

00:50:58,330 --> 00:51:02,920
through from one little kind of kernel

00:51:01,210 --> 00:51:05,230
through an entire function and you can

00:51:02,920 --> 00:51:08,200
envision that if we've changed the

00:51:05,230 --> 00:51:10,000
return type of deadline here there are a

00:51:08,200 --> 00:51:11,770
bunch of other callers to deadlines that

00:51:10,000 --> 00:51:14,470
now have conversions at their call sites

00:51:11,770 --> 00:51:16,210
and what's gonna happen to those well

00:51:14,470 --> 00:51:18,340
the type information is gonna keep kind

00:51:16,210 --> 00:51:19,540
of propagating through their expressions

00:51:18,340 --> 00:51:21,130
and their functions and their you know

00:51:19,540 --> 00:51:23,260
and so like we'll eventually get to a

00:51:21,130 --> 00:51:24,220
point that you know we've propagated it

00:51:23,260 --> 00:51:27,330
through there are certain boundaries

00:51:24,220 --> 00:51:29,710
right so like you know output input

00:51:27,330 --> 00:51:32,340
these kinds of things right like printf

00:51:29,710 --> 00:51:36,600
doesn't take a duration as a conversion

00:51:32,340 --> 00:51:40,170
thing right you could you know have a a

00:51:36,600 --> 00:51:42,310
formatter that does is pretty easy to do

00:51:40,170 --> 00:51:43,510
but you know there are boundaries and so

00:51:42,310 --> 00:51:47,260
we were just pushing this as far as we

00:51:43,510 --> 00:51:48,490
can to those boundaries so what what do

00:51:47,260 --> 00:51:50,260
people think when we do this right we're

00:51:48,490 --> 00:51:52,390
gonna check this one you've added a bug

00:51:50,260 --> 00:51:55,000
oh never mind

00:51:52,390 --> 00:51:59,350
the bugs are there you know people have

00:51:55,000 --> 00:52:02,260
ever been grateful but generally like no

00:51:59,350 --> 00:52:03,460
Sam right that's the best sound right

00:52:02,260 --> 00:52:06,100
because it means that would be able to

00:52:03,460 --> 00:52:08,590
do this without people knowing right and

00:52:06,100 --> 00:52:11,380
their code just gets better that's

00:52:08,590 --> 00:52:13,360
ultimately what like this is a concrete

00:52:11,380 --> 00:52:15,520
example of like that happening but

00:52:13,360 --> 00:52:18,730
ultimately I think we're moving to a

00:52:15,520 --> 00:52:21,790
world in which quasi autonomous or fully

00:52:18,730 --> 00:52:23,650
autonomous tools are run or should or

00:52:21,790 --> 00:52:25,630
can run through your codebase and change

00:52:23,650 --> 00:52:28,870
your code in ways that are provably

00:52:25,630 --> 00:52:30,940
correct without you knowing right and

00:52:28,870 --> 00:52:32,890
they increase your ability to find bugs

00:52:30,940 --> 00:52:34,210
they increase your ability to understand

00:52:32,890 --> 00:52:35,350
your code they increase the compilers

00:52:34,210 --> 00:52:37,090
ability to reason about your code to

00:52:35,350 --> 00:52:38,920
make it harder fuse right bugs right

00:52:37,090 --> 00:52:40,240
you can't take it 30 seconds and

00:52:38,920 --> 00:52:41,680
multiply by five and get a number of

00:52:40,240 --> 00:52:44,350
pumpkins right

00:52:41,680 --> 00:52:46,780
this is like our code is now stronger

00:52:44,350 --> 00:52:50,800
and easier to reason about because we've

00:52:46,780 --> 00:52:52,120
been doing this process and you might

00:52:50,800 --> 00:52:54,390
look at this and say like well this is a

00:52:52,120 --> 00:52:57,130
special case right like you only have

00:52:54,390 --> 00:52:58,090
this time Haswell to find algebra like

00:52:57,130 --> 00:53:00,400
this a bunch of will define

00:52:58,090 --> 00:53:02,440
relationships like how else can I use

00:53:00,400 --> 00:53:04,120
this rate so potential other

00:53:02,440 --> 00:53:06,550
applications I have not written any of

00:53:04,120 --> 00:53:08,830
these but I would like to see them

00:53:06,550 --> 00:53:12,190
written right so imagine a function that

00:53:08,830 --> 00:53:14,920
has the only tape that takes a con

00:53:12,190 --> 00:53:16,750
string ref or a string argument but all

00:53:14,920 --> 00:53:18,370
it does with that argument is call

00:53:16,750 --> 00:53:20,620
things that take string pieces or a

00:53:18,370 --> 00:53:22,240
string views right all it does is

00:53:20,620 --> 00:53:24,370
convert that to string view everywhere

00:53:22,240 --> 00:53:26,320
within the function or only uses it uses

00:53:24,370 --> 00:53:29,830
things that are in the string API but

00:53:26,320 --> 00:53:31,150
also in the stream view API right maybe

00:53:29,830 --> 00:53:34,270
the argument itself should be a string

00:53:31,150 --> 00:53:36,430
string view right do the analysis find

00:53:34,270 --> 00:53:39,000
out right push that better type

00:53:36,430 --> 00:53:41,740
information through the function car

00:53:39,000 --> 00:53:44,170
ownership deduction okay so before

00:53:41,740 --> 00:53:46,240
unique pointer we just passed around Rob

00:53:44,170 --> 00:53:49,210
lenders everywhere with comments saying

00:53:46,240 --> 00:53:53,680
you get ownership right we have seen how

00:53:49,210 --> 00:53:55,420
well that works out okay so if I have

00:53:53,680 --> 00:53:58,150
for instance a function that is called

00:53:55,420 --> 00:54:00,340
many times and maybe one of those

00:53:58,150 --> 00:54:02,890
callers is taking the result and putting

00:54:00,340 --> 00:54:04,390
it into a unique pointer what does that

00:54:02,890 --> 00:54:07,060
tell me about the thing that's being

00:54:04,390 --> 00:54:10,360
returned from that function I'll need

00:54:07,060 --> 00:54:13,390
one caller to do this and now I know

00:54:10,360 --> 00:54:15,220
that that function is returning a it's

00:54:13,390 --> 00:54:17,980
returning ownership of that pointer to

00:54:15,220 --> 00:54:19,540
its kaali's but maybe it should be

00:54:17,980 --> 00:54:21,790
returning a unique pointer you know

00:54:19,540 --> 00:54:23,350
abstraction costs not withstanding maybe

00:54:21,790 --> 00:54:24,760
I should maybe it should be returning a

00:54:23,350 --> 00:54:27,700
unique pointer to better communicate

00:54:24,760 --> 00:54:29,500
ownership I can do that analysis and

00:54:27,700 --> 00:54:31,330
push further use of ownership

00:54:29,500 --> 00:54:33,010
information through my code base making

00:54:31,330 --> 00:54:34,300
it less likely people will have all the

00:54:33,010 --> 00:54:37,360
various pointer bugs that suppose was

00:54:34,300 --> 00:54:40,480
the same as four right so I would love

00:54:37,360 --> 00:54:41,920
to see these implemented please you know

00:54:40,480 --> 00:54:43,240
if you have another idea I'd like to

00:54:41,920 --> 00:54:45,900
hear it right like I think that we can

00:54:43,240 --> 00:54:48,190
be building tools to better to use

00:54:45,900 --> 00:54:51,310
stronger type information in our code

00:54:48,190 --> 00:54:54,970
bases in an iterative and incremental

00:54:51,310 --> 00:54:58,870
way so if you want to see the two

00:54:54,970 --> 00:55:02,650
very implanted that's the poorly line

00:54:58,870 --> 00:55:12,790
broken URL for them but other than that

00:55:02,650 --> 00:55:15,940
I'm higher if you have questions please

00:55:12,790 --> 00:55:17,590
use the mic for people that are

00:55:15,940 --> 00:55:20,820
interested in doing this can you maybe

00:55:17,590 --> 00:55:23,710
discuss the cost in terms of time or

00:55:20,820 --> 00:55:25,360
people like how hard was this for you to

00:55:23,710 --> 00:55:27,250
do before someone else tries to embark

00:55:25,360 --> 00:55:31,420
on this journey so how hard was this for

00:55:27,250 --> 00:55:33,100
me to do um huh so I have been working

00:55:31,420 --> 00:55:35,140
on this off and on for like the last two

00:55:33,100 --> 00:55:36,760
or three years this is not my full-time

00:55:35,140 --> 00:55:38,260
job so I won't say it's been full-time

00:55:36,760 --> 00:55:40,000
for that two or three years I also like

00:55:38,260 --> 00:55:41,890
left Google for the while and then came

00:55:40,000 --> 00:55:44,500
back Slyke that's didn't didn't count

00:55:41,890 --> 00:55:45,510
you know this is you know wasn't part of

00:55:44,500 --> 00:55:48,850
I wasn't working out during that period

00:55:45,510 --> 00:55:50,650
the hardest part is actually dealing

00:55:48,850 --> 00:55:52,660
with all the corner cases right because

00:55:50,650 --> 00:55:54,790
there are cases where the tools you know

00:55:52,660 --> 00:55:55,960
so for instance clanked ID doesn't give

00:55:54,790 --> 00:55:58,060
you a very good way of matching

00:55:55,960 --> 00:56:00,610
references to variables in lambda

00:55:58,060 --> 00:56:01,870
captures right and so if we go rewrite

00:56:00,610 --> 00:56:03,640
all the variable references we're going

00:56:01,870 --> 00:56:06,520
to rewrite stuff in lambda captures and

00:56:03,640 --> 00:56:07,810
like that's gonna fail compilation I

00:56:06,520 --> 00:56:09,940
gotta go up did that manually right so

00:56:07,810 --> 00:56:11,470
like finding corner cases in the tooling

00:56:09,940 --> 00:56:13,390
finding corner cases in the ecosystem I

00:56:11,470 --> 00:56:15,160
mean those are those are parts of like

00:56:13,390 --> 00:56:18,100
the ongoing cost of doing stuff like

00:56:15,160 --> 00:56:20,830
this right I think that the you know

00:56:18,100 --> 00:56:22,810
coming up with a good like writing the

00:56:20,830 --> 00:56:24,160
tools is hard right if you're not free

00:56:22,810 --> 00:56:25,300
look playing the clang ast and the clang

00:56:24,160 --> 00:56:27,190
patty tooling like that's gonna be the

00:56:25,300 --> 00:56:28,750
biggest thing and then developing the

00:56:27,190 --> 00:56:30,430
logical framework to reason about

00:56:28,750 --> 00:56:31,720
fortunately we have one of those because

00:56:30,430 --> 00:56:33,250
time has an affine space and we have a

00:56:31,720 --> 00:56:34,510
mathematical model right but like

00:56:33,250 --> 00:56:36,250
thinking further about that model would

00:56:34,510 --> 00:56:39,250
be is part of the hardness of doing this

00:56:36,250 --> 00:56:41,590
right yes hello thank you for the talk

00:56:39,250 --> 00:56:43,810
I've been working on client ID a bit

00:56:41,590 --> 00:56:46,000
myself and I was thinking about check

00:56:43,810 --> 00:56:48,130
that would add Const in various places

00:56:46,000 --> 00:56:49,840
it seems like an obvious thing to do

00:56:48,130 --> 00:56:51,430
like in general it's really hard but

00:56:49,840 --> 00:56:53,500
there's some things that you could do

00:56:51,430 --> 00:56:54,730
have you been thinking about this yes so

00:56:53,500 --> 00:56:56,110
I haven't been thinking about that

00:56:54,730 --> 00:56:57,490
specifically but certainly like if

00:56:56,110 --> 00:56:59,140
you're looking at propagating stronger

00:56:57,490 --> 00:57:01,360
type can type guarantees through a

00:56:59,140 --> 00:57:02,920
system like constants tough is

00:57:01,360 --> 00:57:05,290
definitely something you can do there

00:57:02,920 --> 00:57:06,580
are some nuances around constipation

00:57:05,290 --> 00:57:08,859
that you may want to be aware of but

00:57:06,580 --> 00:57:10,630
like generally like this

00:57:08,859 --> 00:57:13,509
of approach we probably work in that

00:57:10,630 --> 00:57:15,160
case okay my second question is the big

00:57:13,509 --> 00:57:18,369
problem still seems to be cross

00:57:15,160 --> 00:57:20,980
translation unit replacements yes all

00:57:18,369 --> 00:57:27,460
the clay tidy stuff doesn't really take

00:57:20,980 --> 00:57:28,210
that into account I will agree that it's

00:57:27,460 --> 00:57:30,819
hard

00:57:28,210 --> 00:57:31,839
I will also agree that like we have

00:57:30,819 --> 00:57:33,430
people that are looking at cross

00:57:31,839 --> 00:57:34,989
translation stuff within Google right

00:57:33,430 --> 00:57:37,509
now I'm not one of them

00:57:34,989 --> 00:57:39,640
this is site project but I hope to

00:57:37,509 --> 00:57:44,619
leverage what they come up with okay

00:57:39,640 --> 00:57:47,440
thank you a question about the replacing

00:57:44,619 --> 00:57:48,910
the type in the class definition mm-hmm

00:57:47,440 --> 00:57:52,390
the one issue that jumped out at me

00:57:48,910 --> 00:57:54,430
having done similar things is if any

00:57:52,390 --> 00:57:59,140
code has a dependency on the alignment

00:57:54,430 --> 00:58:01,930
or size of the class any ideas on how to

00:57:59,140 --> 00:58:05,140
detect that or fix that or attribute

00:58:01,930 --> 00:58:06,940
that or otherwise handle that particular

00:58:05,140 --> 00:58:09,069
case so if you have a dependency on the

00:58:06,940 --> 00:58:11,049
size of the class right you should

00:58:09,069 --> 00:58:15,539
encode that as a static assert or or

00:58:11,049 --> 00:58:15,539
alignment like or alignment right like

00:58:16,410 --> 00:58:23,640
encode that as a static assert no I I

00:58:19,839 --> 00:58:25,420
don't know like I I do not know offhand

00:58:23,640 --> 00:58:27,519
what the right tools in the toolbox

00:58:25,420 --> 00:58:29,349
would be to be but like encode yours

00:58:27,519 --> 00:58:31,299
your your the assumptions that you make

00:58:29,349 --> 00:58:33,970
right should be encoded in a way that

00:58:31,299 --> 00:58:35,499
they are detectable right so like if I

00:58:33,970 --> 00:58:38,099
change the alignment and it matters to

00:58:35,499 --> 00:58:40,569
you like your test should start feeling

00:58:38,099 --> 00:58:42,460
right good if you don't encode that in a

00:58:40,569 --> 00:58:44,170
way that I can detect then we're both

00:58:42,460 --> 00:58:46,359
gonna have a bad day okay I was just

00:58:44,170 --> 00:58:48,069
wondering if there's anything and in you

00:58:46,359 --> 00:58:51,160
that you're envisioning in terms of like

00:58:48,069 --> 00:58:53,349
mark a particular class like hey if the

00:58:51,160 --> 00:58:55,119
layout of this class changes that you

00:58:53,349 --> 00:59:00,130
might have a bad day no just good tests

00:58:55,119 --> 00:59:01,769
okay so I totally agree that the code is

00:59:00,130 --> 00:59:04,930
better afterwards

00:59:01,769 --> 00:59:07,029
but I'm imagining going to my boss and

00:59:04,930 --> 00:59:09,789
saying I'd like to spend two or three

00:59:07,029 --> 00:59:11,739
years of my time on this and I'm pretty

00:59:09,789 --> 00:59:13,150
sure the question would be how do you

00:59:11,739 --> 00:59:15,220
justify this from a business standpoint

00:59:13,150 --> 00:59:18,849
right and so I'm curious if you've

00:59:15,220 --> 00:59:21,430
measured code quality or you know rate

00:59:18,849 --> 00:59:22,100
of defects related to you know people

00:59:21,430 --> 00:59:26,120
misusing

00:59:22,100 --> 00:59:28,460
types sir I have made a list of like you

00:59:26,120 --> 00:59:30,680
know bugs found it's actually fairly

00:59:28,460 --> 00:59:32,930
small which I'm happy about also sad

00:59:30,680 --> 00:59:33,920
about right like I'm happy because it

00:59:32,930 --> 00:59:35,660
means that we don't have buggy code

00:59:33,920 --> 00:59:39,560
right I'm sad about because like I want

00:59:35,660 --> 00:59:41,990
my tools to be useful I think I assure

00:59:39,560 --> 00:59:43,670
you that to like strong testing like you

00:59:41,990 --> 00:59:46,100
know lots of these things will show up

00:59:43,670 --> 00:59:47,510
in testing and you know they fix the

00:59:46,100 --> 00:59:48,560
scaling issues and things like that and

00:59:47,510 --> 00:59:50,960
they're in there as part of the testing

00:59:48,560 --> 00:59:53,750
I think more generally the arguments to

00:59:50,960 --> 00:59:56,000
make is we should be able to change our

00:59:53,750 --> 00:59:57,800
software right this is an application of

00:59:56,000 --> 01:00:00,530
that principle but like we should be

00:59:57,800 --> 01:00:02,240
able to change our software and there's

01:00:00,530 --> 01:00:05,840
a lot of reasons why you can make that

01:00:02,240 --> 01:00:07,250
argument right whether it's you know who

01:00:05,840 --> 01:00:09,620
knows when the next Spectre is going to

01:00:07,250 --> 01:00:12,710
come out or whatever rather our software

01:00:09,620 --> 01:00:14,720
cannot be immutable right the biggest

01:00:12,710 --> 01:00:15,800
way and this is generally like to figure

01:00:14,720 --> 01:00:17,180
out if I'm trying to apply a new

01:00:15,800 --> 01:00:20,090
engineering principle and organization

01:00:17,180 --> 01:00:22,100
like find instances where that principle

01:00:20,090 --> 01:00:24,020
cost the lack of that principle cost

01:00:22,100 --> 01:00:25,040
real money right we had a bunch of

01:00:24,020 --> 01:00:28,310
outages because we didn't have good

01:00:25,040 --> 01:00:29,690
testing right like here's how and that

01:00:28,310 --> 01:00:31,610
cost us half a million dollars last

01:00:29,690 --> 01:00:32,330
quarter right why don't we spend a bunch

01:00:31,610 --> 01:00:33,470
of time in a bunch of Engineers

01:00:32,330 --> 01:00:34,910
implementing better testing practices

01:00:33,470 --> 01:00:36,710
right we have a bunch of problems

01:00:34,910 --> 01:00:38,330
because our code is ossified to the

01:00:36,710 --> 01:00:39,310
point where we can't mutate it right I'm

01:00:38,330 --> 01:00:41,870
not saying you have to apply like this

01:00:39,310 --> 01:00:43,430
you know a system like this like even

01:00:41,870 --> 01:00:44,660
starve like small clean thx small

01:00:43,430 --> 01:00:46,790
infrastructure that runs across your

01:00:44,660 --> 01:00:48,680
codebase and makes changes right like be

01:00:46,790 --> 01:00:51,170
prepared and like convince you

01:00:48,680 --> 01:00:53,120
organization to be able to change your

01:00:51,170 --> 01:00:54,560
code right like that's the first step in

01:00:53,120 --> 01:00:56,270
kind of making this work google has a

01:00:54,560 --> 01:00:59,000
culture of doing that it's like plugging

01:00:56,270 --> 01:01:00,110
into that culture is fairly easy but if

01:00:59,000 --> 01:01:01,820
your company doesn't have that culture

01:01:00,110 --> 01:01:04,550
like that's the first step like code

01:01:01,820 --> 01:01:05,870
should be mutable so anyway I am out of

01:01:04,550 --> 01:01:07,400
time thanks for question I'm out of time

01:01:05,870 --> 01:01:08,900
I'm happy to take further comments in

01:01:07,400 --> 01:01:11,770
the hall or wherever else afterwards so

01:01:08,900 --> 01:01:11,770
thank you very much

01:01:12,349 --> 01:01:14,410

YouTube URL: https://www.youtube.com/watch?v=VN0VNoykxtk


