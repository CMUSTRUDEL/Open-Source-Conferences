Title: CppCon 2019: Andrew Sutton “Meta++: Language Support for Advanced Generative Programming”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
or the past several years, we have been working with Herb Sutter on C++ language support for Metaclassses. In order to implement this feature, we’ve had to invent a myriad of new language features, including scalable features for static reflection, the ability to inject partial definitions classes, namespaces, and functions, and the ability to clone and inject (with modifications) existing declarations. All of these capabilities are a precursor to supporting metaclasses.

In this talk, we present the background of this work, the constraints under which the features were designed, and the current status of our work. We will discuss many of the new language features that we’ve created, by giving examples to show how they might be used. Finally, we’ll explain how these metaprogramming features support metaclasses and explain how metaclasses can be used as a new kind of tool for library developers.
— 
Andrew Sutton
Lock3 Software, LLC
Owner
Kent, Ohio

Andrew Sutton is an owner of Lock3 Software, LLC, a software research and development company in Kent, Ohio. His spends his days working on C++ language extensions in Clang and GCC and working on various WG21 language proposals.

His past work included the design, specification, and implementation (in GCC) of concepts along with Bjarne Stroustrup and Gabriel Dos Reis. His current big project is language support for reflection and generative metaprogramming, which directly support Herb Sutter's metaclass proposal.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,160 --> 00:00:11,820
so my name is Andrew Sutton this is my

00:00:11,290 --> 00:00:14,060
second

00:00:11,820 --> 00:00:16,940
metaprogramming

00:00:14,060 --> 00:00:18,230
reflection this was supposed to have

00:00:16,940 --> 00:00:20,510
been a chalk I talked with one of my

00:00:18,230 --> 00:00:22,820
co-workers Wyatt but apparently when I

00:00:20,510 --> 00:00:27,290
submitted the abstract for the talk I

00:00:22,820 --> 00:00:28,490
managed to leave him off so he's

00:00:27,290 --> 00:00:29,779
probably happy at this point that he

00:00:28,490 --> 00:00:32,270
doesn't have to be on stage presenting

00:00:29,779 --> 00:00:35,570
this so he gets the he gets the glory I

00:00:32,270 --> 00:00:38,000
get to do the work so this this work is

00:00:35,570 --> 00:00:41,150
actually a fairly it has been a fairly

00:00:38,000 --> 00:00:43,790
long project this goes back to some work

00:00:41,150 --> 00:00:47,360
with initially Microsoft and herb Sutter

00:00:43,790 --> 00:00:49,430
on metaclasses and so that project kind

00:00:47,360 --> 00:00:50,930
of spun up a whole bunch of work on

00:00:49,430 --> 00:00:53,570
static reflection and in metaprogramming

00:00:50,930 --> 00:00:54,350
in order to get to the point where we

00:00:53,570 --> 00:00:56,570
can actually do something with

00:00:54,350 --> 00:00:58,400
metaclasses so this is sort of like the

00:00:56,570 --> 00:01:01,580
second at the top half of that of that

00:00:58,400 --> 00:01:05,030
set of language features I do have to

00:01:01,580 --> 00:01:08,090
start with this warning this this is not

00:01:05,030 --> 00:01:09,979
going to be in C++ 23 this will

00:01:08,090 --> 00:01:12,890
definitely not be in C++ 20 this might

00:01:09,979 --> 00:01:14,689
be in C++ 26 this is still a work in

00:01:12,890 --> 00:01:15,820
progress there are definitely some some

00:01:14,689 --> 00:01:18,859
placeholders that you're going to see

00:01:15,820 --> 00:01:21,619
some some works some inconsistent

00:01:18,859 --> 00:01:23,299
semantics I'm sure so just just be aware

00:01:21,619 --> 00:01:25,729
of that as I as I present examples

00:01:23,299 --> 00:01:27,409
please oh and they do apologize in

00:01:25,729 --> 00:01:31,329
advance to any compiler engineers in the

00:01:27,409 --> 00:01:31,329
room if you guys have to implement this

00:01:31,359 --> 00:01:36,649
okay so generative meta programming

00:01:34,479 --> 00:01:37,729
turns out I may have made that term up

00:01:36,649 --> 00:01:39,140
because I was trying to find a

00:01:37,729 --> 00:01:41,119
reasonable definition online before

00:01:39,140 --> 00:01:44,899
before my talk and I failed

00:01:41,119 --> 00:01:45,710
so generative programming is really just

00:01:44,899 --> 00:01:47,299
generative programming a meta

00:01:45,710 --> 00:01:48,020
programming you generate embedded

00:01:47,299 --> 00:01:50,359
programming is really this

00:01:48,020 --> 00:01:53,030
classification of tools or approaches we

00:01:50,359 --> 00:01:54,710
have for writing programs that consume

00:01:53,030 --> 00:01:56,899
programs and generate more programs

00:01:54,710 --> 00:01:58,340
right like pre processors are great are

00:01:56,899 --> 00:01:59,600
great generative generative meta

00:01:58,340 --> 00:02:01,999
programs so if you think about like

00:01:59,600 --> 00:02:03,950
cutes mod meta object compiler that's a

00:02:01,999 --> 00:02:05,630
preprocessor it takes in a header file

00:02:03,950 --> 00:02:08,360
with some cute specific declarations

00:02:05,630 --> 00:02:09,649
generates some C++ code that fills it

00:02:08,360 --> 00:02:12,350
out it gives you properties dispatch

00:02:09,649 --> 00:02:13,940
stuff like that domain-specific language

00:02:12,350 --> 00:02:16,569
is pretty popular also I don't know if

00:02:13,940 --> 00:02:20,230
anybody's used Microsoft IDL in my deal

00:02:16,569 --> 00:02:24,610
show of hands anybody still using CORBA

00:02:20,230 --> 00:02:26,650
good no hands by the way

00:02:24,610 --> 00:02:28,060
so we for those tools we actually have

00:02:26,650 --> 00:02:29,560
to have separate compilers we have to

00:02:28,060 --> 00:02:30,850
have a different language we have to

00:02:29,560 --> 00:02:34,210
compile that down into something that

00:02:30,850 --> 00:02:35,770
can be added into a C++ program if these

00:02:34,210 --> 00:02:37,480
two will solve your problems for

00:02:35,770 --> 00:02:39,270
generative programming that's great you

00:02:37,480 --> 00:02:42,400
can safely ignore the rest of this talk

00:02:39,270 --> 00:02:44,080
if you don't really like these tools

00:02:42,400 --> 00:02:46,600
because you know their downsides which

00:02:44,080 --> 00:02:47,740
there are several you might be

00:02:46,600 --> 00:02:49,810
interested in some of the things I'm

00:02:47,740 --> 00:02:50,980
talking about there one of the big

00:02:49,810 --> 00:02:52,570
problems with these things is that you

00:02:50,980 --> 00:02:53,740
always have to maintain them separately

00:02:52,570 --> 00:02:55,360
from the language and separately from

00:02:53,740 --> 00:02:57,070
your build right as soon as you build a

00:02:55,360 --> 00:02:59,260
preprocessor you have to keep it in sync

00:02:57,070 --> 00:03:00,550
with C++ and every new version of C++

00:02:59,260 --> 00:03:02,200
comes out you have to update your

00:03:00,550 --> 00:03:04,720
preprocessor to handle new syntax

00:03:02,200 --> 00:03:07,090
possibly understand your semantics this

00:03:04,720 --> 00:03:09,220
can be come kind of tedious it's a non

00:03:07,090 --> 00:03:10,540
zero effort even if you're building a

00:03:09,220 --> 00:03:12,610
DSL you still have to maintain that

00:03:10,540 --> 00:03:13,959
language and that compiler it's extra

00:03:12,610 --> 00:03:15,730
it's extra effort to do these things

00:03:13,959 --> 00:03:17,860
ideally we'd really like to do is have

00:03:15,730 --> 00:03:22,000
everything in the same language perhaps

00:03:17,860 --> 00:03:24,040
I do not entirely sure meta programming

00:03:22,000 --> 00:03:25,360
I somebody actually asked me this

00:03:24,040 --> 00:03:28,390
question the other day like what is meta

00:03:25,360 --> 00:03:29,380
programming and admittedly was kind of

00:03:28,390 --> 00:03:31,209
late at night and I was a little tired

00:03:29,380 --> 00:03:35,500
and I stumbled around I was like uh

00:03:31,209 --> 00:03:38,440
I don't know but this is this is an

00:03:35,500 --> 00:03:40,239
auspicious beginning so the way that we

00:03:38,440 --> 00:03:43,060
really use template metaprogramming I

00:03:40,239 --> 00:03:46,330
think in the context of C++ is just to

00:03:43,060 --> 00:03:47,470
mean compile time programming we use it

00:03:46,330 --> 00:03:49,090
to compute types and we use it to

00:03:47,470 --> 00:03:50,320
compute values we have template

00:03:49,090 --> 00:03:52,269
metaprogramming so we do things like

00:03:50,320 --> 00:03:54,130
with like type traits so you can add

00:03:52,269 --> 00:03:56,230
Const remove cons to find the result of

00:03:54,130 --> 00:03:58,390
a function call we have constructs for

00:03:56,230 --> 00:04:00,310
metaprogramming just which is really

00:03:58,390 --> 00:04:02,110
purely just compile time evaluation a

00:04:00,310 --> 00:04:03,880
lot of our uses of meta programming

00:04:02,110 --> 00:04:05,410
involve observations of things that are

00:04:03,880 --> 00:04:07,330
already in the program type traits for

00:04:05,410 --> 00:04:10,690
example we use heavily to optimize

00:04:07,330 --> 00:04:13,030
generic algorithms this is these are

00:04:10,690 --> 00:04:14,140
these are pretty good things right so

00:04:13,030 --> 00:04:16,479
generative meta programming I'm just

00:04:14,140 --> 00:04:18,820
gonna say is a form of meta programming

00:04:16,479 --> 00:04:21,430
at least for C++ that emphasizes the

00:04:18,820 --> 00:04:23,140
generation of code that's that's what

00:04:21,430 --> 00:04:25,720
I'm going to roll with for regenerative

00:04:23,140 --> 00:04:27,790
medical that's that's my definition now

00:04:25,720 --> 00:04:29,680
we have tools for generative meta

00:04:27,790 --> 00:04:31,060
programming already we'd had them for a

00:04:29,680 --> 00:04:32,200
long time there's a bunch of them you

00:04:31,060 --> 00:04:36,550
guys are probably familiar with a lot of

00:04:32,200 --> 00:04:36,840
these except the last two macros who

00:04:36,550 --> 00:04:40,590
love

00:04:36,840 --> 00:04:42,840
I heard a whoohoo alright good macros

00:04:40,590 --> 00:04:44,220
are kind of a form of metaprogramming

00:04:42,840 --> 00:04:46,830
they work you can use them they're

00:04:44,220 --> 00:04:49,230
pretty powerful templates how many

00:04:46,830 --> 00:04:50,610
people use templates yeah good all right

00:04:49,230 --> 00:04:53,520
so everybody we all know what those

00:04:50,610 --> 00:04:54,240
rules expressions show of hands that's

00:04:53,520 --> 00:04:56,100
pretty good

00:04:54,240 --> 00:04:57,300
expansion statements didn't you to

00:04:56,100 --> 00:05:00,270
actually see the proposals for these

00:04:57,300 --> 00:05:01,680
this was a template for or thought at

00:05:00,270 --> 00:05:03,570
some point so this was supposed to be

00:05:01,680 --> 00:05:05,610
for C++ 20 but we just missed the ship

00:05:03,570 --> 00:05:08,160
deadline on it trying to word word some

00:05:05,610 --> 00:05:10,169
of the semantics it was closed and then

00:05:08,160 --> 00:05:11,520
C++ 23 we hope we'll get static

00:05:10,169 --> 00:05:13,200
reflection that adds some new features

00:05:11,520 --> 00:05:14,880
for this stuff sometime gonna talk about

00:05:13,200 --> 00:05:18,090
these and the capabilities of them a

00:05:14,880 --> 00:05:20,490
little bit all right so macros as far as

00:05:18,090 --> 00:05:23,370
generative programming goes but macros

00:05:20,490 --> 00:05:24,750
generate tokens we can generate parts of

00:05:23,370 --> 00:05:27,270
IB would basically generate whatever you

00:05:24,750 --> 00:05:28,560
want right hopefully it's conforming C++

00:05:27,270 --> 00:05:30,120
but I think at times that doesn't even

00:05:28,560 --> 00:05:34,919
matter so much

00:05:30,120 --> 00:05:36,600
you know if 0 right so they're really

00:05:34,919 --> 00:05:38,610
powerful they let us generate anything

00:05:36,600 --> 00:05:41,850
parts of classes parts of functions

00:05:38,610 --> 00:05:43,890
parts of expressions the downside about

00:05:41,850 --> 00:05:45,210
these is they're not actually C++ they

00:05:43,890 --> 00:05:47,669
are part of the preprocessor they have

00:05:45,210 --> 00:05:49,350
no knowledge of what your program is or

00:05:47,669 --> 00:05:51,120
what it does you can't use the

00:05:49,350 --> 00:05:53,430
preprocessor in a way that that relies

00:05:51,120 --> 00:05:54,990
on whether a type is trivially

00:05:53,430 --> 00:05:56,880
computable not right

00:05:54,990 --> 00:05:59,010
they are big that happens before any

00:05:56,880 --> 00:06:01,039
processing does so it's powerful but it

00:05:59,010 --> 00:06:03,240
does have some shortcomings for we1

00:06:01,039 --> 00:06:04,110
templates fantastic this is the

00:06:03,240 --> 00:06:06,630
workhorse of all template

00:06:04,110 --> 00:06:08,370
metaprogramming you there we write

00:06:06,630 --> 00:06:10,139
things generically we provide template

00:06:08,370 --> 00:06:12,889
arguments we stamp out new definitions

00:06:10,139 --> 00:06:15,990
there's nothing confusing about this

00:06:12,889 --> 00:06:18,810
full of expressions we use these to

00:06:15,990 --> 00:06:20,610
generate iterated binary operations so

00:06:18,810 --> 00:06:22,110
we can take the conjunction of sequences

00:06:20,610 --> 00:06:23,370
of arguments they're fantastic if you

00:06:22,110 --> 00:06:25,380
happen to use variadic templates a lot

00:06:23,370 --> 00:06:27,419
that's great

00:06:25,380 --> 00:06:30,600
fold expressions node fold expressions

00:06:27,419 --> 00:06:33,450
expansion statements are potentially

00:06:30,600 --> 00:06:34,770
really really powerful they take the

00:06:33,450 --> 00:06:36,270
body they kind of work like a for

00:06:34,770 --> 00:06:37,710
statement acceptance a normal branch

00:06:36,270 --> 00:06:39,570
based for loop except instead of

00:06:37,710 --> 00:06:41,280
iterating you take the body of the loop

00:06:39,570 --> 00:06:43,410
and you just stamp it out or instantiate

00:06:41,280 --> 00:06:45,120
it for 8 for each element inside of that

00:06:43,410 --> 00:06:46,620
list so for example if I want to find

00:06:45,120 --> 00:06:48,150
the minimum arguments this is probably

00:06:46,620 --> 00:06:49,650
not a great example but if I want to

00:06:48,150 --> 00:06:51,130
find the minimum argument of a sequence

00:06:49,650 --> 00:06:53,650
of

00:06:51,130 --> 00:06:55,120
a sequence of arguments minimum value to

00:06:53,650 --> 00:06:57,160
sequence arguments we can actually

00:06:55,120 --> 00:06:58,660
decompose it this way expand over a

00:06:57,160 --> 00:07:00,940
tuple which would be conformed for the

00:06:58,660 --> 00:07:02,430
tail of that list and then actually

00:07:00,940 --> 00:07:04,180
compute the minimum of each step

00:07:02,430 --> 00:07:07,479
assuming they all have you know

00:07:04,180 --> 00:07:09,970
reasonably comparable types here set up

00:07:07,479 --> 00:07:11,560
reflection I would talk more about this

00:07:09,970 --> 00:07:13,720
like if I could but I already did that

00:07:11,560 --> 00:07:16,780
for an hour so static reflection adds a

00:07:13,720 --> 00:07:18,340
small like a number of small generative

00:07:16,780 --> 00:07:21,010
tools for you called reification

00:07:18,340 --> 00:07:23,020
operators so reification operators

00:07:21,010 --> 00:07:25,330
operate on or basically they accept

00:07:23,020 --> 00:07:26,620
reflections reflection values so if you

00:07:25,330 --> 00:07:28,740
observe properties of something to

00:07:26,620 --> 00:07:31,539
reflect something like if I reflect

00:07:28,740 --> 00:07:33,729
reflects per int that gives me a

00:07:31,539 --> 00:07:35,800
reflection of the the type int and then

00:07:33,729 --> 00:07:37,630
if I if I reify that with the type name

00:07:35,800 --> 00:07:39,970
operator I just get the type name int

00:07:37,630 --> 00:07:41,410
right so we can generate small terms

00:07:39,970 --> 00:07:43,150
which turns out to be very powerful in

00:07:41,410 --> 00:07:45,520
context some of these will actually show

00:07:43,150 --> 00:07:48,340
up later in the talk but as far as like

00:07:45,520 --> 00:07:49,389
a real generative tool like these these

00:07:48,340 --> 00:07:53,530
help but they're not really that

00:07:49,389 --> 00:07:56,740
powerful in and of themselves so what's

00:07:53,530 --> 00:07:58,360
missing well it turns out we have a lot

00:07:56,740 --> 00:08:02,200
of patterns that sort of declarative

00:07:58,360 --> 00:08:03,610
patterns that we can't really factor out

00:08:02,200 --> 00:08:05,620
of our existing code easily we can't

00:08:03,610 --> 00:08:07,479
factor out an encapsulate so if you

00:08:05,620 --> 00:08:10,599
think about like take for example an

00:08:07,479 --> 00:08:12,910
iterator right we know that there are

00:08:10,599 --> 00:08:14,260
certain patterns and building iterators

00:08:12,910 --> 00:08:16,690
and there's a concept that defines them

00:08:14,260 --> 00:08:18,639
you have to have these operators right

00:08:16,690 --> 00:08:20,620
well it would be great if we could

00:08:18,639 --> 00:08:22,660
actually you know minimize a set of

00:08:20,620 --> 00:08:23,860
things that we have to do or have to

00:08:22,660 --> 00:08:25,210
provide to implement an iterator and

00:08:23,860 --> 00:08:26,949
then just stamp out the remainder of

00:08:25,210 --> 00:08:29,860
those things right you guys have heard

00:08:26,949 --> 00:08:31,529
of boost iterator facade it's been a

00:08:29,860 --> 00:08:33,490
while since that's been popular but

00:08:31,529 --> 00:08:34,390
those are the kinds of patterns that

00:08:33,490 --> 00:08:36,070
would be able you'd like to be able to

00:08:34,390 --> 00:08:37,870
lift out of these things encapsulate and

00:08:36,070 --> 00:08:39,339
then inject back into programs later on

00:08:37,870 --> 00:08:41,830
basically we're talking about generating

00:08:39,339 --> 00:08:45,040
parts of programs and adding them into

00:08:41,830 --> 00:08:46,170
into our definitions later on and doing

00:08:45,040 --> 00:08:48,700
so programmatically

00:08:46,170 --> 00:08:50,260
okay so generative programming is really

00:08:48,700 --> 00:08:52,170
based on essentially one large feature

00:08:50,260 --> 00:08:54,670
which is code in source code injection

00:08:52,170 --> 00:08:56,980
which of course turns out into two

00:08:54,670 --> 00:08:58,480
smaller program features we have to be

00:08:56,980 --> 00:09:00,490
able to describe the kinds of code that

00:08:58,480 --> 00:09:02,320
we want to inject so we have to have

00:09:00,490 --> 00:09:04,209
some way of expressing what patterns we

00:09:02,320 --> 00:09:04,540
have what parts of a parts of code we're

00:09:04,209 --> 00:09:05,920
going to

00:09:04,540 --> 00:09:07,450
right and then we actually have to have

00:09:05,920 --> 00:09:09,070
a mechanism that takes those parts and

00:09:07,450 --> 00:09:11,620
puts them into the program at some

00:09:09,070 --> 00:09:12,880
particular position and of course this

00:09:11,620 --> 00:09:14,020
doesn't really stand on its own it

00:09:12,880 --> 00:09:16,270
actually builds directly on top of

00:09:14,020 --> 00:09:17,710
static reflection we have to build on

00:09:16,270 --> 00:09:19,660
top of this if we can't observe

00:09:17,710 --> 00:09:21,460
properties of a program we're not going

00:09:19,660 --> 00:09:24,280
to get very far generating useful

00:09:21,460 --> 00:09:25,300
programs at all like if we wouldn't be

00:09:24,280 --> 00:09:27,610
any better off than having a

00:09:25,300 --> 00:09:28,840
preprocessor system essentially sure you

00:09:27,610 --> 00:09:30,040
can generate code but you if you can't

00:09:28,840 --> 00:09:31,840
observe anything about the code that

00:09:30,040 --> 00:09:33,760
you're generating this doesn't seem to

00:09:31,840 --> 00:09:35,140
be particularly useful and of course

00:09:33,760 --> 00:09:36,940
static reflection builds on top of

00:09:35,140 --> 00:09:38,470
context Berger meta program and template

00:09:36,940 --> 00:09:40,090
metaprogramming these are both kind of

00:09:38,470 --> 00:09:43,750
essential pillars for all the kind of

00:09:40,090 --> 00:09:47,620
compile time work that we want to do so

00:09:43,750 --> 00:09:48,880
the rest of the talk is examples these

00:09:47,620 --> 00:09:50,980
examples are based on a compiler that

00:09:48,880 --> 00:09:56,020
implements these features I've been

00:09:50,980 --> 00:09:58,860
working on it for three years now four

00:09:56,020 --> 00:10:02,530
years maybe Wyant the other the other

00:09:58,860 --> 00:10:03,910
co-presenter the absent co-presenter has

00:10:02,530 --> 00:10:05,140
been working on this full-time for the

00:10:03,910 --> 00:10:06,940
last year so he's pretty much the

00:10:05,140 --> 00:10:08,590
maintainer of this at this point you can

00:10:06,940 --> 00:10:10,540
get it from from git lab in our repo

00:10:08,590 --> 00:10:12,640
there's some documentation the wiki

00:10:10,540 --> 00:10:14,680
along with some tutorial stuff it's also

00:10:12,640 --> 00:10:18,250
available on compiler Explorer thank you

00:10:14,680 --> 00:10:20,140
Matt although this might not be the most

00:10:18,250 --> 00:10:22,180
up-to-date version on compiler Explorer

00:10:20,140 --> 00:10:26,830
there was some some late work yesterday

00:10:22,180 --> 00:10:29,590
which I'll talk about sadly sadly these

00:10:26,830 --> 00:10:31,570
examples are not perfect they may not

00:10:29,590 --> 00:10:32,950
compile as written I white and I

00:10:31,570 --> 00:10:34,210
actually worked did a fair bit of work

00:10:32,950 --> 00:10:35,560
yesterday to try to make sure that they

00:10:34,210 --> 00:10:37,840
were saying that they would compile

00:10:35,560 --> 00:10:39,370
although in the course of editing to fit

00:10:37,840 --> 00:10:41,710
things on slide I'm a slides I may have

00:10:39,370 --> 00:10:44,980
made some mistakes that happened on

00:10:41,710 --> 00:10:48,040
Monday also so you can you can type

00:10:44,980 --> 00:10:50,170
along at home or in the audience if

00:10:48,040 --> 00:10:51,700
you'd like just cross your fingers and

00:10:50,170 --> 00:10:54,370
hope the compiler doesn't crash on you

00:10:51,700 --> 00:10:56,280
it shouldn't if you duplicate exactly

00:10:54,370 --> 00:11:00,730
what I write it probably shouldn't crash

00:10:56,280 --> 00:11:02,290
all right so first example and I kind of

00:11:00,730 --> 00:11:06,190
have to apology by I apologize for the

00:11:02,290 --> 00:11:07,750
first example I I've been trying to find

00:11:06,190 --> 00:11:10,390
a really good hello world for template

00:11:07,750 --> 00:11:12,610
metaprogramming I refer a generative

00:11:10,390 --> 00:11:14,680
metaprogramming and it turns out to be

00:11:12,610 --> 00:11:18,339
really difficult to find an example that

00:11:14,680 --> 00:11:19,629
just introduces the basic concepts

00:11:18,339 --> 00:11:23,649
and solves a reasonably interesting

00:11:19,629 --> 00:11:24,910
problem so of course the interesting

00:11:23,649 --> 00:11:28,449
problem I'm going to solve involves bit

00:11:24,910 --> 00:11:29,769
fields because everybody knows this this

00:11:28,449 --> 00:11:30,699
actually ends up being a problem that I

00:11:29,769 --> 00:11:32,410
have to deal with on a fairly regular

00:11:30,699 --> 00:11:33,490
basis and if you happen to work on clang

00:11:32,410 --> 00:11:35,889
and you're actually familiar with this

00:11:33,490 --> 00:11:37,540
problem so inside of compilers there's

00:11:35,889 --> 00:11:39,129
this tendency to take integer data

00:11:37,540 --> 00:11:40,990
associated with abstract syntax tree

00:11:39,129 --> 00:11:42,939
nodes and kind of compress that into the

00:11:40,990 --> 00:11:45,160
root node of a hierarchy an interrupt

00:11:42,939 --> 00:11:47,319
data be like boolean small enum values

00:11:45,160 --> 00:11:49,839
whatever you send up like a 32 or 64-bit

00:11:47,319 --> 00:11:52,059
block of integer values and in the base

00:11:49,839 --> 00:11:54,509
class of your hierarchy and as you have

00:11:52,059 --> 00:11:57,040
derived classes they might add more data

00:11:54,509 --> 00:11:58,720
so we really want this kind of notion of

00:11:57,040 --> 00:12:02,649
an extensible bit field we can add add

00:11:58,720 --> 00:12:04,329
data as the derived classes work down so

00:12:02,649 --> 00:12:05,949
this is a slightly difficult example

00:12:04,329 --> 00:12:07,779
we're more advanced than we'd like to be

00:12:05,949 --> 00:12:09,730
free presented so if I were working in

00:12:07,779 --> 00:12:11,740
clang for example and not following

00:12:09,730 --> 00:12:14,620
clangs coding conventions at all because

00:12:11,740 --> 00:12:17,139
I like lowercase and underscores my

00:12:14,620 --> 00:12:18,999
expression like for my C++ expression if

00:12:17,139 --> 00:12:20,589
I'm writing a C++ compiler this is

00:12:18,999 --> 00:12:22,360
information that I would have for for an

00:12:20,589 --> 00:12:24,399
expression in my tree there's a value

00:12:22,360 --> 00:12:25,990
category we have to know whether the

00:12:24,399 --> 00:12:27,309
type is whether the expression is type

00:12:25,990 --> 00:12:29,019
dependent whether it's value dependent

00:12:27,309 --> 00:12:30,879
whether it has some unexpanded parameter

00:12:29,019 --> 00:12:32,230
packs some other information besides but

00:12:30,879 --> 00:12:35,769
these are kind of the the obvious ones

00:12:32,230 --> 00:12:38,769
are the the easy ones to talk about and

00:12:35,769 --> 00:12:39,910
then if I if I have another if I have

00:12:38,769 --> 00:12:42,639
like a derived class like a fold

00:12:39,910 --> 00:12:44,410
expression I want to have a flag to say

00:12:42,639 --> 00:12:45,579
whether it goes left or right and it

00:12:44,410 --> 00:12:47,199
would be great if I could actually just

00:12:45,579 --> 00:12:49,540
derive from that first that first bit

00:12:47,199 --> 00:12:52,120
field instead of bit fields but you know

00:12:49,540 --> 00:12:56,139
this doesn't really work right for a

00:12:52,120 --> 00:12:57,429
couple of reasons it is my belief and I

00:12:56,139 --> 00:13:00,879
hopefully somebody will tell me that I'm

00:12:57,429 --> 00:13:02,740
right that the bits in this object are

00:13:00,879 --> 00:13:04,600
separate from the bits in the base class

00:13:02,740 --> 00:13:06,850
some object so instead of having a

00:13:04,600 --> 00:13:09,459
32-bit integer for this class now we

00:13:06,850 --> 00:13:11,230
have a 64 uh sorry instead of having a

00:13:09,459 --> 00:13:12,910
one byte feed one byte object now we

00:13:11,230 --> 00:13:14,230
have a 2-lane object which kind of

00:13:12,910 --> 00:13:15,850
defeats the purpose so it doesn't really

00:13:14,230 --> 00:13:17,499
worry and because it's inherited we'd

00:13:15,850 --> 00:13:18,639
have to use a pointer or pass this thing

00:13:17,499 --> 00:13:21,160
around by reference anyway so that's

00:13:18,639 --> 00:13:22,389
that's also now what we want so there's

00:13:21,160 --> 00:13:24,939
there's a lot of reasons why we don't do

00:13:22,389 --> 00:13:26,740
this so the way the client gayatri ends

00:13:24,939 --> 00:13:29,079
up solving this problem is just to read

00:13:26,740 --> 00:13:30,519
eclair the original original set of bits

00:13:29,079 --> 00:13:32,410
but kind of compact them into a cyano

00:13:30,519 --> 00:13:32,800
field that's sort of unreachable right

00:13:32,410 --> 00:13:34,389
like

00:13:32,800 --> 00:13:36,040
there were six bits in the original

00:13:34,389 --> 00:13:38,589
declaration so we'll just put them there

00:13:36,040 --> 00:13:39,850
and then you'll never use them and then

00:13:38,589 --> 00:13:41,980
if you have a lot of these things you

00:13:39,850 --> 00:13:43,420
just stick them into a union and this is

00:13:41,980 --> 00:13:45,850
this is this thing goes into the base

00:13:43,420 --> 00:13:47,619
class of your hierarchy so if you want

00:13:45,850 --> 00:13:48,939
if you want your fold expression bits

00:13:47,619 --> 00:13:50,350
you can just grab that field out of the

00:13:48,939 --> 00:13:51,730
Union if you want your common bits you

00:13:50,350 --> 00:13:54,819
can just grab the common bits out of

00:13:51,730 --> 00:13:56,019
that Union and then you have some some

00:13:54,819 --> 00:13:57,160
rules and your discriminators to make

00:13:56,019 --> 00:13:58,899
sure that you don't do the wrong thing

00:13:57,160 --> 00:14:00,160
this is this is a reasonable solution

00:13:58,899 --> 00:14:02,290
this is actually a fairly effective way

00:14:00,160 --> 00:14:07,299
to do this I was quite pleased to learn

00:14:02,290 --> 00:14:09,339
this but there are some downsides it's

00:14:07,299 --> 00:14:10,540
it's kind of a weird to maintain you got

00:14:09,339 --> 00:14:12,790
a like if you change the size of the

00:14:10,540 --> 00:14:15,040
common bits thing you got to update that

00:14:12,790 --> 00:14:16,569
everywhere which admittedly is trivially

00:14:15,040 --> 00:14:18,399
solved with a context or variable so

00:14:16,569 --> 00:14:20,110
it's not that big of a deal but what I

00:14:18,399 --> 00:14:22,869
don't like about the approach is that if

00:14:20,110 --> 00:14:26,709
I have a fold expression bits object

00:14:22,869 --> 00:14:28,269
I can't also access like the value

00:14:26,709 --> 00:14:29,499
category whether it's type dependent

00:14:28,269 --> 00:14:30,970
whether it's valued I can't access the

00:14:29,499 --> 00:14:34,029
things that I should have inherited

00:14:30,970 --> 00:14:35,589
right so one way we can do that is just

00:14:34,029 --> 00:14:38,049
to simply copy those fields out in each

00:14:35,589 --> 00:14:40,119
time and so if every class actually just

00:14:38,049 --> 00:14:41,829
duplicates all these things now in every

00:14:40,119 --> 00:14:44,170
one of these bit fields I can say well I

00:14:41,829 --> 00:14:45,730
have my full my full bits I can see all

00:14:44,170 --> 00:14:47,470
the original bits it sort of looks like

00:14:45,730 --> 00:14:48,670
inherit or it feels like in herrings

00:14:47,470 --> 00:14:50,860
even though there's no inherent

00:14:48,670 --> 00:14:52,119
inheritance at all and of course this is

00:14:50,860 --> 00:14:54,220
also a maintenance problem because now

00:14:52,119 --> 00:14:57,009
you have to copy that stuff around which

00:14:54,220 --> 00:15:00,189
you can again easily solve with macro if

00:14:57,009 --> 00:15:05,529
you want which may be how I did it on

00:15:00,189 --> 00:15:06,999
mice in my own projects but this is this

00:15:05,529 --> 00:15:08,949
is kind of what we want so the question

00:15:06,999 --> 00:15:10,449
is how do you do this generatively or at

00:15:08,949 --> 00:15:12,309
least safely with the language features

00:15:10,449 --> 00:15:13,839
that I'm talking about here so the

00:15:12,309 --> 00:15:14,769
strategy for this implication is

00:15:13,839 --> 00:15:16,720
actually fairly simple

00:15:14,769 --> 00:15:18,879
it actually exactly matches what we

00:15:16,720 --> 00:15:20,619
would normally do with the macro I want

00:15:18,879 --> 00:15:22,959
to put my common bits into into that

00:15:20,619 --> 00:15:24,490
field right there so now we have the

00:15:22,959 --> 00:15:26,259
problem of how do we declare them and

00:15:24,490 --> 00:15:28,869
then what is the mechanism that actually

00:15:26,259 --> 00:15:33,429
injects those and this is how we

00:15:28,869 --> 00:15:36,459
describe them so this is if you see the

00:15:33,429 --> 00:15:39,100
double underscore that means this syntax

00:15:36,459 --> 00:15:41,110
has not yet been finished so this is

00:15:39,100 --> 00:15:42,730
this is a fragment or a class fragment

00:15:41,110 --> 00:15:45,249
actually let me be let me be precise

00:15:42,730 --> 00:15:46,480
here this is the class fragment so a

00:15:45,249 --> 00:15:48,310
fragment is

00:15:46,480 --> 00:15:49,810
essentially a part of a class it's

00:15:48,310 --> 00:15:51,459
something that's going to be injected

00:15:49,810 --> 00:15:53,410
into a class later on actually shouldn't

00:15:51,459 --> 00:15:55,420
say the fragment isn't going to be

00:15:53,410 --> 00:15:56,800
injected the things inside the fragments

00:15:55,420 --> 00:15:58,180
are going to be injected so this is

00:15:56,800 --> 00:15:59,920
basically a class fragment is basically

00:15:58,180 --> 00:16:01,120
a sequence of member declarations they

00:15:59,920 --> 00:16:05,079
were going to put into another class

00:16:01,120 --> 00:16:07,149
somewhere else a fragment is an

00:16:05,079 --> 00:16:09,940
expression which means an expression has

00:16:07,149 --> 00:16:11,920
a value so the value of this thing is

00:16:09,940 --> 00:16:13,329
just its reflection and all we're doing

00:16:11,920 --> 00:16:14,680
is we're getting the reflection value of

00:16:13,329 --> 00:16:15,970
the reflected value that like this is

00:16:14,680 --> 00:16:17,230
very similar to the reflects per

00:16:15,970 --> 00:16:18,820
operator it gives you back a

00:16:17,230 --> 00:16:21,519
compile-time value that represents these

00:16:18,820 --> 00:16:23,860
things and we can just declare a context

00:16:21,519 --> 00:16:25,660
for variable that holds onto that so

00:16:23,860 --> 00:16:31,720
common bits is the value of that

00:16:25,660 --> 00:16:34,420
reflection injection is pretty easy this

00:16:31,720 --> 00:16:35,889
is an injection declaration it looks a

00:16:34,420 --> 00:16:38,019
little bit weird it looks like an

00:16:35,889 --> 00:16:39,160
implication but it's not you guys will

00:16:38,019 --> 00:16:43,570
see where the syntax comes from in a

00:16:39,160 --> 00:16:46,209
second so the the injection declaration

00:16:43,570 --> 00:16:47,829
takes the fragment on the right which is

00:16:46,209 --> 00:16:48,880
just an expression as long as you have a

00:16:47,829 --> 00:16:53,050
different reflection you can inject

00:16:48,880 --> 00:16:55,410
something and we'll open up the fragment

00:16:53,050 --> 00:16:59,769
and then replay all those members

00:16:55,410 --> 00:17:01,360
copying them into this class where that

00:16:59,769 --> 00:17:04,990
declaration appears in the program and

00:17:01,360 --> 00:17:06,640
that copy it's not really a copy it's

00:17:04,990 --> 00:17:08,500
really close to a template instantiation

00:17:06,640 --> 00:17:10,600
really what we're doing is we're kind of

00:17:08,500 --> 00:17:12,939
like sort of instantiating each member

00:17:10,600 --> 00:17:14,980
declaration into this class performing a

00:17:12,939 --> 00:17:17,260
couple of substitutions a couple of very

00:17:14,980 --> 00:17:20,530
important substitutions as we do that in

00:17:17,260 --> 00:17:22,140
order to adapt those declarations to the

00:17:20,530 --> 00:17:24,250
context where they're being injected

00:17:22,140 --> 00:17:25,870
which isn't really very interesting in

00:17:24,250 --> 00:17:26,410
this example but that's how it works

00:17:25,870 --> 00:17:28,690
right

00:17:26,410 --> 00:17:30,429
so after injection we get exactly what

00:17:28,690 --> 00:17:32,440
we should see which is a sequence of all

00:17:30,429 --> 00:17:34,179
these declarations so I get my fake

00:17:32,440 --> 00:17:36,370
inheritance like version of bit fields

00:17:34,179 --> 00:17:40,720
which are pseudo extensible I guess and

00:17:36,370 --> 00:17:42,940
everything works out nicely so this is

00:17:40,720 --> 00:17:43,840
this is actually fairly macro like I

00:17:42,940 --> 00:17:45,850
just want to point that out

00:17:43,840 --> 00:17:47,200
one way to think of fragments is

00:17:45,850 --> 00:17:49,809
actually that they are somewhat like

00:17:47,200 --> 00:17:53,770
syntactic macros it's just a blob of

00:17:49,809 --> 00:17:56,380
syntax a blob of valid C++ that's

00:17:53,770 --> 00:17:59,770
important that we are going to inject

00:17:56,380 --> 00:18:01,210
into a particular position in C++

00:17:59,770 --> 00:18:03,640
so I'm gonna come back and talk about

00:18:01,210 --> 00:18:05,620
this thing a little bit this is not

00:18:03,640 --> 00:18:08,350
actually a magic declaration by itself

00:18:05,620 --> 00:18:10,540
this is syntactic sugar in fact this

00:18:08,350 --> 00:18:14,200
actually boils down to this little bit

00:18:10,540 --> 00:18:15,940
of code right here so this thing is

00:18:14,200 --> 00:18:17,830
constable block this is called a meta

00:18:15,940 --> 00:18:20,679
program or is what I've been calling

00:18:17,830 --> 00:18:22,090
them in a program this is a sequence of

00:18:20,679 --> 00:18:24,010
statements that are executed where they

00:18:22,090 --> 00:18:25,870
appear in the program so as you parse

00:18:24,010 --> 00:18:27,760
this thing you enter the contest eval

00:18:25,870 --> 00:18:30,160
block and you start executing statements

00:18:27,760 --> 00:18:31,840
and the only thing that this this

00:18:30,160 --> 00:18:34,630
constant email block actually executes

00:18:31,840 --> 00:18:36,340
is this statement which is an injection

00:18:34,630 --> 00:18:37,510
statement and this is the workforce of

00:18:36,340 --> 00:18:40,179
source code of source code injection

00:18:37,510 --> 00:18:42,090
this is how things actually work how the

00:18:40,179 --> 00:18:44,050
how the declaration actually works so

00:18:42,090 --> 00:18:45,460
just like before I said we're going to

00:18:44,050 --> 00:18:47,440
open up the fragment and copy this in

00:18:45,460 --> 00:18:48,760
that's not quite the whole story really

00:18:47,440 --> 00:18:50,650
what happens is that we open up the

00:18:48,760 --> 00:18:52,690
fragment we start replaying those

00:18:50,650 --> 00:18:54,610
members each of the members in the

00:18:52,690 --> 00:18:56,679
fragment but each of those members

00:18:54,610 --> 00:18:59,559
actually ends up being a request to

00:18:56,679 --> 00:19:01,390
inject this code later so we don't

00:18:59,559 --> 00:19:03,070
actually modify the program as this

00:19:01,390 --> 00:19:05,559
thing executes all we're doing is

00:19:03,070 --> 00:19:07,630
queueing requests to inject code at a

00:19:05,559 --> 00:19:11,200
particular point in the future in fact

00:19:07,630 --> 00:19:12,910
here at the end of the meta program so

00:19:11,200 --> 00:19:15,370
anything that would generate code is

00:19:12,910 --> 00:19:17,410
only ever actually finalized kind of

00:19:15,370 --> 00:19:19,150
like transactionally emitted into your

00:19:17,410 --> 00:19:21,250
program at the end of the evaluation of

00:19:19,150 --> 00:19:23,290
this meta program and the reason we did

00:19:21,250 --> 00:19:25,559
this was actually pretty important if

00:19:23,290 --> 00:19:27,880
you for example if you have a loop a

00:19:25,559 --> 00:19:30,000
compiled time loop that is reflecting

00:19:27,880 --> 00:19:32,320
over all the members of your class and

00:19:30,000 --> 00:19:34,990
you're injecting members into your class

00:19:32,320 --> 00:19:39,720
at the same time your loop will not

00:19:34,990 --> 00:19:39,720
terminate and I know this for a fact

00:19:40,680 --> 00:19:45,610
because the implementation used to do

00:19:42,760 --> 00:19:46,990
that so we end up having that we end up

00:19:45,610 --> 00:19:48,820
buffering all these things so all of

00:19:46,990 --> 00:19:50,830
your all of your injections happen at

00:19:48,820 --> 00:19:52,120
one point and they're not visible you

00:19:50,830 --> 00:19:53,680
can't even you can't observe that an

00:19:52,120 --> 00:19:58,260
injection happened until the meta

00:19:53,680 --> 00:19:59,560
program app ends can we do after okay

00:19:58,260 --> 00:20:01,510
all right

00:19:59,560 --> 00:20:04,360
I mentioned facades before they're

00:20:01,510 --> 00:20:07,930
making a comeback boost iterator facade

00:20:04,360 --> 00:20:09,850
so a facade is essentially just a little

00:20:07,930 --> 00:20:12,340
tool for building classes that model

00:20:09,850 --> 00:20:13,570
concepts boost iterator facade is a

00:20:12,340 --> 00:20:14,710
great example of this I think is

00:20:13,570 --> 00:20:17,710
probably the first example that I'm

00:20:14,710 --> 00:20:20,050
familiar with implementing iterators is

00:20:17,710 --> 00:20:22,510
a pain you have to provide like a dozen

00:20:20,050 --> 00:20:25,450
overloads and there's really only five

00:20:22,510 --> 00:20:27,400
functions that all of those invoke you

00:20:25,450 --> 00:20:28,810
can dereference something you can

00:20:27,400 --> 00:20:31,000
dereference them you can increment them

00:20:28,810 --> 00:20:32,920
you can compare them for equality those

00:20:31,000 --> 00:20:34,380
are the three for input iterators those

00:20:32,920 --> 00:20:36,250
are the three essential functions

00:20:34,380 --> 00:20:37,000
everything else is derived from these

00:20:36,250 --> 00:20:38,980
three functions

00:20:37,000 --> 00:20:41,050
so these iterator facades actually gave

00:20:38,980 --> 00:20:42,700
us a tool for simplified or implicit

00:20:41,050 --> 00:20:46,510
implementations of more complex concepts

00:20:42,700 --> 00:20:48,250
I was going to write this example to use

00:20:46,510 --> 00:20:50,500
equality comparison and like less than

00:20:48,250 --> 00:20:52,090
comparison but it would have been a bit

00:20:50,500 --> 00:20:56,050
self-defeating because this we had the

00:20:52,090 --> 00:20:57,190
spaceship operator and C++ 20 so so we

00:20:56,050 --> 00:20:59,740
get iterator facades

00:20:57,190 --> 00:21:00,910
so the boost iterator prasat by the way

00:20:59,740 --> 00:21:03,040
is a base class it's one of these

00:21:00,910 --> 00:21:05,050
curiously recurring templates you you

00:21:03,040 --> 00:21:06,520
derive from it you you provide as a

00:21:05,050 --> 00:21:08,980
template argument the class that you're

00:21:06,520 --> 00:21:10,480
defining and then it out a bunch of

00:21:08,980 --> 00:21:13,180
declarations that are instantiated later

00:21:10,480 --> 00:21:14,980
on when you use them so we're gonna do

00:21:13,180 --> 00:21:16,900
something similar so this is this is the

00:21:14,980 --> 00:21:19,480
declaration of my input iterator facade

00:21:16,900 --> 00:21:21,700
sadly it broke the line on the slide so

00:21:19,480 --> 00:21:23,560
I had to wrap it around but it's the

00:21:21,700 --> 00:21:24,670
same same idea we had before the only

00:21:23,560 --> 00:21:27,010
real differences that we've actually

00:21:24,670 --> 00:21:28,270
given this a name it's pretty important

00:21:27,010 --> 00:21:30,250
sometimes that you have to be able to

00:21:28,270 --> 00:21:35,110
name these concept or sorry not a

00:21:30,250 --> 00:21:36,940
concept these fragments because

00:21:35,110 --> 00:21:38,500
sometimes you have member declarations

00:21:36,940 --> 00:21:40,450
that actually refer to them right like

00:21:38,500 --> 00:21:42,340
you can't have a pointer to a node a

00:21:40,450 --> 00:21:44,500
node class without being able to name

00:21:42,340 --> 00:21:46,270
that class so we make the name available

00:21:44,500 --> 00:21:47,980
here the name this the visibility the

00:21:46,270 --> 00:21:49,570
name ends at the closing brace of the

00:21:47,980 --> 00:21:52,210
struct so it's not like it's introducing

00:21:49,570 --> 00:21:53,980
this name beyond the scope of the

00:21:52,210 --> 00:21:55,630
fragment

00:21:53,980 --> 00:21:57,820
so here's my definition of the deckle

00:21:55,630 --> 00:22:00,070
type Otto iterator sorry the the

00:21:57,820 --> 00:22:02,049
dereferencing operator return to tech

00:22:00,070 --> 00:22:04,990
will type Otto so it's deduced and it

00:22:02,049 --> 00:22:06,610
returns this arrow Deere F now if you

00:22:04,990 --> 00:22:09,309
guys look at this in the following

00:22:06,610 --> 00:22:11,590
slides closely you'll notice that there

00:22:09,309 --> 00:22:16,750
is no declaration of dear F inside of

00:22:11,590 --> 00:22:19,360
this fragment that's because fragments

00:22:16,750 --> 00:22:20,919
are dependent they actually depend on

00:22:19,360 --> 00:22:23,529
the context in which you in which you

00:22:20,919 --> 00:22:25,330
insert them or inject them right so

00:22:23,529 --> 00:22:26,620
remember a fragment is just a piece of

00:22:25,330 --> 00:22:28,510
code that is going to be injected

00:22:26,620 --> 00:22:31,240
somewhere it actually depends entirely

00:22:28,510 --> 00:22:33,100
on the context where it's injected so

00:22:31,240 --> 00:22:35,320
when we write this arrow D ref we're

00:22:33,100 --> 00:22:37,120
basically delaying the lookup of D ref

00:22:35,320 --> 00:22:39,340
and tell the point that we inject it

00:22:37,120 --> 00:22:41,230
this is basically to face look up for

00:22:39,340 --> 00:22:42,549
templates if this were dependent if this

00:22:41,230 --> 00:22:44,830
were a template and it had a dependent

00:22:42,549 --> 00:22:46,360
base that's how you get deferred lookup

00:22:44,830 --> 00:22:49,450
for your base class intent and to fit in

00:22:46,360 --> 00:22:50,889
templates right same principle so then

00:22:49,450 --> 00:22:52,419
when we go to inject this thing we

00:22:50,889 --> 00:22:54,279
instantiate this definition then we'll

00:22:52,419 --> 00:22:56,500
do the lookup the delayed look up and

00:22:54,279 --> 00:22:57,549
we'll find hopefully a dereferencing

00:22:56,500 --> 00:23:01,149
function that will actually make the

00:22:57,549 --> 00:23:02,679
function work incrementing saying my

00:23:01,149 --> 00:23:05,080
same idea you can see that this error of

00:23:02,679 --> 00:23:06,720
increment home anything interesting here

00:23:05,080 --> 00:23:08,500
is we actually named the type itself

00:23:06,720 --> 00:23:10,480
effectively what's going to happen when

00:23:08,500 --> 00:23:12,399
we inject this declaration into an

00:23:10,480 --> 00:23:14,080
actual iterator is that that name will

00:23:12,399 --> 00:23:14,649
be replaced by the name of the iterator

00:23:14,080 --> 00:23:17,019
itself

00:23:14,649 --> 00:23:19,450
the quality operators we can derive this

00:23:17,019 --> 00:23:21,039
way not particularly exciting at this

00:23:19,450 --> 00:23:24,220
point again they they self reference

00:23:21,039 --> 00:23:25,809
this type using the image using the

00:23:24,220 --> 00:23:27,639
facade is pretty trivial we just use a

00:23:25,809 --> 00:23:29,559
constant or sorry injection declaration

00:23:27,639 --> 00:23:32,289
constant evil arrow input iterator

00:23:29,559 --> 00:23:35,620
facade and you're done everything works

00:23:32,289 --> 00:23:36,850
out the injection in this case and I

00:23:35,620 --> 00:23:38,320
want to point this out because this is

00:23:36,850 --> 00:23:41,110
one of the important substitutions that

00:23:38,320 --> 00:23:44,110
we apply when you inject a a class

00:23:41,110 --> 00:23:46,990
fragment into a class we actually set up

00:23:44,110 --> 00:23:48,580
a substitution from the name of the

00:23:46,990 --> 00:23:50,649
fragment to the name of the class that

00:23:48,580 --> 00:23:52,330
you're instantiated into so anywhere you

00:23:50,649 --> 00:23:53,919
use the name of that type inside of your

00:23:52,330 --> 00:23:55,630
fragment now becomes the type that

00:23:53,919 --> 00:23:59,019
you've injected this into so anything

00:23:55,630 --> 00:24:02,710
that was you know iterator facade dude I

00:23:59,019 --> 00:24:04,509
name that I named that correctly yeah

00:24:02,710 --> 00:24:06,969
sure that's fine

00:24:04,509 --> 00:24:08,139
I'm not saying I'm not insane so

00:24:06,969 --> 00:24:09,699
anywhere we use the name iterator to

00:24:08,139 --> 00:24:11,409
refer the type inside of that that

00:24:09,699 --> 00:24:13,659
fragment will would be replaced by

00:24:11,409 --> 00:24:15,429
listed orator in the enclosing class and

00:24:13,659 --> 00:24:17,589
of course anything that was associated

00:24:15,429 --> 00:24:18,909
through that dependent type will also be

00:24:17,589 --> 00:24:21,699
instantiated in kind of the same way

00:24:18,909 --> 00:24:23,049
just like a template so we end up

00:24:21,699 --> 00:24:24,429
generating code that looks like this I

00:24:23,049 --> 00:24:25,869
left off the equality operators because

00:24:24,429 --> 00:24:27,969
it would have pushed too much off the

00:24:25,869 --> 00:24:30,399
slide at bottom of the slide so you can

00:24:27,969 --> 00:24:32,379
actually see where the where the where

00:24:30,399 --> 00:24:33,969
the transformations happened except I

00:24:32,379 --> 00:24:39,549
forgot to change the operator star to a

00:24:33,969 --> 00:24:41,219
deco type motto so that was my second

00:24:39,549 --> 00:24:45,819
objection or second example

00:24:41,219 --> 00:24:48,249
so getters get functions I'm leaving out

00:24:45,819 --> 00:24:51,969
centers it's just redundant at this

00:24:48,249 --> 00:24:54,009
point I I don't write code this way but

00:24:51,969 --> 00:24:56,039
I know that some people do and some

00:24:54,009 --> 00:24:59,499
people really like getters and setters

00:24:56,039 --> 00:25:02,349
so we give an example okay so here's a

00:24:59,499 --> 00:25:06,009
book class it has some properties title

00:25:02,349 --> 00:25:07,569
author page count by the way this

00:25:06,009 --> 00:25:08,829
example actually evolved after my talk

00:25:07,569 --> 00:25:10,779
Monday because somebody asked if you

00:25:08,829 --> 00:25:12,339
could reflect on attributes and I said

00:25:10,779 --> 00:25:13,779
no the implementation doesn't reflect on

00:25:12,339 --> 00:25:15,879
attributes yet we haven't talked about

00:25:13,779 --> 00:25:18,099
it and evolution that much and in the

00:25:15,879 --> 00:25:19,329
committee that much and so I was going

00:25:18,099 --> 00:25:22,029
to write this example up but then I

00:25:19,329 --> 00:25:25,269
thought if I just present this as is

00:25:22,029 --> 00:25:26,529
then anytime I apply this meta program

00:25:25,269 --> 00:25:28,389
to transform thing I'm going to generate

00:25:26,529 --> 00:25:31,749
getters for every single member variable

00:25:28,389 --> 00:25:33,279
and that doesn't seem saying you know

00:25:31,749 --> 00:25:34,629
what let's just go ahead and add the

00:25:33,279 --> 00:25:37,979
ability to reflect on attributes and see

00:25:34,629 --> 00:25:37,979
if we can get this done better so

00:25:39,170 --> 00:25:44,150
so that happens this is this is the

00:25:42,920 --> 00:25:46,490
implementation change that might not be

00:25:44,150 --> 00:25:48,920
available on compiler Explorer because

00:25:46,490 --> 00:25:49,250
it was last night that it got pushed all

00:25:48,920 --> 00:25:51,920
right

00:25:49,250 --> 00:25:53,390
so yes we do have a get attribute that

00:25:51,920 --> 00:25:56,000
will tell that will inform a meta

00:25:53,390 --> 00:25:57,580
program later on to generate code the

00:25:56,000 --> 00:25:59,900
code in this case actually comes from

00:25:57,580 --> 00:26:01,220
this meta program notice there's no

00:25:59,900 --> 00:26:02,870
arrow in here there's no injection

00:26:01,220 --> 00:26:04,850
statement you don't have to have them

00:26:02,870 --> 00:26:06,830
directly an injection in meta programs

00:26:04,850 --> 00:26:08,390
that's fantastic they can just live in

00:26:06,830 --> 00:26:14,470
normal Const expert functions or

00:26:08,390 --> 00:26:18,050
constant Valens I guess I guess but I

00:26:14,470 --> 00:26:20,330
will so this this function Jen getters

00:26:18,050 --> 00:26:22,010
takes a reflection of the book so

00:26:20,330 --> 00:26:24,350
essentially we're generating that

00:26:22,010 --> 00:26:25,460
reflection gives you a view of of the

00:26:24,350 --> 00:26:27,590
class and everything that's been

00:26:25,460 --> 00:26:28,880
declared in that class so far and so we

00:26:27,590 --> 00:26:30,410
can actually observe those properties

00:26:28,880 --> 00:26:32,330
and figure out like what code we want to

00:26:30,410 --> 00:26:35,210
generate and I will let you guys digest

00:26:32,330 --> 00:26:36,620
that when I take a sip of water by the

00:26:35,210 --> 00:26:42,860
way if you didn't see the talk on Monday

00:26:36,620 --> 00:26:45,440
this will be very foreign I did mention

00:26:42,860 --> 00:26:48,170
this built on static reflection to be

00:26:45,440 --> 00:26:51,290
fair okay so the function is actually

00:26:48,170 --> 00:26:52,430
fairly straightforward we're just going

00:26:51,290 --> 00:26:53,720
to get the members of the class the

00:26:52,430 --> 00:26:56,090
members of operator will give me the

00:26:53,720 --> 00:26:58,490
list of all of these members range based

00:26:56,090 --> 00:27:00,230
for loop walks directly over those if

00:26:58,490 --> 00:27:02,840
the member is a non-static data member

00:27:00,230 --> 00:27:04,880
and and it has the attribute and that's

00:27:02,840 --> 00:27:07,670
the new bit then we're going to generate

00:27:04,880 --> 00:27:11,230
the getter function make sense not

00:27:07,670 --> 00:27:15,020
particularly complicated which is good

00:27:11,230 --> 00:27:16,250
this is worse all right so this is the

00:27:15,020 --> 00:27:18,680
Jen get our function there's there's a

00:27:16,250 --> 00:27:20,170
bunch of new stuff here first of all the

00:27:18,680 --> 00:27:23,390
injection statement actually just

00:27:20,170 --> 00:27:24,590
injects the fragment directly you don't

00:27:23,390 --> 00:27:26,390
you don't have to have it defined her

00:27:24,590 --> 00:27:28,310
declared anywhere and it's just a value

00:27:26,390 --> 00:27:30,620
we can generate these values in the fly

00:27:28,310 --> 00:27:34,490
so this works out nicely now the thing

00:27:30,620 --> 00:27:35,690
inside of here if you squint you might

00:27:34,490 --> 00:27:40,310
be able to see that it declares a

00:27:35,690 --> 00:27:42,290
function that is a dick that is a member

00:27:40,310 --> 00:27:45,710
declared ER or it's a member declaration

00:27:42,290 --> 00:27:48,500
sorry the first line names the type and

00:27:45,710 --> 00:27:50,090
the second name generates a name for a

00:27:48,500 --> 00:27:51,760
function I'm going to walk through these

00:27:50,090 --> 00:27:54,640
and explain those in a second

00:27:51,760 --> 00:27:55,990
so generating the type so this is the

00:27:54,640 --> 00:28:00,400
one of these static reflection upper

00:27:55,990 --> 00:28:01,780
operations the deification operator type

00:28:00,400 --> 00:28:03,340
name is the reification operator it

00:28:01,780 --> 00:28:05,500
takes a reflection of a type and it

00:28:03,340 --> 00:28:07,510
generates a type name so if the type of

00:28:05,500 --> 00:28:11,920
the member was int this would generate

00:28:07,510 --> 00:28:13,870
the type in con strength right okay

00:28:11,920 --> 00:28:17,980
there's one small thing that needs to be

00:28:13,870 --> 00:28:20,950
observed here that needs to be a

00:28:17,980 --> 00:28:22,120
constant expression because it we're

00:28:20,950 --> 00:28:24,100
going to generate code you can only

00:28:22,120 --> 00:28:26,110
operate on constant expressions right

00:28:24,100 --> 00:28:27,520
think of like templates template

00:28:26,110 --> 00:28:29,050
arguments must be constant expressions

00:28:27,520 --> 00:28:31,210
you can't pass into X and then use that

00:28:29,050 --> 00:28:33,850
to instantiate an array from the array

00:28:31,210 --> 00:28:35,500
template right and the reason I know

00:28:33,850 --> 00:28:37,510
that's not this isn't a constant

00:28:35,500 --> 00:28:39,820
expression because M is not a constant

00:28:37,510 --> 00:28:43,180
expression it's a parameter it's not a

00:28:39,820 --> 00:28:44,530
constant so there's something weird

00:28:43,180 --> 00:28:47,650
going on here right because this

00:28:44,530 --> 00:28:48,820
actually does work it turns out that

00:28:47,650 --> 00:28:51,340
we've we've made this decision that

00:28:48,820 --> 00:28:55,110
fragments are there kind of implicitly

00:28:51,340 --> 00:28:57,550
parameterised so inside of a fragment

00:28:55,110 --> 00:29:00,250
inside of a fragment if a name refers to

00:28:57,550 --> 00:29:01,780
a local variable what we really do is we

00:29:00,250 --> 00:29:03,280
actually kind of replace that name with

00:29:01,780 --> 00:29:05,200
a place like a constant expression

00:29:03,280 --> 00:29:06,850
placeholder so if we come back here and

00:29:05,200 --> 00:29:09,160
look at the M in this case that's not

00:29:06,850 --> 00:29:10,720
that's not really the same M that M

00:29:09,160 --> 00:29:13,230
inside of the type name operator

00:29:10,720 --> 00:29:15,190
actually refers to this invisible

00:29:13,230 --> 00:29:18,010
placeholder that we've declared as part

00:29:15,190 --> 00:29:19,420
of the fragment and the reason we do

00:29:18,010 --> 00:29:21,040
that is because that actually makes this

00:29:19,420 --> 00:29:22,870
a constant expression but also dependent

00:29:21,040 --> 00:29:25,210
and it allows us to defer the meaning of

00:29:22,870 --> 00:29:30,340
that type name operator until some point

00:29:25,210 --> 00:29:31,750
in the future because we do this because

00:29:30,340 --> 00:29:33,550
we actually have this this these

00:29:31,750 --> 00:29:35,470
placeholders when you think about the

00:29:33,550 --> 00:29:36,970
actual value of the fragment when you

00:29:35,470 --> 00:29:38,650
evaluate this thing at compile time

00:29:36,970 --> 00:29:40,930
during constant event expression

00:29:38,650 --> 00:29:43,180
evaluation the value of a fragment is

00:29:40,930 --> 00:29:45,940
actually two things it's not just the

00:29:43,180 --> 00:29:47,620
reflection of the class it's also this

00:29:45,940 --> 00:29:49,240
mapping of the parameters that we those

00:29:47,620 --> 00:29:51,730
implicit parameters as placeholders to

00:29:49,240 --> 00:29:53,080
the values that we've just computed so

00:29:51,730 --> 00:29:55,090
there's like a little contextual like

00:29:53,080 --> 00:29:56,890
almost like a closure that follows

00:29:55,090 --> 00:30:01,690
around this fragment that we're going to

00:29:56,890 --> 00:30:03,010
rely on later to generate code so if you

00:30:01,690 --> 00:30:04,510
want to like this this way the way is

00:30:03,010 --> 00:30:05,350
really hard to work out the first time I

00:30:04,510 --> 00:30:07,299
implemented

00:30:05,350 --> 00:30:08,500
and I've always struggled to explain it

00:30:07,299 --> 00:30:10,510
but there's really three things to look

00:30:08,500 --> 00:30:12,309
at here so if you think about the way

00:30:10,510 --> 00:30:14,080
this works we have to analyze the

00:30:12,309 --> 00:30:15,789
fragment during parsing we see the

00:30:14,080 --> 00:30:17,380
fragment again during evaluation and

00:30:15,789 --> 00:30:19,179
then there's we see the fragment again

00:30:17,380 --> 00:30:20,470
during source code injection or at least

00:30:19,179 --> 00:30:21,160
the compiler sees it in the last case

00:30:20,470 --> 00:30:24,010
right

00:30:21,160 --> 00:30:25,480
so during parsing what happens is you

00:30:24,010 --> 00:30:26,919
get in the fragment we actually go ahead

00:30:25,480 --> 00:30:28,390
and pre identify all of our local

00:30:26,919 --> 00:30:30,880
variables and just set up placeholders

00:30:28,390 --> 00:30:32,470
for them we just pre declare them so

00:30:30,880 --> 00:30:34,480
anything that was a local variable

00:30:32,470 --> 00:30:36,130
before inside of the fragment is now

00:30:34,480 --> 00:30:38,409
going to be a constant expression

00:30:36,130 --> 00:30:39,850
placeholder during an evaluation we

00:30:38,409 --> 00:30:41,770
actually create a mapping between those

00:30:39,850 --> 00:30:43,630
those placeholders and the values that

00:30:41,770 --> 00:30:46,419
have the same names the local variables

00:30:43,630 --> 00:30:47,620
to name them during injection so when we

00:30:46,419 --> 00:30:49,059
actually go to cue the injection from

00:30:47,620 --> 00:30:50,980
the injection statement we just pass a

00:30:49,059 --> 00:30:53,230
password that entire thing the closure

00:30:50,980 --> 00:30:56,440
closures thing plus the reflection and

00:30:53,230 --> 00:30:58,030
then during injection we actually set up

00:30:56,440 --> 00:30:59,500
additional substitution from those

00:30:58,030 --> 00:31:01,720
placeholders back to the parameters that

00:30:59,500 --> 00:31:04,000
they made that they that they that

00:31:01,720 --> 00:31:06,490
they're mapped to it's a it's a fairly

00:31:04,000 --> 00:31:07,470
complicated process but the results are

00:31:06,490 --> 00:31:09,220
kind of cool

00:31:07,470 --> 00:31:12,010
I'll show you what it looks like in a

00:31:09,220 --> 00:31:13,450
second so the unqualified part it also

00:31:12,010 --> 00:31:13,750
has one of these little placeholders in

00:31:13,450 --> 00:31:17,440
there

00:31:13,750 --> 00:31:19,690
unqualified operator it's a weird one it

00:31:17,440 --> 00:31:21,909
generates an identifier especially

00:31:19,690 --> 00:31:24,760
generates an unqualified identifier that

00:31:21,909 --> 00:31:27,640
has not yet been looked up so it the

00:31:24,760 --> 00:31:30,880
employee ID and qualit a sequence of

00:31:27,640 --> 00:31:32,440
things usually strings and integers so

00:31:30,880 --> 00:31:33,880
we actually generate in this case is

00:31:32,440 --> 00:31:35,770
gonna be get with an underscore followed

00:31:33,880 --> 00:31:37,210
by the name of whatever member it was so

00:31:35,770 --> 00:31:39,280
if the member variable was titled this

00:31:37,210 --> 00:31:41,620
is get title if member variable was

00:31:39,280 --> 00:31:43,240
author this is get author and so forth

00:31:41,620 --> 00:31:45,490
and so on and then the last thing we

00:31:43,240 --> 00:31:47,559
returned that because we can't actually

00:31:45,490 --> 00:31:49,179
like save the name of an identifier we

00:31:47,559 --> 00:31:50,380
don't have a mechanism for doing that we

00:31:49,179 --> 00:31:53,470
have to keep repeating the unqualified

00:31:50,380 --> 00:31:54,970
ID construction so far so we just use it

00:31:53,470 --> 00:31:56,110
again you get the name of the member so

00:31:54,970 --> 00:31:57,850
this would be you know for the member

00:31:56,110 --> 00:32:00,250
variable author it would be return

00:31:57,850 --> 00:32:02,559
author and all those names are gonna be

00:32:00,250 --> 00:32:04,510
looked up and resolved when we inject

00:32:02,559 --> 00:32:05,980
this what do we inject this function and

00:32:04,510 --> 00:32:08,260
actually might be lying about that a

00:32:05,980 --> 00:32:10,419
little bit let me see what's next okay

00:32:08,260 --> 00:32:11,590
so yeah this is what happens when you

00:32:10,419 --> 00:32:15,040
actually run the code so if we had a

00:32:11,590 --> 00:32:16,630
string a property called title with the

00:32:15,040 --> 00:32:19,289
attribute get we're actually going to

00:32:16,630 --> 00:32:27,099
generate the code get title make sense

00:32:19,289 --> 00:32:28,210
okay so trying to think if there's

00:32:27,099 --> 00:32:34,570
anything else that was interesting to

00:32:28,210 --> 00:32:36,729
say about this yes I left something out

00:32:34,570 --> 00:32:39,399
the reason that we actually have this

00:32:36,729 --> 00:32:41,649
this process and this is this is kind of

00:32:39,399 --> 00:32:43,509
fundamental the reason that we have this

00:32:41,649 --> 00:32:45,969
process of setting these things up is

00:32:43,509 --> 00:32:48,729
specifically to defer the generation of

00:32:45,969 --> 00:32:51,399
code as long as possible it turns out

00:32:48,729 --> 00:32:53,649
that we can't generate code during

00:32:51,399 --> 00:32:55,210
compile time evaluation because compile

00:32:53,649 --> 00:32:56,799
time evaluation generally has this

00:32:55,210 --> 00:32:58,929
principle that or this rule that you

00:32:56,799 --> 00:33:00,159
can't have side-effects generating the

00:32:58,929 --> 00:33:02,559
code that modifies generating code that

00:33:00,159 --> 00:33:05,529
modifies your program is a fairly heavy

00:33:02,559 --> 00:33:06,879
side effect of evaluation right so we

00:33:05,529 --> 00:33:08,649
still need we need some way to actually

00:33:06,879 --> 00:33:10,809
bridge compile to that context for

00:33:08,649 --> 00:33:12,129
evaluation and code generation and the

00:33:10,809 --> 00:33:13,629
only way that we can do this is to

00:33:12,129 --> 00:33:15,549
actually package up these values that

00:33:13,629 --> 00:33:17,529
we've computed along with code we want

00:33:15,549 --> 00:33:18,190
to generate and just defer that as long

00:33:17,529 --> 00:33:20,109
as possible

00:33:18,190 --> 00:33:21,999
which happens to the ideal point happens

00:33:20,109 --> 00:33:24,309
to be at the end of the meta program

00:33:21,999 --> 00:33:27,929
where you inject it now there is a

00:33:24,309 --> 00:33:30,599
little bit of an interesting thing here

00:33:27,929 --> 00:33:34,389
this is actually injected in two parts

00:33:30,599 --> 00:33:36,460
so we inject the declaration first just

00:33:34,389 --> 00:33:38,019
to create you know get title and then

00:33:36,460 --> 00:33:40,179
imagine measurement being followed by a

00:33:38,019 --> 00:33:42,820
semicolon and then at the end of the

00:33:40,179 --> 00:33:44,409
class at the end of this class we

00:33:42,820 --> 00:33:45,849
actually go back and inject the

00:33:44,409 --> 00:33:48,669
definition we create the definition

00:33:45,849 --> 00:33:50,080
later this is basically the same pattern

00:33:48,669 --> 00:33:53,349
that you have when you write a class to

00:33:50,080 --> 00:33:55,570
begin with if you haven't in my member

00:33:53,349 --> 00:33:56,979
function definition you're allowed to

00:33:55,570 --> 00:33:59,200
refer to member variables that haven't

00:33:56,979 --> 00:34:00,999
been declared yet that's because all the

00:33:59,200 --> 00:34:03,129
analysis of the definition is deferred

00:34:00,999 --> 00:34:04,359
until the end of the class I think the

00:34:03,129 --> 00:34:07,980
magic keywords here for this are a

00:34:04,359 --> 00:34:10,270
complete complete complete class context

00:34:07,980 --> 00:34:12,129
so we do the exact same thing with

00:34:10,270 --> 00:34:14,020
injection it's almost like you were

00:34:12,129 --> 00:34:18,490
writing this by hand which was kind of a

00:34:14,020 --> 00:34:20,950
goal emulating these things so this is

00:34:18,490 --> 00:34:22,000
my last example which apparently has

00:34:20,950 --> 00:34:23,529
talked a little bit shorter than I

00:34:22,000 --> 00:34:26,560
thought but that's okay

00:34:23,529 --> 00:34:28,330
plenty of time for questions

00:34:26,560 --> 00:34:33,130
okay so you guys know what existential

00:34:28,330 --> 00:34:37,360
types are some abstract data types type

00:34:33,130 --> 00:34:40,570
classes rust type traits okay

00:34:37,360 --> 00:34:42,040
so abstract data type is well these are

00:34:40,570 --> 00:34:43,450
basically abstract data types so

00:34:42,040 --> 00:34:45,550
conceptually these are just a pair of an

00:34:43,450 --> 00:34:47,290
abstract interface and a concrete

00:34:45,550 --> 00:34:49,179
implementation there's lots of ways

00:34:47,290 --> 00:34:52,179
these get that these can get reified in

00:34:49,179 --> 00:34:53,919
C++ you can even think of them as like

00:34:52,179 --> 00:34:57,490
abstract base classes and derive classes

00:34:53,919 --> 00:34:59,260
that's not unreasonable type traits like

00:34:57,490 --> 00:35:00,610
rust traits are kind of an example of

00:34:59,260 --> 00:35:03,940
these type classes are kind of an

00:35:00,610 --> 00:35:06,280
example of these lately in C++ we've

00:35:03,940 --> 00:35:08,470
gotten really fond of using any types or

00:35:06,280 --> 00:35:11,350
type erasure to generate these kinds of

00:35:08,470 --> 00:35:13,720
things in fact actually an existential

00:35:11,350 --> 00:35:14,800
type is really a type erased like think

00:35:13,720 --> 00:35:18,730
the purest expression of these is

00:35:14,800 --> 00:35:19,990
actually a type erased object so I just

00:35:18,730 --> 00:35:21,940
want to point out that these slides are

00:35:19,990 --> 00:35:27,040
actually based on work that cybron has

00:35:21,940 --> 00:35:30,040
done there's a github repo here this is

00:35:27,040 --> 00:35:32,110
actually really interesting code I found

00:35:30,040 --> 00:35:33,610
myself looking at it for about two hours

00:35:32,110 --> 00:35:39,660
this morning trying to figure out what

00:35:33,610 --> 00:35:42,220
it did and you should take a look so

00:35:39,660 --> 00:35:43,630
this is these are the examples that Sai

00:35:42,220 --> 00:35:44,620
gives it is repository them - I'm

00:35:43,630 --> 00:35:47,500
actually gonna talk about a little bit

00:35:44,620 --> 00:35:49,300
so I have this case I have some

00:35:47,500 --> 00:35:52,000
producers have a static producer that

00:35:49,300 --> 00:35:53,830
just returns a constant value fantastic

00:35:52,000 --> 00:35:55,750
always the value 42 there's no reason

00:35:53,830 --> 00:35:57,610
for it to be anything else and then I

00:35:55,750 --> 00:35:59,020
have a dynamic producer which just you

00:35:57,610 --> 00:36:01,510
know generates an increasing sequence of

00:35:59,020 --> 00:36:03,940
integer values but the problem that I

00:36:01,510 --> 00:36:06,070
have is that I want a list of like a

00:36:03,940 --> 00:36:07,330
vector of both of these that

00:36:06,070 --> 00:36:09,430
intersperses static and dynamic

00:36:07,330 --> 00:36:11,050
producers right pretty common problem

00:36:09,430 --> 00:36:13,630
there's a bunch of different ways you

00:36:11,050 --> 00:36:17,410
can solve it for example we could we

00:36:13,630 --> 00:36:20,770
could do this we can generate a an

00:36:17,410 --> 00:36:23,050
abstract based class go and derive from

00:36:20,770 --> 00:36:25,120
that in each case make a vector of

00:36:23,050 --> 00:36:26,980
unique pointers shared pointers do

00:36:25,120 --> 00:36:30,360
whatever you want here just you know as

00:36:26,980 --> 00:36:33,100
usual no naked pointers that's bad C++

00:36:30,360 --> 00:36:35,310
but I have I have I have problems with

00:36:33,100 --> 00:36:35,310
this

00:36:36,099 --> 00:36:39,249
first of all I might not actually own

00:36:37,719 --> 00:36:41,529
static and dynamic producer I might not

00:36:39,249 --> 00:36:43,180
be able to modify that code so this is

00:36:41,529 --> 00:36:44,739
already a non-starter if that's in a lot

00:36:43,180 --> 00:36:46,930
if it's in another library I can't do

00:36:44,739 --> 00:36:49,170
this right you cannot inject base

00:36:46,930 --> 00:36:52,150
classes into somebody else's project I

00:36:49,170 --> 00:36:53,920
mean you could if you copy the project

00:36:52,150 --> 00:36:57,699
and then modified it that's not really

00:36:53,920 --> 00:36:59,140
the same thing so beyond the ability to

00:36:57,699 --> 00:37:00,249
not modify these things even if we did

00:36:59,140 --> 00:37:01,869
this gets us into like reference

00:37:00,249 --> 00:37:03,999
semantics world it's all you know 19

00:37:01,869 --> 00:37:05,769
tiny style object or any programming we

00:37:03,999 --> 00:37:06,969
lose this nice value semantic approach

00:37:05,769 --> 00:37:09,219
that we've kind of developed over the

00:37:06,969 --> 00:37:11,499
last decade or so in C++ so we don't

00:37:09,219 --> 00:37:12,519
really want to do that there is a second

00:37:11,499 --> 00:37:13,930
approach we can actually just jam these

00:37:12,519 --> 00:37:15,699
into a variant that would also be a

00:37:13,930 --> 00:37:17,769
viable approach but that would defeat

00:37:15,699 --> 00:37:21,009
the purpose of the next few slides so we

00:37:17,769 --> 00:37:22,089
don't want to do that the the other

00:37:21,009 --> 00:37:23,619
solution of course since we've already

00:37:22,089 --> 00:37:25,089
talked about type erasure is to go ahead

00:37:23,619 --> 00:37:27,849
and create a value somatic type erased

00:37:25,089 --> 00:37:29,739
object that manages an internal pointer

00:37:27,849 --> 00:37:32,979
to these things in the backend and then

00:37:29,739 --> 00:37:34,359
sets these things up right so this is

00:37:32,979 --> 00:37:36,069
what that program is going to know I

00:37:34,359 --> 00:37:36,940
would say this that implementing type of

00:37:36,069 --> 00:37:39,009
ratio by hand is hard

00:37:36,940 --> 00:37:40,299
has anybody how many people have done

00:37:39,009 --> 00:37:43,539
this like rolled their own type of race

00:37:40,299 --> 00:37:44,739
or value it's tedious you got to

00:37:43,539 --> 00:37:46,119
remember the pattern and then you got to

00:37:44,739 --> 00:37:48,789
get the pattern right and it's it's not

00:37:46,119 --> 00:37:50,440
a trivial amount of code right so of

00:37:48,789 --> 00:37:51,849
course of course and I talked about

00:37:50,440 --> 00:37:54,209
generative metaprogramming the the only

00:37:51,849 --> 00:37:56,979
right solution here was of course just

00:37:54,209 --> 00:37:59,650
generate it all right here's how we're

00:37:56,979 --> 00:38:01,959
going to do that so this is the program

00:37:59,650 --> 00:38:02,949
that we have to generate this code so

00:38:01,959 --> 00:38:04,420
this thing at the top I'm going to talk

00:38:02,949 --> 00:38:07,569
about a little bit but that defines the

00:38:04,420 --> 00:38:09,279
the existential pipe as it were where I

00:38:07,569 --> 00:38:11,319
think is the way that it's I calls it a

00:38:09,279 --> 00:38:13,089
type class and then we can just make a

00:38:11,319 --> 00:38:15,039
vector of those things vector producers

00:38:13,089 --> 00:38:17,440
we can in place back static and dynamic

00:38:15,039 --> 00:38:18,369
and this will just work we can access

00:38:17,440 --> 00:38:19,719
these members you call produce

00:38:18,369 --> 00:38:23,349
everything just works out it's perfectly

00:38:19,719 --> 00:38:25,180
fine right so this thing is a meta class

00:38:23,349 --> 00:38:27,279
declaration actually technically the

00:38:25,180 --> 00:38:30,729
meta class is just the the existential

00:38:27,279 --> 00:38:33,099
the name existential they're a meta

00:38:30,729 --> 00:38:36,009
class is really nothing more than a meta

00:38:33,099 --> 00:38:37,930
program that consumes basically that

00:38:36,009 --> 00:38:40,089
generates a new class from from some

00:38:37,930 --> 00:38:41,769
existing prototype so the producer class

00:38:40,089 --> 00:38:45,789
here that's going to be the prototype

00:38:41,769 --> 00:38:47,229
the existential meta class that's just a

00:38:45,789 --> 00:38:49,209
function that modified with that that

00:38:47,229 --> 00:38:49,730
could pulls that in and spits out a new

00:38:49,209 --> 00:38:51,320
class

00:38:49,730 --> 00:38:53,510
in fact the entire thing is really just

00:38:51,320 --> 00:38:56,540
syntactic sugar for this like this is

00:38:53,510 --> 00:38:59,450
all the magic of metaclasses they are

00:38:56,540 --> 00:39:00,770
they are not mysterious things they

00:38:59,450 --> 00:39:02,990
build on only the things that we've

00:39:00,770 --> 00:39:04,220
talked about in the previous slides so

00:39:02,990 --> 00:39:05,570
the way we do this is we take the

00:39:04,220 --> 00:39:07,370
initial class definition that initial

00:39:05,570 --> 00:39:09,380
producer and we stuff it into a hidden

00:39:07,370 --> 00:39:11,000
namespace just put it out of the way put

00:39:09,380 --> 00:39:12,530
it out of your mind for a second then

00:39:11,000 --> 00:39:13,730
we're gonna regenerate the producer

00:39:12,530 --> 00:39:15,800
class because that's really what we're

00:39:13,730 --> 00:39:17,060
generating and of course we'll just keep

00:39:15,800 --> 00:39:18,920
a link to the original the original

00:39:17,060 --> 00:39:20,360
declaration around for convenience

00:39:18,920 --> 00:39:20,870
because sometimes it's useful to see

00:39:20,360 --> 00:39:22,520
those things

00:39:20,870 --> 00:39:24,620
it's usefully useful be able to write

00:39:22,520 --> 00:39:26,060
write reflective queries or meta

00:39:24,620 --> 00:39:28,570
programs against those at some point in

00:39:26,060 --> 00:39:31,100
the future or even use them directly and

00:39:28,570 --> 00:39:34,130
the rest of this is just a meta program

00:39:31,100 --> 00:39:36,050
conceivable ock that calls existential

00:39:34,130 --> 00:39:37,880
the meta program and passes it a

00:39:36,050 --> 00:39:40,520
reflection of the class that you've just

00:39:37,880 --> 00:39:43,220
are though of the prototype that is that

00:39:40,520 --> 00:39:44,480
is the entirety of meta classes and by

00:39:43,220 --> 00:39:46,850
the way this design took a long time to

00:39:44,480 --> 00:39:49,040
figure out I was I was really happy when

00:39:46,850 --> 00:39:50,570
like the complexity of medical IBM and

00:39:49,040 --> 00:39:52,250
of the original complexity of the

00:39:50,570 --> 00:39:53,990
metaclass idea was reduced to this code

00:39:52,250 --> 00:39:55,220
because that means I don't have to do

00:39:53,990 --> 00:39:57,170
anything magic for them all I have to do

00:39:55,220 --> 00:39:59,330
is some scope manipulation and then just

00:39:57,170 --> 00:40:01,880
drive through all the facilities that we

00:39:59,330 --> 00:40:03,950
built remember that pyramid like all of

00:40:01,880 --> 00:40:06,440
that just builds on top of these so this

00:40:03,950 --> 00:40:08,390
is like the the easiest way to invoke

00:40:06,440 --> 00:40:11,270
this stuff that you hear it's fantastic

00:40:08,390 --> 00:40:15,230
I really like this line of code here so

00:40:11,270 --> 00:40:17,270
what does existential actually do a

00:40:15,230 --> 00:40:18,610
couple of things I'm actually not going

00:40:17,270 --> 00:40:20,690
to talk about the entire implementation

00:40:18,610 --> 00:40:22,700
there's enough there that warrants its

00:40:20,690 --> 00:40:24,050
own talk and I should not give that I

00:40:22,700 --> 00:40:25,850
think it should be up to SCI to get up

00:40:24,050 --> 00:40:27,950
here for an hour and explain what he's

00:40:25,850 --> 00:40:29,570
done because there's some really

00:40:27,950 --> 00:40:31,130
interesting design choices there and I'd

00:40:29,570 --> 00:40:32,660
really like to ask questions about so

00:40:31,130 --> 00:40:35,240
this is what existential does it's just

00:40:32,660 --> 00:40:36,820
an injects a class fragment so this this

00:40:35,240 --> 00:40:39,950
class fragment here that he's injecting

00:40:36,820 --> 00:40:43,660
this this is like the basic interface

00:40:39,950 --> 00:40:46,370
then the primary interface for managing

00:40:43,660 --> 00:40:48,380
the the construction of your sort of

00:40:46,370 --> 00:40:49,580
inner object types right so we have this

00:40:48,380 --> 00:40:51,590
storage class that's actually going to

00:40:49,580 --> 00:40:53,510
maintain the kind of like an internal

00:40:51,590 --> 00:40:55,100
pointer to the concrete type that we're

00:40:53,510 --> 00:40:57,710
going to create and then we have a

00:40:55,100 --> 00:41:00,020
constructor that's going to take a are

00:40:57,710 --> 00:41:01,970
you meant of that concrete type and

00:41:00,020 --> 00:41:04,490
just build it that's that's how you

00:41:01,970 --> 00:41:06,280
build these things right like that's the

00:41:04,490 --> 00:41:11,150
constructor that makes this code work

00:41:06,280 --> 00:41:12,950
the employees back stuff and then after

00:41:11,150 --> 00:41:14,150
it injects all of that stuff it just

00:41:12,950 --> 00:41:16,490
generates a bunch of calls to the fort

00:41:14,150 --> 00:41:19,480
this this generate calls call forwarders

00:41:16,490 --> 00:41:19,480
function is actually really interesting

00:41:19,810 --> 00:41:24,710
it takes all of the operations in the in

00:41:23,300 --> 00:41:26,420
the prototype which of which there's

00:41:24,710 --> 00:41:28,220
only one in this case produce and it

00:41:26,420 --> 00:41:29,630
effectively sets up another call that

00:41:28,220 --> 00:41:31,550
will call in through a sequence of

00:41:29,630 --> 00:41:33,440
objects in the inside so it's just

00:41:31,550 --> 00:41:35,089
duplicating the same interface but it's

00:41:33,440 --> 00:41:38,690
calling through to a bunch of internal

00:41:35,089 --> 00:41:41,180
structures this is basically the storage

00:41:38,690 --> 00:41:43,250
class I'm kind of I'm kind of alighting

00:41:41,180 --> 00:41:46,130
a bunch of code here so the storage

00:41:43,250 --> 00:41:47,869
class sits on a two interesting parts of

00:41:46,130 --> 00:41:50,420
this important part so it sits on a

00:41:47,869 --> 00:41:52,099
unique pointer to a model of the

00:41:50,420 --> 00:41:55,640
abstract type and here the abstract type

00:41:52,099 --> 00:41:57,020
is the the outer class the actual outer

00:41:55,640 --> 00:41:59,150
class not the prototype but the one that

00:41:57,020 --> 00:42:02,480
we've just generated so it's on a model

00:41:59,150 --> 00:42:04,400
to that a model of that and then in the

00:42:02,480 --> 00:42:06,710
constructor of this thing again we were

00:42:04,400 --> 00:42:09,770
forwarded in the object of the concrete

00:42:06,710 --> 00:42:11,690
type and we're going to make a unique

00:42:09,770 --> 00:42:14,450
object of the derived class which is an

00:42:11,690 --> 00:42:17,450
impulse track type along with the

00:42:14,450 --> 00:42:18,859
concrete type so model is going to end

00:42:17,450 --> 00:42:20,930
up being like the base class and a base

00:42:18,859 --> 00:42:23,710
class hierarchy and imple of whatever is

00:42:20,930 --> 00:42:27,500
going to be the derived class make sense

00:42:23,710 --> 00:42:28,820
sure and this is basically this is very

00:42:27,500 --> 00:42:29,839
vaguely what they look like I'm not

00:42:28,820 --> 00:42:31,790
going to talk about the implementations

00:42:29,839 --> 00:42:32,839
I'll just say what they do so the model

00:42:31,790 --> 00:42:34,550
ends up being the base class and this

00:42:32,839 --> 00:42:38,030
hierarchy it keeps the reference it

00:42:34,550 --> 00:42:41,510
keeps around maybe the type of the outer

00:42:38,030 --> 00:42:43,640
class the actual prototype class this

00:42:41,510 --> 00:42:45,619
model class actually has a bunch of

00:42:43,640 --> 00:42:49,490
metaprogramming in it that generates its

00:42:45,619 --> 00:42:53,030
own virtual table which is cool the

00:42:49,490 --> 00:42:54,260
implementation class obviously it has

00:42:53,030 --> 00:42:55,609
the storage for the concrete objects

00:42:54,260 --> 00:42:57,320
when you create the static producer or

00:42:55,609 --> 00:43:00,109
the dynamic producer it's going to live

00:42:57,320 --> 00:43:01,430
into that object there but it also fills

00:43:00,109 --> 00:43:02,480
out again it has a bunch of

00:43:01,430 --> 00:43:04,280
metaprogramming stuff that will actually

00:43:02,480 --> 00:43:06,170
go through and fill out the virtual

00:43:04,280 --> 00:43:07,730
table that the base class is created it

00:43:06,170 --> 00:43:10,430
actually establishes function pointers

00:43:07,730 --> 00:43:12,140
so that when you call produce on the

00:43:10,430 --> 00:43:13,880
outermost object that's going to work

00:43:12,140 --> 00:43:15,800
through the virtual table set up

00:43:13,880 --> 00:43:17,000
actually called the correct function on

00:43:15,800 --> 00:43:17,570
the class that you created in the

00:43:17,000 --> 00:43:19,610
backend

00:43:17,570 --> 00:43:23,570
it's an incredibly interesting

00:43:19,610 --> 00:43:24,740
implementation but it works right so we

00:43:23,570 --> 00:43:26,360
can push things back and then we can

00:43:24,740 --> 00:43:29,270
actually grab the first producer out of

00:43:26,360 --> 00:43:31,370
there call it all this stuff runs to a

00:43:29,270 --> 00:43:33,200
series of generated virtual table calls

00:43:31,370 --> 00:43:35,120
manually construct a virtual table calls

00:43:33,200 --> 00:43:36,710
and it should in fact because we

00:43:35,120 --> 00:43:38,720
produced a push back up static producer

00:43:36,710 --> 00:43:41,600
first return the value 42

00:43:38,720 --> 00:43:42,530
I think sly deserves a lot of credit for

00:43:41,600 --> 00:43:44,060
this this is a really interesting

00:43:42,530 --> 00:43:46,460
implementation I'm so glad that it was

00:43:44,060 --> 00:43:48,790
out there so round of applause

00:43:46,460 --> 00:43:48,790
Versailles

00:43:54,009 --> 00:44:00,199
plus it let me burn 15 minutes of a talk

00:43:56,539 --> 00:44:01,849
so this is great ok so that's actually

00:44:00,199 --> 00:44:03,619
all that I have for this I do I do have

00:44:01,849 --> 00:44:05,299
a one small observation I presented this

00:44:03,619 --> 00:44:08,150
slide at the end of my talk on static

00:44:05,299 --> 00:44:09,529
reflection because Oliver like when we

00:44:08,150 --> 00:44:11,660
talk about static reflection every

00:44:09,529 --> 00:44:14,420
single example had essentially the same

00:44:11,660 --> 00:44:16,189
pattern we have some runtime code that

00:44:14,420 --> 00:44:19,039
calls into a template that uses

00:44:16,189 --> 00:44:20,839
reflection and all the reflection code

00:44:19,039 --> 00:44:23,660
calls into some constant like the meta

00:44:20,839 --> 00:44:25,670
library code to get properties compute

00:44:23,660 --> 00:44:27,259
values whatever and on the way back

00:44:25,670 --> 00:44:30,109
those properties feed back into the

00:44:27,259 --> 00:44:31,999
template that are used in if Const exper

00:44:30,109 --> 00:44:34,130
statements template for statements or

00:44:31,999 --> 00:44:36,049
expansion statements instantiating other

00:44:34,130 --> 00:44:39,140
templates to actually generate that code

00:44:36,049 --> 00:44:40,369
and then of course the generated code

00:44:39,140 --> 00:44:42,769
comes back to runtime and you get really

00:44:40,369 --> 00:44:46,519
fast you know top-of-the-line efficient

00:44:42,769 --> 00:44:47,779
good C++ right but except for the few

00:44:46,519 --> 00:44:49,130
templates that we that we had in size

00:44:47,779 --> 00:44:51,709
example there weren't any templates in

00:44:49,130 --> 00:44:53,059
this example like the first three

00:44:51,709 --> 00:44:55,130
examples had no templates in them

00:44:53,059 --> 00:44:57,829
whatsoever right so there's definitely

00:44:55,130 --> 00:44:59,239
something different here basically we're

00:44:57,829 --> 00:45:00,619
just using meta programs as the

00:44:59,239 --> 00:45:02,539
replacement for templates in this case

00:45:00,619 --> 00:45:04,459
the generative mechanism that we would

00:45:02,539 --> 00:45:07,849
normally have from templates generating

00:45:04,459 --> 00:45:10,849
code we can just replace with a meta

00:45:07,849 --> 00:45:14,119
program and in injection statements

00:45:10,849 --> 00:45:15,890
right so our computation so what happens

00:45:14,119 --> 00:45:16,999
now is we have this runtime code we

00:45:15,890 --> 00:45:17,809
don't we don't instantiate the meta

00:45:16,999 --> 00:45:19,969
program that should actually say

00:45:17,809 --> 00:45:21,769
evaluate apparently didn't needed to fix

00:45:19,969 --> 00:45:24,229
that so you evaluate or execute a meta

00:45:21,769 --> 00:45:25,429
program and all it does is just call

00:45:24,229 --> 00:45:27,229
into this contact with the meta

00:45:25,429 --> 00:45:29,229
programming library stuff if that's just

00:45:27,229 --> 00:45:31,069
all reflection and like regular code

00:45:29,229 --> 00:45:32,299
there's nothing weird in there at all

00:45:31,069 --> 00:45:34,579
let me except for the except for the

00:45:32,299 --> 00:45:36,739
reflection stuff which can be weird and

00:45:34,579 --> 00:45:38,569
then all of that code just injects

00:45:36,739 --> 00:45:40,880
declarations which all get buffered or

00:45:38,569 --> 00:45:42,439
deferred or queued up until the end of

00:45:40,880 --> 00:45:44,059
the meta program and at the end of the

00:45:42,439 --> 00:45:45,349
meta program that's when we generate the

00:45:44,059 --> 00:45:47,329
code that comes back and executes some

00:45:45,349 --> 00:45:49,609
runtime so all of our generative meta

00:45:47,329 --> 00:45:52,099
programming facilities in C++ if we have

00:45:49,609 --> 00:45:54,739
reflection if we have source code

00:45:52,099 --> 00:45:56,329
injection we actually get the best of

00:45:54,739 --> 00:45:57,469
both worlds we can we can pick and

00:45:56,329 --> 00:45:59,119
choose we can generate code through

00:45:57,469 --> 00:46:00,709
templates we can generate code through

00:45:59,119 --> 00:46:03,019
meta programs we can assemble things

00:46:00,709 --> 00:46:05,150
with generic programming which we have

00:46:03,019 --> 00:46:06,559
pretty good ideas how to do we have a

00:46:05,150 --> 00:46:07,440
fairly principled approach for generic

00:46:06,559 --> 00:46:09,720
programming

00:46:07,440 --> 00:46:11,160
or at least you should you know the

00:46:09,720 --> 00:46:16,230
concepts are here should people should

00:46:11,160 --> 00:46:18,180
get better concepts no bias but we can

00:46:16,230 --> 00:46:19,230
do the same thing with meta programs we

00:46:18,180 --> 00:46:20,850
just want haven't quite figured out what

00:46:19,230 --> 00:46:22,680
the principles behind this are but we

00:46:20,850 --> 00:46:23,760
can give you the tools to do this so you

00:46:22,680 --> 00:46:25,800
guys can go on figure them out for

00:46:23,760 --> 00:46:29,220
yourselves come back and tell us what

00:46:25,800 --> 00:46:31,740
works and what doesn't so just to finish

00:46:29,220 --> 00:46:32,970
up language support can reprogram this

00:46:31,740 --> 00:46:34,800
is definitely work in progress

00:46:32,970 --> 00:46:36,420
if you ever see syntax spelled

00:46:34,800 --> 00:46:38,730
underscore underscore as a primary

00:46:36,420 --> 00:46:41,250
feature know that there are future

00:46:38,730 --> 00:46:42,560
designs coming in fact we actually just

00:46:41,250 --> 00:46:45,210
started working on redesigning

00:46:42,560 --> 00:46:46,980
redesigning fragments in their entirety

00:46:45,210 --> 00:46:48,090
we haven't started the implementation of

00:46:46,980 --> 00:46:50,490
it yet we're still kind of kicking the

00:46:48,090 --> 00:46:51,900
idea tires on on somebody some simply

00:46:50,490 --> 00:46:53,460
write ideas for how these are presented

00:46:51,900 --> 00:46:55,890
so maybe I'll come back next year and

00:46:53,460 --> 00:46:57,750
tell you guys what's different I've also

00:46:55,890 --> 00:46:59,820
really only presented about a third of

00:46:57,750 --> 00:47:03,030
the features in source code injection it

00:46:59,820 --> 00:47:04,710
turns out that trying to give a full

00:47:03,030 --> 00:47:06,030
talk or if like trying to cover

00:47:04,710 --> 00:47:07,920
everything every one of the features

00:47:06,030 --> 00:47:11,430
that we'd actually implemented to

00:47:07,920 --> 00:47:13,590
support these features would probably be

00:47:11,430 --> 00:47:18,570
a talk every day for the duration of CPP

00:47:13,590 --> 00:47:19,980
con there is a lot here or we could just

00:47:18,570 --> 00:47:21,240
do a two hour talk and be like drinking

00:47:19,980 --> 00:47:24,260
from a firehose but I don't think that's

00:47:21,240 --> 00:47:26,130
very effective as far as talks go so

00:47:24,260 --> 00:47:28,290
come back next year give you guys an

00:47:26,130 --> 00:47:31,590
update I hope and then if you guys have

00:47:28,290 --> 00:47:34,440
any feedback suggestions questions ideas

00:47:31,590 --> 00:47:36,320
use cases criticisms you can keep to

00:47:34,440 --> 00:47:39,660
yourself

00:47:36,320 --> 00:47:41,000
we'd be happy to hear them so thanks for

00:47:39,660 --> 00:47:44,240
your time if you guys have any questions

00:47:41,000 --> 00:47:44,240
come on up

00:48:33,099 --> 00:48:39,290
yes the common bits are injected there

00:48:36,859 --> 00:48:40,760
yeah and the meta program kind of

00:48:39,290 --> 00:48:54,589
disappears from the program like once

00:48:40,760 --> 00:48:55,670
you've executed it's gone no I actually

00:48:54,589 --> 00:48:59,390
meant to mention this in one of my

00:48:55,670 --> 00:49:02,450
slides about books so the model that we

00:48:59,390 --> 00:49:04,369
have for injection is that it's kind of

00:49:02,450 --> 00:49:05,810
like putting a pen down on paper like

00:49:04,369 --> 00:49:07,220
there is a point where code gets

00:49:05,810 --> 00:49:09,380
injected and there's no other point

00:49:07,220 --> 00:49:10,730
where code gets injected for the most

00:49:09,380 --> 00:49:12,470
part we have some features that

00:49:10,730 --> 00:49:14,450
generalize that a little bit but you

00:49:12,470 --> 00:49:15,650
can't really go backwards we don't we

00:49:14,450 --> 00:49:16,700
thought about doing this we thought

00:49:15,650 --> 00:49:17,750
about supporting features where you

00:49:16,700 --> 00:49:19,510
could to sort of like arbitrarily go

00:49:17,750 --> 00:49:23,060
back and throw code in and name spaces

00:49:19,510 --> 00:49:25,579
that you're not in and that seems deeply

00:49:23,060 --> 00:49:27,109
unprincipled and I like we don't want to

00:49:25,579 --> 00:49:28,819
go back and certainly modify classes

00:49:27,109 --> 00:49:32,319
after they've been completed because

00:49:28,819 --> 00:49:32,319
that would essentially break stuff

00:49:41,940 --> 00:49:45,040
No

00:49:43,210 --> 00:49:46,120
it emits again it's like putting the

00:49:45,040 --> 00:49:47,110
peat it's like putting a pen on paper

00:49:46,120 --> 00:49:49,530
and actually writing off the

00:49:47,110 --> 00:49:51,580
declarations so whatever code follows

00:49:49,530 --> 00:49:54,010
can't conflict with code that you've

00:49:51,580 --> 00:49:55,990
generated like I couldn't have extra

00:49:54,010 --> 00:49:57,310
declarations of like value category in

00:49:55,990 --> 00:49:59,440
this case because we would have already

00:49:57,310 --> 00:50:22,600
have already declared that there's no

00:49:59,440 --> 00:50:26,530
rewind on this I assume at some point at

00:50:22,600 --> 00:50:29,440
some time some company possibly called

00:50:26,530 --> 00:50:34,570
lock 3 software may have a compiler that

00:50:29,440 --> 00:50:37,840
allows you to debug your compiler so you

00:50:34,570 --> 00:50:40,950
need you need more tooling for this and

00:50:37,840 --> 00:50:40,950
it may or may not be being worked on

00:50:45,750 --> 00:51:22,240
with what tell me when to stop can the

00:51:20,620 --> 00:51:23,710
echo in this room is terrible I can't I

00:51:22,240 --> 00:51:25,870
can't actually understand what you're

00:51:23,710 --> 00:51:28,810
asking I'm sorry can you actually come

00:51:25,870 --> 00:51:32,470
up and ask so the the echo doesn't like

00:51:28,810 --> 00:51:34,510
I don't hear the echo in fact just lose

00:51:32,470 --> 00:51:37,570
the mic altogether it's it's like I

00:51:34,510 --> 00:51:42,060
can't hear them from the mic just come

00:51:37,570 --> 00:51:46,330
up because I don't know come up please

00:51:42,060 --> 00:51:49,350
in fact everybody know Mike I can't hear

00:51:46,330 --> 00:51:49,350
this is good yes

00:52:07,380 --> 00:52:11,440
if instead of writing so the question

00:52:10,060 --> 00:52:14,230
was if you had written for example

00:52:11,440 --> 00:52:16,830
deckle type this arrow D ref would that

00:52:14,230 --> 00:52:16,830
be valid Oh

00:52:20,380 --> 00:52:24,070
if you drop to this arrow then name

00:52:22,300 --> 00:52:26,290
lookup will the compiler will try to

00:52:24,070 --> 00:52:28,330
find the ref and you get a you get an

00:52:26,290 --> 00:52:29,680
error I mean if you don't have an

00:52:28,330 --> 00:52:31,690
existing version of de ref you'll get an

00:52:29,680 --> 00:52:33,280
error so you actually have to use that

00:52:31,690 --> 00:52:34,960
this arrow to defer look up until the

00:52:33,280 --> 00:52:37,420
point of injection and we actually have

00:52:34,960 --> 00:52:38,950
some some features that help d4 lookup

00:52:37,420 --> 00:52:52,510
until later but we didn't introduce

00:52:38,950 --> 00:52:55,090
those in this talk price so the question

00:52:52,510 --> 00:52:57,010
is do we envision envision the need to

00:52:55,090 --> 00:52:59,710
inject code into non class scope like

00:52:57,010 --> 00:53:01,480
namespace scope function scope to have a

00:52:59,710 --> 00:53:02,920
parameter scope normal parameter scope

00:53:01,480 --> 00:53:04,900
and the answer is yes there are

00:53:02,920 --> 00:53:06,610
injection context for all of those and

00:53:04,900 --> 00:53:08,680
fragments for all those I just didn't

00:53:06,610 --> 00:53:21,910
present them because these are the the

00:53:08,680 --> 00:53:23,140
easier ones to start with is injecting

00:53:21,910 --> 00:53:25,090
into a class and most useful thing I

00:53:23,140 --> 00:53:26,830
believe so but they're definitely use

00:53:25,090 --> 00:53:31,020
cases where you want to put things in a

00:53:26,830 --> 00:53:31,020
namespace also Thanks

00:53:45,990 --> 00:53:55,480
yeah if you if you miss type your

00:53:49,030 --> 00:53:56,650
program I was repeating the question so

00:53:55,480 --> 00:53:58,240
the question was if you miss type your

00:53:56,650 --> 00:53:59,320
program you're going to get some nasty

00:53:58,240 --> 00:54:01,900
errors because you might end up with

00:53:59,320 --> 00:54:04,150
sequences of nested injections which can

00:54:01,900 --> 00:54:08,710
be weird how do you track them down and

00:54:04,150 --> 00:54:10,690
the answer is carefully so we actually

00:54:08,710 --> 00:54:12,400
have we actually have some facilities in

00:54:10,690 --> 00:54:13,900
our implementation that lets you let's

00:54:12,400 --> 00:54:16,600
you do compile time printing and compile

00:54:13,900 --> 00:54:18,520
time debugging of code a constant

00:54:16,600 --> 00:54:20,590
evaluation time so you can print stuff

00:54:18,520 --> 00:54:22,000
out as you evaluate it but it can be

00:54:20,590 --> 00:54:23,050
kind of weird to use because sometimes

00:54:22,000 --> 00:54:24,880
that treaters are triggered by

00:54:23,050 --> 00:54:26,410
instantiation and sometimes it's

00:54:24,880 --> 00:54:56,620
triggered by evaluation it's never

00:54:26,410 --> 00:54:59,710
really clear when that happens yes you

00:54:56,620 --> 00:55:00,790
can write confusing code I it's hard for

00:54:59,710 --> 00:55:02,290
me to see what you're the kind of

00:55:00,790 --> 00:55:04,390
situation you're talking about but I we

00:55:02,290 --> 00:55:13,780
can talk about it offline I'd like to

00:55:04,390 --> 00:55:15,870
I'd like to see the examples yeah I'm

00:55:13,780 --> 00:55:21,190
good

00:55:15,870 --> 00:55:23,710
so just an announcement apparently the

00:55:21,190 --> 00:55:25,990
version of this compiler supports

00:55:23,710 --> 00:55:28,420
attributes on in compiler Explorer so

00:55:25,990 --> 00:55:32,670
yeah thanks Matt

00:55:28,420 --> 00:55:32,670
[Applause]

00:55:36,950 --> 00:55:43,170
can you write recursive fragments yes

00:55:40,290 --> 00:55:45,030
you can that actually shows up in some

00:55:43,170 --> 00:56:00,000
of our more examples on the webpage or

00:55:45,030 --> 00:56:04,380
wiki yeah how powerful is this feature

00:56:00,000 --> 00:56:06,180
can it replace compiler magic you don't

00:56:04,380 --> 00:56:10,140
want that even if it could I don't think

00:56:06,180 --> 00:56:11,880
you want that the compiler is better at

00:56:10,140 --> 00:56:13,410
teasing out issues and errors than then

00:56:11,880 --> 00:56:14,850
library code will be and it will

00:56:13,410 --> 00:56:21,750
generate better code for you as a result

00:56:14,850 --> 00:56:23,700
I I think that one of the things that

00:56:21,750 --> 00:56:26,520
will happen if we adopt if we adopt this

00:56:23,700 --> 00:56:27,690
feature I strongly suspect that one of

00:56:26,520 --> 00:56:30,000
the things that this will be most used

00:56:27,690 --> 00:56:31,950
for is experimenting with new language

00:56:30,000 --> 00:56:34,170
features that will then be proposed for

00:56:31,950 --> 00:56:36,210
compilers to implement so this will be

00:56:34,170 --> 00:56:37,680
the prototyping space for those and then

00:56:36,210 --> 00:56:48,150
will they'll end up getting formalized I

00:56:37,680 --> 00:56:49,380
think that will happen can generative

00:56:48,150 --> 00:56:52,170
meta programming be used to generate

00:56:49,380 --> 00:56:53,610
archetypes for concepts and for those of

00:56:52,170 --> 00:56:55,470
you guys that don't know an archetype is

00:56:53,610 --> 00:56:57,570
basically a model and a concept that has

00:56:55,470 --> 00:56:58,860
no attach semantics if you instantiate a

00:56:57,570 --> 00:57:00,870
template with an archetype you can use

00:56:58,860 --> 00:57:03,500
it to support definition checking right

00:57:00,870 --> 00:57:06,150
yes

00:57:03,500 --> 00:57:07,950
hypothetically that is a direction that

00:57:06,150 --> 00:57:10,200
could be looked at in the future it'd be

00:57:07,950 --> 00:57:12,240
interesting we don't have the ability

00:57:10,200 --> 00:57:14,250
right now to reflect on statements or

00:57:12,240 --> 00:57:15,600
expressions which you would need to be

00:57:14,250 --> 00:57:17,850
able to analyze to generate the

00:57:15,600 --> 00:57:20,130
declarations for your archetypes but I

00:57:17,850 --> 00:57:21,960
suspect that this will be something that

00:57:20,130 --> 00:57:24,110
we look at in the non not too distant

00:57:21,960 --> 00:57:24,110
future

00:57:31,150 --> 00:58:07,940
yes yes so is the question is can you

00:58:04,869 --> 00:58:10,849
generate free functions while injecting

00:58:07,940 --> 00:58:12,140
into class scope and the answer is yes

00:58:10,849 --> 00:58:15,020
we actually do have a feature that

00:58:12,140 --> 00:58:17,240
allows you to float some injections to

00:58:15,020 --> 00:58:19,430
the enclosing namespace specifically to

00:58:17,240 --> 00:58:21,280
support that in that application but I

00:58:19,430 --> 00:58:25,550
didn't present it because you know

00:58:21,280 --> 00:58:27,260
firehose alright no other questions well

00:58:25,550 --> 00:58:29,619
thank you very much guys enjoy the rest

00:58:27,260 --> 00:58:29,619

YouTube URL: https://www.youtube.com/watch?v=kjQXhuPX-Ac


