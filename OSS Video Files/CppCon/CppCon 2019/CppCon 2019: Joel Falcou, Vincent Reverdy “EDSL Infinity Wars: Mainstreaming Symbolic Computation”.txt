Title: CppCon 2019: Joel Falcou, Vincent Reverdy “EDSL Infinity Wars: Mainstreaming Symbolic Computation”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Scientists and Developers want the same thing: a simple code that does exactly what it should. For the former, it implies adhering to their knowledge base and domain idioms. For the latter, it means it compiles in a reasonable time frame and without bugs. for both, it better computes fast in the end. One way developers, especially in C++, provides scientists with usable libraries is to design them as Embedded Domain Specific Languages. Alas, in all honesty, if someone asked the Scientists, they will probably state that LaTex is *the* perfect DSLs they practice every day.

This is an old story and even if we only focus on matrix-based libraries, the current landscape of high-performance computing library -- Blaze, Blitz++, EIGEN, Armadillo, etc... -- is proof that those techniques have a decent public following. This is the point where the icky things start: stories of meta-programming, so-called expression templates and their uphill battle against new C++ features: interaction with auto, rvalue-references, move semantics and so on. The authors have spent quite a bit of their coding life trying to play with or around those techniques and this talk is about what they learned during this journey.

This talk will focus on what kind of mistakes, oversights and traps the old kind of scientific EDSLs fell into. We will investigate why the new C++ features didn't help them but pushed them further into a state of ever-growing complexity. We will present our vision of how a modern-C++ friendly EDSL for science can be built. By starting from scratch, this talk will cover the actual requirements of such a library including move-aware expression templates, symbolic formula building, type/value maps, named parameters and static visitors. As a conclusion, we will scheme over various immediate benefits of such an EDSL and new applications that old style libraries could not handle like symbolic simplification, automatic analytical derivation and more.
— 
Joel Falcou
LRI - Université paris 11
assistant professor
Paris Area, France

Joel Falcou is an assistant professor at the University Paris-Sud andresearcher at the Laboratoire de Recherche d'Informatique in Orsay, France. His researches focus on studying generative programming idioms and techniques to design tools for parallel software development. The two main parts of those works are : exploration of Embedded Domain Specific Language design for parallel computing on various architectures and the definition of a formal framework for reasoning about meta-programs and prove their compile-time correctness. Applications range from real-time image processing on embedded architectures to High Performance Computing on multi-core clusters. Twitter handle: @joel_f"＞

Vincent Reverdy
University of Illinois at Urbana-Champaign
Researcher
Urbana-Champaign, Illinois Area

Vincent has been working as a post-doctoral researcher at the University of Illinois at Urbana-Champaign (USA) since he obtained his PhD at the Paris observatory (France) in november 2014. His main scientific interests are related to cosmology and general relativity. He his particularly interested in the study of relativistic effects at cosmological scales using high performance simulations run on supercomputers. Because these simulations rely on tree data structures, he started investigating ways to optimize them. He now leads a research team working on tree data structures with main applications in simulations, machine learning, and data science. He also participates into the C++ standardization process and regularly submits proposals to improve the C++ language.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,269 --> 00:00:13,600
so everybody thanks for coming just to

00:00:12,920 --> 00:00:16,090
introduce

00:00:13,600 --> 00:00:19,180
so I'm joyful - I'm in a state professor

00:00:16,090 --> 00:00:23,890
from the computer science research

00:00:19,180 --> 00:00:25,480
laboratory from Paris some of you may

00:00:23,890 --> 00:00:28,500
know me because I like to torture

00:00:25,480 --> 00:00:31,000
compilers with templates and so on so

00:00:28,500 --> 00:00:34,239
this talk would be exactly what you

00:00:31,000 --> 00:00:35,140
expect it to be this despite for the

00:00:34,239 --> 00:00:39,309
title

00:00:35,140 --> 00:00:42,010
Laser laser marking for laser Chris

00:00:39,309 --> 00:00:43,840
Evans was available for a team in which

00:00:42,010 --> 00:00:46,570
he stopped so I just ask then sound with

00:00:43,840 --> 00:00:50,080
me son can you introduce yourself yeah

00:00:46,570 --> 00:00:52,809
so I'm used to be a computational

00:00:50,080 --> 00:00:54,850
astrophysicist I still do some

00:00:52,809 --> 00:00:58,210
astrophysics but now I do mostly stuff

00:00:54,850 --> 00:01:00,760
in C++ and I'm over the last few years

00:00:58,210 --> 00:01:02,530
I've been working lots trying to

00:01:00,760 --> 00:01:04,690
Istanbul the ice bit manipulation stuff

00:01:02,530 --> 00:01:06,850
for the surplus personal doubt so that

00:01:04,690 --> 00:01:08,740
we can deprecated vector pool and we can

00:01:06,850 --> 00:01:09,909
replace a bit set with something modern

00:01:08,740 --> 00:01:11,770
right

00:01:09,909 --> 00:01:14,740
but today I will not speak about that

00:01:11,770 --> 00:01:17,290
they will speak about ETS l infinity was

00:01:14,740 --> 00:01:20,710
mainstreaming symbolic computation so

00:01:17,290 --> 00:01:22,689
behind this cryptic title we have a DSL

00:01:20,710 --> 00:01:25,420
which stands for embedded

00:01:22,689 --> 00:01:27,700
domain-specific language mainstreaming

00:01:25,420 --> 00:01:31,000
will mean that we'll try to make things

00:01:27,700 --> 00:01:33,130
easy for people symbolic will have to do

00:01:31,000 --> 00:01:37,780
with math and computation will have to

00:01:33,130 --> 00:01:39,969
do with computers so it all starts by

00:01:37,780 --> 00:01:43,659
what people have been doing for the last

00:01:39,969 --> 00:01:45,700
decade so thanks to a lot of computing

00:01:43,659 --> 00:01:48,670
power and the high processing power

00:01:45,700 --> 00:01:50,170
people in Sciences have been putting

00:01:48,670 --> 00:01:53,560
more and more effort into developing

00:01:50,170 --> 00:01:56,649
simulations and now there are a lot of

00:01:53,560 --> 00:01:59,170
domain of science where simulation are

00:01:56,649 --> 00:02:01,359
completely integrated within the science

00:01:59,170 --> 00:02:03,729
to demonstrate stuff and one of the most

00:02:01,359 --> 00:02:05,979
recent and popular example has been the

00:02:03,729 --> 00:02:09,009
discovery of black hole managers through

00:02:05,979 --> 00:02:12,850
gravitational waves I think it was one

00:02:09,009 --> 00:02:14,680
or two years ago and in that process

00:02:12,850 --> 00:02:17,530
simulation was very important to be able

00:02:14,680 --> 00:02:21,940
to actually understand what was going on

00:02:17,530 --> 00:02:24,010
and so that's one example but in the

00:02:21,940 --> 00:02:25,810
astrophysics we are doing all the kind

00:02:24,010 --> 00:02:26,880
of simulation for example here you have

00:02:25,810 --> 00:02:32,070
something that

00:02:26,880 --> 00:02:34,860
simulation a very very large portion of

00:02:32,070 --> 00:02:36,750
the universe where and we are doing this

00:02:34,860 --> 00:02:38,400
kind of simulation to understand how

00:02:36,750 --> 00:02:40,820
galaxies forms

00:02:38,400 --> 00:02:42,080
people are also using simulations in

00:02:40,820 --> 00:02:43,560
[Music]

00:02:42,080 --> 00:02:46,860
magnetohydrodynamics

00:02:43,560 --> 00:02:50,190
for example in plasma is in plasma

00:02:46,860 --> 00:02:52,950
physics to try to make to understand how

00:02:50,190 --> 00:02:56,900
fusion works and you have also climate

00:02:52,950 --> 00:03:01,260
modeling which is which are big users of

00:02:56,900 --> 00:03:05,340
computing power to do simulations of how

00:03:01,260 --> 00:03:07,440
the climate and earth works and that's

00:03:05,340 --> 00:03:12,770
just few example but it's the same thing

00:03:07,440 --> 00:03:15,330
for many more application domains but

00:03:12,770 --> 00:03:17,250
the behind all the simulation there is

00:03:15,330 --> 00:03:19,980
usually a problem and the problem is

00:03:17,250 --> 00:03:21,750
that to make that work you can generally

00:03:19,980 --> 00:03:24,660
describe the principle of the simulation

00:03:21,750 --> 00:03:26,730
within let's say a few minutes and a

00:03:24,660 --> 00:03:29,760
white bowl but when it comes to

00:03:26,730 --> 00:03:33,690
implementing the thing then it's far far

00:03:29,760 --> 00:03:37,170
far more complicated and when we have

00:03:33,690 --> 00:03:38,880
students in physics who want to who

00:03:37,170 --> 00:03:40,290
study physics and who want to decide

00:03:38,880 --> 00:03:43,170
whether they want to do a computation

00:03:40,290 --> 00:03:46,530
and or theory really they have

00:03:43,170 --> 00:03:48,540
expectation and generally when you talk

00:03:46,530 --> 00:03:51,030
about simulation they see the large

00:03:48,540 --> 00:03:54,270
commercials all the fun and there are

00:03:51,030 --> 00:03:56,459
other cool people and then when you talk

00:03:54,270 --> 00:03:58,560
about theory you generally think about

00:03:56,459 --> 00:04:01,890
people with pen and paper or trying to

00:03:58,560 --> 00:04:06,120
demonstrate stuff but when it comes to

00:04:01,890 --> 00:04:10,050
how it turns out to be in practice then

00:04:06,120 --> 00:04:12,030
when you are doing simulation you spend

00:04:10,050 --> 00:04:14,490
a lot of time trying to debug code and

00:04:12,030 --> 00:04:16,980
having problem about parties and stuff

00:04:14,490 --> 00:04:18,840
like this while when you are working on

00:04:16,980 --> 00:04:21,750
theory everything is nice everything

00:04:18,840 --> 00:04:24,840
works if you put some time trying to

00:04:21,750 --> 00:04:27,000
understand stuff and you have a farm a

00:04:24,840 --> 00:04:30,630
farm or problem taking a problem when

00:04:27,000 --> 00:04:34,580
you're trying to do simulation and as a

00:04:30,630 --> 00:04:36,360
result currently you have two different

00:04:34,580 --> 00:04:40,140
communities that are doing different

00:04:36,360 --> 00:04:40,729
things in simulation and theory so the

00:04:40,140 --> 00:04:43,309
simulation

00:04:40,729 --> 00:04:45,860
side people are mostly trying to solve

00:04:43,309 --> 00:04:47,930
partial differential equation while on

00:04:45,860 --> 00:04:50,270
the theoretical side people are mostly

00:04:47,930 --> 00:04:53,180
solving ordinary ordinary differential

00:04:50,270 --> 00:04:55,699
equation then the simulation side you

00:04:53,180 --> 00:04:58,059
are using numerical methods and theory

00:04:55,699 --> 00:05:00,559
you are using symbolic calculus

00:04:58,059 --> 00:05:02,900
simulation side supercomputers and the

00:05:00,559 --> 00:05:06,349
theoretical side mostly most of the time

00:05:02,900 --> 00:05:10,039
a laptop is fine enough to run your the

00:05:06,349 --> 00:05:12,559
computation and then when you want to

00:05:10,039 --> 00:05:14,839
run and to develop simulation framework

00:05:12,559 --> 00:05:17,689
you have to use general-purpose language

00:05:14,839 --> 00:05:20,389
while people that are doing theoretical

00:05:17,689 --> 00:05:23,409
stuff mostly use the municipal language

00:05:20,389 --> 00:05:27,379
to help them like Mathematica Mapple

00:05:23,409 --> 00:05:29,270
Sage extra-extra as I said the current

00:05:27,379 --> 00:05:30,979
status of the thing is that you have

00:05:29,270 --> 00:05:32,870
people who are doing simulations and

00:05:30,979 --> 00:05:34,580
people who are doing theory and they are

00:05:32,870 --> 00:05:36,409
Trude if they are relying and to

00:05:34,580 --> 00:05:41,509
different ecosystems with different set

00:05:36,409 --> 00:05:45,110
of tools but what if we were checking

00:05:41,509 --> 00:05:46,939
C++ on one side and we were taking

00:05:45,110 --> 00:05:49,699
something that is used by everyone to

00:05:46,939 --> 00:05:52,430
write equation the other side and we

00:05:49,699 --> 00:05:54,649
were using the magic language that is

00:05:52,430 --> 00:05:57,740
inside C++ which is all the nice

00:05:54,649 --> 00:06:00,469
template stuff and thanks to some

00:05:57,740 --> 00:06:03,080
magical power we are combining all of

00:06:00,469 --> 00:06:05,240
this to be able to produce symbolic

00:06:03,080 --> 00:06:07,189
embedded domain-specific language so

00:06:05,240 --> 00:06:10,639
that you could write write latekka

00:06:07,189 --> 00:06:15,409
equation inside your service bus so

00:06:10,639 --> 00:06:17,719
that's what we are looking for and

00:06:15,409 --> 00:06:19,879
that's where actually come into place

00:06:17,719 --> 00:06:26,839
you know so we are going to you know

00:06:19,879 --> 00:06:28,639
massacres of compilers more he s been a

00:06:26,839 --> 00:06:31,610
domain-specific language stems from

00:06:28,639 --> 00:06:33,649
domain-specific language which is well

00:06:31,610 --> 00:06:36,020
known way to end those in the

00:06:33,649 --> 00:06:39,709
declarative way complex problem by using

00:06:36,020 --> 00:06:41,659
non general-purpose language it's a

00:06:39,709 --> 00:06:43,550
complicated definition but well you

00:06:41,659 --> 00:06:46,159
probably just use a bunch of them every

00:06:43,550 --> 00:06:48,639
time you make an SQL request or write

00:06:46,159 --> 00:06:51,800
make or make or try to make MATLAB works

00:06:48,639 --> 00:06:53,810
the main the main caveat is that instead

00:06:51,800 --> 00:06:54,360
of explaining to the computer how it

00:06:53,810 --> 00:06:56,759
should be

00:06:54,360 --> 00:06:59,400
doing something by every steps you just

00:06:56,759 --> 00:07:02,310
say okay just solve the equation and the

00:06:59,400 --> 00:07:05,009
language we just you know choose a

00:07:02,310 --> 00:07:10,439
correct way to do that so what is the

00:07:05,009 --> 00:07:12,599
functional language so basically when

00:07:10,439 --> 00:07:15,810
you design it here so what you're doing

00:07:12,599 --> 00:07:19,280
is you are turning the knowledge of a

00:07:15,810 --> 00:07:21,120
domain into a bunch of structures

00:07:19,280 --> 00:07:23,460
relationship between those structures

00:07:21,120 --> 00:07:25,430
and rules that drives all those

00:07:23,460 --> 00:07:28,729
structures and relationships should be

00:07:25,430 --> 00:07:31,139
interacting with one another and yes sir

00:07:28,729 --> 00:07:32,969
specific language static is the same

00:07:31,139 --> 00:07:35,310
thing except instead of designing your

00:07:32,969 --> 00:07:37,740
language you design your library usually

00:07:35,310 --> 00:07:39,870
embedded into a general-purpose language

00:07:37,740 --> 00:07:42,870
so that the syntax of the

00:07:39,870 --> 00:07:44,580
general-purpose language X you design

00:07:42,870 --> 00:07:47,759
and implement these domain-specific

00:07:44,580 --> 00:07:51,689
language as a library and one way to do

00:07:47,759 --> 00:07:53,460
that especially in C++ is using

00:07:51,689 --> 00:07:55,259
expression templates I mean you can do

00:07:53,460 --> 00:07:58,500
evidence of a specific language in a lot

00:07:55,259 --> 00:08:00,469
of other general-purpose languages with

00:07:58,500 --> 00:08:02,550
different methods and different tools

00:08:00,469 --> 00:08:06,419
but we will focus on expression

00:08:02,550 --> 00:08:08,520
templates for a while so maybe some of

00:08:06,419 --> 00:08:11,370
you are actually I mean II always the

00:08:08,520 --> 00:08:13,680
technique so basically we abuse function

00:08:11,370 --> 00:08:15,750
and operator overloading to build the

00:08:13,680 --> 00:08:17,339
libraries that instead of computing

00:08:15,750 --> 00:08:21,990
something when you asked him to do it

00:08:17,339 --> 00:08:24,539
like this on the right with small matrix

00:08:21,990 --> 00:08:26,719
like computations there it doesn't do

00:08:24,539 --> 00:08:30,210
any computation like right off the bat

00:08:26,719 --> 00:08:33,029
turn this sequence of codes into a

00:08:30,210 --> 00:08:35,279
representation of what the operation

00:08:33,029 --> 00:08:37,079
should be one way to do that is to

00:08:35,279 --> 00:08:40,229
encourage the abstract syntax trees of

00:08:37,079 --> 00:08:42,240
the expression so we can just message it

00:08:40,229 --> 00:08:44,610
a bit turn it into something else

00:08:42,240 --> 00:08:48,000
analyzing things so on and generate

00:08:44,610 --> 00:08:49,260
arbitrary code out of the year and the

00:08:48,000 --> 00:08:50,820
cool thing about that is that you can

00:08:49,260 --> 00:08:53,160
carry auditory semantic information

00:08:50,820 --> 00:08:55,529
inside your code because you can tie

00:08:53,160 --> 00:08:58,170
love as a type and the function to

00:08:55,529 --> 00:09:01,170
gather all the information of the I

00:08:58,170 --> 00:09:04,199
levels want and bring it down down to

00:09:01,170 --> 00:09:05,850
the to the implementation level and it's

00:09:04,199 --> 00:09:07,620
rather easy because you doesn't have to

00:09:05,850 --> 00:09:08,339
switch languages so you can just write

00:09:07,620 --> 00:09:10,499
your domain

00:09:08,339 --> 00:09:13,379
if you fart inside you're right your

00:09:10,499 --> 00:09:16,649
application using the same language are

00:09:13,379 --> 00:09:21,899
in order to do this well we have a bunch

00:09:16,649 --> 00:09:24,209
of actual benefits you can make any app

00:09:21,899 --> 00:09:28,350
from implementation become aware of all

00:09:24,209 --> 00:09:30,779
children optimized by exploiting those

00:09:28,350 --> 00:09:33,389
information that was referral tree the

00:09:30,779 --> 00:09:38,189
type inside it and so on you can put an

00:09:33,389 --> 00:09:40,110
arbitrary high level of API on the user

00:09:38,189 --> 00:09:42,089
level and you know that you could

00:09:40,110 --> 00:09:45,540
actually get whatever loaded or things

00:09:42,089 --> 00:09:48,779
you want at the end after some amount of

00:09:45,540 --> 00:09:51,920
compile and to do that you are magic

00:09:48,779 --> 00:09:55,139
into choice I saw you do this by n which

00:09:51,920 --> 00:09:57,899
and for why we had a bunch of tools that

00:09:55,139 --> 00:10:00,389
leverage all the boilerplate inquire so

00:09:57,899 --> 00:10:03,360
just two of them I could probably have

00:10:00,389 --> 00:10:06,149
found a couple of small like the Puma

00:10:03,360 --> 00:10:10,230
OPP that boosts proto and Gustav are the

00:10:06,149 --> 00:10:13,019
most known so whose photo is a

00:10:10,230 --> 00:10:17,189
precipitous in library design by Roche

00:10:13,019 --> 00:10:20,399
definitely laid the groundwork for all

00:10:17,189 --> 00:10:22,889
such items should be conceptualized and

00:10:20,399 --> 00:10:25,410
gave rise to a bunch of library even

00:10:22,889 --> 00:10:28,889
there and boost yeah sign by exactly

00:10:25,410 --> 00:10:31,499
laying which is actually more advanced

00:10:28,889 --> 00:10:35,129
modern concept based version of the same

00:10:31,499 --> 00:10:37,290
thing but next to those tools let's have

00:10:35,129 --> 00:10:40,230
a look at what kind of exact existing

00:10:37,290 --> 00:10:44,279
library for doing computation and

00:10:40,230 --> 00:10:47,160
simulation actually exists decided to go

00:10:44,279 --> 00:10:49,740
by you know chronological order whatever

00:10:47,160 --> 00:10:52,079
reason so let's go back to 1990

00:10:49,740 --> 00:10:54,120
something with this plus plus which is

00:10:52,079 --> 00:10:56,839
probably the first or one of the first

00:10:54,120 --> 00:10:59,249
expression template based

00:10:56,839 --> 00:11:02,519
computational library dealing with

00:10:59,249 --> 00:11:05,249
arrays and algebra the goal at at the

00:11:02,519 --> 00:11:08,550
time was make C++ numerical code as fast

00:11:05,249 --> 00:11:11,759
as 4chan because that was a regular

00:11:08,550 --> 00:11:14,069
caveat that people had in C++ it's

00:11:11,759 --> 00:11:16,050
historically a supercilious 98 or 3

00:11:14,069 --> 00:11:18,420
library the other small is a change in

00:11:16,050 --> 00:11:20,939
the said event but doesn't get that much

00:11:18,420 --> 00:11:21,570
far another one that you made more be

00:11:20,939 --> 00:11:24,930
familiar with

00:11:21,570 --> 00:11:26,910
again which has the honor to be probably

00:11:24,930 --> 00:11:27,810
the most mainstream expression

00:11:26,910 --> 00:11:30,509
template-based

00:11:27,810 --> 00:11:32,220
compositional library it works if you

00:11:30,509 --> 00:11:35,339
have an image somewhere it's probably

00:11:32,220 --> 00:11:38,279
inside already installed designed to

00:11:35,339 --> 00:11:39,540
support more than just basic operation

00:11:38,279 --> 00:11:42,810
doesn't support for parties and

00:11:39,540 --> 00:11:45,000
especially in vectorization mode they

00:11:42,810 --> 00:11:46,709
have a slow aging that they are so

00:11:45,000 --> 00:11:48,930
immigrating to more modern she was

00:11:46,709 --> 00:11:51,930
present in what way and next to that

00:11:48,930 --> 00:11:53,759
where was a bunch of other libraries

00:11:51,930 --> 00:11:56,550
that went a bit further

00:11:53,759 --> 00:11:58,589
one of the first place which is also

00:11:56,550 --> 00:12:00,060
like a nine energy brought library based

00:11:58,589 --> 00:12:01,370
on the expression templates that

00:12:00,060 --> 00:12:04,050
actually introduce two very interesting

00:12:01,370 --> 00:12:05,940
things which is called smart expression

00:12:04,050 --> 00:12:08,279
templates in a way that you can actually

00:12:05,940 --> 00:12:10,079
capture more than just the expression

00:12:08,279 --> 00:12:12,420
you want to assign to your left-hand

00:12:10,079 --> 00:12:15,120
side of the equal and from global

00:12:12,420 --> 00:12:17,279
analyzes and operation on your

00:12:15,120 --> 00:12:20,370
expression including the assignment

00:12:17,279 --> 00:12:23,730
which led which makes a library able to

00:12:20,370 --> 00:12:26,010
detect blasts three-level function calls

00:12:23,730 --> 00:12:28,350
and turn them into a naturally optimized

00:12:26,010 --> 00:12:30,829
piece of code instead of just trying to

00:12:28,350 --> 00:12:34,560
rebuild it

00:12:30,829 --> 00:12:37,560
shameless plug entity which was of my

00:12:34,560 --> 00:12:39,180
own of my own old library doing exactly

00:12:37,560 --> 00:12:42,060
the same thing our goal was to have a

00:12:39,180 --> 00:12:43,920
MATLAB syntax like in C++ we basically

00:12:42,060 --> 00:12:45,980
reinvented smart expression template

00:12:43,920 --> 00:12:49,440
without knowing it existed already and

00:12:45,980 --> 00:12:51,089
so one thing we were quite proud of was

00:12:49,440 --> 00:12:54,360
the fact that we could I can separate

00:12:51,089 --> 00:12:56,310
the IC generation from the architecture

00:12:54,360 --> 00:12:58,920
world definitions though you can just

00:12:56,310 --> 00:13:01,709
swap architectures supports and Ice T's

00:12:58,920 --> 00:13:04,529
without having to mix both concerns

00:13:01,709 --> 00:13:07,260
there was a door module which is also

00:13:04,529 --> 00:13:09,899
based on this you know wave it might

00:13:07,260 --> 00:13:10,949
have syntax and they have this fine the

00:13:09,899 --> 00:13:12,899
very interesting dynamic optimization

00:13:10,949 --> 00:13:15,360
strategies well you can actually

00:13:12,899 --> 00:13:16,589
optimize the code a bit much more at

00:13:15,360 --> 00:13:17,220
Trenton because you have more

00:13:16,589 --> 00:13:19,649
information

00:13:17,220 --> 00:13:21,870
so I mean writing linear algebra /

00:13:19,649 --> 00:13:22,500
computational library using extreme

00:13:21,870 --> 00:13:28,259
templates

00:13:22,500 --> 00:13:31,199
not very new not very fancy but recently

00:13:28,259 --> 00:13:33,269
we wanted to go back this kind of task

00:13:31,199 --> 00:13:35,190
and see what we can do better now isn't

00:13:33,269 --> 00:13:41,300
up to say 17

00:13:35,190 --> 00:13:43,709
and before going there well what happens

00:13:41,300 --> 00:13:45,420
these three examples are the most

00:13:43,709 --> 00:13:47,940
classical example of things that just

00:13:45,420 --> 00:13:50,430
grow like not very well when you deal

00:13:47,940 --> 00:13:53,939
with expression templates with different

00:13:50,430 --> 00:13:56,459
level of issues so the first one which

00:13:53,939 --> 00:13:58,079
is basically due to see professor and

00:13:56,459 --> 00:14:00,810
his interaction of expression templates

00:13:58,079 --> 00:14:02,189
with auto keywords so the great one

00:14:00,810 --> 00:14:04,920
question is let's say we have a matrix

00:14:02,189 --> 00:14:08,819
type a and B and what what's the type of

00:14:04,920 --> 00:14:10,860
C if we knew we were not using an

00:14:08,819 --> 00:14:14,490
expression template based libraries and

00:14:10,860 --> 00:14:16,949
so it's probably a matrix and but in

00:14:14,490 --> 00:14:18,720
this case it's probably a very

00:14:16,949 --> 00:14:20,029
complicated template times that I could

00:14:18,720 --> 00:14:21,980
tell you that you are doing to

00:14:20,029 --> 00:14:24,060
implication between two matrixes

00:14:21,980 --> 00:14:26,009
sometimes that's exactly what you want

00:14:24,060 --> 00:14:27,750
because you want to capture these sub

00:14:26,009 --> 00:14:29,730
expression and the repeated elsewhere

00:14:27,750 --> 00:14:31,410
and in the building of a larger

00:14:29,730 --> 00:14:33,839
expression that sometimes that's exactly

00:14:31,410 --> 00:14:38,459
not what you want you want the matrix to

00:14:33,839 --> 00:14:40,170
be related right now different different

00:14:38,459 --> 00:14:42,089
kind of issues is the interaction of

00:14:40,170 --> 00:14:43,560
exertion templates with temporary from a

00:14:42,089 --> 00:14:45,000
function so let's say you are the

00:14:43,560 --> 00:14:47,790
general function think eat or whatever

00:14:45,000 --> 00:14:50,519
you computed some put it into a local

00:14:47,790 --> 00:14:53,939
matrix and you return M divided by G for

00:14:50,519 --> 00:14:58,709
whatever reason let's say G is well

00:14:53,939 --> 00:15:01,649
something that does not do anything

00:14:58,709 --> 00:15:04,259
special we build matrix which is a root

00:15:01,649 --> 00:15:06,149
of firm offer an expression templates

00:15:04,259 --> 00:15:09,600
and we built this expression which is

00:15:06,149 --> 00:15:11,579
division between m and G except like

00:15:09,600 --> 00:15:14,310
most expression template ivory captures

00:15:11,579 --> 00:15:16,050
terminals where reference the expression

00:15:14,310 --> 00:15:17,910
which is returned from F contain a

00:15:16,050 --> 00:15:20,100
reference to these temporary matrix and

00:15:17,910 --> 00:15:23,279
whenever you really varied that yeah

00:15:20,100 --> 00:15:25,439
third line and the other one is the way

00:15:23,279 --> 00:15:28,290
that interact with the invision we have

00:15:25,439 --> 00:15:31,680
of template types so I have a function

00:15:28,290 --> 00:15:32,970
tected T of type big T and I want to

00:15:31,680 --> 00:15:35,550
compute the product of it it's probably

00:15:32,970 --> 00:15:38,699
a big t well except when T is an

00:15:35,550 --> 00:15:43,380
expression itself so all this kind of I

00:15:38,699 --> 00:15:45,209
mean small scale issues well we could

00:15:43,380 --> 00:15:47,379
say well it doesn't happen merge and if

00:15:45,209 --> 00:15:51,099
I write that you know I'm loser

00:15:47,379 --> 00:15:52,389
should know what I do know except not if

00:15:51,099 --> 00:15:54,429
you are using your lip an expression

00:15:52,389 --> 00:15:56,499
template based library as though you had

00:15:54,429 --> 00:15:57,549
an issue with that or you will have it's

00:15:56,499 --> 00:16:02,889
there is no thing

00:15:57,549 --> 00:16:04,209
so most of the developers and libraries

00:16:02,889 --> 00:16:07,299
based on description template just say

00:16:04,209 --> 00:16:10,419
you know what you are shred okay I

00:16:07,299 --> 00:16:12,459
walked as much as I can the regular kgs

00:16:10,419 --> 00:16:16,659
and you know your corner cases well

00:16:12,459 --> 00:16:20,019
whatever and people about that so

00:16:16,659 --> 00:16:23,470
the problem is we forgot one rule which

00:16:20,019 --> 00:16:25,239
is separation of concern when I work

00:16:23,470 --> 00:16:27,009
with my matrix type in my expression

00:16:25,239 --> 00:16:28,959
template based library I'm actually

00:16:27,009 --> 00:16:31,119
doing something which is slightly wrong

00:16:28,959 --> 00:16:33,699
my matrix is both the storage of data

00:16:31,119 --> 00:16:36,279
and it should be ended this way that

00:16:33,699 --> 00:16:38,349
mean I should be copying it correctly

00:16:36,279 --> 00:16:41,709
moving it correctly having the proper

00:16:38,349 --> 00:16:44,919
value of 70 and I'm also a tree spawner

00:16:41,709 --> 00:16:47,319
that I'm the root of lazy iterated

00:16:44,919 --> 00:16:49,989
expression that may or may not require

00:16:47,319 --> 00:16:51,459
the storage to be copied or tagged by

00:16:49,989 --> 00:16:53,619
reference or something else

00:16:51,459 --> 00:16:55,509
so those terminal type Susan yeah

00:16:53,619 --> 00:16:57,039
complicated and it makes the

00:16:55,509 --> 00:17:00,009
implementation of the rest of the system

00:16:57,039 --> 00:17:02,649
complicated he s-said types are usually

00:17:00,009 --> 00:17:03,970
Oh back to that computation there was no

00:17:02,649 --> 00:17:06,429
simple way to know okay give me an

00:17:03,970 --> 00:17:08,259
expression and let's work on the type

00:17:06,429 --> 00:17:10,829
everybody has a different way to encode

00:17:08,259 --> 00:17:13,959
that may or may not be complex and

00:17:10,829 --> 00:17:16,120
bindings of expression in temperate

00:17:13,959 --> 00:17:18,819
context like this where I can solve the

00:17:16,120 --> 00:17:21,639
Z returning a temporary from something

00:17:18,819 --> 00:17:23,649
is complicated so before going further

00:17:21,639 --> 00:17:26,289
what we wanted to do was to eradicate

00:17:23,649 --> 00:17:28,329
this so the one thing we wanted to do is

00:17:26,289 --> 00:17:31,149
that if you say okay let's split the

00:17:28,329 --> 00:17:33,759
concerns the matrix is a storage and

00:17:31,149 --> 00:17:35,200
nothing else and when I want to bid

00:17:33,759 --> 00:17:36,940
something in my expression template

00:17:35,200 --> 00:17:40,029
library I want to build a formula that

00:17:36,940 --> 00:17:42,669
may or may not consume matrices so I can

00:17:40,029 --> 00:17:45,340
actually build it yourself with no

00:17:42,669 --> 00:17:46,629
issues copy temporaries or whatever

00:17:45,340 --> 00:17:50,039
because everything will be copied

00:17:46,629 --> 00:17:51,700
stateless and pure and with this

00:17:50,039 --> 00:17:54,100
stateless

00:17:51,700 --> 00:17:56,230
expression system we could actually make

00:17:54,100 --> 00:17:58,539
the expression across facilities are not

00:17:56,230 --> 00:18:00,549
library matching it over arbitrary

00:17:58,539 --> 00:18:01,059
pattern transforming into something else

00:18:00,549 --> 00:18:02,860
direct

00:18:01,059 --> 00:18:04,830
from the user code and try to see

00:18:02,860 --> 00:18:08,620
transformation of expression makes sense

00:18:04,830 --> 00:18:10,690
we without having to know about the fact

00:18:08,620 --> 00:18:13,389
that that expression actually contains a

00:18:10,690 --> 00:18:15,759
storage and to care for and so to do so

00:18:13,389 --> 00:18:21,519
what we decided to do is actually to do

00:18:15,759 --> 00:18:24,309
some math so if we want you to build a

00:18:21,519 --> 00:18:27,700
DSL for symbolic math the first thing we

00:18:24,309 --> 00:18:29,259
have to ask ourselves is what what are

00:18:27,700 --> 00:18:32,499
the kind of expression we want to deal

00:18:29,259 --> 00:18:34,779
with so you have some types of formulas

00:18:32,499 --> 00:18:39,299
you have very simple ones and you have

00:18:34,779 --> 00:18:42,580
ones where you have like pi or

00:18:39,299 --> 00:18:45,190
exponential functions like this and then

00:18:42,580 --> 00:18:47,409
if you are doing more advanced math then

00:18:45,190 --> 00:18:50,679
you have integrals and derivatives and

00:18:47,409 --> 00:18:53,649
we want to take care of this and then if

00:18:50,679 --> 00:18:55,480
you are a physicist for you partial

00:18:53,649 --> 00:18:59,169
derivatives are very important and

00:18:55,480 --> 00:19:00,700
vectors are also very important and then

00:18:59,169 --> 00:19:02,980
if you have the chance to do general

00:19:00,700 --> 00:19:05,110
relativity you have other problems

00:19:02,980 --> 00:19:09,100
because you need to take care of tensors

00:19:05,110 --> 00:19:12,490
and tones or contraction stuff like this

00:19:09,100 --> 00:19:14,590
and differential geometry and for these

00:19:12,490 --> 00:19:16,629
different types of equations dealing

00:19:14,590 --> 00:19:19,210
with them in a symbolic of the SL for

00:19:16,629 --> 00:19:21,340
example to solve equations or symbol

00:19:19,210 --> 00:19:24,669
like to symbolically solve equation or

00:19:21,340 --> 00:19:28,049
to simplify expression it may use

00:19:24,669 --> 00:19:31,149
different techniques but in all cases

00:19:28,049 --> 00:19:33,220
the important thing about symbolic

00:19:31,149 --> 00:19:35,980
calculus is that we will have this

00:19:33,220 --> 00:19:37,840
principle of substitution so formulas

00:19:35,980 --> 00:19:40,629
are abstract object that are made of

00:19:37,840 --> 00:19:43,960
symbols and some of which are variables

00:19:40,629 --> 00:19:45,279
and when you are doing substitution what

00:19:43,960 --> 00:19:48,309
you want to do is to replace

00:19:45,279 --> 00:19:51,820
consistently these symbol variables by

00:19:48,309 --> 00:19:53,860
values or expressions and currently

00:19:51,820 --> 00:19:55,779
people who are doing surgical staff have

00:19:53,860 --> 00:19:58,720
tools to do that and they are computer

00:19:55,779 --> 00:20:02,139
algebra system and these are software's

00:19:58,720 --> 00:20:04,360
whose role is to manipulate an intrical

00:20:02,139 --> 00:20:06,070
expression so Mathematica as I said

00:20:04,360 --> 00:20:08,619
before Mathematica is doing that my body

00:20:06,070 --> 00:20:12,490
is doing that sage Alden is the energy

00:20:08,619 --> 00:20:14,140
and for example if you are typing

00:20:12,490 --> 00:20:17,290
if you want to get the derivative and

00:20:14,140 --> 00:20:20,620
have an expression you type derivative

00:20:17,290 --> 00:20:24,160
of for example same as sine X plus x

00:20:20,620 --> 00:20:26,380
squared regarding 2x and what the

00:20:24,160 --> 00:20:29,230
computer algebra system will run is not

00:20:26,380 --> 00:20:32,950
actually numerical computation but it

00:20:29,230 --> 00:20:35,020
will just similarly compute the what is

00:20:32,950 --> 00:20:39,220
the symbolic derivative of the

00:20:35,020 --> 00:20:40,870
expression you put and you have all the

00:20:39,220 --> 00:20:43,570
things like simplify if you want to

00:20:40,870 --> 00:20:46,900
simplify an expression in that in the

00:20:43,570 --> 00:20:49,930
case of is sine of x squared plus cosine

00:20:46,900 --> 00:20:53,770
of X square the system should return you

00:20:49,930 --> 00:20:56,680
one and it would be very nice if we

00:20:53,770 --> 00:20:58,630
could have that in C++ do this kind of

00:20:56,680 --> 00:21:00,970
symbolic manipulation and then inject

00:20:58,630 --> 00:21:04,570
that in some numerical code so that

00:21:00,970 --> 00:21:05,260
everything interact nicely so when we

00:21:04,570 --> 00:21:06,970
are talking about mathematical

00:21:05,260 --> 00:21:10,930
expression there are several types of

00:21:06,970 --> 00:21:14,050
them the first most rang the first one

00:21:10,930 --> 00:21:17,350
is the formula so a formula is when you

00:21:14,050 --> 00:21:20,740
effect when you assign least an

00:21:17,350 --> 00:21:22,990
expression to a particular symbol and to

00:21:20,740 --> 00:21:25,540
be able to spot that we need support for

00:21:22,990 --> 00:21:28,180
concerns for name concerns for operators

00:21:25,540 --> 00:21:29,890
for functioning starts and we want to be

00:21:28,180 --> 00:21:32,200
able to support formula combinations so

00:21:29,890 --> 00:21:36,340
that we can inject a formula we can

00:21:32,200 --> 00:21:38,730
replace one a symbolic viable by another

00:21:36,340 --> 00:21:41,860
formula and combine formulas together

00:21:38,730 --> 00:21:44,590
seven thing are equations so equations

00:21:41,860 --> 00:21:46,300
are mathematical statement that asserts

00:21:44,590 --> 00:21:49,540
the equality between two different

00:21:46,300 --> 00:21:52,120
expression for some values of the viable

00:21:49,540 --> 00:21:53,880
symbols you have and to be able to

00:21:52,120 --> 00:21:56,500
support that we need to be able to do

00:21:53,880 --> 00:22:00,370
statement or organization to manipulate

00:21:56,500 --> 00:22:02,620
our expression and also viable in suits

00:22:00,370 --> 00:22:05,110
and soup expression substitution so that

00:22:02,620 --> 00:22:07,900
we can find actually the values we want

00:22:05,110 --> 00:22:10,000
for to solve this equation and then you

00:22:07,900 --> 00:22:11,740
have identities and identities are very

00:22:10,000 --> 00:22:14,380
important to simplify expression

00:22:11,740 --> 00:22:17,530
identities our equation that are always

00:22:14,380 --> 00:22:21,120
true and to be able to do that in an in

00:22:17,530 --> 00:22:23,890
the SL in in in dsl we need to support

00:22:21,120 --> 00:22:26,299
expression and sub expression structural

00:22:23,890 --> 00:22:29,239
matching we need to be able to say

00:22:26,299 --> 00:22:32,479
that's st match the structure of that st

00:22:29,239 --> 00:22:33,919
and they are actually the same and in

00:22:32,479 --> 00:22:36,469
terms of mathematical expression

00:22:33,919 --> 00:22:40,179
depending on the type of simplification

00:22:36,469 --> 00:22:40,179
you want to do depending on the type of

00:22:40,479 --> 00:22:45,349
simplification you want to run and

00:22:42,409 --> 00:22:48,259
calculation you many different different

00:22:45,349 --> 00:22:50,509
stuff and the most simple mathematical

00:22:48,259 --> 00:22:52,969
expression our eyes met expression where

00:22:50,509 --> 00:22:55,789
basically you have the for when I

00:22:52,969 --> 00:22:58,399
predict operators but then the more you

00:22:55,789 --> 00:23:03,399
add stuff for example the spaces your

00:22:58,399 --> 00:23:07,009
this specific function or if you have

00:23:03,399 --> 00:23:09,349
let's say infinite series stuff like

00:23:07,009 --> 00:23:11,629
this you get more and more generic

00:23:09,349 --> 00:23:13,639
mathematical expression and to solve

00:23:11,629 --> 00:23:17,599
them you may need different techniques

00:23:13,639 --> 00:23:23,899
than a basic technique that I just the

00:23:17,599 --> 00:23:26,419
expression but in all cases the way you

00:23:23,899 --> 00:23:28,070
represent your mathematical expression

00:23:26,419 --> 00:23:29,899
manual symbolic expression doesn't

00:23:28,070 --> 00:23:32,059
change so you start with the formula

00:23:29,899 --> 00:23:33,379
that the user type and then you convert

00:23:32,059 --> 00:23:35,719
that into an AST

00:23:33,379 --> 00:23:37,700
so in that case they still stop by the

00:23:35,719 --> 00:23:39,799
multiplication between a and because

00:23:37,700 --> 00:23:40,729
then on one side you have a on the other

00:23:39,799 --> 00:23:42,289
of course

00:23:40,729 --> 00:23:45,229
then inside your course you have an

00:23:42,289 --> 00:23:50,349
addition between something and Phi and

00:23:45,229 --> 00:23:50,349
this something is a multiplication again

00:23:51,070 --> 00:23:57,469
in the tree we get in the trees we get

00:23:55,179 --> 00:23:59,959
the archer important notion the first

00:23:57,469 --> 00:24:02,479
one is our T which is the number of

00:23:59,959 --> 00:24:04,279
children that is not have h not have

00:24:02,479 --> 00:24:06,919
which correspond to the number of

00:24:04,279 --> 00:24:08,929
symbols you need to input for example

00:24:06,919 --> 00:24:11,029
four operators then you have this notion

00:24:08,929 --> 00:24:13,190
of terminal which are nodes that do not

00:24:11,029 --> 00:24:16,579
have any children that correspond they

00:24:13,190 --> 00:24:19,399
can respond to see all things if you

00:24:16,579 --> 00:24:21,169
take a formula then you have several

00:24:19,399 --> 00:24:23,059
components the first one is the

00:24:21,169 --> 00:24:24,859
expression itself an expression can be

00:24:23,059 --> 00:24:26,299
divided into sub expression and

00:24:24,859 --> 00:24:30,440
regardless of whether it's an expression

00:24:26,299 --> 00:24:33,649
also expression both of these are finite

00:24:30,440 --> 00:24:35,239
well from combination of symbol and the

00:24:33,649 --> 00:24:38,179
symbol is an atomic element of an

00:24:35,239 --> 00:24:39,370
expression so for example in the case in

00:24:38,179 --> 00:24:41,779
this case

00:24:39,370 --> 00:24:44,059
every node correspond to a symbol so

00:24:41,779 --> 00:24:47,450
multiply the symbol a is a symbol cosine

00:24:44,059 --> 00:24:48,980
is a symbolic surprise and then you have

00:24:47,450 --> 00:24:51,409
different types of terminal the terminal

00:24:48,980 --> 00:24:53,059
it can be near I functions it can be

00:24:51,409 --> 00:24:56,059
symbolic constants and it can be

00:24:53,059 --> 00:24:58,130
simulate variables and when you want to

00:24:56,059 --> 00:25:03,980
do substitution it has to do with the

00:24:58,130 --> 00:25:06,980
symbolic buyable so this was a simple SC

00:25:03,980 --> 00:25:08,029
but you can have more complicated for

00:25:06,980 --> 00:25:09,110
somebody who take the normal

00:25:08,029 --> 00:25:10,820
distribution the probability

00:25:09,110 --> 00:25:13,460
distribution function of the normal

00:25:10,820 --> 00:25:17,809
distribution get an iced tea like this

00:25:13,460 --> 00:25:21,380
one where you have binary binary or

00:25:17,809 --> 00:25:23,539
purchasing blue you have unary operators

00:25:21,380 --> 00:25:26,659
in purple like square root or

00:25:23,539 --> 00:25:28,700
exponential then you have constants in

00:25:26,659 --> 00:25:30,559
orange and then you have your symbolic

00:25:28,700 --> 00:25:32,179
variables that you want to replace in

00:25:30,559 --> 00:25:35,120
this kind of expression that are in

00:25:32,179 --> 00:25:38,570
green so in that case the symbolic

00:25:35,120 --> 00:25:40,789
variables are Sigma mu and X and you can

00:25:38,570 --> 00:25:42,679
convert any expression in that kind of

00:25:40,789 --> 00:25:44,240
representation so once you have your

00:25:42,679 --> 00:25:46,490
three then you want to iterate through

00:25:44,240 --> 00:25:48,350
this tree so it's just basic stuff but

00:25:46,490 --> 00:25:52,970
depending on what you want to do you may

00:25:48,350 --> 00:25:54,679
want to have different different travel

00:25:52,970 --> 00:25:57,169
solve your tree so for example if you

00:25:54,679 --> 00:26:00,019
want to execute your symbolic expression

00:25:57,169 --> 00:26:02,480
then you will probably go for pre-order

00:26:00,019 --> 00:26:05,539
depth first meaning that every time you

00:26:02,480 --> 00:26:08,360
you have an encounter with the node you

00:26:05,539 --> 00:26:10,250
just run an operation on it then you

00:26:08,360 --> 00:26:11,960
have in order which is very useful for

00:26:10,250 --> 00:26:14,539
display when you have binary operation

00:26:11,960 --> 00:26:16,789
when you access the parent node in

00:26:14,539 --> 00:26:19,309
between children node then you have

00:26:16,789 --> 00:26:20,990
postorder which is very useful to do

00:26:19,309 --> 00:26:24,529
expression analysis because if it

00:26:20,990 --> 00:26:27,440
corresponds to it's very useful

00:26:24,529 --> 00:26:29,419
expression and it and you access the

00:26:27,440 --> 00:26:31,330
partner after you access the children

00:26:29,419 --> 00:26:34,100
and then you have also breadth-first

00:26:31,330 --> 00:26:37,070
access but I don't think we ever

00:26:34,100 --> 00:26:39,919
encounter a use for symbolic mathematics

00:26:37,070 --> 00:26:42,350
where it's actually useful and if you

00:26:39,919 --> 00:26:45,799
want a generic tree traversal strategy

00:26:42,350 --> 00:26:47,210
so it's a function that takes an oath as

00:26:45,799 --> 00:26:49,100
an input and then you have a pre

00:26:47,210 --> 00:26:51,350
function and in function and the post

00:26:49,100 --> 00:26:53,420
function the first thing you do is that

00:26:51,350 --> 00:26:55,670
you execute the pre-function and

00:26:53,420 --> 00:26:57,800
then you do a loop and the children and

00:26:55,670 --> 00:26:59,630
for each children you recursively call

00:26:57,800 --> 00:27:01,790
traverse then you execute your in

00:26:59,630 --> 00:27:03,890
function and you know between each

00:27:01,790 --> 00:27:06,950
children and then at the end you call

00:27:03,890 --> 00:27:08,660
your pass function I don't know and for

00:27:06,950 --> 00:27:11,120
example if you just want to do execution

00:27:08,660 --> 00:27:12,410
then you forget about about the middle

00:27:11,120 --> 00:27:14,290
loop and the pass function you just

00:27:12,410 --> 00:27:17,870
execute the perfection

00:27:14,290 --> 00:27:20,530
so if we get back to the ice the

00:27:17,870 --> 00:27:22,700
abstract syntax tree if we have this

00:27:20,530 --> 00:27:23,720
mathematical expression that corresponds

00:27:22,700 --> 00:27:26,300
with this tree

00:27:23,720 --> 00:27:28,880
then in pre-order traversal in pass one

00:27:26,300 --> 00:27:31,550
to that so you get first the multiply

00:27:28,880 --> 00:27:34,070
then the eve and the cost then the

00:27:31,550 --> 00:27:35,660
cosine then the plus extra extra and

00:27:34,070 --> 00:27:37,720
this is very useful when you want to

00:27:35,660 --> 00:27:40,790
execute your expression as I said before

00:27:37,720 --> 00:27:42,650
the in order is useful for displaying

00:27:40,790 --> 00:27:44,360
when you have binary operators because

00:27:42,650 --> 00:27:47,390
it's first one to the first formula in

00:27:44,360 --> 00:27:49,100
that case and then first order would

00:27:47,390 --> 00:27:50,720
correspond to this representation which

00:27:49,100 --> 00:27:56,210
is very useful when you want to do

00:27:50,720 --> 00:27:58,850
expression analysis and I think the most

00:27:56,210 --> 00:28:00,980
important thing so we won't work on is

00:27:58,850 --> 00:28:04,220
that we have these extra syntax trees

00:28:00,980 --> 00:28:06,290
representing symbolic expression and the

00:28:04,220 --> 00:28:08,120
very important stuff as Yule said is

00:28:06,290 --> 00:28:11,330
that mathematical expression are

00:28:08,120 --> 00:28:13,070
stateless which means that we can do

00:28:11,330 --> 00:28:15,140
separation of concern and the problem

00:28:13,070 --> 00:28:17,360
that most expedite domain-specific

00:28:15,140 --> 00:28:21,230
language have that rely on expression

00:28:17,360 --> 00:28:24,080
templates a that for example you use

00:28:21,230 --> 00:28:27,260
matrix to serve as a storage for

00:28:24,080 --> 00:28:28,910
building your eyes but the iced tea and

00:28:27,260 --> 00:28:31,430
the storage are two different things and

00:28:28,910 --> 00:28:34,070
what we want to do is to separate these

00:28:31,430 --> 00:28:36,290
two things so that in the first step we

00:28:34,070 --> 00:28:38,720
build the icy structure of the formula

00:28:36,290 --> 00:28:40,850
that has no that idea that has no state

00:28:38,720 --> 00:28:44,180
in it and then in step two we want to

00:28:40,850 --> 00:28:48,800
inject the data in the formula through

00:28:44,180 --> 00:28:51,410
simple symbol substitution and then the

00:28:48,800 --> 00:28:54,260
question is how do we actually do that

00:28:51,410 --> 00:28:58,610
right that's a very good question

00:28:54,260 --> 00:29:02,030
actually so it comes from the times when

00:28:58,610 --> 00:29:03,860
we actually do some computation so the

00:29:02,030 --> 00:29:05,610
question is what do we want to achieve

00:29:03,860 --> 00:29:09,210
in terms of

00:29:05,610 --> 00:29:11,040
cause implementation and user API so we

00:29:09,210 --> 00:29:13,440
won't as we say build status from them

00:29:11,040 --> 00:29:15,540
that can be reused for different values

00:29:13,440 --> 00:29:18,660
different type of storage whatever we

00:29:15,540 --> 00:29:22,260
want built from registering variables or

00:29:18,660 --> 00:29:23,790
for custom symbols we want to interact

00:29:22,260 --> 00:29:27,720
with this formula and you know in the

00:29:23,790 --> 00:29:29,940
native way and we want to be able to

00:29:27,720 --> 00:29:33,660
write visitors for those trees to do

00:29:29,940 --> 00:29:35,670
things basic things automatically so

00:29:33,660 --> 00:29:36,660
basically we need a bunch of things we

00:29:35,670 --> 00:29:41,640
need an extraction template

00:29:36,660 --> 00:29:45,840
implementation that is yeah value base

00:29:41,640 --> 00:29:47,340
concepts for no state we have to have

00:29:45,840 --> 00:29:50,280
something which is quite controversial

00:29:47,340 --> 00:29:53,210
new language fidelity argument passed by

00:29:50,280 --> 00:29:56,040
name to formula because we don't we want

00:29:53,210 --> 00:29:58,710
need and we don't want to impose an

00:29:56,040 --> 00:30:03,510
order on the symbols so if you're from

00:29:58,710 --> 00:30:05,309
DAC as bible's X Y and G there is no

00:30:03,510 --> 00:30:06,870
order on that so you should be able to

00:30:05,309 --> 00:30:08,940
call your function by saying okay X

00:30:06,870 --> 00:30:11,460
deport to these T is support to that and

00:30:08,940 --> 00:30:13,440
so on we need to have something which is

00:30:11,460 --> 00:30:17,640
easy to extend when you want to write to

00:30:13,440 --> 00:30:19,530
visitors and our design goal at this

00:30:17,640 --> 00:30:22,440
point was to say okay whenever we write

00:30:19,530 --> 00:30:24,150
something it is not that stupid okay

00:30:22,440 --> 00:30:26,910
that's probably too complex and we have

00:30:24,150 --> 00:30:29,070
to rewrite it so most of the code that

00:30:26,910 --> 00:30:31,799
we show there it's basically the actual

00:30:29,070 --> 00:30:34,980
coding world except for let's say error

00:30:31,799 --> 00:30:38,640
ending and we wanted to be as compact as

00:30:34,980 --> 00:30:42,210
possible and as so let's not miss the

00:30:38,640 --> 00:30:45,059
first batch of this this is what we want

00:30:42,210 --> 00:30:46,919
to write in the end so I can actually be

00:30:45,059 --> 00:30:49,320
the formula using registry in variables

00:30:46,919 --> 00:30:53,160
and we were very inspired to call them X

00:30:49,320 --> 00:30:54,510
Y Z Z but it's Y Z can only go so fast

00:30:53,160 --> 00:30:56,940
so maybe you want to have your own

00:30:54,510 --> 00:30:59,520
variables with a proper name so we have

00:30:56,940 --> 00:31:02,010
this door apparent syntax that you can

00:30:59,520 --> 00:31:05,250
build a symbol okay and you can pass an

00:31:02,010 --> 00:31:07,830
arbitrary string to name your variable

00:31:05,250 --> 00:31:10,740
obviously F and G are bad it is the same

00:31:07,830 --> 00:31:12,570
formula to compute the same thing except

00:31:10,740 --> 00:31:16,169
is they are different because the

00:31:12,570 --> 00:31:18,150
symbols that use are different and so

00:31:16,169 --> 00:31:19,880
three thing we can do is that we can

00:31:18,150 --> 00:31:25,610
actually

00:31:19,880 --> 00:31:28,679
evaluate domina by passing values to its

00:31:25,610 --> 00:31:32,130
its summary variables but those value

00:31:28,679 --> 00:31:35,100
can also be other variables so I mean

00:31:32,130 --> 00:31:37,799
six what is going on that Chi 2 is

00:31:35,100 --> 00:31:40,980
basically saying okay I'm taking the

00:31:37,799 --> 00:31:43,320
formula F and replacing X with mass 1 Y

00:31:40,980 --> 00:31:44,850
with mass to a Jewish distance which end

00:31:43,320 --> 00:31:48,390
up with giving us an object which is

00:31:44,850 --> 00:31:50,059
strictly similar to G ok we can do

00:31:48,390 --> 00:31:53,700
partial evaluation because you just app

00:31:50,059 --> 00:31:55,760
not fast valuable value to a valuable

00:31:53,700 --> 00:31:58,230
which means that G 10 is basically

00:31:55,760 --> 00:32:00,809
another formula in which distance is

00:31:58,230 --> 00:32:03,240
fixed to ten we can mix them using other

00:32:00,809 --> 00:32:05,159
operation G requires three different

00:32:03,240 --> 00:32:08,250
symbolic variables mass one mass to

00:32:05,159 --> 00:32:11,100
distance F requires XYZ so if I wanted

00:32:08,250 --> 00:32:13,679
to every K on something I need to pass

00:32:11,100 --> 00:32:16,020
six back of values and I can actually

00:32:13,679 --> 00:32:20,000
evaluate things by actually passing

00:32:16,020 --> 00:32:23,159
random values to every symbol inside and

00:32:20,000 --> 00:32:24,720
the name of the symbol are important not

00:32:23,159 --> 00:32:27,029
the other so we can pass mass one

00:32:24,720 --> 00:32:28,409
dimension x2 or whatever so that's

00:32:27,029 --> 00:32:30,990
basically what we want to end up with

00:32:28,409 --> 00:32:32,760
okay and the first thing we need to do

00:32:30,990 --> 00:32:34,470
for that is actually adding an actual

00:32:32,760 --> 00:32:38,070
light weight one six four based

00:32:34,470 --> 00:32:40,080
expression template so we went back to

00:32:38,070 --> 00:32:42,600
the fundamentals that was photo provided

00:32:40,080 --> 00:32:44,370
that says that we need the tree with

00:32:42,600 --> 00:32:46,409
terminals and mean the way to build

00:32:44,370 --> 00:32:48,990
nodes but instead of having a very

00:32:46,409 --> 00:32:50,760
generic approach like Bruce Prado we

00:32:48,990 --> 00:32:53,549
went for were very add of solutions

00:32:50,760 --> 00:32:57,899
based on GDP and with a minimal amount

00:32:53,549 --> 00:33:00,179
of let's say been resource to do this we

00:32:57,899 --> 00:33:02,279
will use a lot of stand up and stretch

00:33:00,179 --> 00:33:04,049
the boy and so on and the fact of the

00:33:02,279 --> 00:33:06,690
formula is take this we don't have to

00:33:04,049 --> 00:33:08,309
care about all store chains into the

00:33:06,690 --> 00:33:10,110
expression Depok itself we store

00:33:08,309 --> 00:33:13,169
everything by value and most of those

00:33:10,110 --> 00:33:15,570
value are empty anyway so yet quite

00:33:13,169 --> 00:33:18,289
nicely optimized and whenever it's

00:33:15,570 --> 00:33:20,760
possible everything is cost expert and

00:33:18,289 --> 00:33:23,760
so the code that we show there is

00:33:20,760 --> 00:33:26,760
directly ninety percent of the actual

00:33:23,760 --> 00:33:28,919
code for the generic node elements that

00:33:26,760 --> 00:33:33,760
encode a random node with an arbitrary

00:33:28,919 --> 00:33:35,770
number of children well it read I mean

00:33:33,760 --> 00:33:37,210
we taken Vanek amount of children and

00:33:35,770 --> 00:33:39,100
put them into a top poll and we have

00:33:37,210 --> 00:33:40,840
something that users are rarity the tag

00:33:39,100 --> 00:33:42,880
which is actually what's the operation

00:33:40,840 --> 00:33:46,210
on the node and everything is basically

00:33:42,880 --> 00:33:47,800
doing and by doing this we found out

00:33:46,210 --> 00:33:49,810
that another thing which is interesting

00:33:47,800 --> 00:33:51,580
is actually having adult a sensation

00:33:49,810 --> 00:33:53,980
because if you look at what kind of math

00:33:51,580 --> 00:33:56,620
you write every day when you have a

00:33:53,980 --> 00:33:59,200
really function ordinary functions

00:33:56,620 --> 00:34:02,710
that's pretty much everything we have a

00:33:59,200 --> 00:34:04,920
few cases of gallery or questionnaire

00:34:02,710 --> 00:34:07,690
functions there are not that much

00:34:04,920 --> 00:34:10,120
frequent so we just you know like

00:34:07,690 --> 00:34:12,810
specialized not for one into G's rather

00:34:10,120 --> 00:34:16,480
trivial if context buttons are aq again

00:34:12,810 --> 00:34:18,790
and that's pretty much everything expert

00:34:16,480 --> 00:34:21,940
is a CITT bass data just organized

00:34:18,790 --> 00:34:24,280
everything else and we're done I mean

00:34:21,940 --> 00:34:26,290
the expression template layer is that if

00:34:24,280 --> 00:34:30,280
you wanted registeel eyes comment into

00:34:26,290 --> 00:34:32,920
this so very fast okay so we can be the

00:34:30,280 --> 00:34:34,920
expression we haven't anything just make

00:34:32,920 --> 00:34:37,630
everything for texture and value

00:34:34,920 --> 00:34:41,200
friendly so interesting past came

00:34:37,630 --> 00:34:42,910
afterwards all can I actually match two

00:34:41,200 --> 00:34:44,740
eyes in structure one with the other and

00:34:42,910 --> 00:34:46,960
I can I know that our laboratory

00:34:44,740 --> 00:34:49,120
expression e is actually the product of

00:34:46,960 --> 00:34:51,400
two expression one containing your plus

00:34:49,120 --> 00:34:54,310
and those are being a constant something

00:34:51,400 --> 00:34:57,010
like this mousse proto and Gustav as a

00:34:54,310 --> 00:34:59,890
notion of grammar and transforms that

00:34:57,010 --> 00:35:02,110
you can recursively define as a template

00:34:59,890 --> 00:35:05,380
structure containing to itself and so on

00:35:02,110 --> 00:35:08,050
and so far well like they say on

00:35:05,380 --> 00:35:11,110
Facebook is complicated okay so we

00:35:08,050 --> 00:35:12,340
wanted something more straightforward by

00:35:11,110 --> 00:35:14,620
having something which is that if you

00:35:12,340 --> 00:35:19,240
say you know expression this is what I

00:35:14,620 --> 00:35:21,160
wanted to look does it fit so we wanted

00:35:19,240 --> 00:35:22,900
also to a place order like I want to say

00:35:21,160 --> 00:35:24,970
okay is my expression any kind of

00:35:22,900 --> 00:35:28,230
operation it is assemble to determine or

00:35:24,970 --> 00:35:31,600
any constant and so on and so forth and

00:35:28,230 --> 00:35:33,670
the trick was to actually delegate the

00:35:31,600 --> 00:35:35,650
matching of each sub structures to to

00:35:33,670 --> 00:35:37,600
sub structure itself because there's a

00:35:35,650 --> 00:35:40,270
local knowledge of what it is supposed

00:35:37,600 --> 00:35:42,550
to be and checks the only thing that

00:35:40,270 --> 00:35:44,470
makes sense to be checked and we have a

00:35:42,550 --> 00:35:46,480
small macros that wrap all around this

00:35:44,470 --> 00:35:47,320
so we can ensure that every core of this

00:35:46,480 --> 00:35:51,780
matching thing

00:35:47,320 --> 00:35:54,430
is called expert said basically for

00:35:51,780 --> 00:35:57,250
hiding the fact that some compilers are

00:35:54,430 --> 00:35:59,170
more or less lineand with what is an

00:35:57,250 --> 00:36:00,970
actual prospects for context and

00:35:59,170 --> 00:36:04,330
evaluation context so we wanted to be

00:36:00,970 --> 00:36:07,000
sure it works everywhere so this is not

00:36:04,330 --> 00:36:08,950
again so let's imagine it has all the

00:36:07,000 --> 00:36:10,900
things already has children in the

00:36:08,950 --> 00:36:12,730
conservatory and whatnot and so it has a

00:36:10,900 --> 00:36:14,860
static constants for match function and

00:36:12,730 --> 00:36:16,720
what can I do if I want to know if

00:36:14,860 --> 00:36:18,460
something is actually like this node

00:36:16,720 --> 00:36:20,260
well first things first

00:36:18,460 --> 00:36:22,960
maybe we want to know if it's any

00:36:20,260 --> 00:36:25,360
expression so someone wanted to make his

00:36:22,960 --> 00:36:27,490
node with the place order to Joker for

00:36:25,360 --> 00:36:30,250
any kind of expression that's present

00:36:27,490 --> 00:36:32,500
video yes and an expression that tickly

00:36:30,250 --> 00:36:34,300
what happens leaving six to nine but

00:36:32,500 --> 00:36:37,120
sometimes it could be something else and

00:36:34,300 --> 00:36:40,180
the only case is where I'm actually

00:36:37,120 --> 00:36:42,190
wanting to return true if the other

00:36:40,180 --> 00:36:45,040
thing I want to check is something which

00:36:42,190 --> 00:36:48,250
is actually a node with the same ret as

00:36:45,040 --> 00:36:50,740
me if not well I'm not interested I

00:36:48,250 --> 00:36:52,720
don't match and there is a very specific

00:36:50,740 --> 00:36:55,120
case that if you want to see if you're

00:36:52,720 --> 00:36:57,130
not of a given tag and a given list of

00:36:55,120 --> 00:36:58,750
children is actually matching another

00:36:57,130 --> 00:37:01,360
node with a given tag and a given

00:36:58,750 --> 00:37:02,800
children well let's check the tires say

00:37:01,360 --> 00:37:05,170
let's check we have the same number of

00:37:02,800 --> 00:37:07,660
children and let's violently check that

00:37:05,170 --> 00:37:10,480
every children match this corresponding

00:37:07,660 --> 00:37:13,630
children to the other end of the story

00:37:10,480 --> 00:37:15,190
Tommy knows do the same things all the

00:37:13,630 --> 00:37:18,580
other nodes do the same thing with more

00:37:15,190 --> 00:37:20,980
or less complication and we have a bunch

00:37:18,580 --> 00:37:24,280
of as I say Joker for detecting the

00:37:20,980 --> 00:37:30,760
classical things so it doesn't take that

00:37:24,280 --> 00:37:33,040
much and the one actual use case of iced

00:37:30,760 --> 00:37:36,520
tea matching is simplifying expression

00:37:33,040 --> 00:37:38,590
on the fly one thing that we learn quite

00:37:36,520 --> 00:37:41,530
sadly when dealing with the old way of

00:37:38,590 --> 00:37:44,020
expression templates that as you build

00:37:41,530 --> 00:37:46,900
your tree the type of the same things

00:37:44,020 --> 00:37:49,480
tree grow ever and ever larger in some

00:37:46,900 --> 00:37:51,610
kind sometimes you can even these are

00:37:49,480 --> 00:37:54,010
only sources of slow compile time

00:37:51,610 --> 00:37:56,460
because it takes so much space memory to

00:37:54,010 --> 00:37:58,510
up the magnet symbol that you keep

00:37:56,460 --> 00:38:00,980
allocating things inside the compiler to

00:37:58,510 --> 00:38:04,400
story so one

00:38:00,980 --> 00:38:09,050
wanted to experiment with that what if

00:38:04,400 --> 00:38:11,089
in some amount of identities we know

00:38:09,050 --> 00:38:13,540
about and that makes sense all the time

00:38:11,089 --> 00:38:16,790
can we add constriction time of the node

00:38:13,540 --> 00:38:19,130
simplified so maybe if I write by

00:38:16,790 --> 00:38:21,200
example X plus X or maybe I don't write

00:38:19,130 --> 00:38:25,609
it before I mean I'm not that stupid

00:38:21,200 --> 00:38:27,109
but they say you merge two to formula it

00:38:25,609 --> 00:38:30,740
does know about and then there's being

00:38:27,109 --> 00:38:33,800
extra X well maybe I can actually you

00:38:30,740 --> 00:38:35,780
know store that as to X well we don't

00:38:33,800 --> 00:38:38,119
win that much but maybe I have something

00:38:35,780 --> 00:38:40,280
which is X plus X plus X plus X with X

00:38:38,119 --> 00:38:45,500
plus whatever and I want Jesse to be 10

00:38:40,280 --> 00:38:48,079
X okay same for identity with 0 & 1 with

00:38:45,500 --> 00:38:50,230
the other operators and the succession

00:38:48,079 --> 00:38:53,329
of powers which is really the most

00:38:50,230 --> 00:38:55,130
complicated cases that right so

00:38:53,329 --> 00:38:57,349
basically what we do we have a bunch of

00:38:55,130 --> 00:38:59,150
identities we want to match had no

00:38:57,349 --> 00:39:01,339
conception times that if you want to

00:38:59,150 --> 00:39:03,500
compiler with you and we just smash the

00:39:01,339 --> 00:39:05,329
accession temp back down to what it

00:39:03,500 --> 00:39:08,119
should be the interesting thing that we

00:39:05,329 --> 00:39:13,339
never ever construct the complicated

00:39:08,119 --> 00:39:14,660
tree just completely compatible so

00:39:13,339 --> 00:39:21,109
others it works well let's have a look

00:39:14,660 --> 00:39:22,670
at the plus no generator so we have this

00:39:21,109 --> 00:39:24,170
function B that takes the tag of the

00:39:22,670 --> 00:39:26,599
node so I want to build the node which

00:39:24,170 --> 00:39:28,849
do plus and I have an expression on the

00:39:26,599 --> 00:39:30,980
left and expression on the right and it

00:39:28,849 --> 00:39:31,310
says an error chase so what what's going

00:39:30,980 --> 00:39:33,710
on

00:39:31,310 --> 00:39:35,540
so maybe error left and the right hand

00:39:33,710 --> 00:39:37,700
side are the same so maybe Russia's

00:39:35,540 --> 00:39:40,400
match error says this case I can return

00:39:37,700 --> 00:39:44,030
two times energy not that I'm returning

00:39:40,400 --> 00:39:45,920
to underscore C time Celsius and the

00:39:44,030 --> 00:39:48,230
stasi being a new deal the defined

00:39:45,920 --> 00:39:50,119
intervals that basically jumped to into

00:39:48,230 --> 00:39:53,060
an integral constant of value 2 so we

00:39:50,119 --> 00:39:55,270
can static and know that the constant is

00:39:53,060 --> 00:39:58,220
equal to 2 in the type of the expression

00:39:55,270 --> 00:40:00,109
if I do a sum 0 on the left on the right

00:39:58,220 --> 00:40:02,060
and just return the other one that's to

00:40:00,109 --> 00:40:05,359
your and there is another one which is a

00:40:02,060 --> 00:40:07,430
bit more complicated if the left hand

00:40:05,359 --> 00:40:09,770
side is something which is a constant

00:40:07,430 --> 00:40:12,140
times a random expression and on the

00:40:09,770 --> 00:40:13,890
right side I got the same thing constant

00:40:12,140 --> 00:40:18,840
time and expression I don't know

00:40:13,890 --> 00:40:21,600
if both expression so the expert which

00:40:18,840 --> 00:40:25,440
is there and the expert which is their

00:40:21,600 --> 00:40:27,480
match then I can just take both of the

00:40:25,440 --> 00:40:29,310
constant send them and return the single

00:40:27,480 --> 00:40:32,460
note which is the sum of the constants

00:40:29,310 --> 00:40:34,890
times the rest of the expression so

00:40:32,460 --> 00:40:37,110
obviously this block is repeated for all

00:40:34,890 --> 00:40:39,600
the combination of my constant on the

00:40:37,110 --> 00:40:41,550
left on the right and so on and if

00:40:39,600 --> 00:40:44,940
everything fails well that I just I just

00:40:41,550 --> 00:40:48,120
returned a lingerer no so we have this

00:40:44,940 --> 00:40:50,910
match a macro that do this and we can

00:40:48,120 --> 00:40:54,870
just change if Const expert on match to

00:40:50,910 --> 00:40:58,260
see all our is our our IQs build and

00:40:54,870 --> 00:41:02,550
take take decision about about that and

00:40:58,260 --> 00:41:04,170
change the code on the right okay so we

00:41:02,550 --> 00:41:09,350
can match I see we can actually simplify

00:41:04,170 --> 00:41:12,990
them on the fly oh do we actually manage

00:41:09,350 --> 00:41:15,210
same revivals similar variables doesn't

00:41:12,990 --> 00:41:16,740
store any data the only information I

00:41:15,210 --> 00:41:18,960
need to know about the symbol is its

00:41:16,740 --> 00:41:20,670
name so I need to find a way to take the

00:41:18,960 --> 00:41:22,920
name of the cons and symbolic variables

00:41:20,670 --> 00:41:25,830
and put it into these types if we were

00:41:22,920 --> 00:41:28,200
writing tsipras first 20 or 23 you could

00:41:25,830 --> 00:41:29,910
actually use a non template template for

00:41:28,200 --> 00:41:32,700
me to treat that food the conquer

00:41:29,910 --> 00:41:35,820
pointer into a box and put the box into

00:41:32,700 --> 00:41:37,860
a template parameters itself except

00:41:35,820 --> 00:41:39,990
we're not so we wanted to find a way to

00:41:37,860 --> 00:41:42,420
do this and the simplest thing we found

00:41:39,990 --> 00:41:45,930
out was to actually take the string that

00:41:42,420 --> 00:41:50,160
could present the symbol name like on

00:41:45,930 --> 00:41:53,430
the entry there okay and turn it into an

00:41:50,160 --> 00:41:55,680
integral sequence of 64 bits integral

00:41:53,430 --> 00:41:58,800
which is basically the concatenation of

00:41:55,680 --> 00:42:02,160
all the years of carbon the cool thing

00:41:58,800 --> 00:42:04,200
is that if you have two symbols the same

00:42:02,160 --> 00:42:06,540
name they cannot have different type

00:42:04,200 --> 00:42:10,920
because their name is the fight deadly

00:42:06,540 --> 00:42:14,880
and well you can walk this way with this

00:42:10,920 --> 00:42:17,460
underscore see you here or we have this

00:42:14,880 --> 00:42:19,140
rocket the dollar if anything that you

00:42:17,460 --> 00:42:20,760
are entitled to have spaces in the

00:42:19,140 --> 00:42:24,890
Desrochers variable names you really

00:42:20,760 --> 00:42:27,749
want that spoilers don't do that oh

00:42:24,890 --> 00:42:30,809
isn't it just war

00:42:27,749 --> 00:42:32,849
another idea we had at some point but we

00:42:30,809 --> 00:42:35,939
still need to amass detail was actually

00:42:32,849 --> 00:42:38,399
just compute some kind of ash like UCSC

00:42:35,939 --> 00:42:41,429
or md5 of something like this and just

00:42:38,399 --> 00:42:43,919
thought that the actual interesting part

00:42:41,429 --> 00:42:46,349
with this storage is that unless you

00:42:43,919 --> 00:42:50,009
have arbitrary long name of variables

00:42:46,349 --> 00:42:52,109
it's actually quite small and we have a

00:42:50,009 --> 00:42:54,329
simple way to go back from the sequence

00:42:52,109 --> 00:42:58,140
of values back to the actual screen if

00:42:54,329 --> 00:43:01,890
you want to display the viable name for

00:42:58,140 --> 00:43:04,679
the photo was a joke I try to see when

00:43:01,890 --> 00:43:08,899
this wind break time of compile time so

00:43:04,679 --> 00:43:11,279
if you want to know if you take the text

00:43:08,899 --> 00:43:14,099
version of Hamlet

00:43:11,279 --> 00:43:16,890
use your play and you put it into this

00:43:14,099 --> 00:43:19,759
and discussing things takes about 16

00:43:16,890 --> 00:43:22,499
minutes to combine when it's combined

00:43:19,759 --> 00:43:25,829
unless at least if you have 32 GB of RAM

00:43:22,499 --> 00:43:28,349
but where it was and for more it's

00:43:25,829 --> 00:43:29,269
taking more sensible viable size it

00:43:28,349 --> 00:43:31,919
doesn't matter

00:43:29,269 --> 00:43:33,809
at first I mean it starts to be long

00:43:31,919 --> 00:43:36,329
when you are like 100-something see

00:43:33,809 --> 00:43:38,249
character use simple name which is quite

00:43:36,329 --> 00:43:41,849
a long single name so it doesn't impact

00:43:38,249 --> 00:43:43,829
anything so now we have that so every

00:43:41,849 --> 00:43:46,829
symbol as a different type which is a

00:43:43,829 --> 00:43:50,489
Queen's name so we know now that if I

00:43:46,829 --> 00:43:53,369
have a X in in two places in in formula

00:43:50,489 --> 00:43:56,309
I know that the same thing but now how

00:43:53,369 --> 00:43:58,349
do we do this fancy x equals something

00:43:56,309 --> 00:44:01,739
like or something so we need a way to

00:43:58,349 --> 00:44:04,739
map a value to a symbol but the symbol

00:44:01,739 --> 00:44:07,409
as value as no information so what we

00:44:04,739 --> 00:44:09,809
want to do is map of value to the type

00:44:07,409 --> 00:44:11,009
of the symbol and we already know what

00:44:09,809 --> 00:44:13,109
how to do this

00:44:11,009 --> 00:44:15,179
I mean function overload do that I mean

00:44:13,109 --> 00:44:17,219
you map of a type which is the type you

00:44:15,179 --> 00:44:21,389
want to function to take in to the value

00:44:17,219 --> 00:44:24,659
it returns so what we basically do is we

00:44:21,389 --> 00:44:27,449
have a function for values that we cater

00:44:24,659 --> 00:44:29,819
that for each pair of a symbol in the

00:44:27,449 --> 00:44:32,309
value turn it into a lender function

00:44:29,819 --> 00:44:35,309
that weight variable of the symbol and

00:44:32,309 --> 00:44:38,579
returns a value input and we use a not

00:44:35,309 --> 00:44:41,039
STD of a rod like structure to gather

00:44:38,579 --> 00:44:43,769
all those lambdas any other small

00:44:41,039 --> 00:44:46,619
which to know if and where the symbol is

00:44:43,769 --> 00:44:52,140
actually inside business so it's

00:44:46,619 --> 00:44:53,910
basically 50 lines name parameters so we

00:44:52,140 --> 00:44:56,249
have just aggregate binding structure

00:44:53,910 --> 00:44:58,559
which is basically a report from SCT

00:44:56,249 --> 00:45:01,349
overload it takes another varying amount

00:44:58,559 --> 00:45:04,049
of lambdas inherit from all those

00:45:01,349 --> 00:45:05,789
lenders so he has all the operator

00:45:04,049 --> 00:45:08,699
function codes that we we propagate

00:45:05,789 --> 00:45:13,679
there and we are two of them the first

00:45:08,699 --> 00:45:16,049
one a weight for whatever does so box is

00:45:13,679 --> 00:45:19,109
a simple wrapper around the type so if

00:45:16,049 --> 00:45:21,359
you give me any type and it's not code

00:45:19,109 --> 00:45:23,549
by any other of a retro function core I

00:45:21,359 --> 00:45:26,489
go there and I will talk about the fee I

00:45:23,549 --> 00:45:28,979
don't know your symbol and one way to

00:45:26,489 --> 00:45:31,859
actually ask for a symbol and if you

00:45:28,979 --> 00:45:35,009
don't find it you return a default value

00:45:31,859 --> 00:45:37,949
and we found this funny audience which

00:45:35,009 --> 00:45:40,859
basically says okay if I were calling

00:45:37,949 --> 00:45:43,169
myself with the type you want do I get

00:45:40,859 --> 00:45:45,029
not supported fee is that the case I

00:45:43,169 --> 00:45:47,519
returned the default value and if not I

00:45:45,029 --> 00:45:49,919
do the call so I in constant further

00:45:47,519 --> 00:45:52,499
check if if the type is actually

00:45:49,919 --> 00:45:55,650
supported somewhere in this mess because

00:45:52,499 --> 00:45:57,569
we have no way to introspect all the

00:45:55,650 --> 00:45:59,640
operator parents from all the lambda to

00:45:57,569 --> 00:46:02,489
knowing the title somewhere so we just

00:45:59,640 --> 00:46:04,709
ask do you want it and if you don't want

00:46:02,489 --> 00:46:07,519
it on the default and if not I just call

00:46:04,709 --> 00:46:09,989
you at one time that's really funny

00:46:07,519 --> 00:46:11,969
so we have this aggregate bindings but

00:46:09,989 --> 00:46:14,159
what do we advocate we aggregate this

00:46:11,969 --> 00:46:17,249
vine function we talked about so bind

00:46:14,159 --> 00:46:20,219
take the value and the type P and it

00:46:17,249 --> 00:46:23,640
just returns a lambda that takes both of

00:46:20,219 --> 00:46:25,949
key parameters and returns value and

00:46:23,640 --> 00:46:28,499
what we do that if we pass a natural

00:46:25,949 --> 00:46:29,159
ever you reference we copy inside the

00:46:28,499 --> 00:46:32,789
lambda

00:46:29,159 --> 00:46:35,759
yeah mu instead of just letting it so

00:46:32,789 --> 00:46:38,279
now what do we do well we put these apps

00:46:35,759 --> 00:46:41,579
aggregate bindings of bind function to

00:46:38,279 --> 00:46:45,509
these tight match things that just wrap

00:46:41,579 --> 00:46:48,179
all of this into a proper a proper

00:46:45,509 --> 00:46:50,400
interface that just the wrapper and what

00:46:48,179 --> 00:46:53,279
happens when you write this so on the

00:46:50,400 --> 00:46:54,900
con side you use this V for X plus y and

00:46:53,279 --> 00:46:59,579
I want to be very teach

00:46:54,900 --> 00:47:03,420
x equals point 5 and y equal 4 so it's

00:46:59,579 --> 00:47:06,480
and why are symbols they are terminals

00:47:03,420 --> 00:47:08,970
in our iced tea so there are Nascimento

00:47:06,480 --> 00:47:12,450
burrito that takes whatever and do the

00:47:08,970 --> 00:47:14,099
body they bind their own symbol X with

00:47:12,450 --> 00:47:16,589
whatever value you want it to be and

00:47:14,099 --> 00:47:18,059
returns is lambda so what happens at the

00:47:16,589 --> 00:47:19,589
operative function code of the

00:47:18,059 --> 00:47:22,650
expression which we've an arbitrary

00:47:19,589 --> 00:47:24,390
numbers of vine results pass it into a

00:47:22,650 --> 00:47:26,490
type map and show that into a widget

00:47:24,390 --> 00:47:28,829
does that say okay you know what take my

00:47:26,490 --> 00:47:31,950
iced tea this is binding of value you

00:47:28,829 --> 00:47:35,520
need to use do your computation and the

00:47:31,950 --> 00:47:40,020
funny thing is that if I don't pass a

00:47:35,520 --> 00:47:42,720
value for every symbols let's say I

00:47:40,020 --> 00:47:44,609
don't pass why I just buys X what

00:47:42,720 --> 00:47:47,400
happens is that when the evaluator will

00:47:44,609 --> 00:47:49,920
try to do this express Y you say okay

00:47:47,400 --> 00:47:52,710
give me the value associated to X ok

00:47:49,920 --> 00:47:54,630
that's point five and give me the value

00:47:52,710 --> 00:47:58,049
associated to Y and say where it's

00:47:54,630 --> 00:48:01,440
nothing so I just do UI back oh so I

00:47:58,049 --> 00:48:02,160
need to do point five plus y YB in the

00:48:01,440 --> 00:48:04,170
terminal

00:48:02,160 --> 00:48:06,450
if you just found a new expression where

00:48:04,170 --> 00:48:08,609
X will be replaced by point five we

00:48:06,450 --> 00:48:10,770
didn't have to write a single line to AB

00:48:08,609 --> 00:48:13,799
the partial evolution running that's of

00:48:10,770 --> 00:48:16,140
anything and so now let's think about

00:48:13,799 --> 00:48:17,789
visitors so evaluate so every visitors

00:48:16,140 --> 00:48:20,460
use a bit complex because we need to

00:48:17,789 --> 00:48:22,049
jump in and out in your visitors for

00:48:20,460 --> 00:48:23,849
getting information about the flight and

00:48:22,049 --> 00:48:26,609
so on but the very funny thing is that

00:48:23,849 --> 00:48:28,680
let's say I want to write this daily

00:48:26,609 --> 00:48:31,470
rate visitor that eken expression and

00:48:28,680 --> 00:48:34,260
compute it's an empty call somebody

00:48:31,470 --> 00:48:35,549
called everybody so we don't put

00:48:34,260 --> 00:48:37,200
everything there because it's quite

00:48:35,549 --> 00:48:40,230
longer than that just so you get the

00:48:37,200 --> 00:48:42,000
gist of it well I have a visitor in our

00:48:40,230 --> 00:48:44,819
library is basically a structure with

00:48:42,000 --> 00:48:47,430
visit members don't and the VIP member

00:48:44,819 --> 00:48:49,829
must be context for each possible so

00:48:47,430 --> 00:48:52,289
what do I do I know I mean I went to

00:48:49,829 --> 00:48:54,240
high school so do you normally so you

00:48:52,289 --> 00:48:56,789
know how to derivate something from the

00:48:54,240 --> 00:48:59,130
formula that's with your ok so if my

00:48:56,789 --> 00:49:03,750
expressions actually any kind of

00:48:59,130 --> 00:49:06,480
terminal so I match expose them well

00:49:03,750 --> 00:49:09,310
what should i do well if the terminal

00:49:06,480 --> 00:49:13,180
and elevating is the symbol I'm

00:49:09,310 --> 00:49:15,640
over so we F over the X so whenever I

00:49:13,180 --> 00:49:19,000
find your X I have to turn into a 1 and

00:49:15,640 --> 00:49:20,980
everything else 0 so I just return the

00:49:19,000 --> 00:49:24,430
retail world value the constant value

00:49:20,980 --> 00:49:27,580
which is 0 if I'm actually the symbol I

00:49:24,430 --> 00:49:30,010
should be and one that I'm the symbol it

00:49:27,580 --> 00:49:33,310
should be and you what not and we just

00:49:30,010 --> 00:49:34,690
shows that into a box afterwards there

00:49:33,310 --> 00:49:36,940
is a theme of sermons or some of the

00:49:34,690 --> 00:49:39,250
derivative so we just go visit on both

00:49:36,940 --> 00:49:44,140
sides of the expression if it match x4 +

00:49:39,250 --> 00:49:47,140
x / same from - and the good old you

00:49:44,140 --> 00:49:49,450
know what multiplication coming out and

00:49:47,140 --> 00:49:52,060
do this we have another block that

00:49:49,450 --> 00:49:54,160
endures all the other functions by

00:49:52,060 --> 00:49:56,260
seeing that every time you want to watch

00:49:54,160 --> 00:49:58,420
what you want to write so you want to

00:49:56,260 --> 00:50:00,340
write the derivative of function you

00:49:58,420 --> 00:50:02,920
derivate what's inside the function you

00:50:00,340 --> 00:50:04,570
fetch in the table what kind of function

00:50:02,920 --> 00:50:08,020
should be when you derive and will be

00:50:04,570 --> 00:50:12,430
visiting and the funny thing is when we

00:50:08,020 --> 00:50:14,260
write this that's where the actual

00:50:12,430 --> 00:50:17,350
simplifications come in and is actually

00:50:14,260 --> 00:50:20,500
useful let's say your magnification you

00:50:17,350 --> 00:50:24,010
have x times y and you derivate all of

00:50:20,500 --> 00:50:29,230
these by reference to X you end up with

00:50:24,010 --> 00:50:31,570
a derivative of x times y plus x time

00:50:29,230 --> 00:50:33,820
derivative of Y which is 0 and the other

00:50:31,570 --> 00:50:39,550
one is 1 so we end up with trying to be

00:50:33,820 --> 00:50:43,540
the expression x times 1 plus 0 times X

00:50:39,550 --> 00:50:46,570
okay and zero times and - one time just

00:50:43,540 --> 00:50:48,460
get simplified so if you do end here but

00:50:46,570 --> 00:50:50,860
in that figure could we just call this

00:50:48,460 --> 00:50:52,990
function over and over again and you

00:50:50,860 --> 00:50:55,180
look at the size of you tree it never

00:50:52,990 --> 00:51:00,340
blows up it's always rather small that's

00:50:55,180 --> 00:51:01,840
actually cool well so all involved which

00:51:00,340 --> 00:51:04,840
you have opened design question we are

00:51:01,840 --> 00:51:07,360
not that satisfied with everything is

00:51:04,840 --> 00:51:10,210
the online simplification a good idea or

00:51:07,360 --> 00:51:12,190
should it be you know also available as

00:51:10,210 --> 00:51:15,820
we do so if you really want to simplify

00:51:12,190 --> 00:51:18,040
the given form you can just ask it is it

00:51:15,820 --> 00:51:20,500
is there a way to write those matches

00:51:18,040 --> 00:51:23,089
for the simplification identity so it

00:51:20,500 --> 00:51:24,890
doesn't have to enumerate all of them

00:51:23,089 --> 00:51:28,999
stupid way especially for the ending of

00:51:24,890 --> 00:51:31,069
constants of course all the examples air

00:51:28,999 --> 00:51:33,140
work with values like double and

00:51:31,069 --> 00:51:35,690
integrals the goal is to make them works

00:51:33,140 --> 00:51:38,239
with array that starts to work right now

00:51:35,690 --> 00:51:40,309
it's not complete what if i mix array

00:51:38,239 --> 00:51:42,890
and constant i need to broadcast a

00:51:40,309 --> 00:51:45,079
constant and so on and we should have

00:51:42,890 --> 00:51:46,609
something that still look like a smart

00:51:45,079 --> 00:51:49,160
expression template so we can actually

00:51:46,609 --> 00:51:50,839
match a bunch of tree to say okay no way

00:51:49,160 --> 00:51:53,920
you know what I'm just turning that into

00:51:50,839 --> 00:51:56,989
a single pre-computation of the results

00:51:53,920 --> 00:52:01,489
we also want to have semantic

00:51:56,989 --> 00:52:03,739
constraints on the variables so we can

00:52:01,489 --> 00:52:06,200
actually write from there exists and if

00:52:03,739 --> 00:52:08,479
you pass a value for Z or X which

00:52:06,200 --> 00:52:10,309
doesn't fit the concept of what's a real

00:52:08,479 --> 00:52:14,269
number or what's a tensile number the

00:52:10,309 --> 00:52:17,690
formula doesn't build okay so maybe we

00:52:14,269 --> 00:52:20,049
need a simplified visitor the array

00:52:17,690 --> 00:52:22,309
ending for as visitor for to me okay

00:52:20,049 --> 00:52:24,079
counting how many different pointers I

00:52:22,309 --> 00:52:26,479
need to the data about the size and

00:52:24,079 --> 00:52:30,589
ranks of all the other array and so on

00:52:26,479 --> 00:52:33,380
and basically the constraints could

00:52:30,589 --> 00:52:35,569
actually be something like thin wrapper

00:52:33,380 --> 00:52:38,359
that just say okay when you evaluate me

00:52:35,569 --> 00:52:40,969
or when you build me check that this

00:52:38,359 --> 00:52:42,829
concept requires is true before doing

00:52:40,969 --> 00:52:45,469
whatever and if not just you know just

00:52:42,829 --> 00:52:48,799
don't compile so we still have work to

00:52:45,469 --> 00:52:51,319
do on that but we found out that the

00:52:48,799 --> 00:52:57,799
technique gives some kind of funny

00:52:51,319 --> 00:53:00,200
results so yeah I mean of course of

00:52:57,799 --> 00:53:01,460
course compiled rights for that was a

00:53:00,200 --> 00:53:03,589
given

00:53:01,460 --> 00:53:07,099
so we basically brought some simple

00:53:03,589 --> 00:53:09,799
stuff there so we have this each time so

00:53:07,099 --> 00:53:12,279
I binded by Z or Z square and so on

00:53:09,799 --> 00:53:14,749
which is exactly what we had examples

00:53:12,279 --> 00:53:17,630
there with me I just put the six because

00:53:14,749 --> 00:53:20,450
the constant was like whatever we have G

00:53:17,630 --> 00:53:22,849
which is this m1 times m2 thing and we

00:53:20,450 --> 00:53:26,089
have the g2 which is a renaming of the

00:53:22,849 --> 00:53:28,249
formula F with new symbols if you look

00:53:26,089 --> 00:53:30,950
at what happens when you try to see if F

00:53:28,249 --> 00:53:35,119
and G are the same then so is no because

00:53:30,950 --> 00:53:37,010
F deals with XYZ and G deals with m1 m2

00:53:35,119 --> 00:53:40,040
this so it's not the same time

00:53:37,010 --> 00:53:42,470
when we renamed F by changing all the

00:53:40,040 --> 00:53:44,119
symbols with others and check that G is

00:53:42,470 --> 00:53:48,160
the same as you do so and so we get

00:53:44,119 --> 00:53:50,570
because everything match everything and

00:53:48,160 --> 00:53:52,640
actually we can actually do some

00:53:50,570 --> 00:53:57,220
computations there I'll just put some

00:53:52,640 --> 00:54:00,440
numbers using g2 and the m1 m2 thing

00:53:57,220 --> 00:54:02,930
okay well that's the DCC I guess so this

00:54:00,440 --> 00:54:07,640
is not very funny doesn't compute the

00:54:02,930 --> 00:54:11,510
thing okay

00:54:07,640 --> 00:54:13,550
so train says as a result is Wow yeah he

00:54:11,510 --> 00:54:17,690
was evil whoever she's probably right

00:54:13,550 --> 00:54:19,730
yeah 20 times C divided by 100 square so

00:54:17,690 --> 00:54:22,369
it's okay so everything is bad at each

00:54:19,730 --> 00:54:24,550
video the cool thing is that the

00:54:22,369 --> 00:54:25,750
formulas in self just dissolve into

00:54:24,550 --> 00:54:28,940
nothingness

00:54:25,750 --> 00:54:31,040
okay mostly because I put everything

00:54:28,940 --> 00:54:34,880
from texture let's see what happens if I

00:54:31,040 --> 00:54:37,010
don't have a context for formula well

00:54:34,880 --> 00:54:41,109
everything still works if anything is

00:54:37,010 --> 00:54:44,630
that in this case I got some computation

00:54:41,109 --> 00:54:48,410
some code generated well it's probably

00:54:44,630 --> 00:54:50,510
correct yeah there is a division and

00:54:48,410 --> 00:54:53,750
conversion of an integral to a double so

00:54:50,510 --> 00:54:56,390
it's probably right the other funny

00:54:53,750 --> 00:55:00,319
thing is that connect we have a look at

00:54:56,390 --> 00:55:06,579
this let us say let's see what happens

00:55:00,319 --> 00:55:06,579
when okay let's see what happens when I

00:55:06,700 --> 00:55:14,650
just do something like I don't know

00:55:10,750 --> 00:55:18,260
let's say 1 all the time

00:55:14,650 --> 00:55:24,680
the question is what's the type of eg

00:55:18,260 --> 00:55:27,380
what about you know somewhere and as I

00:55:24,680 --> 00:55:40,660
say this should give us another three

00:55:27,380 --> 00:55:46,670
things yeah so the type in full name for

00:55:40,660 --> 00:55:48,349
this oh yeah that's really useful so

00:55:46,670 --> 00:55:50,300
yeah I got to note which is a division

00:55:48,349 --> 00:55:55,130
of

00:55:50,300 --> 00:55:59,599
identification between an integer and

00:55:55,130 --> 00:56:02,839
means a girl and some symbols which is

00:55:59,599 --> 00:56:04,580
one I don't know which one yet and so on

00:56:02,839 --> 00:56:06,890
and so forth so we haven't known so we

00:56:04,580 --> 00:56:09,859
still have a formula so we can actually

00:56:06,890 --> 00:56:13,849
write something like PG of the other

00:56:09,859 --> 00:56:16,810
variables and you just work and we can

00:56:13,849 --> 00:56:19,609
actually push the envelope quite a bit

00:56:16,810 --> 00:56:23,780
let's see if I can do something together

00:56:19,609 --> 00:56:29,240
oh yeah I can probably what a rhetorical

00:56:23,780 --> 00:56:31,550
question let's say you are that so as

00:56:29,240 --> 00:56:35,470
you saw earlier so it's a it's I don't

00:56:31,550 --> 00:56:39,010
know each X is X plus X cubed things and

00:56:35,470 --> 00:56:52,339
what we say is that PG is actually K

00:56:39,010 --> 00:56:54,589
where X so we can pass your formula to

00:56:52,339 --> 00:56:57,320
symbol and we are you probably have a

00:56:54,589 --> 00:57:03,369
few meter long symbol name now yeah

00:56:57,320 --> 00:57:03,369
pretty much yeah

00:57:03,920 --> 00:57:09,230
this probably look like the formula

00:57:05,420 --> 00:57:11,270
sometimes something so I just work and

00:57:09,230 --> 00:57:14,750
if we look at the compact and put your

00:57:11,270 --> 00:57:18,200
thing is not that big is like 0.3

00:57:14,750 --> 00:57:22,010
seconds we do need that from some test

00:57:18,200 --> 00:57:23,630
and you start beating the alpha second

00:57:22,010 --> 00:57:26,720
math when you start to our formula with

00:57:23,630 --> 00:57:29,930
20-something symbols or different with

00:57:26,720 --> 00:57:33,530
all every not bigger different types so

00:57:29,930 --> 00:57:40,580
that's quite a huge use expression so

00:57:33,530 --> 00:57:44,210
what we spent was with GCC I don't

00:57:40,580 --> 00:57:47,960
remember but you should if not well so

00:57:44,210 --> 00:57:49,460
we have this flexibility on this cool

00:57:47,960 --> 00:57:52,670
things that we we have this notion of

00:57:49,460 --> 00:57:57,080
viable interacting symbols we can run

00:57:52,670 --> 00:58:03,500
around so well what's where when we but

00:57:57,080 --> 00:58:06,350
do we hand I mean that's so we

00:58:03,500 --> 00:58:08,060
that you see and we saw that actually we

00:58:06,350 --> 00:58:10,730
can actually build a DSL system where

00:58:08,060 --> 00:58:13,430
value are not inside the tree everything

00:58:10,730 --> 00:58:15,620
is a symbol and you just repeat the same

00:58:13,430 --> 00:58:17,090
formula again on different values that

00:58:15,620 --> 00:58:20,900
leads to a very simple implementation

00:58:17,090 --> 00:58:22,730
also your extraction template systems

00:58:20,900 --> 00:58:26,390
everything's phone sex first God is

00:58:22,730 --> 00:58:28,820
rather simple and we find another way

00:58:26,390 --> 00:58:30,560
another place where actually taking your

00:58:28,820 --> 00:58:32,780
lambdas and doing something she's not

00:58:30,560 --> 00:58:33,530
supposed to do exactly the correct

00:58:32,780 --> 00:58:35,600
things to do

00:58:33,530 --> 00:58:37,610
I'm speaking about the name document

00:58:35,600 --> 00:58:39,350
things we get a bunch of free by so this

00:58:37,610 --> 00:58:41,720
name argument implementation she's

00:58:39,350 --> 00:58:43,310
probably enough for a lot of cases we

00:58:41,720 --> 00:58:45,440
have this constructs furniture for

00:58:43,310 --> 00:58:47,330
expression structures and we have a very

00:58:45,440 --> 00:58:50,600
simple visit of boilerplate so

00:58:47,330 --> 00:58:54,050
everything is a cute video and compiled

00:58:50,600 --> 00:59:04,400
fat so that's things but we're not done

00:58:54,050 --> 00:59:06,980
yet so our end game sorry for that it's

00:59:04,400 --> 00:59:08,570
a bit further than this if you ask the

00:59:06,980 --> 00:59:10,280
scientist and you tell me okay what do

00:59:08,570 --> 00:59:12,350
you do when you write mad and probably

00:59:10,280 --> 00:59:15,280
say I'm using Natick and if it doesn't

00:59:12,350 --> 00:59:18,830
it should be using that thing anyway and

00:59:15,280 --> 00:59:21,650
the cool thing is that you know I'm big

00:59:18,830 --> 00:59:23,450
fan of what I do secret doesn't compile

00:59:21,650 --> 00:59:25,100
time with low expression and I think

00:59:23,450 --> 00:59:27,650
yeah but what if we actually have a read

00:59:25,100 --> 00:59:29,390
passer for arbitrary language at compile

00:59:27,650 --> 00:59:31,610
time so we can actually fast like that

00:59:29,390 --> 00:59:34,280
you know you know in a thing like this

00:59:31,610 --> 00:59:37,250
and give us a formula actually so we can

00:59:34,280 --> 00:59:38,720
just call it up towards directly so you

00:59:37,250 --> 00:59:41,150
can actually you know like take your

00:59:38,720 --> 00:59:44,120
papers and just encode directly there is

00:59:41,150 --> 00:59:49,340
no error and you may have heard about

00:59:44,120 --> 00:59:52,280
you know STD in bed no does anybody know

00:59:49,340 --> 00:59:54,260
okay so some so STD in bed but if you

00:59:52,280 --> 00:59:56,060
say okay compiler and you see see specs

00:59:54,260 --> 00:59:58,160
fine okay just load it up at compile

00:59:56,060 --> 01:00:00,380
time and put it into this context record

00:59:58,160 --> 01:00:03,950
shop for me please you see where this is

01:00:00,380 --> 01:00:07,520
heading okay so let's say we have F

01:00:03,950 --> 01:00:09,800
which is equal from text from some STD

01:00:07,520 --> 01:00:12,830
embed things and dog okay so that if

01:00:09,800 --> 01:00:13,600
anything it's not that far away from

01:00:12,830 --> 01:00:17,330
being done

01:00:13,600 --> 01:00:19,370
the passer is actually walking

01:00:17,330 --> 01:00:21,080
- a way to know what you want to pass

01:00:19,370 --> 01:00:23,360
and the other thing is that we want to

01:00:21,080 --> 01:00:29,110
be able to write these things so that's

01:00:23,360 --> 01:00:32,690
a classical linear system of equations

01:00:29,110 --> 01:00:36,620
we could actually have PDE inside that

01:00:32,690 --> 01:00:37,040
and the trick is to actually gather your

01:00:36,620 --> 01:00:39,500
things

01:00:37,040 --> 01:00:42,350
analyze your systems extract

01:00:39,500 --> 01:00:44,570
informations and look at ice-t and say

01:00:42,350 --> 01:00:47,240
oh that's a linear systems all that

01:00:44,570 --> 01:00:50,450
abuses them and pick the correct

01:00:47,240 --> 01:00:51,440
numerical systems the numerical methods

01:00:50,450 --> 01:00:53,300
to solve it

01:00:51,440 --> 01:00:56,300
extracting the data directly from the

01:00:53,300 --> 01:00:58,010
ice so say for your attention where

01:00:56,300 --> 01:01:01,490
there is a bunch of acknowledgements of

01:00:58,010 --> 01:01:03,050
course from different paths and if you

01:01:01,490 --> 01:01:04,240
have any questions thank you for your

01:01:03,050 --> 01:01:13,330
attention

01:01:04,240 --> 01:01:18,620
[Applause]

01:01:13,330 --> 01:01:20,300
yep thank you for this talk it's it's

01:01:18,620 --> 01:01:22,970
amazing amazing project that you guys

01:01:20,300 --> 01:01:25,580
have been working on one question I have

01:01:22,970 --> 01:01:28,160
is have you've had any discussions about

01:01:25,580 --> 01:01:34,580
being able to work with like vectorized

01:01:28,160 --> 01:01:36,290
operations sorry oh if you're able to

01:01:34,580 --> 01:01:38,600
have an extension to be able to work

01:01:36,290 --> 01:01:40,970
over oh yeah yes so the question is do

01:01:38,600 --> 01:01:42,500
we we end up actually walking on data

01:01:40,970 --> 01:01:45,890
which are in bad pictures yeah that's

01:01:42,500 --> 01:01:47,900
exactly where we are right now and it's

01:01:45,890 --> 01:01:51,140
more like actually finding a way to say

01:01:47,900 --> 01:01:52,910
what happens if I mean okay give me you

01:01:51,140 --> 01:01:55,010
give me an STD vectors I probably know

01:01:52,910 --> 01:01:56,930
what to do with data and size if you

01:01:55,010 --> 01:01:59,060
give me an eigen table or something that

01:01:56,930 --> 01:02:01,280
came from wherever I need to find a way

01:01:59,060 --> 01:02:05,390
to say okay I dunno this type so I need

01:02:01,280 --> 01:02:07,220
to you know wrap it somewhere so I can

01:02:05,390 --> 01:02:09,860
get my information so we are at this

01:02:07,220 --> 01:02:11,780
point of actually trying to find what

01:02:09,860 --> 01:02:13,250
kind of data we need from an avid term

01:02:11,780 --> 01:02:16,280
storage so we can do whatever we want

01:02:13,250 --> 01:02:18,320
and the next step is actually yeah doing

01:02:16,280 --> 01:02:20,360
this wrapping so offensive vectors of CO

01:02:18,320 --> 01:02:22,850
vector it's a matrix and so on but we

01:02:20,360 --> 01:02:23,630
are currently I mean the fingers into

01:02:22,850 --> 01:02:27,710
that right

01:02:23,630 --> 01:02:32,840
but yes that's that's bad yes I might go

01:02:27,710 --> 01:02:34,280
I great stuff I really wanted to see

01:02:32,840 --> 01:02:36,530
that you guys submit some of this stuff

01:02:34,280 --> 01:02:37,820
for permit for the hg19 machine learning

01:02:36,530 --> 01:02:40,370
group where we were actually working on

01:02:37,820 --> 01:02:42,920
differentiation okay the other thing is

01:02:40,370 --> 01:02:44,540
for the earlier part would you guys talk

01:02:42,920 --> 01:02:46,790
about for the SL for the matrix M play

01:02:44,540 --> 01:02:48,260
algebra stuff you just want to make sure

01:02:46,790 --> 01:03:00,500
that you guys know where that tomorrow

01:02:48,260 --> 01:03:03,380
in the SD 14 tomorrow in the context of

01:03:00,500 --> 01:03:05,440
the things that you guys thanks thank

01:03:03,380 --> 01:03:05,440
you

01:03:17,460 --> 01:03:31,079
right there so the B bar is that an

01:03:22,349 --> 01:03:33,180
empty type where oh wow

01:03:31,079 --> 01:03:35,309
okay so sufficient watch is well where

01:03:33,180 --> 01:03:36,720
exactly you're one of those symbols so

01:03:35,309 --> 01:03:46,920
that's that it is a variable on which

01:03:36,720 --> 01:03:49,559
you want to debate okay yeah that's on

01:03:46,920 --> 01:03:52,500
our short list of things to do right now

01:03:49,559 --> 01:03:54,450
just watch it like it works and there is

01:03:52,500 --> 01:03:56,760
a couple of other places and we're empty

01:03:54,450 --> 01:03:58,890
beta optimization are probably needed I

01:03:56,760 --> 01:04:00,599
mean the nari node and probably the

01:03:58,890 --> 01:04:02,880
binary node we can actually read from

01:04:00,599 --> 01:04:08,280
the one of the others so that's on our

01:04:02,880 --> 01:04:09,930
to-do list yet okay that's that's over

01:04:08,280 --> 01:04:12,050
sorry we could have questioned

01:04:09,930 --> 01:04:18,229
afterwards thank you again

01:04:12,050 --> 01:04:18,229

YouTube URL: https://www.youtube.com/watch?v=XH00wB_bbU4


