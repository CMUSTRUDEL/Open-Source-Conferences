Title: CppCon 2019: Rian Quinn "Using Freestanding C++ for C++17 in Shellcode, UEFI, Embedded & Unikernels"
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
This presentation is a must-see if you would like to learn how C++ works under the hood or how to include the Standard Library when compiling with "-ffreestanding". In this presentation, we will examine how C++ works behind the scenes as well as how to include C++ and the Standard Library in freestanding environments. Such environments include shellcode, UEFI, embedded systems (with no OS available), and unikernels. There are many environments where an OS is not present, or the facilities of the OS are inaccessible (for example with shellcode). In these environments, one compiles C/C++ with "-ffreestanding" to produce an executable with no external dependencies. The downside to this approach is the Standard Library is also not accessible, meaning useful functions such as std::unique_ptr, std::mutex, and std::list are not available. Furthermore, some core language facilities such as std::move, std::forward, and dynamic_cast are also unavailable as the Standard Library implements these.

This presentation teaches the audience how to overcome these problems by leveraging Libc++ from LLVM and Newlib to create a working, freestanding C++ environment with support for the Standard Library. Topics presented include how to compile a static, position independent executable (also called a static PIE) with support for C++ and the Standard Library, how to execute your project in a freestanding environment and what the limitations are and how to overcome them. Finally, this presentation will conclude with a demonstration of a UEFI application written in C++ as well as a demonstration of leveraging C++ in shellcode.

— 
Rian Quinn
Assured Information Security, Inc.
CTO
Greater Denver Area

Dr. Rian Quinn is a Senior Principal Investigator in the Trusted Information Systems Group at Assured Information Security, Inc. were he has focused on trusted computing and hypervisor related technologies for nearly 10 years. He holds a Ph.D. in Computer Engineering with specializations in Information Assurance and Computer Architectures from Binghamton University. He is a lead developer and co-founder of the Bareflank Hypervisor, and is an active member of several open source projects including OpenXT. Specialties: computer architectures, virtualization, operating systems, kernel programming, cyber security, and open source.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,970 --> 00:00:14,110
all right so before we start the

00:00:11,590 --> 00:00:16,869
presentation has anybody in this room

00:00:14,110 --> 00:00:18,960
ever written your own buffer overflow

00:00:16,869 --> 00:00:20,860
attacks raise your hand

00:00:18,960 --> 00:00:23,020
awesome that's a lot more than I

00:00:20,860 --> 00:00:26,739
expected how many of you have ever seen

00:00:23,020 --> 00:00:30,070
one demonstrated live yeah well all of

00:00:26,739 --> 00:00:32,110
you ability of that gun and today my

00:00:30,070 --> 00:00:33,910
name is Ryan Quinn and I work for a

00:00:32,110 --> 00:00:36,100
short informations to carry out of Rome

00:00:33,910 --> 00:00:40,120
New York out of all places will you do

00:00:36,100 --> 00:00:42,520
cyber security today I will be

00:00:40,120 --> 00:00:46,030
presenting how to use your freestanding

00:00:42,520 --> 00:00:49,270
C++ and everything from shell code to

00:00:46,030 --> 00:00:51,670
UEFI embedded systems in the kernels we

00:00:49,270 --> 00:00:55,080
use the approach I'm presenting today

00:00:51,670 --> 00:00:59,020
for our own hypervisor called bare plank

00:00:55,080 --> 00:01:01,000
if you're familiar with my talk in 2016

00:00:59,020 --> 00:01:02,440
on how to run C++ in the Windows and

00:01:01,000 --> 00:01:08,860
Linux kernel this is the logical

00:01:02,440 --> 00:01:10,329
extension to that talk also if you got

00:01:08,860 --> 00:01:12,969
to see Ben's presentation which was

00:01:10,329 --> 00:01:14,829
fantastic we are going to take a very

00:01:12,969 --> 00:01:18,219
different approach to what he presented

00:01:14,829 --> 00:01:21,780
today and you know you're on YouTube go

00:01:18,219 --> 00:01:21,780
watch it first it was fantastic

00:01:22,350 --> 00:01:26,979
ok so what's really the goal of this

00:01:25,479 --> 00:01:30,939
presentation well we want to build every

00:01:26,979 --> 00:01:33,310
one C++ everywhere I mean everywhere so

00:01:30,939 --> 00:01:35,649
no limitations at all

00:01:33,310 --> 00:01:38,799
IOT automotive embedded is usually the

00:01:35,649 --> 00:01:39,939
use case people care the most about but

00:01:38,799 --> 00:01:42,609
there's a lot of operating systems

00:01:39,939 --> 00:01:43,840
frankly that don't support C++ I throw

00:01:42,609 --> 00:01:45,369
thread X up there I don't know if it

00:01:43,840 --> 00:01:49,780
does anymore or not but I know for a

00:01:45,369 --> 00:01:51,249
while didn't and some systems just don't

00:01:49,780 --> 00:01:53,139
have any operating systems at all

00:01:51,249 --> 00:01:56,229
you're literally writing applications

00:01:53,139 --> 00:01:58,060
for direct Hardware you're writing your

00:01:56,229 --> 00:02:01,149
own kernels or you know kernels for

00:01:58,060 --> 00:02:03,520
example include OS you're gonna have to

00:02:01,149 --> 00:02:06,700
do this or your own hypervisors like

00:02:03,520 --> 00:02:10,030
what I usually work on what about UEFI

00:02:06,700 --> 00:02:13,240
and BIOS have you ever wanted to run C++

00:02:10,030 --> 00:02:14,800
from a UEFI application or shell code

00:02:13,240 --> 00:02:16,060
and flat binaries so a lot of work I've

00:02:14,800 --> 00:02:17,500
done in the past has all been with flat

00:02:16,060 --> 00:02:19,090
binaries and if you've ever attempted to

00:02:17,500 --> 00:02:20,170
do C++ in that environment you'll know

00:02:19,090 --> 00:02:22,110
why it's so complicated

00:02:20,170 --> 00:02:26,400
my shell code is essential

00:02:22,110 --> 00:02:29,120
written mostly flat binary all right so

00:02:26,400 --> 00:02:31,170
what is freestanding mean well

00:02:29,120 --> 00:02:32,370
freestanding essentially means that you

00:02:31,170 --> 00:02:38,190
just don't have access to all the stuff

00:02:32,370 --> 00:02:40,890
you want so you know you like been said

00:02:38,190 --> 00:02:42,150
in his previous talk before mine you

00:02:40,890 --> 00:02:44,100
know you do have some things like

00:02:42,150 --> 00:02:45,390
standard in standard deaths you know but

00:02:44,100 --> 00:02:46,890
they're really just definitions there's

00:02:45,390 --> 00:02:48,390
really nothing useful in those libraries

00:02:46,890 --> 00:02:52,260
other than here's how I define it

00:02:48,390 --> 00:02:54,900
integer so there's really no useful

00:02:52,260 --> 00:02:56,820
functions at all there's no libraries

00:02:54,900 --> 00:02:58,709
there's no C runtime support which I get

00:02:56,820 --> 00:03:02,130
into a little bit surprisingly that can

00:02:58,709 --> 00:03:04,830
be really frustrating we don't have and

00:03:02,130 --> 00:03:05,910
you know in non free setting

00:03:04,830 --> 00:03:07,320
environments there's there's no way

00:03:05,910 --> 00:03:09,810
you're gonna get flat binaries to work

00:03:07,320 --> 00:03:11,970
properly and then sometimes you do need

00:03:09,810 --> 00:03:14,250
standard wood like I said in the

00:03:11,970 --> 00:03:15,480
description of the talk that one of the

00:03:14,250 --> 00:03:17,670
biggest problems I ran into when I

00:03:15,480 --> 00:03:19,110
started trying to get C++ to run for the

00:03:17,670 --> 00:03:20,850
types of projects I wanted to use

00:03:19,110 --> 00:03:23,040
there's just simple things like dynamic

00:03:20,850 --> 00:03:25,080
cast in stead move don't exist without

00:03:23,040 --> 00:03:30,090
the standard library I have no idea why

00:03:25,080 --> 00:03:32,670
but that's the way it is and you know

00:03:30,090 --> 00:03:35,040
you it exception supports another big

00:03:32,670 --> 00:03:36,420
one you you can turn all this stuff off

00:03:35,040 --> 00:03:37,560
you can make you know ways of getting

00:03:36,420 --> 00:03:41,519
around all this stuff but in the end or

00:03:37,560 --> 00:03:43,830
you're really programming C++ and you're

00:03:41,519 --> 00:03:45,450
certainly not going to be GSL or sorry

00:03:43,830 --> 00:03:47,310
core guideline compliant if you do

00:03:45,450 --> 00:03:48,600
attempt to do it you know not using

00:03:47,310 --> 00:03:50,910
exceptions and not using the add

00:03:48,600 --> 00:03:52,230
function that kind of stuff means that

00:03:50,910 --> 00:03:54,840
you're just not you know guideline

00:03:52,230 --> 00:03:56,670
complain at all so I really wanted to

00:03:54,840 --> 00:03:59,010
find a way to fix this like how do i how

00:03:56,670 --> 00:04:01,739
do I ensure that I can use all the same

00:03:59,010 --> 00:04:05,220
standard C++ functionality that I used

00:04:01,739 --> 00:04:06,660
I'm used to using that I love in my you

00:04:05,220 --> 00:04:07,769
know sort of freestanding environments

00:04:06,660 --> 00:04:11,310
where I just don't have access to this

00:04:07,769 --> 00:04:13,950
stuff alright so if you want to kind of

00:04:11,310 --> 00:04:18,840
do this yourself you can start by

00:04:13,950 --> 00:04:20,820
grabbing lVN's Lib C++ and lip C++ API

00:04:18,840 --> 00:04:22,970
and then of course you know you're gonna

00:04:20,820 --> 00:04:25,740
need a web C to go along with this and

00:04:22,970 --> 00:04:27,810
so you could use new lid this is good

00:04:25,740 --> 00:04:29,970
this is not their actual logo when I

00:04:27,810 --> 00:04:32,370
googled LLVM logo this is what I got so

00:04:29,970 --> 00:04:35,780
I had to put it up there it's a My

00:04:32,370 --> 00:04:35,780
Little Pony version of their actual logo

00:04:38,430 --> 00:04:47,039
my colleagues are not like so but any

00:04:42,300 --> 00:04:49,590
rate this is how we started we wanted to

00:04:47,039 --> 00:04:51,840
get all of C++ the whole thing whole

00:04:49,590 --> 00:04:53,639
shebang and a free-standing environment

00:04:51,840 --> 00:04:56,520
where these kind of limitations exist

00:04:53,639 --> 00:04:58,620
and how do you make that work this isn't

00:04:56,520 --> 00:05:00,870
easy in fact when we started you

00:04:58,620 --> 00:05:03,770
couldn't really compile live C++ with

00:05:00,870 --> 00:05:07,410
new live at all that's not a problem now

00:05:03,770 --> 00:05:10,110
but it was back in 2016 so let's start

00:05:07,410 --> 00:05:13,080
with looking at the compilers or sorry

00:05:10,110 --> 00:05:16,650
the compiler flags rather I want to keep

00:05:13,080 --> 00:05:17,760
in mind as we go through this we're like

00:05:16,650 --> 00:05:19,380
I said we're taking the totally

00:05:17,760 --> 00:05:22,020
different approach to free standing ok

00:05:19,380 --> 00:05:23,550
most free standing is essentially you

00:05:22,020 --> 00:05:26,070
know hey you get some facilities from

00:05:23,550 --> 00:05:28,349
C++ or C but most of the stuff you care

00:05:26,070 --> 00:05:29,610
about you don't get we're trying to take

00:05:28,349 --> 00:05:30,870
the opposite approach that says I have

00:05:29,610 --> 00:05:32,430
this free standing environment I want

00:05:30,870 --> 00:05:34,560
all that good stuff because frankly I

00:05:32,430 --> 00:05:36,990
don't want to rewrite stit array instead

00:05:34,560 --> 00:05:38,580
back turn all this stuff right I want to

00:05:36,990 --> 00:05:40,710
use all that code how do I do that

00:05:38,580 --> 00:05:41,610
I want exception support I want runtime

00:05:40,710 --> 00:05:45,870
zipper I want all of it

00:05:41,610 --> 00:05:46,919
how do I do that so these are a lot of

00:05:45,870 --> 00:05:48,720
the various different flags you're gonna

00:05:46,919 --> 00:05:50,520
need when you start and we're gonna

00:05:48,720 --> 00:05:52,740
leverage clang for all of this the

00:05:50,520 --> 00:05:54,570
reason we we do that is that

00:05:52,740 --> 00:05:56,639
clangs really helpful when it comes to

00:05:54,570 --> 00:05:57,810
the cross compilation side of things if

00:05:56,639 --> 00:05:59,909
you've ever tried to create a cross

00:05:57,810 --> 00:06:01,740
compiler GCC you know the pain is those

00:05:59,909 --> 00:06:03,240
two having to recompile it just for

00:06:01,740 --> 00:06:04,710
every single target with clang you don't

00:06:03,240 --> 00:06:06,659
have to do that so I pretty much just

00:06:04,710 --> 00:06:09,479
music playing at this point for that

00:06:06,659 --> 00:06:10,770
sole reason you're gonna need to find us

00:06:09,479 --> 00:06:12,120
this route so you'll have to have some

00:06:10,770 --> 00:06:15,260
sort of folder somewhere that says this

00:06:12,120 --> 00:06:17,909
is where all of my stuff is gonna go and

00:06:15,260 --> 00:06:19,830
there are a couple quirks with this when

00:06:17,909 --> 00:06:21,330
you want to try and compile LLVM and you

00:06:19,830 --> 00:06:23,419
live together so we can then run those

00:06:21,330 --> 00:06:26,820
in your sort of isolated environment

00:06:23,419 --> 00:06:27,960
whatever reason elf is needed we're

00:06:26,820 --> 00:06:31,020
gonna compile everything today all

00:06:27,960 --> 00:06:34,260
standard and if the target is you know

00:06:31,020 --> 00:06:35,780
say for example x86 64 - health whatever

00:06:34,260 --> 00:06:37,740
reason clang doesn't include the health

00:06:35,780 --> 00:06:39,960
definition I have no idea why I'm just

00:06:37,740 --> 00:06:43,110
sure at the bug so you'll need to add

00:06:39,960 --> 00:06:46,860
that new Lib doesn't provide long double

00:06:43,110 --> 00:06:48,540
support and so we we kind of toss in a

00:06:46,860 --> 00:06:50,220
flag in there to kind of fool

00:06:48,540 --> 00:06:51,540
new live into thinking that the long

00:06:50,220 --> 00:06:53,220
double is the same thing as a double

00:06:51,540 --> 00:06:54,510
that needs to be addressed and I'll

00:06:53,220 --> 00:06:56,700
explain that and limitations of this

00:06:54,510 --> 00:07:00,000
thing later on so that's a hack and it

00:06:56,700 --> 00:07:02,010
needs to be removed at some point we

00:07:00,000 --> 00:07:03,180
there's there's also really know when

00:07:02,010 --> 00:07:05,520
when I've been able to tell there's no

00:07:03,180 --> 00:07:07,650
easy way to do this since with standard

00:07:05,520 --> 00:07:10,260
ansi flag enabled so you're going to

00:07:07,650 --> 00:07:12,120
need to want an enable good news source

00:07:10,260 --> 00:07:14,430
but you're also going to have to use the

00:07:12,120 --> 00:07:16,560
canoe eleven canoe seventeen flags

00:07:14,430 --> 00:07:20,310
instead of the standard 11 standard

00:07:16,560 --> 00:07:22,800
seventeen flags and then lib c++ does

00:07:20,310 --> 00:07:26,520
expect certain operating system support

00:07:22,800 --> 00:07:28,440
for things like POSIX timers threads and

00:07:26,520 --> 00:07:29,970
even the on the clock and I'll explain

00:07:28,440 --> 00:07:31,050
how that's all handled at the end

00:07:29,970 --> 00:07:32,580
because that's gotta be the first

00:07:31,050 --> 00:07:34,650
question was asking right I'm in a

00:07:32,580 --> 00:07:36,840
free-standing environment for a reason I

00:07:34,650 --> 00:07:38,430
don't have access to thread support I

00:07:36,840 --> 00:07:39,690
don't have access to timers how do I

00:07:38,430 --> 00:07:43,200
make that work in this type of

00:07:39,690 --> 00:07:44,940
environment I'll explain that you're

00:07:43,200 --> 00:07:48,090
likely gonna need F pick if you're on

00:07:44,940 --> 00:07:50,430
64-bit nowadays that there are a couple

00:07:48,090 --> 00:07:52,920
additional ones that are useful so for

00:07:50,430 --> 00:07:54,510
example no red zone in my previous talk

00:07:52,920 --> 00:07:57,000
I talked about the headaches associated

00:07:54,510 --> 00:07:59,760
with this flag but if you're doing

00:07:57,000 --> 00:08:02,100
anything that's in the kernel level like

00:07:59,760 --> 00:08:03,900
ring zero below and until or AMD you're

00:08:02,100 --> 00:08:05,400
gonna need that flag because otherwise

00:08:03,900 --> 00:08:08,240
you're gonna end up generating code

00:08:05,400 --> 00:08:10,920
that's gonna crash very quickly on you

00:08:08,240 --> 00:08:12,210
and things like data structures and

00:08:10,920 --> 00:08:14,070
functions sections are really helpful

00:08:12,210 --> 00:08:17,670
because they help reduce the size of C++

00:08:14,070 --> 00:08:19,560
there's still some issues there now

00:08:17,670 --> 00:08:21,570
granted when I did some comparisons

00:08:19,560 --> 00:08:25,580
against C that C today isn't much better

00:08:21,570 --> 00:08:28,320
but for some odd reason a simple main

00:08:25,580 --> 00:08:30,150
function with nothing in it nothing at

00:08:28,320 --> 00:08:31,980
all just a return zero still ends up

00:08:30,150 --> 00:08:33,360
being about 300k and I have no idea why

00:08:31,980 --> 00:08:35,729
that doesn't make much sense so that's

00:08:33,360 --> 00:08:37,740
even on like Ubuntu standard regular

00:08:35,729 --> 00:08:39,720
hosted environments but it's also true

00:08:37,740 --> 00:08:40,800
in these free spinning environments my

00:08:39,720 --> 00:08:42,960
guess is there's some sort of

00:08:40,800 --> 00:08:47,820
initialization logic at least Lib C++

00:08:42,960 --> 00:08:50,250
it's not being removed properly there's

00:08:47,820 --> 00:08:53,760
also some linker flags enter needed to

00:08:50,250 --> 00:08:55,950
get this to work so why static pi is

00:08:53,760 --> 00:08:58,770
needed I'll get into near the end of

00:08:55,950 --> 00:09:01,050
this but we're going in this particular

00:08:58,770 --> 00:09:02,010
environment we're gonna try to leverage

00:09:01,050 --> 00:09:02,400
just static

00:09:02,010 --> 00:09:06,780
C

00:09:02,400 --> 00:09:08,640
plus plus executables and pi is is

00:09:06,780 --> 00:09:10,740
actually helpful it's not a requirement

00:09:08,640 --> 00:09:14,190
you can do this without without the need

00:09:10,740 --> 00:09:15,840
for pi but it can be really helpful and

00:09:14,190 --> 00:09:17,640
of course if you're gonna be building a

00:09:15,840 --> 00:09:19,350
static PI you want to add the no dynamic

00:09:17,640 --> 00:09:22,500
linker because there's no dynamic linker

00:09:19,350 --> 00:09:25,020
in it necessary no standard lip is

00:09:22,500 --> 00:09:26,850
usually required but also some helpful

00:09:25,020 --> 00:09:28,080
ones would include the last couple I'm

00:09:26,850 --> 00:09:29,190
not going to get into what those do

00:09:28,080 --> 00:09:33,560
other than they just make everything

00:09:29,190 --> 00:09:36,540
smaller and a little bit more secure

00:09:33,560 --> 00:09:38,820
alright so on to the C make flags

00:09:36,540 --> 00:09:41,130
there's I documented this so that in

00:09:38,820 --> 00:09:44,010
case you guys cared so take pictures you

00:09:41,130 --> 00:09:45,840
can you know can see all this stuff it's

00:09:44,010 --> 00:09:46,830
all on our github page so you can go and

00:09:45,840 --> 00:09:48,000
look at the source code and copy

00:09:46,830 --> 00:09:51,000
yourself if you ever wanna do this

00:09:48,000 --> 00:09:53,010
yourself in the end the only thing that

00:09:51,000 --> 00:09:54,900
we really care about here is telling Lib

00:09:53,010 --> 00:09:58,560
C++ that we're only building static

00:09:54,900 --> 00:10:00,420
libraries and what type of threading API

00:09:58,560 --> 00:10:01,830
is we want to leverage we're also gonna

00:10:00,420 --> 00:10:04,350
turn off a lot of the newer features

00:10:01,830 --> 00:10:06,360
that make absolutely no sense in

00:10:04,350 --> 00:10:07,710
freestanding environments like the file

00:10:06,360 --> 00:10:09,660
system and some of the experimental

00:10:07,710 --> 00:10:11,970
stuff which includes like networking it

00:10:09,660 --> 00:10:13,800
just makes no sense at all even with

00:10:11,970 --> 00:10:16,680
some of the stuff we're able do to get

00:10:13,800 --> 00:10:18,780
around the platform problems you you

00:10:16,680 --> 00:10:20,310
know if you have access to an actual

00:10:18,780 --> 00:10:22,320
file system stuff you're likely running

00:10:20,310 --> 00:10:26,430
on an operating system in which case you

00:10:22,320 --> 00:10:29,220
shouldn't need this alright so what

00:10:26,430 --> 00:10:33,300
about new lid new Lib itself isn't a big

00:10:29,220 --> 00:10:34,920
deal to compile anymore you will want to

00:10:33,300 --> 00:10:37,110
turn off lip gloss lip gloss with a new

00:10:34,920 --> 00:10:39,000
Lib is the library that adds hosted

00:10:37,110 --> 00:10:40,410
support and since we're in a

00:10:39,000 --> 00:10:40,740
free-standing environment you don't need

00:10:40,410 --> 00:10:43,170
it

00:10:40,740 --> 00:10:44,640
same with multi Lib that just prevents

00:10:43,170 --> 00:10:47,190
new lip from compiling a bunch of stuff

00:10:44,640 --> 00:10:50,010
you're not going to use and we're gonna

00:10:47,190 --> 00:10:51,900
obviously tell it clang all the flags

00:10:50,010 --> 00:10:55,260
that we provided before go to new it as

00:10:51,900 --> 00:11:01,560
well alright and then there are some

00:10:55,260 --> 00:11:03,720
basic notes for all this so when you're

00:11:01,560 --> 00:11:05,880
compiling all this software you're gonna

00:11:03,720 --> 00:11:07,550
be tempted to take the prefix include

00:11:05,880 --> 00:11:09,600
folders and add them into your

00:11:07,550 --> 00:11:12,210
compilation instructions and if you do

00:11:09,600 --> 00:11:14,760
that and you try to compile lip C++ more

00:11:12,210 --> 00:11:15,660
than once it'll puke on you so don't do

00:11:14,760 --> 00:11:17,220
it

00:11:15,660 --> 00:11:20,220
that's the first one and then once again

00:11:17,220 --> 00:11:21,960
the no red zone basically what happens

00:11:20,220 --> 00:11:23,640
is with the red zone is the very end of

00:11:21,960 --> 00:11:26,820
a leaf function its stack can be

00:11:23,640 --> 00:11:28,980
corrupted purposely but in the event

00:11:26,820 --> 00:11:31,170
that an interrupt fires you'll end up

00:11:28,980 --> 00:11:32,490
with actual real corruption so you need

00:11:31,170 --> 00:11:44,550
this if you're running in something with

00:11:32,490 --> 00:11:45,810
interrupts question can you say that

00:11:44,550 --> 00:11:51,900
through the microphone I'd repeat it but

00:11:45,810 --> 00:11:54,570
I think I missed a part so on x86 64

00:11:51,900 --> 00:11:56,250
there is a construct called an ISDN

00:11:54,570 --> 00:11:58,050
which is specifically made so that any

00:11:56,250 --> 00:11:59,970
instructor any interrupts happen in

00:11:58,050 --> 00:12:02,190
kernel space will be triggered to move

00:11:59,970 --> 00:12:03,690
to his own stack space yes we make that

00:12:02,190 --> 00:12:06,000
case it will not corrupt your stack even

00:12:03,690 --> 00:12:09,270
with the red zone yep that is true

00:12:06,000 --> 00:12:10,400
yeah actually use that in bear fling so

00:12:09,270 --> 00:12:15,770
yes the iced tea

00:12:10,400 --> 00:12:19,320
yes that's helpful doesn't help in some

00:12:15,770 --> 00:12:21,240
instances in particular for when we were

00:12:19,320 --> 00:12:22,770
trying to get C++ running inside the

00:12:21,240 --> 00:12:24,420
kernel that wasn't helpful because we

00:12:22,770 --> 00:12:26,640
weren't controlling our own stat or on

00:12:24,420 --> 00:12:29,190
interrupts so we couldn't you couldn't

00:12:26,640 --> 00:12:35,190
use that feature but yes if you have

00:12:29,190 --> 00:12:39,600
that much control you can do that okay

00:12:35,190 --> 00:12:41,750
so what's missing all the obvious if I

00:12:39,600 --> 00:12:45,780
want an exception support and unwinder

00:12:41,750 --> 00:12:46,680
that's a big problem for seeing runtime

00:12:45,780 --> 00:12:48,630
support a lot of people don't actually

00:12:46,680 --> 00:12:50,940
understand what that is so let me fin

00:12:48,630 --> 00:12:52,530
does a quick second on it if you compile

00:12:50,940 --> 00:12:54,780
with freestanding you don't get a main

00:12:52,530 --> 00:12:56,760
function usually you get an underscore

00:12:54,780 --> 00:12:58,920
start function that's it's good luck at

00:12:56,760 --> 00:13:01,080
your entry point all right so how do you

00:12:58,920 --> 00:13:04,620
how do you initialize global

00:13:01,080 --> 00:13:06,060
constructors and destructors in C++ well

00:13:04,620 --> 00:13:08,010
that's all done for you by the seat

00:13:06,060 --> 00:13:11,940
runtime and then none other that's there

00:13:08,010 --> 00:13:14,070
and oddly enough inside some of those

00:13:11,940 --> 00:13:16,760
functions are things that actually do

00:13:14,070 --> 00:13:19,050
relocations for you during runtime which

00:13:16,760 --> 00:13:20,700
is not documented anywhere I could find

00:13:19,050 --> 00:13:22,170
but I certainly figured out when I

00:13:20,700 --> 00:13:25,140
wasn't doing constructors and things

00:13:22,170 --> 00:13:26,520
weren't working right it's where your

00:13:25,140 --> 00:13:29,279
exceptions stuff is actually registered

00:13:26,520 --> 00:13:30,449
so you got to do that too and

00:13:29,279 --> 00:13:31,709
once again you want an actual main

00:13:30,449 --> 00:13:34,079
function you're gonna need to emulate

00:13:31,709 --> 00:13:36,660
that in some way there's no plastic

00:13:34,079 --> 00:13:38,610
thread support in this right lip c++

00:13:36,660 --> 00:13:41,370
doesn't magically provide pthread

00:13:38,610 --> 00:13:43,709
support and what about system calls like

00:13:41,370 --> 00:13:45,749
whoopsie bus boston new lip have no idea

00:13:43,709 --> 00:13:47,670
how to write to a file they don't know

00:13:45,749 --> 00:13:49,829
how to write to a console something as

00:13:47,670 --> 00:13:51,930
simple as hello world is extremely

00:13:49,829 --> 00:13:53,670
difficult in a free-standing environment

00:13:51,930 --> 00:13:55,740
you have to do it all yourself

00:13:53,670 --> 00:14:01,319
alright so how do we get around some of

00:13:55,740 --> 00:14:04,079
that stuff and so and so yeah so I mean

00:14:01,319 --> 00:14:05,509
essentially you don't execute C++

00:14:04,079 --> 00:14:08,100
without additional section information

00:14:05,509 --> 00:14:09,660
to do all this stuff I just described

00:14:08,100 --> 00:14:12,300
you need additional sections that are

00:14:09,660 --> 00:14:14,939
compiled as part of the executable that

00:14:12,300 --> 00:14:19,110
you need to provide your C code with

00:14:14,939 --> 00:14:20,970
access to so things like damnit Feeny eh

00:14:19,110 --> 00:14:23,129
frame those are all sections that the

00:14:20,970 --> 00:14:25,259
compiler generates that your c++ is

00:14:23,129 --> 00:14:28,499
going to need and in free-spending

00:14:25,259 --> 00:14:29,970
environments you know you could spend

00:14:28,499 --> 00:14:31,350
the time you write a linker script and

00:14:29,970 --> 00:14:33,449
put a lit all together and do all the

00:14:31,350 --> 00:14:34,529
work it's a real total nightmare and the

00:14:33,449 --> 00:14:37,680
chances you're getting it right are

00:14:34,529 --> 00:14:39,180
really small this is what makes this so

00:14:37,680 --> 00:14:41,220
complicated and why free staying

00:14:39,180 --> 00:14:43,589
environments usually prohibit the use of

00:14:41,220 --> 00:14:44,819
all of this stuff because as soon as you

00:14:43,589 --> 00:14:46,500
attempt to try and turn any of this

00:14:44,819 --> 00:14:49,500
stuff on it becomes a real problem so

00:14:46,500 --> 00:14:52,470
the question is is if I want to run C++

00:14:49,500 --> 00:14:55,709
with everything right how do I get

00:14:52,470 --> 00:14:58,259
around this particular problem and be

00:14:55,709 --> 00:14:59,490
able to still work in a free staying

00:14:58,259 --> 00:15:04,860
environment where I have access to

00:14:59,490 --> 00:15:07,019
nothing and do all 20 an elf loader the

00:15:04,860 --> 00:15:10,889
answer is no once again you can do all

00:15:07,019 --> 00:15:12,240
of this yourself I've done it when

00:15:10,889 --> 00:15:14,910
you're done you're gonna realize you

00:15:12,240 --> 00:15:18,839
basically just implemented the elf spec

00:15:14,910 --> 00:15:21,360
grain so what why do it I got you know

00:15:18,839 --> 00:15:23,850
learn from my mistake don't do it right

00:15:21,360 --> 00:15:25,800
just build an elf loader what you'll

00:15:23,850 --> 00:15:29,009
find actually is we already did that for

00:15:25,800 --> 00:15:31,550
you and it's been done by many other

00:15:29,009 --> 00:15:33,749
people too it's all over the place so

00:15:31,550 --> 00:15:35,550
you should just use some sort of

00:15:33,749 --> 00:15:37,649
pre-existing file format you know elf is

00:15:35,550 --> 00:15:39,120
what we use for this most of the people

00:15:37,649 --> 00:15:41,279
working in free staying environments are

00:15:39,120 --> 00:15:43,110
working with UNIX tool systems they're

00:15:41,279 --> 00:15:46,280
not working with you

00:15:43,110 --> 00:15:48,990
but if you need PE you can do that too

00:15:46,280 --> 00:15:50,610
either way there's data there that you

00:15:48,990 --> 00:15:52,260
have to get access to because it's not

00:15:50,610 --> 00:15:56,520
part of the regular executable that

00:15:52,260 --> 00:15:58,200
makes c++ run it unlike C C++ just has

00:15:56,520 --> 00:16:01,650
these extra dependencies that you need

00:15:58,200 --> 00:16:05,910
to include all right so this is our

00:16:01,650 --> 00:16:07,830
approach and so basically we did this

00:16:05,910 --> 00:16:09,120
under the bear flank hypervisor for

00:16:07,830 --> 00:16:10,860
years we wanted to be able to write a

00:16:09,120 --> 00:16:13,050
hypervisor in C++

00:16:10,860 --> 00:16:14,460
that was the goal and well really

00:16:13,050 --> 00:16:16,530
actually the goal is write an hypervisor

00:16:14,460 --> 00:16:19,110
SDK that we could build other

00:16:16,530 --> 00:16:21,180
hypervisors from for research we do lots

00:16:19,110 --> 00:16:22,620
of work with hypervisors and we like

00:16:21,180 --> 00:16:24,360
playing with all the different types of

00:16:22,620 --> 00:16:25,740
things that are in there I personally

00:16:24,360 --> 00:16:28,650
written four of them myself

00:16:25,740 --> 00:16:29,880
one in assembly from scratch and after

00:16:28,650 --> 00:16:32,070
you've done it multiple times as layoffs

00:16:29,880 --> 00:16:33,900
I just want to be able to do this very

00:16:32,070 --> 00:16:36,150
quickly and so the point of this project

00:16:33,900 --> 00:16:37,740
was to do that we also wanted to use it

00:16:36,150 --> 00:16:40,290
in bearing mission-critical type systems

00:16:37,740 --> 00:16:43,470
and C++ was a better option because well

00:16:40,290 --> 00:16:44,370
frankly it's a safer language and so we

00:16:43,470 --> 00:16:46,020
were like all right well this is great

00:16:44,370 --> 00:16:47,580
we want to leverage C++ but how do we

00:16:46,020 --> 00:16:50,370
get access to all these facilities and

00:16:47,580 --> 00:16:51,450
ensure that we're doing things that

00:16:50,370 --> 00:16:54,720
adhere to things like the core

00:16:51,450 --> 00:16:56,910
guidelines but really also allow us to

00:16:54,720 --> 00:16:58,740
leverage the facilities of C++ that go

00:16:56,910 --> 00:17:01,320
above and beyond just a language but

00:16:58,740 --> 00:17:03,900
also the library itself and so we built

00:17:01,320 --> 00:17:06,420
this we been using it for years where

00:17:03,900 --> 00:17:08,880
it's great and we even presented it at

00:17:06,420 --> 00:17:10,980
one point have to represented it we got

00:17:08,880 --> 00:17:13,050
just inundated with requests for how do

00:17:10,980 --> 00:17:14,250
I do this in my own environment right I

00:17:13,050 --> 00:17:15,660
don't care about running stuff on the

00:17:14,250 --> 00:17:17,880
kernel that seems pretty weird on why

00:17:15,660 --> 00:17:19,350
you're doing that but I personally want

00:17:17,880 --> 00:17:22,230
to run it in this environment I want to

00:17:19,350 --> 00:17:24,810
run over here or whatever and so finally

00:17:22,230 --> 00:17:26,640
took the time to take all of that stuff

00:17:24,810 --> 00:17:28,560
out of our project and put it into a

00:17:26,640 --> 00:17:31,970
separate project as you can now leverage

00:17:28,560 --> 00:17:34,680
it's all open source under MIT to

00:17:31,970 --> 00:17:35,930
include C++ in any environment that you

00:17:34,680 --> 00:17:39,600
want very easily

00:17:35,930 --> 00:17:42,600
it supports C++ 17 which is latest and

00:17:39,600 --> 00:17:45,210
greatest LLVM stuff and it's using 9

00:17:42,600 --> 00:17:46,830
right now it has full support for C++

00:17:45,210 --> 00:17:47,940
exceptions actually wrote a custom

00:17:46,830 --> 00:17:49,820
unwinder for it

00:17:47,940 --> 00:17:52,590
eventually we may end up using apples

00:17:49,820 --> 00:17:56,160
instead but for now it does have its own

00:17:52,590 --> 00:17:56,880
unwinder and the actual ability to load

00:17:56,160 --> 00:17:58,770
this applique

00:17:56,880 --> 00:18:01,080
in the freestanding environment is done

00:17:58,770 --> 00:18:03,330
with a custom elf loader very simple its

00:18:01,080 --> 00:18:05,070
header only the real benefit to ours is

00:18:03,330 --> 00:18:06,630
the fact that its header only and it has

00:18:05,070 --> 00:18:07,470
really only the only dependencies are

00:18:06,630 --> 00:18:09,660
things that the freestanding

00:18:07,470 --> 00:18:13,290
environments guaranteed to have and so

00:18:09,660 --> 00:18:14,970
you can essentially run this this hell

00:18:13,290 --> 00:18:18,600
floater from any environment which will

00:18:14,970 --> 00:18:21,870
show here in a little bit alright so how

00:18:18,600 --> 00:18:25,050
does it work well there's no easy

00:18:21,870 --> 00:18:27,330
solution to being able to take a

00:18:25,050 --> 00:18:28,470
free-standing piece of code and add all

00:18:27,330 --> 00:18:32,250
this other stuff that's not supposed to

00:18:28,470 --> 00:18:35,010
be there what we found is that works

00:18:32,250 --> 00:18:36,360
really really well is that you have this

00:18:35,010 --> 00:18:38,190
thing what we're calling which I in this

00:18:36,360 --> 00:18:39,360
in the slides I call the C loader but

00:18:38,190 --> 00:18:40,920
the C loaders really you're a

00:18:39,360 --> 00:18:43,440
free-standing piece of code it can be

00:18:40,920 --> 00:18:45,720
freestanding C++ freestanding C don't

00:18:43,440 --> 00:18:48,080
matter what it is but it's this

00:18:45,720 --> 00:18:51,600
application that yet you have to run

00:18:48,080 --> 00:18:53,580
somewhere in the case of the two demos

00:18:51,600 --> 00:18:55,230
which so today could be a UEFI

00:18:53,580 --> 00:18:57,690
application or it could be shell code

00:18:55,230 --> 00:19:00,870
for buffer overflow attack whatever you

00:18:57,690 --> 00:19:04,290
prefer you can do it's the thing that's

00:19:00,870 --> 00:19:05,940
freestanding then from there kit then

00:19:04,290 --> 00:19:08,280
turns around and loads the C++

00:19:05,940 --> 00:19:11,070
application into itself and that C++

00:19:08,280 --> 00:19:13,710
application has all of the things that

00:19:11,070 --> 00:19:17,310
it needs to operate properly it has its

00:19:13,710 --> 00:19:20,940
unwinder it has the C runtime logic it

00:19:17,310 --> 00:19:23,910
has Lib C it has a method for doing

00:19:20,940 --> 00:19:25,950
system calls to handle the Weisse type

00:19:23,910 --> 00:19:30,750
stuff it's all there and a nice easy to

00:19:25,950 --> 00:19:32,400
use environment and so and and both are

00:19:30,750 --> 00:19:34,200
actually compiled with freestanding now

00:19:32,400 --> 00:19:36,360
the reality is is that the C loader can

00:19:34,200 --> 00:19:39,510
be compiled any way you want and for a

00:19:36,360 --> 00:19:41,670
quick like test it's just a C

00:19:39,510 --> 00:19:44,970
application that's hosted that we just

00:19:41,670 --> 00:19:46,800
then run C++ in and then use once again

00:19:44,970 --> 00:19:48,510
if you can get it working in a really

00:19:46,800 --> 00:19:53,130
limited freestanding environment you can

00:19:48,510 --> 00:19:54,780
pretty much make it work anywhere so

00:19:53,130 --> 00:19:57,390
let's talk about the C++ application

00:19:54,780 --> 00:19:59,580
when you're using this this approach

00:19:57,390 --> 00:20:02,240
that we have here so I'm gonna start

00:19:59,580 --> 00:20:04,770
somewhere so let start with hello world

00:20:02,240 --> 00:20:06,270
oddly enough behind the scenes and

00:20:04,770 --> 00:20:07,740
there's actually another talk that about

00:20:06,270 --> 00:20:09,600
back to the basics that talks about what

00:20:07,740 --> 00:20:10,860
it takes to make this work and so I

00:20:09,600 --> 00:20:14,070
highly advise watching that

00:20:10,860 --> 00:20:15,570
because this is really complicated right

00:20:14,070 --> 00:20:17,340
it's like the example we can teach

00:20:15,570 --> 00:20:19,669
everybody but they have no idea how much

00:20:17,340 --> 00:20:24,360
work been behind to make that work

00:20:19,669 --> 00:20:25,559
and so we're gonna start with this and

00:20:24,360 --> 00:20:28,620
we have to have some way to compile it

00:20:25,559 --> 00:20:30,870
so if this projects to be of any use to

00:20:28,620 --> 00:20:33,120
anybody it's gonna have to be simple to

00:20:30,870 --> 00:20:35,580
compile against and so we make heavy use

00:20:33,120 --> 00:20:38,010
of see make when I present it back in

00:20:35,580 --> 00:20:39,539
2016 there was all custom-make files so

00:20:38,010 --> 00:20:44,730
we graduated and now everything's all

00:20:39,539 --> 00:20:46,320
see make and uh I don't know how

00:20:44,730 --> 00:20:48,000
familiar everybody is with C make but

00:20:46,320 --> 00:20:50,549
this is pretty much your typical C make

00:20:48,000 --> 00:20:52,799
type you know build scripts the only

00:20:50,549 --> 00:20:54,779
addition to the build script that you

00:20:52,799 --> 00:20:57,809
might not recognize is the find package

00:20:54,779 --> 00:20:59,639
function and the you know target link

00:20:57,809 --> 00:21:01,769
libraries function so the fine package

00:20:59,639 --> 00:21:05,309
says please go find me this thing called

00:21:01,769 --> 00:21:06,960
standalone C++ and the link library says

00:21:05,309 --> 00:21:09,210
okay once you find the package please

00:21:06,960 --> 00:21:10,620
link against it and that's it all the

00:21:09,210 --> 00:21:12,419
work is done for you behind the scenes

00:21:10,620 --> 00:21:14,220
it figures out what libraries need to be

00:21:12,419 --> 00:21:16,590
linked to your application it ensures

00:21:14,220 --> 00:21:18,149
all the right Pilar flags are there it

00:21:16,590 --> 00:21:22,049
ensures all the linker flags are there

00:21:18,149 --> 00:21:23,760
everything is there the only strange

00:21:22,049 --> 00:21:25,019
thing that we still have to do because I

00:21:23,760 --> 00:21:27,510
don't have an easy way of doing this

00:21:25,019 --> 00:21:29,399
today with packages is you'll still have

00:21:27,510 --> 00:21:33,179
to define your tool chain and your

00:21:29,399 --> 00:21:37,320
prefix so when you compile the standards

00:21:33,179 --> 00:21:39,269
or the standalone C++ project it will

00:21:37,320 --> 00:21:41,039
you know ask you to put it somewhere

00:21:39,269 --> 00:21:42,510
it'll create a prefix which is once

00:21:41,039 --> 00:21:44,159
again that place you put all the stuff

00:21:42,510 --> 00:21:46,620
all the libraries include files

00:21:44,159 --> 00:21:47,669
everything you're going to use and so

00:21:46,620 --> 00:21:49,380
you have to point it to that because

00:21:47,669 --> 00:21:51,210
it's unfortunately a lot with a great

00:21:49,380 --> 00:21:53,880
way of automating that and then the tool

00:21:51,210 --> 00:21:55,110
chain that's still required I'd like to

00:21:53,880 --> 00:21:57,059
get away from that at some point I think

00:21:55,110 --> 00:22:02,220
it's possible but I haven't figured it

00:21:57,059 --> 00:22:05,760
quite out yet so once you do that you

00:22:02,220 --> 00:22:08,100
can build against your your little

00:22:05,760 --> 00:22:08,789
script there and run make and you'll get

00:22:08,100 --> 00:22:10,830
a hello world

00:22:08,789 --> 00:22:13,529
it'll spit out that's that's all you

00:22:10,830 --> 00:22:16,289
have to do to create a C++ application

00:22:13,529 --> 00:22:18,230
in this environment okay but there's

00:22:16,289 --> 00:22:21,450
still a loader part further question

00:22:18,230 --> 00:22:22,440
question okay so there's still the

00:22:21,450 --> 00:22:24,750
loader part that we got to worry about

00:22:22,440 --> 00:22:26,730
all right so I got the C++ application

00:22:24,750 --> 00:22:30,240
I'll run it in my free standing

00:22:26,730 --> 00:22:31,950
environment how do I do that and so once

00:22:30,240 --> 00:22:34,050
again like I said the loader itself is

00:22:31,950 --> 00:22:35,160
pretty much anything that you could

00:22:34,050 --> 00:22:37,140
think of

00:22:35,160 --> 00:22:40,200
I say freestanding because that's

00:22:37,140 --> 00:22:42,240
usually the environment has nothing but

00:22:40,200 --> 00:22:43,200
frankly it could be anything so UEFI for

00:22:42,240 --> 00:22:46,590
example it's not technically

00:22:43,200 --> 00:22:47,550
freestanding I mean it is but it's you

00:22:46,590 --> 00:22:50,220
know it's got a lot of stuff that it

00:22:47,550 --> 00:22:52,110
provides it so problem tons of purpose

00:22:50,220 --> 00:22:53,940
you can do a lot of things in UEFI that

00:22:52,110 --> 00:22:57,330
you wouldn't normally be used to in a in

00:22:53,940 --> 00:22:58,950
a free thing environment versus like for

00:22:57,330 --> 00:23:02,220
example shellcode where we have nothing

00:22:58,950 --> 00:23:04,560
literally nothing but you might want to

00:23:02,220 --> 00:23:06,000
create like a legacy BIOS boot loader so

00:23:04,560 --> 00:23:07,350
if you're building a unit kernel and you

00:23:06,000 --> 00:23:09,570
want to run a real Hardware where you're

00:23:07,350 --> 00:23:13,110
running a unit kernel on a hypervisor

00:23:09,570 --> 00:23:16,110
that still emulates BIOS then you might

00:23:13,110 --> 00:23:17,430
want that if you're building a c++ at

00:23:16,110 --> 00:23:19,380
the kernel module like we like to do

00:23:17,430 --> 00:23:20,970
then you might need that there's a bunch

00:23:19,380 --> 00:23:23,460
of reasons whatever it is the loader is

00:23:20,970 --> 00:23:28,620
the thing that's gonna it's kind of like

00:23:23,460 --> 00:23:30,000
your entry point in our environment now

00:23:28,620 --> 00:23:32,040
though way of looking at it is the

00:23:30,000 --> 00:23:35,880
loader is the thing that runs BF exec

00:23:32,040 --> 00:23:38,070
and so it the F exec is like exec V it's

00:23:35,880 --> 00:23:39,240
just our version of it that parameters

00:23:38,070 --> 00:23:40,950
are slightly different which I'll

00:23:39,240 --> 00:23:41,370
explain but it's basically the same

00:23:40,950 --> 00:23:45,180
thing

00:23:41,370 --> 00:23:48,300
it runs some sort of application so

00:23:45,180 --> 00:23:49,920
let's look at the UEFI example so I'm

00:23:48,300 --> 00:23:51,840
just going to assume that nobody knows

00:23:49,920 --> 00:23:54,420
anything about you AFI so I'll step you

00:23:51,840 --> 00:23:56,370
through a little bit of the details this

00:23:54,420 --> 00:23:59,420
is what a UEFI entry point looks like so

00:23:56,370 --> 00:24:01,350
instead of the main art v or arc c rd

00:23:59,420 --> 00:24:03,180
signature that everyone's used to and

00:24:01,350 --> 00:24:05,490
UEFI that's what it looks like instead

00:24:03,180 --> 00:24:06,990
but it's the same thing and the

00:24:05,490 --> 00:24:10,320
initialize lip thing you can ignore

00:24:06,990 --> 00:24:12,480
that's UEFI ism the only thing we care

00:24:10,320 --> 00:24:14,160
about is bf exec if exactly is the thing

00:24:12,480 --> 00:24:18,780
that's going to run our sequel C++

00:24:14,160 --> 00:24:20,190
application this cxx UEFI and cxx you if

00:24:18,780 --> 00:24:20,430
i underscore length i'll explain in a

00:24:20,190 --> 00:24:23,040
minute

00:24:20,430 --> 00:24:24,660
and then there's this sort of pointer to

00:24:23,040 --> 00:24:27,420
a functions thing which I'll explain

00:24:24,660 --> 00:24:30,780
that's it so you have bf exec you have

00:24:27,420 --> 00:24:34,650
these three sort of oddball things that

00:24:30,780 --> 00:24:38,010
you provide it that's all as needed okay

00:24:34,650 --> 00:24:38,759
so let's start the headers you have your

00:24:38,010 --> 00:24:41,940
UEFI and

00:24:38,759 --> 00:24:44,070
stuff you could ignore that safely and

00:24:41,940 --> 00:24:45,959
then there's bf alert so RBF exact

00:24:44,070 --> 00:24:48,419
sometimes needs to the output errors

00:24:45,959 --> 00:24:50,579
when bad things happen and so bf alert

00:24:48,419 --> 00:24:52,529
is what's used to do that once again

00:24:50,579 --> 00:24:55,079
this is free standing so like I said

00:24:52,529 --> 00:24:57,299
before printf and see how don't exist

00:24:55,079 --> 00:24:59,639
and so whatever environment you're in

00:24:57,299 --> 00:25:01,289
you've got to provide that and so in

00:24:59,639 --> 00:25:03,479
this particular case that's what printf

00:25:01,289 --> 00:25:06,149
looks like in UEFI it just print and

00:25:03,479 --> 00:25:08,459
everything's 16-bit wide characters but

00:25:06,149 --> 00:25:11,129
it's totally possible that you may not

00:25:08,459 --> 00:25:12,749
have a print function in which case you

00:25:11,129 --> 00:25:15,809
can just leave that macro blank and

00:25:12,749 --> 00:25:19,229
it'll just blank out all the printf

00:25:15,809 --> 00:25:20,909
statements inside the VF exact so you

00:25:19,229 --> 00:25:24,959
know debugging is gonna be a total pain

00:25:20,909 --> 00:25:26,339
but it'll work you can also use that in

00:25:24,959 --> 00:25:28,559
release mode to get rid of all the extra

00:25:26,339 --> 00:25:29,789
stuff so that you don't have it there to

00:25:28,559 --> 00:25:32,519
reduce the size of whatever it is you're

00:25:29,789 --> 00:25:36,799
doing the if exec is the header only

00:25:32,519 --> 00:25:40,559
include that you need question and then

00:25:36,799 --> 00:25:42,389
cxx ufi is this magical little header so

00:25:40,559 --> 00:25:44,129
there are many different ways to get

00:25:42,389 --> 00:25:46,829
your a C++ application into your

00:25:44,129 --> 00:25:48,509
freestanding environment alright so in

00:25:46,829 --> 00:25:50,489
this particular example I'll show one

00:25:48,509 --> 00:25:53,129
way in the show code example I'll show

00:25:50,489 --> 00:25:55,259
you another way here what we did is we

00:25:53,129 --> 00:25:57,239
took the C++ application which we just

00:25:55,259 --> 00:26:00,569
compiled it generates an elf file and we

00:25:57,239 --> 00:26:02,699
use xxd to convert it into a header file

00:26:00,569 --> 00:26:05,969
and it literally creates one giant

00:26:02,699 --> 00:26:08,579
header file with all the bytes for that

00:26:05,969 --> 00:26:10,529
AFI filled into an array and it gives

00:26:08,579 --> 00:26:12,119
you the pointer to the array and its

00:26:10,529 --> 00:26:14,609
size you can pile our then takes all

00:26:12,119 --> 00:26:17,190
that crap and puts it into the data

00:26:14,609 --> 00:26:19,529
section of your executable usually and

00:26:17,190 --> 00:26:21,329
so that's one way to do it it's not a

00:26:19,529 --> 00:26:22,859
great way but it works works really well

00:26:21,329 --> 00:26:24,839
surprisingly for most the stuff we care

00:26:22,859 --> 00:26:26,519
about but there are other better ways to

00:26:24,839 --> 00:26:28,109
do this you could for example in your

00:26:26,519 --> 00:26:30,539
free sitting environment use a linker

00:26:28,109 --> 00:26:33,299
script to place the executable somewhere

00:26:30,539 --> 00:26:34,529
in your free-standing code and then you

00:26:33,299 --> 00:26:35,819
know actually use this linker script to

00:26:34,529 --> 00:26:37,139
get access to your pointers and lengths

00:26:35,819 --> 00:26:40,019
and do all the calculations and all the

00:26:37,139 --> 00:26:41,190
fanciness so that would work too there

00:26:40,019 --> 00:26:43,529
are many different ways that you can get

00:26:41,190 --> 00:26:46,019
it in there it's up to you you could

00:26:43,529 --> 00:26:47,909
also just open a file in a like a memory

00:26:46,019 --> 00:26:49,019
buffer and do all that my guess is if

00:26:47,909 --> 00:26:50,069
you have access to all that kind of

00:26:49,019 --> 00:26:52,169
stuff you probably don't need this in

00:26:50,069 --> 00:26:52,710
the first place but you know if it is

00:26:52,169 --> 00:26:57,600
there sure

00:26:52,710 --> 00:26:58,980
you do it so if we go back real quick we

00:26:57,600 --> 00:27:01,649
look at that signature we now understand

00:26:58,980 --> 00:27:03,960
the first two right so x XD produced AC

00:27:01,649 --> 00:27:09,059
style array in a header file that has

00:27:03,960 --> 00:27:10,559
all our C code embedded in it so the

00:27:09,059 --> 00:27:11,820
last part is this function thing so if

00:27:10,559 --> 00:27:13,140
you're linux programmer this will be

00:27:11,820 --> 00:27:14,730
really familiar to you this is

00:27:13,140 --> 00:27:16,200
essentially how the entire Linux kernel

00:27:14,730 --> 00:27:18,480
works you get just all the you know

00:27:16,200 --> 00:27:20,130
callback structures that you fill in so

00:27:18,480 --> 00:27:22,529
this is essentially the same thing there

00:27:20,130 --> 00:27:24,090
are four functions that you can define

00:27:22,529 --> 00:27:27,299
only one of them is required and I'm

00:27:24,090 --> 00:27:28,380
hopefully over the next like year so we

00:27:27,299 --> 00:27:33,779
can remove the requirement for that one

00:27:28,380 --> 00:27:36,360
too and so there's a leak free mark X 10

00:27:33,779 --> 00:27:40,200
system call so let's get in each one of

00:27:36,360 --> 00:27:43,020
these all right so Alec so the right now

00:27:40,200 --> 00:27:45,029
the way it works is the bf exec will go

00:27:43,020 --> 00:27:46,950
and allocate a buffer and input that C++

00:27:45,029 --> 00:27:51,240
application into it using the elf loader

00:27:46,950 --> 00:27:53,669
ok so you you can't just go and execute

00:27:51,240 --> 00:27:55,890
the elf file you actually have to load

00:27:53,669 --> 00:27:58,440
the elf file into some memory and then

00:27:55,890 --> 00:28:00,299
execute that memory if you don't do that

00:27:58,440 --> 00:28:03,299
step then there's a bunch of stuff

00:28:00,299 --> 00:28:05,100
that's missing and more importantly

00:28:03,299 --> 00:28:06,840
likely the layout your memory is not

00:28:05,100 --> 00:28:09,779
proper unless you did some really fancy

00:28:06,840 --> 00:28:11,460
linker script stuff so the elf file

00:28:09,779 --> 00:28:12,750
still tells you how you're supposed to

00:28:11,460 --> 00:28:14,130
put in memory and that's what this step

00:28:12,750 --> 00:28:16,230
is doing now eventually what I want to

00:28:14,130 --> 00:28:17,730
do is get the point where the elf file

00:28:16,230 --> 00:28:19,890
can be used at Kippur the elf loader can

00:28:17,730 --> 00:28:21,210
be used at compile time it produces the

00:28:19,890 --> 00:28:23,460
memory layout and then you can shove

00:28:21,210 --> 00:28:25,260
that into your executable using the

00:28:23,460 --> 00:28:27,480
linker script or the xxd whatever you

00:28:25,260 --> 00:28:30,059
want so that part can be done not at run

00:28:27,480 --> 00:28:34,049
time but at compile time but for now

00:28:30,059 --> 00:28:38,039
this works and keep in mind too that the

00:28:34,049 --> 00:28:39,779
allocation of memory you know there's

00:28:38,039 --> 00:28:41,539
this we're gonna execute from it so

00:28:39,779 --> 00:28:43,830
execute permissions is going to matter

00:28:41,539 --> 00:28:45,419
and so I'll get to that a little bit but

00:28:43,830 --> 00:28:46,860
in most freestanding environments where

00:28:45,419 --> 00:28:48,840
you're working in embedded systems or

00:28:46,860 --> 00:28:50,190
wherever it is you can just allocate

00:28:48,840 --> 00:28:51,330
memory it's always marked read write

00:28:50,190 --> 00:28:53,340
execute and you just do what you got to

00:28:51,330 --> 00:28:57,000
do that does not always that's not

00:28:53,340 --> 00:28:59,700
always the case in UEFI this is

00:28:57,000 --> 00:29:04,590
essentially how you allocate a buffer of

00:28:59,700 --> 00:29:06,070
bytes free is self-explanatory I don't

00:29:04,590 --> 00:29:08,650
think I need to explain that

00:29:06,070 --> 00:29:09,820
it's the reverse italic it's optional

00:29:08,650 --> 00:29:12,160
because you don't have the free memory

00:29:09,820 --> 00:29:17,440
you get slike so if you don't want to

00:29:12,160 --> 00:29:19,720
use it you're your problem same thing so

00:29:17,440 --> 00:29:21,340
you can you can implement this any way

00:29:19,720 --> 00:29:24,340
you want so this is an example of using

00:29:21,340 --> 00:29:27,460
C functions that exists so Alec a loopy

00:29:24,340 --> 00:29:29,170
no wind Alec and and regular free is

00:29:27,460 --> 00:29:30,940
whatever you need to use in your

00:29:29,170 --> 00:29:33,010
environment if you don't have dynamic

00:29:30,940 --> 00:29:35,200
memory allocation then you can just

00:29:33,010 --> 00:29:37,750
allocate one giant buffer and then use

00:29:35,200 --> 00:29:40,870
something like sprk for example that

00:29:37,750 --> 00:29:43,390
type of memory allocation where it's

00:29:40,870 --> 00:29:44,800
just essentially a moving window and you

00:29:43,390 --> 00:29:46,060
can just start blocking out chunks that

00:29:44,800 --> 00:29:47,650
you can give to it it only has to

00:29:46,060 --> 00:29:50,920
allocate three things so you don't need

00:29:47,650 --> 00:29:52,780
a lot from it and so once again be non

00:29:50,920 --> 00:29:54,520
dynamic memory allocation this isn't

00:29:52,780 --> 00:29:55,630
free and melech isn't being used to

00:29:54,520 --> 00:29:56,980
create all these little things all over

00:29:55,630 --> 00:29:59,350
the place it's gonna get lost everywhere

00:29:56,980 --> 00:30:00,910
it's great three buffers that's it and

00:29:59,350 --> 00:30:02,470
like I said at some point we should be

00:30:00,910 --> 00:30:04,210
able to remove the requirement for that

00:30:02,470 --> 00:30:07,000
and do it all compile time since it

00:30:04,210 --> 00:30:09,160
really is that simple the mark rx

00:30:07,000 --> 00:30:11,380
function is needed because once again

00:30:09,160 --> 00:30:13,210
not all systems mark all of executable

00:30:11,380 --> 00:30:15,730
memo all memory that you allocate as

00:30:13,210 --> 00:30:19,090
executable so what's supposed to happen

00:30:15,730 --> 00:30:21,550
is when you malloc memory its marked

00:30:19,090 --> 00:30:23,020
reprice and you have to explicitly mark

00:30:21,550 --> 00:30:24,460
it read execute if you want and it

00:30:23,020 --> 00:30:26,050
should actually never be read write

00:30:24,460 --> 00:30:29,320
execute that's what causes so many

00:30:26,050 --> 00:30:30,190
problems so if you happen to be on one

00:30:29,320 --> 00:30:32,020
of those environments you have to

00:30:30,190 --> 00:30:33,130
implement that in the case of UEFI we

00:30:32,020 --> 00:30:34,990
don't so we just leave it blank

00:30:33,130 --> 00:30:36,370
you could also fill in a null pointer

00:30:34,990 --> 00:30:38,470
for that if you wanted to you know

00:30:36,370 --> 00:30:40,300
within the structure once all the

00:30:38,470 --> 00:30:42,490
options you can do that but once again

00:30:40,300 --> 00:30:43,930
if you're on a system that that does do

00:30:42,490 --> 00:30:45,430
read/write protections properly then you

00:30:43,930 --> 00:30:46,990
could use something like an protect or

00:30:45,430 --> 00:30:49,060
whatever the facilities are in your

00:30:46,990 --> 00:30:50,530
operating system or if you're like me

00:30:49,060 --> 00:30:55,240
you would probably just parse the page

00:30:50,530 --> 00:30:56,740
tables and mark them your stuff last but

00:30:55,240 --> 00:31:01,300
not least is the system call function

00:30:56,740 --> 00:31:02,830
and this is where all the sort of magic

00:31:01,300 --> 00:31:07,750
happens with respect to the device stuff

00:31:02,830 --> 00:31:09,730
so if I do stood see out in C++ where

00:31:07,750 --> 00:31:11,440
does that go well in the end what it

00:31:09,730 --> 00:31:13,570
really does is it makes its way through

00:31:11,440 --> 00:31:15,970
all the C++ code which is surprisingly

00:31:13,570 --> 00:31:18,220
complex once it finally gets passed all

00:31:15,970 --> 00:31:19,880
that it eventually makes it to a Lib C

00:31:18,220 --> 00:31:22,880
call called right

00:31:19,880 --> 00:31:25,070
Alysse on linux and that actually writes

00:31:22,880 --> 00:31:27,890
to a specific file number that's

00:31:25,070 --> 00:31:29,630
dedicated to console held and so in that

00:31:27,890 --> 00:31:32,620
case it's usually one or two depending

00:31:29,630 --> 00:31:36,650
if it's dead out or stood error and so

00:31:32,620 --> 00:31:39,169
when you compile lib c++ with new lid

00:31:36,650 --> 00:31:41,090
and you don't include lipgloss there's a

00:31:39,169 --> 00:31:43,580
series of functions that live or that

00:31:41,090 --> 00:31:45,340
new lib purposely doesn't implement

00:31:43,580 --> 00:31:48,860
because of I don't what to do with those

00:31:45,340 --> 00:31:51,020
you have to provide them and so what we

00:31:48,860 --> 00:31:52,789
did inside of our project is we

00:31:51,020 --> 00:31:55,400
implement all of those functions and all

00:31:52,789 --> 00:31:56,900
they do is they make a call to the

00:31:55,400 --> 00:31:59,720
function that you point to with this

00:31:56,900 --> 00:32:01,940
function pointer so when it when lib c++

00:31:59,720 --> 00:32:03,380
attempts to make a call to write it

00:32:01,940 --> 00:32:04,610
packages all the information up

00:32:03,380 --> 00:32:08,030
associate with that and makes a call to

00:32:04,610 --> 00:32:09,980
this function and says ok the ID is you

00:32:08,030 --> 00:32:11,690
know sis call right and here's all the

00:32:09,980 --> 00:32:15,140
arguments for it you do what you got to

00:32:11,690 --> 00:32:17,720
do with it and so on UEFI for example

00:32:15,140 --> 00:32:19,820
I'm going to print all the bytes out to

00:32:17,720 --> 00:32:21,919
the console using print and I do that

00:32:19,820 --> 00:32:24,559
stupid methods I frankly couldn't figure

00:32:21,919 --> 00:32:27,590
out how to do the conversion of 16-bit

00:32:24,559 --> 00:32:31,970
wide characters to 8-bit ASCII

00:32:27,590 --> 00:32:34,820
characters so that works but at any rate

00:32:31,970 --> 00:32:36,770
all of those types of weird functions

00:32:34,820 --> 00:32:38,690
that are needed you can implement or not

00:32:36,770 --> 00:32:40,789
implement see it's totally up to you it

00:32:38,690 --> 00:32:42,140
depends on the environment if you are in

00:32:40,789 --> 00:32:44,870
an environment where none of this is

00:32:42,140 --> 00:32:46,700
there and you're writing all the device

00:32:44,870 --> 00:32:48,140
stuff yourself or there it you know in

00:32:46,700 --> 00:32:49,490
the case of like a shell code you don't

00:32:48,140 --> 00:32:50,570
really care about the Vice stuff so

00:32:49,490 --> 00:32:52,760
you're just not gonna do it anyway you

00:32:50,570 --> 00:32:54,350
know it's all is entirely up to you you

00:32:52,760 --> 00:32:55,820
can make it as complex as you want you

00:32:54,350 --> 00:32:57,409
can write all the device stuff right in

00:32:55,820 --> 00:33:01,760
C++ and do everything directly from

00:32:57,409 --> 00:33:03,350
there or you can let our code forward it

00:33:01,760 --> 00:33:04,850
on to this part where the loader can do

00:33:03,350 --> 00:33:06,200
it cuz maybe it has an environment that

00:33:04,850 --> 00:33:08,990
does provide some of these facilities

00:33:06,200 --> 00:33:11,059
like for example if I can print to the

00:33:08,990 --> 00:33:12,200
console it can also write to a file it

00:33:11,059 --> 00:33:13,580
can do all sorts of different things so

00:33:12,200 --> 00:33:15,320
I could fill out this function as much

00:33:13,580 --> 00:33:20,510
as I want and get as much functionality

00:33:15,320 --> 00:33:22,789
as I desire but this this provides that

00:33:20,510 --> 00:33:25,460
sort of missing blue above and beyond

00:33:22,789 --> 00:33:26,720
the you know unwinder that we provide in

00:33:25,460 --> 00:33:27,770
the elf loader and all that kind of

00:33:26,720 --> 00:33:30,470
stuff that's needed to make this stuff

00:33:27,770 --> 00:33:32,330
work and the C runtime all that that's

00:33:30,470 --> 00:33:33,560
all done automatically for you this is

00:33:32,330 --> 00:33:35,000
the only part that's not

00:33:33,560 --> 00:33:36,590
we really honestly have no idea what you

00:33:35,000 --> 00:33:41,660
want to do all depends on your

00:33:36,590 --> 00:33:43,610
environment alright let's do a demo you

00:33:41,660 --> 00:33:44,870
if I I have no idea what's going to

00:33:43,610 --> 00:33:49,460
happen because I had to reboot my

00:33:44,870 --> 00:33:51,050
computer to do this so yeah if it

00:33:49,460 --> 00:33:53,240
doesn't work that's what it's supposed

00:33:51,050 --> 00:33:54,920
to look like sort of it actually doesn't

00:33:53,240 --> 00:33:56,990
say that it just says hello world that's

00:33:54,920 --> 00:33:58,190
an old one but this is the demo we're

00:33:56,990 --> 00:33:59,120
gonna show so I'm gonna reboot we're

00:33:58,190 --> 00:34:13,640
gonna see if this works if it doesn't

00:33:59,120 --> 00:34:14,780
we'll move on to the next one but you

00:34:13,640 --> 00:34:17,820
ever seen anybody reboot it come here

00:34:14,780 --> 00:34:20,940
and maneuver middle of our presentation

00:34:17,820 --> 00:34:20,940
[Laughter]

00:34:20,950 --> 00:34:26,270
I'm gonna go back in and we'll just

00:34:23,600 --> 00:34:30,050
continue so if you want to see all this

00:34:26,270 --> 00:34:33,710
yourself that that UEFI example then you

00:34:30,050 --> 00:34:35,470
can go to our open source project and

00:34:33,710 --> 00:34:38,810
download it compile and run it yourself

00:34:35,470 --> 00:34:40,700
but what you would have seen is me just

00:34:38,810 --> 00:34:42,260
run a UEFI application and it would have

00:34:40,700 --> 00:34:44,720
printed hello world and that hello world

00:34:42,260 --> 00:34:46,100
was coming from a C++ application and so

00:34:44,720 --> 00:34:48,650
using all the stuff I just showed you

00:34:46,100 --> 00:34:50,980
right there I was able to compile a C++

00:34:48,650 --> 00:34:54,550
application into my UEFI environment and

00:34:50,980 --> 00:35:01,600
execute that C++ with our problem so

00:34:54,550 --> 00:35:01,600
let's look at our simple test case

00:35:07,090 --> 00:35:16,280
alright so we look at this make quick

00:35:11,620 --> 00:35:18,740
this is the C++ application running from

00:35:16,280 --> 00:35:21,020
a like I said just a regular good

00:35:18,740 --> 00:35:23,360
old-fashioned hosted C you know as a

00:35:21,020 --> 00:35:26,230
test case so they should kind of show

00:35:23,360 --> 00:35:31,510
you what this looks like if we go to

00:35:26,230 --> 00:35:33,890
tests you can see this code here and

00:35:31,510 --> 00:35:36,260
this is actually a relatively complex

00:35:33,890 --> 00:35:39,370
little hello world example

00:35:36,260 --> 00:35:45,200
so to start there's exception logic

00:35:39,370 --> 00:35:47,300
there's a static class instance ok and I

00:35:45,200 --> 00:35:49,460
was talked about briefly in the previous

00:35:47,300 --> 00:35:51,290
presentation but you know if you want to

00:35:49,460 --> 00:35:53,240
be able to do static type stuff

00:35:51,290 --> 00:35:54,740
you're gonna need not just a global

00:35:53,240 --> 00:35:56,750
construction destruction support but

00:35:54,740 --> 00:35:59,000
support for a exit that's where the

00:35:56,750 --> 00:36:01,160
magic occurs whenever you do a static

00:35:59,000 --> 00:36:03,770
definition it registers the definition

00:36:01,160 --> 00:36:05,300
with the exit function and that's where

00:36:03,770 --> 00:36:08,660
the destruction occurs when you call

00:36:05,300 --> 00:36:10,990
exit exit actually goes and runs through

00:36:08,660 --> 00:36:13,040
all the registered statically defined

00:36:10,990 --> 00:36:15,860
objects and goes through and runs their

00:36:13,040 --> 00:36:18,350
destructors and so to prove that all

00:36:15,860 --> 00:36:21,770
that logic is glued properly and working

00:36:18,350 --> 00:36:23,330
we create two different classes one that

00:36:21,770 --> 00:36:24,770
has a constructor and does something and

00:36:23,330 --> 00:36:27,170
one that has a destructor and does

00:36:24,770 --> 00:36:29,120
something and tests that make sure that

00:36:27,170 --> 00:36:31,070
all these work so we also use a state

00:36:29,120 --> 00:36:32,930
array just to show that the standard

00:36:31,070 --> 00:36:35,720
library does what we want it to it all

00:36:32,930 --> 00:36:36,770
just works so had you know the idea was

00:36:35,720 --> 00:36:37,850
to try and create something that was

00:36:36,770 --> 00:36:40,400
more than just a hello world to prove

00:36:37,850 --> 00:36:43,700
that it you know we didn't just make

00:36:40,400 --> 00:36:45,860
printf work it's you know the whole

00:36:43,700 --> 00:36:48,890
facilities to C++ all working in front

00:36:45,860 --> 00:36:53,600
of you and so the loader in this

00:36:48,890 --> 00:36:55,190
particular case is you know you'll see

00:36:53,600 --> 00:36:57,290
that the same Lodge actually have your

00:36:55,190 --> 00:36:59,660
you have your allocation function your

00:36:57,290 --> 00:37:01,700
free function your mark X to mark the

00:36:59,660 --> 00:37:04,040
pages properly in your sis call and this

00:37:01,700 --> 00:37:09,110
is once again just calling right because

00:37:04,040 --> 00:37:10,520
I'm running it on regular C++ and so or

00:37:09,110 --> 00:37:14,570
so I'm running on Linux and so therefore

00:37:10,520 --> 00:37:16,220
I have access to it so that works this

00:37:14,570 --> 00:37:18,680
function here at map file you'll see in

00:37:16,220 --> 00:37:20,540
the next example it actually takes the

00:37:18,680 --> 00:37:22,040
C++ file and maps it into the

00:37:20,540 --> 00:37:24,980
application then I use that so instead

00:37:22,040 --> 00:37:26,720
of using X XD this is how we're doing it

00:37:24,980 --> 00:37:28,580
just like you know keep it simple so

00:37:26,720 --> 00:37:30,890
this is how you map a file and see

00:37:28,580 --> 00:37:32,900
essentially but we did it in C++ and

00:37:30,890 --> 00:37:35,510
then it just runs the bf exec function

00:37:32,900 --> 00:37:37,910
and then cleans up nice and simple

00:37:35,510 --> 00:37:41,780
alright so let's get to the more

00:37:37,910 --> 00:37:46,490
interesting example of running the show

00:37:41,780 --> 00:37:48,940
code stuff if I can get this monitor

00:37:46,490 --> 00:37:48,940
working

00:37:50,500 --> 00:38:03,980
yay we're back okay

00:37:54,550 --> 00:38:06,140
so before I before I do that let me pull

00:38:03,980 --> 00:38:08,650
up the slides is one more diagram on my

00:38:06,140 --> 00:38:11,120
show because I think this will help with

00:38:08,650 --> 00:38:13,250
explaining how this stuff works all

00:38:11,120 --> 00:38:17,350
right so I don't want to turn this

00:38:13,250 --> 00:38:20,120
lecture into how to write you know

00:38:17,350 --> 00:38:21,860
attacks because it frankly you could

00:38:20,120 --> 00:38:25,190
spend multiple presentations on how to

00:38:21,860 --> 00:38:26,390
do this stuff but I will say that the

00:38:25,190 --> 00:38:28,970
demonstrations based off the original

00:38:26,390 --> 00:38:30,740
stack smashing paper there's some

00:38:28,970 --> 00:38:35,720
additional things you have to do because

00:38:30,740 --> 00:38:37,160
times have changed but in general the

00:38:35,720 --> 00:38:39,770
way the stack works on the Intel

00:38:37,160 --> 00:38:43,640
Architecture is the stack actually grows

00:38:39,770 --> 00:38:45,020
up while all your data grows down or

00:38:43,640 --> 00:38:46,220
it's all the way around either way I

00:38:45,020 --> 00:38:47,240
just know they're backwards that's what

00:38:46,220 --> 00:38:49,970
I remember

00:38:47,240 --> 00:38:52,970
and so if you look at this diagram here

00:38:49,970 --> 00:38:55,760
if I've got a buffer okay so it's just

00:38:52,970 --> 00:38:58,070
some character buffer and it has this

00:38:55,760 --> 00:39:00,980
particular size and I define it at the

00:38:58,070 --> 00:39:03,500
beginning of a function and I go and

00:39:00,980 --> 00:39:06,200
then you know read through the buffer if

00:39:03,500 --> 00:39:08,930
I continue to read past the bounds of

00:39:06,200 --> 00:39:11,180
the buffer I start reading my stack and

00:39:08,930 --> 00:39:12,320
so you're gonna run into other variables

00:39:11,180 --> 00:39:14,660
that are defined in that function

00:39:12,320 --> 00:39:17,920
eventually you're gonna run into the

00:39:14,660 --> 00:39:20,360
return address for the function itself

00:39:17,920 --> 00:39:24,140
and so the way a buffer overflow attack

00:39:20,360 --> 00:39:26,810
works is that you load the buffer with a

00:39:24,140 --> 00:39:29,750
bunch of stuff that's your payload it's

00:39:26,810 --> 00:39:32,330
your attack and then you keep loading

00:39:29,750 --> 00:39:34,370
beyond the extent of the buffer until

00:39:32,330 --> 00:39:36,560
you hit the return address and at that

00:39:34,370 --> 00:39:38,450
specific spot and return address you

00:39:36,560 --> 00:39:40,790
populate it with the address of the

00:39:38,450 --> 00:39:42,920
stack itself and so when the function

00:39:40,790 --> 00:39:44,150
attempts to return it goes to that

00:39:42,920 --> 00:39:45,800
return address to get where it's

00:39:44,150 --> 00:39:47,600
supposed to go and instead of it

00:39:45,800 --> 00:39:50,300
returning to wherever it was meant to go

00:39:47,600 --> 00:39:52,100
instead it returns to the top of the

00:39:50,300 --> 00:39:54,110
stack where you put a whole bunch of

00:39:52,100 --> 00:39:55,490
executable code and so then it starts

00:39:54,110 --> 00:39:59,120
running through all your stuff instead

00:39:55,490 --> 00:40:01,100
right so that's how this works that's

00:39:59,120 --> 00:40:02,630
the basics behind it once again if

00:40:01,100 --> 00:40:04,369
you're more interested in the really

00:40:02,630 --> 00:40:06,529
crazy details

00:40:04,369 --> 00:40:08,539
there's a great paper called smashing

00:40:06,529 --> 00:40:12,259
the stack which based off like kind of

00:40:08,539 --> 00:40:19,519
did all this and go read that it's a

00:40:12,259 --> 00:40:23,059
great read alright so let's look at our

00:40:19,519 --> 00:40:24,589
payload so our payload is the thing

00:40:23,059 --> 00:40:28,039
that's freestanding it's the thing that

00:40:24,589 --> 00:40:29,420
has no environment so literally we're

00:40:28,039 --> 00:40:31,309
trying to compile a piece of code that

00:40:29,420 --> 00:40:33,979
we're gonna stick on the stack somewhere

00:40:31,309 --> 00:40:35,719
and we're gonna execute it we don't have

00:40:33,979 --> 00:40:37,819
any operating system to rely on we have

00:40:35,719 --> 00:40:40,819
nothing absolutely nothing it's just an

00:40:37,819 --> 00:40:42,410
executable we say freestanding because

00:40:40,819 --> 00:40:46,069
there just is no facilities there for us

00:40:42,410 --> 00:40:48,319
to run and so we'll start by looking at

00:40:46,069 --> 00:40:50,269
the same same old stuff here the

00:40:48,319 --> 00:40:51,859
allocation function and Mark X you know

00:40:50,269 --> 00:40:53,900
system call there's no free because

00:40:51,859 --> 00:40:55,279
we're attacking and anybody who builds

00:40:53,900 --> 00:40:57,670
an attack and actually frees memory is

00:40:55,279 --> 00:41:01,249
just no fun at all

00:40:57,670 --> 00:41:02,869
so yeah so the first thing you might say

00:41:01,249 --> 00:41:04,670
to yourself is well what you know what

00:41:02,869 --> 00:41:06,469
is this external malloc what is this

00:41:04,670 --> 00:41:08,989
external and protect and so I'll get to

00:41:06,469 --> 00:41:11,269
that in a second but keep in mind that

00:41:08,989 --> 00:41:12,739
there is no in my environment there is

00:41:11,269 --> 00:41:14,239
no actual malloc or free or anything

00:41:12,739 --> 00:41:18,259
like that I have to get it from

00:41:14,239 --> 00:41:19,999
something else and we have our same

00:41:18,259 --> 00:41:21,440
system call so we can go and write to a

00:41:19,999 --> 00:41:23,989
buffer but same thing it says external

00:41:21,440 --> 00:41:26,809
right thing it'll have anything there I

00:41:23,989 --> 00:41:30,739
had my functions and then from here I

00:41:26,809 --> 00:41:33,170
have this little you know block now the

00:41:30,739 --> 00:41:36,109
actual start function is actually here

00:41:33,170 --> 00:41:38,509
and so when you're in a free-standing

00:41:36,109 --> 00:41:40,719
environment that's what start that's

00:41:38,509 --> 00:41:44,900
that's your actual entry point usually

00:41:40,719 --> 00:41:47,299
it's not always but it usually is and so

00:41:44,900 --> 00:41:48,680
in this particular case the I can't just

00:41:47,299 --> 00:41:50,119
go and execute my code because it's

00:41:48,680 --> 00:41:51,529
going to need a stack this is where we

00:41:50,119 --> 00:41:55,190
deviate a bit from smashing the stack

00:41:51,529 --> 00:41:56,989
they go and really kind of hard code all

00:41:55,190 --> 00:41:58,009
the byte logic that goes in there we

00:41:56,989 --> 00:41:59,869
wanted to make this really simple

00:41:58,009 --> 00:42:00,799
because we wanted to be able to run C++

00:41:59,869 --> 00:42:02,690
and do whatever you want in that

00:42:00,799 --> 00:42:05,869
environment so to do that it's gonna

00:42:02,690 --> 00:42:07,809
need to legit stack and so the problem

00:42:05,869 --> 00:42:10,160
is is that the stack pointer is now all

00:42:07,809 --> 00:42:11,809
combated because we're you know messing

00:42:10,160 --> 00:42:14,359
around with it to do the attack itself

00:42:11,809 --> 00:42:16,579
so the first thing we do is we basically

00:42:14,359 --> 00:42:17,090
move the stack pointer way way up so

00:42:16,579 --> 00:42:18,860
that

00:42:17,090 --> 00:42:20,810
we're not colliding with ourselves and

00:42:18,860 --> 00:42:23,360
we've got space above to go and add

00:42:20,810 --> 00:42:24,740
actual stacks up that we're doing so

00:42:23,360 --> 00:42:32,690
that's what that does and then it just

00:42:24,740 --> 00:42:35,000
calls see which like I said so that's

00:42:32,690 --> 00:42:37,160
here and all this does is it opens up

00:42:35,000 --> 00:42:40,970
the C++ file that we want to run inside

00:42:37,160 --> 00:42:43,130
our shell code and it gets its size it

00:42:40,970 --> 00:42:44,930
actually Maps it in and then it runs BF

00:42:43,130 --> 00:42:47,180
exec but same thing there's this

00:42:44,930 --> 00:42:48,830
external open this external file size

00:42:47,180 --> 00:42:51,650
and file map those aren't even standard

00:42:48,830 --> 00:42:53,510
functions and there's this external exit

00:42:51,650 --> 00:43:00,050
thing the only thing that's not marked

00:42:53,510 --> 00:43:02,780
external is BF exact alright so all that

00:43:00,050 --> 00:43:05,870
external stuff is located here these are

00:43:02,780 --> 00:43:08,180
just function pointers essentially

00:43:05,870 --> 00:43:10,070
marked with this you know deadbeat stuff

00:43:08,180 --> 00:43:12,650
and so what I did

00:43:10,070 --> 00:43:15,830
to make all this work is I take the

00:43:12,650 --> 00:43:18,260
executable that I'm going to hack and I

00:43:15,830 --> 00:43:20,660
analyze it to get the actual virtual

00:43:18,260 --> 00:43:23,150
address of every function I need in my

00:43:20,660 --> 00:43:25,700
payload to make this functional and so

00:43:23,150 --> 00:43:27,820
because the application I'm running

00:43:25,700 --> 00:43:30,620
happened to have been compiled

00:43:27,820 --> 00:43:34,430
statically and it also happened to be

00:43:30,620 --> 00:43:37,190
compiled with a sll turned off and

00:43:34,430 --> 00:43:38,870
though or with an executable stack and

00:43:37,190 --> 00:43:40,970
all these lovely you know security

00:43:38,870 --> 00:43:43,160
features that would never be turned off

00:43:40,970 --> 00:43:45,650
nowadays this one just happened to have

00:43:43,160 --> 00:43:47,390
it all turned off I can very easily now

00:43:45,650 --> 00:43:50,000
just go the application and say hey

00:43:47,390 --> 00:43:53,390
where's open located inside your app

00:43:50,000 --> 00:43:55,340
where is Right located and I can get the

00:43:53,390 --> 00:43:57,620
actual virtual address and then in a

00:43:55,340 --> 00:44:00,710
post compilation stage I can take this

00:43:57,620 --> 00:44:03,050
payload and everywhere I see dead beef 0

00:44:00,710 --> 00:44:05,360
1 inside the code I just overwrite it

00:44:03,050 --> 00:44:08,120
with the actual virtual address of open

00:44:05,360 --> 00:44:10,670
and wherever I see the next one I you

00:44:08,120 --> 00:44:12,620
know do exit and malloc and all that and

00:44:10,670 --> 00:44:14,900
so before you're done you have a payload

00:44:12,620 --> 00:44:18,680
that actually has access to some of

00:44:14,900 --> 00:44:20,060
these functions that belong to the

00:44:18,680 --> 00:44:22,130
application you're hacking itself so

00:44:20,060 --> 00:44:24,230
you're gonna use the application to

00:44:22,130 --> 00:44:25,670
perform the hack in addition to what

00:44:24,230 --> 00:44:28,090
you're doing so I'm a neat little

00:44:25,670 --> 00:44:28,090
approach

00:44:28,470 --> 00:44:36,000
and finally the last part of this is we

00:44:34,020 --> 00:44:38,880
define our bf alert just like before

00:44:36,000 --> 00:44:40,740
we're using external F printf because

00:44:38,880 --> 00:44:42,119
it's oddly enough printf wasn't in the

00:44:40,740 --> 00:44:46,829
application so I had to make it work

00:44:42,119 --> 00:44:48,569
with F printf and there's this fancy

00:44:46,829 --> 00:44:50,099
little stack thing so we use a custom

00:44:48,569 --> 00:44:52,050
linker script to compile the whole

00:44:50,099 --> 00:44:54,359
payload and then at the very end of the

00:44:52,050 --> 00:44:56,190
payload so the payload itself is the

00:44:54,359 --> 00:44:59,910
actual size of the buffer we're gonna

00:44:56,190 --> 00:45:01,109
attack and at the end of the payload we

00:44:59,910 --> 00:45:02,550
have some padding because there happens

00:45:01,109 --> 00:45:03,869
to be some additional variables that

00:45:02,550 --> 00:45:06,089
it's doing so we got to get past that

00:45:03,869 --> 00:45:07,680
and then there's actually a push to our

00:45:06,089 --> 00:45:09,599
BP which you should actually see in

00:45:07,680 --> 00:45:11,819
pretty much every function at least in

00:45:09,599 --> 00:45:13,560
every function compiled in debug mode so

00:45:11,819 --> 00:45:15,839
there's some of that and then eventually

00:45:13,560 --> 00:45:17,760
there's the actual return address and

00:45:15,839 --> 00:45:18,900
that's where we fill in the return

00:45:17,760 --> 00:45:20,880
address that we're gonna go ahead and

00:45:18,900 --> 00:45:24,960
hit and we also get that from the

00:45:20,880 --> 00:45:26,700
application as well and so when it's all

00:45:24,960 --> 00:45:28,740
said and done the linker script and the

00:45:26,700 --> 00:45:31,710
post compilation phase produces this

00:45:28,740 --> 00:45:33,300
binary blob that's about a page in size

00:45:31,710 --> 00:45:37,800
that's actually about two pages in size

00:45:33,300 --> 00:45:39,720
and that binary blob matches perfectly

00:45:37,800 --> 00:45:42,810
with the thing I'm about to attack that

00:45:39,720 --> 00:45:45,119
will fill in the buffer that we're going

00:45:42,810 --> 00:45:47,339
to attack with our executable code and

00:45:45,119 --> 00:45:48,930
then overwrite the return address so

00:45:47,339 --> 00:45:51,960
that it points back to that buffer and

00:45:48,930 --> 00:45:57,079
in execute our logic and that's it

00:45:51,960 --> 00:46:01,680
that's that's how that works so I can

00:45:57,079 --> 00:46:08,400
run this little executable and all it

00:46:01,680 --> 00:46:10,530
does is it it's just as X cubed here and

00:46:08,400 --> 00:46:12,810
it takes two parameters one file and

00:46:10,530 --> 00:46:14,460
another file and it just takes the two

00:46:12,810 --> 00:46:16,890
files and compares it to if they're

00:46:14,460 --> 00:46:18,569
equal it spits out equal if they're not

00:46:16,890 --> 00:46:20,730
equal it spits on not equal it's that

00:46:18,569 --> 00:46:22,770
simple it just so happens that the way

00:46:20,730 --> 00:46:23,910
that the application was written is they

00:46:22,770 --> 00:46:25,619
forget to check the size of the buffer

00:46:23,910 --> 00:46:28,410
and so therefore it's easily overflowed

00:46:25,619 --> 00:46:30,359
sounds stupid but it happens all the

00:46:28,410 --> 00:46:31,980
time it's like all the time

00:46:30,359 --> 00:46:33,810
why things like the core guidelines are

00:46:31,980 --> 00:46:35,160
so important because they don't allow

00:46:33,810 --> 00:46:35,520
you to make those mistakes in the first

00:46:35,160 --> 00:46:37,230
place

00:46:35,520 --> 00:46:40,430
if you adhere to them and there's tools

00:46:37,230 --> 00:46:40,430
to tell you adhering to them

00:46:42,390 --> 00:46:49,630
so I can run this alright so you get to

00:46:48,580 --> 00:46:51,550
see little bit magic here

00:46:49,630 --> 00:46:59,260
I was worried that a reboot would do

00:46:51,550 --> 00:47:01,390
that so if we go to the container I can

00:46:59,260 --> 00:47:03,760
from here this is the actual function in

00:47:01,390 --> 00:47:07,830
a way that you can like you know play

00:47:03,760 --> 00:47:07,830
around with these things is actually to

00:47:07,890 --> 00:47:12,250
modify them yourself so all I'm gonna do

00:47:10,810 --> 00:47:19,510
is say hey where's the location of the

00:47:12,250 --> 00:47:23,230
buffer and now if I run this it'll tell

00:47:19,510 --> 00:47:26,980
me oh that's fine I forgot to run that

00:47:23,230 --> 00:47:29,500
first this is that post compilation page

00:47:26,980 --> 00:47:31,420
that you got to do and the reboot turned

00:47:29,500 --> 00:47:34,660
off a it turned a SLR back on I got to

00:47:31,420 --> 00:47:38,950
turn it back off again once again don't

00:47:34,660 --> 00:47:40,780
do that for real ok so there you go and

00:47:38,950 --> 00:47:43,000
so that little printf is still there

00:47:40,780 --> 00:47:47,050
that I had I just put in there but as

00:47:43,000 --> 00:47:51,160
you can see the equal or sorry not equal

00:47:47,050 --> 00:47:52,450
shows up and because the two might my

00:47:51,160 --> 00:47:54,940
attack is obviously not equal to the

00:47:52,450 --> 00:47:57,700
file is comparing it against and then it

00:47:54,940 --> 00:48:00,190
prints out that that whole giant C++

00:47:57,700 --> 00:48:03,130
application again so there's C++ running

00:48:00,190 --> 00:48:06,730
from shell code from a buffer overflow

00:48:03,130 --> 00:48:08,370
attack and just for the curious if you

00:48:06,730 --> 00:48:11,080
look at the address that I printed out

00:48:08,370 --> 00:48:13,300
before and after the address that's

00:48:11,080 --> 00:48:16,120
there is all sorts of gobbledygook and

00:48:13,300 --> 00:48:18,880
this one is very very specific there's a

00:48:16,120 --> 00:48:20,890
lot s in it right that's a SLR at work

00:48:18,880 --> 00:48:23,380
so I guess all our produces a random

00:48:20,890 --> 00:48:24,940
address for the stack without a SLR you

00:48:23,380 --> 00:48:26,200
get the same address for the stack over

00:48:24,940 --> 00:48:28,900
and over and over which is what allows

00:48:26,200 --> 00:48:29,950
you to create these types of attacks but

00:48:28,900 --> 00:48:33,700
there's all sorts of other things that

00:48:29,950 --> 00:48:38,590
are added to it well alright so just I

00:48:33,700 --> 00:48:39,340
finish up here one last slide what are

00:48:38,590 --> 00:48:41,230
limitations

00:48:39,340 --> 00:48:43,570
well right now it only supports Intel

00:48:41,230 --> 00:48:46,150
AMD on 64-bit there are no plans to

00:48:43,570 --> 00:48:49,480
support 32-bit if somebody really wants

00:48:46,150 --> 00:48:51,660
that maybe but we do plan at arm and

00:48:49,480 --> 00:48:51,660
MIPS

00:48:53,340 --> 00:48:58,470
so then position independence is also

00:48:57,090 --> 00:48:59,670
something that at the moment we

00:48:58,470 --> 00:49:02,400
currently require that can be removed

00:48:59,670 --> 00:49:04,050
and we actually want to remove that so

00:49:02,400 --> 00:49:04,290
static pie is required we want to get to

00:49:04,050 --> 00:49:06,750
you

00:49:04,290 --> 00:49:08,340
static non pie support for shared

00:49:06,750 --> 00:49:10,830
libraries we have no intention of

00:49:08,340 --> 00:49:12,510
supporting and it's not actually to

00:49:10,830 --> 00:49:13,950
watch the community move because like

00:49:12,510 --> 00:49:16,230
GCC and stuff we're kind of moving away

00:49:13,950 --> 00:49:17,550
from from dynamic shared libraries

00:49:16,230 --> 00:49:19,680
because they have their own problems now

00:49:17,550 --> 00:49:21,090
so it kind of interested to see where

00:49:19,680 --> 00:49:24,090
that debate ends up heading because like

00:49:21,090 --> 00:49:24,930
go at the moment is all static but you

00:49:24,090 --> 00:49:26,370
know something everybody doesn't like

00:49:24,930 --> 00:49:28,440
that so I don't know it'd be just to see

00:49:26,370 --> 00:49:30,000
where that goes but at any rate we don't

00:49:28,440 --> 00:49:32,760
plan on providing support for shared

00:49:30,000 --> 00:49:34,080
libraries anybody who actually uses that

00:49:32,760 --> 00:49:35,700
likely already has an operating system

00:49:34,080 --> 00:49:37,140
to do it forum so why would you why

00:49:35,700 --> 00:49:38,550
would you do that

00:49:37,140 --> 00:49:40,200
being able to compile in Windows is

00:49:38,550 --> 00:49:42,420
something we want to do that's gonna

00:49:40,200 --> 00:49:45,090
require a new Lib C to make that work

00:49:42,420 --> 00:49:46,140
new lid doesn't compile in Windows using

00:49:45,090 --> 00:49:47,040
unless you say one or something like

00:49:46,140 --> 00:49:51,120
that

00:49:47,040 --> 00:49:53,010
and pthread support so actually being

00:49:51,120 --> 00:49:54,990
able to run threads is something we also

00:49:53,010 --> 00:49:57,080
want to be able to support it won't look

00:49:54,990 --> 00:49:59,700
like what you're used to thread support

00:49:57,080 --> 00:50:01,740
and an operating system has a scheduler

00:49:59,700 --> 00:50:02,910
and there's talks that are needed to

00:50:01,740 --> 00:50:05,250
make that work and in this particular

00:50:02,910 --> 00:50:07,080
case the thread support would be more

00:50:05,250 --> 00:50:09,960
like you know okay I've got something

00:50:07,080 --> 00:50:11,880
running I want to yield to something

00:50:09,960 --> 00:50:13,410
else and whatever it is you're yielding

00:50:11,880 --> 00:50:14,930
to have to yield for the next thing to

00:50:13,410 --> 00:50:17,160
be able to execute so there's no like

00:50:14,930 --> 00:50:18,690
interruption type stuff going on but

00:50:17,160 --> 00:50:20,760
it's still actually quite useful to have

00:50:18,690 --> 00:50:22,890
the ability to do that so that's

00:50:20,760 --> 00:50:24,300
something you want to do and then we are

00:50:22,890 --> 00:50:25,800
gonna probably want to implement our own

00:50:24,300 --> 00:50:28,020
let's see and give it a new lip it's no

00:50:25,800 --> 00:50:30,240
destiny lid that projects been fantastic

00:50:28,020 --> 00:50:31,710
it's just not really well suited for the

00:50:30,240 --> 00:50:34,620
stuff we're trying to do and we really

00:50:31,710 --> 00:50:38,000
battle a lot with it so we'll probably

00:50:34,620 --> 00:50:39,240
end up doing something else at some time

00:50:38,000 --> 00:50:42,440
okay

00:50:39,240 --> 00:50:42,440
any questions

00:50:52,240 --> 00:50:58,240
hi weather what approach do you support

00:50:55,869 --> 00:51:05,109
for exception handling is a table based

00:50:58,240 --> 00:51:07,480
or frame based a well I mean the table

00:51:05,109 --> 00:51:11,730
based is when a great special table we

00:51:07,480 --> 00:51:11,730
have all information about exception

00:51:11,910 --> 00:51:18,010
right base is using implemented using

00:51:15,310 --> 00:51:20,500
said jumpy and long jumpy yes sir

00:51:18,010 --> 00:51:23,080
it is table based and so once again

00:51:20,500 --> 00:51:26,200
that's why we need some form of like

00:51:23,080 --> 00:51:28,599
file format that can actually do that

00:51:26,200 --> 00:51:30,640
all right so we compiled the health elf

00:51:28,599 --> 00:51:33,130
gives us the tables that we need the C

00:51:30,640 --> 00:51:35,170
runtime in this project is hooked up to

00:51:33,130 --> 00:51:36,910
know where that information is and then

00:51:35,170 --> 00:51:39,130
leverages that within the unwinder and

00:51:36,910 --> 00:51:41,230
how on how do and wine this tag do you

00:51:39,130 --> 00:51:45,550
use this technique tables so you use

00:51:41,230 --> 00:51:48,310
frame printers maybe we use our own one

00:51:45,550 --> 00:51:51,040
winder it actually uses the work tables

00:51:48,310 --> 00:51:53,349
that GCC will put into the elf lawyer or

00:51:51,040 --> 00:51:55,690
into the elf file so there's an actual

00:51:53,349 --> 00:51:57,070
dot eh underscore frame table that

00:51:55,690 --> 00:52:00,220
contains all of the information to

00:51:57,070 --> 00:52:02,260
unwind this the the stack from function

00:52:00,220 --> 00:52:04,690
the function of function in compressed

00:52:02,260 --> 00:52:05,890
dealt dwarf code and then we actually

00:52:04,690 --> 00:52:08,440
built anon wonder that will do all the

00:52:05,890 --> 00:52:11,380
decompression and and actually unwind

00:52:08,440 --> 00:52:12,700
the stack so it does use the zero

00:52:11,380 --> 00:52:15,760
overhead implementation the only thing

00:52:12,700 --> 00:52:19,270
that it it does we don't use at the

00:52:15,760 --> 00:52:20,589
moment our the age frame there's another

00:52:19,270 --> 00:52:22,060
table that gives you a hash table

00:52:20,589 --> 00:52:25,930
essentially we don't use the hash table

00:52:22,060 --> 00:52:27,099
but you know frankly I don't I've never

00:52:25,930 --> 00:52:30,280
cared so much about the hash table

00:52:27,099 --> 00:52:31,570
because in the end you know I don't

00:52:30,280 --> 00:52:33,880
really care of exceptions are slow they

00:52:31,570 --> 00:52:36,070
should never happen ever right so I

00:52:33,880 --> 00:52:37,810
don't care if they're slow I just care

00:52:36,070 --> 00:52:39,099
about their that they work so when an

00:52:37,810 --> 00:52:43,359
exception does happen I needed to be

00:52:39,099 --> 00:52:47,020
reliable so we do I plan someday to

00:52:43,359 --> 00:52:49,690
probably move to the apples unwinder I

00:52:47,020 --> 00:52:50,980
think it's live unwind there's like

00:52:49,690 --> 00:52:53,050
actually five different projects called

00:52:50,980 --> 00:52:55,119
live unwind unfortunately apples is no

00:52:53,050 --> 00:52:56,830
different but the problem that that all

00:52:55,119 --> 00:52:58,450
of them have including apples is that

00:52:56,830 --> 00:53:01,390
they all have always depended stuff in

00:52:58,450 --> 00:53:04,150
them and so we wrote our own because we

00:53:01,390 --> 00:53:05,940
wanted to get rid of that in the end we

00:53:04,150 --> 00:53:10,060
probably could

00:53:05,940 --> 00:53:12,010
actually go and and remove and and

00:53:10,060 --> 00:53:13,930
remove all of that device dependent

00:53:12,010 --> 00:53:16,120
stuff out of apples and then build a

00:53:13,930 --> 00:53:17,380
lever G here but there is it's

00:53:16,120 --> 00:53:18,570
complicated there is some stuff that

00:53:17,380 --> 00:53:21,400
would have to be done to make that work

00:53:18,570 --> 00:53:26,800
did that answer your question yeah okay

00:53:21,400 --> 00:53:28,120
any other questions I could ask one

00:53:26,800 --> 00:53:32,290
question yes

00:53:28,120 --> 00:53:34,840
it's about your approach to implement

00:53:32,290 --> 00:53:37,990
system calls using show code and I

00:53:34,840 --> 00:53:41,470
wonder why don't you write your own

00:53:37,990 --> 00:53:43,480
rubber surround ask the instructions to

00:53:41,470 --> 00:53:44,980
execute the system call for example if

00:53:43,480 --> 00:53:47,700
you know operating system you can just

00:53:44,980 --> 00:53:47,700
throw it on in

00:53:47,730 --> 00:53:58,620
0:08 h with some preceding instructions

00:53:53,590 --> 00:54:02,290
to execute the system why don't on so

00:53:58,620 --> 00:54:03,880
well if this took me about a couple

00:54:02,290 --> 00:54:05,380
hours alright so that's the first reason

00:54:03,880 --> 00:54:06,880
I didn't feel like writing all the

00:54:05,380 --> 00:54:09,760
assembly to do the system calls manually

00:54:06,880 --> 00:54:10,840
you could do that frankly however most

00:54:09,760 --> 00:54:12,610
people don't use in sending more than

00:54:10,840 --> 00:54:14,830
you staff system calls in 64-bit so

00:54:12,610 --> 00:54:16,000
that's a bit more complicated you'd have

00:54:14,830 --> 00:54:18,670
to know a little bit more about the API

00:54:16,000 --> 00:54:19,840
but it's either way buttsfast system

00:54:18,670 --> 00:54:23,170
calls or interrupts base you could do

00:54:19,840 --> 00:54:24,490
either one and yes from the from the

00:54:23,170 --> 00:54:25,960
shell code you could do that and not

00:54:24,490 --> 00:54:28,360
have to get activating that stuff and

00:54:25,960 --> 00:54:31,210
that would simplify things at some

00:54:28,360 --> 00:54:33,640
degree if you had the time to go and and

00:54:31,210 --> 00:54:34,750
write all that but it would work it

00:54:33,640 --> 00:54:36,190
there's a little bit more of a

00:54:34,750 --> 00:54:37,660
complication a sense that there were

00:54:36,190 --> 00:54:39,910
some fanciness that was able to do

00:54:37,660 --> 00:54:41,740
because the application that I was

00:54:39,910 --> 00:54:44,590
hacking happened to have you know just

00:54:41,740 --> 00:54:46,270
so happen I wrote it some functions that

00:54:44,590 --> 00:54:48,490
made things easier so leveraging that

00:54:46,270 --> 00:54:51,610
was nice and you can't do that with

00:54:48,490 --> 00:54:54,370
system calls stuff but yeah what you're

00:54:51,610 --> 00:54:55,420
saying you can definitely do I you know

00:54:54,370 --> 00:54:56,650
frankly there's a million different

00:54:55,420 --> 00:54:59,380
things that you could do to make this

00:54:56,650 --> 00:55:00,850
more impressive including like doing it

00:54:59,380 --> 00:55:02,590
so you don't need all the security

00:55:00,850 --> 00:55:05,700
features turned off but once again I

00:55:02,590 --> 00:55:05,700
wanted to keep it somewhat simple

00:55:10,710 --> 00:55:15,820
any other questions all right well thank

00:55:14,860 --> 00:55:20,109
you very much for your time

00:55:15,820 --> 00:55:20,109

YouTube URL: https://www.youtube.com/watch?v=bKPN-CGhEC0


