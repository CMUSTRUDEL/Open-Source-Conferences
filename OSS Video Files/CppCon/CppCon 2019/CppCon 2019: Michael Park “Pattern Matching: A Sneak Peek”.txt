Title: CppCon 2019: Michael Park “Pattern Matching: A Sneak Peek”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Pattern matching brings a declarative approach to destructuring and inspecting complex data types. It’s a very powerful abstraction provided by many programming languages such as Haskell and OCaml, and more recently, Rust, Scala, and Swift.

In this talk, we’ll discuss the proposal in flight (https://wg21.link/p1371) to add pattern matching as a language feature in the C++. We’ll discuss why pattern matching is more relevant today to C++ than ever before, examples of how pattern matching simplifies the structure of code, and discuss the details of the concrete features being proposed.

The goal of the talk is to build an intuition for pattern matching, and gather feedback of the state of an early stage proposal.
— 
Michael Park
Software Engineer, Facebook
I'm a software engineer at Facebook, working on the C++ libraries and standards team. My focus for C++ is to introduce pattern matching to facilitate better code.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:11,389 --> 00:00:15,080
all right I'll get started welcome

00:00:12,980 --> 00:00:17,300
everybody thank you all for coming

00:00:15,080 --> 00:00:19,939
my name is Michael Park I'm a software

00:00:17,300 --> 00:00:21,590
engineer at Facebook and I work on C++

00:00:19,939 --> 00:00:25,189
libraries and standardization efforts

00:00:21,590 --> 00:00:27,529
for face book so this talk is going to

00:00:25,189 --> 00:00:29,509
be a sneak peek into a specific paper

00:00:27,529 --> 00:00:32,149
that proposes a language feature called

00:00:29,509 --> 00:00:33,530
pattern matching to C++ 23 I say a

00:00:32,149 --> 00:00:35,210
sneak-peek but I'm actually going to

00:00:33,530 --> 00:00:37,670
throw a lot of information at you so

00:00:35,210 --> 00:00:42,980
we're gonna go a little bit quick so the

00:00:37,670 --> 00:00:45,230
specific paper number is P 1371 r1 for

00:00:42,980 --> 00:00:49,250
those of you who don't know you can use

00:00:45,230 --> 00:00:51,230
the WG 21 link slash P 1371 r1 to get

00:00:49,250 --> 00:00:55,040
access to the paper so these are the

00:00:51,230 --> 00:00:56,960
co-authors the the folks are from

00:00:55,040 --> 00:00:57,620
Facebook and Bloomberg so myself from

00:00:56,960 --> 00:00:59,930
Facebook

00:00:57,620 --> 00:01:02,570
Sergey David and then who is in the room

00:00:59,930 --> 00:01:04,610
our Bloomberg folks and so this has been

00:01:02,570 --> 00:01:07,759
a collaborative effort between Facebook

00:01:04,610 --> 00:01:08,180
and Bloomberg this talk has two goals in

00:01:07,759 --> 00:01:10,850
mind

00:01:08,180 --> 00:01:13,219
one is to help you build an intuition as

00:01:10,850 --> 00:01:14,509
to what pattern matching is how it works

00:01:13,219 --> 00:01:16,490
and how it can help you simplify your

00:01:14,509 --> 00:01:18,560
code and second is to gather feedback

00:01:16,490 --> 00:01:20,840
because ultimately we want the feature

00:01:18,560 --> 00:01:22,340
to be awesome we want to share early as

00:01:20,840 --> 00:01:23,870
to what the early design phase is and

00:01:22,340 --> 00:01:25,460
get feedback as to what people liked

00:01:23,870 --> 00:01:26,810
when people don't like and we've gone

00:01:25,460 --> 00:01:30,020
through some of these iteration phases

00:01:26,810 --> 00:01:32,600
already so by show of hands how many

00:01:30,020 --> 00:01:34,250
people are already familiar with with

00:01:32,600 --> 00:01:36,920
pattern matching from other languages

00:01:34,250 --> 00:01:39,350
from Haskell Swift Scala what have you

00:01:36,920 --> 00:01:41,930
okay this is about I would say more than

00:01:39,350 --> 00:01:43,340
half the room so maybe you guys are

00:01:41,930 --> 00:01:44,540
already convinced but for those for

00:01:43,340 --> 00:01:46,970
those of you who didn't raise your hands

00:01:44,540 --> 00:01:49,270
let's go through some motivations so the

00:01:46,970 --> 00:01:52,040
point is that we have these two

00:01:49,270 --> 00:01:53,930
extremely common and simple tasks that

00:01:52,040 --> 00:01:56,810
we perform in programming on a daily

00:01:53,930 --> 00:01:59,119
basis one is selection and the other is

00:01:56,810 --> 00:02:00,619
decomposition these words might sound

00:01:59,119 --> 00:02:02,030
fancy but selection just means

00:02:00,619 --> 00:02:04,250
performing different actions depending

00:02:02,030 --> 00:02:06,340
on a value you already know this from

00:02:04,250 --> 00:02:08,450
examples like switch and if and

00:02:06,340 --> 00:02:09,950
decomposition is just about retrieving

00:02:08,450 --> 00:02:11,299
components out of a value so we

00:02:09,950 --> 00:02:13,909
typically do this through a member

00:02:11,299 --> 00:02:15,500
access or with structured bindings which

00:02:13,909 --> 00:02:18,290
was introduced in signals 417 to help

00:02:15,500 --> 00:02:21,770
with this problem and these two things

00:02:18,290 --> 00:02:24,090
should be simple and let's see where we

00:02:21,770 --> 00:02:25,890
are today so with selection we have

00:02:24,090 --> 00:02:28,739
to selection statements in the language

00:02:25,890 --> 00:02:30,420
one is switch and the other is if so

00:02:28,739 --> 00:02:33,390
let's take a look so first switch

00:02:30,420 --> 00:02:34,890
obviously is the first thing that you

00:02:33,390 --> 00:02:36,750
would reach for when you when you're

00:02:34,890 --> 00:02:39,930
looking for something to do a multi

00:02:36,750 --> 00:02:41,670
branch testing right and soon after you

00:02:39,930 --> 00:02:43,410
start using it I'm sure all of you know

00:02:41,670 --> 00:02:45,120
that you can't match a string with the

00:02:43,410 --> 00:02:49,110
switch because it only supports

00:02:45,120 --> 00:02:50,849
integrals except that it doesn't only

00:02:49,110 --> 00:02:52,739
support integrals it only supports a

00:02:50,849 --> 00:02:55,260
single integral so even if you just had

00:02:52,739 --> 00:02:57,150
two integers X and Y and you wanted to

00:02:55,260 --> 00:03:00,450
test both of them are zero you couldn't

00:02:57,150 --> 00:03:01,920
say switch X comma Y and then case zero

00:03:00,450 --> 00:03:04,319
comma zero you'd have to actually nest

00:03:01,920 --> 00:03:05,640
switches to get what you want

00:03:04,319 --> 00:03:08,730
and so we would like to be able to

00:03:05,640 --> 00:03:12,390
subdue better so the other side is an

00:03:08,730 --> 00:03:14,370
if-else statement here we have a classic

00:03:12,390 --> 00:03:16,349
shape class hierarchy which is a

00:03:14,370 --> 00:03:19,010
polymorphic type circle and rectangle

00:03:16,349 --> 00:03:21,930
which inherit from shape and a

00:03:19,010 --> 00:03:24,420
implementation of get area that

00:03:21,930 --> 00:03:25,290
performers dynamic cast to check the the

00:03:24,420 --> 00:03:27,350
elements that we're looking at the

00:03:25,290 --> 00:03:29,400
derived class that we're looking for so

00:03:27,350 --> 00:03:33,720
most people would look at this example

00:03:29,400 --> 00:03:35,519
and say don't do that and the point the

00:03:33,720 --> 00:03:38,760
Blaine typically goes to that in the

00:03:35,519 --> 00:03:40,950
cast and the point I would like to make

00:03:38,760 --> 00:03:42,840
is that I would like the argue is that

00:03:40,950 --> 00:03:45,000
it's actually not that Emmet cast is

00:03:42,840 --> 00:03:47,700
fault here and the reason I say that is

00:03:45,000 --> 00:03:49,440
because dynamic cast is already slower

00:03:47,700 --> 00:03:51,450
than a virtual function call but let's

00:03:49,440 --> 00:03:52,859
assume that dynamic cast is only as

00:03:51,450 --> 00:03:54,959
expensive as a virtual function call

00:03:52,859 --> 00:03:56,700
even if that were the case this would

00:03:54,959 --> 00:03:59,100
still be double the cost right

00:03:56,700 --> 00:04:00,810
potentially and if there are n of these

00:03:59,100 --> 00:04:03,269
it would be n times the cost and the

00:04:00,810 --> 00:04:06,540
reason for that is actually not that it

00:04:03,269 --> 00:04:08,609
casts fault because the if else the the

00:04:06,540 --> 00:04:10,650
the control structure used here is just

00:04:08,609 --> 00:04:12,209
way too flexible for the compiler to be

00:04:10,650 --> 00:04:14,190
able to reason through all of these

00:04:12,209 --> 00:04:16,019
conditions these arbitrary boolean

00:04:14,190 --> 00:04:17,430
expressions and to know that we can

00:04:16,019 --> 00:04:19,079
actually consolidate these dynamic cast

00:04:17,430 --> 00:04:22,169
into a sink into a single virtual

00:04:19,079 --> 00:04:24,210
dispatch so inherently what we're

00:04:22,169 --> 00:04:26,669
looking at is a structural Association

00:04:24,210 --> 00:04:29,280
so what I mean by that is if you look at

00:04:26,669 --> 00:04:33,120
the switch example we have an int value

00:04:29,280 --> 00:04:36,360
and we have case C 1 and C 2 okay and C

00:04:33,120 --> 00:04:37,260
1 and C 2 are arbitrary expressions now

00:04:36,360 --> 00:04:40,620
even we

00:04:37,260 --> 00:04:42,120
expanding c1 and c2 I can tell that the

00:04:40,620 --> 00:04:43,680
result of the the values of those

00:04:42,120 --> 00:04:46,560
expressions will be compared against

00:04:43,680 --> 00:04:49,260
value right on the other side we have if

00:04:46,560 --> 00:04:50,660
and the B 1 and B 1 and B 2 here are

00:04:49,260 --> 00:04:53,910
arbitrary boolean expressions and

00:04:50,660 --> 00:04:56,190
without expanding B 1 and B 2 and

00:04:53,910 --> 00:04:58,260
analyzing the boolean boolean expression

00:04:56,190 --> 00:05:01,230
we have no idea whether those conditions

00:04:58,260 --> 00:05:06,570
have anything to do with value is that

00:05:01,230 --> 00:05:08,520
clear seeing some nods ok so those are 2

00:05:06,570 --> 00:05:10,410
selection statements we have and what we

00:05:08,520 --> 00:05:11,790
want to strike is a balance in between

00:05:10,410 --> 00:05:14,280
these so we want the structural

00:05:11,790 --> 00:05:15,990
Association of switch but we but we

00:05:14,280 --> 00:05:17,490
don't want the limitations of switch so

00:05:15,990 --> 00:05:20,670
we want to essentially from one

00:05:17,490 --> 00:05:23,430
perspective we want to improve it would

00:05:20,670 --> 00:05:25,050
be a switch on stereos if you will and

00:05:23,430 --> 00:05:27,930
from the other perspective would be a

00:05:25,050 --> 00:05:29,400
structured if-else chain so we're trying

00:05:27,930 --> 00:05:33,000
to strike strike strike a balance in the

00:05:29,400 --> 00:05:36,830
middle an important case for me to cover

00:05:33,000 --> 00:05:39,840
here is still visit and stood variant so

00:05:36,830 --> 00:05:41,490
many of you may have some of you or

00:05:39,840 --> 00:05:45,030
maybe many of you may have seen this

00:05:41,490 --> 00:05:48,690
article which states that stood visit is

00:05:45,030 --> 00:05:50,940
everything wrong with modern C++ so just

00:05:48,690 --> 00:05:52,500
so I have a feel how many people are

00:05:50,940 --> 00:05:55,790
familiar what's the variant add in a

00:05:52,500 --> 00:05:58,170
sequence of 17 ok so I think most of you

00:05:55,790 --> 00:06:01,650
said variant basically allows you to

00:05:58,170 --> 00:06:04,890
hold one of n elements and you can still

00:06:01,650 --> 00:06:08,790
you can use the visit to basically pull

00:06:04,890 --> 00:06:11,730
out the the value that is stored inside

00:06:08,790 --> 00:06:14,130
that Marion and it is very complicated

00:06:11,730 --> 00:06:16,290
so let's I'm not gonna go through it in

00:06:14,130 --> 00:06:19,080
a lot of detail but just to convince you

00:06:16,290 --> 00:06:20,910
that it's that's because looks good

00:06:19,080 --> 00:06:23,430
let's take a look so this is this would

00:06:20,910 --> 00:06:24,810
be the most basic use of it we first

00:06:23,430 --> 00:06:27,450
construct a variant of

00:06:24,810 --> 00:06:30,420
bool in string and then we have we set

00:06:27,450 --> 00:06:33,390
up a visitor which is a struct with an

00:06:30,420 --> 00:06:37,080
operator called bubble operator that

00:06:33,390 --> 00:06:39,270
handles each of the cases ok and at the

00:06:37,080 --> 00:06:44,730
end we're gonna do is to visit a visitor

00:06:39,270 --> 00:06:46,950
on to the variant that we have now a lot

00:06:44,730 --> 00:06:49,020
of people are bothered by the fact that

00:06:46,950 --> 00:06:50,759
we have to define the cases out of line

00:06:49,020 --> 00:06:52,050
and so

00:06:50,759 --> 00:06:54,990
ultimately they want to write something

00:06:52,050 --> 00:06:58,110
like this and so we have visit of

00:06:54,990 --> 00:07:00,979
overload of these lambdas and overload

00:06:58,110 --> 00:07:03,300
there is creating an overload set and

00:07:00,979 --> 00:07:06,029
this would this would be a slightly

00:07:03,300 --> 00:07:08,159
slight improvement and already it gets

00:07:06,029 --> 00:07:11,370
very complicated so here this is the

00:07:08,159 --> 00:07:13,919
overload helper this involves Meriadoc

00:07:11,370 --> 00:07:16,680
templates very attic multiple

00:07:13,919 --> 00:07:18,779
inheritance very attic using which is

00:07:16,680 --> 00:07:20,039
only added in suppose 4:17 so if you try

00:07:18,779 --> 00:07:22,289
to implement this before that it would

00:07:20,039 --> 00:07:24,689
be a lot more complicated we have class

00:07:22,289 --> 00:07:27,089
argument class class template argument

00:07:24,689 --> 00:07:29,069
deduction and deduction guides in order

00:07:27,089 --> 00:07:31,020
to achieve this the code is short but

00:07:29,069 --> 00:07:34,589
the amount of C++ knowledge you need to

00:07:31,020 --> 00:07:38,129
understand this is is a lot let's move

00:07:34,589 --> 00:07:39,569
move move forward so here is this by the

00:07:38,129 --> 00:07:41,550
way these are examples that I pulled off

00:07:39,569 --> 00:07:44,789
from CPP reference so I'm not just like

00:07:41,550 --> 00:07:48,210
making stuff up here ok so this example

00:07:44,789 --> 00:07:50,639
is a way to use a generic lambda to

00:07:48,210 --> 00:07:52,889
visit an arbitrary variant and the way

00:07:50,639 --> 00:07:56,099
the way we were going about handling the

00:07:52,889 --> 00:08:00,509
cases is by using a context but if to

00:07:56,099 --> 00:08:03,740
analyze the types explicitly and at the

00:08:00,509 --> 00:08:06,300
end here we have this always false thing

00:08:03,740 --> 00:08:08,580
again I don't even want to explain this

00:08:06,300 --> 00:08:12,240
but it rich it involves dependent types

00:08:08,580 --> 00:08:13,949
and the instantiation of templates so

00:08:12,240 --> 00:08:16,080
that we can get exhaustive exact thing

00:08:13,949 --> 00:08:17,909
is checking if you if you happen to not

00:08:16,080 --> 00:08:21,809
handle a case that we're supposed to be

00:08:17,909 --> 00:08:25,680
able so that involves introducing this

00:08:21,809 --> 00:08:27,689
always false helper and I don't want to

00:08:25,680 --> 00:08:30,149
explain any of this right I want people

00:08:27,689 --> 00:08:32,339
to just I want people to just use a

00:08:30,149 --> 00:08:35,339
variant which can hold one of n things

00:08:32,339 --> 00:08:37,319
and just take stuff out and go through

00:08:35,339 --> 00:08:42,930
your job right like I don't want to

00:08:37,319 --> 00:08:45,000
explain all of this stuff so so ok we

00:08:42,930 --> 00:08:47,819
want to improve on still visit and ha

00:08:45,000 --> 00:08:49,709
and the usability of it basically now

00:08:47,819 --> 00:08:51,750
the other side of it I mentioned is the

00:08:49,709 --> 00:08:53,550
composition and there's not much to say

00:08:51,750 --> 00:08:56,250
here aside from the fact that it happens

00:08:53,550 --> 00:08:58,290
all the time so typically in this

00:08:56,250 --> 00:09:00,510
example where we're doing like naive

00:08:58,290 --> 00:09:02,550
selection we're gonna do a member access

00:09:00,510 --> 00:09:04,680
to get the pieces out after we select

00:09:02,550 --> 00:09:07,529
the the item that we want

00:09:04,680 --> 00:09:10,800
we're mostly going to access elements

00:09:07,529 --> 00:09:13,290
out of that to do stuff right with

00:09:10,800 --> 00:09:15,209
structures bindings you can change it'll

00:09:13,290 --> 00:09:17,040
change it a little bit and so if you

00:09:15,209 --> 00:09:19,110
happen to refer to the members quite a

00:09:17,040 --> 00:09:22,079
bit then you could shorten shorten the

00:09:19,110 --> 00:09:24,959
syntax but this is just for completeness

00:09:22,079 --> 00:09:29,220
in this area now if we put these

00:09:24,959 --> 00:09:31,439
together then we get something that's it

00:09:29,220 --> 00:09:34,050
gets very complicated so let's do our

00:09:31,439 --> 00:09:35,850
setup so we have this message class a

00:09:34,050 --> 00:09:39,540
message type which is going to be a

00:09:35,850 --> 00:09:42,389
variant of for commands quit move right

00:09:39,540 --> 00:09:44,899
and change color these are commands they

00:09:42,389 --> 00:09:48,179
have associated data and we're going to

00:09:44,899 --> 00:09:50,189
basically just visit them right so we're

00:09:48,179 --> 00:09:52,499
gonna say visit the overload of all this

00:09:50,189 --> 00:09:54,480
stuff and so what we're at what we're

00:09:52,499 --> 00:09:57,869
seeing when we see something like this

00:09:54,480 --> 00:10:00,329
is we're first selecting across the

00:09:57,869 --> 00:10:02,939
vertical axis and then we decompose on

00:10:00,329 --> 00:10:04,649
the horizontal axis and so we're doing

00:10:02,939 --> 00:10:05,999
that for other times but for the for the

00:10:04,649 --> 00:10:09,329
other cases as well but I'm showing it

00:10:05,999 --> 00:10:11,370
for this particular case so if we were

00:10:09,329 --> 00:10:13,199
to and this might not actually look too

00:10:11,370 --> 00:10:14,670
bad right you kind of know what's going

00:10:13,199 --> 00:10:19,170
on here and it's like a little bit of

00:10:14,670 --> 00:10:22,050
boilerplate but whatever but once we

00:10:19,170 --> 00:10:24,499
start nesting it it becomes a lot more

00:10:22,050 --> 00:10:27,540
hairy so let's say the change color

00:10:24,499 --> 00:10:29,939
command we replace the data data members

00:10:27,540 --> 00:10:33,209
to actually abstract it out to a color

00:10:29,939 --> 00:10:36,929
class so that variant is going to be an

00:10:33,209 --> 00:10:38,370
RGB scheme or HSV HSV scheme no idea

00:10:36,929 --> 00:10:40,559
what that means doesn't matter for this

00:10:38,370 --> 00:10:44,790
example so we're gonna we're gonna store

00:10:40,559 --> 00:10:49,379
this color instead okay and then I want

00:10:44,790 --> 00:10:51,959
to select across the top level I want to

00:10:49,379 --> 00:10:53,939
grab the color out of the change color

00:10:51,959 --> 00:10:55,139
argument and I can't even fit this on

00:10:53,939 --> 00:10:57,600
the same take a single slide anymore

00:10:55,139 --> 00:11:01,459
right and then we're gonna visit again

00:10:57,600 --> 00:11:03,749
so this is select selection composition

00:11:01,459 --> 00:11:06,209
decomposition we select that we select

00:11:03,749 --> 00:11:08,999
again and then we have to deke decompose

00:11:06,209 --> 00:11:11,309
again and so it adds this level of

00:11:08,999 --> 00:11:14,189
nesting that makes code very difficult

00:11:11,309 --> 00:11:16,829
for us to read so what's the alternative

00:11:14,189 --> 00:11:18,120
so let's look at what Russ does in this

00:11:16,829 --> 00:11:20,029
example so this example

00:11:18,120 --> 00:11:23,100
was actually pulled out from this URL

00:11:20,029 --> 00:11:26,070
assume the exact same data structures

00:11:23,100 --> 00:11:27,450
that we've set up so far and this is

00:11:26,070 --> 00:11:29,520
what this is what we read up writing so

00:11:27,450 --> 00:11:33,960
we're selecting on the vertical axis

00:11:29,520 --> 00:11:37,130
still we decomposed horizontally revert

00:11:33,960 --> 00:11:39,240
we select again and we decompose again

00:11:37,130 --> 00:11:40,800
right and so all of these things are

00:11:39,240 --> 00:11:43,800
happening but it's happening in a very

00:11:40,800 --> 00:11:45,900
compact way where the construction of

00:11:43,800 --> 00:11:47,880
the value looks very close to the

00:11:45,900 --> 00:11:49,470
construction of the pattern and so you

00:11:47,880 --> 00:11:50,880
can actually without me having to

00:11:49,470 --> 00:11:55,950
explain this example you can probably

00:11:50,880 --> 00:11:58,800
guess what it does okay so the takeaways

00:11:55,950 --> 00:12:00,390
for motivation generally is that

00:11:58,800 --> 00:12:02,220
selection and decomposition are

00:12:00,390 --> 00:12:04,800
extremely common operations that should

00:12:02,220 --> 00:12:06,860
be simple we want a general selection

00:12:04,800 --> 00:12:09,089
mechanism between switch and if-else

00:12:06,860 --> 00:12:11,310
selection in decomposition very often

00:12:09,089 --> 00:12:12,779
nest and nest nested selection

00:12:11,310 --> 00:12:16,230
decomposition leads to a lot of

00:12:12,779 --> 00:12:20,550
indentation which generally I correspond

00:12:16,230 --> 00:12:23,910
with program complexity so what is

00:12:20,550 --> 00:12:26,820
pattern matching so this quote is from

00:12:23,910 --> 00:12:32,220
the haskell wiki and so obviously it's

00:12:26,820 --> 00:12:34,200
correct in so it says that in pattern

00:12:32,220 --> 00:12:35,790
matching we attempt to match values

00:12:34,200 --> 00:12:37,950
against patterns and they're still

00:12:35,790 --> 00:12:39,810
desired bind variables to successful

00:12:37,950 --> 00:12:41,900
matches okay

00:12:39,810 --> 00:12:45,720
so I have this information card up here

00:12:41,900 --> 00:12:47,670
with bold value italicized pattern and

00:12:45,720 --> 00:12:49,860
underlined variable with color codings

00:12:47,670 --> 00:12:51,870
so that we can keep track of what's what

00:12:49,860 --> 00:12:54,270
components are referring to correspond

00:12:51,870 --> 00:12:57,150
to what so let's go back to rest for a

00:12:54,270 --> 00:12:58,830
minute a quick example we have this

00:12:57,150 --> 00:13:01,080
point class which is very simple we have

00:12:58,830 --> 00:13:02,580
an x and y we're gonna create a new

00:13:01,080 --> 00:13:05,700
instance of that point and we're gonna

00:13:02,580 --> 00:13:08,430
match on it and what we're doing is the

00:13:05,700 --> 00:13:13,050
first pattern will match any any x or

00:13:08,430 --> 00:13:14,970
and a 0 0 for y and the second pattern

00:13:13,050 --> 00:13:17,760
which will that match because we have y

00:13:14,970 --> 00:13:20,070
equals 7 right and the second second

00:13:17,760 --> 00:13:23,910
pattern will match because x is 0 and y

00:13:20,070 --> 00:13:27,600
can be anything and then the y there

00:13:23,910 --> 00:13:30,120
will bind the value that's stored inside

00:13:27,600 --> 00:13:32,300
point and when we print it we get y axis

00:13:30,120 --> 00:13:34,529
00:13:32,300 --> 00:13:35,270
okay I don't see any friends so I'll

00:13:34,529 --> 00:13:38,339
move on

00:13:35,270 --> 00:13:41,550
so in C++ we'll probably have to write

00:13:38,339 --> 00:13:43,410
something like this right we would

00:13:41,550 --> 00:13:45,000
rather than being able to describe the

00:13:43,410 --> 00:13:47,700
value that we want to see we would

00:13:45,000 --> 00:13:51,270
actually have to perform imperative

00:13:47,700 --> 00:13:52,470
actions to see to to pull out the

00:13:51,270 --> 00:13:55,620
conditions that we actually want to see

00:13:52,470 --> 00:13:58,320
right and so the color coding here is

00:13:55,620 --> 00:14:02,690
basically where values patterns and

00:13:58,320 --> 00:14:05,670
variables lie so from this perspective

00:14:02,690 --> 00:14:07,950
declarative pattern matching can be seen

00:14:05,670 --> 00:14:09,750
as a declarative alternative to manually

00:14:07,950 --> 00:14:12,930
testing values with conditionals and

00:14:09,750 --> 00:14:14,160
extracting the desired components so

00:14:12,930 --> 00:14:15,750
let's take a look closer look at a

00:14:14,160 --> 00:14:17,910
pattern so this was a this was a pattern

00:14:15,750 --> 00:14:20,459
that we matched a couple slides ago and

00:14:17,910 --> 00:14:23,399
there are two things that are embedded

00:14:20,459 --> 00:14:26,100
in this pattern one is the test testing

00:14:23,399 --> 00:14:28,140
portion right the X code zero is

00:14:26,100 --> 00:14:30,600
actually testing for point X equal to

00:14:28,140 --> 00:14:32,160
zero and the second part is extraction

00:14:30,600 --> 00:14:34,620
so rather than doing point that Y

00:14:32,160 --> 00:14:36,660
whereas we're saying just by like I

00:14:34,620 --> 00:14:39,029
would give you a name make that thing to

00:14:36,660 --> 00:14:41,070
think that I want right and so it's a

00:14:39,029 --> 00:14:43,709
very compact with the compact

00:14:41,070 --> 00:14:45,870
description of the thing the the actions

00:14:43,709 --> 00:14:46,830
that we want to perform and this might

00:14:45,870 --> 00:14:49,890
actually look similar

00:14:46,830 --> 00:14:51,120
remind you of regular expressions so if

00:14:49,890 --> 00:14:54,779
we look at a regular expression like

00:14:51,120 --> 00:14:56,220
this this there will be a first

00:14:54,779 --> 00:14:58,380
component which is a test component

00:14:56,220 --> 00:15:01,500
which matches letters followed by digits

00:14:58,380 --> 00:15:03,140
and the second and the second component

00:15:01,500 --> 00:15:06,540
will be the extract portion which

00:15:03,140 --> 00:15:11,250
extracts digits out of these the string

00:15:06,540 --> 00:15:15,300
that were matching so in the at the core

00:15:11,250 --> 00:15:18,209
of patterns a pattern matches and or

00:15:15,300 --> 00:15:20,790
binds so it could bind it could match

00:15:18,209 --> 00:15:23,270
and not bind anything it could not you

00:15:20,790 --> 00:15:26,190
could always match and all we only find

00:15:23,270 --> 00:15:27,420
or it could try to match and bind and by

00:15:26,190 --> 00:15:29,850
match I mean it could you could try to

00:15:27,420 --> 00:15:32,510
imagine fail right and so if it always

00:15:29,850 --> 00:15:36,540
matches then that's not gonna be pad

00:15:32,510 --> 00:15:38,370
matching that I'm talking about let's go

00:15:36,540 --> 00:15:41,940
back to the Select Plus the compose

00:15:38,370 --> 00:15:43,440
example so if we call it code the parts

00:15:41,940 --> 00:15:45,450
that I think are associated in this

00:15:43,440 --> 00:15:48,780
example I think this is where

00:15:45,450 --> 00:15:52,050
where the colors fall so we can see the

00:15:48,780 --> 00:15:55,320
message is all the way down here we have

00:15:52,050 --> 00:15:57,560
the patterns in the middle the variables

00:15:55,320 --> 00:16:00,480
that introduced and blah blah blah right

00:15:57,560 --> 00:16:02,130
so with the proposal what we want where

00:16:00,480 --> 00:16:03,570
we want to go oh sorry

00:16:02,130 --> 00:16:09,320
here's a here's the thing that I want

00:16:03,570 --> 00:16:11,670
you to whoa sorry wait a minute

00:16:09,320 --> 00:16:13,560
aha there we go okay

00:16:11,670 --> 00:16:16,320
so what I want you to focus on here is

00:16:13,560 --> 00:16:17,700
that there's this change color variable

00:16:16,320 --> 00:16:20,340
introduced and then we use it

00:16:17,700 --> 00:16:21,210
immediately and once we use it we don't

00:16:20,340 --> 00:16:23,700
use it anymore

00:16:21,210 --> 00:16:26,280
and we're looking at this change color

00:16:23,700 --> 00:16:29,150
type and the structured bindings

00:16:26,280 --> 00:16:32,460
decomposition and we have this like

00:16:29,150 --> 00:16:35,370
baton passing that happens that doesn't

00:16:32,460 --> 00:16:37,530
really need to happen and so when we

00:16:35,370 --> 00:16:38,070
collapse that we end up with something

00:16:37,530 --> 00:16:40,710
like this

00:16:38,070 --> 00:16:44,420
so you can see from the change color

00:16:40,710 --> 00:16:46,650
type I'm talking about this right here

00:16:44,420 --> 00:16:48,090
the from the change color type to the

00:16:46,650 --> 00:16:50,460
structured bindings example there's no

00:16:48,090 --> 00:16:51,930
you know giving it a name just to pop

00:16:50,460 --> 00:16:54,750
just the passive attano all along

00:16:51,930 --> 00:16:58,650
anymore and so we get much much more

00:16:54,750 --> 00:17:01,590
compact code so how does it collapse for

00:16:58,650 --> 00:17:04,740
this example so we have this kind of

00:17:01,590 --> 00:17:06,630
color scheme and all of this is going to

00:17:04,740 --> 00:17:09,270
collapse so let's look at let's look at

00:17:06,630 --> 00:17:11,670
it so here's the RGB structured bindings

00:17:09,270 --> 00:17:14,430
there's the RGB type there's the color

00:17:11,670 --> 00:17:17,910
decomposition and the change color okay

00:17:14,430 --> 00:17:21,050
and we're going to describe all of that

00:17:17,910 --> 00:17:21,050
in a single pattern

00:17:26,500 --> 00:17:34,370
okay all right so the key idea here in

00:17:32,510 --> 00:17:37,610
terms of pattern patterns and pattern

00:17:34,370 --> 00:17:40,160
matching the value that well okay we're

00:17:37,610 --> 00:17:42,320
gonna talk about values the benefit that

00:17:40,160 --> 00:17:44,450
you get from using patterns is that

00:17:42,320 --> 00:17:49,700
patterns and values are both built via

00:17:44,450 --> 00:17:52,340
composition so what I mean is we in C++

00:17:49,700 --> 00:17:55,220
or most of most other languages we build

00:17:52,340 --> 00:17:57,050
these values through composition so we

00:17:55,220 --> 00:17:58,670
may have some kind of integral we might

00:17:57,050 --> 00:18:01,010
put that into a pair we might put that

00:17:58,670 --> 00:18:02,750
into a struct we might put that on the

00:18:01,010 --> 00:18:05,720
other side of a pointer or whatever all

00:18:02,750 --> 00:18:08,270
these compose right and then right now

00:18:05,720 --> 00:18:10,130
what we're doing is we're working inside

00:18:08,270 --> 00:18:11,780
out while we build it and then when we

00:18:10,130 --> 00:18:15,230
inspect it we're working outside in

00:18:11,780 --> 00:18:17,780
and so because patterns allow you to

00:18:15,230 --> 00:18:20,180
build like partially build values inside

00:18:17,780 --> 00:18:22,100
out you end up building values inside

00:18:20,180 --> 00:18:24,920
out and then inspecting inside out again

00:18:22,100 --> 00:18:27,560
and so if you think about the cognitive

00:18:24,920 --> 00:18:29,270
load involved in doing those those

00:18:27,560 --> 00:18:30,650
operations in your head

00:18:29,270 --> 00:18:33,500
the analogy I'd like to make is that

00:18:30,650 --> 00:18:36,500
singing the alphabet song forwards twice

00:18:33,500 --> 00:18:41,060
is significantly easier than singing it

00:18:36,500 --> 00:18:45,500
forwards and then backwards okay and so

00:18:41,060 --> 00:18:48,380
I think that this will help you sleep

00:18:45,500 --> 00:18:50,530
better basically I would like to sleep

00:18:48,380 --> 00:18:55,910
better myself

00:18:50,530 --> 00:18:57,590
okay so I think we know roughly what

00:18:55,910 --> 00:18:59,720
pattern pattern matching is about and

00:18:57,590 --> 00:19:02,570
what patterns do let's get a little more

00:18:59,720 --> 00:19:05,000
specific here's the structure of the

00:19:02,570 --> 00:19:05,330
proposal that we actually have in the

00:19:05,000 --> 00:19:08,510
paper

00:19:05,330 --> 00:19:11,750
the first one is statement form and so

00:19:08,510 --> 00:19:15,410
if you ignore the optional components of

00:19:11,750 --> 00:19:16,070
this syntax we end up I'll give you an

00:19:15,410 --> 00:19:18,530
example in a minute

00:19:16,070 --> 00:19:20,720
but just to walk through it we have

00:19:18,530 --> 00:19:22,490
inspect we have the value that were

00:19:20,720 --> 00:19:23,840
inspecting we have a sequence of

00:19:22,490 --> 00:19:25,880
patterns corresponding with

00:19:23,840 --> 00:19:29,180
corresponding statements and each

00:19:25,880 --> 00:19:31,940
pattern has a matching semantics right

00:19:29,180 --> 00:19:33,590
and so if that pattern matches that it's

00:19:31,940 --> 00:19:35,570
going to execute the statement is

00:19:33,590 --> 00:19:37,580
corresponding to that pattern okay

00:19:35,570 --> 00:19:38,659
pretty straightforward and this is going

00:19:37,580 --> 00:19:42,859
to occur

00:19:38,659 --> 00:19:44,419
in a first match basis so here's a

00:19:42,859 --> 00:19:46,399
simple example the thing that we

00:19:44,419 --> 00:19:48,589
couldn't do with switch we matched some

00:19:46,399 --> 00:19:50,659
string we give it string literals and

00:19:48,589 --> 00:19:53,179
the first one that matches will execute

00:19:50,659 --> 00:19:55,159
the corresponding statement and note

00:19:53,179 --> 00:19:57,979
here that there's no break

00:19:55,159 --> 00:20:00,559
and so with pattern matching we don't

00:19:57,979 --> 00:20:03,789
have fall through z' and that'll be a

00:20:00,559 --> 00:20:03,789
good thing for everyone

00:20:03,999 --> 00:20:09,679
second one is an expression form now we

00:20:07,399 --> 00:20:12,259
can kind of get this by wrapping these

00:20:09,679 --> 00:20:14,869
statements in Atlanta but all of that

00:20:12,259 --> 00:20:17,690
gets very hairy and having an expression

00:20:14,869 --> 00:20:20,659
form would be would be would be very

00:20:17,690 --> 00:20:22,129
very useful for a lot of cases that

00:20:20,659 --> 00:20:24,559
we'll see later as well

00:20:22,129 --> 00:20:26,989
so how this works is you say inspect of

00:20:24,559 --> 00:20:28,369
some value optional trailing return type

00:20:26,989 --> 00:20:30,169
we'll look we'll look at why that might

00:20:28,369 --> 00:20:31,729
be why that might be needed

00:20:30,169 --> 00:20:34,009
we have patterns corresponding to

00:20:31,729 --> 00:20:36,889
expressions and the first pattern that

00:20:34,009 --> 00:20:38,690
matches will return basically produce

00:20:36,889 --> 00:20:41,269
the expression on the other of the

00:20:38,690 --> 00:20:44,719
right-hand side so here's a simple

00:20:41,269 --> 00:20:48,559
example we inspected on some x-axis and

00:20:44,719 --> 00:20:50,809
let's say and we produce these string as

00:20:48,559 --> 00:20:52,759
an expression right and then we can

00:20:50,809 --> 00:20:55,789
actually capture the result of this

00:20:52,759 --> 00:21:01,669
inspect because it's an expression form

00:20:55,789 --> 00:21:04,009
okay now if we change the types of the

00:21:01,669 --> 00:21:06,079
expressions then we have a problem right

00:21:04,009 --> 00:21:08,659
because is this is similar to having

00:21:06,079 --> 00:21:09,919
multiple returns in a lambda and so if

00:21:08,659 --> 00:21:11,899
you have multiple returns in a lambda

00:21:09,919 --> 00:21:14,929
that have and you have deduced return

00:21:11,899 --> 00:21:18,049
type and they don't match then your

00:21:14,929 --> 00:21:21,469
compiler will say try again right and so

00:21:18,049 --> 00:21:23,599
in those cases you actually need to

00:21:21,469 --> 00:21:25,309
specify a return type so that the the

00:21:23,599 --> 00:21:29,749
result can convert to it and so in this

00:21:25,309 --> 00:21:31,339
case the first 0 string literal will

00:21:29,749 --> 00:21:33,709
actually convert to a state string and

00:21:31,339 --> 00:21:36,679
the result of that whole expression will

00:21:33,709 --> 00:21:40,099
be a suit string I think that's pretty

00:21:36,679 --> 00:21:44,200
intuitive right now there's there was

00:21:40,099 --> 00:21:46,519
the there are these guard pieces here

00:21:44,200 --> 00:21:48,840
right which are a bit mysterious so

00:21:46,519 --> 00:21:53,139
let's look at that

00:21:48,840 --> 00:21:55,210
so here's a pattern guard I haven't

00:21:53,139 --> 00:21:56,980
quite introduced the structured bindings

00:21:55,210 --> 00:21:58,600
pattern but I think you kind of get what

00:21:56,980 --> 00:22:00,639
that would do based on how structure

00:21:58,600 --> 00:22:04,929
bindings work so we're gonna match some

00:22:00,639 --> 00:22:06,309
pair here oh no D we should be we should

00:22:04,929 --> 00:22:12,519
be inspecting something that's not

00:22:06,309 --> 00:22:15,909
called X this is a sorry so let's say

00:22:12,519 --> 00:22:18,730
we're matching some some some s I don't

00:22:15,909 --> 00:22:20,710
know and we're gonna unpack it into X&Y

00:22:18,730 --> 00:22:24,820
and if we wanted those two things to be

00:22:20,710 --> 00:22:27,010
the same then we can say if X equal Y on

00:22:24,820 --> 00:22:29,049
the right hand side there and so the

00:22:27,010 --> 00:22:32,860
semantics of this is if the pattern

00:22:29,049 --> 00:22:35,380
matches and the guard passes then the

00:22:32,860 --> 00:22:37,090
statement is executed if either of those

00:22:35,380 --> 00:22:40,769
fail then it will fall through to the

00:22:37,090 --> 00:22:40,769
next case okay

00:22:52,170 --> 00:22:57,420
yeah so the question is the terrible

00:22:55,530 --> 00:23:00,540
thing I did here is it actually allowed

00:22:57,420 --> 00:23:03,290
and would it work how would it work it

00:23:00,540 --> 00:23:06,120
would actually work as we expect in that

00:23:03,290 --> 00:23:08,850
like when we say X equal Y inside the if

00:23:06,120 --> 00:23:10,710
it would refer to the binding as opposed

00:23:08,850 --> 00:23:20,880
to the thing that we're matching so it

00:23:10,710 --> 00:23:23,760
does shadow properly but yeah okay now

00:23:20,880 --> 00:23:26,520
those are new things that are fancy and

00:23:23,760 --> 00:23:27,930
exciting to me at least now the other

00:23:26,520 --> 00:23:29,610
thing that we need to consider though is

00:23:27,930 --> 00:23:32,010
how all this fits into the rest of the

00:23:29,610 --> 00:23:34,560
language right and we want this whole

00:23:32,010 --> 00:23:36,540
feature to be cohesive and so we need to

00:23:34,560 --> 00:23:38,910
look at how this pattern matching stuff

00:23:36,540 --> 00:23:41,750
and patterns in general fit back into

00:23:38,910 --> 00:23:45,450
existing declaration forms and so

00:23:41,750 --> 00:23:47,310
can-can does this work and and if it

00:23:45,450 --> 00:23:49,290
does what does it mean we need to define

00:23:47,310 --> 00:23:53,220
all these things so what I'm going to

00:23:49,290 --> 00:23:57,920
say for now is that simply put we can

00:23:53,220 --> 00:24:01,560
put patterns that cannot fail here okay

00:23:57,920 --> 00:24:03,660
that's it you know it's okay okay let's

00:24:01,560 --> 00:24:07,650
go through the patterns now so overview

00:24:03,660 --> 00:24:11,130
of patterns so quick disclaimer here off

00:24:07,650 --> 00:24:12,540
obviously a no-no this is in the in the

00:24:11,130 --> 00:24:15,320
working draft or anything is targeted

00:24:12,540 --> 00:24:18,000
for C+ was 23 details subject to change

00:24:15,320 --> 00:24:19,560
but some of these have gotten pretty

00:24:18,000 --> 00:24:21,630
good feedback and so some of them some

00:24:19,560 --> 00:24:24,060
of them will stay around but you know

00:24:21,630 --> 00:24:26,310
don't be don't be too tied down to the

00:24:24,060 --> 00:24:30,090
syntax too much focus more on the

00:24:26,310 --> 00:24:32,010
semantics of where we're going so let's

00:24:30,090 --> 00:24:35,640
look at primary patterns the first one

00:24:32,010 --> 00:24:38,790
is the wildcard pattern this one was and

00:24:35,640 --> 00:24:40,350
is quite difficult because we really

00:24:38,790 --> 00:24:42,890
want this to be spelled single

00:24:40,350 --> 00:24:48,390
underscore but this is the working

00:24:42,890 --> 00:24:50,460
status of the wildcard so it's a double

00:24:48,390 --> 00:24:52,530
on the score you can repeat them I mean

00:24:50,460 --> 00:24:54,510
how many other times you like they don't

00:24:52,530 --> 00:24:56,430
actually introduce an identifier so you

00:24:54,510 --> 00:24:59,180
don't have multiple declaration issues

00:24:56,430 --> 00:25:02,100
or anything like that and if we were to

00:24:59,180 --> 00:25:03,900
write so if we were to port that back to

00:25:02,100 --> 00:25:05,100
the declaration form then we have what's

00:25:03,900 --> 00:25:07,530
on the right where we

00:25:05,100 --> 00:25:09,090
can you know ignore stuff in structured

00:25:07,530 --> 00:25:11,010
bindings and we can have lock guards

00:25:09,090 --> 00:25:18,480
that actually don't have arbitrary names

00:25:11,010 --> 00:25:19,980
and nice things except the name oh by

00:25:18,480 --> 00:25:22,020
the way if you have questions if you can

00:25:19,980 --> 00:25:26,370
go to the mic that would be helpful for

00:25:22,020 --> 00:25:28,020
me I would come back to it okay so let

00:25:26,370 --> 00:25:30,450
me cover one more in the office of the

00:25:28,020 --> 00:25:32,610
question so the next one is an

00:25:30,450 --> 00:25:34,740
identifier pattern where we just put

00:25:32,610 --> 00:25:37,590
another fire and it introduces a binding

00:25:34,740 --> 00:25:39,780
and so here we're matching on some value

00:25:37,590 --> 00:25:41,789
and we're giving a name X and they were

00:25:39,780 --> 00:25:44,070
gonna print it alright nothing exciting

00:25:41,789 --> 00:25:46,169
the exciting part actually more so is

00:25:44,070 --> 00:25:47,909
that like how this fits back into the

00:25:46,169 --> 00:25:50,940
declaration form it's right we can look

00:25:47,909 --> 00:25:52,740
at the auto x equal value as a

00:25:50,940 --> 00:25:54,780
declaration form of pattern matching

00:25:52,740 --> 00:26:01,950
where it's just an identifier pattern

00:25:54,780 --> 00:26:04,409
okay yep and the previous slide yep the

00:26:01,950 --> 00:26:05,940
wild-card since you're using a double

00:26:04,409 --> 00:26:08,039
underscore and considering a single

00:26:05,940 --> 00:26:10,350
underscore any reason you just wouldn't

00:26:08,039 --> 00:26:15,179
use a classic splat or asterisk for the

00:26:10,350 --> 00:26:18,450
wild-card asterisk yeah so imagine what

00:26:15,179 --> 00:26:22,350
would happen for this example where we

00:26:18,450 --> 00:26:25,289
say Auto star equals value is that a

00:26:22,350 --> 00:26:27,600
pointer is that a missing name what's

00:26:25,289 --> 00:26:29,970
going on right I think I think when you

00:26:27,600 --> 00:26:32,520
put things together in that context it

00:26:29,970 --> 00:26:34,080
gets especially in in a function

00:26:32,520 --> 00:26:35,669
parameter where you can actually omit

00:26:34,080 --> 00:26:37,789
the name if you say oh if you see Auto

00:26:35,669 --> 00:26:41,789
star that might be a pointer that

00:26:37,789 --> 00:26:47,760
probably that is a pointer so that's the

00:26:41,789 --> 00:26:50,039
problem okay I think we're right so next

00:26:47,760 --> 00:26:53,520
one is the expression pattern where we

00:26:50,039 --> 00:26:57,450
can put any constant expression into a

00:26:53,520 --> 00:26:59,760
pattern matching context and match

00:26:57,450 --> 00:27:02,460
against the value okay so the first

00:26:59,760 --> 00:27:04,710
example is matching some some integer

00:27:02,460 --> 00:27:09,470
again with zero and one very simple the

00:27:04,710 --> 00:27:13,860
second one is matching an enum with the

00:27:09,470 --> 00:27:17,820
corresponding unit values so this works

00:27:13,860 --> 00:27:20,929
for the most part except identifiers

00:27:17,820 --> 00:27:23,700
so this is the core of the difficulty in

00:27:20,929 --> 00:27:24,600
introducing pattern matching as far as I

00:27:23,700 --> 00:27:28,440
I can see it

00:27:24,600 --> 00:27:32,070
so why the issue is identifier and ID

00:27:28,440 --> 00:27:34,350
expression are the same thing so we need

00:27:32,070 --> 00:27:38,909
to figure out what we mean right when we

00:27:34,350 --> 00:27:40,379
see X is it introducing a new name or is

00:27:38,909 --> 00:27:43,799
that trying to refer to an existing

00:27:40,379 --> 00:27:45,629
variable so a concrete example of this

00:27:43,799 --> 00:27:48,299
would be there's some static concepts

00:27:45,629 --> 00:27:51,330
for int X and I say match this value

00:27:48,299 --> 00:27:55,139
with X what does that mean what does

00:27:51,330 --> 00:27:59,970
this mean this is going to match or not

00:27:55,139 --> 00:28:04,289
basically right so this is the core of

00:27:59,970 --> 00:28:07,470
the problem so what we're proposing is

00:28:04,289 --> 00:28:09,059
for us to have two modes one called bind

00:28:07,470 --> 00:28:11,220
mode and the other one called

00:28:09,059 --> 00:28:13,049
expert mode and so the meaning of those

00:28:11,220 --> 00:28:14,869
things would be that in bind mode

00:28:13,049 --> 00:28:17,909
identifiers are interpreted as

00:28:14,869 --> 00:28:20,489
identifier patterns and in expert mode

00:28:17,909 --> 00:28:24,029
identifiers are interpreted as ID

00:28:20,489 --> 00:28:27,269
expressions so you can see on the left

00:28:24,029 --> 00:28:29,099
hand side we say bind X for example and

00:28:27,269 --> 00:28:33,149
that would introduce a new variable X on

00:28:29,099 --> 00:28:35,460
the right we have the same enum example

00:28:33,149 --> 00:28:36,659
except we say expert of sorry not the

00:28:35,460 --> 00:28:38,659
same thing though in an example this is

00:28:36,659 --> 00:28:43,499
a different one because it's not scoped

00:28:38,659 --> 00:28:46,259
so before before this was not a problem

00:28:43,499 --> 00:28:49,399
because color : called red is not an

00:28:46,259 --> 00:28:52,369
identifier right so we get away with it

00:28:49,399 --> 00:28:55,859
however if we have an unskilled enum

00:28:52,369 --> 00:28:57,359
then now it's an identifier and so we

00:28:55,859 --> 00:28:59,129
need to figure out what it means how do

00:28:57,359 --> 00:29:00,960
we make it refer to the values of the

00:28:59,129 --> 00:29:03,929
you know and so in this case we're

00:29:00,960 --> 00:29:07,830
saying expert of the identifiers refer

00:29:03,929 --> 00:29:10,259
to those values okay so here's an

00:29:07,830 --> 00:29:12,419
observation look at existing

00:29:10,259 --> 00:29:14,729
declarations right is there some

00:29:12,419 --> 00:29:16,200
declarations like variable declarations

00:29:14,729 --> 00:29:20,729
and structured binding declarations are

00:29:16,200 --> 00:29:22,710
by default the identifiers the

00:29:20,729 --> 00:29:24,720
identifiers iron should get introduced

00:29:22,710 --> 00:29:27,349
in those patterns or by default identify

00:29:24,720 --> 00:29:30,019
patterns right they introduce new names

00:29:27,349 --> 00:29:31,350
whereas if we look at the switch example

00:29:30,019 --> 00:29:34,470
identifiers

00:29:31,350 --> 00:29:37,800
by default ID expressions right so

00:29:34,470 --> 00:29:40,290
there's this existing world that way you

00:29:37,800 --> 00:29:44,010
want to try to be cohesive with so

00:29:40,290 --> 00:29:49,050
here's the idea we rename find pattern

00:29:44,010 --> 00:29:54,450
to bat bind mode with let pattern and we

00:29:49,050 --> 00:29:56,520
rename expert to case so on the left and

00:29:54,450 --> 00:29:58,320
the top-level is a is implicit and so

00:29:56,520 --> 00:30:00,240
that's how we get away with Auto ex and

00:29:58,320 --> 00:30:01,800
Auto structured bindings to be

00:30:00,240 --> 00:30:03,240
identifiers by default because it's led

00:30:01,800 --> 00:30:05,910
by default okay

00:30:03,240 --> 00:30:08,010
and so here we're saying let X where X

00:30:05,910 --> 00:30:10,200
introduces a new name and on the right

00:30:08,010 --> 00:30:11,880
we say case of some pattern where

00:30:10,200 --> 00:30:13,980
pattern in this case is an identifier

00:30:11,880 --> 00:30:16,740
and that's kind of that's going to be

00:30:13,980 --> 00:30:26,160
ancient going to be interpreted as an ID

00:30:16,740 --> 00:30:29,040
expression people see you there okay so

00:30:26,160 --> 00:30:31,010
if you put them together then we end up

00:30:29,040 --> 00:30:34,500
with something like this so we have

00:30:31,010 --> 00:30:36,900
constants 0 and 1 and we have a you know

00:30:34,500 --> 00:30:39,420
arbitrary like kind of a naive example

00:30:36,900 --> 00:30:45,000
of a pair of int and pair of intent and

00:30:39,420 --> 00:30:48,570
we can say case of 0 let X Y and so

00:30:45,000 --> 00:30:51,150
these things can nest and the you know

00:30:48,570 --> 00:30:53,370
the the most recent ancestor basically

00:30:51,150 --> 00:30:56,160
wins it basically sets the context and

00:30:53,370 --> 00:30:59,850
so 0 here would be the ID expression

00:30:56,160 --> 00:31:01,880
that refers to the the constant and X

00:30:59,850 --> 00:31:08,750
and Y's that are inside let would be

00:31:01,880 --> 00:31:08,750
introduced new variables yeah

00:31:10,730 --> 00:31:18,360
why don't you want why don't you want to

00:31:13,170 --> 00:31:21,030
mention the P and in the in each

00:31:18,360 --> 00:31:22,590
production what Daniel then you know

00:31:21,030 --> 00:31:27,060
that would sort of disambiguate this

00:31:22,590 --> 00:31:31,500
problem I didn't understand why don't we

00:31:27,060 --> 00:31:35,180
repeat the P well if you use P here you

00:31:31,500 --> 00:31:38,550
can say keep byte where do you buy here

00:31:35,180 --> 00:31:43,260
well in the first case for example in

00:31:38,550 --> 00:31:43,560
the first case instead of right what do

00:31:43,260 --> 00:31:47,550
you mean

00:31:43,560 --> 00:31:49,730
P where P if the P is used in the K in

00:31:47,550 --> 00:31:52,650
the statement and the case statement

00:31:49,730 --> 00:31:56,210
then okay I can tell whether which you

00:31:52,650 --> 00:32:03,780
mean whether you mean a value or extract

00:31:56,210 --> 00:32:07,320
something yeah P dot first X Y you know

00:32:03,780 --> 00:32:09,510
oh oh oh oh you're asking why we can't

00:32:07,320 --> 00:32:11,460
why we went just like access to value so

00:32:09,510 --> 00:32:13,800
that they don't they end up not becoming

00:32:11,460 --> 00:32:15,810
identifiers is that what you mean you

00:32:13,800 --> 00:32:18,380
could still have a new identifier x' but

00:32:15,810 --> 00:32:20,760
if you if you use p and in this example

00:32:18,380 --> 00:32:23,670
yeah then you me on the right hand side

00:32:20,760 --> 00:32:26,310
if we just use P dot X and stuff yeah

00:32:23,670 --> 00:32:29,070
yeah so this is yeah this is simple

00:32:26,310 --> 00:32:30,780
example but once you get more more

00:32:29,070 --> 00:32:32,640
nesting into your patterns and stuff you

00:32:30,780 --> 00:32:36,030
you won't necessarily have access to

00:32:32,640 --> 00:32:37,530
that as simply as in this example so in

00:32:36,030 --> 00:32:39,540
this example it's just one level down

00:32:37,530 --> 00:32:42,750
but you might be somewhere deeper the

00:32:39,540 --> 00:32:44,730
pattern and then you could rather than

00:32:42,750 --> 00:32:46,650
like if you didn't find names when

00:32:44,730 --> 00:32:48,150
you're deep in a pattern you would have

00:32:46,650 --> 00:32:51,300
to get get the value on the right hand

00:32:48,150 --> 00:32:54,380
side and like access all the way down in

00:32:51,300 --> 00:32:54,380
order to get those pieces out

00:32:59,020 --> 00:33:08,050
oh right okay yeah yeah yeah thank you

00:33:05,559 --> 00:33:11,500
so Richards comment was that if you

00:33:08,050 --> 00:33:15,520
didn't actually save P and put the put

00:33:11,500 --> 00:33:18,550
the right here if this expression the

00:33:15,520 --> 00:33:19,720
dash went directly into the inspect then

00:33:18,550 --> 00:33:21,490
you wouldn't necessarily have a name to

00:33:19,720 --> 00:33:22,950
refer to on the right hand side so yeah

00:33:21,490 --> 00:33:26,380
thank you for that that's that's helpful

00:33:22,950 --> 00:33:30,340
okay let's keep going

00:33:26,380 --> 00:33:31,570
compounds compounds hands so I don't

00:33:30,340 --> 00:33:36,900
think I need to explain much here but I

00:33:31,570 --> 00:33:39,850
will show it to for Plus posterity so

00:33:36,900 --> 00:33:43,630
basically it's structured bindings as

00:33:39,850 --> 00:33:45,820
you know today put into a pattern not

00:33:43,630 --> 00:33:47,770
much going on except that it aside those

00:33:45,820 --> 00:33:49,809
patterns inside those square brackets

00:33:47,770 --> 00:33:51,730
you can put patterns right so today you

00:33:49,809 --> 00:33:54,160
can only put identifiers in there but

00:33:51,730 --> 00:33:56,800
ideal you'd be able to put patterns in

00:33:54,160 --> 00:33:58,600
their arbitrary patterns in there and

00:33:56,800 --> 00:34:00,700
the semantics are just that it matches

00:33:58,600 --> 00:34:02,500
it's it's consistent with structured

00:34:00,700 --> 00:34:06,270
bindings so I don't really want to go

00:34:02,500 --> 00:34:10,899
into explaining that part just yet okay

00:34:06,270 --> 00:34:13,659
the next part is new so this is using

00:34:10,899 --> 00:34:16,210
designated mesh initializer syntax but

00:34:13,659 --> 00:34:19,510
on the other side and so rather than

00:34:16,210 --> 00:34:20,830
being forced to give names to every part

00:34:19,510 --> 00:34:23,830
of the struct or tuple that you're

00:34:20,830 --> 00:34:25,480
unpacking you can actually in the in the

00:34:23,830 --> 00:34:27,700
case of a struct you can actually pick

00:34:25,480 --> 00:34:30,369
pick and choose the components that you

00:34:27,700 --> 00:34:32,169
want and leave the rest out right so in

00:34:30,369 --> 00:34:36,070
this example we have this player class

00:34:32,169 --> 00:34:38,590
with hit points and coins and the first

00:34:36,070 --> 00:34:40,960
pattern for example just cares if the

00:34:38,590 --> 00:34:45,190
hit points value hit points field is 1

00:34:40,960 --> 00:34:46,570
and doesn't care what coins is ok and I

00:34:45,190 --> 00:34:48,840
think the rest of it is pretty

00:34:46,570 --> 00:34:48,840
self-explanatory

00:34:49,590 --> 00:34:55,919
but this but this is very useful and I

00:34:52,419 --> 00:34:58,840
think it's very consistent with how

00:34:55,919 --> 00:35:00,850
structured sorry designated initializer

00:34:58,840 --> 00:35:03,250
construction works today so that's

00:35:00,850 --> 00:35:06,010
pretty cool ok let's move forward

00:35:03,250 --> 00:35:08,020
alternative pattern I mentioned one of

00:35:06,010 --> 00:35:10,630
the motivations was to improve state and

00:35:08,020 --> 00:35:12,260
so the example here is that we have a

00:35:10,630 --> 00:35:15,290
variant of int float

00:35:12,260 --> 00:35:17,510
this is what you would write to inspect

00:35:15,290 --> 00:35:23,570
the components inspect the alternatives

00:35:17,510 --> 00:35:26,210
rather okay now it's important to note

00:35:23,570 --> 00:35:26,570
that this works the way this actually

00:35:26,210 --> 00:35:30,070
works

00:35:26,570 --> 00:35:32,630
is very similar to state visit and so

00:35:30,070 --> 00:35:36,230
this is this slide is here just to show

00:35:32,630 --> 00:35:37,660
you that we're not calling get if all

00:35:36,230 --> 00:35:41,780
right because if we were to do that then

00:35:37,660 --> 00:35:43,369
calling get if int on this B or this

00:35:41,780 --> 00:35:44,990
variant here would be a compiler error

00:35:43,369 --> 00:35:47,660
because it's ambiguous which one we're

00:35:44,990 --> 00:35:50,570
talking about and so likes to visit

00:35:47,660 --> 00:35:52,670
where you can pass a visitor with an int

00:35:50,570 --> 00:35:57,890
handler and both of those alternatives

00:35:52,670 --> 00:36:00,080
would invoke the same handler same thing

00:35:57,890 --> 00:36:01,520
happens here both it's even though

00:36:00,080 --> 00:36:04,190
they're different will actually be

00:36:01,520 --> 00:36:06,710
handled by the same handler what if we

00:36:04,190 --> 00:36:08,540
want to separate them well we can

00:36:06,710 --> 00:36:11,510
actually specify a constant expression

00:36:08,540 --> 00:36:14,590
in there too and in this case we would

00:36:11,510 --> 00:36:17,450
actually just match for the V dot index

00:36:14,590 --> 00:36:19,220
right and we would dispatch to the

00:36:17,450 --> 00:36:22,670
correct handler corresponding to the V

00:36:19,220 --> 00:36:25,930
dot index basically like a switch right

00:36:22,670 --> 00:36:28,130
but we actually do the matching and the

00:36:25,930 --> 00:36:33,890
grabbing of the value and the unpacking

00:36:28,130 --> 00:36:35,570
for you basically okay and going forward

00:36:33,890 --> 00:36:37,190
with with this visit example you can

00:36:35,570 --> 00:36:39,800
also put Auto in here which would mean

00:36:37,190 --> 00:36:41,630
that you match anything and so this is

00:36:39,800 --> 00:36:43,820
kind of a contrived example but you can

00:36:41,630 --> 00:36:50,210
have other cases above this Auto and

00:36:43,820 --> 00:36:52,670
have this Auto be the default okay the

00:36:50,210 --> 00:36:54,980
next one is to allow putting a concept

00:36:52,670 --> 00:36:57,440
in there and so in this case we would

00:36:54,980 --> 00:37:00,260
have this bull char int float in the

00:36:57,440 --> 00:37:01,700
string and if you put integral concept

00:37:00,260 --> 00:37:04,580
into one of the cases then you would

00:37:01,700 --> 00:37:09,410
handle rural char and float and the auto

00:37:04,580 --> 00:37:10,820
would handle the string case the

00:37:09,410 --> 00:37:14,540
alternative pattern actually extends

00:37:10,820 --> 00:37:17,710
much further we have an any like support

00:37:14,540 --> 00:37:22,310
where this would call this this would

00:37:17,710 --> 00:37:23,330
subsequently call any test on the a and

00:37:22,310 --> 00:37:25,250
it would have it would bind to the

00:37:23,330 --> 00:37:26,990
correct handler

00:37:25,250 --> 00:37:28,849
but this one but this one doesn't

00:37:26,990 --> 00:37:29,930
support Auto and concepts and stuff

00:37:28,849 --> 00:37:35,030
because we don't have that much

00:37:29,930 --> 00:37:39,340
information for that now lastly but not

00:37:35,030 --> 00:37:41,330
least polymorphic types the the get area

00:37:39,340 --> 00:37:45,500
example that I had earlier with the

00:37:41,330 --> 00:37:48,109
if-else can actually be improved to be

00:37:45,500 --> 00:37:50,210
written like this so this is the first

00:37:48,109 --> 00:37:52,280
instance of the expression pattern that

00:37:50,210 --> 00:37:54,830
I've shown here where you would inspect

00:37:52,280 --> 00:37:57,200
the shape the two cases get the pieces

00:37:54,830 --> 00:37:58,730
out and then you just write the

00:37:57,200 --> 00:38:05,480
expression and that you return the

00:37:58,730 --> 00:38:11,480
entire thing and what happens if you put

00:38:05,480 --> 00:38:15,950
shape in there as a type puts shape in

00:38:11,480 --> 00:38:18,770
there as a type yes oh okay I'm going to

00:38:15,950 --> 00:38:22,730
defer that question to what happens if

00:38:18,770 --> 00:38:24,440
you dynamic cast a shape to a shape the

00:38:22,730 --> 00:38:29,570
answer to that will be the answer to

00:38:24,440 --> 00:38:35,089
your question I don't remember what the

00:38:29,570 --> 00:38:38,830
answer is for that yeah I really don't

00:38:35,089 --> 00:38:41,180
remember sorry okay let's move forward

00:38:38,830 --> 00:38:43,910
the next one I want to share with you is

00:38:41,180 --> 00:38:46,880
the reference pattern so the syntax is

00:38:43,910 --> 00:38:50,570
star bang or star question mark and what

00:38:46,880 --> 00:38:52,760
this means is we're going to so the star

00:38:50,570 --> 00:38:54,770
bang is called the unchecked the

00:38:52,760 --> 00:38:56,240
reference pattern and the star question

00:38:54,770 --> 00:38:59,780
mark is called to check the reference

00:38:56,240 --> 00:39:03,859
pattern and so it's going to dereference

00:38:59,780 --> 00:39:05,960
the value that we're matching in the

00:39:03,859 --> 00:39:07,369
case of the unchecked and in the case of

00:39:05,960 --> 00:39:09,520
the checked version we're going to check

00:39:07,369 --> 00:39:11,540
that the value that were matching is

00:39:09,520 --> 00:39:14,390
convertible to pool and then the

00:39:11,540 --> 00:39:16,849
reference the value okay so let me let

00:39:14,390 --> 00:39:19,820
me give you an example here so here's a

00:39:16,849 --> 00:39:23,450
fancy ranges min max element where you

00:39:19,820 --> 00:39:25,280
can just pass it V and we get out these

00:39:23,450 --> 00:39:27,859
two iterators write these two iterators

00:39:25,280 --> 00:39:30,980
point to the min element and the max

00:39:27,859 --> 00:39:32,839
element so after we get the iterators

00:39:30,980 --> 00:39:36,349
out and we need to dereference them to

00:39:32,839 --> 00:39:39,120
print the values again this is a similar

00:39:36,349 --> 00:39:41,400
example but we can put the

00:39:39,120 --> 00:39:43,580
start banging in front of the

00:39:41,400 --> 00:39:45,750
identifiers which will dear

00:39:43,580 --> 00:39:48,060
unconditionally dereference the iterator

00:39:45,750 --> 00:39:50,400
and match the result of the V reference

00:39:48,060 --> 00:39:52,260
with with the with the pattern on the

00:39:50,400 --> 00:39:54,090
right in this case the pattern on the

00:39:52,260 --> 00:39:56,910
right is just another fire and so we're

00:39:54,090 --> 00:39:58,470
going to give be able to call them min

00:39:56,910 --> 00:40:00,060
and Max as AB rather than being able to

00:39:58,470 --> 00:40:05,040
call rather than having to call them

00:40:00,060 --> 00:40:06,600
back Minotaur and Max sitter so save

00:40:05,040 --> 00:40:10,680
some characters maybe in the cases where

00:40:06,600 --> 00:40:12,180
you you know have to do star up a whole

00:40:10,680 --> 00:40:13,740
bunch after you actually do the

00:40:12,180 --> 00:40:18,300
destruction bindings maybe it'll be

00:40:13,740 --> 00:40:20,970
helpful but let's keep going so suppose

00:40:18,300 --> 00:40:22,710
we have an employee class with ID and

00:40:20,970 --> 00:40:25,110
name and we have a vector of those and

00:40:22,710 --> 00:40:30,450
we want to call main max element on it

00:40:25,110 --> 00:40:33,930
and we use ranges projection to to

00:40:30,450 --> 00:40:37,860
compare them based on their IDs okay and

00:40:33,930 --> 00:40:40,320
we're going to get the main minimum

00:40:37,860 --> 00:40:43,200
employee by ID and Mac the maximum

00:40:40,320 --> 00:40:45,900
employee by ID right and so we can do

00:40:43,200 --> 00:40:48,210
star bang and as I said because it's a

00:40:45,900 --> 00:40:50,790
pattern on the right you can you can put

00:40:48,210 --> 00:40:52,620
more complex patterns there so we're

00:40:50,790 --> 00:40:54,720
going to dereference the minitor that we

00:40:52,620 --> 00:40:57,900
had before which which will be an

00:40:54,720 --> 00:40:59,610
employee then we will use the structured

00:40:57,900 --> 00:41:02,760
bindings with designated initializer

00:40:59,610 --> 00:41:05,580
syntax to unpack that employee and given

00:41:02,760 --> 00:41:08,040
give a good name to the name portion of

00:41:05,580 --> 00:41:13,310
that employee and I don't care about the

00:41:08,040 --> 00:41:13,310
ID because we already did that operation

00:41:16,990 --> 00:41:24,190
okay I like this example let's so that's

00:41:21,970 --> 00:41:26,980
these this is an example of the star

00:41:24,190 --> 00:41:29,349
Bank pattern let's look at what star

00:41:26,980 --> 00:41:34,810
star questionmark looks like so suppose

00:41:29,349 --> 00:41:36,730
you have a simple signal a linked list

00:41:34,810 --> 00:41:39,730
and you have a node of the value and the

00:41:36,730 --> 00:41:42,130
next pointer and we write a six really

00:41:39,730 --> 00:41:44,290
silly function here called starts with

00:41:42,130 --> 00:41:47,430
two zeros we're gonna inspect that node

00:41:44,290 --> 00:41:51,670
we're checking that the value is zero

00:41:47,430 --> 00:41:55,180
we're going to conditionally dereference

00:41:51,670 --> 00:41:57,339
the next pointer right so if the next

00:41:55,180 --> 00:41:59,980
pointer is null then this pattern won't

00:41:57,339 --> 00:42:02,530
match at all if the next pointer is set

00:41:59,980 --> 00:42:07,089
then we will dereference the pointer and

00:42:02,530 --> 00:42:09,430
use the pattern value zero two to match

00:42:07,089 --> 00:42:13,510
the to match the next node basically and

00:42:09,430 --> 00:42:16,480
so with this pattern we're checking do

00:42:13,510 --> 00:42:18,849
we have a zero and does the next do we

00:42:16,480 --> 00:42:22,510
have a zero does the next node exist and

00:42:18,849 --> 00:42:23,589
if it exists doesn't have zero and I

00:42:22,510 --> 00:42:26,890
don't really care what happens after

00:42:23,589 --> 00:42:28,720
that so this is how you would check this

00:42:26,890 --> 00:42:32,440
is one way to check whether your legs

00:42:28,720 --> 00:42:36,790
list starts with two zeros and the magic

00:42:32,440 --> 00:42:39,580
happens there right and so note that if

00:42:36,790 --> 00:42:40,930
this was a star bang and and you were

00:42:39,580 --> 00:42:42,430
the end of the list then you would be a

00:42:40,930 --> 00:42:45,130
newbie led all right because you would

00:42:42,430 --> 00:42:52,770
are conditionally dereference the

00:42:45,130 --> 00:42:57,820
pointer okay this brings us to the last

00:42:52,770 --> 00:43:00,490
piece that I have the extractor pattern

00:42:57,820 --> 00:43:03,910
this is a bit complicated so I'm going

00:43:00,490 --> 00:43:06,070
to take my time it looks kind of similar

00:43:03,910 --> 00:43:08,290
to the reference pattern and it has

00:43:06,070 --> 00:43:11,010
similar semantics but this is a way to

00:43:08,290 --> 00:43:13,330
give you customization points and

00:43:11,010 --> 00:43:17,170
customization points for introducing

00:43:13,330 --> 00:43:19,690
your own patterns so the first form is

00:43:17,170 --> 00:43:21,369
constant expression bang pattern the

00:43:19,690 --> 00:43:23,410
second one is past expression question

00:43:21,369 --> 00:43:25,510
mark pattern so similar to dereference

00:43:23,410 --> 00:43:30,690
as we just talked about it's going to be

00:43:25,510 --> 00:43:33,330
unchecked and checked the

00:43:30,690 --> 00:43:37,400
the unchecked version matches value if

00:43:33,330 --> 00:43:40,470
we call extractor dot extract value and

00:43:37,400 --> 00:43:44,370
the pattern that were given matches that

00:43:40,470 --> 00:43:46,320
result right and so in the D reference

00:43:44,370 --> 00:43:50,130
example the extract operation was the

00:43:46,320 --> 00:43:53,130
dereference operation okay and in the

00:43:50,130 --> 00:43:56,130
the checked version we do a similar

00:43:53,130 --> 00:43:57,270
thing except we call try extract the

00:43:56,130 --> 00:43:59,220
thing that comes out we're going to

00:43:57,270 --> 00:44:02,940
check whether that is implicitly

00:43:59,220 --> 00:44:05,570
convertible to pool and that the the

00:44:02,940 --> 00:44:08,400
referencing of that matches the pattern

00:44:05,570 --> 00:44:12,480
so coming back to the reference example

00:44:08,400 --> 00:44:14,340
the try extract would return something

00:44:12,480 --> 00:44:16,140
like a pointer or an optional or

00:44:14,340 --> 00:44:18,210
something like that that thing will be

00:44:16,140 --> 00:44:19,590
compulsively convertible to pool and the

00:44:18,210 --> 00:44:24,180
pattern movie matches the case that the

00:44:19,590 --> 00:44:25,710
reference of that of that result so this

00:44:24,180 --> 00:44:29,510
is a bit hard it's hard to see but let's

00:44:25,710 --> 00:44:33,360
let's take a look at a concrete example

00:44:29,510 --> 00:44:37,490
so compile-time regular expressions is a

00:44:33,360 --> 00:44:42,210
library by hana who gave a keynote

00:44:37,490 --> 00:44:43,890
recently at c++ now and this this was

00:44:42,210 --> 00:44:45,330
this is a compelling example so this is

00:44:43,890 --> 00:44:47,130
how pattern matching and regular

00:44:45,330 --> 00:44:49,980
expressions come together and stuff so

00:44:47,130 --> 00:44:52,740
let's take a look at at this example so

00:44:49,980 --> 00:44:55,770
GT re if you haven't seen it this is a

00:44:52,740 --> 00:44:58,350
basic basic intro example this is I took

00:44:55,770 --> 00:45:00,840
this out of Honus keynote so I'm pretty

00:44:58,350 --> 00:45:02,760
sure it's correct so there's an we

00:45:00,840 --> 00:45:05,040
happen is is a date function that takes

00:45:02,760 --> 00:45:09,930
a string view we're saying see tre match

00:45:05,040 --> 00:45:12,360
of the compile time string and we're

00:45:09,930 --> 00:45:15,120
checking that the input conforms whether

00:45:12,360 --> 00:45:16,710
that matches the regex and the result of

00:45:15,120 --> 00:45:18,750
that is going to be some object that is

00:45:16,710 --> 00:45:20,240
convertible to pool and the bool tells

00:45:18,750 --> 00:45:22,440
you whether there was a match or not

00:45:20,240 --> 00:45:25,260
there are a lot more more things you can

00:45:22,440 --> 00:45:29,040
do with it though the first thing to

00:45:25,260 --> 00:45:31,800
note is that C tre match is actually an

00:45:29,040 --> 00:45:34,700
object it's not a function and so you

00:45:31,800 --> 00:45:37,920
can actually store it so CTR a match of

00:45:34,700 --> 00:45:40,680
the digits letters followed by digits

00:45:37,920 --> 00:45:43,740
example can be saved into a regex

00:45:40,680 --> 00:45:44,460
pattern called ID and then you can

00:45:43,740 --> 00:45:47,279
actually call

00:45:44,460 --> 00:45:50,069
idea try extract on the input and you

00:45:47,279 --> 00:45:52,319
get a result right now that result is

00:45:50,069 --> 00:45:54,450
implicitly implicitly convertible to

00:45:52,319 --> 00:45:57,420
pool which which tells you whether they

00:45:54,450 --> 00:46:01,319
it actually matched or not and if you

00:45:57,420 --> 00:46:02,910
dereference it then you can unpack the

00:46:01,319 --> 00:46:05,069
results into with structured bindings

00:46:02,910 --> 00:46:08,460
and so in this example the first piece

00:46:05,069 --> 00:46:09,779
is going to be the full match and the

00:46:08,460 --> 00:46:11,099
second piece is going to be the digits

00:46:09,779 --> 00:46:16,319
portion that we captured with

00:46:11,099 --> 00:46:18,329
parentheses in the regex okay so how

00:46:16,319 --> 00:46:21,569
does this fit with what we were looking

00:46:18,329 --> 00:46:23,750
at we have a question mark pattern right

00:46:21,569 --> 00:46:28,619
this was the checked extractor pattern

00:46:23,750 --> 00:46:33,990
matches value if I deduct I try extract

00:46:28,619 --> 00:46:35,760
input equals x and X is includes the

00:46:33,990 --> 00:46:39,900
convertible to pool and the pattern

00:46:35,760 --> 00:46:41,670
matches star X okay so let me go back so

00:46:39,900 --> 00:46:45,230
this was the this was the condition I'm

00:46:41,670 --> 00:46:51,150
gonna replace e with ID and X with

00:46:45,230 --> 00:46:53,309
result basically right and and and the

00:46:51,150 --> 00:46:56,720
corresponding patterns and so what this

00:46:53,309 --> 00:46:59,190
means is that CT re match is actually a

00:46:56,720 --> 00:47:00,900
extractor pattern that we can use all

00:46:59,190 --> 00:47:01,230
right sorry an extractor that we can use

00:47:00,900 --> 00:47:05,700
today

00:47:01,230 --> 00:47:08,220
if the feature existed but it I mean in

00:47:05,700 --> 00:47:09,599
the current specification so this is

00:47:08,220 --> 00:47:12,990
what this is what you can do right you

00:47:09,599 --> 00:47:15,150
can save the CTR a match object and then

00:47:12,990 --> 00:47:20,069
you can you can put it into an inspect

00:47:15,150 --> 00:47:22,799
as as an extractor pattern and you can

00:47:20,069 --> 00:47:26,819
say ID question mark if the string that

00:47:22,799 --> 00:47:28,619
you have is an ID then it will unpack

00:47:26,819 --> 00:47:30,809
the pieces and you have access to those

00:47:28,619 --> 00:47:35,400
pieces think the captures from your reg

00:47:30,809 --> 00:47:36,809
X if you pass it a date and then if it

00:47:35,400 --> 00:47:38,910
if the string that you have is a date

00:47:36,809 --> 00:47:44,690
then it will match and give you the

00:47:38,910 --> 00:47:47,339
portions that you captured and so

00:47:44,690 --> 00:47:51,359
extractors are very powerful it gives

00:47:47,339 --> 00:47:55,289
you basically full control over patterns

00:47:51,359 --> 00:47:57,839
introducing new patterns and so this is

00:47:55,289 --> 00:48:02,400
a this an example of how that

00:47:57,839 --> 00:48:06,059
how that might come to fruition okay so

00:48:02,400 --> 00:48:07,859
hopefully I've helped you understand the

00:48:06,059 --> 00:48:09,359
value the benefits of pattern matching

00:48:07,859 --> 00:48:12,449
and how it works

00:48:09,359 --> 00:48:14,910
what it's about how they come together

00:48:12,449 --> 00:48:21,049
and how it fits into the existing

00:48:14,910 --> 00:48:21,049
language and I hope that it was helpful

00:48:28,880 --> 00:48:33,329
hello hi how's it going

00:48:31,259 --> 00:48:34,859
good talk thank you um I have just a

00:48:33,329 --> 00:48:36,809
couple questions about syntax okay um

00:48:34,859 --> 00:48:38,400
first of all I love this idea I have a

00:48:36,809 --> 00:48:42,209
lot of pattern matching ever since I

00:48:38,400 --> 00:48:44,400
first saw it yeah okay well so the

00:48:42,209 --> 00:48:45,839
feature is called matching and the key

00:48:44,400 --> 00:48:48,239
word is matched in other languages I've

00:48:45,839 --> 00:48:49,469
seen so I'm curious why you guys chose

00:48:48,239 --> 00:48:51,209
inspect was that just to avoid

00:48:49,469 --> 00:48:54,779
collisions with code that already saved

00:48:51,209 --> 00:48:59,609
match yeah so in the seraphs community

00:48:54,779 --> 00:49:01,769
we have a code repository and code

00:48:59,609 --> 00:49:08,309
search that we do to see how many times

00:49:01,769 --> 00:49:10,549
an identifier is used match is like way

00:49:08,309 --> 00:49:12,719
beyond what the committee would consider

00:49:10,549 --> 00:49:15,029
and so that was that was the issue

00:49:12,719 --> 00:49:18,359
inspect I think is still in the in the

00:49:15,029 --> 00:49:19,799
in the acceptable range but there's even

00:49:18,359 --> 00:49:21,630
with that there's discussions of like

00:49:19,799 --> 00:49:24,150
can we just make it a switch and all

00:49:21,630 --> 00:49:27,979
that kind of stuff so yeah that's the

00:49:24,150 --> 00:49:30,539
reason hello hi great proposal um I just

00:49:27,979 --> 00:49:34,979
wondered whether you also support

00:49:30,539 --> 00:49:39,209
pattern matching over types I'm like in

00:49:34,979 --> 00:49:41,640
a very in a knitter it soon takes like

00:49:39,209 --> 00:49:45,179
you mean in the case of matching

00:49:41,640 --> 00:49:48,869
variants no like actually matching just

00:49:45,179 --> 00:49:51,839
over any type and then doing yes oh oh

00:49:48,869 --> 00:49:55,049
you mean like inspect some tea and then

00:49:51,839 --> 00:49:55,979
exactly yeah yeah okay so we don't have

00:49:55,049 --> 00:50:00,269
that

00:49:55,979 --> 00:50:02,459
currently the there are there are ideas

00:50:00,269 --> 00:50:04,289
and ways I think we can do that but we

00:50:02,459 --> 00:50:06,839
don't we don't support that in the paper

00:50:04,289 --> 00:50:09,029
today yeah hello

00:50:06,839 --> 00:50:10,709
so stood visit code Jen makes me very

00:50:09,029 --> 00:50:11,400
very sad how much better do you think

00:50:10,709 --> 00:50:16,490
this will be

00:50:11,400 --> 00:50:21,150
I I don't know I don't know I think I

00:50:16,490 --> 00:50:26,099
think we could do better but part of the

00:50:21,150 --> 00:50:28,589
issue with visit is that variant is

00:50:26,099 --> 00:50:32,369
required to support scholars expert and

00:50:28,589 --> 00:50:35,700
so I'm not sure that like I'm not sure

00:50:32,369 --> 00:50:38,789
how much visit can actually help because

00:50:35,700 --> 00:50:41,269
I worked with like I've I've I've

00:50:38,789 --> 00:50:44,519
published blog post on how to improve on

00:50:41,269 --> 00:50:46,170
performance of visit and I keep running

00:50:44,519 --> 00:50:49,859
into issues with context for support for

00:50:46,170 --> 00:50:53,849
variants so you may have to wait for

00:50:49,859 --> 00:50:56,339
language variant for that okay so I'm

00:50:53,849 --> 00:50:59,490
gonna harp on syntax a little bit I

00:50:56,339 --> 00:51:03,930
understand the problem of identifiers

00:50:59,490 --> 00:51:06,599
versus ID expression okay but I feel

00:51:03,930 --> 00:51:11,910
like you know having to put let in case

00:51:06,599 --> 00:51:14,460
is pretty noisy okay could we default to

00:51:11,910 --> 00:51:16,950
one of those so you yeah are you

00:51:14,460 --> 00:51:19,650
required to put it in or is it no yeah

00:51:16,950 --> 00:51:22,319
so yeah so the I did mention that at the

00:51:19,650 --> 00:51:25,289
top level it's defaults to lab okay yeah

00:51:22,319 --> 00:51:26,940
and so because we think that introducing

00:51:25,289 --> 00:51:30,749
new identifiers will be the more common

00:51:26,940 --> 00:51:32,849
operation that's that's the a and also

00:51:30,749 --> 00:51:35,549
because it fits better with the existing

00:51:32,849 --> 00:51:39,299
declaration form the default at the top

00:51:35,549 --> 00:51:40,739
level is like and murder yeah okay

00:51:39,299 --> 00:51:44,880
that's I'm cool with that

00:51:40,739 --> 00:51:49,319
okay my last question is is is pattern

00:51:44,880 --> 00:51:51,420
matching required to be exhaustive so in

00:51:49,319 --> 00:51:53,579
other words if you don't if you don't

00:51:51,420 --> 00:51:57,329
cover every pair and is that a

00:51:53,579 --> 00:51:59,039
compile-time error right so we can do

00:51:57,329 --> 00:52:02,039
that in subsets of the cases like

00:51:59,039 --> 00:52:04,849
variant but we but we can't we can't we

00:52:02,039 --> 00:52:07,769
can't do that in general right obviously

00:52:04,849 --> 00:52:10,499
because of pattern guards and the other

00:52:07,769 --> 00:52:14,430
thing is like given the language we have

00:52:10,499 --> 00:52:16,950
like even it's just an enum right and it

00:52:14,430 --> 00:52:18,690
has three values we can't do exhaustive

00:52:16,950 --> 00:52:20,279
is checking on that because it's not

00:52:18,690 --> 00:52:23,660
invalid for the enum to hold other

00:52:20,279 --> 00:52:25,190
values all right and so it gets very

00:52:23,660 --> 00:52:31,490
hairy fair

00:52:25,190 --> 00:52:33,589
fast thank you yeah so first thanks for

00:52:31,490 --> 00:52:35,710
the work it's I think would be really

00:52:33,589 --> 00:52:39,140
great if you could would see that in

00:52:35,710 --> 00:52:41,060
twenty three for example but like a few

00:52:39,140 --> 00:52:43,160
a few things for example first

00:52:41,060 --> 00:52:47,359
I guess you use double underscore

00:52:43,160 --> 00:52:50,060
because one underscore is used for a lot

00:52:47,359 --> 00:52:52,880
of variables right yes it's mostly for

00:52:50,060 --> 00:52:54,770
libraries I see for testing libraries

00:52:52,880 --> 00:52:58,550
they use other score as the as the

00:52:54,770 --> 00:53:02,500
wild-card but anyway quality questions

00:52:58,550 --> 00:53:06,050
so the question is more or less like I

00:53:02,500 --> 00:53:07,819
like put more be like I would ask you to

00:53:06,050 --> 00:53:12,319
please consider like any other option

00:53:07,819 --> 00:53:13,849
even the UNIX heart two underscores for

00:53:12,319 --> 00:53:17,630
my point of view just looks terrible but

00:53:13,849 --> 00:53:22,300
it's obviously just in it yeah I I hate

00:53:17,630 --> 00:53:27,530
it too and then the second thing is

00:53:22,300 --> 00:53:29,660
there like this very much for my feeling

00:53:27,530 --> 00:53:33,230
it very much connects to having a

00:53:29,660 --> 00:53:35,900
language support for STD variant so like

00:53:33,230 --> 00:53:38,990
what many languages actually do is just

00:53:35,900 --> 00:53:42,829
allowing enums to be treated to have

00:53:38,990 --> 00:53:45,380
like any value yeah type they're not

00:53:42,829 --> 00:53:49,670
only integers is that kind of is there

00:53:45,380 --> 00:53:51,200
an effort towards this oh oh oh you're

00:53:49,670 --> 00:53:53,030
talking about like rusty gnomes or other

00:53:51,200 --> 00:53:54,230
in terms where like like it's most

00:53:53,030 --> 00:53:56,119
languages that over pattern-matching

00:53:54,230 --> 00:53:59,020
they also offer enums that actually have

00:53:56,119 --> 00:54:02,119
like parameter yeah yeah so there is

00:53:59,020 --> 00:54:05,150
support being done on the language level

00:54:02,119 --> 00:54:06,440
variant side of things which would let

00:54:05,150 --> 00:54:08,210
you do stuff like that it would be

00:54:06,440 --> 00:54:17,270
basically at this committed union in

00:54:08,210 --> 00:54:19,640
language yep hello hello hello hi so I

00:54:17,270 --> 00:54:22,069
noticed you have a distinction between

00:54:19,640 --> 00:54:25,160
inspect statements that are statements

00:54:22,069 --> 00:54:27,800
and inspect expressions yes

00:54:25,160 --> 00:54:29,960
and of course C++ does not have the nice

00:54:27,800 --> 00:54:32,690
advantage that like Haskell and rust has

00:54:29,960 --> 00:54:33,680
where all things are expressions and so

00:54:32,690 --> 00:54:34,310
you kinda have to distinguish between

00:54:33,680 --> 00:54:37,160
the two

00:54:34,310 --> 00:54:38,420
right what was sort of like that I don't

00:54:37,160 --> 00:54:40,880
know decision to

00:54:38,420 --> 00:54:42,950
do that versus like making special

00:54:40,880 --> 00:54:45,250
syntax that kind of made everything as

00:54:42,950 --> 00:54:50,420
much an expression as much as possible

00:54:45,250 --> 00:54:52,339
like having a block be there and sort of

00:54:50,420 --> 00:54:56,059
like the expression thing like it is in

00:54:52,339 --> 00:54:57,980
rust yeah so I mean coming up with the

00:54:56,059 --> 00:55:01,430
general mechanism to turn statements

00:54:57,980 --> 00:55:05,530
into expressions will be a feat and of

00:55:01,430 --> 00:55:08,270
itself no and the other thing is that

00:55:05,530 --> 00:55:10,160
the the statement so the thing is both

00:55:08,270 --> 00:55:13,369
of them are useful in their own right

00:55:10,160 --> 00:55:14,960
right and what I mean is like you could

00:55:13,369 --> 00:55:16,819
say oh why don't we just say why don't

00:55:14,960 --> 00:55:18,020
we just have the expression form and you

00:55:16,819 --> 00:55:19,190
can have expression statements and

00:55:18,020 --> 00:55:21,980
that's fine

00:55:19,190 --> 00:55:24,859
but what you lose is if you were to do

00:55:21,980 --> 00:55:26,359
and inspect inside of a for loop and in

00:55:24,859 --> 00:55:29,420
one of the cases you want it to continue

00:55:26,359 --> 00:55:31,910
or break with the expression only

00:55:29,420 --> 00:55:35,000
version you couldn't do that so what's

00:55:31,910 --> 00:55:37,250
the way to handle the case where you

00:55:35,000 --> 00:55:38,750
might have a much more complicated you

00:55:37,250 --> 00:55:40,369
want an expression statement but you

00:55:38,750 --> 00:55:42,530
have a much more complicated set of

00:55:40,369 --> 00:55:44,359
logic to determine what that expression

00:55:42,530 --> 00:55:47,299
is that you would want to normally break

00:55:44,359 --> 00:55:51,859
up into like multiple lines instead of

00:55:47,299 --> 00:55:53,319
just having one giant expression sorry

00:55:51,859 --> 00:55:56,390
I'm not sure I followed that question

00:55:53,319 --> 00:55:58,250
you just had like instant like in a lot

00:55:56,390 --> 00:56:01,849
of the expression statement examples it

00:55:58,250 --> 00:56:03,859
ended up being like X plus y and that's

00:56:01,849 --> 00:56:05,450
that's the expression but let's say I

00:56:03,859 --> 00:56:07,640
want to call another function get

00:56:05,450 --> 00:56:10,119
something back from that yeah and then

00:56:07,640 --> 00:56:12,140
compose some result in some work

00:56:10,119 --> 00:56:13,579
complicated way but I still want to be

00:56:12,140 --> 00:56:17,030
able to have the expression of being oh

00:56:13,579 --> 00:56:18,349
I see what you say that's it that's a

00:56:17,030 --> 00:56:20,690
good question I think I think you would

00:56:18,349 --> 00:56:23,510
end up having to use lenses okay yeah

00:56:20,690 --> 00:56:25,940
sorry thank you thank you but I'll

00:56:23,510 --> 00:56:28,400
consider that for sure yeah thank you um

00:56:25,940 --> 00:56:29,990
if the wild card matches is there any

00:56:28,400 --> 00:56:33,680
way to access that value in the

00:56:29,990 --> 00:56:36,200
expression no wild card means that you

00:56:33,680 --> 00:56:37,430
don't care to bind it and so if you want

00:56:36,200 --> 00:56:39,260
to bind it then you need to use in a

00:56:37,430 --> 00:56:40,760
verifier pattern to give it a name okay

00:56:39,260 --> 00:56:42,440
so there's no way to match like

00:56:40,760 --> 00:56:46,670
everything else and then use whatever

00:56:42,440 --> 00:56:48,740
that value is I mean if you want if if

00:56:46,670 --> 00:56:51,049
you want to match anything and do

00:56:48,740 --> 00:56:52,040
nothing with it like as a default case

00:56:51,049 --> 00:56:53,330
or something and you

00:56:52,040 --> 00:56:57,740
could use a wildcard pattern at the end

00:56:53,330 --> 00:57:00,020
of viewer as a last case which will be a

00:56:57,740 --> 00:57:02,860
fallback once at once not other cases

00:57:00,020 --> 00:57:05,270
match is that is that your question

00:57:02,860 --> 00:57:06,180
unless you're actually just it was a

00:57:05,270 --> 00:57:10,600
stupid question

00:57:06,180 --> 00:57:14,270
[Laughter]

00:57:10,600 --> 00:57:16,220
hey first of all I'm really looking

00:57:14,270 --> 00:57:18,950
forward to having this in C++ so thanks

00:57:16,220 --> 00:57:20,630
for working on this thank you and I

00:57:18,950 --> 00:57:22,940
apologize in advance for asking this but

00:57:20,630 --> 00:57:24,290
how does pattern matching into

00:57:22,940 --> 00:57:26,630
integrator combined with meta

00:57:24,290 --> 00:57:28,130
programming so in the one hand rather

00:57:26,630 --> 00:57:30,260
than matching against the constant for

00:57:28,130 --> 00:57:32,330
instance can I match against the result

00:57:30,260 --> 00:57:34,760
of a console expert function and on the

00:57:32,330 --> 00:57:41,480
other hand the spectrum can i generate

00:57:34,760 --> 00:57:43,580
patterns at compile time okay let me

00:57:41,480 --> 00:57:45,430
take it backwards so generate compadres

00:57:43,580 --> 00:57:48,650
at compile time

00:57:45,430 --> 00:57:50,570
that'll have no idea once you can

00:57:48,650 --> 00:57:54,830
generate code maybe you can figure maybe

00:57:50,570 --> 00:57:56,150
you can do something but most of it

00:57:54,830 --> 00:58:00,950
should fit into the extractor

00:57:56,150 --> 00:58:03,530
abstraction but if it doesn't we can we

00:58:00,950 --> 00:58:07,130
can discuss that the first part of that

00:58:03,530 --> 00:58:07,820
was how it interacts with context / and

00:58:07,130 --> 00:58:10,010
metaprogramming

00:58:07,820 --> 00:58:12,590
yeah so for instance you showed examples

00:58:10,010 --> 00:58:14,360
about matching an enum yeah against like

00:58:12,590 --> 00:58:16,040
the color red color green etc right

00:58:14,360 --> 00:58:19,820
could I replace color red with like a

00:58:16,040 --> 00:58:23,740
function call to make color red which is

00:58:19,820 --> 00:58:25,970
context / and just returns color red

00:58:23,740 --> 00:58:27,260
sure yeah that's fine yeah because

00:58:25,970 --> 00:58:32,210
that's the classic it cost an expression

00:58:27,260 --> 00:58:35,270
yeah okay thanks yep great talk first of

00:58:32,210 --> 00:58:38,780
all thank you um I do have one quick

00:58:35,270 --> 00:58:40,190
question so most things in C++ overload

00:58:38,780 --> 00:58:43,520
resolution template specialization

00:58:40,190 --> 00:58:46,400
always works off a best match now in

00:58:43,520 --> 00:58:49,010
pattern matching I can foresee the order

00:58:46,400 --> 00:58:51,620
of say a guard expression be sensitive

00:58:49,010 --> 00:58:53,900
to where lies in the pattern yeah

00:58:51,620 --> 00:58:55,910
is it is it gonna work off best manager

00:58:53,900 --> 00:58:59,530
is it gonna work off no it's going to be

00:58:55,910 --> 00:59:02,600
first match and it's for a good reason

00:58:59,530 --> 00:59:05,539
so the thing about it with the best

00:59:02,600 --> 00:59:07,519
match the way we do best match

00:59:05,539 --> 00:59:10,639
like we with overload sets for example

00:59:07,519 --> 00:59:12,679
right in order to perform best match we

00:59:10,639 --> 00:59:14,419
need to know all the candidates and so

00:59:12,679 --> 00:59:17,209
we end up having to actually instantiate

00:59:14,419 --> 00:59:18,859
like every possible candidate to form

00:59:17,209 --> 00:59:21,589
the overload set and then perform the

00:59:18,859 --> 00:59:23,389
scoring algorithm right and so imagine

00:59:21,589 --> 00:59:26,809
and like all of that happens at compile

00:59:23,389 --> 00:59:28,789
time so it's fine fine but imagine what

00:59:26,809 --> 00:59:32,359
happens if we do that at runtime right

00:59:28,789 --> 00:59:34,759
like we now have to like like have all

00:59:32,359 --> 00:59:36,469
the candidates evaluate them and then I

00:59:34,759 --> 00:59:39,049
got runtime figure out which one fits

00:59:36,469 --> 00:59:42,019
best right and so I think I think in

00:59:39,049 --> 00:59:44,989
terms of the fact that it's a runtime

00:59:42,019 --> 00:59:46,549
thing kind of prevents us from do we

00:59:44,989 --> 00:59:49,189
can't afford to do best matching I don't

00:59:46,549 --> 00:59:53,059
think I know just you sort of try catch

00:59:49,189 --> 00:59:55,849
and caches first match yes yeah that's

00:59:53,059 --> 00:59:57,469
true as well yeah right because that's

00:59:55,849 --> 00:59:59,659
because the chart catch example is a

00:59:57,469 --> 01:00:01,849
good one because the reason why that

00:59:59,659 --> 01:00:06,079
happens I've first match is also because

01:00:01,849 --> 01:00:06,949
it's at runtime right yeah hey thank you

01:00:06,079 --> 01:00:09,619
very much for a very interesting

01:00:06,949 --> 01:00:11,839
proposal if I could ask you to go to the

01:00:09,619 --> 01:00:15,289
slide with the last example if the

01:00:11,839 --> 01:00:18,019
colors last except this one like if the

01:00:15,289 --> 01:00:24,909
types the dynamic cast for example that

01:00:18,019 --> 01:00:28,880
you had before this how far yeah

01:00:24,909 --> 01:00:29,299
yes it's our example one more one one

01:00:28,880 --> 01:00:32,869
back

01:00:29,299 --> 01:00:34,339
yeah for example this one yeah if you

01:00:32,869 --> 01:00:36,739
have structural bindings we actually

01:00:34,339 --> 01:00:39,589
specify specifically right whether we

01:00:36,739 --> 01:00:43,459
want the copy or reference by Auto

01:00:39,589 --> 01:00:45,439
router rafter so here if it's an I does

01:00:43,459 --> 01:00:47,659
it mean as a reference or is it copy of

01:00:45,439 --> 01:00:51,739
that okay a good question so instruction

01:00:47,659 --> 01:00:53,269
bindings the the specif the the auto on

01:00:51,739 --> 01:00:55,699
the outside which is a you know

01:00:53,269 --> 01:00:58,609
reference or whatever is for the full

01:00:55,699 --> 01:01:00,019
object right there identifiers that are

01:00:58,609 --> 01:01:02,269
introduced within structured bindings

01:01:00,019 --> 01:01:06,199
are not specified whether they're

01:01:02,269 --> 01:01:08,989
they're just findings right so so it

01:01:06,199 --> 01:01:12,109
kind of looks more like like a reference

01:01:08,989 --> 01:01:12,469
then so yeah so okay so let me so let me

01:01:12,109 --> 01:01:14,149
start again

01:01:12,469 --> 01:01:18,259
so instruction bindings when you say

01:01:14,149 --> 01:01:19,400
auto x comma y the auto is for the

01:01:18,259 --> 01:01:22,490
entire object

01:01:19,400 --> 01:01:24,980
right and the x and y are almost like

01:01:22,490 --> 01:01:27,890
references kind of right okay those are

01:01:24,980 --> 01:01:31,339
generally called bindings and so I here

01:01:27,890 --> 01:01:32,809
is a binding okay so a same way they are

01:01:31,339 --> 01:01:34,609
instruction bindings so I couldn't use

01:01:32,809 --> 01:01:36,829
it to modify the value and and so on and

01:01:34,609 --> 01:01:38,240
so forth if it's depending on if it's

01:01:36,829 --> 01:01:41,589
the fat in this in this particular

01:01:38,240 --> 01:01:44,690
example yeah and the other thing because

01:01:41,589 --> 01:01:47,029
here with the types how how to inspect

01:01:44,690 --> 01:01:48,619
knows about all of the times from STD

01:01:47,029 --> 01:01:51,230
Bahrain is it possible to use like some

01:01:48,619 --> 01:01:53,119
custom like different version of Orion

01:01:51,230 --> 01:01:55,789
like Orion or something like this and

01:01:53,119 --> 01:01:57,650
this will still work yeah yeah so the

01:01:55,789 --> 01:01:59,089
there are specific customers

01:01:57,650 --> 01:02:01,339
customization points that you can opt

01:01:59,089 --> 01:02:02,779
into to handle other variant like types

01:02:01,339 --> 01:02:04,849
okay thank you

01:02:02,779 --> 01:02:10,480
yeah I think we probably have to cut it

01:02:04,849 --> 01:02:10,480
here I think I'm over a bit right

01:02:11,259 --> 01:02:15,890
okay I won't wear a minute I'll ask you

01:02:13,819 --> 01:02:17,960
a question Oh last question just go okay

01:02:15,890 --> 01:02:20,119
what is it is it quick about this you

01:02:17,960 --> 01:02:23,630
said the sport costume variant types

01:02:20,119 --> 01:02:25,480
yeah about custom RTT I know a lot of

01:02:23,630 --> 01:02:28,670
code base happen

01:02:25,480 --> 01:02:33,140
that's a good question I talked to me

01:02:28,670 --> 01:02:37,250
after this yeah okay thank you

01:02:33,140 --> 01:02:37,250

YouTube URL: https://www.youtube.com/watch?v=PBZBG4nZXhk


