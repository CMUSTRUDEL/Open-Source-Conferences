Title: CppCon 2019: Kostas Kyrimis ADL: introduction in name taxonomy, customization points and use cases
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
This talk introduces argument dependent lookup(ADL); name taxonomy; and customisation points in order to demonstrate and understand the peculiarities and the process of looking up names with ADL. Furthermore, this talk will demonstrate and discuss ADL thoroughly in the context of templates.

What is ADL?

ADL is a C++ feature that extends a name’s* lookup set by associating it with “extra” namespaces. The C++ standard mandates name taxonomy in a nonintuitive way that makes it difficult for young programmers to understand and use this feature. On the other hand, in advanced use cases of templates even experienced programmers sometimes struggle to reason about their code.

Why ADL?

It greatly enhances the usability of templates by allowing the compiler to extend the overload resolution of a template call allowing it look up more declarations which otherwise would be hidden from the compiler.

Library authors who design generic code don’t know firsthand how the users intent to use the library. Therefore, it’s essential to allow clients to customise the behaviour of their generic code on cases where they believe a more specialised implementation is desired. For instance, a qualified call to std::swap() is condemned to bypass any user defined overload of swap().

*The precise definition will be given in the name taxonomy category section of the outline
— 
Kostas Kyrimis
Codeplay Software
Software Engineer

Kostas Kyrimis is a software engineer who is working on ComputeCpp; Codeplay’s implementation of the Khronos Group open standard SYCL for heterogenous computing. He advocates modern C++ practices, appreciates generic programming and algorithms and he is a supporter of expressive, clean and scalable code. Furthermore, Kostas, holds a BSc and MSc in Computer Science and on his free time he enjoys travelling, snowboarding and strength training.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,300 --> 00:00:13,820
hi everybody welcome without any further

00:00:12,320 --> 00:00:14,930
delay I wanted some straight to the

00:00:13,820 --> 00:00:17,720
outline there are lots of things to

00:00:14,930 --> 00:00:20,240
discuss so first I'll speak a little bit

00:00:17,720 --> 00:00:22,910
about me why I'm here and what I do and

00:00:20,240 --> 00:00:24,859
then we're gonna discuss why we need a

00:00:22,910 --> 00:00:26,480
deal in practice then we're gonna move

00:00:24,859 --> 00:00:28,880
on with a name taxonomy which

00:00:26,480 --> 00:00:32,150
essentially is a which essentially the

00:00:28,880 --> 00:00:34,129
theory behind a deal and of course then

00:00:32,150 --> 00:00:35,570
please no surprise here templates

00:00:34,129 --> 00:00:38,900
interact with argument append and lookup

00:00:35,570 --> 00:00:41,269
and therefore sometimes are surprised

00:00:38,900 --> 00:00:43,580
sometimes they're either surprised

00:00:41,269 --> 00:00:46,519
they're surprising cases or unspecified

00:00:43,580 --> 00:00:47,629
cases as we shall soon see and of course

00:00:46,519 --> 00:00:49,850
finally we're going to talk about

00:00:47,629 --> 00:00:50,540
customization points and customization

00:00:49,850 --> 00:00:52,489
foreign objects

00:00:50,540 --> 00:00:54,500
I encourage questions throughout the

00:00:52,489 --> 00:00:57,049
talk please raise your hand I'll get

00:00:54,500 --> 00:00:58,940
back to you as soon as possible and in

00:00:57,049 --> 00:01:01,580
the event that I need some time to think

00:00:58,940 --> 00:01:03,680
about it then we can always take it

00:01:01,580 --> 00:01:06,950
offline after the talk has a discussion

00:01:03,680 --> 00:01:08,780
so a little bit about me I was born in

00:01:06,950 --> 00:01:10,280
Greece I did my bachelor's degree in

00:01:08,780 --> 00:01:12,200
informatics and then I moved to and

00:01:10,280 --> 00:01:13,460
moved in and abroad to do my master's

00:01:12,200 --> 00:01:15,530
degree and for the past year I've been

00:01:13,460 --> 00:01:17,450
working for a company called Coldplay

00:01:15,530 --> 00:01:19,429
and I'm a software engineer there I work

00:01:17,450 --> 00:01:20,899
I'm part of the team that implements

00:01:19,429 --> 00:01:22,700
ickle for those of you who don't know

00:01:20,899 --> 00:01:24,619
sickle is a current group open standard

00:01:22,700 --> 00:01:26,840
which essentially is a programming model

00:01:24,619 --> 00:01:29,090
that enables heterogeneous system

00:01:26,840 --> 00:01:31,310
programming in single source C++

00:01:29,090 --> 00:01:32,749
now feel free to reach me I'm a very

00:01:31,310 --> 00:01:35,149
easygoing person I would love to meet

00:01:32,749 --> 00:01:37,880
all of you after the talk and here is my

00:01:35,149 --> 00:01:41,329
email in case you need me anything now

00:01:37,880 --> 00:01:43,789
why I deal and why this talk so in my

00:01:41,329 --> 00:01:45,950
opinion ADL is fundamental to the

00:01:43,789 --> 00:01:47,689
language because it interacts with many

00:01:45,950 --> 00:01:49,729
of the core features it interacts with

00:01:47,689 --> 00:01:51,560
it interacts with namespaces in

00:01:49,729 --> 00:01:53,659
interacts with templates it even

00:01:51,560 --> 00:01:55,999
interacts with what it's fed to the

00:01:53,659 --> 00:01:59,869
overloaded solution and you will learn

00:01:55,999 --> 00:02:01,729
how actually ADL works and all so with

00:01:59,869 --> 00:02:03,710
that in mind we were gonna make known

00:02:01,729 --> 00:02:06,319
intuitive cases simple enough they will

00:02:03,710 --> 00:02:07,909
no longer be a black box for you and of

00:02:06,319 --> 00:02:10,280
course we're gonna discuss a common

00:02:07,909 --> 00:02:11,810
pitfalls and the traps and we will see

00:02:10,280 --> 00:02:14,510
how we can guard against them by

00:02:11,810 --> 00:02:15,950
providing with guidelines and generic

00:02:14,510 --> 00:02:17,510
code customization points and

00:02:15,950 --> 00:02:20,720
customization point objects we will see

00:02:17,510 --> 00:02:21,590
how ADL rocks in practice and the

00:02:20,720 --> 00:02:26,000
reference is arrived

00:02:21,590 --> 00:02:28,519
used templates the complete guide in my

00:02:26,000 --> 00:02:30,530
opinion is a book it's the best book

00:02:28,519 --> 00:02:32,840
when it comes when it comes to templates

00:02:30,530 --> 00:02:36,489
it's very close to the standard itself

00:02:32,840 --> 00:02:38,150
but it's in a human readable form and

00:02:36,489 --> 00:02:41,239
speaking of the devil

00:02:38,150 --> 00:02:45,260
the C++ standard itself which when it

00:02:41,239 --> 00:02:46,700
comes to really understanding a specific

00:02:45,260 --> 00:02:49,250
feature of the language this is the best

00:02:46,700 --> 00:02:50,390
place to to look up and of course a

00:02:49,250 --> 00:02:52,730
couple of papers that were written by

00:02:50,390 --> 00:02:54,500
the community and real-life code that

00:02:52,730 --> 00:02:56,239
I've developed I've made the mistakes

00:02:54,500 --> 00:02:58,790
I've fallen I fell into the traps and

00:02:56,239 --> 00:03:01,880
I've learned a lot and libraries that I

00:02:58,790 --> 00:03:03,500
interacted with ranged STS for example

00:03:01,880 --> 00:03:06,049
where they introduced customisation

00:03:03,500 --> 00:03:09,170
point objects a feature that essentially

00:03:06,049 --> 00:03:12,799
does a deal on the user's behalf and in

00:03:09,170 --> 00:03:15,110
Loveman sation which uses ADL for their

00:03:12,799 --> 00:03:16,700
serializer i would like to give many

00:03:15,110 --> 00:03:20,660
thanks to our through Dwyers for hit

00:03:16,700 --> 00:03:22,610
worldwide for his blog post and for for

00:03:20,660 --> 00:03:24,680
a discussion that I had with him for ADL

00:03:22,610 --> 00:03:27,410
and Christopher Dibble and Matt got bald

00:03:24,680 --> 00:03:31,040
for giving me continuous feedback about

00:03:27,410 --> 00:03:32,930
my presentation and when and why idea so

00:03:31,040 --> 00:03:35,510
you all know operator overloading right

00:03:32,930 --> 00:03:38,030
and what essentially looks like in your

00:03:35,510 --> 00:03:39,590
source code as an operator the compiler

00:03:38,030 --> 00:03:41,810
takes that and transforms it into a

00:03:39,590 --> 00:03:43,760
function call and it's very easy to see

00:03:41,810 --> 00:03:45,950
that from the following example so in

00:03:43,760 --> 00:03:48,470
line number three here we explicitly

00:03:45,950 --> 00:03:50,930
call the operator itself as if it were a

00:03:48,470 --> 00:03:53,989
function whereas in line for we use a

00:03:50,930 --> 00:03:55,880
syntactic sugar form simply enough but I

00:03:53,989 --> 00:03:58,549
am here to tell you that if we didn't

00:03:55,880 --> 00:04:00,859
have a DL line number four would be L

00:03:58,549 --> 00:04:02,900
form all right we wouldn't be able to

00:04:00,859 --> 00:04:05,690
use the syntactic food the syntactic

00:04:02,900 --> 00:04:08,480
sugar for so you're gonna ask do we need

00:04:05,690 --> 00:04:10,790
a deal yes we we saw the first the first

00:04:08,480 --> 00:04:13,250
reason right if we if we didn't have a

00:04:10,790 --> 00:04:14,870
deal we would totally defeat the purpose

00:04:13,250 --> 00:04:17,389
of operator overloading but it's not

00:04:14,870 --> 00:04:19,760
only that it's actually that C++ has

00:04:17,389 --> 00:04:21,799
non-member functions right insa and

00:04:19,760 --> 00:04:24,169
sometimes these functions are a part of

00:04:21,799 --> 00:04:26,810
the interface of a specific type even

00:04:24,169 --> 00:04:28,789
though they are non-members and for that

00:04:26,810 --> 00:04:30,530
we need to treat them uniformly turns

00:04:28,789 --> 00:04:32,599
out ADL is the answer to that and

00:04:30,530 --> 00:04:34,409
templates templates undergo a process

00:04:32,599 --> 00:04:38,489
called two-phase lookup

00:04:34,409 --> 00:04:39,899
and ADL is fundamental without it

00:04:38,489 --> 00:04:43,709
the usability of templates would be

00:04:39,899 --> 00:04:46,289
greatly reduced on the contrary if we

00:04:43,709 --> 00:04:48,659
have unconstrained templates they can be

00:04:46,289 --> 00:04:50,789
a source of very weird errors right some

00:04:48,659 --> 00:04:53,519
people refer to them as a do bytes

00:04:50,789 --> 00:04:56,309
now named taxonomy a name look up in an

00:04:53,519 --> 00:04:58,319
episode name taxonomy is important

00:04:56,309 --> 00:05:00,899
because it allows the programmer to

00:04:58,319 --> 00:05:03,059
reason about their code essentially when

00:05:00,899 --> 00:05:05,339
the compiler sees a name and what I mean

00:05:03,059 --> 00:05:08,399
by name let's update let's say function

00:05:05,339 --> 00:05:11,489
name it must look it up somehow and the

00:05:08,399 --> 00:05:14,489
process of looking up that name depends

00:05:11,489 --> 00:05:16,919
on the name taxonomy of the entity that

00:05:14,489 --> 00:05:19,229
we refer to and unfortunately the

00:05:16,919 --> 00:05:21,659
standard defines named economy in a non

00:05:19,229 --> 00:05:27,119
intuitive way and we can't rely yes

00:05:21,659 --> 00:05:30,300
please we will see later on just hold on

00:05:27,119 --> 00:05:32,459
for a second so yeah the standard Monday

00:05:30,300 --> 00:05:34,979
it's named economy in a non intuitive

00:05:32,459 --> 00:05:36,839
way and we can we as programmers we

00:05:34,979 --> 00:05:39,329
can't rely on the standard for

00:05:36,839 --> 00:05:41,159
day-to-day programming and hopefully we

00:05:39,329 --> 00:05:43,679
can get away by remembering the four

00:05:41,159 --> 00:05:46,169
things we can say that a name is either

00:05:43,679 --> 00:05:49,679
qualified or unqualified and if it's a

00:05:46,169 --> 00:05:51,419
template we can say that and if it's a

00:05:49,679 --> 00:05:55,259
template it can be dependent or non

00:05:51,419 --> 00:05:57,990
dependent so how does the compiler

00:05:55,259 --> 00:05:59,789
process a function call it turns out

00:05:57,990 --> 00:06:02,009
it's a two-step process the first

00:05:59,789 --> 00:06:05,789
process is a name lookup which

00:06:02,009 --> 00:06:08,579
essentially describes how we construct a

00:06:05,789 --> 00:06:11,039
set of potential candidates and we take

00:06:08,579 --> 00:06:13,139
that set and if it's greater than one

00:06:11,039 --> 00:06:15,300
right if there is if there are more than

00:06:13,139 --> 00:06:17,309
one line elements in that set then we

00:06:15,300 --> 00:06:19,439
feed that to the overloaded solution in

00:06:17,309 --> 00:06:22,110
the over the solution describes the

00:06:19,439 --> 00:06:24,989
process that this set is reduced down to

00:06:22,110 --> 00:06:26,789
one the function that we end up that we

00:06:24,989 --> 00:06:29,579
end up calling in our source code so

00:06:26,789 --> 00:06:31,050
also the subject of overload the

00:06:29,579 --> 00:06:32,939
solution belongs to a different talk

00:06:31,050 --> 00:06:35,219
we're not going to cover it here but in

00:06:32,939 --> 00:06:37,139
case you're interested please refer to

00:06:35,219 --> 00:06:40,709
the templates a complete guide software

00:06:37,139 --> 00:06:43,229
16 it has everything you need to know so

00:06:40,709 --> 00:06:46,139
again we say that a name is qualified

00:06:43,229 --> 00:06:48,190
and in that case it undergoes its looked

00:06:46,139 --> 00:06:51,070
up by the rules

00:06:48,190 --> 00:06:53,170
are specified by qualified lookup and we

00:06:51,070 --> 00:06:55,180
will also produce some will also add

00:06:53,170 --> 00:06:58,060
some models if it's a template later on

00:06:55,180 --> 00:07:01,450
and we can say also that if the name is

00:06:58,060 --> 00:07:03,400
unqualified it undergoes than qualified

00:07:01,450 --> 00:07:05,440
lookup rules and again if it's a

00:07:03,400 --> 00:07:08,470
template there are some extra rules

00:07:05,440 --> 00:07:10,840
we're gonna see all of them in a second

00:07:08,470 --> 00:07:13,330
so let's see how qualified names work in

00:07:10,840 --> 00:07:15,790
practice the lookup scope is always

00:07:13,330 --> 00:07:18,760
implied by the qualified construct and

00:07:15,790 --> 00:07:21,010
of course a qualified name is when that

00:07:18,760 --> 00:07:23,650
name is prefixed with either the scope

00:07:21,010 --> 00:07:24,940
resolution operator or the member access

00:07:23,650 --> 00:07:27,130
operator it's very easy to visualize

00:07:24,940 --> 00:07:29,110
this from the following example you have

00:07:27,130 --> 00:07:30,850
a structure we have a pipe structure and

00:07:29,110 --> 00:07:34,090
you have a member connect and in line

00:07:30,850 --> 00:07:36,820
six you call you have a qualified call

00:07:34,090 --> 00:07:39,700
which the same search is inside the

00:07:36,820 --> 00:07:40,930
scope the implied scope is pipe and it

00:07:39,700 --> 00:07:42,910
calls the write function you already

00:07:40,930 --> 00:07:44,860
know that you've used that you now also

00:07:42,910 --> 00:07:47,350
know that it's it has a name and it's

00:07:44,860 --> 00:07:49,750
called qualified lookup and of course P

00:07:47,350 --> 00:07:52,810
dot Z is is informed there is no the

00:07:49,750 --> 00:07:56,980
inside pipe it makes sense and qualified

00:07:52,810 --> 00:07:59,530
names and qualified names actually

00:07:56,980 --> 00:08:01,500
undergo a two-step process and the first

00:07:59,530 --> 00:08:05,140
process is unqualified lookup and

00:08:01,500 --> 00:08:08,110
sometimes they undergo an extra step the

00:08:05,140 --> 00:08:10,390
argument dependent lookup and we can

00:08:08,110 --> 00:08:13,210
describe that with two sets right the

00:08:10,390 --> 00:08:14,830
first set will be the set produced by

00:08:13,210 --> 00:08:17,620
then qualified lookup which we will call

00:08:14,830 --> 00:08:19,240
you and the second set is the set

00:08:17,620 --> 00:08:22,840
produced by the argument dependent

00:08:19,240 --> 00:08:26,290
lookup which we're gonna call a and now

00:08:22,840 --> 00:08:29,169
we can say that if they said u contains

00:08:26,290 --> 00:08:31,750
and may contains a declaration of a

00:08:29,169 --> 00:08:34,150
class member or a block scope faction

00:08:31,750 --> 00:08:35,740
declaration that is not reducing

00:08:34,150 --> 00:08:37,510
declaration and here in example suppose

00:08:35,740 --> 00:08:40,539
you have a function f and inside the

00:08:37,510 --> 00:08:43,210
function you have X turn some function

00:08:40,539 --> 00:08:45,940
name that this rule is Cecily will block

00:08:43,210 --> 00:08:47,950
ideal in the third case which I want you

00:08:45,940 --> 00:08:50,530
to remember because it's gonna come in

00:08:47,950 --> 00:08:52,930
the very end is that a declaration that

00:08:50,530 --> 00:08:55,000
is neither a function nor a function

00:08:52,930 --> 00:08:58,150
template in customization point objects

00:08:55,000 --> 00:09:01,300
as we will see later on uses that uses a

00:08:58,150 --> 00:09:01,860
true and then the set is then if that's

00:09:01,300 --> 00:09:04,290
the case

00:09:01,860 --> 00:09:04,950
then they said aids and then they said a

00:09:04,290 --> 00:09:08,880
is empty

00:09:04,950 --> 00:09:11,670
otherwise all right then we otherwise we

00:09:08,880 --> 00:09:13,709
take the union of the set a and they

00:09:11,670 --> 00:09:17,940
said you and we feed it to the

00:09:13,709 --> 00:09:19,350
overloaded solution now let's see how

00:09:17,940 --> 00:09:21,329
unqualified lookup works in detail

00:09:19,350 --> 00:09:23,329
that's the first step by the way so

00:09:21,329 --> 00:09:25,829
unqualified lookup search these

00:09:23,329 --> 00:09:29,760
subsequent scopes you can imagine that

00:09:25,829 --> 00:09:33,029
as it propagates up right and again our

00:09:29,760 --> 00:09:35,370
favorite example although this time we

00:09:33,029 --> 00:09:37,470
make an unqualified call to connect and

00:09:35,370 --> 00:09:39,930
we start inside Z there is nothing

00:09:37,470 --> 00:09:41,579
inside the wizards outside and there is

00:09:39,930 --> 00:09:43,500
nothing in the global scope so therefore

00:09:41,579 --> 00:09:46,079
we get a diagnostic again makes sense

00:09:43,500 --> 00:09:48,510
but now if we call F we search there is

00:09:46,079 --> 00:09:51,540
nothing in here we go here and whoops we

00:09:48,510 --> 00:09:53,490
found s and we call that F now the

00:09:51,540 --> 00:09:57,450
second step the argument dependent

00:09:53,490 --> 00:09:59,490
lookup step so we can imagine this in

00:09:57,450 --> 00:10:01,980
order for us in order for me to explain

00:09:59,490 --> 00:10:04,500
how we build up the argument and look

00:10:01,980 --> 00:10:06,720
upset we need to know two more set the

00:10:04,500 --> 00:10:09,360
set of the associate entities and the

00:10:06,720 --> 00:10:12,779
set of the associate namespaces and

00:10:09,360 --> 00:10:15,060
sorry and we're gonna explain how we

00:10:12,779 --> 00:10:17,670
construct these sets because these are

00:10:15,060 --> 00:10:19,980
we use these sets to build the argument

00:10:17,670 --> 00:10:23,519
dependent look upset and we we're gonna

00:10:19,980 --> 00:10:26,699
I'm gonna I'm gonna explain this just if

00:10:23,519 --> 00:10:29,940
it was a game and essentially we need to

00:10:26,699 --> 00:10:32,209
classify its argument with a category

00:10:29,940 --> 00:10:36,930
and that category

00:10:32,209 --> 00:10:39,329
depends on the type we are passing so

00:10:36,930 --> 00:10:41,100
what if the type that we're passing on a

00:10:39,329 --> 00:10:43,410
function call is a fundamental type that

00:10:41,100 --> 00:10:46,380
is a mean the car it's our or a float

00:10:43,410 --> 00:10:48,089
then in that case the set of the

00:10:46,380 --> 00:10:50,070
associate namespaces and the set of the

00:10:48,089 --> 00:10:51,779
associate entities is the empty set so

00:10:50,070 --> 00:10:53,430
if you think you're clever and you try

00:10:51,779 --> 00:10:56,310
to do something like that it won't work

00:10:53,430 --> 00:10:58,709
so essentially you have a namespace you

00:10:56,310 --> 00:11:00,630
have your void func you have a void you

00:10:58,709 --> 00:11:02,519
have an F which accepts a mean and then

00:11:00,630 --> 00:11:05,459
you make an unqualified call you get a

00:11:02,519 --> 00:11:09,120
diagnostic it doesn't work out now what

00:11:05,459 --> 00:11:11,790
if T is a class type then the set of the

00:11:09,120 --> 00:11:14,610
associate entities is a class itself and

00:11:11,790 --> 00:11:15,450
indirect or Die or direct based classes

00:11:14,610 --> 00:11:17,460
and if

00:11:15,450 --> 00:11:20,160
a member of the class then that class

00:11:17,460 --> 00:11:22,440
itself and the set of the associate

00:11:20,160 --> 00:11:25,020
namespaces is the innermost enclosing

00:11:22,440 --> 00:11:26,850
namespace of which associate entities

00:11:25,020 --> 00:11:28,980
and you can see that very clearly from

00:11:26,850 --> 00:11:30,660
the following example you have - we have

00:11:28,980 --> 00:11:32,760
two namespaces we have a library

00:11:30,660 --> 00:11:34,200
namespace and a user name space and

00:11:32,760 --> 00:11:36,030
inside the library namespace we'll have

00:11:34,200 --> 00:11:39,030
again pipe and connect and connect

00:11:36,030 --> 00:11:42,240
accepts a pipe and later on in the

00:11:39,030 --> 00:11:45,270
namespace user we derive from lead pipe

00:11:42,240 --> 00:11:49,770
user pipe derives from lead pipe and

00:11:45,270 --> 00:11:52,230
then connect now accept a user pipe when

00:11:49,770 --> 00:11:56,940
we make an unqualified call to that at

00:11:52,230 --> 00:11:59,520
line 13 over here first and qualified

00:11:56,940 --> 00:12:01,860
lookup is triggered and unqualified

00:11:59,520 --> 00:12:03,870
lookup finds nothing in the global scope

00:12:01,860 --> 00:12:06,090
so then qualified lookup set is empty

00:12:03,870 --> 00:12:09,600
and we also proceed to the argument

00:12:06,090 --> 00:12:11,580
dependent look up and we see the P P is

00:12:09,600 --> 00:12:15,030
a class type and therefore the set of

00:12:11,580 --> 00:12:17,970
the associate entities is leap : : pipe

00:12:15,030 --> 00:12:21,120
and user : called a user pipe in the set

00:12:17,970 --> 00:12:25,020
of the associate namespaces is leap and

00:12:21,120 --> 00:12:27,030
user so in the end the argument depends

00:12:25,020 --> 00:12:30,840
the argument dependent look up set

00:12:27,030 --> 00:12:33,750
contains both leap : : connect and user

00:12:30,840 --> 00:12:35,640
: : connect and of course the overlooked

00:12:33,750 --> 00:12:38,490
this is fed to the overall the solution

00:12:35,640 --> 00:12:42,150
and the over the solution picks up user

00:12:38,490 --> 00:12:45,050
: : connect as a better candidate now

00:12:42,150 --> 00:12:48,660
moving on what if T is an enum then T

00:12:45,050 --> 00:12:50,490
then e is am itself of course and if

00:12:48,660 --> 00:12:52,110
it's a class member then the member

00:12:50,490 --> 00:12:54,780
class in the set of the associate

00:12:52,110 --> 00:12:56,580
namespaces is an innermost namespace of

00:12:54,780 --> 00:12:59,280
its declaration and again we will

00:12:56,580 --> 00:13:00,810
present you a present example here who

00:12:59,280 --> 00:13:02,970
have a user who have a minimum class

00:13:00,810 --> 00:13:05,490
color and we have a function f that

00:13:02,970 --> 00:13:08,430
accepts a color now when we make an

00:13:05,490 --> 00:13:10,950
unqualified call here and qualified look

00:13:08,430 --> 00:13:13,290
up again services are services outside

00:13:10,950 --> 00:13:14,940
finds nothing so that set is empty we

00:13:13,290 --> 00:13:18,630
proceed with the argument dependent look

00:13:14,940 --> 00:13:21,570
up step and we we feed to the we feed

00:13:18,630 --> 00:13:23,790
user so sorry the argument dependent

00:13:21,570 --> 00:13:25,980
looks we look up set will contain user :

00:13:23,790 --> 00:13:28,560
: s and that's the one we end up calling

00:13:25,980 --> 00:13:32,110
so this call is perfectly legal

00:13:28,560 --> 00:13:35,080
now what if T is a pointer to X or a

00:13:32,110 --> 00:13:36,580
pointer or an array of X in that case we

00:13:35,080 --> 00:13:37,810
completely forget about the pointer we

00:13:36,580 --> 00:13:40,660
don't care when we look at the

00:13:37,810 --> 00:13:42,880
underlying type and obviously the under

00:13:40,660 --> 00:13:44,410
light type falls down to the previous

00:13:42,880 --> 00:13:47,730
categories that I've just described to

00:13:44,410 --> 00:13:50,860
you so let's see an example here again

00:13:47,730 --> 00:13:54,010
the same example but this time connect

00:13:50,860 --> 00:13:56,440
accepts a PI pointer and when we make an

00:13:54,010 --> 00:14:00,640
unqualified call to connect and we pass

00:13:56,440 --> 00:14:04,140
now a pointer to a lead-pipe then ADL is

00:14:00,640 --> 00:14:07,420
able to find Lib : : connect

00:14:04,140 --> 00:14:09,220
now what if T is a function type then in

00:14:07,420 --> 00:14:11,140
that case we need to we need two things

00:14:09,220 --> 00:14:13,450
the function parameter they function

00:14:11,140 --> 00:14:15,790
parameter types and obviously the return

00:14:13,450 --> 00:14:19,120
type we can see that from the following

00:14:15,790 --> 00:14:22,060
example again same thing although this

00:14:19,120 --> 00:14:24,220
time process accepts accepts a pointer

00:14:22,060 --> 00:14:26,709
to a function that takes a type object

00:14:24,220 --> 00:14:29,190
and returns a void and we define such a

00:14:26,709 --> 00:14:33,240
function into the global namespace and

00:14:29,190 --> 00:14:36,100
inside AIDS we make an unqualified call

00:14:33,240 --> 00:14:39,070
and then qualify call to process and we

00:14:36,100 --> 00:14:39,910
pass custom now here there are two

00:14:39,070 --> 00:14:43,380
things I'm qualified

00:14:39,910 --> 00:14:45,880
lookup finds nothing it is empty and

00:14:43,380 --> 00:14:47,410
argument appended lookup proceeds we see

00:14:45,880 --> 00:14:49,329
first parrot n type the return type is

00:14:47,410 --> 00:14:51,730
void what did we say for fundamental

00:14:49,329 --> 00:14:53,440
types there is no set of associate

00:14:51,730 --> 00:14:55,360
namespaces and there is no set of

00:14:53,440 --> 00:14:58,180
associated entities so we now look at

00:14:55,360 --> 00:15:00,399
the parameter types and which we already

00:14:58,180 --> 00:15:02,740
cover this right is the second rule so

00:15:00,399 --> 00:15:04,839
we know by what we've what I've

00:15:02,740 --> 00:15:06,730
discussed previously that we the

00:15:04,839 --> 00:15:10,450
argument dependent look up the a set

00:15:06,730 --> 00:15:14,010
will contain Lib : will contain Lib : :

00:15:10,450 --> 00:15:17,730
process and therefore this is valid code

00:15:14,010 --> 00:15:21,279
now what if T is a pointer to a member

00:15:17,730 --> 00:15:23,890
to a member function of the class X this

00:15:21,279 --> 00:15:25,360
is this is this is where this is very

00:15:23,890 --> 00:15:27,610
simple enough all you need to remember

00:15:25,360 --> 00:15:29,260
is the fifth rule of the second rule

00:15:27,610 --> 00:15:30,880
essentially the previous rules I have

00:15:29,260 --> 00:15:35,410
just described and the second rule which

00:15:30,880 --> 00:15:38,050
is a class now as you can see here from

00:15:35,410 --> 00:15:39,610
the following example as you can see

00:15:38,050 --> 00:15:41,720
here from the following example you have

00:15:39,610 --> 00:15:46,189
the we we make an unqualified

00:15:41,720 --> 00:15:47,870
Cole sorry sorry let me rephrase it we

00:15:46,189 --> 00:15:49,279
have the library namespace again we have

00:15:47,870 --> 00:15:51,680
our source we will have our structure

00:15:49,279 --> 00:15:54,410
pipe and we have a function Z at this

00:15:51,680 --> 00:15:57,860
time accent except a pointer to a member

00:15:54,410 --> 00:16:00,019
of pipe and we do that we construct such

00:15:57,860 --> 00:16:03,110
a pointer to a member and we call Z and

00:16:00,019 --> 00:16:04,579
qualified and this works again because

00:16:03,110 --> 00:16:06,829
of the rules I've just described to you

00:16:04,579 --> 00:16:08,899
you already know this by now

00:16:06,829 --> 00:16:11,629
and what if T is a pointer to a data

00:16:08,899 --> 00:16:14,629
member of a class X then in that case we

00:16:11,629 --> 00:16:16,220
need to take then the set of the

00:16:14,629 --> 00:16:19,610
associate namespaces and a set of the

00:16:16,220 --> 00:16:22,250
associate entities is is the class

00:16:19,610 --> 00:16:25,000
itself which is the second rule and also

00:16:22,250 --> 00:16:27,769
we need to take into account the type of

00:16:25,000 --> 00:16:31,990
the member and we can visualize that

00:16:27,769 --> 00:16:36,050
from here from the following exam one

00:16:31,990 --> 00:16:42,410
yeah that shouldn't happen sorry for

00:16:36,050 --> 00:16:52,279
that moving on templates templates an

00:16:42,410 --> 00:16:54,170
ADL sorry so before we get before we dig

00:16:52,279 --> 00:16:56,329
before we get into templates and idea I

00:16:54,170 --> 00:16:59,389
would like to discuss some terminology

00:16:56,329 --> 00:17:01,100
with you so is it a function template or

00:16:59,389 --> 00:17:03,889
a template function we need to be

00:17:01,100 --> 00:17:05,449
precise you will see why is the function

00:17:03,889 --> 00:17:07,459
template or a template function I'm

00:17:05,449 --> 00:17:09,470
gonna quote here Volturi Brown

00:17:07,459 --> 00:17:11,780
it's like saying milk chocolate or

00:17:09,470 --> 00:17:13,309
chocolate milk the one is a beverage the

00:17:11,780 --> 00:17:15,199
other one is a candy for children they

00:17:13,309 --> 00:17:17,120
are not the same thing the right

00:17:15,199 --> 00:17:20,720
terminologies function template and

00:17:17,120 --> 00:17:22,610
class template and what about

00:17:20,720 --> 00:17:25,669
specialization and what about

00:17:22,610 --> 00:17:28,669
instantiation so installation is the

00:17:25,669 --> 00:17:30,679
process where we substitute each of the

00:17:28,669 --> 00:17:33,320
template parameters with the template

00:17:30,679 --> 00:17:35,720
arguments and if that the if that

00:17:33,320 --> 00:17:38,299
process succeeds we end up with a

00:17:35,720 --> 00:17:40,070
specialization but a specialization not

00:17:38,299 --> 00:17:43,549
necessarily is not only it's not

00:17:40,070 --> 00:17:45,710
necessarily produced by the process of

00:17:43,549 --> 00:17:48,320
installation we can always explicitly

00:17:45,710 --> 00:17:52,070
instance if you can always explicitly

00:17:48,320 --> 00:17:54,020
fully specialize our template now I'm

00:17:52,070 --> 00:17:54,840
moving on we need to revise a little bit

00:17:54,020 --> 00:17:56,670
now the rules

00:17:54,840 --> 00:17:59,250
and I'm gonna revise a second rule and

00:17:56,670 --> 00:18:01,590
the second rule is what if T is that

00:17:59,250 --> 00:18:05,250
what if T is a class template

00:18:01,590 --> 00:18:07,170
specialization then in that case we it's

00:18:05,250 --> 00:18:09,480
the set of the associate namespaces and

00:18:07,170 --> 00:18:13,080
a set of the associate entities contains

00:18:09,480 --> 00:18:16,710
what we've said before class we now take

00:18:13,080 --> 00:18:19,380
into account the types the types address

00:18:16,710 --> 00:18:20,970
for the the types of the template

00:18:19,380 --> 00:18:22,740
arguments and the template template

00:18:20,970 --> 00:18:25,140
arguments and you can visualize that

00:18:22,740 --> 00:18:27,420
from the following sample so we have a

00:18:25,140 --> 00:18:29,850
library namespace and we have a class

00:18:27,420 --> 00:18:33,740
template called type and again we have

00:18:29,850 --> 00:18:36,960
user and this time user brings up

00:18:33,740 --> 00:18:38,880
defines water water type and we have an

00:18:36,960 --> 00:18:40,700
unconstraint template an unconstraint

00:18:38,880 --> 00:18:42,720
template that takes a parameter pack of

00:18:40,700 --> 00:18:45,090
universal references or forwarding

00:18:42,720 --> 00:18:49,800
references and we make an unqualified

00:18:45,090 --> 00:18:52,080
call and we pass too much anything the

00:18:49,800 --> 00:18:56,400
specialization produced by instantiating

00:18:52,080 --> 00:19:01,380
pipe with water pipe and so what happens

00:18:56,400 --> 00:19:03,030
here as we as we so first unqualified

00:19:01,380 --> 00:19:05,070
lookup and qualified lookup finds

00:19:03,030 --> 00:19:07,440
nothing so that set is empty and we

00:19:05,070 --> 00:19:09,810
proceed with the argument appended look

00:19:07,440 --> 00:19:12,540
up and now argument argument dependent

00:19:09,810 --> 00:19:14,310
lookup considers builds first the set of

00:19:12,540 --> 00:19:16,830
The Associated entities and the set of

00:19:14,310 --> 00:19:21,660
the associate entities is Lib : : pipe

00:19:16,830 --> 00:19:24,540
and user in user : : water pipe so the

00:19:21,660 --> 00:19:30,510
set of the associate namespaces is Lib

00:19:24,540 --> 00:19:32,580
and user and for that we finally feed we

00:19:30,510 --> 00:19:33,690
finally feed to the argument dependent

00:19:32,580 --> 00:19:36,060
look upset

00:19:33,690 --> 00:19:39,300
user : : Maps anything and therefore

00:19:36,060 --> 00:19:43,140
this call is valid and I must say this

00:19:39,300 --> 00:19:46,440
now this is very dangerous code and you

00:19:43,140 --> 00:19:50,370
will see why later on now

00:19:46,440 --> 00:19:52,890
what is what is a dependent name and

00:19:50,370 --> 00:19:56,100
what is a non dependent name so a

00:19:52,890 --> 00:19:58,290
dependent name is when we say that a

00:19:56,100 --> 00:20:01,860
name is dependent if he depends somehow

00:19:58,290 --> 00:20:04,310
in a template parameter and I have a

00:20:01,860 --> 00:20:07,570
question for you which of the following

00:20:04,310 --> 00:20:09,760
declarations are typed

00:20:07,570 --> 00:20:12,370
Benin so line number three I want you to

00:20:09,760 --> 00:20:14,680
raise your hand if you believe that line

00:20:12,370 --> 00:20:20,380
number three is actually is actually

00:20:14,680 --> 00:20:22,570
dependent named good and what about the

00:20:20,380 --> 00:20:26,470
second one line number nine is this a

00:20:22,570 --> 00:20:31,690
dependent name raise your hand good

00:20:26,470 --> 00:20:34,420
you're smart exactly it's not exactly

00:20:31,690 --> 00:20:37,660
because we know the type right we have a

00:20:34,420 --> 00:20:41,560
type there so this is simple code what

00:20:37,660 --> 00:20:44,620
about to face look up now non-dependent

00:20:41,560 --> 00:20:46,750
names and qualified or qualified our

00:20:44,620 --> 00:20:50,800
sets are looked up by the rules I've

00:20:46,750 --> 00:20:52,750
described to you but even if they if the

00:20:50,800 --> 00:20:55,540
name is an unqualified dependent name

00:20:52,750 --> 00:20:57,790
there is an extra step at the point of

00:20:55,540 --> 00:21:00,670
the instantiation of the template we

00:20:57,790 --> 00:21:04,360
undergo an argument dependent lookup and

00:21:00,670 --> 00:21:10,540
this can be and this can be explained by

00:21:04,360 --> 00:21:14,050
the following example so we have the

00:21:10,540 --> 00:21:16,990
name space leap and we have two fun we

00:21:14,050 --> 00:21:19,600
have a class named political type and we

00:21:16,990 --> 00:21:22,720
have a function template called process

00:21:19,600 --> 00:21:24,430
and we make an unqualified call and a

00:21:22,720 --> 00:21:26,680
qualified call to connect and this is a

00:21:24,430 --> 00:21:30,360
dependent name so while this template

00:21:26,680 --> 00:21:33,100
well this template is being parsed right

00:21:30,360 --> 00:21:35,320
unqualified lookup finds nothing for

00:21:33,100 --> 00:21:37,930
connect but it's not complete it waits

00:21:35,320 --> 00:21:41,260
until the template is instantiated so

00:21:37,930 --> 00:21:44,110
the compiler proceeds we define water

00:21:41,260 --> 00:21:47,260
pipe and we finally we define also

00:21:44,110 --> 00:21:50,050
connect and inside AIDS we make an

00:21:47,260 --> 00:21:53,800
unqualified call to process and we pass

00:21:50,050 --> 00:21:55,810
an object a specialization of the tank

00:21:53,800 --> 00:21:59,950
off by instantiating the template pipe

00:21:55,810 --> 00:22:02,050
by water pipe and here in that case

00:21:59,950 --> 00:22:04,410
which we care a deal and we have a

00:22:02,050 --> 00:22:08,770
second example here where we explicitly

00:22:04,410 --> 00:22:10,420
put explicitly put the template and the

00:22:08,770 --> 00:22:12,700
template the template the template

00:22:10,420 --> 00:22:14,410
arguments as I need so is the first case

00:22:12,700 --> 00:22:16,900
value from what I've described you so

00:22:14,410 --> 00:22:20,460
far is the first case value is this call

00:22:16,900 --> 00:22:20,460
is this valid code raise your hand

00:22:20,909 --> 00:22:27,640
what about this is this valid code can

00:22:25,960 --> 00:22:36,880
anybody tell me why this is not a valid

00:22:27,640 --> 00:22:38,529
code no could be that case later on but

00:22:36,880 --> 00:22:43,080
that's not what this is what happens

00:22:38,529 --> 00:22:45,820
yeah exactly

00:22:43,080 --> 00:22:48,309
C++ is the context sentence context

00:22:45,820 --> 00:22:51,789
sensitive language right so when we are

00:22:48,309 --> 00:22:54,639
here the compiler first this is a valid

00:22:51,789 --> 00:22:56,919
code right and here when the compiler is

00:22:54,639 --> 00:22:59,260
trying to look up and decide is this a

00:22:56,919 --> 00:23:01,480
pro is this a functional or is this a

00:22:59,260 --> 00:23:05,309
statement of the form process less I

00:23:01,480 --> 00:23:09,159
mean greater than the parenthesis now

00:23:05,309 --> 00:23:10,539
this is a Mexican problem right and it

00:23:09,159 --> 00:23:11,470
cannot be resolved so if you want to

00:23:10,539 --> 00:23:12,730
make it work

00:23:11,470 --> 00:23:15,669
all you need to do is add the

00:23:12,730 --> 00:23:18,549
declaration but in C++ 20 there is a

00:23:15,669 --> 00:23:21,279
paper which actually changes the grammar

00:23:18,549 --> 00:23:22,960
rules so this is valid code in C++ 20

00:23:21,279 --> 00:23:24,730
and yes you're gonna get an error but

00:23:22,960 --> 00:23:26,919
later on and you're gonna get the

00:23:24,730 --> 00:23:30,130
correct error that's the important thing

00:23:26,919 --> 00:23:32,169
now friends and ADL I would like to talk

00:23:30,130 --> 00:23:35,380
a little bit about history here so I was

00:23:32,169 --> 00:23:38,230
born in 1994 and back then it used to be

00:23:35,380 --> 00:23:39,820
the case that in class that the definite

00:23:38,230 --> 00:23:42,340
that in class definitions of friend

00:23:39,820 --> 00:23:44,769
functions we're essentially means that

00:23:42,340 --> 00:23:46,570
they were injected to the outer scope

00:23:44,769 --> 00:23:48,279
they were polluting essentially than

00:23:46,570 --> 00:23:50,470
qualified lookup and I was very

00:23:48,279 --> 00:23:52,870
problematic turns out and later on it

00:23:50,470 --> 00:23:56,200
was replaced by argument dependent Luka

00:23:52,870 --> 00:23:58,960
I'm not gonna go into details of how

00:23:56,200 --> 00:24:00,669
that thing works exactly but I'm gonna

00:23:58,960 --> 00:24:02,919
say to you that if you wanna Google it

00:24:00,669 --> 00:24:07,870
you can search part on a napkin to Bart

00:24:02,919 --> 00:24:12,639
on a napkin trick and now let's see how

00:24:07,870 --> 00:24:15,490
friends work with ADL we have we have a

00:24:12,639 --> 00:24:17,980
library we have a namespace library and

00:24:15,490 --> 00:24:20,019
we have a class we have a class template

00:24:17,980 --> 00:24:23,230
called pipe and we have a friend

00:24:20,019 --> 00:24:25,210
function called connect and here pipe is

00:24:23,230 --> 00:24:30,010
the injected class name right it's

00:24:25,210 --> 00:24:34,940
actually pipe pipe of tea and then later

00:24:30,010 --> 00:24:37,340
on inside AIDS in line 12 we we

00:24:34,940 --> 00:24:38,299
creates us an object and we call connect

00:24:37,340 --> 00:24:40,609
and qualified

00:24:38,299 --> 00:24:43,489
so here again I'm qualified look up

00:24:40,609 --> 00:24:45,559
we'll find nothing but also the argument

00:24:43,489 --> 00:24:47,479
dependent look up we'll find that friend

00:24:45,559 --> 00:24:50,720
and it's important you can use that as

00:24:47,479 --> 00:24:53,599
an optimization because essentially with

00:24:50,720 --> 00:24:55,879
that you're saying hey mind doesn't that

00:24:53,599 --> 00:24:58,279
friend function I wanted to be available

00:24:55,879 --> 00:25:00,379
only by argument dependent lookup and

00:24:58,279 --> 00:25:02,269
not by unqualified lookup it turns out

00:25:00,379 --> 00:25:06,830
that this can be very dangerous because

00:25:02,269 --> 00:25:09,169
if you're if if if if your friend is

00:25:06,830 --> 00:25:11,599
available when qualified lookup and if

00:25:09,169 --> 00:25:14,479
your class supports it can if you can

00:25:11,599 --> 00:25:16,549
construct your object of that class with

00:25:14,479 --> 00:25:18,619
an implicit conversion you might find

00:25:16,549 --> 00:25:21,009
yourself shooting shooting yourself in

00:25:18,619 --> 00:25:21,009
the feet

00:25:28,710 --> 00:25:35,409
now the two and a half step dance right

00:25:32,279 --> 00:25:37,059
so you probably seen this code many of

00:25:35,409 --> 00:25:40,350
you who who of you have seen this code

00:25:37,059 --> 00:25:47,409
can i exactly

00:25:40,350 --> 00:25:50,619
anybody okay so moving on so have a

00:25:47,409 --> 00:25:52,360
namespace user and we have class

00:25:50,619 --> 00:25:55,330
template pipe and we have a function

00:25:52,360 --> 00:25:57,489
process again and we do that we do that

00:25:55,330 --> 00:26:01,509
because we want to be as general as

00:25:57,489 --> 00:26:05,049
possible right I can explain you exactly

00:26:01,509 --> 00:26:07,059
why so first what if T is a type defined

00:26:05,049 --> 00:26:09,609
in the standard library then if that's

00:26:07,059 --> 00:26:11,679
the case then a DL from the rules that

00:26:09,609 --> 00:26:12,369
we've just described will be able to

00:26:11,679 --> 00:26:17,169
read that out

00:26:12,369 --> 00:26:19,989
but what if T is a type that is defined

00:26:17,169 --> 00:26:22,929
in some other namespace and it cannot be

00:26:19,989 --> 00:26:26,200
reached by by the generic it cannot find

00:26:22,929 --> 00:26:28,899
the generic template that actually helps

00:26:26,200 --> 00:26:31,059
us do that and also not only that it

00:26:28,899 --> 00:26:35,080
adds an extra layer that extra layer

00:26:31,059 --> 00:26:38,019
says that if that type T has a

00:26:35,080 --> 00:26:41,019
user-defined overload of swap because

00:26:38,019 --> 00:26:44,679
potentially the user knows better can

00:26:41,019 --> 00:26:47,200
optimize how to swap how to how to swap

00:26:44,679 --> 00:26:50,200
for their own type then in that case is

00:26:47,200 --> 00:26:52,749
gonna pick that overload so not only we

00:26:50,200 --> 00:26:56,710
we are saying around this will work for

00:26:52,749 --> 00:27:00,609
any case right even if the user hasn't

00:26:56,710 --> 00:27:03,129
provided an overload and now we can see

00:27:00,609 --> 00:27:08,139
that okay this is an error this would be

00:27:03,129 --> 00:27:12,159
the same time because t t let's be let's

00:27:08,139 --> 00:27:15,100
be precise and now we call p the process

00:27:12,159 --> 00:27:19,179
and we pass a and B in this works all

00:27:15,100 --> 00:27:21,279
right if inside that type there is an

00:27:19,179 --> 00:27:24,789
overload of swap is gonna be preferred

00:27:21,279 --> 00:27:26,859
and if it's not it's gonna fall back to

00:27:24,789 --> 00:27:31,600
the generic swap it's gonna fall back to

00:27:26,859 --> 00:27:34,840
the students walk and now beaten by ADL

00:27:31,600 --> 00:27:36,419
unconstrained templates and a specified

00:27:34,840 --> 00:27:39,480
behavior

00:27:36,419 --> 00:27:43,769
what will the following

00:27:39,480 --> 00:27:47,039
called call and insights here so

00:27:43,769 --> 00:27:49,350
essentially what we do is we define a

00:27:47,039 --> 00:27:52,350
structure we have a user we have a type

00:27:49,350 --> 00:27:53,789
areas for the instance a for the

00:27:52,350 --> 00:27:55,919
specialization produced by instantiating

00:27:53,789 --> 00:27:58,830
the state pointer with a user type and

00:27:55,919 --> 00:27:59,039
we have typed with exception my type you

00:27:58,830 --> 00:28:02,779
have

00:27:59,039 --> 00:28:05,850
oops in making a qualified calling 9/12

00:28:02,779 --> 00:28:10,669
any insights what's gonna happen here

00:28:05,850 --> 00:28:10,669
what do you think is gonna call anybody

00:28:11,990 --> 00:28:18,049
almost is that the case

00:28:15,049 --> 00:28:18,049
always

00:28:31,800 --> 00:28:41,100
so what does this call Oh

00:28:41,830 --> 00:28:48,520
oh yeah he said that he said sorry they

00:28:45,340 --> 00:28:55,930
said that it will cause to tie which is

00:28:48,520 --> 00:28:59,020
almost correct almost correct exactly

00:28:55,930 --> 00:29:05,820
exactly and this is very dangerous cold

00:28:59,020 --> 00:29:09,730
oh yeah yeah sorry they said that these

00:29:05,820 --> 00:29:11,860
they said that the techs are they said

00:29:09,730 --> 00:29:13,809
that this is a specific behavior because

00:29:11,860 --> 00:29:20,110
we don't know at the standard doesn't my

00:29:13,809 --> 00:29:22,990
date what what memory includes right and

00:29:20,110 --> 00:29:26,920
also have another quest so now let's see

00:29:22,990 --> 00:29:30,550
how that works we call and we're making

00:29:26,920 --> 00:29:33,220
a qualified call to tie here and as we

00:29:30,550 --> 00:29:35,020
said it's to tie find that in the

00:29:33,220 --> 00:29:37,630
overload resolution to be in the Oval of

00:29:35,020 --> 00:29:41,410
the solution results to tie to be a

00:29:37,630 --> 00:29:44,710
better month now now on L on track and

00:29:41,410 --> 00:29:50,170
zcc these finds to tie

00:29:44,710 --> 00:29:51,400
well name is vc it finds user : : ty so

00:29:50,170 --> 00:29:54,880
this code is non-portable

00:29:51,400 --> 00:29:59,160
HUS has any of you fall into this trap

00:29:54,880 --> 00:30:03,490
before there you are

00:29:59,160 --> 00:30:04,150
very very dangerous code right let's

00:30:03,490 --> 00:30:07,660
move on

00:30:04,150 --> 00:30:10,600
beaten by a deal to iterators and

00:30:07,660 --> 00:30:14,550
algorithms anything that behaves like an

00:30:10,600 --> 00:30:14,550
iterator is an iterator do you agree

00:30:16,200 --> 00:30:27,970
can anybody see any problem here no okay

00:30:22,870 --> 00:30:31,570
let's see so we have made an inside main

00:30:27,970 --> 00:30:36,429
we have Aurora and stood array and a

00:30:31,570 --> 00:30:39,280
vector and we call unqualified find so I

00:30:36,429 --> 00:30:42,580
have I have a question here is this

00:30:39,280 --> 00:30:45,450
valid code raise your hand who believes

00:30:42,580 --> 00:30:45,450
that this is actually well

00:30:46,670 --> 00:30:52,860
you have a question or you're asking

00:30:48,780 --> 00:30:55,590
your head this is a vodka okay our

00:30:52,860 --> 00:31:00,240
friend there says it's invalid code what

00:30:55,590 --> 00:31:02,780
about this is this a valid code raise

00:31:00,240 --> 00:31:02,780
your hands

00:31:04,730 --> 00:31:10,440
right

00:31:05,970 --> 00:31:12,540
and what about this the third one maybe

00:31:10,440 --> 00:31:12,900
I like that who said maybe raise your

00:31:12,540 --> 00:31:15,630
hand

00:31:12,900 --> 00:31:19,080
there you are Arthur how many of you

00:31:15,630 --> 00:31:22,740
nice nice you know that I like that so

00:31:19,080 --> 00:31:24,690
the first the first example here a is in

00:31:22,740 --> 00:31:27,270
instar right and what did we say about

00:31:24,690 --> 00:31:30,210
fundamental types in star has no

00:31:27,270 --> 00:31:32,430
associate namespaces and not associate

00:31:30,210 --> 00:31:36,840
entities and therefore this cannot be

00:31:32,430 --> 00:31:38,640
called now what about this this again

00:31:36,840 --> 00:31:42,620
returns an int pointer so this is an

00:31:38,640 --> 00:31:45,480
invalid code but these this is the most

00:31:42,620 --> 00:31:52,830
this is this is the most important part

00:31:45,480 --> 00:31:54,360
this is actually again this is this this

00:31:52,830 --> 00:31:56,040
code is not portable and the reason of

00:31:54,360 --> 00:31:58,040
this code is not portable is because

00:31:56,040 --> 00:32:01,800
that we don't know if the implementation

00:31:58,040 --> 00:32:05,250
does something like type def iterator in

00:32:01,800 --> 00:32:07,320
star it could be a type it could be not

00:32:05,250 --> 00:32:10,260
and if it somehow resolves to be an in

00:32:07,320 --> 00:32:13,200
star then too bad for you your code will

00:32:10,260 --> 00:32:15,870
never be will not be portable so here

00:32:13,200 --> 00:32:19,290
please when you're using standard

00:32:15,870 --> 00:32:23,900
algorithms always qualify your calls

00:32:19,290 --> 00:32:23,900
right always qualify your calls we stood

00:32:31,250 --> 00:32:39,059
and now some guidelines now always

00:32:36,390 --> 00:32:41,730
remember the interface principle right

00:32:39,059 --> 00:32:44,610
it comes from help-help solder in and

00:32:41,730 --> 00:32:47,970
really it's Andres key so keep it tight

00:32:44,610 --> 00:32:49,200
keep the types and it's non-member

00:32:47,970 --> 00:32:52,980
functions that are supposed to be

00:32:49,200 --> 00:32:54,710
together in the same namespace and if

00:32:52,980 --> 00:32:58,409
they're not meant to be used together

00:32:54,710 --> 00:33:02,010
then in that case put them in a

00:32:58,409 --> 00:33:02,909
different namespace the second here

00:33:02,010 --> 00:33:05,130
comes from me

00:33:02,909 --> 00:33:07,020
always qualifies calls to the STD

00:33:05,130 --> 00:33:09,419
algorithms right I find it to be the

00:33:07,020 --> 00:33:12,720
best practice and I never had any

00:33:09,419 --> 00:33:16,740
problem in practice and these two are

00:33:12,720 --> 00:33:19,020
coming from the C++ core guidelines and

00:33:16,740 --> 00:33:20,789
avoid high highly visible unconstrained

00:33:19,020 --> 00:33:23,549
templates with common names and this is

00:33:20,789 --> 00:33:26,429
actually the case there was a bug in ll

00:33:23,549 --> 00:33:30,090
in LLVM Thank You Arthur for that of

00:33:26,429 --> 00:33:33,480
stood apply and they had renamed it to

00:33:30,090 --> 00:33:37,260
select because it messed up withstood

00:33:33,480 --> 00:33:39,419
apply and define overload operators in

00:33:37,260 --> 00:33:41,280
the namespaces of the operands that's

00:33:39,419 --> 00:33:45,539
actually the interface principle and

00:33:41,280 --> 00:33:47,880
also I'm gonna adhere prefer to make

00:33:45,539 --> 00:33:50,640
them a friend right and define them in

00:33:47,880 --> 00:33:52,770
class that way you you don't pollute and

00:33:50,640 --> 00:33:57,059
qualified lookup and you have an extra

00:33:52,770 --> 00:33:59,159
safety net under your belt and now let's

00:33:57,059 --> 00:34:03,090
talk about when the net code doesn't

00:33:59,159 --> 00:34:06,809
quite cut it so you know that generic

00:34:03,090 --> 00:34:09,629
code doesn't always not always optimized

00:34:06,809 --> 00:34:12,480
for user-defined types and I can give

00:34:09,629 --> 00:34:14,849
you an example for that right swap swap

00:34:12,480 --> 00:34:16,740
is generic enough but sometimes maybe

00:34:14,849 --> 00:34:19,889
there is some maybe the user knows

00:34:16,740 --> 00:34:22,409
better and as a library you wanna cover

00:34:19,889 --> 00:34:24,119
you wanna do two things right you wanna

00:34:22,409 --> 00:34:27,570
do the first thing is that you want to

00:34:24,119 --> 00:34:31,980
cover the general cases intuitively but

00:34:27,570 --> 00:34:35,730
also allow the user to to customize the

00:34:31,980 --> 00:34:38,369
behavior when that is required and you

00:34:35,730 --> 00:34:40,859
can imagine that right we have suppose

00:34:38,369 --> 00:34:42,959
we have the libraries to suppose we

00:34:40,859 --> 00:34:46,950
we make a call to suit swap princes

00:34:42,959 --> 00:34:49,859
stood swap races call swap and qualified

00:34:46,950 --> 00:34:52,139
and there is only does so is that well

00:34:49,859 --> 00:34:54,059
if you haven't defined Europe your

00:34:52,139 --> 00:34:56,879
overload then it's gonna fall back to

00:34:54,059 --> 00:34:58,709
the generic case they stood swap but if

00:34:56,879 --> 00:35:01,229
you define your overload it's gonna

00:34:58,709 --> 00:35:03,660
prefer that over the cinetic

00:35:01,229 --> 00:35:06,150
implementation so it essentially the

00:35:03,660 --> 00:35:08,640
library from a library's point of view

00:35:06,150 --> 00:35:12,479
you get both of both of the best Wars

00:35:08,640 --> 00:35:16,109
you you you you get in the general case

00:35:12,479 --> 00:35:18,029
and the customer's case and also begin

00:35:16,109 --> 00:35:19,380
is also customized at some point is its

00:35:18,029 --> 00:35:21,749
customization point it's called and

00:35:19,380 --> 00:35:24,209
qualified for the the range for loop

00:35:21,749 --> 00:35:28,709
right it calls begin and end I'm

00:35:24,209 --> 00:35:34,529
qualified now let's see how they

00:35:28,709 --> 00:35:36,930
actually work so here we overlook swap

00:35:34,529 --> 00:35:40,979
we have my type we overloaded for our

00:35:36,930 --> 00:35:42,539
own for our own type and we feel it with

00:35:40,979 --> 00:35:47,819
random input it's supposed heaven in

00:35:42,539 --> 00:35:51,390
here that's and we call swap ranges with

00:35:47,819 --> 00:35:54,180
begin and and essentially this will call

00:35:51,390 --> 00:35:56,519
the user overload but there are

00:35:54,180 --> 00:36:00,809
downfalls to that there are downfalls

00:35:56,519 --> 00:36:05,160
can anybody point them out why is this

00:36:00,809 --> 00:36:13,559
is good code but what why is the problem

00:36:05,160 --> 00:36:16,609
with this code any of you there are two

00:36:13,559 --> 00:36:16,609
things here

00:36:18,950 --> 00:36:47,240
no no sorry no oh sorry can you repeat

00:36:39,180 --> 00:36:47,240
your question yeah I'm sorry

00:36:51,140 --> 00:37:01,520
yes no there is no ambiguity but no no

00:37:01,880 --> 00:37:19,530
no now two things the first up please

00:37:08,069 --> 00:37:52,770
Chris no yeah is it because I want to

00:37:19,530 --> 00:37:53,190
put using declarations no no no that's

00:37:52,770 --> 00:37:55,260
not it

00:37:53,190 --> 00:37:56,549
so there are two things here okay okay

00:37:55,260 --> 00:37:59,010
there are two things you there are two

00:37:56,549 --> 00:38:00,990
things here first with the first one is

00:37:59,010 --> 00:38:02,940
that we can't we can't pass swap as a

00:38:00,990 --> 00:38:04,559
first class object right if we have some

00:38:02,940 --> 00:38:06,630
generic algorithm we can't really pass

00:38:04,559 --> 00:38:09,390
swap right it's not gonna it's not gonna

00:38:06,630 --> 00:38:09,750
work very well and the second thing all

00:38:09,390 --> 00:38:12,030
right

00:38:09,750 --> 00:38:15,210
the second thing is I expect that's

00:38:12,030 --> 00:38:20,339
that's pre C++ 17 swap was unconstrained

00:38:15,210 --> 00:38:23,520
right so if the user overloaded swap in

00:38:20,339 --> 00:38:27,150
a way that it would pass the constraints

00:38:23,520 --> 00:38:29,220
of the mainstay of stood swap it would

00:38:27,150 --> 00:38:31,200
be called and imagine that

00:38:29,220 --> 00:38:33,720
I can give you an example imagine begin

00:38:31,200 --> 00:38:35,780
begin must return an iterator or

00:38:33,720 --> 00:38:38,910
something that behaves like an iterator

00:38:35,780 --> 00:38:42,390
worry if you make it return avoid it's

00:38:38,910 --> 00:38:46,520
not gonna be checked pretty C++ 17 and

00:38:42,390 --> 00:38:49,130
the solution to that it's actually

00:38:46,520 --> 00:38:51,599
customisation porn objects and

00:38:49,130 --> 00:38:54,660
customisation point objects essentially

00:38:51,599 --> 00:38:56,369
do ADL on the user's behalf and they are

00:38:54,660 --> 00:38:59,130
objects and the best part is that you

00:38:56,369 --> 00:39:01,500
can also pass them around and they gonna

00:38:59,130 --> 00:39:04,800
do the right thing for you no matter

00:39:01,500 --> 00:39:07,109
what and this is this is the approach

00:39:04,800 --> 00:39:10,050
that is followed by the ranges by the

00:39:07,109 --> 00:39:12,000
ranges library and we're gonna play I'm

00:39:10,050 --> 00:39:13,980
gonna present you here a simplified

00:39:12,000 --> 00:39:16,109
version of it but if you want you can

00:39:13,980 --> 00:39:18,660
take that and you can build upon that

00:39:16,109 --> 00:39:22,410
and you gonna race to the axle arrange

00:39:18,660 --> 00:39:30,869
this v3 implementation now customization

00:39:22,410 --> 00:39:33,060
sorry moving on suppose we have here we

00:39:30,869 --> 00:39:36,750
have a namespace library and we have the

00:39:33,060 --> 00:39:38,430
namespace detail and inside here we have

00:39:36,750 --> 00:39:39,569
the poison pill which I'm going to

00:39:38,430 --> 00:39:42,200
explain to you shortly

00:39:39,569 --> 00:39:45,350
what exactly does

00:39:42,200 --> 00:39:45,350
[Music]

00:39:48,850 --> 00:39:57,410
and yeah here's a poison pill and then

00:39:53,300 --> 00:40:00,560
if there is any user define oh I'm sorry

00:39:57,410 --> 00:40:02,840
let me repeat myself so we have a

00:40:00,560 --> 00:40:05,540
function template try to swap and it

00:40:02,840 --> 00:40:08,600
accepts a mint and this thing over here

00:40:05,540 --> 00:40:12,020
it's FINA friendly right essentially it

00:40:08,600 --> 00:40:15,140
tries to call swap unqualified and if it

00:40:12,020 --> 00:40:18,260
finds an overload that's actually valid

00:40:15,140 --> 00:40:21,770
code if it doesn't find an overload then

00:40:18,260 --> 00:40:26,270
this will be removed by spinner and it's

00:40:21,770 --> 00:40:30,730
gonna fall back to to the try and swap

00:40:26,270 --> 00:40:35,450
to this person and also the poison pill

00:40:30,730 --> 00:40:38,300
protect us from from pooling stood swap

00:40:35,450 --> 00:40:41,150
right if somehow the type that we pass

00:40:38,300 --> 00:40:44,030
has the standard as the associate

00:40:41,150 --> 00:40:46,370
namespace these will make these

00:40:44,030 --> 00:40:48,920
ambiguous and therefore we're gonna fall

00:40:46,370 --> 00:40:52,640
back to the know a deal tag so no matter

00:40:48,920 --> 00:40:58,880
what no matter any circumstance stood

00:40:52,640 --> 00:41:01,610
Schwab will not be considered and here

00:40:58,880 --> 00:41:05,390
we define a type trait and essentially

00:41:01,610 --> 00:41:10,400
this type trace tries to call swap with

00:41:05,390 --> 00:41:12,620
a value 42 and of course if if that

00:41:10,400 --> 00:41:15,110
thing is valid is gonna call it's gonna

00:41:12,620 --> 00:41:17,030
call it and if not it's gonna fall back

00:41:15,110 --> 00:41:20,030
to this case and what's a return type

00:41:17,030 --> 00:41:24,200
it's no a deal tag and we're using is

00:41:20,030 --> 00:41:26,870
same V and if it's equal to the no a

00:41:24,200 --> 00:41:29,240
deal talk then it means that there is no

00:41:26,870 --> 00:41:31,820
idea there's there's no overload but if

00:41:29,240 --> 00:41:36,860
it is then there is an overload and that

00:41:31,820 --> 00:41:40,640
type trade is true now here we have a

00:41:36,860 --> 00:41:44,570
structure and we have is called swap -

00:41:40,640 --> 00:41:47,510
and inside that we template ties the

00:41:44,570 --> 00:41:50,870
collaborator and we templates that ties

00:41:47,510 --> 00:41:55,400
it in a way that if it's a deal

00:41:50,870 --> 00:41:58,670
swappable then we will call we will

00:41:55,400 --> 00:42:00,470
return the call and a qualified call to

00:41:58,670 --> 00:42:06,200
swap and we know that already

00:42:00,470 --> 00:42:12,859
gonna call the user overload and now

00:42:06,200 --> 00:42:16,250
here we fall back and we enable these in

00:42:12,859 --> 00:42:18,830
the case and we enable this in the case

00:42:16,250 --> 00:42:21,560
but there is no user-defined overly and

00:42:18,830 --> 00:42:23,930
we can fall back to some implementation

00:42:21,560 --> 00:42:27,320
that we have in some detail namespace

00:42:23,930 --> 00:42:31,640
and I must not here that the poison pill

00:42:27,320 --> 00:42:34,310
is according sorry I think that the

00:42:31,640 --> 00:42:36,890
poison pill is not really needed and the

00:42:34,310 --> 00:42:39,859
reason is that stood shop is now

00:42:36,890 --> 00:42:42,580
constrained so there is no there's there

00:42:39,859 --> 00:42:47,020
isn't any case where it will read salt

00:42:42,580 --> 00:42:50,570
stood swab now we do this and

00:42:47,020 --> 00:42:53,060
essentially this actually makes an

00:42:50,570 --> 00:42:55,760
object and now swap is an object swap is

00:42:53,060 --> 00:42:58,359
no longer a function it's an object so

00:42:55,760 --> 00:43:02,900
we can pass it around and if we can pass

00:42:58,359 --> 00:43:07,010
in quotes stood swap around and it does

00:43:02,900 --> 00:43:09,200
you know it does does a deal for us we

00:43:07,010 --> 00:43:11,869
have a first class function that we can

00:43:09,200 --> 00:43:15,859
use in our algorithms and this is very

00:43:11,869 --> 00:43:18,920
powerful now let me give you an example

00:43:15,859 --> 00:43:20,900
of that right the user name space by the

00:43:18,920 --> 00:43:25,760
way this has an address right it's an

00:43:20,900 --> 00:43:28,940
object it exists and here inside we have

00:43:25,760 --> 00:43:34,030
a class template pipe and we stands it

00:43:28,940 --> 00:43:38,510
pipe with a vector of int and later on

00:43:34,030 --> 00:43:43,790
we swap we overload swap for our user

00:43:38,510 --> 00:43:46,880
defined type and here in our function or

00:43:43,790 --> 00:43:52,070
in our function f we create two objects

00:43:46,880 --> 00:43:55,460
of this type and we call leap colon

00:43:52,070 --> 00:43:57,380
colon swap p1 p2 and this is beautiful

00:43:55,460 --> 00:44:00,500
because essentially it goes but here

00:43:57,380 --> 00:44:02,690
because this is a template right now the

00:44:00,500 --> 00:44:06,280
type that action kicks in and says oh

00:44:02,690 --> 00:44:09,200
easily user define overload yes there is

00:44:06,280 --> 00:44:09,980
instantiate this and it resolves the

00:44:09,200 --> 00:44:14,340
right call

00:44:09,980 --> 00:44:17,340
what if what if we

00:44:14,340 --> 00:44:19,500
what if we had using lip swap here would

00:44:17,340 --> 00:44:22,110
it be any different we would do would we

00:44:19,500 --> 00:44:24,080
have any different behavior can you

00:44:22,110 --> 00:44:27,090
raise your hands

00:44:24,080 --> 00:44:31,140
exactly we get the same behavior all

00:44:27,090 --> 00:44:34,890
right so no matter what we do we always

00:44:31,140 --> 00:44:36,990
end up having a deal having the

00:44:34,890 --> 00:44:40,950
customisation point object doing a deal

00:44:36,990 --> 00:44:44,310
for us and as I said previously we can

00:44:40,950 --> 00:44:49,680
we can also we can also call any

00:44:44,310 --> 00:44:51,900
algorithm and we can pass the swap by

00:44:49,680 --> 00:44:54,780
the way this would be this building

00:44:51,900 --> 00:44:58,620
called Lib : : swap right and in that

00:44:54,780 --> 00:45:02,490
case inside that algorithm it would

00:44:58,620 --> 00:45:04,830
resolve to the user overload so we get

00:45:02,490 --> 00:45:07,320
both of the best words and the best part

00:45:04,830 --> 00:45:09,660
is is that they're they're the

00:45:07,320 --> 00:45:13,050
constraints are not bypassed and we can

00:45:09,660 --> 00:45:14,850
do the same design for begin and it's

00:45:13,050 --> 00:45:16,980
even more powerful because we can add

00:45:14,850 --> 00:45:18,810
more spinny overloads we can take if

00:45:16,980 --> 00:45:20,790
there is a member but if there is a

00:45:18,810 --> 00:45:25,740
member prefer the member we are

00:45:20,790 --> 00:45:30,150
essentially controlling the controlling

00:45:25,740 --> 00:45:35,940
both ADL in the overall resolution this

00:45:30,150 --> 00:45:38,370
design is very powerful and that's me

00:45:35,940 --> 00:45:39,950
thank you for listening do you have any

00:45:38,370 --> 00:45:45,809
questions

00:45:39,950 --> 00:45:45,809
[Applause]

00:45:47,440 --> 00:45:52,609
hi thank you for the talk that was good

00:45:50,089 --> 00:45:57,019
just go back to this 61 I think your

00:45:52,609 --> 00:46:08,440
list of guidelines 61 I think your list

00:45:57,019 --> 00:46:19,160
of guidelines no I think it's after that

00:46:08,440 --> 00:46:25,789
SIG's oh yeah sorry oh you said six no

00:46:19,160 --> 00:46:29,450
that's it so speaking as a library

00:46:25,789 --> 00:46:33,230
maintainer herb and Andrei our speaking

00:46:29,450 --> 00:46:35,779
truths if you can promise that the

00:46:33,230 --> 00:46:36,380
namespaces and types will never ever

00:46:35,779 --> 00:46:39,259
change

00:46:36,380 --> 00:46:41,180
he even even names business the name

00:46:39,259 --> 00:46:42,710
spaces for your functions and the name

00:46:41,180 --> 00:46:46,940
spaces for your types will never ever

00:46:42,710 --> 00:46:51,829
change that is not really very well

00:46:46,940 --> 00:46:53,089
guaranteed as the chair for library

00:46:51,829 --> 00:46:55,249
evolution

00:46:53,089 --> 00:46:57,619
I'm deeply hoping that we're gonna

00:46:55,249 --> 00:47:00,289
change a whole lot of stuff out of stood

00:46:57,619 --> 00:47:06,049
ranges into stood over it like the next

00:47:00,289 --> 00:47:08,809
10 years unless your library maintainer

00:47:06,049 --> 00:47:11,480
actually promises for all time these two

00:47:08,809 --> 00:47:16,239
things come together don't rely on a

00:47:11,480 --> 00:47:19,069
deal like so they're there guidance is

00:47:16,239 --> 00:47:19,940
good for short-term programming bad for

00:47:19,069 --> 00:47:22,130
long term vertically

00:47:19,940 --> 00:47:23,839
that'd be my suggestion thank you very

00:47:22,130 --> 00:47:26,359
much for your coming are we appreciated

00:47:23,839 --> 00:47:28,999
I guess they have a discussion in the

00:47:26,359 --> 00:47:32,539
comments here it strikes me that that's

00:47:28,999 --> 00:47:35,329
sort of a special case of if you put

00:47:32,539 --> 00:47:37,759
things in the same namespace you may be

00:47:35,329 --> 00:47:40,050
implying that they are part of the same

00:47:37,759 --> 00:47:42,480
non-member interface

00:47:40,050 --> 00:47:45,480
right the fact that for example stood

00:47:42,480 --> 00:47:49,230
swab is in the same namespaces that

00:47:45,480 --> 00:47:50,610
vector implies maybe a relationship

00:47:49,230 --> 00:47:57,060
there but then we also have things like

00:47:50,610 --> 00:47:58,500
stood named functions did bind is it the

00:47:57,060 --> 00:48:00,780
same namespace withstood vector and

00:47:58,500 --> 00:48:02,970
that's more of an accidental historical

00:48:00,780 --> 00:48:04,530
artifact and there is no distinction

00:48:02,970 --> 00:48:05,940
between the two and wouldn't it be nice

00:48:04,530 --> 00:48:07,620
if there were but the only tool we have

00:48:05,940 --> 00:48:09,210
for that I think is make lots of little

00:48:07,620 --> 00:48:12,530
namespaces I don't think anyone wants to

00:48:09,210 --> 00:48:18,710
do that either so it's a mess

00:48:12,530 --> 00:48:21,330
thank you could you elaborate on how

00:48:18,710 --> 00:48:22,560
introducing new scopes contest that I'm

00:48:21,330 --> 00:48:25,140
guessing that just introduces ambiguity

00:48:22,560 --> 00:48:26,870
rather than if you there's one spot

00:48:25,140 --> 00:48:30,000
where you introduced using student begin

00:48:26,870 --> 00:48:32,000
the function and other times where you

00:48:30,000 --> 00:48:34,470
can entirely bring in another namespace

00:48:32,000 --> 00:48:36,900
why would we not bring the whole

00:48:34,470 --> 00:48:38,820
namespace oh no could you just elaborate

00:48:36,900 --> 00:48:40,680
on there are times where I might need to

00:48:38,820 --> 00:48:45,620
use operator stream insertion or an

00:48:40,680 --> 00:48:48,480
inheriting constructor because using

00:48:45,620 --> 00:48:50,370
using directives are not included in the

00:48:48,480 --> 00:48:52,140
set of the argument dependent okay so

00:48:50,370 --> 00:48:54,450
you need to do a declaration you need to

00:48:52,140 --> 00:48:58,890
say hey using to be king or using

00:48:54,450 --> 00:49:02,100
student that you still need them for

00:48:58,890 --> 00:49:03,960
scope resolution Scott resolution short

00:49:02,100 --> 00:49:05,670
circuit for example if I have a parent

00:49:03,960 --> 00:49:07,800
class that has a function that I choose

00:49:05,670 --> 00:49:11,010
not to overload and can you give me an

00:49:07,800 --> 00:49:12,570
example probably not one that I could

00:49:11,010 --> 00:49:16,560
express in words too quickly even though

00:49:12,570 --> 00:49:17,850
I was just about to try Brady's a

00:49:16,560 --> 00:49:19,050
question might be better served for

00:49:17,850 --> 00:49:20,720
after then I was just searching for

00:49:19,050 --> 00:49:26,160
using statements though they seem to be

00:49:20,720 --> 00:49:29,220
finicky yeah I want to know if I say

00:49:26,160 --> 00:49:31,320
using this opera or stood operator

00:49:29,220 --> 00:49:32,910
stream insertion for example I'm not

00:49:31,320 --> 00:49:34,710
talking about using namespace I'm

00:49:32,910 --> 00:49:36,180
talking about a particular asexual

00:49:34,710 --> 00:49:39,210
instance does that bring in everything

00:49:36,180 --> 00:49:40,830
from that namespace no secularism in

00:49:39,210 --> 00:49:42,330
oxalates it declares in green C does a

00:49:40,830 --> 00:49:45,570
declaration in to your local scope

00:49:42,330 --> 00:49:48,270
that's what he does okay does it doesn't

00:49:45,570 --> 00:49:50,070
answer your question to the best of your

00:49:48,270 --> 00:49:54,289
understanding I suppose I probably have

00:49:50,070 --> 00:49:58,380
to think about it a bit more thank you

00:49:54,289 --> 00:50:02,430
yes if I could rephrase my understanding

00:49:58,380 --> 00:50:04,769
of part of that question you might one

00:50:02,430 --> 00:50:07,019
might ask why do I have to say using

00:50:04,769 --> 00:50:09,359
stead swap and using stood begin but I

00:50:07,019 --> 00:50:11,730
don't have to say using something

00:50:09,359 --> 00:50:12,990
operator you know plus are using

00:50:11,730 --> 00:50:18,630
operator left shift

00:50:12,990 --> 00:50:20,430
aren't those also found by ADL and the

00:50:18,630 --> 00:50:23,400
reason that you have to say using stood

00:50:20,430 --> 00:50:28,650
swap is because you want to not only use

00:50:23,400 --> 00:50:32,640
ADL but also fall back to eat in a spin

00:50:28,650 --> 00:50:35,220
swap even for things like pointers so by

00:50:32,640 --> 00:50:40,190
saying using your saying of a fall back

00:50:35,220 --> 00:50:42,119
path that you want to use when ADL fails

00:50:40,190 --> 00:50:45,079
using is actually bringing things into

00:50:42,119 --> 00:50:45,079
the unqualified

00:50:52,480 --> 00:51:10,060
I believe that is what you think anybody

00:51:03,310 --> 00:51:13,260
else thank you

00:51:10,060 --> 00:51:13,260

YouTube URL: https://www.youtube.com/watch?v=u1iewQYkYGE


