Title: CppCon 2019: Mark Isaacson “Making Testing C++ Binaries Practical @ Facebook Scale: A CI Story”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
When you have thousands of C++ services and you've just changed a core library, how do you make sure nothing broke? In 2016 we explored what that looks like from the perspective of the engineer changing the library (https://youtu.be/_YzUD9FvQlg). Now we're going to look at that same problem from perspective of an engineer working on developer experience, providing that safety, all the while trying to make sure we don't break the bank in machine costs. We'll notice patterns, including how saving machines nearly always means saving developer time and making build/test signal less flaky and more trustworthy. Better savings, better experience.

Most practically for you: we'll go over what can you do in your codebase to improve your testing workflows, ranging from low commitment concepts to high commitment ones. Also importantly: what anti-patterns can you avoid, so that you don't blockade future work in this area.

Our exploration will take us across topics including build tools, how the compiler/linker fits into the story, caching in unexpected places, deciding what to test (in great depth), batching, patterns/anti-patterns for defining workflows, and more. We will talk about real learnings from metric-driven changes to our core continuous integration experiences.
— 
Mark Isaacson
Software Engineer, Facebook
Mark Isaacson is a Software Engineer at Facebook, where he works on improving the developer experience for all C++ programmers at Facebook.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,310 --> 00:00:14,100
welcome everyone I'm mark we're gonna

00:00:11,400 --> 00:00:16,770
talk today about making testing

00:00:14,100 --> 00:00:18,990
practical at scale and what that really

00:00:16,770 --> 00:00:20,820
means now some of you might have joined

00:00:18,990 --> 00:00:22,950
me back in 2016

00:00:20,820 --> 00:00:24,869
presented a talk kind of about a very

00:00:22,950 --> 00:00:27,810
similar idea but from a very different

00:00:24,869 --> 00:00:29,220
perspective so last time I asked you to

00:00:27,810 --> 00:00:30,840
be kind of in your own shoes right a

00:00:29,220 --> 00:00:32,550
developer you're working on some change

00:00:30,840 --> 00:00:34,860
for the codebase and really what you're

00:00:32,550 --> 00:00:37,680
worried about is how can I not break

00:00:34,860 --> 00:00:39,000
things what does it what does the the

00:00:37,680 --> 00:00:40,620
workflow need to look like to make sure

00:00:39,000 --> 00:00:42,030
that I have extreme confidence that I'm

00:00:40,620 --> 00:00:43,590
not about to break my own product I'm

00:00:42,030 --> 00:00:45,870
not about to break something

00:00:43,590 --> 00:00:47,129
that that people depend on my stuff that

00:00:45,870 --> 00:00:49,140
fundamentally whatever you're doing is

00:00:47,129 --> 00:00:51,899
correct and we went through kind of the

00:00:49,140 --> 00:00:53,100
whole life cycle of a DIF at Facebook

00:00:51,899 --> 00:00:56,190
when we started with while you're on

00:00:53,100 --> 00:00:57,840
your dev server right you've got linters

00:00:56,190 --> 00:01:00,329
which we're gonna point out bugs you've

00:00:57,840 --> 00:01:01,980
got post-processing address sanitizer

00:01:00,329 --> 00:01:03,510
stack traces to help you make those bugs

00:01:01,980 --> 00:01:05,520
more clear more obvious for folks who

00:01:03,510 --> 00:01:08,670
aren't at cpp con and using address

00:01:05,520 --> 00:01:10,560
sanitizer hopefully everyday we go into

00:01:08,670 --> 00:01:12,780
our diff workflow we're talking about

00:01:10,560 --> 00:01:14,100
how we select we're gonna run all the

00:01:12,780 --> 00:01:16,560
builds and tests that you need to be

00:01:14,100 --> 00:01:18,000
sure that you're safe there's a human

00:01:16,560 --> 00:01:19,770
component eventually you push the code

00:01:18,000 --> 00:01:22,110
suppose that didn't work you broke

00:01:19,770 --> 00:01:23,700
something fine um we've got continuous

00:01:22,110 --> 00:01:25,439
run these are cron jobs running in the

00:01:23,700 --> 00:01:27,030
background they they catch whatever

00:01:25,439 --> 00:01:28,799
mistakes you've gotten trunk they file a

00:01:27,030 --> 00:01:31,530
task on you to go fix it retroactively

00:01:28,799 --> 00:01:32,759
Li a ok and lastly and we didn't spend

00:01:31,530 --> 00:01:34,350
much time on this there's a deployment

00:01:32,759 --> 00:01:36,150
pipeline where maybe you're doing

00:01:34,350 --> 00:01:37,500
shadowing of production traffic maybe

00:01:36,150 --> 00:01:40,590
you've got end-to-end tests something

00:01:37,500 --> 00:01:42,570
more expensive so last time the the

00:01:40,590 --> 00:01:44,310
whole idea was how do you not break

00:01:42,570 --> 00:01:46,400
things here's the whole workflow that's

00:01:44,310 --> 00:01:48,390
designed to make that happen

00:01:46,400 --> 00:01:51,360
today we're covering a very similar

00:01:48,390 --> 00:01:53,189
space but I'm asking you to do me a

00:01:51,360 --> 00:01:55,170
favor which is step in my shoes a little

00:01:53,189 --> 00:01:59,060
bit and I want to give you just a little

00:01:55,170 --> 00:02:01,920
bit of context I am an imposter right I

00:01:59,060 --> 00:02:05,610
haven't written production C++ in four

00:02:01,920 --> 00:02:08,100
years and yet here I am so what am i

00:02:05,610 --> 00:02:10,500
doing what what happened because I left

00:02:08,100 --> 00:02:13,650
University doing C++ that was what I

00:02:10,500 --> 00:02:16,680
wanted to do forever and I show up at

00:02:13,650 --> 00:02:18,780
Facebook and I'm asking myself how can I

00:02:16,680 --> 00:02:22,090
best contribute to the C++ community at

00:02:18,780 --> 00:02:24,910
the company and at the time for me for

00:02:22,090 --> 00:02:26,470
for my money the the obvious answer was

00:02:24,910 --> 00:02:28,540
our continuous integration needed a lot

00:02:26,470 --> 00:02:31,330
of love and so I've been working on that

00:02:28,540 --> 00:02:32,709
ever since and for all of you lovely

00:02:31,330 --> 00:02:35,470
people who are actually writing that

00:02:32,709 --> 00:02:38,530
code so my goals are very similar to

00:02:35,470 --> 00:02:41,140
your goals I expect um right we want to

00:02:38,530 --> 00:02:42,700
help you find all of those bugs but we

00:02:41,140 --> 00:02:43,840
also want to help you find those results

00:02:42,700 --> 00:02:45,370
very quickly you know of course you

00:02:43,840 --> 00:02:47,230
don't want to spend a lot of time

00:02:45,370 --> 00:02:49,000
waiting for results we want to minimize

00:02:47,230 --> 00:02:51,129
the impact of whatever tests flakiness

00:02:49,000 --> 00:02:52,390
happens to exist in the codebase because

00:02:51,129 --> 00:02:53,920
if you've got a large code base there's

00:02:52,390 --> 00:02:56,319
gonna be some tests that are flaky and

00:02:53,920 --> 00:02:58,569
then lastly and this one's maybe more

00:02:56,319 --> 00:02:59,829
for me than for you it's we got to

00:02:58,569 --> 00:03:01,660
survive at scale we have to figure out

00:02:59,829 --> 00:03:04,390
how to actually provide that experience

00:03:01,660 --> 00:03:07,239
in a way that's reasonable and that's

00:03:04,390 --> 00:03:09,819
where we're gonna be focusing today now

00:03:07,239 --> 00:03:12,819
just to really spell this out today our

00:03:09,819 --> 00:03:14,950
goal is get that same high level of bar

00:03:12,819 --> 00:03:16,870
of safety that we talked about in 2016

00:03:14,950 --> 00:03:18,760
but doing way less work in the process

00:03:16,870 --> 00:03:21,879
that's what we're gonna be doing today

00:03:18,760 --> 00:03:23,860
now this talk isn't interesting if

00:03:21,879 --> 00:03:25,810
there's no scale there is no talk if

00:03:23,860 --> 00:03:27,310
there's no scale right if you have one

00:03:25,810 --> 00:03:28,900
project with a hundred thousand lines of

00:03:27,310 --> 00:03:31,269
code or maybe you just have a few kind

00:03:28,900 --> 00:03:33,310
of smaller projects you've got hard

00:03:31,269 --> 00:03:34,030
problems no doubt but this is a

00:03:33,310 --> 00:03:36,700
different beast

00:03:34,030 --> 00:03:38,380
so we've got thousands of developers

00:03:36,700 --> 00:03:40,209
we've got millions of files in our

00:03:38,380 --> 00:03:43,329
largest repos one of our repos contains

00:03:40,209 --> 00:03:44,530
most of our C++ and we've got developers

00:03:43,329 --> 00:03:46,000
and offices around the world right

00:03:44,530 --> 00:03:47,859
people are writing code all the time and

00:03:46,000 --> 00:03:50,590
the moment it hits drunk it's not at

00:03:47,859 --> 00:03:52,180
deployment but it's on its way right it

00:03:50,590 --> 00:03:55,450
is on a pathway to being deployed

00:03:52,180 --> 00:03:58,209
potentially very quickly so all of that

00:03:55,450 --> 00:04:02,230
means look the problem of not breaking

00:03:58,209 --> 00:04:04,329
stuff matters and it's difficult so

00:04:02,230 --> 00:04:06,340
going back our journey we want to

00:04:04,329 --> 00:04:08,590
provide a high rigorous bar of safety

00:04:06,340 --> 00:04:10,060
doing a lot less work that is the scale

00:04:08,590 --> 00:04:13,690
we're talking about that is why we're

00:04:10,060 --> 00:04:16,000
here how are we gonna do it well caching

00:04:13,690 --> 00:04:17,620
thing number one we're gonna be talking

00:04:16,000 --> 00:04:18,910
about build graph heuristics and we're

00:04:17,620 --> 00:04:20,229
gonna see that this is kind of a zoomed

00:04:18,910 --> 00:04:22,930
out version of

00:04:20,229 --> 00:04:25,300
c-plus builds are hard and/or slow right

00:04:22,930 --> 00:04:28,240
that classic C++ problem is gonna show

00:04:25,300 --> 00:04:30,909
up here as well at the toward the tail

00:04:28,240 --> 00:04:32,320
end of this talk I'm gonna go into how

00:04:30,909 --> 00:04:34,330
you might configure continuous

00:04:32,320 --> 00:04:35,440
integration and anti patterns that are

00:04:34,330 --> 00:04:37,600
going to make it really

00:04:35,440 --> 00:04:38,980
difficult to actually optimize any of

00:04:37,600 --> 00:04:41,170
those goals we talked about either the

00:04:38,980 --> 00:04:42,460
amount of resources you need the amount

00:04:41,170 --> 00:04:44,530
of time it takes for results to come

00:04:42,460 --> 00:04:46,390
back the flakiness things that on the

00:04:44,530 --> 00:04:47,200
face of it seem like very tempting

00:04:46,390 --> 00:04:48,820
things you'd want to be able to

00:04:47,200 --> 00:04:50,140
configure but that just blow up in your

00:04:48,820 --> 00:04:54,190
face and they're not actually great

00:04:50,140 --> 00:04:56,080
ideas now you might be wondering I

00:04:54,190 --> 00:04:58,330
imagine rightly at this point in the

00:04:56,080 --> 00:05:00,550
talk this guy's just admitted to us he

00:04:58,330 --> 00:05:02,320
doesn't write C++ where's the C++ in

00:05:00,550 --> 00:05:04,750
this talk spoiler alert there's not a

00:05:02,320 --> 00:05:08,110
single line of code in this talk so

00:05:04,750 --> 00:05:09,910
where's the C++ alright well I'm gonna

00:05:08,110 --> 00:05:11,530
ask you another favor which is I want

00:05:09,910 --> 00:05:14,050
you to be asking that question to

00:05:11,530 --> 00:05:15,850
yourself the entire way through I want

00:05:14,050 --> 00:05:17,740
you to ask yourself how would this be

00:05:15,850 --> 00:05:19,570
different if we were instead talking

00:05:17,740 --> 00:05:21,400
about writing back in services in Python

00:05:19,570 --> 00:05:22,960
if we were talking about writing mobile

00:05:21,400 --> 00:05:25,480
apps if we were talking about writing a

00:05:22,960 --> 00:05:28,090
website right like facebook.com/ why

00:05:25,480 --> 00:05:29,590
would it be different and it is and I'm

00:05:28,090 --> 00:05:32,230
gonna spent a whole bunch of time at the

00:05:29,590 --> 00:05:33,760
end spelling all of that out doing each

00:05:32,230 --> 00:05:35,050
of those comparisons pointing out why

00:05:33,760 --> 00:05:38,890
what we're talking about today is

00:05:35,050 --> 00:05:40,419
distinctly a C++ story so keep that in

00:05:38,890 --> 00:05:43,570
mind all right

00:05:40,419 --> 00:05:46,390
show of hands who here's happier with

00:05:43,570 --> 00:05:48,100
their build times anyone we got ahead I

00:05:46,390 --> 00:05:51,520
figured we'd get a few brave people I

00:05:48,100 --> 00:05:53,169
admire your courage now I find doesn't

00:05:51,520 --> 00:05:54,490
matter who I talk to what company right

00:05:53,169 --> 00:05:57,070
wherever they've been if you're not

00:05:54,490 --> 00:05:58,270
doing something pretty small um there's

00:05:57,070 --> 00:06:02,140
a reason I don't see more than like

00:05:58,270 --> 00:06:04,419
three hands in that audience so this is

00:06:02,140 --> 00:06:06,040
where we're gonna start right and we're

00:06:04,419 --> 00:06:07,660
gonna start not with the problem of like

00:06:06,040 --> 00:06:09,280
you're compiling your one thing on your

00:06:07,660 --> 00:06:10,600
local machine and the compile time in

00:06:09,280 --> 00:06:12,669
the length time for that particular

00:06:10,600 --> 00:06:14,680
build is kind of nasty that is a problem

00:06:12,669 --> 00:06:17,410
but we're zooming out a bit we resume

00:06:14,680 --> 00:06:19,900
our the continuous integration folks we

00:06:17,410 --> 00:06:21,940
have to run all of the builds all of the

00:06:19,900 --> 00:06:23,590
tests all of the time as you're changing

00:06:21,940 --> 00:06:24,940
that codebase and figure out which

00:06:23,590 --> 00:06:28,630
things we should even bother building

00:06:24,940 --> 00:06:29,710
and testing so this is the C++ build

00:06:28,630 --> 00:06:32,200
time problem

00:06:29,710 --> 00:06:35,350
just wave zoomed out that's what we're

00:06:32,200 --> 00:06:37,270
gonna be doing alright now I figured I

00:06:35,350 --> 00:06:38,530
can tell you about you know flag when to

00:06:37,270 --> 00:06:40,510
use oh three we talked about dynamic

00:06:38,530 --> 00:06:42,190
linking and static linking we could even

00:06:40,510 --> 00:06:43,600
go into modules but I figured I'd be

00:06:42,190 --> 00:06:45,430
boring all of you with stuff you already

00:06:43,600 --> 00:06:47,110
know so we're not going to do that we're

00:06:45,430 --> 00:06:48,580
gonna zoom out past that compiler past

00:06:47,110 --> 00:06:51,370
that linker let's talk

00:06:48,580 --> 00:06:52,780
outbuild tools one layer higher now at

00:06:51,370 --> 00:06:55,270
Facebook we use a build tool called buck

00:06:52,780 --> 00:06:57,460
um you don't need to use buck to benefit

00:06:55,270 --> 00:06:59,889
from this talk no worries and I should

00:06:57,460 --> 00:07:01,150
mention at this point that I've got kind

00:06:59,889 --> 00:07:03,159
of experience with three different build

00:07:01,150 --> 00:07:03,490
tools so if I get some stuff wrong you

00:07:03,159 --> 00:07:05,289
know

00:07:03,490 --> 00:07:07,689
tell me after I'm happy to be wrong I'd

00:07:05,289 --> 00:07:09,400
actually love that the things I know

00:07:07,689 --> 00:07:12,280
about our various kinds of make I know

00:07:09,400 --> 00:07:14,169
buck and I use ninja like three times

00:07:12,280 --> 00:07:16,599
and I'm actually really curious who here

00:07:14,169 --> 00:07:17,370
uses make in a substantial way at their

00:07:16,599 --> 00:07:20,430
company today

00:07:17,370 --> 00:07:23,710
how about buck basil something like that

00:07:20,430 --> 00:07:24,960
cool a habit ninja something else who

00:07:23,710 --> 00:07:28,930
has anything else

00:07:24,960 --> 00:07:30,219
great well welcome to everybody for our

00:07:28,930 --> 00:07:31,479
purposes you might have guessed it there

00:07:30,219 --> 00:07:33,099
are two interesting things that buck

00:07:31,479 --> 00:07:35,110
does one is passion and one is querying

00:07:33,099 --> 00:07:38,139
and we're gonna be talking about both um

00:07:35,110 --> 00:07:39,240
so let's dive in with caching I like to

00:07:38,139 --> 00:07:41,289
think that there's kind of a couple

00:07:39,240 --> 00:07:42,789
interesting levels of caching and I'm

00:07:41,289 --> 00:07:45,250
gonna kind of abuse that word a little

00:07:42,789 --> 00:07:46,659
bit for the first level if you're

00:07:45,250 --> 00:07:48,189
building a project on your machine let's

00:07:46,659 --> 00:07:50,680
say you say build everything there is

00:07:48,189 --> 00:07:52,210
and then you change one file when you go

00:07:50,680 --> 00:07:53,740
to build quote and quote everything

00:07:52,210 --> 00:07:55,180
again it's probably not actually gonna

00:07:53,740 --> 00:07:56,590
build everything it'll build the the

00:07:55,180 --> 00:07:58,419
incremental difference based on what you

00:07:56,590 --> 00:08:00,129
change so maybe you call that cache and

00:07:58,419 --> 00:08:02,770
maybe you don't but I like to think at

00:08:00,129 --> 00:08:05,080
least every builds will have that where

00:08:02,770 --> 00:08:07,750
things may not have another layer of

00:08:05,080 --> 00:08:09,190
caching is me and my buddy are working

00:08:07,750 --> 00:08:10,389
on completely different teams completely

00:08:09,190 --> 00:08:12,129
different projects but both of those

00:08:10,389 --> 00:08:14,349
found include some really popular

00:08:12,129 --> 00:08:16,270
library we've got an open source one

00:08:14,349 --> 00:08:18,520
called Solly tons of people pound

00:08:16,270 --> 00:08:19,659
include that thing so if we're both

00:08:18,520 --> 00:08:21,520
building that thing let's say we're both

00:08:19,659 --> 00:08:24,099
in the same revision why should we ever

00:08:21,520 --> 00:08:25,990
compile that object file twice so if you

00:08:24,099 --> 00:08:26,889
upload the the object file to a cache in

00:08:25,990 --> 00:08:28,479
the background once you're done

00:08:26,889 --> 00:08:30,069
compiling it the other person can

00:08:28,479 --> 00:08:32,579
download it downloading is faster than

00:08:30,069 --> 00:08:35,409
compiling same goes with linking and

00:08:32,579 --> 00:08:36,849
Buck does this natively it also does

00:08:35,409 --> 00:08:40,029
Cashman a bunch of other dimensions we

00:08:36,849 --> 00:08:41,890
won't go into if you don't have this

00:08:40,029 --> 00:08:44,410
today if you don't have that level of

00:08:41,890 --> 00:08:47,260
caching look up the open source projects

00:08:44,410 --> 00:08:49,420
C cache and disk CC install them they're

00:08:47,260 --> 00:08:51,070
easy to throw into a make file system on

00:08:49,420 --> 00:08:54,490
you will get benefit I'm curious are

00:08:51,070 --> 00:08:56,770
people using those today cool lots of

00:08:54,490 --> 00:08:58,569
hands not enough hands go home install

00:08:56,770 --> 00:08:59,339
these things they will make your life

00:08:58,569 --> 00:09:00,550
better

00:08:59,339 --> 00:09:03,730
alright

00:09:00,550 --> 00:09:08,519
maybe that's review let's go one level

00:09:03,730 --> 00:09:10,630
further who doesn't like to be warm so

00:09:08,519 --> 00:09:13,000
how do you get the most out of your

00:09:10,630 --> 00:09:14,890
cache once you have one if you actually

00:09:13,000 --> 00:09:16,690
you know have caching set up great

00:09:14,890 --> 00:09:18,670
you're gonna benefit from it more if you

00:09:16,690 --> 00:09:20,230
have a revision where everything is

00:09:18,670 --> 00:09:21,820
populated in that tax so we have those

00:09:20,230 --> 00:09:23,200
continuous run these cron jobs they

00:09:21,820 --> 00:09:26,200
build and test all of the various things

00:09:23,200 --> 00:09:27,760
and one of the nice properties is we

00:09:26,200 --> 00:09:30,459
build and test all of the projects at

00:09:27,760 --> 00:09:33,130
the same revision at the same time and

00:09:30,459 --> 00:09:34,750
so they're cooperating with each other

00:09:33,130 --> 00:09:36,670
right they're not building many copies

00:09:34,750 --> 00:09:38,320
of folly they're saying oh we all need

00:09:36,670 --> 00:09:41,079
folly one job we'll get it done you

00:09:38,320 --> 00:09:43,450
download it and you're in total doing

00:09:41,079 --> 00:09:45,550
less work because of this but not only

00:09:43,450 --> 00:09:47,140
that instead of having your developers

00:09:45,550 --> 00:09:49,060
let's say go to master in your source

00:09:47,140 --> 00:09:50,649
control system you can provide from a

00:09:49,060 --> 00:09:52,180
binary which says go to whatever

00:09:50,649 --> 00:09:54,910
revision was just warmed in the cache

00:09:52,180 --> 00:09:56,410
and if you do this if you have a

00:09:54,910 --> 00:09:58,690
revision where everything is warming you

00:09:56,410 --> 00:10:00,519
get people to actually use that suppose

00:09:58,690 --> 00:10:02,589
you're doing a clean build no changes

00:10:00,519 --> 00:10:03,970
again Strunk we've got kind of two

00:10:02,589 --> 00:10:06,459
different mindsets you might be in for

00:10:03,970 --> 00:10:08,740
Flags linkers etc we've got a debugging

00:10:06,459 --> 00:10:10,360
iteration mindset it's got dynamic

00:10:08,740 --> 00:10:12,640
linking not a lot of optimization it's

00:10:10,360 --> 00:10:14,410
got sanitizers turned on to find bugs

00:10:12,640 --> 00:10:16,899
and then there's an optimized mode and

00:10:14,410 --> 00:10:19,480
if you do the optimized mode with a

00:10:16,899 --> 00:10:21,550
clean build you get a 6x speed

00:10:19,480 --> 00:10:23,410
improvement now mind you that could be

00:10:21,550 --> 00:10:25,060
faster if we wrote more to our cache we

00:10:23,410 --> 00:10:26,620
have certain limitations there but 6x

00:10:25,060 --> 00:10:28,540
that's not bad

00:10:26,620 --> 00:10:30,820
how about the iteration mindset well

00:10:28,540 --> 00:10:32,500
that's a faster mindset by far being the

00:10:30,820 --> 00:10:35,410
the moat the build mode there and that's

00:10:32,500 --> 00:10:36,399
2x faster I realize that might be boring

00:10:35,410 --> 00:10:37,630
because you've already built those

00:10:36,399 --> 00:10:40,120
things how about if you make an

00:10:37,630 --> 00:10:42,520
incremental change you're still looking

00:10:40,120 --> 00:10:44,740
at a 15% win on your build speed all

00:10:42,520 --> 00:10:46,810
right so I'm having a cash making sure

00:10:44,740 --> 00:10:48,220
people are at that cash is really nice

00:10:46,810 --> 00:10:49,899
and it's nice for you on your

00:10:48,220 --> 00:10:51,160
development machines it's also nice for

00:10:49,899 --> 00:10:53,740
me when you put up your change for code

00:10:51,160 --> 00:10:57,339
review because now the CI machines also

00:10:53,740 --> 00:10:58,690
get that benefit all right well it's up

00:10:57,339 --> 00:11:00,070
until this point we've been saying I you

00:10:58,690 --> 00:11:01,630
need to do some amount of work we can

00:11:00,070 --> 00:11:04,329
you know reduce some amount of

00:11:01,630 --> 00:11:07,390
redundancy great but the fundamental you

00:11:04,329 --> 00:11:09,250
need to produce those object files we're

00:11:07,390 --> 00:11:11,140
gonna change gears a little bit we're

00:11:09,250 --> 00:11:13,260
gonna talk about what do you even pick

00:11:11,140 --> 00:11:14,970
to build and test

00:11:13,260 --> 00:11:17,190
right that's very different I'm going to

00:11:14,970 --> 00:11:18,750
give you this terrible straw man example

00:11:17,190 --> 00:11:21,060
a thing that you would never do when

00:11:18,750 --> 00:11:23,220
your facebook when you have millions of

00:11:21,060 --> 00:11:25,530
files in your repo that you need to deal

00:11:23,220 --> 00:11:27,990
with and so our terrible idea is

00:11:25,530 --> 00:11:30,590
whenever anybody puts up any change for

00:11:27,990 --> 00:11:32,280
code review build and test everything

00:11:30,590 --> 00:11:36,180
right good idea

00:11:32,280 --> 00:11:37,710
great so bad idea number one is it's

00:11:36,180 --> 00:11:40,080
gonna use a lot of machine computing

00:11:37,710 --> 00:11:41,370
effort it's going to end up with you

00:11:40,080 --> 00:11:42,840
waiting for the slowest thing in the

00:11:41,370 --> 00:11:44,520
codebase whatever that happens you're

00:11:42,840 --> 00:11:46,710
gonna be stuck waiting for it and I

00:11:44,520 --> 00:11:48,240
think a lot more subtly is you're going

00:11:46,710 --> 00:11:51,990
to have the worst flakiness you could

00:11:48,240 --> 00:11:53,940
possibly experience why let's say you're

00:11:51,990 --> 00:11:56,010
writing a test that test has some

00:11:53,940 --> 00:11:58,260
non-deterministic spurious failure rate

00:11:56,010 --> 00:12:00,240
of 1 in 10,000 does that sound okay to

00:11:58,260 --> 00:12:02,280
you one in 10,000 right maybe you're

00:12:00,240 --> 00:12:03,510
talking to a database and it's I'm happy

00:12:02,280 --> 00:12:05,160
maybe you're writing a file maybe it's a

00:12:03,510 --> 00:12:07,470
perfect unit test the kernel sad

00:12:05,160 --> 00:12:10,740
anyone think one in ten thousands a good

00:12:07,470 --> 00:12:13,130
rate for spurious failures I on the face

00:12:10,740 --> 00:12:17,130
of it think that seems almost kind of ok

00:12:13,130 --> 00:12:18,240
well take millions of files how many of

00:12:17,130 --> 00:12:21,060
those do you think are files containing

00:12:18,240 --> 00:12:22,650
tests how many tests per file do you

00:12:21,060 --> 00:12:24,840
think they're multiply that all out

00:12:22,650 --> 00:12:28,140
multiply it by the one in 10,000 and you

00:12:24,840 --> 00:12:30,060
get an integer so if you're building and

00:12:28,140 --> 00:12:31,560
testing everything you're getting the

00:12:30,060 --> 00:12:34,260
worst of every single one of these

00:12:31,560 --> 00:12:36,540
dimensions ok fine

00:12:34,260 --> 00:12:38,040
this is a bad idea we knew it going in

00:12:36,540 --> 00:12:39,420
but if you wanted to do it this is how

00:12:38,040 --> 00:12:41,580
you spell it for a couple different

00:12:39,420 --> 00:12:43,440
build systems let's move on let's do

00:12:41,580 --> 00:12:45,480
something slightly more clever I know

00:12:43,440 --> 00:12:47,520
what I'm working on let's just say build

00:12:45,480 --> 00:12:49,320
that particular thing right I'm an

00:12:47,520 --> 00:12:50,730
engineer I'm on my machine I'm certainly

00:12:49,320 --> 00:12:52,830
I'm not spending more resources than I

00:12:50,730 --> 00:12:54,270
need to I'm not going to run more tests

00:12:52,830 --> 00:12:58,140
than I need you so there's not as much

00:12:54,270 --> 00:13:01,290
flakiness all of our numbers look a lot

00:12:58,140 --> 00:13:02,880
nicer here's the problem I've got myself

00:13:01,290 --> 00:13:05,460
an arbitrary little build graph here

00:13:02,880 --> 00:13:08,280
there's a binary be a library la unit

00:13:05,460 --> 00:13:10,680
tests you and if I change those red

00:13:08,280 --> 00:13:15,150
files right my binary dot cpp in my

00:13:10,680 --> 00:13:16,980
library dot cpp well okay I can say buck

00:13:15,150 --> 00:13:18,780
build those two things or make those two

00:13:16,980 --> 00:13:21,000
targets and it'll figure out it needs to

00:13:18,780 --> 00:13:22,620
cloud the the B object file the L object

00:13:21,000 --> 00:13:23,880
file and actually the dot in the center

00:13:22,620 --> 00:13:25,530
there as well there's a forward our

00:13:23,880 --> 00:13:26,010
going towards it you need that to link

00:13:25,530 --> 00:13:27,810
together

00:13:26,010 --> 00:13:30,560
binary so it'll figure all of that out

00:13:27,810 --> 00:13:34,140
right you told it what to do now but

00:13:30,560 --> 00:13:36,450
it's not gonna build your unit test now

00:13:34,140 --> 00:13:37,770
you could say build the unit test too

00:13:36,450 --> 00:13:40,020
but then you have to know the unit test

00:13:37,770 --> 00:13:41,250
exists and maybe you know it exists

00:13:40,020 --> 00:13:42,420
because you were directly touching that

00:13:41,250 --> 00:13:44,640
library but what if you were touching

00:13:42,420 --> 00:13:46,050
something else in a foreign part of the

00:13:44,640 --> 00:13:47,610
code base you don't know what tests

00:13:46,050 --> 00:13:49,380
there are when you're talking about

00:13:47,610 --> 00:13:50,640
millions of files you can't expect to

00:13:49,380 --> 00:13:53,820
actually know the build graph in

00:13:50,640 --> 00:13:55,380
intimate detail so we've got ourselves a

00:13:53,820 --> 00:13:58,130
problem now we're a lot more resource

00:13:55,380 --> 00:14:00,240
efficient but we're no longer correct ah

00:13:58,130 --> 00:14:01,470
sorry what did I do

00:14:00,240 --> 00:14:05,100
I skipped ahead a bunch of slides

00:14:01,470 --> 00:14:08,190
somehow that's what happens this is the

00:14:05,100 --> 00:14:09,180
example I meant to be doing so same

00:14:08,190 --> 00:14:11,340
thing we talked about before there's

00:14:09,180 --> 00:14:13,110
just not a purple node great let's do

00:14:11,340 --> 00:14:16,230
better and my clicker is having some

00:14:13,110 --> 00:14:20,580
trouble all right this is where we're

00:14:16,230 --> 00:14:22,530
gonna leave make files behind so what

00:14:20,580 --> 00:14:24,720
we're trying to do now is to say even

00:14:22,530 --> 00:14:26,100
whatever files I changed in this example

00:14:24,720 --> 00:14:28,620
I have one but you could give a list

00:14:26,100 --> 00:14:30,780
tell me all of the build rules all of

00:14:28,620 --> 00:14:33,210
those bubbles in my graph that I need to

00:14:30,780 --> 00:14:34,830
rebuild that I need to test and Buck has

00:14:33,210 --> 00:14:36,720
this thing but query are depp's we

00:14:34,830 --> 00:14:38,730
mentioned query would show up our DEP

00:14:36,720 --> 00:14:40,110
stands for reverse dependencies the idea

00:14:38,730 --> 00:14:43,290
is you're going to say here's what I

00:14:40,110 --> 00:14:45,420
changed follow the arrows backwards to

00:14:43,290 --> 00:14:47,760
see what depends on the code I changed

00:14:45,420 --> 00:14:50,970
and that will tell you what you actually

00:14:47,760 --> 00:14:53,820
need to do now I actually thought as of

00:14:50,970 --> 00:14:56,310
24 hours ago that make files couldn't do

00:14:53,820 --> 00:14:57,840
this I was wrong I wanted to not lie to

00:14:56,310 --> 00:15:00,030
you people there's a lovely person beta

00:14:57,840 --> 00:15:01,140
on Stack Overflow thank you check out

00:15:00,030 --> 00:15:03,720
the link if you want the make file

00:15:01,140 --> 00:15:05,280
solution to that so now what we're gonna

00:15:03,720 --> 00:15:07,740
do is we're gonna say okay are there any

00:15:05,280 --> 00:15:09,240
arrows going in to be no fine

00:15:07,740 --> 00:15:10,890
are there any arrows going in to elder's

00:15:09,240 --> 00:15:12,810
beep that's redundant but now there's

00:15:10,890 --> 00:15:14,670
you we capture that we're now going to

00:15:12,810 --> 00:15:16,200
include it and we build all three of

00:15:14,670 --> 00:15:19,290
those which again builds the center dot

00:15:16,200 --> 00:15:21,180
as well now we are at the point where we

00:15:19,290 --> 00:15:23,550
are maximally correct we are building

00:15:21,180 --> 00:15:25,230
and testing only what we need to we're

00:15:23,550 --> 00:15:27,420
not leaving anything out we're not doing

00:15:25,230 --> 00:15:30,360
more work than we have to this is a

00:15:27,420 --> 00:15:32,220
great place to be okay well it was

00:15:30,360 --> 00:15:34,170
around this point this was quite a while

00:15:32,220 --> 00:15:35,880
ago that we said you know we're actually

00:15:34,170 --> 00:15:38,130
correct now let's let's try and do

00:15:35,880 --> 00:15:40,959
better let's look at some data

00:15:38,130 --> 00:15:42,640
we learned some interesting things so

00:15:40,959 --> 00:15:45,250
first thing we learned is about two

00:15:42,640 --> 00:15:46,959
thirds of our computational effort was

00:15:45,250 --> 00:15:48,910
going toward the dish workflow one third

00:15:46,959 --> 00:15:51,310
was going toward that continuous run

00:15:48,910 --> 00:15:53,410
cron job stuff and I don't know if that

00:15:51,310 --> 00:15:54,640
matches your intuition um I have

00:15:53,410 --> 00:15:56,079
hindsight but I don't know if it would

00:15:54,640 --> 00:15:58,120
match my intuition either because those

00:15:56,079 --> 00:16:00,850
continuous runs those cron jobs build

00:15:58,120 --> 00:16:02,950
and test everything and when everything

00:16:00,850 --> 00:16:06,579
is a millions of files that's a that's

00:16:02,950 --> 00:16:08,560
gonna be big so the fact that that was

00:16:06,579 --> 00:16:10,570
only one third is kind of striking that

00:16:08,560 --> 00:16:11,769
the diff workflows were so represented

00:16:10,570 --> 00:16:13,240
in there that's a lot and there's

00:16:11,769 --> 00:16:15,519
thousands of Engineers but that's a big

00:16:13,240 --> 00:16:17,110
number so we do whatever we do when we

00:16:15,519 --> 00:16:18,279
figure out that one category is bigger

00:16:17,110 --> 00:16:19,750
than another we go into the bigger

00:16:18,279 --> 00:16:22,269
category and we ask alright well why is

00:16:19,750 --> 00:16:24,910
it so big and we learned something else

00:16:22,269 --> 00:16:26,170
which was an astonishingly small

00:16:24,910 --> 00:16:28,269
percentage of the diffs

00:16:26,170 --> 00:16:30,610
was responsible for an astonishingly

00:16:28,269 --> 00:16:33,070
large percentage of machine resource

00:16:30,610 --> 00:16:36,940
utilization and that looks like this

00:16:33,070 --> 00:16:38,890
right it looks like somebody changed

00:16:36,940 --> 00:16:40,390
that center dot that might be for

00:16:38,890 --> 00:16:42,610
example that open source library I

00:16:40,390 --> 00:16:44,110
mentioned folly right lots of people at

00:16:42,610 --> 00:16:47,050
the end of the day depend on that thing

00:16:44,110 --> 00:16:50,920
and if you've changed that then you need

00:16:47,050 --> 00:16:53,020
to build everything and so all it takes

00:16:50,920 --> 00:16:56,230
is one engineer one engineer at this

00:16:53,020 --> 00:16:58,660
conference who's changing that library

00:16:56,230 --> 00:17:03,190
to incur all of that resource

00:16:58,660 --> 00:17:06,160
utilization and it's worth it but we can

00:17:03,190 --> 00:17:08,410
do better right this is this is a nasty

00:17:06,160 --> 00:17:11,110
place to be okay

00:17:08,410 --> 00:17:14,079
so we're gonna change our goals our goal

00:17:11,110 --> 00:17:16,030
is no longer build and test all of the

00:17:14,079 --> 00:17:17,110
things that in a theoretical world you

00:17:16,030 --> 00:17:19,329
need to build and test in order to

00:17:17,110 --> 00:17:21,669
guarantee correctness no we're going to

00:17:19,329 --> 00:17:24,480
build what we need to get practical

00:17:21,669 --> 00:17:26,740
correctness to be safe in practice and

00:17:24,480 --> 00:17:28,540
there's a parameter that I left off our

00:17:26,740 --> 00:17:30,370
buck query here before right

00:17:28,540 --> 00:17:32,890
and that is that number two which says

00:17:30,370 --> 00:17:34,750
don't go any further than two arrows

00:17:32,890 --> 00:17:37,419
away from what we changed when figuring

00:17:34,750 --> 00:17:39,190
out what the building tests and that

00:17:37,419 --> 00:17:40,750
picture looks like this so we'll go one

00:17:39,190 --> 00:17:42,490
arrow away from the center we'll go two

00:17:40,750 --> 00:17:43,360
hours away but once we go that far

00:17:42,490 --> 00:17:46,480
that's it we're done

00:17:43,360 --> 00:17:49,270
we're gonna stop now let me tell you the

00:17:46,480 --> 00:17:51,010
intuition for why we fought distance

00:17:49,270 --> 00:17:52,660
would be a good heuristic

00:17:51,010 --> 00:17:54,250
we thought the distance would be a good

00:17:52,660 --> 00:17:55,179
heuristic because let's say you know you

00:17:54,250 --> 00:17:57,760
want to make sure you're running the

00:17:55,179 --> 00:18:00,880
tests for folly that center node which

00:17:57,760 --> 00:18:02,410
bubble do you think is the tests I would

00:18:00,880 --> 00:18:04,179
say it's that node right there at the

00:18:02,410 --> 00:18:05,410
bottom kind of down in the center right

00:18:04,179 --> 00:18:07,210
because all that's gonna be doing the

00:18:05,410 --> 00:18:10,090
unit tests for folly is pound including

00:18:07,210 --> 00:18:11,890
folly right away it is one distance away

00:18:10,090 --> 00:18:14,140
in our build craft well what about a

00:18:11,890 --> 00:18:16,500
library that just really exercises folly

00:18:14,140 --> 00:18:19,419
right it just you know really heavily

00:18:16,500 --> 00:18:21,460
figures out all of the stuff that it

00:18:19,419 --> 00:18:23,410
needs to do it exercise of that API

00:18:21,460 --> 00:18:24,790
completely that's also gonna be nearby

00:18:23,410 --> 00:18:26,230
it's probably going to directly pound

00:18:24,790 --> 00:18:28,299
include folly and the further away you

00:18:26,230 --> 00:18:29,679
go and pound include distance the less

00:18:28,299 --> 00:18:31,630
likely you are to be testing folly

00:18:29,679 --> 00:18:34,660
itself and the more likely you are to be

00:18:31,630 --> 00:18:36,730
testing some abstraction over it and so

00:18:34,660 --> 00:18:38,500
fine if you leave some things off that

00:18:36,730 --> 00:18:42,160
are at a higher distance you're not

00:18:38,500 --> 00:18:46,450
missing much well here's another take on

00:18:42,160 --> 00:18:49,240
this let's say it's fine if you catch an

00:18:46,450 --> 00:18:50,919
example of every bug even if you don't

00:18:49,240 --> 00:18:53,590
catch every example of every bug what do

00:18:50,919 --> 00:18:56,650
I mean by that let's say you introduce

00:18:53,590 --> 00:18:58,270
some sort of crash well probably you're

00:18:56,650 --> 00:19:00,220
gonna find that crash in the part that

00:18:58,270 --> 00:19:02,140
we are building you may also find it the

00:19:00,220 --> 00:19:04,179
part we aren't but as long as you see

00:19:02,140 --> 00:19:05,530
that crash you'll be able to fix it now

00:19:04,179 --> 00:19:07,330
there's other kinds of bugs where maybe

00:19:05,530 --> 00:19:09,910
that doesn't work so well but there's

00:19:07,330 --> 00:19:12,429
some intuition for why distance feels

00:19:09,910 --> 00:19:15,010
like it could be a good heuristic okay

00:19:12,429 --> 00:19:16,750
well if we apply this on a smaller

00:19:15,010 --> 00:19:18,400
change did we break everything can we

00:19:16,750 --> 00:19:20,230
just apply this rule universally or is

00:19:18,400 --> 00:19:22,059
this a folly thing for smaller things

00:19:20,230 --> 00:19:23,950
there's no difference whatsoever it's

00:19:22,059 --> 00:19:25,750
exactly the same as if we applied no

00:19:23,950 --> 00:19:27,370
distance limit whatsoever there's

00:19:25,750 --> 00:19:28,690
changes that are of moderate size it

00:19:27,370 --> 00:19:34,660
affects them moderately as you might

00:19:28,690 --> 00:19:36,940
expect cool so in practice we're

00:19:34,660 --> 00:19:40,750
building and testing half as much stuff

00:19:36,940 --> 00:19:42,820
if we roll this out half as much right

00:19:40,750 --> 00:19:45,160
we're not building half the thing is

00:19:42,820 --> 00:19:47,350
we're not testing half the things who

00:19:45,160 --> 00:19:49,179
thinks we just broke everything right I

00:19:47,350 --> 00:19:50,650
gave you some intuition but we're

00:19:49,179 --> 00:19:51,910
building and testing half the stuff we

00:19:50,650 --> 00:19:55,450
did before did we just break the

00:19:51,910 --> 00:19:58,780
universe who thinks so great well I'm

00:19:55,450 --> 00:20:00,630
glad to see some hands but we didn't we

00:19:58,780 --> 00:20:04,210
didn't and this is where the practical

00:20:00,630 --> 00:20:07,700
practical part comes in

00:20:04,210 --> 00:20:09,980
we measure the failure rate in trunk and

00:20:07,700 --> 00:20:11,510
we have those continuous runs those cron

00:20:09,980 --> 00:20:12,980
jobs they build and test everything so

00:20:11,510 --> 00:20:14,720
we know if something is actually

00:20:12,980 --> 00:20:16,370
breaking in trunk right if add if time

00:20:14,720 --> 00:20:19,130
you don't build something and then it

00:20:16,370 --> 00:20:20,630
breaks it'll show up you measure that

00:20:19,130 --> 00:20:22,010
short term you measure that long term

00:20:20,630 --> 00:20:24,200
you know it's luxury it's a bit

00:20:22,010 --> 00:20:26,000
day-to-day but there was no change

00:20:24,200 --> 00:20:29,090
rolling this out you can build and test

00:20:26,000 --> 00:20:31,220
half as much stuff and be just fine and

00:20:29,090 --> 00:20:33,920
by the way the tests work they do find

00:20:31,220 --> 00:20:35,500
bugs rate it's not bad if we're building

00:20:33,920 --> 00:20:39,860
the ones that matter

00:20:35,500 --> 00:20:41,630
okay well more practically about once

00:20:39,860 --> 00:20:43,730
every two months we do have someone who

00:20:41,630 --> 00:20:45,740
comes along and we correctly find out

00:20:43,730 --> 00:20:47,300
that yes this turistic meant we didn't

00:20:45,740 --> 00:20:49,040
build something we should have and it

00:20:47,300 --> 00:20:51,140
caused the breakage that does happen we

00:20:49,040 --> 00:20:52,640
missed some things but at that rate and

00:20:51,140 --> 00:20:54,920
let's even assume that you you know

00:20:52,640 --> 00:20:56,720
there's people who don't report it or we

00:20:54,920 --> 00:20:59,030
don't quite figure it out whatever you

00:20:56,720 --> 00:21:04,160
think that number is it's so small that

00:20:59,030 --> 00:21:05,120
for 50 percent it's worth it all right

00:21:04,160 --> 00:21:06,530
well then there's opt-outs

00:21:05,120 --> 00:21:08,420
from day one we knew this was going to

00:21:06,530 --> 00:21:10,120
be like a really risky idea on the face

00:21:08,420 --> 00:21:13,190
of it because we saw that it was gonna

00:21:10,120 --> 00:21:14,930
not build quite as much stuff and we

00:21:13,190 --> 00:21:16,610
don't not that we said we're gonna make

00:21:14,930 --> 00:21:18,740
sure that there are these things called

00:21:16,610 --> 00:21:20,450
deferred jobs we would have built it

00:21:18,740 --> 00:21:21,740
normally and now we wouldn't we'll put

00:21:20,450 --> 00:21:24,230
it there we'll give you an opportunity

00:21:21,740 --> 00:21:25,640
to say yes please build this and we gave

00:21:24,230 --> 00:21:26,780
him three places to do we said you can

00:21:25,640 --> 00:21:28,340
do when you put up the chain for code

00:21:26,780 --> 00:21:29,630
review you can push it as you're looking

00:21:28,340 --> 00:21:31,220
at the thing it code even you're a

00:21:29,630 --> 00:21:33,050
reviewer can push the button and then

00:21:31,220 --> 00:21:35,450
again we we advertise it right in your

00:21:33,050 --> 00:21:36,800
face when you go to ship the code um hey

00:21:35,450 --> 00:21:40,100
you didn't run these things would you

00:21:36,800 --> 00:21:43,280
like to what happened first of all

00:21:40,100 --> 00:21:44,450
people didn't use it right nobody cared

00:21:43,280 --> 00:21:48,170
there was not that even though we

00:21:44,450 --> 00:21:49,940
advertised it very heavily and you you

00:21:48,170 --> 00:21:51,710
know it would be really bad if they

00:21:49,940 --> 00:21:53,390
didn't push it and our failure rate

00:21:51,710 --> 00:21:55,490
bottom line team but that didn't happen

00:21:53,390 --> 00:21:58,250
right they didn't use it and we saw no

00:21:55,490 --> 00:22:00,260
more failures in trunk well there was a

00:21:58,250 --> 00:22:01,010
small subset who did use it and when

00:22:00,260 --> 00:22:05,090
they pushed it

00:22:01,010 --> 00:22:07,100
they didn't detect more bugs now they

00:22:05,090 --> 00:22:09,440
did in some cases detect more examples

00:22:07,100 --> 00:22:10,730
of the same bug and that might matter if

00:22:09,440 --> 00:22:12,410
let's say you're a person working on a

00:22:10,730 --> 00:22:14,420
library you're changing the API you need

00:22:12,410 --> 00:22:15,950
to detect every single compilation error

00:22:14,420 --> 00:22:17,780
so that you can you know make sure your

00:22:15,950 --> 00:22:19,760
API taint is safe

00:22:17,780 --> 00:22:23,720
but in many cases that just doesn't

00:22:19,760 --> 00:22:24,890
matter and lastly you know if you're one

00:22:23,720 --> 00:22:26,540
of these people for which it does matter

00:22:24,890 --> 00:22:28,580
we actually still save because you

00:22:26,540 --> 00:22:30,380
iterate on your change getting rid of

00:22:28,580 --> 00:22:32,390
all the bugs eventually you click the

00:22:30,380 --> 00:22:33,920
button but you click it one time we do

00:22:32,390 --> 00:22:35,900
that expense one time instead of every

00:22:33,920 --> 00:22:37,880
time you're iterating and then we

00:22:35,900 --> 00:22:40,280
actually remember which jobs fail and

00:22:37,880 --> 00:22:42,590
always rerun them or never defer them

00:22:40,280 --> 00:22:44,090
after that point that they've initially

00:22:42,590 --> 00:22:46,250
failed so if you iterate on that diff in

00:22:44,090 --> 00:22:48,020
the future you're not missing anything

00:22:46,250 --> 00:22:52,010
you will be certain that you have fixed

00:22:48,020 --> 00:22:55,100
stuff so for all practical purposes we

00:22:52,010 --> 00:22:57,170
didn't change the failure rate this is

00:22:55,100 --> 00:22:59,900
good there are some cases where this

00:22:57,170 --> 00:23:01,610
does not work out right so one case is

00:22:59,900 --> 00:23:04,220
virtual machines we've got this thing

00:23:01,610 --> 00:23:06,200
h/h VM it interprets the language hack

00:23:04,220 --> 00:23:09,080
which is at this point thankfully I

00:23:06,200 --> 00:23:11,660
would say a distant offshoot of PHP but

00:23:09,080 --> 00:23:13,610
you might imagine the unit test or maybe

00:23:11,660 --> 00:23:17,270
end-to-end test is a better word for H h

00:23:13,610 --> 00:23:18,860
vm or some PHP code where you're running

00:23:17,270 --> 00:23:20,440
it you're like is this PHP code actually

00:23:18,860 --> 00:23:24,080
producing the results it's supposed to

00:23:20,440 --> 00:23:26,570
and the code that actually implements

00:23:24,080 --> 00:23:28,820
that is this massive C++ project that

00:23:26,570 --> 00:23:29,360
have a rather large build graph all on

00:23:28,820 --> 00:23:32,960
its own

00:23:29,360 --> 00:23:34,910
and there isn't a relationship between

00:23:32,960 --> 00:23:36,530
the PHP and you know your pound

00:23:34,910 --> 00:23:38,300
including the the C++ code that

00:23:36,530 --> 00:23:40,280
implements that that's just not how

00:23:38,300 --> 00:23:42,110
those tests work it's a virtual machine

00:23:40,280 --> 00:23:44,150
the code that implements it is all over

00:23:42,110 --> 00:23:46,940
the place there's no relationship

00:23:44,150 --> 00:23:47,930
between distance and the tests and if

00:23:46,940 --> 00:23:49,460
you have no relationship between

00:23:47,930 --> 00:23:52,490
distance in the test you can't use the

00:23:49,460 --> 00:23:53,960
heuristic we turn it off now the other

00:23:52,490 --> 00:23:56,450
two things on the slide here kind of

00:23:53,960 --> 00:24:00,830
blend together we have an RPC framework

00:23:56,450 --> 00:24:02,180
called thrift and it generates nodes in

00:24:00,830 --> 00:24:03,830
our build graph in some cases it might

00:24:02,180 --> 00:24:05,990
even generate long linear teams like a

00:24:03,830 --> 00:24:07,610
linked list a single Direction linked

00:24:05,990 --> 00:24:09,560
list and I think of those as

00:24:07,610 --> 00:24:11,240
artificially inflating the distances in

00:24:09,560 --> 00:24:13,430
the build graph and so if you discount

00:24:11,240 --> 00:24:15,560
those all to 0 then you again have no

00:24:13,430 --> 00:24:19,340
problems but you do have to actually do

00:24:15,560 --> 00:24:20,750
that discounting all right well at this

00:24:19,340 --> 00:24:22,190
point we're building and testing half as

00:24:20,750 --> 00:24:26,120
much stuff we got away with it we're not

00:24:22,190 --> 00:24:28,310
introducing more bugs you know fine now

00:24:26,120 --> 00:24:29,810
it just takes two of these things to be

00:24:28,310 --> 00:24:31,220
a continuous front in terms of how many

00:24:29,810 --> 00:24:32,929
resources you're using this

00:24:31,220 --> 00:24:35,570
still isn't great even though its place

00:24:32,929 --> 00:24:37,039
is good and so we've got another thing

00:24:35,570 --> 00:24:39,350
you layer on top capitalize on that

00:24:37,039 --> 00:24:41,240
distance Double Down why not pick the

00:24:39,350 --> 00:24:42,620
closest ten and of course we don't use

00:24:41,240 --> 00:24:44,929
two in ten and practice those are

00:24:42,620 --> 00:24:47,630
numbers that fit on slides but if you do

00:24:44,929 --> 00:24:49,669
it there's eight nodes from the graph

00:24:47,630 --> 00:24:51,110
that are one hour away and I picked a

00:24:49,669 --> 00:24:53,330
couple of arbitrary ones that are two

00:24:51,110 --> 00:24:56,150
away we do this deterministically and

00:24:53,330 --> 00:24:58,070
things are looking better still right

00:24:56,150 --> 00:25:01,990
same distance heuristic intuition for

00:24:58,070 --> 00:25:04,520
why this should work and if you do that

00:25:01,990 --> 00:25:05,780
then again on the smaller changes

00:25:04,520 --> 00:25:07,340
there's no difference whatsoever on the

00:25:05,780 --> 00:25:09,409
moderate ones you get a moderate change

00:25:07,340 --> 00:25:10,760
and this is another forty percent so

00:25:09,409 --> 00:25:12,320
that's a multiplication that's fifty

00:25:10,760 --> 00:25:14,980
percent times forty percent we are doing

00:25:12,320 --> 00:25:18,530
twenty percent of the original work and

00:25:14,980 --> 00:25:20,120
yet that failure rate is within the

00:25:18,530 --> 00:25:22,220
noise it did not change the user

00:25:20,120 --> 00:25:23,720
complained do not go up the use of the

00:25:22,220 --> 00:25:25,539
opt-outs people have figured that out

00:25:23,720 --> 00:25:28,100
they know how to develop in this world

00:25:25,539 --> 00:25:30,409
so let's go back to our goals right I've

00:25:28,100 --> 00:25:32,929
been you know kind of really emphasizing

00:25:30,409 --> 00:25:35,570
the detect all the bugs part right don't

00:25:32,929 --> 00:25:37,100
mess up as you're as you're scaling but

00:25:35,570 --> 00:25:39,260
there's a real win that I think is

00:25:37,100 --> 00:25:40,970
practical for each one of you which is

00:25:39,260 --> 00:25:42,650
as you're getting code review as you're

00:25:40,970 --> 00:25:45,799
trying to find out automatically did I

00:25:42,650 --> 00:25:47,570
break stuff it's gonna happen way faster

00:25:45,799 --> 00:25:49,669
you're no longer stuck building the

00:25:47,570 --> 00:25:51,309
slowest thing in the codebase and even

00:25:49,669 --> 00:25:53,900
if you're not you know working on folly

00:25:51,309 --> 00:25:55,280
and I should mention the building twenty

00:25:53,900 --> 00:25:58,309
percent of what we did before is not for

00:25:55,280 --> 00:26:02,600
folly diff that's for all of them that's

00:25:58,309 --> 00:26:03,919
across the board so if we look at the

00:26:02,600 --> 00:26:05,840
time between when you submit a change

00:26:03,919 --> 00:26:07,130
for code review and when the last thing

00:26:05,840 --> 00:26:10,100
finishes that tells you whether or not

00:26:07,130 --> 00:26:13,190
you made a mistake is done P fifty

00:26:10,100 --> 00:26:16,309
through P 99 go way down particularly

00:26:13,190 --> 00:26:19,309
that P 99 they just fall to something

00:26:16,309 --> 00:26:21,049
way more reasonable this is really nice

00:26:19,309 --> 00:26:23,270
for the developers now on top of that

00:26:21,049 --> 00:26:24,950
you know before we had one in ten

00:26:23,270 --> 00:26:27,530
thousand times the number of tests in

00:26:24,950 --> 00:26:29,299
the entire repository now you're dealing

00:26:27,530 --> 00:26:31,640
with twenty percent of that so the

00:26:29,299 --> 00:26:33,830
flakiness goes way way way down moving

00:26:31,640 --> 00:26:35,900
the needle on flakiness is an incredibly

00:26:33,830 --> 00:26:37,580
difficult problem and this is a great

00:26:35,900 --> 00:26:40,159
way to do it if you want an easy way to

00:26:37,580 --> 00:26:43,700
reduce flakiness in your code base run

00:26:40,159 --> 00:26:45,230
less stuff honestly there is nothing

00:26:43,700 --> 00:26:47,539
easier to do

00:26:45,230 --> 00:26:49,399
on that front then run less stuff there

00:26:47,539 --> 00:26:51,260
are other hard things that you can do if

00:26:49,399 --> 00:26:52,700
you go back to my 2016 talk there's

00:26:51,260 --> 00:26:54,409
actually another fairly nice thing to be

00:26:52,700 --> 00:26:56,510
what's called base rep retries check

00:26:54,409 --> 00:27:00,289
that out but flakiness is an incredibly

00:26:56,510 --> 00:27:01,789
hard problem all of this now lets us

00:27:00,289 --> 00:27:02,990
survive at scale now forgive me I'm

00:27:01,789 --> 00:27:04,159
gonna spell out things that maybe are

00:27:02,990 --> 00:27:05,480
kind of obvious but we're gonna hire

00:27:04,159 --> 00:27:06,830
more engineers they're gonna write more

00:27:05,480 --> 00:27:09,019
discs there's gonna be more code in the

00:27:06,830 --> 00:27:12,080
repository and the code is going to be

00:27:09,019 --> 00:27:14,630
more interconnected all of that scares

00:27:12,080 --> 00:27:16,250
me what doesn't is that we now have a

00:27:14,630 --> 00:27:19,190
constant our depth cut off we now have a

00:27:16,250 --> 00:27:22,519
constant closest end cut off and that

00:27:19,190 --> 00:27:23,929
means that our future fake data here

00:27:22,519 --> 00:27:25,880
going over time number of engineers

00:27:23,929 --> 00:27:27,409
number of machines to support them is

00:27:25,880 --> 00:27:29,330
gonna look a lot more like that bottom

00:27:27,409 --> 00:27:31,639
line than that scary up into the right

00:27:29,330 --> 00:27:32,320
line right it's linear we can deal with

00:27:31,639 --> 00:27:35,480
that

00:27:32,320 --> 00:27:38,000
the key idea and you may do this

00:27:35,480 --> 00:27:43,059
differently is that we put an upper

00:27:38,000 --> 00:27:45,919
bound on the cost of a DIF that matters

00:27:43,059 --> 00:27:47,419
okay up until this point I've been able

00:27:45,919 --> 00:27:49,309
to share some numbers about how well

00:27:47,419 --> 00:27:50,899
things have been working I want to talk

00:27:49,309 --> 00:27:52,580
about something that is an experimental

00:27:50,899 --> 00:27:54,559
direction I don't have data for how well

00:27:52,580 --> 00:27:56,659
it works in C++ but we've tried it on a

00:27:54,559 --> 00:27:59,090
certain subset of our web tests and it

00:27:56,659 --> 00:28:01,429
works wonderfully for that um we are

00:27:59,090 --> 00:28:03,110
very close to being able to test this in

00:28:01,429 --> 00:28:05,360
C++ but I wanted to just share the cool

00:28:03,110 --> 00:28:07,220
idea and it's this thing called diff

00:28:05,360 --> 00:28:08,360
batching so suppose you've got three

00:28:07,220 --> 00:28:10,039
different diff three different commits

00:28:08,360 --> 00:28:11,450
maybe wildly different things that

00:28:10,039 --> 00:28:13,519
they're working on but at the end of the

00:28:11,450 --> 00:28:14,809
day buck query our depth tells us that

00:28:13,519 --> 00:28:16,429
they have some things in common right

00:28:14,809 --> 00:28:18,320
they both need to build project a or

00:28:16,429 --> 00:28:20,659
project C or this could be build node

00:28:18,320 --> 00:28:23,029
however you want to think about it what

00:28:20,659 --> 00:28:24,679
if instead we just rebased these on top

00:28:23,029 --> 00:28:26,419
of each other and instead of doing a

00:28:24,679 --> 00:28:28,940
buck query our depth of just commit one

00:28:26,419 --> 00:28:30,470
and the files that were changed in that

00:28:28,940 --> 00:28:32,380
you run a buck query are Depp's on the

00:28:30,470 --> 00:28:34,669
files that were changed across all three

00:28:32,380 --> 00:28:36,529
here in figure out okay I need to build

00:28:34,669 --> 00:28:40,100
the same projects but now there's no

00:28:36,529 --> 00:28:42,710
more redundancy and turns out this case

00:28:40,100 --> 00:28:45,019
where we save two jobs that's doing 2/3

00:28:42,710 --> 00:28:47,360
of the work in this example is really

00:28:45,019 --> 00:28:49,309
really likely and it's likely because

00:28:47,360 --> 00:28:51,200
our job success rate not our you know

00:28:49,309 --> 00:28:53,330
percentage of gifts that have a failure

00:28:51,200 --> 00:28:56,389
on them but for each individual job the

00:28:53,330 --> 00:28:59,030
success rate of a job is upper 90% right

00:28:56,389 --> 00:29:01,010
it is a high 90%

00:28:59,030 --> 00:29:03,050
and that means this case is extremely

00:29:01,010 --> 00:29:05,720
likely you're very likely to save work

00:29:03,050 --> 00:29:08,120
by doing this well let's assume we got

00:29:05,720 --> 00:29:09,620
into our unhappy case something broke

00:29:08,120 --> 00:29:11,330
right people break code that's the

00:29:09,620 --> 00:29:14,030
reason we run the building tests so

00:29:11,330 --> 00:29:15,530
project C is now busted we're gonna look

00:29:14,030 --> 00:29:17,030
back and we're gonna say okay well it

00:29:15,530 --> 00:29:19,010
would be useless of us to say hey

00:29:17,030 --> 00:29:20,600
engineer you you broke stuff when we

00:29:19,010 --> 00:29:24,020
combine your changes with two other

00:29:20,600 --> 00:29:25,910
untested changes that's no fun so we

00:29:24,020 --> 00:29:27,800
look back and say diff one could not

00:29:25,910 --> 00:29:29,810
have broken project see because our

00:29:27,800 --> 00:29:32,870
build graph didn't tell us that C was

00:29:29,810 --> 00:29:35,330
even on its radar so we'll run a copy

00:29:32,870 --> 00:29:37,700
then for diff 2 diff 3 and we figure out

00:29:35,330 --> 00:29:39,290
it was different in this particular case

00:29:37,700 --> 00:29:40,910
and we're back to doing the original

00:29:39,290 --> 00:29:45,050
amount of work but this case is

00:29:40,910 --> 00:29:46,850
extremely unlikely and the least happy

00:29:45,050 --> 00:29:49,430
case where all of those jobs fail is

00:29:46,850 --> 00:29:52,190
significantly more expensive but it's

00:29:49,430 --> 00:29:53,990
also really really unlikely to happen so

00:29:52,190 --> 00:29:55,340
this is a kind of cool thing and part of

00:29:53,990 --> 00:29:56,840
the reason I'm hesitant to even

00:29:55,340 --> 00:29:58,820
speculate on numbers is because there's

00:29:56,840 --> 00:30:00,920
a lot of dimensions to this problem

00:29:58,820 --> 00:30:02,930
right if you stack more dish together

00:30:00,920 --> 00:30:04,790
than if you get in the happy case you

00:30:02,930 --> 00:30:06,040
save a lot more work but on the other

00:30:04,790 --> 00:30:08,710
hand each thing you stack on top

00:30:06,040 --> 00:30:11,240
increases your percentage failure rate

00:30:08,710 --> 00:30:13,610
so you're playing with a trade-off there

00:30:11,240 --> 00:30:15,470
and if each diff run more than two jobs

00:30:13,610 --> 00:30:16,850
then there's also more overlap and you

00:30:15,470 --> 00:30:19,370
get more benefit so there's lots of

00:30:16,850 --> 00:30:22,910
different ways in which this might work

00:30:19,370 --> 00:30:24,560
out this might not one more example of

00:30:22,910 --> 00:30:28,460
how you can scale the diff workflow

00:30:24,560 --> 00:30:31,250
problem the different full problem was

00:30:28,460 --> 00:30:34,370
easy mode continuous runs is where it

00:30:31,250 --> 00:30:35,960
gets hard why it gets hard because at

00:30:34,370 --> 00:30:38,060
the different flow time if I don't run

00:30:35,960 --> 00:30:40,070
something and it breaks continuous runs

00:30:38,060 --> 00:30:41,510
have my back they're gonna file a task

00:30:40,070 --> 00:30:43,570
on you you're not gonna have a great day

00:30:41,510 --> 00:30:45,530
but it's not going out to production in

00:30:43,570 --> 00:30:48,470
continuous runs it's not the end of the

00:30:45,530 --> 00:30:50,630
line but it's closer to it and it's much

00:30:48,470 --> 00:30:53,690
harder to use heuristics to say don't do

00:30:50,630 --> 00:30:58,010
work and just a much harder thing to you

00:30:53,690 --> 00:30:59,210
so and this graph scares me let's break

00:30:58,010 --> 00:31:01,340
this down let's see if there's anything

00:30:59,210 --> 00:31:02,480
we can do in one of these you need to

00:31:01,340 --> 00:31:04,550
build and test all of your stuff on a

00:31:02,480 --> 00:31:08,390
regular basis to see what could go wrong

00:31:04,550 --> 00:31:10,640
and if we do this you know there we can

00:31:08,390 --> 00:31:12,170
break this problem apart we can see you

00:31:10,640 --> 00:31:12,710
know if you want to run your cron jobs

00:31:12,170 --> 00:31:13,730
twice as

00:31:12,710 --> 00:31:17,090
often and you're gonna end up doing

00:31:13,730 --> 00:31:18,649
twice as much work you can ask well what

00:31:17,090 --> 00:31:20,120
flag should I use and I mentioned

00:31:18,649 --> 00:31:22,190
earlier we had kind of an iteration

00:31:20,120 --> 00:31:24,679
debugging build mode and then an

00:31:22,190 --> 00:31:27,980
optimized build mode and it turns out we

00:31:24,679 --> 00:31:29,990
use both we want to run the debugging

00:31:27,980 --> 00:31:31,520
mindset because it has sanitizers right

00:31:29,990 --> 00:31:33,320
and you want to find your bugs before

00:31:31,520 --> 00:31:35,539
you ship stuff and yet on the other hand

00:31:33,320 --> 00:31:37,190
you gotta use static linking at some

00:31:35,539 --> 00:31:39,289
point to find those bugs and you also

00:31:37,190 --> 00:31:42,289
need to deploy your binary so you need

00:31:39,289 --> 00:31:44,630
the optimized mode so fine you can play

00:31:42,289 --> 00:31:46,309
with your Flags a little bit but there's

00:31:44,630 --> 00:31:48,350
work to do you got to build and test all

00:31:46,309 --> 00:31:50,270
the things nicely that becomes the warm

00:31:48,350 --> 00:31:52,429
revision and the jobs cooperate with

00:31:50,270 --> 00:31:54,110
each other you're running the test and

00:31:52,429 --> 00:31:55,399
then there's a deployment pipeline maybe

00:31:54,110 --> 00:31:56,720
your shadow in production traffic maybe

00:31:55,399 --> 00:31:58,370
you're running expensive things like

00:31:56,720 --> 00:31:59,480
end-to-end tests but this is what we're

00:31:58,370 --> 00:32:03,230
working with here where can we find

00:31:59,480 --> 00:32:06,049
savings and I've been misleading you

00:32:03,230 --> 00:32:07,340
I've been leaving you under the

00:32:06,049 --> 00:32:11,110
impression that you got a build and test

00:32:07,340 --> 00:32:13,880
all the things and you really don't and

00:32:11,110 --> 00:32:15,289
the reason why not is because these cron

00:32:13,880 --> 00:32:18,740
jobs are running at a continuous

00:32:15,289 --> 00:32:21,080
interval so all you really need to do is

00:32:18,740 --> 00:32:23,570
build the Delta the things that changed

00:32:21,080 --> 00:32:25,490
since the last one we're no longer just

00:32:23,570 --> 00:32:29,360
running make blindly like we did in our

00:32:25,490 --> 00:32:31,850
strawman way back when we're saying run

00:32:29,360 --> 00:32:33,649
but query on all of the files that

00:32:31,850 --> 00:32:35,870
changed between all of the discs are

00:32:33,649 --> 00:32:37,820
right now and the last continuous run

00:32:35,870 --> 00:32:40,850
it's kind of like a really large dip

00:32:37,820 --> 00:32:43,940
batching stack and if you do that you

00:32:40,850 --> 00:32:45,740
can save 20% of your costs right so now

00:32:43,940 --> 00:32:48,559
you're only doing 80% of everything

00:32:45,740 --> 00:32:49,970
that's still really nice and we've

00:32:48,559 --> 00:32:53,960
looked at kind of all these different

00:32:49,970 --> 00:32:55,010
ways to save computing resources reduce

00:32:53,960 --> 00:32:56,270
the amount of time that you the

00:32:55,010 --> 00:32:57,710
developers are waiting for various

00:32:56,270 --> 00:32:59,090
things whether that's you know your your

00:32:57,710 --> 00:33:01,549
diff or sending the binary out to

00:32:59,090 --> 00:33:05,649
production we've reduced flakiness by

00:33:01,549 --> 00:33:08,929
like 80 percent none of that is possible

00:33:05,649 --> 00:33:13,000
without strong CI standard standardized

00:33:08,929 --> 00:33:16,390
configs none of it let's talk about why

00:33:13,000 --> 00:33:18,140
so first off this is a very good

00:33:16,390 --> 00:33:19,970
approximation of what our configuration

00:33:18,140 --> 00:33:23,029
looks like it really does have basically

00:33:19,970 --> 00:33:24,830
two things in it one is tell me what you

00:33:23,029 --> 00:33:26,060
care about what do you want me to make

00:33:24,830 --> 00:33:28,250
sure is built and test

00:33:26,060 --> 00:33:30,260
and to is if it does somehow break in

00:33:28,250 --> 00:33:32,120
trunk who do I file a task on to make

00:33:30,260 --> 00:33:35,720
sure that you're aware of it that's it

00:33:32,120 --> 00:33:37,460
and there's some things that feel like

00:33:35,720 --> 00:33:38,420
they should be there right that feel

00:33:37,460 --> 00:33:40,340
like they would give you this lovely

00:33:38,420 --> 00:33:42,380
sense of control of an ownership that

00:33:40,340 --> 00:33:43,850
would make your life better but in

00:33:42,380 --> 00:33:47,690
practice they kind of have nasty side

00:33:43,850 --> 00:33:49,580
effects thing number one let's say I

00:33:47,690 --> 00:33:51,500
gave you an option which said run my

00:33:49,580 --> 00:33:53,260
continuous runs every n minutes and you

00:33:51,500 --> 00:33:56,570
can choose whatever value and you want

00:33:53,260 --> 00:33:58,700
so we're in a repository with millions

00:33:56,570 --> 00:34:00,560
of files imagine how many of these

00:33:58,700 --> 00:34:02,300
configures do you think there are how

00:34:00,560 --> 00:34:03,830
many different times that people tell us

00:34:02,300 --> 00:34:07,310
this is what I care about right make

00:34:03,830 --> 00:34:07,820
sure it's built and tested and that's a

00:34:07,310 --> 00:34:10,760
big number

00:34:07,820 --> 00:34:12,890
so now adding every one of them telling

00:34:10,760 --> 00:34:14,420
us I want mine you know to run every

00:34:12,890 --> 00:34:16,220
minute I want mine to run every hour I

00:34:14,420 --> 00:34:17,630
want mine to run once a week right they

00:34:16,220 --> 00:34:19,490
give us different numbers maybe how many

00:34:17,630 --> 00:34:23,000
even tells us some weird number like you

00:34:19,490 --> 00:34:26,660
know every 19 hours you could imagine

00:34:23,000 --> 00:34:28,790
somebody would do it if you're living in

00:34:26,660 --> 00:34:30,500
that world there's a bunch of stuff that

00:34:28,790 --> 00:34:31,850
happened so for starters you're

00:34:30,500 --> 00:34:34,040
triggering these continuous run jobs at

00:34:31,850 --> 00:34:36,500
different times and different revisions

00:34:34,040 --> 00:34:38,480
you're no longer filling that cache at

00:34:36,500 --> 00:34:40,250
one revision so they're not cooperating

00:34:38,480 --> 00:34:42,620
with each other they each need to build

00:34:40,250 --> 00:34:44,030
their own folly object file and the

00:34:42,620 --> 00:34:45,590
cache is smart it can you know it

00:34:44,030 --> 00:34:46,940
doesn't have to be the exact revision if

00:34:45,590 --> 00:34:48,620
it's you know within a few and volley

00:34:46,940 --> 00:34:50,630
hasn't actually changed fine it'll

00:34:48,620 --> 00:34:52,040
figure that out it'll reuse it but if

00:34:50,630 --> 00:34:54,680
you're using loudly different numbers

00:34:52,040 --> 00:34:56,420
then you really are going to be paying a

00:34:54,680 --> 00:34:58,640
lot more cost these jobs cannot

00:34:56,420 --> 00:35:00,800
cooperate with each other and then you

00:34:58,640 --> 00:35:02,960
have no more warm revision you can maybe

00:35:00,800 --> 00:35:03,860
have a warm revision per project but

00:35:02,960 --> 00:35:05,450
then the moment you want to add a

00:35:03,860 --> 00:35:08,150
dependency on something else it's cold

00:35:05,450 --> 00:35:09,290
and of course people are making changes

00:35:08,150 --> 00:35:12,380
to the code base that's that's what

00:35:09,290 --> 00:35:13,880
you're all here to do so if you let

00:35:12,380 --> 00:35:16,760
people pick how often their stuff should

00:35:13,880 --> 00:35:18,050
run it actually slows things down now

00:35:16,760 --> 00:35:20,270
let's say you're the I want to run my

00:35:18,050 --> 00:35:23,200
thing once a week person right and let's

00:35:20,270 --> 00:35:25,910
assume that's less frequently than most

00:35:23,200 --> 00:35:28,610
you might argue but I'm saving machines

00:35:25,910 --> 00:35:30,590
and the thing is we don't even run your

00:35:28,610 --> 00:35:32,510
job if it didn't change we just saw that

00:35:30,590 --> 00:35:34,460
with continuous runs we only build your

00:35:32,510 --> 00:35:36,830
continuous run job if your project was

00:35:34,460 --> 00:35:38,450
affected and so we're not wasting

00:35:36,830 --> 00:35:39,760
machines building your stuff making sure

00:35:38,450 --> 00:35:41,530
that it didn't break telling you

00:35:39,760 --> 00:35:44,680
something broke early while it's still

00:35:41,530 --> 00:35:46,990
okay to reverted right

00:35:44,680 --> 00:35:50,020
you don't actually win by letting people

00:35:46,990 --> 00:35:53,140
configure when to run their job now

00:35:50,020 --> 00:35:54,520
another example of that and on the face

00:35:53,140 --> 00:35:56,800
but I kind of really love this one

00:35:54,520 --> 00:35:59,020
because it seems so simple it would be

00:35:56,800 --> 00:36:01,180
super easy to explain to implement to

00:35:59,020 --> 00:36:03,030
debug on everything about it on the face

00:36:01,180 --> 00:36:07,060
of it I really really like

00:36:03,030 --> 00:36:09,100
but in practice is is less good and and

00:36:07,060 --> 00:36:10,900
that is instead of telling us this is

00:36:09,100 --> 00:36:14,650
what I care about I care about thrift

00:36:10,900 --> 00:36:17,320
you also tell us build my config if and

00:36:14,650 --> 00:36:20,200
only if one of these directories has

00:36:17,320 --> 00:36:21,850
been modified so let's say you tell me

00:36:20,200 --> 00:36:23,470
build the thrift config if and only if

00:36:21,850 --> 00:36:26,830
someone modifies a file in the thrift

00:36:23,470 --> 00:36:29,230
directory or the fawley directory well

00:36:26,830 --> 00:36:30,820
now if I change a file in Folly and with

00:36:29,230 --> 00:36:32,680
buck with the build graft I could prove

00:36:30,820 --> 00:36:36,040
that thrift never pound includes that

00:36:32,680 --> 00:36:39,550
file I'm stuck I have to build the

00:36:36,040 --> 00:36:41,080
thrift config I'm wasting machines and

00:36:39,550 --> 00:36:43,600
on the flip side let's say there's a

00:36:41,080 --> 00:36:45,160
library widget and thrift pound includes

00:36:43,600 --> 00:36:47,080
widget and somebody puts up a diff -

00:36:45,160 --> 00:36:49,630
brick - widget and it would break thrift

00:36:47,080 --> 00:36:52,600
now I can't build thrift because you

00:36:49,630 --> 00:36:55,270
told me not to and so I'm under building

00:36:52,600 --> 00:36:57,130
and so if you tell me here is a concrete

00:36:55,270 --> 00:36:59,350
rule for when you should build and test

00:36:57,130 --> 00:37:01,630
my stuff then you lose out everywhere

00:36:59,350 --> 00:37:06,040
you over build and you under build and

00:37:01,630 --> 00:37:08,980
everything is unhappy but let's let's go

00:37:06,040 --> 00:37:11,350
a one step further away from this let's

00:37:08,980 --> 00:37:14,440
not talk about you know how do we pick

00:37:11,350 --> 00:37:15,850
when things should run let's just talk

00:37:14,440 --> 00:37:17,940
about having standardized convicted in

00:37:15,850 --> 00:37:20,680
the first place right most of our jobs

00:37:17,940 --> 00:37:21,940
the the building test stuff that gives

00:37:20,680 --> 00:37:24,520
you results and tells you whether or not

00:37:21,940 --> 00:37:26,350
everything is working our standardized

00:37:24,520 --> 00:37:28,450
they run more or less the same code they

00:37:26,350 --> 00:37:29,590
they all figure out you know what to

00:37:28,450 --> 00:37:32,290
build they they build it they run the

00:37:29,590 --> 00:37:35,710
test they do that sort of work but we

00:37:32,290 --> 00:37:37,930
have other repositories folks who have

00:37:35,710 --> 00:37:40,420
been at the company by folks I mean

00:37:37,930 --> 00:37:41,860
projects for for less time let's say and

00:37:40,420 --> 00:37:43,600
haven't gotten on standardized

00:37:41,860 --> 00:37:46,090
infrastructure and there's a way to just

00:37:43,600 --> 00:37:48,190
say hey continuous integration machines

00:37:46,090 --> 00:37:49,270
you know here's some work go do this

00:37:48,190 --> 00:37:51,880
thing I told you to do

00:37:49,270 --> 00:37:52,770
and if you look at a repository that has

00:37:51,880 --> 00:37:56,220
more of

00:37:52,770 --> 00:37:58,950
kind of jobs the only thing when we

00:37:56,220 --> 00:38:01,860
looked that they had in common was

00:37:58,950 --> 00:38:03,720
source control operations right if you

00:38:01,860 --> 00:38:05,610
were gonna try and optimize horizontally

00:38:03,720 --> 00:38:07,830
across this tier and reduce the amount

00:38:05,610 --> 00:38:09,750
of work that's it that's all you had to

00:38:07,830 --> 00:38:12,900
work with because they weren't doing the

00:38:09,750 --> 00:38:14,550
same thing it is incredibly important to

00:38:12,900 --> 00:38:16,500
make sure that if you are at scale if

00:38:14,550 --> 00:38:18,690
you are running builds tests buzzers

00:38:16,500 --> 00:38:20,550
whatever you're doing at scale that you

00:38:18,690 --> 00:38:23,280
are doing it consistently that you don't

00:38:20,550 --> 00:38:25,530
have customized jobs at least not very

00:38:23,280 --> 00:38:27,180
many of them because if you have too

00:38:25,530 --> 00:38:31,410
many of these things there's nowhere to

00:38:27,180 --> 00:38:34,980
actually make it better all right

00:38:31,410 --> 00:38:36,450
nothing we did today works if we don't

00:38:34,980 --> 00:38:38,250
have the standardization we saw that you

00:38:36,450 --> 00:38:41,220
couldn't get the warm revision if you do

00:38:38,250 --> 00:38:45,450
the continuous run stuff um if you let

00:38:41,220 --> 00:38:46,800
people select by directory when to build

00:38:45,450 --> 00:38:48,210
and test your stuff there's no more

00:38:46,800 --> 00:38:50,130
build craft optimization that there's no

00:38:48,210 --> 00:38:52,470
more 80% savings of diff workflow

00:38:50,130 --> 00:38:55,530
resources there's no flakiness wins

00:38:52,470 --> 00:38:58,290
nothing now I asked you at the beginning

00:38:55,530 --> 00:39:01,710
of this talk to think about why is this

00:38:58,290 --> 00:39:05,490
a C++ talk because there was no C++ code

00:39:01,710 --> 00:39:08,070
in it why are we here why is this at CPP

00:39:05,490 --> 00:39:10,350
con and I told you we would be looking

00:39:08,070 --> 00:39:12,090
at Python back-end services we would be

00:39:10,350 --> 00:39:14,100
looking at mobile apps we would be

00:39:12,090 --> 00:39:15,750
looking at large websites like Facebook

00:39:14,100 --> 00:39:17,400
comm to tease this apart to figure out

00:39:15,750 --> 00:39:20,880
why is what we've been talking about

00:39:17,400 --> 00:39:22,020
really truly a C++ story and I think

00:39:20,880 --> 00:39:24,840
that it isn't that compare and contrast

00:39:22,020 --> 00:39:27,180
that it really comes to life so let's

00:39:24,840 --> 00:39:30,150
talk about Python Facebook have a ton of

00:39:27,180 --> 00:39:30,990
C++ but we also have no small amount of

00:39:30,150 --> 00:39:34,140
Python

00:39:30,990 --> 00:39:37,530
we've got enough Python to go around and

00:39:34,140 --> 00:39:42,150
that means that we can actually compare

00:39:37,530 --> 00:39:43,350
these things pretty well so if you look

00:39:42,150 --> 00:39:45,270
at our Python we've got some back-end

00:39:43,350 --> 00:39:47,420
services in that we've got some scripts

00:39:45,270 --> 00:39:50,930
we've got a hodgepodge of other stuff

00:39:47,420 --> 00:39:54,120
why is it different thing number one

00:39:50,930 --> 00:39:56,790
where's the compile where's the linking

00:39:54,120 --> 00:39:58,170
right there's some small amount of stuff

00:39:56,790 --> 00:40:01,410
you might do before you just run the

00:39:58,170 --> 00:40:02,910
code but it doesn't even compare to the

00:40:01,410 --> 00:40:05,280
amount of work you're doing in C++ we

00:40:02,910 --> 00:40:06,660
saw earlier that actually we didn't see

00:40:05,280 --> 00:40:08,130
I stripped that up

00:40:06,660 --> 00:40:10,500
about two-thirds of the work that we do

00:40:08,130 --> 00:40:11,880
in any given one of these jobs is spent

00:40:10,500 --> 00:40:15,049
building linking whatever you want to

00:40:11,880 --> 00:40:17,759
call it so for python that's not there

00:40:15,049 --> 00:40:22,140
you don't have that cost it is a very

00:40:17,759 --> 00:40:24,720
different beast and then you can take a

00:40:22,140 --> 00:40:26,279
look at your build graph and the C++

00:40:24,720 --> 00:40:29,190
build graph is wildly different from the

00:40:26,279 --> 00:40:30,869
Python one because in Python you might

00:40:29,190 --> 00:40:32,339
have a library like Folly where everyone

00:40:30,869 --> 00:40:34,470
eventually you are actually probably

00:40:32,339 --> 00:40:35,910
more like directly needs it right you've

00:40:34,470 --> 00:40:37,769
got some core things in every language

00:40:35,910 --> 00:40:39,390
everyone's gonna use the core things but

00:40:37,769 --> 00:40:42,960
what you don't have is as many layers as

00:40:39,390 --> 00:40:45,930
many connections right C++ I think it's

00:40:42,960 --> 00:40:48,359
well understood that it's a language

00:40:45,930 --> 00:40:49,920
where you have the ability to say I'm

00:40:48,359 --> 00:40:50,910
going to build a layer of abstraction on

00:40:49,920 --> 00:40:51,960
this thing somebody's gonna build a

00:40:50,910 --> 00:40:53,309
layer on top of that somebody who's

00:40:51,960 --> 00:40:55,140
gonna build a layer on top of that um

00:40:53,309 --> 00:40:58,519
you're going to have libraries upon

00:40:55,140 --> 00:41:00,720
libraries upon libraries Python less so

00:40:58,519 --> 00:41:02,730
right at least an our code base and we

00:41:00,720 --> 00:41:05,099
measured this you can measure how much

00:41:02,730 --> 00:41:06,900
stuff do you build and test for a change

00:41:05,099 --> 00:41:08,910
of that only affects C++ that only

00:41:06,900 --> 00:41:11,099
affects Python and those numbers are

00:41:08,910 --> 00:41:13,920
wildly different the Python graph just

00:41:11,099 --> 00:41:15,569
isn't as connected even though there are

00:41:13,920 --> 00:41:19,380
core libraries that all of these things

00:41:15,569 --> 00:41:21,059
actually need so the Python story is

00:41:19,380 --> 00:41:22,049
different because you're not doing a lot

00:41:21,059 --> 00:41:23,640
of bills in the first place you're

00:41:22,049 --> 00:41:25,799
caching doesn't matter so much and your

00:41:23,640 --> 00:41:27,990
build graphs the distances are already

00:41:25,799 --> 00:41:31,019
really really small because that's how

00:41:27,990 --> 00:41:33,990
python is well what about mobile apps

00:41:31,019 --> 00:41:37,410
right and let's talk about iOS because

00:41:33,990 --> 00:41:39,690
an iOS they do compile so we've got the

00:41:37,410 --> 00:41:40,680
Facebook app for iOS you've got whatsapp

00:41:39,690 --> 00:41:43,200
you've got Instagram you've got all

00:41:40,680 --> 00:41:45,569
these things but the list of these

00:41:43,200 --> 00:41:47,400
things is actually kind of small when

00:41:45,569 --> 00:41:50,369
you're talking about our main C++ code

00:41:47,400 --> 00:41:52,559
base you know we're talking a whole mess

00:41:50,369 --> 00:41:54,450
of different back-end services and other

00:41:52,559 --> 00:41:57,089
stuff written in C++ a whole lot of

00:41:54,450 --> 00:41:58,500
stuff and so if you manage to break one

00:41:57,089 --> 00:42:00,630
of these right because somehow your

00:41:58,500 --> 00:42:03,000
heuristic failed oh you've made one team

00:42:00,630 --> 00:42:05,750
kind of sad that day but everyone else

00:42:03,000 --> 00:42:08,460
is fine in mobile if you break the

00:42:05,750 --> 00:42:11,430
compilation of the iOS app that's

00:42:08,460 --> 00:42:13,349
affecting way more engineers might

00:42:11,430 --> 00:42:14,640
forget deploying bugs to production for

00:42:13,349 --> 00:42:16,589
a moment we're not going to do that but

00:42:14,640 --> 00:42:19,049
if the compile breaks if some

00:42:16,589 --> 00:42:20,080
significant test suite breaks there are

00:42:19,049 --> 00:42:23,710
more engineer

00:42:20,080 --> 00:42:26,260
day that has slowed down so the mistakes

00:42:23,710 --> 00:42:28,570
have a higher cost to them and so we've

00:42:26,260 --> 00:42:30,670
got a sibling team at work folks who

00:42:28,570 --> 00:42:32,560
come from a machine-learning background

00:42:30,670 --> 00:42:33,910
and they went where the problem was

00:42:32,560 --> 00:42:36,640
harder they went to mobile where

00:42:33,910 --> 00:42:37,870
mistakes are more costly and they're

00:42:36,640 --> 00:42:39,220
able to use machine learning to figure

00:42:37,870 --> 00:42:40,390
out what should we build and test not

00:42:39,220 --> 00:42:41,920
just you know a simple distance

00:42:40,390 --> 00:42:43,330
heuristic and there are papers you can

00:42:41,920 --> 00:42:46,900
you can google for these things um

00:42:43,330 --> 00:42:48,640
they're available so the the problem

00:42:46,900 --> 00:42:50,380
there is also different even though the

00:42:48,640 --> 00:42:51,910
compiled the stakes are hired simply

00:42:50,380 --> 00:42:54,490
because there's more people working on

00:42:51,910 --> 00:42:55,870
it and even if you exclude that there

00:42:54,490 --> 00:42:58,960
build graph just has a very different

00:42:55,870 --> 00:43:02,380
shape as well oh sorry

00:42:58,960 --> 00:43:06,130
web let's talk about web so we've got a

00:43:02,380 --> 00:43:08,710
big website and there's no compilation

00:43:06,130 --> 00:43:12,310
to speak of at all not a lick

00:43:08,710 --> 00:43:14,080
there's no builds there's no build graph

00:43:12,310 --> 00:43:15,760
there's no pound includes no

00:43:14,080 --> 00:43:17,440
dependencies to follow and so if you

00:43:15,760 --> 00:43:19,240
want to figure out what tests to run you

00:43:17,440 --> 00:43:21,310
might be stuck for example saying all

00:43:19,240 --> 00:43:22,900
right I'm gonna run the tests see what

00:43:21,310 --> 00:43:24,430
code that covers with code coverage and

00:43:22,900 --> 00:43:25,480
remember that figure out what tests to

00:43:24,430 --> 00:43:27,670
run in the future it's a different

00:43:25,480 --> 00:43:29,260
ballgame and I don't know about you

00:43:27,670 --> 00:43:31,060
right I know that there are blazing-fast

00:43:29,260 --> 00:43:34,030
C++ unit tests out there there are

00:43:31,060 --> 00:43:36,280
blazing fast web tests out there but I

00:43:34,030 --> 00:43:40,090
feel like you're more likely to end up

00:43:36,280 --> 00:43:42,610
with a few tests in a C++ code base that

00:43:40,090 --> 00:43:44,680
try and do something really expensive

00:43:42,610 --> 00:43:46,840
they want to spin up lots of stuff they

00:43:44,680 --> 00:43:49,750
want to talk to each other um that seems

00:43:46,840 --> 00:43:51,880
like a C++ side of the equation that I

00:43:49,750 --> 00:43:54,520
just don't find as much of when I look

00:43:51,880 --> 00:43:56,530
at our web codebase and so in a code

00:43:54,520 --> 00:43:58,540
base where compile time is nothing and

00:43:56,530 --> 00:44:03,000
so all you're talking about is execution

00:43:58,540 --> 00:44:05,860
time that also potentially way smaller

00:44:03,000 --> 00:44:07,600
it is a very different problem space and

00:44:05,860 --> 00:44:09,220
for that reason what we've been talking

00:44:07,600 --> 00:44:11,680
about today the need for caching the

00:44:09,220 --> 00:44:13,720
benefits of caching and how to take full

00:44:11,680 --> 00:44:15,220
advantage of that the problem of

00:44:13,720 --> 00:44:17,800
selecting what should you build and test

00:44:15,220 --> 00:44:20,290
and being able to even use distance as a

00:44:17,800 --> 00:44:22,000
heuristic that is meaningful there that

00:44:20,290 --> 00:44:24,490
you're able to play heuristic games and

00:44:22,000 --> 00:44:27,190
make some mistakes very rarely and not

00:44:24,490 --> 00:44:29,400
have the matter that is a property of a

00:44:27,190 --> 00:44:32,500
C++ code base

00:44:29,400 --> 00:44:33,440
now our journey today was detect all the

00:44:32,500 --> 00:44:35,000
bugs

00:44:33,440 --> 00:44:38,329
and do a lot less work in the process

00:44:35,000 --> 00:44:40,310
and we did that by using caching by

00:44:38,329 --> 00:44:42,319
using build graph heuristics we saw that

00:44:40,310 --> 00:44:45,560
none of that actually works if you have

00:44:42,319 --> 00:44:47,329
bad CI configs and we wrapped it up by

00:44:45,560 --> 00:44:50,240
saying this is a C++ story this is

00:44:47,329 --> 00:44:53,030
different from Python from mobile from

00:44:50,240 --> 00:45:05,900
web I hope you enjoyed the journey thank

00:44:53,030 --> 00:45:49,430
you very much for being here I'll take

00:45:05,900 --> 00:45:51,380
the mic so just let me see if I got the

00:45:49,430 --> 00:45:52,640
question right is the question that

00:45:51,380 --> 00:45:54,109
you're using rocks DB you want to

00:45:52,640 --> 00:45:56,060
upgrade it but you're nervous because

00:45:54,109 --> 00:45:57,680
it's understandably like a database and

00:45:56,060 --> 00:45:58,880
that's a very sensitive thing you're

00:45:57,680 --> 00:46:04,490
wondering if there's tips for how to do

00:45:58,880 --> 00:46:06,260
that is that correct yeah okay you know

00:46:04,490 --> 00:46:09,220
I'm just gonna start by saying I don't

00:46:06,260 --> 00:46:12,319
have a perfect answer for you here but

00:46:09,220 --> 00:46:14,630
at the end of the day you need to have

00:46:12,319 --> 00:46:16,190
some kind of a test whether or not

00:46:14,630 --> 00:46:17,680
that's a unit test or an end-to-end test

00:46:16,190 --> 00:46:20,930
or shadowing production traffic

00:46:17,680 --> 00:46:23,450
something that says am I going to break

00:46:20,930 --> 00:46:25,520
this and then you need to run it that's

00:46:23,450 --> 00:46:28,609
kind of all I can say there right you

00:46:25,520 --> 00:46:30,260
also want have dating so that you can

00:46:28,609 --> 00:46:32,030
roll it out a bit at a time hopefully I

00:46:30,260 --> 00:46:33,589
don't know if that's possible in the

00:46:32,030 --> 00:46:36,740
scope of rocks TV but hopefully it is

00:46:33,589 --> 00:46:38,780
and if you're able to roll it out slowly

00:46:36,740 --> 00:46:40,520
and compare and measure that would be

00:46:38,780 --> 00:46:42,140
how I would say to do it but the truth

00:46:40,520 --> 00:46:45,820
is this is not something I'm an expert

00:46:42,140 --> 00:47:05,720
on that particular case Thanks

00:46:45,820 --> 00:47:08,240
hi sorry I missed that because of echo

00:47:05,720 --> 00:47:27,170
is there any way we can we can reduce

00:47:08,240 --> 00:47:29,120
the echo a little bit let's do that got

00:47:27,170 --> 00:47:30,110
it so the question was for the warm

00:47:29,120 --> 00:47:32,030
revision what if you have multiple

00:47:30,110 --> 00:47:33,590
branches do you like kind of do it on

00:47:32,030 --> 00:47:37,880
all the branches and somehow get it all

00:47:33,590 --> 00:47:38,930
back together is that correct so more or

00:47:37,880 --> 00:47:42,170
less we just don't have a lot of

00:47:38,930 --> 00:47:43,970
branching people build off of trunk and

00:47:42,170 --> 00:47:46,360
so for that reason we just don't have to

00:47:43,970 --> 00:47:46,360
solve that problem

00:48:06,160 --> 00:48:11,270
so at some periodic interval we wake up

00:48:09,350 --> 00:48:12,890
and we build and test all the things

00:48:11,270 --> 00:48:15,290
that master and that becomes the warm

00:48:12,890 --> 00:48:17,690
revision there's no particular logic to

00:48:15,290 --> 00:48:19,220
say how many revisions in the future you

00:48:17,690 --> 00:48:21,760
should go it's more of a time-based

00:48:19,220 --> 00:48:21,760
thing

00:49:16,420 --> 00:49:21,650
cool let me see if I got that again so I

00:49:19,400 --> 00:49:23,420
think where you're asking is some

00:49:21,650 --> 00:49:25,490
compilation units are really expensive

00:49:23,420 --> 00:49:27,620
do we have tooling to detect that or

00:49:25,490 --> 00:49:29,210
other things to kind of figure out this

00:49:27,620 --> 00:49:32,120
is where the costs are in your builds

00:49:29,210 --> 00:49:33,530
and you know maybe as an extension of

00:49:32,120 --> 00:49:37,240
that question with that ever maybe be

00:49:33,530 --> 00:49:40,490
open sourced or something like that okay

00:49:37,240 --> 00:49:42,710
so we we do have stuff like this there

00:49:40,490 --> 00:49:44,780
maybe not as mature as one would might

00:49:42,710 --> 00:49:46,700
hope but we've got a team of folks who

00:49:44,780 --> 00:49:50,540
are trying to figure out you know hey

00:49:46,700 --> 00:49:52,100
how can we actually make our build times

00:49:50,540 --> 00:49:53,960
more manageable than they are today

00:49:52,100 --> 00:49:56,210
and they're looking at this we have

00:49:53,960 --> 00:49:58,490
folks who've been able to do this but

00:49:56,210 --> 00:50:01,160
basically with no small amount of effort

00:49:58,490 --> 00:50:03,020
if we get it to the point where it's you

00:50:01,160 --> 00:50:05,750
know you just run it and it's basically

00:50:03,020 --> 00:50:07,550
done then I think we'd be in a better

00:50:05,750 --> 00:50:10,400
position to start talking about open

00:50:07,550 --> 00:50:11,990
sourcing but until that happens you know

00:50:10,400 --> 00:50:14,530
all I can really say we've got folks

00:50:11,990 --> 00:50:14,530
looking at it

00:50:36,140 --> 00:50:42,570
so I'm not sure I got this one I'm gonna

00:50:38,610 --> 00:50:44,310
test my not my comprehension again are

00:50:42,570 --> 00:50:45,840
you saying tool teen is in like maybe

00:50:44,310 --> 00:50:59,070
you have to build for Windows and for

00:50:45,840 --> 00:51:04,020
Linux and how do you deal with that got

00:50:59,070 --> 00:51:05,670
it okay so I think I got this let's say

00:51:04,020 --> 00:51:07,050
you've got a version of a compiler and

00:51:05,670 --> 00:51:08,370
you're upgrading to another compiler or

00:51:07,050 --> 00:51:10,740
maybe just some big important

00:51:08,370 --> 00:51:11,880
third-party library how do you deal with

00:51:10,740 --> 00:51:16,620
that and I think you were asking how

00:51:11,880 --> 00:51:18,420
does it affect the cache so short term

00:51:16,620 --> 00:51:20,430
there is an impact on the cache right

00:51:18,420 --> 00:51:22,050
you you don't necessarily immediately

00:51:20,430 --> 00:51:25,710
transition everything all at the same

00:51:22,050 --> 00:51:27,870
time and so you might have to recompile

00:51:25,710 --> 00:51:29,300
certain object files bearing in mind if

00:51:27,870 --> 00:51:31,440
you're using two different compilers and

00:51:29,300 --> 00:51:35,190
the build tool can actually take that

00:51:31,440 --> 00:51:37,230
into account long term and just kind of

00:51:35,190 --> 00:51:38,700
our general strategy is try not to have

00:51:37,230 --> 00:51:41,070
very many versions of stuff at any given

00:51:38,700 --> 00:51:44,550
moment we try very hard to have no more

00:51:41,070 --> 00:51:47,280
than two versions of anything and that

00:51:44,550 --> 00:51:48,780
helps the problem a whole lot and and on

00:51:47,280 --> 00:51:49,830
top of that it's not like you can mix

00:51:48,780 --> 00:51:52,020
and match these things

00:51:49,830 --> 00:51:53,370
it's thirds like a mess of them over

00:51:52,020 --> 00:51:55,980
there and you upgrade them all at once

00:51:53,370 --> 00:52:00,470
now on the next one and that helps keep

00:51:55,980 --> 00:52:00,470
the cash from charting too much

00:52:30,430 --> 00:52:35,170
I'm honestly having a lot of trouble

00:52:32,349 --> 00:53:04,799
with just the microphone I'm gonna just

00:52:35,170 --> 00:53:07,569
jump down here and let's just talk yes

00:53:04,799 --> 00:53:10,480
yeah so we found that using the distance

00:53:07,569 --> 00:53:12,099
heuristic held for basically the entire

00:53:10,480 --> 00:53:14,499
repository anything that was not on that

00:53:12,099 --> 00:53:16,329
slide it works for it was the virtual

00:53:14,499 --> 00:53:18,190
machine it was the generated node that

00:53:16,329 --> 00:53:20,019
gave us any amount of trouble everything

00:53:18,190 --> 00:53:24,630
else with whatever distance threshold we

00:53:20,019 --> 00:53:24,630
were using didn't blow up as far as we

00:53:29,339 --> 00:54:06,759
right yeah honestly that sounds just

00:54:04,269 --> 00:54:08,559
like a wildly different ecosystem so I

00:54:06,759 --> 00:54:10,420
would have a really hard time making

00:54:08,559 --> 00:54:12,069
assertions about the right way to do

00:54:10,420 --> 00:54:14,529
that I would I would go back to first

00:54:12,069 --> 00:54:15,609
principles and want to measure you know

00:54:14,529 --> 00:54:16,839
in a world where you have different

00:54:15,609 --> 00:54:18,849
repos for things I think it's more

00:54:16,839 --> 00:54:20,200
likely that you would have a stable

00:54:18,849 --> 00:54:21,940
version of each of those repos and when

00:54:20,200 --> 00:54:24,099
you go and depend on another repo you be

00:54:21,940 --> 00:54:25,960
talking to the stable one or the the

00:54:24,099 --> 00:54:28,210
directly or the network to a service

00:54:25,960 --> 00:54:31,660
that published that you know works and

00:54:28,210 --> 00:54:32,890
so with that in mind the need for let's

00:54:31,660 --> 00:54:34,329
say a warmer vision is diminished

00:54:32,890 --> 00:54:35,440
because most people are building the

00:54:34,329 --> 00:54:37,089
same thing anyway

00:54:35,440 --> 00:54:38,319
or you get warm for free because you

00:54:37,089 --> 00:54:39,849
have a stable version of every single

00:54:38,319 --> 00:54:42,249
library every single repo that you might

00:54:39,849 --> 00:54:42,850
depend on um so the trade-off space is

00:54:42,249 --> 00:54:46,450
varied

00:54:42,850 --> 00:54:48,700
and you also have a you know less

00:54:46,450 --> 00:54:50,260
ability to let's say use something like

00:54:48,700 --> 00:54:51,760
buk querying to figure out what should

00:54:50,260 --> 00:54:53,110
you build I'm just because it's a less

00:54:51,760 --> 00:54:54,400
important problem you've built

00:54:53,110 --> 00:54:56,470
everything and then you've got object

00:54:54,400 --> 00:54:57,970
files that your your you know maybe or

00:54:56,470 --> 00:55:00,060
dot a files or whatever it is that

00:54:57,970 --> 00:55:02,050
you've got directly that you're using

00:55:00,060 --> 00:55:14,650
it'd be really difficult for me to

00:55:02,050 --> 00:55:17,140
hazard a guess all I can say is that

00:55:14,650 --> 00:55:58,630
that might be the way to do it make an

00:55:17,140 --> 00:56:00,880
assertion without without having so even

00:55:58,630 --> 00:56:02,500
if you wait to run all of your tests

00:56:00,880 --> 00:56:04,300
until the last possible second before

00:56:02,500 --> 00:56:06,220
you push the code there's a race

00:56:04,300 --> 00:56:07,870
condition right just fundamentally

00:56:06,220 --> 00:56:10,390
somebody's ship some code in that window

00:56:07,870 --> 00:56:11,470
and so it's really difficult to avoid

00:56:10,390 --> 00:56:13,120
this today

00:56:11,470 --> 00:56:14,860
it's just not that big of a problem in

00:56:13,120 --> 00:56:16,960
our C++ code base for the same reason

00:56:14,860 --> 00:56:19,330
why the state for hire and mobile wear

00:56:16,960 --> 00:56:21,550
if the app breaks a lot more folks care

00:56:19,330 --> 00:56:23,080
whereas there's less individual

00:56:21,550 --> 00:56:25,570
engineers working on each individual

00:56:23,080 --> 00:56:26,860
back-end service and so the odds of a

00:56:25,570 --> 00:56:28,870
race conditioning happening they're

00:56:26,860 --> 00:56:32,290
lower and so it just hasn't been a huge

00:56:28,870 --> 00:56:34,930
concern yet an idea that we've been

00:56:32,290 --> 00:56:37,170
talking about for if we and when the day

00:56:34,930 --> 00:56:39,220
comes where this is a bigger problem is

00:56:37,170 --> 00:56:41,710
instead of letting everyone willy-nilly

00:56:39,220 --> 00:56:43,390
push through the code base get a whole

00:56:41,710 --> 00:56:45,100
bunch of folks right grab everyone who's

00:56:43,390 --> 00:56:46,330
ready to ship in this 15 minute interval

00:56:45,100 --> 00:56:48,040
and ship them all together and just

00:56:46,330 --> 00:56:49,300
serialize the stuff ship a hundred

00:56:48,040 --> 00:56:50,890
things at a time you can test them all

00:56:49,300 --> 00:56:52,510
together and you can be certain that

00:56:50,890 --> 00:56:53,950
you're not going to break stuff it has

00:56:52,510 --> 00:56:55,859
different characteristics because you're

00:56:53,950 --> 00:56:58,950
going to be in current kind of a

00:56:55,859 --> 00:57:00,210
forced wait time on people and maybe

00:56:58,950 --> 00:57:01,650
you'll even be spending more machines

00:57:00,210 --> 00:57:04,650
depending on when you choose to run your

00:57:01,650 --> 00:57:06,450
tests but if race conditions are a big

00:57:04,650 --> 00:57:07,769
deal that would be the Avenue I would be

00:57:06,450 --> 00:57:14,640
looking at because you can actually

00:57:07,769 --> 00:57:16,739
guarantee it that way we play some games

00:57:14,640 --> 00:57:26,970
to minimize race conditions but the

00:57:16,739 --> 00:57:28,829
emphasis is on minimize not remove the

00:57:26,970 --> 00:57:30,960
number of pound includes it takes to get

00:57:28,829 --> 00:57:38,789
from one bubble in our graph to some

00:57:30,960 --> 00:57:41,249
other bubble in the graph indeed and so

00:57:38,789 --> 00:57:43,650
folly does have an enormous number of

00:57:41,249 --> 00:57:44,910
things that are distance one but it also

00:57:43,650 --> 00:57:47,190
has a bunch of things that are higher

00:57:44,910 --> 00:57:48,779
distances away because it needs to go

00:57:47,190 --> 00:57:50,309
through a few other libraries before

00:57:48,779 --> 00:57:53,970
finally somebody pound includes folly

00:57:50,309 --> 00:57:56,039
and so you know that's why for folly you

00:57:53,970 --> 00:57:57,930
know we weren't done yet when we just

00:57:56,039 --> 00:57:59,789
did be the art ups with a limit of two

00:57:57,930 --> 00:58:02,880
in the slides we then needed to layer on

00:57:59,789 --> 00:58:05,039
top the take the closest m and if you do

00:58:02,880 --> 00:58:06,900
that then you know you're you're again

00:58:05,039 --> 00:58:08,489
saying here's an upper bound

00:58:06,900 --> 00:58:10,499
I know folly has a lot of stuff that

00:58:08,489 --> 00:58:12,150
depends on it directly um but in

00:58:10,499 --> 00:58:23,130
practice you can get away with that it

00:58:12,150 --> 00:58:24,299
works out yes so the question is how

00:58:23,130 --> 00:58:26,190
many should we choose to batch and I

00:58:24,299 --> 00:58:28,470
don't know the answer yet because like I

00:58:26,190 --> 00:58:31,380
said it's in production for a certain

00:58:28,470 --> 00:58:33,269
subset of our web tests but for C++ we

00:58:31,380 --> 00:58:35,640
have not fully rolled this out we have

00:58:33,269 --> 00:58:37,170
not tuned the parameters and so I can't

00:58:35,640 --> 00:58:38,759
I can't really tell you the numbers will

00:58:37,170 --> 00:58:41,059
be until we try it out and see what

00:58:38,759 --> 00:58:41,059
happens

00:58:57,780 --> 00:59:01,980
so it's a lot easier to maintain

00:59:00,000 --> 00:59:04,350
consistent rules than ones that are

00:59:01,980 --> 00:59:06,210
different but certainly we we are

00:59:04,350 --> 00:59:08,130
measuring failure rates and identifying

00:59:06,210 --> 00:59:09,690
common patterns and doing our best to

00:59:08,130 --> 00:59:16,290
make sure that whatever those patterns

00:59:09,690 --> 00:59:17,640
are removed cool thank you everyone for

00:59:16,290 --> 00:59:19,680
being here and if you want I'll be

00:59:17,640 --> 00:59:24,460
around for some more minutes

00:59:19,680 --> 00:59:24,460

YouTube URL: https://www.youtube.com/watch?v=p7xdNjdtojU


