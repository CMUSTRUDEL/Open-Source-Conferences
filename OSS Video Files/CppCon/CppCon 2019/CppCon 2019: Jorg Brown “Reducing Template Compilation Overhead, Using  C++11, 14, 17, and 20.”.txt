Title: CppCon 2019: Jorg Brown “Reducing Template Compilation Overhead, Using  C++11, 14, 17, and 20.”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
At their best, new C++ standards offer simpler, clearer, and faster-to-compile ways to write your code. But many information sources, for example Andrei Alexandrescu’s Modern C++ Design, haven’t been updated.

More importantly, template metaprogramming is not something we generally seek to optimize because a good compiler handles it well, and problems generally only show up in the form of long compile times.

In this presentation, I'll describe techniques you can use to simplify, clarify, and improve the compile speed, of your code, including:
* Using C++17 "if constexpr"
* Using C++11 variadic function / template arguments (often without needing recursion!)
* Using decltype on auto-return functions in order to compute types in a more readable way.
* Using C++20 constraints rather than std::enable_if
— 
Jorg Brown
Google
Software Engineer
jorg.brown@gmail.com

Jorg Brown started coding in the days when getting a home computer often meant assembling it yourself, and while he appreciates high-level languages like C++, he also misses those early days, when computers were simple enough that a programmer could actually fully understand a machine, from a high-level API call all the way down to its bare-metal electrical signals.

If he had a programming motto, it would be that code should be as simple as possible... but not not simpler. If he had a second motto, it would be to imagine your kids having to maintain your code 20 years from now... and add comments accordingly.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,340 --> 00:00:12,600
all right hello everybody my name is

00:00:10,740 --> 00:00:14,400
your brown work

00:00:12,600 --> 00:00:16,350
Google with channel truth on the

00:00:14,400 --> 00:00:20,539
C++ programming on this platform and

00:00:16,350 --> 00:00:28,369
I've personally specialized on risk five

00:00:20,539 --> 00:00:32,279
seriously okay they'll be working on

00:00:28,369 --> 00:00:33,900
I'll just try this one for now so I like

00:00:32,279 --> 00:00:37,410
Chandler I'm obsessed with performance

00:00:33,900 --> 00:00:41,850
and optimization and for some time I've

00:00:37,410 --> 00:00:44,040
wanted to give a talk at VB con rather

00:00:41,850 --> 00:00:44,430
I've wanted to have given a talk at CPP

00:00:44,040 --> 00:00:47,100
gone

00:00:44,430 --> 00:00:49,979
and finally I have something worth

00:00:47,100 --> 00:00:51,750
talking about so there's a recurring

00:00:49,979 --> 00:00:54,409
theme at work which is template

00:00:51,750 --> 00:00:56,659
compilation and overhead sometimes

00:00:54,409 --> 00:00:58,619
there's team comes to us wondering

00:00:56,659 --> 00:01:01,439
complaining really why their builds are

00:00:58,619 --> 00:01:04,530
so slow and a few months ago we switched

00:01:01,439 --> 00:01:06,979
from blitz did C++ and lip to lip C++

00:01:04,530 --> 00:01:09,000
and while it was generally a great thing

00:01:06,979 --> 00:01:11,880
there were a couple of builds that

00:01:09,000 --> 00:01:13,170
refused to build anymore and so a couple

00:01:11,880 --> 00:01:15,689
of us were cast to go and figure out

00:01:13,170 --> 00:01:17,520
what's going on and so this is basically

00:01:15,689 --> 00:01:19,530
the story of the journey to figure out

00:01:17,520 --> 00:01:21,390
what the problems were and help those

00:01:19,530 --> 00:01:25,080
people and in the case of look to was

00:01:21,390 --> 00:01:26,700
supposed to have ourselves so generally

00:01:25,080 --> 00:01:30,180
when I see a compiler it's running out

00:01:26,700 --> 00:01:31,530
of RAM going slow you could just plain

00:01:30,180 --> 00:01:33,120
tablets it's it's almost always the

00:01:31,530 --> 00:01:34,830
problem like we we give up to ten

00:01:33,120 --> 00:01:38,400
gigabytes of RAM to a compiler and

00:01:34,830 --> 00:01:40,790
you're not going to run out in any more

00:01:38,400 --> 00:01:43,020
effective way than misuse of templates

00:01:40,790 --> 00:01:47,070
they're just such a great way to run a

00:01:43,020 --> 00:01:48,870
compiler into the ground before I go

00:01:47,070 --> 00:01:51,440
into too deep into that let me go to

00:01:48,870 --> 00:01:51,440
some background

00:01:51,860 --> 00:01:57,750
first of all just programming basics

00:01:54,780 --> 00:02:01,380
bubble sort is not that bad as long as n

00:01:57,750 --> 00:02:04,200
is small in fact really not that bad but

00:02:01,380 --> 00:02:05,610
what is optimal when n is 3 you can't do

00:02:04,200 --> 00:02:07,409
better than that

00:02:05,610 --> 00:02:09,869
likewise there's a lot of templates

00:02:07,409 --> 00:02:11,220
where if you're not in specifically it's

00:02:09,869 --> 00:02:13,980
mostly very attic templates that are

00:02:11,220 --> 00:02:15,750
causing the problem as long as you're

00:02:13,980 --> 00:02:16,340
not dealing with many parameters they're

00:02:15,750 --> 00:02:19,170
fine

00:02:16,340 --> 00:02:21,360
the trouble is some people write some

00:02:19,170 --> 00:02:23,609
code with a small number of parameters

00:02:21,360 --> 00:02:25,049
in mind and then it gets out into the

00:02:23,609 --> 00:02:25,410
real world and people just adding more

00:02:25,049 --> 00:02:28,040
and

00:02:25,410 --> 00:02:30,390
more and more so in one case we had

00:02:28,040 --> 00:02:32,730
software designed to be able to specify

00:02:30,390 --> 00:02:36,090
a number of folks into you know some

00:02:32,730 --> 00:02:38,340
code that receives our pcs and just I'm

00:02:36,090 --> 00:02:40,140
from Sanford I have maybe 15 or 20 hooks

00:02:38,340 --> 00:02:41,640
when you get into the real world you

00:02:40,140 --> 00:02:43,200
look at you know people are complaining

00:02:41,640 --> 00:02:44,640
about things being slow it's because

00:02:43,200 --> 00:02:52,230
they're passing a hundred and fifty

00:02:44,640 --> 00:02:53,520
template parameters so that's that's

00:02:52,230 --> 00:02:54,840
what this talk is really about how to

00:02:53,520 --> 00:02:58,530
deal with that and make that efficient

00:02:54,840 --> 00:03:00,000
despite the magnitude not so it's kind

00:02:58,530 --> 00:03:03,960
of hard to measure sometimes what things

00:03:00,000 --> 00:03:05,370
are going well you can't just you know

00:03:03,960 --> 00:03:07,200
it's startup the UNIX tool and measure

00:03:05,370 --> 00:03:09,540
the amount of memory allocation before

00:03:07,200 --> 00:03:11,190
and after in many cases because the test

00:03:09,540 --> 00:03:16,770
cases that you construct are just lost

00:03:11,190 --> 00:03:18,210
in the noise and the real cases where

00:03:16,770 --> 00:03:20,520
people are doing you know real work and

00:03:18,210 --> 00:03:22,260
the Kabala takes you know five minutes

00:03:20,520 --> 00:03:24,720
consumes 10 gigabytes there's so much

00:03:22,260 --> 00:03:26,460
data that you can't handle it so what

00:03:24,720 --> 00:03:30,330
I'd recommend if you are going down this

00:03:26,460 --> 00:03:32,790
path and writing test stuff is in clang

00:03:30,330 --> 00:03:35,700
there's just mice - exclaiming - print

00:03:32,790 --> 00:03:37,530
stats it gives you fine detail exactly

00:03:35,700 --> 00:03:39,420
how many templates are being

00:03:37,530 --> 00:03:41,970
instantiated classes variables

00:03:39,420 --> 00:03:43,350
expressions all kinds of stuff it's

00:03:41,970 --> 00:03:45,120
really useful to compare it you know -

00:03:43,350 --> 00:03:46,860
side by side and make sure that the

00:03:45,120 --> 00:03:48,150
changes you're making are really

00:03:46,860 --> 00:03:49,709
effective in going in the right

00:03:48,150 --> 00:03:53,730
direction

00:03:49,709 --> 00:03:56,010
and by the way generally like that the

00:03:53,730 --> 00:03:58,080
two biggest uses of RAM inside of a

00:03:56,010 --> 00:04:00,690
compiler when it's checking a lot of

00:03:58,080 --> 00:04:05,010
overhead is instantiation of classes and

00:04:00,690 --> 00:04:06,570
instantiations of function it's nothing

00:04:05,010 --> 00:04:09,390
to try if you compile with the minus of

00:04:06,570 --> 00:04:11,340
G option then all of the types that the

00:04:09,390 --> 00:04:13,170
compiler had to instantiate in order to

00:04:11,340 --> 00:04:16,680
build the things for the binaries that

00:04:13,170 --> 00:04:18,570
it's it's dumping out will be listed

00:04:16,680 --> 00:04:21,090
dwarf dump is a great way to look at

00:04:18,570 --> 00:04:23,220
them all and I'll show you some of the

00:04:21,090 --> 00:04:27,530
things that were dumped out one had to

00:04:23,220 --> 00:04:30,120
try that with the lip C++ conversion so

00:04:27,530 --> 00:04:32,210
let's get some more basics just

00:04:30,120 --> 00:04:35,400
functions take a simple example

00:04:32,210 --> 00:04:36,870
Fibonacci this is one way to implement

00:04:35,400 --> 00:04:40,410
it it is not

00:04:36,870 --> 00:04:42,360
fast you've heard of Oh inspired

00:04:40,410 --> 00:04:48,300
routines is the Braille exponential

00:04:42,360 --> 00:04:49,620
routine because it recursive twice for

00:04:48,300 --> 00:04:51,740
every parameter you call it all the way

00:04:49,620 --> 00:04:55,940
until it back gets down to zero or one

00:04:51,740 --> 00:04:59,490
but it compiles really nice and fast

00:04:55,940 --> 00:05:01,250
so let's alter that first let's make the

00:04:59,490 --> 00:05:04,680
function context Bert

00:05:01,250 --> 00:05:08,820
turns out this still compiles really

00:05:04,680 --> 00:05:10,320
nice and fast thing is even though the

00:05:08,820 --> 00:05:11,850
function is declared context bur that

00:05:10,320 --> 00:05:13,530
doesn't mean it's actually going to be

00:05:11,850 --> 00:05:16,140
evaluated compile time it just means

00:05:13,530 --> 00:05:19,320
that it could be if it needed to be so

00:05:16,140 --> 00:05:23,820
the second thing we need to do is need

00:05:19,320 --> 00:05:25,980
it to be so we'll take the result of

00:05:23,820 --> 00:05:28,560
Fibonacci and sign it into a context per

00:05:25,980 --> 00:05:31,620
variable now the compiler has to execute

00:05:28,560 --> 00:05:33,750
it compile time this still works okay

00:05:31,620 --> 00:05:39,090
actually however let's up that number

00:05:33,750 --> 00:05:40,410
from 16 to 27 and now it fails to

00:05:39,090 --> 00:05:43,020
compile with clang it'll give you an

00:05:40,410 --> 00:05:44,820
exceeding step limit error Microsoft

00:05:43,020 --> 00:05:46,620
Visual Studio will compile it but take

00:05:44,820 --> 00:05:49,350
about 10 seconds to compile it and if

00:05:46,620 --> 00:05:51,930
you dope the number to 28 Microsoft will

00:05:49,350 --> 00:05:54,300
also give you a failure in certainly

00:05:51,930 --> 00:05:57,870
enough GCC no problem at all it takes

00:05:54,300 --> 00:05:59,310
less than half a second and the

00:05:57,870 --> 00:06:04,880
underlying problem here is that concepts

00:05:59,310 --> 00:06:04,880
for functions not necessarily memorized

00:06:05,660 --> 00:06:10,950
so during this 10 seconds of Microsoft

00:06:09,270 --> 00:06:14,040
is spending their computing Fibonacci of

00:06:10,950 --> 00:06:19,230
5 + 4 + 3 + 2 hundreds of thousands of

00:06:14,040 --> 00:06:21,990
times so one obvious solution to this is

00:06:19,230 --> 00:06:24,090
switch to a template template has a nice

00:06:21,990 --> 00:06:26,010
feature that whenever a template is

00:06:24,090 --> 00:06:30,380
instantiated it always has to be

00:06:26,010 --> 00:06:33,410
remembered and so you can do it this way

00:06:30,380 --> 00:06:37,140
it's basically the same exact algorithm

00:06:33,410 --> 00:06:39,300
this if you try it it will work except

00:06:37,140 --> 00:06:43,320
for one problem actually it as it's

00:06:39,300 --> 00:06:44,730
listed here it will reverse a thousand

00:06:43,320 --> 00:06:47,160
times and give you an error that's

00:06:44,730 --> 00:06:47,910
trying to instantiate Fibonacci of minus

00:06:47,160 --> 00:06:51,120
00:06:47,910 --> 00:06:52,560
thing and it's exceeded its limit and

00:06:51,120 --> 00:06:55,530
the reason is that there's nothing

00:06:52,560 --> 00:06:57,450
blocking it from recursion the question

00:06:55,530 --> 00:07:02,640
mark : does not block in template

00:06:57,450 --> 00:07:04,500
instantiation so what you solve that is

00:07:02,640 --> 00:07:06,510
you just add a couple of specializations

00:07:04,500 --> 00:07:09,390
for zero on one and that will block it

00:07:06,510 --> 00:07:12,030
and now this works and it's nice and

00:07:09,390 --> 00:07:13,890
fast but also it's a bit ugly little bit

00:07:12,030 --> 00:07:18,030
tedious it's weird to have a loop

00:07:13,890 --> 00:07:19,340
termination occur outside of the class

00:07:18,030 --> 00:07:21,990
[Music]

00:07:19,340 --> 00:07:24,480
so when first times I recommend if

00:07:21,990 --> 00:07:26,550
you're doing this kind of thing C+ 17

00:07:24,480 --> 00:07:29,490
has a nice feature if Const oxberg and

00:07:26,550 --> 00:07:32,250
it makes this code a lot easier to read

00:07:29,490 --> 00:07:33,990
so once instantiating this it sees if

00:07:32,250 --> 00:07:36,210
Const expert everything inside those

00:07:33,990 --> 00:07:38,040
braces will be checked for student to

00:07:36,210 --> 00:07:41,480
make sure the syntax is valid but it

00:07:38,040 --> 00:07:41,480
won't actually instantiate anything

00:07:42,710 --> 00:07:50,580
still it's weird to do it exactly this

00:07:47,910 --> 00:07:53,700
way why am i standing with a class and

00:07:50,580 --> 00:07:55,110
in this case a member variable be nice

00:07:53,700 --> 00:08:00,000
if there was a way to make a function be

00:07:55,110 --> 00:08:02,850
evaluated at compile time so that's what

00:08:00,000 --> 00:08:04,860
I call the one weird trick stood

00:08:02,850 --> 00:08:07,700
interval constant is surprisingly useful

00:08:04,860 --> 00:08:10,260
over and over again in this case will

00:08:07,700 --> 00:08:14,880
instantiate this Fibonacci function but

00:08:10,260 --> 00:08:15,930
instead of passing the function of

00:08:14,880 --> 00:08:18,510
parameter will give it a template

00:08:15,930 --> 00:08:20,040
parameter and then we'll just return the

00:08:18,510 --> 00:08:23,730
stood integral constant with it that

00:08:20,040 --> 00:08:25,710
will force it to become a type that's

00:08:23,730 --> 00:08:29,970
being returned rather than an integer

00:08:25,710 --> 00:08:32,099
and thus will force the memoization to

00:08:29,970 --> 00:08:35,630
happen this function will always be

00:08:32,099 --> 00:08:35,630
contacts but no matter how you call it

00:08:36,050 --> 00:08:43,650
this worked great so another interesting

00:08:40,800 --> 00:08:45,840
thing about this is you'll notice it's

00:08:43,650 --> 00:08:49,530
using an auto return type now it has to

00:08:45,840 --> 00:08:51,030
use an auto return type because the type

00:08:49,530 --> 00:08:53,790
that is returned by this function

00:08:51,030 --> 00:08:55,260
depends on the template parameter and so

00:08:53,790 --> 00:08:57,960
if I tried to specify the function

00:08:55,260 --> 00:08:59,730
return inside of the constructional line

00:08:57,960 --> 00:09:00,760
that would be at least as big as the

00:08:59,730 --> 00:09:02,470
function itself

00:09:00,760 --> 00:09:04,750
and worse than that that's not a place

00:09:02,470 --> 00:09:07,480
that I could use it if Const exper

00:09:04,750 --> 00:09:10,240
so it relies on being able to use an

00:09:07,480 --> 00:09:11,500
auto return type but again that there's

00:09:10,240 --> 00:09:13,389
an extra benefit and it has to do with

00:09:11,500 --> 00:09:18,339
the function signatures which also

00:09:13,389 --> 00:09:20,079
contribute to compiler overhead so here

00:09:18,339 --> 00:09:23,139
are three different ways of writing the

00:09:20,079 --> 00:09:24,880
same function could declare it the

00:09:23,139 --> 00:09:27,459
standard way you could template it so

00:09:24,880 --> 00:09:31,120
that if you take any type of string or

00:09:27,459 --> 00:09:34,000
you could also template it but this time

00:09:31,120 --> 00:09:36,070
use an auto return value of course in

00:09:34,000 --> 00:09:37,449
case we're using using Auto return you

00:09:36,070 --> 00:09:38,920
also have to specify what the body of

00:09:37,449 --> 00:09:44,440
the function is so that can figure out

00:09:38,920 --> 00:09:47,350
what the function signature is so these

00:09:44,440 --> 00:09:47,829
each get mangled it may let some strange

00:09:47,350 --> 00:09:50,709
ways

00:09:47,829 --> 00:09:52,750
the usual C++ mangling doesn't need to

00:09:50,709 --> 00:09:56,260
mangle the return type because based on

00:09:52,750 --> 00:09:58,990
the parameters coming in you always know

00:09:56,260 --> 00:10:00,880
what the return type is in the second

00:09:58,990 --> 00:10:03,339
type however the return type depends on

00:10:00,880 --> 00:10:06,130
the template parameter and because of

00:10:03,339 --> 00:10:11,589
that the return type is part of the

00:10:06,130 --> 00:10:14,740
function mangling and you can get rid

00:10:11,589 --> 00:10:16,269
that overhead if you declared by Auto is

00:10:14,740 --> 00:10:18,279
whatever the front type is just replaced

00:10:16,269 --> 00:10:19,870
by auto now in this case that's not a

00:10:18,279 --> 00:10:21,699
big deal stood string actually is a

00:10:19,870 --> 00:10:24,639
special case in that mangler it consumes

00:10:21,699 --> 00:10:27,730
almost no space but in other cases for

00:10:24,639 --> 00:10:30,510
example if you're using enable if that

00:10:27,730 --> 00:10:33,220
can be a significant issue for example

00:10:30,510 --> 00:10:34,480
where we have routine just takes the

00:10:33,220 --> 00:10:36,970
template parameter which one's the same

00:10:34,480 --> 00:10:41,170
thing back but declare what mangling

00:10:36,970 --> 00:10:42,970
would be however if I declare it enable

00:10:41,170 --> 00:10:46,920
if for no other reason than just to say

00:10:42,970 --> 00:10:49,319
you can't call this if the type is void

00:10:46,920 --> 00:10:51,339
what do you think the mangling is I

00:10:49,319 --> 00:10:52,690
would have thought that there would have

00:10:51,339 --> 00:10:56,160
just mangle the return type stood string

00:10:52,690 --> 00:10:59,680
again that's not what happens

00:10:56,160 --> 00:11:05,199
it mangles the way that it computed what

00:10:59,680 --> 00:11:08,800
the return type is I ask somebody who's

00:11:05,199 --> 00:11:10,720
compiler expert exactly why it does this

00:11:08,800 --> 00:11:11,680
and he told me after about four or five

00:11:10,720 --> 00:11:13,629
minutes

00:11:11,680 --> 00:11:15,519
I think I've asked him two or three

00:11:13,629 --> 00:11:19,420
times in fact I still haven't quite got

00:11:15,519 --> 00:11:21,069
it it's a very long story it has to do

00:11:19,420 --> 00:11:22,839
with what if this particular inline

00:11:21,069 --> 00:11:25,930
function is compiled in two different

00:11:22,839 --> 00:11:27,639
environments where other things are

00:11:25,930 --> 00:11:30,100
possibly present in the typography or

00:11:27,639 --> 00:11:31,929
not anyway

00:11:30,100 --> 00:11:33,999
the important thing is if you have an

00:11:31,929 --> 00:11:37,209
auto return type you don't have to deal

00:11:33,999 --> 00:11:39,429
with this because it's an auto return

00:11:37,209 --> 00:11:42,399
type then the return type is just

00:11:39,429 --> 00:11:45,069
mangled as Auto and in this case you can

00:11:42,399 --> 00:11:46,569
just put the static assert in just sort

00:11:45,069 --> 00:11:48,730
of my you know what I wanted to do in

00:11:46,569 --> 00:11:50,829
the first place and the error message

00:11:48,730 --> 00:11:53,649
you get is much nicer anyway you get

00:11:50,829 --> 00:11:55,809
crowler's says this is it it's clear

00:11:53,649 --> 00:11:57,220
like oh the that type you passed in

00:11:55,809 --> 00:11:58,410
is the same as for you can't do that

00:11:57,220 --> 00:12:01,240
fine

00:11:58,410 --> 00:12:07,240
much better than a very long template

00:12:01,240 --> 00:12:09,990
error message so that's the first part

00:12:07,240 --> 00:12:13,540
of background let's just summarize

00:12:09,990 --> 00:12:18,129
inline context break template so what's

00:12:13,540 --> 00:12:19,720
inline so the compiler called something

00:12:18,129 --> 00:12:22,389
an inline function if you declared it

00:12:19,720 --> 00:12:25,600
inline any contacts per function will be

00:12:22,389 --> 00:12:27,899
considered in line and any templated

00:12:25,600 --> 00:12:31,540
function will be implicitly inline and

00:12:27,899 --> 00:12:33,579
any method function of a templated class

00:12:31,540 --> 00:12:40,179
or template function inside of the class

00:12:33,579 --> 00:12:41,439
is also in line going back to the

00:12:40,179 --> 00:12:43,029
original thing we're just you can

00:12:41,439 --> 00:12:44,709
declare functions inline or not the

00:12:43,029 --> 00:12:46,449
problem there is people tend to be a

00:12:44,709 --> 00:12:48,519
little bit overzealous about calling

00:12:46,449 --> 00:12:51,490
things in line they don't really realize

00:12:48,519 --> 00:12:53,290
exactly what it would mean if all of

00:12:51,490 --> 00:12:55,540
their inline functions weren't actually

00:12:53,290 --> 00:12:57,759
done inline don't realize that like a

00:12:55,540 --> 00:13:00,220
hundred K for a single routine is a bad

00:12:57,759 --> 00:13:03,279
thing and the compiler doesn't like it

00:13:00,220 --> 00:13:04,839
either so the compiler second-guesses

00:13:03,279 --> 00:13:06,339
your declaration of war there's

00:13:04,839 --> 00:13:08,980
something in line so it doesn't really

00:13:06,339 --> 00:13:14,519
mean in line that's what it doesn't mean

00:13:08,980 --> 00:13:14,519
well it what it means is the linker

00:13:14,690 --> 00:13:19,550
okay because an inline function that

00:13:16,430 --> 00:13:22,310
isn't in line could be generated in

00:13:19,550 --> 00:13:23,690
multiple translation units inline really

00:13:22,310 --> 00:13:25,100
means is when the linker sees these

00:13:23,690 --> 00:13:26,740
duplicate definitions of the same

00:13:25,100 --> 00:13:30,620
routine it won't give you an error

00:13:26,740 --> 00:13:32,089
that's all of mine really means a second

00:13:30,620 --> 00:13:34,339
thing is if you declare a function in

00:13:32,089 --> 00:13:36,230
line but that translation unit has no

00:13:34,339 --> 00:13:38,600
need to actually call that function or

00:13:36,230 --> 00:13:39,139
if every use of that indeed really is

00:13:38,600 --> 00:13:41,439
inlined

00:13:39,139 --> 00:13:49,490
then that function will not be generated

00:13:41,439 --> 00:13:50,660
by itself anywhere when back when stocks

00:13:49,490 --> 00:13:52,129
birth again

00:13:50,660 --> 00:13:54,470
it doesn't actually guarantee that

00:13:52,129 --> 00:13:56,540
something's evaluated at compile time it

00:13:54,470 --> 00:13:58,639
just guarantees that it could be if it

00:13:56,540 --> 00:14:02,449
needed to be for at least one set of

00:13:58,639 --> 00:14:04,790
inputs on the other hand template

00:14:02,449 --> 00:14:06,949
instantiation is guaranteed to memorized

00:14:04,790 --> 00:14:12,259
to be memorized a template will only be

00:14:06,949 --> 00:14:14,449
rendered exactly once bound to the

00:14:12,259 --> 00:14:15,920
previous example Fibonacci if context

00:14:14,449 --> 00:14:19,279
for an auto return types go very well

00:14:15,920 --> 00:14:22,670
with template it functions as does stood

00:14:19,279 --> 00:14:25,069
integral constant and finally results

00:14:22,670 --> 00:14:26,839
may vary by compiler as you saw GCC was

00:14:25,069 --> 00:14:28,939
ok with one of the inefficient things

00:14:26,839 --> 00:14:35,529
that we had done the other compilers

00:14:28,939 --> 00:14:35,529
were not so it seems easy enough right

00:14:36,730 --> 00:14:42,949
so now it turns out if you look at a lot

00:14:40,250 --> 00:14:45,410
of the instantiations what they very

00:14:42,949 --> 00:14:48,230
often come to is a set of code that is

00:14:45,410 --> 00:14:51,050
templated on a bunch of types and the

00:14:48,230 --> 00:14:52,759
best way I can describe it is let's talk

00:14:51,050 --> 00:14:53,930
about what it would do to write your

00:14:52,759 --> 00:14:57,670
what would we like to write your own

00:14:53,930 --> 00:15:00,980
tupple class so start with a definition

00:14:57,670 --> 00:15:06,949
it's just a class template Adhan bunch

00:15:00,980 --> 00:15:08,660
of times right so at the base if there's

00:15:06,949 --> 00:15:13,309
only one type being passed then you just

00:15:08,660 --> 00:15:14,629
have one element let's call it first of

00:15:13,309 --> 00:15:16,519
course you need some way to be able to

00:15:14,629 --> 00:15:18,350
get at the element and first is a

00:15:16,519 --> 00:15:20,689
private type so we'll have to declare a

00:15:18,350 --> 00:15:21,709
friend struct called getter we'll come

00:15:20,689 --> 00:15:22,900
back to that in the next slide because

00:15:21,709 --> 00:15:26,260
it doesn't fit on this one

00:15:22,900 --> 00:15:28,240
and of course the all the tuples below

00:15:26,260 --> 00:15:30,550
that will just also declare a member of

00:15:28,240 --> 00:15:32,110
name first but then we'll put all the

00:15:30,550 --> 00:15:34,080
rest of the information in the tupple as

00:15:32,110 --> 00:15:36,550
part of a double class that's

00:15:34,080 --> 00:15:39,029
instantiated on all the rest of the

00:15:36,550 --> 00:15:44,140
types all right

00:15:39,029 --> 00:15:46,240
The Giver class in general what it has

00:15:44,140 --> 00:15:48,130
to do is pick off the first type and

00:15:46,240 --> 00:15:50,080
throw it away so that it can stand she

00:15:48,130 --> 00:15:54,430
ate on the rest of the types that are

00:15:50,080 --> 00:15:56,470
left they say when you call get it's

00:15:54,430 --> 00:15:58,990
gonna just call that the next guitar

00:15:56,470 --> 00:16:01,450
down the road and pass it up dot more

00:15:58,990 --> 00:16:05,950
and then the base class all it's going

00:16:01,450 --> 00:16:09,540
to do was return the first and then

00:16:05,950 --> 00:16:11,830
finally the actual get function now that

00:16:09,540 --> 00:16:14,020
you may be wondering why I'm invoking

00:16:11,830 --> 00:16:16,839
stood tupple element rather than just

00:16:14,020 --> 00:16:18,670
using my own tuple code this is because

00:16:16,839 --> 00:16:20,440
as what I actually saw this team doing

00:16:18,670 --> 00:16:22,089
they basically got this far in their

00:16:20,440 --> 00:16:23,680
implementation and then just punted and

00:16:22,089 --> 00:16:25,770
they said you know what stood tuple

00:16:23,680 --> 00:16:28,810
element has a way to find the enth type

00:16:25,770 --> 00:16:31,240
so we're just gonna call it to figure

00:16:28,810 --> 00:16:33,600
out what type yet should be returning

00:16:31,240 --> 00:16:41,380
and we'll use that as a way to

00:16:33,600 --> 00:16:45,040
instantiate getter so what do you think

00:16:41,380 --> 00:16:47,200
this code o of n over N squared turns

00:16:45,040 --> 00:16:52,900
out even for this relatively simple code

00:16:47,200 --> 00:16:56,470
it's worse this is Oven cubed for

00:16:52,900 --> 00:16:58,060
example just the call let's say what we

00:16:56,470 --> 00:17:00,310
instantiate a topple with five elements

00:16:58,060 --> 00:17:03,520
we'll initialize them all return the

00:17:00,310 --> 00:17:08,350
first one and look at what symbols

00:17:03,520 --> 00:17:10,059
actually get generated so the first

00:17:08,350 --> 00:17:12,850
thing is every one of those get calls

00:17:10,059 --> 00:17:15,300
has to generate an actual function call

00:17:12,850 --> 00:17:17,530
to get the return type of get is

00:17:15,300 --> 00:17:20,290
generated by this call to tupple element

00:17:17,530 --> 00:17:21,760
that makes it into the mangling and then

00:17:20,290 --> 00:17:23,339
each one of those has to recursively

00:17:21,760 --> 00:17:27,100
call into a getter

00:17:23,339 --> 00:17:28,870
so every one of those lines is a

00:17:27,100 --> 00:17:31,360
different instantiation of the getter

00:17:28,870 --> 00:17:33,610
class and each one of those Gator

00:17:31,360 --> 00:17:35,290
classes has to instantiate itself with a

00:17:33,610 --> 00:17:38,170
variable number of arguments so

00:17:35,290 --> 00:17:40,660
we have event squared function generated

00:17:38,170 --> 00:17:42,520
and each one of those functions has a

00:17:40,660 --> 00:17:47,080
signature size that is OH event so

00:17:42,520 --> 00:17:52,180
that's where we get n cubed so we do to

00:17:47,080 --> 00:17:56,500
make this better so again well it's just

00:17:52,180 --> 00:17:58,420
just this one line get a four we do this

00:17:56,500 --> 00:18:02,560
gap function which instantiates these

00:17:58,420 --> 00:18:04,000
five bidders in this water just by using

00:18:02,560 --> 00:18:06,520
you know doing the most simple thing

00:18:04,000 --> 00:18:10,080
we'll use an auto return type then we

00:18:06,520 --> 00:18:10,080
don't need the type parameter for getter

00:18:10,200 --> 00:18:16,000
so the getter function becomes this and

00:18:13,870 --> 00:18:19,680
the mangling for the get function

00:18:16,000 --> 00:18:23,800
becomes that so it's a little bit better

00:18:19,680 --> 00:18:27,130
and because we're not you know

00:18:23,800 --> 00:18:30,880
instantiating well it still doesn't

00:18:27,130 --> 00:18:34,900
solve the problem so the question is can

00:18:30,880 --> 00:18:40,240
we avoid having call all of those bitter

00:18:34,900 --> 00:18:42,280
routines well remember when I said that

00:18:40,240 --> 00:18:44,470
one weird trick stood in real time I

00:18:42,280 --> 00:18:45,940
stood it what integral type of also

00:18:44,470 --> 00:18:46,740
works really well with function

00:18:45,940 --> 00:18:51,160
overloads

00:18:46,740 --> 00:18:55,810
so rather than instantiate the rest of

00:18:51,160 --> 00:18:59,770
the tupple will actually inherit from

00:18:55,810 --> 00:19:02,590
the the next double down and that allows

00:18:59,770 --> 00:19:04,590
us to directly call all the member

00:19:02,590 --> 00:19:07,300
functions all of all of these tuples

00:19:04,590 --> 00:19:10,420
then we'll insert an extra routine

00:19:07,300 --> 00:19:13,840
called yet and it will take a parameter

00:19:10,420 --> 00:19:16,060
which is an integral constant according

00:19:13,840 --> 00:19:21,970
to however many types are in the tupple

00:19:16,060 --> 00:19:25,060
at this point and then finally our get

00:19:21,970 --> 00:19:26,980
routine well it wants to call one it has

00:19:25,060 --> 00:19:28,840
to just figure out okay what's the

00:19:26,980 --> 00:19:31,750
function signature of the get that I

00:19:28,840 --> 00:19:34,270
want so what it takes basically you know

00:19:31,750 --> 00:19:35,740
number of types dead minus one then

00:19:34,270 --> 00:19:40,840
subtract some particular couple we're

00:19:35,740 --> 00:19:42,760
interested in holds get and then we

00:19:40,840 --> 00:19:44,530
allow function overrode resolution to

00:19:42,760 --> 00:19:46,149
make exactly the get function that we

00:19:44,530 --> 00:19:48,519
want

00:19:46,149 --> 00:19:50,949
in this case it doesn't quite compile

00:19:48,519 --> 00:19:53,399
you'll notice we have to use using you

00:19:50,949 --> 00:19:57,519
know we have to use the get from our

00:19:53,399 --> 00:19:58,929
superclass get function as well as the

00:19:57,519 --> 00:20:02,409
new one we're defining for each of our

00:19:58,929 --> 00:20:06,789
tuples because we want to you know use

00:20:02,409 --> 00:20:08,319
whatever one is appropriate but that

00:20:06,789 --> 00:20:10,919
also means at the base class which in

00:20:08,319 --> 00:20:14,019
this case is empty it also needs to get

00:20:10,919 --> 00:20:16,209
so we'll add one and even though it's

00:20:14,019 --> 00:20:17,859
never actually called just that the

00:20:16,209 --> 00:20:21,969
point is we have to have something for

00:20:17,859 --> 00:20:26,949
the using function to return so does

00:20:21,969 --> 00:20:28,749
this work yes now the auto get function

00:20:26,949 --> 00:20:32,219
which is still is long exactly calls

00:20:28,749 --> 00:20:35,529
directly down to the get that we want

00:20:32,219 --> 00:20:37,869
but it's still o of N squared to

00:20:35,529 --> 00:20:40,119
instantiate this there's a lot still

00:20:37,869 --> 00:20:42,329
going on and and at the base level the

00:20:40,119 --> 00:20:45,519
fundamental problem with any of these is

00:20:42,329 --> 00:20:47,199
that you're only picking up or picking

00:20:45,519 --> 00:20:50,529
off one type at a time and then

00:20:47,199 --> 00:20:54,639
instantiating for the rest so that's a

00:20:50,529 --> 00:20:56,319
fun little problem you have to solve my

00:20:54,639 --> 00:20:59,409
table ABC interpret Rimmer

00:20:56,319 --> 00:21:01,629
VC which inherits from C and in this

00:20:59,409 --> 00:21:04,809
case it also inherits from the my table

00:21:01,629 --> 00:21:06,579
with no parameters at all and then if

00:21:04,809 --> 00:21:09,429
you inherit if you construct a my topple

00:21:06,579 --> 00:21:11,439
with a comma B comma C comma D now you

00:21:09,429 --> 00:21:13,629
have to instantiate all of those none of

00:21:11,439 --> 00:21:15,009
which are an exact match for any of the

00:21:13,629 --> 00:21:18,219
tuples that you've already had to

00:21:15,009 --> 00:21:20,259
instantiate so what we really needs a

00:21:18,219 --> 00:21:27,159
way to inherit from each type

00:21:20,259 --> 00:21:31,989
individually fortunately C++ allows us

00:21:27,159 --> 00:21:33,399
to do that so we're gonna create a leaf

00:21:31,989 --> 00:21:35,379
node which is separate from our normal

00:21:33,399 --> 00:21:40,509
tupple and it's just going to hold one

00:21:35,379 --> 00:21:41,619
individual value no more and and let's

00:21:40,509 --> 00:21:43,409
step back for a moment I'm also going to

00:21:41,619 --> 00:21:45,699
show you what the constructors look like

00:21:43,409 --> 00:21:46,989
because it turns out that one of the

00:21:45,699 --> 00:21:48,729
other big problems with the previous

00:21:46,989 --> 00:21:50,559
slide and the previous way of doing

00:21:48,729 --> 00:21:53,019
things is that to construct one of these

00:21:50,559 --> 00:21:54,789
actual tuples you have to call first the

00:21:53,019 --> 00:21:58,140
constructor of the topmost couple and

00:21:54,789 --> 00:21:59,970
give it say you know 150 arguments

00:21:58,140 --> 00:22:02,220
that function constructs exactly one

00:21:59,970 --> 00:22:03,450
thing and then passes 149 arguments to

00:22:02,220 --> 00:22:07,290
the next thing down the road and so on

00:22:03,450 --> 00:22:08,580
and so forth this is just a

00:22:07,290 --> 00:22:10,890
demonstration that it becomes much

00:22:08,580 --> 00:22:12,450
cleaner because each individual leaf

00:22:10,890 --> 00:22:17,429
node only has to do with constructing

00:22:12,450 --> 00:22:19,080
itself so that's the second definition

00:22:17,429 --> 00:22:21,870
there this is my table now it hurts from

00:22:19,080 --> 00:22:23,640
my tuple of T dot dot dot so now the

00:22:21,870 --> 00:22:25,470
case of hundred-fifty types you're

00:22:23,640 --> 00:22:29,100
inheriting from 115 my table leaf

00:22:25,470 --> 00:22:32,790
objects but the constructor we can

00:22:29,100 --> 00:22:36,200
actually get it to instantiate my table

00:22:32,790 --> 00:22:42,299
leaf forwarding one argument at a time

00:22:36,200 --> 00:22:45,000
to each individual leaf object and so

00:22:42,299 --> 00:22:47,820
the actual instantiation is there on the

00:22:45,000 --> 00:22:52,169
bottom we still have the problem of how

00:22:47,820 --> 00:22:53,760
on earth does get work we need some way

00:22:52,169 --> 00:22:57,660
to figure out exactly what might uh

00:22:53,760 --> 00:22:58,770
belief to dispatch to but actually

00:22:57,660 --> 00:23:00,450
there's a bigger problem here which is

00:22:58,770 --> 00:23:02,220
if there's any one of these types that's

00:23:00,450 --> 00:23:04,710
duplicated more than once like if you

00:23:02,220 --> 00:23:07,260
want to my tuple of income int this

00:23:04,710 --> 00:23:09,360
doesn't work because it tries to derive

00:23:07,260 --> 00:23:12,380
from to my top a leaf of intz and you

00:23:09,360 --> 00:23:15,480
can't derive from the same class twice

00:23:12,380 --> 00:23:17,700
so we need some way to like add an

00:23:15,480 --> 00:23:23,490
identifier into each one of these tugga

00:23:17,700 --> 00:23:25,500
Leafs so I've added this here and so the

00:23:23,490 --> 00:23:28,410
idea is instead of just instantiating on

00:23:25,500 --> 00:23:33,419
care short an INT will also pass my

00:23:28,410 --> 00:23:35,429
identifier 0 1 & 2 and then instead of

00:23:33,419 --> 00:23:37,559
my top only 50 dot dot dot they leave my

00:23:35,429 --> 00:23:41,400
double leaf of index comma t dot dot dot

00:23:37,559 --> 00:23:44,220
and the team of us knows how to take one

00:23:41,400 --> 00:23:46,200
index and one type in every type of leaf

00:23:44,220 --> 00:23:47,840
that instantiates and then back up by

00:23:46,200 --> 00:23:50,910
the way you know you may notice that the

00:23:47,840 --> 00:23:52,470
constructor calls are gone that's just

00:23:50,910 --> 00:23:55,950
to save space and everything fits on the

00:23:52,470 --> 00:23:57,840
slide now there's one big problem with

00:23:55,950 --> 00:23:59,700
this which is that template

00:23:57,840 --> 00:24:04,770
specialization you can't have multiple

00:23:59,700 --> 00:24:06,540
very at exceptions so we need some way

00:24:04,770 --> 00:24:08,520
to solve that problem

00:24:06,540 --> 00:24:11,360
remember stood in a real constant the

00:24:08,520 --> 00:24:11,360
one weird trick well

00:24:11,430 --> 00:24:17,380
there's a similar thing stood in X

00:24:13,870 --> 00:24:19,540
sequence so wouldn't if you go to the

00:24:17,380 --> 00:24:21,250
bottom will instantiate my two pole with

00:24:19,540 --> 00:24:24,550
a single type that incorporates all of

00:24:21,250 --> 00:24:26,860
those indexes and then we'll use

00:24:24,550 --> 00:24:29,410
template specialization to be able to

00:24:26,860 --> 00:24:32,400
take those indexes and pluck them out of

00:24:29,410 --> 00:24:36,040
the index sequence that's coming in and

00:24:32,400 --> 00:24:38,080
then use the the other syntax we're

00:24:36,040 --> 00:24:38,740
using my my tubble leaf in X comma T dot

00:24:38,080 --> 00:24:47,530
dot dot

00:24:38,740 --> 00:24:50,700
starts working so this works except for

00:24:47,530 --> 00:24:50,700
getting we'll get to that in a moment

00:24:52,500 --> 00:24:58,660
yeah fret we'll get to it right now so

00:24:56,170 --> 00:25:00,490
in the leaf object will now specialize

00:24:58,660 --> 00:25:03,280
the leaf according to that index that

00:25:00,490 --> 00:25:05,770
comes in again we'll use them by using

00:25:03,280 --> 00:25:10,510
my toughie leaf of index comma t get dot

00:25:05,770 --> 00:25:13,090
dot dot and then the actual top-level

00:25:10,510 --> 00:25:17,410
tuples women when it's get gets called

00:25:13,090 --> 00:25:19,570
with an actual index parameter I will

00:25:17,410 --> 00:25:22,030
make a type stood in a real constant

00:25:19,570 --> 00:25:24,670
with that and called get on that then

00:25:22,030 --> 00:25:26,470
function overload resolution will magic

00:25:24,670 --> 00:25:28,630
would go and pick the exact get routine

00:25:26,470 --> 00:25:32,950
that we want and return the thing that

00:25:28,630 --> 00:25:35,170
we want to get out of get and this

00:25:32,950 --> 00:25:39,340
actually works I'm going to step back

00:25:35,170 --> 00:25:41,680
for a moment cuz I know a lot of you do

00:25:39,340 --> 00:25:44,950
not necessarily have access to a C++ 17

00:25:41,680 --> 00:25:48,990
compiler and this technique is

00:25:44,950 --> 00:25:48,990
applicable even in those cases so

00:26:17,130 --> 00:26:25,120
Oh actually there's a bigger pump here

00:26:21,610 --> 00:26:26,380
in one fix first my trouble before we

00:26:25,120 --> 00:26:28,690
were actually passing a student index

00:26:26,380 --> 00:26:32,350
sequence in we'd really want them to be

00:26:28,690 --> 00:26:34,029
automatically generated so we'll add an

00:26:32,350 --> 00:26:38,770
extra level of indirection we'll take my

00:26:34,029 --> 00:26:41,640
double and instantiate it based on it'll

00:26:38,770 --> 00:26:43,750
basically take the incoming types

00:26:41,640 --> 00:26:45,520
rocketed how many of them there are pass

00:26:43,750 --> 00:26:48,070
it to a function call stood make index

00:26:45,520 --> 00:26:51,669
sequence that becomes the first

00:26:48,070 --> 00:26:54,909
parameter and my total can use that of

00:26:51,669 --> 00:26:56,620
course this works except for one little

00:26:54,909 --> 00:26:59,320
detail if you happen to want at up with

00:26:56,620 --> 00:27:01,029
whose first type is itself an index

00:26:59,320 --> 00:27:04,620
sequence I don't know why you want to do

00:27:01,029 --> 00:27:10,000
that but if you did this won't work

00:27:04,620 --> 00:27:12,610
there's an easy workaround just my

00:27:10,000 --> 00:27:14,799
tablet becomes my double dimple and then

00:27:12,610 --> 00:27:16,960
my couple itself just becomes a using

00:27:14,799 --> 00:27:19,330
declaration and the using declaration is

00:27:16,960 --> 00:27:21,070
the thing that automatically builds the

00:27:19,330 --> 00:27:25,510
index sequence of the appropriate size

00:27:21,070 --> 00:27:30,090
to call in now what is where I was going

00:27:25,510 --> 00:27:35,320
word this is C++ 17 it relies on the

00:27:30,090 --> 00:27:38,470
using declaration which is a C++ 17

00:27:35,320 --> 00:27:41,919
thing unfortunately so if you didn't

00:27:38,470 --> 00:27:43,179
have that capability to use that index

00:27:41,919 --> 00:27:47,909
we're gonna have to do something

00:27:43,179 --> 00:27:47,909
different but fairly a lot different

00:27:48,090 --> 00:27:52,090
first let's do a bit of a hat let's

00:27:50,350 --> 00:27:54,610
let's take the get instead of saying you

00:27:52,090 --> 00:27:57,130
know get if one or good of two well ask

00:27:54,610 --> 00:28:00,880
our users to pass get of 1 comma short

00:27:57,130 --> 00:28:03,730
or get of 2 comma int so we're just

00:28:00,880 --> 00:28:05,460
going to add this extra parameter and

00:28:03,730 --> 00:28:08,380
then the get function will take this

00:28:05,460 --> 00:28:10,350
which is you know the the reference or

00:28:08,380 --> 00:28:13,000
the pointer to the tupple itself and

00:28:10,350 --> 00:28:17,080
we'll cast that to a might tumble leaf

00:28:13,000 --> 00:28:18,340
give an I and T type then we'll have the

00:28:17,080 --> 00:28:20,320
extra leaf note that we're interested in

00:28:18,340 --> 00:28:22,350
and then we can call the get function on

00:28:20,320 --> 00:28:22,350
that

00:28:23,320 --> 00:28:29,590
this is not terribly good nobody wants

00:28:26,020 --> 00:28:31,480
to actually have to specify the type but

00:28:29,590 --> 00:28:34,390
maybe we can deduce it so when you call

00:28:31,480 --> 00:28:36,370
a function and it's a templated function

00:28:34,390 --> 00:28:38,200
it can often deduce the type of your

00:28:36,370 --> 00:28:41,370
arguments well it's better than that

00:28:38,200 --> 00:28:43,750
actually if you call a function and you

00:28:41,370 --> 00:28:46,450
say you know not just something has a

00:28:43,750 --> 00:28:48,850
type T but say a vector of T it can

00:28:46,450 --> 00:28:53,250
deduce okay T is the type inside that

00:28:48,850 --> 00:28:56,800
vector in particular if you call it with

00:28:53,250 --> 00:28:58,330
my topple leaf of 1 comma something it

00:28:56,800 --> 00:29:01,780
can figure out what that something is

00:28:58,330 --> 00:29:05,350
and so in this case we have the function

00:29:01,780 --> 00:29:07,090
get and if the first thing we'll do in

00:29:05,350 --> 00:29:09,790
order to calculate which leaf is we'll

00:29:07,090 --> 00:29:12,910
call this function get leaf to put it on

00:29:09,790 --> 00:29:16,060
I and then get leaf we'll look at this

00:29:12,910 --> 00:29:17,680
coming in and say well okay this is in

00:29:16,060 --> 00:29:19,660
my tuple that doesn't correspond but

00:29:17,680 --> 00:29:21,370
this inherits from a lot of my trouble

00:29:19,660 --> 00:29:25,330
Leafs and one of those might uh Feliz

00:29:21,370 --> 00:29:28,360
has a particular index and then it can

00:29:25,330 --> 00:29:33,510
deduce what the T type is return the

00:29:28,360 --> 00:29:33,510
appropriate leaf back and then get works

00:29:33,690 --> 00:29:38,080
now you may be thinking at this point

00:29:35,830 --> 00:29:40,450
well we don't really need this is yet

00:29:38,080 --> 00:29:45,430
function within the Leafs anymore which

00:29:40,450 --> 00:29:47,080
is true we can just have them my topple

00:29:45,430 --> 00:29:49,060
leaves contain nothing but value and

00:29:47,080 --> 00:29:51,490
once we've called the get leaf function

00:29:49,060 --> 00:29:55,840
we can just hold that value out of it

00:29:51,490 --> 00:29:57,910
directly so this is great but this still

00:29:55,840 --> 00:30:00,400
requires super +14 let's go one more

00:29:57,910 --> 00:30:03,490
step further let's make this work on C++

00:30:00,400 --> 00:30:05,640
11 what if we can't deduce the function

00:30:03,490 --> 00:30:09,490
return type we can't use an auto return

00:30:05,640 --> 00:30:11,740
so in the case of get leaf that's pretty

00:30:09,490 --> 00:30:14,280
clear what it's going to return so that

00:30:11,740 --> 00:30:16,630
just becomes my belief of I comma T type

00:30:14,280 --> 00:30:20,680
begin is only slightly harder we can

00:30:16,630 --> 00:30:22,720
just call deckle type of yet leaf let

00:30:20,680 --> 00:30:26,130
get leaf do the expense of determination

00:30:22,720 --> 00:30:28,560
exactly what the type it needed is and

00:30:26,130 --> 00:30:31,810
then that respect this is work great

00:30:28,560 --> 00:30:34,390
technically this is still not C++ 11

00:30:31,810 --> 00:30:34,650
because stood may connect sequence ends

00:30:34,390 --> 00:30:37,830
to

00:30:34,650 --> 00:30:39,540
and excellence are not in C++ 11 but

00:30:37,830 --> 00:30:40,830
there many open-source libraries

00:30:39,540 --> 00:30:42,720
including abseil they have their own

00:30:40,830 --> 00:30:46,080
depth of definition of the making X

00:30:42,720 --> 00:31:01,620
sequence and index sequence that will

00:30:46,080 --> 00:31:03,750
work on C++ 11 so yes so the question is

00:31:01,620 --> 00:31:07,170
we're using auto here for return types

00:31:03,750 --> 00:31:11,280
how does trailing return type syntax

00:31:07,170 --> 00:31:12,810
work with this and basically the benefit

00:31:11,280 --> 00:31:15,750
of using Auto doesn't apply to a

00:31:12,810 --> 00:31:17,160
trailing return type because the whole

00:31:15,750 --> 00:31:19,080
reason for removing the return type is

00:31:17,160 --> 00:31:22,880
so you can do some calculations based on

00:31:19,080 --> 00:31:26,970
the you know based on named parameters

00:31:22,880 --> 00:31:28,680
so it's basically that's a big thing

00:31:26,970 --> 00:31:30,300
whatever the church from the return type

00:31:28,680 --> 00:31:35,430
it gets mangled into the function

00:31:30,300 --> 00:31:41,100
signature so it's moving to case the

00:31:35,430 --> 00:31:42,600
Ember - this is lip C++ looking at all

00:31:41,100 --> 00:31:47,100
the debug symbols which were so

00:31:42,600 --> 00:31:50,790
voluminous that somebody wouldn't build

00:31:47,100 --> 00:31:55,470
anymore and this is actually one of the

00:31:50,790 --> 00:31:57,240
causes stood is saying and you think

00:31:55,470 --> 00:31:58,650
like how can something this incredibly

00:31:57,240 --> 00:32:01,470
simple cause any kind of a problem

00:31:58,650 --> 00:32:06,210
whatsoever the answer is when I looked

00:32:01,470 --> 00:32:07,920
at the debug symbols I saw a bunch of

00:32:06,210 --> 00:32:09,510
you know this is just you know what you

00:32:07,920 --> 00:32:11,970
can do it with care into float and

00:32:09,510 --> 00:32:13,560
double you can imagine a kid in a

00:32:11,970 --> 00:32:15,600
program that has many more types in this

00:32:13,560 --> 00:32:19,650
this is much much much longer like what

00:32:15,600 --> 00:32:24,570
the hell is going on why is this and the

00:32:19,650 --> 00:32:26,990
answer is that actually so the answer is

00:32:24,570 --> 00:32:30,450
that this ends up instantiating

00:32:26,990 --> 00:32:32,250
instantiating an is same class for every

00:32:30,450 --> 00:32:34,200
possible combination that you actually

00:32:32,250 --> 00:32:36,510
pass to it the compiler actually

00:32:34,200 --> 00:32:38,010
constructs a memorized you know class it

00:32:36,510 --> 00:32:39,510
actually ends up saying this is what a

00:32:38,010 --> 00:32:42,000
constructor might look like this is what

00:32:39,510 --> 00:32:44,130
the destructor does whether or not it

00:32:42,000 --> 00:32:45,570
has an implicit copy constructor whether

00:32:44,130 --> 00:32:47,419
or not it can do Louvre construction

00:32:45,570 --> 00:32:49,129
it's really surprising all the work that

00:32:47,419 --> 00:32:55,959
the parlor does on a completely empty

00:32:49,129 --> 00:32:58,549
class so one way to make this better

00:32:55,959 --> 00:32:59,869
let's have a little wrapper class and

00:32:58,549 --> 00:33:00,729
the wrapper class will have two

00:32:59,869 --> 00:33:03,499
functions in it

00:33:00,729 --> 00:33:06,679
one function will take the exact same

00:33:03,499 --> 00:33:10,129
wrapper class as an argument the other

00:33:06,679 --> 00:33:12,529
function will just take a void star so

00:33:10,129 --> 00:33:14,179
in previous case where you would have

00:33:12,529 --> 00:33:17,389
called stood a same type one tag to

00:33:14,179 --> 00:33:19,579
clong clong value and the new code you

00:33:17,389 --> 00:33:22,700
would write wrapper of type one clone

00:33:19,579 --> 00:33:24,700
colon is same will take null pointer

00:33:22,700 --> 00:33:27,169
convert it to a wrapper of type 2 and

00:33:24,700 --> 00:33:30,739
that will call either return to or

00:33:27,169 --> 00:33:34,099
return false function and this is

00:33:30,739 --> 00:33:36,019
tedious sure but it only ever

00:33:34,099 --> 00:33:41,929
instantiates two functions per type and

00:33:36,019 --> 00:33:45,139
it only instantiate its one type per the

00:33:41,929 --> 00:33:47,239
one wrapper type protect coming in so

00:33:45,139 --> 00:33:50,059
it's still you know for a number of

00:33:47,239 --> 00:33:51,619
classes and types if you work under down

00:33:50,059 --> 00:33:54,469
this road we can actually do a little

00:33:51,619 --> 00:33:57,200
bit more of a win we can make a wrapper

00:33:54,469 --> 00:33:59,059
base class that does the same thing

00:33:57,200 --> 00:33:59,989
because it's same as always exactly the

00:33:59,059 --> 00:34:03,379
same for each one of these functions

00:33:59,989 --> 00:34:05,749
each one these classes and then the new

00:34:03,379 --> 00:34:09,679
function is just is same inside of the

00:34:05,749 --> 00:34:15,009
wrapper we can also write a little using

00:34:09,679 --> 00:34:17,149
clause that says is same is going to be

00:34:15,009 --> 00:34:19,759
again when one little tricks good

00:34:17,149 --> 00:34:22,839
interval constant a bull comma and then

00:34:19,759 --> 00:34:25,009
the fancy expression with a wrapper

00:34:22,839 --> 00:34:26,779
stood a door constant that will come a

00:34:25,009 --> 00:34:28,879
true or bull comma false happens to be

00:34:26,779 --> 00:34:31,569
exactly the type that the actual stud is

00:34:28,879 --> 00:34:33,859
same function returns so this is a

00:34:31,569 --> 00:34:36,220
perfect match and the code comes out

00:34:33,859 --> 00:34:39,559
exactly the same either way

00:34:36,220 --> 00:34:41,059
but now instantiates far fewer there's

00:34:39,559 --> 00:34:43,879
you know one wrapper function for any

00:34:41,059 --> 00:34:50,799
type and one function inside of that

00:34:43,879 --> 00:34:54,259
wrapper class for each of those types so

00:34:50,799 --> 00:34:56,269
more clearly a win an even better

00:34:54,259 --> 00:34:58,160
example it turns out it stood

00:34:56,269 --> 00:35:01,640
conditional

00:34:58,160 --> 00:35:03,769
this is also surprisingly simple like

00:35:01,640 --> 00:35:06,499
how would this be a problem well turns

00:35:03,769 --> 00:35:08,119
out that even though our application

00:35:06,499 --> 00:35:10,009
code didn't stop call stood conditional

00:35:08,119 --> 00:35:12,319
a whole lot turns out in the standard

00:35:10,009 --> 00:35:14,479
library within itself calls took

00:35:12,319 --> 00:35:16,039
conditional a huge number of times like

00:35:14,479 --> 00:35:18,710
that the most common example beings

00:35:16,039 --> 00:35:19,940
inside of Sydney pointer it has to

00:35:18,710 --> 00:35:22,430
figure out whether or not it actually

00:35:19,940 --> 00:35:25,069
needs space for an alligator and use

00:35:22,430 --> 00:35:27,319
just a conditional a lot to do that and

00:35:25,069 --> 00:35:30,009
so look at the debug symbols and there's

00:35:27,319 --> 00:35:34,359
the conditional of true care boy - all

00:35:30,009 --> 00:35:41,450
it's just filled and filled filled so

00:35:34,359 --> 00:35:43,910
how can we fix this turns out rather

00:35:41,450 --> 00:35:46,339
than tempting conditional on all three

00:35:43,910 --> 00:35:49,099
at the same time we could template

00:35:46,339 --> 00:35:52,249
conditional on just one and then inside

00:35:49,099 --> 00:35:53,329
of that struct we use using declaration

00:35:52,249 --> 00:35:56,960
to pick out which of the other two

00:35:53,329 --> 00:35:59,809
classes we actually want in fact there

00:35:56,960 --> 00:36:01,700
was actually a similar fix to this as a

00:35:59,809 --> 00:36:06,099
result of our investigations was checked

00:36:01,700 --> 00:36:06,099
into Lipsy plus about three months ago

00:36:06,219 --> 00:36:10,670
now the great thing about this is that

00:36:08,269 --> 00:36:13,009
there's only two conditional classes

00:36:10,670 --> 00:36:14,749
that ever get generated by this honestly

00:36:13,009 --> 00:36:16,609
conditional of true conditional false

00:36:14,749 --> 00:36:18,469
there is no overhead of the using

00:36:16,609 --> 00:36:26,769
declaration at all it just completely

00:36:18,469 --> 00:36:32,109
disappears there's no type involved so

00:36:26,769 --> 00:36:32,109
another interesting one stood add Const

00:36:34,150 --> 00:36:41,900
will declare this it does the same thing

00:36:37,279 --> 00:36:43,700
that all the other type classes do where

00:36:41,900 --> 00:36:48,410
first we'd find that the class and then

00:36:43,700 --> 00:36:51,890
add cons t uses that class to figure out

00:36:48,410 --> 00:36:54,019
what type it's gonna return this wasn't

00:36:51,890 --> 00:36:59,390
really a big burden advanced isn't all

00:36:54,019 --> 00:37:01,160
but a whole lot however it can still be

00:36:59,390 --> 00:37:04,190
improved because rather than having

00:37:01,160 --> 00:37:08,029
using egg cons t depend on instantiating

00:37:04,190 --> 00:37:10,609
the add construct once reach type could

00:37:08,029 --> 00:37:12,400
just make at kant's t be equal to cos t

00:37:10,609 --> 00:37:15,740
right

00:37:12,400 --> 00:37:19,570
so I tried this out picked a reasonable

00:37:15,740 --> 00:37:19,570
rule by turning tried to build it and

00:37:20,230 --> 00:37:23,950
some of you have seen this guy before

00:37:22,100 --> 00:37:26,120
this is Hiram right

00:37:23,950 --> 00:37:27,650
he made an offhand comment which has

00:37:26,120 --> 00:37:30,200
become Hiram's law which says with a

00:37:27,650 --> 00:37:32,270
sufficient number of users of an API it

00:37:30,200 --> 00:37:35,420
does not matter what you promise in the

00:37:32,270 --> 00:37:37,670
contract all observable behaviors of

00:37:35,420 --> 00:37:41,870
your system will be depended on by

00:37:37,670 --> 00:37:43,910
someone so what's going on here well if

00:37:41,870 --> 00:37:46,250
let's take a really simple case right

00:37:43,910 --> 00:37:48,470
we'll have a new definition here we'll

00:37:46,250 --> 00:37:50,840
declare a new routine called mop which

00:37:48,470 --> 00:37:53,150
for whatever reason takes the template

00:37:50,840 --> 00:37:56,420
parameters passed in adds conce to it

00:37:53,150 --> 00:37:58,100
and does whatever it does and we'll call

00:37:56,420 --> 00:38:02,510
it in this case we'll just call knob of

00:37:58,100 --> 00:38:04,990
I now because the using declaration of

00:38:02,510 --> 00:38:08,090
AB consti in this case is just Kant's T

00:38:04,990 --> 00:38:10,820
the compiler sees this call to not being

00:38:08,090 --> 00:38:14,660
passed an integer and says well okay I

00:38:10,820 --> 00:38:19,340
can figure out that this T has to be int

00:38:14,660 --> 00:38:21,680
in that case no problem well turns out

00:38:19,340 --> 00:38:24,770
in the current actual definition where

00:38:21,680 --> 00:38:26,750
AB Const he has to instantiate a class

00:38:24,770 --> 00:38:30,890
and then pick a type from inside of that

00:38:26,750 --> 00:38:33,530
class it can't deduce what the type is

00:38:30,890 --> 00:38:36,680
so with the original definition of add

00:38:33,530 --> 00:38:39,170
Const this wouldn't compile correctly

00:38:36,680 --> 00:38:41,240
and it wouldn't so much throw an error

00:38:39,170 --> 00:38:43,130
due to this definition table it's just

00:38:41,240 --> 00:38:44,780
that knob wouldn't appear in the

00:38:43,130 --> 00:38:48,560
overload set of functions that you would

00:38:44,780 --> 00:38:49,970
possibly be referring to now I think

00:38:48,560 --> 00:38:51,110
some of you are hearing that and

00:38:49,970 --> 00:38:53,470
thinking well that's kind of sad that

00:38:51,110 --> 00:38:56,360
the compiler can't figure it out and

00:38:53,470 --> 00:38:58,370
then a few others of you are thinking oh

00:38:56,360 --> 00:39:00,950
wait a minute so I can use this to

00:38:58,370 --> 00:39:07,250
remove my function from the overload set

00:39:00,950 --> 00:39:09,550
I could use that which is why I'm

00:39:07,250 --> 00:39:09,550
getting

00:39:11,850 --> 00:39:19,290
so you can't can't do that a little more

00:39:16,770 --> 00:39:21,860
time just one more an interesting weird

00:39:19,290 --> 00:39:25,860
trick that helps you reduce the event

00:39:21,860 --> 00:39:30,930
properties in sepals 417 we have these

00:39:25,860 --> 00:39:32,280
fold expressions and so very often when

00:39:30,930 --> 00:39:33,990
you're dealing with a long list of types

00:39:32,280 --> 00:39:38,160
you want to apply a function to each

00:39:33,990 --> 00:39:40,020
individual type in this case we have a

00:39:38,160 --> 00:39:42,090
simple constant expert function which

00:39:40,020 --> 00:39:46,650
just tells you whether or not any one of

00:39:42,090 --> 00:39:48,690
those types is equal to a void type that

00:39:46,650 --> 00:39:52,620
worsen C plus 417 but now how would you

00:39:48,690 --> 00:39:54,570
get that to work in C++ 11 well again it

00:39:52,620 --> 00:39:55,490
stood in a real constant and function

00:39:54,570 --> 00:39:58,830
overloads

00:39:55,490 --> 00:40:01,230
they play really well together so what

00:39:58,830 --> 00:40:04,410
we can do is we can find two functions

00:40:01,230 --> 00:40:08,820
or the first one takes an initializer

00:40:04,410 --> 00:40:10,980
list of interval constants Wolfe false

00:40:08,820 --> 00:40:12,360
okay so if you keep pass it an

00:40:10,980 --> 00:40:15,120
initializer list where every single

00:40:12,360 --> 00:40:16,860
entry in it is of type stood in

00:40:15,120 --> 00:40:20,130
reponsible of false then it will return

00:40:16,860 --> 00:40:23,460
false will have another load another

00:40:20,130 --> 00:40:25,050
overload of the function or and in this

00:40:23,460 --> 00:40:28,170
overload it will just take a stood in

00:40:25,050 --> 00:40:30,480
analyzer list of bool this works because

00:40:28,170 --> 00:40:33,240
the interval constant of bull comma true

00:40:30,480 --> 00:40:35,790
or false freely converts to the

00:40:33,240 --> 00:40:39,330
underlying bool so when you call this

00:40:35,790 --> 00:40:41,340
function you'll hit this first one only

00:40:39,330 --> 00:40:43,920
if everything you passed is false and

00:40:41,340 --> 00:40:47,400
you'll get the second one if any one of

00:40:43,920 --> 00:40:49,410
the elements is true and the great thing

00:40:47,400 --> 00:40:51,860
is this only ever generates two

00:40:49,410 --> 00:40:51,860
functions

00:40:54,600 --> 00:41:00,060
so it's a nice way to solve that problem

00:40:57,360 --> 00:41:06,330
bringing over N squared thing back down

00:41:00,060 --> 00:41:07,590
to of one and just for reference this is

00:41:06,330 --> 00:41:10,230
how you would actually end up calling it

00:41:07,590 --> 00:41:12,330
in that case we have a function where

00:41:10,230 --> 00:41:16,410
template of number of parameters and you

00:41:12,330 --> 00:41:20,040
just call spit afford to the void call

00:41:16,410 --> 00:41:22,950
type it's Dan she ate each one call it

00:41:20,040 --> 00:41:26,720
off to war and it comes back with your

00:41:22,950 --> 00:41:32,940
two revolts director correctly

00:41:26,720 --> 00:41:37,950
finally compilers vary and compilers

00:41:32,940 --> 00:41:39,510
evolve a lot of this stuff I think in

00:41:37,950 --> 00:41:41,850
two or three years time is gonna be

00:41:39,510 --> 00:41:46,250
somewhat obsolete it turns out that

00:41:41,850 --> 00:41:49,260
compilers don't compile the C++ language

00:41:46,250 --> 00:41:51,210
they compile the general C++

00:41:49,260 --> 00:41:53,880
specification which also includes the

00:41:51,210 --> 00:41:58,290
libraries so just like when you write

00:41:53,880 --> 00:41:59,970
mem copy the compiler can actually avoid

00:41:58,290 --> 00:42:01,770
making the function call to mem copy

00:41:59,970 --> 00:42:04,170
because it knows what mem copy is

00:42:01,770 --> 00:42:07,740
defined to do so if you copy mem copy of

00:42:04,170 --> 00:42:10,590
four bytes it can decide to just pick up

00:42:07,740 --> 00:42:12,800
four bytes and you're reading to a

00:42:10,590 --> 00:42:16,170
register and store it

00:42:12,800 --> 00:42:17,850
likewise stood the same doesn't have to

00:42:16,170 --> 00:42:19,290
do all the bad things that I'm talking

00:42:17,850 --> 00:42:20,760
about here they could change the

00:42:19,290 --> 00:42:22,020
compiler and just say we know what stood

00:42:20,760 --> 00:42:25,410
the same does we're not going to bother

00:42:22,020 --> 00:42:28,170
to instantiate as long as it doesn't

00:42:25,410 --> 00:42:30,330
have that weird Hiram's law issue of

00:42:28,170 --> 00:42:35,370
blocking overload resolution in certain

00:42:30,330 --> 00:42:37,320
cases having said that that only affects

00:42:35,370 --> 00:42:39,630
the standard library all of your code

00:42:37,320 --> 00:42:41,990
can still benefit from all of these

00:42:39,630 --> 00:42:41,990
techniques

00:42:43,200 --> 00:42:56,819
any questions and thank you for specking

00:42:54,540 --> 00:42:57,869
it's stepping up to the mic I don't

00:42:56,819 --> 00:42:59,400
actually have a question this is more of

00:42:57,869 --> 00:43:00,750
a comment it was actually really

00:42:59,400 --> 00:43:03,180
enlightening to see the example with the

00:43:00,750 --> 00:43:05,220
auto return type because like I used I

00:43:03,180 --> 00:43:07,020
mostly work on Windows and on Windows in

00:43:05,220 --> 00:43:08,880
the MS VCA VI the return type is not

00:43:07,020 --> 00:43:11,130
mangled into the function signature and

00:43:08,880 --> 00:43:12,390
so I suspect although I didn't even know

00:43:11,130 --> 00:43:13,890
about this trick in the Itanium maybe I

00:43:12,390 --> 00:43:16,619
but I suspect that this won't be a

00:43:13,890 --> 00:43:17,339
source of optimization and a mess BCA VI

00:43:16,619 --> 00:43:20,910
but I thought that was an interesting

00:43:17,339 --> 00:43:22,980
difference and that means that there's

00:43:20,910 --> 00:43:25,470
probably a very subtle bug that MS PC

00:43:22,980 --> 00:43:26,940
has I mean functions are overloaded on

00:43:25,470 --> 00:43:30,869
return type so but there are different

00:43:26,940 --> 00:43:31,799
semantics anyway so like like I mean we

00:43:30,869 --> 00:43:33,420
can take it offline if you want but

00:43:31,799 --> 00:43:34,980
there's there's issues where like when

00:43:33,420 --> 00:43:36,990
you have a dependent template type

00:43:34,980 --> 00:43:38,460
parameter and a function like MS PC will

00:43:36,990 --> 00:43:40,890
think the types are identical even

00:43:38,460 --> 00:43:42,869
though a conforming compiler will not I

00:43:40,890 --> 00:43:50,010
mean it's like unfixable because of the

00:43:42,869 --> 00:43:53,780
API but when you try to implement your

00:43:50,010 --> 00:43:56,940
own traits so like the same or like just

00:43:53,780 --> 00:43:59,450
unary traits you have experience in how

00:43:56,940 --> 00:44:01,380
the compile time performance behaves of

00:43:59,450 --> 00:44:03,000
implementing it like this time the

00:44:01,380 --> 00:44:11,040
library does often like what this chart

00:44:03,000 --> 00:44:14,270
or the deco tie this V&A way so there's

00:44:11,040 --> 00:44:16,440
there's two avenues of optimization that

00:44:14,270 --> 00:44:17,819
address two different problems that

00:44:16,440 --> 00:44:19,890
people have one is that the power is

00:44:17,819 --> 00:44:21,770
consuming up too much memory the other

00:44:19,890 --> 00:44:24,990
is that the compiler is taking too long

00:44:21,770 --> 00:44:28,200
I know that these techniques definitely

00:44:24,990 --> 00:44:30,329
help with memory consumption they tend

00:44:28,200 --> 00:44:31,530
to also help in time just because if

00:44:30,329 --> 00:44:34,380
you're outfitting a lot of memory

00:44:31,530 --> 00:44:35,970
allocation isn't free depending on

00:44:34,380 --> 00:44:38,369
operating on what your operating system

00:44:35,970 --> 00:44:40,799
is and how much memory you have it

00:44:38,369 --> 00:44:48,270
depends on how free it is or how not

00:44:40,799 --> 00:44:51,690
free this function sensation don't have

00:44:48,270 --> 00:44:53,770
to be kept inside the compiler state

00:44:51,690 --> 00:44:56,780
what during copulation

00:44:53,770 --> 00:44:59,420
in the Atty compilation unit so you

00:44:56,780 --> 00:45:03,950
could like forget about a function that

00:44:59,420 --> 00:45:05,060
was declared earlier but it's not so

00:45:03,950 --> 00:45:07,070
much that it's gonna forget about the

00:45:05,060 --> 00:45:10,340
function what it forgets about is that

00:45:07,070 --> 00:45:13,790
if this function is passed to that it

00:45:10,340 --> 00:45:17,590
returns the value two and if it's you

00:45:13,790 --> 00:45:17,590
know past three its return value five

00:45:22,660 --> 00:45:27,710
oftentimes when I'm implementing

00:45:25,360 --> 00:45:29,810
something that's actually lifting a

00:45:27,710 --> 00:45:31,640
value into the type system I'm

00:45:29,810 --> 00:45:32,870
implementing something like types traits

00:45:31,640 --> 00:45:36,430
to use enable it

00:45:32,870 --> 00:45:40,040
have you found variable templates to be

00:45:36,430 --> 00:45:41,960
me to immediately impact compiled as

00:45:40,040 --> 00:45:44,090
opposed to building an entire type I

00:45:41,960 --> 00:45:47,480
have not but in Google's case we

00:45:44,090 --> 00:45:50,450
actually turned on C++ 17 fully on there

00:45:47,480 --> 00:45:51,710
last month or two so it hasn't had a

00:45:50,450 --> 00:45:56,650
chance yet to be an issue

00:45:51,710 --> 00:45:56,650
ask me again in either thank you

00:45:57,830 --> 00:46:02,390
I was just curious when you showed the

00:45:59,210 --> 00:46:05,120
example of the enable if versus Auto if

00:46:02,390 --> 00:46:08,240
you know anything about performance

00:46:05,120 --> 00:46:13,910
differences of speen idea like an

00:46:08,240 --> 00:46:15,290
unnamed type name parameter we have the

00:46:13,910 --> 00:46:17,330
substitution failures in the parameter

00:46:15,290 --> 00:46:21,290
pack not in any of the return or

00:46:17,330 --> 00:46:23,330
function arguments so unfortunately I

00:46:21,290 --> 00:46:26,750
didn't have a time to if I didn't at the

00:46:23,330 --> 00:46:28,010
slides but do you see the if console

00:46:26,750 --> 00:46:32,120
expert trick that I did for Fibonacci

00:46:28,010 --> 00:46:35,090
yeah in many cases you would want to do

00:46:32,120 --> 00:46:37,520
something similar for its context bird

00:46:35,090 --> 00:46:40,340
in actual template instantiations and

00:46:37,520 --> 00:46:42,830
when you do that using if Const expert

00:46:40,340 --> 00:46:44,570
is much much cleaner much more easier to

00:46:42,830 --> 00:46:47,860
read and also much easier on the

00:46:44,570 --> 00:46:50,600
compiler then the various did enable if

00:46:47,860 --> 00:46:52,810
variations that you might use well

00:46:50,600 --> 00:46:52,810
thanks

00:46:57,930 --> 00:47:01,319
thank you all for coming

00:47:02,770 --> 00:47:06,159

YouTube URL: https://www.youtube.com/watch?v=TyiiNVA1syk


