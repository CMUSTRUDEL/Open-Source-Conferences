Title: CppCon 2019:Ben Saks “Back to Basics: Understanding Value Categories”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
You may be familiar with the terms lvalue, rvalue, and xvalue, if only because they occasionally appear in compiler error messages. However, if you have only a vague understanding of what they mean, you're not alone. Lvalues, rvalues, and xvalues aren't actually language features, but rather semantic properties of expressions and sub-expressions. Understanding these properties provides valuable insights into the behavior of built-in operators, the code generated to execute those operators, and the meaning of some otherwise cryptic compiler error messages. Understanding these properties is also essential for working effectively with lvalue and rvalue reference types, as well as overloaded operators. 

This session explains why the language distinguishes among lvalues, rvalues, and xvalues. It describes how the semantic properties of lvalues, rvalues, and xvalues are different and how those properties are reflected in the behavior of lvalue and rvalue references.
— 
Ben Saks
Chief Engineer, Saks & Associates
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,099 --> 00:00:13,609
hey everyone my name's Ben Sachs

00:00:12,139 --> 00:00:15,949
for those of you who don't know me my

00:00:13,609 --> 00:00:18,770
company Sachs & Associates offers

00:00:15,949 --> 00:00:21,140
training in C and C++ for companies all

00:00:18,770 --> 00:00:23,720
over the world and I'm here to talk a

00:00:21,140 --> 00:00:26,779
little bit about value categories in C

00:00:23,720 --> 00:00:30,619
and C++ and the first thing I want to

00:00:26,779 --> 00:00:33,350
mention is that value categories aren't

00:00:30,619 --> 00:00:35,840
language features not in the sense that

00:00:33,350 --> 00:00:40,160
the ability to do things like overload

00:00:35,840 --> 00:00:42,500
operators is a language feature the

00:00:40,160 --> 00:00:45,110
value categories are part of how the

00:00:42,500 --> 00:00:48,670
compiler understands and interprets

00:00:45,110 --> 00:00:50,600
expressions in the language so

00:00:48,670 --> 00:00:54,350
understanding what these value

00:00:50,600 --> 00:00:56,600
categories are and what they mean will

00:00:54,350 --> 00:00:59,450
help you understand how the compiler

00:00:56,600 --> 00:01:01,760
thinks which is helpful mostly both

00:00:59,450 --> 00:01:03,410
because it helps you decipher some error

00:01:01,760 --> 00:01:06,079
messages that might otherwise be

00:01:03,410 --> 00:01:09,439
confusing and it also provides some

00:01:06,079 --> 00:01:11,840
insight into why certain features of the

00:01:09,439 --> 00:01:16,009
language like operators and references

00:01:11,840 --> 00:01:18,679
work the way that they do now originally

00:01:16,009 --> 00:01:21,289
there were only two value categories l

00:01:18,679 --> 00:01:23,779
values and our values back when they

00:01:21,289 --> 00:01:25,490
were first introduced in C they were

00:01:23,779 --> 00:01:31,279
relatively straightforward and simple

00:01:25,490 --> 00:01:35,299
concepts then c++ came along it added

00:01:31,279 --> 00:01:38,509
classes const references and those

00:01:35,299 --> 00:01:40,639
concepts needed to evolve to handle the

00:01:38,509 --> 00:01:43,999
new possibilities that these new

00:01:40,639 --> 00:01:46,579
language features offered and then we

00:01:43,999 --> 00:01:49,099
got along to modern C++ and r-value

00:01:46,579 --> 00:01:51,679
references were introduced and this

00:01:49,099 --> 00:01:53,630
further complicated the situation the

00:01:51,679 --> 00:01:56,299
concepts had to evolve yet again and

00:01:53,630 --> 00:01:59,840
they also had to introduce new types of

00:01:56,299 --> 00:02:02,990
value categories to describe exactly

00:01:59,840 --> 00:02:06,590
what the language was doing in various

00:02:02,990 --> 00:02:09,289
places so in this talk I'm going to kind

00:02:06,590 --> 00:02:12,440
of walk you through this evolutionary

00:02:09,289 --> 00:02:15,290
process we'll start from the early view

00:02:12,440 --> 00:02:19,330
of where these terms came from and I'll

00:02:15,290 --> 00:02:22,069
gradually refine the picture as we go so

00:02:19,330 --> 00:02:24,200
there's a lot of material to cover

00:02:22,069 --> 00:02:27,080
I'm going to try and speak relatively

00:02:24,200 --> 00:02:29,120
quickly feel free to ask questions as I

00:02:27,080 --> 00:02:32,269
go so you may want to come up to the mic

00:02:29,120 --> 00:02:33,349
here too if you decide to do that but

00:02:32,269 --> 00:02:36,830
you should be prepared for the

00:02:33,349 --> 00:02:41,629
possibility that I'll say that's coming

00:02:36,830 --> 00:02:44,480
up in a future slide ok so the terms l

00:02:41,629 --> 00:02:49,329
value and our value come from assignment

00:02:44,480 --> 00:02:52,430
expressions the idea is the L means left

00:02:49,329 --> 00:02:53,900
B thing on the left hand side of an

00:02:52,430 --> 00:02:57,290
assignment statement the thing being

00:02:53,900 --> 00:02:59,959
assigned to has to be an L value so

00:02:57,290 --> 00:03:03,200
what's an L value it's any expression

00:02:59,959 --> 00:03:06,200
that refers to an object okay that begs

00:03:03,200 --> 00:03:09,019
the question what's an object an object

00:03:06,200 --> 00:03:11,420
is a region of storage it's something

00:03:09,019 --> 00:03:14,840
that has a defined location in memory

00:03:11,420 --> 00:03:16,849
where it lives so let's take a look at a

00:03:14,840 --> 00:03:20,299
simple assignment statement here we have

00:03:16,849 --> 00:03:25,160
an integer n we're assigning one to that

00:03:20,299 --> 00:03:27,349
n so here there are several expressions

00:03:25,160 --> 00:03:30,019
in that assignment statement and as an

00:03:27,349 --> 00:03:32,959
expression one is an expression and the

00:03:30,019 --> 00:03:36,709
whole thing n equals one is also an

00:03:32,959 --> 00:03:39,109
expression so in here n is the sub

00:03:36,709 --> 00:03:42,139
expression that refers to an integer

00:03:39,109 --> 00:03:43,669
object it's an L value and that makes it

00:03:42,139 --> 00:03:47,900
the sort of thing that can be assigned

00:03:43,669 --> 00:03:50,389
to one is also a sub expression but it

00:03:47,900 --> 00:03:54,620
is not an object it's just of an R value

00:03:50,389 --> 00:03:57,799
an R value is something that isn't an L

00:03:54,620 --> 00:04:02,419
value so anything that isn't an L value

00:03:57,799 --> 00:04:04,250
is an R value now I showed you the

00:04:02,419 --> 00:04:06,769
example I just showed you used

00:04:04,250 --> 00:04:08,660
relatively simple expressions but those

00:04:06,769 --> 00:04:11,480
expressions can also be more complicated

00:04:08,660 --> 00:04:13,669
as in this example so here the left hand

00:04:11,480 --> 00:04:16,639
side is made up of several tokens it's X

00:04:13,669 --> 00:04:20,199
sub I plus one the right-hand side is

00:04:16,639 --> 00:04:23,180
the absolute value of P arrow value

00:04:20,199 --> 00:04:26,300
both of those are sub expressions and

00:04:23,180 --> 00:04:28,760
the same rules apply the thing on the

00:04:26,300 --> 00:04:31,190
left hand side has to be an object that

00:04:28,760 --> 00:04:36,370
can be assigned to in this case it is

00:04:31,190 --> 00:04:39,620
it's the I plus 1 member of the array X

00:04:36,370 --> 00:04:42,110
so it has to refer to an object the

00:04:39,620 --> 00:04:44,960
right-hand side can be either an L value

00:04:42,110 --> 00:04:48,260
or an R value we can assign from either

00:04:44,960 --> 00:04:53,450
L values or our values so any expression

00:04:48,260 --> 00:04:55,370
will work on the right-hand side so why

00:04:53,450 --> 00:04:58,730
does this distinction exist why did the

00:04:55,370 --> 00:05:03,320
language designers introduce these two

00:04:58,730 --> 00:05:08,840
categories in the first place it lets

00:05:03,320 --> 00:05:11,270
the compiler be generate code more

00:05:08,840 --> 00:05:15,530
efficiently than it would be forced to

00:05:11,270 --> 00:05:17,690
do if our values were required to occupy

00:05:15,530 --> 00:05:21,200
storage in memory so may give you an

00:05:17,690 --> 00:05:24,740
example going back to the N equals one

00:05:21,200 --> 00:05:27,020
assignment statement here so it's

00:05:24,740 --> 00:05:30,110
possible that the compiler will choose

00:05:27,020 --> 00:05:32,060
to place that value one in data storage

00:05:30,110 --> 00:05:34,280
even though it doesn't have to put it

00:05:32,060 --> 00:05:39,190
there it may choose to put it there in

00:05:34,280 --> 00:05:42,370
as if it were an L value so in this case

00:05:39,190 --> 00:05:46,010
in the assembly language we would have a

00:05:42,370 --> 00:05:49,610
portion of the of the executable that is

00:05:46,010 --> 00:05:52,070
reserved for that value 1 in data space

00:05:49,610 --> 00:05:53,900
and then the assignment statement might

00:05:52,070 --> 00:05:56,780
look something like this where we move

00:05:53,900 --> 00:06:01,430
the value from 1 into the location

00:05:56,780 --> 00:06:03,110
designated by n on the other hand the

00:06:01,430 --> 00:06:04,760
compiler might choose to do things like

00:06:03,110 --> 00:06:07,370
this there are many architectures that

00:06:04,760 --> 00:06:11,900
offer what are called immediate operands

00:06:07,370 --> 00:06:15,440
where the value to be operated on

00:06:11,900 --> 00:06:17,450
doesn't have to be a separate data value

00:06:15,440 --> 00:06:20,150
it can actually be built into the

00:06:17,450 --> 00:06:23,810
instruction like this so in this case

00:06:20,150 --> 00:06:27,680
the value 1 appears directly in the move

00:06:23,810 --> 00:06:29,720
expression so there's no data storage

00:06:27,680 --> 00:06:32,330
associated with that one it doesn't

00:06:29,720 --> 00:06:34,940
appear anywhere in data space it's a

00:06:32,330 --> 00:06:38,210
part of the code space built into one of

00:06:34,940 --> 00:06:41,720
the instructions if our values had to

00:06:38,210 --> 00:06:45,800
occupy memory the compiler wouldn't be

00:06:41,720 --> 00:06:47,690
able to do this sort of thing so suppose

00:06:45,800 --> 00:06:49,249
that I wrote the assignment statement

00:06:47,690 --> 00:06:52,939
the other way around I said

00:06:49,249 --> 00:06:56,539
one equals n now we know we can't do

00:06:52,939 --> 00:07:00,379
this but why can't we do this it's not

00:06:56,539 --> 00:07:03,679
because of pipes and is it an object of

00:07:00,379 --> 00:07:06,619
type int one is a literal which also has

00:07:03,679 --> 00:07:09,019
type in it they are the same pipe but

00:07:06,619 --> 00:07:11,509
it's not valid because the thing on the

00:07:09,019 --> 00:07:13,729
left hand side has to be an L value and

00:07:11,509 --> 00:07:17,209
one isn't an L value it doesn't

00:07:13,729 --> 00:07:22,009
necessarily live at any defined place in

00:07:17,209 --> 00:07:24,349
memory so everything is either an every

00:07:22,009 --> 00:07:26,869
expression is either an L value or an R

00:07:24,349 --> 00:07:32,019
value L values refer to objects that

00:07:26,869 --> 00:07:35,629
live in memory our values don't kind of

00:07:32,019 --> 00:07:37,429
this is true for built in objects of

00:07:35,629 --> 00:07:39,379
built-in types the picture is a little

00:07:37,429 --> 00:07:42,019
more complicated when we're talking

00:07:39,379 --> 00:07:44,989
about class types I'll explain that a

00:07:42,019 --> 00:07:46,339
little bit later on so what sorts of

00:07:44,989 --> 00:07:48,439
things are our values

00:07:46,339 --> 00:07:52,309
well literals as I've shown you so

00:07:48,439 --> 00:07:54,949
values like three 3.14159 character

00:07:52,309 --> 00:07:57,979
literals like a these things don't have

00:07:54,949 --> 00:08:01,339
to occupy data storage it turns out that

00:07:57,979 --> 00:08:04,519
string literals like X Y Z Z Y here do

00:08:01,339 --> 00:08:06,679
have to occupy storage because these

00:08:04,519 --> 00:08:08,179
things have to behave like arrays you

00:08:06,679 --> 00:08:10,489
need to be able to step through them

00:08:08,179 --> 00:08:12,769
with a pointer and in order to do that

00:08:10,489 --> 00:08:17,989
the thing has to live in a will to find

00:08:12,769 --> 00:08:20,389
location in memory so L values can

00:08:17,989 --> 00:08:22,610
appear on either side of an assignment

00:08:20,389 --> 00:08:25,099
statement as we know the thing on the

00:08:22,610 --> 00:08:27,439
right doesn't have to be a literal value

00:08:25,099 --> 00:08:31,759
or something like that it can also be an

00:08:27,439 --> 00:08:36,649
object that we are assigning from and in

00:08:31,759 --> 00:08:39,889
this case we're using the value n as an

00:08:36,649 --> 00:08:41,930
R value we're assigning from it and the

00:08:39,889 --> 00:08:45,220
language refers to this under a special

00:08:41,930 --> 00:08:48,379
term l value to our a value conversion

00:08:45,220 --> 00:08:52,579
which is sort of a the standards way of

00:08:48,379 --> 00:08:56,059
saying that we are we're taking we're

00:08:52,579 --> 00:08:58,459
reading the value from n when we care

00:08:56,059 --> 00:09:00,290
about something being an L value we care

00:08:58,459 --> 00:09:02,540
about where that value will

00:09:00,290 --> 00:09:04,999
when we care about something being an

00:09:02,540 --> 00:09:11,299
r-value we care about what value it

00:09:04,999 --> 00:09:13,579
holds so the concepts l value and our

00:09:11,299 --> 00:09:16,009
value come from assignment expressions

00:09:13,579 --> 00:09:18,979
but they apply in lots of other

00:09:16,009 --> 00:09:23,269
expressions as well so for example let's

00:09:18,979 --> 00:09:25,279
look at the plus operator by the way L

00:09:23,269 --> 00:09:26,829
values and our values are one sort of

00:09:25,279 --> 00:09:28,970
restriction that can be applied to

00:09:26,829 --> 00:09:31,160
operators like this but there are others

00:09:28,970 --> 00:09:35,439
the things being added have to have

00:09:31,160 --> 00:09:39,109
types that are compatible for example so

00:09:35,439 --> 00:09:41,689
the operands of the plus operator can be

00:09:39,109 --> 00:09:45,169
either L values or our values in either

00:09:41,689 --> 00:09:49,970
order whether I add X plus 2 or 2 plus X

00:09:45,169 --> 00:09:53,600
doesn't matter on the other hand what

00:09:49,970 --> 00:09:58,339
about the return value where does the

00:09:53,600 --> 00:10:01,479
result M + n go it doesn't go in M it

00:09:58,339 --> 00:10:04,899
doesn't go in n it goes into a temporary

00:10:01,479 --> 00:10:07,959
location maybe a CPU register and that

00:10:04,899 --> 00:10:10,850
sort of temporary object is an R value

00:10:07,959 --> 00:10:13,910
it's not guaranteed to have memory

00:10:10,850 --> 00:10:16,489
storage associated with it and so as

00:10:13,910 --> 00:10:19,189
such just like you can't assign to the

00:10:16,489 --> 00:10:22,039
literal one you also can't assign to the

00:10:19,189 --> 00:10:25,369
result of M plus 1 because that's an R

00:10:22,039 --> 00:10:31,279
value there's nowhere for the assignment

00:10:25,369 --> 00:10:33,470
to assign to so another operator that

00:10:31,279 --> 00:10:38,480
we'll look at is the unary star operator

00:10:33,470 --> 00:10:42,529
so unary star yields an L value when we

00:10:38,480 --> 00:10:43,730
dereference a pointer star P is an L

00:10:42,529 --> 00:10:45,889
value it's something that can be

00:10:43,730 --> 00:10:47,869
assigned to so here we have an example

00:10:45,889 --> 00:10:49,639
we have an array of integers we have a

00:10:47,869 --> 00:10:52,069
pointer pointing to one of the elements

00:10:49,639 --> 00:10:56,199
in that array we also have a character

00:10:52,069 --> 00:10:59,959
pointer that's initialized to null so

00:10:56,199 --> 00:11:04,189
that assignment there star P equals 3 is

00:10:59,959 --> 00:11:06,529
valid because stars star P is an L value

00:11:04,189 --> 00:11:10,309
it lives at a particular location in

00:11:06,529 --> 00:11:13,189
memory star s is actually also an L

00:11:10,309 --> 00:11:14,030
value now I shouldn't do something like

00:11:13,189 --> 00:11:15,890
this where I

00:11:14,030 --> 00:11:18,800
sign of value to it because it's

00:11:15,890 --> 00:11:21,860
pointing to null and that would give me

00:11:18,800 --> 00:11:24,680
undefined behavior but from the

00:11:21,860 --> 00:11:27,670
compilers perspective l value ness is

00:11:24,680 --> 00:11:30,320
totally evaluated at compile time

00:11:27,670 --> 00:11:33,620
the assignment is problematic for other

00:11:30,320 --> 00:11:39,460
reasons but in terms of L value nice and

00:11:33,620 --> 00:11:42,740
our value Ness it's perfectly valid so

00:11:39,460 --> 00:11:44,600
here's how you think about data storage

00:11:42,740 --> 00:11:48,230
because when the optimizer gets involved

00:11:44,600 --> 00:11:51,230
things change a little bit when we think

00:11:48,230 --> 00:11:54,170
about our values we don't think about

00:11:51,230 --> 00:11:56,870
them as occupying data storage as it

00:11:54,170 --> 00:11:58,310
turns out some of them might I showed

00:11:56,870 --> 00:12:00,190
you that example of the immediate

00:11:58,310 --> 00:12:03,650
operands that are built into

00:12:00,190 --> 00:12:06,710
instructions earlier that worked well

00:12:03,650 --> 00:12:08,960
because I was using a small operand one

00:12:06,710 --> 00:12:11,660
but there's only a limited amount of

00:12:08,960 --> 00:12:14,840
space in the instructions that can be

00:12:11,660 --> 00:12:18,440
given over to these immediate operands

00:12:14,840 --> 00:12:20,500
so if I had a very large value like 1

00:12:18,440 --> 00:12:23,450
billion that I was trying to assign that

00:12:20,500 --> 00:12:25,340
might not fit in that space and in that

00:12:23,450 --> 00:12:27,620
situation the compiler might fall back

00:12:25,340 --> 00:12:32,150
on giving that about that r-value

00:12:27,620 --> 00:12:35,300
storage in memory so it turns out some R

00:12:32,150 --> 00:12:38,900
values might be in memory but you're

00:12:35,300 --> 00:12:41,450
required to program as if they don't the

00:12:38,900 --> 00:12:45,860
compiler has to have the freedom to not

00:12:41,450 --> 00:12:48,590
put on our value in memory we think of L

00:12:45,860 --> 00:12:50,840
values as occupying data storage now

00:12:48,590 --> 00:12:53,830
once the optimizer gets involved it

00:12:50,840 --> 00:12:56,960
might optimize away some of that storage

00:12:53,830 --> 00:12:59,720
but it will only do that when you won't

00:12:56,960 --> 00:13:02,450
notice so you as the programmer are

00:12:59,720 --> 00:13:06,050
always allowed to program as if an L

00:13:02,450 --> 00:13:07,730
value has a location in memory and then

00:13:06,050 --> 00:13:09,650
the optimizer might just come along and

00:13:07,730 --> 00:13:14,360
make things a little bit faster or more

00:13:09,650 --> 00:13:18,620
space efficient now on the other hand

00:13:14,360 --> 00:13:20,990
our values of class types we do think of

00:13:18,620 --> 00:13:24,110
those as occupying data storage so why

00:13:20,990 --> 00:13:26,720
do those have to be different well let's

00:13:24,110 --> 00:13:28,790
take a look at this example where

00:13:26,720 --> 00:13:32,240
and we have a struct that's made up of

00:13:28,790 --> 00:13:34,190
two integers x and y by the way when we

00:13:32,240 --> 00:13:37,009
talk about the standard refers to

00:13:34,190 --> 00:13:38,720
objects of class types and when it talks

00:13:37,009 --> 00:13:42,410
about a class type it means anything

00:13:38,720 --> 00:13:46,240
that the class a struct for a union so

00:13:42,410 --> 00:13:49,269
here we have an object of type s s1

00:13:46,240 --> 00:13:51,980
initialized with the values one and four

00:13:49,269 --> 00:13:54,860
so what would it look like when the

00:13:51,980 --> 00:13:58,819
compiler generates code to read from the

00:13:54,860 --> 00:14:04,819
Y data member of that object when in

00:13:58,819 --> 00:14:06,620
this case s1 is an L value of type s it

00:14:04,819 --> 00:14:09,649
depends on how it's being used in the

00:14:06,620 --> 00:14:13,100
expression and s we don't say that s1 is

00:14:09,649 --> 00:14:15,620
an L value we say that when it's used in

00:14:13,100 --> 00:14:21,050
this expression it's being used as an L

00:14:15,620 --> 00:14:22,610
it's it is an L value so this assembly

00:14:21,050 --> 00:14:25,689
code is a little bit more complicated

00:14:22,610 --> 00:14:31,339
but what I want you to notice here is

00:14:25,689 --> 00:14:35,000
that it the process of reading the Y

00:14:31,339 --> 00:14:37,850
data member it happens in two steps the

00:14:35,000 --> 00:14:41,060
first one is that it looks happy is that

00:14:37,850 --> 00:14:44,509
it takes the address of the s-1 object

00:14:41,060 --> 00:14:48,380
here and places that into a register and

00:14:44,509 --> 00:14:52,790
then it uses that register as the base

00:14:48,380 --> 00:14:56,750
address of the s-1 object and performs a

00:14:52,790 --> 00:14:59,180
calculation using that base address to

00:14:56,750 --> 00:15:01,970
find the Y data member and then it reads

00:14:59,180 --> 00:15:05,120
from that location into another register

00:15:01,970 --> 00:15:06,740
r2 and then once it has that value then

00:15:05,120 --> 00:15:11,029
it can go ahead and store that value

00:15:06,740 --> 00:15:13,759
into the location designated by I so

00:15:11,029 --> 00:15:15,559
there's this calculation going involved

00:15:13,759 --> 00:15:17,839
that involves going on that involves a

00:15:15,559 --> 00:15:20,750
base address so what would it look like

00:15:17,839 --> 00:15:23,300
if we were dealing with an R value of

00:15:20,750 --> 00:15:27,680
type s like the return value of this

00:15:23,300 --> 00:15:29,509
function foo here so in this case the

00:15:27,680 --> 00:15:32,569
compiler still needs to go through a

00:15:29,509 --> 00:15:36,410
similar process to access the data

00:15:32,569 --> 00:15:38,569
member Y of that return value which

00:15:36,410 --> 00:15:40,649
means that if it's going to perform that

00:15:38,569 --> 00:15:43,860
base plus offset how

00:15:40,649 --> 00:15:47,699
halation to get it why the return value

00:15:43,860 --> 00:15:49,680
of foo has to have a base address when

00:15:47,699 --> 00:15:52,680
something has a base address it occupies

00:15:49,680 --> 00:15:56,009
a location in memory we think of it as

00:15:52,680 --> 00:15:58,319
occupying storage this is why our values

00:15:56,009 --> 00:16:01,679
of class types need to be treated a

00:15:58,319 --> 00:16:04,290
little bit differently we'll refine this

00:16:01,679 --> 00:16:09,959
picture a little bit as we go on but

00:16:04,290 --> 00:16:13,709
this is just the first approximation so

00:16:09,959 --> 00:16:15,959
it turns out there are L values that

00:16:13,709 --> 00:16:17,759
actually can't appear on the left hand

00:16:15,959 --> 00:16:20,879
side of an assignment statement this is

00:16:17,759 --> 00:16:24,240
one of the cases where once C++ got

00:16:20,879 --> 00:16:27,240
involved those concepts became more

00:16:24,240 --> 00:16:31,769
complicated because in C++ we can have

00:16:27,240 --> 00:16:34,110
constants like this array name here so

00:16:31,769 --> 00:16:37,649
if I try and assign to it into one of

00:16:34,110 --> 00:16:41,100
the elements of name the elements of a

00:16:37,649 --> 00:16:45,029
constant are themselves Const I can't do

00:16:41,100 --> 00:16:46,079
that because it's a Const object it

00:16:45,029 --> 00:16:49,379
can't be modified

00:16:46,079 --> 00:16:52,620
it still has a location in memory it's

00:16:49,379 --> 00:16:55,889
an L value but it's a non-modifiable l

00:16:52,620 --> 00:16:57,949
value and this term is actually used in

00:16:55,889 --> 00:17:01,860
the standard I didn't just make that up

00:16:57,949 --> 00:17:04,649
so this distinction between L values

00:17:01,860 --> 00:17:07,380
non-modifiable l values and our values

00:17:04,649 --> 00:17:09,990
helps to give us a vocabulary for

00:17:07,380 --> 00:17:13,860
explaining certain differences in the

00:17:09,990 --> 00:17:16,890
language so for example here I have an

00:17:13,860 --> 00:17:20,909
enumeration constant called max time I

00:17:16,890 --> 00:17:24,149
have a single enumeration unnamed that

00:17:20,909 --> 00:17:26,429
contains a single value called max that

00:17:24,149 --> 00:17:32,010
I expect to use in expressions as a

00:17:26,429 --> 00:17:33,990
constant integer this value max when

00:17:32,010 --> 00:17:36,750
it's used in an expression it behaves

00:17:33,990 --> 00:17:39,450
like an order value so I can't assign to

00:17:36,750 --> 00:17:43,200
it like this I can't change the value of

00:17:39,450 --> 00:17:46,020
Max because Max is an r-value I also

00:17:43,200 --> 00:17:48,690
can't take its address I can't set up a

00:17:46,020 --> 00:17:52,409
pointer to point to the location where

00:17:48,690 --> 00:17:54,260
that value max lives because there isn't

00:17:52,409 --> 00:17:58,880
necessarily a location that does that

00:17:54,260 --> 00:18:02,360
it's an r-value but if I make max a

00:17:58,880 --> 00:18:05,000
constant integer object like this then

00:18:02,360 --> 00:18:08,120
it becomes a non modifiable L value

00:18:05,000 --> 00:18:09,530
I still can't assign to it because it's

00:18:08,120 --> 00:18:13,190
not the kind of thing we can have its

00:18:09,530 --> 00:18:15,350
value changed but I am allowed to take

00:18:13,190 --> 00:18:18,170
its address I can set up a pointer that

00:18:15,350 --> 00:18:23,060
points to the location at which max

00:18:18,170 --> 00:18:27,170
lives in order to pass that or that

00:18:23,060 --> 00:18:28,850
pointer around max is an L value here so

00:18:27,170 --> 00:18:30,950
here's the this table gives you the

00:18:28,850 --> 00:18:34,220
summary l values are both addressable

00:18:30,950 --> 00:18:37,610
and assignable non-modifiable l values

00:18:34,220 --> 00:18:40,670
are addressable but not assignable class

00:18:37,610 --> 00:18:43,670
or non class or values are not

00:18:40,670 --> 00:18:45,050
addressable and not assignable again

00:18:43,670 --> 00:18:51,830
it's a little bit more complicated for

00:18:45,050 --> 00:18:54,380
class R values as I explained so when we

00:18:51,830 --> 00:18:56,860
think about these B this distinction

00:18:54,380 --> 00:19:02,060
helps us explain the behaviors of

00:18:56,860 --> 00:19:04,670
references so for anyone not aware

00:19:02,060 --> 00:19:08,570
references behave very much like

00:19:04,670 --> 00:19:11,780
pointers in C++ when I create a

00:19:08,570 --> 00:19:16,700
reference a reference to an end RI here

00:19:11,780 --> 00:19:20,030
and I bind it to an end on that

00:19:16,700 --> 00:19:23,990
essentially sets up RI as an alias for I

00:19:20,030 --> 00:19:28,070
at that point any time I go on to use RI

00:19:23,990 --> 00:19:35,170
in an expression after that the the code

00:19:28,070 --> 00:19:37,520
behaves as if I had written I instead so

00:19:35,170 --> 00:19:40,520
references the standard takes great

00:19:37,520 --> 00:19:42,350
pains to say that references and

00:19:40,520 --> 00:19:44,980
pointers are different things they're

00:19:42,350 --> 00:19:47,270
not necessarily implemented the same way

00:19:44,980 --> 00:19:49,580
but in practice you can you almost

00:19:47,270 --> 00:19:53,750
always think of them as being the same

00:19:49,580 --> 00:19:56,270
moment and a lot of code that you that

00:19:53,750 --> 00:19:59,780
uses references could also be rewritten

00:19:56,270 --> 00:20:03,140
to use a constant pointer instead not a

00:19:59,780 --> 00:20:04,400
not a pointer to Const not something

00:20:03,140 --> 00:20:07,370
that points to something that can't be

00:20:04,400 --> 00:20:11,150
modified but a pointer that itself can't

00:20:07,370 --> 00:20:13,370
to point to anything else because just

00:20:11,150 --> 00:20:17,150
like because a reference once it's bound

00:20:13,370 --> 00:20:17,330
to a value like I it is always bound to

00:20:17,150 --> 00:20:20,150
I

00:20:17,330 --> 00:20:22,400
there's no way to rebind it to something

00:20:20,150 --> 00:20:24,410
else so the closest analogy with

00:20:22,400 --> 00:20:26,930
pointers is a constant pointer that

00:20:24,410 --> 00:20:28,400
always points to the same thing and then

00:20:26,930 --> 00:20:31,820
anywhere that we would have used our eye

00:20:28,400 --> 00:20:36,280
with a reference we can use star CPI as

00:20:31,820 --> 00:20:40,190
a pointer and so just like star CPI

00:20:36,280 --> 00:20:43,550
yielded an l-value references are also L

00:20:40,190 --> 00:20:45,350
values so why does why did the language

00:20:43,550 --> 00:20:49,010
choose to introduce references if they

00:20:45,350 --> 00:20:52,130
complicated things like this the real

00:20:49,010 --> 00:20:55,760
reason that references are in C++ is to

00:20:52,130 --> 00:20:57,380
make overloaded operators work the way

00:20:55,760 --> 00:21:00,550
that you would like one of the design

00:20:57,380 --> 00:21:04,250
philosophies in C and C++ is that

00:21:00,550 --> 00:21:07,700
built-in types and class types should

00:21:04,250 --> 00:21:10,070
behave very much the same you should be

00:21:07,700 --> 00:21:13,910
able to write a class type that looks

00:21:10,070 --> 00:21:15,980
like a built-in type and if we don't

00:21:13,910 --> 00:21:18,410
have references it's really hard to

00:21:15,980 --> 00:21:21,440
write overloaded operators that give us

00:21:18,410 --> 00:21:24,050
that behavior so here is an example we

00:21:21,440 --> 00:21:26,840
have an enumeration type month that

00:21:24,050 --> 00:21:31,900
represents the different months in the

00:21:26,840 --> 00:21:33,620
year in see in the original C

00:21:31,900 --> 00:21:35,750
enumerations were basically just

00:21:33,620 --> 00:21:38,780
integers they were it was a paper thin

00:21:35,750 --> 00:21:40,520
disguise over an int so I would have

00:21:38,780 --> 00:21:43,370
been allowed to write code like this

00:21:40,520 --> 00:21:49,010
where I loop through all of the months

00:21:43,370 --> 00:21:52,460
and I using a variable of type m and I

00:21:49,010 --> 00:21:56,059
you do plus plus M that compiles and

00:21:52,460 --> 00:21:58,070
runs in C it doesn't work in C++ because

00:21:56,059 --> 00:22:01,820
enumerations are treated more like

00:21:58,070 --> 00:22:04,400
distinct types in C++ so if I want to

00:22:01,820 --> 00:22:07,730
make this work I would need to overload

00:22:04,400 --> 00:22:10,400
the plus plus operator for month so

00:22:07,730 --> 00:22:12,920
let's try and do that without references

00:22:10,400 --> 00:22:17,060
and I hope you'll see why references are

00:22:12,920 --> 00:22:20,060
so important so here we're writing the

00:22:17,060 --> 00:22:20,930
plus plus operator as passed by value we

00:22:20,060 --> 00:22:23,330
just pass in the

00:22:20,930 --> 00:22:25,880
you of a month we go ahead and add one

00:22:23,330 --> 00:22:29,410
to that month value we have to use a

00:22:25,880 --> 00:22:33,440
static past to turn it into an integer

00:22:29,410 --> 00:22:35,150
or we need it will convert to an integer

00:22:33,440 --> 00:22:37,580
automatically but then we need to

00:22:35,150 --> 00:22:41,120
convert it back into month to update the

00:22:37,580 --> 00:22:43,040
value of X except that updating the

00:22:41,120 --> 00:22:46,700
value of X doesn't really do what we

00:22:43,040 --> 00:22:49,280
want it because I can write plus plus M

00:22:46,700 --> 00:22:54,050
but it doesn't actually change the value

00:22:49,280 --> 00:22:57,650
in M M was passed to X by value so X

00:22:54,050 --> 00:22:59,060
gets incremented but M doesn't so this

00:22:57,650 --> 00:23:04,190
doesn't give us the behavior that we

00:22:59,060 --> 00:23:05,720
want even worse because it's in this

00:23:04,190 --> 00:23:08,960
situation I'd be allowed to apply the

00:23:05,720 --> 00:23:12,830
plus plus operator to an hour value like

00:23:08,960 --> 00:23:14,450
the April value here that's not

00:23:12,830 --> 00:23:17,000
something you can do with the built-in

00:23:14,450 --> 00:23:19,160
operators if you have an hour value of

00:23:17,000 --> 00:23:24,680
type int like 42 you're not allowed to

00:23:19,160 --> 00:23:26,720
apply the plus plus to it so okay we

00:23:24,680 --> 00:23:31,520
passed by now you didn't work let's try

00:23:26,720 --> 00:23:33,980
pass by pointer instead so here we would

00:23:31,520 --> 00:23:38,180
be taking the value the month that we

00:23:33,980 --> 00:23:39,920
want to point to in by pointer turns out

00:23:38,180 --> 00:23:43,010
you can't even write this it just

00:23:39,920 --> 00:23:46,250
doesn't compile overloaded operators in

00:23:43,010 --> 00:23:48,920
C++ can't have parameters of pointer

00:23:46,250 --> 00:23:52,070
types but let's suppose it did compile

00:23:48,920 --> 00:23:53,990
for a moment it still wouldn't look the

00:23:52,070 --> 00:23:56,860
way that we want it to look it doesn't

00:23:53,990 --> 00:23:59,810
behave like the built-in types because

00:23:56,860 --> 00:24:01,580
plus plus M isn't what you would write

00:23:59,810 --> 00:24:03,940
the thing that you would have to pass

00:24:01,580 --> 00:24:08,420
off as the argument to this function

00:24:03,940 --> 00:24:11,480
would be the address of M so whereas you

00:24:08,420 --> 00:24:12,980
would write plus plus I to increment an

00:24:11,480 --> 00:24:16,250
int you'd have to write plus plus

00:24:12,980 --> 00:24:19,250
ampersand m to increment a month and

00:24:16,250 --> 00:24:21,230
that just ruins the whole thing it

00:24:19,250 --> 00:24:24,320
destroys the illusion that we're trying

00:24:21,230 --> 00:24:28,730
to create that built-in types and class

00:24:24,320 --> 00:24:31,910
and user-defined types like month behave

00:24:28,730 --> 00:24:34,040
the same way so we really need a

00:24:31,910 --> 00:24:34,759
references in this case we need

00:24:34,040 --> 00:24:37,309
something that

00:24:34,759 --> 00:24:39,320
Caves like a pointer but doesn't force

00:24:37,309 --> 00:24:42,739
us to take the address of the thing when

00:24:39,320 --> 00:24:45,289
we're passing it in so here we passing

00:24:42,739 --> 00:24:48,079
the value of the of the month by

00:24:45,289 --> 00:24:51,949
reference we can update the value inside

00:24:48,079 --> 00:24:54,469
there and now as a result + + M actually

00:24:51,949 --> 00:24:55,729
changes the value that it's apply the

00:24:54,469 --> 00:24:59,419
value of the argument that it's applied

00:24:55,729 --> 00:25:02,659
to it works the way that we want and as

00:24:59,419 --> 00:25:06,289
a bonus plus plus in this case will only

00:25:02,659 --> 00:25:09,589
work on L values references won't bind

00:25:06,289 --> 00:25:11,629
to our values because our values don't

00:25:09,589 --> 00:25:15,229
have a well-defined location in memory

00:25:11,629 --> 00:25:19,339
there's not necessarily a place where

00:25:15,229 --> 00:25:24,349
April lives that we can update its value

00:25:19,339 --> 00:25:26,479
this way yeah by the way if I were

00:25:24,349 --> 00:25:29,089
really writing a + + operator it doesn't

00:25:26,479 --> 00:25:31,190
return void it returns a reference to

00:25:29,089 --> 00:25:33,319
the thing that's incremented I didn't

00:25:31,190 --> 00:25:35,209
want to distract the discussion before

00:25:33,319 --> 00:25:39,259
this point with that but this is what it

00:25:35,209 --> 00:25:41,779
really looked like ok so we can also

00:25:39,259 --> 00:25:47,629
have parameters that are referenced to

00:25:41,779 --> 00:25:50,179
Const and references to cost will bind

00:25:47,629 --> 00:25:53,569
to objects that are either Const or non

00:25:50,179 --> 00:25:58,609
cost references to non Const objects

00:25:53,569 --> 00:26:03,949
will only bind to modifiable objects non

00:25:58,609 --> 00:26:07,159
constant Jax so so in this case this

00:26:03,949 --> 00:26:12,849
function would accept any T object

00:26:07,159 --> 00:26:17,599
whether it was constant or non constant

00:26:12,849 --> 00:26:19,219
inside the function f it would be it

00:26:17,599 --> 00:26:21,199
would be a reference to Const and it

00:26:19,219 --> 00:26:24,769
would behave like a non-modifiable l

00:26:21,199 --> 00:26:28,759
value something that has an address but

00:26:24,769 --> 00:26:32,059
I can't change the value there so this

00:26:28,759 --> 00:26:35,209
function winds up behaving very much as

00:26:32,059 --> 00:26:38,119
if I had written the same function using

00:26:35,209 --> 00:26:42,559
passed by value instead in the sense

00:26:38,119 --> 00:26:44,809
that if I use if I write F and I whether

00:26:42,559 --> 00:26:48,440
I'm passing by a value or by reference

00:26:44,809 --> 00:26:51,380
to Const I know that the call to F isn't

00:26:48,440 --> 00:26:55,190
going to change the value of x because

00:26:51,380 --> 00:26:57,410
if I pass by value the the function only

00:26:55,190 --> 00:27:02,480
sees a copy of X it doesn't see the

00:26:57,410 --> 00:27:04,970
value of X itself you can't change X if

00:27:02,480 --> 00:27:08,890
I pass by reference to Const the

00:27:04,970 --> 00:27:12,590
function sees a non-modifiable l value

00:27:08,890 --> 00:27:14,810
of type reference that is bound to X it

00:27:12,590 --> 00:27:19,130
can't change X because X is treated as

00:27:14,810 --> 00:27:20,870
Const in that situation so why would I

00:27:19,130 --> 00:27:23,180
want to make a distinct what I want to

00:27:20,870 --> 00:27:26,030
do these things pass by reference the

00:27:23,180 --> 00:27:27,650
cons instead of pass by value passing by

00:27:26,030 --> 00:27:31,840
reference to Const might be more

00:27:27,650 --> 00:27:34,700
efficient making a copy of a value is

00:27:31,840 --> 00:27:36,620
required when you pass by value if

00:27:34,700 --> 00:27:39,260
you're talking about a class type that's

00:27:36,620 --> 00:27:42,980
very large that copy could be a very

00:27:39,260 --> 00:27:46,100
expensive thing to do whereas binding a

00:27:42,980 --> 00:27:48,680
reference to something is very cheap and

00:27:46,100 --> 00:27:54,140
the cost doesn't go up as the object

00:27:48,680 --> 00:27:57,080
gets bigger so as I mentioned before a

00:27:54,140 --> 00:28:00,980
pointer to a tee object can only point

00:27:57,080 --> 00:28:04,010
to an L value of type T and in the same

00:28:00,980 --> 00:28:08,960
way a reference to non cons T will only

00:28:04,010 --> 00:28:12,410
bind to an L value of type T so I can't

00:28:08,960 --> 00:28:14,570
take the address of 3 and assign it to a

00:28:12,410 --> 00:28:17,240
pointer to an integer and in the same

00:28:14,570 --> 00:28:20,690
way I can't bind a reference to an

00:28:17,240 --> 00:28:23,150
integer to the literal three those both

00:28:20,690 --> 00:28:26,630
neither of those works because three is

00:28:23,150 --> 00:28:31,490
an r-value for the same reason I can't

00:28:26,630 --> 00:28:34,130
make I can't set up a pointer to to an

00:28:31,490 --> 00:28:36,050
object that isn't of the right type for

00:28:34,130 --> 00:28:38,330
the pointer to point to so I can't make

00:28:36,050 --> 00:28:40,850
a pointer to a double that actually

00:28:38,330 --> 00:28:43,340
points to an integer even though I is an

00:28:40,850 --> 00:28:47,990
ml value here it's an it's an L value of

00:28:43,340 --> 00:28:50,060
the wrong type so I can't take the

00:28:47,990 --> 00:28:52,580
address of I and put it in a pointer I

00:28:50,060 --> 00:28:57,200
also can't bind a reference to a double

00:28:52,580 --> 00:28:59,030
to I because I as a vid is an int well

00:28:57,200 --> 00:29:01,779
sort of there's an exception to that

00:28:59,030 --> 00:29:04,779
rule when we get into reference

00:29:01,779 --> 00:29:08,109
two constant objects it turns out that a

00:29:04,779 --> 00:29:11,409
reference to a compte can bind to an

00:29:08,109 --> 00:29:15,210
expression X that's not an L value of

00:29:11,409 --> 00:29:20,320
type t as long as there's a conversion

00:29:15,210 --> 00:29:24,009
from whatever type x has into the type t

00:29:20,320 --> 00:29:26,559
that the reference wants to bind to the

00:29:24,009 --> 00:29:30,669
way that this works is that the compiler

00:29:26,559 --> 00:29:34,989
creates a temporary object that holds

00:29:30,669 --> 00:29:37,869
the value of X converted into a T object

00:29:34,989 --> 00:29:40,659
and that temporary object that was

00:29:37,869 --> 00:29:44,649
created that's what the reference winds

00:29:40,659 --> 00:29:47,019
up being bound to that temporary object

00:29:44,649 --> 00:29:49,809
has some sort of location in memory that

00:29:47,019 --> 00:29:52,059
there but the reference can refer to so

00:29:49,809 --> 00:29:55,089
here's an example I'm allowed to write a

00:29:52,059 --> 00:29:57,940
reference to a constant double Rd and

00:29:55,089 --> 00:30:01,299
bind that to a3 and the way that it

00:29:57,940 --> 00:30:03,429
would work is three is of type end so

00:30:01,299 --> 00:30:07,049
the compiler would first convert that

00:30:03,429 --> 00:30:11,379
three into a double with the same value

00:30:07,049 --> 00:30:14,169
it would put that converted value into a

00:30:11,379 --> 00:30:16,149
temporary object of type double that

00:30:14,169 --> 00:30:19,089
holds the result of that conversion and

00:30:16,149 --> 00:30:22,719
then it would bind Rd to that temporary

00:30:19,089 --> 00:30:26,409
object that temporary object would last

00:30:22,719 --> 00:30:29,200
as long as the reference Rd lasts when

00:30:26,409 --> 00:30:35,589
Rd is destroyed the temporary is also

00:30:29,200 --> 00:30:37,029
destroyed so why is this so spec but why

00:30:35,589 --> 00:30:39,309
do things in this special way

00:30:37,029 --> 00:30:41,799
why does reference the Const have to

00:30:39,309 --> 00:30:44,529
behave this way and it's done

00:30:41,799 --> 00:30:47,889
so that passed by reference to Const is

00:30:44,529 --> 00:30:50,289
a viable replacement for passed by value

00:30:47,889 --> 00:30:53,249
we want to be able to pass by reference

00:30:50,289 --> 00:30:57,039
to Const instead of passing by a value

00:30:53,249 --> 00:31:00,820
because it might be cheaper than passing

00:30:57,039 --> 00:31:03,269
by value but think about what happens if

00:31:00,820 --> 00:31:06,700
I pass by value so here I have a

00:31:03,269 --> 00:31:10,960
function f that takes a long double by

00:31:06,700 --> 00:31:14,920
value I can pass it out a long double

00:31:10,960 --> 00:31:18,010
value like X there in which case

00:31:14,920 --> 00:31:22,480
we just generate a copy of X passed that

00:31:18,010 --> 00:31:25,660
off as the argument to the function on

00:31:22,480 --> 00:31:28,750
the other hand I can also pass in values

00:31:25,660 --> 00:31:32,740
that aren't long doubles like this

00:31:28,750 --> 00:31:35,380
integer one here one the literal one is

00:31:32,740 --> 00:31:37,090
of type int when the compiler generates

00:31:35,380 --> 00:31:40,240
the code for that it will convert the

00:31:37,090 --> 00:31:42,130
one into a long double and pass that as

00:31:40,240 --> 00:31:44,650
the argument to the function pass that

00:31:42,130 --> 00:31:47,740
converted value as the argument to the

00:31:44,650 --> 00:31:50,680
function so in order to make reference

00:31:47,740 --> 00:31:53,170
to Const work the same way it's

00:31:50,680 --> 00:31:55,900
important that I be able to pass not

00:31:53,170 --> 00:31:58,120
just a long double to a function that

00:31:55,900 --> 00:32:01,330
expects to take a reference to a

00:31:58,120 --> 00:32:04,390
constant long double but also something

00:32:01,330 --> 00:32:09,040
like an integer in this case an integer

00:32:04,390 --> 00:32:11,230
that is an hour value in which case we

00:32:09,040 --> 00:32:14,260
create this temporary object and bind

00:32:11,230 --> 00:32:16,720
the reference to that and then and it's

00:32:14,260 --> 00:32:19,150
perfectly safe to do that to bind the

00:32:16,720 --> 00:32:22,350
reference to that temporary because it's

00:32:19,150 --> 00:32:25,530
non-modifiable there's no danger that

00:32:22,350 --> 00:32:28,180
someone will call this function

00:32:25,530 --> 00:32:32,140
expecting to get back a modified version

00:32:28,180 --> 00:32:36,490
of one because the thing has to be

00:32:32,140 --> 00:32:38,140
treated as Const inside F so either way

00:32:36,490 --> 00:32:40,330
the function calls essentially had

00:32:38,140 --> 00:32:46,020
equivalent behavior from the callers

00:32:40,330 --> 00:32:48,880
perspective so I talked before about how

00:32:46,020 --> 00:32:51,070
normally we don't want we think of our

00:32:48,880 --> 00:32:54,670
values of built-in types as not

00:32:51,070 --> 00:32:58,840
occupying storage our values of class

00:32:54,670 --> 00:33:02,440
types do occupy storage this temporary

00:32:58,840 --> 00:33:06,220
object that we've just created as part

00:33:02,440 --> 00:33:09,520
of doing this reference binding that

00:33:06,220 --> 00:33:12,010
also occupies storage it has to because

00:33:09,520 --> 00:33:15,010
the reference has to have some a place

00:33:12,010 --> 00:33:17,380
in memory to refer to and this works

00:33:15,010 --> 00:33:20,470
even for built-in types like long double

00:33:17,380 --> 00:33:22,020
it's not true just for class types so

00:33:20,470 --> 00:33:26,260
this is another way that you can have

00:33:22,020 --> 00:33:28,790
our values that have locations in memory

00:33:26,260 --> 00:33:30,770
that occupy data storage

00:33:28,790 --> 00:33:34,850
the way that class our values of class

00:33:30,770 --> 00:33:37,400
types do it turns out in modern C++

00:33:34,850 --> 00:33:40,580
there are two kinds of our values and

00:33:37,400 --> 00:33:44,540
they have special names there are pure

00:33:40,580 --> 00:33:47,150
Val our values or P our values which

00:33:44,540 --> 00:33:49,280
don't occupy data storage conceptually

00:33:47,150 --> 00:33:53,480
and then there are what are called

00:33:49,280 --> 00:33:56,510
expiring values or X values which do

00:33:53,480 --> 00:33:59,230
occupy data storage both of these are

00:33:56,510 --> 00:34:02,540
considered to be types of our values

00:33:59,230 --> 00:34:04,790
therein so when I refer to our values

00:34:02,540 --> 00:34:10,130
going forward I could be talking about

00:34:04,790 --> 00:34:12,919
either a P R value or an X value it

00:34:10,130 --> 00:34:15,409
turns out as the programmer you don't

00:34:12,919 --> 00:34:18,320
need to worry that much about the

00:34:15,409 --> 00:34:21,169
distinction of what an art or what an x

00:34:18,320 --> 00:34:24,169
value is it's mostly in the standard to

00:34:21,169 --> 00:34:27,350
describe the behavior of the language so

00:34:24,169 --> 00:34:29,720
that compiler authors know what needs to

00:34:27,350 --> 00:34:32,570
be done you as the programmer don't

00:34:29,720 --> 00:34:33,800
usually think in terms of X values but I

00:34:32,570 --> 00:34:36,830
wanted to make sure that you were aware

00:34:33,800 --> 00:34:37,940
that you were had some understanding of

00:34:36,830 --> 00:34:40,250
the term because I know that a lot of

00:34:37,940 --> 00:34:45,500
people are familiar with it but don't

00:34:40,250 --> 00:34:48,500
necessarily know what it means so when

00:34:45,500 --> 00:34:50,570
the temporary is created as part of

00:34:48,500 --> 00:34:54,980
binding this reference to a constant

00:34:50,570 --> 00:34:56,560
object to an R value it's created

00:34:54,980 --> 00:35:00,080
through what's called a temporary

00:34:56,560 --> 00:35:02,840
materialization conversion it's a

00:35:00,080 --> 00:35:05,560
conversion that turns a P R value that

00:35:02,840 --> 00:35:10,370
doesn't have a location into an x value

00:35:05,560 --> 00:35:14,240
that does have a location so that's

00:35:10,370 --> 00:35:16,280
what's going on there so suppose that I

00:35:14,240 --> 00:35:18,410
want let's revisit the idea of

00:35:16,280 --> 00:35:22,340
overloading operators and let's look at

00:35:18,410 --> 00:35:26,660
how would we create an overloaded plus

00:35:22,340 --> 00:35:28,810
operator for a string type that does

00:35:26,660 --> 00:35:32,840
that concatenates two strings together

00:35:28,810 --> 00:35:35,300
that behaves in a way that looks very

00:35:32,840 --> 00:35:37,430
much like the way that the built-in plus

00:35:35,300 --> 00:35:40,660
operator behaves for objects like

00:35:37,430 --> 00:35:43,540
integers so

00:35:40,660 --> 00:35:45,880
here's just a rudimentary version of the

00:35:43,540 --> 00:35:47,860
string class it has a copy constructor

00:35:45,880 --> 00:35:52,240
it has a converting constructor that

00:35:47,860 --> 00:35:54,640
allows us to treat string literals as as

00:35:52,240 --> 00:35:57,640
string objects and it also has an

00:35:54,640 --> 00:36:00,370
assignment operator a copy assignment

00:35:57,640 --> 00:36:02,290
operator to be specific and then we have

00:36:00,370 --> 00:36:06,280
our plus operator that will concatenate

00:36:02,290 --> 00:36:09,370
two strings together so the plus

00:36:06,280 --> 00:36:12,160
operator takes its arguments by

00:36:09,370 --> 00:36:15,550
reference to Const which means that they

00:36:12,160 --> 00:36:18,460
will bind to either L values or R values

00:36:15,550 --> 00:36:20,710
of the appropriate type which means that

00:36:18,460 --> 00:36:25,630
I can write something like this where I

00:36:20,710 --> 00:36:28,690
have two strings s and T and then I I

00:36:25,630 --> 00:36:33,300
can add those together so that I say s

00:36:28,690 --> 00:36:39,460
plus the string literal containing the

00:36:33,300 --> 00:36:41,380
comma plus T and the compiler will

00:36:39,460 --> 00:36:45,430
interpret it like this and we'll see

00:36:41,380 --> 00:36:48,160
that that string literal can be treated

00:36:45,430 --> 00:36:50,020
as a pointer to constant character we

00:36:48,160 --> 00:36:51,910
have a converting constructor from

00:36:50,020 --> 00:36:55,120
pointer to constant character into a

00:36:51,910 --> 00:36:57,160
string so it will first apply the

00:36:55,120 --> 00:37:00,880
converting constructor there so that we

00:36:57,160 --> 00:37:03,160
have all operands of type string in that

00:37:00,880 --> 00:37:05,020
case and the result of doing that

00:37:03,160 --> 00:37:07,360
conversion is that is that the string

00:37:05,020 --> 00:37:13,540
that's created is an r-value it's a

00:37:07,360 --> 00:37:18,310
temporary object and whereas SNP in this

00:37:13,540 --> 00:37:20,680
expression behave like L values on the

00:37:18,310 --> 00:37:23,770
other hand the function returns the

00:37:20,680 --> 00:37:26,500
result by value so the result of the

00:37:23,770 --> 00:37:28,810
func of calling that function is an

00:37:26,500 --> 00:37:31,510
r-value you can't take it address and

00:37:28,810 --> 00:37:34,560
set up a pointer that will point to it

00:37:31,510 --> 00:37:40,550
the way that you could for S or T

00:37:34,560 --> 00:37:43,430
individually so

00:37:40,550 --> 00:37:47,450
up until now I've been referring to just

00:37:43,430 --> 00:37:49,220
references that's the way that these

00:37:47,450 --> 00:37:52,400
things work that reference is referred

00:37:49,220 --> 00:37:55,790
to in C++ oh three all there were were

00:37:52,400 --> 00:37:58,100
references in C++ eleven and Beyond we

00:37:55,790 --> 00:38:01,460
now have two different kinds of

00:37:58,100 --> 00:38:04,220
references we have L value references

00:38:01,460 --> 00:38:08,510
which are the references that existed

00:38:04,220 --> 00:38:10,850
before in C++ oh three and we also now

00:38:08,510 --> 00:38:15,260
have our value references which are a

00:38:10,850 --> 00:38:18,050
new feature introduced in modern C++ so

00:38:15,260 --> 00:38:20,810
L value references behave the same way

00:38:18,050 --> 00:38:25,160
that that references did before our

00:38:20,810 --> 00:38:28,040
value references were introduced so l

00:38:25,160 --> 00:38:31,240
value references are declared with the

00:38:28,040 --> 00:38:34,700
single with a single ampersand operator

00:38:31,240 --> 00:38:38,720
our value references are declared with a

00:38:34,700 --> 00:38:44,050
double ampersand operator so here our

00:38:38,720 --> 00:38:47,240
eye is an R value reference to an int

00:38:44,050 --> 00:38:52,850
unsurprisingly an R value reference and

00:38:47,240 --> 00:38:56,090
bind to an R value like 10 there so you

00:38:52,850 --> 00:38:57,440
are value references can appear as in

00:38:56,090 --> 00:38:59,840
lots of different places but they're

00:38:57,440 --> 00:39:03,620
typically used as function parameters

00:38:59,840 --> 00:39:06,470
and function return pipes just like L

00:39:03,620 --> 00:39:09,410
value references are traditionally we

00:39:06,470 --> 00:39:12,200
usually don't create reference objects

00:39:09,410 --> 00:39:14,690
on the stack and pass them around where

00:39:12,200 --> 00:39:19,070
they're usually used as function

00:39:14,690 --> 00:39:21,740
parameters and return pipes and you can

00:39:19,070 --> 00:39:24,800
have our value references to Const like

00:39:21,740 --> 00:39:27,740
this it's usually not a particularly

00:39:24,800 --> 00:39:30,040
useful thing to do because as you'll see

00:39:27,740 --> 00:39:32,300
our value references are in the language

00:39:30,040 --> 00:39:35,840
to implement something called

00:39:32,300 --> 00:39:38,300
move semantics which usually expects the

00:39:35,840 --> 00:39:39,790
thing to be treated as mod the thing

00:39:38,300 --> 00:39:43,400
being referred to to be treated as

00:39:39,790 --> 00:39:46,280
modifiable and an R value to reference

00:39:43,400 --> 00:39:50,780
to comes refers to a non-modifiable

00:39:46,280 --> 00:39:53,390
object so our value references will only

00:39:50,780 --> 00:39:54,380
bind to our values even an R value

00:39:53,390 --> 00:39:57,800
reference

00:39:54,380 --> 00:40:00,920
const will not bind to an l-value it

00:39:57,800 --> 00:40:04,190
will only bind you to an r-value so here

00:40:00,920 --> 00:40:08,390
if i have an integer n initialized with

00:40:04,190 --> 00:40:11,690
the value 10 i can't bind on our value

00:40:08,390 --> 00:40:14,600
reference to n because n is an L value

00:40:11,690 --> 00:40:16,880
it's not an R value even if I'm trying

00:40:14,600 --> 00:40:20,770
to bind a reference to a an R value

00:40:16,880 --> 00:40:26,240
reference the cons to it it doesn't work

00:40:20,770 --> 00:40:28,960
when I bind the R value reference to an

00:40:26,240 --> 00:40:32,300
R value that triggers a temporary

00:40:28,960 --> 00:40:35,410
materialization conversion that thing

00:40:32,300 --> 00:40:38,990
that turns a PR value into an x value

00:40:35,410 --> 00:40:41,320
the same way that binding an L value

00:40:38,990 --> 00:40:44,120
reference to Const to an R value

00:40:41,320 --> 00:40:47,210
triggered a temporary materialization

00:40:44,120 --> 00:40:51,140
conversion similar behavior in both in

00:40:47,210 --> 00:40:55,210
both cases so as I mentioned r-value

00:40:51,140 --> 00:40:59,240
references are in the language to

00:40:55,210 --> 00:41:04,310
implement implement move semantics

00:40:59,240 --> 00:41:07,970
they provide a mechanism by which in

00:41:04,310 --> 00:41:11,000
some situations we don't want to copy an

00:41:07,970 --> 00:41:15,110
object it's cheaper if we can instead of

00:41:11,000 --> 00:41:17,480
leaving if we want to take the value

00:41:15,110 --> 00:41:20,210
from one object and put it into an into

00:41:17,480 --> 00:41:22,880
another object if we need to preserve

00:41:20,210 --> 00:41:25,490
the value in the original object then we

00:41:22,880 --> 00:41:29,180
need to make a complete copy of that

00:41:25,490 --> 00:41:31,790
object into the new object but if we

00:41:29,180 --> 00:41:34,820
don't care about preserving the value of

00:41:31,790 --> 00:41:37,990
the original object for example if it's

00:41:34,820 --> 00:41:41,270
only a temporary object like an R value

00:41:37,990 --> 00:41:44,240
then it's then we might be able to

00:41:41,270 --> 00:41:47,180
implement the transfer of value more

00:41:44,240 --> 00:41:50,210
efficiently by moving that value just

00:41:47,180 --> 00:41:52,910
stealing the contents of the thing that

00:41:50,210 --> 00:41:55,010
we're assigning from and placing them in

00:41:52,910 --> 00:41:59,120
the thing that we're assigning to that's

00:41:55,010 --> 00:42:01,430
a move operation so this is in this case

00:41:59,120 --> 00:42:04,550
the class string has both copy

00:42:01,430 --> 00:42:07,130
operations that take their parameters by

00:42:04,550 --> 00:42:09,320
reference to Const and

00:42:07,130 --> 00:42:11,600
move operations that take their

00:42:09,320 --> 00:42:12,350
parameters by r-value reference to non

00:42:11,600 --> 00:42:14,480
Const

00:42:12,350 --> 00:42:17,570
if they took them for the parameters by

00:42:14,480 --> 00:42:20,210
our value reference to Const they would

00:42:17,570 --> 00:42:21,410
still be binding to our values but those

00:42:20,210 --> 00:42:24,140
are values would be treated as

00:42:21,410 --> 00:42:27,110
non-modifiable and the purpose of being

00:42:24,140 --> 00:42:30,050
able to do a move operation is that we

00:42:27,110 --> 00:42:33,440
want to be able to destroy the thing

00:42:30,050 --> 00:42:35,480
that we are moving from because that

00:42:33,440 --> 00:42:37,130
might provide us with a more efficient

00:42:35,480 --> 00:42:40,910
way of getting the value that we want

00:42:37,130 --> 00:42:43,070
into the object that we want so here are

00:42:40,910 --> 00:42:48,320
some objects three objects of type

00:42:43,070 --> 00:42:54,010
string s1 s2 and s3 if I assign from s2

00:42:48,320 --> 00:42:57,440
to s1 that that performs copy assignment

00:42:54,010 --> 00:43:01,640
s2 in this expression designates an L

00:42:57,440 --> 00:43:04,310
value it it's not expiring so the value

00:43:01,640 --> 00:43:07,690
has to be preserved which means it has

00:43:04,310 --> 00:43:10,550
to be copied it can't be moved from on

00:43:07,690 --> 00:43:14,840
the other hand if I assign from an R

00:43:10,550 --> 00:43:16,580
value like s2 plus s3 the result of that

00:43:14,840 --> 00:43:20,350
plus operator as I showed you a moment

00:43:16,580 --> 00:43:24,230
ago that will perform move assignment

00:43:20,350 --> 00:43:27,290
it's safe to move from the result of s2

00:43:24,230 --> 00:43:30,200
plus s3 because that's a temporary

00:43:27,290 --> 00:43:32,900
object it's going to die as soon as we

00:43:30,200 --> 00:43:36,010
reach the end of that statement so it's

00:43:32,900 --> 00:43:43,790
perfectly safe to move the value out of

00:43:36,010 --> 00:43:46,250
s2 plus s 3 into s 1 because because s2

00:43:43,790 --> 00:43:48,800
plus s3 is going away it's sort of I

00:43:46,250 --> 00:43:51,530
like to think of this as C++ providing a

00:43:48,800 --> 00:43:57,970
way for s1 to say hey are you gonna eat

00:43:51,530 --> 00:43:57,970
that because if you're not I'll take it

00:43:58,000 --> 00:44:05,270
so when you bind an R value reference to

00:44:02,750 --> 00:44:07,820
an R value it performs one of those

00:44:05,270 --> 00:44:10,370
temporary materialization conversions

00:44:07,820 --> 00:44:13,670
it creates an X value and then an

00:44:10,370 --> 00:44:17,570
expiring value but let's look at the

00:44:13,670 --> 00:44:21,260
code inside the move assignment operator

00:44:17,570 --> 00:44:23,090
here that r-value references

00:44:21,260 --> 00:44:25,730
a parameter to the function called other

00:44:23,090 --> 00:44:29,030
there now let's suppose somewhere inside

00:44:25,730 --> 00:44:33,700
this operator I wanted to create a

00:44:29,030 --> 00:44:36,380
string temp using the value of other

00:44:33,700 --> 00:44:38,720
with this perform copy assignment and

00:44:36,380 --> 00:44:41,450
copy construction or move construction

00:44:38,720 --> 00:44:44,510
it turns out it performs copy

00:44:41,450 --> 00:44:47,750
construction it's not treated like an

00:44:44,510 --> 00:44:51,950
r-value that I could move from it's

00:44:47,750 --> 00:44:55,720
treated like an L value because from the

00:44:51,950 --> 00:44:59,000
perspective of the caller the r-value

00:44:55,720 --> 00:45:01,130
the thing behaved as an r-value it was

00:44:59,000 --> 00:45:04,160
about to die at the end of the statement

00:45:01,130 --> 00:45:07,160
it was safe to move from but inside the

00:45:04,160 --> 00:45:11,000
function this function could be hundreds

00:45:07,160 --> 00:45:14,270
of lines long I hope it isn't but it

00:45:11,000 --> 00:45:16,730
could be as long as I want so from the

00:45:14,270 --> 00:45:20,570
perspective of people inside this

00:45:16,730 --> 00:45:22,670
function the object other looks like it

00:45:20,570 --> 00:45:25,280
has a fairly long life it lives as long

00:45:22,670 --> 00:45:27,440
as the function does so it needs to be

00:45:25,280 --> 00:45:30,740
treated as something that doesn't expire

00:45:27,440 --> 00:45:33,020
like an L value and the general rule

00:45:30,740 --> 00:45:36,850
here is pretty simple if it has a name

00:45:33,020 --> 00:45:40,820
it's an L value it doesn't have a name

00:45:36,850 --> 00:45:44,150
it's an R value it might be an R value I

00:45:40,820 --> 00:45:46,040
should say not necessarily unnamed

00:45:44,150 --> 00:45:49,160
things aren't necessarily our values

00:45:46,040 --> 00:45:52,010
named things are are almost always L

00:45:49,160 --> 00:45:54,860
values so there are some situations

00:45:52,010 --> 00:45:58,790
though where it does make sense to move

00:45:54,860 --> 00:46:02,420
from an L value so here the most common

00:45:58,790 --> 00:46:05,690
example is swap here if I were to before

00:46:02,420 --> 00:46:07,910
the advent of our value references a

00:46:05,690 --> 00:46:11,270
swap function would typically be written

00:46:07,910 --> 00:46:15,400
something like this some I take in two

00:46:11,270 --> 00:46:18,890
values a and B I copy the value from a

00:46:15,400 --> 00:46:22,010
into a temporary location I over write a

00:46:18,890 --> 00:46:24,700
with B and then I copy the value that

00:46:22,010 --> 00:46:32,750
was in a now in the temporary location

00:46:24,700 --> 00:46:34,609
into B if I even if T has moved has a

00:46:32,750 --> 00:46:37,940
move constructor and a move assign

00:46:34,609 --> 00:46:40,460
and operator in this case but if it's

00:46:37,940 --> 00:46:44,869
written like this the compiler will

00:46:40,460 --> 00:46:47,539
generate code that performs copy

00:46:44,869 --> 00:46:52,239
construction and copy assignment in this

00:46:47,539 --> 00:46:54,829
case because the compiler doesn't see a

00:46:52,239 --> 00:46:58,119
just focus on the first case here where

00:46:54,829 --> 00:47:01,759
we're creating the object temp from a

00:46:58,119 --> 00:47:04,130
hey doesn't look like it's expiring to

00:47:01,759 --> 00:47:07,759
the compiler it lasts as long as the

00:47:04,130 --> 00:47:10,940
function does but as the programmer we

00:47:07,759 --> 00:47:13,460
can tell the very next line over writes

00:47:10,940 --> 00:47:16,190
the value of a there's no need to

00:47:13,460 --> 00:47:19,160
preserve it it would be safe to perform

00:47:16,190 --> 00:47:22,489
a destructive copy aka

00:47:19,160 --> 00:47:28,609
a move when we're creating from a to

00:47:22,489 --> 00:47:32,920
create temp so it's safe to move from an

00:47:28,609 --> 00:47:37,099
L value if it's expiring but the but the

00:47:32,920 --> 00:47:39,799
compiler can't always tell when an L

00:47:37,099 --> 00:47:42,319
value is about to expire in some cases

00:47:39,799 --> 00:47:44,690
the programmer has knowledge but the

00:47:42,319 --> 00:47:47,900
compiler can't real that the compiler

00:47:44,690 --> 00:47:49,759
can't easily discern so how can we tell

00:47:47,900 --> 00:47:54,589
the compiler that an L value is about to

00:47:49,759 --> 00:47:59,769
expire we need to convert it into an X

00:47:54,589 --> 00:48:01,759
value an expiring value in other

00:47:59,769 --> 00:48:05,930
specifically we need to convert it into

00:48:01,759 --> 00:48:08,059
an unnamed r value reference something

00:48:05,930 --> 00:48:10,880
that designates an object but it

00:48:08,059 --> 00:48:13,249
designates a temporary object that's

00:48:10,880 --> 00:48:16,099
about to expire and can be safely moved

00:48:13,249 --> 00:48:19,730
from and that's what the standard move

00:48:16,099 --> 00:48:24,680
function does here when I call move on

00:48:19,730 --> 00:48:28,339
an object that that perfective li

00:48:24,680 --> 00:48:31,910
performs a conversion from from from

00:48:28,339 --> 00:48:33,950
that object from L value into X value

00:48:31,910 --> 00:48:35,720
now what I'm showing you here is a

00:48:33,950 --> 00:48:37,880
somewhat simplified version of the

00:48:35,720 --> 00:48:39,890
function move if you go look at the way

00:48:37,880 --> 00:48:41,539
that it's defined in the standard it

00:48:39,890 --> 00:48:44,960
actually looks more complicated than

00:48:41,539 --> 00:48:48,140
this but I want you to focus on the fact

00:48:44,960 --> 00:48:52,010
that it returns an R value referenced

00:48:48,140 --> 00:48:54,680
to a tee return values don't have names

00:48:52,010 --> 00:49:01,040
so the result of a move is an unnamed

00:48:54,680 --> 00:49:03,110
r-value reference an X value again as a

00:49:01,040 --> 00:49:06,980
programmer we don't often think about X

00:49:03,110 --> 00:49:10,310
values because we're usually thinking

00:49:06,980 --> 00:49:14,060
about something as either a long-lived

00:49:10,310 --> 00:49:18,050
value like an L value or a short-lived

00:49:14,060 --> 00:49:20,510
value like an R value but but this term

00:49:18,050 --> 00:49:23,210
x value is mainly there for compiler

00:49:20,510 --> 00:49:26,890
writers to describe this slightly

00:49:23,210 --> 00:49:29,570
in-between state that objects can be in

00:49:26,890 --> 00:49:31,460
so the actual way that it's described in

00:49:29,570 --> 00:49:34,340
the standard looks like this is that

00:49:31,460 --> 00:49:37,040
there are expressions and expressions

00:49:34,340 --> 00:49:41,030
break down into two categories there are

00:49:37,040 --> 00:49:46,250
our value P values and generalized L

00:49:41,030 --> 00:49:47,990
values GL values and then what I've been

00:49:46,250 --> 00:49:51,080
called what I've usually been calling an

00:49:47,990 --> 00:49:56,720
L value up to this point is one kind of

00:49:51,080 --> 00:50:00,110
GL value an L value only behaves like an

00:49:56,720 --> 00:50:03,170
L value it has a location in memory a PR

00:50:00,110 --> 00:50:05,270
value a pure R value always behaves like

00:50:03,170 --> 00:50:07,670
an R value we have to treat it as if it

00:50:05,270 --> 00:50:11,720
doesn't have a location memory an x

00:50:07,670 --> 00:50:16,250
value behaves like both it behaves both

00:50:11,720 --> 00:50:18,680
like an L value and an R value and so

00:50:16,250 --> 00:50:23,570
that's what's going on in this picture

00:50:18,680 --> 00:50:27,560
that's the the final truth that the fix

00:50:23,570 --> 00:50:30,140
the past and 'red has at the moment that

00:50:27,560 --> 00:50:31,670
brings me to the end of the talk so I'm

00:50:30,140 --> 00:50:34,190
happy to take questions at this point

00:50:31,670 --> 00:50:36,450
but otherwise I hope you find it useful

00:50:34,190 --> 00:50:45,520
good luck in your programming

00:50:36,450 --> 00:50:45,520
[Applause]

00:50:57,430 --> 00:51:04,970
I'm sorry when did you know L values

00:51:00,020 --> 00:51:07,130
what implicit implicitly become X values

00:51:04,970 --> 00:51:09,140
what was that the question okay

00:51:07,130 --> 00:51:13,940
when did and when do L values implicitly

00:51:09,140 --> 00:51:16,640
become X values essentially in return

00:51:13,940 --> 00:51:18,860
statements it's a little bit estándar

00:51:16,640 --> 00:51:22,940
uses more complicated terminology than

00:51:18,860 --> 00:51:25,790
that but almost always when you think of

00:51:22,940 --> 00:51:28,580
an L value that B that is being

00:51:25,790 --> 00:51:31,670
converted into an X value and you don't

00:51:28,580 --> 00:51:34,810
need to explicitly move from it it's

00:51:31,670 --> 00:51:34,810
usually in a return statement

00:51:41,800 --> 00:51:56,050
yeah who do you want to use the

00:51:44,330 --> 00:51:59,840
microphone okay the question is is it

00:51:56,050 --> 00:52:02,270
was like her did I say that a string

00:51:59,840 --> 00:52:05,270
literal was an L value and did I really

00:52:02,270 --> 00:52:10,550
mean to say that yes I did

00:52:05,270 --> 00:52:14,030
the string literals have to have some

00:52:10,550 --> 00:52:17,150
location in memory because so a string

00:52:14,030 --> 00:52:21,020
literal is really an array underneath an

00:52:17,150 --> 00:52:23,330
array has to have elements laid out in

00:52:21,020 --> 00:52:25,790
memory in some kind of sequential order

00:52:23,330 --> 00:52:27,980
so that you can do things like step

00:52:25,790 --> 00:52:30,470
through it with a pointer like we often

00:52:27,980 --> 00:52:32,900
do with Springwood all literals say if

00:52:30,470 --> 00:52:41,330
you wanted to take the length of it with

00:52:32,900 --> 00:52:47,300
sterlin what says that you can't assign

00:52:41,330 --> 00:52:52,520
to to a string literal you can't really

00:52:47,300 --> 00:52:55,370
it's because we often think about string

00:52:52,520 --> 00:52:56,660
literals as being pointers to constant

00:52:55,370 --> 00:52:59,810
characters but that's not actually their

00:52:56,660 --> 00:53:03,650
real type their real type is array of

00:52:59,810 --> 00:53:06,950
constant characters and you can't assign

00:53:03,650 --> 00:53:10,579
to an array in as a

00:53:06,950 --> 00:53:13,190
in a blanket form so if you tried to put

00:53:10,579 --> 00:53:15,200
a string literal on the left hand side

00:53:13,190 --> 00:53:17,000
of an assignment statement you'd be

00:53:15,200 --> 00:53:20,380
assigning to a complete array and the

00:53:17,000 --> 00:53:20,380
language just doesn't let you do that

00:53:27,040 --> 00:53:33,530
okay I'm happy to if if you're if you

00:53:32,030 --> 00:53:35,599
don't want to use the microphone I'm

00:53:33,530 --> 00:53:38,089
happy to have you come up and ask me

00:53:35,599 --> 00:53:39,980
questions more individually as I said

00:53:38,089 --> 00:53:41,420
other what otherwise though as I said

00:53:39,980 --> 00:53:43,430
good luck in your coding endeavors

00:53:41,420 --> 00:53:44,400
endeavors and I hope you find this stuff

00:53:43,430 --> 00:53:49,010
useful

00:53:44,400 --> 00:53:49,010

YouTube URL: https://www.youtube.com/watch?v=XS2JddPq7GQ


